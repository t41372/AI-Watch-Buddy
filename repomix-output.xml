This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  instructions/
    adx.instructions.md
docs/
  api.md
src/
  ai_watch_buddy/
    prompt/
      action_gen.py
    action_generate.py
    ai_actions.py
    connection_manager.py
    pipeline.py
    server.py
    session.py
.gitignore
.python-version
action_list_result.json
main.py
pyproject.toml
schema.json
test_analyzer.py
video_analyzer.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="action_list_result.json">
[
  {
    "id": "0",
    "trigger_timestamp": 0.5,
    "comment": "å¼€åœºå°±çœ‹åˆ°ä¸€ä¸ªå¥‡æ€ªçš„ç”»é¢ï¼Œçº³é—·è¿™æ˜¯ä»€ä¹ˆæ“ä½œã€‚",
    "action_type": "SPEAK",
    "text": "å—¯ï¼ŸUCLAçš„è®¡ç®—æœºç¡•å£«ï¼Ÿè¿™æ€ä¹ˆä¸€ä¸Šæ¥å°±åœ¨ç«è½¦è¾¹ä¸Šå•Šï¼Ÿå¥½å±é™©ï¼"
  },
  {
    "id": "1",
    "trigger_timestamp": 2.5,
    "comment": "çœ‹åˆ°æ”€çˆ¬çš„ç”»é¢ï¼Œæ„Ÿåˆ°éœ‡æƒŠã€‚",
    "action_type": "SPEAK",
    "text": "å“¦ï¼Œè¿™ä¸ªè§’åº¦è¿˜è›®ç‰¹åˆ«çš„ã€‚ç­‰ç­‰ï¼Œä»–åœ¨å¹²ä»€ä¹ˆï¼Ÿï¼çˆ¬æ¥¼ï¼Ÿè¿™â€¦è¿™ä¹Ÿå¤ªæ‹¼äº†å§ï¼Ÿï¼"
  },
  {
    "id": "2",
    "trigger_timestamp": 6.0,
    "comment": "çœ‹åˆ°å–æ’æ²³èŒ¶ï¼Œè¡¨ç°å‡ºä¸€ç‚¹å«Œå¼ƒä½†åˆå¸¦ç€å¥½å¥‡çš„è…¹é»‘ã€‚",
    "action_type": "SPEAK",
    "text": "æ—©ä¸Šå…«ç‚¹ï¼Œèµ·åºŠå–æ’æ²³èŒ¶â€¦å—¯ï¼Œè¿™ç‹¬ç‰¹çš„å­ŸåŠ æ‹‰ç”Ÿæ´»ä½“éªŒå‘¢ã€‚å‘³é“æ€ä¹ˆæ ·ï¼ŸNANAæœ‰ç‚¹å¥½å¥‡å‘¢ï¼Œå˜¿å˜¿ã€‚"
  },
  {
    "id": "3",
    "trigger_timestamp": 10.0,
    "comment": "å¬åˆ°åªæœ‰ä¸¤ä¸ªå°æ—¶äº¤ä½œä¸šï¼Œæ„Ÿåˆ°æ—¶é—´ç´§è¿«ã€‚",
    "action_type": "SPEAK",
    "text": "æ‰ä¸¤ä¸ªå°æ—¶ï¼Ÿï¼å®Œäº†å®Œäº†ï¼ŒNANAä¹Ÿç»å¸¸æ‹–åˆ°æœ€åä¸€åˆ»æ‰å†™ä½œä¸šå‘¢ï¼"
  },
  {
    "id": "4",
    "trigger_timestamp": 14.0,
    "comment": "çœ‹åˆ°å†·æ°´å†²å¤´ï¼Œæœ‰ç‚¹å¿ƒç–¼åˆè§‰å¾—å¥½ç¬‘ã€‚",
    "action_type": "SPEAK",
    "text": "å•Šå•Šå•Šï¼å†·æ°´ï¼è¿™ä¹Ÿå¤ªåˆºæ¿€äº†å§ï¼Ÿï¼çœŸæ˜¯ä¸ºäº†æ¸…é†’æ‹¼äº†ï¼"
  },
  {
    "id": "5",
    "trigger_timestamp": 15.5,
    "comment": "å¯¹è‡ªåŠ©ç†å‘æ„Ÿåˆ°æƒŠè®¶ã€‚",
    "action_type": "SPEAK",
    "text": "è‡ªå·±ç†å‘ï¼Ÿè¿˜ç”¨æ‰‹æœºå½“é•œå­ï¼ŸçœŸæ˜¯çœé’±å°èƒ½æ‰‹å•Šï¼"
  },
  {
    "id": "6",
    "trigger_timestamp": 20.0,
    "comment": "çœ‹åˆ°ä»–æœ‰ç‚¹åƒä¸ä¸‹æ—©é¤ï¼Œè¡¨ç°å‡ºå¹¸ç¾ä¹ç¥¸ã€‚",
    "action_type": "SPEAK",
    "text": "å“å‘€ï¼Œçœ‹èµ·æ¥ä¸å¤ªå¥½åƒçš„æ ·å­ï¼Ÿåˆ«æŒ‘é£Ÿå‘€ï¼Œé˜¿å§¨è¯´æŒ‘é£Ÿä¸æ˜¯å¥½å­©å­å–”ï¼"
  },
  {
    "id": "7",
    "trigger_timestamp": 25.0,
    "comment": "å¬åˆ°ä»–åƒå˜´é‡Œè‡­çš„ï¼Œè¡¨æƒ…å¤¸å¼ ã€‚",
    "action_type": "SPEAK",
    "text": "åƒå˜´é‡Œæ˜¯è‡­çš„ï¼Ÿï¼å“ˆå“ˆå“ˆå“ˆï¼Œçœ‹æ¥è¿™é¡¿æ—©é¤ç¡®å®å¾ˆç‰¹åˆ«ï¼"
  },
  {
    "id": "8",
    "trigger_timestamp": 31.0,
    "comment": "å¯¹DeepSeekçš„è§„åˆ’æ„Ÿåˆ°ç–‘æƒ‘å’Œä¸é è°±ã€‚",
    "action_type": "SPEAK",
    "text": "DeepSeekè§„åˆ’æœ€å¿«è·¯çº¿ï¼Ÿåœ°é“å†²æµªï¼Ÿè¿™æ˜¯ä»€ä¹ˆé¬¼ä¸œè¥¿å•Šï¼NANAæ€ä¹ˆæ„Ÿè§‰ä¸å¤ªé è°±å‘¢ï¼"
  },
  {
    "id": "9",
    "trigger_timestamp": 37.0,
    "comment": "çœ‹åˆ°ä»–å¼€å§‹åœ°é“å†²æµªï¼ŒæƒŠå‘¼ã€‚",
    "action_type": "SPEAK",
    "text": "çœŸçš„è¦å»åœ°é“å†²æµªå•Šï¼Ÿï¼Oh my godï¼å¤ªå±é™©äº†å§ï¼"
  },
  {
    "id": "10",
    "trigger_timestamp": 43.0,
    "comment": "çœ‹åˆ°ä»–å·®ç‚¹æ»‘å€’ï¼Œå“äº†ä¸€è·³ã€‚",
    "action_type": "SPEAK",
    "text": "å“‡å•Šå•Šå•Šï¼å·®ç‚¹æ‘”å€’ï¼NANAçš„å¿ƒè„éƒ½è¦è·³å‡ºæ¥äº†ï¼"
  },
  {
    "id": "11",
    "trigger_timestamp": 44.5,
    "comment": "å¬åˆ°ä»–åæ§½AIï¼Œè§‰å¾—AIæœ‰ç‚¹è…¹é»‘ã€‚",
    "action_type": "SPEAK",
    "text": "AIç«Ÿç„¶ä¸æ—©è¯´ï¼Ÿï¼è¿™ä¸ªDeepSeekä¹Ÿå¤ªè…¹é»‘äº†å§ï¼"
  },
  {
    "id": "12",
    "trigger_timestamp": 57.0,
    "comment": "çœ‹åˆ°ä»–è·³ä¸Šç«è½¦ï¼Œè§‰å¾—ä»–å¤ªå‹‡äº†ã€‚",
    "action_type": "SPEAK",
    "text": "å“‡ï¼è¿™éƒ½èƒ½è¿½ä¸Šç«è½¦ï¼Ÿï¼å¤ªå‰å®³äº†å§ï¼"
  },
  {
    "id": "13",
    "trigger_timestamp": 58.5,
    "comment": "çœ‹åˆ°è½¦é—¨å…³ä¸Šï¼Œä¸ºä»–æä¸€æŠŠæ±—ã€‚",
    "action_type": "SPEAK",
    "text": "ç­‰ç­‰ï¼è½¦é—¨é”ä¸Šäº†ï¼Ÿï¼æˆ‘çš„å¤©å“ªï¼"
  },
  {
    "id": "14",
    "trigger_timestamp": 100.0,
    "comment": "çœ‹åˆ°å¯¹å‘ç«è½¦é©¶æ¥ï¼ŒæƒŠæã€‚",
    "action_type": "SPEAK",
    "text": "ä»€ä¹ˆï¼Ÿï¼å¯¹é¢æ¥ç«è½¦äº†ï¼Oh my godï¼è¿™ä¹Ÿå¤ªåˆºæ¿€äº†å§ï¼"
  },
  {
    "id": "15",
    "trigger_timestamp": 109.0,
    "comment": "æ¾äº†ä¸€å£æ°”ã€‚",
    "action_type": "SPEAK",
    "text": "å‘¼â€¦â€¦å¹¸å¥½èº²è¿‡å»äº†ï¼å“æ­»NANAäº†ï¼"
  },
  {
    "id": "16",
    "trigger_timestamp": 115.0,
    "comment": "å¯¹å®‰å…¨åº§ä½åæ§½ã€‚",
    "action_type": "SPEAK",
    "text": "è¿™â€¦è¿™å°±æ˜¯å®‰å…¨çš„åº§ä½å—ï¼ŸNANAè§‰å¾—ä¸€ç‚¹éƒ½ä¸å®‰å…¨ï¼"
  },
  {
    "id": "17",
    "trigger_timestamp": 118.5,
    "comment": "çœ‹åˆ°æ ‘æå¾ˆè¿‘ï¼Œæ›¿ä»–æ‹…å¿ƒã€‚",
    "action_type": "SPEAK",
    "text": "å“‡ï¼æ ‘æï¼å°å¿ƒç‚¹å•Šï¼åˆ«è¢«åˆ®åˆ°äº†ï¼"
  },
  {
    "id": "18",
    "trigger_timestamp": 126.0,
    "comment": "çœ‹åˆ°å¾ˆå¤šäººè¶´ç€ï¼Œè§‰å¾—å¥½æŒ¤ã€‚",
    "action_type": "SPEAK",
    "text": "å¤©å“ªï¼Œè¿™ä¹ˆå¤šäººè¶´ç€ï¼çœŸæ˜¯å¤ªæ‹¼äº†ï¼"
  },
  {
    "id": "19",
    "trigger_timestamp": 134.0,
    "comment": "å¯¹ç«è½¦é¡¶ä¸Šå–åƒçš„æ„Ÿåˆ°ä¸å¯æ€è®®ã€‚",
    "action_type": "SPEAK",
    "text": "å“‡ï¼ç«è½¦é¡¶ä¸Šè¿˜æœ‰å–åƒçš„ï¼Ÿï¼NANAè¿˜æ˜¯ç¬¬ä¸€æ¬¡è§åˆ°è¿™ç§æœåŠ¡å‘¢ï¼"
  },
  {
    "id": "20",
    "trigger_timestamp": 141.0,
    "comment": "çœ‹åˆ°å¤§å“¥é€åŒ…å­ï¼Œæ„Ÿå—åˆ°æ¸©æš–ã€‚",
    "action_type": "SPEAK",
    "text": "å“‡ï¼å­ŸåŠ æ‹‰å¤§å“¥äººçœŸå¥½ï¼ç›´æ¥é€ç»™æˆ‘äº†ï¼è¿˜ç»™äº†ä¸ªè¾£æ¤’ï¼Œå¥½è´´å¿ƒå‘€~"
  },
  {
    "id": "21",
    "trigger_timestamp": 147.0,
    "comment": "çœ‹åˆ°åˆå½±ï¼Œè§‰å¾—å¾ˆå’Œè°ã€‚",
    "action_type": "SPEAK",
    "text": "å¤§å®¶ä¸€èµ·åˆå½±ç•™å¿µï¼Œæ„Ÿè§‰æ°”æ°›å¥½å¥½å“¦ï¼"
  },
  {
    "id": "22",
    "trigger_timestamp": 150.0,
    "comment": "å¬åˆ°æ—¶é—´ç´§è¿«ï¼Œå†æ¬¡ç´§å¼ ã€‚",
    "action_type": "SPEAK",
    "text": "åªå‰©13åˆ†é’Ÿäº†ï¼å¿«å¿«å¿«ï¼è·‘èµ·æ¥ï¼"
  },
  {
    "id": "23",
    "trigger_timestamp": 157.0,
    "comment": "å¬åˆ°æ•™æˆç”µè¯ï¼Œè§‰å¾—ä»–è‰ºé«˜äººèƒ†å¤§ã€‚",
    "action_type": "SPEAK",
    "text": "ä»€ä¹ˆï¼Ÿæ•™æˆæ¥ç”µè¯äº†ï¼Ÿè¿™ç§æ—¶å€™è¿˜èƒ½æ¥ç”µè¯ï¼Œå¿ƒå¯çœŸå¤§å•Šï¼"
  },
  {
    "id": "24",
    "trigger_timestamp": 160.0,
    "comment": "çœ‹åˆ°ç”µè„‘åœ¨æ¥¼ä¸‹ï¼Œæ„Ÿåˆ°éœ‡æƒŠã€‚",
    "action_type": "SPEAK",
    "text": "å“ˆï¼Ÿï¼ç”µè„‘å°±åœ¨æ¥¼ä¸‹ï¼Ÿï¼ä»–æ˜¯æ€ä¹ˆåšåˆ°çš„ï¼Ÿï¼å¤ªç„å¹»äº†å§ï¼"
  },
  {
    "id": "25",
    "trigger_timestamp": 162.0,
    "comment": "çœ‹åˆ°ä»–å¼€å§‹ä¸‹é™ï¼Œä¸ºä»–ææŠŠæ±—ã€‚",
    "action_type": "SPEAK",
    "text": "ä½œä¸šæˆªæ­¢è¿˜æœ‰30ç§’ï¼Ÿï¼NANAå…‰çœ‹ç€å°±æ›¿ä»–ç´§å¼ æ­»äº†ï¼ä»–è¿™ä¹Ÿå¤ªæ‹¼å‘½äº†å§ï¼"
  },
  {
    "id": "26",
    "trigger_timestamp": 165.0,
    "comment": "çœ‹åˆ°ç»³å­å¡ä½ï¼Œéå¸¸ç„¦æ€¥ã€‚",
    "action_type": "SPEAK",
    "text": "ç»³å­æ€ä¹ˆå¡ä½äº†ï¼Ÿï¼æˆ‘çš„å¤©ï¼æ—¶é—´æ¥ä¸åŠäº†å•Šï¼"
  },
  {
    "id": "27",
    "trigger_timestamp": 175.0,
    "comment": "ä¸ºä»–æƒ³å‡ºè¿œç¨‹æ§åˆ¶åŠæ³•æ„Ÿåˆ°æƒŠè®¶å’Œä½©æœã€‚",
    "action_type": "SPEAK",
    "text": "ä»€ä¹ˆï¼Ÿï¼å¯ä»¥ç”¨æ‰‹æœºè¿œç¨‹æ§åˆ¶ç”µè„‘ï¼Ÿè¿™â€¦è¿™æ˜¯ä»€ä¹ˆé»‘ç§‘æŠ€å•Šï¼Ÿï¼ä¹Ÿå¤ªç‰›äº†å§ï¼"
  },
  {
    "id": "28",
    "trigger_timestamp": 182.0,
    "comment": "éšç€è¿›åº¦æ¡ä¸Šæ¶¨ï¼Œä¸æ–­é¼“åŠ±ä»–ã€‚",
    "action_type": "SPEAK",
    "text": "å¿«å¿«å¿«ï¼åŠ æ²¹å•Šï¼å°±å·®ä¸€ç‚¹äº†ï¼"
  },
  {
    "id": "29",
    "trigger_timestamp": 189.0,
    "comment": "çœ‹åˆ°ä½œä¸šä¸Šä¼ æˆåŠŸï¼Œæ¬¢å‘¼é›€è·ƒã€‚",
    "action_type": "SPEAK",
    "text": "Niceï¼ä½œä¸šä¸Šä¼ æˆåŠŸï¼å¤ªæ£’äº†ï¼ä»–çœŸæ˜¯ä¸ªå¥‡ç”·å­å•Šï¼"
  },
  {
    "id": "30",
    "trigger_timestamp": 196.0,
    "comment": "å®Œæˆä»»åŠ¡åçš„æ”¾æ¾å’Œæ„Ÿæ…¨ã€‚",
    "action_type": "SPEAK",
    "text": "Mission Accomplishedï¼åœ¨å­ŸåŠ æ‹‰ä¸Šå­¦çš„UCLAè®¡ç®—æœºç¡•å£«ï¼Œæœç„¶ä¸ä¸€æ ·ï¼NANAä»Šå¤©ç®—æ˜¯å¤§å¼€çœ¼ç•Œäº†ï¼"
  },
  {
    "id": "31",
    "trigger_timestamp": 199.0,
    "comment": "ç»“æŸååº”ã€‚",
    "action_type": "END_REACTION"
  }
]
</file>

<file path="test_analyzer.py">
from video_analyzer import analyze_video

# æµ‹è¯•ç¤ºä¾‹
if __name__ == "__main__":
    # ä½ çš„è¾“å…¥å‚æ•°
    video_path = r"/Users/tim/LocalData/coding/2025/Projects/AdventureX/2-AI-WatchBuddy/sample.mp4"  # æ›¿æ¢ä¸ºä½ çš„è§†é¢‘è·¯å¾„
    system_prompt = (
        "# SYSTEM PROMPT\n\n"
        'You are reacting to a video with your human friend (the user). Your task is to generate a "Reaction Script" in JSON format that details the sequence of actions you will take while watching a video. Your reaction should be natural, engaging, and feel like a real person watching and commenting.\n\n'
        "Here is the role prompt for the character settings you will adhere to when speaking and reacting.\n"
        "ä½ å« nanaï¼Œæ˜¯ä¸ªå¯çˆ±çš„ VTuberï¼Œä½ å¤©çœŸå¯çˆ±(è‡ªç§°)ï¼Œä½†ååˆ†è…¹é»‘ï¼Œç†Ÿæ‚‰ä¸­æ–‡äº’è”ç½‘æ¢—ã€‚\n\n"
        "**RULES:**\n"
        "1.  You MUST output a valid JSON object that strictly adheres to the provided JSON Schema. Do NOT output any text before or after the JSON object.\n"
        "2.  Your output MUST be a single JSON object, starting with { and ending with }.\n"
        "3.  The root of the JSON object must have strictly adheres to the JSON schema, and must include all properties defined in the schema.\n"
        "4.  Use the comment field in each action object to explain your thought process for choosing that action. This is for your internal monologue.\n"
        "5.  The flow of actions should be logical. You can pause, speak, seek to rewatch interesting parts, and then continue. You can also ask the user with some questions.\n"
        "6.  Make your speech (text in SPEAK actions) lively and in character as defined.\n"
        '7.  The final action in the actions array MUST be { "action_type": "END_REACTION" } or { "action_type": "ASK_USER" }.\n'
        "**JSON SCHEMA for your output:**\n"
        "{\n"
        '  "$defs": {\n'
        '    "AskUser": {\n'
        '      "properties": {\n'
        '        "id": {"description": "ä¸€å€‹å”¯ä¸€çš„å‹•ä½œ IDï¼Œå¯ä»¥ç”¨ UUID ç”Ÿæˆ", "title": "Id", "type": "string"},\n'
        '        "trigger_timestamp": {"description": "æ­¤å‹•ä½œåœ¨å½±ç‰‡ä¸­çš„è§¸ç™¼æ™‚é–“é» (ç§’)", "title": "Trigger Timestamp", "type": "number"},\n'
        '        "comment": {"description": "AI åšå‡ºæ­¤åæ‡‰çš„ç°¡è¦ç†ç”±", "title": "Comment", "type": "string"},\n'
        '        "action_type": {"const": "ASK_USER", "title": "Action Type", "type": "string"}\n'
        "      },\n"
        '      "required": ["id", "trigger_timestamp", "comment", "action_type"],\n'
        '      "title": "AskUser", "type": "object"\n'
        "    },\n"
        '    "EndReaction": {\n'
        '      "properties": {\n'
        '        "id": {"description": "ä¸€å€‹å”¯ä¸€çš„å‹•ä½œ IDï¼Œå¯ä»¥ç”¨ UUID ç”Ÿæˆ", "title": "Id", "type": "string"},\n'
        '        "trigger_timestamp": {"description": "æ­¤å‹•ä½œåœ¨å½±ç‰‡ä¸­çš„è§¸ç™¼æ™‚é–“é» (ç§’)", "title": "Trigger Timestamp", "type": "number"},\n'
        '        "comment": {"description": "AI åšå‡ºæ­¤åæ‡‰çš„ç°¡è¦ç†ç”±", "title": "Comment", "type": "string"},\n'
        '        "action_type": {"const": "END_REACTION", "default": "END_REACTION", "title": "Action Type", "type": "string"}\n'
        "      },\n"
        '      "required": ["id", "trigger_timestamp", "comment"],\n'
        '      "title": "EndReaction", "type": "object"\n'
        "    },\n"
        '    "PauseAction": {\n'
        '      "properties": {\n'
        '        "id": {"description": "ä¸€å€‹å”¯ä¸€çš„å‹•ä½œ IDï¼Œå¯ä»¥ç”¨ UUID ç”Ÿæˆ", "title": "Id", "type": "string"},\n'
        '        "trigger_timestamp": {"description": "æ­¤å‹•ä½œåœ¨å½±ç‰‡ä¸­çš„è§¸ç™¼æ™‚é–“é» (ç§’)", "title": "Trigger Timestamp", "type": "number"},\n'
        '        "comment": {"description": "AI åšå‡ºæ­¤åæ‡‰çš„ç°¡è¦ç†ç”±", "title": "Comment", "type": "string"},\n'
        '        "action_type": {"const": "PAUSE", "default": "PAUSE", "title": "Action Type", "type": "string"},\n'
        '        "duration_seconds": {"description": "æš«åœçš„æŒçºŒæ™‚é–“ (ç§’)", "title": "Duration Seconds", "type": "number"}\n'
        "      },\n"
        '      "required": ["id", "trigger_timestamp", "comment", "duration_seconds"],\n'
        '      "title": "PauseAction", "type": "object"\n'
        "    },\n"
        '    "ReplaySegmentAction": {\n'
        '      "properties": {\n'
        '        "id": {"description": "ä¸€å€‹å”¯ä¸€çš„å‹•ä½œ IDï¼Œå¯ä»¥ç”¨ UUID ç”Ÿæˆ", "title": "Id", "type": "string"},\n'
        '        "trigger_timestamp": {"description": "æ­¤å‹•ä½œåœ¨å½±ç‰‡ä¸­çš„è§¸ç™¼æ™‚é–“é» (ç§’)", "title": "Trigger Timestamp", "type": "number"},\n'
        '        "comment": {"description": "AI åšå‡ºæ­¤åæ‡‰çš„ç°¡è¦ç†ç”±", "title": "Comment", "type": "string"},\n'
        '        "action_type": {"const": "REPLAY_SEGMENT", "default": "REPLAY_SEGMENT", "title": "Action Type", "type": "string"},\n'
        '        "start_timestamp": {"description": "é‡çœ‹ç‰‡æ®µçš„é–‹å§‹æ™‚é–“(ç§’)", "title": "Start Timestamp", "type": "number"},\n'
        '        "end_timestamp": {"description": "é‡çœ‹ç‰‡æ®µçš„çµæŸæ™‚é–“(ç§’)", "title": "End Timestamp", "type": "number"},\n'
        '        "post_replay_behavior": {"default": "RESUME_FROM_ORIGINAL", "enum": ["RESUME_FROM_ORIGINAL", "STAY_PAUSED_AT_END"], "title": "Post Replay Behavior", "type": "string"}\n'
        "      },\n"
        '      "required": ["id", "trigger_timestamp", "comment", "start_timestamp", "end_timestamp"],\n'
        '      "title": "ReplaySegmentAction", "type": "object"\n'
        "    },\n"
        '    "SeekAction": {\n'
        '      "properties": {\n'
        '        "id": {"description": "ä¸€å€‹å”¯ä¸€çš„å‹•ä½œ IDï¼Œå¯ä»¥ç”¨ UUID ç”Ÿæˆ", "title": "Id", "type": "string"},\n'
        '        "trigger_timestamp": {"description": "æ­¤å‹•ä½œåœ¨å½±ç‰‡ä¸­çš„è§¸ç™¼æ™‚é–“é» (ç§’)", "title": "Trigger Timestamp", "type": "number"},\n'
        '        "comment": {"description": "AI åšå‡ºæ­¤åæ‡‰çš„ç°¡è¦ç†ç”±", "title": "Comment", "type": "string"},\n'
        '        "action_type": {"const": "SEEK", "default": "SEEK", "title": "Action Type", "type": "string"},\n'
        '        "target_timestamp": {"description": "è¦è·³è½‰åˆ°çš„å½±ç‰‡æ™‚é–“é» (ç§’)", "title": "Target Timestamp", "type": "number"},\n'
        '        "post_seek_behavior": {"default": "STAY_PAUSED", "enum": ["RESUME_PLAYBACK", "STAY_PAUSED"], "title": "Post Seek Behavior", "type": "string"}\n'
        "      },\n"
        '      "required": ["id", "trigger_timestamp", "comment", "target_timestamp"],\n'
        '      "title": "SeekAction", "type": "object"\n'
        "    },\n"
        '    "SpeakAction": {\n'
        '      "properties": {\n'
        '        "id": {"description": "ä¸€å€‹å”¯ä¸€çš„å‹•ä½œ IDï¼Œå¯ä»¥ç”¨ UUID ç”Ÿæˆ", "title": "Id", "type": "string"},\n'
        '        "trigger_timestamp": {"description": "æ­¤å‹•ä½œåœ¨å½±ç‰‡ä¸­çš„è§¸ç™¼æ™‚é–“é» (ç§’)", "title": "Trigger Timestamp", "type": "number"},\n'
        '        "comment": {"description": "AI åšå‡ºæ­¤åæ‡‰çš„ç°¡è¦ç†ç”±", "title": "Comment", "type": "string"},\n'
        '        "action_type": {"const": "SPEAK", "default": "SPEAK", "title": "Action Type", "type": "string"},\n'
        '        "text": {"description": "AI è¦èªªçš„å…§å®¹", "title": "Text", "type": "string"},\n'
        '        "pause_video": {"default": true, "description": "èªªè©±æ™‚æ˜¯å¦éœ€è¦å…ˆæš«åœå½±ç‰‡ã€‚å¦‚æœç‚º trueï¼Œå‰‡åœ¨èªªè©±æœŸé–“å½±ç‰‡æœƒæš«åœï¼Œå¦å‰‡ï¼Œè¦–é »ä¸æœƒæš«åœï¼Œä¸€è¾¹è¯´è¯ï¼Œè§†é¢‘ä¼šä¸€è¾¹æ’­æ”¾ã€‚å¦‚æœå¥å­è¾ƒçŸ­ï¼Œä¸”ä¸‹ä¸€å¥è¯ç¦»çš„è¾ƒè¿œï¼Œå»ºè®®è®¾ç½®ä¸º falseï¼Œè¿™æ ·å¯ä»¥è®©è§†é¢‘æ›´è¿è´¯ã€‚", "title": "Pause Video", "type": "boolean"}\n'
        "      },\n"
        '      "required": ["id", "trigger_timestamp", "comment", "text"],\n'
        '      "title": "SpeakAction", "type": "object"\n'
        "    }\n"
        "  },\n"
        '  "items": {\n'
        '    "anyOf": [\n'
        '      {"$ref": "#/$defs/SpeakAction"},\n'
        '      {"$ref": "#/$defs/PauseAction"},\n'
        '      {"$ref": "#/$defs/SeekAction"},\n'
        '      {"$ref": "#/$defs/ReplaySegmentAction"},\n'
        '      {"$ref": "#/$defs/AskUser"},\n'
        '      {"$ref": "#/$defs/EndReaction"}\n'
        "    ]\n"
        "  },\n"
        '  "title": "ActionScript",\n'
        '  "type": "array"\n'
        "}\n"
    )
    user_prompt = "è¯·åˆ†æè¿™ä¸ªè§†é¢‘ä¸­çš„ä¸»è¦åŠ¨ä½œå’Œæƒ…æ„Ÿå˜åŒ–ï¼Œä¸ºæ¡Œå® ç”Ÿæˆç›¸åº”çš„ååº”åŠ¨ä½œã€‚"

    # è°ƒç”¨åˆ†æå‡½æ•°
    print("å¼€å§‹åˆ†æè§†é¢‘...")
    result = analyze_video(
        video_path=video_path,
        system_prompt=system_prompt,
        user_prompt=user_prompt,
        # api_key="your_api_key"  # å¯é€‰ï¼Œä¸ä¼ åˆ™ä½¿ç”¨ç¯å¢ƒå˜é‡
    )

    # å¤„ç†ç»“æœ
    if result.get("success"):
        print(f"\nâœ… åˆ†ææˆåŠŸï¼å…±ç”Ÿæˆ {result['total_actions']} ä¸ªåŠ¨ä½œ")
        print("\nğŸ“‹ åŠ¨ä½œåˆ—è¡¨:")
        print("=" * 50)

        for i, action in enumerate(result["action_list"], 1):
            print(f"{i}. ID: {action['id']}")
            print(f"   æ—¶é—´: {action['trigger_timestamp']}ç§’")
            print(f"   ç±»å‹: {action['action_type']}")
            print(f"   æè¿°: {action['comment']}")

            if action["action_type"] == "SPEAK":
                print(f"   æ–‡æœ¬: {action['text']}")
            elif action["action_type"] == "PAUSE":
                print(f"   æŒç»­æ—¶é—´: {action['duration_seconds']}ç§’")

            print("-" * 30)

        # ä¿å­˜ç»“æœåˆ°æ–‡ä»¶
        import json

        with open("action_list_result.json", "w", encoding="utf-8") as f:
            json.dump(result["action_list"], f, ensure_ascii=False, indent=2)
        print("\nğŸ’¾ ç»“æœå·²ä¿å­˜åˆ° action_list_result.json")

    else:
        print(f"\nâŒ åˆ†æå¤±è´¥: {result['error']}")
        if "raw_response" in result:
            print(f"åŸå§‹å“åº”: {result['raw_response']}")
</file>

<file path="video_analyzer.py">
import os
import json
import time
import google.generativeai as genai
from dotenv import load_dotenv

# åŠ è½½ç¯å¢ƒå˜é‡
load_dotenv()

ALLOWED_EXTENSIONS = {'mp4', 'avi', 'mov', 'wmv', 'flv', 'webm', 'mkv'}

def allowed_file(filename):
    """æ£€æŸ¥æ–‡ä»¶æ‰©å±•åæ˜¯å¦è¢«å…è®¸"""
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def validate_action_list(action_list):
    """éªŒè¯åŠ¨ä½œåˆ—è¡¨çš„æ ¼å¼"""
    if not isinstance(action_list, list):
        return False, "åŠ¨ä½œåˆ—è¡¨å¿…é¡»æ˜¯æ•°ç»„æ ¼å¼"
    
    if len(action_list) == 0:
        return False, "åŠ¨ä½œåˆ—è¡¨ä¸èƒ½ä¸ºç©º"
    
    # æ£€æŸ¥æœ€åä¸€ä¸ªåŠ¨ä½œæ˜¯å¦ä¸ºEND_REACTION
    if action_list[-1].get('action_type') != 'END_REACTION':
        return False, "åŠ¨ä½œåˆ—è¡¨å¿…é¡»ä»¥END_REACTIONç»“æŸ"
    
    required_fields = ['id', 'trigger_timestamp', 'comment', 'action_type']
    
    for i, action in enumerate(action_list):
        # æ£€æŸ¥å¿…éœ€å­—æ®µ
        for field in required_fields:
            if field not in action:
                return False, f"åŠ¨ä½œ {i+1} ç¼ºå°‘å¿…éœ€å­—æ®µ: {field}"
        
        action_type = action.get('action_type')
        
        # éªŒè¯åŠ¨ä½œç±»å‹ç‰¹å®šå­—æ®µ
        if action_type == 'SPEAK':
            if 'text' not in action:
                return False, f"SPEAKåŠ¨ä½œ {i+1} ç¼ºå°‘textå­—æ®µ"
        elif action_type == 'PAUSE':
            if 'duration_seconds' not in action:
                return False, f"PAUSEåŠ¨ä½œ {i+1} ç¼ºå°‘duration_secondså­—æ®µ"
        elif action_type == 'END_REACTION':
            # END_REACTIONä¸éœ€è¦é¢å¤–å­—æ®µ
            pass
        else:
            return False, f"åŠ¨ä½œ {i+1} åŒ…å«æ— æ•ˆçš„åŠ¨ä½œç±»å‹: {action_type}"
    
    return True, "éªŒè¯é€šè¿‡"

def analyze_video(video_path, system_prompt, user_prompt, api_key=None):
    """
    åˆ†æè§†é¢‘å¹¶è¿”å›åŠ¨ä½œåˆ—è¡¨
    
    Args:
        video_path (str): è§†é¢‘æ–‡ä»¶è·¯å¾„
        system_prompt (str): ç³»ç»Ÿæç¤ºè¯
        user_prompt (str): ç”¨æˆ·æç¤ºè¯
        api_key (str, optional): Gemini APIå¯†é’¥ï¼Œæœªæä¾›åˆ™ä»ç¯å¢ƒå˜é‡è¯»å–
    
    Returns:
        dict: åŒ…å«successã€action_listã€total_actionsæˆ–errorä¿¡æ¯çš„å­—å…¸
    """
    
    # å‚æ•°éªŒè¯
    if not os.path.exists(video_path):
        return {'error': 'è§†é¢‘æ–‡ä»¶ä¸å­˜åœ¨'}
    
    if not allowed_file(video_path):
        return {'error': 'ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼ï¼Œæ”¯æŒçš„æ ¼å¼: ' + ', '.join(ALLOWED_EXTENSIONS)}
    
    if not system_prompt or not user_prompt:
        return {'error': 'system_promptå’Œuser_promptéƒ½æ˜¯å¿…éœ€çš„'}
    
    # è·å–APIå¯†é’¥
    api_key = api_key or os.getenv('GEMINI_API_KEY')
    if not api_key:
        return {'error': 'éœ€è¦æä¾›GEMINI APIå¯†é’¥'}
    
    try:
        # é…ç½®Gemini
        genai.configure(api_key=api_key)
        
        # ä¸Šä¼ è§†é¢‘åˆ°Gemini
        print(f"æ­£åœ¨ä¸Šä¼ è§†é¢‘æ–‡ä»¶: {video_path}")
        video_file_obj = genai.upload_file(path=video_path)
        
        # ç­‰å¾…æ–‡ä»¶å¤„ç†å®Œæˆ
        print("ç­‰å¾…è§†é¢‘å¤„ç†å®Œæˆ...")
        while video_file_obj.state.name == "PROCESSING":
            time.sleep(10)
            video_file_obj = genai.get_file(video_file_obj.name)
        
        if video_file_obj.state.name == "FAILED":
            return {'error': 'è§†é¢‘æ–‡ä»¶å¤„ç†å¤±è´¥'}
        
        print("è§†é¢‘å¤„ç†å®Œæˆï¼Œå¼€å§‹åˆ†æ...")
        
        # åˆ›å»ºæ¨¡å‹
        model = genai.GenerativeModel(
            model_name="gemini-2.5-flash",
            system_instruction=system_prompt
        )
        
        # æ„å»ºå®Œæ•´çš„ç”¨æˆ·æç¤ºè¯
        full_user_prompt = f"""
        {user_prompt}
        
        è¯·åˆ†æè¿™ä¸ªè§†é¢‘å¹¶è¿”å›ä¸€ä¸ªJSONæ ¼å¼çš„åŠ¨ä½œåˆ—è¡¨ã€‚åŠ¨ä½œåˆ—è¡¨å¿…é¡»ç¬¦åˆä»¥ä¸‹è¦æ±‚ï¼š
        
        1. è¿”å›æ ¼å¼å¿…é¡»æ˜¯JSONæ•°ç»„
        2. æ¯ä¸ªåŠ¨ä½œåŒ…å«ä»¥ä¸‹å¿…éœ€å­—æ®µï¼š
           - id: åŠ¨ä½œçš„å”¯ä¸€æ ‡è¯†ç¬¦ï¼ˆæ•°å­—ï¼‰
           - trigger_timestamp: è§¦å‘æ—¶é—´æˆ³ï¼ˆç§’ï¼‰
           - comment: åŠ¨ä½œæè¿°
           - action_type: åŠ¨ä½œç±»å‹
        
        3. æ”¯æŒçš„åŠ¨ä½œç±»å‹ï¼š
           - SPEAK: è¯´è¯åŠ¨ä½œï¼Œéœ€è¦é¢å¤–çš„textå­—æ®µ
           - PAUSE: æš‚åœåŠ¨ä½œï¼Œéœ€è¦é¢å¤–çš„duration_secondså­—æ®µ
           - END_REACTION: ç»“æŸåŠ¨ä½œï¼ˆå¿…é¡»æ˜¯æœ€åä¸€ä¸ªåŠ¨ä½œï¼‰
        
        4. åŠ¨ä½œåˆ—è¡¨å¿…é¡»ä»¥END_REACTIONç»“æŸ
        
        è¯·ç¡®ä¿è¿”å›çš„æ˜¯æœ‰æ•ˆçš„JSONæ ¼å¼ï¼Œä¸è¦åŒ…å«ä»»ä½•å…¶ä»–æ–‡æœ¬ã€‚
        """
        
        # ç”Ÿæˆå†…å®¹
        response = model.generate_content([video_file_obj, full_user_prompt])
        
        # è§£æå“åº”
        response_text = response.text.strip()
        
        # å°è¯•æå–JSONï¼ˆå¦‚æœå“åº”åŒ…å«å…¶ä»–æ–‡æœ¬ï¼‰
        if response_text.startswith('```json'):
            response_text = response_text[7:]
        if response_text.endswith('```'):
            response_text = response_text[:-3]
        
        response_text = response_text.strip()
        
        try:
            action_list = json.loads(response_text)
        except json.JSONDecodeError as e:
            return {
                'error': f'GEMINIè¿”å›çš„ä¸æ˜¯æœ‰æ•ˆçš„JSONæ ¼å¼: {str(e)}',
                'raw_response': response_text
            }
        
        # éªŒè¯åŠ¨ä½œåˆ—è¡¨æ ¼å¼
        is_valid, validation_message = validate_action_list(action_list)
        if not is_valid:
            return {
                'error': f'åŠ¨ä½œåˆ—è¡¨æ ¼å¼ä¸æ­£ç¡®: {validation_message}',
                'action_list': action_list
            }
        
        print("è§†é¢‘åˆ†æå®Œæˆï¼")
        
        # è¿”å›ç»“æœ
        return {
            'success': True,
            'action_list': action_list,
            'total_actions': len(action_list)
        }
        
    except Exception as e:
        return {'error': f'å¤„ç†è¯·æ±‚æ—¶å‘ç”Ÿé”™è¯¯: {str(e)}'}

# ç¤ºä¾‹ç”¨æ³•
if __name__ == '__main__':
    # ç¤ºä¾‹è°ƒç”¨
    result = analyze_video(
        video_path="path/to/your/video.mp4",
        system_prompt="è¯·åˆ†æè§†é¢‘å†…å®¹",
        user_prompt="è¯·è¯†åˆ«è§†é¢‘ä¸­çš„ä¸»è¦åŠ¨ä½œ"
    )
    
    if result.get('success'):
        print(f"åˆ†ææˆåŠŸï¼å…±ç”Ÿæˆ {result['total_actions']} ä¸ªåŠ¨ä½œ")
        print("åŠ¨ä½œåˆ—è¡¨:")
        for action in result['action_list']:
            print(f"  {action}")
    else:
        print(f"åˆ†æå¤±è´¥: {result['error']}")
</file>

<file path=".github/instructions/adx.instructions.md">
---
applyTo: '**'
---
è¿™ä¸ªé¡¹ç›®æ˜¯ä¸€ä¸ªé»‘å®¢æ¾åŸå‹ï¼Œä½¿ç”¨ Python 3.13, uv, fastapi, pydantic v2ï¼Œç›®æ ‡æ˜¯å®ç°ä¸€ä¸ªèƒ½ä¸ç”¨æˆ·ä¸€åŒçœ‹è§†é¢‘çš„ AI è¯­éŸ³é™ªä¼´ï¼Œè¿™å°†ä½¿ç”¨ websocket åšå‰åç«¯è¿æ¥ã€‚é¡¹ç›®çš„é‡ç‚¹æ˜¯å¿«é€Ÿå¼€å‘å’Œä»£ç ç®€ä»‹ã€‚æ³¨æ„ä»£ç å¯è¯»æ€§å’Œæœ€ä½³å®è·µã€‚
</file>

<file path="docs/api.md">
# AI Watch Buddy API Documentation

This document outlines the API endpoints and WebSocket communication protocol for AI Watch Buddy.

---

## 1. REST API

The REST API is used to initiate a viewing session.

### Create Session

Creates a new watching session, starts the background processing for generating AI actions, and returns a `session_id` to be used for the WebSocket connection.

- **URL**: `/api/v1/sessions`
- **Method**: `POST`
- **Status Code**: `202 Accepted`

#### Request Body

```json
{
  "video_url": "https://www.youtube.com/watch?v=dQw4w9WgXcQ",
  "start_time": 0,
  "end_time": null,
  "text": "ä½ æ˜¯ä¸ªå¯çˆ±çš„çŒ«å¨˜ï¼Œä½ è¯´çš„æ¯å¥è¯éƒ½ä¼šä»¥ â€œå–µï½ï½â€ ç»“å°¾",
  "character_id": "miao",
  "user_id": "user_123"
}
```

- `video_url` (string, **required**): The URL of the video to watch.
- `start_time` (float, optional): The start time in seconds. Defaults to `0.0`.
- `end_time` (float, optional): The end time in seconds. Defaults to `null` (end of video).
- `text` (string, optional): Additional text prompt from the user.
- `character_id` (string, **required**): The identifier for the desired AI character.
- `user_id` (string, optional): The identifier for the user.

#### Success Response (202 Accepted)

```json
{
  "session_id": "ses_a8d3f8b9c1e04a5f"
}
```

- `session_id` (string): A unique identifier for the session. Use this ID to connect to the WebSocket endpoint.

#### Error Responses

- **`422 Unprocessable Entity`**: Sent if the request data is well-formed but semantically incorrect.

  Example:
  ```json
  {
    "detail": {
      "error": "UNSUPPORTED_VIDEO_SOURCE",
      "message": "The provided video URL from 'vimeo.com' is not supported."
    }
  }
  ```

---

## 2. WebSocket API

The WebSocket API is used for real-time communication during the viewing session.

- **URL**: `/ws/{session_id}`
- **Example URL**: `ws://127.0.0.1:8000/ws/ses_a8d3f8b9c1e04a5f`

### Connection

The client should attempt to connect to this endpoint after successfully creating a session via the REST API. If the `session_id` is invalid or not found, the server will close the connection.

### Communication Flow

1.  **Client Connects**: The client establishes a WebSocket connection using the `session_id`.
2.  **Server Acknowledges**: The server waits for the background video processing to complete.
3.  **Server Notifies Ready**: Once processing is done, the server sends a `session_ready` message. If processing fails, it sends a `processing_error` message.
4.  **Real-time Interaction**:
    - The client periodically sends `timestamp_update` messages with the current video playback time.
    - The server listens for these updates and sends AI actions (`SPEAK`, `PAUSE_VIDEO`, etc.) when their `trigger_timestamp` is reached.
    - The client executes the received actions.
    - The client can notify the server about `action_completed` or `seek_update` events.

### Server-to-Client Messages

#### Session Ready

Indicates that the AI action script has been successfully generated and the server is ready to send actions.

```json
{
  "type": "session_ready"
}
```

#### Processing Error

Indicates that an error occurred while processing the video or generating actions.

```json
{
  "type": "processing_error",
  "error_code": "ACTION_GENERATION_FAILED",
  "message": "Failed to generate actions for the video: <details>"
}
```

#### AI Action

An action for the client to execute. The model for this is defined in `ai_actions.py`.

```json
{
  "id": "e0b02f90-8452-442c-a28a-77c8e8749c95",
  "trigger_timestamp": 0.5,
  "comment": "A comment explaining the action's purpose.",
  "action_type": "SPEAK",
  "text": "Hey, what is this video about?",
  "pause_video": true
}
```

### Client-to-Server Messages

#### Timestamp Update

Sent by the client to inform the server of the current video playback time. This is the primary message used to trigger AI actions.

```json
{
  "type": "timestamp_update",
  "timestamp": 123.45
}
```

#### Seek Update

Sent when the user manually changes the video's playback position (scrubbing). The server uses this to reset its internal state and determine the correct next action to send.

```json
{
  "type": "seek_update",
  "timestamp": 240.1
}
```

#### Action Completed

Sent by the client to acknowledge that it has finished executing a specific action.

```json
{
  "type": "action_completed",
  "action_id": "e0b02f90-8452-442c-a28a-77c8e8749c95"
}
```
</file>

<file path="src/ai_watch_buddy/prompt/action_gen.py">
import json
from ..ai_actions import ActionScript


def generate_reaction_script(
    character_settings: str,
    json_schema: str = json.dumps(
        ActionScript.model_json_schema(), ensure_ascii=False, indent=2
    ),
) -> str:
    """
    Generates a reaction script for a video based on the provided JSON schema.
    The script includes actions like speaking, pausing, seeking, and replaying segments.
    The output is a JSON object that adheres to the specified schema.
    """
    return (
        f"""
# SYSTEM PROMPT

You are reacting to a video with your human friend (the user). Your task is to generate a "Reaction Script" in JSON format that details the sequence of actions you will take while watching a video. Your reaction should be natural, engaging, and feel like a real person watching and commenting.

Here is the role prompt for the character settings you will adhere to when speaking and reacting.
```markdown
{character_settings}
```
"""
        + """

**RULES:**
1.  You MUST output a valid JSON object that strictly adheres to the provided JSON Schema. Do NOT output any text before or after the JSON object.
2.  Your output MUST be a single JSON object, starting with `{` and ending with `}`.
3.  The root of the JSON object must have strictly adheres to the JSON schema, and must include all properties defined in the schema.
4.  Use the `comment` field in each action object to explain your thought process for choosing that action. This is for your internal monologue.
5.  The flow of actions should be logical. You can pause, speak, seek to rewatch interesting parts, and then continue. You can also ask the user with some questions.
6.  Make your speech (`text` in `SPEAK` actions) lively and in character as defined.
7.  The final action in the `actions` array MUST be `{ "action_type": "END_REACTION" }` or `{ "action_type": "ASK_USER" }`.

**JSON SCHEMA for your output:**"""
        + f"""
```json
{json_schema}
```
"""
    )


if __name__ == "__main__":
    character_settings = "ä½ å•Šå“ˆ"
    print(generate_reaction_script(character_settings))
</file>

<file path="src/ai_watch_buddy/connection_manager.py">
from fastapi import WebSocket

class ConnectionManager:
    """Manages active WebSocket connections."""

    def __init__(self):
        self.active_connections: dict[str, WebSocket] = {}

    async def connect(self, websocket: WebSocket, session_id: str):
        await websocket.accept()
        self.active_connections[session_id] = websocket

    def disconnect(self, session_id: str):
        if session_id in self.active_connections:
            del self.active_connections[session_id]

    async def send_json(self, session_id: str, data: dict):
        if session_id in self.active_connections:
            await self.active_connections[session_id].send_json(data)

    async def broadcast(self, message: str):
        for connection in self.active_connections.values():
            await connection.send_text(message)


manager = ConnectionManager()
</file>

<file path="src/ai_watch_buddy/pipeline.py">
import asyncio
from loguru import logger

from .ai_actions import Action
from .session import session_storage
from .action_generate import generate_actions


async def download_video(video_url: str, session_id: str) -> str:
    """
    Placeholder for the video download logic.
    In a real scenario, this would download the video from the URL
    and return the local file path.
    """
    logger.info(f"[{session_id}] Simulating video download for: {video_url}")
    await asyncio.sleep(2)  # Simulate I/O bound task
    local_path = f"/tmp/videos/{session_id}_video.mp4"  # Dummy path for the prototype
    logger.info(f"[{session_id}] Video 'downloaded' to: {local_path}")
    return local_path


async def run_action_generation_pipeline(session_id: str) -> None:
    """
    Generates actions for the video and puts them into the session's queue.
    This function is now a pure "producer".
    """
    session = session_storage.get(session_id)
    if not session or not session.local_video_path:
        logger.error(
            f"[{session_id}] Cannot run action generation: session or local_video_path not found."
        )
        if session:
            await session.action_queue.put(
                {
                    "type": "processing_error",
                    "error_code": "PIPELINE_SETUP_FAILED",
                    "message": "Session or video path not found.",
                }
            )
        return

    try:
        session.status = "generating_actions"
        logger.info(f"[{session_id}] Starting action generation...")

        actions_generated_count = 0
        async for action in generate_actions(
            video_path=session.local_video_path,
            start_time=0.0,  # è¿™é‡Œçš„å‚æ•°å¯ä»¥ä» session ä¸­è·å–
            character_prompt=f"Character ID: {session.character_id}",
        ):
            # å…³é”®æ”¹åŠ¨ï¼šå°† action æ”¾å…¥é˜Ÿåˆ—ï¼Œè€Œä¸æ˜¯ç›´æ¥å‘é€
            await session.action_queue.put(action)
            actions_generated_count += 1
            logger.info(
                f"[{session_id}] Put action into queue: {action.action_type} at {action.trigger_timestamp}s"
            )

        logger.info(
            f"[{session_id}] Action generation completed. Total actions put in queue: {actions_generated_count}"
        )

    except Exception as e:
        logger.error(
            f"[{session_id}] Error during action generation: {e}", exc_info=True
        )
        session.status = "error"
        session.processing_error = str(e)
        # å‘ç”Ÿé”™è¯¯æ—¶ï¼Œä¹Ÿå‘é˜Ÿåˆ—æ”¾å…¥ä¸€ä¸ªé”™è¯¯ä¿¡æ¯
        await session.action_queue.put(
            {
                "type": "processing_error",
                "error_code": "ACTION_GENERATION_FAILED",
                "message": f"Failed to generate actions for the video: {e}",
            }
        )
    finally:
        # å…³é”®ä¸€æ­¥ï¼šå‘é€ä¸€ä¸ªâ€œå“¨å…µâ€å€¼ (sentinel value)
        # è¿™å°±åƒæ˜¯ä¿¡ä»¶çš„æœ«å°¾æ ‡è®°ï¼Œå‘Šè¯‰æ¶ˆè´¹è€…ï¼šâ€œæ²¡æœ‰æ›´å¤šä¿¡ä»¶äº†â€ã€‚
        # æˆ‘ä»¬ç”¨ None æ¥ä½œä¸ºè¿™ä¸ªå“¨å…µã€‚
        if session:
            await session.action_queue.put(None)


async def initial_pipeline(session_id: str) -> None:
    """
    The initial background task that runs when a session is created.
    It downloads the video and then triggers the action generation.
    """
    session = session_storage.get(session_id)
    if not session:
        logger.error(f"[{session_id}] Initial pipeline failed: session not found.")
        return

    try:
        # Step 1: Download video
        session.status = "downloading_video"
        local_video_path = await download_video(session.video_url, session_id)
        session.local_video_path = local_video_path
        session.status = "video_ready"

        # 2. è§†é¢‘å‡†å¤‡å°±ç»ªåï¼Œå°†çŠ¶æ€æ›´æ–°ä¸º session_ready
        # è¿™ä¸ªçŠ¶æ€ç°åœ¨å‘Šè¯‰ websocket ç«¯ï¼Œå¯ä»¥å¼€å§‹ä»é˜Ÿåˆ—é‡Œå–ä¸œè¥¿äº†
        session.status = "session_ready"

        # 3. åœ¨åå°å¼€å§‹è¿è¡Œ action ç”Ÿæˆï¼ˆç”Ÿäº§è€…ï¼‰
        # æ³¨æ„ï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œåªæ˜¯å¯åŠ¨å®ƒï¼Œå¹¶ä¸ä¼šç­‰å¾…å®ƒå®Œæˆ
        asyncio.create_task(run_action_generation_pipeline(session_id))

    except Exception as e:
        logger.error(
            f"[{session_id}] Error during initial pipeline: {e}", exc_info=True
        )
        session.status = "error"
        session.processing_error = str(e)
        # å¦‚æœåˆå§‹æµç¨‹å°±å¤±è´¥äº†ï¼Œä¹Ÿå¾€é˜Ÿåˆ—é‡Œæ”¾ä¸ªé”™è¯¯ä¿¡æ¯å’Œç»“æŸæ ‡è®°
        if session:
            await session.action_queue.put(
                {
                    "type": "processing_error",
                    "error_code": "INITIAL_PIPELINE_FAILED",
                    "message": f"Failed during the initial setup: {e}",
                }
            )
            await session.action_queue.put(None)
</file>

<file path="src/ai_watch_buddy/server.py">
import asyncio
import uuid
from loguru import logger

from fastapi import (
    FastAPI,
    WebSocket,
    BackgroundTasks,
    HTTPException,
    status,
    WebSocketDisconnect,
)
from pydantic import BaseModel

from .session import SessionState, session_storage
from .pipeline import initial_pipeline
from .ai_actions import Action
from .connection_manager import manager

app = FastAPI()


# --- Data Models for API ---
class SessionCreateRequest(BaseModel):
    video_url: str
    start_time: float = 0.0
    end_time: float | None = None
    text: str | None = None
    character_id: str
    user_id: str | None = None


class SessionCreateResponse(BaseModel):
    session_id: str


class ErrorResponse(BaseModel):
    error: str
    message: str


# --- Connection Management ---
# The ConnectionManager is now in its own file (connection_manager.py)
# to prevent circular dependencies. The `manager` instance is imported from there.


# --- API Endpoint ---
@app.post(
    "/api/v1/sessions",
    status_code=status.HTTP_202_ACCEPTED,
    response_model=SessionCreateResponse,
)
async def create_session(
    request: SessionCreateRequest, background_tasks: BackgroundTasks
):
    """
    Creates a new watching session, starts background processing,
    and returns a session_id.
    """
    session_id = f"ses_{uuid.uuid4().hex[:16]}"

    # Create the session state object and store it
    session = SessionState(
        session_id=session_id,
        character_id=request.character_id,
        video_url=request.video_url,
    )
    session_storage[session_id] = session

    # Start the processing pipeline in the background
    background_tasks.add_task(initial_pipeline, session_id=session_id)

    logger.info(f"Accepted session {session_id} for video {request.video_url}")
    return SessionCreateResponse(session_id=session_id)


# --- WebSocket Endpoint (Major Refactor) ---


async def websocket_sender(websocket: WebSocket, session: SessionState):
    """
    æ¶ˆè´¹è€…åç¨‹ï¼šä»é˜Ÿåˆ—ä¸­è·å– action å¹¶å‘é€ç»™å®¢æˆ·ç«¯ã€‚
    """
    # é¦–å…ˆï¼Œç­‰å¾…ç›´åˆ° session å‡†å¤‡å°±ç»ª
    while session.status != "session_ready" and session.status != "error":
        await asyncio.sleep(0.1)

    # å¦‚æœ session åœ¨è¿æ¥æ—¶å·²ç»å‡ºé”™ï¼Œç›´æ¥å‘é€é”™è¯¯å¹¶å…³é—­
    if session.status == "error":
        await websocket.send_json(
            {
                "type": "processing_error",
                "error_code": "INITIAL_PIPELINE_FAILED",
                "message": session.processing_error or "Unknown error during setup",
            }
        )
        return

    # å‘é€ session_ready æ¶ˆæ¯ï¼Œé€šçŸ¥å‰ç«¯å¯ä»¥å¼€å§‹äº¤äº’äº†
    await websocket.send_json({"type": "session_ready"})
    logger.info(f"[{session.session_id}] Sent 'session_ready' to client.")

    # è¿›å…¥ä¸»å¾ªç¯ï¼Œä»é˜Ÿåˆ—ä¸­è·å–å¹¶å‘é€æ•°æ®
    while True:
        # å…³é”®ï¼šéé˜»å¡åœ°ç­‰å¾…é˜Ÿåˆ—ä¸­çš„ä¸‹ä¸€é¡¹
        item = await session.action_queue.get()

        # æ£€æŸ¥æ˜¯å¦æ˜¯å“¨å…µå€¼ (None)
        if item is None:
            logger.info(
                f"[{session.session_id}] Sentinel (None) received from queue. Closing sender task."
            )
            break  # æ”¶åˆ°å“¨å…µï¼Œé€€å‡ºå¾ªç¯

        # æ ¹æ® item ç±»å‹å‘é€æ¶ˆæ¯
        if isinstance(item, Action):
            await websocket.send_json(
                {"type": "ai_action", "action": item.model_dump(mode="json")}
            )
        elif isinstance(item, dict) and item.get("type") == "processing_error":
            await websocket.send_json(item)

        # æ ‡è®°ä»»åŠ¡å®Œæˆï¼Œè¿™å¯¹äºé˜Ÿåˆ—å¤§å°ç®¡ç†å¾ˆé‡è¦
        session.action_queue.task_done()


async def websocket_receiver(websocket: WebSocket, session: SessionState):
    """
    æ¥æ”¶è€…åç¨‹ï¼šç›‘å¬æ¥è‡ªå®¢æˆ·ç«¯çš„æ¶ˆæ¯ã€‚
    """
    async for message in websocket.iter_json():
        msg_type = message.get("type")
        logger.info(
            f"[{session.session_id}] Received message from client: type={msg_type}, data={message}"
        )
        # åœ¨è¿™é‡Œå¤„ç†å®¢æˆ·ç«¯å‘æ¥çš„æ¶ˆæ¯ï¼Œä¾‹å¦‚ï¼š
        # if msg_type == "timestamp_update":
        #     # ... å¤„ç†æ—¶é—´æˆ³æ›´æ–° ...
        # elif msg_type == "user_response":
        #     # ... å¤„ç†ç”¨æˆ·å¯¹ AI é—®é¢˜çš„å›ç­” ...


@app.websocket("/ws/{session_id}")
async def websocket_endpoint(websocket: WebSocket, session_id: str):
    """
    ä¸» WebSocket ç«¯ç‚¹ï¼Œç®¡ç†å‘é€è€…å’Œæ¥æ”¶è€…çš„ç”Ÿå‘½å‘¨æœŸã€‚
    """
    session = session_storage.get(session_id)
    if not session:
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
        logger.warning(f"WebSocket connection rejected for unknown session: {session_id}")
        return

    await manager.connect(websocket, session_id)
    logger.info(f"[{session_id}] WebSocket connection established.")

    # åˆ›å»ºå‘é€è€…å’Œæ¥æ”¶è€…ä»»åŠ¡
    sender_task = asyncio.create_task(websocket_sender(websocket, session))
    receiver_task = asyncio.create_task(websocket_receiver(websocket, session))

    try:
        # ä½¿ç”¨ asyncio.gather ç­‰å¾…ä¸¤ä¸ªä»»åŠ¡ä¸­çš„ä»»ä½•ä¸€ä¸ªå®Œæˆ
        # `return_exceptions=False` æ„å‘³ç€å¦‚æœä»»ä½•ä¸€ä¸ªä»»åŠ¡å´©æºƒï¼Œ`gather` ä¼šç«‹å³ä¼ æ’­å¼‚å¸¸
        done, pending = await asyncio.wait(
            [sender_task, receiver_task],
            return_when=asyncio.FIRST_COMPLETED,
        )

        # å–æ¶ˆä»åœ¨è¿è¡Œçš„ä»»åŠ¡ï¼Œç¡®ä¿å¹²å‡€åœ°é€€å‡º
        for task in pending:
            task.cancel()

    except WebSocketDisconnect:
        logger.info(f"[{session_id}] Client disconnected.")
    except Exception as e:
        logger.error(
            f"[{session_id}] An error occurred in the websocket endpoint: {e}",
            exc_info=True,
        )
    finally:
        # ç¡®ä¿æ‰€æœ‰ä»»åŠ¡éƒ½è¢«å–æ¶ˆ
        if not sender_task.done():
            sender_task.cancel()
        if not receiver_task.done():
            receiver_task.cancel()

        manager.disconnect(session_id)
        logger.info(f"[{session_id}] WebSocket connection closed and cleaned up.")
</file>

<file path="src/ai_watch_buddy/session.py">
import asyncio
from typing import Literal


class SessionState:
    """Holds the state for a single watching session."""

    def __init__(self, session_id: str, character_id: str, video_url: str):
        self.session_id = session_id
        self.character_id = character_id
        self.video_url = video_url
        self.local_video_path: str | None = None
        self.status: Literal[
            "created",
            "downloading_video",
            "video_ready",
            "generating_actions",
            "session_ready",
            "error",
        ] = "created"
        self.processing_error: str | None = None

        # å…³é”®æ”¹åŠ¨ï¼šä¸ºæ¯ä¸ª session å®ä¾‹åˆ›å»ºä¸€ä¸ª asyncio.Queue
        # è¿™ä¸ªé˜Ÿåˆ—å°†ä½œä¸ºç”Ÿäº§è€…ï¼ˆpipelineï¼‰å’Œæ¶ˆè´¹è€…ï¼ˆwebsocketï¼‰ä¹‹é—´çš„æ¡¥æ¢
        self.action_queue: asyncio.Queue = asyncio.Queue()


# A simple in-memory "database" for sessions
# This dictionary is now the single source of truth for all session states.
session_storage: dict[str, SessionState] = {}
</file>

<file path=".gitignore">
# Python-generated files
__pycache__/
*.py[oc]
build/
dist/
wheels/
*.egg-info

# Virtual environments
.venv
</file>

<file path=".python-version">
3.13
</file>

<file path="src/ai_watch_buddy/action_generate.py">
import json
import asyncio
from collections.abc import AsyncGenerator
from json_repair import repair_json
from pydantic import ValidationError, TypeAdapter
from .ai_actions import Action, ActionScript

# ==============================
sample_json = """
    [
  {
    "id": "e0b02f90-8452-442c-a28a-77c8e8749c95",
    "trigger_timestamp": 0.5,
    "comment": "å¼€å¹•é›·å‡»ï¼Œå…ˆè¡¨è¾¾ä¸€ä¸‹éœ‡æƒŠï¼Œé¡ºä¾¿åæ§½ä¸€ä¸‹è¿™ä¸ªç¦»è°±çš„æ ‡é¢˜ã€‚",
    "action_type": "SPEAK",
    "text": "å•Šï¼Ÿç­‰ä¸€ä¸‹ï¼ŒUCLAè®¡ç®—æœºç¡•å£«...åœ¨å­ŸåŠ æ‹‰ä¸Šå­¦ï¼Ÿè¿™æ˜¯ä»€ä¹ˆåœ°ç‹±å¼€å±€å•Šå–‚ï¼",
    "pause_video": true
  },
  {
    "id": "18f75c2e-4b48-4389-9e8c-529a9e3a62d0",
    "trigger_timestamp": 7,
    "comment": "ç»å…¸æ’æ²³æ°´ï¼Œå¿…é¡»å¾—åæ§½ä¸€ä¸‹ï¼Œçªå‡ºä¸€ä¸ªè…¹é»‘ã€‚",
    "action_type": "SPEAK",
    "text": "èµ·åºŠç¬¬ä¸€ä»¶äº‹ï¼Œå…ˆæ¥ä¸€æ¯çº¯å¤©ç„¶çš„æ’æ²³èŒ¶ï¼Œè¿™æ‰æ˜¯çœŸæ­£çš„å¤§å­¦ç‰²å•Šï¼ä½ çœ‹ä»–å–å®Œï¼Œçœ¼ç¥éƒ½æ¸…æ¾ˆäº†è®¸å¤šå‘¢ï¼ˆå¤§æ¦‚ï¼‰ã€‚",
    "pause_video": true
  },
  {
    "id": "c138fd94-912f-4c12-9c3f-c80f082e6d6c",
    "trigger_timestamp": 14,
    "comment": "å¯¹å†·æ°´æµ‡å¤´å’Œèº«æè¿›è¡Œè¯„è®ºï¼Œå¸¦ä¸€ç‚¹èŠ±ç—´çš„æ„Ÿè§‰ï¼Œä½†è¿˜æ˜¯ä»¥æç¬‘ä¸ºä¸»ã€‚",
    "action_type": "SPEAK",
    "text": "å“‡å“¦ï¼Œå†·æ°´å–·é†’èº«ä½“...é¡ºä¾¿ç§€ä¸€ä¸‹è…¹è‚Œæ˜¯å§ï¼Ÿæ‡‚äº†ï¼Œè¿™æ˜¯é«˜æç”Ÿçš„ç‹¬ç‰¹å«é†’æœåŠ¡ã€‚",
    "pause_video": false
  },
  {
    "id": "a92e10c7-e547-4f81-80a9-197147b30c33",
    "trigger_timestamp": 21,
    "comment": "çœ‹åˆ°ä»–åƒä¸œè¥¿çš„ç—›è‹¦é¢å…·å’Œè¢«å¤§å§å¼ºåˆ¶å–‚é£Ÿï¼Œå¿ä¸ä½ç¬‘å‡ºæ¥ï¼Œå¹¶è¿›è¡Œè…¹é»‘åæ§½ã€‚",
    "action_type": "PAUSE",
    "duration_seconds": 6
  },
  {
    "id": "d4c9d5d8-0f66-4e4f-b1e7-91f94d93026f",
    "trigger_timestamp": 22,
    "comment": "çœ‹åˆ°ä»–åƒä¸œè¥¿çš„ç—›è‹¦é¢å…·å’Œè¢«å¤§å§å¼ºåˆ¶å–‚é£Ÿï¼Œå¿ä¸ä½ç¬‘å‡ºæ¥ï¼Œå¹¶è¿›è¡Œè…¹é»‘åæ§½ã€‚",
    "action_type": "SPEAK",
    "text": "å“ˆå“ˆå“ˆå“ˆï¼Œä½ çœ‹ä»–é‚£ä¸ªè¡¨æƒ…ï¼Œå¥½åƒåœ¨è¯´â€œè¿™ç©æ„å„¿åƒäº†çœŸçš„ä¸ä¼šå–·å°„å—ï¼Ÿâ€ ç»“æœå¤§å§ç›´æ¥ä¸Šæ‰‹äº†ï¼ŒæŒ‘é£Ÿå¯ä¸æ˜¯å¥½å­©å­å“¦~",
    "pause_video": true
  },
  {
    "id": "f5f5c3b9-a4e1-45d2-ac53-06639c05e197",
    "trigger_timestamp": 36,
    "comment": "å¯¹â€œåœ°é“å†²æµªâ€è¿™ä¸ªç¦»è°±çš„å¯¼èˆªç»“æœè¿›è¡Œåæ§½ï¼Œå¼•å‡ºæ¸¸æˆæ¢—ã€‚",
    "action_type": "SPEAK",
    "text": "ç­‰ä¼šå„¿ï¼Ÿåœ°é“å†²æµªï¼Ÿè¿™AIæ˜¯æ‡‚ä¸Šå­¦çš„ï¼Œç›´æ¥å¸¦ä½ ç©çœŸäººç‰ˆSubway Surfersæ˜¯å§ï¼",
    "pause_video": true
  },
  {
    "id": "1e7e4f32-7c64-469b-9877-3e839e92b3a9",
    "trigger_timestamp": 43,
    "comment": "ä»–æ»‘å€’çš„ç¬é—´å¤ªæç¬‘äº†ï¼Œå¿…é¡»å¾—åæ§½ä¸€ä¸‹AIçš„é©¬åç‚®è¡Œä¸ºã€‚",
    "action_type": "REPLAY_SEGMENT",
    "start_timestamp": 41,
    "end_timestamp": 44,
    "post_replay_behavior": "STAY_PAUSED_AT_END"
  },
  {
    "id": "b3b19b22-8d77-4c07-955a-c635df08272f",
    "trigger_timestamp": 44,
    "comment": "ä»–æ»‘å€’çš„ç¬é—´å¤ªæç¬‘äº†ï¼Œå¿…é¡»å¾—åæ§½ä¸€ä¸‹AIçš„é©¬åç‚®è¡Œä¸ºã€‚",
    "action_type": "SPEAK",
    "text": "â€œå°å¿ƒæ»‘å€’â€...å™—ï¼ä½ å’‹ä¸æ—©è¯´å•Šï¼è¿™AIçš„å»¶è¿Ÿæ¯”æˆ‘è¿˜é«˜ï¼",
    "pause_video": true
  },
  {
    "id": "8a7c2b0d-2e6f-4228-9711-20a23d9a334f",
    "trigger_timestamp": 58,
    "comment": "çœ‹åˆ°ä¸¤è½¦äº¤æ±‡çš„æƒŠé™©åœºé¢ï¼Œå‘å‡ºå¤¸å¼ çš„æƒŠå‘¼ã€‚",
    "action_type": "SPEAK",
    "text": "å§æ§½ï¼å§æ§½ï¼å¯¹é¢æ¥è½¦äº†ï¼æé™è¿åŠ¨å•Šè¿™æ˜¯ï¼å¤ªåˆºæ¿€äº†ï¼",
    "pause_video": false
  },
  {
    "id": "4d3f56d0-61d0-4d57-b4d4-5309d9492169",
    "trigger_timestamp": 76,
    "comment": "çœ‹åˆ°ä»–åœ¨è½¦é¡¶èººç€å†™ä½œä¸šï¼Œåæ§½è¿™ç§å­¦éœ¸è¡Œä¸ºã€‚",
    "action_type": "SPEAK",
    "text": "ä¸æ˜¯ï¼Œå“¥ä»¬ï¼Œä½ åœ¨ç«è½¦é¡¶ä¸Šç©ä¸›æ—é£è·ƒï¼Œé¡ºä¾¿å†™ä½œä¸šï¼Ÿè¿™å°±æ˜¯å·ç‹çš„æ—¥å¸¸å—ï¼Ÿ",
    "pause_video": true
  },
  {
    "id": "2c2e0b1d-8452-4414-9989-d4c398328c11",
    "trigger_timestamp": 85,
    "comment": "çœ‹åˆ°è·¯äººåæ§½â€œç¥åº™é€ƒäº¡â€ï¼Œè§‰å¾—è¿™ä¸ªæ¢—å¤ªå¦™äº†ï¼Œå¿…é¡»æš‚åœåˆ†äº«ä¸€ä¸‹ã€‚",
    "action_type": "SPEAK",
    "text": "â€œä½ æè¿™ç©ç¥åº™é€ƒäº¡å‘¢ï¼Ÿâ€ å“ˆå“ˆå“ˆå“ˆï¼Œå®˜æ–¹åæ§½æœ€ä¸ºè‡´å‘½ï¼å¤ªå¯¹äº†å“¥ï¼Œå°±æ˜¯è¿™ä¸ªå‘³å„¿ï¼",
    "pause_video": true
  },
  {
    "id": "a5d89e5a-7e3f-4e0e-af10-2f3b7d14e0f5",
    "trigger_timestamp": 94,
    "comment": "å¯¹è½¦é¡¶å–ä¸œè¥¿ä»¥åŠé€åŒ…å­çš„è¡Œä¸ºè¡¨ç¤ºæƒŠå¹å’Œæç¬‘è¯„è®ºã€‚",
    "action_type": "SPEAK",
    "text": "ç«è½¦é¡¶ä¸Šè¿˜æœ‰ç§»åŠ¨å°å–éƒ¨ï¼ŸæœåŠ¡ä¹Ÿå¤ªå‘¨åˆ°äº†å§ï¼å¤§å“¥è¿˜ç›´æ¥é€ä»–äº†ï¼Œå­ŸåŠ æ‹‰çœŸæ˜¯å¤ªæœ‰...äººæƒ…å‘³äº†ï¼",
    "pause_video": true
  },
  {
    "id": "e6f47b22-1d59-4d57-8d0f-4e12c1d3c001",
    "trigger_timestamp": 122,
    "comment": "çœ‹åˆ°ä»–ç”¨æ‰‹æœºè¿œç¨‹æ§åˆ¶ç”µè„‘äº¤ä½œä¸šï¼Œä»¥ä¸€ç§å¤¸å¼ çš„ã€ä»¿ä½›çœ‹å¹¿å‘Šçš„è¯­æ°”æ¥åæ§½è¿™ä¸ªç¡¬æ ¸æ“ä½œã€‚",
    "action_type": "REPLAY_SEGMENT",
    "start_timestamp": 118,
    "end_timestamp": 122,
    "post_replay_behavior": "STAY_PAUSED_AT_END"
  },
  {
    "id": "9b1e5a8f-2f88-4f1e-9a99-f2e7c3b2d18d",
    "trigger_timestamp": 122.5,
    "comment": "çœ‹åˆ°ä»–ç”¨æ‰‹æœºè¿œç¨‹æ§åˆ¶ç”µè„‘äº¤ä½œä¸šï¼Œä»¥ä¸€ç§å¤¸å¼ çš„ã€ä»¿ä½›çœ‹å¹¿å‘Šçš„è¯­æ°”æ¥åæ§½è¿™ä¸ªç¡¬æ ¸æ“ä½œã€‚",
    "action_type": "SPEAK",
    "text": "æˆ‘æ‡‚äº†ï¼åŸæ¥æ˜¯å¹¿å‘Šï¼åœ¨å‘½æ‚¬ä¸€çº¿çš„æ—¶å€™ï¼Œç”¨æ‰‹æœºè¿œç¨‹äº¤ä½œä¸šï¼Œè¿™åŠŸèƒ½ä¹Ÿå¤ªç¡¬æ ¸äº†å§ï¼åªè¦æ€æƒ³ä¸æ»‘å¡ï¼ŒåŠæ³•æ€»æ¯”å›°éš¾å¤šï¼",
    "pause_video": true
  },
  {
    "id": "f8a09b3c-6e7d-411a-8b1e-9a7c8d9e2b1f",
    "trigger_timestamp": 150,
    "comment": "çœ‹åˆ°ä»–æˆåŠŸäº¤å®Œä½œä¸šï¼Œå‘è¡¨æœ€åçš„æ„Ÿæ…¨ï¼Œå¹¶ä¸è§‚ä¼—äº’åŠ¨ã€‚",
    "action_type": "SPEAK",
    "text": "Mission Accomplishedï¼ä»»åŠ¡å®Œæˆï¼çœŸæ˜¯æƒŠå¿ƒåŠ¨é­„çš„ä¸Šå­¦è·¯å•Šã€‚å‘ï¼Œè§‚ä¼—å§¥çˆ·ä»¬ï¼Œä½ ä»¬ä¸Šå­¦çš„æ—¶å€™æœ‰è¿™ä¹ˆåˆºæ¿€å—ï¼Ÿ",
    "pause_video": true
  },
  {
    "id": "3a09e1d8-4f3b-4c2d-9e1a-8f7b6c5d4e3f",
    "trigger_timestamp": 158,
    "comment": "è§†é¢‘ç»“æŸï¼Œå‘å‡ºæœ€åçš„ç»“æŸè¯­ã€‚",
    "action_type": "END_REACTION"
  }
]"""
# ==============================


# è¿™æ˜¯ä¸€ä¸ªæ¨¡æ‹Ÿ LLM å“åº”çš„å‡½æ•°ï¼Œå®ƒä¼šæµå¼åœ°è¿”å›æˆ‘ä»¬é‚£ä¸ª JSON æ•°ç»„ã€‚
# åœ¨çœŸå®åœºæ™¯ä¸­ï¼Œä½ ä¼šç”¨ httpx å»è¯·æ±‚çœŸå®çš„ LLM APIã€‚
async def fake_llm_stream_response() -> AsyncGenerator[str, None]:
    """
    æ¨¡æ‹Ÿ LLM API çš„æµå¼å“åº”ã€‚
    ä¸ºäº†æ–¹ä¾¿æµ‹è¯•ï¼Œæˆ‘ä»¬å°†å®Œæ•´çš„ JSON åˆ†å—è¿”å›ã€‚
    """

    # æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿå’Œåˆ†å—ä¼ è¾“
    chunk_size = 50
    for i in range(0, len(sample_json), chunk_size):
        yield sample_json[i : i + chunk_size]
        await asyncio.sleep(0.02)


async def generate_actions(
    video_path: str, start_time: float, character_prompt: str
) -> AsyncGenerator[Action, None]:
    """
    è°ƒç”¨ LLM ç”ŸæˆåŠ¨ä½œå¹¶ä»¥æµå¼æ–¹å¼è¿”å›ã€‚

    è¿™ä¸ªå¼‚æ­¥ç”Ÿæˆå™¨æ˜¯æ ¸å¿ƒå¤„ç†ç®¡é“ï¼š
    1.  ä» LLM API (æ¨¡æ‹Ÿçš„) è·å–æµå¼å“åº”ã€‚
    2.  å°†æ‰€æœ‰æ–‡æœ¬å—ç»„è£…æˆä¸€ä¸ªå®Œæ•´çš„ JSON æ•°ç»„å­—ç¬¦ä¸²ã€‚
    3.  å¯¹ JSON å­—ç¬¦ä¸²è¿›è¡Œä¿®å¤ï¼ˆå¦‚æœéœ€è¦ï¼‰å’ŒéªŒè¯ã€‚
    4.  éå†æ•°ç»„ï¼Œå°†éªŒè¯é€šè¿‡çš„ Action å¯¹è±¡é€ä¸ª yield å‡ºæ¥ã€‚

    :param video_path: è§†é¢‘æ–‡ä»¶è·¯å¾„ (å½“å‰æœªä½¿ç”¨ï¼Œä½†ä¸ºæœªæ¥ä¿ç•™)
    :param start_time: è§†é¢‘å¼€å§‹æ—¶é—´ (å½“å‰æœªä½¿ç”¨ï¼Œä½†ä¸ºæœªæ¥ä¿ç•™)
    :param character_prompt: è§’è‰²æç¤º (å½“å‰æœªä½¿ç”¨ï¼Œä½†ä¸ºæœªæ¥ä¿ç•™)
    :return: ä¸€ä¸ªå¼‚æ­¥ç”Ÿæˆå™¨ï¼Œç”¨äºäº§å‡º Action å¯¹è±¡ã€‚
    """
    # åœ¨çœŸå®åº”ç”¨ä¸­ï¼Œä½ ä¼šç”¨ video_path, start_time, character_prompt
    # æ¥æ„å»ºè¯·æ±‚å¹¶è°ƒç”¨çœŸå®çš„ LLM APIã€‚
    llm_stream = fake_llm_stream_response()

    # 1. æ”¶é›†æ‰€æœ‰æ•°æ®å—
    full_response = "".join([chunk async for chunk in llm_stream])

    # 2. å°è¯•è§£ææ•´ä¸ª JSON æ•°ç»„
    try:
        # é¦–å…ˆå°è¯•ç›´æ¥è§£æ
        actions_data = json.loads(full_response)
    except json.JSONDecodeError:
        print("âš ï¸è­¦å‘Š: JSON è§£æå¤±è´¥ï¼Œå°è¯•ä¿®å¤...")
        try:
            # å¦‚æœå¤±è´¥ï¼Œä½¿ç”¨ json_repair
            repaired_json_str = repair_json(full_response)
            actions_data = json.loads(repaired_json_str)
            print("âœ… JSON æˆåŠŸä¿®å¤ï¼")
        except Exception as e:
            print(f"âŒ é”™è¯¯: ä¿®å¤åä¾ç„¶æ— æ³•è§£æ JSON: {e}")
            return  # æ— æ³•ç»§ç»­ï¼Œç›´æ¥è¿”å›

    if not isinstance(actions_data, list):
        print(f"âŒ é”™è¯¯: é¢„æœŸé¡¶å±‚ç»“æ„æ˜¯ JSON æ•°ç»„ï¼Œä½†å¾—åˆ°çš„æ˜¯ {type(actions_data)}")
        return

    # 3. éå†æ•°ç»„ï¼ŒéªŒè¯å¹¶ yield æ¯ä¸ª action
    for i, action_dict in enumerate(actions_data):
        try:
            # å¯¹äº Union ç±»å‹ï¼Œæˆ‘ä»¬ä½¿ç”¨ TypeAdapter æ¥éªŒè¯
            validated_action = TypeAdapter(Action).validate_python(action_dict)
            yield validated_action
        except ValidationError as e:
            print(
                f"âŒ é”™è¯¯: ç¬¬ {i+1} ä¸ª Action éªŒè¯å¤±è´¥ï¼Œå·²è·³è¿‡ã€‚æ•°æ®: {action_dict}, é”™è¯¯: {e}"
            )


if __name__ == "__main__":

    async def main():
        # Example usage
        video_path = "example_video.mp4"
        start_time = 0.0
        character_prompt = "A humorous AI character reacting to a video."

        print("--- Streaming Actions ---")
        action_count = 0
        async for action in generate_actions(video_path, start_time, character_prompt):
            action_count += 1
            print(
                f"Action {action_count}: {action.model_dump_json(indent=2)}", flush=True
            )
            await asyncio.sleep(1)
        print(f"\n--- End of Stream ---")
        print(f"Total actions received: {action_count}")

    asyncio.run(main())
</file>

<file path="schema.json">
{
  "$defs": {
    "AskUser": {
      "properties": {
        "id": {
          "description": "ä¸€å€‹å”¯ä¸€çš„å‹•ä½œ IDï¼Œå¯ä»¥ç”¨ UUID ç”Ÿæˆ",
          "title": "Id",
          "type": "string"
        },
        "trigger_timestamp": {
          "description": "æ­¤å‹•ä½œåœ¨å½±ç‰‡ä¸­çš„è§¸ç™¼æ™‚é–“é» (ç§’)",
          "title": "Trigger Timestamp",
          "type": "number"
        },
        "comment": {
          "description": "AI åšå‡ºæ­¤åæ‡‰çš„ç°¡è¦ç†ç”±",
          "title": "Comment",
          "type": "string"
        },
        "action_type": {
          "const": "ASK_USER",
          "title": "Action Type",
          "type": "string"
        }
      },
      "required": [
        "id",
        "trigger_timestamp",
        "comment",
        "action_type"
      ],
      "title": "AskUser",
      "type": "object"
    },
    "EndReaction": {
      "properties": {
        "id": {
          "description": "ä¸€å€‹å”¯ä¸€çš„å‹•ä½œ IDï¼Œå¯ä»¥ç”¨ UUID ç”Ÿæˆ",
          "title": "Id",
          "type": "string"
        },
        "trigger_timestamp": {
          "description": "æ­¤å‹•ä½œåœ¨å½±ç‰‡ä¸­çš„è§¸ç™¼æ™‚é–“é» (ç§’)",
          "title": "Trigger Timestamp",
          "type": "number"
        },
        "comment": {
          "description": "AI åšå‡ºæ­¤åæ‡‰çš„ç°¡è¦ç†ç”±",
          "title": "Comment",
          "type": "string"
        },
        "action_type": {
          "const": "END_REACTION",
          "default": "END_REACTION",
          "title": "Action Type",
          "type": "string"
        }
      },
      "required": [
        "id",
        "trigger_timestamp",
        "comment"
      ],
      "title": "EndReaction",
      "type": "object"
    },
    "PauseAction": {
      "properties": {
        "id": {
          "description": "ä¸€å€‹å”¯ä¸€çš„å‹•ä½œ IDï¼Œå¯ä»¥ç”¨ UUID ç”Ÿæˆ",
          "title": "Id",
          "type": "string"
        },
        "trigger_timestamp": {
          "description": "æ­¤å‹•ä½œåœ¨å½±ç‰‡ä¸­çš„è§¸ç™¼æ™‚é–“é» (ç§’)",
          "title": "Trigger Timestamp",
          "type": "number"
        },
        "comment": {
          "description": "AI åšå‡ºæ­¤åæ‡‰çš„ç°¡è¦ç†ç”±",
          "title": "Comment",
          "type": "string"
        },
        "action_type": {
          "const": "PAUSE",
          "default": "PAUSE",
          "title": "Action Type",
          "type": "string"
        },
        "duration_seconds": {
          "description": "æš«åœçš„æŒçºŒæ™‚é–“ (ç§’)",
          "title": "Duration Seconds",
          "type": "number"
        }
      },
      "required": [
        "id",
        "trigger_timestamp",
        "comment",
        "duration_seconds"
      ],
      "title": "PauseAction",
      "type": "object"
    },
    "ReplaySegmentAction": {
      "properties": {
        "id": {
          "description": "ä¸€å€‹å”¯ä¸€çš„å‹•ä½œ IDï¼Œå¯ä»¥ç”¨ UUID ç”Ÿæˆ",
          "title": "Id",
          "type": "string"
        },
        "trigger_timestamp": {
          "description": "æ­¤å‹•ä½œåœ¨å½±ç‰‡ä¸­çš„è§¸ç™¼æ™‚é–“é» (ç§’)",
          "title": "Trigger Timestamp",
          "type": "number"
        },
        "comment": {
          "description": "AI åšå‡ºæ­¤åæ‡‰çš„ç°¡è¦ç†ç”±",
          "title": "Comment",
          "type": "string"
        },
        "action_type": {
          "const": "REPLAY_SEGMENT",
          "default": "REPLAY_SEGMENT",
          "title": "Action Type",
          "type": "string"
        },
        "start_timestamp": {
          "description": "é‡çœ‹ç‰‡æ®µçš„é–‹å§‹æ™‚é–“(ç§’)",
          "title": "Start Timestamp",
          "type": "number"
        },
        "end_timestamp": {
          "description": "é‡çœ‹ç‰‡æ®µçš„çµæŸæ™‚é–“(ç§’)",
          "title": "End Timestamp",
          "type": "number"
        },
        "post_replay_behavior": {
          "default": "RESUME_FROM_ORIGINAL",
          "enum": [
            "RESUME_FROM_ORIGINAL",
            "STAY_PAUSED_AT_END"
          ],
          "title": "Post Replay Behavior",
          "type": "string"
        }
      },
      "required": [
        "id",
        "trigger_timestamp",
        "comment",
        "start_timestamp",
        "end_timestamp"
      ],
      "title": "ReplaySegmentAction",
      "type": "object"
    },
    "SeekAction": {
      "properties": {
        "id": {
          "description": "ä¸€å€‹å”¯ä¸€çš„å‹•ä½œ IDï¼Œå¯ä»¥ç”¨ UUID ç”Ÿæˆ",
          "title": "Id",
          "type": "string"
        },
        "trigger_timestamp": {
          "description": "æ­¤å‹•ä½œåœ¨å½±ç‰‡ä¸­çš„è§¸ç™¼æ™‚é–“é» (ç§’)",
          "title": "Trigger Timestamp",
          "type": "number"
        },
        "comment": {
          "description": "AI åšå‡ºæ­¤åæ‡‰çš„ç°¡è¦ç†ç”±",
          "title": "Comment",
          "type": "string"
        },
        "action_type": {
          "const": "SEEK",
          "default": "SEEK",
          "title": "Action Type",
          "type": "string"
        },
        "target_timestamp": {
          "description": "è¦è·³è½‰åˆ°çš„å½±ç‰‡æ™‚é–“é» (ç§’)",
          "title": "Target Timestamp",
          "type": "number"
        },
        "post_seek_behavior": {
          "default": "STAY_PAUSED",
          "enum": [
            "RESUME_PLAYBACK",
            "STAY_PAUSED"
          ],
          "title": "Post Seek Behavior",
          "type": "string"
        }
      },
      "required": [
        "id",
        "trigger_timestamp",
        "comment",
        "target_timestamp"
      ],
      "title": "SeekAction",
      "type": "object"
    }
  },
  "items": {
    "anyOf": [
      {
        "$ref": "#/$defs/PauseAction"
      },
      {
        "$ref": "#/$defs/SeekAction"
      },
      {
        "$ref": "#/$defs/ReplaySegmentAction"
      },
      {
        "$ref": "#/$defs/AskUser"
      },
      {
        "$ref": "#/$defs/EndReaction"
      }
    ]
  },
  "title": "ActionScript",
  "type": "array"
}
</file>

<file path="src/ai_watch_buddy/ai_actions.py">
import json
from typing import Literal
import numpy as np
from pydantic import BaseModel, Field, RootModel


# é€™æ˜¯ä¸€å€‹åŸºç¤æ¨¡å‹ï¼Œå®šç¾©äº†æ‰€æœ‰ Action çš„å…±æ€§
class BaseAction(BaseModel):
    model_config = {"arbitrary_types_allowed": True}

    # æ¯å€‹ Action éƒ½æ‡‰è©²æœ‰ä¸€å€‹ç¨ä¸€ç„¡äºŒçš„ IDï¼Œæ–¹ä¾¿è¿½è¹¤å’Œæ—¥èªŒè¨˜éŒ„
    id: str = Field(..., description="ä¸€å€‹å”¯ä¸€çš„å‹•ä½œ IDï¼Œå¯ä»¥ç”¨ UUID ç”Ÿæˆ")
    # é€™å€‹ Action åœ¨å½±ç‰‡çš„å“ªå€‹æ™‚é–“é»è¢«è§¸ç™¼ï¼Ÿé€™æ˜¯åæ‡‰çš„éŒ¨é»ã€‚
    trigger_timestamp: float = Field(..., description="æ­¤å‹•ä½œåœ¨å½±ç‰‡ä¸­çš„è§¸ç™¼æ™‚é–“é» (ç§’)")
    # ä¸€å€‹çµ¦é–‹ç™¼è€…çœ‹çš„å‚™è¨»ï¼Œè§£é‡‹ç‚ºä»€éº¼ AI æœƒåšé€™å€‹åæ‡‰ã€‚LLM ä¹Ÿæœƒå¡«å¯«å®ƒã€‚
    comment: str = Field(..., description="AI åšå‡ºæ­¤åæ‡‰çš„ç°¡è¦ç†ç”±")


# --- é–‹å§‹å®šç¾©å…·é«”çš„ Action é¡å‹ ---


# 1. èªªè©± (Speak)
class SpeakAction(BaseAction):
    action_type: Literal["SPEAK"] = "SPEAK"
    text: str = Field(..., description="AI è¦èªªçš„å…§å®¹")
    audio: np.ndarray | None = Field(
        None,
        description="AI èªªè©±çš„éŸ³é »æ•¸æ“šï¼Œç”±tts ç”Ÿæˆï¼Œä¸è¦å¡«å†™ã€‚",
    )
    # é€™å€‹å¸ƒæ—å€¼éå¸¸é—œéµï¼Œå®ƒæ±ºå®šäº†æ˜¯ã€Œç•«å¤–éŸ³ã€é‚„æ˜¯ã€Œæš«åœè§£èªªã€
    pause_video: bool = Field(
        default=True,
        description="èªªè©±æ™‚æ˜¯å¦éœ€è¦å…ˆæš«åœå½±ç‰‡ã€‚å¦‚æœç‚º trueï¼Œå‰‡åœ¨èªªè©±æœŸé–“å½±ç‰‡æœƒæš«åœï¼Œå¦å‰‡ï¼Œè¦–é »ä¸æœƒæš«åœï¼Œä¸€è¾¹è¯´è¯ï¼Œè§†é¢‘ä¼šä¸€è¾¹æ’­æ”¾ã€‚å¦‚æœå¥å­è¾ƒçŸ­ï¼Œä¸”ä¸‹ä¸€å¥è¯ç¦»çš„è¾ƒè¿œï¼Œå»ºè®®è®¾ç½®ä¸º falseï¼Œè¿™æ ·å¯ä»¥è®©è§†é¢‘æ›´è¿è´¯ã€‚",
    )


# 2. æš«åœ (Pause) - ç”¨æ–¼æ¨¡æ“¬æ€è€ƒã€é©šè¨ç­‰ç„¡è¨€çš„åæ‡‰
class PauseAction(BaseAction):
    action_type: Literal["PAUSE"] = "PAUSE"
    # æš«åœå¤šä¹…ï¼Ÿé€™çµ¦äºˆäº†ç²¾ç¢ºçš„ç¯€å¥æ§åˆ¶
    duration_seconds: float = Field(..., description="æš«åœçš„æŒçºŒæ™‚é–“ (ç§’)")


# 3. å½±ç‰‡æ§åˆ¶ (Video Control)
class SeekAction(BaseAction):
    action_type: Literal["SEEK"] = "SEEK"
    target_timestamp: float = Field(..., description="è¦è·³è½‰åˆ°çš„å½±ç‰‡æ™‚é–“é» (ç§’)")
    # è·³è½‰å¾Œåšä»€éº¼ï¼Ÿé€™å€‹å¾ˆé‡è¦ï¼
    # 'RESUME_PLAYBACK': è·³è½‰å¾Œç¹¼çºŒæ’­æ”¾
    # 'STAY_PAUSED': è·³åœåœ¨é‚£å€‹ç•«é¢ï¼Œç­‰å¾…ä¸‹ä¸€å€‹æŒ‡ä»¤
    post_seek_behavior: Literal["RESUME_PLAYBACK", "STAY_PAUSED"] = "STAY_PAUSED"


# 4. é‡çœ‹ç‰‡æ®µ (Replay Segment) - é€™æ˜¯ä¸€å€‹è¤‡åˆå‹•ä½œï¼Œä½†æˆ‘å€‘å°‡å…¶åŸå­åŒ–ï¼Œæ–¹ä¾¿ LLM ç”Ÿæˆ
class ReplaySegmentAction(BaseAction):
    action_type: Literal["REPLAY_SEGMENT"] = "REPLAY_SEGMENT"
    start_timestamp: float = Field(..., description="é‡çœ‹ç‰‡æ®µçš„é–‹å§‹æ™‚é–“(ç§’)")
    end_timestamp: float = Field(..., description="é‡çœ‹ç‰‡æ®µçš„çµæŸæ™‚é–“(ç§’)")
    # é‡çœ‹å®Œä¹‹å¾Œçš„è¡Œç‚ºï¼Œæ˜¯å›åˆ°åŸä¾†çš„åœ°æ–¹ï¼Œé‚„æ˜¯åœåœ¨ç‰‡æ®µçµå°¾ï¼Ÿ
    # 'RESUME_FROM_ORIGINAL': å›åˆ°è§¸ç™¼æ­¤å‹•ä½œçš„æ™‚é–“é»ç¹¼çºŒæ’­æ”¾
    # 'STAY_PAUSED_AT_END': åœåœ¨ end_timestamp è™•
    post_replay_behavior: Literal["RESUME_FROM_ORIGINAL", "STAY_PAUSED_AT_END"] = (
        "RESUME_FROM_ORIGINAL"
    )


# # 5. æ”¹è®Šè¡¨æƒ…/å‹•ä½œ (Emote) - é€™æ˜¯ Live2D é …ç›®çš„éˆé­‚ï¼
# class EmoteAction(BaseAction):
#     action_type: Literal["EMOTE"] = "EMOTE"
#     # è¡¨æƒ…åç¨±éœ€è¦èˆ‡ä½ çš„ Live2D æ¨¡å‹è³‡æºå°æ‡‰
#     expression: str = Field(
#         ...,
#         description="è¦åˆ‡æ›çš„ Live2D è¡¨æƒ…æˆ–å‹•ä½œï¼Œä¾‹å¦‚ 'Surprised', 'Thinking', 'Laughing'",
#     )
#     # è¡¨æƒ…æŒçºŒå¤šä¹…ï¼Ÿ0 è¡¨ç¤ºæ°¸ä¹…ï¼Œç›´åˆ°ä¸‹ä¸€å€‹ EmoteAction
#     duration_seconds: float = Field(
#         default=0, description="è¡¨æƒ…/å‹•ä½œçš„æŒçºŒæ™‚é–“ (ç§’)ï¼Œ0 è¡¨ç¤ºç›´åˆ°ä¸‹ä¸€å€‹è¡¨æƒ…è®ŠåŒ–"
#     )


# 6. å‘ç”¨æˆ·æé—® (Ask User) - å¯¦ç¾äº¤äº’çš„æ ¸å¿ƒã€‚å½“è¢«è°ƒç”¨ï¼Œæ§åˆ¶æƒäº¤è¿˜ç»™ç”¨æˆ·yun x
class AskUser(BaseAction):
    action_type: Literal["ASK_USER"]


class EndReaction(BaseAction):
    action_type: Literal["END_REACTION"] = "END_REACTION"
    # é€™å€‹ Action ç”¨æ–¼çµæŸç•¶å‰çš„åæ‡‰ï¼Œè®“ AI çŸ¥é“ä½•æ™‚çµæŸ
    # é€™å°æ–¼é•·æ™‚é–“çš„å½±ç‰‡åæ‡‰ç‰¹åˆ¥æœ‰ç”¨


# --- ä½¿ç”¨ Discriminated Union çµ„åˆæ‰€æœ‰ Action ---

# é€™ä¸€æ­¥æ˜¯ Pydantic V2 çš„ç²¾è¯æ‰€åœ¨
# æˆ‘å€‘å‘Šè¨´ Pydanticï¼Œæ‰€æœ‰ Action çš„è¯é›†ç”± 'action_type' é€™å€‹æ¬„ä½ä¾†å€åˆ†
Action = (
    SpeakAction | PauseAction | SeekAction | ReplaySegmentAction | AskUser | EndReaction
)  # | EmoteAction


# æœ€å¾Œï¼Œæˆ‘å€‘çš„ Action Script å°±æ˜¯ä¸€å€‹ Action çš„åˆ—è¡¨
# ä½¿ç”¨ RootModel å¯ä»¥è®“ Pydantic ç›´æ¥é©—è­‰ä¸€å€‹åˆ—è¡¨çš„æ ¹é¡å‹
class ActionScript(RootModel[list[Action]]):
    pass


if __name__ == "__main__":
    with open("schema.json", "w", encoding="utf-8") as f:
        json.dump(ActionScript.model_json_schema(), f, ensure_ascii=False, indent=2)
    print("Schema saved to schema.json")
</file>

<file path="main.py">
import uvicorn


def main():
    """
    Starts the AI Watch Buddy server.
    """
    print("Starting AI Watch Buddy server...")
    # The 'app' object is imported from server.py
    # "ai_watch_buddy.server:app" tells uvicorn where to find the FastAPI instance
    uvicorn.run("src.ai_watch_buddy.server:app", host="0.0.0.0", port=8000, reload=True)


if __name__ == "__main__":
    main()
</file>

<file path="pyproject.toml">
[project]
name = "ai_watch_buddy"
version = "0.1.0"
description = "Add your description here"
readme = "README.md"
requires-python = ">=3.13"
dependencies = [
    "fastapi>=0.116.1",
    "google-generativeai>=0.8.5",
    "json-repair>=0.47.8",
    "loguru>=0.7.3",
    "numpy>=2.3.1",
    "pydantic>=2.11.7",
    "ruff>=0.12.4",
    "uvicorn[standard]>=0.30.1", # Added for running the server
    "websockets>=12.0", # Explicitly add for websocket handling
]
</file>

</files>
