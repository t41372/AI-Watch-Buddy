# ai_actions.py
import json
from typing import Literal, Union
from pydantic import BaseModel, Field, RootModel
import uuid

# ==============================================================================
# Base Model and Core Atomic Actions
# ==============================================================================


class BaseAction(BaseModel):
    """
    The base model for all atomic actions. It defines the common properties
    that every action in the script must have.
    """

    action_type: str = Field(..., description="The type of the action to be performed.")
    id: str = Field(
        default_factory=lambda: str(uuid.uuid4()),
        description="A unique identifier for this action instance.",
    )
    trigger_timestamp: float = Field(
        ...,
        description="The video timestamp (in seconds) when this action should be triggered. Actions with the same trigger_timestamp will be executed sequentially by the player.",
    )
    comment: str = Field(
        ...,
        description="AI's internal monologue or reasoning for why this specific action was chosen at this time.",
    )


class PauseAction(BaseAction):
    """
    An action to pause the video playback. This is used to create a moment for
    the AI to speak or to emphasize a specific frame.
    """

    action_type: Literal["PAUSE"] = "PAUSE"


class ResumeAction(BaseAction):
    """
    An action to resume the video playback. It should typically follow a PAUSE
    or a SEEK action where the video was left in a paused state.
    """

    action_type: Literal["RESUME"] = "RESUME"


class SpeakAction(BaseAction):
    """
    An action for the AI to speak. The video can be either playing or paused
    when this occurs, depending on the preceding actions in the script.
    """

    action_type: Literal["SPEAK"] = "SPEAK"
    text: str = Field(
        ..., description="The dialogue content the AI character will speak."
    )
    audio: str | None = Field(
        None,
        description="The audio data for the speech. This is generated by a TTS engine later and should not be filled by the LLM.",
    )


class SeekAction(BaseAction):
    """
    An action to jump to a specific point in the video. The video remains paused
    after seeking until a RESUME action is issued.
    """

    action_type: Literal["SEEK"] = "SEEK"
    target_time: float = Field(
        ..., description="The target video timestamp (in seconds) to jump to."
    )


class EndAction(BaseAction):
    """
    A special action that signals the end of the current generation batch.
    The AI should use this when it has finished reacting to a segment and is now
    waiting for the user to watch further and request more actions.
    """

    action_type: Literal["END"] = "END"


# ==============================================================================
# Pydantic Discriminated Union and Script Model
# ==============================================================================

# A Discriminated Union of all possible atomic actions.
# Pydantic uses the 'action_type' field to determine which model to use for validation.
Action = Union[PauseAction, ResumeAction, SpeakAction, SeekAction, EndAction]


# The complete ActionScript is a list of these atomic Action objects.
# Using RootModel allows us to validate a list as the top-level object.
class ActionScript(RootModel[list[Action]]):
    root: list[Action] = Field(
        ..., description="A sequence of actions to be performed by the AI character."
    )


# ==============================================================================
# Main execution block for generating the schema
# ==============================================================================

if __name__ == "__main__":
    schema_path = "atomic_schema.json"
    with open(schema_path, "w", encoding="utf-8") as f:
        # Generate the JSON schema from the ActionScript model
        json.dump(ActionScript.model_json_schema(), f, ensure_ascii=False, indent=2)
    print(f"Atomic action schema saved to {schema_path}")
