import { useCallback, useState, useEffect } from 'react';
import { WebSocketMessage } from '@/context/websocket-context';

// Action types from AI backend - updated to match new schema
export interface AIAction {
  action_type: 'SPEAK' | 'PAUSE' | 'SEEK' | 'REPLAY_SEGMENT' | 'END_REACTION' | 'EXPRESSION';
  id: string;
  trigger_timestamp: number;
  comment: string;

  // SPEAK action fields
  text?: string; // For SPEAK actions
  audio?: string; // For SPEAK actions (generated by TTS)
  pause_video?: boolean; // For SPEAK actions - whether to pause video while speaking

  // PAUSE action fields
  duration_seconds?: number; // For PAUSE actions

  // SEEK action fields
  target_timestamp?: number; // For SEEK actions
  post_seek_behavior?: 'RESUME_PLAYBACK' | 'STAY_PAUSED'; // For SEEK actions

  // REPLAY_SEGMENT action fields
  start_timestamp?: number; // For REPLAY_SEGMENT actions
  end_timestamp?: number; // For REPLAY_SEGMENT actions
  post_replay_behavior?: 'RESUME_FROM_ORIGINAL' | 'STAY_PAUSED_AT_END'; // For REPLAY_SEGMENT actions

  // EXPRESSION action fields
  emotion_expressions?: string; // For EXPRESSION actions - emotion name from emotionMap
}

export interface ProcessingError {
  error_code: string;
  message: string;
}

export type SessionStatus = 'idle' | 'preparing' | 'ready' | 'error';

export interface UseMessageHandlerReturn {
  sessionStatus: SessionStatus;
  processingError: ProcessingError | null;
  receivedActions: AIAction[];
  isSessionReady: boolean;
  handleMessage: (message: WebSocketMessage) => void;
  clearError: () => void;
  resetHandler: () => void;
  clearReceivedActions: () => void;
}

export const useMessageHandler = (): UseMessageHandlerReturn => {
  const [sessionStatus, setSessionStatus] = useState<SessionStatus>('idle');
  const [processingError, setProcessingError] = useState<ProcessingError | null>(null);
  const [receivedActions, setReceivedActions] = useState<AIAction[]>([]);

  const clearReceivedActions = useCallback(() => {
    setReceivedActions([]);
  }, []);

  // Handle incoming WebSocket messages
  const handleMessage = useCallback((message: WebSocketMessage) => {
    console.log('Received WebSocket message:', message);

    switch (message.type) {
      case 'session_ready':
        console.log('âœ… Session is ready! Setting status to ready');
        setSessionStatus('ready');
        setProcessingError(null);
        break;

      case 'processing_error':
        console.error('Processing error received:', message);
        console.error('Full error details:', JSON.stringify(message, null, 2));
        const error: ProcessingError = {
          error_code: message.error_code || 'UNKNOWN_ERROR',
          message: message.message || 'An unknown error occurred'
        };
        setProcessingError(error);
        setSessionStatus('error');
        break;

      case 'ai_action':
        console.log('Received AI action message:', message);
        if (message.action && isValidSingleAction(message.action)) {
          const actionData = message.action;
          const action: AIAction = {
            action_type: actionData.action_type,
            id: actionData.id,
            trigger_timestamp: actionData.trigger_timestamp,
            comment: actionData.comment,
            text: actionData.text,
            audio: actionData.audio,
            pause_video: actionData.pause_video,
            duration_seconds: actionData.duration_seconds,
            target_timestamp: actionData.target_timestamp,
            post_seek_behavior: actionData.post_seek_behavior,
            start_timestamp: actionData.start_timestamp,
            end_timestamp: actionData.end_timestamp,
            post_replay_behavior: actionData.post_replay_behavior,
            emotion_expressions: actionData.emotion_expressions
          };

          setReceivedActions(prev => {
            // Insert action in the correct position based on trigger_timestamp
            const newActions = [...prev, action];
            return newActions.sort((a, b) => a.trigger_timestamp - b.trigger_timestamp);
          });
        } else {
          console.warn('Received invalid ai_action message:', message);
        }
        break;

      default:
        console.log('Unhandled message type:', message.type);
        break;
    }
  }, []);

  // Clear current error
  const clearError = useCallback(() => {
    setProcessingError(null);
    if (sessionStatus === 'error') {
      setSessionStatus('idle');
    }
  }, [sessionStatus]);

  // Reset all handler state
  const resetHandler = useCallback(() => {
    setSessionStatus('idle');
    setProcessingError(null);
    setReceivedActions([]);
  }, []);

  const isSessionReady = sessionStatus === 'ready';
  
  // Debug: Log session status changes
  useEffect(() => {
    console.log('ðŸ“Š Message handler session status changed:', sessionStatus, 'isReady:', isSessionReady);
  }, [sessionStatus, isSessionReady]);

  return {
    sessionStatus,
    processingError,
    receivedActions,
    isSessionReady,
    handleMessage,
    clearError,
    resetHandler,
    clearReceivedActions
  };
};


// Helper function to validate single action data (for ai_action type)
function isValidSingleAction(actionData: any): boolean {
  return (
    actionData &&
    typeof actionData.action_type === 'string' &&
    ['SPEAK', 'PAUSE', 'SEEK', 'REPLAY_SEGMENT', 'END_REACTION', 'EXPRESSION'].includes(actionData.action_type) &&
    typeof actionData.id === 'string' &&
    typeof actionData.trigger_timestamp === 'number' &&
    typeof actionData.comment === 'string'
  );
}