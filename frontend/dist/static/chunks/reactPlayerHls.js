"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["reactPlayerHls"],{

/***/ "(app-pages-browser)/./node_modules/custom-media-element/dist/custom-media-element.js":
/*!************************************************************************!*\
  !*** ./node_modules/custom-media-element/dist/custom-media-element.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Attributes: () => (/* binding */ Attributes),\n/* harmony export */   CustomAudioElement: () => (/* binding */ CustomAudioElement),\n/* harmony export */   CustomMediaMixin: () => (/* binding */ CustomMediaMixin),\n/* harmony export */   CustomVideoElement: () => (/* binding */ CustomVideoElement),\n/* harmony export */   Events: () => (/* binding */ Events)\n/* harmony export */ });\nconst Events = [\n  \"abort\",\n  \"canplay\",\n  \"canplaythrough\",\n  \"durationchange\",\n  \"emptied\",\n  \"encrypted\",\n  \"ended\",\n  \"error\",\n  \"loadeddata\",\n  \"loadedmetadata\",\n  \"loadstart\",\n  \"pause\",\n  \"play\",\n  \"playing\",\n  \"progress\",\n  \"ratechange\",\n  \"seeked\",\n  \"seeking\",\n  \"stalled\",\n  \"suspend\",\n  \"timeupdate\",\n  \"volumechange\",\n  \"waiting\",\n  \"waitingforkey\",\n  \"resize\",\n  \"enterpictureinpicture\",\n  \"leavepictureinpicture\",\n  \"webkitbeginfullscreen\",\n  \"webkitendfullscreen\",\n  \"webkitpresentationmodechanged\"\n];\nconst Attributes = [\n  \"autopictureinpicture\",\n  \"disablepictureinpicture\",\n  \"disableremoteplayback\",\n  \"autoplay\",\n  \"controls\",\n  \"controlslist\",\n  \"crossorigin\",\n  \"loop\",\n  \"muted\",\n  \"playsinline\",\n  \"poster\",\n  \"preload\",\n  \"src\"\n];\nfunction getAudioTemplateHTML(attrs) {\n  return (\n    /*html*/\n    `\n    <style>\n      :host {\n        display: inline-flex;\n        line-height: 0;\n        flex-direction: column;\n        justify-content: end;\n      }\n\n      audio {\n        width: 100%;\n      }\n    </style>\n    <slot name=\"media\">\n      <audio${serializeAttributes(attrs)}></audio>\n    </slot>\n    <slot></slot>\n  `\n  );\n}\nfunction getVideoTemplateHTML(attrs) {\n  return (\n    /*html*/\n    `\n    <style>\n      :host {\n        display: inline-block;\n        line-height: 0;\n      }\n\n      video {\n        max-width: 100%;\n        max-height: 100%;\n        min-width: 100%;\n        min-height: 100%;\n        object-fit: var(--media-object-fit, contain);\n        object-position: var(--media-object-position, 50% 50%);\n      }\n\n      video::-webkit-media-text-track-container {\n        transform: var(--media-webkit-text-track-transform);\n        transition: var(--media-webkit-text-track-transition);\n      }\n    </style>\n    <slot name=\"media\">\n      <video${serializeAttributes(attrs)}></video>\n    </slot>\n    <slot></slot>\n  `\n  );\n}\nfunction CustomMediaMixin(superclass, { tag, is }) {\n  const nativeElTest = globalThis.document?.createElement?.(tag, { is });\n  const nativeElProps = nativeElTest ? getNativeElProps(nativeElTest) : [];\n  return class CustomMedia extends superclass {\n    static getTemplateHTML = tag.endsWith(\"audio\") ? getAudioTemplateHTML : getVideoTemplateHTML;\n    static shadowRootOptions = { mode: \"open\" };\n    static Events = Events;\n    static #isDefined = false;\n    static get observedAttributes() {\n      CustomMedia.#define();\n      const natAttrs = nativeElTest?.constructor?.observedAttributes ?? [];\n      return [\n        ...natAttrs,\n        ...Attributes\n      ];\n    }\n    static #define() {\n      if (this.#isDefined) return;\n      this.#isDefined = true;\n      const propsToAttrs = new Set(this.observedAttributes);\n      propsToAttrs.delete(\"muted\");\n      for (const prop of nativeElProps) {\n        if (prop in this.prototype) continue;\n        if (typeof nativeElTest[prop] === \"function\") {\n          this.prototype[prop] = function(...args) {\n            this.#init();\n            const fn = () => {\n              if (this.call) return this.call(prop, ...args);\n              const nativeFn = this.nativeEl?.[prop];\n              return nativeFn?.apply(this.nativeEl, args);\n            };\n            return fn();\n          };\n        } else {\n          const config = {\n            get() {\n              this.#init();\n              const attr = prop.toLowerCase();\n              if (propsToAttrs.has(attr)) {\n                const val = this.getAttribute(attr);\n                return val === null ? false : val === \"\" ? true : val;\n              }\n              return this.get?.(prop) ?? this.nativeEl?.[prop];\n            }\n          };\n          if (prop !== prop.toUpperCase()) {\n            config.set = function(val) {\n              this.#init();\n              const attr = prop.toLowerCase();\n              if (propsToAttrs.has(attr)) {\n                if (val === true || val === false || val == null) {\n                  this.toggleAttribute(attr, Boolean(val));\n                } else {\n                  this.setAttribute(attr, val);\n                }\n                return;\n              }\n              if (this.set) {\n                this.set(prop, val);\n                return;\n              }\n              if (this.nativeEl) {\n                this.nativeEl[prop] = val;\n              }\n            };\n          }\n          Object.defineProperty(this.prototype, prop, config);\n        }\n      }\n    }\n    // Private fields\n    #isInit = false;\n    #nativeEl = null;\n    #childMap = /* @__PURE__ */ new Map();\n    #childObserver;\n    get;\n    set;\n    call;\n    // If the custom element is defined before the custom element's HTML is parsed\n    // no attributes will be available in the constructor (construction process).\n    // Wait until initializing in the attributeChangedCallback or\n    // connectedCallback or accessing any properties.\n    get nativeEl() {\n      this.#init();\n      return this.#nativeEl ?? this.querySelector(\":scope > [slot=media]\") ?? this.querySelector(tag) ?? this.shadowRoot?.querySelector(tag) ?? null;\n    }\n    set nativeEl(val) {\n      this.#nativeEl = val;\n    }\n    get defaultMuted() {\n      return this.hasAttribute(\"muted\");\n    }\n    set defaultMuted(val) {\n      this.toggleAttribute(\"muted\", val);\n    }\n    get src() {\n      return this.getAttribute(\"src\");\n    }\n    set src(val) {\n      this.setAttribute(\"src\", `${val}`);\n    }\n    get preload() {\n      return this.getAttribute(\"preload\") ?? this.nativeEl?.preload;\n    }\n    set preload(val) {\n      this.setAttribute(\"preload\", `${val}`);\n    }\n    #init() {\n      if (this.#isInit) return;\n      this.#isInit = true;\n      this.init();\n    }\n    init() {\n      if (!this.shadowRoot) {\n        this.attachShadow({ mode: \"open\" });\n        const attrs = namedNodeMapToObject(this.attributes);\n        if (is) attrs.is = is;\n        if (tag) attrs.part = tag;\n        this.shadowRoot.innerHTML = this.constructor.getTemplateHTML(attrs);\n      }\n      this.nativeEl.muted = this.hasAttribute(\"muted\");\n      for (const prop of nativeElProps) {\n        this.#upgradeProperty(prop);\n      }\n      this.#childObserver = new MutationObserver(this.#syncMediaChildAttribute.bind(this));\n      this.shadowRoot.addEventListener(\"slotchange\", () => this.#syncMediaChildren());\n      this.#syncMediaChildren();\n      for (const type of this.constructor.Events) {\n        this.shadowRoot.addEventListener(type, this, true);\n      }\n    }\n    handleEvent(event) {\n      if (event.target === this.nativeEl) {\n        this.dispatchEvent(new CustomEvent(event.type, { detail: event.detail }));\n      }\n    }\n    #syncMediaChildren() {\n      const removeNativeChildren = new Map(this.#childMap);\n      const defaultSlot = this.shadowRoot?.querySelector(\"slot:not([name])\");\n      const mediaChildren = defaultSlot?.assignedElements({ flatten: true }).filter((el) => [\"track\", \"source\"].includes(el.localName));\n      mediaChildren.forEach((el) => {\n        removeNativeChildren.delete(el);\n        let clone = this.#childMap.get(el);\n        if (!clone) {\n          clone = el.cloneNode();\n          this.#childMap.set(el, clone);\n          this.#childObserver?.observe(el, { attributes: true });\n        }\n        this.nativeEl?.append(clone);\n        this.#enableDefaultTrack(clone);\n      });\n      removeNativeChildren.forEach((clone, el) => {\n        clone.remove();\n        this.#childMap.delete(el);\n      });\n    }\n    #syncMediaChildAttribute(mutations) {\n      for (const mutation of mutations) {\n        if (mutation.type === \"attributes\") {\n          const { target, attributeName } = mutation;\n          const clone = this.#childMap.get(target);\n          if (clone && attributeName) {\n            clone.setAttribute(attributeName, target.getAttribute(attributeName) ?? \"\");\n            this.#enableDefaultTrack(clone);\n          }\n        }\n      }\n    }\n    #enableDefaultTrack(trackEl) {\n      if (trackEl && trackEl.localName === \"track\" && trackEl.default && (trackEl.kind === \"chapters\" || trackEl.kind === \"metadata\") && trackEl.track.mode === \"disabled\") {\n        trackEl.track.mode = \"hidden\";\n      }\n    }\n    #upgradeProperty(prop) {\n      if (Object.prototype.hasOwnProperty.call(this, prop)) {\n        const value = this[prop];\n        delete this[prop];\n        this[prop] = value;\n      }\n    }\n    attributeChangedCallback(attrName, oldValue, newValue) {\n      this.#init();\n      this.#forwardAttribute(attrName, oldValue, newValue);\n    }\n    #forwardAttribute(attrName, _oldValue, newValue) {\n      if ([\"id\", \"class\"].includes(attrName)) return;\n      if (!CustomMedia.observedAttributes.includes(attrName) && this.constructor.observedAttributes.includes(attrName)) {\n        return;\n      }\n      if (newValue === null) {\n        this.nativeEl?.removeAttribute(attrName);\n      } else if (this.nativeEl?.getAttribute(attrName) !== newValue) {\n        this.nativeEl?.setAttribute(attrName, newValue);\n      }\n    }\n    connectedCallback() {\n      this.#init();\n    }\n  };\n}\nfunction getNativeElProps(nativeElTest) {\n  const nativeElProps = [];\n  for (let proto = Object.getPrototypeOf(nativeElTest); proto && proto !== HTMLElement.prototype; proto = Object.getPrototypeOf(proto)) {\n    const props = Object.getOwnPropertyNames(proto);\n    nativeElProps.push(...props);\n  }\n  return nativeElProps;\n}\nfunction serializeAttributes(attrs) {\n  let html = \"\";\n  for (const key in attrs) {\n    if (!Attributes.includes(key)) continue;\n    const value = attrs[key];\n    if (value === \"\") html += ` ${key}`;\n    else html += ` ${key}=\"${value}\"`;\n  }\n  return html;\n}\nfunction namedNodeMapToObject(namedNodeMap) {\n  const obj = {};\n  for (const attr of namedNodeMap) {\n    obj[attr.name] = attr.value;\n  }\n  return obj;\n}\nconst CustomVideoElement = CustomMediaMixin(globalThis.HTMLElement ?? class {\n}, {\n  tag: \"video\"\n});\nconst CustomAudioElement = CustomMediaMixin(globalThis.HTMLElement ?? class {\n}, {\n  tag: \"audio\"\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jdXN0b20tbWVkaWEtZWxlbWVudC9kaXN0L2N1c3RvbS1tZWRpYS1lbGVtZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkJBQTJCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJCQUEyQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQsbUVBQW1FLElBQUk7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsSUFBSTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLElBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxzQkFBc0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxlQUFlO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxrQkFBa0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3QkFBd0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsMENBQTBDO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLElBQUk7QUFDdEMscUJBQXFCLElBQUksSUFBSSxNQUFNO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBT0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy9FdGhhbkxlZS9EZXNrdG9wL0FkdlgvQUktV2F0Y2gtQnVkZHkvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2N1c3RvbS1tZWRpYS1lbGVtZW50L2Rpc3QvY3VzdG9tLW1lZGlhLWVsZW1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgRXZlbnRzID0gW1xuICBcImFib3J0XCIsXG4gIFwiY2FucGxheVwiLFxuICBcImNhbnBsYXl0aHJvdWdoXCIsXG4gIFwiZHVyYXRpb25jaGFuZ2VcIixcbiAgXCJlbXB0aWVkXCIsXG4gIFwiZW5jcnlwdGVkXCIsXG4gIFwiZW5kZWRcIixcbiAgXCJlcnJvclwiLFxuICBcImxvYWRlZGRhdGFcIixcbiAgXCJsb2FkZWRtZXRhZGF0YVwiLFxuICBcImxvYWRzdGFydFwiLFxuICBcInBhdXNlXCIsXG4gIFwicGxheVwiLFxuICBcInBsYXlpbmdcIixcbiAgXCJwcm9ncmVzc1wiLFxuICBcInJhdGVjaGFuZ2VcIixcbiAgXCJzZWVrZWRcIixcbiAgXCJzZWVraW5nXCIsXG4gIFwic3RhbGxlZFwiLFxuICBcInN1c3BlbmRcIixcbiAgXCJ0aW1ldXBkYXRlXCIsXG4gIFwidm9sdW1lY2hhbmdlXCIsXG4gIFwid2FpdGluZ1wiLFxuICBcIndhaXRpbmdmb3JrZXlcIixcbiAgXCJyZXNpemVcIixcbiAgXCJlbnRlcnBpY3R1cmVpbnBpY3R1cmVcIixcbiAgXCJsZWF2ZXBpY3R1cmVpbnBpY3R1cmVcIixcbiAgXCJ3ZWJraXRiZWdpbmZ1bGxzY3JlZW5cIixcbiAgXCJ3ZWJraXRlbmRmdWxsc2NyZWVuXCIsXG4gIFwid2Via2l0cHJlc2VudGF0aW9ubW9kZWNoYW5nZWRcIlxuXTtcbmNvbnN0IEF0dHJpYnV0ZXMgPSBbXG4gIFwiYXV0b3BpY3R1cmVpbnBpY3R1cmVcIixcbiAgXCJkaXNhYmxlcGljdHVyZWlucGljdHVyZVwiLFxuICBcImRpc2FibGVyZW1vdGVwbGF5YmFja1wiLFxuICBcImF1dG9wbGF5XCIsXG4gIFwiY29udHJvbHNcIixcbiAgXCJjb250cm9sc2xpc3RcIixcbiAgXCJjcm9zc29yaWdpblwiLFxuICBcImxvb3BcIixcbiAgXCJtdXRlZFwiLFxuICBcInBsYXlzaW5saW5lXCIsXG4gIFwicG9zdGVyXCIsXG4gIFwicHJlbG9hZFwiLFxuICBcInNyY1wiXG5dO1xuZnVuY3Rpb24gZ2V0QXVkaW9UZW1wbGF0ZUhUTUwoYXR0cnMpIHtcbiAgcmV0dXJuIChcbiAgICAvKmh0bWwqL1xuICAgIGBcbiAgICA8c3R5bGU+XG4gICAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICAgICAgICBsaW5lLWhlaWdodDogMDtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBlbmQ7XG4gICAgICB9XG5cbiAgICAgIGF1ZGlvIHtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICB9XG4gICAgPC9zdHlsZT5cbiAgICA8c2xvdCBuYW1lPVwibWVkaWFcIj5cbiAgICAgIDxhdWRpbyR7c2VyaWFsaXplQXR0cmlidXRlcyhhdHRycyl9PjwvYXVkaW8+XG4gICAgPC9zbG90PlxuICAgIDxzbG90Pjwvc2xvdD5cbiAgYFxuICApO1xufVxuZnVuY3Rpb24gZ2V0VmlkZW9UZW1wbGF0ZUhUTUwoYXR0cnMpIHtcbiAgcmV0dXJuIChcbiAgICAvKmh0bWwqL1xuICAgIGBcbiAgICA8c3R5bGU+XG4gICAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgbGluZS1oZWlnaHQ6IDA7XG4gICAgICB9XG5cbiAgICAgIHZpZGVvIHtcbiAgICAgICAgbWF4LXdpZHRoOiAxMDAlO1xuICAgICAgICBtYXgtaGVpZ2h0OiAxMDAlO1xuICAgICAgICBtaW4td2lkdGg6IDEwMCU7XG4gICAgICAgIG1pbi1oZWlnaHQ6IDEwMCU7XG4gICAgICAgIG9iamVjdC1maXQ6IHZhcigtLW1lZGlhLW9iamVjdC1maXQsIGNvbnRhaW4pO1xuICAgICAgICBvYmplY3QtcG9zaXRpb246IHZhcigtLW1lZGlhLW9iamVjdC1wb3NpdGlvbiwgNTAlIDUwJSk7XG4gICAgICB9XG5cbiAgICAgIHZpZGVvOjotd2Via2l0LW1lZGlhLXRleHQtdHJhY2stY29udGFpbmVyIHtcbiAgICAgICAgdHJhbnNmb3JtOiB2YXIoLS1tZWRpYS13ZWJraXQtdGV4dC10cmFjay10cmFuc2Zvcm0pO1xuICAgICAgICB0cmFuc2l0aW9uOiB2YXIoLS1tZWRpYS13ZWJraXQtdGV4dC10cmFjay10cmFuc2l0aW9uKTtcbiAgICAgIH1cbiAgICA8L3N0eWxlPlxuICAgIDxzbG90IG5hbWU9XCJtZWRpYVwiPlxuICAgICAgPHZpZGVvJHtzZXJpYWxpemVBdHRyaWJ1dGVzKGF0dHJzKX0+PC92aWRlbz5cbiAgICA8L3Nsb3Q+XG4gICAgPHNsb3Q+PC9zbG90PlxuICBgXG4gICk7XG59XG5mdW5jdGlvbiBDdXN0b21NZWRpYU1peGluKHN1cGVyY2xhc3MsIHsgdGFnLCBpcyB9KSB7XG4gIGNvbnN0IG5hdGl2ZUVsVGVzdCA9IGdsb2JhbFRoaXMuZG9jdW1lbnQ/LmNyZWF0ZUVsZW1lbnQ/Lih0YWcsIHsgaXMgfSk7XG4gIGNvbnN0IG5hdGl2ZUVsUHJvcHMgPSBuYXRpdmVFbFRlc3QgPyBnZXROYXRpdmVFbFByb3BzKG5hdGl2ZUVsVGVzdCkgOiBbXTtcbiAgcmV0dXJuIGNsYXNzIEN1c3RvbU1lZGlhIGV4dGVuZHMgc3VwZXJjbGFzcyB7XG4gICAgc3RhdGljIGdldFRlbXBsYXRlSFRNTCA9IHRhZy5lbmRzV2l0aChcImF1ZGlvXCIpID8gZ2V0QXVkaW9UZW1wbGF0ZUhUTUwgOiBnZXRWaWRlb1RlbXBsYXRlSFRNTDtcbiAgICBzdGF0aWMgc2hhZG93Um9vdE9wdGlvbnMgPSB7IG1vZGU6IFwib3BlblwiIH07XG4gICAgc3RhdGljIEV2ZW50cyA9IEV2ZW50cztcbiAgICBzdGF0aWMgI2lzRGVmaW5lZCA9IGZhbHNlO1xuICAgIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgICAgQ3VzdG9tTWVkaWEuI2RlZmluZSgpO1xuICAgICAgY29uc3QgbmF0QXR0cnMgPSBuYXRpdmVFbFRlc3Q/LmNvbnN0cnVjdG9yPy5vYnNlcnZlZEF0dHJpYnV0ZXMgPz8gW107XG4gICAgICByZXR1cm4gW1xuICAgICAgICAuLi5uYXRBdHRycyxcbiAgICAgICAgLi4uQXR0cmlidXRlc1xuICAgICAgXTtcbiAgICB9XG4gICAgc3RhdGljICNkZWZpbmUoKSB7XG4gICAgICBpZiAodGhpcy4jaXNEZWZpbmVkKSByZXR1cm47XG4gICAgICB0aGlzLiNpc0RlZmluZWQgPSB0cnVlO1xuICAgICAgY29uc3QgcHJvcHNUb0F0dHJzID0gbmV3IFNldCh0aGlzLm9ic2VydmVkQXR0cmlidXRlcyk7XG4gICAgICBwcm9wc1RvQXR0cnMuZGVsZXRlKFwibXV0ZWRcIik7XG4gICAgICBmb3IgKGNvbnN0IHByb3Agb2YgbmF0aXZlRWxQcm9wcykge1xuICAgICAgICBpZiAocHJvcCBpbiB0aGlzLnByb3RvdHlwZSkgY29udGludWU7XG4gICAgICAgIGlmICh0eXBlb2YgbmF0aXZlRWxUZXN0W3Byb3BdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aGlzLnByb3RvdHlwZVtwcm9wXSA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuI2luaXQoKTtcbiAgICAgICAgICAgIGNvbnN0IGZuID0gKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAodGhpcy5jYWxsKSByZXR1cm4gdGhpcy5jYWxsKHByb3AsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgICBjb25zdCBuYXRpdmVGbiA9IHRoaXMubmF0aXZlRWw/Lltwcm9wXTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZUZuPy5hcHBseSh0aGlzLm5hdGl2ZUVsLCBhcmdzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgdGhpcy4jaW5pdCgpO1xuICAgICAgICAgICAgICBjb25zdCBhdHRyID0gcHJvcC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICBpZiAocHJvcHNUb0F0dHJzLmhhcyhhdHRyKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IHRoaXMuZ2V0QXR0cmlidXRlKGF0dHIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWwgPT09IG51bGwgPyBmYWxzZSA6IHZhbCA9PT0gXCJcIiA/IHRydWUgOiB2YWw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Py4ocHJvcCkgPz8gdGhpcy5uYXRpdmVFbD8uW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKHByb3AgIT09IHByb3AudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgY29uZmlnLnNldCA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICB0aGlzLiNpbml0KCk7XG4gICAgICAgICAgICAgIGNvbnN0IGF0dHIgPSBwcm9wLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgIGlmIChwcm9wc1RvQXR0cnMuaGFzKGF0dHIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbCA9PT0gdHJ1ZSB8fCB2YWwgPT09IGZhbHNlIHx8IHZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnRvZ2dsZUF0dHJpYnV0ZShhdHRyLCBCb29sZWFuKHZhbCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShhdHRyLCB2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQocHJvcCwgdmFsKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHRoaXMubmF0aXZlRWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5hdGl2ZUVsW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5wcm90b3R5cGUsIHByb3AsIGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUHJpdmF0ZSBmaWVsZHNcbiAgICAjaXNJbml0ID0gZmFsc2U7XG4gICAgI25hdGl2ZUVsID0gbnVsbDtcbiAgICAjY2hpbGRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICNjaGlsZE9ic2VydmVyO1xuICAgIGdldDtcbiAgICBzZXQ7XG4gICAgY2FsbDtcbiAgICAvLyBJZiB0aGUgY3VzdG9tIGVsZW1lbnQgaXMgZGVmaW5lZCBiZWZvcmUgdGhlIGN1c3RvbSBlbGVtZW50J3MgSFRNTCBpcyBwYXJzZWRcbiAgICAvLyBubyBhdHRyaWJ1dGVzIHdpbGwgYmUgYXZhaWxhYmxlIGluIHRoZSBjb25zdHJ1Y3RvciAoY29uc3RydWN0aW9uIHByb2Nlc3MpLlxuICAgIC8vIFdhaXQgdW50aWwgaW5pdGlhbGl6aW5nIGluIHRoZSBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgb3JcbiAgICAvLyBjb25uZWN0ZWRDYWxsYmFjayBvciBhY2Nlc3NpbmcgYW55IHByb3BlcnRpZXMuXG4gICAgZ2V0IG5hdGl2ZUVsKCkge1xuICAgICAgdGhpcy4jaW5pdCgpO1xuICAgICAgcmV0dXJuIHRoaXMuI25hdGl2ZUVsID8/IHRoaXMucXVlcnlTZWxlY3RvcihcIjpzY29wZSA+IFtzbG90PW1lZGlhXVwiKSA/PyB0aGlzLnF1ZXJ5U2VsZWN0b3IodGFnKSA/PyB0aGlzLnNoYWRvd1Jvb3Q/LnF1ZXJ5U2VsZWN0b3IodGFnKSA/PyBudWxsO1xuICAgIH1cbiAgICBzZXQgbmF0aXZlRWwodmFsKSB7XG4gICAgICB0aGlzLiNuYXRpdmVFbCA9IHZhbDtcbiAgICB9XG4gICAgZ2V0IGRlZmF1bHRNdXRlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZShcIm11dGVkXCIpO1xuICAgIH1cbiAgICBzZXQgZGVmYXVsdE11dGVkKHZhbCkge1xuICAgICAgdGhpcy50b2dnbGVBdHRyaWJ1dGUoXCJtdXRlZFwiLCB2YWwpO1xuICAgIH1cbiAgICBnZXQgc3JjKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKFwic3JjXCIpO1xuICAgIH1cbiAgICBzZXQgc3JjKHZhbCkge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgYCR7dmFsfWApO1xuICAgIH1cbiAgICBnZXQgcHJlbG9hZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZShcInByZWxvYWRcIikgPz8gdGhpcy5uYXRpdmVFbD8ucHJlbG9hZDtcbiAgICB9XG4gICAgc2V0IHByZWxvYWQodmFsKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZShcInByZWxvYWRcIiwgYCR7dmFsfWApO1xuICAgIH1cbiAgICAjaW5pdCgpIHtcbiAgICAgIGlmICh0aGlzLiNpc0luaXQpIHJldHVybjtcbiAgICAgIHRoaXMuI2lzSW5pdCA9IHRydWU7XG4gICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgIGlmICghdGhpcy5zaGFkb3dSb290KSB7XG4gICAgICAgIHRoaXMuYXR0YWNoU2hhZG93KHsgbW9kZTogXCJvcGVuXCIgfSk7XG4gICAgICAgIGNvbnN0IGF0dHJzID0gbmFtZWROb2RlTWFwVG9PYmplY3QodGhpcy5hdHRyaWJ1dGVzKTtcbiAgICAgICAgaWYgKGlzKSBhdHRycy5pcyA9IGlzO1xuICAgICAgICBpZiAodGFnKSBhdHRycy5wYXJ0ID0gdGFnO1xuICAgICAgICB0aGlzLnNoYWRvd1Jvb3QuaW5uZXJIVE1MID0gdGhpcy5jb25zdHJ1Y3Rvci5nZXRUZW1wbGF0ZUhUTUwoYXR0cnMpO1xuICAgICAgfVxuICAgICAgdGhpcy5uYXRpdmVFbC5tdXRlZCA9IHRoaXMuaGFzQXR0cmlidXRlKFwibXV0ZWRcIik7XG4gICAgICBmb3IgKGNvbnN0IHByb3Agb2YgbmF0aXZlRWxQcm9wcykge1xuICAgICAgICB0aGlzLiN1cGdyYWRlUHJvcGVydHkocHJvcCk7XG4gICAgICB9XG4gICAgICB0aGlzLiNjaGlsZE9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy4jc3luY01lZGlhQ2hpbGRBdHRyaWJ1dGUuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLnNoYWRvd1Jvb3QuYWRkRXZlbnRMaXN0ZW5lcihcInNsb3RjaGFuZ2VcIiwgKCkgPT4gdGhpcy4jc3luY01lZGlhQ2hpbGRyZW4oKSk7XG4gICAgICB0aGlzLiNzeW5jTWVkaWFDaGlsZHJlbigpO1xuICAgICAgZm9yIChjb25zdCB0eXBlIG9mIHRoaXMuY29uc3RydWN0b3IuRXZlbnRzKSB7XG4gICAgICAgIHRoaXMuc2hhZG93Um9vdC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIHRoaXMsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVFdmVudChldmVudCkge1xuICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcy5uYXRpdmVFbCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KGV2ZW50LnR5cGUsIHsgZGV0YWlsOiBldmVudC5kZXRhaWwgfSkpO1xuICAgICAgfVxuICAgIH1cbiAgICAjc3luY01lZGlhQ2hpbGRyZW4oKSB7XG4gICAgICBjb25zdCByZW1vdmVOYXRpdmVDaGlsZHJlbiA9IG5ldyBNYXAodGhpcy4jY2hpbGRNYXApO1xuICAgICAgY29uc3QgZGVmYXVsdFNsb3QgPSB0aGlzLnNoYWRvd1Jvb3Q/LnF1ZXJ5U2VsZWN0b3IoXCJzbG90Om5vdChbbmFtZV0pXCIpO1xuICAgICAgY29uc3QgbWVkaWFDaGlsZHJlbiA9IGRlZmF1bHRTbG90Py5hc3NpZ25lZEVsZW1lbnRzKHsgZmxhdHRlbjogdHJ1ZSB9KS5maWx0ZXIoKGVsKSA9PiBbXCJ0cmFja1wiLCBcInNvdXJjZVwiXS5pbmNsdWRlcyhlbC5sb2NhbE5hbWUpKTtcbiAgICAgIG1lZGlhQ2hpbGRyZW4uZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgICAgcmVtb3ZlTmF0aXZlQ2hpbGRyZW4uZGVsZXRlKGVsKTtcbiAgICAgICAgbGV0IGNsb25lID0gdGhpcy4jY2hpbGRNYXAuZ2V0KGVsKTtcbiAgICAgICAgaWYgKCFjbG9uZSkge1xuICAgICAgICAgIGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XG4gICAgICAgICAgdGhpcy4jY2hpbGRNYXAuc2V0KGVsLCBjbG9uZSk7XG4gICAgICAgICAgdGhpcy4jY2hpbGRPYnNlcnZlcj8ub2JzZXJ2ZShlbCwgeyBhdHRyaWJ1dGVzOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmF0aXZlRWw/LmFwcGVuZChjbG9uZSk7XG4gICAgICAgIHRoaXMuI2VuYWJsZURlZmF1bHRUcmFjayhjbG9uZSk7XG4gICAgICB9KTtcbiAgICAgIHJlbW92ZU5hdGl2ZUNoaWxkcmVuLmZvckVhY2goKGNsb25lLCBlbCkgPT4ge1xuICAgICAgICBjbG9uZS5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy4jY2hpbGRNYXAuZGVsZXRlKGVsKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAjc3luY01lZGlhQ2hpbGRBdHRyaWJ1dGUobXV0YXRpb25zKSB7XG4gICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIG11dGF0aW9ucykge1xuICAgICAgICBpZiAobXV0YXRpb24udHlwZSA9PT0gXCJhdHRyaWJ1dGVzXCIpIHtcbiAgICAgICAgICBjb25zdCB7IHRhcmdldCwgYXR0cmlidXRlTmFtZSB9ID0gbXV0YXRpb247XG4gICAgICAgICAgY29uc3QgY2xvbmUgPSB0aGlzLiNjaGlsZE1hcC5nZXQodGFyZ2V0KTtcbiAgICAgICAgICBpZiAoY2xvbmUgJiYgYXR0cmlidXRlTmFtZSkge1xuICAgICAgICAgICAgY2xvbmUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIHRhcmdldC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSkgPz8gXCJcIik7XG4gICAgICAgICAgICB0aGlzLiNlbmFibGVEZWZhdWx0VHJhY2soY2xvbmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAjZW5hYmxlRGVmYXVsdFRyYWNrKHRyYWNrRWwpIHtcbiAgICAgIGlmICh0cmFja0VsICYmIHRyYWNrRWwubG9jYWxOYW1lID09PSBcInRyYWNrXCIgJiYgdHJhY2tFbC5kZWZhdWx0ICYmICh0cmFja0VsLmtpbmQgPT09IFwiY2hhcHRlcnNcIiB8fCB0cmFja0VsLmtpbmQgPT09IFwibWV0YWRhdGFcIikgJiYgdHJhY2tFbC50cmFjay5tb2RlID09PSBcImRpc2FibGVkXCIpIHtcbiAgICAgICAgdHJhY2tFbC50cmFjay5tb2RlID0gXCJoaWRkZW5cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgI3VwZ3JhZGVQcm9wZXJ0eShwcm9wKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIHByb3ApKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpc1twcm9wXTtcbiAgICAgICAgZGVsZXRlIHRoaXNbcHJvcF07XG4gICAgICAgIHRoaXNbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGF0dHJOYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgIHRoaXMuI2luaXQoKTtcbiAgICAgIHRoaXMuI2ZvcndhcmRBdHRyaWJ1dGUoYXR0ck5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgfVxuICAgICNmb3J3YXJkQXR0cmlidXRlKGF0dHJOYW1lLCBfb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgICBpZiAoW1wiaWRcIiwgXCJjbGFzc1wiXS5pbmNsdWRlcyhhdHRyTmFtZSkpIHJldHVybjtcbiAgICAgIGlmICghQ3VzdG9tTWVkaWEub2JzZXJ2ZWRBdHRyaWJ1dGVzLmluY2x1ZGVzKGF0dHJOYW1lKSAmJiB0aGlzLmNvbnN0cnVjdG9yLm9ic2VydmVkQXR0cmlidXRlcy5pbmNsdWRlcyhhdHRyTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG5ld1ZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMubmF0aXZlRWw/LnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubmF0aXZlRWw/LmdldEF0dHJpYnV0ZShhdHRyTmFtZSkgIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgIHRoaXMubmF0aXZlRWw/LnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgbmV3VmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIHRoaXMuI2luaXQoKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBnZXROYXRpdmVFbFByb3BzKG5hdGl2ZUVsVGVzdCkge1xuICBjb25zdCBuYXRpdmVFbFByb3BzID0gW107XG4gIGZvciAobGV0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG5hdGl2ZUVsVGVzdCk7IHByb3RvICYmIHByb3RvICE9PSBIVE1MRWxlbWVudC5wcm90b3R5cGU7IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKSkge1xuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pO1xuICAgIG5hdGl2ZUVsUHJvcHMucHVzaCguLi5wcm9wcyk7XG4gIH1cbiAgcmV0dXJuIG5hdGl2ZUVsUHJvcHM7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVBdHRyaWJ1dGVzKGF0dHJzKSB7XG4gIGxldCBodG1sID0gXCJcIjtcbiAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcbiAgICBpZiAoIUF0dHJpYnV0ZXMuaW5jbHVkZXMoa2V5KSkgY29udGludWU7XG4gICAgY29uc3QgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgIGlmICh2YWx1ZSA9PT0gXCJcIikgaHRtbCArPSBgICR7a2V5fWA7XG4gICAgZWxzZSBodG1sICs9IGAgJHtrZXl9PVwiJHt2YWx1ZX1cImA7XG4gIH1cbiAgcmV0dXJuIGh0bWw7XG59XG5mdW5jdGlvbiBuYW1lZE5vZGVNYXBUb09iamVjdChuYW1lZE5vZGVNYXApIHtcbiAgY29uc3Qgb2JqID0ge307XG4gIGZvciAoY29uc3QgYXR0ciBvZiBuYW1lZE5vZGVNYXApIHtcbiAgICBvYmpbYXR0ci5uYW1lXSA9IGF0dHIudmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cbmNvbnN0IEN1c3RvbVZpZGVvRWxlbWVudCA9IEN1c3RvbU1lZGlhTWl4aW4oZ2xvYmFsVGhpcy5IVE1MRWxlbWVudCA/PyBjbGFzcyB7XG59LCB7XG4gIHRhZzogXCJ2aWRlb1wiXG59KTtcbmNvbnN0IEN1c3RvbUF1ZGlvRWxlbWVudCA9IEN1c3RvbU1lZGlhTWl4aW4oZ2xvYmFsVGhpcy5IVE1MRWxlbWVudCA/PyBjbGFzcyB7XG59LCB7XG4gIHRhZzogXCJhdWRpb1wiXG59KTtcbmV4cG9ydCB7XG4gIEF0dHJpYnV0ZXMsXG4gIEN1c3RvbUF1ZGlvRWxlbWVudCxcbiAgQ3VzdG9tTWVkaWFNaXhpbixcbiAgQ3VzdG9tVmlkZW9FbGVtZW50LFxuICBFdmVudHNcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/custom-media-element/dist/custom-media-element.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/hls-video-element/dist/hls-video-element.js":
/*!******************************************************************!*\
  !*** ./node_modules/hls-video-element/dist/hls-video-element.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hls: () => (/* reexport safe */ hls_js_dist_hls_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   HlsVideoElement: () => (/* binding */ HlsVideoElement),\n/* harmony export */   HlsVideoMixin: () => (/* binding */ HlsVideoMixin),\n/* harmony export */   \"default\": () => (/* binding */ hls_video_element_default)\n/* harmony export */ });\n/* harmony import */ var custom_media_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! custom-media-element */ \"(app-pages-browser)/./node_modules/custom-media-element/dist/custom-media-element.js\");\n/* harmony import */ var media_tracks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! media-tracks */ \"(app-pages-browser)/./node_modules/media-tracks/dist/index.js\");\n/* harmony import */ var hls_js_dist_hls_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! hls.js/dist/hls.mjs */ \"(app-pages-browser)/./node_modules/hls.js/dist/hls.mjs\");\n\n\n\nconst HlsVideoMixin = (superclass) => {\n  return class HlsVideo extends superclass {\n    static shadowRootOptions = { ...superclass.shadowRootOptions };\n    static getTemplateHTML = (attrs, props = {}) => {\n      const { src, ...rest } = attrs;\n      return `\n        <script type=\"application/json\" id=\"config\">\n          ${JSON.stringify(props.config || {})}\n        </script>\n        ${superclass.getTemplateHTML(rest)}\n      `;\n    };\n    #airplaySourceEl = null;\n    #config = null;\n    constructor() {\n      super();\n      this.#upgradeProperty(\"config\");\n    }\n    get config() {\n      return this.#config;\n    }\n    set config(value) {\n      this.#config = value;\n    }\n    attributeChangedCallback(attrName, oldValue, newValue) {\n      if (attrName !== \"src\") {\n        super.attributeChangedCallback(attrName, oldValue, newValue);\n      }\n      if (attrName === \"src\" && oldValue != newValue) {\n        this.load();\n      }\n    }\n    #destroy() {\n      var _a, _b;\n      (_a = this.#airplaySourceEl) == null ? void 0 : _a.remove();\n      (_b = this.nativeEl) == null ? void 0 : _b.removeEventListener(\n        \"webkitcurrentplaybacktargetiswirelesschanged\",\n        this.#toggleHlsLoad\n      );\n      if (this.api) {\n        this.api.detachMedia();\n        this.api.destroy();\n        this.api = null;\n      }\n    }\n    async load() {\n      var _a, _b;\n      const isFirstLoad = !this.api;\n      this.#destroy();\n      if (!this.src) {\n        return;\n      }\n      if (isFirstLoad && !this.#config) {\n        this.#config = JSON.parse(((_a = this.shadowRoot.getElementById(\"config\")) == null ? void 0 : _a.textContent) || \"{}\");\n      }\n      if (hls_js_dist_hls_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].isSupported()) {\n        this.api = new hls_js_dist_hls_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({\n          // Mimic the media element with an Infinity duration for live streams.\n          liveDurationInfinity: true,\n          // Disable auto quality level/fragment loading.\n          autoStartLoad: false,\n          // Custom configuration for hls.js.\n          ...this.config\n        });\n        await Promise.resolve();\n        this.api.loadSource(this.src);\n        this.api.attachMedia(this.nativeEl);\n        switch (this.nativeEl.preload) {\n          case \"none\": {\n            const loadSourceOnPlay = () => this.api.startLoad();\n            this.nativeEl.addEventListener(\"play\", loadSourceOnPlay, {\n              once: true\n            });\n            this.api.on(hls_js_dist_hls_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Events.DESTROYING, () => {\n              this.nativeEl.removeEventListener(\"play\", loadSourceOnPlay);\n            });\n            break;\n          }\n          case \"metadata\": {\n            const originalLength = this.api.config.maxBufferLength;\n            const originalSize = this.api.config.maxBufferSize;\n            this.api.config.maxBufferLength = 1;\n            this.api.config.maxBufferSize = 1;\n            const increaseBufferOnPlay = () => {\n              this.api.config.maxBufferLength = originalLength;\n              this.api.config.maxBufferSize = originalSize;\n            };\n            this.nativeEl.addEventListener(\"play\", increaseBufferOnPlay, {\n              once: true\n            });\n            this.api.on(hls_js_dist_hls_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Events.DESTROYING, () => {\n              this.nativeEl.removeEventListener(\"play\", increaseBufferOnPlay);\n            });\n            this.api.startLoad();\n            break;\n          }\n          default:\n            this.api.startLoad();\n        }\n        if (this.nativeEl.webkitCurrentPlaybackTargetIsWireless) {\n          this.api.stopLoad();\n        }\n        this.nativeEl.addEventListener(\n          \"webkitcurrentplaybacktargetiswirelesschanged\",\n          this.#toggleHlsLoad\n        );\n        this.#airplaySourceEl = document.createElement(\"source\");\n        this.#airplaySourceEl.setAttribute(\"type\", \"application/x-mpegURL\");\n        this.#airplaySourceEl.setAttribute(\"src\", this.src);\n        this.nativeEl.disableRemotePlayback = false;\n        this.nativeEl.append(this.#airplaySourceEl);\n        const levelIdMap = /* @__PURE__ */ new WeakMap();\n        this.api.on(hls_js_dist_hls_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Events.MANIFEST_PARSED, (event, data) => {\n          if (this.nativeEl.autoplay && this.nativeEl.paused) {\n            this.nativeEl.play().catch((err) => {\n              console.warn(\"Autoplay failed:\", err);\n            });\n          }\n          removeAllMediaTracks();\n          let videoTrack = this.videoTracks.getTrackById(\"main\");\n          if (!videoTrack) {\n            videoTrack = this.addVideoTrack(\"main\");\n            videoTrack.id = \"main\";\n            videoTrack.selected = true;\n          }\n          for (const [id, level] of data.levels.entries()) {\n            const videoRendition = videoTrack.addRendition(\n              level.url[0],\n              level.width,\n              level.height,\n              level.videoCodec,\n              level.bitrate\n            );\n            levelIdMap.set(level, `${id}`);\n            videoRendition.id = `${id}`;\n          }\n          for (let [id, a] of data.audioTracks.entries()) {\n            const kind = a.default ? \"main\" : \"alternative\";\n            const audioTrack = this.addAudioTrack(kind, a.name, a.lang);\n            audioTrack.id = `${id}`;\n            if (a.default) {\n              audioTrack.enabled = true;\n            }\n          }\n        });\n        this.audioTracks.addEventListener(\"change\", () => {\n          var _a2;\n          const audioTrackId = +((_a2 = [...this.audioTracks].find((t) => t.enabled)) == null ? void 0 : _a2.id);\n          const availableIds = this.api.audioTracks.map((t) => t.id);\n          if (audioTrackId != this.api.audioTrack && availableIds.includes(audioTrackId)) {\n            this.api.audioTrack = audioTrackId;\n          }\n        });\n        this.api.on(hls_js_dist_hls_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Events.LEVELS_UPDATED, (event, data) => {\n          const videoTrack = this.videoTracks[this.videoTracks.selectedIndex ?? 0];\n          if (!videoTrack) return;\n          const levelIds = data.levels.map((l) => levelIdMap.get(l));\n          for (const rendition of this.videoRenditions) {\n            if (rendition.id && !levelIds.includes(rendition.id)) {\n              videoTrack.removeRendition(rendition);\n            }\n          }\n        });\n        const switchRendition = (event) => {\n          const level = event.target.selectedIndex;\n          if (level != this.api.nextLevel) {\n            this.api.nextLevel = level;\n          }\n        };\n        (_b = this.videoRenditions) == null ? void 0 : _b.addEventListener(\"change\", switchRendition);\n        const removeAllMediaTracks = () => {\n          for (const videoTrack of this.videoTracks) {\n            this.removeVideoTrack(videoTrack);\n          }\n          for (const audioTrack of this.audioTracks) {\n            this.removeAudioTrack(audioTrack);\n          }\n        };\n        this.api.once(hls_js_dist_hls_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Events.DESTROYING, removeAllMediaTracks);\n        return;\n      }\n      await Promise.resolve();\n      if (this.nativeEl.canPlayType(\"application/vnd.apple.mpegurl\")) {\n        this.nativeEl.src = this.src;\n      }\n    }\n    #toggleHlsLoad = () => {\n      var _a, _b, _c;\n      if ((_a = this.nativeEl) == null ? void 0 : _a.webkitCurrentPlaybackTargetIsWireless) {\n        (_b = this.api) == null ? void 0 : _b.stopLoad();\n      } else {\n        (_c = this.api) == null ? void 0 : _c.startLoad();\n      }\n    };\n    // This is a pattern to update property values that are set before\n    // the custom element is upgraded.\n    // https://web.dev/custom-elements-best-practices/#make-properties-lazy\n    #upgradeProperty(prop) {\n      if (Object.prototype.hasOwnProperty.call(this, prop)) {\n        const value = this[prop];\n        delete this[prop];\n        this[prop] = value;\n      }\n    }\n  };\n};\nconst HlsVideoElement = HlsVideoMixin((0,media_tracks__WEBPACK_IMPORTED_MODULE_1__.MediaTracksMixin)(custom_media_element__WEBPACK_IMPORTED_MODULE_0__.CustomVideoElement));\nif (globalThis.customElements && !globalThis.customElements.get(\"hls-video\")) {\n  globalThis.customElements.define(\"hls-video\", HlsVideoElement);\n}\nvar hls_video_element_default = HlsVideoElement;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9obHMtdmlkZW8tZWxlbWVudC9kaXN0L2hscy12aWRlby1lbGVtZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBMEQ7QUFDVjtBQUNWO0FBQ3RDO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsK0NBQStDO0FBQy9DLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0EsWUFBWSxpQ0FBaUM7QUFDN0M7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SEFBNEg7QUFDNUg7QUFDQSxVQUFVLHVFQUFlO0FBQ3pCLHVCQUF1QiwyREFBRztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYix3QkFBd0Isa0VBQVU7QUFDbEM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isd0JBQXdCLGtFQUFVO0FBQ2xDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtFQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxHQUFHO0FBQ3hDLG1DQUFtQyxHQUFHO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEdBQUc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsb0JBQW9CLGtFQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtFQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDhEQUFnQixDQUFDLG9FQUFrQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQU1FIiwic291cmNlcyI6WyIvVXNlcnMvRXRoYW5MZWUvRGVza3RvcC9BZHZYL0FJLVdhdGNoLUJ1ZGR5L2Zyb250ZW5kL25vZGVfbW9kdWxlcy9obHMtdmlkZW8tZWxlbWVudC9kaXN0L2hscy12aWRlby1lbGVtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEN1c3RvbVZpZGVvRWxlbWVudCB9IGZyb20gXCJjdXN0b20tbWVkaWEtZWxlbWVudFwiO1xuaW1wb3J0IHsgTWVkaWFUcmFja3NNaXhpbiB9IGZyb20gXCJtZWRpYS10cmFja3NcIjtcbmltcG9ydCBIbHMgZnJvbSBcImhscy5qcy9kaXN0L2hscy5tanNcIjtcbmNvbnN0IEhsc1ZpZGVvTWl4aW4gPSAoc3VwZXJjbGFzcykgPT4ge1xuICByZXR1cm4gY2xhc3MgSGxzVmlkZW8gZXh0ZW5kcyBzdXBlcmNsYXNzIHtcbiAgICBzdGF0aWMgc2hhZG93Um9vdE9wdGlvbnMgPSB7IC4uLnN1cGVyY2xhc3Muc2hhZG93Um9vdE9wdGlvbnMgfTtcbiAgICBzdGF0aWMgZ2V0VGVtcGxhdGVIVE1MID0gKGF0dHJzLCBwcm9wcyA9IHt9KSA9PiB7XG4gICAgICBjb25zdCB7IHNyYywgLi4ucmVzdCB9ID0gYXR0cnM7XG4gICAgICByZXR1cm4gYFxuICAgICAgICA8c2NyaXB0IHR5cGU9XCJhcHBsaWNhdGlvbi9qc29uXCIgaWQ9XCJjb25maWdcIj5cbiAgICAgICAgICAke0pTT04uc3RyaW5naWZ5KHByb3BzLmNvbmZpZyB8fCB7fSl9XG4gICAgICAgIDwvc2NyaXB0PlxuICAgICAgICAke3N1cGVyY2xhc3MuZ2V0VGVtcGxhdGVIVE1MKHJlc3QpfVxuICAgICAgYDtcbiAgICB9O1xuICAgICNhaXJwbGF5U291cmNlRWwgPSBudWxsO1xuICAgICNjb25maWcgPSBudWxsO1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMuI3VwZ3JhZGVQcm9wZXJ0eShcImNvbmZpZ1wiKTtcbiAgICB9XG4gICAgZ2V0IGNvbmZpZygpIHtcbiAgICAgIHJldHVybiB0aGlzLiNjb25maWc7XG4gICAgfVxuICAgIHNldCBjb25maWcodmFsdWUpIHtcbiAgICAgIHRoaXMuI2NvbmZpZyA9IHZhbHVlO1xuICAgIH1cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0ck5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgICAgaWYgKGF0dHJOYW1lICE9PSBcInNyY1wiKSB7XG4gICAgICAgIHN1cGVyLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhhdHRyTmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChhdHRyTmFtZSA9PT0gXCJzcmNcIiAmJiBvbGRWYWx1ZSAhPSBuZXdWYWx1ZSkge1xuICAgICAgICB0aGlzLmxvYWQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgI2Rlc3Ryb3koKSB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgKF9hID0gdGhpcy4jYWlycGxheVNvdXJjZUVsKSA9PSBudWxsID8gdm9pZCAwIDogX2EucmVtb3ZlKCk7XG4gICAgICAoX2IgPSB0aGlzLm5hdGl2ZUVsKSA9PSBudWxsID8gdm9pZCAwIDogX2IucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJ3ZWJraXRjdXJyZW50cGxheWJhY2t0YXJnZXRpc3dpcmVsZXNzY2hhbmdlZFwiLFxuICAgICAgICB0aGlzLiN0b2dnbGVIbHNMb2FkXG4gICAgICApO1xuICAgICAgaWYgKHRoaXMuYXBpKSB7XG4gICAgICAgIHRoaXMuYXBpLmRldGFjaE1lZGlhKCk7XG4gICAgICAgIHRoaXMuYXBpLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5hcGkgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBsb2FkKCkge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGNvbnN0IGlzRmlyc3RMb2FkID0gIXRoaXMuYXBpO1xuICAgICAgdGhpcy4jZGVzdHJveSgpO1xuICAgICAgaWYgKCF0aGlzLnNyYykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNGaXJzdExvYWQgJiYgIXRoaXMuI2NvbmZpZykge1xuICAgICAgICB0aGlzLiNjb25maWcgPSBKU09OLnBhcnNlKCgoX2EgPSB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoXCJjb25maWdcIikpID09IG51bGwgPyB2b2lkIDAgOiBfYS50ZXh0Q29udGVudCkgfHwgXCJ7fVwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChIbHMuaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICB0aGlzLmFwaSA9IG5ldyBIbHMoe1xuICAgICAgICAgIC8vIE1pbWljIHRoZSBtZWRpYSBlbGVtZW50IHdpdGggYW4gSW5maW5pdHkgZHVyYXRpb24gZm9yIGxpdmUgc3RyZWFtcy5cbiAgICAgICAgICBsaXZlRHVyYXRpb25JbmZpbml0eTogdHJ1ZSxcbiAgICAgICAgICAvLyBEaXNhYmxlIGF1dG8gcXVhbGl0eSBsZXZlbC9mcmFnbWVudCBsb2FkaW5nLlxuICAgICAgICAgIGF1dG9TdGFydExvYWQ6IGZhbHNlLFxuICAgICAgICAgIC8vIEN1c3RvbSBjb25maWd1cmF0aW9uIGZvciBobHMuanMuXG4gICAgICAgICAgLi4udGhpcy5jb25maWdcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB0aGlzLmFwaS5sb2FkU291cmNlKHRoaXMuc3JjKTtcbiAgICAgICAgdGhpcy5hcGkuYXR0YWNoTWVkaWEodGhpcy5uYXRpdmVFbCk7XG4gICAgICAgIHN3aXRjaCAodGhpcy5uYXRpdmVFbC5wcmVsb2FkKSB7XG4gICAgICAgICAgY2FzZSBcIm5vbmVcIjoge1xuICAgICAgICAgICAgY29uc3QgbG9hZFNvdXJjZU9uUGxheSA9ICgpID0+IHRoaXMuYXBpLnN0YXJ0TG9hZCgpO1xuICAgICAgICAgICAgdGhpcy5uYXRpdmVFbC5hZGRFdmVudExpc3RlbmVyKFwicGxheVwiLCBsb2FkU291cmNlT25QbGF5LCB7XG4gICAgICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5hcGkub24oSGxzLkV2ZW50cy5ERVNUUk9ZSU5HLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMubmF0aXZlRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBsYXlcIiwgbG9hZFNvdXJjZU9uUGxheSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwibWV0YWRhdGFcIjoge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxMZW5ndGggPSB0aGlzLmFwaS5jb25maWcubWF4QnVmZmVyTGVuZ3RoO1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxTaXplID0gdGhpcy5hcGkuY29uZmlnLm1heEJ1ZmZlclNpemU7XG4gICAgICAgICAgICB0aGlzLmFwaS5jb25maWcubWF4QnVmZmVyTGVuZ3RoID0gMTtcbiAgICAgICAgICAgIHRoaXMuYXBpLmNvbmZpZy5tYXhCdWZmZXJTaXplID0gMTtcbiAgICAgICAgICAgIGNvbnN0IGluY3JlYXNlQnVmZmVyT25QbGF5ID0gKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLmFwaS5jb25maWcubWF4QnVmZmVyTGVuZ3RoID0gb3JpZ2luYWxMZW5ndGg7XG4gICAgICAgICAgICAgIHRoaXMuYXBpLmNvbmZpZy5tYXhCdWZmZXJTaXplID0gb3JpZ2luYWxTaXplO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMubmF0aXZlRWwuYWRkRXZlbnRMaXN0ZW5lcihcInBsYXlcIiwgaW5jcmVhc2VCdWZmZXJPblBsYXksIHtcbiAgICAgICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmFwaS5vbihIbHMuRXZlbnRzLkRFU1RST1lJTkcsICgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5uYXRpdmVFbC5yZW1vdmVFdmVudExpc3RlbmVyKFwicGxheVwiLCBpbmNyZWFzZUJ1ZmZlck9uUGxheSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuYXBpLnN0YXJ0TG9hZCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLmFwaS5zdGFydExvYWQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uYXRpdmVFbC53ZWJraXRDdXJyZW50UGxheWJhY2tUYXJnZXRJc1dpcmVsZXNzKSB7XG4gICAgICAgICAgdGhpcy5hcGkuc3RvcExvYWQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5hdGl2ZUVsLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgXCJ3ZWJraXRjdXJyZW50cGxheWJhY2t0YXJnZXRpc3dpcmVsZXNzY2hhbmdlZFwiLFxuICAgICAgICAgIHRoaXMuI3RvZ2dsZUhsc0xvYWRcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy4jYWlycGxheVNvdXJjZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNvdXJjZVwiKTtcbiAgICAgICAgdGhpcy4jYWlycGxheVNvdXJjZUVsLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJhcHBsaWNhdGlvbi94LW1wZWdVUkxcIik7XG4gICAgICAgIHRoaXMuI2FpcnBsYXlTb3VyY2VFbC5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgdGhpcy5zcmMpO1xuICAgICAgICB0aGlzLm5hdGl2ZUVsLmRpc2FibGVSZW1vdGVQbGF5YmFjayA9IGZhbHNlO1xuICAgICAgICB0aGlzLm5hdGl2ZUVsLmFwcGVuZCh0aGlzLiNhaXJwbGF5U291cmNlRWwpO1xuICAgICAgICBjb25zdCBsZXZlbElkTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIHRoaXMuYXBpLm9uKEhscy5FdmVudHMuTUFOSUZFU1RfUEFSU0VELCAoZXZlbnQsIGRhdGEpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5uYXRpdmVFbC5hdXRvcGxheSAmJiB0aGlzLm5hdGl2ZUVsLnBhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5uYXRpdmVFbC5wbGF5KCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJBdXRvcGxheSBmYWlsZWQ6XCIsIGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVtb3ZlQWxsTWVkaWFUcmFja3MoKTtcbiAgICAgICAgICBsZXQgdmlkZW9UcmFjayA9IHRoaXMudmlkZW9UcmFja3MuZ2V0VHJhY2tCeUlkKFwibWFpblwiKTtcbiAgICAgICAgICBpZiAoIXZpZGVvVHJhY2spIHtcbiAgICAgICAgICAgIHZpZGVvVHJhY2sgPSB0aGlzLmFkZFZpZGVvVHJhY2soXCJtYWluXCIpO1xuICAgICAgICAgICAgdmlkZW9UcmFjay5pZCA9IFwibWFpblwiO1xuICAgICAgICAgICAgdmlkZW9UcmFjay5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoY29uc3QgW2lkLCBsZXZlbF0gb2YgZGF0YS5sZXZlbHMuZW50cmllcygpKSB7XG4gICAgICAgICAgICBjb25zdCB2aWRlb1JlbmRpdGlvbiA9IHZpZGVvVHJhY2suYWRkUmVuZGl0aW9uKFxuICAgICAgICAgICAgICBsZXZlbC51cmxbMF0sXG4gICAgICAgICAgICAgIGxldmVsLndpZHRoLFxuICAgICAgICAgICAgICBsZXZlbC5oZWlnaHQsXG4gICAgICAgICAgICAgIGxldmVsLnZpZGVvQ29kZWMsXG4gICAgICAgICAgICAgIGxldmVsLmJpdHJhdGVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsZXZlbElkTWFwLnNldChsZXZlbCwgYCR7aWR9YCk7XG4gICAgICAgICAgICB2aWRlb1JlbmRpdGlvbi5pZCA9IGAke2lkfWA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAobGV0IFtpZCwgYV0gb2YgZGF0YS5hdWRpb1RyYWNrcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGtpbmQgPSBhLmRlZmF1bHQgPyBcIm1haW5cIiA6IFwiYWx0ZXJuYXRpdmVcIjtcbiAgICAgICAgICAgIGNvbnN0IGF1ZGlvVHJhY2sgPSB0aGlzLmFkZEF1ZGlvVHJhY2soa2luZCwgYS5uYW1lLCBhLmxhbmcpO1xuICAgICAgICAgICAgYXVkaW9UcmFjay5pZCA9IGAke2lkfWA7XG4gICAgICAgICAgICBpZiAoYS5kZWZhdWx0KSB7XG4gICAgICAgICAgICAgIGF1ZGlvVHJhY2suZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hdWRpb1RyYWNrcy5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsICgpID0+IHtcbiAgICAgICAgICB2YXIgX2EyO1xuICAgICAgICAgIGNvbnN0IGF1ZGlvVHJhY2tJZCA9ICsoKF9hMiA9IFsuLi50aGlzLmF1ZGlvVHJhY2tzXS5maW5kKCh0KSA9PiB0LmVuYWJsZWQpKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmlkKTtcbiAgICAgICAgICBjb25zdCBhdmFpbGFibGVJZHMgPSB0aGlzLmFwaS5hdWRpb1RyYWNrcy5tYXAoKHQpID0+IHQuaWQpO1xuICAgICAgICAgIGlmIChhdWRpb1RyYWNrSWQgIT0gdGhpcy5hcGkuYXVkaW9UcmFjayAmJiBhdmFpbGFibGVJZHMuaW5jbHVkZXMoYXVkaW9UcmFja0lkKSkge1xuICAgICAgICAgICAgdGhpcy5hcGkuYXVkaW9UcmFjayA9IGF1ZGlvVHJhY2tJZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFwaS5vbihIbHMuRXZlbnRzLkxFVkVMU19VUERBVEVELCAoZXZlbnQsIGRhdGEpID0+IHtcbiAgICAgICAgICBjb25zdCB2aWRlb1RyYWNrID0gdGhpcy52aWRlb1RyYWNrc1t0aGlzLnZpZGVvVHJhY2tzLnNlbGVjdGVkSW5kZXggPz8gMF07XG4gICAgICAgICAgaWYgKCF2aWRlb1RyYWNrKSByZXR1cm47XG4gICAgICAgICAgY29uc3QgbGV2ZWxJZHMgPSBkYXRhLmxldmVscy5tYXAoKGwpID0+IGxldmVsSWRNYXAuZ2V0KGwpKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHJlbmRpdGlvbiBvZiB0aGlzLnZpZGVvUmVuZGl0aW9ucykge1xuICAgICAgICAgICAgaWYgKHJlbmRpdGlvbi5pZCAmJiAhbGV2ZWxJZHMuaW5jbHVkZXMocmVuZGl0aW9uLmlkKSkge1xuICAgICAgICAgICAgICB2aWRlb1RyYWNrLnJlbW92ZVJlbmRpdGlvbihyZW5kaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHN3aXRjaFJlbmRpdGlvbiA9IChldmVudCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGxldmVsID0gZXZlbnQudGFyZ2V0LnNlbGVjdGVkSW5kZXg7XG4gICAgICAgICAgaWYgKGxldmVsICE9IHRoaXMuYXBpLm5leHRMZXZlbCkge1xuICAgICAgICAgICAgdGhpcy5hcGkubmV4dExldmVsID0gbGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAoX2IgPSB0aGlzLnZpZGVvUmVuZGl0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgc3dpdGNoUmVuZGl0aW9uKTtcbiAgICAgICAgY29uc3QgcmVtb3ZlQWxsTWVkaWFUcmFja3MgPSAoKSA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCB2aWRlb1RyYWNrIG9mIHRoaXMudmlkZW9UcmFja3MpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlVmlkZW9UcmFjayh2aWRlb1RyYWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChjb25zdCBhdWRpb1RyYWNrIG9mIHRoaXMuYXVkaW9UcmFja3MpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQXVkaW9UcmFjayhhdWRpb1RyYWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYXBpLm9uY2UoSGxzLkV2ZW50cy5ERVNUUk9ZSU5HLCByZW1vdmVBbGxNZWRpYVRyYWNrcyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgaWYgKHRoaXMubmF0aXZlRWwuY2FuUGxheVR5cGUoXCJhcHBsaWNhdGlvbi92bmQuYXBwbGUubXBlZ3VybFwiKSkge1xuICAgICAgICB0aGlzLm5hdGl2ZUVsLnNyYyA9IHRoaXMuc3JjO1xuICAgICAgfVxuICAgIH1cbiAgICAjdG9nZ2xlSGxzTG9hZCA9ICgpID0+IHtcbiAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgaWYgKChfYSA9IHRoaXMubmF0aXZlRWwpID09IG51bGwgPyB2b2lkIDAgOiBfYS53ZWJraXRDdXJyZW50UGxheWJhY2tUYXJnZXRJc1dpcmVsZXNzKSB7XG4gICAgICAgIChfYiA9IHRoaXMuYXBpKSA9PSBudWxsID8gdm9pZCAwIDogX2Iuc3RvcExvYWQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIChfYyA9IHRoaXMuYXBpKSA9PSBudWxsID8gdm9pZCAwIDogX2Muc3RhcnRMb2FkKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICAvLyBUaGlzIGlzIGEgcGF0dGVybiB0byB1cGRhdGUgcHJvcGVydHkgdmFsdWVzIHRoYXQgYXJlIHNldCBiZWZvcmVcbiAgICAvLyB0aGUgY3VzdG9tIGVsZW1lbnQgaXMgdXBncmFkZWQuXG4gICAgLy8gaHR0cHM6Ly93ZWIuZGV2L2N1c3RvbS1lbGVtZW50cy1iZXN0LXByYWN0aWNlcy8jbWFrZS1wcm9wZXJ0aWVzLWxhenlcbiAgICAjdXBncmFkZVByb3BlcnR5KHByb3ApIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcywgcHJvcCkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzW3Byb3BdO1xuICAgICAgICBkZWxldGUgdGhpc1twcm9wXTtcbiAgICAgICAgdGhpc1twcm9wXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG5jb25zdCBIbHNWaWRlb0VsZW1lbnQgPSBIbHNWaWRlb01peGluKE1lZGlhVHJhY2tzTWl4aW4oQ3VzdG9tVmlkZW9FbGVtZW50KSk7XG5pZiAoZ2xvYmFsVGhpcy5jdXN0b21FbGVtZW50cyAmJiAhZ2xvYmFsVGhpcy5jdXN0b21FbGVtZW50cy5nZXQoXCJobHMtdmlkZW9cIikpIHtcbiAgZ2xvYmFsVGhpcy5jdXN0b21FbGVtZW50cy5kZWZpbmUoXCJobHMtdmlkZW9cIiwgSGxzVmlkZW9FbGVtZW50KTtcbn1cbnZhciBobHNfdmlkZW9fZWxlbWVudF9kZWZhdWx0ID0gSGxzVmlkZW9FbGVtZW50O1xuZXhwb3J0IHtcbiAgSGxzLFxuICBIbHNWaWRlb0VsZW1lbnQsXG4gIEhsc1ZpZGVvTWl4aW4sXG4gIGhsc192aWRlb19lbGVtZW50X2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/hls-video-element/dist/hls-video-element.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/hls-video-element/dist/react.js":
/*!******************************************************!*\
  !*** ./node_modules/hls-video-element/dist/react.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ react_default)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _hls_video_element_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hls-video-element.js */ \"(app-pages-browser)/./node_modules/hls-video-element/dist/hls-video-element.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ // dist/react.ts\n\n\n// ../../node_modules/ce-la-react/dist/ce-la-react.js\nvar reservedReactProps = /* @__PURE__ */ new Set([\n    \"style\",\n    \"children\",\n    \"ref\",\n    \"key\",\n    \"suppressContentEditableWarning\",\n    \"suppressHydrationWarning\",\n    \"dangerouslySetInnerHTML\"\n]);\nvar reactPropToAttrNameMap = {\n    className: \"class\",\n    htmlFor: \"for\"\n};\nfunction defaultToAttributeName(propName) {\n    return propName.toLowerCase();\n}\nfunction defaultToAttributeValue(propValue) {\n    if (typeof propValue === \"boolean\") return propValue ? \"\" : void 0;\n    if (typeof propValue === \"function\") return void 0;\n    if (typeof propValue === \"object\" && propValue !== null) return void 0;\n    return propValue;\n}\nfunction createComponent(param) {\n    let { react: React2, tagName, elementClass, events, displayName, defaultProps, toAttributeName = defaultToAttributeName, toAttributeValue = defaultToAttributeValue } = param;\n    var _s = $RefreshSig$();\n    const IS_REACT_19_OR_NEWER = Number.parseInt(React2.version) >= 19;\n    const ReactComponent = React2.forwardRef(_s((props, ref)=>{\n        _s();\n        var _a, _b;\n        const elementRef = React2.useRef(null);\n        const prevElemPropsRef = React2.useRef(/* @__PURE__ */ new Map());\n        const eventProps = {};\n        const attrs = {};\n        const reactProps = {};\n        const elementProps = {};\n        for (const [k, v] of Object.entries(props)){\n            if (reservedReactProps.has(k)) {\n                reactProps[k] = v;\n                continue;\n            }\n            var _reactPropToAttrNameMap_k;\n            const attrName = toAttributeName((_reactPropToAttrNameMap_k = reactPropToAttrNameMap[k]) !== null && _reactPropToAttrNameMap_k !== void 0 ? _reactPropToAttrNameMap_k : k);\n            var _ref;\n            if (k in elementClass.prototype && !(k in ((_ref = (_a = globalThis.HTMLElement) == null ? void 0 : _a.prototype) !== null && _ref !== void 0 ? _ref : {})) && !((_b = elementClass.observedAttributes) == null ? void 0 : _b.some((attr)=>attr === attrName))) {\n                elementProps[k] = v;\n                continue;\n            }\n            if (k.startsWith(\"on\")) {\n                eventProps[k] = v;\n                continue;\n            }\n            const attrValue = toAttributeValue(v);\n            if (attrName && attrValue != null) {\n                attrs[attrName] = String(attrValue);\n                if (!IS_REACT_19_OR_NEWER) {\n                    reactProps[attrName] = attrValue;\n                }\n            }\n            if (attrName && IS_REACT_19_OR_NEWER) {\n                const attrValueFromDefault = defaultToAttributeValue(v);\n                if (attrValue !== attrValueFromDefault) {\n                    reactProps[attrName] = attrValue;\n                } else {\n                    reactProps[attrName] = v;\n                }\n            }\n        }\n        if (typeof window !== \"undefined\") {\n            for(const propName in eventProps){\n                const callback = eventProps[propName];\n                const useCapture = propName.endsWith(\"Capture\");\n                var _ref1;\n                const eventName = ((_ref1 = events == null ? void 0 : events[propName]) !== null && _ref1 !== void 0 ? _ref1 : propName.slice(2).toLowerCase()).slice(0, useCapture ? -7 : void 0);\n                React2.useLayoutEffect({\n                    \"createComponent.ReactComponent.useLayoutEffect\": ()=>{\n                        const eventTarget = elementRef == null ? void 0 : elementRef.current;\n                        if (!eventTarget || typeof callback !== \"function\") return;\n                        eventTarget.addEventListener(eventName, callback, useCapture);\n                        return ({\n                            \"createComponent.ReactComponent.useLayoutEffect\": ()=>{\n                                eventTarget.removeEventListener(eventName, callback, useCapture);\n                            }\n                        })[\"createComponent.ReactComponent.useLayoutEffect\"];\n                    }\n                }[\"createComponent.ReactComponent.useLayoutEffect\"], [\n                    elementRef == null ? void 0 : elementRef.current,\n                    callback\n                ]);\n            }\n            React2.useLayoutEffect({\n                \"createComponent.ReactComponent.useLayoutEffect\": ()=>{\n                    if (elementRef.current === null) return;\n                    const newElemProps = /* @__PURE__ */ new Map();\n                    for(const key in elementProps){\n                        setProperty(elementRef.current, key, elementProps[key]);\n                        prevElemPropsRef.current.delete(key);\n                        newElemProps.set(key, elementProps[key]);\n                    }\n                    for (const [key, _value] of prevElemPropsRef.current){\n                        setProperty(elementRef.current, key, void 0);\n                    }\n                    prevElemPropsRef.current = newElemProps;\n                }\n            }[\"createComponent.ReactComponent.useLayoutEffect\"]);\n        }\n        if (typeof window === \"undefined\" && (elementClass == null ? void 0 : elementClass.getTemplateHTML) && (elementClass == null ? void 0 : elementClass.shadowRootOptions)) {\n            const { mode, delegatesFocus } = elementClass.shadowRootOptions;\n            const templateShadowRoot = React2.createElement(\"template\", {\n                shadowrootmode: mode,\n                shadowrootdelegatesfocus: delegatesFocus,\n                dangerouslySetInnerHTML: {\n                    __html: elementClass.getTemplateHTML(attrs, props)\n                }\n            });\n            reactProps.children = [\n                templateShadowRoot,\n                reactProps.children\n            ];\n        }\n        return React2.createElement(tagName, {\n            ...defaultProps,\n            ...reactProps,\n            ref: React2.useCallback({\n                \"createComponent.ReactComponent.useCallback\": (node)=>{\n                    elementRef.current = node;\n                    if (typeof ref === \"function\") {\n                        ref(node);\n                    } else if (ref !== null) {\n                        ref.current = node;\n                    }\n                }\n            }[\"createComponent.ReactComponent.useCallback\"], [\n                ref\n            ])\n        });\n    }, \"9mplyF7vgg8XUtKXUe3PLSYpH8g=\"));\n    ReactComponent.displayName = displayName !== null && displayName !== void 0 ? displayName : elementClass.name;\n    return ReactComponent;\n}\nfunction setProperty(node, name, value) {\n    var _a;\n    node[name] = value;\n    var _ref;\n    if (value == null && name in ((_ref = (_a = globalThis.HTMLElement) == null ? void 0 : _a.prototype) !== null && _ref !== void 0 ? _ref : {})) {\n        node.removeAttribute(name);\n    }\n}\n// dist/react.ts\nvar react_default = createComponent({\n    react: react__WEBPACK_IMPORTED_MODULE_0__,\n    tagName: \"hls-video\",\n    elementClass: _hls_video_element_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n    toAttributeName (propName) {\n        if (propName === \"muted\") return \"\";\n        if (propName === \"defaultMuted\") return \"muted\";\n        return defaultToAttributeName(propName);\n    }\n});\n /*! Bundled license information:\n\nce-la-react/dist/ce-la-react.js:\n  (**\n   * @license\n   * Copyright 2018 Google LLC\n   * SPDX-License-Identifier: BSD-3-Clause\n   *\n   * Modified version of `@lit/react` for vanilla custom elements with support for SSR.\n   *)\n*/ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9obHMtdmlkZW8tZWxlbWVudC9kaXN0L3JlYWN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs2REFFQSxnQkFBZ0I7QUFDVTtBQUM4QjtBQUV4RCxxREFBcUQ7QUFDckQsSUFBSUUscUJBQXFCLGFBQWEsR0FBRyxJQUFJQyxJQUFJO0lBQy9DO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0Q7QUFDRCxJQUFJQyx5QkFBeUI7SUFDM0JDLFdBQVc7SUFDWEMsU0FBUztBQUNYO0FBQ0EsU0FBU0MsdUJBQXVCQyxRQUFRO0lBQ3RDLE9BQU9BLFNBQVNDLFdBQVc7QUFDN0I7QUFDQSxTQUFTQyx3QkFBd0JDLFNBQVM7SUFDeEMsSUFBSSxPQUFPQSxjQUFjLFdBQVcsT0FBT0EsWUFBWSxLQUFLLEtBQUs7SUFDakUsSUFBSSxPQUFPQSxjQUFjLFlBQVksT0FBTyxLQUFLO0lBQ2pELElBQUksT0FBT0EsY0FBYyxZQUFZQSxjQUFjLE1BQU0sT0FBTyxLQUFLO0lBQ3JFLE9BQU9BO0FBQ1Q7QUFDQSxTQUFTQyxnQkFBZ0IsS0FTeEI7UUFUd0IsRUFDdkJDLE9BQU9DLE1BQU0sRUFDYkMsT0FBTyxFQUNQQyxZQUFZLEVBQ1pDLE1BQU0sRUFDTkMsV0FBVyxFQUNYQyxZQUFZLEVBQ1pDLGtCQUFrQmIsc0JBQXNCLEVBQ3hDYyxtQkFBbUJYLHVCQUF1QixFQUMzQyxHQVR3Qjs7SUFVdkIsTUFBTVksdUJBQXVCQyxPQUFPQyxRQUFRLENBQUNWLE9BQU9XLE9BQU8sS0FBSztJQUNoRSxNQUFNQyxpQkFBaUJaLE9BQU9hLFVBQVUsSUFBQyxDQUFDQyxPQUFPQzs7UUFDL0MsSUFBSUMsSUFBSUM7UUFDUixNQUFNQyxhQUFhbEIsT0FBT21CLE1BQU0sQ0FBQztRQUNqQyxNQUFNQyxtQkFBbUJwQixPQUFPbUIsTUFBTSxDQUFDLGFBQWEsR0FBRyxJQUFJRTtRQUMzRCxNQUFNQyxhQUFhLENBQUM7UUFDcEIsTUFBTUMsUUFBUSxDQUFDO1FBQ2YsTUFBTUMsYUFBYSxDQUFDO1FBQ3BCLE1BQU1DLGVBQWUsQ0FBQztRQUN0QixLQUFLLE1BQU0sQ0FBQ0MsR0FBR0MsRUFBRSxJQUFJQyxPQUFPQyxPQUFPLENBQUNmLE9BQVE7WUFDMUMsSUFBSTFCLG1CQUFtQjBDLEdBQUcsQ0FBQ0osSUFBSTtnQkFDN0JGLFVBQVUsQ0FBQ0UsRUFBRSxHQUFHQztnQkFDaEI7WUFDRjtnQkFDaUNyQztZQUFqQyxNQUFNeUMsV0FBV3pCLGdCQUFnQmhCLENBQUFBLDRCQUFBQSxzQkFBc0IsQ0FBQ29DLEVBQUUsY0FBekJwQyx1Q0FBQUEsNEJBQTZCb0M7Z0JBQ2xCO1lBQTVDLElBQUlBLEtBQUt4QixhQUFhOEIsU0FBUyxJQUFJLENBQUVOLENBQUFBLEtBQU0sRUFBQyxRQUFDVixLQUFLaUIsV0FBV0MsV0FBVyxLQUFLLE9BQU8sS0FBSyxJQUFJbEIsR0FBR2dCLFNBQVMsY0FBN0QseUJBQWtFLENBQUMsRUFBQyxLQUFNLENBQUUsRUFBQ2YsS0FBS2YsYUFBYWlDLGtCQUFrQixLQUFLLE9BQU8sS0FBSyxJQUFJbEIsR0FBR21CLElBQUksQ0FBQyxDQUFDQyxPQUFTQSxTQUFTTixTQUFRLEdBQUk7Z0JBQ3ZOTixZQUFZLENBQUNDLEVBQUUsR0FBR0M7Z0JBQ2xCO1lBQ0Y7WUFDQSxJQUFJRCxFQUFFWSxVQUFVLENBQUMsT0FBTztnQkFDdEJoQixVQUFVLENBQUNJLEVBQUUsR0FBR0M7Z0JBQ2hCO1lBQ0Y7WUFDQSxNQUFNWSxZQUFZaEMsaUJBQWlCb0I7WUFDbkMsSUFBSUksWUFBWVEsYUFBYSxNQUFNO2dCQUNqQ2hCLEtBQUssQ0FBQ1EsU0FBUyxHQUFHUyxPQUFPRDtnQkFDekIsSUFBSSxDQUFDL0Isc0JBQXNCO29CQUN6QmdCLFVBQVUsQ0FBQ08sU0FBUyxHQUFHUTtnQkFDekI7WUFDRjtZQUNBLElBQUlSLFlBQVl2QixzQkFBc0I7Z0JBQ3BDLE1BQU1pQyx1QkFBdUI3Qyx3QkFBd0IrQjtnQkFDckQsSUFBSVksY0FBY0Usc0JBQXNCO29CQUN0Q2pCLFVBQVUsQ0FBQ08sU0FBUyxHQUFHUTtnQkFDekIsT0FBTztvQkFDTGYsVUFBVSxDQUFDTyxTQUFTLEdBQUdKO2dCQUN6QjtZQUNGO1FBQ0Y7UUFDQSxJQUFJLE9BQU9lLFdBQVcsYUFBYTtZQUNqQyxJQUFLLE1BQU1oRCxZQUFZNEIsV0FBWTtnQkFDakMsTUFBTXFCLFdBQVdyQixVQUFVLENBQUM1QixTQUFTO2dCQUNyQyxNQUFNa0QsYUFBYWxELFNBQVNtRCxRQUFRLENBQUM7b0JBQ2pCMUM7Z0JBQXBCLE1BQU0yQyxZQUFZLENBQUMsQ0FBQzNDLFFBQUFBLFVBQVUsT0FBTyxLQUFLLElBQUlBLE1BQU0sQ0FBQ1QsU0FBUyxjQUExQ1MsbUJBQUFBLFFBQStDVCxTQUFTcUQsS0FBSyxDQUFDLEdBQUdwRCxXQUFXLEVBQUMsRUFBR29ELEtBQUssQ0FDdkcsR0FDQUgsYUFBYSxDQUFDLElBQUksS0FBSztnQkFFekI1QyxPQUFPZ0QsZUFBZTtzRUFBQzt3QkFDckIsTUFBTUMsY0FBYy9CLGNBQWMsT0FBTyxLQUFLLElBQUlBLFdBQVdnQyxPQUFPO3dCQUNwRSxJQUFJLENBQUNELGVBQWUsT0FBT04sYUFBYSxZQUFZO3dCQUNwRE0sWUFBWUUsZ0JBQWdCLENBQUNMLFdBQVdILFVBQVVDO3dCQUNsRDs4RUFBTztnQ0FDTEssWUFBWUcsbUJBQW1CLENBQUNOLFdBQVdILFVBQVVDOzRCQUN2RDs7b0JBQ0Y7cUVBQUc7b0JBQUMxQixjQUFjLE9BQU8sS0FBSyxJQUFJQSxXQUFXZ0MsT0FBTztvQkFBRVA7aUJBQVM7WUFDakU7WUFDQTNDLE9BQU9nRCxlQUFlO2tFQUFDO29CQUNyQixJQUFJOUIsV0FBV2dDLE9BQU8sS0FBSyxNQUFNO29CQUNqQyxNQUFNRyxlQUFlLGFBQWEsR0FBRyxJQUFJaEM7b0JBQ3pDLElBQUssTUFBTWlDLE9BQU83QixhQUFjO3dCQUM5QjhCLFlBQVlyQyxXQUFXZ0MsT0FBTyxFQUFFSSxLQUFLN0IsWUFBWSxDQUFDNkIsSUFBSTt3QkFDdERsQyxpQkFBaUI4QixPQUFPLENBQUNNLE1BQU0sQ0FBQ0Y7d0JBQ2hDRCxhQUFhSSxHQUFHLENBQUNILEtBQUs3QixZQUFZLENBQUM2QixJQUFJO29CQUN6QztvQkFDQSxLQUFLLE1BQU0sQ0FBQ0EsS0FBS0ksT0FBTyxJQUFJdEMsaUJBQWlCOEIsT0FBTyxDQUFFO3dCQUNwREssWUFBWXJDLFdBQVdnQyxPQUFPLEVBQUVJLEtBQUssS0FBSztvQkFDNUM7b0JBQ0FsQyxpQkFBaUI4QixPQUFPLEdBQUdHO2dCQUM3Qjs7UUFDRjtRQUNBLElBQUksT0FBT1gsV0FBVyxlQUFnQnhDLENBQUFBLGdCQUFnQixPQUFPLEtBQUssSUFBSUEsYUFBYXlELGVBQWUsS0FBTXpELENBQUFBLGdCQUFnQixPQUFPLEtBQUssSUFBSUEsYUFBYTBELGlCQUFpQixHQUFHO1lBQ3ZLLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxjQUFjLEVBQUUsR0FBRzVELGFBQWEwRCxpQkFBaUI7WUFDL0QsTUFBTUcscUJBQXFCL0QsT0FBT2dFLGFBQWEsQ0FBQyxZQUFZO2dCQUMxREMsZ0JBQWdCSjtnQkFDaEJLLDBCQUEwQko7Z0JBQzFCSyx5QkFBeUI7b0JBQ3ZCQyxRQUFRbEUsYUFBYXlELGVBQWUsQ0FBQ3BDLE9BQU9UO2dCQUM5QztZQUNGO1lBQ0FVLFdBQVc2QyxRQUFRLEdBQUc7Z0JBQUNOO2dCQUFvQnZDLFdBQVc2QyxRQUFRO2FBQUM7UUFDakU7UUFDQSxPQUFPckUsT0FBT2dFLGFBQWEsQ0FBQy9ELFNBQVM7WUFDbkMsR0FBR0ksWUFBWTtZQUNmLEdBQUdtQixVQUFVO1lBQ2JULEtBQUtmLE9BQU9zRSxXQUFXOzhEQUNyQixDQUFDQztvQkFDQ3JELFdBQVdnQyxPQUFPLEdBQUdxQjtvQkFDckIsSUFBSSxPQUFPeEQsUUFBUSxZQUFZO3dCQUM3QkEsSUFBSXdEO29CQUNOLE9BQU8sSUFBSXhELFFBQVEsTUFBTTt3QkFDdkJBLElBQUltQyxPQUFPLEdBQUdxQjtvQkFDaEI7Z0JBQ0Y7NkRBQ0E7Z0JBQUN4RDthQUFJO1FBRVQ7SUFDRjtJQUNBSCxlQUFlUixXQUFXLEdBQUdBLHdCQUFBQSx5QkFBQUEsY0FBZUYsYUFBYXNFLElBQUk7SUFDN0QsT0FBTzVEO0FBQ1Q7QUFDQSxTQUFTMkMsWUFBWWdCLElBQUksRUFBRUMsSUFBSSxFQUFFQyxLQUFLO0lBQ3BDLElBQUl6RDtJQUNKdUQsSUFBSSxDQUFDQyxLQUFLLEdBQUdDO1FBQ2tCO0lBQS9CLElBQUlBLFNBQVMsUUFBUUQsUUFBUyxFQUFDLFFBQUN4RCxLQUFLaUIsV0FBV0MsV0FBVyxLQUFLLE9BQU8sS0FBSyxJQUFJbEIsR0FBR2dCLFNBQVMsY0FBN0QseUJBQWtFLENBQUMsSUFBSTtRQUNwR3VDLEtBQUtHLGVBQWUsQ0FBQ0Y7SUFDdkI7QUFDRjtBQUVBLGdCQUFnQjtBQUNoQixJQUFJRyxnQkFBZ0I3RSxnQkFBZ0I7SUFDbENDLE9BQU9iLGtDQUFLQTtJQUNaZSxTQUFTO0lBQ1RDLGNBQWNmLDZEQUFrQkE7SUFDaENtQixpQkFBZ0JaLFFBQVE7UUFDdEIsSUFBSUEsYUFBYSxTQUFTLE9BQU87UUFDakMsSUFBSUEsYUFBYSxnQkFBZ0IsT0FBTztRQUN4QyxPQUFPRCx1QkFBdUJDO0lBQ2hDO0FBQ0Y7QUFHRSxDQUNGOzs7Ozs7Ozs7O0FBVUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9FdGhhbkxlZS9EZXNrdG9wL0FkdlgvQUktV2F0Y2gtQnVkZHkvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2hscy12aWRlby1lbGVtZW50L2Rpc3QvcmVhY3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbi8vIGRpc3QvcmVhY3QudHNcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBDdXN0b21NZWRpYUVsZW1lbnQgZnJvbSBcIi4vaGxzLXZpZGVvLWVsZW1lbnQuanNcIjtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2NlLWxhLXJlYWN0L2Rpc3QvY2UtbGEtcmVhY3QuanNcbnZhciByZXNlcnZlZFJlYWN0UHJvcHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwic3R5bGVcIixcbiAgXCJjaGlsZHJlblwiLFxuICBcInJlZlwiLFxuICBcImtleVwiLFxuICBcInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ1wiLFxuICBcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiLFxuICBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCJcbl0pO1xudmFyIHJlYWN0UHJvcFRvQXR0ck5hbWVNYXAgPSB7XG4gIGNsYXNzTmFtZTogXCJjbGFzc1wiLFxuICBodG1sRm9yOiBcImZvclwiXG59O1xuZnVuY3Rpb24gZGVmYXVsdFRvQXR0cmlidXRlTmFtZShwcm9wTmFtZSkge1xuICByZXR1cm4gcHJvcE5hbWUudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRUb0F0dHJpYnV0ZVZhbHVlKHByb3BWYWx1ZSkge1xuICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gXCJib29sZWFuXCIpIHJldHVybiBwcm9wVmFsdWUgPyBcIlwiIDogdm9pZCAwO1xuICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdm9pZCAwO1xuICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBwcm9wVmFsdWUgIT09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gIHJldHVybiBwcm9wVmFsdWU7XG59XG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnQoe1xuICByZWFjdDogUmVhY3QyLFxuICB0YWdOYW1lLFxuICBlbGVtZW50Q2xhc3MsXG4gIGV2ZW50cyxcbiAgZGlzcGxheU5hbWUsXG4gIGRlZmF1bHRQcm9wcyxcbiAgdG9BdHRyaWJ1dGVOYW1lID0gZGVmYXVsdFRvQXR0cmlidXRlTmFtZSxcbiAgdG9BdHRyaWJ1dGVWYWx1ZSA9IGRlZmF1bHRUb0F0dHJpYnV0ZVZhbHVlXG59KSB7XG4gIGNvbnN0IElTX1JFQUNUXzE5X09SX05FV0VSID0gTnVtYmVyLnBhcnNlSW50KFJlYWN0Mi52ZXJzaW9uKSA+PSAxOTtcbiAgY29uc3QgUmVhY3RDb21wb25lbnQgPSBSZWFjdDIuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgZWxlbWVudFJlZiA9IFJlYWN0Mi51c2VSZWYobnVsbCk7XG4gICAgY29uc3QgcHJldkVsZW1Qcm9wc1JlZiA9IFJlYWN0Mi51c2VSZWYoLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgY29uc3QgZXZlbnRQcm9wcyA9IHt9O1xuICAgIGNvbnN0IGF0dHJzID0ge307XG4gICAgY29uc3QgcmVhY3RQcm9wcyA9IHt9O1xuICAgIGNvbnN0IGVsZW1lbnRQcm9wcyA9IHt9O1xuICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKHByb3BzKSkge1xuICAgICAgaWYgKHJlc2VydmVkUmVhY3RQcm9wcy5oYXMoaykpIHtcbiAgICAgICAgcmVhY3RQcm9wc1trXSA9IHY7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgYXR0ck5hbWUgPSB0b0F0dHJpYnV0ZU5hbWUocmVhY3RQcm9wVG9BdHRyTmFtZU1hcFtrXSA/PyBrKTtcbiAgICAgIGlmIChrIGluIGVsZW1lbnRDbGFzcy5wcm90b3R5cGUgJiYgIShrIGluICgoKF9hID0gZ2xvYmFsVGhpcy5IVE1MRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnByb3RvdHlwZSkgPz8ge30pKSAmJiAhKChfYiA9IGVsZW1lbnRDbGFzcy5vYnNlcnZlZEF0dHJpYnV0ZXMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5zb21lKChhdHRyKSA9PiBhdHRyID09PSBhdHRyTmFtZSkpKSB7XG4gICAgICAgIGVsZW1lbnRQcm9wc1trXSA9IHY7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGsuc3RhcnRzV2l0aChcIm9uXCIpKSB7XG4gICAgICAgIGV2ZW50UHJvcHNba10gPSB2O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGF0dHJWYWx1ZSA9IHRvQXR0cmlidXRlVmFsdWUodik7XG4gICAgICBpZiAoYXR0ck5hbWUgJiYgYXR0clZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgYXR0cnNbYXR0ck5hbWVdID0gU3RyaW5nKGF0dHJWYWx1ZSk7XG4gICAgICAgIGlmICghSVNfUkVBQ1RfMTlfT1JfTkVXRVIpIHtcbiAgICAgICAgICByZWFjdFByb3BzW2F0dHJOYW1lXSA9IGF0dHJWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGF0dHJOYW1lICYmIElTX1JFQUNUXzE5X09SX05FV0VSKSB7XG4gICAgICAgIGNvbnN0IGF0dHJWYWx1ZUZyb21EZWZhdWx0ID0gZGVmYXVsdFRvQXR0cmlidXRlVmFsdWUodik7XG4gICAgICAgIGlmIChhdHRyVmFsdWUgIT09IGF0dHJWYWx1ZUZyb21EZWZhdWx0KSB7XG4gICAgICAgICAgcmVhY3RQcm9wc1thdHRyTmFtZV0gPSBhdHRyVmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVhY3RQcm9wc1thdHRyTmFtZV0gPSB2O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBmb3IgKGNvbnN0IHByb3BOYW1lIGluIGV2ZW50UHJvcHMpIHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBldmVudFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgY29uc3QgdXNlQ2FwdHVyZSA9IHByb3BOYW1lLmVuZHNXaXRoKFwiQ2FwdHVyZVwiKTtcbiAgICAgICAgY29uc3QgZXZlbnROYW1lID0gKChldmVudHMgPT0gbnVsbCA/IHZvaWQgMCA6IGV2ZW50c1twcm9wTmFtZV0pID8/IHByb3BOYW1lLnNsaWNlKDIpLnRvTG93ZXJDYXNlKCkpLnNsaWNlKFxuICAgICAgICAgIDAsXG4gICAgICAgICAgdXNlQ2FwdHVyZSA/IC03IDogdm9pZCAwXG4gICAgICAgICk7XG4gICAgICAgIFJlYWN0Mi51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGV2ZW50VGFyZ2V0ID0gZWxlbWVudFJlZiA9PSBudWxsID8gdm9pZCAwIDogZWxlbWVudFJlZi5jdXJyZW50O1xuICAgICAgICAgIGlmICghZXZlbnRUYXJnZXQgfHwgdHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybjtcbiAgICAgICAgICBldmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgY2FsbGJhY2ssIHVzZUNhcHR1cmUpO1xuICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBldmVudFRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgY2FsbGJhY2ssIHVzZUNhcHR1cmUpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0sIFtlbGVtZW50UmVmID09IG51bGwgPyB2b2lkIDAgOiBlbGVtZW50UmVmLmN1cnJlbnQsIGNhbGxiYWNrXSk7XG4gICAgICB9XG4gICAgICBSZWFjdDIudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGVsZW1lbnRSZWYuY3VycmVudCA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBuZXdFbGVtUHJvcHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBlbGVtZW50UHJvcHMpIHtcbiAgICAgICAgICBzZXRQcm9wZXJ0eShlbGVtZW50UmVmLmN1cnJlbnQsIGtleSwgZWxlbWVudFByb3BzW2tleV0pO1xuICAgICAgICAgIHByZXZFbGVtUHJvcHNSZWYuY3VycmVudC5kZWxldGUoa2V5KTtcbiAgICAgICAgICBuZXdFbGVtUHJvcHMuc2V0KGtleSwgZWxlbWVudFByb3BzW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgX3ZhbHVlXSBvZiBwcmV2RWxlbVByb3BzUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICBzZXRQcm9wZXJ0eShlbGVtZW50UmVmLmN1cnJlbnQsIGtleSwgdm9pZCAwKTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2RWxlbVByb3BzUmVmLmN1cnJlbnQgPSBuZXdFbGVtUHJvcHM7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgJiYgKGVsZW1lbnRDbGFzcyA9PSBudWxsID8gdm9pZCAwIDogZWxlbWVudENsYXNzLmdldFRlbXBsYXRlSFRNTCkgJiYgKGVsZW1lbnRDbGFzcyA9PSBudWxsID8gdm9pZCAwIDogZWxlbWVudENsYXNzLnNoYWRvd1Jvb3RPcHRpb25zKSkge1xuICAgICAgY29uc3QgeyBtb2RlLCBkZWxlZ2F0ZXNGb2N1cyB9ID0gZWxlbWVudENsYXNzLnNoYWRvd1Jvb3RPcHRpb25zO1xuICAgICAgY29uc3QgdGVtcGxhdGVTaGFkb3dSb290ID0gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiLCB7XG4gICAgICAgIHNoYWRvd3Jvb3Rtb2RlOiBtb2RlLFxuICAgICAgICBzaGFkb3dyb290ZGVsZWdhdGVzZm9jdXM6IGRlbGVnYXRlc0ZvY3VzLFxuICAgICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xuICAgICAgICAgIF9faHRtbDogZWxlbWVudENsYXNzLmdldFRlbXBsYXRlSFRNTChhdHRycywgcHJvcHMpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmVhY3RQcm9wcy5jaGlsZHJlbiA9IFt0ZW1wbGF0ZVNoYWRvd1Jvb3QsIHJlYWN0UHJvcHMuY2hpbGRyZW5dO1xuICAgIH1cbiAgICByZXR1cm4gUmVhY3QyLmNyZWF0ZUVsZW1lbnQodGFnTmFtZSwge1xuICAgICAgLi4uZGVmYXVsdFByb3BzLFxuICAgICAgLi4ucmVhY3RQcm9wcyxcbiAgICAgIHJlZjogUmVhY3QyLnVzZUNhbGxiYWNrKFxuICAgICAgICAobm9kZSkgPT4ge1xuICAgICAgICAgIGVsZW1lbnRSZWYuY3VycmVudCA9IG5vZGU7XG4gICAgICAgICAgaWYgKHR5cGVvZiByZWYgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmVmKG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmVmICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZWYuY3VycmVudCA9IG5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBbcmVmXVxuICAgICAgKVxuICAgIH0pO1xuICB9KTtcbiAgUmVhY3RDb21wb25lbnQuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZSA/PyBlbGVtZW50Q2xhc3MubmFtZTtcbiAgcmV0dXJuIFJlYWN0Q29tcG9uZW50O1xufVxuZnVuY3Rpb24gc2V0UHJvcGVydHkobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgdmFyIF9hO1xuICBub2RlW25hbWVdID0gdmFsdWU7XG4gIGlmICh2YWx1ZSA9PSBudWxsICYmIG5hbWUgaW4gKCgoX2EgPSBnbG9iYWxUaGlzLkhUTUxFbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EucHJvdG90eXBlKSA/PyB7fSkpIHtcbiAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgfVxufVxuXG4vLyBkaXN0L3JlYWN0LnRzXG52YXIgcmVhY3RfZGVmYXVsdCA9IGNyZWF0ZUNvbXBvbmVudCh7XG4gIHJlYWN0OiBSZWFjdCxcbiAgdGFnTmFtZTogXCJobHMtdmlkZW9cIixcbiAgZWxlbWVudENsYXNzOiBDdXN0b21NZWRpYUVsZW1lbnQsXG4gIHRvQXR0cmlidXRlTmFtZShwcm9wTmFtZSkge1xuICAgIGlmIChwcm9wTmFtZSA9PT0gXCJtdXRlZFwiKSByZXR1cm4gXCJcIjtcbiAgICBpZiAocHJvcE5hbWUgPT09IFwiZGVmYXVsdE11dGVkXCIpIHJldHVybiBcIm11dGVkXCI7XG4gICAgcmV0dXJuIGRlZmF1bHRUb0F0dHJpYnV0ZU5hbWUocHJvcE5hbWUpO1xuICB9XG59KTtcbmV4cG9ydCB7XG4gIHJlYWN0X2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbi8qISBCdW5kbGVkIGxpY2Vuc2UgaW5mb3JtYXRpb246XG5cbmNlLWxhLXJlYWN0L2Rpc3QvY2UtbGEtcmVhY3QuanM6XG4gICgqKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG4gICAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBCU0QtMy1DbGF1c2VcbiAgICpcbiAgICogTW9kaWZpZWQgdmVyc2lvbiBvZiBgQGxpdC9yZWFjdGAgZm9yIHZhbmlsbGEgY3VzdG9tIGVsZW1lbnRzIHdpdGggc3VwcG9ydCBmb3IgU1NSLlxuICAgKilcbiovXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJDdXN0b21NZWRpYUVsZW1lbnQiLCJyZXNlcnZlZFJlYWN0UHJvcHMiLCJTZXQiLCJyZWFjdFByb3BUb0F0dHJOYW1lTWFwIiwiY2xhc3NOYW1lIiwiaHRtbEZvciIsImRlZmF1bHRUb0F0dHJpYnV0ZU5hbWUiLCJwcm9wTmFtZSIsInRvTG93ZXJDYXNlIiwiZGVmYXVsdFRvQXR0cmlidXRlVmFsdWUiLCJwcm9wVmFsdWUiLCJjcmVhdGVDb21wb25lbnQiLCJyZWFjdCIsIlJlYWN0MiIsInRhZ05hbWUiLCJlbGVtZW50Q2xhc3MiLCJldmVudHMiLCJkaXNwbGF5TmFtZSIsImRlZmF1bHRQcm9wcyIsInRvQXR0cmlidXRlTmFtZSIsInRvQXR0cmlidXRlVmFsdWUiLCJJU19SRUFDVF8xOV9PUl9ORVdFUiIsIk51bWJlciIsInBhcnNlSW50IiwidmVyc2lvbiIsIlJlYWN0Q29tcG9uZW50IiwiZm9yd2FyZFJlZiIsInByb3BzIiwicmVmIiwiX2EiLCJfYiIsImVsZW1lbnRSZWYiLCJ1c2VSZWYiLCJwcmV2RWxlbVByb3BzUmVmIiwiTWFwIiwiZXZlbnRQcm9wcyIsImF0dHJzIiwicmVhY3RQcm9wcyIsImVsZW1lbnRQcm9wcyIsImsiLCJ2IiwiT2JqZWN0IiwiZW50cmllcyIsImhhcyIsImF0dHJOYW1lIiwicHJvdG90eXBlIiwiZ2xvYmFsVGhpcyIsIkhUTUxFbGVtZW50Iiwib2JzZXJ2ZWRBdHRyaWJ1dGVzIiwic29tZSIsImF0dHIiLCJzdGFydHNXaXRoIiwiYXR0clZhbHVlIiwiU3RyaW5nIiwiYXR0clZhbHVlRnJvbURlZmF1bHQiLCJ3aW5kb3ciLCJjYWxsYmFjayIsInVzZUNhcHR1cmUiLCJlbmRzV2l0aCIsImV2ZW50TmFtZSIsInNsaWNlIiwidXNlTGF5b3V0RWZmZWN0IiwiZXZlbnRUYXJnZXQiLCJjdXJyZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJuZXdFbGVtUHJvcHMiLCJrZXkiLCJzZXRQcm9wZXJ0eSIsImRlbGV0ZSIsInNldCIsIl92YWx1ZSIsImdldFRlbXBsYXRlSFRNTCIsInNoYWRvd1Jvb3RPcHRpb25zIiwibW9kZSIsImRlbGVnYXRlc0ZvY3VzIiwidGVtcGxhdGVTaGFkb3dSb290IiwiY3JlYXRlRWxlbWVudCIsInNoYWRvd3Jvb3Rtb2RlIiwic2hhZG93cm9vdGRlbGVnYXRlc2ZvY3VzIiwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiLCJfX2h0bWwiLCJjaGlsZHJlbiIsInVzZUNhbGxiYWNrIiwibm9kZSIsIm5hbWUiLCJ2YWx1ZSIsInJlbW92ZUF0dHJpYnV0ZSIsInJlYWN0X2RlZmF1bHQiLCJkZWZhdWx0Il0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/hls-video-element/dist/react.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/hls.js/dist/hls.mjs":
/*!******************************************!*\
  !*** ./node_modules/hls.js/dist/hls.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbrController: () => (/* binding */ AbrController),\n/* harmony export */   AttrList: () => (/* binding */ AttrList),\n/* harmony export */   AudioStreamController: () => (/* binding */ AudioStreamController),\n/* harmony export */   AudioTrackController: () => (/* binding */ AudioTrackController),\n/* harmony export */   BasePlaylistController: () => (/* binding */ BasePlaylistController),\n/* harmony export */   BaseSegment: () => (/* binding */ BaseSegment),\n/* harmony export */   BaseStreamController: () => (/* binding */ BaseStreamController),\n/* harmony export */   BufferController: () => (/* binding */ BufferController),\n/* harmony export */   CMCDController: () => (/* binding */ CMCDController),\n/* harmony export */   CapLevelController: () => (/* binding */ CapLevelController),\n/* harmony export */   ChunkMetadata: () => (/* binding */ ChunkMetadata),\n/* harmony export */   ContentSteeringController: () => (/* binding */ ContentSteeringController),\n/* harmony export */   Cues: () => (/* binding */ Cues),\n/* harmony export */   DateRange: () => (/* binding */ DateRange),\n/* harmony export */   EMEController: () => (/* binding */ EMEController),\n/* harmony export */   ErrorActionFlags: () => (/* binding */ ErrorActionFlags),\n/* harmony export */   ErrorController: () => (/* binding */ ErrorController),\n/* harmony export */   ErrorDetails: () => (/* binding */ ErrorDetails),\n/* harmony export */   ErrorTypes: () => (/* binding */ ErrorTypes),\n/* harmony export */   Events: () => (/* binding */ Events),\n/* harmony export */   FPSController: () => (/* binding */ FPSController),\n/* harmony export */   FetchLoader: () => (/* binding */ FetchLoader),\n/* harmony export */   Fragment: () => (/* binding */ Fragment),\n/* harmony export */   Hls: () => (/* binding */ Hls),\n/* harmony export */   HlsSkip: () => (/* binding */ HlsSkip),\n/* harmony export */   HlsUrlParameters: () => (/* binding */ HlsUrlParameters),\n/* harmony export */   KeySystemFormats: () => (/* binding */ KeySystemFormats),\n/* harmony export */   KeySystems: () => (/* binding */ KeySystems),\n/* harmony export */   Level: () => (/* binding */ Level),\n/* harmony export */   LevelDetails: () => (/* binding */ LevelDetails),\n/* harmony export */   LevelKey: () => (/* binding */ LevelKey),\n/* harmony export */   LoadStats: () => (/* binding */ LoadStats),\n/* harmony export */   M3U8Parser: () => (/* binding */ M3U8Parser),\n/* harmony export */   MetadataSchema: () => (/* binding */ MetadataSchema),\n/* harmony export */   NetworkErrorAction: () => (/* binding */ NetworkErrorAction),\n/* harmony export */   Part: () => (/* binding */ Part),\n/* harmony export */   PlaylistLevelType: () => (/* binding */ PlaylistLevelType),\n/* harmony export */   SubtitleStreamController: () => (/* binding */ SubtitleStreamController),\n/* harmony export */   SubtitleTrackController: () => (/* binding */ SubtitleTrackController),\n/* harmony export */   TimelineController: () => (/* binding */ TimelineController),\n/* harmony export */   XhrLoader: () => (/* binding */ XhrLoader),\n/* harmony export */   \"default\": () => (/* binding */ Hls),\n/* harmony export */   fetchSupported: () => (/* binding */ fetchSupported),\n/* harmony export */   getMediaSource: () => (/* binding */ getMediaSource),\n/* harmony export */   isMSESupported: () => (/* binding */ isMSESupported),\n/* harmony export */   isSupported: () => (/* binding */ isSupported),\n/* harmony export */   requestMediaKeySystemAccess: () => (/* binding */ requestMediaKeySystemAccess)\n/* harmony export */ });\n// https://caniuse.com/mdn-javascript_builtins_number_isfinite\nconst isFiniteNumber = Number.isFinite || function (value) {\n  return typeof value === 'number' && isFinite(value);\n};\n\n// https://caniuse.com/mdn-javascript_builtins_number_issafeinteger\nconst isSafeInteger = Number.isSafeInteger || function (value) {\n  return typeof value === 'number' && Math.abs(value) <= MAX_SAFE_INTEGER;\n};\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\n\nlet ErrorTypes = /*#__PURE__*/function (ErrorTypes) {\n  // Identifier for a network error (loading error / timeout ...)\n  ErrorTypes[\"NETWORK_ERROR\"] = \"networkError\";\n  // Identifier for a media Error (video/parsing/mediasource error)\n  ErrorTypes[\"MEDIA_ERROR\"] = \"mediaError\";\n  // EME (encrypted media extensions) errors\n  ErrorTypes[\"KEY_SYSTEM_ERROR\"] = \"keySystemError\";\n  // Identifier for a mux Error (demuxing/remuxing)\n  ErrorTypes[\"MUX_ERROR\"] = \"muxError\";\n  // Identifier for all other errors\n  ErrorTypes[\"OTHER_ERROR\"] = \"otherError\";\n  return ErrorTypes;\n}({});\nlet ErrorDetails = /*#__PURE__*/function (ErrorDetails) {\n  ErrorDetails[\"KEY_SYSTEM_NO_KEYS\"] = \"keySystemNoKeys\";\n  ErrorDetails[\"KEY_SYSTEM_NO_ACCESS\"] = \"keySystemNoAccess\";\n  ErrorDetails[\"KEY_SYSTEM_NO_SESSION\"] = \"keySystemNoSession\";\n  ErrorDetails[\"KEY_SYSTEM_NO_CONFIGURED_LICENSE\"] = \"keySystemNoConfiguredLicense\";\n  ErrorDetails[\"KEY_SYSTEM_LICENSE_REQUEST_FAILED\"] = \"keySystemLicenseRequestFailed\";\n  ErrorDetails[\"KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED\"] = \"keySystemServerCertificateRequestFailed\";\n  ErrorDetails[\"KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED\"] = \"keySystemServerCertificateUpdateFailed\";\n  ErrorDetails[\"KEY_SYSTEM_SESSION_UPDATE_FAILED\"] = \"keySystemSessionUpdateFailed\";\n  ErrorDetails[\"KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED\"] = \"keySystemStatusOutputRestricted\";\n  ErrorDetails[\"KEY_SYSTEM_STATUS_INTERNAL_ERROR\"] = \"keySystemStatusInternalError\";\n  ErrorDetails[\"KEY_SYSTEM_DESTROY_MEDIA_KEYS_ERROR\"] = \"keySystemDestroyMediaKeysError\";\n  ErrorDetails[\"KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR\"] = \"keySystemDestroyCloseSessionError\";\n  ErrorDetails[\"KEY_SYSTEM_DESTROY_REMOVE_SESSION_ERROR\"] = \"keySystemDestroyRemoveSessionError\";\n  // Identifier for a manifest load error - data: { url : faulty URL, response : { code: error code, text: error text }}\n  ErrorDetails[\"MANIFEST_LOAD_ERROR\"] = \"manifestLoadError\";\n  // Identifier for a manifest load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}\n  ErrorDetails[\"MANIFEST_LOAD_TIMEOUT\"] = \"manifestLoadTimeOut\";\n  // Identifier for a manifest parsing error - data: { url : faulty URL, reason : error reason}\n  ErrorDetails[\"MANIFEST_PARSING_ERROR\"] = \"manifestParsingError\";\n  // Identifier for a manifest with only incompatible codecs error - data: { url : faulty URL, reason : error reason}\n  ErrorDetails[\"MANIFEST_INCOMPATIBLE_CODECS_ERROR\"] = \"manifestIncompatibleCodecsError\";\n  // Identifier for a level which contains no fragments - data: { url: faulty URL, reason: \"no fragments found in level\", level: index of the bad level }\n  ErrorDetails[\"LEVEL_EMPTY_ERROR\"] = \"levelEmptyError\";\n  // Identifier for a level load error - data: { url : faulty URL, response : { code: error code, text: error text }}\n  ErrorDetails[\"LEVEL_LOAD_ERROR\"] = \"levelLoadError\";\n  // Identifier for a level load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}\n  ErrorDetails[\"LEVEL_LOAD_TIMEOUT\"] = \"levelLoadTimeOut\";\n  // Identifier for a level parse error - data: { url : faulty URL, error: Error, reason: error message }\n  ErrorDetails[\"LEVEL_PARSING_ERROR\"] = \"levelParsingError\";\n  // Identifier for a level switch error - data: { level : faulty level Id, event : error description}\n  ErrorDetails[\"LEVEL_SWITCH_ERROR\"] = \"levelSwitchError\";\n  // Identifier for an audio track load error - data: { url : faulty URL, response : { code: error code, text: error text }}\n  ErrorDetails[\"AUDIO_TRACK_LOAD_ERROR\"] = \"audioTrackLoadError\";\n  // Identifier for an audio track load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}\n  ErrorDetails[\"AUDIO_TRACK_LOAD_TIMEOUT\"] = \"audioTrackLoadTimeOut\";\n  // Identifier for a subtitle track load error - data: { url : faulty URL, response : { code: error code, text: error text }}\n  ErrorDetails[\"SUBTITLE_LOAD_ERROR\"] = \"subtitleTrackLoadError\";\n  // Identifier for a subtitle track load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}\n  ErrorDetails[\"SUBTITLE_TRACK_LOAD_TIMEOUT\"] = \"subtitleTrackLoadTimeOut\";\n  // Identifier for fragment load error - data: { frag : fragment object, response : { code: error code, text: error text }}\n  ErrorDetails[\"FRAG_LOAD_ERROR\"] = \"fragLoadError\";\n  // Identifier for fragment load timeout error - data: { frag : fragment object}\n  ErrorDetails[\"FRAG_LOAD_TIMEOUT\"] = \"fragLoadTimeOut\";\n  // Identifier for a fragment decryption error event - data: {id : demuxer Id,frag: fragment object, reason : parsing error description }\n  ErrorDetails[\"FRAG_DECRYPT_ERROR\"] = \"fragDecryptError\";\n  // Identifier for a fragment parsing error event - data: { id : demuxer Id, reason : parsing error description }\n  // will be renamed DEMUX_PARSING_ERROR and switched to MUX_ERROR in the next major release\n  ErrorDetails[\"FRAG_PARSING_ERROR\"] = \"fragParsingError\";\n  // Identifier for a fragment or part load skipped because of a GAP tag or attribute\n  ErrorDetails[\"FRAG_GAP\"] = \"fragGap\";\n  // Identifier for a remux alloc error event - data: { id : demuxer Id, frag : fragment object, bytes : nb of bytes on which allocation failed , reason : error text }\n  ErrorDetails[\"REMUX_ALLOC_ERROR\"] = \"remuxAllocError\";\n  // Identifier for decrypt key load error - data: { frag : fragment object, response : { code: error code, text: error text }}\n  ErrorDetails[\"KEY_LOAD_ERROR\"] = \"keyLoadError\";\n  // Identifier for decrypt key load timeout error - data: { frag : fragment object}\n  ErrorDetails[\"KEY_LOAD_TIMEOUT\"] = \"keyLoadTimeOut\";\n  // Triggered when an exception occurs while adding a sourceBuffer to MediaSource - data : { error : exception , mimeType : mimeType }\n  ErrorDetails[\"BUFFER_ADD_CODEC_ERROR\"] = \"bufferAddCodecError\";\n  // Triggered when source buffer(s) could not be created using level (manifest CODECS attribute), parsed media, or best guess codec(s) - data: { reason : error reason }\n  ErrorDetails[\"BUFFER_INCOMPATIBLE_CODECS_ERROR\"] = \"bufferIncompatibleCodecsError\";\n  // Identifier for a buffer append error - data: append error description\n  ErrorDetails[\"BUFFER_APPEND_ERROR\"] = \"bufferAppendError\";\n  // Identifier for a buffer appending error event - data: appending error description\n  ErrorDetails[\"BUFFER_APPENDING_ERROR\"] = \"bufferAppendingError\";\n  // Identifier for a buffer stalled error event\n  ErrorDetails[\"BUFFER_STALLED_ERROR\"] = \"bufferStalledError\";\n  // Identifier for a buffer full event\n  ErrorDetails[\"BUFFER_FULL_ERROR\"] = \"bufferFullError\";\n  // Identifier for a buffer seek over hole event\n  ErrorDetails[\"BUFFER_SEEK_OVER_HOLE\"] = \"bufferSeekOverHole\";\n  // Identifier for a buffer nudge on stall (playback is stuck although currentTime is in a buffered area)\n  ErrorDetails[\"BUFFER_NUDGE_ON_STALL\"] = \"bufferNudgeOnStall\";\n  // Identifier for a Interstitial Asset List load error - data: { url: faulty URL, response: { code: error code, text: error text } }\n  ErrorDetails[\"ASSET_LIST_LOAD_ERROR\"] = \"assetListLoadError\";\n  // Identifier for a Interstitial Asset List load timeout - data: { url: faulty URL, response: { code: error code, text: error text } }\n  ErrorDetails[\"ASSET_LIST_LOAD_TIMEOUT\"] = \"assetListLoadTimeout\";\n  // Identifier for a Interstitial Asset List parsing error - data: { url : faulty URL, reason : error reason, response : { code: error code, text: error text }}\n  ErrorDetails[\"ASSET_LIST_PARSING_ERROR\"] = \"assetListParsingError\";\n  // Identifier for a Interstitial Asset List parsing error - data: { url : faulty URL, reason : error reason, response : { code: error code, text: error text }}\n  ErrorDetails[\"INTERSTITIAL_ASSET_ITEM_ERROR\"] = \"interstitialAssetItemError\";\n  // Identifier for an internal exception happening inside hls.js while handling an event\n  ErrorDetails[\"INTERNAL_EXCEPTION\"] = \"internalException\";\n  // Identifier for an internal call to abort a loader\n  ErrorDetails[\"INTERNAL_ABORTED\"] = \"aborted\";\n  // Triggered when attachMedia fails\n  ErrorDetails[\"ATTACH_MEDIA_ERROR\"] = \"attachMediaError\";\n  // Uncategorized error\n  ErrorDetails[\"UNKNOWN\"] = \"unknown\";\n  return ErrorDetails;\n}({});\n\nlet Events = /*#__PURE__*/function (Events) {\n  // Fired before MediaSource is attaching to media element\n  Events[\"MEDIA_ATTACHING\"] = \"hlsMediaAttaching\";\n  // Fired when MediaSource has been successfully attached to media element\n  Events[\"MEDIA_ATTACHED\"] = \"hlsMediaAttached\";\n  // Fired before detaching MediaSource from media element\n  Events[\"MEDIA_DETACHING\"] = \"hlsMediaDetaching\";\n  // Fired when MediaSource has been detached from media element\n  Events[\"MEDIA_DETACHED\"] = \"hlsMediaDetached\";\n  // Fired when HTMLMediaElement dispatches \"ended\" event, or stalls at end of VOD program\n  Events[\"MEDIA_ENDED\"] = \"hlsMediaEnded\";\n  // Fired after playback stall is resolved with playing, seeked, or ended event following BUFFER_STALLED_ERROR\n  Events[\"STALL_RESOLVED\"] = \"hlsStallResolved\";\n  // Fired when the buffer is going to be reset\n  Events[\"BUFFER_RESET\"] = \"hlsBufferReset\";\n  // Fired when we know about the codecs that we need buffers for to push into - data: {tracks : { container, codec, levelCodec, initSegment, metadata }}\n  Events[\"BUFFER_CODECS\"] = \"hlsBufferCodecs\";\n  // fired when sourcebuffers have been created - data: { tracks : tracks }\n  Events[\"BUFFER_CREATED\"] = \"hlsBufferCreated\";\n  // fired when we append a segment to the buffer - data: { segment: segment object }\n  Events[\"BUFFER_APPENDING\"] = \"hlsBufferAppending\";\n  // fired when we are done with appending a media segment to the buffer - data : { parent : segment parent that triggered BUFFER_APPENDING, pending : nb of segments waiting for appending for this segment parent}\n  Events[\"BUFFER_APPENDED\"] = \"hlsBufferAppended\";\n  // fired when the stream is finished and we want to notify the media buffer that there will be no more data - data: { }\n  Events[\"BUFFER_EOS\"] = \"hlsBufferEos\";\n  // fired when all buffers are full to the end of the program, after calling MediaSource.endOfStream() (unless restricted)\n  Events[\"BUFFERED_TO_END\"] = \"hlsBufferedToEnd\";\n  // fired when the media buffer should be flushed - data { startOffset, endOffset }\n  Events[\"BUFFER_FLUSHING\"] = \"hlsBufferFlushing\";\n  // fired when the media buffer has been flushed - data: { }\n  Events[\"BUFFER_FLUSHED\"] = \"hlsBufferFlushed\";\n  // fired to signal that a manifest loading starts - data: { url : manifestURL}\n  Events[\"MANIFEST_LOADING\"] = \"hlsManifestLoading\";\n  // fired after manifest has been loaded - data: { levels : [available quality levels], audioTracks : [ available audio tracks ], url : manifestURL, stats : LoaderStats }\n  Events[\"MANIFEST_LOADED\"] = \"hlsManifestLoaded\";\n  // fired after manifest has been parsed - data: { levels : [available quality levels], firstLevel : index of first quality level appearing in Manifest}\n  Events[\"MANIFEST_PARSED\"] = \"hlsManifestParsed\";\n  // fired when a level switch is requested - data: { level : id of new level }\n  Events[\"LEVEL_SWITCHING\"] = \"hlsLevelSwitching\";\n  // fired when a level switch is effective - data: { level : id of new level }\n  Events[\"LEVEL_SWITCHED\"] = \"hlsLevelSwitched\";\n  // fired when a level playlist loading starts - data: { url : level URL, level : id of level being loaded}\n  Events[\"LEVEL_LOADING\"] = \"hlsLevelLoading\";\n  // fired when a level playlist loading finishes - data: { details : levelDetails object, level : id of loaded level, stats : LoaderStats }\n  Events[\"LEVEL_LOADED\"] = \"hlsLevelLoaded\";\n  // fired when a level's details have been updated based on previous details, after it has been loaded - data: { details : levelDetails object, level : id of updated level }\n  Events[\"LEVEL_UPDATED\"] = \"hlsLevelUpdated\";\n  // fired when a level's PTS information has been updated after parsing a fragment - data: { details : levelDetails object, level : id of updated level, drift: PTS drift observed when parsing last fragment }\n  Events[\"LEVEL_PTS_UPDATED\"] = \"hlsLevelPtsUpdated\";\n  // fired to notify that levels have changed after removing a level - data: { levels : [available quality levels] }\n  Events[\"LEVELS_UPDATED\"] = \"hlsLevelsUpdated\";\n  // fired to notify that audio track lists has been updated - data: { audioTracks : audioTracks }\n  Events[\"AUDIO_TRACKS_UPDATED\"] = \"hlsAudioTracksUpdated\";\n  // fired when an audio track switching is requested - data: { id : audio track id }\n  Events[\"AUDIO_TRACK_SWITCHING\"] = \"hlsAudioTrackSwitching\";\n  // fired when an audio track switch actually occurs - data: { id : audio track id }\n  Events[\"AUDIO_TRACK_SWITCHED\"] = \"hlsAudioTrackSwitched\";\n  // fired when an audio track loading starts - data: { url : audio track URL, id : audio track id }\n  Events[\"AUDIO_TRACK_LOADING\"] = \"hlsAudioTrackLoading\";\n  // fired when an audio track loading finishes - data: { details : levelDetails object, id : audio track id, stats : LoaderStats }\n  Events[\"AUDIO_TRACK_LOADED\"] = \"hlsAudioTrackLoaded\";\n  // fired when an audio tracks's details have been updated based on previous details, after it has been loaded - data: { details : levelDetails object, id : track id }\n  Events[\"AUDIO_TRACK_UPDATED\"] = \"hlsAudioTrackUpdated\";\n  // fired to notify that subtitle track lists has been updated - data: { subtitleTracks : subtitleTracks }\n  Events[\"SUBTITLE_TRACKS_UPDATED\"] = \"hlsSubtitleTracksUpdated\";\n  // fired to notify that subtitle tracks were cleared as a result of stopping the media\n  Events[\"SUBTITLE_TRACKS_CLEARED\"] = \"hlsSubtitleTracksCleared\";\n  // fired when an subtitle track switch occurs - data: { id : subtitle track id }\n  Events[\"SUBTITLE_TRACK_SWITCH\"] = \"hlsSubtitleTrackSwitch\";\n  // fired when a subtitle track loading starts - data: { url : subtitle track URL, id : subtitle track id }\n  Events[\"SUBTITLE_TRACK_LOADING\"] = \"hlsSubtitleTrackLoading\";\n  // fired when a subtitle track loading finishes - data: { details : levelDetails object, id : subtitle track id, stats : LoaderStats }\n  Events[\"SUBTITLE_TRACK_LOADED\"] = \"hlsSubtitleTrackLoaded\";\n  // fired when a subtitle  racks's details have been updated based on previous details, after it has been loaded - data: { details : levelDetails object, id : track id }\n  Events[\"SUBTITLE_TRACK_UPDATED\"] = \"hlsSubtitleTrackUpdated\";\n  // fired when a subtitle fragment has been processed - data: { success : boolean, frag : the processed frag }\n  Events[\"SUBTITLE_FRAG_PROCESSED\"] = \"hlsSubtitleFragProcessed\";\n  // fired when a set of VTTCues to be managed externally has been parsed - data: { type: string, track: string, cues: [ VTTCue ] }\n  Events[\"CUES_PARSED\"] = \"hlsCuesParsed\";\n  // fired when a text track to be managed externally is found - data: { tracks: [ { label: string, kind: string, default: boolean } ] }\n  Events[\"NON_NATIVE_TEXT_TRACKS_FOUND\"] = \"hlsNonNativeTextTracksFound\";\n  // fired when the first timestamp is found - data: { id : demuxer id, initPTS: initPTS, timescale: timescale, frag : fragment object }\n  Events[\"INIT_PTS_FOUND\"] = \"hlsInitPtsFound\";\n  // fired when a fragment loading starts - data: { frag : fragment object }\n  Events[\"FRAG_LOADING\"] = \"hlsFragLoading\";\n  // fired when a fragment loading is progressing - data: { frag : fragment object, { trequest, tfirst, loaded } }\n  // FRAG_LOAD_PROGRESS = 'hlsFragLoadProgress',\n  // Identifier for fragment load aborting for emergency switch down - data: { frag : fragment object }\n  Events[\"FRAG_LOAD_EMERGENCY_ABORTED\"] = \"hlsFragLoadEmergencyAborted\";\n  // fired when a fragment loading is completed - data: { frag : fragment object, payload : fragment payload, stats : LoaderStats }\n  Events[\"FRAG_LOADED\"] = \"hlsFragLoaded\";\n  // fired when a fragment has finished decrypting - data: { id : demuxer id, frag: fragment object, payload : fragment payload, stats : { tstart, tdecrypt } }\n  Events[\"FRAG_DECRYPTED\"] = \"hlsFragDecrypted\";\n  // fired when Init Segment has been extracted from fragment - data: { id : demuxer id, frag: fragment object, moov : moov MP4 box, codecs : codecs found while parsing fragment }\n  Events[\"FRAG_PARSING_INIT_SEGMENT\"] = \"hlsFragParsingInitSegment\";\n  // fired when parsing sei text is completed - data: { id : demuxer id, frag: fragment object, samples : [ sei samples pes ] }\n  Events[\"FRAG_PARSING_USERDATA\"] = \"hlsFragParsingUserdata\";\n  // fired when parsing id3 is completed - data: { id : demuxer id, frag: fragment object, samples : [ id3 samples pes ] }\n  Events[\"FRAG_PARSING_METADATA\"] = \"hlsFragParsingMetadata\";\n  // fired when data have been extracted from fragment - data: { id : demuxer id, frag: fragment object, data1 : moof MP4 box or TS fragments, data2 : mdat MP4 box or null}\n  // FRAG_PARSING_DATA = 'hlsFragParsingData',\n  // fired when fragment parsing is completed - data: { id : demuxer id, frag: fragment object }\n  Events[\"FRAG_PARSED\"] = \"hlsFragParsed\";\n  // fired when fragment remuxed MP4 boxes have all been appended into SourceBuffer - data: { id : demuxer id, frag : fragment object, stats : LoaderStats }\n  Events[\"FRAG_BUFFERED\"] = \"hlsFragBuffered\";\n  // fired when fragment matching with current media position is changing - data : { id : demuxer id, frag : fragment object }\n  Events[\"FRAG_CHANGED\"] = \"hlsFragChanged\";\n  // Identifier for a FPS drop event - data: { currentDropped, currentDecoded, totalDroppedFrames }\n  Events[\"FPS_DROP\"] = \"hlsFpsDrop\";\n  // triggered when FPS drop triggers auto level capping - data: { level, droppedLevel }\n  Events[\"FPS_DROP_LEVEL_CAPPING\"] = \"hlsFpsDropLevelCapping\";\n  // triggered when maxAutoLevel changes - data { autoLevelCapping, levels, maxAutoLevel, minAutoLevel, maxHdcpLevel }\n  Events[\"MAX_AUTO_LEVEL_UPDATED\"] = \"hlsMaxAutoLevelUpdated\";\n  // Identifier for an error event - data: { type : error type, details : error details, fatal : if true, hls.js cannot/will not try to recover, if false, hls.js will try to recover,other error specific data }\n  Events[\"ERROR\"] = \"hlsError\";\n  // fired when hls.js instance starts destroying. Different from MEDIA_DETACHED as one could want to detach and reattach a media to the instance of hls.js to handle mid-rolls for example - data: { }\n  Events[\"DESTROYING\"] = \"hlsDestroying\";\n  // fired when a decrypt key loading starts - data: { frag : fragment object }\n  Events[\"KEY_LOADING\"] = \"hlsKeyLoading\";\n  // fired when a decrypt key loading is completed - data: { frag : fragment object, keyInfo : KeyLoaderInfo }\n  Events[\"KEY_LOADED\"] = \"hlsKeyLoaded\";\n  // deprecated; please use BACK_BUFFER_REACHED - data : { bufferEnd: number }\n  Events[\"LIVE_BACK_BUFFER_REACHED\"] = \"hlsLiveBackBufferReached\";\n  // fired when the back buffer is reached as defined by the backBufferLength config option - data : { bufferEnd: number }\n  Events[\"BACK_BUFFER_REACHED\"] = \"hlsBackBufferReached\";\n  // fired after steering manifest has been loaded - data: { steeringManifest: SteeringManifest object, url: steering manifest URL }\n  Events[\"STEERING_MANIFEST_LOADED\"] = \"hlsSteeringManifestLoaded\";\n  // fired when asset list has begun loading\n  Events[\"ASSET_LIST_LOADING\"] = \"hlsAssetListLoading\";\n  // fired when a valid asset list is loaded\n  Events[\"ASSET_LIST_LOADED\"] = \"hlsAssetListLoaded\";\n  // fired when the list of Interstitial Events and Interstitial Schedule is updated\n  Events[\"INTERSTITIALS_UPDATED\"] = \"hlsInterstitialsUpdated\";\n  // fired when the buffer reaches an Interstitial Schedule boundary (both Primary segments and Interstitial Assets)\n  Events[\"INTERSTITIALS_BUFFERED_TO_BOUNDARY\"] = \"hlsInterstitialsBufferedToBoundary\";\n  // fired when a player instance for an Interstitial Asset has been created\n  Events[\"INTERSTITIAL_ASSET_PLAYER_CREATED\"] = \"hlsInterstitialAssetPlayerCreated\";\n  // Interstitial playback started\n  Events[\"INTERSTITIAL_STARTED\"] = \"hlsInterstitialStarted\";\n  // InterstitialAsset playback started\n  Events[\"INTERSTITIAL_ASSET_STARTED\"] = \"hlsInterstitialAssetStarted\";\n  // InterstitialAsset playback ended\n  Events[\"INTERSTITIAL_ASSET_ENDED\"] = \"hlsInterstitialAssetEnded\";\n  // InterstitialAsset playback errored\n  Events[\"INTERSTITIAL_ASSET_ERROR\"] = \"hlsInterstitialAssetError\";\n  // Interstitial playback ended\n  Events[\"INTERSTITIAL_ENDED\"] = \"hlsInterstitialEnded\";\n  // Interstitial schedule resumed primary playback\n  Events[\"INTERSTITIALS_PRIMARY_RESUMED\"] = \"hlsInterstitialsPrimaryResumed\";\n  // Interstitial players dispatch this event when playout limit is reached\n  Events[\"PLAYOUT_LIMIT_REACHED\"] = \"hlsPlayoutLimitReached\";\n  // Event DateRange cue \"enter\" event dispatched\n  Events[\"EVENT_CUE_ENTER\"] = \"hlsEventCueEnter\";\n  return Events;\n}({});\n\n/**\n * Defines each Event type and payload by Event name. Used in {@link hls.js#HlsEventEmitter} to strongly type the event listener API.\n */\n\nvar PlaylistContextType = {\n  MANIFEST: \"manifest\",\n  LEVEL: \"level\",\n  AUDIO_TRACK: \"audioTrack\",\n  SUBTITLE_TRACK: \"subtitleTrack\"\n};\nvar PlaylistLevelType = {\n  MAIN: \"main\",\n  AUDIO: \"audio\",\n  SUBTITLE: \"subtitle\"\n};\n\n/*\n * compute an Exponential Weighted moving average\n * - https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average\n *  - heavily inspired from shaka-player\n */\n\nclass EWMA {\n  //  About half of the estimated value will be from the last |halfLife| samples by weight.\n  constructor(halfLife, estimate = 0, weight = 0) {\n    this.halfLife = void 0;\n    this.alpha_ = void 0;\n    this.estimate_ = void 0;\n    this.totalWeight_ = void 0;\n    this.halfLife = halfLife;\n    // Larger values of alpha expire historical data more slowly.\n    this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;\n    this.estimate_ = estimate;\n    this.totalWeight_ = weight;\n  }\n  sample(weight, value) {\n    const adjAlpha = Math.pow(this.alpha_, weight);\n    this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;\n    this.totalWeight_ += weight;\n  }\n  getTotalWeight() {\n    return this.totalWeight_;\n  }\n  getEstimate() {\n    if (this.alpha_) {\n      const zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);\n      if (zeroFactor) {\n        return this.estimate_ / zeroFactor;\n      }\n    }\n    return this.estimate_;\n  }\n}\n\n/*\n * EWMA Bandwidth Estimator\n *  - heavily inspired from shaka-player\n * Tracks bandwidth samples and estimates available bandwidth.\n * Based on the minimum of two exponentially-weighted moving averages with\n * different half-lives.\n */\n\nclass EwmaBandWidthEstimator {\n  constructor(slow, fast, defaultEstimate, defaultTTFB = 100) {\n    this.defaultEstimate_ = void 0;\n    this.minWeight_ = void 0;\n    this.minDelayMs_ = void 0;\n    this.slow_ = void 0;\n    this.fast_ = void 0;\n    this.defaultTTFB_ = void 0;\n    this.ttfb_ = void 0;\n    this.defaultEstimate_ = defaultEstimate;\n    this.minWeight_ = 0.001;\n    this.minDelayMs_ = 50;\n    this.slow_ = new EWMA(slow);\n    this.fast_ = new EWMA(fast);\n    this.defaultTTFB_ = defaultTTFB;\n    this.ttfb_ = new EWMA(slow);\n  }\n  update(slow, fast) {\n    const {\n      slow_,\n      fast_,\n      ttfb_\n    } = this;\n    if (slow_.halfLife !== slow) {\n      this.slow_ = new EWMA(slow, slow_.getEstimate(), slow_.getTotalWeight());\n    }\n    if (fast_.halfLife !== fast) {\n      this.fast_ = new EWMA(fast, fast_.getEstimate(), fast_.getTotalWeight());\n    }\n    if (ttfb_.halfLife !== slow) {\n      this.ttfb_ = new EWMA(slow, ttfb_.getEstimate(), ttfb_.getTotalWeight());\n    }\n  }\n  sample(durationMs, numBytes) {\n    durationMs = Math.max(durationMs, this.minDelayMs_);\n    const numBits = 8 * numBytes;\n    // weight is duration in seconds\n    const durationS = durationMs / 1000;\n    // value is bandwidth in bits/s\n    const bandwidthInBps = numBits / durationS;\n    this.fast_.sample(durationS, bandwidthInBps);\n    this.slow_.sample(durationS, bandwidthInBps);\n  }\n  sampleTTFB(ttfb) {\n    // weight is frequency curve applied to TTFB in seconds\n    // (longer times have less weight with expected input under 1 second)\n    const seconds = ttfb / 1000;\n    const weight = Math.sqrt(2) * Math.exp(-Math.pow(seconds, 2) / 2);\n    this.ttfb_.sample(weight, Math.max(ttfb, 5));\n  }\n  canEstimate() {\n    return this.fast_.getTotalWeight() >= this.minWeight_;\n  }\n  getEstimate() {\n    if (this.canEstimate()) {\n      // console.log('slow estimate:'+ Math.round(this.slow_.getEstimate()));\n      // console.log('fast estimate:'+ Math.round(this.fast_.getEstimate()));\n      // Take the minimum of these two estimates.  This should have the effect of\n      // adapting down quickly, but up more slowly.\n      return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());\n    } else {\n      return this.defaultEstimate_;\n    }\n  }\n  getEstimateTTFB() {\n    if (this.ttfb_.getTotalWeight() >= this.minWeight_) {\n      return this.ttfb_.getEstimate();\n    } else {\n      return this.defaultTTFB_;\n    }\n  }\n  get defaultEstimate() {\n    return this.defaultEstimate_;\n  }\n  destroy() {}\n}\n\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: true,\n    configurable: true,\n    writable: true\n  }) : e[r] = t, e;\n}\nfunction _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), true).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r);\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\n\nclass Logger {\n  constructor(label, logger) {\n    this.trace = void 0;\n    this.debug = void 0;\n    this.log = void 0;\n    this.warn = void 0;\n    this.info = void 0;\n    this.error = void 0;\n    const lb = `[${label}]:`;\n    this.trace = noop;\n    this.debug = logger.debug.bind(null, lb);\n    this.log = logger.log.bind(null, lb);\n    this.warn = logger.warn.bind(null, lb);\n    this.info = logger.info.bind(null, lb);\n    this.error = logger.error.bind(null, lb);\n  }\n}\nconst noop = function noop() {};\nconst fakeLogger = {\n  trace: noop,\n  debug: noop,\n  log: noop,\n  warn: noop,\n  info: noop,\n  error: noop\n};\nfunction createLogger() {\n  return _extends({}, fakeLogger);\n}\n\n// let lastCallTime;\n// function formatMsgWithTimeInfo(type, msg) {\n//   const now = Date.now();\n//   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';\n//   lastCallTime = now;\n//   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';\n//   return msg;\n// }\n\nfunction consolePrintFn(type, id) {\n  const func = self.console[type];\n  return func ? func.bind(self.console, `${id ? '[' + id + '] ' : ''}[${type}] >`) : noop;\n}\nfunction getLoggerFn(key, debugConfig, id) {\n  return debugConfig[key] ? debugConfig[key].bind(debugConfig) : consolePrintFn(key, id);\n}\nconst exportedLogger = createLogger();\nfunction enableLogs(debugConfig, context, id) {\n  // check that console is available\n  const newLogger = createLogger();\n  if (typeof console === 'object' && debugConfig === true || typeof debugConfig === 'object') {\n    const keys = [\n    // Remove out from list here to hard-disable a log-level\n    // 'trace',\n    'debug', 'log', 'info', 'warn', 'error'];\n    keys.forEach(key => {\n      newLogger[key] = getLoggerFn(key, debugConfig, id);\n    });\n    // Some browsers don't allow to use bind on console object anyway\n    // fallback to default if needed\n    try {\n      newLogger.log(`Debug logs enabled for \"${context}\" in hls.js version ${\"1.6.7\"}`);\n    } catch (e) {\n      /* log fn threw an exception. All logger methods are no-ops. */\n      return createLogger();\n    }\n    // global exported logger uses the same functions as new logger without `id`\n    keys.forEach(key => {\n      exportedLogger[key] = getLoggerFn(key, debugConfig);\n    });\n  } else {\n    // Reset global exported logger\n    _extends(exportedLogger, newLogger);\n  }\n  return newLogger;\n}\nconst logger = exportedLogger;\n\nfunction getMediaSource(preferManagedMediaSource = true) {\n  if (typeof self === 'undefined') return undefined;\n  const mms = (preferManagedMediaSource || !self.MediaSource) && self.ManagedMediaSource;\n  return mms || self.MediaSource || self.WebKitMediaSource;\n}\nfunction isManagedMediaSource(source) {\n  return typeof self !== 'undefined' && source === self.ManagedMediaSource;\n}\nfunction isCompatibleTrackChange(currentTracks, requiredTracks) {\n  const trackNames = Object.keys(currentTracks);\n  const requiredTrackNames = Object.keys(requiredTracks);\n  const trackCount = trackNames.length;\n  const requiredTrackCount = requiredTrackNames.length;\n  return !trackCount || !requiredTrackCount || trackCount === requiredTrackCount && !trackNames.some(name => requiredTrackNames.indexOf(name) === -1);\n}\n\n// http://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript/22373197\n// http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt\n/* utf.js - UTF-8 <=> UTF-16 convertion\n *\n * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\n * Version: 1.0\n * LastModified: Dec 25 1999\n * This library is free.  You can redistribute it and/or modify it.\n */\n/**\n * Converts a UTF-8 array to a string.\n *\n * @param array - The UTF-8 array to convert\n *\n * @returns The string\n *\n * @group Utils\n *\n * @beta\n */\nfunction utf8ArrayToStr(array, exitOnNull = false) {\n  if (typeof TextDecoder !== 'undefined') {\n    const decoder = new TextDecoder('utf-8');\n    const decoded = decoder.decode(array);\n    if (exitOnNull) {\n      // grab up to the first null\n      const idx = decoded.indexOf('\\0');\n      return idx !== -1 ? decoded.substring(0, idx) : decoded;\n    }\n    // remove any null characters\n    return decoded.replace(/\\0/g, '');\n  }\n  const len = array.length;\n  let c;\n  let char2;\n  let char3;\n  let out = '';\n  let i = 0;\n  while (i < len) {\n    c = array[i++];\n    if (c === 0x00 && exitOnNull) {\n      return out;\n    } else if (c === 0x00 || c === 0x03) {\n      // If the character is 3 (END_OF_TEXT) or 0 (NULL) then skip it\n      continue;\n    }\n    switch (c >> 4) {\n      case 0:\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n        // 0xxxxxxx\n        out += String.fromCharCode(c);\n        break;\n      case 12:\n      case 13:\n        // 110x xxxx   10xx xxxx\n        char2 = array[i++];\n        out += String.fromCharCode((c & 0x1f) << 6 | char2 & 0x3f);\n        break;\n      case 14:\n        // 1110 xxxx  10xx xxxx  10xx xxxx\n        char2 = array[i++];\n        char3 = array[i++];\n        out += String.fromCharCode((c & 0x0f) << 12 | (char2 & 0x3f) << 6 | (char3 & 0x3f) << 0);\n        break;\n    }\n  }\n  return out;\n}\n\n/**\n *  hex dump helper class\n */\n\nconst Hex = {\n  hexDump: function (array) {\n    let str = '';\n    for (let i = 0; i < array.length; i++) {\n      let h = array[i].toString(16);\n      if (h.length < 2) {\n        h = '0' + h;\n      }\n      str += h;\n    }\n    return str;\n  }\n};\nfunction hexToArrayBuffer(str) {\n  return Uint8Array.from(str.replace(/^0x/, '').replace(/([\\da-fA-F]{2}) ?/g, '0x$1 ').replace(/ +$/, '').split(' ')).buffer;\n}\n\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nvar urlToolkit = {exports: {}};\n\nvar hasRequiredUrlToolkit;\n\nfunction requireUrlToolkit () {\n\tif (hasRequiredUrlToolkit) return urlToolkit.exports;\n\thasRequiredUrlToolkit = 1;\n\t(function (module, exports) {\n\t\t// see https://tools.ietf.org/html/rfc1808\n\n\t\t(function (root) {\n\t\t  var URL_REGEX =\n\t\t    /^(?=((?:[a-zA-Z0-9+\\-.]+:)?))\\1(?=((?:\\/\\/[^\\/?#]*)?))\\2(?=((?:(?:[^?#\\/]*\\/)*[^;?#\\/]*)?))\\3((?:;[^?#]*)?)(\\?[^#]*)?(#[^]*)?$/;\n\t\t  var FIRST_SEGMENT_REGEX = /^(?=([^\\/?#]*))\\1([^]*)$/;\n\t\t  var SLASH_DOT_REGEX = /(?:\\/|^)\\.(?=\\/)/g;\n\t\t  var SLASH_DOT_DOT_REGEX = /(?:\\/|^)\\.\\.\\/(?!\\.\\.\\/)[^\\/]*(?=\\/)/g;\n\n\t\t  var URLToolkit = {\n\t\t    // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //\n\t\t    // E.g\n\t\t    // With opts.alwaysNormalize = false (default, spec compliant)\n\t\t    // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g\n\t\t    // With opts.alwaysNormalize = true (not spec compliant)\n\t\t    // http://a.com/b/cd + /e/f/../g => http://a.com/e/g\n\t\t    buildAbsoluteURL: function (baseURL, relativeURL, opts) {\n\t\t      opts = opts || {};\n\t\t      // remove any remaining space and CRLF\n\t\t      baseURL = baseURL.trim();\n\t\t      relativeURL = relativeURL.trim();\n\t\t      if (!relativeURL) {\n\t\t        // 2a) If the embedded URL is entirely empty, it inherits the\n\t\t        // entire base URL (i.e., is set equal to the base URL)\n\t\t        // and we are done.\n\t\t        if (!opts.alwaysNormalize) {\n\t\t          return baseURL;\n\t\t        }\n\t\t        var basePartsForNormalise = URLToolkit.parseURL(baseURL);\n\t\t        if (!basePartsForNormalise) {\n\t\t          throw new Error('Error trying to parse base URL.');\n\t\t        }\n\t\t        basePartsForNormalise.path = URLToolkit.normalizePath(\n\t\t          basePartsForNormalise.path\n\t\t        );\n\t\t        return URLToolkit.buildURLFromParts(basePartsForNormalise);\n\t\t      }\n\t\t      var relativeParts = URLToolkit.parseURL(relativeURL);\n\t\t      if (!relativeParts) {\n\t\t        throw new Error('Error trying to parse relative URL.');\n\t\t      }\n\t\t      if (relativeParts.scheme) {\n\t\t        // 2b) If the embedded URL starts with a scheme name, it is\n\t\t        // interpreted as an absolute URL and we are done.\n\t\t        if (!opts.alwaysNormalize) {\n\t\t          return relativeURL;\n\t\t        }\n\t\t        relativeParts.path = URLToolkit.normalizePath(relativeParts.path);\n\t\t        return URLToolkit.buildURLFromParts(relativeParts);\n\t\t      }\n\t\t      var baseParts = URLToolkit.parseURL(baseURL);\n\t\t      if (!baseParts) {\n\t\t        throw new Error('Error trying to parse base URL.');\n\t\t      }\n\t\t      if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {\n\t\t        // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc\n\t\t        // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'\n\t\t        var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);\n\t\t        baseParts.netLoc = pathParts[1];\n\t\t        baseParts.path = pathParts[2];\n\t\t      }\n\t\t      if (baseParts.netLoc && !baseParts.path) {\n\t\t        baseParts.path = '/';\n\t\t      }\n\t\t      var builtParts = {\n\t\t        // 2c) Otherwise, the embedded URL inherits the scheme of\n\t\t        // the base URL.\n\t\t        scheme: baseParts.scheme,\n\t\t        netLoc: relativeParts.netLoc,\n\t\t        path: null,\n\t\t        params: relativeParts.params,\n\t\t        query: relativeParts.query,\n\t\t        fragment: relativeParts.fragment,\n\t\t      };\n\t\t      if (!relativeParts.netLoc) {\n\t\t        // 3) If the embedded URL's <net_loc> is non-empty, we skip to\n\t\t        // Step 7.  Otherwise, the embedded URL inherits the <net_loc>\n\t\t        // (if any) of the base URL.\n\t\t        builtParts.netLoc = baseParts.netLoc;\n\t\t        // 4) If the embedded URL path is preceded by a slash \"/\", the\n\t\t        // path is not relative and we skip to Step 7.\n\t\t        if (relativeParts.path[0] !== '/') {\n\t\t          if (!relativeParts.path) {\n\t\t            // 5) If the embedded URL path is empty (and not preceded by a\n\t\t            // slash), then the embedded URL inherits the base URL path\n\t\t            builtParts.path = baseParts.path;\n\t\t            // 5a) if the embedded URL's <params> is non-empty, we skip to\n\t\t            // step 7; otherwise, it inherits the <params> of the base\n\t\t            // URL (if any) and\n\t\t            if (!relativeParts.params) {\n\t\t              builtParts.params = baseParts.params;\n\t\t              // 5b) if the embedded URL's <query> is non-empty, we skip to\n\t\t              // step 7; otherwise, it inherits the <query> of the base\n\t\t              // URL (if any) and we skip to step 7.\n\t\t              if (!relativeParts.query) {\n\t\t                builtParts.query = baseParts.query;\n\t\t              }\n\t\t            }\n\t\t          } else {\n\t\t            // 6) The last segment of the base URL's path (anything\n\t\t            // following the rightmost slash \"/\", or the entire path if no\n\t\t            // slash is present) is removed and the embedded URL's path is\n\t\t            // appended in its place.\n\t\t            var baseURLPath = baseParts.path;\n\t\t            var newPath =\n\t\t              baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) +\n\t\t              relativeParts.path;\n\t\t            builtParts.path = URLToolkit.normalizePath(newPath);\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t      if (builtParts.path === null) {\n\t\t        builtParts.path = opts.alwaysNormalize\n\t\t          ? URLToolkit.normalizePath(relativeParts.path)\n\t\t          : relativeParts.path;\n\t\t      }\n\t\t      return URLToolkit.buildURLFromParts(builtParts);\n\t\t    },\n\t\t    parseURL: function (url) {\n\t\t      var parts = URL_REGEX.exec(url);\n\t\t      if (!parts) {\n\t\t        return null;\n\t\t      }\n\t\t      return {\n\t\t        scheme: parts[1] || '',\n\t\t        netLoc: parts[2] || '',\n\t\t        path: parts[3] || '',\n\t\t        params: parts[4] || '',\n\t\t        query: parts[5] || '',\n\t\t        fragment: parts[6] || '',\n\t\t      };\n\t\t    },\n\t\t    normalizePath: function (path) {\n\t\t      // The following operations are\n\t\t      // then applied, in order, to the new path:\n\t\t      // 6a) All occurrences of \"./\", where \".\" is a complete path\n\t\t      // segment, are removed.\n\t\t      // 6b) If the path ends with \".\" as a complete path segment,\n\t\t      // that \".\" is removed.\n\t\t      path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');\n\t\t      // 6c) All occurrences of \"<segment>/../\", where <segment> is a\n\t\t      // complete path segment not equal to \"..\", are removed.\n\t\t      // Removal of these path segments is performed iteratively,\n\t\t      // removing the leftmost matching pattern on each iteration,\n\t\t      // until no matching pattern remains.\n\t\t      // 6d) If the path ends with \"<segment>/..\", where <segment> is a\n\t\t      // complete path segment not equal to \"..\", that\n\t\t      // \"<segment>/..\" is removed.\n\t\t      while (\n\t\t        path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length\n\t\t      ) {}\n\t\t      return path.split('').reverse().join('');\n\t\t    },\n\t\t    buildURLFromParts: function (parts) {\n\t\t      return (\n\t\t        parts.scheme +\n\t\t        parts.netLoc +\n\t\t        parts.path +\n\t\t        parts.params +\n\t\t        parts.query +\n\t\t        parts.fragment\n\t\t      );\n\t\t    },\n\t\t  };\n\n\t\t  module.exports = URLToolkit;\n\t\t})(); \n\t} (urlToolkit));\n\treturn urlToolkit.exports;\n}\n\nvar urlToolkitExports = requireUrlToolkit();\n\nclass LoadStats {\n  constructor() {\n    this.aborted = false;\n    this.loaded = 0;\n    this.retry = 0;\n    this.total = 0;\n    this.chunkCount = 0;\n    this.bwEstimate = 0;\n    this.loading = {\n      start: 0,\n      first: 0,\n      end: 0\n    };\n    this.parsing = {\n      start: 0,\n      end: 0\n    };\n    this.buffering = {\n      start: 0,\n      first: 0,\n      end: 0\n    };\n  }\n}\n\nvar ElementaryStreamTypes = {\n  AUDIO: \"audio\",\n  VIDEO: \"video\",\n  AUDIOVIDEO: \"audiovideo\"\n};\nclass BaseSegment {\n  constructor(base) {\n    this._byteRange = null;\n    this._url = null;\n    this._stats = null;\n    this._streams = null;\n    // baseurl is the URL to the playlist\n    this.base = void 0;\n    // relurl is the portion of the URL that comes from inside the playlist.\n    this.relurl = void 0;\n    if (typeof base === 'string') {\n      base = {\n        url: base\n      };\n    }\n    this.base = base;\n    makeEnumerable(this, 'stats');\n  }\n\n  // setByteRange converts a EXT-X-BYTERANGE attribute into a two element array\n  setByteRange(value, previous) {\n    const params = value.split('@', 2);\n    let start;\n    if (params.length === 1) {\n      start = (previous == null ? void 0 : previous.byteRangeEndOffset) || 0;\n    } else {\n      start = parseInt(params[1]);\n    }\n    this._byteRange = [start, parseInt(params[0]) + start];\n  }\n  get baseurl() {\n    return this.base.url;\n  }\n  get byteRange() {\n    if (this._byteRange === null) {\n      return [];\n    }\n    return this._byteRange;\n  }\n  get byteRangeStartOffset() {\n    return this.byteRange[0];\n  }\n  get byteRangeEndOffset() {\n    return this.byteRange[1];\n  }\n  get elementaryStreams() {\n    if (this._streams === null) {\n      this._streams = {\n        [ElementaryStreamTypes.AUDIO]: null,\n        [ElementaryStreamTypes.VIDEO]: null,\n        [ElementaryStreamTypes.AUDIOVIDEO]: null\n      };\n    }\n    return this._streams;\n  }\n  set elementaryStreams(value) {\n    this._streams = value;\n  }\n  get hasStats() {\n    return this._stats !== null;\n  }\n  get hasStreams() {\n    return this._streams !== null;\n  }\n  get stats() {\n    if (this._stats === null) {\n      this._stats = new LoadStats();\n    }\n    return this._stats;\n  }\n  set stats(value) {\n    this._stats = value;\n  }\n  get url() {\n    if (!this._url && this.baseurl && this.relurl) {\n      this._url = urlToolkitExports.buildAbsoluteURL(this.baseurl, this.relurl, {\n        alwaysNormalize: true\n      });\n    }\n    return this._url || '';\n  }\n  set url(value) {\n    this._url = value;\n  }\n  clearElementaryStreamInfo() {\n    const {\n      elementaryStreams\n    } = this;\n    elementaryStreams[ElementaryStreamTypes.AUDIO] = null;\n    elementaryStreams[ElementaryStreamTypes.VIDEO] = null;\n    elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO] = null;\n  }\n}\nfunction isMediaFragment(frag) {\n  return frag.sn !== 'initSegment';\n}\n\n/**\n * Object representing parsed data from an HLS Segment. Found in {@link hls.js#LevelDetails.fragments}.\n */\nclass Fragment extends BaseSegment {\n  constructor(type, base) {\n    super(base);\n    this._decryptdata = null;\n    this._programDateTime = null;\n    this._ref = null;\n    // Approximate bit rate of the fragment expressed in bits per second (bps) as indicated by the last EXT-X-BITRATE (kbps) tag\n    this._bitrate = void 0;\n    this.rawProgramDateTime = null;\n    this.tagList = [];\n    // EXTINF has to be present for a m3u8 to be considered valid\n    this.duration = 0;\n    // sn notates the sequence number for a segment, and if set to a string can be 'initSegment'\n    this.sn = 0;\n    // levelkeys are the EXT-X-KEY tags that apply to this segment for decryption\n    // core difference from the private field _decryptdata is the lack of the initialized IV\n    // _decryptdata will set the IV for this segment based on the segment number in the fragment\n    this.levelkeys = void 0;\n    // A string representing the fragment type\n    this.type = void 0;\n    // A reference to the loader. Set while the fragment is loading, and removed afterwards. Used to abort fragment loading\n    this.loader = null;\n    // A reference to the key loader. Set while the key is loading, and removed afterwards. Used to abort key loading\n    this.keyLoader = null;\n    // The level/track index to which the fragment belongs\n    this.level = -1;\n    // The continuity counter of the fragment\n    this.cc = 0;\n    // The starting Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.\n    this.startPTS = void 0;\n    // The ending Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.\n    this.endPTS = void 0;\n    // The starting Decode Time Stamp (DTS) of the fragment. Set after transmux complete.\n    this.startDTS = void 0;\n    // The ending Decode Time Stamp (DTS) of the fragment. Set after transmux complete.\n    this.endDTS = void 0;\n    // The start time of the fragment, as listed in the manifest. Updated after transmux complete.\n    this.start = 0;\n    // The offset time (seconds) of the fragment from the start of the Playlist\n    this.playlistOffset = 0;\n    // Set by `updateFragPTSDTS` in level-helper\n    this.deltaPTS = void 0;\n    // The maximum starting Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.\n    this.maxStartPTS = void 0;\n    // The minimum ending Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.\n    this.minEndPTS = void 0;\n    // Init Segment bytes (unset for media segments)\n    this.data = void 0;\n    // A flag indicating whether the segment was downloaded in order to test bitrate, and was not buffered\n    this.bitrateTest = false;\n    // #EXTINF  segment title\n    this.title = null;\n    // The Media Initialization Section for this segment\n    this.initSegment = null;\n    // Fragment is the last fragment in the media playlist\n    this.endList = void 0;\n    // Fragment is marked by an EXT-X-GAP tag indicating that it does not contain media data and should not be loaded\n    this.gap = void 0;\n    // Deprecated\n    this.urlId = 0;\n    this.type = type;\n  }\n  get byteLength() {\n    if (this.hasStats) {\n      const total = this.stats.total;\n      if (total) {\n        return total;\n      }\n    }\n    if (this.byteRange) {\n      const start = this.byteRange[0];\n      const end = this.byteRange[1];\n      if (isFiniteNumber(start) && isFiniteNumber(end)) {\n        return end - start;\n      }\n    }\n    return null;\n  }\n  get bitrate() {\n    if (this.byteLength) {\n      return this.byteLength * 8 / this.duration;\n    }\n    if (this._bitrate) {\n      return this._bitrate;\n    }\n    return null;\n  }\n  set bitrate(value) {\n    this._bitrate = value;\n  }\n  get decryptdata() {\n    const {\n      levelkeys\n    } = this;\n    if (!levelkeys && !this._decryptdata) {\n      return null;\n    }\n    if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {\n      const key = this.levelkeys.identity;\n      if (key) {\n        this._decryptdata = key.getDecryptData(this.sn);\n      } else {\n        const keyFormats = Object.keys(this.levelkeys);\n        if (keyFormats.length === 1) {\n          return this._decryptdata = this.levelkeys[keyFormats[0]].getDecryptData(this.sn);\n        }\n      }\n    }\n    return this._decryptdata;\n  }\n  get end() {\n    return this.start + this.duration;\n  }\n  get endProgramDateTime() {\n    if (this.programDateTime === null) {\n      return null;\n    }\n    const duration = !isFiniteNumber(this.duration) ? 0 : this.duration;\n    return this.programDateTime + duration * 1000;\n  }\n  get encrypted() {\n    var _this$_decryptdata;\n    // At the m3u8-parser level we need to add support for manifest signalled keyformats\n    // when we want the fragment to start reporting that it is encrypted.\n    // Currently, keyFormat will only be set for identity keys\n    if ((_this$_decryptdata = this._decryptdata) != null && _this$_decryptdata.encrypted) {\n      return true;\n    } else if (this.levelkeys) {\n      const keyFormats = Object.keys(this.levelkeys);\n      const len = keyFormats.length;\n      if (len > 1 || len === 1 && this.levelkeys[keyFormats[0]].encrypted) {\n        return true;\n      }\n    }\n    return false;\n  }\n  get programDateTime() {\n    if (this._programDateTime === null && this.rawProgramDateTime) {\n      this.programDateTime = Date.parse(this.rawProgramDateTime);\n    }\n    return this._programDateTime;\n  }\n  set programDateTime(value) {\n    if (!isFiniteNumber(value)) {\n      this._programDateTime = this.rawProgramDateTime = null;\n      return;\n    }\n    this._programDateTime = value;\n  }\n  get ref() {\n    if (!isMediaFragment(this)) {\n      return null;\n    }\n    if (!this._ref) {\n      this._ref = {\n        base: this.base,\n        start: this.start,\n        duration: this.duration,\n        sn: this.sn,\n        programDateTime: this.programDateTime\n      };\n    }\n    return this._ref;\n  }\n  addStart(value) {\n    this.setStart(this.start + value);\n  }\n  setStart(value) {\n    this.start = value;\n    if (this._ref) {\n      this._ref.start = value;\n    }\n  }\n  setDuration(value) {\n    this.duration = value;\n    if (this._ref) {\n      this._ref.duration = value;\n    }\n  }\n  setKeyFormat(keyFormat) {\n    if (this.levelkeys) {\n      const key = this.levelkeys[keyFormat];\n      if (key && !this._decryptdata) {\n        this._decryptdata = key.getDecryptData(this.sn);\n      }\n    }\n  }\n  abortRequests() {\n    var _this$loader, _this$keyLoader;\n    (_this$loader = this.loader) == null ? void 0 : _this$loader.abort();\n    (_this$keyLoader = this.keyLoader) == null ? void 0 : _this$keyLoader.abort();\n  }\n  setElementaryStreamInfo(type, startPTS, endPTS, startDTS, endDTS, partial = false) {\n    const {\n      elementaryStreams\n    } = this;\n    const info = elementaryStreams[type];\n    if (!info) {\n      elementaryStreams[type] = {\n        startPTS,\n        endPTS,\n        startDTS,\n        endDTS,\n        partial\n      };\n      return;\n    }\n    info.startPTS = Math.min(info.startPTS, startPTS);\n    info.endPTS = Math.max(info.endPTS, endPTS);\n    info.startDTS = Math.min(info.startDTS, startDTS);\n    info.endDTS = Math.max(info.endDTS, endDTS);\n  }\n}\n\n/**\n * Object representing parsed data from an HLS Partial Segment. Found in {@link hls.js#LevelDetails.partList}.\n */\nclass Part extends BaseSegment {\n  constructor(partAttrs, frag, base, index, previous) {\n    super(base);\n    this.fragOffset = 0;\n    this.duration = 0;\n    this.gap = false;\n    this.independent = false;\n    this.relurl = void 0;\n    this.fragment = void 0;\n    this.index = void 0;\n    this.duration = partAttrs.decimalFloatingPoint('DURATION');\n    this.gap = partAttrs.bool('GAP');\n    this.independent = partAttrs.bool('INDEPENDENT');\n    this.relurl = partAttrs.enumeratedString('URI');\n    this.fragment = frag;\n    this.index = index;\n    const byteRange = partAttrs.enumeratedString('BYTERANGE');\n    if (byteRange) {\n      this.setByteRange(byteRange, previous);\n    }\n    if (previous) {\n      this.fragOffset = previous.fragOffset + previous.duration;\n    }\n  }\n  get start() {\n    return this.fragment.start + this.fragOffset;\n  }\n  get end() {\n    return this.start + this.duration;\n  }\n  get loaded() {\n    const {\n      elementaryStreams\n    } = this;\n    return !!(elementaryStreams.audio || elementaryStreams.video || elementaryStreams.audiovideo);\n  }\n}\nfunction getOwnPropertyDescriptorFromPrototypeChain(object, property) {\n  const prototype = Object.getPrototypeOf(object);\n  if (prototype) {\n    const propertyDescriptor = Object.getOwnPropertyDescriptor(prototype, property);\n    if (propertyDescriptor) {\n      return propertyDescriptor;\n    }\n    return getOwnPropertyDescriptorFromPrototypeChain(prototype, property);\n  }\n}\nfunction makeEnumerable(object, property) {\n  const d = getOwnPropertyDescriptorFromPrototypeChain(object, property);\n  if (d) {\n    d.enumerable = true;\n    Object.defineProperty(object, property, d);\n  }\n}\n\nconst UINT32_MAX$1 = Math.pow(2, 32) - 1;\nconst push = [].push;\n\n// We are using fixed track IDs for driving the MP4 remuxer\n// instead of following the TS PIDs.\n// There is no reason not to do this and some browsers/SourceBuffer-demuxers\n// may not like if there are TrackID \"switches\"\n// See https://github.com/video-dev/hls.js/issues/1331\n// Here we are mapping our internal track types to constant MP4 track IDs\n// With MSE currently one can only have one track of each, and we are muxing\n// whatever video/audio rendition in them.\nconst RemuxerTrackIdConfig = {\n  video: 1,\n  audio: 2,\n  id3: 3,\n  text: 4\n};\nfunction bin2str(data) {\n  return String.fromCharCode.apply(null, data);\n}\nfunction readUint16(buffer, offset) {\n  const val = buffer[offset] << 8 | buffer[offset + 1];\n  return val < 0 ? 65536 + val : val;\n}\nfunction readUint32(buffer, offset) {\n  const val = readSint32(buffer, offset);\n  return val < 0 ? 4294967296 + val : val;\n}\nfunction readUint64(buffer, offset) {\n  let result = readUint32(buffer, offset);\n  result *= Math.pow(2, 32);\n  result += readUint32(buffer, offset + 4);\n  return result;\n}\nfunction readSint32(buffer, offset) {\n  return buffer[offset] << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3];\n}\n\n// Find \"moof\" box\nfunction hasMoofData(data) {\n  const end = data.byteLength;\n  for (let i = 0; i < end;) {\n    const size = readUint32(data, i);\n    if (size > 8 && data[i + 4] === 0x6d && data[i + 5] === 0x6f && data[i + 6] === 0x6f && data[i + 7] === 0x66) {\n      return true;\n    }\n    i = size > 1 ? i + size : end;\n  }\n  return false;\n}\n\n// Find the data for a box specified by its path\nfunction findBox(data, path) {\n  const results = [];\n  if (!path.length) {\n    // short-circuit the search for empty paths\n    return results;\n  }\n  const end = data.byteLength;\n  for (let i = 0; i < end;) {\n    const size = readUint32(data, i);\n    const type = bin2str(data.subarray(i + 4, i + 8));\n    const endbox = size > 1 ? i + size : end;\n    if (type === path[0]) {\n      if (path.length === 1) {\n        // this is the end of the path and we've found the box we were\n        // looking for\n        results.push(data.subarray(i + 8, endbox));\n      } else {\n        // recursively search for the next box along the path\n        const subresults = findBox(data.subarray(i + 8, endbox), path.slice(1));\n        if (subresults.length) {\n          push.apply(results, subresults);\n        }\n      }\n    }\n    i = endbox;\n  }\n\n  // we've finished searching all of data\n  return results;\n}\nfunction parseSegmentIndex(sidx) {\n  const references = [];\n  const version = sidx[0];\n\n  // set initial offset, we skip the reference ID (not needed)\n  let index = 8;\n  const timescale = readUint32(sidx, index);\n  index += 4;\n  let earliestPresentationTime = 0;\n  let firstOffset = 0;\n  if (version === 0) {\n    earliestPresentationTime = readUint32(sidx, index);\n    firstOffset = readUint32(sidx, index + 4);\n    index += 8;\n  } else {\n    earliestPresentationTime = readUint64(sidx, index);\n    firstOffset = readUint64(sidx, index + 8);\n    index += 16;\n  }\n\n  // skip reserved\n  index += 2;\n  let startByte = sidx.length + firstOffset;\n  const referencesCount = readUint16(sidx, index);\n  index += 2;\n  for (let i = 0; i < referencesCount; i++) {\n    let referenceIndex = index;\n    const referenceInfo = readUint32(sidx, referenceIndex);\n    referenceIndex += 4;\n    const referenceSize = referenceInfo & 0x7fffffff;\n    const referenceType = (referenceInfo & 0x80000000) >>> 31;\n    if (referenceType === 1) {\n      logger.warn('SIDX has hierarchical references (not supported)');\n      return null;\n    }\n    const subsegmentDuration = readUint32(sidx, referenceIndex);\n    referenceIndex += 4;\n    references.push({\n      referenceSize,\n      subsegmentDuration,\n      // unscaled\n      info: {\n        duration: subsegmentDuration / timescale,\n        start: startByte,\n        end: startByte + referenceSize - 1\n      }\n    });\n    startByte += referenceSize;\n\n    // Skipping 1 bit for |startsWithSap|, 3 bits for |sapType|, and 28 bits\n    // for |sapDelta|.\n    referenceIndex += 4;\n\n    // skip to next ref\n    index = referenceIndex;\n  }\n  return {\n    earliestPresentationTime,\n    timescale,\n    version,\n    referencesCount,\n    references\n  };\n}\n\n/**\n * Parses an MP4 initialization segment and extracts stream type and\n * timescale values for any declared tracks. Timescale values indicate the\n * number of clock ticks per second to assume for time-based values\n * elsewhere in the MP4.\n *\n * To determine the start time of an MP4, you need two pieces of\n * information: the timescale unit and the earliest base media decode\n * time. Multiple timescales can be specified within an MP4 but the\n * base media decode time is always expressed in the timescale from\n * the media header box for the track:\n * ```\n * moov > trak > mdia > mdhd.timescale\n * moov > trak > mdia > hdlr\n * ```\n * @param initSegment the bytes of the init segment\n * @returns a hash of track type to timescale values or null if\n * the init segment is malformed.\n */\n\nfunction parseInitSegment(initSegment) {\n  const result = [];\n  const traks = findBox(initSegment, ['moov', 'trak']);\n  for (let i = 0; i < traks.length; i++) {\n    const trak = traks[i];\n    const tkhd = findBox(trak, ['tkhd'])[0];\n    if (tkhd) {\n      let version = tkhd[0];\n      const trackId = readUint32(tkhd, version === 0 ? 12 : 20);\n      const mdhd = findBox(trak, ['mdia', 'mdhd'])[0];\n      if (mdhd) {\n        version = mdhd[0];\n        const timescale = readUint32(mdhd, version === 0 ? 12 : 20);\n        const hdlr = findBox(trak, ['mdia', 'hdlr'])[0];\n        if (hdlr) {\n          const hdlrType = bin2str(hdlr.subarray(8, 12));\n          const type = {\n            soun: ElementaryStreamTypes.AUDIO,\n            vide: ElementaryStreamTypes.VIDEO\n          }[hdlrType];\n          // Parse codec details\n          const stsdBox = findBox(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];\n          const stsd = parseStsd(stsdBox);\n          if (type) {\n            // Add 'audio', 'video', and 'audiovideo' track records that will map to SourceBuffers\n            result[trackId] = {\n              timescale,\n              type,\n              stsd\n            };\n            result[type] = _objectSpread2({\n              timescale,\n              id: trackId\n            }, stsd);\n          } else {\n            // Add 'meta' and other track records\n            result[trackId] = {\n              timescale,\n              type: hdlrType,\n              stsd\n            };\n          }\n        }\n      }\n    }\n  }\n  const trex = findBox(initSegment, ['moov', 'mvex', 'trex']);\n  trex.forEach(trex => {\n    const trackId = readUint32(trex, 4);\n    const track = result[trackId];\n    if (track) {\n      track.default = {\n        duration: readUint32(trex, 12),\n        flags: readUint32(trex, 20)\n      };\n    }\n  });\n  return result;\n}\nfunction parseStsd(stsd) {\n  const sampleEntries = stsd.subarray(8);\n  const sampleEntriesEnd = sampleEntries.subarray(8 + 78);\n  const fourCC = bin2str(sampleEntries.subarray(4, 8));\n  let codec = fourCC;\n  let supplemental;\n  const encrypted = fourCC === 'enca' || fourCC === 'encv';\n  if (encrypted) {\n    const encBox = findBox(sampleEntries, [fourCC])[0];\n    const encBoxChildren = encBox.subarray(fourCC === 'enca' ? 28 : 78);\n    const sinfs = findBox(encBoxChildren, ['sinf']);\n    sinfs.forEach(sinf => {\n      const schm = findBox(sinf, ['schm'])[0];\n      if (schm) {\n        const scheme = bin2str(schm.subarray(4, 8));\n        if (scheme === 'cbcs' || scheme === 'cenc') {\n          const frma = findBox(sinf, ['frma'])[0];\n          if (frma) {\n            // for encrypted content codec fourCC will be in frma\n            codec = bin2str(frma);\n          }\n        }\n      }\n    });\n  }\n  const codecFourCC = codec;\n  switch (codec) {\n    case 'avc1':\n    case 'avc2':\n    case 'avc3':\n    case 'avc4':\n      {\n        // extract profile + compatibility + level out of avcC box\n        const avcCBox = findBox(sampleEntriesEnd, ['avcC'])[0];\n        if (avcCBox && avcCBox.length > 3) {\n          codec += '.' + toHex(avcCBox[1]) + toHex(avcCBox[2]) + toHex(avcCBox[3]);\n          supplemental = parseSupplementalDoViCodec(codecFourCC === 'avc1' ? 'dva1' : 'dvav', sampleEntriesEnd);\n        }\n        break;\n      }\n    case 'mp4a':\n      {\n        const codecBox = findBox(sampleEntries, [fourCC])[0];\n        const esdsBox = findBox(codecBox.subarray(28), ['esds'])[0];\n        if (esdsBox && esdsBox.length > 7) {\n          let i = 4;\n          // ES Descriptor tag\n          if (esdsBox[i++] !== 0x03) {\n            break;\n          }\n          i = skipBERInteger(esdsBox, i);\n          i += 2; // skip es_id;\n          const flags = esdsBox[i++];\n          if (flags & 0x80) {\n            i += 2; // skip dependency es_id\n          }\n          if (flags & 0x40) {\n            i += esdsBox[i++]; // skip URL\n          }\n          // Decoder config descriptor\n          if (esdsBox[i++] !== 0x04) {\n            break;\n          }\n          i = skipBERInteger(esdsBox, i);\n          const objectType = esdsBox[i++];\n          if (objectType === 0x40) {\n            codec += '.' + toHex(objectType);\n          } else {\n            break;\n          }\n          i += 12;\n          // Decoder specific info\n          if (esdsBox[i++] !== 0x05) {\n            break;\n          }\n          i = skipBERInteger(esdsBox, i);\n          const firstByte = esdsBox[i++];\n          let audioObjectType = (firstByte & 0xf8) >> 3;\n          if (audioObjectType === 31) {\n            audioObjectType += 1 + ((firstByte & 0x7) << 3) + ((esdsBox[i] & 0xe0) >> 5);\n          }\n          codec += '.' + audioObjectType;\n        }\n        break;\n      }\n    case 'hvc1':\n    case 'hev1':\n      {\n        const hvcCBox = findBox(sampleEntriesEnd, ['hvcC'])[0];\n        if (hvcCBox && hvcCBox.length > 12) {\n          const profileByte = hvcCBox[1];\n          const profileSpace = ['', 'A', 'B', 'C'][profileByte >> 6];\n          const generalProfileIdc = profileByte & 0x1f;\n          const profileCompat = readUint32(hvcCBox, 2);\n          const tierFlag = (profileByte & 0x20) >> 5 ? 'H' : 'L';\n          const levelIDC = hvcCBox[12];\n          const constraintIndicator = hvcCBox.subarray(6, 12);\n          codec += '.' + profileSpace + generalProfileIdc;\n          codec += '.' + reverse32BitInt(profileCompat).toString(16).toUpperCase();\n          codec += '.' + tierFlag + levelIDC;\n          let constraintString = '';\n          for (let i = constraintIndicator.length; i--;) {\n            const byte = constraintIndicator[i];\n            if (byte || constraintString) {\n              const encodedByte = byte.toString(16).toUpperCase();\n              constraintString = '.' + encodedByte + constraintString;\n            }\n          }\n          codec += constraintString;\n        }\n        supplemental = parseSupplementalDoViCodec(codecFourCC == 'hev1' ? 'dvhe' : 'dvh1', sampleEntriesEnd);\n        break;\n      }\n    case 'dvh1':\n    case 'dvhe':\n    case 'dvav':\n    case 'dva1':\n    case 'dav1':\n      {\n        codec = parseSupplementalDoViCodec(codec, sampleEntriesEnd) || codec;\n        break;\n      }\n    case 'vp09':\n      {\n        const vpcCBox = findBox(sampleEntriesEnd, ['vpcC'])[0];\n        if (vpcCBox && vpcCBox.length > 6) {\n          const profile = vpcCBox[4];\n          const level = vpcCBox[5];\n          const bitDepth = vpcCBox[6] >> 4 & 0x0f;\n          codec += '.' + addLeadingZero(profile) + '.' + addLeadingZero(level) + '.' + addLeadingZero(bitDepth);\n        }\n        break;\n      }\n    case 'av01':\n      {\n        const av1CBox = findBox(sampleEntriesEnd, ['av1C'])[0];\n        if (av1CBox && av1CBox.length > 2) {\n          const profile = av1CBox[1] >>> 5;\n          const level = av1CBox[1] & 0x1f;\n          const tierFlag = av1CBox[2] >>> 7 ? 'H' : 'M';\n          const highBitDepth = (av1CBox[2] & 0x40) >> 6;\n          const twelveBit = (av1CBox[2] & 0x20) >> 5;\n          const bitDepth = profile === 2 && highBitDepth ? twelveBit ? 12 : 10 : highBitDepth ? 10 : 8;\n          const monochrome = (av1CBox[2] & 0x10) >> 4;\n          const chromaSubsamplingX = (av1CBox[2] & 0x08) >> 3;\n          const chromaSubsamplingY = (av1CBox[2] & 0x04) >> 2;\n          const chromaSamplePosition = av1CBox[2] & 0x03;\n          // TODO: parse color_description_present_flag\n          // default it to BT.709/limited range for now\n          // more info https://aomediacodec.github.io/av1-isobmff/#av1codecconfigurationbox-syntax\n          const colorPrimaries = 1;\n          const transferCharacteristics = 1;\n          const matrixCoefficients = 1;\n          const videoFullRangeFlag = 0;\n          codec += '.' + profile + '.' + addLeadingZero(level) + tierFlag + '.' + addLeadingZero(bitDepth) + '.' + monochrome + '.' + chromaSubsamplingX + chromaSubsamplingY + chromaSamplePosition + '.' + addLeadingZero(colorPrimaries) + '.' + addLeadingZero(transferCharacteristics) + '.' + addLeadingZero(matrixCoefficients) + '.' + videoFullRangeFlag;\n          supplemental = parseSupplementalDoViCodec('dav1', sampleEntriesEnd);\n        }\n        break;\n      }\n  }\n  return {\n    codec,\n    encrypted,\n    supplemental\n  };\n}\nfunction parseSupplementalDoViCodec(fourCC, sampleEntriesEnd) {\n  const dvvCResult = findBox(sampleEntriesEnd, ['dvvC']); // used by DoVi Profile 8 to 10\n  const dvXCBox = dvvCResult.length ? dvvCResult[0] : findBox(sampleEntriesEnd, ['dvcC'])[0]; // used by DoVi Profiles up to 7 and 20\n  if (dvXCBox) {\n    const doViProfile = dvXCBox[2] >> 1 & 0x7f;\n    const doViLevel = dvXCBox[2] << 5 & 0x20 | dvXCBox[3] >> 3 & 0x1f;\n    return fourCC + '.' + addLeadingZero(doViProfile) + '.' + addLeadingZero(doViLevel);\n  }\n}\nfunction reverse32BitInt(val) {\n  let result = 0;\n  for (let i = 0; i < 32; i++) {\n    result |= (val >> i & 1) << 32 - 1 - i;\n  }\n  return result >>> 0;\n}\nfunction skipBERInteger(bytes, i) {\n  const limit = i + 5;\n  while (bytes[i++] & 0x80 && i < limit) {\n    /* do nothing */\n  }\n  return i;\n}\nfunction toHex(x) {\n  return ('0' + x.toString(16).toUpperCase()).slice(-2);\n}\nfunction addLeadingZero(num) {\n  return (num < 10 ? '0' : '') + num;\n}\nfunction patchEncyptionData(initSegment, decryptdata) {\n  if (!initSegment || !decryptdata) {\n    return initSegment;\n  }\n  const keyId = decryptdata.keyId;\n  if (keyId && decryptdata.isCommonEncryption) {\n    const traks = findBox(initSegment, ['moov', 'trak']);\n    traks.forEach(trak => {\n      const stsd = findBox(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];\n\n      // skip the sample entry count\n      const sampleEntries = stsd.subarray(8);\n      let encBoxes = findBox(sampleEntries, ['enca']);\n      const isAudio = encBoxes.length > 0;\n      if (!isAudio) {\n        encBoxes = findBox(sampleEntries, ['encv']);\n      }\n      encBoxes.forEach(enc => {\n        const encBoxChildren = isAudio ? enc.subarray(28) : enc.subarray(78);\n        const sinfBoxes = findBox(encBoxChildren, ['sinf']);\n        sinfBoxes.forEach(sinf => {\n          const tenc = parseSinf(sinf);\n          if (tenc) {\n            // Look for default key id (keyID offset is always 8 within the tenc box):\n            const tencKeyId = tenc.subarray(8, 24);\n            if (!tencKeyId.some(b => b !== 0)) {\n              logger.log(`[eme] Patching keyId in 'enc${isAudio ? 'a' : 'v'}>sinf>>tenc' box: ${Hex.hexDump(tencKeyId)} -> ${Hex.hexDump(keyId)}`);\n              tenc.set(keyId, 8);\n            }\n          }\n        });\n      });\n    });\n  }\n  return initSegment;\n}\nfunction parseSinf(sinf) {\n  const schm = findBox(sinf, ['schm'])[0];\n  if (schm) {\n    const scheme = bin2str(schm.subarray(4, 8));\n    if (scheme === 'cbcs' || scheme === 'cenc') {\n      return findBox(sinf, ['schi', 'tenc'])[0];\n    }\n  }\n  return null;\n}\n\n/*\n  For Reference:\n  aligned(8) class TrackFragmentHeaderBox\n           extends FullBox(‘tfhd’, 0, tf_flags){\n     unsigned int(32)  track_ID;\n     // all the following are optional fields\n     unsigned int(64)  base_data_offset;\n     unsigned int(32)  sample_description_index;\n     unsigned int(32)  default_sample_duration;\n     unsigned int(32)  default_sample_size;\n     unsigned int(32)  default_sample_flags\n  }\n */\n\nfunction getSampleData(data, initData, logger) {\n  const tracks = {};\n  const trafs = findBox(data, ['moof', 'traf']);\n  for (let i = 0; i < trafs.length; i++) {\n    const traf = trafs[i];\n    // There is only one tfhd & trun per traf\n    // This is true for CMAF style content, and we should perhaps check the ftyp\n    // and only look for a single trun then, but for ISOBMFF we should check\n    // for multiple track runs.\n    const tfhd = findBox(traf, ['tfhd'])[0];\n    // get the track id from the tfhd\n    const id = readUint32(tfhd, 4);\n    const track = initData[id];\n    if (!track) {\n      continue;\n    }\n    const trackTimes = tracks[id] || (tracks[id] = {\n      start: NaN,\n      duration: 0,\n      sampleCount: 0,\n      timescale: track.timescale,\n      type: track.type\n    });\n    // get start DTS\n    const tfdt = findBox(traf, ['tfdt'])[0];\n    if (tfdt) {\n      const version = tfdt[0];\n      let baseTime = readUint32(tfdt, 4);\n      if (version === 1) {\n        // If value is too large, assume signed 64-bit. Negative track fragment decode times are invalid, but they exist in the wild.\n        // This prevents large values from being used for initPTS, which can cause playlist sync issues.\n        // https://github.com/video-dev/hls.js/issues/5303\n        if (baseTime === UINT32_MAX$1) {\n          logger.warn(`[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time`);\n        } else {\n          baseTime *= UINT32_MAX$1 + 1;\n          baseTime += readUint32(tfdt, 8);\n        }\n      }\n      if (isFiniteNumber(baseTime) && (!isFiniteNumber(trackTimes.start) || baseTime < trackTimes.start)) {\n        trackTimes.start = baseTime;\n      }\n    }\n    const trackDefault = track.default;\n    const tfhdFlags = readUint32(tfhd, 0) | (trackDefault == null ? void 0 : trackDefault.flags);\n    let defaultSampleDuration = (trackDefault == null ? void 0 : trackDefault.duration) || 0;\n    if (tfhdFlags & 0x000008) {\n      // 0x000008 indicates the presence of the default_sample_duration field\n      if (tfhdFlags & 0x000002) {\n        // 0x000002 indicates the presence of the sample_description_index field, which precedes default_sample_duration\n        // If present, the default_sample_duration exists at byte offset 12\n        defaultSampleDuration = readUint32(tfhd, 12);\n      } else {\n        // Otherwise, the duration is at byte offset 8\n        defaultSampleDuration = readUint32(tfhd, 8);\n      }\n    }\n    const truns = findBox(traf, ['trun']);\n    let sampleDTS = trackTimes.start || 0;\n    let rawDuration = 0;\n    let sampleDuration = defaultSampleDuration;\n    for (let j = 0; j < truns.length; j++) {\n      const trun = truns[j];\n      const sampleCount = readUint32(trun, 4);\n      const sampleIndex = trackTimes.sampleCount;\n      trackTimes.sampleCount += sampleCount;\n      // Get duration from samples\n      const dataOffsetPresent = trun[3] & 0x01;\n      const firstSampleFlagsPresent = trun[3] & 0x04;\n      const sampleDurationPresent = trun[2] & 0x01;\n      const sampleSizePresent = trun[2] & 0x02;\n      const sampleFlagsPresent = trun[2] & 0x04;\n      const sampleCompositionTimeOffsetPresent = trun[2] & 0x08;\n      let offset = 8;\n      let remaining = sampleCount;\n      if (dataOffsetPresent) {\n        offset += 4;\n      }\n      if (firstSampleFlagsPresent && sampleCount) {\n        const isNonSyncSample = trun[offset + 1] & 0x01;\n        if (!isNonSyncSample && trackTimes.keyFrameIndex === undefined) {\n          trackTimes.keyFrameIndex = sampleIndex;\n        }\n        offset += 4;\n        if (sampleDurationPresent) {\n          sampleDuration = readUint32(trun, offset);\n          offset += 4;\n        } else {\n          sampleDuration = defaultSampleDuration;\n        }\n        if (sampleSizePresent) {\n          offset += 4;\n        }\n        if (sampleCompositionTimeOffsetPresent) {\n          offset += 4;\n        }\n        sampleDTS += sampleDuration;\n        rawDuration += sampleDuration;\n        remaining--;\n      }\n      while (remaining--) {\n        if (sampleDurationPresent) {\n          sampleDuration = readUint32(trun, offset);\n          offset += 4;\n        } else {\n          sampleDuration = defaultSampleDuration;\n        }\n        if (sampleSizePresent) {\n          offset += 4;\n        }\n        if (sampleFlagsPresent) {\n          const isNonSyncSample = trun[offset + 1] & 0x01;\n          if (!isNonSyncSample) {\n            if (trackTimes.keyFrameIndex === undefined) {\n              trackTimes.keyFrameIndex = trackTimes.sampleCount - (remaining + 1);\n              trackTimes.keyFrameStart = sampleDTS;\n            }\n          }\n          offset += 4;\n        }\n        if (sampleCompositionTimeOffsetPresent) {\n          offset += 4;\n        }\n        sampleDTS += sampleDuration;\n        rawDuration += sampleDuration;\n      }\n      if (!rawDuration && defaultSampleDuration) {\n        rawDuration += defaultSampleDuration * sampleCount;\n      }\n    }\n    trackTimes.duration += rawDuration;\n  }\n  if (!Object.keys(tracks).some(trackId => tracks[trackId].duration)) {\n    // If duration samples are not available in the traf use sidx subsegment_duration\n    let sidxMinStart = Infinity;\n    let sidxMaxEnd = 0;\n    const sidxs = findBox(data, ['sidx']);\n    for (let i = 0; i < sidxs.length; i++) {\n      const sidx = parseSegmentIndex(sidxs[i]);\n      if (sidx != null && sidx.references) {\n        sidxMinStart = Math.min(sidxMinStart, sidx.earliestPresentationTime / sidx.timescale);\n        const subSegmentDuration = sidx.references.reduce((dur, ref) => dur + ref.info.duration || 0, 0);\n        sidxMaxEnd = Math.max(sidxMaxEnd, subSegmentDuration + sidx.earliestPresentationTime / sidx.timescale);\n      }\n    }\n    if (sidxMaxEnd && isFiniteNumber(sidxMaxEnd)) {\n      Object.keys(tracks).forEach(trackId => {\n        if (!tracks[trackId].duration) {\n          tracks[trackId].duration = sidxMaxEnd * tracks[trackId].timescale - tracks[trackId].start;\n        }\n      });\n    }\n  }\n  return tracks;\n}\n\n// TODO: Check if the last moof+mdat pair is part of the valid range\nfunction segmentValidRange(data) {\n  const segmentedRange = {\n    valid: null,\n    remainder: null\n  };\n  const moofs = findBox(data, ['moof']);\n  if (moofs.length < 2) {\n    segmentedRange.remainder = data;\n    return segmentedRange;\n  }\n  const last = moofs[moofs.length - 1];\n  // Offset by 8 bytes; findBox offsets the start by as much\n  segmentedRange.valid = data.slice(0, last.byteOffset - 8);\n  segmentedRange.remainder = data.slice(last.byteOffset - 8);\n  return segmentedRange;\n}\nfunction appendUint8Array(data1, data2) {\n  const temp = new Uint8Array(data1.length + data2.length);\n  temp.set(data1);\n  temp.set(data2, data1.length);\n  return temp;\n}\nfunction parseSamples(timeOffset, track) {\n  const seiSamples = [];\n  const videoData = track.samples;\n  const timescale = track.timescale;\n  const trackId = track.id;\n  let isHEVCFlavor = false;\n  const moofs = findBox(videoData, ['moof']);\n  moofs.map(moof => {\n    const moofOffset = moof.byteOffset - 8;\n    const trafs = findBox(moof, ['traf']);\n    trafs.map(traf => {\n      // get the base media decode time from the tfdt\n      const baseTime = findBox(traf, ['tfdt']).map(tfdt => {\n        const version = tfdt[0];\n        let result = readUint32(tfdt, 4);\n        if (version === 1) {\n          result *= Math.pow(2, 32);\n          result += readUint32(tfdt, 8);\n        }\n        return result / timescale;\n      })[0];\n      if (baseTime !== undefined) {\n        timeOffset = baseTime;\n      }\n      return findBox(traf, ['tfhd']).map(tfhd => {\n        const id = readUint32(tfhd, 4);\n        const tfhdFlags = readUint32(tfhd, 0) & 0xffffff;\n        const baseDataOffsetPresent = (tfhdFlags & 0x000001) !== 0;\n        const sampleDescriptionIndexPresent = (tfhdFlags & 0x000002) !== 0;\n        const defaultSampleDurationPresent = (tfhdFlags & 0x000008) !== 0;\n        let defaultSampleDuration = 0;\n        const defaultSampleSizePresent = (tfhdFlags & 0x000010) !== 0;\n        let defaultSampleSize = 0;\n        const defaultSampleFlagsPresent = (tfhdFlags & 0x000020) !== 0;\n        let tfhdOffset = 8;\n        if (id === trackId) {\n          if (baseDataOffsetPresent) {\n            tfhdOffset += 8;\n          }\n          if (sampleDescriptionIndexPresent) {\n            tfhdOffset += 4;\n          }\n          if (defaultSampleDurationPresent) {\n            defaultSampleDuration = readUint32(tfhd, tfhdOffset);\n            tfhdOffset += 4;\n          }\n          if (defaultSampleSizePresent) {\n            defaultSampleSize = readUint32(tfhd, tfhdOffset);\n            tfhdOffset += 4;\n          }\n          if (defaultSampleFlagsPresent) {\n            tfhdOffset += 4;\n          }\n          if (track.type === 'video') {\n            isHEVCFlavor = isHEVC(track.codec);\n          }\n          findBox(traf, ['trun']).map(trun => {\n            const version = trun[0];\n            const flags = readUint32(trun, 0) & 0xffffff;\n            const dataOffsetPresent = (flags & 0x000001) !== 0;\n            let dataOffset = 0;\n            const firstSampleFlagsPresent = (flags & 0x000004) !== 0;\n            const sampleDurationPresent = (flags & 0x000100) !== 0;\n            let sampleDuration = 0;\n            const sampleSizePresent = (flags & 0x000200) !== 0;\n            let sampleSize = 0;\n            const sampleFlagsPresent = (flags & 0x000400) !== 0;\n            const sampleCompositionOffsetsPresent = (flags & 0x000800) !== 0;\n            let compositionOffset = 0;\n            const sampleCount = readUint32(trun, 4);\n            let trunOffset = 8; // past version, flags, and sample count\n\n            if (dataOffsetPresent) {\n              dataOffset = readUint32(trun, trunOffset);\n              trunOffset += 4;\n            }\n            if (firstSampleFlagsPresent) {\n              trunOffset += 4;\n            }\n            let sampleOffset = dataOffset + moofOffset;\n            for (let ix = 0; ix < sampleCount; ix++) {\n              if (sampleDurationPresent) {\n                sampleDuration = readUint32(trun, trunOffset);\n                trunOffset += 4;\n              } else {\n                sampleDuration = defaultSampleDuration;\n              }\n              if (sampleSizePresent) {\n                sampleSize = readUint32(trun, trunOffset);\n                trunOffset += 4;\n              } else {\n                sampleSize = defaultSampleSize;\n              }\n              if (sampleFlagsPresent) {\n                trunOffset += 4;\n              }\n              if (sampleCompositionOffsetsPresent) {\n                if (version === 0) {\n                  compositionOffset = readUint32(trun, trunOffset);\n                } else {\n                  compositionOffset = readSint32(trun, trunOffset);\n                }\n                trunOffset += 4;\n              }\n              if (track.type === ElementaryStreamTypes.VIDEO) {\n                let naluTotalSize = 0;\n                while (naluTotalSize < sampleSize) {\n                  const naluSize = readUint32(videoData, sampleOffset);\n                  sampleOffset += 4;\n                  if (isSEIMessage(isHEVCFlavor, videoData[sampleOffset])) {\n                    const data = videoData.subarray(sampleOffset, sampleOffset + naluSize);\n                    parseSEIMessageFromNALu(data, isHEVCFlavor ? 2 : 1, timeOffset + compositionOffset / timescale, seiSamples);\n                  }\n                  sampleOffset += naluSize;\n                  naluTotalSize += naluSize + 4;\n                }\n              }\n              timeOffset += sampleDuration / timescale;\n            }\n          });\n        }\n      });\n    });\n  });\n  return seiSamples;\n}\nfunction isHEVC(codec) {\n  if (!codec) {\n    return false;\n  }\n  const baseCodec = codec.substring(0, 4);\n  return baseCodec === 'hvc1' || baseCodec === 'hev1' ||\n  // Dolby Vision\n  baseCodec === 'dvh1' || baseCodec === 'dvhe';\n}\nfunction isSEIMessage(isHEVCFlavor, naluHeader) {\n  if (isHEVCFlavor) {\n    const naluType = naluHeader >> 1 & 0x3f;\n    return naluType === 39 || naluType === 40;\n  } else {\n    const naluType = naluHeader & 0x1f;\n    return naluType === 6;\n  }\n}\nfunction parseSEIMessageFromNALu(unescapedData, headerSize, pts, samples) {\n  const data = discardEPB(unescapedData);\n  let seiPtr = 0;\n  // skip nal header\n  seiPtr += headerSize;\n  let payloadType = 0;\n  let payloadSize = 0;\n  let b = 0;\n  while (seiPtr < data.length) {\n    payloadType = 0;\n    do {\n      if (seiPtr >= data.length) {\n        break;\n      }\n      b = data[seiPtr++];\n      payloadType += b;\n    } while (b === 0xff);\n\n    // Parse payload size.\n    payloadSize = 0;\n    do {\n      if (seiPtr >= data.length) {\n        break;\n      }\n      b = data[seiPtr++];\n      payloadSize += b;\n    } while (b === 0xff);\n    const leftOver = data.length - seiPtr;\n    // Create a variable to process the payload\n    let payPtr = seiPtr;\n\n    // Increment the seiPtr to the end of the payload\n    if (payloadSize < leftOver) {\n      seiPtr += payloadSize;\n    } else if (payloadSize > leftOver) {\n      // Some type of corruption has happened?\n      logger.error(`Malformed SEI payload. ${payloadSize} is too small, only ${leftOver} bytes left to parse.`);\n      // We might be able to parse some data, but let's be safe and ignore it.\n      break;\n    }\n    if (payloadType === 4) {\n      const countryCode = data[payPtr++];\n      if (countryCode === 181) {\n        const providerCode = readUint16(data, payPtr);\n        payPtr += 2;\n        if (providerCode === 49) {\n          const userStructure = readUint32(data, payPtr);\n          payPtr += 4;\n          if (userStructure === 0x47413934) {\n            const userDataType = data[payPtr++];\n\n            // Raw CEA-608 bytes wrapped in CEA-708 packet\n            if (userDataType === 3) {\n              const firstByte = data[payPtr++];\n              const totalCCs = 0x1f & firstByte;\n              const enabled = 0x40 & firstByte;\n              const totalBytes = enabled ? 2 + totalCCs * 3 : 0;\n              const byteArray = new Uint8Array(totalBytes);\n              if (enabled) {\n                byteArray[0] = firstByte;\n                for (let i = 1; i < totalBytes; i++) {\n                  byteArray[i] = data[payPtr++];\n                }\n              }\n              samples.push({\n                type: userDataType,\n                payloadType,\n                pts,\n                bytes: byteArray\n              });\n            }\n          }\n        }\n      }\n    } else if (payloadType === 5) {\n      if (payloadSize > 16) {\n        const uuidStrArray = [];\n        for (let i = 0; i < 16; i++) {\n          const _b = data[payPtr++].toString(16);\n          uuidStrArray.push(_b.length == 1 ? '0' + _b : _b);\n          if (i === 3 || i === 5 || i === 7 || i === 9) {\n            uuidStrArray.push('-');\n          }\n        }\n        const length = payloadSize - 16;\n        const userDataBytes = new Uint8Array(length);\n        for (let i = 0; i < length; i++) {\n          userDataBytes[i] = data[payPtr++];\n        }\n        samples.push({\n          payloadType,\n          pts,\n          uuid: uuidStrArray.join(''),\n          userData: utf8ArrayToStr(userDataBytes),\n          userDataBytes\n        });\n      }\n    }\n  }\n}\n\n/**\n * remove Emulation Prevention bytes from a RBSP\n */\nfunction discardEPB(data) {\n  const length = data.byteLength;\n  const EPBPositions = [];\n  let i = 1;\n\n  // Find all `Emulation Prevention Bytes`\n  while (i < length - 2) {\n    if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n      EPBPositions.push(i + 2);\n      i += 2;\n    } else {\n      i++;\n    }\n  }\n\n  // If no Emulation Prevention Bytes were found just return the original\n  // array\n  if (EPBPositions.length === 0) {\n    return data;\n  }\n\n  // Create a new array to hold the NAL unit data\n  const newLength = length - EPBPositions.length;\n  const newData = new Uint8Array(newLength);\n  let sourceIndex = 0;\n  for (i = 0; i < newLength; sourceIndex++, i++) {\n    if (sourceIndex === EPBPositions[0]) {\n      // Skip this byte\n      sourceIndex++;\n      // Remove this position index\n      EPBPositions.shift();\n    }\n    newData[i] = data[sourceIndex];\n  }\n  return newData;\n}\nfunction parseEmsg(data) {\n  const version = data[0];\n  let schemeIdUri = '';\n  let value = '';\n  let timeScale = 0;\n  let presentationTimeDelta = 0;\n  let presentationTime = 0;\n  let eventDuration = 0;\n  let id = 0;\n  let offset = 0;\n  if (version === 0) {\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n      schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n    schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n    offset += 1;\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n      value += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n    value += bin2str(data.subarray(offset, offset + 1));\n    offset += 1;\n    timeScale = readUint32(data, 12);\n    presentationTimeDelta = readUint32(data, 16);\n    eventDuration = readUint32(data, 20);\n    id = readUint32(data, 24);\n    offset = 28;\n  } else if (version === 1) {\n    offset += 4;\n    timeScale = readUint32(data, offset);\n    offset += 4;\n    const leftPresentationTime = readUint32(data, offset);\n    offset += 4;\n    const rightPresentationTime = readUint32(data, offset);\n    offset += 4;\n    presentationTime = 2 ** 32 * leftPresentationTime + rightPresentationTime;\n    if (!isSafeInteger(presentationTime)) {\n      presentationTime = Number.MAX_SAFE_INTEGER;\n      logger.warn('Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box');\n    }\n    eventDuration = readUint32(data, offset);\n    offset += 4;\n    id = readUint32(data, offset);\n    offset += 4;\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n      schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n    schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n    offset += 1;\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n      value += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n    value += bin2str(data.subarray(offset, offset + 1));\n    offset += 1;\n  }\n  const payload = data.subarray(offset, data.byteLength);\n  return {\n    schemeIdUri,\n    value,\n    timeScale,\n    presentationTime,\n    presentationTimeDelta,\n    eventDuration,\n    id,\n    payload\n  };\n}\nfunction mp4Box(type, ...payload) {\n  const len = payload.length;\n  let size = 8;\n  let i = len;\n  while (i--) {\n    size += payload[i].byteLength;\n  }\n  const result = new Uint8Array(size);\n  result[0] = size >> 24 & 0xff;\n  result[1] = size >> 16 & 0xff;\n  result[2] = size >> 8 & 0xff;\n  result[3] = size & 0xff;\n  result.set(type, 4);\n  for (i = 0, size = 8; i < len; i++) {\n    result.set(payload[i], size);\n    size += payload[i].byteLength;\n  }\n  return result;\n}\nfunction mp4pssh(systemId, keyids, data) {\n  if (systemId.byteLength !== 16) {\n    throw new RangeError('Invalid system id');\n  }\n  let version;\n  let kids;\n  {\n    version = 0;\n    kids = new Uint8Array();\n  }\n  let kidCount;\n  if (version > 0) {\n    kidCount = new Uint8Array(4);\n    if (keyids.length > 0) {\n      new DataView(kidCount.buffer).setUint32(0, keyids.length, false);\n    }\n  } else {\n    kidCount = new Uint8Array();\n  }\n  const dataSize = new Uint8Array(4);\n  if (data && data.byteLength > 0) {\n    new DataView(dataSize.buffer).setUint32(0, data.byteLength, false);\n  }\n  return mp4Box([112, 115, 115, 104], new Uint8Array([version, 0x00, 0x00, 0x00 // Flags\n  ]), systemId,\n  // 16 bytes\n  kidCount, kids, dataSize, data || new Uint8Array());\n}\n\nconst userAgentHevcSupportIsInaccurate = () => {\n  return /\\(Windows.+Firefox\\//i.test(navigator.userAgent);\n};\n\n// from http://mp4ra.org/codecs.html\n// values indicate codec selection preference (lower is higher priority)\nconst sampleEntryCodesISO = {\n  audio: {\n    a3ds: 1,\n    'ac-3': 0.95,\n    'ac-4': 1,\n    alac: 0.9,\n    alaw: 1,\n    dra1: 1,\n    'dts+': 1,\n    'dts-': 1,\n    dtsc: 1,\n    dtse: 1,\n    dtsh: 1,\n    'ec-3': 0.9,\n    enca: 1,\n    fLaC: 0.9,\n    // MP4-RA listed codec entry for FLAC\n    flac: 0.9,\n    // legacy browser codec name for FLAC\n    FLAC: 0.9,\n    // some manifests may list \"FLAC\" with Apple's tools\n    g719: 1,\n    g726: 1,\n    m4ae: 1,\n    mha1: 1,\n    mha2: 1,\n    mhm1: 1,\n    mhm2: 1,\n    mlpa: 1,\n    mp4a: 1,\n    'raw ': 1,\n    Opus: 1,\n    opus: 1,\n    // browsers expect this to be lowercase despite MP4RA says 'Opus'\n    samr: 1,\n    sawb: 1,\n    sawp: 1,\n    sevc: 1,\n    sqcp: 1,\n    ssmv: 1,\n    twos: 1,\n    ulaw: 1\n  },\n  video: {\n    avc1: 1,\n    avc2: 1,\n    avc3: 1,\n    avc4: 1,\n    avcp: 1,\n    av01: 0.8,\n    dav1: 0.8,\n    drac: 1,\n    dva1: 1,\n    dvav: 1,\n    dvh1: 0.7,\n    dvhe: 0.7,\n    encv: 1,\n    hev1: 0.75,\n    hvc1: 0.75,\n    mjp2: 1,\n    mp4v: 1,\n    mvc1: 1,\n    mvc2: 1,\n    mvc3: 1,\n    mvc4: 1,\n    resv: 1,\n    rv60: 1,\n    s263: 1,\n    svc1: 1,\n    svc2: 1,\n    'vc-1': 1,\n    vp08: 1,\n    vp09: 0.9\n  },\n  text: {\n    stpp: 1,\n    wvtt: 1\n  }\n};\nfunction isCodecType(codec, type) {\n  const typeCodes = sampleEntryCodesISO[type];\n  return !!typeCodes && !!typeCodes[codec.slice(0, 4)];\n}\nfunction areCodecsMediaSourceSupported(codecs, type, preferManagedMediaSource = true) {\n  return !codecs.split(',').some(codec => !isCodecMediaSourceSupported(codec, type, preferManagedMediaSource));\n}\nfunction isCodecMediaSourceSupported(codec, type, preferManagedMediaSource = true) {\n  var _MediaSource$isTypeSu;\n  const MediaSource = getMediaSource(preferManagedMediaSource);\n  return (_MediaSource$isTypeSu = MediaSource == null ? void 0 : MediaSource.isTypeSupported(mimeTypeForCodec(codec, type))) != null ? _MediaSource$isTypeSu : false;\n}\nfunction mimeTypeForCodec(codec, type) {\n  return `${type}/mp4;codecs=${codec}`;\n}\nfunction videoCodecPreferenceValue(videoCodec) {\n  if (videoCodec) {\n    const fourCC = videoCodec.substring(0, 4);\n    return sampleEntryCodesISO.video[fourCC];\n  }\n  return 2;\n}\nfunction codecsSetSelectionPreferenceValue(codecSet) {\n  const limitedHevcSupport = userAgentHevcSupportIsInaccurate();\n  return codecSet.split(',').reduce((num, fourCC) => {\n    const lowerPriority = limitedHevcSupport && isHEVC(fourCC);\n    const preferenceValue = lowerPriority ? 9 : sampleEntryCodesISO.video[fourCC];\n    if (preferenceValue) {\n      return (preferenceValue * 2 + num) / (num ? 3 : 2);\n    }\n    return (sampleEntryCodesISO.audio[fourCC] + num) / (num ? 2 : 1);\n  }, 0);\n}\nconst CODEC_COMPATIBLE_NAMES = {};\nfunction getCodecCompatibleNameLower(lowerCaseCodec, preferManagedMediaSource = true) {\n  if (CODEC_COMPATIBLE_NAMES[lowerCaseCodec]) {\n    return CODEC_COMPATIBLE_NAMES[lowerCaseCodec];\n  }\n  const codecsToCheck = {\n    // Idealy fLaC and Opus would be first (spec-compliant) but\n    // some browsers will report that fLaC is supported then fail.\n    // see: https://bugs.chromium.org/p/chromium/issues/detail?id=1422728\n    flac: ['flac', 'fLaC', 'FLAC'],\n    opus: ['opus', 'Opus'],\n    // Replace audio codec info if browser does not support mp4a.40.34,\n    // and demuxer can fallback to 'audio/mpeg' or 'audio/mp4;codecs=\"mp3\"'\n    'mp4a.40.34': ['mp3']\n  }[lowerCaseCodec];\n  for (let i = 0; i < codecsToCheck.length; i++) {\n    var _getMediaSource;\n    if (isCodecMediaSourceSupported(codecsToCheck[i], 'audio', preferManagedMediaSource)) {\n      CODEC_COMPATIBLE_NAMES[lowerCaseCodec] = codecsToCheck[i];\n      return codecsToCheck[i];\n    } else if (codecsToCheck[i] === 'mp3' && (_getMediaSource = getMediaSource(preferManagedMediaSource)) != null && _getMediaSource.isTypeSupported('audio/mpeg')) {\n      return '';\n    }\n  }\n  return lowerCaseCodec;\n}\nconst AUDIO_CODEC_REGEXP = /flac|opus|mp4a\\.40\\.34/i;\nfunction getCodecCompatibleName(codec, preferManagedMediaSource = true) {\n  return codec.replace(AUDIO_CODEC_REGEXP, m => getCodecCompatibleNameLower(m.toLowerCase(), preferManagedMediaSource));\n}\nfunction replaceVideoCodec(originalCodecs, newVideoCodec) {\n  const codecs = [];\n  if (originalCodecs) {\n    const allCodecs = originalCodecs.split(',');\n    for (let i = 0; i < allCodecs.length; i++) {\n      if (!isCodecType(allCodecs[i], 'video')) {\n        codecs.push(allCodecs[i]);\n      }\n    }\n  }\n  if (newVideoCodec) {\n    codecs.push(newVideoCodec);\n  }\n  return codecs.join(',');\n}\nfunction pickMostCompleteCodecName(parsedCodec, levelCodec) {\n  // Parsing of mp4a codecs strings in mp4-tools from media is incomplete as of d8c6c7a\n  // so use level codec is parsed codec is unavailable or incomplete\n  if (parsedCodec && (parsedCodec.length > 4 || ['ac-3', 'ec-3', 'alac', 'fLaC', 'Opus'].indexOf(parsedCodec) !== -1)) {\n    if (isCodecSupportedAsType(parsedCodec, 'audio') || isCodecSupportedAsType(parsedCodec, 'video')) {\n      return parsedCodec;\n    }\n  }\n  if (levelCodec) {\n    const levelCodecs = levelCodec.split(',');\n    if (levelCodecs.length > 1) {\n      if (parsedCodec) {\n        for (let i = levelCodecs.length; i--;) {\n          if (levelCodecs[i].substring(0, 4) === parsedCodec.substring(0, 4)) {\n            return levelCodecs[i];\n          }\n        }\n      }\n      return levelCodecs[0];\n    }\n  }\n  return levelCodec || parsedCodec;\n}\nfunction isCodecSupportedAsType(codec, type) {\n  return isCodecType(codec, type) && isCodecMediaSourceSupported(codec, type);\n}\nfunction convertAVC1ToAVCOTI(videoCodecs) {\n  // Convert avc1 codec string from RFC-4281 to RFC-6381 for MediaSource.isTypeSupported\n  // Examples: avc1.66.30 to avc1.42001e and avc1.77.30,avc1.66.30 to avc1.4d001e,avc1.42001e.\n  const codecs = videoCodecs.split(',');\n  for (let i = 0; i < codecs.length; i++) {\n    const avcdata = codecs[i].split('.');\n    // only convert codec strings starting with avc1 (Examples: avc1.64001f,dvh1.05.07)\n    if (avcdata.length > 2 && avcdata[0] === 'avc1') {\n      codecs[i] = `avc1.${parseInt(avcdata[1]).toString(16)}${('000' + parseInt(avcdata[2]).toString(16)).slice(-4)}`;\n    }\n  }\n  return codecs.join(',');\n}\nfunction fillInMissingAV01Params(videoCodec) {\n  // Used to fill in incomplete AV1 playlist CODECS strings for mediaCapabilities.decodingInfo queries\n  if (videoCodec.startsWith('av01.')) {\n    const av1params = videoCodec.split('.');\n    const placeholders = ['0', '111', '01', '01', '01', '0'];\n    for (let i = av1params.length; i > 4 && i < 10; i++) {\n      av1params[i] = placeholders[i - 4];\n    }\n    return av1params.join('.');\n  }\n  return videoCodec;\n}\nfunction getM2TSSupportedAudioTypes(preferManagedMediaSource) {\n  const MediaSource = getMediaSource(preferManagedMediaSource) || {\n    isTypeSupported: () => false\n  };\n  return {\n    mpeg: MediaSource.isTypeSupported('audio/mpeg'),\n    mp3: MediaSource.isTypeSupported('audio/mp4; codecs=\"mp3\"'),\n    ac3: MediaSource.isTypeSupported('audio/mp4; codecs=\"ac-3\"') \n  };\n}\nfunction getCodecsForMimeType(mimeType) {\n  return mimeType.replace(/^.+codecs=[\"']?([^\"']+).*$/, '$1');\n}\n\nconst SUPPORTED_INFO_DEFAULT = {\n  supported: true,\n  configurations: [],\n  decodingInfoResults: [{\n    supported: true,\n    powerEfficient: true,\n    smooth: true\n  }]\n};\nfunction getUnsupportedResult(error, configurations) {\n  return {\n    supported: false,\n    configurations,\n    decodingInfoResults: [{\n      supported: false,\n      smooth: false,\n      powerEfficient: false\n    }],\n    error\n  };\n}\nfunction requiresMediaCapabilitiesDecodingInfo(level, audioTracksByGroup, currentVideoRange, currentFrameRate, currentBw, audioPreference) {\n  // Only test support when configuration is exceeds minimum options\n  const videoCodecs = level.videoCodec;\n  const audioGroups = level.audioCodec ? level.audioGroups : null;\n  const audioCodecPreference = audioPreference == null ? void 0 : audioPreference.audioCodec;\n  const channelsPreference = audioPreference == null ? void 0 : audioPreference.channels;\n  const maxChannels = channelsPreference ? parseInt(channelsPreference) : audioCodecPreference ? Infinity : 2;\n  let audioChannels = null;\n  if (audioGroups != null && audioGroups.length) {\n    try {\n      if (audioGroups.length === 1 && audioGroups[0]) {\n        audioChannels = audioTracksByGroup.groups[audioGroups[0]].channels;\n      } else {\n        audioChannels = audioGroups.reduce((acc, groupId) => {\n          if (groupId) {\n            const audioTrackGroup = audioTracksByGroup.groups[groupId];\n            if (!audioTrackGroup) {\n              throw new Error(`Audio track group ${groupId} not found`);\n            }\n            // Sum all channel key values\n            Object.keys(audioTrackGroup.channels).forEach(key => {\n              acc[key] = (acc[key] || 0) + audioTrackGroup.channels[key];\n            });\n          }\n          return acc;\n        }, {\n          2: 0\n        });\n      }\n    } catch (error) {\n      return true;\n    }\n  }\n  return videoCodecs !== undefined && (\n  // Force media capabilities check for HEVC to avoid failure on Windows\n  videoCodecs.split(',').some(videoCodec => isHEVC(videoCodec)) || level.width > 1920 && level.height > 1088 || level.height > 1920 && level.width > 1088 || level.frameRate > Math.max(currentFrameRate, 30) || level.videoRange !== 'SDR' && level.videoRange !== currentVideoRange || level.bitrate > Math.max(currentBw, 8e6)) || !!audioChannels && isFiniteNumber(maxChannels) && Object.keys(audioChannels).some(channels => parseInt(channels) > maxChannels);\n}\nfunction getMediaDecodingInfoPromise(level, audioTracksByGroup, mediaCapabilities, cache = {}) {\n  const videoCodecs = level.videoCodec;\n  if (!videoCodecs && !level.audioCodec || !mediaCapabilities) {\n    return Promise.resolve(SUPPORTED_INFO_DEFAULT);\n  }\n  const configurations = [];\n  const videoDecodeList = makeVideoConfigurations(level);\n  const videoCount = videoDecodeList.length;\n  const audioDecodeList = makeAudioConfigurations(level, audioTracksByGroup, videoCount > 0);\n  const audioCount = audioDecodeList.length;\n  for (let i = videoCount || 1 * audioCount || 1; i--;) {\n    const configuration = {\n      type: 'media-source'\n    };\n    if (videoCount) {\n      configuration.video = videoDecodeList[i % videoCount];\n    }\n    if (audioCount) {\n      configuration.audio = audioDecodeList[i % audioCount];\n      const audioBitrate = configuration.audio.bitrate;\n      if (configuration.video && audioBitrate) {\n        configuration.video.bitrate -= audioBitrate;\n      }\n    }\n    configurations.push(configuration);\n  }\n  if (videoCodecs) {\n    // Override Windows Firefox HEVC MediaCapabilities result (https://github.com/video-dev/hls.js/issues/7046)\n    const ua = navigator.userAgent;\n    if (videoCodecs.split(',').some(videoCodec => isHEVC(videoCodec)) && userAgentHevcSupportIsInaccurate()) {\n      return Promise.resolve(getUnsupportedResult(new Error(`Overriding Windows Firefox HEVC MediaCapabilities result based on user-agent string: (${ua})`), configurations));\n    }\n  }\n  return Promise.all(configurations.map(configuration => {\n    // Cache MediaCapabilities promises\n    const decodingInfoKey = getMediaDecodingInfoKey(configuration);\n    return cache[decodingInfoKey] || (cache[decodingInfoKey] = mediaCapabilities.decodingInfo(configuration));\n  })).then(decodingInfoResults => ({\n    supported: !decodingInfoResults.some(info => !info.supported),\n    configurations,\n    decodingInfoResults\n  })).catch(error => ({\n    supported: false,\n    configurations,\n    decodingInfoResults: [],\n    error\n  }));\n}\nfunction makeVideoConfigurations(level) {\n  var _level$videoCodec;\n  const videoCodecs = (_level$videoCodec = level.videoCodec) == null ? void 0 : _level$videoCodec.split(',');\n  const bitrate = getVariantDecodingBitrate(level);\n  const width = level.width || 640;\n  const height = level.height || 480;\n  // Assume a framerate of 30fps since MediaCapabilities will not accept Level default of 0.\n  const framerate = level.frameRate || 30;\n  const videoRange = level.videoRange.toLowerCase();\n  return videoCodecs ? videoCodecs.map(videoCodec => {\n    const videoConfiguration = {\n      contentType: mimeTypeForCodec(fillInMissingAV01Params(videoCodec), 'video'),\n      width,\n      height,\n      bitrate,\n      framerate\n    };\n    if (videoRange !== 'sdr') {\n      videoConfiguration.transferFunction = videoRange;\n    }\n    return videoConfiguration;\n  }) : [];\n}\nfunction makeAudioConfigurations(level, audioTracksByGroup, hasVideo) {\n  var _level$audioCodec;\n  const audioCodecs = (_level$audioCodec = level.audioCodec) == null ? void 0 : _level$audioCodec.split(',');\n  const combinedBitrate = getVariantDecodingBitrate(level);\n  if (audioCodecs && level.audioGroups) {\n    return level.audioGroups.reduce((configurations, audioGroupId) => {\n      var _audioTracksByGroup$g;\n      const tracks = audioGroupId ? (_audioTracksByGroup$g = audioTracksByGroup.groups[audioGroupId]) == null ? void 0 : _audioTracksByGroup$g.tracks : null;\n      if (tracks) {\n        return tracks.reduce((configs, audioTrack) => {\n          if (audioTrack.groupId === audioGroupId) {\n            const channelsNumber = parseFloat(audioTrack.channels || '');\n            audioCodecs.forEach(audioCodec => {\n              const audioConfiguration = {\n                contentType: mimeTypeForCodec(audioCodec, 'audio'),\n                bitrate: hasVideo ? estimatedAudioBitrate(audioCodec, combinedBitrate) : combinedBitrate\n              };\n              if (channelsNumber) {\n                audioConfiguration.channels = '' + channelsNumber;\n              }\n              configs.push(audioConfiguration);\n            });\n          }\n          return configs;\n        }, configurations);\n      }\n      return configurations;\n    }, []);\n  }\n  return [];\n}\nfunction estimatedAudioBitrate(audioCodec, levelBitrate) {\n  if (levelBitrate <= 1) {\n    return 1;\n  }\n  let audioBitrate = 128000;\n  if (audioCodec === 'ec-3') {\n    audioBitrate = 768000;\n  } else if (audioCodec === 'ac-3') {\n    audioBitrate = 640000;\n  }\n  return Math.min(levelBitrate / 2, audioBitrate); // Don't exceed some % of level bitrate\n}\nfunction getVariantDecodingBitrate(level) {\n  return Math.ceil(Math.max(level.bitrate * 0.9, level.averageBitrate) / 1000) * 1000 || 1;\n}\nfunction getMediaDecodingInfoKey(config) {\n  let key = '';\n  const {\n    audio,\n    video\n  } = config;\n  if (video) {\n    const codec = getCodecsForMimeType(video.contentType);\n    key += `${codec}_r${video.height}x${video.width}f${Math.ceil(video.framerate)}${video.transferFunction || 'sd'}_${Math.ceil(video.bitrate / 1e5)}`;\n  }\n  if (audio) {\n    const codec = getCodecsForMimeType(audio.contentType);\n    key += `${video ? '_' : ''}${codec}_c${audio.channels}`;\n  }\n  return key;\n}\n\nconst HdcpLevels = ['NONE', 'TYPE-0', 'TYPE-1', null];\nfunction isHdcpLevel(value) {\n  return HdcpLevels.indexOf(value) > -1;\n}\nconst VideoRangeValues = ['SDR', 'PQ', 'HLG'];\nfunction isVideoRange(value) {\n  return !!value && VideoRangeValues.indexOf(value) > -1;\n}\nvar HlsSkip = {\n  No: \"\",\n  Yes: \"YES\",\n  v2: \"v2\"\n};\nfunction getSkipValue(details) {\n  const {\n    canSkipUntil,\n    canSkipDateRanges,\n    age\n  } = details;\n  // A Client SHOULD NOT request a Playlist Delta Update unless it already\n  // has a version of the Playlist that is no older than one-half of the Skip Boundary.\n  // @see: https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis#section-6.3.7\n  const playlistRecentEnough = age < canSkipUntil / 2;\n  if (canSkipUntil && playlistRecentEnough) {\n    if (canSkipDateRanges) {\n      return HlsSkip.v2;\n    }\n    return HlsSkip.Yes;\n  }\n  return HlsSkip.No;\n}\nclass HlsUrlParameters {\n  constructor(msn, part, skip) {\n    this.msn = void 0;\n    this.part = void 0;\n    this.skip = void 0;\n    this.msn = msn;\n    this.part = part;\n    this.skip = skip;\n  }\n  addDirectives(uri) {\n    const url = new self.URL(uri);\n    if (this.msn !== undefined) {\n      url.searchParams.set('_HLS_msn', this.msn.toString());\n    }\n    if (this.part !== undefined) {\n      url.searchParams.set('_HLS_part', this.part.toString());\n    }\n    if (this.skip) {\n      url.searchParams.set('_HLS_skip', this.skip);\n    }\n    return url.href;\n  }\n}\nclass Level {\n  constructor(data) {\n    this._attrs = void 0;\n    this.audioCodec = void 0;\n    this.bitrate = void 0;\n    this.codecSet = void 0;\n    this.url = void 0;\n    this.frameRate = void 0;\n    this.height = void 0;\n    this.id = void 0;\n    this.name = void 0;\n    this.supplemental = void 0;\n    this.videoCodec = void 0;\n    this.width = void 0;\n    this.details = void 0;\n    this.fragmentError = 0;\n    this.loadError = 0;\n    this.loaded = void 0;\n    this.realBitrate = 0;\n    this.supportedPromise = void 0;\n    this.supportedResult = void 0;\n    this._avgBitrate = 0;\n    this._audioGroups = void 0;\n    this._subtitleGroups = void 0;\n    // Deprecated (retained for backwards compatibility)\n    this._urlId = 0;\n    this.url = [data.url];\n    this._attrs = [data.attrs];\n    this.bitrate = data.bitrate;\n    if (data.details) {\n      this.details = data.details;\n    }\n    this.id = data.id || 0;\n    this.name = data.name;\n    this.width = data.width || 0;\n    this.height = data.height || 0;\n    this.frameRate = data.attrs.optionalFloat('FRAME-RATE', 0);\n    this._avgBitrate = data.attrs.decimalInteger('AVERAGE-BANDWIDTH');\n    this.audioCodec = data.audioCodec;\n    this.videoCodec = data.videoCodec;\n    this.codecSet = [data.videoCodec, data.audioCodec].filter(c => !!c).map(s => s.substring(0, 4)).join(',');\n    if ('supplemental' in data) {\n      var _data$supplemental;\n      this.supplemental = data.supplemental;\n      const supplementalVideo = (_data$supplemental = data.supplemental) == null ? void 0 : _data$supplemental.videoCodec;\n      if (supplementalVideo && supplementalVideo !== data.videoCodec) {\n        this.codecSet += `,${supplementalVideo.substring(0, 4)}`;\n      }\n    }\n    this.addGroupId('audio', data.attrs.AUDIO);\n    this.addGroupId('text', data.attrs.SUBTITLES);\n  }\n  get maxBitrate() {\n    return Math.max(this.realBitrate, this.bitrate);\n  }\n  get averageBitrate() {\n    return this._avgBitrate || this.realBitrate || this.bitrate;\n  }\n  get attrs() {\n    return this._attrs[0];\n  }\n  get codecs() {\n    return this.attrs.CODECS || '';\n  }\n  get pathwayId() {\n    return this.attrs['PATHWAY-ID'] || '.';\n  }\n  get videoRange() {\n    return this.attrs['VIDEO-RANGE'] || 'SDR';\n  }\n  get score() {\n    return this.attrs.optionalFloat('SCORE', 0);\n  }\n  get uri() {\n    return this.url[0] || '';\n  }\n  hasAudioGroup(groupId) {\n    return hasGroup(this._audioGroups, groupId);\n  }\n  hasSubtitleGroup(groupId) {\n    return hasGroup(this._subtitleGroups, groupId);\n  }\n  get audioGroups() {\n    return this._audioGroups;\n  }\n  get subtitleGroups() {\n    return this._subtitleGroups;\n  }\n  addGroupId(type, groupId) {\n    if (!groupId) {\n      return;\n    }\n    if (type === 'audio') {\n      let audioGroups = this._audioGroups;\n      if (!audioGroups) {\n        audioGroups = this._audioGroups = [];\n      }\n      if (audioGroups.indexOf(groupId) === -1) {\n        audioGroups.push(groupId);\n      }\n    } else if (type === 'text') {\n      let subtitleGroups = this._subtitleGroups;\n      if (!subtitleGroups) {\n        subtitleGroups = this._subtitleGroups = [];\n      }\n      if (subtitleGroups.indexOf(groupId) === -1) {\n        subtitleGroups.push(groupId);\n      }\n    }\n  }\n\n  // Deprecated methods (retained for backwards compatibility)\n  get urlId() {\n    return 0;\n  }\n  set urlId(value) {}\n  get audioGroupIds() {\n    return this.audioGroups ? [this.audioGroupId] : undefined;\n  }\n  get textGroupIds() {\n    return this.subtitleGroups ? [this.textGroupId] : undefined;\n  }\n  get audioGroupId() {\n    var _this$audioGroups;\n    return (_this$audioGroups = this.audioGroups) == null ? void 0 : _this$audioGroups[0];\n  }\n  get textGroupId() {\n    var _this$subtitleGroups;\n    return (_this$subtitleGroups = this.subtitleGroups) == null ? void 0 : _this$subtitleGroups[0];\n  }\n  addFallback() {}\n}\nfunction hasGroup(groups, groupId) {\n  if (!groupId || !groups) {\n    return false;\n  }\n  return groups.indexOf(groupId) !== -1;\n}\n\n/**\n * @returns Whether we can detect and validate HDR capability within the window context\n */\nfunction isHdrSupported() {\n  if (typeof matchMedia === 'function') {\n    const mediaQueryList = matchMedia('(dynamic-range: high)');\n    const badQuery = matchMedia('bad query');\n    if (mediaQueryList.media !== badQuery.media) {\n      return mediaQueryList.matches === true;\n    }\n  }\n  return false;\n}\n\n/**\n * Sanitizes inputs to return the active video selection options for HDR/SDR.\n * When both inputs are null:\n *\n *    `{ preferHDR: false, allowedVideoRanges: [] }`\n *\n * When `currentVideoRange` non-null, maintain the active range:\n *\n *    `{ preferHDR: currentVideoRange !== 'SDR', allowedVideoRanges: [currentVideoRange] }`\n *\n * When VideoSelectionOption non-null:\n *\n *  - Allow all video ranges if `allowedVideoRanges` unspecified.\n *  - If `preferHDR` is non-null use the value to filter `allowedVideoRanges`.\n *  - Else check window for HDR support and set `preferHDR` to the result.\n *\n * @param currentVideoRange\n * @param videoPreference\n */\nfunction getVideoSelectionOptions(currentVideoRange, videoPreference) {\n  let preferHDR = false;\n  let allowedVideoRanges = [];\n  if (currentVideoRange) {\n    preferHDR = currentVideoRange !== 'SDR';\n    allowedVideoRanges = [currentVideoRange];\n  }\n  if (videoPreference) {\n    allowedVideoRanges = videoPreference.allowedVideoRanges || VideoRangeValues.slice(0);\n    const allowAutoPreferHDR = allowedVideoRanges.join('') !== 'SDR' && !videoPreference.videoCodec;\n    preferHDR = videoPreference.preferHDR !== undefined ? videoPreference.preferHDR : allowAutoPreferHDR && isHdrSupported();\n    if (!preferHDR) {\n      allowedVideoRanges = ['SDR'];\n    }\n  }\n  return {\n    preferHDR,\n    allowedVideoRanges\n  };\n}\n\nconst omitCircularRefsReplacer = replacer => {\n  const known = new WeakSet();\n  return (_, value) => {\n    if (replacer) {\n      value = replacer(_, value);\n    }\n    if (typeof value === 'object' && value !== null) {\n      if (known.has(value)) {\n        return;\n      }\n      known.add(value);\n    }\n    return value;\n  };\n};\nconst stringify = (object, replacer) => JSON.stringify(object, omitCircularRefsReplacer(replacer));\n\nfunction getStartCodecTier(codecTiers, currentVideoRange, currentBw, audioPreference, videoPreference) {\n  const codecSets = Object.keys(codecTiers);\n  const channelsPreference = audioPreference == null ? void 0 : audioPreference.channels;\n  const audioCodecPreference = audioPreference == null ? void 0 : audioPreference.audioCodec;\n  const videoCodecPreference = videoPreference == null ? void 0 : videoPreference.videoCodec;\n  const preferStereo = channelsPreference && parseInt(channelsPreference) === 2;\n  // Use first level set to determine stereo, and minimum resolution and framerate\n  let hasStereo = false;\n  let hasCurrentVideoRange = false;\n  let minHeight = Infinity;\n  let minFramerate = Infinity;\n  let minBitrate = Infinity;\n  let minIndex = Infinity;\n  let selectedScore = 0;\n  let videoRanges = [];\n  const {\n    preferHDR,\n    allowedVideoRanges\n  } = getVideoSelectionOptions(currentVideoRange, videoPreference);\n  for (let i = codecSets.length; i--;) {\n    const tier = codecTiers[codecSets[i]];\n    hasStereo || (hasStereo = tier.channels[2] > 0);\n    minHeight = Math.min(minHeight, tier.minHeight);\n    minFramerate = Math.min(minFramerate, tier.minFramerate);\n    minBitrate = Math.min(minBitrate, tier.minBitrate);\n    const matchingVideoRanges = allowedVideoRanges.filter(range => tier.videoRanges[range] > 0);\n    if (matchingVideoRanges.length > 0) {\n      hasCurrentVideoRange = true;\n    }\n  }\n  minHeight = isFiniteNumber(minHeight) ? minHeight : 0;\n  minFramerate = isFiniteNumber(minFramerate) ? minFramerate : 0;\n  const maxHeight = Math.max(1080, minHeight);\n  const maxFramerate = Math.max(30, minFramerate);\n  minBitrate = isFiniteNumber(minBitrate) ? minBitrate : currentBw;\n  currentBw = Math.max(minBitrate, currentBw);\n  // If there are no variants with matching preference, set currentVideoRange to undefined\n  if (!hasCurrentVideoRange) {\n    currentVideoRange = undefined;\n  }\n  const hasMultipleSets = codecSets.length > 1;\n  const codecSet = codecSets.reduce((selected, candidate) => {\n    // Remove candiates which do not meet bitrate, default audio, stereo or channels preference, 1080p or lower, 30fps or lower, or SDR/HDR selection if present\n    const candidateTier = codecTiers[candidate];\n    if (candidate === selected) {\n      return selected;\n    }\n    videoRanges = hasCurrentVideoRange ? allowedVideoRanges.filter(range => candidateTier.videoRanges[range] > 0) : [];\n    if (hasMultipleSets) {\n      if (candidateTier.minBitrate > currentBw) {\n        logStartCodecCandidateIgnored(candidate, `min bitrate of ${candidateTier.minBitrate} > current estimate of ${currentBw}`);\n        return selected;\n      }\n      if (!candidateTier.hasDefaultAudio) {\n        logStartCodecCandidateIgnored(candidate, `no renditions with default or auto-select sound found`);\n        return selected;\n      }\n      if (audioCodecPreference && candidate.indexOf(audioCodecPreference.substring(0, 4)) % 5 !== 0) {\n        logStartCodecCandidateIgnored(candidate, `audio codec preference \"${audioCodecPreference}\" not found`);\n        return selected;\n      }\n      if (channelsPreference && !preferStereo) {\n        if (!candidateTier.channels[channelsPreference]) {\n          logStartCodecCandidateIgnored(candidate, `no renditions with ${channelsPreference} channel sound found (channels options: ${Object.keys(candidateTier.channels)})`);\n          return selected;\n        }\n      } else if ((!audioCodecPreference || preferStereo) && hasStereo && candidateTier.channels['2'] === 0) {\n        logStartCodecCandidateIgnored(candidate, `no renditions with stereo sound found`);\n        return selected;\n      }\n      if (candidateTier.minHeight > maxHeight) {\n        logStartCodecCandidateIgnored(candidate, `min resolution of ${candidateTier.minHeight} > maximum of ${maxHeight}`);\n        return selected;\n      }\n      if (candidateTier.minFramerate > maxFramerate) {\n        logStartCodecCandidateIgnored(candidate, `min framerate of ${candidateTier.minFramerate} > maximum of ${maxFramerate}`);\n        return selected;\n      }\n      if (!videoRanges.some(range => candidateTier.videoRanges[range] > 0)) {\n        logStartCodecCandidateIgnored(candidate, `no variants with VIDEO-RANGE of ${stringify(videoRanges)} found`);\n        return selected;\n      }\n      if (videoCodecPreference && candidate.indexOf(videoCodecPreference.substring(0, 4)) % 5 !== 0) {\n        logStartCodecCandidateIgnored(candidate, `video codec preference \"${videoCodecPreference}\" not found`);\n        return selected;\n      }\n      if (candidateTier.maxScore < selectedScore) {\n        logStartCodecCandidateIgnored(candidate, `max score of ${candidateTier.maxScore} < selected max of ${selectedScore}`);\n        return selected;\n      }\n    }\n    // Remove candiates with less preferred codecs or more errors\n    if (selected && (codecsSetSelectionPreferenceValue(candidate) >= codecsSetSelectionPreferenceValue(selected) || candidateTier.fragmentError > codecTiers[selected].fragmentError)) {\n      return selected;\n    }\n    minIndex = candidateTier.minIndex;\n    selectedScore = candidateTier.maxScore;\n    return candidate;\n  }, undefined);\n  return {\n    codecSet,\n    videoRanges,\n    preferHDR,\n    minFramerate,\n    minBitrate,\n    minIndex\n  };\n}\nfunction logStartCodecCandidateIgnored(codeSet, reason) {\n  logger.log(`[abr] start candidates with \"${codeSet}\" ignored because ${reason}`);\n}\nfunction getAudioTracksByGroup(allAudioTracks) {\n  return allAudioTracks.reduce((audioTracksByGroup, track) => {\n    let trackGroup = audioTracksByGroup.groups[track.groupId];\n    if (!trackGroup) {\n      trackGroup = audioTracksByGroup.groups[track.groupId] = {\n        tracks: [],\n        channels: {\n          2: 0\n        },\n        hasDefault: false,\n        hasAutoSelect: false\n      };\n    }\n    trackGroup.tracks.push(track);\n    const channelsKey = track.channels || '2';\n    trackGroup.channels[channelsKey] = (trackGroup.channels[channelsKey] || 0) + 1;\n    trackGroup.hasDefault = trackGroup.hasDefault || track.default;\n    trackGroup.hasAutoSelect = trackGroup.hasAutoSelect || track.autoselect;\n    if (trackGroup.hasDefault) {\n      audioTracksByGroup.hasDefaultAudio = true;\n    }\n    if (trackGroup.hasAutoSelect) {\n      audioTracksByGroup.hasAutoSelectAudio = true;\n    }\n    return audioTracksByGroup;\n  }, {\n    hasDefaultAudio: false,\n    hasAutoSelectAudio: false,\n    groups: {}\n  });\n}\nfunction getCodecTiers(levels, audioTracksByGroup, minAutoLevel, maxAutoLevel) {\n  return levels.slice(minAutoLevel, maxAutoLevel + 1).reduce((tiers, level, index) => {\n    if (!level.codecSet) {\n      return tiers;\n    }\n    const audioGroups = level.audioGroups;\n    let tier = tiers[level.codecSet];\n    if (!tier) {\n      tiers[level.codecSet] = tier = {\n        minBitrate: Infinity,\n        minHeight: Infinity,\n        minFramerate: Infinity,\n        minIndex: index,\n        maxScore: 0,\n        videoRanges: {\n          SDR: 0\n        },\n        channels: {\n          '2': 0\n        },\n        hasDefaultAudio: !audioGroups,\n        fragmentError: 0\n      };\n    }\n    tier.minBitrate = Math.min(tier.minBitrate, level.bitrate);\n    const lesserWidthOrHeight = Math.min(level.height, level.width);\n    tier.minHeight = Math.min(tier.minHeight, lesserWidthOrHeight);\n    tier.minFramerate = Math.min(tier.minFramerate, level.frameRate);\n    tier.minIndex = Math.min(tier.minIndex, index);\n    tier.maxScore = Math.max(tier.maxScore, level.score);\n    tier.fragmentError += level.fragmentError;\n    tier.videoRanges[level.videoRange] = (tier.videoRanges[level.videoRange] || 0) + 1;\n    if (audioGroups) {\n      audioGroups.forEach(audioGroupId => {\n        if (!audioGroupId) {\n          return;\n        }\n        const audioGroup = audioTracksByGroup.groups[audioGroupId];\n        if (!audioGroup) {\n          return;\n        }\n        // Default audio is any group with DEFAULT=YES, or if missing then any group with AUTOSELECT=YES, or all variants\n        tier.hasDefaultAudio = tier.hasDefaultAudio || audioTracksByGroup.hasDefaultAudio ? audioGroup.hasDefault : audioGroup.hasAutoSelect || !audioTracksByGroup.hasDefaultAudio && !audioTracksByGroup.hasAutoSelectAudio;\n        Object.keys(audioGroup.channels).forEach(channels => {\n          tier.channels[channels] = (tier.channels[channels] || 0) + audioGroup.channels[channels];\n        });\n      });\n    }\n    return tiers;\n  }, {});\n}\nfunction getBasicSelectionOption(option) {\n  if (!option) {\n    return option;\n  }\n  const {\n    lang,\n    assocLang,\n    characteristics,\n    channels,\n    audioCodec\n  } = option;\n  return {\n    lang,\n    assocLang,\n    characteristics,\n    channels,\n    audioCodec\n  };\n}\nfunction findMatchingOption(option, tracks, matchPredicate) {\n  if ('attrs' in option) {\n    const index = tracks.indexOf(option);\n    if (index !== -1) {\n      return index;\n    }\n  }\n  for (let i = 0; i < tracks.length; i++) {\n    const track = tracks[i];\n    if (matchesOption(option, track, matchPredicate)) {\n      return i;\n    }\n  }\n  return -1;\n}\nfunction matchesOption(option, track, matchPredicate) {\n  const {\n    groupId,\n    name,\n    lang,\n    assocLang,\n    default: isDefault\n  } = option;\n  const forced = option.forced;\n  return (groupId === undefined || track.groupId === groupId) && (name === undefined || track.name === name) && (lang === undefined || languagesMatch(lang, track.lang)) && (lang === undefined || track.assocLang === assocLang) && (isDefault === undefined || track.default === isDefault) && (forced === undefined || track.forced === forced) && (!('characteristics' in option) || characteristicsMatch(option.characteristics || '', track.characteristics)) && (matchPredicate === undefined || matchPredicate(option, track));\n}\nfunction languagesMatch(languageA, languageB = '--') {\n  if (languageA.length === languageB.length) {\n    return languageA === languageB;\n  }\n  return languageA.startsWith(languageB) || languageB.startsWith(languageA);\n}\nfunction characteristicsMatch(characteristicsA, characteristicsB = '') {\n  const arrA = characteristicsA.split(',');\n  const arrB = characteristicsB.split(',');\n  // Expects each item to be unique:\n  return arrA.length === arrB.length && !arrA.some(el => arrB.indexOf(el) === -1);\n}\nfunction audioMatchPredicate(option, track) {\n  const {\n    audioCodec,\n    channels\n  } = option;\n  return (audioCodec === undefined || (track.audioCodec || '').substring(0, 4) === audioCodec.substring(0, 4)) && (channels === undefined || channels === (track.channels || '2'));\n}\nfunction findClosestLevelWithAudioGroup(option, levels, allAudioTracks, searchIndex, matchPredicate) {\n  const currentLevel = levels[searchIndex];\n  // Are there variants with same URI as current level?\n  // If so, find a match that does not require any level URI change\n  const variants = levels.reduce((variantMap, level, index) => {\n    const uri = level.uri;\n    const renditions = variantMap[uri] || (variantMap[uri] = []);\n    renditions.push(index);\n    return variantMap;\n  }, {});\n  const renditions = variants[currentLevel.uri];\n  if (renditions.length > 1) {\n    searchIndex = Math.max.apply(Math, renditions);\n  }\n  // Find best match\n  const currentVideoRange = currentLevel.videoRange;\n  const currentFrameRate = currentLevel.frameRate;\n  const currentVideoCodec = currentLevel.codecSet.substring(0, 4);\n  const matchingVideo = searchDownAndUpList(levels, searchIndex, level => {\n    if (level.videoRange !== currentVideoRange || level.frameRate !== currentFrameRate || level.codecSet.substring(0, 4) !== currentVideoCodec) {\n      return false;\n    }\n    const audioGroups = level.audioGroups;\n    const tracks = allAudioTracks.filter(track => !audioGroups || audioGroups.indexOf(track.groupId) !== -1);\n    return findMatchingOption(option, tracks, matchPredicate) > -1;\n  });\n  if (matchingVideo > -1) {\n    return matchingVideo;\n  }\n  return searchDownAndUpList(levels, searchIndex, level => {\n    const audioGroups = level.audioGroups;\n    const tracks = allAudioTracks.filter(track => !audioGroups || audioGroups.indexOf(track.groupId) !== -1);\n    return findMatchingOption(option, tracks, matchPredicate) > -1;\n  });\n}\nfunction searchDownAndUpList(arr, searchIndex, predicate) {\n  for (let i = searchIndex; i > -1; i--) {\n    if (predicate(arr[i])) {\n      return i;\n    }\n  }\n  for (let i = searchIndex + 1; i < arr.length; i++) {\n    if (predicate(arr[i])) {\n      return i;\n    }\n  }\n  return -1;\n}\nfunction useAlternateAudio(audioTrackUrl, hls) {\n  var _hls$loadLevelObj;\n  return !!audioTrackUrl && audioTrackUrl !== ((_hls$loadLevelObj = hls.loadLevelObj) == null ? void 0 : _hls$loadLevelObj.uri);\n}\n\nclass AbrController extends Logger {\n  constructor(_hls) {\n    super('abr', _hls.logger);\n    this.hls = void 0;\n    this.lastLevelLoadSec = 0;\n    this.lastLoadedFragLevel = -1;\n    this.firstSelection = -1;\n    this._nextAutoLevel = -1;\n    this.nextAutoLevelKey = '';\n    this.audioTracksByGroup = null;\n    this.codecTiers = null;\n    this.timer = -1;\n    this.fragCurrent = null;\n    this.partCurrent = null;\n    this.bitrateTestDelay = 0;\n    this.rebufferNotice = -1;\n    this.supportedCache = {};\n    this.bwEstimator = void 0;\n    /*\n        This method monitors the download rate of the current fragment, and will downswitch if that fragment will not load\n        quickly enough to prevent underbuffering\n      */\n    this._abandonRulesCheck = levelLoaded => {\n      var _ref;\n      const {\n        fragCurrent: frag,\n        partCurrent: part,\n        hls\n      } = this;\n      const {\n        autoLevelEnabled,\n        media\n      } = hls;\n      if (!frag || !media) {\n        return;\n      }\n      const now = performance.now();\n      const stats = part ? part.stats : frag.stats;\n      const duration = part ? part.duration : frag.duration;\n      const timeLoading = now - stats.loading.start;\n      const minAutoLevel = hls.minAutoLevel;\n      const loadingFragForLevel = frag.level;\n      const currentAutoLevel = this._nextAutoLevel;\n      // If frag loading is aborted, complete, or from lowest level, stop timer and return\n      if (stats.aborted || stats.loaded && stats.loaded === stats.total || loadingFragForLevel <= minAutoLevel) {\n        this.clearTimer();\n        // reset forced auto level value so that next level will be selected\n        this._nextAutoLevel = -1;\n        return;\n      }\n\n      // This check only runs if we're in ABR mode\n      if (!autoLevelEnabled) {\n        return;\n      }\n\n      // Must be loading/loaded a new level or be in a playing state\n      const fragBlockingSwitch = currentAutoLevel > -1 && currentAutoLevel !== loadingFragForLevel;\n      const levelChange = !!levelLoaded || fragBlockingSwitch;\n      if (!levelChange && (media.paused || !media.playbackRate || !media.readyState)) {\n        return;\n      }\n      const bufferInfo = hls.mainForwardBufferInfo;\n      if (!levelChange && bufferInfo === null) {\n        return;\n      }\n      const ttfbEstimate = this.bwEstimator.getEstimateTTFB();\n      const playbackRate = Math.abs(media.playbackRate);\n      // To maintain stable adaptive playback, only begin monitoring frag loading after half or more of its playback duration has passed\n      if (timeLoading <= Math.max(ttfbEstimate, 1000 * (duration / (playbackRate * 2)))) {\n        return;\n      }\n\n      // bufferStarvationDelay is an estimate of the amount time (in seconds) it will take to exhaust the buffer\n      const bufferStarvationDelay = bufferInfo ? bufferInfo.len / playbackRate : 0;\n      const ttfb = stats.loading.first ? stats.loading.first - stats.loading.start : -1;\n      const loadedFirstByte = stats.loaded && ttfb > -1;\n      const bwEstimate = this.getBwEstimate();\n      const levels = hls.levels;\n      const level = levels[loadingFragForLevel];\n      const expectedLen = Math.max(stats.loaded, Math.round(duration * (frag.bitrate || level.averageBitrate) / 8));\n      let timeStreaming = loadedFirstByte ? timeLoading - ttfb : timeLoading;\n      if (timeStreaming < 1 && loadedFirstByte) {\n        timeStreaming = Math.min(timeLoading, stats.loaded * 8 / bwEstimate);\n      }\n      const loadRate = loadedFirstByte ? stats.loaded * 1000 / timeStreaming : 0;\n      // fragLoadDelay is an estimate of the time (in seconds) it will take to buffer the remainder of the fragment\n      const ttfbSeconds = ttfbEstimate / 1000;\n      const fragLoadedDelay = loadRate ? (expectedLen - stats.loaded) / loadRate : expectedLen * 8 / bwEstimate + ttfbSeconds;\n      // Only downswitch if the time to finish loading the current fragment is greater than the amount of buffer left\n      if (fragLoadedDelay <= bufferStarvationDelay) {\n        return;\n      }\n      const bwe = loadRate ? loadRate * 8 : bwEstimate;\n      const live = ((_ref = (levelLoaded == null ? void 0 : levelLoaded.details) || this.hls.latestLevelDetails) == null ? void 0 : _ref.live) === true;\n      const abrBandWidthUpFactor = this.hls.config.abrBandWidthUpFactor;\n      let fragLevelNextLoadedDelay = Number.POSITIVE_INFINITY;\n      let nextLoadLevel;\n      // Iterate through lower level and try to find the largest one that avoids rebuffering\n      for (nextLoadLevel = loadingFragForLevel - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) {\n        // compute time to load next fragment at lower level\n        // 8 = bits per byte (bps/Bps)\n        const levelNextBitrate = levels[nextLoadLevel].maxBitrate;\n        const requiresLevelLoad = !levels[nextLoadLevel].details || live;\n        fragLevelNextLoadedDelay = this.getTimeToLoadFrag(ttfbSeconds, bwe, duration * levelNextBitrate, requiresLevelLoad);\n        if (fragLevelNextLoadedDelay < Math.min(bufferStarvationDelay, duration + ttfbSeconds)) {\n          break;\n        }\n      }\n      // Only emergency switch down if it takes less time to load a new fragment at lowest level instead of continuing\n      // to load the current one\n      if (fragLevelNextLoadedDelay >= fragLoadedDelay) {\n        return;\n      }\n\n      // if estimated load time of new segment is completely unreasonable, ignore and do not emergency switch down\n      if (fragLevelNextLoadedDelay > duration * 10) {\n        return;\n      }\n      if (loadedFirstByte) {\n        // If there has been loading progress, sample bandwidth using loading time offset by minimum TTFB time\n        this.bwEstimator.sample(timeLoading - Math.min(ttfbEstimate, ttfb), stats.loaded);\n      } else {\n        // If there has been no loading progress, sample TTFB\n        this.bwEstimator.sampleTTFB(timeLoading);\n      }\n      const nextLoadLevelBitrate = levels[nextLoadLevel].maxBitrate;\n      if (this.getBwEstimate() * abrBandWidthUpFactor > nextLoadLevelBitrate) {\n        this.resetEstimator(nextLoadLevelBitrate);\n      }\n      const bestSwitchLevel = this.findBestLevel(nextLoadLevelBitrate, minAutoLevel, nextLoadLevel, 0, bufferStarvationDelay, 1, 1);\n      if (bestSwitchLevel > -1) {\n        nextLoadLevel = bestSwitchLevel;\n      }\n      this.warn(`Fragment ${frag.sn}${part ? ' part ' + part.index : ''} of level ${loadingFragForLevel} is loading too slowly;\n      Fragment duration: ${frag.duration.toFixed(3)}\n      Time to underbuffer: ${bufferStarvationDelay.toFixed(3)} s\n      Estimated load time for current fragment: ${fragLoadedDelay.toFixed(3)} s\n      Estimated load time for down switch fragment: ${fragLevelNextLoadedDelay.toFixed(3)} s\n      TTFB estimate: ${ttfb | 0} ms\n      Current BW estimate: ${isFiniteNumber(bwEstimate) ? bwEstimate | 0 : 'Unknown'} bps\n      New BW estimate: ${this.getBwEstimate() | 0} bps\n      Switching to level ${nextLoadLevel} @ ${nextLoadLevelBitrate | 0} bps`);\n      hls.nextLoadLevel = hls.nextAutoLevel = nextLoadLevel;\n      this.clearTimer();\n      const abortAndSwitch = () => {\n        // Are nextLoadLevel details available or is stream-controller still in \"WAITING_LEVEL\" state?\n        this.clearTimer();\n        if (this.fragCurrent === frag && this.hls.loadLevel === nextLoadLevel && nextLoadLevel > 0) {\n          const bufferStarvationDelay = this.getStarvationDelay();\n          this.warn(`Aborting inflight request ${nextLoadLevel > 0 ? 'and switching down' : ''}\n      Fragment duration: ${frag.duration.toFixed(3)} s\n      Time to underbuffer: ${bufferStarvationDelay.toFixed(3)} s`);\n          frag.abortRequests();\n          this.fragCurrent = this.partCurrent = null;\n          if (nextLoadLevel > minAutoLevel) {\n            let lowestSwitchLevel = this.findBestLevel(this.hls.levels[minAutoLevel].bitrate, minAutoLevel, nextLoadLevel, 0, bufferStarvationDelay, 1, 1);\n            if (lowestSwitchLevel === -1) {\n              lowestSwitchLevel = minAutoLevel;\n            }\n            this.hls.nextLoadLevel = this.hls.nextAutoLevel = lowestSwitchLevel;\n            this.resetEstimator(this.hls.levels[lowestSwitchLevel].bitrate);\n          }\n        }\n      };\n      if (fragBlockingSwitch || fragLoadedDelay > fragLevelNextLoadedDelay * 2) {\n        abortAndSwitch();\n      } else {\n        this.timer = self.setInterval(abortAndSwitch, fragLevelNextLoadedDelay * 1000);\n      }\n      hls.trigger(Events.FRAG_LOAD_EMERGENCY_ABORTED, {\n        frag,\n        part,\n        stats\n      });\n    };\n    this.hls = _hls;\n    this.bwEstimator = this.initEstimator();\n    this.registerListeners();\n  }\n  resetEstimator(abrEwmaDefaultEstimate) {\n    if (abrEwmaDefaultEstimate) {\n      this.log(`setting initial bwe to ${abrEwmaDefaultEstimate}`);\n      this.hls.config.abrEwmaDefaultEstimate = abrEwmaDefaultEstimate;\n    }\n    this.firstSelection = -1;\n    this.bwEstimator = this.initEstimator();\n  }\n  initEstimator() {\n    const config = this.hls.config;\n    return new EwmaBandWidthEstimator(config.abrEwmaSlowVoD, config.abrEwmaFastVoD, config.abrEwmaDefaultEstimate);\n  }\n  registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.FRAG_LOADING, this.onFragLoading, this);\n    hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);\n    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.on(Events.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this);\n    hls.on(Events.ERROR, this.onError, this);\n  }\n  unregisterListeners() {\n    const {\n      hls\n    } = this;\n    if (!hls) {\n      return;\n    }\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.FRAG_LOADING, this.onFragLoading, this);\n    hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);\n    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.off(Events.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this);\n    hls.off(Events.ERROR, this.onError, this);\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.clearTimer();\n    // @ts-ignore\n    this.hls = this._abandonRulesCheck = this.supportedCache = null;\n    this.fragCurrent = this.partCurrent = null;\n  }\n  onManifestLoading(event, data) {\n    this.lastLoadedFragLevel = -1;\n    this.firstSelection = -1;\n    this.lastLevelLoadSec = 0;\n    this.supportedCache = {};\n    this.fragCurrent = this.partCurrent = null;\n    this.onLevelsUpdated();\n    this.clearTimer();\n  }\n  onLevelsUpdated() {\n    if (this.lastLoadedFragLevel > -1 && this.fragCurrent) {\n      this.lastLoadedFragLevel = this.fragCurrent.level;\n    }\n    this._nextAutoLevel = -1;\n    this.onMaxAutoLevelUpdated();\n    this.codecTiers = null;\n    this.audioTracksByGroup = null;\n  }\n  onMaxAutoLevelUpdated() {\n    this.firstSelection = -1;\n    this.nextAutoLevelKey = '';\n  }\n  onFragLoading(event, data) {\n    const frag = data.frag;\n    if (this.ignoreFragment(frag)) {\n      return;\n    }\n    if (!frag.bitrateTest) {\n      var _data$part;\n      this.fragCurrent = frag;\n      this.partCurrent = (_data$part = data.part) != null ? _data$part : null;\n    }\n    this.clearTimer();\n    this.timer = self.setInterval(this._abandonRulesCheck, 100);\n  }\n  onLevelSwitching(event, data) {\n    this.clearTimer();\n  }\n  onError(event, data) {\n    if (data.fatal) {\n      return;\n    }\n    switch (data.details) {\n      case ErrorDetails.BUFFER_ADD_CODEC_ERROR:\n      case ErrorDetails.BUFFER_APPEND_ERROR:\n        // Reset last loaded level so that a new selection can be made after calling recoverMediaError\n        this.lastLoadedFragLevel = -1;\n        this.firstSelection = -1;\n        break;\n      case ErrorDetails.FRAG_LOAD_TIMEOUT:\n        {\n          const frag = data.frag;\n          const {\n            fragCurrent,\n            partCurrent: part\n          } = this;\n          if (frag && fragCurrent && frag.sn === fragCurrent.sn && frag.level === fragCurrent.level) {\n            const now = performance.now();\n            const stats = part ? part.stats : frag.stats;\n            const timeLoading = now - stats.loading.start;\n            const ttfb = stats.loading.first ? stats.loading.first - stats.loading.start : -1;\n            const loadedFirstByte = stats.loaded && ttfb > -1;\n            if (loadedFirstByte) {\n              const ttfbEstimate = this.bwEstimator.getEstimateTTFB();\n              this.bwEstimator.sample(timeLoading - Math.min(ttfbEstimate, ttfb), stats.loaded);\n            } else {\n              this.bwEstimator.sampleTTFB(timeLoading);\n            }\n          }\n          break;\n        }\n    }\n  }\n  getTimeToLoadFrag(timeToFirstByteSec, bandwidth, fragSizeBits, isSwitch) {\n    const fragLoadSec = timeToFirstByteSec + fragSizeBits / bandwidth;\n    const playlistLoadSec = isSwitch ? timeToFirstByteSec + this.lastLevelLoadSec : 0;\n    return fragLoadSec + playlistLoadSec;\n  }\n  onLevelLoaded(event, data) {\n    const config = this.hls.config;\n    const {\n      loading\n    } = data.stats;\n    const timeLoadingMs = loading.end - loading.first;\n    if (isFiniteNumber(timeLoadingMs)) {\n      this.lastLevelLoadSec = timeLoadingMs / 1000;\n    }\n    if (data.details.live) {\n      this.bwEstimator.update(config.abrEwmaSlowLive, config.abrEwmaFastLive);\n    } else {\n      this.bwEstimator.update(config.abrEwmaSlowVoD, config.abrEwmaFastVoD);\n    }\n    if (this.timer > -1) {\n      this._abandonRulesCheck(data.levelInfo);\n    }\n  }\n  onFragLoaded(event, {\n    frag,\n    part\n  }) {\n    const stats = part ? part.stats : frag.stats;\n    if (frag.type === PlaylistLevelType.MAIN) {\n      this.bwEstimator.sampleTTFB(stats.loading.first - stats.loading.start);\n    }\n    if (this.ignoreFragment(frag)) {\n      return;\n    }\n    // stop monitoring bw once frag loaded\n    this.clearTimer();\n    // reset forced auto level value so that next level will be selected\n    if (frag.level === this._nextAutoLevel) {\n      this._nextAutoLevel = -1;\n    }\n    this.firstSelection = -1;\n\n    // compute level average bitrate\n    if (this.hls.config.abrMaxWithRealBitrate) {\n      const duration = part ? part.duration : frag.duration;\n      const level = this.hls.levels[frag.level];\n      const loadedBytes = (level.loaded ? level.loaded.bytes : 0) + stats.loaded;\n      const loadedDuration = (level.loaded ? level.loaded.duration : 0) + duration;\n      level.loaded = {\n        bytes: loadedBytes,\n        duration: loadedDuration\n      };\n      level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);\n    }\n    if (frag.bitrateTest) {\n      const fragBufferedData = {\n        stats,\n        frag,\n        part,\n        id: frag.type\n      };\n      this.onFragBuffered(Events.FRAG_BUFFERED, fragBufferedData);\n      frag.bitrateTest = false;\n    } else {\n      // store level id after successful fragment load for playback\n      this.lastLoadedFragLevel = frag.level;\n    }\n  }\n  onFragBuffered(event, data) {\n    const {\n      frag,\n      part\n    } = data;\n    const stats = part != null && part.stats.loaded ? part.stats : frag.stats;\n    if (stats.aborted) {\n      return;\n    }\n    if (this.ignoreFragment(frag)) {\n      return;\n    }\n    // Use the difference between parsing and request instead of buffering and request to compute fragLoadingProcessing;\n    // rationale is that buffer appending only happens once media is attached. This can happen when config.startFragPrefetch\n    // is used. If we used buffering in that case, our BW estimate sample will be very large.\n    const processingMs = stats.parsing.end - stats.loading.start - Math.min(stats.loading.first - stats.loading.start, this.bwEstimator.getEstimateTTFB());\n    this.bwEstimator.sample(processingMs, stats.loaded);\n    stats.bwEstimate = this.getBwEstimate();\n    if (frag.bitrateTest) {\n      this.bitrateTestDelay = processingMs / 1000;\n    } else {\n      this.bitrateTestDelay = 0;\n    }\n  }\n  ignoreFragment(frag) {\n    // Only count non-alt-audio frags which were actually buffered in our BW calculations\n    return frag.type !== PlaylistLevelType.MAIN || frag.sn === 'initSegment';\n  }\n  clearTimer() {\n    if (this.timer > -1) {\n      self.clearInterval(this.timer);\n      this.timer = -1;\n    }\n  }\n  get firstAutoLevel() {\n    const {\n      maxAutoLevel,\n      minAutoLevel\n    } = this.hls;\n    const bwEstimate = this.getBwEstimate();\n    const maxStartDelay = this.hls.config.maxStarvationDelay;\n    const abrAutoLevel = this.findBestLevel(bwEstimate, minAutoLevel, maxAutoLevel, 0, maxStartDelay, 1, 1);\n    if (abrAutoLevel > -1) {\n      return abrAutoLevel;\n    }\n    const firstLevel = this.hls.firstLevel;\n    const clamped = Math.min(Math.max(firstLevel, minAutoLevel), maxAutoLevel);\n    this.warn(`Could not find best starting auto level. Defaulting to first in playlist ${firstLevel} clamped to ${clamped}`);\n    return clamped;\n  }\n  get forcedAutoLevel() {\n    if (this.nextAutoLevelKey) {\n      return -1;\n    }\n    return this._nextAutoLevel;\n  }\n\n  // return next auto level\n  get nextAutoLevel() {\n    const forcedAutoLevel = this.forcedAutoLevel;\n    const bwEstimator = this.bwEstimator;\n    const useEstimate = bwEstimator.canEstimate();\n    const loadedFirstFrag = this.lastLoadedFragLevel > -1;\n    // in case next auto level has been forced, and bw not available or not reliable, return forced value\n    if (forcedAutoLevel !== -1 && (!useEstimate || !loadedFirstFrag || this.nextAutoLevelKey === this.getAutoLevelKey())) {\n      return forcedAutoLevel;\n    }\n\n    // compute next level using ABR logic\n    const nextABRAutoLevel = useEstimate && loadedFirstFrag ? this.getNextABRAutoLevel() : this.firstAutoLevel;\n\n    // use forced auto level while it hasn't errored more than ABR selection\n    if (forcedAutoLevel !== -1) {\n      const levels = this.hls.levels;\n      if (levels.length > Math.max(forcedAutoLevel, nextABRAutoLevel) && levels[forcedAutoLevel].loadError <= levels[nextABRAutoLevel].loadError) {\n        return forcedAutoLevel;\n      }\n    }\n\n    // save result until state has changed\n    this._nextAutoLevel = nextABRAutoLevel;\n    this.nextAutoLevelKey = this.getAutoLevelKey();\n    return nextABRAutoLevel;\n  }\n  getAutoLevelKey() {\n    return `${this.getBwEstimate()}_${this.getStarvationDelay().toFixed(2)}`;\n  }\n  getNextABRAutoLevel() {\n    const {\n      fragCurrent,\n      partCurrent,\n      hls\n    } = this;\n    if (hls.levels.length <= 1) {\n      return hls.loadLevel;\n    }\n    const {\n      maxAutoLevel,\n      config,\n      minAutoLevel\n    } = hls;\n    const currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;\n    const avgbw = this.getBwEstimate();\n    // bufferStarvationDelay is the wall-clock time left until the playback buffer is exhausted.\n    const bufferStarvationDelay = this.getStarvationDelay();\n    let bwFactor = config.abrBandWidthFactor;\n    let bwUpFactor = config.abrBandWidthUpFactor;\n\n    // First, look to see if we can find a level matching with our avg bandwidth AND that could also guarantee no rebuffering at all\n    if (bufferStarvationDelay) {\n      const _bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, 0, bwFactor, bwUpFactor);\n      if (_bestLevel >= 0) {\n        this.rebufferNotice = -1;\n        return _bestLevel;\n      }\n    }\n    // not possible to get rid of rebuffering... try to find level that will guarantee less than maxStarvationDelay of rebuffering\n    let maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay;\n    if (!bufferStarvationDelay) {\n      // in case buffer is empty, let's check if previous fragment was loaded to perform a bitrate test\n      const bitrateTestDelay = this.bitrateTestDelay;\n      if (bitrateTestDelay) {\n        // if it is the case, then we need to adjust our max starvation delay using maxLoadingDelay config value\n        // max video loading delay used in  automatic start level selection :\n        // in that mode ABR controller will ensure that video loading time (ie the time to fetch the first fragment at lowest quality level +\n        // the time to fetch the fragment at the appropriate quality level is less than ```maxLoadingDelay``` )\n        // cap maxLoadingDelay and ensure it is not bigger 'than bitrate test' frag duration\n        const maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;\n        maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;\n        this.info(`bitrate test took ${Math.round(1000 * bitrateTestDelay)}ms, set first fragment max fetchDuration to ${Math.round(1000 * maxStarvationDelay)} ms`);\n        // don't use conservative factor on bitrate test\n        bwFactor = bwUpFactor = 1;\n      }\n    }\n    const bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, maxStarvationDelay, bwFactor, bwUpFactor);\n    if (this.rebufferNotice !== bestLevel) {\n      this.rebufferNotice = bestLevel;\n      this.info(`${bufferStarvationDelay ? 'rebuffering expected' : 'buffer is empty'}, optimal quality level ${bestLevel}`);\n    }\n    if (bestLevel > -1) {\n      return bestLevel;\n    }\n    // If no matching level found, see if min auto level would be a better option\n    const minLevel = hls.levels[minAutoLevel];\n    const autoLevel = hls.loadLevelObj;\n    if (autoLevel && (minLevel == null ? void 0 : minLevel.bitrate) < autoLevel.bitrate) {\n      return minAutoLevel;\n    }\n    // or if bitrate is not lower, continue to use loadLevel\n    return hls.loadLevel;\n  }\n  getStarvationDelay() {\n    const hls = this.hls;\n    const media = hls.media;\n    if (!media) {\n      return Infinity;\n    }\n    // playbackRate is the absolute value of the playback rate; if media.playbackRate is 0, we use 1 to load as\n    // if we're playing back at the normal rate.\n    const playbackRate = media && media.playbackRate !== 0 ? Math.abs(media.playbackRate) : 1.0;\n    const bufferInfo = hls.mainForwardBufferInfo;\n    return (bufferInfo ? bufferInfo.len : 0) / playbackRate;\n  }\n  getBwEstimate() {\n    return this.bwEstimator.canEstimate() ? this.bwEstimator.getEstimate() : this.hls.config.abrEwmaDefaultEstimate;\n  }\n  findBestLevel(currentBw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, maxStarvationDelay, bwFactor, bwUpFactor) {\n    var _this$hls$latestLevel;\n    const maxFetchDuration = bufferStarvationDelay + maxStarvationDelay;\n    const lastLoadedFragLevel = this.lastLoadedFragLevel;\n    const selectionBaseLevel = lastLoadedFragLevel === -1 ? this.hls.firstLevel : lastLoadedFragLevel;\n    const {\n      fragCurrent,\n      partCurrent\n    } = this;\n    const {\n      levels,\n      allAudioTracks,\n      loadLevel,\n      config\n    } = this.hls;\n    if (levels.length === 1) {\n      return 0;\n    }\n    const level = levels[selectionBaseLevel];\n    const live = !!((_this$hls$latestLevel = this.hls.latestLevelDetails) != null && _this$hls$latestLevel.live);\n    const firstSelection = loadLevel === -1 || lastLoadedFragLevel === -1;\n    let currentCodecSet;\n    let currentVideoRange = 'SDR';\n    let currentFrameRate = (level == null ? void 0 : level.frameRate) || 0;\n    const {\n      audioPreference,\n      videoPreference\n    } = config;\n    const audioTracksByGroup = this.audioTracksByGroup || (this.audioTracksByGroup = getAudioTracksByGroup(allAudioTracks));\n    let minStartIndex = -1;\n    if (firstSelection) {\n      if (this.firstSelection !== -1) {\n        return this.firstSelection;\n      }\n      const codecTiers = this.codecTiers || (this.codecTiers = getCodecTiers(levels, audioTracksByGroup, minAutoLevel, maxAutoLevel));\n      const startTier = getStartCodecTier(codecTiers, currentVideoRange, currentBw, audioPreference, videoPreference);\n      const {\n        codecSet,\n        videoRanges,\n        minFramerate,\n        minBitrate,\n        minIndex,\n        preferHDR\n      } = startTier;\n      minStartIndex = minIndex;\n      currentCodecSet = codecSet;\n      currentVideoRange = preferHDR ? videoRanges[videoRanges.length - 1] : videoRanges[0];\n      currentFrameRate = minFramerate;\n      currentBw = Math.max(currentBw, minBitrate);\n      this.log(`picked start tier ${stringify(startTier)}`);\n    } else {\n      currentCodecSet = level == null ? void 0 : level.codecSet;\n      currentVideoRange = level == null ? void 0 : level.videoRange;\n    }\n    const currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;\n    const ttfbEstimateSec = this.bwEstimator.getEstimateTTFB() / 1000;\n    const levelsSkipped = [];\n    for (let i = maxAutoLevel; i >= minAutoLevel; i--) {\n      var _levelInfo$supportedR, _levelInfo$supportedR2;\n      const levelInfo = levels[i];\n      const upSwitch = i > selectionBaseLevel;\n      if (!levelInfo) {\n        continue;\n      }\n      if (config.useMediaCapabilities && !levelInfo.supportedResult && !levelInfo.supportedPromise) {\n        const mediaCapabilities = navigator.mediaCapabilities;\n        if (typeof (mediaCapabilities == null ? void 0 : mediaCapabilities.decodingInfo) === 'function' && requiresMediaCapabilitiesDecodingInfo(levelInfo, audioTracksByGroup, currentVideoRange, currentFrameRate, currentBw, audioPreference)) {\n          levelInfo.supportedPromise = getMediaDecodingInfoPromise(levelInfo, audioTracksByGroup, mediaCapabilities, this.supportedCache);\n          levelInfo.supportedPromise.then(decodingInfo => {\n            if (!this.hls) {\n              return;\n            }\n            levelInfo.supportedResult = decodingInfo;\n            const levels = this.hls.levels;\n            const index = levels.indexOf(levelInfo);\n            if (decodingInfo.error) {\n              this.warn(`MediaCapabilities decodingInfo error: \"${decodingInfo.error}\" for level ${index} ${stringify(decodingInfo)}`);\n            } else if (!decodingInfo.supported) {\n              this.warn(`Unsupported MediaCapabilities decodingInfo result for level ${index} ${stringify(decodingInfo)}`);\n              if (index > -1 && levels.length > 1) {\n                this.log(`Removing unsupported level ${index}`);\n                this.hls.removeLevel(index);\n                if (this.hls.loadLevel === -1) {\n                  this.hls.nextLoadLevel = 0;\n                }\n              }\n            } else if (decodingInfo.decodingInfoResults.some(info => info.smooth === false || info.powerEfficient === false)) {\n              this.log(`MediaCapabilities decodingInfo for level ${index} not smooth or powerEfficient: ${stringify(decodingInfo)}`);\n            }\n          });\n        } else {\n          levelInfo.supportedResult = SUPPORTED_INFO_DEFAULT;\n        }\n      }\n\n      // skip candidates which change codec-family or video-range,\n      // and which decrease or increase frame-rate for up and down-switch respectfully\n      if (currentCodecSet && levelInfo.codecSet !== currentCodecSet || currentVideoRange && levelInfo.videoRange !== currentVideoRange || upSwitch && currentFrameRate > levelInfo.frameRate || !upSwitch && currentFrameRate > 0 && currentFrameRate < levelInfo.frameRate || (_levelInfo$supportedR = levelInfo.supportedResult) != null && (_levelInfo$supportedR2 = _levelInfo$supportedR.decodingInfoResults) != null && _levelInfo$supportedR2.some(info => info.smooth === false)) {\n        if (!firstSelection || i !== minStartIndex) {\n          levelsSkipped.push(i);\n          continue;\n        }\n      }\n      const levelDetails = levelInfo.details;\n      const avgDuration = (partCurrent ? levelDetails == null ? void 0 : levelDetails.partTarget : levelDetails == null ? void 0 : levelDetails.averagetargetduration) || currentFragDuration;\n      let adjustedbw;\n      // follow algorithm captured from stagefright :\n      // https://android.googlesource.com/platform/frameworks/av/+/master/media/libstagefright/httplive/LiveSession.cpp\n      // Pick the highest bandwidth stream below or equal to estimated bandwidth.\n      // consider only 80% of the available bandwidth, but if we are switching up,\n      // be even more conservative (70%) to avoid overestimating and immediately\n      // switching back.\n      if (!upSwitch) {\n        adjustedbw = bwFactor * currentBw;\n      } else {\n        adjustedbw = bwUpFactor * currentBw;\n      }\n\n      // Use average bitrate when starvation delay (buffer length) is gt or eq two segment durations and rebuffering is not expected (maxStarvationDelay > 0)\n      const bitrate = currentFragDuration && bufferStarvationDelay >= currentFragDuration * 2 && maxStarvationDelay === 0 ? levelInfo.averageBitrate : levelInfo.maxBitrate;\n      const fetchDuration = this.getTimeToLoadFrag(ttfbEstimateSec, adjustedbw, bitrate * avgDuration, levelDetails === undefined);\n      const canSwitchWithinTolerance =\n      // if adjusted bw is greater than level bitrate AND\n      adjustedbw >= bitrate && (\n      // no level change, or new level has no error history\n      i === lastLoadedFragLevel || levelInfo.loadError === 0 && levelInfo.fragmentError === 0) && (\n      // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches\n      // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...\n      // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that findBestLevel will return -1\n      fetchDuration <= ttfbEstimateSec || !isFiniteNumber(fetchDuration) || live && !this.bitrateTestDelay || fetchDuration < maxFetchDuration);\n      if (canSwitchWithinTolerance) {\n        const forcedAutoLevel = this.forcedAutoLevel;\n        if (i !== loadLevel && (forcedAutoLevel === -1 || forcedAutoLevel !== loadLevel)) {\n          if (levelsSkipped.length) {\n            this.trace(`Skipped level(s) ${levelsSkipped.join(',')} of ${maxAutoLevel} max with CODECS and VIDEO-RANGE:\"${levels[levelsSkipped[0]].codecs}\" ${levels[levelsSkipped[0]].videoRange}; not compatible with \"${currentCodecSet}\" ${currentVideoRange}`);\n          }\n          this.info(`switch candidate:${selectionBaseLevel}->${i} adjustedbw(${Math.round(adjustedbw)})-bitrate=${Math.round(adjustedbw - bitrate)} ttfb:${ttfbEstimateSec.toFixed(1)} avgDuration:${avgDuration.toFixed(1)} maxFetchDuration:${maxFetchDuration.toFixed(1)} fetchDuration:${fetchDuration.toFixed(1)} firstSelection:${firstSelection} codecSet:${levelInfo.codecSet} videoRange:${levelInfo.videoRange} hls.loadLevel:${loadLevel}`);\n        }\n        if (firstSelection) {\n          this.firstSelection = i;\n        }\n        // as we are looping from highest to lowest, this will return the best achievable quality level\n        return i;\n      }\n    }\n    // not enough time budget even with quality level 0 ... rebuffering might happen\n    return -1;\n  }\n  set nextAutoLevel(nextLevel) {\n    const value = this.deriveNextAutoLevel(nextLevel);\n    if (this._nextAutoLevel !== value) {\n      this.nextAutoLevelKey = '';\n      this._nextAutoLevel = value;\n    }\n  }\n  deriveNextAutoLevel(nextLevel) {\n    const {\n      maxAutoLevel,\n      minAutoLevel\n    } = this.hls;\n    return Math.min(Math.max(nextLevel, minAutoLevel), maxAutoLevel);\n  }\n}\n\nconst BinarySearch = {\n  /**\n   * Searches for an item in an array which matches a certain condition.\n   * This requires the condition to only match one item in the array,\n   * and for the array to be ordered.\n   *\n   * @param list The array to search.\n   * @param comparisonFn\n   *      Called and provided a candidate item as the first argument.\n   *      Should return:\n   *          > -1 if the item should be located at a lower index than the provided item.\n   *          > 1 if the item should be located at a higher index than the provided item.\n   *          > 0 if the item is the item you're looking for.\n   *\n   * @returns the object if found, otherwise returns null\n   */\n  search: function (list, comparisonFn) {\n    let minIndex = 0;\n    let maxIndex = list.length - 1;\n    let currentIndex = null;\n    let currentElement = null;\n    while (minIndex <= maxIndex) {\n      currentIndex = (minIndex + maxIndex) / 2 | 0;\n      currentElement = list[currentIndex];\n      const comparisonResult = comparisonFn(currentElement);\n      if (comparisonResult > 0) {\n        minIndex = currentIndex + 1;\n      } else if (comparisonResult < 0) {\n        maxIndex = currentIndex - 1;\n      } else {\n        return currentElement;\n      }\n    }\n    return null;\n  }\n};\n\n/**\n * Returns first fragment whose endPdt value exceeds the given PDT, or null.\n * @param fragments - The array of candidate fragments\n * @param PDTValue - The PDT value which must be exceeded\n * @param maxFragLookUpTolerance - The amount of time that a fragment's start/end can be within in order to be considered contiguous\n */\nfunction findFragmentByPDT(fragments, PDTValue, maxFragLookUpTolerance) {\n  if (PDTValue === null || !Array.isArray(fragments) || !fragments.length || !isFiniteNumber(PDTValue)) {\n    return null;\n  }\n\n  // if less than start\n  const startPDT = fragments[0].programDateTime;\n  if (PDTValue < (startPDT || 0)) {\n    return null;\n  }\n  const endPDT = fragments[fragments.length - 1].endProgramDateTime;\n  if (PDTValue >= (endPDT || 0)) {\n    return null;\n  }\n  for (let seg = 0; seg < fragments.length; ++seg) {\n    const frag = fragments[seg];\n    if (pdtWithinToleranceTest(PDTValue, maxFragLookUpTolerance, frag)) {\n      return frag;\n    }\n  }\n  return null;\n}\n\n/**\n * Finds a fragment based on the SN of the previous fragment; or based on the needs of the current buffer.\n * This method compensates for small buffer gaps by applying a tolerance to the start of any candidate fragment, thus\n * breaking any traps which would cause the same fragment to be continuously selected within a small range.\n * @param fragPrevious - The last frag successfully appended\n * @param fragments - The array of candidate fragments\n * @param bufferEnd - The end of the contiguous buffered range the playhead is currently within\n * @param maxFragLookUpTolerance - The amount of time that a fragment's start/end can be within in order to be considered contiguous\n * @returns a matching fragment or null\n */\nfunction findFragmentByPTS(fragPrevious, fragments, bufferEnd = 0, maxFragLookUpTolerance = 0, nextFragLookupTolerance = 0.005) {\n  let fragNext = null;\n  if (fragPrevious) {\n    fragNext = fragments[1 + fragPrevious.sn - fragments[0].sn] || null;\n    // check for buffer-end rounding error\n    const bufferEdgeError = fragPrevious.endDTS - bufferEnd;\n    if (bufferEdgeError > 0 && bufferEdgeError < 0.0000015) {\n      bufferEnd += 0.0000015;\n    }\n    if (fragNext && fragPrevious.level !== fragNext.level && fragNext.end <= fragPrevious.end) {\n      fragNext = fragments[2 + fragPrevious.sn - fragments[0].sn] || null;\n    }\n  } else if (bufferEnd === 0 && fragments[0].start === 0) {\n    fragNext = fragments[0];\n  }\n  // Prefer the next fragment if it's within tolerance\n  if (fragNext && ((!fragPrevious || fragPrevious.level === fragNext.level) && fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, fragNext) === 0 || fragmentWithinFastStartSwitch(fragNext, fragPrevious, Math.min(nextFragLookupTolerance, maxFragLookUpTolerance)))) {\n    return fragNext;\n  }\n  // We might be seeking past the tolerance so find the best match\n  const foundFragment = BinarySearch.search(fragments, fragmentWithinToleranceTest.bind(null, bufferEnd, maxFragLookUpTolerance));\n  if (foundFragment && (foundFragment !== fragPrevious || !fragNext)) {\n    return foundFragment;\n  }\n  // If no match was found return the next fragment after fragPrevious, or null\n  return fragNext;\n}\nfunction fragmentWithinFastStartSwitch(fragNext, fragPrevious, nextFragLookupTolerance) {\n  if (fragPrevious && fragPrevious.start === 0 && fragPrevious.level < fragNext.level && (fragPrevious.endPTS || 0) > 0) {\n    const firstDuration = fragPrevious.tagList.reduce((duration, tag) => {\n      if (tag[0] === 'INF') {\n        duration += parseFloat(tag[1]);\n      }\n      return duration;\n    }, nextFragLookupTolerance);\n    return fragNext.start <= firstDuration;\n  }\n  return false;\n}\n\n/**\n * The test function used by the findFragmentBySn's BinarySearch to look for the best match to the current buffer conditions.\n * @param candidate - The fragment to test\n * @param bufferEnd - The end of the current buffered range the playhead is currently within\n * @param maxFragLookUpTolerance - The amount of time that a fragment's start can be within in order to be considered contiguous\n * @returns 0 if it matches, 1 if too low, -1 if too high\n */\nfunction fragmentWithinToleranceTest(bufferEnd = 0, maxFragLookUpTolerance = 0, candidate) {\n  // eagerly accept an accurate match (no tolerance)\n  if (candidate.start <= bufferEnd && candidate.start + candidate.duration > bufferEnd) {\n    return 0;\n  }\n  // offset should be within fragment boundary - config.maxFragLookUpTolerance\n  // this is to cope with situations like\n  // bufferEnd = 9.991\n  // frag[Ø] : [0,10]\n  // frag[1] : [10,20]\n  // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here\n  //              frag start               frag start+duration\n  //                  |-----------------------------|\n  //              <--->                         <--->\n  //  ...--------><-----------------------------><---------....\n  // previous frag         matching fragment         next frag\n  //  return -1             return 0                 return 1\n  // logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);\n  // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments\n  const candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0));\n  if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {\n    return 1;\n  } else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {\n    // if maxFragLookUpTolerance will have negative value then don't return -1 for first element\n    return -1;\n  }\n  return 0;\n}\n\n/**\n * The test function used by the findFragmentByPdt's BinarySearch to look for the best match to the current buffer conditions.\n * This function tests the candidate's program date time values, as represented in Unix time\n * @param candidate - The fragment to test\n * @param pdtBufferEnd - The Unix time representing the end of the current buffered range\n * @param maxFragLookUpTolerance - The amount of time that a fragment's start can be within in order to be considered contiguous\n * @returns true if contiguous, false otherwise\n */\nfunction pdtWithinToleranceTest(pdtBufferEnd, maxFragLookUpTolerance, candidate) {\n  const candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0)) * 1000;\n\n  // endProgramDateTime can be null, default to zero\n  const endProgramDateTime = candidate.endProgramDateTime || 0;\n  return endProgramDateTime - candidateLookupTolerance > pdtBufferEnd;\n}\nfunction findNearestWithCC(details, cc, pos) {\n  if (details) {\n    if (details.startCC <= cc && details.endCC >= cc) {\n      let fragments = details.fragments;\n      const {\n        fragmentHint\n      } = details;\n      if (fragmentHint) {\n        fragments = fragments.concat(fragmentHint);\n      }\n      let closest;\n      BinarySearch.search(fragments, candidate => {\n        if (candidate.cc < cc) {\n          return 1;\n        }\n        if (candidate.cc > cc) {\n          return -1;\n        }\n        closest = candidate;\n        if (candidate.end <= pos) {\n          return 1;\n        }\n        if (candidate.start > pos) {\n          return -1;\n        }\n        return 0;\n      });\n      return closest || null;\n    }\n  }\n  return null;\n}\n\nfunction isTimeoutError(error) {\n  switch (error.details) {\n    case ErrorDetails.FRAG_LOAD_TIMEOUT:\n    case ErrorDetails.KEY_LOAD_TIMEOUT:\n    case ErrorDetails.LEVEL_LOAD_TIMEOUT:\n    case ErrorDetails.MANIFEST_LOAD_TIMEOUT:\n      return true;\n  }\n  return false;\n}\nfunction getRetryConfig(loadPolicy, error) {\n  const isTimeout = isTimeoutError(error);\n  return loadPolicy.default[`${isTimeout ? 'timeout' : 'error'}Retry`];\n}\nfunction getRetryDelay(retryConfig, retryCount) {\n  // exponential backoff capped to max retry delay\n  const backoffFactor = retryConfig.backoff === 'linear' ? 1 : Math.pow(2, retryCount);\n  return Math.min(backoffFactor * retryConfig.retryDelayMs, retryConfig.maxRetryDelayMs);\n}\nfunction getLoaderConfigWithoutReties(loderConfig) {\n  return _objectSpread2(_objectSpread2({}, loderConfig), {\n    errorRetry: null,\n    timeoutRetry: null\n  });\n}\nfunction shouldRetry(retryConfig, retryCount, isTimeout, loaderResponse) {\n  if (!retryConfig) {\n    return false;\n  }\n  const httpStatus = loaderResponse == null ? void 0 : loaderResponse.code;\n  const retry = retryCount < retryConfig.maxNumRetry && (retryForHttpStatus(httpStatus) || !!isTimeout);\n  return retryConfig.shouldRetry ? retryConfig.shouldRetry(retryConfig, retryCount, isTimeout, loaderResponse, retry) : retry;\n}\nfunction retryForHttpStatus(httpStatus) {\n  // Do not retry on status 4xx, status 0 (CORS error), or undefined (decrypt/gap/parse error)\n  return httpStatus === 0 && navigator.onLine === false || !!httpStatus && (httpStatus < 400 || httpStatus > 499);\n}\n\nvar NetworkErrorAction = {\n  DoNothing: 0,\n  SendEndCallback: 1,\n  SendAlternateToPenaltyBox: 2,\n  RemoveAlternatePermanently: 3,\n  InsertDiscontinuity: 4,\n  RetryRequest: 5\n};\nvar ErrorActionFlags = {\n  None: 0,\n  MoveAllAlternatesMatchingHost: 1,\n  MoveAllAlternatesMatchingHDCP: 2,\n  SwitchToSDR: 4\n};\nclass ErrorController extends Logger {\n  constructor(hls) {\n    super('error-controller', hls.logger);\n    this.hls = void 0;\n    this.playlistError = 0;\n    this.penalizedRenditions = {};\n    this.hls = hls;\n    this.registerListeners();\n  }\n  registerListeners() {\n    const hls = this.hls;\n    hls.on(Events.ERROR, this.onError, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n  }\n  unregisterListeners() {\n    const hls = this.hls;\n    if (!hls) {\n      return;\n    }\n    hls.off(Events.ERROR, this.onError, this);\n    hls.off(Events.ERROR, this.onErrorOut, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n  }\n  destroy() {\n    this.unregisterListeners();\n    // @ts-ignore\n    this.hls = null;\n    this.penalizedRenditions = {};\n  }\n  startLoad(startPosition) {}\n  stopLoad() {\n    this.playlistError = 0;\n  }\n  getVariantLevelIndex(frag) {\n    return (frag == null ? void 0 : frag.type) === PlaylistLevelType.MAIN ? frag.level : this.hls.loadLevel;\n  }\n  onManifestLoading() {\n    this.playlistError = 0;\n    this.penalizedRenditions = {};\n  }\n  onLevelUpdated() {\n    this.playlistError = 0;\n  }\n  onError(event, data) {\n    var _data$frag;\n    if (data.fatal) {\n      return;\n    }\n    const hls = this.hls;\n    const context = data.context;\n    switch (data.details) {\n      case ErrorDetails.FRAG_LOAD_ERROR:\n      case ErrorDetails.FRAG_LOAD_TIMEOUT:\n      case ErrorDetails.KEY_LOAD_ERROR:\n      case ErrorDetails.KEY_LOAD_TIMEOUT:\n        data.errorAction = this.getFragRetryOrSwitchAction(data);\n        return;\n      case ErrorDetails.FRAG_PARSING_ERROR:\n        // ignore empty segment errors marked as gap\n        if ((_data$frag = data.frag) != null && _data$frag.gap) {\n          data.errorAction = createDoNothingErrorAction();\n          return;\n        }\n      // falls through\n      case ErrorDetails.FRAG_GAP:\n      case ErrorDetails.FRAG_DECRYPT_ERROR:\n        {\n          // Switch level if possible, otherwise allow retry count to reach max error retries\n          data.errorAction = this.getFragRetryOrSwitchAction(data);\n          data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;\n          return;\n        }\n      case ErrorDetails.LEVEL_EMPTY_ERROR:\n      case ErrorDetails.LEVEL_PARSING_ERROR:\n        {\n          var _data$context, _data$context$levelDe;\n          // Only retry when empty and live\n          const levelIndex = data.parent === PlaylistLevelType.MAIN ? data.level : hls.loadLevel;\n          if (data.details === ErrorDetails.LEVEL_EMPTY_ERROR && !!((_data$context = data.context) != null && (_data$context$levelDe = _data$context.levelDetails) != null && _data$context$levelDe.live)) {\n            data.errorAction = this.getPlaylistRetryOrSwitchAction(data, levelIndex);\n          } else {\n            // Escalate to fatal if not retrying or switching\n            data.levelRetry = false;\n            data.errorAction = this.getLevelSwitchAction(data, levelIndex);\n          }\n        }\n        return;\n      case ErrorDetails.LEVEL_LOAD_ERROR:\n      case ErrorDetails.LEVEL_LOAD_TIMEOUT:\n        if (typeof (context == null ? void 0 : context.level) === 'number') {\n          data.errorAction = this.getPlaylistRetryOrSwitchAction(data, context.level);\n        }\n        return;\n      case ErrorDetails.AUDIO_TRACK_LOAD_ERROR:\n      case ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:\n      case ErrorDetails.SUBTITLE_LOAD_ERROR:\n      case ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT:\n        if (context) {\n          const level = hls.loadLevelObj;\n          if (level && (context.type === PlaylistContextType.AUDIO_TRACK && level.hasAudioGroup(context.groupId) || context.type === PlaylistContextType.SUBTITLE_TRACK && level.hasSubtitleGroup(context.groupId))) {\n            // Perform Pathway switch or Redundant failover if possible for fastest recovery\n            // otherwise allow playlist retry count to reach max error retries\n            data.errorAction = this.getPlaylistRetryOrSwitchAction(data, hls.loadLevel);\n            data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;\n            data.errorAction.flags = ErrorActionFlags.MoveAllAlternatesMatchingHost;\n            return;\n          }\n        }\n        return;\n      case ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:\n        {\n          const level = hls.loadLevelObj;\n          const restrictedHdcpLevel = level == null ? void 0 : level.attrs['HDCP-LEVEL'];\n          if (restrictedHdcpLevel) {\n            data.errorAction = {\n              action: NetworkErrorAction.SendAlternateToPenaltyBox,\n              flags: ErrorActionFlags.MoveAllAlternatesMatchingHDCP,\n              hdcpLevel: restrictedHdcpLevel\n            };\n          } else {\n            this.keySystemError(data);\n          }\n        }\n        return;\n      case ErrorDetails.BUFFER_ADD_CODEC_ERROR:\n      case ErrorDetails.REMUX_ALLOC_ERROR:\n      case ErrorDetails.BUFFER_APPEND_ERROR:\n        // Buffer-controller can set errorAction when append errors can be ignored or resolved locally\n        if (!data.errorAction) {\n          var _data$level;\n          data.errorAction = this.getLevelSwitchAction(data, (_data$level = data.level) != null ? _data$level : hls.loadLevel);\n        }\n        return;\n      case ErrorDetails.INTERNAL_EXCEPTION:\n      case ErrorDetails.BUFFER_APPENDING_ERROR:\n      case ErrorDetails.BUFFER_FULL_ERROR:\n      case ErrorDetails.LEVEL_SWITCH_ERROR:\n      case ErrorDetails.BUFFER_STALLED_ERROR:\n      case ErrorDetails.BUFFER_SEEK_OVER_HOLE:\n      case ErrorDetails.BUFFER_NUDGE_ON_STALL:\n        data.errorAction = createDoNothingErrorAction();\n        return;\n    }\n    if (data.type === ErrorTypes.KEY_SYSTEM_ERROR) {\n      this.keySystemError(data);\n    }\n  }\n  keySystemError(data) {\n    const levelIndex = this.getVariantLevelIndex(data.frag);\n    // Do not retry level. Escalate to fatal if switching levels fails.\n    data.levelRetry = false;\n    data.errorAction = this.getLevelSwitchAction(data, levelIndex);\n  }\n  getPlaylistRetryOrSwitchAction(data, levelIndex) {\n    const hls = this.hls;\n    const retryConfig = getRetryConfig(hls.config.playlistLoadPolicy, data);\n    const retryCount = this.playlistError++;\n    const retry = shouldRetry(retryConfig, retryCount, isTimeoutError(data), data.response);\n    if (retry) {\n      return {\n        action: NetworkErrorAction.RetryRequest,\n        flags: ErrorActionFlags.None,\n        retryConfig,\n        retryCount\n      };\n    }\n    const errorAction = this.getLevelSwitchAction(data, levelIndex);\n    if (retryConfig) {\n      errorAction.retryConfig = retryConfig;\n      errorAction.retryCount = retryCount;\n    }\n    return errorAction;\n  }\n  getFragRetryOrSwitchAction(data) {\n    const hls = this.hls;\n    // Share fragment error count accross media options (main, audio, subs)\n    // This allows for level based rendition switching when media option assets fail\n    const variantLevelIndex = this.getVariantLevelIndex(data.frag);\n    const level = hls.levels[variantLevelIndex];\n    const {\n      fragLoadPolicy,\n      keyLoadPolicy\n    } = hls.config;\n    const retryConfig = getRetryConfig(data.details.startsWith('key') ? keyLoadPolicy : fragLoadPolicy, data);\n    const fragmentErrors = hls.levels.reduce((acc, level) => acc + level.fragmentError, 0);\n    // Switch levels when out of retried or level index out of bounds\n    if (level) {\n      if (data.details !== ErrorDetails.FRAG_GAP) {\n        level.fragmentError++;\n      }\n      const retry = shouldRetry(retryConfig, fragmentErrors, isTimeoutError(data), data.response);\n      if (retry) {\n        return {\n          action: NetworkErrorAction.RetryRequest,\n          flags: ErrorActionFlags.None,\n          retryConfig,\n          retryCount: fragmentErrors\n        };\n      }\n    }\n    // Reach max retry count, or Missing level reference\n    // Switch to valid index\n    const errorAction = this.getLevelSwitchAction(data, variantLevelIndex);\n    // Add retry details to allow skipping of FRAG_PARSING_ERROR\n    if (retryConfig) {\n      errorAction.retryConfig = retryConfig;\n      errorAction.retryCount = fragmentErrors;\n    }\n    return errorAction;\n  }\n  getLevelSwitchAction(data, levelIndex) {\n    const hls = this.hls;\n    if (levelIndex === null || levelIndex === undefined) {\n      levelIndex = hls.loadLevel;\n    }\n    const level = this.hls.levels[levelIndex];\n    if (level) {\n      var _data$frag2, _data$context2;\n      const errorDetails = data.details;\n      level.loadError++;\n      if (errorDetails === ErrorDetails.BUFFER_APPEND_ERROR) {\n        level.fragmentError++;\n      }\n      // Search for next level to retry\n      let nextLevel = -1;\n      const {\n        levels,\n        loadLevel,\n        minAutoLevel,\n        maxAutoLevel\n      } = hls;\n      if (!hls.autoLevelEnabled && !hls.config.preserveManualLevelOnError) {\n        hls.loadLevel = -1;\n      }\n      const fragErrorType = (_data$frag2 = data.frag) == null ? void 0 : _data$frag2.type;\n      // Find alternate audio codec if available on audio codec error\n      const isAudioCodecError = fragErrorType === PlaylistLevelType.AUDIO && errorDetails === ErrorDetails.FRAG_PARSING_ERROR || data.sourceBufferName === 'audio' && (errorDetails === ErrorDetails.BUFFER_ADD_CODEC_ERROR || errorDetails === ErrorDetails.BUFFER_APPEND_ERROR);\n      const findAudioCodecAlternate = isAudioCodecError && levels.some(({\n        audioCodec\n      }) => level.audioCodec !== audioCodec);\n      // Find alternate video codec if available on video codec error\n      const isVideoCodecError = data.sourceBufferName === 'video' && (errorDetails === ErrorDetails.BUFFER_ADD_CODEC_ERROR || errorDetails === ErrorDetails.BUFFER_APPEND_ERROR);\n      const findVideoCodecAlternate = isVideoCodecError && levels.some(({\n        codecSet,\n        audioCodec\n      }) => level.codecSet !== codecSet && level.audioCodec === audioCodec);\n      const {\n        type: playlistErrorType,\n        groupId: playlistErrorGroupId\n      } = (_data$context2 = data.context) != null ? _data$context2 : {};\n      for (let i = levels.length; i--;) {\n        const candidate = (i + loadLevel) % levels.length;\n        if (candidate !== loadLevel && candidate >= minAutoLevel && candidate <= maxAutoLevel && levels[candidate].loadError === 0) {\n          var _level$audioGroups, _level$subtitleGroups;\n          const levelCandidate = levels[candidate];\n          // Skip level switch if GAP tag is found in next level at same position\n          if (errorDetails === ErrorDetails.FRAG_GAP && fragErrorType === PlaylistLevelType.MAIN && data.frag) {\n            const levelDetails = levels[candidate].details;\n            if (levelDetails) {\n              const fragCandidate = findFragmentByPTS(data.frag, levelDetails.fragments, data.frag.start);\n              if (fragCandidate != null && fragCandidate.gap) {\n                continue;\n              }\n            }\n          } else if (playlistErrorType === PlaylistContextType.AUDIO_TRACK && levelCandidate.hasAudioGroup(playlistErrorGroupId) || playlistErrorType === PlaylistContextType.SUBTITLE_TRACK && levelCandidate.hasSubtitleGroup(playlistErrorGroupId)) {\n            // For audio/subs playlist errors find another group ID or fallthrough to redundant fail-over\n            continue;\n          } else if (fragErrorType === PlaylistLevelType.AUDIO && (_level$audioGroups = level.audioGroups) != null && _level$audioGroups.some(groupId => levelCandidate.hasAudioGroup(groupId)) || fragErrorType === PlaylistLevelType.SUBTITLE && (_level$subtitleGroups = level.subtitleGroups) != null && _level$subtitleGroups.some(groupId => levelCandidate.hasSubtitleGroup(groupId)) || findAudioCodecAlternate && level.audioCodec === levelCandidate.audioCodec || !findAudioCodecAlternate && level.audioCodec !== levelCandidate.audioCodec || findVideoCodecAlternate && level.codecSet === levelCandidate.codecSet) {\n            // For video/audio/subs frag errors find another group ID or fallthrough to redundant fail-over\n            continue;\n          }\n          nextLevel = candidate;\n          break;\n        }\n      }\n      if (nextLevel > -1 && hls.loadLevel !== nextLevel) {\n        data.levelRetry = true;\n        this.playlistError = 0;\n        return {\n          action: NetworkErrorAction.SendAlternateToPenaltyBox,\n          flags: ErrorActionFlags.None,\n          nextAutoLevel: nextLevel\n        };\n      }\n    }\n    // No levels to switch / Manual level selection / Level not found\n    // Resolve with Pathway switch, Redundant fail-over, or stay on lowest Level\n    return {\n      action: NetworkErrorAction.SendAlternateToPenaltyBox,\n      flags: ErrorActionFlags.MoveAllAlternatesMatchingHost\n    };\n  }\n  onErrorOut(event, data) {\n    var _data$errorAction;\n    switch ((_data$errorAction = data.errorAction) == null ? void 0 : _data$errorAction.action) {\n      case NetworkErrorAction.DoNothing:\n        break;\n      case NetworkErrorAction.SendAlternateToPenaltyBox:\n        this.sendAlternateToPenaltyBox(data);\n        if (!data.errorAction.resolved && data.details !== ErrorDetails.FRAG_GAP) {\n          data.fatal = true;\n        } else if (/MediaSource readyState: ended/.test(data.error.message)) {\n          this.warn(`MediaSource ended after \"${data.sourceBufferName}\" sourceBuffer append error. Attempting to recover from media error.`);\n          this.hls.recoverMediaError();\n        }\n        break;\n      case NetworkErrorAction.RetryRequest:\n        // handled by stream and playlist/level controllers\n        break;\n    }\n    if (data.fatal) {\n      this.hls.stopLoad();\n      return;\n    }\n  }\n  sendAlternateToPenaltyBox(data) {\n    const hls = this.hls;\n    const errorAction = data.errorAction;\n    if (!errorAction) {\n      return;\n    }\n    const {\n      flags,\n      hdcpLevel,\n      nextAutoLevel\n    } = errorAction;\n    switch (flags) {\n      case ErrorActionFlags.None:\n        this.switchLevel(data, nextAutoLevel);\n        break;\n      case ErrorActionFlags.MoveAllAlternatesMatchingHDCP:\n        if (hdcpLevel) {\n          hls.maxHdcpLevel = HdcpLevels[HdcpLevels.indexOf(hdcpLevel) - 1];\n          errorAction.resolved = true;\n        }\n        this.warn(`Restricting playback to HDCP-LEVEL of \"${hls.maxHdcpLevel}\" or lower`);\n        break;\n    }\n    // If not resolved by previous actions try to switch to next level\n    if (!errorAction.resolved) {\n      this.switchLevel(data, nextAutoLevel);\n    }\n  }\n  switchLevel(data, levelIndex) {\n    if (levelIndex !== undefined && data.errorAction) {\n      this.warn(`switching to level ${levelIndex} after ${data.details}`);\n      this.hls.nextAutoLevel = levelIndex;\n      data.errorAction.resolved = true;\n      // Stream controller is responsible for this but won't switch on false start\n      this.hls.nextLoadLevel = this.hls.nextAutoLevel;\n      if (data.details === ErrorDetails.BUFFER_ADD_CODEC_ERROR && data.mimeType && data.sourceBufferName !== 'audiovideo') {\n        const codec = getCodecsForMimeType(data.mimeType);\n        const levels = this.hls.levels;\n        for (let i = levels.length; i--;) {\n          if (levels[i][`${data.sourceBufferName}Codec`] === codec) {\n            this.hls.removeLevel(i);\n          }\n        }\n      }\n    }\n  }\n}\nfunction createDoNothingErrorAction(resolved) {\n  const errorAction = {\n    action: NetworkErrorAction.DoNothing,\n    flags: ErrorActionFlags.None\n  };\n  if (resolved) {\n    errorAction.resolved = true;\n  }\n  return errorAction;\n}\n\nvar FragmentState = {\n  NOT_LOADED: \"NOT_LOADED\",\n  APPENDING: \"APPENDING\",\n  PARTIAL: \"PARTIAL\",\n  OK: \"OK\"\n};\nclass FragmentTracker {\n  constructor(hls) {\n    this.activePartLists = Object.create(null);\n    this.endListFragments = Object.create(null);\n    this.fragments = Object.create(null);\n    this.timeRanges = Object.create(null);\n    this.bufferPadding = 0.2;\n    this.hls = void 0;\n    this.hasGaps = false;\n    this.hls = hls;\n    this._registerListeners();\n  }\n  _registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.BUFFER_APPENDED, this.onBufferAppended, this);\n    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);\n  }\n  _unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.BUFFER_APPENDED, this.onBufferAppended, this);\n    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);\n  }\n  destroy() {\n    this._unregisterListeners();\n    // @ts-ignore\n    this.fragments =\n    // @ts-ignore\n    this.activePartLists =\n    // @ts-ignore\n    this.endListFragments = this.timeRanges = null;\n  }\n\n  /**\n   * Return a Fragment or Part with an appended range that matches the position and levelType\n   * Otherwise, return null\n   */\n  getAppendedFrag(position, levelType) {\n    const activeParts = this.activePartLists[levelType];\n    if (activeParts) {\n      for (let i = activeParts.length; i--;) {\n        const activePart = activeParts[i];\n        if (!activePart) {\n          break;\n        }\n        const appendedPTS = activePart.end;\n        if (activePart.start <= position && appendedPTS !== null && position <= appendedPTS) {\n          return activePart;\n        }\n      }\n    }\n    return this.getBufferedFrag(position, levelType);\n  }\n\n  /**\n   * Return a buffered Fragment that matches the position and levelType.\n   * A buffered Fragment is one whose loading, parsing and appending is done (completed or \"partial\" meaning aborted).\n   * If not found any Fragment, return null\n   */\n  getBufferedFrag(position, levelType) {\n    return this.getFragAtPos(position, levelType, true);\n  }\n  getFragAtPos(position, levelType, buffered) {\n    const {\n      fragments\n    } = this;\n    const keys = Object.keys(fragments);\n    for (let i = keys.length; i--;) {\n      const fragmentEntity = fragments[keys[i]];\n      if ((fragmentEntity == null ? void 0 : fragmentEntity.body.type) === levelType && (!buffered || fragmentEntity.buffered)) {\n        const frag = fragmentEntity.body;\n        if (frag.start <= position && position <= frag.end) {\n          return frag;\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Partial fragments effected by coded frame eviction will be removed\n   * The browser will unload parts of the buffer to free up memory for new buffer data\n   * Fragments will need to be reloaded when the buffer is freed up, removing partial fragments will allow them to reload(since there might be parts that are still playable)\n   */\n  detectEvictedFragments(elementaryStream, timeRange, playlistType, appendedPart, removeAppending) {\n    if (this.timeRanges) {\n      this.timeRanges[elementaryStream] = timeRange;\n    }\n    // Check if any flagged fragments have been unloaded\n    // excluding anything newer than appendedPartSn\n    const appendedPartSn = (appendedPart == null ? void 0 : appendedPart.fragment.sn) || -1;\n    Object.keys(this.fragments).forEach(key => {\n      const fragmentEntity = this.fragments[key];\n      if (!fragmentEntity) {\n        return;\n      }\n      if (appendedPartSn >= fragmentEntity.body.sn) {\n        return;\n      }\n      if (!fragmentEntity.buffered && (!fragmentEntity.loaded || removeAppending)) {\n        if (fragmentEntity.body.type === playlistType) {\n          this.removeFragment(fragmentEntity.body);\n        }\n        return;\n      }\n      const esData = fragmentEntity.range[elementaryStream];\n      if (!esData) {\n        return;\n      }\n      if (esData.time.length === 0) {\n        this.removeFragment(fragmentEntity.body);\n        return;\n      }\n      esData.time.some(time => {\n        const isNotBuffered = !this.isTimeBuffered(time.startPTS, time.endPTS, timeRange);\n        if (isNotBuffered) {\n          // Unregister partial fragment as it needs to load again to be reused\n          this.removeFragment(fragmentEntity.body);\n        }\n        return isNotBuffered;\n      });\n    });\n  }\n\n  /**\n   * Checks if the fragment passed in is loaded in the buffer properly\n   * Partially loaded fragments will be registered as a partial fragment\n   */\n  detectPartialFragments(data) {\n    const timeRanges = this.timeRanges;\n    if (!timeRanges || data.frag.sn === 'initSegment') {\n      return;\n    }\n    const frag = data.frag;\n    const fragKey = getFragmentKey(frag);\n    const fragmentEntity = this.fragments[fragKey];\n    if (!fragmentEntity || fragmentEntity.buffered && frag.gap) {\n      return;\n    }\n    const isFragHint = !frag.relurl;\n    Object.keys(timeRanges).forEach(elementaryStream => {\n      const streamInfo = frag.elementaryStreams[elementaryStream];\n      if (!streamInfo) {\n        return;\n      }\n      const timeRange = timeRanges[elementaryStream];\n      const partial = isFragHint || streamInfo.partial === true;\n      fragmentEntity.range[elementaryStream] = this.getBufferedTimes(frag, data.part, partial, timeRange);\n    });\n    fragmentEntity.loaded = null;\n    if (Object.keys(fragmentEntity.range).length) {\n      fragmentEntity.buffered = true;\n      const endList = fragmentEntity.body.endList = frag.endList || fragmentEntity.body.endList;\n      if (endList) {\n        this.endListFragments[fragmentEntity.body.type] = fragmentEntity;\n      }\n      if (!isPartial(fragmentEntity)) {\n        // Remove older fragment parts from lookup after frag is tracked as buffered\n        this.removeParts(frag.sn - 1, frag.type);\n      }\n    } else {\n      // remove fragment if nothing was appended\n      this.removeFragment(fragmentEntity.body);\n    }\n  }\n  removeParts(snToKeep, levelType) {\n    const activeParts = this.activePartLists[levelType];\n    if (!activeParts) {\n      return;\n    }\n    this.activePartLists[levelType] = filterParts(activeParts, part => part.fragment.sn >= snToKeep);\n  }\n  fragBuffered(frag, force) {\n    const fragKey = getFragmentKey(frag);\n    let fragmentEntity = this.fragments[fragKey];\n    if (!fragmentEntity && force) {\n      fragmentEntity = this.fragments[fragKey] = {\n        body: frag,\n        appendedPTS: null,\n        loaded: null,\n        buffered: false,\n        range: Object.create(null)\n      };\n      if (frag.gap) {\n        this.hasGaps = true;\n      }\n    }\n    if (fragmentEntity) {\n      fragmentEntity.loaded = null;\n      fragmentEntity.buffered = true;\n    }\n  }\n  getBufferedTimes(fragment, part, partial, timeRange) {\n    const buffered = {\n      time: [],\n      partial\n    };\n    const startPTS = fragment.start;\n    const endPTS = fragment.end;\n    const minEndPTS = fragment.minEndPTS || endPTS;\n    const maxStartPTS = fragment.maxStartPTS || startPTS;\n    for (let i = 0; i < timeRange.length; i++) {\n      const startTime = timeRange.start(i) - this.bufferPadding;\n      const endTime = timeRange.end(i) + this.bufferPadding;\n      if (maxStartPTS >= startTime && minEndPTS <= endTime) {\n        // Fragment is entirely contained in buffer\n        // No need to check the other timeRange times since it's completely playable\n        buffered.time.push({\n          startPTS: Math.max(startPTS, timeRange.start(i)),\n          endPTS: Math.min(endPTS, timeRange.end(i))\n        });\n        break;\n      } else if (startPTS < endTime && endPTS > startTime) {\n        const start = Math.max(startPTS, timeRange.start(i));\n        const end = Math.min(endPTS, timeRange.end(i));\n        if (end > start) {\n          buffered.partial = true;\n          // Check for intersection with buffer\n          // Get playable sections of the fragment\n          buffered.time.push({\n            startPTS: start,\n            endPTS: end\n          });\n        }\n      } else if (endPTS <= startTime) {\n        // No need to check the rest of the timeRange as it is in order\n        break;\n      }\n    }\n    return buffered;\n  }\n\n  /**\n   * Gets the partial fragment for a certain time\n   */\n  getPartialFragment(time) {\n    let bestFragment = null;\n    let timePadding;\n    let startTime;\n    let endTime;\n    let bestOverlap = 0;\n    const {\n      bufferPadding,\n      fragments\n    } = this;\n    Object.keys(fragments).forEach(key => {\n      const fragmentEntity = fragments[key];\n      if (!fragmentEntity) {\n        return;\n      }\n      if (isPartial(fragmentEntity)) {\n        startTime = fragmentEntity.body.start - bufferPadding;\n        endTime = fragmentEntity.body.end + bufferPadding;\n        if (time >= startTime && time <= endTime) {\n          // Use the fragment that has the most padding from start and end time\n          timePadding = Math.min(time - startTime, endTime - time);\n          if (bestOverlap <= timePadding) {\n            bestFragment = fragmentEntity.body;\n            bestOverlap = timePadding;\n          }\n        }\n      }\n    });\n    return bestFragment;\n  }\n  isEndListAppended(type) {\n    const lastFragmentEntity = this.endListFragments[type];\n    return lastFragmentEntity !== undefined && (lastFragmentEntity.buffered || isPartial(lastFragmentEntity));\n  }\n  getState(fragment) {\n    const fragKey = getFragmentKey(fragment);\n    const fragmentEntity = this.fragments[fragKey];\n    if (fragmentEntity) {\n      if (!fragmentEntity.buffered) {\n        return FragmentState.APPENDING;\n      } else if (isPartial(fragmentEntity)) {\n        return FragmentState.PARTIAL;\n      } else {\n        return FragmentState.OK;\n      }\n    }\n    return FragmentState.NOT_LOADED;\n  }\n  isTimeBuffered(startPTS, endPTS, timeRange) {\n    let startTime;\n    let endTime;\n    for (let i = 0; i < timeRange.length; i++) {\n      startTime = timeRange.start(i) - this.bufferPadding;\n      endTime = timeRange.end(i) + this.bufferPadding;\n      if (startPTS >= startTime && endPTS <= endTime) {\n        return true;\n      }\n      if (endPTS <= startTime) {\n        // No need to check the rest of the timeRange as it is in order\n        return false;\n      }\n    }\n    return false;\n  }\n  onManifestLoading() {\n    this.removeAllFragments();\n  }\n  onFragLoaded(event, data) {\n    // don't track initsegment (for which sn is not a number)\n    // don't track frags used for bitrateTest, they're irrelevant.\n    if (data.frag.sn === 'initSegment' || data.frag.bitrateTest) {\n      return;\n    }\n    const frag = data.frag;\n    // Fragment entity `loaded` FragLoadedData is null when loading parts\n    const loaded = data.part ? null : data;\n    const fragKey = getFragmentKey(frag);\n    this.fragments[fragKey] = {\n      body: frag,\n      appendedPTS: null,\n      loaded,\n      buffered: false,\n      range: Object.create(null)\n    };\n  }\n  onBufferAppended(event, data) {\n    const {\n      frag,\n      part,\n      timeRanges,\n      type\n    } = data;\n    if (frag.sn === 'initSegment') {\n      return;\n    }\n    const playlistType = frag.type;\n    if (part) {\n      let activeParts = this.activePartLists[playlistType];\n      if (!activeParts) {\n        this.activePartLists[playlistType] = activeParts = [];\n      }\n      activeParts.push(part);\n    }\n    // Store the latest timeRanges loaded in the buffer\n    this.timeRanges = timeRanges;\n    const timeRange = timeRanges[type];\n    this.detectEvictedFragments(type, timeRange, playlistType, part);\n  }\n  onFragBuffered(event, data) {\n    this.detectPartialFragments(data);\n  }\n  hasFragment(fragment) {\n    const fragKey = getFragmentKey(fragment);\n    return !!this.fragments[fragKey];\n  }\n  hasFragments(type) {\n    const {\n      fragments\n    } = this;\n    const keys = Object.keys(fragments);\n    if (!type) {\n      return keys.length > 0;\n    }\n    for (let i = keys.length; i--;) {\n      const fragmentEntity = fragments[keys[i]];\n      if ((fragmentEntity == null ? void 0 : fragmentEntity.body.type) === type) {\n        return true;\n      }\n    }\n    return false;\n  }\n  hasParts(type) {\n    var _this$activePartLists;\n    return !!((_this$activePartLists = this.activePartLists[type]) != null && _this$activePartLists.length);\n  }\n  removeFragmentsInRange(start, end, playlistType, withGapOnly, unbufferedOnly) {\n    if (withGapOnly && !this.hasGaps) {\n      return;\n    }\n    Object.keys(this.fragments).forEach(key => {\n      const fragmentEntity = this.fragments[key];\n      if (!fragmentEntity) {\n        return;\n      }\n      const frag = fragmentEntity.body;\n      if (frag.type !== playlistType || withGapOnly && !frag.gap) {\n        return;\n      }\n      if (frag.start < end && frag.end > start && (fragmentEntity.buffered || unbufferedOnly)) {\n        this.removeFragment(frag);\n      }\n    });\n  }\n  removeFragment(fragment) {\n    const fragKey = getFragmentKey(fragment);\n    fragment.clearElementaryStreamInfo();\n    const activeParts = this.activePartLists[fragment.type];\n    if (activeParts) {\n      const snToRemove = fragment.sn;\n      this.activePartLists[fragment.type] = filterParts(activeParts, part => part.fragment.sn !== snToRemove);\n    }\n    delete this.fragments[fragKey];\n    if (fragment.endList) {\n      delete this.endListFragments[fragment.type];\n    }\n  }\n  removeAllFragments() {\n    var _this$hls, _this$hls$latestLevel;\n    this.fragments = Object.create(null);\n    this.endListFragments = Object.create(null);\n    this.activePartLists = Object.create(null);\n    this.hasGaps = false;\n    const partlist = (_this$hls = this.hls) == null ? void 0 : (_this$hls$latestLevel = _this$hls.latestLevelDetails) == null ? void 0 : _this$hls$latestLevel.partList;\n    if (partlist) {\n      partlist.forEach(part => part.clearElementaryStreamInfo());\n    }\n  }\n}\nfunction isPartial(fragmentEntity) {\n  var _fragmentEntity$range, _fragmentEntity$range2, _fragmentEntity$range3;\n  return fragmentEntity.buffered && (fragmentEntity.body.gap || ((_fragmentEntity$range = fragmentEntity.range.video) == null ? void 0 : _fragmentEntity$range.partial) || ((_fragmentEntity$range2 = fragmentEntity.range.audio) == null ? void 0 : _fragmentEntity$range2.partial) || ((_fragmentEntity$range3 = fragmentEntity.range.audiovideo) == null ? void 0 : _fragmentEntity$range3.partial));\n}\nfunction getFragmentKey(fragment) {\n  return `${fragment.type}_${fragment.level}_${fragment.sn}`;\n}\nfunction filterParts(partList, predicate) {\n  return partList.filter(part => {\n    const keep = predicate(part);\n    if (!keep) {\n      part.clearElementaryStreamInfo();\n    }\n    return keep;\n  });\n}\n\nvar DecrypterAesMode = {\n  cbc: 0,\n  ctr: 1\n};\n\nclass AESCrypto {\n  constructor(subtle, iv, aesMode) {\n    this.subtle = void 0;\n    this.aesIV = void 0;\n    this.aesMode = void 0;\n    this.subtle = subtle;\n    this.aesIV = iv;\n    this.aesMode = aesMode;\n  }\n  decrypt(data, key) {\n    switch (this.aesMode) {\n      case DecrypterAesMode.cbc:\n        return this.subtle.decrypt({\n          name: 'AES-CBC',\n          iv: this.aesIV\n        }, key, data);\n      case DecrypterAesMode.ctr:\n        return this.subtle.decrypt({\n          name: 'AES-CTR',\n          counter: this.aesIV,\n          length: 64\n        },\n        //64 : NIST SP800-38A standard suggests that the counter should occupy half of the counter block\n        key, data);\n      default:\n        throw new Error(`[AESCrypto] invalid aes mode ${this.aesMode}`);\n    }\n  }\n}\n\n// PKCS7\nfunction removePadding(array) {\n  const outputBytes = array.byteLength;\n  const paddingBytes = outputBytes && new DataView(array.buffer).getUint8(outputBytes - 1);\n  if (paddingBytes) {\n    return array.slice(0, outputBytes - paddingBytes);\n  }\n  return array;\n}\nclass AESDecryptor {\n  constructor() {\n    this.rcon = [0x0, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\n    this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];\n    this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];\n    this.sBox = new Uint32Array(256);\n    this.invSBox = new Uint32Array(256);\n    this.key = new Uint32Array(0);\n    this.ksRows = 0;\n    this.keySize = 0;\n    this.keySchedule = void 0;\n    this.invKeySchedule = void 0;\n    this.initTable();\n  }\n\n  // Using view.getUint32() also swaps the byte order.\n  uint8ArrayToUint32Array_(arrayBuffer) {\n    const view = new DataView(arrayBuffer);\n    const newArray = new Uint32Array(4);\n    for (let i = 0; i < 4; i++) {\n      newArray[i] = view.getUint32(i * 4);\n    }\n    return newArray;\n  }\n  initTable() {\n    const sBox = this.sBox;\n    const invSBox = this.invSBox;\n    const subMix = this.subMix;\n    const subMix0 = subMix[0];\n    const subMix1 = subMix[1];\n    const subMix2 = subMix[2];\n    const subMix3 = subMix[3];\n    const invSubMix = this.invSubMix;\n    const invSubMix0 = invSubMix[0];\n    const invSubMix1 = invSubMix[1];\n    const invSubMix2 = invSubMix[2];\n    const invSubMix3 = invSubMix[3];\n    const d = new Uint32Array(256);\n    let x = 0;\n    let xi = 0;\n    let i = 0;\n    for (i = 0; i < 256; i++) {\n      if (i < 128) {\n        d[i] = i << 1;\n      } else {\n        d[i] = i << 1 ^ 0x11b;\n      }\n    }\n    for (i = 0; i < 256; i++) {\n      let sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;\n      sx = sx >>> 8 ^ sx & 0xff ^ 0x63;\n      sBox[x] = sx;\n      invSBox[sx] = x;\n\n      // Compute multiplication\n      const x2 = d[x];\n      const x4 = d[x2];\n      const x8 = d[x4];\n\n      // Compute sub/invSub bytes, mix columns tables\n      let t = d[sx] * 0x101 ^ sx * 0x1010100;\n      subMix0[x] = t << 24 | t >>> 8;\n      subMix1[x] = t << 16 | t >>> 16;\n      subMix2[x] = t << 8 | t >>> 24;\n      subMix3[x] = t;\n\n      // Compute inv sub bytes, inv mix columns tables\n      t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;\n      invSubMix0[sx] = t << 24 | t >>> 8;\n      invSubMix1[sx] = t << 16 | t >>> 16;\n      invSubMix2[sx] = t << 8 | t >>> 24;\n      invSubMix3[sx] = t;\n\n      // Compute next counter\n      if (!x) {\n        x = xi = 1;\n      } else {\n        x = x2 ^ d[d[d[x8 ^ x2]]];\n        xi ^= d[d[xi]];\n      }\n    }\n  }\n  expandKey(keyBuffer) {\n    // convert keyBuffer to Uint32Array\n    const key = this.uint8ArrayToUint32Array_(keyBuffer);\n    let sameKey = true;\n    let offset = 0;\n    while (offset < key.length && sameKey) {\n      sameKey = key[offset] === this.key[offset];\n      offset++;\n    }\n    if (sameKey) {\n      return;\n    }\n    this.key = key;\n    const keySize = this.keySize = key.length;\n    if (keySize !== 4 && keySize !== 6 && keySize !== 8) {\n      throw new Error('Invalid aes key size=' + keySize);\n    }\n    const ksRows = this.ksRows = (keySize + 6 + 1) * 4;\n    let ksRow;\n    let invKsRow;\n    const keySchedule = this.keySchedule = new Uint32Array(ksRows);\n    const invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);\n    const sbox = this.sBox;\n    const rcon = this.rcon;\n    const invSubMix = this.invSubMix;\n    const invSubMix0 = invSubMix[0];\n    const invSubMix1 = invSubMix[1];\n    const invSubMix2 = invSubMix[2];\n    const invSubMix3 = invSubMix[3];\n    let prev;\n    let t;\n    for (ksRow = 0; ksRow < ksRows; ksRow++) {\n      if (ksRow < keySize) {\n        prev = keySchedule[ksRow] = key[ksRow];\n        continue;\n      }\n      t = prev;\n      if (ksRow % keySize === 0) {\n        // Rot word\n        t = t << 8 | t >>> 24;\n\n        // Sub word\n        t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];\n\n        // Mix Rcon\n        t ^= rcon[ksRow / keySize | 0] << 24;\n      } else if (keySize > 6 && ksRow % keySize === 4) {\n        // Sub word\n        t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];\n      }\n      keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;\n    }\n    for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {\n      ksRow = ksRows - invKsRow;\n      if (invKsRow & 3) {\n        t = keySchedule[ksRow];\n      } else {\n        t = keySchedule[ksRow - 4];\n      }\n      if (invKsRow < 4 || ksRow <= 4) {\n        invKeySchedule[invKsRow] = t;\n      } else {\n        invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 0xff]] ^ invSubMix2[sbox[t >>> 8 & 0xff]] ^ invSubMix3[sbox[t & 0xff]];\n      }\n      invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;\n    }\n  }\n\n  // Adding this as a method greatly improves performance.\n  networkToHostOrderSwap(word) {\n    return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;\n  }\n  decrypt(inputArrayBuffer, offset, aesIV) {\n    const nRounds = this.keySize + 6;\n    const invKeySchedule = this.invKeySchedule;\n    const invSBOX = this.invSBox;\n    const invSubMix = this.invSubMix;\n    const invSubMix0 = invSubMix[0];\n    const invSubMix1 = invSubMix[1];\n    const invSubMix2 = invSubMix[2];\n    const invSubMix3 = invSubMix[3];\n    const initVector = this.uint8ArrayToUint32Array_(aesIV);\n    let initVector0 = initVector[0];\n    let initVector1 = initVector[1];\n    let initVector2 = initVector[2];\n    let initVector3 = initVector[3];\n    const inputInt32 = new Int32Array(inputArrayBuffer);\n    const outputInt32 = new Int32Array(inputInt32.length);\n    let t0, t1, t2, t3;\n    let s0, s1, s2, s3;\n    let inputWords0, inputWords1, inputWords2, inputWords3;\n    let ksRow, i;\n    const swapWord = this.networkToHostOrderSwap;\n    while (offset < inputInt32.length) {\n      inputWords0 = swapWord(inputInt32[offset]);\n      inputWords1 = swapWord(inputInt32[offset + 1]);\n      inputWords2 = swapWord(inputInt32[offset + 2]);\n      inputWords3 = swapWord(inputInt32[offset + 3]);\n      s0 = inputWords0 ^ invKeySchedule[0];\n      s1 = inputWords3 ^ invKeySchedule[1];\n      s2 = inputWords2 ^ invKeySchedule[2];\n      s3 = inputWords1 ^ invKeySchedule[3];\n      ksRow = 4;\n\n      // Iterate through the rounds of decryption\n      for (i = 1; i < nRounds; i++) {\n        t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 0xff] ^ invSubMix2[s2 >> 8 & 0xff] ^ invSubMix3[s3 & 0xff] ^ invKeySchedule[ksRow];\n        t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 0xff] ^ invSubMix2[s3 >> 8 & 0xff] ^ invSubMix3[s0 & 0xff] ^ invKeySchedule[ksRow + 1];\n        t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 0xff] ^ invSubMix2[s0 >> 8 & 0xff] ^ invSubMix3[s1 & 0xff] ^ invKeySchedule[ksRow + 2];\n        t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 0xff] ^ invSubMix2[s1 >> 8 & 0xff] ^ invSubMix3[s2 & 0xff] ^ invKeySchedule[ksRow + 3];\n        // Update state\n        s0 = t0;\n        s1 = t1;\n        s2 = t2;\n        s3 = t3;\n        ksRow = ksRow + 4;\n      }\n\n      // Shift rows, sub bytes, add round key\n      t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 0xff] << 16 ^ invSBOX[s2 >> 8 & 0xff] << 8 ^ invSBOX[s3 & 0xff] ^ invKeySchedule[ksRow];\n      t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 0xff] << 16 ^ invSBOX[s3 >> 8 & 0xff] << 8 ^ invSBOX[s0 & 0xff] ^ invKeySchedule[ksRow + 1];\n      t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 0xff] << 16 ^ invSBOX[s0 >> 8 & 0xff] << 8 ^ invSBOX[s1 & 0xff] ^ invKeySchedule[ksRow + 2];\n      t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 0xff] << 16 ^ invSBOX[s1 >> 8 & 0xff] << 8 ^ invSBOX[s2 & 0xff] ^ invKeySchedule[ksRow + 3];\n\n      // Write\n      outputInt32[offset] = swapWord(t0 ^ initVector0);\n      outputInt32[offset + 1] = swapWord(t3 ^ initVector1);\n      outputInt32[offset + 2] = swapWord(t2 ^ initVector2);\n      outputInt32[offset + 3] = swapWord(t1 ^ initVector3);\n\n      // reset initVector to last 4 unsigned int\n      initVector0 = inputWords0;\n      initVector1 = inputWords1;\n      initVector2 = inputWords2;\n      initVector3 = inputWords3;\n      offset = offset + 4;\n    }\n    return outputInt32.buffer;\n  }\n}\n\nclass FastAESKey {\n  constructor(subtle, key, aesMode) {\n    this.subtle = void 0;\n    this.key = void 0;\n    this.aesMode = void 0;\n    this.subtle = subtle;\n    this.key = key;\n    this.aesMode = aesMode;\n  }\n  expandKey() {\n    const subtleAlgoName = getSubtleAlgoName(this.aesMode);\n    return this.subtle.importKey('raw', this.key, {\n      name: subtleAlgoName\n    }, false, ['encrypt', 'decrypt']);\n  }\n}\nfunction getSubtleAlgoName(aesMode) {\n  switch (aesMode) {\n    case DecrypterAesMode.cbc:\n      return 'AES-CBC';\n    case DecrypterAesMode.ctr:\n      return 'AES-CTR';\n    default:\n      throw new Error(`[FastAESKey] invalid aes mode ${aesMode}`);\n  }\n}\n\nconst CHUNK_SIZE = 16; // 16 bytes, 128 bits\n\nclass Decrypter {\n  constructor(config, {\n    removePKCS7Padding = true\n  } = {}) {\n    this.logEnabled = true;\n    this.removePKCS7Padding = void 0;\n    this.subtle = null;\n    this.softwareDecrypter = null;\n    this.key = null;\n    this.fastAesKey = null;\n    this.remainderData = null;\n    this.currentIV = null;\n    this.currentResult = null;\n    this.useSoftware = void 0;\n    this.enableSoftwareAES = void 0;\n    this.enableSoftwareAES = config.enableSoftwareAES;\n    this.removePKCS7Padding = removePKCS7Padding;\n    // built in decryptor expects PKCS7 padding\n    if (removePKCS7Padding) {\n      try {\n        const browserCrypto = self.crypto;\n        if (browserCrypto) {\n          this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\n        }\n      } catch (e) {\n        /* no-op */\n      }\n    }\n    this.useSoftware = !this.subtle;\n  }\n  destroy() {\n    this.subtle = null;\n    this.softwareDecrypter = null;\n    this.key = null;\n    this.fastAesKey = null;\n    this.remainderData = null;\n    this.currentIV = null;\n    this.currentResult = null;\n  }\n  isSync() {\n    return this.useSoftware;\n  }\n  flush() {\n    const {\n      currentResult,\n      remainderData\n    } = this;\n    if (!currentResult || remainderData) {\n      this.reset();\n      return null;\n    }\n    const data = new Uint8Array(currentResult);\n    this.reset();\n    if (this.removePKCS7Padding) {\n      return removePadding(data);\n    }\n    return data;\n  }\n  reset() {\n    this.currentResult = null;\n    this.currentIV = null;\n    this.remainderData = null;\n    if (this.softwareDecrypter) {\n      this.softwareDecrypter = null;\n    }\n  }\n  decrypt(data, key, iv, aesMode) {\n    if (this.useSoftware) {\n      return new Promise((resolve, reject) => {\n        const dataView = ArrayBuffer.isView(data) ? data : new Uint8Array(data);\n        this.softwareDecrypt(dataView, key, iv, aesMode);\n        const decryptResult = this.flush();\n        if (decryptResult) {\n          resolve(decryptResult.buffer);\n        } else {\n          reject(new Error('[softwareDecrypt] Failed to decrypt data'));\n        }\n      });\n    }\n    return this.webCryptoDecrypt(new Uint8Array(data), key, iv, aesMode);\n  }\n\n  // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached\n  // data is handled in the flush() call\n  softwareDecrypt(data, key, iv, aesMode) {\n    const {\n      currentIV,\n      currentResult,\n      remainderData\n    } = this;\n    if (aesMode !== DecrypterAesMode.cbc || key.byteLength !== 16) {\n      logger.warn('SoftwareDecrypt: can only handle AES-128-CBC');\n      return null;\n    }\n    this.logOnce('JS AES decrypt');\n    // The output is staggered during progressive parsing - the current result is cached, and emitted on the next call\n    // This is done in order to strip PKCS7 padding, which is found at the end of each segment. We only know we've reached\n    // the end on flush(), but by that time we have already received all bytes for the segment.\n    // Progressive decryption does not work with WebCrypto\n\n    if (remainderData) {\n      data = appendUint8Array(remainderData, data);\n      this.remainderData = null;\n    }\n\n    // Byte length must be a multiple of 16 (AES-128 = 128 bit blocks = 16 bytes)\n    const currentChunk = this.getValidChunk(data);\n    if (!currentChunk.length) {\n      return null;\n    }\n    if (currentIV) {\n      iv = currentIV;\n    }\n    let softwareDecrypter = this.softwareDecrypter;\n    if (!softwareDecrypter) {\n      softwareDecrypter = this.softwareDecrypter = new AESDecryptor();\n    }\n    softwareDecrypter.expandKey(key);\n    const result = currentResult;\n    this.currentResult = softwareDecrypter.decrypt(currentChunk.buffer, 0, iv);\n    this.currentIV = currentChunk.slice(-16).buffer;\n    if (!result) {\n      return null;\n    }\n    return result;\n  }\n  webCryptoDecrypt(data, key, iv, aesMode) {\n    if (this.key !== key || !this.fastAesKey) {\n      if (!this.subtle) {\n        return Promise.resolve(this.onWebCryptoError(data, key, iv, aesMode));\n      }\n      this.key = key;\n      this.fastAesKey = new FastAESKey(this.subtle, key, aesMode);\n    }\n    return this.fastAesKey.expandKey().then(aesKey => {\n      // decrypt using web crypto\n      if (!this.subtle) {\n        return Promise.reject(new Error('web crypto not initialized'));\n      }\n      this.logOnce('WebCrypto AES decrypt');\n      const crypto = new AESCrypto(this.subtle, new Uint8Array(iv), aesMode);\n      return crypto.decrypt(data.buffer, aesKey);\n    }).catch(err => {\n      logger.warn(`[decrypter]: WebCrypto Error, disable WebCrypto API, ${err.name}: ${err.message}`);\n      return this.onWebCryptoError(data, key, iv, aesMode);\n    });\n  }\n  onWebCryptoError(data, key, iv, aesMode) {\n    const enableSoftwareAES = this.enableSoftwareAES;\n    if (enableSoftwareAES) {\n      this.useSoftware = true;\n      this.logEnabled = true;\n      this.softwareDecrypt(data, key, iv, aesMode);\n      const decryptResult = this.flush();\n      if (decryptResult) {\n        return decryptResult.buffer;\n      }\n    }\n    throw new Error('WebCrypto' + (enableSoftwareAES ? ' and softwareDecrypt' : '') + ': failed to decrypt data');\n  }\n  getValidChunk(data) {\n    let currentChunk = data;\n    const splitPoint = data.length - data.length % CHUNK_SIZE;\n    if (splitPoint !== data.length) {\n      currentChunk = data.slice(0, splitPoint);\n      this.remainderData = data.slice(splitPoint);\n    }\n    return currentChunk;\n  }\n  logOnce(msg) {\n    if (!this.logEnabled) {\n      return;\n    }\n    logger.log(`[decrypter]: ${msg}`);\n    this.logEnabled = false;\n  }\n}\n\nconst MIN_CHUNK_SIZE = Math.pow(2, 17); // 128kb\n\nclass FragmentLoader {\n  constructor(config) {\n    this.config = void 0;\n    this.loader = null;\n    this.partLoadTimeout = -1;\n    this.config = config;\n  }\n  destroy() {\n    if (this.loader) {\n      this.loader.destroy();\n      this.loader = null;\n    }\n  }\n  abort() {\n    if (this.loader) {\n      // Abort the loader for current fragment. Only one may load at any given time\n      this.loader.abort();\n    }\n  }\n  load(frag, onProgress) {\n    const url = frag.url;\n    if (!url) {\n      return Promise.reject(new LoadError({\n        type: ErrorTypes.NETWORK_ERROR,\n        details: ErrorDetails.FRAG_LOAD_ERROR,\n        fatal: false,\n        frag,\n        error: new Error(`Fragment does not have a ${url ? 'part list' : 'url'}`),\n        networkDetails: null\n      }));\n    }\n    this.abort();\n    const config = this.config;\n    const FragmentILoader = config.fLoader;\n    const DefaultILoader = config.loader;\n    return new Promise((resolve, reject) => {\n      if (this.loader) {\n        this.loader.destroy();\n      }\n      if (frag.gap) {\n        if (frag.tagList.some(tags => tags[0] === 'GAP')) {\n          reject(createGapLoadError(frag));\n          return;\n        } else {\n          // Reset temporary treatment as GAP tag\n          frag.gap = false;\n        }\n      }\n      const loader = this.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);\n      const loaderContext = createLoaderContext(frag);\n      frag.loader = loader;\n      const loadPolicy = getLoaderConfigWithoutReties(config.fragLoadPolicy.default);\n      const loaderConfig = {\n        loadPolicy,\n        timeout: loadPolicy.maxLoadTimeMs,\n        maxRetry: 0,\n        retryDelay: 0,\n        maxRetryDelay: 0,\n        highWaterMark: frag.sn === 'initSegment' ? Infinity : MIN_CHUNK_SIZE\n      };\n      // Assign frag stats to the loader's stats reference\n      frag.stats = loader.stats;\n      const callbacks = {\n        onSuccess: (response, stats, context, networkDetails) => {\n          this.resetLoader(frag, loader);\n          let payload = response.data;\n          if (context.resetIV && frag.decryptdata) {\n            frag.decryptdata.iv = new Uint8Array(payload.slice(0, 16));\n            payload = payload.slice(16);\n          }\n          resolve({\n            frag,\n            part: null,\n            payload,\n            networkDetails\n          });\n        },\n        onError: (response, context, networkDetails, stats) => {\n          this.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.FRAG_LOAD_ERROR,\n            fatal: false,\n            frag,\n            response: _objectSpread2({\n              url,\n              data: undefined\n            }, response),\n            error: new Error(`HTTP Error ${response.code} ${response.text}`),\n            networkDetails,\n            stats\n          }));\n        },\n        onAbort: (stats, context, networkDetails) => {\n          this.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.INTERNAL_ABORTED,\n            fatal: false,\n            frag,\n            error: new Error('Aborted'),\n            networkDetails,\n            stats\n          }));\n        },\n        onTimeout: (stats, context, networkDetails) => {\n          this.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.FRAG_LOAD_TIMEOUT,\n            fatal: false,\n            frag,\n            error: new Error(`Timeout after ${loaderConfig.timeout}ms`),\n            networkDetails,\n            stats\n          }));\n        }\n      };\n      if (onProgress) {\n        callbacks.onProgress = (stats, context, data, networkDetails) => onProgress({\n          frag,\n          part: null,\n          payload: data,\n          networkDetails\n        });\n      }\n      loader.load(loaderContext, loaderConfig, callbacks);\n    });\n  }\n  loadPart(frag, part, onProgress) {\n    this.abort();\n    const config = this.config;\n    const FragmentILoader = config.fLoader;\n    const DefaultILoader = config.loader;\n    return new Promise((resolve, reject) => {\n      if (this.loader) {\n        this.loader.destroy();\n      }\n      if (frag.gap || part.gap) {\n        reject(createGapLoadError(frag, part));\n        return;\n      }\n      const loader = this.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);\n      const loaderContext = createLoaderContext(frag, part);\n      frag.loader = loader;\n      // Should we define another load policy for parts?\n      const loadPolicy = getLoaderConfigWithoutReties(config.fragLoadPolicy.default);\n      const loaderConfig = {\n        loadPolicy,\n        timeout: loadPolicy.maxLoadTimeMs,\n        maxRetry: 0,\n        retryDelay: 0,\n        maxRetryDelay: 0,\n        highWaterMark: MIN_CHUNK_SIZE\n      };\n      // Assign part stats to the loader's stats reference\n      part.stats = loader.stats;\n      loader.load(loaderContext, loaderConfig, {\n        onSuccess: (response, stats, context, networkDetails) => {\n          this.resetLoader(frag, loader);\n          this.updateStatsFromPart(frag, part);\n          const partLoadedData = {\n            frag,\n            part,\n            payload: response.data,\n            networkDetails\n          };\n          onProgress(partLoadedData);\n          resolve(partLoadedData);\n        },\n        onError: (response, context, networkDetails, stats) => {\n          this.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.FRAG_LOAD_ERROR,\n            fatal: false,\n            frag,\n            part,\n            response: _objectSpread2({\n              url: loaderContext.url,\n              data: undefined\n            }, response),\n            error: new Error(`HTTP Error ${response.code} ${response.text}`),\n            networkDetails,\n            stats\n          }));\n        },\n        onAbort: (stats, context, networkDetails) => {\n          frag.stats.aborted = part.stats.aborted;\n          this.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.INTERNAL_ABORTED,\n            fatal: false,\n            frag,\n            part,\n            error: new Error('Aborted'),\n            networkDetails,\n            stats\n          }));\n        },\n        onTimeout: (stats, context, networkDetails) => {\n          this.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.FRAG_LOAD_TIMEOUT,\n            fatal: false,\n            frag,\n            part,\n            error: new Error(`Timeout after ${loaderConfig.timeout}ms`),\n            networkDetails,\n            stats\n          }));\n        }\n      });\n    });\n  }\n  updateStatsFromPart(frag, part) {\n    const fragStats = frag.stats;\n    const partStats = part.stats;\n    const partTotal = partStats.total;\n    fragStats.loaded += partStats.loaded;\n    if (partTotal) {\n      const estTotalParts = Math.round(frag.duration / part.duration);\n      const estLoadedParts = Math.min(Math.round(fragStats.loaded / partTotal), estTotalParts);\n      const estRemainingParts = estTotalParts - estLoadedParts;\n      const estRemainingBytes = estRemainingParts * Math.round(fragStats.loaded / estLoadedParts);\n      fragStats.total = fragStats.loaded + estRemainingBytes;\n    } else {\n      fragStats.total = Math.max(fragStats.loaded, fragStats.total);\n    }\n    const fragLoading = fragStats.loading;\n    const partLoading = partStats.loading;\n    if (fragLoading.start) {\n      // add to fragment loader latency\n      fragLoading.first += partLoading.first - partLoading.start;\n    } else {\n      fragLoading.start = partLoading.start;\n      fragLoading.first = partLoading.first;\n    }\n    fragLoading.end = partLoading.end;\n  }\n  resetLoader(frag, loader) {\n    frag.loader = null;\n    if (this.loader === loader) {\n      self.clearTimeout(this.partLoadTimeout);\n      this.loader = null;\n    }\n    loader.destroy();\n  }\n}\nfunction createLoaderContext(frag, part = null) {\n  const segment = part || frag;\n  const loaderContext = {\n    frag,\n    part,\n    responseType: 'arraybuffer',\n    url: segment.url,\n    headers: {},\n    rangeStart: 0,\n    rangeEnd: 0\n  };\n  const start = segment.byteRangeStartOffset;\n  const end = segment.byteRangeEndOffset;\n  if (isFiniteNumber(start) && isFiniteNumber(end)) {\n    var _frag$decryptdata;\n    let byteRangeStart = start;\n    let byteRangeEnd = end;\n    if (frag.sn === 'initSegment' && isMethodFullSegmentAesCbc((_frag$decryptdata = frag.decryptdata) == null ? void 0 : _frag$decryptdata.method)) {\n      // MAP segment encrypted with method 'AES-128' or 'AES-256' (cbc), when served with HTTP Range,\n      // has the unencrypted size specified in the range.\n      // Ref: https://tools.ietf.org/html/draft-pantos-hls-rfc8216bis-08#section-6.3.6\n      const fragmentLen = end - start;\n      if (fragmentLen % 16) {\n        byteRangeEnd = end + (16 - fragmentLen % 16);\n      }\n      if (start !== 0) {\n        loaderContext.resetIV = true;\n        byteRangeStart = start - 16;\n      }\n    }\n    loaderContext.rangeStart = byteRangeStart;\n    loaderContext.rangeEnd = byteRangeEnd;\n  }\n  return loaderContext;\n}\nfunction createGapLoadError(frag, part) {\n  const error = new Error(`GAP ${frag.gap ? 'tag' : 'attribute'} found`);\n  const errorData = {\n    type: ErrorTypes.MEDIA_ERROR,\n    details: ErrorDetails.FRAG_GAP,\n    fatal: false,\n    frag,\n    error,\n    networkDetails: null\n  };\n  if (part) {\n    errorData.part = part;\n  }\n  (part ? part : frag).stats.aborted = true;\n  return new LoadError(errorData);\n}\nfunction isMethodFullSegmentAesCbc(method) {\n  return method === 'AES-128' || method === 'AES-256';\n}\nclass LoadError extends Error {\n  constructor(data) {\n    super(data.error.message);\n    this.data = void 0;\n    this.data = data;\n  }\n}\n\n/**\n * @ignore\n * Sub-class specialization of EventHandler base class.\n *\n * TaskLoop allows to schedule a task function being called (optionnaly repeatedly) on the main loop,\n * scheduled asynchroneously, avoiding recursive calls in the same tick.\n *\n * The task itself is implemented in `doTick`. It can be requested and called for single execution\n * using the `tick` method.\n *\n * It will be assured that the task execution method (`tick`) only gets called once per main loop \"tick\",\n * no matter how often it gets requested for execution. Execution in further ticks will be scheduled accordingly.\n *\n * If further execution requests have already been scheduled on the next tick, it can be checked with `hasNextTick`,\n * and cancelled with `clearNextTick`.\n *\n * The task can be scheduled as an interval repeatedly with a period as parameter (see `setInterval`, `clearInterval`).\n *\n * Sub-classes need to implement the `doTick` method which will effectively have the task execution routine.\n *\n * Further explanations:\n *\n * The baseclass has a `tick` method that will schedule the doTick call. It may be called synchroneously\n * only for a stack-depth of one. On re-entrant calls, sub-sequent calls are scheduled for next main loop ticks.\n *\n * When the task execution (`tick` method) is called in re-entrant way this is detected and\n * we are limiting the task execution per call stack to exactly one, but scheduling/post-poning further\n * task processing on the next main loop iteration (also known as \"next tick\" in the Node/JS runtime lingo).\n */\nclass TaskLoop extends Logger {\n  constructor(label, logger) {\n    super(label, logger);\n    this._boundTick = void 0;\n    this._tickTimer = null;\n    this._tickInterval = null;\n    this._tickCallCount = 0;\n    this._boundTick = this.tick.bind(this);\n  }\n  destroy() {\n    this.onHandlerDestroying();\n    this.onHandlerDestroyed();\n  }\n  onHandlerDestroying() {\n    // clear all timers before unregistering from event bus\n    this.clearNextTick();\n    this.clearInterval();\n  }\n  onHandlerDestroyed() {}\n  hasInterval() {\n    return !!this._tickInterval;\n  }\n  hasNextTick() {\n    return !!this._tickTimer;\n  }\n\n  /**\n   * @param millis - Interval time (ms)\n   * @eturns True when interval has been scheduled, false when already scheduled (no effect)\n   */\n  setInterval(millis) {\n    if (!this._tickInterval) {\n      this._tickCallCount = 0;\n      this._tickInterval = self.setInterval(this._boundTick, millis);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @returns True when interval was cleared, false when none was set (no effect)\n   */\n  clearInterval() {\n    if (this._tickInterval) {\n      self.clearInterval(this._tickInterval);\n      this._tickInterval = null;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @returns True when timeout was cleared, false when none was set (no effect)\n   */\n  clearNextTick() {\n    if (this._tickTimer) {\n      self.clearTimeout(this._tickTimer);\n      this._tickTimer = null;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Will call the subclass doTick implementation in this main loop tick\n   * or in the next one (via setTimeout(,0)) in case it has already been called\n   * in this tick (in case this is a re-entrant call).\n   */\n  tick() {\n    this._tickCallCount++;\n    if (this._tickCallCount === 1) {\n      this.doTick();\n      // re-entrant call to tick from previous doTick call stack\n      // -> schedule a call on the next main loop iteration to process this task processing request\n      if (this._tickCallCount > 1) {\n        // make sure only one timer exists at any time at max\n        this.tickImmediate();\n      }\n      this._tickCallCount = 0;\n    }\n  }\n  tickImmediate() {\n    this.clearNextTick();\n    this._tickTimer = self.setTimeout(this._boundTick, 0);\n  }\n\n  /**\n   * For subclass to implement task logic\n   * @abstract\n   */\n  doTick() {}\n}\n\nclass ChunkMetadata {\n  constructor(level, sn, id, size = 0, part = -1, partial = false) {\n    this.level = void 0;\n    this.sn = void 0;\n    this.part = void 0;\n    this.id = void 0;\n    this.size = void 0;\n    this.partial = void 0;\n    this.transmuxing = getNewPerformanceTiming();\n    this.buffering = {\n      audio: getNewPerformanceTiming(),\n      video: getNewPerformanceTiming(),\n      audiovideo: getNewPerformanceTiming()\n    };\n    this.level = level;\n    this.sn = sn;\n    this.id = id;\n    this.size = size;\n    this.part = part;\n    this.partial = partial;\n  }\n}\nfunction getNewPerformanceTiming() {\n  return {\n    start: 0,\n    executeStart: 0,\n    executeEnd: 0,\n    end: 0\n  };\n}\n\n/**\n * Provides methods dealing with buffer length retrieval for example.\n *\n * In general, a helper around HTML5 MediaElement TimeRanges gathered from `buffered` property.\n *\n * Also @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/buffered\n */\n\nconst noopBuffered = {\n  length: 0,\n  start: () => 0,\n  end: () => 0\n};\nclass BufferHelper {\n  /**\n   * Return true if `media`'s buffered include `position`\n   */\n  static isBuffered(media, position) {\n    if (media) {\n      const buffered = BufferHelper.getBuffered(media);\n      for (let i = buffered.length; i--;) {\n        if (position >= buffered.start(i) && position <= buffered.end(i)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  static bufferedRanges(media) {\n    if (media) {\n      const timeRanges = BufferHelper.getBuffered(media);\n      return BufferHelper.timeRangesToArray(timeRanges);\n    }\n    return [];\n  }\n  static timeRangesToArray(timeRanges) {\n    const buffered = [];\n    for (let i = 0; i < timeRanges.length; i++) {\n      buffered.push({\n        start: timeRanges.start(i),\n        end: timeRanges.end(i)\n      });\n    }\n    return buffered;\n  }\n  static bufferInfo(media, pos, maxHoleDuration) {\n    if (media) {\n      const buffered = BufferHelper.bufferedRanges(media);\n      if (buffered.length) {\n        return BufferHelper.bufferedInfo(buffered, pos, maxHoleDuration);\n      }\n    }\n    return {\n      len: 0,\n      start: pos,\n      end: pos,\n      bufferedIndex: -1\n    };\n  }\n  static bufferedInfo(buffered, pos, maxHoleDuration) {\n    pos = Math.max(0, pos);\n    // sort on buffer.start/smaller end (IE does not always return sorted buffered range)\n    if (buffered.length > 1) {\n      buffered.sort((a, b) => a.start - b.start || b.end - a.end);\n    }\n    let bufferedIndex = -1;\n    let buffered2 = [];\n    if (maxHoleDuration) {\n      // there might be some small holes between buffer time range\n      // consider that holes smaller than maxHoleDuration are irrelevant and build another\n      // buffer time range representations that discards those holes\n      for (let i = 0; i < buffered.length; i++) {\n        if (pos >= buffered[i].start && pos <= buffered[i].end) {\n          bufferedIndex = i;\n        }\n        const buf2len = buffered2.length;\n        if (buf2len) {\n          const buf2end = buffered2[buf2len - 1].end;\n          // if small hole (value between 0 or maxHoleDuration ) or overlapping (negative)\n          if (buffered[i].start - buf2end < maxHoleDuration) {\n            // merge overlapping time ranges\n            // update lastRange.end only if smaller than item.end\n            // e.g.  [ 1, 15] with  [ 2,8] => [ 1,15] (no need to modify lastRange.end)\n            // whereas [ 1, 8] with  [ 2,15] => [ 1,15] ( lastRange should switch from [1,8] to [1,15])\n            if (buffered[i].end > buf2end) {\n              buffered2[buf2len - 1].end = buffered[i].end;\n            }\n          } else {\n            // big hole\n            buffered2.push(buffered[i]);\n          }\n        } else {\n          // first value\n          buffered2.push(buffered[i]);\n        }\n      }\n    } else {\n      buffered2 = buffered;\n    }\n    let bufferLen = 0;\n    let nextStart;\n\n    // bufferStart and bufferEnd are buffer boundaries around current playback position (pos)\n    let bufferStart = pos;\n    let bufferEnd = pos;\n    for (let i = 0; i < buffered2.length; i++) {\n      const start = buffered2[i].start;\n      const end = buffered2[i].end;\n      // logger.log('buf start/end:' + buffered.start(i) + '/' + buffered.end(i));\n      if (bufferedIndex === -1 && pos >= start && pos <= end) {\n        bufferedIndex = i;\n      }\n      if (pos + maxHoleDuration >= start && pos < end) {\n        // play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length\n        bufferStart = start;\n        bufferEnd = end;\n        bufferLen = bufferEnd - pos;\n      } else if (pos + maxHoleDuration < start) {\n        nextStart = start;\n        break;\n      }\n    }\n    return {\n      len: bufferLen,\n      start: bufferStart || 0,\n      end: bufferEnd || 0,\n      nextStart,\n      buffered,\n      bufferedIndex\n    };\n  }\n\n  /**\n   * Safe method to get buffered property.\n   * SourceBuffer.buffered may throw if SourceBuffer is removed from it's MediaSource\n   */\n  static getBuffered(media) {\n    try {\n      return media.buffered || noopBuffered;\n    } catch (e) {\n      logger.log('failed to get media.buffered', e);\n      return noopBuffered;\n    }\n  }\n}\n\nconst VARIABLE_REPLACEMENT_REGEX = /\\{\\$([a-zA-Z0-9-_]+)\\}/g;\nfunction hasVariableReferences(str) {\n  return VARIABLE_REPLACEMENT_REGEX.test(str);\n}\nfunction substituteVariables(parsed, value) {\n  if (parsed.variableList !== null || parsed.hasVariableRefs) {\n    const variableList = parsed.variableList;\n    return value.replace(VARIABLE_REPLACEMENT_REGEX, variableReference => {\n      const variableName = variableReference.substring(2, variableReference.length - 1);\n      const variableValue = variableList == null ? void 0 : variableList[variableName];\n      if (variableValue === undefined) {\n        parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`Missing preceding EXT-X-DEFINE tag for Variable Reference: \"${variableName}\"`));\n        return variableReference;\n      }\n      return variableValue;\n    });\n  }\n  return value;\n}\nfunction addVariableDefinition(parsed, attr, parentUrl) {\n  let variableList = parsed.variableList;\n  if (!variableList) {\n    parsed.variableList = variableList = {};\n  }\n  let NAME;\n  let VALUE;\n  if ('QUERYPARAM' in attr) {\n    NAME = attr.QUERYPARAM;\n    try {\n      const searchParams = new self.URL(parentUrl).searchParams;\n      if (searchParams.has(NAME)) {\n        VALUE = searchParams.get(NAME);\n      } else {\n        throw new Error(`\"${NAME}\" does not match any query parameter in URI: \"${parentUrl}\"`);\n      }\n    } catch (error) {\n      parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`EXT-X-DEFINE QUERYPARAM: ${error.message}`));\n    }\n  } else {\n    NAME = attr.NAME;\n    VALUE = attr.VALUE;\n  }\n  if (NAME in variableList) {\n    parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`EXT-X-DEFINE duplicate Variable Name declarations: \"${NAME}\"`));\n  } else {\n    variableList[NAME] = VALUE || '';\n  }\n}\nfunction importVariableDefinition(parsed, attr, sourceVariableList) {\n  const IMPORT = attr.IMPORT;\n  if (sourceVariableList && IMPORT in sourceVariableList) {\n    let variableList = parsed.variableList;\n    if (!variableList) {\n      parsed.variableList = variableList = {};\n    }\n    variableList[IMPORT] = sourceVariableList[IMPORT];\n  } else {\n    parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: \"${IMPORT}\"`));\n  }\n}\n\nconst DECIMAL_RESOLUTION_REGEX = /^(\\d+)x(\\d+)$/;\nconst ATTR_LIST_REGEX = /(.+?)=(\".*?\"|.*?)(?:,|$)/g;\n\n// adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js\nclass AttrList {\n  constructor(attrs, parsed) {\n    if (typeof attrs === 'string') {\n      attrs = AttrList.parseAttrList(attrs, parsed);\n    }\n    _extends(this, attrs);\n  }\n  get clientAttrs() {\n    return Object.keys(this).filter(attr => attr.substring(0, 2) === 'X-');\n  }\n  decimalInteger(attrName) {\n    const intValue = parseInt(this[attrName], 10);\n    if (intValue > Number.MAX_SAFE_INTEGER) {\n      return Infinity;\n    }\n    return intValue;\n  }\n  hexadecimalInteger(attrName) {\n    if (this[attrName]) {\n      let stringValue = (this[attrName] || '0x').slice(2);\n      stringValue = (stringValue.length & 1 ? '0' : '') + stringValue;\n      const value = new Uint8Array(stringValue.length / 2);\n      for (let i = 0; i < stringValue.length / 2; i++) {\n        value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);\n      }\n      return value;\n    }\n    return null;\n  }\n  hexadecimalIntegerAsNumber(attrName) {\n    const intValue = parseInt(this[attrName], 16);\n    if (intValue > Number.MAX_SAFE_INTEGER) {\n      return Infinity;\n    }\n    return intValue;\n  }\n  decimalFloatingPoint(attrName) {\n    return parseFloat(this[attrName]);\n  }\n  optionalFloat(attrName, defaultValue) {\n    const value = this[attrName];\n    return value ? parseFloat(value) : defaultValue;\n  }\n  enumeratedString(attrName) {\n    return this[attrName];\n  }\n  enumeratedStringList(attrName, dict) {\n    const attrValue = this[attrName];\n    return (attrValue ? attrValue.split(/[ ,]+/) : []).reduce((result, identifier) => {\n      result[identifier.toLowerCase()] = true;\n      return result;\n    }, dict);\n  }\n  bool(attrName) {\n    return this[attrName] === 'YES';\n  }\n  decimalResolution(attrName) {\n    const res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);\n    if (res === null) {\n      return undefined;\n    }\n    return {\n      width: parseInt(res[1], 10),\n      height: parseInt(res[2], 10)\n    };\n  }\n  static parseAttrList(input, parsed) {\n    let match;\n    const attrs = {};\n    const quote = '\"';\n    ATTR_LIST_REGEX.lastIndex = 0;\n    while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {\n      const name = match[1].trim();\n      let value = match[2];\n      const quotedString = value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1;\n      let hexadecimalSequence = false;\n      if (quotedString) {\n        value = value.slice(1, -1);\n      } else {\n        switch (name) {\n          case 'IV':\n          case 'SCTE35-CMD':\n          case 'SCTE35-IN':\n          case 'SCTE35-OUT':\n            hexadecimalSequence = true;\n        }\n      }\n      if (parsed && (quotedString || hexadecimalSequence)) {\n        {\n          value = substituteVariables(parsed, value);\n        }\n      } else if (!hexadecimalSequence && !quotedString) {\n        switch (name) {\n          case 'CLOSED-CAPTIONS':\n            if (value === 'NONE') {\n              break;\n            }\n          // falls through\n          case 'ALLOWED-CPC':\n          case 'CLASS':\n          case 'ASSOC-LANGUAGE':\n          case 'AUDIO':\n          case 'BYTERANGE':\n          case 'CHANNELS':\n          case 'CHARACTERISTICS':\n          case 'CODECS':\n          case 'DATA-ID':\n          case 'END-DATE':\n          case 'GROUP-ID':\n          case 'ID':\n          case 'IMPORT':\n          case 'INSTREAM-ID':\n          case 'KEYFORMAT':\n          case 'KEYFORMATVERSIONS':\n          case 'LANGUAGE':\n          case 'NAME':\n          case 'PATHWAY-ID':\n          case 'QUERYPARAM':\n          case 'RECENTLY-REMOVED-DATERANGES':\n          case 'SERVER-URI':\n          case 'STABLE-RENDITION-ID':\n          case 'STABLE-VARIANT-ID':\n          case 'START-DATE':\n          case 'SUBTITLES':\n          case 'SUPPLEMENTAL-CODECS':\n          case 'URI':\n          case 'VALUE':\n          case 'VIDEO':\n          case 'X-ASSET-LIST':\n          case 'X-ASSET-URI':\n            // Since we are not checking tag:attribute combination, just warn rather than ignoring attribute\n            logger.warn(`${input}: attribute ${name} is missing quotes`);\n          // continue;\n        }\n      }\n      attrs[name] = value;\n    }\n    return attrs;\n  }\n}\n\n// Avoid exporting const enum so that these values can be inlined\n\nconst CLASS_INTERSTITIAL = 'com.apple.hls.interstitial';\nfunction isDateRangeCueAttribute(attrName) {\n  return attrName !== \"ID\" && attrName !== \"CLASS\" && attrName !== \"CUE\" && attrName !== \"START-DATE\" && attrName !== \"DURATION\" && attrName !== \"END-DATE\" && attrName !== \"END-ON-NEXT\";\n}\nfunction isSCTE35Attribute(attrName) {\n  return attrName === \"SCTE35-OUT\" || attrName === \"SCTE35-IN\" || attrName === \"SCTE35-CMD\";\n}\nclass DateRange {\n  constructor(dateRangeAttr, dateRangeWithSameId, tagCount = 0) {\n    var _dateRangeWithSameId$;\n    this.attr = void 0;\n    this.tagAnchor = void 0;\n    this.tagOrder = void 0;\n    this._startDate = void 0;\n    this._endDate = void 0;\n    this._dateAtEnd = void 0;\n    this._cue = void 0;\n    this._badValueForSameId = void 0;\n    this.tagAnchor = (dateRangeWithSameId == null ? void 0 : dateRangeWithSameId.tagAnchor) || null;\n    this.tagOrder = (_dateRangeWithSameId$ = dateRangeWithSameId == null ? void 0 : dateRangeWithSameId.tagOrder) != null ? _dateRangeWithSameId$ : tagCount;\n    if (dateRangeWithSameId) {\n      const previousAttr = dateRangeWithSameId.attr;\n      for (const key in previousAttr) {\n        if (Object.prototype.hasOwnProperty.call(dateRangeAttr, key) && dateRangeAttr[key] !== previousAttr[key]) {\n          logger.warn(`DATERANGE tag attribute: \"${key}\" does not match for tags with ID: \"${dateRangeAttr.ID}\"`);\n          this._badValueForSameId = key;\n          break;\n        }\n      }\n      // Merge DateRange tags with the same ID\n      dateRangeAttr = _extends(new AttrList({}), previousAttr, dateRangeAttr);\n    }\n    this.attr = dateRangeAttr;\n    if (dateRangeWithSameId) {\n      this._startDate = dateRangeWithSameId._startDate;\n      this._cue = dateRangeWithSameId._cue;\n      this._endDate = dateRangeWithSameId._endDate;\n      this._dateAtEnd = dateRangeWithSameId._dateAtEnd;\n    } else {\n      this._startDate = new Date(dateRangeAttr[\"START-DATE\"]);\n    }\n    if (\"END-DATE\" in this.attr) {\n      const endDate = (dateRangeWithSameId == null ? void 0 : dateRangeWithSameId.endDate) || new Date(this.attr[\"END-DATE\"]);\n      if (isFiniteNumber(endDate.getTime())) {\n        this._endDate = endDate;\n      }\n    }\n  }\n  get id() {\n    return this.attr.ID;\n  }\n  get class() {\n    return this.attr.CLASS;\n  }\n  get cue() {\n    const _cue = this._cue;\n    if (_cue === undefined) {\n      return this._cue = this.attr.enumeratedStringList(this.attr.CUE ? 'CUE' : 'X-CUE', {\n        pre: false,\n        post: false,\n        once: false\n      });\n    }\n    return _cue;\n  }\n  get startTime() {\n    const {\n      tagAnchor\n    } = this;\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (tagAnchor === null || tagAnchor.programDateTime === null) {\n      logger.warn(`Expected tagAnchor Fragment with PDT set for DateRange \"${this.id}\": ${tagAnchor}`);\n      return NaN;\n    }\n    return tagAnchor.start + (this.startDate.getTime() - tagAnchor.programDateTime) / 1000;\n  }\n  get startDate() {\n    return this._startDate;\n  }\n  get endDate() {\n    const dateAtEnd = this._endDate || this._dateAtEnd;\n    if (dateAtEnd) {\n      return dateAtEnd;\n    }\n    const duration = this.duration;\n    if (duration !== null) {\n      return this._dateAtEnd = new Date(this._startDate.getTime() + duration * 1000);\n    }\n    return null;\n  }\n  get duration() {\n    if (\"DURATION\" in this.attr) {\n      const duration = this.attr.decimalFloatingPoint(\"DURATION\");\n      if (isFiniteNumber(duration)) {\n        return duration;\n      }\n    } else if (this._endDate) {\n      return (this._endDate.getTime() - this._startDate.getTime()) / 1000;\n    }\n    return null;\n  }\n  get plannedDuration() {\n    if (\"PLANNED-DURATION\" in this.attr) {\n      return this.attr.decimalFloatingPoint(\"PLANNED-DURATION\");\n    }\n    return null;\n  }\n  get endOnNext() {\n    return this.attr.bool(\"END-ON-NEXT\");\n  }\n  get isInterstitial() {\n    return this.class === CLASS_INTERSTITIAL;\n  }\n  get isValid() {\n    return !!this.id && !this._badValueForSameId && isFiniteNumber(this.startDate.getTime()) && (this.duration === null || this.duration >= 0) && (!this.endOnNext || !!this.class) && (!this.attr.CUE || !this.cue.pre && !this.cue.post || this.cue.pre !== this.cue.post) && (!this.isInterstitial || 'X-ASSET-URI' in this.attr || 'X-ASSET-LIST' in this.attr);\n  }\n}\n\nconst DEFAULT_TARGET_DURATION = 10;\n\n/**\n * Object representing parsed data from an HLS Media Playlist. Found in {@link hls.js#Level.details}.\n */\nclass LevelDetails {\n  constructor(baseUrl) {\n    this.PTSKnown = false;\n    this.alignedSliding = false;\n    this.averagetargetduration = void 0;\n    this.endCC = 0;\n    this.endSN = 0;\n    this.fragments = void 0;\n    this.fragmentHint = void 0;\n    this.partList = null;\n    this.dateRanges = void 0;\n    this.dateRangeTagCount = 0;\n    this.live = true;\n    this.requestScheduled = -1;\n    this.ageHeader = 0;\n    this.advancedDateTime = void 0;\n    this.updated = true;\n    this.advanced = true;\n    this.misses = 0;\n    this.startCC = 0;\n    this.startSN = 0;\n    this.startTimeOffset = null;\n    this.targetduration = 0;\n    this.totalduration = 0;\n    this.type = null;\n    this.url = void 0;\n    this.m3u8 = '';\n    this.version = null;\n    this.canBlockReload = false;\n    this.canSkipUntil = 0;\n    this.canSkipDateRanges = false;\n    this.skippedSegments = 0;\n    this.recentlyRemovedDateranges = void 0;\n    this.partHoldBack = 0;\n    this.holdBack = 0;\n    this.partTarget = 0;\n    this.preloadHint = void 0;\n    this.renditionReports = void 0;\n    this.tuneInGoal = 0;\n    this.deltaUpdateFailed = void 0;\n    this.driftStartTime = 0;\n    this.driftEndTime = 0;\n    this.driftStart = 0;\n    this.driftEnd = 0;\n    this.encryptedFragments = void 0;\n    this.playlistParsingError = null;\n    this.variableList = null;\n    this.hasVariableRefs = false;\n    this.appliedTimelineOffset = void 0;\n    this.fragments = [];\n    this.encryptedFragments = [];\n    this.dateRanges = {};\n    this.url = baseUrl;\n  }\n  reloaded(previous) {\n    if (!previous) {\n      this.advanced = true;\n      this.updated = true;\n      return;\n    }\n    const partSnDiff = this.lastPartSn - previous.lastPartSn;\n    const partIndexDiff = this.lastPartIndex - previous.lastPartIndex;\n    this.updated = this.endSN !== previous.endSN || !!partIndexDiff || !!partSnDiff || !this.live;\n    this.advanced = this.endSN > previous.endSN || partSnDiff > 0 || partSnDiff === 0 && partIndexDiff > 0;\n    if (this.updated || this.advanced) {\n      this.misses = Math.floor(previous.misses * 0.6);\n    } else {\n      this.misses = previous.misses + 1;\n    }\n  }\n  get hasProgramDateTime() {\n    if (this.fragments.length) {\n      return isFiniteNumber(this.fragments[this.fragments.length - 1].programDateTime);\n    }\n    return false;\n  }\n  get levelTargetDuration() {\n    return this.averagetargetduration || this.targetduration || DEFAULT_TARGET_DURATION;\n  }\n  get drift() {\n    const runTime = this.driftEndTime - this.driftStartTime;\n    if (runTime > 0) {\n      const runDuration = this.driftEnd - this.driftStart;\n      return runDuration * 1000 / runTime;\n    }\n    return 1;\n  }\n  get edge() {\n    return this.partEnd || this.fragmentEnd;\n  }\n  get partEnd() {\n    var _this$partList;\n    if ((_this$partList = this.partList) != null && _this$partList.length) {\n      return this.partList[this.partList.length - 1].end;\n    }\n    return this.fragmentEnd;\n  }\n  get fragmentEnd() {\n    var _this$fragments;\n    if ((_this$fragments = this.fragments) != null && _this$fragments.length) {\n      return this.fragments[this.fragments.length - 1].end;\n    }\n    return 0;\n  }\n  get fragmentStart() {\n    var _this$fragments2;\n    if ((_this$fragments2 = this.fragments) != null && _this$fragments2.length) {\n      return this.fragments[0].start;\n    }\n    return 0;\n  }\n  get age() {\n    if (this.advancedDateTime) {\n      return Math.max(Date.now() - this.advancedDateTime, 0) / 1000;\n    }\n    return 0;\n  }\n  get lastPartIndex() {\n    var _this$partList2;\n    if ((_this$partList2 = this.partList) != null && _this$partList2.length) {\n      return this.partList[this.partList.length - 1].index;\n    }\n    return -1;\n  }\n  get maxPartIndex() {\n    const partList = this.partList;\n    if (partList) {\n      const lastIndex = this.lastPartIndex;\n      if (lastIndex !== -1) {\n        for (let i = partList.length; i--;) {\n          if (partList[i].index > lastIndex) {\n            return partList[i].index;\n          }\n        }\n        return lastIndex;\n      }\n    }\n    return 0;\n  }\n  get lastPartSn() {\n    var _this$partList3;\n    if ((_this$partList3 = this.partList) != null && _this$partList3.length) {\n      return this.partList[this.partList.length - 1].fragment.sn;\n    }\n    return this.endSN;\n  }\n  get expired() {\n    if (this.live && this.age && this.misses < 3) {\n      const playlistWindowDuration = this.partEnd - this.fragmentStart;\n      return this.age > Math.max(playlistWindowDuration, this.totalduration) + this.levelTargetDuration;\n    }\n    return false;\n  }\n}\n\nfunction isFullSegmentEncryption(method) {\n  return method === 'AES-128' || method === 'AES-256' || method === 'AES-256-CTR';\n}\nfunction getAesModeFromFullSegmentMethod(method) {\n  switch (method) {\n    case 'AES-128':\n    case 'AES-256':\n      return DecrypterAesMode.cbc;\n    case 'AES-256-CTR':\n      return DecrypterAesMode.ctr;\n    default:\n      throw new Error(`invalid full segment method ${method}`);\n  }\n}\n\nfunction base64Decode(base64encodedStr) {\n  return Uint8Array.from(atob(base64encodedStr), c => c.charCodeAt(0));\n}\n\n// breaking up those two types in order to clarify what is happening in the decoding path.\n\n// http://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript/22373197\n// http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt\n/* utf.js - UTF-8 <=> UTF-16 convertion\n *\n * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\n * Version: 1.0\n * LastModified: Dec 25 1999\n * This library is free.  You can redistribute it and/or modify it.\n */\n\nfunction strToUtf8array(str) {\n  return Uint8Array.from(unescape(encodeURIComponent(str)), c => c.charCodeAt(0));\n}\n\nfunction getKeyIdBytes(str) {\n  const keyIdbytes = strToUtf8array(str).subarray(0, 16);\n  const paddedkeyIdbytes = new Uint8Array(16);\n  paddedkeyIdbytes.set(keyIdbytes, 16 - keyIdbytes.length);\n  return paddedkeyIdbytes;\n}\nfunction changeEndianness(keyId) {\n  const swap = function swap(array, from, to) {\n    const cur = array[from];\n    array[from] = array[to];\n    array[to] = cur;\n  };\n  swap(keyId, 0, 3);\n  swap(keyId, 1, 2);\n  swap(keyId, 4, 5);\n  swap(keyId, 6, 7);\n}\nfunction convertDataUriToArrayBytes(uri) {\n  // data:[<media type][;attribute=value][;base64],<data>\n  const colonsplit = uri.split(':');\n  let keydata = null;\n  if (colonsplit[0] === 'data' && colonsplit.length === 2) {\n    const semicolonsplit = colonsplit[1].split(';');\n    const commasplit = semicolonsplit[semicolonsplit.length - 1].split(',');\n    if (commasplit.length === 2) {\n      const isbase64 = commasplit[0] === 'base64';\n      const data = commasplit[1];\n      if (isbase64) {\n        semicolonsplit.splice(-1, 1); // remove from processing\n        keydata = base64Decode(data);\n      } else {\n        keydata = getKeyIdBytes(data);\n      }\n    }\n  }\n  return keydata;\n}\n\n/** returns `undefined` is `self` is missing, e.g. in node */\nconst optionalSelf = typeof self !== 'undefined' ? self : undefined;\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess\n */\nvar KeySystems = {\n  CLEARKEY: \"org.w3.clearkey\",\n  FAIRPLAY: \"com.apple.fps\",\n  PLAYREADY: \"com.microsoft.playready\",\n  WIDEVINE: \"com.widevine.alpha\"\n};\n\n// Playlist #EXT-X-KEY KEYFORMAT values\nvar KeySystemFormats = {\n  CLEARKEY: \"org.w3.clearkey\",\n  FAIRPLAY: \"com.apple.streamingkeydelivery\",\n  PLAYREADY: \"com.microsoft.playready\",\n  WIDEVINE: \"urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed\"\n};\nfunction keySystemFormatToKeySystemDomain(format) {\n  switch (format) {\n    case KeySystemFormats.FAIRPLAY:\n      return KeySystems.FAIRPLAY;\n    case KeySystemFormats.PLAYREADY:\n      return KeySystems.PLAYREADY;\n    case KeySystemFormats.WIDEVINE:\n      return KeySystems.WIDEVINE;\n    case KeySystemFormats.CLEARKEY:\n      return KeySystems.CLEARKEY;\n  }\n}\nfunction keySystemDomainToKeySystemFormat(keySystem) {\n  switch (keySystem) {\n    case KeySystems.FAIRPLAY:\n      return KeySystemFormats.FAIRPLAY;\n    case KeySystems.PLAYREADY:\n      return KeySystemFormats.PLAYREADY;\n    case KeySystems.WIDEVINE:\n      return KeySystemFormats.WIDEVINE;\n    case KeySystems.CLEARKEY:\n      return KeySystemFormats.CLEARKEY;\n  }\n}\nfunction getKeySystemsForConfig(config) {\n  const {\n    drmSystems,\n    widevineLicenseUrl\n  } = config;\n  const keySystemsToAttempt = drmSystems ? [KeySystems.FAIRPLAY, KeySystems.WIDEVINE, KeySystems.PLAYREADY, KeySystems.CLEARKEY].filter(keySystem => !!drmSystems[keySystem]) : [];\n  if (!keySystemsToAttempt[KeySystems.WIDEVINE] && widevineLicenseUrl) {\n    keySystemsToAttempt.push(KeySystems.WIDEVINE);\n  }\n  return keySystemsToAttempt;\n}\nconst requestMediaKeySystemAccess = function (_optionalSelf$navigat) {\n  if (optionalSelf != null && (_optionalSelf$navigat = optionalSelf.navigator) != null && _optionalSelf$navigat.requestMediaKeySystemAccess) {\n    return self.navigator.requestMediaKeySystemAccess.bind(self.navigator);\n  } else {\n    return null;\n  }\n}();\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/MediaKeySystemConfiguration\n */\nfunction getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, drmSystemOptions) {\n  let initDataTypes;\n  switch (keySystem) {\n    case KeySystems.FAIRPLAY:\n      initDataTypes = ['cenc', 'sinf'];\n      break;\n    case KeySystems.WIDEVINE:\n    case KeySystems.PLAYREADY:\n      initDataTypes = ['cenc'];\n      break;\n    case KeySystems.CLEARKEY:\n      initDataTypes = ['cenc', 'keyids'];\n      break;\n    default:\n      throw new Error(`Unknown key-system: ${keySystem}`);\n  }\n  return createMediaKeySystemConfigurations(initDataTypes, audioCodecs, videoCodecs, drmSystemOptions);\n}\nfunction createMediaKeySystemConfigurations(initDataTypes, audioCodecs, videoCodecs, drmSystemOptions) {\n  const baseConfig = {\n    initDataTypes: initDataTypes,\n    persistentState: drmSystemOptions.persistentState || 'optional',\n    distinctiveIdentifier: drmSystemOptions.distinctiveIdentifier || 'optional',\n    sessionTypes: drmSystemOptions.sessionTypes || [drmSystemOptions.sessionType || 'temporary'],\n    audioCapabilities: audioCodecs.map(codec => ({\n      contentType: `audio/mp4; codecs=${codec}`,\n      robustness: drmSystemOptions.audioRobustness || '',\n      encryptionScheme: drmSystemOptions.audioEncryptionScheme || null\n    })),\n    videoCapabilities: videoCodecs.map(codec => ({\n      contentType: `video/mp4; codecs=${codec}`,\n      robustness: drmSystemOptions.videoRobustness || '',\n      encryptionScheme: drmSystemOptions.videoEncryptionScheme || null\n    }))\n  };\n  return [baseConfig];\n}\nfunction isPersistentSessionType(drmSystemOptions) {\n  var _drmSystemOptions$ses;\n  return drmSystemOptions.sessionType === 'persistent-license' || !!((_drmSystemOptions$ses = drmSystemOptions.sessionTypes) != null && _drmSystemOptions$ses.some(type => type === 'persistent-license'));\n}\nfunction parsePlayReadyWRM(keyBytes) {\n  const keyBytesUtf16 = new Uint16Array(keyBytes.buffer, keyBytes.byteOffset, keyBytes.byteLength / 2);\n  const keyByteStr = String.fromCharCode.apply(null, Array.from(keyBytesUtf16));\n\n  // Parse Playready WRMHeader XML\n  const xmlKeyBytes = keyByteStr.substring(keyByteStr.indexOf('<'), keyByteStr.length);\n  const parser = new DOMParser();\n  const xmlDoc = parser.parseFromString(xmlKeyBytes, 'text/xml');\n  const keyData = xmlDoc.getElementsByTagName('KID')[0];\n  if (keyData) {\n    const keyId = keyData.childNodes[0] ? keyData.childNodes[0].nodeValue : keyData.getAttribute('VALUE');\n    if (keyId) {\n      const keyIdArray = base64Decode(keyId).subarray(0, 16);\n      // KID value in PRO is a base64-encoded little endian GUID interpretation of UUID\n      // KID value in ‘tenc’ is a big endian UUID GUID interpretation of UUID\n      changeEndianness(keyIdArray);\n      return keyIdArray;\n    }\n  }\n  return null;\n}\n\nlet keyUriToKeyIdMap = {};\nclass LevelKey {\n  static clearKeyUriToKeyIdMap() {\n    keyUriToKeyIdMap = {};\n  }\n  constructor(method, uri, format, formatversions = [1], iv = null, keyId) {\n    this.uri = void 0;\n    this.method = void 0;\n    this.keyFormat = void 0;\n    this.keyFormatVersions = void 0;\n    this.encrypted = void 0;\n    this.isCommonEncryption = void 0;\n    this.iv = null;\n    this.key = null;\n    this.keyId = null;\n    this.pssh = null;\n    this.method = method;\n    this.uri = uri;\n    this.keyFormat = format;\n    this.keyFormatVersions = formatversions;\n    this.iv = iv;\n    this.encrypted = method ? method !== 'NONE' : false;\n    this.isCommonEncryption = this.encrypted && !isFullSegmentEncryption(method);\n    if (keyId != null && keyId.startsWith('0x')) {\n      this.keyId = new Uint8Array(hexToArrayBuffer(keyId));\n    }\n  }\n  matches(key) {\n    var _key$iv, _this$iv;\n    return key.uri === this.uri && key.method === this.method && key.encrypted === this.encrypted && key.keyFormat === this.keyFormat && key.keyFormatVersions.join(',') === this.keyFormatVersions.join(',') && ((_key$iv = key.iv) == null ? void 0 : _key$iv.join(',')) === ((_this$iv = this.iv) == null ? void 0 : _this$iv.join(','));\n  }\n  isSupported() {\n    // If it's Segment encryption or No encryption, just select that key system\n    if (this.method) {\n      if (isFullSegmentEncryption(this.method) || this.method === 'NONE') {\n        return true;\n      }\n      if (this.keyFormat === 'identity') {\n        // Maintain support for clear SAMPLE-AES with MPEG-3 TS\n        return this.method === 'SAMPLE-AES';\n      } else {\n        switch (this.keyFormat) {\n          case KeySystemFormats.FAIRPLAY:\n          case KeySystemFormats.WIDEVINE:\n          case KeySystemFormats.PLAYREADY:\n          case KeySystemFormats.CLEARKEY:\n            return ['ISO-23001-7', 'SAMPLE-AES', 'SAMPLE-AES-CENC', 'SAMPLE-AES-CTR'].indexOf(this.method) !== -1;\n        }\n      }\n    }\n    return false;\n  }\n  getDecryptData(sn) {\n    if (!this.encrypted || !this.uri) {\n      return null;\n    }\n    if (isFullSegmentEncryption(this.method) && this.uri && !this.iv) {\n      if (typeof sn !== 'number') {\n        // We are fetching decryption data for a initialization segment\n        // If the segment was encrypted with AES-128/256\n        // It must have an IV defined. We cannot substitute the Segment Number in.\n        logger.warn(`missing IV for initialization segment with method=\"${this.method}\" - compliance issue`);\n\n        // Explicitly set sn to resulting value from implicit conversions 'initSegment' values for IV generation.\n        sn = 0;\n      }\n      const iv = createInitializationVector(sn);\n      const decryptdata = new LevelKey(this.method, this.uri, 'identity', this.keyFormatVersions, iv);\n      return decryptdata;\n    }\n    if (this.pssh && this.keyId) {\n      return this;\n    }\n\n    // Initialize keyId if possible\n    const keyBytes = convertDataUriToArrayBytes(this.uri);\n    if (keyBytes) {\n      switch (this.keyFormat) {\n        case KeySystemFormats.WIDEVINE:\n          // Setting `pssh` on this LevelKey/DecryptData allows HLS.js to generate a session using\n          // the playlist-key before the \"encrypted\" event. (Comment out to only use \"encrypted\" path.)\n          this.pssh = keyBytes;\n          // In case of Widevine, if KEYID is not in the playlist, assume only two fields in the pssh KEY tag URI.\n          if (!this.keyId && keyBytes.length >= 22) {\n            const offset = keyBytes.length - 22;\n            this.keyId = keyBytes.subarray(offset, offset + 16);\n          }\n          break;\n        case KeySystemFormats.PLAYREADY:\n          {\n            const PlayReadyKeySystemUUID = new Uint8Array([0x9a, 0x04, 0xf0, 0x79, 0x98, 0x40, 0x42, 0x86, 0xab, 0x92, 0xe6, 0x5b, 0xe0, 0x88, 0x5f, 0x95]);\n\n            // Setting `pssh` on this LevelKey/DecryptData allows HLS.js to generate a session using\n            // the playlist-key before the \"encrypted\" event. (Comment out to only use \"encrypted\" path.)\n            this.pssh = mp4pssh(PlayReadyKeySystemUUID, null, keyBytes);\n            this.keyId = parsePlayReadyWRM(keyBytes);\n            break;\n          }\n        default:\n          {\n            let keydata = keyBytes.subarray(0, 16);\n            if (keydata.length !== 16) {\n              const padded = new Uint8Array(16);\n              padded.set(keydata, 16 - keydata.length);\n              keydata = padded;\n            }\n            this.keyId = keydata;\n            break;\n          }\n      }\n    }\n\n    // Default behavior: assign a new keyId for each uri\n    if (!this.keyId || this.keyId.byteLength !== 16) {\n      let keyId = keyUriToKeyIdMap[this.uri];\n      if (!keyId) {\n        const val = Object.keys(keyUriToKeyIdMap).length % Number.MAX_SAFE_INTEGER;\n        keyId = new Uint8Array(16);\n        const dv = new DataView(keyId.buffer, 12, 4); // Just set the last 4 bytes\n        dv.setUint32(0, val);\n        keyUriToKeyIdMap[this.uri] = keyId;\n      }\n      this.keyId = keyId;\n    }\n    return this;\n  }\n}\nfunction createInitializationVector(segmentNumber) {\n  const uint8View = new Uint8Array(16);\n  for (let i = 12; i < 16; i++) {\n    uint8View[i] = segmentNumber >> 8 * (15 - i) & 0xff;\n  }\n  return uint8View;\n}\n\nconst MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\\r\\n]*)(?:[\\r\\n](?:#[^\\r\\n]*)?)*([^\\r\\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\\r\\n]*)[\\r\\n]+/g;\nconst MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;\nconst IS_MEDIA_PLAYLIST = /^#EXT(?:INF|-X-TARGETDURATION):/m; // Handle empty Media Playlist (first EXTINF not signaled, but TARGETDURATION present)\n\nconst LEVEL_PLAYLIST_REGEX_FAST = new RegExp([/#EXTINF:\\s*(\\d*(?:\\.\\d+)?)(?:,(.*)\\s+)?/.source,\n// duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title\n/(?!#) *(\\S[^\\r\\n]*)/.source,\n// segment URI, group 3 => the URI (note newline is not eaten)\n/#.*/.source // All other non-segment oriented tags will match with all groups empty\n].join('|'), 'g');\nconst LEVEL_PLAYLIST_REGEX_SLOW = new RegExp([/#EXT-X-(PROGRAM-DATE-TIME|BYTERANGE|DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP|INDEPENDENT-SEGMENTS)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\\r?\\n?/.source].join('|'));\nclass M3U8Parser {\n  static findGroup(groups, mediaGroupId) {\n    for (let i = 0; i < groups.length; i++) {\n      const group = groups[i];\n      if (group.id === mediaGroupId) {\n        return group;\n      }\n    }\n  }\n  static resolve(url, baseUrl) {\n    return urlToolkitExports.buildAbsoluteURL(baseUrl, url, {\n      alwaysNormalize: true\n    });\n  }\n  static isMediaPlaylist(str) {\n    return IS_MEDIA_PLAYLIST.test(str);\n  }\n  static parseMasterPlaylist(string, baseurl) {\n    const hasVariableRefs = hasVariableReferences(string) ;\n    const parsed = {\n      contentSteering: null,\n      levels: [],\n      playlistParsingError: null,\n      sessionData: null,\n      sessionKeys: null,\n      startTimeOffset: null,\n      variableList: null,\n      hasVariableRefs\n    };\n    const levelsWithKnownCodecs = [];\n    MASTER_PLAYLIST_REGEX.lastIndex = 0;\n    let result;\n    while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {\n      if (result[1]) {\n        var _level$unknownCodecs;\n        // '#EXT-X-STREAM-INF' is found, parse level tag  in group 1\n        const attrs = new AttrList(result[1], parsed);\n        const uri = substituteVariables(parsed, result[2]) ;\n        const level = {\n          attrs,\n          bitrate: attrs.decimalInteger('BANDWIDTH') || attrs.decimalInteger('AVERAGE-BANDWIDTH'),\n          name: attrs.NAME,\n          url: M3U8Parser.resolve(uri, baseurl)\n        };\n        const resolution = attrs.decimalResolution('RESOLUTION');\n        if (resolution) {\n          level.width = resolution.width;\n          level.height = resolution.height;\n        }\n        setCodecs(attrs.CODECS, level);\n        const supplementalCodecs = attrs['SUPPLEMENTAL-CODECS'];\n        if (supplementalCodecs) {\n          level.supplemental = {};\n          setCodecs(supplementalCodecs, level.supplemental);\n        }\n        if (!((_level$unknownCodecs = level.unknownCodecs) != null && _level$unknownCodecs.length)) {\n          levelsWithKnownCodecs.push(level);\n        }\n        parsed.levels.push(level);\n      } else if (result[3]) {\n        const tag = result[3];\n        const attributes = result[4];\n        switch (tag) {\n          case 'SESSION-DATA':\n            {\n              // #EXT-X-SESSION-DATA\n              const sessionAttrs = new AttrList(attributes, parsed);\n              const dataId = sessionAttrs['DATA-ID'];\n              if (dataId) {\n                if (parsed.sessionData === null) {\n                  parsed.sessionData = {};\n                }\n                parsed.sessionData[dataId] = sessionAttrs;\n              }\n              break;\n            }\n          case 'SESSION-KEY':\n            {\n              // #EXT-X-SESSION-KEY\n              const sessionKey = parseKey(attributes, baseurl, parsed);\n              if (sessionKey.encrypted && sessionKey.isSupported()) {\n                if (parsed.sessionKeys === null) {\n                  parsed.sessionKeys = [];\n                }\n                parsed.sessionKeys.push(sessionKey);\n              } else {\n                logger.warn(`[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: \"${attributes}\"`);\n              }\n              break;\n            }\n          case 'DEFINE':\n            {\n              // #EXT-X-DEFINE\n              {\n                const variableAttributes = new AttrList(attributes, parsed);\n                addVariableDefinition(parsed, variableAttributes, baseurl);\n              }\n              break;\n            }\n          case 'CONTENT-STEERING':\n            {\n              // #EXT-X-CONTENT-STEERING\n              const contentSteeringAttributes = new AttrList(attributes, parsed);\n              parsed.contentSteering = {\n                uri: M3U8Parser.resolve(contentSteeringAttributes['SERVER-URI'], baseurl),\n                pathwayId: contentSteeringAttributes['PATHWAY-ID'] || '.'\n              };\n              break;\n            }\n          case 'START':\n            {\n              // #EXT-X-START\n              parsed.startTimeOffset = parseStartTimeOffset(attributes);\n              break;\n            }\n        }\n      }\n    }\n    // Filter out levels with unknown codecs if it does not remove all levels\n    const stripUnknownCodecLevels = levelsWithKnownCodecs.length > 0 && levelsWithKnownCodecs.length < parsed.levels.length;\n    parsed.levels = stripUnknownCodecLevels ? levelsWithKnownCodecs : parsed.levels;\n    if (parsed.levels.length === 0) {\n      parsed.playlistParsingError = new Error('no levels found in manifest');\n    }\n    return parsed;\n  }\n  static parseMasterPlaylistMedia(string, baseurl, parsed) {\n    let result;\n    const results = {};\n    const levels = parsed.levels;\n    const groupsByType = {\n      AUDIO: levels.map(level => ({\n        id: level.attrs.AUDIO,\n        audioCodec: level.audioCodec\n      })),\n      SUBTITLES: levels.map(level => ({\n        id: level.attrs.SUBTITLES,\n        textCodec: level.textCodec\n      })),\n      'CLOSED-CAPTIONS': []\n    };\n    let id = 0;\n    MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;\n    while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) !== null) {\n      const attrs = new AttrList(result[1], parsed);\n      const type = attrs.TYPE;\n      if (type) {\n        const groups = groupsByType[type];\n        const medias = results[type] || [];\n        results[type] = medias;\n        const lang = attrs.LANGUAGE;\n        const assocLang = attrs['ASSOC-LANGUAGE'];\n        const channels = attrs.CHANNELS;\n        const characteristics = attrs.CHARACTERISTICS;\n        const instreamId = attrs['INSTREAM-ID'];\n        const media = {\n          attrs,\n          bitrate: 0,\n          id: id++,\n          groupId: attrs['GROUP-ID'] || '',\n          name: attrs.NAME || lang || '',\n          type,\n          default: attrs.bool('DEFAULT'),\n          autoselect: attrs.bool('AUTOSELECT'),\n          forced: attrs.bool('FORCED'),\n          lang,\n          url: attrs.URI ? M3U8Parser.resolve(attrs.URI, baseurl) : ''\n        };\n        if (assocLang) {\n          media.assocLang = assocLang;\n        }\n        if (channels) {\n          media.channels = channels;\n        }\n        if (characteristics) {\n          media.characteristics = characteristics;\n        }\n        if (instreamId) {\n          media.instreamId = instreamId;\n        }\n        if (groups != null && groups.length) {\n          // If there are audio or text groups signalled in the manifest, let's look for a matching codec string for this track\n          // If we don't find the track signalled, lets use the first audio groups codec we have\n          // Acting as a best guess\n          const groupCodec = M3U8Parser.findGroup(groups, media.groupId) || groups[0];\n          assignCodec(media, groupCodec, 'audioCodec');\n          assignCodec(media, groupCodec, 'textCodec');\n        }\n        medias.push(media);\n      }\n    }\n    return results;\n  }\n  static parseLevelPlaylist(string, baseurl, id, type, levelUrlId, multivariantVariableList) {\n    var _LEVEL_PLAYLIST_REGEX;\n    const base = {\n      url: baseurl\n    };\n    const level = new LevelDetails(baseurl);\n    const fragments = level.fragments;\n    const programDateTimes = [];\n    // The most recent init segment seen (applies to all subsequent segments)\n    let currentInitSegment = null;\n    let currentSN = 0;\n    let currentPart = 0;\n    let totalduration = 0;\n    let discontinuityCounter = 0;\n    let currentBitrate = 0;\n    let prevFrag = null;\n    let frag = new Fragment(type, base);\n    let result;\n    let i;\n    let levelkeys;\n    let firstPdtIndex = -1;\n    let createNextFrag = false;\n    let nextByteRange = null;\n    let serverControlAttrs;\n    LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;\n    level.m3u8 = string;\n    level.hasVariableRefs = hasVariableReferences(string) ;\n    if (((_LEVEL_PLAYLIST_REGEX = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) == null ? void 0 : _LEVEL_PLAYLIST_REGEX[0]) !== '#EXTM3U') {\n      level.playlistParsingError = new Error('Missing format identifier #EXTM3U');\n      return level;\n    }\n    while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {\n      if (createNextFrag) {\n        createNextFrag = false;\n        frag = new Fragment(type, base);\n        // setup the next fragment for part loading\n        frag.playlistOffset = totalduration;\n        frag.start = totalduration;\n        frag.sn = currentSN;\n        frag.cc = discontinuityCounter;\n        if (currentBitrate) {\n          frag.bitrate = currentBitrate;\n        }\n        frag.level = id;\n        if (currentInitSegment) {\n          frag.initSegment = currentInitSegment;\n          if (currentInitSegment.rawProgramDateTime) {\n            frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;\n            currentInitSegment.rawProgramDateTime = null;\n          }\n          if (nextByteRange) {\n            frag.setByteRange(nextByteRange);\n            nextByteRange = null;\n          }\n        }\n      }\n      const duration = result[1];\n      if (duration) {\n        // INF\n        frag.duration = parseFloat(duration);\n        // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n        const title = (' ' + result[2]).slice(1);\n        frag.title = title || null;\n        frag.tagList.push(title ? ['INF', duration, title] : ['INF', duration]);\n      } else if (result[3]) {\n        // url\n        if (isFiniteNumber(frag.duration)) {\n          frag.playlistOffset = totalduration;\n          frag.start = totalduration;\n          if (levelkeys) {\n            setFragLevelKeys(frag, levelkeys, level);\n          }\n          frag.sn = currentSN;\n          frag.level = id;\n          frag.cc = discontinuityCounter;\n          fragments.push(frag);\n          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n          const uri = (' ' + result[3]).slice(1);\n          frag.relurl = substituteVariables(level, uri) ;\n          assignProgramDateTime(frag, prevFrag, programDateTimes);\n          prevFrag = frag;\n          totalduration += frag.duration;\n          currentSN++;\n          currentPart = 0;\n          createNextFrag = true;\n        }\n      } else {\n        result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);\n        if (!result) {\n          logger.warn('No matches on slow regex match for level playlist!');\n          continue;\n        }\n        for (i = 1; i < result.length; i++) {\n          if (result[i] !== undefined) {\n            break;\n          }\n        }\n\n        // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n        const tag = (' ' + result[i]).slice(1);\n        const value1 = (' ' + result[i + 1]).slice(1);\n        const value2 = result[i + 2] ? (' ' + result[i + 2]).slice(1) : null;\n        switch (tag) {\n          case 'BYTERANGE':\n            if (prevFrag) {\n              frag.setByteRange(value1, prevFrag);\n            } else {\n              frag.setByteRange(value1);\n            }\n            break;\n          case 'PROGRAM-DATE-TIME':\n            // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n            frag.rawProgramDateTime = value1;\n            frag.tagList.push(['PROGRAM-DATE-TIME', value1]);\n            if (firstPdtIndex === -1) {\n              firstPdtIndex = fragments.length;\n            }\n            break;\n          case 'PLAYLIST-TYPE':\n            if (level.type) {\n              assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);\n            }\n            level.type = value1.toUpperCase();\n            break;\n          case 'MEDIA-SEQUENCE':\n            if (level.startSN !== 0) {\n              assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);\n            } else if (fragments.length > 0) {\n              assignMustAppearBeforeSegmentsError(level, tag, result);\n            }\n            currentSN = level.startSN = parseInt(value1);\n            break;\n          case 'SKIP':\n            {\n              if (level.skippedSegments) {\n                assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);\n              }\n              const skipAttrs = new AttrList(value1, level);\n              const skippedSegments = skipAttrs.decimalInteger('SKIPPED-SEGMENTS');\n              if (isFiniteNumber(skippedSegments)) {\n                level.skippedSegments += skippedSegments;\n                // This will result in fragments[] containing undefined values, which we will fill in with `mergeDetails`\n                for (let _i = skippedSegments; _i--;) {\n                  fragments.push(null);\n                }\n                currentSN += skippedSegments;\n              }\n              const recentlyRemovedDateranges = skipAttrs.enumeratedString('RECENTLY-REMOVED-DATERANGES');\n              if (recentlyRemovedDateranges) {\n                level.recentlyRemovedDateranges = (level.recentlyRemovedDateranges || []).concat(recentlyRemovedDateranges.split('\\t'));\n              }\n              break;\n            }\n          case 'TARGETDURATION':\n            if (level.targetduration !== 0) {\n              assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);\n            }\n            level.targetduration = Math.max(parseInt(value1), 1);\n            break;\n          case 'VERSION':\n            if (level.version !== null) {\n              assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);\n            }\n            level.version = parseInt(value1);\n            break;\n          case 'INDEPENDENT-SEGMENTS':\n            break;\n          case 'ENDLIST':\n            if (!level.live) {\n              assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);\n            }\n            level.live = false;\n            break;\n          case '#':\n            if (value1 || value2) {\n              frag.tagList.push(value2 ? [value1, value2] : [value1]);\n            }\n            break;\n          case 'DISCONTINUITY':\n            discontinuityCounter++;\n            frag.tagList.push(['DIS']);\n            break;\n          case 'GAP':\n            frag.gap = true;\n            frag.tagList.push([tag]);\n            break;\n          case 'BITRATE':\n            frag.tagList.push([tag, value1]);\n            currentBitrate = parseInt(value1) * 1000;\n            if (isFiniteNumber(currentBitrate)) {\n              frag.bitrate = currentBitrate;\n            } else {\n              currentBitrate = 0;\n            }\n            break;\n          case 'DATERANGE':\n            {\n              const dateRangeAttr = new AttrList(value1, level);\n              const dateRange = new DateRange(dateRangeAttr, level.dateRanges[dateRangeAttr.ID], level.dateRangeTagCount);\n              level.dateRangeTagCount++;\n              if (dateRange.isValid || level.skippedSegments) {\n                level.dateRanges[dateRange.id] = dateRange;\n              } else {\n                logger.warn(`Ignoring invalid DATERANGE tag: \"${value1}\"`);\n              }\n              // Add to fragment tag list for backwards compatibility (< v1.2.0)\n              frag.tagList.push(['EXT-X-DATERANGE', value1]);\n              break;\n            }\n          case 'DEFINE':\n            {\n              {\n                const variableAttributes = new AttrList(value1, level);\n                if ('IMPORT' in variableAttributes) {\n                  importVariableDefinition(level, variableAttributes, multivariantVariableList);\n                } else {\n                  addVariableDefinition(level, variableAttributes, baseurl);\n                }\n              }\n              break;\n            }\n          case 'DISCONTINUITY-SEQUENCE':\n            if (level.startCC !== 0) {\n              assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);\n            } else if (fragments.length > 0) {\n              assignMustAppearBeforeSegmentsError(level, tag, result);\n            }\n            level.startCC = discontinuityCounter = parseInt(value1);\n            break;\n          case 'KEY':\n            {\n              const levelKey = parseKey(value1, baseurl, level);\n              if (levelKey.isSupported()) {\n                if (levelKey.method === 'NONE') {\n                  levelkeys = undefined;\n                  break;\n                }\n                if (!levelkeys) {\n                  levelkeys = {};\n                }\n                const currentKey = levelkeys[levelKey.keyFormat];\n                // Ignore duplicate playlist KEY tags\n                if (!(currentKey != null && currentKey.matches(levelKey))) {\n                  if (currentKey) {\n                    levelkeys = _extends({}, levelkeys);\n                  }\n                  levelkeys[levelKey.keyFormat] = levelKey;\n                }\n              } else {\n                logger.warn(`[Keys] Ignoring invalid EXT-X-KEY tag: \"${value1}\"`);\n              }\n              break;\n            }\n          case 'START':\n            level.startTimeOffset = parseStartTimeOffset(value1);\n            break;\n          case 'MAP':\n            {\n              const mapAttrs = new AttrList(value1, level);\n              if (frag.duration) {\n                // Initial segment tag is after segment duration tag.\n                //   #EXTINF: 6.0\n                //   #EXT-X-MAP:URI=\"init.mp4\n                const init = new Fragment(type, base);\n                setInitSegment(init, mapAttrs, id, levelkeys);\n                currentInitSegment = init;\n                frag.initSegment = currentInitSegment;\n                if (currentInitSegment.rawProgramDateTime && !frag.rawProgramDateTime) {\n                  frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;\n                }\n              } else {\n                // Initial segment tag is before segment duration tag\n                // Handle case where EXT-X-MAP is declared after EXT-X-BYTERANGE\n                const end = frag.byteRangeEndOffset;\n                if (end) {\n                  const start = frag.byteRangeStartOffset;\n                  nextByteRange = `${end - start}@${start}`;\n                } else {\n                  nextByteRange = null;\n                }\n                setInitSegment(frag, mapAttrs, id, levelkeys);\n                currentInitSegment = frag;\n                createNextFrag = true;\n              }\n              currentInitSegment.cc = discontinuityCounter;\n              break;\n            }\n          case 'SERVER-CONTROL':\n            {\n              if (serverControlAttrs) {\n                assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);\n              }\n              serverControlAttrs = new AttrList(value1);\n              level.canBlockReload = serverControlAttrs.bool('CAN-BLOCK-RELOAD');\n              level.canSkipUntil = serverControlAttrs.optionalFloat('CAN-SKIP-UNTIL', 0);\n              level.canSkipDateRanges = level.canSkipUntil > 0 && serverControlAttrs.bool('CAN-SKIP-DATERANGES');\n              level.partHoldBack = serverControlAttrs.optionalFloat('PART-HOLD-BACK', 0);\n              level.holdBack = serverControlAttrs.optionalFloat('HOLD-BACK', 0);\n              break;\n            }\n          case 'PART-INF':\n            {\n              if (level.partTarget) {\n                assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);\n              }\n              const partInfAttrs = new AttrList(value1);\n              level.partTarget = partInfAttrs.decimalFloatingPoint('PART-TARGET');\n              break;\n            }\n          case 'PART':\n            {\n              let partList = level.partList;\n              if (!partList) {\n                partList = level.partList = [];\n              }\n              const previousFragmentPart = currentPart > 0 ? partList[partList.length - 1] : undefined;\n              const index = currentPart++;\n              const partAttrs = new AttrList(value1, level);\n              const part = new Part(partAttrs, frag, base, index, previousFragmentPart);\n              partList.push(part);\n              frag.duration += part.duration;\n              break;\n            }\n          case 'PRELOAD-HINT':\n            {\n              const preloadHintAttrs = new AttrList(value1, level);\n              level.preloadHint = preloadHintAttrs;\n              break;\n            }\n          case 'RENDITION-REPORT':\n            {\n              const renditionReportAttrs = new AttrList(value1, level);\n              level.renditionReports = level.renditionReports || [];\n              level.renditionReports.push(renditionReportAttrs);\n              break;\n            }\n          default:\n            logger.warn(`line parsed but not handled: ${result}`);\n            break;\n        }\n      }\n    }\n    if (prevFrag && !prevFrag.relurl) {\n      fragments.pop();\n      totalduration -= prevFrag.duration;\n      if (level.partList) {\n        level.fragmentHint = prevFrag;\n      }\n    } else if (level.partList) {\n      assignProgramDateTime(frag, prevFrag, programDateTimes);\n      frag.cc = discontinuityCounter;\n      level.fragmentHint = frag;\n      if (levelkeys) {\n        setFragLevelKeys(frag, levelkeys, level);\n      }\n    }\n    if (!level.targetduration) {\n      level.playlistParsingError = new Error(`#EXT-X-TARGETDURATION is required`);\n    }\n    const fragmentLength = fragments.length;\n    const firstFragment = fragments[0];\n    const lastFragment = fragments[fragmentLength - 1];\n    totalduration += level.skippedSegments * level.targetduration;\n    if (totalduration > 0 && fragmentLength && lastFragment) {\n      level.averagetargetduration = totalduration / fragmentLength;\n      const lastSn = lastFragment.sn;\n      level.endSN = lastSn !== 'initSegment' ? lastSn : 0;\n      if (!level.live) {\n        lastFragment.endList = true;\n      }\n      if (firstFragment && level.startCC === undefined) {\n        level.startCC = firstFragment.cc;\n      }\n      /**\n       * Backfill any missing PDT values\n       * \"If the first EXT-X-PROGRAM-DATE-TIME tag in a Playlist appears after\n       * one or more Media Segment URIs, the client SHOULD extrapolate\n       * backward from that tag (using EXTINF durations and/or media\n       * timestamps) to associate dates with those segments.\"\n       * We have already extrapolated forward, but all fragments up to the first instance of PDT do not have their PDTs\n       * computed.\n       */\n      if (firstPdtIndex > 0) {\n        backfillProgramDateTimes(fragments, firstPdtIndex);\n        if (firstFragment) {\n          programDateTimes.unshift(firstFragment);\n        }\n      }\n    } else {\n      level.endSN = 0;\n      level.startCC = 0;\n    }\n    if (level.fragmentHint) {\n      totalduration += level.fragmentHint.duration;\n    }\n    level.totalduration = totalduration;\n    if (programDateTimes.length && level.dateRangeTagCount && firstFragment) {\n      mapDateRanges(programDateTimes, level);\n    }\n    level.endCC = discontinuityCounter;\n    return level;\n  }\n}\nfunction mapDateRanges(programDateTimes, details) {\n  // Make sure DateRanges are mapped to a ProgramDateTime tag that applies a date to a segment that overlaps with its start date\n  const programDateTimeCount = programDateTimes.length;\n  if (!programDateTimeCount) {\n    return;\n  }\n  const lastProgramDateTime = programDateTimes[programDateTimeCount - 1];\n  const playlistEnd = details.live ? Infinity : details.totalduration;\n  const dateRangeIds = Object.keys(details.dateRanges);\n  for (let i = dateRangeIds.length; i--;) {\n    const dateRange = details.dateRanges[dateRangeIds[i]];\n    const startDateTime = dateRange.startDate.getTime();\n    dateRange.tagAnchor = lastProgramDateTime.ref;\n    for (let j = programDateTimeCount; j--;) {\n      const fragIndex = findFragmentWithStartDate(details, startDateTime, programDateTimes, j, playlistEnd);\n      if (fragIndex !== -1) {\n        dateRange.tagAnchor = details.fragments[fragIndex].ref;\n        break;\n      }\n    }\n  }\n}\nfunction findFragmentWithStartDate(details, startDateTime, programDateTimes, index, endTime) {\n  const pdtFragment = programDateTimes[index];\n  if (pdtFragment) {\n    // find matching range between PDT tags\n    const pdtStart = pdtFragment.programDateTime;\n    if (startDateTime >= pdtStart || index === 0) {\n      var _programDateTimes;\n      const durationBetweenPdt = (((_programDateTimes = programDateTimes[index + 1]) == null ? void 0 : _programDateTimes.start) || endTime) - pdtFragment.start;\n      if (startDateTime <= pdtStart + durationBetweenPdt * 1000) {\n        // map to fragment with date-time range\n        const startIndex = programDateTimes[index].sn - details.startSN;\n        const fragments = details.fragments;\n        if (fragments.length > programDateTimes.length) {\n          const endSegment = programDateTimes[index + 1] || fragments[fragments.length - 1];\n          const endIndex = endSegment.sn - details.startSN;\n          for (let i = endIndex; i > startIndex; i--) {\n            const fragStartDateTime = fragments[i].programDateTime;\n            if (startDateTime >= fragStartDateTime && startDateTime < fragStartDateTime + fragments[i].duration * 1000) {\n              return i;\n            }\n          }\n        }\n        return startIndex;\n      }\n    }\n  }\n  return -1;\n}\nfunction parseKey(keyTagAttributes, baseurl, parsed) {\n  var _keyAttrs$METHOD, _keyAttrs$KEYFORMAT;\n  // https://tools.ietf.org/html/rfc8216#section-4.3.2.4\n  const keyAttrs = new AttrList(keyTagAttributes, parsed);\n  const decryptmethod = (_keyAttrs$METHOD = keyAttrs.METHOD) != null ? _keyAttrs$METHOD : '';\n  const decrypturi = keyAttrs.URI;\n  const decryptiv = keyAttrs.hexadecimalInteger('IV');\n  const decryptkeyformatversions = keyAttrs.KEYFORMATVERSIONS;\n  // From RFC: This attribute is OPTIONAL; its absence indicates an implicit value of \"identity\".\n  const decryptkeyformat = (_keyAttrs$KEYFORMAT = keyAttrs.KEYFORMAT) != null ? _keyAttrs$KEYFORMAT : 'identity';\n  if (decrypturi && keyAttrs.IV && !decryptiv) {\n    logger.error(`Invalid IV: ${keyAttrs.IV}`);\n  }\n  // If decrypturi is a URI with a scheme, then baseurl will be ignored\n  // No uri is allowed when METHOD is NONE\n  const resolvedUri = decrypturi ? M3U8Parser.resolve(decrypturi, baseurl) : '';\n  const keyFormatVersions = (decryptkeyformatversions ? decryptkeyformatversions : '1').split('/').map(Number).filter(Number.isFinite);\n  return new LevelKey(decryptmethod, resolvedUri, decryptkeyformat, keyFormatVersions, decryptiv, keyAttrs.KEYID);\n}\nfunction parseStartTimeOffset(startAttributes) {\n  const startAttrs = new AttrList(startAttributes);\n  const startTimeOffset = startAttrs.decimalFloatingPoint('TIME-OFFSET');\n  if (isFiniteNumber(startTimeOffset)) {\n    return startTimeOffset;\n  }\n  return null;\n}\nfunction setCodecs(codecsAttributeValue, level) {\n  let codecs = (codecsAttributeValue || '').split(/[ ,]+/).filter(c => c);\n  ['video', 'audio', 'text'].forEach(type => {\n    const filtered = codecs.filter(codec => isCodecType(codec, type));\n    if (filtered.length) {\n      // Comma separated list of all codecs for type\n      level[`${type}Codec`] = filtered.map(c => c.split('/')[0]).join(',');\n      // Remove known codecs so that only unknownCodecs are left after iterating through each type\n      codecs = codecs.filter(codec => filtered.indexOf(codec) === -1);\n    }\n  });\n  level.unknownCodecs = codecs;\n}\nfunction assignCodec(media, groupItem, codecProperty) {\n  const codecValue = groupItem[codecProperty];\n  if (codecValue) {\n    media[codecProperty] = codecValue;\n  }\n}\nfunction backfillProgramDateTimes(fragments, firstPdtIndex) {\n  let fragPrev = fragments[firstPdtIndex];\n  for (let i = firstPdtIndex; i--;) {\n    const frag = fragments[i];\n    // Exit on delta-playlist skipped segments\n    if (!frag) {\n      return;\n    }\n    frag.programDateTime = fragPrev.programDateTime - frag.duration * 1000;\n    fragPrev = frag;\n  }\n}\nfunction assignProgramDateTime(frag, prevFrag, programDateTimes) {\n  if (frag.rawProgramDateTime) {\n    programDateTimes.push(frag);\n  } else if (prevFrag != null && prevFrag.programDateTime) {\n    frag.programDateTime = prevFrag.endProgramDateTime;\n  }\n}\nfunction setInitSegment(frag, mapAttrs, id, levelkeys) {\n  frag.relurl = mapAttrs.URI;\n  if (mapAttrs.BYTERANGE) {\n    frag.setByteRange(mapAttrs.BYTERANGE);\n  }\n  frag.level = id;\n  frag.sn = 'initSegment';\n  if (levelkeys) {\n    frag.levelkeys = levelkeys;\n  }\n  frag.initSegment = null;\n}\nfunction setFragLevelKeys(frag, levelkeys, level) {\n  frag.levelkeys = levelkeys;\n  const {\n    encryptedFragments\n  } = level;\n  if ((!encryptedFragments.length || encryptedFragments[encryptedFragments.length - 1].levelkeys !== levelkeys) && Object.keys(levelkeys).some(format => levelkeys[format].isCommonEncryption)) {\n    encryptedFragments.push(frag);\n  }\n}\nfunction assignMultipleMediaPlaylistTagOccuranceError(level, tag, result) {\n  level.playlistParsingError = new Error(`#EXT-X-${tag} must not appear more than once (${result[0]})`);\n}\nfunction assignMustAppearBeforeSegmentsError(level, tag, result) {\n  level.playlistParsingError = new Error(`#EXT-X-${tag} must appear before the first Media Segment (${result[0]})`);\n}\n\nfunction updateFromToPTS(fragFrom, fragTo) {\n  const fragToPTS = fragTo.startPTS;\n  // if we know startPTS[toIdx]\n  if (isFiniteNumber(fragToPTS)) {\n    // update fragment duration.\n    // it helps to fix drifts between playlist reported duration and fragment real duration\n    let duration = 0;\n    let frag;\n    if (fragTo.sn > fragFrom.sn) {\n      duration = fragToPTS - fragFrom.start;\n      frag = fragFrom;\n    } else {\n      duration = fragFrom.start - fragToPTS;\n      frag = fragTo;\n    }\n    if (frag.duration !== duration) {\n      frag.setDuration(duration);\n    }\n    // we dont know startPTS[toIdx]\n  } else if (fragTo.sn > fragFrom.sn) {\n    const contiguous = fragFrom.cc === fragTo.cc;\n    // TODO: With part-loading end/durations we need to confirm the whole fragment is loaded before using (or setting) minEndPTS\n    if (contiguous && fragFrom.minEndPTS) {\n      fragTo.setStart(fragFrom.start + (fragFrom.minEndPTS - fragFrom.start));\n    } else {\n      fragTo.setStart(fragFrom.start + fragFrom.duration);\n    }\n  } else {\n    fragTo.setStart(Math.max(fragFrom.start - fragTo.duration, 0));\n  }\n}\nfunction updateFragPTSDTS(details, frag, startPTS, endPTS, startDTS, endDTS) {\n  const parsedMediaDuration = endPTS - startPTS;\n  if (parsedMediaDuration <= 0) {\n    logger.warn('Fragment should have a positive duration', frag);\n    endPTS = startPTS + frag.duration;\n    endDTS = startDTS + frag.duration;\n  }\n  let maxStartPTS = startPTS;\n  let minEndPTS = endPTS;\n  const fragStartPts = frag.startPTS;\n  const fragEndPts = frag.endPTS;\n  if (isFiniteNumber(fragStartPts)) {\n    // delta PTS between audio and video\n    const deltaPTS = Math.abs(fragStartPts - startPTS);\n    if (!isFiniteNumber(frag.deltaPTS)) {\n      frag.deltaPTS = deltaPTS;\n    } else {\n      frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);\n    }\n    maxStartPTS = Math.max(startPTS, fragStartPts);\n    startPTS = Math.min(startPTS, fragStartPts);\n    startDTS = Math.min(startDTS, frag.startDTS);\n    minEndPTS = Math.min(endPTS, fragEndPts);\n    endPTS = Math.max(endPTS, fragEndPts);\n    endDTS = Math.max(endDTS, frag.endDTS);\n  }\n  const drift = startPTS - frag.start;\n  if (frag.start !== 0) {\n    frag.setStart(startPTS);\n  }\n  frag.setDuration(endPTS - frag.start);\n  frag.startPTS = startPTS;\n  frag.maxStartPTS = maxStartPTS;\n  frag.startDTS = startDTS;\n  frag.endPTS = endPTS;\n  frag.minEndPTS = minEndPTS;\n  frag.endDTS = endDTS;\n  const sn = frag.sn;\n  // exit if sn out of range\n  if (!details || sn < details.startSN || sn > details.endSN) {\n    return 0;\n  }\n  let i;\n  const fragIdx = sn - details.startSN;\n  const fragments = details.fragments;\n  // update frag reference in fragments array\n  // rationale is that fragments array might not contain this frag object.\n  // this will happen if playlist has been refreshed between frag loading and call to updateFragPTSDTS()\n  // if we don't update frag, we won't be able to propagate PTS info on the playlist\n  // resulting in invalid sliding computation\n  fragments[fragIdx] = frag;\n  // adjust fragment PTS/duration from seqnum-1 to frag 0\n  for (i = fragIdx; i > 0; i--) {\n    updateFromToPTS(fragments[i], fragments[i - 1]);\n  }\n\n  // adjust fragment PTS/duration from seqnum to last frag\n  for (i = fragIdx; i < fragments.length - 1; i++) {\n    updateFromToPTS(fragments[i], fragments[i + 1]);\n  }\n  if (details.fragmentHint) {\n    updateFromToPTS(fragments[fragments.length - 1], details.fragmentHint);\n  }\n  details.PTSKnown = details.alignedSliding = true;\n  return drift;\n}\nfunction mergeDetails(oldDetails, newDetails) {\n  if (oldDetails === newDetails) {\n    return;\n  }\n  // Track the last initSegment processed. Initialize it to the last one on the timeline.\n  let currentInitSegment = null;\n  const oldFragments = oldDetails.fragments;\n  for (let i = oldFragments.length - 1; i >= 0; i--) {\n    const oldInit = oldFragments[i].initSegment;\n    if (oldInit) {\n      currentInitSegment = oldInit;\n      break;\n    }\n  }\n  if (oldDetails.fragmentHint) {\n    // prevent PTS and duration from being adjusted on the next hint\n    delete oldDetails.fragmentHint.endPTS;\n  }\n  // check if old/new playlists have fragments in common\n  // loop through overlapping SN and update startPTS, cc, and duration if any found\n  let PTSFrag;\n  mapFragmentIntersection(oldDetails, newDetails, (oldFrag, newFrag, newFragIndex, newFragments) => {\n    if ((!newDetails.startCC || newDetails.skippedSegments) && newFrag.cc !== oldFrag.cc) {\n      const ccOffset = oldFrag.cc - newFrag.cc;\n      for (let i = newFragIndex; i < newFragments.length; i++) {\n        newFragments[i].cc += ccOffset;\n      }\n      newDetails.endCC = newFragments[newFragments.length - 1].cc;\n    }\n    if (isFiniteNumber(oldFrag.startPTS) && isFiniteNumber(oldFrag.endPTS)) {\n      newFrag.setStart(newFrag.startPTS = oldFrag.startPTS);\n      newFrag.startDTS = oldFrag.startDTS;\n      newFrag.maxStartPTS = oldFrag.maxStartPTS;\n      newFrag.endPTS = oldFrag.endPTS;\n      newFrag.endDTS = oldFrag.endDTS;\n      newFrag.minEndPTS = oldFrag.minEndPTS;\n      newFrag.setDuration(oldFrag.endPTS - oldFrag.startPTS);\n      if (newFrag.duration) {\n        PTSFrag = newFrag;\n      }\n\n      // PTS is known when any segment has startPTS and endPTS\n      newDetails.PTSKnown = newDetails.alignedSliding = true;\n    }\n    if (oldFrag.hasStreams) {\n      newFrag.elementaryStreams = oldFrag.elementaryStreams;\n    }\n    newFrag.loader = oldFrag.loader;\n    if (oldFrag.hasStats) {\n      newFrag.stats = oldFrag.stats;\n    }\n    if (oldFrag.initSegment) {\n      newFrag.initSegment = oldFrag.initSegment;\n      currentInitSegment = oldFrag.initSegment;\n    }\n  });\n  const newFragments = newDetails.fragments;\n  const fragmentsToCheck = newDetails.fragmentHint ? newFragments.concat(newDetails.fragmentHint) : newFragments;\n  if (currentInitSegment) {\n    fragmentsToCheck.forEach(frag => {\n      var _currentInitSegment;\n      if (frag && (!frag.initSegment || frag.initSegment.relurl === ((_currentInitSegment = currentInitSegment) == null ? void 0 : _currentInitSegment.relurl))) {\n        frag.initSegment = currentInitSegment;\n      }\n    });\n  }\n  if (newDetails.skippedSegments) {\n    newDetails.deltaUpdateFailed = newFragments.some(frag => !frag);\n    if (newDetails.deltaUpdateFailed) {\n      logger.warn('[level-helper] Previous playlist missing segments skipped in delta playlist');\n      for (let i = newDetails.skippedSegments; i--;) {\n        newFragments.shift();\n      }\n      newDetails.startSN = newFragments[0].sn;\n    } else {\n      if (newDetails.canSkipDateRanges) {\n        newDetails.dateRanges = mergeDateRanges(oldDetails.dateRanges, newDetails);\n      }\n      const programDateTimes = oldDetails.fragments.filter(frag => frag.rawProgramDateTime);\n      if (oldDetails.hasProgramDateTime && !newDetails.hasProgramDateTime) {\n        for (let i = 1; i < fragmentsToCheck.length; i++) {\n          if (fragmentsToCheck[i].programDateTime === null) {\n            assignProgramDateTime(fragmentsToCheck[i], fragmentsToCheck[i - 1], programDateTimes);\n          }\n        }\n      }\n      mapDateRanges(programDateTimes, newDetails);\n    }\n    newDetails.endCC = newFragments[newFragments.length - 1].cc;\n  }\n  if (!newDetails.startCC) {\n    var _fragPriorToNewStart$;\n    const fragPriorToNewStart = getFragmentWithSN(oldDetails, newDetails.startSN - 1);\n    newDetails.startCC = (_fragPriorToNewStart$ = fragPriorToNewStart == null ? void 0 : fragPriorToNewStart.cc) != null ? _fragPriorToNewStart$ : newFragments[0].cc;\n  }\n\n  // Merge parts\n  mapPartIntersection(oldDetails.partList, newDetails.partList, (oldPart, newPart) => {\n    newPart.elementaryStreams = oldPart.elementaryStreams;\n    newPart.stats = oldPart.stats;\n  });\n\n  // if at least one fragment contains PTS info, recompute PTS information for all fragments\n  if (PTSFrag) {\n    updateFragPTSDTS(newDetails, PTSFrag, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);\n  } else {\n    // ensure that delta is within oldFragments range\n    // also adjust sliding in case delta is 0 (we could have old=[50-60] and new=old=[50-61])\n    // in that case we also need to adjust start offset of all fragments\n    adjustSliding(oldDetails, newDetails);\n  }\n  if (newFragments.length) {\n    newDetails.totalduration = newDetails.edge - newFragments[0].start;\n  }\n  newDetails.driftStartTime = oldDetails.driftStartTime;\n  newDetails.driftStart = oldDetails.driftStart;\n  const advancedDateTime = newDetails.advancedDateTime;\n  if (newDetails.advanced && advancedDateTime) {\n    const edge = newDetails.edge;\n    if (!newDetails.driftStart) {\n      newDetails.driftStartTime = advancedDateTime;\n      newDetails.driftStart = edge;\n    }\n    newDetails.driftEndTime = advancedDateTime;\n    newDetails.driftEnd = edge;\n  } else {\n    newDetails.driftEndTime = oldDetails.driftEndTime;\n    newDetails.driftEnd = oldDetails.driftEnd;\n    newDetails.advancedDateTime = oldDetails.advancedDateTime;\n  }\n  if (newDetails.requestScheduled === -1) {\n    newDetails.requestScheduled = oldDetails.requestScheduled;\n  }\n}\nfunction mergeDateRanges(oldDateRanges, newDetails) {\n  const {\n    dateRanges: deltaDateRanges,\n    recentlyRemovedDateranges\n  } = newDetails;\n  const dateRanges = _extends({}, oldDateRanges);\n  if (recentlyRemovedDateranges) {\n    recentlyRemovedDateranges.forEach(id => {\n      delete dateRanges[id];\n    });\n  }\n  const mergeIds = Object.keys(dateRanges);\n  const mergeCount = mergeIds.length;\n  if (mergeCount) {\n    Object.keys(deltaDateRanges).forEach(id => {\n      const mergedDateRange = dateRanges[id];\n      const dateRange = new DateRange(deltaDateRanges[id].attr, mergedDateRange);\n      if (dateRange.isValid) {\n        dateRanges[id] = dateRange;\n        if (!mergedDateRange) {\n          dateRange.tagOrder += mergeCount;\n        }\n      } else {\n        logger.warn(`Ignoring invalid Playlist Delta Update DATERANGE tag: \"${stringify(deltaDateRanges[id].attr)}\"`);\n      }\n    });\n  }\n  return dateRanges;\n}\nfunction mapPartIntersection(oldParts, newParts, intersectionFn) {\n  if (oldParts && newParts) {\n    let delta = 0;\n    for (let i = 0, len = oldParts.length; i <= len; i++) {\n      const oldPart = oldParts[i];\n      const newPart = newParts[i + delta];\n      if (oldPart && newPart && oldPart.index === newPart.index && oldPart.fragment.sn === newPart.fragment.sn) {\n        intersectionFn(oldPart, newPart);\n      } else {\n        delta--;\n      }\n    }\n  }\n}\nfunction mapFragmentIntersection(oldDetails, newDetails, intersectionFn) {\n  const skippedSegments = newDetails.skippedSegments;\n  const start = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN;\n  const end = (oldDetails.fragmentHint ? 1 : 0) + (skippedSegments ? newDetails.endSN : Math.min(oldDetails.endSN, newDetails.endSN)) - newDetails.startSN;\n  const delta = newDetails.startSN - oldDetails.startSN;\n  const newFrags = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;\n  const oldFrags = oldDetails.fragmentHint ? oldDetails.fragments.concat(oldDetails.fragmentHint) : oldDetails.fragments;\n  for (let i = start; i <= end; i++) {\n    const oldFrag = oldFrags[delta + i];\n    let newFrag = newFrags[i];\n    if (skippedSegments && !newFrag && oldFrag) {\n      // Fill in skipped segments in delta playlist\n      newFrag = newDetails.fragments[i] = oldFrag;\n    }\n    if (oldFrag && newFrag) {\n      intersectionFn(oldFrag, newFrag, i, newFrags);\n      if (oldFrag.url && oldFrag.url !== newFrag.url) {\n        newDetails.playlistParsingError = getSequenceError(`media sequence mismatch ${newFrag.sn}:`, oldDetails, newDetails, oldFrag, newFrag);\n        return;\n      } else if (oldFrag.cc !== newFrag.cc) {\n        newDetails.playlistParsingError = getSequenceError(`discontinuity sequence mismatch (${oldFrag.cc}!=${newFrag.cc})`, oldDetails, newDetails, oldFrag, newFrag);\n        return;\n      }\n    }\n  }\n}\nfunction getSequenceError(message, oldDetails, newDetails, oldFrag, newFrag) {\n  return new Error(`${message} ${newFrag.url}\nPlaylist starting @${oldDetails.startSN}\n${oldDetails.m3u8}\n\nPlaylist starting @${newDetails.startSN}\n${newDetails.m3u8}`);\n}\nfunction adjustSliding(oldDetails, newDetails, matchingStableVariantOrRendition = true) {\n  const delta = newDetails.startSN + newDetails.skippedSegments - oldDetails.startSN;\n  const oldFragments = oldDetails.fragments;\n  const advancedOrStable = delta >= 0;\n  let sliding = 0;\n  if (advancedOrStable && delta < oldFragments.length) {\n    sliding = oldFragments[delta].start;\n  } else if (advancedOrStable && newDetails.startSN === oldDetails.endSN + 1) {\n    sliding = oldDetails.fragmentEnd;\n  } else if (advancedOrStable && matchingStableVariantOrRendition) {\n    // align with expected position (updated playlist start sequence is past end sequence of last update)\n    sliding = oldDetails.fragmentStart + delta * newDetails.levelTargetDuration;\n  } else if (!newDetails.skippedSegments && newDetails.fragmentStart === 0) {\n    // align new start with old (playlist switch has a sequence with no overlap and should not be used for alignment)\n    sliding = oldDetails.fragmentStart;\n  } else {\n    // new details already has a sliding offset or has skipped segments\n    return;\n  }\n  addSliding(newDetails, sliding);\n}\nfunction addSliding(details, sliding) {\n  if (sliding) {\n    const fragments = details.fragments;\n    for (let i = details.skippedSegments; i < fragments.length; i++) {\n      fragments[i].addStart(sliding);\n    }\n    if (details.fragmentHint) {\n      details.fragmentHint.addStart(sliding);\n    }\n  }\n}\nfunction computeReloadInterval(newDetails, distanceToLiveEdgeMs = Infinity) {\n  let reloadInterval = 1000 * newDetails.targetduration;\n  if (newDetails.updated) {\n    // Use last segment duration when shorter than target duration and near live edge\n    const fragments = newDetails.fragments;\n    const liveEdgeMaxTargetDurations = 4;\n    if (fragments.length && reloadInterval * liveEdgeMaxTargetDurations > distanceToLiveEdgeMs) {\n      const lastSegmentDuration = fragments[fragments.length - 1].duration * 1000;\n      if (lastSegmentDuration < reloadInterval) {\n        reloadInterval = lastSegmentDuration;\n      }\n    }\n  } else {\n    // estimate = 'miss half average';\n    // follow HLS Spec, If the client reloads a Playlist file and finds that it has not\n    // changed then it MUST wait for a period of one-half the target\n    // duration before retrying.\n    reloadInterval /= 2;\n  }\n  return Math.round(reloadInterval);\n}\nfunction getFragmentWithSN(details, sn, fragCurrent) {\n  if (!details) {\n    return null;\n  }\n  let fragment = details.fragments[sn - details.startSN];\n  if (fragment) {\n    return fragment;\n  }\n  fragment = details.fragmentHint;\n  if (fragment && fragment.sn === sn) {\n    return fragment;\n  }\n  if (sn < details.startSN && fragCurrent && fragCurrent.sn === sn) {\n    return fragCurrent;\n  }\n  return null;\n}\nfunction getPartWith(details, sn, partIndex) {\n  if (!details) {\n    return null;\n  }\n  return findPart(details.partList, sn, partIndex);\n}\nfunction findPart(partList, sn, partIndex) {\n  if (partList) {\n    for (let i = partList.length; i--;) {\n      const part = partList[i];\n      if (part.index === partIndex && part.fragment.sn === sn) {\n        return part;\n      }\n    }\n  }\n  return null;\n}\nfunction reassignFragmentLevelIndexes(levels) {\n  levels.forEach((level, index) => {\n    var _level$details;\n    (_level$details = level.details) == null ? void 0 : _level$details.fragments.forEach(fragment => {\n      fragment.level = index;\n      if (fragment.initSegment) {\n        fragment.initSegment.level = index;\n      }\n    });\n  });\n}\n\nfunction findFirstFragWithCC(fragments, cc) {\n  for (let i = 0, len = fragments.length; i < len; i++) {\n    var _fragments$i;\n    if (((_fragments$i = fragments[i]) == null ? void 0 : _fragments$i.cc) === cc) {\n      return fragments[i];\n    }\n  }\n  return null;\n}\nfunction shouldAlignOnDiscontinuities(refDetails, details) {\n  if (refDetails) {\n    if (details.startCC < refDetails.endCC && details.endCC > refDetails.startCC) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction adjustFragmentStart(frag, sliding) {\n  if (frag) {\n    const start = frag.start + sliding;\n    frag.start = frag.startPTS = start;\n    frag.endPTS = start + frag.duration;\n  }\n}\nfunction adjustSlidingStart(sliding, details) {\n  // Update segments\n  const fragments = details.fragments;\n  for (let i = 0, len = fragments.length; i < len; i++) {\n    adjustFragmentStart(fragments[i], sliding);\n  }\n  // Update LL-HLS parts at the end of the playlist\n  if (details.fragmentHint) {\n    adjustFragmentStart(details.fragmentHint, sliding);\n  }\n  details.alignedSliding = true;\n}\n\n/**\n * Using the parameters of the last level, this function computes PTS' of the new fragments so that they form a\n * contiguous stream with the last fragments.\n * The PTS of a fragment lets Hls.js know where it fits into a stream - by knowing every PTS, we know which fragment to\n * download at any given time. PTS is normally computed when the fragment is demuxed, so taking this step saves us time\n * and an extra download.\n * @param lastLevel\n * @param details\n */\nfunction alignStream(switchDetails, details) {\n  if (!switchDetails) {\n    return;\n  }\n  alignDiscontinuities(details, switchDetails);\n  if (!details.alignedSliding && switchDetails) {\n    // If the PTS wasn't figured out via discontinuity sequence that means there was no CC increase within the level.\n    // Aligning via Program Date Time should therefore be reliable, since PDT should be the same within the same\n    // discontinuity sequence.\n    alignMediaPlaylistByPDT(details, switchDetails);\n  }\n  if (!details.alignedSliding && switchDetails && !details.skippedSegments) {\n    // Try to align on sn so that we pick a better start fragment.\n    // Do not perform this on playlists with delta updates as this is only to align levels on switch\n    // and adjustSliding only adjusts fragments after skippedSegments.\n    adjustSliding(switchDetails, details, false);\n  }\n}\n\n/**\n * Ajust the start of fragments in `details` by the difference in time between fragments of the latest\n * shared discontinuity sequence change.\n * @param lastLevel - The details of the last loaded level\n * @param details - The details of the new level\n */\nfunction alignDiscontinuities(details, refDetails) {\n  if (!shouldAlignOnDiscontinuities(refDetails, details)) {\n    return;\n  }\n  const targetCC = Math.min(refDetails.endCC, details.endCC);\n  const refFrag = findFirstFragWithCC(refDetails.fragments, targetCC);\n  const frag = findFirstFragWithCC(details.fragments, targetCC);\n  if (!refFrag || !frag) {\n    return;\n  }\n  logger.log(`Aligning playlist at start of dicontinuity sequence ${targetCC}`);\n  const delta = refFrag.start - frag.start;\n  adjustSlidingStart(delta, details);\n}\n\n/**\n * Ensures appropriate time-alignment between renditions based on PDT.\n * This function assumes the timelines represented in `refDetails` are accurate, including the PDTs\n * for the last discontinuity sequence number shared by both playlists when present,\n * and uses the \"wallclock\"/PDT timeline as a cross-reference to `details`, adjusting the presentation\n * times/timelines of `details` accordingly.\n * Given the asynchronous nature of fetches and initial loads of live `main` and audio/subtitle tracks,\n * the primary purpose of this function is to ensure the \"local timelines\" of audio/subtitle tracks\n * are aligned to the main/video timeline, using PDT as the cross-reference/\"anchor\" that should\n * be consistent across playlists, per the HLS spec.\n * @param details - The details of the rendition you'd like to time-align (e.g. an audio rendition).\n * @param refDetails - The details of the reference rendition with start and PDT times for alignment.\n */\nfunction alignMediaPlaylistByPDT(details, refDetails) {\n  if (!details.hasProgramDateTime || !refDetails.hasProgramDateTime) {\n    return;\n  }\n  const fragments = details.fragments;\n  const refFragments = refDetails.fragments;\n  if (!fragments.length || !refFragments.length) {\n    return;\n  }\n\n  // Calculate a delta to apply to all fragments according to the delta in PDT times and start times\n  // of a fragment in the reference details, and a fragment in the target details of the same discontinuity.\n  // If a fragment of the same discontinuity was not found use the middle fragment of both.\n  let refFrag;\n  let frag;\n  const targetCC = Math.min(refDetails.endCC, details.endCC);\n  if (refDetails.startCC < targetCC && details.startCC < targetCC) {\n    refFrag = findFirstFragWithCC(refFragments, targetCC);\n    frag = findFirstFragWithCC(fragments, targetCC);\n  }\n  if (!refFrag || !frag) {\n    refFrag = refFragments[Math.floor(refFragments.length / 2)];\n    frag = findFirstFragWithCC(fragments, refFrag.cc) || fragments[Math.floor(fragments.length / 2)];\n  }\n  const refPDT = refFrag.programDateTime;\n  const targetPDT = frag.programDateTime;\n  if (!refPDT || !targetPDT) {\n    return;\n  }\n  const delta = (targetPDT - refPDT) / 1000 - (frag.start - refFrag.start);\n  adjustSlidingStart(delta, details);\n}\n\n/**\n *  TimeRanges to string helper\n */\n\nconst TimeRanges = {\n  toString: function (r) {\n    let log = '';\n    const len = r.length;\n    for (let i = 0; i < len; i++) {\n      log += `[${r.start(i).toFixed(3)}-${r.end(i).toFixed(3)}]`;\n    }\n    return log;\n  }\n};\n\nconst State = {\n  STOPPED: 'STOPPED',\n  IDLE: 'IDLE',\n  KEY_LOADING: 'KEY_LOADING',\n  FRAG_LOADING: 'FRAG_LOADING',\n  FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',\n  WAITING_TRACK: 'WAITING_TRACK',\n  PARSING: 'PARSING',\n  PARSED: 'PARSED',\n  ENDED: 'ENDED',\n  ERROR: 'ERROR',\n  WAITING_INIT_PTS: 'WAITING_INIT_PTS',\n  WAITING_LEVEL: 'WAITING_LEVEL'\n};\nclass BaseStreamController extends TaskLoop {\n  constructor(hls, fragmentTracker, keyLoader, logPrefix, playlistType) {\n    super(logPrefix, hls.logger);\n    this.hls = void 0;\n    this.fragPrevious = null;\n    this.fragCurrent = null;\n    this.fragmentTracker = void 0;\n    this.transmuxer = null;\n    this._state = State.STOPPED;\n    this.playlistType = void 0;\n    this.media = null;\n    this.mediaBuffer = null;\n    this.config = void 0;\n    this.bitrateTest = false;\n    this.lastCurrentTime = 0;\n    this.nextLoadPosition = 0;\n    this.startPosition = 0;\n    this.startTimeOffset = null;\n    this.retryDate = 0;\n    this.levels = null;\n    this.fragmentLoader = void 0;\n    this.keyLoader = void 0;\n    this.levelLastLoaded = null;\n    this.startFragRequested = false;\n    this.decrypter = void 0;\n    this.initPTS = [];\n    this.buffering = true;\n    this.loadingParts = false;\n    this.loopSn = void 0;\n    this.onMediaSeeking = () => {\n      const {\n        config,\n        fragCurrent,\n        media,\n        mediaBuffer,\n        state\n      } = this;\n      const currentTime = media ? media.currentTime : 0;\n      const bufferInfo = BufferHelper.bufferInfo(mediaBuffer ? mediaBuffer : media, currentTime, config.maxBufferHole);\n      const noFowardBuffer = !bufferInfo.len;\n      this.log(`Media seeking to ${isFiniteNumber(currentTime) ? currentTime.toFixed(3) : currentTime}, state: ${state}, ${noFowardBuffer ? 'out of' : 'in'} buffer`);\n      if (this.state === State.ENDED) {\n        this.resetLoadingState();\n      } else if (fragCurrent) {\n        // Seeking while frag load is in progress\n        const tolerance = config.maxFragLookUpTolerance;\n        const fragStartOffset = fragCurrent.start - tolerance;\n        const fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;\n        // if seeking out of buffered range or into new one\n        if (noFowardBuffer || fragEndOffset < bufferInfo.start || fragStartOffset > bufferInfo.end) {\n          const pastFragment = currentTime > fragEndOffset;\n          // if the seek position is outside the current fragment range\n          if (currentTime < fragStartOffset || pastFragment) {\n            if (pastFragment && fragCurrent.loader) {\n              this.log(`Cancelling fragment load for seek (sn: ${fragCurrent.sn})`);\n              fragCurrent.abortRequests();\n              this.resetLoadingState();\n            }\n            this.fragPrevious = null;\n          }\n        }\n      }\n      if (media) {\n        // Remove gap fragments\n        this.fragmentTracker.removeFragmentsInRange(currentTime, Infinity, this.playlistType, true);\n\n        // Don't set lastCurrentTime with backward seeks (allows for frag selection with strict tolerances)\n        const lastCurrentTime = this.lastCurrentTime;\n        if (currentTime > lastCurrentTime) {\n          this.lastCurrentTime = currentTime;\n        }\n        if (!this.loadingParts) {\n          const bufferEnd = Math.max(bufferInfo.end, currentTime);\n          const shouldLoadParts = this.shouldLoadParts(this.getLevelDetails(), bufferEnd);\n          if (shouldLoadParts) {\n            this.log(`LL-Part loading ON after seeking to ${currentTime.toFixed(2)} with buffer @${bufferEnd.toFixed(2)}`);\n            this.loadingParts = shouldLoadParts;\n          }\n        }\n      }\n\n      // in case seeking occurs although no media buffered, adjust startPosition and nextLoadPosition to seek target\n      if (!this.hls.hasEnoughToStart) {\n        this.log(`Setting ${noFowardBuffer ? 'startPosition' : 'nextLoadPosition'} to ${currentTime} for seek without enough to start`);\n        this.nextLoadPosition = currentTime;\n        if (noFowardBuffer) {\n          this.startPosition = currentTime;\n        }\n      }\n\n      // Async tick to speed up processing\n      this.tickImmediate();\n    };\n    this.onMediaEnded = () => {\n      // reset startPosition and lastCurrentTime to restart playback @ stream beginning\n      this.log(`setting startPosition to 0 because media ended`);\n      this.startPosition = this.lastCurrentTime = 0;\n    };\n    this.playlistType = playlistType;\n    this.hls = hls;\n    this.fragmentLoader = new FragmentLoader(hls.config);\n    this.keyLoader = keyLoader;\n    this.fragmentTracker = fragmentTracker;\n    this.config = hls.config;\n    this.decrypter = new Decrypter(hls.config);\n  }\n  registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.on(Events.ERROR, this.onError, this);\n  }\n  unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.off(Events.ERROR, this.onError, this);\n  }\n  doTick() {\n    this.onTickEnd();\n  }\n  onTickEnd() {}\n  startLoad(startPosition) {}\n  stopLoad() {\n    if (this.state === State.STOPPED) {\n      return;\n    }\n    this.fragmentLoader.abort();\n    this.keyLoader.abort(this.playlistType);\n    const frag = this.fragCurrent;\n    if (frag != null && frag.loader) {\n      frag.abortRequests();\n      this.fragmentTracker.removeFragment(frag);\n    }\n    this.resetTransmuxer();\n    this.fragCurrent = null;\n    this.fragPrevious = null;\n    this.clearInterval();\n    this.clearNextTick();\n    this.state = State.STOPPED;\n  }\n  get startPositionValue() {\n    const {\n      nextLoadPosition,\n      startPosition\n    } = this;\n    if (startPosition === -1 && nextLoadPosition) {\n      return nextLoadPosition;\n    }\n    return startPosition;\n  }\n  get bufferingEnabled() {\n    return this.buffering;\n  }\n  pauseBuffering() {\n    this.buffering = false;\n  }\n  resumeBuffering() {\n    this.buffering = true;\n  }\n  get inFlightFrag() {\n    return {\n      frag: this.fragCurrent,\n      state: this.state\n    };\n  }\n  _streamEnded(bufferInfo, levelDetails) {\n    // Stream is never \"ended\" when playlist is live or media is detached\n    if (levelDetails.live || !this.media) {\n      return false;\n    }\n    // Stream is not \"ended\" when nothing is buffered past the start\n    const bufferEnd = bufferInfo.end || 0;\n    const timelineStart = this.config.timelineOffset || 0;\n    if (bufferEnd <= timelineStart) {\n      return false;\n    }\n    // Stream is not \"ended\" when there is a second buffered range starting before the end of the playlist\n    const bufferedRanges = bufferInfo.buffered;\n    if (this.config.maxBufferHole && bufferedRanges && bufferedRanges.length > 1) {\n      // make sure bufferInfo accounts for any gaps\n      bufferInfo = BufferHelper.bufferedInfo(bufferedRanges, bufferInfo.start, 0);\n    }\n    const nextStart = bufferInfo.nextStart;\n    const hasSecondBufferedRange = nextStart && nextStart > timelineStart && nextStart < levelDetails.edge;\n    if (hasSecondBufferedRange) {\n      return false;\n    }\n    // Playhead is in unbuffered region. Marking EoS now could result in Safari failing to dispatch \"ended\" event following seek on start.\n    if (this.media.currentTime < bufferInfo.start) {\n      return false;\n    }\n    const partList = levelDetails.partList;\n    // Since the last part isn't guaranteed to correspond to the last playlist segment for Low-Latency HLS,\n    // check instead if the last part is buffered.\n    if (partList != null && partList.length) {\n      const lastPart = partList[partList.length - 1];\n\n      // Checking the midpoint of the part for potential margin of error and related issues.\n      // NOTE: Technically I believe parts could yield content that is < the computed duration (including potential a duration of 0)\n      // and still be spec-compliant, so there may still be edge cases here. Likewise, there could be issues in end of stream\n      // part mismatches for independent audio and video playlists/segments.\n      const lastPartBuffered = BufferHelper.isBuffered(this.media, lastPart.start + lastPart.duration / 2);\n      return lastPartBuffered;\n    }\n    const playlistType = levelDetails.fragments[levelDetails.fragments.length - 1].type;\n    return this.fragmentTracker.isEndListAppended(playlistType);\n  }\n  getLevelDetails() {\n    if (this.levels && this.levelLastLoaded !== null) {\n      var _this$levelLastLoaded;\n      return (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details;\n    }\n  }\n  get timelineOffset() {\n    const configuredTimelineOffset = this.config.timelineOffset;\n    if (configuredTimelineOffset) {\n      var _this$getLevelDetails;\n      return ((_this$getLevelDetails = this.getLevelDetails()) == null ? void 0 : _this$getLevelDetails.appliedTimelineOffset) || configuredTimelineOffset;\n    }\n    return 0;\n  }\n  onMediaAttached(event, data) {\n    const media = this.media = this.mediaBuffer = data.media;\n    media.removeEventListener('seeking', this.onMediaSeeking);\n    media.removeEventListener('ended', this.onMediaEnded);\n    media.addEventListener('seeking', this.onMediaSeeking);\n    media.addEventListener('ended', this.onMediaEnded);\n    const config = this.config;\n    if (this.levels && config.autoStartLoad && this.state === State.STOPPED) {\n      this.startLoad(config.startPosition);\n    }\n  }\n  onMediaDetaching(event, data) {\n    const transferringMedia = !!data.transferMedia;\n    const media = this.media;\n    if (media === null) {\n      return;\n    }\n    if (media.ended) {\n      this.log('MSE detaching and video ended, reset startPosition');\n      this.startPosition = this.lastCurrentTime = 0;\n    }\n\n    // remove video listeners\n    media.removeEventListener('seeking', this.onMediaSeeking);\n    media.removeEventListener('ended', this.onMediaEnded);\n    if (this.keyLoader && !transferringMedia) {\n      this.keyLoader.detach();\n    }\n    this.media = this.mediaBuffer = null;\n    this.loopSn = undefined;\n    if (transferringMedia) {\n      this.resetLoadingState();\n      this.resetTransmuxer();\n      return;\n    }\n    this.loadingParts = false;\n    this.fragmentTracker.removeAllFragments();\n    this.stopLoad();\n  }\n  onManifestLoading() {\n    this.initPTS = [];\n    this.levels = this.levelLastLoaded = this.fragCurrent = null;\n    this.lastCurrentTime = this.startPosition = 0;\n    this.startFragRequested = false;\n  }\n  onError(event, data) {}\n  onManifestLoaded(event, data) {\n    this.startTimeOffset = data.startTimeOffset;\n  }\n  onHandlerDestroying() {\n    this.stopLoad();\n    if (this.transmuxer) {\n      this.transmuxer.destroy();\n      this.transmuxer = null;\n    }\n    super.onHandlerDestroying();\n    // @ts-ignore\n    this.hls = this.onMediaSeeking = this.onMediaEnded = null;\n  }\n  onHandlerDestroyed() {\n    this.state = State.STOPPED;\n    if (this.fragmentLoader) {\n      this.fragmentLoader.destroy();\n    }\n    if (this.keyLoader) {\n      this.keyLoader.destroy();\n    }\n    if (this.decrypter) {\n      this.decrypter.destroy();\n    }\n    this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null;\n    super.onHandlerDestroyed();\n  }\n  loadFragment(frag, level, targetBufferTime) {\n    this.startFragRequested = true;\n    this._loadFragForPlayback(frag, level, targetBufferTime);\n  }\n  _loadFragForPlayback(fragment, level, targetBufferTime) {\n    const progressCallback = data => {\n      const frag = data.frag;\n      if (this.fragContextChanged(frag)) {\n        this.warn(`${frag.type} sn: ${frag.sn}${data.part ? ' part: ' + data.part.index : ''} of ${this.fragInfo(frag, false, data.part)}) was dropped during download.`);\n        this.fragmentTracker.removeFragment(frag);\n        return;\n      }\n      frag.stats.chunkCount++;\n      this._handleFragmentLoadProgress(data);\n    };\n    this._doFragLoad(fragment, level, targetBufferTime, progressCallback).then(data => {\n      if (!data) {\n        // if we're here we probably needed to backtrack or are waiting for more parts\n        return;\n      }\n      const state = this.state;\n      const frag = data.frag;\n      if (this.fragContextChanged(frag)) {\n        if (state === State.FRAG_LOADING || !this.fragCurrent && state === State.PARSING) {\n          this.fragmentTracker.removeFragment(frag);\n          this.state = State.IDLE;\n        }\n        return;\n      }\n      if ('payload' in data) {\n        this.log(`Loaded ${frag.type} sn: ${frag.sn} of ${this.playlistLabel()} ${frag.level}`);\n        this.hls.trigger(Events.FRAG_LOADED, data);\n      }\n\n      // Pass through the whole payload; controllers not implementing progressive loading receive data from this callback\n      this._handleFragmentLoadComplete(data);\n    }).catch(reason => {\n      if (this.state === State.STOPPED || this.state === State.ERROR) {\n        return;\n      }\n      this.warn(`Frag error: ${(reason == null ? void 0 : reason.message) || reason}`);\n      this.resetFragmentLoading(fragment);\n    });\n  }\n  clearTrackerIfNeeded(frag) {\n    var _this$mediaBuffer;\n    const {\n      fragmentTracker\n    } = this;\n    const fragState = fragmentTracker.getState(frag);\n    if (fragState === FragmentState.APPENDING) {\n      // Lower the max buffer length and try again\n      const playlistType = frag.type;\n      const bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);\n      const minForwardBufferLength = Math.max(frag.duration, bufferedInfo ? bufferedInfo.len : this.config.maxBufferLength);\n      // If backtracking, always remove from the tracker without reducing max buffer length\n      const backtrackFragment = this.backtrackFragment;\n      const backtracked = backtrackFragment ? frag.sn - backtrackFragment.sn : 0;\n      if (backtracked === 1 || this.reduceMaxBufferLength(minForwardBufferLength, frag.duration)) {\n        fragmentTracker.removeFragment(frag);\n      }\n    } else if (((_this$mediaBuffer = this.mediaBuffer) == null ? void 0 : _this$mediaBuffer.buffered.length) === 0) {\n      // Stop gap for bad tracker / buffer flush behavior\n      fragmentTracker.removeAllFragments();\n    } else if (fragmentTracker.hasParts(frag.type)) {\n      // In low latency mode, remove fragments for which only some parts were buffered\n      fragmentTracker.detectPartialFragments({\n        frag,\n        part: null,\n        stats: frag.stats,\n        id: frag.type\n      });\n      if (fragmentTracker.getState(frag) === FragmentState.PARTIAL) {\n        fragmentTracker.removeFragment(frag);\n      }\n    }\n  }\n  checkLiveUpdate(details) {\n    if (details.updated && !details.live) {\n      // Live stream ended, update fragment tracker\n      const lastFragment = details.fragments[details.fragments.length - 1];\n      this.fragmentTracker.detectPartialFragments({\n        frag: lastFragment,\n        part: null,\n        stats: lastFragment.stats,\n        id: lastFragment.type\n      });\n    }\n    if (!details.fragments[0]) {\n      details.deltaUpdateFailed = true;\n    }\n  }\n  waitForLive(levelInfo) {\n    const details = levelInfo.details;\n    return (details == null ? void 0 : details.live) && details.type !== 'EVENT' && (this.levelLastLoaded !== levelInfo || details.expired);\n  }\n  flushMainBuffer(startOffset, endOffset, type = null) {\n    if (!(startOffset - endOffset)) {\n      return;\n    }\n    // When alternate audio is playing, the audio-stream-controller is responsible for the audio buffer. Otherwise,\n    // passing a null type flushes both buffers\n    const flushScope = {\n      startOffset,\n      endOffset,\n      type\n    };\n    this.hls.trigger(Events.BUFFER_FLUSHING, flushScope);\n  }\n  _loadInitSegment(fragment, level) {\n    this._doFragLoad(fragment, level).then(data => {\n      const frag = data == null ? void 0 : data.frag;\n      if (!frag || this.fragContextChanged(frag) || !this.levels) {\n        throw new Error('init load aborted');\n      }\n      return data;\n    }).then(data => {\n      const {\n        hls\n      } = this;\n      const {\n        frag,\n        payload\n      } = data;\n      const decryptData = frag.decryptdata;\n\n      // check to see if the payload needs to be decrypted\n      if (payload && payload.byteLength > 0 && decryptData != null && decryptData.key && decryptData.iv && isFullSegmentEncryption(decryptData.method)) {\n        const startTime = self.performance.now();\n        // decrypt init segment data\n        return this.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer, getAesModeFromFullSegmentMethod(decryptData.method)).catch(err => {\n          hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.FRAG_DECRYPT_ERROR,\n            fatal: false,\n            error: err,\n            reason: err.message,\n            frag\n          });\n          throw err;\n        }).then(decryptedData => {\n          const endTime = self.performance.now();\n          hls.trigger(Events.FRAG_DECRYPTED, {\n            frag,\n            payload: decryptedData,\n            stats: {\n              tstart: startTime,\n              tdecrypt: endTime\n            }\n          });\n          data.payload = decryptedData;\n          return this.completeInitSegmentLoad(data);\n        });\n      }\n      return this.completeInitSegmentLoad(data);\n    }).catch(reason => {\n      if (this.state === State.STOPPED || this.state === State.ERROR) {\n        return;\n      }\n      this.warn(reason);\n      this.resetFragmentLoading(fragment);\n    });\n  }\n  completeInitSegmentLoad(data) {\n    const {\n      levels\n    } = this;\n    if (!levels) {\n      throw new Error('init load aborted, missing levels');\n    }\n    const stats = data.frag.stats;\n    if (this.state !== State.STOPPED) {\n      this.state = State.IDLE;\n    }\n    data.frag.data = new Uint8Array(data.payload);\n    stats.parsing.start = stats.buffering.start = self.performance.now();\n    stats.parsing.end = stats.buffering.end = self.performance.now();\n    this.tick();\n  }\n  fragContextChanged(frag) {\n    const {\n      fragCurrent\n    } = this;\n    return !frag || !fragCurrent || frag.sn !== fragCurrent.sn || frag.level !== fragCurrent.level;\n  }\n  fragBufferedComplete(frag, part) {\n    const media = this.mediaBuffer ? this.mediaBuffer : this.media;\n    this.log(`Buffered ${frag.type} sn: ${frag.sn}${part ? ' part: ' + part.index : ''} of ${this.fragInfo(frag, false, part)} > buffer:${media ? TimeRanges.toString(BufferHelper.getBuffered(media)) : '(detached)'})`);\n    if (isMediaFragment(frag)) {\n      var _this$levels;\n      if (frag.type !== PlaylistLevelType.SUBTITLE) {\n        const el = frag.elementaryStreams;\n        if (!Object.keys(el).some(type => !!el[type])) {\n          // empty segment\n          this.state = State.IDLE;\n          return;\n        }\n      }\n      const level = (_this$levels = this.levels) == null ? void 0 : _this$levels[frag.level];\n      if (level != null && level.fragmentError) {\n        this.log(`Resetting level fragment error count of ${level.fragmentError} on frag buffered`);\n        level.fragmentError = 0;\n      }\n    }\n    this.state = State.IDLE;\n  }\n  _handleFragmentLoadComplete(fragLoadedEndData) {\n    const {\n      transmuxer\n    } = this;\n    if (!transmuxer) {\n      return;\n    }\n    const {\n      frag,\n      part,\n      partsLoaded\n    } = fragLoadedEndData;\n    // If we did not load parts, or loaded all parts, we have complete (not partial) fragment data\n    const complete = !partsLoaded || partsLoaded.length === 0 || partsLoaded.some(fragLoaded => !fragLoaded);\n    const chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount + 1, 0, part ? part.index : -1, !complete);\n    transmuxer.flush(chunkMeta);\n  }\n  _handleFragmentLoadProgress(frag) {}\n  _doFragLoad(frag, level, targetBufferTime = null, progressCallback) {\n    var _frag$decryptdata;\n    this.fragCurrent = frag;\n    const details = level == null ? void 0 : level.details;\n    if (!this.levels || !details) {\n      throw new Error(`frag load aborted, missing level${details ? '' : ' detail'}s`);\n    }\n    let keyLoadingPromise = null;\n    if (frag.encrypted && !((_frag$decryptdata = frag.decryptdata) != null && _frag$decryptdata.key)) {\n      this.log(`Loading key for ${frag.sn} of [${details.startSN}-${details.endSN}], ${this.playlistLabel()} ${frag.level}`);\n      this.state = State.KEY_LOADING;\n      this.fragCurrent = frag;\n      keyLoadingPromise = this.keyLoader.load(frag).then(keyLoadedData => {\n        if (!this.fragContextChanged(keyLoadedData.frag)) {\n          this.hls.trigger(Events.KEY_LOADED, keyLoadedData);\n          if (this.state === State.KEY_LOADING) {\n            this.state = State.IDLE;\n          }\n          return keyLoadedData;\n        }\n      });\n      this.hls.trigger(Events.KEY_LOADING, {\n        frag\n      });\n      if (this.fragCurrent === null) {\n        keyLoadingPromise = Promise.reject(new Error(`frag load aborted, context changed in KEY_LOADING`));\n      }\n    } else if (!frag.encrypted) {\n      keyLoadingPromise = this.keyLoader.loadClear(frag, details.encryptedFragments, this.startFragRequested);\n      if (keyLoadingPromise) {\n        this.log(`[eme] blocking frag load until media-keys acquired`);\n      }\n    }\n    const fragPrevious = this.fragPrevious;\n    if (isMediaFragment(frag) && (!fragPrevious || frag.sn !== fragPrevious.sn)) {\n      const shouldLoadParts = this.shouldLoadParts(level.details, frag.end);\n      if (shouldLoadParts !== this.loadingParts) {\n        this.log(`LL-Part loading ${shouldLoadParts ? 'ON' : 'OFF'} loading sn ${fragPrevious == null ? void 0 : fragPrevious.sn}->${frag.sn}`);\n        this.loadingParts = shouldLoadParts;\n      }\n    }\n    targetBufferTime = Math.max(frag.start, targetBufferTime || 0);\n    if (this.loadingParts && isMediaFragment(frag)) {\n      const partList = details.partList;\n      if (partList && progressCallback) {\n        if (targetBufferTime > frag.end && details.fragmentHint) {\n          frag = details.fragmentHint;\n        }\n        const partIndex = this.getNextPart(partList, frag, targetBufferTime);\n        if (partIndex > -1) {\n          const part = partList[partIndex];\n          frag = this.fragCurrent = part.fragment;\n          this.log(`Loading ${frag.type} sn: ${frag.sn} part: ${part.index} (${partIndex}/${partList.length - 1}) of ${this.fragInfo(frag, false, part)}) cc: ${frag.cc} [${details.startSN}-${details.endSN}], target: ${parseFloat(targetBufferTime.toFixed(3))}`);\n          this.nextLoadPosition = part.start + part.duration;\n          this.state = State.FRAG_LOADING;\n          let _result;\n          if (keyLoadingPromise) {\n            _result = keyLoadingPromise.then(keyLoadedData => {\n              if (!keyLoadedData || this.fragContextChanged(keyLoadedData.frag)) {\n                return null;\n              }\n              return this.doFragPartsLoad(frag, part, level, progressCallback);\n            }).catch(error => this.handleFragLoadError(error));\n          } else {\n            _result = this.doFragPartsLoad(frag, part, level, progressCallback).catch(error => this.handleFragLoadError(error));\n          }\n          this.hls.trigger(Events.FRAG_LOADING, {\n            frag,\n            part,\n            targetBufferTime\n          });\n          if (this.fragCurrent === null) {\n            return Promise.reject(new Error(`frag load aborted, context changed in FRAG_LOADING parts`));\n          }\n          return _result;\n        } else if (!frag.url || this.loadedEndOfParts(partList, targetBufferTime)) {\n          // Fragment hint has no parts\n          return Promise.resolve(null);\n        }\n      }\n    }\n    if (isMediaFragment(frag) && this.loadingParts) {\n      this.log(`LL-Part loading OFF after next part miss @${targetBufferTime.toFixed(2)}`);\n      this.loadingParts = false;\n    } else if (!frag.url) {\n      // Selected fragment hint for part but not loading parts\n      return Promise.resolve(null);\n    }\n    this.log(`Loading ${frag.type} sn: ${frag.sn} of ${this.fragInfo(frag, false)}) cc: ${frag.cc} ${details ? '[' + details.startSN + '-' + details.endSN + ']' : ''}, target: ${parseFloat(targetBufferTime.toFixed(3))}`);\n    // Don't update nextLoadPosition for fragments which are not buffered\n    if (isFiniteNumber(frag.sn) && !this.bitrateTest) {\n      this.nextLoadPosition = frag.start + frag.duration;\n    }\n    this.state = State.FRAG_LOADING;\n\n    // Load key before streaming fragment data\n    const dataOnProgress = this.config.progressive;\n    let result;\n    if (dataOnProgress && keyLoadingPromise) {\n      result = keyLoadingPromise.then(keyLoadedData => {\n        if (!keyLoadedData || this.fragContextChanged(keyLoadedData == null ? void 0 : keyLoadedData.frag)) {\n          return null;\n        }\n        return this.fragmentLoader.load(frag, progressCallback);\n      }).catch(error => this.handleFragLoadError(error));\n    } else {\n      // load unencrypted fragment data with progress event,\n      // or handle fragment result after key and fragment are finished loading\n      result = Promise.all([this.fragmentLoader.load(frag, dataOnProgress ? progressCallback : undefined), keyLoadingPromise]).then(([fragLoadedData]) => {\n        if (!dataOnProgress && fragLoadedData && progressCallback) {\n          progressCallback(fragLoadedData);\n        }\n        return fragLoadedData;\n      }).catch(error => this.handleFragLoadError(error));\n    }\n    this.hls.trigger(Events.FRAG_LOADING, {\n      frag,\n      targetBufferTime\n    });\n    if (this.fragCurrent === null) {\n      return Promise.reject(new Error(`frag load aborted, context changed in FRAG_LOADING`));\n    }\n    return result;\n  }\n  doFragPartsLoad(frag, fromPart, level, progressCallback) {\n    return new Promise((resolve, reject) => {\n      var _level$details;\n      const partsLoaded = [];\n      const initialPartList = (_level$details = level.details) == null ? void 0 : _level$details.partList;\n      const loadPart = part => {\n        this.fragmentLoader.loadPart(frag, part, progressCallback).then(partLoadedData => {\n          partsLoaded[part.index] = partLoadedData;\n          const loadedPart = partLoadedData.part;\n          this.hls.trigger(Events.FRAG_LOADED, partLoadedData);\n          const nextPart = getPartWith(level.details, frag.sn, part.index + 1) || findPart(initialPartList, frag.sn, part.index + 1);\n          if (nextPart) {\n            loadPart(nextPart);\n          } else {\n            return resolve({\n              frag,\n              part: loadedPart,\n              partsLoaded\n            });\n          }\n        }).catch(reject);\n      };\n      loadPart(fromPart);\n    });\n  }\n  handleFragLoadError(error) {\n    if ('data' in error) {\n      const data = error.data;\n      if (error.data && data.details === ErrorDetails.INTERNAL_ABORTED) {\n        this.handleFragLoadAborted(data.frag, data.part);\n      } else {\n        this.hls.trigger(Events.ERROR, data);\n      }\n    } else {\n      this.hls.trigger(Events.ERROR, {\n        type: ErrorTypes.OTHER_ERROR,\n        details: ErrorDetails.INTERNAL_EXCEPTION,\n        err: error,\n        error,\n        fatal: true\n      });\n    }\n    return null;\n  }\n  _handleTransmuxerFlush(chunkMeta) {\n    const context = this.getCurrentContext(chunkMeta);\n    if (!context || this.state !== State.PARSING) {\n      if (!this.fragCurrent && this.state !== State.STOPPED && this.state !== State.ERROR) {\n        this.state = State.IDLE;\n      }\n      return;\n    }\n    const {\n      frag,\n      part,\n      level\n    } = context;\n    const now = self.performance.now();\n    frag.stats.parsing.end = now;\n    if (part) {\n      part.stats.parsing.end = now;\n    }\n    // See if part loading should be disabled/enabled based on buffer and playback position.\n    const levelDetails = this.getLevelDetails();\n    const loadingPartsAtEdge = levelDetails && frag.sn > levelDetails.endSN;\n    const shouldLoadParts = loadingPartsAtEdge || this.shouldLoadParts(levelDetails, frag.end);\n    if (shouldLoadParts !== this.loadingParts) {\n      this.log(`LL-Part loading ${shouldLoadParts ? 'ON' : 'OFF'} after parsing segment ending @${frag.end.toFixed(2)}`);\n      this.loadingParts = shouldLoadParts;\n    }\n    this.updateLevelTiming(frag, part, level, chunkMeta.partial);\n  }\n  shouldLoadParts(details, bufferEnd) {\n    if (this.config.lowLatencyMode) {\n      if (!details) {\n        return this.loadingParts;\n      }\n      if (details != null && details.partList) {\n        var _details$fragmentHint;\n        // Buffer must be ahead of first part + duration of parts after last segment\n        // and playback must be at or past segment adjacent to part list\n        const firstPart = details.partList[0];\n        const safePartStart = firstPart.end + (((_details$fragmentHint = details.fragmentHint) == null ? void 0 : _details$fragmentHint.duration) || 0);\n        if (bufferEnd >= safePartStart) {\n          var _this$media;\n          const playhead = this.hls.hasEnoughToStart ? ((_this$media = this.media) == null ? void 0 : _this$media.currentTime) || this.lastCurrentTime : this.getLoadPosition();\n          if (playhead > firstPart.start - firstPart.fragment.duration) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  getCurrentContext(chunkMeta) {\n    const {\n      levels,\n      fragCurrent\n    } = this;\n    const {\n      level: levelIndex,\n      sn,\n      part: partIndex\n    } = chunkMeta;\n    if (!(levels != null && levels[levelIndex])) {\n      this.warn(`Levels object was unset while buffering fragment ${sn} of ${this.playlistLabel()} ${levelIndex}. The current chunk will not be buffered.`);\n      return null;\n    }\n    const level = levels[levelIndex];\n    const levelDetails = level.details;\n    const part = partIndex > -1 ? getPartWith(levelDetails, sn, partIndex) : null;\n    const frag = part ? part.fragment : getFragmentWithSN(levelDetails, sn, fragCurrent);\n    if (!frag) {\n      return null;\n    }\n    if (fragCurrent && fragCurrent !== frag) {\n      frag.stats = fragCurrent.stats;\n    }\n    return {\n      frag,\n      part,\n      level\n    };\n  }\n  bufferFragmentData(data, frag, part, chunkMeta, noBacktracking) {\n    var _buffer;\n    if (!data || this.state !== State.PARSING) {\n      return;\n    }\n    const {\n      data1,\n      data2\n    } = data;\n    let buffer = data1;\n    if (data1 && data2) {\n      // Combine the moof + mdat so that we buffer with a single append\n      buffer = appendUint8Array(data1, data2);\n    }\n    if (!((_buffer = buffer) != null && _buffer.length)) {\n      return;\n    }\n    const offsetTimestamp = this.initPTS[frag.cc];\n    const offset = offsetTimestamp ? -offsetTimestamp.baseTime / offsetTimestamp.timescale : undefined;\n    const segment = {\n      type: data.type,\n      frag,\n      part,\n      chunkMeta,\n      offset,\n      parent: frag.type,\n      data: buffer\n    };\n    this.hls.trigger(Events.BUFFER_APPENDING, segment);\n    if (data.dropped && data.independent && !part) {\n      if (noBacktracking) {\n        return;\n      }\n      // Clear buffer so that we reload previous segments sequentially if required\n      this.flushBufferGap(frag);\n    }\n  }\n  flushBufferGap(frag) {\n    const media = this.media;\n    if (!media) {\n      return;\n    }\n    // If currentTime is not buffered, clear the back buffer so that we can backtrack as much as needed\n    if (!BufferHelper.isBuffered(media, media.currentTime)) {\n      this.flushMainBuffer(0, frag.start);\n      return;\n    }\n    // Remove back-buffer without interrupting playback to allow back tracking\n    const currentTime = media.currentTime;\n    const bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);\n    const fragDuration = frag.duration;\n    const segmentFraction = Math.min(this.config.maxFragLookUpTolerance * 2, fragDuration * 0.25);\n    const start = Math.max(Math.min(frag.start - segmentFraction, bufferInfo.end - segmentFraction), currentTime + segmentFraction);\n    if (frag.start - start > segmentFraction) {\n      this.flushMainBuffer(start, frag.start);\n    }\n  }\n  getFwdBufferInfo(bufferable, type) {\n    var _this$media2;\n    const pos = this.getLoadPosition();\n    if (!isFiniteNumber(pos)) {\n      return null;\n    }\n    const backwardSeek = this.lastCurrentTime > pos;\n    const maxBufferHole = backwardSeek || (_this$media2 = this.media) != null && _this$media2.paused ? 0 : this.config.maxBufferHole;\n    return this.getFwdBufferInfoAtPos(bufferable, pos, type, maxBufferHole);\n  }\n  getFwdBufferInfoAtPos(bufferable, pos, type, maxBufferHole) {\n    const bufferInfo = BufferHelper.bufferInfo(bufferable, pos, maxBufferHole);\n    // Workaround flaw in getting forward buffer when maxBufferHole is smaller than gap at current pos\n    if (bufferInfo.len === 0 && bufferInfo.nextStart !== undefined) {\n      const bufferedFragAtPos = this.fragmentTracker.getBufferedFrag(pos, type);\n      if (bufferedFragAtPos && (bufferInfo.nextStart <= bufferedFragAtPos.end || bufferedFragAtPos.gap)) {\n        const gapDuration = Math.max(Math.min(bufferInfo.nextStart, bufferedFragAtPos.end) - pos, maxBufferHole);\n        return BufferHelper.bufferInfo(bufferable, pos, gapDuration);\n      }\n    }\n    return bufferInfo;\n  }\n  getMaxBufferLength(levelBitrate) {\n    const {\n      config\n    } = this;\n    let maxBufLen;\n    if (levelBitrate) {\n      maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);\n    } else {\n      maxBufLen = config.maxBufferLength;\n    }\n    return Math.min(maxBufLen, config.maxMaxBufferLength);\n  }\n  reduceMaxBufferLength(threshold, fragDuration) {\n    const config = this.config;\n    const minLength = Math.max(Math.min(threshold - fragDuration, config.maxBufferLength), fragDuration);\n    const reducedLength = Math.max(threshold - fragDuration * 3, config.maxMaxBufferLength / 2, minLength);\n    if (reducedLength >= minLength) {\n      // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...\n      config.maxMaxBufferLength = reducedLength;\n      this.warn(`Reduce max buffer length to ${reducedLength}s`);\n      return true;\n    }\n    return false;\n  }\n  getAppendedFrag(position, playlistType = PlaylistLevelType.MAIN) {\n    var _this$fragmentTracker;\n    const fragOrPart = (_this$fragmentTracker = this.fragmentTracker) == null ? void 0 : _this$fragmentTracker.getAppendedFrag(position, playlistType);\n    if (fragOrPart && 'fragment' in fragOrPart) {\n      return fragOrPart.fragment;\n    }\n    return fragOrPart;\n  }\n  getNextFragment(pos, levelDetails) {\n    const fragments = levelDetails.fragments;\n    const fragLen = fragments.length;\n    if (!fragLen) {\n      return null;\n    }\n\n    // find fragment index, contiguous with end of buffer position\n    const {\n      config\n    } = this;\n    const start = fragments[0].start;\n    const canLoadParts = config.lowLatencyMode && !!levelDetails.partList;\n    let frag = null;\n    if (levelDetails.live) {\n      const initialLiveManifestSize = config.initialLiveManifestSize;\n      if (fragLen < initialLiveManifestSize) {\n        this.warn(`Not enough fragments to start playback (have: ${fragLen}, need: ${initialLiveManifestSize})`);\n        return null;\n      }\n      // The real fragment start times for a live stream are only known after the PTS range for that level is known.\n      // In order to discover the range, we load the best matching fragment for that level and demux it.\n      // Do not load using live logic if the starting frag is requested - we want to use getFragmentAtPosition() so that\n      // we get the fragment matching that start time\n      if (!levelDetails.PTSKnown && !this.startFragRequested && this.startPosition === -1 || pos < start) {\n        var _frag;\n        if (canLoadParts && !this.loadingParts) {\n          this.log(`LL-Part loading ON for initial live fragment`);\n          this.loadingParts = true;\n        }\n        frag = this.getInitialLiveFragment(levelDetails);\n        const mainStart = this.hls.startPosition;\n        const liveSyncPosition = this.hls.liveSyncPosition;\n        const startPosition = frag ? (mainStart !== -1 && mainStart >= start ? mainStart : liveSyncPosition) || frag.start : pos;\n        this.log(`Setting startPosition to ${startPosition} to match start frag at live edge. mainStart: ${mainStart} liveSyncPosition: ${liveSyncPosition} frag.start: ${(_frag = frag) == null ? void 0 : _frag.start}`);\n        this.startPosition = this.nextLoadPosition = startPosition;\n      }\n    } else if (pos <= start) {\n      // VoD playlist: if loadPosition before start of playlist, load first fragment\n      frag = fragments[0];\n    }\n\n    // If we haven't run into any special cases already, just load the fragment most closely matching the requested position\n    if (!frag) {\n      const end = this.loadingParts ? levelDetails.partEnd : levelDetails.fragmentEnd;\n      frag = this.getFragmentAtPosition(pos, end, levelDetails);\n    }\n    let programFrag = this.filterReplacedPrimary(frag, levelDetails);\n    if (!programFrag && frag) {\n      const curSNIdx = frag.sn - levelDetails.startSN;\n      programFrag = this.filterReplacedPrimary(fragments[curSNIdx + 1] || null, levelDetails);\n    }\n    return this.mapToInitFragWhenRequired(programFrag);\n  }\n  isLoopLoading(frag, targetBufferTime) {\n    const trackerState = this.fragmentTracker.getState(frag);\n    return (trackerState === FragmentState.OK || trackerState === FragmentState.PARTIAL && !!frag.gap) && this.nextLoadPosition > targetBufferTime;\n  }\n  getNextFragmentLoopLoading(frag, levelDetails, bufferInfo, playlistType, maxBufLen) {\n    let nextFragment = null;\n    if (frag.gap) {\n      nextFragment = this.getNextFragment(this.nextLoadPosition, levelDetails);\n      if (nextFragment && !nextFragment.gap && bufferInfo.nextStart) {\n        // Media buffered after GAP tags should not make the next buffer timerange exceed forward buffer length\n        const nextbufferInfo = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, bufferInfo.nextStart, playlistType, 0);\n        if (nextbufferInfo !== null && bufferInfo.len + nextbufferInfo.len >= maxBufLen) {\n          // Returning here might result in not finding an audio and video candiate to skip to\n          const sn = nextFragment.sn;\n          if (this.loopSn !== sn) {\n            this.log(`buffer full after gaps in \"${playlistType}\" playlist starting at sn: ${sn}`);\n            this.loopSn = sn;\n          }\n          return null;\n        }\n      }\n    }\n    this.loopSn = undefined;\n    return nextFragment;\n  }\n  get primaryPrefetch() {\n    if (interstitialsEnabled(this.hls.config)) {\n      var _this$hls$interstitia, _this$hls$interstitia2;\n      const playingInterstitial = (_this$hls$interstitia = this.hls.interstitialsManager) == null ? void 0 : (_this$hls$interstitia2 = _this$hls$interstitia.playingItem) == null ? void 0 : _this$hls$interstitia2.event;\n      if (playingInterstitial) {\n        return true;\n      }\n    }\n    return false;\n  }\n  filterReplacedPrimary(frag, details) {\n    if (!frag) {\n      return frag;\n    }\n    if (interstitialsEnabled(this.hls.config) && frag.type !== PlaylistLevelType.SUBTITLE) {\n      // Do not load fragments outside the buffering schedule segment\n      const interstitials = this.hls.interstitialsManager;\n      const bufferingItem = interstitials == null ? void 0 : interstitials.bufferingItem;\n      if (bufferingItem) {\n        const bufferingInterstitial = bufferingItem.event;\n        if (bufferingInterstitial) {\n          // Do not stream fragments while buffering Interstitial Events (except for overlap at the start)\n          if (bufferingInterstitial.appendInPlace || Math.abs(frag.start - bufferingItem.start) > 1 || bufferingItem.start === 0) {\n            return null;\n          }\n        } else {\n          // Limit fragment loading to media in schedule item\n          if (frag.end <= bufferingItem.start && (details == null ? void 0 : details.live) === false) {\n            // fragment ends by schedule item start\n            // this.fragmentTracker.fragBuffered(frag, true);\n            return null;\n          }\n          if (frag.start > bufferingItem.end && bufferingItem.nextEvent) {\n            // fragment is past schedule item end\n            // allow some overflow when not appending in place to prevent stalls\n            if (bufferingItem.nextEvent.appendInPlace || frag.start - bufferingItem.end > 1) {\n              return null;\n            }\n          }\n        }\n      }\n      // Skip loading of fragments that overlap completely with appendInPlace interstitials\n      const playerQueue = interstitials == null ? void 0 : interstitials.playerQueue;\n      if (playerQueue) {\n        for (let i = playerQueue.length; i--;) {\n          const interstitial = playerQueue[i].interstitial;\n          if (interstitial.appendInPlace && frag.start >= interstitial.startTime && frag.end <= interstitial.resumeTime) {\n            return null;\n          }\n        }\n      }\n    }\n    return frag;\n  }\n  mapToInitFragWhenRequired(frag) {\n    // If an initSegment is present, it must be buffered first\n    if (frag != null && frag.initSegment && !(frag != null && frag.initSegment.data) && !this.bitrateTest) {\n      return frag.initSegment;\n    }\n    return frag;\n  }\n  getNextPart(partList, frag, targetBufferTime) {\n    let nextPart = -1;\n    let contiguous = false;\n    let independentAttrOmitted = true;\n    for (let i = 0, len = partList.length; i < len; i++) {\n      const part = partList[i];\n      independentAttrOmitted = independentAttrOmitted && !part.independent;\n      if (nextPart > -1 && targetBufferTime < part.start) {\n        break;\n      }\n      const loaded = part.loaded;\n      if (loaded) {\n        nextPart = -1;\n      } else if ((contiguous || part.independent || independentAttrOmitted) && part.fragment === frag) {\n        nextPart = i;\n      }\n      contiguous = loaded;\n    }\n    return nextPart;\n  }\n  loadedEndOfParts(partList, targetBufferTime) {\n    const lastPart = partList[partList.length - 1];\n    return lastPart && targetBufferTime > lastPart.start && lastPart.loaded;\n  }\n\n  /*\n   This method is used find the best matching first fragment for a live playlist. This fragment is used to calculate the\n   \"sliding\" of the playlist, which is its offset from the start of playback. After sliding we can compute the real\n   start and end times for each fragment in the playlist (after which this method will not need to be called).\n  */\n  getInitialLiveFragment(levelDetails) {\n    const fragments = levelDetails.fragments;\n    const fragPrevious = this.fragPrevious;\n    let frag = null;\n    if (fragPrevious) {\n      if (levelDetails.hasProgramDateTime) {\n        // Prefer using PDT, because it can be accurate enough to choose the correct fragment without knowing the level sliding\n        this.log(`Live playlist, switching playlist, load frag with same PDT: ${fragPrevious.programDateTime}`);\n        frag = findFragmentByPDT(fragments, fragPrevious.endProgramDateTime, this.config.maxFragLookUpTolerance);\n      }\n      if (!frag) {\n        // SN does not need to be accurate between renditions, but depending on the packaging it may be so.\n        const targetSN = fragPrevious.sn + 1;\n        if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {\n          const fragNext = fragments[targetSN - levelDetails.startSN];\n          // Ensure that we're staying within the continuity range, since PTS resets upon a new range\n          if (fragPrevious.cc === fragNext.cc) {\n            frag = fragNext;\n            this.log(`Live playlist, switching playlist, load frag with next SN: ${frag.sn}`);\n          }\n        }\n        // It's important to stay within the continuity range if available; otherwise the fragments in the playlist\n        // will have the wrong start times\n        if (!frag) {\n          frag = findNearestWithCC(levelDetails, fragPrevious.cc, fragPrevious.end);\n          if (frag) {\n            this.log(`Live playlist, switching playlist, load frag with same CC: ${frag.sn}`);\n          }\n        }\n      }\n    } else {\n      // Find a new start fragment when fragPrevious is null\n      const liveStart = this.hls.liveSyncPosition;\n      if (liveStart !== null) {\n        frag = this.getFragmentAtPosition(liveStart, this.bitrateTest ? levelDetails.fragmentEnd : levelDetails.edge, levelDetails);\n      }\n    }\n    return frag;\n  }\n\n  /*\n  This method finds the best matching fragment given the provided position.\n   */\n  getFragmentAtPosition(bufferEnd, end, levelDetails) {\n    const {\n      config\n    } = this;\n    let {\n      fragPrevious\n    } = this;\n    let {\n      fragments,\n      endSN\n    } = levelDetails;\n    const {\n      fragmentHint\n    } = levelDetails;\n    const {\n      maxFragLookUpTolerance\n    } = config;\n    const partList = levelDetails.partList;\n    const loadingParts = !!(this.loadingParts && partList != null && partList.length && fragmentHint);\n    if (loadingParts && fragmentHint && !this.bitrateTest && partList[partList.length - 1].fragment.sn === fragmentHint.sn) {\n      // Include incomplete fragment with parts at end\n      fragments = fragments.concat(fragmentHint);\n      endSN = fragmentHint.sn;\n    }\n    let frag;\n    if (bufferEnd < end) {\n      var _this$media3;\n      const backwardSeek = bufferEnd < this.lastCurrentTime;\n      const lookupTolerance = backwardSeek || bufferEnd > end - maxFragLookUpTolerance || (_this$media3 = this.media) != null && _this$media3.paused || !this.startFragRequested ? 0 : maxFragLookUpTolerance;\n      // Remove the tolerance if it would put the bufferEnd past the actual end of stream\n      // Uses buffer and sequence number to calculate switch segment (required if using EXT-X-DISCONTINUITY-SEQUENCE)\n      frag = findFragmentByPTS(fragPrevious, fragments, bufferEnd, lookupTolerance);\n    } else {\n      // reach end of playlist\n      frag = fragments[fragments.length - 1];\n    }\n    if (frag) {\n      const curSNIdx = frag.sn - levelDetails.startSN;\n      // Move fragPrevious forward to support forcing the next fragment to load\n      // when the buffer catches up to a previously buffered range.\n      const fragState = this.fragmentTracker.getState(frag);\n      if (fragState === FragmentState.OK || fragState === FragmentState.PARTIAL && frag.gap) {\n        fragPrevious = frag;\n      }\n      if (fragPrevious && frag.sn === fragPrevious.sn && (!loadingParts || partList[0].fragment.sn > frag.sn || !levelDetails.live && !loadingParts)) {\n        // Force the next fragment to load if the previous one was already selected. This can occasionally happen with\n        // non-uniform fragment durations\n        const sameLevel = fragPrevious && frag.level === fragPrevious.level;\n        if (sameLevel) {\n          const nextFrag = fragments[curSNIdx + 1];\n          if (frag.sn < endSN && this.fragmentTracker.getState(nextFrag) !== FragmentState.OK) {\n            frag = nextFrag;\n          } else {\n            frag = null;\n          }\n        }\n      }\n    }\n    return frag;\n  }\n  alignPlaylists(details, previousDetails, switchDetails) {\n    // TODO: If not for `shouldAlignOnDiscontinuities` requiring fragPrevious.cc,\n    //  this could all go in level-helper mergeDetails()\n    const length = details.fragments.length;\n    if (!length) {\n      this.warn(`No fragments in live playlist`);\n      return 0;\n    }\n    const slidingStart = details.fragmentStart;\n    const firstLevelLoad = !previousDetails;\n    const aligned = details.alignedSliding && isFiniteNumber(slidingStart);\n    if (firstLevelLoad || !aligned && !slidingStart) {\n      alignStream(switchDetails, details);\n      const alignedSlidingStart = details.fragmentStart;\n      this.log(`Live playlist sliding: ${alignedSlidingStart.toFixed(2)} start-sn: ${previousDetails ? previousDetails.startSN : 'na'}->${details.startSN} fragments: ${length}`);\n      return alignedSlidingStart;\n    }\n    return slidingStart;\n  }\n  waitForCdnTuneIn(details) {\n    // Wait for Low-Latency CDN Tune-in to get an updated playlist\n    const advancePartLimit = 3;\n    return details.live && details.canBlockReload && details.partTarget && details.tuneInGoal > Math.max(details.partHoldBack, details.partTarget * advancePartLimit);\n  }\n  setStartPosition(details, sliding) {\n    // compute start position if set to -1. use it straight away if value is defined\n    let startPosition = this.startPosition;\n    if (startPosition < sliding) {\n      startPosition = -1;\n    }\n    const timelineOffset = this.timelineOffset;\n    if (startPosition === -1) {\n      // Use Playlist EXT-X-START:TIME-OFFSET when set\n      // Prioritize Multivariant Playlist offset so that main, audio, and subtitle stream-controller start times match\n      const offsetInMultivariantPlaylist = this.startTimeOffset !== null;\n      const startTimeOffset = offsetInMultivariantPlaylist ? this.startTimeOffset : details.startTimeOffset;\n      if (startTimeOffset !== null && isFiniteNumber(startTimeOffset)) {\n        startPosition = sliding + startTimeOffset;\n        if (startTimeOffset < 0) {\n          startPosition += details.edge;\n        }\n        startPosition = Math.min(Math.max(sliding, startPosition), sliding + details.totalduration);\n        this.log(`Setting startPosition to ${startPosition} for start time offset ${startTimeOffset} found in ${offsetInMultivariantPlaylist ? 'multivariant' : 'media'} playlist`);\n        this.startPosition = startPosition;\n      } else if (details.live) {\n        // Leave this.startPosition at -1, so that we can use `getInitialLiveFragment` logic when startPosition has\n        // not been specified via the config or an as an argument to startLoad (#3736).\n        startPosition = this.hls.liveSyncPosition || sliding;\n        this.log(`Setting startPosition to -1 to start at live edge ${startPosition}`);\n        this.startPosition = -1;\n      } else {\n        this.log(`setting startPosition to 0 by default`);\n        this.startPosition = startPosition = 0;\n      }\n      this.lastCurrentTime = startPosition + timelineOffset;\n    }\n    this.nextLoadPosition = startPosition + timelineOffset;\n  }\n  getLoadPosition() {\n    var _this$hls;\n    const {\n      media\n    } = this;\n    // if we have not yet loaded any fragment, start loading from start position\n    let pos = 0;\n    if ((_this$hls = this.hls) != null && _this$hls.hasEnoughToStart && media) {\n      pos = media.currentTime;\n    } else if (this.nextLoadPosition >= 0) {\n      pos = this.nextLoadPosition;\n    }\n    return pos;\n  }\n  handleFragLoadAborted(frag, part) {\n    if (this.transmuxer && frag.type === this.playlistType && isMediaFragment(frag) && frag.stats.aborted) {\n      this.log(`Fragment ${frag.sn}${part ? ' part ' + part.index : ''} of ${this.playlistLabel()} ${frag.level} was aborted`);\n      this.resetFragmentLoading(frag);\n    }\n  }\n  resetFragmentLoading(frag) {\n    if (!this.fragCurrent || !this.fragContextChanged(frag) && this.state !== State.FRAG_LOADING_WAITING_RETRY) {\n      this.state = State.IDLE;\n    }\n  }\n  onFragmentOrKeyLoadError(filterType, data) {\n    if (data.chunkMeta && !data.frag) {\n      const context = this.getCurrentContext(data.chunkMeta);\n      if (context) {\n        data.frag = context.frag;\n      }\n    }\n    const frag = data.frag;\n    // Handle frag error related to caller's filterType\n    if (!frag || frag.type !== filterType || !this.levels) {\n      return;\n    }\n    if (this.fragContextChanged(frag)) {\n      var _this$fragCurrent;\n      this.warn(`Frag load error must match current frag to retry ${frag.url} > ${(_this$fragCurrent = this.fragCurrent) == null ? void 0 : _this$fragCurrent.url}`);\n      return;\n    }\n    const gapTagEncountered = data.details === ErrorDetails.FRAG_GAP;\n    if (gapTagEncountered) {\n      this.fragmentTracker.fragBuffered(frag, true);\n    }\n    // keep retrying until the limit will be reached\n    const errorAction = data.errorAction;\n    const {\n      action,\n      flags,\n      retryCount = 0,\n      retryConfig\n    } = errorAction || {};\n    const couldRetry = !!errorAction && !!retryConfig;\n    const retry = couldRetry && action === NetworkErrorAction.RetryRequest;\n    const noAlternate = couldRetry && !errorAction.resolved && flags === ErrorActionFlags.MoveAllAlternatesMatchingHost;\n    if (!retry && noAlternate && isMediaFragment(frag) && !frag.endList) {\n      this.resetFragmentErrors(filterType);\n      this.treatAsGap(frag);\n      errorAction.resolved = true;\n    } else if ((retry || noAlternate) && retryCount < retryConfig.maxNumRetry) {\n      this.resetStartWhenNotLoaded(this.levelLastLoaded);\n      const delay = getRetryDelay(retryConfig, retryCount);\n      this.warn(`Fragment ${frag.sn} of ${filterType} ${frag.level} errored with ${data.details}, retrying loading ${retryCount + 1}/${retryConfig.maxNumRetry} in ${delay}ms`);\n      errorAction.resolved = true;\n      this.retryDate = self.performance.now() + delay;\n      this.state = State.FRAG_LOADING_WAITING_RETRY;\n    } else if (retryConfig && errorAction) {\n      this.resetFragmentErrors(filterType);\n      if (retryCount < retryConfig.maxNumRetry) {\n        // Network retry is skipped when level switch is preferred\n        if (!gapTagEncountered && action !== NetworkErrorAction.RemoveAlternatePermanently) {\n          errorAction.resolved = true;\n        }\n      } else {\n        this.warn(`${data.details} reached or exceeded max retry (${retryCount})`);\n        return;\n      }\n    } else if (action === NetworkErrorAction.SendAlternateToPenaltyBox) {\n      this.state = State.WAITING_LEVEL;\n    } else {\n      this.state = State.ERROR;\n    }\n    // Perform next async tick sooner to speed up error action resolution\n    this.tickImmediate();\n  }\n  reduceLengthAndFlushBuffer(data) {\n    // if in appending state\n    if (this.state === State.PARSING || this.state === State.PARSED) {\n      const frag = data.frag;\n      const playlistType = data.parent;\n      const bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);\n      // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end\n      // reduce max buf len if current position is buffered\n      const buffered = bufferedInfo && bufferedInfo.len > 0.5;\n      if (buffered) {\n        this.reduceMaxBufferLength(bufferedInfo.len, (frag == null ? void 0 : frag.duration) || 10);\n      }\n      const flushBuffer = !buffered;\n      if (flushBuffer) {\n        // current position is not buffered, but browser is still complaining about buffer full error\n        // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708\n        // in that case flush the whole audio buffer to recover\n        this.warn(`Buffer full error while media.currentTime is not buffered, flush ${playlistType} buffer`);\n      }\n      if (frag) {\n        this.fragmentTracker.removeFragment(frag);\n        this.nextLoadPosition = frag.start;\n      }\n      this.resetLoadingState();\n      return flushBuffer;\n    }\n    return false;\n  }\n  resetFragmentErrors(filterType) {\n    if (filterType === PlaylistLevelType.AUDIO) {\n      // Reset current fragment since audio track audio is essential and may not have a fail-over track\n      this.fragCurrent = null;\n    }\n    // Fragment errors that result in a level switch or redundant fail-over\n    // should reset the stream controller state to idle\n    if (!this.hls.hasEnoughToStart) {\n      this.startFragRequested = false;\n    }\n    if (this.state !== State.STOPPED) {\n      this.state = State.IDLE;\n    }\n  }\n  afterBufferFlushed(media, bufferType, playlistType) {\n    if (!media) {\n      return;\n    }\n    // After successful buffer flushing, filter flushed fragments from bufferedFrags use mediaBuffered instead of media\n    // (so that we will check against video.buffered ranges in case of alt audio track)\n    const bufferedTimeRanges = BufferHelper.getBuffered(media);\n    this.fragmentTracker.detectEvictedFragments(bufferType, bufferedTimeRanges, playlistType);\n    if (this.state === State.ENDED) {\n      this.resetLoadingState();\n    }\n  }\n  resetLoadingState() {\n    this.log('Reset loading state');\n    this.fragCurrent = null;\n    this.fragPrevious = null;\n    if (this.state !== State.STOPPED) {\n      this.state = State.IDLE;\n    }\n  }\n  resetStartWhenNotLoaded(level) {\n    // if loadedmetadata is not set, it means that first frag request failed\n    // in that case, reset startFragRequested flag\n    if (!this.hls.hasEnoughToStart) {\n      this.startFragRequested = false;\n      const details = level ? level.details : null;\n      if (details != null && details.live) {\n        // Update the start position and return to IDLE to recover live start\n        this.log(`resetting startPosition for live start`);\n        this.startPosition = -1;\n        this.setStartPosition(details, details.fragmentStart);\n        this.resetLoadingState();\n      } else {\n        this.nextLoadPosition = this.startPosition;\n      }\n    }\n  }\n  resetWhenMissingContext(chunkMeta) {\n    this.warn(`The loading context changed while buffering fragment ${chunkMeta.sn} of ${this.playlistLabel()} ${chunkMeta.level}. This chunk will not be buffered.`);\n    this.removeUnbufferedFrags();\n    this.resetStartWhenNotLoaded(this.levelLastLoaded);\n    this.resetLoadingState();\n  }\n  removeUnbufferedFrags(start = 0) {\n    this.fragmentTracker.removeFragmentsInRange(start, Infinity, this.playlistType, false, true);\n  }\n  updateLevelTiming(frag, part, level, partial) {\n    const details = level.details;\n    if (!details) {\n      this.warn('level.details undefined');\n      return;\n    }\n    const parsed = Object.keys(frag.elementaryStreams).reduce((result, type) => {\n      const info = frag.elementaryStreams[type];\n      if (info) {\n        const parsedDuration = info.endPTS - info.startPTS;\n        if (parsedDuration <= 0) {\n          // Destroy the transmuxer after it's next time offset failed to advance because duration was <= 0.\n          // The new transmuxer will be configured with a time offset matching the next fragment start,\n          // preventing the timeline from shifting.\n          this.warn(`Could not parse fragment ${frag.sn} ${type} duration reliably (${parsedDuration})`);\n          return result || false;\n        }\n        const drift = partial ? 0 : updateFragPTSDTS(details, frag, info.startPTS, info.endPTS, info.startDTS, info.endDTS);\n        this.hls.trigger(Events.LEVEL_PTS_UPDATED, {\n          details,\n          level,\n          drift,\n          type,\n          frag,\n          start: info.startPTS,\n          end: info.endPTS\n        });\n        return true;\n      }\n      return result;\n    }, false);\n    if (!parsed) {\n      var _this$transmuxer;\n      if (level.fragmentError === 0) {\n        // Mark and track the odd empty segment as a gap to avoid reloading\n        this.treatAsGap(frag, level);\n      }\n      if (((_this$transmuxer = this.transmuxer) == null ? void 0 : _this$transmuxer.error) === null) {\n        const error = new Error(`Found no media in fragment ${frag.sn} of ${this.playlistLabel()} ${frag.level} resetting transmuxer to fallback to playlist timing`);\n        this.warn(error.message);\n        this.hls.trigger(Events.ERROR, {\n          type: ErrorTypes.MEDIA_ERROR,\n          details: ErrorDetails.FRAG_PARSING_ERROR,\n          fatal: false,\n          error,\n          frag,\n          reason: `Found no media in msn ${frag.sn} of ${this.playlistLabel()} \"${level.url}\"`\n        });\n        if (!this.hls) {\n          return;\n        }\n        this.resetTransmuxer();\n      }\n      // For this error fallthrough. Marking parsed will allow advancing to next fragment.\n    }\n    this.state = State.PARSED;\n    this.log(`Parsed ${frag.type} sn: ${frag.sn}${part ? ' part: ' + part.index : ''} of ${this.fragInfo(frag, false, part)})`);\n    this.hls.trigger(Events.FRAG_PARSED, {\n      frag,\n      part\n    });\n  }\n  playlistLabel() {\n    return this.playlistType === PlaylistLevelType.MAIN ? 'level' : 'track';\n  }\n  fragInfo(frag, pts = true, part) {\n    var _ref, _ref2;\n    return `${this.playlistLabel()} ${frag.level} (${part ? 'part' : 'frag'}:[${((_ref = pts && !part ? frag.startPTS : (part || frag).start) != null ? _ref : NaN).toFixed(3)}-${((_ref2 = pts && !part ? frag.endPTS : (part || frag).end) != null ? _ref2 : NaN).toFixed(3)}]${part && frag.type === 'main' ? 'INDEPENDENT=' + (part.independent ? 'YES' : 'NO') : ''}`;\n  }\n  treatAsGap(frag, level) {\n    if (level) {\n      level.fragmentError++;\n    }\n    frag.gap = true;\n    this.fragmentTracker.removeFragment(frag);\n    this.fragmentTracker.fragBuffered(frag, true);\n  }\n  resetTransmuxer() {\n    var _this$transmuxer2;\n    (_this$transmuxer2 = this.transmuxer) == null ? void 0 : _this$transmuxer2.reset();\n  }\n  recoverWorkerError(data) {\n    if (data.event === 'demuxerWorker') {\n      this.fragmentTracker.removeAllFragments();\n      if (this.transmuxer) {\n        this.transmuxer.destroy();\n        this.transmuxer = null;\n      }\n      this.resetStartWhenNotLoaded(this.levelLastLoaded);\n      this.resetLoadingState();\n    }\n  }\n  set state(nextState) {\n    const previousState = this._state;\n    if (previousState !== nextState) {\n      this._state = nextState;\n      this.log(`${previousState}->${nextState}`);\n    }\n  }\n  get state() {\n    return this._state;\n  }\n}\nfunction interstitialsEnabled(config) {\n  return !!config.interstitialsController && config.enableInterstitialPlayback !== false;\n}\n\nclass ChunkCache {\n  constructor() {\n    this.chunks = [];\n    this.dataLength = 0;\n  }\n  push(chunk) {\n    this.chunks.push(chunk);\n    this.dataLength += chunk.length;\n  }\n  flush() {\n    const {\n      chunks,\n      dataLength\n    } = this;\n    let result;\n    if (!chunks.length) {\n      return new Uint8Array(0);\n    } else if (chunks.length === 1) {\n      result = chunks[0];\n    } else {\n      result = concatUint8Arrays(chunks, dataLength);\n    }\n    this.reset();\n    return result;\n  }\n  reset() {\n    this.chunks.length = 0;\n    this.dataLength = 0;\n  }\n}\nfunction concatUint8Arrays(chunks, dataLength) {\n  const result = new Uint8Array(dataLength);\n  let offset = 0;\n  for (let i = 0; i < chunks.length; i++) {\n    const chunk = chunks[i];\n    result.set(chunk, offset);\n    offset += chunk.length;\n  }\n  return result;\n}\n\nvar eventemitter3 = {exports: {}};\n\nvar hasRequiredEventemitter3;\n\nfunction requireEventemitter3 () {\n\tif (hasRequiredEventemitter3) return eventemitter3.exports;\n\thasRequiredEventemitter3 = 1;\n\t(function (module) {\n\n\t\tvar has = Object.prototype.hasOwnProperty\n\t\t  , prefix = '~';\n\n\t\t/**\n\t\t * Constructor to create a storage for our `EE` objects.\n\t\t * An `Events` instance is a plain object whose properties are event names.\n\t\t *\n\t\t * @constructor\n\t\t * @private\n\t\t */\n\t\tfunction Events() {}\n\n\t\t//\n\t\t// We try to not inherit from `Object.prototype`. In some engines creating an\n\t\t// instance in this way is faster than calling `Object.create(null)` directly.\n\t\t// If `Object.create(null)` is not supported we prefix the event names with a\n\t\t// character to make sure that the built-in object properties are not\n\t\t// overridden or used as an attack vector.\n\t\t//\n\t\tif (Object.create) {\n\t\t  Events.prototype = Object.create(null);\n\n\t\t  //\n\t\t  // This hack is needed because the `__proto__` property is still inherited in\n\t\t  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n\t\t  //\n\t\t  if (!new Events().__proto__) prefix = false;\n\t\t}\n\n\t\t/**\n\t\t * Representation of a single event listener.\n\t\t *\n\t\t * @param {Function} fn The listener function.\n\t\t * @param {*} context The context to invoke the listener with.\n\t\t * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n\t\t * @constructor\n\t\t * @private\n\t\t */\n\t\tfunction EE(fn, context, once) {\n\t\t  this.fn = fn;\n\t\t  this.context = context;\n\t\t  this.once = once || false;\n\t\t}\n\n\t\t/**\n\t\t * Add a listener for a given event.\n\t\t *\n\t\t * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n\t\t * @param {(String|Symbol)} event The event name.\n\t\t * @param {Function} fn The listener function.\n\t\t * @param {*} context The context to invoke the listener with.\n\t\t * @param {Boolean} once Specify if the listener is a one-time listener.\n\t\t * @returns {EventEmitter}\n\t\t * @private\n\t\t */\n\t\tfunction addListener(emitter, event, fn, context, once) {\n\t\t  if (typeof fn !== 'function') {\n\t\t    throw new TypeError('The listener must be a function');\n\t\t  }\n\n\t\t  var listener = new EE(fn, context || emitter, once)\n\t\t    , evt = prefix ? prefix + event : event;\n\n\t\t  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n\t\t  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n\t\t  else emitter._events[evt] = [emitter._events[evt], listener];\n\n\t\t  return emitter;\n\t\t}\n\n\t\t/**\n\t\t * Clear event by name.\n\t\t *\n\t\t * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n\t\t * @param {(String|Symbol)} evt The Event name.\n\t\t * @private\n\t\t */\n\t\tfunction clearEvent(emitter, evt) {\n\t\t  if (--emitter._eventsCount === 0) emitter._events = new Events();\n\t\t  else delete emitter._events[evt];\n\t\t}\n\n\t\t/**\n\t\t * Minimal `EventEmitter` interface that is molded against the Node.js\n\t\t * `EventEmitter` interface.\n\t\t *\n\t\t * @constructor\n\t\t * @public\n\t\t */\n\t\tfunction EventEmitter() {\n\t\t  this._events = new Events();\n\t\t  this._eventsCount = 0;\n\t\t}\n\n\t\t/**\n\t\t * Return an array listing the events for which the emitter has registered\n\t\t * listeners.\n\t\t *\n\t\t * @returns {Array}\n\t\t * @public\n\t\t */\n\t\tEventEmitter.prototype.eventNames = function eventNames() {\n\t\t  var names = []\n\t\t    , events\n\t\t    , name;\n\n\t\t  if (this._eventsCount === 0) return names;\n\n\t\t  for (name in (events = this._events)) {\n\t\t    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n\t\t  }\n\n\t\t  if (Object.getOwnPropertySymbols) {\n\t\t    return names.concat(Object.getOwnPropertySymbols(events));\n\t\t  }\n\n\t\t  return names;\n\t\t};\n\n\t\t/**\n\t\t * Return the listeners registered for a given event.\n\t\t *\n\t\t * @param {(String|Symbol)} event The event name.\n\t\t * @returns {Array} The registered listeners.\n\t\t * @public\n\t\t */\n\t\tEventEmitter.prototype.listeners = function listeners(event) {\n\t\t  var evt = prefix ? prefix + event : event\n\t\t    , handlers = this._events[evt];\n\n\t\t  if (!handlers) return [];\n\t\t  if (handlers.fn) return [handlers.fn];\n\n\t\t  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n\t\t    ee[i] = handlers[i].fn;\n\t\t  }\n\n\t\t  return ee;\n\t\t};\n\n\t\t/**\n\t\t * Return the number of listeners listening to a given event.\n\t\t *\n\t\t * @param {(String|Symbol)} event The event name.\n\t\t * @returns {Number} The number of listeners.\n\t\t * @public\n\t\t */\n\t\tEventEmitter.prototype.listenerCount = function listenerCount(event) {\n\t\t  var evt = prefix ? prefix + event : event\n\t\t    , listeners = this._events[evt];\n\n\t\t  if (!listeners) return 0;\n\t\t  if (listeners.fn) return 1;\n\t\t  return listeners.length;\n\t\t};\n\n\t\t/**\n\t\t * Calls each of the listeners registered for a given event.\n\t\t *\n\t\t * @param {(String|Symbol)} event The event name.\n\t\t * @returns {Boolean} `true` if the event had listeners, else `false`.\n\t\t * @public\n\t\t */\n\t\tEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n\t\t  var evt = prefix ? prefix + event : event;\n\n\t\t  if (!this._events[evt]) return false;\n\n\t\t  var listeners = this._events[evt]\n\t\t    , len = arguments.length\n\t\t    , args\n\t\t    , i;\n\n\t\t  if (listeners.fn) {\n\t\t    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n\t\t    switch (len) {\n\t\t      case 1: return listeners.fn.call(listeners.context), true;\n\t\t      case 2: return listeners.fn.call(listeners.context, a1), true;\n\t\t      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n\t\t      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n\t\t      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n\t\t      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n\t\t    }\n\n\t\t    for (i = 1, args = new Array(len -1); i < len; i++) {\n\t\t      args[i - 1] = arguments[i];\n\t\t    }\n\n\t\t    listeners.fn.apply(listeners.context, args);\n\t\t  } else {\n\t\t    var length = listeners.length\n\t\t      , j;\n\n\t\t    for (i = 0; i < length; i++) {\n\t\t      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n\t\t      switch (len) {\n\t\t        case 1: listeners[i].fn.call(listeners[i].context); break;\n\t\t        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n\t\t        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n\t\t        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n\t\t        default:\n\t\t          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n\t\t            args[j - 1] = arguments[j];\n\t\t          }\n\n\t\t          listeners[i].fn.apply(listeners[i].context, args);\n\t\t      }\n\t\t    }\n\t\t  }\n\n\t\t  return true;\n\t\t};\n\n\t\t/**\n\t\t * Add a listener for a given event.\n\t\t *\n\t\t * @param {(String|Symbol)} event The event name.\n\t\t * @param {Function} fn The listener function.\n\t\t * @param {*} [context=this] The context to invoke the listener with.\n\t\t * @returns {EventEmitter} `this`.\n\t\t * @public\n\t\t */\n\t\tEventEmitter.prototype.on = function on(event, fn, context) {\n\t\t  return addListener(this, event, fn, context, false);\n\t\t};\n\n\t\t/**\n\t\t * Add a one-time listener for a given event.\n\t\t *\n\t\t * @param {(String|Symbol)} event The event name.\n\t\t * @param {Function} fn The listener function.\n\t\t * @param {*} [context=this] The context to invoke the listener with.\n\t\t * @returns {EventEmitter} `this`.\n\t\t * @public\n\t\t */\n\t\tEventEmitter.prototype.once = function once(event, fn, context) {\n\t\t  return addListener(this, event, fn, context, true);\n\t\t};\n\n\t\t/**\n\t\t * Remove the listeners of a given event.\n\t\t *\n\t\t * @param {(String|Symbol)} event The event name.\n\t\t * @param {Function} fn Only remove the listeners that match this function.\n\t\t * @param {*} context Only remove the listeners that have this context.\n\t\t * @param {Boolean} once Only remove one-time listeners.\n\t\t * @returns {EventEmitter} `this`.\n\t\t * @public\n\t\t */\n\t\tEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n\t\t  var evt = prefix ? prefix + event : event;\n\n\t\t  if (!this._events[evt]) return this;\n\t\t  if (!fn) {\n\t\t    clearEvent(this, evt);\n\t\t    return this;\n\t\t  }\n\n\t\t  var listeners = this._events[evt];\n\n\t\t  if (listeners.fn) {\n\t\t    if (\n\t\t      listeners.fn === fn &&\n\t\t      (!once || listeners.once) &&\n\t\t      (!context || listeners.context === context)\n\t\t    ) {\n\t\t      clearEvent(this, evt);\n\t\t    }\n\t\t  } else {\n\t\t    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n\t\t      if (\n\t\t        listeners[i].fn !== fn ||\n\t\t        (once && !listeners[i].once) ||\n\t\t        (context && listeners[i].context !== context)\n\t\t      ) {\n\t\t        events.push(listeners[i]);\n\t\t      }\n\t\t    }\n\n\t\t    //\n\t\t    // Reset the array, or remove it completely if we have no more listeners.\n\t\t    //\n\t\t    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n\t\t    else clearEvent(this, evt);\n\t\t  }\n\n\t\t  return this;\n\t\t};\n\n\t\t/**\n\t\t * Remove all listeners, or those of the specified event.\n\t\t *\n\t\t * @param {(String|Symbol)} [event] The event name.\n\t\t * @returns {EventEmitter} `this`.\n\t\t * @public\n\t\t */\n\t\tEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n\t\t  var evt;\n\n\t\t  if (event) {\n\t\t    evt = prefix ? prefix + event : event;\n\t\t    if (this._events[evt]) clearEvent(this, evt);\n\t\t  } else {\n\t\t    this._events = new Events();\n\t\t    this._eventsCount = 0;\n\t\t  }\n\n\t\t  return this;\n\t\t};\n\n\t\t//\n\t\t// Alias methods names because people roll like that.\n\t\t//\n\t\tEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\t\tEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n\t\t//\n\t\t// Expose the prefix.\n\t\t//\n\t\tEventEmitter.prefixed = prefix;\n\n\t\t//\n\t\t// Allow `EventEmitter` to be imported as module namespace.\n\t\t//\n\t\tEventEmitter.EventEmitter = EventEmitter;\n\n\t\t//\n\t\t// Expose the module.\n\t\t//\n\t\t{\n\t\t  module.exports = EventEmitter;\n\t\t} \n\t} (eventemitter3));\n\treturn eventemitter3.exports;\n}\n\nvar eventemitter3Exports = requireEventemitter3();\nvar EventEmitter = /*@__PURE__*/getDefaultExportFromCjs(eventemitter3Exports);\n\nconst version = \"1.6.7\";\n\n// ensure the worker ends up in the bundle\n// If the worker should not be included this gets aliased to empty.js\nconst workerStore = {};\nfunction hasUMDWorker() {\n  return typeof __HLS_WORKER_BUNDLE__ === 'function';\n}\nfunction injectWorker() {\n  const workerContext = workerStore[version];\n  if (workerContext) {\n    workerContext.clientCount++;\n    return workerContext;\n  }\n  const blob = new self.Blob([`var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(${__HLS_WORKER_BUNDLE__.toString()})(true);`], {\n    type: 'text/javascript'\n  });\n  const objectURL = self.URL.createObjectURL(blob);\n  const worker = new self.Worker(objectURL);\n  const result = {\n    worker,\n    objectURL,\n    clientCount: 1\n  };\n  workerStore[version] = result;\n  return result;\n}\nfunction loadWorker(path) {\n  const workerContext = workerStore[path];\n  if (workerContext) {\n    workerContext.clientCount++;\n    return workerContext;\n  }\n  const scriptURL = new self.URL(path, self.location.href).href;\n  const worker = new self.Worker(scriptURL);\n  const result = {\n    worker,\n    scriptURL,\n    clientCount: 1\n  };\n  workerStore[path] = result;\n  return result;\n}\nfunction removeWorkerFromStore(path) {\n  const workerContext = workerStore[path || version];\n  if (workerContext) {\n    const clientCount = workerContext.clientCount--;\n    if (clientCount === 1) {\n      const {\n        worker,\n        objectURL\n      } = workerContext;\n      delete workerStore[path || version];\n      if (objectURL) {\n        // revoke the Object URL that was used to create transmuxer worker, so as not to leak it\n        self.URL.revokeObjectURL(objectURL);\n      }\n      worker.terminate();\n    }\n  }\n}\n\n/**\n * Returns true if an ID3 footer can be found at offset in data\n *\n * @param data - The data to search in\n * @param offset - The offset at which to start searching\n *\n * @returns `true` if an ID3 footer is found\n *\n * @internal\n *\n * @group ID3\n */\nfunction isId3Footer(data, offset) {\n  /*\n   * The footer is a copy of the header, but with a different identifier\n   */\n  if (offset + 10 <= data.length) {\n    // look for '3DI' identifier\n    if (data[offset] === 0x33 && data[offset + 1] === 0x44 && data[offset + 2] === 0x49) {\n      // check version is within range\n      if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {\n        // check size is within range\n        if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Returns true if an ID3 header can be found at offset in data\n *\n * @param data - The data to search in\n * @param offset - The offset at which to start searching\n *\n * @returns `true` if an ID3 header is found\n *\n * @internal\n *\n * @group ID3\n */\nfunction isId3Header(data, offset) {\n  /*\n   * http://id3.org/id3v2.3.0\n   * [0]     = 'I'\n   * [1]     = 'D'\n   * [2]     = '3'\n   * [3,4]   = {Version}\n   * [5]     = {Flags}\n   * [6-9]   = {ID3 Size}\n   *\n   * An ID3v2 tag can be detected with the following pattern:\n   *  $49 44 33 yy yy xx zz zz zz zz\n   * Where yy is less than $FF, xx is the 'flags' byte and zz is less than $80\n   */\n  if (offset + 10 <= data.length) {\n    // look for 'ID3' identifier\n    if (data[offset] === 0x49 && data[offset + 1] === 0x44 && data[offset + 2] === 0x33) {\n      // check version is within range\n      if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {\n        // check size is within range\n        if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Read ID3 size\n *\n * @param data - The data to read from\n * @param offset - The offset at which to start reading\n *\n * @returns The size\n *\n * @internal\n *\n * @group ID3\n */\nfunction readId3Size(data, offset) {\n  let size = 0;\n  size = (data[offset] & 0x7f) << 21;\n  size |= (data[offset + 1] & 0x7f) << 14;\n  size |= (data[offset + 2] & 0x7f) << 7;\n  size |= data[offset + 3] & 0x7f;\n  return size;\n}\n\n/**\n * Returns any adjacent ID3 tags found in data starting at offset, as one block of data\n *\n * @param data - The data to search in\n * @param offset - The offset at which to start searching\n *\n * @returns The block of data containing any ID3 tags found\n * or `undefined` if no header is found at the starting offset\n *\n * @internal\n *\n * @group ID3\n */\nfunction getId3Data(data, offset) {\n  const front = offset;\n  let length = 0;\n  while (isId3Header(data, offset)) {\n    // ID3 header is 10 bytes\n    length += 10;\n    const size = readId3Size(data, offset + 6);\n    length += size;\n    if (isId3Footer(data, offset + 10)) {\n      // ID3 footer is 10 bytes\n      length += 10;\n    }\n    offset += length;\n  }\n  if (length > 0) {\n    return data.subarray(front, front + length);\n  }\n  return undefined;\n}\n\nfunction getAudioConfig(observer, data, offset, manifestCodec) {\n  const adtsSamplingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n  const byte2 = data[offset + 2];\n  const adtsSamplingIndex = byte2 >> 2 & 0xf;\n  if (adtsSamplingIndex > 12) {\n    const error = new Error(`invalid ADTS sampling index:${adtsSamplingIndex}`);\n    observer.emit(Events.ERROR, Events.ERROR, {\n      type: ErrorTypes.MEDIA_ERROR,\n      details: ErrorDetails.FRAG_PARSING_ERROR,\n      fatal: true,\n      error,\n      reason: error.message\n    });\n    return;\n  }\n  // MPEG-4 Audio Object Type (profile_ObjectType+1)\n  const adtsObjectType = (byte2 >> 6 & 0x3) + 1;\n  const channelCount = data[offset + 3] >> 6 & 0x3 | (byte2 & 1) << 2;\n  const codec = 'mp4a.40.' + adtsObjectType;\n  /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config\n      ISO/IEC 14496-3 - Table 1.13 — Syntax of AudioSpecificConfig()\n    Audio Profile / Audio Object Type\n    0: Null\n    1: AAC Main\n    2: AAC LC (Low Complexity)\n    3: AAC SSR (Scalable Sample Rate)\n    4: AAC LTP (Long Term Prediction)\n    5: SBR (Spectral Band Replication)\n    6: AAC Scalable\n   sampling freq\n    0: 96000 Hz\n    1: 88200 Hz\n    2: 64000 Hz\n    3: 48000 Hz\n    4: 44100 Hz\n    5: 32000 Hz\n    6: 24000 Hz\n    7: 22050 Hz\n    8: 16000 Hz\n    9: 12000 Hz\n    10: 11025 Hz\n    11: 8000 Hz\n    12: 7350 Hz\n    13: Reserved\n    14: Reserved\n    15: frequency is written explictly\n    Channel Configurations\n    These are the channel configurations:\n    0: Defined in AOT Specifc Config\n    1: 1 channel: front-center\n    2: 2 channels: front-left, front-right\n  */\n  // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1\n  const samplerate = adtsSamplingRates[adtsSamplingIndex];\n  let aacSampleIndex = adtsSamplingIndex;\n  if (adtsObjectType === 5 || adtsObjectType === 29) {\n    // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\n    // there is a factor 2 between frame sample rate and output sample rate\n    // multiply frequency by 2 (see table above, equivalent to substract 3)\n    aacSampleIndex -= 3;\n  }\n  const config = [adtsObjectType << 3 | (aacSampleIndex & 0x0e) >> 1, (aacSampleIndex & 0x01) << 7 | channelCount << 3];\n  logger.log(`manifest codec:${manifestCodec}, parsed codec:${codec}, channels:${channelCount}, rate:${samplerate} (ADTS object type:${adtsObjectType} sampling index:${adtsSamplingIndex})`);\n  return {\n    config,\n    samplerate,\n    channelCount,\n    codec,\n    parsedCodec: codec,\n    manifestCodec\n  };\n}\nfunction isHeaderPattern$1(data, offset) {\n  return data[offset] === 0xff && (data[offset + 1] & 0xf6) === 0xf0;\n}\nfunction getHeaderLength(data, offset) {\n  return data[offset + 1] & 0x01 ? 7 : 9;\n}\nfunction getFullFrameLength(data, offset) {\n  return (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xe0) >>> 5;\n}\nfunction canGetFrameLength(data, offset) {\n  return offset + 5 < data.length;\n}\nfunction isHeader$1(data, offset) {\n  // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1\n  // Layer bits (position 14 and 15) in header should be always 0 for ADTS\n  // More info https://wiki.multimedia.cx/index.php?title=ADTS\n  return offset + 1 < data.length && isHeaderPattern$1(data, offset);\n}\nfunction canParse$1(data, offset) {\n  return canGetFrameLength(data, offset) && isHeaderPattern$1(data, offset) && getFullFrameLength(data, offset) <= data.length - offset;\n}\nfunction probe$1(data, offset) {\n  // same as isHeader but we also check that ADTS frame follows last ADTS frame\n  // or end of data is reached\n  if (isHeader$1(data, offset)) {\n    // ADTS header Length\n    const headerLength = getHeaderLength(data, offset);\n    if (offset + headerLength >= data.length) {\n      return false;\n    }\n    // ADTS frame Length\n    const frameLength = getFullFrameLength(data, offset);\n    if (frameLength <= headerLength) {\n      return false;\n    }\n    const newOffset = offset + frameLength;\n    return newOffset === data.length || isHeader$1(data, newOffset);\n  }\n  return false;\n}\nfunction initTrackConfig(track, observer, data, offset, audioCodec) {\n  if (!track.samplerate) {\n    const config = getAudioConfig(observer, data, offset, audioCodec);\n    if (!config) {\n      return;\n    }\n    _extends(track, config);\n  }\n}\nfunction getFrameDuration(samplerate) {\n  return 1024 * 90000 / samplerate;\n}\nfunction parseFrameHeader(data, offset) {\n  // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header\n  const headerLength = getHeaderLength(data, offset);\n  if (offset + headerLength <= data.length) {\n    // retrieve frame size\n    const frameLength = getFullFrameLength(data, offset) - headerLength;\n    if (frameLength > 0) {\n      // logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}`);\n      return {\n        headerLength,\n        frameLength\n      };\n    }\n  }\n}\nfunction appendFrame$2(track, data, offset, pts, frameIndex) {\n  const frameDuration = getFrameDuration(track.samplerate);\n  const stamp = pts + frameIndex * frameDuration;\n  const header = parseFrameHeader(data, offset);\n  let unit;\n  if (header) {\n    const {\n      frameLength,\n      headerLength\n    } = header;\n    const _length = headerLength + frameLength;\n    const missing = Math.max(0, offset + _length - data.length);\n    // logger.log(`AAC frame ${frameIndex}, pts:${stamp} length@offset/total: ${frameLength}@${offset+headerLength}/${data.byteLength} missing: ${missing}`);\n    if (missing) {\n      unit = new Uint8Array(_length - headerLength);\n      unit.set(data.subarray(offset + headerLength, data.length), 0);\n    } else {\n      unit = data.subarray(offset + headerLength, offset + _length);\n    }\n    const _sample = {\n      unit,\n      pts: stamp\n    };\n    if (!missing) {\n      track.samples.push(_sample);\n    }\n    return {\n      sample: _sample,\n      length: _length,\n      missing\n    };\n  }\n  // overflow incomplete header\n  const length = data.length - offset;\n  unit = new Uint8Array(length);\n  unit.set(data.subarray(offset, data.length), 0);\n  const sample = {\n    unit,\n    pts: stamp\n  };\n  return {\n    sample,\n    length,\n    missing: -1\n  };\n}\n\n/**\n * Checks if the given data contains an ID3 tag.\n *\n * @param data - The data to check\n * @param offset - The offset at which to start checking\n *\n * @returns `true` if an ID3 tag is found\n *\n * @group ID3\n *\n * @beta\n */\nfunction canParseId3(data, offset) {\n  return isId3Header(data, offset) && readId3Size(data, offset + 6) + 10 <= data.length - offset;\n}\n\nfunction toArrayBuffer(view) {\n  if (view instanceof ArrayBuffer) {\n    return view;\n  } else {\n    if (view.byteOffset == 0 && view.byteLength == view.buffer.byteLength) {\n      // This is a TypedArray over the whole buffer.\n      return view.buffer;\n    }\n    // This is a 'view' on the buffer.  Create a new buffer that only contains\n    // the data.  Note that since this isn't an ArrayBuffer, the 'new' call\n    // will allocate a new buffer to hold the copy.\n    return new Uint8Array(view).buffer;\n  }\n}\n\nfunction toUint8(data, offset = 0, length = Infinity) {\n  return view(data, offset, length, Uint8Array);\n}\nfunction view(data, offset, length, Type) {\n  const buffer = unsafeGetArrayBuffer(data);\n  let bytesPerElement = 1;\n  if ('BYTES_PER_ELEMENT' in Type) {\n    bytesPerElement = Type.BYTES_PER_ELEMENT;\n  }\n  // Absolute end of the |data| view within |buffer|.\n  const dataOffset = isArrayBufferView(data) ? data.byteOffset : 0;\n  const dataEnd = (dataOffset + data.byteLength) / bytesPerElement;\n  // Absolute start of the result within |buffer|.\n  const rawStart = (dataOffset + offset) / bytesPerElement;\n  const start = Math.floor(Math.max(0, Math.min(rawStart, dataEnd)));\n  // Absolute end of the result within |buffer|.\n  const end = Math.floor(Math.min(start + Math.max(length, 0), dataEnd));\n  return new Type(buffer, start, end - start);\n}\nfunction unsafeGetArrayBuffer(view) {\n  if (view instanceof ArrayBuffer) {\n    return view;\n  } else {\n    return view.buffer;\n  }\n}\nfunction isArrayBufferView(obj) {\n  return obj && obj.buffer instanceof ArrayBuffer && obj.byteLength !== undefined && obj.byteOffset !== undefined;\n}\n\nfunction decodeId3ImageFrame(frame) {\n  const metadataFrame = {\n    key: frame.type,\n    description: '',\n    data: '',\n    mimeType: null,\n    pictureType: null\n  };\n  const utf8Encoding = 0x03;\n  if (frame.size < 2) {\n    return undefined;\n  }\n  if (frame.data[0] !== utf8Encoding) {\n    console.log('Ignore frame with unrecognized character ' + 'encoding');\n    return undefined;\n  }\n  const mimeTypeEndIndex = frame.data.subarray(1).indexOf(0);\n  if (mimeTypeEndIndex === -1) {\n    return undefined;\n  }\n  const mimeType = utf8ArrayToStr(toUint8(frame.data, 1, mimeTypeEndIndex));\n  const pictureType = frame.data[2 + mimeTypeEndIndex];\n  const descriptionEndIndex = frame.data.subarray(3 + mimeTypeEndIndex).indexOf(0);\n  if (descriptionEndIndex === -1) {\n    return undefined;\n  }\n  const description = utf8ArrayToStr(toUint8(frame.data, 3 + mimeTypeEndIndex, descriptionEndIndex));\n  let data;\n  if (mimeType === '-->') {\n    data = utf8ArrayToStr(toUint8(frame.data, 4 + mimeTypeEndIndex + descriptionEndIndex));\n  } else {\n    data = toArrayBuffer(frame.data.subarray(4 + mimeTypeEndIndex + descriptionEndIndex));\n  }\n  metadataFrame.mimeType = mimeType;\n  metadataFrame.pictureType = pictureType;\n  metadataFrame.description = description;\n  metadataFrame.data = data;\n  return metadataFrame;\n}\n\n/**\n * Decode an ID3 PRIV frame.\n *\n * @param frame - the ID3 PRIV frame\n *\n * @returns The decoded ID3 PRIV frame\n *\n * @internal\n *\n * @group ID3\n */\nfunction decodeId3PrivFrame(frame) {\n  /*\n  Format: <text string>\\0<binary data>\n  */\n  if (frame.size < 2) {\n    return undefined;\n  }\n  const owner = utf8ArrayToStr(frame.data, true);\n  const privateData = new Uint8Array(frame.data.subarray(owner.length + 1));\n  return {\n    key: frame.type,\n    info: owner,\n    data: privateData.buffer\n  };\n}\n\n/**\n * Decodes an ID3 text frame\n *\n * @param frame - the ID3 text frame\n *\n * @returns The decoded ID3 text frame\n *\n * @internal\n *\n * @group ID3\n */\nfunction decodeId3TextFrame(frame) {\n  if (frame.size < 2) {\n    return undefined;\n  }\n  if (frame.type === 'TXXX') {\n    /*\n    Format:\n    [0]   = {Text Encoding}\n    [1-?] = {Description}\\0{Value}\n    */\n    let index = 1;\n    const description = utf8ArrayToStr(frame.data.subarray(index), true);\n    index += description.length + 1;\n    const value = utf8ArrayToStr(frame.data.subarray(index));\n    return {\n      key: frame.type,\n      info: description,\n      data: value\n    };\n  }\n  /*\n  Format:\n  [0]   = {Text Encoding}\n  [1-?] = {Value}\n  */\n  const text = utf8ArrayToStr(frame.data.subarray(1));\n  return {\n    key: frame.type,\n    info: '',\n    data: text\n  };\n}\n\n/**\n * Decode a URL frame\n *\n * @param frame - the ID3 URL frame\n *\n * @returns The decoded ID3 URL frame\n *\n * @internal\n *\n * @group ID3\n */\nfunction decodeId3UrlFrame(frame) {\n  if (frame.type === 'WXXX') {\n    /*\n    Format:\n    [0]   = {Text Encoding}\n    [1-?] = {Description}\\0{URL}\n    */\n    if (frame.size < 2) {\n      return undefined;\n    }\n    let index = 1;\n    const description = utf8ArrayToStr(frame.data.subarray(index), true);\n    index += description.length + 1;\n    const value = utf8ArrayToStr(frame.data.subarray(index));\n    return {\n      key: frame.type,\n      info: description,\n      data: value\n    };\n  }\n  /*\n  Format:\n  [0-?] = {URL}\n  */\n  const url = utf8ArrayToStr(frame.data);\n  return {\n    key: frame.type,\n    info: '',\n    data: url\n  };\n}\n\n/**\n * Decode an ID3 frame.\n *\n * @param frame - the ID3 frame\n *\n * @returns The decoded ID3 frame\n *\n * @internal\n *\n * @group ID3\n */\nfunction decodeId3Frame(frame) {\n  if (frame.type === 'PRIV') {\n    return decodeId3PrivFrame(frame);\n  } else if (frame.type[0] === 'W') {\n    return decodeId3UrlFrame(frame);\n  } else if (frame.type === 'APIC') {\n    return decodeId3ImageFrame(frame);\n  }\n  return decodeId3TextFrame(frame);\n}\n\n/**\n * Returns the data of an ID3 frame.\n *\n * @param data - The data to read from\n *\n * @returns The data of the ID3 frame\n *\n * @internal\n *\n * @group ID3\n */\nfunction getId3FrameData(data) {\n  /*\n  Frame ID       $xx xx xx xx (four characters)\n  Size           $xx xx xx xx\n  Flags          $xx xx\n  */\n  const type = String.fromCharCode(data[0], data[1], data[2], data[3]);\n  const size = readId3Size(data, 4);\n  // skip frame id, size, and flags\n  const offset = 10;\n  return {\n    type,\n    size,\n    data: data.subarray(offset, offset + size)\n  };\n}\n\nconst HEADER_FOOTER_SIZE = 10;\nconst FRAME_SIZE = 10;\n/**\n * Returns an array of ID3 frames found in all the ID3 tags in the id3Data\n *\n * @param id3Data - The ID3 data containing one or more ID3 tags\n *\n * @returns Array of ID3 frame objects\n *\n * @group ID3\n *\n * @beta\n */\nfunction getId3Frames(id3Data) {\n  let offset = 0;\n  const frames = [];\n  while (isId3Header(id3Data, offset)) {\n    const size = readId3Size(id3Data, offset + 6);\n    if (id3Data[offset + 5] >> 6 & 1) {\n      // skip extended header\n      offset += HEADER_FOOTER_SIZE;\n    }\n    // skip past ID3 header\n    offset += HEADER_FOOTER_SIZE;\n    const end = offset + size;\n    // loop through frames in the ID3 tag\n    while (offset + FRAME_SIZE < end) {\n      const frameData = getId3FrameData(id3Data.subarray(offset));\n      const frame = decodeId3Frame(frameData);\n      if (frame) {\n        frames.push(frame);\n      }\n      // skip frame header and frame data\n      offset += frameData.size + HEADER_FOOTER_SIZE;\n    }\n    if (isId3Footer(id3Data, offset)) {\n      offset += HEADER_FOOTER_SIZE;\n    }\n  }\n  return frames;\n}\n\n/**\n * Returns true if the ID3 frame is an Elementary Stream timestamp frame\n *\n * @param frame - the ID3 frame\n *\n * @returns `true` if the ID3 frame is an Elementary Stream timestamp frame\n *\n * @internal\n *\n * @group ID3\n */\nfunction isId3TimestampFrame(frame) {\n  return frame && frame.key === 'PRIV' && frame.info === 'com.apple.streaming.transportStreamTimestamp';\n}\n\n/**\n * Read a 33 bit timestamp from an ID3 frame.\n *\n * @param timeStampFrame - the ID3 frame\n *\n * @returns The timestamp\n *\n * @internal\n *\n * @group ID3\n */\nfunction readId3Timestamp(timeStampFrame) {\n  if (timeStampFrame.data.byteLength === 8) {\n    const data = new Uint8Array(timeStampFrame.data);\n    // timestamp is 33 bit expressed as a big-endian eight-octet number,\n    // with the upper 31 bits set to zero.\n    const pts33Bit = data[3] & 0x1;\n    let timestamp = (data[4] << 23) + (data[5] << 15) + (data[6] << 7) + data[7];\n    timestamp /= 45;\n    if (pts33Bit) {\n      timestamp += 47721858.84;\n    } // 2^32 / 90\n    return Math.round(timestamp);\n  }\n  return undefined;\n}\n\n/**\n * Searches for the Elementary Stream timestamp found in the ID3 data chunk\n *\n * @param data - Block of data containing one or more ID3 tags\n *\n * @returns The timestamp\n *\n * @group ID3\n *\n * @beta\n */\nfunction getId3Timestamp(data) {\n  const frames = getId3Frames(data);\n  for (let i = 0; i < frames.length; i++) {\n    const frame = frames[i];\n    if (isId3TimestampFrame(frame)) {\n      return readId3Timestamp(frame);\n    }\n  }\n  return undefined;\n}\n\nlet MetadataSchema = /*#__PURE__*/function (MetadataSchema) {\n  MetadataSchema[\"audioId3\"] = \"org.id3\";\n  MetadataSchema[\"dateRange\"] = \"com.apple.quicktime.HLS\";\n  MetadataSchema[\"emsg\"] = \"https://aomedia.org/emsg/ID3\";\n  MetadataSchema[\"misbklv\"] = \"urn:misb:KLV:bin:1910.1\";\n  return MetadataSchema;\n}({});\n\nfunction dummyTrack(type = '', inputTimeScale = 90000) {\n  return {\n    type,\n    id: -1,\n    pid: -1,\n    inputTimeScale,\n    sequenceNumber: -1,\n    samples: [],\n    dropped: 0\n  };\n}\n\nclass BaseAudioDemuxer {\n  constructor() {\n    this._audioTrack = void 0;\n    this._id3Track = void 0;\n    this.frameIndex = 0;\n    this.cachedData = null;\n    this.basePTS = null;\n    this.initPTS = null;\n    this.lastPTS = null;\n  }\n  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    this._id3Track = {\n      type: 'id3',\n      id: 3,\n      pid: -1,\n      inputTimeScale: 90000,\n      sequenceNumber: 0,\n      samples: [],\n      dropped: 0\n    };\n  }\n  resetTimeStamp(deaultTimestamp) {\n    this.initPTS = deaultTimestamp;\n    this.resetContiguity();\n  }\n  resetContiguity() {\n    this.basePTS = null;\n    this.lastPTS = null;\n    this.frameIndex = 0;\n  }\n  canParse(data, offset) {\n    return false;\n  }\n  appendFrame(track, data, offset) {}\n\n  // feed incoming data to the front of the parsing pipeline\n  demux(data, timeOffset) {\n    if (this.cachedData) {\n      data = appendUint8Array(this.cachedData, data);\n      this.cachedData = null;\n    }\n    let id3Data = getId3Data(data, 0);\n    let offset = id3Data ? id3Data.length : 0;\n    let lastDataIndex;\n    const track = this._audioTrack;\n    const id3Track = this._id3Track;\n    const timestamp = id3Data ? getId3Timestamp(id3Data) : undefined;\n    const length = data.length;\n    if (this.basePTS === null || this.frameIndex === 0 && isFiniteNumber(timestamp)) {\n      this.basePTS = initPTSFn(timestamp, timeOffset, this.initPTS);\n      this.lastPTS = this.basePTS;\n    }\n    if (this.lastPTS === null) {\n      this.lastPTS = this.basePTS;\n    }\n\n    // more expressive than alternative: id3Data?.length\n    if (id3Data && id3Data.length > 0) {\n      id3Track.samples.push({\n        pts: this.lastPTS,\n        dts: this.lastPTS,\n        data: id3Data,\n        type: MetadataSchema.audioId3,\n        duration: Number.POSITIVE_INFINITY\n      });\n    }\n    while (offset < length) {\n      if (this.canParse(data, offset)) {\n        const frame = this.appendFrame(track, data, offset);\n        if (frame) {\n          this.frameIndex++;\n          this.lastPTS = frame.sample.pts;\n          offset += frame.length;\n          lastDataIndex = offset;\n        } else {\n          offset = length;\n        }\n      } else if (canParseId3(data, offset)) {\n        // after a canParse, a call to getId3Data *should* always returns some data\n        id3Data = getId3Data(data, offset);\n        id3Track.samples.push({\n          pts: this.lastPTS,\n          dts: this.lastPTS,\n          data: id3Data,\n          type: MetadataSchema.audioId3,\n          duration: Number.POSITIVE_INFINITY\n        });\n        offset += id3Data.length;\n        lastDataIndex = offset;\n      } else {\n        offset++;\n      }\n      if (offset === length && lastDataIndex !== length) {\n        const partialData = data.slice(lastDataIndex);\n        if (this.cachedData) {\n          this.cachedData = appendUint8Array(this.cachedData, partialData);\n        } else {\n          this.cachedData = partialData;\n        }\n      }\n    }\n    return {\n      audioTrack: track,\n      videoTrack: dummyTrack(),\n      id3Track,\n      textTrack: dummyTrack()\n    };\n  }\n  demuxSampleAes(data, keyData, timeOffset) {\n    return Promise.reject(new Error(`[${this}] This demuxer does not support Sample-AES decryption`));\n  }\n  flush(timeOffset) {\n    // Parse cache in case of remaining frames.\n    const cachedData = this.cachedData;\n    if (cachedData) {\n      this.cachedData = null;\n      this.demux(cachedData, 0);\n    }\n    return {\n      audioTrack: this._audioTrack,\n      videoTrack: dummyTrack(),\n      id3Track: this._id3Track,\n      textTrack: dummyTrack()\n    };\n  }\n  destroy() {\n    this.cachedData = null;\n    // @ts-ignore\n    this._audioTrack = this._id3Track = undefined;\n  }\n}\n\n/**\n * Initialize PTS\n * <p>\n *    use timestamp unless it is undefined, NaN or Infinity\n * </p>\n */\nconst initPTSFn = (timestamp, timeOffset, initPTS) => {\n  if (isFiniteNumber(timestamp)) {\n    return timestamp * 90;\n  }\n  const init90kHz = initPTS ? initPTS.baseTime * 90000 / initPTS.timescale : 0;\n  return timeOffset * 90000 + init90kHz;\n};\n\n/**\n *  MPEG parser helper\n */\n\nlet chromeVersion$1 = null;\nconst BitratesMap = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160];\nconst SamplingRateMap = [44100, 48000, 32000, 22050, 24000, 16000, 11025, 12000, 8000];\nconst SamplesCoefficients = [\n// MPEG 2.5\n[0,\n// Reserved\n72,\n// Layer3\n144,\n// Layer2\n12 // Layer1\n],\n// Reserved\n[0,\n// Reserved\n0,\n// Layer3\n0,\n// Layer2\n0 // Layer1\n],\n// MPEG 2\n[0,\n// Reserved\n72,\n// Layer3\n144,\n// Layer2\n12 // Layer1\n],\n// MPEG 1\n[0,\n// Reserved\n144,\n// Layer3\n144,\n// Layer2\n12 // Layer1\n]];\nconst BytesInSlot = [0,\n// Reserved\n1,\n// Layer3\n1,\n// Layer2\n4 // Layer1\n];\nfunction appendFrame$1(track, data, offset, pts, frameIndex) {\n  // Using http://www.datavoyage.com/mpgscript/mpeghdr.htm as a reference\n  if (offset + 24 > data.length) {\n    return;\n  }\n  const header = parseHeader(data, offset);\n  if (header && offset + header.frameLength <= data.length) {\n    const frameDuration = header.samplesPerFrame * 90000 / header.sampleRate;\n    const stamp = pts + frameIndex * frameDuration;\n    const sample = {\n      unit: data.subarray(offset, offset + header.frameLength),\n      pts: stamp,\n      dts: stamp\n    };\n    track.config = [];\n    track.channelCount = header.channelCount;\n    track.samplerate = header.sampleRate;\n    track.samples.push(sample);\n    return {\n      sample,\n      length: header.frameLength,\n      missing: 0\n    };\n  }\n}\nfunction parseHeader(data, offset) {\n  const mpegVersion = data[offset + 1] >> 3 & 3;\n  const mpegLayer = data[offset + 1] >> 1 & 3;\n  const bitRateIndex = data[offset + 2] >> 4 & 15;\n  const sampleRateIndex = data[offset + 2] >> 2 & 3;\n  if (mpegVersion !== 1 && bitRateIndex !== 0 && bitRateIndex !== 15 && sampleRateIndex !== 3) {\n    const paddingBit = data[offset + 2] >> 1 & 1;\n    const channelMode = data[offset + 3] >> 6;\n    const columnInBitrates = mpegVersion === 3 ? 3 - mpegLayer : mpegLayer === 3 ? 3 : 4;\n    const bitRate = BitratesMap[columnInBitrates * 14 + bitRateIndex - 1] * 1000;\n    const columnInSampleRates = mpegVersion === 3 ? 0 : mpegVersion === 2 ? 1 : 2;\n    const sampleRate = SamplingRateMap[columnInSampleRates * 3 + sampleRateIndex];\n    const channelCount = channelMode === 3 ? 1 : 2; // If bits of channel mode are `11` then it is a single channel (Mono)\n    const sampleCoefficient = SamplesCoefficients[mpegVersion][mpegLayer];\n    const bytesInSlot = BytesInSlot[mpegLayer];\n    const samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;\n    const frameLength = Math.floor(sampleCoefficient * bitRate / sampleRate + paddingBit) * bytesInSlot;\n    if (chromeVersion$1 === null) {\n      const userAgent = navigator.userAgent || '';\n      const result = userAgent.match(/Chrome\\/(\\d+)/i);\n      chromeVersion$1 = result ? parseInt(result[1]) : 0;\n    }\n    const needChromeFix = !!chromeVersion$1 && chromeVersion$1 <= 87;\n    if (needChromeFix && mpegLayer === 2 && bitRate >= 224000 && channelMode === 0) {\n      // Work around bug in Chromium by setting channelMode to dual-channel (01) instead of stereo (00)\n      data[offset + 3] = data[offset + 3] | 0x80;\n    }\n    return {\n      sampleRate,\n      channelCount,\n      frameLength,\n      samplesPerFrame\n    };\n  }\n}\nfunction isHeaderPattern(data, offset) {\n  return data[offset] === 0xff && (data[offset + 1] & 0xe0) === 0xe0 && (data[offset + 1] & 0x06) !== 0x00;\n}\nfunction isHeader(data, offset) {\n  // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1\n  // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)\n  // More info http://www.mp3-tech.org/programmer/frame_header.html\n  return offset + 1 < data.length && isHeaderPattern(data, offset);\n}\nfunction canParse(data, offset) {\n  const headerSize = 4;\n  return isHeaderPattern(data, offset) && headerSize <= data.length - offset;\n}\nfunction probe(data, offset) {\n  // same as isHeader but we also check that MPEG frame follows last MPEG frame\n  // or end of data is reached\n  if (offset + 1 < data.length && isHeaderPattern(data, offset)) {\n    // MPEG header Length\n    const headerLength = 4;\n    // MPEG frame Length\n    const header = parseHeader(data, offset);\n    let frameLength = headerLength;\n    if (header != null && header.frameLength) {\n      frameLength = header.frameLength;\n    }\n    const newOffset = offset + frameLength;\n    return newOffset === data.length || isHeader(data, newOffset);\n  }\n  return false;\n}\n\n/**\n * AAC demuxer\n */\nclass AACDemuxer extends BaseAudioDemuxer {\n  constructor(observer, config) {\n    super();\n    this.observer = void 0;\n    this.config = void 0;\n    this.observer = observer;\n    this.config = config;\n  }\n  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);\n    this._audioTrack = {\n      container: 'audio/adts',\n      type: 'audio',\n      id: 2,\n      pid: -1,\n      sequenceNumber: 0,\n      segmentCodec: 'aac',\n      samples: [],\n      manifestCodec: audioCodec,\n      duration: trackDuration,\n      inputTimeScale: 90000,\n      dropped: 0\n    };\n  }\n\n  // Source for probe info - https://wiki.multimedia.cx/index.php?title=ADTS\n  static probe(data, logger) {\n    if (!data) {\n      return false;\n    }\n\n    // Check for the ADTS sync word\n    // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1\n    // Layer bits (position 14 and 15) in header should be always 0 for ADTS\n    // More info https://wiki.multimedia.cx/index.php?title=ADTS\n    const id3Data = getId3Data(data, 0);\n    let offset = (id3Data == null ? void 0 : id3Data.length) || 0;\n    if (probe(data, offset)) {\n      return false;\n    }\n    for (let length = data.length; offset < length; offset++) {\n      if (probe$1(data, offset)) {\n        logger.log('ADTS sync word found !');\n        return true;\n      }\n    }\n    return false;\n  }\n  canParse(data, offset) {\n    return canParse$1(data, offset);\n  }\n  appendFrame(track, data, offset) {\n    initTrackConfig(track, this.observer, data, offset, track.manifestCodec);\n    const frame = appendFrame$2(track, data, offset, this.basePTS, this.frameIndex);\n    if (frame && frame.missing === 0) {\n      return frame;\n    }\n  }\n}\n\nconst getAudioBSID = (data, offset) => {\n  // check the bsid to confirm ac-3 | ec-3\n  let bsid = 0;\n  let numBits = 5;\n  offset += numBits;\n  const temp = new Uint32Array(1); // unsigned 32 bit for temporary storage\n  const mask = new Uint32Array(1); // unsigned 32 bit mask value\n  const byte = new Uint8Array(1); // unsigned 8 bit for temporary storage\n  while (numBits > 0) {\n    byte[0] = data[offset];\n    // read remaining bits, upto 8 bits at a time\n    const bits = Math.min(numBits, 8);\n    const shift = 8 - bits;\n    mask[0] = 0xff000000 >>> 24 + shift << shift;\n    temp[0] = (byte[0] & mask[0]) >> shift;\n    bsid = !bsid ? temp[0] : bsid << bits | temp[0];\n    offset += 1;\n    numBits -= bits;\n  }\n  return bsid;\n};\n\nclass AC3Demuxer extends BaseAudioDemuxer {\n  constructor(observer) {\n    super();\n    this.observer = void 0;\n    this.observer = observer;\n  }\n  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);\n    this._audioTrack = {\n      container: 'audio/ac-3',\n      type: 'audio',\n      id: 2,\n      pid: -1,\n      sequenceNumber: 0,\n      segmentCodec: 'ac3',\n      samples: [],\n      manifestCodec: audioCodec,\n      duration: trackDuration,\n      inputTimeScale: 90000,\n      dropped: 0\n    };\n  }\n  canParse(data, offset) {\n    return offset + 64 < data.length;\n  }\n  appendFrame(track, data, offset) {\n    const frameLength = appendFrame(track, data, offset, this.basePTS, this.frameIndex);\n    if (frameLength !== -1) {\n      const sample = track.samples[track.samples.length - 1];\n      return {\n        sample,\n        length: frameLength,\n        missing: 0\n      };\n    }\n  }\n  static probe(data) {\n    if (!data) {\n      return false;\n    }\n    const id3Data = getId3Data(data, 0);\n    if (!id3Data) {\n      return false;\n    }\n\n    // look for the ac-3 sync bytes\n    const offset = id3Data.length;\n    if (data[offset] === 0x0b && data[offset + 1] === 0x77 && getId3Timestamp(id3Data) !== undefined &&\n    // check the bsid to confirm ac-3\n    getAudioBSID(data, offset) < 16) {\n      return true;\n    }\n    return false;\n  }\n}\nfunction appendFrame(track, data, start, pts, frameIndex) {\n  if (start + 8 > data.length) {\n    return -1; // not enough bytes left\n  }\n  if (data[start] !== 0x0b || data[start + 1] !== 0x77) {\n    return -1; // invalid magic\n  }\n\n  // get sample rate\n  const samplingRateCode = data[start + 4] >> 6;\n  if (samplingRateCode >= 3) {\n    return -1; // invalid sampling rate\n  }\n  const samplingRateMap = [48000, 44100, 32000];\n  const sampleRate = samplingRateMap[samplingRateCode];\n\n  // get frame size\n  const frameSizeCode = data[start + 4] & 0x3f;\n  const frameSizeMap = [64, 69, 96, 64, 70, 96, 80, 87, 120, 80, 88, 120, 96, 104, 144, 96, 105, 144, 112, 121, 168, 112, 122, 168, 128, 139, 192, 128, 140, 192, 160, 174, 240, 160, 175, 240, 192, 208, 288, 192, 209, 288, 224, 243, 336, 224, 244, 336, 256, 278, 384, 256, 279, 384, 320, 348, 480, 320, 349, 480, 384, 417, 576, 384, 418, 576, 448, 487, 672, 448, 488, 672, 512, 557, 768, 512, 558, 768, 640, 696, 960, 640, 697, 960, 768, 835, 1152, 768, 836, 1152, 896, 975, 1344, 896, 976, 1344, 1024, 1114, 1536, 1024, 1115, 1536, 1152, 1253, 1728, 1152, 1254, 1728, 1280, 1393, 1920, 1280, 1394, 1920];\n  const frameLength = frameSizeMap[frameSizeCode * 3 + samplingRateCode] * 2;\n  if (start + frameLength > data.length) {\n    return -1;\n  }\n\n  // get channel count\n  const channelMode = data[start + 6] >> 5;\n  let skipCount = 0;\n  if (channelMode === 2) {\n    skipCount += 2;\n  } else {\n    if (channelMode & 1 && channelMode !== 1) {\n      skipCount += 2;\n    }\n    if (channelMode & 4) {\n      skipCount += 2;\n    }\n  }\n  const lfeon = (data[start + 6] << 8 | data[start + 7]) >> 12 - skipCount & 1;\n  const channelsMap = [2, 1, 2, 3, 3, 4, 4, 5];\n  const channelCount = channelsMap[channelMode] + lfeon;\n\n  // build dac3 box\n  const bsid = data[start + 5] >> 3;\n  const bsmod = data[start + 5] & 7;\n  const config = new Uint8Array([samplingRateCode << 6 | bsid << 1 | bsmod >> 2, (bsmod & 3) << 6 | channelMode << 3 | lfeon << 2 | frameSizeCode >> 4, frameSizeCode << 4 & 0xe0]);\n  const frameDuration = 1536 / sampleRate * 90000;\n  const stamp = pts + frameIndex * frameDuration;\n  const unit = data.subarray(start, start + frameLength);\n  track.config = config;\n  track.channelCount = channelCount;\n  track.samplerate = sampleRate;\n  track.samples.push({\n    unit,\n    pts: stamp\n  });\n  return frameLength;\n}\n\n/**\n * MP3 demuxer\n */\nclass MP3Demuxer extends BaseAudioDemuxer {\n  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);\n    this._audioTrack = {\n      container: 'audio/mpeg',\n      type: 'audio',\n      id: 2,\n      pid: -1,\n      sequenceNumber: 0,\n      segmentCodec: 'mp3',\n      samples: [],\n      manifestCodec: audioCodec,\n      duration: trackDuration,\n      inputTimeScale: 90000,\n      dropped: 0\n    };\n  }\n  static probe(data) {\n    if (!data) {\n      return false;\n    }\n\n    // check if data contains ID3 timestamp and MPEG sync word\n    // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1\n    // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)\n    // More info http://www.mp3-tech.org/programmer/frame_header.html\n    const id3Data = getId3Data(data, 0);\n    let offset = (id3Data == null ? void 0 : id3Data.length) || 0;\n\n    // Check for ac-3|ec-3 sync bytes and return false if present\n    if (id3Data && data[offset] === 0x0b && data[offset + 1] === 0x77 && getId3Timestamp(id3Data) !== undefined &&\n    // check the bsid to confirm ac-3 or ec-3 (not mp3)\n    getAudioBSID(data, offset) <= 16) {\n      return false;\n    }\n    for (let length = data.length; offset < length; offset++) {\n      if (probe(data, offset)) {\n        logger.log('MPEG Audio sync word found !');\n        return true;\n      }\n    }\n    return false;\n  }\n  canParse(data, offset) {\n    return canParse(data, offset);\n  }\n  appendFrame(track, data, offset) {\n    if (this.basePTS === null) {\n      return;\n    }\n    return appendFrame$1(track, data, offset, this.basePTS, this.frameIndex);\n  }\n}\n\nconst emsgSchemePattern = /\\/emsg[-/]ID3/i;\nclass MP4Demuxer {\n  constructor(observer, config) {\n    this.remainderData = null;\n    this.timeOffset = 0;\n    this.config = void 0;\n    this.videoTrack = void 0;\n    this.audioTrack = void 0;\n    this.id3Track = void 0;\n    this.txtTrack = void 0;\n    this.config = config;\n  }\n  resetTimeStamp() {}\n  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    const videoTrack = this.videoTrack = dummyTrack('video', 1);\n    const audioTrack = this.audioTrack = dummyTrack('audio', 1);\n    const captionTrack = this.txtTrack = dummyTrack('text', 1);\n    this.id3Track = dummyTrack('id3', 1);\n    this.timeOffset = 0;\n    if (!(initSegment != null && initSegment.byteLength)) {\n      return;\n    }\n    const initData = parseInitSegment(initSegment);\n    if (initData.video) {\n      const {\n        id,\n        timescale,\n        codec,\n        supplemental\n      } = initData.video;\n      videoTrack.id = id;\n      videoTrack.timescale = captionTrack.timescale = timescale;\n      videoTrack.codec = codec;\n      videoTrack.supplemental = supplemental;\n    }\n    if (initData.audio) {\n      const {\n        id,\n        timescale,\n        codec\n      } = initData.audio;\n      audioTrack.id = id;\n      audioTrack.timescale = timescale;\n      audioTrack.codec = codec;\n    }\n    captionTrack.id = RemuxerTrackIdConfig.text;\n    videoTrack.sampleDuration = 0;\n    videoTrack.duration = audioTrack.duration = trackDuration;\n  }\n  resetContiguity() {\n    this.remainderData = null;\n  }\n  static probe(data) {\n    return hasMoofData(data);\n  }\n  demux(data, timeOffset) {\n    this.timeOffset = timeOffset;\n    // Load all data into the avc track. The CMAF remuxer will look for the data in the samples object; the rest of the fields do not matter\n    let videoSamples = data;\n    const videoTrack = this.videoTrack;\n    const textTrack = this.txtTrack;\n    if (this.config.progressive) {\n      // Split the bytestream into two ranges: one encompassing all data up until the start of the last moof, and everything else.\n      // This is done to guarantee that we're sending valid data to MSE - when demuxing progressively, we have no guarantee\n      // that the fetch loader gives us flush moof+mdat pairs. If we push jagged data to MSE, it will throw an exception.\n      if (this.remainderData) {\n        videoSamples = appendUint8Array(this.remainderData, data);\n      }\n      const segmentedData = segmentValidRange(videoSamples);\n      this.remainderData = segmentedData.remainder;\n      videoTrack.samples = segmentedData.valid || new Uint8Array();\n    } else {\n      videoTrack.samples = videoSamples;\n    }\n    const id3Track = this.extractID3Track(videoTrack, timeOffset);\n    textTrack.samples = parseSamples(timeOffset, videoTrack);\n    return {\n      videoTrack,\n      audioTrack: this.audioTrack,\n      id3Track,\n      textTrack: this.txtTrack\n    };\n  }\n  flush() {\n    const timeOffset = this.timeOffset;\n    const videoTrack = this.videoTrack;\n    const textTrack = this.txtTrack;\n    videoTrack.samples = this.remainderData || new Uint8Array();\n    this.remainderData = null;\n    const id3Track = this.extractID3Track(videoTrack, this.timeOffset);\n    textTrack.samples = parseSamples(timeOffset, videoTrack);\n    return {\n      videoTrack,\n      audioTrack: dummyTrack(),\n      id3Track,\n      textTrack: dummyTrack()\n    };\n  }\n  extractID3Track(videoTrack, timeOffset) {\n    const id3Track = this.id3Track;\n    if (videoTrack.samples.length) {\n      const emsgs = findBox(videoTrack.samples, ['emsg']);\n      if (emsgs) {\n        emsgs.forEach(data => {\n          const emsgInfo = parseEmsg(data);\n          if (emsgSchemePattern.test(emsgInfo.schemeIdUri)) {\n            const pts = getEmsgStartTime(emsgInfo, timeOffset);\n            let duration = emsgInfo.eventDuration === 0xffffffff ? Number.POSITIVE_INFINITY : emsgInfo.eventDuration / emsgInfo.timeScale;\n            // Safari takes anything <= 0.001 seconds and maps it to Infinity\n            if (duration <= 0.001) {\n              duration = Number.POSITIVE_INFINITY;\n            }\n            const payload = emsgInfo.payload;\n            id3Track.samples.push({\n              data: payload,\n              len: payload.byteLength,\n              dts: pts,\n              pts: pts,\n              type: MetadataSchema.emsg,\n              duration: duration\n            });\n          } else if (this.config.enableEmsgKLVMetadata && emsgInfo.schemeIdUri.startsWith('urn:misb:KLV:bin:1910.1')) {\n            const pts = getEmsgStartTime(emsgInfo, timeOffset);\n            id3Track.samples.push({\n              data: emsgInfo.payload,\n              len: emsgInfo.payload.byteLength,\n              dts: pts,\n              pts: pts,\n              type: MetadataSchema.misbklv,\n              duration: Number.POSITIVE_INFINITY\n            });\n          }\n        });\n      }\n    }\n    return id3Track;\n  }\n  demuxSampleAes(data, keyData, timeOffset) {\n    return Promise.reject(new Error('The MP4 demuxer does not support SAMPLE-AES decryption'));\n  }\n  destroy() {\n    // @ts-ignore\n    this.config = null;\n    this.remainderData = null;\n    this.videoTrack = this.audioTrack = this.id3Track = this.txtTrack = undefined;\n  }\n}\nfunction getEmsgStartTime(emsgInfo, timeOffset) {\n  return isFiniteNumber(emsgInfo.presentationTime) ? emsgInfo.presentationTime / emsgInfo.timeScale : timeOffset + emsgInfo.presentationTimeDelta / emsgInfo.timeScale;\n}\n\n/**\n * SAMPLE-AES decrypter\n */\n\nclass SampleAesDecrypter {\n  constructor(observer, config, keyData) {\n    this.keyData = void 0;\n    this.decrypter = void 0;\n    this.keyData = keyData;\n    this.decrypter = new Decrypter(config, {\n      removePKCS7Padding: false\n    });\n  }\n  decryptBuffer(encryptedData) {\n    return this.decrypter.decrypt(encryptedData, this.keyData.key.buffer, this.keyData.iv.buffer, DecrypterAesMode.cbc);\n  }\n\n  // AAC - encrypt all full 16 bytes blocks starting from offset 16\n  decryptAacSample(samples, sampleIndex, callback) {\n    const curUnit = samples[sampleIndex].unit;\n    if (curUnit.length <= 16) {\n      // No encrypted portion in this sample (first 16 bytes is not\n      // encrypted, see https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/HLS_Sample_Encryption/Encryption/Encryption.html),\n      return;\n    }\n    const encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);\n    const encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);\n    this.decryptBuffer(encryptedBuffer).then(decryptedBuffer => {\n      const decryptedData = new Uint8Array(decryptedBuffer);\n      curUnit.set(decryptedData, 16);\n      if (!this.decrypter.isSync()) {\n        this.decryptAacSamples(samples, sampleIndex + 1, callback);\n      }\n    });\n  }\n  decryptAacSamples(samples, sampleIndex, callback) {\n    for (;; sampleIndex++) {\n      if (sampleIndex >= samples.length) {\n        callback();\n        return;\n      }\n      if (samples[sampleIndex].unit.length < 32) {\n        continue;\n      }\n      this.decryptAacSample(samples, sampleIndex, callback);\n      if (!this.decrypter.isSync()) {\n        return;\n      }\n    }\n  }\n\n  // AVC - encrypt one 16 bytes block out of ten, starting from offset 32\n  getAvcEncryptedData(decodedData) {\n    const encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;\n    const encryptedData = new Int8Array(encryptedDataLen);\n    let outputPos = 0;\n    for (let inputPos = 32; inputPos < decodedData.length - 16; inputPos += 160, outputPos += 16) {\n      encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);\n    }\n    return encryptedData;\n  }\n  getAvcDecryptedUnit(decodedData, decryptedData) {\n    const uint8DecryptedData = new Uint8Array(decryptedData);\n    let inputPos = 0;\n    for (let outputPos = 32; outputPos < decodedData.length - 16; outputPos += 160, inputPos += 16) {\n      decodedData.set(uint8DecryptedData.subarray(inputPos, inputPos + 16), outputPos);\n    }\n    return decodedData;\n  }\n  decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit) {\n    const decodedData = discardEPB(curUnit.data);\n    const encryptedData = this.getAvcEncryptedData(decodedData);\n    this.decryptBuffer(encryptedData.buffer).then(decryptedBuffer => {\n      curUnit.data = this.getAvcDecryptedUnit(decodedData, decryptedBuffer);\n      if (!this.decrypter.isSync()) {\n        this.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);\n      }\n    });\n  }\n  decryptAvcSamples(samples, sampleIndex, unitIndex, callback) {\n    if (samples instanceof Uint8Array) {\n      throw new Error('Cannot decrypt samples of type Uint8Array');\n    }\n    for (;; sampleIndex++, unitIndex = 0) {\n      if (sampleIndex >= samples.length) {\n        callback();\n        return;\n      }\n      const curUnits = samples[sampleIndex].units;\n      for (;; unitIndex++) {\n        if (unitIndex >= curUnits.length) {\n          break;\n        }\n        const curUnit = curUnits[unitIndex];\n        if (curUnit.data.length <= 48 || curUnit.type !== 1 && curUnit.type !== 5) {\n          continue;\n        }\n        this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit);\n        if (!this.decrypter.isSync()) {\n          return;\n        }\n      }\n    }\n  }\n}\n\nclass BaseVideoParser {\n  constructor() {\n    this.VideoSample = null;\n  }\n  createVideoSample(key, pts, dts) {\n    return {\n      key,\n      frame: false,\n      pts,\n      dts,\n      units: [],\n      length: 0\n    };\n  }\n  getLastNalUnit(samples) {\n    var _VideoSample;\n    let VideoSample = this.VideoSample;\n    let lastUnit;\n    // try to fallback to previous sample if current one is empty\n    if (!VideoSample || VideoSample.units.length === 0) {\n      VideoSample = samples[samples.length - 1];\n    }\n    if ((_VideoSample = VideoSample) != null && _VideoSample.units) {\n      const units = VideoSample.units;\n      lastUnit = units[units.length - 1];\n    }\n    return lastUnit;\n  }\n  pushAccessUnit(VideoSample, videoTrack) {\n    if (VideoSample.units.length && VideoSample.frame) {\n      // if sample does not have PTS/DTS, patch with last sample PTS/DTS\n      if (VideoSample.pts === undefined) {\n        const samples = videoTrack.samples;\n        const nbSamples = samples.length;\n        if (nbSamples) {\n          const lastSample = samples[nbSamples - 1];\n          VideoSample.pts = lastSample.pts;\n          VideoSample.dts = lastSample.dts;\n        } else {\n          // dropping samples, no timestamp found\n          videoTrack.dropped++;\n          return;\n        }\n      }\n      videoTrack.samples.push(VideoSample);\n    }\n  }\n  parseNALu(track, array, endOfSegment) {\n    const len = array.byteLength;\n    let state = track.naluState || 0;\n    const lastState = state;\n    const units = [];\n    let i = 0;\n    let value;\n    let overflow;\n    let unitType;\n    let lastUnitStart = -1;\n    let lastUnitType = 0;\n    // logger.log('PES:' + Hex.hexDump(array));\n\n    if (state === -1) {\n      // special use case where we found 3 or 4-byte start codes exactly at the end of previous PES packet\n      lastUnitStart = 0;\n      // NALu type is value read from offset 0\n      lastUnitType = this.getNALuType(array, 0);\n      state = 0;\n      i = 1;\n    }\n    while (i < len) {\n      value = array[i++];\n      // optimization. state 0 and 1 are the predominant case. let's handle them outside of the switch/case\n      if (!state) {\n        state = value ? 0 : 1;\n        continue;\n      }\n      if (state === 1) {\n        state = value ? 0 : 2;\n        continue;\n      }\n      // here we have state either equal to 2 or 3\n      if (!value) {\n        state = 3;\n      } else if (value === 1) {\n        overflow = i - state - 1;\n        if (lastUnitStart >= 0) {\n          const unit = {\n            data: array.subarray(lastUnitStart, overflow),\n            type: lastUnitType\n          };\n          // logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);\n          units.push(unit);\n        } else {\n          // lastUnitStart is undefined => this is the first start code found in this PES packet\n          // first check if start code delimiter is overlapping between 2 PES packets,\n          // ie it started in last packet (lastState not zero)\n          // and ended at the beginning of this PES packet (i <= 4 - lastState)\n          const lastUnit = this.getLastNalUnit(track.samples);\n          if (lastUnit) {\n            if (lastState && i <= 4 - lastState) {\n              // start delimiter overlapping between PES packets\n              // strip start delimiter bytes from the end of last NAL unit\n              // check if lastUnit had a state different from zero\n              if (lastUnit.state) {\n                // strip last bytes\n                lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);\n              }\n            }\n            // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.\n\n            if (overflow > 0) {\n              // logger.log('first NALU found with overflow:' + overflow);\n              lastUnit.data = appendUint8Array(lastUnit.data, array.subarray(0, overflow));\n              lastUnit.state = 0;\n            }\n          }\n        }\n        // check if we can read unit type\n        if (i < len) {\n          unitType = this.getNALuType(array, i);\n          // logger.log('find NALU @ offset:' + i + ',type:' + unitType);\n          lastUnitStart = i;\n          lastUnitType = unitType;\n          state = 0;\n        } else {\n          // not enough byte to read unit type. let's read it on next PES parsing\n          state = -1;\n        }\n      } else {\n        state = 0;\n      }\n    }\n    if (lastUnitStart >= 0 && state >= 0) {\n      const unit = {\n        data: array.subarray(lastUnitStart, len),\n        type: lastUnitType,\n        state: state\n      };\n      units.push(unit);\n      // logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);\n    }\n    // no NALu found\n    if (units.length === 0) {\n      // append pes.data to previous NAL unit\n      const lastUnit = this.getLastNalUnit(track.samples);\n      if (lastUnit) {\n        lastUnit.data = appendUint8Array(lastUnit.data, array);\n      }\n    }\n    track.naluState = state;\n    return units;\n  }\n}\n\n/**\n * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.\n */\n\nclass ExpGolomb {\n  constructor(data) {\n    this.data = void 0;\n    this.bytesAvailable = void 0;\n    this.word = void 0;\n    this.bitsAvailable = void 0;\n    this.data = data;\n    // the number of bytes left to examine in this.data\n    this.bytesAvailable = data.byteLength;\n    // the current word being examined\n    this.word = 0; // :uint\n    // the number of bits left to examine in the current word\n    this.bitsAvailable = 0; // :uint\n  }\n\n  // ():void\n  loadWord() {\n    const data = this.data;\n    const bytesAvailable = this.bytesAvailable;\n    const position = data.byteLength - bytesAvailable;\n    const workingBytes = new Uint8Array(4);\n    const availableBytes = Math.min(4, bytesAvailable);\n    if (availableBytes === 0) {\n      throw new Error('no bytes available');\n    }\n    workingBytes.set(data.subarray(position, position + availableBytes));\n    this.word = new DataView(workingBytes.buffer).getUint32(0);\n    // track the amount of this.data that has been processed\n    this.bitsAvailable = availableBytes * 8;\n    this.bytesAvailable -= availableBytes;\n  }\n\n  // (count:int):void\n  skipBits(count) {\n    let skipBytes; // :int\n    count = Math.min(count, this.bytesAvailable * 8 + this.bitsAvailable);\n    if (this.bitsAvailable > count) {\n      this.word <<= count;\n      this.bitsAvailable -= count;\n    } else {\n      count -= this.bitsAvailable;\n      skipBytes = count >> 3;\n      count -= skipBytes << 3;\n      this.bytesAvailable -= skipBytes;\n      this.loadWord();\n      this.word <<= count;\n      this.bitsAvailable -= count;\n    }\n  }\n\n  // (size:int):uint\n  readBits(size) {\n    let bits = Math.min(this.bitsAvailable, size); // :uint\n    const valu = this.word >>> 32 - bits; // :uint\n    if (size > 32) {\n      logger.error('Cannot read more than 32 bits at a time');\n    }\n    this.bitsAvailable -= bits;\n    if (this.bitsAvailable > 0) {\n      this.word <<= bits;\n    } else if (this.bytesAvailable > 0) {\n      this.loadWord();\n    } else {\n      throw new Error('no bits available');\n    }\n    bits = size - bits;\n    if (bits > 0 && this.bitsAvailable) {\n      return valu << bits | this.readBits(bits);\n    } else {\n      return valu;\n    }\n  }\n\n  // ():uint\n  skipLZ() {\n    let leadingZeroCount; // :uint\n    for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {\n      if ((this.word & 0x80000000 >>> leadingZeroCount) !== 0) {\n        // the first bit of working word is 1\n        this.word <<= leadingZeroCount;\n        this.bitsAvailable -= leadingZeroCount;\n        return leadingZeroCount;\n      }\n    }\n    // we exhausted word and still have not found a 1\n    this.loadWord();\n    return leadingZeroCount + this.skipLZ();\n  }\n\n  // ():void\n  skipUEG() {\n    this.skipBits(1 + this.skipLZ());\n  }\n\n  // ():void\n  skipEG() {\n    this.skipBits(1 + this.skipLZ());\n  }\n\n  // ():uint\n  readUEG() {\n    const clz = this.skipLZ(); // :uint\n    return this.readBits(clz + 1) - 1;\n  }\n\n  // ():int\n  readEG() {\n    const valu = this.readUEG(); // :int\n    if (0x01 & valu) {\n      // the number is odd if the low order bit is set\n      return 1 + valu >>> 1; // add 1 to make it even, and divide by 2\n    } else {\n      return -1 * (valu >>> 1); // divide by two then make it negative\n    }\n  }\n\n  // Some convenience functions\n  // :Boolean\n  readBoolean() {\n    return this.readBits(1) === 1;\n  }\n\n  // ():int\n  readUByte() {\n    return this.readBits(8);\n  }\n\n  // ():int\n  readUShort() {\n    return this.readBits(16);\n  }\n\n  // ():int\n  readUInt() {\n    return this.readBits(32);\n  }\n}\n\nclass AvcVideoParser extends BaseVideoParser {\n  parsePES(track, textTrack, pes, endOfSegment) {\n    const units = this.parseNALu(track, pes.data, endOfSegment);\n    let VideoSample = this.VideoSample;\n    let push;\n    let spsfound = false;\n    // free pes.data to save up some memory\n    pes.data = null;\n\n    // if new NAL units found and last sample still there, let's push ...\n    // this helps parsing streams with missing AUD (only do this if AUD never found)\n    if (VideoSample && units.length && !track.audFound) {\n      this.pushAccessUnit(VideoSample, track);\n      VideoSample = this.VideoSample = this.createVideoSample(false, pes.pts, pes.dts);\n    }\n    units.forEach(unit => {\n      var _VideoSample2, _VideoSample3;\n      switch (unit.type) {\n        // NDR\n        case 1:\n          {\n            let iskey = false;\n            push = true;\n            const data = unit.data;\n            // only check slice type to detect KF in case SPS found in same packet (any keyframe is preceded by SPS ...)\n            if (spsfound && data.length > 4) {\n              // retrieve slice type by parsing beginning of NAL unit (follow H264 spec, slice_header definition) to detect keyframe embedded in NDR\n              const sliceType = this.readSliceType(data);\n              // 2 : I slice, 4 : SI slice, 7 : I slice, 9: SI slice\n              // SI slice : A slice that is coded using intra prediction only and using quantisation of the prediction samples.\n              // An SI slice can be coded such that its decoded samples can be constructed identically to an SP slice.\n              // I slice: A slice that is not an SI slice that is decoded using intra prediction only.\n              // if (sliceType === 2 || sliceType === 7) {\n              if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {\n                iskey = true;\n              }\n            }\n            if (iskey) {\n              var _VideoSample;\n              // if we have non-keyframe data already, that cannot belong to the same frame as a keyframe, so force a push\n              if ((_VideoSample = VideoSample) != null && _VideoSample.frame && !VideoSample.key) {\n                this.pushAccessUnit(VideoSample, track);\n                VideoSample = this.VideoSample = null;\n              }\n            }\n            if (!VideoSample) {\n              VideoSample = this.VideoSample = this.createVideoSample(true, pes.pts, pes.dts);\n            }\n            VideoSample.frame = true;\n            VideoSample.key = iskey;\n            break;\n            // IDR\n          }\n        case 5:\n          push = true;\n          // handle PES not starting with AUD\n          // if we have frame data already, that cannot belong to the same frame, so force a push\n          if ((_VideoSample2 = VideoSample) != null && _VideoSample2.frame && !VideoSample.key) {\n            this.pushAccessUnit(VideoSample, track);\n            VideoSample = this.VideoSample = null;\n          }\n          if (!VideoSample) {\n            VideoSample = this.VideoSample = this.createVideoSample(true, pes.pts, pes.dts);\n          }\n          VideoSample.key = true;\n          VideoSample.frame = true;\n          break;\n        // SEI\n        case 6:\n          {\n            push = true;\n            parseSEIMessageFromNALu(unit.data, 1, pes.pts, textTrack.samples);\n            break;\n            // SPS\n          }\n        case 7:\n          {\n            var _track$pixelRatio, _track$pixelRatio2;\n            push = true;\n            spsfound = true;\n            const sps = unit.data;\n            const config = this.readSPS(sps);\n            if (!track.sps || track.width !== config.width || track.height !== config.height || ((_track$pixelRatio = track.pixelRatio) == null ? void 0 : _track$pixelRatio[0]) !== config.pixelRatio[0] || ((_track$pixelRatio2 = track.pixelRatio) == null ? void 0 : _track$pixelRatio2[1]) !== config.pixelRatio[1]) {\n              track.width = config.width;\n              track.height = config.height;\n              track.pixelRatio = config.pixelRatio;\n              track.sps = [sps];\n              const codecarray = sps.subarray(1, 4);\n              let codecstring = 'avc1.';\n              for (let i = 0; i < 3; i++) {\n                let h = codecarray[i].toString(16);\n                if (h.length < 2) {\n                  h = '0' + h;\n                }\n                codecstring += h;\n              }\n              track.codec = codecstring;\n            }\n            break;\n          }\n        // PPS\n        case 8:\n          push = true;\n          track.pps = [unit.data];\n          break;\n        // AUD\n        case 9:\n          push = true;\n          track.audFound = true;\n          if ((_VideoSample3 = VideoSample) != null && _VideoSample3.frame) {\n            this.pushAccessUnit(VideoSample, track);\n            VideoSample = null;\n          }\n          if (!VideoSample) {\n            VideoSample = this.VideoSample = this.createVideoSample(false, pes.pts, pes.dts);\n          }\n          break;\n        // Filler Data\n        case 12:\n          push = true;\n          break;\n        default:\n          push = false;\n          break;\n      }\n      if (VideoSample && push) {\n        const units = VideoSample.units;\n        units.push(unit);\n      }\n    });\n    // if last PES packet, push samples\n    if (endOfSegment && VideoSample) {\n      this.pushAccessUnit(VideoSample, track);\n      this.VideoSample = null;\n    }\n  }\n  getNALuType(data, offset) {\n    return data[offset] & 0x1f;\n  }\n  readSliceType(data) {\n    const eg = new ExpGolomb(data);\n    // skip NALu type\n    eg.readUByte();\n    // discard first_mb_in_slice\n    eg.readUEG();\n    // return slice_type\n    return eg.readUEG();\n  }\n\n  /**\n   * The scaling list is optionally transmitted as part of a sequence parameter\n   * set and is not relevant to transmuxing.\n   * @param count the number of entries in this scaling list\n   * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1\n   */\n  skipScalingList(count, reader) {\n    let lastScale = 8;\n    let nextScale = 8;\n    let deltaScale;\n    for (let j = 0; j < count; j++) {\n      if (nextScale !== 0) {\n        deltaScale = reader.readEG();\n        nextScale = (lastScale + deltaScale + 256) % 256;\n      }\n      lastScale = nextScale === 0 ? lastScale : nextScale;\n    }\n  }\n\n  /**\n   * Read a sequence parameter set and return some interesting video\n   * properties. A sequence parameter set is the H264 metadata that\n   * describes the properties of upcoming video frames.\n   * @returns an object with configuration parsed from the\n   * sequence parameter set, including the dimensions of the\n   * associated video frames.\n   */\n  readSPS(sps) {\n    const eg = new ExpGolomb(sps);\n    let frameCropLeftOffset = 0;\n    let frameCropRightOffset = 0;\n    let frameCropTopOffset = 0;\n    let frameCropBottomOffset = 0;\n    let numRefFramesInPicOrderCntCycle;\n    let scalingListCount;\n    let i;\n    const readUByte = eg.readUByte.bind(eg);\n    const readBits = eg.readBits.bind(eg);\n    const readUEG = eg.readUEG.bind(eg);\n    const readBoolean = eg.readBoolean.bind(eg);\n    const skipBits = eg.skipBits.bind(eg);\n    const skipEG = eg.skipEG.bind(eg);\n    const skipUEG = eg.skipUEG.bind(eg);\n    const skipScalingList = this.skipScalingList.bind(this);\n    readUByte();\n    const profileIdc = readUByte(); // profile_idc\n    readBits(5); // profileCompat constraint_set[0-4]_flag, u(5)\n    skipBits(3); // reserved_zero_3bits u(3),\n    readUByte(); // level_idc u(8)\n    skipUEG(); // seq_parameter_set_id\n    // some profiles have more optional data we don't need\n    if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {\n      const chromaFormatIdc = readUEG();\n      if (chromaFormatIdc === 3) {\n        skipBits(1);\n      } // separate_colour_plane_flag\n\n      skipUEG(); // bit_depth_luma_minus8\n      skipUEG(); // bit_depth_chroma_minus8\n      skipBits(1); // qpprime_y_zero_transform_bypass_flag\n      if (readBoolean()) {\n        // seq_scaling_matrix_present_flag\n        scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;\n        for (i = 0; i < scalingListCount; i++) {\n          if (readBoolean()) {\n            // seq_scaling_list_present_flag[ i ]\n            if (i < 6) {\n              skipScalingList(16, eg);\n            } else {\n              skipScalingList(64, eg);\n            }\n          }\n        }\n      }\n    }\n    skipUEG(); // log2_max_frame_num_minus4\n    const picOrderCntType = readUEG();\n    if (picOrderCntType === 0) {\n      readUEG(); // log2_max_pic_order_cnt_lsb_minus4\n    } else if (picOrderCntType === 1) {\n      skipBits(1); // delta_pic_order_always_zero_flag\n      skipEG(); // offset_for_non_ref_pic\n      skipEG(); // offset_for_top_to_bottom_field\n      numRefFramesInPicOrderCntCycle = readUEG();\n      for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\n        skipEG();\n      } // offset_for_ref_frame[ i ]\n    }\n    skipUEG(); // max_num_ref_frames\n    skipBits(1); // gaps_in_frame_num_value_allowed_flag\n    const picWidthInMbsMinus1 = readUEG();\n    const picHeightInMapUnitsMinus1 = readUEG();\n    const frameMbsOnlyFlag = readBits(1);\n    if (frameMbsOnlyFlag === 0) {\n      skipBits(1);\n    } // mb_adaptive_frame_field_flag\n\n    skipBits(1); // direct_8x8_inference_flag\n    if (readBoolean()) {\n      // frame_cropping_flag\n      frameCropLeftOffset = readUEG();\n      frameCropRightOffset = readUEG();\n      frameCropTopOffset = readUEG();\n      frameCropBottomOffset = readUEG();\n    }\n    let pixelRatio = [1, 1];\n    if (readBoolean()) {\n      // vui_parameters_present_flag\n      if (readBoolean()) {\n        // aspect_ratio_info_present_flag\n        const aspectRatioIdc = readUByte();\n        switch (aspectRatioIdc) {\n          case 1:\n            pixelRatio = [1, 1];\n            break;\n          case 2:\n            pixelRatio = [12, 11];\n            break;\n          case 3:\n            pixelRatio = [10, 11];\n            break;\n          case 4:\n            pixelRatio = [16, 11];\n            break;\n          case 5:\n            pixelRatio = [40, 33];\n            break;\n          case 6:\n            pixelRatio = [24, 11];\n            break;\n          case 7:\n            pixelRatio = [20, 11];\n            break;\n          case 8:\n            pixelRatio = [32, 11];\n            break;\n          case 9:\n            pixelRatio = [80, 33];\n            break;\n          case 10:\n            pixelRatio = [18, 11];\n            break;\n          case 11:\n            pixelRatio = [15, 11];\n            break;\n          case 12:\n            pixelRatio = [64, 33];\n            break;\n          case 13:\n            pixelRatio = [160, 99];\n            break;\n          case 14:\n            pixelRatio = [4, 3];\n            break;\n          case 15:\n            pixelRatio = [3, 2];\n            break;\n          case 16:\n            pixelRatio = [2, 1];\n            break;\n          case 255:\n            {\n              pixelRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];\n              break;\n            }\n        }\n      }\n    }\n    return {\n      width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2),\n      height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),\n      pixelRatio: pixelRatio\n    };\n  }\n}\n\nclass HevcVideoParser extends BaseVideoParser {\n  constructor(...args) {\n    super(...args);\n    this.initVPS = null;\n  }\n  parsePES(track, textTrack, pes, endOfSegment) {\n    const units = this.parseNALu(track, pes.data, endOfSegment);\n    let VideoSample = this.VideoSample;\n    let push;\n    let spsfound = false;\n    // free pes.data to save up some memory\n    pes.data = null;\n\n    // if new NAL units found and last sample still there, let's push ...\n    // this helps parsing streams with missing AUD (only do this if AUD never found)\n    if (VideoSample && units.length && !track.audFound) {\n      this.pushAccessUnit(VideoSample, track);\n      VideoSample = this.VideoSample = this.createVideoSample(false, pes.pts, pes.dts);\n    }\n    units.forEach(unit => {\n      var _VideoSample2, _VideoSample3;\n      switch (unit.type) {\n        // NON-IDR, NON RANDOM ACCESS SLICE\n        case 0:\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n          if (!VideoSample) {\n            VideoSample = this.VideoSample = this.createVideoSample(false, pes.pts, pes.dts);\n          }\n          VideoSample.frame = true;\n          push = true;\n          break;\n\n        // CRA, BLA (random access picture)\n        case 16:\n        case 17:\n        case 18:\n        case 21:\n          push = true;\n          if (spsfound) {\n            var _VideoSample;\n            // handle PES not starting with AUD\n            // if we have frame data already, that cannot belong to the same frame, so force a push\n            if ((_VideoSample = VideoSample) != null && _VideoSample.frame && !VideoSample.key) {\n              this.pushAccessUnit(VideoSample, track);\n              VideoSample = this.VideoSample = null;\n            }\n          }\n          if (!VideoSample) {\n            VideoSample = this.VideoSample = this.createVideoSample(true, pes.pts, pes.dts);\n          }\n          VideoSample.key = true;\n          VideoSample.frame = true;\n          break;\n\n        // IDR\n        case 19:\n        case 20:\n          push = true;\n          // handle PES not starting with AUD\n          // if we have frame data already, that cannot belong to the same frame, so force a push\n          if ((_VideoSample2 = VideoSample) != null && _VideoSample2.frame && !VideoSample.key) {\n            this.pushAccessUnit(VideoSample, track);\n            VideoSample = this.VideoSample = null;\n          }\n          if (!VideoSample) {\n            VideoSample = this.VideoSample = this.createVideoSample(true, pes.pts, pes.dts);\n          }\n          VideoSample.key = true;\n          VideoSample.frame = true;\n          break;\n\n        // SEI\n        case 39:\n          push = true;\n          parseSEIMessageFromNALu(unit.data, 2,\n          // NALu header size\n          pes.pts, textTrack.samples);\n          break;\n\n        // VPS\n        case 32:\n          push = true;\n          if (!track.vps) {\n            if (typeof track.params !== 'object') {\n              track.params = {};\n            }\n            track.params = _extends(track.params, this.readVPS(unit.data));\n            this.initVPS = unit.data;\n          }\n          track.vps = [unit.data];\n          break;\n\n        // SPS\n        case 33:\n          push = true;\n          spsfound = true;\n          if (track.vps !== undefined && track.vps[0] !== this.initVPS && track.sps !== undefined && !this.matchSPS(track.sps[0], unit.data)) {\n            this.initVPS = track.vps[0];\n            track.sps = track.pps = undefined;\n          }\n          if (!track.sps) {\n            const config = this.readSPS(unit.data);\n            track.width = config.width;\n            track.height = config.height;\n            track.pixelRatio = config.pixelRatio;\n            track.codec = config.codecString;\n            track.sps = [];\n            if (typeof track.params !== 'object') {\n              track.params = {};\n            }\n            for (const prop in config.params) {\n              track.params[prop] = config.params[prop];\n            }\n          }\n          this.pushParameterSet(track.sps, unit.data, track.vps);\n          if (!VideoSample) {\n            VideoSample = this.VideoSample = this.createVideoSample(true, pes.pts, pes.dts);\n          }\n          VideoSample.key = true;\n          break;\n\n        // PPS\n        case 34:\n          push = true;\n          if (typeof track.params === 'object') {\n            if (!track.pps) {\n              track.pps = [];\n              const config = this.readPPS(unit.data);\n              for (const prop in config) {\n                track.params[prop] = config[prop];\n              }\n            }\n            this.pushParameterSet(track.pps, unit.data, track.vps);\n          }\n          break;\n\n        // ACCESS UNIT DELIMITER\n        case 35:\n          push = true;\n          track.audFound = true;\n          if ((_VideoSample3 = VideoSample) != null && _VideoSample3.frame) {\n            this.pushAccessUnit(VideoSample, track);\n            VideoSample = null;\n          }\n          if (!VideoSample) {\n            VideoSample = this.VideoSample = this.createVideoSample(false, pes.pts, pes.dts);\n          }\n          break;\n        default:\n          push = false;\n          break;\n      }\n      if (VideoSample && push) {\n        const units = VideoSample.units;\n        units.push(unit);\n      }\n    });\n    // if last PES packet, push samples\n    if (endOfSegment && VideoSample) {\n      this.pushAccessUnit(VideoSample, track);\n      this.VideoSample = null;\n    }\n  }\n  pushParameterSet(parameterSets, data, vps) {\n    if (vps && vps[0] === this.initVPS || !vps && !parameterSets.length) {\n      parameterSets.push(data);\n    }\n  }\n  getNALuType(data, offset) {\n    return (data[offset] & 0x7e) >>> 1;\n  }\n  ebsp2rbsp(arr) {\n    const dst = new Uint8Array(arr.byteLength);\n    let dstIdx = 0;\n    for (let i = 0; i < arr.byteLength; i++) {\n      if (i >= 2) {\n        // Unescape: Skip 0x03 after 00 00\n        if (arr[i] === 0x03 && arr[i - 1] === 0x00 && arr[i - 2] === 0x00) {\n          continue;\n        }\n      }\n      dst[dstIdx] = arr[i];\n      dstIdx++;\n    }\n    return new Uint8Array(dst.buffer, 0, dstIdx);\n  }\n  pushAccessUnit(VideoSample, videoTrack) {\n    super.pushAccessUnit(VideoSample, videoTrack);\n    if (this.initVPS) {\n      this.initVPS = null; // null initVPS to prevent possible track's sps/pps growth until next VPS\n    }\n  }\n  readVPS(vps) {\n    const eg = new ExpGolomb(vps);\n    // remove header\n    eg.readUByte();\n    eg.readUByte();\n    eg.readBits(4); // video_parameter_set_id\n    eg.skipBits(2);\n    eg.readBits(6); // max_layers_minus1\n    const max_sub_layers_minus1 = eg.readBits(3);\n    const temporal_id_nesting_flag = eg.readBoolean();\n    // ...vui fps can be here, but empty fps value is not critical for metadata\n\n    return {\n      numTemporalLayers: max_sub_layers_minus1 + 1,\n      temporalIdNested: temporal_id_nesting_flag\n    };\n  }\n  readSPS(sps) {\n    const eg = new ExpGolomb(this.ebsp2rbsp(sps));\n    eg.readUByte();\n    eg.readUByte();\n    eg.readBits(4); //video_parameter_set_id\n    const max_sub_layers_minus1 = eg.readBits(3);\n    eg.readBoolean(); // temporal_id_nesting_flag\n\n    // profile_tier_level\n    const general_profile_space = eg.readBits(2);\n    const general_tier_flag = eg.readBoolean();\n    const general_profile_idc = eg.readBits(5);\n    const general_profile_compatibility_flags_1 = eg.readUByte();\n    const general_profile_compatibility_flags_2 = eg.readUByte();\n    const general_profile_compatibility_flags_3 = eg.readUByte();\n    const general_profile_compatibility_flags_4 = eg.readUByte();\n    const general_constraint_indicator_flags_1 = eg.readUByte();\n    const general_constraint_indicator_flags_2 = eg.readUByte();\n    const general_constraint_indicator_flags_3 = eg.readUByte();\n    const general_constraint_indicator_flags_4 = eg.readUByte();\n    const general_constraint_indicator_flags_5 = eg.readUByte();\n    const general_constraint_indicator_flags_6 = eg.readUByte();\n    const general_level_idc = eg.readUByte();\n    const sub_layer_profile_present_flags = [];\n    const sub_layer_level_present_flags = [];\n    for (let i = 0; i < max_sub_layers_minus1; i++) {\n      sub_layer_profile_present_flags.push(eg.readBoolean());\n      sub_layer_level_present_flags.push(eg.readBoolean());\n    }\n    if (max_sub_layers_minus1 > 0) {\n      for (let i = max_sub_layers_minus1; i < 8; i++) {\n        eg.readBits(2);\n      }\n    }\n    for (let i = 0; i < max_sub_layers_minus1; i++) {\n      if (sub_layer_profile_present_flags[i]) {\n        eg.readUByte(); // sub_layer_profile_space, sub_layer_tier_flag, sub_layer_profile_idc\n        eg.readUByte();\n        eg.readUByte();\n        eg.readUByte();\n        eg.readUByte(); // sub_layer_profile_compatibility_flag\n        eg.readUByte();\n        eg.readUByte();\n        eg.readUByte();\n        eg.readUByte();\n        eg.readUByte();\n        eg.readUByte();\n      }\n      if (sub_layer_level_present_flags[i]) {\n        eg.readUByte();\n      }\n    }\n    eg.readUEG(); // seq_parameter_set_id\n    const chroma_format_idc = eg.readUEG();\n    if (chroma_format_idc == 3) {\n      eg.skipBits(1); //separate_colour_plane_flag\n    }\n    const pic_width_in_luma_samples = eg.readUEG();\n    const pic_height_in_luma_samples = eg.readUEG();\n    const conformance_window_flag = eg.readBoolean();\n    let pic_left_offset = 0,\n      pic_right_offset = 0,\n      pic_top_offset = 0,\n      pic_bottom_offset = 0;\n    if (conformance_window_flag) {\n      pic_left_offset += eg.readUEG();\n      pic_right_offset += eg.readUEG();\n      pic_top_offset += eg.readUEG();\n      pic_bottom_offset += eg.readUEG();\n    }\n    const bit_depth_luma_minus8 = eg.readUEG();\n    const bit_depth_chroma_minus8 = eg.readUEG();\n    const log2_max_pic_order_cnt_lsb_minus4 = eg.readUEG();\n    const sub_layer_ordering_info_present_flag = eg.readBoolean();\n    for (let i = sub_layer_ordering_info_present_flag ? 0 : max_sub_layers_minus1; i <= max_sub_layers_minus1; i++) {\n      eg.skipUEG(); // max_dec_pic_buffering_minus1[i]\n      eg.skipUEG(); // max_num_reorder_pics[i]\n      eg.skipUEG(); // max_latency_increase_plus1[i]\n    }\n    eg.skipUEG(); // log2_min_luma_coding_block_size_minus3\n    eg.skipUEG(); // log2_diff_max_min_luma_coding_block_size\n    eg.skipUEG(); // log2_min_transform_block_size_minus2\n    eg.skipUEG(); // log2_diff_max_min_transform_block_size\n    eg.skipUEG(); // max_transform_hierarchy_depth_inter\n    eg.skipUEG(); // max_transform_hierarchy_depth_intra\n    const scaling_list_enabled_flag = eg.readBoolean();\n    if (scaling_list_enabled_flag) {\n      const sps_scaling_list_data_present_flag = eg.readBoolean();\n      if (sps_scaling_list_data_present_flag) {\n        for (let sizeId = 0; sizeId < 4; sizeId++) {\n          for (let matrixId = 0; matrixId < (sizeId === 3 ? 2 : 6); matrixId++) {\n            const scaling_list_pred_mode_flag = eg.readBoolean();\n            if (!scaling_list_pred_mode_flag) {\n              eg.readUEG(); // scaling_list_pred_matrix_id_delta\n            } else {\n              const coefNum = Math.min(64, 1 << 4 + (sizeId << 1));\n              if (sizeId > 1) {\n                eg.readEG();\n              }\n              for (let i = 0; i < coefNum; i++) {\n                eg.readEG();\n              }\n            }\n          }\n        }\n      }\n    }\n    eg.readBoolean(); // amp_enabled_flag\n    eg.readBoolean(); // sample_adaptive_offset_enabled_flag\n    const pcm_enabled_flag = eg.readBoolean();\n    if (pcm_enabled_flag) {\n      eg.readUByte();\n      eg.skipUEG();\n      eg.skipUEG();\n      eg.readBoolean();\n    }\n    const num_short_term_ref_pic_sets = eg.readUEG();\n    let num_delta_pocs = 0;\n    for (let i = 0; i < num_short_term_ref_pic_sets; i++) {\n      let inter_ref_pic_set_prediction_flag = false;\n      if (i !== 0) {\n        inter_ref_pic_set_prediction_flag = eg.readBoolean();\n      }\n      if (inter_ref_pic_set_prediction_flag) {\n        if (i === num_short_term_ref_pic_sets) {\n          eg.readUEG();\n        }\n        eg.readBoolean();\n        eg.readUEG();\n        let next_num_delta_pocs = 0;\n        for (let j = 0; j <= num_delta_pocs; j++) {\n          const used_by_curr_pic_flag = eg.readBoolean();\n          let use_delta_flag = false;\n          if (!used_by_curr_pic_flag) {\n            use_delta_flag = eg.readBoolean();\n          }\n          if (used_by_curr_pic_flag || use_delta_flag) {\n            next_num_delta_pocs++;\n          }\n        }\n        num_delta_pocs = next_num_delta_pocs;\n      } else {\n        const num_negative_pics = eg.readUEG();\n        const num_positive_pics = eg.readUEG();\n        num_delta_pocs = num_negative_pics + num_positive_pics;\n        for (let j = 0; j < num_negative_pics; j++) {\n          eg.readUEG();\n          eg.readBoolean();\n        }\n        for (let j = 0; j < num_positive_pics; j++) {\n          eg.readUEG();\n          eg.readBoolean();\n        }\n      }\n    }\n    const long_term_ref_pics_present_flag = eg.readBoolean();\n    if (long_term_ref_pics_present_flag) {\n      const num_long_term_ref_pics_sps = eg.readUEG();\n      for (let i = 0; i < num_long_term_ref_pics_sps; i++) {\n        for (let j = 0; j < log2_max_pic_order_cnt_lsb_minus4 + 4; j++) {\n          eg.readBits(1);\n        }\n        eg.readBits(1);\n      }\n    }\n    let min_spatial_segmentation_idc = 0;\n    let sar_width = 1,\n      sar_height = 1;\n    let fps_fixed = true,\n      fps_den = 1,\n      fps_num = 0;\n    eg.readBoolean(); // sps_temporal_mvp_enabled_flag\n    eg.readBoolean(); // strong_intra_smoothing_enabled_flag\n    let default_display_window_flag = false;\n    const vui_parameters_present_flag = eg.readBoolean();\n    if (vui_parameters_present_flag) {\n      const aspect_ratio_info_present_flag = eg.readBoolean();\n      if (aspect_ratio_info_present_flag) {\n        const aspect_ratio_idc = eg.readUByte();\n        const sar_width_table = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2];\n        const sar_height_table = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1];\n        if (aspect_ratio_idc > 0 && aspect_ratio_idc < 16) {\n          sar_width = sar_width_table[aspect_ratio_idc - 1];\n          sar_height = sar_height_table[aspect_ratio_idc - 1];\n        } else if (aspect_ratio_idc === 255) {\n          sar_width = eg.readBits(16);\n          sar_height = eg.readBits(16);\n        }\n      }\n      const overscan_info_present_flag = eg.readBoolean();\n      if (overscan_info_present_flag) {\n        eg.readBoolean();\n      }\n      const video_signal_type_present_flag = eg.readBoolean();\n      if (video_signal_type_present_flag) {\n        eg.readBits(3);\n        eg.readBoolean();\n        const colour_description_present_flag = eg.readBoolean();\n        if (colour_description_present_flag) {\n          eg.readUByte();\n          eg.readUByte();\n          eg.readUByte();\n        }\n      }\n      const chroma_loc_info_present_flag = eg.readBoolean();\n      if (chroma_loc_info_present_flag) {\n        eg.readUEG();\n        eg.readUEG();\n      }\n      eg.readBoolean(); // neutral_chroma_indication_flag\n      eg.readBoolean(); // field_seq_flag\n      eg.readBoolean(); // frame_field_info_present_flag\n      default_display_window_flag = eg.readBoolean();\n      if (default_display_window_flag) {\n        pic_left_offset += eg.readUEG();\n        pic_right_offset += eg.readUEG();\n        pic_top_offset += eg.readUEG();\n        pic_bottom_offset += eg.readUEG();\n      }\n      const vui_timing_info_present_flag = eg.readBoolean();\n      if (vui_timing_info_present_flag) {\n        fps_den = eg.readBits(32);\n        fps_num = eg.readBits(32);\n        const vui_poc_proportional_to_timing_flag = eg.readBoolean();\n        if (vui_poc_proportional_to_timing_flag) {\n          eg.readUEG();\n        }\n        const vui_hrd_parameters_present_flag = eg.readBoolean();\n        if (vui_hrd_parameters_present_flag) {\n          //const commonInfPresentFlag = true;\n          //if (commonInfPresentFlag) {\n          const nal_hrd_parameters_present_flag = eg.readBoolean();\n          const vcl_hrd_parameters_present_flag = eg.readBoolean();\n          let sub_pic_hrd_params_present_flag = false;\n          if (nal_hrd_parameters_present_flag || vcl_hrd_parameters_present_flag) {\n            sub_pic_hrd_params_present_flag = eg.readBoolean();\n            if (sub_pic_hrd_params_present_flag) {\n              eg.readUByte();\n              eg.readBits(5);\n              eg.readBoolean();\n              eg.readBits(5);\n            }\n            eg.readBits(4); // bit_rate_scale\n            eg.readBits(4); // cpb_size_scale\n            if (sub_pic_hrd_params_present_flag) {\n              eg.readBits(4);\n            }\n            eg.readBits(5);\n            eg.readBits(5);\n            eg.readBits(5);\n          }\n          //}\n          for (let i = 0; i <= max_sub_layers_minus1; i++) {\n            fps_fixed = eg.readBoolean(); // fixed_pic_rate_general_flag\n            const fixed_pic_rate_within_cvs_flag = fps_fixed || eg.readBoolean();\n            let low_delay_hrd_flag = false;\n            if (fixed_pic_rate_within_cvs_flag) {\n              eg.readEG();\n            } else {\n              low_delay_hrd_flag = eg.readBoolean();\n            }\n            const cpb_cnt = low_delay_hrd_flag ? 1 : eg.readUEG() + 1;\n            if (nal_hrd_parameters_present_flag) {\n              for (let j = 0; j < cpb_cnt; j++) {\n                eg.readUEG();\n                eg.readUEG();\n                if (sub_pic_hrd_params_present_flag) {\n                  eg.readUEG();\n                  eg.readUEG();\n                }\n                eg.skipBits(1);\n              }\n            }\n            if (vcl_hrd_parameters_present_flag) {\n              for (let j = 0; j < cpb_cnt; j++) {\n                eg.readUEG();\n                eg.readUEG();\n                if (sub_pic_hrd_params_present_flag) {\n                  eg.readUEG();\n                  eg.readUEG();\n                }\n                eg.skipBits(1);\n              }\n            }\n          }\n        }\n      }\n      const bitstream_restriction_flag = eg.readBoolean();\n      if (bitstream_restriction_flag) {\n        eg.readBoolean(); // tiles_fixed_structure_flag\n        eg.readBoolean(); // motion_vectors_over_pic_boundaries_flag\n        eg.readBoolean(); // restricted_ref_pic_lists_flag\n        min_spatial_segmentation_idc = eg.readUEG();\n      }\n    }\n    let width = pic_width_in_luma_samples,\n      height = pic_height_in_luma_samples;\n    if (conformance_window_flag || default_display_window_flag) {\n      let chroma_scale_w = 1,\n        chroma_scale_h = 1;\n      if (chroma_format_idc === 1) {\n        // YUV 420\n        chroma_scale_w = chroma_scale_h = 2;\n      } else if (chroma_format_idc == 2) {\n        // YUV 422\n        chroma_scale_w = 2;\n      }\n      width = pic_width_in_luma_samples - chroma_scale_w * pic_right_offset - chroma_scale_w * pic_left_offset;\n      height = pic_height_in_luma_samples - chroma_scale_h * pic_bottom_offset - chroma_scale_h * pic_top_offset;\n    }\n    const profile_space_string = general_profile_space ? ['A', 'B', 'C'][general_profile_space] : '';\n    const profile_compatibility_buf = general_profile_compatibility_flags_1 << 24 | general_profile_compatibility_flags_2 << 16 | general_profile_compatibility_flags_3 << 8 | general_profile_compatibility_flags_4;\n    let profile_compatibility_rev = 0;\n    for (let i = 0; i < 32; i++) {\n      profile_compatibility_rev = (profile_compatibility_rev | (profile_compatibility_buf >> i & 1) << 31 - i) >>> 0; // reverse bit position (and cast as UInt32)\n    }\n    let profile_compatibility_flags_string = profile_compatibility_rev.toString(16);\n    if (general_profile_idc === 1 && profile_compatibility_flags_string === '2') {\n      profile_compatibility_flags_string = '6';\n    }\n    const tier_flag_string = general_tier_flag ? 'H' : 'L';\n    return {\n      codecString: `hvc1.${profile_space_string}${general_profile_idc}.${profile_compatibility_flags_string}.${tier_flag_string}${general_level_idc}.B0`,\n      params: {\n        general_tier_flag,\n        general_profile_idc,\n        general_profile_space,\n        general_profile_compatibility_flags: [general_profile_compatibility_flags_1, general_profile_compatibility_flags_2, general_profile_compatibility_flags_3, general_profile_compatibility_flags_4],\n        general_constraint_indicator_flags: [general_constraint_indicator_flags_1, general_constraint_indicator_flags_2, general_constraint_indicator_flags_3, general_constraint_indicator_flags_4, general_constraint_indicator_flags_5, general_constraint_indicator_flags_6],\n        general_level_idc,\n        bit_depth: bit_depth_luma_minus8 + 8,\n        bit_depth_luma_minus8,\n        bit_depth_chroma_minus8,\n        min_spatial_segmentation_idc,\n        chroma_format_idc: chroma_format_idc,\n        frame_rate: {\n          fixed: fps_fixed,\n          fps: fps_num / fps_den\n        }\n      },\n      width,\n      height,\n      pixelRatio: [sar_width, sar_height]\n    };\n  }\n  readPPS(pps) {\n    const eg = new ExpGolomb(this.ebsp2rbsp(pps));\n    eg.readUByte();\n    eg.readUByte();\n    eg.skipUEG(); // pic_parameter_set_id\n    eg.skipUEG(); // seq_parameter_set_id\n    eg.skipBits(2); // dependent_slice_segments_enabled_flag, output_flag_present_flag\n    eg.skipBits(3); // num_extra_slice_header_bits\n    eg.skipBits(2); // sign_data_hiding_enabled_flag, cabac_init_present_flag\n    eg.skipUEG();\n    eg.skipUEG();\n    eg.skipEG(); // init_qp_minus26\n    eg.skipBits(2); // constrained_intra_pred_flag, transform_skip_enabled_flag\n    const cu_qp_delta_enabled_flag = eg.readBoolean();\n    if (cu_qp_delta_enabled_flag) {\n      eg.skipUEG();\n    }\n    eg.skipEG(); // cb_qp_offset\n    eg.skipEG(); // cr_qp_offset\n    eg.skipBits(4); // pps_slice_chroma_qp_offsets_present_flag, weighted_pred_flag, weighted_bipred_flag, transquant_bypass_enabled_flag\n    const tiles_enabled_flag = eg.readBoolean();\n    const entropy_coding_sync_enabled_flag = eg.readBoolean();\n    let parallelismType = 1; // slice-based parallel decoding\n    if (entropy_coding_sync_enabled_flag && tiles_enabled_flag) {\n      parallelismType = 0; // mixed-type parallel decoding\n    } else if (entropy_coding_sync_enabled_flag) {\n      parallelismType = 3; // wavefront-based parallel decoding\n    } else if (tiles_enabled_flag) {\n      parallelismType = 2; // tile-based parallel decoding\n    }\n    return {\n      parallelismType\n    };\n  }\n  matchSPS(sps1, sps2) {\n    // compare without headers and VPS related params\n    return String.fromCharCode.apply(null, sps1).substr(3) === String.fromCharCode.apply(null, sps2).substr(3);\n  }\n}\n\nconst PACKET_LENGTH = 188;\nclass TSDemuxer {\n  constructor(observer, config, typeSupported, logger) {\n    this.logger = void 0;\n    this.observer = void 0;\n    this.config = void 0;\n    this.typeSupported = void 0;\n    this.sampleAes = null;\n    this.pmtParsed = false;\n    this.audioCodec = void 0;\n    this.videoCodec = void 0;\n    this._pmtId = -1;\n    this._videoTrack = void 0;\n    this._audioTrack = void 0;\n    this._id3Track = void 0;\n    this._txtTrack = void 0;\n    this.aacOverFlow = null;\n    this.remainderData = null;\n    this.videoParser = void 0;\n    this.observer = observer;\n    this.config = config;\n    this.typeSupported = typeSupported;\n    this.logger = logger;\n    this.videoParser = null;\n  }\n  static probe(data, logger) {\n    const syncOffset = TSDemuxer.syncOffset(data);\n    if (syncOffset > 0) {\n      logger.warn(`MPEG2-TS detected but first sync word found @ offset ${syncOffset}`);\n    }\n    return syncOffset !== -1;\n  }\n  static syncOffset(data) {\n    const length = data.length;\n    let scanwindow = Math.min(PACKET_LENGTH * 5, length - PACKET_LENGTH) + 1;\n    let i = 0;\n    while (i < scanwindow) {\n      // a TS init segment should contain at least 2 TS packets: PAT and PMT, each starting with 0x47\n      let foundPat = false;\n      let packetStart = -1;\n      let tsPackets = 0;\n      for (let j = i; j < length; j += PACKET_LENGTH) {\n        if (data[j] === 0x47 && (length - j === PACKET_LENGTH || data[j + PACKET_LENGTH] === 0x47)) {\n          tsPackets++;\n          if (packetStart === -1) {\n            packetStart = j;\n            // First sync word found at offset, increase scan length (#5251)\n            if (packetStart !== 0) {\n              scanwindow = Math.min(packetStart + PACKET_LENGTH * 99, data.length - PACKET_LENGTH) + 1;\n            }\n          }\n          if (!foundPat) {\n            foundPat = parsePID(data, j) === 0;\n          }\n          // Sync word found at 0 with 3 packets, or found at offset least 2 packets up to scanwindow (#5501)\n          if (foundPat && tsPackets > 1 && (packetStart === 0 && tsPackets > 2 || j + PACKET_LENGTH > scanwindow)) {\n            return packetStart;\n          }\n        } else if (tsPackets) {\n          // Exit if sync word found, but does not contain contiguous packets\n          return -1;\n        } else {\n          break;\n        }\n      }\n      i++;\n    }\n    return -1;\n  }\n\n  /**\n   * Creates a track model internal to demuxer used to drive remuxing input\n   */\n  static createTrack(type, duration) {\n    return {\n      container: type === 'video' || type === 'audio' ? 'video/mp2t' : undefined,\n      type,\n      id: RemuxerTrackIdConfig[type],\n      pid: -1,\n      inputTimeScale: 90000,\n      sequenceNumber: 0,\n      samples: [],\n      dropped: 0,\n      duration: type === 'audio' ? duration : undefined\n    };\n  }\n\n  /**\n   * Initializes a new init segment on the demuxer/remuxer interface. Needed for discontinuities/track-switches (or at stream start)\n   * Resets all internal track instances of the demuxer.\n   */\n  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    this.pmtParsed = false;\n    this._pmtId = -1;\n    this._videoTrack = TSDemuxer.createTrack('video');\n    this._videoTrack.duration = trackDuration;\n    this._audioTrack = TSDemuxer.createTrack('audio', trackDuration);\n    this._id3Track = TSDemuxer.createTrack('id3');\n    this._txtTrack = TSDemuxer.createTrack('text');\n    this._audioTrack.segmentCodec = 'aac';\n\n    // flush any partial content\n    this.aacOverFlow = null;\n    this.remainderData = null;\n    this.audioCodec = audioCodec;\n    this.videoCodec = videoCodec;\n  }\n  resetTimeStamp() {}\n  resetContiguity() {\n    const {\n      _audioTrack,\n      _videoTrack,\n      _id3Track\n    } = this;\n    if (_audioTrack) {\n      _audioTrack.pesData = null;\n    }\n    if (_videoTrack) {\n      _videoTrack.pesData = null;\n    }\n    if (_id3Track) {\n      _id3Track.pesData = null;\n    }\n    this.aacOverFlow = null;\n    this.remainderData = null;\n  }\n  demux(data, timeOffset, isSampleAes = false, flush = false) {\n    if (!isSampleAes) {\n      this.sampleAes = null;\n    }\n    let pes;\n    const videoTrack = this._videoTrack;\n    const audioTrack = this._audioTrack;\n    const id3Track = this._id3Track;\n    const textTrack = this._txtTrack;\n    let videoPid = videoTrack.pid;\n    let videoData = videoTrack.pesData;\n    let audioPid = audioTrack.pid;\n    let id3Pid = id3Track.pid;\n    let audioData = audioTrack.pesData;\n    let id3Data = id3Track.pesData;\n    let unknownPID = null;\n    let pmtParsed = this.pmtParsed;\n    let pmtId = this._pmtId;\n    let len = data.length;\n    if (this.remainderData) {\n      data = appendUint8Array(this.remainderData, data);\n      len = data.length;\n      this.remainderData = null;\n    }\n    if (len < PACKET_LENGTH && !flush) {\n      this.remainderData = data;\n      return {\n        audioTrack,\n        videoTrack,\n        id3Track,\n        textTrack\n      };\n    }\n    const syncOffset = Math.max(0, TSDemuxer.syncOffset(data));\n    len -= (len - syncOffset) % PACKET_LENGTH;\n    if (len < data.byteLength && !flush) {\n      this.remainderData = new Uint8Array(data.buffer, len, data.buffer.byteLength - len);\n    }\n\n    // loop through TS packets\n    let tsPacketErrors = 0;\n    for (let start = syncOffset; start < len; start += PACKET_LENGTH) {\n      if (data[start] === 0x47) {\n        const stt = !!(data[start + 1] & 0x40);\n        const pid = parsePID(data, start);\n        const atf = (data[start + 3] & 0x30) >> 4;\n\n        // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.\n        let offset;\n        if (atf > 1) {\n          offset = start + 5 + data[start + 4];\n          // continue if there is only adaptation field\n          if (offset === start + PACKET_LENGTH) {\n            continue;\n          }\n        } else {\n          offset = start + 4;\n        }\n        switch (pid) {\n          case videoPid:\n            if (stt) {\n              if (videoData && (pes = parsePES(videoData, this.logger))) {\n                if (this.videoParser === null) {\n                  switch (videoTrack.segmentCodec) {\n                    case 'avc':\n                      this.videoParser = new AvcVideoParser();\n                      break;\n                    case 'hevc':\n                      {\n                        this.videoParser = new HevcVideoParser();\n                      }\n                      break;\n                  }\n                }\n                if (this.videoParser !== null) {\n                  this.videoParser.parsePES(videoTrack, textTrack, pes, false);\n                }\n              }\n              videoData = {\n                data: [],\n                size: 0\n              };\n            }\n            if (videoData) {\n              videoData.data.push(data.subarray(offset, start + PACKET_LENGTH));\n              videoData.size += start + PACKET_LENGTH - offset;\n            }\n            break;\n          case audioPid:\n            if (stt) {\n              if (audioData && (pes = parsePES(audioData, this.logger))) {\n                switch (audioTrack.segmentCodec) {\n                  case 'aac':\n                    this.parseAACPES(audioTrack, pes);\n                    break;\n                  case 'mp3':\n                    this.parseMPEGPES(audioTrack, pes);\n                    break;\n                  case 'ac3':\n                    {\n                      this.parseAC3PES(audioTrack, pes);\n                    }\n                    break;\n                }\n              }\n              audioData = {\n                data: [],\n                size: 0\n              };\n            }\n            if (audioData) {\n              audioData.data.push(data.subarray(offset, start + PACKET_LENGTH));\n              audioData.size += start + PACKET_LENGTH - offset;\n            }\n            break;\n          case id3Pid:\n            if (stt) {\n              if (id3Data && (pes = parsePES(id3Data, this.logger))) {\n                this.parseID3PES(id3Track, pes);\n              }\n              id3Data = {\n                data: [],\n                size: 0\n              };\n            }\n            if (id3Data) {\n              id3Data.data.push(data.subarray(offset, start + PACKET_LENGTH));\n              id3Data.size += start + PACKET_LENGTH - offset;\n            }\n            break;\n          case 0:\n            if (stt) {\n              offset += data[offset] + 1;\n            }\n            pmtId = this._pmtId = parsePAT(data, offset);\n            // this.logger.log('PMT PID:'  + this._pmtId);\n            break;\n          case pmtId:\n            {\n              if (stt) {\n                offset += data[offset] + 1;\n              }\n              const parsedPIDs = parsePMT(data, offset, this.typeSupported, isSampleAes, this.observer, this.logger);\n\n              // only update track id if track PID found while parsing PMT\n              // this is to avoid resetting the PID to -1 in case\n              // track PID transiently disappears from the stream\n              // this could happen in case of transient missing audio samples for example\n              // NOTE this is only the PID of the track as found in TS,\n              // but we are not using this for MP4 track IDs.\n              videoPid = parsedPIDs.videoPid;\n              if (videoPid > 0) {\n                videoTrack.pid = videoPid;\n                videoTrack.segmentCodec = parsedPIDs.segmentVideoCodec;\n              }\n              audioPid = parsedPIDs.audioPid;\n              if (audioPid > 0) {\n                audioTrack.pid = audioPid;\n                audioTrack.segmentCodec = parsedPIDs.segmentAudioCodec;\n              }\n              id3Pid = parsedPIDs.id3Pid;\n              if (id3Pid > 0) {\n                id3Track.pid = id3Pid;\n              }\n              if (unknownPID !== null && !pmtParsed) {\n                this.logger.warn(`MPEG-TS PMT found at ${start} after unknown PID '${unknownPID}'. Backtracking to sync byte @${syncOffset} to parse all TS packets.`);\n                unknownPID = null;\n                // we set it to -188, the += 188 in the for loop will reset start to 0\n                start = syncOffset - 188;\n              }\n              pmtParsed = this.pmtParsed = true;\n              break;\n            }\n          case 0x11:\n          case 0x1fff:\n            break;\n          default:\n            unknownPID = pid;\n            break;\n        }\n      } else {\n        tsPacketErrors++;\n      }\n    }\n    if (tsPacketErrors > 0) {\n      emitParsingError(this.observer, new Error(`Found ${tsPacketErrors} TS packet/s that do not start with 0x47`), undefined, this.logger);\n    }\n    videoTrack.pesData = videoData;\n    audioTrack.pesData = audioData;\n    id3Track.pesData = id3Data;\n    const demuxResult = {\n      audioTrack,\n      videoTrack,\n      id3Track,\n      textTrack\n    };\n    if (flush) {\n      this.extractRemainingSamples(demuxResult);\n    }\n    return demuxResult;\n  }\n  flush() {\n    const {\n      remainderData\n    } = this;\n    this.remainderData = null;\n    let result;\n    if (remainderData) {\n      result = this.demux(remainderData, -1, false, true);\n    } else {\n      result = {\n        videoTrack: this._videoTrack,\n        audioTrack: this._audioTrack,\n        id3Track: this._id3Track,\n        textTrack: this._txtTrack\n      };\n    }\n    this.extractRemainingSamples(result);\n    if (this.sampleAes) {\n      return this.decrypt(result, this.sampleAes);\n    }\n    return result;\n  }\n  extractRemainingSamples(demuxResult) {\n    const {\n      audioTrack,\n      videoTrack,\n      id3Track,\n      textTrack\n    } = demuxResult;\n    const videoData = videoTrack.pesData;\n    const audioData = audioTrack.pesData;\n    const id3Data = id3Track.pesData;\n    // try to parse last PES packets\n    let pes;\n    if (videoData && (pes = parsePES(videoData, this.logger))) {\n      if (this.videoParser === null) {\n        switch (videoTrack.segmentCodec) {\n          case 'avc':\n            this.videoParser = new AvcVideoParser();\n            break;\n          case 'hevc':\n            {\n              this.videoParser = new HevcVideoParser();\n            }\n            break;\n        }\n      }\n      if (this.videoParser !== null) {\n        this.videoParser.parsePES(videoTrack, textTrack, pes, true);\n        videoTrack.pesData = null;\n      }\n    } else {\n      // either avcData null or PES truncated, keep it for next frag parsing\n      videoTrack.pesData = videoData;\n    }\n    if (audioData && (pes = parsePES(audioData, this.logger))) {\n      switch (audioTrack.segmentCodec) {\n        case 'aac':\n          this.parseAACPES(audioTrack, pes);\n          break;\n        case 'mp3':\n          this.parseMPEGPES(audioTrack, pes);\n          break;\n        case 'ac3':\n          {\n            this.parseAC3PES(audioTrack, pes);\n          }\n          break;\n      }\n      audioTrack.pesData = null;\n    } else {\n      if (audioData != null && audioData.size) {\n        this.logger.log('last AAC PES packet truncated,might overlap between fragments');\n      }\n\n      // either audioData null or PES truncated, keep it for next frag parsing\n      audioTrack.pesData = audioData;\n    }\n    if (id3Data && (pes = parsePES(id3Data, this.logger))) {\n      this.parseID3PES(id3Track, pes);\n      id3Track.pesData = null;\n    } else {\n      // either id3Data null or PES truncated, keep it for next frag parsing\n      id3Track.pesData = id3Data;\n    }\n  }\n  demuxSampleAes(data, keyData, timeOffset) {\n    const demuxResult = this.demux(data, timeOffset, true, !this.config.progressive);\n    const sampleAes = this.sampleAes = new SampleAesDecrypter(this.observer, this.config, keyData);\n    return this.decrypt(demuxResult, sampleAes);\n  }\n  decrypt(demuxResult, sampleAes) {\n    return new Promise(resolve => {\n      const {\n        audioTrack,\n        videoTrack\n      } = demuxResult;\n      if (audioTrack.samples && audioTrack.segmentCodec === 'aac') {\n        sampleAes.decryptAacSamples(audioTrack.samples, 0, () => {\n          if (videoTrack.samples) {\n            sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, () => {\n              resolve(demuxResult);\n            });\n          } else {\n            resolve(demuxResult);\n          }\n        });\n      } else if (videoTrack.samples) {\n        sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, () => {\n          resolve(demuxResult);\n        });\n      }\n    });\n  }\n  destroy() {\n    if (this.observer) {\n      this.observer.removeAllListeners();\n    }\n    // @ts-ignore\n    this.config = this.logger = this.observer = null;\n    this.aacOverFlow = this.videoParser = this.remainderData = this.sampleAes = null;\n    this._videoTrack = this._audioTrack = this._id3Track = this._txtTrack = undefined;\n  }\n  parseAACPES(track, pes) {\n    let startOffset = 0;\n    const aacOverFlow = this.aacOverFlow;\n    let data = pes.data;\n    if (aacOverFlow) {\n      this.aacOverFlow = null;\n      const frameMissingBytes = aacOverFlow.missing;\n      const sampleLength = aacOverFlow.sample.unit.byteLength;\n      // logger.log(`AAC: append overflowing ${sampleLength} bytes to beginning of new PES`);\n      if (frameMissingBytes === -1) {\n        data = appendUint8Array(aacOverFlow.sample.unit, data);\n      } else {\n        const frameOverflowBytes = sampleLength - frameMissingBytes;\n        aacOverFlow.sample.unit.set(data.subarray(0, frameMissingBytes), frameOverflowBytes);\n        track.samples.push(aacOverFlow.sample);\n        startOffset = aacOverFlow.missing;\n      }\n    }\n    // look for ADTS header (0xFFFx)\n    let offset;\n    let len;\n    for (offset = startOffset, len = data.length; offset < len - 1; offset++) {\n      if (isHeader$1(data, offset)) {\n        break;\n      }\n    }\n    // if ADTS header does not start straight from the beginning of the PES payload, raise an error\n    if (offset !== startOffset) {\n      let reason;\n      const recoverable = offset < len - 1;\n      if (recoverable) {\n        reason = `AAC PES did not start with ADTS header,offset:${offset}`;\n      } else {\n        reason = 'No ADTS header found in AAC PES';\n      }\n      emitParsingError(this.observer, new Error(reason), recoverable, this.logger);\n      if (!recoverable) {\n        return;\n      }\n    }\n    initTrackConfig(track, this.observer, data, offset, this.audioCodec);\n    let pts;\n    if (pes.pts !== undefined) {\n      pts = pes.pts;\n    } else if (aacOverFlow) {\n      // if last AAC frame is overflowing, we should ensure timestamps are contiguous:\n      // first sample PTS should be equal to last sample PTS + frameDuration\n      const frameDuration = getFrameDuration(track.samplerate);\n      pts = aacOverFlow.sample.pts + frameDuration;\n    } else {\n      this.logger.warn('[tsdemuxer]: AAC PES unknown PTS');\n      return;\n    }\n\n    // scan for aac samples\n    let frameIndex = 0;\n    let frame;\n    while (offset < len) {\n      frame = appendFrame$2(track, data, offset, pts, frameIndex);\n      offset += frame.length;\n      if (!frame.missing) {\n        frameIndex++;\n        for (; offset < len - 1; offset++) {\n          if (isHeader$1(data, offset)) {\n            break;\n          }\n        }\n      } else {\n        this.aacOverFlow = frame;\n        break;\n      }\n    }\n  }\n  parseMPEGPES(track, pes) {\n    const data = pes.data;\n    const length = data.length;\n    let frameIndex = 0;\n    let offset = 0;\n    const pts = pes.pts;\n    if (pts === undefined) {\n      this.logger.warn('[tsdemuxer]: MPEG PES unknown PTS');\n      return;\n    }\n    while (offset < length) {\n      if (isHeader(data, offset)) {\n        const frame = appendFrame$1(track, data, offset, pts, frameIndex);\n        if (frame) {\n          offset += frame.length;\n          frameIndex++;\n        } else {\n          // logger.log('Unable to parse Mpeg audio frame');\n          break;\n        }\n      } else {\n        // nothing found, keep looking\n        offset++;\n      }\n    }\n  }\n  parseAC3PES(track, pes) {\n    {\n      const data = pes.data;\n      const pts = pes.pts;\n      if (pts === undefined) {\n        this.logger.warn('[tsdemuxer]: AC3 PES unknown PTS');\n        return;\n      }\n      const length = data.length;\n      let frameIndex = 0;\n      let offset = 0;\n      let parsed;\n      while (offset < length && (parsed = appendFrame(track, data, offset, pts, frameIndex++)) > 0) {\n        offset += parsed;\n      }\n    }\n  }\n  parseID3PES(id3Track, pes) {\n    if (pes.pts === undefined) {\n      this.logger.warn('[tsdemuxer]: ID3 PES unknown PTS');\n      return;\n    }\n    const id3Sample = _extends({}, pes, {\n      type: this._videoTrack ? MetadataSchema.emsg : MetadataSchema.audioId3,\n      duration: Number.POSITIVE_INFINITY\n    });\n    id3Track.samples.push(id3Sample);\n  }\n}\nfunction parsePID(data, offset) {\n  // pid is a 13-bit field starting at the last bit of TS[1]\n  return ((data[offset + 1] & 0x1f) << 8) + data[offset + 2];\n}\nfunction parsePAT(data, offset) {\n  // skip the PSI header and parse the first PMT entry\n  return (data[offset + 10] & 0x1f) << 8 | data[offset + 11];\n}\nfunction parsePMT(data, offset, typeSupported, isSampleAes, observer, logger) {\n  const result = {\n    audioPid: -1,\n    videoPid: -1,\n    id3Pid: -1,\n    segmentVideoCodec: 'avc',\n    segmentAudioCodec: 'aac'\n  };\n  const sectionLength = (data[offset + 1] & 0x0f) << 8 | data[offset + 2];\n  const tableEnd = offset + 3 + sectionLength - 4;\n  // to determine where the table is, we have to figure out how\n  // long the program info descriptors are\n  const programInfoLength = (data[offset + 10] & 0x0f) << 8 | data[offset + 11];\n  // advance the offset to the first entry in the mapping table\n  offset += 12 + programInfoLength;\n  while (offset < tableEnd) {\n    const pid = parsePID(data, offset);\n    const esInfoLength = (data[offset + 3] & 0x0f) << 8 | data[offset + 4];\n    switch (data[offset]) {\n      case 0xcf:\n        // SAMPLE-AES AAC\n        if (!isSampleAes) {\n          logEncryptedSamplesFoundInUnencryptedStream('ADTS AAC', logger);\n          break;\n        }\n      /* falls through */\n      case 0x0f:\n        // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)\n        // logger.log('AAC PID:'  + pid);\n        if (result.audioPid === -1) {\n          result.audioPid = pid;\n        }\n        break;\n\n      // Packetized metadata (ID3)\n      case 0x15:\n        // logger.log('ID3 PID:'  + pid);\n        if (result.id3Pid === -1) {\n          result.id3Pid = pid;\n        }\n        break;\n      case 0xdb:\n        // SAMPLE-AES AVC\n        if (!isSampleAes) {\n          logEncryptedSamplesFoundInUnencryptedStream('H.264', logger);\n          break;\n        }\n      /* falls through */\n      case 0x1b:\n        // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)\n        // logger.log('AVC PID:'  + pid);\n        if (result.videoPid === -1) {\n          result.videoPid = pid;\n        }\n        break;\n\n      // ISO/IEC 11172-3 (MPEG-1 audio)\n      // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)\n      case 0x03:\n      case 0x04:\n        // logger.log('MPEG PID:'  + pid);\n        if (!typeSupported.mpeg && !typeSupported.mp3) {\n          logger.log('MPEG audio found, not supported in this browser');\n        } else if (result.audioPid === -1) {\n          result.audioPid = pid;\n          result.segmentAudioCodec = 'mp3';\n        }\n        break;\n      case 0xc1:\n        // SAMPLE-AES AC3\n        if (!isSampleAes) {\n          logEncryptedSamplesFoundInUnencryptedStream('AC-3', logger);\n          break;\n        }\n      /* falls through */\n      case 0x81:\n        {\n          if (!typeSupported.ac3) {\n            logger.log('AC-3 audio found, not supported in this browser');\n          } else if (result.audioPid === -1) {\n            result.audioPid = pid;\n            result.segmentAudioCodec = 'ac3';\n          }\n        }\n        break;\n      case 0x06:\n        // stream_type 6 can mean a lot of different things in case of DVB.\n        // We need to look at the descriptors. Right now, we're only interested\n        // in AC-3 audio, so we do the descriptor parsing only when we don't have\n        // an audio PID yet.\n        if (result.audioPid === -1 && esInfoLength > 0) {\n          let parsePos = offset + 5;\n          let remaining = esInfoLength;\n          while (remaining > 2) {\n            const descriptorId = data[parsePos];\n            switch (descriptorId) {\n              case 0x6a:\n                // DVB Descriptor for AC-3\n                {\n                  if (typeSupported.ac3 !== true) {\n                    logger.log('AC-3 audio found, not supported in this browser for now');\n                  } else {\n                    result.audioPid = pid;\n                    result.segmentAudioCodec = 'ac3';\n                  }\n                }\n                break;\n            }\n            const descriptorLen = data[parsePos + 1] + 2;\n            parsePos += descriptorLen;\n            remaining -= descriptorLen;\n          }\n        }\n        break;\n      case 0xc2: // SAMPLE-AES EC3\n      /* falls through */\n      case 0x87:\n        emitParsingError(observer, new Error('Unsupported EC-3 in M2TS found'), undefined, logger);\n        return result;\n      case 0x24:\n        // ITU-T Rec. H.265 and ISO/IEC 23008-2 (HEVC)\n        {\n          if (result.videoPid === -1) {\n            result.videoPid = pid;\n            result.segmentVideoCodec = 'hevc';\n            logger.log('HEVC in M2TS found');\n          }\n        }\n        break;\n    }\n    // move to the next table entry\n    // skip past the elementary stream descriptors, if present\n    offset += esInfoLength + 5;\n  }\n  return result;\n}\nfunction emitParsingError(observer, error, levelRetry, logger) {\n  logger.warn(`parsing error: ${error.message}`);\n  observer.emit(Events.ERROR, Events.ERROR, {\n    type: ErrorTypes.MEDIA_ERROR,\n    details: ErrorDetails.FRAG_PARSING_ERROR,\n    fatal: false,\n    levelRetry,\n    error,\n    reason: error.message\n  });\n}\nfunction logEncryptedSamplesFoundInUnencryptedStream(type, logger) {\n  logger.log(`${type} with AES-128-CBC encryption found in unencrypted stream`);\n}\nfunction parsePES(stream, logger) {\n  let i = 0;\n  let frag;\n  let pesLen;\n  let pesHdrLen;\n  let pesPts;\n  let pesDts;\n  const data = stream.data;\n  // safety check\n  if (!stream || stream.size === 0) {\n    return null;\n  }\n\n  // we might need up to 19 bytes to read PES header\n  // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes\n  // usually only one merge is needed (and this is rare ...)\n  while (data[0].length < 19 && data.length > 1) {\n    data[0] = appendUint8Array(data[0], data[1]);\n    data.splice(1, 1);\n  }\n  // retrieve PTS/DTS from first fragment\n  frag = data[0];\n  const pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];\n  if (pesPrefix === 1) {\n    pesLen = (frag[4] << 8) + frag[5];\n    // if PES parsed length is not zero and greater than total received length, stop parsing. PES might be truncated\n    // minus 6 : PES header size\n    if (pesLen && pesLen > stream.size - 6) {\n      return null;\n    }\n    const pesFlags = frag[7];\n    if (pesFlags & 0xc0) {\n      /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n          as PTS / DTS is 33 bit we cannot use bitwise operator in JS,\n          as Bitwise operators treat their operands as a sequence of 32 bits */\n      pesPts = (frag[9] & 0x0e) * 536870912 +\n      // 1 << 29\n      (frag[10] & 0xff) * 4194304 +\n      // 1 << 22\n      (frag[11] & 0xfe) * 16384 +\n      // 1 << 14\n      (frag[12] & 0xff) * 128 +\n      // 1 << 7\n      (frag[13] & 0xfe) / 2;\n      if (pesFlags & 0x40) {\n        pesDts = (frag[14] & 0x0e) * 536870912 +\n        // 1 << 29\n        (frag[15] & 0xff) * 4194304 +\n        // 1 << 22\n        (frag[16] & 0xfe) * 16384 +\n        // 1 << 14\n        (frag[17] & 0xff) * 128 +\n        // 1 << 7\n        (frag[18] & 0xfe) / 2;\n        if (pesPts - pesDts > 60 * 90000) {\n          logger.warn(`${Math.round((pesPts - pesDts) / 90000)}s delta between PTS and DTS, align them`);\n          pesPts = pesDts;\n        }\n      } else {\n        pesDts = pesPts;\n      }\n    }\n    pesHdrLen = frag[8];\n    // 9 bytes : 6 bytes for PES header + 3 bytes for PES extension\n    let payloadStartOffset = pesHdrLen + 9;\n    if (stream.size <= payloadStartOffset) {\n      return null;\n    }\n    stream.size -= payloadStartOffset;\n    // reassemble PES packet\n    const pesData = new Uint8Array(stream.size);\n    for (let j = 0, dataLen = data.length; j < dataLen; j++) {\n      frag = data[j];\n      let len = frag.byteLength;\n      if (payloadStartOffset) {\n        if (payloadStartOffset > len) {\n          // trim full frag if PES header bigger than frag\n          payloadStartOffset -= len;\n          continue;\n        } else {\n          // trim partial frag if PES header smaller than frag\n          frag = frag.subarray(payloadStartOffset);\n          len -= payloadStartOffset;\n          payloadStartOffset = 0;\n        }\n      }\n      pesData.set(frag, i);\n      i += len;\n    }\n    if (pesLen) {\n      // payload size : remove PES header + PES extension\n      pesLen -= pesHdrLen + 3;\n    }\n    return {\n      data: pesData,\n      pts: pesPts,\n      dts: pesDts,\n      len: pesLen\n    };\n  }\n  return null;\n}\n\n/**\n *  AAC helper\n */\n\nclass AAC {\n  static getSilentFrame(codec, channelCount) {\n    switch (codec) {\n      case 'mp4a.40.2':\n        if (channelCount === 1) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);\n        } else if (channelCount === 2) {\n          return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);\n        } else if (channelCount === 3) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);\n        } else if (channelCount === 4) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);\n        } else if (channelCount === 5) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);\n        } else if (channelCount === 6) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);\n        }\n        break;\n      // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)\n      default:\n        if (channelCount === 1) {\n          // ffmpeg -y -f lavfi -i \"aevalsrc=0:d=0.05\" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n          return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n        } else if (channelCount === 2) {\n          // ffmpeg -y -f lavfi -i \"aevalsrc=0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n          return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n        } else if (channelCount === 3) {\n          // ffmpeg -y -f lavfi -i \"aevalsrc=0|0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n          return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n        }\n        break;\n    }\n    return undefined;\n  }\n}\n\n/**\n * Generate MP4 Box\n */\n\nconst UINT32_MAX = Math.pow(2, 32) - 1;\nclass MP4 {\n  static init() {\n    MP4.types = {\n      avc1: [],\n      // codingname\n      avcC: [],\n      hvc1: [],\n      hvcC: [],\n      btrt: [],\n      dinf: [],\n      dref: [],\n      esds: [],\n      ftyp: [],\n      hdlr: [],\n      mdat: [],\n      mdhd: [],\n      mdia: [],\n      mfhd: [],\n      minf: [],\n      moof: [],\n      moov: [],\n      mp4a: [],\n      '.mp3': [],\n      dac3: [],\n      'ac-3': [],\n      mvex: [],\n      mvhd: [],\n      pasp: [],\n      sdtp: [],\n      stbl: [],\n      stco: [],\n      stsc: [],\n      stsd: [],\n      stsz: [],\n      stts: [],\n      tfdt: [],\n      tfhd: [],\n      traf: [],\n      trak: [],\n      trun: [],\n      trex: [],\n      tkhd: [],\n      vmhd: [],\n      smhd: []\n    };\n    let i;\n    for (i in MP4.types) {\n      if (MP4.types.hasOwnProperty(i)) {\n        MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];\n      }\n    }\n    const videoHdlr = new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00,\n    // pre_defined\n    0x76, 0x69, 0x64, 0x65,\n    // handler_type: 'vide'\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\n    ]);\n    const audioHdlr = new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00,\n    // pre_defined\n    0x73, 0x6f, 0x75, 0x6e,\n    // handler_type: 'soun'\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\n    ]);\n    MP4.HDLR_TYPES = {\n      video: videoHdlr,\n      audio: audioHdlr\n    };\n    const dref = new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x01,\n    // entry_count\n    0x00, 0x00, 0x00, 0x0c,\n    // entry_size\n    0x75, 0x72, 0x6c, 0x20,\n    // 'url' type\n    0x00,\n    // version 0\n    0x00, 0x00, 0x01 // entry_flags\n    ]);\n    const stco = new Uint8Array([0x00,\n    // version\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00 // entry_count\n    ]);\n    MP4.STTS = MP4.STSC = MP4.STCO = stco;\n    MP4.STSZ = new Uint8Array([0x00,\n    // version\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00,\n    // sample_size\n    0x00, 0x00, 0x00, 0x00 // sample_count\n    ]);\n    MP4.VMHD = new Uint8Array([0x00,\n    // version\n    0x00, 0x00, 0x01,\n    // flags\n    0x00, 0x00,\n    // graphicsmode\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor\n    ]);\n    MP4.SMHD = new Uint8Array([0x00,\n    // version\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00,\n    // balance\n    0x00, 0x00 // reserved\n    ]);\n    MP4.STSD = new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x01]); // entry_count\n\n    const majorBrand = new Uint8Array([105, 115, 111, 109]); // isom\n    const avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1\n    const minorVersion = new Uint8Array([0, 0, 0, 1]);\n    MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);\n    MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));\n  }\n  static box(type, ...payload) {\n    let size = 8;\n    let i = payload.length;\n    const len = i;\n    // calculate the total size we need to allocate\n    while (i--) {\n      size += payload[i].byteLength;\n    }\n    const result = new Uint8Array(size);\n    result[0] = size >> 24 & 0xff;\n    result[1] = size >> 16 & 0xff;\n    result[2] = size >> 8 & 0xff;\n    result[3] = size & 0xff;\n    result.set(type, 4);\n    // copy the payload into the result\n    for (i = 0, size = 8; i < len; i++) {\n      // copy payload[i] array @ offset size\n      result.set(payload[i], size);\n      size += payload[i].byteLength;\n    }\n    return result;\n  }\n  static hdlr(type) {\n    return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);\n  }\n  static mdat(data) {\n    return MP4.box(MP4.types.mdat, data);\n  }\n  static mdhd(timescale, duration) {\n    duration *= timescale;\n    const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n    const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n    return MP4.box(MP4.types.mdhd, new Uint8Array([0x01,\n    // version 1\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,\n    // creation_time\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,\n    // modification_time\n    timescale >> 24 & 0xff, timescale >> 16 & 0xff, timescale >> 8 & 0xff, timescale & 0xff,\n    // timescale\n    upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x55, 0xc4,\n    // 'und' language (undetermined)\n    0x00, 0x00]));\n  }\n  static mdia(track) {\n    return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale || 0, track.duration || 0), MP4.hdlr(track.type), MP4.minf(track));\n  }\n  static mfhd(sequenceNumber) {\n    return MP4.box(MP4.types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00,\n    // flags\n    sequenceNumber >> 24, sequenceNumber >> 16 & 0xff, sequenceNumber >> 8 & 0xff, sequenceNumber & 0xff // sequence_number\n    ]));\n  }\n  static minf(track) {\n    if (track.type === 'audio') {\n      return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));\n    } else {\n      return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));\n    }\n  }\n  static moof(sn, baseMediaDecodeTime, track) {\n    return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));\n  }\n  static moov(tracks) {\n    let i = tracks.length;\n    const boxes = [];\n    while (i--) {\n      boxes[i] = MP4.trak(tracks[i]);\n    }\n    return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].timescale || 0, tracks[0].duration || 0)].concat(boxes).concat(MP4.mvex(tracks)));\n  }\n  static mvex(tracks) {\n    let i = tracks.length;\n    const boxes = [];\n    while (i--) {\n      boxes[i] = MP4.trex(tracks[i]);\n    }\n    return MP4.box.apply(null, [MP4.types.mvex, ...boxes]);\n  }\n  static mvhd(timescale, duration) {\n    duration *= timescale;\n    const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n    const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n    const bytes = new Uint8Array([0x01,\n    // version 1\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,\n    // creation_time\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,\n    // modification_time\n    timescale >> 24 & 0xff, timescale >> 16 & 0xff, timescale >> 8 & 0xff, timescale & 0xff,\n    // timescale\n    upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x00, 0x01, 0x00, 0x00,\n    // 1.0 rate\n    0x01, 0x00,\n    // 1.0 volume\n    0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,\n    // transformation: unity matrix\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // pre_defined\n    0xff, 0xff, 0xff, 0xff // next_track_ID\n    ]);\n    return MP4.box(MP4.types.mvhd, bytes);\n  }\n  static sdtp(track) {\n    const samples = track.samples || [];\n    const bytes = new Uint8Array(4 + samples.length);\n    let i;\n    let flags;\n    // leave the full box header (4 bytes) all zero\n    // write the sample table\n    for (i = 0; i < samples.length; i++) {\n      flags = samples[i].flags;\n      bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;\n    }\n    return MP4.box(MP4.types.sdtp, bytes);\n  }\n  static stbl(track) {\n    return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));\n  }\n  static avc1(track) {\n    let sps = [];\n    let pps = [];\n    let i;\n    let data;\n    let len;\n    // assemble the SPSs\n\n    for (i = 0; i < track.sps.length; i++) {\n      data = track.sps[i];\n      len = data.byteLength;\n      sps.push(len >>> 8 & 0xff);\n      sps.push(len & 0xff);\n\n      // SPS\n      sps = sps.concat(Array.prototype.slice.call(data));\n    }\n\n    // assemble the PPSs\n    for (i = 0; i < track.pps.length; i++) {\n      data = track.pps[i];\n      len = data.byteLength;\n      pps.push(len >>> 8 & 0xff);\n      pps.push(len & 0xff);\n      pps = pps.concat(Array.prototype.slice.call(data));\n    }\n    const avcc = MP4.box(MP4.types.avcC, new Uint8Array([0x01,\n    // version\n    sps[3],\n    // profile\n    sps[4],\n    // profile compat\n    sps[5],\n    // level\n    0xfc | 3,\n    // lengthSizeMinusOne, hard-coded to 4 bytes\n    0xe0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets\n    ].concat(sps).concat([track.pps.length // numOfPictureParameterSets\n    ]).concat(pps))); // \"PPS\"\n    const width = track.width;\n    const height = track.height;\n    const hSpacing = track.pixelRatio[0];\n    const vSpacing = track.pixelRatio[1];\n    return MP4.box(MP4.types.avc1, new Uint8Array([0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x01,\n    // data_reference_index\n    0x00, 0x00,\n    // pre_defined\n    0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // pre_defined\n    width >> 8 & 0xff, width & 0xff,\n    // width\n    height >> 8 & 0xff, height & 0xff,\n    // height\n    0x00, 0x48, 0x00, 0x00,\n    // horizresolution\n    0x00, 0x48, 0x00, 0x00,\n    // vertresolution\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x01,\n    // frame_count\n    0x12, 0x64, 0x61, 0x69, 0x6c,\n    // dailymotion/hls.js\n    0x79, 0x6d, 0x6f, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x68, 0x6c, 0x73, 0x2e, 0x6a, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // compressorname\n    0x00, 0x18,\n    // depth = 24\n    0x11, 0x11]),\n    // pre_defined = -1\n    avcc, MP4.box(MP4.types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80,\n    // bufferSizeDB\n    0x00, 0x2d, 0xc6, 0xc0,\n    // maxBitrate\n    0x00, 0x2d, 0xc6, 0xc0])),\n    // avgBitrate\n    MP4.box(MP4.types.pasp, new Uint8Array([hSpacing >> 24,\n    // hSpacing\n    hSpacing >> 16 & 0xff, hSpacing >> 8 & 0xff, hSpacing & 0xff, vSpacing >> 24,\n    // vSpacing\n    vSpacing >> 16 & 0xff, vSpacing >> 8 & 0xff, vSpacing & 0xff])));\n  }\n  static esds(track) {\n    const config = track.config;\n    return new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n\n    0x03,\n    // descriptor_type\n    0x19,\n    // length\n\n    0x00, 0x01,\n    // es_id\n\n    0x00,\n    // stream_priority\n\n    0x04,\n    // descriptor_type\n    0x11,\n    // length\n    0x40,\n    // codec : mpeg4_audio\n    0x15,\n    // stream_type\n    0x00, 0x00, 0x00,\n    // buffer_size\n    0x00, 0x00, 0x00, 0x00,\n    // maxBitrate\n    0x00, 0x00, 0x00, 0x00,\n    // avgBitrate\n\n    0x05,\n    // descriptor_type\n    0x02,\n    // length\n    ...config, 0x06, 0x01, 0x02 // GASpecificConfig)); // length + audio config descriptor\n    ]);\n  }\n  static audioStsd(track) {\n    const samplerate = track.samplerate || 0;\n    return new Uint8Array([0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x01,\n    // data_reference_index\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, track.channelCount || 0,\n    // channelcount\n    0x00, 0x10,\n    // sampleSize:16bits\n    0x00, 0x00, 0x00, 0x00,\n    // reserved2\n    samplerate >> 8 & 0xff, samplerate & 0xff,\n    //\n    0x00, 0x00]);\n  }\n  static mp4a(track) {\n    return MP4.box(MP4.types.mp4a, MP4.audioStsd(track), MP4.box(MP4.types.esds, MP4.esds(track)));\n  }\n  static mp3(track) {\n    return MP4.box(MP4.types['.mp3'], MP4.audioStsd(track));\n  }\n  static ac3(track) {\n    return MP4.box(MP4.types['ac-3'], MP4.audioStsd(track), MP4.box(MP4.types.dac3, track.config));\n  }\n  static stsd(track) {\n    const {\n      segmentCodec\n    } = track;\n    if (track.type === 'audio') {\n      if (segmentCodec === 'aac') {\n        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));\n      }\n      if (segmentCodec === 'ac3' && track.config) {\n        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.ac3(track));\n      }\n      if (segmentCodec === 'mp3' && track.codec === 'mp3') {\n        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));\n      }\n    } else {\n      if (track.pps && track.sps) {\n        if (segmentCodec === 'avc') {\n          return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));\n        }\n        if (segmentCodec === 'hevc' && track.vps) {\n          return MP4.box(MP4.types.stsd, MP4.STSD, MP4.hvc1(track));\n        }\n      } else {\n        throw new Error(`video track missing pps or sps`);\n      }\n    }\n    throw new Error(`unsupported ${track.type} segment codec (${segmentCodec}/${track.codec})`);\n  }\n  static tkhd(track) {\n    const id = track.id;\n    const duration = (track.duration || 0) * (track.timescale || 0);\n    const width = track.width || 0;\n    const height = track.height || 0;\n    const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n    const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n    return MP4.box(MP4.types.tkhd, new Uint8Array([0x01,\n    // version 1\n    0x00, 0x00, 0x07,\n    // flags\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,\n    // creation_time\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,\n    // modification_time\n    id >> 24 & 0xff, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff,\n    // track_ID\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00,\n    // layer\n    0x00, 0x00,\n    // alternate_group\n    0x00, 0x00,\n    // non-audio track volume\n    0x00, 0x00,\n    // reserved\n    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,\n    // transformation: unity matrix\n    width >> 8 & 0xff, width & 0xff, 0x00, 0x00,\n    // width\n    height >> 8 & 0xff, height & 0xff, 0x00, 0x00 // height\n    ]));\n  }\n  static traf(track, baseMediaDecodeTime) {\n    const sampleDependencyTable = MP4.sdtp(track);\n    const id = track.id;\n    const upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));\n    const lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));\n    return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    id >> 24, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff // track_ID\n    ])), MP4.box(MP4.types.tfdt, new Uint8Array([0x01,\n    // version 1\n    0x00, 0x00, 0x00,\n    // flags\n    upperWordBaseMediaDecodeTime >> 24, upperWordBaseMediaDecodeTime >> 16 & 0xff, upperWordBaseMediaDecodeTime >> 8 & 0xff, upperWordBaseMediaDecodeTime & 0xff, lowerWordBaseMediaDecodeTime >> 24, lowerWordBaseMediaDecodeTime >> 16 & 0xff, lowerWordBaseMediaDecodeTime >> 8 & 0xff, lowerWordBaseMediaDecodeTime & 0xff])), MP4.trun(track, sampleDependencyTable.length + 16 +\n    // tfhd\n    20 +\n    // tfdt\n    8 +\n    // traf header\n    16 +\n    // mfhd\n    8 +\n    // moof header\n    8),\n    // mdat header\n    sampleDependencyTable);\n  }\n\n  /**\n   * Generate a track box.\n   * @param track a track definition\n   */\n  static trak(track) {\n    track.duration = track.duration || 0xffffffff;\n    return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));\n  }\n  static trex(track) {\n    const id = track.id;\n    return MP4.box(MP4.types.trex, new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    id >> 24, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff,\n    // track_ID\n    0x00, 0x00, 0x00, 0x01,\n    // default_sample_description_index\n    0x00, 0x00, 0x00, 0x00,\n    // default_sample_duration\n    0x00, 0x00, 0x00, 0x00,\n    // default_sample_size\n    0x00, 0x01, 0x00, 0x01 // default_sample_flags\n    ]));\n  }\n  static trun(track, offset) {\n    const samples = track.samples || [];\n    const len = samples.length;\n    const arraylen = 12 + 16 * len;\n    const array = new Uint8Array(arraylen);\n    let i;\n    let sample;\n    let duration;\n    let size;\n    let flags;\n    let cts;\n    offset += 8 + arraylen;\n    array.set([track.type === 'video' ? 0x01 : 0x00,\n    // version 1 for video with signed-int sample_composition_time_offset\n    0x00, 0x0f, 0x01,\n    // flags\n    len >>> 24 & 0xff, len >>> 16 & 0xff, len >>> 8 & 0xff, len & 0xff,\n    // sample_count\n    offset >>> 24 & 0xff, offset >>> 16 & 0xff, offset >>> 8 & 0xff, offset & 0xff // data_offset\n    ], 0);\n    for (i = 0; i < len; i++) {\n      sample = samples[i];\n      duration = sample.duration;\n      size = sample.size;\n      flags = sample.flags;\n      cts = sample.cts;\n      array.set([duration >>> 24 & 0xff, duration >>> 16 & 0xff, duration >>> 8 & 0xff, duration & 0xff,\n      // sample_duration\n      size >>> 24 & 0xff, size >>> 16 & 0xff, size >>> 8 & 0xff, size & 0xff,\n      // sample_size\n      flags.isLeading << 2 | flags.dependsOn, flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync, flags.degradPrio & 0xf0 << 8, flags.degradPrio & 0x0f,\n      // sample_flags\n      cts >>> 24 & 0xff, cts >>> 16 & 0xff, cts >>> 8 & 0xff, cts & 0xff // sample_composition_time_offset\n      ], 12 + 16 * i);\n    }\n    return MP4.box(MP4.types.trun, array);\n  }\n  static initSegment(tracks) {\n    if (!MP4.types) {\n      MP4.init();\n    }\n    const movie = MP4.moov(tracks);\n    const result = appendUint8Array(MP4.FTYP, movie);\n    return result;\n  }\n  static hvc1(track) {\n    const ps = track.params;\n    const units = [track.vps, track.sps, track.pps];\n    const NALuLengthSize = 4;\n    const config = new Uint8Array([0x01, ps.general_profile_space << 6 | (ps.general_tier_flag ? 32 : 0) | ps.general_profile_idc, ps.general_profile_compatibility_flags[0], ps.general_profile_compatibility_flags[1], ps.general_profile_compatibility_flags[2], ps.general_profile_compatibility_flags[3], ps.general_constraint_indicator_flags[0], ps.general_constraint_indicator_flags[1], ps.general_constraint_indicator_flags[2], ps.general_constraint_indicator_flags[3], ps.general_constraint_indicator_flags[4], ps.general_constraint_indicator_flags[5], ps.general_level_idc, 240 | ps.min_spatial_segmentation_idc >> 8, 255 & ps.min_spatial_segmentation_idc, 252 | ps.parallelismType, 252 | ps.chroma_format_idc, 248 | ps.bit_depth_luma_minus8, 248 | ps.bit_depth_chroma_minus8, 0x00, parseInt(ps.frame_rate.fps), NALuLengthSize - 1 | ps.temporal_id_nested << 2 | ps.num_temporal_layers << 3 | (ps.frame_rate.fixed ? 64 : 0), units.length]);\n\n    // compute hvcC size in bytes\n    let length = config.length;\n    for (let i = 0; i < units.length; i += 1) {\n      length += 3;\n      for (let j = 0; j < units[i].length; j += 1) {\n        length += 2 + units[i][j].length;\n      }\n    }\n    const hvcC = new Uint8Array(length);\n    hvcC.set(config, 0);\n    length = config.length;\n    // append parameter set units: one vps, one or more sps and pps\n    const iMax = units.length - 1;\n    for (let i = 0; i < units.length; i += 1) {\n      hvcC.set(new Uint8Array([32 + i | (i === iMax ? 128 : 0), 0x00, units[i].length]), length);\n      length += 3;\n      for (let j = 0; j < units[i].length; j += 1) {\n        hvcC.set(new Uint8Array([units[i][j].length >> 8, units[i][j].length & 255]), length);\n        length += 2;\n        hvcC.set(units[i][j], length);\n        length += units[i][j].length;\n      }\n    }\n    const hvcc = MP4.box(MP4.types.hvcC, hvcC);\n    const width = track.width;\n    const height = track.height;\n    const hSpacing = track.pixelRatio[0];\n    const vSpacing = track.pixelRatio[1];\n    return MP4.box(MP4.types.hvc1, new Uint8Array([0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x01,\n    // data_reference_index\n    0x00, 0x00,\n    // pre_defined\n    0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // pre_defined\n    width >> 8 & 0xff, width & 0xff,\n    // width\n    height >> 8 & 0xff, height & 0xff,\n    // height\n    0x00, 0x48, 0x00, 0x00,\n    // horizresolution\n    0x00, 0x48, 0x00, 0x00,\n    // vertresolution\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x01,\n    // frame_count\n    0x12, 0x64, 0x61, 0x69, 0x6c,\n    // dailymotion/hls.js\n    0x79, 0x6d, 0x6f, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x68, 0x6c, 0x73, 0x2e, 0x6a, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // compressorname\n    0x00, 0x18,\n    // depth = 24\n    0x11, 0x11]),\n    // pre_defined = -1\n    hvcc, MP4.box(MP4.types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80,\n    // bufferSizeDB\n    0x00, 0x2d, 0xc6, 0xc0,\n    // maxBitrate\n    0x00, 0x2d, 0xc6, 0xc0])),\n    // avgBitrate\n    MP4.box(MP4.types.pasp, new Uint8Array([hSpacing >> 24,\n    // hSpacing\n    hSpacing >> 16 & 0xff, hSpacing >> 8 & 0xff, hSpacing & 0xff, vSpacing >> 24,\n    // vSpacing\n    vSpacing >> 16 & 0xff, vSpacing >> 8 & 0xff, vSpacing & 0xff])));\n  }\n}\nMP4.types = void 0;\nMP4.HDLR_TYPES = void 0;\nMP4.STTS = void 0;\nMP4.STSC = void 0;\nMP4.STCO = void 0;\nMP4.STSZ = void 0;\nMP4.VMHD = void 0;\nMP4.SMHD = void 0;\nMP4.STSD = void 0;\nMP4.FTYP = void 0;\nMP4.DINF = void 0;\n\nconst MPEG_TS_CLOCK_FREQ_HZ = 90000;\nfunction toTimescaleFromBase(baseTime, destScale, srcBase = 1, round = false) {\n  const result = baseTime * destScale * srcBase; // equivalent to `(value * scale) / (1 / base)`\n  return round ? Math.round(result) : result;\n}\nfunction toTimescaleFromScale(baseTime, destScale, srcScale = 1, round = false) {\n  return toTimescaleFromBase(baseTime, destScale, 1 / srcScale, round);\n}\nfunction toMsFromMpegTsClock(baseTime, round = false) {\n  return toTimescaleFromBase(baseTime, 1000, 1 / MPEG_TS_CLOCK_FREQ_HZ, round);\n}\nfunction toMpegTsClockFromTimescale(baseTime, srcScale = 1) {\n  return toTimescaleFromBase(baseTime, MPEG_TS_CLOCK_FREQ_HZ, 1 / srcScale);\n}\n\nconst MAX_SILENT_FRAME_DURATION = 10 * 1000; // 10 seconds\nconst AAC_SAMPLES_PER_FRAME = 1024;\nconst MPEG_AUDIO_SAMPLE_PER_FRAME = 1152;\nconst AC3_SAMPLES_PER_FRAME = 1536;\nlet chromeVersion = null;\nlet safariWebkitVersion = null;\nfunction createMp4Sample(isKeyframe, duration, size, cts) {\n  return {\n    duration,\n    size,\n    cts,\n    flags: {\n      isLeading: 0,\n      isDependedOn: 0,\n      hasRedundancy: 0,\n      degradPrio: 0,\n      dependsOn: isKeyframe ? 2 : 1,\n      isNonSync: isKeyframe ? 0 : 1\n    }\n  };\n}\nclass MP4Remuxer extends Logger {\n  constructor(observer, config, typeSupported, logger) {\n    super('mp4-remuxer', logger);\n    this.observer = void 0;\n    this.config = void 0;\n    this.typeSupported = void 0;\n    this.ISGenerated = false;\n    this._initPTS = null;\n    this._initDTS = null;\n    this.nextVideoTs = null;\n    this.nextAudioTs = null;\n    this.videoSampleDuration = null;\n    this.isAudioContiguous = false;\n    this.isVideoContiguous = false;\n    this.videoTrackConfig = void 0;\n    this.observer = observer;\n    this.config = config;\n    this.typeSupported = typeSupported;\n    this.ISGenerated = false;\n    if (chromeVersion === null) {\n      const userAgent = navigator.userAgent || '';\n      const result = userAgent.match(/Chrome\\/(\\d+)/i);\n      chromeVersion = result ? parseInt(result[1]) : 0;\n    }\n    if (safariWebkitVersion === null) {\n      const result = navigator.userAgent.match(/Safari\\/(\\d+)/i);\n      safariWebkitVersion = result ? parseInt(result[1]) : 0;\n    }\n  }\n  destroy() {\n    // @ts-ignore\n    this.config = this.videoTrackConfig = this._initPTS = this._initDTS = null;\n  }\n  resetTimeStamp(defaultTimeStamp) {\n    this.log('initPTS & initDTS reset');\n    this._initPTS = this._initDTS = defaultTimeStamp;\n  }\n  resetNextTimestamp() {\n    this.log('reset next timestamp');\n    this.isVideoContiguous = false;\n    this.isAudioContiguous = false;\n  }\n  resetInitSegment() {\n    this.log('ISGenerated flag reset');\n    this.ISGenerated = false;\n    this.videoTrackConfig = undefined;\n  }\n  getVideoStartPts(videoSamples) {\n    // Get the minimum PTS value relative to the first sample's PTS, normalized for 33-bit wrapping\n    let rolloverDetected = false;\n    const firstPts = videoSamples[0].pts;\n    const startPTS = videoSamples.reduce((minPTS, sample) => {\n      let pts = sample.pts;\n      let delta = pts - minPTS;\n      if (delta < -4294967296) {\n        // 2^32, see PTSNormalize for reasoning, but we're hitting a rollover here, and we don't want that to impact the timeOffset calculation\n        rolloverDetected = true;\n        pts = normalizePts(pts, firstPts);\n        delta = pts - minPTS;\n      }\n      if (delta > 0) {\n        return minPTS;\n      }\n      return pts;\n    }, firstPts);\n    if (rolloverDetected) {\n      this.debug('PTS rollover detected');\n    }\n    return startPTS;\n  }\n  remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, flush, playlistType) {\n    let video;\n    let audio;\n    let initSegment;\n    let text;\n    let id3;\n    let independent;\n    let audioTimeOffset = timeOffset;\n    let videoTimeOffset = timeOffset;\n\n    // If we're remuxing audio and video progressively, wait until we've received enough samples for each track before proceeding.\n    // This is done to synchronize the audio and video streams. We know if the current segment will have samples if the \"pid\"\n    // parameter is greater than -1. The pid is set when the PMT is parsed, which contains the tracks list.\n    // However, if the initSegment has already been generated, or we've reached the end of a segment (flush),\n    // then we can remux one track without waiting for the other.\n    const hasAudio = audioTrack.pid > -1;\n    const hasVideo = videoTrack.pid > -1;\n    const length = videoTrack.samples.length;\n    const enoughAudioSamples = audioTrack.samples.length > 0;\n    const enoughVideoSamples = flush && length > 0 || length > 1;\n    const canRemuxAvc = (!hasAudio || enoughAudioSamples) && (!hasVideo || enoughVideoSamples) || this.ISGenerated || flush;\n    if (canRemuxAvc) {\n      if (this.ISGenerated) {\n        var _videoTrack$pixelRati, _config$pixelRatio, _videoTrack$pixelRati2, _config$pixelRatio2;\n        const config = this.videoTrackConfig;\n        if (config && (videoTrack.width !== config.width || videoTrack.height !== config.height || ((_videoTrack$pixelRati = videoTrack.pixelRatio) == null ? void 0 : _videoTrack$pixelRati[0]) !== ((_config$pixelRatio = config.pixelRatio) == null ? void 0 : _config$pixelRatio[0]) || ((_videoTrack$pixelRati2 = videoTrack.pixelRatio) == null ? void 0 : _videoTrack$pixelRati2[1]) !== ((_config$pixelRatio2 = config.pixelRatio) == null ? void 0 : _config$pixelRatio2[1])) || !config && enoughVideoSamples || this.nextAudioTs === null && enoughAudioSamples) {\n          this.resetInitSegment();\n        }\n      }\n      if (!this.ISGenerated) {\n        initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);\n      }\n      const isVideoContiguous = this.isVideoContiguous;\n      let firstKeyFrameIndex = -1;\n      let firstKeyFramePTS;\n      if (enoughVideoSamples) {\n        firstKeyFrameIndex = findKeyframeIndex(videoTrack.samples);\n        if (!isVideoContiguous && this.config.forceKeyFrameOnDiscontinuity) {\n          independent = true;\n          if (firstKeyFrameIndex > 0) {\n            this.warn(`Dropped ${firstKeyFrameIndex} out of ${length} video samples due to a missing keyframe`);\n            const startPTS = this.getVideoStartPts(videoTrack.samples);\n            videoTrack.samples = videoTrack.samples.slice(firstKeyFrameIndex);\n            videoTrack.dropped += firstKeyFrameIndex;\n            videoTimeOffset += (videoTrack.samples[0].pts - startPTS) / videoTrack.inputTimeScale;\n            firstKeyFramePTS = videoTimeOffset;\n          } else if (firstKeyFrameIndex === -1) {\n            this.warn(`No keyframe found out of ${length} video samples`);\n            independent = false;\n          }\n        }\n      }\n      if (this.ISGenerated) {\n        if (enoughAudioSamples && enoughVideoSamples) {\n          // timeOffset is expected to be the offset of the first timestamp of this fragment (first DTS)\n          // if first audio DTS is not aligned with first video DTS then we need to take that into account\n          // when providing timeOffset to remuxAudio / remuxVideo. if we don't do that, there might be a permanent / small\n          // drift between audio and video streams\n          const startPTS = this.getVideoStartPts(videoTrack.samples);\n          const tsDelta = normalizePts(audioTrack.samples[0].pts, startPTS) - startPTS;\n          const audiovideoTimestampDelta = tsDelta / videoTrack.inputTimeScale;\n          audioTimeOffset += Math.max(0, audiovideoTimestampDelta);\n          videoTimeOffset += Math.max(0, -audiovideoTimestampDelta);\n        }\n\n        // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is calculated in remuxAudio.\n        if (enoughAudioSamples) {\n          // if initSegment was generated without audio samples, regenerate it again\n          if (!audioTrack.samplerate) {\n            this.warn('regenerate InitSegment as audio detected');\n            initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);\n          }\n          audio = this.remuxAudio(audioTrack, audioTimeOffset, this.isAudioContiguous, accurateTimeOffset, hasVideo || enoughVideoSamples || playlistType === PlaylistLevelType.AUDIO ? videoTimeOffset : undefined);\n          if (enoughVideoSamples) {\n            const audioTrackLength = audio ? audio.endPTS - audio.startPTS : 0;\n            // if initSegment was generated without video samples, regenerate it again\n            if (!videoTrack.inputTimeScale) {\n              this.warn('regenerate InitSegment as video detected');\n              initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);\n            }\n            video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, audioTrackLength);\n          }\n        } else if (enoughVideoSamples) {\n          video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, 0);\n        }\n        if (video) {\n          video.firstKeyFrame = firstKeyFrameIndex;\n          video.independent = firstKeyFrameIndex !== -1;\n          video.firstKeyFramePTS = firstKeyFramePTS;\n        }\n      }\n    }\n\n    // Allow ID3 and text to remux, even if more audio/video samples are required\n    if (this.ISGenerated && this._initPTS && this._initDTS) {\n      if (id3Track.samples.length) {\n        id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, this._initPTS, this._initDTS);\n      }\n      if (textTrack.samples.length) {\n        text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, this._initPTS);\n      }\n    }\n    return {\n      audio,\n      video,\n      initSegment,\n      independent,\n      text,\n      id3\n    };\n  }\n  generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset) {\n    const audioSamples = audioTrack.samples;\n    const videoSamples = videoTrack.samples;\n    const typeSupported = this.typeSupported;\n    const tracks = {};\n    const _initPTS = this._initPTS;\n    let computePTSDTS = !_initPTS || accurateTimeOffset;\n    let container = 'audio/mp4';\n    let initPTS;\n    let initDTS;\n    let timescale;\n    let trackId;\n    if (computePTSDTS) {\n      initPTS = initDTS = Infinity;\n    }\n    if (audioTrack.config && audioSamples.length) {\n      // let's use audio sampling rate as MP4 time scale.\n      // rationale is that there is a integer nb of audio frames per audio sample (1024 for AAC)\n      // using audio sampling rate here helps having an integer MP4 frame duration\n      // this avoids potential rounding issue and AV sync issue\n      audioTrack.timescale = audioTrack.samplerate;\n      switch (audioTrack.segmentCodec) {\n        case 'mp3':\n          if (typeSupported.mpeg) {\n            // Chrome and Safari\n            container = 'audio/mpeg';\n            audioTrack.codec = '';\n          } else if (typeSupported.mp3) {\n            // Firefox\n            audioTrack.codec = 'mp3';\n          }\n          break;\n        case 'ac3':\n          audioTrack.codec = 'ac-3';\n          break;\n      }\n      tracks.audio = {\n        id: 'audio',\n        container: container,\n        codec: audioTrack.codec,\n        initSegment: audioTrack.segmentCodec === 'mp3' && typeSupported.mpeg ? new Uint8Array(0) : MP4.initSegment([audioTrack]),\n        metadata: {\n          channelCount: audioTrack.channelCount\n        }\n      };\n      if (computePTSDTS) {\n        trackId = audioTrack.id;\n        timescale = audioTrack.inputTimeScale;\n        if (!_initPTS || timescale !== _initPTS.timescale) {\n          // remember first PTS of this demuxing context. for audio, PTS = DTS\n          initPTS = initDTS = audioSamples[0].pts - Math.round(timescale * timeOffset);\n        } else {\n          computePTSDTS = false;\n        }\n      }\n    }\n    if (videoTrack.sps && videoTrack.pps && videoSamples.length) {\n      // let's use input time scale as MP4 video timescale\n      // we use input time scale straight away to avoid rounding issues on frame duration / cts computation\n      videoTrack.timescale = videoTrack.inputTimeScale;\n      tracks.video = {\n        id: 'main',\n        container: 'video/mp4',\n        codec: videoTrack.codec,\n        initSegment: MP4.initSegment([videoTrack]),\n        metadata: {\n          width: videoTrack.width,\n          height: videoTrack.height\n        }\n      };\n      if (computePTSDTS) {\n        trackId = videoTrack.id;\n        timescale = videoTrack.inputTimeScale;\n        if (!_initPTS || timescale !== _initPTS.timescale) {\n          const startPTS = this.getVideoStartPts(videoSamples);\n          const startOffset = Math.round(timescale * timeOffset);\n          initDTS = Math.min(initDTS, normalizePts(videoSamples[0].dts, startPTS) - startOffset);\n          initPTS = Math.min(initPTS, startPTS - startOffset);\n        } else {\n          computePTSDTS = false;\n        }\n      }\n      this.videoTrackConfig = {\n        width: videoTrack.width,\n        height: videoTrack.height,\n        pixelRatio: videoTrack.pixelRatio\n      };\n    }\n    if (Object.keys(tracks).length) {\n      this.ISGenerated = true;\n      if (computePTSDTS) {\n        this._initPTS = {\n          baseTime: initPTS,\n          timescale: timescale\n        };\n        this._initDTS = {\n          baseTime: initDTS,\n          timescale: timescale\n        };\n      } else {\n        initPTS = timescale = undefined;\n      }\n      return {\n        tracks,\n        initPTS,\n        timescale,\n        trackId\n      };\n    }\n  }\n  remuxVideo(track, timeOffset, contiguous, audioTrackLength) {\n    const timeScale = track.inputTimeScale;\n    const inputSamples = track.samples;\n    const outputSamples = [];\n    const nbSamples = inputSamples.length;\n    const initPTS = this._initPTS;\n    const initTime = initPTS.baseTime * timeScale / initPTS.timescale;\n    let nextVideoTs = this.nextVideoTs;\n    let offset = 8;\n    let mp4SampleDuration = this.videoSampleDuration;\n    let firstDTS;\n    let lastDTS;\n    let minPTS = Number.POSITIVE_INFINITY;\n    let maxPTS = Number.NEGATIVE_INFINITY;\n    let sortSamples = false;\n\n    // if parsed fragment is contiguous with last one, let's use last DTS value as reference\n    if (!contiguous || nextVideoTs === null) {\n      const pts = initTime + timeOffset * timeScale;\n      const cts = inputSamples[0].pts - normalizePts(inputSamples[0].dts, inputSamples[0].pts);\n      if (chromeVersion && nextVideoTs !== null && Math.abs(pts - cts - (nextVideoTs + initTime)) < 15000) {\n        // treat as contigous to adjust samples that would otherwise produce video buffer gaps in Chrome\n        contiguous = true;\n      } else {\n        // if not contiguous, let's use target timeOffset\n        nextVideoTs = pts - cts - initTime;\n      }\n    }\n\n    // PTS is coded on 33bits, and can loop from -2^32 to 2^32\n    // PTSNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value\n    const nextVideoPts = nextVideoTs + initTime;\n    for (let i = 0; i < nbSamples; i++) {\n      const sample = inputSamples[i];\n      sample.pts = normalizePts(sample.pts, nextVideoPts);\n      sample.dts = normalizePts(sample.dts, nextVideoPts);\n      if (sample.dts < inputSamples[i > 0 ? i - 1 : i].dts) {\n        sortSamples = true;\n      }\n    }\n\n    // sort video samples by DTS then PTS then demux id order\n    if (sortSamples) {\n      inputSamples.sort(function (a, b) {\n        const deltadts = a.dts - b.dts;\n        const deltapts = a.pts - b.pts;\n        return deltadts || deltapts;\n      });\n    }\n\n    // Get first/last DTS\n    firstDTS = inputSamples[0].dts;\n    lastDTS = inputSamples[inputSamples.length - 1].dts;\n\n    // Sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS\n    // set this constant duration as being the avg delta between consecutive DTS.\n    const inputDuration = lastDTS - firstDTS;\n    const averageSampleDuration = inputDuration ? Math.round(inputDuration / (nbSamples - 1)) : mp4SampleDuration || track.inputTimeScale / 30;\n\n    // if fragment are contiguous, detect hole/overlapping between fragments\n    if (contiguous) {\n      // check timestamp continuity across consecutive fragments (this is to remove inter-fragment gap/hole)\n      const delta = firstDTS - nextVideoPts;\n      const foundHole = delta > averageSampleDuration;\n      const foundOverlap = delta < -1;\n      if (foundHole || foundOverlap) {\n        if (foundHole) {\n          this.warn(`${(track.segmentCodec || '').toUpperCase()}: ${toMsFromMpegTsClock(delta, true)} ms (${delta}dts) hole between fragments detected at ${timeOffset.toFixed(3)}`);\n        } else {\n          this.warn(`${(track.segmentCodec || '').toUpperCase()}: ${toMsFromMpegTsClock(-delta, true)} ms (${delta}dts) overlapping between fragments detected at ${timeOffset.toFixed(3)}`);\n        }\n        if (!foundOverlap || nextVideoPts >= inputSamples[0].pts || chromeVersion) {\n          firstDTS = nextVideoPts;\n          const firstPTS = inputSamples[0].pts - delta;\n          if (foundHole) {\n            inputSamples[0].dts = firstDTS;\n            inputSamples[0].pts = firstPTS;\n          } else {\n            let isPTSOrderRetained = true;\n            for (let i = 0; i < inputSamples.length; i++) {\n              if (inputSamples[i].dts > firstPTS && isPTSOrderRetained) {\n                break;\n              }\n              const prevPTS = inputSamples[i].pts;\n              inputSamples[i].dts -= delta;\n              inputSamples[i].pts -= delta;\n\n              // check to see if this sample's PTS order has changed\n              // relative to the next one\n              if (i < inputSamples.length - 1) {\n                const nextSamplePTS = inputSamples[i + 1].pts;\n                const currentSamplePTS = inputSamples[i].pts;\n                const currentOrder = nextSamplePTS <= currentSamplePTS;\n                const prevOrder = nextSamplePTS <= prevPTS;\n                isPTSOrderRetained = currentOrder == prevOrder;\n              }\n            }\n          }\n          this.log(`Video: Initial PTS/DTS adjusted: ${toMsFromMpegTsClock(firstPTS, true)}/${toMsFromMpegTsClock(firstDTS, true)}, delta: ${toMsFromMpegTsClock(delta, true)} ms`);\n        }\n      }\n    }\n    firstDTS = Math.max(0, firstDTS);\n    let nbNalu = 0;\n    let naluLen = 0;\n    let dtsStep = firstDTS;\n    for (let i = 0; i < nbSamples; i++) {\n      // compute total/avc sample length and nb of NAL units\n      const sample = inputSamples[i];\n      const units = sample.units;\n      const nbUnits = units.length;\n      let sampleLen = 0;\n      for (let j = 0; j < nbUnits; j++) {\n        sampleLen += units[j].data.length;\n      }\n      naluLen += sampleLen;\n      nbNalu += nbUnits;\n      sample.length = sampleLen;\n\n      // ensure sample monotonic DTS\n      if (sample.dts < dtsStep) {\n        sample.dts = dtsStep;\n        dtsStep += averageSampleDuration / 4 | 0 || 1;\n      } else {\n        dtsStep = sample.dts;\n      }\n      minPTS = Math.min(sample.pts, minPTS);\n      maxPTS = Math.max(sample.pts, maxPTS);\n    }\n    lastDTS = inputSamples[nbSamples - 1].dts;\n\n    /* concatenate the video data and construct the mdat in place\n      (need 8 more bytes to fill length and mpdat type) */\n    const mdatSize = naluLen + 4 * nbNalu + 8;\n    let mdat;\n    try {\n      mdat = new Uint8Array(mdatSize);\n    } catch (err) {\n      this.observer.emit(Events.ERROR, Events.ERROR, {\n        type: ErrorTypes.MUX_ERROR,\n        details: ErrorDetails.REMUX_ALLOC_ERROR,\n        fatal: false,\n        error: err,\n        bytes: mdatSize,\n        reason: `fail allocating video mdat ${mdatSize}`\n      });\n      return;\n    }\n    const view = new DataView(mdat.buffer);\n    view.setUint32(0, mdatSize);\n    mdat.set(MP4.types.mdat, 4);\n    let stretchedLastFrame = false;\n    let minDtsDelta = Number.POSITIVE_INFINITY;\n    let minPtsDelta = Number.POSITIVE_INFINITY;\n    let maxDtsDelta = Number.NEGATIVE_INFINITY;\n    let maxPtsDelta = Number.NEGATIVE_INFINITY;\n    for (let i = 0; i < nbSamples; i++) {\n      const VideoSample = inputSamples[i];\n      const VideoSampleUnits = VideoSample.units;\n      let mp4SampleLength = 0;\n      // convert NALU bitstream to MP4 format (prepend NALU with size field)\n      for (let j = 0, nbUnits = VideoSampleUnits.length; j < nbUnits; j++) {\n        const unit = VideoSampleUnits[j];\n        const unitData = unit.data;\n        const unitDataLen = unit.data.byteLength;\n        view.setUint32(offset, unitDataLen);\n        offset += 4;\n        mdat.set(unitData, offset);\n        offset += unitDataLen;\n        mp4SampleLength += 4 + unitDataLen;\n      }\n\n      // expected sample duration is the Decoding Timestamp diff of consecutive samples\n      let ptsDelta;\n      if (i < nbSamples - 1) {\n        mp4SampleDuration = inputSamples[i + 1].dts - VideoSample.dts;\n        ptsDelta = inputSamples[i + 1].pts - VideoSample.pts;\n      } else {\n        const config = this.config;\n        const lastFrameDuration = i > 0 ? VideoSample.dts - inputSamples[i - 1].dts : averageSampleDuration;\n        ptsDelta = i > 0 ? VideoSample.pts - inputSamples[i - 1].pts : averageSampleDuration;\n        if (config.stretchShortVideoTrack && this.nextAudioTs !== null) {\n          // In some cases, a segment's audio track duration may exceed the video track duration.\n          // Since we've already remuxed audio, and we know how long the audio track is, we look to\n          // see if the delta to the next segment is longer than maxBufferHole.\n          // If so, playback would potentially get stuck, so we artificially inflate\n          // the duration of the last frame to minimize any potential gap between segments.\n          const gapTolerance = Math.floor(config.maxBufferHole * timeScale);\n          const deltaToFrameEnd = (audioTrackLength ? minPTS + audioTrackLength * timeScale : this.nextAudioTs + initTime) - VideoSample.pts;\n          if (deltaToFrameEnd > gapTolerance) {\n            // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video\n            // frame overlap. maxBufferHole should be >> lastFrameDuration anyway.\n            mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;\n            if (mp4SampleDuration < 0) {\n              mp4SampleDuration = lastFrameDuration;\n            } else {\n              stretchedLastFrame = true;\n            }\n            this.log(`It is approximately ${deltaToFrameEnd / 90} ms to the next segment; using duration ${mp4SampleDuration / 90} ms for the last video frame.`);\n          } else {\n            mp4SampleDuration = lastFrameDuration;\n          }\n        } else {\n          mp4SampleDuration = lastFrameDuration;\n        }\n      }\n      const compositionTimeOffset = Math.round(VideoSample.pts - VideoSample.dts);\n      minDtsDelta = Math.min(minDtsDelta, mp4SampleDuration);\n      maxDtsDelta = Math.max(maxDtsDelta, mp4SampleDuration);\n      minPtsDelta = Math.min(minPtsDelta, ptsDelta);\n      maxPtsDelta = Math.max(maxPtsDelta, ptsDelta);\n      outputSamples.push(createMp4Sample(VideoSample.key, mp4SampleDuration, mp4SampleLength, compositionTimeOffset));\n    }\n    if (outputSamples.length) {\n      if (chromeVersion) {\n        if (chromeVersion < 70) {\n          // Chrome workaround, mark first sample as being a Random Access Point (keyframe) to avoid sourcebuffer append issue\n          // https://code.google.com/p/chromium/issues/detail?id=229412\n          const flags = outputSamples[0].flags;\n          flags.dependsOn = 2;\n          flags.isNonSync = 0;\n        }\n      } else if (safariWebkitVersion) {\n        // Fix for \"CNN special report, with CC\" in test-streams (Safari browser only)\n        // Ignore DTS when frame durations are irregular. Safari MSE does not handle this leading to gaps.\n        if (maxPtsDelta - minPtsDelta < maxDtsDelta - minDtsDelta && averageSampleDuration / maxDtsDelta < 0.025 && outputSamples[0].cts === 0) {\n          this.warn('Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.');\n          let dts = firstDTS;\n          for (let i = 0, len = outputSamples.length; i < len; i++) {\n            const nextDts = dts + outputSamples[i].duration;\n            const pts = dts + outputSamples[i].cts;\n            if (i < len - 1) {\n              const nextPts = nextDts + outputSamples[i + 1].cts;\n              outputSamples[i].duration = nextPts - pts;\n            } else {\n              outputSamples[i].duration = i ? outputSamples[i - 1].duration : averageSampleDuration;\n            }\n            outputSamples[i].cts = 0;\n            dts = nextDts;\n          }\n        }\n      }\n    }\n    // next AVC/HEVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)\n    mp4SampleDuration = stretchedLastFrame || !mp4SampleDuration ? averageSampleDuration : mp4SampleDuration;\n    const endDTS = lastDTS + mp4SampleDuration;\n    this.nextVideoTs = nextVideoTs = endDTS - initTime;\n    this.videoSampleDuration = mp4SampleDuration;\n    this.isVideoContiguous = true;\n    const moof = MP4.moof(track.sequenceNumber++, firstDTS, _extends(track, {\n      samples: outputSamples\n    }));\n    const type = 'video';\n    const data = {\n      data1: moof,\n      data2: mdat,\n      startPTS: (minPTS - initTime) / timeScale,\n      endPTS: (maxPTS + mp4SampleDuration - initTime) / timeScale,\n      startDTS: (firstDTS - initTime) / timeScale,\n      endDTS: nextVideoTs / timeScale,\n      type,\n      hasAudio: false,\n      hasVideo: true,\n      nb: outputSamples.length,\n      dropped: track.dropped\n    };\n    track.samples = [];\n    track.dropped = 0;\n    return data;\n  }\n  getSamplesPerFrame(track) {\n    switch (track.segmentCodec) {\n      case 'mp3':\n        return MPEG_AUDIO_SAMPLE_PER_FRAME;\n      case 'ac3':\n        return AC3_SAMPLES_PER_FRAME;\n      default:\n        return AAC_SAMPLES_PER_FRAME;\n    }\n  }\n  remuxAudio(track, timeOffset, contiguous, accurateTimeOffset, videoTimeOffset) {\n    const inputTimeScale = track.inputTimeScale;\n    const mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;\n    const scaleFactor = inputTimeScale / mp4timeScale;\n    const mp4SampleDuration = this.getSamplesPerFrame(track);\n    const inputSampleDuration = mp4SampleDuration * scaleFactor;\n    const initPTS = this._initPTS;\n    const rawMPEG = track.segmentCodec === 'mp3' && this.typeSupported.mpeg;\n    const outputSamples = [];\n    const alignedWithVideo = videoTimeOffset !== undefined;\n    let inputSamples = track.samples;\n    let offset = rawMPEG ? 0 : 8;\n    let nextAudioTs = this.nextAudioTs || -1;\n\n    // window.audioSamples ? window.audioSamples.push(inputSamples.map(s => s.pts)) : (window.audioSamples = [inputSamples.map(s => s.pts)]);\n\n    // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),\n    // for sake of clarity:\n    // consecutive fragments are frags with\n    //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR\n    //  - less than 20 audio frames distance\n    // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)\n    // this helps ensuring audio continuity\n    // and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame\n    const initTime = initPTS.baseTime * inputTimeScale / initPTS.timescale;\n    const timeOffsetMpegTS = initTime + timeOffset * inputTimeScale;\n    this.isAudioContiguous = contiguous = contiguous || inputSamples.length && nextAudioTs > 0 && (accurateTimeOffset && Math.abs(timeOffsetMpegTS - (nextAudioTs + initTime)) < 9000 || Math.abs(normalizePts(inputSamples[0].pts, timeOffsetMpegTS) - (nextAudioTs + initTime)) < 20 * inputSampleDuration);\n\n    // compute normalized PTS\n    inputSamples.forEach(function (sample) {\n      sample.pts = normalizePts(sample.pts, timeOffsetMpegTS);\n    });\n    if (!contiguous || nextAudioTs < 0) {\n      // filter out sample with negative PTS that are not playable anyway\n      // if we don't remove these negative samples, they will shift all audio samples forward.\n      // leading to audio overlap between current / next fragment\n      inputSamples = inputSamples.filter(sample => sample.pts >= 0);\n\n      // in case all samples have negative PTS, and have been filtered out, return now\n      if (!inputSamples.length) {\n        return;\n      }\n      if (videoTimeOffset === 0) {\n        // Set the start to match video so that start gaps larger than inputSampleDuration are filled with silence\n        nextAudioTs = 0;\n      } else if (accurateTimeOffset && !alignedWithVideo) {\n        // When not seeking, not live, and LevelDetails.PTSKnown, use fragment start as predicted next audio PTS\n        nextAudioTs = Math.max(0, timeOffsetMpegTS - initTime);\n      } else {\n        // if frags are not contiguous and if we cant trust time offset, let's use first sample PTS as next audio PTS\n        nextAudioTs = inputSamples[0].pts - initTime;\n      }\n    }\n\n    // If the audio track is missing samples, the frames seem to get \"left-shifted\" within the\n    // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.\n    // In an effort to prevent this from happening, we inject frames here where there are gaps.\n    // When possible, we inject a silent frame; when that's not possible, we duplicate the last\n    // frame.\n\n    if (track.segmentCodec === 'aac') {\n      const maxAudioFramesDrift = this.config.maxAudioFramesDrift;\n      for (let i = 0, nextPts = nextAudioTs + initTime; i < inputSamples.length; i++) {\n        // First, let's see how far off this frame is from where we expect it to be\n        const sample = inputSamples[i];\n        const pts = sample.pts;\n        const delta = pts - nextPts;\n        const duration = Math.abs(1000 * delta / inputTimeScale);\n\n        // When remuxing with video, if we're overlapping by more than a duration, drop this sample to stay in sync\n        if (delta <= -maxAudioFramesDrift * inputSampleDuration && alignedWithVideo) {\n          if (i === 0) {\n            this.warn(`Audio frame @ ${(pts / inputTimeScale).toFixed(3)}s overlaps marker by ${Math.round(1000 * delta / inputTimeScale)} ms.`);\n            this.nextAudioTs = nextAudioTs = pts - initTime;\n            nextPts = pts;\n          }\n        } // eslint-disable-line brace-style\n\n        // Insert missing frames if:\n        // 1: We're more than maxAudioFramesDrift frame away\n        // 2: Not more than MAX_SILENT_FRAME_DURATION away\n        // 3: currentTime (aka nextPtsNorm) is not 0\n        // 4: remuxing with video (videoTimeOffset !== undefined)\n        else if (delta >= maxAudioFramesDrift * inputSampleDuration && duration < MAX_SILENT_FRAME_DURATION && alignedWithVideo) {\n          let missing = Math.round(delta / inputSampleDuration);\n          // Adjust nextPts so that silent samples are aligned with media pts. This will prevent media samples from\n          // later being shifted if nextPts is based on timeOffset and delta is not a multiple of inputSampleDuration.\n          nextPts = pts - missing * inputSampleDuration;\n          while (nextPts < 0 && missing && inputSampleDuration) {\n            missing--;\n            nextPts += inputSampleDuration;\n          }\n          if (i === 0) {\n            this.nextAudioTs = nextAudioTs = nextPts - initTime;\n          }\n          this.warn(`Injecting ${missing} audio frames @ ${((nextPts - initTime) / inputTimeScale).toFixed(3)}s due to ${Math.round(1000 * delta / inputTimeScale)} ms gap.`);\n          for (let j = 0; j < missing; j++) {\n            let fillFrame = AAC.getSilentFrame(track.parsedCodec || track.manifestCodec || track.codec, track.channelCount);\n            if (!fillFrame) {\n              this.log('Unable to get silent frame for given audio codec; duplicating last frame instead.');\n              fillFrame = sample.unit.subarray();\n            }\n            inputSamples.splice(i, 0, {\n              unit: fillFrame,\n              pts: nextPts\n            });\n            nextPts += inputSampleDuration;\n            i++;\n          }\n        }\n        sample.pts = nextPts;\n        nextPts += inputSampleDuration;\n      }\n    }\n    let firstPTS = null;\n    let lastPTS = null;\n    let mdat;\n    let mdatSize = 0;\n    let sampleLength = inputSamples.length;\n    while (sampleLength--) {\n      mdatSize += inputSamples[sampleLength].unit.byteLength;\n    }\n    for (let j = 0, _nbSamples = inputSamples.length; j < _nbSamples; j++) {\n      const audioSample = inputSamples[j];\n      const unit = audioSample.unit;\n      let pts = audioSample.pts;\n      if (lastPTS !== null) {\n        // If we have more than one sample, set the duration of the sample to the \"real\" duration; the PTS diff with\n        // the previous sample\n        const prevSample = outputSamples[j - 1];\n        prevSample.duration = Math.round((pts - lastPTS) / scaleFactor);\n      } else {\n        if (contiguous && track.segmentCodec === 'aac') {\n          // set PTS/DTS to expected PTS/DTS\n          pts = nextAudioTs + initTime;\n        }\n        // remember first PTS of our audioSamples\n        firstPTS = pts;\n        if (mdatSize > 0) {\n          /* concatenate the audio data and construct the mdat in place\n            (need 8 more bytes to fill length and mdat type) */\n          mdatSize += offset;\n          try {\n            mdat = new Uint8Array(mdatSize);\n          } catch (err) {\n            this.observer.emit(Events.ERROR, Events.ERROR, {\n              type: ErrorTypes.MUX_ERROR,\n              details: ErrorDetails.REMUX_ALLOC_ERROR,\n              fatal: false,\n              error: err,\n              bytes: mdatSize,\n              reason: `fail allocating audio mdat ${mdatSize}`\n            });\n            return;\n          }\n          if (!rawMPEG) {\n            const view = new DataView(mdat.buffer);\n            view.setUint32(0, mdatSize);\n            mdat.set(MP4.types.mdat, 4);\n          }\n        } else {\n          // no audio samples\n          return;\n        }\n      }\n      mdat.set(unit, offset);\n      const unitLen = unit.byteLength;\n      offset += unitLen;\n      // Default the sample's duration to the computed mp4SampleDuration, which will either be 1024 for AAC or 1152 for MPEG\n      // In the case that we have 1 sample, this will be the duration. If we have more than one sample, the duration\n      // becomes the PTS diff with the previous sample\n      outputSamples.push(createMp4Sample(true, mp4SampleDuration, unitLen, 0));\n      lastPTS = pts;\n    }\n\n    // We could end up with no audio samples if all input samples were overlapping with the previously remuxed ones\n    const nbSamples = outputSamples.length;\n    if (!nbSamples) {\n      return;\n    }\n\n    // The next audio sample PTS should be equal to last sample PTS + duration\n    const lastSample = outputSamples[outputSamples.length - 1];\n    nextAudioTs = lastPTS - initTime;\n    this.nextAudioTs = nextAudioTs + scaleFactor * lastSample.duration;\n\n    // Set the track samples from inputSamples to outputSamples before remuxing\n    const moof = rawMPEG ? new Uint8Array(0) : MP4.moof(track.sequenceNumber++, firstPTS / scaleFactor, _extends({}, track, {\n      samples: outputSamples\n    }));\n\n    // Clear the track samples. This also clears the samples array in the demuxer, since the reference is shared\n    track.samples = [];\n    const start = (firstPTS - initTime) / inputTimeScale;\n    const end = nextAudioTs / inputTimeScale;\n    const type = 'audio';\n    const audioData = {\n      data1: moof,\n      data2: mdat,\n      startPTS: start,\n      endPTS: end,\n      startDTS: start,\n      endDTS: end,\n      type,\n      hasAudio: true,\n      hasVideo: false,\n      nb: nbSamples\n    };\n    this.isAudioContiguous = true;\n    return audioData;\n  }\n}\nfunction normalizePts(value, reference) {\n  let offset;\n  if (reference === null) {\n    return value;\n  }\n  if (reference < value) {\n    // - 2^33\n    offset = -8589934592;\n  } else {\n    // + 2^33\n    offset = 8589934592;\n  }\n  /* PTS is 33bit (from 0 to 2^33 -1)\n    if diff between value and reference is bigger than half of the amplitude (2^32) then it means that\n    PTS looping occured. fill the gap */\n  while (Math.abs(value - reference) > 4294967296) {\n    value += offset;\n  }\n  return value;\n}\nfunction findKeyframeIndex(samples) {\n  for (let i = 0; i < samples.length; i++) {\n    if (samples[i].key) {\n      return i;\n    }\n  }\n  return -1;\n}\nfunction flushTextTrackMetadataCueSamples(track, timeOffset, initPTS, initDTS) {\n  const length = track.samples.length;\n  if (!length) {\n    return;\n  }\n  const inputTimeScale = track.inputTimeScale;\n  for (let index = 0; index < length; index++) {\n    const sample = track.samples[index];\n    // setting id3 pts, dts to relative time\n    // using this._initPTS and this._initDTS to calculate relative time\n    sample.pts = normalizePts(sample.pts - initPTS.baseTime * inputTimeScale / initPTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;\n    sample.dts = normalizePts(sample.dts - initDTS.baseTime * inputTimeScale / initDTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;\n  }\n  const samples = track.samples;\n  track.samples = [];\n  return {\n    samples\n  };\n}\nfunction flushTextTrackUserdataCueSamples(track, timeOffset, initPTS) {\n  const length = track.samples.length;\n  if (!length) {\n    return;\n  }\n  const inputTimeScale = track.inputTimeScale;\n  for (let index = 0; index < length; index++) {\n    const sample = track.samples[index];\n    // setting text pts, dts to relative time\n    // using this._initPTS and this._initDTS to calculate relative time\n    sample.pts = normalizePts(sample.pts - initPTS.baseTime * inputTimeScale / initPTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;\n  }\n  track.samples.sort((a, b) => a.pts - b.pts);\n  const samples = track.samples;\n  track.samples = [];\n  return {\n    samples\n  };\n}\n\nclass PassThroughRemuxer extends Logger {\n  constructor(observer, config, typeSupported, logger) {\n    super('passthrough-remuxer', logger);\n    this.emitInitSegment = false;\n    this.audioCodec = void 0;\n    this.videoCodec = void 0;\n    this.initData = void 0;\n    this.initPTS = null;\n    this.initTracks = void 0;\n    this.lastEndTime = null;\n    this.isVideoContiguous = false;\n  }\n  destroy() {}\n  resetTimeStamp(defaultInitPTS) {\n    this.lastEndTime = null;\n    const initPTS = this.initPTS;\n    if (initPTS && defaultInitPTS) {\n      if (initPTS.baseTime === defaultInitPTS.baseTime && initPTS.timescale === defaultInitPTS.timescale) {\n        return;\n      }\n    }\n    this.initPTS = defaultInitPTS;\n  }\n  resetNextTimestamp() {\n    this.isVideoContiguous = false;\n    this.lastEndTime = null;\n  }\n  resetInitSegment(initSegment, audioCodec, videoCodec, decryptdata) {\n    this.audioCodec = audioCodec;\n    this.videoCodec = videoCodec;\n    this.generateInitSegment(patchEncyptionData(initSegment, decryptdata));\n    this.emitInitSegment = true;\n  }\n  generateInitSegment(initSegment) {\n    let {\n      audioCodec,\n      videoCodec\n    } = this;\n    if (!(initSegment != null && initSegment.byteLength)) {\n      this.initTracks = undefined;\n      this.initData = undefined;\n      return;\n    }\n    const initData = this.initData = parseInitSegment(initSegment);\n\n    // Get codec from initSegment\n    if (initData.audio) {\n      audioCodec = getParsedTrackCodec(initData.audio, ElementaryStreamTypes.AUDIO, this);\n    }\n    if (initData.video) {\n      videoCodec = getParsedTrackCodec(initData.video, ElementaryStreamTypes.VIDEO, this);\n    }\n    const tracks = {};\n    if (initData.audio && initData.video) {\n      tracks.audiovideo = {\n        container: 'video/mp4',\n        codec: audioCodec + ',' + videoCodec,\n        supplemental: initData.video.supplemental,\n        initSegment,\n        id: 'main'\n      };\n    } else if (initData.audio) {\n      tracks.audio = {\n        container: 'audio/mp4',\n        codec: audioCodec,\n        initSegment,\n        id: 'audio'\n      };\n    } else if (initData.video) {\n      tracks.video = {\n        container: 'video/mp4',\n        codec: videoCodec,\n        supplemental: initData.video.supplemental,\n        initSegment,\n        id: 'main'\n      };\n    } else {\n      this.warn('initSegment does not contain moov or trak boxes.');\n    }\n    this.initTracks = tracks;\n  }\n  remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset) {\n    var _initData, _initData2;\n    let {\n      initPTS,\n      lastEndTime\n    } = this;\n    const result = {\n      audio: undefined,\n      video: undefined,\n      text: textTrack,\n      id3: id3Track,\n      initSegment: undefined\n    };\n\n    // If we haven't yet set a lastEndDTS, or it was reset, set it to the provided timeOffset. We want to use the\n    // lastEndDTS over timeOffset whenever possible; during progressive playback, the media source will not update\n    // the media duration (which is what timeOffset is provided as) before we need to process the next chunk.\n    if (!isFiniteNumber(lastEndTime)) {\n      lastEndTime = this.lastEndTime = timeOffset || 0;\n    }\n\n    // The binary segment data is added to the videoTrack in the mp4demuxer. We don't check to see if the data is only\n    // audio or video (or both); adding it to video was an arbitrary choice.\n    const data = videoTrack.samples;\n    if (!(data != null && data.length)) {\n      return result;\n    }\n    const initSegment = {\n      initPTS: undefined,\n      timescale: undefined,\n      trackId: undefined\n    };\n    let initData = this.initData;\n    if (!((_initData = initData) != null && _initData.length)) {\n      this.generateInitSegment(data);\n      initData = this.initData;\n    }\n    if (!((_initData2 = initData) != null && _initData2.length)) {\n      // We can't remux if the initSegment could not be generated\n      this.warn('Failed to generate initSegment.');\n      return result;\n    }\n    if (this.emitInitSegment) {\n      initSegment.tracks = this.initTracks;\n      this.emitInitSegment = false;\n    }\n    const trackSampleData = getSampleData(data, initData, this);\n    const audioSampleTimestamps = initData.audio ? trackSampleData[initData.audio.id] : null;\n    const videoSampleTimestamps = initData.video ? trackSampleData[initData.video.id] : null;\n    const videoStartTime = toStartEndOrDefault(videoSampleTimestamps, Infinity);\n    const audioStartTime = toStartEndOrDefault(audioSampleTimestamps, Infinity);\n    const videoEndTime = toStartEndOrDefault(videoSampleTimestamps, 0, true);\n    const audioEndTime = toStartEndOrDefault(audioSampleTimestamps, 0, true);\n    let baseOffsetSamples;\n    let decodeTime = timeOffset;\n    let duration = 0;\n    if (audioSampleTimestamps && (!videoSampleTimestamps || !initPTS && audioStartTime < videoStartTime || initPTS && initPTS.trackId === initData.audio.id)) {\n      initSegment.trackId = initData.audio.id;\n      baseOffsetSamples = audioSampleTimestamps;\n      duration = audioEndTime - audioStartTime;\n    } else if (videoSampleTimestamps) {\n      initSegment.trackId = initData.video.id;\n      baseOffsetSamples = videoSampleTimestamps;\n      duration = videoEndTime - videoStartTime;\n    }\n    if (baseOffsetSamples) {\n      const timescale = baseOffsetSamples.timescale;\n      decodeTime = baseOffsetSamples.start / timescale;\n      initSegment.initPTS = baseOffsetSamples.start - timeOffset * timescale;\n      initSegment.timescale = timescale;\n      if (!initPTS) {\n        this.initPTS = initPTS = {\n          baseTime: initSegment.initPTS,\n          timescale,\n          trackId: initSegment.trackId\n        };\n      }\n    }\n    if ((accurateTimeOffset || !initPTS) && (isInvalidInitPts(initPTS, decodeTime, timeOffset, duration) || initSegment.timescale !== initPTS.timescale)) {\n      initSegment.initPTS = decodeTime - timeOffset;\n      initSegment.timescale = 1;\n      if (initPTS && initPTS.timescale === 1) {\n        this.warn(`Adjusting initPTS @${timeOffset} from ${initPTS.baseTime / initPTS.timescale} to ${initSegment.initPTS}`);\n      }\n      this.initPTS = initPTS = {\n        baseTime: initSegment.initPTS,\n        timescale: 1\n      };\n    }\n    const startTime = audioTrack ? decodeTime - initPTS.baseTime / initPTS.timescale : lastEndTime;\n    const endTime = startTime + duration;\n    if (duration > 0) {\n      this.lastEndTime = endTime;\n    } else {\n      this.warn('Duration parsed from mp4 should be greater than zero');\n      this.resetNextTimestamp();\n    }\n    const hasAudio = !!initData.audio;\n    const hasVideo = !!initData.video;\n    let type = '';\n    if (hasAudio) {\n      type += 'audio';\n    }\n    if (hasVideo) {\n      type += 'video';\n    }\n    const track = {\n      data1: data,\n      startPTS: startTime,\n      startDTS: startTime,\n      endPTS: endTime,\n      endDTS: endTime,\n      type,\n      hasAudio,\n      hasVideo,\n      nb: 1,\n      dropped: 0\n    };\n    result.audio = hasAudio && !hasVideo ? track : undefined;\n    result.video = hasVideo ? track : undefined;\n    const videoSampleCount = videoSampleTimestamps == null ? void 0 : videoSampleTimestamps.sampleCount;\n    if (videoSampleCount) {\n      const firstKeyFrame = videoSampleTimestamps.keyFrameIndex;\n      const independent = firstKeyFrame !== -1;\n      track.nb = videoSampleCount;\n      track.dropped = firstKeyFrame === 0 || this.isVideoContiguous ? 0 : independent ? firstKeyFrame : videoSampleCount;\n      track.independent = independent;\n      track.firstKeyFrame = firstKeyFrame;\n      if (independent && videoSampleTimestamps.keyFrameStart) {\n        track.firstKeyFramePTS = (videoSampleTimestamps.keyFrameStart - initPTS.baseTime) / initPTS.timescale;\n      }\n      if (!this.isVideoContiguous) {\n        result.independent = independent;\n      }\n      this.isVideoContiguous || (this.isVideoContiguous = independent);\n      if (track.dropped) {\n        this.warn(`fmp4 does not start with IDR: firstIDR ${firstKeyFrame}/${videoSampleCount} dropped: ${track.dropped} start: ${track.firstKeyFramePTS || 'NA'}`);\n      }\n    }\n    result.initSegment = initSegment;\n    result.id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, initPTS, initPTS);\n    if (textTrack.samples.length) {\n      result.text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, initPTS);\n    }\n    return result;\n  }\n}\nfunction toStartEndOrDefault(trackTimes, defaultValue, end = false) {\n  return (trackTimes == null ? void 0 : trackTimes.start) !== undefined ? (trackTimes.start + (end ? trackTimes.duration : 0)) / trackTimes.timescale : defaultValue;\n}\nfunction isInvalidInitPts(initPTS, startDTS, timeOffset, duration) {\n  if (initPTS === null) {\n    return true;\n  }\n  // InitPTS is invalid when distance from program would be more than segment duration or a minimum of one second\n  const minDuration = Math.max(duration, 1);\n  const startTime = startDTS - initPTS.baseTime / initPTS.timescale;\n  return Math.abs(startTime - timeOffset) > minDuration;\n}\nfunction getParsedTrackCodec(track, type, logger) {\n  const parsedCodec = track == null ? void 0 : track.codec;\n  if (parsedCodec && parsedCodec.length > 4) {\n    return parsedCodec;\n  }\n  if (type === ElementaryStreamTypes.AUDIO) {\n    if (parsedCodec === 'ec-3' || parsedCodec === 'ac-3' || parsedCodec === 'alac') {\n      return parsedCodec;\n    }\n    if (parsedCodec === 'fLaC' || parsedCodec === 'Opus') {\n      // Opting not to get `preferManagedMediaSource` from player config for isSupported() check for simplicity\n      const preferManagedMediaSource = false;\n      return getCodecCompatibleName(parsedCodec, preferManagedMediaSource);\n    }\n    logger.warn(`Unhandled audio codec \"${parsedCodec}\" in mp4 MAP`);\n    return parsedCodec || 'mp4a';\n  }\n  // Provide defaults based on codec type\n  // This allows for some playback of some fmp4 playlists without CODECS defined in manifest\n  logger.warn(`Unhandled video codec \"${parsedCodec}\" in mp4 MAP`);\n  return parsedCodec || 'avc1';\n}\n\nlet now;\n// performance.now() not available on WebWorker, at least on Safari Desktop\ntry {\n  now = self.performance.now.bind(self.performance);\n} catch (err) {\n  now = Date.now;\n}\nconst muxConfig = [{\n  demux: MP4Demuxer,\n  remux: PassThroughRemuxer\n}, {\n  demux: TSDemuxer,\n  remux: MP4Remuxer\n}, {\n  demux: AACDemuxer,\n  remux: MP4Remuxer\n}, {\n  demux: MP3Demuxer,\n  remux: MP4Remuxer\n}];\n{\n  muxConfig.splice(2, 0, {\n    demux: AC3Demuxer,\n    remux: MP4Remuxer\n  });\n}\nclass Transmuxer {\n  constructor(observer, typeSupported, config, vendor, id, logger) {\n    this.asyncResult = false;\n    this.logger = void 0;\n    this.observer = void 0;\n    this.typeSupported = void 0;\n    this.config = void 0;\n    this.id = void 0;\n    this.demuxer = void 0;\n    this.remuxer = void 0;\n    this.decrypter = void 0;\n    this.probe = void 0;\n    this.decryptionPromise = null;\n    this.transmuxConfig = void 0;\n    this.currentTransmuxState = void 0;\n    this.observer = observer;\n    this.typeSupported = typeSupported;\n    this.config = config;\n    this.id = id;\n    this.logger = logger;\n  }\n  configure(transmuxConfig) {\n    this.transmuxConfig = transmuxConfig;\n    if (this.decrypter) {\n      this.decrypter.reset();\n    }\n  }\n  push(data, decryptdata, chunkMeta, state) {\n    const stats = chunkMeta.transmuxing;\n    stats.executeStart = now();\n    let uintData = new Uint8Array(data);\n    const {\n      currentTransmuxState,\n      transmuxConfig\n    } = this;\n    if (state) {\n      this.currentTransmuxState = state;\n    }\n    const {\n      contiguous,\n      discontinuity,\n      trackSwitch,\n      accurateTimeOffset,\n      timeOffset,\n      initSegmentChange\n    } = state || currentTransmuxState;\n    const {\n      audioCodec,\n      videoCodec,\n      defaultInitPts,\n      duration,\n      initSegmentData\n    } = transmuxConfig;\n    const keyData = getEncryptionType(uintData, decryptdata);\n    if (keyData && isFullSegmentEncryption(keyData.method)) {\n      const decrypter = this.getDecrypter();\n      const aesMode = getAesModeFromFullSegmentMethod(keyData.method);\n\n      // Software decryption is synchronous; webCrypto is not\n      if (decrypter.isSync()) {\n        // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached\n        // data is handled in the flush() call\n        let decryptedData = decrypter.softwareDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer, aesMode);\n        // For Low-Latency HLS Parts, decrypt in place, since part parsing is expected on push progress\n        const loadingParts = chunkMeta.part > -1;\n        if (loadingParts) {\n          const _data = decrypter.flush();\n          decryptedData = _data ? _data.buffer : _data;\n        }\n        if (!decryptedData) {\n          stats.executeEnd = now();\n          return emptyResult(chunkMeta);\n        }\n        uintData = new Uint8Array(decryptedData);\n      } else {\n        this.asyncResult = true;\n        this.decryptionPromise = decrypter.webCryptoDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer, aesMode).then(decryptedData => {\n          // Calling push here is important; if flush() is called while this is still resolving, this ensures that\n          // the decrypted data has been transmuxed\n          const result = this.push(decryptedData, null, chunkMeta);\n          this.decryptionPromise = null;\n          return result;\n        });\n        return this.decryptionPromise;\n      }\n    }\n    const resetMuxers = this.needsProbing(discontinuity, trackSwitch);\n    if (resetMuxers) {\n      const error = this.configureTransmuxer(uintData);\n      if (error) {\n        this.logger.warn(`[transmuxer] ${error.message}`);\n        this.observer.emit(Events.ERROR, Events.ERROR, {\n          type: ErrorTypes.MEDIA_ERROR,\n          details: ErrorDetails.FRAG_PARSING_ERROR,\n          fatal: false,\n          error,\n          reason: error.message\n        });\n        stats.executeEnd = now();\n        return emptyResult(chunkMeta);\n      }\n    }\n    if (discontinuity || trackSwitch || initSegmentChange || resetMuxers) {\n      this.resetInitSegment(initSegmentData, audioCodec, videoCodec, duration, decryptdata);\n    }\n    if (discontinuity || initSegmentChange || resetMuxers) {\n      this.resetInitialTimestamp(defaultInitPts);\n    }\n    if (!contiguous) {\n      this.resetContiguity();\n    }\n    const result = this.transmux(uintData, keyData, timeOffset, accurateTimeOffset, chunkMeta);\n    this.asyncResult = isPromise(result);\n    const currentState = this.currentTransmuxState;\n    currentState.contiguous = true;\n    currentState.discontinuity = false;\n    currentState.trackSwitch = false;\n    stats.executeEnd = now();\n    return result;\n  }\n\n  // Due to data caching, flush calls can produce more than one TransmuxerResult (hence the Array type)\n  flush(chunkMeta) {\n    const stats = chunkMeta.transmuxing;\n    stats.executeStart = now();\n    const {\n      decrypter,\n      currentTransmuxState,\n      decryptionPromise\n    } = this;\n    if (decryptionPromise) {\n      this.asyncResult = true;\n      // Upon resolution, the decryption promise calls push() and returns its TransmuxerResult up the stack. Therefore\n      // only flushing is required for async decryption\n      return decryptionPromise.then(() => {\n        return this.flush(chunkMeta);\n      });\n    }\n    const transmuxResults = [];\n    const {\n      timeOffset\n    } = currentTransmuxState;\n    if (decrypter) {\n      // The decrypter may have data cached, which needs to be demuxed. In this case we'll have two TransmuxResults\n      // This happens in the case that we receive only 1 push call for a segment (either for non-progressive downloads,\n      // or for progressive downloads with small segments)\n      const decryptedData = decrypter.flush();\n      if (decryptedData) {\n        // Push always returns a TransmuxerResult if decryptdata is null\n        transmuxResults.push(this.push(decryptedData.buffer, null, chunkMeta));\n      }\n    }\n    const {\n      demuxer,\n      remuxer\n    } = this;\n    if (!demuxer || !remuxer) {\n      // If probing failed, then Hls.js has been given content its not able to handle\n      stats.executeEnd = now();\n      const emptyResults = [emptyResult(chunkMeta)];\n      if (this.asyncResult) {\n        return Promise.resolve(emptyResults);\n      }\n      return emptyResults;\n    }\n    const demuxResultOrPromise = demuxer.flush(timeOffset);\n    if (isPromise(demuxResultOrPromise)) {\n      this.asyncResult = true;\n      // Decrypt final SAMPLE-AES samples\n      return demuxResultOrPromise.then(demuxResult => {\n        this.flushRemux(transmuxResults, demuxResult, chunkMeta);\n        return transmuxResults;\n      });\n    }\n    this.flushRemux(transmuxResults, demuxResultOrPromise, chunkMeta);\n    if (this.asyncResult) {\n      return Promise.resolve(transmuxResults);\n    }\n    return transmuxResults;\n  }\n  flushRemux(transmuxResults, demuxResult, chunkMeta) {\n    const {\n      audioTrack,\n      videoTrack,\n      id3Track,\n      textTrack\n    } = demuxResult;\n    const {\n      accurateTimeOffset,\n      timeOffset\n    } = this.currentTransmuxState;\n    this.logger.log(`[transmuxer.ts]: Flushed ${this.id} sn: ${chunkMeta.sn}${chunkMeta.part > -1 ? ' part: ' + chunkMeta.part : ''} of ${this.id === PlaylistLevelType.MAIN ? 'level' : 'track'} ${chunkMeta.level}`);\n    const remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, true, this.id);\n    transmuxResults.push({\n      remuxResult,\n      chunkMeta\n    });\n    chunkMeta.transmuxing.executeEnd = now();\n  }\n  resetInitialTimestamp(defaultInitPts) {\n    const {\n      demuxer,\n      remuxer\n    } = this;\n    if (!demuxer || !remuxer) {\n      return;\n    }\n    demuxer.resetTimeStamp(defaultInitPts);\n    remuxer.resetTimeStamp(defaultInitPts);\n  }\n  resetContiguity() {\n    const {\n      demuxer,\n      remuxer\n    } = this;\n    if (!demuxer || !remuxer) {\n      return;\n    }\n    demuxer.resetContiguity();\n    remuxer.resetNextTimestamp();\n  }\n  resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration, decryptdata) {\n    const {\n      demuxer,\n      remuxer\n    } = this;\n    if (!demuxer || !remuxer) {\n      return;\n    }\n    demuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration);\n    remuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, decryptdata);\n  }\n  destroy() {\n    if (this.demuxer) {\n      this.demuxer.destroy();\n      this.demuxer = undefined;\n    }\n    if (this.remuxer) {\n      this.remuxer.destroy();\n      this.remuxer = undefined;\n    }\n  }\n  transmux(data, keyData, timeOffset, accurateTimeOffset, chunkMeta) {\n    let result;\n    if (keyData && keyData.method === 'SAMPLE-AES') {\n      result = this.transmuxSampleAes(data, keyData, timeOffset, accurateTimeOffset, chunkMeta);\n    } else {\n      result = this.transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta);\n    }\n    return result;\n  }\n  transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta) {\n    const {\n      audioTrack,\n      videoTrack,\n      id3Track,\n      textTrack\n    } = this.demuxer.demux(data, timeOffset, false, !this.config.progressive);\n    const remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, false, this.id);\n    return {\n      remuxResult,\n      chunkMeta\n    };\n  }\n  transmuxSampleAes(data, decryptData, timeOffset, accurateTimeOffset, chunkMeta) {\n    return this.demuxer.demuxSampleAes(data, decryptData, timeOffset).then(demuxResult => {\n      const remuxResult = this.remuxer.remux(demuxResult.audioTrack, demuxResult.videoTrack, demuxResult.id3Track, demuxResult.textTrack, timeOffset, accurateTimeOffset, false, this.id);\n      return {\n        remuxResult,\n        chunkMeta\n      };\n    });\n  }\n  configureTransmuxer(data) {\n    const {\n      config,\n      observer,\n      typeSupported\n    } = this;\n    // probe for content type\n    let mux;\n    for (let i = 0, len = muxConfig.length; i < len; i++) {\n      var _muxConfig$i$demux;\n      if ((_muxConfig$i$demux = muxConfig[i].demux) != null && _muxConfig$i$demux.probe(data, this.logger)) {\n        mux = muxConfig[i];\n        break;\n      }\n    }\n    if (!mux) {\n      return new Error('Failed to find demuxer by probing fragment data');\n    }\n    // so let's check that current remuxer and demuxer are still valid\n    const demuxer = this.demuxer;\n    const remuxer = this.remuxer;\n    const Remuxer = mux.remux;\n    const Demuxer = mux.demux;\n    if (!remuxer || !(remuxer instanceof Remuxer)) {\n      this.remuxer = new Remuxer(observer, config, typeSupported, this.logger);\n    }\n    if (!demuxer || !(demuxer instanceof Demuxer)) {\n      this.demuxer = new Demuxer(observer, config, typeSupported, this.logger);\n      this.probe = Demuxer.probe;\n    }\n  }\n  needsProbing(discontinuity, trackSwitch) {\n    // in case of continuity change, or track switch\n    // we might switch from content type (AAC container to TS container, or TS to fmp4 for example)\n    return !this.demuxer || !this.remuxer || discontinuity || trackSwitch;\n  }\n  getDecrypter() {\n    let decrypter = this.decrypter;\n    if (!decrypter) {\n      decrypter = this.decrypter = new Decrypter(this.config);\n    }\n    return decrypter;\n  }\n}\nfunction getEncryptionType(data, decryptData) {\n  let encryptionType = null;\n  if (data.byteLength > 0 && (decryptData == null ? void 0 : decryptData.key) != null && decryptData.iv !== null && decryptData.method != null) {\n    encryptionType = decryptData;\n  }\n  return encryptionType;\n}\nconst emptyResult = chunkMeta => ({\n  remuxResult: {},\n  chunkMeta\n});\nfunction isPromise(p) {\n  return 'then' in p && p.then instanceof Function;\n}\nclass TransmuxConfig {\n  constructor(audioCodec, videoCodec, initSegmentData, duration, defaultInitPts) {\n    this.audioCodec = void 0;\n    this.videoCodec = void 0;\n    this.initSegmentData = void 0;\n    this.duration = void 0;\n    this.defaultInitPts = void 0;\n    this.audioCodec = audioCodec;\n    this.videoCodec = videoCodec;\n    this.initSegmentData = initSegmentData;\n    this.duration = duration;\n    this.defaultInitPts = defaultInitPts || null;\n  }\n}\nclass TransmuxState {\n  constructor(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange) {\n    this.discontinuity = void 0;\n    this.contiguous = void 0;\n    this.accurateTimeOffset = void 0;\n    this.trackSwitch = void 0;\n    this.timeOffset = void 0;\n    this.initSegmentChange = void 0;\n    this.discontinuity = discontinuity;\n    this.contiguous = contiguous;\n    this.accurateTimeOffset = accurateTimeOffset;\n    this.trackSwitch = trackSwitch;\n    this.timeOffset = timeOffset;\n    this.initSegmentChange = initSegmentChange;\n  }\n}\n\nlet transmuxerInstanceCount = 0;\nclass TransmuxerInterface {\n  constructor(_hls, id, onTransmuxComplete, onFlush) {\n    this.error = null;\n    this.hls = void 0;\n    this.id = void 0;\n    this.instanceNo = transmuxerInstanceCount++;\n    this.observer = void 0;\n    this.frag = null;\n    this.part = null;\n    this.useWorker = void 0;\n    this.workerContext = null;\n    this.transmuxer = null;\n    this.onTransmuxComplete = void 0;\n    this.onFlush = void 0;\n    this.onWorkerMessage = event => {\n      const data = event.data;\n      const hls = this.hls;\n      if (!hls || !(data != null && data.event) || data.instanceNo !== this.instanceNo) {\n        return;\n      }\n      switch (data.event) {\n        case 'init':\n          {\n            var _this$workerContext;\n            const objectURL = (_this$workerContext = this.workerContext) == null ? void 0 : _this$workerContext.objectURL;\n            if (objectURL) {\n              // revoke the Object URL that was used to create transmuxer worker, so as not to leak it\n              self.URL.revokeObjectURL(objectURL);\n            }\n            break;\n          }\n        case 'transmuxComplete':\n          {\n            this.handleTransmuxComplete(data.data);\n            break;\n          }\n        case 'flush':\n          {\n            this.onFlush(data.data);\n            break;\n          }\n\n        // pass logs from the worker thread to the main logger\n        case 'workerLog':\n          {\n            if (hls.logger[data.data.logType]) {\n              hls.logger[data.data.logType](data.data.message);\n            }\n            break;\n          }\n        default:\n          {\n            data.data = data.data || {};\n            data.data.frag = this.frag;\n            data.data.part = this.part;\n            data.data.id = this.id;\n            hls.trigger(data.event, data.data);\n            break;\n          }\n      }\n    };\n    this.onWorkerError = event => {\n      if (!this.hls) {\n        return;\n      }\n      const error = new Error(`${event.message}  (${event.filename}:${event.lineno})`);\n      this.hls.config.enableWorker = false;\n      this.hls.logger.warn(`Error in \"${this.id}\" Web Worker, fallback to inline`);\n      this.hls.trigger(Events.ERROR, {\n        type: ErrorTypes.OTHER_ERROR,\n        details: ErrorDetails.INTERNAL_EXCEPTION,\n        fatal: false,\n        event: 'demuxerWorker',\n        error\n      });\n    };\n    const config = _hls.config;\n    this.hls = _hls;\n    this.id = id;\n    this.useWorker = !!config.enableWorker;\n    this.onTransmuxComplete = onTransmuxComplete;\n    this.onFlush = onFlush;\n    const forwardMessage = (ev, data) => {\n      data = data || {};\n      data.frag = this.frag || undefined;\n      if (ev === Events.ERROR) {\n        data = data;\n        data.parent = this.id;\n        data.part = this.part;\n        this.error = data.error;\n      }\n      this.hls.trigger(ev, data);\n    };\n\n    // forward events to main thread\n    this.observer = new EventEmitter();\n    this.observer.on(Events.FRAG_DECRYPTED, forwardMessage);\n    this.observer.on(Events.ERROR, forwardMessage);\n    const m2tsTypeSupported = getM2TSSupportedAudioTypes(config.preferManagedMediaSource);\n    if (this.useWorker && typeof Worker !== 'undefined') {\n      const logger = this.hls.logger;\n      const canCreateWorker = config.workerPath || hasUMDWorker();\n      if (canCreateWorker) {\n        try {\n          if (config.workerPath) {\n            logger.log(`loading Web Worker ${config.workerPath} for \"${id}\"`);\n            this.workerContext = loadWorker(config.workerPath);\n          } else {\n            logger.log(`injecting Web Worker for \"${id}\"`);\n            this.workerContext = injectWorker();\n          }\n          const {\n            worker\n          } = this.workerContext;\n          worker.addEventListener('message', this.onWorkerMessage);\n          worker.addEventListener('error', this.onWorkerError);\n          worker.postMessage({\n            instanceNo: this.instanceNo,\n            cmd: 'init',\n            typeSupported: m2tsTypeSupported,\n            id,\n            config: stringify(config)\n          });\n        } catch (err) {\n          logger.warn(`Error setting up \"${id}\" Web Worker, fallback to inline`, err);\n          this.terminateWorker();\n          this.error = null;\n          this.transmuxer = new Transmuxer(this.observer, m2tsTypeSupported, config, '', id, _hls.logger);\n        }\n        return;\n      }\n    }\n    this.transmuxer = new Transmuxer(this.observer, m2tsTypeSupported, config, '', id, _hls.logger);\n  }\n  reset() {\n    this.frag = null;\n    this.part = null;\n    if (this.workerContext) {\n      const instanceNo = this.instanceNo;\n      this.instanceNo = transmuxerInstanceCount++;\n      const config = this.hls.config;\n      const m2tsTypeSupported = getM2TSSupportedAudioTypes(config.preferManagedMediaSource);\n      this.workerContext.worker.postMessage({\n        instanceNo: this.instanceNo,\n        cmd: 'reset',\n        resetNo: instanceNo,\n        typeSupported: m2tsTypeSupported,\n        id: this.id,\n        config: stringify(config)\n      });\n    }\n  }\n  terminateWorker() {\n    if (this.workerContext) {\n      const {\n        worker\n      } = this.workerContext;\n      this.workerContext = null;\n      worker.removeEventListener('message', this.onWorkerMessage);\n      worker.removeEventListener('error', this.onWorkerError);\n      removeWorkerFromStore(this.hls.config.workerPath);\n    }\n  }\n  destroy() {\n    if (this.workerContext) {\n      this.terminateWorker();\n      // @ts-ignore\n      this.onWorkerMessage = this.onWorkerError = null;\n    } else {\n      const transmuxer = this.transmuxer;\n      if (transmuxer) {\n        transmuxer.destroy();\n        this.transmuxer = null;\n      }\n    }\n    const observer = this.observer;\n    if (observer) {\n      observer.removeAllListeners();\n    }\n    this.frag = null;\n    this.part = null;\n    // @ts-ignore\n    this.observer = null;\n    // @ts-ignore\n    this.hls = null;\n  }\n  push(data, initSegmentData, audioCodec, videoCodec, frag, part, duration, accurateTimeOffset, chunkMeta, defaultInitPTS) {\n    var _frag$initSegment, _lastFrag$initSegment;\n    chunkMeta.transmuxing.start = self.performance.now();\n    const {\n      instanceNo,\n      transmuxer\n    } = this;\n    const timeOffset = part ? part.start : frag.start;\n    // TODO: push \"clear-lead\" decrypt data for unencrypted fragments in streams with encrypted ones\n    const decryptdata = frag.decryptdata;\n    const lastFrag = this.frag;\n    const discontinuity = !(lastFrag && frag.cc === lastFrag.cc);\n    const trackSwitch = !(lastFrag && chunkMeta.level === lastFrag.level);\n    const snDiff = lastFrag ? chunkMeta.sn - lastFrag.sn : -1;\n    const partDiff = this.part ? chunkMeta.part - this.part.index : -1;\n    const progressive = snDiff === 0 && chunkMeta.id > 1 && chunkMeta.id === (lastFrag == null ? void 0 : lastFrag.stats.chunkCount);\n    const contiguous = !trackSwitch && (snDiff === 1 || snDiff === 0 && (partDiff === 1 || progressive && partDiff <= 0));\n    const now = self.performance.now();\n    if (trackSwitch || snDiff || frag.stats.parsing.start === 0) {\n      frag.stats.parsing.start = now;\n    }\n    if (part && (partDiff || !contiguous)) {\n      part.stats.parsing.start = now;\n    }\n    const initSegmentChange = !(lastFrag && ((_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.url) === ((_lastFrag$initSegment = lastFrag.initSegment) == null ? void 0 : _lastFrag$initSegment.url));\n    const state = new TransmuxState(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange);\n    if (!contiguous || discontinuity || initSegmentChange) {\n      this.hls.logger.log(`[transmuxer-interface]: Starting new transmux session for ${frag.type} sn: ${chunkMeta.sn}${chunkMeta.part > -1 ? ' part: ' + chunkMeta.part : ''} ${this.id === PlaylistLevelType.MAIN ? 'level' : 'track'}: ${chunkMeta.level} id: ${chunkMeta.id}\n        discontinuity: ${discontinuity}\n        trackSwitch: ${trackSwitch}\n        contiguous: ${contiguous}\n        accurateTimeOffset: ${accurateTimeOffset}\n        timeOffset: ${timeOffset}\n        initSegmentChange: ${initSegmentChange}`);\n      const config = new TransmuxConfig(audioCodec, videoCodec, initSegmentData, duration, defaultInitPTS);\n      this.configureTransmuxer(config);\n    }\n    this.frag = frag;\n    this.part = part;\n\n    // Frags with sn of 'initSegment' are not transmuxed\n    if (this.workerContext) {\n      // post fragment payload as transferable objects for ArrayBuffer (no copy)\n      this.workerContext.worker.postMessage({\n        instanceNo,\n        cmd: 'demux',\n        data,\n        decryptdata,\n        chunkMeta,\n        state\n      }, data instanceof ArrayBuffer ? [data] : []);\n    } else if (transmuxer) {\n      const transmuxResult = transmuxer.push(data, decryptdata, chunkMeta, state);\n      if (isPromise(transmuxResult)) {\n        transmuxResult.then(data => {\n          this.handleTransmuxComplete(data);\n        }).catch(error => {\n          this.transmuxerError(error, chunkMeta, 'transmuxer-interface push error');\n        });\n      } else {\n        this.handleTransmuxComplete(transmuxResult);\n      }\n    }\n  }\n  flush(chunkMeta) {\n    chunkMeta.transmuxing.start = self.performance.now();\n    const {\n      instanceNo,\n      transmuxer\n    } = this;\n    if (this.workerContext) {\n      this.workerContext.worker.postMessage({\n        instanceNo,\n        cmd: 'flush',\n        chunkMeta\n      });\n    } else if (transmuxer) {\n      const transmuxResult = transmuxer.flush(chunkMeta);\n      if (isPromise(transmuxResult)) {\n        transmuxResult.then(data => {\n          this.handleFlushResult(data, chunkMeta);\n        }).catch(error => {\n          this.transmuxerError(error, chunkMeta, 'transmuxer-interface flush error');\n        });\n      } else {\n        this.handleFlushResult(transmuxResult, chunkMeta);\n      }\n    }\n  }\n  transmuxerError(error, chunkMeta, reason) {\n    if (!this.hls) {\n      return;\n    }\n    this.error = error;\n    this.hls.trigger(Events.ERROR, {\n      type: ErrorTypes.MEDIA_ERROR,\n      details: ErrorDetails.FRAG_PARSING_ERROR,\n      chunkMeta,\n      frag: this.frag || undefined,\n      part: this.part || undefined,\n      fatal: false,\n      error,\n      err: error,\n      reason\n    });\n  }\n  handleFlushResult(results, chunkMeta) {\n    results.forEach(result => {\n      this.handleTransmuxComplete(result);\n    });\n    this.onFlush(chunkMeta);\n  }\n  configureTransmuxer(config) {\n    const {\n      instanceNo,\n      transmuxer\n    } = this;\n    if (this.workerContext) {\n      this.workerContext.worker.postMessage({\n        instanceNo,\n        cmd: 'configure',\n        config\n      });\n    } else if (transmuxer) {\n      transmuxer.configure(config);\n    }\n  }\n  handleTransmuxComplete(result) {\n    result.chunkMeta.transmuxing.end = self.performance.now();\n    this.onTransmuxComplete(result);\n  }\n}\n\nconst TICK_INTERVAL$3 = 100; // how often to tick in ms\n\nclass AudioStreamController extends BaseStreamController {\n  constructor(hls, fragmentTracker, keyLoader) {\n    super(hls, fragmentTracker, keyLoader, 'audio-stream-controller', PlaylistLevelType.AUDIO);\n    this.mainAnchor = null;\n    this.mainFragLoading = null;\n    this.audioOnly = false;\n    this.bufferedTrack = null;\n    this.switchingTrack = null;\n    this.trackId = -1;\n    this.waitingData = null;\n    this.mainDetails = null;\n    this.flushing = false;\n    this.bufferFlushed = false;\n    this.cachedTrackLoadedData = null;\n    this.registerListeners();\n  }\n  onHandlerDestroying() {\n    this.unregisterListeners();\n    super.onHandlerDestroying();\n    this.resetItem();\n  }\n  resetItem() {\n    this.mainDetails = this.mainAnchor = this.mainFragLoading = this.bufferedTrack = this.switchingTrack = this.waitingData = this.cachedTrackLoadedData = null;\n  }\n  registerListeners() {\n    super.registerListeners();\n    const {\n      hls\n    } = this;\n    hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);\n    hls.on(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n    hls.on(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n    hls.on(Events.BUFFER_RESET, this.onBufferReset, this);\n    hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);\n    hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.on(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n    hls.on(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);\n    hls.on(Events.FRAG_LOADING, this.onFragLoading, this);\n    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n  }\n  unregisterListeners() {\n    const {\n      hls\n    } = this;\n    if (!hls) {\n      return;\n    }\n    super.unregisterListeners();\n    hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);\n    hls.off(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n    hls.off(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n    hls.off(Events.BUFFER_RESET, this.onBufferReset, this);\n    hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);\n    hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.off(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n    hls.off(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);\n    hls.off(Events.FRAG_LOADING, this.onFragLoading, this);\n    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n  }\n\n  // INIT_PTS_FOUND is triggered when the video track parsed in the stream-controller has a new PTS value\n  onInitPtsFound(event, {\n    frag,\n    id,\n    initPTS,\n    timescale\n  }) {\n    // Always update the new INIT PTS\n    // Can change due level switch\n    if (id === PlaylistLevelType.MAIN) {\n      const cc = frag.cc;\n      const inFlightFrag = this.fragCurrent;\n      this.initPTS[cc] = {\n        baseTime: initPTS,\n        timescale\n      };\n      this.log(`InitPTS for cc: ${cc} found from main: ${initPTS}/${timescale}`);\n      this.mainAnchor = frag;\n      // If we are waiting, tick immediately to unblock audio fragment transmuxing\n      if (this.state === State.WAITING_INIT_PTS) {\n        const waitingData = this.waitingData;\n        if (!waitingData && !this.loadingParts || waitingData && waitingData.frag.cc !== cc) {\n          this.syncWithAnchor(frag, waitingData == null ? void 0 : waitingData.frag);\n        }\n      } else if (!this.hls.hasEnoughToStart && inFlightFrag && inFlightFrag.cc !== cc) {\n        inFlightFrag.abortRequests();\n        this.syncWithAnchor(frag, inFlightFrag);\n      } else if (this.state === State.IDLE) {\n        this.tick();\n      }\n    }\n  }\n  getLoadPosition() {\n    if (!this.startFragRequested && this.nextLoadPosition >= 0) {\n      return this.nextLoadPosition;\n    }\n    return super.getLoadPosition();\n  }\n  syncWithAnchor(mainAnchor, waitingToAppend) {\n    var _this$mainFragLoading;\n    // Drop waiting fragment if videoTrackCC has changed since waitingFragment was set and initPTS was not found\n    const mainFragLoading = ((_this$mainFragLoading = this.mainFragLoading) == null ? void 0 : _this$mainFragLoading.frag) || null;\n    if (waitingToAppend) {\n      if ((mainFragLoading == null ? void 0 : mainFragLoading.cc) === waitingToAppend.cc) {\n        // Wait for loading frag to complete and INIT_PTS_FOUND\n        return;\n      }\n    }\n    const targetDiscontinuity = (mainFragLoading || mainAnchor).cc;\n    const trackDetails = this.getLevelDetails();\n    const pos = this.getLoadPosition();\n    const syncFrag = findNearestWithCC(trackDetails, targetDiscontinuity, pos);\n    // Only stop waiting for audioFrag.cc if an audio segment of the same discontinuity domain (cc) is found\n    if (syncFrag) {\n      this.log(`Syncing with main frag at ${syncFrag.start} cc ${syncFrag.cc}`);\n      this.startFragRequested = false;\n      this.nextLoadPosition = syncFrag.start;\n      this.resetLoadingState();\n      if (this.state === State.IDLE) {\n        this.doTickIdle();\n      }\n    }\n  }\n  startLoad(startPosition, skipSeekToStartPosition) {\n    if (!this.levels) {\n      this.startPosition = startPosition;\n      this.state = State.STOPPED;\n      return;\n    }\n    const lastCurrentTime = this.lastCurrentTime;\n    this.stopLoad();\n    this.setInterval(TICK_INTERVAL$3);\n    if (lastCurrentTime > 0 && startPosition === -1) {\n      this.log(`Override startPosition with lastCurrentTime @${lastCurrentTime.toFixed(3)}`);\n      startPosition = lastCurrentTime;\n      this.state = State.IDLE;\n    } else {\n      this.state = State.WAITING_TRACK;\n    }\n    this.nextLoadPosition = this.lastCurrentTime = startPosition + this.timelineOffset;\n    this.startPosition = skipSeekToStartPosition ? -1 : startPosition;\n    this.tick();\n  }\n  doTick() {\n    switch (this.state) {\n      case State.IDLE:\n        this.doTickIdle();\n        break;\n      case State.WAITING_TRACK:\n        {\n          const {\n            levels,\n            trackId\n          } = this;\n          const currenTrack = levels == null ? void 0 : levels[trackId];\n          const details = currenTrack == null ? void 0 : currenTrack.details;\n          if (details && !this.waitForLive(currenTrack)) {\n            if (this.waitForCdnTuneIn(details)) {\n              break;\n            }\n            this.state = State.WAITING_INIT_PTS;\n          }\n          break;\n        }\n      case State.FRAG_LOADING_WAITING_RETRY:\n        {\n          var _this$media;\n          const now = performance.now();\n          const retryDate = this.retryDate;\n          // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading\n          if (!retryDate || now >= retryDate || (_this$media = this.media) != null && _this$media.seeking) {\n            const {\n              levels,\n              trackId\n            } = this;\n            this.log('RetryDate reached, switch back to IDLE state');\n            this.resetStartWhenNotLoaded((levels == null ? void 0 : levels[trackId]) || null);\n            this.state = State.IDLE;\n          }\n          break;\n        }\n      case State.WAITING_INIT_PTS:\n        {\n          // Ensure we don't get stuck in the WAITING_INIT_PTS state if the waiting frag CC doesn't match any initPTS\n          const waitingData = this.waitingData;\n          if (waitingData) {\n            const {\n              frag,\n              part,\n              cache,\n              complete\n            } = waitingData;\n            const mainAnchor = this.mainAnchor;\n            if (this.initPTS[frag.cc] !== undefined) {\n              this.waitingData = null;\n              this.state = State.FRAG_LOADING;\n              const payload = cache.flush().buffer;\n              const data = {\n                frag,\n                part,\n                payload,\n                networkDetails: null\n              };\n              this._handleFragmentLoadProgress(data);\n              if (complete) {\n                super._handleFragmentLoadComplete(data);\n              }\n            } else if (mainAnchor && mainAnchor.cc !== waitingData.frag.cc) {\n              this.syncWithAnchor(mainAnchor, waitingData.frag);\n            }\n          } else {\n            this.state = State.IDLE;\n          }\n        }\n    }\n    this.onTickEnd();\n  }\n  resetLoadingState() {\n    const waitingData = this.waitingData;\n    if (waitingData) {\n      this.fragmentTracker.removeFragment(waitingData.frag);\n      this.waitingData = null;\n    }\n    super.resetLoadingState();\n  }\n  onTickEnd() {\n    const {\n      media\n    } = this;\n    if (!(media != null && media.readyState)) {\n      // Exit early if we don't have media or if the media hasn't buffered anything yet (readyState 0)\n      return;\n    }\n    this.lastCurrentTime = media.currentTime;\n  }\n  doTickIdle() {\n    var _this$mainFragLoading2;\n    const {\n      hls,\n      levels,\n      media,\n      trackId\n    } = this;\n    const config = hls.config;\n\n    // 1. if buffering is suspended\n    // 2. if video not attached AND\n    //    start fragment already requested OR start frag prefetch not enabled\n    // 3. if tracks or track not loaded and selected\n    // then exit loop\n    // => if media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop\n    if (!this.buffering || !media && !this.primaryPrefetch && (this.startFragRequested || !config.startFragPrefetch) || !(levels != null && levels[trackId])) {\n      return;\n    }\n    const levelInfo = levels[trackId];\n    const trackDetails = levelInfo.details;\n    if (!trackDetails || this.waitForLive(levelInfo) || this.waitForCdnTuneIn(trackDetails)) {\n      this.state = State.WAITING_TRACK;\n      this.startFragRequested = false;\n      return;\n    }\n    const bufferable = this.mediaBuffer ? this.mediaBuffer : this.media;\n    if (this.bufferFlushed && bufferable) {\n      this.bufferFlushed = false;\n      this.afterBufferFlushed(bufferable, ElementaryStreamTypes.AUDIO, PlaylistLevelType.AUDIO);\n    }\n    const bufferInfo = this.getFwdBufferInfo(bufferable, PlaylistLevelType.AUDIO);\n    if (bufferInfo === null) {\n      return;\n    }\n    if (!this.switchingTrack && this._streamEnded(bufferInfo, trackDetails)) {\n      hls.trigger(Events.BUFFER_EOS, {\n        type: 'audio'\n      });\n      this.state = State.ENDED;\n      return;\n    }\n    const bufferLen = bufferInfo.len;\n    const maxBufLen = hls.maxBufferLength;\n    const fragments = trackDetails.fragments;\n    const start = fragments[0].start;\n    const loadPosition = this.getLoadPosition();\n    const targetBufferTime = this.flushing ? loadPosition : bufferInfo.end;\n    if (this.switchingTrack && media) {\n      const pos = loadPosition;\n      // if currentTime (pos) is less than alt audio playlist start time, it means that alt audio is ahead of currentTime\n      if (trackDetails.PTSKnown && pos < start) {\n        // if everything is buffered from pos to start or if audio buffer upfront, let's seek to start\n        if (bufferInfo.end > start || bufferInfo.nextStart) {\n          this.log('Alt audio track ahead of main track, seek to start of alt audio track');\n          media.currentTime = start + 0.05;\n        }\n      }\n    }\n\n    // if buffer length is less than maxBufLen, or near the end, find a fragment to load\n    if (bufferLen >= maxBufLen && !this.switchingTrack && targetBufferTime < fragments[fragments.length - 1].start) {\n      return;\n    }\n    let frag = this.getNextFragment(targetBufferTime, trackDetails);\n    // Avoid loop loading by using nextLoadPosition set for backtracking and skipping consecutive GAP tags\n    if (frag && this.isLoopLoading(frag, targetBufferTime)) {\n      frag = this.getNextFragmentLoopLoading(frag, trackDetails, bufferInfo, PlaylistLevelType.MAIN, maxBufLen);\n    }\n    if (!frag) {\n      this.bufferFlushed = true;\n      return;\n    }\n\n    // Request audio segments up to one fragment ahead of main stream-controller\n    let mainFragLoading = ((_this$mainFragLoading2 = this.mainFragLoading) == null ? void 0 : _this$mainFragLoading2.frag) || null;\n    if (!this.audioOnly && this.startFragRequested && mainFragLoading && isMediaFragment(frag) && !frag.endList && (!trackDetails.live || !this.loadingParts && targetBufferTime < this.hls.liveSyncPosition)) {\n      if (this.fragmentTracker.getState(mainFragLoading) === FragmentState.OK) {\n        this.mainFragLoading = mainFragLoading = null;\n      }\n      if (mainFragLoading && isMediaFragment(mainFragLoading)) {\n        if (frag.start > mainFragLoading.end) {\n          // Get buffered frag at target position from tracker (loaded out of sequence)\n          const mainFragAtPos = this.fragmentTracker.getFragAtPos(targetBufferTime, PlaylistLevelType.MAIN);\n          if (mainFragAtPos && mainFragAtPos.end > mainFragLoading.end) {\n            mainFragLoading = mainFragAtPos;\n            this.mainFragLoading = {\n              frag: mainFragAtPos,\n              targetBufferTime: null\n            };\n          }\n        }\n        const atBufferSyncLimit = frag.start > mainFragLoading.end;\n        if (atBufferSyncLimit) {\n          return;\n        }\n      }\n    }\n    this.loadFragment(frag, levelInfo, targetBufferTime);\n  }\n  onMediaDetaching(event, data) {\n    this.bufferFlushed = this.flushing = false;\n    super.onMediaDetaching(event, data);\n  }\n  onAudioTracksUpdated(event, {\n    audioTracks\n  }) {\n    // Reset tranxmuxer is essential for large context switches (Content Steering)\n    this.resetTransmuxer();\n    this.levels = audioTracks.map(mediaPlaylist => new Level(mediaPlaylist));\n  }\n  onAudioTrackSwitching(event, data) {\n    // if any URL found on new audio track, it is an alternate audio track\n    const altAudio = !!data.url;\n    this.trackId = data.id;\n    const {\n      fragCurrent\n    } = this;\n    if (fragCurrent) {\n      fragCurrent.abortRequests();\n      this.removeUnbufferedFrags(fragCurrent.start);\n    }\n    this.resetLoadingState();\n\n    // should we switch tracks ?\n    if (altAudio) {\n      this.switchingTrack = data;\n      // main audio track are handled by stream-controller, just do something if switching to alt audio track\n      this.flushAudioIfNeeded(data);\n      if (this.state !== State.STOPPED) {\n        // switching to audio track, start timer if not already started\n        this.setInterval(TICK_INTERVAL$3);\n        this.state = State.IDLE;\n        this.tick();\n      }\n    } else {\n      // destroy useless transmuxer when switching audio to main\n      this.resetTransmuxer();\n      this.switchingTrack = null;\n      this.bufferedTrack = data;\n      this.clearInterval();\n    }\n  }\n  onManifestLoading() {\n    super.onManifestLoading();\n    this.bufferFlushed = this.flushing = this.audioOnly = false;\n    this.resetItem();\n    this.trackId = -1;\n  }\n  onLevelLoaded(event, data) {\n    this.mainDetails = data.details;\n    const cachedTrackLoadedData = this.cachedTrackLoadedData;\n    if (cachedTrackLoadedData) {\n      this.cachedTrackLoadedData = null;\n      this.onAudioTrackLoaded(Events.AUDIO_TRACK_LOADED, cachedTrackLoadedData);\n    }\n  }\n  onAudioTrackLoaded(event, data) {\n    var _trackLevel$details;\n    const {\n      levels\n    } = this;\n    const {\n      details: newDetails,\n      id: trackId,\n      groupId,\n      track\n    } = data;\n    if (!levels) {\n      this.warn(`Audio tracks reset while loading track ${trackId} \"${track.name}\" of \"${groupId}\"`);\n      return;\n    }\n    const mainDetails = this.mainDetails;\n    if (!mainDetails || newDetails.endCC > mainDetails.endCC || mainDetails.expired) {\n      this.cachedTrackLoadedData = data;\n      if (this.state !== State.STOPPED) {\n        this.state = State.WAITING_TRACK;\n      }\n      return;\n    }\n    this.cachedTrackLoadedData = null;\n    this.log(`Audio track ${trackId} \"${track.name}\" of \"${groupId}\" loaded [${newDetails.startSN},${newDetails.endSN}]${newDetails.lastPartSn ? `[part-${newDetails.lastPartSn}-${newDetails.lastPartIndex}]` : ''},duration:${newDetails.totalduration}`);\n    const trackLevel = levels[trackId];\n    let sliding = 0;\n    if (newDetails.live || (_trackLevel$details = trackLevel.details) != null && _trackLevel$details.live) {\n      this.checkLiveUpdate(newDetails);\n      if (newDetails.deltaUpdateFailed) {\n        return;\n      }\n      if (trackLevel.details) {\n        var _this$levelLastLoaded;\n        sliding = this.alignPlaylists(newDetails, trackLevel.details, (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details);\n      }\n      if (!newDetails.alignedSliding) {\n        // Align audio rendition with the \"main\" playlist on discontinuity change\n        // or program-date-time (PDT)\n        alignDiscontinuities(newDetails, mainDetails);\n        if (!newDetails.alignedSliding) {\n          alignMediaPlaylistByPDT(newDetails, mainDetails);\n        }\n        sliding = newDetails.fragmentStart;\n      }\n    }\n    trackLevel.details = newDetails;\n    this.levelLastLoaded = trackLevel;\n\n    // compute start position if we are aligned with the main playlist\n    if (!this.startFragRequested) {\n      this.setStartPosition(mainDetails, sliding);\n    }\n    this.hls.trigger(Events.AUDIO_TRACK_UPDATED, {\n      details: newDetails,\n      id: trackId,\n      groupId: data.groupId\n    });\n\n    // only switch back to IDLE state if we were waiting for track to start downloading a new fragment\n    if (this.state === State.WAITING_TRACK && !this.waitForCdnTuneIn(newDetails)) {\n      this.state = State.IDLE;\n    }\n\n    // trigger handler right now\n    this.tick();\n  }\n  _handleFragmentLoadProgress(data) {\n    var _frag$initSegment;\n    const frag = data.frag;\n    const {\n      part,\n      payload\n    } = data;\n    const {\n      config,\n      trackId,\n      levels\n    } = this;\n    if (!levels) {\n      this.warn(`Audio tracks were reset while fragment load was in progress. Fragment ${frag.sn} of level ${frag.level} will not be buffered`);\n      return;\n    }\n    const track = levels[trackId];\n    if (!track) {\n      this.warn('Audio track is undefined on fragment load progress');\n      return;\n    }\n    const details = track.details;\n    if (!details) {\n      this.warn('Audio track details undefined on fragment load progress');\n      this.removeUnbufferedFrags(frag.start);\n      return;\n    }\n    const audioCodec = config.defaultAudioCodec || track.audioCodec || 'mp4a.40.2';\n    let transmuxer = this.transmuxer;\n    if (!transmuxer) {\n      transmuxer = this.transmuxer = new TransmuxerInterface(this.hls, PlaylistLevelType.AUDIO, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));\n    }\n\n    // Check if we have video initPTS\n    // If not we need to wait for it\n    const initPTS = this.initPTS[frag.cc];\n    const initSegmentData = (_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.data;\n    if (initPTS !== undefined) {\n      // this.log(`Transmuxing ${sn} of [${details.startSN} ,${details.endSN}],track ${trackId}`);\n      // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)\n      const accurateTimeOffset = false; // details.PTSKnown || !details.live;\n      const partIndex = part ? part.index : -1;\n      const partial = partIndex !== -1;\n      const chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);\n      transmuxer.push(payload, initSegmentData, audioCodec, '', frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);\n    } else {\n      this.log(`Unknown video PTS for cc ${frag.cc}, waiting for video PTS before demuxing audio frag ${frag.sn} of [${details.startSN} ,${details.endSN}],track ${trackId}`);\n      const {\n        cache\n      } = this.waitingData = this.waitingData || {\n        frag,\n        part,\n        cache: new ChunkCache(),\n        complete: false\n      };\n      cache.push(new Uint8Array(payload));\n      if (this.state !== State.STOPPED) {\n        this.state = State.WAITING_INIT_PTS;\n      }\n    }\n  }\n  _handleFragmentLoadComplete(fragLoadedData) {\n    if (this.waitingData) {\n      this.waitingData.complete = true;\n      return;\n    }\n    super._handleFragmentLoadComplete(fragLoadedData);\n  }\n  onBufferReset(/* event: Events.BUFFER_RESET */\n  ) {\n    // reset reference to sourcebuffers\n    this.mediaBuffer = null;\n  }\n  onBufferCreated(event, data) {\n    this.bufferFlushed = this.flushing = false;\n    const audioTrack = data.tracks.audio;\n    if (audioTrack) {\n      this.mediaBuffer = audioTrack.buffer || null;\n    }\n  }\n  onFragLoading(event, data) {\n    if (!this.audioOnly && data.frag.type === PlaylistLevelType.MAIN && isMediaFragment(data.frag)) {\n      this.mainFragLoading = data;\n      if (this.state === State.IDLE) {\n        this.tick();\n      }\n    }\n  }\n  onFragBuffered(event, data) {\n    const {\n      frag,\n      part\n    } = data;\n    if (frag.type !== PlaylistLevelType.AUDIO) {\n      if (!this.audioOnly && frag.type === PlaylistLevelType.MAIN && !frag.elementaryStreams.video && !frag.elementaryStreams.audiovideo) {\n        this.audioOnly = true;\n        this.mainFragLoading = null;\n      }\n      return;\n    }\n    if (this.fragContextChanged(frag)) {\n      // If a level switch was requested while a fragment was buffering, it will emit the FRAG_BUFFERED event upon completion\n      // Avoid setting state back to IDLE or concluding the audio switch; otherwise, the switched-to track will not buffer\n      this.warn(`Fragment ${frag.sn}${part ? ' p: ' + part.index : ''} of level ${frag.level} finished buffering, but was aborted. state: ${this.state}, audioSwitch: ${this.switchingTrack ? this.switchingTrack.name : 'false'}`);\n      return;\n    }\n    if (isMediaFragment(frag)) {\n      this.fragPrevious = frag;\n      const track = this.switchingTrack;\n      if (track) {\n        this.bufferedTrack = track;\n        this.switchingTrack = null;\n        this.hls.trigger(Events.AUDIO_TRACK_SWITCHED, _objectSpread2({}, track));\n      }\n    }\n    this.fragBufferedComplete(frag, part);\n    if (this.media) {\n      this.tick();\n    }\n  }\n  onError(event, data) {\n    var _data$context;\n    if (data.fatal) {\n      this.state = State.ERROR;\n      return;\n    }\n    switch (data.details) {\n      case ErrorDetails.FRAG_GAP:\n      case ErrorDetails.FRAG_PARSING_ERROR:\n      case ErrorDetails.FRAG_DECRYPT_ERROR:\n      case ErrorDetails.FRAG_LOAD_ERROR:\n      case ErrorDetails.FRAG_LOAD_TIMEOUT:\n      case ErrorDetails.KEY_LOAD_ERROR:\n      case ErrorDetails.KEY_LOAD_TIMEOUT:\n        this.onFragmentOrKeyLoadError(PlaylistLevelType.AUDIO, data);\n        break;\n      case ErrorDetails.AUDIO_TRACK_LOAD_ERROR:\n      case ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:\n      case ErrorDetails.LEVEL_PARSING_ERROR:\n        // in case of non fatal error while loading track, if not retrying to load track, switch back to IDLE\n        if (!data.levelRetry && this.state === State.WAITING_TRACK && ((_data$context = data.context) == null ? void 0 : _data$context.type) === PlaylistContextType.AUDIO_TRACK) {\n          this.state = State.IDLE;\n        }\n        break;\n      case ErrorDetails.BUFFER_ADD_CODEC_ERROR:\n      case ErrorDetails.BUFFER_APPEND_ERROR:\n        if (data.parent !== 'audio') {\n          return;\n        }\n        if (!this.reduceLengthAndFlushBuffer(data)) {\n          this.resetLoadingState();\n        }\n        break;\n      case ErrorDetails.BUFFER_FULL_ERROR:\n        if (data.parent !== 'audio') {\n          return;\n        }\n        if (this.reduceLengthAndFlushBuffer(data)) {\n          this.bufferedTrack = null;\n          super.flushMainBuffer(0, Number.POSITIVE_INFINITY, 'audio');\n        }\n        break;\n      case ErrorDetails.INTERNAL_EXCEPTION:\n        this.recoverWorkerError(data);\n        break;\n    }\n  }\n  onBufferFlushing(event, {\n    type\n  }) {\n    if (type !== ElementaryStreamTypes.VIDEO) {\n      this.flushing = true;\n    }\n  }\n  onBufferFlushed(event, {\n    type\n  }) {\n    if (type !== ElementaryStreamTypes.VIDEO) {\n      this.flushing = false;\n      this.bufferFlushed = true;\n      if (this.state === State.ENDED) {\n        this.state = State.IDLE;\n      }\n      const mediaBuffer = this.mediaBuffer || this.media;\n      if (mediaBuffer) {\n        this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.AUDIO);\n        this.tick();\n      }\n    }\n  }\n  _handleTransmuxComplete(transmuxResult) {\n    var _id3$samples;\n    const id = 'audio';\n    const {\n      hls\n    } = this;\n    const {\n      remuxResult,\n      chunkMeta\n    } = transmuxResult;\n    const context = this.getCurrentContext(chunkMeta);\n    if (!context) {\n      this.resetWhenMissingContext(chunkMeta);\n      return;\n    }\n    const {\n      frag,\n      part,\n      level\n    } = context;\n    const {\n      details\n    } = level;\n    const {\n      audio,\n      text,\n      id3,\n      initSegment\n    } = remuxResult;\n\n    // Check if the current fragment has been aborted. We check this by first seeing if we're still playing the current level.\n    // If we are, subsequently check if the currently loading fragment (fragCurrent) has changed.\n    if (this.fragContextChanged(frag) || !details) {\n      this.fragmentTracker.removeFragment(frag);\n      return;\n    }\n    this.state = State.PARSING;\n    if (this.switchingTrack && audio) {\n      this.completeAudioSwitch(this.switchingTrack);\n    }\n    if (initSegment != null && initSegment.tracks) {\n      const mapFragment = frag.initSegment || frag;\n      this._bufferInitSegment(level, initSegment.tracks, mapFragment, chunkMeta);\n      hls.trigger(Events.FRAG_PARSING_INIT_SEGMENT, {\n        frag: mapFragment,\n        id,\n        tracks: initSegment.tracks\n      });\n      // Only flush audio from old audio tracks when PTS is known on new audio track\n    }\n    if (audio) {\n      const {\n        startPTS,\n        endPTS,\n        startDTS,\n        endDTS\n      } = audio;\n      if (part) {\n        part.elementaryStreams[ElementaryStreamTypes.AUDIO] = {\n          startPTS,\n          endPTS,\n          startDTS,\n          endDTS\n        };\n      }\n      frag.setElementaryStreamInfo(ElementaryStreamTypes.AUDIO, startPTS, endPTS, startDTS, endDTS);\n      this.bufferFragmentData(audio, frag, part, chunkMeta);\n    }\n    if (id3 != null && (_id3$samples = id3.samples) != null && _id3$samples.length) {\n      const emittedID3 = _extends({\n        id,\n        frag,\n        details\n      }, id3);\n      hls.trigger(Events.FRAG_PARSING_METADATA, emittedID3);\n    }\n    if (text) {\n      const emittedText = _extends({\n        id,\n        frag,\n        details\n      }, text);\n      hls.trigger(Events.FRAG_PARSING_USERDATA, emittedText);\n    }\n  }\n  _bufferInitSegment(currentLevel, tracks, frag, chunkMeta) {\n    if (this.state !== State.PARSING) {\n      return;\n    }\n    // delete any video track found on audio transmuxer\n    if (tracks.video) {\n      delete tracks.video;\n    }\n    if (tracks.audiovideo) {\n      delete tracks.audiovideo;\n    }\n\n    // include levelCodec in audio and video tracks\n    if (!tracks.audio) {\n      return;\n    }\n    const track = tracks.audio;\n    track.id = PlaylistLevelType.AUDIO;\n    const variantAudioCodecs = currentLevel.audioCodec;\n    this.log(`Init audio buffer, container:${track.container}, codecs[level/parsed]=[${variantAudioCodecs}/${track.codec}]`);\n    // SourceBuffer will use track.levelCodec if defined\n    if (variantAudioCodecs && variantAudioCodecs.split(',').length === 1) {\n      track.levelCodec = variantAudioCodecs;\n    }\n    this.hls.trigger(Events.BUFFER_CODECS, tracks);\n    const initSegment = track.initSegment;\n    if (initSegment != null && initSegment.byteLength) {\n      const segment = {\n        type: 'audio',\n        frag,\n        part: null,\n        chunkMeta,\n        parent: frag.type,\n        data: initSegment\n      };\n      this.hls.trigger(Events.BUFFER_APPENDING, segment);\n    }\n    // trigger handler right now\n    this.tickImmediate();\n  }\n  loadFragment(frag, track, targetBufferTime) {\n    // only load if fragment is not loaded or if in audio switch\n    const fragState = this.fragmentTracker.getState(frag);\n\n    // we force a frag loading in audio switch as fragment tracker might not have evicted previous frags in case of quick audio switch\n    if (this.switchingTrack || fragState === FragmentState.NOT_LOADED || fragState === FragmentState.PARTIAL) {\n      var _track$details;\n      if (!isMediaFragment(frag)) {\n        this._loadInitSegment(frag, track);\n      } else if ((_track$details = track.details) != null && _track$details.live && !this.initPTS[frag.cc]) {\n        this.log(`Waiting for video PTS in continuity counter ${frag.cc} of live stream before loading audio fragment ${frag.sn} of level ${this.trackId}`);\n        this.state = State.WAITING_INIT_PTS;\n        const mainDetails = this.mainDetails;\n        if (mainDetails && mainDetails.fragmentStart !== track.details.fragmentStart) {\n          alignMediaPlaylistByPDT(track.details, mainDetails);\n        }\n      } else {\n        super.loadFragment(frag, track, targetBufferTime);\n      }\n    } else {\n      this.clearTrackerIfNeeded(frag);\n    }\n  }\n  flushAudioIfNeeded(switchingTrack) {\n    if (this.media && this.bufferedTrack) {\n      const {\n        name,\n        lang,\n        assocLang,\n        characteristics,\n        audioCodec,\n        channels\n      } = this.bufferedTrack;\n      if (!matchesOption({\n        name,\n        lang,\n        assocLang,\n        characteristics,\n        audioCodec,\n        channels\n      }, switchingTrack, audioMatchPredicate)) {\n        if (useAlternateAudio(switchingTrack.url, this.hls)) {\n          this.log('Switching audio track : flushing all audio');\n          super.flushMainBuffer(0, Number.POSITIVE_INFINITY, 'audio');\n          this.bufferedTrack = null;\n        } else {\n          // Main is being buffered. Set bufferedTrack so that it is flushed when switching back to alt-audio\n          this.bufferedTrack = switchingTrack;\n        }\n      }\n    }\n  }\n  completeAudioSwitch(switchingTrack) {\n    const {\n      hls\n    } = this;\n    this.flushAudioIfNeeded(switchingTrack);\n    this.bufferedTrack = switchingTrack;\n    this.switchingTrack = null;\n    hls.trigger(Events.AUDIO_TRACK_SWITCHED, _objectSpread2({}, switchingTrack));\n  }\n}\n\nclass BasePlaylistController extends Logger {\n  constructor(hls, logPrefix) {\n    super(logPrefix, hls.logger);\n    this.hls = void 0;\n    this.canLoad = false;\n    this.timer = -1;\n    this.hls = hls;\n  }\n  destroy() {\n    this.clearTimer();\n    // @ts-ignore\n    this.hls = this.log = this.warn = null;\n  }\n  clearTimer() {\n    if (this.timer !== -1) {\n      self.clearTimeout(this.timer);\n      this.timer = -1;\n    }\n  }\n  startLoad() {\n    this.canLoad = true;\n    this.loadPlaylist();\n  }\n  stopLoad() {\n    this.canLoad = false;\n    this.clearTimer();\n  }\n  switchParams(playlistUri, previous, current) {\n    const renditionReports = previous == null ? void 0 : previous.renditionReports;\n    if (renditionReports) {\n      let foundIndex = -1;\n      for (let i = 0; i < renditionReports.length; i++) {\n        const attr = renditionReports[i];\n        let uri;\n        try {\n          uri = new self.URL(attr.URI, previous.url).href;\n        } catch (error) {\n          this.warn(`Could not construct new URL for Rendition Report: ${error}`);\n          uri = attr.URI || '';\n        }\n        // Use exact match. Otherwise, the last partial match, if any, will be used\n        // (Playlist URI includes a query string that the Rendition Report does not)\n        if (uri === playlistUri) {\n          foundIndex = i;\n          break;\n        } else if (uri === playlistUri.substring(0, uri.length)) {\n          foundIndex = i;\n        }\n      }\n      if (foundIndex !== -1) {\n        const attr = renditionReports[foundIndex];\n        const msn = parseInt(attr['LAST-MSN']) || (previous == null ? void 0 : previous.lastPartSn);\n        let part = parseInt(attr['LAST-PART']) || (previous == null ? void 0 : previous.lastPartIndex);\n        if (this.hls.config.lowLatencyMode) {\n          const currentGoal = Math.min(previous.age - previous.partTarget, previous.targetduration);\n          if (part >= 0 && currentGoal > previous.partTarget) {\n            part += 1;\n          }\n        }\n        const skip = current && getSkipValue(current);\n        return new HlsUrlParameters(msn, part >= 0 ? part : undefined, skip);\n      }\n    }\n  }\n  loadPlaylist(hlsUrlParameters) {\n    // Loading is handled by the subclasses\n    this.clearTimer();\n  }\n  loadingPlaylist(playlist, hlsUrlParameters) {\n    // Loading is handled by the subclasses\n    this.clearTimer();\n  }\n  shouldLoadPlaylist(playlist) {\n    return this.canLoad && !!playlist && !!playlist.url && (!playlist.details || playlist.details.live);\n  }\n  getUrlWithDirectives(uri, hlsUrlParameters) {\n    if (hlsUrlParameters) {\n      try {\n        return hlsUrlParameters.addDirectives(uri);\n      } catch (error) {\n        this.warn(`Could not construct new URL with HLS Delivery Directives: ${error}`);\n      }\n    }\n    return uri;\n  }\n  playlistLoaded(index, data, previousDetails) {\n    const {\n      details,\n      stats\n    } = data;\n\n    // Set last updated date-time\n    const now = self.performance.now();\n    const elapsed = stats.loading.first ? Math.max(0, now - stats.loading.first) : 0;\n    details.advancedDateTime = Date.now() - elapsed;\n\n    // shift fragment starts with timelineOffset\n    const timelineOffset = this.hls.config.timelineOffset;\n    if (timelineOffset !== details.appliedTimelineOffset) {\n      const offset = Math.max(timelineOffset || 0, 0);\n      details.appliedTimelineOffset = offset;\n      details.fragments.forEach(frag => {\n        frag.start = frag.playlistOffset + offset;\n      });\n    }\n\n    // if current playlist is a live playlist, arm a timer to reload it\n    if (details.live || previousDetails != null && previousDetails.live) {\n      const levelOrTrack = 'levelInfo' in data ? data.levelInfo : data.track;\n      details.reloaded(previousDetails);\n      // Merge live playlists to adjust fragment starts and fill in delta playlist skipped segments\n      if (previousDetails && details.fragments.length > 0) {\n        mergeDetails(previousDetails, details);\n        const error = details.playlistParsingError;\n        if (error) {\n          this.warn(error);\n          const hls = this.hls;\n          if (!hls.config.ignorePlaylistParsingErrors) {\n            var _details$fragments$;\n            const {\n              networkDetails\n            } = data;\n            hls.trigger(Events.ERROR, {\n              type: ErrorTypes.NETWORK_ERROR,\n              details: ErrorDetails.LEVEL_PARSING_ERROR,\n              fatal: false,\n              url: details.url,\n              error,\n              reason: error.message,\n              level: data.level || undefined,\n              parent: (_details$fragments$ = details.fragments[0]) == null ? void 0 : _details$fragments$.type,\n              networkDetails,\n              stats\n            });\n            return;\n          }\n          details.playlistParsingError = null;\n        }\n      }\n      if (details.requestScheduled === -1) {\n        details.requestScheduled = stats.loading.start;\n      }\n      const bufferInfo = this.hls.mainForwardBufferInfo;\n      const position = bufferInfo ? bufferInfo.end - bufferInfo.len : 0;\n      const distanceToLiveEdgeMs = (details.edge - position) * 1000;\n      const reloadInterval = computeReloadInterval(details, distanceToLiveEdgeMs);\n      if (details.requestScheduled + reloadInterval < now) {\n        details.requestScheduled = now;\n      } else {\n        details.requestScheduled += reloadInterval;\n      }\n      this.log(`live playlist ${index} ${details.advanced ? 'REFRESHED ' + details.lastPartSn + '-' + details.lastPartIndex : details.updated ? 'UPDATED' : 'MISSED'}`);\n      if (!this.canLoad || !details.live) {\n        return;\n      }\n      let deliveryDirectives;\n      let msn = undefined;\n      let part = undefined;\n      if (details.canBlockReload && details.endSN && details.advanced) {\n        // Load level with LL-HLS delivery directives\n        const lowLatencyMode = this.hls.config.lowLatencyMode;\n        const lastPartSn = details.lastPartSn;\n        const endSn = details.endSN;\n        const lastPartIndex = details.lastPartIndex;\n        const hasParts = lastPartIndex !== -1;\n        const atLastPartOfSegment = lastPartSn === endSn;\n        if (hasParts) {\n          // When low latency mode is disabled, request the last part of the next segment\n          if (atLastPartOfSegment) {\n            msn = endSn + 1;\n            part = lowLatencyMode ? 0 : lastPartIndex;\n          } else {\n            msn = lastPartSn;\n            part = lowLatencyMode ? lastPartIndex + 1 : details.maxPartIndex;\n          }\n        } else {\n          msn = endSn + 1;\n        }\n        // Low-Latency CDN Tune-in: \"age\" header and time since load indicates we're behind by more than one part\n        // Update directives to obtain the Playlist that has the estimated additional duration of media\n        const lastAdvanced = details.age;\n        const cdnAge = lastAdvanced + details.ageHeader;\n        let currentGoal = Math.min(cdnAge - details.partTarget, details.targetduration * 1.5);\n        if (currentGoal > 0) {\n          if (cdnAge > details.targetduration * 3) {\n            // Omit segment and part directives when the last response was more than 3 target durations ago,\n            this.log(`Playlist last advanced ${lastAdvanced.toFixed(2)}s ago. Omitting segment and part directives.`);\n            msn = undefined;\n            part = undefined;\n          } else if (previousDetails != null && previousDetails.tuneInGoal && cdnAge - details.partTarget > previousDetails.tuneInGoal) {\n            // If we attempted to get the next or latest playlist update, but currentGoal increased,\n            // then we either can't catchup, or the \"age\" header cannot be trusted.\n            this.warn(`CDN Tune-in goal increased from: ${previousDetails.tuneInGoal} to: ${currentGoal} with playlist age: ${details.age}`);\n            currentGoal = 0;\n          } else {\n            const segments = Math.floor(currentGoal / details.targetduration);\n            msn += segments;\n            if (part !== undefined) {\n              const parts = Math.round(currentGoal % details.targetduration / details.partTarget);\n              part += parts;\n            }\n            this.log(`CDN Tune-in age: ${details.ageHeader}s last advanced ${lastAdvanced.toFixed(2)}s goal: ${currentGoal} skip sn ${segments} to part ${part}`);\n          }\n          details.tuneInGoal = currentGoal;\n        }\n        deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);\n        if (lowLatencyMode || !atLastPartOfSegment) {\n          details.requestScheduled = now;\n          this.loadingPlaylist(levelOrTrack, deliveryDirectives);\n          return;\n        }\n      } else if (details.canBlockReload || details.canSkipUntil) {\n        deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);\n      }\n      if (deliveryDirectives && msn !== undefined && details.canBlockReload) {\n        details.requestScheduled = stats.loading.first + Math.max(reloadInterval - elapsed * 2, reloadInterval / 2);\n      }\n      this.scheduleLoading(levelOrTrack, deliveryDirectives, details);\n    } else {\n      this.clearTimer();\n    }\n  }\n  scheduleLoading(levelOrTrack, deliveryDirectives, updatedDetails) {\n    const details = updatedDetails || levelOrTrack.details;\n    if (!details) {\n      this.loadingPlaylist(levelOrTrack, deliveryDirectives);\n      return;\n    }\n    const now = self.performance.now();\n    const requestScheduled = details.requestScheduled;\n    if (now >= requestScheduled) {\n      this.loadingPlaylist(levelOrTrack, deliveryDirectives);\n      return;\n    }\n    const estimatedTimeUntilUpdate = requestScheduled - now;\n    this.log(`reload live playlist ${levelOrTrack.name || levelOrTrack.bitrate + 'bps'} in ${Math.round(estimatedTimeUntilUpdate)} ms`);\n    this.clearTimer();\n    this.timer = self.setTimeout(() => this.loadingPlaylist(levelOrTrack, deliveryDirectives), estimatedTimeUntilUpdate);\n  }\n  getDeliveryDirectives(details, previousDeliveryDirectives, msn, part) {\n    let skip = getSkipValue(details);\n    if (previousDeliveryDirectives != null && previousDeliveryDirectives.skip && details.deltaUpdateFailed) {\n      msn = previousDeliveryDirectives.msn;\n      part = previousDeliveryDirectives.part;\n      skip = HlsSkip.No;\n    }\n    return new HlsUrlParameters(msn, part, skip);\n  }\n  checkRetry(errorEvent) {\n    const errorDetails = errorEvent.details;\n    const isTimeout = isTimeoutError(errorEvent);\n    const errorAction = errorEvent.errorAction;\n    const {\n      action,\n      retryCount = 0,\n      retryConfig\n    } = errorAction || {};\n    const retry = !!errorAction && !!retryConfig && (action === NetworkErrorAction.RetryRequest || !errorAction.resolved && action === NetworkErrorAction.SendAlternateToPenaltyBox);\n    if (retry) {\n      var _errorEvent$context;\n      if (retryCount >= retryConfig.maxNumRetry) {\n        return false;\n      }\n      if (isTimeout && (_errorEvent$context = errorEvent.context) != null && _errorEvent$context.deliveryDirectives) {\n        // The LL-HLS request already timed out so retry immediately\n        this.warn(`Retrying playlist loading ${retryCount + 1}/${retryConfig.maxNumRetry} after \"${errorDetails}\" without delivery-directives`);\n        this.loadPlaylist();\n      } else {\n        const delay = getRetryDelay(retryConfig, retryCount);\n        // Schedule level/track reload\n        this.clearTimer();\n        this.timer = self.setTimeout(() => this.loadPlaylist(), delay);\n        this.warn(`Retrying playlist loading ${retryCount + 1}/${retryConfig.maxNumRetry} after \"${errorDetails}\" in ${delay}ms`);\n      }\n      // `levelRetry = true` used to inform other controllers that a retry is happening\n      errorEvent.levelRetry = true;\n      errorAction.resolved = true;\n    }\n    return retry;\n  }\n}\n\nfunction subtitleOptionsIdentical(trackList1, trackList2) {\n  if (trackList1.length !== trackList2.length) {\n    return false;\n  }\n  for (let i = 0; i < trackList1.length; i++) {\n    if (!mediaAttributesIdentical(trackList1[i].attrs, trackList2[i].attrs)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction mediaAttributesIdentical(attrs1, attrs2, customAttributes) {\n  // Media options with the same rendition ID must be bit identical\n  const stableRenditionId = attrs1['STABLE-RENDITION-ID'];\n  if (stableRenditionId && !customAttributes) {\n    return stableRenditionId === attrs2['STABLE-RENDITION-ID'];\n  }\n  // When rendition ID is not present, compare attributes\n  return !(customAttributes || ['LANGUAGE', 'NAME', 'CHARACTERISTICS', 'AUTOSELECT', 'DEFAULT', 'FORCED', 'ASSOC-LANGUAGE']).some(subtitleAttribute => attrs1[subtitleAttribute] !== attrs2[subtitleAttribute]);\n}\nfunction subtitleTrackMatchesTextTrack(subtitleTrack, textTrack) {\n  return textTrack.label.toLowerCase() === subtitleTrack.name.toLowerCase() && (!textTrack.language || textTrack.language.toLowerCase() === (subtitleTrack.lang || '').toLowerCase());\n}\n\nclass AudioTrackController extends BasePlaylistController {\n  constructor(hls) {\n    super(hls, 'audio-track-controller');\n    this.tracks = [];\n    this.groupIds = null;\n    this.tracksInGroup = [];\n    this.trackId = -1;\n    this.currentTrack = null;\n    this.selectDefaultTrack = true;\n    this.registerListeners();\n  }\n  registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.on(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n    hls.on(Events.ERROR, this.onError, this);\n  }\n  unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.off(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n    hls.off(Events.ERROR, this.onError, this);\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.tracks.length = 0;\n    this.tracksInGroup.length = 0;\n    this.currentTrack = null;\n    super.destroy();\n  }\n  onManifestLoading() {\n    this.tracks = [];\n    this.tracksInGroup = [];\n    this.groupIds = null;\n    this.currentTrack = null;\n    this.trackId = -1;\n    this.selectDefaultTrack = true;\n  }\n  onManifestParsed(event, data) {\n    this.tracks = data.audioTracks || [];\n  }\n  onAudioTrackLoaded(event, data) {\n    const {\n      id,\n      groupId,\n      details\n    } = data;\n    const trackInActiveGroup = this.tracksInGroup[id];\n    if (!trackInActiveGroup || trackInActiveGroup.groupId !== groupId) {\n      this.warn(`Audio track with id:${id} and group:${groupId} not found in active group ${trackInActiveGroup == null ? void 0 : trackInActiveGroup.groupId}`);\n      return;\n    }\n    const curDetails = trackInActiveGroup.details;\n    trackInActiveGroup.details = data.details;\n    this.log(`Audio track ${id} \"${trackInActiveGroup.name}\" lang:${trackInActiveGroup.lang} group:${groupId} loaded [${details.startSN}-${details.endSN}]`);\n    if (id === this.trackId) {\n      this.playlistLoaded(id, data, curDetails);\n    }\n  }\n  onLevelLoading(event, data) {\n    this.switchLevel(data.level);\n  }\n  onLevelSwitching(event, data) {\n    this.switchLevel(data.level);\n  }\n  switchLevel(levelIndex) {\n    const levelInfo = this.hls.levels[levelIndex];\n    if (!levelInfo) {\n      return;\n    }\n    const audioGroups = levelInfo.audioGroups || null;\n    const currentGroups = this.groupIds;\n    let currentTrack = this.currentTrack;\n    if (!audioGroups || (currentGroups == null ? void 0 : currentGroups.length) !== (audioGroups == null ? void 0 : audioGroups.length) || audioGroups != null && audioGroups.some(groupId => (currentGroups == null ? void 0 : currentGroups.indexOf(groupId)) === -1)) {\n      this.groupIds = audioGroups;\n      this.trackId = -1;\n      this.currentTrack = null;\n      const audioTracks = this.tracks.filter(track => !audioGroups || audioGroups.indexOf(track.groupId) !== -1);\n      if (audioTracks.length) {\n        // Disable selectDefaultTrack if there are no default tracks\n        if (this.selectDefaultTrack && !audioTracks.some(track => track.default)) {\n          this.selectDefaultTrack = false;\n        }\n        // track.id should match hls.audioTracks index\n        audioTracks.forEach((track, i) => {\n          track.id = i;\n        });\n      } else if (!currentTrack && !this.tracksInGroup.length) {\n        // Do not dispatch AUDIO_TRACKS_UPDATED when there were and are no tracks\n        return;\n      }\n      this.tracksInGroup = audioTracks;\n\n      // Find preferred track\n      const audioPreference = this.hls.config.audioPreference;\n      if (!currentTrack && audioPreference) {\n        const groupIndex = findMatchingOption(audioPreference, audioTracks, audioMatchPredicate);\n        if (groupIndex > -1) {\n          currentTrack = audioTracks[groupIndex];\n        } else {\n          const allIndex = findMatchingOption(audioPreference, this.tracks);\n          currentTrack = this.tracks[allIndex];\n        }\n      }\n\n      // Select initial track\n      let trackId = this.findTrackId(currentTrack);\n      if (trackId === -1 && currentTrack) {\n        trackId = this.findTrackId(null);\n      }\n\n      // Dispatch events and load track if needed\n      const audioTracksUpdated = {\n        audioTracks\n      };\n      this.log(`Updating audio tracks, ${audioTracks.length} track(s) found in group(s): ${audioGroups == null ? void 0 : audioGroups.join(',')}`);\n      this.hls.trigger(Events.AUDIO_TRACKS_UPDATED, audioTracksUpdated);\n      const selectedTrackId = this.trackId;\n      if (trackId !== -1 && selectedTrackId === -1) {\n        this.setAudioTrack(trackId);\n      } else if (audioTracks.length && selectedTrackId === -1) {\n        var _this$groupIds;\n        const error = new Error(`No audio track selected for current audio group-ID(s): ${(_this$groupIds = this.groupIds) == null ? void 0 : _this$groupIds.join(',')} track count: ${audioTracks.length}`);\n        this.warn(error.message);\n        this.hls.trigger(Events.ERROR, {\n          type: ErrorTypes.MEDIA_ERROR,\n          details: ErrorDetails.AUDIO_TRACK_LOAD_ERROR,\n          fatal: true,\n          error\n        });\n      }\n    }\n  }\n  onError(event, data) {\n    if (data.fatal || !data.context) {\n      return;\n    }\n    if (data.context.type === PlaylistContextType.AUDIO_TRACK && data.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(data.context.groupId) !== -1)) {\n      this.checkRetry(data);\n    }\n  }\n  get allAudioTracks() {\n    return this.tracks;\n  }\n  get audioTracks() {\n    return this.tracksInGroup;\n  }\n  get audioTrack() {\n    return this.trackId;\n  }\n  set audioTrack(newId) {\n    // If audio track is selected from API then don't choose from the manifest default track\n    this.selectDefaultTrack = false;\n    this.setAudioTrack(newId);\n  }\n  setAudioOption(audioOption) {\n    const hls = this.hls;\n    hls.config.audioPreference = audioOption;\n    if (audioOption) {\n      const allAudioTracks = this.allAudioTracks;\n      this.selectDefaultTrack = false;\n      if (allAudioTracks.length) {\n        // First see if current option matches (no switch op)\n        const currentTrack = this.currentTrack;\n        if (currentTrack && matchesOption(audioOption, currentTrack, audioMatchPredicate)) {\n          return currentTrack;\n        }\n        // Find option in available tracks (tracksInGroup)\n        const groupIndex = findMatchingOption(audioOption, this.tracksInGroup, audioMatchPredicate);\n        if (groupIndex > -1) {\n          const track = this.tracksInGroup[groupIndex];\n          this.setAudioTrack(groupIndex);\n          return track;\n        } else if (currentTrack) {\n          // Find option in nearest level audio group\n          let searchIndex = hls.loadLevel;\n          if (searchIndex === -1) {\n            searchIndex = hls.firstAutoLevel;\n          }\n          const switchIndex = findClosestLevelWithAudioGroup(audioOption, hls.levels, allAudioTracks, searchIndex, audioMatchPredicate);\n          if (switchIndex === -1) {\n            // could not find matching variant\n            return null;\n          }\n          // and switch level to acheive the audio group switch\n          hls.nextLoadLevel = switchIndex;\n        }\n        if (audioOption.channels || audioOption.audioCodec) {\n          // Could not find a match with codec / channels predicate\n          // Find a match without channels or codec\n          const withoutCodecAndChannelsMatch = findMatchingOption(audioOption, allAudioTracks);\n          if (withoutCodecAndChannelsMatch > -1) {\n            return allAudioTracks[withoutCodecAndChannelsMatch];\n          }\n        }\n      }\n    }\n    return null;\n  }\n  setAudioTrack(newId) {\n    const tracks = this.tracksInGroup;\n\n    // check if level idx is valid\n    if (newId < 0 || newId >= tracks.length) {\n      this.warn(`Invalid audio track id: ${newId}`);\n      return;\n    }\n    this.selectDefaultTrack = false;\n    const lastTrack = this.currentTrack;\n    const track = tracks[newId];\n    const trackLoaded = track.details && !track.details.live;\n    if (newId === this.trackId && track === lastTrack && trackLoaded) {\n      return;\n    }\n    this.log(`Switching to audio-track ${newId} \"${track.name}\" lang:${track.lang} group:${track.groupId} channels:${track.channels}`);\n    this.trackId = newId;\n    this.currentTrack = track;\n    this.hls.trigger(Events.AUDIO_TRACK_SWITCHING, _objectSpread2({}, track));\n    // Do not reload track unless live\n    if (trackLoaded) {\n      return;\n    }\n    const hlsUrlParameters = this.switchParams(track.url, lastTrack == null ? void 0 : lastTrack.details, track.details);\n    this.loadPlaylist(hlsUrlParameters);\n  }\n  findTrackId(currentTrack) {\n    const audioTracks = this.tracksInGroup;\n    for (let i = 0; i < audioTracks.length; i++) {\n      const track = audioTracks[i];\n      if (this.selectDefaultTrack && !track.default) {\n        continue;\n      }\n      if (!currentTrack || matchesOption(currentTrack, track, audioMatchPredicate)) {\n        return i;\n      }\n    }\n    if (currentTrack) {\n      const {\n        name,\n        lang,\n        assocLang,\n        characteristics,\n        audioCodec,\n        channels\n      } = currentTrack;\n      for (let i = 0; i < audioTracks.length; i++) {\n        const track = audioTracks[i];\n        if (matchesOption({\n          name,\n          lang,\n          assocLang,\n          characteristics,\n          audioCodec,\n          channels\n        }, track, audioMatchPredicate)) {\n          return i;\n        }\n      }\n      for (let i = 0; i < audioTracks.length; i++) {\n        const track = audioTracks[i];\n        if (mediaAttributesIdentical(currentTrack.attrs, track.attrs, ['LANGUAGE', 'ASSOC-LANGUAGE', 'CHARACTERISTICS'])) {\n          return i;\n        }\n      }\n      for (let i = 0; i < audioTracks.length; i++) {\n        const track = audioTracks[i];\n        if (mediaAttributesIdentical(currentTrack.attrs, track.attrs, ['LANGUAGE'])) {\n          return i;\n        }\n      }\n    }\n    return -1;\n  }\n  loadPlaylist(hlsUrlParameters) {\n    super.loadPlaylist();\n    const audioTrack = this.currentTrack;\n    if (!this.shouldLoadPlaylist(audioTrack)) {\n      return;\n    }\n    // Do not load audio rendition with URI matching main variant URI\n    if (useAlternateAudio(audioTrack.url, this.hls)) {\n      this.scheduleLoading(audioTrack, hlsUrlParameters);\n    }\n  }\n  loadingPlaylist(audioTrack, hlsUrlParameters) {\n    super.loadingPlaylist(audioTrack, hlsUrlParameters);\n    const id = audioTrack.id;\n    const groupId = audioTrack.groupId;\n    const url = this.getUrlWithDirectives(audioTrack.url, hlsUrlParameters);\n    const details = audioTrack.details;\n    const age = details == null ? void 0 : details.age;\n    this.log(`Loading audio-track ${id} \"${audioTrack.name}\" lang:${audioTrack.lang} group:${groupId}${(hlsUrlParameters == null ? void 0 : hlsUrlParameters.msn) !== undefined ? ' at sn ' + hlsUrlParameters.msn + ' part ' + hlsUrlParameters.part : ''}${age && details.live ? ' age ' + age.toFixed(1) + (details.type ? ' ' + details.type || 0 : '') : ''} ${url}`);\n    this.hls.trigger(Events.AUDIO_TRACK_LOADING, {\n      url,\n      id,\n      groupId,\n      deliveryDirectives: hlsUrlParameters || null,\n      track: audioTrack\n    });\n  }\n}\n\nclass BufferOperationQueue {\n  constructor(sourceBufferReference) {\n    this.tracks = void 0;\n    this.queues = {\n      video: [],\n      audio: [],\n      audiovideo: []\n    };\n    this.tracks = sourceBufferReference;\n  }\n  destroy() {\n    this.tracks = this.queues = null;\n  }\n  append(operation, type, pending) {\n    if (this.queues === null || this.tracks === null) {\n      return;\n    }\n    const queue = this.queues[type];\n    queue.push(operation);\n    if (queue.length === 1 && !pending) {\n      this.executeNext(type);\n    }\n  }\n  appendBlocker(type) {\n    return new Promise(resolve => {\n      const operation = {\n        label: 'async-blocker',\n        execute: resolve,\n        onStart: () => {},\n        onComplete: () => {},\n        onError: () => {}\n      };\n      this.append(operation, type);\n    });\n  }\n  prependBlocker(type) {\n    return new Promise(resolve => {\n      if (this.queues) {\n        const operation = {\n          label: 'async-blocker-prepend',\n          execute: resolve,\n          onStart: () => {},\n          onComplete: () => {},\n          onError: () => {}\n        };\n        this.queues[type].unshift(operation);\n      }\n    });\n  }\n  removeBlockers() {\n    if (this.queues === null) {\n      return;\n    }\n    [this.queues.video, this.queues.audio, this.queues.audiovideo].forEach(queue => {\n      var _queue$;\n      const label = (_queue$ = queue[0]) == null ? void 0 : _queue$.label;\n      if (label === 'async-blocker' || label === 'async-blocker-prepend') {\n        queue[0].execute();\n        queue.splice(0, 1);\n      }\n    });\n  }\n  unblockAudio(op) {\n    if (this.queues === null) {\n      return;\n    }\n    const queue = this.queues.audio;\n    if (queue[0] === op) {\n      this.shiftAndExecuteNext('audio');\n    }\n  }\n  executeNext(type) {\n    if (this.queues === null || this.tracks === null) {\n      return;\n    }\n    const queue = this.queues[type];\n    if (queue.length) {\n      const operation = queue[0];\n      try {\n        // Operations are expected to result in an 'updateend' event being fired. If not, the queue will lock. Operations\n        // which do not end with this event must call _onSBUpdateEnd manually\n        operation.execute();\n      } catch (error) {\n        var _this$tracks$type;\n        operation.onError(error);\n        if (this.queues === null || this.tracks === null) {\n          return;\n        }\n\n        // Only shift the current operation off, otherwise the updateend handler will do this for us\n        const sb = (_this$tracks$type = this.tracks[type]) == null ? void 0 : _this$tracks$type.buffer;\n        if (!(sb != null && sb.updating)) {\n          this.shiftAndExecuteNext(type);\n        }\n      }\n    }\n  }\n  shiftAndExecuteNext(type) {\n    if (this.queues === null) {\n      return;\n    }\n    this.queues[type].shift();\n    this.executeNext(type);\n  }\n  current(type) {\n    var _this$queues;\n    return ((_this$queues = this.queues) == null ? void 0 : _this$queues[type][0]) || null;\n  }\n  toString() {\n    const {\n      queues,\n      tracks\n    } = this;\n    if (queues === null || tracks === null) {\n      return `<destroyed>`;\n    }\n    return `\n${this.list('video')}\n${this.list('audio')}\n${this.list('audiovideo')}}`;\n  }\n  list(type) {\n    var _this$queues2, _this$tracks;\n    return (_this$queues2 = this.queues) != null && _this$queues2[type] || (_this$tracks = this.tracks) != null && _this$tracks[type] ? `${type}: (${this.listSbInfo(type)}) ${this.listOps(type)}` : '';\n  }\n  listSbInfo(type) {\n    var _this$tracks2;\n    const track = (_this$tracks2 = this.tracks) == null ? void 0 : _this$tracks2[type];\n    const sb = track == null ? void 0 : track.buffer;\n    if (!sb) {\n      return 'none';\n    }\n    return `SourceBuffer${sb.updating ? ' updating' : ''}${track.ended ? ' ended' : ''}${track.ending ? ' ending' : ''}`;\n  }\n  listOps(type) {\n    var _this$queues3;\n    return ((_this$queues3 = this.queues) == null ? void 0 : _this$queues3[type].map(op => op.label).join(', ')) || '';\n  }\n}\n\nconst VIDEO_CODEC_PROFILE_REPLACE = /(avc[1234]|hvc1|hev1|dvh[1e]|vp09|av01)(?:\\.[^.,]+)+/;\nconst TRACK_REMOVED_ERROR_NAME = 'HlsJsTrackRemovedError';\nclass HlsJsTrackRemovedError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = TRACK_REMOVED_ERROR_NAME;\n  }\n}\nclass BufferController extends Logger {\n  constructor(hls, fragmentTracker) {\n    super('buffer-controller', hls.logger);\n    this.hls = void 0;\n    this.fragmentTracker = void 0;\n    // The level details used to determine duration, target-duration and live\n    this.details = null;\n    // cache the self generated object url to detect hijack of video tag\n    this._objectUrl = null;\n    // A queue of buffer operations which require the SourceBuffer to not be updating upon execution\n    this.operationQueue = null;\n    // The total number track codecs expected before any sourceBuffers are created (2: audio and video or 1: audiovideo | audio | video)\n    this.bufferCodecEventsTotal = 0;\n    // A reference to the attached media element\n    this.media = null;\n    // A reference to the active media source\n    this.mediaSource = null;\n    // Last MP3 audio chunk appended\n    this.lastMpegAudioChunk = null;\n    // Audio fragment blocked from appending until corresponding video appends or context changes\n    this.blockedAudioAppend = null;\n    // Keep track of video append position for unblocking audio\n    this.lastVideoAppendEnd = 0;\n    // Whether or not to use ManagedMediaSource API and append source element to media element.\n    this.appendSource = void 0;\n    // Transferred MediaSource information used to detmerine if duration end endstream may be appended\n    this.transferData = void 0;\n    // Directives used to override default MediaSource handling\n    this.overrides = void 0;\n    // Error counters\n    this.appendErrors = {\n      audio: 0,\n      video: 0,\n      audiovideo: 0\n    };\n    // Record of required or created buffers by type. SourceBuffer is stored in Track.buffer once created.\n    this.tracks = {};\n    // Array of SourceBuffer type and SourceBuffer (or null). One entry per TrackSet in this.tracks.\n    this.sourceBuffers = [[null, null], [null, null]];\n    this._onEndStreaming = event => {\n      var _this$mediaSource;\n      if (!this.hls) {\n        return;\n      }\n      if (((_this$mediaSource = this.mediaSource) == null ? void 0 : _this$mediaSource.readyState) !== 'open') {\n        return;\n      }\n      this.hls.pauseBuffering();\n    };\n    this._onStartStreaming = event => {\n      if (!this.hls) {\n        return;\n      }\n      this.hls.resumeBuffering();\n    };\n    // Keep as arrow functions so that we can directly reference these functions directly as event listeners\n    this._onMediaSourceOpen = e => {\n      const {\n        media,\n        mediaSource\n      } = this;\n      if (e) {\n        this.log('Media source opened');\n      }\n      if (!media || !mediaSource) {\n        return;\n      }\n      // once received, don't listen anymore to sourceopen event\n      mediaSource.removeEventListener('sourceopen', this._onMediaSourceOpen);\n      media.removeEventListener('emptied', this._onMediaEmptied);\n      this.updateDuration();\n      this.hls.trigger(Events.MEDIA_ATTACHED, {\n        media,\n        mediaSource: mediaSource\n      });\n      if (this.mediaSource !== null) {\n        this.checkPendingTracks();\n      }\n    };\n    this._onMediaSourceClose = () => {\n      this.log('Media source closed');\n    };\n    this._onMediaSourceEnded = () => {\n      this.log('Media source ended');\n    };\n    this._onMediaEmptied = () => {\n      const {\n        mediaSrc,\n        _objectUrl\n      } = this;\n      if (mediaSrc !== _objectUrl) {\n        this.error(`Media element src was set while attaching MediaSource (${_objectUrl} > ${mediaSrc})`);\n      }\n    };\n    this.hls = hls;\n    this.fragmentTracker = fragmentTracker;\n    this.appendSource = isManagedMediaSource(getMediaSource(hls.config.preferManagedMediaSource));\n    this.initTracks();\n    this.registerListeners();\n  }\n  hasSourceTypes() {\n    return Object.keys(this.tracks).length > 0;\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.details = null;\n    this.lastMpegAudioChunk = this.blockedAudioAppend = null;\n    this.transferData = this.overrides = undefined;\n    if (this.operationQueue) {\n      this.operationQueue.destroy();\n      this.operationQueue = null;\n    }\n    // @ts-ignore\n    this.hls = this.fragmentTracker = null;\n    // @ts-ignore\n    this._onMediaSourceOpen = this._onMediaSourceClose = null;\n    // @ts-ignore\n    this._onMediaSourceEnded = null;\n    // @ts-ignore\n    this._onStartStreaming = this._onEndStreaming = null;\n  }\n  registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(Events.BUFFER_RESET, this.onBufferReset, this);\n    hls.on(Events.BUFFER_APPENDING, this.onBufferAppending, this);\n    hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n    hls.on(Events.BUFFER_EOS, this.onBufferEos, this);\n    hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    hls.on(Events.FRAG_PARSED, this.onFragParsed, this);\n    hls.on(Events.FRAG_CHANGED, this.onFragChanged, this);\n    hls.on(Events.ERROR, this.onError, this);\n  }\n  unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(Events.BUFFER_RESET, this.onBufferReset, this);\n    hls.off(Events.BUFFER_APPENDING, this.onBufferAppending, this);\n    hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n    hls.off(Events.BUFFER_EOS, this.onBufferEos, this);\n    hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    hls.off(Events.FRAG_PARSED, this.onFragParsed, this);\n    hls.off(Events.FRAG_CHANGED, this.onFragChanged, this);\n    hls.off(Events.ERROR, this.onError, this);\n  }\n  transferMedia() {\n    const {\n      media,\n      mediaSource\n    } = this;\n    if (!media) {\n      return null;\n    }\n    const tracks = {};\n    if (this.operationQueue) {\n      const updating = this.isUpdating();\n      if (!updating) {\n        this.operationQueue.removeBlockers();\n      }\n      const queued = this.isQueued();\n      if (updating || queued) {\n        this.warn(`Transfering MediaSource with${queued ? ' operations in queue' : ''}${updating ? ' updating SourceBuffer(s)' : ''} ${this.operationQueue}`);\n      }\n      this.operationQueue.destroy();\n    }\n    const transferData = this.transferData;\n    if (!this.sourceBufferCount && transferData && transferData.mediaSource === mediaSource) {\n      _extends(tracks, transferData.tracks);\n    } else {\n      this.sourceBuffers.forEach(tuple => {\n        const [type] = tuple;\n        if (type) {\n          tracks[type] = _extends({}, this.tracks[type]);\n          this.removeBuffer(type);\n        }\n        tuple[0] = tuple[1] = null;\n      });\n    }\n    return {\n      media,\n      mediaSource,\n      tracks\n    };\n  }\n  initTracks() {\n    const tracks = {};\n    this.sourceBuffers = [[null, null], [null, null]];\n    this.tracks = tracks;\n    this.resetQueue();\n    this.resetAppendErrors();\n    this.lastMpegAudioChunk = this.blockedAudioAppend = null;\n    this.lastVideoAppendEnd = 0;\n  }\n  onManifestLoading() {\n    this.bufferCodecEventsTotal = 0;\n    this.details = null;\n  }\n  onManifestParsed(event, data) {\n    var _this$transferData;\n    // in case of alt audio 2 BUFFER_CODECS events will be triggered, one per stream controller\n    // sourcebuffers will be created all at once when the expected nb of tracks will be reached\n    // in case alt audio is not used, only one BUFFER_CODEC event will be fired from main stream controller\n    // it will contain the expected nb of source buffers, no need to compute it\n    let codecEvents = 2;\n    if (data.audio && !data.video || !data.altAudio) {\n      codecEvents = 1;\n    }\n    this.bufferCodecEventsTotal = codecEvents;\n    this.log(`${codecEvents} bufferCodec event(s) expected.`);\n    if ((_this$transferData = this.transferData) != null && _this$transferData.mediaSource && this.sourceBufferCount && codecEvents) {\n      this.bufferCreated();\n    }\n  }\n  onMediaAttaching(event, data) {\n    const media = this.media = data.media;\n    const MediaSource = getMediaSource(this.appendSource);\n    this.transferData = this.overrides = undefined;\n    if (media && MediaSource) {\n      const transferringMedia = !!data.mediaSource;\n      if (transferringMedia || data.overrides) {\n        this.transferData = data;\n        this.overrides = data.overrides;\n      }\n      const ms = this.mediaSource = data.mediaSource || new MediaSource();\n      this.assignMediaSource(ms);\n      if (transferringMedia) {\n        this._objectUrl = media.src;\n        this.attachTransferred();\n      } else {\n        // cache the locally generated object url\n        const objectUrl = this._objectUrl = self.URL.createObjectURL(ms);\n        // link video and media Source\n        if (this.appendSource) {\n          try {\n            media.removeAttribute('src');\n            // ManagedMediaSource will not open without disableRemotePlayback set to false or source alternatives\n            const MMS = self.ManagedMediaSource;\n            media.disableRemotePlayback = media.disableRemotePlayback || MMS && ms instanceof MMS;\n            removeSourceChildren(media);\n            addSource(media, objectUrl);\n            media.load();\n          } catch (error) {\n            media.src = objectUrl;\n          }\n        } else {\n          media.src = objectUrl;\n        }\n      }\n      media.addEventListener('emptied', this._onMediaEmptied);\n    }\n  }\n  assignMediaSource(ms) {\n    var _this$transferData2, _ms$constructor;\n    this.log(`${((_this$transferData2 = this.transferData) == null ? void 0 : _this$transferData2.mediaSource) === ms ? 'transferred' : 'created'} media source: ${(_ms$constructor = ms.constructor) == null ? void 0 : _ms$constructor.name}`);\n    // MediaSource listeners are arrow functions with a lexical scope, and do not need to be bound\n    ms.addEventListener('sourceopen', this._onMediaSourceOpen);\n    ms.addEventListener('sourceended', this._onMediaSourceEnded);\n    ms.addEventListener('sourceclose', this._onMediaSourceClose);\n    if (this.appendSource) {\n      ms.addEventListener('startstreaming', this._onStartStreaming);\n      ms.addEventListener('endstreaming', this._onEndStreaming);\n    }\n  }\n  attachTransferred() {\n    const media = this.media;\n    const data = this.transferData;\n    if (!data || !media) {\n      return;\n    }\n    const requiredTracks = this.tracks;\n    const transferredTracks = data.tracks;\n    const trackNames = transferredTracks ? Object.keys(transferredTracks) : null;\n    const trackCount = trackNames ? trackNames.length : 0;\n    const mediaSourceOpenCallback = () => {\n      if (this.media && this.mediaSourceOpenOrEnded) {\n        this._onMediaSourceOpen();\n      }\n    };\n    if (transferredTracks && trackNames && trackCount) {\n      if (!this.tracksReady) {\n        // Wait for CODECS event(s)\n        this.hls.config.startFragPrefetch = true;\n        this.log(`attachTransferred: waiting for SourceBuffer track info`);\n        return;\n      }\n      this.log(`attachTransferred: (bufferCodecEventsTotal ${this.bufferCodecEventsTotal})\nrequired tracks: ${stringify(requiredTracks, (key, value) => key === 'initSegment' ? undefined : value)};\ntransfer tracks: ${stringify(transferredTracks, (key, value) => key === 'initSegment' ? undefined : value)}}`);\n      if (!isCompatibleTrackChange(transferredTracks, requiredTracks)) {\n        // destroy attaching media source\n        data.mediaSource = null;\n        data.tracks = undefined;\n        const currentTime = media.currentTime;\n        const details = this.details;\n        const startTime = Math.max(currentTime, (details == null ? void 0 : details.fragments[0].start) || 0);\n        if (startTime - currentTime > 1) {\n          this.log(`attachTransferred: waiting for playback to reach new tracks start time ${currentTime} -> ${startTime}`);\n          return;\n        }\n        this.warn(`attachTransferred: resetting MediaSource for incompatible tracks (\"${Object.keys(transferredTracks)}\"->\"${Object.keys(requiredTracks)}\") start time: ${startTime} currentTime: ${currentTime}`);\n        this.onMediaDetaching(Events.MEDIA_DETACHING, {});\n        this.onMediaAttaching(Events.MEDIA_ATTACHING, data);\n        media.currentTime = startTime;\n        return;\n      }\n      this.transferData = undefined;\n      trackNames.forEach(trackName => {\n        const type = trackName;\n        const track = transferredTracks[type];\n        if (track) {\n          const sb = track.buffer;\n          if (sb) {\n            // Purge fragment tracker of ejected segments for existing buffer\n            const fragmentTracker = this.fragmentTracker;\n            const playlistType = track.id;\n            if (fragmentTracker.hasFragments(playlistType) || fragmentTracker.hasParts(playlistType)) {\n              const bufferedTimeRanges = BufferHelper.getBuffered(sb);\n              fragmentTracker.detectEvictedFragments(type, bufferedTimeRanges, playlistType, null, true);\n            }\n            // Transfer SourceBuffer\n            const sbIndex = sourceBufferNameToIndex(type);\n            const sbTuple = [type, sb];\n            this.sourceBuffers[sbIndex] = sbTuple;\n            if (sb.updating && this.operationQueue) {\n              this.operationQueue.prependBlocker(type);\n            }\n            this.trackSourceBuffer(type, track);\n          }\n        }\n      });\n      mediaSourceOpenCallback();\n      this.bufferCreated();\n    } else {\n      this.log(`attachTransferred: MediaSource w/o SourceBuffers`);\n      mediaSourceOpenCallback();\n    }\n  }\n  get mediaSourceOpenOrEnded() {\n    var _this$mediaSource2;\n    const readyState = (_this$mediaSource2 = this.mediaSource) == null ? void 0 : _this$mediaSource2.readyState;\n    return readyState === 'open' || readyState === 'ended';\n  }\n  onMediaDetaching(event, data) {\n    const transferringMedia = !!data.transferMedia;\n    this.transferData = this.overrides = undefined;\n    const {\n      media,\n      mediaSource,\n      _objectUrl\n    } = this;\n    if (mediaSource) {\n      this.log(`media source ${transferringMedia ? 'transferring' : 'detaching'}`);\n      if (transferringMedia) {\n        // Detach SourceBuffers without removing from MediaSource\n        // and leave `tracks` (required SourceBuffers configuration)\n        this.sourceBuffers.forEach(([type]) => {\n          if (type) {\n            this.removeBuffer(type);\n          }\n        });\n        this.resetQueue();\n      } else {\n        if (this.mediaSourceOpenOrEnded) {\n          const open = mediaSource.readyState === 'open';\n          try {\n            const sourceBuffers = mediaSource.sourceBuffers;\n            for (let i = sourceBuffers.length; i--;) {\n              if (open) {\n                sourceBuffers[i].abort();\n              }\n              mediaSource.removeSourceBuffer(sourceBuffers[i]);\n            }\n            if (open) {\n              // endOfStream could trigger exception if any sourcebuffer is in updating state\n              // we don't really care about checking sourcebuffer state here,\n              // as we are anyway detaching the MediaSource\n              // let's just avoid this exception to propagate\n              mediaSource.endOfStream();\n            }\n          } catch (err) {\n            this.warn(`onMediaDetaching: ${err.message} while calling endOfStream`);\n          }\n        }\n        // Clean up the SourceBuffers by invoking onBufferReset\n        if (this.sourceBufferCount) {\n          this.onBufferReset();\n        }\n      }\n      mediaSource.removeEventListener('sourceopen', this._onMediaSourceOpen);\n      mediaSource.removeEventListener('sourceended', this._onMediaSourceEnded);\n      mediaSource.removeEventListener('sourceclose', this._onMediaSourceClose);\n      if (this.appendSource) {\n        mediaSource.removeEventListener('startstreaming', this._onStartStreaming);\n        mediaSource.removeEventListener('endstreaming', this._onEndStreaming);\n      }\n      this.mediaSource = null;\n      this._objectUrl = null;\n    }\n\n    // Detach properly the MediaSource from the HTMLMediaElement as\n    // suggested in https://github.com/w3c/media-source/issues/53.\n    if (media) {\n      media.removeEventListener('emptied', this._onMediaEmptied);\n      if (!transferringMedia) {\n        if (_objectUrl) {\n          self.URL.revokeObjectURL(_objectUrl);\n        }\n\n        // clean up video tag src only if it's our own url. some external libraries might\n        // hijack the video tag and change its 'src' without destroying the Hls instance first\n        if (this.mediaSrc === _objectUrl) {\n          media.removeAttribute('src');\n          if (this.appendSource) {\n            removeSourceChildren(media);\n          }\n          media.load();\n        } else {\n          this.warn('media|source.src was changed by a third party - skip cleanup');\n        }\n      }\n      this.media = null;\n    }\n    this.hls.trigger(Events.MEDIA_DETACHED, data);\n  }\n  onBufferReset() {\n    this.sourceBuffers.forEach(([type]) => {\n      if (type) {\n        this.resetBuffer(type);\n      }\n    });\n    this.initTracks();\n  }\n  resetBuffer(type) {\n    var _this$tracks$type;\n    const sb = (_this$tracks$type = this.tracks[type]) == null ? void 0 : _this$tracks$type.buffer;\n    this.removeBuffer(type);\n    if (sb) {\n      try {\n        var _this$mediaSource3;\n        if ((_this$mediaSource3 = this.mediaSource) != null && _this$mediaSource3.sourceBuffers.length) {\n          this.mediaSource.removeSourceBuffer(sb);\n        }\n      } catch (err) {\n        this.warn(`onBufferReset ${type}`, err);\n      }\n    }\n    delete this.tracks[type];\n  }\n  removeBuffer(type) {\n    this.removeBufferListeners(type);\n    this.sourceBuffers[sourceBufferNameToIndex(type)] = [null, null];\n    const track = this.tracks[type];\n    if (track) {\n      track.buffer = undefined;\n    }\n  }\n  resetQueue() {\n    if (this.operationQueue) {\n      this.operationQueue.destroy();\n    }\n    this.operationQueue = new BufferOperationQueue(this.tracks);\n  }\n  onBufferCodecs(event, data) {\n    const tracks = this.tracks;\n    const trackNames = Object.keys(data);\n    this.log(`BUFFER_CODECS: \"${trackNames}\" (current SB count ${this.sourceBufferCount})`);\n    const unmuxedToMuxed = 'audiovideo' in data && (tracks.audio || tracks.video) || tracks.audiovideo && ('audio' in data || 'video' in data);\n    const muxedToUnmuxed = !unmuxedToMuxed && this.sourceBufferCount && this.media && trackNames.some(sbName => !tracks[sbName]);\n    if (unmuxedToMuxed || muxedToUnmuxed) {\n      this.warn(`Unsupported transition between \"${Object.keys(tracks)}\" and \"${trackNames}\" SourceBuffers`);\n      // Do not add incompatible track ('audiovideo' <-> 'video'/'audio').\n      // Allow following onBufferAppending handle to trigger BUFFER_APPEND_ERROR.\n      // This will either be resolved by level switch or could be handled with recoverMediaError().\n      return;\n    }\n    trackNames.forEach(trackName => {\n      var _this$transferData3, _this$transferData3$t, _trackCodec;\n      const parsedTrack = data[trackName];\n      const {\n        id,\n        codec,\n        levelCodec,\n        container,\n        metadata,\n        supplemental\n      } = parsedTrack;\n      let track = tracks[trackName];\n      const transferredTrack = (_this$transferData3 = this.transferData) == null ? void 0 : (_this$transferData3$t = _this$transferData3.tracks) == null ? void 0 : _this$transferData3$t[trackName];\n      const sbTrack = transferredTrack != null && transferredTrack.buffer ? transferredTrack : track;\n      const sbCodec = (sbTrack == null ? void 0 : sbTrack.pendingCodec) || (sbTrack == null ? void 0 : sbTrack.codec);\n      const trackLevelCodec = sbTrack == null ? void 0 : sbTrack.levelCodec;\n      if (!track) {\n        track = tracks[trackName] = {\n          buffer: undefined,\n          listeners: [],\n          codec,\n          supplemental,\n          container,\n          levelCodec,\n          metadata,\n          id\n        };\n      }\n      // check if SourceBuffer codec needs to change\n      const currentCodecFull = pickMostCompleteCodecName(sbCodec, trackLevelCodec);\n      const currentCodec = currentCodecFull == null ? void 0 : currentCodecFull.replace(VIDEO_CODEC_PROFILE_REPLACE, '$1');\n      let trackCodec = pickMostCompleteCodecName(codec, levelCodec);\n      const nextCodec = (_trackCodec = trackCodec) == null ? void 0 : _trackCodec.replace(VIDEO_CODEC_PROFILE_REPLACE, '$1');\n      if (trackCodec && currentCodecFull && currentCodec !== nextCodec) {\n        if (trackName.slice(0, 5) === 'audio') {\n          trackCodec = getCodecCompatibleName(trackCodec, this.appendSource);\n        }\n        this.log(`switching codec ${sbCodec} to ${trackCodec}`);\n        if (trackCodec !== (track.pendingCodec || track.codec)) {\n          track.pendingCodec = trackCodec;\n        }\n        track.container = container;\n        this.appendChangeType(trackName, container, trackCodec);\n      }\n    });\n    if (this.tracksReady || this.sourceBufferCount) {\n      data.tracks = this.sourceBufferTracks;\n    }\n\n    // if sourcebuffers already created, do nothing ...\n    if (this.sourceBufferCount) {\n      return;\n    }\n    if (this.mediaSourceOpenOrEnded) {\n      this.checkPendingTracks();\n    }\n  }\n  get sourceBufferTracks() {\n    return Object.keys(this.tracks).reduce((baseTracks, type) => {\n      const track = this.tracks[type];\n      baseTracks[type] = {\n        id: track.id,\n        container: track.container,\n        codec: track.codec,\n        levelCodec: track.levelCodec\n      };\n      return baseTracks;\n    }, {});\n  }\n  appendChangeType(type, container, codec) {\n    const mimeType = `${container};codecs=${codec}`;\n    const operation = {\n      label: `change-type=${mimeType}`,\n      execute: () => {\n        const track = this.tracks[type];\n        if (track) {\n          const sb = track.buffer;\n          if (sb != null && sb.changeType) {\n            this.log(`changing ${type} sourceBuffer type to ${mimeType}`);\n            sb.changeType(mimeType);\n            track.codec = codec;\n            track.container = container;\n          }\n        }\n        this.shiftAndExecuteNext(type);\n      },\n      onStart: () => {},\n      onComplete: () => {},\n      onError: error => {\n        this.warn(`Failed to change ${type} SourceBuffer type`, error);\n      }\n    };\n    this.append(operation, type, this.isPending(this.tracks[type]));\n  }\n  blockAudio(partOrFrag) {\n    var _this$fragmentTracker;\n    const pStart = partOrFrag.start;\n    const pTime = pStart + partOrFrag.duration * 0.05;\n    const atGap = ((_this$fragmentTracker = this.fragmentTracker.getAppendedFrag(pStart, PlaylistLevelType.MAIN)) == null ? void 0 : _this$fragmentTracker.gap) === true;\n    if (atGap) {\n      return;\n    }\n    const op = {\n      label: 'block-audio',\n      execute: () => {\n        var _this$fragmentTracker2;\n        const videoTrack = this.tracks.video;\n        if (this.lastVideoAppendEnd > pTime || videoTrack != null && videoTrack.buffer && BufferHelper.isBuffered(videoTrack.buffer, pTime) || ((_this$fragmentTracker2 = this.fragmentTracker.getAppendedFrag(pTime, PlaylistLevelType.MAIN)) == null ? void 0 : _this$fragmentTracker2.gap) === true) {\n          this.blockedAudioAppend = null;\n          this.shiftAndExecuteNext('audio');\n        }\n      },\n      onStart: () => {},\n      onComplete: () => {},\n      onError: error => {\n        this.warn('Error executing block-audio operation', error);\n      }\n    };\n    this.blockedAudioAppend = {\n      op,\n      frag: partOrFrag\n    };\n    this.append(op, 'audio', true);\n  }\n  unblockAudio() {\n    const {\n      blockedAudioAppend,\n      operationQueue\n    } = this;\n    if (blockedAudioAppend && operationQueue) {\n      this.blockedAudioAppend = null;\n      operationQueue.unblockAudio(blockedAudioAppend.op);\n    }\n  }\n  onBufferAppending(event, eventData) {\n    const {\n      tracks\n    } = this;\n    const {\n      data,\n      type,\n      parent,\n      frag,\n      part,\n      chunkMeta,\n      offset\n    } = eventData;\n    const chunkStats = chunkMeta.buffering[type];\n    const {\n      sn,\n      cc\n    } = frag;\n    const bufferAppendingStart = self.performance.now();\n    chunkStats.start = bufferAppendingStart;\n    const fragBuffering = frag.stats.buffering;\n    const partBuffering = part ? part.stats.buffering : null;\n    if (fragBuffering.start === 0) {\n      fragBuffering.start = bufferAppendingStart;\n    }\n    if (partBuffering && partBuffering.start === 0) {\n      partBuffering.start = bufferAppendingStart;\n    }\n\n    // TODO: Only update timestampOffset when audio/mpeg fragment or part is not contiguous with previously appended\n    // Adjusting `SourceBuffer.timestampOffset` (desired point in the timeline where the next frames should be appended)\n    // in Chrome browser when we detect MPEG audio container and time delta between level PTS and `SourceBuffer.timestampOffset`\n    // is greater than 100ms (this is enough to handle seek for VOD or level change for LIVE videos).\n    // More info here: https://github.com/video-dev/hls.js/issues/332#issuecomment-257986486\n    const audioTrack = tracks.audio;\n    let checkTimestampOffset = false;\n    if (type === 'audio' && (audioTrack == null ? void 0 : audioTrack.container) === 'audio/mpeg') {\n      checkTimestampOffset = !this.lastMpegAudioChunk || chunkMeta.id === 1 || this.lastMpegAudioChunk.sn !== chunkMeta.sn;\n      this.lastMpegAudioChunk = chunkMeta;\n    }\n\n    // Block audio append until overlapping video append\n    const videoTrack = tracks.video;\n    const videoSb = videoTrack == null ? void 0 : videoTrack.buffer;\n    if (videoSb && sn !== 'initSegment') {\n      const partOrFrag = part || frag;\n      const blockedAudioAppend = this.blockedAudioAppend;\n      if (type === 'audio' && parent !== 'main' && !this.blockedAudioAppend) {\n        const pStart = partOrFrag.start;\n        const pTime = pStart + partOrFrag.duration * 0.05;\n        const vbuffered = videoSb.buffered;\n        const vappending = this.currentOp('video');\n        if (!vbuffered.length && !vappending) {\n          // wait for video before appending audio\n          this.blockAudio(partOrFrag);\n        } else if (!vappending && !BufferHelper.isBuffered(videoSb, pTime) && this.lastVideoAppendEnd < pTime) {\n          // audio is ahead of video\n          this.blockAudio(partOrFrag);\n        }\n      } else if (type === 'video') {\n        const videoAppendEnd = partOrFrag.end;\n        if (blockedAudioAppend) {\n          const audioStart = blockedAudioAppend.frag.start;\n          if (videoAppendEnd > audioStart || videoAppendEnd < this.lastVideoAppendEnd || BufferHelper.isBuffered(videoSb, audioStart)) {\n            this.unblockAudio();\n          }\n        }\n        this.lastVideoAppendEnd = videoAppendEnd;\n      }\n    }\n    const fragStart = (part || frag).start;\n    const operation = {\n      label: `append-${type}`,\n      execute: () => {\n        var _this$tracks$type2;\n        chunkStats.executeStart = self.performance.now();\n        const sb = (_this$tracks$type2 = this.tracks[type]) == null ? void 0 : _this$tracks$type2.buffer;\n        if (sb) {\n          if (checkTimestampOffset) {\n            this.updateTimestampOffset(sb, fragStart, 0.1, type, sn, cc);\n          } else if (offset !== undefined && isFiniteNumber(offset)) {\n            this.updateTimestampOffset(sb, offset, 0.000001, type, sn, cc);\n          }\n        }\n        this.appendExecutor(data, type);\n      },\n      onStart: () => {\n        // logger.debug(`[buffer-controller]: ${type} SourceBuffer updatestart`);\n      },\n      onComplete: () => {\n        // logger.debug(`[buffer-controller]: ${type} SourceBuffer updateend`);\n        const end = self.performance.now();\n        chunkStats.executeEnd = chunkStats.end = end;\n        if (fragBuffering.first === 0) {\n          fragBuffering.first = end;\n        }\n        if (partBuffering && partBuffering.first === 0) {\n          partBuffering.first = end;\n        }\n        const timeRanges = {};\n        this.sourceBuffers.forEach(([type, sb]) => {\n          if (type) {\n            timeRanges[type] = BufferHelper.getBuffered(sb);\n          }\n        });\n        this.appendErrors[type] = 0;\n        if (type === 'audio' || type === 'video') {\n          this.appendErrors.audiovideo = 0;\n        } else {\n          this.appendErrors.audio = 0;\n          this.appendErrors.video = 0;\n        }\n        this.hls.trigger(Events.BUFFER_APPENDED, {\n          type,\n          frag,\n          part,\n          chunkMeta,\n          parent: frag.type,\n          timeRanges\n        });\n      },\n      onError: error => {\n        var _this$media;\n        // in case any error occured while appending, put back segment in segments table\n        const event = {\n          type: ErrorTypes.MEDIA_ERROR,\n          parent: frag.type,\n          details: ErrorDetails.BUFFER_APPEND_ERROR,\n          sourceBufferName: type,\n          frag,\n          part,\n          chunkMeta,\n          error,\n          err: error,\n          fatal: false\n        };\n        const mediaError = (_this$media = this.media) == null ? void 0 : _this$media.error;\n        if (error.code === DOMException.QUOTA_EXCEEDED_ERR || error.name == 'QuotaExceededError' || `quota` in error) {\n          // QuotaExceededError: http://www.w3.org/TR/html5/infrastructure.html#quotaexceedederror\n          // let's stop appending any segments, and report BUFFER_FULL_ERROR error\n          event.details = ErrorDetails.BUFFER_FULL_ERROR;\n        } else if (error.code === DOMException.INVALID_STATE_ERR && this.mediaSourceOpenOrEnded && !mediaError) {\n          // Allow retry for \"Failed to execute 'appendBuffer' on 'SourceBuffer': This SourceBuffer is still processing\" errors\n          event.errorAction = createDoNothingErrorAction(true);\n        } else if (error.name === TRACK_REMOVED_ERROR_NAME && this.sourceBufferCount === 0) {\n          // Do nothing if sourceBuffers were removed (media is detached and append was not aborted)\n          event.errorAction = createDoNothingErrorAction(true);\n        } else {\n          const appendErrorCount = ++this.appendErrors[type];\n          /* with UHD content, we could get loop of quota exceeded error until\n            browser is able to evict some data from sourcebuffer. Retrying can help recover.\n          */\n          this.warn(`Failed ${appendErrorCount}/${this.hls.config.appendErrorMaxRetry} times to append segment in \"${type}\" sourceBuffer (${mediaError ? mediaError : 'no media error'})`);\n          if (appendErrorCount >= this.hls.config.appendErrorMaxRetry || !!mediaError) {\n            event.fatal = true;\n          }\n        }\n        this.hls.trigger(Events.ERROR, event);\n      }\n    };\n    this.append(operation, type, this.isPending(this.tracks[type]));\n  }\n  getFlushOp(type, start, end) {\n    this.log(`queuing \"${type}\" remove ${start}-${end}`);\n    return {\n      label: 'remove',\n      execute: () => {\n        this.removeExecutor(type, start, end);\n      },\n      onStart: () => {\n        // logger.debug(`[buffer-controller]: Started flushing ${data.startOffset} -> ${data.endOffset} for ${type} Source Buffer`);\n      },\n      onComplete: () => {\n        // logger.debug(`[buffer-controller]: Finished flushing ${data.startOffset} -> ${data.endOffset} for ${type} Source Buffer`);\n        this.hls.trigger(Events.BUFFER_FLUSHED, {\n          type\n        });\n      },\n      onError: error => {\n        this.warn(`Failed to remove ${start}-${end} from \"${type}\" SourceBuffer`, error);\n      }\n    };\n  }\n  onBufferFlushing(event, data) {\n    const {\n      type,\n      startOffset,\n      endOffset\n    } = data;\n    if (type) {\n      this.append(this.getFlushOp(type, startOffset, endOffset), type);\n    } else {\n      this.sourceBuffers.forEach(([type]) => {\n        if (type) {\n          this.append(this.getFlushOp(type, startOffset, endOffset), type);\n        }\n      });\n    }\n  }\n  onFragParsed(event, data) {\n    const {\n      frag,\n      part\n    } = data;\n    const buffersAppendedTo = [];\n    const elementaryStreams = part ? part.elementaryStreams : frag.elementaryStreams;\n    if (elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO]) {\n      buffersAppendedTo.push('audiovideo');\n    } else {\n      if (elementaryStreams[ElementaryStreamTypes.AUDIO]) {\n        buffersAppendedTo.push('audio');\n      }\n      if (elementaryStreams[ElementaryStreamTypes.VIDEO]) {\n        buffersAppendedTo.push('video');\n      }\n    }\n    const onUnblocked = () => {\n      const now = self.performance.now();\n      frag.stats.buffering.end = now;\n      if (part) {\n        part.stats.buffering.end = now;\n      }\n      const stats = part ? part.stats : frag.stats;\n      this.hls.trigger(Events.FRAG_BUFFERED, {\n        frag,\n        part,\n        stats,\n        id: frag.type\n      });\n    };\n    if (buffersAppendedTo.length === 0) {\n      this.warn(`Fragments must have at least one ElementaryStreamType set. type: ${frag.type} level: ${frag.level} sn: ${frag.sn}`);\n    }\n    this.blockBuffers(onUnblocked, buffersAppendedTo).catch(error => {\n      this.warn(`Fragment buffered callback ${error}`);\n      this.stepOperationQueue(this.sourceBufferTypes);\n    });\n  }\n  onFragChanged(event, data) {\n    this.trimBuffers();\n  }\n  get bufferedToEnd() {\n    return this.sourceBufferCount > 0 && !this.sourceBuffers.some(([type]) => {\n      var _this$tracks$type3, _this$tracks$type4;\n      return type && (!((_this$tracks$type3 = this.tracks[type]) != null && _this$tracks$type3.ended) || ((_this$tracks$type4 = this.tracks[type]) == null ? void 0 : _this$tracks$type4.ending));\n    });\n  }\n\n  // on BUFFER_EOS mark matching sourcebuffer(s) as \"ending\" and \"ended\" and queue endOfStream after remaining operations(s)\n  // an undefined data.type will mark all buffers as EOS.\n  onBufferEos(event, data) {\n    var _this$overrides;\n    this.sourceBuffers.forEach(([type]) => {\n      if (type) {\n        const track = this.tracks[type];\n        if (!data.type || data.type === type) {\n          track.ending = true;\n          if (!track.ended) {\n            track.ended = true;\n            this.log(`${type} buffer reached EOS`);\n          }\n        }\n      }\n    });\n    const allowEndOfStream = ((_this$overrides = this.overrides) == null ? void 0 : _this$overrides.endOfStream) !== false;\n    const allTracksEnding = this.sourceBufferCount > 0 && !this.sourceBuffers.some(([type]) => {\n      var _this$tracks$type5;\n      return type && !((_this$tracks$type5 = this.tracks[type]) != null && _this$tracks$type5.ended);\n    });\n    if (allTracksEnding) {\n      if (allowEndOfStream) {\n        this.log(`Queueing EOS`);\n        this.blockUntilOpen(() => {\n          this.tracksEnded();\n          const {\n            mediaSource\n          } = this;\n          if (!mediaSource || mediaSource.readyState !== 'open') {\n            if (mediaSource) {\n              this.log(`Could not call mediaSource.endOfStream(). mediaSource.readyState: ${mediaSource.readyState}`);\n            }\n            return;\n          }\n          this.log(`Calling mediaSource.endOfStream()`);\n          // Allow this to throw and be caught by the enqueueing function\n          mediaSource.endOfStream();\n          this.hls.trigger(Events.BUFFERED_TO_END, undefined);\n        });\n      } else {\n        this.tracksEnded();\n        this.hls.trigger(Events.BUFFERED_TO_END, undefined);\n      }\n    }\n  }\n  tracksEnded() {\n    this.sourceBuffers.forEach(([type]) => {\n      if (type !== null) {\n        const track = this.tracks[type];\n        if (track) {\n          track.ending = false;\n        }\n      }\n    });\n  }\n  onLevelUpdated(event, {\n    details\n  }) {\n    if (!details.fragments.length) {\n      return;\n    }\n    this.details = details;\n    this.updateDuration();\n  }\n  updateDuration() {\n    this.blockUntilOpen(() => {\n      const durationAndRange = this.getDurationAndRange();\n      if (!durationAndRange) {\n        return;\n      }\n      this.updateMediaSource(durationAndRange);\n    });\n  }\n  onError(event, data) {\n    if (data.details === ErrorDetails.BUFFER_APPEND_ERROR && data.frag) {\n      var _data$errorAction;\n      const nextAutoLevel = (_data$errorAction = data.errorAction) == null ? void 0 : _data$errorAction.nextAutoLevel;\n      if (isFiniteNumber(nextAutoLevel) && nextAutoLevel !== data.frag.level) {\n        this.resetAppendErrors();\n      }\n    }\n  }\n  resetAppendErrors() {\n    this.appendErrors = {\n      audio: 0,\n      video: 0,\n      audiovideo: 0\n    };\n  }\n  trimBuffers() {\n    const {\n      hls,\n      details,\n      media\n    } = this;\n    if (!media || details === null) {\n      return;\n    }\n    if (!this.sourceBufferCount) {\n      return;\n    }\n    const config = hls.config;\n    const currentTime = media.currentTime;\n    const targetDuration = details.levelTargetDuration;\n\n    // Support for deprecated liveBackBufferLength\n    const backBufferLength = details.live && config.liveBackBufferLength !== null ? config.liveBackBufferLength : config.backBufferLength;\n    if (isFiniteNumber(backBufferLength) && backBufferLength >= 0) {\n      const maxBackBufferLength = Math.max(backBufferLength, targetDuration);\n      const targetBackBufferPosition = Math.floor(currentTime / targetDuration) * targetDuration - maxBackBufferLength;\n      this.flushBackBuffer(currentTime, targetDuration, targetBackBufferPosition);\n    }\n    if (isFiniteNumber(config.frontBufferFlushThreshold) && config.frontBufferFlushThreshold > 0) {\n      const frontBufferLength = Math.max(config.maxBufferLength, config.frontBufferFlushThreshold);\n      const maxFrontBufferLength = Math.max(frontBufferLength, targetDuration);\n      const targetFrontBufferPosition = Math.floor(currentTime / targetDuration) * targetDuration + maxFrontBufferLength;\n      this.flushFrontBuffer(currentTime, targetDuration, targetFrontBufferPosition);\n    }\n  }\n  flushBackBuffer(currentTime, targetDuration, targetBackBufferPosition) {\n    this.sourceBuffers.forEach(([type, sb]) => {\n      if (sb) {\n        const buffered = BufferHelper.getBuffered(sb);\n        // when target buffer start exceeds actual buffer start\n        if (buffered.length > 0 && targetBackBufferPosition > buffered.start(0)) {\n          var _this$details;\n          this.hls.trigger(Events.BACK_BUFFER_REACHED, {\n            bufferEnd: targetBackBufferPosition\n          });\n\n          // Support for deprecated event:\n          const track = this.tracks[type];\n          if ((_this$details = this.details) != null && _this$details.live) {\n            this.hls.trigger(Events.LIVE_BACK_BUFFER_REACHED, {\n              bufferEnd: targetBackBufferPosition\n            });\n          } else if (track != null && track.ended) {\n            this.log(`Cannot flush ${type} back buffer while SourceBuffer is in ended state`);\n            return;\n          }\n          this.hls.trigger(Events.BUFFER_FLUSHING, {\n            startOffset: 0,\n            endOffset: targetBackBufferPosition,\n            type\n          });\n        }\n      }\n    });\n  }\n  flushFrontBuffer(currentTime, targetDuration, targetFrontBufferPosition) {\n    this.sourceBuffers.forEach(([type, sb]) => {\n      if (sb) {\n        const buffered = BufferHelper.getBuffered(sb);\n        const numBufferedRanges = buffered.length;\n        // The buffer is either empty or contiguous\n        if (numBufferedRanges < 2) {\n          return;\n        }\n        const bufferStart = buffered.start(numBufferedRanges - 1);\n        const bufferEnd = buffered.end(numBufferedRanges - 1);\n        // No flush if we can tolerate the current buffer length or the current buffer range we would flush is contiguous with current position\n        if (targetFrontBufferPosition > bufferStart || currentTime >= bufferStart && currentTime <= bufferEnd) {\n          return;\n        }\n        this.hls.trigger(Events.BUFFER_FLUSHING, {\n          startOffset: bufferStart,\n          endOffset: Infinity,\n          type\n        });\n      }\n    });\n  }\n\n  /**\n   * Update Media Source duration to current level duration or override to Infinity if configuration parameter\n   * 'liveDurationInfinity` is set to `true`\n   * More details: https://github.com/video-dev/hls.js/issues/355\n   */\n  getDurationAndRange() {\n    var _this$overrides2;\n    const {\n      details,\n      mediaSource\n    } = this;\n    if (!details || !this.media || (mediaSource == null ? void 0 : mediaSource.readyState) !== 'open') {\n      return null;\n    }\n    const playlistEnd = details.edge;\n    if (details.live && this.hls.config.liveDurationInfinity) {\n      const len = details.fragments.length;\n      if (len && details.live && !!mediaSource.setLiveSeekableRange) {\n        const start = Math.max(0, details.fragmentStart);\n        const end = Math.max(start, playlistEnd);\n        return {\n          duration: Infinity,\n          start,\n          end\n        };\n      }\n      return {\n        duration: Infinity\n      };\n    }\n    const overrideDuration = (_this$overrides2 = this.overrides) == null ? void 0 : _this$overrides2.duration;\n    if (overrideDuration) {\n      if (!isFiniteNumber(overrideDuration)) {\n        return null;\n      }\n      return {\n        duration: overrideDuration\n      };\n    }\n    const mediaDuration = this.media.duration;\n    const msDuration = isFiniteNumber(mediaSource.duration) ? mediaSource.duration : 0;\n    if (playlistEnd > msDuration && playlistEnd > mediaDuration || !isFiniteNumber(mediaDuration)) {\n      return {\n        duration: playlistEnd\n      };\n    }\n    return null;\n  }\n  updateMediaSource({\n    duration,\n    start,\n    end\n  }) {\n    const mediaSource = this.mediaSource;\n    if (!this.media || !mediaSource || mediaSource.readyState !== 'open') {\n      return;\n    }\n    if (mediaSource.duration !== duration) {\n      if (isFiniteNumber(duration)) {\n        this.log(`Updating MediaSource duration to ${duration.toFixed(3)}`);\n      }\n      mediaSource.duration = duration;\n    }\n    if (start !== undefined && end !== undefined) {\n      this.log(`MediaSource duration is set to ${mediaSource.duration}. Setting seekable range to ${start}-${end}.`);\n      mediaSource.setLiveSeekableRange(start, end);\n    }\n  }\n  get tracksReady() {\n    const pendingTrackCount = this.pendingTrackCount;\n    return pendingTrackCount > 0 && (pendingTrackCount >= this.bufferCodecEventsTotal || this.isPending(this.tracks.audiovideo));\n  }\n  checkPendingTracks() {\n    const {\n      bufferCodecEventsTotal,\n      pendingTrackCount,\n      tracks\n    } = this;\n    this.log(`checkPendingTracks (pending: ${pendingTrackCount} codec events expected: ${bufferCodecEventsTotal}) ${stringify(tracks)}`);\n    // Check if we've received all of the expected bufferCodec events. When none remain, create all the sourceBuffers at once.\n    // This is important because the MSE spec allows implementations to throw QuotaExceededErrors if creating new sourceBuffers after\n    // data has been appended to existing ones.\n    // 2 tracks is the max (one for audio, one for video). If we've reach this max go ahead and create the buffers.\n    if (this.tracksReady) {\n      var _this$transferData4;\n      const transferredTracks = (_this$transferData4 = this.transferData) == null ? void 0 : _this$transferData4.tracks;\n      if (transferredTracks && Object.keys(transferredTracks).length) {\n        this.attachTransferred();\n      } else {\n        // ok, let's create them now !\n        this.createSourceBuffers();\n      }\n    }\n  }\n  bufferCreated() {\n    if (this.sourceBufferCount) {\n      const tracks = {};\n      this.sourceBuffers.forEach(([type, buffer]) => {\n        if (type) {\n          const track = this.tracks[type];\n          tracks[type] = {\n            buffer,\n            container: track.container,\n            codec: track.codec,\n            supplemental: track.supplemental,\n            levelCodec: track.levelCodec,\n            id: track.id,\n            metadata: track.metadata\n          };\n        }\n      });\n      this.hls.trigger(Events.BUFFER_CREATED, {\n        tracks\n      });\n      this.log(`SourceBuffers created. Running queue: ${this.operationQueue}`);\n      this.sourceBuffers.forEach(([type]) => {\n        this.executeNext(type);\n      });\n    } else {\n      const error = new Error('could not create source buffer for media codec(s)');\n      this.hls.trigger(Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.BUFFER_INCOMPATIBLE_CODECS_ERROR,\n        fatal: true,\n        error,\n        reason: error.message\n      });\n    }\n  }\n  createSourceBuffers() {\n    const {\n      tracks,\n      sourceBuffers,\n      mediaSource\n    } = this;\n    if (!mediaSource) {\n      throw new Error('createSourceBuffers called when mediaSource was null');\n    }\n    for (const trackName in tracks) {\n      const type = trackName;\n      const track = tracks[type];\n      if (this.isPending(track)) {\n        const codec = this.getTrackCodec(track, type);\n        const mimeType = `${track.container};codecs=${codec}`;\n        track.codec = codec;\n        this.log(`creating sourceBuffer(${mimeType})${this.currentOp(type) ? ' Queued' : ''} ${stringify(track)}`);\n        try {\n          const sb = mediaSource.addSourceBuffer(mimeType);\n          const sbIndex = sourceBufferNameToIndex(type);\n          const sbTuple = [type, sb];\n          sourceBuffers[sbIndex] = sbTuple;\n          track.buffer = sb;\n        } catch (error) {\n          var _this$operationQueue;\n          this.error(`error while trying to add sourceBuffer: ${error.message}`);\n          // remove init segment from queue and delete track info\n          this.shiftAndExecuteNext(type);\n          (_this$operationQueue = this.operationQueue) == null ? void 0 : _this$operationQueue.removeBlockers();\n          delete this.tracks[type];\n          this.hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.BUFFER_ADD_CODEC_ERROR,\n            fatal: false,\n            error,\n            sourceBufferName: type,\n            mimeType: mimeType,\n            parent: track.id\n          });\n          return;\n        }\n        this.trackSourceBuffer(type, track);\n      }\n    }\n    this.bufferCreated();\n  }\n  getTrackCodec(track, trackName) {\n    // Use supplemental video codec when supported when adding SourceBuffer (#5558)\n    const supplementalCodec = track.supplemental;\n    let trackCodec = track.codec;\n    if (supplementalCodec && (trackName === 'video' || trackName === 'audiovideo') && areCodecsMediaSourceSupported(supplementalCodec, 'video')) {\n      trackCodec = replaceVideoCodec(trackCodec, supplementalCodec);\n    }\n    const codec = pickMostCompleteCodecName(trackCodec, track.levelCodec);\n    if (codec) {\n      if (trackName.slice(0, 5) === 'audio') {\n        return getCodecCompatibleName(codec, this.appendSource);\n      }\n      return codec;\n    }\n    return '';\n  }\n  trackSourceBuffer(type, track) {\n    const buffer = track.buffer;\n    if (!buffer) {\n      return;\n    }\n    const codec = this.getTrackCodec(track, type);\n    this.tracks[type] = {\n      buffer,\n      codec,\n      container: track.container,\n      levelCodec: track.levelCodec,\n      supplemental: track.supplemental,\n      metadata: track.metadata,\n      id: track.id,\n      listeners: []\n    };\n    this.removeBufferListeners(type);\n    this.addBufferListener(type, 'updatestart', this.onSBUpdateStart);\n    this.addBufferListener(type, 'updateend', this.onSBUpdateEnd);\n    this.addBufferListener(type, 'error', this.onSBUpdateError);\n    // ManagedSourceBuffer bufferedchange event\n    if (this.appendSource) {\n      this.addBufferListener(type, 'bufferedchange', (type, event) => {\n        // If media was ejected check for a change. Added ranges are redundant with changes on 'updateend' event.\n        const removedRanges = event.removedRanges;\n        if (removedRanges != null && removedRanges.length) {\n          this.hls.trigger(Events.BUFFER_FLUSHED, {\n            type: type\n          });\n        }\n      });\n    }\n  }\n  get mediaSrc() {\n    var _this$media2, _this$media2$querySel;\n    const media = ((_this$media2 = this.media) == null ? void 0 : (_this$media2$querySel = _this$media2.querySelector) == null ? void 0 : _this$media2$querySel.call(_this$media2, 'source')) || this.media;\n    return media == null ? void 0 : media.src;\n  }\n  onSBUpdateStart(type) {\n    const operation = this.currentOp(type);\n    if (!operation) {\n      return;\n    }\n    operation.onStart();\n  }\n  onSBUpdateEnd(type) {\n    var _this$mediaSource4;\n    if (((_this$mediaSource4 = this.mediaSource) == null ? void 0 : _this$mediaSource4.readyState) === 'closed') {\n      this.resetBuffer(type);\n      return;\n    }\n    const operation = this.currentOp(type);\n    if (!operation) {\n      return;\n    }\n    operation.onComplete();\n    this.shiftAndExecuteNext(type);\n  }\n  onSBUpdateError(type, event) {\n    var _this$mediaSource5;\n    const error = new Error(`${type} SourceBuffer error. MediaSource readyState: ${(_this$mediaSource5 = this.mediaSource) == null ? void 0 : _this$mediaSource5.readyState}`);\n    this.error(`${error}`, event);\n    // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error\n    // SourceBuffer errors are not necessarily fatal; if so, the HTMLMediaElement will fire an error event\n    this.hls.trigger(Events.ERROR, {\n      type: ErrorTypes.MEDIA_ERROR,\n      details: ErrorDetails.BUFFER_APPENDING_ERROR,\n      sourceBufferName: type,\n      error,\n      fatal: false\n    });\n    // updateend is always fired after error, so we'll allow that to shift the current operation off of the queue\n    const operation = this.currentOp(type);\n    if (operation) {\n      operation.onError(error);\n    }\n  }\n  updateTimestampOffset(sb, timestampOffset, tolerance, type, sn, cc) {\n    const delta = timestampOffset - sb.timestampOffset;\n    if (Math.abs(delta) >= tolerance) {\n      this.log(`Updating ${type} SourceBuffer timestampOffset to ${timestampOffset} (sn: ${sn} cc: ${cc})`);\n      sb.timestampOffset = timestampOffset;\n    }\n  }\n\n  // This method must result in an updateend event; if remove is not called, onSBUpdateEnd must be called manually\n  removeExecutor(type, startOffset, endOffset) {\n    const {\n      media,\n      mediaSource\n    } = this;\n    const track = this.tracks[type];\n    const sb = track == null ? void 0 : track.buffer;\n    if (!media || !mediaSource || !sb) {\n      this.warn(`Attempting to remove from the ${type} SourceBuffer, but it does not exist`);\n      this.shiftAndExecuteNext(type);\n      return;\n    }\n    const mediaDuration = isFiniteNumber(media.duration) ? media.duration : Infinity;\n    const msDuration = isFiniteNumber(mediaSource.duration) ? mediaSource.duration : Infinity;\n    const removeStart = Math.max(0, startOffset);\n    const removeEnd = Math.min(endOffset, mediaDuration, msDuration);\n    if (removeEnd > removeStart && (!track.ending || track.ended)) {\n      track.ended = false;\n      this.log(`Removing [${removeStart},${removeEnd}] from the ${type} SourceBuffer`);\n      sb.remove(removeStart, removeEnd);\n    } else {\n      // Cycle the queue\n      this.shiftAndExecuteNext(type);\n    }\n  }\n\n  // This method must result in an updateend event; if append is not called, onSBUpdateEnd must be called manually\n  appendExecutor(data, type) {\n    const track = this.tracks[type];\n    const sb = track == null ? void 0 : track.buffer;\n    if (!sb) {\n      throw new HlsJsTrackRemovedError(`Attempting to append to the ${type} SourceBuffer, but it does not exist`);\n    }\n    track.ending = false;\n    track.ended = false;\n    sb.appendBuffer(data);\n  }\n  blockUntilOpen(callback) {\n    if (this.isUpdating() || this.isQueued()) {\n      this.blockBuffers(callback).catch(error => {\n        this.warn(`SourceBuffer blocked callback ${error}`);\n        this.stepOperationQueue(this.sourceBufferTypes);\n      });\n    } else {\n      try {\n        callback();\n      } catch (error) {\n        this.warn(`Callback run without blocking ${this.operationQueue} ${error}`);\n      }\n    }\n  }\n  isUpdating() {\n    return this.sourceBuffers.some(([type, sb]) => type && sb.updating);\n  }\n  isQueued() {\n    return this.sourceBuffers.some(([type]) => type && !!this.currentOp(type));\n  }\n  isPending(track) {\n    return !!track && !track.buffer;\n  }\n\n  // Enqueues an operation to each SourceBuffer queue which, upon execution, resolves a promise. When all promises\n  // resolve, the onUnblocked function is executed. Functions calling this method do not need to unblock the queue\n  // upon completion, since we already do it here\n  blockBuffers(onUnblocked, bufferNames = this.sourceBufferTypes) {\n    if (!bufferNames.length) {\n      this.log('Blocking operation requested, but no SourceBuffers exist');\n      return Promise.resolve().then(onUnblocked);\n    }\n    const {\n      operationQueue\n    } = this;\n\n    // logger.debug(`[buffer-controller]: Blocking ${buffers} SourceBuffer`);\n    const blockingOperations = bufferNames.map(type => this.appendBlocker(type));\n    const audioBlocked = bufferNames.length > 1 && !!this.blockedAudioAppend;\n    if (audioBlocked) {\n      this.unblockAudio();\n    }\n    return Promise.all(blockingOperations).then(result => {\n      if (operationQueue !== this.operationQueue) {\n        return;\n      }\n      // logger.debug(`[buffer-controller]: Blocking operation resolved; unblocking ${buffers} SourceBuffer`);\n      onUnblocked();\n      this.stepOperationQueue(this.sourceBufferTypes);\n    });\n  }\n  stepOperationQueue(bufferNames) {\n    bufferNames.forEach(type => {\n      var _this$tracks$type6;\n      const sb = (_this$tracks$type6 = this.tracks[type]) == null ? void 0 : _this$tracks$type6.buffer;\n      // Only cycle the queue if the SB is not updating. There's a bug in Chrome which sets the SB updating flag to\n      // true when changing the MediaSource duration (https://bugs.chromium.org/p/chromium/issues/detail?id=959359&can=2&q=mediasource%20duration)\n      // While this is a workaround, it's probably useful to have around\n      if (!sb || sb.updating) {\n        return;\n      }\n      this.shiftAndExecuteNext(type);\n    });\n  }\n  append(operation, type, pending) {\n    if (this.operationQueue) {\n      this.operationQueue.append(operation, type, pending);\n    }\n  }\n  appendBlocker(type) {\n    if (this.operationQueue) {\n      return this.operationQueue.appendBlocker(type);\n    }\n  }\n  currentOp(type) {\n    if (this.operationQueue) {\n      return this.operationQueue.current(type);\n    }\n    return null;\n  }\n  executeNext(type) {\n    if (type && this.operationQueue) {\n      this.operationQueue.executeNext(type);\n    }\n  }\n  shiftAndExecuteNext(type) {\n    if (this.operationQueue) {\n      this.operationQueue.shiftAndExecuteNext(type);\n    }\n  }\n  get pendingTrackCount() {\n    return Object.keys(this.tracks).reduce((acc, type) => acc + (this.isPending(this.tracks[type]) ? 1 : 0), 0);\n  }\n  get sourceBufferCount() {\n    return this.sourceBuffers.reduce((acc, [type]) => acc + (type ? 1 : 0), 0);\n  }\n  get sourceBufferTypes() {\n    return this.sourceBuffers.map(([type]) => type).filter(type => !!type);\n  }\n  addBufferListener(type, event, fn) {\n    const track = this.tracks[type];\n    if (!track) {\n      return;\n    }\n    const buffer = track.buffer;\n    if (!buffer) {\n      return;\n    }\n    const listener = fn.bind(this, type);\n    track.listeners.push({\n      event,\n      listener\n    });\n    buffer.addEventListener(event, listener);\n  }\n  removeBufferListeners(type) {\n    const track = this.tracks[type];\n    if (!track) {\n      return;\n    }\n    const buffer = track.buffer;\n    if (!buffer) {\n      return;\n    }\n    track.listeners.forEach(l => {\n      buffer.removeEventListener(l.event, l.listener);\n    });\n    track.listeners.length = 0;\n  }\n}\nfunction removeSourceChildren(node) {\n  const sourceChildren = node.querySelectorAll('source');\n  [].slice.call(sourceChildren).forEach(source => {\n    node.removeChild(source);\n  });\n}\nfunction addSource(media, url) {\n  const source = self.document.createElement('source');\n  source.type = 'video/mp4';\n  source.src = url;\n  media.appendChild(source);\n}\nfunction sourceBufferNameToIndex(type) {\n  return type === 'audio' ? 1 : 0;\n}\n\nclass CapLevelController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.autoLevelCapping = void 0;\n    this.firstLevel = void 0;\n    this.media = void 0;\n    this.restrictedLevels = void 0;\n    this.timer = void 0;\n    this.clientRect = void 0;\n    this.streamController = void 0;\n    this.hls = hls;\n    this.autoLevelCapping = Number.POSITIVE_INFINITY;\n    this.firstLevel = -1;\n    this.media = null;\n    this.restrictedLevels = [];\n    this.timer = undefined;\n    this.clientRect = null;\n    this.registerListeners();\n  }\n  setStreamController(streamController) {\n    this.streamController = streamController;\n  }\n  destroy() {\n    if (this.hls) {\n      this.unregisterListener();\n    }\n    if (this.timer) {\n      this.stopCapping();\n    }\n    this.media = null;\n    this.clientRect = null;\n    // @ts-ignore\n    this.hls = this.streamController = null;\n  }\n  registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);\n    hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n  }\n  unregisterListener() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);\n    hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n  }\n  onFpsDropLevelCapping(event, data) {\n    // Don't add a restricted level more than once\n    const level = this.hls.levels[data.droppedLevel];\n    if (this.isLevelAllowed(level)) {\n      this.restrictedLevels.push({\n        bitrate: level.bitrate,\n        height: level.height,\n        width: level.width\n      });\n    }\n  }\n  onMediaAttaching(event, data) {\n    this.media = data.media instanceof HTMLVideoElement ? data.media : null;\n    this.clientRect = null;\n    if (this.timer && this.hls.levels.length) {\n      this.detectPlayerSize();\n    }\n  }\n  onManifestParsed(event, data) {\n    const hls = this.hls;\n    this.restrictedLevels = [];\n    this.firstLevel = data.firstLevel;\n    if (hls.config.capLevelToPlayerSize && data.video) {\n      // Start capping immediately if the manifest has signaled video codecs\n      this.startCapping();\n    }\n  }\n  onLevelsUpdated(event, data) {\n    if (this.timer && isFiniteNumber(this.autoLevelCapping)) {\n      this.detectPlayerSize();\n    }\n  }\n\n  // Only activate capping when playing a video stream; otherwise, multi-bitrate audio-only streams will be restricted\n  // to the first level\n  onBufferCodecs(event, data) {\n    const hls = this.hls;\n    if (hls.config.capLevelToPlayerSize && data.video) {\n      // If the manifest did not signal a video codec capping has been deferred until we're certain video is present\n      this.startCapping();\n    }\n  }\n  onMediaDetaching() {\n    this.stopCapping();\n    this.media = null;\n  }\n  detectPlayerSize() {\n    if (this.media) {\n      if (this.mediaHeight <= 0 || this.mediaWidth <= 0) {\n        this.clientRect = null;\n        return;\n      }\n      const levels = this.hls.levels;\n      if (levels.length) {\n        const hls = this.hls;\n        const maxLevel = this.getMaxLevel(levels.length - 1);\n        if (maxLevel !== this.autoLevelCapping) {\n          hls.logger.log(`Setting autoLevelCapping to ${maxLevel}: ${levels[maxLevel].height}p@${levels[maxLevel].bitrate} for media ${this.mediaWidth}x${this.mediaHeight}`);\n        }\n        hls.autoLevelCapping = maxLevel;\n        if (hls.autoLevelEnabled && hls.autoLevelCapping > this.autoLevelCapping && this.streamController) {\n          // if auto level capping has a higher value for the previous one, flush the buffer using nextLevelSwitch\n          // usually happen when the user go to the fullscreen mode.\n          this.streamController.nextLevelSwitch();\n        }\n        this.autoLevelCapping = hls.autoLevelCapping;\n      }\n    }\n  }\n\n  /*\n   * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)\n   */\n  getMaxLevel(capLevelIndex) {\n    const levels = this.hls.levels;\n    if (!levels.length) {\n      return -1;\n    }\n    const validLevels = levels.filter((level, index) => this.isLevelAllowed(level) && index <= capLevelIndex);\n    this.clientRect = null;\n    return CapLevelController.getMaxLevelByMediaSize(validLevels, this.mediaWidth, this.mediaHeight);\n  }\n  startCapping() {\n    if (this.timer) {\n      // Don't reset capping if started twice; this can happen if the manifest signals a video codec\n      return;\n    }\n    this.autoLevelCapping = Number.POSITIVE_INFINITY;\n    self.clearInterval(this.timer);\n    this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1000);\n    this.detectPlayerSize();\n  }\n  stopCapping() {\n    this.restrictedLevels = [];\n    this.firstLevel = -1;\n    this.autoLevelCapping = Number.POSITIVE_INFINITY;\n    if (this.timer) {\n      self.clearInterval(this.timer);\n      this.timer = undefined;\n    }\n  }\n  getDimensions() {\n    if (this.clientRect) {\n      return this.clientRect;\n    }\n    const media = this.media;\n    const boundsRect = {\n      width: 0,\n      height: 0\n    };\n    if (media) {\n      const clientRect = media.getBoundingClientRect();\n      boundsRect.width = clientRect.width;\n      boundsRect.height = clientRect.height;\n      if (!boundsRect.width && !boundsRect.height) {\n        // When the media element has no width or height (equivalent to not being in the DOM),\n        // then use its width and height attributes (media.width, media.height)\n        boundsRect.width = clientRect.right - clientRect.left || media.width || 0;\n        boundsRect.height = clientRect.bottom - clientRect.top || media.height || 0;\n      }\n    }\n    this.clientRect = boundsRect;\n    return boundsRect;\n  }\n  get mediaWidth() {\n    return this.getDimensions().width * this.contentScaleFactor;\n  }\n  get mediaHeight() {\n    return this.getDimensions().height * this.contentScaleFactor;\n  }\n  get contentScaleFactor() {\n    let pixelRatio = 1;\n    if (!this.hls.config.ignoreDevicePixelRatio) {\n      try {\n        pixelRatio = self.devicePixelRatio;\n      } catch (e) {\n        /* no-op */\n      }\n    }\n    return Math.min(pixelRatio, this.hls.config.maxDevicePixelRatio);\n  }\n  isLevelAllowed(level) {\n    const restrictedLevels = this.restrictedLevels;\n    return !restrictedLevels.some(restrictedLevel => {\n      return level.bitrate === restrictedLevel.bitrate && level.width === restrictedLevel.width && level.height === restrictedLevel.height;\n    });\n  }\n  static getMaxLevelByMediaSize(levels, width, height) {\n    if (!(levels != null && levels.length)) {\n      return -1;\n    }\n\n    // Levels can have the same dimensions but differing bandwidths - since levels are ordered, we can look to the next\n    // to determine whether we've chosen the greatest bandwidth for the media's dimensions\n    const atGreatestBandwidth = (curLevel, nextLevel) => {\n      if (!nextLevel) {\n        return true;\n      }\n      return curLevel.width !== nextLevel.width || curLevel.height !== nextLevel.height;\n    };\n\n    // If we run through the loop without breaking, the media's dimensions are greater than every level, so default to\n    // the max level\n    let maxLevelIndex = levels.length - 1;\n    // Prevent changes in aspect-ratio from causing capping to toggle back and forth\n    const squareSize = Math.max(width, height);\n    for (let i = 0; i < levels.length; i += 1) {\n      const level = levels[i];\n      if ((level.width >= squareSize || level.height >= squareSize) && atGreatestBandwidth(level, levels[i + 1])) {\n        maxLevelIndex = i;\n        break;\n      }\n    }\n    return maxLevelIndex;\n  }\n}\n\n/**\n * Common Media Object Type\n *\n * @internal\n */\nconst CmObjectType = {\n  /**\n   * text file, such as a manifest or playlist\n   */\n  MANIFEST: 'm',\n  /**\n   * audio only\n   */\n  AUDIO: 'a',\n  /**\n   * video only\n   */\n  VIDEO: 'v',\n  /**\n   * muxed audio and video\n   */\n  MUXED: 'av',\n  /**\n   * init segment\n   */\n  INIT: 'i',\n  /**\n   * caption or subtitle\n   */\n  CAPTION: 'c',\n  /**\n   * ISOBMFF timed text track\n   */\n  TIMED_TEXT: 'tt',\n  /**\n   * cryptographic key, license or certificate.\n   */\n  KEY: 'k',\n  /**\n   * other\n   */\n  OTHER: 'o'\n};\n\n/**\n * Common Media Client Data Object Type\n *\n * @group CMCD\n *\n * @beta\n *\n * @enum\n */\nconst CmcdObjectType = CmObjectType;\n\n/**\n * Common Media Streaming Format\n *\n * @internal\n */\nconst CmStreamingFormat = {\n  /**\n   * HTTP Live Streaming (HLS)\n   */\n  HLS: 'h'};\n\n/**\n * Common Media Client Data Streaming Format\n *\n * @group CMCD\n *\n * @enum\n *\n * @beta\n */\nconst CmcdStreamingFormat = CmStreamingFormat;\n\n/**\n * CMCD object header name.\n *\n * @group CMCD\n *\n * @beta\n */\nconst CMCD_OBJECT = 'CMCD-Object';\n\n/**\n * CMCD request header name.\n *\n * @group CMCD\n *\n * @beta\n */\nconst CMCD_REQUEST = 'CMCD-Request';\n\n/**\n * CMCD session header name.\n *\n * @group CMCD\n *\n * @beta\n */\nconst CMCD_SESSION = 'CMCD-Session';\n\n/**\n * CMCD status header name.\n *\n * @group CMCD\n *\n * @beta\n */\nconst CMCD_STATUS = 'CMCD-Status';\n\n/**\n * CMCD header fields.\n *\n * @group CMCD\n *\n * @enum\n *\n * @beta\n */\nconst CmcdHeaderField = {\n  /**\n   * keys whose values vary with the object being requested.\n   */\n  OBJECT: CMCD_OBJECT,\n  /**\n   * keys whose values vary with each request.\n   */\n  REQUEST: CMCD_REQUEST,\n  /**\n   * keys whose values are expected to be invariant over the life of the session.\n   */\n  SESSION: CMCD_SESSION,\n  /**\n   * keys whose values do not vary with every request or object.\n   */\n  STATUS: CMCD_STATUS\n};\n\n/**\n * The map of CMCD header fields to official CMCD keys.\n *\n * @internal\n *\n * @group CMCD\n */\nconst CmcdHeaderMap = {\n  [CmcdHeaderField.OBJECT]: ['br', 'ab', 'd', 'ot', 'tb', 'tpb', 'lb', 'tab', 'lab', 'url'],\n  [CmcdHeaderField.REQUEST]: ['pb', 'bl', 'tbl', 'dl', 'ltc', 'mtp', 'nor', 'nrr', 'rc', 'sn', 'sta', 'su', 'ttfb', 'ttfbb', 'ttlb', 'cmsdd', 'cmsds', 'smrt', 'df', 'cs'],\n  [CmcdHeaderField.SESSION]: ['cid', 'pr', 'sf', 'sid', 'st', 'v', 'msd'],\n  [CmcdHeaderField.STATUS]: ['bs', 'bsd', 'cdn', 'rtp', 'bg', 'pt', 'ec', 'e']\n};\n\n/**\n * Structured Field Item\n *\n * @group Structured Field\n *\n * @beta\n */\nclass SfItem {\n  constructor(value, params) {\n    if (Array.isArray(value)) {\n      value = value.map(v => v instanceof SfItem ? v : new SfItem(v));\n    }\n    this.value = value;\n    this.params = params;\n  }\n}\n\nconst DICT = 'Dict';\n\nfunction format(value) {\n  if (Array.isArray(value)) {\n    return JSON.stringify(value);\n  }\n  if (value instanceof Map) {\n    return 'Map{}';\n  }\n  if (value instanceof Set) {\n    return 'Set{}';\n  }\n  if (typeof value === 'object') {\n    return JSON.stringify(value);\n  }\n  return String(value);\n}\nfunction throwError(action, src, type, cause) {\n  return new Error(`failed to ${action} \"${format(src)}\" as ${type}`, {\n    cause\n  });\n}\n\nfunction serializeError(src, type, cause) {\n  return throwError('serialize', src, type, cause);\n}\n\n/**\n * A class to represent structured field tokens when `Symbol` is not available.\n *\n * @group Structured Field\n *\n * @beta\n */\nclass SfToken {\n  constructor(description) {\n    this.description = description;\n  }\n}\n\nconst BARE_ITEM = 'Bare Item';\n\nconst BOOLEAN = 'Boolean';\n\n// 4.1.9.  Serializing a Boolean\n//\n// Given a Boolean as input_boolean, return an ASCII string suitable for\n// use in a HTTP field value.\n//\n// 1.  If input_boolean is not a boolean, fail serialization.\n//\n// 2.  Let output be an empty string.\n//\n// 3.  Append \"?\" to output.\n//\n// 4.  If input_boolean is true, append \"1\" to output.\n//\n// 5.  If input_boolean is false, append \"0\" to output.\n//\n// 6.  Return output.\nfunction serializeBoolean(value) {\n  if (typeof value !== 'boolean') {\n    throw serializeError(value, BOOLEAN);\n  }\n  return value ? '?1' : '?0';\n}\n\n/**\n * Encodes binary data to base64\n *\n * @param binary - The binary data to encode\n * @returns The base64 encoded string\n *\n * @group Utils\n *\n * @beta\n */\nfunction encodeBase64(binary) {\n  return btoa(String.fromCharCode(...binary));\n}\n\nconst BYTES = 'Byte Sequence';\n\n// 4.1.8.  Serializing a Byte Sequence\n//\n// Given a Byte Sequence as input_bytes, return an ASCII string suitable\n// for use in a HTTP field value.\n//\n// 1.  If input_bytes is not a sequence of bytes, fail serialization.\n//\n// 2.  Let output be an empty string.\n//\n// 3.  Append \":\" to output.\n//\n// 4.  Append the result of base64-encoding input_bytes as per\n//     [RFC4648], Section 4, taking account of the requirements below.\n//\n// 5.  Append \":\" to output.\n//\n// 6.  Return output.\n//\n// The encoded data is required to be padded with \"=\", as per [RFC4648],\n// Section 3.2.\n//\n// Likewise, encoded data SHOULD have pad bits set to zero, as per\n// [RFC4648], Section 3.5, unless it is not possible to do so due to\n// implementation constraints.\nfunction serializeByteSequence(value) {\n  if (ArrayBuffer.isView(value) === false) {\n    throw serializeError(value, BYTES);\n  }\n  return `:${encodeBase64(value)}:`;\n}\n\nconst INTEGER = 'Integer';\n\nfunction isInvalidInt(value) {\n  return value < -999999999999999 || 999999999999999 < value;\n}\n\n// 4.1.4.  Serializing an Integer\n//\n// Given an Integer as input_integer, return an ASCII string suitable\n// for use in a HTTP field value.\n//\n// 1.  If input_integer is not an integer in the range of\n//     -999,999,999,999,999 to 999,999,999,999,999 inclusive, fail\n//     serialization.\n//\n// 2.  Let output be an empty string.\n//\n// 3.  If input_integer is less than (but not equal to) 0, append \"-\" to\n//     output.\n//\n// 4.  Append input_integer's numeric value represented in base 10 using\n//     only decimal digits to output.\n//\n// 5.  Return output.\nfunction serializeInteger(value) {\n  if (isInvalidInt(value)) {\n    throw serializeError(value, INTEGER);\n  }\n  return value.toString();\n}\n\n// 4.1.10.  Serializing a Date\n//\n// Given a Date as input_integer, return an ASCII string suitable for\n// use in an HTTP field value.\n// 1.  Let output be \"@\".\n// 2.  Append to output the result of running Serializing an Integer\n//     with input_date (Section 4.1.4).\n// 3.  Return output.\nfunction serializeDate(value) {\n  return `@${serializeInteger(value.getTime() / 1000)}`;\n}\n\n/**\n * This implements the rounding procedure described in step 2 of the \"Serializing a Decimal\" specification.\n * This rounding style is known as \"even rounding\", \"banker's rounding\", or \"commercial rounding\".\n *\n * @param value - The value to round\n * @param precision - The number of decimal places to round to\n * @returns The rounded value\n *\n * @group Utils\n *\n * @beta\n */\nfunction roundToEven(value, precision) {\n  if (value < 0) {\n    return -roundToEven(-value, precision);\n  }\n  const decimalShift = Math.pow(10, precision);\n  const isEquidistant = Math.abs(value * decimalShift % 1 - 0.5) < Number.EPSILON;\n  if (isEquidistant) {\n    // If the tail of the decimal place is 'equidistant' we round to the nearest even value\n    const flooredValue = Math.floor(value * decimalShift);\n    return (flooredValue % 2 === 0 ? flooredValue : flooredValue + 1) / decimalShift;\n  } else {\n    // Otherwise, proceed as normal\n    return Math.round(value * decimalShift) / decimalShift;\n  }\n}\n\nconst DECIMAL = 'Decimal';\n\n// 4.1.5.  Serializing a Decimal\n//\n// Given a decimal number as input_decimal, return an ASCII string\n// suitable for use in a HTTP field value.\n//\n// 1.   If input_decimal is not a decimal number, fail serialization.\n//\n// 2.   If input_decimal has more than three significant digits to the\n//      right of the decimal point, round it to three decimal places,\n//      rounding the final digit to the nearest value, or to the even\n//      value if it is equidistant.\n//\n// 3.   If input_decimal has more than 12 significant digits to the left\n//      of the decimal point after rounding, fail serialization.\n//\n// 4.   Let output be an empty string.\n//\n// 5.   If input_decimal is less than (but not equal to) 0, append \"-\"\n//      to output.\n//\n// 6.   Append input_decimal's integer component represented in base 10\n//      (using only decimal digits) to output; if it is zero, append\n//      \"0\".\n//\n// 7.   Append \".\" to output.\n//\n// 8.   If input_decimal's fractional component is zero, append \"0\" to\n//      output.\n//\n// 9.   Otherwise, append the significant digits of input_decimal's\n//      fractional component represented in base 10 (using only decimal\n//      digits) to output.\n//\n// 10.  Return output.\nfunction serializeDecimal(value) {\n  const roundedValue = roundToEven(value, 3); // round to 3 decimal places\n  if (Math.floor(Math.abs(roundedValue)).toString().length > 12) {\n    throw serializeError(value, DECIMAL);\n  }\n  const stringValue = roundedValue.toString();\n  return stringValue.includes('.') ? stringValue : `${stringValue}.0`;\n}\n\nconst STRING = 'String';\n\nconst STRING_REGEX = /[\\x00-\\x1f\\x7f]+/;\n\n// 4.1.6.  Serializing a String\n//\n// Given a String as input_string, return an ASCII string suitable for\n// use in a HTTP field value.\n//\n// 1.  Convert input_string into a sequence of ASCII characters; if\n//     conversion fails, fail serialization.\n//\n// 2.  If input_string contains characters in the range %x00-1f or %x7f\n//     (i.e., not in VCHAR or SP), fail serialization.\n//\n// 3.  Let output be the string DQUOTE.\n//\n// 4.  For each character char in input_string:\n//\n//     1.  If char is \"\\\" or DQUOTE:\n//\n//         1.  Append \"\\\" to output.\n//\n//     2.  Append char to output.\n//\n// 5.  Append DQUOTE to output.\n//\n// 6.  Return output.\nfunction serializeString(value) {\n  if (STRING_REGEX.test(value)) {\n    throw serializeError(value, STRING);\n  }\n  return `\"${value.replace(/\\\\/g, `\\\\\\\\`).replace(/\"/g, `\\\\\"`)}\"`;\n}\n\n/**\n * Converts a symbol to a string.\n *\n * @param symbol - The symbol to convert.\n *\n * @returns The string representation of the symbol.\n *\n * @internal\n */\nfunction symbolToStr(symbol) {\n  return symbol.description || symbol.toString().slice(7, -1);\n}\n\nconst TOKEN = 'Token';\n\nfunction serializeToken(token) {\n  const value = symbolToStr(token);\n  if (/^([a-zA-Z*])([!#$%&'*+\\-.^_`|~\\w:/]*)$/.test(value) === false) {\n    throw serializeError(value, TOKEN);\n  }\n  return value;\n}\n\n// 4.1.3.1.  Serializing a Bare Item\n//\n// Given an Item as input_item, return an ASCII string suitable for use\n// in a HTTP field value.\n//\n// 1.  If input_item is an Integer, return the result of running\n//     Serializing an Integer (Section 4.1.4) with input_item.\n//\n// 2.  If input_item is a Decimal, return the result of running\n//     Serializing a Decimal (Section 4.1.5) with input_item.\n//\n// 3.  If input_item is a String, return the result of running\n//     Serializing a String (Section 4.1.6) with input_item.\n//\n// 4.  If input_item is a Token, return the result of running\n//     Serializing a Token (Section 4.1.7) with input_item.\n//\n// 5.  If input_item is a Boolean, return the result of running\n//     Serializing a Boolean (Section 4.1.9) with input_item.\n//\n// 6.  If input_item is a Byte Sequence, return the result of running\n//     Serializing a Byte Sequence (Section 4.1.8) with input_item.\n//\n// 7.  If input_item is a Date, return the result of running Serializing\n//     a Date (Section 4.1.10) with input_item.\n//\n// 8.  Otherwise, fail serialization.\nfunction serializeBareItem(value) {\n  switch (typeof value) {\n    case 'number':\n      if (!isFiniteNumber(value)) {\n        throw serializeError(value, BARE_ITEM);\n      }\n      if (Number.isInteger(value)) {\n        return serializeInteger(value);\n      }\n      return serializeDecimal(value);\n    case 'string':\n      return serializeString(value);\n    case 'symbol':\n      return serializeToken(value);\n    case 'boolean':\n      return serializeBoolean(value);\n    case 'object':\n      if (value instanceof Date) {\n        return serializeDate(value);\n      }\n      if (value instanceof Uint8Array) {\n        return serializeByteSequence(value);\n      }\n      if (value instanceof SfToken) {\n        return serializeToken(value);\n      }\n    default:\n      // fail\n      throw serializeError(value, BARE_ITEM);\n  }\n}\n\nconst KEY = 'Key';\n\n// 4.1.1.3.  Serializing a Key\n//\n// Given a key as input_key, return an ASCII string suitable for use in\n// a HTTP field value.\n//\n// 1.  Convert input_key into a sequence of ASCII characters; if\n//     conversion fails, fail serialization.\n//\n// 2.  If input_key contains characters not in lcalpha, DIGIT, \"_\", \"-\",\n//     \".\", or \"*\" fail serialization.\n//\n// 3.  If the first character of input_key is not lcalpha or \"*\", fail\n//     serialization.\n//\n// 4.  Let output be an empty string.\n//\n// 5.  Append input_key to output.\n//\n// 6.  Return output.\nfunction serializeKey(value) {\n  if (/^[a-z*][a-z0-9\\-_.*]*$/.test(value) === false) {\n    throw serializeError(value, KEY);\n  }\n  return value;\n}\n\n// 4.1.1.2.  Serializing Parameters\n//\n// Given an ordered Dictionary as input_parameters (each member having a\n// param_name and a param_value), return an ASCII string suitable for\n// use in a HTTP field value.\n//\n// 1.  Let output be an empty string.\n//\n// 2.  For each param_name with a value of param_value in\n//     input_parameters:\n//\n//     1.  Append \";\" to output.\n//\n//     2.  Append the result of running Serializing a Key\n//         (Section 4.1.1.3) with param_name to output.\n//\n//     3.  If param_value is not Boolean true:\n//\n//         1.  Append \"=\" to output.\n//\n//         2.  Append the result of running Serializing a bare Item\n//             (Section 4.1.3.1) with param_value to output.\n//\n// 3.  Return output.\nfunction serializeParams(params) {\n  if (params == null) {\n    return '';\n  }\n  return Object.entries(params).map(([key, value]) => {\n    if (value === true) {\n      return `;${serializeKey(key)}`; // omit true\n    }\n    return `;${serializeKey(key)}=${serializeBareItem(value)}`;\n  }).join('');\n}\n\n// 4.1.3.  Serializing an Item\n//\n// Given an Item as bare_item and Parameters as item_parameters, return\n// an ASCII string suitable for use in a HTTP field value.\n//\n// 1.  Let output be an empty string.\n//\n// 2.  Append the result of running Serializing a Bare Item\n//     Section 4.1.3.1 with bare_item to output.\n//\n// 3.  Append the result of running Serializing Parameters\n//     Section 4.1.1.2 with item_parameters to output.\n//\n// 4.  Return output.\nfunction serializeItem(value) {\n  if (value instanceof SfItem) {\n    return `${serializeBareItem(value.value)}${serializeParams(value.params)}`;\n  } else {\n    return serializeBareItem(value);\n  }\n}\n\n// 4.1.1.1.  Serializing an Inner List\n//\n// Given an array of (member_value, parameters) tuples as inner_list,\n// and parameters as list_parameters, return an ASCII string suitable\n// for use in a HTTP field value.\n//\n// 1.  Let output be the string \"(\".\n//\n// 2.  For each (member_value, parameters) of inner_list:\n//\n//     1.  Append the result of running Serializing an Item\n//         (Section 4.1.3) with (member_value, parameters) to output.\n//\n//     2.  If more values remain in inner_list, append a single SP to\n//         output.\n//\n// 3.  Append \")\" to output.\n//\n// 4.  Append the result of running Serializing Parameters\n//     (Section 4.1.1.2) with list_parameters to output.\n//\n// 5.  Return output.\nfunction serializeInnerList(value) {\n  return `(${value.value.map(serializeItem).join(' ')})${serializeParams(value.params)}`;\n}\n\n// 4.1.2.  Serializing a Dictionary\n//\n// Given an ordered Dictionary as input_dictionary (each member having a\n// member_name and a tuple value of (member_value, parameters)), return\n// an ASCII string suitable for use in a HTTP field value.\n//\n// 1.  Let output be an empty string.\n//\n// 2.  For each member_name with a value of (member_value, parameters)\n//     in input_dictionary:\n//\n//     1.  Append the result of running Serializing a Key\n//         (Section 4.1.1.3) with member's member_name to output.\n//\n//     2.  If member_value is Boolean true:\n//\n//         1.  Append the result of running Serializing Parameters\n//             (Section 4.1.1.2) with parameters to output.\n//\n//     3.  Otherwise:\n//\n//         1.  Append \"=\" to output.\n//\n//         2.  If member_value is an array, append the result of running\n//             Serializing an Inner List (Section 4.1.1.1) with\n//             (member_value, parameters) to output.\n//\n//         3.  Otherwise, append the result of running Serializing an\n//             Item (Section 4.1.3) with (member_value, parameters) to\n//             output.\n//\n//     4.  If more members remain in input_dictionary:\n//\n//         1.  Append \",\" to output.\n//\n//         2.  Append a single SP to output.\n//\n// 3.  Return output.\nfunction serializeDict(dict, options = {\n  whitespace: true\n}) {\n  if (typeof dict !== 'object') {\n    throw serializeError(dict, DICT);\n  }\n  const entries = dict instanceof Map ? dict.entries() : Object.entries(dict);\n  const optionalWhiteSpace = (options === null || options === void 0 ? void 0 : options.whitespace) ? ' ' : '';\n  return Array.from(entries).map(([key, item]) => {\n    if (item instanceof SfItem === false) {\n      item = new SfItem(item);\n    }\n    let output = serializeKey(key);\n    if (item.value === true) {\n      output += serializeParams(item.params);\n    } else {\n      output += '=';\n      if (Array.isArray(item.value)) {\n        output += serializeInnerList(item);\n      } else {\n        output += serializeItem(item);\n      }\n    }\n    return output;\n  }).join(`,${optionalWhiteSpace}`);\n}\n\n/**\n * Encode an object into a structured field dictionary\n *\n * @param value - The structured field dictionary to encode\n * @param options - Encoding options\n *\n * @returns The structured field string\n *\n * @group Structured Field\n *\n * @beta\n */\nfunction encodeSfDict(value, options) {\n  return serializeDict(value, options);\n}\n\n/**\n * Checks if the given key is a token field.\n *\n * @param key - The key to check.\n *\n * @returns `true` if the key is a token field.\n *\n * @internal\n */\nfunction isTokenField(key) {\n  return ['ot', 'sf', 'st', 'e', 'sta'].includes(key);\n}\n\n/**\n * Checks if the given value is valid\n *\n * @param value - The value to check.\n *\n * @returns `true` if the key is a value is valid.\n *\n * @internal\n */\nfunction isValid(value) {\n  if (typeof value === 'number') {\n    return isFiniteNumber(value);\n  }\n  return value != null && value !== '' && value !== false;\n}\n\n/**\n * Constructs a relative path from a URL.\n *\n * @param url - The destination URL\n * @param base - The base URL\n * @returns The relative path\n *\n * @group Utils\n *\n * @beta\n */\nfunction urlToRelativePath(url, base) {\n  const to = new URL(url);\n  const from = new URL(base);\n  if (to.origin !== from.origin) {\n    return url;\n  }\n  const toPath = to.pathname.split('/').slice(1);\n  const fromPath = from.pathname.split('/').slice(1, -1);\n  // remove common parents\n  while (toPath[0] === fromPath[0]) {\n    toPath.shift();\n    fromPath.shift();\n  }\n  // add back paths\n  while (fromPath.length) {\n    fromPath.shift();\n    toPath.unshift('..');\n  }\n  return toPath.join('/');\n}\n\nconst toRounded = value => Math.round(value);\nconst toUrlSafe = (value, options) => {\n  if (options === null || options === void 0 ? void 0 : options.baseUrl) {\n    value = urlToRelativePath(value, options.baseUrl);\n  }\n  return encodeURIComponent(value);\n};\nconst toHundred = value => toRounded(value / 100) * 100;\n/**\n * The default formatters for CMCD values.\n *\n * @group CMCD\n *\n * @beta\n */\nconst CmcdFormatters = {\n  /**\n   * Bitrate (kbps) rounded integer\n   */\n  br: toRounded,\n  /**\n   * Duration (milliseconds) rounded integer\n   */\n  d: toRounded,\n  /**\n   * Buffer Length (milliseconds) rounded nearest 100ms\n   */\n  bl: toHundred,\n  /**\n   * Deadline (milliseconds) rounded nearest 100ms\n   */\n  dl: toHundred,\n  /**\n   * Measured Throughput (kbps) rounded nearest 100kbps\n   */\n  mtp: toHundred,\n  /**\n   * Next Object Request URL encoded\n   */\n  nor: toUrlSafe,\n  /**\n   * Requested maximum throughput (kbps) rounded nearest 100kbps\n   */\n  rtp: toHundred,\n  /**\n   * Top Bitrate (kbps) rounded integer\n   */\n  tb: toRounded\n};\n\n/**\n * Internal CMCD processing function.\n *\n * @param obj - The CMCD object to process.\n * @param map - The mapping function to use.\n * @param options - Options for encoding.\n *\n * @internal\n *\n * @group CMCD\n */\nfunction processCmcd(obj, options) {\n  const results = {};\n  if (obj == null || typeof obj !== 'object') {\n    return results;\n  }\n  const keys = Object.keys(obj).sort();\n  const formatters = _extends({}, CmcdFormatters, options === null || options === void 0 ? void 0 : options.formatters);\n  const filter = options === null || options === void 0 ? void 0 : options.filter;\n  keys.forEach(key => {\n    if ((filter === null || filter === void 0 ? void 0 : filter(key)) === false) {\n      return;\n    }\n    let value = obj[key];\n    const formatter = formatters[key];\n    if (formatter) {\n      value = formatter(value, options);\n    }\n    // Version should only be reported if not equal to 1.\n    if (key === 'v' && value === 1) {\n      return;\n    }\n    // Playback rate should only be sent if not equal to 1.\n    if (key == 'pr' && value === 1) {\n      return;\n    }\n    // ignore invalid values\n    if (!isValid(value)) {\n      return;\n    }\n    if (isTokenField(key) && typeof value === 'string') {\n      value = new SfToken(value);\n    }\n    results[key] = value;\n  });\n  return results;\n}\n\n/**\n * Encode a CMCD object to a string.\n *\n * @param cmcd - The CMCD object to encode.\n * @param options - Options for encoding.\n *\n * @returns The encoded CMCD string.\n *\n * @group CMCD\n *\n * @beta\n */\nfunction encodeCmcd(cmcd, options = {}) {\n  if (!cmcd) {\n    return '';\n  }\n  return encodeSfDict(processCmcd(cmcd, options), _extends({\n    whitespace: false\n  }, options));\n}\n\n/**\n * Convert a CMCD data object to request headers\n *\n * @param cmcd - The CMCD data object to convert.\n * @param options - Options for encoding the CMCD object.\n *\n * @returns The CMCD header shards.\n *\n * @group CMCD\n *\n * @beta\n */\nfunction toCmcdHeaders(cmcd, options = {}) {\n  const result = {};\n  if (!cmcd) {\n    return result;\n  }\n  const entries = Object.entries(cmcd);\n  const headerMap = Object.entries(CmcdHeaderMap).concat(Object.entries((options === null || options === void 0 ? void 0 : options.customHeaderMap) || {}));\n  const shards = entries.reduce((acc, entry) => {\n    var _a, _b;\n    const [key, value] = entry;\n    const field = ((_a = headerMap.find(entry => entry[1].includes(key))) === null || _a === void 0 ? void 0 : _a[0]) || CmcdHeaderField.REQUEST;\n    (_b = acc[field]) !== null && _b !== void 0 ? _b : acc[field] = {};\n    acc[field][key] = value;\n    return acc;\n  }, {});\n  return Object.entries(shards).reduce((acc, [field, value]) => {\n    acc[field] = encodeCmcd(value, options);\n    return acc;\n  }, result);\n}\n\n/**\n * Append CMCD query args to a header object.\n *\n * @param headers - The headers to append to.\n * @param cmcd - The CMCD object to append.\n * @param options - Encode options.\n *\n * @returns The headers with the CMCD header shards appended.\n *\n * @group CMCD\n *\n * @beta\n */\nfunction appendCmcdHeaders(headers, cmcd, options) {\n  return _extends(headers, toCmcdHeaders(cmcd, options));\n}\n\n/**\n * CMCD parameter name.\n *\n * @group CMCD\n *\n * @beta\n */\nconst CMCD_PARAM = 'CMCD';\n\n/**\n * Convert a CMCD data object to a query arg.\n *\n * @param cmcd - The CMCD object to convert.\n * @param options - Options for encoding the CMCD object.\n *\n * @returns The CMCD query arg.\n *\n * @group CMCD\n *\n * @beta\n */\nfunction toCmcdQuery(cmcd, options = {}) {\n  if (!cmcd) {\n    return '';\n  }\n  const params = encodeCmcd(cmcd, options);\n  return `${CMCD_PARAM}=${encodeURIComponent(params)}`;\n}\n\nconst REGEX = /CMCD=[^&#]+/;\n/**\n * Append CMCD query args to a URL.\n *\n * @param url - The URL to append to.\n * @param cmcd - The CMCD object to append.\n * @param options - Options for encoding the CMCD object.\n *\n * @returns The URL with the CMCD query args appended.\n *\n * @group CMCD\n *\n * @beta\n */\nfunction appendCmcdQuery(url, cmcd, options) {\n  // TODO: Replace with URLSearchParams once we drop Safari < 10.1 & Chrome < 49 support.\n  // https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams\n  const query = toCmcdQuery(cmcd, options);\n  if (!query) {\n    return url;\n  }\n  if (REGEX.test(url)) {\n    return url.replace(REGEX, query);\n  }\n  const separator = url.includes('?') ? '&' : '?';\n  return `${url}${separator}${query}`;\n}\n\n/**\n * Controller to deal with Common Media Client Data (CMCD)\n * @see https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5004-final.pdf\n */\nclass CMCDController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.config = void 0;\n    this.media = void 0;\n    this.sid = void 0;\n    this.cid = void 0;\n    this.useHeaders = false;\n    this.includeKeys = void 0;\n    this.initialized = false;\n    this.starved = false;\n    this.buffering = true;\n    this.audioBuffer = void 0;\n    this.videoBuffer = void 0;\n    this.onWaiting = () => {\n      if (this.initialized) {\n        this.starved = true;\n      }\n      this.buffering = true;\n    };\n    this.onPlaying = () => {\n      if (!this.initialized) {\n        this.initialized = true;\n      }\n      this.buffering = false;\n    };\n    /**\n     * Apply CMCD data to a manifest request.\n     */\n    this.applyPlaylistData = context => {\n      try {\n        this.apply(context, {\n          ot: CmcdObjectType.MANIFEST,\n          su: !this.initialized\n        });\n      } catch (error) {\n        this.hls.logger.warn('Could not generate manifest CMCD data.', error);\n      }\n    };\n    /**\n     * Apply CMCD data to a segment request\n     */\n    this.applyFragmentData = context => {\n      try {\n        const {\n          frag,\n          part\n        } = context;\n        const level = this.hls.levels[frag.level];\n        const ot = this.getObjectType(frag);\n        const data = {\n          d: (part || frag).duration * 1000,\n          ot\n        };\n        if (ot === CmcdObjectType.VIDEO || ot === CmcdObjectType.AUDIO || ot == CmcdObjectType.MUXED) {\n          data.br = level.bitrate / 1000;\n          data.tb = this.getTopBandwidth(ot) / 1000;\n          data.bl = this.getBufferLength(ot);\n        }\n        const next = part ? this.getNextPart(part) : this.getNextFrag(frag);\n        if (next != null && next.url && next.url !== frag.url) {\n          data.nor = next.url;\n        }\n        this.apply(context, data);\n      } catch (error) {\n        this.hls.logger.warn('Could not generate segment CMCD data.', error);\n      }\n    };\n    this.hls = hls;\n    const config = this.config = hls.config;\n    const {\n      cmcd\n    } = config;\n    if (cmcd != null) {\n      config.pLoader = this.createPlaylistLoader();\n      config.fLoader = this.createFragmentLoader();\n      this.sid = cmcd.sessionId || hls.sessionId;\n      this.cid = cmcd.contentId;\n      this.useHeaders = cmcd.useHeaders === true;\n      this.includeKeys = cmcd.includeKeys;\n      this.registerListeners();\n    }\n  }\n  registerListeners() {\n    const hls = this.hls;\n    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(Events.MEDIA_DETACHED, this.onMediaDetached, this);\n    hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);\n  }\n  unregisterListeners() {\n    const hls = this.hls;\n    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(Events.MEDIA_DETACHED, this.onMediaDetached, this);\n    hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.onMediaDetached();\n\n    // @ts-ignore\n    this.hls = this.config = this.audioBuffer = this.videoBuffer = null;\n    // @ts-ignore\n    this.onWaiting = this.onPlaying = this.media = null;\n  }\n  onMediaAttached(event, data) {\n    this.media = data.media;\n    this.media.addEventListener('waiting', this.onWaiting);\n    this.media.addEventListener('playing', this.onPlaying);\n  }\n  onMediaDetached() {\n    if (!this.media) {\n      return;\n    }\n    this.media.removeEventListener('waiting', this.onWaiting);\n    this.media.removeEventListener('playing', this.onPlaying);\n\n    // @ts-ignore\n    this.media = null;\n  }\n  onBufferCreated(event, data) {\n    var _data$tracks$audio, _data$tracks$video;\n    this.audioBuffer = (_data$tracks$audio = data.tracks.audio) == null ? void 0 : _data$tracks$audio.buffer;\n    this.videoBuffer = (_data$tracks$video = data.tracks.video) == null ? void 0 : _data$tracks$video.buffer;\n  }\n  /**\n   * Create baseline CMCD data\n   */\n  createData() {\n    var _this$media;\n    return {\n      v: 1,\n      sf: CmcdStreamingFormat.HLS,\n      sid: this.sid,\n      cid: this.cid,\n      pr: (_this$media = this.media) == null ? void 0 : _this$media.playbackRate,\n      mtp: this.hls.bandwidthEstimate / 1000\n    };\n  }\n\n  /**\n   * Apply CMCD data to a request.\n   */\n  apply(context, data = {}) {\n    // apply baseline data\n    _extends(data, this.createData());\n    const isVideo = data.ot === CmcdObjectType.INIT || data.ot === CmcdObjectType.VIDEO || data.ot === CmcdObjectType.MUXED;\n    if (this.starved && isVideo) {\n      data.bs = true;\n      data.su = true;\n      this.starved = false;\n    }\n    if (data.su == null) {\n      data.su = this.buffering;\n    }\n\n    // TODO: Implement rtp, nrr, dl\n\n    const {\n      includeKeys\n    } = this;\n    if (includeKeys) {\n      data = Object.keys(data).reduce((acc, key) => {\n        includeKeys.includes(key) && (acc[key] = data[key]);\n        return acc;\n      }, {});\n    }\n    const options = {\n      baseUrl: context.url\n    };\n    if (this.useHeaders) {\n      if (!context.headers) {\n        context.headers = {};\n      }\n      appendCmcdHeaders(context.headers, data, options);\n    } else {\n      context.url = appendCmcdQuery(context.url, data, options);\n    }\n  }\n  getNextFrag(fragment) {\n    var _this$hls$levels$frag;\n    const levelDetails = (_this$hls$levels$frag = this.hls.levels[fragment.level]) == null ? void 0 : _this$hls$levels$frag.details;\n    if (levelDetails) {\n      const index = fragment.sn - levelDetails.startSN;\n      return levelDetails.fragments[index + 1];\n    }\n    return undefined;\n  }\n  getNextPart(part) {\n    var _this$hls$levels$frag2, _this$hls$levels$frag3;\n    const {\n      index,\n      fragment\n    } = part;\n    const partList = (_this$hls$levels$frag2 = this.hls.levels[fragment.level]) == null ? void 0 : (_this$hls$levels$frag3 = _this$hls$levels$frag2.details) == null ? void 0 : _this$hls$levels$frag3.partList;\n    if (partList) {\n      const {\n        sn\n      } = fragment;\n      for (let i = partList.length - 1; i >= 0; i--) {\n        const p = partList[i];\n        if (p.index === index && p.fragment.sn === sn) {\n          return partList[i + 1];\n        }\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * The CMCD object type.\n   */\n  getObjectType(fragment) {\n    const {\n      type\n    } = fragment;\n    if (type === 'subtitle') {\n      return CmcdObjectType.TIMED_TEXT;\n    }\n    if (fragment.sn === 'initSegment') {\n      return CmcdObjectType.INIT;\n    }\n    if (type === 'audio') {\n      return CmcdObjectType.AUDIO;\n    }\n    if (type === 'main') {\n      if (!this.hls.audioTracks.length) {\n        return CmcdObjectType.MUXED;\n      }\n      return CmcdObjectType.VIDEO;\n    }\n    return undefined;\n  }\n\n  /**\n   * Get the highest bitrate.\n   */\n  getTopBandwidth(type) {\n    let bitrate = 0;\n    let levels;\n    const hls = this.hls;\n    if (type === CmcdObjectType.AUDIO) {\n      levels = hls.audioTracks;\n    } else {\n      const max = hls.maxAutoLevel;\n      const len = max > -1 ? max + 1 : hls.levels.length;\n      levels = hls.levels.slice(0, len);\n    }\n    levels.forEach(level => {\n      if (level.bitrate > bitrate) {\n        bitrate = level.bitrate;\n      }\n    });\n    return bitrate > 0 ? bitrate : NaN;\n  }\n\n  /**\n   * Get the buffer length for a media type in milliseconds\n   */\n  getBufferLength(type) {\n    const media = this.media;\n    const buffer = type === CmcdObjectType.AUDIO ? this.audioBuffer : this.videoBuffer;\n    if (!buffer || !media) {\n      return NaN;\n    }\n    const info = BufferHelper.bufferInfo(buffer, media.currentTime, this.config.maxBufferHole);\n    return info.len * 1000;\n  }\n\n  /**\n   * Create a playlist loader\n   */\n  createPlaylistLoader() {\n    const {\n      pLoader\n    } = this.config;\n    const apply = this.applyPlaylistData;\n    const Ctor = pLoader || this.config.loader;\n    return class CmcdPlaylistLoader {\n      constructor(config) {\n        this.loader = void 0;\n        this.loader = new Ctor(config);\n      }\n      get stats() {\n        return this.loader.stats;\n      }\n      get context() {\n        return this.loader.context;\n      }\n      destroy() {\n        this.loader.destroy();\n      }\n      abort() {\n        this.loader.abort();\n      }\n      load(context, config, callbacks) {\n        apply(context);\n        this.loader.load(context, config, callbacks);\n      }\n    };\n  }\n\n  /**\n   * Create a playlist loader\n   */\n  createFragmentLoader() {\n    const {\n      fLoader\n    } = this.config;\n    const apply = this.applyFragmentData;\n    const Ctor = fLoader || this.config.loader;\n    return class CmcdFragmentLoader {\n      constructor(config) {\n        this.loader = void 0;\n        this.loader = new Ctor(config);\n      }\n      get stats() {\n        return this.loader.stats;\n      }\n      get context() {\n        return this.loader.context;\n      }\n      destroy() {\n        this.loader.destroy();\n      }\n      abort() {\n        this.loader.abort();\n      }\n      load(context, config, callbacks) {\n        apply(context);\n        this.loader.load(context, config, callbacks);\n      }\n    };\n  }\n}\n\nconst PATHWAY_PENALTY_DURATION_MS = 300000;\nclass ContentSteeringController extends Logger {\n  constructor(hls) {\n    super('content-steering', hls.logger);\n    this.hls = void 0;\n    this.loader = null;\n    this.uri = null;\n    this.pathwayId = '.';\n    this._pathwayPriority = null;\n    this.timeToLoad = 300;\n    this.reloadTimer = -1;\n    this.updated = 0;\n    this.started = false;\n    this.enabled = true;\n    this.levels = null;\n    this.audioTracks = null;\n    this.subtitleTracks = null;\n    this.penalizedPathways = {};\n    this.hls = hls;\n    this.registerListeners();\n  }\n  registerListeners() {\n    const hls = this.hls;\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(Events.ERROR, this.onError, this);\n  }\n  unregisterListeners() {\n    const hls = this.hls;\n    if (!hls) {\n      return;\n    }\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(Events.ERROR, this.onError, this);\n  }\n  pathways() {\n    return (this.levels || []).reduce((pathways, level) => {\n      if (pathways.indexOf(level.pathwayId) === -1) {\n        pathways.push(level.pathwayId);\n      }\n      return pathways;\n    }, []);\n  }\n  get pathwayPriority() {\n    return this._pathwayPriority;\n  }\n  set pathwayPriority(pathwayPriority) {\n    this.updatePathwayPriority(pathwayPriority);\n  }\n  startLoad() {\n    this.started = true;\n    this.clearTimeout();\n    if (this.enabled && this.uri) {\n      if (this.updated) {\n        const ttl = this.timeToLoad * 1000 - (performance.now() - this.updated);\n        if (ttl > 0) {\n          this.scheduleRefresh(this.uri, ttl);\n          return;\n        }\n      }\n      this.loadSteeringManifest(this.uri);\n    }\n  }\n  stopLoad() {\n    this.started = false;\n    if (this.loader) {\n      this.loader.destroy();\n      this.loader = null;\n    }\n    this.clearTimeout();\n  }\n  clearTimeout() {\n    if (this.reloadTimer !== -1) {\n      self.clearTimeout(this.reloadTimer);\n      this.reloadTimer = -1;\n    }\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.stopLoad();\n    // @ts-ignore\n    this.hls = null;\n    this.levels = this.audioTracks = this.subtitleTracks = null;\n  }\n  removeLevel(levelToRemove) {\n    const levels = this.levels;\n    if (levels) {\n      this.levels = levels.filter(level => level !== levelToRemove);\n    }\n  }\n  onManifestLoading() {\n    this.stopLoad();\n    this.enabled = true;\n    this.timeToLoad = 300;\n    this.updated = 0;\n    this.uri = null;\n    this.pathwayId = '.';\n    this.levels = this.audioTracks = this.subtitleTracks = null;\n  }\n  onManifestLoaded(event, data) {\n    const {\n      contentSteering\n    } = data;\n    if (contentSteering === null) {\n      return;\n    }\n    this.pathwayId = contentSteering.pathwayId;\n    this.uri = contentSteering.uri;\n    if (this.started) {\n      this.startLoad();\n    }\n  }\n  onManifestParsed(event, data) {\n    this.audioTracks = data.audioTracks;\n    this.subtitleTracks = data.subtitleTracks;\n  }\n  onError(event, data) {\n    const {\n      errorAction\n    } = data;\n    if ((errorAction == null ? void 0 : errorAction.action) === NetworkErrorAction.SendAlternateToPenaltyBox && errorAction.flags === ErrorActionFlags.MoveAllAlternatesMatchingHost) {\n      const levels = this.levels;\n      let pathwayPriority = this._pathwayPriority;\n      let errorPathway = this.pathwayId;\n      if (data.context) {\n        const {\n          groupId,\n          pathwayId,\n          type\n        } = data.context;\n        if (groupId && levels) {\n          errorPathway = this.getPathwayForGroupId(groupId, type, errorPathway);\n        } else if (pathwayId) {\n          errorPathway = pathwayId;\n        }\n      }\n      if (!(errorPathway in this.penalizedPathways)) {\n        this.penalizedPathways[errorPathway] = performance.now();\n      }\n      if (!pathwayPriority && levels) {\n        // If PATHWAY-PRIORITY was not provided, list pathways for error handling\n        pathwayPriority = this.pathways();\n      }\n      if (pathwayPriority && pathwayPriority.length > 1) {\n        this.updatePathwayPriority(pathwayPriority);\n        errorAction.resolved = this.pathwayId !== errorPathway;\n      }\n      if (data.details === ErrorDetails.BUFFER_APPEND_ERROR && !data.fatal) {\n        // Error will become fatal in buffer-controller when reaching `appendErrorMaxRetry`\n        // Stream-controllers are expected to reduce buffer length even if this is not deemed a QuotaExceededError\n        errorAction.resolved = true;\n      } else if (!errorAction.resolved) {\n        this.warn(`Could not resolve ${data.details} (\"${data.error.message}\") with content-steering for Pathway: ${errorPathway} levels: ${levels ? levels.length : levels} priorities: ${stringify(pathwayPriority)} penalized: ${stringify(this.penalizedPathways)}`);\n      }\n    }\n  }\n  filterParsedLevels(levels) {\n    // Filter levels to only include those that are in the initial pathway\n    this.levels = levels;\n    let pathwayLevels = this.getLevelsForPathway(this.pathwayId);\n    if (pathwayLevels.length === 0) {\n      const pathwayId = levels[0].pathwayId;\n      this.log(`No levels found in Pathway ${this.pathwayId}. Setting initial Pathway to \"${pathwayId}\"`);\n      pathwayLevels = this.getLevelsForPathway(pathwayId);\n      this.pathwayId = pathwayId;\n    }\n    if (pathwayLevels.length !== levels.length) {\n      this.log(`Found ${pathwayLevels.length}/${levels.length} levels in Pathway \"${this.pathwayId}\"`);\n    }\n    return pathwayLevels;\n  }\n  getLevelsForPathway(pathwayId) {\n    if (this.levels === null) {\n      return [];\n    }\n    return this.levels.filter(level => pathwayId === level.pathwayId);\n  }\n  updatePathwayPriority(pathwayPriority) {\n    this._pathwayPriority = pathwayPriority;\n    let levels;\n\n    // Evaluate if we should remove the pathway from the penalized list\n    const penalizedPathways = this.penalizedPathways;\n    const now = performance.now();\n    Object.keys(penalizedPathways).forEach(pathwayId => {\n      if (now - penalizedPathways[pathwayId] > PATHWAY_PENALTY_DURATION_MS) {\n        delete penalizedPathways[pathwayId];\n      }\n    });\n    for (let i = 0; i < pathwayPriority.length; i++) {\n      const pathwayId = pathwayPriority[i];\n      if (pathwayId in penalizedPathways) {\n        continue;\n      }\n      if (pathwayId === this.pathwayId) {\n        return;\n      }\n      const selectedIndex = this.hls.nextLoadLevel;\n      const selectedLevel = this.hls.levels[selectedIndex];\n      levels = this.getLevelsForPathway(pathwayId);\n      if (levels.length > 0) {\n        this.log(`Setting Pathway to \"${pathwayId}\"`);\n        this.pathwayId = pathwayId;\n        reassignFragmentLevelIndexes(levels);\n        this.hls.trigger(Events.LEVELS_UPDATED, {\n          levels\n        });\n        // Set LevelController's level to trigger LEVEL_SWITCHING which loads playlist if needed\n        const levelAfterChange = this.hls.levels[selectedIndex];\n        if (selectedLevel && levelAfterChange && this.levels) {\n          if (levelAfterChange.attrs['STABLE-VARIANT-ID'] !== selectedLevel.attrs['STABLE-VARIANT-ID'] && levelAfterChange.bitrate !== selectedLevel.bitrate) {\n            this.log(`Unstable Pathways change from bitrate ${selectedLevel.bitrate} to ${levelAfterChange.bitrate}`);\n          }\n          this.hls.nextLoadLevel = selectedIndex;\n        }\n        break;\n      }\n    }\n  }\n  getPathwayForGroupId(groupId, type, defaultPathway) {\n    const levels = this.getLevelsForPathway(defaultPathway).concat(this.levels || []);\n    for (let i = 0; i < levels.length; i++) {\n      if (type === PlaylistContextType.AUDIO_TRACK && levels[i].hasAudioGroup(groupId) || type === PlaylistContextType.SUBTITLE_TRACK && levels[i].hasSubtitleGroup(groupId)) {\n        return levels[i].pathwayId;\n      }\n    }\n    return defaultPathway;\n  }\n  clonePathways(pathwayClones) {\n    const levels = this.levels;\n    if (!levels) {\n      return;\n    }\n    const audioGroupCloneMap = {};\n    const subtitleGroupCloneMap = {};\n    pathwayClones.forEach(pathwayClone => {\n      const {\n        ID: cloneId,\n        'BASE-ID': baseId,\n        'URI-REPLACEMENT': uriReplacement\n      } = pathwayClone;\n      if (levels.some(level => level.pathwayId === cloneId)) {\n        return;\n      }\n      const clonedVariants = this.getLevelsForPathway(baseId).map(baseLevel => {\n        const attributes = new AttrList(baseLevel.attrs);\n        attributes['PATHWAY-ID'] = cloneId;\n        const clonedAudioGroupId = attributes.AUDIO && `${attributes.AUDIO}_clone_${cloneId}`;\n        const clonedSubtitleGroupId = attributes.SUBTITLES && `${attributes.SUBTITLES}_clone_${cloneId}`;\n        if (clonedAudioGroupId) {\n          audioGroupCloneMap[attributes.AUDIO] = clonedAudioGroupId;\n          attributes.AUDIO = clonedAudioGroupId;\n        }\n        if (clonedSubtitleGroupId) {\n          subtitleGroupCloneMap[attributes.SUBTITLES] = clonedSubtitleGroupId;\n          attributes.SUBTITLES = clonedSubtitleGroupId;\n        }\n        const url = performUriReplacement(baseLevel.uri, attributes['STABLE-VARIANT-ID'], 'PER-VARIANT-URIS', uriReplacement);\n        const clonedLevel = new Level({\n          attrs: attributes,\n          audioCodec: baseLevel.audioCodec,\n          bitrate: baseLevel.bitrate,\n          height: baseLevel.height,\n          name: baseLevel.name,\n          url,\n          videoCodec: baseLevel.videoCodec,\n          width: baseLevel.width\n        });\n        if (baseLevel.audioGroups) {\n          for (let i = 1; i < baseLevel.audioGroups.length; i++) {\n            clonedLevel.addGroupId('audio', `${baseLevel.audioGroups[i]}_clone_${cloneId}`);\n          }\n        }\n        if (baseLevel.subtitleGroups) {\n          for (let i = 1; i < baseLevel.subtitleGroups.length; i++) {\n            clonedLevel.addGroupId('text', `${baseLevel.subtitleGroups[i]}_clone_${cloneId}`);\n          }\n        }\n        return clonedLevel;\n      });\n      levels.push(...clonedVariants);\n      cloneRenditionGroups(this.audioTracks, audioGroupCloneMap, uriReplacement, cloneId);\n      cloneRenditionGroups(this.subtitleTracks, subtitleGroupCloneMap, uriReplacement, cloneId);\n    });\n  }\n  loadSteeringManifest(uri) {\n    const config = this.hls.config;\n    const Loader = config.loader;\n    if (this.loader) {\n      this.loader.destroy();\n    }\n    this.loader = new Loader(config);\n    let url;\n    try {\n      url = new self.URL(uri);\n    } catch (error) {\n      this.enabled = false;\n      this.log(`Failed to parse Steering Manifest URI: ${uri}`);\n      return;\n    }\n    if (url.protocol !== 'data:') {\n      const throughput = (this.hls.bandwidthEstimate || config.abrEwmaDefaultEstimate) | 0;\n      url.searchParams.set('_HLS_pathway', this.pathwayId);\n      url.searchParams.set('_HLS_throughput', '' + throughput);\n    }\n    const context = {\n      responseType: 'json',\n      url: url.href\n    };\n    const loadPolicy = config.steeringManifestLoadPolicy.default;\n    const legacyRetryCompatibility = loadPolicy.errorRetry || loadPolicy.timeoutRetry || {};\n    const loaderConfig = {\n      loadPolicy,\n      timeout: loadPolicy.maxLoadTimeMs,\n      maxRetry: legacyRetryCompatibility.maxNumRetry || 0,\n      retryDelay: legacyRetryCompatibility.retryDelayMs || 0,\n      maxRetryDelay: legacyRetryCompatibility.maxRetryDelayMs || 0\n    };\n    const callbacks = {\n      onSuccess: (response, stats, context, networkDetails) => {\n        this.log(`Loaded steering manifest: \"${url}\"`);\n        const steeringData = response.data;\n        if ((steeringData == null ? void 0 : steeringData.VERSION) !== 1) {\n          this.log(`Steering VERSION ${steeringData.VERSION} not supported!`);\n          return;\n        }\n        this.updated = performance.now();\n        this.timeToLoad = steeringData.TTL;\n        const {\n          'RELOAD-URI': reloadUri,\n          'PATHWAY-CLONES': pathwayClones,\n          'PATHWAY-PRIORITY': pathwayPriority\n        } = steeringData;\n        if (reloadUri) {\n          try {\n            this.uri = new self.URL(reloadUri, url).href;\n          } catch (error) {\n            this.enabled = false;\n            this.log(`Failed to parse Steering Manifest RELOAD-URI: ${reloadUri}`);\n            return;\n          }\n        }\n        this.scheduleRefresh(this.uri || context.url);\n        if (pathwayClones) {\n          this.clonePathways(pathwayClones);\n        }\n        const loadedSteeringData = {\n          steeringManifest: steeringData,\n          url: url.toString()\n        };\n        this.hls.trigger(Events.STEERING_MANIFEST_LOADED, loadedSteeringData);\n        if (pathwayPriority) {\n          this.updatePathwayPriority(pathwayPriority);\n        }\n      },\n      onError: (error, context, networkDetails, stats) => {\n        this.log(`Error loading steering manifest: ${error.code} ${error.text} (${context.url})`);\n        this.stopLoad();\n        if (error.code === 410) {\n          this.enabled = false;\n          this.log(`Steering manifest ${context.url} no longer available`);\n          return;\n        }\n        let ttl = this.timeToLoad * 1000;\n        if (error.code === 429) {\n          const loader = this.loader;\n          if (typeof (loader == null ? void 0 : loader.getResponseHeader) === 'function') {\n            const retryAfter = loader.getResponseHeader('Retry-After');\n            if (retryAfter) {\n              ttl = parseFloat(retryAfter) * 1000;\n            }\n          }\n          this.log(`Steering manifest ${context.url} rate limited`);\n          return;\n        }\n        this.scheduleRefresh(this.uri || context.url, ttl);\n      },\n      onTimeout: (stats, context, networkDetails) => {\n        this.log(`Timeout loading steering manifest (${context.url})`);\n        this.scheduleRefresh(this.uri || context.url);\n      }\n    };\n    this.log(`Requesting steering manifest: ${url}`);\n    this.loader.load(context, loaderConfig, callbacks);\n  }\n  scheduleRefresh(uri, ttlMs = this.timeToLoad * 1000) {\n    this.clearTimeout();\n    this.reloadTimer = self.setTimeout(() => {\n      var _this$hls;\n      const media = (_this$hls = this.hls) == null ? void 0 : _this$hls.media;\n      if (media && !media.ended) {\n        this.loadSteeringManifest(uri);\n        return;\n      }\n      this.scheduleRefresh(uri, this.timeToLoad * 1000);\n    }, ttlMs);\n  }\n}\nfunction cloneRenditionGroups(tracks, groupCloneMap, uriReplacement, cloneId) {\n  if (!tracks) {\n    return;\n  }\n  Object.keys(groupCloneMap).forEach(audioGroupId => {\n    const clonedTracks = tracks.filter(track => track.groupId === audioGroupId).map(track => {\n      const clonedTrack = _extends({}, track);\n      clonedTrack.details = undefined;\n      clonedTrack.attrs = new AttrList(clonedTrack.attrs);\n      clonedTrack.url = clonedTrack.attrs.URI = performUriReplacement(track.url, track.attrs['STABLE-RENDITION-ID'], 'PER-RENDITION-URIS', uriReplacement);\n      clonedTrack.groupId = clonedTrack.attrs['GROUP-ID'] = groupCloneMap[audioGroupId];\n      clonedTrack.attrs['PATHWAY-ID'] = cloneId;\n      return clonedTrack;\n    });\n    tracks.push(...clonedTracks);\n  });\n}\nfunction performUriReplacement(uri, stableId, perOptionKey, uriReplacement) {\n  const {\n    HOST: host,\n    PARAMS: params,\n    [perOptionKey]: perOptionUris\n  } = uriReplacement;\n  let perVariantUri;\n  if (stableId) {\n    perVariantUri = perOptionUris == null ? void 0 : perOptionUris[stableId];\n    if (perVariantUri) {\n      uri = perVariantUri;\n    }\n  }\n  const url = new self.URL(uri);\n  if (host && !perVariantUri) {\n    url.host = host;\n  }\n  if (params) {\n    Object.keys(params).sort().forEach(key => {\n      if (key) {\n        url.searchParams.set(key, params[key]);\n      }\n    });\n  }\n  return url.href;\n}\n\nfunction addEventListener(el, type, listener) {\n  removeEventListener(el, type, listener);\n  el.addEventListener(type, listener);\n}\nfunction removeEventListener(el, type, listener) {\n  el.removeEventListener(type, listener);\n}\n\n/**\n * Controller to deal with encrypted media extensions (EME)\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API\n *\n * @class\n * @constructor\n */\nclass EMEController extends Logger {\n  constructor(hls) {\n    super('eme', hls.logger);\n    this.hls = void 0;\n    this.config = void 0;\n    this.media = null;\n    this.keyFormatPromise = null;\n    this.keySystemAccessPromises = {};\n    this._requestLicenseFailureCount = 0;\n    this.mediaKeySessions = [];\n    this.keyIdToKeySessionPromise = {};\n    this.mediaKeys = null;\n    this.setMediaKeysQueue = EMEController.CDMCleanupPromise ? [EMEController.CDMCleanupPromise] : [];\n    this.onWaitingForKey = event => {\n      this.log(`\"${event.type}\" event`);\n    };\n    this.hls = hls;\n    this.config = hls.config;\n    this.registerListeners();\n  }\n  destroy() {\n    this.onDestroying();\n    this.onMediaDetached();\n    // Remove any references that could be held in config options or callbacks\n    const config = this.config;\n    config.requestMediaKeySystemAccessFunc = null;\n    config.licenseXhrSetup = config.licenseResponseCallback = undefined;\n    config.drmSystems = config.drmSystemOptions = {};\n    // @ts-ignore\n    this.hls = this.config = this.keyIdToKeySessionPromise = null;\n    // @ts-ignore\n    this.onWaitingForKey = null;\n  }\n  registerListeners() {\n    this.hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    this.hls.on(Events.MEDIA_DETACHED, this.onMediaDetached, this);\n    this.hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    this.hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    this.hls.on(Events.DESTROYING, this.onDestroying, this);\n  }\n  unregisterListeners() {\n    this.hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    this.hls.off(Events.MEDIA_DETACHED, this.onMediaDetached, this);\n    this.hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    this.hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    this.hls.off(Events.DESTROYING, this.onDestroying, this);\n  }\n  getLicenseServerUrl(keySystem) {\n    const {\n      drmSystems,\n      widevineLicenseUrl\n    } = this.config;\n    const keySystemConfiguration = drmSystems[keySystem];\n    if (keySystemConfiguration) {\n      return keySystemConfiguration.licenseUrl;\n    }\n\n    // For backward compatibility\n    if (keySystem === KeySystems.WIDEVINE && widevineLicenseUrl) {\n      return widevineLicenseUrl;\n    }\n  }\n  getLicenseServerUrlOrThrow(keySystem) {\n    const url = this.getLicenseServerUrl(keySystem);\n    if (url === undefined) {\n      throw new Error(`no license server URL configured for key-system \"${keySystem}\"`);\n    }\n    return url;\n  }\n  getServerCertificateUrl(keySystem) {\n    const {\n      drmSystems\n    } = this.config;\n    const keySystemConfiguration = drmSystems[keySystem];\n    if (keySystemConfiguration) {\n      return keySystemConfiguration.serverCertificateUrl;\n    } else {\n      this.log(`No Server Certificate in config.drmSystems[\"${keySystem}\"]`);\n    }\n  }\n  attemptKeySystemAccess(keySystemsToAttempt) {\n    const levels = this.hls.levels;\n    const uniqueCodec = (value, i, a) => !!value && a.indexOf(value) === i;\n    const audioCodecs = levels.map(level => level.audioCodec).filter(uniqueCodec);\n    const videoCodecs = levels.map(level => level.videoCodec).filter(uniqueCodec);\n    if (audioCodecs.length + videoCodecs.length === 0) {\n      videoCodecs.push('avc1.42e01e');\n    }\n    return new Promise((resolve, reject) => {\n      const attempt = keySystems => {\n        const keySystem = keySystems.shift();\n        this.getMediaKeysPromise(keySystem, audioCodecs, videoCodecs).then(mediaKeys => resolve({\n          keySystem,\n          mediaKeys\n        })).catch(error => {\n          if (keySystems.length) {\n            attempt(keySystems);\n          } else if (error instanceof EMEKeyError) {\n            reject(error);\n          } else {\n            reject(new EMEKeyError({\n              type: ErrorTypes.KEY_SYSTEM_ERROR,\n              details: ErrorDetails.KEY_SYSTEM_NO_ACCESS,\n              error,\n              fatal: true\n            }, error.message));\n          }\n        });\n      };\n      attempt(keySystemsToAttempt);\n    });\n  }\n  requestMediaKeySystemAccess(keySystem, supportedConfigurations) {\n    const {\n      requestMediaKeySystemAccessFunc\n    } = this.config;\n    if (!(typeof requestMediaKeySystemAccessFunc === 'function')) {\n      let errMessage = `Configured requestMediaKeySystemAccess is not a function ${requestMediaKeySystemAccessFunc}`;\n      if (requestMediaKeySystemAccess === null && self.location.protocol === 'http:') {\n        errMessage = `navigator.requestMediaKeySystemAccess is not available over insecure protocol ${location.protocol}`;\n      }\n      return Promise.reject(new Error(errMessage));\n    }\n    return requestMediaKeySystemAccessFunc(keySystem, supportedConfigurations);\n  }\n  getMediaKeysPromise(keySystem, audioCodecs, videoCodecs) {\n    // This can throw, but is caught in event handler callpath\n    const mediaKeySystemConfigs = getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, this.config.drmSystemOptions);\n    const keySystemAccessPromises = this.keySystemAccessPromises[keySystem];\n    let keySystemAccess = keySystemAccessPromises == null ? void 0 : keySystemAccessPromises.keySystemAccess;\n    if (!keySystemAccess) {\n      this.log(`Requesting encrypted media \"${keySystem}\" key-system access with config: ${stringify(mediaKeySystemConfigs)}`);\n      keySystemAccess = this.requestMediaKeySystemAccess(keySystem, mediaKeySystemConfigs);\n      const _keySystemAccessPromises = this.keySystemAccessPromises[keySystem] = {\n        keySystemAccess\n      };\n      keySystemAccess.catch(error => {\n        this.log(`Failed to obtain access to key-system \"${keySystem}\": ${error}`);\n      });\n      return keySystemAccess.then(mediaKeySystemAccess => {\n        this.log(`Access for key-system \"${mediaKeySystemAccess.keySystem}\" obtained`);\n        const certificateRequest = this.fetchServerCertificate(keySystem);\n        this.log(`Create media-keys for \"${keySystem}\"`);\n        _keySystemAccessPromises.mediaKeys = mediaKeySystemAccess.createMediaKeys().then(mediaKeys => {\n          this.log(`Media-keys created for \"${keySystem}\"`);\n          _keySystemAccessPromises.hasMediaKeys = true;\n          return certificateRequest.then(certificate => {\n            if (certificate) {\n              return this.setMediaKeysServerCertificate(mediaKeys, keySystem, certificate);\n            }\n            return mediaKeys;\n          });\n        });\n        _keySystemAccessPromises.mediaKeys.catch(error => {\n          this.error(`Failed to create media-keys for \"${keySystem}\"}: ${error}`);\n        });\n        return _keySystemAccessPromises.mediaKeys;\n      });\n    }\n    return keySystemAccess.then(() => keySystemAccessPromises.mediaKeys);\n  }\n  createMediaKeySessionContext({\n    decryptdata,\n    keySystem,\n    mediaKeys\n  }) {\n    this.log(`Creating key-system session \"${keySystem}\" keyId: ${Hex.hexDump(decryptdata.keyId || [])}`);\n    const mediaKeysSession = mediaKeys.createSession();\n    const mediaKeySessionContext = {\n      decryptdata,\n      keySystem,\n      mediaKeys,\n      mediaKeysSession,\n      keyStatus: 'status-pending'\n    };\n    this.mediaKeySessions.push(mediaKeySessionContext);\n    return mediaKeySessionContext;\n  }\n  renewKeySession(mediaKeySessionContext) {\n    const decryptdata = mediaKeySessionContext.decryptdata;\n    if (decryptdata.pssh) {\n      const keySessionContext = this.createMediaKeySessionContext(mediaKeySessionContext);\n      const keyId = this.getKeyIdString(decryptdata);\n      const scheme = 'cenc';\n      this.keyIdToKeySessionPromise[keyId] = this.generateRequestWithPreferredKeySession(keySessionContext, scheme, decryptdata.pssh.buffer, 'expired');\n    } else {\n      this.warn(`Could not renew expired session. Missing pssh initData.`);\n    }\n    this.removeSession(mediaKeySessionContext);\n  }\n  getKeyIdString(decryptdata) {\n    if (!decryptdata) {\n      throw new Error('Could not read keyId of undefined decryptdata');\n    }\n    if (decryptdata.keyId === null) {\n      throw new Error('keyId is null');\n    }\n    return Hex.hexDump(decryptdata.keyId);\n  }\n  updateKeySession(mediaKeySessionContext, data) {\n    var _mediaKeySessionConte;\n    const keySession = mediaKeySessionContext.mediaKeysSession;\n    this.log(`Updating key-session \"${keySession.sessionId}\" for keyID ${Hex.hexDump(((_mediaKeySessionConte = mediaKeySessionContext.decryptdata) == null ? void 0 : _mediaKeySessionConte.keyId) || [])}\n      } (data length: ${data ? data.byteLength : data})`);\n    return keySession.update(data);\n  }\n  getSelectedKeySystemFormats() {\n    return Object.keys(this.keySystemAccessPromises).map(keySystem => ({\n      keySystem,\n      hasMediaKeys: this.keySystemAccessPromises[keySystem].hasMediaKeys\n    })).filter(({\n      hasMediaKeys\n    }) => !!hasMediaKeys).map(({\n      keySystem\n    }) => keySystemDomainToKeySystemFormat(keySystem)).filter(keySystem => !!keySystem);\n  }\n  getKeySystemAccess(keySystemsToAttempt) {\n    return this.getKeySystemSelectionPromise(keySystemsToAttempt).then(({\n      keySystem,\n      mediaKeys\n    }) => {\n      return this.attemptSetMediaKeys(keySystem, mediaKeys);\n    });\n  }\n  selectKeySystem(keySystemsToAttempt) {\n    return new Promise((resolve, reject) => {\n      return this.getKeySystemSelectionPromise(keySystemsToAttempt).then(({\n        keySystem\n      }) => {\n        const keySystemFormat = keySystemDomainToKeySystemFormat(keySystem);\n        if (keySystemFormat) {\n          resolve(keySystemFormat);\n        } else {\n          reject(new Error(`Unable to find format for key-system \"${keySystem}\"`));\n        }\n      }).catch(reject);\n    });\n  }\n  selectKeySystemFormat(frag) {\n    const keyFormats = Object.keys(frag.levelkeys || {});\n    if (!this.keyFormatPromise) {\n      this.log(`Selecting key-system from fragment (sn: ${frag.sn} ${frag.type}: ${frag.level}) key formats ${keyFormats.join(', ')}`);\n      this.keyFormatPromise = this.getKeyFormatPromise(keyFormats);\n    }\n    return this.keyFormatPromise;\n  }\n  getKeyFormatPromise(keyFormats) {\n    const keySystemsInConfig = getKeySystemsForConfig(this.config);\n    const keySystemsToAttempt = keyFormats.map(keySystemFormatToKeySystemDomain).filter(value => !!value && keySystemsInConfig.indexOf(value) !== -1);\n    return this.selectKeySystem(keySystemsToAttempt);\n  }\n  loadKey(data) {\n    const decryptdata = data.keyInfo.decryptdata;\n    const keyId = this.getKeyIdString(decryptdata);\n    const keyDetails = `(keyId: ${keyId} format: \"${decryptdata.keyFormat}\" method: ${decryptdata.method} uri: ${decryptdata.uri})`;\n    this.log(`Starting session for key ${keyDetails}`);\n    let keyContextPromise = this.keyIdToKeySessionPromise[keyId];\n    if (!keyContextPromise) {\n      keyContextPromise = this.getKeySystemForKeyPromise(decryptdata).then(({\n        keySystem,\n        mediaKeys\n      }) => {\n        this.throwIfDestroyed();\n        this.log(`Handle encrypted media sn: ${data.frag.sn} ${data.frag.type}: ${data.frag.level} using key ${keyDetails}`);\n        return this.attemptSetMediaKeys(keySystem, mediaKeys).then(() => {\n          this.throwIfDestroyed();\n          return this.createMediaKeySessionContext({\n            keySystem,\n            mediaKeys,\n            decryptdata\n          });\n        });\n      });\n      const keySessionContextPromise = this.keyIdToKeySessionPromise[keyId] = keyContextPromise.then(keySessionContext => {\n        const scheme = 'cenc';\n        const initData = decryptdata.pssh ? decryptdata.pssh.buffer : null;\n        return this.generateRequestWithPreferredKeySession(keySessionContext, scheme, initData, 'playlist-key');\n      });\n      keySessionContextPromise.catch(error => this.handleError(error));\n    }\n    return keyContextPromise;\n  }\n  throwIfDestroyed(message = 'Invalid state') {\n    if (!this.hls) {\n      throw new Error('invalid state');\n    }\n  }\n  handleError(error) {\n    if (!this.hls) {\n      return;\n    }\n    this.error(error.message);\n    if (error instanceof EMEKeyError) {\n      this.hls.trigger(Events.ERROR, error.data);\n    } else {\n      this.hls.trigger(Events.ERROR, {\n        type: ErrorTypes.KEY_SYSTEM_ERROR,\n        details: ErrorDetails.KEY_SYSTEM_NO_KEYS,\n        error,\n        fatal: true\n      });\n    }\n  }\n  getKeySystemForKeyPromise(decryptdata) {\n    const keyId = this.getKeyIdString(decryptdata);\n    const mediaKeySessionContext = this.keyIdToKeySessionPromise[keyId];\n    if (!mediaKeySessionContext) {\n      const keySystem = keySystemFormatToKeySystemDomain(decryptdata.keyFormat);\n      const keySystemsToAttempt = keySystem ? [keySystem] : getKeySystemsForConfig(this.config);\n      return this.attemptKeySystemAccess(keySystemsToAttempt);\n    }\n    return mediaKeySessionContext;\n  }\n  getKeySystemSelectionPromise(keySystemsToAttempt) {\n    if (!keySystemsToAttempt.length) {\n      keySystemsToAttempt = getKeySystemsForConfig(this.config);\n    }\n    if (keySystemsToAttempt.length === 0) {\n      throw new EMEKeyError({\n        type: ErrorTypes.KEY_SYSTEM_ERROR,\n        details: ErrorDetails.KEY_SYSTEM_NO_CONFIGURED_LICENSE,\n        fatal: true\n      }, `Missing key-system license configuration options ${stringify({\n        drmSystems: this.config.drmSystems\n      })}`);\n    }\n    return this.attemptKeySystemAccess(keySystemsToAttempt);\n  }\n  attemptSetMediaKeys(keySystem, mediaKeys) {\n    if (this.mediaKeys === mediaKeys) {\n      return Promise.resolve();\n    }\n    const queue = this.setMediaKeysQueue.slice();\n    this.log(`Setting media-keys for \"${keySystem}\"`);\n    // Only one setMediaKeys() can run at one time, and multiple setMediaKeys() operations\n    // can be queued for execution for multiple key sessions.\n    const setMediaKeysPromise = Promise.all(queue).then(() => {\n      if (!this.media) {\n        this.mediaKeys = null;\n        throw new Error('Attempted to set mediaKeys without media element attached');\n      }\n      return this.media.setMediaKeys(mediaKeys);\n    });\n    this.mediaKeys = mediaKeys;\n    this.setMediaKeysQueue.push(setMediaKeysPromise);\n    return setMediaKeysPromise.then(() => {\n      this.log(`Media-keys set for \"${keySystem}\"`);\n      queue.push(setMediaKeysPromise);\n      this.setMediaKeysQueue = this.setMediaKeysQueue.filter(p => queue.indexOf(p) === -1);\n    });\n  }\n  generateRequestWithPreferredKeySession(context, initDataType, initData, reason) {\n    var _this$config$drmSyste, _this$config$drmSyste2;\n    const generateRequestFilter = (_this$config$drmSyste = this.config.drmSystems) == null ? void 0 : (_this$config$drmSyste2 = _this$config$drmSyste[context.keySystem]) == null ? void 0 : _this$config$drmSyste2.generateRequest;\n    if (generateRequestFilter) {\n      try {\n        const mappedInitData = generateRequestFilter.call(this.hls, initDataType, initData, context);\n        if (!mappedInitData) {\n          throw new Error('Invalid response from configured generateRequest filter');\n        }\n        initDataType = mappedInitData.initDataType;\n        initData = mappedInitData.initData ? mappedInitData.initData : null;\n        context.decryptdata.pssh = initData ? new Uint8Array(initData) : null;\n      } catch (error) {\n        var _this$hls;\n        this.warn(error.message);\n        if ((_this$hls = this.hls) != null && _this$hls.config.debug) {\n          throw error;\n        }\n      }\n    }\n    if (initData === null) {\n      this.log(`Skipping key-session request for \"${reason}\" (no initData)`);\n      return Promise.resolve(context);\n    }\n    const keyId = this.getKeyIdString(context.decryptdata);\n    this.log(`Generating key-session request for \"${reason}\": ${keyId} (init data type: ${initDataType} length: ${initData ? initData.byteLength : null})`);\n    const licenseStatus = new EventEmitter();\n    const onmessage = context._onmessage = event => {\n      const keySession = context.mediaKeysSession;\n      if (!keySession) {\n        licenseStatus.emit('error', new Error('invalid state'));\n        return;\n      }\n      const {\n        messageType,\n        message\n      } = event;\n      this.log(`\"${messageType}\" message event for session \"${keySession.sessionId}\" message size: ${message.byteLength}`);\n      if (messageType === 'license-request' || messageType === 'license-renewal') {\n        this.renewLicense(context, message).catch(error => {\n          if (licenseStatus.eventNames().length) {\n            licenseStatus.emit('error', error);\n          } else {\n            this.handleError(error);\n          }\n        });\n      } else if (messageType === 'license-release') {\n        if (context.keySystem === KeySystems.FAIRPLAY) {\n          this.updateKeySession(context, strToUtf8array('acknowledged'));\n          this.removeSession(context);\n        }\n      } else {\n        this.warn(`unhandled media key message type \"${messageType}\"`);\n      }\n    };\n    const onkeystatuseschange = context._onkeystatuseschange = event => {\n      const keySession = context.mediaKeysSession;\n      if (!keySession) {\n        licenseStatus.emit('error', new Error('invalid state'));\n        return;\n      }\n      this.onKeyStatusChange(context);\n      const keyStatus = context.keyStatus;\n      licenseStatus.emit('keyStatus', keyStatus);\n      if (keyStatus === 'expired') {\n        this.warn(`${context.keySystem} expired for key ${keyId}`);\n        this.renewKeySession(context);\n      }\n    };\n    addEventListener(context.mediaKeysSession, 'message', onmessage);\n    addEventListener(context.mediaKeysSession, 'keystatuseschange', onkeystatuseschange);\n    const keyUsablePromise = new Promise((resolve, reject) => {\n      licenseStatus.on('error', reject);\n      licenseStatus.on('keyStatus', keyStatus => {\n        if (keyStatus.startsWith('usable')) {\n          resolve();\n        } else if (keyStatus === 'output-restricted') {\n          reject(new EMEKeyError({\n            type: ErrorTypes.KEY_SYSTEM_ERROR,\n            details: ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED,\n            fatal: false\n          }, 'HDCP level output restricted'));\n        } else if (keyStatus === 'internal-error') {\n          reject(new EMEKeyError({\n            type: ErrorTypes.KEY_SYSTEM_ERROR,\n            details: ErrorDetails.KEY_SYSTEM_STATUS_INTERNAL_ERROR,\n            fatal: true\n          }, `key status changed to \"${keyStatus}\"`));\n        } else if (keyStatus === 'expired') {\n          reject(new Error('key expired while generating request'));\n        } else {\n          this.warn(`unhandled key status change \"${keyStatus}\"`);\n        }\n      });\n    });\n    return context.mediaKeysSession.generateRequest(initDataType, initData).then(() => {\n      var _context$mediaKeysSes;\n      this.log(`Request generated for key-session \"${(_context$mediaKeysSes = context.mediaKeysSession) == null ? void 0 : _context$mediaKeysSes.sessionId}\" keyId: ${keyId}`);\n    }).catch(error => {\n      throw new EMEKeyError({\n        type: ErrorTypes.KEY_SYSTEM_ERROR,\n        details: ErrorDetails.KEY_SYSTEM_NO_SESSION,\n        error,\n        fatal: false\n      }, `Error generating key-session request: ${error}`);\n    }).then(() => keyUsablePromise).catch(error => {\n      licenseStatus.removeAllListeners();\n      this.removeSession(context);\n      throw error;\n    }).then(() => {\n      licenseStatus.removeAllListeners();\n      return context;\n    });\n  }\n  onKeyStatusChange(mediaKeySessionContext) {\n    mediaKeySessionContext.mediaKeysSession.keyStatuses.forEach((status, keyId) => {\n      // keyStatuses.forEach is not standard API so the callback value looks weird on xboxone\n      // xboxone callback(keyId, status) so we need to exchange them\n      if (typeof keyId === 'string' && typeof status === 'object') {\n        const temp = keyId;\n        keyId = status;\n        status = temp;\n      }\n      this.log(`key status change \"${status}\" for keyStatuses keyId: ${Hex.hexDump('buffer' in keyId ? new Uint8Array(keyId.buffer, keyId.byteOffset, keyId.byteLength) : new Uint8Array(keyId))} session keyId: ${Hex.hexDump(new Uint8Array(mediaKeySessionContext.decryptdata.keyId || []))} uri: ${mediaKeySessionContext.decryptdata.uri}`);\n      mediaKeySessionContext.keyStatus = status;\n    });\n  }\n  fetchServerCertificate(keySystem) {\n    const config = this.config;\n    const Loader = config.loader;\n    const certLoader = new Loader(config);\n    const url = this.getServerCertificateUrl(keySystem);\n    if (!url) {\n      return Promise.resolve();\n    }\n    this.log(`Fetching server certificate for \"${keySystem}\"`);\n    return new Promise((resolve, reject) => {\n      const loaderContext = {\n        responseType: 'arraybuffer',\n        url\n      };\n      const loadPolicy = config.certLoadPolicy.default;\n      const loaderConfig = {\n        loadPolicy,\n        timeout: loadPolicy.maxLoadTimeMs,\n        maxRetry: 0,\n        retryDelay: 0,\n        maxRetryDelay: 0\n      };\n      const loaderCallbacks = {\n        onSuccess: (response, stats, context, networkDetails) => {\n          resolve(response.data);\n        },\n        onError: (response, contex, networkDetails, stats) => {\n          reject(new EMEKeyError({\n            type: ErrorTypes.KEY_SYSTEM_ERROR,\n            details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,\n            fatal: true,\n            networkDetails,\n            response: _objectSpread2({\n              url: loaderContext.url,\n              data: undefined\n            }, response)\n          }, `\"${keySystem}\" certificate request failed (${url}). Status: ${response.code} (${response.text})`));\n        },\n        onTimeout: (stats, context, networkDetails) => {\n          reject(new EMEKeyError({\n            type: ErrorTypes.KEY_SYSTEM_ERROR,\n            details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,\n            fatal: true,\n            networkDetails,\n            response: {\n              url: loaderContext.url,\n              data: undefined\n            }\n          }, `\"${keySystem}\" certificate request timed out (${url})`));\n        },\n        onAbort: (stats, context, networkDetails) => {\n          reject(new Error('aborted'));\n        }\n      };\n      certLoader.load(loaderContext, loaderConfig, loaderCallbacks);\n    });\n  }\n  setMediaKeysServerCertificate(mediaKeys, keySystem, cert) {\n    return new Promise((resolve, reject) => {\n      mediaKeys.setServerCertificate(cert).then(success => {\n        this.log(`setServerCertificate ${success ? 'success' : 'not supported by CDM'} (${cert == null ? void 0 : cert.byteLength}) on \"${keySystem}\"`);\n        resolve(mediaKeys);\n      }).catch(error => {\n        reject(new EMEKeyError({\n          type: ErrorTypes.KEY_SYSTEM_ERROR,\n          details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED,\n          error,\n          fatal: true\n        }, error.message));\n      });\n    });\n  }\n  renewLicense(context, keyMessage) {\n    return this.requestLicense(context, new Uint8Array(keyMessage)).then(data => {\n      return this.updateKeySession(context, new Uint8Array(data)).catch(error => {\n        throw new EMEKeyError({\n          type: ErrorTypes.KEY_SYSTEM_ERROR,\n          details: ErrorDetails.KEY_SYSTEM_SESSION_UPDATE_FAILED,\n          error,\n          fatal: true\n        }, error.message);\n      });\n    });\n  }\n  unpackPlayReadyKeyMessage(xhr, licenseChallenge) {\n    // On Edge, the raw license message is UTF-16-encoded XML.  We need\n    // to unpack the Challenge element (base64-encoded string containing the\n    // actual license request) and any HttpHeader elements (sent as request\n    // headers).\n    // For PlayReady CDMs, we need to dig the Challenge out of the XML.\n    const xmlString = String.fromCharCode.apply(null, new Uint16Array(licenseChallenge.buffer));\n    if (!xmlString.includes('PlayReadyKeyMessage')) {\n      // This does not appear to be a wrapped message as on Edge.  Some\n      // clients do not need this unwrapping, so we will assume this is one of\n      // them.  Note that \"xml\" at this point probably looks like random\n      // garbage, since we interpreted UTF-8 as UTF-16.\n      xhr.setRequestHeader('Content-Type', 'text/xml; charset=utf-8');\n      return licenseChallenge;\n    }\n    const keyMessageXml = new DOMParser().parseFromString(xmlString, 'application/xml');\n    // Set request headers.\n    const headers = keyMessageXml.querySelectorAll('HttpHeader');\n    if (headers.length > 0) {\n      let header;\n      for (let i = 0, len = headers.length; i < len; i++) {\n        var _header$querySelector, _header$querySelector2;\n        header = headers[i];\n        const name = (_header$querySelector = header.querySelector('name')) == null ? void 0 : _header$querySelector.textContent;\n        const value = (_header$querySelector2 = header.querySelector('value')) == null ? void 0 : _header$querySelector2.textContent;\n        if (name && value) {\n          xhr.setRequestHeader(name, value);\n        }\n      }\n    }\n    const challengeElement = keyMessageXml.querySelector('Challenge');\n    const challengeText = challengeElement == null ? void 0 : challengeElement.textContent;\n    if (!challengeText) {\n      throw new Error(`Cannot find <Challenge> in key message`);\n    }\n    return strToUtf8array(atob(challengeText));\n  }\n  setupLicenseXHR(xhr, url, keysListItem, licenseChallenge) {\n    const licenseXhrSetup = this.config.licenseXhrSetup;\n    if (!licenseXhrSetup) {\n      xhr.open('POST', url, true);\n      return Promise.resolve({\n        xhr,\n        licenseChallenge\n      });\n    }\n    return Promise.resolve().then(() => {\n      if (!keysListItem.decryptdata) {\n        throw new Error('Key removed');\n      }\n      return licenseXhrSetup.call(this.hls, xhr, url, keysListItem, licenseChallenge);\n    }).catch(error => {\n      if (!keysListItem.decryptdata) {\n        // Key session removed. Cancel license request.\n        throw error;\n      }\n      // let's try to open before running setup\n      xhr.open('POST', url, true);\n      return licenseXhrSetup.call(this.hls, xhr, url, keysListItem, licenseChallenge);\n    }).then(licenseXhrSetupResult => {\n      // if licenseXhrSetup did not yet call open, let's do it now\n      if (!xhr.readyState) {\n        xhr.open('POST', url, true);\n      }\n      const finalLicenseChallenge = licenseXhrSetupResult ? licenseXhrSetupResult : licenseChallenge;\n      return {\n        xhr,\n        licenseChallenge: finalLicenseChallenge\n      };\n    });\n  }\n  requestLicense(keySessionContext, licenseChallenge) {\n    const keyLoadPolicy = this.config.keyLoadPolicy.default;\n    return new Promise((resolve, reject) => {\n      const url = this.getLicenseServerUrlOrThrow(keySessionContext.keySystem);\n      this.log(`Sending license request to URL: ${url}`);\n      const xhr = new XMLHttpRequest();\n      xhr.responseType = 'arraybuffer';\n      xhr.onreadystatechange = () => {\n        if (!this.hls || !keySessionContext.mediaKeysSession) {\n          return reject(new Error('invalid state'));\n        }\n        if (xhr.readyState === 4) {\n          if (xhr.status === 200) {\n            this._requestLicenseFailureCount = 0;\n            let data = xhr.response;\n            this.log(`License received ${data instanceof ArrayBuffer ? data.byteLength : data}`);\n            const licenseResponseCallback = this.config.licenseResponseCallback;\n            if (licenseResponseCallback) {\n              try {\n                data = licenseResponseCallback.call(this.hls, xhr, url, keySessionContext);\n              } catch (error) {\n                this.error(error);\n              }\n            }\n            resolve(data);\n          } else {\n            const retryConfig = keyLoadPolicy.errorRetry;\n            const maxNumRetry = retryConfig ? retryConfig.maxNumRetry : 0;\n            this._requestLicenseFailureCount++;\n            if (this._requestLicenseFailureCount > maxNumRetry || xhr.status >= 400 && xhr.status < 500) {\n              reject(new EMEKeyError({\n                type: ErrorTypes.KEY_SYSTEM_ERROR,\n                details: ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,\n                fatal: true,\n                networkDetails: xhr,\n                response: {\n                  url,\n                  data: undefined,\n                  code: xhr.status,\n                  text: xhr.statusText\n                }\n              }, `License Request XHR failed (${url}). Status: ${xhr.status} (${xhr.statusText})`));\n            } else {\n              const attemptsLeft = maxNumRetry - this._requestLicenseFailureCount + 1;\n              this.warn(`Retrying license request, ${attemptsLeft} attempts left`);\n              this.requestLicense(keySessionContext, licenseChallenge).then(resolve, reject);\n            }\n          }\n        }\n      };\n      if (keySessionContext.licenseXhr && keySessionContext.licenseXhr.readyState !== XMLHttpRequest.DONE) {\n        keySessionContext.licenseXhr.abort();\n      }\n      keySessionContext.licenseXhr = xhr;\n      this.setupLicenseXHR(xhr, url, keySessionContext, licenseChallenge).then(({\n        xhr,\n        licenseChallenge\n      }) => {\n        if (keySessionContext.keySystem == KeySystems.PLAYREADY) {\n          licenseChallenge = this.unpackPlayReadyKeyMessage(xhr, licenseChallenge);\n        }\n        xhr.send(licenseChallenge);\n      });\n    });\n  }\n  onDestroying() {\n    this.unregisterListeners();\n    this._clear();\n  }\n  onMediaAttached(event, data) {\n    if (!this.config.emeEnabled) {\n      return;\n    }\n    const media = data.media;\n\n    // keep reference of media\n    this.media = media;\n    addEventListener(media, 'waitingforkey', this.onWaitingForKey);\n  }\n  onMediaDetached() {\n    const media = this.media;\n    if (media) {\n      removeEventListener(media, 'waitingforkey', this.onWaitingForKey);\n      this.media = null;\n      this.mediaKeys = null;\n    }\n  }\n  _clear() {\n    var _media$setMediaKeys;\n    this._requestLicenseFailureCount = 0;\n    this.keyIdToKeySessionPromise = {};\n    if (!this.mediaKeys && !this.mediaKeySessions.length) {\n      return;\n    }\n    const media = this.media;\n    const mediaKeysList = this.mediaKeySessions.slice();\n    this.mediaKeySessions = [];\n    this.mediaKeys = null;\n    LevelKey.clearKeyUriToKeyIdMap();\n\n    // Close all sessions and remove media keys from the video element.\n    const keySessionCount = mediaKeysList.length;\n    EMEController.CDMCleanupPromise = Promise.all(mediaKeysList.map(mediaKeySessionContext => this.removeSession(mediaKeySessionContext)).concat(media == null ? void 0 : (_media$setMediaKeys = media.setMediaKeys(null)) == null ? void 0 : _media$setMediaKeys.catch(error => {\n      var _this$hls2;\n      this.log(`Could not clear media keys: ${error}`);\n      (_this$hls2 = this.hls) == null ? void 0 : _this$hls2.trigger(Events.ERROR, {\n        type: ErrorTypes.OTHER_ERROR,\n        details: ErrorDetails.KEY_SYSTEM_DESTROY_MEDIA_KEYS_ERROR,\n        fatal: false,\n        error: new Error(`Could not clear media keys: ${error}`)\n      });\n    }))).catch(error => {\n      var _this$hls3;\n      this.log(`Could not close sessions and clear media keys: ${error}`);\n      (_this$hls3 = this.hls) == null ? void 0 : _this$hls3.trigger(Events.ERROR, {\n        type: ErrorTypes.OTHER_ERROR,\n        details: ErrorDetails.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR,\n        fatal: false,\n        error: new Error(`Could not close sessions and clear media keys: ${error}`)\n      });\n    }).then(() => {\n      if (keySessionCount) {\n        this.log('finished closing key sessions and clearing media keys');\n      }\n    });\n  }\n  onManifestLoading() {\n    this.keyFormatPromise = null;\n  }\n  onManifestLoaded(event, {\n    sessionKeys\n  }) {\n    if (!sessionKeys || !this.config.emeEnabled) {\n      return;\n    }\n    if (!this.keyFormatPromise) {\n      const keyFormats = sessionKeys.reduce((formats, sessionKey) => {\n        if (formats.indexOf(sessionKey.keyFormat) === -1) {\n          formats.push(sessionKey.keyFormat);\n        }\n        return formats;\n      }, []);\n      this.log(`Selecting key-system from session-keys ${keyFormats.join(', ')}`);\n      this.keyFormatPromise = this.getKeyFormatPromise(keyFormats);\n    }\n  }\n  removeSession(mediaKeySessionContext) {\n    const {\n      mediaKeysSession,\n      licenseXhr\n    } = mediaKeySessionContext;\n    if (mediaKeysSession) {\n      this.log(`Remove licenses and keys and close session ${mediaKeysSession.sessionId}`);\n      if (mediaKeySessionContext._onmessage) {\n        mediaKeysSession.removeEventListener('message', mediaKeySessionContext._onmessage);\n        mediaKeySessionContext._onmessage = undefined;\n      }\n      if (mediaKeySessionContext._onkeystatuseschange) {\n        mediaKeysSession.removeEventListener('keystatuseschange', mediaKeySessionContext._onkeystatuseschange);\n        mediaKeySessionContext._onkeystatuseschange = undefined;\n      }\n      if (licenseXhr && licenseXhr.readyState !== XMLHttpRequest.DONE) {\n        licenseXhr.abort();\n      }\n      mediaKeySessionContext.mediaKeysSession = mediaKeySessionContext.decryptdata = mediaKeySessionContext.licenseXhr = undefined;\n      const index = this.mediaKeySessions.indexOf(mediaKeySessionContext);\n      if (index > -1) {\n        this.mediaKeySessions.splice(index, 1);\n      }\n      const {\n        drmSystemOptions\n      } = this.config;\n      const removePromise = isPersistentSessionType(drmSystemOptions) ? new Promise((resolve, reject) => {\n        self.setTimeout(() => reject(new Error(`MediaKeySession.remove() timeout`)), 8000);\n        mediaKeysSession.remove().then(resolve);\n      }) : Promise.resolve();\n      return removePromise.catch(error => {\n        var _this$hls4;\n        this.log(`Could not remove session: ${error}`);\n        (_this$hls4 = this.hls) == null ? void 0 : _this$hls4.trigger(Events.ERROR, {\n          type: ErrorTypes.OTHER_ERROR,\n          details: ErrorDetails.KEY_SYSTEM_DESTROY_REMOVE_SESSION_ERROR,\n          fatal: false,\n          error: new Error(`Could not remove session: ${error}`)\n        });\n      }).then(() => {\n        return mediaKeysSession.close();\n      }).catch(error => {\n        var _this$hls5;\n        this.log(`Could not close session: ${error}`);\n        (_this$hls5 = this.hls) == null ? void 0 : _this$hls5.trigger(Events.ERROR, {\n          type: ErrorTypes.OTHER_ERROR,\n          details: ErrorDetails.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR,\n          fatal: false,\n          error: new Error(`Could not close session: ${error}`)\n        });\n      });\n    }\n  }\n}\nEMEController.CDMCleanupPromise = void 0;\nclass EMEKeyError extends Error {\n  constructor(data, message) {\n    super(message);\n    this.data = void 0;\n    data.error || (data.error = new Error(message));\n    this.data = data;\n    data.err = data.error;\n  }\n}\n\nclass FPSController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.isVideoPlaybackQualityAvailable = false;\n    this.timer = void 0;\n    this.media = null;\n    this.lastTime = void 0;\n    this.lastDroppedFrames = 0;\n    this.lastDecodedFrames = 0;\n    // stream controller must be provided as a dependency!\n    this.streamController = void 0;\n    this.hls = hls;\n    this.registerListeners();\n  }\n  setStreamController(streamController) {\n    this.streamController = streamController;\n  }\n  registerListeners() {\n    this.hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    this.hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n  }\n  unregisterListeners() {\n    this.hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    this.hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n  }\n  destroy() {\n    if (this.timer) {\n      clearInterval(this.timer);\n    }\n    this.unregisterListeners();\n    this.isVideoPlaybackQualityAvailable = false;\n    this.media = null;\n  }\n  onMediaAttaching(event, data) {\n    const config = this.hls.config;\n    if (config.capLevelOnFPSDrop) {\n      const media = data.media instanceof self.HTMLVideoElement ? data.media : null;\n      this.media = media;\n      if (media && typeof media.getVideoPlaybackQuality === 'function') {\n        this.isVideoPlaybackQualityAvailable = true;\n      }\n      self.clearInterval(this.timer);\n      this.timer = self.setInterval(this.checkFPSInterval.bind(this), config.fpsDroppedMonitoringPeriod);\n    }\n  }\n  onMediaDetaching() {\n    this.media = null;\n  }\n  checkFPS(video, decodedFrames, droppedFrames) {\n    const currentTime = performance.now();\n    if (decodedFrames) {\n      if (this.lastTime) {\n        const currentPeriod = currentTime - this.lastTime;\n        const currentDropped = droppedFrames - this.lastDroppedFrames;\n        const currentDecoded = decodedFrames - this.lastDecodedFrames;\n        const droppedFPS = 1000 * currentDropped / currentPeriod;\n        const hls = this.hls;\n        hls.trigger(Events.FPS_DROP, {\n          currentDropped: currentDropped,\n          currentDecoded: currentDecoded,\n          totalDroppedFrames: droppedFrames\n        });\n        if (droppedFPS > 0) {\n          // hls.logger.log('checkFPS : droppedFPS/decodedFPS:' + droppedFPS/(1000 * currentDecoded / currentPeriod));\n          if (currentDropped > hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {\n            let currentLevel = hls.currentLevel;\n            hls.logger.warn('drop FPS ratio greater than max allowed value for currentLevel: ' + currentLevel);\n            if (currentLevel > 0 && (hls.autoLevelCapping === -1 || hls.autoLevelCapping >= currentLevel)) {\n              currentLevel = currentLevel - 1;\n              hls.trigger(Events.FPS_DROP_LEVEL_CAPPING, {\n                level: currentLevel,\n                droppedLevel: hls.currentLevel\n              });\n              hls.autoLevelCapping = currentLevel;\n              this.streamController.nextLevelSwitch();\n            }\n          }\n        }\n      }\n      this.lastTime = currentTime;\n      this.lastDroppedFrames = droppedFrames;\n      this.lastDecodedFrames = decodedFrames;\n    }\n  }\n  checkFPSInterval() {\n    const video = this.media;\n    if (video) {\n      if (this.isVideoPlaybackQualityAvailable) {\n        const videoPlaybackQuality = video.getVideoPlaybackQuality();\n        this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);\n      } else {\n        // HTMLVideoElement doesn't include the webkit types\n        this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);\n      }\n    }\n  }\n}\n\nfunction sendAddTrackEvent(track, videoEl) {\n  let event;\n  try {\n    event = new Event('addtrack');\n  } catch (err) {\n    // for IE11\n    event = document.createEvent('Event');\n    event.initEvent('addtrack', false, false);\n  }\n  event.track = track;\n  videoEl.dispatchEvent(event);\n}\nfunction addCueToTrack(track, cue) {\n  // Sometimes there are cue overlaps on segmented vtts so the same\n  // cue can appear more than once in different vtt files.\n  // This avoid showing duplicated cues with same timecode and text.\n  const mode = track.mode;\n  if (mode === 'disabled') {\n    track.mode = 'hidden';\n  }\n  if (track.cues && !track.cues.getCueById(cue.id)) {\n    try {\n      track.addCue(cue);\n      if (!track.cues.getCueById(cue.id)) {\n        throw new Error(`addCue is failed for: ${cue}`);\n      }\n    } catch (err) {\n      logger.debug(`[texttrack-utils]: ${err}`);\n      try {\n        const textTrackCue = new self.TextTrackCue(cue.startTime, cue.endTime, cue.text);\n        textTrackCue.id = cue.id;\n        track.addCue(textTrackCue);\n      } catch (err2) {\n        logger.debug(`[texttrack-utils]: Legacy TextTrackCue fallback failed: ${err2}`);\n      }\n    }\n  }\n  if (mode === 'disabled') {\n    track.mode = mode;\n  }\n}\nfunction clearCurrentCues(track, enterHandler) {\n  // When track.mode is disabled, track.cues will be null.\n  // To guarantee the removal of cues, we need to temporarily\n  // change the mode to hidden\n  const mode = track.mode;\n  if (mode === 'disabled') {\n    track.mode = 'hidden';\n  }\n  if (track.cues) {\n    for (let i = track.cues.length; i--;) {\n      if (enterHandler) {\n        track.cues[i].removeEventListener('enter', enterHandler);\n      }\n      track.removeCue(track.cues[i]);\n    }\n  }\n  if (mode === 'disabled') {\n    track.mode = mode;\n  }\n}\nfunction removeCuesInRange(track, start, end, predicate) {\n  const mode = track.mode;\n  if (mode === 'disabled') {\n    track.mode = 'hidden';\n  }\n  if (track.cues && track.cues.length > 0) {\n    const cues = getCuesInRange(track.cues, start, end);\n    for (let i = 0; i < cues.length; i++) {\n      if (!predicate || predicate(cues[i])) {\n        track.removeCue(cues[i]);\n      }\n    }\n  }\n  if (mode === 'disabled') {\n    track.mode = mode;\n  }\n}\n\n// Find first cue starting at or after given time.\n// Modified version of binary search O(log(n)).\nfunction getFirstCueIndexFromTime(cues, time) {\n  // If first cue starts at or after time, start there\n  if (time <= cues[0].startTime) {\n    return 0;\n  }\n  // If the last cue ends before time there is no overlap\n  const len = cues.length - 1;\n  if (time > cues[len].endTime) {\n    return -1;\n  }\n  let left = 0;\n  let right = len;\n  let mid;\n  while (left <= right) {\n    mid = Math.floor((right + left) / 2);\n    if (time < cues[mid].startTime) {\n      right = mid - 1;\n    } else if (time > cues[mid].startTime && left < len) {\n      left = mid + 1;\n    } else {\n      // If it's not lower or higher, it must be equal.\n      return mid;\n    }\n  }\n  // At this point, left and right have swapped.\n  // No direct match was found, left or right element must be the closest. Check which one has the smallest diff.\n  return cues[left].startTime - time < time - cues[right].startTime ? left : right;\n}\nfunction getCuesInRange(cues, start, end) {\n  const cuesFound = [];\n  const firstCueInRange = getFirstCueIndexFromTime(cues, start);\n  if (firstCueInRange > -1) {\n    for (let i = firstCueInRange, len = cues.length; i < len; i++) {\n      const cue = cues[i];\n      if (cue.startTime >= start && cue.endTime <= end) {\n        cuesFound.push(cue);\n      } else if (cue.startTime > end) {\n        return cuesFound;\n      }\n    }\n  }\n  return cuesFound;\n}\nfunction filterSubtitleTracks(textTrackList) {\n  const tracks = [];\n  for (let i = 0; i < textTrackList.length; i++) {\n    const track = textTrackList[i];\n    // Edge adds a track without a label; we don't want to use it\n    if ((track.kind === 'subtitles' || track.kind === 'captions') && track.label) {\n      tracks.push(textTrackList[i]);\n    }\n  }\n  return tracks;\n}\n\nclass SubtitleTrackController extends BasePlaylistController {\n  constructor(hls) {\n    super(hls, 'subtitle-track-controller');\n    this.media = null;\n    this.tracks = [];\n    this.groupIds = null;\n    this.tracksInGroup = [];\n    this.trackId = -1;\n    this.currentTrack = null;\n    this.selectDefaultTrack = true;\n    this.queuedDefaultTrack = -1;\n    this.useTextTrackPolling = false;\n    this.subtitlePollingInterval = -1;\n    this._subtitleDisplay = true;\n    this.asyncPollTrackChange = () => this.pollTrackChange(0);\n    this.onTextTracksChanged = () => {\n      if (!this.useTextTrackPolling) {\n        self.clearInterval(this.subtitlePollingInterval);\n      }\n      // Media is undefined when switching streams via loadSource()\n      if (!this.media || !this.hls.config.renderTextTracksNatively) {\n        return;\n      }\n      let textTrack = null;\n      const tracks = filterSubtitleTracks(this.media.textTracks);\n      for (let i = 0; i < tracks.length; i++) {\n        if (tracks[i].mode === 'hidden') {\n          // Do not break in case there is a following track with showing.\n          textTrack = tracks[i];\n        } else if (tracks[i].mode === 'showing') {\n          textTrack = tracks[i];\n          break;\n        }\n      }\n\n      // Find internal track index for TextTrack\n      const trackId = this.findTrackForTextTrack(textTrack);\n      if (this.subtitleTrack !== trackId) {\n        this.setSubtitleTrack(trackId);\n      }\n    };\n    this.registerListeners();\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.tracks.length = 0;\n    this.tracksInGroup.length = 0;\n    this.currentTrack = null;\n    // @ts-ignore\n    this.onTextTracksChanged = this.asyncPollTrackChange = null;\n    super.destroy();\n  }\n  get subtitleDisplay() {\n    return this._subtitleDisplay;\n  }\n  set subtitleDisplay(value) {\n    this._subtitleDisplay = value;\n    if (this.trackId > -1) {\n      this.toggleTrackModes();\n    }\n  }\n  registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.on(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n    hls.on(Events.ERROR, this.onError, this);\n  }\n  unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.off(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n    hls.off(Events.ERROR, this.onError, this);\n  }\n\n  // Listen for subtitle track change, then extract the current track ID.\n  onMediaAttached(event, data) {\n    this.media = data.media;\n    if (!this.media) {\n      return;\n    }\n    if (this.queuedDefaultTrack > -1) {\n      this.subtitleTrack = this.queuedDefaultTrack;\n      this.queuedDefaultTrack = -1;\n    }\n    this.useTextTrackPolling = !(this.media.textTracks && 'onchange' in this.media.textTracks);\n    if (this.useTextTrackPolling) {\n      this.pollTrackChange(500);\n    } else {\n      this.media.textTracks.addEventListener('change', this.asyncPollTrackChange);\n    }\n  }\n  pollTrackChange(timeout) {\n    self.clearInterval(this.subtitlePollingInterval);\n    this.subtitlePollingInterval = self.setInterval(this.onTextTracksChanged, timeout);\n  }\n  onMediaDetaching(event, data) {\n    const media = this.media;\n    if (!media) {\n      return;\n    }\n    const transferringMedia = !!data.transferMedia;\n    self.clearInterval(this.subtitlePollingInterval);\n    if (!this.useTextTrackPolling) {\n      media.textTracks.removeEventListener('change', this.asyncPollTrackChange);\n    }\n    if (this.trackId > -1) {\n      this.queuedDefaultTrack = this.trackId;\n    }\n\n    // Disable all subtitle tracks before detachment so when reattached only tracks in that content are enabled.\n    this.subtitleTrack = -1;\n    this.media = null;\n    if (transferringMedia) {\n      return;\n    }\n    const textTracks = filterSubtitleTracks(media.textTracks);\n    // Clear loaded cues on media detachment from tracks\n    textTracks.forEach(track => {\n      clearCurrentCues(track);\n    });\n  }\n  onManifestLoading() {\n    this.tracks = [];\n    this.groupIds = null;\n    this.tracksInGroup = [];\n    this.trackId = -1;\n    this.currentTrack = null;\n    this.selectDefaultTrack = true;\n  }\n\n  // Fired whenever a new manifest is loaded.\n  onManifestParsed(event, data) {\n    this.tracks = data.subtitleTracks;\n  }\n  onSubtitleTrackLoaded(event, data) {\n    const {\n      id,\n      groupId,\n      details\n    } = data;\n    const trackInActiveGroup = this.tracksInGroup[id];\n    if (!trackInActiveGroup || trackInActiveGroup.groupId !== groupId) {\n      this.warn(`Subtitle track with id:${id} and group:${groupId} not found in active group ${trackInActiveGroup == null ? void 0 : trackInActiveGroup.groupId}`);\n      return;\n    }\n    const curDetails = trackInActiveGroup.details;\n    trackInActiveGroup.details = data.details;\n    this.log(`Subtitle track ${id} \"${trackInActiveGroup.name}\" lang:${trackInActiveGroup.lang} group:${groupId} loaded [${details.startSN}-${details.endSN}]`);\n    if (id === this.trackId) {\n      this.playlistLoaded(id, data, curDetails);\n    }\n  }\n  onLevelLoading(event, data) {\n    this.switchLevel(data.level);\n  }\n  onLevelSwitching(event, data) {\n    this.switchLevel(data.level);\n  }\n  switchLevel(levelIndex) {\n    const levelInfo = this.hls.levels[levelIndex];\n    if (!levelInfo) {\n      return;\n    }\n    const subtitleGroups = levelInfo.subtitleGroups || null;\n    const currentGroups = this.groupIds;\n    let currentTrack = this.currentTrack;\n    if (!subtitleGroups || (currentGroups == null ? void 0 : currentGroups.length) !== (subtitleGroups == null ? void 0 : subtitleGroups.length) || subtitleGroups != null && subtitleGroups.some(groupId => (currentGroups == null ? void 0 : currentGroups.indexOf(groupId)) === -1)) {\n      this.groupIds = subtitleGroups;\n      this.trackId = -1;\n      this.currentTrack = null;\n      const subtitleTracks = this.tracks.filter(track => !subtitleGroups || subtitleGroups.indexOf(track.groupId) !== -1);\n      if (subtitleTracks.length) {\n        // Disable selectDefaultTrack if there are no default tracks\n        if (this.selectDefaultTrack && !subtitleTracks.some(track => track.default)) {\n          this.selectDefaultTrack = false;\n        }\n        // track.id should match hls.audioTracks index\n        subtitleTracks.forEach((track, i) => {\n          track.id = i;\n        });\n      } else if (!currentTrack && !this.tracksInGroup.length) {\n        // Do not dispatch SUBTITLE_TRACKS_UPDATED when there were and are no tracks\n        return;\n      }\n      this.tracksInGroup = subtitleTracks;\n\n      // Find preferred track\n      const subtitlePreference = this.hls.config.subtitlePreference;\n      if (!currentTrack && subtitlePreference) {\n        this.selectDefaultTrack = false;\n        const groupIndex = findMatchingOption(subtitlePreference, subtitleTracks);\n        if (groupIndex > -1) {\n          currentTrack = subtitleTracks[groupIndex];\n        } else {\n          const allIndex = findMatchingOption(subtitlePreference, this.tracks);\n          currentTrack = this.tracks[allIndex];\n        }\n      }\n\n      // Select initial track\n      let trackId = this.findTrackId(currentTrack);\n      if (trackId === -1 && currentTrack) {\n        trackId = this.findTrackId(null);\n      }\n\n      // Dispatch events and load track if needed\n      const subtitleTracksUpdated = {\n        subtitleTracks\n      };\n      this.log(`Updating subtitle tracks, ${subtitleTracks.length} track(s) found in \"${subtitleGroups == null ? void 0 : subtitleGroups.join(',')}\" group-id`);\n      this.hls.trigger(Events.SUBTITLE_TRACKS_UPDATED, subtitleTracksUpdated);\n      if (trackId !== -1 && this.trackId === -1) {\n        this.setSubtitleTrack(trackId);\n      }\n    }\n  }\n  findTrackId(currentTrack) {\n    const tracks = this.tracksInGroup;\n    const selectDefault = this.selectDefaultTrack;\n    for (let i = 0; i < tracks.length; i++) {\n      const track = tracks[i];\n      if (selectDefault && !track.default || !selectDefault && !currentTrack) {\n        continue;\n      }\n      if (!currentTrack || matchesOption(track, currentTrack)) {\n        return i;\n      }\n    }\n    if (currentTrack) {\n      for (let i = 0; i < tracks.length; i++) {\n        const track = tracks[i];\n        if (mediaAttributesIdentical(currentTrack.attrs, track.attrs, ['LANGUAGE', 'ASSOC-LANGUAGE', 'CHARACTERISTICS'])) {\n          return i;\n        }\n      }\n      for (let i = 0; i < tracks.length; i++) {\n        const track = tracks[i];\n        if (mediaAttributesIdentical(currentTrack.attrs, track.attrs, ['LANGUAGE'])) {\n          return i;\n        }\n      }\n    }\n    return -1;\n  }\n  findTrackForTextTrack(textTrack) {\n    if (textTrack) {\n      const tracks = this.tracksInGroup;\n      for (let i = 0; i < tracks.length; i++) {\n        const track = tracks[i];\n        if (subtitleTrackMatchesTextTrack(track, textTrack)) {\n          return i;\n        }\n      }\n    }\n    return -1;\n  }\n  onError(event, data) {\n    if (data.fatal || !data.context) {\n      return;\n    }\n    if (data.context.type === PlaylistContextType.SUBTITLE_TRACK && data.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(data.context.groupId) !== -1)) {\n      this.checkRetry(data);\n    }\n  }\n  get allSubtitleTracks() {\n    return this.tracks;\n  }\n\n  /** get alternate subtitle tracks list from playlist **/\n  get subtitleTracks() {\n    return this.tracksInGroup;\n  }\n\n  /** get/set index of the selected subtitle track (based on index in subtitle track lists) **/\n  get subtitleTrack() {\n    return this.trackId;\n  }\n  set subtitleTrack(newId) {\n    this.selectDefaultTrack = false;\n    this.setSubtitleTrack(newId);\n  }\n  setSubtitleOption(subtitleOption) {\n    this.hls.config.subtitlePreference = subtitleOption;\n    if (subtitleOption) {\n      if (subtitleOption.id === -1) {\n        this.setSubtitleTrack(-1);\n        return null;\n      }\n      const allSubtitleTracks = this.allSubtitleTracks;\n      this.selectDefaultTrack = false;\n      if (allSubtitleTracks.length) {\n        // First see if current option matches (no switch op)\n        const currentTrack = this.currentTrack;\n        if (currentTrack && matchesOption(subtitleOption, currentTrack)) {\n          return currentTrack;\n        }\n        // Find option in current group\n        const groupIndex = findMatchingOption(subtitleOption, this.tracksInGroup);\n        if (groupIndex > -1) {\n          const track = this.tracksInGroup[groupIndex];\n          this.setSubtitleTrack(groupIndex);\n          return track;\n        } else if (currentTrack) {\n          // If this is not the initial selection return null\n          // option should have matched one in active group\n          return null;\n        } else {\n          // Find the option in all tracks for initial selection\n          const allIndex = findMatchingOption(subtitleOption, allSubtitleTracks);\n          if (allIndex > -1) {\n            return allSubtitleTracks[allIndex];\n          }\n        }\n      }\n    }\n    return null;\n  }\n  loadPlaylist(hlsUrlParameters) {\n    super.loadPlaylist();\n    if (this.shouldLoadPlaylist(this.currentTrack)) {\n      this.scheduleLoading(this.currentTrack, hlsUrlParameters);\n    }\n  }\n  loadingPlaylist(currentTrack, hlsUrlParameters) {\n    super.loadingPlaylist(currentTrack, hlsUrlParameters);\n    const id = currentTrack.id;\n    const groupId = currentTrack.groupId;\n    const url = this.getUrlWithDirectives(currentTrack.url, hlsUrlParameters);\n    const details = currentTrack.details;\n    const age = details == null ? void 0 : details.age;\n    this.log(`Loading subtitle ${id} \"${currentTrack.name}\" lang:${currentTrack.lang} group:${groupId}${(hlsUrlParameters == null ? void 0 : hlsUrlParameters.msn) !== undefined ? ' at sn ' + hlsUrlParameters.msn + ' part ' + hlsUrlParameters.part : ''}${age && details.live ? ' age ' + age.toFixed(1) + (details.type ? ' ' + details.type || 0 : '') : ''} ${url}`);\n    this.hls.trigger(Events.SUBTITLE_TRACK_LOADING, {\n      url,\n      id,\n      groupId,\n      deliveryDirectives: hlsUrlParameters || null,\n      track: currentTrack\n    });\n  }\n\n  /**\n   * Disables the old subtitleTrack and sets current mode on the next subtitleTrack.\n   * This operates on the DOM textTracks.\n   * A value of -1 will disable all subtitle tracks.\n   */\n  toggleTrackModes() {\n    const {\n      media\n    } = this;\n    if (!media) {\n      return;\n    }\n    const textTracks = filterSubtitleTracks(media.textTracks);\n    const currentTrack = this.currentTrack;\n    let nextTrack;\n    if (currentTrack) {\n      nextTrack = textTracks.filter(textTrack => subtitleTrackMatchesTextTrack(currentTrack, textTrack))[0];\n      if (!nextTrack) {\n        this.warn(`Unable to find subtitle TextTrack with name \"${currentTrack.name}\" and language \"${currentTrack.lang}\"`);\n      }\n    }\n    [].slice.call(textTracks).forEach(track => {\n      if (track.mode !== 'disabled' && track !== nextTrack) {\n        track.mode = 'disabled';\n      }\n    });\n    if (nextTrack) {\n      const mode = this.subtitleDisplay ? 'showing' : 'hidden';\n      if (nextTrack.mode !== mode) {\n        nextTrack.mode = mode;\n      }\n    }\n  }\n\n  /**\n   * This method is responsible for validating the subtitle index and periodically reloading if live.\n   * Dispatches the SUBTITLE_TRACK_SWITCH event, which instructs the subtitle-stream-controller to load the selected track.\n   */\n  setSubtitleTrack(newId) {\n    const tracks = this.tracksInGroup;\n\n    // setting this.subtitleTrack will trigger internal logic\n    // if media has not been attached yet, it will fail\n    // we keep a reference to the default track id\n    // and we'll set subtitleTrack when onMediaAttached is triggered\n    if (!this.media) {\n      this.queuedDefaultTrack = newId;\n      return;\n    }\n\n    // exit if track id as already set or invalid\n    if (newId < -1 || newId >= tracks.length || !isFiniteNumber(newId)) {\n      this.warn(`Invalid subtitle track id: ${newId}`);\n      return;\n    }\n    this.selectDefaultTrack = false;\n    const lastTrack = this.currentTrack;\n    const track = tracks[newId] || null;\n    this.trackId = newId;\n    this.currentTrack = track;\n    this.toggleTrackModes();\n    if (!track) {\n      // switch to -1\n      this.hls.trigger(Events.SUBTITLE_TRACK_SWITCH, {\n        id: newId\n      });\n      return;\n    }\n    const trackLoaded = !!track.details && !track.details.live;\n    if (newId === this.trackId && track === lastTrack && trackLoaded) {\n      return;\n    }\n    this.log(`Switching to subtitle-track ${newId}` + (track ? ` \"${track.name}\" lang:${track.lang} group:${track.groupId}` : ''));\n    const {\n      id,\n      groupId = '',\n      name,\n      type,\n      url\n    } = track;\n    this.hls.trigger(Events.SUBTITLE_TRACK_SWITCH, {\n      id,\n      groupId,\n      name,\n      type,\n      url\n    });\n    const hlsUrlParameters = this.switchParams(track.url, lastTrack == null ? void 0 : lastTrack.details, track.details);\n    this.loadPlaylist(hlsUrlParameters);\n  }\n}\n\n/**\n * Generate a random v4 UUID\n *\n * @returns A random v4 UUID\n *\n * @group Utils\n *\n * @beta\n */\nfunction uuid() {\n  try {\n    return crypto.randomUUID();\n  } catch (error) {\n    try {\n      const url = URL.createObjectURL(new Blob());\n      const uuid = url.toString();\n      URL.revokeObjectURL(url);\n      return uuid.slice(uuid.lastIndexOf('/') + 1);\n    } catch (error) {\n      let dt = new Date().getTime();\n      const uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n        const r = (dt + Math.random() * 16) % 16 | 0;\n        dt = Math.floor(dt / 16);\n        return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n      });\n      return uuid;\n    }\n  }\n}\n\n// From https://github.com/darkskyapp/string-hash\nfunction hash(text) {\n  let hash = 5381;\n  let i = text.length;\n  while (i) {\n    hash = hash * 33 ^ text.charCodeAt(--i);\n  }\n  return (hash >>> 0).toString();\n}\n\nconst ALIGNED_END_THRESHOLD_SECONDS = 0.025;\nlet TimelineOccupancy = /*#__PURE__*/function (TimelineOccupancy) {\n  TimelineOccupancy[TimelineOccupancy[\"Point\"] = 0] = \"Point\";\n  TimelineOccupancy[TimelineOccupancy[\"Range\"] = 1] = \"Range\";\n  return TimelineOccupancy;\n}({});\nfunction generateAssetIdentifier(interstitial, uri, assetListIndex) {\n  return `${interstitial.identifier}-${assetListIndex + 1}-${hash(uri)}`;\n}\nclass InterstitialEvent {\n  constructor(dateRange, base) {\n    this.base = void 0;\n    this._duration = null;\n    this._timelineStart = null;\n    this.appendInPlaceDisabled = void 0;\n    this.appendInPlaceStarted = void 0;\n    this.dateRange = void 0;\n    this.hasPlayed = false;\n    this.cumulativeDuration = 0;\n    this.resumeOffset = NaN;\n    this.playoutLimit = NaN;\n    this.restrictions = {\n      skip: false,\n      jump: false\n    };\n    this.snapOptions = {\n      out: false,\n      in: false\n    };\n    this.assetList = [];\n    this.assetListLoader = void 0;\n    this.assetListResponse = null;\n    this.resumeAnchor = void 0;\n    this.error = void 0;\n    this.resetOnResume = void 0;\n    this.base = base;\n    this.dateRange = dateRange;\n    this.setDateRange(dateRange);\n  }\n  setDateRange(dateRange) {\n    this.dateRange = dateRange;\n    this.resumeOffset = dateRange.attr.optionalFloat('X-RESUME-OFFSET', this.resumeOffset);\n    this.playoutLimit = dateRange.attr.optionalFloat('X-PLAYOUT-LIMIT', this.playoutLimit);\n    this.restrictions = dateRange.attr.enumeratedStringList('X-RESTRICT', this.restrictions);\n    this.snapOptions = dateRange.attr.enumeratedStringList('X-SNAP', this.snapOptions);\n  }\n  reset() {\n    var _this$assetListLoader;\n    this.appendInPlaceStarted = false;\n    (_this$assetListLoader = this.assetListLoader) == null ? void 0 : _this$assetListLoader.destroy();\n    this.assetListLoader = undefined;\n    if (!this.supplementsPrimary) {\n      this.assetListResponse = null;\n      this.assetList = [];\n      this._duration = null;\n    }\n    // `error?` is reset when seeking back over interstitial `startOffset`\n    //  using `schedule.resetErrorsInRange(start, end)`.\n  }\n  isAssetPastPlayoutLimit(assetIndex) {\n    var _this$assetList$asset;\n    if (assetIndex > 0 && assetIndex >= this.assetList.length) {\n      return true;\n    }\n    const playoutLimit = this.playoutLimit;\n    if (assetIndex <= 0 || isNaN(playoutLimit)) {\n      return false;\n    }\n    if (playoutLimit === 0) {\n      return true;\n    }\n    const assetOffset = ((_this$assetList$asset = this.assetList[assetIndex]) == null ? void 0 : _this$assetList$asset.startOffset) || 0;\n    return assetOffset > playoutLimit;\n  }\n  findAssetIndex(asset) {\n    const index = this.assetList.indexOf(asset);\n    return index;\n  }\n  get identifier() {\n    return this.dateRange.id;\n  }\n  get startDate() {\n    return this.dateRange.startDate;\n  }\n  get startTime() {\n    // Primary media timeline start time\n    const startTime = this.dateRange.startTime;\n    if (this.snapOptions.out) {\n      const frag = this.dateRange.tagAnchor;\n      if (frag) {\n        return getSnapToFragmentTime(startTime, frag);\n      }\n    }\n    return startTime;\n  }\n  get startOffset() {\n    return this.cue.pre ? 0 : this.startTime;\n  }\n  get startIsAligned() {\n    if (this.startTime === 0 || this.snapOptions.out) {\n      return true;\n    }\n    const frag = this.dateRange.tagAnchor;\n    if (frag) {\n      const startTime = this.dateRange.startTime;\n      const snappedStart = getSnapToFragmentTime(startTime, frag);\n      return startTime - snappedStart < 0.1;\n    }\n    return false;\n  }\n  get resumptionOffset() {\n    const resumeOffset = this.resumeOffset;\n    const offset = isFiniteNumber(resumeOffset) ? resumeOffset : this.duration;\n    return this.cumulativeDuration + offset;\n  }\n  get resumeTime() {\n    // Primary media timeline resumption time\n    const resumeTime = this.startOffset + this.resumptionOffset;\n    if (this.snapOptions.in) {\n      const frag = this.resumeAnchor;\n      if (frag) {\n        return getSnapToFragmentTime(resumeTime, frag);\n      }\n    }\n    return resumeTime;\n  }\n  get appendInPlace() {\n    if (this.appendInPlaceStarted) {\n      return true;\n    }\n    if (this.appendInPlaceDisabled) {\n      return false;\n    }\n    if (!this.cue.once && !this.cue.pre &&\n    // preroll starts at startPosition before startPosition is known (live)\n    this.startIsAligned && (isNaN(this.playoutLimit) && isNaN(this.resumeOffset) || this.resumeOffset && this.duration && Math.abs(this.resumeOffset - this.duration) < ALIGNED_END_THRESHOLD_SECONDS)) {\n      return true;\n    }\n    return false;\n  }\n  set appendInPlace(value) {\n    if (this.appendInPlaceStarted) {\n      this.resetOnResume = !value;\n      return;\n    }\n    this.appendInPlaceDisabled = !value;\n  }\n\n  // Extended timeline start time\n  get timelineStart() {\n    if (this._timelineStart !== null) {\n      return this._timelineStart;\n    }\n    return this.startTime;\n  }\n  set timelineStart(value) {\n    this._timelineStart = value;\n  }\n  get duration() {\n    const playoutLimit = this.playoutLimit;\n    let duration;\n    if (this._duration !== null) {\n      duration = this._duration;\n    } else if (this.dateRange.duration) {\n      duration = this.dateRange.duration;\n    } else {\n      duration = this.dateRange.plannedDuration || 0;\n    }\n    if (!isNaN(playoutLimit) && playoutLimit < duration) {\n      duration = playoutLimit;\n    }\n    return duration;\n  }\n  set duration(value) {\n    this._duration = value;\n  }\n  get cue() {\n    return this.dateRange.cue;\n  }\n  get timelineOccupancy() {\n    if (this.dateRange.attr['X-TIMELINE-OCCUPIES'] === 'RANGE') {\n      return TimelineOccupancy.Range;\n    }\n    return TimelineOccupancy.Point;\n  }\n  get supplementsPrimary() {\n    return this.dateRange.attr['X-TIMELINE-STYLE'] === 'PRIMARY';\n  }\n  get contentMayVary() {\n    return this.dateRange.attr['X-CONTENT-MAY-VARY'] !== 'NO';\n  }\n  get assetUrl() {\n    return this.dateRange.attr['X-ASSET-URI'];\n  }\n  get assetListUrl() {\n    return this.dateRange.attr['X-ASSET-LIST'];\n  }\n  get baseUrl() {\n    return this.base.url;\n  }\n  get assetListLoaded() {\n    return this.assetList.length > 0 || this.assetListResponse !== null;\n  }\n  toString() {\n    return eventToString(this);\n  }\n}\nfunction getSnapToFragmentTime(time, frag) {\n  return time - frag.start < frag.duration / 2 && !(Math.abs(time - (frag.start + frag.duration)) < ALIGNED_END_THRESHOLD_SECONDS) ? frag.start : frag.start + frag.duration;\n}\nfunction getInterstitialUrl(uri, sessionId, baseUrl) {\n  const url = new self.URL(uri, baseUrl);\n  if (url.protocol !== 'data:') {\n    url.searchParams.set('_HLS_primary_id', sessionId);\n  }\n  return url;\n}\nfunction getNextAssetIndex(interstitial, assetListIndex) {\n  while ((_interstitial$assetLi = interstitial.assetList[++assetListIndex]) != null && _interstitial$assetLi.error) {\n    var _interstitial$assetLi;\n  } /* no-op */\n  return assetListIndex;\n}\nfunction eventToString(interstitial) {\n  return `[\"${interstitial.identifier}\" ${interstitial.cue.pre ? '<pre>' : interstitial.cue.post ? '<post>' : ''}${interstitial.timelineStart.toFixed(2)}-${interstitial.resumeTime.toFixed(2)}]`;\n}\nfunction eventAssetToString(asset) {\n  const start = asset.timelineStart;\n  const duration = asset.duration || 0;\n  return `[\"${asset.identifier}\" ${start.toFixed(2)}-${(start + duration).toFixed(2)}]`;\n}\n\nclass HlsAssetPlayer {\n  constructor(HlsPlayerClass, userConfig, interstitial, assetItem) {\n    this.hls = void 0;\n    this.interstitial = void 0;\n    this.assetItem = void 0;\n    this.tracks = null;\n    this.hasDetails = false;\n    this.mediaAttached = null;\n    this._currentTime = void 0;\n    this._bufferedEosTime = void 0;\n    this.checkPlayout = () => {\n      if (this.reachedPlayout(this.currentTime)) {\n        this.hls.trigger(Events.PLAYOUT_LIMIT_REACHED, {});\n      }\n    };\n    const hls = this.hls = new HlsPlayerClass(userConfig);\n    this.interstitial = interstitial;\n    this.assetItem = assetItem;\n    let uri = assetItem.uri;\n    try {\n      uri = getInterstitialUrl(uri, userConfig.primarySessionId).href;\n    } catch (error) {\n      // Ignore error parsing ASSET_URI or adding _HLS_primary_id to it. The\n      // issue should surface as an INTERSTITIAL_ASSET_ERROR loading the asset.\n    }\n    hls.loadSource(uri);\n    const detailsLoaded = () => {\n      this.hasDetails = true;\n    };\n    hls.once(Events.LEVEL_LOADED, detailsLoaded);\n    hls.once(Events.AUDIO_TRACK_LOADED, detailsLoaded);\n    hls.once(Events.SUBTITLE_TRACK_LOADED, detailsLoaded);\n    hls.on(Events.MEDIA_ATTACHING, (name, {\n      media\n    }) => {\n      this.removeMediaListeners();\n      this.mediaAttached = media;\n      const event = this.interstitial;\n      if (event.playoutLimit) {\n        media.addEventListener('timeupdate', this.checkPlayout);\n        if (this.appendInPlace) {\n          hls.on(Events.BUFFER_APPENDED, () => {\n            const bufferedEnd = this.bufferedEnd;\n            if (this.reachedPlayout(bufferedEnd)) {\n              this._bufferedEosTime = bufferedEnd;\n              hls.trigger(Events.BUFFERED_TO_END, undefined);\n            }\n          });\n        }\n      }\n    });\n  }\n  get appendInPlace() {\n    var _this$interstitial;\n    return ((_this$interstitial = this.interstitial) == null ? void 0 : _this$interstitial.appendInPlace) || false;\n  }\n  bufferedInPlaceToEnd(media) {\n    var _this$hls;\n    if (!this.appendInPlace) {\n      return false;\n    }\n    if ((_this$hls = this.hls) != null && _this$hls.bufferedToEnd) {\n      return true;\n    }\n    if (!media || !this._bufferedEosTime) {\n      return false;\n    }\n    const start = this.timelineOffset;\n    const bufferInfo = BufferHelper.bufferInfo(media, start, 0);\n    const bufferedEnd = this.getAssetTime(bufferInfo.end);\n    return bufferedEnd >= this._bufferedEosTime - 0.02;\n  }\n  reachedPlayout(time) {\n    const interstitial = this.interstitial;\n    const playoutLimit = interstitial.playoutLimit;\n    return this.startOffset + time >= playoutLimit;\n  }\n  get destroyed() {\n    var _this$hls2;\n    return !((_this$hls2 = this.hls) != null && _this$hls2.userConfig);\n  }\n  get assetId() {\n    return this.assetItem.identifier;\n  }\n  get interstitialId() {\n    return this.assetItem.parentIdentifier;\n  }\n  get media() {\n    var _this$hls3;\n    return ((_this$hls3 = this.hls) == null ? void 0 : _this$hls3.media) || null;\n  }\n  get bufferedEnd() {\n    const media = this.media || this.mediaAttached;\n    if (!media) {\n      if (this._bufferedEosTime) {\n        return this._bufferedEosTime;\n      }\n      return this.currentTime;\n    }\n    const bufferInfo = BufferHelper.bufferInfo(media, media.currentTime, 0.001);\n    return this.getAssetTime(bufferInfo.end);\n  }\n  get currentTime() {\n    const media = this.media || this.mediaAttached;\n    if (!media) {\n      return this._currentTime || 0;\n    }\n    return this.getAssetTime(media.currentTime);\n  }\n  get duration() {\n    const duration = this.assetItem.duration;\n    if (!duration) {\n      return 0;\n    }\n    return duration;\n  }\n  get remaining() {\n    const duration = this.duration;\n    if (!duration) {\n      return 0;\n    }\n    return Math.max(0, duration - this.currentTime);\n  }\n  get startOffset() {\n    return this.assetItem.startOffset;\n  }\n  get timelineOffset() {\n    var _this$hls4;\n    return ((_this$hls4 = this.hls) == null ? void 0 : _this$hls4.config.timelineOffset) || 0;\n  }\n  set timelineOffset(value) {\n    const timelineOffset = this.timelineOffset;\n    if (value !== timelineOffset) {\n      const diff = value - timelineOffset;\n      if (Math.abs(diff) > 1 / 90000) {\n        if (this.hasDetails) {\n          throw new Error(`Cannot set timelineOffset after playlists are loaded`);\n        }\n        this.hls.config.timelineOffset = value;\n      }\n    }\n  }\n  getAssetTime(time) {\n    const timelineOffset = this.timelineOffset;\n    const duration = this.duration;\n    return Math.min(Math.max(0, time - timelineOffset), duration);\n  }\n  removeMediaListeners() {\n    const media = this.mediaAttached;\n    if (media) {\n      this._currentTime = media.currentTime;\n      this.bufferSnapShot();\n      media.removeEventListener('timeupdate', this.checkPlayout);\n    }\n  }\n  bufferSnapShot() {\n    if (this.mediaAttached) {\n      var _this$hls5;\n      if ((_this$hls5 = this.hls) != null && _this$hls5.bufferedToEnd) {\n        this._bufferedEosTime = this.bufferedEnd;\n      }\n    }\n  }\n  destroy() {\n    this.removeMediaListeners();\n    this.hls.destroy();\n    // @ts-ignore\n    this.hls = this.interstitial = null;\n    // @ts-ignore\n    this.tracks = this.mediaAttached = this.checkPlayout = null;\n  }\n  attachMedia(data) {\n    this.hls.attachMedia(data);\n  }\n  detachMedia() {\n    this.removeMediaListeners();\n    this.mediaAttached = null;\n    this.hls.detachMedia();\n  }\n  resumeBuffering() {\n    this.hls.resumeBuffering();\n  }\n  pauseBuffering() {\n    this.hls.pauseBuffering();\n  }\n  transferMedia() {\n    this.bufferSnapShot();\n    return this.hls.transferMedia();\n  }\n  resetDetails() {\n    const hls = this.hls;\n    if (this.hasDetails) {\n      hls.stopLoad();\n      const deleteDetails = obj => delete obj.details;\n      hls.levels.forEach(deleteDetails);\n      hls.allAudioTracks.forEach(deleteDetails);\n      hls.allSubtitleTracks.forEach(deleteDetails);\n      this.hasDetails = false;\n    }\n  }\n  on(event, listener, context) {\n    this.hls.on(event, listener);\n  }\n  once(event, listener, context) {\n    this.hls.once(event, listener);\n  }\n  off(event, listener, context) {\n    this.hls.off(event, listener);\n  }\n  toString() {\n    var _this$hls6;\n    return `HlsAssetPlayer: ${eventAssetToString(this.assetItem)} ${(_this$hls6 = this.hls) == null ? void 0 : _this$hls6.sessionId} ${this.appendInPlace ? 'append-in-place' : ''}`;\n  }\n}\n\nconst ABUTTING_THRESHOLD_SECONDS = 0.033;\nclass InterstitialsSchedule extends Logger {\n  constructor(onScheduleUpdate, logger) {\n    super('interstitials-sched', logger);\n    this.onScheduleUpdate = void 0;\n    this.eventMap = {};\n    this.events = null;\n    this.items = null;\n    this.durations = {\n      primary: 0,\n      playout: 0,\n      integrated: 0\n    };\n    this.onScheduleUpdate = onScheduleUpdate;\n  }\n  destroy() {\n    this.reset();\n    // @ts-ignore\n    this.onScheduleUpdate = null;\n  }\n  reset() {\n    this.eventMap = {};\n    this.setDurations(0, 0, 0);\n    if (this.events) {\n      this.events.forEach(interstitial => interstitial.reset());\n    }\n    this.events = this.items = null;\n  }\n  resetErrorsInRange(start, end) {\n    if (this.events) {\n      return this.events.reduce((count, interstitial) => {\n        if (start <= interstitial.startOffset && end > interstitial.startOffset) {\n          delete interstitial.error;\n          return count + 1;\n        }\n        return count;\n      }, 0);\n    }\n    return 0;\n  }\n  get duration() {\n    const items = this.items;\n    return items ? items[items.length - 1].end : 0;\n  }\n  get length() {\n    return this.items ? this.items.length : 0;\n  }\n  getEvent(identifier) {\n    return identifier ? this.eventMap[identifier] || null : null;\n  }\n  hasEvent(identifier) {\n    return identifier in this.eventMap;\n  }\n  findItemIndex(item, time) {\n    if (item.event) {\n      // Find Event Item\n      return this.findEventIndex(item.event.identifier);\n    }\n    // Find Primary Item\n    let index = -1;\n    if (item.nextEvent) {\n      index = this.findEventIndex(item.nextEvent.identifier) - 1;\n    } else if (item.previousEvent) {\n      index = this.findEventIndex(item.previousEvent.identifier) + 1;\n    }\n    const items = this.items;\n    if (items) {\n      if (!items[index]) {\n        if (time === undefined) {\n          time = item.start;\n        }\n        index = this.findItemIndexAtTime(time);\n      }\n      // Only return index of a Primary Item\n      while (index >= 0 && (_items$index = items[index]) != null && _items$index.event) {\n        var _items$index;\n        // If index found is an interstitial it is not a valid result as it should have been matched up top\n        // decrement until result is negative (not found) or a primary segment\n        index--;\n      }\n    }\n    return index;\n  }\n  findItemIndexAtTime(timelinePos, timelineType) {\n    const items = this.items;\n    if (items) {\n      for (let i = 0; i < items.length; i++) {\n        let timeRange = items[i];\n        if (timelineType && timelineType !== 'primary') {\n          timeRange = timeRange[timelineType];\n        }\n        if (timelinePos === timeRange.start || timelinePos > timeRange.start && timelinePos < timeRange.end) {\n          return i;\n        }\n      }\n    }\n    return -1;\n  }\n  findJumpRestrictedIndex(startIndex, endIndex) {\n    const items = this.items;\n    if (items) {\n      for (let i = startIndex; i <= endIndex; i++) {\n        if (!items[i]) {\n          break;\n        }\n        const event = items[i].event;\n        if (event != null && event.restrictions.jump && !event.appendInPlace) {\n          return i;\n        }\n      }\n    }\n    return -1;\n  }\n  findEventIndex(identifier) {\n    const items = this.items;\n    if (items) {\n      for (let i = items.length; i--;) {\n        var _items$i$event;\n        if (((_items$i$event = items[i].event) == null ? void 0 : _items$i$event.identifier) === identifier) {\n          return i;\n        }\n      }\n    }\n    return -1;\n  }\n  findAssetIndex(event, timelinePos) {\n    const assetList = event.assetList;\n    const length = assetList.length;\n    if (length > 1) {\n      for (let i = 0; i < length; i++) {\n        const asset = assetList[i];\n        if (!asset.error) {\n          const timelineStart = asset.timelineStart;\n          if (timelinePos === timelineStart || timelinePos > timelineStart && timelinePos < timelineStart + (asset.duration || 0)) {\n            return i;\n          }\n        }\n      }\n    }\n    return 0;\n  }\n  get assetIdAtEnd() {\n    var _this$items, _this$items2;\n    const interstitialAtEnd = (_this$items = this.items) == null ? void 0 : (_this$items2 = _this$items[this.length - 1]) == null ? void 0 : _this$items2.event;\n    if (interstitialAtEnd) {\n      const assetList = interstitialAtEnd.assetList;\n      const assetAtEnd = assetList[assetList.length - 1];\n      if (assetAtEnd) {\n        return assetAtEnd.identifier;\n      }\n    }\n    return null;\n  }\n  parseInterstitialDateRanges(mediaSelection, enableAppendInPlace) {\n    const details = mediaSelection.main.details;\n    const {\n      dateRanges\n    } = details;\n    const previousInterstitialEvents = this.events;\n    const interstitialEvents = this.parseDateRanges(dateRanges, {\n      url: details.url\n    }, enableAppendInPlace);\n    const ids = Object.keys(dateRanges);\n    const removedInterstitials = previousInterstitialEvents ? previousInterstitialEvents.filter(event => !ids.includes(event.identifier)) : [];\n    if (interstitialEvents.length) {\n      // pre-rolls, post-rolls, and events with the same start time are played in playlist tag order\n      // all other events are ordered by start time\n      interstitialEvents.sort((a, b) => {\n        const aPre = a.cue.pre;\n        const aPost = a.cue.post;\n        const bPre = b.cue.pre;\n        const bPost = b.cue.post;\n        if (aPre && !bPre) {\n          return -1;\n        }\n        if (bPre && !aPre) {\n          return 1;\n        }\n        if (aPost && !bPost) {\n          return 1;\n        }\n        if (bPost && !aPost) {\n          return -1;\n        }\n        if (!aPre && !bPre && !aPost && !bPost) {\n          const startA = a.startTime;\n          const startB = b.startTime;\n          if (startA !== startB) {\n            return startA - startB;\n          }\n        }\n        return a.dateRange.tagOrder - b.dateRange.tagOrder;\n      });\n    }\n    this.events = interstitialEvents;\n\n    // Clear removed DateRanges from buffered list (kills playback of active Interstitials)\n    removedInterstitials.forEach(interstitial => {\n      this.removeEvent(interstitial);\n    });\n    this.updateSchedule(mediaSelection, removedInterstitials);\n  }\n  updateSchedule(mediaSelection, removedInterstitials = []) {\n    const events = this.events || [];\n    if (events.length || removedInterstitials.length || this.length < 2) {\n      const currentItems = this.items;\n      const updatedItems = this.parseSchedule(events, mediaSelection);\n      const updated = removedInterstitials.length || (currentItems == null ? void 0 : currentItems.length) !== updatedItems.length || updatedItems.some((item, i) => {\n        return Math.abs(item.playout.start - currentItems[i].playout.start) > 0.005 || Math.abs(item.playout.end - currentItems[i].playout.end) > 0.005;\n      });\n      if (updated) {\n        this.items = updatedItems;\n        // call interstitials-controller onScheduleUpdated()\n        this.onScheduleUpdate(removedInterstitials, currentItems);\n      }\n    }\n  }\n  parseDateRanges(dateRanges, baseData, enableAppendInPlace) {\n    const interstitialEvents = [];\n    const ids = Object.keys(dateRanges);\n    for (let i = 0; i < ids.length; i++) {\n      const id = ids[i];\n      const dateRange = dateRanges[id];\n      if (dateRange.isInterstitial) {\n        let interstitial = this.eventMap[id];\n        if (interstitial) {\n          // Update InterstitialEvent already parsed and mapped\n          // This retains already loaded duration and loaded asset list info\n          interstitial.setDateRange(dateRange);\n        } else {\n          interstitial = new InterstitialEvent(dateRange, baseData);\n          this.eventMap[id] = interstitial;\n          if (enableAppendInPlace === false) {\n            interstitial.appendInPlace = enableAppendInPlace;\n          }\n        }\n        interstitialEvents.push(interstitial);\n      }\n    }\n    return interstitialEvents;\n  }\n  parseSchedule(interstitialEvents, mediaSelection) {\n    const schedule = [];\n    const details = mediaSelection.main.details;\n    const primaryDuration = details.live ? Infinity : details.edge;\n    let playoutDuration = 0;\n\n    // Filter events that have errored from the schedule (Primary fallback)\n    interstitialEvents = interstitialEvents.filter(event => !event.error && !(event.cue.once && event.hasPlayed));\n    if (interstitialEvents.length) {\n      // Update Schedule\n      this.resolveOffsets(interstitialEvents, mediaSelection);\n\n      // Populate Schedule with Interstitial Event and Primary Segment Items\n      let primaryPosition = 0;\n      let integratedTime = 0;\n      interstitialEvents.forEach((interstitial, i) => {\n        const preroll = interstitial.cue.pre;\n        const postroll = interstitial.cue.post;\n        const previousEvent = interstitialEvents[i - 1] || null;\n        const appendInPlace = interstitial.appendInPlace;\n        const eventStart = postroll ? primaryDuration : interstitial.startOffset;\n        const interstitialDuration = interstitial.duration;\n        const timelineDuration = interstitial.timelineOccupancy === TimelineOccupancy.Range ? interstitialDuration : 0;\n        const resumptionOffset = interstitial.resumptionOffset;\n        const inSameStartTimeSequence = (previousEvent == null ? void 0 : previousEvent.startTime) === eventStart;\n        const start = eventStart + interstitial.cumulativeDuration;\n        let end = appendInPlace ? start + interstitialDuration : eventStart + resumptionOffset;\n        if (preroll || !postroll && eventStart <= 0) {\n          // preroll or in-progress midroll\n          const integratedStart = integratedTime;\n          integratedTime += timelineDuration;\n          interstitial.timelineStart = start;\n          const playoutStart = playoutDuration;\n          playoutDuration += interstitialDuration;\n          schedule.push({\n            event: interstitial,\n            start,\n            end,\n            playout: {\n              start: playoutStart,\n              end: playoutDuration\n            },\n            integrated: {\n              start: integratedStart,\n              end: integratedTime\n            }\n          });\n        } else if (eventStart <= primaryDuration) {\n          if (!inSameStartTimeSequence) {\n            const segmentDuration = eventStart - primaryPosition;\n            // Do not schedule a primary segment if interstitials are abutting by less than ABUTTING_THRESHOLD_SECONDS\n            if (segmentDuration > ABUTTING_THRESHOLD_SECONDS) {\n              // primary segment\n              const timelineStart = primaryPosition;\n              const _integratedStart = integratedTime;\n              integratedTime += segmentDuration;\n              const _playoutStart = playoutDuration;\n              playoutDuration += segmentDuration;\n              const primarySegment = {\n                previousEvent: interstitialEvents[i - 1] || null,\n                nextEvent: interstitial,\n                start: timelineStart,\n                end: timelineStart + segmentDuration,\n                playout: {\n                  start: _playoutStart,\n                  end: playoutDuration\n                },\n                integrated: {\n                  start: _integratedStart,\n                  end: integratedTime\n                }\n              };\n              schedule.push(primarySegment);\n            } else if (segmentDuration > 0 && previousEvent) {\n              // Add previous event `resumeTime` (based on duration or resumeOffset) so that it ends aligned with this one\n              previousEvent.cumulativeDuration += segmentDuration;\n              schedule[schedule.length - 1].end = eventStart;\n            }\n          }\n          // midroll / postroll\n          if (postroll) {\n            end = start;\n          }\n          interstitial.timelineStart = start;\n          const integratedStart = integratedTime;\n          integratedTime += timelineDuration;\n          const playoutStart = playoutDuration;\n          playoutDuration += interstitialDuration;\n          schedule.push({\n            event: interstitial,\n            start,\n            end,\n            playout: {\n              start: playoutStart,\n              end: playoutDuration\n            },\n            integrated: {\n              start: integratedStart,\n              end: integratedTime\n            }\n          });\n        } else {\n          // Interstitial starts after end of primary VOD - not included in schedule\n          return;\n        }\n        const resumeTime = interstitial.resumeTime;\n        if (postroll || resumeTime > primaryDuration) {\n          primaryPosition = primaryDuration;\n        } else {\n          primaryPosition = resumeTime;\n        }\n      });\n      if (primaryPosition < primaryDuration) {\n        var _schedule;\n        // last primary segment\n        const timelineStart = primaryPosition;\n        const integratedStart = integratedTime;\n        const segmentDuration = primaryDuration - primaryPosition;\n        integratedTime += segmentDuration;\n        const playoutStart = playoutDuration;\n        playoutDuration += segmentDuration;\n        schedule.push({\n          previousEvent: ((_schedule = schedule[schedule.length - 1]) == null ? void 0 : _schedule.event) || null,\n          nextEvent: null,\n          start: primaryPosition,\n          end: timelineStart + segmentDuration,\n          playout: {\n            start: playoutStart,\n            end: playoutDuration\n          },\n          integrated: {\n            start: integratedStart,\n            end: integratedTime\n          }\n        });\n      }\n      this.setDurations(primaryDuration, playoutDuration, integratedTime);\n    } else {\n      // no interstials - schedule is one primary segment\n      const start = 0;\n      schedule.push({\n        previousEvent: null,\n        nextEvent: null,\n        start,\n        end: primaryDuration,\n        playout: {\n          start,\n          end: primaryDuration\n        },\n        integrated: {\n          start,\n          end: primaryDuration\n        }\n      });\n      this.setDurations(primaryDuration, primaryDuration, primaryDuration);\n    }\n    return schedule;\n  }\n  setDurations(primary, playout, integrated) {\n    this.durations = {\n      primary,\n      playout,\n      integrated\n    };\n  }\n  resolveOffsets(interstitialEvents, mediaSelection) {\n    const details = mediaSelection.main.details;\n    const primaryDuration = details.live ? Infinity : details.edge;\n\n    // First resolve cumulative resumption offsets for Interstitials that start at the same DateTime\n    let cumulativeDuration = 0;\n    let lastScheduledStart = -1;\n    interstitialEvents.forEach((interstitial, i) => {\n      const preroll = interstitial.cue.pre;\n      const postroll = interstitial.cue.post;\n      const eventStart = preroll ? 0 : postroll ? primaryDuration : interstitial.startTime;\n      this.updateAssetDurations(interstitial);\n\n      // X-RESUME-OFFSET values of interstitials scheduled at the same time are cumulative\n      const inSameStartTimeSequence = lastScheduledStart === eventStart;\n      if (inSameStartTimeSequence) {\n        interstitial.cumulativeDuration = cumulativeDuration;\n      } else {\n        cumulativeDuration = 0;\n        lastScheduledStart = eventStart;\n      }\n      if (!postroll && interstitial.snapOptions.in) {\n        // FIXME: Include audio playlist in snapping\n        interstitial.resumeAnchor = findFragmentByPTS(null, details.fragments, interstitial.startOffset + interstitial.resumptionOffset, 0, 0) || undefined;\n      }\n      // Check if primary fragments align with resumption offset and disable appendInPlace if they do not\n      if (interstitial.appendInPlace && !interstitial.appendInPlaceStarted) {\n        const alignedSegmentStart = this.primaryCanResumeInPlaceAt(interstitial, mediaSelection);\n        if (!alignedSegmentStart) {\n          interstitial.appendInPlace = false;\n        }\n      }\n      if (!interstitial.appendInPlace && i + 1 < interstitialEvents.length) {\n        // abutting Interstitials must use the same MediaSource strategy, this applies to all whether or not they are back to back:\n        const timeBetween = interstitialEvents[i + 1].startTime - interstitialEvents[i].resumeTime;\n        if (timeBetween < ABUTTING_THRESHOLD_SECONDS) {\n          interstitialEvents[i + 1].appendInPlace = false;\n          if (interstitialEvents[i + 1].appendInPlace) {\n            this.warn(`Could not change append strategy for abutting event ${interstitial}`);\n          }\n        }\n      }\n      // Update cumulativeDuration for next abutting interstitial with the same start date\n      const resumeOffset = isFiniteNumber(interstitial.resumeOffset) ? interstitial.resumeOffset : interstitial.duration;\n      cumulativeDuration += resumeOffset;\n    });\n  }\n  primaryCanResumeInPlaceAt(interstitial, mediaSelection) {\n    const resumeTime = interstitial.resumeTime;\n    const resumesInPlaceAt = interstitial.startTime + interstitial.resumptionOffset;\n    if (Math.abs(resumeTime - resumesInPlaceAt) > ALIGNED_END_THRESHOLD_SECONDS) {\n      this.log(`\"${interstitial.identifier}\" resumption ${resumeTime} not aligned with estimated timeline end ${resumesInPlaceAt}`);\n      return false;\n    }\n    if (!mediaSelection) {\n      this.log(`\"${interstitial.identifier}\" resumption ${resumeTime} can not be aligned with media (none selected)`);\n      return false;\n    }\n    const playlists = Object.keys(mediaSelection);\n    return !playlists.some(playlistType => {\n      const details = mediaSelection[playlistType].details;\n      const playlistEnd = details.edge;\n      if (resumeTime >= playlistEnd) {\n        // Live playback - resumption segments are not yet available\n        this.log(`\"${interstitial.identifier}\" resumption ${resumeTime} past ${playlistType} playlist end ${playlistEnd}`);\n        // Assume alignment is possible (or reset can take place)\n        return false;\n      }\n      const startFragment = findFragmentByPTS(null, details.fragments, resumeTime);\n      if (!startFragment) {\n        this.log(`\"${interstitial.identifier}\" resumption ${resumeTime} does not align with any fragments in ${playlistType} playlist (${details.fragStart}-${details.fragmentEnd})`);\n        return true;\n      }\n      const allowance = playlistType === 'audio' ? 0.175 : 0;\n      const alignedWithSegment = Math.abs(startFragment.start - resumeTime) < ALIGNED_END_THRESHOLD_SECONDS + allowance || Math.abs(startFragment.end - resumeTime) < ALIGNED_END_THRESHOLD_SECONDS + allowance;\n      if (!alignedWithSegment) {\n        this.log(`\"${interstitial.identifier}\" resumption ${resumeTime} not aligned with ${playlistType} fragment bounds (${startFragment.start}-${startFragment.end} sn: ${startFragment.sn} cc: ${startFragment.cc})`);\n        return true;\n      }\n      return false;\n    });\n  }\n  updateAssetDurations(interstitial) {\n    if (!interstitial.assetListLoaded) {\n      return;\n    }\n    const eventStart = interstitial.timelineStart;\n    let sumDuration = 0;\n    let hasUnknownDuration = false;\n    let hasErrors = false;\n    interstitial.assetList.forEach((asset, i) => {\n      const timelineStart = eventStart + sumDuration;\n      asset.startOffset = sumDuration;\n      asset.timelineStart = timelineStart;\n      hasUnknownDuration || (hasUnknownDuration = asset.duration === null);\n      hasErrors || (hasErrors = !!asset.error);\n      const duration = asset.error ? 0 : asset.duration || 0;\n      sumDuration += duration;\n    });\n    // Use the sum of known durations when it is greater than the stated duration\n    if (hasUnknownDuration && !hasErrors) {\n      interstitial.duration = Math.max(sumDuration, interstitial.duration);\n    } else {\n      interstitial.duration = sumDuration;\n    }\n  }\n  removeEvent(interstitial) {\n    interstitial.reset();\n    delete this.eventMap[interstitial.identifier];\n  }\n}\nfunction segmentToString(segment) {\n  return `[${segment.event ? '\"' + segment.event.identifier + '\"' : 'primary'}: ${segment.start.toFixed(2)}-${segment.end.toFixed(2)}]`;\n}\n\nclass AssetListLoader {\n  constructor(hls) {\n    this.hls = void 0;\n    this.hls = hls;\n  }\n  destroy() {\n    // @ts-ignore\n    this.hls = null;\n  }\n  loadAssetList(interstitial, hlsStartOffset) {\n    const assetListUrl = interstitial.assetListUrl;\n    let url;\n    try {\n      url = getInterstitialUrl(assetListUrl, this.hls.sessionId, interstitial.baseUrl);\n    } catch (error) {\n      const errorData = this.assignAssetListError(interstitial, ErrorDetails.ASSET_LIST_LOAD_ERROR, error, assetListUrl);\n      this.hls.trigger(Events.ERROR, errorData);\n      return;\n    }\n    if (hlsStartOffset && url.protocol !== 'data:') {\n      url.searchParams.set('_HLS_start_offset', '' + hlsStartOffset);\n    }\n    const config = this.hls.config;\n    const Loader = config.loader;\n    const loader = new Loader(config);\n    const context = {\n      responseType: 'json',\n      url: url.href\n    };\n    const loadPolicy = config.interstitialAssetListLoadPolicy.default;\n    const loaderConfig = {\n      loadPolicy,\n      timeout: loadPolicy.maxLoadTimeMs,\n      maxRetry: 0,\n      retryDelay: 0,\n      maxRetryDelay: 0\n    };\n    const callbacks = {\n      onSuccess: (response, stats, context, networkDetails) => {\n        const assetListResponse = response.data;\n        const assets = assetListResponse == null ? void 0 : assetListResponse.ASSETS;\n        if (!Array.isArray(assets)) {\n          const errorData = this.assignAssetListError(interstitial, ErrorDetails.ASSET_LIST_PARSING_ERROR, new Error(`Invalid interstitial asset list`), context.url, stats, networkDetails);\n          this.hls.trigger(Events.ERROR, errorData);\n          return;\n        }\n        interstitial.assetListResponse = assetListResponse;\n        this.hls.trigger(Events.ASSET_LIST_LOADED, {\n          event: interstitial,\n          assetListResponse,\n          networkDetails\n        });\n      },\n      onError: (error, context, networkDetails, stats) => {\n        const errorData = this.assignAssetListError(interstitial, ErrorDetails.ASSET_LIST_LOAD_ERROR, new Error(`Error loading X-ASSET-LIST: HTTP status ${error.code} ${error.text} (${context.url})`), context.url, stats, networkDetails);\n        this.hls.trigger(Events.ERROR, errorData);\n      },\n      onTimeout: (stats, context, networkDetails) => {\n        const errorData = this.assignAssetListError(interstitial, ErrorDetails.ASSET_LIST_LOAD_TIMEOUT, new Error(`Timeout loading X-ASSET-LIST (${context.url})`), context.url, stats, networkDetails);\n        this.hls.trigger(Events.ERROR, errorData);\n      }\n    };\n    loader.load(context, loaderConfig, callbacks);\n    this.hls.trigger(Events.ASSET_LIST_LOADING, {\n      event: interstitial\n    });\n    return loader;\n  }\n  assignAssetListError(interstitial, details, error, url, stats, networkDetails) {\n    interstitial.error = error;\n    return {\n      type: ErrorTypes.NETWORK_ERROR,\n      details,\n      fatal: false,\n      interstitial,\n      url,\n      error,\n      networkDetails,\n      stats\n    };\n  }\n}\n\nfunction playWithCatch(media) {\n  media == null ? void 0 : media.play().catch(() => {\n    /* no-op */\n  });\n}\nclass InterstitialsController extends Logger {\n  constructor(hls, HlsPlayerClass) {\n    super('interstitials', hls.logger);\n    this.HlsPlayerClass = void 0;\n    this.hls = void 0;\n    this.assetListLoader = void 0;\n    // Last updated LevelDetails\n    this.mediaSelection = null;\n    this.altSelection = null;\n    // Media and MediaSource/SourceBuffers\n    this.media = null;\n    this.detachedData = null;\n    this.requiredTracks = null;\n    // Public Interface for Interstitial playback state and control\n    this.manager = null;\n    // Interstitial Asset Players\n    this.playerQueue = [];\n    // Timeline position tracking\n    this.bufferedPos = -1;\n    this.timelinePos = -1;\n    // Schedule\n    this.schedule = void 0;\n    // Schedule playback and buffering state\n    this.playingItem = null;\n    this.bufferingItem = null;\n    this.waitingItem = null;\n    this.endedItem = null;\n    this.playingAsset = null;\n    this.endedAsset = null;\n    this.bufferingAsset = null;\n    this.shouldPlay = false;\n    this.onPlay = () => {\n      this.shouldPlay = true;\n    };\n    this.onPause = () => {\n      this.shouldPlay = false;\n    };\n    this.onSeeking = () => {\n      const currentTime = this.currentTime;\n      if (currentTime === undefined || this.playbackDisabled) {\n        return;\n      }\n      const diff = currentTime - this.timelinePos;\n      const roundingError = Math.abs(diff) < 1 / 705600000; // one flick\n      if (roundingError) {\n        return;\n      }\n      const backwardSeek = diff <= -0.01;\n      this.timelinePos = currentTime;\n      this.bufferedPos = currentTime;\n\n      // Check if seeking out of an item\n      const playingItem = this.playingItem;\n      if (!playingItem) {\n        this.checkBuffer();\n        return;\n      }\n      if (backwardSeek) {\n        const resetCount = this.schedule.resetErrorsInRange(currentTime, currentTime - diff);\n        if (resetCount) {\n          this.updateSchedule();\n        }\n      }\n      this.checkBuffer();\n      if (backwardSeek && currentTime < playingItem.start || currentTime >= playingItem.end) {\n        var _this$media;\n        const scheduleIndex = this.schedule.findItemIndexAtTime(this.timelinePos);\n        if (!this.isInterstitial(playingItem) && (_this$media = this.media) != null && _this$media.paused) {\n          this.shouldPlay = false;\n        }\n        if (!backwardSeek) {\n          // check if an Interstitial between the current item and target item has an X-RESTRICT JUMP restriction\n          const playingIndex = this.findItemIndex(playingItem);\n          if (scheduleIndex > playingIndex) {\n            const jumpIndex = this.schedule.findJumpRestrictedIndex(playingIndex + 1, scheduleIndex);\n            if (jumpIndex > playingIndex) {\n              this.setSchedulePosition(jumpIndex);\n              return;\n            }\n          }\n        }\n        this.setSchedulePosition(scheduleIndex);\n        return;\n      }\n      // Check if seeking out of an asset (assumes same item following above check)\n      const playingAsset = this.playingAsset;\n      if (!playingAsset) {\n        // restart Interstitial at end\n        if (this.playingLastItem && this.isInterstitial(playingItem)) {\n          const restartAsset = playingItem.event.assetList[0];\n          if (restartAsset) {\n            this.endedItem = this.playingItem;\n            this.playingItem = null;\n            this.setScheduleToAssetAtTime(currentTime, restartAsset);\n          }\n        }\n        return;\n      }\n      const start = playingAsset.timelineStart;\n      const duration = playingAsset.duration || 0;\n      if (backwardSeek && currentTime < start || currentTime >= start + duration) {\n        this.setScheduleToAssetAtTime(currentTime, playingAsset);\n      }\n    };\n    this.onTimeupdate = () => {\n      const currentTime = this.currentTime;\n      if (currentTime === undefined || this.playbackDisabled) {\n        return;\n      }\n\n      // Only allow timeupdate to advance primary position, seeking is used for jumping back\n      // this prevents primaryPos from being reset to 0 after re-attach\n      if (currentTime > this.timelinePos) {\n        this.timelinePos = currentTime;\n        if (currentTime > this.bufferedPos) {\n          this.checkBuffer();\n        }\n      } else {\n        return;\n      }\n\n      // Check if playback has entered the next item\n      const playingItem = this.playingItem;\n      if (!playingItem || this.playingLastItem) {\n        return;\n      }\n      if (currentTime >= playingItem.end) {\n        this.timelinePos = playingItem.end;\n        const playingIndex = this.findItemIndex(playingItem);\n        this.setSchedulePosition(playingIndex + 1);\n      }\n      // Check if playback has entered the next asset\n      const playingAsset = this.playingAsset;\n      if (!playingAsset) {\n        return;\n      }\n      const end = playingAsset.timelineStart + (playingAsset.duration || 0);\n      if (currentTime >= end) {\n        this.setScheduleToAssetAtTime(currentTime, playingAsset);\n      }\n    };\n    // Schedule update callback\n    this.onScheduleUpdate = (removedInterstitials, previousItems) => {\n      const schedule = this.schedule;\n      const playingItem = this.playingItem;\n      const interstitialEvents = schedule.events || [];\n      const scheduleItems = schedule.items || [];\n      const durations = schedule.durations;\n      const removedIds = removedInterstitials.map(interstitial => interstitial.identifier);\n      const interstitialsUpdated = !!(interstitialEvents.length || removedIds.length);\n      if (interstitialsUpdated || previousItems) {\n        this.log(`INTERSTITIALS_UPDATED (${interstitialEvents.length}): ${interstitialEvents}\nSchedule: ${scheduleItems.map(seg => segmentToString(seg))} pos: ${this.timelinePos}`);\n      }\n      if (removedIds.length) {\n        this.log(`Removed events ${removedIds}`);\n      }\n      this.playerQueue.forEach(player => {\n        if (player.interstitial.appendInPlace) {\n          const timelineStart = player.assetItem.timelineStart;\n          const diff = player.timelineOffset - timelineStart;\n          if (diff) {\n            try {\n              player.timelineOffset = timelineStart;\n            } catch (e) {\n              if (Math.abs(diff) > ALIGNED_END_THRESHOLD_SECONDS) {\n                this.warn(`${e} (\"${player.assetId}\" ${player.timelineOffset}->${timelineStart})`);\n              }\n            }\n          }\n        }\n      });\n\n      // Update schedule item references\n      // Do not replace Interstitial playingItem without a match - used for INTERSTITIAL_ASSET_ENDED and INTERSTITIAL_ENDED\n      let trimInPlaceForPlayout = null;\n      if (playingItem) {\n        const updatedPlayingItem = this.updateItem(playingItem, this.timelinePos);\n        if (this.itemsMatch(playingItem, updatedPlayingItem)) {\n          this.playingItem = updatedPlayingItem;\n          this.waitingItem = this.endedItem = null;\n          trimInPlaceForPlayout = () => this.trimInPlace(updatedPlayingItem, playingItem);\n        }\n      } else {\n        // Clear waitingItem if it has been removed from the schedule\n        this.waitingItem = this.updateItem(this.waitingItem);\n        this.endedItem = this.updateItem(this.endedItem);\n      }\n      // Do not replace Interstitial bufferingItem without a match - used for transfering media element or source\n      const bufferingItem = this.bufferingItem;\n      if (bufferingItem) {\n        const updatedBufferingItem = this.updateItem(bufferingItem, this.bufferedPos);\n        if (this.itemsMatch(bufferingItem, updatedBufferingItem)) {\n          this.bufferingItem = updatedBufferingItem;\n          trimInPlaceForPlayout || (trimInPlaceForPlayout = () => this.trimInPlace(updatedBufferingItem, bufferingItem));\n        } else if (bufferingItem.event) {\n          // Interstitial removed from schedule (Live -> VOD or other scenario where Start Date is outside the range of VOD Playlist)\n          this.bufferingItem = this.playingItem;\n          this.clearInterstitial(bufferingItem.event, null);\n        }\n      }\n      removedInterstitials.forEach(interstitial => {\n        interstitial.assetList.forEach(asset => {\n          this.clearAssetPlayer(asset.identifier, null);\n        });\n      });\n      if (interstitialsUpdated || previousItems) {\n        this.hls.trigger(Events.INTERSTITIALS_UPDATED, {\n          events: interstitialEvents.slice(0),\n          schedule: scheduleItems.slice(0),\n          durations,\n          removedIds\n        });\n        if (this.isInterstitial(playingItem) && removedIds.includes(playingItem.event.identifier)) {\n          this.warn(`Interstitial \"${playingItem.event.identifier}\" removed while playing`);\n          this.primaryFallback(playingItem.event);\n          return;\n        }\n        if (trimInPlaceForPlayout) {\n          trimInPlaceForPlayout();\n        }\n\n        // Check is buffered to new Interstitial event boundary\n        // (Live update publishes Interstitial with new segment)\n        this.checkBuffer();\n      }\n    };\n    this.hls = hls;\n    this.HlsPlayerClass = HlsPlayerClass;\n    this.assetListLoader = new AssetListLoader(hls);\n    this.schedule = new InterstitialsSchedule(this.onScheduleUpdate, hls.logger);\n    this.registerListeners();\n  }\n  registerListeners() {\n    const hls = this.hls;\n    hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    hls.on(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n    hls.on(Events.AUDIO_TRACK_UPDATED, this.onAudioTrackUpdated, this);\n    hls.on(Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);\n    hls.on(Events.SUBTITLE_TRACK_UPDATED, this.onSubtitleTrackUpdated, this);\n    hls.on(Events.EVENT_CUE_ENTER, this.onInterstitialCueEnter, this);\n    hls.on(Events.ASSET_LIST_LOADED, this.onAssetListLoaded, this);\n    hls.on(Events.BUFFER_APPENDED, this.onBufferAppended, this);\n    hls.on(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n    hls.on(Events.BUFFERED_TO_END, this.onBufferedToEnd, this);\n    hls.on(Events.MEDIA_ENDED, this.onMediaEnded, this);\n    hls.on(Events.ERROR, this.onError, this);\n    hls.on(Events.DESTROYING, this.onDestroying, this);\n  }\n  unregisterListeners() {\n    const hls = this.hls;\n    if (!hls) {\n      return;\n    }\n    hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    hls.off(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n    hls.off(Events.AUDIO_TRACK_UPDATED, this.onAudioTrackUpdated, this);\n    hls.off(Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);\n    hls.off(Events.SUBTITLE_TRACK_UPDATED, this.onSubtitleTrackUpdated, this);\n    hls.off(Events.EVENT_CUE_ENTER, this.onInterstitialCueEnter, this);\n    hls.off(Events.ASSET_LIST_LOADED, this.onAssetListLoaded, this);\n    hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n    hls.off(Events.BUFFER_APPENDED, this.onBufferAppended, this);\n    hls.off(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n    hls.off(Events.BUFFERED_TO_END, this.onBufferedToEnd, this);\n    hls.off(Events.MEDIA_ENDED, this.onMediaEnded, this);\n    hls.off(Events.ERROR, this.onError, this);\n    hls.off(Events.DESTROYING, this.onDestroying, this);\n  }\n  startLoad() {\n    // TODO: startLoad - check for waitingItem and retry by resetting schedule\n    this.resumeBuffering();\n  }\n  stopLoad() {\n    // TODO: stopLoad - stop all scheule.events[].assetListLoader?.abort() then delete the loaders\n    this.pauseBuffering();\n  }\n  resumeBuffering() {\n    var _this$getBufferingPla;\n    (_this$getBufferingPla = this.getBufferingPlayer()) == null ? void 0 : _this$getBufferingPla.resumeBuffering();\n  }\n  pauseBuffering() {\n    var _this$getBufferingPla2;\n    (_this$getBufferingPla2 = this.getBufferingPlayer()) == null ? void 0 : _this$getBufferingPla2.pauseBuffering();\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.stopLoad();\n    if (this.assetListLoader) {\n      this.assetListLoader.destroy();\n    }\n    this.emptyPlayerQueue();\n    this.clearScheduleState();\n    if (this.schedule) {\n      this.schedule.destroy();\n    }\n    this.media = this.detachedData = this.mediaSelection = this.requiredTracks = this.altSelection = this.manager = null;\n    // @ts-ignore\n    this.hls = this.HlsPlayerClass = this.schedule = this.log = null;\n    // @ts-ignore\n    this.assetListLoader = null;\n    // @ts-ignore\n    this.onPlay = this.onPause = this.onSeeking = this.onTimeupdate = null;\n    // @ts-ignore\n    this.onScheduleUpdate = null;\n  }\n  onDestroying() {\n    const media = this.primaryMedia || this.media;\n    if (media) {\n      this.removeMediaListeners(media);\n    }\n  }\n  removeMediaListeners(media) {\n    removeEventListener(media, 'play', this.onPlay);\n    removeEventListener(media, 'pause', this.onPause);\n    removeEventListener(media, 'seeking', this.onSeeking);\n    removeEventListener(media, 'timeupdate', this.onTimeupdate);\n  }\n  onMediaAttaching(event, data) {\n    const media = this.media = data.media;\n    addEventListener(media, 'seeking', this.onSeeking);\n    addEventListener(media, 'timeupdate', this.onTimeupdate);\n    addEventListener(media, 'play', this.onPlay);\n    addEventListener(media, 'pause', this.onPause);\n  }\n  onMediaAttached(event, data) {\n    const playingItem = this.effectivePlayingItem;\n    const detachedMedia = this.detachedData;\n    this.detachedData = null;\n    if (playingItem === null) {\n      this.checkStart();\n    } else if (!detachedMedia) {\n      // Resume schedule after detached externally\n      this.clearScheduleState();\n      const playingIndex = this.findItemIndex(playingItem);\n      this.setSchedulePosition(playingIndex);\n    }\n  }\n  clearScheduleState() {\n    this.playingItem = this.bufferingItem = this.waitingItem = this.endedItem = this.playingAsset = this.endedAsset = this.bufferingAsset = null;\n  }\n  onMediaDetaching(event, data) {\n    const transferringMedia = !!data.transferMedia;\n    const media = this.media;\n    this.media = null;\n    if (transferringMedia) {\n      return;\n    }\n    if (media) {\n      this.removeMediaListeners(media);\n    }\n    // If detachMedia is called while in an Interstitial, detach the asset player as well and reset the schedule position\n    if (this.detachedData) {\n      const player = this.getBufferingPlayer();\n      if (player) {\n        this.playingAsset = this.endedAsset = this.bufferingAsset = this.bufferingItem = this.waitingItem = this.detachedData = null;\n        player.detachMedia();\n      }\n      this.shouldPlay = false;\n    }\n  }\n  get interstitialsManager() {\n    if (!this.manager) {\n      if (!this.hls) {\n        return null;\n      }\n      const c = this;\n      const effectiveBufferingItem = () => c.bufferingItem || c.waitingItem;\n      const getAssetPlayer = asset => asset ? c.getAssetPlayer(asset.identifier) : asset;\n      const getMappedTime = (item, timelineType, asset, controllerField, assetPlayerField) => {\n        if (item) {\n          let time = item[timelineType].start;\n          const interstitial = item.event;\n          if (interstitial) {\n            if (timelineType === 'playout' || interstitial.timelineOccupancy !== TimelineOccupancy.Point) {\n              const assetPlayer = getAssetPlayer(asset);\n              if ((assetPlayer == null ? void 0 : assetPlayer.interstitial) === interstitial) {\n                time += assetPlayer.assetItem.startOffset + assetPlayer[assetPlayerField];\n              }\n            }\n          } else {\n            const value = controllerField === 'bufferedPos' ? getBufferedEnd() : c[controllerField];\n            time += value - item.start;\n          }\n          return time;\n        }\n        return 0;\n      };\n      const findMappedTime = (primaryTime, timelineType) => {\n        if (primaryTime !== 0 && timelineType !== 'primary' && c.schedule.length) {\n          var _c$schedule$items;\n          const index = c.schedule.findItemIndexAtTime(primaryTime);\n          const item = (_c$schedule$items = c.schedule.items) == null ? void 0 : _c$schedule$items[index];\n          if (item) {\n            const diff = item[timelineType].start - item.start;\n            return primaryTime + diff;\n          }\n        }\n        return primaryTime;\n      };\n      const getBufferedEnd = () => {\n        const value = c.bufferedPos;\n        if (value === Number.MAX_VALUE) {\n          return getMappedDuration('primary');\n        }\n        return Math.max(value, 0);\n      };\n      const getMappedDuration = timelineType => {\n        var _c$primaryDetails;\n        if ((_c$primaryDetails = c.primaryDetails) != null && _c$primaryDetails.live) {\n          // return end of last event item or playlist\n          return c.primaryDetails.edge;\n        }\n        return c.schedule.durations[timelineType];\n      };\n      const seekTo = (time, timelineType) => {\n        var _item$event, _c$schedule$items2;\n        const item = c.effectivePlayingItem;\n        if (item != null && (_item$event = item.event) != null && _item$event.restrictions.skip) {\n          return;\n        }\n        c.log(`seek to ${time} \"${timelineType}\"`);\n        const playingItem = c.effectivePlayingItem;\n        const targetIndex = c.schedule.findItemIndexAtTime(time, timelineType);\n        const targetItem = (_c$schedule$items2 = c.schedule.items) == null ? void 0 : _c$schedule$items2[targetIndex];\n        const bufferingPlayer = c.getBufferingPlayer();\n        const bufferingInterstitial = bufferingPlayer == null ? void 0 : bufferingPlayer.interstitial;\n        const appendInPlace = bufferingInterstitial == null ? void 0 : bufferingInterstitial.appendInPlace;\n        const seekInItem = playingItem && c.itemsMatch(playingItem, targetItem);\n        if (playingItem && (appendInPlace || seekInItem)) {\n          // seek in asset player or primary media (appendInPlace)\n          const assetPlayer = getAssetPlayer(c.playingAsset);\n          const media = (assetPlayer == null ? void 0 : assetPlayer.media) || c.primaryMedia;\n          if (media) {\n            const currentTime = timelineType === 'primary' ? media.currentTime : getMappedTime(playingItem, timelineType, c.playingAsset, 'timelinePos', 'currentTime');\n            const diff = time - currentTime;\n            const seekToTime = (appendInPlace ? currentTime : media.currentTime) + diff;\n            if (seekToTime >= 0 && (!assetPlayer || appendInPlace || seekToTime <= assetPlayer.duration)) {\n              media.currentTime = seekToTime;\n              return;\n            }\n          }\n        }\n        // seek out of item or asset\n        if (targetItem) {\n          let seekToTime = time;\n          if (timelineType !== 'primary') {\n            const primarySegmentStart = targetItem[timelineType].start;\n            const diff = time - primarySegmentStart;\n            seekToTime = targetItem.start + diff;\n          }\n          const targetIsPrimary = !c.isInterstitial(targetItem);\n          if ((!c.isInterstitial(playingItem) || playingItem.event.appendInPlace) && (targetIsPrimary || targetItem.event.appendInPlace)) {\n            const media = c.media || (appendInPlace ? bufferingPlayer == null ? void 0 : bufferingPlayer.media : null);\n            if (media) {\n              media.currentTime = seekToTime;\n            }\n          } else if (playingItem) {\n            // check if an Interstitial between the current item and target item has an X-RESTRICT JUMP restriction\n            const playingIndex = c.findItemIndex(playingItem);\n            if (targetIndex > playingIndex) {\n              const jumpIndex = c.schedule.findJumpRestrictedIndex(playingIndex + 1, targetIndex);\n              if (jumpIndex > playingIndex) {\n                c.setSchedulePosition(jumpIndex);\n                return;\n              }\n            }\n            let assetIndex = 0;\n            if (targetIsPrimary) {\n              c.timelinePos = seekToTime;\n              c.checkBuffer();\n            } else {\n              var _targetItem$event;\n              const assetList = targetItem == null ? void 0 : (_targetItem$event = targetItem.event) == null ? void 0 : _targetItem$event.assetList;\n              if (assetList) {\n                const eventTime = time - (targetItem[timelineType] || targetItem).start;\n                for (let i = assetList.length; i--;) {\n                  const asset = assetList[i];\n                  if (asset.duration && eventTime >= asset.startOffset && eventTime < asset.startOffset + asset.duration) {\n                    assetIndex = i;\n                    break;\n                  }\n                }\n              }\n            }\n            c.setSchedulePosition(targetIndex, assetIndex);\n          }\n        }\n      };\n      const getActiveInterstitial = () => {\n        const playingItem = c.effectivePlayingItem;\n        if (c.isInterstitial(playingItem)) {\n          return playingItem;\n        }\n        const bufferingItem = effectiveBufferingItem();\n        if (c.isInterstitial(bufferingItem)) {\n          return bufferingItem;\n        }\n        return null;\n      };\n      const interstitialPlayer = {\n        get currentTime() {\n          const interstitialItem = getActiveInterstitial();\n          const playingItem = c.effectivePlayingItem;\n          if (playingItem && playingItem === interstitialItem) {\n            return getMappedTime(playingItem, 'playout', c.effectivePlayingAsset, 'timelinePos', 'currentTime') - playingItem.playout.start;\n          }\n          return 0;\n        },\n        set currentTime(time) {\n          const interstitialItem = getActiveInterstitial();\n          const playingItem = c.effectivePlayingItem;\n          if (playingItem && playingItem === interstitialItem) {\n            seekTo(time + playingItem.playout.start, 'playout');\n          }\n        },\n        get duration() {\n          const interstitialItem = getActiveInterstitial();\n          if (interstitialItem) {\n            return interstitialItem.playout.end - interstitialItem.playout.start;\n          }\n          return 0;\n        },\n        get assetPlayers() {\n          var _getActiveInterstitia;\n          const assetList = (_getActiveInterstitia = getActiveInterstitial()) == null ? void 0 : _getActiveInterstitia.event.assetList;\n          if (assetList) {\n            return assetList.map(asset => c.getAssetPlayer(asset.identifier));\n          }\n          return [];\n        },\n        get playingIndex() {\n          var _getActiveInterstitia2;\n          const interstitial = (_getActiveInterstitia2 = getActiveInterstitial()) == null ? void 0 : _getActiveInterstitia2.event;\n          if (interstitial && c.effectivePlayingAsset) {\n            return interstitial.findAssetIndex(c.effectivePlayingAsset);\n          }\n          return -1;\n        },\n        get scheduleItem() {\n          return getActiveInterstitial();\n        }\n      };\n      this.manager = {\n        get events() {\n          var _c$schedule, _c$schedule$events;\n          return ((_c$schedule = c.schedule) == null ? void 0 : (_c$schedule$events = _c$schedule.events) == null ? void 0 : _c$schedule$events.slice(0)) || [];\n        },\n        get schedule() {\n          var _c$schedule2, _c$schedule2$items;\n          return ((_c$schedule2 = c.schedule) == null ? void 0 : (_c$schedule2$items = _c$schedule2.items) == null ? void 0 : _c$schedule2$items.slice(0)) || [];\n        },\n        get interstitialPlayer() {\n          if (getActiveInterstitial()) {\n            return interstitialPlayer;\n          }\n          return null;\n        },\n        get playerQueue() {\n          return c.playerQueue.slice(0);\n        },\n        get bufferingAsset() {\n          return c.bufferingAsset;\n        },\n        get bufferingItem() {\n          return effectiveBufferingItem();\n        },\n        get bufferingIndex() {\n          const item = effectiveBufferingItem();\n          return c.findItemIndex(item);\n        },\n        get playingAsset() {\n          return c.effectivePlayingAsset;\n        },\n        get playingItem() {\n          return c.effectivePlayingItem;\n        },\n        get playingIndex() {\n          const item = c.effectivePlayingItem;\n          return c.findItemIndex(item);\n        },\n        primary: {\n          get bufferedEnd() {\n            return getBufferedEnd();\n          },\n          get currentTime() {\n            const timelinePos = c.timelinePos;\n            return timelinePos > 0 ? timelinePos : 0;\n          },\n          set currentTime(time) {\n            seekTo(time, 'primary');\n          },\n          get duration() {\n            return getMappedDuration('primary');\n          },\n          get seekableStart() {\n            var _c$primaryDetails2;\n            return ((_c$primaryDetails2 = c.primaryDetails) == null ? void 0 : _c$primaryDetails2.fragmentStart) || 0;\n          }\n        },\n        integrated: {\n          get bufferedEnd() {\n            return getMappedTime(effectiveBufferingItem(), 'integrated', c.bufferingAsset, 'bufferedPos', 'bufferedEnd');\n          },\n          get currentTime() {\n            return getMappedTime(c.effectivePlayingItem, 'integrated', c.effectivePlayingAsset, 'timelinePos', 'currentTime');\n          },\n          set currentTime(time) {\n            seekTo(time, 'integrated');\n          },\n          get duration() {\n            return getMappedDuration('integrated');\n          },\n          get seekableStart() {\n            var _c$primaryDetails3;\n            return findMappedTime(((_c$primaryDetails3 = c.primaryDetails) == null ? void 0 : _c$primaryDetails3.fragmentStart) || 0, 'integrated');\n          }\n        },\n        skip: () => {\n          const item = c.effectivePlayingItem;\n          const event = item == null ? void 0 : item.event;\n          if (event && !event.restrictions.skip) {\n            const index = c.findItemIndex(item);\n            if (event.appendInPlace) {\n              const time = item.playout.start + item.event.duration;\n              seekTo(time + 0.001, 'playout');\n            } else {\n              c.advanceAfterAssetEnded(event, index, Infinity);\n            }\n          }\n        }\n      };\n    }\n    return this.manager;\n  }\n\n  // Schedule getters\n  get effectivePlayingItem() {\n    return this.waitingItem || this.playingItem || this.endedItem;\n  }\n  get effectivePlayingAsset() {\n    return this.playingAsset || this.endedAsset;\n  }\n  get playingLastItem() {\n    var _this$schedule;\n    const playingItem = this.playingItem;\n    const items = (_this$schedule = this.schedule) == null ? void 0 : _this$schedule.items;\n    if (!this.playbackStarted || !playingItem || !items) {\n      return false;\n    }\n    return this.findItemIndex(playingItem) === items.length - 1;\n  }\n  get playbackStarted() {\n    return this.effectivePlayingItem !== null;\n  }\n\n  // Media getters and event callbacks\n  get currentTime() {\n    var _this$bufferingItem, _this$bufferingItem$e, _media;\n    if (this.mediaSelection === null) {\n      // Do not advance before schedule is known\n      return undefined;\n    }\n    // Ignore currentTime when detached for Interstitial playback with source reset\n    const queuedForPlayback = this.waitingItem || this.playingItem;\n    if (this.isInterstitial(queuedForPlayback) && !queuedForPlayback.event.appendInPlace) {\n      return undefined;\n    }\n    let media = this.media;\n    if (!media && (_this$bufferingItem = this.bufferingItem) != null && (_this$bufferingItem$e = _this$bufferingItem.event) != null && _this$bufferingItem$e.appendInPlace) {\n      // Observe detached media currentTime when appending in place\n      media = this.primaryMedia;\n    }\n    const currentTime = (_media = media) == null ? void 0 : _media.currentTime;\n    if (currentTime === undefined || !isFiniteNumber(currentTime)) {\n      return undefined;\n    }\n    return currentTime;\n  }\n  get primaryMedia() {\n    var _this$detachedData;\n    return this.media || ((_this$detachedData = this.detachedData) == null ? void 0 : _this$detachedData.media) || null;\n  }\n  isInterstitial(item) {\n    return !!(item != null && item.event);\n  }\n  retreiveMediaSource(assetId, toSegment) {\n    const player = this.getAssetPlayer(assetId);\n    if (player) {\n      this.transferMediaFromPlayer(player, toSegment);\n    }\n  }\n  transferMediaFromPlayer(player, toSegment) {\n    const appendInPlace = player.interstitial.appendInPlace;\n    const playerMedia = player.media;\n    if (appendInPlace && playerMedia === this.primaryMedia) {\n      this.bufferingAsset = null;\n      if (!toSegment || this.isInterstitial(toSegment) && !toSegment.event.appendInPlace) {\n        // MediaSource cannot be transfered back to an Interstitial that requires a source reset\n        // no-op when toSegment is undefined\n        if (toSegment && playerMedia) {\n          this.detachedData = {\n            media: playerMedia\n          };\n          return;\n        }\n      }\n      const attachMediaSourceData = player.transferMedia();\n      this.log(`transfer MediaSource from ${player} ${stringify(attachMediaSourceData)}`);\n      this.detachedData = attachMediaSourceData;\n    } else if (toSegment && playerMedia) {\n      this.shouldPlay || (this.shouldPlay = !playerMedia.paused);\n    }\n  }\n  transferMediaTo(player, media) {\n    var _this$detachedData2, _attachMediaSourceDat;\n    if (player.media === media) {\n      return;\n    }\n    let attachMediaSourceData = null;\n    const primaryPlayer = this.hls;\n    const isAssetPlayer = player !== primaryPlayer;\n    const appendInPlace = isAssetPlayer && player.interstitial.appendInPlace;\n    const detachedMediaSource = (_this$detachedData2 = this.detachedData) == null ? void 0 : _this$detachedData2.mediaSource;\n    let logFromSource;\n    if (primaryPlayer.media) {\n      if (appendInPlace) {\n        attachMediaSourceData = primaryPlayer.transferMedia();\n        this.detachedData = attachMediaSourceData;\n      }\n      logFromSource = `Primary`;\n    } else if (detachedMediaSource) {\n      const bufferingPlayer = this.getBufferingPlayer();\n      if (bufferingPlayer) {\n        attachMediaSourceData = bufferingPlayer.transferMedia();\n        logFromSource = `${bufferingPlayer}`;\n      } else {\n        logFromSource = `detached MediaSource`;\n      }\n    } else {\n      logFromSource = `detached media`;\n    }\n    if (!attachMediaSourceData) {\n      if (detachedMediaSource) {\n        attachMediaSourceData = this.detachedData;\n        this.log(`using detachedData: MediaSource ${stringify(attachMediaSourceData)}`);\n      } else if (!this.detachedData || primaryPlayer.media === media) {\n        // Keep interstitial media transition consistent\n        const playerQueue = this.playerQueue;\n        if (playerQueue.length > 1) {\n          playerQueue.forEach(queuedPlayer => {\n            if (isAssetPlayer && queuedPlayer.interstitial.appendInPlace !== appendInPlace) {\n              const interstitial = queuedPlayer.interstitial;\n              this.clearInterstitial(queuedPlayer.interstitial, null);\n              interstitial.appendInPlace = false;\n              if (interstitial.appendInPlace) {\n                this.warn(`Could not change append strategy for queued assets ${interstitial}`);\n              }\n            }\n          });\n        }\n        this.hls.detachMedia();\n        this.detachedData = {\n          media\n        };\n      }\n    }\n    const transferring = attachMediaSourceData && 'mediaSource' in attachMediaSourceData && ((_attachMediaSourceDat = attachMediaSourceData.mediaSource) == null ? void 0 : _attachMediaSourceDat.readyState) !== 'closed';\n    const dataToAttach = transferring && attachMediaSourceData ? attachMediaSourceData : media;\n    this.log(`${transferring ? 'transfering MediaSource' : 'attaching media'} to ${isAssetPlayer ? player : 'Primary'} from ${logFromSource}`);\n    if (dataToAttach === attachMediaSourceData) {\n      const isAssetAtEndOfSchedule = isAssetPlayer && player.assetId === this.schedule.assetIdAtEnd;\n      // Prevent asset players from marking EoS on transferred MediaSource\n      dataToAttach.overrides = {\n        duration: this.schedule.duration,\n        endOfStream: !isAssetPlayer || isAssetAtEndOfSchedule,\n        cueRemoval: !isAssetPlayer\n      };\n    }\n    player.attachMedia(dataToAttach);\n  }\n  onInterstitialCueEnter() {\n    this.onTimeupdate();\n  }\n  // Scheduling methods\n  checkStart() {\n    const schedule = this.schedule;\n    const interstitialEvents = schedule.events;\n    if (!interstitialEvents || this.playbackDisabled || !this.media) {\n      return;\n    }\n    // Check buffered to pre-roll\n    if (this.bufferedPos === -1) {\n      this.bufferedPos = 0;\n    }\n    // Start stepping through schedule when playback begins for the first time and we have a pre-roll\n    const timelinePos = this.timelinePos;\n    const effectivePlayingItem = this.effectivePlayingItem;\n    if (timelinePos === -1) {\n      const startPosition = this.hls.startPosition;\n      this.timelinePos = startPosition;\n      if (interstitialEvents.length && interstitialEvents[0].cue.pre) {\n        const index = schedule.findEventIndex(interstitialEvents[0].identifier);\n        this.setSchedulePosition(index);\n      } else if (startPosition >= 0 || !this.primaryLive) {\n        const start = this.timelinePos = startPosition > 0 ? startPosition : 0;\n        const index = schedule.findItemIndexAtTime(start);\n        this.setSchedulePosition(index);\n      }\n    } else if (effectivePlayingItem && !this.playingItem) {\n      const index = schedule.findItemIndex(effectivePlayingItem);\n      this.setSchedulePosition(index);\n    }\n  }\n  advanceAfterAssetEnded(interstitial, index, assetListIndex) {\n    const nextAssetIndex = getNextAssetIndex(interstitial, assetListIndex);\n    if (!interstitial.isAssetPastPlayoutLimit(nextAssetIndex)) {\n      // Advance to next asset list item\n      this.setSchedulePosition(index, nextAssetIndex);\n    } else {\n      // Advance to next schedule segment\n      // check if we've reached the end of the program\n      const scheduleItems = this.schedule.items;\n      if (scheduleItems) {\n        const nextIndex = index + 1;\n        const scheduleLength = scheduleItems.length;\n        if (nextIndex >= scheduleLength) {\n          this.setSchedulePosition(-1);\n          return;\n        }\n        const resumptionTime = interstitial.resumeTime;\n        if (this.timelinePos < resumptionTime) {\n          this.timelinePos = resumptionTime;\n          this.checkBuffer();\n        }\n        this.setSchedulePosition(nextIndex);\n      }\n    }\n  }\n  setScheduleToAssetAtTime(time, playingAsset) {\n    const schedule = this.schedule;\n    const parentIdentifier = playingAsset.parentIdentifier;\n    const interstitial = schedule.getEvent(parentIdentifier);\n    if (interstitial) {\n      const itemIndex = schedule.findEventIndex(parentIdentifier);\n      const assetListIndex = schedule.findAssetIndex(interstitial, time);\n      this.advanceAfterAssetEnded(interstitial, itemIndex, assetListIndex - 1);\n    }\n  }\n  setSchedulePosition(index, assetListIndex) {\n    const scheduleItems = this.schedule.items;\n    if (!scheduleItems || this.playbackDisabled) {\n      return;\n    }\n    this.log(`setSchedulePosition ${index}, ${assetListIndex}`);\n    const scheduledItem = index >= 0 ? scheduleItems[index] : null;\n    // Cleanup current item / asset\n    const currentItem = this.playingItem;\n    const playingLastItem = this.playingLastItem;\n    if (this.isInterstitial(currentItem)) {\n      var _interstitial$assetLi;\n      const interstitial = currentItem.event;\n      const playingAsset = this.playingAsset;\n      const assetId = playingAsset == null ? void 0 : playingAsset.identifier;\n      const player = assetId ? this.getAssetPlayer(assetId) : null;\n      if (player && assetId && (!this.eventItemsMatch(currentItem, scheduledItem) || assetListIndex !== undefined && assetId !== ((_interstitial$assetLi = interstitial.assetList) == null ? void 0 : _interstitial$assetLi[assetListIndex].identifier))) {\n        var _this$detachedData3;\n        const playingAssetListIndex = interstitial.findAssetIndex(playingAsset);\n        this.log(`INTERSTITIAL_ASSET_ENDED ${playingAssetListIndex + 1}/${interstitial.assetList.length} ${eventAssetToString(playingAsset)}`);\n        this.endedAsset = playingAsset;\n        this.playingAsset = null;\n        this.hls.trigger(Events.INTERSTITIAL_ASSET_ENDED, {\n          asset: playingAsset,\n          assetListIndex: playingAssetListIndex,\n          event: interstitial,\n          schedule: scheduleItems.slice(0),\n          scheduleIndex: index,\n          player\n        });\n        if (currentItem !== this.playingItem) {\n          // Schedule change occured on INTERSTITIAL_ASSET_ENDED\n          if (this.itemsMatch(currentItem, this.playingItem) && !this.playingAsset) {\n            this.advanceAfterAssetEnded(interstitial, this.findItemIndex(this.playingItem), playingAssetListIndex);\n          }\n          // Navigation occured on INTERSTITIAL_ASSET_ENDED\n          return;\n        }\n        this.retreiveMediaSource(assetId, scheduledItem);\n        if (player.media && !((_this$detachedData3 = this.detachedData) != null && _this$detachedData3.mediaSource)) {\n          player.detachMedia();\n        }\n      }\n      if (!this.eventItemsMatch(currentItem, scheduledItem)) {\n        this.endedItem = currentItem;\n        this.playingItem = null;\n        this.log(`INTERSTITIAL_ENDED ${interstitial} ${segmentToString(currentItem)}`);\n        interstitial.hasPlayed = true;\n        this.hls.trigger(Events.INTERSTITIAL_ENDED, {\n          event: interstitial,\n          schedule: scheduleItems.slice(0),\n          scheduleIndex: index\n        });\n        // Exiting an Interstitial\n        if (interstitial.cue.once) {\n          // Remove interstitial with CUE attribute value of ONCE after it has played\n          this.updateSchedule();\n          const items = this.schedule.items;\n          if (scheduledItem && items) {\n            const updatedIndex = this.findItemIndex(scheduledItem);\n            this.advanceSchedule(updatedIndex, items, assetListIndex, currentItem, playingLastItem);\n          }\n          return;\n        }\n      }\n    }\n    this.advanceSchedule(index, scheduleItems, assetListIndex, currentItem, playingLastItem);\n  }\n  advanceSchedule(index, scheduleItems, assetListIndex, currentItem, playedLastItem) {\n    const scheduledItem = index >= 0 ? scheduleItems[index] : null;\n    const media = this.primaryMedia;\n    // Cleanup out of range Interstitials\n    const playerQueue = this.playerQueue;\n    if (playerQueue.length) {\n      playerQueue.forEach(player => {\n        const interstitial = player.interstitial;\n        const queuedIndex = this.schedule.findEventIndex(interstitial.identifier);\n        if (queuedIndex < index || queuedIndex > index + 1) {\n          this.clearInterstitial(interstitial, scheduledItem);\n        }\n      });\n    }\n    // Setup scheduled item\n    if (this.isInterstitial(scheduledItem)) {\n      this.timelinePos = Math.min(Math.max(this.timelinePos, scheduledItem.start), scheduledItem.end);\n      // Handle Interstitial\n      const interstitial = scheduledItem.event;\n      // find asset index\n      if (assetListIndex === undefined) {\n        assetListIndex = this.schedule.findAssetIndex(interstitial, this.timelinePos);\n        const assetIndexCandidate = getNextAssetIndex(interstitial, assetListIndex - 1);\n        if (interstitial.isAssetPastPlayoutLimit(assetIndexCandidate)) {\n          this.advanceAfterAssetEnded(interstitial, index, assetListIndex);\n          return;\n        }\n        assetListIndex = assetIndexCandidate;\n      }\n      // Ensure Interstitial is enqueued\n      const waitingItem = this.waitingItem;\n      if (!this.assetsBuffered(scheduledItem, media)) {\n        this.setBufferingItem(scheduledItem);\n      }\n      let player = this.preloadAssets(interstitial, assetListIndex);\n      if (!this.eventItemsMatch(scheduledItem, waitingItem || currentItem)) {\n        this.waitingItem = scheduledItem;\n        this.log(`INTERSTITIAL_STARTED ${segmentToString(scheduledItem)} ${interstitial.appendInPlace ? 'append in place' : ''}`);\n        this.hls.trigger(Events.INTERSTITIAL_STARTED, {\n          event: interstitial,\n          schedule: scheduleItems.slice(0),\n          scheduleIndex: index\n        });\n      }\n      if (!interstitial.assetListLoaded) {\n        // Waiting at end of primary content segment\n        // Expect setSchedulePosition to be called again once ASSET-LIST is loaded\n        this.log(`Waiting for ASSET-LIST to complete loading ${interstitial}`);\n        return;\n      }\n      if (interstitial.assetListLoader) {\n        interstitial.assetListLoader.destroy();\n        interstitial.assetListLoader = undefined;\n      }\n      if (!media) {\n        this.log(`Waiting for attachMedia to start Interstitial ${interstitial}`);\n        return;\n      }\n      // Update schedule and asset list position now that it can start\n      this.waitingItem = this.endedItem = null;\n      this.playingItem = scheduledItem;\n\n      // If asset-list is empty or missing asset index, advance to next item\n      const assetItem = interstitial.assetList[assetListIndex];\n      if (!assetItem) {\n        const nextItem = scheduleItems[index + 1];\n        const _media2 = this.media;\n        if (nextItem && _media2 && !this.isInterstitial(nextItem) && _media2.currentTime < nextItem.start) {\n          _media2.currentTime = this.timelinePos = nextItem.start;\n        }\n        this.advanceAfterAssetEnded(interstitial, index, assetListIndex || 0);\n        return;\n      }\n\n      // Start Interstitial Playback\n      if (!player) {\n        player = this.getAssetPlayer(assetItem.identifier);\n      }\n      if (player === null || player.destroyed) {\n        const assetListLength = interstitial.assetList.length;\n        this.warn(`asset ${assetListIndex + 1}/${assetListLength} player destroyed ${interstitial}`);\n        player = this.createAssetPlayer(interstitial, assetItem, assetListIndex);\n      }\n      if (!this.eventItemsMatch(scheduledItem, this.bufferingItem)) {\n        if (interstitial.appendInPlace && this.isAssetBuffered(assetItem)) {\n          return;\n        }\n      }\n      this.startAssetPlayer(player, assetListIndex, scheduleItems, index, media);\n      if (this.shouldPlay) {\n        playWithCatch(player.media);\n      }\n    } else if (scheduledItem !== null) {\n      this.resumePrimary(scheduledItem, index, currentItem);\n      if (this.shouldPlay) {\n        playWithCatch(this.hls.media);\n      }\n    } else if (playedLastItem && this.isInterstitial(currentItem)) {\n      // Maintain playingItem state at end of schedule (setSchedulePosition(-1) called to end program)\n      // this allows onSeeking handler to update schedule position\n      this.endedItem = null;\n      this.playingItem = currentItem;\n      if (!currentItem.event.appendInPlace) {\n        // Media must be re-attached to resume primary schedule if not sharing source\n        this.attachPrimary(this.schedule.durations.primary, null);\n      }\n    }\n  }\n  get playbackDisabled() {\n    return this.hls.config.enableInterstitialPlayback === false;\n  }\n  get primaryDetails() {\n    var _this$mediaSelection, _this$mediaSelection$;\n    return (_this$mediaSelection = this.mediaSelection) == null ? void 0 : (_this$mediaSelection$ = _this$mediaSelection.main) == null ? void 0 : _this$mediaSelection$.details;\n  }\n  get primaryLive() {\n    var _this$primaryDetails;\n    return !!((_this$primaryDetails = this.primaryDetails) != null && _this$primaryDetails.live);\n  }\n  resumePrimary(scheduledItem, index, fromItem) {\n    var _this$detachedData4;\n    this.playingItem = scheduledItem;\n    this.playingAsset = this.endedAsset = null;\n    this.waitingItem = this.endedItem = null;\n    this.bufferedToItem(scheduledItem);\n    this.log(`resuming ${segmentToString(scheduledItem)}`);\n    if (!((_this$detachedData4 = this.detachedData) != null && _this$detachedData4.mediaSource)) {\n      let timelinePos = this.timelinePos;\n      if (timelinePos < scheduledItem.start || timelinePos >= scheduledItem.end) {\n        timelinePos = this.getPrimaryResumption(scheduledItem, index);\n        this.timelinePos = timelinePos;\n      }\n      this.attachPrimary(timelinePos, scheduledItem);\n    }\n    if (!fromItem) {\n      return;\n    }\n    const scheduleItems = this.schedule.items;\n    if (!scheduleItems) {\n      return;\n    }\n    this.log(`INTERSTITIALS_PRIMARY_RESUMED ${segmentToString(scheduledItem)}`);\n    this.hls.trigger(Events.INTERSTITIALS_PRIMARY_RESUMED, {\n      schedule: scheduleItems.slice(0),\n      scheduleIndex: index\n    });\n    this.checkBuffer();\n  }\n  getPrimaryResumption(scheduledItem, index) {\n    const itemStart = scheduledItem.start;\n    if (this.primaryLive) {\n      const details = this.primaryDetails;\n      if (index === 0) {\n        return this.hls.startPosition;\n      } else if (details && (itemStart < details.fragmentStart || itemStart > details.edge)) {\n        return this.hls.liveSyncPosition || -1;\n      }\n    }\n    return itemStart;\n  }\n  isAssetBuffered(asset) {\n    const player = this.getAssetPlayer(asset.identifier);\n    if (player != null && player.hls) {\n      return player.hls.bufferedToEnd;\n    }\n    const bufferInfo = BufferHelper.bufferInfo(this.primaryMedia, this.timelinePos, 0);\n    return bufferInfo.end + 1 >= asset.timelineStart + (asset.duration || 0);\n  }\n  attachPrimary(timelinePos, item, skipSeekToStartPosition) {\n    if (item) {\n      this.setBufferingItem(item);\n    } else {\n      this.bufferingItem = this.playingItem;\n    }\n    this.bufferingAsset = null;\n    const media = this.primaryMedia;\n    if (!media) {\n      return;\n    }\n    const hls = this.hls;\n    if (hls.media) {\n      this.checkBuffer();\n    } else {\n      this.transferMediaTo(hls, media);\n      if (skipSeekToStartPosition) {\n        this.startLoadingPrimaryAt(timelinePos, skipSeekToStartPosition);\n      }\n    }\n    if (!skipSeekToStartPosition) {\n      // Set primary position to resume time\n      this.timelinePos = timelinePos;\n      this.startLoadingPrimaryAt(timelinePos, skipSeekToStartPosition);\n    }\n  }\n  startLoadingPrimaryAt(timelinePos, skipSeekToStartPosition) {\n    var _hls$mainForwardBuffe;\n    const hls = this.hls;\n    if (!hls.loadingEnabled || !hls.media || Math.abs((((_hls$mainForwardBuffe = hls.mainForwardBufferInfo) == null ? void 0 : _hls$mainForwardBuffe.start) || hls.media.currentTime) - timelinePos) > 0.5) {\n      hls.startLoad(timelinePos, skipSeekToStartPosition);\n    } else if (!hls.bufferingEnabled) {\n      hls.resumeBuffering();\n    }\n  }\n\n  // HLS.js event callbacks\n  onManifestLoading() {\n    this.stopLoad();\n    this.schedule.reset();\n    this.emptyPlayerQueue();\n    this.clearScheduleState();\n    this.shouldPlay = false;\n    this.bufferedPos = this.timelinePos = -1;\n    this.mediaSelection = this.altSelection = this.manager = this.requiredTracks = null;\n    // BUFFER_CODECS listener added here for buffer-controller to handle it first where it adds tracks\n    this.hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n    this.hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n  }\n  onLevelUpdated(event, data) {\n    if (data.level === -1) {\n      // level was removed\n      return;\n    }\n    const main = this.hls.levels[data.level];\n    const currentSelection = _objectSpread2(_objectSpread2({}, this.mediaSelection || this.altSelection), {}, {\n      main\n    });\n    this.mediaSelection = currentSelection;\n    this.schedule.parseInterstitialDateRanges(currentSelection, this.hls.config.interstitialAppendInPlace);\n    if (!this.effectivePlayingItem && this.schedule.items) {\n      this.checkStart();\n    }\n  }\n  onAudioTrackUpdated(event, data) {\n    const audio = this.hls.audioTracks[data.id];\n    const previousSelection = this.mediaSelection;\n    if (!previousSelection) {\n      this.altSelection = _objectSpread2(_objectSpread2({}, this.altSelection), {}, {\n        audio\n      });\n      return;\n    }\n    const currentSelection = _objectSpread2(_objectSpread2({}, previousSelection), {}, {\n      audio\n    });\n    this.mediaSelection = currentSelection;\n  }\n  onSubtitleTrackUpdated(event, data) {\n    const subtitles = this.hls.subtitleTracks[data.id];\n    const previousSelection = this.mediaSelection;\n    if (!previousSelection) {\n      this.altSelection = _objectSpread2(_objectSpread2({}, this.altSelection), {}, {\n        subtitles\n      });\n      return;\n    }\n    const currentSelection = _objectSpread2(_objectSpread2({}, previousSelection), {}, {\n      subtitles\n    });\n    this.mediaSelection = currentSelection;\n  }\n  onAudioTrackSwitching(event, data) {\n    const audioOption = getBasicSelectionOption(data);\n    this.playerQueue.forEach(player => player.hls.setAudioOption(data) || player.hls.setAudioOption(audioOption));\n  }\n  onSubtitleTrackSwitch(event, data) {\n    const subtitleOption = getBasicSelectionOption(data);\n    this.playerQueue.forEach(player => player.hls.setSubtitleOption(data) || data.id !== -1 && player.hls.setSubtitleOption(subtitleOption));\n  }\n  onBufferCodecs(event, data) {\n    const requiredTracks = data.tracks;\n    if (requiredTracks) {\n      this.requiredTracks = requiredTracks;\n    }\n  }\n  onBufferAppended(event, data) {\n    this.checkBuffer();\n  }\n  onBufferFlushed(event, data) {\n    const playingItem = this.playingItem;\n    if (playingItem && !this.itemsMatch(playingItem, this.bufferingItem) && !this.isInterstitial(playingItem)) {\n      const timelinePos = this.timelinePos;\n      this.bufferedPos = timelinePos;\n      this.checkBuffer();\n    }\n  }\n  onBufferedToEnd(event) {\n    // Buffered to post-roll\n    const interstitialEvents = this.schedule.events;\n    if (this.bufferedPos < Number.MAX_VALUE && interstitialEvents) {\n      for (let i = 0; i < interstitialEvents.length; i++) {\n        const interstitial = interstitialEvents[i];\n        if (interstitial.cue.post) {\n          var _this$schedule$items;\n          const scheduleIndex = this.schedule.findEventIndex(interstitial.identifier);\n          const item = (_this$schedule$items = this.schedule.items) == null ? void 0 : _this$schedule$items[scheduleIndex];\n          if (this.isInterstitial(item) && this.eventItemsMatch(item, this.bufferingItem)) {\n            this.bufferedToItem(item, 0);\n          }\n          break;\n        }\n      }\n      this.bufferedPos = Number.MAX_VALUE;\n    }\n  }\n  onMediaEnded(event) {\n    const playingItem = this.playingItem;\n    if (!this.playingLastItem && playingItem) {\n      const playingIndex = this.findItemIndex(playingItem);\n      this.setSchedulePosition(playingIndex + 1);\n    } else {\n      this.shouldPlay = false;\n    }\n  }\n  updateItem(previousItem, time) {\n    // find item in this.schedule.items;\n    const items = this.schedule.items;\n    if (previousItem && items) {\n      const index = this.findItemIndex(previousItem, time);\n      return items[index] || null;\n    }\n    return null;\n  }\n  trimInPlace(updatedItem, itemBeforeUpdate) {\n    if (this.isInterstitial(updatedItem) && updatedItem.event.appendInPlace && itemBeforeUpdate.end - updatedItem.end > 0.25) {\n      updatedItem.event.assetList.forEach((asset, index) => {\n        if (updatedItem.event.isAssetPastPlayoutLimit(index)) {\n          this.clearAssetPlayer(asset.identifier, null);\n        }\n      });\n      const flushStart = updatedItem.end + 0.25;\n      const bufferInfo = BufferHelper.bufferInfo(this.primaryMedia, flushStart, 0);\n      if (bufferInfo.end > flushStart || (bufferInfo.nextStart || 0) > flushStart) {\n        this.attachPrimary(flushStart, null);\n        this.flushFrontBuffer(flushStart);\n      }\n    }\n  }\n  itemsMatch(a, b) {\n    return !!b && (a === b || a.event && b.event && this.eventItemsMatch(a, b) || !a.event && !b.event && this.findItemIndex(a) === this.findItemIndex(b));\n  }\n  eventItemsMatch(a, b) {\n    var _b$event;\n    return !!b && (a === b || a.event.identifier === ((_b$event = b.event) == null ? void 0 : _b$event.identifier));\n  }\n  findItemIndex(item, time) {\n    return item ? this.schedule.findItemIndex(item, time) : -1;\n  }\n  updateSchedule() {\n    const mediaSelection = this.mediaSelection;\n    if (!mediaSelection) {\n      return;\n    }\n    this.schedule.updateSchedule(mediaSelection, []);\n  }\n\n  // Schedule buffer control\n  checkBuffer(starved) {\n    const items = this.schedule.items;\n    if (!items) {\n      return;\n    }\n    // Find when combined forward buffer change reaches next schedule segment\n    const bufferInfo = BufferHelper.bufferInfo(this.primaryMedia, this.timelinePos, 0);\n    if (starved) {\n      this.bufferedPos = this.timelinePos;\n    }\n    starved || (starved = bufferInfo.len < 1);\n    this.updateBufferedPos(bufferInfo.end, items, starved);\n  }\n  updateBufferedPos(bufferEnd, items, bufferIsEmpty) {\n    const schedule = this.schedule;\n    const bufferingItem = this.bufferingItem;\n    if (this.bufferedPos > bufferEnd) {\n      return;\n    }\n    if (items.length === 1 && this.itemsMatch(items[0], bufferingItem)) {\n      this.bufferedPos = bufferEnd;\n      return;\n    }\n    const playingItem = this.playingItem;\n    const playingIndex = this.findItemIndex(playingItem);\n    let bufferEndIndex = schedule.findItemIndexAtTime(bufferEnd);\n    if (this.bufferedPos < bufferEnd) {\n      var _nextItemToBuffer$eve, _bufferingItem$event;\n      const bufferingIndex = this.findItemIndex(bufferingItem);\n      const nextToBufferIndex = Math.min(bufferingIndex + 1, items.length - 1);\n      const nextItemToBuffer = items[nextToBufferIndex];\n      if (bufferEndIndex === -1 && bufferingItem && bufferEnd >= bufferingItem.end || (_nextItemToBuffer$eve = nextItemToBuffer.event) != null && _nextItemToBuffer$eve.appendInPlace && bufferEnd + 0.01 >= nextItemToBuffer.start) {\n        bufferEndIndex = nextToBufferIndex;\n      }\n      if (nextToBufferIndex - playingIndex > 1 && (bufferingItem == null ? void 0 : (_bufferingItem$event = bufferingItem.event) == null ? void 0 : _bufferingItem$event.appendInPlace) === false) {\n        // do not advance buffering item past Interstitial that requires source reset\n        return;\n      }\n      this.bufferedPos = bufferEnd;\n      if (bufferEndIndex > bufferingIndex && bufferEndIndex > playingIndex) {\n        this.bufferedToItem(nextItemToBuffer);\n      } else {\n        // allow more time than distance from edge for assets to load\n        const details = this.primaryDetails;\n        if (this.primaryLive && details && bufferEnd > details.edge - details.targetduration && nextItemToBuffer.start < details.edge + this.hls.config.interstitialLiveLookAhead && this.isInterstitial(nextItemToBuffer)) {\n          this.preloadAssets(nextItemToBuffer.event, 0);\n        }\n      }\n    } else if (bufferIsEmpty && playingItem && !this.itemsMatch(playingItem, bufferingItem)) {\n      if (bufferEndIndex === playingIndex) {\n        this.bufferedToItem(playingItem);\n      } else if (bufferEndIndex === playingIndex + 1) {\n        this.bufferedToItem(items[bufferEndIndex]);\n      }\n    }\n  }\n  assetsBuffered(item, media) {\n    const assetList = item.event.assetList;\n    if (assetList.length === 0) {\n      return false;\n    }\n    return !item.event.assetList.some(asset => {\n      const player = this.getAssetPlayer(asset.identifier);\n      return !(player != null && player.bufferedInPlaceToEnd(media));\n    });\n  }\n  setBufferingItem(item) {\n    const bufferingLast = this.bufferingItem;\n    const schedule = this.schedule;\n    if (!this.itemsMatch(item, bufferingLast)) {\n      const {\n        items,\n        events\n      } = schedule;\n      if (!items || !events) {\n        return bufferingLast;\n      }\n      const isInterstitial = this.isInterstitial(item);\n      const bufferingPlayer = this.getBufferingPlayer();\n      this.bufferingItem = item;\n      this.bufferedPos = Math.max(item.start, Math.min(item.end, this.timelinePos));\n      const timeRemaining = bufferingPlayer ? bufferingPlayer.remaining : bufferingLast ? bufferingLast.end - this.timelinePos : 0;\n      this.log(`INTERSTITIALS_BUFFERED_TO_BOUNDARY ${segmentToString(item)}` + (bufferingLast ? ` (${timeRemaining.toFixed(2)} remaining)` : ''));\n      if (!this.playbackDisabled) {\n        if (isInterstitial) {\n          // primary fragment loading will exit early in base-stream-controller while `bufferingItem` is set to an Interstitial block\n          item.event.assetList.forEach(asset => {\n            const player = this.getAssetPlayer(asset.identifier);\n            if (player) {\n              player.resumeBuffering();\n            }\n          });\n        } else {\n          this.hls.resumeBuffering();\n          this.playerQueue.forEach(player => player.pauseBuffering());\n        }\n      }\n      this.hls.trigger(Events.INTERSTITIALS_BUFFERED_TO_BOUNDARY, {\n        events: events.slice(0),\n        schedule: items.slice(0),\n        bufferingIndex: this.findItemIndex(item),\n        playingIndex: this.findItemIndex(this.playingItem)\n      });\n    } else if (this.bufferingItem !== item) {\n      this.bufferingItem = item;\n    }\n    return bufferingLast;\n  }\n  bufferedToItem(item, assetListIndex = 0) {\n    const bufferingLast = this.setBufferingItem(item);\n    if (this.playbackDisabled) {\n      return;\n    }\n    if (this.isInterstitial(item)) {\n      // Ensure asset list is loaded\n      this.bufferedToEvent(item, assetListIndex);\n    } else if (bufferingLast !== null) {\n      // If primary player is detached, it is also stopped, restart loading at primary position\n      this.bufferingAsset = null;\n      const detachedData = this.detachedData;\n      if (detachedData) {\n        if (detachedData.mediaSource) {\n          const skipSeekToStartPosition = true;\n          this.attachPrimary(item.start, item, skipSeekToStartPosition);\n        } else {\n          this.preloadPrimary(item);\n        }\n      } else {\n        // If not detached seek to resumption point\n        this.preloadPrimary(item);\n      }\n    }\n  }\n  preloadPrimary(item) {\n    const index = this.findItemIndex(item);\n    const timelinePos = this.getPrimaryResumption(item, index);\n    this.startLoadingPrimaryAt(timelinePos);\n  }\n  bufferedToEvent(item, assetListIndex) {\n    const interstitial = item.event;\n    const neverLoaded = interstitial.assetList.length === 0 && !interstitial.assetListLoader;\n    const playOnce = interstitial.cue.once;\n    if (neverLoaded || !playOnce) {\n      // Buffered to Interstitial boundary\n      const player = this.preloadAssets(interstitial, assetListIndex);\n      if (player != null && player.interstitial.appendInPlace) {\n        // If we have a player and asset list info, start buffering\n        const assetItem = interstitial.assetList[assetListIndex];\n        const media = this.primaryMedia;\n        if (assetItem && media) {\n          this.bufferAssetPlayer(player, media);\n        }\n      }\n    }\n  }\n  preloadAssets(interstitial, assetListIndex) {\n    const uri = interstitial.assetUrl;\n    const assetListLength = interstitial.assetList.length;\n    const neverLoaded = assetListLength === 0 && !interstitial.assetListLoader;\n    const playOnce = interstitial.cue.once;\n    if (neverLoaded) {\n      const timelineStart = interstitial.timelineStart;\n      if (interstitial.appendInPlace) {\n        var _playingItem$nextEven;\n        const playingItem = this.playingItem;\n        if (!this.isInterstitial(playingItem) && (playingItem == null ? void 0 : (_playingItem$nextEven = playingItem.nextEvent) == null ? void 0 : _playingItem$nextEven.identifier) === interstitial.identifier) {\n          this.flushFrontBuffer(timelineStart + 0.25);\n        }\n      }\n      let hlsStartOffset;\n      let liveStartPosition = 0;\n      if (!this.playingItem && this.primaryLive) {\n        liveStartPosition = this.hls.startPosition;\n        if (liveStartPosition === -1) {\n          liveStartPosition = this.hls.liveSyncPosition || 0;\n        }\n      }\n      if (liveStartPosition && !(interstitial.cue.pre || interstitial.cue.post)) {\n        const startOffset = liveStartPosition - timelineStart;\n        if (startOffset > 0) {\n          hlsStartOffset = Math.round(startOffset * 1000) / 1000;\n        }\n      }\n      this.log(`Load interstitial asset ${assetListIndex + 1}/${uri ? 1 : assetListLength} ${interstitial}${hlsStartOffset ? ` live-start: ${liveStartPosition} start-offset: ${hlsStartOffset}` : ''}`);\n      if (uri) {\n        return this.createAsset(interstitial, 0, 0, timelineStart, interstitial.duration, uri);\n      }\n      const assetListLoader = this.assetListLoader.loadAssetList(interstitial, hlsStartOffset);\n      if (assetListLoader) {\n        interstitial.assetListLoader = assetListLoader;\n      }\n    } else if (!playOnce && assetListLength) {\n      // Re-buffered to Interstitial boundary, re-create asset player(s)\n      for (let i = assetListIndex; i < assetListLength; i++) {\n        const asset = interstitial.assetList[i];\n        const playerIndex = this.getAssetPlayerQueueIndex(asset.identifier);\n        if ((playerIndex === -1 || this.playerQueue[playerIndex].destroyed) && !asset.error) {\n          this.createAssetPlayer(interstitial, asset, i);\n        }\n      }\n      return this.getAssetPlayer(interstitial.assetList[assetListIndex].identifier);\n    }\n    return null;\n  }\n  flushFrontBuffer(startOffset) {\n    // Force queued flushing of all buffers\n    const requiredTracks = this.requiredTracks;\n    if (!requiredTracks) {\n      return;\n    }\n    this.log(`Removing front buffer starting at ${startOffset}`);\n    const sourceBufferNames = Object.keys(requiredTracks);\n    sourceBufferNames.forEach(type => {\n      this.hls.trigger(Events.BUFFER_FLUSHING, {\n        startOffset,\n        endOffset: Infinity,\n        type\n      });\n    });\n  }\n\n  // Interstitial Asset Player control\n  getAssetPlayerQueueIndex(assetId) {\n    const playerQueue = this.playerQueue;\n    for (let i = 0; i < playerQueue.length; i++) {\n      if (assetId === playerQueue[i].assetId) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  getAssetPlayer(assetId) {\n    const index = this.getAssetPlayerQueueIndex(assetId);\n    return this.playerQueue[index] || null;\n  }\n  getBufferingPlayer() {\n    const {\n      playerQueue,\n      primaryMedia\n    } = this;\n    if (primaryMedia) {\n      for (let i = 0; i < playerQueue.length; i++) {\n        if (playerQueue[i].media === primaryMedia) {\n          return playerQueue[i];\n        }\n      }\n    }\n    return null;\n  }\n  createAsset(interstitial, assetListIndex, startOffset, timelineStart, duration, uri) {\n    const assetItem = {\n      parentIdentifier: interstitial.identifier,\n      identifier: generateAssetIdentifier(interstitial, uri, assetListIndex),\n      duration,\n      startOffset,\n      timelineStart,\n      uri\n    };\n    return this.createAssetPlayer(interstitial, assetItem, assetListIndex);\n  }\n  createAssetPlayer(interstitial, assetItem, assetListIndex) {\n    const primary = this.hls;\n    const userConfig = primary.userConfig;\n    let videoPreference = userConfig.videoPreference;\n    const currentLevel = primary.loadLevelObj || primary.levels[primary.currentLevel];\n    if (videoPreference || currentLevel) {\n      videoPreference = _extends({}, videoPreference);\n      if (currentLevel.videoCodec) {\n        videoPreference.videoCodec = currentLevel.videoCodec;\n      }\n      if (currentLevel.videoRange) {\n        videoPreference.allowedVideoRanges = [currentLevel.videoRange];\n      }\n    }\n    const selectedAudio = primary.audioTracks[primary.audioTrack];\n    const selectedSubtitle = primary.subtitleTracks[primary.subtitleTrack];\n    let startPosition = 0;\n    if (this.primaryLive || interstitial.appendInPlace) {\n      const timePastStart = this.timelinePos - assetItem.timelineStart;\n      if (timePastStart > 1) {\n        const duration = assetItem.duration;\n        if (duration && timePastStart < duration) {\n          startPosition = timePastStart;\n        }\n      }\n    }\n    const assetId = assetItem.identifier;\n    const playerConfig = _objectSpread2(_objectSpread2({}, userConfig), {}, {\n      autoStartLoad: true,\n      startFragPrefetch: true,\n      primarySessionId: primary.sessionId,\n      assetPlayerId: assetId,\n      abrEwmaDefaultEstimate: primary.bandwidthEstimate,\n      interstitialsController: undefined,\n      startPosition,\n      liveDurationInfinity: false,\n      testBandwidth: false,\n      videoPreference,\n      audioPreference: selectedAudio || userConfig.audioPreference,\n      subtitlePreference: selectedSubtitle || userConfig.subtitlePreference\n    });\n    if (interstitial.appendInPlace) {\n      interstitial.appendInPlaceStarted = true;\n      if (assetItem.timelineStart) {\n        playerConfig.timelineOffset = assetItem.timelineStart;\n      }\n    }\n    const cmcd = playerConfig.cmcd;\n    if (cmcd != null && cmcd.sessionId && cmcd.contentId) {\n      playerConfig.cmcd = _extends({}, cmcd, {\n        contentId: hash(assetItem.uri)\n      });\n    }\n    if (this.getAssetPlayer(assetId)) {\n      this.warn(`Duplicate date range identifier ${interstitial} and asset ${assetId}`);\n    }\n    const player = new HlsAssetPlayer(this.HlsPlayerClass, playerConfig, interstitial, assetItem);\n    this.playerQueue.push(player);\n    interstitial.assetList[assetListIndex] = assetItem;\n    // Listen for LevelDetails and PTS change to update duration\n    const updateAssetPlayerDetails = details => {\n      if (details.live) {\n        const error = new Error(`Interstitials MUST be VOD assets ${interstitial}`);\n        const errorData = {\n          fatal: true,\n          type: ErrorTypes.OTHER_ERROR,\n          details: ErrorDetails.INTERSTITIAL_ASSET_ITEM_ERROR,\n          error\n        };\n        this.handleAssetItemError(errorData, interstitial, this.schedule.findEventIndex(interstitial.identifier), assetListIndex, error.message);\n        return;\n      }\n      // Get time at end of last fragment\n      const duration = details.edge - details.fragmentStart;\n      const currentAssetDuration = assetItem.duration;\n      if (currentAssetDuration === null || duration > currentAssetDuration) {\n        this.log(`Interstitial asset \"${assetId}\" duration change ${currentAssetDuration} > ${duration}`);\n        assetItem.duration = duration;\n        // Update schedule with new event and asset duration\n        this.updateSchedule();\n      }\n    };\n    player.on(Events.LEVEL_UPDATED, (event, {\n      details\n    }) => updateAssetPlayerDetails(details));\n    player.on(Events.LEVEL_PTS_UPDATED, (event, {\n      details\n    }) => updateAssetPlayerDetails(details));\n    const onBufferCodecs = (event, data) => {\n      const inQueuPlayer = this.getAssetPlayer(assetId);\n      if (inQueuPlayer && data.tracks) {\n        inQueuPlayer.off(Events.BUFFER_CODECS, onBufferCodecs);\n        inQueuPlayer.tracks = data.tracks;\n        const media = this.primaryMedia;\n        if (this.bufferingAsset === inQueuPlayer.assetItem && media && !inQueuPlayer.media) {\n          this.bufferAssetPlayer(inQueuPlayer, media);\n        }\n      }\n    };\n    player.on(Events.BUFFER_CODECS, onBufferCodecs);\n    const bufferedToEnd = () => {\n      var _this$schedule$items2;\n      const inQueuPlayer = this.getAssetPlayer(assetId);\n      this.log(`buffered to end of asset ${inQueuPlayer}`);\n      if (!inQueuPlayer) {\n        return;\n      }\n      // Preload at end of asset\n      const scheduleIndex = this.schedule.findEventIndex(interstitial.identifier);\n      const item = (_this$schedule$items2 = this.schedule.items) == null ? void 0 : _this$schedule$items2[scheduleIndex];\n      if (this.isInterstitial(item)) {\n        const assetListIndex = interstitial.findAssetIndex(assetItem);\n        const nextAssetIndex = getNextAssetIndex(interstitial, assetListIndex);\n        if (!interstitial.isAssetPastPlayoutLimit(nextAssetIndex)) {\n          this.bufferedToItem(item, nextAssetIndex);\n        } else {\n          var _this$schedule$items3;\n          const nextItem = (_this$schedule$items3 = this.schedule.items) == null ? void 0 : _this$schedule$items3[scheduleIndex + 1];\n          if (nextItem) {\n            this.bufferedToItem(nextItem);\n          }\n        }\n      }\n    };\n    player.on(Events.BUFFERED_TO_END, bufferedToEnd);\n    const endedWithAssetIndex = assetIndex => {\n      return () => {\n        const inQueuPlayer = this.getAssetPlayer(assetId);\n        if (!inQueuPlayer) {\n          return;\n        }\n        this.shouldPlay = true;\n        const scheduleIndex = this.schedule.findEventIndex(interstitial.identifier);\n        this.advanceAfterAssetEnded(interstitial, scheduleIndex, assetIndex);\n      };\n    };\n    player.once(Events.MEDIA_ENDED, endedWithAssetIndex(assetListIndex));\n    player.once(Events.PLAYOUT_LIMIT_REACHED, endedWithAssetIndex(Infinity));\n    player.on(Events.ERROR, (event, data) => {\n      const inQueuPlayer = this.getAssetPlayer(assetId);\n      if (data.details === ErrorDetails.BUFFER_STALLED_ERROR) {\n        if (inQueuPlayer != null && inQueuPlayer.media) {\n          const assetCurrentTime = inQueuPlayer.currentTime;\n          const distanceFromEnd = inQueuPlayer.duration - assetCurrentTime;\n          if (assetCurrentTime && interstitial.appendInPlace && distanceFromEnd / inQueuPlayer.media.playbackRate < 0.5) {\n            this.log(`Advancing buffer past end of asset ${assetId} ${interstitial} at ${inQueuPlayer.media.currentTime}`);\n            bufferedToEnd();\n          } else {\n            this.warn(`Stalled at ${assetCurrentTime} of ${assetCurrentTime + distanceFromEnd} in asset ${assetId} ${interstitial}`);\n            this.onTimeupdate();\n            this.checkBuffer(true);\n          }\n        }\n        return;\n      }\n      this.handleAssetItemError(data, interstitial, this.schedule.findEventIndex(interstitial.identifier), assetListIndex, `Asset player error ${data.error} ${interstitial}`);\n    });\n    player.on(Events.DESTROYING, () => {\n      const inQueuPlayer = this.getAssetPlayer(assetId);\n      if (!inQueuPlayer) {\n        return;\n      }\n      const error = new Error(`Asset player destroyed unexpectedly ${assetId}`);\n      const errorData = {\n        fatal: true,\n        type: ErrorTypes.OTHER_ERROR,\n        details: ErrorDetails.INTERSTITIAL_ASSET_ITEM_ERROR,\n        error\n      };\n      this.handleAssetItemError(errorData, interstitial, this.schedule.findEventIndex(interstitial.identifier), assetListIndex, error.message);\n    });\n    this.log(`INTERSTITIAL_ASSET_PLAYER_CREATED ${eventAssetToString(assetItem)}`);\n    this.hls.trigger(Events.INTERSTITIAL_ASSET_PLAYER_CREATED, {\n      asset: assetItem,\n      assetListIndex,\n      event: interstitial,\n      player\n    });\n    return player;\n  }\n  clearInterstitial(interstitial, toSegment) {\n    interstitial.assetList.forEach(asset => {\n      this.clearAssetPlayer(asset.identifier, toSegment);\n    });\n    // Remove asset list and resolved duration\n    interstitial.reset();\n  }\n  resetAssetPlayer(assetId) {\n    // Reset asset player so that it's timeline can be adjusted without reloading the MVP\n    const playerIndex = this.getAssetPlayerQueueIndex(assetId);\n    if (playerIndex !== -1) {\n      this.log(`reset asset player \"${assetId}\" after error`);\n      const player = this.playerQueue[playerIndex];\n      this.transferMediaFromPlayer(player, null);\n      player.resetDetails();\n    }\n  }\n  clearAssetPlayer(assetId, toSegment) {\n    const playerIndex = this.getAssetPlayerQueueIndex(assetId);\n    if (playerIndex !== -1) {\n      this.log(`clear asset player \"${assetId}\" toSegment: ${toSegment ? segmentToString(toSegment) : toSegment}`);\n      const player = this.playerQueue[playerIndex];\n      this.transferMediaFromPlayer(player, toSegment);\n      this.playerQueue.splice(playerIndex, 1);\n      player.destroy();\n    }\n  }\n  emptyPlayerQueue() {\n    let player;\n    while (player = this.playerQueue.pop()) {\n      player.destroy();\n    }\n    this.playerQueue = [];\n  }\n  startAssetPlayer(player, assetListIndex, scheduleItems, scheduleIndex, media) {\n    const {\n      interstitial,\n      assetItem,\n      assetId\n    } = player;\n    const assetListLength = interstitial.assetList.length;\n    const playingAsset = this.playingAsset;\n    this.endedAsset = null;\n    this.playingAsset = assetItem;\n    if (!playingAsset || playingAsset.identifier !== assetId) {\n      if (playingAsset) {\n        // Exiting another Interstitial asset\n        this.clearAssetPlayer(playingAsset.identifier, scheduleItems[scheduleIndex]);\n        delete playingAsset.error;\n      }\n      this.log(`INTERSTITIAL_ASSET_STARTED ${assetListIndex + 1}/${assetListLength} ${eventAssetToString(assetItem)}`);\n      this.hls.trigger(Events.INTERSTITIAL_ASSET_STARTED, {\n        asset: assetItem,\n        assetListIndex,\n        event: interstitial,\n        schedule: scheduleItems.slice(0),\n        scheduleIndex,\n        player\n      });\n    }\n\n    // detach media and attach to interstitial player if it does not have another element attached\n    this.bufferAssetPlayer(player, media);\n  }\n  bufferAssetPlayer(player, media) {\n    var _this$schedule$items4, _this$detachedData5;\n    const {\n      interstitial,\n      assetItem\n    } = player;\n    const scheduleIndex = this.schedule.findEventIndex(interstitial.identifier);\n    const item = (_this$schedule$items4 = this.schedule.items) == null ? void 0 : _this$schedule$items4[scheduleIndex];\n    if (!item) {\n      return;\n    }\n    this.setBufferingItem(item);\n    this.bufferingAsset = assetItem;\n    const bufferingPlayer = this.getBufferingPlayer();\n    if (bufferingPlayer === player) {\n      return;\n    }\n    const appendInPlaceNext = interstitial.appendInPlace;\n    if (appendInPlaceNext && (bufferingPlayer == null ? void 0 : bufferingPlayer.interstitial.appendInPlace) === false) {\n      // Media is detached and not available to append in place\n      return;\n    }\n    const activeTracks = (bufferingPlayer == null ? void 0 : bufferingPlayer.tracks) || ((_this$detachedData5 = this.detachedData) == null ? void 0 : _this$detachedData5.tracks) || this.requiredTracks;\n    if (appendInPlaceNext && assetItem !== this.playingAsset) {\n      // Do not buffer another item if tracks are unknown or incompatible\n      if (!player.tracks) {\n        return;\n      }\n      if (activeTracks && !isCompatibleTrackChange(activeTracks, player.tracks)) {\n        const error = new Error(`Asset ${eventAssetToString(assetItem)} SourceBuffer tracks ('${Object.keys(player.tracks)}') are not compatible with primary content tracks ('${Object.keys(activeTracks)}')`);\n        const errorData = {\n          fatal: true,\n          type: ErrorTypes.OTHER_ERROR,\n          details: ErrorDetails.INTERSTITIAL_ASSET_ITEM_ERROR,\n          error\n        };\n        const assetListIndex = interstitial.findAssetIndex(assetItem);\n        this.handleAssetItemError(errorData, interstitial, scheduleIndex, assetListIndex, error.message);\n        return;\n      }\n    }\n    this.transferMediaTo(player, media);\n  }\n  handleAssetItemError(data, interstitial, scheduleIndex, assetListIndex, errorMessage) {\n    if (data.details === ErrorDetails.BUFFER_STALLED_ERROR) {\n      return;\n    }\n    const assetItem = interstitial.assetList[assetListIndex];\n    this.warn(`INTERSTITIAL_ASSET_ERROR ${assetItem ? eventAssetToString(assetItem) : assetItem} ${data.error}`);\n    const assetId = assetItem == null ? void 0 : assetItem.identifier;\n    const playerIndex = this.getAssetPlayerQueueIndex(assetId);\n    const player = this.playerQueue[playerIndex] || null;\n    const items = this.schedule.items;\n    const interstitialAssetError = _extends({}, data, {\n      fatal: false,\n      errorAction: createDoNothingErrorAction(true),\n      asset: assetItem,\n      assetListIndex,\n      event: interstitial,\n      schedule: items,\n      scheduleIndex,\n      player\n    });\n    this.hls.trigger(Events.INTERSTITIAL_ASSET_ERROR, interstitialAssetError);\n    if (!data.fatal) {\n      return;\n    }\n    const playingAsset = this.playingAsset;\n    const error = new Error(errorMessage);\n    if (assetItem) {\n      this.clearAssetPlayer(assetId, null);\n      assetItem.error = error;\n    }\n\n    // If all assets in interstitial fail, mark the interstitial with an error\n    if (!interstitial.assetList.some(asset => !asset.error)) {\n      interstitial.error = error;\n    } else {\n      // Reset level details and reload/parse media playlists to align with updated schedule\n      for (let i = assetListIndex; i < interstitial.assetList.length; i++) {\n        this.resetAssetPlayer(interstitial.assetList[i].identifier);\n      }\n      this.updateSchedule();\n    }\n    if (interstitial.error) {\n      this.primaryFallback(interstitial);\n    } else if (playingAsset && playingAsset.identifier === assetId) {\n      this.advanceAfterAssetEnded(interstitial, scheduleIndex, assetListIndex);\n    }\n  }\n  primaryFallback(interstitial) {\n    // Fallback to Primary by on current or future events by updating schedule to skip errored interstitials/assets\n    const flushStart = interstitial.timelineStart;\n    const playingItem = this.effectivePlayingItem;\n    // Update schedule now that interstitial/assets are flagged with `error` for fallback\n    this.updateSchedule();\n    if (playingItem) {\n      this.log(`Fallback to primary from event \"${interstitial.identifier}\" start: ${flushStart} pos: ${this.timelinePos} playing: ${playingItem ? segmentToString(playingItem) : '<none>'} error: ${interstitial.error}`);\n      let timelinePos = this.timelinePos;\n      if (timelinePos === -1) {\n        timelinePos = this.hls.startPosition;\n      }\n      const newPlayingItem = this.updateItem(playingItem, timelinePos);\n      if (this.itemsMatch(playingItem, newPlayingItem)) {\n        this.clearInterstitial(interstitial, null);\n      }\n      if (interstitial.appendInPlace) {\n        this.attachPrimary(flushStart, null);\n        this.flushFrontBuffer(flushStart);\n      }\n      const scheduleIndex = this.schedule.findItemIndexAtTime(timelinePos);\n      this.setSchedulePosition(scheduleIndex);\n    } else {\n      this.checkStart();\n    }\n  }\n\n  // Asset List loading\n  onAssetListLoaded(event, data) {\n    var _this$bufferingItem2;\n    const interstitial = data.event;\n    const interstitialId = interstitial.identifier;\n    const assets = data.assetListResponse.ASSETS;\n    if (!this.schedule.hasEvent(interstitialId)) {\n      // Interstitial with id was removed\n      return;\n    }\n    const eventStart = interstitial.timelineStart;\n    const previousDuration = interstitial.duration;\n    let sumDuration = 0;\n    assets.forEach((asset, assetListIndex) => {\n      const duration = parseFloat(asset.DURATION);\n      this.createAsset(interstitial, assetListIndex, sumDuration, eventStart + sumDuration, duration, asset.URI);\n      sumDuration += duration;\n    });\n    interstitial.duration = sumDuration;\n    this.log(`Loaded asset-list with duration: ${sumDuration} (was: ${previousDuration}) ${interstitial}`);\n    const waitingItem = this.waitingItem;\n    const waitingForItem = (waitingItem == null ? void 0 : waitingItem.event.identifier) === interstitialId;\n\n    // Update schedule now that asset.DURATION(s) are parsed\n    this.updateSchedule();\n    const bufferingEvent = (_this$bufferingItem2 = this.bufferingItem) == null ? void 0 : _this$bufferingItem2.event;\n\n    // If buffer reached Interstitial, start buffering first asset\n    if (waitingForItem) {\n      var _this$schedule$items5;\n      // Advance schedule when waiting for asset list data to play\n      const scheduleIndex = this.schedule.findEventIndex(interstitialId);\n      const item = (_this$schedule$items5 = this.schedule.items) == null ? void 0 : _this$schedule$items5[scheduleIndex];\n      if (item) {\n        if (!this.playingItem && this.timelinePos > item.end) {\n          // Abandon if new duration is reduced enough to land playback in primary start\n          const index = this.schedule.findItemIndexAtTime(this.timelinePos);\n          if (index !== scheduleIndex) {\n            interstitial.error = new Error(`Interstitial no longer within playback range ${this.timelinePos} ${interstitial}`);\n            this.primaryFallback(interstitial);\n            return;\n          }\n        }\n        this.setBufferingItem(item);\n      }\n      this.setSchedulePosition(scheduleIndex);\n    } else if ((bufferingEvent == null ? void 0 : bufferingEvent.identifier) === interstitialId && bufferingEvent.appendInPlace) {\n      // If buffering (but not playback) has reached this item transfer media-source\n      const assetItem = interstitial.assetList[0];\n      const player = this.getAssetPlayer(assetItem.identifier);\n      const media = this.primaryMedia;\n      if (assetItem && player && media) {\n        this.bufferAssetPlayer(player, media);\n      }\n    }\n  }\n  onError(event, data) {\n    switch (data.details) {\n      case ErrorDetails.ASSET_LIST_PARSING_ERROR:\n      case ErrorDetails.ASSET_LIST_LOAD_ERROR:\n      case ErrorDetails.ASSET_LIST_LOAD_TIMEOUT:\n        {\n          const interstitial = data.interstitial;\n          if (interstitial) {\n            this.primaryFallback(interstitial);\n          }\n          break;\n        }\n      case ErrorDetails.BUFFER_STALLED_ERROR:\n        {\n          this.onTimeupdate();\n          this.checkBuffer(true);\n          break;\n        }\n    }\n  }\n}\n\nconst TICK_INTERVAL$2 = 500; // how often to tick in ms\n\nclass SubtitleStreamController extends BaseStreamController {\n  constructor(hls, fragmentTracker, keyLoader) {\n    super(hls, fragmentTracker, keyLoader, 'subtitle-stream-controller', PlaylistLevelType.SUBTITLE);\n    this.currentTrackId = -1;\n    this.tracksBuffered = [];\n    this.mainDetails = null;\n    this.registerListeners();\n  }\n  onHandlerDestroying() {\n    this.unregisterListeners();\n    super.onHandlerDestroying();\n    this.mainDetails = null;\n  }\n  registerListeners() {\n    super.registerListeners();\n    const {\n      hls\n    } = this;\n    hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n    hls.on(Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);\n    hls.on(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n    hls.on(Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);\n    hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n  }\n  unregisterListeners() {\n    super.unregisterListeners();\n    const {\n      hls\n    } = this;\n    hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n    hls.off(Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);\n    hls.off(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n    hls.off(Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);\n    hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n  }\n  startLoad(startPosition, skipSeekToStartPosition) {\n    this.stopLoad();\n    this.state = State.IDLE;\n    this.setInterval(TICK_INTERVAL$2);\n    this.nextLoadPosition = this.lastCurrentTime = startPosition + this.timelineOffset;\n    this.startPosition = skipSeekToStartPosition ? -1 : startPosition;\n    this.tick();\n  }\n  onManifestLoading() {\n    super.onManifestLoading();\n    this.mainDetails = null;\n  }\n  onMediaDetaching(event, data) {\n    this.tracksBuffered = [];\n    super.onMediaDetaching(event, data);\n  }\n  onLevelLoaded(event, data) {\n    this.mainDetails = data.details;\n  }\n  onSubtitleFragProcessed(event, data) {\n    const {\n      frag,\n      success\n    } = data;\n    if (!this.fragContextChanged(frag)) {\n      if (isMediaFragment(frag)) {\n        this.fragPrevious = frag;\n      }\n      this.state = State.IDLE;\n    }\n    if (!success) {\n      return;\n    }\n    const buffered = this.tracksBuffered[this.currentTrackId];\n    if (!buffered) {\n      return;\n    }\n\n    // Create/update a buffered array matching the interface used by BufferHelper.bufferedInfo\n    // so we can re-use the logic used to detect how much has been buffered\n    let timeRange;\n    const fragStart = frag.start;\n    for (let i = 0; i < buffered.length; i++) {\n      if (fragStart >= buffered[i].start && fragStart <= buffered[i].end) {\n        timeRange = buffered[i];\n        break;\n      }\n    }\n    const fragEnd = frag.start + frag.duration;\n    if (timeRange) {\n      timeRange.end = fragEnd;\n    } else {\n      timeRange = {\n        start: fragStart,\n        end: fragEnd\n      };\n      buffered.push(timeRange);\n    }\n    this.fragmentTracker.fragBuffered(frag);\n    this.fragBufferedComplete(frag, null);\n    if (this.media) {\n      this.tick();\n    }\n  }\n  onBufferFlushing(event, data) {\n    const {\n      startOffset,\n      endOffset\n    } = data;\n    if (startOffset === 0 && endOffset !== Number.POSITIVE_INFINITY) {\n      const endOffsetSubtitles = endOffset - 1;\n      if (endOffsetSubtitles <= 0) {\n        return;\n      }\n      data.endOffsetSubtitles = Math.max(0, endOffsetSubtitles);\n      this.tracksBuffered.forEach(buffered => {\n        for (let i = 0; i < buffered.length;) {\n          if (buffered[i].end <= endOffsetSubtitles) {\n            buffered.shift();\n            continue;\n          } else if (buffered[i].start < endOffsetSubtitles) {\n            buffered[i].start = endOffsetSubtitles;\n          } else {\n            break;\n          }\n          i++;\n        }\n      });\n      this.fragmentTracker.removeFragmentsInRange(startOffset, endOffsetSubtitles, PlaylistLevelType.SUBTITLE);\n    }\n  }\n\n  // If something goes wrong, proceed to next frag, if we were processing one.\n  onError(event, data) {\n    const frag = data.frag;\n    if ((frag == null ? void 0 : frag.type) === PlaylistLevelType.SUBTITLE) {\n      if (data.details === ErrorDetails.FRAG_GAP) {\n        this.fragmentTracker.fragBuffered(frag, true);\n      }\n      if (this.fragCurrent) {\n        this.fragCurrent.abortRequests();\n      }\n      if (this.state !== State.STOPPED) {\n        this.state = State.IDLE;\n      }\n    }\n  }\n\n  // Got all new subtitle levels.\n  onSubtitleTracksUpdated(event, {\n    subtitleTracks\n  }) {\n    if (this.levels && subtitleOptionsIdentical(this.levels, subtitleTracks)) {\n      this.levels = subtitleTracks.map(mediaPlaylist => new Level(mediaPlaylist));\n      return;\n    }\n    this.tracksBuffered = [];\n    this.levels = subtitleTracks.map(mediaPlaylist => {\n      const level = new Level(mediaPlaylist);\n      this.tracksBuffered[level.id] = [];\n      return level;\n    });\n    this.fragmentTracker.removeFragmentsInRange(0, Number.POSITIVE_INFINITY, PlaylistLevelType.SUBTITLE);\n    this.fragPrevious = null;\n    this.mediaBuffer = null;\n  }\n  onSubtitleTrackSwitch(event, data) {\n    var _this$levels;\n    this.currentTrackId = data.id;\n    if (!((_this$levels = this.levels) != null && _this$levels.length) || this.currentTrackId === -1) {\n      this.clearInterval();\n      return;\n    }\n\n    // Check if track has the necessary details to load fragments\n    const currentTrack = this.levels[this.currentTrackId];\n    if (currentTrack != null && currentTrack.details) {\n      this.mediaBuffer = this.mediaBufferTimeRanges;\n    } else {\n      this.mediaBuffer = null;\n    }\n    if (currentTrack && this.state !== State.STOPPED) {\n      this.setInterval(TICK_INTERVAL$2);\n    }\n  }\n\n  // Got a new set of subtitle fragments.\n  onSubtitleTrackLoaded(event, data) {\n    var _track$details;\n    const {\n      currentTrackId,\n      levels\n    } = this;\n    const {\n      details: newDetails,\n      id: trackId\n    } = data;\n    if (!levels) {\n      this.warn(`Subtitle tracks were reset while loading level ${trackId}`);\n      return;\n    }\n    const track = levels[trackId];\n    if (trackId >= levels.length || !track) {\n      return;\n    }\n    this.log(`Subtitle track ${trackId} loaded [${newDetails.startSN},${newDetails.endSN}]${newDetails.lastPartSn ? `[part-${newDetails.lastPartSn}-${newDetails.lastPartIndex}]` : ''},duration:${newDetails.totalduration}`);\n    this.mediaBuffer = this.mediaBufferTimeRanges;\n    let sliding = 0;\n    if (newDetails.live || (_track$details = track.details) != null && _track$details.live) {\n      if (newDetails.deltaUpdateFailed) {\n        return;\n      }\n      const mainDetails = this.mainDetails;\n      if (!mainDetails) {\n        this.startFragRequested = false;\n        return;\n      }\n      const mainSlidingStartFragment = mainDetails.fragments[0];\n      if (!track.details) {\n        if (newDetails.hasProgramDateTime && mainDetails.hasProgramDateTime) {\n          alignMediaPlaylistByPDT(newDetails, mainDetails);\n          sliding = newDetails.fragmentStart;\n        } else if (mainSlidingStartFragment) {\n          // line up live playlist with main so that fragments in range are loaded\n          sliding = mainSlidingStartFragment.start;\n          addSliding(newDetails, sliding);\n        }\n      } else {\n        var _this$levelLastLoaded;\n        sliding = this.alignPlaylists(newDetails, track.details, (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details);\n        if (sliding === 0 && mainSlidingStartFragment) {\n          // realign with main when there is no overlap with last refresh\n          sliding = mainSlidingStartFragment.start;\n          addSliding(newDetails, sliding);\n        }\n      }\n      // compute start position if we are aligned with the main playlist\n      if (mainDetails && !this.startFragRequested) {\n        this.setStartPosition(mainDetails, sliding);\n      }\n    }\n    track.details = newDetails;\n    this.levelLastLoaded = track;\n    if (trackId !== currentTrackId) {\n      return;\n    }\n    this.hls.trigger(Events.SUBTITLE_TRACK_UPDATED, {\n      details: newDetails,\n      id: trackId,\n      groupId: data.groupId\n    });\n\n    // trigger handler right now\n    this.tick();\n\n    // If playlist is misaligned because of bad PDT or drift, delete details to resync with main on reload\n    if (newDetails.live && !this.fragCurrent && this.media && this.state === State.IDLE) {\n      const foundFrag = findFragmentByPTS(null, newDetails.fragments, this.media.currentTime, 0);\n      if (!foundFrag) {\n        this.warn('Subtitle playlist not aligned with playback');\n        track.details = undefined;\n      }\n    }\n  }\n  _handleFragmentLoadComplete(fragLoadedData) {\n    const {\n      frag,\n      payload\n    } = fragLoadedData;\n    const decryptData = frag.decryptdata;\n    const hls = this.hls;\n    if (this.fragContextChanged(frag)) {\n      return;\n    }\n    // check to see if the payload needs to be decrypted\n    if (payload && payload.byteLength > 0 && decryptData != null && decryptData.key && decryptData.iv && isFullSegmentEncryption(decryptData.method)) {\n      const startTime = performance.now();\n      // decrypt the subtitles\n      this.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer, getAesModeFromFullSegmentMethod(decryptData.method)).catch(err => {\n        hls.trigger(Events.ERROR, {\n          type: ErrorTypes.MEDIA_ERROR,\n          details: ErrorDetails.FRAG_DECRYPT_ERROR,\n          fatal: false,\n          error: err,\n          reason: err.message,\n          frag\n        });\n        throw err;\n      }).then(decryptedData => {\n        const endTime = performance.now();\n        hls.trigger(Events.FRAG_DECRYPTED, {\n          frag,\n          payload: decryptedData,\n          stats: {\n            tstart: startTime,\n            tdecrypt: endTime\n          }\n        });\n      }).catch(err => {\n        this.warn(`${err.name}: ${err.message}`);\n        this.state = State.IDLE;\n      });\n    }\n  }\n  doTick() {\n    if (!this.media) {\n      this.state = State.IDLE;\n      return;\n    }\n    if (this.state === State.IDLE) {\n      const {\n        currentTrackId,\n        levels\n      } = this;\n      const track = levels == null ? void 0 : levels[currentTrackId];\n      if (!track || !levels.length || !track.details) {\n        return;\n      }\n      if (this.waitForLive(track)) {\n        return;\n      }\n      const {\n        config\n      } = this;\n      const currentTime = this.getLoadPosition();\n      const bufferedInfo = BufferHelper.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], currentTime, config.maxBufferHole);\n      const {\n        end: targetBufferTime,\n        len: bufferLen\n      } = bufferedInfo;\n      const trackDetails = track.details;\n      const maxBufLen = this.hls.maxBufferLength + trackDetails.levelTargetDuration;\n      if (bufferLen > maxBufLen) {\n        return;\n      }\n      const fragments = trackDetails.fragments;\n      const fragLen = fragments.length;\n      const end = trackDetails.edge;\n      let foundFrag = null;\n      const fragPrevious = this.fragPrevious;\n      if (targetBufferTime < end) {\n        const tolerance = config.maxFragLookUpTolerance;\n        const lookupTolerance = targetBufferTime > end - tolerance ? 0 : tolerance;\n        foundFrag = findFragmentByPTS(fragPrevious, fragments, Math.max(fragments[0].start, targetBufferTime), lookupTolerance);\n        if (!foundFrag && fragPrevious && fragPrevious.start < fragments[0].start) {\n          foundFrag = fragments[0];\n        }\n      } else {\n        foundFrag = fragments[fragLen - 1];\n      }\n      foundFrag = this.filterReplacedPrimary(foundFrag, track.details);\n      if (!foundFrag) {\n        return;\n      }\n      // Load earlier fragment in same discontinuity to make up for misaligned playlists and cues that extend beyond end of segment\n      const curSNIdx = foundFrag.sn - trackDetails.startSN;\n      const prevFrag = fragments[curSNIdx - 1];\n      if (prevFrag && prevFrag.cc === foundFrag.cc && this.fragmentTracker.getState(prevFrag) === FragmentState.NOT_LOADED) {\n        foundFrag = prevFrag;\n      }\n      if (this.fragmentTracker.getState(foundFrag) === FragmentState.NOT_LOADED) {\n        // only load if fragment is not loaded\n        const fragToLoad = this.mapToInitFragWhenRequired(foundFrag);\n        if (fragToLoad) {\n          this.loadFragment(fragToLoad, track, targetBufferTime);\n        }\n      }\n    }\n  }\n  loadFragment(frag, level, targetBufferTime) {\n    if (!isMediaFragment(frag)) {\n      this._loadInitSegment(frag, level);\n    } else {\n      super.loadFragment(frag, level, targetBufferTime);\n    }\n  }\n  get mediaBufferTimeRanges() {\n    return new BufferableInstance(this.tracksBuffered[this.currentTrackId] || []);\n  }\n}\nclass BufferableInstance {\n  constructor(timeranges) {\n    this.buffered = void 0;\n    const getRange = (name, index, length) => {\n      index = index >>> 0;\n      if (index > length - 1) {\n        throw new DOMException(`Failed to execute '${name}' on 'TimeRanges': The index provided (${index}) is greater than the maximum bound (${length})`);\n      }\n      return timeranges[index][name];\n    };\n    this.buffered = {\n      get length() {\n        return timeranges.length;\n      },\n      end(index) {\n        return getRange('end', index, timeranges.length);\n      },\n      start(index) {\n        return getRange('start', index, timeranges.length);\n      }\n    };\n  }\n}\n\n/**\n *\n * This code was ported from the dash.js project at:\n *   https://github.com/Dash-Industry-Forum/dash.js/blob/development/externals/cea608-parser.js\n *   https://github.com/Dash-Industry-Forum/dash.js/commit/8269b26a761e0853bb21d78780ed945144ecdd4d#diff-71bc295a2d6b6b7093a1d3290d53a4b2\n *\n * The original copyright appears below:\n *\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2015-2016, DASH Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  1. Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  2. Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n/**\n *  Exceptions from regular ASCII. CodePoints are mapped to UTF-16 codes\n */\n\nconst specialCea608CharsCodes = {\n  0x2a: 0xe1,\n  // lowercase a, acute accent\n  0x5c: 0xe9,\n  // lowercase e, acute accent\n  0x5e: 0xed,\n  // lowercase i, acute accent\n  0x5f: 0xf3,\n  // lowercase o, acute accent\n  0x60: 0xfa,\n  // lowercase u, acute accent\n  0x7b: 0xe7,\n  // lowercase c with cedilla\n  0x7c: 0xf7,\n  // division symbol\n  0x7d: 0xd1,\n  // uppercase N tilde\n  0x7e: 0xf1,\n  // lowercase n tilde\n  0x7f: 0x2588,\n  // Full block\n  // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n  // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F\n  // THIS MEANS THAT \\x50 MUST BE ADDED TO THE VALUES\n  0x80: 0xae,\n  // Registered symbol (R)\n  0x81: 0xb0,\n  // degree sign\n  0x82: 0xbd,\n  // 1/2 symbol\n  0x83: 0xbf,\n  // Inverted (open) question mark\n  0x84: 0x2122,\n  // Trademark symbol (TM)\n  0x85: 0xa2,\n  // Cents symbol\n  0x86: 0xa3,\n  // Pounds sterling\n  0x87: 0x266a,\n  // Music 8'th note\n  0x88: 0xe0,\n  // lowercase a, grave accent\n  0x89: 0x20,\n  // transparent space (regular)\n  0x8a: 0xe8,\n  // lowercase e, grave accent\n  0x8b: 0xe2,\n  // lowercase a, circumflex accent\n  0x8c: 0xea,\n  // lowercase e, circumflex accent\n  0x8d: 0xee,\n  // lowercase i, circumflex accent\n  0x8e: 0xf4,\n  // lowercase o, circumflex accent\n  0x8f: 0xfb,\n  // lowercase u, circumflex accent\n  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n  // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F\n  0x90: 0xc1,\n  // capital letter A with acute\n  0x91: 0xc9,\n  // capital letter E with acute\n  0x92: 0xd3,\n  // capital letter O with acute\n  0x93: 0xda,\n  // capital letter U with acute\n  0x94: 0xdc,\n  // capital letter U with diaresis\n  0x95: 0xfc,\n  // lowercase letter U with diaeresis\n  0x96: 0x2018,\n  // opening single quote\n  0x97: 0xa1,\n  // inverted exclamation mark\n  0x98: 0x2a,\n  // asterisk\n  0x99: 0x2019,\n  // closing single quote\n  0x9a: 0x2501,\n  // box drawings heavy horizontal\n  0x9b: 0xa9,\n  // copyright sign\n  0x9c: 0x2120,\n  // Service mark\n  0x9d: 0x2022,\n  // (round) bullet\n  0x9e: 0x201c,\n  // Left double quotation mark\n  0x9f: 0x201d,\n  // Right double quotation mark\n  0xa0: 0xc0,\n  // uppercase A, grave accent\n  0xa1: 0xc2,\n  // uppercase A, circumflex\n  0xa2: 0xc7,\n  // uppercase C with cedilla\n  0xa3: 0xc8,\n  // uppercase E, grave accent\n  0xa4: 0xca,\n  // uppercase E, circumflex\n  0xa5: 0xcb,\n  // capital letter E with diaresis\n  0xa6: 0xeb,\n  // lowercase letter e with diaresis\n  0xa7: 0xce,\n  // uppercase I, circumflex\n  0xa8: 0xcf,\n  // uppercase I, with diaresis\n  0xa9: 0xef,\n  // lowercase i, with diaresis\n  0xaa: 0xd4,\n  // uppercase O, circumflex\n  0xab: 0xd9,\n  // uppercase U, grave accent\n  0xac: 0xf9,\n  // lowercase u, grave accent\n  0xad: 0xdb,\n  // uppercase U, circumflex\n  0xae: 0xab,\n  // left-pointing double angle quotation mark\n  0xaf: 0xbb,\n  // right-pointing double angle quotation mark\n  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n  // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F\n  0xb0: 0xc3,\n  // Uppercase A, tilde\n  0xb1: 0xe3,\n  // Lowercase a, tilde\n  0xb2: 0xcd,\n  // Uppercase I, acute accent\n  0xb3: 0xcc,\n  // Uppercase I, grave accent\n  0xb4: 0xec,\n  // Lowercase i, grave accent\n  0xb5: 0xd2,\n  // Uppercase O, grave accent\n  0xb6: 0xf2,\n  // Lowercase o, grave accent\n  0xb7: 0xd5,\n  // Uppercase O, tilde\n  0xb8: 0xf5,\n  // Lowercase o, tilde\n  0xb9: 0x7b,\n  // Open curly brace\n  0xba: 0x7d,\n  // Closing curly brace\n  0xbb: 0x5c,\n  // Backslash\n  0xbc: 0x5e,\n  // Caret\n  0xbd: 0x5f,\n  // Underscore\n  0xbe: 0x7c,\n  // Pipe (vertical line)\n  0xbf: 0x223c,\n  // Tilde operator\n  0xc0: 0xc4,\n  // Uppercase A, umlaut\n  0xc1: 0xe4,\n  // Lowercase A, umlaut\n  0xc2: 0xd6,\n  // Uppercase O, umlaut\n  0xc3: 0xf6,\n  // Lowercase o, umlaut\n  0xc4: 0xdf,\n  // Esszett (sharp S)\n  0xc5: 0xa5,\n  // Yen symbol\n  0xc6: 0xa4,\n  // Generic currency sign\n  0xc7: 0x2503,\n  // Box drawings heavy vertical\n  0xc8: 0xc5,\n  // Uppercase A, ring\n  0xc9: 0xe5,\n  // Lowercase A, ring\n  0xca: 0xd8,\n  // Uppercase O, stroke\n  0xcb: 0xf8,\n  // Lowercase o, strok\n  0xcc: 0x250f,\n  // Box drawings heavy down and right\n  0xcd: 0x2513,\n  // Box drawings heavy down and left\n  0xce: 0x2517,\n  // Box drawings heavy up and right\n  0xcf: 0x251b // Box drawings heavy up and left\n};\n\n/**\n * Utils\n */\nconst getCharForByte = byte => String.fromCharCode(specialCea608CharsCodes[byte] || byte);\nconst NR_ROWS = 15;\nconst NR_COLS = 100;\n// Tables to look up row from PAC data\nconst rowsLowCh1 = {\n  0x11: 1,\n  0x12: 3,\n  0x15: 5,\n  0x16: 7,\n  0x17: 9,\n  0x10: 11,\n  0x13: 12,\n  0x14: 14\n};\nconst rowsHighCh1 = {\n  0x11: 2,\n  0x12: 4,\n  0x15: 6,\n  0x16: 8,\n  0x17: 10,\n  0x13: 13,\n  0x14: 15\n};\nconst rowsLowCh2 = {\n  0x19: 1,\n  0x1a: 3,\n  0x1d: 5,\n  0x1e: 7,\n  0x1f: 9,\n  0x18: 11,\n  0x1b: 12,\n  0x1c: 14\n};\nconst rowsHighCh2 = {\n  0x19: 2,\n  0x1a: 4,\n  0x1d: 6,\n  0x1e: 8,\n  0x1f: 10,\n  0x1b: 13,\n  0x1c: 15\n};\nconst backgroundColors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'black', 'transparent'];\nclass CaptionsLogger {\n  constructor() {\n    this.time = null;\n    this.verboseLevel = 0;\n  }\n  log(severity, msg) {\n    if (this.verboseLevel >= severity) {\n      const m = typeof msg === 'function' ? msg() : msg;\n      logger.log(`${this.time} [${severity}] ${m}`);\n    }\n  }\n}\nconst numArrayToHexArray = function numArrayToHexArray(numArray) {\n  const hexArray = [];\n  for (let j = 0; j < numArray.length; j++) {\n    hexArray.push(numArray[j].toString(16));\n  }\n  return hexArray;\n};\nclass PenState {\n  constructor() {\n    this.foreground = 'white';\n    this.underline = false;\n    this.italics = false;\n    this.background = 'black';\n    this.flash = false;\n  }\n  reset() {\n    this.foreground = 'white';\n    this.underline = false;\n    this.italics = false;\n    this.background = 'black';\n    this.flash = false;\n  }\n  setStyles(styles) {\n    const attribs = ['foreground', 'underline', 'italics', 'background', 'flash'];\n    for (let i = 0; i < attribs.length; i++) {\n      const style = attribs[i];\n      if (styles.hasOwnProperty(style)) {\n        this[style] = styles[style];\n      }\n    }\n  }\n  isDefault() {\n    return this.foreground === 'white' && !this.underline && !this.italics && this.background === 'black' && !this.flash;\n  }\n  equals(other) {\n    return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;\n  }\n  copy(newPenState) {\n    this.foreground = newPenState.foreground;\n    this.underline = newPenState.underline;\n    this.italics = newPenState.italics;\n    this.background = newPenState.background;\n    this.flash = newPenState.flash;\n  }\n  toString() {\n    return 'color=' + this.foreground + ', underline=' + this.underline + ', italics=' + this.italics + ', background=' + this.background + ', flash=' + this.flash;\n  }\n}\n\n/**\n * Unicode character with styling and background.\n * @constructor\n */\nclass StyledUnicodeChar {\n  constructor() {\n    this.uchar = ' ';\n    this.penState = new PenState();\n  }\n  reset() {\n    this.uchar = ' ';\n    this.penState.reset();\n  }\n  setChar(uchar, newPenState) {\n    this.uchar = uchar;\n    this.penState.copy(newPenState);\n  }\n  setPenState(newPenState) {\n    this.penState.copy(newPenState);\n  }\n  equals(other) {\n    return this.uchar === other.uchar && this.penState.equals(other.penState);\n  }\n  copy(newChar) {\n    this.uchar = newChar.uchar;\n    this.penState.copy(newChar.penState);\n  }\n  isEmpty() {\n    return this.uchar === ' ' && this.penState.isDefault();\n  }\n}\n\n/**\n * CEA-608 row consisting of NR_COLS instances of StyledUnicodeChar.\n * @constructor\n */\nclass Row {\n  constructor(logger) {\n    this.chars = [];\n    this.pos = 0;\n    this.currPenState = new PenState();\n    this.cueStartTime = null;\n    this.logger = void 0;\n    for (let i = 0; i < NR_COLS; i++) {\n      this.chars.push(new StyledUnicodeChar());\n    }\n    this.logger = logger;\n  }\n  equals(other) {\n    for (let i = 0; i < NR_COLS; i++) {\n      if (!this.chars[i].equals(other.chars[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  copy(other) {\n    for (let i = 0; i < NR_COLS; i++) {\n      this.chars[i].copy(other.chars[i]);\n    }\n  }\n  isEmpty() {\n    let empty = true;\n    for (let i = 0; i < NR_COLS; i++) {\n      if (!this.chars[i].isEmpty()) {\n        empty = false;\n        break;\n      }\n    }\n    return empty;\n  }\n\n  /**\n   *  Set the cursor to a valid column.\n   */\n  setCursor(absPos) {\n    if (this.pos !== absPos) {\n      this.pos = absPos;\n    }\n    if (this.pos < 0) {\n      this.logger.log(3, 'Negative cursor position ' + this.pos);\n      this.pos = 0;\n    } else if (this.pos > NR_COLS) {\n      this.logger.log(3, 'Too large cursor position ' + this.pos);\n      this.pos = NR_COLS;\n    }\n  }\n\n  /**\n   * Move the cursor relative to current position.\n   */\n  moveCursor(relPos) {\n    const newPos = this.pos + relPos;\n    if (relPos > 1) {\n      for (let i = this.pos + 1; i < newPos + 1; i++) {\n        this.chars[i].setPenState(this.currPenState);\n      }\n    }\n    this.setCursor(newPos);\n  }\n\n  /**\n   * Backspace, move one step back and clear character.\n   */\n  backSpace() {\n    this.moveCursor(-1);\n    this.chars[this.pos].setChar(' ', this.currPenState);\n  }\n  insertChar(byte) {\n    if (byte >= 0x90) {\n      // Extended char\n      this.backSpace();\n    }\n    const char = getCharForByte(byte);\n    if (this.pos >= NR_COLS) {\n      this.logger.log(0, () => 'Cannot insert ' + byte.toString(16) + ' (' + char + ') at position ' + this.pos + '. Skipping it!');\n      return;\n    }\n    this.chars[this.pos].setChar(char, this.currPenState);\n    this.moveCursor(1);\n  }\n  clearFromPos(startPos) {\n    let i;\n    for (i = startPos; i < NR_COLS; i++) {\n      this.chars[i].reset();\n    }\n  }\n  clear() {\n    this.clearFromPos(0);\n    this.pos = 0;\n    this.currPenState.reset();\n  }\n  clearToEndOfRow() {\n    this.clearFromPos(this.pos);\n  }\n  getTextString() {\n    const chars = [];\n    let empty = true;\n    for (let i = 0; i < NR_COLS; i++) {\n      const char = this.chars[i].uchar;\n      if (char !== ' ') {\n        empty = false;\n      }\n      chars.push(char);\n    }\n    if (empty) {\n      return '';\n    } else {\n      return chars.join('');\n    }\n  }\n  setPenStyles(styles) {\n    this.currPenState.setStyles(styles);\n    const currChar = this.chars[this.pos];\n    currChar.setPenState(this.currPenState);\n  }\n}\n\n/**\n * Keep a CEA-608 screen of 32x15 styled characters\n * @constructor\n */\nclass CaptionScreen {\n  constructor(logger) {\n    this.rows = [];\n    this.currRow = NR_ROWS - 1;\n    this.nrRollUpRows = null;\n    this.lastOutputScreen = null;\n    this.logger = void 0;\n    for (let i = 0; i < NR_ROWS; i++) {\n      this.rows.push(new Row(logger));\n    }\n    this.logger = logger;\n  }\n  reset() {\n    for (let i = 0; i < NR_ROWS; i++) {\n      this.rows[i].clear();\n    }\n    this.currRow = NR_ROWS - 1;\n  }\n  equals(other) {\n    let equal = true;\n    for (let i = 0; i < NR_ROWS; i++) {\n      if (!this.rows[i].equals(other.rows[i])) {\n        equal = false;\n        break;\n      }\n    }\n    return equal;\n  }\n  copy(other) {\n    for (let i = 0; i < NR_ROWS; i++) {\n      this.rows[i].copy(other.rows[i]);\n    }\n  }\n  isEmpty() {\n    let empty = true;\n    for (let i = 0; i < NR_ROWS; i++) {\n      if (!this.rows[i].isEmpty()) {\n        empty = false;\n        break;\n      }\n    }\n    return empty;\n  }\n  backSpace() {\n    const row = this.rows[this.currRow];\n    row.backSpace();\n  }\n  clearToEndOfRow() {\n    const row = this.rows[this.currRow];\n    row.clearToEndOfRow();\n  }\n\n  /**\n   * Insert a character (without styling) in the current row.\n   */\n  insertChar(char) {\n    const row = this.rows[this.currRow];\n    row.insertChar(char);\n  }\n  setPen(styles) {\n    const row = this.rows[this.currRow];\n    row.setPenStyles(styles);\n  }\n  moveCursor(relPos) {\n    const row = this.rows[this.currRow];\n    row.moveCursor(relPos);\n  }\n  setCursor(absPos) {\n    this.logger.log(2, 'setCursor: ' + absPos);\n    const row = this.rows[this.currRow];\n    row.setCursor(absPos);\n  }\n  setPAC(pacData) {\n    this.logger.log(2, () => 'pacData = ' + stringify(pacData));\n    let newRow = pacData.row - 1;\n    if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {\n      newRow = this.nrRollUpRows - 1;\n    }\n\n    // Make sure this only affects Roll-up Captions by checking this.nrRollUpRows\n    if (this.nrRollUpRows && this.currRow !== newRow) {\n      // clear all rows first\n      for (let i = 0; i < NR_ROWS; i++) {\n        this.rows[i].clear();\n      }\n\n      // Copy this.nrRollUpRows rows from lastOutputScreen and place it in the newRow location\n      // topRowIndex - the start of rows to copy (inclusive index)\n      const topRowIndex = this.currRow + 1 - this.nrRollUpRows;\n      // We only copy if the last position was already shown.\n      // We use the cueStartTime value to check this.\n      const lastOutputScreen = this.lastOutputScreen;\n      if (lastOutputScreen) {\n        const prevLineTime = lastOutputScreen.rows[topRowIndex].cueStartTime;\n        const time = this.logger.time;\n        if (prevLineTime !== null && time !== null && prevLineTime < time) {\n          for (let i = 0; i < this.nrRollUpRows; i++) {\n            this.rows[newRow - this.nrRollUpRows + i + 1].copy(lastOutputScreen.rows[topRowIndex + i]);\n          }\n        }\n      }\n    }\n    this.currRow = newRow;\n    const row = this.rows[this.currRow];\n    if (pacData.indent !== null) {\n      const indent = pacData.indent;\n      const prevPos = Math.max(indent - 1, 0);\n      row.setCursor(pacData.indent);\n      pacData.color = row.chars[prevPos].penState.foreground;\n    }\n    const styles = {\n      foreground: pacData.color,\n      underline: pacData.underline,\n      italics: pacData.italics,\n      background: 'black',\n      flash: false\n    };\n    this.setPen(styles);\n  }\n\n  /**\n   * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).\n   */\n  setBkgData(bkgData) {\n    this.logger.log(2, () => 'bkgData = ' + stringify(bkgData));\n    this.backSpace();\n    this.setPen(bkgData);\n    this.insertChar(0x20); // Space\n  }\n  setRollUpRows(nrRows) {\n    this.nrRollUpRows = nrRows;\n  }\n  rollUp() {\n    if (this.nrRollUpRows === null) {\n      this.logger.log(3, 'roll_up but nrRollUpRows not set yet');\n      return; // Not properly setup\n    }\n    this.logger.log(1, () => this.getDisplayText());\n    const topRowIndex = this.currRow + 1 - this.nrRollUpRows;\n    const topRow = this.rows.splice(topRowIndex, 1)[0];\n    topRow.clear();\n    this.rows.splice(this.currRow, 0, topRow);\n    this.logger.log(2, 'Rolling up');\n    // this.logger.log(VerboseLevel.TEXT, this.get_display_text())\n  }\n\n  /**\n   * Get all non-empty rows with as unicode text.\n   */\n  getDisplayText(asOneRow) {\n    asOneRow = asOneRow || false;\n    const displayText = [];\n    let text = '';\n    let rowNr = -1;\n    for (let i = 0; i < NR_ROWS; i++) {\n      const rowText = this.rows[i].getTextString();\n      if (rowText) {\n        rowNr = i + 1;\n        if (asOneRow) {\n          displayText.push('Row ' + rowNr + \": '\" + rowText + \"'\");\n        } else {\n          displayText.push(rowText.trim());\n        }\n      }\n    }\n    if (displayText.length > 0) {\n      if (asOneRow) {\n        text = '[' + displayText.join(' | ') + ']';\n      } else {\n        text = displayText.join('\\n');\n      }\n    }\n    return text;\n  }\n  getTextAndFormat() {\n    return this.rows;\n  }\n}\n\n// var modes = ['MODE_ROLL-UP', 'MODE_POP-ON', 'MODE_PAINT-ON', 'MODE_TEXT'];\n\nclass Cea608Channel {\n  constructor(channelNumber, outputFilter, logger) {\n    this.chNr = void 0;\n    this.outputFilter = void 0;\n    this.mode = void 0;\n    this.verbose = void 0;\n    this.displayedMemory = void 0;\n    this.nonDisplayedMemory = void 0;\n    this.lastOutputScreen = void 0;\n    this.currRollUpRow = void 0;\n    this.writeScreen = void 0;\n    this.cueStartTime = void 0;\n    this.logger = void 0;\n    this.chNr = channelNumber;\n    this.outputFilter = outputFilter;\n    this.mode = null;\n    this.verbose = 0;\n    this.displayedMemory = new CaptionScreen(logger);\n    this.nonDisplayedMemory = new CaptionScreen(logger);\n    this.lastOutputScreen = new CaptionScreen(logger);\n    this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];\n    this.writeScreen = this.displayedMemory;\n    this.mode = null;\n    this.cueStartTime = null; // Keeps track of where a cue started.\n    this.logger = logger;\n  }\n  reset() {\n    this.mode = null;\n    this.displayedMemory.reset();\n    this.nonDisplayedMemory.reset();\n    this.lastOutputScreen.reset();\n    this.outputFilter.reset();\n    this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];\n    this.writeScreen = this.displayedMemory;\n    this.mode = null;\n    this.cueStartTime = null;\n  }\n  getHandler() {\n    return this.outputFilter;\n  }\n  setHandler(newHandler) {\n    this.outputFilter = newHandler;\n  }\n  setPAC(pacData) {\n    this.writeScreen.setPAC(pacData);\n  }\n  setBkgData(bkgData) {\n    this.writeScreen.setBkgData(bkgData);\n  }\n  setMode(newMode) {\n    if (newMode === this.mode) {\n      return;\n    }\n    this.mode = newMode;\n    this.logger.log(2, () => 'MODE=' + newMode);\n    if (this.mode === 'MODE_POP-ON') {\n      this.writeScreen = this.nonDisplayedMemory;\n    } else {\n      this.writeScreen = this.displayedMemory;\n      this.writeScreen.reset();\n    }\n    if (this.mode !== 'MODE_ROLL-UP') {\n      this.displayedMemory.nrRollUpRows = null;\n      this.nonDisplayedMemory.nrRollUpRows = null;\n    }\n    this.mode = newMode;\n  }\n  insertChars(chars) {\n    for (let i = 0; i < chars.length; i++) {\n      this.writeScreen.insertChar(chars[i]);\n    }\n    const screen = this.writeScreen === this.displayedMemory ? 'DISP' : 'NON_DISP';\n    this.logger.log(2, () => screen + ': ' + this.writeScreen.getDisplayText(true));\n    if (this.mode === 'MODE_PAINT-ON' || this.mode === 'MODE_ROLL-UP') {\n      this.logger.log(1, () => 'DISPLAYED: ' + this.displayedMemory.getDisplayText(true));\n      this.outputDataUpdate();\n    }\n  }\n  ccRCL() {\n    // Resume Caption Loading (switch mode to Pop On)\n    this.logger.log(2, 'RCL - Resume Caption Loading');\n    this.setMode('MODE_POP-ON');\n  }\n  ccBS() {\n    // BackSpace\n    this.logger.log(2, 'BS - BackSpace');\n    if (this.mode === 'MODE_TEXT') {\n      return;\n    }\n    this.writeScreen.backSpace();\n    if (this.writeScreen === this.displayedMemory) {\n      this.outputDataUpdate();\n    }\n  }\n  ccAOF() {\n    // Reserved (formerly Alarm Off)\n  }\n  ccAON() {\n    // Reserved (formerly Alarm On)\n  }\n  ccDER() {\n    // Delete to End of Row\n    this.logger.log(2, 'DER- Delete to End of Row');\n    this.writeScreen.clearToEndOfRow();\n    this.outputDataUpdate();\n  }\n  ccRU(nrRows) {\n    // Roll-Up Captions-2,3,or 4 Rows\n    this.logger.log(2, 'RU(' + nrRows + ') - Roll Up');\n    this.writeScreen = this.displayedMemory;\n    this.setMode('MODE_ROLL-UP');\n    this.writeScreen.setRollUpRows(nrRows);\n  }\n  ccFON() {\n    // Flash On\n    this.logger.log(2, 'FON - Flash On');\n    this.writeScreen.setPen({\n      flash: true\n    });\n  }\n  ccRDC() {\n    // Resume Direct Captioning (switch mode to PaintOn)\n    this.logger.log(2, 'RDC - Resume Direct Captioning');\n    this.setMode('MODE_PAINT-ON');\n  }\n  ccTR() {\n    // Text Restart in text mode (not supported, however)\n    this.logger.log(2, 'TR');\n    this.setMode('MODE_TEXT');\n  }\n  ccRTD() {\n    // Resume Text Display in Text mode (not supported, however)\n    this.logger.log(2, 'RTD');\n    this.setMode('MODE_TEXT');\n  }\n  ccEDM() {\n    // Erase Displayed Memory\n    this.logger.log(2, 'EDM - Erase Displayed Memory');\n    this.displayedMemory.reset();\n    this.outputDataUpdate(true);\n  }\n  ccCR() {\n    // Carriage Return\n    this.logger.log(2, 'CR - Carriage Return');\n    this.writeScreen.rollUp();\n    this.outputDataUpdate(true);\n  }\n  ccENM() {\n    // Erase Non-Displayed Memory\n    this.logger.log(2, 'ENM - Erase Non-displayed Memory');\n    this.nonDisplayedMemory.reset();\n  }\n  ccEOC() {\n    // End of Caption (Flip Memories)\n    this.logger.log(2, 'EOC - End Of Caption');\n    if (this.mode === 'MODE_POP-ON') {\n      const tmp = this.displayedMemory;\n      this.displayedMemory = this.nonDisplayedMemory;\n      this.nonDisplayedMemory = tmp;\n      this.writeScreen = this.nonDisplayedMemory;\n      this.logger.log(1, () => 'DISP: ' + this.displayedMemory.getDisplayText());\n    }\n    this.outputDataUpdate(true);\n  }\n  ccTO(nrCols) {\n    // Tab Offset 1,2, or 3 columns\n    this.logger.log(2, 'TO(' + nrCols + ') - Tab Offset');\n    this.writeScreen.moveCursor(nrCols);\n  }\n  ccMIDROW(secondByte) {\n    // Parse MIDROW command\n    const styles = {\n      flash: false\n    };\n    styles.underline = secondByte % 2 === 1;\n    styles.italics = secondByte >= 0x2e;\n    if (!styles.italics) {\n      const colorIndex = Math.floor(secondByte / 2) - 0x10;\n      const colors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta'];\n      styles.foreground = colors[colorIndex];\n    } else {\n      styles.foreground = 'white';\n    }\n    this.logger.log(2, 'MIDROW: ' + stringify(styles));\n    this.writeScreen.setPen(styles);\n  }\n  outputDataUpdate(dispatch = false) {\n    const time = this.logger.time;\n    if (time === null) {\n      return;\n    }\n    if (this.outputFilter) {\n      if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {\n        // Start of a new cue\n        this.cueStartTime = time;\n      } else {\n        if (!this.displayedMemory.equals(this.lastOutputScreen)) {\n          this.outputFilter.newCue(this.cueStartTime, time, this.lastOutputScreen);\n          if (dispatch && this.outputFilter.dispatchCue) {\n            this.outputFilter.dispatchCue();\n          }\n          this.cueStartTime = this.displayedMemory.isEmpty() ? null : time;\n        }\n      }\n      this.lastOutputScreen.copy(this.displayedMemory);\n    }\n  }\n  cueSplitAtTime(t) {\n    if (this.outputFilter) {\n      if (!this.displayedMemory.isEmpty()) {\n        if (this.outputFilter.newCue) {\n          this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);\n        }\n        this.cueStartTime = t;\n      }\n    }\n  }\n}\n\n// Will be 1 or 2 when parsing captions\n\nclass Cea608Parser {\n  constructor(field, out1, out2) {\n    this.channels = void 0;\n    this.currentChannel = 0;\n    this.cmdHistory = createCmdHistory();\n    this.logger = void 0;\n    const logger = this.logger = new CaptionsLogger();\n    this.channels = [null, new Cea608Channel(field, out1, logger), new Cea608Channel(field + 1, out2, logger)];\n  }\n  getHandler(channel) {\n    return this.channels[channel].getHandler();\n  }\n  setHandler(channel, newHandler) {\n    this.channels[channel].setHandler(newHandler);\n  }\n\n  /**\n   * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.\n   */\n  addData(time, byteList) {\n    this.logger.time = time;\n    for (let i = 0; i < byteList.length; i += 2) {\n      const a = byteList[i] & 0x7f;\n      const b = byteList[i + 1] & 0x7f;\n      let cmdFound = false;\n      let charsFound = null;\n      if (a === 0 && b === 0) {\n        continue;\n      } else {\n        this.logger.log(3, () => '[' + numArrayToHexArray([byteList[i], byteList[i + 1]]) + '] -> (' + numArrayToHexArray([a, b]) + ')');\n      }\n      const cmdHistory = this.cmdHistory;\n      const isControlCode = a >= 0x10 && a <= 0x1f;\n      if (isControlCode) {\n        // Skip redundant control codes\n        if (hasCmdRepeated(a, b, cmdHistory)) {\n          setLastCmd(null, null, cmdHistory);\n          this.logger.log(3, () => 'Repeated command (' + numArrayToHexArray([a, b]) + ') is dropped');\n          continue;\n        }\n        setLastCmd(a, b, this.cmdHistory);\n        cmdFound = this.parseCmd(a, b);\n        if (!cmdFound) {\n          cmdFound = this.parseMidrow(a, b);\n        }\n        if (!cmdFound) {\n          cmdFound = this.parsePAC(a, b);\n        }\n        if (!cmdFound) {\n          cmdFound = this.parseBackgroundAttributes(a, b);\n        }\n      } else {\n        setLastCmd(null, null, cmdHistory);\n      }\n      if (!cmdFound) {\n        charsFound = this.parseChars(a, b);\n        if (charsFound) {\n          const currChNr = this.currentChannel;\n          if (currChNr && currChNr > 0) {\n            const channel = this.channels[currChNr];\n            channel.insertChars(charsFound);\n          } else {\n            this.logger.log(2, 'No channel found yet. TEXT-MODE?');\n          }\n        }\n      }\n      if (!cmdFound && !charsFound) {\n        this.logger.log(2, () => \"Couldn't parse cleaned data \" + numArrayToHexArray([a, b]) + ' orig: ' + numArrayToHexArray([byteList[i], byteList[i + 1]]));\n      }\n    }\n  }\n\n  /**\n   * Parse Command.\n   * @returns True if a command was found\n   */\n  parseCmd(a, b) {\n    const cond1 = (a === 0x14 || a === 0x1c || a === 0x15 || a === 0x1d) && b >= 0x20 && b <= 0x2f;\n    const cond2 = (a === 0x17 || a === 0x1f) && b >= 0x21 && b <= 0x23;\n    if (!(cond1 || cond2)) {\n      return false;\n    }\n    const chNr = a === 0x14 || a === 0x15 || a === 0x17 ? 1 : 2;\n    const channel = this.channels[chNr];\n    if (a === 0x14 || a === 0x15 || a === 0x1c || a === 0x1d) {\n      if (b === 0x20) {\n        channel.ccRCL();\n      } else if (b === 0x21) {\n        channel.ccBS();\n      } else if (b === 0x22) {\n        channel.ccAOF();\n      } else if (b === 0x23) {\n        channel.ccAON();\n      } else if (b === 0x24) {\n        channel.ccDER();\n      } else if (b === 0x25) {\n        channel.ccRU(2);\n      } else if (b === 0x26) {\n        channel.ccRU(3);\n      } else if (b === 0x27) {\n        channel.ccRU(4);\n      } else if (b === 0x28) {\n        channel.ccFON();\n      } else if (b === 0x29) {\n        channel.ccRDC();\n      } else if (b === 0x2a) {\n        channel.ccTR();\n      } else if (b === 0x2b) {\n        channel.ccRTD();\n      } else if (b === 0x2c) {\n        channel.ccEDM();\n      } else if (b === 0x2d) {\n        channel.ccCR();\n      } else if (b === 0x2e) {\n        channel.ccENM();\n      } else if (b === 0x2f) {\n        channel.ccEOC();\n      }\n    } else {\n      // a == 0x17 || a == 0x1F\n      channel.ccTO(b - 0x20);\n    }\n    this.currentChannel = chNr;\n    return true;\n  }\n\n  /**\n   * Parse midrow styling command\n   */\n  parseMidrow(a, b) {\n    let chNr = 0;\n    if ((a === 0x11 || a === 0x19) && b >= 0x20 && b <= 0x2f) {\n      if (a === 0x11) {\n        chNr = 1;\n      } else {\n        chNr = 2;\n      }\n      if (chNr !== this.currentChannel) {\n        this.logger.log(0, 'Mismatch channel in midrow parsing');\n        return false;\n      }\n      const channel = this.channels[chNr];\n      if (!channel) {\n        return false;\n      }\n      channel.ccMIDROW(b);\n      this.logger.log(3, () => 'MIDROW (' + numArrayToHexArray([a, b]) + ')');\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Parse Preable Access Codes (Table 53).\n   * @returns {Boolean} Tells if PAC found\n   */\n  parsePAC(a, b) {\n    let row;\n    const case1 = (a >= 0x11 && a <= 0x17 || a >= 0x19 && a <= 0x1f) && b >= 0x40 && b <= 0x7f;\n    const case2 = (a === 0x10 || a === 0x18) && b >= 0x40 && b <= 0x5f;\n    if (!(case1 || case2)) {\n      return false;\n    }\n    const chNr = a <= 0x17 ? 1 : 2;\n    if (b >= 0x40 && b <= 0x5f) {\n      row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];\n    } else {\n      // 0x60 <= b <= 0x7F\n      row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];\n    }\n    const channel = this.channels[chNr];\n    if (!channel) {\n      return false;\n    }\n    channel.setPAC(this.interpretPAC(row, b));\n    this.currentChannel = chNr;\n    return true;\n  }\n\n  /**\n   * Interpret the second byte of the pac, and return the information.\n   * @returns pacData with style parameters\n   */\n  interpretPAC(row, byte) {\n    let pacIndex;\n    const pacData = {\n      color: null,\n      italics: false,\n      indent: null,\n      underline: false,\n      row: row\n    };\n    if (byte > 0x5f) {\n      pacIndex = byte - 0x60;\n    } else {\n      pacIndex = byte - 0x40;\n    }\n    pacData.underline = (pacIndex & 1) === 1;\n    if (pacIndex <= 0xd) {\n      pacData.color = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'white'][Math.floor(pacIndex / 2)];\n    } else if (pacIndex <= 0xf) {\n      pacData.italics = true;\n      pacData.color = 'white';\n    } else {\n      pacData.indent = Math.floor((pacIndex - 0x10) / 2) * 4;\n    }\n    return pacData; // Note that row has zero offset. The spec uses 1.\n  }\n\n  /**\n   * Parse characters.\n   * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.\n   */\n  parseChars(a, b) {\n    let channelNr;\n    let charCodes = null;\n    let charCode1 = null;\n    if (a >= 0x19) {\n      channelNr = 2;\n      charCode1 = a - 8;\n    } else {\n      channelNr = 1;\n      charCode1 = a;\n    }\n    if (charCode1 >= 0x11 && charCode1 <= 0x13) {\n      // Special character\n      let oneCode;\n      if (charCode1 === 0x11) {\n        oneCode = b + 0x50;\n      } else if (charCode1 === 0x12) {\n        oneCode = b + 0x70;\n      } else {\n        oneCode = b + 0x90;\n      }\n      this.logger.log(2, () => \"Special char '\" + getCharForByte(oneCode) + \"' in channel \" + channelNr);\n      charCodes = [oneCode];\n    } else if (a >= 0x20 && a <= 0x7f) {\n      charCodes = b === 0 ? [a] : [a, b];\n    }\n    if (charCodes) {\n      this.logger.log(3, () => 'Char codes =  ' + numArrayToHexArray(charCodes).join(','));\n    }\n    return charCodes;\n  }\n\n  /**\n   * Parse extended background attributes as well as new foreground color black.\n   * @returns True if background attributes are found\n   */\n  parseBackgroundAttributes(a, b) {\n    const case1 = (a === 0x10 || a === 0x18) && b >= 0x20 && b <= 0x2f;\n    const case2 = (a === 0x17 || a === 0x1f) && b >= 0x2d && b <= 0x2f;\n    if (!(case1 || case2)) {\n      return false;\n    }\n    let index;\n    const bkgData = {};\n    if (a === 0x10 || a === 0x18) {\n      index = Math.floor((b - 0x20) / 2);\n      bkgData.background = backgroundColors[index];\n      if (b % 2 === 1) {\n        bkgData.background = bkgData.background + '_semi';\n      }\n    } else if (b === 0x2d) {\n      bkgData.background = 'transparent';\n    } else {\n      bkgData.foreground = 'black';\n      if (b === 0x2f) {\n        bkgData.underline = true;\n      }\n    }\n    const chNr = a <= 0x17 ? 1 : 2;\n    const channel = this.channels[chNr];\n    channel.setBkgData(bkgData);\n    return true;\n  }\n\n  /**\n   * Reset state of parser and its channels.\n   */\n  reset() {\n    for (let i = 0; i < Object.keys(this.channels).length; i++) {\n      const channel = this.channels[i];\n      if (channel) {\n        channel.reset();\n      }\n    }\n    setLastCmd(null, null, this.cmdHistory);\n  }\n\n  /**\n   * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.\n   */\n  cueSplitAtTime(t) {\n    for (let i = 0; i < this.channels.length; i++) {\n      const channel = this.channels[i];\n      if (channel) {\n        channel.cueSplitAtTime(t);\n      }\n    }\n  }\n}\nfunction setLastCmd(a, b, cmdHistory) {\n  cmdHistory.a = a;\n  cmdHistory.b = b;\n}\nfunction hasCmdRepeated(a, b, cmdHistory) {\n  return cmdHistory.a === a && cmdHistory.b === b;\n}\nfunction createCmdHistory() {\n  return {\n    a: null,\n    b: null\n  };\n}\n\n/**\n * Copyright 2013 vtt.js Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar VTTCue = (function () {\n  if (optionalSelf != null && optionalSelf.VTTCue) {\n    return self.VTTCue;\n  }\n  const AllowedDirections = ['', 'lr', 'rl'];\n  const AllowedAlignments = ['start', 'middle', 'end', 'left', 'right'];\n  function isAllowedValue(allowed, value) {\n    if (typeof value !== 'string') {\n      return false;\n    }\n    // necessary for assuring the generic conforms to the Array interface\n    if (!Array.isArray(allowed)) {\n      return false;\n    }\n    // reset the type so that the next narrowing works well\n    const lcValue = value.toLowerCase();\n    // use the allow list to narrow the type to a specific subset of strings\n    if (~allowed.indexOf(lcValue)) {\n      return lcValue;\n    }\n    return false;\n  }\n  function findDirectionSetting(value) {\n    return isAllowedValue(AllowedDirections, value);\n  }\n  function findAlignSetting(value) {\n    return isAllowedValue(AllowedAlignments, value);\n  }\n  function extend(obj, ...rest) {\n    let i = 1;\n    for (; i < arguments.length; i++) {\n      const cobj = arguments[i];\n      for (const p in cobj) {\n        obj[p] = cobj[p];\n      }\n    }\n    return obj;\n  }\n  function VTTCue(startTime, endTime, text) {\n    const cue = this;\n    const baseObj = {\n      enumerable: true\n    };\n    /**\n     * Shim implementation specific properties. These properties are not in\n     * the spec.\n     */\n\n    // Lets us know when the VTTCue's data has changed in such a way that we need\n    // to recompute its display state. This lets us compute its display state\n    // lazily.\n    cue.hasBeenReset = false;\n\n    /**\n     * VTTCue and TextTrackCue properties\n     * http://dev.w3.org/html5/webvtt/#vttcue-interface\n     */\n\n    let _id = '';\n    let _pauseOnExit = false;\n    let _startTime = startTime;\n    let _endTime = endTime;\n    let _text = text;\n    let _region = null;\n    let _vertical = '';\n    let _snapToLines = true;\n    let _line = 'auto';\n    let _lineAlign = 'start';\n    let _position = 50;\n    let _positionAlign = 'middle';\n    let _size = 50;\n    let _align = 'middle';\n    Object.defineProperty(cue, 'id', extend({}, baseObj, {\n      get: function () {\n        return _id;\n      },\n      set: function (value) {\n        _id = '' + value;\n      }\n    }));\n    Object.defineProperty(cue, 'pauseOnExit', extend({}, baseObj, {\n      get: function () {\n        return _pauseOnExit;\n      },\n      set: function (value) {\n        _pauseOnExit = !!value;\n      }\n    }));\n    Object.defineProperty(cue, 'startTime', extend({}, baseObj, {\n      get: function () {\n        return _startTime;\n      },\n      set: function (value) {\n        if (typeof value !== 'number') {\n          throw new TypeError('Start time must be set to a number.');\n        }\n        _startTime = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'endTime', extend({}, baseObj, {\n      get: function () {\n        return _endTime;\n      },\n      set: function (value) {\n        if (typeof value !== 'number') {\n          throw new TypeError('End time must be set to a number.');\n        }\n        _endTime = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'text', extend({}, baseObj, {\n      get: function () {\n        return _text;\n      },\n      set: function (value) {\n        _text = '' + value;\n        this.hasBeenReset = true;\n      }\n    }));\n\n    // todo: implement VTTRegion polyfill?\n    Object.defineProperty(cue, 'region', extend({}, baseObj, {\n      get: function () {\n        return _region;\n      },\n      set: function (value) {\n        _region = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'vertical', extend({}, baseObj, {\n      get: function () {\n        return _vertical;\n      },\n      set: function (value) {\n        const setting = findDirectionSetting(value);\n        // Have to check for false because the setting an be an empty string.\n        if (setting === false) {\n          throw new SyntaxError('An invalid or illegal string was specified.');\n        }\n        _vertical = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'snapToLines', extend({}, baseObj, {\n      get: function () {\n        return _snapToLines;\n      },\n      set: function (value) {\n        _snapToLines = !!value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'line', extend({}, baseObj, {\n      get: function () {\n        return _line;\n      },\n      set: function (value) {\n        if (typeof value !== 'number' && value !== 'auto') {\n          throw new SyntaxError('An invalid number or illegal string was specified.');\n        }\n        _line = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'lineAlign', extend({}, baseObj, {\n      get: function () {\n        return _lineAlign;\n      },\n      set: function (value) {\n        const setting = findAlignSetting(value);\n        if (!setting) {\n          throw new SyntaxError('An invalid or illegal string was specified.');\n        }\n        _lineAlign = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'position', extend({}, baseObj, {\n      get: function () {\n        return _position;\n      },\n      set: function (value) {\n        if (value < 0 || value > 100) {\n          throw new Error('Position must be between 0 and 100.');\n        }\n        _position = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'positionAlign', extend({}, baseObj, {\n      get: function () {\n        return _positionAlign;\n      },\n      set: function (value) {\n        const setting = findAlignSetting(value);\n        if (!setting) {\n          throw new SyntaxError('An invalid or illegal string was specified.');\n        }\n        _positionAlign = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'size', extend({}, baseObj, {\n      get: function () {\n        return _size;\n      },\n      set: function (value) {\n        if (value < 0 || value > 100) {\n          throw new Error('Size must be between 0 and 100.');\n        }\n        _size = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'align', extend({}, baseObj, {\n      get: function () {\n        return _align;\n      },\n      set: function (value) {\n        const setting = findAlignSetting(value);\n        if (!setting) {\n          throw new SyntaxError('An invalid or illegal string was specified.');\n        }\n        _align = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n\n    /**\n     * Other <track> spec defined properties\n     */\n\n    // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state\n    cue.displayState = undefined;\n  }\n\n  /**\n   * VTTCue methods\n   */\n\n  VTTCue.prototype.getCueAsHTML = function () {\n    // Assume WebVTT.convertCueToDOMTree is on the global.\n    const WebVTT = self.WebVTT;\n    return WebVTT.convertCueToDOMTree(self, this.text);\n  };\n  // this is a polyfill hack\n  return VTTCue;\n})();\n\n/*\n * Source: https://github.com/mozilla/vtt.js/blob/master/dist/vtt.js\n */\n\nclass StringDecoder {\n  decode(data, options) {\n    if (!data) {\n      return '';\n    }\n    if (typeof data !== 'string') {\n      throw new Error('Error - expected string data.');\n    }\n    return decodeURIComponent(encodeURIComponent(data));\n  }\n}\n\n// Try to parse input as a time stamp.\nfunction parseTimeStamp(input) {\n  function computeSeconds(h, m, s, f) {\n    return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + parseFloat(f || 0);\n  }\n  const m = input.match(/^(?:(\\d+):)?(\\d{2}):(\\d{2})(\\.\\d+)?/);\n  if (!m) {\n    return null;\n  }\n  if (parseFloat(m[2]) > 59) {\n    // Timestamp takes the form of [hours]:[minutes].[milliseconds]\n    // First position is hours as it's over 59.\n    return computeSeconds(m[2], m[3], 0, m[4]);\n  }\n  // Timestamp takes the form of [hours (optional)]:[minutes]:[seconds].[milliseconds]\n  return computeSeconds(m[1], m[2], m[3], m[4]);\n}\n\n// A settings object holds key/value pairs and will ignore anything but the first\n// assignment to a specific key.\nclass Settings {\n  constructor() {\n    this.values = Object.create(null);\n  }\n  // Only accept the first assignment to any key.\n  set(k, v) {\n    if (!this.get(k) && v !== '') {\n      this.values[k] = v;\n    }\n  }\n  // Return the value for a key, or a default value.\n  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with\n  // a number of possible default values as properties where 'defaultKey' is\n  // the key of the property that will be chosen; otherwise it's assumed to be\n  // a single value.\n  get(k, dflt, defaultKey) {\n    if (defaultKey) {\n      return this.has(k) ? this.values[k] : dflt[defaultKey];\n    }\n    return this.has(k) ? this.values[k] : dflt;\n  }\n  // Check whether we have a value for a key.\n  has(k) {\n    return k in this.values;\n  }\n  // Accept a setting if its one of the given alternatives.\n  alt(k, v, a) {\n    for (let n = 0; n < a.length; ++n) {\n      if (v === a[n]) {\n        this.set(k, v);\n        break;\n      }\n    }\n  }\n  // Accept a setting if its a valid (signed) integer.\n  integer(k, v) {\n    if (/^-?\\d+$/.test(v)) {\n      // integer\n      this.set(k, parseInt(v, 10));\n    }\n  }\n  // Accept a setting if its a valid percentage.\n  percent(k, v) {\n    if (/^([\\d]{1,3})(\\.[\\d]*)?%$/.test(v)) {\n      const percent = parseFloat(v);\n      if (percent >= 0 && percent <= 100) {\n        this.set(k, percent);\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\n// Helper function to parse input into groups separated by 'groupDelim', and\n// interpret each group as a key/value pair separated by 'keyValueDelim'.\nfunction parseOptions(input, callback, keyValueDelim, groupDelim) {\n  const groups = groupDelim ? input.split(groupDelim) : [input];\n  for (const i in groups) {\n    if (typeof groups[i] !== 'string') {\n      continue;\n    }\n    const kv = groups[i].split(keyValueDelim);\n    if (kv.length !== 2) {\n      continue;\n    }\n    const k = kv[0];\n    const v = kv[1];\n    callback(k, v);\n  }\n}\nconst defaults = new VTTCue(0, 0, '');\n// 'middle' was changed to 'center' in the spec: https://github.com/w3c/webvtt/pull/244\n//  Safari doesn't yet support this change, but FF and Chrome do.\nconst center = defaults.align === 'middle' ? 'middle' : 'center';\nfunction parseCue(input, cue, regionList) {\n  // Remember the original input if we need to throw an error.\n  const oInput = input;\n  // 4.1 WebVTT timestamp\n  function consumeTimeStamp() {\n    const ts = parseTimeStamp(input);\n    if (ts === null) {\n      throw new Error('Malformed timestamp: ' + oInput);\n    }\n\n    // Remove time stamp from input.\n    input = input.replace(/^[^\\sa-zA-Z-]+/, '');\n    return ts;\n  }\n\n  // 4.4.2 WebVTT cue settings\n  function consumeCueSettings(input, cue) {\n    const settings = new Settings();\n    parseOptions(input, function (k, v) {\n      let vals;\n      switch (k) {\n        case 'region':\n          // Find the last region we parsed with the same region id.\n          for (let i = regionList.length - 1; i >= 0; i--) {\n            if (regionList[i].id === v) {\n              settings.set(k, regionList[i].region);\n              break;\n            }\n          }\n          break;\n        case 'vertical':\n          settings.alt(k, v, ['rl', 'lr']);\n          break;\n        case 'line':\n          vals = v.split(',');\n          settings.integer(k, vals[0]);\n          if (settings.percent(k, vals[0])) {\n            settings.set('snapToLines', false);\n          }\n          settings.alt(k, vals[0], ['auto']);\n          if (vals.length === 2) {\n            settings.alt('lineAlign', vals[1], ['start', center, 'end']);\n          }\n          break;\n        case 'position':\n          vals = v.split(',');\n          settings.percent(k, vals[0]);\n          if (vals.length === 2) {\n            settings.alt('positionAlign', vals[1], ['start', center, 'end', 'line-left', 'line-right', 'auto']);\n          }\n          break;\n        case 'size':\n          settings.percent(k, v);\n          break;\n        case 'align':\n          settings.alt(k, v, ['start', center, 'end', 'left', 'right']);\n          break;\n      }\n    }, /:/, /\\s/);\n\n    // Apply default values for any missing fields.\n    cue.region = settings.get('region', null);\n    cue.vertical = settings.get('vertical', '');\n    let line = settings.get('line', 'auto');\n    if (line === 'auto' && defaults.line === -1) {\n      // set numeric line number for Safari\n      line = -1;\n    }\n    cue.line = line;\n    cue.lineAlign = settings.get('lineAlign', 'start');\n    cue.snapToLines = settings.get('snapToLines', true);\n    cue.size = settings.get('size', 100);\n    cue.align = settings.get('align', center);\n    let position = settings.get('position', 'auto');\n    if (position === 'auto' && defaults.position === 50) {\n      // set numeric position for Safari\n      position = cue.align === 'start' || cue.align === 'left' ? 0 : cue.align === 'end' || cue.align === 'right' ? 100 : 50;\n    }\n    cue.position = position;\n  }\n  function skipWhitespace() {\n    input = input.replace(/^\\s+/, '');\n  }\n\n  // 4.1 WebVTT cue timings.\n  skipWhitespace();\n  cue.startTime = consumeTimeStamp(); // (1) collect cue start time\n  skipWhitespace();\n  if (input.slice(0, 3) !== '-->') {\n    // (3) next characters must match '-->'\n    throw new Error(\"Malformed time stamp (time stamps must be separated by '-->'): \" + oInput);\n  }\n  input = input.slice(3);\n  skipWhitespace();\n  cue.endTime = consumeTimeStamp(); // (5) collect cue end time\n\n  // 4.1 WebVTT cue settings list.\n  skipWhitespace();\n  consumeCueSettings(input, cue);\n}\nfunction fixLineBreaks(input) {\n  return input.replace(/<br(?: \\/)?>/gi, '\\n');\n}\nclass VTTParser {\n  constructor() {\n    this.state = 'INITIAL';\n    this.buffer = '';\n    this.decoder = new StringDecoder();\n    this.regionList = [];\n    this.cue = null;\n    this.oncue = void 0;\n    this.onparsingerror = void 0;\n    this.onflush = void 0;\n  }\n  parse(data) {\n    const _this = this;\n\n    // If there is no data then we won't decode it, but will just try to parse\n    // whatever is in buffer already. This may occur in circumstances, for\n    // example when flush() is called.\n    if (data) {\n      // Try to decode the data that we received.\n      _this.buffer += _this.decoder.decode(data, {\n        stream: true\n      });\n    }\n    function collectNextLine() {\n      let buffer = _this.buffer;\n      let pos = 0;\n      buffer = fixLineBreaks(buffer);\n      while (pos < buffer.length && buffer[pos] !== '\\r' && buffer[pos] !== '\\n') {\n        ++pos;\n      }\n      const line = buffer.slice(0, pos);\n      // Advance the buffer early in case we fail below.\n      if (buffer[pos] === '\\r') {\n        ++pos;\n      }\n      if (buffer[pos] === '\\n') {\n        ++pos;\n      }\n      _this.buffer = buffer.slice(pos);\n      return line;\n    }\n\n    // 3.2 WebVTT metadata header syntax\n    function parseHeader(input) {\n      parseOptions(input, function (k, v) {\n        // switch (k) {\n        // case 'region':\n        // 3.3 WebVTT region metadata header syntax\n        // console.log('parse region', v);\n        // parseRegion(v);\n        // break;\n        // }\n      }, /:/);\n    }\n\n    // 5.1 WebVTT file parsing.\n    try {\n      let line = '';\n      if (_this.state === 'INITIAL') {\n        // We can't start parsing until we have the first line.\n        if (!/\\r\\n|\\n/.test(_this.buffer)) {\n          return this;\n        }\n        line = collectNextLine();\n        // strip of UTF-8 BOM if any\n        // https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8\n        const m = line.match(/^(ï»¿)?WEBVTT([ \\t].*)?$/);\n        if (!(m != null && m[0])) {\n          throw new Error('Malformed WebVTT signature.');\n        }\n        _this.state = 'HEADER';\n      }\n      let alreadyCollectedLine = false;\n      while (_this.buffer) {\n        // We can't parse a line until we have the full line.\n        if (!/\\r\\n|\\n/.test(_this.buffer)) {\n          return this;\n        }\n        if (!alreadyCollectedLine) {\n          line = collectNextLine();\n        } else {\n          alreadyCollectedLine = false;\n        }\n        switch (_this.state) {\n          case 'HEADER':\n            // 13-18 - Allow a header (metadata) under the WEBVTT line.\n            if (/:/.test(line)) {\n              parseHeader(line);\n            } else if (!line) {\n              // An empty line terminates the header and starts the body (cues).\n              _this.state = 'ID';\n            }\n            continue;\n          case 'NOTE':\n            // Ignore NOTE blocks.\n            if (!line) {\n              _this.state = 'ID';\n            }\n            continue;\n          case 'ID':\n            // Check for the start of NOTE blocks.\n            if (/^NOTE($|[ \\t])/.test(line)) {\n              _this.state = 'NOTE';\n              break;\n            }\n            // 19-29 - Allow any number of line terminators, then initialize new cue values.\n            if (!line) {\n              continue;\n            }\n            _this.cue = new VTTCue(0, 0, '');\n            _this.state = 'CUE';\n            // 30-39 - Check if self line contains an optional identifier or timing data.\n            if (line.indexOf('-->') === -1) {\n              _this.cue.id = line;\n              continue;\n            }\n          // Process line as start of a cue.\n          /* falls through */\n          case 'CUE':\n            // 40 - Collect cue timings and settings.\n            if (!_this.cue) {\n              _this.state = 'BADCUE';\n              continue;\n            }\n            try {\n              parseCue(line, _this.cue, _this.regionList);\n            } catch (e) {\n              // In case of an error ignore rest of the cue.\n              _this.cue = null;\n              _this.state = 'BADCUE';\n              continue;\n            }\n            _this.state = 'CUETEXT';\n            continue;\n          case 'CUETEXT':\n            {\n              const hasSubstring = line.indexOf('-->') !== -1;\n              // 34 - If we have an empty line then report the cue.\n              // 35 - If we have the special substring '-->' then report the cue,\n              // but do not collect the line as we need to process the current\n              // one as a new cue.\n              if (!line || hasSubstring && (alreadyCollectedLine = true)) {\n                // We are done parsing self cue.\n                if (_this.oncue && _this.cue) {\n                  _this.oncue(_this.cue);\n                }\n                _this.cue = null;\n                _this.state = 'ID';\n                continue;\n              }\n              if (_this.cue === null) {\n                continue;\n              }\n              if (_this.cue.text) {\n                _this.cue.text += '\\n';\n              }\n              _this.cue.text += line;\n            }\n            continue;\n          case 'BADCUE':\n            // 54-62 - Collect and discard the remaining cue.\n            if (!line) {\n              _this.state = 'ID';\n            }\n        }\n      }\n    } catch (e) {\n      // If we are currently parsing a cue, report what we have.\n      if (_this.state === 'CUETEXT' && _this.cue && _this.oncue) {\n        _this.oncue(_this.cue);\n      }\n      _this.cue = null;\n      // Enter BADWEBVTT state if header was not parsed correctly otherwise\n      // another exception occurred so enter BADCUE state.\n      _this.state = _this.state === 'INITIAL' ? 'BADWEBVTT' : 'BADCUE';\n    }\n    return this;\n  }\n  flush() {\n    const _this = this;\n    try {\n      // Finish decoding the stream.\n      // _this.buffer += _this.decoder.decode();\n      // Synthesize the end of the current cue or region.\n      if (_this.cue || _this.state === 'HEADER') {\n        _this.buffer += '\\n\\n';\n        _this.parse();\n      }\n      // If we've flushed, parsed, and we're still on the INITIAL state then\n      // that means we don't have enough of the stream to parse the first\n      // line.\n      if (_this.state === 'INITIAL' || _this.state === 'BADWEBVTT') {\n        throw new Error('Malformed WebVTT signature.');\n      }\n    } catch (e) {\n      if (_this.onparsingerror) {\n        _this.onparsingerror(e);\n      }\n    }\n    if (_this.onflush) {\n      _this.onflush();\n    }\n    return this;\n  }\n}\n\nconst LINEBREAKS = /\\r\\n|\\n\\r|\\n|\\r/g;\n\n// String.prototype.startsWith is not supported in IE11\nconst startsWith = function startsWith(inputString, searchString, position = 0) {\n  return inputString.slice(position, position + searchString.length) === searchString;\n};\nconst cueString2millis = function cueString2millis(timeString) {\n  let ts = parseInt(timeString.slice(-3));\n  const secs = parseInt(timeString.slice(-6, -4));\n  const mins = parseInt(timeString.slice(-9, -7));\n  const hours = timeString.length > 9 ? parseInt(timeString.substring(0, timeString.indexOf(':'))) : 0;\n  if (!isFiniteNumber(ts) || !isFiniteNumber(secs) || !isFiniteNumber(mins) || !isFiniteNumber(hours)) {\n    throw Error(`Malformed X-TIMESTAMP-MAP: Local:${timeString}`);\n  }\n  ts += 1000 * secs;\n  ts += 60 * 1000 * mins;\n  ts += 60 * 60 * 1000 * hours;\n  return ts;\n};\n\n// Create a unique hash id for a cue based on start/end times and text.\n// This helps timeline-controller to avoid showing repeated captions.\nfunction generateCueId(startTime, endTime, text) {\n  return hash(startTime.toString()) + hash(endTime.toString()) + hash(text);\n}\nconst calculateOffset = function calculateOffset(vttCCs, cc, presentationTime) {\n  let currCC = vttCCs[cc];\n  let prevCC = vttCCs[currCC.prevCC];\n\n  // This is the first discontinuity or cues have been processed since the last discontinuity\n  // Offset = current discontinuity time\n  if (!prevCC || !prevCC.new && currCC.new) {\n    vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start;\n    currCC.new = false;\n    return;\n  }\n\n  // There have been discontinuities since cues were last parsed.\n  // Offset = time elapsed\n  while ((_prevCC = prevCC) != null && _prevCC.new) {\n    var _prevCC;\n    vttCCs.ccOffset += currCC.start - prevCC.start;\n    currCC.new = false;\n    currCC = prevCC;\n    prevCC = vttCCs[currCC.prevCC];\n  }\n  vttCCs.presentationOffset = presentationTime;\n};\nfunction parseWebVTT(vttByteArray, initPTS, vttCCs, cc, timeOffset, callBack, errorCallBack) {\n  const parser = new VTTParser();\n  // Convert byteArray into string, replacing any somewhat exotic linefeeds with \"\\n\", then split on that character.\n  // Uint8Array.prototype.reduce is not implemented in IE11\n  const vttLines = utf8ArrayToStr(new Uint8Array(vttByteArray)).trim().replace(LINEBREAKS, '\\n').split('\\n');\n  const cues = [];\n  const init90kHz = initPTS ? toMpegTsClockFromTimescale(initPTS.baseTime, initPTS.timescale) : 0;\n  let cueTime = '00:00.000';\n  let timestampMapMPEGTS = 0;\n  let timestampMapLOCAL = 0;\n  let parsingError;\n  let inHeader = true;\n  parser.oncue = function (cue) {\n    // Adjust cue timing; clamp cues to start no earlier than - and drop cues that don't end after - 0 on timeline.\n    const currCC = vttCCs[cc];\n    let cueOffset = vttCCs.ccOffset;\n\n    // Calculate subtitle PTS offset\n    const webVttMpegTsMapOffset = (timestampMapMPEGTS - init90kHz) / 90000;\n\n    // Update offsets for new discontinuities\n    if (currCC != null && currCC.new) {\n      if (timestampMapLOCAL !== undefined) {\n        // When local time is provided, offset = discontinuity start time - local time\n        cueOffset = vttCCs.ccOffset = currCC.start;\n      } else {\n        calculateOffset(vttCCs, cc, webVttMpegTsMapOffset);\n      }\n    }\n    if (webVttMpegTsMapOffset) {\n      if (!initPTS) {\n        parsingError = new Error('Missing initPTS for VTT MPEGTS');\n        return;\n      }\n      // If we have MPEGTS, offset = presentation time + discontinuity offset\n      cueOffset = webVttMpegTsMapOffset - vttCCs.presentationOffset;\n    }\n    const duration = cue.endTime - cue.startTime;\n    const startTime = normalizePts((cue.startTime + cueOffset - timestampMapLOCAL) * 90000, timeOffset * 90000) / 90000;\n    cue.startTime = Math.max(startTime, 0);\n    cue.endTime = Math.max(startTime + duration, 0);\n\n    //trim trailing webvtt block whitespaces\n    const text = cue.text.trim();\n\n    // Fix encoding of special characters\n    cue.text = decodeURIComponent(encodeURIComponent(text));\n\n    // If the cue was not assigned an id from the VTT file (line above the content), create one.\n    if (!cue.id) {\n      cue.id = generateCueId(cue.startTime, cue.endTime, text);\n    }\n    if (cue.endTime > 0) {\n      cues.push(cue);\n    }\n  };\n  parser.onparsingerror = function (error) {\n    parsingError = error;\n  };\n  parser.onflush = function () {\n    if (parsingError) {\n      errorCallBack(parsingError);\n      return;\n    }\n    callBack(cues);\n  };\n\n  // Go through contents line by line.\n  vttLines.forEach(line => {\n    if (inHeader) {\n      // Look for X-TIMESTAMP-MAP in header.\n      if (startsWith(line, 'X-TIMESTAMP-MAP=')) {\n        // Once found, no more are allowed anyway, so stop searching.\n        inHeader = false;\n        // Extract LOCAL and MPEGTS.\n        line.slice(16).split(',').forEach(timestamp => {\n          if (startsWith(timestamp, 'LOCAL:')) {\n            cueTime = timestamp.slice(6);\n          } else if (startsWith(timestamp, 'MPEGTS:')) {\n            timestampMapMPEGTS = parseInt(timestamp.slice(7));\n          }\n        });\n        try {\n          // Convert cue time to seconds\n          timestampMapLOCAL = cueString2millis(cueTime) / 1000;\n        } catch (error) {\n          parsingError = error;\n        }\n        // Return without parsing X-TIMESTAMP-MAP line.\n        return;\n      } else if (line === '') {\n        inHeader = false;\n      }\n    }\n    // Parse line by default.\n    parser.parse(line + '\\n');\n  });\n  parser.flush();\n}\n\nconst IMSC1_CODEC = 'stpp.ttml.im1t';\n\n// Time format: h:m:s:frames(.subframes)\nconst HMSF_REGEX = /^(\\d{2,}):(\\d{2}):(\\d{2}):(\\d{2})\\.?(\\d+)?$/;\n\n// Time format: hours, minutes, seconds, milliseconds, frames, ticks\nconst TIME_UNIT_REGEX = /^(\\d*(?:\\.\\d*)?)(h|m|s|ms|f|t)$/;\nconst textAlignToLineAlign = {\n  left: 'start',\n  center: 'center',\n  right: 'end',\n  start: 'start',\n  end: 'end'\n};\nfunction parseIMSC1(payload, initPTS, callBack, errorCallBack) {\n  const results = findBox(new Uint8Array(payload), ['mdat']);\n  if (results.length === 0) {\n    errorCallBack(new Error('Could not parse IMSC1 mdat'));\n    return;\n  }\n  const ttmlList = results.map(mdat => utf8ArrayToStr(mdat));\n  const syncTime = toTimescaleFromScale(initPTS.baseTime, 1, initPTS.timescale);\n  try {\n    ttmlList.forEach(ttml => callBack(parseTTML(ttml, syncTime)));\n  } catch (error) {\n    errorCallBack(error);\n  }\n}\nfunction parseTTML(ttml, syncTime) {\n  const parser = new DOMParser();\n  const xmlDoc = parser.parseFromString(ttml, 'text/xml');\n  const tt = xmlDoc.getElementsByTagName('tt')[0];\n  if (!tt) {\n    throw new Error('Invalid ttml');\n  }\n  const defaultRateInfo = {\n    frameRate: 30,\n    subFrameRate: 1,\n    frameRateMultiplier: 0,\n    tickRate: 0\n  };\n  const rateInfo = Object.keys(defaultRateInfo).reduce((result, key) => {\n    result[key] = tt.getAttribute(`ttp:${key}`) || defaultRateInfo[key];\n    return result;\n  }, {});\n  const trim = tt.getAttribute('xml:space') !== 'preserve';\n  const styleElements = collectionToDictionary(getElementCollection(tt, 'styling', 'style'));\n  const regionElements = collectionToDictionary(getElementCollection(tt, 'layout', 'region'));\n  const cueElements = getElementCollection(tt, 'body', '[begin]');\n  return [].map.call(cueElements, cueElement => {\n    const cueText = getTextContent(cueElement, trim);\n    if (!cueText || !cueElement.hasAttribute('begin')) {\n      return null;\n    }\n    const startTime = parseTtmlTime(cueElement.getAttribute('begin'), rateInfo);\n    const duration = parseTtmlTime(cueElement.getAttribute('dur'), rateInfo);\n    let endTime = parseTtmlTime(cueElement.getAttribute('end'), rateInfo);\n    if (startTime === null) {\n      throw timestampParsingError(cueElement);\n    }\n    if (endTime === null) {\n      if (duration === null) {\n        throw timestampParsingError(cueElement);\n      }\n      endTime = startTime + duration;\n    }\n    const cue = new VTTCue(startTime - syncTime, endTime - syncTime, cueText);\n    cue.id = generateCueId(cue.startTime, cue.endTime, cue.text);\n    const region = regionElements[cueElement.getAttribute('region')];\n    const style = styleElements[cueElement.getAttribute('style')];\n\n    // Apply styles to cue\n    const styles = getTtmlStyles(region, style, styleElements);\n    const {\n      textAlign\n    } = styles;\n    if (textAlign) {\n      // cue.positionAlign not settable in FF~2016\n      const lineAlign = textAlignToLineAlign[textAlign];\n      if (lineAlign) {\n        cue.lineAlign = lineAlign;\n      }\n      cue.align = textAlign;\n    }\n    _extends(cue, styles);\n    return cue;\n  }).filter(cue => cue !== null);\n}\nfunction getElementCollection(fromElement, parentName, childName) {\n  const parent = fromElement.getElementsByTagName(parentName)[0];\n  if (parent) {\n    return [].slice.call(parent.querySelectorAll(childName));\n  }\n  return [];\n}\nfunction collectionToDictionary(elementsWithId) {\n  return elementsWithId.reduce((dict, element) => {\n    const id = element.getAttribute('xml:id');\n    if (id) {\n      dict[id] = element;\n    }\n    return dict;\n  }, {});\n}\nfunction getTextContent(element, trim) {\n  return [].slice.call(element.childNodes).reduce((str, node, i) => {\n    var _node$childNodes;\n    if (node.nodeName === 'br' && i) {\n      return str + '\\n';\n    }\n    if ((_node$childNodes = node.childNodes) != null && _node$childNodes.length) {\n      return getTextContent(node, trim);\n    } else if (trim) {\n      return str + node.textContent.trim().replace(/\\s+/g, ' ');\n    }\n    return str + node.textContent;\n  }, '');\n}\nfunction getTtmlStyles(region, style, styleElements) {\n  const ttsNs = 'http://www.w3.org/ns/ttml#styling';\n  let regionStyle = null;\n  const styleAttributes = ['displayAlign', 'textAlign', 'color', 'backgroundColor', 'fontSize', 'fontFamily'\n  // 'fontWeight',\n  // 'lineHeight',\n  // 'wrapOption',\n  // 'fontStyle',\n  // 'direction',\n  // 'writingMode'\n  ];\n  const regionStyleName = region != null && region.hasAttribute('style') ? region.getAttribute('style') : null;\n  if (regionStyleName && styleElements.hasOwnProperty(regionStyleName)) {\n    regionStyle = styleElements[regionStyleName];\n  }\n  return styleAttributes.reduce((styles, name) => {\n    const value = getAttributeNS(style, ttsNs, name) || getAttributeNS(region, ttsNs, name) || getAttributeNS(regionStyle, ttsNs, name);\n    if (value) {\n      styles[name] = value;\n    }\n    return styles;\n  }, {});\n}\nfunction getAttributeNS(element, ns, name) {\n  if (!element) {\n    return null;\n  }\n  return element.hasAttributeNS(ns, name) ? element.getAttributeNS(ns, name) : null;\n}\nfunction timestampParsingError(node) {\n  return new Error(`Could not parse ttml timestamp ${node}`);\n}\nfunction parseTtmlTime(timeAttributeValue, rateInfo) {\n  if (!timeAttributeValue) {\n    return null;\n  }\n  let seconds = parseTimeStamp(timeAttributeValue);\n  if (seconds === null) {\n    if (HMSF_REGEX.test(timeAttributeValue)) {\n      seconds = parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo);\n    } else if (TIME_UNIT_REGEX.test(timeAttributeValue)) {\n      seconds = parseTimeUnits(timeAttributeValue, rateInfo);\n    }\n  }\n  return seconds;\n}\nfunction parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo) {\n  const m = HMSF_REGEX.exec(timeAttributeValue);\n  const frames = (m[4] | 0) + (m[5] | 0) / rateInfo.subFrameRate;\n  return (m[1] | 0) * 3600 + (m[2] | 0) * 60 + (m[3] | 0) + frames / rateInfo.frameRate;\n}\nfunction parseTimeUnits(timeAttributeValue, rateInfo) {\n  const m = TIME_UNIT_REGEX.exec(timeAttributeValue);\n  const value = Number(m[1]);\n  const unit = m[2];\n  switch (unit) {\n    case 'h':\n      return value * 3600;\n    case 'm':\n      return value * 60;\n    case 'ms':\n      return value * 1000;\n    case 'f':\n      return value / rateInfo.frameRate;\n    case 't':\n      return value / rateInfo.tickRate;\n  }\n  return value;\n}\n\nclass OutputFilter {\n  constructor(timelineController, trackName) {\n    this.timelineController = void 0;\n    this.cueRanges = [];\n    this.trackName = void 0;\n    this.startTime = null;\n    this.endTime = null;\n    this.screen = null;\n    this.timelineController = timelineController;\n    this.trackName = trackName;\n  }\n  dispatchCue() {\n    if (this.startTime === null) {\n      return;\n    }\n    this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges);\n    this.startTime = null;\n  }\n  newCue(startTime, endTime, screen) {\n    if (this.startTime === null || this.startTime > startTime) {\n      this.startTime = startTime;\n    }\n    this.endTime = endTime;\n    this.screen = screen;\n    this.timelineController.createCaptionsTrack(this.trackName);\n  }\n  reset() {\n    this.cueRanges = [];\n    this.startTime = null;\n  }\n}\n\nclass TimelineController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.media = null;\n    this.config = void 0;\n    this.enabled = true;\n    this.Cues = void 0;\n    this.textTracks = [];\n    this.tracks = [];\n    this.initPTS = [];\n    this.unparsedVttFrags = [];\n    this.captionsTracks = {};\n    this.nonNativeCaptionsTracks = {};\n    this.cea608Parser1 = void 0;\n    this.cea608Parser2 = void 0;\n    this.lastCc = -1;\n    // Last video (CEA-608) fragment CC\n    this.lastSn = -1;\n    // Last video (CEA-608) fragment MSN\n    this.lastPartIndex = -1;\n    // Last video (CEA-608) fragment Part Index\n    this.prevCC = -1;\n    // Last subtitle fragment CC\n    this.vttCCs = newVTTCCs();\n    this.captionsProperties = void 0;\n    this.hls = hls;\n    this.config = hls.config;\n    this.Cues = hls.config.cueHandler;\n    this.captionsProperties = {\n      textTrack1: {\n        label: this.config.captionsTextTrack1Label,\n        languageCode: this.config.captionsTextTrack1LanguageCode\n      },\n      textTrack2: {\n        label: this.config.captionsTextTrack2Label,\n        languageCode: this.config.captionsTextTrack2LanguageCode\n      },\n      textTrack3: {\n        label: this.config.captionsTextTrack3Label,\n        languageCode: this.config.captionsTextTrack3LanguageCode\n      },\n      textTrack4: {\n        label: this.config.captionsTextTrack4Label,\n        languageCode: this.config.captionsTextTrack4LanguageCode\n      }\n    };\n    hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.on(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n    hls.on(Events.FRAG_LOADING, this.onFragLoading, this);\n    hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);\n    hls.on(Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);\n    hls.on(Events.FRAG_DECRYPTED, this.onFragDecrypted, this);\n    hls.on(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);\n    hls.on(Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);\n    hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n  }\n  destroy() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.off(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n    hls.off(Events.FRAG_LOADING, this.onFragLoading, this);\n    hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);\n    hls.off(Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);\n    hls.off(Events.FRAG_DECRYPTED, this.onFragDecrypted, this);\n    hls.off(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);\n    hls.off(Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);\n    hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    // @ts-ignore\n    this.hls = this.config = this.media = null;\n    this.cea608Parser1 = this.cea608Parser2 = undefined;\n  }\n  initCea608Parsers() {\n    const channel1 = new OutputFilter(this, 'textTrack1');\n    const channel2 = new OutputFilter(this, 'textTrack2');\n    const channel3 = new OutputFilter(this, 'textTrack3');\n    const channel4 = new OutputFilter(this, 'textTrack4');\n    this.cea608Parser1 = new Cea608Parser(1, channel1, channel2);\n    this.cea608Parser2 = new Cea608Parser(3, channel3, channel4);\n  }\n  addCues(trackName, startTime, endTime, screen, cueRanges) {\n    // skip cues which overlap more than 50% with previously parsed time ranges\n    let merged = false;\n    for (let i = cueRanges.length; i--;) {\n      const cueRange = cueRanges[i];\n      const overlap = intersection(cueRange[0], cueRange[1], startTime, endTime);\n      if (overlap >= 0) {\n        cueRange[0] = Math.min(cueRange[0], startTime);\n        cueRange[1] = Math.max(cueRange[1], endTime);\n        merged = true;\n        if (overlap / (endTime - startTime) > 0.5) {\n          return;\n        }\n      }\n    }\n    if (!merged) {\n      cueRanges.push([startTime, endTime]);\n    }\n    if (this.config.renderTextTracksNatively) {\n      const track = this.captionsTracks[trackName];\n      this.Cues.newCue(track, startTime, endTime, screen);\n    } else {\n      const cues = this.Cues.newCue(null, startTime, endTime, screen);\n      this.hls.trigger(Events.CUES_PARSED, {\n        type: 'captions',\n        cues,\n        track: trackName\n      });\n    }\n  }\n\n  // Triggered when an initial PTS is found; used for synchronisation of WebVTT.\n  onInitPtsFound(event, {\n    frag,\n    id,\n    initPTS,\n    timescale\n  }) {\n    const {\n      unparsedVttFrags\n    } = this;\n    if (id === PlaylistLevelType.MAIN) {\n      this.initPTS[frag.cc] = {\n        baseTime: initPTS,\n        timescale\n      };\n    }\n\n    // Due to asynchronous processing, initial PTS may arrive later than the first VTT fragments are loaded.\n    // Parse any unparsed fragments upon receiving the initial PTS.\n    if (unparsedVttFrags.length) {\n      this.unparsedVttFrags = [];\n      unparsedVttFrags.forEach(data => {\n        if (this.initPTS[data.frag.cc]) {\n          this.onFragLoaded(Events.FRAG_LOADED, data);\n        } else {\n          this.hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n            success: false,\n            frag: data.frag,\n            error: new Error('Subtitle discontinuity domain does not match main')\n          });\n        }\n      });\n    }\n  }\n  getExistingTrack(label, language) {\n    const {\n      media\n    } = this;\n    if (media) {\n      for (let i = 0; i < media.textTracks.length; i++) {\n        const textTrack = media.textTracks[i];\n        if (canReuseVttTextTrack(textTrack, {\n          name: label,\n          lang: language,\n          characteristics: 'transcribes-spoken-dialog,describes-music-and-sound'})) {\n          return textTrack;\n        }\n      }\n    }\n    return null;\n  }\n  createCaptionsTrack(trackName) {\n    if (this.config.renderTextTracksNatively) {\n      this.createNativeTrack(trackName);\n    } else {\n      this.createNonNativeTrack(trackName);\n    }\n  }\n  createNativeTrack(trackName) {\n    if (this.captionsTracks[trackName]) {\n      return;\n    }\n    const {\n      captionsProperties,\n      captionsTracks,\n      media\n    } = this;\n    const {\n      label,\n      languageCode\n    } = captionsProperties[trackName];\n    // Enable reuse of existing text track.\n    const existingTrack = this.getExistingTrack(label, languageCode);\n    if (!existingTrack) {\n      const textTrack = this.createTextTrack('captions', label, languageCode);\n      if (textTrack) {\n        // Set a special property on the track so we know it's managed by Hls.js\n        textTrack[trackName] = true;\n        captionsTracks[trackName] = textTrack;\n      }\n    } else {\n      captionsTracks[trackName] = existingTrack;\n      clearCurrentCues(captionsTracks[trackName]);\n      sendAddTrackEvent(captionsTracks[trackName], media);\n    }\n  }\n  createNonNativeTrack(trackName) {\n    if (this.nonNativeCaptionsTracks[trackName]) {\n      return;\n    }\n    // Create a list of a single track for the provider to consume\n    const trackProperties = this.captionsProperties[trackName];\n    if (!trackProperties) {\n      return;\n    }\n    const label = trackProperties.label;\n    const track = {\n      _id: trackName,\n      label,\n      kind: 'captions',\n      default: trackProperties.media ? !!trackProperties.media.default : false,\n      closedCaptions: trackProperties.media\n    };\n    this.nonNativeCaptionsTracks[trackName] = track;\n    this.hls.trigger(Events.NON_NATIVE_TEXT_TRACKS_FOUND, {\n      tracks: [track]\n    });\n  }\n  createTextTrack(kind, label, lang) {\n    const media = this.media;\n    if (!media) {\n      return;\n    }\n    return media.addTextTrack(kind, label, lang);\n  }\n  onMediaAttaching(event, data) {\n    this.media = data.media;\n    if (!data.mediaSource) {\n      this._cleanTracks();\n    }\n  }\n  onMediaDetaching(event, data) {\n    const transferringMedia = !!data.transferMedia;\n    this.media = null;\n    if (transferringMedia) {\n      return;\n    }\n    const {\n      captionsTracks\n    } = this;\n    Object.keys(captionsTracks).forEach(trackName => {\n      clearCurrentCues(captionsTracks[trackName]);\n      delete captionsTracks[trackName];\n    });\n    this.nonNativeCaptionsTracks = {};\n  }\n  onManifestLoading() {\n    // Detect discontinuity in video fragment (CEA-608) parsing\n    this.lastCc = -1;\n    this.lastSn = -1;\n    this.lastPartIndex = -1;\n    // Detect discontinuity in subtitle manifests\n    this.prevCC = -1;\n    this.vttCCs = newVTTCCs();\n    // Reset tracks\n    this._cleanTracks();\n    this.tracks = [];\n    this.captionsTracks = {};\n    this.nonNativeCaptionsTracks = {};\n    this.textTracks = [];\n    this.unparsedVttFrags = [];\n    this.initPTS = [];\n    if (this.cea608Parser1 && this.cea608Parser2) {\n      this.cea608Parser1.reset();\n      this.cea608Parser2.reset();\n    }\n  }\n  _cleanTracks() {\n    // clear outdated subtitles\n    const {\n      media\n    } = this;\n    if (!media) {\n      return;\n    }\n    const textTracks = media.textTracks;\n    if (textTracks) {\n      for (let i = 0; i < textTracks.length; i++) {\n        clearCurrentCues(textTracks[i]);\n      }\n    }\n  }\n  onSubtitleTracksUpdated(event, data) {\n    const tracks = data.subtitleTracks || [];\n    const hasIMSC1 = tracks.some(track => track.textCodec === IMSC1_CODEC);\n    if (this.config.enableWebVTT || hasIMSC1 && this.config.enableIMSC1) {\n      const listIsIdentical = subtitleOptionsIdentical(this.tracks, tracks);\n      if (listIsIdentical) {\n        this.tracks = tracks;\n        return;\n      }\n      this.textTracks = [];\n      this.tracks = tracks;\n      if (this.config.renderTextTracksNatively) {\n        const media = this.media;\n        const inUseTracks = media ? filterSubtitleTracks(media.textTracks) : null;\n        this.tracks.forEach((track, index) => {\n          // Reuse tracks with the same label and lang, but do not reuse 608/708 tracks\n          let textTrack;\n          if (inUseTracks) {\n            let inUseTrack = null;\n            for (let i = 0; i < inUseTracks.length; i++) {\n              if (inUseTracks[i] && canReuseVttTextTrack(inUseTracks[i], track)) {\n                inUseTrack = inUseTracks[i];\n                inUseTracks[i] = null;\n                break;\n              }\n            }\n            if (inUseTrack) {\n              textTrack = inUseTrack;\n            }\n          }\n          if (textTrack) {\n            clearCurrentCues(textTrack);\n          } else {\n            const textTrackKind = captionsOrSubtitlesFromCharacteristics(track);\n            textTrack = this.createTextTrack(textTrackKind, track.name, track.lang);\n            if (textTrack) {\n              textTrack.mode = 'disabled';\n            }\n          }\n          if (textTrack) {\n            this.textTracks.push(textTrack);\n          }\n        });\n        // Warn when video element has captions or subtitle TextTracks carried over from another source\n        if (inUseTracks != null && inUseTracks.length) {\n          const unusedTextTracks = inUseTracks.filter(t => t !== null).map(t => t.label);\n          if (unusedTextTracks.length) {\n            this.hls.logger.warn(`Media element contains unused subtitle tracks: ${unusedTextTracks.join(', ')}. Replace media element for each source to clear TextTracks and captions menu.`);\n          }\n        }\n      } else if (this.tracks.length) {\n        // Create a list of tracks for the provider to consume\n        const tracksList = this.tracks.map(track => {\n          return {\n            label: track.name,\n            kind: track.type.toLowerCase(),\n            default: track.default,\n            subtitleTrack: track\n          };\n        });\n        this.hls.trigger(Events.NON_NATIVE_TEXT_TRACKS_FOUND, {\n          tracks: tracksList\n        });\n      }\n    }\n  }\n  onManifestLoaded(event, data) {\n    if (this.config.enableCEA708Captions && data.captions) {\n      data.captions.forEach(captionsTrack => {\n        const instreamIdMatch = /(?:CC|SERVICE)([1-4])/.exec(captionsTrack.instreamId);\n        if (!instreamIdMatch) {\n          return;\n        }\n        const trackName = `textTrack${instreamIdMatch[1]}`;\n        const trackProperties = this.captionsProperties[trackName];\n        if (!trackProperties) {\n          return;\n        }\n        trackProperties.label = captionsTrack.name;\n        if (captionsTrack.lang) {\n          // optional attribute\n          trackProperties.languageCode = captionsTrack.lang;\n        }\n        trackProperties.media = captionsTrack;\n      });\n    }\n  }\n  closedCaptionsForLevel(frag) {\n    const level = this.hls.levels[frag.level];\n    return level == null ? void 0 : level.attrs['CLOSED-CAPTIONS'];\n  }\n  onFragLoading(event, data) {\n    // if this frag isn't contiguous, clear the parser so cues with bad start/end times aren't added to the textTrack\n    if (this.enabled && data.frag.type === PlaylistLevelType.MAIN) {\n      var _data$part$index, _data$part;\n      const {\n        cea608Parser1,\n        cea608Parser2,\n        lastSn\n      } = this;\n      const {\n        cc,\n        sn\n      } = data.frag;\n      const partIndex = (_data$part$index = (_data$part = data.part) == null ? void 0 : _data$part.index) != null ? _data$part$index : -1;\n      if (cea608Parser1 && cea608Parser2) {\n        if (sn !== lastSn + 1 || sn === lastSn && partIndex !== this.lastPartIndex + 1 || cc !== this.lastCc) {\n          cea608Parser1.reset();\n          cea608Parser2.reset();\n        }\n      }\n      this.lastCc = cc;\n      this.lastSn = sn;\n      this.lastPartIndex = partIndex;\n    }\n  }\n  onFragLoaded(event, data) {\n    const {\n      frag,\n      payload\n    } = data;\n    if (frag.type === PlaylistLevelType.SUBTITLE) {\n      // If fragment is subtitle type, parse as WebVTT.\n      if (payload.byteLength) {\n        const decryptData = frag.decryptdata;\n        // fragment after decryption has a stats object\n        const decrypted = 'stats' in data;\n        // If the subtitles are not encrypted, parse VTTs now. Otherwise, we need to wait.\n        if (decryptData == null || !decryptData.encrypted || decrypted) {\n          const trackPlaylistMedia = this.tracks[frag.level];\n          const vttCCs = this.vttCCs;\n          if (!vttCCs[frag.cc]) {\n            vttCCs[frag.cc] = {\n              start: frag.start,\n              prevCC: this.prevCC,\n              new: true\n            };\n            this.prevCC = frag.cc;\n          }\n          if (trackPlaylistMedia && trackPlaylistMedia.textCodec === IMSC1_CODEC) {\n            this._parseIMSC1(frag, payload);\n          } else {\n            this._parseVTTs(data);\n          }\n        }\n      } else {\n        // In case there is no payload, finish unsuccessfully.\n        this.hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n          success: false,\n          frag,\n          error: new Error('Empty subtitle payload')\n        });\n      }\n    }\n  }\n  _parseIMSC1(frag, payload) {\n    const hls = this.hls;\n    parseIMSC1(payload, this.initPTS[frag.cc], cues => {\n      this._appendCues(cues, frag.level);\n      hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n        success: true,\n        frag: frag\n      });\n    }, error => {\n      hls.logger.log(`Failed to parse IMSC1: ${error}`);\n      hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n        success: false,\n        frag: frag,\n        error\n      });\n    });\n  }\n  _parseVTTs(data) {\n    var _frag$initSegment;\n    const {\n      frag,\n      payload\n    } = data;\n    // We need an initial synchronisation PTS. Store fragments as long as none has arrived\n    const {\n      initPTS,\n      unparsedVttFrags\n    } = this;\n    const maxAvCC = initPTS.length - 1;\n    if (!initPTS[frag.cc] && maxAvCC === -1) {\n      unparsedVttFrags.push(data);\n      return;\n    }\n    const hls = this.hls;\n    // Parse the WebVTT file contents.\n    const payloadWebVTT = (_frag$initSegment = frag.initSegment) != null && _frag$initSegment.data ? appendUint8Array(frag.initSegment.data, new Uint8Array(payload)).buffer : payload;\n    parseWebVTT(payloadWebVTT, this.initPTS[frag.cc], this.vttCCs, frag.cc, frag.start, cues => {\n      this._appendCues(cues, frag.level);\n      hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n        success: true,\n        frag: frag\n      });\n    }, error => {\n      const missingInitPTS = error.message === 'Missing initPTS for VTT MPEGTS';\n      if (missingInitPTS) {\n        unparsedVttFrags.push(data);\n      } else {\n        this._fallbackToIMSC1(frag, payload);\n      }\n      // Something went wrong while parsing. Trigger event with success false.\n      hls.logger.log(`Failed to parse VTT cue: ${error}`);\n      if (missingInitPTS && maxAvCC > frag.cc) {\n        return;\n      }\n      hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n        success: false,\n        frag: frag,\n        error\n      });\n    });\n  }\n  _fallbackToIMSC1(frag, payload) {\n    // If textCodec is unknown, try parsing as IMSC1. Set textCodec based on the result\n    const trackPlaylistMedia = this.tracks[frag.level];\n    if (!trackPlaylistMedia.textCodec) {\n      parseIMSC1(payload, this.initPTS[frag.cc], () => {\n        trackPlaylistMedia.textCodec = IMSC1_CODEC;\n        this._parseIMSC1(frag, payload);\n      }, () => {\n        trackPlaylistMedia.textCodec = 'wvtt';\n      });\n    }\n  }\n  _appendCues(cues, fragLevel) {\n    const hls = this.hls;\n    if (this.config.renderTextTracksNatively) {\n      const textTrack = this.textTracks[fragLevel];\n      // WebVTTParser.parse is an async method and if the currently selected text track mode is set to \"disabled\"\n      // before parsing is done then don't try to access currentTrack.cues.getCueById as cues will be null\n      // and trying to access getCueById method of cues will throw an exception\n      // Because we check if the mode is disabled, we can force check `cues` below. They can't be null.\n      if (!textTrack || textTrack.mode === 'disabled') {\n        return;\n      }\n      cues.forEach(cue => addCueToTrack(textTrack, cue));\n    } else {\n      const currentTrack = this.tracks[fragLevel];\n      if (!currentTrack) {\n        return;\n      }\n      const track = currentTrack.default ? 'default' : 'subtitles' + fragLevel;\n      hls.trigger(Events.CUES_PARSED, {\n        type: 'subtitles',\n        cues,\n        track\n      });\n    }\n  }\n  onFragDecrypted(event, data) {\n    const {\n      frag\n    } = data;\n    if (frag.type === PlaylistLevelType.SUBTITLE) {\n      this.onFragLoaded(Events.FRAG_LOADED, data);\n    }\n  }\n  onSubtitleTracksCleared() {\n    this.tracks = [];\n    this.captionsTracks = {};\n  }\n  onFragParsingUserdata(event, data) {\n    if (!this.enabled || !this.config.enableCEA708Captions) {\n      return;\n    }\n    const {\n      frag,\n      samples\n    } = data;\n    if (frag.type === PlaylistLevelType.MAIN && this.closedCaptionsForLevel(frag) === 'NONE') {\n      return;\n    }\n    // If the event contains captions (found in the bytes property), push all bytes into the parser immediately\n    // It will create the proper timestamps based on the PTS value\n    for (let i = 0; i < samples.length; i++) {\n      const ccBytes = samples[i].bytes;\n      if (ccBytes) {\n        if (!this.cea608Parser1) {\n          this.initCea608Parsers();\n        }\n        const ccdatas = this.extractCea608Data(ccBytes);\n        this.cea608Parser1.addData(samples[i].pts, ccdatas[0]);\n        this.cea608Parser2.addData(samples[i].pts, ccdatas[1]);\n      }\n    }\n  }\n  onBufferFlushing(event, {\n    startOffset,\n    endOffset,\n    endOffsetSubtitles,\n    type\n  }) {\n    const {\n      media\n    } = this;\n    if (!media || media.currentTime < endOffset) {\n      return;\n    }\n    // Clear 608 caption cues from the captions TextTracks when the video back buffer is flushed\n    // Forward cues are never removed because we can loose streamed 608 content from recent fragments\n    if (!type || type === 'video') {\n      const {\n        captionsTracks\n      } = this;\n      Object.keys(captionsTracks).forEach(trackName => removeCuesInRange(captionsTracks[trackName], startOffset, endOffset));\n    }\n    if (this.config.renderTextTracksNatively) {\n      // Clear VTT/IMSC1 subtitle cues from the subtitle TextTracks when the back buffer is flushed\n      if (startOffset === 0 && endOffsetSubtitles !== undefined) {\n        const {\n          textTracks\n        } = this;\n        Object.keys(textTracks).forEach(trackName => removeCuesInRange(textTracks[trackName], startOffset, endOffsetSubtitles));\n      }\n    }\n  }\n  extractCea608Data(byteArray) {\n    const actualCCBytes = [[], []];\n    const count = byteArray[0] & 0x1f;\n    let position = 2;\n    for (let j = 0; j < count; j++) {\n      const tmpByte = byteArray[position++];\n      const ccbyte1 = 0x7f & byteArray[position++];\n      const ccbyte2 = 0x7f & byteArray[position++];\n      if (ccbyte1 === 0 && ccbyte2 === 0) {\n        continue;\n      }\n      const ccValid = (0x04 & tmpByte) !== 0; // Support all four channels\n      if (ccValid) {\n        const ccType = 0x03 & tmpByte;\n        if (0x00 /* CEA608 field1*/ === ccType || 0x01 /* CEA608 field2*/ === ccType) {\n          // Exclude CEA708 CC data.\n          actualCCBytes[ccType].push(ccbyte1);\n          actualCCBytes[ccType].push(ccbyte2);\n        }\n      }\n    }\n    return actualCCBytes;\n  }\n}\nfunction captionsOrSubtitlesFromCharacteristics(track) {\n  if (track.characteristics) {\n    if (/transcribes-spoken-dialog/gi.test(track.characteristics) && /describes-music-and-sound/gi.test(track.characteristics)) {\n      return 'captions';\n    }\n  }\n  return 'subtitles';\n}\nfunction canReuseVttTextTrack(inUseTrack, manifestTrack) {\n  return !!inUseTrack && inUseTrack.kind === captionsOrSubtitlesFromCharacteristics(manifestTrack) && subtitleTrackMatchesTextTrack(manifestTrack, inUseTrack);\n}\nfunction intersection(x1, x2, y1, y2) {\n  return Math.min(x2, y2) - Math.max(x1, y1);\n}\nfunction newVTTCCs() {\n  return {\n    ccOffset: 0,\n    presentationOffset: 0,\n    0: {\n      start: 0,\n      prevCC: -1,\n      new: true\n    }\n  };\n}\n\nconst WHITESPACE_CHAR = /\\s/;\nconst Cues = {\n  newCue(track, startTime, endTime, captionScreen) {\n    const result = [];\n    let row;\n    // the type data states this is VTTCue, but it can potentially be a TextTrackCue on old browsers\n    let cue;\n    let indenting;\n    let indent;\n    let text;\n    const Cue = self.VTTCue || self.TextTrackCue;\n    for (let r = 0; r < captionScreen.rows.length; r++) {\n      row = captionScreen.rows[r];\n      indenting = true;\n      indent = 0;\n      text = '';\n      if (!row.isEmpty()) {\n        var _track$cues;\n        for (let c = 0; c < row.chars.length; c++) {\n          if (WHITESPACE_CHAR.test(row.chars[c].uchar) && indenting) {\n            indent++;\n          } else {\n            text += row.chars[c].uchar;\n            indenting = false;\n          }\n        }\n        // To be used for cleaning-up orphaned roll-up captions\n        row.cueStartTime = startTime;\n\n        // Give a slight bump to the endTime if it's equal to startTime to avoid a SyntaxError in IE\n        if (startTime === endTime) {\n          endTime += 0.0001;\n        }\n        if (indent >= 16) {\n          indent--;\n        } else {\n          indent++;\n        }\n        const cueText = fixLineBreaks(text.trim());\n        const id = generateCueId(startTime, endTime, cueText);\n\n        // If this cue already exists in the track do not push it\n        if (!(track != null && (_track$cues = track.cues) != null && _track$cues.getCueById(id))) {\n          cue = new Cue(startTime, endTime, cueText);\n          cue.id = id;\n          cue.line = r + 1;\n          cue.align = 'left';\n          // Clamp the position between 10 and 80 percent (CEA-608 PAC indent code)\n          // https://dvcs.w3.org/hg/text-tracks/raw-file/default/608toVTT/608toVTT.html#positioning-in-cea-608\n          // Firefox throws an exception and captions break with out of bounds 0-100 values\n          cue.position = 10 + Math.min(80, Math.floor(indent * 8 / 32) * 10);\n          result.push(cue);\n        }\n      }\n    }\n    if (track && result.length) {\n      // Sort bottom cues in reverse order so that they render in line order when overlapping in Chrome\n      result.sort((cueA, cueB) => {\n        if (cueA.line === 'auto' || cueB.line === 'auto') {\n          return 0;\n        }\n        if (cueA.line > 8 && cueB.line > 8) {\n          return cueB.line - cueA.line;\n        }\n        return cueA.line - cueB.line;\n      });\n      result.forEach(cue => addCueToTrack(track, cue));\n    }\n    return result;\n  }\n};\n\nfunction fetchSupported() {\n  if (\n  // @ts-ignore\n  self.fetch && self.AbortController && self.ReadableStream && self.Request) {\n    try {\n      new self.ReadableStream({}); // eslint-disable-line no-new\n      return true;\n    } catch (e) {\n      /* noop */\n    }\n  }\n  return false;\n}\nconst BYTERANGE = /(\\d+)-(\\d+)\\/(\\d+)/;\nclass FetchLoader {\n  constructor(config) {\n    this.fetchSetup = void 0;\n    this.requestTimeout = void 0;\n    this.request = null;\n    this.response = null;\n    this.controller = void 0;\n    this.context = null;\n    this.config = null;\n    this.callbacks = null;\n    this.stats = void 0;\n    this.loader = null;\n    this.fetchSetup = config.fetchSetup || getRequest;\n    this.controller = new self.AbortController();\n    this.stats = new LoadStats();\n  }\n  destroy() {\n    this.loader = this.callbacks = this.context = this.config = this.request = null;\n    this.abortInternal();\n    this.response = null;\n    // @ts-ignore\n    this.fetchSetup = this.controller = this.stats = null;\n  }\n  abortInternal() {\n    if (this.controller && !this.stats.loading.end) {\n      this.stats.aborted = true;\n      this.controller.abort();\n    }\n  }\n  abort() {\n    var _this$callbacks;\n    this.abortInternal();\n    if ((_this$callbacks = this.callbacks) != null && _this$callbacks.onAbort) {\n      this.callbacks.onAbort(this.stats, this.context, this.response);\n    }\n  }\n  load(context, config, callbacks) {\n    const stats = this.stats;\n    if (stats.loading.start) {\n      throw new Error('Loader can only be used once.');\n    }\n    stats.loading.start = self.performance.now();\n    const initParams = getRequestParameters(context, this.controller.signal);\n    const isArrayBuffer = context.responseType === 'arraybuffer';\n    const LENGTH = isArrayBuffer ? 'byteLength' : 'length';\n    const {\n      maxTimeToFirstByteMs,\n      maxLoadTimeMs\n    } = config.loadPolicy;\n    this.context = context;\n    this.config = config;\n    this.callbacks = callbacks;\n    this.request = this.fetchSetup(context, initParams);\n    self.clearTimeout(this.requestTimeout);\n    config.timeout = maxTimeToFirstByteMs && isFiniteNumber(maxTimeToFirstByteMs) ? maxTimeToFirstByteMs : maxLoadTimeMs;\n    this.requestTimeout = self.setTimeout(() => {\n      if (this.callbacks) {\n        this.abortInternal();\n        this.callbacks.onTimeout(stats, context, this.response);\n      }\n    }, config.timeout);\n    const fetchPromise = isPromise(this.request) ? this.request.then(self.fetch) : self.fetch(this.request);\n    fetchPromise.then(response => {\n      var _this$callbacks2;\n      this.response = this.loader = response;\n      const first = Math.max(self.performance.now(), stats.loading.start);\n      self.clearTimeout(this.requestTimeout);\n      config.timeout = maxLoadTimeMs;\n      this.requestTimeout = self.setTimeout(() => {\n        if (this.callbacks) {\n          this.abortInternal();\n          this.callbacks.onTimeout(stats, context, this.response);\n        }\n      }, maxLoadTimeMs - (first - stats.loading.start));\n      if (!response.ok) {\n        const {\n          status,\n          statusText\n        } = response;\n        throw new FetchError(statusText || 'fetch, bad network response', status, response);\n      }\n      stats.loading.first = first;\n      stats.total = getContentLength(response.headers) || stats.total;\n      const onProgress = (_this$callbacks2 = this.callbacks) == null ? void 0 : _this$callbacks2.onProgress;\n      if (onProgress && isFiniteNumber(config.highWaterMark)) {\n        return this.loadProgressively(response, stats, context, config.highWaterMark, onProgress);\n      }\n      if (isArrayBuffer) {\n        return response.arrayBuffer();\n      }\n      if (context.responseType === 'json') {\n        return response.json();\n      }\n      return response.text();\n    }).then(responseData => {\n      var _this$callbacks3, _this$callbacks4;\n      const response = this.response;\n      if (!response) {\n        throw new Error('loader destroyed');\n      }\n      self.clearTimeout(this.requestTimeout);\n      stats.loading.end = Math.max(self.performance.now(), stats.loading.first);\n      const total = responseData[LENGTH];\n      if (total) {\n        stats.loaded = stats.total = total;\n      }\n      const loaderResponse = {\n        url: response.url,\n        data: responseData,\n        code: response.status\n      };\n      const onProgress = (_this$callbacks3 = this.callbacks) == null ? void 0 : _this$callbacks3.onProgress;\n      if (onProgress && !isFiniteNumber(config.highWaterMark)) {\n        onProgress(stats, context, responseData, response);\n      }\n      (_this$callbacks4 = this.callbacks) == null ? void 0 : _this$callbacks4.onSuccess(loaderResponse, stats, context, response);\n    }).catch(error => {\n      var _this$callbacks5;\n      self.clearTimeout(this.requestTimeout);\n      if (stats.aborted) {\n        return;\n      }\n      // CORS errors result in an undefined code. Set it to 0 here to align with XHR's behavior\n      // when destroying, 'error' itself can be undefined\n      const code = !error ? 0 : error.code || 0;\n      const text = !error ? null : error.message;\n      (_this$callbacks5 = this.callbacks) == null ? void 0 : _this$callbacks5.onError({\n        code,\n        text\n      }, context, error ? error.details : null, stats);\n    });\n  }\n  getCacheAge() {\n    let result = null;\n    if (this.response) {\n      const ageHeader = this.response.headers.get('age');\n      result = ageHeader ? parseFloat(ageHeader) : null;\n    }\n    return result;\n  }\n  getResponseHeader(name) {\n    return this.response ? this.response.headers.get(name) : null;\n  }\n  loadProgressively(response, stats, context, highWaterMark = 0, onProgress) {\n    const chunkCache = new ChunkCache();\n    const reader = response.body.getReader();\n    const pump = () => {\n      return reader.read().then(data => {\n        if (data.done) {\n          if (chunkCache.dataLength) {\n            onProgress(stats, context, chunkCache.flush().buffer, response);\n          }\n          return Promise.resolve(new ArrayBuffer(0));\n        }\n        const chunk = data.value;\n        const len = chunk.length;\n        stats.loaded += len;\n        if (len < highWaterMark || chunkCache.dataLength) {\n          // The current chunk is too small to to be emitted or the cache already has data\n          // Push it to the cache\n          chunkCache.push(chunk);\n          if (chunkCache.dataLength >= highWaterMark) {\n            // flush in order to join the typed arrays\n            onProgress(stats, context, chunkCache.flush().buffer, response);\n          }\n        } else {\n          // If there's nothing cached already, and the chache is large enough\n          // just emit the progress event\n          onProgress(stats, context, chunk.buffer, response);\n        }\n        return pump();\n      }).catch(() => {\n        /* aborted */\n        return Promise.reject();\n      });\n    };\n    return pump();\n  }\n}\nfunction getRequestParameters(context, signal) {\n  const initParams = {\n    method: 'GET',\n    mode: 'cors',\n    credentials: 'same-origin',\n    signal,\n    headers: new self.Headers(_extends({}, context.headers))\n  };\n  if (context.rangeEnd) {\n    initParams.headers.set('Range', 'bytes=' + context.rangeStart + '-' + String(context.rangeEnd - 1));\n  }\n  return initParams;\n}\nfunction getByteRangeLength(byteRangeHeader) {\n  const result = BYTERANGE.exec(byteRangeHeader);\n  if (result) {\n    return parseInt(result[2]) - parseInt(result[1]) + 1;\n  }\n}\nfunction getContentLength(headers) {\n  const contentRange = headers.get('Content-Range');\n  if (contentRange) {\n    const byteRangeLength = getByteRangeLength(contentRange);\n    if (isFiniteNumber(byteRangeLength)) {\n      return byteRangeLength;\n    }\n  }\n  const contentLength = headers.get('Content-Length');\n  if (contentLength) {\n    return parseInt(contentLength);\n  }\n}\nfunction getRequest(context, initParams) {\n  return new self.Request(context.url, initParams);\n}\nclass FetchError extends Error {\n  constructor(message, code, details) {\n    super(message);\n    this.code = void 0;\n    this.details = void 0;\n    this.code = code;\n    this.details = details;\n  }\n}\n\nconst AGE_HEADER_LINE_REGEX = /^age:\\s*[\\d.]+\\s*$/im;\nclass XhrLoader {\n  constructor(config) {\n    this.xhrSetup = void 0;\n    this.requestTimeout = void 0;\n    this.retryTimeout = void 0;\n    this.retryDelay = void 0;\n    this.config = null;\n    this.callbacks = null;\n    this.context = null;\n    this.loader = null;\n    this.stats = void 0;\n    this.xhrSetup = config ? config.xhrSetup || null : null;\n    this.stats = new LoadStats();\n    this.retryDelay = 0;\n  }\n  destroy() {\n    this.callbacks = null;\n    this.abortInternal();\n    this.loader = null;\n    this.config = null;\n    this.context = null;\n    this.xhrSetup = null;\n  }\n  abortInternal() {\n    const loader = this.loader;\n    self.clearTimeout(this.requestTimeout);\n    self.clearTimeout(this.retryTimeout);\n    if (loader) {\n      loader.onreadystatechange = null;\n      loader.onprogress = null;\n      if (loader.readyState !== 4) {\n        this.stats.aborted = true;\n        loader.abort();\n      }\n    }\n  }\n  abort() {\n    var _this$callbacks;\n    this.abortInternal();\n    if ((_this$callbacks = this.callbacks) != null && _this$callbacks.onAbort) {\n      this.callbacks.onAbort(this.stats, this.context, this.loader);\n    }\n  }\n  load(context, config, callbacks) {\n    if (this.stats.loading.start) {\n      throw new Error('Loader can only be used once.');\n    }\n    this.stats.loading.start = self.performance.now();\n    this.context = context;\n    this.config = config;\n    this.callbacks = callbacks;\n    this.loadInternal();\n  }\n  loadInternal() {\n    const {\n      config,\n      context\n    } = this;\n    if (!config || !context) {\n      return;\n    }\n    const xhr = this.loader = new self.XMLHttpRequest();\n    const stats = this.stats;\n    stats.loading.first = 0;\n    stats.loaded = 0;\n    stats.aborted = false;\n    const xhrSetup = this.xhrSetup;\n    if (xhrSetup) {\n      Promise.resolve().then(() => {\n        if (this.loader !== xhr || this.stats.aborted) return;\n        return xhrSetup(xhr, context.url);\n      }).catch(error => {\n        if (this.loader !== xhr || this.stats.aborted) return;\n        xhr.open('GET', context.url, true);\n        return xhrSetup(xhr, context.url);\n      }).then(() => {\n        if (this.loader !== xhr || this.stats.aborted) return;\n        this.openAndSendXhr(xhr, context, config);\n      }).catch(error => {\n        var _this$callbacks2;\n        // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS\n        (_this$callbacks2 = this.callbacks) == null ? void 0 : _this$callbacks2.onError({\n          code: xhr.status,\n          text: error.message\n        }, context, xhr, stats);\n        return;\n      });\n    } else {\n      this.openAndSendXhr(xhr, context, config);\n    }\n  }\n  openAndSendXhr(xhr, context, config) {\n    if (!xhr.readyState) {\n      xhr.open('GET', context.url, true);\n    }\n    const headers = context.headers;\n    const {\n      maxTimeToFirstByteMs,\n      maxLoadTimeMs\n    } = config.loadPolicy;\n    if (headers) {\n      for (const header in headers) {\n        xhr.setRequestHeader(header, headers[header]);\n      }\n    }\n    if (context.rangeEnd) {\n      xhr.setRequestHeader('Range', 'bytes=' + context.rangeStart + '-' + (context.rangeEnd - 1));\n    }\n    xhr.onreadystatechange = this.readystatechange.bind(this);\n    xhr.onprogress = this.loadprogress.bind(this);\n    xhr.responseType = context.responseType;\n    // setup timeout before we perform request\n    self.clearTimeout(this.requestTimeout);\n    config.timeout = maxTimeToFirstByteMs && isFiniteNumber(maxTimeToFirstByteMs) ? maxTimeToFirstByteMs : maxLoadTimeMs;\n    this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.timeout);\n    xhr.send();\n  }\n  readystatechange() {\n    const {\n      context,\n      loader: xhr,\n      stats\n    } = this;\n    if (!context || !xhr) {\n      return;\n    }\n    const readyState = xhr.readyState;\n    const config = this.config;\n\n    // don't proceed if xhr has been aborted\n    if (stats.aborted) {\n      return;\n    }\n\n    // >= HEADERS_RECEIVED\n    if (readyState >= 2) {\n      if (stats.loading.first === 0) {\n        stats.loading.first = Math.max(self.performance.now(), stats.loading.start);\n        // readyState >= 2 AND readyState !==4 (readyState = HEADERS_RECEIVED || LOADING) rearm timeout as xhr not finished yet\n        if (config.timeout !== config.loadPolicy.maxLoadTimeMs) {\n          self.clearTimeout(this.requestTimeout);\n          config.timeout = config.loadPolicy.maxLoadTimeMs;\n          this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.loadPolicy.maxLoadTimeMs - (stats.loading.first - stats.loading.start));\n        }\n      }\n      if (readyState === 4) {\n        self.clearTimeout(this.requestTimeout);\n        xhr.onreadystatechange = null;\n        xhr.onprogress = null;\n        const status = xhr.status;\n        // http status between 200 to 299 are all successful\n        const useResponseText = xhr.responseType === 'text' ? xhr.responseText : null;\n        if (status >= 200 && status < 300) {\n          const data = useResponseText != null ? useResponseText : xhr.response;\n          if (data != null) {\n            var _this$callbacks3, _this$callbacks4;\n            stats.loading.end = Math.max(self.performance.now(), stats.loading.first);\n            const len = xhr.responseType === 'arraybuffer' ? data.byteLength : data.length;\n            stats.loaded = stats.total = len;\n            stats.bwEstimate = stats.total * 8000 / (stats.loading.end - stats.loading.first);\n            const onProgress = (_this$callbacks3 = this.callbacks) == null ? void 0 : _this$callbacks3.onProgress;\n            if (onProgress) {\n              onProgress(stats, context, data, xhr);\n            }\n            const _response = {\n              url: xhr.responseURL,\n              data: data,\n              code: status\n            };\n            (_this$callbacks4 = this.callbacks) == null ? void 0 : _this$callbacks4.onSuccess(_response, stats, context, xhr);\n            return;\n          }\n        }\n\n        // Handle bad status or nullish response\n        const retryConfig = config.loadPolicy.errorRetry;\n        const retryCount = stats.retry;\n        // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error\n        const response = {\n          url: context.url,\n          data: undefined,\n          code: status\n        };\n        if (shouldRetry(retryConfig, retryCount, false, response)) {\n          this.retry(retryConfig);\n        } else {\n          var _this$callbacks5;\n          logger.error(`${status} while loading ${context.url}`);\n          (_this$callbacks5 = this.callbacks) == null ? void 0 : _this$callbacks5.onError({\n            code: status,\n            text: xhr.statusText\n          }, context, xhr, stats);\n        }\n      }\n    }\n  }\n  loadtimeout() {\n    if (!this.config) return;\n    const retryConfig = this.config.loadPolicy.timeoutRetry;\n    const retryCount = this.stats.retry;\n    if (shouldRetry(retryConfig, retryCount, true)) {\n      this.retry(retryConfig);\n    } else {\n      var _this$context;\n      logger.warn(`timeout while loading ${(_this$context = this.context) == null ? void 0 : _this$context.url}`);\n      const callbacks = this.callbacks;\n      if (callbacks) {\n        this.abortInternal();\n        callbacks.onTimeout(this.stats, this.context, this.loader);\n      }\n    }\n  }\n  retry(retryConfig) {\n    const {\n      context,\n      stats\n    } = this;\n    this.retryDelay = getRetryDelay(retryConfig, stats.retry);\n    stats.retry++;\n    logger.warn(`${status ? 'HTTP Status ' + status : 'Timeout'} while loading ${context == null ? void 0 : context.url}, retrying ${stats.retry}/${retryConfig.maxNumRetry} in ${this.retryDelay}ms`);\n    // abort and reset internal state\n    this.abortInternal();\n    this.loader = null;\n    // schedule retry\n    self.clearTimeout(this.retryTimeout);\n    this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay);\n  }\n  loadprogress(event) {\n    const stats = this.stats;\n    stats.loaded = event.loaded;\n    if (event.lengthComputable) {\n      stats.total = event.total;\n    }\n  }\n  getCacheAge() {\n    let result = null;\n    if (this.loader && AGE_HEADER_LINE_REGEX.test(this.loader.getAllResponseHeaders())) {\n      const ageHeader = this.loader.getResponseHeader('age');\n      result = ageHeader ? parseFloat(ageHeader) : null;\n    }\n    return result;\n  }\n  getResponseHeader(name) {\n    if (this.loader && new RegExp(`^${name}:\\\\s*[\\\\d.]+\\\\s*$`, 'im').test(this.loader.getAllResponseHeaders())) {\n      return this.loader.getResponseHeader(name);\n    }\n    return null;\n  }\n}\n\n/**\n * @deprecated use fragLoadPolicy.default\n */\n\n/**\n * @deprecated use manifestLoadPolicy.default and playlistLoadPolicy.default\n */\n\nconst defaultLoadPolicy = {\n  maxTimeToFirstByteMs: 8000,\n  maxLoadTimeMs: 20000,\n  timeoutRetry: null,\n  errorRetry: null\n};\n\n/**\n * @ignore\n * If possible, keep hlsDefaultConfig shallow\n * It is cloned whenever a new Hls instance is created, by keeping the config\n * shallow the properties are cloned, and we don't end up manipulating the default\n */\nconst hlsDefaultConfig = _objectSpread2(_objectSpread2({\n  autoStartLoad: true,\n  // used by stream-controller\n  startPosition: -1,\n  // used by stream-controller\n  defaultAudioCodec: undefined,\n  // used by stream-controller\n  debug: false,\n  // used by logger\n  capLevelOnFPSDrop: false,\n  // used by fps-controller\n  capLevelToPlayerSize: false,\n  // used by cap-level-controller\n  ignoreDevicePixelRatio: false,\n  // used by cap-level-controller\n  maxDevicePixelRatio: Number.POSITIVE_INFINITY,\n  // used by cap-level-controller\n  preferManagedMediaSource: true,\n  initialLiveManifestSize: 1,\n  // used by stream-controller\n  maxBufferLength: 30,\n  // used by stream-controller\n  backBufferLength: Infinity,\n  // used by buffer-controller\n  frontBufferFlushThreshold: Infinity,\n  startOnSegmentBoundary: false,\n  // used by stream-controller\n  maxBufferSize: 60 * 1000 * 1000,\n  // used by stream-controller\n  maxFragLookUpTolerance: 0.25,\n  // used by stream-controller\n  maxBufferHole: 0.1,\n  // used by stream-controller and gap-controller\n  detectStallWithCurrentTimeMs: 1250,\n  // used by gap-controller\n  highBufferWatchdogPeriod: 2,\n  // used by gap-controller\n  nudgeOffset: 0.1,\n  // used by gap-controller\n  nudgeMaxRetry: 3,\n  // used by gap-controller\n  nudgeOnVideoHole: true,\n  // used by gap-controller\n  liveSyncMode: 'edge',\n  // used by stream-controller\n  liveSyncDurationCount: 3,\n  // used by latency-controller\n  liveSyncOnStallIncrease: 1,\n  // used by latency-controller\n  liveMaxLatencyDurationCount: Infinity,\n  // used by latency-controller\n  liveSyncDuration: undefined,\n  // used by latency-controller\n  liveMaxLatencyDuration: undefined,\n  // used by latency-controller\n  maxLiveSyncPlaybackRate: 1,\n  // used by latency-controller\n  liveDurationInfinity: false,\n  // used by buffer-controller\n  /**\n   * @deprecated use backBufferLength\n   */\n  liveBackBufferLength: null,\n  // used by buffer-controller\n  maxMaxBufferLength: 600,\n  // used by stream-controller\n  enableWorker: true,\n  // used by transmuxer\n  workerPath: null,\n  // used by transmuxer\n  enableSoftwareAES: true,\n  // used by decrypter\n  startLevel: undefined,\n  // used by level-controller\n  startFragPrefetch: false,\n  // used by stream-controller\n  fpsDroppedMonitoringPeriod: 5000,\n  // used by fps-controller\n  fpsDroppedMonitoringThreshold: 0.2,\n  // used by fps-controller\n  appendErrorMaxRetry: 3,\n  // used by buffer-controller\n  ignorePlaylistParsingErrors: false,\n  loader: XhrLoader,\n  // loader: FetchLoader,\n  fLoader: undefined,\n  // used by fragment-loader\n  pLoader: undefined,\n  // used by playlist-loader\n  xhrSetup: undefined,\n  // used by xhr-loader\n  licenseXhrSetup: undefined,\n  // used by eme-controller\n  licenseResponseCallback: undefined,\n  // used by eme-controller\n  abrController: AbrController,\n  bufferController: BufferController,\n  capLevelController: CapLevelController,\n  errorController: ErrorController,\n  fpsController: FPSController,\n  stretchShortVideoTrack: false,\n  // used by mp4-remuxer\n  maxAudioFramesDrift: 1,\n  // used by mp4-remuxer\n  forceKeyFrameOnDiscontinuity: true,\n  // used by ts-demuxer\n  abrEwmaFastLive: 3,\n  // used by abr-controller\n  abrEwmaSlowLive: 9,\n  // used by abr-controller\n  abrEwmaFastVoD: 3,\n  // used by abr-controller\n  abrEwmaSlowVoD: 9,\n  // used by abr-controller\n  abrEwmaDefaultEstimate: 5e5,\n  // 500 kbps  // used by abr-controller\n  abrEwmaDefaultEstimateMax: 5e6,\n  // 5 mbps\n  abrBandWidthFactor: 0.95,\n  // used by abr-controller\n  abrBandWidthUpFactor: 0.7,\n  // used by abr-controller\n  abrMaxWithRealBitrate: false,\n  // used by abr-controller\n  maxStarvationDelay: 4,\n  // used by abr-controller\n  maxLoadingDelay: 4,\n  // used by abr-controller\n  minAutoBitrate: 0,\n  // used by hls\n  emeEnabled: false,\n  // used by eme-controller\n  widevineLicenseUrl: undefined,\n  // used by eme-controller\n  drmSystems: {},\n  // used by eme-controller\n  drmSystemOptions: {},\n  // used by eme-controller\n  requestMediaKeySystemAccessFunc: requestMediaKeySystemAccess ,\n  // used by eme-controller\n  requireKeySystemAccessOnStart: false,\n  // used by eme-controller\n  testBandwidth: true,\n  progressive: false,\n  lowLatencyMode: true,\n  cmcd: undefined,\n  enableDateRangeMetadataCues: true,\n  enableEmsgMetadataCues: true,\n  enableEmsgKLVMetadata: false,\n  enableID3MetadataCues: true,\n  enableInterstitialPlayback: true,\n  interstitialAppendInPlace: true,\n  interstitialLiveLookAhead: 10,\n  useMediaCapabilities: true,\n  preserveManualLevelOnError: false,\n  certLoadPolicy: {\n    default: defaultLoadPolicy\n  },\n  keyLoadPolicy: {\n    default: {\n      maxTimeToFirstByteMs: 8000,\n      maxLoadTimeMs: 20000,\n      timeoutRetry: {\n        maxNumRetry: 1,\n        retryDelayMs: 1000,\n        maxRetryDelayMs: 20000,\n        backoff: 'linear'\n      },\n      errorRetry: {\n        maxNumRetry: 8,\n        retryDelayMs: 1000,\n        maxRetryDelayMs: 20000,\n        backoff: 'linear'\n      }\n    }\n  },\n  manifestLoadPolicy: {\n    default: {\n      maxTimeToFirstByteMs: Infinity,\n      maxLoadTimeMs: 20000,\n      timeoutRetry: {\n        maxNumRetry: 2,\n        retryDelayMs: 0,\n        maxRetryDelayMs: 0\n      },\n      errorRetry: {\n        maxNumRetry: 1,\n        retryDelayMs: 1000,\n        maxRetryDelayMs: 8000\n      }\n    }\n  },\n  playlistLoadPolicy: {\n    default: {\n      maxTimeToFirstByteMs: 10000,\n      maxLoadTimeMs: 20000,\n      timeoutRetry: {\n        maxNumRetry: 2,\n        retryDelayMs: 0,\n        maxRetryDelayMs: 0\n      },\n      errorRetry: {\n        maxNumRetry: 2,\n        retryDelayMs: 1000,\n        maxRetryDelayMs: 8000\n      }\n    }\n  },\n  fragLoadPolicy: {\n    default: {\n      maxTimeToFirstByteMs: 10000,\n      maxLoadTimeMs: 120000,\n      timeoutRetry: {\n        maxNumRetry: 4,\n        retryDelayMs: 0,\n        maxRetryDelayMs: 0\n      },\n      errorRetry: {\n        maxNumRetry: 6,\n        retryDelayMs: 1000,\n        maxRetryDelayMs: 8000\n      }\n    }\n  },\n  steeringManifestLoadPolicy: {\n    default: {\n      maxTimeToFirstByteMs: 10000,\n      maxLoadTimeMs: 20000,\n      timeoutRetry: {\n        maxNumRetry: 2,\n        retryDelayMs: 0,\n        maxRetryDelayMs: 0\n      },\n      errorRetry: {\n        maxNumRetry: 1,\n        retryDelayMs: 1000,\n        maxRetryDelayMs: 8000\n      }\n    } \n  },\n  interstitialAssetListLoadPolicy: {\n    default: {\n      maxTimeToFirstByteMs: 10000,\n      maxLoadTimeMs: 30000,\n      timeoutRetry: {\n        maxNumRetry: 0,\n        retryDelayMs: 0,\n        maxRetryDelayMs: 0\n      },\n      errorRetry: {\n        maxNumRetry: 0,\n        retryDelayMs: 1000,\n        maxRetryDelayMs: 8000\n      }\n    } \n  },\n  // These default settings are deprecated in favor of the above policies\n  // and are maintained for backwards compatibility\n  manifestLoadingTimeOut: 10000,\n  manifestLoadingMaxRetry: 1,\n  manifestLoadingRetryDelay: 1000,\n  manifestLoadingMaxRetryTimeout: 64000,\n  levelLoadingTimeOut: 10000,\n  levelLoadingMaxRetry: 4,\n  levelLoadingRetryDelay: 1000,\n  levelLoadingMaxRetryTimeout: 64000,\n  fragLoadingTimeOut: 20000,\n  fragLoadingMaxRetry: 6,\n  fragLoadingRetryDelay: 1000,\n  fragLoadingMaxRetryTimeout: 64000\n}, timelineConfig()), {}, {\n  subtitleStreamController: SubtitleStreamController ,\n  subtitleTrackController: SubtitleTrackController ,\n  timelineController: TimelineController ,\n  audioStreamController: AudioStreamController ,\n  audioTrackController: AudioTrackController ,\n  emeController: EMEController ,\n  cmcdController: CMCDController ,\n  contentSteeringController: ContentSteeringController ,\n  interstitialsController: InterstitialsController \n});\nfunction timelineConfig() {\n  return {\n    cueHandler: Cues,\n    // used by timeline-controller\n    enableWebVTT: true,\n    // used by timeline-controller\n    enableIMSC1: true,\n    // used by timeline-controller\n    enableCEA708Captions: true,\n    // used by timeline-controller\n    captionsTextTrack1Label: 'English',\n    // used by timeline-controller\n    captionsTextTrack1LanguageCode: 'en',\n    // used by timeline-controller\n    captionsTextTrack2Label: 'Spanish',\n    // used by timeline-controller\n    captionsTextTrack2LanguageCode: 'es',\n    // used by timeline-controller\n    captionsTextTrack3Label: 'Unknown CC',\n    // used by timeline-controller\n    captionsTextTrack3LanguageCode: '',\n    // used by timeline-controller\n    captionsTextTrack4Label: 'Unknown CC',\n    // used by timeline-controller\n    captionsTextTrack4LanguageCode: '',\n    // used by timeline-controller\n    renderTextTracksNatively: true\n  };\n}\n\n/**\n * @ignore\n */\nfunction mergeConfig(defaultConfig, userConfig, logger) {\n  if ((userConfig.liveSyncDurationCount || userConfig.liveMaxLatencyDurationCount) && (userConfig.liveSyncDuration || userConfig.liveMaxLatencyDuration)) {\n    throw new Error(\"Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration\");\n  }\n  if (userConfig.liveMaxLatencyDurationCount !== undefined && (userConfig.liveSyncDurationCount === undefined || userConfig.liveMaxLatencyDurationCount <= userConfig.liveSyncDurationCount)) {\n    throw new Error('Illegal hls.js config: \"liveMaxLatencyDurationCount\" must be greater than \"liveSyncDurationCount\"');\n  }\n  if (userConfig.liveMaxLatencyDuration !== undefined && (userConfig.liveSyncDuration === undefined || userConfig.liveMaxLatencyDuration <= userConfig.liveSyncDuration)) {\n    throw new Error('Illegal hls.js config: \"liveMaxLatencyDuration\" must be greater than \"liveSyncDuration\"');\n  }\n  const defaultsCopy = deepCpy(defaultConfig);\n\n  // Backwards compatibility with deprecated config values\n  const deprecatedSettingTypes = ['manifest', 'level', 'frag'];\n  const deprecatedSettings = ['TimeOut', 'MaxRetry', 'RetryDelay', 'MaxRetryTimeout'];\n  deprecatedSettingTypes.forEach(type => {\n    const policyName = `${type === 'level' ? 'playlist' : type}LoadPolicy`;\n    const policyNotSet = userConfig[policyName] === undefined;\n    const report = [];\n    deprecatedSettings.forEach(setting => {\n      const deprecatedSetting = `${type}Loading${setting}`;\n      const value = userConfig[deprecatedSetting];\n      if (value !== undefined && policyNotSet) {\n        report.push(deprecatedSetting);\n        const settings = defaultsCopy[policyName].default;\n        userConfig[policyName] = {\n          default: settings\n        };\n        switch (setting) {\n          case 'TimeOut':\n            settings.maxLoadTimeMs = value;\n            settings.maxTimeToFirstByteMs = value;\n            break;\n          case 'MaxRetry':\n            settings.errorRetry.maxNumRetry = value;\n            settings.timeoutRetry.maxNumRetry = value;\n            break;\n          case 'RetryDelay':\n            settings.errorRetry.retryDelayMs = value;\n            settings.timeoutRetry.retryDelayMs = value;\n            break;\n          case 'MaxRetryTimeout':\n            settings.errorRetry.maxRetryDelayMs = value;\n            settings.timeoutRetry.maxRetryDelayMs = value;\n            break;\n        }\n      }\n    });\n    if (report.length) {\n      logger.warn(`hls.js config: \"${report.join('\", \"')}\" setting(s) are deprecated, use \"${policyName}\": ${stringify(userConfig[policyName])}`);\n    }\n  });\n  return _objectSpread2(_objectSpread2({}, defaultsCopy), userConfig);\n}\nfunction deepCpy(obj) {\n  if (obj && typeof obj === 'object') {\n    if (Array.isArray(obj)) {\n      return obj.map(deepCpy);\n    }\n    return Object.keys(obj).reduce((result, key) => {\n      result[key] = deepCpy(obj[key]);\n      return result;\n    }, {});\n  }\n  return obj;\n}\n\n/**\n * @ignore\n */\nfunction enableStreamingMode(config, logger) {\n  const currentLoader = config.loader;\n  if (currentLoader !== FetchLoader && currentLoader !== XhrLoader) {\n    // If a developer has configured their own loader, respect that choice\n    logger.log('[config]: Custom loader detected, cannot enable progressive streaming');\n    config.progressive = false;\n  } else {\n    const canStreamProgressively = fetchSupported();\n    if (canStreamProgressively) {\n      config.loader = FetchLoader;\n      config.progressive = true;\n      config.enableSoftwareAES = true;\n      logger.log('[config]: Progressive streaming enabled, using FetchLoader');\n    }\n  }\n}\n\nconst MAX_START_GAP_JUMP = 2.0;\nconst SKIP_BUFFER_HOLE_STEP_SECONDS = 0.1;\nconst SKIP_BUFFER_RANGE_START = 0.05;\nconst TICK_INTERVAL$1 = 100;\nclass GapController extends TaskLoop {\n  constructor(hls, fragmentTracker) {\n    super('gap-controller', hls.logger);\n    this.hls = null;\n    this.fragmentTracker = null;\n    this.media = null;\n    this.mediaSource = void 0;\n    this.nudgeRetry = 0;\n    this.stallReported = false;\n    this.stalled = null;\n    this.moved = false;\n    this.seeking = false;\n    this.buffered = {};\n    this.lastCurrentTime = 0;\n    this.ended = 0;\n    this.waiting = 0;\n    this.onMediaPlaying = () => {\n      this.ended = 0;\n      this.waiting = 0;\n    };\n    this.onMediaWaiting = () => {\n      var _this$media;\n      if ((_this$media = this.media) != null && _this$media.seeking) {\n        return;\n      }\n      this.waiting = self.performance.now();\n      this.tick();\n    };\n    this.onMediaEnded = () => {\n      if (this.hls) {\n        var _this$media2;\n        // ended is set when triggering MEDIA_ENDED so that we do not trigger it again on stall or on tick with media.ended\n        this.ended = ((_this$media2 = this.media) == null ? void 0 : _this$media2.currentTime) || 1;\n        this.hls.trigger(Events.MEDIA_ENDED, {\n          stalled: false\n        });\n      }\n    };\n    this.hls = hls;\n    this.fragmentTracker = fragmentTracker;\n    this.registerListeners();\n  }\n  registerListeners() {\n    const {\n      hls\n    } = this;\n    if (hls) {\n      hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n      hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n      hls.on(Events.BUFFER_APPENDED, this.onBufferAppended, this);\n    }\n  }\n  unregisterListeners() {\n    const {\n      hls\n    } = this;\n    if (hls) {\n      hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n      hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n      hls.off(Events.BUFFER_APPENDED, this.onBufferAppended, this);\n    }\n  }\n  destroy() {\n    super.destroy();\n    this.unregisterListeners();\n    this.media = this.hls = this.fragmentTracker = null;\n    this.mediaSource = undefined;\n  }\n  onMediaAttached(event, data) {\n    this.setInterval(TICK_INTERVAL$1);\n    this.mediaSource = data.mediaSource;\n    const media = this.media = data.media;\n    addEventListener(media, 'playing', this.onMediaPlaying);\n    addEventListener(media, 'waiting', this.onMediaWaiting);\n    addEventListener(media, 'ended', this.onMediaEnded);\n  }\n  onMediaDetaching(event, data) {\n    this.clearInterval();\n    const {\n      media\n    } = this;\n    if (media) {\n      removeEventListener(media, 'playing', this.onMediaPlaying);\n      removeEventListener(media, 'waiting', this.onMediaWaiting);\n      removeEventListener(media, 'ended', this.onMediaEnded);\n      this.media = null;\n    }\n    this.mediaSource = undefined;\n  }\n  onBufferAppended(event, data) {\n    this.buffered = data.timeRanges;\n  }\n  get hasBuffered() {\n    return Object.keys(this.buffered).length > 0;\n  }\n  tick() {\n    var _this$media3;\n    if (!((_this$media3 = this.media) != null && _this$media3.readyState) || !this.hasBuffered) {\n      return;\n    }\n    const currentTime = this.media.currentTime;\n    this.poll(currentTime, this.lastCurrentTime);\n    this.lastCurrentTime = currentTime;\n  }\n\n  /**\n   * Checks if the playhead is stuck within a gap, and if so, attempts to free it.\n   * A gap is an unbuffered range between two buffered ranges (or the start and the first buffered range).\n   *\n   * @param lastCurrentTime - Previously read playhead position\n   */\n  poll(currentTime, lastCurrentTime) {\n    var _this$hls, _this$hls2;\n    const config = (_this$hls = this.hls) == null ? void 0 : _this$hls.config;\n    if (!config) {\n      return;\n    }\n    const media = this.media;\n    if (!media) {\n      return;\n    }\n    const {\n      seeking\n    } = media;\n    const seeked = this.seeking && !seeking;\n    const beginSeek = !this.seeking && seeking;\n    const pausedEndedOrHalted = media.paused && !seeking || media.ended || media.playbackRate === 0;\n    this.seeking = seeking;\n\n    // The playhead is moving, no-op\n    if (currentTime !== lastCurrentTime) {\n      if (lastCurrentTime) {\n        this.ended = 0;\n      }\n      this.moved = true;\n      if (!seeking) {\n        this.nudgeRetry = 0;\n        // When crossing between buffered video time ranges, but not audio, flush pipeline with seek (Chrome)\n        if (config.nudgeOnVideoHole && !pausedEndedOrHalted && currentTime > lastCurrentTime) {\n          this.nudgeOnVideoHole(currentTime, lastCurrentTime);\n        }\n      }\n      if (this.waiting === 0) {\n        this.stallResolved(currentTime);\n      }\n      return;\n    }\n\n    // Clear stalled state when beginning or finishing seeking so that we don't report stalls coming out of a seek\n    if (beginSeek || seeked) {\n      if (seeked) {\n        this.stallResolved(currentTime);\n      }\n      return;\n    }\n\n    // The playhead should not be moving\n    if (pausedEndedOrHalted) {\n      this.nudgeRetry = 0;\n      this.stallResolved(currentTime);\n      // Fire MEDIA_ENDED to workaround event not being dispatched by browser\n      if (!this.ended && media.ended && this.hls) {\n        this.ended = currentTime || 1;\n        this.hls.trigger(Events.MEDIA_ENDED, {\n          stalled: false\n        });\n      }\n      return;\n    }\n    if (!BufferHelper.getBuffered(media).length) {\n      this.nudgeRetry = 0;\n      return;\n    }\n\n    // Resolve stalls at buffer holes using the main buffer, whose ranges are the intersections of the A/V sourcebuffers\n    const bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);\n    const nextStart = bufferInfo.nextStart || 0;\n    const fragmentTracker = this.fragmentTracker;\n    if (seeking && fragmentTracker && this.hls) {\n      // Is there a fragment loading/parsing/appending before currentTime?\n      const inFlightDependency = getInFlightDependency(this.hls.inFlightFragments, currentTime);\n\n      // Waiting for seeking in a buffered range to complete\n      const hasEnoughBuffer = bufferInfo.len > MAX_START_GAP_JUMP;\n      // Next buffered range is too far ahead to jump to while still seeking\n      const noBufferHole = !nextStart || inFlightDependency || nextStart - currentTime > MAX_START_GAP_JUMP && !fragmentTracker.getPartialFragment(currentTime);\n      if (hasEnoughBuffer || noBufferHole) {\n        return;\n      }\n      // Reset moved state when seeking to a point in or before a gap/hole\n      this.moved = false;\n    }\n\n    // Skip start gaps if we haven't played, but the last poll detected the start of a stall\n    // The addition poll gives the browser a chance to jump the gap for us\n    const levelDetails = (_this$hls2 = this.hls) == null ? void 0 : _this$hls2.latestLevelDetails;\n    if (!this.moved && this.stalled !== null && fragmentTracker) {\n      // There is no playable buffer (seeked, waiting for buffer)\n      const isBuffered = bufferInfo.len > 0;\n      if (!isBuffered && !nextStart) {\n        return;\n      }\n      // Jump start gaps within jump threshold\n      const startJump = Math.max(nextStart, bufferInfo.start || 0) - currentTime;\n\n      // When joining a live stream with audio tracks, account for live playlist window sliding by allowing\n      // a larger jump over start gaps caused by the audio-stream-controller buffering a start fragment\n      // that begins over 1 target duration after the video start position.\n      const isLive = !!(levelDetails != null && levelDetails.live);\n      const maxStartGapJump = isLive ? levelDetails.targetduration * 2 : MAX_START_GAP_JUMP;\n      const partialOrGap = fragmentTracker.getPartialFragment(currentTime);\n      if (startJump > 0 && (startJump <= maxStartGapJump || partialOrGap)) {\n        if (!media.paused) {\n          this._trySkipBufferHole(partialOrGap);\n        }\n        return;\n      }\n    }\n\n    // Start tracking stall time\n    const detectStallWithCurrentTimeMs = config.detectStallWithCurrentTimeMs;\n    const tnow = self.performance.now();\n    const tWaiting = this.waiting;\n    let stalled = this.stalled;\n    if (stalled === null) {\n      // Use time of recent \"waiting\" event\n      if (tWaiting > 0 && tnow - tWaiting < detectStallWithCurrentTimeMs) {\n        stalled = this.stalled = tWaiting;\n      } else {\n        this.stalled = tnow;\n        return;\n      }\n    }\n    const stalledDuration = tnow - stalled;\n    if (!seeking && (stalledDuration >= detectStallWithCurrentTimeMs || tWaiting) && this.hls) {\n      var _this$mediaSource;\n      // Dispatch MEDIA_ENDED when media.ended/ended event is not signalled at end of stream\n      if (((_this$mediaSource = this.mediaSource) == null ? void 0 : _this$mediaSource.readyState) === 'ended' && !(levelDetails != null && levelDetails.live) && Math.abs(currentTime - ((levelDetails == null ? void 0 : levelDetails.edge) || 0)) < 1) {\n        if (this.ended) {\n          return;\n        }\n        this.ended = currentTime || 1;\n        this.hls.trigger(Events.MEDIA_ENDED, {\n          stalled: true\n        });\n        return;\n      }\n      // Report stalling after trying to fix\n      this._reportStall(bufferInfo);\n      if (!this.media || !this.hls) {\n        return;\n      }\n    }\n    const bufferedWithHoles = BufferHelper.bufferInfo(media, currentTime, config.maxBufferHole);\n    this._tryFixBufferStall(bufferedWithHoles, stalledDuration, currentTime);\n  }\n  stallResolved(currentTime) {\n    const stalled = this.stalled;\n    if (stalled && this.hls) {\n      this.stalled = null;\n      // The playhead is now moving, but was previously stalled\n      if (this.stallReported) {\n        const stalledDuration = self.performance.now() - stalled;\n        this.log(`playback not stuck anymore @${currentTime}, after ${Math.round(stalledDuration)}ms`);\n        this.stallReported = false;\n        this.waiting = 0;\n        this.hls.trigger(Events.STALL_RESOLVED, {});\n      }\n    }\n  }\n  nudgeOnVideoHole(currentTime, lastCurrentTime) {\n    var _this$buffered$audio;\n    // Chrome will play one second past a hole in video buffered time ranges without rendering any video from the subsequent range and then stall as long as audio is buffered:\n    // https://github.com/video-dev/hls.js/issues/5631\n    // https://issues.chromium.org/issues/40280613#comment10\n    // Detect the potential for this situation and proactively seek to flush the video pipeline once the playhead passes the start of the video hole.\n    // When there are audio and video buffers and currentTime is past the end of the first video buffered range...\n    const videoSourceBuffered = this.buffered.video;\n    if (this.hls && this.media && this.fragmentTracker && (_this$buffered$audio = this.buffered.audio) != null && _this$buffered$audio.length && videoSourceBuffered && videoSourceBuffered.length > 1 && currentTime > videoSourceBuffered.end(0)) {\n      // and audio is buffered at the playhead\n      const audioBufferInfo = BufferHelper.bufferedInfo(BufferHelper.timeRangesToArray(this.buffered.audio), currentTime, 0);\n      if (audioBufferInfo.len > 1 && lastCurrentTime >= audioBufferInfo.start) {\n        const videoTimes = BufferHelper.timeRangesToArray(videoSourceBuffered);\n        const lastBufferedIndex = BufferHelper.bufferedInfo(videoTimes, lastCurrentTime, 0).bufferedIndex;\n        // nudge when crossing into another video buffered range (hole).\n        if (lastBufferedIndex > -1 && lastBufferedIndex < videoTimes.length - 1) {\n          const bufferedIndex = BufferHelper.bufferedInfo(videoTimes, currentTime, 0).bufferedIndex;\n          const holeStart = videoTimes[lastBufferedIndex].end;\n          const holeEnd = videoTimes[lastBufferedIndex + 1].start;\n          if ((bufferedIndex === -1 || bufferedIndex > lastBufferedIndex) && holeEnd - holeStart < 1 &&\n          // `maxBufferHole` may be too small and setting it to 0 should not disable this feature\n          currentTime - holeStart < 2) {\n            const error = new Error(`nudging playhead to flush pipeline after video hole. currentTime: ${currentTime} hole: ${holeStart} -> ${holeEnd} buffered index: ${bufferedIndex}`);\n            this.warn(error.message);\n            // Magic number to flush the pipeline without interuption to audio playback:\n            this.media.currentTime += 0.000001;\n            const frag = this.fragmentTracker.getPartialFragment(currentTime) || undefined;\n            const bufferInfo = BufferHelper.bufferInfo(this.media, currentTime, 0);\n            this.hls.trigger(Events.ERROR, {\n              type: ErrorTypes.MEDIA_ERROR,\n              details: ErrorDetails.BUFFER_SEEK_OVER_HOLE,\n              fatal: false,\n              error,\n              reason: error.message,\n              frag,\n              buffer: bufferInfo.len,\n              bufferInfo\n            });\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Detects and attempts to fix known buffer stalling issues.\n   * @param bufferInfo - The properties of the current buffer.\n   * @param stalledDurationMs - The amount of time Hls.js has been stalling for.\n   * @private\n   */\n  _tryFixBufferStall(bufferInfo, stalledDurationMs, currentTime) {\n    var _this$hls3, _this$hls4;\n    const {\n      fragmentTracker,\n      media\n    } = this;\n    const config = (_this$hls3 = this.hls) == null ? void 0 : _this$hls3.config;\n    if (!media || !fragmentTracker || !config) {\n      return;\n    }\n    const levelDetails = (_this$hls4 = this.hls) == null ? void 0 : _this$hls4.latestLevelDetails;\n    const partial = fragmentTracker.getPartialFragment(currentTime);\n    if (partial || levelDetails != null && levelDetails.live && currentTime < levelDetails.fragmentStart) {\n      // Try to skip over the buffer hole caused by a partial fragment\n      // This method isn't limited by the size of the gap between buffered ranges\n      const targetTime = this._trySkipBufferHole(partial);\n      // we return here in this case, meaning\n      // the branch below only executes when we haven't seeked to a new position\n      if (targetTime || !this.media) {\n        return;\n      }\n    }\n\n    // if we haven't had to skip over a buffer hole of a partial fragment\n    // we may just have to \"nudge\" the playlist as the browser decoding/rendering engine\n    // needs to cross some sort of threshold covering all source-buffers content\n    // to start playing properly.\n    const bufferedRanges = bufferInfo.buffered;\n    const adjacentTraversal = this.adjacentTraversal(bufferInfo, currentTime);\n    if ((bufferedRanges && bufferedRanges.length > 1 && bufferInfo.len > config.maxBufferHole || bufferInfo.nextStart && (bufferInfo.nextStart - currentTime < config.maxBufferHole || adjacentTraversal)) && (stalledDurationMs > config.highBufferWatchdogPeriod * 1000 || this.waiting)) {\n      this.warn('Trying to nudge playhead over buffer-hole');\n      // Try to nudge currentTime over a buffer hole if we've been stalling for the configured amount of seconds\n      // We only try to jump the hole if it's under the configured size\n      this._tryNudgeBuffer(bufferInfo);\n    }\n  }\n  adjacentTraversal(bufferInfo, currentTime) {\n    const fragmentTracker = this.fragmentTracker;\n    const nextStart = bufferInfo.nextStart;\n    if (fragmentTracker && nextStart) {\n      const current = fragmentTracker.getFragAtPos(currentTime, PlaylistLevelType.MAIN);\n      const next = fragmentTracker.getFragAtPos(nextStart, PlaylistLevelType.MAIN);\n      if (current && next) {\n        return next.sn - current.sn < 2;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Triggers a BUFFER_STALLED_ERROR event, but only once per stall period.\n   * @param bufferLen - The playhead distance from the end of the current buffer segment.\n   * @private\n   */\n  _reportStall(bufferInfo) {\n    const {\n      hls,\n      media,\n      stallReported,\n      stalled\n    } = this;\n    if (!stallReported && stalled !== null && media && hls) {\n      // Report stalled error once\n      this.stallReported = true;\n      const error = new Error(`Playback stalling at @${media.currentTime} due to low buffer (${stringify(bufferInfo)})`);\n      this.warn(error.message);\n      hls.trigger(Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.BUFFER_STALLED_ERROR,\n        fatal: false,\n        error,\n        buffer: bufferInfo.len,\n        bufferInfo,\n        stalled: {\n          start: stalled\n        }\n      });\n    }\n  }\n\n  /**\n   * Attempts to fix buffer stalls by jumping over known gaps caused by partial fragments\n   * @param partial - The partial fragment found at the current time (where playback is stalling).\n   * @private\n   */\n  _trySkipBufferHole(partial) {\n    var _this$hls5;\n    const {\n      fragmentTracker,\n      media\n    } = this;\n    const config = (_this$hls5 = this.hls) == null ? void 0 : _this$hls5.config;\n    if (!media || !fragmentTracker || !config) {\n      return 0;\n    }\n\n    // Check if currentTime is between unbuffered regions of partial fragments\n    const currentTime = media.currentTime;\n    const bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);\n    const startTime = currentTime < bufferInfo.start ? bufferInfo.start : bufferInfo.nextStart;\n    if (startTime && this.hls) {\n      const bufferStarved = bufferInfo.len <= config.maxBufferHole;\n      const waiting = bufferInfo.len > 0 && bufferInfo.len < 1 && media.readyState < 3;\n      const gapLength = startTime - currentTime;\n      if (gapLength > 0 && (bufferStarved || waiting)) {\n        // Only allow large gaps to be skipped if it is a start gap, or all fragments in skip range are partial\n        if (gapLength > config.maxBufferHole) {\n          let startGap = false;\n          if (currentTime === 0) {\n            const startFrag = fragmentTracker.getAppendedFrag(0, PlaylistLevelType.MAIN);\n            if (startFrag && startTime < startFrag.end) {\n              startGap = true;\n            }\n          }\n          if (!startGap) {\n            const startProvisioned = partial || fragmentTracker.getAppendedFrag(currentTime, PlaylistLevelType.MAIN);\n            if (startProvisioned) {\n              var _this$hls$loadLevelOb;\n              // Do not seek when selected variant playlist is unloaded\n              if (!((_this$hls$loadLevelOb = this.hls.loadLevelObj) != null && _this$hls$loadLevelOb.details)) {\n                return 0;\n              }\n              // Do not seek when required fragments are inflight or appending\n              const inFlightDependency = getInFlightDependency(this.hls.inFlightFragments, startTime);\n              if (inFlightDependency) {\n                return 0;\n              }\n              // Do not seek if we can't walk tracked fragments to end of gap\n              let moreToLoad = false;\n              let pos = startProvisioned.end;\n              while (pos < startTime) {\n                const provisioned = fragmentTracker.getAppendedFrag(pos, PlaylistLevelType.MAIN) || fragmentTracker.getPartialFragment(pos);\n                if (provisioned) {\n                  pos += provisioned.duration;\n                } else {\n                  moreToLoad = true;\n                  break;\n                }\n              }\n              if (moreToLoad) {\n                return 0;\n              }\n            }\n          }\n        }\n        const targetTime = Math.max(startTime + SKIP_BUFFER_RANGE_START, currentTime + SKIP_BUFFER_HOLE_STEP_SECONDS);\n        this.warn(`skipping hole, adjusting currentTime from ${currentTime} to ${targetTime}`);\n        this.moved = true;\n        media.currentTime = targetTime;\n        if (!(partial != null && partial.gap)) {\n          const error = new Error(`fragment loaded with buffer holes, seeking from ${currentTime} to ${targetTime}`);\n          this.hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.BUFFER_SEEK_OVER_HOLE,\n            fatal: false,\n            error,\n            reason: error.message,\n            frag: partial || undefined,\n            buffer: bufferInfo.len,\n            bufferInfo\n          });\n        }\n        return targetTime;\n      }\n    }\n    return 0;\n  }\n\n  /**\n   * Attempts to fix buffer stalls by advancing the mediaElement's current time by a small amount.\n   * @private\n   */\n  _tryNudgeBuffer(bufferInfo) {\n    const {\n      hls,\n      media,\n      nudgeRetry\n    } = this;\n    const config = hls == null ? void 0 : hls.config;\n    if (!media || !config) {\n      return 0;\n    }\n    const currentTime = media.currentTime;\n    this.nudgeRetry++;\n    if (nudgeRetry < config.nudgeMaxRetry) {\n      const targetTime = currentTime + (nudgeRetry + 1) * config.nudgeOffset;\n      // playback stalled in buffered area ... let's nudge currentTime to try to overcome this\n      const error = new Error(`Nudging 'currentTime' from ${currentTime} to ${targetTime}`);\n      this.warn(error.message);\n      media.currentTime = targetTime;\n      hls.trigger(Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.BUFFER_NUDGE_ON_STALL,\n        error,\n        fatal: false,\n        buffer: bufferInfo.len,\n        bufferInfo\n      });\n    } else {\n      const error = new Error(`Playhead still not moving while enough data buffered @${currentTime} after ${config.nudgeMaxRetry} nudges`);\n      this.error(error.message);\n      hls.trigger(Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.BUFFER_STALLED_ERROR,\n        error,\n        fatal: true,\n        buffer: bufferInfo.len,\n        bufferInfo\n      });\n    }\n  }\n}\nfunction getInFlightDependency(inFlightFragments, currentTime) {\n  const main = inFlight(inFlightFragments.main);\n  if (main && main.start <= currentTime) {\n    return main;\n  }\n  const audio = inFlight(inFlightFragments.audio);\n  if (audio && audio.start <= currentTime) {\n    return audio;\n  }\n  return null;\n}\nfunction inFlight(inFlightData) {\n  if (!inFlightData) {\n    return null;\n  }\n  switch (inFlightData.state) {\n    case State.IDLE:\n    case State.STOPPED:\n    case State.ENDED:\n    case State.ERROR:\n      return null;\n  }\n  return inFlightData.frag;\n}\n\nconst MIN_CUE_DURATION = 0.25;\nfunction getCueClass() {\n  if (typeof self === 'undefined') return undefined;\n  return self.VTTCue || self.TextTrackCue;\n}\nfunction createCueWithDataFields(Cue, startTime, endTime, data, type) {\n  let cue = new Cue(startTime, endTime, '');\n  try {\n    cue.value = data;\n    if (type) {\n      cue.type = type;\n    }\n  } catch (e) {\n    cue = new Cue(startTime, endTime, stringify(type ? _objectSpread2({\n      type\n    }, data) : data));\n  }\n  return cue;\n}\n\n// VTTCue latest draft allows an infinite duration, fallback\n// to MAX_VALUE if necessary\nconst MAX_CUE_ENDTIME = (() => {\n  const Cue = getCueClass();\n  try {\n    Cue && new Cue(0, Number.POSITIVE_INFINITY, '');\n  } catch (e) {\n    return Number.MAX_VALUE;\n  }\n  return Number.POSITIVE_INFINITY;\n})();\nclass ID3TrackController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.id3Track = null;\n    this.media = null;\n    this.dateRangeCuesAppended = {};\n    this.removeCues = true;\n    this.onEventCueEnter = () => {\n      if (!this.hls) {\n        return;\n      }\n      this.hls.trigger(Events.EVENT_CUE_ENTER, {});\n    };\n    this.hls = hls;\n    this._registerListeners();\n  }\n  destroy() {\n    this._unregisterListeners();\n    this.id3Track = null;\n    this.media = null;\n    this.dateRangeCuesAppended = {};\n    // @ts-ignore\n    this.hls = this.onEventCueEnter = null;\n  }\n  _registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);\n    hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    hls.on(Events.LEVEL_PTS_UPDATED, this.onLevelPtsUpdated, this);\n  }\n  _unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);\n    hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    hls.off(Events.LEVEL_PTS_UPDATED, this.onLevelPtsUpdated, this);\n  }\n  // Add ID3 metatadata text track.\n  onMediaAttaching(event, data) {\n    var _data$overrides;\n    this.media = data.media;\n    if (((_data$overrides = data.overrides) == null ? void 0 : _data$overrides.cueRemoval) === false) {\n      this.removeCues = false;\n    }\n  }\n  onMediaAttached() {\n    const details = this.hls.latestLevelDetails;\n    if (details) {\n      this.updateDateRangeCues(details);\n    }\n  }\n  onMediaDetaching(event, data) {\n    this.media = null;\n    const transferringMedia = !!data.transferMedia;\n    if (transferringMedia) {\n      return;\n    }\n    if (this.id3Track) {\n      if (this.removeCues) {\n        clearCurrentCues(this.id3Track, this.onEventCueEnter);\n      }\n      this.id3Track = null;\n    }\n    this.dateRangeCuesAppended = {};\n  }\n  onManifestLoading() {\n    this.dateRangeCuesAppended = {};\n  }\n  createTrack(media) {\n    const track = this.getID3Track(media.textTracks);\n    track.mode = 'hidden';\n    return track;\n  }\n  getID3Track(textTracks) {\n    if (!this.media) {\n      return;\n    }\n    for (let i = 0; i < textTracks.length; i++) {\n      const textTrack = textTracks[i];\n      if (textTrack.kind === 'metadata' && textTrack.label === 'id3') {\n        // send 'addtrack' when reusing the textTrack for metadata,\n        // same as what we do for captions\n        sendAddTrackEvent(textTrack, this.media);\n        return textTrack;\n      }\n    }\n    return this.media.addTextTrack('metadata', 'id3');\n  }\n  onFragParsingMetadata(event, data) {\n    if (!this.media) {\n      return;\n    }\n    const {\n      hls: {\n        config: {\n          enableEmsgMetadataCues,\n          enableID3MetadataCues\n        }\n      }\n    } = this;\n    if (!enableEmsgMetadataCues && !enableID3MetadataCues) {\n      return;\n    }\n    const {\n      samples\n    } = data;\n\n    // create track dynamically\n    if (!this.id3Track) {\n      this.id3Track = this.createTrack(this.media);\n    }\n    const Cue = getCueClass();\n    if (!Cue) {\n      return;\n    }\n    for (let i = 0; i < samples.length; i++) {\n      const type = samples[i].type;\n      if (type === MetadataSchema.emsg && !enableEmsgMetadataCues || !enableID3MetadataCues) {\n        continue;\n      }\n      const frames = getId3Frames(samples[i].data);\n      if (frames) {\n        const startTime = samples[i].pts;\n        let endTime = startTime + samples[i].duration;\n        if (endTime > MAX_CUE_ENDTIME) {\n          endTime = MAX_CUE_ENDTIME;\n        }\n        const timeDiff = endTime - startTime;\n        if (timeDiff <= 0) {\n          endTime = startTime + MIN_CUE_DURATION;\n        }\n        for (let j = 0; j < frames.length; j++) {\n          const frame = frames[j];\n          // Safari doesn't put the timestamp frame in the TextTrack\n          if (!isId3TimestampFrame(frame)) {\n            // add a bounds to any unbounded cues\n            this.updateId3CueEnds(startTime, type);\n            const cue = createCueWithDataFields(Cue, startTime, endTime, frame, type);\n            if (cue) {\n              this.id3Track.addCue(cue);\n            }\n          }\n        }\n      }\n    }\n  }\n  updateId3CueEnds(startTime, type) {\n    var _this$id3Track;\n    const cues = (_this$id3Track = this.id3Track) == null ? void 0 : _this$id3Track.cues;\n    if (cues) {\n      for (let i = cues.length; i--;) {\n        const cue = cues[i];\n        if (cue.type === type && cue.startTime < startTime && cue.endTime === MAX_CUE_ENDTIME) {\n          cue.endTime = startTime;\n        }\n      }\n    }\n  }\n  onBufferFlushing(event, {\n    startOffset,\n    endOffset,\n    type\n  }) {\n    const {\n      id3Track,\n      hls\n    } = this;\n    if (!hls) {\n      return;\n    }\n    const {\n      config: {\n        enableEmsgMetadataCues,\n        enableID3MetadataCues\n      }\n    } = hls;\n    if (id3Track && (enableEmsgMetadataCues || enableID3MetadataCues)) {\n      let predicate;\n      if (type === 'audio') {\n        predicate = cue => cue.type === MetadataSchema.audioId3 && enableID3MetadataCues;\n      } else if (type === 'video') {\n        predicate = cue => cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;\n      } else {\n        predicate = cue => cue.type === MetadataSchema.audioId3 && enableID3MetadataCues || cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;\n      }\n      removeCuesInRange(id3Track, startOffset, endOffset, predicate);\n    }\n  }\n  onLevelUpdated(event, {\n    details\n  }) {\n    this.updateDateRangeCues(details, true);\n  }\n  onLevelPtsUpdated(event, data) {\n    if (Math.abs(data.drift) > 0.01) {\n      this.updateDateRangeCues(data.details);\n    }\n  }\n  updateDateRangeCues(details, removeOldCues) {\n    if (!this.media || !details.hasProgramDateTime || !this.hls.config.enableDateRangeMetadataCues) {\n      return;\n    }\n    const {\n      id3Track\n    } = this;\n    const {\n      dateRanges\n    } = details;\n    const ids = Object.keys(dateRanges);\n    let dateRangeCuesAppended = this.dateRangeCuesAppended;\n    // Remove cues from track not found in details.dateRanges\n    if (id3Track && removeOldCues) {\n      var _id3Track$cues;\n      if ((_id3Track$cues = id3Track.cues) != null && _id3Track$cues.length) {\n        const idsToRemove = Object.keys(dateRangeCuesAppended).filter(id => !ids.includes(id));\n        for (let i = idsToRemove.length; i--;) {\n          const id = idsToRemove[i];\n          const cues = dateRangeCuesAppended[id].cues;\n          delete dateRangeCuesAppended[id];\n          Object.keys(cues).forEach(key => {\n            try {\n              const cue = cues[key];\n              cue.removeEventListener('enter', this.onEventCueEnter);\n              id3Track.removeCue(cue);\n            } catch (e) {\n              /* no-op */\n            }\n          });\n        }\n      } else {\n        dateRangeCuesAppended = this.dateRangeCuesAppended = {};\n      }\n    }\n    // Exit if the playlist does not have Date Ranges or does not have Program Date Time\n    const lastFragment = details.fragments[details.fragments.length - 1];\n    if (ids.length === 0 || !isFiniteNumber(lastFragment == null ? void 0 : lastFragment.programDateTime)) {\n      return;\n    }\n    if (!this.id3Track) {\n      this.id3Track = this.createTrack(this.media);\n    }\n    const Cue = getCueClass();\n    for (let i = 0; i < ids.length; i++) {\n      const id = ids[i];\n      const dateRange = dateRanges[id];\n      const startTime = dateRange.startTime;\n\n      // Process DateRanges to determine end-time (known DURATION, END-DATE, or END-ON-NEXT)\n      const appendedDateRangeCues = dateRangeCuesAppended[id];\n      const cues = (appendedDateRangeCues == null ? void 0 : appendedDateRangeCues.cues) || {};\n      let durationKnown = (appendedDateRangeCues == null ? void 0 : appendedDateRangeCues.durationKnown) || false;\n      let endTime = MAX_CUE_ENDTIME;\n      const {\n        duration,\n        endDate\n      } = dateRange;\n      if (endDate && duration !== null) {\n        endTime = startTime + duration;\n        durationKnown = true;\n      } else if (dateRange.endOnNext && !durationKnown) {\n        const nextDateRangeWithSameClass = ids.reduce((candidateDateRange, id) => {\n          if (id !== dateRange.id) {\n            const otherDateRange = dateRanges[id];\n            if (otherDateRange.class === dateRange.class && otherDateRange.startDate > dateRange.startDate && (!candidateDateRange || dateRange.startDate < candidateDateRange.startDate)) {\n              return otherDateRange;\n            }\n          }\n          return candidateDateRange;\n        }, null);\n        if (nextDateRangeWithSameClass) {\n          endTime = nextDateRangeWithSameClass.startTime;\n          durationKnown = true;\n        }\n      }\n\n      // Create TextTrack Cues for each MetadataGroup Item (select DateRange attribute)\n      // This is to emulate Safari HLS playback handling of DateRange tags\n      const attributes = Object.keys(dateRange.attr);\n      for (let j = 0; j < attributes.length; j++) {\n        const key = attributes[j];\n        if (!isDateRangeCueAttribute(key)) {\n          continue;\n        }\n        const cue = cues[key];\n        if (cue) {\n          if (durationKnown && !appendedDateRangeCues.durationKnown) {\n            cue.endTime = endTime;\n          } else if (Math.abs(cue.startTime - startTime) > 0.01) {\n            cue.startTime = startTime;\n            cue.endTime = endTime;\n          }\n        } else if (Cue) {\n          let data = dateRange.attr[key];\n          if (isSCTE35Attribute(key)) {\n            data = hexToArrayBuffer(data);\n          }\n          const payload = {\n            key,\n            data\n          };\n          const _cue = createCueWithDataFields(Cue, startTime, endTime, payload, MetadataSchema.dateRange);\n          if (_cue) {\n            _cue.id = id;\n            this.id3Track.addCue(_cue);\n            cues[key] = _cue;\n            if (this.hls.config.interstitialsController) {\n              if (key === 'X-ASSET-LIST' || key === 'X-ASSET-URL') {\n                _cue.addEventListener('enter', this.onEventCueEnter);\n              }\n            }\n          }\n        }\n      }\n\n      // Keep track of processed DateRanges by ID for updating cues with new DateRange tag attributes\n      dateRangeCuesAppended[id] = {\n        cues,\n        dateRange,\n        durationKnown\n      };\n    }\n  }\n}\n\nclass LatencyController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.config = void 0;\n    this.media = null;\n    this.currentTime = 0;\n    this.stallCount = 0;\n    this._latency = null;\n    this._targetLatencyUpdated = false;\n    this.onTimeupdate = () => {\n      const {\n        media\n      } = this;\n      const levelDetails = this.levelDetails;\n      if (!media || !levelDetails) {\n        return;\n      }\n      this.currentTime = media.currentTime;\n      const latency = this.computeLatency();\n      if (latency === null) {\n        return;\n      }\n      this._latency = latency;\n\n      // Adapt playbackRate to meet target latency in low-latency mode\n      const {\n        lowLatencyMode,\n        maxLiveSyncPlaybackRate\n      } = this.config;\n      if (!lowLatencyMode || maxLiveSyncPlaybackRate === 1 || !levelDetails.live) {\n        return;\n      }\n      const targetLatency = this.targetLatency;\n      if (targetLatency === null) {\n        return;\n      }\n      const distanceFromTarget = latency - targetLatency;\n      // Only adjust playbackRate when within one target duration of targetLatency\n      // and more than one second from under-buffering.\n      // Playback further than one target duration from target can be considered DVR playback.\n      const liveMinLatencyDuration = Math.min(this.maxLatency, targetLatency + levelDetails.targetduration);\n      const inLiveRange = distanceFromTarget < liveMinLatencyDuration;\n      if (inLiveRange && distanceFromTarget > 0.05 && this.forwardBufferLength > 1) {\n        const max = Math.min(2, Math.max(1.0, maxLiveSyncPlaybackRate));\n        const rate = Math.round(2 / (1 + Math.exp(-0.75 * distanceFromTarget - this.edgeStalled)) * 20) / 20;\n        const playbackRate = Math.min(max, Math.max(1, rate));\n        this.changeMediaPlaybackRate(media, playbackRate);\n      } else if (media.playbackRate !== 1 && media.playbackRate !== 0) {\n        this.changeMediaPlaybackRate(media, 1);\n      }\n    };\n    this.hls = hls;\n    this.config = hls.config;\n    this.registerListeners();\n  }\n  get levelDetails() {\n    var _this$hls;\n    return ((_this$hls = this.hls) == null ? void 0 : _this$hls.latestLevelDetails) || null;\n  }\n  get latency() {\n    return this._latency || 0;\n  }\n  get maxLatency() {\n    const {\n      config\n    } = this;\n    if (config.liveMaxLatencyDuration !== undefined) {\n      return config.liveMaxLatencyDuration;\n    }\n    const levelDetails = this.levelDetails;\n    return levelDetails ? config.liveMaxLatencyDurationCount * levelDetails.targetduration : 0;\n  }\n  get targetLatency() {\n    const levelDetails = this.levelDetails;\n    if (levelDetails === null || this.hls === null) {\n      return null;\n    }\n    const {\n      holdBack,\n      partHoldBack,\n      targetduration\n    } = levelDetails;\n    const {\n      liveSyncDuration,\n      liveSyncDurationCount,\n      lowLatencyMode\n    } = this.config;\n    const userConfig = this.hls.userConfig;\n    let targetLatency = lowLatencyMode ? partHoldBack || holdBack : holdBack;\n    if (this._targetLatencyUpdated || userConfig.liveSyncDuration || userConfig.liveSyncDurationCount || targetLatency === 0) {\n      targetLatency = liveSyncDuration !== undefined ? liveSyncDuration : liveSyncDurationCount * targetduration;\n    }\n    const maxLiveSyncOnStallIncrease = targetduration;\n    return targetLatency + Math.min(this.stallCount * this.config.liveSyncOnStallIncrease, maxLiveSyncOnStallIncrease);\n  }\n  set targetLatency(latency) {\n    this.stallCount = 0;\n    this.config.liveSyncDuration = latency;\n    this._targetLatencyUpdated = true;\n  }\n  get liveSyncPosition() {\n    const liveEdge = this.estimateLiveEdge();\n    const targetLatency = this.targetLatency;\n    if (liveEdge === null || targetLatency === null) {\n      return null;\n    }\n    const levelDetails = this.levelDetails;\n    if (levelDetails === null) {\n      return null;\n    }\n    const edge = levelDetails.edge;\n    const syncPosition = liveEdge - targetLatency - this.edgeStalled;\n    const min = edge - levelDetails.totalduration;\n    const max = edge - (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration);\n    return Math.min(Math.max(min, syncPosition), max);\n  }\n  get drift() {\n    const levelDetails = this.levelDetails;\n    if (levelDetails === null) {\n      return 1;\n    }\n    return levelDetails.drift;\n  }\n  get edgeStalled() {\n    const levelDetails = this.levelDetails;\n    if (levelDetails === null) {\n      return 0;\n    }\n    const maxLevelUpdateAge = (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration) * 3;\n    return Math.max(levelDetails.age - maxLevelUpdateAge, 0);\n  }\n  get forwardBufferLength() {\n    const {\n      media\n    } = this;\n    const levelDetails = this.levelDetails;\n    if (!media || !levelDetails) {\n      return 0;\n    }\n    const bufferedRanges = media.buffered.length;\n    return (bufferedRanges ? media.buffered.end(bufferedRanges - 1) : levelDetails.edge) - this.currentTime;\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.onMediaDetaching();\n    this.hls = null;\n  }\n  registerListeners() {\n    const {\n      hls\n    } = this;\n    if (!hls) {\n      return;\n    }\n    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    hls.on(Events.ERROR, this.onError, this);\n  }\n  unregisterListeners() {\n    const {\n      hls\n    } = this;\n    if (!hls) {\n      return;\n    }\n    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    hls.off(Events.ERROR, this.onError, this);\n  }\n  onMediaAttached(event, data) {\n    this.media = data.media;\n    this.media.addEventListener('timeupdate', this.onTimeupdate);\n  }\n  onMediaDetaching() {\n    if (this.media) {\n      this.media.removeEventListener('timeupdate', this.onTimeupdate);\n      this.media = null;\n    }\n  }\n  onManifestLoading() {\n    this._latency = null;\n    this.stallCount = 0;\n  }\n  onLevelUpdated(event, {\n    details\n  }) {\n    if (details.advanced) {\n      this.onTimeupdate();\n    }\n    if (!details.live && this.media) {\n      this.media.removeEventListener('timeupdate', this.onTimeupdate);\n    }\n  }\n  onError(event, data) {\n    var _this$levelDetails;\n    if (data.details !== ErrorDetails.BUFFER_STALLED_ERROR) {\n      return;\n    }\n    this.stallCount++;\n    if (this.hls && (_this$levelDetails = this.levelDetails) != null && _this$levelDetails.live) {\n      this.hls.logger.warn('[latency-controller]: Stall detected, adjusting target latency');\n    }\n  }\n  changeMediaPlaybackRate(media, playbackRate) {\n    var _this$hls2, _this$targetLatency;\n    if (media.playbackRate === playbackRate) {\n      return;\n    }\n    (_this$hls2 = this.hls) == null ? void 0 : _this$hls2.logger.debug(`[latency-controller]: latency=${this.latency.toFixed(3)}, targetLatency=${(_this$targetLatency = this.targetLatency) == null ? void 0 : _this$targetLatency.toFixed(3)}, forwardBufferLength=${this.forwardBufferLength.toFixed(3)}: adjusting playback rate from ${media.playbackRate} to ${playbackRate}`);\n    media.playbackRate = playbackRate;\n  }\n  estimateLiveEdge() {\n    const levelDetails = this.levelDetails;\n    if (levelDetails === null) {\n      return null;\n    }\n    return levelDetails.edge + levelDetails.age;\n  }\n  computeLatency() {\n    const liveEdge = this.estimateLiveEdge();\n    if (liveEdge === null) {\n      return null;\n    }\n    return liveEdge - this.currentTime;\n  }\n}\n\nclass LevelController extends BasePlaylistController {\n  constructor(hls, contentSteeringController) {\n    super(hls, 'level-controller');\n    this._levels = [];\n    this._firstLevel = -1;\n    this._maxAutoLevel = -1;\n    this._startLevel = void 0;\n    this.currentLevel = null;\n    this.currentLevelIndex = -1;\n    this.manualLevelIndex = -1;\n    this.steering = void 0;\n    this.onParsedComplete = void 0;\n    this.steering = contentSteeringController;\n    this._registerListeners();\n  }\n  _registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.on(Events.ERROR, this.onError, this);\n  }\n  _unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.off(Events.ERROR, this.onError, this);\n  }\n  destroy() {\n    this._unregisterListeners();\n    this.steering = null;\n    this.resetLevels();\n    super.destroy();\n  }\n  stopLoad() {\n    const levels = this._levels;\n\n    // clean up live level details to force reload them, and reset load errors\n    levels.forEach(level => {\n      level.loadError = 0;\n      level.fragmentError = 0;\n    });\n    super.stopLoad();\n  }\n  resetLevels() {\n    this._startLevel = undefined;\n    this.manualLevelIndex = -1;\n    this.currentLevelIndex = -1;\n    this.currentLevel = null;\n    this._levels = [];\n    this._maxAutoLevel = -1;\n  }\n  onManifestLoading(event, data) {\n    this.resetLevels();\n  }\n  onManifestLoaded(event, data) {\n    const preferManagedMediaSource = this.hls.config.preferManagedMediaSource;\n    const levels = [];\n    const redundantSet = {};\n    const generatePathwaySet = {};\n    let resolutionFound = false;\n    let videoCodecFound = false;\n    let audioCodecFound = false;\n    data.levels.forEach(levelParsed => {\n      const attributes = levelParsed.attrs;\n      let {\n        audioCodec,\n        videoCodec\n      } = levelParsed;\n      if (audioCodec) {\n        // Returns empty and set to undefined for 'mp4a.40.34' with fallback to 'audio/mpeg' SourceBuffer\n        levelParsed.audioCodec = audioCodec = getCodecCompatibleName(audioCodec, preferManagedMediaSource) || undefined;\n      }\n      if (videoCodec) {\n        videoCodec = levelParsed.videoCodec = convertAVC1ToAVCOTI(videoCodec);\n      }\n\n      // only keep levels with supported audio/video codecs\n      const {\n        width,\n        height,\n        unknownCodecs\n      } = levelParsed;\n      let unknownUnsupportedCodecCount = unknownCodecs ? unknownCodecs.length : 0;\n      if (unknownCodecs) {\n        // Treat unknown codec as audio or video codec based on passing `isTypeSupported` check\n        // (allows for playback of any supported codec even if not indexed in utils/codecs)\n        for (let i = unknownUnsupportedCodecCount; i--;) {\n          const unknownCodec = unknownCodecs[i];\n          if (this.isAudioSupported(unknownCodec)) {\n            levelParsed.audioCodec = audioCodec = audioCodec ? `${audioCodec},${unknownCodec}` : unknownCodec;\n            unknownUnsupportedCodecCount--;\n            sampleEntryCodesISO.audio[audioCodec.substring(0, 4)] = 2;\n          } else if (this.isVideoSupported(unknownCodec)) {\n            levelParsed.videoCodec = videoCodec = videoCodec ? `${videoCodec},${unknownCodec}` : unknownCodec;\n            unknownUnsupportedCodecCount--;\n            sampleEntryCodesISO.video[videoCodec.substring(0, 4)] = 2;\n          }\n        }\n      }\n      resolutionFound || (resolutionFound = !!(width && height));\n      videoCodecFound || (videoCodecFound = !!videoCodec);\n      audioCodecFound || (audioCodecFound = !!audioCodec);\n      if (unknownUnsupportedCodecCount || audioCodec && !this.isAudioSupported(audioCodec) || videoCodec && !this.isVideoSupported(videoCodec)) {\n        this.log(`Some or all CODECS not supported \"${attributes.CODECS}\"`);\n        return;\n      }\n      const {\n        CODECS,\n        'FRAME-RATE': FRAMERATE,\n        'HDCP-LEVEL': HDCP,\n        'PATHWAY-ID': PATHWAY,\n        RESOLUTION,\n        'VIDEO-RANGE': VIDEO_RANGE\n      } = attributes;\n      const contentSteeringPrefix = `${PATHWAY || '.'}-`;\n      const levelKey = `${contentSteeringPrefix}${levelParsed.bitrate}-${RESOLUTION}-${FRAMERATE}-${CODECS}-${VIDEO_RANGE}-${HDCP}`;\n      if (!redundantSet[levelKey]) {\n        const level = this.createLevel(levelParsed);\n        redundantSet[levelKey] = level;\n        generatePathwaySet[levelKey] = 1;\n        levels.push(level);\n      } else if (redundantSet[levelKey].uri !== levelParsed.url && !levelParsed.attrs['PATHWAY-ID']) {\n        // Assign Pathway IDs to Redundant Streams (default Pathways is \".\". Redundant Streams \"..\", \"...\", and so on.)\n        // Content Steering controller to handles Pathway fallback on error\n        const pathwayCount = generatePathwaySet[levelKey] += 1;\n        levelParsed.attrs['PATHWAY-ID'] = new Array(pathwayCount + 1).join('.');\n        const level = this.createLevel(levelParsed);\n        redundantSet[levelKey] = level;\n        levels.push(level);\n      } else {\n        redundantSet[levelKey].addGroupId('audio', attributes.AUDIO);\n        redundantSet[levelKey].addGroupId('text', attributes.SUBTITLES);\n      }\n    });\n    this.filterAndSortMediaOptions(levels, data, resolutionFound, videoCodecFound, audioCodecFound);\n  }\n  createLevel(levelParsed) {\n    const level = new Level(levelParsed);\n    const supplemental = levelParsed.supplemental;\n    if (supplemental != null && supplemental.videoCodec && !this.isVideoSupported(supplemental.videoCodec)) {\n      const error = new Error(`SUPPLEMENTAL-CODECS not supported \"${supplemental.videoCodec}\"`);\n      this.log(error.message);\n      level.supportedResult = getUnsupportedResult(error, []);\n    }\n    return level;\n  }\n  isAudioSupported(codec) {\n    return areCodecsMediaSourceSupported(codec, 'audio', this.hls.config.preferManagedMediaSource);\n  }\n  isVideoSupported(codec) {\n    return areCodecsMediaSourceSupported(codec, 'video', this.hls.config.preferManagedMediaSource);\n  }\n  filterAndSortMediaOptions(filteredLevels, data, resolutionFound, videoCodecFound, audioCodecFound) {\n    let audioTracks = [];\n    let subtitleTracks = [];\n    let levels = filteredLevels;\n\n    // remove audio-only and invalid video-range levels if we also have levels with video codecs or RESOLUTION signalled\n    if ((resolutionFound || videoCodecFound) && audioCodecFound) {\n      levels = levels.filter(({\n        videoCodec,\n        videoRange,\n        width,\n        height\n      }) => (!!videoCodec || !!(width && height)) && isVideoRange(videoRange));\n    }\n    if (levels.length === 0) {\n      // Dispatch error after MANIFEST_LOADED is done propagating\n      Promise.resolve().then(() => {\n        if (this.hls) {\n          let message = 'no level with compatible codecs found in manifest';\n          let reason = message;\n          if (data.levels.length) {\n            reason = `one or more CODECS in variant not supported: ${stringify(data.levels.map(level => level.attrs.CODECS).filter((value, index, array) => array.indexOf(value) === index))}`;\n            this.warn(reason);\n            message += ` (${reason})`;\n          }\n          const error = new Error(message);\n          this.hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR,\n            fatal: true,\n            url: data.url,\n            error,\n            reason\n          });\n        }\n      });\n      return;\n    }\n    if (data.audioTracks) {\n      audioTracks = data.audioTracks.filter(track => !track.audioCodec || this.isAudioSupported(track.audioCodec));\n      // Assign ids after filtering as array indices by group-id\n      assignTrackIdsByGroup(audioTracks);\n    }\n    if (data.subtitles) {\n      subtitleTracks = data.subtitles;\n      assignTrackIdsByGroup(subtitleTracks);\n    }\n    // start bitrate is the first bitrate of the manifest\n    const unsortedLevels = levels.slice(0);\n    // sort levels from lowest to highest\n    levels.sort((a, b) => {\n      if (a.attrs['HDCP-LEVEL'] !== b.attrs['HDCP-LEVEL']) {\n        return (a.attrs['HDCP-LEVEL'] || '') > (b.attrs['HDCP-LEVEL'] || '') ? 1 : -1;\n      }\n      // sort on height before bitrate for cap-level-controller\n      if (resolutionFound && a.height !== b.height) {\n        return a.height - b.height;\n      }\n      if (a.frameRate !== b.frameRate) {\n        return a.frameRate - b.frameRate;\n      }\n      if (a.videoRange !== b.videoRange) {\n        return VideoRangeValues.indexOf(a.videoRange) - VideoRangeValues.indexOf(b.videoRange);\n      }\n      if (a.videoCodec !== b.videoCodec) {\n        const valueA = videoCodecPreferenceValue(a.videoCodec);\n        const valueB = videoCodecPreferenceValue(b.videoCodec);\n        if (valueA !== valueB) {\n          return valueB - valueA;\n        }\n      }\n      if (a.uri === b.uri && a.codecSet !== b.codecSet) {\n        const valueA = codecsSetSelectionPreferenceValue(a.codecSet);\n        const valueB = codecsSetSelectionPreferenceValue(b.codecSet);\n        if (valueA !== valueB) {\n          return valueB - valueA;\n        }\n      }\n      if (a.averageBitrate !== b.averageBitrate) {\n        return a.averageBitrate - b.averageBitrate;\n      }\n      return 0;\n    });\n    let firstLevelInPlaylist = unsortedLevels[0];\n    if (this.steering) {\n      levels = this.steering.filterParsedLevels(levels);\n      if (levels.length !== unsortedLevels.length) {\n        for (let i = 0; i < unsortedLevels.length; i++) {\n          if (unsortedLevels[i].pathwayId === levels[0].pathwayId) {\n            firstLevelInPlaylist = unsortedLevels[i];\n            break;\n          }\n        }\n      }\n    }\n    this._levels = levels;\n\n    // find index of first level in sorted levels\n    for (let i = 0; i < levels.length; i++) {\n      if (levels[i] === firstLevelInPlaylist) {\n        var _this$hls$userConfig;\n        this._firstLevel = i;\n        const firstLevelBitrate = firstLevelInPlaylist.bitrate;\n        const bandwidthEstimate = this.hls.bandwidthEstimate;\n        this.log(`manifest loaded, ${levels.length} level(s) found, first bitrate: ${firstLevelBitrate}`);\n        // Update default bwe to first variant bitrate as long it has not been configured or set\n        if (((_this$hls$userConfig = this.hls.userConfig) == null ? void 0 : _this$hls$userConfig.abrEwmaDefaultEstimate) === undefined) {\n          const startingBwEstimate = Math.min(firstLevelBitrate, this.hls.config.abrEwmaDefaultEstimateMax);\n          if (startingBwEstimate > bandwidthEstimate && bandwidthEstimate === this.hls.abrEwmaDefaultEstimate) {\n            this.hls.bandwidthEstimate = startingBwEstimate;\n          }\n        }\n        break;\n      }\n    }\n\n    // Audio is only alternate if manifest include a URI along with the audio group tag,\n    // and this is not an audio-only stream where levels contain audio-only\n    const audioOnly = audioCodecFound && !videoCodecFound;\n    const config = this.hls.config;\n    const altAudioEnabled = !!(config.audioStreamController && config.audioTrackController);\n    const edata = {\n      levels,\n      audioTracks,\n      subtitleTracks,\n      sessionData: data.sessionData,\n      sessionKeys: data.sessionKeys,\n      firstLevel: this._firstLevel,\n      stats: data.stats,\n      audio: audioCodecFound,\n      video: videoCodecFound,\n      altAudio: altAudioEnabled && !audioOnly && audioTracks.some(t => !!t.url)\n    };\n    this.hls.trigger(Events.MANIFEST_PARSED, edata);\n  }\n  get levels() {\n    if (this._levels.length === 0) {\n      return null;\n    }\n    return this._levels;\n  }\n  get loadLevelObj() {\n    return this.currentLevel;\n  }\n  get level() {\n    return this.currentLevelIndex;\n  }\n  set level(newLevel) {\n    const levels = this._levels;\n    if (levels.length === 0) {\n      return;\n    }\n    // check if level idx is valid\n    if (newLevel < 0 || newLevel >= levels.length) {\n      // invalid level id given, trigger error\n      const error = new Error('invalid level idx');\n      const fatal = newLevel < 0;\n      this.hls.trigger(Events.ERROR, {\n        type: ErrorTypes.OTHER_ERROR,\n        details: ErrorDetails.LEVEL_SWITCH_ERROR,\n        level: newLevel,\n        fatal,\n        error,\n        reason: error.message\n      });\n      if (fatal) {\n        return;\n      }\n      newLevel = Math.min(newLevel, levels.length - 1);\n    }\n    const lastLevelIndex = this.currentLevelIndex;\n    const lastLevel = this.currentLevel;\n    const lastPathwayId = lastLevel ? lastLevel.attrs['PATHWAY-ID'] : undefined;\n    const level = levels[newLevel];\n    const pathwayId = level.attrs['PATHWAY-ID'];\n    this.currentLevelIndex = newLevel;\n    this.currentLevel = level;\n    if (lastLevelIndex === newLevel && lastLevel && lastPathwayId === pathwayId) {\n      return;\n    }\n    this.log(`Switching to level ${newLevel} (${level.height ? level.height + 'p ' : ''}${level.videoRange ? level.videoRange + ' ' : ''}${level.codecSet ? level.codecSet + ' ' : ''}@${level.bitrate})${pathwayId ? ' with Pathway ' + pathwayId : ''} from level ${lastLevelIndex}${lastPathwayId ? ' with Pathway ' + lastPathwayId : ''}`);\n    const levelSwitchingData = {\n      level: newLevel,\n      attrs: level.attrs,\n      details: level.details,\n      bitrate: level.bitrate,\n      averageBitrate: level.averageBitrate,\n      maxBitrate: level.maxBitrate,\n      realBitrate: level.realBitrate,\n      width: level.width,\n      height: level.height,\n      codecSet: level.codecSet,\n      audioCodec: level.audioCodec,\n      videoCodec: level.videoCodec,\n      audioGroups: level.audioGroups,\n      subtitleGroups: level.subtitleGroups,\n      loaded: level.loaded,\n      loadError: level.loadError,\n      fragmentError: level.fragmentError,\n      name: level.name,\n      id: level.id,\n      uri: level.uri,\n      url: level.url,\n      urlId: 0,\n      audioGroupIds: level.audioGroupIds,\n      textGroupIds: level.textGroupIds\n    };\n    this.hls.trigger(Events.LEVEL_SWITCHING, levelSwitchingData);\n    // check if we need to load playlist for this level\n    const levelDetails = level.details;\n    if (!levelDetails || levelDetails.live) {\n      // level not retrieved yet, or live playlist we need to (re)load it\n      const hlsUrlParameters = this.switchParams(level.uri, lastLevel == null ? void 0 : lastLevel.details, levelDetails);\n      this.loadPlaylist(hlsUrlParameters);\n    }\n  }\n  get manualLevel() {\n    return this.manualLevelIndex;\n  }\n  set manualLevel(newLevel) {\n    this.manualLevelIndex = newLevel;\n    if (this._startLevel === undefined) {\n      this._startLevel = newLevel;\n    }\n    if (newLevel !== -1) {\n      this.level = newLevel;\n    }\n  }\n  get firstLevel() {\n    return this._firstLevel;\n  }\n  set firstLevel(newLevel) {\n    this._firstLevel = newLevel;\n  }\n  get startLevel() {\n    // Setting hls.startLevel (this._startLevel) overrides config.startLevel\n    if (this._startLevel === undefined) {\n      const configStartLevel = this.hls.config.startLevel;\n      if (configStartLevel !== undefined) {\n        return configStartLevel;\n      }\n      return this.hls.firstAutoLevel;\n    }\n    return this._startLevel;\n  }\n  set startLevel(newLevel) {\n    this._startLevel = newLevel;\n  }\n  get pathways() {\n    if (this.steering) {\n      return this.steering.pathways();\n    }\n    return [];\n  }\n  get pathwayPriority() {\n    if (this.steering) {\n      return this.steering.pathwayPriority;\n    }\n    return null;\n  }\n  set pathwayPriority(pathwayPriority) {\n    if (this.steering) {\n      const pathwaysList = this.steering.pathways();\n      const filteredPathwayPriority = pathwayPriority.filter(pathwayId => {\n        return pathwaysList.indexOf(pathwayId) !== -1;\n      });\n      if (pathwayPriority.length < 1) {\n        this.warn(`pathwayPriority ${pathwayPriority} should contain at least one pathway from list: ${pathwaysList}`);\n        return;\n      }\n      this.steering.pathwayPriority = filteredPathwayPriority;\n    }\n  }\n  onError(event, data) {\n    if (data.fatal || !data.context) {\n      return;\n    }\n    if (data.context.type === PlaylistContextType.LEVEL && data.context.level === this.level) {\n      this.checkRetry(data);\n    }\n  }\n\n  // reset errors on the successful load of a fragment\n  onFragBuffered(event, {\n    frag\n  }) {\n    if (frag !== undefined && frag.type === PlaylistLevelType.MAIN) {\n      const el = frag.elementaryStreams;\n      if (!Object.keys(el).some(type => !!el[type])) {\n        return;\n      }\n      const level = this._levels[frag.level];\n      if (level != null && level.loadError) {\n        this.log(`Resetting level error count of ${level.loadError} on frag buffered`);\n        level.loadError = 0;\n      }\n    }\n  }\n  onLevelLoaded(event, data) {\n    var _data$deliveryDirecti2;\n    const {\n      level,\n      details\n    } = data;\n    const curLevel = data.levelInfo;\n    if (!curLevel) {\n      var _data$deliveryDirecti;\n      this.warn(`Invalid level index ${level}`);\n      if ((_data$deliveryDirecti = data.deliveryDirectives) != null && _data$deliveryDirecti.skip) {\n        details.deltaUpdateFailed = true;\n      }\n      return;\n    }\n\n    // only process level loaded events matching with expected level or prior to switch when media playlist is loaded directly\n    if (curLevel === this.currentLevel || data.withoutMultiVariant) {\n      // reset level load error counter on successful level loaded only if there is no issues with fragments\n      if (curLevel.fragmentError === 0) {\n        curLevel.loadError = 0;\n      }\n      // Ignore matching details populated by loading a Media Playlist directly\n      let previousDetails = curLevel.details;\n      if (previousDetails === data.details && previousDetails.advanced) {\n        previousDetails = undefined;\n      }\n      this.playlistLoaded(level, data, previousDetails);\n    } else if ((_data$deliveryDirecti2 = data.deliveryDirectives) != null && _data$deliveryDirecti2.skip) {\n      // received a delta playlist update that cannot be merged\n      details.deltaUpdateFailed = true;\n    }\n  }\n  loadPlaylist(hlsUrlParameters) {\n    super.loadPlaylist();\n    if (this.shouldLoadPlaylist(this.currentLevel)) {\n      this.scheduleLoading(this.currentLevel, hlsUrlParameters);\n    }\n  }\n  loadingPlaylist(currentLevel, hlsUrlParameters) {\n    super.loadingPlaylist(currentLevel, hlsUrlParameters);\n    const url = this.getUrlWithDirectives(currentLevel.uri, hlsUrlParameters);\n    const currentLevelIndex = this.currentLevelIndex;\n    const pathwayId = currentLevel.attrs['PATHWAY-ID'];\n    const details = currentLevel.details;\n    const age = details == null ? void 0 : details.age;\n    this.log(`Loading level index ${currentLevelIndex}${(hlsUrlParameters == null ? void 0 : hlsUrlParameters.msn) !== undefined ? ' at sn ' + hlsUrlParameters.msn + ' part ' + hlsUrlParameters.part : ''}${pathwayId ? ' Pathway ' + pathwayId : ''}${age && details.live ? ' age ' + age.toFixed(1) + (details.type ? ' ' + details.type || 0 : '') : ''} ${url}`);\n    this.hls.trigger(Events.LEVEL_LOADING, {\n      url,\n      level: currentLevelIndex,\n      levelInfo: currentLevel,\n      pathwayId: currentLevel.attrs['PATHWAY-ID'],\n      id: 0,\n      // Deprecated Level urlId\n      deliveryDirectives: hlsUrlParameters || null\n    });\n  }\n  get nextLoadLevel() {\n    if (this.manualLevelIndex !== -1) {\n      return this.manualLevelIndex;\n    } else {\n      return this.hls.nextAutoLevel;\n    }\n  }\n  set nextLoadLevel(nextLevel) {\n    this.level = nextLevel;\n    if (this.manualLevelIndex === -1) {\n      this.hls.nextAutoLevel = nextLevel;\n    }\n  }\n  removeLevel(levelIndex) {\n    var _this$currentLevel;\n    if (this._levels.length === 1) {\n      return;\n    }\n    const levels = this._levels.filter((level, index) => {\n      if (index !== levelIndex) {\n        return true;\n      }\n      if (this.steering) {\n        this.steering.removeLevel(level);\n      }\n      if (level === this.currentLevel) {\n        this.currentLevel = null;\n        this.currentLevelIndex = -1;\n        if (level.details) {\n          level.details.fragments.forEach(f => f.level = -1);\n        }\n      }\n      return false;\n    });\n    reassignFragmentLevelIndexes(levels);\n    this._levels = levels;\n    if (this.currentLevelIndex > -1 && (_this$currentLevel = this.currentLevel) != null && _this$currentLevel.details) {\n      this.currentLevelIndex = this.currentLevel.details.fragments[0].level;\n    }\n    if (this.manualLevelIndex > -1) {\n      this.manualLevelIndex = this.currentLevelIndex;\n    }\n    const maxLevel = levels.length - 1;\n    this._firstLevel = Math.min(this._firstLevel, maxLevel);\n    if (this._startLevel) {\n      this._startLevel = Math.min(this._startLevel, maxLevel);\n    }\n    this.hls.trigger(Events.LEVELS_UPDATED, {\n      levels\n    });\n  }\n  onLevelsUpdated(event, {\n    levels\n  }) {\n    this._levels = levels;\n  }\n  checkMaxAutoUpdated() {\n    const {\n      autoLevelCapping,\n      maxAutoLevel,\n      maxHdcpLevel\n    } = this.hls;\n    if (this._maxAutoLevel !== maxAutoLevel) {\n      this._maxAutoLevel = maxAutoLevel;\n      this.hls.trigger(Events.MAX_AUTO_LEVEL_UPDATED, {\n        autoLevelCapping,\n        levels: this.levels,\n        maxAutoLevel,\n        minAutoLevel: this.hls.minAutoLevel,\n        maxHdcpLevel\n      });\n    }\n  }\n}\nfunction assignTrackIdsByGroup(tracks) {\n  const groups = {};\n  tracks.forEach(track => {\n    const groupId = track.groupId || '';\n    track.id = groups[groupId] = groups[groupId] || 0;\n    groups[groupId]++;\n  });\n}\n\nfunction getSourceBuffer() {\n  return self.SourceBuffer || self.WebKitSourceBuffer;\n}\nfunction isMSESupported() {\n  const mediaSource = getMediaSource();\n  if (!mediaSource) {\n    return false;\n  }\n\n  // if SourceBuffer is exposed ensure its API is valid\n  // Older browsers do not expose SourceBuffer globally so checking SourceBuffer.prototype is impossible\n  const sourceBuffer = getSourceBuffer();\n  return !sourceBuffer || sourceBuffer.prototype && typeof sourceBuffer.prototype.appendBuffer === 'function' && typeof sourceBuffer.prototype.remove === 'function';\n}\nfunction isSupported() {\n  if (!isMSESupported()) {\n    return false;\n  }\n  const mediaSource = getMediaSource();\n  return typeof (mediaSource == null ? void 0 : mediaSource.isTypeSupported) === 'function' && (['avc1.42E01E,mp4a.40.2', 'av01.0.01M.08', 'vp09.00.50.08'].some(codecsForVideoContainer => mediaSource.isTypeSupported(mimeTypeForCodec(codecsForVideoContainer, 'video'))) || ['mp4a.40.2', 'fLaC'].some(codecForAudioContainer => mediaSource.isTypeSupported(mimeTypeForCodec(codecForAudioContainer, 'audio'))));\n}\nfunction changeTypeSupported() {\n  var _sourceBuffer$prototy;\n  const sourceBuffer = getSourceBuffer();\n  return typeof (sourceBuffer == null ? void 0 : (_sourceBuffer$prototy = sourceBuffer.prototype) == null ? void 0 : _sourceBuffer$prototy.changeType) === 'function';\n}\n\nconst TICK_INTERVAL = 100; // how often to tick in ms\n\nclass StreamController extends BaseStreamController {\n  constructor(hls, fragmentTracker, keyLoader) {\n    super(hls, fragmentTracker, keyLoader, 'stream-controller', PlaylistLevelType.MAIN);\n    this.audioCodecSwap = false;\n    this.level = -1;\n    this._forceStartLoad = false;\n    this._hasEnoughToStart = false;\n    this.altAudio = 0;\n    this.audioOnly = false;\n    this.fragPlaying = null;\n    this.fragLastKbps = 0;\n    this.couldBacktrack = false;\n    this.backtrackFragment = null;\n    this.audioCodecSwitch = false;\n    this.videoBuffer = null;\n    this.onMediaPlaying = () => {\n      // tick to speed up FRAG_CHANGED triggering\n      this.tick();\n    };\n    this.onMediaSeeked = () => {\n      const media = this.media;\n      const currentTime = media ? media.currentTime : null;\n      if (currentTime === null || !isFiniteNumber(currentTime)) {\n        return;\n      }\n      this.log(`Media seeked to ${currentTime.toFixed(3)}`);\n\n      // If seeked was issued before buffer was appended do not tick immediately\n      if (!this.getBufferedFrag(currentTime)) {\n        return;\n      }\n      const bufferInfo = this.getFwdBufferInfoAtPos(media, currentTime, PlaylistLevelType.MAIN, 0);\n      if (bufferInfo === null || bufferInfo.len === 0) {\n        this.warn(`Main forward buffer length at ${currentTime} on \"seeked\" event ${bufferInfo ? bufferInfo.len : 'empty'})`);\n        return;\n      }\n\n      // tick to speed up FRAG_CHANGED triggering\n      this.tick();\n    };\n    this.registerListeners();\n  }\n  registerListeners() {\n    super.registerListeners();\n    const {\n      hls\n    } = this;\n    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);\n    hls.on(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n    hls.on(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n    hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);\n    hls.on(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n    hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n  }\n  unregisterListeners() {\n    super.unregisterListeners();\n    const {\n      hls\n    } = this;\n    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);\n    hls.off(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n    hls.off(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n    hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);\n    hls.off(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n    hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n  }\n  onHandlerDestroying() {\n    // @ts-ignore\n    this.onMediaPlaying = this.onMediaSeeked = null;\n    this.unregisterListeners();\n    super.onHandlerDestroying();\n  }\n  startLoad(startPosition, skipSeekToStartPosition) {\n    if (this.levels) {\n      const {\n        lastCurrentTime,\n        hls\n      } = this;\n      this.stopLoad();\n      this.setInterval(TICK_INTERVAL);\n      this.level = -1;\n      if (!this.startFragRequested) {\n        // determine load level\n        let startLevel = hls.startLevel;\n        if (startLevel === -1) {\n          if (hls.config.testBandwidth && this.levels.length > 1) {\n            // -1 : guess start Level by doing a bitrate test by loading first fragment of lowest quality level\n            startLevel = 0;\n            this.bitrateTest = true;\n          } else {\n            startLevel = hls.firstAutoLevel;\n          }\n        }\n        // set new level to playlist loader : this will trigger start level load\n        // hls.nextLoadLevel remains until it is set to a new value or until a new frag is successfully loaded\n        hls.nextLoadLevel = startLevel;\n        this.level = hls.loadLevel;\n        this._hasEnoughToStart = !!skipSeekToStartPosition;\n      }\n      // if startPosition undefined but lastCurrentTime set, set startPosition to last currentTime\n      if (lastCurrentTime > 0 && startPosition === -1 && !skipSeekToStartPosition) {\n        this.log(`Override startPosition with lastCurrentTime @${lastCurrentTime.toFixed(3)}`);\n        startPosition = lastCurrentTime;\n      }\n      this.state = State.IDLE;\n      this.nextLoadPosition = this.lastCurrentTime = startPosition + this.timelineOffset;\n      this.startPosition = skipSeekToStartPosition ? -1 : startPosition;\n      this.tick();\n    } else {\n      this._forceStartLoad = true;\n      this.state = State.STOPPED;\n    }\n  }\n  stopLoad() {\n    this._forceStartLoad = false;\n    super.stopLoad();\n  }\n  doTick() {\n    switch (this.state) {\n      case State.WAITING_LEVEL:\n        {\n          const {\n            levels,\n            level\n          } = this;\n          const currentLevel = levels == null ? void 0 : levels[level];\n          const details = currentLevel == null ? void 0 : currentLevel.details;\n          if (details && (!details.live || this.levelLastLoaded === currentLevel && !this.waitForLive(currentLevel))) {\n            if (this.waitForCdnTuneIn(details)) {\n              break;\n            }\n            this.state = State.IDLE;\n            break;\n          } else if (this.hls.nextLoadLevel !== this.level) {\n            this.state = State.IDLE;\n            break;\n          }\n          break;\n        }\n      case State.FRAG_LOADING_WAITING_RETRY:\n        {\n          var _this$media;\n          const now = self.performance.now();\n          const retryDate = this.retryDate;\n          // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading\n          if (!retryDate || now >= retryDate || (_this$media = this.media) != null && _this$media.seeking) {\n            const {\n              levels,\n              level\n            } = this;\n            const currentLevel = levels == null ? void 0 : levels[level];\n            this.resetStartWhenNotLoaded(currentLevel || null);\n            this.state = State.IDLE;\n          }\n        }\n        break;\n    }\n    if (this.state === State.IDLE) {\n      this.doTickIdle();\n    }\n    this.onTickEnd();\n  }\n  onTickEnd() {\n    var _this$media2;\n    super.onTickEnd();\n    if ((_this$media2 = this.media) != null && _this$media2.readyState && this.media.seeking === false) {\n      this.lastCurrentTime = this.media.currentTime;\n    }\n    this.checkFragmentChanged();\n  }\n  doTickIdle() {\n    const {\n      hls,\n      levelLastLoaded,\n      levels,\n      media\n    } = this;\n\n    // if start level not parsed yet OR\n    // if video not attached AND start fragment already requested OR start frag prefetch not enabled\n    // exit loop, as we either need more info (level not parsed) or we need media to be attached to load new fragment\n    if (levelLastLoaded === null || !media && !this.primaryPrefetch && (this.startFragRequested || !hls.config.startFragPrefetch)) {\n      return;\n    }\n\n    // If the \"main\" level is audio-only but we are loading an alternate track in the same group, do not load anything\n    if (this.altAudio && this.audioOnly) {\n      return;\n    }\n    const level = this.buffering ? hls.nextLoadLevel : hls.loadLevel;\n    if (!(levels != null && levels[level])) {\n      return;\n    }\n    const levelInfo = levels[level];\n\n    // if buffer length is less than maxBufLen try to load a new fragment\n\n    const bufferInfo = this.getMainFwdBufferInfo();\n    if (bufferInfo === null) {\n      return;\n    }\n    const lastDetails = this.getLevelDetails();\n    if (lastDetails && this._streamEnded(bufferInfo, lastDetails)) {\n      const data = {};\n      if (this.altAudio === 2) {\n        data.type = 'video';\n      }\n      this.hls.trigger(Events.BUFFER_EOS, data);\n      this.state = State.ENDED;\n      return;\n    }\n    if (!this.buffering) {\n      return;\n    }\n\n    // set next load level : this will trigger a playlist load if needed\n    if (hls.loadLevel !== level && hls.manualLevel === -1) {\n      this.log(`Adapting to level ${level} from level ${this.level}`);\n    }\n    this.level = hls.nextLoadLevel = level;\n    const levelDetails = levelInfo.details;\n    // if level info not retrieved yet, switch state and wait for level retrieval\n    // if live playlist, ensure that new playlist has been refreshed to avoid loading/try to load\n    // a useless and outdated fragment (that might even introduce load error if it is already out of the live playlist)\n    if (!levelDetails || this.state === State.WAITING_LEVEL || this.waitForLive(levelInfo)) {\n      this.level = level;\n      this.state = State.WAITING_LEVEL;\n      this.startFragRequested = false;\n      return;\n    }\n    const bufferLen = bufferInfo.len;\n\n    // compute max Buffer Length that we could get from this load level, based on level bitrate. don't buffer more than 60 MB and more than 30s\n    const maxBufLen = this.getMaxBufferLength(levelInfo.maxBitrate);\n\n    // Stay idle if we are still with buffer margins\n    if (bufferLen >= maxBufLen) {\n      return;\n    }\n    if (this.backtrackFragment && this.backtrackFragment.start > bufferInfo.end) {\n      this.backtrackFragment = null;\n    }\n    const targetBufferTime = this.backtrackFragment ? this.backtrackFragment.start : bufferInfo.end;\n    let frag = this.getNextFragment(targetBufferTime, levelDetails);\n    // Avoid backtracking by loading an earlier segment in streams with segments that do not start with a key frame (flagged by `couldBacktrack`)\n    if (this.couldBacktrack && !this.fragPrevious && frag && isMediaFragment(frag) && this.fragmentTracker.getState(frag) !== FragmentState.OK) {\n      var _this$backtrackFragme;\n      const backtrackSn = ((_this$backtrackFragme = this.backtrackFragment) != null ? _this$backtrackFragme : frag).sn;\n      const fragIdx = backtrackSn - levelDetails.startSN;\n      const backtrackFrag = levelDetails.fragments[fragIdx - 1];\n      if (backtrackFrag && frag.cc === backtrackFrag.cc) {\n        frag = backtrackFrag;\n        this.fragmentTracker.removeFragment(backtrackFrag);\n      }\n    } else if (this.backtrackFragment && bufferInfo.len) {\n      this.backtrackFragment = null;\n    }\n    // Avoid loop loading by using nextLoadPosition set for backtracking and skipping consecutive GAP tags\n    if (frag && this.isLoopLoading(frag, targetBufferTime)) {\n      const gapStart = frag.gap;\n      if (!gapStart) {\n        // Cleanup the fragment tracker before trying to find the next unbuffered fragment\n        const type = this.audioOnly && !this.altAudio ? ElementaryStreamTypes.AUDIO : ElementaryStreamTypes.VIDEO;\n        const mediaBuffer = (type === ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;\n        if (mediaBuffer) {\n          this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.MAIN);\n        }\n      }\n      frag = this.getNextFragmentLoopLoading(frag, levelDetails, bufferInfo, PlaylistLevelType.MAIN, maxBufLen);\n    }\n    if (!frag) {\n      return;\n    }\n    if (frag.initSegment && !frag.initSegment.data && !this.bitrateTest) {\n      frag = frag.initSegment;\n    }\n    this.loadFragment(frag, levelInfo, targetBufferTime);\n  }\n  loadFragment(frag, level, targetBufferTime) {\n    // Check if fragment is not loaded\n    const fragState = this.fragmentTracker.getState(frag);\n    if (fragState === FragmentState.NOT_LOADED || fragState === FragmentState.PARTIAL) {\n      if (!isMediaFragment(frag)) {\n        this._loadInitSegment(frag, level);\n      } else if (this.bitrateTest) {\n        this.log(`Fragment ${frag.sn} of level ${frag.level} is being downloaded to test bitrate and will not be buffered`);\n        this._loadBitrateTestFrag(frag, level);\n      } else {\n        super.loadFragment(frag, level, targetBufferTime);\n      }\n    } else {\n      this.clearTrackerIfNeeded(frag);\n    }\n  }\n  getBufferedFrag(position) {\n    return this.fragmentTracker.getBufferedFrag(position, PlaylistLevelType.MAIN);\n  }\n  followingBufferedFrag(frag) {\n    if (frag) {\n      // try to get range of next fragment (500ms after this range)\n      return this.getBufferedFrag(frag.end + 0.5);\n    }\n    return null;\n  }\n\n  /*\n    on immediate level switch :\n     - pause playback if playing\n     - cancel any pending load request\n     - and trigger a buffer flush\n  */\n  immediateLevelSwitch() {\n    this.abortCurrentFrag();\n    this.flushMainBuffer(0, Number.POSITIVE_INFINITY);\n  }\n\n  /**\n   * try to switch ASAP without breaking video playback:\n   * in order to ensure smooth but quick level switching,\n   * we need to find the next flushable buffer range\n   * we should take into account new segment fetch time\n   */\n  nextLevelSwitch() {\n    const {\n      levels,\n      media\n    } = this;\n    // ensure that media is defined and that metadata are available (to retrieve currentTime)\n    if (media != null && media.readyState) {\n      let fetchdelay;\n      const fragPlayingCurrent = this.getAppendedFrag(media.currentTime);\n      if (fragPlayingCurrent && fragPlayingCurrent.start > 1) {\n        // flush buffer preceding current fragment (flush until current fragment start offset)\n        // minus 1s to avoid video freezing, that could happen if we flush keyframe of current video ...\n        this.flushMainBuffer(0, fragPlayingCurrent.start - 1);\n      }\n      const levelDetails = this.getLevelDetails();\n      if (levelDetails != null && levelDetails.live) {\n        const bufferInfo = this.getMainFwdBufferInfo();\n        // Do not flush in live stream with low buffer\n        if (!bufferInfo || bufferInfo.len < levelDetails.targetduration * 2) {\n          return;\n        }\n      }\n      if (!media.paused && levels) {\n        // add a safety delay of 1s\n        const nextLevelId = this.hls.nextLoadLevel;\n        const nextLevel = levels[nextLevelId];\n        const fragLastKbps = this.fragLastKbps;\n        if (fragLastKbps && this.fragCurrent) {\n          fetchdelay = this.fragCurrent.duration * nextLevel.maxBitrate / (1000 * fragLastKbps) + 1;\n        } else {\n          fetchdelay = 0;\n        }\n      } else {\n        fetchdelay = 0;\n      }\n      // this.log('fetchdelay:'+fetchdelay);\n      // find buffer range that will be reached once new fragment will be fetched\n      const bufferedFrag = this.getBufferedFrag(media.currentTime + fetchdelay);\n      if (bufferedFrag) {\n        // we can flush buffer range following this one without stalling playback\n        const nextBufferedFrag = this.followingBufferedFrag(bufferedFrag);\n        if (nextBufferedFrag) {\n          // if we are here, we can also cancel any loading/demuxing in progress, as they are useless\n          this.abortCurrentFrag();\n          // start flush position is in next buffered frag. Leave some padding for non-independent segments and smoother playback.\n          const maxStart = nextBufferedFrag.maxStartPTS ? nextBufferedFrag.maxStartPTS : nextBufferedFrag.start;\n          const fragDuration = nextBufferedFrag.duration;\n          const startPts = Math.max(bufferedFrag.end, maxStart + Math.min(Math.max(fragDuration - this.config.maxFragLookUpTolerance, fragDuration * (this.couldBacktrack ? 0.5 : 0.125)), fragDuration * (this.couldBacktrack ? 0.75 : 0.25)));\n          this.flushMainBuffer(startPts, Number.POSITIVE_INFINITY);\n        }\n      }\n    }\n  }\n  abortCurrentFrag() {\n    const fragCurrent = this.fragCurrent;\n    this.fragCurrent = null;\n    this.backtrackFragment = null;\n    if (fragCurrent) {\n      fragCurrent.abortRequests();\n      this.fragmentTracker.removeFragment(fragCurrent);\n    }\n    switch (this.state) {\n      case State.KEY_LOADING:\n      case State.FRAG_LOADING:\n      case State.FRAG_LOADING_WAITING_RETRY:\n      case State.PARSING:\n      case State.PARSED:\n        this.state = State.IDLE;\n        break;\n    }\n    this.nextLoadPosition = this.getLoadPosition();\n  }\n  flushMainBuffer(startOffset, endOffset) {\n    super.flushMainBuffer(startOffset, endOffset, this.altAudio === 2 ? 'video' : null);\n  }\n  onMediaAttached(event, data) {\n    super.onMediaAttached(event, data);\n    const media = data.media;\n    addEventListener(media, 'playing', this.onMediaPlaying);\n    addEventListener(media, 'seeked', this.onMediaSeeked);\n  }\n  onMediaDetaching(event, data) {\n    const {\n      media\n    } = this;\n    if (media) {\n      removeEventListener(media, 'playing', this.onMediaPlaying);\n      removeEventListener(media, 'seeked', this.onMediaSeeked);\n    }\n    this.videoBuffer = null;\n    this.fragPlaying = null;\n    super.onMediaDetaching(event, data);\n    const transferringMedia = !!data.transferMedia;\n    if (transferringMedia) {\n      return;\n    }\n    this._hasEnoughToStart = false;\n  }\n  onManifestLoading() {\n    super.onManifestLoading();\n    // reset buffer on manifest loading\n    this.log('Trigger BUFFER_RESET');\n    this.hls.trigger(Events.BUFFER_RESET, undefined);\n    this.couldBacktrack = false;\n    this.fragLastKbps = 0;\n    this.fragPlaying = this.backtrackFragment = null;\n    this.altAudio = 0;\n    this.audioOnly = false;\n  }\n  onManifestParsed(event, data) {\n    // detect if we have different kind of audio codecs used amongst playlists\n    let aac = false;\n    let heaac = false;\n    data.levels.forEach(level => {\n      const codec = level.audioCodec;\n      if (codec) {\n        aac = aac || codec.indexOf('mp4a.40.2') !== -1;\n        heaac = heaac || codec.indexOf('mp4a.40.5') !== -1;\n      }\n    });\n    this.audioCodecSwitch = aac && heaac && !changeTypeSupported();\n    if (this.audioCodecSwitch) {\n      this.log('Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC');\n    }\n    this.levels = data.levels;\n    this.startFragRequested = false;\n  }\n  onLevelLoading(event, data) {\n    const {\n      levels\n    } = this;\n    if (!levels || this.state !== State.IDLE) {\n      return;\n    }\n    const level = data.levelInfo;\n    if (!level.details || level.details.live && (this.levelLastLoaded !== level || level.details.expired) || this.waitForCdnTuneIn(level.details)) {\n      this.state = State.WAITING_LEVEL;\n    }\n  }\n  onLevelLoaded(event, data) {\n    var _curLevel$details;\n    const {\n      levels,\n      startFragRequested\n    } = this;\n    const newLevelId = data.level;\n    const newDetails = data.details;\n    const duration = newDetails.totalduration;\n    if (!levels) {\n      this.warn(`Levels were reset while loading level ${newLevelId}`);\n      return;\n    }\n    this.log(`Level ${newLevelId} loaded [${newDetails.startSN},${newDetails.endSN}]${newDetails.lastPartSn ? `[part-${newDetails.lastPartSn}-${newDetails.lastPartIndex}]` : ''}, cc [${newDetails.startCC}, ${newDetails.endCC}] duration:${duration}`);\n    const curLevel = data.levelInfo;\n    const fragCurrent = this.fragCurrent;\n    if (fragCurrent && (this.state === State.FRAG_LOADING || this.state === State.FRAG_LOADING_WAITING_RETRY)) {\n      if (fragCurrent.level !== data.level && fragCurrent.loader) {\n        this.abortCurrentFrag();\n      }\n    }\n    let sliding = 0;\n    if (newDetails.live || (_curLevel$details = curLevel.details) != null && _curLevel$details.live) {\n      var _this$levelLastLoaded;\n      this.checkLiveUpdate(newDetails);\n      if (newDetails.deltaUpdateFailed) {\n        return;\n      }\n      sliding = this.alignPlaylists(newDetails, curLevel.details, (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details);\n    }\n    // override level info\n    curLevel.details = newDetails;\n    this.levelLastLoaded = curLevel;\n    if (!startFragRequested) {\n      this.setStartPosition(newDetails, sliding);\n    }\n    this.hls.trigger(Events.LEVEL_UPDATED, {\n      details: newDetails,\n      level: newLevelId\n    });\n\n    // only switch back to IDLE state if we were waiting for level to start downloading a new fragment\n    if (this.state === State.WAITING_LEVEL) {\n      if (this.waitForCdnTuneIn(newDetails)) {\n        // Wait for Low-Latency CDN Tune-in\n        return;\n      }\n      this.state = State.IDLE;\n    }\n    if (startFragRequested && newDetails.live) {\n      this.synchronizeToLiveEdge(newDetails);\n    }\n\n    // trigger handler right now\n    this.tick();\n  }\n  synchronizeToLiveEdge(levelDetails) {\n    const {\n      config,\n      media\n    } = this;\n    if (!media) {\n      return;\n    }\n    const liveSyncPosition = this.hls.liveSyncPosition;\n    const currentTime = this.getLoadPosition();\n    const start = levelDetails.fragmentStart;\n    const end = levelDetails.edge;\n    const withinSlidingWindow = currentTime >= start - config.maxFragLookUpTolerance && currentTime <= end;\n    // Continue if we can seek forward to sync position or if current time is outside of sliding window\n    if (liveSyncPosition !== null && media.duration > liveSyncPosition && (currentTime < liveSyncPosition || !withinSlidingWindow)) {\n      // Continue if buffer is starving or if current time is behind max latency\n      const maxLatency = config.liveMaxLatencyDuration !== undefined ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;\n      if (!withinSlidingWindow && media.readyState < 4 || currentTime < end - maxLatency) {\n        if (!this._hasEnoughToStart) {\n          this.nextLoadPosition = liveSyncPosition;\n        }\n        // Only seek if ready and there is not a significant forward buffer available for playback\n        if (media.readyState) {\n          this.warn(`Playback: ${currentTime.toFixed(3)} is located too far from the end of live sliding playlist: ${end}, reset currentTime to : ${liveSyncPosition.toFixed(3)}`);\n          if (this.config.liveSyncMode === 'buffered') {\n            var _bufferInfo$buffered;\n            const bufferInfo = BufferHelper.bufferInfo(media, liveSyncPosition, 0);\n            if (!(bufferInfo != null && (_bufferInfo$buffered = bufferInfo.buffered) != null && _bufferInfo$buffered.length)) {\n              media.currentTime = liveSyncPosition;\n              return;\n            }\n            const isLiveSyncInBuffer = bufferInfo.start <= currentTime;\n            if (isLiveSyncInBuffer) {\n              media.currentTime = liveSyncPosition;\n              return;\n            }\n            const {\n              nextStart\n            } = BufferHelper.bufferedInfo(bufferInfo.buffered, currentTime, 0);\n            if (nextStart) {\n              media.currentTime = nextStart;\n            }\n          } else {\n            media.currentTime = liveSyncPosition;\n          }\n        }\n      }\n    }\n  }\n  _handleFragmentLoadProgress(data) {\n    var _frag$initSegment;\n    const frag = data.frag;\n    const {\n      part,\n      payload\n    } = data;\n    const {\n      levels\n    } = this;\n    if (!levels) {\n      this.warn(`Levels were reset while fragment load was in progress. Fragment ${frag.sn} of level ${frag.level} will not be buffered`);\n      return;\n    }\n    const currentLevel = levels[frag.level];\n    if (!currentLevel) {\n      this.warn(`Level ${frag.level} not found on progress`);\n      return;\n    }\n    const details = currentLevel.details;\n    if (!details) {\n      this.warn(`Dropping fragment ${frag.sn} of level ${frag.level} after level details were reset`);\n      this.fragmentTracker.removeFragment(frag);\n      return;\n    }\n    const videoCodec = currentLevel.videoCodec;\n\n    // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)\n    const accurateTimeOffset = details.PTSKnown || !details.live;\n    const initSegmentData = (_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.data;\n    const audioCodec = this._getAudioCodec(currentLevel);\n\n    // transmux the MPEG-TS data to ISO-BMFF segments\n    // this.log(`Transmuxing ${frag.sn} of [${details.startSN} ,${details.endSN}],level ${frag.level}, cc ${frag.cc}`);\n    const transmuxer = this.transmuxer = this.transmuxer || new TransmuxerInterface(this.hls, PlaylistLevelType.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));\n    const partIndex = part ? part.index : -1;\n    const partial = partIndex !== -1;\n    const chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);\n    const initPTS = this.initPTS[frag.cc];\n    transmuxer.push(payload, initSegmentData, audioCodec, videoCodec, frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);\n  }\n  onAudioTrackSwitching(event, data) {\n    const hls = this.hls;\n    // if any URL found on new audio track, it is an alternate audio track\n    const fromAltAudio = this.altAudio === 2;\n    const altAudio = useAlternateAudio(data.url, hls);\n    // if we switch on main audio, ensure that main fragment scheduling is synced with media.buffered\n    // don't do anything if we switch to alt audio: audio stream controller is handling it.\n    // we will just have to change buffer scheduling on audioTrackSwitched\n    if (!altAudio) {\n      if (this.mediaBuffer !== this.media) {\n        this.log('Switching on main audio, use media.buffered to schedule main fragment loading');\n        this.mediaBuffer = this.media;\n        const fragCurrent = this.fragCurrent;\n        // we need to refill audio buffer from main: cancel any frag loading to speed up audio switch\n        if (fragCurrent) {\n          this.log('Switching to main audio track, cancel main fragment load');\n          fragCurrent.abortRequests();\n          this.fragmentTracker.removeFragment(fragCurrent);\n        }\n        // destroy transmuxer to force init segment generation (following audio switch)\n        this.resetTransmuxer();\n        // switch to IDLE state to load new fragment\n        this.resetLoadingState();\n      } else if (this.audioOnly) {\n        // Reset audio transmuxer so when switching back to main audio we're not still appending where we left off\n        this.resetTransmuxer();\n      }\n      // If switching from alt to main audio, flush all audio and trigger track switched\n      if (fromAltAudio) {\n        this.fragmentTracker.removeAllFragments();\n        hls.once(Events.BUFFER_FLUSHED, () => {\n          var _this$hls;\n          (_this$hls = this.hls) == null ? void 0 : _this$hls.trigger(Events.AUDIO_TRACK_SWITCHED, data);\n        });\n        hls.trigger(Events.BUFFER_FLUSHING, {\n          startOffset: 0,\n          endOffset: Number.POSITIVE_INFINITY,\n          type: null\n        });\n        return;\n      }\n      hls.trigger(Events.AUDIO_TRACK_SWITCHED, data);\n    } else {\n      this.altAudio = 1;\n    }\n  }\n  onAudioTrackSwitched(event, data) {\n    const altAudio = useAlternateAudio(data.url, this.hls);\n    if (altAudio) {\n      const videoBuffer = this.videoBuffer;\n      // if we switched on alternate audio, ensure that main fragment scheduling is synced with video sourcebuffer buffered\n      if (videoBuffer && this.mediaBuffer !== videoBuffer) {\n        this.log('Switching on alternate audio, use video.buffered to schedule main fragment loading');\n        this.mediaBuffer = videoBuffer;\n      }\n    }\n    this.altAudio = altAudio ? 2 : 0;\n    this.tick();\n  }\n  onBufferCreated(event, data) {\n    const tracks = data.tracks;\n    let mediaTrack;\n    let name;\n    let alternate = false;\n    for (const type in tracks) {\n      const track = tracks[type];\n      if (track.id === 'main') {\n        name = type;\n        mediaTrack = track;\n        // keep video source buffer reference\n        if (type === 'video') {\n          const videoTrack = tracks[type];\n          if (videoTrack) {\n            this.videoBuffer = videoTrack.buffer;\n          }\n        }\n      } else {\n        alternate = true;\n      }\n    }\n    if (alternate && mediaTrack) {\n      this.log(`Alternate track found, use ${name}.buffered to schedule main fragment loading`);\n      this.mediaBuffer = mediaTrack.buffer;\n    } else {\n      this.mediaBuffer = this.media;\n    }\n  }\n  onFragBuffered(event, data) {\n    const {\n      frag,\n      part\n    } = data;\n    const bufferedMainFragment = frag.type === PlaylistLevelType.MAIN;\n    if (bufferedMainFragment) {\n      if (this.fragContextChanged(frag)) {\n        // If a level switch was requested while a fragment was buffering, it will emit the FRAG_BUFFERED event upon completion\n        // Avoid setting state back to IDLE, since that will interfere with a level switch\n        this.warn(`Fragment ${frag.sn}${part ? ' p: ' + part.index : ''} of level ${frag.level} finished buffering, but was aborted. state: ${this.state}`);\n        if (this.state === State.PARSED) {\n          this.state = State.IDLE;\n        }\n        return;\n      }\n      const stats = part ? part.stats : frag.stats;\n      this.fragLastKbps = Math.round(8 * stats.total / (stats.buffering.end - stats.loading.first));\n      if (isMediaFragment(frag)) {\n        this.fragPrevious = frag;\n      }\n      this.fragBufferedComplete(frag, part);\n    }\n    const media = this.media;\n    if (!media) {\n      return;\n    }\n    if (!this._hasEnoughToStart && BufferHelper.getBuffered(media).length) {\n      this._hasEnoughToStart = true;\n      this.seekToStartPos();\n    }\n    if (bufferedMainFragment) {\n      this.tick();\n    }\n  }\n  get hasEnoughToStart() {\n    return this._hasEnoughToStart;\n  }\n  onError(event, data) {\n    var _data$context;\n    if (data.fatal) {\n      this.state = State.ERROR;\n      return;\n    }\n    switch (data.details) {\n      case ErrorDetails.FRAG_GAP:\n      case ErrorDetails.FRAG_PARSING_ERROR:\n      case ErrorDetails.FRAG_DECRYPT_ERROR:\n      case ErrorDetails.FRAG_LOAD_ERROR:\n      case ErrorDetails.FRAG_LOAD_TIMEOUT:\n      case ErrorDetails.KEY_LOAD_ERROR:\n      case ErrorDetails.KEY_LOAD_TIMEOUT:\n        this.onFragmentOrKeyLoadError(PlaylistLevelType.MAIN, data);\n        break;\n      case ErrorDetails.LEVEL_LOAD_ERROR:\n      case ErrorDetails.LEVEL_LOAD_TIMEOUT:\n      case ErrorDetails.LEVEL_PARSING_ERROR:\n        // in case of non fatal error while loading level, if level controller is not retrying to load level, switch back to IDLE\n        if (!data.levelRetry && this.state === State.WAITING_LEVEL && ((_data$context = data.context) == null ? void 0 : _data$context.type) === PlaylistContextType.LEVEL) {\n          this.state = State.IDLE;\n        }\n        break;\n      case ErrorDetails.BUFFER_ADD_CODEC_ERROR:\n      case ErrorDetails.BUFFER_APPEND_ERROR:\n        if (data.parent !== 'main') {\n          return;\n        }\n        if (this.reduceLengthAndFlushBuffer(data)) {\n          this.resetLoadingState();\n        }\n        break;\n      case ErrorDetails.BUFFER_FULL_ERROR:\n        if (data.parent !== 'main') {\n          return;\n        }\n        if (this.reduceLengthAndFlushBuffer(data)) {\n          this.flushMainBuffer(0, Number.POSITIVE_INFINITY);\n        }\n        break;\n      case ErrorDetails.INTERNAL_EXCEPTION:\n        this.recoverWorkerError(data);\n        break;\n    }\n  }\n  onFragLoadEmergencyAborted() {\n    this.state = State.IDLE;\n    // if loadedmetadata is not set, it means that we are emergency switch down on first frag\n    // in that case, reset startFragRequested flag\n    if (!this._hasEnoughToStart) {\n      this.startFragRequested = false;\n      this.nextLoadPosition = this.lastCurrentTime;\n    }\n    this.tickImmediate();\n  }\n  onBufferFlushed(event, {\n    type\n  }) {\n    if (type !== ElementaryStreamTypes.AUDIO || !this.altAudio) {\n      const mediaBuffer = (type === ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;\n      if (mediaBuffer) {\n        this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.MAIN);\n        this.tick();\n      }\n    }\n  }\n  onLevelsUpdated(event, data) {\n    if (this.level > -1 && this.fragCurrent) {\n      this.level = this.fragCurrent.level;\n      if (this.level === -1) {\n        this.resetWhenMissingContext(this.fragCurrent);\n      }\n    }\n    this.levels = data.levels;\n  }\n  swapAudioCodec() {\n    this.audioCodecSwap = !this.audioCodecSwap;\n  }\n\n  /**\n   * Seeks to the set startPosition if not equal to the mediaElement's current time.\n   */\n  seekToStartPos() {\n    const {\n      media\n    } = this;\n    if (!media) {\n      return;\n    }\n    const currentTime = media.currentTime;\n    let startPosition = this.startPosition;\n    // only adjust currentTime if different from startPosition or if startPosition not buffered\n    // at that stage, there should be only one buffered range, as we reach that code after first fragment has been buffered\n    if (startPosition >= 0 && currentTime < startPosition) {\n      if (media.seeking) {\n        this.log(`could not seek to ${startPosition}, already seeking at ${currentTime}`);\n        return;\n      }\n\n      // Offset start position by timeline offset\n      const timelineOffset = this.timelineOffset;\n      if (timelineOffset && startPosition) {\n        startPosition += timelineOffset;\n      }\n      const details = this.getLevelDetails();\n      const buffered = BufferHelper.getBuffered(media);\n      const bufferStart = buffered.length ? buffered.start(0) : 0;\n      const delta = bufferStart - startPosition;\n      const skipTolerance = Math.max(this.config.maxBufferHole, this.config.maxFragLookUpTolerance);\n      if (this.config.startOnSegmentBoundary || delta > 0 && (delta < skipTolerance || this.loadingParts && delta < 2 * ((details == null ? void 0 : details.partTarget) || 0))) {\n        this.log(`adjusting start position by ${delta} to match buffer start`);\n        startPosition += delta;\n        this.startPosition = startPosition;\n      }\n      if (currentTime < startPosition) {\n        this.log(`seek to target start position ${startPosition} from current time ${currentTime} buffer start ${bufferStart}`);\n        media.currentTime = startPosition;\n      }\n    }\n  }\n  _getAudioCodec(currentLevel) {\n    let audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;\n    if (this.audioCodecSwap && audioCodec) {\n      this.log('Swapping audio codec');\n      if (audioCodec.indexOf('mp4a.40.5') !== -1) {\n        audioCodec = 'mp4a.40.2';\n      } else {\n        audioCodec = 'mp4a.40.5';\n      }\n    }\n    return audioCodec;\n  }\n  _loadBitrateTestFrag(fragment, level) {\n    fragment.bitrateTest = true;\n    this._doFragLoad(fragment, level).then(data => {\n      const {\n        hls\n      } = this;\n      const frag = data == null ? void 0 : data.frag;\n      if (!frag || this.fragContextChanged(frag)) {\n        return;\n      }\n      level.fragmentError = 0;\n      this.state = State.IDLE;\n      this.startFragRequested = false;\n      this.bitrateTest = false;\n      const stats = frag.stats;\n      // Bitrate tests fragments are neither parsed nor buffered\n      stats.parsing.start = stats.parsing.end = stats.buffering.start = stats.buffering.end = self.performance.now();\n      hls.trigger(Events.FRAG_LOADED, data);\n      frag.bitrateTest = false;\n    });\n  }\n  _handleTransmuxComplete(transmuxResult) {\n    var _id3$samples;\n    const id = this.playlistType;\n    const {\n      hls\n    } = this;\n    const {\n      remuxResult,\n      chunkMeta\n    } = transmuxResult;\n    const context = this.getCurrentContext(chunkMeta);\n    if (!context) {\n      this.resetWhenMissingContext(chunkMeta);\n      return;\n    }\n    const {\n      frag,\n      part,\n      level\n    } = context;\n    const {\n      video,\n      text,\n      id3,\n      initSegment\n    } = remuxResult;\n    const {\n      details\n    } = level;\n    // The audio-stream-controller handles audio buffering if Hls.js is playing an alternate audio track\n    const audio = this.altAudio ? undefined : remuxResult.audio;\n\n    // Check if the current fragment has been aborted. We check this by first seeing if we're still playing the current level.\n    // If we are, subsequently check if the currently loading fragment (fragCurrent) has changed.\n    if (this.fragContextChanged(frag)) {\n      this.fragmentTracker.removeFragment(frag);\n      return;\n    }\n    this.state = State.PARSING;\n    if (initSegment) {\n      if (initSegment != null && initSegment.tracks) {\n        const mapFragment = frag.initSegment || frag;\n        this._bufferInitSegment(level, initSegment.tracks, mapFragment, chunkMeta);\n        hls.trigger(Events.FRAG_PARSING_INIT_SEGMENT, {\n          frag: mapFragment,\n          id,\n          tracks: initSegment.tracks\n        });\n      }\n\n      // This would be nice if Number.isFinite acted as a typeguard, but it doesn't. See: https://github.com/Microsoft/TypeScript/issues/10038\n      const baseTime = initSegment.initPTS;\n      const timescale = initSegment.timescale;\n      const initPTS = this.initPTS[frag.cc];\n      if (isFiniteNumber(baseTime) && (!initPTS || initPTS.baseTime !== baseTime || initPTS.timescale !== timescale)) {\n        this.initPTS[frag.cc] = {\n          baseTime,\n          timescale\n        };\n        hls.trigger(Events.INIT_PTS_FOUND, {\n          frag,\n          id,\n          initPTS: baseTime,\n          timescale\n        });\n      }\n    }\n\n    // Avoid buffering if backtracking this fragment\n    if (video && details) {\n      if (audio && video.type === 'audiovideo') {\n        this.logMuxedErr(frag);\n      }\n      const prevFrag = details.fragments[frag.sn - 1 - details.startSN];\n      const isFirstFragment = frag.sn === details.startSN;\n      const isFirstInDiscontinuity = !prevFrag || frag.cc > prevFrag.cc;\n      if (remuxResult.independent !== false) {\n        const {\n          startPTS,\n          endPTS,\n          startDTS,\n          endDTS\n        } = video;\n        if (part) {\n          part.elementaryStreams[video.type] = {\n            startPTS,\n            endPTS,\n            startDTS,\n            endDTS\n          };\n        } else {\n          if (video.firstKeyFrame && video.independent && chunkMeta.id === 1 && !isFirstInDiscontinuity) {\n            this.couldBacktrack = true;\n          }\n          if (video.dropped && video.independent) {\n            // Backtrack if dropped frames create a gap after currentTime\n\n            const bufferInfo = this.getMainFwdBufferInfo();\n            const targetBufferTime = (bufferInfo ? bufferInfo.end : this.getLoadPosition()) + this.config.maxBufferHole;\n            const startTime = video.firstKeyFramePTS ? video.firstKeyFramePTS : startPTS;\n            if (!isFirstFragment && targetBufferTime < startTime - this.config.maxBufferHole && !isFirstInDiscontinuity) {\n              this.backtrack(frag);\n              return;\n            } else if (isFirstInDiscontinuity) {\n              // Mark segment with a gap to avoid loop loading\n              frag.gap = true;\n            }\n            // Set video stream start to fragment start so that truncated samples do not distort the timeline, and mark it partial\n            frag.setElementaryStreamInfo(video.type, frag.start, endPTS, frag.start, endDTS, true);\n          } else if (isFirstFragment && startPTS - (details.appliedTimelineOffset || 0) > MAX_START_GAP_JUMP) {\n            // Mark segment with a gap to skip large start gap\n            frag.gap = true;\n          }\n        }\n        frag.setElementaryStreamInfo(video.type, startPTS, endPTS, startDTS, endDTS);\n        if (this.backtrackFragment) {\n          this.backtrackFragment = frag;\n        }\n        this.bufferFragmentData(video, frag, part, chunkMeta, isFirstFragment || isFirstInDiscontinuity);\n      } else if (isFirstFragment || isFirstInDiscontinuity) {\n        // Mark segment with a gap to avoid loop loading\n        frag.gap = true;\n      } else {\n        this.backtrack(frag);\n        return;\n      }\n    }\n    if (audio) {\n      const {\n        startPTS,\n        endPTS,\n        startDTS,\n        endDTS\n      } = audio;\n      if (part) {\n        part.elementaryStreams[ElementaryStreamTypes.AUDIO] = {\n          startPTS,\n          endPTS,\n          startDTS,\n          endDTS\n        };\n      }\n      frag.setElementaryStreamInfo(ElementaryStreamTypes.AUDIO, startPTS, endPTS, startDTS, endDTS);\n      this.bufferFragmentData(audio, frag, part, chunkMeta);\n    }\n    if (details && id3 != null && (_id3$samples = id3.samples) != null && _id3$samples.length) {\n      const emittedID3 = {\n        id,\n        frag,\n        details,\n        samples: id3.samples\n      };\n      hls.trigger(Events.FRAG_PARSING_METADATA, emittedID3);\n    }\n    if (details && text) {\n      const emittedText = {\n        id,\n        frag,\n        details,\n        samples: text.samples\n      };\n      hls.trigger(Events.FRAG_PARSING_USERDATA, emittedText);\n    }\n  }\n  logMuxedErr(frag) {\n    this.warn(`${isMediaFragment(frag) ? 'Media' : 'Init'} segment with muxed audiovideo where only video expected: ${frag.url}`);\n  }\n  _bufferInitSegment(currentLevel, tracks, frag, chunkMeta) {\n    if (this.state !== State.PARSING) {\n      return;\n    }\n    this.audioOnly = !!tracks.audio && !tracks.video;\n\n    // if audio track is expected to come from audio stream controller, discard any coming from main\n    if (this.altAudio && !this.audioOnly) {\n      delete tracks.audio;\n      if (tracks.audiovideo) {\n        this.logMuxedErr(frag);\n      }\n    }\n    // include levelCodec in audio and video tracks\n    const {\n      audio,\n      video,\n      audiovideo\n    } = tracks;\n    if (audio) {\n      const levelCodec = currentLevel.audioCodec;\n      let audioCodec = pickMostCompleteCodecName(audio.codec, levelCodec);\n      // Add level and profile to make up for remuxer not being able to parse full codec\n      // (logger warning \"Unhandled audio codec...\")\n      if (audioCodec === 'mp4a') {\n        audioCodec = 'mp4a.40.5';\n      }\n      // Handle `audioCodecSwitch`\n      const ua = navigator.userAgent.toLowerCase();\n      if (this.audioCodecSwitch) {\n        if (audioCodec) {\n          if (audioCodec.indexOf('mp4a.40.5') !== -1) {\n            audioCodec = 'mp4a.40.2';\n          } else {\n            audioCodec = 'mp4a.40.5';\n          }\n        }\n        // In the case that AAC and HE-AAC audio codecs are signalled in manifest,\n        // force HE-AAC, as it seems that most browsers prefers it.\n        // don't force HE-AAC if mono stream, or in Firefox\n        const audioMetadata = audio.metadata;\n        if (audioMetadata && 'channelCount' in audioMetadata && (audioMetadata.channelCount || 1) !== 1 && ua.indexOf('firefox') === -1) {\n          audioCodec = 'mp4a.40.5';\n        }\n      }\n      // HE-AAC is broken on Android, always signal audio codec as AAC even if variant manifest states otherwise\n      if (audioCodec && audioCodec.indexOf('mp4a.40.5') !== -1 && ua.indexOf('android') !== -1 && audio.container !== 'audio/mpeg') {\n        // Exclude mpeg audio\n        audioCodec = 'mp4a.40.2';\n        this.log(`Android: force audio codec to ${audioCodec}`);\n      }\n      if (levelCodec && levelCodec !== audioCodec) {\n        this.log(`Swapping manifest audio codec \"${levelCodec}\" for \"${audioCodec}\"`);\n      }\n      audio.levelCodec = audioCodec;\n      audio.id = PlaylistLevelType.MAIN;\n      this.log(`Init audio buffer, container:${audio.container}, codecs[selected/level/parsed]=[${audioCodec || ''}/${levelCodec || ''}/${audio.codec}]`);\n      delete tracks.audiovideo;\n    }\n    if (video) {\n      video.levelCodec = currentLevel.videoCodec;\n      video.id = PlaylistLevelType.MAIN;\n      const parsedVideoCodec = video.codec;\n      if ((parsedVideoCodec == null ? void 0 : parsedVideoCodec.length) === 4) {\n        // Make up for passthrough-remuxer not being able to parse full codec\n        // (logger warning \"Unhandled video codec...\")\n        switch (parsedVideoCodec) {\n          case 'hvc1':\n          case 'hev1':\n            video.codec = 'hvc1.1.6.L120.90';\n            break;\n          case 'av01':\n            video.codec = 'av01.0.04M.08';\n            break;\n          case 'avc1':\n            video.codec = 'avc1.42e01e';\n            break;\n        }\n      }\n      this.log(`Init video buffer, container:${video.container}, codecs[level/parsed]=[${currentLevel.videoCodec || ''}/${parsedVideoCodec}]${video.codec !== parsedVideoCodec ? ' parsed-corrected=' + video.codec : ''}${video.supplemental ? ' supplemental=' + video.supplemental : ''}`);\n      delete tracks.audiovideo;\n    }\n    if (audiovideo) {\n      this.log(`Init audiovideo buffer, container:${audiovideo.container}, codecs[level/parsed]=[${currentLevel.codecs}/${audiovideo.codec}]`);\n      delete tracks.video;\n      delete tracks.audio;\n    }\n    const trackTypes = Object.keys(tracks);\n    if (trackTypes.length) {\n      this.hls.trigger(Events.BUFFER_CODECS, tracks);\n      if (!this.hls) {\n        // Exit after fatal tracks error\n        return;\n      }\n      // loop through tracks that are going to be provided to bufferController\n      trackTypes.forEach(trackName => {\n        const track = tracks[trackName];\n        const initSegment = track.initSegment;\n        if (initSegment != null && initSegment.byteLength) {\n          this.hls.trigger(Events.BUFFER_APPENDING, {\n            type: trackName,\n            data: initSegment,\n            frag,\n            part: null,\n            chunkMeta,\n            parent: frag.type\n          });\n        }\n      });\n    }\n    // trigger handler right now\n    this.tickImmediate();\n  }\n  getMainFwdBufferInfo() {\n    // Observe video SourceBuffer (this.mediaBuffer) only when alt-audio is used, otherwise observe combined media buffer\n    const bufferOutput = this.mediaBuffer && this.altAudio === 2 ? this.mediaBuffer : this.media;\n    return this.getFwdBufferInfo(bufferOutput, PlaylistLevelType.MAIN);\n  }\n  get maxBufferLength() {\n    const {\n      levels,\n      level\n    } = this;\n    const levelInfo = levels == null ? void 0 : levels[level];\n    if (!levelInfo) {\n      return this.config.maxBufferLength;\n    }\n    return this.getMaxBufferLength(levelInfo.maxBitrate);\n  }\n  backtrack(frag) {\n    this.couldBacktrack = true;\n    // Causes findFragments to backtrack through fragments to find the keyframe\n    this.backtrackFragment = frag;\n    this.resetTransmuxer();\n    this.flushBufferGap(frag);\n    this.fragmentTracker.removeFragment(frag);\n    this.fragPrevious = null;\n    this.nextLoadPosition = frag.start;\n    this.state = State.IDLE;\n  }\n  checkFragmentChanged() {\n    const video = this.media;\n    let fragPlayingCurrent = null;\n    if (video && video.readyState > 1 && video.seeking === false) {\n      const currentTime = video.currentTime;\n      /* if video element is in seeked state, currentTime can only increase.\n        (assuming that playback rate is positive ...)\n        As sometimes currentTime jumps back to zero after a\n        media decode error, check this, to avoid seeking back to\n        wrong position after a media decode error\n      */\n\n      if (BufferHelper.isBuffered(video, currentTime)) {\n        fragPlayingCurrent = this.getAppendedFrag(currentTime);\n      } else if (BufferHelper.isBuffered(video, currentTime + 0.1)) {\n        /* ensure that FRAG_CHANGED event is triggered at startup,\n          when first video frame is displayed and playback is paused.\n          add a tolerance of 100ms, in case current position is not buffered,\n          check if current pos+100ms is buffered and use that buffer range\n          for FRAG_CHANGED event reporting */\n        fragPlayingCurrent = this.getAppendedFrag(currentTime + 0.1);\n      }\n      if (fragPlayingCurrent) {\n        this.backtrackFragment = null;\n        const fragPlaying = this.fragPlaying;\n        const fragCurrentLevel = fragPlayingCurrent.level;\n        if (!fragPlaying || fragPlayingCurrent.sn !== fragPlaying.sn || fragPlaying.level !== fragCurrentLevel) {\n          this.fragPlaying = fragPlayingCurrent;\n          this.hls.trigger(Events.FRAG_CHANGED, {\n            frag: fragPlayingCurrent\n          });\n          if (!fragPlaying || fragPlaying.level !== fragCurrentLevel) {\n            this.hls.trigger(Events.LEVEL_SWITCHED, {\n              level: fragCurrentLevel\n            });\n          }\n        }\n      }\n    }\n  }\n  get nextLevel() {\n    const frag = this.nextBufferedFrag;\n    if (frag) {\n      return frag.level;\n    }\n    return -1;\n  }\n  get currentFrag() {\n    var _this$media3;\n    if (this.fragPlaying) {\n      return this.fragPlaying;\n    }\n    const currentTime = ((_this$media3 = this.media) == null ? void 0 : _this$media3.currentTime) || this.lastCurrentTime;\n    if (isFiniteNumber(currentTime)) {\n      return this.getAppendedFrag(currentTime);\n    }\n    return null;\n  }\n  get currentProgramDateTime() {\n    var _this$media4;\n    const currentTime = ((_this$media4 = this.media) == null ? void 0 : _this$media4.currentTime) || this.lastCurrentTime;\n    if (isFiniteNumber(currentTime)) {\n      const details = this.getLevelDetails();\n      const frag = this.currentFrag || (details ? findFragmentByPTS(null, details.fragments, currentTime) : null);\n      if (frag) {\n        const programDateTime = frag.programDateTime;\n        if (programDateTime !== null) {\n          const epocMs = programDateTime + (currentTime - frag.start) * 1000;\n          return new Date(epocMs);\n        }\n      }\n    }\n    return null;\n  }\n  get currentLevel() {\n    const frag = this.currentFrag;\n    if (frag) {\n      return frag.level;\n    }\n    return -1;\n  }\n  get nextBufferedFrag() {\n    const frag = this.currentFrag;\n    if (frag) {\n      return this.followingBufferedFrag(frag);\n    }\n    return null;\n  }\n  get forceStartLoad() {\n    return this._forceStartLoad;\n  }\n}\n\nclass KeyLoader {\n  constructor(config) {\n    this.config = void 0;\n    this.keyUriToKeyInfo = {};\n    this.emeController = null;\n    this.config = config;\n  }\n  abort(type) {\n    for (const uri in this.keyUriToKeyInfo) {\n      const loader = this.keyUriToKeyInfo[uri].loader;\n      if (loader) {\n        var _loader$context;\n        if (type && type !== ((_loader$context = loader.context) == null ? void 0 : _loader$context.frag.type)) {\n          return;\n        }\n        loader.abort();\n      }\n    }\n  }\n  detach() {\n    for (const uri in this.keyUriToKeyInfo) {\n      const keyInfo = this.keyUriToKeyInfo[uri];\n      // Remove cached EME keys on detach\n      if (keyInfo.mediaKeySessionContext || keyInfo.decryptdata.isCommonEncryption) {\n        delete this.keyUriToKeyInfo[uri];\n      }\n    }\n  }\n  destroy() {\n    this.detach();\n    for (const uri in this.keyUriToKeyInfo) {\n      const loader = this.keyUriToKeyInfo[uri].loader;\n      if (loader) {\n        loader.destroy();\n      }\n    }\n    this.keyUriToKeyInfo = {};\n  }\n  createKeyLoadError(frag, details = ErrorDetails.KEY_LOAD_ERROR, error, networkDetails, response) {\n    return new LoadError({\n      type: ErrorTypes.NETWORK_ERROR,\n      details,\n      fatal: false,\n      frag,\n      response,\n      error,\n      networkDetails\n    });\n  }\n  loadClear(loadingFrag, encryptedFragments, startFragRequested) {\n    if (this.emeController && this.config.emeEnabled && !this.emeController.getSelectedKeySystemFormats().length) {\n      // Access key-system with nearest key on start (loading frag is unencrypted)\n      if (encryptedFragments.length) {\n        for (let i = 0, l = encryptedFragments.length; i < l; i++) {\n          const frag = encryptedFragments[i];\n          // Loading at or before segment with EXT-X-KEY, or first frag loading and last EXT-X-KEY\n          if (loadingFrag.cc <= frag.cc && (!isMediaFragment(loadingFrag) || !isMediaFragment(frag) || loadingFrag.sn < frag.sn) || !startFragRequested && i == l - 1) {\n            return this.emeController.selectKeySystemFormat(frag).then(keySystemFormat => {\n              if (!this.emeController) {\n                return;\n              }\n              frag.setKeyFormat(keySystemFormat);\n              const keySystem = keySystemFormatToKeySystemDomain(keySystemFormat);\n              if (keySystem) {\n                return this.emeController.getKeySystemAccess([keySystem]);\n              }\n            });\n          }\n        }\n      }\n      if (this.config.requireKeySystemAccessOnStart) {\n        const keySystemsInConfig = getKeySystemsForConfig(this.config);\n        if (keySystemsInConfig.length) {\n          return this.emeController.getKeySystemAccess(keySystemsInConfig);\n        }\n      }\n    }\n    return null;\n  }\n  load(frag) {\n    if (!frag.decryptdata && frag.encrypted && this.emeController && this.config.emeEnabled) {\n      // Multiple keys, but none selected, resolve in eme-controller\n      return this.emeController.selectKeySystemFormat(frag).then(keySystemFormat => {\n        return this.loadInternal(frag, keySystemFormat);\n      });\n    }\n    return this.loadInternal(frag);\n  }\n  loadInternal(frag, keySystemFormat) {\n    var _keyInfo, _keyInfo2;\n    if (keySystemFormat) {\n      frag.setKeyFormat(keySystemFormat);\n    }\n    const decryptdata = frag.decryptdata;\n    if (!decryptdata) {\n      const error = new Error(keySystemFormat ? `Expected frag.decryptdata to be defined after setting format ${keySystemFormat}` : 'Missing decryption data on fragment in onKeyLoading');\n      return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, error));\n    }\n    const uri = decryptdata.uri;\n    if (!uri) {\n      return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(`Invalid key URI: \"${uri}\"`)));\n    }\n    let keyInfo = this.keyUriToKeyInfo[uri];\n    if ((_keyInfo = keyInfo) != null && _keyInfo.decryptdata.key) {\n      decryptdata.key = keyInfo.decryptdata.key;\n      return Promise.resolve({\n        frag,\n        keyInfo\n      });\n    }\n    // Return key load promise as long as it does not have a mediakey session with an unusable key status\n    if ((_keyInfo2 = keyInfo) != null && _keyInfo2.keyLoadPromise) {\n      var _keyInfo$mediaKeySess;\n      switch ((_keyInfo$mediaKeySess = keyInfo.mediaKeySessionContext) == null ? void 0 : _keyInfo$mediaKeySess.keyStatus) {\n        case undefined:\n        case 'status-pending':\n        case 'usable':\n        case 'usable-in-future':\n          return keyInfo.keyLoadPromise.then(keyLoadedData => {\n            // Return the correct fragment with updated decryptdata key and loaded keyInfo\n            decryptdata.key = keyLoadedData.keyInfo.decryptdata.key;\n            return {\n              frag,\n              keyInfo\n            };\n          });\n      }\n      // If we have a key session and status and it is not pending or usable, continue\n      // This will go back to the eme-controller for expired keys to get a new keyLoadPromise\n    }\n\n    // Load the key or return the loading promise\n    keyInfo = this.keyUriToKeyInfo[uri] = {\n      decryptdata,\n      keyLoadPromise: null,\n      loader: null,\n      mediaKeySessionContext: null\n    };\n    switch (decryptdata.method) {\n      case 'ISO-23001-7':\n      case 'SAMPLE-AES':\n      case 'SAMPLE-AES-CENC':\n      case 'SAMPLE-AES-CTR':\n        if (decryptdata.keyFormat === 'identity') {\n          // loadKeyHTTP handles http(s) and data URLs\n          return this.loadKeyHTTP(keyInfo, frag);\n        }\n        return this.loadKeyEME(keyInfo, frag);\n      case 'AES-128':\n      case 'AES-256':\n      case 'AES-256-CTR':\n        return this.loadKeyHTTP(keyInfo, frag);\n      default:\n        return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(`Key supplied with unsupported METHOD: \"${decryptdata.method}\"`)));\n    }\n  }\n  loadKeyEME(keyInfo, frag) {\n    const keyLoadedData = {\n      frag,\n      keyInfo\n    };\n    if (this.emeController && this.config.emeEnabled) {\n      const keySessionContextPromise = this.emeController.loadKey(keyLoadedData);\n      if (keySessionContextPromise) {\n        return (keyInfo.keyLoadPromise = keySessionContextPromise.then(keySessionContext => {\n          keyInfo.mediaKeySessionContext = keySessionContext;\n          return keyLoadedData;\n        })).catch(error => {\n          // Remove promise for license renewal or retry\n          keyInfo.keyLoadPromise = null;\n          throw error;\n        });\n      }\n    }\n    return Promise.resolve(keyLoadedData);\n  }\n  loadKeyHTTP(keyInfo, frag) {\n    const config = this.config;\n    const Loader = config.loader;\n    const keyLoader = new Loader(config);\n    frag.keyLoader = keyInfo.loader = keyLoader;\n    return keyInfo.keyLoadPromise = new Promise((resolve, reject) => {\n      const loaderContext = {\n        keyInfo,\n        frag,\n        responseType: 'arraybuffer',\n        url: keyInfo.decryptdata.uri\n      };\n\n      // maxRetry is 0 so that instead of retrying the same key on the same variant multiple times,\n      // key-loader will trigger an error and rely on stream-controller to handle retry logic.\n      // this will also align retry logic with fragment-loader\n      const loadPolicy = config.keyLoadPolicy.default;\n      const loaderConfig = {\n        loadPolicy,\n        timeout: loadPolicy.maxLoadTimeMs,\n        maxRetry: 0,\n        retryDelay: 0,\n        maxRetryDelay: 0\n      };\n      const loaderCallbacks = {\n        onSuccess: (response, stats, context, networkDetails) => {\n          const {\n            frag,\n            keyInfo,\n            url: uri\n          } = context;\n          if (!frag.decryptdata || keyInfo !== this.keyUriToKeyInfo[uri]) {\n            return reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error('after key load, decryptdata unset or changed'), networkDetails));\n          }\n          keyInfo.decryptdata.key = frag.decryptdata.key = new Uint8Array(response.data);\n\n          // detach fragment key loader on load success\n          frag.keyLoader = null;\n          keyInfo.loader = null;\n          resolve({\n            frag,\n            keyInfo\n          });\n        },\n        onError: (response, context, networkDetails, stats) => {\n          this.resetLoader(context);\n          reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(`HTTP Error ${response.code} loading key ${response.text}`), networkDetails, _objectSpread2({\n            url: loaderContext.url,\n            data: undefined\n          }, response)));\n        },\n        onTimeout: (stats, context, networkDetails) => {\n          this.resetLoader(context);\n          reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_TIMEOUT, new Error('key loading timed out'), networkDetails));\n        },\n        onAbort: (stats, context, networkDetails) => {\n          this.resetLoader(context);\n          reject(this.createKeyLoadError(frag, ErrorDetails.INTERNAL_ABORTED, new Error('key loading aborted'), networkDetails));\n        }\n      };\n      keyLoader.load(loaderContext, loaderConfig, loaderCallbacks);\n    });\n  }\n  resetLoader(context) {\n    const {\n      frag,\n      keyInfo,\n      url: uri\n    } = context;\n    const loader = keyInfo.loader;\n    if (frag.keyLoader === loader) {\n      frag.keyLoader = null;\n      keyInfo.loader = null;\n    }\n    delete this.keyUriToKeyInfo[uri];\n    if (loader) {\n      loader.destroy();\n    }\n  }\n}\n\nfunction mapContextToLevelType(context) {\n  const {\n    type\n  } = context;\n  switch (type) {\n    case PlaylistContextType.AUDIO_TRACK:\n      return PlaylistLevelType.AUDIO;\n    case PlaylistContextType.SUBTITLE_TRACK:\n      return PlaylistLevelType.SUBTITLE;\n    default:\n      return PlaylistLevelType.MAIN;\n  }\n}\nfunction getResponseUrl(response, context) {\n  let url = response.url;\n  // responseURL not supported on some browsers (it is used to detect URL redirection)\n  // data-uri mode also not supported (but no need to detect redirection)\n  if (url === undefined || url.indexOf('data:') === 0) {\n    // fallback to initial URL\n    url = context.url;\n  }\n  return url;\n}\nclass PlaylistLoader {\n  constructor(hls) {\n    this.hls = void 0;\n    this.loaders = Object.create(null);\n    this.variableList = null;\n    this.onManifestLoaded = this.checkAutostartLoad;\n    this.hls = hls;\n    this.registerListeners();\n  }\n  startLoad(startPosition) {}\n  stopLoad() {\n    this.destroyInternalLoaders();\n  }\n  registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.on(Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);\n    hls.on(Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);\n    hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n  }\n  unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.off(Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);\n    hls.off(Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);\n    hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n  }\n\n  /**\n   * Returns defaults or configured loader-type overloads (pLoader and loader config params)\n   */\n  createInternalLoader(context) {\n    const config = this.hls.config;\n    const PLoader = config.pLoader;\n    const Loader = config.loader;\n    const InternalLoader = PLoader || Loader;\n    const loader = new InternalLoader(config);\n    this.loaders[context.type] = loader;\n    return loader;\n  }\n  getInternalLoader(context) {\n    return this.loaders[context.type];\n  }\n  resetInternalLoader(contextType) {\n    if (this.loaders[contextType]) {\n      delete this.loaders[contextType];\n    }\n  }\n\n  /**\n   * Call `destroy` on all internal loader instances mapped (one per context type)\n   */\n  destroyInternalLoaders() {\n    for (const contextType in this.loaders) {\n      const loader = this.loaders[contextType];\n      if (loader) {\n        loader.destroy();\n      }\n      this.resetInternalLoader(contextType);\n    }\n  }\n  destroy() {\n    this.variableList = null;\n    this.unregisterListeners();\n    this.destroyInternalLoaders();\n  }\n  onManifestLoading(event, data) {\n    const {\n      url\n    } = data;\n    this.variableList = null;\n    this.load({\n      id: null,\n      level: 0,\n      responseType: 'text',\n      type: PlaylistContextType.MANIFEST,\n      url,\n      deliveryDirectives: null,\n      levelOrTrack: null\n    });\n  }\n  onLevelLoading(event, data) {\n    const {\n      id,\n      level,\n      pathwayId,\n      url,\n      deliveryDirectives,\n      levelInfo\n    } = data;\n    this.load({\n      id,\n      level,\n      pathwayId,\n      responseType: 'text',\n      type: PlaylistContextType.LEVEL,\n      url,\n      deliveryDirectives,\n      levelOrTrack: levelInfo\n    });\n  }\n  onAudioTrackLoading(event, data) {\n    const {\n      id,\n      groupId,\n      url,\n      deliveryDirectives,\n      track\n    } = data;\n    this.load({\n      id,\n      groupId,\n      level: null,\n      responseType: 'text',\n      type: PlaylistContextType.AUDIO_TRACK,\n      url,\n      deliveryDirectives,\n      levelOrTrack: track\n    });\n  }\n  onSubtitleTrackLoading(event, data) {\n    const {\n      id,\n      groupId,\n      url,\n      deliveryDirectives,\n      track\n    } = data;\n    this.load({\n      id,\n      groupId,\n      level: null,\n      responseType: 'text',\n      type: PlaylistContextType.SUBTITLE_TRACK,\n      url,\n      deliveryDirectives,\n      levelOrTrack: track\n    });\n  }\n  onLevelsUpdated(event, data) {\n    // abort and delete loader of removed levels\n    const loader = this.loaders[PlaylistContextType.LEVEL];\n    if (loader) {\n      const context = loader.context;\n      if (context && !data.levels.some(lvl => lvl === context.levelOrTrack)) {\n        loader.abort();\n        delete this.loaders[PlaylistContextType.LEVEL];\n      }\n    }\n  }\n  load(context) {\n    var _context$deliveryDire;\n    const config = this.hls.config;\n\n    // logger.debug(`[playlist-loader]: Loading playlist of type ${context.type}, level: ${context.level}, id: ${context.id}`);\n\n    // Check if a loader for this context already exists\n    let loader = this.getInternalLoader(context);\n    if (loader) {\n      const logger = this.hls.logger;\n      const loaderContext = loader.context;\n      if (loaderContext && loaderContext.levelOrTrack === context.levelOrTrack && (loaderContext.url === context.url || loaderContext.deliveryDirectives && !context.deliveryDirectives)) {\n        // same URL can't overlap, or wait for blocking request\n        if (loaderContext.url === context.url) {\n          logger.log(`[playlist-loader]: ignore ${context.url} ongoing request`);\n        } else {\n          logger.log(`[playlist-loader]: ignore ${context.url} in favor of ${loaderContext.url}`);\n        }\n        return;\n      }\n      logger.log(`[playlist-loader]: aborting previous loader for type: ${context.type}`);\n      loader.abort();\n    }\n\n    // apply different configs for retries depending on\n    // context (manifest, level, audio/subs playlist)\n    let loadPolicy;\n    if (context.type === PlaylistContextType.MANIFEST) {\n      loadPolicy = config.manifestLoadPolicy.default;\n    } else {\n      loadPolicy = _extends({}, config.playlistLoadPolicy.default, {\n        timeoutRetry: null,\n        errorRetry: null\n      });\n    }\n    loader = this.createInternalLoader(context);\n\n    // Override level/track timeout for LL-HLS requests\n    // (the default of 10000ms is counter productive to blocking playlist reload requests)\n    if (isFiniteNumber((_context$deliveryDire = context.deliveryDirectives) == null ? void 0 : _context$deliveryDire.part)) {\n      let levelDetails;\n      if (context.type === PlaylistContextType.LEVEL && context.level !== null) {\n        levelDetails = this.hls.levels[context.level].details;\n      } else if (context.type === PlaylistContextType.AUDIO_TRACK && context.id !== null) {\n        levelDetails = this.hls.audioTracks[context.id].details;\n      } else if (context.type === PlaylistContextType.SUBTITLE_TRACK && context.id !== null) {\n        levelDetails = this.hls.subtitleTracks[context.id].details;\n      }\n      if (levelDetails) {\n        const partTarget = levelDetails.partTarget;\n        const targetDuration = levelDetails.targetduration;\n        if (partTarget && targetDuration) {\n          const maxLowLatencyPlaylistRefresh = Math.max(partTarget * 3, targetDuration * 0.8) * 1000;\n          loadPolicy = _extends({}, loadPolicy, {\n            maxTimeToFirstByteMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs),\n            maxLoadTimeMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs)\n          });\n        }\n      }\n    }\n    const legacyRetryCompatibility = loadPolicy.errorRetry || loadPolicy.timeoutRetry || {};\n    const loaderConfig = {\n      loadPolicy,\n      timeout: loadPolicy.maxLoadTimeMs,\n      maxRetry: legacyRetryCompatibility.maxNumRetry || 0,\n      retryDelay: legacyRetryCompatibility.retryDelayMs || 0,\n      maxRetryDelay: legacyRetryCompatibility.maxRetryDelayMs || 0\n    };\n    const loaderCallbacks = {\n      onSuccess: (response, stats, context, networkDetails) => {\n        const loader = this.getInternalLoader(context);\n        this.resetInternalLoader(context.type);\n        const string = response.data;\n\n        // Validate if it is an M3U8 at all\n        if (string.indexOf('#EXTM3U') !== 0) {\n          this.handleManifestParsingError(response, context, new Error('no EXTM3U delimiter'), networkDetails || null, stats);\n          return;\n        }\n        stats.parsing.start = performance.now();\n        if (M3U8Parser.isMediaPlaylist(string) || context.type !== PlaylistContextType.MANIFEST) {\n          this.handleTrackOrLevelPlaylist(response, stats, context, networkDetails || null, loader);\n        } else {\n          this.handleMasterPlaylist(response, stats, context, networkDetails);\n        }\n      },\n      onError: (response, context, networkDetails, stats) => {\n        this.handleNetworkError(context, networkDetails, false, response, stats);\n      },\n      onTimeout: (stats, context, networkDetails) => {\n        this.handleNetworkError(context, networkDetails, true, undefined, stats);\n      }\n    };\n\n    // logger.debug(`[playlist-loader]: Calling internal loader delegate for URL: ${context.url}`);\n\n    loader.load(context, loaderConfig, loaderCallbacks);\n  }\n  checkAutostartLoad() {\n    if (!this.hls) {\n      return;\n    }\n    const {\n      config: {\n        autoStartLoad,\n        startPosition\n      },\n      forceStartLoad\n    } = this.hls;\n    if (autoStartLoad || forceStartLoad) {\n      this.hls.logger.log(`${autoStartLoad ? 'auto' : 'force'} startLoad with configured startPosition ${startPosition}`);\n      this.hls.startLoad(startPosition);\n    }\n  }\n  handleMasterPlaylist(response, stats, context, networkDetails) {\n    const hls = this.hls;\n    const string = response.data;\n    const url = getResponseUrl(response, context);\n    const parsedResult = M3U8Parser.parseMasterPlaylist(string, url);\n    if (parsedResult.playlistParsingError) {\n      this.handleManifestParsingError(response, context, parsedResult.playlistParsingError, networkDetails, stats);\n      return;\n    }\n    const {\n      contentSteering,\n      levels,\n      sessionData,\n      sessionKeys,\n      startTimeOffset,\n      variableList\n    } = parsedResult;\n    this.variableList = variableList;\n    const {\n      AUDIO: audioTracks = [],\n      SUBTITLES: subtitles,\n      'CLOSED-CAPTIONS': captions\n    } = M3U8Parser.parseMasterPlaylistMedia(string, url, parsedResult);\n    if (audioTracks.length) {\n      // check if we have found an audio track embedded in main playlist (audio track without URI attribute)\n      const embeddedAudioFound = audioTracks.some(audioTrack => !audioTrack.url);\n\n      // if no embedded audio track defined, but audio codec signaled in quality level,\n      // we need to signal this main audio track this could happen with playlists with\n      // alt audio rendition in which quality levels (main)\n      // contains both audio+video. but with mixed audio track not signaled\n      if (!embeddedAudioFound && levels[0].audioCodec && !levels[0].attrs.AUDIO) {\n        this.hls.logger.log('[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one');\n        audioTracks.unshift({\n          type: 'main',\n          name: 'main',\n          groupId: 'main',\n          default: false,\n          autoselect: false,\n          forced: false,\n          id: -1,\n          attrs: new AttrList({}),\n          bitrate: 0,\n          url: ''\n        });\n      }\n    }\n    hls.trigger(Events.MANIFEST_LOADED, {\n      levels,\n      audioTracks,\n      subtitles,\n      captions,\n      contentSteering,\n      url,\n      stats,\n      networkDetails,\n      sessionData,\n      sessionKeys,\n      startTimeOffset,\n      variableList\n    });\n  }\n  handleTrackOrLevelPlaylist(response, stats, context, networkDetails, loader) {\n    const hls = this.hls;\n    const {\n      id,\n      level,\n      type\n    } = context;\n    const url = getResponseUrl(response, context);\n    const levelId = isFiniteNumber(level) ? level : isFiniteNumber(id) ? id : 0;\n    const levelType = mapContextToLevelType(context);\n    const levelDetails = M3U8Parser.parseLevelPlaylist(response.data, url, levelId, levelType, 0, this.variableList);\n\n    // We have done our first request (Manifest-type) and receive\n    // not a master playlist but a chunk-list (track/level)\n    // We fire the manifest-loaded event anyway with the parsed level-details\n    // by creating a single-level structure for it.\n    if (type === PlaylistContextType.MANIFEST) {\n      const singleLevel = {\n        attrs: new AttrList({}),\n        bitrate: 0,\n        details: levelDetails,\n        name: '',\n        url\n      };\n      levelDetails.requestScheduled = stats.loading.start + computeReloadInterval(levelDetails, 0);\n      hls.trigger(Events.MANIFEST_LOADED, {\n        levels: [singleLevel],\n        audioTracks: [],\n        url,\n        stats,\n        networkDetails,\n        sessionData: null,\n        sessionKeys: null,\n        contentSteering: null,\n        startTimeOffset: null,\n        variableList: null\n      });\n    }\n\n    // save parsing time\n    stats.parsing.end = performance.now();\n\n    // extend the context with the new levelDetails property\n    context.levelDetails = levelDetails;\n    this.handlePlaylistLoaded(levelDetails, response, stats, context, networkDetails, loader);\n  }\n  handleManifestParsingError(response, context, error, networkDetails, stats) {\n    this.hls.trigger(Events.ERROR, {\n      type: ErrorTypes.NETWORK_ERROR,\n      details: ErrorDetails.MANIFEST_PARSING_ERROR,\n      fatal: context.type === PlaylistContextType.MANIFEST,\n      url: response.url,\n      err: error,\n      error,\n      reason: error.message,\n      response,\n      context,\n      networkDetails,\n      stats\n    });\n  }\n  handleNetworkError(context, networkDetails, timeout = false, response, stats) {\n    let message = `A network ${timeout ? 'timeout' : 'error' + (response ? ' (status ' + response.code + ')' : '')} occurred while loading ${context.type}`;\n    if (context.type === PlaylistContextType.LEVEL) {\n      message += `: ${context.level} id: ${context.id}`;\n    } else if (context.type === PlaylistContextType.AUDIO_TRACK || context.type === PlaylistContextType.SUBTITLE_TRACK) {\n      message += ` id: ${context.id} group-id: \"${context.groupId}\"`;\n    }\n    const error = new Error(message);\n    this.hls.logger.warn(`[playlist-loader]: ${message}`);\n    let details = ErrorDetails.UNKNOWN;\n    let fatal = false;\n    const loader = this.getInternalLoader(context);\n    switch (context.type) {\n      case PlaylistContextType.MANIFEST:\n        details = timeout ? ErrorDetails.MANIFEST_LOAD_TIMEOUT : ErrorDetails.MANIFEST_LOAD_ERROR;\n        fatal = true;\n        break;\n      case PlaylistContextType.LEVEL:\n        details = timeout ? ErrorDetails.LEVEL_LOAD_TIMEOUT : ErrorDetails.LEVEL_LOAD_ERROR;\n        fatal = false;\n        break;\n      case PlaylistContextType.AUDIO_TRACK:\n        details = timeout ? ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT : ErrorDetails.AUDIO_TRACK_LOAD_ERROR;\n        fatal = false;\n        break;\n      case PlaylistContextType.SUBTITLE_TRACK:\n        details = timeout ? ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT : ErrorDetails.SUBTITLE_LOAD_ERROR;\n        fatal = false;\n        break;\n    }\n    if (loader) {\n      this.resetInternalLoader(context.type);\n    }\n    const errorData = {\n      type: ErrorTypes.NETWORK_ERROR,\n      details,\n      fatal,\n      url: context.url,\n      loader,\n      context,\n      error,\n      networkDetails,\n      stats\n    };\n    if (response) {\n      const url = (networkDetails == null ? void 0 : networkDetails.url) || context.url;\n      errorData.response = _objectSpread2({\n        url,\n        data: undefined\n      }, response);\n    }\n    this.hls.trigger(Events.ERROR, errorData);\n  }\n  handlePlaylistLoaded(levelDetails, response, stats, context, networkDetails, loader) {\n    const hls = this.hls;\n    const {\n      type,\n      level,\n      id,\n      groupId,\n      deliveryDirectives\n    } = context;\n    const url = getResponseUrl(response, context);\n    const parent = mapContextToLevelType(context);\n    const levelIndex = typeof context.level === 'number' && parent === PlaylistLevelType.MAIN ? level : undefined;\n    if (!levelDetails.fragments.length) {\n      const _error = levelDetails.playlistParsingError = new Error('No Segments found in Playlist');\n      hls.trigger(Events.ERROR, {\n        type: ErrorTypes.NETWORK_ERROR,\n        details: ErrorDetails.LEVEL_EMPTY_ERROR,\n        fatal: false,\n        url,\n        error: _error,\n        reason: _error.message,\n        response,\n        context,\n        level: levelIndex,\n        parent,\n        networkDetails,\n        stats\n      });\n      return;\n    }\n    if (!levelDetails.targetduration) {\n      levelDetails.playlistParsingError = new Error('Missing Target Duration');\n    }\n    const error = levelDetails.playlistParsingError;\n    if (error) {\n      this.hls.logger.warn(error);\n      if (!hls.config.ignorePlaylistParsingErrors) {\n        hls.trigger(Events.ERROR, {\n          type: ErrorTypes.NETWORK_ERROR,\n          details: ErrorDetails.LEVEL_PARSING_ERROR,\n          fatal: false,\n          url,\n          error,\n          reason: error.message,\n          response,\n          context,\n          level: levelIndex,\n          parent,\n          networkDetails,\n          stats\n        });\n        return;\n      }\n      levelDetails.playlistParsingError = null;\n    }\n    if (levelDetails.live && loader) {\n      if (loader.getCacheAge) {\n        levelDetails.ageHeader = loader.getCacheAge() || 0;\n      }\n      if (!loader.getCacheAge || isNaN(levelDetails.ageHeader)) {\n        levelDetails.ageHeader = 0;\n      }\n    }\n    switch (type) {\n      case PlaylistContextType.MANIFEST:\n      case PlaylistContextType.LEVEL:\n        hls.trigger(Events.LEVEL_LOADED, {\n          details: levelDetails,\n          levelInfo: context.levelOrTrack || hls.levels[0],\n          level: levelIndex || 0,\n          id: id || 0,\n          stats,\n          networkDetails,\n          deliveryDirectives,\n          withoutMultiVariant: type === PlaylistContextType.MANIFEST\n        });\n        break;\n      case PlaylistContextType.AUDIO_TRACK:\n        hls.trigger(Events.AUDIO_TRACK_LOADED, {\n          details: levelDetails,\n          track: context.levelOrTrack,\n          id: id || 0,\n          groupId: groupId || '',\n          stats,\n          networkDetails,\n          deliveryDirectives\n        });\n        break;\n      case PlaylistContextType.SUBTITLE_TRACK:\n        hls.trigger(Events.SUBTITLE_TRACK_LOADED, {\n          details: levelDetails,\n          track: context.levelOrTrack,\n          id: id || 0,\n          groupId: groupId || '',\n          stats,\n          networkDetails,\n          deliveryDirectives\n        });\n        break;\n    }\n  }\n}\n\n/**\n * The `Hls` class is the core of the HLS.js library used to instantiate player instances.\n * @public\n */\nclass Hls {\n  /**\n   * Get the video-dev/hls.js package version.\n   */\n  static get version() {\n    return version;\n  }\n\n  /**\n   * Check if the required MediaSource Extensions are available.\n   */\n  static isMSESupported() {\n    return isMSESupported();\n  }\n\n  /**\n   * Check if MediaSource Extensions are available and isTypeSupported checks pass for any baseline codecs.\n   */\n  static isSupported() {\n    return isSupported();\n  }\n\n  /**\n   * Get the MediaSource global used for MSE playback (ManagedMediaSource, MediaSource, or WebKitMediaSource).\n   */\n  static getMediaSource() {\n    return getMediaSource();\n  }\n  static get Events() {\n    return Events;\n  }\n  static get MetadataSchema() {\n    return MetadataSchema;\n  }\n  static get ErrorTypes() {\n    return ErrorTypes;\n  }\n  static get ErrorDetails() {\n    return ErrorDetails;\n  }\n\n  /**\n   * Get the default configuration applied to new instances.\n   */\n  static get DefaultConfig() {\n    if (!Hls.defaultConfig) {\n      return hlsDefaultConfig;\n    }\n    return Hls.defaultConfig;\n  }\n\n  /**\n   * Replace the default configuration applied to new instances.\n   */\n  static set DefaultConfig(defaultConfig) {\n    Hls.defaultConfig = defaultConfig;\n  }\n\n  /**\n   * Creates an instance of an HLS client that can attach to exactly one `HTMLMediaElement`.\n   * @param userConfig - Configuration options applied over `Hls.DefaultConfig`\n   */\n  constructor(userConfig = {}) {\n    /**\n     * The runtime configuration used by the player. At instantiation this is combination of `hls.userConfig` merged over `Hls.DefaultConfig`.\n     */\n    this.config = void 0;\n    /**\n     * The configuration object provided on player instantiation.\n     */\n    this.userConfig = void 0;\n    /**\n     * The logger functions used by this player instance, configured on player instantiation.\n     */\n    this.logger = void 0;\n    this.coreComponents = void 0;\n    this.networkControllers = void 0;\n    this._emitter = new EventEmitter();\n    this._autoLevelCapping = -1;\n    this._maxHdcpLevel = null;\n    this.abrController = void 0;\n    this.bufferController = void 0;\n    this.capLevelController = void 0;\n    this.latencyController = void 0;\n    this.levelController = void 0;\n    this.streamController = void 0;\n    this.audioStreamController = void 0;\n    this.subtititleStreamController = void 0;\n    this.audioTrackController = void 0;\n    this.subtitleTrackController = void 0;\n    this.interstitialsController = void 0;\n    this.gapController = void 0;\n    this.emeController = void 0;\n    this.cmcdController = void 0;\n    this._media = null;\n    this._url = null;\n    this._sessionId = void 0;\n    this.triggeringException = void 0;\n    this.started = false;\n    const logger = this.logger = enableLogs(userConfig.debug || false, 'Hls instance', userConfig.assetPlayerId);\n    const config = this.config = mergeConfig(Hls.DefaultConfig, userConfig, logger);\n    this.userConfig = userConfig;\n    if (config.progressive) {\n      enableStreamingMode(config, logger);\n    }\n\n    // core controllers and network loaders\n    const {\n      abrController: _AbrController,\n      bufferController: _BufferController,\n      capLevelController: _CapLevelController,\n      errorController: _ErrorController,\n      fpsController: _FpsController\n    } = config;\n    const errorController = new _ErrorController(this);\n    const abrController = this.abrController = new _AbrController(this);\n    // FragmentTracker must be defined before StreamController because the order of event handling is important\n    const fragmentTracker = new FragmentTracker(this);\n    const _InterstitialsController = config.interstitialsController;\n    const interstitialsController = _InterstitialsController ? this.interstitialsController = new _InterstitialsController(this, Hls) : null;\n    const bufferController = this.bufferController = new _BufferController(this, fragmentTracker);\n    const capLevelController = this.capLevelController = new _CapLevelController(this);\n    const fpsController = new _FpsController(this);\n    const playListLoader = new PlaylistLoader(this);\n    const _ContentSteeringController = config.contentSteeringController;\n    // Instantiate ConentSteeringController before LevelController to receive Multivariant Playlist events first\n    const contentSteering = _ContentSteeringController ? new _ContentSteeringController(this) : null;\n    const levelController = this.levelController = new LevelController(this, contentSteering);\n    const id3TrackController = new ID3TrackController(this);\n    const keyLoader = new KeyLoader(this.config);\n    const streamController = this.streamController = new StreamController(this, fragmentTracker, keyLoader);\n    const gapController = this.gapController = new GapController(this, fragmentTracker);\n\n    // Cap level controller uses streamController to flush the buffer\n    capLevelController.setStreamController(streamController);\n    // fpsController uses streamController to switch when frames are being dropped\n    fpsController.setStreamController(streamController);\n    const networkControllers = [playListLoader, levelController, streamController];\n    if (interstitialsController) {\n      networkControllers.splice(1, 0, interstitialsController);\n    }\n    if (contentSteering) {\n      networkControllers.splice(1, 0, contentSteering);\n    }\n    this.networkControllers = networkControllers;\n    const coreComponents = [abrController, bufferController, gapController, capLevelController, fpsController, id3TrackController, fragmentTracker];\n    this.audioTrackController = this.createController(config.audioTrackController, networkControllers);\n    const AudioStreamControllerClass = config.audioStreamController;\n    if (AudioStreamControllerClass) {\n      networkControllers.push(this.audioStreamController = new AudioStreamControllerClass(this, fragmentTracker, keyLoader));\n    }\n    // Instantiate subtitleTrackController before SubtitleStreamController to receive level events first\n    this.subtitleTrackController = this.createController(config.subtitleTrackController, networkControllers);\n    const SubtitleStreamControllerClass = config.subtitleStreamController;\n    if (SubtitleStreamControllerClass) {\n      networkControllers.push(this.subtititleStreamController = new SubtitleStreamControllerClass(this, fragmentTracker, keyLoader));\n    }\n    this.createController(config.timelineController, coreComponents);\n    keyLoader.emeController = this.emeController = this.createController(config.emeController, coreComponents);\n    this.cmcdController = this.createController(config.cmcdController, coreComponents);\n    this.latencyController = this.createController(LatencyController, coreComponents);\n    this.coreComponents = coreComponents;\n\n    // Error controller handles errors before and after all other controllers\n    // This listener will be invoked after all other controllers error listeners\n    networkControllers.push(errorController);\n    const onErrorOut = errorController.onErrorOut;\n    if (typeof onErrorOut === 'function') {\n      this.on(Events.ERROR, onErrorOut, errorController);\n    }\n    // Autostart load handler\n    this.on(Events.MANIFEST_LOADED, playListLoader.onManifestLoaded, playListLoader);\n  }\n  createController(ControllerClass, components) {\n    if (ControllerClass) {\n      const controllerInstance = new ControllerClass(this);\n      if (components) {\n        components.push(controllerInstance);\n      }\n      return controllerInstance;\n    }\n    return null;\n  }\n\n  // Delegate the EventEmitter through the public API of Hls.js\n  on(event, listener, context = this) {\n    this._emitter.on(event, listener, context);\n  }\n  once(event, listener, context = this) {\n    this._emitter.once(event, listener, context);\n  }\n  removeAllListeners(event) {\n    this._emitter.removeAllListeners(event);\n  }\n  off(event, listener, context = this, once) {\n    this._emitter.off(event, listener, context, once);\n  }\n  listeners(event) {\n    return this._emitter.listeners(event);\n  }\n  emit(event, name, eventObject) {\n    return this._emitter.emit(event, name, eventObject);\n  }\n  trigger(event, eventObject) {\n    if (this.config.debug) {\n      return this.emit(event, event, eventObject);\n    } else {\n      try {\n        return this.emit(event, event, eventObject);\n      } catch (error) {\n        this.logger.error('An internal error happened while handling event ' + event + '. Error message: \"' + error.message + '\". Here is a stacktrace:', error);\n        // Prevent recursion in error event handlers that throw #5497\n        if (!this.triggeringException) {\n          this.triggeringException = true;\n          const fatal = event === Events.ERROR;\n          this.trigger(Events.ERROR, {\n            type: ErrorTypes.OTHER_ERROR,\n            details: ErrorDetails.INTERNAL_EXCEPTION,\n            fatal,\n            event,\n            error\n          });\n          this.triggeringException = false;\n        }\n      }\n    }\n    return false;\n  }\n  listenerCount(event) {\n    return this._emitter.listenerCount(event);\n  }\n\n  /**\n   * Dispose of the instance\n   */\n  destroy() {\n    this.logger.log('destroy');\n    this.trigger(Events.DESTROYING, undefined);\n    this.detachMedia();\n    this.removeAllListeners();\n    this._autoLevelCapping = -1;\n    this._url = null;\n    this.networkControllers.forEach(component => component.destroy());\n    this.networkControllers.length = 0;\n    this.coreComponents.forEach(component => component.destroy());\n    this.coreComponents.length = 0;\n    // Remove any references that could be held in config options or callbacks\n    const config = this.config;\n    config.xhrSetup = config.fetchSetup = undefined;\n    // @ts-ignore\n    this.userConfig = null;\n  }\n\n  /**\n   * Attaches Hls.js to a media element\n   */\n  attachMedia(data) {\n    if (!data || 'media' in data && !data.media) {\n      const error = new Error(`attachMedia failed: invalid argument (${data})`);\n      this.trigger(Events.ERROR, {\n        type: ErrorTypes.OTHER_ERROR,\n        details: ErrorDetails.ATTACH_MEDIA_ERROR,\n        fatal: true,\n        error\n      });\n      return;\n    }\n    this.logger.log(`attachMedia`);\n    if (this._media) {\n      this.logger.warn(`media must be detached before attaching`);\n      this.detachMedia();\n    }\n    const attachMediaSource = 'media' in data;\n    const media = attachMediaSource ? data.media : data;\n    const attachingData = attachMediaSource ? data : {\n      media\n    };\n    this._media = media;\n    this.trigger(Events.MEDIA_ATTACHING, attachingData);\n  }\n\n  /**\n   * Detach Hls.js from the media\n   */\n  detachMedia() {\n    this.logger.log('detachMedia');\n    this.trigger(Events.MEDIA_DETACHING, {});\n    this._media = null;\n  }\n\n  /**\n   * Detach HTMLMediaElement, MediaSource, and SourceBuffers without reset, for attaching to another instance\n   */\n  transferMedia() {\n    this._media = null;\n    const transferMedia = this.bufferController.transferMedia();\n    this.trigger(Events.MEDIA_DETACHING, {\n      transferMedia\n    });\n    return transferMedia;\n  }\n\n  /**\n   * Set the source URL. Can be relative or absolute.\n   */\n  loadSource(url) {\n    this.stopLoad();\n    const media = this.media;\n    const loadedSource = this._url;\n    const loadingSource = this._url = urlToolkitExports.buildAbsoluteURL(self.location.href, url, {\n      alwaysNormalize: true\n    });\n    this._autoLevelCapping = -1;\n    this._maxHdcpLevel = null;\n    this.logger.log(`loadSource:${loadingSource}`);\n    if (media && loadedSource && (loadedSource !== loadingSource || this.bufferController.hasSourceTypes())) {\n      // Remove and re-create MediaSource\n      this.detachMedia();\n      this.attachMedia(media);\n    }\n    // when attaching to a source URL, trigger a playlist load\n    this.trigger(Events.MANIFEST_LOADING, {\n      url: url\n    });\n  }\n\n  /**\n   * Gets the currently loaded URL\n   */\n  get url() {\n    return this._url;\n  }\n\n  /**\n   * Whether or not enough has been buffered to seek to start position or use `media.currentTime` to determine next load position\n   */\n  get hasEnoughToStart() {\n    return this.streamController.hasEnoughToStart;\n  }\n\n  /**\n   * Get the startPosition set on startLoad(position) or on autostart with config.startPosition\n   */\n  get startPosition() {\n    return this.streamController.startPositionValue;\n  }\n\n  /**\n   * Start loading data from the stream source.\n   * Depending on default config, client starts loading automatically when a source is set.\n   *\n   * @param startPosition - Set the start position to stream from.\n   * Defaults to -1 (None: starts from earliest point)\n   */\n  startLoad(startPosition = -1, skipSeekToStartPosition) {\n    this.logger.log(`startLoad(${startPosition + (skipSeekToStartPosition ? ', <skip seek to start>' : '')})`);\n    this.started = true;\n    this.resumeBuffering();\n    for (let i = 0; i < this.networkControllers.length; i++) {\n      this.networkControllers[i].startLoad(startPosition, skipSeekToStartPosition);\n      if (!this.started || !this.networkControllers) {\n        break;\n      }\n    }\n  }\n\n  /**\n   * Stop loading of any stream data.\n   */\n  stopLoad() {\n    this.logger.log('stopLoad');\n    this.started = false;\n    for (let i = 0; i < this.networkControllers.length; i++) {\n      this.networkControllers[i].stopLoad();\n      if (this.started || !this.networkControllers) {\n        break;\n      }\n    }\n  }\n\n  /**\n   * Returns whether loading, toggled with `startLoad()` and `stopLoad()`, is active or not`.\n   */\n  get loadingEnabled() {\n    return this.started;\n  }\n\n  /**\n   * Returns state of fragment loading toggled by calling `pauseBuffering()` and `resumeBuffering()`.\n   */\n  get bufferingEnabled() {\n    return this.streamController.bufferingEnabled;\n  }\n\n  /**\n   * Resumes stream controller segment loading after `pauseBuffering` has been called.\n   */\n  resumeBuffering() {\n    if (!this.bufferingEnabled) {\n      this.logger.log(`resume buffering`);\n      this.networkControllers.forEach(controller => {\n        if (controller.resumeBuffering) {\n          controller.resumeBuffering();\n        }\n      });\n    }\n  }\n\n  /**\n   * Prevents stream controller from loading new segments until `resumeBuffering` is called.\n   * This allows for media buffering to be paused without interupting playlist loading.\n   */\n  pauseBuffering() {\n    if (this.bufferingEnabled) {\n      this.logger.log(`pause buffering`);\n      this.networkControllers.forEach(controller => {\n        if (controller.pauseBuffering) {\n          controller.pauseBuffering();\n        }\n      });\n    }\n  }\n  get inFlightFragments() {\n    const inFlightData = {\n      [PlaylistLevelType.MAIN]: this.streamController.inFlightFrag\n    };\n    if (this.audioStreamController) {\n      inFlightData[PlaylistLevelType.AUDIO] = this.audioStreamController.inFlightFrag;\n    }\n    if (this.subtititleStreamController) {\n      inFlightData[PlaylistLevelType.SUBTITLE] = this.subtititleStreamController.inFlightFrag;\n    }\n    return inFlightData;\n  }\n\n  /**\n   * Swap through possible audio codecs in the stream (for example to switch from stereo to 5.1)\n   */\n  swapAudioCodec() {\n    this.logger.log('swapAudioCodec');\n    this.streamController.swapAudioCodec();\n  }\n\n  /**\n   * When the media-element fails, this allows to detach and then re-attach it\n   * as one call (convenience method).\n   *\n   * Automatic recovery of media-errors by this process is configurable.\n   */\n  recoverMediaError() {\n    this.logger.log('recoverMediaError');\n    const media = this._media;\n    const time = media == null ? void 0 : media.currentTime;\n    this.detachMedia();\n    if (media) {\n      this.attachMedia(media);\n      if (time) {\n        this.startLoad(time);\n      }\n    }\n  }\n  removeLevel(levelIndex) {\n    this.levelController.removeLevel(levelIndex);\n  }\n\n  /**\n   * @returns a UUID for this player instance\n   */\n  get sessionId() {\n    let _sessionId = this._sessionId;\n    if (!_sessionId) {\n      _sessionId = this._sessionId = uuid();\n    }\n    return _sessionId;\n  }\n\n  /**\n   * @returns an array of levels (variants) sorted by HDCP-LEVEL, RESOLUTION (height), FRAME-RATE, CODECS, VIDEO-RANGE, and BANDWIDTH\n   */\n  get levels() {\n    const levels = this.levelController.levels;\n    return levels ? levels : [];\n  }\n\n  /**\n   * @returns LevelDetails of last loaded level (variant) or `null` prior to loading a media playlist.\n   */\n  get latestLevelDetails() {\n    return this.streamController.getLevelDetails() || null;\n  }\n\n  /**\n   * @returns Level object of selected level (variant) or `null` prior to selecting a level or once the level is removed.\n   */\n  get loadLevelObj() {\n    return this.levelController.loadLevelObj;\n  }\n\n  /**\n   * Index of quality level (variant) currently played\n   */\n  get currentLevel() {\n    return this.streamController.currentLevel;\n  }\n\n  /**\n   * Set quality level index immediately. This will flush the current buffer to replace the quality asap. That means playback will interrupt at least shortly to re-buffer and re-sync eventually. Set to -1 for automatic level selection.\n   */\n  set currentLevel(newLevel) {\n    this.logger.log(`set currentLevel:${newLevel}`);\n    this.levelController.manualLevel = newLevel;\n    this.streamController.immediateLevelSwitch();\n  }\n\n  /**\n   * Index of next quality level loaded as scheduled by stream controller.\n   */\n  get nextLevel() {\n    return this.streamController.nextLevel;\n  }\n\n  /**\n   * Set quality level index for next loaded data.\n   * This will switch the video quality asap, without interrupting playback.\n   * May abort current loading of data, and flush parts of buffer (outside currently played fragment region).\n   * @param newLevel - Pass -1 for automatic level selection\n   */\n  set nextLevel(newLevel) {\n    this.logger.log(`set nextLevel:${newLevel}`);\n    this.levelController.manualLevel = newLevel;\n    this.streamController.nextLevelSwitch();\n  }\n\n  /**\n   * Return the quality level of the currently or last (of none is loaded currently) segment\n   */\n  get loadLevel() {\n    return this.levelController.level;\n  }\n\n  /**\n   * Set quality level index for next loaded data in a conservative way.\n   * This will switch the quality without flushing, but interrupt current loading.\n   * Thus the moment when the quality switch will appear in effect will only be after the already existing buffer.\n   * @param newLevel - Pass -1 for automatic level selection\n   */\n  set loadLevel(newLevel) {\n    this.logger.log(`set loadLevel:${newLevel}`);\n    this.levelController.manualLevel = newLevel;\n  }\n\n  /**\n   * get next quality level loaded\n   */\n  get nextLoadLevel() {\n    return this.levelController.nextLoadLevel;\n  }\n\n  /**\n   * Set quality level of next loaded segment in a fully \"non-destructive\" way.\n   * Same as `loadLevel` but will wait for next switch (until current loading is done).\n   */\n  set nextLoadLevel(level) {\n    this.levelController.nextLoadLevel = level;\n  }\n\n  /**\n   * Return \"first level\": like a default level, if not set,\n   * falls back to index of first level referenced in manifest\n   */\n  get firstLevel() {\n    return Math.max(this.levelController.firstLevel, this.minAutoLevel);\n  }\n\n  /**\n   * Sets \"first-level\", see getter.\n   */\n  set firstLevel(newLevel) {\n    this.logger.log(`set firstLevel:${newLevel}`);\n    this.levelController.firstLevel = newLevel;\n  }\n\n  /**\n   * Return the desired start level for the first fragment that will be loaded.\n   * The default value of -1 indicates automatic start level selection.\n   * Setting hls.nextAutoLevel without setting a startLevel will result in\n   * the nextAutoLevel value being used for one fragment load.\n   */\n  get startLevel() {\n    const startLevel = this.levelController.startLevel;\n    if (startLevel === -1 && this.abrController.forcedAutoLevel > -1) {\n      return this.abrController.forcedAutoLevel;\n    }\n    return startLevel;\n  }\n\n  /**\n   * set  start level (level of first fragment that will be played back)\n   * if not overrided by user, first level appearing in manifest will be used as start level\n   * if -1 : automatic start level selection, playback will start from level matching download bandwidth\n   * (determined from download of first segment)\n   */\n  set startLevel(newLevel) {\n    this.logger.log(`set startLevel:${newLevel}`);\n    // if not in automatic start level detection, ensure startLevel is greater than minAutoLevel\n    if (newLevel !== -1) {\n      newLevel = Math.max(newLevel, this.minAutoLevel);\n    }\n    this.levelController.startLevel = newLevel;\n  }\n\n  /**\n   * Whether level capping is enabled.\n   * Default value is set via `config.capLevelToPlayerSize`.\n   */\n  get capLevelToPlayerSize() {\n    return this.config.capLevelToPlayerSize;\n  }\n\n  /**\n   * Enables or disables level capping. If disabled after previously enabled, `nextLevelSwitch` will be immediately called.\n   */\n  set capLevelToPlayerSize(shouldStartCapping) {\n    const newCapLevelToPlayerSize = !!shouldStartCapping;\n    if (newCapLevelToPlayerSize !== this.config.capLevelToPlayerSize) {\n      if (newCapLevelToPlayerSize) {\n        this.capLevelController.startCapping(); // If capping occurs, nextLevelSwitch will happen based on size.\n      } else {\n        this.capLevelController.stopCapping();\n        this.autoLevelCapping = -1;\n        this.streamController.nextLevelSwitch(); // Now we're uncapped, get the next level asap.\n      }\n      this.config.capLevelToPlayerSize = newCapLevelToPlayerSize;\n    }\n  }\n\n  /**\n   * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)\n   */\n  get autoLevelCapping() {\n    return this._autoLevelCapping;\n  }\n\n  /**\n   * Returns the current bandwidth estimate in bits per second, when available. Otherwise, `NaN` is returned.\n   */\n  get bandwidthEstimate() {\n    const {\n      bwEstimator\n    } = this.abrController;\n    if (!bwEstimator) {\n      return NaN;\n    }\n    return bwEstimator.getEstimate();\n  }\n  set bandwidthEstimate(abrEwmaDefaultEstimate) {\n    this.abrController.resetEstimator(abrEwmaDefaultEstimate);\n  }\n  get abrEwmaDefaultEstimate() {\n    const {\n      bwEstimator\n    } = this.abrController;\n    if (!bwEstimator) {\n      return NaN;\n    }\n    return bwEstimator.defaultEstimate;\n  }\n\n  /**\n   * get time to first byte estimate\n   * @type {number}\n   */\n  get ttfbEstimate() {\n    const {\n      bwEstimator\n    } = this.abrController;\n    if (!bwEstimator) {\n      return NaN;\n    }\n    return bwEstimator.getEstimateTTFB();\n  }\n\n  /**\n   * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)\n   */\n  set autoLevelCapping(newLevel) {\n    if (this._autoLevelCapping !== newLevel) {\n      this.logger.log(`set autoLevelCapping:${newLevel}`);\n      this._autoLevelCapping = newLevel;\n      this.levelController.checkMaxAutoUpdated();\n    }\n  }\n  get maxHdcpLevel() {\n    return this._maxHdcpLevel;\n  }\n  set maxHdcpLevel(value) {\n    if (isHdcpLevel(value) && this._maxHdcpLevel !== value) {\n      this._maxHdcpLevel = value;\n      this.levelController.checkMaxAutoUpdated();\n    }\n  }\n\n  /**\n   * True when automatic level selection enabled\n   */\n  get autoLevelEnabled() {\n    return this.levelController.manualLevel === -1;\n  }\n\n  /**\n   * Level set manually (if any)\n   */\n  get manualLevel() {\n    return this.levelController.manualLevel;\n  }\n\n  /**\n   * min level selectable in auto mode according to config.minAutoBitrate\n   */\n  get minAutoLevel() {\n    const {\n      levels,\n      config: {\n        minAutoBitrate\n      }\n    } = this;\n    if (!levels) return 0;\n    const len = levels.length;\n    for (let i = 0; i < len; i++) {\n      if (levels[i].maxBitrate >= minAutoBitrate) {\n        return i;\n      }\n    }\n    return 0;\n  }\n\n  /**\n   * max level selectable in auto mode according to autoLevelCapping\n   */\n  get maxAutoLevel() {\n    const {\n      levels,\n      autoLevelCapping,\n      maxHdcpLevel\n    } = this;\n    let maxAutoLevel;\n    if (autoLevelCapping === -1 && levels != null && levels.length) {\n      maxAutoLevel = levels.length - 1;\n    } else {\n      maxAutoLevel = autoLevelCapping;\n    }\n    if (maxHdcpLevel) {\n      for (let i = maxAutoLevel; i--;) {\n        const hdcpLevel = levels[i].attrs['HDCP-LEVEL'];\n        if (hdcpLevel && hdcpLevel <= maxHdcpLevel) {\n          return i;\n        }\n      }\n    }\n    return maxAutoLevel;\n  }\n  get firstAutoLevel() {\n    return this.abrController.firstAutoLevel;\n  }\n\n  /**\n   * next automatically selected quality level\n   */\n  get nextAutoLevel() {\n    return this.abrController.nextAutoLevel;\n  }\n\n  /**\n   * this setter is used to force next auto level.\n   * this is useful to force a switch down in auto mode:\n   * in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)\n   * forced value is valid for one fragment. upon successful frag loading at forced level,\n   * this value will be resetted to -1 by ABR controller.\n   */\n  set nextAutoLevel(nextLevel) {\n    this.abrController.nextAutoLevel = nextLevel;\n  }\n\n  /**\n   * get the datetime value relative to media.currentTime for the active level Program Date Time if present\n   */\n  get playingDate() {\n    return this.streamController.currentProgramDateTime;\n  }\n  get mainForwardBufferInfo() {\n    return this.streamController.getMainFwdBufferInfo();\n  }\n  get maxBufferLength() {\n    return this.streamController.maxBufferLength;\n  }\n\n  /**\n   * Find and select the best matching audio track, making a level switch when a Group change is necessary.\n   * Updates `hls.config.audioPreference`. Returns the selected track, or null when no matching track is found.\n   */\n  setAudioOption(audioOption) {\n    var _this$audioTrackContr;\n    return ((_this$audioTrackContr = this.audioTrackController) == null ? void 0 : _this$audioTrackContr.setAudioOption(audioOption)) || null;\n  }\n  /**\n   * Find and select the best matching subtitle track, making a level switch when a Group change is necessary.\n   * Updates `hls.config.subtitlePreference`. Returns the selected track, or null when no matching track is found.\n   */\n  setSubtitleOption(subtitleOption) {\n    var _this$subtitleTrackCo;\n    return ((_this$subtitleTrackCo = this.subtitleTrackController) == null ? void 0 : _this$subtitleTrackCo.setSubtitleOption(subtitleOption)) || null;\n  }\n\n  /**\n   * Get the complete list of audio tracks across all media groups\n   */\n  get allAudioTracks() {\n    const audioTrackController = this.audioTrackController;\n    return audioTrackController ? audioTrackController.allAudioTracks : [];\n  }\n\n  /**\n   * Get the list of selectable audio tracks\n   */\n  get audioTracks() {\n    const audioTrackController = this.audioTrackController;\n    return audioTrackController ? audioTrackController.audioTracks : [];\n  }\n\n  /**\n   * index of the selected audio track (index in audio track lists)\n   */\n  get audioTrack() {\n    const audioTrackController = this.audioTrackController;\n    return audioTrackController ? audioTrackController.audioTrack : -1;\n  }\n\n  /**\n   * selects an audio track, based on its index in audio track lists\n   */\n  set audioTrack(audioTrackId) {\n    const audioTrackController = this.audioTrackController;\n    if (audioTrackController) {\n      audioTrackController.audioTrack = audioTrackId;\n    }\n  }\n\n  /**\n   * get the complete list of subtitle tracks across all media groups\n   */\n  get allSubtitleTracks() {\n    const subtitleTrackController = this.subtitleTrackController;\n    return subtitleTrackController ? subtitleTrackController.allSubtitleTracks : [];\n  }\n\n  /**\n   * get alternate subtitle tracks list from playlist\n   */\n  get subtitleTracks() {\n    const subtitleTrackController = this.subtitleTrackController;\n    return subtitleTrackController ? subtitleTrackController.subtitleTracks : [];\n  }\n\n  /**\n   * index of the selected subtitle track (index in subtitle track lists)\n   */\n  get subtitleTrack() {\n    const subtitleTrackController = this.subtitleTrackController;\n    return subtitleTrackController ? subtitleTrackController.subtitleTrack : -1;\n  }\n  get media() {\n    return this._media;\n  }\n\n  /**\n   * select an subtitle track, based on its index in subtitle track lists\n   */\n  set subtitleTrack(subtitleTrackId) {\n    const subtitleTrackController = this.subtitleTrackController;\n    if (subtitleTrackController) {\n      subtitleTrackController.subtitleTrack = subtitleTrackId;\n    }\n  }\n\n  /**\n   * Whether subtitle display is enabled or not\n   */\n  get subtitleDisplay() {\n    const subtitleTrackController = this.subtitleTrackController;\n    return subtitleTrackController ? subtitleTrackController.subtitleDisplay : false;\n  }\n\n  /**\n   * Enable/disable subtitle display rendering\n   */\n  set subtitleDisplay(value) {\n    const subtitleTrackController = this.subtitleTrackController;\n    if (subtitleTrackController) {\n      subtitleTrackController.subtitleDisplay = value;\n    }\n  }\n\n  /**\n   * get mode for Low-Latency HLS loading\n   */\n  get lowLatencyMode() {\n    return this.config.lowLatencyMode;\n  }\n\n  /**\n   * Enable/disable Low-Latency HLS part playlist and segment loading, and start live streams at playlist PART-HOLD-BACK rather than HOLD-BACK.\n   */\n  set lowLatencyMode(mode) {\n    this.config.lowLatencyMode = mode;\n  }\n\n  /**\n   * Position (in seconds) of live sync point (ie edge of live position minus safety delay defined by ```hls.config.liveSyncDuration```)\n   * @returns null prior to loading live Playlist\n   */\n  get liveSyncPosition() {\n    return this.latencyController.liveSyncPosition;\n  }\n\n  /**\n   * Estimated position (in seconds) of live edge (ie edge of live playlist plus time sync playlist advanced)\n   * @returns 0 before first playlist is loaded\n   */\n  get latency() {\n    return this.latencyController.latency;\n  }\n\n  /**\n   * maximum distance from the edge before the player seeks forward to ```hls.liveSyncPosition```\n   * configured using ```liveMaxLatencyDurationCount``` (multiple of target duration) or ```liveMaxLatencyDuration```\n   * @returns 0 before first playlist is loaded\n   */\n  get maxLatency() {\n    return this.latencyController.maxLatency;\n  }\n\n  /**\n   * target distance from the edge as calculated by the latency controller\n   */\n  get targetLatency() {\n    return this.latencyController.targetLatency;\n  }\n  set targetLatency(latency) {\n    this.latencyController.targetLatency = latency;\n  }\n\n  /**\n   * the rate at which the edge of the current live playlist is advancing or 1 if there is none\n   */\n  get drift() {\n    return this.latencyController.drift;\n  }\n\n  /**\n   * set to true when startLoad is called before MANIFEST_PARSED event\n   */\n  get forceStartLoad() {\n    return this.streamController.forceStartLoad;\n  }\n\n  /**\n   * ContentSteering pathways getter\n   */\n  get pathways() {\n    return this.levelController.pathways;\n  }\n\n  /**\n   * ContentSteering pathwayPriority getter/setter\n   */\n  get pathwayPriority() {\n    return this.levelController.pathwayPriority;\n  }\n  set pathwayPriority(pathwayPriority) {\n    this.levelController.pathwayPriority = pathwayPriority;\n  }\n\n  /**\n   * returns true when all SourceBuffers are buffered to the end\n   */\n  get bufferedToEnd() {\n    var _this$bufferControlle;\n    return !!((_this$bufferControlle = this.bufferController) != null && _this$bufferControlle.bufferedToEnd);\n  }\n\n  /**\n   * returns Interstitials Program Manager\n   */\n  get interstitialsManager() {\n    var _this$interstitialsCo;\n    return ((_this$interstitialsCo = this.interstitialsController) == null ? void 0 : _this$interstitialsCo.interstitialsManager) || null;\n  }\n\n  /**\n   * returns mediaCapabilities.decodingInfo for a variant/rendition\n   */\n  getMediaDecodingInfo(level, audioTracks = this.allAudioTracks) {\n    const audioTracksByGroup = getAudioTracksByGroup(audioTracks);\n    return getMediaDecodingInfoPromise(level, audioTracksByGroup, navigator.mediaCapabilities);\n  }\n}\nHls.defaultConfig = void 0;\n\n\n//# sourceMappingURL=hls.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9obHMuanMvZGlzdC9obHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUc7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELCtCQUErQjtBQUNuRjtBQUNBLHNEQUFzRCwrQkFBK0I7QUFDckY7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQSxpREFBaUQsK0JBQStCO0FBQ2hGO0FBQ0EsbURBQW1ELCtCQUErQjtBQUNsRjtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBLHdEQUF3RCwrQkFBK0I7QUFDdkY7QUFDQSwwREFBMEQsK0JBQStCO0FBQ3pGO0FBQ0EsMERBQTBELCtCQUErQjtBQUN6RjtBQUNBLDREQUE0RCwrQkFBK0I7QUFDM0Y7QUFDQSxrREFBa0QscUNBQXFDO0FBQ3ZGO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0EscURBQXFELHFDQUFxQztBQUMxRjtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBLDhGQUE4RjtBQUM5RjtBQUNBLGtKQUFrSjtBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSw2QkFBNkI7QUFDaEc7QUFDQSxxRUFBcUUsNkJBQTZCO0FBQ2xHO0FBQ0Esc0VBQXNFLHNEQUFzRDtBQUM1SDtBQUNBLHNFQUFzRSxzREFBc0Q7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUc7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLFdBQVc7QUFDbkc7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQSxrSEFBa0g7QUFDbEg7QUFDQSw4RkFBOEY7QUFDOUY7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQSwwSEFBMEg7QUFDMUg7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0EsNEhBQTRIO0FBQzVIO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0EseUVBQXlFLFlBQVksZ0RBQWdEO0FBQ3JJO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0EsNERBQTRELDBCQUEwQjtBQUN0RjtBQUNBLCtFQUErRTtBQUMvRTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBLDZEQUE2RCw4RUFBOEU7QUFDM0k7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQSxpRUFBaUU7QUFDakU7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQSw4RkFBOEY7QUFDOUY7QUFDQSxxRkFBcUY7QUFDckY7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0EsaUJBQWlCLDBDQUEwQztBQUMzRDtBQUNBLHVHQUF1RztBQUN2RztBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsR0FBRzs7QUFFSjtBQUNBLCtEQUErRCw4QkFBOEI7QUFDN0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsTUFBTTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLDBCQUEwQixHQUFHLEtBQUs7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRLHNCQUFzQixRQUFRO0FBQ3JGLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLEVBQUU7QUFDdkU7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjs7QUFFbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0ZBQXdGLGlCQUFpQjtBQUN6RztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsR0FBRztBQUNILEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrRUFBa0Usb0NBQW9DO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwRUFBMEUsbUNBQW1DO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxJQUFJO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQsOEZBQThGO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELG9CQUFvQixvQkFBb0Isd0JBQXdCLEtBQUssbUJBQW1CO0FBQ2hKO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrQkFBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSw2Q0FBNkMsYUFBYSxxQkFBcUIsVUFBVTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGVBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFLLEtBQUssU0FBUyxNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQSxHQUFHO0FBQ0gsa0JBQWtCLDBCQUEwQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsSUFBSTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0NBQWtDLEVBQUUsc0RBQXNEO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxpQkFBaUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxJQUFJO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUpBQXFKLEdBQUc7QUFDeEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGNBQWMsTUFBTSxJQUFJLGFBQWEsR0FBRyxZQUFZLEdBQUcsMkJBQTJCLEVBQUUsK0JBQStCLEdBQUcsK0JBQStCO0FBQ3JKO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUJBQWlCLEVBQUUsTUFBTSxJQUFJLGVBQWU7QUFDMUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0NBQWtDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsMENBQTBDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFNBQVMsaUZBQWlGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osaUNBQWlDLElBQUk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLDBCQUEwQix3QkFBd0IsVUFBVTtBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxxQkFBcUI7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsb0JBQW9CLHlDQUF5QyxvQ0FBb0M7QUFDMUs7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSx5QkFBeUIsZUFBZSxVQUFVO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSw0QkFBNEIsZUFBZSxhQUFhO0FBQzdIO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRix3QkFBd0I7QUFDNUc7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLHFCQUFxQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsd0JBQXdCLG9CQUFvQixjQUFjO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVEsb0JBQW9CLE9BQU87QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCw4QkFBOEI7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVEsRUFBRSxtQ0FBbUMsV0FBVyxxQkFBcUI7QUFDekcsMkJBQTJCO0FBQzNCLDZCQUE2QixrQ0FBa0M7QUFDL0Qsa0RBQWtELDRCQUE0QjtBQUM5RSxzREFBc0QscUNBQXFDO0FBQzNGLHVCQUF1QixVQUFVO0FBQ2pDLDZCQUE2Qix5REFBeUQ7QUFDdEYseUJBQXlCLDBCQUEwQjtBQUNuRCwyQkFBMkIsZUFBZSxJQUFJLDBCQUEwQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCwyQkFBMkIsMEJBQTBCO0FBQ3JELDZCQUE2QixrQ0FBa0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsdUJBQXVCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLFlBQVksYUFBYSxRQUFRO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFCQUFxQixHQUFHLHFDQUFxQztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxvQ0FBb0MsOENBQThDLHVDQUF1QztBQUNoSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtRUFBbUUsMEJBQTBCLFVBQVU7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MscUJBQXFCO0FBQ3pELE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxtQkFBbUIsY0FBYyxPQUFPLEVBQUUsd0JBQXdCO0FBQ3BJLGNBQWM7QUFDZCx1RkFBdUYsT0FBTyxFQUFFLHdCQUF3QjtBQUN4SDtBQUNBLHVEQUF1RCxNQUFNO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsbUVBQW1FLE9BQU8sZ0NBQWdDLHdCQUF3QjtBQUNsSTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMseUJBQXlCLEtBQUssY0FBYyxtQ0FBbUMsZ0NBQWdDLElBQUksc0NBQXNDLHVCQUF1QixnQkFBZ0IsSUFBSSxrQkFBa0I7QUFDalE7QUFDQSx3Q0FBd0MsbUJBQW1CLElBQUksR0FBRyxhQUFhLHVCQUF1QixZQUFZLGtDQUFrQyxPQUFPLDRCQUE0QixjQUFjLHdCQUF3QixtQkFBbUIsNkJBQTZCLGdCQUFnQiwwQkFBMEIsaUJBQWlCLGdCQUFnQixXQUFXLG9CQUFvQixhQUFhLHNCQUFzQixnQkFBZ0IsVUFBVTtBQUNwYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxNQUFNLEdBQUcsYUFBYSxHQUFHLGdCQUFnQixHQUFHLHFDQUFxQyxHQUFHLFVBQVU7QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQ0FBZ0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixrQ0FBa0MsSUFBSTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixnREFBZ0Qsc0JBQXNCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxpQkFBaUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFlBQVksUUFBUSxhQUFhO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLElBQUk7QUFDeEMsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsSUFBSTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDhCQUE4QixJQUFJO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLElBQUk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjLEdBQUcsZUFBZSxHQUFHLFlBQVk7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsYUFBYTtBQUNyRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGFBQWE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFFBQVE7QUFDL0Q7QUFDQTs7QUFFQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMEVBQTBFLFNBQVMsSUFBSSxZQUFZO0FBQ25HO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixJQUFJO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCwwQkFBMEI7QUFDL0U7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLDJDQUEyQyxlQUFlLEVBQUUsY0FBYztBQUMxRTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMscUJBQXFCO0FBQ25FO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiwyQ0FBMkMsZUFBZSxFQUFFLGNBQWM7QUFDMUU7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHFCQUFxQjtBQUNuRTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdDQUFnQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLG9CQUFvQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtJQUErSSxhQUFhO0FBQzVKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiw0QkFBNEIsS0FBSyxnREFBZ0QsVUFBVTtBQUMzRjtBQUNBLE1BQU07QUFDTiwwR0FBMEcsY0FBYztBQUN4SDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1JQUFtSSxLQUFLO0FBQ3hJLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGtKQUFrSixPQUFPO0FBQ3pKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRCQUE0QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsTUFBTSxjQUFjLE1BQU07QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsSUFBSSxzQ0FBc0MsaUJBQWlCO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSw2RUFBNkUsUUFBUSxLQUFLLFVBQVU7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx5RUFBeUUsMkJBQTJCO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsSUFBSTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxPQUFPO0FBQzVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtCQUFrQjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxVQUFVO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFNBQVMsTUFBTTtBQUM5QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsK0JBQStCLFNBQVMsTUFBTTtBQUM5QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxZQUFZOztBQUV0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4REFBOEQ7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLCtFQUErRSxXQUFXO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxLQUFLO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixnRUFBZ0UsT0FBTztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLHVFQUF1RSxPQUFPO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxZQUFZLEdBQUcsTUFBTTtBQUMxRCxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxPQUFPO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLElBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLElBQUk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0EsZ0NBQWdDLFlBQVk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixJQUFJO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELEtBQUssa0NBQWtDLFVBQVU7QUFDcEc7QUFDQTtBQUNBLG1EQUFtRCxLQUFLLDhDQUE4QyxVQUFVO0FBQ2hIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMseUJBQXlCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxJQUFJO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDZCQUE2QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDhFQUE4RSxvQ0FBb0M7QUFDbEg7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFVBQVU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLFdBQVc7QUFDakc7QUFDQSxRQUFRO0FBQ1IsK0ZBQStGLFdBQVcsSUFBSSxXQUFXO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTLEVBQUU7QUFDakMscUJBQXFCO0FBQ3JCLEVBQUU7O0FBRUYscUJBQXFCO0FBQ3JCLEVBQUUsZ0JBQWdCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsc0JBQXNCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxJQUFJO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsU0FBUztBQUM3RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0IsaUJBQWlCLHNCQUFzQixHQUFHLG9CQUFvQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxtRUFBbUUsV0FBVyxNQUFNLElBQUksa0NBQWtDO0FBQzdKO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsZUFBZTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsd0JBQXdCLGVBQWUscUJBQXFCO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsdURBQXVELEtBQUssYUFBYTtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFdBQVcsTUFBTSxRQUFRLEVBQUUsOENBQThDLEtBQUssc0NBQXNDO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixXQUFXLE1BQU0sU0FBUyxLQUFLLHNCQUFzQixFQUFFLFdBQVc7QUFDN0Y7QUFDQTs7QUFFQSx5Q0FBeUM7QUFDekM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHFEQUFxRDtBQUNwRjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFdBQVcsTUFBTSxRQUFRLEVBQUUsb0NBQW9DLEtBQUssa0NBQWtDLFdBQVcsNEVBQTRFO0FBQ3ROO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxxQkFBcUI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELHlCQUF5QjtBQUNsRjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUyxNQUFNLGdCQUFnQixHQUFHLGNBQWMsS0FBSyxzQkFBc0IsRUFBRSxXQUFXO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxnQ0FBZ0MsYUFBYSxnREFBZ0QsSUFBSSxRQUFRO0FBQzdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsV0FBVyxNQUFNLFNBQVMsUUFBUSxZQUFZLEdBQUcsVUFBVSxHQUFHLG9CQUFvQixPQUFPLGlDQUFpQyxRQUFRLFNBQVMsR0FBRyxnQkFBZ0IsR0FBRyxjQUFjLGFBQWEsd0NBQXdDO0FBQ2xRO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCw0QkFBNEI7QUFDeEY7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFdBQVcsTUFBTSxTQUFTLEtBQUssMkJBQTJCLFFBQVEsU0FBUyxFQUFFLGlFQUFpRSxZQUFZLHdDQUF3QztBQUMxTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxnQ0FBZ0MsZ0NBQWdDLG9CQUFvQjtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxvRUFBb0UsSUFBSSxLQUFLLHNCQUFzQixFQUFFLFdBQVc7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxjQUFjO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLFFBQVEsVUFBVSx3QkFBd0I7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZUFBZSwrQ0FBK0MsV0FBVyxvQkFBb0Isa0JBQWtCLGNBQWMsOENBQThDO0FBQ3hOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxhQUFhLDZCQUE2QixHQUFHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxJQUFJO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRiw2QkFBNkI7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsUUFBUTtBQUMzRjtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLFFBQVE7QUFDM0Y7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdDQUFnQyxZQUFZLGlEQUFpRCxJQUFJLGlCQUFpQixhQUFhLE9BQU87QUFDL0s7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGVBQWUsd0JBQXdCLGlCQUFpQixXQUFXLHlEQUF5RDtBQUN6SztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsY0FBYztBQUNwRjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixRQUFRLEVBQUUsbUNBQW1DLEtBQUssc0JBQXNCLEVBQUUsWUFBWTtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxVQUFVLElBQUksZ0ZBQWdGO0FBQ2xLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUyxLQUFLLFlBQVksRUFBRSxZQUFZLGVBQWUsYUFBYSxxQkFBcUIsZUFBZSxHQUFHLHlCQUF5QixLQUFLLE1BQU07QUFDM0s7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixxQkFBcUIsY0FBYyxpQ0FBaUMsV0FBVztBQUMvRTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLGNBQWM7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGNBQWMsS0FBSyxzQkFBc0IsRUFBRSxnQkFBZ0I7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFNBQVMsRUFBRSxNQUFNLHFCQUFxQixlQUFlO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFNBQVMsS0FBSyxzQkFBc0IsRUFBRSxZQUFZO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVMsS0FBSyxzQkFBc0IsR0FBRyxVQUFVO0FBQzVGLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVcsTUFBTSxRQUFRLEVBQUUsb0NBQW9DLEtBQUssaUNBQWlDO0FBQzVIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNCQUFzQixFQUFFLFlBQVksR0FBRyx1QkFBdUIsSUFBSSwrRkFBK0YsR0FBRyw2RkFBNkYsR0FBRyx1RkFBdUY7QUFDelc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYyxJQUFJLFVBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjs7QUFFckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsR0FBRztBQUNoQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0IsYUFBYSxpQkFBaUI7QUFDOUIsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsR0FBRztBQUNoQixhQUFhLFNBQVM7QUFDdEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQixhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNERBQTRELE9BQU87QUFDbkU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBLGtCQUFrQixZQUFZO0FBQzlCOztBQUVBO0FBQ0EsOERBQThEO0FBQzlELGtFQUFrRTtBQUNsRSxzRUFBc0U7QUFDdEUsMEVBQTBFO0FBQzFFO0FBQ0EsNkRBQTZELFNBQVM7QUFDdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCLGFBQWEsVUFBVTtBQUN2QixhQUFhLEdBQUc7QUFDaEIsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUIsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsR0FBRztBQUNoQixlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QixhQUFhLFVBQVU7QUFDdkIsYUFBYSxHQUFHO0FBQ2hCLGFBQWEsU0FBUztBQUN0QixlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDhEQUE4RCxZQUFZO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUIsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFlBQVksaUJBQWlCLG1CQUFtQixLQUFLLGdCQUFnQixHQUFHLGlDQUFpQyxRQUFRO0FBQy9KO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsa0JBQWtCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixjQUFjLGlCQUFpQixNQUFNLGFBQWEsYUFBYSxTQUFTLFlBQVksb0JBQW9CLGdCQUFnQixpQkFBaUIsa0JBQWtCO0FBQzFMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsb0JBQW9CLEdBQUcsWUFBWSxHQUFHLGdCQUFnQjtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsK0JBQStCLFdBQVcsUUFBUSxPQUFPLHVCQUF1QixZQUFZLEdBQUcsb0JBQW9CLEdBQUcsaUJBQWlCLFdBQVcsUUFBUTtBQUMxSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixhQUFhLFlBQVksR0FBRztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsYUFBYSxZQUFZLEdBQUc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUc7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsS0FBSztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxpQkFBaUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsbUNBQW1DO0FBQ25DLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGlCQUFpQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0c7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvQ0FBb0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIscUNBQXFDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRCwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsK0JBQStCLHVDQUF1QztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsTUFBTTtBQUNOLGdDQUFnQztBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixNQUFNO0FBQ04sbUJBQW1CO0FBQ25CLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEI7QUFDQSxrQkFBa0Isb0NBQW9DO0FBQ3REO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsZUFBZTtBQUNmLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRiw0QkFBNEI7QUFDL0csb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEI7QUFDQSxrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixZQUFZO0FBQ3pDLGlDQUFpQyxtQ0FBbUM7QUFDcEU7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsYUFBYTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlDQUFpQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQ0FBZ0M7QUFDdEQsd0JBQXdCLDJDQUEyQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw0QkFBNEI7QUFDdEQsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGFBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsYUFBYTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QixzSEFBc0g7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIscUJBQXFCLEVBQUUsb0JBQW9CLEdBQUcsbUNBQW1DLEdBQUcsaUJBQWlCLEVBQUUsa0JBQWtCO0FBQ3BKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsMkJBQTJCO0FBQzNCLE1BQU07QUFDTiwyQkFBMkI7QUFDM0IsTUFBTTtBQUNOLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxXQUFXO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyxhQUFhO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxPQUFPLHFCQUFxQixXQUFXLGdDQUFnQyxZQUFZO0FBQzVJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsZ0JBQWdCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGNBQWM7QUFDN0Q7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsa0JBQWtCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxPQUFPO0FBQ3pFLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNDQUFzQztBQUMvRDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCLDZEQUE2RDtBQUM3RCx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsU0FBUztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixzQkFBc0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsWUFBWSxpQkFBaUIsYUFBYSxHQUFHLFlBQVk7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0Esc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0Esc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxvQkFBb0IsU0FBUyxRQUFRO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osa0RBQWtELFFBQVE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5Q0FBeUMsSUFBSSxrQ0FBa0MsTUFBTSxNQUFNLDBDQUEwQyxzQkFBc0I7QUFDbEwsVUFBVTtBQUNWLHVCQUF1Qix5Q0FBeUMsSUFBSSxtQ0FBbUMsTUFBTSxNQUFNLGlEQUFpRCxzQkFBc0I7QUFDMUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSw0QkFBNEIseUJBQXlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELG9DQUFvQyxHQUFHLG9DQUFvQyxXQUFXLGtDQUFrQztBQUMvSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFNBQVM7QUFDdkQsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsYUFBYTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSw0Q0FBNEMsc0JBQXNCLHdCQUF3QixpQkFBaUIsd0JBQXdCO0FBQ25JLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsU0FBUztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDs7QUFFQTtBQUNBO0FBQ0Esd0RBQXdELHlCQUF5QjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxrQ0FBa0MsdUJBQXVCLDJDQUEyQztBQUMzSTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsU0FBUyxpQkFBaUIsbURBQW1ELFdBQVcsMkNBQTJDO0FBQ3BLLDBCQUEwQixhQUFhO0FBQ3ZDO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxnQkFBZ0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkc7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsU0FBUztBQUM3RCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1IQUFtSDtBQUNuSDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFlBQVksT0FBTyxzQ0FBc0MsS0FBSyxvQkFBb0I7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGNBQWMsR0FBRyxrQkFBa0IsV0FBVyxlQUFlLFNBQVMsK0JBQStCO0FBQ2pLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxZQUFZO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFlBQVk7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxjQUFjO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sZ0RBQWdELFNBQVMsTUFBTSxhQUFhLEVBQUUsdURBQXVELEtBQUssd0RBQXdELEVBQUUsZ0JBQWdCO0FBQ3BOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQixHQUFHLGVBQWUsR0FBRyxhQUFhO0FBQ25GO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLG1CQUFtQixPQUFPLEdBQUc7QUFDMUU7QUFDQSxZQUFZO0FBQ1osb0RBQW9ELEdBQUc7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1YsMkNBQTJDLEdBQUc7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RixXQUFXLE1BQU0sYUFBYSxFQUFFLHVEQUF1RCxFQUFFLHVEQUF1RCxJQUFJLGlCQUFpQixNQUFNO0FBQ2xRLHlCQUF5QjtBQUN6Qix1QkFBdUI7QUFDdkIsc0JBQXNCO0FBQ3RCLDhCQUE4QjtBQUM5QixzQkFBc0I7QUFDdEIsNkJBQTZCLGtCQUFrQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLElBQUksbUJBQW1CLFFBQVEsR0FBRyxVQUFVO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxnQkFBZ0IsS0FBSyxZQUFZO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCwyQkFBMkI7QUFDMUY7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsMERBQTBELFNBQVMsR0FBRyxXQUFXLFFBQVEsUUFBUTtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVMsR0FBRyxXQUFXLFFBQVEsUUFBUSxZQUFZLG1CQUFtQixHQUFHLGlCQUFpQixHQUFHLGlDQUFpQyxzQkFBc0IsR0FBRyx5QkFBeUIsUUFBUSxZQUFZLHlCQUF5QjtBQUN6UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHlGQUF5RixTQUFTLFdBQVcsWUFBWTtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxJQUFJLE1BQU0saUJBQWlCLEdBQUcsY0FBYyxVQUFVLFFBQVE7QUFDL0Y7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMkNBQTJDLFFBQVEscURBQXFELFNBQVMsTUFBTSxpQkFBaUIsR0FBRyxjQUFjLFVBQVUsUUFBUTtBQUMzSztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUUsNEJBQTRCLFFBQVEsRUFBRSxpQ0FBaUMsV0FBVyxZQUFZLDhDQUE4QyxXQUFXLGlCQUFpQix5REFBeUQ7QUFDak87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGdCQUFnQiwwQkFBMEIsbUJBQW1CLEdBQUcsWUFBWTtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsZ0VBQWdFLFNBQVMsK0NBQStDLFNBQVMsV0FBVyxhQUFhO0FBQ3pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDZCQUE2QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVix5RUFBeUUsTUFBTTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsK0VBQStFLE1BQU07QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU8sRUFBRSw0SEFBNEg7QUFDcks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHdCQUF3QjtBQUN2RTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSwwREFBMEQsNEJBQTRCLE1BQU0sYUFBYSxxQkFBcUIsWUFBWTtBQUMxSTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsa0JBQWtCLGtCQUFrQix3QkFBd0IsVUFBVSxhQUFhLFVBQVUsVUFBVSxVQUFVLEtBQUs7QUFDL0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxtREFBbUQsS0FBSyxzQ0FBc0M7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGVBQWUsR0FBRyx5QkFBeUIsU0FBUyxhQUFhO0FBQ2hIO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGVBQWUsR0FBRyx5QkFBeUIsU0FBUyxhQUFhLE9BQU8sTUFBTTtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHVDQUF1QyxJQUFJLFlBQVksU0FBUyw0QkFBNEIsaUVBQWlFO0FBQzdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLElBQUksR0FBRyx3QkFBd0IsU0FBUyx5QkFBeUIsUUFBUSxTQUFTLFVBQVUsZ0JBQWdCLEdBQUcsY0FBYztBQUN6SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsb0JBQW9CLDhCQUE4QixxREFBcUQ7QUFDaEo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSwwRkFBMEYsOEVBQThFLGVBQWUsbUJBQW1CO0FBQzFNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQyxNQUFNO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxPQUFPLEdBQUcsV0FBVyxTQUFTLFlBQVksUUFBUSxlQUFlLFdBQVcsZUFBZTtBQUNwSTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxJQUFJLEdBQUcsZ0JBQWdCLFNBQVMsaUJBQWlCLFFBQVEsUUFBUSxFQUFFLG9KQUFvSixFQUFFLHVGQUF1RixDQUFFLGFBQWEsRUFBRSxJQUFJO0FBQ3pXO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLEVBQUU7QUFDRixFQUFFLHlCQUF5QjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSwySUFBMkksS0FBSyxLQUFLLHNCQUFzQixJQUFJLG1CQUFtQjtBQUNsTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLCtCQUErQixFQUFFLDRCQUE0QixFQUFFLDhCQUE4QjtBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsNkVBQTZFLFlBQVksSUFBSSxTQUFTO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxxQ0FBcUMsRUFBRSw2Q0FBNkMsRUFBRSxvQkFBb0I7QUFDM0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1JQUFtSSxnQkFBZ0IsMkVBQTJFO0FBQzlPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELDRCQUE0QjtBQUN6RixtQkFBbUI7QUFDbkIsbUJBQW1CLHlGQUF5RjtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLGFBQWEsS0FBSyxVQUFVO0FBQ3pIO0FBQ0E7QUFDQSx3RkFBd0YsK0JBQStCLE1BQU0sNEJBQTRCLGlCQUFpQixXQUFXLGVBQWUsWUFBWTtBQUNoTix3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLCtCQUErQixpREFBaUQ7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsSUFBSTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osMkNBQTJDLGFBQWE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixtQ0FBbUMsS0FBSztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVyxzQkFBc0IsdUJBQXVCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxvQkFBb0IsU0FBUyxXQUFXO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFNBQVMsS0FBSyxXQUFXO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBLHdCQUF3QixXQUFXLFNBQVMsTUFBTTtBQUNsRDtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsTUFBTSx1QkFBdUIsU0FBUztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsdUJBQXVCO0FBQ3ZCLDBCQUEwQjtBQUMxQjtBQUNBLHNDQUFzQyxNQUFNO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCx1QkFBdUI7QUFDdkIsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEtBQUs7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxnREFBZ0QsTUFBTTtBQUN0RCxPQUFPO0FBQ1A7QUFDQSxnREFBZ0QsTUFBTTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlCQUFpQixHQUFHLHFDQUFxQyw4QkFBOEIsS0FBSyxrQkFBa0IsMkNBQTJDO0FBQ3ZMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLEtBQUssV0FBVyxNQUFNLEdBQUcsSUFBSTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGlFQUFpRSxrQkFBa0IsS0FBSyxnQkFBZ0IsTUFBTSxNQUFNO0FBQ3BILE9BQU87QUFDUDtBQUNBLGtFQUFrRSxrQkFBa0IsS0FBSyxnQkFBZ0IsTUFBTSxNQUFNO0FBQ3JIO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0Esc0NBQXNDLE1BQU0sR0FBRyxLQUFLLFFBQVEsS0FBSztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxvRkFBb0YsV0FBVyxTQUFTLFlBQVksTUFBTSxRQUFRO0FBQ2xJO0FBQ0E7QUFDQSw4Q0FBOEMsTUFBTTtBQUNwRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsTUFBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLDRGQUE0Rix1QkFBdUI7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1oscUNBQXFDLE1BQU07QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxvQkFBb0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQscUJBQXFCLDhCQUE4QixNQUFNLEdBQUcsSUFBSTtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNkNBQTZDLG1CQUFtQix5QkFBeUIsdUJBQXVCLElBQUksa0JBQWtCO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCx3REFBd0Qsb0JBQW9CO0FBQzVFO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUJBQWlCLFNBQVMsTUFBTTtBQUM1RDtBQUNBLDBDQUEwQyxTQUFTLEdBQUcsdUNBQXVDLEVBQUUsaUJBQWlCO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLGdFQUFnRSxjQUFjO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNLDhDQUE4Qyx5RkFBeUY7QUFDNUssa0JBQWtCLE1BQU07QUFDeEI7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixNQUFNLGtDQUFrQyxpQkFBaUIsT0FBTyxJQUFJLE1BQU0sR0FBRztBQUN4RztBQUNBO0FBQ0E7O0FBRUEsb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxNQUFNO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixZQUFZLEdBQUcsVUFBVSxhQUFhLE1BQU07QUFDeEU7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLE1BQU07QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxNQUFNO0FBQ3pEO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSLG1EQUFtRCxxQkFBcUIsRUFBRSxNQUFNO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU4scURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGFBQWEsU0FBUztBQUMvRjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxTQUFTLElBQUksd0JBQXdCLElBQUksMEJBQTBCLFlBQVksZ0JBQWdCLEdBQUcsaUJBQWlCO0FBQzNLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRLEdBQUcsWUFBWSxPQUFPLEtBQUs7QUFDbkU7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx5Q0FBeUM7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFlBQVk7QUFDbEU7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0RBQWtEO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFLGtCQUFrQixHQUFHO0FBQ3RDO0FBQ0EsYUFBYSxFQUFFLGtCQUFrQixHQUFHLHlCQUF5QjtBQUM3RCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtCQUErQixFQUFFLDhCQUE4QjtBQUM3RSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHlDQUF5QyxHQUFHLDhCQUE4QjtBQUN2Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxXQUFXLG1CQUFtQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlKQUF5SjtBQUN6SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVyxHQUFHLDJCQUEyQjtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksSUFBSSxFQUFFLFVBQVUsRUFBRSxNQUFNO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sSUFBSTtBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUix1Q0FBdUMsY0FBYyxJQUFJLG1CQUFtQix3Q0FBd0MsY0FBYyxVQUFVLGlDQUFpQyxjQUFjLDRCQUE0QixhQUFhLGtDQUFrQztBQUN0UTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZUFBZSxnQ0FBZ0MsVUFBVTtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUIsR0FBRyxlQUFlLHFCQUFxQixlQUFlO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQkFBb0IsNEJBQTRCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsVUFBVTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCx1QkFBdUIsS0FBSyx5QkFBeUI7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGlCQUFpQixTQUFTLFFBQVE7QUFDNUYsaUVBQWlFLHFCQUFxQixTQUFTLFFBQVE7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsMEJBQTBCLGtDQUFrQztBQUM1RCwrQ0FBK0MseUJBQXlCLFNBQVMsUUFBUTtBQUN6RjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUNBQXFDO0FBQy9ELDhDQUE4Qyw0QkFBNEIsU0FBUyxRQUFRO0FBQzNGO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHlEQUF5RCxJQUFJO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLElBQUk7QUFDbkQ7QUFDQTtBQUNBLHVDQUF1QyxzQkFBc0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxzRUFBc0UsVUFBVTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxxREFBcUQsWUFBWSxFQUFFLFlBQVksR0FBRyxZQUFZO0FBQzlGO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxhQUFhO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsYUFBYTtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSx1REFBdUQsWUFBWTtBQUNuRTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsSUFBSTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsV0FBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxVQUFVO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sOERBQThELFVBQVU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxtRkFBbUYsZ0NBQWdDO0FBQ25IO0FBQ0Esc0dBQXNHLGtCQUFrQjtBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFVBQVUsbUNBQW1DLGlDQUFpQztBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFVBQVUsS0FBSyxNQUFNO0FBQ2hGLE9BQU87QUFDUDtBQUNBLDJDQUEyQywrQkFBK0I7QUFDMUU7QUFDQSwyQ0FBMkMsVUFBVTtBQUNyRDtBQUNBLDhDQUE4QyxVQUFVO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSx5REFBeUQsVUFBVSxFQUFFLElBQUksTUFBTTtBQUMvRSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsNkNBQTZDLFVBQVUsV0FBVyxxQ0FBcUM7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHFCQUFxQixjQUFjO0FBQ3pFLFFBQVEsZ0JBQWdCLDhCQUE4QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixvRUFBb0UsVUFBVTtBQUM5RTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBLDBEQUEwRCxTQUFTLEVBQUUsVUFBVSxJQUFJLFdBQVcsZ0JBQWdCLHNCQUFzQjtBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTyxXQUFXLHNCQUFzQixZQUFZLG9CQUFvQixPQUFPLGdCQUFnQjtBQUNqSSx5Q0FBeUMsV0FBVztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsK0NBQStDLGNBQWMsRUFBRSxlQUFlLElBQUksaUJBQWlCLFlBQVksV0FBVztBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sc0RBQXNEO0FBQzdEO0FBQ0EsT0FBTyxFQUFFO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxVQUFVO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFVBQVU7QUFDaEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELE9BQU87QUFDM0Q7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELE9BQU8sS0FBSyxPQUFPLG1CQUFtQixjQUFjLFVBQVUsc0NBQXNDO0FBQ3hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLG1CQUFtQixZQUFZLCtCQUErQixxQkFBcUIsa0JBQWtCLG1CQUFtQjtBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUix1REFBdUQsWUFBWTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQW1CLGtCQUFrQixNQUFNO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNEJBQTRCLFVBQVU7QUFDakQsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWLG9EQUFvRCxVQUFVO0FBQzlEO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EscURBQXFELHNHQUFzRyxXQUFXLE1BQU07QUFDNUssS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLDJDQUEyQyxNQUFNO0FBQ3hELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPLDJCQUEyQiwySEFBMkgsaUJBQWlCLDZFQUE2RSxPQUFPLHVDQUF1QztBQUM5VTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsVUFBVTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVyxNQUFNLFVBQVUsZ0NBQWdDLElBQUksYUFBYSxlQUFlLEdBQUcsY0FBYztBQUM1RyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU0sVUFBVSxtQ0FBbUMsSUFBSTtBQUNsRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyw4Q0FBOEMsR0FBRyx3Q0FBd0MsUUFBUSxVQUFVO0FBQ3BKO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELElBQUk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMscURBQXFEO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUNBQWlDLElBQUksYUFBYSxZQUFZLEdBQUcsZUFBZTtBQUMvRixjQUFjO0FBQ2Q7QUFDQSxxREFBcUQsY0FBYztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxNQUFNO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELE1BQU07QUFDOUQsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLGlFQUFpRSxNQUFNO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLE1BQU07QUFDakYsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCx5REFBeUQsc0JBQXNCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsNkRBQTZELDJCQUEyQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSw4Q0FBOEMsTUFBTTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxNQUFNO0FBQzlELFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSw2Q0FBNkMsTUFBTTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxNQUFNO0FBQzdELFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsSUFBSTtBQUNyRDtBQUNBLE1BQU07QUFDTix5Q0FBeUMsSUFBSTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixnRkFBZ0YsS0FBSztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsU0FBUztBQUM5RDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsMENBQTBDLElBQUksWUFBWSxTQUFTLDRCQUE0QixpRUFBaUU7QUFDaEs7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsSUFBSSxHQUFHLHdCQUF3QixTQUFTLHlCQUF5QixRQUFRLFNBQVMsVUFBVSxnQkFBZ0IsR0FBRyxjQUFjO0FBQzVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHVCQUF1QixxQkFBcUIsMkRBQTJEO0FBQ25KO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLElBQUksR0FBRyxrQkFBa0IsU0FBUyxtQkFBbUIsUUFBUSxRQUFRLEVBQUUsb0pBQW9KLEVBQUUsdUZBQXVGLENBQUUsYUFBYSxFQUFFLElBQUk7QUFDMVc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGtCQUFrQixrQkFBa0Isa0JBQWtCO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDLE1BQU07QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxNQUFNLGtCQUFrQixXQUFXLFNBQVMsWUFBWSxRQUFRLGNBQWM7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHO0FBQ0o7QUFDQSxZQUFZLHdCQUF3QixHQUFHLG1CQUFtQixHQUFHLFVBQVU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxjQUFjLHdCQUF3QixJQUFJLHVFQUF1RSxFQUFFLHNDQUFzQyxHQUFHLG1DQUFtQztBQUMvTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUJBQWlCLElBQUksaUJBQWlCLEdBQUcsOEJBQThCO0FBQ3JGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixvQ0FBb0MsRUFBRSxpRUFBaUUsRUFBRSw0Q0FBNEM7QUFDbkw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixlQUFlO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsSUFBSTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLGFBQWE7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCLGVBQWUsWUFBWSwwQ0FBMEMsaUJBQWlCO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3QkFBd0IsZUFBZSxZQUFZO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0JBQXdCLGVBQWUsWUFBWSxPQUFPLGNBQWMsZUFBZSxZQUFZO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0JBQXdCLGVBQWUsWUFBWSx1Q0FBdUMsY0FBYyxZQUFZLGtCQUFrQixHQUFHLG9CQUFvQjtBQUNsTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdCQUF3QixlQUFlLFlBQVksbUJBQW1CLGNBQWMsbUJBQW1CLG9CQUFvQixHQUFHLG1CQUFtQixNQUFNLGtCQUFrQixNQUFNLGlCQUFpQjtBQUNyTjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpRUFBaUUsSUFBSSx5QkFBeUIsR0FBRyx1QkFBdUI7QUFDckk7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsMkpBQTJKLFlBQVksRUFBRSxZQUFZLEdBQUcsWUFBWTtBQUNwTTtBQUNBLE9BQU87QUFDUDtBQUNBLG1KQUFtSixZQUFZO0FBQy9KO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsMEJBQTBCLEtBQUs7QUFDMUUsWUFBWSxnREFBZ0QsT0FBTyxpQkFBaUI7QUFDcEY7QUFDQTtBQUNBLG1DQUFtQyxXQUFXO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSw2QkFBNkIsR0FBRyxJQUFJLGVBQWUsSUFBSSxzQkFBc0IsSUFBSSxjQUFjO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHFDQUFxQyw2QkFBNkI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsTUFBTSxHQUFHLGFBQWE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxJQUFJO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVEsRUFBRSxpQ0FBaUM7QUFDdkY7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsaUNBQWlDO0FBQ3JGLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsYUFBYTtBQUM3RjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4REFBOEQsS0FBSyxvQ0FBb0MsT0FBTyxjQUFjO0FBQzVJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxNQUFNLElBQUksZUFBZTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywwQkFBMEIsR0FBRywrQkFBK0IsRUFBRSxpQ0FBaUM7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGNBQWMsRUFBRSw2QkFBNkI7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdDQUFnQyxFQUFFLG9EQUFvRDtBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxhQUFhO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGFBQWE7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtQkFBbUIsR0FBRyxpQkFBaUIsbUJBQW1CLGFBQWE7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsK0JBQStCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QywrQkFBK0I7QUFDN0U7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELCtDQUErQztBQUM1RztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCx3QkFBd0I7QUFDbEY7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLDZEQUE2RCx3QkFBd0I7QUFDckY7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHdCQUF3QjtBQUNsRjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsNkRBQTZELHdCQUF3QjtBQUNyRjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwrQkFBK0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELHNCQUFzQiwwQkFBMEIsMEJBQTBCO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsbUJBQW1CLEdBQUcsMkJBQTJCLEVBQUUsYUFBYSxFQUFFLGlDQUFpQyxtQkFBbUIsZ0JBQWdCLGVBQWUsT0FBTztBQUN0TTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLG1DQUFtQyxxQkFBcUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsWUFBWTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsaUJBQWlCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxtREFBbUQsY0FBYyxZQUFZLFFBQVE7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsYUFBYTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRLG9CQUFvQixzQkFBc0IsSUFBSSxTQUFTO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGFBQWE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFNBQVMsRUFBRSxjQUFjLEtBQUssK0JBQStCO0FBQ3hIO0FBQ0EsWUFBWTtBQUNaLG9DQUFvQyxrQkFBa0IsS0FBSyxvQ0FBb0MsV0FBVyxTQUFTLEVBQUUsYUFBYTtBQUNsSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpSkFBaUosWUFBWSxFQUFFLGFBQWE7QUFDNUssS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsUUFBUTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxrREFBa0QsOEJBQThCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUSxlQUFlLG1EQUFtRDtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsbUJBQW1CLEdBQUcsaUJBQWlCLEVBQUUsOEJBQThCO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QywrQkFBK0Isd0JBQXdCLDJCQUEyQixzREFBc0QsMEJBQTBCO0FBQzNNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx1REFBdUQsRUFBRSxXQUFXO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsbUNBQW1DLG1DQUFtQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsd0JBQXdCLFdBQVcsWUFBWSxPQUFPLGtCQUFrQixXQUFXLHVEQUF1RCxTQUFTLG1CQUFtQjtBQUN4TjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsaURBQWlELGFBQWEsUUFBUSxpQkFBaUIsSUFBSSxhQUFhO0FBQ3hHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkYsa0JBQWtCLEVBQUUsYUFBYTtBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxrRUFBa0UsUUFBUTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsU0FBUyxVQUFVLG1CQUFtQixHQUFHLGlCQUFpQixHQUFHLGlDQUFpQyxzQkFBc0IsR0FBRyx5QkFBeUIsUUFBUSxZQUFZLHlCQUF5QjtBQUM1TjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLHFCQUFxQixTQUFTLElBQUksWUFBWTtBQUM5QztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELEtBQUsseUNBQXlDLE1BQU0sdUNBQXVDLE9BQU87QUFDdko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXLEdBQUcsU0FBUyxJQUFJLEVBQUU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVCQUF1QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1Q0FBdUM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsRUFBRSxNQUFNLEVBQUU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsSUFBSTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsV0FBVztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx5QkFBeUIsR0FBRyxNQUFNLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRTs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxJQUFJO0FBQzdDO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsS0FBSztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsSUFBSTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esc0JBQXNCLDZCQUE2QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRiw0QkFBNEI7QUFDL0c7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsbUJBQW1CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLCtDQUErQyxNQUFNO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsTUFBTTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtCQUErQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLEdBQUc7QUFDbkM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsMEJBQTBCLFFBQVEsZ0JBQWdCLFlBQVk7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsMkNBQTJDLG9FQUFvRTtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxtQkFBbUIsOENBQThDLGdCQUFnQix1Q0FBdUMsYUFBYSxZQUFZLEdBQUcseUJBQXlCLEtBQUssZ0JBQWdCO0FBQ2xNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsS0FBSztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsdUJBQXVCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUNBQXFDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxLQUFLLFNBQVMsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EscUNBQXFDLG9CQUFvQixvQ0FBb0MsV0FBVyxLQUFLLGtDQUFrQztBQUMvSTtBQUNBLEdBQUc7QUFDSCx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZLFVBQVUsNEJBQTRCO0FBQ2xHO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcsYUFBYSxRQUFRLFdBQVcsS0FBSyxTQUFTLGtCQUFrQixjQUFjO0FBQ3ZMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsdURBQXVELG1CQUFtQixxQkFBcUIsc0JBQXNCO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsYUFBYSxLQUFLLFdBQVc7QUFDNUY7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLGFBQWEsS0FBSyxXQUFXO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxhQUFhLEtBQUssV0FBVztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOLHVGQUF1RixhQUFhLFFBQVEsc0JBQXNCO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLElBQUk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0csd0JBQXdCLGtCQUFrQiw2RkFBNkYsd0JBQXdCLG9DQUFvQyxpQ0FBaUMsb0JBQW9CLEtBQUssYUFBYTtBQUNsWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELElBQUk7QUFDdkQ7QUFDQTtBQUNBLGtFQUFrRSxXQUFXLEdBQUcsYUFBYTtBQUM3RjtBQUNBO0FBQ0EsWUFBWTtBQUNaLGtFQUFrRSxXQUFXLEdBQUcsYUFBYTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsa0JBQWtCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUix1Q0FBdUMsZUFBZTtBQUN0RCwwQkFBMEIsc0JBQXNCLEVBQUUsb0JBQW9CLEdBQUcsV0FBVyxHQUFHLFVBQVUsR0FBRyxPQUFPLEdBQUcsWUFBWSxHQUFHLEtBQUs7QUFDbEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLHdCQUF3QjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSx3SEFBd0g7QUFDN0w7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsZUFBZSxpQ0FBaUMsa0JBQWtCO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsVUFBVSxHQUFHLHdDQUF3QyxFQUFFLCtDQUErQyxFQUFFLDJDQUEyQyxHQUFHLGNBQWMsR0FBRywrQ0FBK0MsYUFBYSxlQUFlLEVBQUUsc0RBQXNEO0FBQzdVO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHFDQUFxQyxpQkFBaUIsaURBQWlELGFBQWE7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGlCQUFpQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE1BQU07QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrQkFBa0IsRUFBRSxvSkFBb0osRUFBRSx5Q0FBeUMsRUFBRSx1RkFBdUYsQ0FBRSxhQUFhLEVBQUUsSUFBSTtBQUNyVztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx1QkFBdUI7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxhQUFhLG9CQUFvQixzQ0FBc0M7QUFDMUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsMkJBQTJCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTyxhQUFhLFdBQVc7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDZCQUE2QixTQUFTLFdBQVcsWUFBWTtBQUM3RDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFdBQVc7QUFDcEU7QUFDQTtBQUNBLHNCQUFzQixZQUFZLFVBQVUsbUJBQW1CLEdBQUcsaUJBQWlCLEdBQUcsaUNBQWlDLHNCQUFzQixHQUFHLHlCQUF5QixRQUFRLFFBQVEsbUJBQW1CLElBQUksaUJBQWlCLGFBQWEsU0FBUztBQUN2UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsd0JBQXdCLDREQUE0RCxJQUFJLDJCQUEyQiw0QkFBNEI7QUFDaEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxtRkFBbUYsU0FBUyxXQUFXLFlBQVk7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsWUFBWTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTLFdBQVcsWUFBWTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixTQUFTLE1BQU0saUJBQWlCLEdBQUcsY0FBYyxVQUFVLFdBQVcsT0FBTyxRQUFRO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxLQUFLO0FBQ2xEO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsUUFBUSxFQUFFLGlDQUFpQyxXQUFXLFlBQVksOENBQThDLFdBQVc7QUFDeko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGNBQWMsdUJBQXVCLFlBQVk7QUFDdkY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZUFBZSxvQkFBb0IsYUFBYSxlQUFlLFlBQVk7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMENBQTBDLDJEQUEyRCxTQUFTO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsV0FBVztBQUM3RDtBQUNBO0FBQ0EsbURBQW1ELFdBQVcsU0FBUyxXQUFXO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxnQkFBZ0IsbUNBQW1DLGlCQUFpQixHQUFHLGlCQUFpQixHQUFHLFlBQVk7QUFDdEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZ0JBQWdCLDBCQUEwQiw4QkFBOEIsR0FBRyxpQkFBaUIsR0FBRywyRUFBMkUsRUFBRSxnRUFBZ0U7QUFDM1I7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHFCQUFxQiwwQkFBMEIsb0JBQW9CLEdBQUcsaUJBQWlCO0FBQzNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnSEFBZ0gsZ0JBQWdCO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0hBQXNILElBQUk7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2SUFBNkksbUJBQW1CO0FBQ2hLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9HQUFvRyxlQUFlLGNBQWMsY0FBYztBQUMvSTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtRUFBbUUsYUFBYSxXQUFXLGNBQWMsUUFBUSxXQUFXOztBQUU1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGFBQWE7QUFDL0QsVUFBVTtBQUNWLGtEQUFrRCxhQUFhLGNBQWMsa0JBQWtCO0FBQy9GO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxhQUFhO0FBQ3ZGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9GQUFvRixZQUFZOztBQUVoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBLDZCQUE2QixrQ0FBa0MsMENBQTBDLGNBQWM7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLCtCQUErQixxRkFBcUYseUJBQXlCLGFBQWE7QUFDMUo7QUFDQSxzQkFBc0IsZUFBZSxNQUFNLFdBQVc7QUFDdEQsTUFBTTtBQUNOLHlCQUF5QixZQUFZLGFBQWEsZ0JBQWdCO0FBQ2xFO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLEtBQUs7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtDQUFrQyxjQUFjO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywwRUFBMEU7QUFDM0c7QUFDQTtBQUNBLG9CQUFvQixvQ0FBb0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQ0FBb0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsU0FBUztBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQsUUFBUTtBQUNSO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxJQUFJO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW11QjtBQUNudUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9FdGhhbkxlZS9EZXNrdG9wL0FkdlgvQUktV2F0Y2gtQnVkZHkvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2hscy5qcy9kaXN0L2hscy5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS9tZG4tamF2YXNjcmlwdF9idWlsdGluc19udW1iZXJfaXNmaW5pdGVcbmNvbnN0IGlzRmluaXRlTnVtYmVyID0gTnVtYmVyLmlzRmluaXRlIHx8IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWx1ZSk7XG59O1xuXG4vLyBodHRwczovL2Nhbml1c2UuY29tL21kbi1qYXZhc2NyaXB0X2J1aWx0aW5zX251bWJlcl9pc3NhZmVpbnRlZ2VyXG5jb25zdCBpc1NhZmVJbnRlZ2VyID0gTnVtYmVyLmlzU2FmZUludGVnZXIgfHwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIE1hdGguYWJzKHZhbHVlKSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufTtcbmNvbnN0IE1BWF9TQUZFX0lOVEVHRVIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCA5MDA3MTk5MjU0NzQwOTkxO1xuXG5sZXQgRXJyb3JUeXBlcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoRXJyb3JUeXBlcykge1xuICAvLyBJZGVudGlmaWVyIGZvciBhIG5ldHdvcmsgZXJyb3IgKGxvYWRpbmcgZXJyb3IgLyB0aW1lb3V0IC4uLilcbiAgRXJyb3JUeXBlc1tcIk5FVFdPUktfRVJST1JcIl0gPSBcIm5ldHdvcmtFcnJvclwiO1xuICAvLyBJZGVudGlmaWVyIGZvciBhIG1lZGlhIEVycm9yICh2aWRlby9wYXJzaW5nL21lZGlhc291cmNlIGVycm9yKVxuICBFcnJvclR5cGVzW1wiTUVESUFfRVJST1JcIl0gPSBcIm1lZGlhRXJyb3JcIjtcbiAgLy8gRU1FIChlbmNyeXB0ZWQgbWVkaWEgZXh0ZW5zaW9ucykgZXJyb3JzXG4gIEVycm9yVHlwZXNbXCJLRVlfU1lTVEVNX0VSUk9SXCJdID0gXCJrZXlTeXN0ZW1FcnJvclwiO1xuICAvLyBJZGVudGlmaWVyIGZvciBhIG11eCBFcnJvciAoZGVtdXhpbmcvcmVtdXhpbmcpXG4gIEVycm9yVHlwZXNbXCJNVVhfRVJST1JcIl0gPSBcIm11eEVycm9yXCI7XG4gIC8vIElkZW50aWZpZXIgZm9yIGFsbCBvdGhlciBlcnJvcnNcbiAgRXJyb3JUeXBlc1tcIk9USEVSX0VSUk9SXCJdID0gXCJvdGhlckVycm9yXCI7XG4gIHJldHVybiBFcnJvclR5cGVzO1xufSh7fSk7XG5sZXQgRXJyb3JEZXRhaWxzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChFcnJvckRldGFpbHMpIHtcbiAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9OT19LRVlTXCJdID0gXCJrZXlTeXN0ZW1Ob0tleXNcIjtcbiAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9OT19BQ0NFU1NcIl0gPSBcImtleVN5c3RlbU5vQWNjZXNzXCI7XG4gIEVycm9yRGV0YWlsc1tcIktFWV9TWVNURU1fTk9fU0VTU0lPTlwiXSA9IFwia2V5U3lzdGVtTm9TZXNzaW9uXCI7XG4gIEVycm9yRGV0YWlsc1tcIktFWV9TWVNURU1fTk9fQ09ORklHVVJFRF9MSUNFTlNFXCJdID0gXCJrZXlTeXN0ZW1Ob0NvbmZpZ3VyZWRMaWNlbnNlXCI7XG4gIEVycm9yRGV0YWlsc1tcIktFWV9TWVNURU1fTElDRU5TRV9SRVFVRVNUX0ZBSUxFRFwiXSA9IFwia2V5U3lzdGVtTGljZW5zZVJlcXVlc3RGYWlsZWRcIjtcbiAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9TRVJWRVJfQ0VSVElGSUNBVEVfUkVRVUVTVF9GQUlMRURcIl0gPSBcImtleVN5c3RlbVNlcnZlckNlcnRpZmljYXRlUmVxdWVzdEZhaWxlZFwiO1xuICBFcnJvckRldGFpbHNbXCJLRVlfU1lTVEVNX1NFUlZFUl9DRVJUSUZJQ0FURV9VUERBVEVfRkFJTEVEXCJdID0gXCJrZXlTeXN0ZW1TZXJ2ZXJDZXJ0aWZpY2F0ZVVwZGF0ZUZhaWxlZFwiO1xuICBFcnJvckRldGFpbHNbXCJLRVlfU1lTVEVNX1NFU1NJT05fVVBEQVRFX0ZBSUxFRFwiXSA9IFwia2V5U3lzdGVtU2Vzc2lvblVwZGF0ZUZhaWxlZFwiO1xuICBFcnJvckRldGFpbHNbXCJLRVlfU1lTVEVNX1NUQVRVU19PVVRQVVRfUkVTVFJJQ1RFRFwiXSA9IFwia2V5U3lzdGVtU3RhdHVzT3V0cHV0UmVzdHJpY3RlZFwiO1xuICBFcnJvckRldGFpbHNbXCJLRVlfU1lTVEVNX1NUQVRVU19JTlRFUk5BTF9FUlJPUlwiXSA9IFwia2V5U3lzdGVtU3RhdHVzSW50ZXJuYWxFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJLRVlfU1lTVEVNX0RFU1RST1lfTUVESUFfS0VZU19FUlJPUlwiXSA9IFwia2V5U3lzdGVtRGVzdHJveU1lZGlhS2V5c0Vycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIktFWV9TWVNURU1fREVTVFJPWV9DTE9TRV9TRVNTSU9OX0VSUk9SXCJdID0gXCJrZXlTeXN0ZW1EZXN0cm95Q2xvc2VTZXNzaW9uRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9ERVNUUk9ZX1JFTU9WRV9TRVNTSU9OX0VSUk9SXCJdID0gXCJrZXlTeXN0ZW1EZXN0cm95UmVtb3ZlU2Vzc2lvbkVycm9yXCI7XG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbWFuaWZlc3QgbG9hZCBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgRXJyb3JEZXRhaWxzW1wiTUFOSUZFU1RfTE9BRF9FUlJPUlwiXSA9IFwibWFuaWZlc3RMb2FkRXJyb3JcIjtcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtYW5pZmVzdCBsb2FkIHRpbWVvdXQgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIEVycm9yRGV0YWlsc1tcIk1BTklGRVNUX0xPQURfVElNRU9VVFwiXSA9IFwibWFuaWZlc3RMb2FkVGltZU91dFwiO1xuICAvLyBJZGVudGlmaWVyIGZvciBhIG1hbmlmZXN0IHBhcnNpbmcgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlYXNvbiA6IGVycm9yIHJlYXNvbn1cbiAgRXJyb3JEZXRhaWxzW1wiTUFOSUZFU1RfUEFSU0lOR19FUlJPUlwiXSA9IFwibWFuaWZlc3RQYXJzaW5nRXJyb3JcIjtcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtYW5pZmVzdCB3aXRoIG9ubHkgaW5jb21wYXRpYmxlIGNvZGVjcyBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVhc29uIDogZXJyb3IgcmVhc29ufVxuICBFcnJvckRldGFpbHNbXCJNQU5JRkVTVF9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SXCJdID0gXCJtYW5pZmVzdEluY29tcGF0aWJsZUNvZGVjc0Vycm9yXCI7XG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbGV2ZWwgd2hpY2ggY29udGFpbnMgbm8gZnJhZ21lbnRzIC0gZGF0YTogeyB1cmw6IGZhdWx0eSBVUkwsIHJlYXNvbjogXCJubyBmcmFnbWVudHMgZm91bmQgaW4gbGV2ZWxcIiwgbGV2ZWw6IGluZGV4IG9mIHRoZSBiYWQgbGV2ZWwgfVxuICBFcnJvckRldGFpbHNbXCJMRVZFTF9FTVBUWV9FUlJPUlwiXSA9IFwibGV2ZWxFbXB0eUVycm9yXCI7XG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbGV2ZWwgbG9hZCBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgRXJyb3JEZXRhaWxzW1wiTEVWRUxfTE9BRF9FUlJPUlwiXSA9IFwibGV2ZWxMb2FkRXJyb3JcIjtcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBsZXZlbCBsb2FkIHRpbWVvdXQgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIEVycm9yRGV0YWlsc1tcIkxFVkVMX0xPQURfVElNRU9VVFwiXSA9IFwibGV2ZWxMb2FkVGltZU91dFwiO1xuICAvLyBJZGVudGlmaWVyIGZvciBhIGxldmVsIHBhcnNlIGVycm9yIC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCBlcnJvcjogRXJyb3IsIHJlYXNvbjogZXJyb3IgbWVzc2FnZSB9XG4gIEVycm9yRGV0YWlsc1tcIkxFVkVMX1BBUlNJTkdfRVJST1JcIl0gPSBcImxldmVsUGFyc2luZ0Vycm9yXCI7XG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbGV2ZWwgc3dpdGNoIGVycm9yIC0gZGF0YTogeyBsZXZlbCA6IGZhdWx0eSBsZXZlbCBJZCwgZXZlbnQgOiBlcnJvciBkZXNjcmlwdGlvbn1cbiAgRXJyb3JEZXRhaWxzW1wiTEVWRUxfU1dJVENIX0VSUk9SXCJdID0gXCJsZXZlbFN3aXRjaEVycm9yXCI7XG4gIC8vIElkZW50aWZpZXIgZm9yIGFuIGF1ZGlvIHRyYWNrIGxvYWQgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIEVycm9yRGV0YWlsc1tcIkFVRElPX1RSQUNLX0xPQURfRVJST1JcIl0gPSBcImF1ZGlvVHJhY2tMb2FkRXJyb3JcIjtcbiAgLy8gSWRlbnRpZmllciBmb3IgYW4gYXVkaW8gdHJhY2sgbG9hZCB0aW1lb3V0IC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBFcnJvckRldGFpbHNbXCJBVURJT19UUkFDS19MT0FEX1RJTUVPVVRcIl0gPSBcImF1ZGlvVHJhY2tMb2FkVGltZU91dFwiO1xuICAvLyBJZGVudGlmaWVyIGZvciBhIHN1YnRpdGxlIHRyYWNrIGxvYWQgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIEVycm9yRGV0YWlsc1tcIlNVQlRJVExFX0xPQURfRVJST1JcIl0gPSBcInN1YnRpdGxlVHJhY2tMb2FkRXJyb3JcIjtcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBzdWJ0aXRsZSB0cmFjayBsb2FkIHRpbWVvdXQgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIEVycm9yRGV0YWlsc1tcIlNVQlRJVExFX1RSQUNLX0xPQURfVElNRU9VVFwiXSA9IFwic3VidGl0bGVUcmFja0xvYWRUaW1lT3V0XCI7XG4gIC8vIElkZW50aWZpZXIgZm9yIGZyYWdtZW50IGxvYWQgZXJyb3IgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIEVycm9yRGV0YWlsc1tcIkZSQUdfTE9BRF9FUlJPUlwiXSA9IFwiZnJhZ0xvYWRFcnJvclwiO1xuICAvLyBJZGVudGlmaWVyIGZvciBmcmFnbWVudCBsb2FkIHRpbWVvdXQgZXJyb3IgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3R9XG4gIEVycm9yRGV0YWlsc1tcIkZSQUdfTE9BRF9USU1FT1VUXCJdID0gXCJmcmFnTG9hZFRpbWVPdXRcIjtcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBmcmFnbWVudCBkZWNyeXB0aW9uIGVycm9yIGV2ZW50IC0gZGF0YToge2lkIDogZGVtdXhlciBJZCxmcmFnOiBmcmFnbWVudCBvYmplY3QsIHJlYXNvbiA6IHBhcnNpbmcgZXJyb3IgZGVzY3JpcHRpb24gfVxuICBFcnJvckRldGFpbHNbXCJGUkFHX0RFQ1JZUFRfRVJST1JcIl0gPSBcImZyYWdEZWNyeXB0RXJyb3JcIjtcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBmcmFnbWVudCBwYXJzaW5nIGVycm9yIGV2ZW50IC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgSWQsIHJlYXNvbiA6IHBhcnNpbmcgZXJyb3IgZGVzY3JpcHRpb24gfVxuICAvLyB3aWxsIGJlIHJlbmFtZWQgREVNVVhfUEFSU0lOR19FUlJPUiBhbmQgc3dpdGNoZWQgdG8gTVVYX0VSUk9SIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2VcbiAgRXJyb3JEZXRhaWxzW1wiRlJBR19QQVJTSU5HX0VSUk9SXCJdID0gXCJmcmFnUGFyc2luZ0Vycm9yXCI7XG4gIC8vIElkZW50aWZpZXIgZm9yIGEgZnJhZ21lbnQgb3IgcGFydCBsb2FkIHNraXBwZWQgYmVjYXVzZSBvZiBhIEdBUCB0YWcgb3IgYXR0cmlidXRlXG4gIEVycm9yRGV0YWlsc1tcIkZSQUdfR0FQXCJdID0gXCJmcmFnR2FwXCI7XG4gIC8vIElkZW50aWZpZXIgZm9yIGEgcmVtdXggYWxsb2MgZXJyb3IgZXZlbnQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBJZCwgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgYnl0ZXMgOiBuYiBvZiBieXRlcyBvbiB3aGljaCBhbGxvY2F0aW9uIGZhaWxlZCAsIHJlYXNvbiA6IGVycm9yIHRleHQgfVxuICBFcnJvckRldGFpbHNbXCJSRU1VWF9BTExPQ19FUlJPUlwiXSA9IFwicmVtdXhBbGxvY0Vycm9yXCI7XG4gIC8vIElkZW50aWZpZXIgZm9yIGRlY3J5cHQga2V5IGxvYWQgZXJyb3IgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIEVycm9yRGV0YWlsc1tcIktFWV9MT0FEX0VSUk9SXCJdID0gXCJrZXlMb2FkRXJyb3JcIjtcbiAgLy8gSWRlbnRpZmllciBmb3IgZGVjcnlwdCBrZXkgbG9hZCB0aW1lb3V0IGVycm9yIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0fVxuICBFcnJvckRldGFpbHNbXCJLRVlfTE9BRF9USU1FT1VUXCJdID0gXCJrZXlMb2FkVGltZU91dFwiO1xuICAvLyBUcmlnZ2VyZWQgd2hlbiBhbiBleGNlcHRpb24gb2NjdXJzIHdoaWxlIGFkZGluZyBhIHNvdXJjZUJ1ZmZlciB0byBNZWRpYVNvdXJjZSAtIGRhdGEgOiB7IGVycm9yIDogZXhjZXB0aW9uICwgbWltZVR5cGUgOiBtaW1lVHlwZSB9XG4gIEVycm9yRGV0YWlsc1tcIkJVRkZFUl9BRERfQ09ERUNfRVJST1JcIl0gPSBcImJ1ZmZlckFkZENvZGVjRXJyb3JcIjtcbiAgLy8gVHJpZ2dlcmVkIHdoZW4gc291cmNlIGJ1ZmZlcihzKSBjb3VsZCBub3QgYmUgY3JlYXRlZCB1c2luZyBsZXZlbCAobWFuaWZlc3QgQ09ERUNTIGF0dHJpYnV0ZSksIHBhcnNlZCBtZWRpYSwgb3IgYmVzdCBndWVzcyBjb2RlYyhzKSAtIGRhdGE6IHsgcmVhc29uIDogZXJyb3IgcmVhc29uIH1cbiAgRXJyb3JEZXRhaWxzW1wiQlVGRkVSX0lOQ09NUEFUSUJMRV9DT0RFQ1NfRVJST1JcIl0gPSBcImJ1ZmZlckluY29tcGF0aWJsZUNvZGVjc0Vycm9yXCI7XG4gIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIGFwcGVuZCBlcnJvciAtIGRhdGE6IGFwcGVuZCBlcnJvciBkZXNjcmlwdGlvblxuICBFcnJvckRldGFpbHNbXCJCVUZGRVJfQVBQRU5EX0VSUk9SXCJdID0gXCJidWZmZXJBcHBlbmRFcnJvclwiO1xuICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBhcHBlbmRpbmcgZXJyb3IgZXZlbnQgLSBkYXRhOiBhcHBlbmRpbmcgZXJyb3IgZGVzY3JpcHRpb25cbiAgRXJyb3JEZXRhaWxzW1wiQlVGRkVSX0FQUEVORElOR19FUlJPUlwiXSA9IFwiYnVmZmVyQXBwZW5kaW5nRXJyb3JcIjtcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBidWZmZXIgc3RhbGxlZCBlcnJvciBldmVudFxuICBFcnJvckRldGFpbHNbXCJCVUZGRVJfU1RBTExFRF9FUlJPUlwiXSA9IFwiYnVmZmVyU3RhbGxlZEVycm9yXCI7XG4gIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIGZ1bGwgZXZlbnRcbiAgRXJyb3JEZXRhaWxzW1wiQlVGRkVSX0ZVTExfRVJST1JcIl0gPSBcImJ1ZmZlckZ1bGxFcnJvclwiO1xuICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBzZWVrIG92ZXIgaG9sZSBldmVudFxuICBFcnJvckRldGFpbHNbXCJCVUZGRVJfU0VFS19PVkVSX0hPTEVcIl0gPSBcImJ1ZmZlclNlZWtPdmVySG9sZVwiO1xuICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBudWRnZSBvbiBzdGFsbCAocGxheWJhY2sgaXMgc3R1Y2sgYWx0aG91Z2ggY3VycmVudFRpbWUgaXMgaW4gYSBidWZmZXJlZCBhcmVhKVxuICBFcnJvckRldGFpbHNbXCJCVUZGRVJfTlVER0VfT05fU1RBTExcIl0gPSBcImJ1ZmZlck51ZGdlT25TdGFsbFwiO1xuICAvLyBJZGVudGlmaWVyIGZvciBhIEludGVyc3RpdGlhbCBBc3NldCBMaXN0IGxvYWQgZXJyb3IgLSBkYXRhOiB7IHVybDogZmF1bHR5IFVSTCwgcmVzcG9uc2U6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9IH1cbiAgRXJyb3JEZXRhaWxzW1wiQVNTRVRfTElTVF9MT0FEX0VSUk9SXCJdID0gXCJhc3NldExpc3RMb2FkRXJyb3JcIjtcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBJbnRlcnN0aXRpYWwgQXNzZXQgTGlzdCBsb2FkIHRpbWVvdXQgLSBkYXRhOiB7IHVybDogZmF1bHR5IFVSTCwgcmVzcG9uc2U6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9IH1cbiAgRXJyb3JEZXRhaWxzW1wiQVNTRVRfTElTVF9MT0FEX1RJTUVPVVRcIl0gPSBcImFzc2V0TGlzdExvYWRUaW1lb3V0XCI7XG4gIC8vIElkZW50aWZpZXIgZm9yIGEgSW50ZXJzdGl0aWFsIEFzc2V0IExpc3QgcGFyc2luZyBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVhc29uIDogZXJyb3IgcmVhc29uLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBFcnJvckRldGFpbHNbXCJBU1NFVF9MSVNUX1BBUlNJTkdfRVJST1JcIl0gPSBcImFzc2V0TGlzdFBhcnNpbmdFcnJvclwiO1xuICAvLyBJZGVudGlmaWVyIGZvciBhIEludGVyc3RpdGlhbCBBc3NldCBMaXN0IHBhcnNpbmcgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlYXNvbiA6IGVycm9yIHJlYXNvbiwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgRXJyb3JEZXRhaWxzW1wiSU5URVJTVElUSUFMX0FTU0VUX0lURU1fRVJST1JcIl0gPSBcImludGVyc3RpdGlhbEFzc2V0SXRlbUVycm9yXCI7XG4gIC8vIElkZW50aWZpZXIgZm9yIGFuIGludGVybmFsIGV4Y2VwdGlvbiBoYXBwZW5pbmcgaW5zaWRlIGhscy5qcyB3aGlsZSBoYW5kbGluZyBhbiBldmVudFxuICBFcnJvckRldGFpbHNbXCJJTlRFUk5BTF9FWENFUFRJT05cIl0gPSBcImludGVybmFsRXhjZXB0aW9uXCI7XG4gIC8vIElkZW50aWZpZXIgZm9yIGFuIGludGVybmFsIGNhbGwgdG8gYWJvcnQgYSBsb2FkZXJcbiAgRXJyb3JEZXRhaWxzW1wiSU5URVJOQUxfQUJPUlRFRFwiXSA9IFwiYWJvcnRlZFwiO1xuICAvLyBUcmlnZ2VyZWQgd2hlbiBhdHRhY2hNZWRpYSBmYWlsc1xuICBFcnJvckRldGFpbHNbXCJBVFRBQ0hfTUVESUFfRVJST1JcIl0gPSBcImF0dGFjaE1lZGlhRXJyb3JcIjtcbiAgLy8gVW5jYXRlZ29yaXplZCBlcnJvclxuICBFcnJvckRldGFpbHNbXCJVTktOT1dOXCJdID0gXCJ1bmtub3duXCI7XG4gIHJldHVybiBFcnJvckRldGFpbHM7XG59KHt9KTtcblxubGV0IEV2ZW50cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoRXZlbnRzKSB7XG4gIC8vIEZpcmVkIGJlZm9yZSBNZWRpYVNvdXJjZSBpcyBhdHRhY2hpbmcgdG8gbWVkaWEgZWxlbWVudFxuICBFdmVudHNbXCJNRURJQV9BVFRBQ0hJTkdcIl0gPSBcImhsc01lZGlhQXR0YWNoaW5nXCI7XG4gIC8vIEZpcmVkIHdoZW4gTWVkaWFTb3VyY2UgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGF0dGFjaGVkIHRvIG1lZGlhIGVsZW1lbnRcbiAgRXZlbnRzW1wiTUVESUFfQVRUQUNIRURcIl0gPSBcImhsc01lZGlhQXR0YWNoZWRcIjtcbiAgLy8gRmlyZWQgYmVmb3JlIGRldGFjaGluZyBNZWRpYVNvdXJjZSBmcm9tIG1lZGlhIGVsZW1lbnRcbiAgRXZlbnRzW1wiTUVESUFfREVUQUNISU5HXCJdID0gXCJobHNNZWRpYURldGFjaGluZ1wiO1xuICAvLyBGaXJlZCB3aGVuIE1lZGlhU291cmNlIGhhcyBiZWVuIGRldGFjaGVkIGZyb20gbWVkaWEgZWxlbWVudFxuICBFdmVudHNbXCJNRURJQV9ERVRBQ0hFRFwiXSA9IFwiaGxzTWVkaWFEZXRhY2hlZFwiO1xuICAvLyBGaXJlZCB3aGVuIEhUTUxNZWRpYUVsZW1lbnQgZGlzcGF0Y2hlcyBcImVuZGVkXCIgZXZlbnQsIG9yIHN0YWxscyBhdCBlbmQgb2YgVk9EIHByb2dyYW1cbiAgRXZlbnRzW1wiTUVESUFfRU5ERURcIl0gPSBcImhsc01lZGlhRW5kZWRcIjtcbiAgLy8gRmlyZWQgYWZ0ZXIgcGxheWJhY2sgc3RhbGwgaXMgcmVzb2x2ZWQgd2l0aCBwbGF5aW5nLCBzZWVrZWQsIG9yIGVuZGVkIGV2ZW50IGZvbGxvd2luZyBCVUZGRVJfU1RBTExFRF9FUlJPUlxuICBFdmVudHNbXCJTVEFMTF9SRVNPTFZFRFwiXSA9IFwiaGxzU3RhbGxSZXNvbHZlZFwiO1xuICAvLyBGaXJlZCB3aGVuIHRoZSBidWZmZXIgaXMgZ29pbmcgdG8gYmUgcmVzZXRcbiAgRXZlbnRzW1wiQlVGRkVSX1JFU0VUXCJdID0gXCJobHNCdWZmZXJSZXNldFwiO1xuICAvLyBGaXJlZCB3aGVuIHdlIGtub3cgYWJvdXQgdGhlIGNvZGVjcyB0aGF0IHdlIG5lZWQgYnVmZmVycyBmb3IgdG8gcHVzaCBpbnRvIC0gZGF0YToge3RyYWNrcyA6IHsgY29udGFpbmVyLCBjb2RlYywgbGV2ZWxDb2RlYywgaW5pdFNlZ21lbnQsIG1ldGFkYXRhIH19XG4gIEV2ZW50c1tcIkJVRkZFUl9DT0RFQ1NcIl0gPSBcImhsc0J1ZmZlckNvZGVjc1wiO1xuICAvLyBmaXJlZCB3aGVuIHNvdXJjZWJ1ZmZlcnMgaGF2ZSBiZWVuIGNyZWF0ZWQgLSBkYXRhOiB7IHRyYWNrcyA6IHRyYWNrcyB9XG4gIEV2ZW50c1tcIkJVRkZFUl9DUkVBVEVEXCJdID0gXCJobHNCdWZmZXJDcmVhdGVkXCI7XG4gIC8vIGZpcmVkIHdoZW4gd2UgYXBwZW5kIGEgc2VnbWVudCB0byB0aGUgYnVmZmVyIC0gZGF0YTogeyBzZWdtZW50OiBzZWdtZW50IG9iamVjdCB9XG4gIEV2ZW50c1tcIkJVRkZFUl9BUFBFTkRJTkdcIl0gPSBcImhsc0J1ZmZlckFwcGVuZGluZ1wiO1xuICAvLyBmaXJlZCB3aGVuIHdlIGFyZSBkb25lIHdpdGggYXBwZW5kaW5nIGEgbWVkaWEgc2VnbWVudCB0byB0aGUgYnVmZmVyIC0gZGF0YSA6IHsgcGFyZW50IDogc2VnbWVudCBwYXJlbnQgdGhhdCB0cmlnZ2VyZWQgQlVGRkVSX0FQUEVORElORywgcGVuZGluZyA6IG5iIG9mIHNlZ21lbnRzIHdhaXRpbmcgZm9yIGFwcGVuZGluZyBmb3IgdGhpcyBzZWdtZW50IHBhcmVudH1cbiAgRXZlbnRzW1wiQlVGRkVSX0FQUEVOREVEXCJdID0gXCJobHNCdWZmZXJBcHBlbmRlZFwiO1xuICAvLyBmaXJlZCB3aGVuIHRoZSBzdHJlYW0gaXMgZmluaXNoZWQgYW5kIHdlIHdhbnQgdG8gbm90aWZ5IHRoZSBtZWRpYSBidWZmZXIgdGhhdCB0aGVyZSB3aWxsIGJlIG5vIG1vcmUgZGF0YSAtIGRhdGE6IHsgfVxuICBFdmVudHNbXCJCVUZGRVJfRU9TXCJdID0gXCJobHNCdWZmZXJFb3NcIjtcbiAgLy8gZmlyZWQgd2hlbiBhbGwgYnVmZmVycyBhcmUgZnVsbCB0byB0aGUgZW5kIG9mIHRoZSBwcm9ncmFtLCBhZnRlciBjYWxsaW5nIE1lZGlhU291cmNlLmVuZE9mU3RyZWFtKCkgKHVubGVzcyByZXN0cmljdGVkKVxuICBFdmVudHNbXCJCVUZGRVJFRF9UT19FTkRcIl0gPSBcImhsc0J1ZmZlcmVkVG9FbmRcIjtcbiAgLy8gZmlyZWQgd2hlbiB0aGUgbWVkaWEgYnVmZmVyIHNob3VsZCBiZSBmbHVzaGVkIC0gZGF0YSB7IHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQgfVxuICBFdmVudHNbXCJCVUZGRVJfRkxVU0hJTkdcIl0gPSBcImhsc0J1ZmZlckZsdXNoaW5nXCI7XG4gIC8vIGZpcmVkIHdoZW4gdGhlIG1lZGlhIGJ1ZmZlciBoYXMgYmVlbiBmbHVzaGVkIC0gZGF0YTogeyB9XG4gIEV2ZW50c1tcIkJVRkZFUl9GTFVTSEVEXCJdID0gXCJobHNCdWZmZXJGbHVzaGVkXCI7XG4gIC8vIGZpcmVkIHRvIHNpZ25hbCB0aGF0IGEgbWFuaWZlc3QgbG9hZGluZyBzdGFydHMgLSBkYXRhOiB7IHVybCA6IG1hbmlmZXN0VVJMfVxuICBFdmVudHNbXCJNQU5JRkVTVF9MT0FESU5HXCJdID0gXCJobHNNYW5pZmVzdExvYWRpbmdcIjtcbiAgLy8gZmlyZWQgYWZ0ZXIgbWFuaWZlc3QgaGFzIGJlZW4gbG9hZGVkIC0gZGF0YTogeyBsZXZlbHMgOiBbYXZhaWxhYmxlIHF1YWxpdHkgbGV2ZWxzXSwgYXVkaW9UcmFja3MgOiBbIGF2YWlsYWJsZSBhdWRpbyB0cmFja3MgXSwgdXJsIDogbWFuaWZlc3RVUkwsIHN0YXRzIDogTG9hZGVyU3RhdHMgfVxuICBFdmVudHNbXCJNQU5JRkVTVF9MT0FERURcIl0gPSBcImhsc01hbmlmZXN0TG9hZGVkXCI7XG4gIC8vIGZpcmVkIGFmdGVyIG1hbmlmZXN0IGhhcyBiZWVuIHBhcnNlZCAtIGRhdGE6IHsgbGV2ZWxzIDogW2F2YWlsYWJsZSBxdWFsaXR5IGxldmVsc10sIGZpcnN0TGV2ZWwgOiBpbmRleCBvZiBmaXJzdCBxdWFsaXR5IGxldmVsIGFwcGVhcmluZyBpbiBNYW5pZmVzdH1cbiAgRXZlbnRzW1wiTUFOSUZFU1RfUEFSU0VEXCJdID0gXCJobHNNYW5pZmVzdFBhcnNlZFwiO1xuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwgc3dpdGNoIGlzIHJlcXVlc3RlZCAtIGRhdGE6IHsgbGV2ZWwgOiBpZCBvZiBuZXcgbGV2ZWwgfVxuICBFdmVudHNbXCJMRVZFTF9TV0lUQ0hJTkdcIl0gPSBcImhsc0xldmVsU3dpdGNoaW5nXCI7XG4gIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCBzd2l0Y2ggaXMgZWZmZWN0aXZlIC0gZGF0YTogeyBsZXZlbCA6IGlkIG9mIG5ldyBsZXZlbCB9XG4gIEV2ZW50c1tcIkxFVkVMX1NXSVRDSEVEXCJdID0gXCJobHNMZXZlbFN3aXRjaGVkXCI7XG4gIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCBwbGF5bGlzdCBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgdXJsIDogbGV2ZWwgVVJMLCBsZXZlbCA6IGlkIG9mIGxldmVsIGJlaW5nIGxvYWRlZH1cbiAgRXZlbnRzW1wiTEVWRUxfTE9BRElOR1wiXSA9IFwiaGxzTGV2ZWxMb2FkaW5nXCI7XG4gIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCBwbGF5bGlzdCBsb2FkaW5nIGZpbmlzaGVzIC0gZGF0YTogeyBkZXRhaWxzIDogbGV2ZWxEZXRhaWxzIG9iamVjdCwgbGV2ZWwgOiBpZCBvZiBsb2FkZWQgbGV2ZWwsIHN0YXRzIDogTG9hZGVyU3RhdHMgfVxuICBFdmVudHNbXCJMRVZFTF9MT0FERURcIl0gPSBcImhsc0xldmVsTG9hZGVkXCI7XG4gIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCdzIGRldGFpbHMgaGF2ZSBiZWVuIHVwZGF0ZWQgYmFzZWQgb24gcHJldmlvdXMgZGV0YWlscywgYWZ0ZXIgaXQgaGFzIGJlZW4gbG9hZGVkIC0gZGF0YTogeyBkZXRhaWxzIDogbGV2ZWxEZXRhaWxzIG9iamVjdCwgbGV2ZWwgOiBpZCBvZiB1cGRhdGVkIGxldmVsIH1cbiAgRXZlbnRzW1wiTEVWRUxfVVBEQVRFRFwiXSA9IFwiaGxzTGV2ZWxVcGRhdGVkXCI7XG4gIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCdzIFBUUyBpbmZvcm1hdGlvbiBoYXMgYmVlbiB1cGRhdGVkIGFmdGVyIHBhcnNpbmcgYSBmcmFnbWVudCAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGxldmVsIDogaWQgb2YgdXBkYXRlZCBsZXZlbCwgZHJpZnQ6IFBUUyBkcmlmdCBvYnNlcnZlZCB3aGVuIHBhcnNpbmcgbGFzdCBmcmFnbWVudCB9XG4gIEV2ZW50c1tcIkxFVkVMX1BUU19VUERBVEVEXCJdID0gXCJobHNMZXZlbFB0c1VwZGF0ZWRcIjtcbiAgLy8gZmlyZWQgdG8gbm90aWZ5IHRoYXQgbGV2ZWxzIGhhdmUgY2hhbmdlZCBhZnRlciByZW1vdmluZyBhIGxldmVsIC0gZGF0YTogeyBsZXZlbHMgOiBbYXZhaWxhYmxlIHF1YWxpdHkgbGV2ZWxzXSB9XG4gIEV2ZW50c1tcIkxFVkVMU19VUERBVEVEXCJdID0gXCJobHNMZXZlbHNVcGRhdGVkXCI7XG4gIC8vIGZpcmVkIHRvIG5vdGlmeSB0aGF0IGF1ZGlvIHRyYWNrIGxpc3RzIGhhcyBiZWVuIHVwZGF0ZWQgLSBkYXRhOiB7IGF1ZGlvVHJhY2tzIDogYXVkaW9UcmFja3MgfVxuICBFdmVudHNbXCJBVURJT19UUkFDS1NfVVBEQVRFRFwiXSA9IFwiaGxzQXVkaW9UcmFja3NVcGRhdGVkXCI7XG4gIC8vIGZpcmVkIHdoZW4gYW4gYXVkaW8gdHJhY2sgc3dpdGNoaW5nIGlzIHJlcXVlc3RlZCAtIGRhdGE6IHsgaWQgOiBhdWRpbyB0cmFjayBpZCB9XG4gIEV2ZW50c1tcIkFVRElPX1RSQUNLX1NXSVRDSElOR1wiXSA9IFwiaGxzQXVkaW9UcmFja1N3aXRjaGluZ1wiO1xuICAvLyBmaXJlZCB3aGVuIGFuIGF1ZGlvIHRyYWNrIHN3aXRjaCBhY3R1YWxseSBvY2N1cnMgLSBkYXRhOiB7IGlkIDogYXVkaW8gdHJhY2sgaWQgfVxuICBFdmVudHNbXCJBVURJT19UUkFDS19TV0lUQ0hFRFwiXSA9IFwiaGxzQXVkaW9UcmFja1N3aXRjaGVkXCI7XG4gIC8vIGZpcmVkIHdoZW4gYW4gYXVkaW8gdHJhY2sgbG9hZGluZyBzdGFydHMgLSBkYXRhOiB7IHVybCA6IGF1ZGlvIHRyYWNrIFVSTCwgaWQgOiBhdWRpbyB0cmFjayBpZCB9XG4gIEV2ZW50c1tcIkFVRElPX1RSQUNLX0xPQURJTkdcIl0gPSBcImhsc0F1ZGlvVHJhY2tMb2FkaW5nXCI7XG4gIC8vIGZpcmVkIHdoZW4gYW4gYXVkaW8gdHJhY2sgbG9hZGluZyBmaW5pc2hlcyAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGlkIDogYXVkaW8gdHJhY2sgaWQsIHN0YXRzIDogTG9hZGVyU3RhdHMgfVxuICBFdmVudHNbXCJBVURJT19UUkFDS19MT0FERURcIl0gPSBcImhsc0F1ZGlvVHJhY2tMb2FkZWRcIjtcbiAgLy8gZmlyZWQgd2hlbiBhbiBhdWRpbyB0cmFja3MncyBkZXRhaWxzIGhhdmUgYmVlbiB1cGRhdGVkIGJhc2VkIG9uIHByZXZpb3VzIGRldGFpbHMsIGFmdGVyIGl0IGhhcyBiZWVuIGxvYWRlZCAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGlkIDogdHJhY2sgaWQgfVxuICBFdmVudHNbXCJBVURJT19UUkFDS19VUERBVEVEXCJdID0gXCJobHNBdWRpb1RyYWNrVXBkYXRlZFwiO1xuICAvLyBmaXJlZCB0byBub3RpZnkgdGhhdCBzdWJ0aXRsZSB0cmFjayBsaXN0cyBoYXMgYmVlbiB1cGRhdGVkIC0gZGF0YTogeyBzdWJ0aXRsZVRyYWNrcyA6IHN1YnRpdGxlVHJhY2tzIH1cbiAgRXZlbnRzW1wiU1VCVElUTEVfVFJBQ0tTX1VQREFURURcIl0gPSBcImhsc1N1YnRpdGxlVHJhY2tzVXBkYXRlZFwiO1xuICAvLyBmaXJlZCB0byBub3RpZnkgdGhhdCBzdWJ0aXRsZSB0cmFja3Mgd2VyZSBjbGVhcmVkIGFzIGEgcmVzdWx0IG9mIHN0b3BwaW5nIHRoZSBtZWRpYVxuICBFdmVudHNbXCJTVUJUSVRMRV9UUkFDS1NfQ0xFQVJFRFwiXSA9IFwiaGxzU3VidGl0bGVUcmFja3NDbGVhcmVkXCI7XG4gIC8vIGZpcmVkIHdoZW4gYW4gc3VidGl0bGUgdHJhY2sgc3dpdGNoIG9jY3VycyAtIGRhdGE6IHsgaWQgOiBzdWJ0aXRsZSB0cmFjayBpZCB9XG4gIEV2ZW50c1tcIlNVQlRJVExFX1RSQUNLX1NXSVRDSFwiXSA9IFwiaGxzU3VidGl0bGVUcmFja1N3aXRjaFwiO1xuICAvLyBmaXJlZCB3aGVuIGEgc3VidGl0bGUgdHJhY2sgbG9hZGluZyBzdGFydHMgLSBkYXRhOiB7IHVybCA6IHN1YnRpdGxlIHRyYWNrIFVSTCwgaWQgOiBzdWJ0aXRsZSB0cmFjayBpZCB9XG4gIEV2ZW50c1tcIlNVQlRJVExFX1RSQUNLX0xPQURJTkdcIl0gPSBcImhsc1N1YnRpdGxlVHJhY2tMb2FkaW5nXCI7XG4gIC8vIGZpcmVkIHdoZW4gYSBzdWJ0aXRsZSB0cmFjayBsb2FkaW5nIGZpbmlzaGVzIC0gZGF0YTogeyBkZXRhaWxzIDogbGV2ZWxEZXRhaWxzIG9iamVjdCwgaWQgOiBzdWJ0aXRsZSB0cmFjayBpZCwgc3RhdHMgOiBMb2FkZXJTdGF0cyB9XG4gIEV2ZW50c1tcIlNVQlRJVExFX1RSQUNLX0xPQURFRFwiXSA9IFwiaGxzU3VidGl0bGVUcmFja0xvYWRlZFwiO1xuICAvLyBmaXJlZCB3aGVuIGEgc3VidGl0bGUgIHJhY2tzJ3MgZGV0YWlscyBoYXZlIGJlZW4gdXBkYXRlZCBiYXNlZCBvbiBwcmV2aW91cyBkZXRhaWxzLCBhZnRlciBpdCBoYXMgYmVlbiBsb2FkZWQgLSBkYXRhOiB7IGRldGFpbHMgOiBsZXZlbERldGFpbHMgb2JqZWN0LCBpZCA6IHRyYWNrIGlkIH1cbiAgRXZlbnRzW1wiU1VCVElUTEVfVFJBQ0tfVVBEQVRFRFwiXSA9IFwiaGxzU3VidGl0bGVUcmFja1VwZGF0ZWRcIjtcbiAgLy8gZmlyZWQgd2hlbiBhIHN1YnRpdGxlIGZyYWdtZW50IGhhcyBiZWVuIHByb2Nlc3NlZCAtIGRhdGE6IHsgc3VjY2VzcyA6IGJvb2xlYW4sIGZyYWcgOiB0aGUgcHJvY2Vzc2VkIGZyYWcgfVxuICBFdmVudHNbXCJTVUJUSVRMRV9GUkFHX1BST0NFU1NFRFwiXSA9IFwiaGxzU3VidGl0bGVGcmFnUHJvY2Vzc2VkXCI7XG4gIC8vIGZpcmVkIHdoZW4gYSBzZXQgb2YgVlRUQ3VlcyB0byBiZSBtYW5hZ2VkIGV4dGVybmFsbHkgaGFzIGJlZW4gcGFyc2VkIC0gZGF0YTogeyB0eXBlOiBzdHJpbmcsIHRyYWNrOiBzdHJpbmcsIGN1ZXM6IFsgVlRUQ3VlIF0gfVxuICBFdmVudHNbXCJDVUVTX1BBUlNFRFwiXSA9IFwiaGxzQ3Vlc1BhcnNlZFwiO1xuICAvLyBmaXJlZCB3aGVuIGEgdGV4dCB0cmFjayB0byBiZSBtYW5hZ2VkIGV4dGVybmFsbHkgaXMgZm91bmQgLSBkYXRhOiB7IHRyYWNrczogWyB7IGxhYmVsOiBzdHJpbmcsIGtpbmQ6IHN0cmluZywgZGVmYXVsdDogYm9vbGVhbiB9IF0gfVxuICBFdmVudHNbXCJOT05fTkFUSVZFX1RFWFRfVFJBQ0tTX0ZPVU5EXCJdID0gXCJobHNOb25OYXRpdmVUZXh0VHJhY2tzRm91bmRcIjtcbiAgLy8gZmlyZWQgd2hlbiB0aGUgZmlyc3QgdGltZXN0YW1wIGlzIGZvdW5kIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGluaXRQVFM6IGluaXRQVFMsIHRpbWVzY2FsZTogdGltZXNjYWxlLCBmcmFnIDogZnJhZ21lbnQgb2JqZWN0IH1cbiAgRXZlbnRzW1wiSU5JVF9QVFNfRk9VTkRcIl0gPSBcImhsc0luaXRQdHNGb3VuZFwiO1xuICAvLyBmaXJlZCB3aGVuIGEgZnJhZ21lbnQgbG9hZGluZyBzdGFydHMgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QgfVxuICBFdmVudHNbXCJGUkFHX0xPQURJTkdcIl0gPSBcImhsc0ZyYWdMb2FkaW5nXCI7XG4gIC8vIGZpcmVkIHdoZW4gYSBmcmFnbWVudCBsb2FkaW5nIGlzIHByb2dyZXNzaW5nIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCB7IHRyZXF1ZXN0LCB0Zmlyc3QsIGxvYWRlZCB9IH1cbiAgLy8gRlJBR19MT0FEX1BST0dSRVNTID0gJ2hsc0ZyYWdMb2FkUHJvZ3Jlc3MnLFxuICAvLyBJZGVudGlmaWVyIGZvciBmcmFnbWVudCBsb2FkIGFib3J0aW5nIGZvciBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QgfVxuICBFdmVudHNbXCJGUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURURcIl0gPSBcImhsc0ZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZFwiO1xuICAvLyBmaXJlZCB3aGVuIGEgZnJhZ21lbnQgbG9hZGluZyBpcyBjb21wbGV0ZWQgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIHBheWxvYWQgOiBmcmFnbWVudCBwYXlsb2FkLCBzdGF0cyA6IExvYWRlclN0YXRzIH1cbiAgRXZlbnRzW1wiRlJBR19MT0FERURcIl0gPSBcImhsc0ZyYWdMb2FkZWRcIjtcbiAgLy8gZmlyZWQgd2hlbiBhIGZyYWdtZW50IGhhcyBmaW5pc2hlZCBkZWNyeXB0aW5nIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWc6IGZyYWdtZW50IG9iamVjdCwgcGF5bG9hZCA6IGZyYWdtZW50IHBheWxvYWQsIHN0YXRzIDogeyB0c3RhcnQsIHRkZWNyeXB0IH0gfVxuICBFdmVudHNbXCJGUkFHX0RFQ1JZUFRFRFwiXSA9IFwiaGxzRnJhZ0RlY3J5cHRlZFwiO1xuICAvLyBmaXJlZCB3aGVuIEluaXQgU2VnbWVudCBoYXMgYmVlbiBleHRyYWN0ZWQgZnJvbSBmcmFnbWVudCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnOiBmcmFnbWVudCBvYmplY3QsIG1vb3YgOiBtb292IE1QNCBib3gsIGNvZGVjcyA6IGNvZGVjcyBmb3VuZCB3aGlsZSBwYXJzaW5nIGZyYWdtZW50IH1cbiAgRXZlbnRzW1wiRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVFwiXSA9IFwiaGxzRnJhZ1BhcnNpbmdJbml0U2VnbWVudFwiO1xuICAvLyBmaXJlZCB3aGVuIHBhcnNpbmcgc2VpIHRleHQgaXMgY29tcGxldGVkIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWc6IGZyYWdtZW50IG9iamVjdCwgc2FtcGxlcyA6IFsgc2VpIHNhbXBsZXMgcGVzIF0gfVxuICBFdmVudHNbXCJGUkFHX1BBUlNJTkdfVVNFUkRBVEFcIl0gPSBcImhsc0ZyYWdQYXJzaW5nVXNlcmRhdGFcIjtcbiAgLy8gZmlyZWQgd2hlbiBwYXJzaW5nIGlkMyBpcyBjb21wbGV0ZWQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZzogZnJhZ21lbnQgb2JqZWN0LCBzYW1wbGVzIDogWyBpZDMgc2FtcGxlcyBwZXMgXSB9XG4gIEV2ZW50c1tcIkZSQUdfUEFSU0lOR19NRVRBREFUQVwiXSA9IFwiaGxzRnJhZ1BhcnNpbmdNZXRhZGF0YVwiO1xuICAvLyBmaXJlZCB3aGVuIGRhdGEgaGF2ZSBiZWVuIGV4dHJhY3RlZCBmcm9tIGZyYWdtZW50IC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWc6IGZyYWdtZW50IG9iamVjdCwgZGF0YTEgOiBtb29mIE1QNCBib3ggb3IgVFMgZnJhZ21lbnRzLCBkYXRhMiA6IG1kYXQgTVA0IGJveCBvciBudWxsfVxuICAvLyBGUkFHX1BBUlNJTkdfREFUQSA9ICdobHNGcmFnUGFyc2luZ0RhdGEnLFxuICAvLyBmaXJlZCB3aGVuIGZyYWdtZW50IHBhcnNpbmcgaXMgY29tcGxldGVkIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWc6IGZyYWdtZW50IG9iamVjdCB9XG4gIEV2ZW50c1tcIkZSQUdfUEFSU0VEXCJdID0gXCJobHNGcmFnUGFyc2VkXCI7XG4gIC8vIGZpcmVkIHdoZW4gZnJhZ21lbnQgcmVtdXhlZCBNUDQgYm94ZXMgaGF2ZSBhbGwgYmVlbiBhcHBlbmRlZCBpbnRvIFNvdXJjZUJ1ZmZlciAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCBzdGF0cyA6IExvYWRlclN0YXRzIH1cbiAgRXZlbnRzW1wiRlJBR19CVUZGRVJFRFwiXSA9IFwiaGxzRnJhZ0J1ZmZlcmVkXCI7XG4gIC8vIGZpcmVkIHdoZW4gZnJhZ21lbnQgbWF0Y2hpbmcgd2l0aCBjdXJyZW50IG1lZGlhIHBvc2l0aW9uIGlzIGNoYW5naW5nIC0gZGF0YSA6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnIDogZnJhZ21lbnQgb2JqZWN0IH1cbiAgRXZlbnRzW1wiRlJBR19DSEFOR0VEXCJdID0gXCJobHNGcmFnQ2hhbmdlZFwiO1xuICAvLyBJZGVudGlmaWVyIGZvciBhIEZQUyBkcm9wIGV2ZW50IC0gZGF0YTogeyBjdXJyZW50RHJvcHBlZCwgY3VycmVudERlY29kZWQsIHRvdGFsRHJvcHBlZEZyYW1lcyB9XG4gIEV2ZW50c1tcIkZQU19EUk9QXCJdID0gXCJobHNGcHNEcm9wXCI7XG4gIC8vIHRyaWdnZXJlZCB3aGVuIEZQUyBkcm9wIHRyaWdnZXJzIGF1dG8gbGV2ZWwgY2FwcGluZyAtIGRhdGE6IHsgbGV2ZWwsIGRyb3BwZWRMZXZlbCB9XG4gIEV2ZW50c1tcIkZQU19EUk9QX0xFVkVMX0NBUFBJTkdcIl0gPSBcImhsc0Zwc0Ryb3BMZXZlbENhcHBpbmdcIjtcbiAgLy8gdHJpZ2dlcmVkIHdoZW4gbWF4QXV0b0xldmVsIGNoYW5nZXMgLSBkYXRhIHsgYXV0b0xldmVsQ2FwcGluZywgbGV2ZWxzLCBtYXhBdXRvTGV2ZWwsIG1pbkF1dG9MZXZlbCwgbWF4SGRjcExldmVsIH1cbiAgRXZlbnRzW1wiTUFYX0FVVE9fTEVWRUxfVVBEQVRFRFwiXSA9IFwiaGxzTWF4QXV0b0xldmVsVXBkYXRlZFwiO1xuICAvLyBJZGVudGlmaWVyIGZvciBhbiBlcnJvciBldmVudCAtIGRhdGE6IHsgdHlwZSA6IGVycm9yIHR5cGUsIGRldGFpbHMgOiBlcnJvciBkZXRhaWxzLCBmYXRhbCA6IGlmIHRydWUsIGhscy5qcyBjYW5ub3Qvd2lsbCBub3QgdHJ5IHRvIHJlY292ZXIsIGlmIGZhbHNlLCBobHMuanMgd2lsbCB0cnkgdG8gcmVjb3ZlcixvdGhlciBlcnJvciBzcGVjaWZpYyBkYXRhIH1cbiAgRXZlbnRzW1wiRVJST1JcIl0gPSBcImhsc0Vycm9yXCI7XG4gIC8vIGZpcmVkIHdoZW4gaGxzLmpzIGluc3RhbmNlIHN0YXJ0cyBkZXN0cm95aW5nLiBEaWZmZXJlbnQgZnJvbSBNRURJQV9ERVRBQ0hFRCBhcyBvbmUgY291bGQgd2FudCB0byBkZXRhY2ggYW5kIHJlYXR0YWNoIGEgbWVkaWEgdG8gdGhlIGluc3RhbmNlIG9mIGhscy5qcyB0byBoYW5kbGUgbWlkLXJvbGxzIGZvciBleGFtcGxlIC0gZGF0YTogeyB9XG4gIEV2ZW50c1tcIkRFU1RST1lJTkdcIl0gPSBcImhsc0Rlc3Ryb3lpbmdcIjtcbiAgLy8gZmlyZWQgd2hlbiBhIGRlY3J5cHQga2V5IGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0IH1cbiAgRXZlbnRzW1wiS0VZX0xPQURJTkdcIl0gPSBcImhsc0tleUxvYWRpbmdcIjtcbiAgLy8gZmlyZWQgd2hlbiBhIGRlY3J5cHQga2V5IGxvYWRpbmcgaXMgY29tcGxldGVkIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCBrZXlJbmZvIDogS2V5TG9hZGVySW5mbyB9XG4gIEV2ZW50c1tcIktFWV9MT0FERURcIl0gPSBcImhsc0tleUxvYWRlZFwiO1xuICAvLyBkZXByZWNhdGVkOyBwbGVhc2UgdXNlIEJBQ0tfQlVGRkVSX1JFQUNIRUQgLSBkYXRhIDogeyBidWZmZXJFbmQ6IG51bWJlciB9XG4gIEV2ZW50c1tcIkxJVkVfQkFDS19CVUZGRVJfUkVBQ0hFRFwiXSA9IFwiaGxzTGl2ZUJhY2tCdWZmZXJSZWFjaGVkXCI7XG4gIC8vIGZpcmVkIHdoZW4gdGhlIGJhY2sgYnVmZmVyIGlzIHJlYWNoZWQgYXMgZGVmaW5lZCBieSB0aGUgYmFja0J1ZmZlckxlbmd0aCBjb25maWcgb3B0aW9uIC0gZGF0YSA6IHsgYnVmZmVyRW5kOiBudW1iZXIgfVxuICBFdmVudHNbXCJCQUNLX0JVRkZFUl9SRUFDSEVEXCJdID0gXCJobHNCYWNrQnVmZmVyUmVhY2hlZFwiO1xuICAvLyBmaXJlZCBhZnRlciBzdGVlcmluZyBtYW5pZmVzdCBoYXMgYmVlbiBsb2FkZWQgLSBkYXRhOiB7IHN0ZWVyaW5nTWFuaWZlc3Q6IFN0ZWVyaW5nTWFuaWZlc3Qgb2JqZWN0LCB1cmw6IHN0ZWVyaW5nIG1hbmlmZXN0IFVSTCB9XG4gIEV2ZW50c1tcIlNURUVSSU5HX01BTklGRVNUX0xPQURFRFwiXSA9IFwiaGxzU3RlZXJpbmdNYW5pZmVzdExvYWRlZFwiO1xuICAvLyBmaXJlZCB3aGVuIGFzc2V0IGxpc3QgaGFzIGJlZ3VuIGxvYWRpbmdcbiAgRXZlbnRzW1wiQVNTRVRfTElTVF9MT0FESU5HXCJdID0gXCJobHNBc3NldExpc3RMb2FkaW5nXCI7XG4gIC8vIGZpcmVkIHdoZW4gYSB2YWxpZCBhc3NldCBsaXN0IGlzIGxvYWRlZFxuICBFdmVudHNbXCJBU1NFVF9MSVNUX0xPQURFRFwiXSA9IFwiaGxzQXNzZXRMaXN0TG9hZGVkXCI7XG4gIC8vIGZpcmVkIHdoZW4gdGhlIGxpc3Qgb2YgSW50ZXJzdGl0aWFsIEV2ZW50cyBhbmQgSW50ZXJzdGl0aWFsIFNjaGVkdWxlIGlzIHVwZGF0ZWRcbiAgRXZlbnRzW1wiSU5URVJTVElUSUFMU19VUERBVEVEXCJdID0gXCJobHNJbnRlcnN0aXRpYWxzVXBkYXRlZFwiO1xuICAvLyBmaXJlZCB3aGVuIHRoZSBidWZmZXIgcmVhY2hlcyBhbiBJbnRlcnN0aXRpYWwgU2NoZWR1bGUgYm91bmRhcnkgKGJvdGggUHJpbWFyeSBzZWdtZW50cyBhbmQgSW50ZXJzdGl0aWFsIEFzc2V0cylcbiAgRXZlbnRzW1wiSU5URVJTVElUSUFMU19CVUZGRVJFRF9UT19CT1VOREFSWVwiXSA9IFwiaGxzSW50ZXJzdGl0aWFsc0J1ZmZlcmVkVG9Cb3VuZGFyeVwiO1xuICAvLyBmaXJlZCB3aGVuIGEgcGxheWVyIGluc3RhbmNlIGZvciBhbiBJbnRlcnN0aXRpYWwgQXNzZXQgaGFzIGJlZW4gY3JlYXRlZFxuICBFdmVudHNbXCJJTlRFUlNUSVRJQUxfQVNTRVRfUExBWUVSX0NSRUFURURcIl0gPSBcImhsc0ludGVyc3RpdGlhbEFzc2V0UGxheWVyQ3JlYXRlZFwiO1xuICAvLyBJbnRlcnN0aXRpYWwgcGxheWJhY2sgc3RhcnRlZFxuICBFdmVudHNbXCJJTlRFUlNUSVRJQUxfU1RBUlRFRFwiXSA9IFwiaGxzSW50ZXJzdGl0aWFsU3RhcnRlZFwiO1xuICAvLyBJbnRlcnN0aXRpYWxBc3NldCBwbGF5YmFjayBzdGFydGVkXG4gIEV2ZW50c1tcIklOVEVSU1RJVElBTF9BU1NFVF9TVEFSVEVEXCJdID0gXCJobHNJbnRlcnN0aXRpYWxBc3NldFN0YXJ0ZWRcIjtcbiAgLy8gSW50ZXJzdGl0aWFsQXNzZXQgcGxheWJhY2sgZW5kZWRcbiAgRXZlbnRzW1wiSU5URVJTVElUSUFMX0FTU0VUX0VOREVEXCJdID0gXCJobHNJbnRlcnN0aXRpYWxBc3NldEVuZGVkXCI7XG4gIC8vIEludGVyc3RpdGlhbEFzc2V0IHBsYXliYWNrIGVycm9yZWRcbiAgRXZlbnRzW1wiSU5URVJTVElUSUFMX0FTU0VUX0VSUk9SXCJdID0gXCJobHNJbnRlcnN0aXRpYWxBc3NldEVycm9yXCI7XG4gIC8vIEludGVyc3RpdGlhbCBwbGF5YmFjayBlbmRlZFxuICBFdmVudHNbXCJJTlRFUlNUSVRJQUxfRU5ERURcIl0gPSBcImhsc0ludGVyc3RpdGlhbEVuZGVkXCI7XG4gIC8vIEludGVyc3RpdGlhbCBzY2hlZHVsZSByZXN1bWVkIHByaW1hcnkgcGxheWJhY2tcbiAgRXZlbnRzW1wiSU5URVJTVElUSUFMU19QUklNQVJZX1JFU1VNRURcIl0gPSBcImhsc0ludGVyc3RpdGlhbHNQcmltYXJ5UmVzdW1lZFwiO1xuICAvLyBJbnRlcnN0aXRpYWwgcGxheWVycyBkaXNwYXRjaCB0aGlzIGV2ZW50IHdoZW4gcGxheW91dCBsaW1pdCBpcyByZWFjaGVkXG4gIEV2ZW50c1tcIlBMQVlPVVRfTElNSVRfUkVBQ0hFRFwiXSA9IFwiaGxzUGxheW91dExpbWl0UmVhY2hlZFwiO1xuICAvLyBFdmVudCBEYXRlUmFuZ2UgY3VlIFwiZW50ZXJcIiBldmVudCBkaXNwYXRjaGVkXG4gIEV2ZW50c1tcIkVWRU5UX0NVRV9FTlRFUlwiXSA9IFwiaGxzRXZlbnRDdWVFbnRlclwiO1xuICByZXR1cm4gRXZlbnRzO1xufSh7fSk7XG5cbi8qKlxuICogRGVmaW5lcyBlYWNoIEV2ZW50IHR5cGUgYW5kIHBheWxvYWQgYnkgRXZlbnQgbmFtZS4gVXNlZCBpbiB7QGxpbmsgaGxzLmpzI0hsc0V2ZW50RW1pdHRlcn0gdG8gc3Ryb25nbHkgdHlwZSB0aGUgZXZlbnQgbGlzdGVuZXIgQVBJLlxuICovXG5cbnZhciBQbGF5bGlzdENvbnRleHRUeXBlID0ge1xuICBNQU5JRkVTVDogXCJtYW5pZmVzdFwiLFxuICBMRVZFTDogXCJsZXZlbFwiLFxuICBBVURJT19UUkFDSzogXCJhdWRpb1RyYWNrXCIsXG4gIFNVQlRJVExFX1RSQUNLOiBcInN1YnRpdGxlVHJhY2tcIlxufTtcbnZhciBQbGF5bGlzdExldmVsVHlwZSA9IHtcbiAgTUFJTjogXCJtYWluXCIsXG4gIEFVRElPOiBcImF1ZGlvXCIsXG4gIFNVQlRJVExFOiBcInN1YnRpdGxlXCJcbn07XG5cbi8qXG4gKiBjb21wdXRlIGFuIEV4cG9uZW50aWFsIFdlaWdodGVkIG1vdmluZyBhdmVyYWdlXG4gKiAtIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vdmluZ19hdmVyYWdlI0V4cG9uZW50aWFsX21vdmluZ19hdmVyYWdlXG4gKiAgLSBoZWF2aWx5IGluc3BpcmVkIGZyb20gc2hha2EtcGxheWVyXG4gKi9cblxuY2xhc3MgRVdNQSB7XG4gIC8vICBBYm91dCBoYWxmIG9mIHRoZSBlc3RpbWF0ZWQgdmFsdWUgd2lsbCBiZSBmcm9tIHRoZSBsYXN0IHxoYWxmTGlmZXwgc2FtcGxlcyBieSB3ZWlnaHQuXG4gIGNvbnN0cnVjdG9yKGhhbGZMaWZlLCBlc3RpbWF0ZSA9IDAsIHdlaWdodCA9IDApIHtcbiAgICB0aGlzLmhhbGZMaWZlID0gdm9pZCAwO1xuICAgIHRoaXMuYWxwaGFfID0gdm9pZCAwO1xuICAgIHRoaXMuZXN0aW1hdGVfID0gdm9pZCAwO1xuICAgIHRoaXMudG90YWxXZWlnaHRfID0gdm9pZCAwO1xuICAgIHRoaXMuaGFsZkxpZmUgPSBoYWxmTGlmZTtcbiAgICAvLyBMYXJnZXIgdmFsdWVzIG9mIGFscGhhIGV4cGlyZSBoaXN0b3JpY2FsIGRhdGEgbW9yZSBzbG93bHkuXG4gICAgdGhpcy5hbHBoYV8gPSBoYWxmTGlmZSA/IE1hdGguZXhwKE1hdGgubG9nKDAuNSkgLyBoYWxmTGlmZSkgOiAwO1xuICAgIHRoaXMuZXN0aW1hdGVfID0gZXN0aW1hdGU7XG4gICAgdGhpcy50b3RhbFdlaWdodF8gPSB3ZWlnaHQ7XG4gIH1cbiAgc2FtcGxlKHdlaWdodCwgdmFsdWUpIHtcbiAgICBjb25zdCBhZGpBbHBoYSA9IE1hdGgucG93KHRoaXMuYWxwaGFfLCB3ZWlnaHQpO1xuICAgIHRoaXMuZXN0aW1hdGVfID0gdmFsdWUgKiAoMSAtIGFkakFscGhhKSArIGFkakFscGhhICogdGhpcy5lc3RpbWF0ZV87XG4gICAgdGhpcy50b3RhbFdlaWdodF8gKz0gd2VpZ2h0O1xuICB9XG4gIGdldFRvdGFsV2VpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnRvdGFsV2VpZ2h0XztcbiAgfVxuICBnZXRFc3RpbWF0ZSgpIHtcbiAgICBpZiAodGhpcy5hbHBoYV8pIHtcbiAgICAgIGNvbnN0IHplcm9GYWN0b3IgPSAxIC0gTWF0aC5wb3codGhpcy5hbHBoYV8sIHRoaXMudG90YWxXZWlnaHRfKTtcbiAgICAgIGlmICh6ZXJvRmFjdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVzdGltYXRlXyAvIHplcm9GYWN0b3I7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVzdGltYXRlXztcbiAgfVxufVxuXG4vKlxuICogRVdNQSBCYW5kd2lkdGggRXN0aW1hdG9yXG4gKiAgLSBoZWF2aWx5IGluc3BpcmVkIGZyb20gc2hha2EtcGxheWVyXG4gKiBUcmFja3MgYmFuZHdpZHRoIHNhbXBsZXMgYW5kIGVzdGltYXRlcyBhdmFpbGFibGUgYmFuZHdpZHRoLlxuICogQmFzZWQgb24gdGhlIG1pbmltdW0gb2YgdHdvIGV4cG9uZW50aWFsbHktd2VpZ2h0ZWQgbW92aW5nIGF2ZXJhZ2VzIHdpdGhcbiAqIGRpZmZlcmVudCBoYWxmLWxpdmVzLlxuICovXG5cbmNsYXNzIEV3bWFCYW5kV2lkdGhFc3RpbWF0b3Ige1xuICBjb25zdHJ1Y3RvcihzbG93LCBmYXN0LCBkZWZhdWx0RXN0aW1hdGUsIGRlZmF1bHRUVEZCID0gMTAwKSB7XG4gICAgdGhpcy5kZWZhdWx0RXN0aW1hdGVfID0gdm9pZCAwO1xuICAgIHRoaXMubWluV2VpZ2h0XyA9IHZvaWQgMDtcbiAgICB0aGlzLm1pbkRlbGF5TXNfID0gdm9pZCAwO1xuICAgIHRoaXMuc2xvd18gPSB2b2lkIDA7XG4gICAgdGhpcy5mYXN0XyA9IHZvaWQgMDtcbiAgICB0aGlzLmRlZmF1bHRUVEZCXyA9IHZvaWQgMDtcbiAgICB0aGlzLnR0ZmJfID0gdm9pZCAwO1xuICAgIHRoaXMuZGVmYXVsdEVzdGltYXRlXyA9IGRlZmF1bHRFc3RpbWF0ZTtcbiAgICB0aGlzLm1pbldlaWdodF8gPSAwLjAwMTtcbiAgICB0aGlzLm1pbkRlbGF5TXNfID0gNTA7XG4gICAgdGhpcy5zbG93XyA9IG5ldyBFV01BKHNsb3cpO1xuICAgIHRoaXMuZmFzdF8gPSBuZXcgRVdNQShmYXN0KTtcbiAgICB0aGlzLmRlZmF1bHRUVEZCXyA9IGRlZmF1bHRUVEZCO1xuICAgIHRoaXMudHRmYl8gPSBuZXcgRVdNQShzbG93KTtcbiAgfVxuICB1cGRhdGUoc2xvdywgZmFzdCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNsb3dfLFxuICAgICAgZmFzdF8sXG4gICAgICB0dGZiX1xuICAgIH0gPSB0aGlzO1xuICAgIGlmIChzbG93Xy5oYWxmTGlmZSAhPT0gc2xvdykge1xuICAgICAgdGhpcy5zbG93XyA9IG5ldyBFV01BKHNsb3csIHNsb3dfLmdldEVzdGltYXRlKCksIHNsb3dfLmdldFRvdGFsV2VpZ2h0KCkpO1xuICAgIH1cbiAgICBpZiAoZmFzdF8uaGFsZkxpZmUgIT09IGZhc3QpIHtcbiAgICAgIHRoaXMuZmFzdF8gPSBuZXcgRVdNQShmYXN0LCBmYXN0Xy5nZXRFc3RpbWF0ZSgpLCBmYXN0Xy5nZXRUb3RhbFdlaWdodCgpKTtcbiAgICB9XG4gICAgaWYgKHR0ZmJfLmhhbGZMaWZlICE9PSBzbG93KSB7XG4gICAgICB0aGlzLnR0ZmJfID0gbmV3IEVXTUEoc2xvdywgdHRmYl8uZ2V0RXN0aW1hdGUoKSwgdHRmYl8uZ2V0VG90YWxXZWlnaHQoKSk7XG4gICAgfVxuICB9XG4gIHNhbXBsZShkdXJhdGlvbk1zLCBudW1CeXRlcykge1xuICAgIGR1cmF0aW9uTXMgPSBNYXRoLm1heChkdXJhdGlvbk1zLCB0aGlzLm1pbkRlbGF5TXNfKTtcbiAgICBjb25zdCBudW1CaXRzID0gOCAqIG51bUJ5dGVzO1xuICAgIC8vIHdlaWdodCBpcyBkdXJhdGlvbiBpbiBzZWNvbmRzXG4gICAgY29uc3QgZHVyYXRpb25TID0gZHVyYXRpb25NcyAvIDEwMDA7XG4gICAgLy8gdmFsdWUgaXMgYmFuZHdpZHRoIGluIGJpdHMvc1xuICAgIGNvbnN0IGJhbmR3aWR0aEluQnBzID0gbnVtQml0cyAvIGR1cmF0aW9uUztcbiAgICB0aGlzLmZhc3RfLnNhbXBsZShkdXJhdGlvblMsIGJhbmR3aWR0aEluQnBzKTtcbiAgICB0aGlzLnNsb3dfLnNhbXBsZShkdXJhdGlvblMsIGJhbmR3aWR0aEluQnBzKTtcbiAgfVxuICBzYW1wbGVUVEZCKHR0ZmIpIHtcbiAgICAvLyB3ZWlnaHQgaXMgZnJlcXVlbmN5IGN1cnZlIGFwcGxpZWQgdG8gVFRGQiBpbiBzZWNvbmRzXG4gICAgLy8gKGxvbmdlciB0aW1lcyBoYXZlIGxlc3Mgd2VpZ2h0IHdpdGggZXhwZWN0ZWQgaW5wdXQgdW5kZXIgMSBzZWNvbmQpXG4gICAgY29uc3Qgc2Vjb25kcyA9IHR0ZmIgLyAxMDAwO1xuICAgIGNvbnN0IHdlaWdodCA9IE1hdGguc3FydCgyKSAqIE1hdGguZXhwKC1NYXRoLnBvdyhzZWNvbmRzLCAyKSAvIDIpO1xuICAgIHRoaXMudHRmYl8uc2FtcGxlKHdlaWdodCwgTWF0aC5tYXgodHRmYiwgNSkpO1xuICB9XG4gIGNhbkVzdGltYXRlKCkge1xuICAgIHJldHVybiB0aGlzLmZhc3RfLmdldFRvdGFsV2VpZ2h0KCkgPj0gdGhpcy5taW5XZWlnaHRfO1xuICB9XG4gIGdldEVzdGltYXRlKCkge1xuICAgIGlmICh0aGlzLmNhbkVzdGltYXRlKCkpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdzbG93IGVzdGltYXRlOicrIE1hdGgucm91bmQodGhpcy5zbG93Xy5nZXRFc3RpbWF0ZSgpKSk7XG4gICAgICAvLyBjb25zb2xlLmxvZygnZmFzdCBlc3RpbWF0ZTonKyBNYXRoLnJvdW5kKHRoaXMuZmFzdF8uZ2V0RXN0aW1hdGUoKSkpO1xuICAgICAgLy8gVGFrZSB0aGUgbWluaW11bSBvZiB0aGVzZSB0d28gZXN0aW1hdGVzLiAgVGhpcyBzaG91bGQgaGF2ZSB0aGUgZWZmZWN0IG9mXG4gICAgICAvLyBhZGFwdGluZyBkb3duIHF1aWNrbHksIGJ1dCB1cCBtb3JlIHNsb3dseS5cbiAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLmZhc3RfLmdldEVzdGltYXRlKCksIHRoaXMuc2xvd18uZ2V0RXN0aW1hdGUoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRFc3RpbWF0ZV87XG4gICAgfVxuICB9XG4gIGdldEVzdGltYXRlVFRGQigpIHtcbiAgICBpZiAodGhpcy50dGZiXy5nZXRUb3RhbFdlaWdodCgpID49IHRoaXMubWluV2VpZ2h0Xykge1xuICAgICAgcmV0dXJuIHRoaXMudHRmYl8uZ2V0RXN0aW1hdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdFRURkJfO1xuICAgIH1cbiAgfVxuICBnZXQgZGVmYXVsdEVzdGltYXRlKCkge1xuICAgIHJldHVybiB0aGlzLmRlZmF1bHRFc3RpbWF0ZV87XG4gIH1cbiAgZGVzdHJveSgpIHt9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7XG4gIHJldHVybiAociA9IF90b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHtcbiAgICB2YWx1ZTogdCxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSA6IGVbcl0gPSB0LCBlO1xufVxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIHJldHVybiBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uIChuKSB7XG4gICAgZm9yICh2YXIgZSA9IDE7IGUgPCBhcmd1bWVudHMubGVuZ3RoOyBlKyspIHtcbiAgICAgIHZhciB0ID0gYXJndW1lbnRzW2VdO1xuICAgICAgZm9yICh2YXIgciBpbiB0KSAoe30pLmhhc093blByb3BlcnR5LmNhbGwodCwgcikgJiYgKG5bcl0gPSB0W3JdKTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH0sIF9leHRlbmRzLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHtcbiAgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pO1xuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIoZSkge1xuICBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykge1xuICAgIHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTtcbiAgICByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikge1xuICBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgdCB8fCAhdCkgcmV0dXJuIHQ7XG4gIHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAodm9pZCAwICE9PSBlKSB7XG4gICAgdmFyIGkgPSBlLmNhbGwodCwgcik7XG4gICAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIGkpIHJldHVybiBpO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpO1xufVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkge1xuICB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIFwic3ltYm9sXCIgPT0gdHlwZW9mIGkgPyBpIDogaSArIFwiXCI7XG59XG5cbmNsYXNzIExvZ2dlciB7XG4gIGNvbnN0cnVjdG9yKGxhYmVsLCBsb2dnZXIpIHtcbiAgICB0aGlzLnRyYWNlID0gdm9pZCAwO1xuICAgIHRoaXMuZGVidWcgPSB2b2lkIDA7XG4gICAgdGhpcy5sb2cgPSB2b2lkIDA7XG4gICAgdGhpcy53YXJuID0gdm9pZCAwO1xuICAgIHRoaXMuaW5mbyA9IHZvaWQgMDtcbiAgICB0aGlzLmVycm9yID0gdm9pZCAwO1xuICAgIGNvbnN0IGxiID0gYFske2xhYmVsfV06YDtcbiAgICB0aGlzLnRyYWNlID0gbm9vcDtcbiAgICB0aGlzLmRlYnVnID0gbG9nZ2VyLmRlYnVnLmJpbmQobnVsbCwgbGIpO1xuICAgIHRoaXMubG9nID0gbG9nZ2VyLmxvZy5iaW5kKG51bGwsIGxiKTtcbiAgICB0aGlzLndhcm4gPSBsb2dnZXIud2Fybi5iaW5kKG51bGwsIGxiKTtcbiAgICB0aGlzLmluZm8gPSBsb2dnZXIuaW5mby5iaW5kKG51bGwsIGxiKTtcbiAgICB0aGlzLmVycm9yID0gbG9nZ2VyLmVycm9yLmJpbmQobnVsbCwgbGIpO1xuICB9XG59XG5jb25zdCBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuY29uc3QgZmFrZUxvZ2dlciA9IHtcbiAgdHJhY2U6IG5vb3AsXG4gIGRlYnVnOiBub29wLFxuICBsb2c6IG5vb3AsXG4gIHdhcm46IG5vb3AsXG4gIGluZm86IG5vb3AsXG4gIGVycm9yOiBub29wXG59O1xuZnVuY3Rpb24gY3JlYXRlTG9nZ2VyKCkge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIGZha2VMb2dnZXIpO1xufVxuXG4vLyBsZXQgbGFzdENhbGxUaW1lO1xuLy8gZnVuY3Rpb24gZm9ybWF0TXNnV2l0aFRpbWVJbmZvKHR5cGUsIG1zZykge1xuLy8gICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuLy8gICBjb25zdCBkaWZmID0gbGFzdENhbGxUaW1lID8gJysnICsgKG5vdyAtIGxhc3RDYWxsVGltZSkgOiAnMCc7XG4vLyAgIGxhc3RDYWxsVGltZSA9IG5vdztcbi8vICAgbXNnID0gKG5ldyBEYXRlKG5vdykpLnRvSVNPU3RyaW5nKCkgKyAnIHwgWycgKyAgdHlwZSArICddID4gJyArIG1zZyArICcgKCAnICsgZGlmZiArICcgbXMgKSc7XG4vLyAgIHJldHVybiBtc2c7XG4vLyB9XG5cbmZ1bmN0aW9uIGNvbnNvbGVQcmludEZuKHR5cGUsIGlkKSB7XG4gIGNvbnN0IGZ1bmMgPSBzZWxmLmNvbnNvbGVbdHlwZV07XG4gIHJldHVybiBmdW5jID8gZnVuYy5iaW5kKHNlbGYuY29uc29sZSwgYCR7aWQgPyAnWycgKyBpZCArICddICcgOiAnJ31bJHt0eXBlfV0gPmApIDogbm9vcDtcbn1cbmZ1bmN0aW9uIGdldExvZ2dlckZuKGtleSwgZGVidWdDb25maWcsIGlkKSB7XG4gIHJldHVybiBkZWJ1Z0NvbmZpZ1trZXldID8gZGVidWdDb25maWdba2V5XS5iaW5kKGRlYnVnQ29uZmlnKSA6IGNvbnNvbGVQcmludEZuKGtleSwgaWQpO1xufVxuY29uc3QgZXhwb3J0ZWRMb2dnZXIgPSBjcmVhdGVMb2dnZXIoKTtcbmZ1bmN0aW9uIGVuYWJsZUxvZ3MoZGVidWdDb25maWcsIGNvbnRleHQsIGlkKSB7XG4gIC8vIGNoZWNrIHRoYXQgY29uc29sZSBpcyBhdmFpbGFibGVcbiAgY29uc3QgbmV3TG9nZ2VyID0gY3JlYXRlTG9nZ2VyKCk7XG4gIGlmICh0eXBlb2YgY29uc29sZSA9PT0gJ29iamVjdCcgJiYgZGVidWdDb25maWcgPT09IHRydWUgfHwgdHlwZW9mIGRlYnVnQ29uZmlnID09PSAnb2JqZWN0Jykge1xuICAgIGNvbnN0IGtleXMgPSBbXG4gICAgLy8gUmVtb3ZlIG91dCBmcm9tIGxpc3QgaGVyZSB0byBoYXJkLWRpc2FibGUgYSBsb2ctbGV2ZWxcbiAgICAvLyAndHJhY2UnLFxuICAgICdkZWJ1ZycsICdsb2cnLCAnaW5mbycsICd3YXJuJywgJ2Vycm9yJ107XG4gICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBuZXdMb2dnZXJba2V5XSA9IGdldExvZ2dlckZuKGtleSwgZGVidWdDb25maWcsIGlkKTtcbiAgICB9KTtcbiAgICAvLyBTb21lIGJyb3dzZXJzIGRvbid0IGFsbG93IHRvIHVzZSBiaW5kIG9uIGNvbnNvbGUgb2JqZWN0IGFueXdheVxuICAgIC8vIGZhbGxiYWNrIHRvIGRlZmF1bHQgaWYgbmVlZGVkXG4gICAgdHJ5IHtcbiAgICAgIG5ld0xvZ2dlci5sb2coYERlYnVnIGxvZ3MgZW5hYmxlZCBmb3IgXCIke2NvbnRleHR9XCIgaW4gaGxzLmpzIHZlcnNpb24gJHtcIjEuNi43XCJ9YCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLyogbG9nIGZuIHRocmV3IGFuIGV4Y2VwdGlvbi4gQWxsIGxvZ2dlciBtZXRob2RzIGFyZSBuby1vcHMuICovXG4gICAgICByZXR1cm4gY3JlYXRlTG9nZ2VyKCk7XG4gICAgfVxuICAgIC8vIGdsb2JhbCBleHBvcnRlZCBsb2dnZXIgdXNlcyB0aGUgc2FtZSBmdW5jdGlvbnMgYXMgbmV3IGxvZ2dlciB3aXRob3V0IGBpZGBcbiAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGV4cG9ydGVkTG9nZ2VyW2tleV0gPSBnZXRMb2dnZXJGbihrZXksIGRlYnVnQ29uZmlnKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBSZXNldCBnbG9iYWwgZXhwb3J0ZWQgbG9nZ2VyXG4gICAgX2V4dGVuZHMoZXhwb3J0ZWRMb2dnZXIsIG5ld0xvZ2dlcik7XG4gIH1cbiAgcmV0dXJuIG5ld0xvZ2dlcjtcbn1cbmNvbnN0IGxvZ2dlciA9IGV4cG9ydGVkTG9nZ2VyO1xuXG5mdW5jdGlvbiBnZXRNZWRpYVNvdXJjZShwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UgPSB0cnVlKSB7XG4gIGlmICh0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiB1bmRlZmluZWQ7XG4gIGNvbnN0IG1tcyA9IChwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UgfHwgIXNlbGYuTWVkaWFTb3VyY2UpICYmIHNlbGYuTWFuYWdlZE1lZGlhU291cmNlO1xuICByZXR1cm4gbW1zIHx8IHNlbGYuTWVkaWFTb3VyY2UgfHwgc2VsZi5XZWJLaXRNZWRpYVNvdXJjZTtcbn1cbmZ1bmN0aW9uIGlzTWFuYWdlZE1lZGlhU291cmNlKHNvdXJjZSkge1xuICByZXR1cm4gdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNvdXJjZSA9PT0gc2VsZi5NYW5hZ2VkTWVkaWFTb3VyY2U7XG59XG5mdW5jdGlvbiBpc0NvbXBhdGlibGVUcmFja0NoYW5nZShjdXJyZW50VHJhY2tzLCByZXF1aXJlZFRyYWNrcykge1xuICBjb25zdCB0cmFja05hbWVzID0gT2JqZWN0LmtleXMoY3VycmVudFRyYWNrcyk7XG4gIGNvbnN0IHJlcXVpcmVkVHJhY2tOYW1lcyA9IE9iamVjdC5rZXlzKHJlcXVpcmVkVHJhY2tzKTtcbiAgY29uc3QgdHJhY2tDb3VudCA9IHRyYWNrTmFtZXMubGVuZ3RoO1xuICBjb25zdCByZXF1aXJlZFRyYWNrQ291bnQgPSByZXF1aXJlZFRyYWNrTmFtZXMubGVuZ3RoO1xuICByZXR1cm4gIXRyYWNrQ291bnQgfHwgIXJlcXVpcmVkVHJhY2tDb3VudCB8fCB0cmFja0NvdW50ID09PSByZXF1aXJlZFRyYWNrQ291bnQgJiYgIXRyYWNrTmFtZXMuc29tZShuYW1lID0+IHJlcXVpcmVkVHJhY2tOYW1lcy5pbmRleE9mKG5hbWUpID09PSAtMSk7XG59XG5cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODkzNjk4NC91aW50OGFycmF5LXRvLXN0cmluZy1pbi1qYXZhc2NyaXB0LzIyMzczMTk3XG4vLyBodHRwOi8vd3d3Lm9uaWNvcy5jb20vc3RhZmYvaXovYW11c2UvamF2YXNjcmlwdC9leHBlcnQvdXRmLnR4dFxuLyogdXRmLmpzIC0gVVRGLTggPD0+IFVURi0xNiBjb252ZXJ0aW9uXG4gKlxuICogQ29weXJpZ2h0IChDKSAxOTk5IE1hc2FuYW8gSXp1bW8gPGl6QG9uaWNvcy5jby5qcD5cbiAqIFZlcnNpb246IDEuMFxuICogTGFzdE1vZGlmaWVkOiBEZWMgMjUgMTk5OVxuICogVGhpcyBsaWJyYXJ5IGlzIGZyZWUuICBZb3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0LlxuICovXG4vKipcbiAqIENvbnZlcnRzIGEgVVRGLTggYXJyYXkgdG8gYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGFycmF5IC0gVGhlIFVURi04IGFycmF5IHRvIGNvbnZlcnRcbiAqXG4gKiBAcmV0dXJucyBUaGUgc3RyaW5nXG4gKlxuICogQGdyb3VwIFV0aWxzXG4gKlxuICogQGJldGFcbiAqL1xuZnVuY3Rpb24gdXRmOEFycmF5VG9TdHIoYXJyYXksIGV4aXRPbk51bGwgPSBmYWxzZSkge1xuICBpZiAodHlwZW9mIFRleHREZWNvZGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi04Jyk7XG4gICAgY29uc3QgZGVjb2RlZCA9IGRlY29kZXIuZGVjb2RlKGFycmF5KTtcbiAgICBpZiAoZXhpdE9uTnVsbCkge1xuICAgICAgLy8gZ3JhYiB1cCB0byB0aGUgZmlyc3QgbnVsbFxuICAgICAgY29uc3QgaWR4ID0gZGVjb2RlZC5pbmRleE9mKCdcXDAnKTtcbiAgICAgIHJldHVybiBpZHggIT09IC0xID8gZGVjb2RlZC5zdWJzdHJpbmcoMCwgaWR4KSA6IGRlY29kZWQ7XG4gICAgfVxuICAgIC8vIHJlbW92ZSBhbnkgbnVsbCBjaGFyYWN0ZXJzXG4gICAgcmV0dXJuIGRlY29kZWQucmVwbGFjZSgvXFwwL2csICcnKTtcbiAgfVxuICBjb25zdCBsZW4gPSBhcnJheS5sZW5ndGg7XG4gIGxldCBjO1xuICBsZXQgY2hhcjI7XG4gIGxldCBjaGFyMztcbiAgbGV0IG91dCA9ICcnO1xuICBsZXQgaSA9IDA7XG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgYyA9IGFycmF5W2krK107XG4gICAgaWYgKGMgPT09IDB4MDAgJiYgZXhpdE9uTnVsbCkge1xuICAgICAgcmV0dXJuIG91dDtcbiAgICB9IGVsc2UgaWYgKGMgPT09IDB4MDAgfHwgYyA9PT0gMHgwMykge1xuICAgICAgLy8gSWYgdGhlIGNoYXJhY3RlciBpcyAzIChFTkRfT0ZfVEVYVCkgb3IgMCAoTlVMTCkgdGhlbiBza2lwIGl0XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgc3dpdGNoIChjID4+IDQpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgIGNhc2UgMTpcbiAgICAgIGNhc2UgMjpcbiAgICAgIGNhc2UgMzpcbiAgICAgIGNhc2UgNDpcbiAgICAgIGNhc2UgNTpcbiAgICAgIGNhc2UgNjpcbiAgICAgIGNhc2UgNzpcbiAgICAgICAgLy8gMHh4eHh4eHhcbiAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjpcbiAgICAgIGNhc2UgMTM6XG4gICAgICAgIC8vIDExMHggeHh4eCAgIDEweHggeHh4eFxuICAgICAgICBjaGFyMiA9IGFycmF5W2krK107XG4gICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgMHgxZikgPDwgNiB8IGNoYXIyICYgMHgzZik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxNDpcbiAgICAgICAgLy8gMTExMCB4eHh4ICAxMHh4IHh4eHggIDEweHggeHh4eFxuICAgICAgICBjaGFyMiA9IGFycmF5W2krK107XG4gICAgICAgIGNoYXIzID0gYXJyYXlbaSsrXTtcbiAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgJiAweDBmKSA8PCAxMiB8IChjaGFyMiAmIDB4M2YpIDw8IDYgfCAoY2hhcjMgJiAweDNmKSA8PCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogIGhleCBkdW1wIGhlbHBlciBjbGFzc1xuICovXG5cbmNvbnN0IEhleCA9IHtcbiAgaGV4RHVtcDogZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBoID0gYXJyYXlbaV0udG9TdHJpbmcoMTYpO1xuICAgICAgaWYgKGgubGVuZ3RoIDwgMikge1xuICAgICAgICBoID0gJzAnICsgaDtcbiAgICAgIH1cbiAgICAgIHN0ciArPSBoO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9XG59O1xuZnVuY3Rpb24gaGV4VG9BcnJheUJ1ZmZlcihzdHIpIHtcbiAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShzdHIucmVwbGFjZSgvXjB4LywgJycpLnJlcGxhY2UoLyhbXFxkYS1mQS1GXXsyfSkgPy9nLCAnMHgkMSAnKS5yZXBsYWNlKC8gKyQvLCAnJykuc3BsaXQoJyAnKSkuYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyAoeCkge1xuXHRyZXR1cm4geCAmJiB4Ll9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdkZWZhdWx0JykgPyB4WydkZWZhdWx0J10gOiB4O1xufVxuXG52YXIgdXJsVG9vbGtpdCA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBoYXNSZXF1aXJlZFVybFRvb2xraXQ7XG5cbmZ1bmN0aW9uIHJlcXVpcmVVcmxUb29sa2l0ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkVXJsVG9vbGtpdCkgcmV0dXJuIHVybFRvb2xraXQuZXhwb3J0cztcblx0aGFzUmVxdWlyZWRVcmxUb29sa2l0ID0gMTtcblx0KGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XHQvLyBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzE4MDhcblxuXHRcdChmdW5jdGlvbiAocm9vdCkge1xuXHRcdCAgdmFyIFVSTF9SRUdFWCA9XG5cdFx0ICAgIC9eKD89KCg/OlthLXpBLVowLTkrXFwtLl0rOik/KSlcXDEoPz0oKD86XFwvXFwvW15cXC8/I10qKT8pKVxcMig/PSgoPzooPzpbXj8jXFwvXSpcXC8pKlteOz8jXFwvXSopPykpXFwzKCg/OjtbXj8jXSopPykoXFw/W14jXSopPygjW15dKik/JC87XG5cdFx0ICB2YXIgRklSU1RfU0VHTUVOVF9SRUdFWCA9IC9eKD89KFteXFwvPyNdKikpXFwxKFteXSopJC87XG5cdFx0ICB2YXIgU0xBU0hfRE9UX1JFR0VYID0gLyg/OlxcL3xeKVxcLig/PVxcLykvZztcblx0XHQgIHZhciBTTEFTSF9ET1RfRE9UX1JFR0VYID0gLyg/OlxcL3xeKVxcLlxcLlxcLyg/IVxcLlxcLlxcLylbXlxcL10qKD89XFwvKS9nO1xuXG5cdFx0ICB2YXIgVVJMVG9vbGtpdCA9IHtcblx0XHQgICAgLy8gSWYgb3B0cy5hbHdheXNOb3JtYWxpemUgaXMgdHJ1ZSB0aGVuIHRoZSBwYXRoIHdpbGwgYWx3YXlzIGJlIG5vcm1hbGl6ZWQgZXZlbiB3aGVuIGl0IHN0YXJ0cyB3aXRoIC8gb3IgLy9cblx0XHQgICAgLy8gRS5nXG5cdFx0ICAgIC8vIFdpdGggb3B0cy5hbHdheXNOb3JtYWxpemUgPSBmYWxzZSAoZGVmYXVsdCwgc3BlYyBjb21wbGlhbnQpXG5cdFx0ICAgIC8vIGh0dHA6Ly9hLmNvbS9iL2NkICsgL2UvZi8uLi9nID0+IGh0dHA6Ly9hLmNvbS9lL2YvLi4vZ1xuXHRcdCAgICAvLyBXaXRoIG9wdHMuYWx3YXlzTm9ybWFsaXplID0gdHJ1ZSAobm90IHNwZWMgY29tcGxpYW50KVxuXHRcdCAgICAvLyBodHRwOi8vYS5jb20vYi9jZCArIC9lL2YvLi4vZyA9PiBodHRwOi8vYS5jb20vZS9nXG5cdFx0ICAgIGJ1aWxkQWJzb2x1dGVVUkw6IGZ1bmN0aW9uIChiYXNlVVJMLCByZWxhdGl2ZVVSTCwgb3B0cykge1xuXHRcdCAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXHRcdCAgICAgIC8vIHJlbW92ZSBhbnkgcmVtYWluaW5nIHNwYWNlIGFuZCBDUkxGXG5cdFx0ICAgICAgYmFzZVVSTCA9IGJhc2VVUkwudHJpbSgpO1xuXHRcdCAgICAgIHJlbGF0aXZlVVJMID0gcmVsYXRpdmVVUkwudHJpbSgpO1xuXHRcdCAgICAgIGlmICghcmVsYXRpdmVVUkwpIHtcblx0XHQgICAgICAgIC8vIDJhKSBJZiB0aGUgZW1iZWRkZWQgVVJMIGlzIGVudGlyZWx5IGVtcHR5LCBpdCBpbmhlcml0cyB0aGVcblx0XHQgICAgICAgIC8vIGVudGlyZSBiYXNlIFVSTCAoaS5lLiwgaXMgc2V0IGVxdWFsIHRvIHRoZSBiYXNlIFVSTClcblx0XHQgICAgICAgIC8vIGFuZCB3ZSBhcmUgZG9uZS5cblx0XHQgICAgICAgIGlmICghb3B0cy5hbHdheXNOb3JtYWxpemUpIHtcblx0XHQgICAgICAgICAgcmV0dXJuIGJhc2VVUkw7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICB2YXIgYmFzZVBhcnRzRm9yTm9ybWFsaXNlID0gVVJMVG9vbGtpdC5wYXJzZVVSTChiYXNlVVJMKTtcblx0XHQgICAgICAgIGlmICghYmFzZVBhcnRzRm9yTm9ybWFsaXNlKSB7XG5cdFx0ICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgdHJ5aW5nIHRvIHBhcnNlIGJhc2UgVVJMLicpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgYmFzZVBhcnRzRm9yTm9ybWFsaXNlLnBhdGggPSBVUkxUb29sa2l0Lm5vcm1hbGl6ZVBhdGgoXG5cdFx0ICAgICAgICAgIGJhc2VQYXJ0c0Zvck5vcm1hbGlzZS5wYXRoXG5cdFx0ICAgICAgICApO1xuXHRcdCAgICAgICAgcmV0dXJuIFVSTFRvb2xraXQuYnVpbGRVUkxGcm9tUGFydHMoYmFzZVBhcnRzRm9yTm9ybWFsaXNlKTtcblx0XHQgICAgICB9XG5cdFx0ICAgICAgdmFyIHJlbGF0aXZlUGFydHMgPSBVUkxUb29sa2l0LnBhcnNlVVJMKHJlbGF0aXZlVVJMKTtcblx0XHQgICAgICBpZiAoIXJlbGF0aXZlUGFydHMpIHtcblx0XHQgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgdHJ5aW5nIHRvIHBhcnNlIHJlbGF0aXZlIFVSTC4nKTtcblx0XHQgICAgICB9XG5cdFx0ICAgICAgaWYgKHJlbGF0aXZlUGFydHMuc2NoZW1lKSB7XG5cdFx0ICAgICAgICAvLyAyYikgSWYgdGhlIGVtYmVkZGVkIFVSTCBzdGFydHMgd2l0aCBhIHNjaGVtZSBuYW1lLCBpdCBpc1xuXHRcdCAgICAgICAgLy8gaW50ZXJwcmV0ZWQgYXMgYW4gYWJzb2x1dGUgVVJMIGFuZCB3ZSBhcmUgZG9uZS5cblx0XHQgICAgICAgIGlmICghb3B0cy5hbHdheXNOb3JtYWxpemUpIHtcblx0XHQgICAgICAgICAgcmV0dXJuIHJlbGF0aXZlVVJMO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmVsYXRpdmVQYXJ0cy5wYXRoID0gVVJMVG9vbGtpdC5ub3JtYWxpemVQYXRoKHJlbGF0aXZlUGFydHMucGF0aCk7XG5cdFx0ICAgICAgICByZXR1cm4gVVJMVG9vbGtpdC5idWlsZFVSTEZyb21QYXJ0cyhyZWxhdGl2ZVBhcnRzKTtcblx0XHQgICAgICB9XG5cdFx0ICAgICAgdmFyIGJhc2VQYXJ0cyA9IFVSTFRvb2xraXQucGFyc2VVUkwoYmFzZVVSTCk7XG5cdFx0ICAgICAgaWYgKCFiYXNlUGFydHMpIHtcblx0XHQgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgdHJ5aW5nIHRvIHBhcnNlIGJhc2UgVVJMLicpO1xuXHRcdCAgICAgIH1cblx0XHQgICAgICBpZiAoIWJhc2VQYXJ0cy5uZXRMb2MgJiYgYmFzZVBhcnRzLnBhdGggJiYgYmFzZVBhcnRzLnBhdGhbMF0gIT09ICcvJykge1xuXHRcdCAgICAgICAgLy8gSWYgbmV0TG9jIG1pc3NpbmcgYW5kIHBhdGggZG9lc24ndCBzdGFydCB3aXRoICcvJywgYXNzdW1lIGV2ZXJ0aGluZyBiZWZvcmUgdGhlIGZpcnN0ICcvJyBpcyB0aGUgbmV0TG9jXG5cdFx0ICAgICAgICAvLyBUaGlzIGNhdXNlcyAnZXhhbXBsZS5jb20vYScgdG8gYmUgaGFuZGxlZCBhcyAnLy9leGFtcGxlLmNvbS9hJyBpbnN0ZWFkIG9mICcvZXhhbXBsZS5jb20vYSdcblx0XHQgICAgICAgIHZhciBwYXRoUGFydHMgPSBGSVJTVF9TRUdNRU5UX1JFR0VYLmV4ZWMoYmFzZVBhcnRzLnBhdGgpO1xuXHRcdCAgICAgICAgYmFzZVBhcnRzLm5ldExvYyA9IHBhdGhQYXJ0c1sxXTtcblx0XHQgICAgICAgIGJhc2VQYXJ0cy5wYXRoID0gcGF0aFBhcnRzWzJdO1xuXHRcdCAgICAgIH1cblx0XHQgICAgICBpZiAoYmFzZVBhcnRzLm5ldExvYyAmJiAhYmFzZVBhcnRzLnBhdGgpIHtcblx0XHQgICAgICAgIGJhc2VQYXJ0cy5wYXRoID0gJy8nO1xuXHRcdCAgICAgIH1cblx0XHQgICAgICB2YXIgYnVpbHRQYXJ0cyA9IHtcblx0XHQgICAgICAgIC8vIDJjKSBPdGhlcndpc2UsIHRoZSBlbWJlZGRlZCBVUkwgaW5oZXJpdHMgdGhlIHNjaGVtZSBvZlxuXHRcdCAgICAgICAgLy8gdGhlIGJhc2UgVVJMLlxuXHRcdCAgICAgICAgc2NoZW1lOiBiYXNlUGFydHMuc2NoZW1lLFxuXHRcdCAgICAgICAgbmV0TG9jOiByZWxhdGl2ZVBhcnRzLm5ldExvYyxcblx0XHQgICAgICAgIHBhdGg6IG51bGwsXG5cdFx0ICAgICAgICBwYXJhbXM6IHJlbGF0aXZlUGFydHMucGFyYW1zLFxuXHRcdCAgICAgICAgcXVlcnk6IHJlbGF0aXZlUGFydHMucXVlcnksXG5cdFx0ICAgICAgICBmcmFnbWVudDogcmVsYXRpdmVQYXJ0cy5mcmFnbWVudCxcblx0XHQgICAgICB9O1xuXHRcdCAgICAgIGlmICghcmVsYXRpdmVQYXJ0cy5uZXRMb2MpIHtcblx0XHQgICAgICAgIC8vIDMpIElmIHRoZSBlbWJlZGRlZCBVUkwncyA8bmV0X2xvYz4gaXMgbm9uLWVtcHR5LCB3ZSBza2lwIHRvXG5cdFx0ICAgICAgICAvLyBTdGVwIDcuICBPdGhlcndpc2UsIHRoZSBlbWJlZGRlZCBVUkwgaW5oZXJpdHMgdGhlIDxuZXRfbG9jPlxuXHRcdCAgICAgICAgLy8gKGlmIGFueSkgb2YgdGhlIGJhc2UgVVJMLlxuXHRcdCAgICAgICAgYnVpbHRQYXJ0cy5uZXRMb2MgPSBiYXNlUGFydHMubmV0TG9jO1xuXHRcdCAgICAgICAgLy8gNCkgSWYgdGhlIGVtYmVkZGVkIFVSTCBwYXRoIGlzIHByZWNlZGVkIGJ5IGEgc2xhc2ggXCIvXCIsIHRoZVxuXHRcdCAgICAgICAgLy8gcGF0aCBpcyBub3QgcmVsYXRpdmUgYW5kIHdlIHNraXAgdG8gU3RlcCA3LlxuXHRcdCAgICAgICAgaWYgKHJlbGF0aXZlUGFydHMucGF0aFswXSAhPT0gJy8nKSB7XG5cdFx0ICAgICAgICAgIGlmICghcmVsYXRpdmVQYXJ0cy5wYXRoKSB7XG5cdFx0ICAgICAgICAgICAgLy8gNSkgSWYgdGhlIGVtYmVkZGVkIFVSTCBwYXRoIGlzIGVtcHR5IChhbmQgbm90IHByZWNlZGVkIGJ5IGFcblx0XHQgICAgICAgICAgICAvLyBzbGFzaCksIHRoZW4gdGhlIGVtYmVkZGVkIFVSTCBpbmhlcml0cyB0aGUgYmFzZSBVUkwgcGF0aFxuXHRcdCAgICAgICAgICAgIGJ1aWx0UGFydHMucGF0aCA9IGJhc2VQYXJ0cy5wYXRoO1xuXHRcdCAgICAgICAgICAgIC8vIDVhKSBpZiB0aGUgZW1iZWRkZWQgVVJMJ3MgPHBhcmFtcz4gaXMgbm9uLWVtcHR5LCB3ZSBza2lwIHRvXG5cdFx0ICAgICAgICAgICAgLy8gc3RlcCA3OyBvdGhlcndpc2UsIGl0IGluaGVyaXRzIHRoZSA8cGFyYW1zPiBvZiB0aGUgYmFzZVxuXHRcdCAgICAgICAgICAgIC8vIFVSTCAoaWYgYW55KSBhbmRcblx0XHQgICAgICAgICAgICBpZiAoIXJlbGF0aXZlUGFydHMucGFyYW1zKSB7XG5cdFx0ICAgICAgICAgICAgICBidWlsdFBhcnRzLnBhcmFtcyA9IGJhc2VQYXJ0cy5wYXJhbXM7XG5cdFx0ICAgICAgICAgICAgICAvLyA1YikgaWYgdGhlIGVtYmVkZGVkIFVSTCdzIDxxdWVyeT4gaXMgbm9uLWVtcHR5LCB3ZSBza2lwIHRvXG5cdFx0ICAgICAgICAgICAgICAvLyBzdGVwIDc7IG90aGVyd2lzZSwgaXQgaW5oZXJpdHMgdGhlIDxxdWVyeT4gb2YgdGhlIGJhc2Vcblx0XHQgICAgICAgICAgICAgIC8vIFVSTCAoaWYgYW55KSBhbmQgd2Ugc2tpcCB0byBzdGVwIDcuXG5cdFx0ICAgICAgICAgICAgICBpZiAoIXJlbGF0aXZlUGFydHMucXVlcnkpIHtcblx0XHQgICAgICAgICAgICAgICAgYnVpbHRQYXJ0cy5xdWVyeSA9IGJhc2VQYXJ0cy5xdWVyeTtcblx0XHQgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgIH0gZWxzZSB7XG5cdFx0ICAgICAgICAgICAgLy8gNikgVGhlIGxhc3Qgc2VnbWVudCBvZiB0aGUgYmFzZSBVUkwncyBwYXRoIChhbnl0aGluZ1xuXHRcdCAgICAgICAgICAgIC8vIGZvbGxvd2luZyB0aGUgcmlnaHRtb3N0IHNsYXNoIFwiL1wiLCBvciB0aGUgZW50aXJlIHBhdGggaWYgbm9cblx0XHQgICAgICAgICAgICAvLyBzbGFzaCBpcyBwcmVzZW50KSBpcyByZW1vdmVkIGFuZCB0aGUgZW1iZWRkZWQgVVJMJ3MgcGF0aCBpc1xuXHRcdCAgICAgICAgICAgIC8vIGFwcGVuZGVkIGluIGl0cyBwbGFjZS5cblx0XHQgICAgICAgICAgICB2YXIgYmFzZVVSTFBhdGggPSBiYXNlUGFydHMucGF0aDtcblx0XHQgICAgICAgICAgICB2YXIgbmV3UGF0aCA9XG5cdFx0ICAgICAgICAgICAgICBiYXNlVVJMUGF0aC5zdWJzdHJpbmcoMCwgYmFzZVVSTFBhdGgubGFzdEluZGV4T2YoJy8nKSArIDEpICtcblx0XHQgICAgICAgICAgICAgIHJlbGF0aXZlUGFydHMucGF0aDtcblx0XHQgICAgICAgICAgICBidWlsdFBhcnRzLnBhdGggPSBVUkxUb29sa2l0Lm5vcm1hbGl6ZVBhdGgobmV3UGF0aCk7XG5cdFx0ICAgICAgICAgIH1cblx0XHQgICAgICAgIH1cblx0XHQgICAgICB9XG5cdFx0ICAgICAgaWYgKGJ1aWx0UGFydHMucGF0aCA9PT0gbnVsbCkge1xuXHRcdCAgICAgICAgYnVpbHRQYXJ0cy5wYXRoID0gb3B0cy5hbHdheXNOb3JtYWxpemVcblx0XHQgICAgICAgICAgPyBVUkxUb29sa2l0Lm5vcm1hbGl6ZVBhdGgocmVsYXRpdmVQYXJ0cy5wYXRoKVxuXHRcdCAgICAgICAgICA6IHJlbGF0aXZlUGFydHMucGF0aDtcblx0XHQgICAgICB9XG5cdFx0ICAgICAgcmV0dXJuIFVSTFRvb2xraXQuYnVpbGRVUkxGcm9tUGFydHMoYnVpbHRQYXJ0cyk7XG5cdFx0ICAgIH0sXG5cdFx0ICAgIHBhcnNlVVJMOiBmdW5jdGlvbiAodXJsKSB7XG5cdFx0ICAgICAgdmFyIHBhcnRzID0gVVJMX1JFR0VYLmV4ZWModXJsKTtcblx0XHQgICAgICBpZiAoIXBhcnRzKSB7XG5cdFx0ICAgICAgICByZXR1cm4gbnVsbDtcblx0XHQgICAgICB9XG5cdFx0ICAgICAgcmV0dXJuIHtcblx0XHQgICAgICAgIHNjaGVtZTogcGFydHNbMV0gfHwgJycsXG5cdFx0ICAgICAgICBuZXRMb2M6IHBhcnRzWzJdIHx8ICcnLFxuXHRcdCAgICAgICAgcGF0aDogcGFydHNbM10gfHwgJycsXG5cdFx0ICAgICAgICBwYXJhbXM6IHBhcnRzWzRdIHx8ICcnLFxuXHRcdCAgICAgICAgcXVlcnk6IHBhcnRzWzVdIHx8ICcnLFxuXHRcdCAgICAgICAgZnJhZ21lbnQ6IHBhcnRzWzZdIHx8ICcnLFxuXHRcdCAgICAgIH07XG5cdFx0ICAgIH0sXG5cdFx0ICAgIG5vcm1hbGl6ZVBhdGg6IGZ1bmN0aW9uIChwYXRoKSB7XG5cdFx0ICAgICAgLy8gVGhlIGZvbGxvd2luZyBvcGVyYXRpb25zIGFyZVxuXHRcdCAgICAgIC8vIHRoZW4gYXBwbGllZCwgaW4gb3JkZXIsIHRvIHRoZSBuZXcgcGF0aDpcblx0XHQgICAgICAvLyA2YSkgQWxsIG9jY3VycmVuY2VzIG9mIFwiLi9cIiwgd2hlcmUgXCIuXCIgaXMgYSBjb21wbGV0ZSBwYXRoXG5cdFx0ICAgICAgLy8gc2VnbWVudCwgYXJlIHJlbW92ZWQuXG5cdFx0ICAgICAgLy8gNmIpIElmIHRoZSBwYXRoIGVuZHMgd2l0aCBcIi5cIiBhcyBhIGNvbXBsZXRlIHBhdGggc2VnbWVudCxcblx0XHQgICAgICAvLyB0aGF0IFwiLlwiIGlzIHJlbW92ZWQuXG5cdFx0ICAgICAgcGF0aCA9IHBhdGguc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKS5yZXBsYWNlKFNMQVNIX0RPVF9SRUdFWCwgJycpO1xuXHRcdCAgICAgIC8vIDZjKSBBbGwgb2NjdXJyZW5jZXMgb2YgXCI8c2VnbWVudD4vLi4vXCIsIHdoZXJlIDxzZWdtZW50PiBpcyBhXG5cdFx0ICAgICAgLy8gY29tcGxldGUgcGF0aCBzZWdtZW50IG5vdCBlcXVhbCB0byBcIi4uXCIsIGFyZSByZW1vdmVkLlxuXHRcdCAgICAgIC8vIFJlbW92YWwgb2YgdGhlc2UgcGF0aCBzZWdtZW50cyBpcyBwZXJmb3JtZWQgaXRlcmF0aXZlbHksXG5cdFx0ICAgICAgLy8gcmVtb3ZpbmcgdGhlIGxlZnRtb3N0IG1hdGNoaW5nIHBhdHRlcm4gb24gZWFjaCBpdGVyYXRpb24sXG5cdFx0ICAgICAgLy8gdW50aWwgbm8gbWF0Y2hpbmcgcGF0dGVybiByZW1haW5zLlxuXHRcdCAgICAgIC8vIDZkKSBJZiB0aGUgcGF0aCBlbmRzIHdpdGggXCI8c2VnbWVudD4vLi5cIiwgd2hlcmUgPHNlZ21lbnQ+IGlzIGFcblx0XHQgICAgICAvLyBjb21wbGV0ZSBwYXRoIHNlZ21lbnQgbm90IGVxdWFsIHRvIFwiLi5cIiwgdGhhdFxuXHRcdCAgICAgIC8vIFwiPHNlZ21lbnQ+Ly4uXCIgaXMgcmVtb3ZlZC5cblx0XHQgICAgICB3aGlsZSAoXG5cdFx0ICAgICAgICBwYXRoLmxlbmd0aCAhPT0gKHBhdGggPSBwYXRoLnJlcGxhY2UoU0xBU0hfRE9UX0RPVF9SRUdFWCwgJycpKS5sZW5ndGhcblx0XHQgICAgICApIHt9XG5cdFx0ICAgICAgcmV0dXJuIHBhdGguc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKTtcblx0XHQgICAgfSxcblx0XHQgICAgYnVpbGRVUkxGcm9tUGFydHM6IGZ1bmN0aW9uIChwYXJ0cykge1xuXHRcdCAgICAgIHJldHVybiAoXG5cdFx0ICAgICAgICBwYXJ0cy5zY2hlbWUgK1xuXHRcdCAgICAgICAgcGFydHMubmV0TG9jICtcblx0XHQgICAgICAgIHBhcnRzLnBhdGggK1xuXHRcdCAgICAgICAgcGFydHMucGFyYW1zICtcblx0XHQgICAgICAgIHBhcnRzLnF1ZXJ5ICtcblx0XHQgICAgICAgIHBhcnRzLmZyYWdtZW50XG5cdFx0ICAgICAgKTtcblx0XHQgICAgfSxcblx0XHQgIH07XG5cblx0XHQgIG1vZHVsZS5leHBvcnRzID0gVVJMVG9vbGtpdDtcblx0XHR9KSgpOyBcblx0fSAodXJsVG9vbGtpdCkpO1xuXHRyZXR1cm4gdXJsVG9vbGtpdC5leHBvcnRzO1xufVxuXG52YXIgdXJsVG9vbGtpdEV4cG9ydHMgPSByZXF1aXJlVXJsVG9vbGtpdCgpO1xuXG5jbGFzcyBMb2FkU3RhdHMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmFib3J0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmxvYWRlZCA9IDA7XG4gICAgdGhpcy5yZXRyeSA9IDA7XG4gICAgdGhpcy50b3RhbCA9IDA7XG4gICAgdGhpcy5jaHVua0NvdW50ID0gMDtcbiAgICB0aGlzLmJ3RXN0aW1hdGUgPSAwO1xuICAgIHRoaXMubG9hZGluZyA9IHtcbiAgICAgIHN0YXJ0OiAwLFxuICAgICAgZmlyc3Q6IDAsXG4gICAgICBlbmQ6IDBcbiAgICB9O1xuICAgIHRoaXMucGFyc2luZyA9IHtcbiAgICAgIHN0YXJ0OiAwLFxuICAgICAgZW5kOiAwXG4gICAgfTtcbiAgICB0aGlzLmJ1ZmZlcmluZyA9IHtcbiAgICAgIHN0YXJ0OiAwLFxuICAgICAgZmlyc3Q6IDAsXG4gICAgICBlbmQ6IDBcbiAgICB9O1xuICB9XG59XG5cbnZhciBFbGVtZW50YXJ5U3RyZWFtVHlwZXMgPSB7XG4gIEFVRElPOiBcImF1ZGlvXCIsXG4gIFZJREVPOiBcInZpZGVvXCIsXG4gIEFVRElPVklERU86IFwiYXVkaW92aWRlb1wiXG59O1xuY2xhc3MgQmFzZVNlZ21lbnQge1xuICBjb25zdHJ1Y3RvcihiYXNlKSB7XG4gICAgdGhpcy5fYnl0ZVJhbmdlID0gbnVsbDtcbiAgICB0aGlzLl91cmwgPSBudWxsO1xuICAgIHRoaXMuX3N0YXRzID0gbnVsbDtcbiAgICB0aGlzLl9zdHJlYW1zID0gbnVsbDtcbiAgICAvLyBiYXNldXJsIGlzIHRoZSBVUkwgdG8gdGhlIHBsYXlsaXN0XG4gICAgdGhpcy5iYXNlID0gdm9pZCAwO1xuICAgIC8vIHJlbHVybCBpcyB0aGUgcG9ydGlvbiBvZiB0aGUgVVJMIHRoYXQgY29tZXMgZnJvbSBpbnNpZGUgdGhlIHBsYXlsaXN0LlxuICAgIHRoaXMucmVsdXJsID0gdm9pZCAwO1xuICAgIGlmICh0eXBlb2YgYmFzZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJhc2UgPSB7XG4gICAgICAgIHVybDogYmFzZVxuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5iYXNlID0gYmFzZTtcbiAgICBtYWtlRW51bWVyYWJsZSh0aGlzLCAnc3RhdHMnKTtcbiAgfVxuXG4gIC8vIHNldEJ5dGVSYW5nZSBjb252ZXJ0cyBhIEVYVC1YLUJZVEVSQU5HRSBhdHRyaWJ1dGUgaW50byBhIHR3byBlbGVtZW50IGFycmF5XG4gIHNldEJ5dGVSYW5nZSh2YWx1ZSwgcHJldmlvdXMpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB2YWx1ZS5zcGxpdCgnQCcsIDIpO1xuICAgIGxldCBzdGFydDtcbiAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgc3RhcnQgPSAocHJldmlvdXMgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZpb3VzLmJ5dGVSYW5nZUVuZE9mZnNldCkgfHwgMDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnQgPSBwYXJzZUludChwYXJhbXNbMV0pO1xuICAgIH1cbiAgICB0aGlzLl9ieXRlUmFuZ2UgPSBbc3RhcnQsIHBhcnNlSW50KHBhcmFtc1swXSkgKyBzdGFydF07XG4gIH1cbiAgZ2V0IGJhc2V1cmwoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFzZS51cmw7XG4gIH1cbiAgZ2V0IGJ5dGVSYW5nZSgpIHtcbiAgICBpZiAodGhpcy5fYnl0ZVJhbmdlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9ieXRlUmFuZ2U7XG4gIH1cbiAgZ2V0IGJ5dGVSYW5nZVN0YXJ0T2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLmJ5dGVSYW5nZVswXTtcbiAgfVxuICBnZXQgYnl0ZVJhbmdlRW5kT2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLmJ5dGVSYW5nZVsxXTtcbiAgfVxuICBnZXQgZWxlbWVudGFyeVN0cmVhbXMoKSB7XG4gICAgaWYgKHRoaXMuX3N0cmVhbXMgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3N0cmVhbXMgPSB7XG4gICAgICAgIFtFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU9dOiBudWxsLFxuICAgICAgICBbRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPXTogbnVsbCxcbiAgICAgICAgW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJT1ZJREVPXTogbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3N0cmVhbXM7XG4gIH1cbiAgc2V0IGVsZW1lbnRhcnlTdHJlYW1zKHZhbHVlKSB7XG4gICAgdGhpcy5fc3RyZWFtcyA9IHZhbHVlO1xuICB9XG4gIGdldCBoYXNTdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdHMgIT09IG51bGw7XG4gIH1cbiAgZ2V0IGhhc1N0cmVhbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cmVhbXMgIT09IG51bGw7XG4gIH1cbiAgZ2V0IHN0YXRzKCkge1xuICAgIGlmICh0aGlzLl9zdGF0cyA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fc3RhdHMgPSBuZXcgTG9hZFN0YXRzKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zdGF0cztcbiAgfVxuICBzZXQgc3RhdHModmFsdWUpIHtcbiAgICB0aGlzLl9zdGF0cyA9IHZhbHVlO1xuICB9XG4gIGdldCB1cmwoKSB7XG4gICAgaWYgKCF0aGlzLl91cmwgJiYgdGhpcy5iYXNldXJsICYmIHRoaXMucmVsdXJsKSB7XG4gICAgICB0aGlzLl91cmwgPSB1cmxUb29sa2l0RXhwb3J0cy5idWlsZEFic29sdXRlVVJMKHRoaXMuYmFzZXVybCwgdGhpcy5yZWx1cmwsIHtcbiAgICAgICAgYWx3YXlzTm9ybWFsaXplOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3VybCB8fCAnJztcbiAgfVxuICBzZXQgdXJsKHZhbHVlKSB7XG4gICAgdGhpcy5fdXJsID0gdmFsdWU7XG4gIH1cbiAgY2xlYXJFbGVtZW50YXJ5U3RyZWFtSW5mbygpIHtcbiAgICBjb25zdCB7XG4gICAgICBlbGVtZW50YXJ5U3RyZWFtc1xuICAgIH0gPSB0aGlzO1xuICAgIGVsZW1lbnRhcnlTdHJlYW1zW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJT10gPSBudWxsO1xuICAgIGVsZW1lbnRhcnlTdHJlYW1zW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFT10gPSBudWxsO1xuICAgIGVsZW1lbnRhcnlTdHJlYW1zW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJT1ZJREVPXSA9IG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzTWVkaWFGcmFnbWVudChmcmFnKSB7XG4gIHJldHVybiBmcmFnLnNuICE9PSAnaW5pdFNlZ21lbnQnO1xufVxuXG4vKipcbiAqIE9iamVjdCByZXByZXNlbnRpbmcgcGFyc2VkIGRhdGEgZnJvbSBhbiBITFMgU2VnbWVudC4gRm91bmQgaW4ge0BsaW5rIGhscy5qcyNMZXZlbERldGFpbHMuZnJhZ21lbnRzfS5cbiAqL1xuY2xhc3MgRnJhZ21lbnQgZXh0ZW5kcyBCYXNlU2VnbWVudCB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIGJhc2UpIHtcbiAgICBzdXBlcihiYXNlKTtcbiAgICB0aGlzLl9kZWNyeXB0ZGF0YSA9IG51bGw7XG4gICAgdGhpcy5fcHJvZ3JhbURhdGVUaW1lID0gbnVsbDtcbiAgICB0aGlzLl9yZWYgPSBudWxsO1xuICAgIC8vIEFwcHJveGltYXRlIGJpdCByYXRlIG9mIHRoZSBmcmFnbWVudCBleHByZXNzZWQgaW4gYml0cyBwZXIgc2Vjb25kIChicHMpIGFzIGluZGljYXRlZCBieSB0aGUgbGFzdCBFWFQtWC1CSVRSQVRFIChrYnBzKSB0YWdcbiAgICB0aGlzLl9iaXRyYXRlID0gdm9pZCAwO1xuICAgIHRoaXMucmF3UHJvZ3JhbURhdGVUaW1lID0gbnVsbDtcbiAgICB0aGlzLnRhZ0xpc3QgPSBbXTtcbiAgICAvLyBFWFRJTkYgaGFzIHRvIGJlIHByZXNlbnQgZm9yIGEgbTN1OCB0byBiZSBjb25zaWRlcmVkIHZhbGlkXG4gICAgdGhpcy5kdXJhdGlvbiA9IDA7XG4gICAgLy8gc24gbm90YXRlcyB0aGUgc2VxdWVuY2UgbnVtYmVyIGZvciBhIHNlZ21lbnQsIGFuZCBpZiBzZXQgdG8gYSBzdHJpbmcgY2FuIGJlICdpbml0U2VnbWVudCdcbiAgICB0aGlzLnNuID0gMDtcbiAgICAvLyBsZXZlbGtleXMgYXJlIHRoZSBFWFQtWC1LRVkgdGFncyB0aGF0IGFwcGx5IHRvIHRoaXMgc2VnbWVudCBmb3IgZGVjcnlwdGlvblxuICAgIC8vIGNvcmUgZGlmZmVyZW5jZSBmcm9tIHRoZSBwcml2YXRlIGZpZWxkIF9kZWNyeXB0ZGF0YSBpcyB0aGUgbGFjayBvZiB0aGUgaW5pdGlhbGl6ZWQgSVZcbiAgICAvLyBfZGVjcnlwdGRhdGEgd2lsbCBzZXQgdGhlIElWIGZvciB0aGlzIHNlZ21lbnQgYmFzZWQgb24gdGhlIHNlZ21lbnQgbnVtYmVyIGluIHRoZSBmcmFnbWVudFxuICAgIHRoaXMubGV2ZWxrZXlzID0gdm9pZCAwO1xuICAgIC8vIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZnJhZ21lbnQgdHlwZVxuICAgIHRoaXMudHlwZSA9IHZvaWQgMDtcbiAgICAvLyBBIHJlZmVyZW5jZSB0byB0aGUgbG9hZGVyLiBTZXQgd2hpbGUgdGhlIGZyYWdtZW50IGlzIGxvYWRpbmcsIGFuZCByZW1vdmVkIGFmdGVyd2FyZHMuIFVzZWQgdG8gYWJvcnQgZnJhZ21lbnQgbG9hZGluZ1xuICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgICAvLyBBIHJlZmVyZW5jZSB0byB0aGUga2V5IGxvYWRlci4gU2V0IHdoaWxlIHRoZSBrZXkgaXMgbG9hZGluZywgYW5kIHJlbW92ZWQgYWZ0ZXJ3YXJkcy4gVXNlZCB0byBhYm9ydCBrZXkgbG9hZGluZ1xuICAgIHRoaXMua2V5TG9hZGVyID0gbnVsbDtcbiAgICAvLyBUaGUgbGV2ZWwvdHJhY2sgaW5kZXggdG8gd2hpY2ggdGhlIGZyYWdtZW50IGJlbG9uZ3NcbiAgICB0aGlzLmxldmVsID0gLTE7XG4gICAgLy8gVGhlIGNvbnRpbnVpdHkgY291bnRlciBvZiB0aGUgZnJhZ21lbnRcbiAgICB0aGlzLmNjID0gMDtcbiAgICAvLyBUaGUgc3RhcnRpbmcgUHJlc2VudGF0aW9uIFRpbWUgU3RhbXAgKFBUUykgb2YgdGhlIGZyYWdtZW50LiBTZXQgYWZ0ZXIgdHJhbnNtdXggY29tcGxldGUuXG4gICAgdGhpcy5zdGFydFBUUyA9IHZvaWQgMDtcbiAgICAvLyBUaGUgZW5kaW5nIFByZXNlbnRhdGlvbiBUaW1lIFN0YW1wIChQVFMpIG9mIHRoZSBmcmFnbWVudC4gU2V0IGFmdGVyIHRyYW5zbXV4IGNvbXBsZXRlLlxuICAgIHRoaXMuZW5kUFRTID0gdm9pZCAwO1xuICAgIC8vIFRoZSBzdGFydGluZyBEZWNvZGUgVGltZSBTdGFtcCAoRFRTKSBvZiB0aGUgZnJhZ21lbnQuIFNldCBhZnRlciB0cmFuc211eCBjb21wbGV0ZS5cbiAgICB0aGlzLnN0YXJ0RFRTID0gdm9pZCAwO1xuICAgIC8vIFRoZSBlbmRpbmcgRGVjb2RlIFRpbWUgU3RhbXAgKERUUykgb2YgdGhlIGZyYWdtZW50LiBTZXQgYWZ0ZXIgdHJhbnNtdXggY29tcGxldGUuXG4gICAgdGhpcy5lbmREVFMgPSB2b2lkIDA7XG4gICAgLy8gVGhlIHN0YXJ0IHRpbWUgb2YgdGhlIGZyYWdtZW50LCBhcyBsaXN0ZWQgaW4gdGhlIG1hbmlmZXN0LiBVcGRhdGVkIGFmdGVyIHRyYW5zbXV4IGNvbXBsZXRlLlxuICAgIHRoaXMuc3RhcnQgPSAwO1xuICAgIC8vIFRoZSBvZmZzZXQgdGltZSAoc2Vjb25kcykgb2YgdGhlIGZyYWdtZW50IGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBQbGF5bGlzdFxuICAgIHRoaXMucGxheWxpc3RPZmZzZXQgPSAwO1xuICAgIC8vIFNldCBieSBgdXBkYXRlRnJhZ1BUU0RUU2AgaW4gbGV2ZWwtaGVscGVyXG4gICAgdGhpcy5kZWx0YVBUUyA9IHZvaWQgMDtcbiAgICAvLyBUaGUgbWF4aW11bSBzdGFydGluZyBQcmVzZW50YXRpb24gVGltZSBTdGFtcCAoYXVkaW8vdmlkZW8gUFRTKSBvZiB0aGUgZnJhZ21lbnQuIFNldCBhZnRlciB0cmFuc211eCBjb21wbGV0ZS5cbiAgICB0aGlzLm1heFN0YXJ0UFRTID0gdm9pZCAwO1xuICAgIC8vIFRoZSBtaW5pbXVtIGVuZGluZyBQcmVzZW50YXRpb24gVGltZSBTdGFtcCAoYXVkaW8vdmlkZW8gUFRTKSBvZiB0aGUgZnJhZ21lbnQuIFNldCBhZnRlciB0cmFuc211eCBjb21wbGV0ZS5cbiAgICB0aGlzLm1pbkVuZFBUUyA9IHZvaWQgMDtcbiAgICAvLyBJbml0IFNlZ21lbnQgYnl0ZXMgKHVuc2V0IGZvciBtZWRpYSBzZWdtZW50cylcbiAgICB0aGlzLmRhdGEgPSB2b2lkIDA7XG4gICAgLy8gQSBmbGFnIGluZGljYXRpbmcgd2hldGhlciB0aGUgc2VnbWVudCB3YXMgZG93bmxvYWRlZCBpbiBvcmRlciB0byB0ZXN0IGJpdHJhdGUsIGFuZCB3YXMgbm90IGJ1ZmZlcmVkXG4gICAgdGhpcy5iaXRyYXRlVGVzdCA9IGZhbHNlO1xuICAgIC8vICNFWFRJTkYgIHNlZ21lbnQgdGl0bGVcbiAgICB0aGlzLnRpdGxlID0gbnVsbDtcbiAgICAvLyBUaGUgTWVkaWEgSW5pdGlhbGl6YXRpb24gU2VjdGlvbiBmb3IgdGhpcyBzZWdtZW50XG4gICAgdGhpcy5pbml0U2VnbWVudCA9IG51bGw7XG4gICAgLy8gRnJhZ21lbnQgaXMgdGhlIGxhc3QgZnJhZ21lbnQgaW4gdGhlIG1lZGlhIHBsYXlsaXN0XG4gICAgdGhpcy5lbmRMaXN0ID0gdm9pZCAwO1xuICAgIC8vIEZyYWdtZW50IGlzIG1hcmtlZCBieSBhbiBFWFQtWC1HQVAgdGFnIGluZGljYXRpbmcgdGhhdCBpdCBkb2VzIG5vdCBjb250YWluIG1lZGlhIGRhdGEgYW5kIHNob3VsZCBub3QgYmUgbG9hZGVkXG4gICAgdGhpcy5nYXAgPSB2b2lkIDA7XG4gICAgLy8gRGVwcmVjYXRlZFxuICAgIHRoaXMudXJsSWQgPSAwO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gIH1cbiAgZ2V0IGJ5dGVMZW5ndGgoKSB7XG4gICAgaWYgKHRoaXMuaGFzU3RhdHMpIHtcbiAgICAgIGNvbnN0IHRvdGFsID0gdGhpcy5zdGF0cy50b3RhbDtcbiAgICAgIGlmICh0b3RhbCkge1xuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmJ5dGVSYW5nZSkge1xuICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLmJ5dGVSYW5nZVswXTtcbiAgICAgIGNvbnN0IGVuZCA9IHRoaXMuYnl0ZVJhbmdlWzFdO1xuICAgICAgaWYgKGlzRmluaXRlTnVtYmVyKHN0YXJ0KSAmJiBpc0Zpbml0ZU51bWJlcihlbmQpKSB7XG4gICAgICAgIHJldHVybiBlbmQgLSBzdGFydDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2V0IGJpdHJhdGUoKSB7XG4gICAgaWYgKHRoaXMuYnl0ZUxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuYnl0ZUxlbmd0aCAqIDggLyB0aGlzLmR1cmF0aW9uO1xuICAgIH1cbiAgICBpZiAodGhpcy5fYml0cmF0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2JpdHJhdGU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHNldCBiaXRyYXRlKHZhbHVlKSB7XG4gICAgdGhpcy5fYml0cmF0ZSA9IHZhbHVlO1xuICB9XG4gIGdldCBkZWNyeXB0ZGF0YSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBsZXZlbGtleXNcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWxldmVsa2V5cyAmJiAhdGhpcy5fZGVjcnlwdGRhdGEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2RlY3J5cHRkYXRhICYmIHRoaXMubGV2ZWxrZXlzICYmICF0aGlzLmxldmVsa2V5cy5OT05FKSB7XG4gICAgICBjb25zdCBrZXkgPSB0aGlzLmxldmVsa2V5cy5pZGVudGl0eTtcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgdGhpcy5fZGVjcnlwdGRhdGEgPSBrZXkuZ2V0RGVjcnlwdERhdGEodGhpcy5zbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBrZXlGb3JtYXRzID0gT2JqZWN0LmtleXModGhpcy5sZXZlbGtleXMpO1xuICAgICAgICBpZiAoa2V5Rm9ybWF0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZGVjcnlwdGRhdGEgPSB0aGlzLmxldmVsa2V5c1trZXlGb3JtYXRzWzBdXS5nZXREZWNyeXB0RGF0YSh0aGlzLnNuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZGVjcnlwdGRhdGE7XG4gIH1cbiAgZ2V0IGVuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFydCArIHRoaXMuZHVyYXRpb247XG4gIH1cbiAgZ2V0IGVuZFByb2dyYW1EYXRlVGltZSgpIHtcbiAgICBpZiAodGhpcy5wcm9ncmFtRGF0ZVRpbWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBkdXJhdGlvbiA9ICFpc0Zpbml0ZU51bWJlcih0aGlzLmR1cmF0aW9uKSA/IDAgOiB0aGlzLmR1cmF0aW9uO1xuICAgIHJldHVybiB0aGlzLnByb2dyYW1EYXRlVGltZSArIGR1cmF0aW9uICogMTAwMDtcbiAgfVxuICBnZXQgZW5jcnlwdGVkKCkge1xuICAgIHZhciBfdGhpcyRfZGVjcnlwdGRhdGE7XG4gICAgLy8gQXQgdGhlIG0zdTgtcGFyc2VyIGxldmVsIHdlIG5lZWQgdG8gYWRkIHN1cHBvcnQgZm9yIG1hbmlmZXN0IHNpZ25hbGxlZCBrZXlmb3JtYXRzXG4gICAgLy8gd2hlbiB3ZSB3YW50IHRoZSBmcmFnbWVudCB0byBzdGFydCByZXBvcnRpbmcgdGhhdCBpdCBpcyBlbmNyeXB0ZWQuXG4gICAgLy8gQ3VycmVudGx5LCBrZXlGb3JtYXQgd2lsbCBvbmx5IGJlIHNldCBmb3IgaWRlbnRpdHkga2V5c1xuICAgIGlmICgoX3RoaXMkX2RlY3J5cHRkYXRhID0gdGhpcy5fZGVjcnlwdGRhdGEpICE9IG51bGwgJiYgX3RoaXMkX2RlY3J5cHRkYXRhLmVuY3J5cHRlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxldmVsa2V5cykge1xuICAgICAgY29uc3Qga2V5Rm9ybWF0cyA9IE9iamVjdC5rZXlzKHRoaXMubGV2ZWxrZXlzKTtcbiAgICAgIGNvbnN0IGxlbiA9IGtleUZvcm1hdHMubGVuZ3RoO1xuICAgICAgaWYgKGxlbiA+IDEgfHwgbGVuID09PSAxICYmIHRoaXMubGV2ZWxrZXlzW2tleUZvcm1hdHNbMF1dLmVuY3J5cHRlZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGdldCBwcm9ncmFtRGF0ZVRpbWUoKSB7XG4gICAgaWYgKHRoaXMuX3Byb2dyYW1EYXRlVGltZSA9PT0gbnVsbCAmJiB0aGlzLnJhd1Byb2dyYW1EYXRlVGltZSkge1xuICAgICAgdGhpcy5wcm9ncmFtRGF0ZVRpbWUgPSBEYXRlLnBhcnNlKHRoaXMucmF3UHJvZ3JhbURhdGVUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3Byb2dyYW1EYXRlVGltZTtcbiAgfVxuICBzZXQgcHJvZ3JhbURhdGVUaW1lKHZhbHVlKSB7XG4gICAgaWYgKCFpc0Zpbml0ZU51bWJlcih2YWx1ZSkpIHtcbiAgICAgIHRoaXMuX3Byb2dyYW1EYXRlVGltZSA9IHRoaXMucmF3UHJvZ3JhbURhdGVUaW1lID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcHJvZ3JhbURhdGVUaW1lID0gdmFsdWU7XG4gIH1cbiAgZ2V0IHJlZigpIHtcbiAgICBpZiAoIWlzTWVkaWFGcmFnbWVudCh0aGlzKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICghdGhpcy5fcmVmKSB7XG4gICAgICB0aGlzLl9yZWYgPSB7XG4gICAgICAgIGJhc2U6IHRoaXMuYmFzZSxcbiAgICAgICAgc3RhcnQ6IHRoaXMuc3RhcnQsXG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICBzbjogdGhpcy5zbixcbiAgICAgICAgcHJvZ3JhbURhdGVUaW1lOiB0aGlzLnByb2dyYW1EYXRlVGltZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlZjtcbiAgfVxuICBhZGRTdGFydCh2YWx1ZSkge1xuICAgIHRoaXMuc2V0U3RhcnQodGhpcy5zdGFydCArIHZhbHVlKTtcbiAgfVxuICBzZXRTdGFydCh2YWx1ZSkge1xuICAgIHRoaXMuc3RhcnQgPSB2YWx1ZTtcbiAgICBpZiAodGhpcy5fcmVmKSB7XG4gICAgICB0aGlzLl9yZWYuc3RhcnQgPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgc2V0RHVyYXRpb24odmFsdWUpIHtcbiAgICB0aGlzLmR1cmF0aW9uID0gdmFsdWU7XG4gICAgaWYgKHRoaXMuX3JlZikge1xuICAgICAgdGhpcy5fcmVmLmR1cmF0aW9uID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHNldEtleUZvcm1hdChrZXlGb3JtYXQpIHtcbiAgICBpZiAodGhpcy5sZXZlbGtleXMpIHtcbiAgICAgIGNvbnN0IGtleSA9IHRoaXMubGV2ZWxrZXlzW2tleUZvcm1hdF07XG4gICAgICBpZiAoa2V5ICYmICF0aGlzLl9kZWNyeXB0ZGF0YSkge1xuICAgICAgICB0aGlzLl9kZWNyeXB0ZGF0YSA9IGtleS5nZXREZWNyeXB0RGF0YSh0aGlzLnNuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYWJvcnRSZXF1ZXN0cygpIHtcbiAgICB2YXIgX3RoaXMkbG9hZGVyLCBfdGhpcyRrZXlMb2FkZXI7XG4gICAgKF90aGlzJGxvYWRlciA9IHRoaXMubG9hZGVyKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbG9hZGVyLmFib3J0KCk7XG4gICAgKF90aGlzJGtleUxvYWRlciA9IHRoaXMua2V5TG9hZGVyKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMka2V5TG9hZGVyLmFib3J0KCk7XG4gIH1cbiAgc2V0RWxlbWVudGFyeVN0cmVhbUluZm8odHlwZSwgc3RhcnRQVFMsIGVuZFBUUywgc3RhcnREVFMsIGVuZERUUywgcGFydGlhbCA9IGZhbHNlKSB7XG4gICAgY29uc3Qge1xuICAgICAgZWxlbWVudGFyeVN0cmVhbXNcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBpbmZvID0gZWxlbWVudGFyeVN0cmVhbXNbdHlwZV07XG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICBlbGVtZW50YXJ5U3RyZWFtc1t0eXBlXSA9IHtcbiAgICAgICAgc3RhcnRQVFMsXG4gICAgICAgIGVuZFBUUyxcbiAgICAgICAgc3RhcnREVFMsXG4gICAgICAgIGVuZERUUyxcbiAgICAgICAgcGFydGlhbFxuICAgICAgfTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW5mby5zdGFydFBUUyA9IE1hdGgubWluKGluZm8uc3RhcnRQVFMsIHN0YXJ0UFRTKTtcbiAgICBpbmZvLmVuZFBUUyA9IE1hdGgubWF4KGluZm8uZW5kUFRTLCBlbmRQVFMpO1xuICAgIGluZm8uc3RhcnREVFMgPSBNYXRoLm1pbihpbmZvLnN0YXJ0RFRTLCBzdGFydERUUyk7XG4gICAgaW5mby5lbmREVFMgPSBNYXRoLm1heChpbmZvLmVuZERUUywgZW5kRFRTKTtcbiAgfVxufVxuXG4vKipcbiAqIE9iamVjdCByZXByZXNlbnRpbmcgcGFyc2VkIGRhdGEgZnJvbSBhbiBITFMgUGFydGlhbCBTZWdtZW50LiBGb3VuZCBpbiB7QGxpbmsgaGxzLmpzI0xldmVsRGV0YWlscy5wYXJ0TGlzdH0uXG4gKi9cbmNsYXNzIFBhcnQgZXh0ZW5kcyBCYXNlU2VnbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcnRBdHRycywgZnJhZywgYmFzZSwgaW5kZXgsIHByZXZpb3VzKSB7XG4gICAgc3VwZXIoYmFzZSk7XG4gICAgdGhpcy5mcmFnT2Zmc2V0ID0gMDtcbiAgICB0aGlzLmR1cmF0aW9uID0gMDtcbiAgICB0aGlzLmdhcCA9IGZhbHNlO1xuICAgIHRoaXMuaW5kZXBlbmRlbnQgPSBmYWxzZTtcbiAgICB0aGlzLnJlbHVybCA9IHZvaWQgMDtcbiAgICB0aGlzLmZyYWdtZW50ID0gdm9pZCAwO1xuICAgIHRoaXMuaW5kZXggPSB2b2lkIDA7XG4gICAgdGhpcy5kdXJhdGlvbiA9IHBhcnRBdHRycy5kZWNpbWFsRmxvYXRpbmdQb2ludCgnRFVSQVRJT04nKTtcbiAgICB0aGlzLmdhcCA9IHBhcnRBdHRycy5ib29sKCdHQVAnKTtcbiAgICB0aGlzLmluZGVwZW5kZW50ID0gcGFydEF0dHJzLmJvb2woJ0lOREVQRU5ERU5UJyk7XG4gICAgdGhpcy5yZWx1cmwgPSBwYXJ0QXR0cnMuZW51bWVyYXRlZFN0cmluZygnVVJJJyk7XG4gICAgdGhpcy5mcmFnbWVudCA9IGZyYWc7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIGNvbnN0IGJ5dGVSYW5nZSA9IHBhcnRBdHRycy5lbnVtZXJhdGVkU3RyaW5nKCdCWVRFUkFOR0UnKTtcbiAgICBpZiAoYnl0ZVJhbmdlKSB7XG4gICAgICB0aGlzLnNldEJ5dGVSYW5nZShieXRlUmFuZ2UsIHByZXZpb3VzKTtcbiAgICB9XG4gICAgaWYgKHByZXZpb3VzKSB7XG4gICAgICB0aGlzLmZyYWdPZmZzZXQgPSBwcmV2aW91cy5mcmFnT2Zmc2V0ICsgcHJldmlvdXMuZHVyYXRpb247XG4gICAgfVxuICB9XG4gIGdldCBzdGFydCgpIHtcbiAgICByZXR1cm4gdGhpcy5mcmFnbWVudC5zdGFydCArIHRoaXMuZnJhZ09mZnNldDtcbiAgfVxuICBnZXQgZW5kKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXJ0ICsgdGhpcy5kdXJhdGlvbjtcbiAgfVxuICBnZXQgbG9hZGVkKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW1lbnRhcnlTdHJlYW1zXG4gICAgfSA9IHRoaXM7XG4gICAgcmV0dXJuICEhKGVsZW1lbnRhcnlTdHJlYW1zLmF1ZGlvIHx8IGVsZW1lbnRhcnlTdHJlYW1zLnZpZGVvIHx8IGVsZW1lbnRhcnlTdHJlYW1zLmF1ZGlvdmlkZW8pO1xuICB9XG59XG5mdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JGcm9tUHJvdG90eXBlQ2hhaW4ob2JqZWN0LCBwcm9wZXJ0eSkge1xuICBjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgaWYgKHByb3RvdHlwZSkge1xuICAgIGNvbnN0IHByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG90eXBlLCBwcm9wZXJ0eSk7XG4gICAgaWYgKHByb3BlcnR5RGVzY3JpcHRvcikge1xuICAgICAgcmV0dXJuIHByb3BlcnR5RGVzY3JpcHRvcjtcbiAgICB9XG4gICAgcmV0dXJuIGdldE93blByb3BlcnR5RGVzY3JpcHRvckZyb21Qcm90b3R5cGVDaGFpbihwcm90b3R5cGUsIHByb3BlcnR5KTtcbiAgfVxufVxuZnVuY3Rpb24gbWFrZUVudW1lcmFibGUob2JqZWN0LCBwcm9wZXJ0eSkge1xuICBjb25zdCBkID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yRnJvbVByb3RvdHlwZUNoYWluKG9iamVjdCwgcHJvcGVydHkpO1xuICBpZiAoZCkge1xuICAgIGQuZW51bWVyYWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIGQpO1xuICB9XG59XG5cbmNvbnN0IFVJTlQzMl9NQVgkMSA9IE1hdGgucG93KDIsIDMyKSAtIDE7XG5jb25zdCBwdXNoID0gW10ucHVzaDtcblxuLy8gV2UgYXJlIHVzaW5nIGZpeGVkIHRyYWNrIElEcyBmb3IgZHJpdmluZyB0aGUgTVA0IHJlbXV4ZXJcbi8vIGluc3RlYWQgb2YgZm9sbG93aW5nIHRoZSBUUyBQSURzLlxuLy8gVGhlcmUgaXMgbm8gcmVhc29uIG5vdCB0byBkbyB0aGlzIGFuZCBzb21lIGJyb3dzZXJzL1NvdXJjZUJ1ZmZlci1kZW11eGVyc1xuLy8gbWF5IG5vdCBsaWtlIGlmIHRoZXJlIGFyZSBUcmFja0lEIFwic3dpdGNoZXNcIlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy8xMzMxXG4vLyBIZXJlIHdlIGFyZSBtYXBwaW5nIG91ciBpbnRlcm5hbCB0cmFjayB0eXBlcyB0byBjb25zdGFudCBNUDQgdHJhY2sgSURzXG4vLyBXaXRoIE1TRSBjdXJyZW50bHkgb25lIGNhbiBvbmx5IGhhdmUgb25lIHRyYWNrIG9mIGVhY2gsIGFuZCB3ZSBhcmUgbXV4aW5nXG4vLyB3aGF0ZXZlciB2aWRlby9hdWRpbyByZW5kaXRpb24gaW4gdGhlbS5cbmNvbnN0IFJlbXV4ZXJUcmFja0lkQ29uZmlnID0ge1xuICB2aWRlbzogMSxcbiAgYXVkaW86IDIsXG4gIGlkMzogMyxcbiAgdGV4dDogNFxufTtcbmZ1bmN0aW9uIGJpbjJzdHIoZGF0YSkge1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBkYXRhKTtcbn1cbmZ1bmN0aW9uIHJlYWRVaW50MTYoYnVmZmVyLCBvZmZzZXQpIHtcbiAgY29uc3QgdmFsID0gYnVmZmVyW29mZnNldF0gPDwgOCB8IGJ1ZmZlcltvZmZzZXQgKyAxXTtcbiAgcmV0dXJuIHZhbCA8IDAgPyA2NTUzNiArIHZhbCA6IHZhbDtcbn1cbmZ1bmN0aW9uIHJlYWRVaW50MzIoYnVmZmVyLCBvZmZzZXQpIHtcbiAgY29uc3QgdmFsID0gcmVhZFNpbnQzMihidWZmZXIsIG9mZnNldCk7XG4gIHJldHVybiB2YWwgPCAwID8gNDI5NDk2NzI5NiArIHZhbCA6IHZhbDtcbn1cbmZ1bmN0aW9uIHJlYWRVaW50NjQoYnVmZmVyLCBvZmZzZXQpIHtcbiAgbGV0IHJlc3VsdCA9IHJlYWRVaW50MzIoYnVmZmVyLCBvZmZzZXQpO1xuICByZXN1bHQgKj0gTWF0aC5wb3coMiwgMzIpO1xuICByZXN1bHQgKz0gcmVhZFVpbnQzMihidWZmZXIsIG9mZnNldCArIDQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcmVhZFNpbnQzMihidWZmZXIsIG9mZnNldCkge1xuICByZXR1cm4gYnVmZmVyW29mZnNldF0gPDwgMjQgfCBidWZmZXJbb2Zmc2V0ICsgMV0gPDwgMTYgfCBidWZmZXJbb2Zmc2V0ICsgMl0gPDwgOCB8IGJ1ZmZlcltvZmZzZXQgKyAzXTtcbn1cblxuLy8gRmluZCBcIm1vb2ZcIiBib3hcbmZ1bmN0aW9uIGhhc01vb2ZEYXRhKGRhdGEpIHtcbiAgY29uc3QgZW5kID0gZGF0YS5ieXRlTGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGVuZDspIHtcbiAgICBjb25zdCBzaXplID0gcmVhZFVpbnQzMihkYXRhLCBpKTtcbiAgICBpZiAoc2l6ZSA+IDggJiYgZGF0YVtpICsgNF0gPT09IDB4NmQgJiYgZGF0YVtpICsgNV0gPT09IDB4NmYgJiYgZGF0YVtpICsgNl0gPT09IDB4NmYgJiYgZGF0YVtpICsgN10gPT09IDB4NjYpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpID0gc2l6ZSA+IDEgPyBpICsgc2l6ZSA6IGVuZDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIEZpbmQgdGhlIGRhdGEgZm9yIGEgYm94IHNwZWNpZmllZCBieSBpdHMgcGF0aFxuZnVuY3Rpb24gZmluZEJveChkYXRhLCBwYXRoKSB7XG4gIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgaWYgKCFwYXRoLmxlbmd0aCkge1xuICAgIC8vIHNob3J0LWNpcmN1aXQgdGhlIHNlYXJjaCBmb3IgZW1wdHkgcGF0aHNcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuICBjb25zdCBlbmQgPSBkYXRhLmJ5dGVMZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZW5kOykge1xuICAgIGNvbnN0IHNpemUgPSByZWFkVWludDMyKGRhdGEsIGkpO1xuICAgIGNvbnN0IHR5cGUgPSBiaW4yc3RyKGRhdGEuc3ViYXJyYXkoaSArIDQsIGkgKyA4KSk7XG4gICAgY29uc3QgZW5kYm94ID0gc2l6ZSA+IDEgPyBpICsgc2l6ZSA6IGVuZDtcbiAgICBpZiAodHlwZSA9PT0gcGF0aFswXSkge1xuICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgdGhlIGVuZCBvZiB0aGUgcGF0aCBhbmQgd2UndmUgZm91bmQgdGhlIGJveCB3ZSB3ZXJlXG4gICAgICAgIC8vIGxvb2tpbmcgZm9yXG4gICAgICAgIHJlc3VsdHMucHVzaChkYXRhLnN1YmFycmF5KGkgKyA4LCBlbmRib3gpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgdGhlIG5leHQgYm94IGFsb25nIHRoZSBwYXRoXG4gICAgICAgIGNvbnN0IHN1YnJlc3VsdHMgPSBmaW5kQm94KGRhdGEuc3ViYXJyYXkoaSArIDgsIGVuZGJveCksIHBhdGguc2xpY2UoMSkpO1xuICAgICAgICBpZiAoc3VicmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICBwdXNoLmFwcGx5KHJlc3VsdHMsIHN1YnJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGkgPSBlbmRib3g7XG4gIH1cblxuICAvLyB3ZSd2ZSBmaW5pc2hlZCBzZWFyY2hpbmcgYWxsIG9mIGRhdGFcbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5mdW5jdGlvbiBwYXJzZVNlZ21lbnRJbmRleChzaWR4KSB7XG4gIGNvbnN0IHJlZmVyZW5jZXMgPSBbXTtcbiAgY29uc3QgdmVyc2lvbiA9IHNpZHhbMF07XG5cbiAgLy8gc2V0IGluaXRpYWwgb2Zmc2V0LCB3ZSBza2lwIHRoZSByZWZlcmVuY2UgSUQgKG5vdCBuZWVkZWQpXG4gIGxldCBpbmRleCA9IDg7XG4gIGNvbnN0IHRpbWVzY2FsZSA9IHJlYWRVaW50MzIoc2lkeCwgaW5kZXgpO1xuICBpbmRleCArPSA0O1xuICBsZXQgZWFybGllc3RQcmVzZW50YXRpb25UaW1lID0gMDtcbiAgbGV0IGZpcnN0T2Zmc2V0ID0gMDtcbiAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICBlYXJsaWVzdFByZXNlbnRhdGlvblRpbWUgPSByZWFkVWludDMyKHNpZHgsIGluZGV4KTtcbiAgICBmaXJzdE9mZnNldCA9IHJlYWRVaW50MzIoc2lkeCwgaW5kZXggKyA0KTtcbiAgICBpbmRleCArPSA4O1xuICB9IGVsc2Uge1xuICAgIGVhcmxpZXN0UHJlc2VudGF0aW9uVGltZSA9IHJlYWRVaW50NjQoc2lkeCwgaW5kZXgpO1xuICAgIGZpcnN0T2Zmc2V0ID0gcmVhZFVpbnQ2NChzaWR4LCBpbmRleCArIDgpO1xuICAgIGluZGV4ICs9IDE2O1xuICB9XG5cbiAgLy8gc2tpcCByZXNlcnZlZFxuICBpbmRleCArPSAyO1xuICBsZXQgc3RhcnRCeXRlID0gc2lkeC5sZW5ndGggKyBmaXJzdE9mZnNldDtcbiAgY29uc3QgcmVmZXJlbmNlc0NvdW50ID0gcmVhZFVpbnQxNihzaWR4LCBpbmRleCk7XG4gIGluZGV4ICs9IDI7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmVmZXJlbmNlc0NvdW50OyBpKyspIHtcbiAgICBsZXQgcmVmZXJlbmNlSW5kZXggPSBpbmRleDtcbiAgICBjb25zdCByZWZlcmVuY2VJbmZvID0gcmVhZFVpbnQzMihzaWR4LCByZWZlcmVuY2VJbmRleCk7XG4gICAgcmVmZXJlbmNlSW5kZXggKz0gNDtcbiAgICBjb25zdCByZWZlcmVuY2VTaXplID0gcmVmZXJlbmNlSW5mbyAmIDB4N2ZmZmZmZmY7XG4gICAgY29uc3QgcmVmZXJlbmNlVHlwZSA9IChyZWZlcmVuY2VJbmZvICYgMHg4MDAwMDAwMCkgPj4+IDMxO1xuICAgIGlmIChyZWZlcmVuY2VUeXBlID09PSAxKSB7XG4gICAgICBsb2dnZXIud2FybignU0lEWCBoYXMgaGllcmFyY2hpY2FsIHJlZmVyZW5jZXMgKG5vdCBzdXBwb3J0ZWQpJyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc3Vic2VnbWVudER1cmF0aW9uID0gcmVhZFVpbnQzMihzaWR4LCByZWZlcmVuY2VJbmRleCk7XG4gICAgcmVmZXJlbmNlSW5kZXggKz0gNDtcbiAgICByZWZlcmVuY2VzLnB1c2goe1xuICAgICAgcmVmZXJlbmNlU2l6ZSxcbiAgICAgIHN1YnNlZ21lbnREdXJhdGlvbixcbiAgICAgIC8vIHVuc2NhbGVkXG4gICAgICBpbmZvOiB7XG4gICAgICAgIGR1cmF0aW9uOiBzdWJzZWdtZW50RHVyYXRpb24gLyB0aW1lc2NhbGUsXG4gICAgICAgIHN0YXJ0OiBzdGFydEJ5dGUsXG4gICAgICAgIGVuZDogc3RhcnRCeXRlICsgcmVmZXJlbmNlU2l6ZSAtIDFcbiAgICAgIH1cbiAgICB9KTtcbiAgICBzdGFydEJ5dGUgKz0gcmVmZXJlbmNlU2l6ZTtcblxuICAgIC8vIFNraXBwaW5nIDEgYml0IGZvciB8c3RhcnRzV2l0aFNhcHwsIDMgYml0cyBmb3IgfHNhcFR5cGV8LCBhbmQgMjggYml0c1xuICAgIC8vIGZvciB8c2FwRGVsdGF8LlxuICAgIHJlZmVyZW5jZUluZGV4ICs9IDQ7XG5cbiAgICAvLyBza2lwIHRvIG5leHQgcmVmXG4gICAgaW5kZXggPSByZWZlcmVuY2VJbmRleDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGVhcmxpZXN0UHJlc2VudGF0aW9uVGltZSxcbiAgICB0aW1lc2NhbGUsXG4gICAgdmVyc2lvbixcbiAgICByZWZlcmVuY2VzQ291bnQsXG4gICAgcmVmZXJlbmNlc1xuICB9O1xufVxuXG4vKipcbiAqIFBhcnNlcyBhbiBNUDQgaW5pdGlhbGl6YXRpb24gc2VnbWVudCBhbmQgZXh0cmFjdHMgc3RyZWFtIHR5cGUgYW5kXG4gKiB0aW1lc2NhbGUgdmFsdWVzIGZvciBhbnkgZGVjbGFyZWQgdHJhY2tzLiBUaW1lc2NhbGUgdmFsdWVzIGluZGljYXRlIHRoZVxuICogbnVtYmVyIG9mIGNsb2NrIHRpY2tzIHBlciBzZWNvbmQgdG8gYXNzdW1lIGZvciB0aW1lLWJhc2VkIHZhbHVlc1xuICogZWxzZXdoZXJlIGluIHRoZSBNUDQuXG4gKlxuICogVG8gZGV0ZXJtaW5lIHRoZSBzdGFydCB0aW1lIG9mIGFuIE1QNCwgeW91IG5lZWQgdHdvIHBpZWNlcyBvZlxuICogaW5mb3JtYXRpb246IHRoZSB0aW1lc2NhbGUgdW5pdCBhbmQgdGhlIGVhcmxpZXN0IGJhc2UgbWVkaWEgZGVjb2RlXG4gKiB0aW1lLiBNdWx0aXBsZSB0aW1lc2NhbGVzIGNhbiBiZSBzcGVjaWZpZWQgd2l0aGluIGFuIE1QNCBidXQgdGhlXG4gKiBiYXNlIG1lZGlhIGRlY29kZSB0aW1lIGlzIGFsd2F5cyBleHByZXNzZWQgaW4gdGhlIHRpbWVzY2FsZSBmcm9tXG4gKiB0aGUgbWVkaWEgaGVhZGVyIGJveCBmb3IgdGhlIHRyYWNrOlxuICogYGBgXG4gKiBtb292ID4gdHJhayA+IG1kaWEgPiBtZGhkLnRpbWVzY2FsZVxuICogbW9vdiA+IHRyYWsgPiBtZGlhID4gaGRsclxuICogYGBgXG4gKiBAcGFyYW0gaW5pdFNlZ21lbnQgdGhlIGJ5dGVzIG9mIHRoZSBpbml0IHNlZ21lbnRcbiAqIEByZXR1cm5zIGEgaGFzaCBvZiB0cmFjayB0eXBlIHRvIHRpbWVzY2FsZSB2YWx1ZXMgb3IgbnVsbCBpZlxuICogdGhlIGluaXQgc2VnbWVudCBpcyBtYWxmb3JtZWQuXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VJbml0U2VnbWVudChpbml0U2VnbWVudCkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3QgdHJha3MgPSBmaW5kQm94KGluaXRTZWdtZW50LCBbJ21vb3YnLCAndHJhayddKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFrcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRyYWsgPSB0cmFrc1tpXTtcbiAgICBjb25zdCB0a2hkID0gZmluZEJveCh0cmFrLCBbJ3RraGQnXSlbMF07XG4gICAgaWYgKHRraGQpIHtcbiAgICAgIGxldCB2ZXJzaW9uID0gdGtoZFswXTtcbiAgICAgIGNvbnN0IHRyYWNrSWQgPSByZWFkVWludDMyKHRraGQsIHZlcnNpb24gPT09IDAgPyAxMiA6IDIwKTtcbiAgICAgIGNvbnN0IG1kaGQgPSBmaW5kQm94KHRyYWssIFsnbWRpYScsICdtZGhkJ10pWzBdO1xuICAgICAgaWYgKG1kaGQpIHtcbiAgICAgICAgdmVyc2lvbiA9IG1kaGRbMF07XG4gICAgICAgIGNvbnN0IHRpbWVzY2FsZSA9IHJlYWRVaW50MzIobWRoZCwgdmVyc2lvbiA9PT0gMCA/IDEyIDogMjApO1xuICAgICAgICBjb25zdCBoZGxyID0gZmluZEJveCh0cmFrLCBbJ21kaWEnLCAnaGRsciddKVswXTtcbiAgICAgICAgaWYgKGhkbHIpIHtcbiAgICAgICAgICBjb25zdCBoZGxyVHlwZSA9IGJpbjJzdHIoaGRsci5zdWJhcnJheSg4LCAxMikpO1xuICAgICAgICAgIGNvbnN0IHR5cGUgPSB7XG4gICAgICAgICAgICBzb3VuOiBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU8sXG4gICAgICAgICAgICB2aWRlOiBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU9cbiAgICAgICAgICB9W2hkbHJUeXBlXTtcbiAgICAgICAgICAvLyBQYXJzZSBjb2RlYyBkZXRhaWxzXG4gICAgICAgICAgY29uc3Qgc3RzZEJveCA9IGZpbmRCb3godHJhaywgWydtZGlhJywgJ21pbmYnLCAnc3RibCcsICdzdHNkJ10pWzBdO1xuICAgICAgICAgIGNvbnN0IHN0c2QgPSBwYXJzZVN0c2Qoc3RzZEJveCk7XG4gICAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgIC8vIEFkZCAnYXVkaW8nLCAndmlkZW8nLCBhbmQgJ2F1ZGlvdmlkZW8nIHRyYWNrIHJlY29yZHMgdGhhdCB3aWxsIG1hcCB0byBTb3VyY2VCdWZmZXJzXG4gICAgICAgICAgICByZXN1bHRbdHJhY2tJZF0gPSB7XG4gICAgICAgICAgICAgIHRpbWVzY2FsZSxcbiAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgc3RzZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3VsdFt0eXBlXSA9IF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgICAgICAgdGltZXNjYWxlLFxuICAgICAgICAgICAgICBpZDogdHJhY2tJZFxuICAgICAgICAgICAgfSwgc3RzZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFkZCAnbWV0YScgYW5kIG90aGVyIHRyYWNrIHJlY29yZHNcbiAgICAgICAgICAgIHJlc3VsdFt0cmFja0lkXSA9IHtcbiAgICAgICAgICAgICAgdGltZXNjYWxlLFxuICAgICAgICAgICAgICB0eXBlOiBoZGxyVHlwZSxcbiAgICAgICAgICAgICAgc3RzZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgdHJleCA9IGZpbmRCb3goaW5pdFNlZ21lbnQsIFsnbW9vdicsICdtdmV4JywgJ3RyZXgnXSk7XG4gIHRyZXguZm9yRWFjaCh0cmV4ID0+IHtcbiAgICBjb25zdCB0cmFja0lkID0gcmVhZFVpbnQzMih0cmV4LCA0KTtcbiAgICBjb25zdCB0cmFjayA9IHJlc3VsdFt0cmFja0lkXTtcbiAgICBpZiAodHJhY2spIHtcbiAgICAgIHRyYWNrLmRlZmF1bHQgPSB7XG4gICAgICAgIGR1cmF0aW9uOiByZWFkVWludDMyKHRyZXgsIDEyKSxcbiAgICAgICAgZmxhZ3M6IHJlYWRVaW50MzIodHJleCwgMjApXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXJzZVN0c2Qoc3RzZCkge1xuICBjb25zdCBzYW1wbGVFbnRyaWVzID0gc3RzZC5zdWJhcnJheSg4KTtcbiAgY29uc3Qgc2FtcGxlRW50cmllc0VuZCA9IHNhbXBsZUVudHJpZXMuc3ViYXJyYXkoOCArIDc4KTtcbiAgY29uc3QgZm91ckNDID0gYmluMnN0cihzYW1wbGVFbnRyaWVzLnN1YmFycmF5KDQsIDgpKTtcbiAgbGV0IGNvZGVjID0gZm91ckNDO1xuICBsZXQgc3VwcGxlbWVudGFsO1xuICBjb25zdCBlbmNyeXB0ZWQgPSBmb3VyQ0MgPT09ICdlbmNhJyB8fCBmb3VyQ0MgPT09ICdlbmN2JztcbiAgaWYgKGVuY3J5cHRlZCkge1xuICAgIGNvbnN0IGVuY0JveCA9IGZpbmRCb3goc2FtcGxlRW50cmllcywgW2ZvdXJDQ10pWzBdO1xuICAgIGNvbnN0IGVuY0JveENoaWxkcmVuID0gZW5jQm94LnN1YmFycmF5KGZvdXJDQyA9PT0gJ2VuY2EnID8gMjggOiA3OCk7XG4gICAgY29uc3Qgc2luZnMgPSBmaW5kQm94KGVuY0JveENoaWxkcmVuLCBbJ3NpbmYnXSk7XG4gICAgc2luZnMuZm9yRWFjaChzaW5mID0+IHtcbiAgICAgIGNvbnN0IHNjaG0gPSBmaW5kQm94KHNpbmYsIFsnc2NobSddKVswXTtcbiAgICAgIGlmIChzY2htKSB7XG4gICAgICAgIGNvbnN0IHNjaGVtZSA9IGJpbjJzdHIoc2NobS5zdWJhcnJheSg0LCA4KSk7XG4gICAgICAgIGlmIChzY2hlbWUgPT09ICdjYmNzJyB8fCBzY2hlbWUgPT09ICdjZW5jJykge1xuICAgICAgICAgIGNvbnN0IGZybWEgPSBmaW5kQm94KHNpbmYsIFsnZnJtYSddKVswXTtcbiAgICAgICAgICBpZiAoZnJtYSkge1xuICAgICAgICAgICAgLy8gZm9yIGVuY3J5cHRlZCBjb250ZW50IGNvZGVjIGZvdXJDQyB3aWxsIGJlIGluIGZybWFcbiAgICAgICAgICAgIGNvZGVjID0gYmluMnN0cihmcm1hKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjb25zdCBjb2RlY0ZvdXJDQyA9IGNvZGVjO1xuICBzd2l0Y2ggKGNvZGVjKSB7XG4gICAgY2FzZSAnYXZjMSc6XG4gICAgY2FzZSAnYXZjMic6XG4gICAgY2FzZSAnYXZjMyc6XG4gICAgY2FzZSAnYXZjNCc6XG4gICAgICB7XG4gICAgICAgIC8vIGV4dHJhY3QgcHJvZmlsZSArIGNvbXBhdGliaWxpdHkgKyBsZXZlbCBvdXQgb2YgYXZjQyBib3hcbiAgICAgICAgY29uc3QgYXZjQ0JveCA9IGZpbmRCb3goc2FtcGxlRW50cmllc0VuZCwgWydhdmNDJ10pWzBdO1xuICAgICAgICBpZiAoYXZjQ0JveCAmJiBhdmNDQm94Lmxlbmd0aCA+IDMpIHtcbiAgICAgICAgICBjb2RlYyArPSAnLicgKyB0b0hleChhdmNDQm94WzFdKSArIHRvSGV4KGF2Y0NCb3hbMl0pICsgdG9IZXgoYXZjQ0JveFszXSk7XG4gICAgICAgICAgc3VwcGxlbWVudGFsID0gcGFyc2VTdXBwbGVtZW50YWxEb1ZpQ29kZWMoY29kZWNGb3VyQ0MgPT09ICdhdmMxJyA/ICdkdmExJyA6ICdkdmF2Jywgc2FtcGxlRW50cmllc0VuZCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSAnbXA0YSc6XG4gICAgICB7XG4gICAgICAgIGNvbnN0IGNvZGVjQm94ID0gZmluZEJveChzYW1wbGVFbnRyaWVzLCBbZm91ckNDXSlbMF07XG4gICAgICAgIGNvbnN0IGVzZHNCb3ggPSBmaW5kQm94KGNvZGVjQm94LnN1YmFycmF5KDI4KSwgWydlc2RzJ10pWzBdO1xuICAgICAgICBpZiAoZXNkc0JveCAmJiBlc2RzQm94Lmxlbmd0aCA+IDcpIHtcbiAgICAgICAgICBsZXQgaSA9IDQ7XG4gICAgICAgICAgLy8gRVMgRGVzY3JpcHRvciB0YWdcbiAgICAgICAgICBpZiAoZXNkc0JveFtpKytdICE9PSAweDAzKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaSA9IHNraXBCRVJJbnRlZ2VyKGVzZHNCb3gsIGkpO1xuICAgICAgICAgIGkgKz0gMjsgLy8gc2tpcCBlc19pZDtcbiAgICAgICAgICBjb25zdCBmbGFncyA9IGVzZHNCb3hbaSsrXTtcbiAgICAgICAgICBpZiAoZmxhZ3MgJiAweDgwKSB7XG4gICAgICAgICAgICBpICs9IDI7IC8vIHNraXAgZGVwZW5kZW5jeSBlc19pZFxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZmxhZ3MgJiAweDQwKSB7XG4gICAgICAgICAgICBpICs9IGVzZHNCb3hbaSsrXTsgLy8gc2tpcCBVUkxcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gRGVjb2RlciBjb25maWcgZGVzY3JpcHRvclxuICAgICAgICAgIGlmIChlc2RzQm94W2krK10gIT09IDB4MDQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpID0gc2tpcEJFUkludGVnZXIoZXNkc0JveCwgaSk7XG4gICAgICAgICAgY29uc3Qgb2JqZWN0VHlwZSA9IGVzZHNCb3hbaSsrXTtcbiAgICAgICAgICBpZiAob2JqZWN0VHlwZSA9PT0gMHg0MCkge1xuICAgICAgICAgICAgY29kZWMgKz0gJy4nICsgdG9IZXgob2JqZWN0VHlwZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpICs9IDEyO1xuICAgICAgICAgIC8vIERlY29kZXIgc3BlY2lmaWMgaW5mb1xuICAgICAgICAgIGlmIChlc2RzQm94W2krK10gIT09IDB4MDUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpID0gc2tpcEJFUkludGVnZXIoZXNkc0JveCwgaSk7XG4gICAgICAgICAgY29uc3QgZmlyc3RCeXRlID0gZXNkc0JveFtpKytdO1xuICAgICAgICAgIGxldCBhdWRpb09iamVjdFR5cGUgPSAoZmlyc3RCeXRlICYgMHhmOCkgPj4gMztcbiAgICAgICAgICBpZiAoYXVkaW9PYmplY3RUeXBlID09PSAzMSkge1xuICAgICAgICAgICAgYXVkaW9PYmplY3RUeXBlICs9IDEgKyAoKGZpcnN0Qnl0ZSAmIDB4NykgPDwgMykgKyAoKGVzZHNCb3hbaV0gJiAweGUwKSA+PiA1KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29kZWMgKz0gJy4nICsgYXVkaW9PYmplY3RUeXBlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgJ2h2YzEnOlxuICAgIGNhc2UgJ2hldjEnOlxuICAgICAge1xuICAgICAgICBjb25zdCBodmNDQm94ID0gZmluZEJveChzYW1wbGVFbnRyaWVzRW5kLCBbJ2h2Y0MnXSlbMF07XG4gICAgICAgIGlmIChodmNDQm94ICYmIGh2Y0NCb3gubGVuZ3RoID4gMTIpIHtcbiAgICAgICAgICBjb25zdCBwcm9maWxlQnl0ZSA9IGh2Y0NCb3hbMV07XG4gICAgICAgICAgY29uc3QgcHJvZmlsZVNwYWNlID0gWycnLCAnQScsICdCJywgJ0MnXVtwcm9maWxlQnl0ZSA+PiA2XTtcbiAgICAgICAgICBjb25zdCBnZW5lcmFsUHJvZmlsZUlkYyA9IHByb2ZpbGVCeXRlICYgMHgxZjtcbiAgICAgICAgICBjb25zdCBwcm9maWxlQ29tcGF0ID0gcmVhZFVpbnQzMihodmNDQm94LCAyKTtcbiAgICAgICAgICBjb25zdCB0aWVyRmxhZyA9IChwcm9maWxlQnl0ZSAmIDB4MjApID4+IDUgPyAnSCcgOiAnTCc7XG4gICAgICAgICAgY29uc3QgbGV2ZWxJREMgPSBodmNDQm94WzEyXTtcbiAgICAgICAgICBjb25zdCBjb25zdHJhaW50SW5kaWNhdG9yID0gaHZjQ0JveC5zdWJhcnJheSg2LCAxMik7XG4gICAgICAgICAgY29kZWMgKz0gJy4nICsgcHJvZmlsZVNwYWNlICsgZ2VuZXJhbFByb2ZpbGVJZGM7XG4gICAgICAgICAgY29kZWMgKz0gJy4nICsgcmV2ZXJzZTMyQml0SW50KHByb2ZpbGVDb21wYXQpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgIGNvZGVjICs9ICcuJyArIHRpZXJGbGFnICsgbGV2ZWxJREM7XG4gICAgICAgICAgbGV0IGNvbnN0cmFpbnRTdHJpbmcgPSAnJztcbiAgICAgICAgICBmb3IgKGxldCBpID0gY29uc3RyYWludEluZGljYXRvci5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUgPSBjb25zdHJhaW50SW5kaWNhdG9yW2ldO1xuICAgICAgICAgICAgaWYgKGJ5dGUgfHwgY29uc3RyYWludFN0cmluZykge1xuICAgICAgICAgICAgICBjb25zdCBlbmNvZGVkQnl0ZSA9IGJ5dGUudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgIGNvbnN0cmFpbnRTdHJpbmcgPSAnLicgKyBlbmNvZGVkQnl0ZSArIGNvbnN0cmFpbnRTdHJpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvZGVjICs9IGNvbnN0cmFpbnRTdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgc3VwcGxlbWVudGFsID0gcGFyc2VTdXBwbGVtZW50YWxEb1ZpQ29kZWMoY29kZWNGb3VyQ0MgPT0gJ2hldjEnID8gJ2R2aGUnIDogJ2R2aDEnLCBzYW1wbGVFbnRyaWVzRW5kKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSAnZHZoMSc6XG4gICAgY2FzZSAnZHZoZSc6XG4gICAgY2FzZSAnZHZhdic6XG4gICAgY2FzZSAnZHZhMSc6XG4gICAgY2FzZSAnZGF2MSc6XG4gICAgICB7XG4gICAgICAgIGNvZGVjID0gcGFyc2VTdXBwbGVtZW50YWxEb1ZpQ29kZWMoY29kZWMsIHNhbXBsZUVudHJpZXNFbmQpIHx8IGNvZGVjO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlICd2cDA5JzpcbiAgICAgIHtcbiAgICAgICAgY29uc3QgdnBjQ0JveCA9IGZpbmRCb3goc2FtcGxlRW50cmllc0VuZCwgWyd2cGNDJ10pWzBdO1xuICAgICAgICBpZiAodnBjQ0JveCAmJiB2cGNDQm94Lmxlbmd0aCA+IDYpIHtcbiAgICAgICAgICBjb25zdCBwcm9maWxlID0gdnBjQ0JveFs0XTtcbiAgICAgICAgICBjb25zdCBsZXZlbCA9IHZwY0NCb3hbNV07XG4gICAgICAgICAgY29uc3QgYml0RGVwdGggPSB2cGNDQm94WzZdID4+IDQgJiAweDBmO1xuICAgICAgICAgIGNvZGVjICs9ICcuJyArIGFkZExlYWRpbmdaZXJvKHByb2ZpbGUpICsgJy4nICsgYWRkTGVhZGluZ1plcm8obGV2ZWwpICsgJy4nICsgYWRkTGVhZGluZ1plcm8oYml0RGVwdGgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgJ2F2MDEnOlxuICAgICAge1xuICAgICAgICBjb25zdCBhdjFDQm94ID0gZmluZEJveChzYW1wbGVFbnRyaWVzRW5kLCBbJ2F2MUMnXSlbMF07XG4gICAgICAgIGlmIChhdjFDQm94ICYmIGF2MUNCb3gubGVuZ3RoID4gMikge1xuICAgICAgICAgIGNvbnN0IHByb2ZpbGUgPSBhdjFDQm94WzFdID4+PiA1O1xuICAgICAgICAgIGNvbnN0IGxldmVsID0gYXYxQ0JveFsxXSAmIDB4MWY7XG4gICAgICAgICAgY29uc3QgdGllckZsYWcgPSBhdjFDQm94WzJdID4+PiA3ID8gJ0gnIDogJ00nO1xuICAgICAgICAgIGNvbnN0IGhpZ2hCaXREZXB0aCA9IChhdjFDQm94WzJdICYgMHg0MCkgPj4gNjtcbiAgICAgICAgICBjb25zdCB0d2VsdmVCaXQgPSAoYXYxQ0JveFsyXSAmIDB4MjApID4+IDU7XG4gICAgICAgICAgY29uc3QgYml0RGVwdGggPSBwcm9maWxlID09PSAyICYmIGhpZ2hCaXREZXB0aCA/IHR3ZWx2ZUJpdCA/IDEyIDogMTAgOiBoaWdoQml0RGVwdGggPyAxMCA6IDg7XG4gICAgICAgICAgY29uc3QgbW9ub2Nocm9tZSA9IChhdjFDQm94WzJdICYgMHgxMCkgPj4gNDtcbiAgICAgICAgICBjb25zdCBjaHJvbWFTdWJzYW1wbGluZ1ggPSAoYXYxQ0JveFsyXSAmIDB4MDgpID4+IDM7XG4gICAgICAgICAgY29uc3QgY2hyb21hU3Vic2FtcGxpbmdZID0gKGF2MUNCb3hbMl0gJiAweDA0KSA+PiAyO1xuICAgICAgICAgIGNvbnN0IGNocm9tYVNhbXBsZVBvc2l0aW9uID0gYXYxQ0JveFsyXSAmIDB4MDM7XG4gICAgICAgICAgLy8gVE9ETzogcGFyc2UgY29sb3JfZGVzY3JpcHRpb25fcHJlc2VudF9mbGFnXG4gICAgICAgICAgLy8gZGVmYXVsdCBpdCB0byBCVC43MDkvbGltaXRlZCByYW5nZSBmb3Igbm93XG4gICAgICAgICAgLy8gbW9yZSBpbmZvIGh0dHBzOi8vYW9tZWRpYWNvZGVjLmdpdGh1Yi5pby9hdjEtaXNvYm1mZi8jYXYxY29kZWNjb25maWd1cmF0aW9uYm94LXN5bnRheFxuICAgICAgICAgIGNvbnN0IGNvbG9yUHJpbWFyaWVzID0gMTtcbiAgICAgICAgICBjb25zdCB0cmFuc2ZlckNoYXJhY3RlcmlzdGljcyA9IDE7XG4gICAgICAgICAgY29uc3QgbWF0cml4Q29lZmZpY2llbnRzID0gMTtcbiAgICAgICAgICBjb25zdCB2aWRlb0Z1bGxSYW5nZUZsYWcgPSAwO1xuICAgICAgICAgIGNvZGVjICs9ICcuJyArIHByb2ZpbGUgKyAnLicgKyBhZGRMZWFkaW5nWmVybyhsZXZlbCkgKyB0aWVyRmxhZyArICcuJyArIGFkZExlYWRpbmdaZXJvKGJpdERlcHRoKSArICcuJyArIG1vbm9jaHJvbWUgKyAnLicgKyBjaHJvbWFTdWJzYW1wbGluZ1ggKyBjaHJvbWFTdWJzYW1wbGluZ1kgKyBjaHJvbWFTYW1wbGVQb3NpdGlvbiArICcuJyArIGFkZExlYWRpbmdaZXJvKGNvbG9yUHJpbWFyaWVzKSArICcuJyArIGFkZExlYWRpbmdaZXJvKHRyYW5zZmVyQ2hhcmFjdGVyaXN0aWNzKSArICcuJyArIGFkZExlYWRpbmdaZXJvKG1hdHJpeENvZWZmaWNpZW50cykgKyAnLicgKyB2aWRlb0Z1bGxSYW5nZUZsYWc7XG4gICAgICAgICAgc3VwcGxlbWVudGFsID0gcGFyc2VTdXBwbGVtZW50YWxEb1ZpQ29kZWMoJ2RhdjEnLCBzYW1wbGVFbnRyaWVzRW5kKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGNvZGVjLFxuICAgIGVuY3J5cHRlZCxcbiAgICBzdXBwbGVtZW50YWxcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlU3VwcGxlbWVudGFsRG9WaUNvZGVjKGZvdXJDQywgc2FtcGxlRW50cmllc0VuZCkge1xuICBjb25zdCBkdnZDUmVzdWx0ID0gZmluZEJveChzYW1wbGVFbnRyaWVzRW5kLCBbJ2R2dkMnXSk7IC8vIHVzZWQgYnkgRG9WaSBQcm9maWxlIDggdG8gMTBcbiAgY29uc3QgZHZYQ0JveCA9IGR2dkNSZXN1bHQubGVuZ3RoID8gZHZ2Q1Jlc3VsdFswXSA6IGZpbmRCb3goc2FtcGxlRW50cmllc0VuZCwgWydkdmNDJ10pWzBdOyAvLyB1c2VkIGJ5IERvVmkgUHJvZmlsZXMgdXAgdG8gNyBhbmQgMjBcbiAgaWYgKGR2WENCb3gpIHtcbiAgICBjb25zdCBkb1ZpUHJvZmlsZSA9IGR2WENCb3hbMl0gPj4gMSAmIDB4N2Y7XG4gICAgY29uc3QgZG9WaUxldmVsID0gZHZYQ0JveFsyXSA8PCA1ICYgMHgyMCB8IGR2WENCb3hbM10gPj4gMyAmIDB4MWY7XG4gICAgcmV0dXJuIGZvdXJDQyArICcuJyArIGFkZExlYWRpbmdaZXJvKGRvVmlQcm9maWxlKSArICcuJyArIGFkZExlYWRpbmdaZXJvKGRvVmlMZXZlbCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJldmVyc2UzMkJpdEludCh2YWwpIHtcbiAgbGV0IHJlc3VsdCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgIHJlc3VsdCB8PSAodmFsID4+IGkgJiAxKSA8PCAzMiAtIDEgLSBpO1xuICB9XG4gIHJldHVybiByZXN1bHQgPj4+IDA7XG59XG5mdW5jdGlvbiBza2lwQkVSSW50ZWdlcihieXRlcywgaSkge1xuICBjb25zdCBsaW1pdCA9IGkgKyA1O1xuICB3aGlsZSAoYnl0ZXNbaSsrXSAmIDB4ODAgJiYgaSA8IGxpbWl0KSB7XG4gICAgLyogZG8gbm90aGluZyAqL1xuICB9XG4gIHJldHVybiBpO1xufVxuZnVuY3Rpb24gdG9IZXgoeCkge1xuICByZXR1cm4gKCcwJyArIHgudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpLnNsaWNlKC0yKTtcbn1cbmZ1bmN0aW9uIGFkZExlYWRpbmdaZXJvKG51bSkge1xuICByZXR1cm4gKG51bSA8IDEwID8gJzAnIDogJycpICsgbnVtO1xufVxuZnVuY3Rpb24gcGF0Y2hFbmN5cHRpb25EYXRhKGluaXRTZWdtZW50LCBkZWNyeXB0ZGF0YSkge1xuICBpZiAoIWluaXRTZWdtZW50IHx8ICFkZWNyeXB0ZGF0YSkge1xuICAgIHJldHVybiBpbml0U2VnbWVudDtcbiAgfVxuICBjb25zdCBrZXlJZCA9IGRlY3J5cHRkYXRhLmtleUlkO1xuICBpZiAoa2V5SWQgJiYgZGVjcnlwdGRhdGEuaXNDb21tb25FbmNyeXB0aW9uKSB7XG4gICAgY29uc3QgdHJha3MgPSBmaW5kQm94KGluaXRTZWdtZW50LCBbJ21vb3YnLCAndHJhayddKTtcbiAgICB0cmFrcy5mb3JFYWNoKHRyYWsgPT4ge1xuICAgICAgY29uc3Qgc3RzZCA9IGZpbmRCb3godHJhaywgWydtZGlhJywgJ21pbmYnLCAnc3RibCcsICdzdHNkJ10pWzBdO1xuXG4gICAgICAvLyBza2lwIHRoZSBzYW1wbGUgZW50cnkgY291bnRcbiAgICAgIGNvbnN0IHNhbXBsZUVudHJpZXMgPSBzdHNkLnN1YmFycmF5KDgpO1xuICAgICAgbGV0IGVuY0JveGVzID0gZmluZEJveChzYW1wbGVFbnRyaWVzLCBbJ2VuY2EnXSk7XG4gICAgICBjb25zdCBpc0F1ZGlvID0gZW5jQm94ZXMubGVuZ3RoID4gMDtcbiAgICAgIGlmICghaXNBdWRpbykge1xuICAgICAgICBlbmNCb3hlcyA9IGZpbmRCb3goc2FtcGxlRW50cmllcywgWydlbmN2J10pO1xuICAgICAgfVxuICAgICAgZW5jQm94ZXMuZm9yRWFjaChlbmMgPT4ge1xuICAgICAgICBjb25zdCBlbmNCb3hDaGlsZHJlbiA9IGlzQXVkaW8gPyBlbmMuc3ViYXJyYXkoMjgpIDogZW5jLnN1YmFycmF5KDc4KTtcbiAgICAgICAgY29uc3Qgc2luZkJveGVzID0gZmluZEJveChlbmNCb3hDaGlsZHJlbiwgWydzaW5mJ10pO1xuICAgICAgICBzaW5mQm94ZXMuZm9yRWFjaChzaW5mID0+IHtcbiAgICAgICAgICBjb25zdCB0ZW5jID0gcGFyc2VTaW5mKHNpbmYpO1xuICAgICAgICAgIGlmICh0ZW5jKSB7XG4gICAgICAgICAgICAvLyBMb29rIGZvciBkZWZhdWx0IGtleSBpZCAoa2V5SUQgb2Zmc2V0IGlzIGFsd2F5cyA4IHdpdGhpbiB0aGUgdGVuYyBib3gpOlxuICAgICAgICAgICAgY29uc3QgdGVuY0tleUlkID0gdGVuYy5zdWJhcnJheSg4LCAyNCk7XG4gICAgICAgICAgICBpZiAoIXRlbmNLZXlJZC5zb21lKGIgPT4gYiAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgW2VtZV0gUGF0Y2hpbmcga2V5SWQgaW4gJ2VuYyR7aXNBdWRpbyA/ICdhJyA6ICd2J30+c2luZj4+dGVuYycgYm94OiAke0hleC5oZXhEdW1wKHRlbmNLZXlJZCl9IC0+ICR7SGV4LmhleER1bXAoa2V5SWQpfWApO1xuICAgICAgICAgICAgICB0ZW5jLnNldChrZXlJZCwgOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBpbml0U2VnbWVudDtcbn1cbmZ1bmN0aW9uIHBhcnNlU2luZihzaW5mKSB7XG4gIGNvbnN0IHNjaG0gPSBmaW5kQm94KHNpbmYsIFsnc2NobSddKVswXTtcbiAgaWYgKHNjaG0pIHtcbiAgICBjb25zdCBzY2hlbWUgPSBiaW4yc3RyKHNjaG0uc3ViYXJyYXkoNCwgOCkpO1xuICAgIGlmIChzY2hlbWUgPT09ICdjYmNzJyB8fCBzY2hlbWUgPT09ICdjZW5jJykge1xuICAgICAgcmV0dXJuIGZpbmRCb3goc2luZiwgWydzY2hpJywgJ3RlbmMnXSlbMF07XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKlxuICBGb3IgUmVmZXJlbmNlOlxuICBhbGlnbmVkKDgpIGNsYXNzIFRyYWNrRnJhZ21lbnRIZWFkZXJCb3hcbiAgICAgICAgICAgZXh0ZW5kcyBGdWxsQm94KOKAmHRmaGTigJksIDAsIHRmX2ZsYWdzKXtcbiAgICAgdW5zaWduZWQgaW50KDMyKSAgdHJhY2tfSUQ7XG4gICAgIC8vIGFsbCB0aGUgZm9sbG93aW5nIGFyZSBvcHRpb25hbCBmaWVsZHNcbiAgICAgdW5zaWduZWQgaW50KDY0KSAgYmFzZV9kYXRhX29mZnNldDtcbiAgICAgdW5zaWduZWQgaW50KDMyKSAgc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4O1xuICAgICB1bnNpZ25lZCBpbnQoMzIpICBkZWZhdWx0X3NhbXBsZV9kdXJhdGlvbjtcbiAgICAgdW5zaWduZWQgaW50KDMyKSAgZGVmYXVsdF9zYW1wbGVfc2l6ZTtcbiAgICAgdW5zaWduZWQgaW50KDMyKSAgZGVmYXVsdF9zYW1wbGVfZmxhZ3NcbiAgfVxuICovXG5cbmZ1bmN0aW9uIGdldFNhbXBsZURhdGEoZGF0YSwgaW5pdERhdGEsIGxvZ2dlcikge1xuICBjb25zdCB0cmFja3MgPSB7fTtcbiAgY29uc3QgdHJhZnMgPSBmaW5kQm94KGRhdGEsIFsnbW9vZicsICd0cmFmJ10pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdHJhZiA9IHRyYWZzW2ldO1xuICAgIC8vIFRoZXJlIGlzIG9ubHkgb25lIHRmaGQgJiB0cnVuIHBlciB0cmFmXG4gICAgLy8gVGhpcyBpcyB0cnVlIGZvciBDTUFGIHN0eWxlIGNvbnRlbnQsIGFuZCB3ZSBzaG91bGQgcGVyaGFwcyBjaGVjayB0aGUgZnR5cFxuICAgIC8vIGFuZCBvbmx5IGxvb2sgZm9yIGEgc2luZ2xlIHRydW4gdGhlbiwgYnV0IGZvciBJU09CTUZGIHdlIHNob3VsZCBjaGVja1xuICAgIC8vIGZvciBtdWx0aXBsZSB0cmFjayBydW5zLlxuICAgIGNvbnN0IHRmaGQgPSBmaW5kQm94KHRyYWYsIFsndGZoZCddKVswXTtcbiAgICAvLyBnZXQgdGhlIHRyYWNrIGlkIGZyb20gdGhlIHRmaGRcbiAgICBjb25zdCBpZCA9IHJlYWRVaW50MzIodGZoZCwgNCk7XG4gICAgY29uc3QgdHJhY2sgPSBpbml0RGF0YVtpZF07XG4gICAgaWYgKCF0cmFjaykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHRyYWNrVGltZXMgPSB0cmFja3NbaWRdIHx8ICh0cmFja3NbaWRdID0ge1xuICAgICAgc3RhcnQ6IE5hTixcbiAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgc2FtcGxlQ291bnQ6IDAsXG4gICAgICB0aW1lc2NhbGU6IHRyYWNrLnRpbWVzY2FsZSxcbiAgICAgIHR5cGU6IHRyYWNrLnR5cGVcbiAgICB9KTtcbiAgICAvLyBnZXQgc3RhcnQgRFRTXG4gICAgY29uc3QgdGZkdCA9IGZpbmRCb3godHJhZiwgWyd0ZmR0J10pWzBdO1xuICAgIGlmICh0ZmR0KSB7XG4gICAgICBjb25zdCB2ZXJzaW9uID0gdGZkdFswXTtcbiAgICAgIGxldCBiYXNlVGltZSA9IHJlYWRVaW50MzIodGZkdCwgNCk7XG4gICAgICBpZiAodmVyc2lvbiA9PT0gMSkge1xuICAgICAgICAvLyBJZiB2YWx1ZSBpcyB0b28gbGFyZ2UsIGFzc3VtZSBzaWduZWQgNjQtYml0LiBOZWdhdGl2ZSB0cmFjayBmcmFnbWVudCBkZWNvZGUgdGltZXMgYXJlIGludmFsaWQsIGJ1dCB0aGV5IGV4aXN0IGluIHRoZSB3aWxkLlxuICAgICAgICAvLyBUaGlzIHByZXZlbnRzIGxhcmdlIHZhbHVlcyBmcm9tIGJlaW5nIHVzZWQgZm9yIGluaXRQVFMsIHdoaWNoIGNhbiBjYXVzZSBwbGF5bGlzdCBzeW5jIGlzc3Vlcy5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzUzMDNcbiAgICAgICAgaWYgKGJhc2VUaW1lID09PSBVSU5UMzJfTUFYJDEpIHtcbiAgICAgICAgICBsb2dnZXIud2FybihgW21wNC1kZW11eGVyXTogSWdub3JpbmcgYXNzdW1lZCBpbnZhbGlkIHNpZ25lZCA2NC1iaXQgdHJhY2sgZnJhZ21lbnQgZGVjb2RlIHRpbWVgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBiYXNlVGltZSAqPSBVSU5UMzJfTUFYJDEgKyAxO1xuICAgICAgICAgIGJhc2VUaW1lICs9IHJlYWRVaW50MzIodGZkdCwgOCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0Zpbml0ZU51bWJlcihiYXNlVGltZSkgJiYgKCFpc0Zpbml0ZU51bWJlcih0cmFja1RpbWVzLnN0YXJ0KSB8fCBiYXNlVGltZSA8IHRyYWNrVGltZXMuc3RhcnQpKSB7XG4gICAgICAgIHRyYWNrVGltZXMuc3RhcnQgPSBiYXNlVGltZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdHJhY2tEZWZhdWx0ID0gdHJhY2suZGVmYXVsdDtcbiAgICBjb25zdCB0ZmhkRmxhZ3MgPSByZWFkVWludDMyKHRmaGQsIDApIHwgKHRyYWNrRGVmYXVsdCA9PSBudWxsID8gdm9pZCAwIDogdHJhY2tEZWZhdWx0LmZsYWdzKTtcbiAgICBsZXQgZGVmYXVsdFNhbXBsZUR1cmF0aW9uID0gKHRyYWNrRGVmYXVsdCA9PSBudWxsID8gdm9pZCAwIDogdHJhY2tEZWZhdWx0LmR1cmF0aW9uKSB8fCAwO1xuICAgIGlmICh0ZmhkRmxhZ3MgJiAweDAwMDAwOCkge1xuICAgICAgLy8gMHgwMDAwMDggaW5kaWNhdGVzIHRoZSBwcmVzZW5jZSBvZiB0aGUgZGVmYXVsdF9zYW1wbGVfZHVyYXRpb24gZmllbGRcbiAgICAgIGlmICh0ZmhkRmxhZ3MgJiAweDAwMDAwMikge1xuICAgICAgICAvLyAweDAwMDAwMiBpbmRpY2F0ZXMgdGhlIHByZXNlbmNlIG9mIHRoZSBzYW1wbGVfZGVzY3JpcHRpb25faW5kZXggZmllbGQsIHdoaWNoIHByZWNlZGVzIGRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uXG4gICAgICAgIC8vIElmIHByZXNlbnQsIHRoZSBkZWZhdWx0X3NhbXBsZV9kdXJhdGlvbiBleGlzdHMgYXQgYnl0ZSBvZmZzZXQgMTJcbiAgICAgICAgZGVmYXVsdFNhbXBsZUR1cmF0aW9uID0gcmVhZFVpbnQzMih0ZmhkLCAxMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPdGhlcndpc2UsIHRoZSBkdXJhdGlvbiBpcyBhdCBieXRlIG9mZnNldCA4XG4gICAgICAgIGRlZmF1bHRTYW1wbGVEdXJhdGlvbiA9IHJlYWRVaW50MzIodGZoZCwgOCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRydW5zID0gZmluZEJveCh0cmFmLCBbJ3RydW4nXSk7XG4gICAgbGV0IHNhbXBsZURUUyA9IHRyYWNrVGltZXMuc3RhcnQgfHwgMDtcbiAgICBsZXQgcmF3RHVyYXRpb24gPSAwO1xuICAgIGxldCBzYW1wbGVEdXJhdGlvbiA9IGRlZmF1bHRTYW1wbGVEdXJhdGlvbjtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRydW5zLmxlbmd0aDsgaisrKSB7XG4gICAgICBjb25zdCB0cnVuID0gdHJ1bnNbal07XG4gICAgICBjb25zdCBzYW1wbGVDb3VudCA9IHJlYWRVaW50MzIodHJ1biwgNCk7XG4gICAgICBjb25zdCBzYW1wbGVJbmRleCA9IHRyYWNrVGltZXMuc2FtcGxlQ291bnQ7XG4gICAgICB0cmFja1RpbWVzLnNhbXBsZUNvdW50ICs9IHNhbXBsZUNvdW50O1xuICAgICAgLy8gR2V0IGR1cmF0aW9uIGZyb20gc2FtcGxlc1xuICAgICAgY29uc3QgZGF0YU9mZnNldFByZXNlbnQgPSB0cnVuWzNdICYgMHgwMTtcbiAgICAgIGNvbnN0IGZpcnN0U2FtcGxlRmxhZ3NQcmVzZW50ID0gdHJ1blszXSAmIDB4MDQ7XG4gICAgICBjb25zdCBzYW1wbGVEdXJhdGlvblByZXNlbnQgPSB0cnVuWzJdICYgMHgwMTtcbiAgICAgIGNvbnN0IHNhbXBsZVNpemVQcmVzZW50ID0gdHJ1blsyXSAmIDB4MDI7XG4gICAgICBjb25zdCBzYW1wbGVGbGFnc1ByZXNlbnQgPSB0cnVuWzJdICYgMHgwNDtcbiAgICAgIGNvbnN0IHNhbXBsZUNvbXBvc2l0aW9uVGltZU9mZnNldFByZXNlbnQgPSB0cnVuWzJdICYgMHgwODtcbiAgICAgIGxldCBvZmZzZXQgPSA4O1xuICAgICAgbGV0IHJlbWFpbmluZyA9IHNhbXBsZUNvdW50O1xuICAgICAgaWYgKGRhdGFPZmZzZXRQcmVzZW50KSB7XG4gICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgfVxuICAgICAgaWYgKGZpcnN0U2FtcGxlRmxhZ3NQcmVzZW50ICYmIHNhbXBsZUNvdW50KSB7XG4gICAgICAgIGNvbnN0IGlzTm9uU3luY1NhbXBsZSA9IHRydW5bb2Zmc2V0ICsgMV0gJiAweDAxO1xuICAgICAgICBpZiAoIWlzTm9uU3luY1NhbXBsZSAmJiB0cmFja1RpbWVzLmtleUZyYW1lSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRyYWNrVGltZXMua2V5RnJhbWVJbmRleCA9IHNhbXBsZUluZGV4O1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICBpZiAoc2FtcGxlRHVyYXRpb25QcmVzZW50KSB7XG4gICAgICAgICAgc2FtcGxlRHVyYXRpb24gPSByZWFkVWludDMyKHRydW4sIG9mZnNldCk7XG4gICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2FtcGxlRHVyYXRpb24gPSBkZWZhdWx0U2FtcGxlRHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNhbXBsZVNpemVQcmVzZW50KSB7XG4gICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNhbXBsZUNvbXBvc2l0aW9uVGltZU9mZnNldFByZXNlbnQpIHtcbiAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgfVxuICAgICAgICBzYW1wbGVEVFMgKz0gc2FtcGxlRHVyYXRpb247XG4gICAgICAgIHJhd0R1cmF0aW9uICs9IHNhbXBsZUR1cmF0aW9uO1xuICAgICAgICByZW1haW5pbmctLTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChyZW1haW5pbmctLSkge1xuICAgICAgICBpZiAoc2FtcGxlRHVyYXRpb25QcmVzZW50KSB7XG4gICAgICAgICAgc2FtcGxlRHVyYXRpb24gPSByZWFkVWludDMyKHRydW4sIG9mZnNldCk7XG4gICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2FtcGxlRHVyYXRpb24gPSBkZWZhdWx0U2FtcGxlRHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNhbXBsZVNpemVQcmVzZW50KSB7XG4gICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNhbXBsZUZsYWdzUHJlc2VudCkge1xuICAgICAgICAgIGNvbnN0IGlzTm9uU3luY1NhbXBsZSA9IHRydW5bb2Zmc2V0ICsgMV0gJiAweDAxO1xuICAgICAgICAgIGlmICghaXNOb25TeW5jU2FtcGxlKSB7XG4gICAgICAgICAgICBpZiAodHJhY2tUaW1lcy5rZXlGcmFtZUluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdHJhY2tUaW1lcy5rZXlGcmFtZUluZGV4ID0gdHJhY2tUaW1lcy5zYW1wbGVDb3VudCAtIChyZW1haW5pbmcgKyAxKTtcbiAgICAgICAgICAgICAgdHJhY2tUaW1lcy5rZXlGcmFtZVN0YXJ0ID0gc2FtcGxlRFRTO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2FtcGxlQ29tcG9zaXRpb25UaW1lT2Zmc2V0UHJlc2VudCkge1xuICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICB9XG4gICAgICAgIHNhbXBsZURUUyArPSBzYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgcmF3RHVyYXRpb24gKz0gc2FtcGxlRHVyYXRpb247XG4gICAgICB9XG4gICAgICBpZiAoIXJhd0R1cmF0aW9uICYmIGRlZmF1bHRTYW1wbGVEdXJhdGlvbikge1xuICAgICAgICByYXdEdXJhdGlvbiArPSBkZWZhdWx0U2FtcGxlRHVyYXRpb24gKiBzYW1wbGVDb3VudDtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJhY2tUaW1lcy5kdXJhdGlvbiArPSByYXdEdXJhdGlvbjtcbiAgfVxuICBpZiAoIU9iamVjdC5rZXlzKHRyYWNrcykuc29tZSh0cmFja0lkID0+IHRyYWNrc1t0cmFja0lkXS5kdXJhdGlvbikpIHtcbiAgICAvLyBJZiBkdXJhdGlvbiBzYW1wbGVzIGFyZSBub3QgYXZhaWxhYmxlIGluIHRoZSB0cmFmIHVzZSBzaWR4IHN1YnNlZ21lbnRfZHVyYXRpb25cbiAgICBsZXQgc2lkeE1pblN0YXJ0ID0gSW5maW5pdHk7XG4gICAgbGV0IHNpZHhNYXhFbmQgPSAwO1xuICAgIGNvbnN0IHNpZHhzID0gZmluZEJveChkYXRhLCBbJ3NpZHgnXSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWR4cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc2lkeCA9IHBhcnNlU2VnbWVudEluZGV4KHNpZHhzW2ldKTtcbiAgICAgIGlmIChzaWR4ICE9IG51bGwgJiYgc2lkeC5yZWZlcmVuY2VzKSB7XG4gICAgICAgIHNpZHhNaW5TdGFydCA9IE1hdGgubWluKHNpZHhNaW5TdGFydCwgc2lkeC5lYXJsaWVzdFByZXNlbnRhdGlvblRpbWUgLyBzaWR4LnRpbWVzY2FsZSk7XG4gICAgICAgIGNvbnN0IHN1YlNlZ21lbnREdXJhdGlvbiA9IHNpZHgucmVmZXJlbmNlcy5yZWR1Y2UoKGR1ciwgcmVmKSA9PiBkdXIgKyByZWYuaW5mby5kdXJhdGlvbiB8fCAwLCAwKTtcbiAgICAgICAgc2lkeE1heEVuZCA9IE1hdGgubWF4KHNpZHhNYXhFbmQsIHN1YlNlZ21lbnREdXJhdGlvbiArIHNpZHguZWFybGllc3RQcmVzZW50YXRpb25UaW1lIC8gc2lkeC50aW1lc2NhbGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2lkeE1heEVuZCAmJiBpc0Zpbml0ZU51bWJlcihzaWR4TWF4RW5kKSkge1xuICAgICAgT2JqZWN0LmtleXModHJhY2tzKS5mb3JFYWNoKHRyYWNrSWQgPT4ge1xuICAgICAgICBpZiAoIXRyYWNrc1t0cmFja0lkXS5kdXJhdGlvbikge1xuICAgICAgICAgIHRyYWNrc1t0cmFja0lkXS5kdXJhdGlvbiA9IHNpZHhNYXhFbmQgKiB0cmFja3NbdHJhY2tJZF0udGltZXNjYWxlIC0gdHJhY2tzW3RyYWNrSWRdLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRyYWNrcztcbn1cblxuLy8gVE9ETzogQ2hlY2sgaWYgdGhlIGxhc3QgbW9vZittZGF0IHBhaXIgaXMgcGFydCBvZiB0aGUgdmFsaWQgcmFuZ2VcbmZ1bmN0aW9uIHNlZ21lbnRWYWxpZFJhbmdlKGRhdGEpIHtcbiAgY29uc3Qgc2VnbWVudGVkUmFuZ2UgPSB7XG4gICAgdmFsaWQ6IG51bGwsXG4gICAgcmVtYWluZGVyOiBudWxsXG4gIH07XG4gIGNvbnN0IG1vb2ZzID0gZmluZEJveChkYXRhLCBbJ21vb2YnXSk7XG4gIGlmIChtb29mcy5sZW5ndGggPCAyKSB7XG4gICAgc2VnbWVudGVkUmFuZ2UucmVtYWluZGVyID0gZGF0YTtcbiAgICByZXR1cm4gc2VnbWVudGVkUmFuZ2U7XG4gIH1cbiAgY29uc3QgbGFzdCA9IG1vb2ZzW21vb2ZzLmxlbmd0aCAtIDFdO1xuICAvLyBPZmZzZXQgYnkgOCBieXRlczsgZmluZEJveCBvZmZzZXRzIHRoZSBzdGFydCBieSBhcyBtdWNoXG4gIHNlZ21lbnRlZFJhbmdlLnZhbGlkID0gZGF0YS5zbGljZSgwLCBsYXN0LmJ5dGVPZmZzZXQgLSA4KTtcbiAgc2VnbWVudGVkUmFuZ2UucmVtYWluZGVyID0gZGF0YS5zbGljZShsYXN0LmJ5dGVPZmZzZXQgLSA4KTtcbiAgcmV0dXJuIHNlZ21lbnRlZFJhbmdlO1xufVxuZnVuY3Rpb24gYXBwZW5kVWludDhBcnJheShkYXRhMSwgZGF0YTIpIHtcbiAgY29uc3QgdGVtcCA9IG5ldyBVaW50OEFycmF5KGRhdGExLmxlbmd0aCArIGRhdGEyLmxlbmd0aCk7XG4gIHRlbXAuc2V0KGRhdGExKTtcbiAgdGVtcC5zZXQoZGF0YTIsIGRhdGExLmxlbmd0aCk7XG4gIHJldHVybiB0ZW1wO1xufVxuZnVuY3Rpb24gcGFyc2VTYW1wbGVzKHRpbWVPZmZzZXQsIHRyYWNrKSB7XG4gIGNvbnN0IHNlaVNhbXBsZXMgPSBbXTtcbiAgY29uc3QgdmlkZW9EYXRhID0gdHJhY2suc2FtcGxlcztcbiAgY29uc3QgdGltZXNjYWxlID0gdHJhY2sudGltZXNjYWxlO1xuICBjb25zdCB0cmFja0lkID0gdHJhY2suaWQ7XG4gIGxldCBpc0hFVkNGbGF2b3IgPSBmYWxzZTtcbiAgY29uc3QgbW9vZnMgPSBmaW5kQm94KHZpZGVvRGF0YSwgWydtb29mJ10pO1xuICBtb29mcy5tYXAobW9vZiA9PiB7XG4gICAgY29uc3QgbW9vZk9mZnNldCA9IG1vb2YuYnl0ZU9mZnNldCAtIDg7XG4gICAgY29uc3QgdHJhZnMgPSBmaW5kQm94KG1vb2YsIFsndHJhZiddKTtcbiAgICB0cmFmcy5tYXAodHJhZiA9PiB7XG4gICAgICAvLyBnZXQgdGhlIGJhc2UgbWVkaWEgZGVjb2RlIHRpbWUgZnJvbSB0aGUgdGZkdFxuICAgICAgY29uc3QgYmFzZVRpbWUgPSBmaW5kQm94KHRyYWYsIFsndGZkdCddKS5tYXAodGZkdCA9PiB7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSB0ZmR0WzBdO1xuICAgICAgICBsZXQgcmVzdWx0ID0gcmVhZFVpbnQzMih0ZmR0LCA0KTtcbiAgICAgICAgaWYgKHZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgICByZXN1bHQgKj0gTWF0aC5wb3coMiwgMzIpO1xuICAgICAgICAgIHJlc3VsdCArPSByZWFkVWludDMyKHRmZHQsIDgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgLyB0aW1lc2NhbGU7XG4gICAgICB9KVswXTtcbiAgICAgIGlmIChiYXNlVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRpbWVPZmZzZXQgPSBiYXNlVGltZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmaW5kQm94KHRyYWYsIFsndGZoZCddKS5tYXAodGZoZCA9PiB7XG4gICAgICAgIGNvbnN0IGlkID0gcmVhZFVpbnQzMih0ZmhkLCA0KTtcbiAgICAgICAgY29uc3QgdGZoZEZsYWdzID0gcmVhZFVpbnQzMih0ZmhkLCAwKSAmIDB4ZmZmZmZmO1xuICAgICAgICBjb25zdCBiYXNlRGF0YU9mZnNldFByZXNlbnQgPSAodGZoZEZsYWdzICYgMHgwMDAwMDEpICE9PSAwO1xuICAgICAgICBjb25zdCBzYW1wbGVEZXNjcmlwdGlvbkluZGV4UHJlc2VudCA9ICh0ZmhkRmxhZ3MgJiAweDAwMDAwMikgIT09IDA7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRTYW1wbGVEdXJhdGlvblByZXNlbnQgPSAodGZoZEZsYWdzICYgMHgwMDAwMDgpICE9PSAwO1xuICAgICAgICBsZXQgZGVmYXVsdFNhbXBsZUR1cmF0aW9uID0gMDtcbiAgICAgICAgY29uc3QgZGVmYXVsdFNhbXBsZVNpemVQcmVzZW50ID0gKHRmaGRGbGFncyAmIDB4MDAwMDEwKSAhPT0gMDtcbiAgICAgICAgbGV0IGRlZmF1bHRTYW1wbGVTaXplID0gMDtcbiAgICAgICAgY29uc3QgZGVmYXVsdFNhbXBsZUZsYWdzUHJlc2VudCA9ICh0ZmhkRmxhZ3MgJiAweDAwMDAyMCkgIT09IDA7XG4gICAgICAgIGxldCB0ZmhkT2Zmc2V0ID0gODtcbiAgICAgICAgaWYgKGlkID09PSB0cmFja0lkKSB7XG4gICAgICAgICAgaWYgKGJhc2VEYXRhT2Zmc2V0UHJlc2VudCkge1xuICAgICAgICAgICAgdGZoZE9mZnNldCArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2FtcGxlRGVzY3JpcHRpb25JbmRleFByZXNlbnQpIHtcbiAgICAgICAgICAgIHRmaGRPZmZzZXQgKz0gNDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRlZmF1bHRTYW1wbGVEdXJhdGlvblByZXNlbnQpIHtcbiAgICAgICAgICAgIGRlZmF1bHRTYW1wbGVEdXJhdGlvbiA9IHJlYWRVaW50MzIodGZoZCwgdGZoZE9mZnNldCk7XG4gICAgICAgICAgICB0ZmhkT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZWZhdWx0U2FtcGxlU2l6ZVByZXNlbnQpIHtcbiAgICAgICAgICAgIGRlZmF1bHRTYW1wbGVTaXplID0gcmVhZFVpbnQzMih0ZmhkLCB0ZmhkT2Zmc2V0KTtcbiAgICAgICAgICAgIHRmaGRPZmZzZXQgKz0gNDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRlZmF1bHRTYW1wbGVGbGFnc1ByZXNlbnQpIHtcbiAgICAgICAgICAgIHRmaGRPZmZzZXQgKz0gNDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRyYWNrLnR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICAgIGlzSEVWQ0ZsYXZvciA9IGlzSEVWQyh0cmFjay5jb2RlYyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpbmRCb3godHJhZiwgWyd0cnVuJ10pLm1hcCh0cnVuID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZlcnNpb24gPSB0cnVuWzBdO1xuICAgICAgICAgICAgY29uc3QgZmxhZ3MgPSByZWFkVWludDMyKHRydW4sIDApICYgMHhmZmZmZmY7XG4gICAgICAgICAgICBjb25zdCBkYXRhT2Zmc2V0UHJlc2VudCA9IChmbGFncyAmIDB4MDAwMDAxKSAhPT0gMDtcbiAgICAgICAgICAgIGxldCBkYXRhT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0U2FtcGxlRmxhZ3NQcmVzZW50ID0gKGZsYWdzICYgMHgwMDAwMDQpICE9PSAwO1xuICAgICAgICAgICAgY29uc3Qgc2FtcGxlRHVyYXRpb25QcmVzZW50ID0gKGZsYWdzICYgMHgwMDAxMDApICE9PSAwO1xuICAgICAgICAgICAgbGV0IHNhbXBsZUR1cmF0aW9uID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZVNpemVQcmVzZW50ID0gKGZsYWdzICYgMHgwMDAyMDApICE9PSAwO1xuICAgICAgICAgICAgbGV0IHNhbXBsZVNpemUgPSAwO1xuICAgICAgICAgICAgY29uc3Qgc2FtcGxlRmxhZ3NQcmVzZW50ID0gKGZsYWdzICYgMHgwMDA0MDApICE9PSAwO1xuICAgICAgICAgICAgY29uc3Qgc2FtcGxlQ29tcG9zaXRpb25PZmZzZXRzUHJlc2VudCA9IChmbGFncyAmIDB4MDAwODAwKSAhPT0gMDtcbiAgICAgICAgICAgIGxldCBjb21wb3NpdGlvbk9mZnNldCA9IDA7XG4gICAgICAgICAgICBjb25zdCBzYW1wbGVDb3VudCA9IHJlYWRVaW50MzIodHJ1biwgNCk7XG4gICAgICAgICAgICBsZXQgdHJ1bk9mZnNldCA9IDg7IC8vIHBhc3QgdmVyc2lvbiwgZmxhZ3MsIGFuZCBzYW1wbGUgY291bnRcblxuICAgICAgICAgICAgaWYgKGRhdGFPZmZzZXRQcmVzZW50KSB7XG4gICAgICAgICAgICAgIGRhdGFPZmZzZXQgPSByZWFkVWludDMyKHRydW4sIHRydW5PZmZzZXQpO1xuICAgICAgICAgICAgICB0cnVuT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlyc3RTYW1wbGVGbGFnc1ByZXNlbnQpIHtcbiAgICAgICAgICAgICAgdHJ1bk9mZnNldCArPSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHNhbXBsZU9mZnNldCA9IGRhdGFPZmZzZXQgKyBtb29mT2Zmc2V0O1xuICAgICAgICAgICAgZm9yIChsZXQgaXggPSAwOyBpeCA8IHNhbXBsZUNvdW50OyBpeCsrKSB7XG4gICAgICAgICAgICAgIGlmIChzYW1wbGVEdXJhdGlvblByZXNlbnQpIHtcbiAgICAgICAgICAgICAgICBzYW1wbGVEdXJhdGlvbiA9IHJlYWRVaW50MzIodHJ1biwgdHJ1bk9mZnNldCk7XG4gICAgICAgICAgICAgICAgdHJ1bk9mZnNldCArPSA0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNhbXBsZUR1cmF0aW9uID0gZGVmYXVsdFNhbXBsZUR1cmF0aW9uO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzYW1wbGVTaXplUHJlc2VudCkge1xuICAgICAgICAgICAgICAgIHNhbXBsZVNpemUgPSByZWFkVWludDMyKHRydW4sIHRydW5PZmZzZXQpO1xuICAgICAgICAgICAgICAgIHRydW5PZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzYW1wbGVTaXplID0gZGVmYXVsdFNhbXBsZVNpemU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHNhbXBsZUZsYWdzUHJlc2VudCkge1xuICAgICAgICAgICAgICAgIHRydW5PZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoc2FtcGxlQ29tcG9zaXRpb25PZmZzZXRzUHJlc2VudCkge1xuICAgICAgICAgICAgICAgIGlmICh2ZXJzaW9uID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBjb21wb3NpdGlvbk9mZnNldCA9IHJlYWRVaW50MzIodHJ1biwgdHJ1bk9mZnNldCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNvbXBvc2l0aW9uT2Zmc2V0ID0gcmVhZFNpbnQzMih0cnVuLCB0cnVuT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ1bk9mZnNldCArPSA0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0cmFjay50eXBlID09PSBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU8pIHtcbiAgICAgICAgICAgICAgICBsZXQgbmFsdVRvdGFsU2l6ZSA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5hbHVUb3RhbFNpemUgPCBzYW1wbGVTaXplKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBuYWx1U2l6ZSA9IHJlYWRVaW50MzIodmlkZW9EYXRhLCBzYW1wbGVPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgc2FtcGxlT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNTRUlNZXNzYWdlKGlzSEVWQ0ZsYXZvciwgdmlkZW9EYXRhW3NhbXBsZU9mZnNldF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB2aWRlb0RhdGEuc3ViYXJyYXkoc2FtcGxlT2Zmc2V0LCBzYW1wbGVPZmZzZXQgKyBuYWx1U2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlU0VJTWVzc2FnZUZyb21OQUx1KGRhdGEsIGlzSEVWQ0ZsYXZvciA/IDIgOiAxLCB0aW1lT2Zmc2V0ICsgY29tcG9zaXRpb25PZmZzZXQgLyB0aW1lc2NhbGUsIHNlaVNhbXBsZXMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgc2FtcGxlT2Zmc2V0ICs9IG5hbHVTaXplO1xuICAgICAgICAgICAgICAgICAgbmFsdVRvdGFsU2l6ZSArPSBuYWx1U2l6ZSArIDQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRpbWVPZmZzZXQgKz0gc2FtcGxlRHVyYXRpb24gLyB0aW1lc2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHNlaVNhbXBsZXM7XG59XG5mdW5jdGlvbiBpc0hFVkMoY29kZWMpIHtcbiAgaWYgKCFjb2RlYykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBiYXNlQ29kZWMgPSBjb2RlYy5zdWJzdHJpbmcoMCwgNCk7XG4gIHJldHVybiBiYXNlQ29kZWMgPT09ICdodmMxJyB8fCBiYXNlQ29kZWMgPT09ICdoZXYxJyB8fFxuICAvLyBEb2xieSBWaXNpb25cbiAgYmFzZUNvZGVjID09PSAnZHZoMScgfHwgYmFzZUNvZGVjID09PSAnZHZoZSc7XG59XG5mdW5jdGlvbiBpc1NFSU1lc3NhZ2UoaXNIRVZDRmxhdm9yLCBuYWx1SGVhZGVyKSB7XG4gIGlmIChpc0hFVkNGbGF2b3IpIHtcbiAgICBjb25zdCBuYWx1VHlwZSA9IG5hbHVIZWFkZXIgPj4gMSAmIDB4M2Y7XG4gICAgcmV0dXJuIG5hbHVUeXBlID09PSAzOSB8fCBuYWx1VHlwZSA9PT0gNDA7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbmFsdVR5cGUgPSBuYWx1SGVhZGVyICYgMHgxZjtcbiAgICByZXR1cm4gbmFsdVR5cGUgPT09IDY7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlU0VJTWVzc2FnZUZyb21OQUx1KHVuZXNjYXBlZERhdGEsIGhlYWRlclNpemUsIHB0cywgc2FtcGxlcykge1xuICBjb25zdCBkYXRhID0gZGlzY2FyZEVQQih1bmVzY2FwZWREYXRhKTtcbiAgbGV0IHNlaVB0ciA9IDA7XG4gIC8vIHNraXAgbmFsIGhlYWRlclxuICBzZWlQdHIgKz0gaGVhZGVyU2l6ZTtcbiAgbGV0IHBheWxvYWRUeXBlID0gMDtcbiAgbGV0IHBheWxvYWRTaXplID0gMDtcbiAgbGV0IGIgPSAwO1xuICB3aGlsZSAoc2VpUHRyIDwgZGF0YS5sZW5ndGgpIHtcbiAgICBwYXlsb2FkVHlwZSA9IDA7XG4gICAgZG8ge1xuICAgICAgaWYgKHNlaVB0ciA+PSBkYXRhLmxlbmd0aCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGIgPSBkYXRhW3NlaVB0cisrXTtcbiAgICAgIHBheWxvYWRUeXBlICs9IGI7XG4gICAgfSB3aGlsZSAoYiA9PT0gMHhmZik7XG5cbiAgICAvLyBQYXJzZSBwYXlsb2FkIHNpemUuXG4gICAgcGF5bG9hZFNpemUgPSAwO1xuICAgIGRvIHtcbiAgICAgIGlmIChzZWlQdHIgPj0gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBiID0gZGF0YVtzZWlQdHIrK107XG4gICAgICBwYXlsb2FkU2l6ZSArPSBiO1xuICAgIH0gd2hpbGUgKGIgPT09IDB4ZmYpO1xuICAgIGNvbnN0IGxlZnRPdmVyID0gZGF0YS5sZW5ndGggLSBzZWlQdHI7XG4gICAgLy8gQ3JlYXRlIGEgdmFyaWFibGUgdG8gcHJvY2VzcyB0aGUgcGF5bG9hZFxuICAgIGxldCBwYXlQdHIgPSBzZWlQdHI7XG5cbiAgICAvLyBJbmNyZW1lbnQgdGhlIHNlaVB0ciB0byB0aGUgZW5kIG9mIHRoZSBwYXlsb2FkXG4gICAgaWYgKHBheWxvYWRTaXplIDwgbGVmdE92ZXIpIHtcbiAgICAgIHNlaVB0ciArPSBwYXlsb2FkU2l6ZTtcbiAgICB9IGVsc2UgaWYgKHBheWxvYWRTaXplID4gbGVmdE92ZXIpIHtcbiAgICAgIC8vIFNvbWUgdHlwZSBvZiBjb3JydXB0aW9uIGhhcyBoYXBwZW5lZD9cbiAgICAgIGxvZ2dlci5lcnJvcihgTWFsZm9ybWVkIFNFSSBwYXlsb2FkLiAke3BheWxvYWRTaXplfSBpcyB0b28gc21hbGwsIG9ubHkgJHtsZWZ0T3Zlcn0gYnl0ZXMgbGVmdCB0byBwYXJzZS5gKTtcbiAgICAgIC8vIFdlIG1pZ2h0IGJlIGFibGUgdG8gcGFyc2Ugc29tZSBkYXRhLCBidXQgbGV0J3MgYmUgc2FmZSBhbmQgaWdub3JlIGl0LlxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChwYXlsb2FkVHlwZSA9PT0gNCkge1xuICAgICAgY29uc3QgY291bnRyeUNvZGUgPSBkYXRhW3BheVB0cisrXTtcbiAgICAgIGlmIChjb3VudHJ5Q29kZSA9PT0gMTgxKSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyQ29kZSA9IHJlYWRVaW50MTYoZGF0YSwgcGF5UHRyKTtcbiAgICAgICAgcGF5UHRyICs9IDI7XG4gICAgICAgIGlmIChwcm92aWRlckNvZGUgPT09IDQ5KSB7XG4gICAgICAgICAgY29uc3QgdXNlclN0cnVjdHVyZSA9IHJlYWRVaW50MzIoZGF0YSwgcGF5UHRyKTtcbiAgICAgICAgICBwYXlQdHIgKz0gNDtcbiAgICAgICAgICBpZiAodXNlclN0cnVjdHVyZSA9PT0gMHg0NzQxMzkzNCkge1xuICAgICAgICAgICAgY29uc3QgdXNlckRhdGFUeXBlID0gZGF0YVtwYXlQdHIrK107XG5cbiAgICAgICAgICAgIC8vIFJhdyBDRUEtNjA4IGJ5dGVzIHdyYXBwZWQgaW4gQ0VBLTcwOCBwYWNrZXRcbiAgICAgICAgICAgIGlmICh1c2VyRGF0YVR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgY29uc3QgZmlyc3RCeXRlID0gZGF0YVtwYXlQdHIrK107XG4gICAgICAgICAgICAgIGNvbnN0IHRvdGFsQ0NzID0gMHgxZiAmIGZpcnN0Qnl0ZTtcbiAgICAgICAgICAgICAgY29uc3QgZW5hYmxlZCA9IDB4NDAgJiBmaXJzdEJ5dGU7XG4gICAgICAgICAgICAgIGNvbnN0IHRvdGFsQnl0ZXMgPSBlbmFibGVkID8gMiArIHRvdGFsQ0NzICogMyA6IDA7XG4gICAgICAgICAgICAgIGNvbnN0IGJ5dGVBcnJheSA9IG5ldyBVaW50OEFycmF5KHRvdGFsQnl0ZXMpO1xuICAgICAgICAgICAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGJ5dGVBcnJheVswXSA9IGZpcnN0Qnl0ZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRvdGFsQnl0ZXM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgYnl0ZUFycmF5W2ldID0gZGF0YVtwYXlQdHIrK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNhbXBsZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogdXNlckRhdGFUeXBlLFxuICAgICAgICAgICAgICAgIHBheWxvYWRUeXBlLFxuICAgICAgICAgICAgICAgIHB0cyxcbiAgICAgICAgICAgICAgICBieXRlczogYnl0ZUFycmF5XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGF5bG9hZFR5cGUgPT09IDUpIHtcbiAgICAgIGlmIChwYXlsb2FkU2l6ZSA+IDE2KSB7XG4gICAgICAgIGNvbnN0IHV1aWRTdHJBcnJheSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICBjb25zdCBfYiA9IGRhdGFbcGF5UHRyKytdLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICB1dWlkU3RyQXJyYXkucHVzaChfYi5sZW5ndGggPT0gMSA/ICcwJyArIF9iIDogX2IpO1xuICAgICAgICAgIGlmIChpID09PSAzIHx8IGkgPT09IDUgfHwgaSA9PT0gNyB8fCBpID09PSA5KSB7XG4gICAgICAgICAgICB1dWlkU3RyQXJyYXkucHVzaCgnLScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW5ndGggPSBwYXlsb2FkU2l6ZSAtIDE2O1xuICAgICAgICBjb25zdCB1c2VyRGF0YUJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHVzZXJEYXRhQnl0ZXNbaV0gPSBkYXRhW3BheVB0cisrXTtcbiAgICAgICAgfVxuICAgICAgICBzYW1wbGVzLnB1c2goe1xuICAgICAgICAgIHBheWxvYWRUeXBlLFxuICAgICAgICAgIHB0cyxcbiAgICAgICAgICB1dWlkOiB1dWlkU3RyQXJyYXkuam9pbignJyksXG4gICAgICAgICAgdXNlckRhdGE6IHV0ZjhBcnJheVRvU3RyKHVzZXJEYXRhQnl0ZXMpLFxuICAgICAgICAgIHVzZXJEYXRhQnl0ZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogcmVtb3ZlIEVtdWxhdGlvbiBQcmV2ZW50aW9uIGJ5dGVzIGZyb20gYSBSQlNQXG4gKi9cbmZ1bmN0aW9uIGRpc2NhcmRFUEIoZGF0YSkge1xuICBjb25zdCBsZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGg7XG4gIGNvbnN0IEVQQlBvc2l0aW9ucyA9IFtdO1xuICBsZXQgaSA9IDE7XG5cbiAgLy8gRmluZCBhbGwgYEVtdWxhdGlvbiBQcmV2ZW50aW9uIEJ5dGVzYFxuICB3aGlsZSAoaSA8IGxlbmd0aCAtIDIpIHtcbiAgICBpZiAoZGF0YVtpXSA9PT0gMCAmJiBkYXRhW2kgKyAxXSA9PT0gMCAmJiBkYXRhW2kgKyAyXSA9PT0gMHgwMykge1xuICAgICAgRVBCUG9zaXRpb25zLnB1c2goaSArIDIpO1xuICAgICAgaSArPSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBpKys7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgbm8gRW11bGF0aW9uIFByZXZlbnRpb24gQnl0ZXMgd2VyZSBmb3VuZCBqdXN0IHJldHVybiB0aGUgb3JpZ2luYWxcbiAgLy8gYXJyYXlcbiAgaWYgKEVQQlBvc2l0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIC8vIENyZWF0ZSBhIG5ldyBhcnJheSB0byBob2xkIHRoZSBOQUwgdW5pdCBkYXRhXG4gIGNvbnN0IG5ld0xlbmd0aCA9IGxlbmd0aCAtIEVQQlBvc2l0aW9ucy5sZW5ndGg7XG4gIGNvbnN0IG5ld0RhdGEgPSBuZXcgVWludDhBcnJheShuZXdMZW5ndGgpO1xuICBsZXQgc291cmNlSW5kZXggPSAwO1xuICBmb3IgKGkgPSAwOyBpIDwgbmV3TGVuZ3RoOyBzb3VyY2VJbmRleCsrLCBpKyspIHtcbiAgICBpZiAoc291cmNlSW5kZXggPT09IEVQQlBvc2l0aW9uc1swXSkge1xuICAgICAgLy8gU2tpcCB0aGlzIGJ5dGVcbiAgICAgIHNvdXJjZUluZGV4Kys7XG4gICAgICAvLyBSZW1vdmUgdGhpcyBwb3NpdGlvbiBpbmRleFxuICAgICAgRVBCUG9zaXRpb25zLnNoaWZ0KCk7XG4gICAgfVxuICAgIG5ld0RhdGFbaV0gPSBkYXRhW3NvdXJjZUluZGV4XTtcbiAgfVxuICByZXR1cm4gbmV3RGF0YTtcbn1cbmZ1bmN0aW9uIHBhcnNlRW1zZyhkYXRhKSB7XG4gIGNvbnN0IHZlcnNpb24gPSBkYXRhWzBdO1xuICBsZXQgc2NoZW1lSWRVcmkgPSAnJztcbiAgbGV0IHZhbHVlID0gJyc7XG4gIGxldCB0aW1lU2NhbGUgPSAwO1xuICBsZXQgcHJlc2VudGF0aW9uVGltZURlbHRhID0gMDtcbiAgbGV0IHByZXNlbnRhdGlvblRpbWUgPSAwO1xuICBsZXQgZXZlbnREdXJhdGlvbiA9IDA7XG4gIGxldCBpZCA9IDA7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBpZiAodmVyc2lvbiA9PT0gMCkge1xuICAgIHdoaWxlIChiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSkgIT09ICdcXDAnKSB7XG4gICAgICBzY2hlbWVJZFVyaSArPSBiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSk7XG4gICAgICBvZmZzZXQgKz0gMTtcbiAgICB9XG4gICAgc2NoZW1lSWRVcmkgKz0gYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpO1xuICAgIG9mZnNldCArPSAxO1xuICAgIHdoaWxlIChiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSkgIT09ICdcXDAnKSB7XG4gICAgICB2YWx1ZSArPSBiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSk7XG4gICAgICBvZmZzZXQgKz0gMTtcbiAgICB9XG4gICAgdmFsdWUgKz0gYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpO1xuICAgIG9mZnNldCArPSAxO1xuICAgIHRpbWVTY2FsZSA9IHJlYWRVaW50MzIoZGF0YSwgMTIpO1xuICAgIHByZXNlbnRhdGlvblRpbWVEZWx0YSA9IHJlYWRVaW50MzIoZGF0YSwgMTYpO1xuICAgIGV2ZW50RHVyYXRpb24gPSByZWFkVWludDMyKGRhdGEsIDIwKTtcbiAgICBpZCA9IHJlYWRVaW50MzIoZGF0YSwgMjQpO1xuICAgIG9mZnNldCA9IDI4O1xuICB9IGVsc2UgaWYgKHZlcnNpb24gPT09IDEpIHtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICB0aW1lU2NhbGUgPSByZWFkVWludDMyKGRhdGEsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gICAgY29uc3QgbGVmdFByZXNlbnRhdGlvblRpbWUgPSByZWFkVWludDMyKGRhdGEsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gICAgY29uc3QgcmlnaHRQcmVzZW50YXRpb25UaW1lID0gcmVhZFVpbnQzMihkYXRhLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSA0O1xuICAgIHByZXNlbnRhdGlvblRpbWUgPSAyICoqIDMyICogbGVmdFByZXNlbnRhdGlvblRpbWUgKyByaWdodFByZXNlbnRhdGlvblRpbWU7XG4gICAgaWYgKCFpc1NhZmVJbnRlZ2VyKHByZXNlbnRhdGlvblRpbWUpKSB7XG4gICAgICBwcmVzZW50YXRpb25UaW1lID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICBsb2dnZXIud2FybignUHJlc2VudGF0aW9uIHRpbWUgZXhjZWVkcyBzYWZlIGludGVnZXIgbGltaXQgYW5kIHdyYXBwZWQgdG8gbWF4IHNhZmUgaW50ZWdlciBpbiBwYXJzaW5nIGVtc2cgYm94Jyk7XG4gICAgfVxuICAgIGV2ZW50RHVyYXRpb24gPSByZWFkVWludDMyKGRhdGEsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gICAgaWQgPSByZWFkVWludDMyKGRhdGEsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gICAgd2hpbGUgKGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKSAhPT0gJ1xcMCcpIHtcbiAgICAgIHNjaGVtZUlkVXJpICs9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKTtcbiAgICAgIG9mZnNldCArPSAxO1xuICAgIH1cbiAgICBzY2hlbWVJZFVyaSArPSBiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSk7XG4gICAgb2Zmc2V0ICs9IDE7XG4gICAgd2hpbGUgKGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKSAhPT0gJ1xcMCcpIHtcbiAgICAgIHZhbHVlICs9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKTtcbiAgICAgIG9mZnNldCArPSAxO1xuICAgIH1cbiAgICB2YWx1ZSArPSBiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSk7XG4gICAgb2Zmc2V0ICs9IDE7XG4gIH1cbiAgY29uc3QgcGF5bG9hZCA9IGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpO1xuICByZXR1cm4ge1xuICAgIHNjaGVtZUlkVXJpLFxuICAgIHZhbHVlLFxuICAgIHRpbWVTY2FsZSxcbiAgICBwcmVzZW50YXRpb25UaW1lLFxuICAgIHByZXNlbnRhdGlvblRpbWVEZWx0YSxcbiAgICBldmVudER1cmF0aW9uLFxuICAgIGlkLFxuICAgIHBheWxvYWRcbiAgfTtcbn1cbmZ1bmN0aW9uIG1wNEJveCh0eXBlLCAuLi5wYXlsb2FkKSB7XG4gIGNvbnN0IGxlbiA9IHBheWxvYWQubGVuZ3RoO1xuICBsZXQgc2l6ZSA9IDg7XG4gIGxldCBpID0gbGVuO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgc2l6ZSArPSBwYXlsb2FkW2ldLmJ5dGVMZW5ndGg7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gIHJlc3VsdFswXSA9IHNpemUgPj4gMjQgJiAweGZmO1xuICByZXN1bHRbMV0gPSBzaXplID4+IDE2ICYgMHhmZjtcbiAgcmVzdWx0WzJdID0gc2l6ZSA+PiA4ICYgMHhmZjtcbiAgcmVzdWx0WzNdID0gc2l6ZSAmIDB4ZmY7XG4gIHJlc3VsdC5zZXQodHlwZSwgNCk7XG4gIGZvciAoaSA9IDAsIHNpemUgPSA4OyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXN1bHQuc2V0KHBheWxvYWRbaV0sIHNpemUpO1xuICAgIHNpemUgKz0gcGF5bG9hZFtpXS5ieXRlTGVuZ3RoO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtcDRwc3NoKHN5c3RlbUlkLCBrZXlpZHMsIGRhdGEpIHtcbiAgaWYgKHN5c3RlbUlkLmJ5dGVMZW5ndGggIT09IDE2KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgc3lzdGVtIGlkJyk7XG4gIH1cbiAgbGV0IHZlcnNpb247XG4gIGxldCBraWRzO1xuICB7XG4gICAgdmVyc2lvbiA9IDA7XG4gICAga2lkcyA9IG5ldyBVaW50OEFycmF5KCk7XG4gIH1cbiAgbGV0IGtpZENvdW50O1xuICBpZiAodmVyc2lvbiA+IDApIHtcbiAgICBraWRDb3VudCA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIGlmIChrZXlpZHMubGVuZ3RoID4gMCkge1xuICAgICAgbmV3IERhdGFWaWV3KGtpZENvdW50LmJ1ZmZlcikuc2V0VWludDMyKDAsIGtleWlkcy5sZW5ndGgsIGZhbHNlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAga2lkQ291bnQgPSBuZXcgVWludDhBcnJheSgpO1xuICB9XG4gIGNvbnN0IGRhdGFTaXplID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gIGlmIChkYXRhICYmIGRhdGEuYnl0ZUxlbmd0aCA+IDApIHtcbiAgICBuZXcgRGF0YVZpZXcoZGF0YVNpemUuYnVmZmVyKS5zZXRVaW50MzIoMCwgZGF0YS5ieXRlTGVuZ3RoLCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIG1wNEJveChbMTEyLCAxMTUsIDExNSwgMTA0XSwgbmV3IFVpbnQ4QXJyYXkoW3ZlcnNpb24sIDB4MDAsIDB4MDAsIDB4MDAgLy8gRmxhZ3NcbiAgXSksIHN5c3RlbUlkLFxuICAvLyAxNiBieXRlc1xuICBraWRDb3VudCwga2lkcywgZGF0YVNpemUsIGRhdGEgfHwgbmV3IFVpbnQ4QXJyYXkoKSk7XG59XG5cbmNvbnN0IHVzZXJBZ2VudEhldmNTdXBwb3J0SXNJbmFjY3VyYXRlID0gKCkgPT4ge1xuICByZXR1cm4gL1xcKFdpbmRvd3MuK0ZpcmVmb3hcXC8vaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xufTtcblxuLy8gZnJvbSBodHRwOi8vbXA0cmEub3JnL2NvZGVjcy5odG1sXG4vLyB2YWx1ZXMgaW5kaWNhdGUgY29kZWMgc2VsZWN0aW9uIHByZWZlcmVuY2UgKGxvd2VyIGlzIGhpZ2hlciBwcmlvcml0eSlcbmNvbnN0IHNhbXBsZUVudHJ5Q29kZXNJU08gPSB7XG4gIGF1ZGlvOiB7XG4gICAgYTNkczogMSxcbiAgICAnYWMtMyc6IDAuOTUsXG4gICAgJ2FjLTQnOiAxLFxuICAgIGFsYWM6IDAuOSxcbiAgICBhbGF3OiAxLFxuICAgIGRyYTE6IDEsXG4gICAgJ2R0cysnOiAxLFxuICAgICdkdHMtJzogMSxcbiAgICBkdHNjOiAxLFxuICAgIGR0c2U6IDEsXG4gICAgZHRzaDogMSxcbiAgICAnZWMtMyc6IDAuOSxcbiAgICBlbmNhOiAxLFxuICAgIGZMYUM6IDAuOSxcbiAgICAvLyBNUDQtUkEgbGlzdGVkIGNvZGVjIGVudHJ5IGZvciBGTEFDXG4gICAgZmxhYzogMC45LFxuICAgIC8vIGxlZ2FjeSBicm93c2VyIGNvZGVjIG5hbWUgZm9yIEZMQUNcbiAgICBGTEFDOiAwLjksXG4gICAgLy8gc29tZSBtYW5pZmVzdHMgbWF5IGxpc3QgXCJGTEFDXCIgd2l0aCBBcHBsZSdzIHRvb2xzXG4gICAgZzcxOTogMSxcbiAgICBnNzI2OiAxLFxuICAgIG00YWU6IDEsXG4gICAgbWhhMTogMSxcbiAgICBtaGEyOiAxLFxuICAgIG1obTE6IDEsXG4gICAgbWhtMjogMSxcbiAgICBtbHBhOiAxLFxuICAgIG1wNGE6IDEsXG4gICAgJ3JhdyAnOiAxLFxuICAgIE9wdXM6IDEsXG4gICAgb3B1czogMSxcbiAgICAvLyBicm93c2VycyBleHBlY3QgdGhpcyB0byBiZSBsb3dlcmNhc2UgZGVzcGl0ZSBNUDRSQSBzYXlzICdPcHVzJ1xuICAgIHNhbXI6IDEsXG4gICAgc2F3YjogMSxcbiAgICBzYXdwOiAxLFxuICAgIHNldmM6IDEsXG4gICAgc3FjcDogMSxcbiAgICBzc212OiAxLFxuICAgIHR3b3M6IDEsXG4gICAgdWxhdzogMVxuICB9LFxuICB2aWRlbzoge1xuICAgIGF2YzE6IDEsXG4gICAgYXZjMjogMSxcbiAgICBhdmMzOiAxLFxuICAgIGF2YzQ6IDEsXG4gICAgYXZjcDogMSxcbiAgICBhdjAxOiAwLjgsXG4gICAgZGF2MTogMC44LFxuICAgIGRyYWM6IDEsXG4gICAgZHZhMTogMSxcbiAgICBkdmF2OiAxLFxuICAgIGR2aDE6IDAuNyxcbiAgICBkdmhlOiAwLjcsXG4gICAgZW5jdjogMSxcbiAgICBoZXYxOiAwLjc1LFxuICAgIGh2YzE6IDAuNzUsXG4gICAgbWpwMjogMSxcbiAgICBtcDR2OiAxLFxuICAgIG12YzE6IDEsXG4gICAgbXZjMjogMSxcbiAgICBtdmMzOiAxLFxuICAgIG12YzQ6IDEsXG4gICAgcmVzdjogMSxcbiAgICBydjYwOiAxLFxuICAgIHMyNjM6IDEsXG4gICAgc3ZjMTogMSxcbiAgICBzdmMyOiAxLFxuICAgICd2Yy0xJzogMSxcbiAgICB2cDA4OiAxLFxuICAgIHZwMDk6IDAuOVxuICB9LFxuICB0ZXh0OiB7XG4gICAgc3RwcDogMSxcbiAgICB3dnR0OiAxXG4gIH1cbn07XG5mdW5jdGlvbiBpc0NvZGVjVHlwZShjb2RlYywgdHlwZSkge1xuICBjb25zdCB0eXBlQ29kZXMgPSBzYW1wbGVFbnRyeUNvZGVzSVNPW3R5cGVdO1xuICByZXR1cm4gISF0eXBlQ29kZXMgJiYgISF0eXBlQ29kZXNbY29kZWMuc2xpY2UoMCwgNCldO1xufVxuZnVuY3Rpb24gYXJlQ29kZWNzTWVkaWFTb3VyY2VTdXBwb3J0ZWQoY29kZWNzLCB0eXBlLCBwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UgPSB0cnVlKSB7XG4gIHJldHVybiAhY29kZWNzLnNwbGl0KCcsJykuc29tZShjb2RlYyA9PiAhaXNDb2RlY01lZGlhU291cmNlU3VwcG9ydGVkKGNvZGVjLCB0eXBlLCBwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UpKTtcbn1cbmZ1bmN0aW9uIGlzQ29kZWNNZWRpYVNvdXJjZVN1cHBvcnRlZChjb2RlYywgdHlwZSwgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlID0gdHJ1ZSkge1xuICB2YXIgX01lZGlhU291cmNlJGlzVHlwZVN1O1xuICBjb25zdCBNZWRpYVNvdXJjZSA9IGdldE1lZGlhU291cmNlKHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSk7XG4gIHJldHVybiAoX01lZGlhU291cmNlJGlzVHlwZVN1ID0gTWVkaWFTb3VyY2UgPT0gbnVsbCA/IHZvaWQgMCA6IE1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZChtaW1lVHlwZUZvckNvZGVjKGNvZGVjLCB0eXBlKSkpICE9IG51bGwgPyBfTWVkaWFTb3VyY2UkaXNUeXBlU3UgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG1pbWVUeXBlRm9yQ29kZWMoY29kZWMsIHR5cGUpIHtcbiAgcmV0dXJuIGAke3R5cGV9L21wNDtjb2RlY3M9JHtjb2RlY31gO1xufVxuZnVuY3Rpb24gdmlkZW9Db2RlY1ByZWZlcmVuY2VWYWx1ZSh2aWRlb0NvZGVjKSB7XG4gIGlmICh2aWRlb0NvZGVjKSB7XG4gICAgY29uc3QgZm91ckNDID0gdmlkZW9Db2RlYy5zdWJzdHJpbmcoMCwgNCk7XG4gICAgcmV0dXJuIHNhbXBsZUVudHJ5Q29kZXNJU08udmlkZW9bZm91ckNDXTtcbiAgfVxuICByZXR1cm4gMjtcbn1cbmZ1bmN0aW9uIGNvZGVjc1NldFNlbGVjdGlvblByZWZlcmVuY2VWYWx1ZShjb2RlY1NldCkge1xuICBjb25zdCBsaW1pdGVkSGV2Y1N1cHBvcnQgPSB1c2VyQWdlbnRIZXZjU3VwcG9ydElzSW5hY2N1cmF0ZSgpO1xuICByZXR1cm4gY29kZWNTZXQuc3BsaXQoJywnKS5yZWR1Y2UoKG51bSwgZm91ckNDKSA9PiB7XG4gICAgY29uc3QgbG93ZXJQcmlvcml0eSA9IGxpbWl0ZWRIZXZjU3VwcG9ydCAmJiBpc0hFVkMoZm91ckNDKTtcbiAgICBjb25zdCBwcmVmZXJlbmNlVmFsdWUgPSBsb3dlclByaW9yaXR5ID8gOSA6IHNhbXBsZUVudHJ5Q29kZXNJU08udmlkZW9bZm91ckNDXTtcbiAgICBpZiAocHJlZmVyZW5jZVZhbHVlKSB7XG4gICAgICByZXR1cm4gKHByZWZlcmVuY2VWYWx1ZSAqIDIgKyBudW0pIC8gKG51bSA/IDMgOiAyKTtcbiAgICB9XG4gICAgcmV0dXJuIChzYW1wbGVFbnRyeUNvZGVzSVNPLmF1ZGlvW2ZvdXJDQ10gKyBudW0pIC8gKG51bSA/IDIgOiAxKTtcbiAgfSwgMCk7XG59XG5jb25zdCBDT0RFQ19DT01QQVRJQkxFX05BTUVTID0ge307XG5mdW5jdGlvbiBnZXRDb2RlY0NvbXBhdGlibGVOYW1lTG93ZXIobG93ZXJDYXNlQ29kZWMsIHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSA9IHRydWUpIHtcbiAgaWYgKENPREVDX0NPTVBBVElCTEVfTkFNRVNbbG93ZXJDYXNlQ29kZWNdKSB7XG4gICAgcmV0dXJuIENPREVDX0NPTVBBVElCTEVfTkFNRVNbbG93ZXJDYXNlQ29kZWNdO1xuICB9XG4gIGNvbnN0IGNvZGVjc1RvQ2hlY2sgPSB7XG4gICAgLy8gSWRlYWx5IGZMYUMgYW5kIE9wdXMgd291bGQgYmUgZmlyc3QgKHNwZWMtY29tcGxpYW50KSBidXRcbiAgICAvLyBzb21lIGJyb3dzZXJzIHdpbGwgcmVwb3J0IHRoYXQgZkxhQyBpcyBzdXBwb3J0ZWQgdGhlbiBmYWlsLlxuICAgIC8vIHNlZTogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTQyMjcyOFxuICAgIGZsYWM6IFsnZmxhYycsICdmTGFDJywgJ0ZMQUMnXSxcbiAgICBvcHVzOiBbJ29wdXMnLCAnT3B1cyddLFxuICAgIC8vIFJlcGxhY2UgYXVkaW8gY29kZWMgaW5mbyBpZiBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgbXA0YS40MC4zNCxcbiAgICAvLyBhbmQgZGVtdXhlciBjYW4gZmFsbGJhY2sgdG8gJ2F1ZGlvL21wZWcnIG9yICdhdWRpby9tcDQ7Y29kZWNzPVwibXAzXCInXG4gICAgJ21wNGEuNDAuMzQnOiBbJ21wMyddXG4gIH1bbG93ZXJDYXNlQ29kZWNdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvZGVjc1RvQ2hlY2subGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgX2dldE1lZGlhU291cmNlO1xuICAgIGlmIChpc0NvZGVjTWVkaWFTb3VyY2VTdXBwb3J0ZWQoY29kZWNzVG9DaGVja1tpXSwgJ2F1ZGlvJywgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlKSkge1xuICAgICAgQ09ERUNfQ09NUEFUSUJMRV9OQU1FU1tsb3dlckNhc2VDb2RlY10gPSBjb2RlY3NUb0NoZWNrW2ldO1xuICAgICAgcmV0dXJuIGNvZGVjc1RvQ2hlY2tbaV07XG4gICAgfSBlbHNlIGlmIChjb2RlY3NUb0NoZWNrW2ldID09PSAnbXAzJyAmJiAoX2dldE1lZGlhU291cmNlID0gZ2V0TWVkaWFTb3VyY2UocHJlZmVyTWFuYWdlZE1lZGlhU291cmNlKSkgIT0gbnVsbCAmJiBfZ2V0TWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCdhdWRpby9tcGVnJykpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxvd2VyQ2FzZUNvZGVjO1xufVxuY29uc3QgQVVESU9fQ09ERUNfUkVHRVhQID0gL2ZsYWN8b3B1c3xtcDRhXFwuNDBcXC4zNC9pO1xuZnVuY3Rpb24gZ2V0Q29kZWNDb21wYXRpYmxlTmFtZShjb2RlYywgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlID0gdHJ1ZSkge1xuICByZXR1cm4gY29kZWMucmVwbGFjZShBVURJT19DT0RFQ19SRUdFWFAsIG0gPT4gZ2V0Q29kZWNDb21wYXRpYmxlTmFtZUxvd2VyKG0udG9Mb3dlckNhc2UoKSwgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlKSk7XG59XG5mdW5jdGlvbiByZXBsYWNlVmlkZW9Db2RlYyhvcmlnaW5hbENvZGVjcywgbmV3VmlkZW9Db2RlYykge1xuICBjb25zdCBjb2RlY3MgPSBbXTtcbiAgaWYgKG9yaWdpbmFsQ29kZWNzKSB7XG4gICAgY29uc3QgYWxsQ29kZWNzID0gb3JpZ2luYWxDb2RlY3Muc3BsaXQoJywnKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsbENvZGVjcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFpc0NvZGVjVHlwZShhbGxDb2RlY3NbaV0sICd2aWRlbycpKSB7XG4gICAgICAgIGNvZGVjcy5wdXNoKGFsbENvZGVjc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChuZXdWaWRlb0NvZGVjKSB7XG4gICAgY29kZWNzLnB1c2gobmV3VmlkZW9Db2RlYyk7XG4gIH1cbiAgcmV0dXJuIGNvZGVjcy5qb2luKCcsJyk7XG59XG5mdW5jdGlvbiBwaWNrTW9zdENvbXBsZXRlQ29kZWNOYW1lKHBhcnNlZENvZGVjLCBsZXZlbENvZGVjKSB7XG4gIC8vIFBhcnNpbmcgb2YgbXA0YSBjb2RlY3Mgc3RyaW5ncyBpbiBtcDQtdG9vbHMgZnJvbSBtZWRpYSBpcyBpbmNvbXBsZXRlIGFzIG9mIGQ4YzZjN2FcbiAgLy8gc28gdXNlIGxldmVsIGNvZGVjIGlzIHBhcnNlZCBjb2RlYyBpcyB1bmF2YWlsYWJsZSBvciBpbmNvbXBsZXRlXG4gIGlmIChwYXJzZWRDb2RlYyAmJiAocGFyc2VkQ29kZWMubGVuZ3RoID4gNCB8fCBbJ2FjLTMnLCAnZWMtMycsICdhbGFjJywgJ2ZMYUMnLCAnT3B1cyddLmluZGV4T2YocGFyc2VkQ29kZWMpICE9PSAtMSkpIHtcbiAgICBpZiAoaXNDb2RlY1N1cHBvcnRlZEFzVHlwZShwYXJzZWRDb2RlYywgJ2F1ZGlvJykgfHwgaXNDb2RlY1N1cHBvcnRlZEFzVHlwZShwYXJzZWRDb2RlYywgJ3ZpZGVvJykpIHtcbiAgICAgIHJldHVybiBwYXJzZWRDb2RlYztcbiAgICB9XG4gIH1cbiAgaWYgKGxldmVsQ29kZWMpIHtcbiAgICBjb25zdCBsZXZlbENvZGVjcyA9IGxldmVsQ29kZWMuc3BsaXQoJywnKTtcbiAgICBpZiAobGV2ZWxDb2RlY3MubGVuZ3RoID4gMSkge1xuICAgICAgaWYgKHBhcnNlZENvZGVjKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBsZXZlbENvZGVjcy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICBpZiAobGV2ZWxDb2RlY3NbaV0uc3Vic3RyaW5nKDAsIDQpID09PSBwYXJzZWRDb2RlYy5zdWJzdHJpbmcoMCwgNCkpIHtcbiAgICAgICAgICAgIHJldHVybiBsZXZlbENvZGVjc1tpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBsZXZlbENvZGVjc1swXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxldmVsQ29kZWMgfHwgcGFyc2VkQ29kZWM7XG59XG5mdW5jdGlvbiBpc0NvZGVjU3VwcG9ydGVkQXNUeXBlKGNvZGVjLCB0eXBlKSB7XG4gIHJldHVybiBpc0NvZGVjVHlwZShjb2RlYywgdHlwZSkgJiYgaXNDb2RlY01lZGlhU291cmNlU3VwcG9ydGVkKGNvZGVjLCB0eXBlKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRBVkMxVG9BVkNPVEkodmlkZW9Db2RlY3MpIHtcbiAgLy8gQ29udmVydCBhdmMxIGNvZGVjIHN0cmluZyBmcm9tIFJGQy00MjgxIHRvIFJGQy02MzgxIGZvciBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWRcbiAgLy8gRXhhbXBsZXM6IGF2YzEuNjYuMzAgdG8gYXZjMS40MjAwMWUgYW5kIGF2YzEuNzcuMzAsYXZjMS42Ni4zMCB0byBhdmMxLjRkMDAxZSxhdmMxLjQyMDAxZS5cbiAgY29uc3QgY29kZWNzID0gdmlkZW9Db2RlY3Muc3BsaXQoJywnKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2RlY3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBhdmNkYXRhID0gY29kZWNzW2ldLnNwbGl0KCcuJyk7XG4gICAgLy8gb25seSBjb252ZXJ0IGNvZGVjIHN0cmluZ3Mgc3RhcnRpbmcgd2l0aCBhdmMxIChFeGFtcGxlczogYXZjMS42NDAwMWYsZHZoMS4wNS4wNylcbiAgICBpZiAoYXZjZGF0YS5sZW5ndGggPiAyICYmIGF2Y2RhdGFbMF0gPT09ICdhdmMxJykge1xuICAgICAgY29kZWNzW2ldID0gYGF2YzEuJHtwYXJzZUludChhdmNkYXRhWzFdKS50b1N0cmluZygxNil9JHsoJzAwMCcgKyBwYXJzZUludChhdmNkYXRhWzJdKS50b1N0cmluZygxNikpLnNsaWNlKC00KX1gO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY29kZWNzLmpvaW4oJywnKTtcbn1cbmZ1bmN0aW9uIGZpbGxJbk1pc3NpbmdBVjAxUGFyYW1zKHZpZGVvQ29kZWMpIHtcbiAgLy8gVXNlZCB0byBmaWxsIGluIGluY29tcGxldGUgQVYxIHBsYXlsaXN0IENPREVDUyBzdHJpbmdzIGZvciBtZWRpYUNhcGFiaWxpdGllcy5kZWNvZGluZ0luZm8gcXVlcmllc1xuICBpZiAodmlkZW9Db2RlYy5zdGFydHNXaXRoKCdhdjAxLicpKSB7XG4gICAgY29uc3QgYXYxcGFyYW1zID0gdmlkZW9Db2RlYy5zcGxpdCgnLicpO1xuICAgIGNvbnN0IHBsYWNlaG9sZGVycyA9IFsnMCcsICcxMTEnLCAnMDEnLCAnMDEnLCAnMDEnLCAnMCddO1xuICAgIGZvciAobGV0IGkgPSBhdjFwYXJhbXMubGVuZ3RoOyBpID4gNCAmJiBpIDwgMTA7IGkrKykge1xuICAgICAgYXYxcGFyYW1zW2ldID0gcGxhY2Vob2xkZXJzW2kgLSA0XTtcbiAgICB9XG4gICAgcmV0dXJuIGF2MXBhcmFtcy5qb2luKCcuJyk7XG4gIH1cbiAgcmV0dXJuIHZpZGVvQ29kZWM7XG59XG5mdW5jdGlvbiBnZXRNMlRTU3VwcG9ydGVkQXVkaW9UeXBlcyhwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UpIHtcbiAgY29uc3QgTWVkaWFTb3VyY2UgPSBnZXRNZWRpYVNvdXJjZShwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UpIHx8IHtcbiAgICBpc1R5cGVTdXBwb3J0ZWQ6ICgpID0+IGZhbHNlXG4gIH07XG4gIHJldHVybiB7XG4gICAgbXBlZzogTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCdhdWRpby9tcGVnJyksXG4gICAgbXAzOiBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoJ2F1ZGlvL21wNDsgY29kZWNzPVwibXAzXCInKSxcbiAgICBhYzM6IE1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCgnYXVkaW8vbXA0OyBjb2RlY3M9XCJhYy0zXCInKSBcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldENvZGVjc0Zvck1pbWVUeXBlKG1pbWVUeXBlKSB7XG4gIHJldHVybiBtaW1lVHlwZS5yZXBsYWNlKC9eLitjb2RlY3M9W1wiJ10/KFteXCInXSspLiokLywgJyQxJyk7XG59XG5cbmNvbnN0IFNVUFBPUlRFRF9JTkZPX0RFRkFVTFQgPSB7XG4gIHN1cHBvcnRlZDogdHJ1ZSxcbiAgY29uZmlndXJhdGlvbnM6IFtdLFxuICBkZWNvZGluZ0luZm9SZXN1bHRzOiBbe1xuICAgIHN1cHBvcnRlZDogdHJ1ZSxcbiAgICBwb3dlckVmZmljaWVudDogdHJ1ZSxcbiAgICBzbW9vdGg6IHRydWVcbiAgfV1cbn07XG5mdW5jdGlvbiBnZXRVbnN1cHBvcnRlZFJlc3VsdChlcnJvciwgY29uZmlndXJhdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBzdXBwb3J0ZWQ6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYXRpb25zLFxuICAgIGRlY29kaW5nSW5mb1Jlc3VsdHM6IFt7XG4gICAgICBzdXBwb3J0ZWQ6IGZhbHNlLFxuICAgICAgc21vb3RoOiBmYWxzZSxcbiAgICAgIHBvd2VyRWZmaWNpZW50OiBmYWxzZVxuICAgIH1dLFxuICAgIGVycm9yXG4gIH07XG59XG5mdW5jdGlvbiByZXF1aXJlc01lZGlhQ2FwYWJpbGl0aWVzRGVjb2RpbmdJbmZvKGxldmVsLCBhdWRpb1RyYWNrc0J5R3JvdXAsIGN1cnJlbnRWaWRlb1JhbmdlLCBjdXJyZW50RnJhbWVSYXRlLCBjdXJyZW50QncsIGF1ZGlvUHJlZmVyZW5jZSkge1xuICAvLyBPbmx5IHRlc3Qgc3VwcG9ydCB3aGVuIGNvbmZpZ3VyYXRpb24gaXMgZXhjZWVkcyBtaW5pbXVtIG9wdGlvbnNcbiAgY29uc3QgdmlkZW9Db2RlY3MgPSBsZXZlbC52aWRlb0NvZGVjO1xuICBjb25zdCBhdWRpb0dyb3VwcyA9IGxldmVsLmF1ZGlvQ29kZWMgPyBsZXZlbC5hdWRpb0dyb3VwcyA6IG51bGw7XG4gIGNvbnN0IGF1ZGlvQ29kZWNQcmVmZXJlbmNlID0gYXVkaW9QcmVmZXJlbmNlID09IG51bGwgPyB2b2lkIDAgOiBhdWRpb1ByZWZlcmVuY2UuYXVkaW9Db2RlYztcbiAgY29uc3QgY2hhbm5lbHNQcmVmZXJlbmNlID0gYXVkaW9QcmVmZXJlbmNlID09IG51bGwgPyB2b2lkIDAgOiBhdWRpb1ByZWZlcmVuY2UuY2hhbm5lbHM7XG4gIGNvbnN0IG1heENoYW5uZWxzID0gY2hhbm5lbHNQcmVmZXJlbmNlID8gcGFyc2VJbnQoY2hhbm5lbHNQcmVmZXJlbmNlKSA6IGF1ZGlvQ29kZWNQcmVmZXJlbmNlID8gSW5maW5pdHkgOiAyO1xuICBsZXQgYXVkaW9DaGFubmVscyA9IG51bGw7XG4gIGlmIChhdWRpb0dyb3VwcyAhPSBudWxsICYmIGF1ZGlvR3JvdXBzLmxlbmd0aCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoYXVkaW9Hcm91cHMubGVuZ3RoID09PSAxICYmIGF1ZGlvR3JvdXBzWzBdKSB7XG4gICAgICAgIGF1ZGlvQ2hhbm5lbHMgPSBhdWRpb1RyYWNrc0J5R3JvdXAuZ3JvdXBzW2F1ZGlvR3JvdXBzWzBdXS5jaGFubmVscztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF1ZGlvQ2hhbm5lbHMgPSBhdWRpb0dyb3Vwcy5yZWR1Y2UoKGFjYywgZ3JvdXBJZCkgPT4ge1xuICAgICAgICAgIGlmIChncm91cElkKSB7XG4gICAgICAgICAgICBjb25zdCBhdWRpb1RyYWNrR3JvdXAgPSBhdWRpb1RyYWNrc0J5R3JvdXAuZ3JvdXBzW2dyb3VwSWRdO1xuICAgICAgICAgICAgaWYgKCFhdWRpb1RyYWNrR3JvdXApIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdWRpbyB0cmFjayBncm91cCAke2dyb3VwSWR9IG5vdCBmb3VuZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3VtIGFsbCBjaGFubmVsIGtleSB2YWx1ZXNcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF1ZGlvVHJhY2tHcm91cC5jaGFubmVscykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICBhY2Nba2V5XSA9IChhY2Nba2V5XSB8fCAwKSArIGF1ZGlvVHJhY2tHcm91cC5jaGFubmVsc1trZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAyOiAwXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZpZGVvQ29kZWNzICE9PSB1bmRlZmluZWQgJiYgKFxuICAvLyBGb3JjZSBtZWRpYSBjYXBhYmlsaXRpZXMgY2hlY2sgZm9yIEhFVkMgdG8gYXZvaWQgZmFpbHVyZSBvbiBXaW5kb3dzXG4gIHZpZGVvQ29kZWNzLnNwbGl0KCcsJykuc29tZSh2aWRlb0NvZGVjID0+IGlzSEVWQyh2aWRlb0NvZGVjKSkgfHwgbGV2ZWwud2lkdGggPiAxOTIwICYmIGxldmVsLmhlaWdodCA+IDEwODggfHwgbGV2ZWwuaGVpZ2h0ID4gMTkyMCAmJiBsZXZlbC53aWR0aCA+IDEwODggfHwgbGV2ZWwuZnJhbWVSYXRlID4gTWF0aC5tYXgoY3VycmVudEZyYW1lUmF0ZSwgMzApIHx8IGxldmVsLnZpZGVvUmFuZ2UgIT09ICdTRFInICYmIGxldmVsLnZpZGVvUmFuZ2UgIT09IGN1cnJlbnRWaWRlb1JhbmdlIHx8IGxldmVsLmJpdHJhdGUgPiBNYXRoLm1heChjdXJyZW50QncsIDhlNikpIHx8ICEhYXVkaW9DaGFubmVscyAmJiBpc0Zpbml0ZU51bWJlcihtYXhDaGFubmVscykgJiYgT2JqZWN0LmtleXMoYXVkaW9DaGFubmVscykuc29tZShjaGFubmVscyA9PiBwYXJzZUludChjaGFubmVscykgPiBtYXhDaGFubmVscyk7XG59XG5mdW5jdGlvbiBnZXRNZWRpYURlY29kaW5nSW5mb1Byb21pc2UobGV2ZWwsIGF1ZGlvVHJhY2tzQnlHcm91cCwgbWVkaWFDYXBhYmlsaXRpZXMsIGNhY2hlID0ge30pIHtcbiAgY29uc3QgdmlkZW9Db2RlY3MgPSBsZXZlbC52aWRlb0NvZGVjO1xuICBpZiAoIXZpZGVvQ29kZWNzICYmICFsZXZlbC5hdWRpb0NvZGVjIHx8ICFtZWRpYUNhcGFiaWxpdGllcykge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoU1VQUE9SVEVEX0lORk9fREVGQVVMVCk7XG4gIH1cbiAgY29uc3QgY29uZmlndXJhdGlvbnMgPSBbXTtcbiAgY29uc3QgdmlkZW9EZWNvZGVMaXN0ID0gbWFrZVZpZGVvQ29uZmlndXJhdGlvbnMobGV2ZWwpO1xuICBjb25zdCB2aWRlb0NvdW50ID0gdmlkZW9EZWNvZGVMaXN0Lmxlbmd0aDtcbiAgY29uc3QgYXVkaW9EZWNvZGVMaXN0ID0gbWFrZUF1ZGlvQ29uZmlndXJhdGlvbnMobGV2ZWwsIGF1ZGlvVHJhY2tzQnlHcm91cCwgdmlkZW9Db3VudCA+IDApO1xuICBjb25zdCBhdWRpb0NvdW50ID0gYXVkaW9EZWNvZGVMaXN0Lmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IHZpZGVvQ291bnQgfHwgMSAqIGF1ZGlvQ291bnQgfHwgMTsgaS0tOykge1xuICAgIGNvbnN0IGNvbmZpZ3VyYXRpb24gPSB7XG4gICAgICB0eXBlOiAnbWVkaWEtc291cmNlJ1xuICAgIH07XG4gICAgaWYgKHZpZGVvQ291bnQpIHtcbiAgICAgIGNvbmZpZ3VyYXRpb24udmlkZW8gPSB2aWRlb0RlY29kZUxpc3RbaSAlIHZpZGVvQ291bnRdO1xuICAgIH1cbiAgICBpZiAoYXVkaW9Db3VudCkge1xuICAgICAgY29uZmlndXJhdGlvbi5hdWRpbyA9IGF1ZGlvRGVjb2RlTGlzdFtpICUgYXVkaW9Db3VudF07XG4gICAgICBjb25zdCBhdWRpb0JpdHJhdGUgPSBjb25maWd1cmF0aW9uLmF1ZGlvLmJpdHJhdGU7XG4gICAgICBpZiAoY29uZmlndXJhdGlvbi52aWRlbyAmJiBhdWRpb0JpdHJhdGUpIHtcbiAgICAgICAgY29uZmlndXJhdGlvbi52aWRlby5iaXRyYXRlIC09IGF1ZGlvQml0cmF0ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uZmlndXJhdGlvbnMucHVzaChjb25maWd1cmF0aW9uKTtcbiAgfVxuICBpZiAodmlkZW9Db2RlY3MpIHtcbiAgICAvLyBPdmVycmlkZSBXaW5kb3dzIEZpcmVmb3ggSEVWQyBNZWRpYUNhcGFiaWxpdGllcyByZXN1bHQgKGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy83MDQ2KVxuICAgIGNvbnN0IHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICBpZiAodmlkZW9Db2RlY3Muc3BsaXQoJywnKS5zb21lKHZpZGVvQ29kZWMgPT4gaXNIRVZDKHZpZGVvQ29kZWMpKSAmJiB1c2VyQWdlbnRIZXZjU3VwcG9ydElzSW5hY2N1cmF0ZSgpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGdldFVuc3VwcG9ydGVkUmVzdWx0KG5ldyBFcnJvcihgT3ZlcnJpZGluZyBXaW5kb3dzIEZpcmVmb3ggSEVWQyBNZWRpYUNhcGFiaWxpdGllcyByZXN1bHQgYmFzZWQgb24gdXNlci1hZ2VudCBzdHJpbmc6ICgke3VhfSlgKSwgY29uZmlndXJhdGlvbnMpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFByb21pc2UuYWxsKGNvbmZpZ3VyYXRpb25zLm1hcChjb25maWd1cmF0aW9uID0+IHtcbiAgICAvLyBDYWNoZSBNZWRpYUNhcGFiaWxpdGllcyBwcm9taXNlc1xuICAgIGNvbnN0IGRlY29kaW5nSW5mb0tleSA9IGdldE1lZGlhRGVjb2RpbmdJbmZvS2V5KGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiBjYWNoZVtkZWNvZGluZ0luZm9LZXldIHx8IChjYWNoZVtkZWNvZGluZ0luZm9LZXldID0gbWVkaWFDYXBhYmlsaXRpZXMuZGVjb2RpbmdJbmZvKGNvbmZpZ3VyYXRpb24pKTtcbiAgfSkpLnRoZW4oZGVjb2RpbmdJbmZvUmVzdWx0cyA9PiAoe1xuICAgIHN1cHBvcnRlZDogIWRlY29kaW5nSW5mb1Jlc3VsdHMuc29tZShpbmZvID0+ICFpbmZvLnN1cHBvcnRlZCksXG4gICAgY29uZmlndXJhdGlvbnMsXG4gICAgZGVjb2RpbmdJbmZvUmVzdWx0c1xuICB9KSkuY2F0Y2goZXJyb3IgPT4gKHtcbiAgICBzdXBwb3J0ZWQ6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYXRpb25zLFxuICAgIGRlY29kaW5nSW5mb1Jlc3VsdHM6IFtdLFxuICAgIGVycm9yXG4gIH0pKTtcbn1cbmZ1bmN0aW9uIG1ha2VWaWRlb0NvbmZpZ3VyYXRpb25zKGxldmVsKSB7XG4gIHZhciBfbGV2ZWwkdmlkZW9Db2RlYztcbiAgY29uc3QgdmlkZW9Db2RlY3MgPSAoX2xldmVsJHZpZGVvQ29kZWMgPSBsZXZlbC52aWRlb0NvZGVjKSA9PSBudWxsID8gdm9pZCAwIDogX2xldmVsJHZpZGVvQ29kZWMuc3BsaXQoJywnKTtcbiAgY29uc3QgYml0cmF0ZSA9IGdldFZhcmlhbnREZWNvZGluZ0JpdHJhdGUobGV2ZWwpO1xuICBjb25zdCB3aWR0aCA9IGxldmVsLndpZHRoIHx8IDY0MDtcbiAgY29uc3QgaGVpZ2h0ID0gbGV2ZWwuaGVpZ2h0IHx8IDQ4MDtcbiAgLy8gQXNzdW1lIGEgZnJhbWVyYXRlIG9mIDMwZnBzIHNpbmNlIE1lZGlhQ2FwYWJpbGl0aWVzIHdpbGwgbm90IGFjY2VwdCBMZXZlbCBkZWZhdWx0IG9mIDAuXG4gIGNvbnN0IGZyYW1lcmF0ZSA9IGxldmVsLmZyYW1lUmF0ZSB8fCAzMDtcbiAgY29uc3QgdmlkZW9SYW5nZSA9IGxldmVsLnZpZGVvUmFuZ2UudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIHZpZGVvQ29kZWNzID8gdmlkZW9Db2RlY3MubWFwKHZpZGVvQ29kZWMgPT4ge1xuICAgIGNvbnN0IHZpZGVvQ29uZmlndXJhdGlvbiA9IHtcbiAgICAgIGNvbnRlbnRUeXBlOiBtaW1lVHlwZUZvckNvZGVjKGZpbGxJbk1pc3NpbmdBVjAxUGFyYW1zKHZpZGVvQ29kZWMpLCAndmlkZW8nKSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgYml0cmF0ZSxcbiAgICAgIGZyYW1lcmF0ZVxuICAgIH07XG4gICAgaWYgKHZpZGVvUmFuZ2UgIT09ICdzZHInKSB7XG4gICAgICB2aWRlb0NvbmZpZ3VyYXRpb24udHJhbnNmZXJGdW5jdGlvbiA9IHZpZGVvUmFuZ2U7XG4gICAgfVxuICAgIHJldHVybiB2aWRlb0NvbmZpZ3VyYXRpb247XG4gIH0pIDogW107XG59XG5mdW5jdGlvbiBtYWtlQXVkaW9Db25maWd1cmF0aW9ucyhsZXZlbCwgYXVkaW9UcmFja3NCeUdyb3VwLCBoYXNWaWRlbykge1xuICB2YXIgX2xldmVsJGF1ZGlvQ29kZWM7XG4gIGNvbnN0IGF1ZGlvQ29kZWNzID0gKF9sZXZlbCRhdWRpb0NvZGVjID0gbGV2ZWwuYXVkaW9Db2RlYykgPT0gbnVsbCA/IHZvaWQgMCA6IF9sZXZlbCRhdWRpb0NvZGVjLnNwbGl0KCcsJyk7XG4gIGNvbnN0IGNvbWJpbmVkQml0cmF0ZSA9IGdldFZhcmlhbnREZWNvZGluZ0JpdHJhdGUobGV2ZWwpO1xuICBpZiAoYXVkaW9Db2RlY3MgJiYgbGV2ZWwuYXVkaW9Hcm91cHMpIHtcbiAgICByZXR1cm4gbGV2ZWwuYXVkaW9Hcm91cHMucmVkdWNlKChjb25maWd1cmF0aW9ucywgYXVkaW9Hcm91cElkKSA9PiB7XG4gICAgICB2YXIgX2F1ZGlvVHJhY2tzQnlHcm91cCRnO1xuICAgICAgY29uc3QgdHJhY2tzID0gYXVkaW9Hcm91cElkID8gKF9hdWRpb1RyYWNrc0J5R3JvdXAkZyA9IGF1ZGlvVHJhY2tzQnlHcm91cC5ncm91cHNbYXVkaW9Hcm91cElkXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hdWRpb1RyYWNrc0J5R3JvdXAkZy50cmFja3MgOiBudWxsO1xuICAgICAgaWYgKHRyYWNrcykge1xuICAgICAgICByZXR1cm4gdHJhY2tzLnJlZHVjZSgoY29uZmlncywgYXVkaW9UcmFjaykgPT4ge1xuICAgICAgICAgIGlmIChhdWRpb1RyYWNrLmdyb3VwSWQgPT09IGF1ZGlvR3JvdXBJZCkge1xuICAgICAgICAgICAgY29uc3QgY2hhbm5lbHNOdW1iZXIgPSBwYXJzZUZsb2F0KGF1ZGlvVHJhY2suY2hhbm5lbHMgfHwgJycpO1xuICAgICAgICAgICAgYXVkaW9Db2RlY3MuZm9yRWFjaChhdWRpb0NvZGVjID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgYXVkaW9Db25maWd1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBtaW1lVHlwZUZvckNvZGVjKGF1ZGlvQ29kZWMsICdhdWRpbycpLFxuICAgICAgICAgICAgICAgIGJpdHJhdGU6IGhhc1ZpZGVvID8gZXN0aW1hdGVkQXVkaW9CaXRyYXRlKGF1ZGlvQ29kZWMsIGNvbWJpbmVkQml0cmF0ZSkgOiBjb21iaW5lZEJpdHJhdGVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgaWYgKGNoYW5uZWxzTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgYXVkaW9Db25maWd1cmF0aW9uLmNoYW5uZWxzID0gJycgKyBjaGFubmVsc051bWJlcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25maWdzLnB1c2goYXVkaW9Db25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY29uZmlncztcbiAgICAgICAgfSwgY29uZmlndXJhdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25zO1xuICAgIH0sIFtdKTtcbiAgfVxuICByZXR1cm4gW107XG59XG5mdW5jdGlvbiBlc3RpbWF0ZWRBdWRpb0JpdHJhdGUoYXVkaW9Db2RlYywgbGV2ZWxCaXRyYXRlKSB7XG4gIGlmIChsZXZlbEJpdHJhdGUgPD0gMSkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIGxldCBhdWRpb0JpdHJhdGUgPSAxMjgwMDA7XG4gIGlmIChhdWRpb0NvZGVjID09PSAnZWMtMycpIHtcbiAgICBhdWRpb0JpdHJhdGUgPSA3NjgwMDA7XG4gIH0gZWxzZSBpZiAoYXVkaW9Db2RlYyA9PT0gJ2FjLTMnKSB7XG4gICAgYXVkaW9CaXRyYXRlID0gNjQwMDAwO1xuICB9XG4gIHJldHVybiBNYXRoLm1pbihsZXZlbEJpdHJhdGUgLyAyLCBhdWRpb0JpdHJhdGUpOyAvLyBEb24ndCBleGNlZWQgc29tZSAlIG9mIGxldmVsIGJpdHJhdGVcbn1cbmZ1bmN0aW9uIGdldFZhcmlhbnREZWNvZGluZ0JpdHJhdGUobGV2ZWwpIHtcbiAgcmV0dXJuIE1hdGguY2VpbChNYXRoLm1heChsZXZlbC5iaXRyYXRlICogMC45LCBsZXZlbC5hdmVyYWdlQml0cmF0ZSkgLyAxMDAwKSAqIDEwMDAgfHwgMTtcbn1cbmZ1bmN0aW9uIGdldE1lZGlhRGVjb2RpbmdJbmZvS2V5KGNvbmZpZykge1xuICBsZXQga2V5ID0gJyc7XG4gIGNvbnN0IHtcbiAgICBhdWRpbyxcbiAgICB2aWRlb1xuICB9ID0gY29uZmlnO1xuICBpZiAodmlkZW8pIHtcbiAgICBjb25zdCBjb2RlYyA9IGdldENvZGVjc0Zvck1pbWVUeXBlKHZpZGVvLmNvbnRlbnRUeXBlKTtcbiAgICBrZXkgKz0gYCR7Y29kZWN9X3Ike3ZpZGVvLmhlaWdodH14JHt2aWRlby53aWR0aH1mJHtNYXRoLmNlaWwodmlkZW8uZnJhbWVyYXRlKX0ke3ZpZGVvLnRyYW5zZmVyRnVuY3Rpb24gfHwgJ3NkJ31fJHtNYXRoLmNlaWwodmlkZW8uYml0cmF0ZSAvIDFlNSl9YDtcbiAgfVxuICBpZiAoYXVkaW8pIHtcbiAgICBjb25zdCBjb2RlYyA9IGdldENvZGVjc0Zvck1pbWVUeXBlKGF1ZGlvLmNvbnRlbnRUeXBlKTtcbiAgICBrZXkgKz0gYCR7dmlkZW8gPyAnXycgOiAnJ30ke2NvZGVjfV9jJHthdWRpby5jaGFubmVsc31gO1xuICB9XG4gIHJldHVybiBrZXk7XG59XG5cbmNvbnN0IEhkY3BMZXZlbHMgPSBbJ05PTkUnLCAnVFlQRS0wJywgJ1RZUEUtMScsIG51bGxdO1xuZnVuY3Rpb24gaXNIZGNwTGV2ZWwodmFsdWUpIHtcbiAgcmV0dXJuIEhkY3BMZXZlbHMuaW5kZXhPZih2YWx1ZSkgPiAtMTtcbn1cbmNvbnN0IFZpZGVvUmFuZ2VWYWx1ZXMgPSBbJ1NEUicsICdQUScsICdITEcnXTtcbmZ1bmN0aW9uIGlzVmlkZW9SYW5nZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiBWaWRlb1JhbmdlVmFsdWVzLmluZGV4T2YodmFsdWUpID4gLTE7XG59XG52YXIgSGxzU2tpcCA9IHtcbiAgTm86IFwiXCIsXG4gIFllczogXCJZRVNcIixcbiAgdjI6IFwidjJcIlxufTtcbmZ1bmN0aW9uIGdldFNraXBWYWx1ZShkZXRhaWxzKSB7XG4gIGNvbnN0IHtcbiAgICBjYW5Ta2lwVW50aWwsXG4gICAgY2FuU2tpcERhdGVSYW5nZXMsXG4gICAgYWdlXG4gIH0gPSBkZXRhaWxzO1xuICAvLyBBIENsaWVudCBTSE9VTEQgTk9UIHJlcXVlc3QgYSBQbGF5bGlzdCBEZWx0YSBVcGRhdGUgdW5sZXNzIGl0IGFscmVhZHlcbiAgLy8gaGFzIGEgdmVyc2lvbiBvZiB0aGUgUGxheWxpc3QgdGhhdCBpcyBubyBvbGRlciB0aGFuIG9uZS1oYWxmIG9mIHRoZSBTa2lwIEJvdW5kYXJ5LlxuICAvLyBAc2VlOiBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LXBhbnRvcy1obHMtcmZjODIxNmJpcyNzZWN0aW9uLTYuMy43XG4gIGNvbnN0IHBsYXlsaXN0UmVjZW50RW5vdWdoID0gYWdlIDwgY2FuU2tpcFVudGlsIC8gMjtcbiAgaWYgKGNhblNraXBVbnRpbCAmJiBwbGF5bGlzdFJlY2VudEVub3VnaCkge1xuICAgIGlmIChjYW5Ta2lwRGF0ZVJhbmdlcykge1xuICAgICAgcmV0dXJuIEhsc1NraXAudjI7XG4gICAgfVxuICAgIHJldHVybiBIbHNTa2lwLlllcztcbiAgfVxuICByZXR1cm4gSGxzU2tpcC5Obztcbn1cbmNsYXNzIEhsc1VybFBhcmFtZXRlcnMge1xuICBjb25zdHJ1Y3Rvcihtc24sIHBhcnQsIHNraXApIHtcbiAgICB0aGlzLm1zbiA9IHZvaWQgMDtcbiAgICB0aGlzLnBhcnQgPSB2b2lkIDA7XG4gICAgdGhpcy5za2lwID0gdm9pZCAwO1xuICAgIHRoaXMubXNuID0gbXNuO1xuICAgIHRoaXMucGFydCA9IHBhcnQ7XG4gICAgdGhpcy5za2lwID0gc2tpcDtcbiAgfVxuICBhZGREaXJlY3RpdmVzKHVyaSkge1xuICAgIGNvbnN0IHVybCA9IG5ldyBzZWxmLlVSTCh1cmkpO1xuICAgIGlmICh0aGlzLm1zbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnX0hMU19tc24nLCB0aGlzLm1zbi50b1N0cmluZygpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnX0hMU19wYXJ0JywgdGhpcy5wYXJ0LnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5za2lwKSB7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnX0hMU19za2lwJywgdGhpcy5za2lwKTtcbiAgICB9XG4gICAgcmV0dXJuIHVybC5ocmVmO1xuICB9XG59XG5jbGFzcyBMZXZlbCB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICB0aGlzLl9hdHRycyA9IHZvaWQgMDtcbiAgICB0aGlzLmF1ZGlvQ29kZWMgPSB2b2lkIDA7XG4gICAgdGhpcy5iaXRyYXRlID0gdm9pZCAwO1xuICAgIHRoaXMuY29kZWNTZXQgPSB2b2lkIDA7XG4gICAgdGhpcy51cmwgPSB2b2lkIDA7XG4gICAgdGhpcy5mcmFtZVJhdGUgPSB2b2lkIDA7XG4gICAgdGhpcy5oZWlnaHQgPSB2b2lkIDA7XG4gICAgdGhpcy5pZCA9IHZvaWQgMDtcbiAgICB0aGlzLm5hbWUgPSB2b2lkIDA7XG4gICAgdGhpcy5zdXBwbGVtZW50YWwgPSB2b2lkIDA7XG4gICAgdGhpcy52aWRlb0NvZGVjID0gdm9pZCAwO1xuICAgIHRoaXMud2lkdGggPSB2b2lkIDA7XG4gICAgdGhpcy5kZXRhaWxzID0gdm9pZCAwO1xuICAgIHRoaXMuZnJhZ21lbnRFcnJvciA9IDA7XG4gICAgdGhpcy5sb2FkRXJyb3IgPSAwO1xuICAgIHRoaXMubG9hZGVkID0gdm9pZCAwO1xuICAgIHRoaXMucmVhbEJpdHJhdGUgPSAwO1xuICAgIHRoaXMuc3VwcG9ydGVkUHJvbWlzZSA9IHZvaWQgMDtcbiAgICB0aGlzLnN1cHBvcnRlZFJlc3VsdCA9IHZvaWQgMDtcbiAgICB0aGlzLl9hdmdCaXRyYXRlID0gMDtcbiAgICB0aGlzLl9hdWRpb0dyb3VwcyA9IHZvaWQgMDtcbiAgICB0aGlzLl9zdWJ0aXRsZUdyb3VwcyA9IHZvaWQgMDtcbiAgICAvLyBEZXByZWNhdGVkIChyZXRhaW5lZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkpXG4gICAgdGhpcy5fdXJsSWQgPSAwO1xuICAgIHRoaXMudXJsID0gW2RhdGEudXJsXTtcbiAgICB0aGlzLl9hdHRycyA9IFtkYXRhLmF0dHJzXTtcbiAgICB0aGlzLmJpdHJhdGUgPSBkYXRhLmJpdHJhdGU7XG4gICAgaWYgKGRhdGEuZGV0YWlscykge1xuICAgICAgdGhpcy5kZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuICAgIH1cbiAgICB0aGlzLmlkID0gZGF0YS5pZCB8fCAwO1xuICAgIHRoaXMubmFtZSA9IGRhdGEubmFtZTtcbiAgICB0aGlzLndpZHRoID0gZGF0YS53aWR0aCB8fCAwO1xuICAgIHRoaXMuaGVpZ2h0ID0gZGF0YS5oZWlnaHQgfHwgMDtcbiAgICB0aGlzLmZyYW1lUmF0ZSA9IGRhdGEuYXR0cnMub3B0aW9uYWxGbG9hdCgnRlJBTUUtUkFURScsIDApO1xuICAgIHRoaXMuX2F2Z0JpdHJhdGUgPSBkYXRhLmF0dHJzLmRlY2ltYWxJbnRlZ2VyKCdBVkVSQUdFLUJBTkRXSURUSCcpO1xuICAgIHRoaXMuYXVkaW9Db2RlYyA9IGRhdGEuYXVkaW9Db2RlYztcbiAgICB0aGlzLnZpZGVvQ29kZWMgPSBkYXRhLnZpZGVvQ29kZWM7XG4gICAgdGhpcy5jb2RlY1NldCA9IFtkYXRhLnZpZGVvQ29kZWMsIGRhdGEuYXVkaW9Db2RlY10uZmlsdGVyKGMgPT4gISFjKS5tYXAocyA9PiBzLnN1YnN0cmluZygwLCA0KSkuam9pbignLCcpO1xuICAgIGlmICgnc3VwcGxlbWVudGFsJyBpbiBkYXRhKSB7XG4gICAgICB2YXIgX2RhdGEkc3VwcGxlbWVudGFsO1xuICAgICAgdGhpcy5zdXBwbGVtZW50YWwgPSBkYXRhLnN1cHBsZW1lbnRhbDtcbiAgICAgIGNvbnN0IHN1cHBsZW1lbnRhbFZpZGVvID0gKF9kYXRhJHN1cHBsZW1lbnRhbCA9IGRhdGEuc3VwcGxlbWVudGFsKSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGEkc3VwcGxlbWVudGFsLnZpZGVvQ29kZWM7XG4gICAgICBpZiAoc3VwcGxlbWVudGFsVmlkZW8gJiYgc3VwcGxlbWVudGFsVmlkZW8gIT09IGRhdGEudmlkZW9Db2RlYykge1xuICAgICAgICB0aGlzLmNvZGVjU2V0ICs9IGAsJHtzdXBwbGVtZW50YWxWaWRlby5zdWJzdHJpbmcoMCwgNCl9YDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5hZGRHcm91cElkKCdhdWRpbycsIGRhdGEuYXR0cnMuQVVESU8pO1xuICAgIHRoaXMuYWRkR3JvdXBJZCgndGV4dCcsIGRhdGEuYXR0cnMuU1VCVElUTEVTKTtcbiAgfVxuICBnZXQgbWF4Qml0cmF0ZSgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5yZWFsQml0cmF0ZSwgdGhpcy5iaXRyYXRlKTtcbiAgfVxuICBnZXQgYXZlcmFnZUJpdHJhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F2Z0JpdHJhdGUgfHwgdGhpcy5yZWFsQml0cmF0ZSB8fCB0aGlzLmJpdHJhdGU7XG4gIH1cbiAgZ2V0IGF0dHJzKCkge1xuICAgIHJldHVybiB0aGlzLl9hdHRyc1swXTtcbiAgfVxuICBnZXQgY29kZWNzKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJzLkNPREVDUyB8fCAnJztcbiAgfVxuICBnZXQgcGF0aHdheUlkKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJzWydQQVRIV0FZLUlEJ10gfHwgJy4nO1xuICB9XG4gIGdldCB2aWRlb1JhbmdlKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJzWydWSURFTy1SQU5HRSddIHx8ICdTRFInO1xuICB9XG4gIGdldCBzY29yZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRycy5vcHRpb25hbEZsb2F0KCdTQ09SRScsIDApO1xuICB9XG4gIGdldCB1cmkoKSB7XG4gICAgcmV0dXJuIHRoaXMudXJsWzBdIHx8ICcnO1xuICB9XG4gIGhhc0F1ZGlvR3JvdXAoZ3JvdXBJZCkge1xuICAgIHJldHVybiBoYXNHcm91cCh0aGlzLl9hdWRpb0dyb3VwcywgZ3JvdXBJZCk7XG4gIH1cbiAgaGFzU3VidGl0bGVHcm91cChncm91cElkKSB7XG4gICAgcmV0dXJuIGhhc0dyb3VwKHRoaXMuX3N1YnRpdGxlR3JvdXBzLCBncm91cElkKTtcbiAgfVxuICBnZXQgYXVkaW9Hcm91cHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F1ZGlvR3JvdXBzO1xuICB9XG4gIGdldCBzdWJ0aXRsZUdyb3VwcygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3VidGl0bGVHcm91cHM7XG4gIH1cbiAgYWRkR3JvdXBJZCh0eXBlLCBncm91cElkKSB7XG4gICAgaWYgKCFncm91cElkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICBsZXQgYXVkaW9Hcm91cHMgPSB0aGlzLl9hdWRpb0dyb3VwcztcbiAgICAgIGlmICghYXVkaW9Hcm91cHMpIHtcbiAgICAgICAgYXVkaW9Hcm91cHMgPSB0aGlzLl9hdWRpb0dyb3VwcyA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKGF1ZGlvR3JvdXBzLmluZGV4T2YoZ3JvdXBJZCkgPT09IC0xKSB7XG4gICAgICAgIGF1ZGlvR3JvdXBzLnB1c2goZ3JvdXBJZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAndGV4dCcpIHtcbiAgICAgIGxldCBzdWJ0aXRsZUdyb3VwcyA9IHRoaXMuX3N1YnRpdGxlR3JvdXBzO1xuICAgICAgaWYgKCFzdWJ0aXRsZUdyb3Vwcykge1xuICAgICAgICBzdWJ0aXRsZUdyb3VwcyA9IHRoaXMuX3N1YnRpdGxlR3JvdXBzID0gW107XG4gICAgICB9XG4gICAgICBpZiAoc3VidGl0bGVHcm91cHMuaW5kZXhPZihncm91cElkKSA9PT0gLTEpIHtcbiAgICAgICAgc3VidGl0bGVHcm91cHMucHVzaChncm91cElkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBEZXByZWNhdGVkIG1ldGhvZHMgKHJldGFpbmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSlcbiAgZ2V0IHVybElkKCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHNldCB1cmxJZCh2YWx1ZSkge31cbiAgZ2V0IGF1ZGlvR3JvdXBJZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXVkaW9Hcm91cHMgPyBbdGhpcy5hdWRpb0dyb3VwSWRdIDogdW5kZWZpbmVkO1xuICB9XG4gIGdldCB0ZXh0R3JvdXBJZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3VidGl0bGVHcm91cHMgPyBbdGhpcy50ZXh0R3JvdXBJZF0gOiB1bmRlZmluZWQ7XG4gIH1cbiAgZ2V0IGF1ZGlvR3JvdXBJZCgpIHtcbiAgICB2YXIgX3RoaXMkYXVkaW9Hcm91cHM7XG4gICAgcmV0dXJuIChfdGhpcyRhdWRpb0dyb3VwcyA9IHRoaXMuYXVkaW9Hcm91cHMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRhdWRpb0dyb3Vwc1swXTtcbiAgfVxuICBnZXQgdGV4dEdyb3VwSWQoKSB7XG4gICAgdmFyIF90aGlzJHN1YnRpdGxlR3JvdXBzO1xuICAgIHJldHVybiAoX3RoaXMkc3VidGl0bGVHcm91cHMgPSB0aGlzLnN1YnRpdGxlR3JvdXBzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkc3VidGl0bGVHcm91cHNbMF07XG4gIH1cbiAgYWRkRmFsbGJhY2soKSB7fVxufVxuZnVuY3Rpb24gaGFzR3JvdXAoZ3JvdXBzLCBncm91cElkKSB7XG4gIGlmICghZ3JvdXBJZCB8fCAhZ3JvdXBzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBncm91cHMuaW5kZXhPZihncm91cElkKSAhPT0gLTE7XG59XG5cbi8qKlxuICogQHJldHVybnMgV2hldGhlciB3ZSBjYW4gZGV0ZWN0IGFuZCB2YWxpZGF0ZSBIRFIgY2FwYWJpbGl0eSB3aXRoaW4gdGhlIHdpbmRvdyBjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIGlzSGRyU3VwcG9ydGVkKCkge1xuICBpZiAodHlwZW9mIG1hdGNoTWVkaWEgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCBtZWRpYVF1ZXJ5TGlzdCA9IG1hdGNoTWVkaWEoJyhkeW5hbWljLXJhbmdlOiBoaWdoKScpO1xuICAgIGNvbnN0IGJhZFF1ZXJ5ID0gbWF0Y2hNZWRpYSgnYmFkIHF1ZXJ5Jyk7XG4gICAgaWYgKG1lZGlhUXVlcnlMaXN0Lm1lZGlhICE9PSBiYWRRdWVyeS5tZWRpYSkge1xuICAgICAgcmV0dXJuIG1lZGlhUXVlcnlMaXN0Lm1hdGNoZXMgPT09IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBTYW5pdGl6ZXMgaW5wdXRzIHRvIHJldHVybiB0aGUgYWN0aXZlIHZpZGVvIHNlbGVjdGlvbiBvcHRpb25zIGZvciBIRFIvU0RSLlxuICogV2hlbiBib3RoIGlucHV0cyBhcmUgbnVsbDpcbiAqXG4gKiAgICBgeyBwcmVmZXJIRFI6IGZhbHNlLCBhbGxvd2VkVmlkZW9SYW5nZXM6IFtdIH1gXG4gKlxuICogV2hlbiBgY3VycmVudFZpZGVvUmFuZ2VgIG5vbi1udWxsLCBtYWludGFpbiB0aGUgYWN0aXZlIHJhbmdlOlxuICpcbiAqICAgIGB7IHByZWZlckhEUjogY3VycmVudFZpZGVvUmFuZ2UgIT09ICdTRFInLCBhbGxvd2VkVmlkZW9SYW5nZXM6IFtjdXJyZW50VmlkZW9SYW5nZV0gfWBcbiAqXG4gKiBXaGVuIFZpZGVvU2VsZWN0aW9uT3B0aW9uIG5vbi1udWxsOlxuICpcbiAqICAtIEFsbG93IGFsbCB2aWRlbyByYW5nZXMgaWYgYGFsbG93ZWRWaWRlb1Jhbmdlc2AgdW5zcGVjaWZpZWQuXG4gKiAgLSBJZiBgcHJlZmVySERSYCBpcyBub24tbnVsbCB1c2UgdGhlIHZhbHVlIHRvIGZpbHRlciBgYWxsb3dlZFZpZGVvUmFuZ2VzYC5cbiAqICAtIEVsc2UgY2hlY2sgd2luZG93IGZvciBIRFIgc3VwcG9ydCBhbmQgc2V0IGBwcmVmZXJIRFJgIHRvIHRoZSByZXN1bHQuXG4gKlxuICogQHBhcmFtIGN1cnJlbnRWaWRlb1JhbmdlXG4gKiBAcGFyYW0gdmlkZW9QcmVmZXJlbmNlXG4gKi9cbmZ1bmN0aW9uIGdldFZpZGVvU2VsZWN0aW9uT3B0aW9ucyhjdXJyZW50VmlkZW9SYW5nZSwgdmlkZW9QcmVmZXJlbmNlKSB7XG4gIGxldCBwcmVmZXJIRFIgPSBmYWxzZTtcbiAgbGV0IGFsbG93ZWRWaWRlb1JhbmdlcyA9IFtdO1xuICBpZiAoY3VycmVudFZpZGVvUmFuZ2UpIHtcbiAgICBwcmVmZXJIRFIgPSBjdXJyZW50VmlkZW9SYW5nZSAhPT0gJ1NEUic7XG4gICAgYWxsb3dlZFZpZGVvUmFuZ2VzID0gW2N1cnJlbnRWaWRlb1JhbmdlXTtcbiAgfVxuICBpZiAodmlkZW9QcmVmZXJlbmNlKSB7XG4gICAgYWxsb3dlZFZpZGVvUmFuZ2VzID0gdmlkZW9QcmVmZXJlbmNlLmFsbG93ZWRWaWRlb1JhbmdlcyB8fCBWaWRlb1JhbmdlVmFsdWVzLnNsaWNlKDApO1xuICAgIGNvbnN0IGFsbG93QXV0b1ByZWZlckhEUiA9IGFsbG93ZWRWaWRlb1Jhbmdlcy5qb2luKCcnKSAhPT0gJ1NEUicgJiYgIXZpZGVvUHJlZmVyZW5jZS52aWRlb0NvZGVjO1xuICAgIHByZWZlckhEUiA9IHZpZGVvUHJlZmVyZW5jZS5wcmVmZXJIRFIgIT09IHVuZGVmaW5lZCA/IHZpZGVvUHJlZmVyZW5jZS5wcmVmZXJIRFIgOiBhbGxvd0F1dG9QcmVmZXJIRFIgJiYgaXNIZHJTdXBwb3J0ZWQoKTtcbiAgICBpZiAoIXByZWZlckhEUikge1xuICAgICAgYWxsb3dlZFZpZGVvUmFuZ2VzID0gWydTRFInXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwcmVmZXJIRFIsXG4gICAgYWxsb3dlZFZpZGVvUmFuZ2VzXG4gIH07XG59XG5cbmNvbnN0IG9taXRDaXJjdWxhclJlZnNSZXBsYWNlciA9IHJlcGxhY2VyID0+IHtcbiAgY29uc3Qga25vd24gPSBuZXcgV2Vha1NldCgpO1xuICByZXR1cm4gKF8sIHZhbHVlKSA9PiB7XG4gICAgaWYgKHJlcGxhY2VyKSB7XG4gICAgICB2YWx1ZSA9IHJlcGxhY2VyKF8sIHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgIGlmIChrbm93bi5oYXModmFsdWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGtub3duLmFkZCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn07XG5jb25zdCBzdHJpbmdpZnkgPSAob2JqZWN0LCByZXBsYWNlcikgPT4gSlNPTi5zdHJpbmdpZnkob2JqZWN0LCBvbWl0Q2lyY3VsYXJSZWZzUmVwbGFjZXIocmVwbGFjZXIpKTtcblxuZnVuY3Rpb24gZ2V0U3RhcnRDb2RlY1RpZXIoY29kZWNUaWVycywgY3VycmVudFZpZGVvUmFuZ2UsIGN1cnJlbnRCdywgYXVkaW9QcmVmZXJlbmNlLCB2aWRlb1ByZWZlcmVuY2UpIHtcbiAgY29uc3QgY29kZWNTZXRzID0gT2JqZWN0LmtleXMoY29kZWNUaWVycyk7XG4gIGNvbnN0IGNoYW5uZWxzUHJlZmVyZW5jZSA9IGF1ZGlvUHJlZmVyZW5jZSA9PSBudWxsID8gdm9pZCAwIDogYXVkaW9QcmVmZXJlbmNlLmNoYW5uZWxzO1xuICBjb25zdCBhdWRpb0NvZGVjUHJlZmVyZW5jZSA9IGF1ZGlvUHJlZmVyZW5jZSA9PSBudWxsID8gdm9pZCAwIDogYXVkaW9QcmVmZXJlbmNlLmF1ZGlvQ29kZWM7XG4gIGNvbnN0IHZpZGVvQ29kZWNQcmVmZXJlbmNlID0gdmlkZW9QcmVmZXJlbmNlID09IG51bGwgPyB2b2lkIDAgOiB2aWRlb1ByZWZlcmVuY2UudmlkZW9Db2RlYztcbiAgY29uc3QgcHJlZmVyU3RlcmVvID0gY2hhbm5lbHNQcmVmZXJlbmNlICYmIHBhcnNlSW50KGNoYW5uZWxzUHJlZmVyZW5jZSkgPT09IDI7XG4gIC8vIFVzZSBmaXJzdCBsZXZlbCBzZXQgdG8gZGV0ZXJtaW5lIHN0ZXJlbywgYW5kIG1pbmltdW0gcmVzb2x1dGlvbiBhbmQgZnJhbWVyYXRlXG4gIGxldCBoYXNTdGVyZW8gPSBmYWxzZTtcbiAgbGV0IGhhc0N1cnJlbnRWaWRlb1JhbmdlID0gZmFsc2U7XG4gIGxldCBtaW5IZWlnaHQgPSBJbmZpbml0eTtcbiAgbGV0IG1pbkZyYW1lcmF0ZSA9IEluZmluaXR5O1xuICBsZXQgbWluQml0cmF0ZSA9IEluZmluaXR5O1xuICBsZXQgbWluSW5kZXggPSBJbmZpbml0eTtcbiAgbGV0IHNlbGVjdGVkU2NvcmUgPSAwO1xuICBsZXQgdmlkZW9SYW5nZXMgPSBbXTtcbiAgY29uc3Qge1xuICAgIHByZWZlckhEUixcbiAgICBhbGxvd2VkVmlkZW9SYW5nZXNcbiAgfSA9IGdldFZpZGVvU2VsZWN0aW9uT3B0aW9ucyhjdXJyZW50VmlkZW9SYW5nZSwgdmlkZW9QcmVmZXJlbmNlKTtcbiAgZm9yIChsZXQgaSA9IGNvZGVjU2V0cy5sZW5ndGg7IGktLTspIHtcbiAgICBjb25zdCB0aWVyID0gY29kZWNUaWVyc1tjb2RlY1NldHNbaV1dO1xuICAgIGhhc1N0ZXJlbyB8fCAoaGFzU3RlcmVvID0gdGllci5jaGFubmVsc1syXSA+IDApO1xuICAgIG1pbkhlaWdodCA9IE1hdGgubWluKG1pbkhlaWdodCwgdGllci5taW5IZWlnaHQpO1xuICAgIG1pbkZyYW1lcmF0ZSA9IE1hdGgubWluKG1pbkZyYW1lcmF0ZSwgdGllci5taW5GcmFtZXJhdGUpO1xuICAgIG1pbkJpdHJhdGUgPSBNYXRoLm1pbihtaW5CaXRyYXRlLCB0aWVyLm1pbkJpdHJhdGUpO1xuICAgIGNvbnN0IG1hdGNoaW5nVmlkZW9SYW5nZXMgPSBhbGxvd2VkVmlkZW9SYW5nZXMuZmlsdGVyKHJhbmdlID0+IHRpZXIudmlkZW9SYW5nZXNbcmFuZ2VdID4gMCk7XG4gICAgaWYgKG1hdGNoaW5nVmlkZW9SYW5nZXMubGVuZ3RoID4gMCkge1xuICAgICAgaGFzQ3VycmVudFZpZGVvUmFuZ2UgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBtaW5IZWlnaHQgPSBpc0Zpbml0ZU51bWJlcihtaW5IZWlnaHQpID8gbWluSGVpZ2h0IDogMDtcbiAgbWluRnJhbWVyYXRlID0gaXNGaW5pdGVOdW1iZXIobWluRnJhbWVyYXRlKSA/IG1pbkZyYW1lcmF0ZSA6IDA7XG4gIGNvbnN0IG1heEhlaWdodCA9IE1hdGgubWF4KDEwODAsIG1pbkhlaWdodCk7XG4gIGNvbnN0IG1heEZyYW1lcmF0ZSA9IE1hdGgubWF4KDMwLCBtaW5GcmFtZXJhdGUpO1xuICBtaW5CaXRyYXRlID0gaXNGaW5pdGVOdW1iZXIobWluQml0cmF0ZSkgPyBtaW5CaXRyYXRlIDogY3VycmVudEJ3O1xuICBjdXJyZW50QncgPSBNYXRoLm1heChtaW5CaXRyYXRlLCBjdXJyZW50QncpO1xuICAvLyBJZiB0aGVyZSBhcmUgbm8gdmFyaWFudHMgd2l0aCBtYXRjaGluZyBwcmVmZXJlbmNlLCBzZXQgY3VycmVudFZpZGVvUmFuZ2UgdG8gdW5kZWZpbmVkXG4gIGlmICghaGFzQ3VycmVudFZpZGVvUmFuZ2UpIHtcbiAgICBjdXJyZW50VmlkZW9SYW5nZSA9IHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCBoYXNNdWx0aXBsZVNldHMgPSBjb2RlY1NldHMubGVuZ3RoID4gMTtcbiAgY29uc3QgY29kZWNTZXQgPSBjb2RlY1NldHMucmVkdWNlKChzZWxlY3RlZCwgY2FuZGlkYXRlKSA9PiB7XG4gICAgLy8gUmVtb3ZlIGNhbmRpYXRlcyB3aGljaCBkbyBub3QgbWVldCBiaXRyYXRlLCBkZWZhdWx0IGF1ZGlvLCBzdGVyZW8gb3IgY2hhbm5lbHMgcHJlZmVyZW5jZSwgMTA4MHAgb3IgbG93ZXIsIDMwZnBzIG9yIGxvd2VyLCBvciBTRFIvSERSIHNlbGVjdGlvbiBpZiBwcmVzZW50XG4gICAgY29uc3QgY2FuZGlkYXRlVGllciA9IGNvZGVjVGllcnNbY2FuZGlkYXRlXTtcbiAgICBpZiAoY2FuZGlkYXRlID09PSBzZWxlY3RlZCkge1xuICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgIH1cbiAgICB2aWRlb1JhbmdlcyA9IGhhc0N1cnJlbnRWaWRlb1JhbmdlID8gYWxsb3dlZFZpZGVvUmFuZ2VzLmZpbHRlcihyYW5nZSA9PiBjYW5kaWRhdGVUaWVyLnZpZGVvUmFuZ2VzW3JhbmdlXSA+IDApIDogW107XG4gICAgaWYgKGhhc011bHRpcGxlU2V0cykge1xuICAgICAgaWYgKGNhbmRpZGF0ZVRpZXIubWluQml0cmF0ZSA+IGN1cnJlbnRCdykge1xuICAgICAgICBsb2dTdGFydENvZGVjQ2FuZGlkYXRlSWdub3JlZChjYW5kaWRhdGUsIGBtaW4gYml0cmF0ZSBvZiAke2NhbmRpZGF0ZVRpZXIubWluQml0cmF0ZX0gPiBjdXJyZW50IGVzdGltYXRlIG9mICR7Y3VycmVudEJ3fWApO1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgICBpZiAoIWNhbmRpZGF0ZVRpZXIuaGFzRGVmYXVsdEF1ZGlvKSB7XG4gICAgICAgIGxvZ1N0YXJ0Q29kZWNDYW5kaWRhdGVJZ25vcmVkKGNhbmRpZGF0ZSwgYG5vIHJlbmRpdGlvbnMgd2l0aCBkZWZhdWx0IG9yIGF1dG8tc2VsZWN0IHNvdW5kIGZvdW5kYCk7XG4gICAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICAgIGlmIChhdWRpb0NvZGVjUHJlZmVyZW5jZSAmJiBjYW5kaWRhdGUuaW5kZXhPZihhdWRpb0NvZGVjUHJlZmVyZW5jZS5zdWJzdHJpbmcoMCwgNCkpICUgNSAhPT0gMCkge1xuICAgICAgICBsb2dTdGFydENvZGVjQ2FuZGlkYXRlSWdub3JlZChjYW5kaWRhdGUsIGBhdWRpbyBjb2RlYyBwcmVmZXJlbmNlIFwiJHthdWRpb0NvZGVjUHJlZmVyZW5jZX1cIiBub3QgZm91bmRgKTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgICAgfVxuICAgICAgaWYgKGNoYW5uZWxzUHJlZmVyZW5jZSAmJiAhcHJlZmVyU3RlcmVvKSB7XG4gICAgICAgIGlmICghY2FuZGlkYXRlVGllci5jaGFubmVsc1tjaGFubmVsc1ByZWZlcmVuY2VdKSB7XG4gICAgICAgICAgbG9nU3RhcnRDb2RlY0NhbmRpZGF0ZUlnbm9yZWQoY2FuZGlkYXRlLCBgbm8gcmVuZGl0aW9ucyB3aXRoICR7Y2hhbm5lbHNQcmVmZXJlbmNlfSBjaGFubmVsIHNvdW5kIGZvdW5kIChjaGFubmVscyBvcHRpb25zOiAke09iamVjdC5rZXlzKGNhbmRpZGF0ZVRpZXIuY2hhbm5lbHMpfSlgKTtcbiAgICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoKCFhdWRpb0NvZGVjUHJlZmVyZW5jZSB8fCBwcmVmZXJTdGVyZW8pICYmIGhhc1N0ZXJlbyAmJiBjYW5kaWRhdGVUaWVyLmNoYW5uZWxzWycyJ10gPT09IDApIHtcbiAgICAgICAgbG9nU3RhcnRDb2RlY0NhbmRpZGF0ZUlnbm9yZWQoY2FuZGlkYXRlLCBgbm8gcmVuZGl0aW9ucyB3aXRoIHN0ZXJlbyBzb3VuZCBmb3VuZGApO1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgICBpZiAoY2FuZGlkYXRlVGllci5taW5IZWlnaHQgPiBtYXhIZWlnaHQpIHtcbiAgICAgICAgbG9nU3RhcnRDb2RlY0NhbmRpZGF0ZUlnbm9yZWQoY2FuZGlkYXRlLCBgbWluIHJlc29sdXRpb24gb2YgJHtjYW5kaWRhdGVUaWVyLm1pbkhlaWdodH0gPiBtYXhpbXVtIG9mICR7bWF4SGVpZ2h0fWApO1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgICBpZiAoY2FuZGlkYXRlVGllci5taW5GcmFtZXJhdGUgPiBtYXhGcmFtZXJhdGUpIHtcbiAgICAgICAgbG9nU3RhcnRDb2RlY0NhbmRpZGF0ZUlnbm9yZWQoY2FuZGlkYXRlLCBgbWluIGZyYW1lcmF0ZSBvZiAke2NhbmRpZGF0ZVRpZXIubWluRnJhbWVyYXRlfSA+IG1heGltdW0gb2YgJHttYXhGcmFtZXJhdGV9YCk7XG4gICAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICAgIGlmICghdmlkZW9SYW5nZXMuc29tZShyYW5nZSA9PiBjYW5kaWRhdGVUaWVyLnZpZGVvUmFuZ2VzW3JhbmdlXSA+IDApKSB7XG4gICAgICAgIGxvZ1N0YXJ0Q29kZWNDYW5kaWRhdGVJZ25vcmVkKGNhbmRpZGF0ZSwgYG5vIHZhcmlhbnRzIHdpdGggVklERU8tUkFOR0Ugb2YgJHtzdHJpbmdpZnkodmlkZW9SYW5nZXMpfSBmb3VuZGApO1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgICBpZiAodmlkZW9Db2RlY1ByZWZlcmVuY2UgJiYgY2FuZGlkYXRlLmluZGV4T2YodmlkZW9Db2RlY1ByZWZlcmVuY2Uuc3Vic3RyaW5nKDAsIDQpKSAlIDUgIT09IDApIHtcbiAgICAgICAgbG9nU3RhcnRDb2RlY0NhbmRpZGF0ZUlnbm9yZWQoY2FuZGlkYXRlLCBgdmlkZW8gY29kZWMgcHJlZmVyZW5jZSBcIiR7dmlkZW9Db2RlY1ByZWZlcmVuY2V9XCIgbm90IGZvdW5kYCk7XG4gICAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5kaWRhdGVUaWVyLm1heFNjb3JlIDwgc2VsZWN0ZWRTY29yZSkge1xuICAgICAgICBsb2dTdGFydENvZGVjQ2FuZGlkYXRlSWdub3JlZChjYW5kaWRhdGUsIGBtYXggc2NvcmUgb2YgJHtjYW5kaWRhdGVUaWVyLm1heFNjb3JlfSA8IHNlbGVjdGVkIG1heCBvZiAke3NlbGVjdGVkU2NvcmV9YCk7XG4gICAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVtb3ZlIGNhbmRpYXRlcyB3aXRoIGxlc3MgcHJlZmVycmVkIGNvZGVjcyBvciBtb3JlIGVycm9yc1xuICAgIGlmIChzZWxlY3RlZCAmJiAoY29kZWNzU2V0U2VsZWN0aW9uUHJlZmVyZW5jZVZhbHVlKGNhbmRpZGF0ZSkgPj0gY29kZWNzU2V0U2VsZWN0aW9uUHJlZmVyZW5jZVZhbHVlKHNlbGVjdGVkKSB8fCBjYW5kaWRhdGVUaWVyLmZyYWdtZW50RXJyb3IgPiBjb2RlY1RpZXJzW3NlbGVjdGVkXS5mcmFnbWVudEVycm9yKSkge1xuICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgIH1cbiAgICBtaW5JbmRleCA9IGNhbmRpZGF0ZVRpZXIubWluSW5kZXg7XG4gICAgc2VsZWN0ZWRTY29yZSA9IGNhbmRpZGF0ZVRpZXIubWF4U2NvcmU7XG4gICAgcmV0dXJuIGNhbmRpZGF0ZTtcbiAgfSwgdW5kZWZpbmVkKTtcbiAgcmV0dXJuIHtcbiAgICBjb2RlY1NldCxcbiAgICB2aWRlb1JhbmdlcyxcbiAgICBwcmVmZXJIRFIsXG4gICAgbWluRnJhbWVyYXRlLFxuICAgIG1pbkJpdHJhdGUsXG4gICAgbWluSW5kZXhcbiAgfTtcbn1cbmZ1bmN0aW9uIGxvZ1N0YXJ0Q29kZWNDYW5kaWRhdGVJZ25vcmVkKGNvZGVTZXQsIHJlYXNvbikge1xuICBsb2dnZXIubG9nKGBbYWJyXSBzdGFydCBjYW5kaWRhdGVzIHdpdGggXCIke2NvZGVTZXR9XCIgaWdub3JlZCBiZWNhdXNlICR7cmVhc29ufWApO1xufVxuZnVuY3Rpb24gZ2V0QXVkaW9UcmFja3NCeUdyb3VwKGFsbEF1ZGlvVHJhY2tzKSB7XG4gIHJldHVybiBhbGxBdWRpb1RyYWNrcy5yZWR1Y2UoKGF1ZGlvVHJhY2tzQnlHcm91cCwgdHJhY2spID0+IHtcbiAgICBsZXQgdHJhY2tHcm91cCA9IGF1ZGlvVHJhY2tzQnlHcm91cC5ncm91cHNbdHJhY2suZ3JvdXBJZF07XG4gICAgaWYgKCF0cmFja0dyb3VwKSB7XG4gICAgICB0cmFja0dyb3VwID0gYXVkaW9UcmFja3NCeUdyb3VwLmdyb3Vwc1t0cmFjay5ncm91cElkXSA9IHtcbiAgICAgICAgdHJhY2tzOiBbXSxcbiAgICAgICAgY2hhbm5lbHM6IHtcbiAgICAgICAgICAyOiAwXG4gICAgICAgIH0sXG4gICAgICAgIGhhc0RlZmF1bHQ6IGZhbHNlLFxuICAgICAgICBoYXNBdXRvU2VsZWN0OiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgdHJhY2tHcm91cC50cmFja3MucHVzaCh0cmFjayk7XG4gICAgY29uc3QgY2hhbm5lbHNLZXkgPSB0cmFjay5jaGFubmVscyB8fCAnMic7XG4gICAgdHJhY2tHcm91cC5jaGFubmVsc1tjaGFubmVsc0tleV0gPSAodHJhY2tHcm91cC5jaGFubmVsc1tjaGFubmVsc0tleV0gfHwgMCkgKyAxO1xuICAgIHRyYWNrR3JvdXAuaGFzRGVmYXVsdCA9IHRyYWNrR3JvdXAuaGFzRGVmYXVsdCB8fCB0cmFjay5kZWZhdWx0O1xuICAgIHRyYWNrR3JvdXAuaGFzQXV0b1NlbGVjdCA9IHRyYWNrR3JvdXAuaGFzQXV0b1NlbGVjdCB8fCB0cmFjay5hdXRvc2VsZWN0O1xuICAgIGlmICh0cmFja0dyb3VwLmhhc0RlZmF1bHQpIHtcbiAgICAgIGF1ZGlvVHJhY2tzQnlHcm91cC5oYXNEZWZhdWx0QXVkaW8gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodHJhY2tHcm91cC5oYXNBdXRvU2VsZWN0KSB7XG4gICAgICBhdWRpb1RyYWNrc0J5R3JvdXAuaGFzQXV0b1NlbGVjdEF1ZGlvID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGF1ZGlvVHJhY2tzQnlHcm91cDtcbiAgfSwge1xuICAgIGhhc0RlZmF1bHRBdWRpbzogZmFsc2UsXG4gICAgaGFzQXV0b1NlbGVjdEF1ZGlvOiBmYWxzZSxcbiAgICBncm91cHM6IHt9XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0Q29kZWNUaWVycyhsZXZlbHMsIGF1ZGlvVHJhY2tzQnlHcm91cCwgbWluQXV0b0xldmVsLCBtYXhBdXRvTGV2ZWwpIHtcbiAgcmV0dXJuIGxldmVscy5zbGljZShtaW5BdXRvTGV2ZWwsIG1heEF1dG9MZXZlbCArIDEpLnJlZHVjZSgodGllcnMsIGxldmVsLCBpbmRleCkgPT4ge1xuICAgIGlmICghbGV2ZWwuY29kZWNTZXQpIHtcbiAgICAgIHJldHVybiB0aWVycztcbiAgICB9XG4gICAgY29uc3QgYXVkaW9Hcm91cHMgPSBsZXZlbC5hdWRpb0dyb3VwcztcbiAgICBsZXQgdGllciA9IHRpZXJzW2xldmVsLmNvZGVjU2V0XTtcbiAgICBpZiAoIXRpZXIpIHtcbiAgICAgIHRpZXJzW2xldmVsLmNvZGVjU2V0XSA9IHRpZXIgPSB7XG4gICAgICAgIG1pbkJpdHJhdGU6IEluZmluaXR5LFxuICAgICAgICBtaW5IZWlnaHQ6IEluZmluaXR5LFxuICAgICAgICBtaW5GcmFtZXJhdGU6IEluZmluaXR5LFxuICAgICAgICBtaW5JbmRleDogaW5kZXgsXG4gICAgICAgIG1heFNjb3JlOiAwLFxuICAgICAgICB2aWRlb1Jhbmdlczoge1xuICAgICAgICAgIFNEUjogMFxuICAgICAgICB9LFxuICAgICAgICBjaGFubmVsczoge1xuICAgICAgICAgICcyJzogMFxuICAgICAgICB9LFxuICAgICAgICBoYXNEZWZhdWx0QXVkaW86ICFhdWRpb0dyb3VwcyxcbiAgICAgICAgZnJhZ21lbnRFcnJvcjogMFxuICAgICAgfTtcbiAgICB9XG4gICAgdGllci5taW5CaXRyYXRlID0gTWF0aC5taW4odGllci5taW5CaXRyYXRlLCBsZXZlbC5iaXRyYXRlKTtcbiAgICBjb25zdCBsZXNzZXJXaWR0aE9ySGVpZ2h0ID0gTWF0aC5taW4obGV2ZWwuaGVpZ2h0LCBsZXZlbC53aWR0aCk7XG4gICAgdGllci5taW5IZWlnaHQgPSBNYXRoLm1pbih0aWVyLm1pbkhlaWdodCwgbGVzc2VyV2lkdGhPckhlaWdodCk7XG4gICAgdGllci5taW5GcmFtZXJhdGUgPSBNYXRoLm1pbih0aWVyLm1pbkZyYW1lcmF0ZSwgbGV2ZWwuZnJhbWVSYXRlKTtcbiAgICB0aWVyLm1pbkluZGV4ID0gTWF0aC5taW4odGllci5taW5JbmRleCwgaW5kZXgpO1xuICAgIHRpZXIubWF4U2NvcmUgPSBNYXRoLm1heCh0aWVyLm1heFNjb3JlLCBsZXZlbC5zY29yZSk7XG4gICAgdGllci5mcmFnbWVudEVycm9yICs9IGxldmVsLmZyYWdtZW50RXJyb3I7XG4gICAgdGllci52aWRlb1Jhbmdlc1tsZXZlbC52aWRlb1JhbmdlXSA9ICh0aWVyLnZpZGVvUmFuZ2VzW2xldmVsLnZpZGVvUmFuZ2VdIHx8IDApICsgMTtcbiAgICBpZiAoYXVkaW9Hcm91cHMpIHtcbiAgICAgIGF1ZGlvR3JvdXBzLmZvckVhY2goYXVkaW9Hcm91cElkID0+IHtcbiAgICAgICAgaWYgKCFhdWRpb0dyb3VwSWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXVkaW9Hcm91cCA9IGF1ZGlvVHJhY2tzQnlHcm91cC5ncm91cHNbYXVkaW9Hcm91cElkXTtcbiAgICAgICAgaWYgKCFhdWRpb0dyb3VwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIERlZmF1bHQgYXVkaW8gaXMgYW55IGdyb3VwIHdpdGggREVGQVVMVD1ZRVMsIG9yIGlmIG1pc3NpbmcgdGhlbiBhbnkgZ3JvdXAgd2l0aCBBVVRPU0VMRUNUPVlFUywgb3IgYWxsIHZhcmlhbnRzXG4gICAgICAgIHRpZXIuaGFzRGVmYXVsdEF1ZGlvID0gdGllci5oYXNEZWZhdWx0QXVkaW8gfHwgYXVkaW9UcmFja3NCeUdyb3VwLmhhc0RlZmF1bHRBdWRpbyA/IGF1ZGlvR3JvdXAuaGFzRGVmYXVsdCA6IGF1ZGlvR3JvdXAuaGFzQXV0b1NlbGVjdCB8fCAhYXVkaW9UcmFja3NCeUdyb3VwLmhhc0RlZmF1bHRBdWRpbyAmJiAhYXVkaW9UcmFja3NCeUdyb3VwLmhhc0F1dG9TZWxlY3RBdWRpbztcbiAgICAgICAgT2JqZWN0LmtleXMoYXVkaW9Hcm91cC5jaGFubmVscykuZm9yRWFjaChjaGFubmVscyA9PiB7XG4gICAgICAgICAgdGllci5jaGFubmVsc1tjaGFubmVsc10gPSAodGllci5jaGFubmVsc1tjaGFubmVsc10gfHwgMCkgKyBhdWRpb0dyb3VwLmNoYW5uZWxzW2NoYW5uZWxzXTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRpZXJzO1xuICB9LCB7fSk7XG59XG5mdW5jdGlvbiBnZXRCYXNpY1NlbGVjdGlvbk9wdGlvbihvcHRpb24pIHtcbiAgaWYgKCFvcHRpb24pIHtcbiAgICByZXR1cm4gb3B0aW9uO1xuICB9XG4gIGNvbnN0IHtcbiAgICBsYW5nLFxuICAgIGFzc29jTGFuZyxcbiAgICBjaGFyYWN0ZXJpc3RpY3MsXG4gICAgY2hhbm5lbHMsXG4gICAgYXVkaW9Db2RlY1xuICB9ID0gb3B0aW9uO1xuICByZXR1cm4ge1xuICAgIGxhbmcsXG4gICAgYXNzb2NMYW5nLFxuICAgIGNoYXJhY3RlcmlzdGljcyxcbiAgICBjaGFubmVscyxcbiAgICBhdWRpb0NvZGVjXG4gIH07XG59XG5mdW5jdGlvbiBmaW5kTWF0Y2hpbmdPcHRpb24ob3B0aW9uLCB0cmFja3MsIG1hdGNoUHJlZGljYXRlKSB7XG4gIGlmICgnYXR0cnMnIGluIG9wdGlvbikge1xuICAgIGNvbnN0IGluZGV4ID0gdHJhY2tzLmluZGV4T2Yob3B0aW9uKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdHJhY2sgPSB0cmFja3NbaV07XG4gICAgaWYgKG1hdGNoZXNPcHRpb24ob3B0aW9uLCB0cmFjaywgbWF0Y2hQcmVkaWNhdGUpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gbWF0Y2hlc09wdGlvbihvcHRpb24sIHRyYWNrLCBtYXRjaFByZWRpY2F0ZSkge1xuICBjb25zdCB7XG4gICAgZ3JvdXBJZCxcbiAgICBuYW1lLFxuICAgIGxhbmcsXG4gICAgYXNzb2NMYW5nLFxuICAgIGRlZmF1bHQ6IGlzRGVmYXVsdFxuICB9ID0gb3B0aW9uO1xuICBjb25zdCBmb3JjZWQgPSBvcHRpb24uZm9yY2VkO1xuICByZXR1cm4gKGdyb3VwSWQgPT09IHVuZGVmaW5lZCB8fCB0cmFjay5ncm91cElkID09PSBncm91cElkKSAmJiAobmFtZSA9PT0gdW5kZWZpbmVkIHx8IHRyYWNrLm5hbWUgPT09IG5hbWUpICYmIChsYW5nID09PSB1bmRlZmluZWQgfHwgbGFuZ3VhZ2VzTWF0Y2gobGFuZywgdHJhY2subGFuZykpICYmIChsYW5nID09PSB1bmRlZmluZWQgfHwgdHJhY2suYXNzb2NMYW5nID09PSBhc3NvY0xhbmcpICYmIChpc0RlZmF1bHQgPT09IHVuZGVmaW5lZCB8fCB0cmFjay5kZWZhdWx0ID09PSBpc0RlZmF1bHQpICYmIChmb3JjZWQgPT09IHVuZGVmaW5lZCB8fCB0cmFjay5mb3JjZWQgPT09IGZvcmNlZCkgJiYgKCEoJ2NoYXJhY3RlcmlzdGljcycgaW4gb3B0aW9uKSB8fCBjaGFyYWN0ZXJpc3RpY3NNYXRjaChvcHRpb24uY2hhcmFjdGVyaXN0aWNzIHx8ICcnLCB0cmFjay5jaGFyYWN0ZXJpc3RpY3MpKSAmJiAobWF0Y2hQcmVkaWNhdGUgPT09IHVuZGVmaW5lZCB8fCBtYXRjaFByZWRpY2F0ZShvcHRpb24sIHRyYWNrKSk7XG59XG5mdW5jdGlvbiBsYW5ndWFnZXNNYXRjaChsYW5ndWFnZUEsIGxhbmd1YWdlQiA9ICctLScpIHtcbiAgaWYgKGxhbmd1YWdlQS5sZW5ndGggPT09IGxhbmd1YWdlQi5sZW5ndGgpIHtcbiAgICByZXR1cm4gbGFuZ3VhZ2VBID09PSBsYW5ndWFnZUI7XG4gIH1cbiAgcmV0dXJuIGxhbmd1YWdlQS5zdGFydHNXaXRoKGxhbmd1YWdlQikgfHwgbGFuZ3VhZ2VCLnN0YXJ0c1dpdGgobGFuZ3VhZ2VBKTtcbn1cbmZ1bmN0aW9uIGNoYXJhY3RlcmlzdGljc01hdGNoKGNoYXJhY3RlcmlzdGljc0EsIGNoYXJhY3RlcmlzdGljc0IgPSAnJykge1xuICBjb25zdCBhcnJBID0gY2hhcmFjdGVyaXN0aWNzQS5zcGxpdCgnLCcpO1xuICBjb25zdCBhcnJCID0gY2hhcmFjdGVyaXN0aWNzQi5zcGxpdCgnLCcpO1xuICAvLyBFeHBlY3RzIGVhY2ggaXRlbSB0byBiZSB1bmlxdWU6XG4gIHJldHVybiBhcnJBLmxlbmd0aCA9PT0gYXJyQi5sZW5ndGggJiYgIWFyckEuc29tZShlbCA9PiBhcnJCLmluZGV4T2YoZWwpID09PSAtMSk7XG59XG5mdW5jdGlvbiBhdWRpb01hdGNoUHJlZGljYXRlKG9wdGlvbiwgdHJhY2spIHtcbiAgY29uc3Qge1xuICAgIGF1ZGlvQ29kZWMsXG4gICAgY2hhbm5lbHNcbiAgfSA9IG9wdGlvbjtcbiAgcmV0dXJuIChhdWRpb0NvZGVjID09PSB1bmRlZmluZWQgfHwgKHRyYWNrLmF1ZGlvQ29kZWMgfHwgJycpLnN1YnN0cmluZygwLCA0KSA9PT0gYXVkaW9Db2RlYy5zdWJzdHJpbmcoMCwgNCkpICYmIChjaGFubmVscyA9PT0gdW5kZWZpbmVkIHx8IGNoYW5uZWxzID09PSAodHJhY2suY2hhbm5lbHMgfHwgJzInKSk7XG59XG5mdW5jdGlvbiBmaW5kQ2xvc2VzdExldmVsV2l0aEF1ZGlvR3JvdXAob3B0aW9uLCBsZXZlbHMsIGFsbEF1ZGlvVHJhY2tzLCBzZWFyY2hJbmRleCwgbWF0Y2hQcmVkaWNhdGUpIHtcbiAgY29uc3QgY3VycmVudExldmVsID0gbGV2ZWxzW3NlYXJjaEluZGV4XTtcbiAgLy8gQXJlIHRoZXJlIHZhcmlhbnRzIHdpdGggc2FtZSBVUkkgYXMgY3VycmVudCBsZXZlbD9cbiAgLy8gSWYgc28sIGZpbmQgYSBtYXRjaCB0aGF0IGRvZXMgbm90IHJlcXVpcmUgYW55IGxldmVsIFVSSSBjaGFuZ2VcbiAgY29uc3QgdmFyaWFudHMgPSBsZXZlbHMucmVkdWNlKCh2YXJpYW50TWFwLCBsZXZlbCwgaW5kZXgpID0+IHtcbiAgICBjb25zdCB1cmkgPSBsZXZlbC51cmk7XG4gICAgY29uc3QgcmVuZGl0aW9ucyA9IHZhcmlhbnRNYXBbdXJpXSB8fCAodmFyaWFudE1hcFt1cmldID0gW10pO1xuICAgIHJlbmRpdGlvbnMucHVzaChpbmRleCk7XG4gICAgcmV0dXJuIHZhcmlhbnRNYXA7XG4gIH0sIHt9KTtcbiAgY29uc3QgcmVuZGl0aW9ucyA9IHZhcmlhbnRzW2N1cnJlbnRMZXZlbC51cmldO1xuICBpZiAocmVuZGl0aW9ucy5sZW5ndGggPiAxKSB7XG4gICAgc2VhcmNoSW5kZXggPSBNYXRoLm1heC5hcHBseShNYXRoLCByZW5kaXRpb25zKTtcbiAgfVxuICAvLyBGaW5kIGJlc3QgbWF0Y2hcbiAgY29uc3QgY3VycmVudFZpZGVvUmFuZ2UgPSBjdXJyZW50TGV2ZWwudmlkZW9SYW5nZTtcbiAgY29uc3QgY3VycmVudEZyYW1lUmF0ZSA9IGN1cnJlbnRMZXZlbC5mcmFtZVJhdGU7XG4gIGNvbnN0IGN1cnJlbnRWaWRlb0NvZGVjID0gY3VycmVudExldmVsLmNvZGVjU2V0LnN1YnN0cmluZygwLCA0KTtcbiAgY29uc3QgbWF0Y2hpbmdWaWRlbyA9IHNlYXJjaERvd25BbmRVcExpc3QobGV2ZWxzLCBzZWFyY2hJbmRleCwgbGV2ZWwgPT4ge1xuICAgIGlmIChsZXZlbC52aWRlb1JhbmdlICE9PSBjdXJyZW50VmlkZW9SYW5nZSB8fCBsZXZlbC5mcmFtZVJhdGUgIT09IGN1cnJlbnRGcmFtZVJhdGUgfHwgbGV2ZWwuY29kZWNTZXQuc3Vic3RyaW5nKDAsIDQpICE9PSBjdXJyZW50VmlkZW9Db2RlYykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhdWRpb0dyb3VwcyA9IGxldmVsLmF1ZGlvR3JvdXBzO1xuICAgIGNvbnN0IHRyYWNrcyA9IGFsbEF1ZGlvVHJhY2tzLmZpbHRlcih0cmFjayA9PiAhYXVkaW9Hcm91cHMgfHwgYXVkaW9Hcm91cHMuaW5kZXhPZih0cmFjay5ncm91cElkKSAhPT0gLTEpO1xuICAgIHJldHVybiBmaW5kTWF0Y2hpbmdPcHRpb24ob3B0aW9uLCB0cmFja3MsIG1hdGNoUHJlZGljYXRlKSA+IC0xO1xuICB9KTtcbiAgaWYgKG1hdGNoaW5nVmlkZW8gPiAtMSkge1xuICAgIHJldHVybiBtYXRjaGluZ1ZpZGVvO1xuICB9XG4gIHJldHVybiBzZWFyY2hEb3duQW5kVXBMaXN0KGxldmVscywgc2VhcmNoSW5kZXgsIGxldmVsID0+IHtcbiAgICBjb25zdCBhdWRpb0dyb3VwcyA9IGxldmVsLmF1ZGlvR3JvdXBzO1xuICAgIGNvbnN0IHRyYWNrcyA9IGFsbEF1ZGlvVHJhY2tzLmZpbHRlcih0cmFjayA9PiAhYXVkaW9Hcm91cHMgfHwgYXVkaW9Hcm91cHMuaW5kZXhPZih0cmFjay5ncm91cElkKSAhPT0gLTEpO1xuICAgIHJldHVybiBmaW5kTWF0Y2hpbmdPcHRpb24ob3B0aW9uLCB0cmFja3MsIG1hdGNoUHJlZGljYXRlKSA+IC0xO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHNlYXJjaERvd25BbmRVcExpc3QoYXJyLCBzZWFyY2hJbmRleCwgcHJlZGljYXRlKSB7XG4gIGZvciAobGV0IGkgPSBzZWFyY2hJbmRleDsgaSA+IC0xOyBpLS0pIHtcbiAgICBpZiAocHJlZGljYXRlKGFycltpXSkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gc2VhcmNoSW5kZXggKyAxOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJbaV0pKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gdXNlQWx0ZXJuYXRlQXVkaW8oYXVkaW9UcmFja1VybCwgaGxzKSB7XG4gIHZhciBfaGxzJGxvYWRMZXZlbE9iajtcbiAgcmV0dXJuICEhYXVkaW9UcmFja1VybCAmJiBhdWRpb1RyYWNrVXJsICE9PSAoKF9obHMkbG9hZExldmVsT2JqID0gaGxzLmxvYWRMZXZlbE9iaikgPT0gbnVsbCA/IHZvaWQgMCA6IF9obHMkbG9hZExldmVsT2JqLnVyaSk7XG59XG5cbmNsYXNzIEFickNvbnRyb2xsZXIgZXh0ZW5kcyBMb2dnZXIge1xuICBjb25zdHJ1Y3RvcihfaGxzKSB7XG4gICAgc3VwZXIoJ2FicicsIF9obHMubG9nZ2VyKTtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmxhc3RMZXZlbExvYWRTZWMgPSAwO1xuICAgIHRoaXMubGFzdExvYWRlZEZyYWdMZXZlbCA9IC0xO1xuICAgIHRoaXMuZmlyc3RTZWxlY3Rpb24gPSAtMTtcbiAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gLTE7XG4gICAgdGhpcy5uZXh0QXV0b0xldmVsS2V5ID0gJyc7XG4gICAgdGhpcy5hdWRpb1RyYWNrc0J5R3JvdXAgPSBudWxsO1xuICAgIHRoaXMuY29kZWNUaWVycyA9IG51bGw7XG4gICAgdGhpcy50aW1lciA9IC0xO1xuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgIHRoaXMucGFydEN1cnJlbnQgPSBudWxsO1xuICAgIHRoaXMuYml0cmF0ZVRlc3REZWxheSA9IDA7XG4gICAgdGhpcy5yZWJ1ZmZlck5vdGljZSA9IC0xO1xuICAgIHRoaXMuc3VwcG9ydGVkQ2FjaGUgPSB7fTtcbiAgICB0aGlzLmJ3RXN0aW1hdG9yID0gdm9pZCAwO1xuICAgIC8qXG4gICAgICAgIFRoaXMgbWV0aG9kIG1vbml0b3JzIHRoZSBkb3dubG9hZCByYXRlIG9mIHRoZSBjdXJyZW50IGZyYWdtZW50LCBhbmQgd2lsbCBkb3duc3dpdGNoIGlmIHRoYXQgZnJhZ21lbnQgd2lsbCBub3QgbG9hZFxuICAgICAgICBxdWlja2x5IGVub3VnaCB0byBwcmV2ZW50IHVuZGVyYnVmZmVyaW5nXG4gICAgICAqL1xuICAgIHRoaXMuX2FiYW5kb25SdWxlc0NoZWNrID0gbGV2ZWxMb2FkZWQgPT4ge1xuICAgICAgdmFyIF9yZWY7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZyYWdDdXJyZW50OiBmcmFnLFxuICAgICAgICBwYXJ0Q3VycmVudDogcGFydCxcbiAgICAgICAgaGxzXG4gICAgICB9ID0gdGhpcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYXV0b0xldmVsRW5hYmxlZCxcbiAgICAgICAgbWVkaWFcbiAgICAgIH0gPSBobHM7XG4gICAgICBpZiAoIWZyYWcgfHwgIW1lZGlhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3Qgc3RhdHMgPSBwYXJ0ID8gcGFydC5zdGF0cyA6IGZyYWcuc3RhdHM7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IHBhcnQgPyBwYXJ0LmR1cmF0aW9uIDogZnJhZy5kdXJhdGlvbjtcbiAgICAgIGNvbnN0IHRpbWVMb2FkaW5nID0gbm93IC0gc3RhdHMubG9hZGluZy5zdGFydDtcbiAgICAgIGNvbnN0IG1pbkF1dG9MZXZlbCA9IGhscy5taW5BdXRvTGV2ZWw7XG4gICAgICBjb25zdCBsb2FkaW5nRnJhZ0ZvckxldmVsID0gZnJhZy5sZXZlbDtcbiAgICAgIGNvbnN0IGN1cnJlbnRBdXRvTGV2ZWwgPSB0aGlzLl9uZXh0QXV0b0xldmVsO1xuICAgICAgLy8gSWYgZnJhZyBsb2FkaW5nIGlzIGFib3J0ZWQsIGNvbXBsZXRlLCBvciBmcm9tIGxvd2VzdCBsZXZlbCwgc3RvcCB0aW1lciBhbmQgcmV0dXJuXG4gICAgICBpZiAoc3RhdHMuYWJvcnRlZCB8fCBzdGF0cy5sb2FkZWQgJiYgc3RhdHMubG9hZGVkID09PSBzdGF0cy50b3RhbCB8fCBsb2FkaW5nRnJhZ0ZvckxldmVsIDw9IG1pbkF1dG9MZXZlbCkge1xuICAgICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgICAgLy8gcmVzZXQgZm9yY2VkIGF1dG8gbGV2ZWwgdmFsdWUgc28gdGhhdCBuZXh0IGxldmVsIHdpbGwgYmUgc2VsZWN0ZWRcbiAgICAgICAgdGhpcy5fbmV4dEF1dG9MZXZlbCA9IC0xO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFRoaXMgY2hlY2sgb25seSBydW5zIGlmIHdlJ3JlIGluIEFCUiBtb2RlXG4gICAgICBpZiAoIWF1dG9MZXZlbEVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBNdXN0IGJlIGxvYWRpbmcvbG9hZGVkIGEgbmV3IGxldmVsIG9yIGJlIGluIGEgcGxheWluZyBzdGF0ZVxuICAgICAgY29uc3QgZnJhZ0Jsb2NraW5nU3dpdGNoID0gY3VycmVudEF1dG9MZXZlbCA+IC0xICYmIGN1cnJlbnRBdXRvTGV2ZWwgIT09IGxvYWRpbmdGcmFnRm9yTGV2ZWw7XG4gICAgICBjb25zdCBsZXZlbENoYW5nZSA9ICEhbGV2ZWxMb2FkZWQgfHwgZnJhZ0Jsb2NraW5nU3dpdGNoO1xuICAgICAgaWYgKCFsZXZlbENoYW5nZSAmJiAobWVkaWEucGF1c2VkIHx8ICFtZWRpYS5wbGF5YmFja1JhdGUgfHwgIW1lZGlhLnJlYWR5U3RhdGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBobHMubWFpbkZvcndhcmRCdWZmZXJJbmZvO1xuICAgICAgaWYgKCFsZXZlbENoYW5nZSAmJiBidWZmZXJJbmZvID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHR0ZmJFc3RpbWF0ZSA9IHRoaXMuYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGVUVEZCKCk7XG4gICAgICBjb25zdCBwbGF5YmFja1JhdGUgPSBNYXRoLmFicyhtZWRpYS5wbGF5YmFja1JhdGUpO1xuICAgICAgLy8gVG8gbWFpbnRhaW4gc3RhYmxlIGFkYXB0aXZlIHBsYXliYWNrLCBvbmx5IGJlZ2luIG1vbml0b3JpbmcgZnJhZyBsb2FkaW5nIGFmdGVyIGhhbGYgb3IgbW9yZSBvZiBpdHMgcGxheWJhY2sgZHVyYXRpb24gaGFzIHBhc3NlZFxuICAgICAgaWYgKHRpbWVMb2FkaW5nIDw9IE1hdGgubWF4KHR0ZmJFc3RpbWF0ZSwgMTAwMCAqIChkdXJhdGlvbiAvIChwbGF5YmFja1JhdGUgKiAyKSkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gYnVmZmVyU3RhcnZhdGlvbkRlbGF5IGlzIGFuIGVzdGltYXRlIG9mIHRoZSBhbW91bnQgdGltZSAoaW4gc2Vjb25kcykgaXQgd2lsbCB0YWtlIHRvIGV4aGF1c3QgdGhlIGJ1ZmZlclxuICAgICAgY29uc3QgYnVmZmVyU3RhcnZhdGlvbkRlbGF5ID0gYnVmZmVySW5mbyA/IGJ1ZmZlckluZm8ubGVuIC8gcGxheWJhY2tSYXRlIDogMDtcbiAgICAgIGNvbnN0IHR0ZmIgPSBzdGF0cy5sb2FkaW5nLmZpcnN0ID8gc3RhdHMubG9hZGluZy5maXJzdCAtIHN0YXRzLmxvYWRpbmcuc3RhcnQgOiAtMTtcbiAgICAgIGNvbnN0IGxvYWRlZEZpcnN0Qnl0ZSA9IHN0YXRzLmxvYWRlZCAmJiB0dGZiID4gLTE7XG4gICAgICBjb25zdCBid0VzdGltYXRlID0gdGhpcy5nZXRCd0VzdGltYXRlKCk7XG4gICAgICBjb25zdCBsZXZlbHMgPSBobHMubGV2ZWxzO1xuICAgICAgY29uc3QgbGV2ZWwgPSBsZXZlbHNbbG9hZGluZ0ZyYWdGb3JMZXZlbF07XG4gICAgICBjb25zdCBleHBlY3RlZExlbiA9IE1hdGgubWF4KHN0YXRzLmxvYWRlZCwgTWF0aC5yb3VuZChkdXJhdGlvbiAqIChmcmFnLmJpdHJhdGUgfHwgbGV2ZWwuYXZlcmFnZUJpdHJhdGUpIC8gOCkpO1xuICAgICAgbGV0IHRpbWVTdHJlYW1pbmcgPSBsb2FkZWRGaXJzdEJ5dGUgPyB0aW1lTG9hZGluZyAtIHR0ZmIgOiB0aW1lTG9hZGluZztcbiAgICAgIGlmICh0aW1lU3RyZWFtaW5nIDwgMSAmJiBsb2FkZWRGaXJzdEJ5dGUpIHtcbiAgICAgICAgdGltZVN0cmVhbWluZyA9IE1hdGgubWluKHRpbWVMb2FkaW5nLCBzdGF0cy5sb2FkZWQgKiA4IC8gYndFc3RpbWF0ZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBsb2FkUmF0ZSA9IGxvYWRlZEZpcnN0Qnl0ZSA/IHN0YXRzLmxvYWRlZCAqIDEwMDAgLyB0aW1lU3RyZWFtaW5nIDogMDtcbiAgICAgIC8vIGZyYWdMb2FkRGVsYXkgaXMgYW4gZXN0aW1hdGUgb2YgdGhlIHRpbWUgKGluIHNlY29uZHMpIGl0IHdpbGwgdGFrZSB0byBidWZmZXIgdGhlIHJlbWFpbmRlciBvZiB0aGUgZnJhZ21lbnRcbiAgICAgIGNvbnN0IHR0ZmJTZWNvbmRzID0gdHRmYkVzdGltYXRlIC8gMTAwMDtcbiAgICAgIGNvbnN0IGZyYWdMb2FkZWREZWxheSA9IGxvYWRSYXRlID8gKGV4cGVjdGVkTGVuIC0gc3RhdHMubG9hZGVkKSAvIGxvYWRSYXRlIDogZXhwZWN0ZWRMZW4gKiA4IC8gYndFc3RpbWF0ZSArIHR0ZmJTZWNvbmRzO1xuICAgICAgLy8gT25seSBkb3duc3dpdGNoIGlmIHRoZSB0aW1lIHRvIGZpbmlzaCBsb2FkaW5nIHRoZSBjdXJyZW50IGZyYWdtZW50IGlzIGdyZWF0ZXIgdGhhbiB0aGUgYW1vdW50IG9mIGJ1ZmZlciBsZWZ0XG4gICAgICBpZiAoZnJhZ0xvYWRlZERlbGF5IDw9IGJ1ZmZlclN0YXJ2YXRpb25EZWxheSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBid2UgPSBsb2FkUmF0ZSA/IGxvYWRSYXRlICogOCA6IGJ3RXN0aW1hdGU7XG4gICAgICBjb25zdCBsaXZlID0gKChfcmVmID0gKGxldmVsTG9hZGVkID09IG51bGwgPyB2b2lkIDAgOiBsZXZlbExvYWRlZC5kZXRhaWxzKSB8fCB0aGlzLmhscy5sYXRlc3RMZXZlbERldGFpbHMpID09IG51bGwgPyB2b2lkIDAgOiBfcmVmLmxpdmUpID09PSB0cnVlO1xuICAgICAgY29uc3QgYWJyQmFuZFdpZHRoVXBGYWN0b3IgPSB0aGlzLmhscy5jb25maWcuYWJyQmFuZFdpZHRoVXBGYWN0b3I7XG4gICAgICBsZXQgZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgbGV0IG5leHRMb2FkTGV2ZWw7XG4gICAgICAvLyBJdGVyYXRlIHRocm91Z2ggbG93ZXIgbGV2ZWwgYW5kIHRyeSB0byBmaW5kIHRoZSBsYXJnZXN0IG9uZSB0aGF0IGF2b2lkcyByZWJ1ZmZlcmluZ1xuICAgICAgZm9yIChuZXh0TG9hZExldmVsID0gbG9hZGluZ0ZyYWdGb3JMZXZlbCAtIDE7IG5leHRMb2FkTGV2ZWwgPiBtaW5BdXRvTGV2ZWw7IG5leHRMb2FkTGV2ZWwtLSkge1xuICAgICAgICAvLyBjb21wdXRlIHRpbWUgdG8gbG9hZCBuZXh0IGZyYWdtZW50IGF0IGxvd2VyIGxldmVsXG4gICAgICAgIC8vIDggPSBiaXRzIHBlciBieXRlIChicHMvQnBzKVxuICAgICAgICBjb25zdCBsZXZlbE5leHRCaXRyYXRlID0gbGV2ZWxzW25leHRMb2FkTGV2ZWxdLm1heEJpdHJhdGU7XG4gICAgICAgIGNvbnN0IHJlcXVpcmVzTGV2ZWxMb2FkID0gIWxldmVsc1tuZXh0TG9hZExldmVsXS5kZXRhaWxzIHx8IGxpdmU7XG4gICAgICAgIGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA9IHRoaXMuZ2V0VGltZVRvTG9hZEZyYWcodHRmYlNlY29uZHMsIGJ3ZSwgZHVyYXRpb24gKiBsZXZlbE5leHRCaXRyYXRlLCByZXF1aXJlc0xldmVsTG9hZCk7XG4gICAgICAgIGlmIChmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkgPCBNYXRoLm1pbihidWZmZXJTdGFydmF0aW9uRGVsYXksIGR1cmF0aW9uICsgdHRmYlNlY29uZHMpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIE9ubHkgZW1lcmdlbmN5IHN3aXRjaCBkb3duIGlmIGl0IHRha2VzIGxlc3MgdGltZSB0byBsb2FkIGEgbmV3IGZyYWdtZW50IGF0IGxvd2VzdCBsZXZlbCBpbnN0ZWFkIG9mIGNvbnRpbnVpbmdcbiAgICAgIC8vIHRvIGxvYWQgdGhlIGN1cnJlbnQgb25lXG4gICAgICBpZiAoZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5ID49IGZyYWdMb2FkZWREZWxheSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIGVzdGltYXRlZCBsb2FkIHRpbWUgb2YgbmV3IHNlZ21lbnQgaXMgY29tcGxldGVseSB1bnJlYXNvbmFibGUsIGlnbm9yZSBhbmQgZG8gbm90IGVtZXJnZW5jeSBzd2l0Y2ggZG93blxuICAgICAgaWYgKGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA+IGR1cmF0aW9uICogMTApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGxvYWRlZEZpcnN0Qnl0ZSkge1xuICAgICAgICAvLyBJZiB0aGVyZSBoYXMgYmVlbiBsb2FkaW5nIHByb2dyZXNzLCBzYW1wbGUgYmFuZHdpZHRoIHVzaW5nIGxvYWRpbmcgdGltZSBvZmZzZXQgYnkgbWluaW11bSBUVEZCIHRpbWVcbiAgICAgICAgdGhpcy5id0VzdGltYXRvci5zYW1wbGUodGltZUxvYWRpbmcgLSBNYXRoLm1pbih0dGZiRXN0aW1hdGUsIHR0ZmIpLCBzdGF0cy5sb2FkZWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgaGFzIGJlZW4gbm8gbG9hZGluZyBwcm9ncmVzcywgc2FtcGxlIFRURkJcbiAgICAgICAgdGhpcy5id0VzdGltYXRvci5zYW1wbGVUVEZCKHRpbWVMb2FkaW5nKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5leHRMb2FkTGV2ZWxCaXRyYXRlID0gbGV2ZWxzW25leHRMb2FkTGV2ZWxdLm1heEJpdHJhdGU7XG4gICAgICBpZiAodGhpcy5nZXRCd0VzdGltYXRlKCkgKiBhYnJCYW5kV2lkdGhVcEZhY3RvciA+IG5leHRMb2FkTGV2ZWxCaXRyYXRlKSB7XG4gICAgICAgIHRoaXMucmVzZXRFc3RpbWF0b3IobmV4dExvYWRMZXZlbEJpdHJhdGUpO1xuICAgICAgfVxuICAgICAgY29uc3QgYmVzdFN3aXRjaExldmVsID0gdGhpcy5maW5kQmVzdExldmVsKG5leHRMb2FkTGV2ZWxCaXRyYXRlLCBtaW5BdXRvTGV2ZWwsIG5leHRMb2FkTGV2ZWwsIDAsIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSwgMSwgMSk7XG4gICAgICBpZiAoYmVzdFN3aXRjaExldmVsID4gLTEpIHtcbiAgICAgICAgbmV4dExvYWRMZXZlbCA9IGJlc3RTd2l0Y2hMZXZlbDtcbiAgICAgIH1cbiAgICAgIHRoaXMud2FybihgRnJhZ21lbnQgJHtmcmFnLnNufSR7cGFydCA/ICcgcGFydCAnICsgcGFydC5pbmRleCA6ICcnfSBvZiBsZXZlbCAke2xvYWRpbmdGcmFnRm9yTGV2ZWx9IGlzIGxvYWRpbmcgdG9vIHNsb3dseTtcbiAgICAgIEZyYWdtZW50IGR1cmF0aW9uOiAke2ZyYWcuZHVyYXRpb24udG9GaXhlZCgzKX1cbiAgICAgIFRpbWUgdG8gdW5kZXJidWZmZXI6ICR7YnVmZmVyU3RhcnZhdGlvbkRlbGF5LnRvRml4ZWQoMyl9IHNcbiAgICAgIEVzdGltYXRlZCBsb2FkIHRpbWUgZm9yIGN1cnJlbnQgZnJhZ21lbnQ6ICR7ZnJhZ0xvYWRlZERlbGF5LnRvRml4ZWQoMyl9IHNcbiAgICAgIEVzdGltYXRlZCBsb2FkIHRpbWUgZm9yIGRvd24gc3dpdGNoIGZyYWdtZW50OiAke2ZyYWdMZXZlbE5leHRMb2FkZWREZWxheS50b0ZpeGVkKDMpfSBzXG4gICAgICBUVEZCIGVzdGltYXRlOiAke3R0ZmIgfCAwfSBtc1xuICAgICAgQ3VycmVudCBCVyBlc3RpbWF0ZTogJHtpc0Zpbml0ZU51bWJlcihid0VzdGltYXRlKSA/IGJ3RXN0aW1hdGUgfCAwIDogJ1Vua25vd24nfSBicHNcbiAgICAgIE5ldyBCVyBlc3RpbWF0ZTogJHt0aGlzLmdldEJ3RXN0aW1hdGUoKSB8IDB9IGJwc1xuICAgICAgU3dpdGNoaW5nIHRvIGxldmVsICR7bmV4dExvYWRMZXZlbH0gQCAke25leHRMb2FkTGV2ZWxCaXRyYXRlIHwgMH0gYnBzYCk7XG4gICAgICBobHMubmV4dExvYWRMZXZlbCA9IGhscy5uZXh0QXV0b0xldmVsID0gbmV4dExvYWRMZXZlbDtcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgY29uc3QgYWJvcnRBbmRTd2l0Y2ggPSAoKSA9PiB7XG4gICAgICAgIC8vIEFyZSBuZXh0TG9hZExldmVsIGRldGFpbHMgYXZhaWxhYmxlIG9yIGlzIHN0cmVhbS1jb250cm9sbGVyIHN0aWxsIGluIFwiV0FJVElOR19MRVZFTFwiIHN0YXRlP1xuICAgICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgICAgaWYgKHRoaXMuZnJhZ0N1cnJlbnQgPT09IGZyYWcgJiYgdGhpcy5obHMubG9hZExldmVsID09PSBuZXh0TG9hZExldmVsICYmIG5leHRMb2FkTGV2ZWwgPiAwKSB7XG4gICAgICAgICAgY29uc3QgYnVmZmVyU3RhcnZhdGlvbkRlbGF5ID0gdGhpcy5nZXRTdGFydmF0aW9uRGVsYXkoKTtcbiAgICAgICAgICB0aGlzLndhcm4oYEFib3J0aW5nIGluZmxpZ2h0IHJlcXVlc3QgJHtuZXh0TG9hZExldmVsID4gMCA/ICdhbmQgc3dpdGNoaW5nIGRvd24nIDogJyd9XG4gICAgICBGcmFnbWVudCBkdXJhdGlvbjogJHtmcmFnLmR1cmF0aW9uLnRvRml4ZWQoMyl9IHNcbiAgICAgIFRpbWUgdG8gdW5kZXJidWZmZXI6ICR7YnVmZmVyU3RhcnZhdGlvbkRlbGF5LnRvRml4ZWQoMyl9IHNgKTtcbiAgICAgICAgICBmcmFnLmFib3J0UmVxdWVzdHMoKTtcbiAgICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gdGhpcy5wYXJ0Q3VycmVudCA9IG51bGw7XG4gICAgICAgICAgaWYgKG5leHRMb2FkTGV2ZWwgPiBtaW5BdXRvTGV2ZWwpIHtcbiAgICAgICAgICAgIGxldCBsb3dlc3RTd2l0Y2hMZXZlbCA9IHRoaXMuZmluZEJlc3RMZXZlbCh0aGlzLmhscy5sZXZlbHNbbWluQXV0b0xldmVsXS5iaXRyYXRlLCBtaW5BdXRvTGV2ZWwsIG5leHRMb2FkTGV2ZWwsIDAsIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSwgMSwgMSk7XG4gICAgICAgICAgICBpZiAobG93ZXN0U3dpdGNoTGV2ZWwgPT09IC0xKSB7XG4gICAgICAgICAgICAgIGxvd2VzdFN3aXRjaExldmVsID0gbWluQXV0b0xldmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5obHMubmV4dExvYWRMZXZlbCA9IHRoaXMuaGxzLm5leHRBdXRvTGV2ZWwgPSBsb3dlc3RTd2l0Y2hMZXZlbDtcbiAgICAgICAgICAgIHRoaXMucmVzZXRFc3RpbWF0b3IodGhpcy5obHMubGV2ZWxzW2xvd2VzdFN3aXRjaExldmVsXS5iaXRyYXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoZnJhZ0Jsb2NraW5nU3dpdGNoIHx8IGZyYWdMb2FkZWREZWxheSA+IGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSAqIDIpIHtcbiAgICAgICAgYWJvcnRBbmRTd2l0Y2goKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudGltZXIgPSBzZWxmLnNldEludGVydmFsKGFib3J0QW5kU3dpdGNoLCBmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkgKiAxMDAwKTtcbiAgICAgIH1cbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQsIHtcbiAgICAgICAgZnJhZyxcbiAgICAgICAgcGFydCxcbiAgICAgICAgc3RhdHNcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5obHMgPSBfaGxzO1xuICAgIHRoaXMuYndFc3RpbWF0b3IgPSB0aGlzLmluaXRFc3RpbWF0b3IoKTtcbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgcmVzZXRFc3RpbWF0b3IoYWJyRXdtYURlZmF1bHRFc3RpbWF0ZSkge1xuICAgIGlmIChhYnJFd21hRGVmYXVsdEVzdGltYXRlKSB7XG4gICAgICB0aGlzLmxvZyhgc2V0dGluZyBpbml0aWFsIGJ3ZSB0byAke2FickV3bWFEZWZhdWx0RXN0aW1hdGV9YCk7XG4gICAgICB0aGlzLmhscy5jb25maWcuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZSA9IGFickV3bWFEZWZhdWx0RXN0aW1hdGU7XG4gICAgfVxuICAgIHRoaXMuZmlyc3RTZWxlY3Rpb24gPSAtMTtcbiAgICB0aGlzLmJ3RXN0aW1hdG9yID0gdGhpcy5pbml0RXN0aW1hdG9yKCk7XG4gIH1cbiAgaW5pdEVzdGltYXRvcigpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG4gICAgcmV0dXJuIG5ldyBFd21hQmFuZFdpZHRoRXN0aW1hdG9yKGNvbmZpZy5hYnJFd21hU2xvd1ZvRCwgY29uZmlnLmFickV3bWFGYXN0Vm9ELCBjb25maWcuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZSk7XG4gIH1cbiAgcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfTE9BRElORywgdGhpcy5vbkZyYWdMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfTE9BREVELCB0aGlzLm9uRnJhZ0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX1NXSVRDSElORywgdGhpcy5vbkxldmVsU3dpdGNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMU19VUERBVEVELCB0aGlzLm9uTGV2ZWxzVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQVhfQVVUT19MRVZFTF9VUERBVEVELCB0aGlzLm9uTWF4QXV0b0xldmVsVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfVxuICB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmICghaGxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfTE9BRElORywgdGhpcy5vbkZyYWdMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0xPQURFRCwgdGhpcy5vbkZyYWdMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX1NXSVRDSElORywgdGhpcy5vbkxldmVsU3dpdGNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxTX1VQREFURUQsIHRoaXMub25MZXZlbHNVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NQVhfQVVUT19MRVZFTF9VUERBVEVELCB0aGlzLm9uTWF4QXV0b0xldmVsVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSB0aGlzLl9hYmFuZG9uUnVsZXNDaGVjayA9IHRoaXMuc3VwcG9ydGVkQ2FjaGUgPSBudWxsO1xuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSB0aGlzLnBhcnRDdXJyZW50ID0gbnVsbDtcbiAgfVxuICBvbk1hbmlmZXN0TG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgIHRoaXMubGFzdExvYWRlZEZyYWdMZXZlbCA9IC0xO1xuICAgIHRoaXMuZmlyc3RTZWxlY3Rpb24gPSAtMTtcbiAgICB0aGlzLmxhc3RMZXZlbExvYWRTZWMgPSAwO1xuICAgIHRoaXMuc3VwcG9ydGVkQ2FjaGUgPSB7fTtcbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gdGhpcy5wYXJ0Q3VycmVudCA9IG51bGw7XG4gICAgdGhpcy5vbkxldmVsc1VwZGF0ZWQoKTtcbiAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgfVxuICBvbkxldmVsc1VwZGF0ZWQoKSB7XG4gICAgaWYgKHRoaXMubGFzdExvYWRlZEZyYWdMZXZlbCA+IC0xICYmIHRoaXMuZnJhZ0N1cnJlbnQpIHtcbiAgICAgIHRoaXMubGFzdExvYWRlZEZyYWdMZXZlbCA9IHRoaXMuZnJhZ0N1cnJlbnQubGV2ZWw7XG4gICAgfVxuICAgIHRoaXMuX25leHRBdXRvTGV2ZWwgPSAtMTtcbiAgICB0aGlzLm9uTWF4QXV0b0xldmVsVXBkYXRlZCgpO1xuICAgIHRoaXMuY29kZWNUaWVycyA9IG51bGw7XG4gICAgdGhpcy5hdWRpb1RyYWNrc0J5R3JvdXAgPSBudWxsO1xuICB9XG4gIG9uTWF4QXV0b0xldmVsVXBkYXRlZCgpIHtcbiAgICB0aGlzLmZpcnN0U2VsZWN0aW9uID0gLTE7XG4gICAgdGhpcy5uZXh0QXV0b0xldmVsS2V5ID0gJyc7XG4gIH1cbiAgb25GcmFnTG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgaWYgKHRoaXMuaWdub3JlRnJhZ21lbnQoZnJhZykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFmcmFnLmJpdHJhdGVUZXN0KSB7XG4gICAgICB2YXIgX2RhdGEkcGFydDtcbiAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBmcmFnO1xuICAgICAgdGhpcy5wYXJ0Q3VycmVudCA9IChfZGF0YSRwYXJ0ID0gZGF0YS5wYXJ0KSAhPSBudWxsID8gX2RhdGEkcGFydCA6IG51bGw7XG4gICAgfVxuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgIHRoaXMudGltZXIgPSBzZWxmLnNldEludGVydmFsKHRoaXMuX2FiYW5kb25SdWxlc0NoZWNrLCAxMDApO1xuICB9XG4gIG9uTGV2ZWxTd2l0Y2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgfVxuICBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKGRhdGEuZmF0YWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3dpdGNoIChkYXRhLmRldGFpbHMpIHtcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9BRERfQ09ERUNfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5EX0VSUk9SOlxuICAgICAgICAvLyBSZXNldCBsYXN0IGxvYWRlZCBsZXZlbCBzbyB0aGF0IGEgbmV3IHNlbGVjdGlvbiBjYW4gYmUgbWFkZSBhZnRlciBjYWxsaW5nIHJlY292ZXJNZWRpYUVycm9yXG4gICAgICAgIHRoaXMubGFzdExvYWRlZEZyYWdMZXZlbCA9IC0xO1xuICAgICAgICB0aGlzLmZpcnN0U2VsZWN0aW9uID0gLTE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBmcmFnID0gZGF0YS5mcmFnO1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGZyYWdDdXJyZW50LFxuICAgICAgICAgICAgcGFydEN1cnJlbnQ6IHBhcnRcbiAgICAgICAgICB9ID0gdGhpcztcbiAgICAgICAgICBpZiAoZnJhZyAmJiBmcmFnQ3VycmVudCAmJiBmcmFnLnNuID09PSBmcmFnQ3VycmVudC5zbiAmJiBmcmFnLmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCkge1xuICAgICAgICAgICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICBjb25zdCBzdGF0cyA9IHBhcnQgPyBwYXJ0LnN0YXRzIDogZnJhZy5zdGF0cztcbiAgICAgICAgICAgIGNvbnN0IHRpbWVMb2FkaW5nID0gbm93IC0gc3RhdHMubG9hZGluZy5zdGFydDtcbiAgICAgICAgICAgIGNvbnN0IHR0ZmIgPSBzdGF0cy5sb2FkaW5nLmZpcnN0ID8gc3RhdHMubG9hZGluZy5maXJzdCAtIHN0YXRzLmxvYWRpbmcuc3RhcnQgOiAtMTtcbiAgICAgICAgICAgIGNvbnN0IGxvYWRlZEZpcnN0Qnl0ZSA9IHN0YXRzLmxvYWRlZCAmJiB0dGZiID4gLTE7XG4gICAgICAgICAgICBpZiAobG9hZGVkRmlyc3RCeXRlKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHR0ZmJFc3RpbWF0ZSA9IHRoaXMuYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGVUVEZCKCk7XG4gICAgICAgICAgICAgIHRoaXMuYndFc3RpbWF0b3Iuc2FtcGxlKHRpbWVMb2FkaW5nIC0gTWF0aC5taW4odHRmYkVzdGltYXRlLCB0dGZiKSwgc3RhdHMubG9hZGVkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuYndFc3RpbWF0b3Iuc2FtcGxlVFRGQih0aW1lTG9hZGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICB9XG4gIGdldFRpbWVUb0xvYWRGcmFnKHRpbWVUb0ZpcnN0Qnl0ZVNlYywgYmFuZHdpZHRoLCBmcmFnU2l6ZUJpdHMsIGlzU3dpdGNoKSB7XG4gICAgY29uc3QgZnJhZ0xvYWRTZWMgPSB0aW1lVG9GaXJzdEJ5dGVTZWMgKyBmcmFnU2l6ZUJpdHMgLyBiYW5kd2lkdGg7XG4gICAgY29uc3QgcGxheWxpc3RMb2FkU2VjID0gaXNTd2l0Y2ggPyB0aW1lVG9GaXJzdEJ5dGVTZWMgKyB0aGlzLmxhc3RMZXZlbExvYWRTZWMgOiAwO1xuICAgIHJldHVybiBmcmFnTG9hZFNlYyArIHBsYXlsaXN0TG9hZFNlYztcbiAgfVxuICBvbkxldmVsTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuICAgIGNvbnN0IHtcbiAgICAgIGxvYWRpbmdcbiAgICB9ID0gZGF0YS5zdGF0cztcbiAgICBjb25zdCB0aW1lTG9hZGluZ01zID0gbG9hZGluZy5lbmQgLSBsb2FkaW5nLmZpcnN0O1xuICAgIGlmIChpc0Zpbml0ZU51bWJlcih0aW1lTG9hZGluZ01zKSkge1xuICAgICAgdGhpcy5sYXN0TGV2ZWxMb2FkU2VjID0gdGltZUxvYWRpbmdNcyAvIDEwMDA7XG4gICAgfVxuICAgIGlmIChkYXRhLmRldGFpbHMubGl2ZSkge1xuICAgICAgdGhpcy5id0VzdGltYXRvci51cGRhdGUoY29uZmlnLmFickV3bWFTbG93TGl2ZSwgY29uZmlnLmFickV3bWFGYXN0TGl2ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYndFc3RpbWF0b3IudXBkYXRlKGNvbmZpZy5hYnJFd21hU2xvd1ZvRCwgY29uZmlnLmFickV3bWFGYXN0Vm9EKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGltZXIgPiAtMSkge1xuICAgICAgdGhpcy5fYWJhbmRvblJ1bGVzQ2hlY2soZGF0YS5sZXZlbEluZm8pO1xuICAgIH1cbiAgfVxuICBvbkZyYWdMb2FkZWQoZXZlbnQsIHtcbiAgICBmcmFnLFxuICAgIHBhcnRcbiAgfSkge1xuICAgIGNvbnN0IHN0YXRzID0gcGFydCA/IHBhcnQuc3RhdHMgOiBmcmFnLnN0YXRzO1xuICAgIGlmIChmcmFnLnR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pIHtcbiAgICAgIHRoaXMuYndFc3RpbWF0b3Iuc2FtcGxlVFRGQihzdGF0cy5sb2FkaW5nLmZpcnN0IC0gc3RhdHMubG9hZGluZy5zdGFydCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlnbm9yZUZyYWdtZW50KGZyYWcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHN0b3AgbW9uaXRvcmluZyBidyBvbmNlIGZyYWcgbG9hZGVkXG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgLy8gcmVzZXQgZm9yY2VkIGF1dG8gbGV2ZWwgdmFsdWUgc28gdGhhdCBuZXh0IGxldmVsIHdpbGwgYmUgc2VsZWN0ZWRcbiAgICBpZiAoZnJhZy5sZXZlbCA9PT0gdGhpcy5fbmV4dEF1dG9MZXZlbCkge1xuICAgICAgdGhpcy5fbmV4dEF1dG9MZXZlbCA9IC0xO1xuICAgIH1cbiAgICB0aGlzLmZpcnN0U2VsZWN0aW9uID0gLTE7XG5cbiAgICAvLyBjb21wdXRlIGxldmVsIGF2ZXJhZ2UgYml0cmF0ZVxuICAgIGlmICh0aGlzLmhscy5jb25maWcuYWJyTWF4V2l0aFJlYWxCaXRyYXRlKSB7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IHBhcnQgPyBwYXJ0LmR1cmF0aW9uIDogZnJhZy5kdXJhdGlvbjtcbiAgICAgIGNvbnN0IGxldmVsID0gdGhpcy5obHMubGV2ZWxzW2ZyYWcubGV2ZWxdO1xuICAgICAgY29uc3QgbG9hZGVkQnl0ZXMgPSAobGV2ZWwubG9hZGVkID8gbGV2ZWwubG9hZGVkLmJ5dGVzIDogMCkgKyBzdGF0cy5sb2FkZWQ7XG4gICAgICBjb25zdCBsb2FkZWREdXJhdGlvbiA9IChsZXZlbC5sb2FkZWQgPyBsZXZlbC5sb2FkZWQuZHVyYXRpb24gOiAwKSArIGR1cmF0aW9uO1xuICAgICAgbGV2ZWwubG9hZGVkID0ge1xuICAgICAgICBieXRlczogbG9hZGVkQnl0ZXMsXG4gICAgICAgIGR1cmF0aW9uOiBsb2FkZWREdXJhdGlvblxuICAgICAgfTtcbiAgICAgIGxldmVsLnJlYWxCaXRyYXRlID0gTWF0aC5yb3VuZCg4ICogbG9hZGVkQnl0ZXMgLyBsb2FkZWREdXJhdGlvbik7XG4gICAgfVxuICAgIGlmIChmcmFnLmJpdHJhdGVUZXN0KSB7XG4gICAgICBjb25zdCBmcmFnQnVmZmVyZWREYXRhID0ge1xuICAgICAgICBzdGF0cyxcbiAgICAgICAgZnJhZyxcbiAgICAgICAgcGFydCxcbiAgICAgICAgaWQ6IGZyYWcudHlwZVxuICAgICAgfTtcbiAgICAgIHRoaXMub25GcmFnQnVmZmVyZWQoRXZlbnRzLkZSQUdfQlVGRkVSRUQsIGZyYWdCdWZmZXJlZERhdGEpO1xuICAgICAgZnJhZy5iaXRyYXRlVGVzdCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzdG9yZSBsZXZlbCBpZCBhZnRlciBzdWNjZXNzZnVsIGZyYWdtZW50IGxvYWQgZm9yIHBsYXliYWNrXG4gICAgICB0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwgPSBmcmFnLmxldmVsO1xuICAgIH1cbiAgfVxuICBvbkZyYWdCdWZmZXJlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWcsXG4gICAgICBwYXJ0XG4gICAgfSA9IGRhdGE7XG4gICAgY29uc3Qgc3RhdHMgPSBwYXJ0ICE9IG51bGwgJiYgcGFydC5zdGF0cy5sb2FkZWQgPyBwYXJ0LnN0YXRzIDogZnJhZy5zdGF0cztcbiAgICBpZiAoc3RhdHMuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5pZ25vcmVGcmFnbWVudChmcmFnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBVc2UgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBwYXJzaW5nIGFuZCByZXF1ZXN0IGluc3RlYWQgb2YgYnVmZmVyaW5nIGFuZCByZXF1ZXN0IHRvIGNvbXB1dGUgZnJhZ0xvYWRpbmdQcm9jZXNzaW5nO1xuICAgIC8vIHJhdGlvbmFsZSBpcyB0aGF0IGJ1ZmZlciBhcHBlbmRpbmcgb25seSBoYXBwZW5zIG9uY2UgbWVkaWEgaXMgYXR0YWNoZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGNvbmZpZy5zdGFydEZyYWdQcmVmZXRjaFxuICAgIC8vIGlzIHVzZWQuIElmIHdlIHVzZWQgYnVmZmVyaW5nIGluIHRoYXQgY2FzZSwgb3VyIEJXIGVzdGltYXRlIHNhbXBsZSB3aWxsIGJlIHZlcnkgbGFyZ2UuXG4gICAgY29uc3QgcHJvY2Vzc2luZ01zID0gc3RhdHMucGFyc2luZy5lbmQgLSBzdGF0cy5sb2FkaW5nLnN0YXJ0IC0gTWF0aC5taW4oc3RhdHMubG9hZGluZy5maXJzdCAtIHN0YXRzLmxvYWRpbmcuc3RhcnQsIHRoaXMuYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGVUVEZCKCkpO1xuICAgIHRoaXMuYndFc3RpbWF0b3Iuc2FtcGxlKHByb2Nlc3NpbmdNcywgc3RhdHMubG9hZGVkKTtcbiAgICBzdGF0cy5id0VzdGltYXRlID0gdGhpcy5nZXRCd0VzdGltYXRlKCk7XG4gICAgaWYgKGZyYWcuYml0cmF0ZVRlc3QpIHtcbiAgICAgIHRoaXMuYml0cmF0ZVRlc3REZWxheSA9IHByb2Nlc3NpbmdNcyAvIDEwMDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYml0cmF0ZVRlc3REZWxheSA9IDA7XG4gICAgfVxuICB9XG4gIGlnbm9yZUZyYWdtZW50KGZyYWcpIHtcbiAgICAvLyBPbmx5IGNvdW50IG5vbi1hbHQtYXVkaW8gZnJhZ3Mgd2hpY2ggd2VyZSBhY3R1YWxseSBidWZmZXJlZCBpbiBvdXIgQlcgY2FsY3VsYXRpb25zXG4gICAgcmV0dXJuIGZyYWcudHlwZSAhPT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTiB8fCBmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnO1xuICB9XG4gIGNsZWFyVGltZXIoKSB7XG4gICAgaWYgKHRoaXMudGltZXIgPiAtMSkge1xuICAgICAgc2VsZi5jbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgdGhpcy50aW1lciA9IC0xO1xuICAgIH1cbiAgfVxuICBnZXQgZmlyc3RBdXRvTGV2ZWwoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbWF4QXV0b0xldmVsLFxuICAgICAgbWluQXV0b0xldmVsXG4gICAgfSA9IHRoaXMuaGxzO1xuICAgIGNvbnN0IGJ3RXN0aW1hdGUgPSB0aGlzLmdldEJ3RXN0aW1hdGUoKTtcbiAgICBjb25zdCBtYXhTdGFydERlbGF5ID0gdGhpcy5obHMuY29uZmlnLm1heFN0YXJ2YXRpb25EZWxheTtcbiAgICBjb25zdCBhYnJBdXRvTGV2ZWwgPSB0aGlzLmZpbmRCZXN0TGV2ZWwoYndFc3RpbWF0ZSwgbWluQXV0b0xldmVsLCBtYXhBdXRvTGV2ZWwsIDAsIG1heFN0YXJ0RGVsYXksIDEsIDEpO1xuICAgIGlmIChhYnJBdXRvTGV2ZWwgPiAtMSkge1xuICAgICAgcmV0dXJuIGFickF1dG9MZXZlbDtcbiAgICB9XG4gICAgY29uc3QgZmlyc3RMZXZlbCA9IHRoaXMuaGxzLmZpcnN0TGV2ZWw7XG4gICAgY29uc3QgY2xhbXBlZCA9IE1hdGgubWluKE1hdGgubWF4KGZpcnN0TGV2ZWwsIG1pbkF1dG9MZXZlbCksIG1heEF1dG9MZXZlbCk7XG4gICAgdGhpcy53YXJuKGBDb3VsZCBub3QgZmluZCBiZXN0IHN0YXJ0aW5nIGF1dG8gbGV2ZWwuIERlZmF1bHRpbmcgdG8gZmlyc3QgaW4gcGxheWxpc3QgJHtmaXJzdExldmVsfSBjbGFtcGVkIHRvICR7Y2xhbXBlZH1gKTtcbiAgICByZXR1cm4gY2xhbXBlZDtcbiAgfVxuICBnZXQgZm9yY2VkQXV0b0xldmVsKCkge1xuICAgIGlmICh0aGlzLm5leHRBdXRvTGV2ZWxLZXkpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX25leHRBdXRvTGV2ZWw7XG4gIH1cblxuICAvLyByZXR1cm4gbmV4dCBhdXRvIGxldmVsXG4gIGdldCBuZXh0QXV0b0xldmVsKCkge1xuICAgIGNvbnN0IGZvcmNlZEF1dG9MZXZlbCA9IHRoaXMuZm9yY2VkQXV0b0xldmVsO1xuICAgIGNvbnN0IGJ3RXN0aW1hdG9yID0gdGhpcy5id0VzdGltYXRvcjtcbiAgICBjb25zdCB1c2VFc3RpbWF0ZSA9IGJ3RXN0aW1hdG9yLmNhbkVzdGltYXRlKCk7XG4gICAgY29uc3QgbG9hZGVkRmlyc3RGcmFnID0gdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsID4gLTE7XG4gICAgLy8gaW4gY2FzZSBuZXh0IGF1dG8gbGV2ZWwgaGFzIGJlZW4gZm9yY2VkLCBhbmQgYncgbm90IGF2YWlsYWJsZSBvciBub3QgcmVsaWFibGUsIHJldHVybiBmb3JjZWQgdmFsdWVcbiAgICBpZiAoZm9yY2VkQXV0b0xldmVsICE9PSAtMSAmJiAoIXVzZUVzdGltYXRlIHx8ICFsb2FkZWRGaXJzdEZyYWcgfHwgdGhpcy5uZXh0QXV0b0xldmVsS2V5ID09PSB0aGlzLmdldEF1dG9MZXZlbEtleSgpKSkge1xuICAgICAgcmV0dXJuIGZvcmNlZEF1dG9MZXZlbDtcbiAgICB9XG5cbiAgICAvLyBjb21wdXRlIG5leHQgbGV2ZWwgdXNpbmcgQUJSIGxvZ2ljXG4gICAgY29uc3QgbmV4dEFCUkF1dG9MZXZlbCA9IHVzZUVzdGltYXRlICYmIGxvYWRlZEZpcnN0RnJhZyA/IHRoaXMuZ2V0TmV4dEFCUkF1dG9MZXZlbCgpIDogdGhpcy5maXJzdEF1dG9MZXZlbDtcblxuICAgIC8vIHVzZSBmb3JjZWQgYXV0byBsZXZlbCB3aGlsZSBpdCBoYXNuJ3QgZXJyb3JlZCBtb3JlIHRoYW4gQUJSIHNlbGVjdGlvblxuICAgIGlmIChmb3JjZWRBdXRvTGV2ZWwgIT09IC0xKSB7XG4gICAgICBjb25zdCBsZXZlbHMgPSB0aGlzLmhscy5sZXZlbHM7XG4gICAgICBpZiAobGV2ZWxzLmxlbmd0aCA+IE1hdGgubWF4KGZvcmNlZEF1dG9MZXZlbCwgbmV4dEFCUkF1dG9MZXZlbCkgJiYgbGV2ZWxzW2ZvcmNlZEF1dG9MZXZlbF0ubG9hZEVycm9yIDw9IGxldmVsc1tuZXh0QUJSQXV0b0xldmVsXS5sb2FkRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZvcmNlZEF1dG9MZXZlbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzYXZlIHJlc3VsdCB1bnRpbCBzdGF0ZSBoYXMgY2hhbmdlZFxuICAgIHRoaXMuX25leHRBdXRvTGV2ZWwgPSBuZXh0QUJSQXV0b0xldmVsO1xuICAgIHRoaXMubmV4dEF1dG9MZXZlbEtleSA9IHRoaXMuZ2V0QXV0b0xldmVsS2V5KCk7XG4gICAgcmV0dXJuIG5leHRBQlJBdXRvTGV2ZWw7XG4gIH1cbiAgZ2V0QXV0b0xldmVsS2V5KCkge1xuICAgIHJldHVybiBgJHt0aGlzLmdldEJ3RXN0aW1hdGUoKX1fJHt0aGlzLmdldFN0YXJ2YXRpb25EZWxheSgpLnRvRml4ZWQoMil9YDtcbiAgfVxuICBnZXROZXh0QUJSQXV0b0xldmVsKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWdDdXJyZW50LFxuICAgICAgcGFydEN1cnJlbnQsXG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoaGxzLmxldmVscy5sZW5ndGggPD0gMSkge1xuICAgICAgcmV0dXJuIGhscy5sb2FkTGV2ZWw7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIG1heEF1dG9MZXZlbCxcbiAgICAgIGNvbmZpZyxcbiAgICAgIG1pbkF1dG9MZXZlbFxuICAgIH0gPSBobHM7XG4gICAgY29uc3QgY3VycmVudEZyYWdEdXJhdGlvbiA9IHBhcnRDdXJyZW50ID8gcGFydEN1cnJlbnQuZHVyYXRpb24gOiBmcmFnQ3VycmVudCA/IGZyYWdDdXJyZW50LmR1cmF0aW9uIDogMDtcbiAgICBjb25zdCBhdmdidyA9IHRoaXMuZ2V0QndFc3RpbWF0ZSgpO1xuICAgIC8vIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSBpcyB0aGUgd2FsbC1jbG9jayB0aW1lIGxlZnQgdW50aWwgdGhlIHBsYXliYWNrIGJ1ZmZlciBpcyBleGhhdXN0ZWQuXG4gICAgY29uc3QgYnVmZmVyU3RhcnZhdGlvbkRlbGF5ID0gdGhpcy5nZXRTdGFydmF0aW9uRGVsYXkoKTtcbiAgICBsZXQgYndGYWN0b3IgPSBjb25maWcuYWJyQmFuZFdpZHRoRmFjdG9yO1xuICAgIGxldCBid1VwRmFjdG9yID0gY29uZmlnLmFickJhbmRXaWR0aFVwRmFjdG9yO1xuXG4gICAgLy8gRmlyc3QsIGxvb2sgdG8gc2VlIGlmIHdlIGNhbiBmaW5kIGEgbGV2ZWwgbWF0Y2hpbmcgd2l0aCBvdXIgYXZnIGJhbmR3aWR0aCBBTkQgdGhhdCBjb3VsZCBhbHNvIGd1YXJhbnRlZSBubyByZWJ1ZmZlcmluZyBhdCBhbGxcbiAgICBpZiAoYnVmZmVyU3RhcnZhdGlvbkRlbGF5KSB7XG4gICAgICBjb25zdCBfYmVzdExldmVsID0gdGhpcy5maW5kQmVzdExldmVsKGF2Z2J3LCBtaW5BdXRvTGV2ZWwsIG1heEF1dG9MZXZlbCwgYnVmZmVyU3RhcnZhdGlvbkRlbGF5LCAwLCBid0ZhY3RvciwgYndVcEZhY3Rvcik7XG4gICAgICBpZiAoX2Jlc3RMZXZlbCA+PSAwKSB7XG4gICAgICAgIHRoaXMucmVidWZmZXJOb3RpY2UgPSAtMTtcbiAgICAgICAgcmV0dXJuIF9iZXN0TGV2ZWw7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG5vdCBwb3NzaWJsZSB0byBnZXQgcmlkIG9mIHJlYnVmZmVyaW5nLi4uIHRyeSB0byBmaW5kIGxldmVsIHRoYXQgd2lsbCBndWFyYW50ZWUgbGVzcyB0aGFuIG1heFN0YXJ2YXRpb25EZWxheSBvZiByZWJ1ZmZlcmluZ1xuICAgIGxldCBtYXhTdGFydmF0aW9uRGVsYXkgPSBjdXJyZW50RnJhZ0R1cmF0aW9uID8gTWF0aC5taW4oY3VycmVudEZyYWdEdXJhdGlvbiwgY29uZmlnLm1heFN0YXJ2YXRpb25EZWxheSkgOiBjb25maWcubWF4U3RhcnZhdGlvbkRlbGF5O1xuICAgIGlmICghYnVmZmVyU3RhcnZhdGlvbkRlbGF5KSB7XG4gICAgICAvLyBpbiBjYXNlIGJ1ZmZlciBpcyBlbXB0eSwgbGV0J3MgY2hlY2sgaWYgcHJldmlvdXMgZnJhZ21lbnQgd2FzIGxvYWRlZCB0byBwZXJmb3JtIGEgYml0cmF0ZSB0ZXN0XG4gICAgICBjb25zdCBiaXRyYXRlVGVzdERlbGF5ID0gdGhpcy5iaXRyYXRlVGVzdERlbGF5O1xuICAgICAgaWYgKGJpdHJhdGVUZXN0RGVsYXkpIHtcbiAgICAgICAgLy8gaWYgaXQgaXMgdGhlIGNhc2UsIHRoZW4gd2UgbmVlZCB0byBhZGp1c3Qgb3VyIG1heCBzdGFydmF0aW9uIGRlbGF5IHVzaW5nIG1heExvYWRpbmdEZWxheSBjb25maWcgdmFsdWVcbiAgICAgICAgLy8gbWF4IHZpZGVvIGxvYWRpbmcgZGVsYXkgdXNlZCBpbiAgYXV0b21hdGljIHN0YXJ0IGxldmVsIHNlbGVjdGlvbiA6XG4gICAgICAgIC8vIGluIHRoYXQgbW9kZSBBQlIgY29udHJvbGxlciB3aWxsIGVuc3VyZSB0aGF0IHZpZGVvIGxvYWRpbmcgdGltZSAoaWUgdGhlIHRpbWUgdG8gZmV0Y2ggdGhlIGZpcnN0IGZyYWdtZW50IGF0IGxvd2VzdCBxdWFsaXR5IGxldmVsICtcbiAgICAgICAgLy8gdGhlIHRpbWUgdG8gZmV0Y2ggdGhlIGZyYWdtZW50IGF0IHRoZSBhcHByb3ByaWF0ZSBxdWFsaXR5IGxldmVsIGlzIGxlc3MgdGhhbiBgYGBtYXhMb2FkaW5nRGVsYXlgYGAgKVxuICAgICAgICAvLyBjYXAgbWF4TG9hZGluZ0RlbGF5IGFuZCBlbnN1cmUgaXQgaXMgbm90IGJpZ2dlciAndGhhbiBiaXRyYXRlIHRlc3QnIGZyYWcgZHVyYXRpb25cbiAgICAgICAgY29uc3QgbWF4TG9hZGluZ0RlbGF5ID0gY3VycmVudEZyYWdEdXJhdGlvbiA/IE1hdGgubWluKGN1cnJlbnRGcmFnRHVyYXRpb24sIGNvbmZpZy5tYXhMb2FkaW5nRGVsYXkpIDogY29uZmlnLm1heExvYWRpbmdEZWxheTtcbiAgICAgICAgbWF4U3RhcnZhdGlvbkRlbGF5ID0gbWF4TG9hZGluZ0RlbGF5IC0gYml0cmF0ZVRlc3REZWxheTtcbiAgICAgICAgdGhpcy5pbmZvKGBiaXRyYXRlIHRlc3QgdG9vayAke01hdGgucm91bmQoMTAwMCAqIGJpdHJhdGVUZXN0RGVsYXkpfW1zLCBzZXQgZmlyc3QgZnJhZ21lbnQgbWF4IGZldGNoRHVyYXRpb24gdG8gJHtNYXRoLnJvdW5kKDEwMDAgKiBtYXhTdGFydmF0aW9uRGVsYXkpfSBtc2ApO1xuICAgICAgICAvLyBkb24ndCB1c2UgY29uc2VydmF0aXZlIGZhY3RvciBvbiBiaXRyYXRlIHRlc3RcbiAgICAgICAgYndGYWN0b3IgPSBid1VwRmFjdG9yID0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYmVzdExldmVsID0gdGhpcy5maW5kQmVzdExldmVsKGF2Z2J3LCBtaW5BdXRvTGV2ZWwsIG1heEF1dG9MZXZlbCwgYnVmZmVyU3RhcnZhdGlvbkRlbGF5LCBtYXhTdGFydmF0aW9uRGVsYXksIGJ3RmFjdG9yLCBid1VwRmFjdG9yKTtcbiAgICBpZiAodGhpcy5yZWJ1ZmZlck5vdGljZSAhPT0gYmVzdExldmVsKSB7XG4gICAgICB0aGlzLnJlYnVmZmVyTm90aWNlID0gYmVzdExldmVsO1xuICAgICAgdGhpcy5pbmZvKGAke2J1ZmZlclN0YXJ2YXRpb25EZWxheSA/ICdyZWJ1ZmZlcmluZyBleHBlY3RlZCcgOiAnYnVmZmVyIGlzIGVtcHR5J30sIG9wdGltYWwgcXVhbGl0eSBsZXZlbCAke2Jlc3RMZXZlbH1gKTtcbiAgICB9XG4gICAgaWYgKGJlc3RMZXZlbCA+IC0xKSB7XG4gICAgICByZXR1cm4gYmVzdExldmVsO1xuICAgIH1cbiAgICAvLyBJZiBubyBtYXRjaGluZyBsZXZlbCBmb3VuZCwgc2VlIGlmIG1pbiBhdXRvIGxldmVsIHdvdWxkIGJlIGEgYmV0dGVyIG9wdGlvblxuICAgIGNvbnN0IG1pbkxldmVsID0gaGxzLmxldmVsc1ttaW5BdXRvTGV2ZWxdO1xuICAgIGNvbnN0IGF1dG9MZXZlbCA9IGhscy5sb2FkTGV2ZWxPYmo7XG4gICAgaWYgKGF1dG9MZXZlbCAmJiAobWluTGV2ZWwgPT0gbnVsbCA/IHZvaWQgMCA6IG1pbkxldmVsLmJpdHJhdGUpIDwgYXV0b0xldmVsLmJpdHJhdGUpIHtcbiAgICAgIHJldHVybiBtaW5BdXRvTGV2ZWw7XG4gICAgfVxuICAgIC8vIG9yIGlmIGJpdHJhdGUgaXMgbm90IGxvd2VyLCBjb250aW51ZSB0byB1c2UgbG9hZExldmVsXG4gICAgcmV0dXJuIGhscy5sb2FkTGV2ZWw7XG4gIH1cbiAgZ2V0U3RhcnZhdGlvbkRlbGF5KCkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGNvbnN0IG1lZGlhID0gaGxzLm1lZGlhO1xuICAgIGlmICghbWVkaWEpIHtcbiAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgLy8gcGxheWJhY2tSYXRlIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGUgcGxheWJhY2sgcmF0ZTsgaWYgbWVkaWEucGxheWJhY2tSYXRlIGlzIDAsIHdlIHVzZSAxIHRvIGxvYWQgYXNcbiAgICAvLyBpZiB3ZSdyZSBwbGF5aW5nIGJhY2sgYXQgdGhlIG5vcm1hbCByYXRlLlxuICAgIGNvbnN0IHBsYXliYWNrUmF0ZSA9IG1lZGlhICYmIG1lZGlhLnBsYXliYWNrUmF0ZSAhPT0gMCA/IE1hdGguYWJzKG1lZGlhLnBsYXliYWNrUmF0ZSkgOiAxLjA7XG4gICAgY29uc3QgYnVmZmVySW5mbyA9IGhscy5tYWluRm9yd2FyZEJ1ZmZlckluZm87XG4gICAgcmV0dXJuIChidWZmZXJJbmZvID8gYnVmZmVySW5mby5sZW4gOiAwKSAvIHBsYXliYWNrUmF0ZTtcbiAgfVxuICBnZXRCd0VzdGltYXRlKCkge1xuICAgIHJldHVybiB0aGlzLmJ3RXN0aW1hdG9yLmNhbkVzdGltYXRlKCkgPyB0aGlzLmJ3RXN0aW1hdG9yLmdldEVzdGltYXRlKCkgOiB0aGlzLmhscy5jb25maWcuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZTtcbiAgfVxuICBmaW5kQmVzdExldmVsKGN1cnJlbnRCdywgbWluQXV0b0xldmVsLCBtYXhBdXRvTGV2ZWwsIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSwgbWF4U3RhcnZhdGlvbkRlbGF5LCBid0ZhY3RvciwgYndVcEZhY3Rvcikge1xuICAgIHZhciBfdGhpcyRobHMkbGF0ZXN0TGV2ZWw7XG4gICAgY29uc3QgbWF4RmV0Y2hEdXJhdGlvbiA9IGJ1ZmZlclN0YXJ2YXRpb25EZWxheSArIG1heFN0YXJ2YXRpb25EZWxheTtcbiAgICBjb25zdCBsYXN0TG9hZGVkRnJhZ0xldmVsID0gdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsO1xuICAgIGNvbnN0IHNlbGVjdGlvbkJhc2VMZXZlbCA9IGxhc3RMb2FkZWRGcmFnTGV2ZWwgPT09IC0xID8gdGhpcy5obHMuZmlyc3RMZXZlbCA6IGxhc3RMb2FkZWRGcmFnTGV2ZWw7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZ0N1cnJlbnQsXG4gICAgICBwYXJ0Q3VycmVudFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIGxldmVscyxcbiAgICAgIGFsbEF1ZGlvVHJhY2tzLFxuICAgICAgbG9hZExldmVsLFxuICAgICAgY29uZmlnXG4gICAgfSA9IHRoaXMuaGxzO1xuICAgIGlmIChsZXZlbHMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29uc3QgbGV2ZWwgPSBsZXZlbHNbc2VsZWN0aW9uQmFzZUxldmVsXTtcbiAgICBjb25zdCBsaXZlID0gISEoKF90aGlzJGhscyRsYXRlc3RMZXZlbCA9IHRoaXMuaGxzLmxhdGVzdExldmVsRGV0YWlscykgIT0gbnVsbCAmJiBfdGhpcyRobHMkbGF0ZXN0TGV2ZWwubGl2ZSk7XG4gICAgY29uc3QgZmlyc3RTZWxlY3Rpb24gPSBsb2FkTGV2ZWwgPT09IC0xIHx8IGxhc3RMb2FkZWRGcmFnTGV2ZWwgPT09IC0xO1xuICAgIGxldCBjdXJyZW50Q29kZWNTZXQ7XG4gICAgbGV0IGN1cnJlbnRWaWRlb1JhbmdlID0gJ1NEUic7XG4gICAgbGV0IGN1cnJlbnRGcmFtZVJhdGUgPSAobGV2ZWwgPT0gbnVsbCA/IHZvaWQgMCA6IGxldmVsLmZyYW1lUmF0ZSkgfHwgMDtcbiAgICBjb25zdCB7XG4gICAgICBhdWRpb1ByZWZlcmVuY2UsXG4gICAgICB2aWRlb1ByZWZlcmVuY2VcbiAgICB9ID0gY29uZmlnO1xuICAgIGNvbnN0IGF1ZGlvVHJhY2tzQnlHcm91cCA9IHRoaXMuYXVkaW9UcmFja3NCeUdyb3VwIHx8ICh0aGlzLmF1ZGlvVHJhY2tzQnlHcm91cCA9IGdldEF1ZGlvVHJhY2tzQnlHcm91cChhbGxBdWRpb1RyYWNrcykpO1xuICAgIGxldCBtaW5TdGFydEluZGV4ID0gLTE7XG4gICAgaWYgKGZpcnN0U2VsZWN0aW9uKSB7XG4gICAgICBpZiAodGhpcy5maXJzdFNlbGVjdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlyc3RTZWxlY3Rpb247XG4gICAgICB9XG4gICAgICBjb25zdCBjb2RlY1RpZXJzID0gdGhpcy5jb2RlY1RpZXJzIHx8ICh0aGlzLmNvZGVjVGllcnMgPSBnZXRDb2RlY1RpZXJzKGxldmVscywgYXVkaW9UcmFja3NCeUdyb3VwLCBtaW5BdXRvTGV2ZWwsIG1heEF1dG9MZXZlbCkpO1xuICAgICAgY29uc3Qgc3RhcnRUaWVyID0gZ2V0U3RhcnRDb2RlY1RpZXIoY29kZWNUaWVycywgY3VycmVudFZpZGVvUmFuZ2UsIGN1cnJlbnRCdywgYXVkaW9QcmVmZXJlbmNlLCB2aWRlb1ByZWZlcmVuY2UpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb2RlY1NldCxcbiAgICAgICAgdmlkZW9SYW5nZXMsXG4gICAgICAgIG1pbkZyYW1lcmF0ZSxcbiAgICAgICAgbWluQml0cmF0ZSxcbiAgICAgICAgbWluSW5kZXgsXG4gICAgICAgIHByZWZlckhEUlxuICAgICAgfSA9IHN0YXJ0VGllcjtcbiAgICAgIG1pblN0YXJ0SW5kZXggPSBtaW5JbmRleDtcbiAgICAgIGN1cnJlbnRDb2RlY1NldCA9IGNvZGVjU2V0O1xuICAgICAgY3VycmVudFZpZGVvUmFuZ2UgPSBwcmVmZXJIRFIgPyB2aWRlb1Jhbmdlc1t2aWRlb1Jhbmdlcy5sZW5ndGggLSAxXSA6IHZpZGVvUmFuZ2VzWzBdO1xuICAgICAgY3VycmVudEZyYW1lUmF0ZSA9IG1pbkZyYW1lcmF0ZTtcbiAgICAgIGN1cnJlbnRCdyA9IE1hdGgubWF4KGN1cnJlbnRCdywgbWluQml0cmF0ZSk7XG4gICAgICB0aGlzLmxvZyhgcGlja2VkIHN0YXJ0IHRpZXIgJHtzdHJpbmdpZnkoc3RhcnRUaWVyKX1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudENvZGVjU2V0ID0gbGV2ZWwgPT0gbnVsbCA/IHZvaWQgMCA6IGxldmVsLmNvZGVjU2V0O1xuICAgICAgY3VycmVudFZpZGVvUmFuZ2UgPSBsZXZlbCA9PSBudWxsID8gdm9pZCAwIDogbGV2ZWwudmlkZW9SYW5nZTtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudEZyYWdEdXJhdGlvbiA9IHBhcnRDdXJyZW50ID8gcGFydEN1cnJlbnQuZHVyYXRpb24gOiBmcmFnQ3VycmVudCA/IGZyYWdDdXJyZW50LmR1cmF0aW9uIDogMDtcbiAgICBjb25zdCB0dGZiRXN0aW1hdGVTZWMgPSB0aGlzLmJ3RXN0aW1hdG9yLmdldEVzdGltYXRlVFRGQigpIC8gMTAwMDtcbiAgICBjb25zdCBsZXZlbHNTa2lwcGVkID0gW107XG4gICAgZm9yIChsZXQgaSA9IG1heEF1dG9MZXZlbDsgaSA+PSBtaW5BdXRvTGV2ZWw7IGktLSkge1xuICAgICAgdmFyIF9sZXZlbEluZm8kc3VwcG9ydGVkUiwgX2xldmVsSW5mbyRzdXBwb3J0ZWRSMjtcbiAgICAgIGNvbnN0IGxldmVsSW5mbyA9IGxldmVsc1tpXTtcbiAgICAgIGNvbnN0IHVwU3dpdGNoID0gaSA+IHNlbGVjdGlvbkJhc2VMZXZlbDtcbiAgICAgIGlmICghbGV2ZWxJbmZvKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGNvbmZpZy51c2VNZWRpYUNhcGFiaWxpdGllcyAmJiAhbGV2ZWxJbmZvLnN1cHBvcnRlZFJlc3VsdCAmJiAhbGV2ZWxJbmZvLnN1cHBvcnRlZFByb21pc2UpIHtcbiAgICAgICAgY29uc3QgbWVkaWFDYXBhYmlsaXRpZXMgPSBuYXZpZ2F0b3IubWVkaWFDYXBhYmlsaXRpZXM7XG4gICAgICAgIGlmICh0eXBlb2YgKG1lZGlhQ2FwYWJpbGl0aWVzID09IG51bGwgPyB2b2lkIDAgOiBtZWRpYUNhcGFiaWxpdGllcy5kZWNvZGluZ0luZm8pID09PSAnZnVuY3Rpb24nICYmIHJlcXVpcmVzTWVkaWFDYXBhYmlsaXRpZXNEZWNvZGluZ0luZm8obGV2ZWxJbmZvLCBhdWRpb1RyYWNrc0J5R3JvdXAsIGN1cnJlbnRWaWRlb1JhbmdlLCBjdXJyZW50RnJhbWVSYXRlLCBjdXJyZW50QncsIGF1ZGlvUHJlZmVyZW5jZSkpIHtcbiAgICAgICAgICBsZXZlbEluZm8uc3VwcG9ydGVkUHJvbWlzZSA9IGdldE1lZGlhRGVjb2RpbmdJbmZvUHJvbWlzZShsZXZlbEluZm8sIGF1ZGlvVHJhY2tzQnlHcm91cCwgbWVkaWFDYXBhYmlsaXRpZXMsIHRoaXMuc3VwcG9ydGVkQ2FjaGUpO1xuICAgICAgICAgIGxldmVsSW5mby5zdXBwb3J0ZWRQcm9taXNlLnRoZW4oZGVjb2RpbmdJbmZvID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5obHMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV2ZWxJbmZvLnN1cHBvcnRlZFJlc3VsdCA9IGRlY29kaW5nSW5mbztcbiAgICAgICAgICAgIGNvbnN0IGxldmVscyA9IHRoaXMuaGxzLmxldmVscztcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gbGV2ZWxzLmluZGV4T2YobGV2ZWxJbmZvKTtcbiAgICAgICAgICAgIGlmIChkZWNvZGluZ0luZm8uZXJyb3IpIHtcbiAgICAgICAgICAgICAgdGhpcy53YXJuKGBNZWRpYUNhcGFiaWxpdGllcyBkZWNvZGluZ0luZm8gZXJyb3I6IFwiJHtkZWNvZGluZ0luZm8uZXJyb3J9XCIgZm9yIGxldmVsICR7aW5kZXh9ICR7c3RyaW5naWZ5KGRlY29kaW5nSW5mbyl9YCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFkZWNvZGluZ0luZm8uc3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgIHRoaXMud2FybihgVW5zdXBwb3J0ZWQgTWVkaWFDYXBhYmlsaXRpZXMgZGVjb2RpbmdJbmZvIHJlc3VsdCBmb3IgbGV2ZWwgJHtpbmRleH0gJHtzdHJpbmdpZnkoZGVjb2RpbmdJbmZvKX1gKTtcbiAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEgJiYgbGV2ZWxzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZyhgUmVtb3ZpbmcgdW5zdXBwb3J0ZWQgbGV2ZWwgJHtpbmRleH1gKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhscy5yZW1vdmVMZXZlbChpbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGxzLmxvYWRMZXZlbCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuaGxzLm5leHRMb2FkTGV2ZWwgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChkZWNvZGluZ0luZm8uZGVjb2RpbmdJbmZvUmVzdWx0cy5zb21lKGluZm8gPT4gaW5mby5zbW9vdGggPT09IGZhbHNlIHx8IGluZm8ucG93ZXJFZmZpY2llbnQgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgICB0aGlzLmxvZyhgTWVkaWFDYXBhYmlsaXRpZXMgZGVjb2RpbmdJbmZvIGZvciBsZXZlbCAke2luZGV4fSBub3Qgc21vb3RoIG9yIHBvd2VyRWZmaWNpZW50OiAke3N0cmluZ2lmeShkZWNvZGluZ0luZm8pfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldmVsSW5mby5zdXBwb3J0ZWRSZXN1bHQgPSBTVVBQT1JURURfSU5GT19ERUZBVUxUO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHNraXAgY2FuZGlkYXRlcyB3aGljaCBjaGFuZ2UgY29kZWMtZmFtaWx5IG9yIHZpZGVvLXJhbmdlLFxuICAgICAgLy8gYW5kIHdoaWNoIGRlY3JlYXNlIG9yIGluY3JlYXNlIGZyYW1lLXJhdGUgZm9yIHVwIGFuZCBkb3duLXN3aXRjaCByZXNwZWN0ZnVsbHlcbiAgICAgIGlmIChjdXJyZW50Q29kZWNTZXQgJiYgbGV2ZWxJbmZvLmNvZGVjU2V0ICE9PSBjdXJyZW50Q29kZWNTZXQgfHwgY3VycmVudFZpZGVvUmFuZ2UgJiYgbGV2ZWxJbmZvLnZpZGVvUmFuZ2UgIT09IGN1cnJlbnRWaWRlb1JhbmdlIHx8IHVwU3dpdGNoICYmIGN1cnJlbnRGcmFtZVJhdGUgPiBsZXZlbEluZm8uZnJhbWVSYXRlIHx8ICF1cFN3aXRjaCAmJiBjdXJyZW50RnJhbWVSYXRlID4gMCAmJiBjdXJyZW50RnJhbWVSYXRlIDwgbGV2ZWxJbmZvLmZyYW1lUmF0ZSB8fCAoX2xldmVsSW5mbyRzdXBwb3J0ZWRSID0gbGV2ZWxJbmZvLnN1cHBvcnRlZFJlc3VsdCkgIT0gbnVsbCAmJiAoX2xldmVsSW5mbyRzdXBwb3J0ZWRSMiA9IF9sZXZlbEluZm8kc3VwcG9ydGVkUi5kZWNvZGluZ0luZm9SZXN1bHRzKSAhPSBudWxsICYmIF9sZXZlbEluZm8kc3VwcG9ydGVkUjIuc29tZShpbmZvID0+IGluZm8uc21vb3RoID09PSBmYWxzZSkpIHtcbiAgICAgICAgaWYgKCFmaXJzdFNlbGVjdGlvbiB8fCBpICE9PSBtaW5TdGFydEluZGV4KSB7XG4gICAgICAgICAgbGV2ZWxzU2tpcHBlZC5wdXNoKGkpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBsZXZlbERldGFpbHMgPSBsZXZlbEluZm8uZGV0YWlscztcbiAgICAgIGNvbnN0IGF2Z0R1cmF0aW9uID0gKHBhcnRDdXJyZW50ID8gbGV2ZWxEZXRhaWxzID09IG51bGwgPyB2b2lkIDAgOiBsZXZlbERldGFpbHMucGFydFRhcmdldCA6IGxldmVsRGV0YWlscyA9PSBudWxsID8gdm9pZCAwIDogbGV2ZWxEZXRhaWxzLmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbikgfHwgY3VycmVudEZyYWdEdXJhdGlvbjtcbiAgICAgIGxldCBhZGp1c3RlZGJ3O1xuICAgICAgLy8gZm9sbG93IGFsZ29yaXRobSBjYXB0dXJlZCBmcm9tIHN0YWdlZnJpZ2h0IDpcbiAgICAgIC8vIGh0dHBzOi8vYW5kcm9pZC5nb29nbGVzb3VyY2UuY29tL3BsYXRmb3JtL2ZyYW1ld29ya3MvYXYvKy9tYXN0ZXIvbWVkaWEvbGlic3RhZ2VmcmlnaHQvaHR0cGxpdmUvTGl2ZVNlc3Npb24uY3BwXG4gICAgICAvLyBQaWNrIHRoZSBoaWdoZXN0IGJhbmR3aWR0aCBzdHJlYW0gYmVsb3cgb3IgZXF1YWwgdG8gZXN0aW1hdGVkIGJhbmR3aWR0aC5cbiAgICAgIC8vIGNvbnNpZGVyIG9ubHkgODAlIG9mIHRoZSBhdmFpbGFibGUgYmFuZHdpZHRoLCBidXQgaWYgd2UgYXJlIHN3aXRjaGluZyB1cCxcbiAgICAgIC8vIGJlIGV2ZW4gbW9yZSBjb25zZXJ2YXRpdmUgKDcwJSkgdG8gYXZvaWQgb3ZlcmVzdGltYXRpbmcgYW5kIGltbWVkaWF0ZWx5XG4gICAgICAvLyBzd2l0Y2hpbmcgYmFjay5cbiAgICAgIGlmICghdXBTd2l0Y2gpIHtcbiAgICAgICAgYWRqdXN0ZWRidyA9IGJ3RmFjdG9yICogY3VycmVudEJ3O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRqdXN0ZWRidyA9IGJ3VXBGYWN0b3IgKiBjdXJyZW50Qnc7XG4gICAgICB9XG5cbiAgICAgIC8vIFVzZSBhdmVyYWdlIGJpdHJhdGUgd2hlbiBzdGFydmF0aW9uIGRlbGF5IChidWZmZXIgbGVuZ3RoKSBpcyBndCBvciBlcSB0d28gc2VnbWVudCBkdXJhdGlvbnMgYW5kIHJlYnVmZmVyaW5nIGlzIG5vdCBleHBlY3RlZCAobWF4U3RhcnZhdGlvbkRlbGF5ID4gMClcbiAgICAgIGNvbnN0IGJpdHJhdGUgPSBjdXJyZW50RnJhZ0R1cmF0aW9uICYmIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSA+PSBjdXJyZW50RnJhZ0R1cmF0aW9uICogMiAmJiBtYXhTdGFydmF0aW9uRGVsYXkgPT09IDAgPyBsZXZlbEluZm8uYXZlcmFnZUJpdHJhdGUgOiBsZXZlbEluZm8ubWF4Qml0cmF0ZTtcbiAgICAgIGNvbnN0IGZldGNoRHVyYXRpb24gPSB0aGlzLmdldFRpbWVUb0xvYWRGcmFnKHR0ZmJFc3RpbWF0ZVNlYywgYWRqdXN0ZWRidywgYml0cmF0ZSAqIGF2Z0R1cmF0aW9uLCBsZXZlbERldGFpbHMgPT09IHVuZGVmaW5lZCk7XG4gICAgICBjb25zdCBjYW5Td2l0Y2hXaXRoaW5Ub2xlcmFuY2UgPVxuICAgICAgLy8gaWYgYWRqdXN0ZWQgYncgaXMgZ3JlYXRlciB0aGFuIGxldmVsIGJpdHJhdGUgQU5EXG4gICAgICBhZGp1c3RlZGJ3ID49IGJpdHJhdGUgJiYgKFxuICAgICAgLy8gbm8gbGV2ZWwgY2hhbmdlLCBvciBuZXcgbGV2ZWwgaGFzIG5vIGVycm9yIGhpc3RvcnlcbiAgICAgIGkgPT09IGxhc3RMb2FkZWRGcmFnTGV2ZWwgfHwgbGV2ZWxJbmZvLmxvYWRFcnJvciA9PT0gMCAmJiBsZXZlbEluZm8uZnJhZ21lbnRFcnJvciA9PT0gMCkgJiYgKFxuICAgICAgLy8gZnJhZ21lbnQgZmV0Y2hEdXJhdGlvbiB1bmtub3duIE9SIGxpdmUgc3RyZWFtIE9SIGZyYWdtZW50IGZldGNoRHVyYXRpb24gbGVzcyB0aGFuIG1heCBhbGxvd2VkIGZldGNoIGR1cmF0aW9uLCB0aGVuIHRoaXMgbGV2ZWwgbWF0Y2hlc1xuICAgICAgLy8gd2UgZG9uJ3QgYWNjb3VudCBmb3IgbWF4IEZldGNoIER1cmF0aW9uIGZvciBsaXZlIHN0cmVhbXMsIHRoaXMgaXMgdG8gYXZvaWQgc3dpdGNoaW5nIGRvd24gd2hlbiBuZWFyIHRoZSBlZGdlIG9mIGxpdmUgc2xpZGluZyB3aW5kb3cgLi4uXG4gICAgICAvLyBzcGVjaWFsIGNhc2UgdG8gc3VwcG9ydCBzdGFydExldmVsID0gLTEgKGJpdHJhdGVUZXN0KSBvbiBsaXZlIHN0cmVhbXMgOiBpbiB0aGF0IGNhc2Ugd2Ugc2hvdWxkIG5vdCBleGl0IGxvb3Agc28gdGhhdCBmaW5kQmVzdExldmVsIHdpbGwgcmV0dXJuIC0xXG4gICAgICBmZXRjaER1cmF0aW9uIDw9IHR0ZmJFc3RpbWF0ZVNlYyB8fCAhaXNGaW5pdGVOdW1iZXIoZmV0Y2hEdXJhdGlvbikgfHwgbGl2ZSAmJiAhdGhpcy5iaXRyYXRlVGVzdERlbGF5IHx8IGZldGNoRHVyYXRpb24gPCBtYXhGZXRjaER1cmF0aW9uKTtcbiAgICAgIGlmIChjYW5Td2l0Y2hXaXRoaW5Ub2xlcmFuY2UpIHtcbiAgICAgICAgY29uc3QgZm9yY2VkQXV0b0xldmVsID0gdGhpcy5mb3JjZWRBdXRvTGV2ZWw7XG4gICAgICAgIGlmIChpICE9PSBsb2FkTGV2ZWwgJiYgKGZvcmNlZEF1dG9MZXZlbCA9PT0gLTEgfHwgZm9yY2VkQXV0b0xldmVsICE9PSBsb2FkTGV2ZWwpKSB7XG4gICAgICAgICAgaWYgKGxldmVsc1NraXBwZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKGBTa2lwcGVkIGxldmVsKHMpICR7bGV2ZWxzU2tpcHBlZC5qb2luKCcsJyl9IG9mICR7bWF4QXV0b0xldmVsfSBtYXggd2l0aCBDT0RFQ1MgYW5kIFZJREVPLVJBTkdFOlwiJHtsZXZlbHNbbGV2ZWxzU2tpcHBlZFswXV0uY29kZWNzfVwiICR7bGV2ZWxzW2xldmVsc1NraXBwZWRbMF1dLnZpZGVvUmFuZ2V9OyBub3QgY29tcGF0aWJsZSB3aXRoIFwiJHtjdXJyZW50Q29kZWNTZXR9XCIgJHtjdXJyZW50VmlkZW9SYW5nZX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5pbmZvKGBzd2l0Y2ggY2FuZGlkYXRlOiR7c2VsZWN0aW9uQmFzZUxldmVsfS0+JHtpfSBhZGp1c3RlZGJ3KCR7TWF0aC5yb3VuZChhZGp1c3RlZGJ3KX0pLWJpdHJhdGU9JHtNYXRoLnJvdW5kKGFkanVzdGVkYncgLSBiaXRyYXRlKX0gdHRmYjoke3R0ZmJFc3RpbWF0ZVNlYy50b0ZpeGVkKDEpfSBhdmdEdXJhdGlvbjoke2F2Z0R1cmF0aW9uLnRvRml4ZWQoMSl9IG1heEZldGNoRHVyYXRpb246JHttYXhGZXRjaER1cmF0aW9uLnRvRml4ZWQoMSl9IGZldGNoRHVyYXRpb246JHtmZXRjaER1cmF0aW9uLnRvRml4ZWQoMSl9IGZpcnN0U2VsZWN0aW9uOiR7Zmlyc3RTZWxlY3Rpb259IGNvZGVjU2V0OiR7bGV2ZWxJbmZvLmNvZGVjU2V0fSB2aWRlb1JhbmdlOiR7bGV2ZWxJbmZvLnZpZGVvUmFuZ2V9IGhscy5sb2FkTGV2ZWw6JHtsb2FkTGV2ZWx9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpcnN0U2VsZWN0aW9uKSB7XG4gICAgICAgICAgdGhpcy5maXJzdFNlbGVjdGlvbiA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXMgd2UgYXJlIGxvb3BpbmcgZnJvbSBoaWdoZXN0IHRvIGxvd2VzdCwgdGhpcyB3aWxsIHJldHVybiB0aGUgYmVzdCBhY2hpZXZhYmxlIHF1YWxpdHkgbGV2ZWxcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG5vdCBlbm91Z2ggdGltZSBidWRnZXQgZXZlbiB3aXRoIHF1YWxpdHkgbGV2ZWwgMCAuLi4gcmVidWZmZXJpbmcgbWlnaHQgaGFwcGVuXG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHNldCBuZXh0QXV0b0xldmVsKG5leHRMZXZlbCkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5kZXJpdmVOZXh0QXV0b0xldmVsKG5leHRMZXZlbCk7XG4gICAgaWYgKHRoaXMuX25leHRBdXRvTGV2ZWwgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLm5leHRBdXRvTGV2ZWxLZXkgPSAnJztcbiAgICAgIHRoaXMuX25leHRBdXRvTGV2ZWwgPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgZGVyaXZlTmV4dEF1dG9MZXZlbChuZXh0TGV2ZWwpIHtcbiAgICBjb25zdCB7XG4gICAgICBtYXhBdXRvTGV2ZWwsXG4gICAgICBtaW5BdXRvTGV2ZWxcbiAgICB9ID0gdGhpcy5obHM7XG4gICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG5leHRMZXZlbCwgbWluQXV0b0xldmVsKSwgbWF4QXV0b0xldmVsKTtcbiAgfVxufVxuXG5jb25zdCBCaW5hcnlTZWFyY2ggPSB7XG4gIC8qKlxuICAgKiBTZWFyY2hlcyBmb3IgYW4gaXRlbSBpbiBhbiBhcnJheSB3aGljaCBtYXRjaGVzIGEgY2VydGFpbiBjb25kaXRpb24uXG4gICAqIFRoaXMgcmVxdWlyZXMgdGhlIGNvbmRpdGlvbiB0byBvbmx5IG1hdGNoIG9uZSBpdGVtIGluIHRoZSBhcnJheSxcbiAgICogYW5kIGZvciB0aGUgYXJyYXkgdG8gYmUgb3JkZXJlZC5cbiAgICpcbiAgICogQHBhcmFtIGxpc3QgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICogQHBhcmFtIGNvbXBhcmlzb25GblxuICAgKiAgICAgIENhbGxlZCBhbmQgcHJvdmlkZWQgYSBjYW5kaWRhdGUgaXRlbSBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXG4gICAqICAgICAgU2hvdWxkIHJldHVybjpcbiAgICogICAgICAgICAgPiAtMSBpZiB0aGUgaXRlbSBzaG91bGQgYmUgbG9jYXRlZCBhdCBhIGxvd2VyIGluZGV4IHRoYW4gdGhlIHByb3ZpZGVkIGl0ZW0uXG4gICAqICAgICAgICAgID4gMSBpZiB0aGUgaXRlbSBzaG91bGQgYmUgbG9jYXRlZCBhdCBhIGhpZ2hlciBpbmRleCB0aGFuIHRoZSBwcm92aWRlZCBpdGVtLlxuICAgKiAgICAgICAgICA+IDAgaWYgdGhlIGl0ZW0gaXMgdGhlIGl0ZW0geW91J3JlIGxvb2tpbmcgZm9yLlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgb2JqZWN0IGlmIGZvdW5kLCBvdGhlcndpc2UgcmV0dXJucyBudWxsXG4gICAqL1xuICBzZWFyY2g6IGZ1bmN0aW9uIChsaXN0LCBjb21wYXJpc29uRm4pIHtcbiAgICBsZXQgbWluSW5kZXggPSAwO1xuICAgIGxldCBtYXhJbmRleCA9IGxpc3QubGVuZ3RoIC0gMTtcbiAgICBsZXQgY3VycmVudEluZGV4ID0gbnVsbDtcbiAgICBsZXQgY3VycmVudEVsZW1lbnQgPSBudWxsO1xuICAgIHdoaWxlIChtaW5JbmRleCA8PSBtYXhJbmRleCkge1xuICAgICAgY3VycmVudEluZGV4ID0gKG1pbkluZGV4ICsgbWF4SW5kZXgpIC8gMiB8IDA7XG4gICAgICBjdXJyZW50RWxlbWVudCA9IGxpc3RbY3VycmVudEluZGV4XTtcbiAgICAgIGNvbnN0IGNvbXBhcmlzb25SZXN1bHQgPSBjb21wYXJpc29uRm4oY3VycmVudEVsZW1lbnQpO1xuICAgICAgaWYgKGNvbXBhcmlzb25SZXN1bHQgPiAwKSB7XG4gICAgICAgIG1pbkluZGV4ID0gY3VycmVudEluZGV4ICsgMTtcbiAgICAgIH0gZWxzZSBpZiAoY29tcGFyaXNvblJlc3VsdCA8IDApIHtcbiAgICAgICAgbWF4SW5kZXggPSBjdXJyZW50SW5kZXggLSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRFbGVtZW50O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGZpcnN0IGZyYWdtZW50IHdob3NlIGVuZFBkdCB2YWx1ZSBleGNlZWRzIHRoZSBnaXZlbiBQRFQsIG9yIG51bGwuXG4gKiBAcGFyYW0gZnJhZ21lbnRzIC0gVGhlIGFycmF5IG9mIGNhbmRpZGF0ZSBmcmFnbWVudHNcbiAqIEBwYXJhbSBQRFRWYWx1ZSAtIFRoZSBQRFQgdmFsdWUgd2hpY2ggbXVzdCBiZSBleGNlZWRlZFxuICogQHBhcmFtIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgLSBUaGUgYW1vdW50IG9mIHRpbWUgdGhhdCBhIGZyYWdtZW50J3Mgc3RhcnQvZW5kIGNhbiBiZSB3aXRoaW4gaW4gb3JkZXIgdG8gYmUgY29uc2lkZXJlZCBjb250aWd1b3VzXG4gKi9cbmZ1bmN0aW9uIGZpbmRGcmFnbWVudEJ5UERUKGZyYWdtZW50cywgUERUVmFsdWUsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UpIHtcbiAgaWYgKFBEVFZhbHVlID09PSBudWxsIHx8ICFBcnJheS5pc0FycmF5KGZyYWdtZW50cykgfHwgIWZyYWdtZW50cy5sZW5ndGggfHwgIWlzRmluaXRlTnVtYmVyKFBEVFZhbHVlKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gaWYgbGVzcyB0aGFuIHN0YXJ0XG4gIGNvbnN0IHN0YXJ0UERUID0gZnJhZ21lbnRzWzBdLnByb2dyYW1EYXRlVGltZTtcbiAgaWYgKFBEVFZhbHVlIDwgKHN0YXJ0UERUIHx8IDApKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgZW5kUERUID0gZnJhZ21lbnRzW2ZyYWdtZW50cy5sZW5ndGggLSAxXS5lbmRQcm9ncmFtRGF0ZVRpbWU7XG4gIGlmIChQRFRWYWx1ZSA+PSAoZW5kUERUIHx8IDApKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZm9yIChsZXQgc2VnID0gMDsgc2VnIDwgZnJhZ21lbnRzLmxlbmd0aDsgKytzZWcpIHtcbiAgICBjb25zdCBmcmFnID0gZnJhZ21lbnRzW3NlZ107XG4gICAgaWYgKHBkdFdpdGhpblRvbGVyYW5jZVRlc3QoUERUVmFsdWUsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGZyYWcpKSB7XG4gICAgICByZXR1cm4gZnJhZztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogRmluZHMgYSBmcmFnbWVudCBiYXNlZCBvbiB0aGUgU04gb2YgdGhlIHByZXZpb3VzIGZyYWdtZW50OyBvciBiYXNlZCBvbiB0aGUgbmVlZHMgb2YgdGhlIGN1cnJlbnQgYnVmZmVyLlxuICogVGhpcyBtZXRob2QgY29tcGVuc2F0ZXMgZm9yIHNtYWxsIGJ1ZmZlciBnYXBzIGJ5IGFwcGx5aW5nIGEgdG9sZXJhbmNlIHRvIHRoZSBzdGFydCBvZiBhbnkgY2FuZGlkYXRlIGZyYWdtZW50LCB0aHVzXG4gKiBicmVha2luZyBhbnkgdHJhcHMgd2hpY2ggd291bGQgY2F1c2UgdGhlIHNhbWUgZnJhZ21lbnQgdG8gYmUgY29udGludW91c2x5IHNlbGVjdGVkIHdpdGhpbiBhIHNtYWxsIHJhbmdlLlxuICogQHBhcmFtIGZyYWdQcmV2aW91cyAtIFRoZSBsYXN0IGZyYWcgc3VjY2Vzc2Z1bGx5IGFwcGVuZGVkXG4gKiBAcGFyYW0gZnJhZ21lbnRzIC0gVGhlIGFycmF5IG9mIGNhbmRpZGF0ZSBmcmFnbWVudHNcbiAqIEBwYXJhbSBidWZmZXJFbmQgLSBUaGUgZW5kIG9mIHRoZSBjb250aWd1b3VzIGJ1ZmZlcmVkIHJhbmdlIHRoZSBwbGF5aGVhZCBpcyBjdXJyZW50bHkgd2l0aGluXG4gKiBAcGFyYW0gbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSAtIFRoZSBhbW91bnQgb2YgdGltZSB0aGF0IGEgZnJhZ21lbnQncyBzdGFydC9lbmQgY2FuIGJlIHdpdGhpbiBpbiBvcmRlciB0byBiZSBjb25zaWRlcmVkIGNvbnRpZ3VvdXNcbiAqIEByZXR1cm5zIGEgbWF0Y2hpbmcgZnJhZ21lbnQgb3IgbnVsbFxuICovXG5mdW5jdGlvbiBmaW5kRnJhZ21lbnRCeVBUUyhmcmFnUHJldmlvdXMsIGZyYWdtZW50cywgYnVmZmVyRW5kID0gMCwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IDAsIG5leHRGcmFnTG9va3VwVG9sZXJhbmNlID0gMC4wMDUpIHtcbiAgbGV0IGZyYWdOZXh0ID0gbnVsbDtcbiAgaWYgKGZyYWdQcmV2aW91cykge1xuICAgIGZyYWdOZXh0ID0gZnJhZ21lbnRzWzEgKyBmcmFnUHJldmlvdXMuc24gLSBmcmFnbWVudHNbMF0uc25dIHx8IG51bGw7XG4gICAgLy8gY2hlY2sgZm9yIGJ1ZmZlci1lbmQgcm91bmRpbmcgZXJyb3JcbiAgICBjb25zdCBidWZmZXJFZGdlRXJyb3IgPSBmcmFnUHJldmlvdXMuZW5kRFRTIC0gYnVmZmVyRW5kO1xuICAgIGlmIChidWZmZXJFZGdlRXJyb3IgPiAwICYmIGJ1ZmZlckVkZ2VFcnJvciA8IDAuMDAwMDAxNSkge1xuICAgICAgYnVmZmVyRW5kICs9IDAuMDAwMDAxNTtcbiAgICB9XG4gICAgaWYgKGZyYWdOZXh0ICYmIGZyYWdQcmV2aW91cy5sZXZlbCAhPT0gZnJhZ05leHQubGV2ZWwgJiYgZnJhZ05leHQuZW5kIDw9IGZyYWdQcmV2aW91cy5lbmQpIHtcbiAgICAgIGZyYWdOZXh0ID0gZnJhZ21lbnRzWzIgKyBmcmFnUHJldmlvdXMuc24gLSBmcmFnbWVudHNbMF0uc25dIHx8IG51bGw7XG4gICAgfVxuICB9IGVsc2UgaWYgKGJ1ZmZlckVuZCA9PT0gMCAmJiBmcmFnbWVudHNbMF0uc3RhcnQgPT09IDApIHtcbiAgICBmcmFnTmV4dCA9IGZyYWdtZW50c1swXTtcbiAgfVxuICAvLyBQcmVmZXIgdGhlIG5leHQgZnJhZ21lbnQgaWYgaXQncyB3aXRoaW4gdG9sZXJhbmNlXG4gIGlmIChmcmFnTmV4dCAmJiAoKCFmcmFnUHJldmlvdXMgfHwgZnJhZ1ByZXZpb3VzLmxldmVsID09PSBmcmFnTmV4dC5sZXZlbCkgJiYgZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0KGJ1ZmZlckVuZCwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgZnJhZ05leHQpID09PSAwIHx8IGZyYWdtZW50V2l0aGluRmFzdFN0YXJ0U3dpdGNoKGZyYWdOZXh0LCBmcmFnUHJldmlvdXMsIE1hdGgubWluKG5leHRGcmFnTG9va3VwVG9sZXJhbmNlLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlKSkpKSB7XG4gICAgcmV0dXJuIGZyYWdOZXh0O1xuICB9XG4gIC8vIFdlIG1pZ2h0IGJlIHNlZWtpbmcgcGFzdCB0aGUgdG9sZXJhbmNlIHNvIGZpbmQgdGhlIGJlc3QgbWF0Y2hcbiAgY29uc3QgZm91bmRGcmFnbWVudCA9IEJpbmFyeVNlYXJjaC5zZWFyY2goZnJhZ21lbnRzLCBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QuYmluZChudWxsLCBidWZmZXJFbmQsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UpKTtcbiAgaWYgKGZvdW5kRnJhZ21lbnQgJiYgKGZvdW5kRnJhZ21lbnQgIT09IGZyYWdQcmV2aW91cyB8fCAhZnJhZ05leHQpKSB7XG4gICAgcmV0dXJuIGZvdW5kRnJhZ21lbnQ7XG4gIH1cbiAgLy8gSWYgbm8gbWF0Y2ggd2FzIGZvdW5kIHJldHVybiB0aGUgbmV4dCBmcmFnbWVudCBhZnRlciBmcmFnUHJldmlvdXMsIG9yIG51bGxcbiAgcmV0dXJuIGZyYWdOZXh0O1xufVxuZnVuY3Rpb24gZnJhZ21lbnRXaXRoaW5GYXN0U3RhcnRTd2l0Y2goZnJhZ05leHQsIGZyYWdQcmV2aW91cywgbmV4dEZyYWdMb29rdXBUb2xlcmFuY2UpIHtcbiAgaWYgKGZyYWdQcmV2aW91cyAmJiBmcmFnUHJldmlvdXMuc3RhcnQgPT09IDAgJiYgZnJhZ1ByZXZpb3VzLmxldmVsIDwgZnJhZ05leHQubGV2ZWwgJiYgKGZyYWdQcmV2aW91cy5lbmRQVFMgfHwgMCkgPiAwKSB7XG4gICAgY29uc3QgZmlyc3REdXJhdGlvbiA9IGZyYWdQcmV2aW91cy50YWdMaXN0LnJlZHVjZSgoZHVyYXRpb24sIHRhZykgPT4ge1xuICAgICAgaWYgKHRhZ1swXSA9PT0gJ0lORicpIHtcbiAgICAgICAgZHVyYXRpb24gKz0gcGFyc2VGbG9hdCh0YWdbMV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGR1cmF0aW9uO1xuICAgIH0sIG5leHRGcmFnTG9va3VwVG9sZXJhbmNlKTtcbiAgICByZXR1cm4gZnJhZ05leHQuc3RhcnQgPD0gZmlyc3REdXJhdGlvbjtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogVGhlIHRlc3QgZnVuY3Rpb24gdXNlZCBieSB0aGUgZmluZEZyYWdtZW50QnlTbidzIEJpbmFyeVNlYXJjaCB0byBsb29rIGZvciB0aGUgYmVzdCBtYXRjaCB0byB0aGUgY3VycmVudCBidWZmZXIgY29uZGl0aW9ucy5cbiAqIEBwYXJhbSBjYW5kaWRhdGUgLSBUaGUgZnJhZ21lbnQgdG8gdGVzdFxuICogQHBhcmFtIGJ1ZmZlckVuZCAtIFRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgYnVmZmVyZWQgcmFuZ2UgdGhlIHBsYXloZWFkIGlzIGN1cnJlbnRseSB3aXRoaW5cbiAqIEBwYXJhbSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIC0gVGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgYSBmcmFnbWVudCdzIHN0YXJ0IGNhbiBiZSB3aXRoaW4gaW4gb3JkZXIgdG8gYmUgY29uc2lkZXJlZCBjb250aWd1b3VzXG4gKiBAcmV0dXJucyAwIGlmIGl0IG1hdGNoZXMsIDEgaWYgdG9vIGxvdywgLTEgaWYgdG9vIGhpZ2hcbiAqL1xuZnVuY3Rpb24gZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0KGJ1ZmZlckVuZCA9IDAsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPSAwLCBjYW5kaWRhdGUpIHtcbiAgLy8gZWFnZXJseSBhY2NlcHQgYW4gYWNjdXJhdGUgbWF0Y2ggKG5vIHRvbGVyYW5jZSlcbiAgaWYgKGNhbmRpZGF0ZS5zdGFydCA8PSBidWZmZXJFbmQgJiYgY2FuZGlkYXRlLnN0YXJ0ICsgY2FuZGlkYXRlLmR1cmF0aW9uID4gYnVmZmVyRW5kKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgLy8gb2Zmc2V0IHNob3VsZCBiZSB3aXRoaW4gZnJhZ21lbnQgYm91bmRhcnkgLSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZVxuICAvLyB0aGlzIGlzIHRvIGNvcGUgd2l0aCBzaXR1YXRpb25zIGxpa2VcbiAgLy8gYnVmZmVyRW5kID0gOS45OTFcbiAgLy8gZnJhZ1vDmF0gOiBbMCwxMF1cbiAgLy8gZnJhZ1sxXSA6IFsxMCwyMF1cbiAgLy8gYnVmZmVyRW5kIGlzIHdpdGhpbiBmcmFnWzBdIHJhbmdlIC4uLiBhbHRob3VnaCB3aGF0IHdlIGFyZSBleHBlY3RpbmcgaXMgdG8gcmV0dXJuIGZyYWdbMV0gaGVyZVxuICAvLyAgICAgICAgICAgICAgZnJhZyBzdGFydCAgICAgICAgICAgICAgIGZyYWcgc3RhcnQrZHVyYXRpb25cbiAgLy8gICAgICAgICAgICAgICAgICB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gIC8vICAgICAgICAgICAgICA8LS0tPiAgICAgICAgICAgICAgICAgICAgICAgICA8LS0tPlxuICAvLyAgLi4uLS0tLS0tLS0+PC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPjwtLS0tLS0tLS0uLi4uXG4gIC8vIHByZXZpb3VzIGZyYWcgICAgICAgICBtYXRjaGluZyBmcmFnbWVudCAgICAgICAgIG5leHQgZnJhZ1xuICAvLyAgcmV0dXJuIC0xICAgICAgICAgICAgIHJldHVybiAwICAgICAgICAgICAgICAgICByZXR1cm4gMVxuICAvLyBsb2dnZXIubG9nKGBsZXZlbC9zbi9zdGFydC9lbmQvYnVmRW5kOiR7bGV2ZWx9LyR7Y2FuZGlkYXRlLnNufS8ke2NhbmRpZGF0ZS5zdGFydH0vJHsoY2FuZGlkYXRlLnN0YXJ0K2NhbmRpZGF0ZS5kdXJhdGlvbil9LyR7YnVmZmVyRW5kfWApO1xuICAvLyBTZXQgdGhlIGxvb2t1cCB0b2xlcmFuY2UgdG8gYmUgc21hbGwgZW5vdWdoIHRvIGRldGVjdCB0aGUgY3VycmVudCBzZWdtZW50IC0gZW5zdXJlcyB3ZSBkb24ndCBza2lwIG92ZXIgdmVyeSBzbWFsbCBzZWdtZW50c1xuICBjb25zdCBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPSBNYXRoLm1pbihtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBjYW5kaWRhdGUuZHVyYXRpb24gKyAoY2FuZGlkYXRlLmRlbHRhUFRTID8gY2FuZGlkYXRlLmRlbHRhUFRTIDogMCkpO1xuICBpZiAoY2FuZGlkYXRlLnN0YXJ0ICsgY2FuZGlkYXRlLmR1cmF0aW9uIC0gY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlIDw9IGJ1ZmZlckVuZCkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2UgaWYgKGNhbmRpZGF0ZS5zdGFydCAtIGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA+IGJ1ZmZlckVuZCAmJiBjYW5kaWRhdGUuc3RhcnQpIHtcbiAgICAvLyBpZiBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIHdpbGwgaGF2ZSBuZWdhdGl2ZSB2YWx1ZSB0aGVuIGRvbid0IHJldHVybiAtMSBmb3IgZmlyc3QgZWxlbWVudFxuICAgIHJldHVybiAtMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLyoqXG4gKiBUaGUgdGVzdCBmdW5jdGlvbiB1c2VkIGJ5IHRoZSBmaW5kRnJhZ21lbnRCeVBkdCdzIEJpbmFyeVNlYXJjaCB0byBsb29rIGZvciB0aGUgYmVzdCBtYXRjaCB0byB0aGUgY3VycmVudCBidWZmZXIgY29uZGl0aW9ucy5cbiAqIFRoaXMgZnVuY3Rpb24gdGVzdHMgdGhlIGNhbmRpZGF0ZSdzIHByb2dyYW0gZGF0ZSB0aW1lIHZhbHVlcywgYXMgcmVwcmVzZW50ZWQgaW4gVW5peCB0aW1lXG4gKiBAcGFyYW0gY2FuZGlkYXRlIC0gVGhlIGZyYWdtZW50IHRvIHRlc3RcbiAqIEBwYXJhbSBwZHRCdWZmZXJFbmQgLSBUaGUgVW5peCB0aW1lIHJlcHJlc2VudGluZyB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGJ1ZmZlcmVkIHJhbmdlXG4gKiBAcGFyYW0gbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSAtIFRoZSBhbW91bnQgb2YgdGltZSB0aGF0IGEgZnJhZ21lbnQncyBzdGFydCBjYW4gYmUgd2l0aGluIGluIG9yZGVyIHRvIGJlIGNvbnNpZGVyZWQgY29udGlndW91c1xuICogQHJldHVybnMgdHJ1ZSBpZiBjb250aWd1b3VzLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZnVuY3Rpb24gcGR0V2l0aGluVG9sZXJhbmNlVGVzdChwZHRCdWZmZXJFbmQsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGNhbmRpZGF0ZSkge1xuICBjb25zdCBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPSBNYXRoLm1pbihtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBjYW5kaWRhdGUuZHVyYXRpb24gKyAoY2FuZGlkYXRlLmRlbHRhUFRTID8gY2FuZGlkYXRlLmRlbHRhUFRTIDogMCkpICogMTAwMDtcblxuICAvLyBlbmRQcm9ncmFtRGF0ZVRpbWUgY2FuIGJlIG51bGwsIGRlZmF1bHQgdG8gemVyb1xuICBjb25zdCBlbmRQcm9ncmFtRGF0ZVRpbWUgPSBjYW5kaWRhdGUuZW5kUHJvZ3JhbURhdGVUaW1lIHx8IDA7XG4gIHJldHVybiBlbmRQcm9ncmFtRGF0ZVRpbWUgLSBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPiBwZHRCdWZmZXJFbmQ7XG59XG5mdW5jdGlvbiBmaW5kTmVhcmVzdFdpdGhDQyhkZXRhaWxzLCBjYywgcG9zKSB7XG4gIGlmIChkZXRhaWxzKSB7XG4gICAgaWYgKGRldGFpbHMuc3RhcnRDQyA8PSBjYyAmJiBkZXRhaWxzLmVuZENDID49IGNjKSB7XG4gICAgICBsZXQgZnJhZ21lbnRzID0gZGV0YWlscy5mcmFnbWVudHM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZyYWdtZW50SGludFxuICAgICAgfSA9IGRldGFpbHM7XG4gICAgICBpZiAoZnJhZ21lbnRIaW50KSB7XG4gICAgICAgIGZyYWdtZW50cyA9IGZyYWdtZW50cy5jb25jYXQoZnJhZ21lbnRIaW50KTtcbiAgICAgIH1cbiAgICAgIGxldCBjbG9zZXN0O1xuICAgICAgQmluYXJ5U2VhcmNoLnNlYXJjaChmcmFnbWVudHMsIGNhbmRpZGF0ZSA9PiB7XG4gICAgICAgIGlmIChjYW5kaWRhdGUuY2MgPCBjYykge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYW5kaWRhdGUuY2MgPiBjYykge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBjbG9zZXN0ID0gY2FuZGlkYXRlO1xuICAgICAgICBpZiAoY2FuZGlkYXRlLmVuZCA8PSBwb3MpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FuZGlkYXRlLnN0YXJ0ID4gcG9zKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gY2xvc2VzdCB8fCBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNUaW1lb3V0RXJyb3IoZXJyb3IpIHtcbiAgc3dpdGNoIChlcnJvci5kZXRhaWxzKSB7XG4gICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVDpcbiAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQ6XG4gICAgY2FzZSBFcnJvckRldGFpbHMuTUFOSUZFU1RfTE9BRF9USU1FT1VUOlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0UmV0cnlDb25maWcobG9hZFBvbGljeSwgZXJyb3IpIHtcbiAgY29uc3QgaXNUaW1lb3V0ID0gaXNUaW1lb3V0RXJyb3IoZXJyb3IpO1xuICByZXR1cm4gbG9hZFBvbGljeS5kZWZhdWx0W2Ake2lzVGltZW91dCA/ICd0aW1lb3V0JyA6ICdlcnJvcid9UmV0cnlgXTtcbn1cbmZ1bmN0aW9uIGdldFJldHJ5RGVsYXkocmV0cnlDb25maWcsIHJldHJ5Q291bnQpIHtcbiAgLy8gZXhwb25lbnRpYWwgYmFja29mZiBjYXBwZWQgdG8gbWF4IHJldHJ5IGRlbGF5XG4gIGNvbnN0IGJhY2tvZmZGYWN0b3IgPSByZXRyeUNvbmZpZy5iYWNrb2ZmID09PSAnbGluZWFyJyA/IDEgOiBNYXRoLnBvdygyLCByZXRyeUNvdW50KTtcbiAgcmV0dXJuIE1hdGgubWluKGJhY2tvZmZGYWN0b3IgKiByZXRyeUNvbmZpZy5yZXRyeURlbGF5TXMsIHJldHJ5Q29uZmlnLm1heFJldHJ5RGVsYXlNcyk7XG59XG5mdW5jdGlvbiBnZXRMb2FkZXJDb25maWdXaXRob3V0UmV0aWVzKGxvZGVyQ29uZmlnKSB7XG4gIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgbG9kZXJDb25maWcpLCB7XG4gICAgZXJyb3JSZXRyeTogbnVsbCxcbiAgICB0aW1lb3V0UmV0cnk6IG51bGxcbiAgfSk7XG59XG5mdW5jdGlvbiBzaG91bGRSZXRyeShyZXRyeUNvbmZpZywgcmV0cnlDb3VudCwgaXNUaW1lb3V0LCBsb2FkZXJSZXNwb25zZSkge1xuICBpZiAoIXJldHJ5Q29uZmlnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGh0dHBTdGF0dXMgPSBsb2FkZXJSZXNwb25zZSA9PSBudWxsID8gdm9pZCAwIDogbG9hZGVyUmVzcG9uc2UuY29kZTtcbiAgY29uc3QgcmV0cnkgPSByZXRyeUNvdW50IDwgcmV0cnlDb25maWcubWF4TnVtUmV0cnkgJiYgKHJldHJ5Rm9ySHR0cFN0YXR1cyhodHRwU3RhdHVzKSB8fCAhIWlzVGltZW91dCk7XG4gIHJldHVybiByZXRyeUNvbmZpZy5zaG91bGRSZXRyeSA/IHJldHJ5Q29uZmlnLnNob3VsZFJldHJ5KHJldHJ5Q29uZmlnLCByZXRyeUNvdW50LCBpc1RpbWVvdXQsIGxvYWRlclJlc3BvbnNlLCByZXRyeSkgOiByZXRyeTtcbn1cbmZ1bmN0aW9uIHJldHJ5Rm9ySHR0cFN0YXR1cyhodHRwU3RhdHVzKSB7XG4gIC8vIERvIG5vdCByZXRyeSBvbiBzdGF0dXMgNHh4LCBzdGF0dXMgMCAoQ09SUyBlcnJvciksIG9yIHVuZGVmaW5lZCAoZGVjcnlwdC9nYXAvcGFyc2UgZXJyb3IpXG4gIHJldHVybiBodHRwU3RhdHVzID09PSAwICYmIG5hdmlnYXRvci5vbkxpbmUgPT09IGZhbHNlIHx8ICEhaHR0cFN0YXR1cyAmJiAoaHR0cFN0YXR1cyA8IDQwMCB8fCBodHRwU3RhdHVzID4gNDk5KTtcbn1cblxudmFyIE5ldHdvcmtFcnJvckFjdGlvbiA9IHtcbiAgRG9Ob3RoaW5nOiAwLFxuICBTZW5kRW5kQ2FsbGJhY2s6IDEsXG4gIFNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3g6IDIsXG4gIFJlbW92ZUFsdGVybmF0ZVBlcm1hbmVudGx5OiAzLFxuICBJbnNlcnREaXNjb250aW51aXR5OiA0LFxuICBSZXRyeVJlcXVlc3Q6IDVcbn07XG52YXIgRXJyb3JBY3Rpb25GbGFncyA9IHtcbiAgTm9uZTogMCxcbiAgTW92ZUFsbEFsdGVybmF0ZXNNYXRjaGluZ0hvc3Q6IDEsXG4gIE1vdmVBbGxBbHRlcm5hdGVzTWF0Y2hpbmdIRENQOiAyLFxuICBTd2l0Y2hUb1NEUjogNFxufTtcbmNsYXNzIEVycm9yQ29udHJvbGxlciBleHRlbmRzIExvZ2dlciB7XG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHN1cGVyKCdlcnJvci1jb250cm9sbGVyJywgaGxzLmxvZ2dlcik7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5wbGF5bGlzdEVycm9yID0gMDtcbiAgICB0aGlzLnBlbmFsaXplZFJlbmRpdGlvbnMgPSB7fTtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9uKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxfVVBEQVRFRCwgdGhpcy5vbkxldmVsVXBkYXRlZCwgdGhpcyk7XG4gIH1cbiAgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBpZiAoIWhscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBobHMub2ZmKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yT3V0LCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmhscyA9IG51bGw7XG4gICAgdGhpcy5wZW5hbGl6ZWRSZW5kaXRpb25zID0ge307XG4gIH1cbiAgc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24pIHt9XG4gIHN0b3BMb2FkKCkge1xuICAgIHRoaXMucGxheWxpc3RFcnJvciA9IDA7XG4gIH1cbiAgZ2V0VmFyaWFudExldmVsSW5kZXgoZnJhZykge1xuICAgIHJldHVybiAoZnJhZyA9PSBudWxsID8gdm9pZCAwIDogZnJhZy50eXBlKSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTiA/IGZyYWcubGV2ZWwgOiB0aGlzLmhscy5sb2FkTGV2ZWw7XG4gIH1cbiAgb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgdGhpcy5wbGF5bGlzdEVycm9yID0gMDtcbiAgICB0aGlzLnBlbmFsaXplZFJlbmRpdGlvbnMgPSB7fTtcbiAgfVxuICBvbkxldmVsVXBkYXRlZCgpIHtcbiAgICB0aGlzLnBsYXlsaXN0RXJyb3IgPSAwO1xuICB9XG4gIG9uRXJyb3IoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgX2RhdGEkZnJhZztcbiAgICBpZiAoZGF0YS5mYXRhbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBjb25zdCBjb250ZXh0ID0gZGF0YS5jb250ZXh0O1xuICAgIHN3aXRjaCAoZGF0YS5kZXRhaWxzKSB7XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVDpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVDpcbiAgICAgICAgZGF0YS5lcnJvckFjdGlvbiA9IHRoaXMuZ2V0RnJhZ1JldHJ5T3JTd2l0Y2hBY3Rpb24oZGF0YSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUjpcbiAgICAgICAgLy8gaWdub3JlIGVtcHR5IHNlZ21lbnQgZXJyb3JzIG1hcmtlZCBhcyBnYXBcbiAgICAgICAgaWYgKChfZGF0YSRmcmFnID0gZGF0YS5mcmFnKSAhPSBudWxsICYmIF9kYXRhJGZyYWcuZ2FwKSB7XG4gICAgICAgICAgZGF0YS5lcnJvckFjdGlvbiA9IGNyZWF0ZURvTm90aGluZ0Vycm9yQWN0aW9uKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0dBUDpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfREVDUllQVF9FUlJPUjpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFN3aXRjaCBsZXZlbCBpZiBwb3NzaWJsZSwgb3RoZXJ3aXNlIGFsbG93IHJldHJ5IGNvdW50IHRvIHJlYWNoIG1heCBlcnJvciByZXRyaWVzXG4gICAgICAgICAgZGF0YS5lcnJvckFjdGlvbiA9IHRoaXMuZ2V0RnJhZ1JldHJ5T3JTd2l0Y2hBY3Rpb24oZGF0YSk7XG4gICAgICAgICAgZGF0YS5lcnJvckFjdGlvbi5hY3Rpb24gPSBOZXR3b3JrRXJyb3JBY3Rpb24uU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0VNUFRZX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuTEVWRUxfUEFSU0lOR19FUlJPUjpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfZGF0YSRjb250ZXh0LCBfZGF0YSRjb250ZXh0JGxldmVsRGU7XG4gICAgICAgICAgLy8gT25seSByZXRyeSB3aGVuIGVtcHR5IGFuZCBsaXZlXG4gICAgICAgICAgY29uc3QgbGV2ZWxJbmRleCA9IGRhdGEucGFyZW50ID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOID8gZGF0YS5sZXZlbCA6IGhscy5sb2FkTGV2ZWw7XG4gICAgICAgICAgaWYgKGRhdGEuZGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLkxFVkVMX0VNUFRZX0VSUk9SICYmICEhKChfZGF0YSRjb250ZXh0ID0gZGF0YS5jb250ZXh0KSAhPSBudWxsICYmIChfZGF0YSRjb250ZXh0JGxldmVsRGUgPSBfZGF0YSRjb250ZXh0LmxldmVsRGV0YWlscykgIT0gbnVsbCAmJiBfZGF0YSRjb250ZXh0JGxldmVsRGUubGl2ZSkpIHtcbiAgICAgICAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSB0aGlzLmdldFBsYXlsaXN0UmV0cnlPclN3aXRjaEFjdGlvbihkYXRhLCBsZXZlbEluZGV4KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRXNjYWxhdGUgdG8gZmF0YWwgaWYgbm90IHJldHJ5aW5nIG9yIHN3aXRjaGluZ1xuICAgICAgICAgICAgZGF0YS5sZXZlbFJldHJ5ID0gZmFsc2U7XG4gICAgICAgICAgICBkYXRhLmVycm9yQWN0aW9uID0gdGhpcy5nZXRMZXZlbFN3aXRjaEFjdGlvbihkYXRhLCBsZXZlbEluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfVElNRU9VVDpcbiAgICAgICAgaWYgKHR5cGVvZiAoY29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogY29udGV4dC5sZXZlbCkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgZGF0YS5lcnJvckFjdGlvbiA9IHRoaXMuZ2V0UGxheWxpc3RSZXRyeU9yU3dpdGNoQWN0aW9uKGRhdGEsIGNvbnRleHQubGV2ZWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX1RJTUVPVVQ6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5TVUJUSVRMRV9MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuU1VCVElUTEVfVFJBQ0tfTE9BRF9USU1FT1VUOlxuICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgIGNvbnN0IGxldmVsID0gaGxzLmxvYWRMZXZlbE9iajtcbiAgICAgICAgICBpZiAobGV2ZWwgJiYgKGNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSyAmJiBsZXZlbC5oYXNBdWRpb0dyb3VwKGNvbnRleHQuZ3JvdXBJZCkgfHwgY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLICYmIGxldmVsLmhhc1N1YnRpdGxlR3JvdXAoY29udGV4dC5ncm91cElkKSkpIHtcbiAgICAgICAgICAgIC8vIFBlcmZvcm0gUGF0aHdheSBzd2l0Y2ggb3IgUmVkdW5kYW50IGZhaWxvdmVyIGlmIHBvc3NpYmxlIGZvciBmYXN0ZXN0IHJlY292ZXJ5XG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgYWxsb3cgcGxheWxpc3QgcmV0cnkgY291bnQgdG8gcmVhY2ggbWF4IGVycm9yIHJldHJpZXNcbiAgICAgICAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSB0aGlzLmdldFBsYXlsaXN0UmV0cnlPclN3aXRjaEFjdGlvbihkYXRhLCBobHMubG9hZExldmVsKTtcbiAgICAgICAgICAgIGRhdGEuZXJyb3JBY3Rpb24uYWN0aW9uID0gTmV0d29ya0Vycm9yQWN0aW9uLlNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3g7XG4gICAgICAgICAgICBkYXRhLmVycm9yQWN0aW9uLmZsYWdzID0gRXJyb3JBY3Rpb25GbGFncy5Nb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nSG9zdDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9TVEFUVVNfT1VUUFVUX1JFU1RSSUNURUQ6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBsZXZlbCA9IGhscy5sb2FkTGV2ZWxPYmo7XG4gICAgICAgICAgY29uc3QgcmVzdHJpY3RlZEhkY3BMZXZlbCA9IGxldmVsID09IG51bGwgPyB2b2lkIDAgOiBsZXZlbC5hdHRyc1snSERDUC1MRVZFTCddO1xuICAgICAgICAgIGlmIChyZXN0cmljdGVkSGRjcExldmVsKSB7XG4gICAgICAgICAgICBkYXRhLmVycm9yQWN0aW9uID0ge1xuICAgICAgICAgICAgICBhY3Rpb246IE5ldHdvcmtFcnJvckFjdGlvbi5TZW5kQWx0ZXJuYXRlVG9QZW5hbHR5Qm94LFxuICAgICAgICAgICAgICBmbGFnczogRXJyb3JBY3Rpb25GbGFncy5Nb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nSERDUCxcbiAgICAgICAgICAgICAgaGRjcExldmVsOiByZXN0cmljdGVkSGRjcExldmVsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmtleVN5c3RlbUVycm9yKGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfQUREX0NPREVDX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuUkVNVVhfQUxMT0NfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5EX0VSUk9SOlxuICAgICAgICAvLyBCdWZmZXItY29udHJvbGxlciBjYW4gc2V0IGVycm9yQWN0aW9uIHdoZW4gYXBwZW5kIGVycm9ycyBjYW4gYmUgaWdub3JlZCBvciByZXNvbHZlZCBsb2NhbGx5XG4gICAgICAgIGlmICghZGF0YS5lcnJvckFjdGlvbikge1xuICAgICAgICAgIHZhciBfZGF0YSRsZXZlbDtcbiAgICAgICAgICBkYXRhLmVycm9yQWN0aW9uID0gdGhpcy5nZXRMZXZlbFN3aXRjaEFjdGlvbihkYXRhLCAoX2RhdGEkbGV2ZWwgPSBkYXRhLmxldmVsKSAhPSBudWxsID8gX2RhdGEkbGV2ZWwgOiBobHMubG9hZExldmVsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5JTlRFUk5BTF9FWENFUFRJT046XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5ESU5HX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0ZVTExfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9TV0lUQ0hfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfU1RBTExFRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9TRUVLX09WRVJfSE9MRTpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9OVURHRV9PTl9TVEFMTDpcbiAgICAgICAgZGF0YS5lcnJvckFjdGlvbiA9IGNyZWF0ZURvTm90aGluZ0Vycm9yQWN0aW9uKCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRhdGEudHlwZSA9PT0gRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SKSB7XG4gICAgICB0aGlzLmtleVN5c3RlbUVycm9yKGRhdGEpO1xuICAgIH1cbiAgfVxuICBrZXlTeXN0ZW1FcnJvcihkYXRhKSB7XG4gICAgY29uc3QgbGV2ZWxJbmRleCA9IHRoaXMuZ2V0VmFyaWFudExldmVsSW5kZXgoZGF0YS5mcmFnKTtcbiAgICAvLyBEbyBub3QgcmV0cnkgbGV2ZWwuIEVzY2FsYXRlIHRvIGZhdGFsIGlmIHN3aXRjaGluZyBsZXZlbHMgZmFpbHMuXG4gICAgZGF0YS5sZXZlbFJldHJ5ID0gZmFsc2U7XG4gICAgZGF0YS5lcnJvckFjdGlvbiA9IHRoaXMuZ2V0TGV2ZWxTd2l0Y2hBY3Rpb24oZGF0YSwgbGV2ZWxJbmRleCk7XG4gIH1cbiAgZ2V0UGxheWxpc3RSZXRyeU9yU3dpdGNoQWN0aW9uKGRhdGEsIGxldmVsSW5kZXgpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBjb25zdCByZXRyeUNvbmZpZyA9IGdldFJldHJ5Q29uZmlnKGhscy5jb25maWcucGxheWxpc3RMb2FkUG9saWN5LCBkYXRhKTtcbiAgICBjb25zdCByZXRyeUNvdW50ID0gdGhpcy5wbGF5bGlzdEVycm9yKys7XG4gICAgY29uc3QgcmV0cnkgPSBzaG91bGRSZXRyeShyZXRyeUNvbmZpZywgcmV0cnlDb3VudCwgaXNUaW1lb3V0RXJyb3IoZGF0YSksIGRhdGEucmVzcG9uc2UpO1xuICAgIGlmIChyZXRyeSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWN0aW9uOiBOZXR3b3JrRXJyb3JBY3Rpb24uUmV0cnlSZXF1ZXN0LFxuICAgICAgICBmbGFnczogRXJyb3JBY3Rpb25GbGFncy5Ob25lLFxuICAgICAgICByZXRyeUNvbmZpZyxcbiAgICAgICAgcmV0cnlDb3VudFxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgZXJyb3JBY3Rpb24gPSB0aGlzLmdldExldmVsU3dpdGNoQWN0aW9uKGRhdGEsIGxldmVsSW5kZXgpO1xuICAgIGlmIChyZXRyeUNvbmZpZykge1xuICAgICAgZXJyb3JBY3Rpb24ucmV0cnlDb25maWcgPSByZXRyeUNvbmZpZztcbiAgICAgIGVycm9yQWN0aW9uLnJldHJ5Q291bnQgPSByZXRyeUNvdW50O1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JBY3Rpb247XG4gIH1cbiAgZ2V0RnJhZ1JldHJ5T3JTd2l0Y2hBY3Rpb24oZGF0YSkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIC8vIFNoYXJlIGZyYWdtZW50IGVycm9yIGNvdW50IGFjY3Jvc3MgbWVkaWEgb3B0aW9ucyAobWFpbiwgYXVkaW8sIHN1YnMpXG4gICAgLy8gVGhpcyBhbGxvd3MgZm9yIGxldmVsIGJhc2VkIHJlbmRpdGlvbiBzd2l0Y2hpbmcgd2hlbiBtZWRpYSBvcHRpb24gYXNzZXRzIGZhaWxcbiAgICBjb25zdCB2YXJpYW50TGV2ZWxJbmRleCA9IHRoaXMuZ2V0VmFyaWFudExldmVsSW5kZXgoZGF0YS5mcmFnKTtcbiAgICBjb25zdCBsZXZlbCA9IGhscy5sZXZlbHNbdmFyaWFudExldmVsSW5kZXhdO1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWdMb2FkUG9saWN5LFxuICAgICAga2V5TG9hZFBvbGljeVxuICAgIH0gPSBobHMuY29uZmlnO1xuICAgIGNvbnN0IHJldHJ5Q29uZmlnID0gZ2V0UmV0cnlDb25maWcoZGF0YS5kZXRhaWxzLnN0YXJ0c1dpdGgoJ2tleScpID8ga2V5TG9hZFBvbGljeSA6IGZyYWdMb2FkUG9saWN5LCBkYXRhKTtcbiAgICBjb25zdCBmcmFnbWVudEVycm9ycyA9IGhscy5sZXZlbHMucmVkdWNlKChhY2MsIGxldmVsKSA9PiBhY2MgKyBsZXZlbC5mcmFnbWVudEVycm9yLCAwKTtcbiAgICAvLyBTd2l0Y2ggbGV2ZWxzIHdoZW4gb3V0IG9mIHJldHJpZWQgb3IgbGV2ZWwgaW5kZXggb3V0IG9mIGJvdW5kc1xuICAgIGlmIChsZXZlbCkge1xuICAgICAgaWYgKGRhdGEuZGV0YWlscyAhPT0gRXJyb3JEZXRhaWxzLkZSQUdfR0FQKSB7XG4gICAgICAgIGxldmVsLmZyYWdtZW50RXJyb3IrKztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJldHJ5ID0gc2hvdWxkUmV0cnkocmV0cnlDb25maWcsIGZyYWdtZW50RXJyb3JzLCBpc1RpbWVvdXRFcnJvcihkYXRhKSwgZGF0YS5yZXNwb25zZSk7XG4gICAgICBpZiAocmV0cnkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhY3Rpb246IE5ldHdvcmtFcnJvckFjdGlvbi5SZXRyeVJlcXVlc3QsXG4gICAgICAgICAgZmxhZ3M6IEVycm9yQWN0aW9uRmxhZ3MuTm9uZSxcbiAgICAgICAgICByZXRyeUNvbmZpZyxcbiAgICAgICAgICByZXRyeUNvdW50OiBmcmFnbWVudEVycm9yc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZWFjaCBtYXggcmV0cnkgY291bnQsIG9yIE1pc3NpbmcgbGV2ZWwgcmVmZXJlbmNlXG4gICAgLy8gU3dpdGNoIHRvIHZhbGlkIGluZGV4XG4gICAgY29uc3QgZXJyb3JBY3Rpb24gPSB0aGlzLmdldExldmVsU3dpdGNoQWN0aW9uKGRhdGEsIHZhcmlhbnRMZXZlbEluZGV4KTtcbiAgICAvLyBBZGQgcmV0cnkgZGV0YWlscyB0byBhbGxvdyBza2lwcGluZyBvZiBGUkFHX1BBUlNJTkdfRVJST1JcbiAgICBpZiAocmV0cnlDb25maWcpIHtcbiAgICAgIGVycm9yQWN0aW9uLnJldHJ5Q29uZmlnID0gcmV0cnlDb25maWc7XG4gICAgICBlcnJvckFjdGlvbi5yZXRyeUNvdW50ID0gZnJhZ21lbnRFcnJvcnM7XG4gICAgfVxuICAgIHJldHVybiBlcnJvckFjdGlvbjtcbiAgfVxuICBnZXRMZXZlbFN3aXRjaEFjdGlvbihkYXRhLCBsZXZlbEluZGV4KSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgaWYgKGxldmVsSW5kZXggPT09IG51bGwgfHwgbGV2ZWxJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXZlbEluZGV4ID0gaGxzLmxvYWRMZXZlbDtcbiAgICB9XG4gICAgY29uc3QgbGV2ZWwgPSB0aGlzLmhscy5sZXZlbHNbbGV2ZWxJbmRleF07XG4gICAgaWYgKGxldmVsKSB7XG4gICAgICB2YXIgX2RhdGEkZnJhZzIsIF9kYXRhJGNvbnRleHQyO1xuICAgICAgY29uc3QgZXJyb3JEZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuICAgICAgbGV2ZWwubG9hZEVycm9yKys7XG4gICAgICBpZiAoZXJyb3JEZXRhaWxzID09PSBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORF9FUlJPUikge1xuICAgICAgICBsZXZlbC5mcmFnbWVudEVycm9yKys7XG4gICAgICB9XG4gICAgICAvLyBTZWFyY2ggZm9yIG5leHQgbGV2ZWwgdG8gcmV0cnlcbiAgICAgIGxldCBuZXh0TGV2ZWwgPSAtMTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGV2ZWxzLFxuICAgICAgICBsb2FkTGV2ZWwsXG4gICAgICAgIG1pbkF1dG9MZXZlbCxcbiAgICAgICAgbWF4QXV0b0xldmVsXG4gICAgICB9ID0gaGxzO1xuICAgICAgaWYgKCFobHMuYXV0b0xldmVsRW5hYmxlZCAmJiAhaGxzLmNvbmZpZy5wcmVzZXJ2ZU1hbnVhbExldmVsT25FcnJvcikge1xuICAgICAgICBobHMubG9hZExldmVsID0gLTE7XG4gICAgICB9XG4gICAgICBjb25zdCBmcmFnRXJyb3JUeXBlID0gKF9kYXRhJGZyYWcyID0gZGF0YS5mcmFnKSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGEkZnJhZzIudHlwZTtcbiAgICAgIC8vIEZpbmQgYWx0ZXJuYXRlIGF1ZGlvIGNvZGVjIGlmIGF2YWlsYWJsZSBvbiBhdWRpbyBjb2RlYyBlcnJvclxuICAgICAgY29uc3QgaXNBdWRpb0NvZGVjRXJyb3IgPSBmcmFnRXJyb3JUeXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5BVURJTyAmJiBlcnJvckRldGFpbHMgPT09IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IgfHwgZGF0YS5zb3VyY2VCdWZmZXJOYW1lID09PSAnYXVkaW8nICYmIChlcnJvckRldGFpbHMgPT09IEVycm9yRGV0YWlscy5CVUZGRVJfQUREX0NPREVDX0VSUk9SIHx8IGVycm9yRGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRfRVJST1IpO1xuICAgICAgY29uc3QgZmluZEF1ZGlvQ29kZWNBbHRlcm5hdGUgPSBpc0F1ZGlvQ29kZWNFcnJvciAmJiBsZXZlbHMuc29tZSgoe1xuICAgICAgICBhdWRpb0NvZGVjXG4gICAgICB9KSA9PiBsZXZlbC5hdWRpb0NvZGVjICE9PSBhdWRpb0NvZGVjKTtcbiAgICAgIC8vIEZpbmQgYWx0ZXJuYXRlIHZpZGVvIGNvZGVjIGlmIGF2YWlsYWJsZSBvbiB2aWRlbyBjb2RlYyBlcnJvclxuICAgICAgY29uc3QgaXNWaWRlb0NvZGVjRXJyb3IgPSBkYXRhLnNvdXJjZUJ1ZmZlck5hbWUgPT09ICd2aWRlbycgJiYgKGVycm9yRGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLkJVRkZFUl9BRERfQ09ERUNfRVJST1IgfHwgZXJyb3JEZXRhaWxzID09PSBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORF9FUlJPUik7XG4gICAgICBjb25zdCBmaW5kVmlkZW9Db2RlY0FsdGVybmF0ZSA9IGlzVmlkZW9Db2RlY0Vycm9yICYmIGxldmVscy5zb21lKCh7XG4gICAgICAgIGNvZGVjU2V0LFxuICAgICAgICBhdWRpb0NvZGVjXG4gICAgICB9KSA9PiBsZXZlbC5jb2RlY1NldCAhPT0gY29kZWNTZXQgJiYgbGV2ZWwuYXVkaW9Db2RlYyA9PT0gYXVkaW9Db2RlYyk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHR5cGU6IHBsYXlsaXN0RXJyb3JUeXBlLFxuICAgICAgICBncm91cElkOiBwbGF5bGlzdEVycm9yR3JvdXBJZFxuICAgICAgfSA9IChfZGF0YSRjb250ZXh0MiA9IGRhdGEuY29udGV4dCkgIT0gbnVsbCA/IF9kYXRhJGNvbnRleHQyIDoge307XG4gICAgICBmb3IgKGxldCBpID0gbGV2ZWxzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSAoaSArIGxvYWRMZXZlbCkgJSBsZXZlbHMubGVuZ3RoO1xuICAgICAgICBpZiAoY2FuZGlkYXRlICE9PSBsb2FkTGV2ZWwgJiYgY2FuZGlkYXRlID49IG1pbkF1dG9MZXZlbCAmJiBjYW5kaWRhdGUgPD0gbWF4QXV0b0xldmVsICYmIGxldmVsc1tjYW5kaWRhdGVdLmxvYWRFcnJvciA9PT0gMCkge1xuICAgICAgICAgIHZhciBfbGV2ZWwkYXVkaW9Hcm91cHMsIF9sZXZlbCRzdWJ0aXRsZUdyb3VwcztcbiAgICAgICAgICBjb25zdCBsZXZlbENhbmRpZGF0ZSA9IGxldmVsc1tjYW5kaWRhdGVdO1xuICAgICAgICAgIC8vIFNraXAgbGV2ZWwgc3dpdGNoIGlmIEdBUCB0YWcgaXMgZm91bmQgaW4gbmV4dCBsZXZlbCBhdCBzYW1lIHBvc2l0aW9uXG4gICAgICAgICAgaWYgKGVycm9yRGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLkZSQUdfR0FQICYmIGZyYWdFcnJvclR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4gJiYgZGF0YS5mcmFnKSB7XG4gICAgICAgICAgICBjb25zdCBsZXZlbERldGFpbHMgPSBsZXZlbHNbY2FuZGlkYXRlXS5kZXRhaWxzO1xuICAgICAgICAgICAgaWYgKGxldmVsRGV0YWlscykge1xuICAgICAgICAgICAgICBjb25zdCBmcmFnQ2FuZGlkYXRlID0gZmluZEZyYWdtZW50QnlQVFMoZGF0YS5mcmFnLCBsZXZlbERldGFpbHMuZnJhZ21lbnRzLCBkYXRhLmZyYWcuc3RhcnQpO1xuICAgICAgICAgICAgICBpZiAoZnJhZ0NhbmRpZGF0ZSAhPSBudWxsICYmIGZyYWdDYW5kaWRhdGUuZ2FwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHBsYXlsaXN0RXJyb3JUeXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLkFVRElPX1RSQUNLICYmIGxldmVsQ2FuZGlkYXRlLmhhc0F1ZGlvR3JvdXAocGxheWxpc3RFcnJvckdyb3VwSWQpIHx8IHBsYXlsaXN0RXJyb3JUeXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLICYmIGxldmVsQ2FuZGlkYXRlLmhhc1N1YnRpdGxlR3JvdXAocGxheWxpc3RFcnJvckdyb3VwSWQpKSB7XG4gICAgICAgICAgICAvLyBGb3IgYXVkaW8vc3VicyBwbGF5bGlzdCBlcnJvcnMgZmluZCBhbm90aGVyIGdyb3VwIElEIG9yIGZhbGx0aHJvdWdoIHRvIHJlZHVuZGFudCBmYWlsLW92ZXJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZnJhZ0Vycm9yVHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuQVVESU8gJiYgKF9sZXZlbCRhdWRpb0dyb3VwcyA9IGxldmVsLmF1ZGlvR3JvdXBzKSAhPSBudWxsICYmIF9sZXZlbCRhdWRpb0dyb3Vwcy5zb21lKGdyb3VwSWQgPT4gbGV2ZWxDYW5kaWRhdGUuaGFzQXVkaW9Hcm91cChncm91cElkKSkgfHwgZnJhZ0Vycm9yVHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuU1VCVElUTEUgJiYgKF9sZXZlbCRzdWJ0aXRsZUdyb3VwcyA9IGxldmVsLnN1YnRpdGxlR3JvdXBzKSAhPSBudWxsICYmIF9sZXZlbCRzdWJ0aXRsZUdyb3Vwcy5zb21lKGdyb3VwSWQgPT4gbGV2ZWxDYW5kaWRhdGUuaGFzU3VidGl0bGVHcm91cChncm91cElkKSkgfHwgZmluZEF1ZGlvQ29kZWNBbHRlcm5hdGUgJiYgbGV2ZWwuYXVkaW9Db2RlYyA9PT0gbGV2ZWxDYW5kaWRhdGUuYXVkaW9Db2RlYyB8fCAhZmluZEF1ZGlvQ29kZWNBbHRlcm5hdGUgJiYgbGV2ZWwuYXVkaW9Db2RlYyAhPT0gbGV2ZWxDYW5kaWRhdGUuYXVkaW9Db2RlYyB8fCBmaW5kVmlkZW9Db2RlY0FsdGVybmF0ZSAmJiBsZXZlbC5jb2RlY1NldCA9PT0gbGV2ZWxDYW5kaWRhdGUuY29kZWNTZXQpIHtcbiAgICAgICAgICAgIC8vIEZvciB2aWRlby9hdWRpby9zdWJzIGZyYWcgZXJyb3JzIGZpbmQgYW5vdGhlciBncm91cCBJRCBvciBmYWxsdGhyb3VnaCB0byByZWR1bmRhbnQgZmFpbC1vdmVyXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dExldmVsID0gY2FuZGlkYXRlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobmV4dExldmVsID4gLTEgJiYgaGxzLmxvYWRMZXZlbCAhPT0gbmV4dExldmVsKSB7XG4gICAgICAgIGRhdGEubGV2ZWxSZXRyeSA9IHRydWU7XG4gICAgICAgIHRoaXMucGxheWxpc3RFcnJvciA9IDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYWN0aW9uOiBOZXR3b3JrRXJyb3JBY3Rpb24uU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveCxcbiAgICAgICAgICBmbGFnczogRXJyb3JBY3Rpb25GbGFncy5Ob25lLFxuICAgICAgICAgIG5leHRBdXRvTGV2ZWw6IG5leHRMZXZlbFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBObyBsZXZlbHMgdG8gc3dpdGNoIC8gTWFudWFsIGxldmVsIHNlbGVjdGlvbiAvIExldmVsIG5vdCBmb3VuZFxuICAgIC8vIFJlc29sdmUgd2l0aCBQYXRod2F5IHN3aXRjaCwgUmVkdW5kYW50IGZhaWwtb3Zlciwgb3Igc3RheSBvbiBsb3dlc3QgTGV2ZWxcbiAgICByZXR1cm4ge1xuICAgICAgYWN0aW9uOiBOZXR3b3JrRXJyb3JBY3Rpb24uU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveCxcbiAgICAgIGZsYWdzOiBFcnJvckFjdGlvbkZsYWdzLk1vdmVBbGxBbHRlcm5hdGVzTWF0Y2hpbmdIb3N0XG4gICAgfTtcbiAgfVxuICBvbkVycm9yT3V0KGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF9kYXRhJGVycm9yQWN0aW9uO1xuICAgIHN3aXRjaCAoKF9kYXRhJGVycm9yQWN0aW9uID0gZGF0YS5lcnJvckFjdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhJGVycm9yQWN0aW9uLmFjdGlvbikge1xuICAgICAgY2FzZSBOZXR3b3JrRXJyb3JBY3Rpb24uRG9Ob3RoaW5nOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTmV0d29ya0Vycm9yQWN0aW9uLlNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3g6XG4gICAgICAgIHRoaXMuc2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveChkYXRhKTtcbiAgICAgICAgaWYgKCFkYXRhLmVycm9yQWN0aW9uLnJlc29sdmVkICYmIGRhdGEuZGV0YWlscyAhPT0gRXJyb3JEZXRhaWxzLkZSQUdfR0FQKSB7XG4gICAgICAgICAgZGF0YS5mYXRhbCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoL01lZGlhU291cmNlIHJlYWR5U3RhdGU6IGVuZGVkLy50ZXN0KGRhdGEuZXJyb3IubWVzc2FnZSkpIHtcbiAgICAgICAgICB0aGlzLndhcm4oYE1lZGlhU291cmNlIGVuZGVkIGFmdGVyIFwiJHtkYXRhLnNvdXJjZUJ1ZmZlck5hbWV9XCIgc291cmNlQnVmZmVyIGFwcGVuZCBlcnJvci4gQXR0ZW1wdGluZyB0byByZWNvdmVyIGZyb20gbWVkaWEgZXJyb3IuYCk7XG4gICAgICAgICAgdGhpcy5obHMucmVjb3Zlck1lZGlhRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTmV0d29ya0Vycm9yQWN0aW9uLlJldHJ5UmVxdWVzdDpcbiAgICAgICAgLy8gaGFuZGxlZCBieSBzdHJlYW0gYW5kIHBsYXlsaXN0L2xldmVsIGNvbnRyb2xsZXJzXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoZGF0YS5mYXRhbCkge1xuICAgICAgdGhpcy5obHMuc3RvcExvYWQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgc2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveChkYXRhKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgY29uc3QgZXJyb3JBY3Rpb24gPSBkYXRhLmVycm9yQWN0aW9uO1xuICAgIGlmICghZXJyb3JBY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgZmxhZ3MsXG4gICAgICBoZGNwTGV2ZWwsXG4gICAgICBuZXh0QXV0b0xldmVsXG4gICAgfSA9IGVycm9yQWN0aW9uO1xuICAgIHN3aXRjaCAoZmxhZ3MpIHtcbiAgICAgIGNhc2UgRXJyb3JBY3Rpb25GbGFncy5Ob25lOlxuICAgICAgICB0aGlzLnN3aXRjaExldmVsKGRhdGEsIG5leHRBdXRvTGV2ZWwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXJyb3JBY3Rpb25GbGFncy5Nb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nSERDUDpcbiAgICAgICAgaWYgKGhkY3BMZXZlbCkge1xuICAgICAgICAgIGhscy5tYXhIZGNwTGV2ZWwgPSBIZGNwTGV2ZWxzW0hkY3BMZXZlbHMuaW5kZXhPZihoZGNwTGV2ZWwpIC0gMV07XG4gICAgICAgICAgZXJyb3JBY3Rpb24ucmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2FybihgUmVzdHJpY3RpbmcgcGxheWJhY2sgdG8gSERDUC1MRVZFTCBvZiBcIiR7aGxzLm1heEhkY3BMZXZlbH1cIiBvciBsb3dlcmApO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gSWYgbm90IHJlc29sdmVkIGJ5IHByZXZpb3VzIGFjdGlvbnMgdHJ5IHRvIHN3aXRjaCB0byBuZXh0IGxldmVsXG4gICAgaWYgKCFlcnJvckFjdGlvbi5yZXNvbHZlZCkge1xuICAgICAgdGhpcy5zd2l0Y2hMZXZlbChkYXRhLCBuZXh0QXV0b0xldmVsKTtcbiAgICB9XG4gIH1cbiAgc3dpdGNoTGV2ZWwoZGF0YSwgbGV2ZWxJbmRleCkge1xuICAgIGlmIChsZXZlbEluZGV4ICE9PSB1bmRlZmluZWQgJiYgZGF0YS5lcnJvckFjdGlvbikge1xuICAgICAgdGhpcy53YXJuKGBzd2l0Y2hpbmcgdG8gbGV2ZWwgJHtsZXZlbEluZGV4fSBhZnRlciAke2RhdGEuZGV0YWlsc31gKTtcbiAgICAgIHRoaXMuaGxzLm5leHRBdXRvTGV2ZWwgPSBsZXZlbEluZGV4O1xuICAgICAgZGF0YS5lcnJvckFjdGlvbi5yZXNvbHZlZCA9IHRydWU7XG4gICAgICAvLyBTdHJlYW0gY29udHJvbGxlciBpcyByZXNwb25zaWJsZSBmb3IgdGhpcyBidXQgd29uJ3Qgc3dpdGNoIG9uIGZhbHNlIHN0YXJ0XG4gICAgICB0aGlzLmhscy5uZXh0TG9hZExldmVsID0gdGhpcy5obHMubmV4dEF1dG9MZXZlbDtcbiAgICAgIGlmIChkYXRhLmRldGFpbHMgPT09IEVycm9yRGV0YWlscy5CVUZGRVJfQUREX0NPREVDX0VSUk9SICYmIGRhdGEubWltZVR5cGUgJiYgZGF0YS5zb3VyY2VCdWZmZXJOYW1lICE9PSAnYXVkaW92aWRlbycpIHtcbiAgICAgICAgY29uc3QgY29kZWMgPSBnZXRDb2RlY3NGb3JNaW1lVHlwZShkYXRhLm1pbWVUeXBlKTtcbiAgICAgICAgY29uc3QgbGV2ZWxzID0gdGhpcy5obHMubGV2ZWxzO1xuICAgICAgICBmb3IgKGxldCBpID0gbGV2ZWxzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgIGlmIChsZXZlbHNbaV1bYCR7ZGF0YS5zb3VyY2VCdWZmZXJOYW1lfUNvZGVjYF0gPT09IGNvZGVjKSB7XG4gICAgICAgICAgICB0aGlzLmhscy5yZW1vdmVMZXZlbChpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZURvTm90aGluZ0Vycm9yQWN0aW9uKHJlc29sdmVkKSB7XG4gIGNvbnN0IGVycm9yQWN0aW9uID0ge1xuICAgIGFjdGlvbjogTmV0d29ya0Vycm9yQWN0aW9uLkRvTm90aGluZyxcbiAgICBmbGFnczogRXJyb3JBY3Rpb25GbGFncy5Ob25lXG4gIH07XG4gIGlmIChyZXNvbHZlZCkge1xuICAgIGVycm9yQWN0aW9uLnJlc29sdmVkID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZXJyb3JBY3Rpb247XG59XG5cbnZhciBGcmFnbWVudFN0YXRlID0ge1xuICBOT1RfTE9BREVEOiBcIk5PVF9MT0FERURcIixcbiAgQVBQRU5ESU5HOiBcIkFQUEVORElOR1wiLFxuICBQQVJUSUFMOiBcIlBBUlRJQUxcIixcbiAgT0s6IFwiT0tcIlxufTtcbmNsYXNzIEZyYWdtZW50VHJhY2tlciB7XG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHRoaXMuYWN0aXZlUGFydExpc3RzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmVuZExpc3RGcmFnbWVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuZnJhZ21lbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnRpbWVSYW5nZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuYnVmZmVyUGFkZGluZyA9IDAuMjtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmhhc0dhcHMgPSBmYWxzZTtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLl9yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIF9yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0FQUEVOREVELCB0aGlzLm9uQnVmZmVyQXBwZW5kZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX0xPQURFRCwgdGhpcy5vbkZyYWdMb2FkZWQsIHRoaXMpO1xuICB9XG4gIF91bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9BUFBFTkRFRCwgdGhpcy5vbkJ1ZmZlckFwcGVuZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0xPQURFRCwgdGhpcy5vbkZyYWdMb2FkZWQsIHRoaXMpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fdW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmZyYWdtZW50cyA9XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuYWN0aXZlUGFydExpc3RzID1cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5lbmRMaXN0RnJhZ21lbnRzID0gdGhpcy50aW1lUmFuZ2VzID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBGcmFnbWVudCBvciBQYXJ0IHdpdGggYW4gYXBwZW5kZWQgcmFuZ2UgdGhhdCBtYXRjaGVzIHRoZSBwb3NpdGlvbiBhbmQgbGV2ZWxUeXBlXG4gICAqIE90aGVyd2lzZSwgcmV0dXJuIG51bGxcbiAgICovXG4gIGdldEFwcGVuZGVkRnJhZyhwb3NpdGlvbiwgbGV2ZWxUeXBlKSB7XG4gICAgY29uc3QgYWN0aXZlUGFydHMgPSB0aGlzLmFjdGl2ZVBhcnRMaXN0c1tsZXZlbFR5cGVdO1xuICAgIGlmIChhY3RpdmVQYXJ0cykge1xuICAgICAgZm9yIChsZXQgaSA9IGFjdGl2ZVBhcnRzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICBjb25zdCBhY3RpdmVQYXJ0ID0gYWN0aXZlUGFydHNbaV07XG4gICAgICAgIGlmICghYWN0aXZlUGFydCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwcGVuZGVkUFRTID0gYWN0aXZlUGFydC5lbmQ7XG4gICAgICAgIGlmIChhY3RpdmVQYXJ0LnN0YXJ0IDw9IHBvc2l0aW9uICYmIGFwcGVuZGVkUFRTICE9PSBudWxsICYmIHBvc2l0aW9uIDw9IGFwcGVuZGVkUFRTKSB7XG4gICAgICAgICAgcmV0dXJuIGFjdGl2ZVBhcnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyZWRGcmFnKHBvc2l0aW9uLCBsZXZlbFR5cGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGJ1ZmZlcmVkIEZyYWdtZW50IHRoYXQgbWF0Y2hlcyB0aGUgcG9zaXRpb24gYW5kIGxldmVsVHlwZS5cbiAgICogQSBidWZmZXJlZCBGcmFnbWVudCBpcyBvbmUgd2hvc2UgbG9hZGluZywgcGFyc2luZyBhbmQgYXBwZW5kaW5nIGlzIGRvbmUgKGNvbXBsZXRlZCBvciBcInBhcnRpYWxcIiBtZWFuaW5nIGFib3J0ZWQpLlxuICAgKiBJZiBub3QgZm91bmQgYW55IEZyYWdtZW50LCByZXR1cm4gbnVsbFxuICAgKi9cbiAgZ2V0QnVmZmVyZWRGcmFnKHBvc2l0aW9uLCBsZXZlbFR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRGcmFnQXRQb3MocG9zaXRpb24sIGxldmVsVHlwZSwgdHJ1ZSk7XG4gIH1cbiAgZ2V0RnJhZ0F0UG9zKHBvc2l0aW9uLCBsZXZlbFR5cGUsIGJ1ZmZlcmVkKSB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZ21lbnRzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50cyk7XG4gICAgZm9yIChsZXQgaSA9IGtleXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICBjb25zdCBmcmFnbWVudEVudGl0eSA9IGZyYWdtZW50c1trZXlzW2ldXTtcbiAgICAgIGlmICgoZnJhZ21lbnRFbnRpdHkgPT0gbnVsbCA/IHZvaWQgMCA6IGZyYWdtZW50RW50aXR5LmJvZHkudHlwZSkgPT09IGxldmVsVHlwZSAmJiAoIWJ1ZmZlcmVkIHx8IGZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkKSkge1xuICAgICAgICBjb25zdCBmcmFnID0gZnJhZ21lbnRFbnRpdHkuYm9keTtcbiAgICAgICAgaWYgKGZyYWcuc3RhcnQgPD0gcG9zaXRpb24gJiYgcG9zaXRpb24gPD0gZnJhZy5lbmQpIHtcbiAgICAgICAgICByZXR1cm4gZnJhZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJ0aWFsIGZyYWdtZW50cyBlZmZlY3RlZCBieSBjb2RlZCBmcmFtZSBldmljdGlvbiB3aWxsIGJlIHJlbW92ZWRcbiAgICogVGhlIGJyb3dzZXIgd2lsbCB1bmxvYWQgcGFydHMgb2YgdGhlIGJ1ZmZlciB0byBmcmVlIHVwIG1lbW9yeSBmb3IgbmV3IGJ1ZmZlciBkYXRhXG4gICAqIEZyYWdtZW50cyB3aWxsIG5lZWQgdG8gYmUgcmVsb2FkZWQgd2hlbiB0aGUgYnVmZmVyIGlzIGZyZWVkIHVwLCByZW1vdmluZyBwYXJ0aWFsIGZyYWdtZW50cyB3aWxsIGFsbG93IHRoZW0gdG8gcmVsb2FkKHNpbmNlIHRoZXJlIG1pZ2h0IGJlIHBhcnRzIHRoYXQgYXJlIHN0aWxsIHBsYXlhYmxlKVxuICAgKi9cbiAgZGV0ZWN0RXZpY3RlZEZyYWdtZW50cyhlbGVtZW50YXJ5U3RyZWFtLCB0aW1lUmFuZ2UsIHBsYXlsaXN0VHlwZSwgYXBwZW5kZWRQYXJ0LCByZW1vdmVBcHBlbmRpbmcpIHtcbiAgICBpZiAodGhpcy50aW1lUmFuZ2VzKSB7XG4gICAgICB0aGlzLnRpbWVSYW5nZXNbZWxlbWVudGFyeVN0cmVhbV0gPSB0aW1lUmFuZ2U7XG4gICAgfVxuICAgIC8vIENoZWNrIGlmIGFueSBmbGFnZ2VkIGZyYWdtZW50cyBoYXZlIGJlZW4gdW5sb2FkZWRcbiAgICAvLyBleGNsdWRpbmcgYW55dGhpbmcgbmV3ZXIgdGhhbiBhcHBlbmRlZFBhcnRTblxuICAgIGNvbnN0IGFwcGVuZGVkUGFydFNuID0gKGFwcGVuZGVkUGFydCA9PSBudWxsID8gdm9pZCAwIDogYXBwZW5kZWRQYXJ0LmZyYWdtZW50LnNuKSB8fCAtMTtcbiAgICBPYmplY3Qua2V5cyh0aGlzLmZyYWdtZW50cykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgY29uc3QgZnJhZ21lbnRFbnRpdHkgPSB0aGlzLmZyYWdtZW50c1trZXldO1xuICAgICAgaWYgKCFmcmFnbWVudEVudGl0eSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoYXBwZW5kZWRQYXJ0U24gPj0gZnJhZ21lbnRFbnRpdHkuYm9keS5zbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkICYmICghZnJhZ21lbnRFbnRpdHkubG9hZGVkIHx8IHJlbW92ZUFwcGVuZGluZykpIHtcbiAgICAgICAgaWYgKGZyYWdtZW50RW50aXR5LmJvZHkudHlwZSA9PT0gcGxheWxpc3RUeXBlKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVGcmFnbWVudChmcmFnbWVudEVudGl0eS5ib2R5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBlc0RhdGEgPSBmcmFnbWVudEVudGl0eS5yYW5nZVtlbGVtZW50YXJ5U3RyZWFtXTtcbiAgICAgIGlmICghZXNEYXRhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChlc0RhdGEudGltZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5yZW1vdmVGcmFnbWVudChmcmFnbWVudEVudGl0eS5ib2R5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXNEYXRhLnRpbWUuc29tZSh0aW1lID0+IHtcbiAgICAgICAgY29uc3QgaXNOb3RCdWZmZXJlZCA9ICF0aGlzLmlzVGltZUJ1ZmZlcmVkKHRpbWUuc3RhcnRQVFMsIHRpbWUuZW5kUFRTLCB0aW1lUmFuZ2UpO1xuICAgICAgICBpZiAoaXNOb3RCdWZmZXJlZCkge1xuICAgICAgICAgIC8vIFVucmVnaXN0ZXIgcGFydGlhbCBmcmFnbWVudCBhcyBpdCBuZWVkcyB0byBsb2FkIGFnYWluIHRvIGJlIHJldXNlZFxuICAgICAgICAgIHRoaXMucmVtb3ZlRnJhZ21lbnQoZnJhZ21lbnRFbnRpdHkuYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzTm90QnVmZmVyZWQ7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGZyYWdtZW50IHBhc3NlZCBpbiBpcyBsb2FkZWQgaW4gdGhlIGJ1ZmZlciBwcm9wZXJseVxuICAgKiBQYXJ0aWFsbHkgbG9hZGVkIGZyYWdtZW50cyB3aWxsIGJlIHJlZ2lzdGVyZWQgYXMgYSBwYXJ0aWFsIGZyYWdtZW50XG4gICAqL1xuICBkZXRlY3RQYXJ0aWFsRnJhZ21lbnRzKGRhdGEpIHtcbiAgICBjb25zdCB0aW1lUmFuZ2VzID0gdGhpcy50aW1lUmFuZ2VzO1xuICAgIGlmICghdGltZVJhbmdlcyB8fCBkYXRhLmZyYWcuc24gPT09ICdpbml0U2VnbWVudCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZnJhZyA9IGRhdGEuZnJhZztcbiAgICBjb25zdCBmcmFnS2V5ID0gZ2V0RnJhZ21lbnRLZXkoZnJhZyk7XG4gICAgY29uc3QgZnJhZ21lbnRFbnRpdHkgPSB0aGlzLmZyYWdtZW50c1tmcmFnS2V5XTtcbiAgICBpZiAoIWZyYWdtZW50RW50aXR5IHx8IGZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkICYmIGZyYWcuZ2FwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlzRnJhZ0hpbnQgPSAhZnJhZy5yZWx1cmw7XG4gICAgT2JqZWN0LmtleXModGltZVJhbmdlcykuZm9yRWFjaChlbGVtZW50YXJ5U3RyZWFtID0+IHtcbiAgICAgIGNvbnN0IHN0cmVhbUluZm8gPSBmcmFnLmVsZW1lbnRhcnlTdHJlYW1zW2VsZW1lbnRhcnlTdHJlYW1dO1xuICAgICAgaWYgKCFzdHJlYW1JbmZvKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRpbWVSYW5nZSA9IHRpbWVSYW5nZXNbZWxlbWVudGFyeVN0cmVhbV07XG4gICAgICBjb25zdCBwYXJ0aWFsID0gaXNGcmFnSGludCB8fCBzdHJlYW1JbmZvLnBhcnRpYWwgPT09IHRydWU7XG4gICAgICBmcmFnbWVudEVudGl0eS5yYW5nZVtlbGVtZW50YXJ5U3RyZWFtXSA9IHRoaXMuZ2V0QnVmZmVyZWRUaW1lcyhmcmFnLCBkYXRhLnBhcnQsIHBhcnRpYWwsIHRpbWVSYW5nZSk7XG4gICAgfSk7XG4gICAgZnJhZ21lbnRFbnRpdHkubG9hZGVkID0gbnVsbDtcbiAgICBpZiAoT2JqZWN0LmtleXMoZnJhZ21lbnRFbnRpdHkucmFuZ2UpLmxlbmd0aCkge1xuICAgICAgZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQgPSB0cnVlO1xuICAgICAgY29uc3QgZW5kTGlzdCA9IGZyYWdtZW50RW50aXR5LmJvZHkuZW5kTGlzdCA9IGZyYWcuZW5kTGlzdCB8fCBmcmFnbWVudEVudGl0eS5ib2R5LmVuZExpc3Q7XG4gICAgICBpZiAoZW5kTGlzdCkge1xuICAgICAgICB0aGlzLmVuZExpc3RGcmFnbWVudHNbZnJhZ21lbnRFbnRpdHkuYm9keS50eXBlXSA9IGZyYWdtZW50RW50aXR5O1xuICAgICAgfVxuICAgICAgaWYgKCFpc1BhcnRpYWwoZnJhZ21lbnRFbnRpdHkpKSB7XG4gICAgICAgIC8vIFJlbW92ZSBvbGRlciBmcmFnbWVudCBwYXJ0cyBmcm9tIGxvb2t1cCBhZnRlciBmcmFnIGlzIHRyYWNrZWQgYXMgYnVmZmVyZWRcbiAgICAgICAgdGhpcy5yZW1vdmVQYXJ0cyhmcmFnLnNuIC0gMSwgZnJhZy50eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVtb3ZlIGZyYWdtZW50IGlmIG5vdGhpbmcgd2FzIGFwcGVuZGVkXG4gICAgICB0aGlzLnJlbW92ZUZyYWdtZW50KGZyYWdtZW50RW50aXR5LmJvZHkpO1xuICAgIH1cbiAgfVxuICByZW1vdmVQYXJ0cyhzblRvS2VlcCwgbGV2ZWxUeXBlKSB7XG4gICAgY29uc3QgYWN0aXZlUGFydHMgPSB0aGlzLmFjdGl2ZVBhcnRMaXN0c1tsZXZlbFR5cGVdO1xuICAgIGlmICghYWN0aXZlUGFydHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmVQYXJ0TGlzdHNbbGV2ZWxUeXBlXSA9IGZpbHRlclBhcnRzKGFjdGl2ZVBhcnRzLCBwYXJ0ID0+IHBhcnQuZnJhZ21lbnQuc24gPj0gc25Ub0tlZXApO1xuICB9XG4gIGZyYWdCdWZmZXJlZChmcmFnLCBmb3JjZSkge1xuICAgIGNvbnN0IGZyYWdLZXkgPSBnZXRGcmFnbWVudEtleShmcmFnKTtcbiAgICBsZXQgZnJhZ21lbnRFbnRpdHkgPSB0aGlzLmZyYWdtZW50c1tmcmFnS2V5XTtcbiAgICBpZiAoIWZyYWdtZW50RW50aXR5ICYmIGZvcmNlKSB7XG4gICAgICBmcmFnbWVudEVudGl0eSA9IHRoaXMuZnJhZ21lbnRzW2ZyYWdLZXldID0ge1xuICAgICAgICBib2R5OiBmcmFnLFxuICAgICAgICBhcHBlbmRlZFBUUzogbnVsbCxcbiAgICAgICAgbG9hZGVkOiBudWxsLFxuICAgICAgICBidWZmZXJlZDogZmFsc2UsXG4gICAgICAgIHJhbmdlOiBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgICB9O1xuICAgICAgaWYgKGZyYWcuZ2FwKSB7XG4gICAgICAgIHRoaXMuaGFzR2FwcyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmcmFnbWVudEVudGl0eSkge1xuICAgICAgZnJhZ21lbnRFbnRpdHkubG9hZGVkID0gbnVsbDtcbiAgICAgIGZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgZ2V0QnVmZmVyZWRUaW1lcyhmcmFnbWVudCwgcGFydCwgcGFydGlhbCwgdGltZVJhbmdlKSB7XG4gICAgY29uc3QgYnVmZmVyZWQgPSB7XG4gICAgICB0aW1lOiBbXSxcbiAgICAgIHBhcnRpYWxcbiAgICB9O1xuICAgIGNvbnN0IHN0YXJ0UFRTID0gZnJhZ21lbnQuc3RhcnQ7XG4gICAgY29uc3QgZW5kUFRTID0gZnJhZ21lbnQuZW5kO1xuICAgIGNvbnN0IG1pbkVuZFBUUyA9IGZyYWdtZW50Lm1pbkVuZFBUUyB8fCBlbmRQVFM7XG4gICAgY29uc3QgbWF4U3RhcnRQVFMgPSBmcmFnbWVudC5tYXhTdGFydFBUUyB8fCBzdGFydFBUUztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRpbWVSYW5nZS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gdGltZVJhbmdlLnN0YXJ0KGkpIC0gdGhpcy5idWZmZXJQYWRkaW5nO1xuICAgICAgY29uc3QgZW5kVGltZSA9IHRpbWVSYW5nZS5lbmQoaSkgKyB0aGlzLmJ1ZmZlclBhZGRpbmc7XG4gICAgICBpZiAobWF4U3RhcnRQVFMgPj0gc3RhcnRUaW1lICYmIG1pbkVuZFBUUyA8PSBlbmRUaW1lKSB7XG4gICAgICAgIC8vIEZyYWdtZW50IGlzIGVudGlyZWx5IGNvbnRhaW5lZCBpbiBidWZmZXJcbiAgICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayB0aGUgb3RoZXIgdGltZVJhbmdlIHRpbWVzIHNpbmNlIGl0J3MgY29tcGxldGVseSBwbGF5YWJsZVxuICAgICAgICBidWZmZXJlZC50aW1lLnB1c2goe1xuICAgICAgICAgIHN0YXJ0UFRTOiBNYXRoLm1heChzdGFydFBUUywgdGltZVJhbmdlLnN0YXJ0KGkpKSxcbiAgICAgICAgICBlbmRQVFM6IE1hdGgubWluKGVuZFBUUywgdGltZVJhbmdlLmVuZChpKSlcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChzdGFydFBUUyA8IGVuZFRpbWUgJiYgZW5kUFRTID4gc3RhcnRUaW1lKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoc3RhcnRQVFMsIHRpbWVSYW5nZS5zdGFydChpKSk7XG4gICAgICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKGVuZFBUUywgdGltZVJhbmdlLmVuZChpKSk7XG4gICAgICAgIGlmIChlbmQgPiBzdGFydCkge1xuICAgICAgICAgIGJ1ZmZlcmVkLnBhcnRpYWwgPSB0cnVlO1xuICAgICAgICAgIC8vIENoZWNrIGZvciBpbnRlcnNlY3Rpb24gd2l0aCBidWZmZXJcbiAgICAgICAgICAvLyBHZXQgcGxheWFibGUgc2VjdGlvbnMgb2YgdGhlIGZyYWdtZW50XG4gICAgICAgICAgYnVmZmVyZWQudGltZS5wdXNoKHtcbiAgICAgICAgICAgIHN0YXJ0UFRTOiBzdGFydCxcbiAgICAgICAgICAgIGVuZFBUUzogZW5kXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZW5kUFRTIDw9IHN0YXJ0VGltZSkge1xuICAgICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIHRoZSByZXN0IG9mIHRoZSB0aW1lUmFuZ2UgYXMgaXQgaXMgaW4gb3JkZXJcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBidWZmZXJlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBwYXJ0aWFsIGZyYWdtZW50IGZvciBhIGNlcnRhaW4gdGltZVxuICAgKi9cbiAgZ2V0UGFydGlhbEZyYWdtZW50KHRpbWUpIHtcbiAgICBsZXQgYmVzdEZyYWdtZW50ID0gbnVsbDtcbiAgICBsZXQgdGltZVBhZGRpbmc7XG4gICAgbGV0IHN0YXJ0VGltZTtcbiAgICBsZXQgZW5kVGltZTtcbiAgICBsZXQgYmVzdE92ZXJsYXAgPSAwO1xuICAgIGNvbnN0IHtcbiAgICAgIGJ1ZmZlclBhZGRpbmcsXG4gICAgICBmcmFnbWVudHNcbiAgICB9ID0gdGhpcztcbiAgICBPYmplY3Qua2V5cyhmcmFnbWVudHMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGNvbnN0IGZyYWdtZW50RW50aXR5ID0gZnJhZ21lbnRzW2tleV07XG4gICAgICBpZiAoIWZyYWdtZW50RW50aXR5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc1BhcnRpYWwoZnJhZ21lbnRFbnRpdHkpKSB7XG4gICAgICAgIHN0YXJ0VGltZSA9IGZyYWdtZW50RW50aXR5LmJvZHkuc3RhcnQgLSBidWZmZXJQYWRkaW5nO1xuICAgICAgICBlbmRUaW1lID0gZnJhZ21lbnRFbnRpdHkuYm9keS5lbmQgKyBidWZmZXJQYWRkaW5nO1xuICAgICAgICBpZiAodGltZSA+PSBzdGFydFRpbWUgJiYgdGltZSA8PSBlbmRUaW1lKSB7XG4gICAgICAgICAgLy8gVXNlIHRoZSBmcmFnbWVudCB0aGF0IGhhcyB0aGUgbW9zdCBwYWRkaW5nIGZyb20gc3RhcnQgYW5kIGVuZCB0aW1lXG4gICAgICAgICAgdGltZVBhZGRpbmcgPSBNYXRoLm1pbih0aW1lIC0gc3RhcnRUaW1lLCBlbmRUaW1lIC0gdGltZSk7XG4gICAgICAgICAgaWYgKGJlc3RPdmVybGFwIDw9IHRpbWVQYWRkaW5nKSB7XG4gICAgICAgICAgICBiZXN0RnJhZ21lbnQgPSBmcmFnbWVudEVudGl0eS5ib2R5O1xuICAgICAgICAgICAgYmVzdE92ZXJsYXAgPSB0aW1lUGFkZGluZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYmVzdEZyYWdtZW50O1xuICB9XG4gIGlzRW5kTGlzdEFwcGVuZGVkKHR5cGUpIHtcbiAgICBjb25zdCBsYXN0RnJhZ21lbnRFbnRpdHkgPSB0aGlzLmVuZExpc3RGcmFnbWVudHNbdHlwZV07XG4gICAgcmV0dXJuIGxhc3RGcmFnbWVudEVudGl0eSAhPT0gdW5kZWZpbmVkICYmIChsYXN0RnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQgfHwgaXNQYXJ0aWFsKGxhc3RGcmFnbWVudEVudGl0eSkpO1xuICB9XG4gIGdldFN0YXRlKGZyYWdtZW50KSB7XG4gICAgY29uc3QgZnJhZ0tleSA9IGdldEZyYWdtZW50S2V5KGZyYWdtZW50KTtcbiAgICBjb25zdCBmcmFnbWVudEVudGl0eSA9IHRoaXMuZnJhZ21lbnRzW2ZyYWdLZXldO1xuICAgIGlmIChmcmFnbWVudEVudGl0eSkge1xuICAgICAgaWYgKCFmcmFnbWVudEVudGl0eS5idWZmZXJlZCkge1xuICAgICAgICByZXR1cm4gRnJhZ21lbnRTdGF0ZS5BUFBFTkRJTkc7XG4gICAgICB9IGVsc2UgaWYgKGlzUGFydGlhbChmcmFnbWVudEVudGl0eSkpIHtcbiAgICAgICAgcmV0dXJuIEZyYWdtZW50U3RhdGUuUEFSVElBTDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBGcmFnbWVudFN0YXRlLk9LO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gRnJhZ21lbnRTdGF0ZS5OT1RfTE9BREVEO1xuICB9XG4gIGlzVGltZUJ1ZmZlcmVkKHN0YXJ0UFRTLCBlbmRQVFMsIHRpbWVSYW5nZSkge1xuICAgIGxldCBzdGFydFRpbWU7XG4gICAgbGV0IGVuZFRpbWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aW1lUmFuZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIHN0YXJ0VGltZSA9IHRpbWVSYW5nZS5zdGFydChpKSAtIHRoaXMuYnVmZmVyUGFkZGluZztcbiAgICAgIGVuZFRpbWUgPSB0aW1lUmFuZ2UuZW5kKGkpICsgdGhpcy5idWZmZXJQYWRkaW5nO1xuICAgICAgaWYgKHN0YXJ0UFRTID49IHN0YXJ0VGltZSAmJiBlbmRQVFMgPD0gZW5kVGltZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmRQVFMgPD0gc3RhcnRUaW1lKSB7XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgdGhlIHJlc3Qgb2YgdGhlIHRpbWVSYW5nZSBhcyBpdCBpcyBpbiBvcmRlclxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLnJlbW92ZUFsbEZyYWdtZW50cygpO1xuICB9XG4gIG9uRnJhZ0xvYWRlZChldmVudCwgZGF0YSkge1xuICAgIC8vIGRvbid0IHRyYWNrIGluaXRzZWdtZW50IChmb3Igd2hpY2ggc24gaXMgbm90IGEgbnVtYmVyKVxuICAgIC8vIGRvbid0IHRyYWNrIGZyYWdzIHVzZWQgZm9yIGJpdHJhdGVUZXN0LCB0aGV5J3JlIGlycmVsZXZhbnQuXG4gICAgaWYgKGRhdGEuZnJhZy5zbiA9PT0gJ2luaXRTZWdtZW50JyB8fCBkYXRhLmZyYWcuYml0cmF0ZVRlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZnJhZyA9IGRhdGEuZnJhZztcbiAgICAvLyBGcmFnbWVudCBlbnRpdHkgYGxvYWRlZGAgRnJhZ0xvYWRlZERhdGEgaXMgbnVsbCB3aGVuIGxvYWRpbmcgcGFydHNcbiAgICBjb25zdCBsb2FkZWQgPSBkYXRhLnBhcnQgPyBudWxsIDogZGF0YTtcbiAgICBjb25zdCBmcmFnS2V5ID0gZ2V0RnJhZ21lbnRLZXkoZnJhZyk7XG4gICAgdGhpcy5mcmFnbWVudHNbZnJhZ0tleV0gPSB7XG4gICAgICBib2R5OiBmcmFnLFxuICAgICAgYXBwZW5kZWRQVFM6IG51bGwsXG4gICAgICBsb2FkZWQsXG4gICAgICBidWZmZXJlZDogZmFsc2UsXG4gICAgICByYW5nZTogT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgIH07XG4gIH1cbiAgb25CdWZmZXJBcHBlbmRlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWcsXG4gICAgICBwYXJ0LFxuICAgICAgdGltZVJhbmdlcyxcbiAgICAgIHR5cGVcbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoZnJhZy5zbiA9PT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwbGF5bGlzdFR5cGUgPSBmcmFnLnR5cGU7XG4gICAgaWYgKHBhcnQpIHtcbiAgICAgIGxldCBhY3RpdmVQYXJ0cyA9IHRoaXMuYWN0aXZlUGFydExpc3RzW3BsYXlsaXN0VHlwZV07XG4gICAgICBpZiAoIWFjdGl2ZVBhcnRzKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlUGFydExpc3RzW3BsYXlsaXN0VHlwZV0gPSBhY3RpdmVQYXJ0cyA9IFtdO1xuICAgICAgfVxuICAgICAgYWN0aXZlUGFydHMucHVzaChwYXJ0KTtcbiAgICB9XG4gICAgLy8gU3RvcmUgdGhlIGxhdGVzdCB0aW1lUmFuZ2VzIGxvYWRlZCBpbiB0aGUgYnVmZmVyXG4gICAgdGhpcy50aW1lUmFuZ2VzID0gdGltZVJhbmdlcztcbiAgICBjb25zdCB0aW1lUmFuZ2UgPSB0aW1lUmFuZ2VzW3R5cGVdO1xuICAgIHRoaXMuZGV0ZWN0RXZpY3RlZEZyYWdtZW50cyh0eXBlLCB0aW1lUmFuZ2UsIHBsYXlsaXN0VHlwZSwgcGFydCk7XG4gIH1cbiAgb25GcmFnQnVmZmVyZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLmRldGVjdFBhcnRpYWxGcmFnbWVudHMoZGF0YSk7XG4gIH1cbiAgaGFzRnJhZ21lbnQoZnJhZ21lbnQpIHtcbiAgICBjb25zdCBmcmFnS2V5ID0gZ2V0RnJhZ21lbnRLZXkoZnJhZ21lbnQpO1xuICAgIHJldHVybiAhIXRoaXMuZnJhZ21lbnRzW2ZyYWdLZXldO1xuICB9XG4gIGhhc0ZyYWdtZW50cyh0eXBlKSB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZ21lbnRzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50cyk7XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICByZXR1cm4ga2V5cy5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0ga2V5cy5sZW5ndGg7IGktLTspIHtcbiAgICAgIGNvbnN0IGZyYWdtZW50RW50aXR5ID0gZnJhZ21lbnRzW2tleXNbaV1dO1xuICAgICAgaWYgKChmcmFnbWVudEVudGl0eSA9PSBudWxsID8gdm9pZCAwIDogZnJhZ21lbnRFbnRpdHkuYm9keS50eXBlKSA9PT0gdHlwZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGhhc1BhcnRzKHR5cGUpIHtcbiAgICB2YXIgX3RoaXMkYWN0aXZlUGFydExpc3RzO1xuICAgIHJldHVybiAhISgoX3RoaXMkYWN0aXZlUGFydExpc3RzID0gdGhpcy5hY3RpdmVQYXJ0TGlzdHNbdHlwZV0pICE9IG51bGwgJiYgX3RoaXMkYWN0aXZlUGFydExpc3RzLmxlbmd0aCk7XG4gIH1cbiAgcmVtb3ZlRnJhZ21lbnRzSW5SYW5nZShzdGFydCwgZW5kLCBwbGF5bGlzdFR5cGUsIHdpdGhHYXBPbmx5LCB1bmJ1ZmZlcmVkT25seSkge1xuICAgIGlmICh3aXRoR2FwT25seSAmJiAhdGhpcy5oYXNHYXBzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKHRoaXMuZnJhZ21lbnRzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBmcmFnbWVudEVudGl0eSA9IHRoaXMuZnJhZ21lbnRzW2tleV07XG4gICAgICBpZiAoIWZyYWdtZW50RW50aXR5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZyYWcgPSBmcmFnbWVudEVudGl0eS5ib2R5O1xuICAgICAgaWYgKGZyYWcudHlwZSAhPT0gcGxheWxpc3RUeXBlIHx8IHdpdGhHYXBPbmx5ICYmICFmcmFnLmdhcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZnJhZy5zdGFydCA8IGVuZCAmJiBmcmFnLmVuZCA+IHN0YXJ0ICYmIChmcmFnbWVudEVudGl0eS5idWZmZXJlZCB8fCB1bmJ1ZmZlcmVkT25seSkpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZW1vdmVGcmFnbWVudChmcmFnbWVudCkge1xuICAgIGNvbnN0IGZyYWdLZXkgPSBnZXRGcmFnbWVudEtleShmcmFnbWVudCk7XG4gICAgZnJhZ21lbnQuY2xlYXJFbGVtZW50YXJ5U3RyZWFtSW5mbygpO1xuICAgIGNvbnN0IGFjdGl2ZVBhcnRzID0gdGhpcy5hY3RpdmVQYXJ0TGlzdHNbZnJhZ21lbnQudHlwZV07XG4gICAgaWYgKGFjdGl2ZVBhcnRzKSB7XG4gICAgICBjb25zdCBzblRvUmVtb3ZlID0gZnJhZ21lbnQuc247XG4gICAgICB0aGlzLmFjdGl2ZVBhcnRMaXN0c1tmcmFnbWVudC50eXBlXSA9IGZpbHRlclBhcnRzKGFjdGl2ZVBhcnRzLCBwYXJ0ID0+IHBhcnQuZnJhZ21lbnQuc24gIT09IHNuVG9SZW1vdmUpO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5mcmFnbWVudHNbZnJhZ0tleV07XG4gICAgaWYgKGZyYWdtZW50LmVuZExpc3QpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmVuZExpc3RGcmFnbWVudHNbZnJhZ21lbnQudHlwZV07XG4gICAgfVxuICB9XG4gIHJlbW92ZUFsbEZyYWdtZW50cygpIHtcbiAgICB2YXIgX3RoaXMkaGxzLCBfdGhpcyRobHMkbGF0ZXN0TGV2ZWw7XG4gICAgdGhpcy5mcmFnbWVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuZW5kTGlzdEZyYWdtZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5hY3RpdmVQYXJ0TGlzdHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuaGFzR2FwcyA9IGZhbHNlO1xuICAgIGNvbnN0IHBhcnRsaXN0ID0gKF90aGlzJGhscyA9IHRoaXMuaGxzKSA9PSBudWxsID8gdm9pZCAwIDogKF90aGlzJGhscyRsYXRlc3RMZXZlbCA9IF90aGlzJGhscy5sYXRlc3RMZXZlbERldGFpbHMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRobHMkbGF0ZXN0TGV2ZWwucGFydExpc3Q7XG4gICAgaWYgKHBhcnRsaXN0KSB7XG4gICAgICBwYXJ0bGlzdC5mb3JFYWNoKHBhcnQgPT4gcGFydC5jbGVhckVsZW1lbnRhcnlTdHJlYW1JbmZvKCkpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaXNQYXJ0aWFsKGZyYWdtZW50RW50aXR5KSB7XG4gIHZhciBfZnJhZ21lbnRFbnRpdHkkcmFuZ2UsIF9mcmFnbWVudEVudGl0eSRyYW5nZTIsIF9mcmFnbWVudEVudGl0eSRyYW5nZTM7XG4gIHJldHVybiBmcmFnbWVudEVudGl0eS5idWZmZXJlZCAmJiAoZnJhZ21lbnRFbnRpdHkuYm9keS5nYXAgfHwgKChfZnJhZ21lbnRFbnRpdHkkcmFuZ2UgPSBmcmFnbWVudEVudGl0eS5yYW5nZS52aWRlbykgPT0gbnVsbCA/IHZvaWQgMCA6IF9mcmFnbWVudEVudGl0eSRyYW5nZS5wYXJ0aWFsKSB8fCAoKF9mcmFnbWVudEVudGl0eSRyYW5nZTIgPSBmcmFnbWVudEVudGl0eS5yYW5nZS5hdWRpbykgPT0gbnVsbCA/IHZvaWQgMCA6IF9mcmFnbWVudEVudGl0eSRyYW5nZTIucGFydGlhbCkgfHwgKChfZnJhZ21lbnRFbnRpdHkkcmFuZ2UzID0gZnJhZ21lbnRFbnRpdHkucmFuZ2UuYXVkaW92aWRlbykgPT0gbnVsbCA/IHZvaWQgMCA6IF9mcmFnbWVudEVudGl0eSRyYW5nZTMucGFydGlhbCkpO1xufVxuZnVuY3Rpb24gZ2V0RnJhZ21lbnRLZXkoZnJhZ21lbnQpIHtcbiAgcmV0dXJuIGAke2ZyYWdtZW50LnR5cGV9XyR7ZnJhZ21lbnQubGV2ZWx9XyR7ZnJhZ21lbnQuc259YDtcbn1cbmZ1bmN0aW9uIGZpbHRlclBhcnRzKHBhcnRMaXN0LCBwcmVkaWNhdGUpIHtcbiAgcmV0dXJuIHBhcnRMaXN0LmZpbHRlcihwYXJ0ID0+IHtcbiAgICBjb25zdCBrZWVwID0gcHJlZGljYXRlKHBhcnQpO1xuICAgIGlmICgha2VlcCkge1xuICAgICAgcGFydC5jbGVhckVsZW1lbnRhcnlTdHJlYW1JbmZvKCk7XG4gICAgfVxuICAgIHJldHVybiBrZWVwO1xuICB9KTtcbn1cblxudmFyIERlY3J5cHRlckFlc01vZGUgPSB7XG4gIGNiYzogMCxcbiAgY3RyOiAxXG59O1xuXG5jbGFzcyBBRVNDcnlwdG8ge1xuICBjb25zdHJ1Y3RvcihzdWJ0bGUsIGl2LCBhZXNNb2RlKSB7XG4gICAgdGhpcy5zdWJ0bGUgPSB2b2lkIDA7XG4gICAgdGhpcy5hZXNJViA9IHZvaWQgMDtcbiAgICB0aGlzLmFlc01vZGUgPSB2b2lkIDA7XG4gICAgdGhpcy5zdWJ0bGUgPSBzdWJ0bGU7XG4gICAgdGhpcy5hZXNJViA9IGl2O1xuICAgIHRoaXMuYWVzTW9kZSA9IGFlc01vZGU7XG4gIH1cbiAgZGVjcnlwdChkYXRhLCBrZXkpIHtcbiAgICBzd2l0Y2ggKHRoaXMuYWVzTW9kZSkge1xuICAgICAgY2FzZSBEZWNyeXB0ZXJBZXNNb2RlLmNiYzpcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VidGxlLmRlY3J5cHQoe1xuICAgICAgICAgIG5hbWU6ICdBRVMtQ0JDJyxcbiAgICAgICAgICBpdjogdGhpcy5hZXNJVlxuICAgICAgICB9LCBrZXksIGRhdGEpO1xuICAgICAgY2FzZSBEZWNyeXB0ZXJBZXNNb2RlLmN0cjpcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VidGxlLmRlY3J5cHQoe1xuICAgICAgICAgIG5hbWU6ICdBRVMtQ1RSJyxcbiAgICAgICAgICBjb3VudGVyOiB0aGlzLmFlc0lWLFxuICAgICAgICAgIGxlbmd0aDogNjRcbiAgICAgICAgfSxcbiAgICAgICAgLy82NCA6IE5JU1QgU1A4MDAtMzhBIHN0YW5kYXJkIHN1Z2dlc3RzIHRoYXQgdGhlIGNvdW50ZXIgc2hvdWxkIG9jY3VweSBoYWxmIG9mIHRoZSBjb3VudGVyIGJsb2NrXG4gICAgICAgIGtleSwgZGF0YSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFtBRVNDcnlwdG9dIGludmFsaWQgYWVzIG1vZGUgJHt0aGlzLmFlc01vZGV9YCk7XG4gICAgfVxuICB9XG59XG5cbi8vIFBLQ1M3XG5mdW5jdGlvbiByZW1vdmVQYWRkaW5nKGFycmF5KSB7XG4gIGNvbnN0IG91dHB1dEJ5dGVzID0gYXJyYXkuYnl0ZUxlbmd0aDtcbiAgY29uc3QgcGFkZGluZ0J5dGVzID0gb3V0cHV0Qnl0ZXMgJiYgbmV3IERhdGFWaWV3KGFycmF5LmJ1ZmZlcikuZ2V0VWludDgob3V0cHV0Qnl0ZXMgLSAxKTtcbiAgaWYgKHBhZGRpbmdCeXRlcykge1xuICAgIHJldHVybiBhcnJheS5zbGljZSgwLCBvdXRwdXRCeXRlcyAtIHBhZGRpbmdCeXRlcyk7XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuY2xhc3MgQUVTRGVjcnlwdG9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5yY29uID0gWzB4MCwgMHgxLCAweDIsIDB4NCwgMHg4LCAweDEwLCAweDIwLCAweDQwLCAweDgwLCAweDFiLCAweDM2XTtcbiAgICB0aGlzLnN1Yk1peCA9IFtuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KV07XG4gICAgdGhpcy5pbnZTdWJNaXggPSBbbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NildO1xuICAgIHRoaXMuc0JveCA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgIHRoaXMuaW52U0JveCA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgIHRoaXMua2V5ID0gbmV3IFVpbnQzMkFycmF5KDApO1xuICAgIHRoaXMua3NSb3dzID0gMDtcbiAgICB0aGlzLmtleVNpemUgPSAwO1xuICAgIHRoaXMua2V5U2NoZWR1bGUgPSB2b2lkIDA7XG4gICAgdGhpcy5pbnZLZXlTY2hlZHVsZSA9IHZvaWQgMDtcbiAgICB0aGlzLmluaXRUYWJsZSgpO1xuICB9XG5cbiAgLy8gVXNpbmcgdmlldy5nZXRVaW50MzIoKSBhbHNvIHN3YXBzIHRoZSBieXRlIG9yZGVyLlxuICB1aW50OEFycmF5VG9VaW50MzJBcnJheV8oYXJyYXlCdWZmZXIpIHtcbiAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGFycmF5QnVmZmVyKTtcbiAgICBjb25zdCBuZXdBcnJheSA9IG5ldyBVaW50MzJBcnJheSg0KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgbmV3QXJyYXlbaV0gPSB2aWV3LmdldFVpbnQzMihpICogNCk7XG4gICAgfVxuICAgIHJldHVybiBuZXdBcnJheTtcbiAgfVxuICBpbml0VGFibGUoKSB7XG4gICAgY29uc3Qgc0JveCA9IHRoaXMuc0JveDtcbiAgICBjb25zdCBpbnZTQm94ID0gdGhpcy5pbnZTQm94O1xuICAgIGNvbnN0IHN1Yk1peCA9IHRoaXMuc3ViTWl4O1xuICAgIGNvbnN0IHN1Yk1peDAgPSBzdWJNaXhbMF07XG4gICAgY29uc3Qgc3ViTWl4MSA9IHN1Yk1peFsxXTtcbiAgICBjb25zdCBzdWJNaXgyID0gc3ViTWl4WzJdO1xuICAgIGNvbnN0IHN1Yk1peDMgPSBzdWJNaXhbM107XG4gICAgY29uc3QgaW52U3ViTWl4ID0gdGhpcy5pbnZTdWJNaXg7XG4gICAgY29uc3QgaW52U3ViTWl4MCA9IGludlN1Yk1peFswXTtcbiAgICBjb25zdCBpbnZTdWJNaXgxID0gaW52U3ViTWl4WzFdO1xuICAgIGNvbnN0IGludlN1Yk1peDIgPSBpbnZTdWJNaXhbMl07XG4gICAgY29uc3QgaW52U3ViTWl4MyA9IGludlN1Yk1peFszXTtcbiAgICBjb25zdCBkID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gICAgbGV0IHggPSAwO1xuICAgIGxldCB4aSA9IDA7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgaWYgKGkgPCAxMjgpIHtcbiAgICAgICAgZFtpXSA9IGkgPDwgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRbaV0gPSBpIDw8IDEgXiAweDExYjtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICBsZXQgc3ggPSB4aSBeIHhpIDw8IDEgXiB4aSA8PCAyIF4geGkgPDwgMyBeIHhpIDw8IDQ7XG4gICAgICBzeCA9IHN4ID4+PiA4IF4gc3ggJiAweGZmIF4gMHg2MztcbiAgICAgIHNCb3hbeF0gPSBzeDtcbiAgICAgIGludlNCb3hbc3hdID0geDtcblxuICAgICAgLy8gQ29tcHV0ZSBtdWx0aXBsaWNhdGlvblxuICAgICAgY29uc3QgeDIgPSBkW3hdO1xuICAgICAgY29uc3QgeDQgPSBkW3gyXTtcbiAgICAgIGNvbnN0IHg4ID0gZFt4NF07XG5cbiAgICAgIC8vIENvbXB1dGUgc3ViL2ludlN1YiBieXRlcywgbWl4IGNvbHVtbnMgdGFibGVzXG4gICAgICBsZXQgdCA9IGRbc3hdICogMHgxMDEgXiBzeCAqIDB4MTAxMDEwMDtcbiAgICAgIHN1Yk1peDBbeF0gPSB0IDw8IDI0IHwgdCA+Pj4gODtcbiAgICAgIHN1Yk1peDFbeF0gPSB0IDw8IDE2IHwgdCA+Pj4gMTY7XG4gICAgICBzdWJNaXgyW3hdID0gdCA8PCA4IHwgdCA+Pj4gMjQ7XG4gICAgICBzdWJNaXgzW3hdID0gdDtcblxuICAgICAgLy8gQ29tcHV0ZSBpbnYgc3ViIGJ5dGVzLCBpbnYgbWl4IGNvbHVtbnMgdGFibGVzXG4gICAgICB0ID0geDggKiAweDEwMTAxMDEgXiB4NCAqIDB4MTAwMDEgXiB4MiAqIDB4MTAxIF4geCAqIDB4MTAxMDEwMDtcbiAgICAgIGludlN1Yk1peDBbc3hdID0gdCA8PCAyNCB8IHQgPj4+IDg7XG4gICAgICBpbnZTdWJNaXgxW3N4XSA9IHQgPDwgMTYgfCB0ID4+PiAxNjtcbiAgICAgIGludlN1Yk1peDJbc3hdID0gdCA8PCA4IHwgdCA+Pj4gMjQ7XG4gICAgICBpbnZTdWJNaXgzW3N4XSA9IHQ7XG5cbiAgICAgIC8vIENvbXB1dGUgbmV4dCBjb3VudGVyXG4gICAgICBpZiAoIXgpIHtcbiAgICAgICAgeCA9IHhpID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSB4MiBeIGRbZFtkW3g4IF4geDJdXV07XG4gICAgICAgIHhpIF49IGRbZFt4aV1dO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBleHBhbmRLZXkoa2V5QnVmZmVyKSB7XG4gICAgLy8gY29udmVydCBrZXlCdWZmZXIgdG8gVWludDMyQXJyYXlcbiAgICBjb25zdCBrZXkgPSB0aGlzLnVpbnQ4QXJyYXlUb1VpbnQzMkFycmF5XyhrZXlCdWZmZXIpO1xuICAgIGxldCBzYW1lS2V5ID0gdHJ1ZTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICB3aGlsZSAob2Zmc2V0IDwga2V5Lmxlbmd0aCAmJiBzYW1lS2V5KSB7XG4gICAgICBzYW1lS2V5ID0ga2V5W29mZnNldF0gPT09IHRoaXMua2V5W29mZnNldF07XG4gICAgICBvZmZzZXQrKztcbiAgICB9XG4gICAgaWYgKHNhbWVLZXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgY29uc3Qga2V5U2l6ZSA9IHRoaXMua2V5U2l6ZSA9IGtleS5sZW5ndGg7XG4gICAgaWYgKGtleVNpemUgIT09IDQgJiYga2V5U2l6ZSAhPT0gNiAmJiBrZXlTaXplICE9PSA4KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWVzIGtleSBzaXplPScgKyBrZXlTaXplKTtcbiAgICB9XG4gICAgY29uc3Qga3NSb3dzID0gdGhpcy5rc1Jvd3MgPSAoa2V5U2l6ZSArIDYgKyAxKSAqIDQ7XG4gICAgbGV0IGtzUm93O1xuICAgIGxldCBpbnZLc1JvdztcbiAgICBjb25zdCBrZXlTY2hlZHVsZSA9IHRoaXMua2V5U2NoZWR1bGUgPSBuZXcgVWludDMyQXJyYXkoa3NSb3dzKTtcbiAgICBjb25zdCBpbnZLZXlTY2hlZHVsZSA9IHRoaXMuaW52S2V5U2NoZWR1bGUgPSBuZXcgVWludDMyQXJyYXkoa3NSb3dzKTtcbiAgICBjb25zdCBzYm94ID0gdGhpcy5zQm94O1xuICAgIGNvbnN0IHJjb24gPSB0aGlzLnJjb247XG4gICAgY29uc3QgaW52U3ViTWl4ID0gdGhpcy5pbnZTdWJNaXg7XG4gICAgY29uc3QgaW52U3ViTWl4MCA9IGludlN1Yk1peFswXTtcbiAgICBjb25zdCBpbnZTdWJNaXgxID0gaW52U3ViTWl4WzFdO1xuICAgIGNvbnN0IGludlN1Yk1peDIgPSBpbnZTdWJNaXhbMl07XG4gICAgY29uc3QgaW52U3ViTWl4MyA9IGludlN1Yk1peFszXTtcbiAgICBsZXQgcHJldjtcbiAgICBsZXQgdDtcbiAgICBmb3IgKGtzUm93ID0gMDsga3NSb3cgPCBrc1Jvd3M7IGtzUm93KyspIHtcbiAgICAgIGlmIChrc1JvdyA8IGtleVNpemUpIHtcbiAgICAgICAgcHJldiA9IGtleVNjaGVkdWxlW2tzUm93XSA9IGtleVtrc1Jvd107XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdCA9IHByZXY7XG4gICAgICBpZiAoa3NSb3cgJSBrZXlTaXplID09PSAwKSB7XG4gICAgICAgIC8vIFJvdCB3b3JkXG4gICAgICAgIHQgPSB0IDw8IDggfCB0ID4+PiAyNDtcblxuICAgICAgICAvLyBTdWIgd29yZFxuICAgICAgICB0ID0gc2JveFt0ID4+PiAyNF0gPDwgMjQgfCBzYm94W3QgPj4+IDE2ICYgMHhmZl0gPDwgMTYgfCBzYm94W3QgPj4+IDggJiAweGZmXSA8PCA4IHwgc2JveFt0ICYgMHhmZl07XG5cbiAgICAgICAgLy8gTWl4IFJjb25cbiAgICAgICAgdCBePSByY29uW2tzUm93IC8ga2V5U2l6ZSB8IDBdIDw8IDI0O1xuICAgICAgfSBlbHNlIGlmIChrZXlTaXplID4gNiAmJiBrc1JvdyAlIGtleVNpemUgPT09IDQpIHtcbiAgICAgICAgLy8gU3ViIHdvcmRcbiAgICAgICAgdCA9IHNib3hbdCA+Pj4gMjRdIDw8IDI0IHwgc2JveFt0ID4+PiAxNiAmIDB4ZmZdIDw8IDE2IHwgc2JveFt0ID4+PiA4ICYgMHhmZl0gPDwgOCB8IHNib3hbdCAmIDB4ZmZdO1xuICAgICAgfVxuICAgICAga2V5U2NoZWR1bGVba3NSb3ddID0gcHJldiA9IChrZXlTY2hlZHVsZVtrc1JvdyAtIGtleVNpemVdIF4gdCkgPj4+IDA7XG4gICAgfVxuICAgIGZvciAoaW52S3NSb3cgPSAwOyBpbnZLc1JvdyA8IGtzUm93czsgaW52S3NSb3crKykge1xuICAgICAga3NSb3cgPSBrc1Jvd3MgLSBpbnZLc1JvdztcbiAgICAgIGlmIChpbnZLc1JvdyAmIDMpIHtcbiAgICAgICAgdCA9IGtleVNjaGVkdWxlW2tzUm93XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHQgPSBrZXlTY2hlZHVsZVtrc1JvdyAtIDRdO1xuICAgICAgfVxuICAgICAgaWYgKGludktzUm93IDwgNCB8fCBrc1JvdyA8PSA0KSB7XG4gICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSBpbnZTdWJNaXgwW3Nib3hbdCA+Pj4gMjRdXSBeIGludlN1Yk1peDFbc2JveFt0ID4+PiAxNiAmIDB4ZmZdXSBeIGludlN1Yk1peDJbc2JveFt0ID4+PiA4ICYgMHhmZl1dIF4gaW52U3ViTWl4M1tzYm94W3QgJiAweGZmXV07XG4gICAgICB9XG4gICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPj4+IDA7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkaW5nIHRoaXMgYXMgYSBtZXRob2QgZ3JlYXRseSBpbXByb3ZlcyBwZXJmb3JtYW5jZS5cbiAgbmV0d29ya1RvSG9zdE9yZGVyU3dhcCh3b3JkKSB7XG4gICAgcmV0dXJuIHdvcmQgPDwgMjQgfCAod29yZCAmIDB4ZmYwMCkgPDwgOCB8ICh3b3JkICYgMHhmZjAwMDApID4+IDggfCB3b3JkID4+PiAyNDtcbiAgfVxuICBkZWNyeXB0KGlucHV0QXJyYXlCdWZmZXIsIG9mZnNldCwgYWVzSVYpIHtcbiAgICBjb25zdCBuUm91bmRzID0gdGhpcy5rZXlTaXplICsgNjtcbiAgICBjb25zdCBpbnZLZXlTY2hlZHVsZSA9IHRoaXMuaW52S2V5U2NoZWR1bGU7XG4gICAgY29uc3QgaW52U0JPWCA9IHRoaXMuaW52U0JveDtcbiAgICBjb25zdCBpbnZTdWJNaXggPSB0aGlzLmludlN1Yk1peDtcbiAgICBjb25zdCBpbnZTdWJNaXgwID0gaW52U3ViTWl4WzBdO1xuICAgIGNvbnN0IGludlN1Yk1peDEgPSBpbnZTdWJNaXhbMV07XG4gICAgY29uc3QgaW52U3ViTWl4MiA9IGludlN1Yk1peFsyXTtcbiAgICBjb25zdCBpbnZTdWJNaXgzID0gaW52U3ViTWl4WzNdO1xuICAgIGNvbnN0IGluaXRWZWN0b3IgPSB0aGlzLnVpbnQ4QXJyYXlUb1VpbnQzMkFycmF5XyhhZXNJVik7XG4gICAgbGV0IGluaXRWZWN0b3IwID0gaW5pdFZlY3RvclswXTtcbiAgICBsZXQgaW5pdFZlY3RvcjEgPSBpbml0VmVjdG9yWzFdO1xuICAgIGxldCBpbml0VmVjdG9yMiA9IGluaXRWZWN0b3JbMl07XG4gICAgbGV0IGluaXRWZWN0b3IzID0gaW5pdFZlY3RvclszXTtcbiAgICBjb25zdCBpbnB1dEludDMyID0gbmV3IEludDMyQXJyYXkoaW5wdXRBcnJheUJ1ZmZlcik7XG4gICAgY29uc3Qgb3V0cHV0SW50MzIgPSBuZXcgSW50MzJBcnJheShpbnB1dEludDMyLmxlbmd0aCk7XG4gICAgbGV0IHQwLCB0MSwgdDIsIHQzO1xuICAgIGxldCBzMCwgczEsIHMyLCBzMztcbiAgICBsZXQgaW5wdXRXb3JkczAsIGlucHV0V29yZHMxLCBpbnB1dFdvcmRzMiwgaW5wdXRXb3JkczM7XG4gICAgbGV0IGtzUm93LCBpO1xuICAgIGNvbnN0IHN3YXBXb3JkID0gdGhpcy5uZXR3b3JrVG9Ib3N0T3JkZXJTd2FwO1xuICAgIHdoaWxlIChvZmZzZXQgPCBpbnB1dEludDMyLmxlbmd0aCkge1xuICAgICAgaW5wdXRXb3JkczAgPSBzd2FwV29yZChpbnB1dEludDMyW29mZnNldF0pO1xuICAgICAgaW5wdXRXb3JkczEgPSBzd2FwV29yZChpbnB1dEludDMyW29mZnNldCArIDFdKTtcbiAgICAgIGlucHV0V29yZHMyID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXQgKyAyXSk7XG4gICAgICBpbnB1dFdvcmRzMyA9IHN3YXBXb3JkKGlucHV0SW50MzJbb2Zmc2V0ICsgM10pO1xuICAgICAgczAgPSBpbnB1dFdvcmRzMCBeIGludktleVNjaGVkdWxlWzBdO1xuICAgICAgczEgPSBpbnB1dFdvcmRzMyBeIGludktleVNjaGVkdWxlWzFdO1xuICAgICAgczIgPSBpbnB1dFdvcmRzMiBeIGludktleVNjaGVkdWxlWzJdO1xuICAgICAgczMgPSBpbnB1dFdvcmRzMSBeIGludktleVNjaGVkdWxlWzNdO1xuICAgICAga3NSb3cgPSA0O1xuXG4gICAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIHJvdW5kcyBvZiBkZWNyeXB0aW9uXG4gICAgICBmb3IgKGkgPSAxOyBpIDwgblJvdW5kczsgaSsrKSB7XG4gICAgICAgIHQwID0gaW52U3ViTWl4MFtzMCA+Pj4gMjRdIF4gaW52U3ViTWl4MVtzMSA+PiAxNiAmIDB4ZmZdIF4gaW52U3ViTWl4MltzMiA+PiA4ICYgMHhmZl0gXiBpbnZTdWJNaXgzW3MzICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1Jvd107XG4gICAgICAgIHQxID0gaW52U3ViTWl4MFtzMSA+Pj4gMjRdIF4gaW52U3ViTWl4MVtzMiA+PiAxNiAmIDB4ZmZdIF4gaW52U3ViTWl4MltzMyA+PiA4ICYgMHhmZl0gXiBpbnZTdWJNaXgzW3MwICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDFdO1xuICAgICAgICB0MiA9IGludlN1Yk1peDBbczIgPj4+IDI0XSBeIGludlN1Yk1peDFbczMgPj4gMTYgJiAweGZmXSBeIGludlN1Yk1peDJbczAgPj4gOCAmIDB4ZmZdIF4gaW52U3ViTWl4M1tzMSAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAyXTtcbiAgICAgICAgdDMgPSBpbnZTdWJNaXgwW3MzID4+PiAyNF0gXiBpbnZTdWJNaXgxW3MwID4+IDE2ICYgMHhmZl0gXiBpbnZTdWJNaXgyW3MxID4+IDggJiAweGZmXSBeIGludlN1Yk1peDNbczIgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgM107XG4gICAgICAgIC8vIFVwZGF0ZSBzdGF0ZVxuICAgICAgICBzMCA9IHQwO1xuICAgICAgICBzMSA9IHQxO1xuICAgICAgICBzMiA9IHQyO1xuICAgICAgICBzMyA9IHQzO1xuICAgICAgICBrc1JvdyA9IGtzUm93ICsgNDtcbiAgICAgIH1cblxuICAgICAgLy8gU2hpZnQgcm93cywgc3ViIGJ5dGVzLCBhZGQgcm91bmQga2V5XG4gICAgICB0MCA9IGludlNCT1hbczAgPj4+IDI0XSA8PCAyNCBeIGludlNCT1hbczEgPj4gMTYgJiAweGZmXSA8PCAxNiBeIGludlNCT1hbczIgPj4gOCAmIDB4ZmZdIDw8IDggXiBpbnZTQk9YW3MzICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1Jvd107XG4gICAgICB0MSA9IGludlNCT1hbczEgPj4+IDI0XSA8PCAyNCBeIGludlNCT1hbczIgPj4gMTYgJiAweGZmXSA8PCAxNiBeIGludlNCT1hbczMgPj4gOCAmIDB4ZmZdIDw8IDggXiBpbnZTQk9YW3MwICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDFdO1xuICAgICAgdDIgPSBpbnZTQk9YW3MyID4+PiAyNF0gPDwgMjQgXiBpbnZTQk9YW3MzID4+IDE2ICYgMHhmZl0gPDwgMTYgXiBpbnZTQk9YW3MwID4+IDggJiAweGZmXSA8PCA4IF4gaW52U0JPWFtzMSAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAyXTtcbiAgICAgIHQzID0gaW52U0JPWFtzMyA+Pj4gMjRdIDw8IDI0IF4gaW52U0JPWFtzMCA+PiAxNiAmIDB4ZmZdIDw8IDE2IF4gaW52U0JPWFtzMSA+PiA4ICYgMHhmZl0gPDwgOCBeIGludlNCT1hbczIgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgM107XG5cbiAgICAgIC8vIFdyaXRlXG4gICAgICBvdXRwdXRJbnQzMltvZmZzZXRdID0gc3dhcFdvcmQodDAgXiBpbml0VmVjdG9yMCk7XG4gICAgICBvdXRwdXRJbnQzMltvZmZzZXQgKyAxXSA9IHN3YXBXb3JkKHQzIF4gaW5pdFZlY3RvcjEpO1xuICAgICAgb3V0cHV0SW50MzJbb2Zmc2V0ICsgMl0gPSBzd2FwV29yZCh0MiBeIGluaXRWZWN0b3IyKTtcbiAgICAgIG91dHB1dEludDMyW29mZnNldCArIDNdID0gc3dhcFdvcmQodDEgXiBpbml0VmVjdG9yMyk7XG5cbiAgICAgIC8vIHJlc2V0IGluaXRWZWN0b3IgdG8gbGFzdCA0IHVuc2lnbmVkIGludFxuICAgICAgaW5pdFZlY3RvcjAgPSBpbnB1dFdvcmRzMDtcbiAgICAgIGluaXRWZWN0b3IxID0gaW5wdXRXb3JkczE7XG4gICAgICBpbml0VmVjdG9yMiA9IGlucHV0V29yZHMyO1xuICAgICAgaW5pdFZlY3RvcjMgPSBpbnB1dFdvcmRzMztcbiAgICAgIG9mZnNldCA9IG9mZnNldCArIDQ7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXRJbnQzMi5idWZmZXI7XG4gIH1cbn1cblxuY2xhc3MgRmFzdEFFU0tleSB7XG4gIGNvbnN0cnVjdG9yKHN1YnRsZSwga2V5LCBhZXNNb2RlKSB7XG4gICAgdGhpcy5zdWJ0bGUgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5hZXNNb2RlID0gdm9pZCAwO1xuICAgIHRoaXMuc3VidGxlID0gc3VidGxlO1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMuYWVzTW9kZSA9IGFlc01vZGU7XG4gIH1cbiAgZXhwYW5kS2V5KCkge1xuICAgIGNvbnN0IHN1YnRsZUFsZ29OYW1lID0gZ2V0U3VidGxlQWxnb05hbWUodGhpcy5hZXNNb2RlKTtcbiAgICByZXR1cm4gdGhpcy5zdWJ0bGUuaW1wb3J0S2V5KCdyYXcnLCB0aGlzLmtleSwge1xuICAgICAgbmFtZTogc3VidGxlQWxnb05hbWVcbiAgICB9LCBmYWxzZSwgWydlbmNyeXB0JywgJ2RlY3J5cHQnXSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFN1YnRsZUFsZ29OYW1lKGFlc01vZGUpIHtcbiAgc3dpdGNoIChhZXNNb2RlKSB7XG4gICAgY2FzZSBEZWNyeXB0ZXJBZXNNb2RlLmNiYzpcbiAgICAgIHJldHVybiAnQUVTLUNCQyc7XG4gICAgY2FzZSBEZWNyeXB0ZXJBZXNNb2RlLmN0cjpcbiAgICAgIHJldHVybiAnQUVTLUNUUic7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgW0Zhc3RBRVNLZXldIGludmFsaWQgYWVzIG1vZGUgJHthZXNNb2RlfWApO1xuICB9XG59XG5cbmNvbnN0IENIVU5LX1NJWkUgPSAxNjsgLy8gMTYgYnl0ZXMsIDEyOCBiaXRzXG5cbmNsYXNzIERlY3J5cHRlciB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZywge1xuICAgIHJlbW92ZVBLQ1M3UGFkZGluZyA9IHRydWVcbiAgfSA9IHt9KSB7XG4gICAgdGhpcy5sb2dFbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLnJlbW92ZVBLQ1M3UGFkZGluZyA9IHZvaWQgMDtcbiAgICB0aGlzLnN1YnRsZSA9IG51bGw7XG4gICAgdGhpcy5zb2Z0d2FyZURlY3J5cHRlciA9IG51bGw7XG4gICAgdGhpcy5rZXkgPSBudWxsO1xuICAgIHRoaXMuZmFzdEFlc0tleSA9IG51bGw7XG4gICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRJViA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50UmVzdWx0ID0gbnVsbDtcbiAgICB0aGlzLnVzZVNvZnR3YXJlID0gdm9pZCAwO1xuICAgIHRoaXMuZW5hYmxlU29mdHdhcmVBRVMgPSB2b2lkIDA7XG4gICAgdGhpcy5lbmFibGVTb2Z0d2FyZUFFUyA9IGNvbmZpZy5lbmFibGVTb2Z0d2FyZUFFUztcbiAgICB0aGlzLnJlbW92ZVBLQ1M3UGFkZGluZyA9IHJlbW92ZVBLQ1M3UGFkZGluZztcbiAgICAvLyBidWlsdCBpbiBkZWNyeXB0b3IgZXhwZWN0cyBQS0NTNyBwYWRkaW5nXG4gICAgaWYgKHJlbW92ZVBLQ1M3UGFkZGluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYnJvd3NlckNyeXB0byA9IHNlbGYuY3J5cHRvO1xuICAgICAgICBpZiAoYnJvd3NlckNyeXB0bykge1xuICAgICAgICAgIHRoaXMuc3VidGxlID0gYnJvd3NlckNyeXB0by5zdWJ0bGUgfHwgYnJvd3NlckNyeXB0by53ZWJraXRTdWJ0bGU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLyogbm8tb3AgKi9cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy51c2VTb2Z0d2FyZSA9ICF0aGlzLnN1YnRsZTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuc3VidGxlID0gbnVsbDtcbiAgICB0aGlzLnNvZnR3YXJlRGVjcnlwdGVyID0gbnVsbDtcbiAgICB0aGlzLmtleSA9IG51bGw7XG4gICAgdGhpcy5mYXN0QWVzS2V5ID0gbnVsbDtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudElWID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRSZXN1bHQgPSBudWxsO1xuICB9XG4gIGlzU3luYygpIHtcbiAgICByZXR1cm4gdGhpcy51c2VTb2Z0d2FyZTtcbiAgfVxuICBmbHVzaCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBjdXJyZW50UmVzdWx0LFxuICAgICAgcmVtYWluZGVyRGF0YVxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghY3VycmVudFJlc3VsdCB8fCByZW1haW5kZXJEYXRhKSB7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KGN1cnJlbnRSZXN1bHQpO1xuICAgIHRoaXMucmVzZXQoKTtcbiAgICBpZiAodGhpcy5yZW1vdmVQS0NTN1BhZGRpbmcpIHtcbiAgICAgIHJldHVybiByZW1vdmVQYWRkaW5nKGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLmN1cnJlbnRSZXN1bHQgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudElWID0gbnVsbDtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIGlmICh0aGlzLnNvZnR3YXJlRGVjcnlwdGVyKSB7XG4gICAgICB0aGlzLnNvZnR3YXJlRGVjcnlwdGVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZGVjcnlwdChkYXRhLCBrZXksIGl2LCBhZXNNb2RlKSB7XG4gICAgaWYgKHRoaXMudXNlU29mdHdhcmUpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpID8gZGF0YSA6IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICAgICAgICB0aGlzLnNvZnR3YXJlRGVjcnlwdChkYXRhVmlldywga2V5LCBpdiwgYWVzTW9kZSk7XG4gICAgICAgIGNvbnN0IGRlY3J5cHRSZXN1bHQgPSB0aGlzLmZsdXNoKCk7XG4gICAgICAgIGlmIChkZWNyeXB0UmVzdWx0KSB7XG4gICAgICAgICAgcmVzb2x2ZShkZWNyeXB0UmVzdWx0LmJ1ZmZlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignW3NvZnR3YXJlRGVjcnlwdF0gRmFpbGVkIHRvIGRlY3J5cHQgZGF0YScpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndlYkNyeXB0b0RlY3J5cHQobmV3IFVpbnQ4QXJyYXkoZGF0YSksIGtleSwgaXYsIGFlc01vZGUpO1xuICB9XG5cbiAgLy8gU29mdHdhcmUgZGVjcnlwdGlvbiBpcyBwcm9ncmVzc2l2ZS4gUHJvZ3Jlc3NpdmUgZGVjcnlwdGlvbiBtYXkgbm90IHJldHVybiBhIHJlc3VsdCBvbiBlYWNoIGNhbGwuIEFueSBjYWNoZWRcbiAgLy8gZGF0YSBpcyBoYW5kbGVkIGluIHRoZSBmbHVzaCgpIGNhbGxcbiAgc29mdHdhcmVEZWNyeXB0KGRhdGEsIGtleSwgaXYsIGFlc01vZGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBjdXJyZW50SVYsXG4gICAgICBjdXJyZW50UmVzdWx0LFxuICAgICAgcmVtYWluZGVyRGF0YVxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChhZXNNb2RlICE9PSBEZWNyeXB0ZXJBZXNNb2RlLmNiYyB8fCBrZXkuYnl0ZUxlbmd0aCAhPT0gMTYpIHtcbiAgICAgIGxvZ2dlci53YXJuKCdTb2Z0d2FyZURlY3J5cHQ6IGNhbiBvbmx5IGhhbmRsZSBBRVMtMTI4LUNCQycpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRoaXMubG9nT25jZSgnSlMgQUVTIGRlY3J5cHQnKTtcbiAgICAvLyBUaGUgb3V0cHV0IGlzIHN0YWdnZXJlZCBkdXJpbmcgcHJvZ3Jlc3NpdmUgcGFyc2luZyAtIHRoZSBjdXJyZW50IHJlc3VsdCBpcyBjYWNoZWQsIGFuZCBlbWl0dGVkIG9uIHRoZSBuZXh0IGNhbGxcbiAgICAvLyBUaGlzIGlzIGRvbmUgaW4gb3JkZXIgdG8gc3RyaXAgUEtDUzcgcGFkZGluZywgd2hpY2ggaXMgZm91bmQgYXQgdGhlIGVuZCBvZiBlYWNoIHNlZ21lbnQuIFdlIG9ubHkga25vdyB3ZSd2ZSByZWFjaGVkXG4gICAgLy8gdGhlIGVuZCBvbiBmbHVzaCgpLCBidXQgYnkgdGhhdCB0aW1lIHdlIGhhdmUgYWxyZWFkeSByZWNlaXZlZCBhbGwgYnl0ZXMgZm9yIHRoZSBzZWdtZW50LlxuICAgIC8vIFByb2dyZXNzaXZlIGRlY3J5cHRpb24gZG9lcyBub3Qgd29yayB3aXRoIFdlYkNyeXB0b1xuXG4gICAgaWYgKHJlbWFpbmRlckRhdGEpIHtcbiAgICAgIGRhdGEgPSBhcHBlbmRVaW50OEFycmF5KHJlbWFpbmRlckRhdGEsIGRhdGEpO1xuICAgICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBCeXRlIGxlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYgKEFFUy0xMjggPSAxMjggYml0IGJsb2NrcyA9IDE2IGJ5dGVzKVxuICAgIGNvbnN0IGN1cnJlbnRDaHVuayA9IHRoaXMuZ2V0VmFsaWRDaHVuayhkYXRhKTtcbiAgICBpZiAoIWN1cnJlbnRDaHVuay5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoY3VycmVudElWKSB7XG4gICAgICBpdiA9IGN1cnJlbnRJVjtcbiAgICB9XG4gICAgbGV0IHNvZnR3YXJlRGVjcnlwdGVyID0gdGhpcy5zb2Z0d2FyZURlY3J5cHRlcjtcbiAgICBpZiAoIXNvZnR3YXJlRGVjcnlwdGVyKSB7XG4gICAgICBzb2Z0d2FyZURlY3J5cHRlciA9IHRoaXMuc29mdHdhcmVEZWNyeXB0ZXIgPSBuZXcgQUVTRGVjcnlwdG9yKCk7XG4gICAgfVxuICAgIHNvZnR3YXJlRGVjcnlwdGVyLmV4cGFuZEtleShrZXkpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGN1cnJlbnRSZXN1bHQ7XG4gICAgdGhpcy5jdXJyZW50UmVzdWx0ID0gc29mdHdhcmVEZWNyeXB0ZXIuZGVjcnlwdChjdXJyZW50Q2h1bmsuYnVmZmVyLCAwLCBpdik7XG4gICAgdGhpcy5jdXJyZW50SVYgPSBjdXJyZW50Q2h1bmsuc2xpY2UoLTE2KS5idWZmZXI7XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHdlYkNyeXB0b0RlY3J5cHQoZGF0YSwga2V5LCBpdiwgYWVzTW9kZSkge1xuICAgIGlmICh0aGlzLmtleSAhPT0ga2V5IHx8ICF0aGlzLmZhc3RBZXNLZXkpIHtcbiAgICAgIGlmICghdGhpcy5zdWJ0bGUpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLm9uV2ViQ3J5cHRvRXJyb3IoZGF0YSwga2V5LCBpdiwgYWVzTW9kZSkpO1xuICAgICAgfVxuICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICB0aGlzLmZhc3RBZXNLZXkgPSBuZXcgRmFzdEFFU0tleSh0aGlzLnN1YnRsZSwga2V5LCBhZXNNb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmFzdEFlc0tleS5leHBhbmRLZXkoKS50aGVuKGFlc0tleSA9PiB7XG4gICAgICAvLyBkZWNyeXB0IHVzaW5nIHdlYiBjcnlwdG9cbiAgICAgIGlmICghdGhpcy5zdWJ0bGUpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignd2ViIGNyeXB0byBub3QgaW5pdGlhbGl6ZWQnKSk7XG4gICAgICB9XG4gICAgICB0aGlzLmxvZ09uY2UoJ1dlYkNyeXB0byBBRVMgZGVjcnlwdCcpO1xuICAgICAgY29uc3QgY3J5cHRvID0gbmV3IEFFU0NyeXB0byh0aGlzLnN1YnRsZSwgbmV3IFVpbnQ4QXJyYXkoaXYpLCBhZXNNb2RlKTtcbiAgICAgIHJldHVybiBjcnlwdG8uZGVjcnlwdChkYXRhLmJ1ZmZlciwgYWVzS2V5KTtcbiAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgbG9nZ2VyLndhcm4oYFtkZWNyeXB0ZXJdOiBXZWJDcnlwdG8gRXJyb3IsIGRpc2FibGUgV2ViQ3J5cHRvIEFQSSwgJHtlcnIubmFtZX06ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICByZXR1cm4gdGhpcy5vbldlYkNyeXB0b0Vycm9yKGRhdGEsIGtleSwgaXYsIGFlc01vZGUpO1xuICAgIH0pO1xuICB9XG4gIG9uV2ViQ3J5cHRvRXJyb3IoZGF0YSwga2V5LCBpdiwgYWVzTW9kZSkge1xuICAgIGNvbnN0IGVuYWJsZVNvZnR3YXJlQUVTID0gdGhpcy5lbmFibGVTb2Z0d2FyZUFFUztcbiAgICBpZiAoZW5hYmxlU29mdHdhcmVBRVMpIHtcbiAgICAgIHRoaXMudXNlU29mdHdhcmUgPSB0cnVlO1xuICAgICAgdGhpcy5sb2dFbmFibGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuc29mdHdhcmVEZWNyeXB0KGRhdGEsIGtleSwgaXYsIGFlc01vZGUpO1xuICAgICAgY29uc3QgZGVjcnlwdFJlc3VsdCA9IHRoaXMuZmx1c2goKTtcbiAgICAgIGlmIChkZWNyeXB0UmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBkZWNyeXB0UmVzdWx0LmJ1ZmZlcjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdXZWJDcnlwdG8nICsgKGVuYWJsZVNvZnR3YXJlQUVTID8gJyBhbmQgc29mdHdhcmVEZWNyeXB0JyA6ICcnKSArICc6IGZhaWxlZCB0byBkZWNyeXB0IGRhdGEnKTtcbiAgfVxuICBnZXRWYWxpZENodW5rKGRhdGEpIHtcbiAgICBsZXQgY3VycmVudENodW5rID0gZGF0YTtcbiAgICBjb25zdCBzcGxpdFBvaW50ID0gZGF0YS5sZW5ndGggLSBkYXRhLmxlbmd0aCAlIENIVU5LX1NJWkU7XG4gICAgaWYgKHNwbGl0UG9pbnQgIT09IGRhdGEubGVuZ3RoKSB7XG4gICAgICBjdXJyZW50Q2h1bmsgPSBkYXRhLnNsaWNlKDAsIHNwbGl0UG9pbnQpO1xuICAgICAgdGhpcy5yZW1haW5kZXJEYXRhID0gZGF0YS5zbGljZShzcGxpdFBvaW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnRDaHVuaztcbiAgfVxuICBsb2dPbmNlKG1zZykge1xuICAgIGlmICghdGhpcy5sb2dFbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxvZ2dlci5sb2coYFtkZWNyeXB0ZXJdOiAke21zZ31gKTtcbiAgICB0aGlzLmxvZ0VuYWJsZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5jb25zdCBNSU5fQ0hVTktfU0laRSA9IE1hdGgucG93KDIsIDE3KTsgLy8gMTI4a2JcblxuY2xhc3MgRnJhZ21lbnRMb2FkZXIge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgdGhpcy5wYXJ0TG9hZFRpbWVvdXQgPSAtMTtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmxvYWRlcikge1xuICAgICAgdGhpcy5sb2FkZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5sb2FkZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICBhYm9ydCgpIHtcbiAgICBpZiAodGhpcy5sb2FkZXIpIHtcbiAgICAgIC8vIEFib3J0IHRoZSBsb2FkZXIgZm9yIGN1cnJlbnQgZnJhZ21lbnQuIE9ubHkgb25lIG1heSBsb2FkIGF0IGFueSBnaXZlbiB0aW1lXG4gICAgICB0aGlzLmxvYWRlci5hYm9ydCgpO1xuICAgIH1cbiAgfVxuICBsb2FkKGZyYWcsIG9uUHJvZ3Jlc3MpIHtcbiAgICBjb25zdCB1cmwgPSBmcmFnLnVybDtcbiAgICBpZiAoIXVybCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBMb2FkRXJyb3Ioe1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1IsXG4gICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgZnJhZyxcbiAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihgRnJhZ21lbnQgZG9lcyBub3QgaGF2ZSBhICR7dXJsID8gJ3BhcnQgbGlzdCcgOiAndXJsJ31gKSxcbiAgICAgICAgbmV0d29ya0RldGFpbHM6IG51bGxcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgdGhpcy5hYm9ydCgpO1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGNvbnN0IEZyYWdtZW50SUxvYWRlciA9IGNvbmZpZy5mTG9hZGVyO1xuICAgIGNvbnN0IERlZmF1bHRJTG9hZGVyID0gY29uZmlnLmxvYWRlcjtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMubG9hZGVyKSB7XG4gICAgICAgIHRoaXMubG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIGlmIChmcmFnLmdhcCkge1xuICAgICAgICBpZiAoZnJhZy50YWdMaXN0LnNvbWUodGFncyA9PiB0YWdzWzBdID09PSAnR0FQJykpIHtcbiAgICAgICAgICByZWplY3QoY3JlYXRlR2FwTG9hZEVycm9yKGZyYWcpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUmVzZXQgdGVtcG9yYXJ5IHRyZWF0bWVudCBhcyBHQVAgdGFnXG4gICAgICAgICAgZnJhZy5nYXAgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgbG9hZGVyID0gdGhpcy5sb2FkZXIgPSBGcmFnbWVudElMb2FkZXIgPyBuZXcgRnJhZ21lbnRJTG9hZGVyKGNvbmZpZykgOiBuZXcgRGVmYXVsdElMb2FkZXIoY29uZmlnKTtcbiAgICAgIGNvbnN0IGxvYWRlckNvbnRleHQgPSBjcmVhdGVMb2FkZXJDb250ZXh0KGZyYWcpO1xuICAgICAgZnJhZy5sb2FkZXIgPSBsb2FkZXI7XG4gICAgICBjb25zdCBsb2FkUG9saWN5ID0gZ2V0TG9hZGVyQ29uZmlnV2l0aG91dFJldGllcyhjb25maWcuZnJhZ0xvYWRQb2xpY3kuZGVmYXVsdCk7XG4gICAgICBjb25zdCBsb2FkZXJDb25maWcgPSB7XG4gICAgICAgIGxvYWRQb2xpY3ksXG4gICAgICAgIHRpbWVvdXQ6IGxvYWRQb2xpY3kubWF4TG9hZFRpbWVNcyxcbiAgICAgICAgbWF4UmV0cnk6IDAsXG4gICAgICAgIHJldHJ5RGVsYXk6IDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXk6IDAsXG4gICAgICAgIGhpZ2hXYXRlck1hcms6IGZyYWcuc24gPT09ICdpbml0U2VnbWVudCcgPyBJbmZpbml0eSA6IE1JTl9DSFVOS19TSVpFXG4gICAgICB9O1xuICAgICAgLy8gQXNzaWduIGZyYWcgc3RhdHMgdG8gdGhlIGxvYWRlcidzIHN0YXRzIHJlZmVyZW5jZVxuICAgICAgZnJhZy5zdGF0cyA9IGxvYWRlci5zdGF0cztcbiAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHtcbiAgICAgICAgb25TdWNjZXNzOiAocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcbiAgICAgICAgICBsZXQgcGF5bG9hZCA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgICAgaWYgKGNvbnRleHQucmVzZXRJViAmJiBmcmFnLmRlY3J5cHRkYXRhKSB7XG4gICAgICAgICAgICBmcmFnLmRlY3J5cHRkYXRhLml2ID0gbmV3IFVpbnQ4QXJyYXkocGF5bG9hZC5zbGljZSgwLCAxNikpO1xuICAgICAgICAgICAgcGF5bG9hZCA9IHBheWxvYWQuc2xpY2UoMTYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICBwYXJ0OiBudWxsLFxuICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRXJyb3I6IChyZXNwb25zZSwgY29udGV4dCwgbmV0d29ya0RldGFpbHMsIHN0YXRzKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuICAgICAgICAgIHJlamVjdChuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1IsXG4gICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgcmVzcG9uc2U6IF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICBkYXRhOiB1bmRlZmluZWRcbiAgICAgICAgICAgIH0sIHJlc3BvbnNlKSxcbiAgICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3IoYEhUVFAgRXJyb3IgJHtyZXNwb25zZS5jb2RlfSAke3Jlc3BvbnNlLnRleHR9YCksXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICAgIHN0YXRzXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9LFxuICAgICAgICBvbkFib3J0OiAoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuICAgICAgICAgIHJlamVjdChuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5JTlRFUk5BTF9BQk9SVEVELFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3IoJ0Fib3J0ZWQnKSxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgc3RhdHNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uVGltZW91dDogKHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcbiAgICAgICAgICByZWplY3QobmV3IExvYWRFcnJvcih7XG4gICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQsXG4gICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihgVGltZW91dCBhZnRlciAke2xvYWRlckNvbmZpZy50aW1lb3V0fW1zYCksXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICAgIHN0YXRzXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKG9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgY2FsbGJhY2tzLm9uUHJvZ3Jlc3MgPSAoc3RhdHMsIGNvbnRleHQsIGRhdGEsIG5ldHdvcmtEZXRhaWxzKSA9PiBvblByb2dyZXNzKHtcbiAgICAgICAgICBmcmFnLFxuICAgICAgICAgIHBhcnQ6IG51bGwsXG4gICAgICAgICAgcGF5bG9hZDogZGF0YSxcbiAgICAgICAgICBuZXR3b3JrRGV0YWlsc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGxvYWRlci5sb2FkKGxvYWRlckNvbnRleHQsIGxvYWRlckNvbmZpZywgY2FsbGJhY2tzKTtcbiAgICB9KTtcbiAgfVxuICBsb2FkUGFydChmcmFnLCBwYXJ0LCBvblByb2dyZXNzKSB7XG4gICAgdGhpcy5hYm9ydCgpO1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGNvbnN0IEZyYWdtZW50SUxvYWRlciA9IGNvbmZpZy5mTG9hZGVyO1xuICAgIGNvbnN0IERlZmF1bHRJTG9hZGVyID0gY29uZmlnLmxvYWRlcjtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMubG9hZGVyKSB7XG4gICAgICAgIHRoaXMubG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIGlmIChmcmFnLmdhcCB8fCBwYXJ0LmdhcCkge1xuICAgICAgICByZWplY3QoY3JlYXRlR2FwTG9hZEVycm9yKGZyYWcsIHBhcnQpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbG9hZGVyID0gdGhpcy5sb2FkZXIgPSBGcmFnbWVudElMb2FkZXIgPyBuZXcgRnJhZ21lbnRJTG9hZGVyKGNvbmZpZykgOiBuZXcgRGVmYXVsdElMb2FkZXIoY29uZmlnKTtcbiAgICAgIGNvbnN0IGxvYWRlckNvbnRleHQgPSBjcmVhdGVMb2FkZXJDb250ZXh0KGZyYWcsIHBhcnQpO1xuICAgICAgZnJhZy5sb2FkZXIgPSBsb2FkZXI7XG4gICAgICAvLyBTaG91bGQgd2UgZGVmaW5lIGFub3RoZXIgbG9hZCBwb2xpY3kgZm9yIHBhcnRzP1xuICAgICAgY29uc3QgbG9hZFBvbGljeSA9IGdldExvYWRlckNvbmZpZ1dpdGhvdXRSZXRpZXMoY29uZmlnLmZyYWdMb2FkUG9saWN5LmRlZmF1bHQpO1xuICAgICAgY29uc3QgbG9hZGVyQ29uZmlnID0ge1xuICAgICAgICBsb2FkUG9saWN5LFxuICAgICAgICB0aW1lb3V0OiBsb2FkUG9saWN5Lm1heExvYWRUaW1lTXMsXG4gICAgICAgIG1heFJldHJ5OiAwLFxuICAgICAgICByZXRyeURlbGF5OiAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5OiAwLFxuICAgICAgICBoaWdoV2F0ZXJNYXJrOiBNSU5fQ0hVTktfU0laRVxuICAgICAgfTtcbiAgICAgIC8vIEFzc2lnbiBwYXJ0IHN0YXRzIHRvIHRoZSBsb2FkZXIncyBzdGF0cyByZWZlcmVuY2VcbiAgICAgIHBhcnQuc3RhdHMgPSBsb2FkZXIuc3RhdHM7XG4gICAgICBsb2FkZXIubG9hZChsb2FkZXJDb250ZXh0LCBsb2FkZXJDb25maWcsIHtcbiAgICAgICAgb25TdWNjZXNzOiAocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRzRnJvbVBhcnQoZnJhZywgcGFydCk7XG4gICAgICAgICAgY29uc3QgcGFydExvYWRlZERhdGEgPSB7XG4gICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgcGFydCxcbiAgICAgICAgICAgIHBheWxvYWQ6IHJlc3BvbnNlLmRhdGEsXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlsc1xuICAgICAgICAgIH07XG4gICAgICAgICAgb25Qcm9ncmVzcyhwYXJ0TG9hZGVkRGF0YSk7XG4gICAgICAgICAgcmVzb2x2ZShwYXJ0TG9hZGVkRGF0YSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRXJyb3I6IChyZXNwb25zZSwgY29udGV4dCwgbmV0d29ya0RldGFpbHMsIHN0YXRzKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuICAgICAgICAgIHJlamVjdChuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1IsXG4gICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgcGFydCxcbiAgICAgICAgICAgIHJlc3BvbnNlOiBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgICAgIHVybDogbG9hZGVyQ29udGV4dC51cmwsXG4gICAgICAgICAgICAgIGRhdGE6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSwgcmVzcG9uc2UpLFxuICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihgSFRUUCBFcnJvciAke3Jlc3BvbnNlLmNvZGV9ICR7cmVzcG9uc2UudGV4dH1gKSxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgc3RhdHNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQWJvcnQ6IChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpID0+IHtcbiAgICAgICAgICBmcmFnLnN0YXRzLmFib3J0ZWQgPSBwYXJ0LnN0YXRzLmFib3J0ZWQ7XG4gICAgICAgICAgdGhpcy5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuICAgICAgICAgIHJlamVjdChuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5JTlRFUk5BTF9BQk9SVEVELFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgIHBhcnQsXG4gICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKCdBYm9ydGVkJyksXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICAgIHN0YXRzXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9LFxuICAgICAgICBvblRpbWVvdXQ6IChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpID0+IHtcbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGVyKGZyYWcsIGxvYWRlcik7XG4gICAgICAgICAgcmVqZWN0KG5ldyBMb2FkRXJyb3Ioe1xuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VULFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgIHBhcnQsXG4gICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKGBUaW1lb3V0IGFmdGVyICR7bG9hZGVyQ29uZmlnLnRpbWVvdXR9bXNgKSxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgc3RhdHNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZVN0YXRzRnJvbVBhcnQoZnJhZywgcGFydCkge1xuICAgIGNvbnN0IGZyYWdTdGF0cyA9IGZyYWcuc3RhdHM7XG4gICAgY29uc3QgcGFydFN0YXRzID0gcGFydC5zdGF0cztcbiAgICBjb25zdCBwYXJ0VG90YWwgPSBwYXJ0U3RhdHMudG90YWw7XG4gICAgZnJhZ1N0YXRzLmxvYWRlZCArPSBwYXJ0U3RhdHMubG9hZGVkO1xuICAgIGlmIChwYXJ0VG90YWwpIHtcbiAgICAgIGNvbnN0IGVzdFRvdGFsUGFydHMgPSBNYXRoLnJvdW5kKGZyYWcuZHVyYXRpb24gLyBwYXJ0LmR1cmF0aW9uKTtcbiAgICAgIGNvbnN0IGVzdExvYWRlZFBhcnRzID0gTWF0aC5taW4oTWF0aC5yb3VuZChmcmFnU3RhdHMubG9hZGVkIC8gcGFydFRvdGFsKSwgZXN0VG90YWxQYXJ0cyk7XG4gICAgICBjb25zdCBlc3RSZW1haW5pbmdQYXJ0cyA9IGVzdFRvdGFsUGFydHMgLSBlc3RMb2FkZWRQYXJ0cztcbiAgICAgIGNvbnN0IGVzdFJlbWFpbmluZ0J5dGVzID0gZXN0UmVtYWluaW5nUGFydHMgKiBNYXRoLnJvdW5kKGZyYWdTdGF0cy5sb2FkZWQgLyBlc3RMb2FkZWRQYXJ0cyk7XG4gICAgICBmcmFnU3RhdHMudG90YWwgPSBmcmFnU3RhdHMubG9hZGVkICsgZXN0UmVtYWluaW5nQnl0ZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYWdTdGF0cy50b3RhbCA9IE1hdGgubWF4KGZyYWdTdGF0cy5sb2FkZWQsIGZyYWdTdGF0cy50b3RhbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyYWdMb2FkaW5nID0gZnJhZ1N0YXRzLmxvYWRpbmc7XG4gICAgY29uc3QgcGFydExvYWRpbmcgPSBwYXJ0U3RhdHMubG9hZGluZztcbiAgICBpZiAoZnJhZ0xvYWRpbmcuc3RhcnQpIHtcbiAgICAgIC8vIGFkZCB0byBmcmFnbWVudCBsb2FkZXIgbGF0ZW5jeVxuICAgICAgZnJhZ0xvYWRpbmcuZmlyc3QgKz0gcGFydExvYWRpbmcuZmlyc3QgLSBwYXJ0TG9hZGluZy5zdGFydDtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhZ0xvYWRpbmcuc3RhcnQgPSBwYXJ0TG9hZGluZy5zdGFydDtcbiAgICAgIGZyYWdMb2FkaW5nLmZpcnN0ID0gcGFydExvYWRpbmcuZmlyc3Q7XG4gICAgfVxuICAgIGZyYWdMb2FkaW5nLmVuZCA9IHBhcnRMb2FkaW5nLmVuZDtcbiAgfVxuICByZXNldExvYWRlcihmcmFnLCBsb2FkZXIpIHtcbiAgICBmcmFnLmxvYWRlciA9IG51bGw7XG4gICAgaWYgKHRoaXMubG9hZGVyID09PSBsb2FkZXIpIHtcbiAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucGFydExvYWRUaW1lb3V0KTtcbiAgICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgICB9XG4gICAgbG9hZGVyLmRlc3Ryb3koKTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlTG9hZGVyQ29udGV4dChmcmFnLCBwYXJ0ID0gbnVsbCkge1xuICBjb25zdCBzZWdtZW50ID0gcGFydCB8fCBmcmFnO1xuICBjb25zdCBsb2FkZXJDb250ZXh0ID0ge1xuICAgIGZyYWcsXG4gICAgcGFydCxcbiAgICByZXNwb25zZVR5cGU6ICdhcnJheWJ1ZmZlcicsXG4gICAgdXJsOiBzZWdtZW50LnVybCxcbiAgICBoZWFkZXJzOiB7fSxcbiAgICByYW5nZVN0YXJ0OiAwLFxuICAgIHJhbmdlRW5kOiAwXG4gIH07XG4gIGNvbnN0IHN0YXJ0ID0gc2VnbWVudC5ieXRlUmFuZ2VTdGFydE9mZnNldDtcbiAgY29uc3QgZW5kID0gc2VnbWVudC5ieXRlUmFuZ2VFbmRPZmZzZXQ7XG4gIGlmIChpc0Zpbml0ZU51bWJlcihzdGFydCkgJiYgaXNGaW5pdGVOdW1iZXIoZW5kKSkge1xuICAgIHZhciBfZnJhZyRkZWNyeXB0ZGF0YTtcbiAgICBsZXQgYnl0ZVJhbmdlU3RhcnQgPSBzdGFydDtcbiAgICBsZXQgYnl0ZVJhbmdlRW5kID0gZW5kO1xuICAgIGlmIChmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnICYmIGlzTWV0aG9kRnVsbFNlZ21lbnRBZXNDYmMoKF9mcmFnJGRlY3J5cHRkYXRhID0gZnJhZy5kZWNyeXB0ZGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mcmFnJGRlY3J5cHRkYXRhLm1ldGhvZCkpIHtcbiAgICAgIC8vIE1BUCBzZWdtZW50IGVuY3J5cHRlZCB3aXRoIG1ldGhvZCAnQUVTLTEyOCcgb3IgJ0FFUy0yNTYnIChjYmMpLCB3aGVuIHNlcnZlZCB3aXRoIEhUVFAgUmFuZ2UsXG4gICAgICAvLyBoYXMgdGhlIHVuZW5jcnlwdGVkIHNpemUgc3BlY2lmaWVkIGluIHRoZSByYW5nZS5cbiAgICAgIC8vIFJlZjogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LXBhbnRvcy1obHMtcmZjODIxNmJpcy0wOCNzZWN0aW9uLTYuMy42XG4gICAgICBjb25zdCBmcmFnbWVudExlbiA9IGVuZCAtIHN0YXJ0O1xuICAgICAgaWYgKGZyYWdtZW50TGVuICUgMTYpIHtcbiAgICAgICAgYnl0ZVJhbmdlRW5kID0gZW5kICsgKDE2IC0gZnJhZ21lbnRMZW4gJSAxNik7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgIT09IDApIHtcbiAgICAgICAgbG9hZGVyQ29udGV4dC5yZXNldElWID0gdHJ1ZTtcbiAgICAgICAgYnl0ZVJhbmdlU3RhcnQgPSBzdGFydCAtIDE2O1xuICAgICAgfVxuICAgIH1cbiAgICBsb2FkZXJDb250ZXh0LnJhbmdlU3RhcnQgPSBieXRlUmFuZ2VTdGFydDtcbiAgICBsb2FkZXJDb250ZXh0LnJhbmdlRW5kID0gYnl0ZVJhbmdlRW5kO1xuICB9XG4gIHJldHVybiBsb2FkZXJDb250ZXh0O1xufVxuZnVuY3Rpb24gY3JlYXRlR2FwTG9hZEVycm9yKGZyYWcsIHBhcnQpIHtcbiAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYEdBUCAke2ZyYWcuZ2FwID8gJ3RhZycgOiAnYXR0cmlidXRlJ30gZm91bmRgKTtcbiAgY29uc3QgZXJyb3JEYXRhID0ge1xuICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfR0FQLFxuICAgIGZhdGFsOiBmYWxzZSxcbiAgICBmcmFnLFxuICAgIGVycm9yLFxuICAgIG5ldHdvcmtEZXRhaWxzOiBudWxsXG4gIH07XG4gIGlmIChwYXJ0KSB7XG4gICAgZXJyb3JEYXRhLnBhcnQgPSBwYXJ0O1xuICB9XG4gIChwYXJ0ID8gcGFydCA6IGZyYWcpLnN0YXRzLmFib3J0ZWQgPSB0cnVlO1xuICByZXR1cm4gbmV3IExvYWRFcnJvcihlcnJvckRhdGEpO1xufVxuZnVuY3Rpb24gaXNNZXRob2RGdWxsU2VnbWVudEFlc0NiYyhtZXRob2QpIHtcbiAgcmV0dXJuIG1ldGhvZCA9PT0gJ0FFUy0xMjgnIHx8IG1ldGhvZCA9PT0gJ0FFUy0yNTYnO1xufVxuY2xhc3MgTG9hZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoZGF0YS5lcnJvci5tZXNzYWdlKTtcbiAgICB0aGlzLmRhdGEgPSB2b2lkIDA7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxufVxuXG4vKipcbiAqIEBpZ25vcmVcbiAqIFN1Yi1jbGFzcyBzcGVjaWFsaXphdGlvbiBvZiBFdmVudEhhbmRsZXIgYmFzZSBjbGFzcy5cbiAqXG4gKiBUYXNrTG9vcCBhbGxvd3MgdG8gc2NoZWR1bGUgYSB0YXNrIGZ1bmN0aW9uIGJlaW5nIGNhbGxlZCAob3B0aW9ubmFseSByZXBlYXRlZGx5KSBvbiB0aGUgbWFpbiBsb29wLFxuICogc2NoZWR1bGVkIGFzeW5jaHJvbmVvdXNseSwgYXZvaWRpbmcgcmVjdXJzaXZlIGNhbGxzIGluIHRoZSBzYW1lIHRpY2suXG4gKlxuICogVGhlIHRhc2sgaXRzZWxmIGlzIGltcGxlbWVudGVkIGluIGBkb1RpY2tgLiBJdCBjYW4gYmUgcmVxdWVzdGVkIGFuZCBjYWxsZWQgZm9yIHNpbmdsZSBleGVjdXRpb25cbiAqIHVzaW5nIHRoZSBgdGlja2AgbWV0aG9kLlxuICpcbiAqIEl0IHdpbGwgYmUgYXNzdXJlZCB0aGF0IHRoZSB0YXNrIGV4ZWN1dGlvbiBtZXRob2QgKGB0aWNrYCkgb25seSBnZXRzIGNhbGxlZCBvbmNlIHBlciBtYWluIGxvb3AgXCJ0aWNrXCIsXG4gKiBubyBtYXR0ZXIgaG93IG9mdGVuIGl0IGdldHMgcmVxdWVzdGVkIGZvciBleGVjdXRpb24uIEV4ZWN1dGlvbiBpbiBmdXJ0aGVyIHRpY2tzIHdpbGwgYmUgc2NoZWR1bGVkIGFjY29yZGluZ2x5LlxuICpcbiAqIElmIGZ1cnRoZXIgZXhlY3V0aW9uIHJlcXVlc3RzIGhhdmUgYWxyZWFkeSBiZWVuIHNjaGVkdWxlZCBvbiB0aGUgbmV4dCB0aWNrLCBpdCBjYW4gYmUgY2hlY2tlZCB3aXRoIGBoYXNOZXh0VGlja2AsXG4gKiBhbmQgY2FuY2VsbGVkIHdpdGggYGNsZWFyTmV4dFRpY2tgLlxuICpcbiAqIFRoZSB0YXNrIGNhbiBiZSBzY2hlZHVsZWQgYXMgYW4gaW50ZXJ2YWwgcmVwZWF0ZWRseSB3aXRoIGEgcGVyaW9kIGFzIHBhcmFtZXRlciAoc2VlIGBzZXRJbnRlcnZhbGAsIGBjbGVhckludGVydmFsYCkuXG4gKlxuICogU3ViLWNsYXNzZXMgbmVlZCB0byBpbXBsZW1lbnQgdGhlIGBkb1RpY2tgIG1ldGhvZCB3aGljaCB3aWxsIGVmZmVjdGl2ZWx5IGhhdmUgdGhlIHRhc2sgZXhlY3V0aW9uIHJvdXRpbmUuXG4gKlxuICogRnVydGhlciBleHBsYW5hdGlvbnM6XG4gKlxuICogVGhlIGJhc2VjbGFzcyBoYXMgYSBgdGlja2AgbWV0aG9kIHRoYXQgd2lsbCBzY2hlZHVsZSB0aGUgZG9UaWNrIGNhbGwuIEl0IG1heSBiZSBjYWxsZWQgc3luY2hyb25lb3VzbHlcbiAqIG9ubHkgZm9yIGEgc3RhY2stZGVwdGggb2Ygb25lLiBPbiByZS1lbnRyYW50IGNhbGxzLCBzdWItc2VxdWVudCBjYWxscyBhcmUgc2NoZWR1bGVkIGZvciBuZXh0IG1haW4gbG9vcCB0aWNrcy5cbiAqXG4gKiBXaGVuIHRoZSB0YXNrIGV4ZWN1dGlvbiAoYHRpY2tgIG1ldGhvZCkgaXMgY2FsbGVkIGluIHJlLWVudHJhbnQgd2F5IHRoaXMgaXMgZGV0ZWN0ZWQgYW5kXG4gKiB3ZSBhcmUgbGltaXRpbmcgdGhlIHRhc2sgZXhlY3V0aW9uIHBlciBjYWxsIHN0YWNrIHRvIGV4YWN0bHkgb25lLCBidXQgc2NoZWR1bGluZy9wb3N0LXBvbmluZyBmdXJ0aGVyXG4gKiB0YXNrIHByb2Nlc3Npbmcgb24gdGhlIG5leHQgbWFpbiBsb29wIGl0ZXJhdGlvbiAoYWxzbyBrbm93biBhcyBcIm5leHQgdGlja1wiIGluIHRoZSBOb2RlL0pTIHJ1bnRpbWUgbGluZ28pLlxuICovXG5jbGFzcyBUYXNrTG9vcCBleHRlbmRzIExvZ2dlciB7XG4gIGNvbnN0cnVjdG9yKGxhYmVsLCBsb2dnZXIpIHtcbiAgICBzdXBlcihsYWJlbCwgbG9nZ2VyKTtcbiAgICB0aGlzLl9ib3VuZFRpY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5fdGlja1RpbWVyID0gbnVsbDtcbiAgICB0aGlzLl90aWNrSW50ZXJ2YWwgPSBudWxsO1xuICAgIHRoaXMuX3RpY2tDYWxsQ291bnQgPSAwO1xuICAgIHRoaXMuX2JvdW5kVGljayA9IHRoaXMudGljay5iaW5kKHRoaXMpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5vbkhhbmRsZXJEZXN0cm95aW5nKCk7XG4gICAgdGhpcy5vbkhhbmRsZXJEZXN0cm95ZWQoKTtcbiAgfVxuICBvbkhhbmRsZXJEZXN0cm95aW5nKCkge1xuICAgIC8vIGNsZWFyIGFsbCB0aW1lcnMgYmVmb3JlIHVucmVnaXN0ZXJpbmcgZnJvbSBldmVudCBidXNcbiAgICB0aGlzLmNsZWFyTmV4dFRpY2soKTtcbiAgICB0aGlzLmNsZWFySW50ZXJ2YWwoKTtcbiAgfVxuICBvbkhhbmRsZXJEZXN0cm95ZWQoKSB7fVxuICBoYXNJbnRlcnZhbCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl90aWNrSW50ZXJ2YWw7XG4gIH1cbiAgaGFzTmV4dFRpY2soKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fdGlja1RpbWVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBtaWxsaXMgLSBJbnRlcnZhbCB0aW1lIChtcylcbiAgICogQGV0dXJucyBUcnVlIHdoZW4gaW50ZXJ2YWwgaGFzIGJlZW4gc2NoZWR1bGVkLCBmYWxzZSB3aGVuIGFscmVhZHkgc2NoZWR1bGVkIChubyBlZmZlY3QpXG4gICAqL1xuICBzZXRJbnRlcnZhbChtaWxsaXMpIHtcbiAgICBpZiAoIXRoaXMuX3RpY2tJbnRlcnZhbCkge1xuICAgICAgdGhpcy5fdGlja0NhbGxDb3VudCA9IDA7XG4gICAgICB0aGlzLl90aWNrSW50ZXJ2YWwgPSBzZWxmLnNldEludGVydmFsKHRoaXMuX2JvdW5kVGljaywgbWlsbGlzKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgVHJ1ZSB3aGVuIGludGVydmFsIHdhcyBjbGVhcmVkLCBmYWxzZSB3aGVuIG5vbmUgd2FzIHNldCAobm8gZWZmZWN0KVxuICAgKi9cbiAgY2xlYXJJbnRlcnZhbCgpIHtcbiAgICBpZiAodGhpcy5fdGlja0ludGVydmFsKSB7XG4gICAgICBzZWxmLmNsZWFySW50ZXJ2YWwodGhpcy5fdGlja0ludGVydmFsKTtcbiAgICAgIHRoaXMuX3RpY2tJbnRlcnZhbCA9IG51bGw7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIFRydWUgd2hlbiB0aW1lb3V0IHdhcyBjbGVhcmVkLCBmYWxzZSB3aGVuIG5vbmUgd2FzIHNldCAobm8gZWZmZWN0KVxuICAgKi9cbiAgY2xlYXJOZXh0VGljaygpIHtcbiAgICBpZiAodGhpcy5fdGlja1RpbWVyKSB7XG4gICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLl90aWNrVGltZXIpO1xuICAgICAgdGhpcy5fdGlja1RpbWVyID0gbnVsbDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogV2lsbCBjYWxsIHRoZSBzdWJjbGFzcyBkb1RpY2sgaW1wbGVtZW50YXRpb24gaW4gdGhpcyBtYWluIGxvb3AgdGlja1xuICAgKiBvciBpbiB0aGUgbmV4dCBvbmUgKHZpYSBzZXRUaW1lb3V0KCwwKSkgaW4gY2FzZSBpdCBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZFxuICAgKiBpbiB0aGlzIHRpY2sgKGluIGNhc2UgdGhpcyBpcyBhIHJlLWVudHJhbnQgY2FsbCkuXG4gICAqL1xuICB0aWNrKCkge1xuICAgIHRoaXMuX3RpY2tDYWxsQ291bnQrKztcbiAgICBpZiAodGhpcy5fdGlja0NhbGxDb3VudCA9PT0gMSkge1xuICAgICAgdGhpcy5kb1RpY2soKTtcbiAgICAgIC8vIHJlLWVudHJhbnQgY2FsbCB0byB0aWNrIGZyb20gcHJldmlvdXMgZG9UaWNrIGNhbGwgc3RhY2tcbiAgICAgIC8vIC0+IHNjaGVkdWxlIGEgY2FsbCBvbiB0aGUgbmV4dCBtYWluIGxvb3AgaXRlcmF0aW9uIHRvIHByb2Nlc3MgdGhpcyB0YXNrIHByb2Nlc3NpbmcgcmVxdWVzdFxuICAgICAgaWYgKHRoaXMuX3RpY2tDYWxsQ291bnQgPiAxKSB7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSBvbmx5IG9uZSB0aW1lciBleGlzdHMgYXQgYW55IHRpbWUgYXQgbWF4XG4gICAgICAgIHRoaXMudGlja0ltbWVkaWF0ZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fdGlja0NhbGxDb3VudCA9IDA7XG4gICAgfVxuICB9XG4gIHRpY2tJbW1lZGlhdGUoKSB7XG4gICAgdGhpcy5jbGVhck5leHRUaWNrKCk7XG4gICAgdGhpcy5fdGlja1RpbWVyID0gc2VsZi5zZXRUaW1lb3V0KHRoaXMuX2JvdW5kVGljaywgMCk7XG4gIH1cblxuICAvKipcbiAgICogRm9yIHN1YmNsYXNzIHRvIGltcGxlbWVudCB0YXNrIGxvZ2ljXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgZG9UaWNrKCkge31cbn1cblxuY2xhc3MgQ2h1bmtNZXRhZGF0YSB7XG4gIGNvbnN0cnVjdG9yKGxldmVsLCBzbiwgaWQsIHNpemUgPSAwLCBwYXJ0ID0gLTEsIHBhcnRpYWwgPSBmYWxzZSkge1xuICAgIHRoaXMubGV2ZWwgPSB2b2lkIDA7XG4gICAgdGhpcy5zbiA9IHZvaWQgMDtcbiAgICB0aGlzLnBhcnQgPSB2b2lkIDA7XG4gICAgdGhpcy5pZCA9IHZvaWQgMDtcbiAgICB0aGlzLnNpemUgPSB2b2lkIDA7XG4gICAgdGhpcy5wYXJ0aWFsID0gdm9pZCAwO1xuICAgIHRoaXMudHJhbnNtdXhpbmcgPSBnZXROZXdQZXJmb3JtYW5jZVRpbWluZygpO1xuICAgIHRoaXMuYnVmZmVyaW5nID0ge1xuICAgICAgYXVkaW86IGdldE5ld1BlcmZvcm1hbmNlVGltaW5nKCksXG4gICAgICB2aWRlbzogZ2V0TmV3UGVyZm9ybWFuY2VUaW1pbmcoKSxcbiAgICAgIGF1ZGlvdmlkZW86IGdldE5ld1BlcmZvcm1hbmNlVGltaW5nKClcbiAgICB9O1xuICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICB0aGlzLnNuID0gc247XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgdGhpcy5wYXJ0ID0gcGFydDtcbiAgICB0aGlzLnBhcnRpYWwgPSBwYXJ0aWFsO1xuICB9XG59XG5mdW5jdGlvbiBnZXROZXdQZXJmb3JtYW5jZVRpbWluZygpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogMCxcbiAgICBleGVjdXRlU3RhcnQ6IDAsXG4gICAgZXhlY3V0ZUVuZDogMCxcbiAgICBlbmQ6IDBcbiAgfTtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBtZXRob2RzIGRlYWxpbmcgd2l0aCBidWZmZXIgbGVuZ3RoIHJldHJpZXZhbCBmb3IgZXhhbXBsZS5cbiAqXG4gKiBJbiBnZW5lcmFsLCBhIGhlbHBlciBhcm91bmQgSFRNTDUgTWVkaWFFbGVtZW50IFRpbWVSYW5nZXMgZ2F0aGVyZWQgZnJvbSBgYnVmZmVyZWRgIHByb3BlcnR5LlxuICpcbiAqIEFsc28gQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTE1lZGlhRWxlbWVudC9idWZmZXJlZFxuICovXG5cbmNvbnN0IG5vb3BCdWZmZXJlZCA9IHtcbiAgbGVuZ3RoOiAwLFxuICBzdGFydDogKCkgPT4gMCxcbiAgZW5kOiAoKSA9PiAwXG59O1xuY2xhc3MgQnVmZmVySGVscGVyIHtcbiAgLyoqXG4gICAqIFJldHVybiB0cnVlIGlmIGBtZWRpYWAncyBidWZmZXJlZCBpbmNsdWRlIGBwb3NpdGlvbmBcbiAgICovXG4gIHN0YXRpYyBpc0J1ZmZlcmVkKG1lZGlhLCBwb3NpdGlvbikge1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgY29uc3QgYnVmZmVyZWQgPSBCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQobWVkaWEpO1xuICAgICAgZm9yIChsZXQgaSA9IGJ1ZmZlcmVkLmxlbmd0aDsgaS0tOykge1xuICAgICAgICBpZiAocG9zaXRpb24gPj0gYnVmZmVyZWQuc3RhcnQoaSkgJiYgcG9zaXRpb24gPD0gYnVmZmVyZWQuZW5kKGkpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YXRpYyBidWZmZXJlZFJhbmdlcyhtZWRpYSkge1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgY29uc3QgdGltZVJhbmdlcyA9IEJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZChtZWRpYSk7XG4gICAgICByZXR1cm4gQnVmZmVySGVscGVyLnRpbWVSYW5nZXNUb0FycmF5KHRpbWVSYW5nZXMpO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cbiAgc3RhdGljIHRpbWVSYW5nZXNUb0FycmF5KHRpbWVSYW5nZXMpIHtcbiAgICBjb25zdCBidWZmZXJlZCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGltZVJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgYnVmZmVyZWQucHVzaCh7XG4gICAgICAgIHN0YXJ0OiB0aW1lUmFuZ2VzLnN0YXJ0KGkpLFxuICAgICAgICBlbmQ6IHRpbWVSYW5nZXMuZW5kKGkpXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlcmVkO1xuICB9XG4gIHN0YXRpYyBidWZmZXJJbmZvKG1lZGlhLCBwb3MsIG1heEhvbGVEdXJhdGlvbikge1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgY29uc3QgYnVmZmVyZWQgPSBCdWZmZXJIZWxwZXIuYnVmZmVyZWRSYW5nZXMobWVkaWEpO1xuICAgICAgaWYgKGJ1ZmZlcmVkLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gQnVmZmVySGVscGVyLmJ1ZmZlcmVkSW5mbyhidWZmZXJlZCwgcG9zLCBtYXhIb2xlRHVyYXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbGVuOiAwLFxuICAgICAgc3RhcnQ6IHBvcyxcbiAgICAgIGVuZDogcG9zLFxuICAgICAgYnVmZmVyZWRJbmRleDogLTFcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBidWZmZXJlZEluZm8oYnVmZmVyZWQsIHBvcywgbWF4SG9sZUR1cmF0aW9uKSB7XG4gICAgcG9zID0gTWF0aC5tYXgoMCwgcG9zKTtcbiAgICAvLyBzb3J0IG9uIGJ1ZmZlci5zdGFydC9zbWFsbGVyIGVuZCAoSUUgZG9lcyBub3QgYWx3YXlzIHJldHVybiBzb3J0ZWQgYnVmZmVyZWQgcmFuZ2UpXG4gICAgaWYgKGJ1ZmZlcmVkLmxlbmd0aCA+IDEpIHtcbiAgICAgIGJ1ZmZlcmVkLnNvcnQoKGEsIGIpID0+IGEuc3RhcnQgLSBiLnN0YXJ0IHx8IGIuZW5kIC0gYS5lbmQpO1xuICAgIH1cbiAgICBsZXQgYnVmZmVyZWRJbmRleCA9IC0xO1xuICAgIGxldCBidWZmZXJlZDIgPSBbXTtcbiAgICBpZiAobWF4SG9sZUR1cmF0aW9uKSB7XG4gICAgICAvLyB0aGVyZSBtaWdodCBiZSBzb21lIHNtYWxsIGhvbGVzIGJldHdlZW4gYnVmZmVyIHRpbWUgcmFuZ2VcbiAgICAgIC8vIGNvbnNpZGVyIHRoYXQgaG9sZXMgc21hbGxlciB0aGFuIG1heEhvbGVEdXJhdGlvbiBhcmUgaXJyZWxldmFudCBhbmQgYnVpbGQgYW5vdGhlclxuICAgICAgLy8gYnVmZmVyIHRpbWUgcmFuZ2UgcmVwcmVzZW50YXRpb25zIHRoYXQgZGlzY2FyZHMgdGhvc2UgaG9sZXNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHBvcyA+PSBidWZmZXJlZFtpXS5zdGFydCAmJiBwb3MgPD0gYnVmZmVyZWRbaV0uZW5kKSB7XG4gICAgICAgICAgYnVmZmVyZWRJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnVmMmxlbiA9IGJ1ZmZlcmVkMi5sZW5ndGg7XG4gICAgICAgIGlmIChidWYybGVuKSB7XG4gICAgICAgICAgY29uc3QgYnVmMmVuZCA9IGJ1ZmZlcmVkMltidWYybGVuIC0gMV0uZW5kO1xuICAgICAgICAgIC8vIGlmIHNtYWxsIGhvbGUgKHZhbHVlIGJldHdlZW4gMCBvciBtYXhIb2xlRHVyYXRpb24gKSBvciBvdmVybGFwcGluZyAobmVnYXRpdmUpXG4gICAgICAgICAgaWYgKGJ1ZmZlcmVkW2ldLnN0YXJ0IC0gYnVmMmVuZCA8IG1heEhvbGVEdXJhdGlvbikge1xuICAgICAgICAgICAgLy8gbWVyZ2Ugb3ZlcmxhcHBpbmcgdGltZSByYW5nZXNcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBsYXN0UmFuZ2UuZW5kIG9ubHkgaWYgc21hbGxlciB0aGFuIGl0ZW0uZW5kXG4gICAgICAgICAgICAvLyBlLmcuICBbIDEsIDE1XSB3aXRoICBbIDIsOF0gPT4gWyAxLDE1XSAobm8gbmVlZCB0byBtb2RpZnkgbGFzdFJhbmdlLmVuZClcbiAgICAgICAgICAgIC8vIHdoZXJlYXMgWyAxLCA4XSB3aXRoICBbIDIsMTVdID0+IFsgMSwxNV0gKCBsYXN0UmFuZ2Ugc2hvdWxkIHN3aXRjaCBmcm9tIFsxLDhdIHRvIFsxLDE1XSlcbiAgICAgICAgICAgIGlmIChidWZmZXJlZFtpXS5lbmQgPiBidWYyZW5kKSB7XG4gICAgICAgICAgICAgIGJ1ZmZlcmVkMltidWYybGVuIC0gMV0uZW5kID0gYnVmZmVyZWRbaV0uZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBiaWcgaG9sZVxuICAgICAgICAgICAgYnVmZmVyZWQyLnB1c2goYnVmZmVyZWRbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBmaXJzdCB2YWx1ZVxuICAgICAgICAgIGJ1ZmZlcmVkMi5wdXNoKGJ1ZmZlcmVkW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBidWZmZXJlZDIgPSBidWZmZXJlZDtcbiAgICB9XG4gICAgbGV0IGJ1ZmZlckxlbiA9IDA7XG4gICAgbGV0IG5leHRTdGFydDtcblxuICAgIC8vIGJ1ZmZlclN0YXJ0IGFuZCBidWZmZXJFbmQgYXJlIGJ1ZmZlciBib3VuZGFyaWVzIGFyb3VuZCBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uIChwb3MpXG4gICAgbGV0IGJ1ZmZlclN0YXJ0ID0gcG9zO1xuICAgIGxldCBidWZmZXJFbmQgPSBwb3M7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXJlZDIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gYnVmZmVyZWQyW2ldLnN0YXJ0O1xuICAgICAgY29uc3QgZW5kID0gYnVmZmVyZWQyW2ldLmVuZDtcbiAgICAgIC8vIGxvZ2dlci5sb2coJ2J1ZiBzdGFydC9lbmQ6JyArIGJ1ZmZlcmVkLnN0YXJ0KGkpICsgJy8nICsgYnVmZmVyZWQuZW5kKGkpKTtcbiAgICAgIGlmIChidWZmZXJlZEluZGV4ID09PSAtMSAmJiBwb3MgPj0gc3RhcnQgJiYgcG9zIDw9IGVuZCkge1xuICAgICAgICBidWZmZXJlZEluZGV4ID0gaTtcbiAgICAgIH1cbiAgICAgIGlmIChwb3MgKyBtYXhIb2xlRHVyYXRpb24gPj0gc3RhcnQgJiYgcG9zIDwgZW5kKSB7XG4gICAgICAgIC8vIHBsYXkgcG9zaXRpb24gaXMgaW5zaWRlIHRoaXMgYnVmZmVyIFRpbWVSYW5nZSwgcmV0cmlldmUgZW5kIG9mIGJ1ZmZlciBwb3NpdGlvbiBhbmQgYnVmZmVyIGxlbmd0aFxuICAgICAgICBidWZmZXJTdGFydCA9IHN0YXJ0O1xuICAgICAgICBidWZmZXJFbmQgPSBlbmQ7XG4gICAgICAgIGJ1ZmZlckxlbiA9IGJ1ZmZlckVuZCAtIHBvcztcbiAgICAgIH0gZWxzZSBpZiAocG9zICsgbWF4SG9sZUR1cmF0aW9uIDwgc3RhcnQpIHtcbiAgICAgICAgbmV4dFN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbGVuOiBidWZmZXJMZW4sXG4gICAgICBzdGFydDogYnVmZmVyU3RhcnQgfHwgMCxcbiAgICAgIGVuZDogYnVmZmVyRW5kIHx8IDAsXG4gICAgICBuZXh0U3RhcnQsXG4gICAgICBidWZmZXJlZCxcbiAgICAgIGJ1ZmZlcmVkSW5kZXhcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNhZmUgbWV0aG9kIHRvIGdldCBidWZmZXJlZCBwcm9wZXJ0eS5cbiAgICogU291cmNlQnVmZmVyLmJ1ZmZlcmVkIG1heSB0aHJvdyBpZiBTb3VyY2VCdWZmZXIgaXMgcmVtb3ZlZCBmcm9tIGl0J3MgTWVkaWFTb3VyY2VcbiAgICovXG4gIHN0YXRpYyBnZXRCdWZmZXJlZChtZWRpYSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbWVkaWEuYnVmZmVyZWQgfHwgbm9vcEJ1ZmZlcmVkO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ2dlci5sb2coJ2ZhaWxlZCB0byBnZXQgbWVkaWEuYnVmZmVyZWQnLCBlKTtcbiAgICAgIHJldHVybiBub29wQnVmZmVyZWQ7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IFZBUklBQkxFX1JFUExBQ0VNRU5UX1JFR0VYID0gL1xce1xcJChbYS16QS1aMC05LV9dKylcXH0vZztcbmZ1bmN0aW9uIGhhc1ZhcmlhYmxlUmVmZXJlbmNlcyhzdHIpIHtcbiAgcmV0dXJuIFZBUklBQkxFX1JFUExBQ0VNRU5UX1JFR0VYLnRlc3Qoc3RyKTtcbn1cbmZ1bmN0aW9uIHN1YnN0aXR1dGVWYXJpYWJsZXMocGFyc2VkLCB2YWx1ZSkge1xuICBpZiAocGFyc2VkLnZhcmlhYmxlTGlzdCAhPT0gbnVsbCB8fCBwYXJzZWQuaGFzVmFyaWFibGVSZWZzKSB7XG4gICAgY29uc3QgdmFyaWFibGVMaXN0ID0gcGFyc2VkLnZhcmlhYmxlTGlzdDtcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZShWQVJJQUJMRV9SRVBMQUNFTUVOVF9SRUdFWCwgdmFyaWFibGVSZWZlcmVuY2UgPT4ge1xuICAgICAgY29uc3QgdmFyaWFibGVOYW1lID0gdmFyaWFibGVSZWZlcmVuY2Uuc3Vic3RyaW5nKDIsIHZhcmlhYmxlUmVmZXJlbmNlLmxlbmd0aCAtIDEpO1xuICAgICAgY29uc3QgdmFyaWFibGVWYWx1ZSA9IHZhcmlhYmxlTGlzdCA9PSBudWxsID8gdm9pZCAwIDogdmFyaWFibGVMaXN0W3ZhcmlhYmxlTmFtZV07XG4gICAgICBpZiAodmFyaWFibGVWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcnNlZC5wbGF5bGlzdFBhcnNpbmdFcnJvciB8fCAocGFyc2VkLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKGBNaXNzaW5nIHByZWNlZGluZyBFWFQtWC1ERUZJTkUgdGFnIGZvciBWYXJpYWJsZSBSZWZlcmVuY2U6IFwiJHt2YXJpYWJsZU5hbWV9XCJgKSk7XG4gICAgICAgIHJldHVybiB2YXJpYWJsZVJlZmVyZW5jZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YXJpYWJsZVZhbHVlO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGFkZFZhcmlhYmxlRGVmaW5pdGlvbihwYXJzZWQsIGF0dHIsIHBhcmVudFVybCkge1xuICBsZXQgdmFyaWFibGVMaXN0ID0gcGFyc2VkLnZhcmlhYmxlTGlzdDtcbiAgaWYgKCF2YXJpYWJsZUxpc3QpIHtcbiAgICBwYXJzZWQudmFyaWFibGVMaXN0ID0gdmFyaWFibGVMaXN0ID0ge307XG4gIH1cbiAgbGV0IE5BTUU7XG4gIGxldCBWQUxVRTtcbiAgaWYgKCdRVUVSWVBBUkFNJyBpbiBhdHRyKSB7XG4gICAgTkFNRSA9IGF0dHIuUVVFUllQQVJBTTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2VhcmNoUGFyYW1zID0gbmV3IHNlbGYuVVJMKHBhcmVudFVybCkuc2VhcmNoUGFyYW1zO1xuICAgICAgaWYgKHNlYXJjaFBhcmFtcy5oYXMoTkFNRSkpIHtcbiAgICAgICAgVkFMVUUgPSBzZWFyY2hQYXJhbXMuZ2V0KE5BTUUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7TkFNRX1cIiBkb2VzIG5vdCBtYXRjaCBhbnkgcXVlcnkgcGFyYW1ldGVyIGluIFVSSTogXCIke3BhcmVudFVybH1cImApO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBwYXJzZWQucGxheWxpc3RQYXJzaW5nRXJyb3IgfHwgKHBhcnNlZC5wbGF5bGlzdFBhcnNpbmdFcnJvciA9IG5ldyBFcnJvcihgRVhULVgtREVGSU5FIFFVRVJZUEFSQU06ICR7ZXJyb3IubWVzc2FnZX1gKSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIE5BTUUgPSBhdHRyLk5BTUU7XG4gICAgVkFMVUUgPSBhdHRyLlZBTFVFO1xuICB9XG4gIGlmIChOQU1FIGluIHZhcmlhYmxlTGlzdCkge1xuICAgIHBhcnNlZC5wbGF5bGlzdFBhcnNpbmdFcnJvciB8fCAocGFyc2VkLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKGBFWFQtWC1ERUZJTkUgZHVwbGljYXRlIFZhcmlhYmxlIE5hbWUgZGVjbGFyYXRpb25zOiBcIiR7TkFNRX1cImApKTtcbiAgfSBlbHNlIHtcbiAgICB2YXJpYWJsZUxpc3RbTkFNRV0gPSBWQUxVRSB8fCAnJztcbiAgfVxufVxuZnVuY3Rpb24gaW1wb3J0VmFyaWFibGVEZWZpbml0aW9uKHBhcnNlZCwgYXR0ciwgc291cmNlVmFyaWFibGVMaXN0KSB7XG4gIGNvbnN0IElNUE9SVCA9IGF0dHIuSU1QT1JUO1xuICBpZiAoc291cmNlVmFyaWFibGVMaXN0ICYmIElNUE9SVCBpbiBzb3VyY2VWYXJpYWJsZUxpc3QpIHtcbiAgICBsZXQgdmFyaWFibGVMaXN0ID0gcGFyc2VkLnZhcmlhYmxlTGlzdDtcbiAgICBpZiAoIXZhcmlhYmxlTGlzdCkge1xuICAgICAgcGFyc2VkLnZhcmlhYmxlTGlzdCA9IHZhcmlhYmxlTGlzdCA9IHt9O1xuICAgIH1cbiAgICB2YXJpYWJsZUxpc3RbSU1QT1JUXSA9IHNvdXJjZVZhcmlhYmxlTGlzdFtJTVBPUlRdO1xuICB9IGVsc2Uge1xuICAgIHBhcnNlZC5wbGF5bGlzdFBhcnNpbmdFcnJvciB8fCAocGFyc2VkLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKGBFWFQtWC1ERUZJTkUgSU1QT1JUIGF0dHJpYnV0ZSBub3QgZm91bmQgaW4gTXVsdGl2YXJpYW50IFBsYXlsaXN0OiBcIiR7SU1QT1JUfVwiYCkpO1xuICB9XG59XG5cbmNvbnN0IERFQ0lNQUxfUkVTT0xVVElPTl9SRUdFWCA9IC9eKFxcZCspeChcXGQrKSQvO1xuY29uc3QgQVRUUl9MSVNUX1JFR0VYID0gLyguKz8pPShcIi4qP1wifC4qPykoPzosfCQpL2c7XG5cbi8vIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20va2Fub25naWwvbm9kZS1tM3U4cGFyc2UvYmxvYi9tYXN0ZXIvYXR0cmxpc3QuanNcbmNsYXNzIEF0dHJMaXN0IHtcbiAgY29uc3RydWN0b3IoYXR0cnMsIHBhcnNlZCkge1xuICAgIGlmICh0eXBlb2YgYXR0cnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBhdHRycyA9IEF0dHJMaXN0LnBhcnNlQXR0ckxpc3QoYXR0cnMsIHBhcnNlZCk7XG4gICAgfVxuICAgIF9leHRlbmRzKHRoaXMsIGF0dHJzKTtcbiAgfVxuICBnZXQgY2xpZW50QXR0cnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMpLmZpbHRlcihhdHRyID0+IGF0dHIuc3Vic3RyaW5nKDAsIDIpID09PSAnWC0nKTtcbiAgfVxuICBkZWNpbWFsSW50ZWdlcihhdHRyTmFtZSkge1xuICAgIGNvbnN0IGludFZhbHVlID0gcGFyc2VJbnQodGhpc1thdHRyTmFtZV0sIDEwKTtcbiAgICBpZiAoaW50VmFsdWUgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cbiAgICByZXR1cm4gaW50VmFsdWU7XG4gIH1cbiAgaGV4YWRlY2ltYWxJbnRlZ2VyKGF0dHJOYW1lKSB7XG4gICAgaWYgKHRoaXNbYXR0ck5hbWVdKSB7XG4gICAgICBsZXQgc3RyaW5nVmFsdWUgPSAodGhpc1thdHRyTmFtZV0gfHwgJzB4Jykuc2xpY2UoMik7XG4gICAgICBzdHJpbmdWYWx1ZSA9IChzdHJpbmdWYWx1ZS5sZW5ndGggJiAxID8gJzAnIDogJycpICsgc3RyaW5nVmFsdWU7XG4gICAgICBjb25zdCB2YWx1ZSA9IG5ldyBVaW50OEFycmF5KHN0cmluZ1ZhbHVlLmxlbmd0aCAvIDIpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmdWYWx1ZS5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgdmFsdWVbaV0gPSBwYXJzZUludChzdHJpbmdWYWx1ZS5zbGljZShpICogMiwgaSAqIDIgKyAyKSwgMTYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBoZXhhZGVjaW1hbEludGVnZXJBc051bWJlcihhdHRyTmFtZSkge1xuICAgIGNvbnN0IGludFZhbHVlID0gcGFyc2VJbnQodGhpc1thdHRyTmFtZV0sIDE2KTtcbiAgICBpZiAoaW50VmFsdWUgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cbiAgICByZXR1cm4gaW50VmFsdWU7XG4gIH1cbiAgZGVjaW1hbEZsb2F0aW5nUG9pbnQoYXR0ck5hbWUpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh0aGlzW2F0dHJOYW1lXSk7XG4gIH1cbiAgb3B0aW9uYWxGbG9hdChhdHRyTmFtZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzW2F0dHJOYW1lXTtcbiAgICByZXR1cm4gdmFsdWUgPyBwYXJzZUZsb2F0KHZhbHVlKSA6IGRlZmF1bHRWYWx1ZTtcbiAgfVxuICBlbnVtZXJhdGVkU3RyaW5nKGF0dHJOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXNbYXR0ck5hbWVdO1xuICB9XG4gIGVudW1lcmF0ZWRTdHJpbmdMaXN0KGF0dHJOYW1lLCBkaWN0KSB7XG4gICAgY29uc3QgYXR0clZhbHVlID0gdGhpc1thdHRyTmFtZV07XG4gICAgcmV0dXJuIChhdHRyVmFsdWUgPyBhdHRyVmFsdWUuc3BsaXQoL1sgLF0rLykgOiBbXSkucmVkdWNlKChyZXN1bHQsIGlkZW50aWZpZXIpID0+IHtcbiAgICAgIHJlc3VsdFtpZGVudGlmaWVyLnRvTG93ZXJDYXNlKCldID0gdHJ1ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgZGljdCk7XG4gIH1cbiAgYm9vbChhdHRyTmFtZSkge1xuICAgIHJldHVybiB0aGlzW2F0dHJOYW1lXSA9PT0gJ1lFUyc7XG4gIH1cbiAgZGVjaW1hbFJlc29sdXRpb24oYXR0ck5hbWUpIHtcbiAgICBjb25zdCByZXMgPSBERUNJTUFMX1JFU09MVVRJT05fUkVHRVguZXhlYyh0aGlzW2F0dHJOYW1lXSk7XG4gICAgaWYgKHJlcyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBwYXJzZUludChyZXNbMV0sIDEwKSxcbiAgICAgIGhlaWdodDogcGFyc2VJbnQocmVzWzJdLCAxMClcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBwYXJzZUF0dHJMaXN0KGlucHV0LCBwYXJzZWQpIHtcbiAgICBsZXQgbWF0Y2g7XG4gICAgY29uc3QgYXR0cnMgPSB7fTtcbiAgICBjb25zdCBxdW90ZSA9ICdcIic7XG4gICAgQVRUUl9MSVNUX1JFR0VYLmxhc3RJbmRleCA9IDA7XG4gICAgd2hpbGUgKChtYXRjaCA9IEFUVFJfTElTVF9SRUdFWC5leGVjKGlucHV0KSkgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBtYXRjaFsxXS50cmltKCk7XG4gICAgICBsZXQgdmFsdWUgPSBtYXRjaFsyXTtcbiAgICAgIGNvbnN0IHF1b3RlZFN0cmluZyA9IHZhbHVlLmluZGV4T2YocXVvdGUpID09PSAwICYmIHZhbHVlLmxhc3RJbmRleE9mKHF1b3RlKSA9PT0gdmFsdWUubGVuZ3RoIC0gMTtcbiAgICAgIGxldCBoZXhhZGVjaW1hbFNlcXVlbmNlID0gZmFsc2U7XG4gICAgICBpZiAocXVvdGVkU3RyaW5nKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMSwgLTEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgY2FzZSAnSVYnOlxuICAgICAgICAgIGNhc2UgJ1NDVEUzNS1DTUQnOlxuICAgICAgICAgIGNhc2UgJ1NDVEUzNS1JTic6XG4gICAgICAgICAgY2FzZSAnU0NURTM1LU9VVCc6XG4gICAgICAgICAgICBoZXhhZGVjaW1hbFNlcXVlbmNlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBhcnNlZCAmJiAocXVvdGVkU3RyaW5nIHx8IGhleGFkZWNpbWFsU2VxdWVuY2UpKSB7XG4gICAgICAgIHtcbiAgICAgICAgICB2YWx1ZSA9IHN1YnN0aXR1dGVWYXJpYWJsZXMocGFyc2VkLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWhleGFkZWNpbWFsU2VxdWVuY2UgJiYgIXF1b3RlZFN0cmluZykge1xuICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICBjYXNlICdDTE9TRUQtQ0FQVElPTlMnOlxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAnTk9ORScpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICAgIGNhc2UgJ0FMTE9XRUQtQ1BDJzpcbiAgICAgICAgICBjYXNlICdDTEFTUyc6XG4gICAgICAgICAgY2FzZSAnQVNTT0MtTEFOR1VBR0UnOlxuICAgICAgICAgIGNhc2UgJ0FVRElPJzpcbiAgICAgICAgICBjYXNlICdCWVRFUkFOR0UnOlxuICAgICAgICAgIGNhc2UgJ0NIQU5ORUxTJzpcbiAgICAgICAgICBjYXNlICdDSEFSQUNURVJJU1RJQ1MnOlxuICAgICAgICAgIGNhc2UgJ0NPREVDUyc6XG4gICAgICAgICAgY2FzZSAnREFUQS1JRCc6XG4gICAgICAgICAgY2FzZSAnRU5ELURBVEUnOlxuICAgICAgICAgIGNhc2UgJ0dST1VQLUlEJzpcbiAgICAgICAgICBjYXNlICdJRCc6XG4gICAgICAgICAgY2FzZSAnSU1QT1JUJzpcbiAgICAgICAgICBjYXNlICdJTlNUUkVBTS1JRCc6XG4gICAgICAgICAgY2FzZSAnS0VZRk9STUFUJzpcbiAgICAgICAgICBjYXNlICdLRVlGT1JNQVRWRVJTSU9OUyc6XG4gICAgICAgICAgY2FzZSAnTEFOR1VBR0UnOlxuICAgICAgICAgIGNhc2UgJ05BTUUnOlxuICAgICAgICAgIGNhc2UgJ1BBVEhXQVktSUQnOlxuICAgICAgICAgIGNhc2UgJ1FVRVJZUEFSQU0nOlxuICAgICAgICAgIGNhc2UgJ1JFQ0VOVExZLVJFTU9WRUQtREFURVJBTkdFUyc6XG4gICAgICAgICAgY2FzZSAnU0VSVkVSLVVSSSc6XG4gICAgICAgICAgY2FzZSAnU1RBQkxFLVJFTkRJVElPTi1JRCc6XG4gICAgICAgICAgY2FzZSAnU1RBQkxFLVZBUklBTlQtSUQnOlxuICAgICAgICAgIGNhc2UgJ1NUQVJULURBVEUnOlxuICAgICAgICAgIGNhc2UgJ1NVQlRJVExFUyc6XG4gICAgICAgICAgY2FzZSAnU1VQUExFTUVOVEFMLUNPREVDUyc6XG4gICAgICAgICAgY2FzZSAnVVJJJzpcbiAgICAgICAgICBjYXNlICdWQUxVRSc6XG4gICAgICAgICAgY2FzZSAnVklERU8nOlxuICAgICAgICAgIGNhc2UgJ1gtQVNTRVQtTElTVCc6XG4gICAgICAgICAgY2FzZSAnWC1BU1NFVC1VUkknOlxuICAgICAgICAgICAgLy8gU2luY2Ugd2UgYXJlIG5vdCBjaGVja2luZyB0YWc6YXR0cmlidXRlIGNvbWJpbmF0aW9uLCBqdXN0IHdhcm4gcmF0aGVyIHRoYW4gaWdub3JpbmcgYXR0cmlidXRlXG4gICAgICAgICAgICBsb2dnZXIud2FybihgJHtpbnB1dH06IGF0dHJpYnV0ZSAke25hbWV9IGlzIG1pc3NpbmcgcXVvdGVzYCk7XG4gICAgICAgICAgLy8gY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGF0dHJzW25hbWVdID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBhdHRycztcbiAgfVxufVxuXG4vLyBBdm9pZCBleHBvcnRpbmcgY29uc3QgZW51bSBzbyB0aGF0IHRoZXNlIHZhbHVlcyBjYW4gYmUgaW5saW5lZFxuXG5jb25zdCBDTEFTU19JTlRFUlNUSVRJQUwgPSAnY29tLmFwcGxlLmhscy5pbnRlcnN0aXRpYWwnO1xuZnVuY3Rpb24gaXNEYXRlUmFuZ2VDdWVBdHRyaWJ1dGUoYXR0ck5hbWUpIHtcbiAgcmV0dXJuIGF0dHJOYW1lICE9PSBcIklEXCIgJiYgYXR0ck5hbWUgIT09IFwiQ0xBU1NcIiAmJiBhdHRyTmFtZSAhPT0gXCJDVUVcIiAmJiBhdHRyTmFtZSAhPT0gXCJTVEFSVC1EQVRFXCIgJiYgYXR0ck5hbWUgIT09IFwiRFVSQVRJT05cIiAmJiBhdHRyTmFtZSAhPT0gXCJFTkQtREFURVwiICYmIGF0dHJOYW1lICE9PSBcIkVORC1PTi1ORVhUXCI7XG59XG5mdW5jdGlvbiBpc1NDVEUzNUF0dHJpYnV0ZShhdHRyTmFtZSkge1xuICByZXR1cm4gYXR0ck5hbWUgPT09IFwiU0NURTM1LU9VVFwiIHx8IGF0dHJOYW1lID09PSBcIlNDVEUzNS1JTlwiIHx8IGF0dHJOYW1lID09PSBcIlNDVEUzNS1DTURcIjtcbn1cbmNsYXNzIERhdGVSYW5nZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGVSYW5nZUF0dHIsIGRhdGVSYW5nZVdpdGhTYW1lSWQsIHRhZ0NvdW50ID0gMCkge1xuICAgIHZhciBfZGF0ZVJhbmdlV2l0aFNhbWVJZCQ7XG4gICAgdGhpcy5hdHRyID0gdm9pZCAwO1xuICAgIHRoaXMudGFnQW5jaG9yID0gdm9pZCAwO1xuICAgIHRoaXMudGFnT3JkZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5fc3RhcnREYXRlID0gdm9pZCAwO1xuICAgIHRoaXMuX2VuZERhdGUgPSB2b2lkIDA7XG4gICAgdGhpcy5fZGF0ZUF0RW5kID0gdm9pZCAwO1xuICAgIHRoaXMuX2N1ZSA9IHZvaWQgMDtcbiAgICB0aGlzLl9iYWRWYWx1ZUZvclNhbWVJZCA9IHZvaWQgMDtcbiAgICB0aGlzLnRhZ0FuY2hvciA9IChkYXRlUmFuZ2VXaXRoU2FtZUlkID09IG51bGwgPyB2b2lkIDAgOiBkYXRlUmFuZ2VXaXRoU2FtZUlkLnRhZ0FuY2hvcikgfHwgbnVsbDtcbiAgICB0aGlzLnRhZ09yZGVyID0gKF9kYXRlUmFuZ2VXaXRoU2FtZUlkJCA9IGRhdGVSYW5nZVdpdGhTYW1lSWQgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGVSYW5nZVdpdGhTYW1lSWQudGFnT3JkZXIpICE9IG51bGwgPyBfZGF0ZVJhbmdlV2l0aFNhbWVJZCQgOiB0YWdDb3VudDtcbiAgICBpZiAoZGF0ZVJhbmdlV2l0aFNhbWVJZCkge1xuICAgICAgY29uc3QgcHJldmlvdXNBdHRyID0gZGF0ZVJhbmdlV2l0aFNhbWVJZC5hdHRyO1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJldmlvdXNBdHRyKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGF0ZVJhbmdlQXR0ciwga2V5KSAmJiBkYXRlUmFuZ2VBdHRyW2tleV0gIT09IHByZXZpb3VzQXR0cltrZXldKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYERBVEVSQU5HRSB0YWcgYXR0cmlidXRlOiBcIiR7a2V5fVwiIGRvZXMgbm90IG1hdGNoIGZvciB0YWdzIHdpdGggSUQ6IFwiJHtkYXRlUmFuZ2VBdHRyLklEfVwiYCk7XG4gICAgICAgICAgdGhpcy5fYmFkVmFsdWVGb3JTYW1lSWQgPSBrZXk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIE1lcmdlIERhdGVSYW5nZSB0YWdzIHdpdGggdGhlIHNhbWUgSURcbiAgICAgIGRhdGVSYW5nZUF0dHIgPSBfZXh0ZW5kcyhuZXcgQXR0ckxpc3Qoe30pLCBwcmV2aW91c0F0dHIsIGRhdGVSYW5nZUF0dHIpO1xuICAgIH1cbiAgICB0aGlzLmF0dHIgPSBkYXRlUmFuZ2VBdHRyO1xuICAgIGlmIChkYXRlUmFuZ2VXaXRoU2FtZUlkKSB7XG4gICAgICB0aGlzLl9zdGFydERhdGUgPSBkYXRlUmFuZ2VXaXRoU2FtZUlkLl9zdGFydERhdGU7XG4gICAgICB0aGlzLl9jdWUgPSBkYXRlUmFuZ2VXaXRoU2FtZUlkLl9jdWU7XG4gICAgICB0aGlzLl9lbmREYXRlID0gZGF0ZVJhbmdlV2l0aFNhbWVJZC5fZW5kRGF0ZTtcbiAgICAgIHRoaXMuX2RhdGVBdEVuZCA9IGRhdGVSYW5nZVdpdGhTYW1lSWQuX2RhdGVBdEVuZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc3RhcnREYXRlID0gbmV3IERhdGUoZGF0ZVJhbmdlQXR0cltcIlNUQVJULURBVEVcIl0pO1xuICAgIH1cbiAgICBpZiAoXCJFTkQtREFURVwiIGluIHRoaXMuYXR0cikge1xuICAgICAgY29uc3QgZW5kRGF0ZSA9IChkYXRlUmFuZ2VXaXRoU2FtZUlkID09IG51bGwgPyB2b2lkIDAgOiBkYXRlUmFuZ2VXaXRoU2FtZUlkLmVuZERhdGUpIHx8IG5ldyBEYXRlKHRoaXMuYXR0cltcIkVORC1EQVRFXCJdKTtcbiAgICAgIGlmIChpc0Zpbml0ZU51bWJlcihlbmREYXRlLmdldFRpbWUoKSkpIHtcbiAgICAgICAgdGhpcy5fZW5kRGF0ZSA9IGVuZERhdGU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyLklEO1xuICB9XG4gIGdldCBjbGFzcygpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyLkNMQVNTO1xuICB9XG4gIGdldCBjdWUoKSB7XG4gICAgY29uc3QgX2N1ZSA9IHRoaXMuX2N1ZTtcbiAgICBpZiAoX2N1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY3VlID0gdGhpcy5hdHRyLmVudW1lcmF0ZWRTdHJpbmdMaXN0KHRoaXMuYXR0ci5DVUUgPyAnQ1VFJyA6ICdYLUNVRScsIHtcbiAgICAgICAgcHJlOiBmYWxzZSxcbiAgICAgICAgcG9zdDogZmFsc2UsXG4gICAgICAgIG9uY2U6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIF9jdWU7XG4gIH1cbiAgZ2V0IHN0YXJ0VGltZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICB0YWdBbmNob3JcbiAgICB9ID0gdGhpcztcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1vcHRpb25hbC1jaGFpblxuICAgIGlmICh0YWdBbmNob3IgPT09IG51bGwgfHwgdGFnQW5jaG9yLnByb2dyYW1EYXRlVGltZSA9PT0gbnVsbCkge1xuICAgICAgbG9nZ2VyLndhcm4oYEV4cGVjdGVkIHRhZ0FuY2hvciBGcmFnbWVudCB3aXRoIFBEVCBzZXQgZm9yIERhdGVSYW5nZSBcIiR7dGhpcy5pZH1cIjogJHt0YWdBbmNob3J9YCk7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICByZXR1cm4gdGFnQW5jaG9yLnN0YXJ0ICsgKHRoaXMuc3RhcnREYXRlLmdldFRpbWUoKSAtIHRhZ0FuY2hvci5wcm9ncmFtRGF0ZVRpbWUpIC8gMTAwMDtcbiAgfVxuICBnZXQgc3RhcnREYXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGFydERhdGU7XG4gIH1cbiAgZ2V0IGVuZERhdGUoKSB7XG4gICAgY29uc3QgZGF0ZUF0RW5kID0gdGhpcy5fZW5kRGF0ZSB8fCB0aGlzLl9kYXRlQXRFbmQ7XG4gICAgaWYgKGRhdGVBdEVuZCkge1xuICAgICAgcmV0dXJuIGRhdGVBdEVuZDtcbiAgICB9XG4gICAgY29uc3QgZHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uO1xuICAgIGlmIChkdXJhdGlvbiAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RhdGVBdEVuZCA9IG5ldyBEYXRlKHRoaXMuX3N0YXJ0RGF0ZS5nZXRUaW1lKCkgKyBkdXJhdGlvbiAqIDEwMDApO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnZXQgZHVyYXRpb24oKSB7XG4gICAgaWYgKFwiRFVSQVRJT05cIiBpbiB0aGlzLmF0dHIpIHtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5hdHRyLmRlY2ltYWxGbG9hdGluZ1BvaW50KFwiRFVSQVRJT05cIik7XG4gICAgICBpZiAoaXNGaW5pdGVOdW1iZXIoZHVyYXRpb24pKSB7XG4gICAgICAgIHJldHVybiBkdXJhdGlvbjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX2VuZERhdGUpIHtcbiAgICAgIHJldHVybiAodGhpcy5fZW5kRGF0ZS5nZXRUaW1lKCkgLSB0aGlzLl9zdGFydERhdGUuZ2V0VGltZSgpKSAvIDEwMDA7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdldCBwbGFubmVkRHVyYXRpb24oKSB7XG4gICAgaWYgKFwiUExBTk5FRC1EVVJBVElPTlwiIGluIHRoaXMuYXR0cikge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0ci5kZWNpbWFsRmxvYXRpbmdQb2ludChcIlBMQU5ORUQtRFVSQVRJT05cIik7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdldCBlbmRPbk5leHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0ci5ib29sKFwiRU5ELU9OLU5FWFRcIik7XG4gIH1cbiAgZ2V0IGlzSW50ZXJzdGl0aWFsKCkge1xuICAgIHJldHVybiB0aGlzLmNsYXNzID09PSBDTEFTU19JTlRFUlNUSVRJQUw7XG4gIH1cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5pZCAmJiAhdGhpcy5fYmFkVmFsdWVGb3JTYW1lSWQgJiYgaXNGaW5pdGVOdW1iZXIodGhpcy5zdGFydERhdGUuZ2V0VGltZSgpKSAmJiAodGhpcy5kdXJhdGlvbiA9PT0gbnVsbCB8fCB0aGlzLmR1cmF0aW9uID49IDApICYmICghdGhpcy5lbmRPbk5leHQgfHwgISF0aGlzLmNsYXNzKSAmJiAoIXRoaXMuYXR0ci5DVUUgfHwgIXRoaXMuY3VlLnByZSAmJiAhdGhpcy5jdWUucG9zdCB8fCB0aGlzLmN1ZS5wcmUgIT09IHRoaXMuY3VlLnBvc3QpICYmICghdGhpcy5pc0ludGVyc3RpdGlhbCB8fCAnWC1BU1NFVC1VUkknIGluIHRoaXMuYXR0ciB8fCAnWC1BU1NFVC1MSVNUJyBpbiB0aGlzLmF0dHIpO1xuICB9XG59XG5cbmNvbnN0IERFRkFVTFRfVEFSR0VUX0RVUkFUSU9OID0gMTA7XG5cbi8qKlxuICogT2JqZWN0IHJlcHJlc2VudGluZyBwYXJzZWQgZGF0YSBmcm9tIGFuIEhMUyBNZWRpYSBQbGF5bGlzdC4gRm91bmQgaW4ge0BsaW5rIGhscy5qcyNMZXZlbC5kZXRhaWxzfS5cbiAqL1xuY2xhc3MgTGV2ZWxEZXRhaWxzIHtcbiAgY29uc3RydWN0b3IoYmFzZVVybCkge1xuICAgIHRoaXMuUFRTS25vd24gPSBmYWxzZTtcbiAgICB0aGlzLmFsaWduZWRTbGlkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5hdmVyYWdldGFyZ2V0ZHVyYXRpb24gPSB2b2lkIDA7XG4gICAgdGhpcy5lbmRDQyA9IDA7XG4gICAgdGhpcy5lbmRTTiA9IDA7XG4gICAgdGhpcy5mcmFnbWVudHMgPSB2b2lkIDA7XG4gICAgdGhpcy5mcmFnbWVudEhpbnQgPSB2b2lkIDA7XG4gICAgdGhpcy5wYXJ0TGlzdCA9IG51bGw7XG4gICAgdGhpcy5kYXRlUmFuZ2VzID0gdm9pZCAwO1xuICAgIHRoaXMuZGF0ZVJhbmdlVGFnQ291bnQgPSAwO1xuICAgIHRoaXMubGl2ZSA9IHRydWU7XG4gICAgdGhpcy5yZXF1ZXN0U2NoZWR1bGVkID0gLTE7XG4gICAgdGhpcy5hZ2VIZWFkZXIgPSAwO1xuICAgIHRoaXMuYWR2YW5jZWREYXRlVGltZSA9IHZvaWQgMDtcbiAgICB0aGlzLnVwZGF0ZWQgPSB0cnVlO1xuICAgIHRoaXMuYWR2YW5jZWQgPSB0cnVlO1xuICAgIHRoaXMubWlzc2VzID0gMDtcbiAgICB0aGlzLnN0YXJ0Q0MgPSAwO1xuICAgIHRoaXMuc3RhcnRTTiA9IDA7XG4gICAgdGhpcy5zdGFydFRpbWVPZmZzZXQgPSBudWxsO1xuICAgIHRoaXMudGFyZ2V0ZHVyYXRpb24gPSAwO1xuICAgIHRoaXMudG90YWxkdXJhdGlvbiA9IDA7XG4gICAgdGhpcy50eXBlID0gbnVsbDtcbiAgICB0aGlzLnVybCA9IHZvaWQgMDtcbiAgICB0aGlzLm0zdTggPSAnJztcbiAgICB0aGlzLnZlcnNpb24gPSBudWxsO1xuICAgIHRoaXMuY2FuQmxvY2tSZWxvYWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhblNraXBVbnRpbCA9IDA7XG4gICAgdGhpcy5jYW5Ta2lwRGF0ZVJhbmdlcyA9IGZhbHNlO1xuICAgIHRoaXMuc2tpcHBlZFNlZ21lbnRzID0gMDtcbiAgICB0aGlzLnJlY2VudGx5UmVtb3ZlZERhdGVyYW5nZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5wYXJ0SG9sZEJhY2sgPSAwO1xuICAgIHRoaXMuaG9sZEJhY2sgPSAwO1xuICAgIHRoaXMucGFydFRhcmdldCA9IDA7XG4gICAgdGhpcy5wcmVsb2FkSGludCA9IHZvaWQgMDtcbiAgICB0aGlzLnJlbmRpdGlvblJlcG9ydHMgPSB2b2lkIDA7XG4gICAgdGhpcy50dW5lSW5Hb2FsID0gMDtcbiAgICB0aGlzLmRlbHRhVXBkYXRlRmFpbGVkID0gdm9pZCAwO1xuICAgIHRoaXMuZHJpZnRTdGFydFRpbWUgPSAwO1xuICAgIHRoaXMuZHJpZnRFbmRUaW1lID0gMDtcbiAgICB0aGlzLmRyaWZ0U3RhcnQgPSAwO1xuICAgIHRoaXMuZHJpZnRFbmQgPSAwO1xuICAgIHRoaXMuZW5jcnlwdGVkRnJhZ21lbnRzID0gdm9pZCAwO1xuICAgIHRoaXMucGxheWxpc3RQYXJzaW5nRXJyb3IgPSBudWxsO1xuICAgIHRoaXMudmFyaWFibGVMaXN0ID0gbnVsbDtcbiAgICB0aGlzLmhhc1ZhcmlhYmxlUmVmcyA9IGZhbHNlO1xuICAgIHRoaXMuYXBwbGllZFRpbWVsaW5lT2Zmc2V0ID0gdm9pZCAwO1xuICAgIHRoaXMuZnJhZ21lbnRzID0gW107XG4gICAgdGhpcy5lbmNyeXB0ZWRGcmFnbWVudHMgPSBbXTtcbiAgICB0aGlzLmRhdGVSYW5nZXMgPSB7fTtcbiAgICB0aGlzLnVybCA9IGJhc2VVcmw7XG4gIH1cbiAgcmVsb2FkZWQocHJldmlvdXMpIHtcbiAgICBpZiAoIXByZXZpb3VzKSB7XG4gICAgICB0aGlzLmFkdmFuY2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMudXBkYXRlZCA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBhcnRTbkRpZmYgPSB0aGlzLmxhc3RQYXJ0U24gLSBwcmV2aW91cy5sYXN0UGFydFNuO1xuICAgIGNvbnN0IHBhcnRJbmRleERpZmYgPSB0aGlzLmxhc3RQYXJ0SW5kZXggLSBwcmV2aW91cy5sYXN0UGFydEluZGV4O1xuICAgIHRoaXMudXBkYXRlZCA9IHRoaXMuZW5kU04gIT09IHByZXZpb3VzLmVuZFNOIHx8ICEhcGFydEluZGV4RGlmZiB8fCAhIXBhcnRTbkRpZmYgfHwgIXRoaXMubGl2ZTtcbiAgICB0aGlzLmFkdmFuY2VkID0gdGhpcy5lbmRTTiA+IHByZXZpb3VzLmVuZFNOIHx8IHBhcnRTbkRpZmYgPiAwIHx8IHBhcnRTbkRpZmYgPT09IDAgJiYgcGFydEluZGV4RGlmZiA+IDA7XG4gICAgaWYgKHRoaXMudXBkYXRlZCB8fCB0aGlzLmFkdmFuY2VkKSB7XG4gICAgICB0aGlzLm1pc3NlcyA9IE1hdGguZmxvb3IocHJldmlvdXMubWlzc2VzICogMC42KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5taXNzZXMgPSBwcmV2aW91cy5taXNzZXMgKyAxO1xuICAgIH1cbiAgfVxuICBnZXQgaGFzUHJvZ3JhbURhdGVUaW1lKCkge1xuICAgIGlmICh0aGlzLmZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBpc0Zpbml0ZU51bWJlcih0aGlzLmZyYWdtZW50c1t0aGlzLmZyYWdtZW50cy5sZW5ndGggLSAxXS5wcm9ncmFtRGF0ZVRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZ2V0IGxldmVsVGFyZ2V0RHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYXZlcmFnZXRhcmdldGR1cmF0aW9uIHx8IHRoaXMudGFyZ2V0ZHVyYXRpb24gfHwgREVGQVVMVF9UQVJHRVRfRFVSQVRJT047XG4gIH1cbiAgZ2V0IGRyaWZ0KCkge1xuICAgIGNvbnN0IHJ1blRpbWUgPSB0aGlzLmRyaWZ0RW5kVGltZSAtIHRoaXMuZHJpZnRTdGFydFRpbWU7XG4gICAgaWYgKHJ1blRpbWUgPiAwKSB7XG4gICAgICBjb25zdCBydW5EdXJhdGlvbiA9IHRoaXMuZHJpZnRFbmQgLSB0aGlzLmRyaWZ0U3RhcnQ7XG4gICAgICByZXR1cm4gcnVuRHVyYXRpb24gKiAxMDAwIC8gcnVuVGltZTtcbiAgICB9XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgZ2V0IGVkZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFydEVuZCB8fCB0aGlzLmZyYWdtZW50RW5kO1xuICB9XG4gIGdldCBwYXJ0RW5kKCkge1xuICAgIHZhciBfdGhpcyRwYXJ0TGlzdDtcbiAgICBpZiAoKF90aGlzJHBhcnRMaXN0ID0gdGhpcy5wYXJ0TGlzdCkgIT0gbnVsbCAmJiBfdGhpcyRwYXJ0TGlzdC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnRMaXN0W3RoaXMucGFydExpc3QubGVuZ3RoIC0gMV0uZW5kO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mcmFnbWVudEVuZDtcbiAgfVxuICBnZXQgZnJhZ21lbnRFbmQoKSB7XG4gICAgdmFyIF90aGlzJGZyYWdtZW50cztcbiAgICBpZiAoKF90aGlzJGZyYWdtZW50cyA9IHRoaXMuZnJhZ21lbnRzKSAhPSBudWxsICYmIF90aGlzJGZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLmZyYWdtZW50c1t0aGlzLmZyYWdtZW50cy5sZW5ndGggLSAxXS5lbmQ7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIGdldCBmcmFnbWVudFN0YXJ0KCkge1xuICAgIHZhciBfdGhpcyRmcmFnbWVudHMyO1xuICAgIGlmICgoX3RoaXMkZnJhZ21lbnRzMiA9IHRoaXMuZnJhZ21lbnRzKSAhPSBudWxsICYmIF90aGlzJGZyYWdtZW50czIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5mcmFnbWVudHNbMF0uc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIGdldCBhZ2UoKSB7XG4gICAgaWYgKHRoaXMuYWR2YW5jZWREYXRlVGltZSkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KERhdGUubm93KCkgLSB0aGlzLmFkdmFuY2VkRGF0ZVRpbWUsIDApIC8gMTAwMDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZ2V0IGxhc3RQYXJ0SW5kZXgoKSB7XG4gICAgdmFyIF90aGlzJHBhcnRMaXN0MjtcbiAgICBpZiAoKF90aGlzJHBhcnRMaXN0MiA9IHRoaXMucGFydExpc3QpICE9IG51bGwgJiYgX3RoaXMkcGFydExpc3QyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFydExpc3RbdGhpcy5wYXJ0TGlzdC5sZW5ndGggLSAxXS5pbmRleDtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGdldCBtYXhQYXJ0SW5kZXgoKSB7XG4gICAgY29uc3QgcGFydExpc3QgPSB0aGlzLnBhcnRMaXN0O1xuICAgIGlmIChwYXJ0TGlzdCkge1xuICAgICAgY29uc3QgbGFzdEluZGV4ID0gdGhpcy5sYXN0UGFydEluZGV4O1xuICAgICAgaWYgKGxhc3RJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHBhcnRMaXN0Lmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgIGlmIChwYXJ0TGlzdFtpXS5pbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnRMaXN0W2ldLmluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGFzdEluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICBnZXQgbGFzdFBhcnRTbigpIHtcbiAgICB2YXIgX3RoaXMkcGFydExpc3QzO1xuICAgIGlmICgoX3RoaXMkcGFydExpc3QzID0gdGhpcy5wYXJ0TGlzdCkgIT0gbnVsbCAmJiBfdGhpcyRwYXJ0TGlzdDMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJ0TGlzdFt0aGlzLnBhcnRMaXN0Lmxlbmd0aCAtIDFdLmZyYWdtZW50LnNuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lbmRTTjtcbiAgfVxuICBnZXQgZXhwaXJlZCgpIHtcbiAgICBpZiAodGhpcy5saXZlICYmIHRoaXMuYWdlICYmIHRoaXMubWlzc2VzIDwgMykge1xuICAgICAgY29uc3QgcGxheWxpc3RXaW5kb3dEdXJhdGlvbiA9IHRoaXMucGFydEVuZCAtIHRoaXMuZnJhZ21lbnRTdGFydDtcbiAgICAgIHJldHVybiB0aGlzLmFnZSA+IE1hdGgubWF4KHBsYXlsaXN0V2luZG93RHVyYXRpb24sIHRoaXMudG90YWxkdXJhdGlvbikgKyB0aGlzLmxldmVsVGFyZ2V0RHVyYXRpb247XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0Z1bGxTZWdtZW50RW5jcnlwdGlvbihtZXRob2QpIHtcbiAgcmV0dXJuIG1ldGhvZCA9PT0gJ0FFUy0xMjgnIHx8IG1ldGhvZCA9PT0gJ0FFUy0yNTYnIHx8IG1ldGhvZCA9PT0gJ0FFUy0yNTYtQ1RSJztcbn1cbmZ1bmN0aW9uIGdldEFlc01vZGVGcm9tRnVsbFNlZ21lbnRNZXRob2QobWV0aG9kKSB7XG4gIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgY2FzZSAnQUVTLTEyOCc6XG4gICAgY2FzZSAnQUVTLTI1Nic6XG4gICAgICByZXR1cm4gRGVjcnlwdGVyQWVzTW9kZS5jYmM7XG4gICAgY2FzZSAnQUVTLTI1Ni1DVFInOlxuICAgICAgcmV0dXJuIERlY3J5cHRlckFlc01vZGUuY3RyO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZnVsbCBzZWdtZW50IG1ldGhvZCAke21ldGhvZH1gKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjREZWNvZGUoYmFzZTY0ZW5jb2RlZFN0cikge1xuICByZXR1cm4gVWludDhBcnJheS5mcm9tKGF0b2IoYmFzZTY0ZW5jb2RlZFN0ciksIGMgPT4gYy5jaGFyQ29kZUF0KDApKTtcbn1cblxuLy8gYnJlYWtpbmcgdXAgdGhvc2UgdHdvIHR5cGVzIGluIG9yZGVyIHRvIGNsYXJpZnkgd2hhdCBpcyBoYXBwZW5pbmcgaW4gdGhlIGRlY29kaW5nIHBhdGguXG5cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODkzNjk4NC91aW50OGFycmF5LXRvLXN0cmluZy1pbi1qYXZhc2NyaXB0LzIyMzczMTk3XG4vLyBodHRwOi8vd3d3Lm9uaWNvcy5jb20vc3RhZmYvaXovYW11c2UvamF2YXNjcmlwdC9leHBlcnQvdXRmLnR4dFxuLyogdXRmLmpzIC0gVVRGLTggPD0+IFVURi0xNiBjb252ZXJ0aW9uXG4gKlxuICogQ29weXJpZ2h0IChDKSAxOTk5IE1hc2FuYW8gSXp1bW8gPGl6QG9uaWNvcy5jby5qcD5cbiAqIFZlcnNpb246IDEuMFxuICogTGFzdE1vZGlmaWVkOiBEZWMgMjUgMTk5OVxuICogVGhpcyBsaWJyYXJ5IGlzIGZyZWUuICBZb3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0LlxuICovXG5cbmZ1bmN0aW9uIHN0clRvVXRmOGFycmF5KHN0cikge1xuICByZXR1cm4gVWludDhBcnJheS5mcm9tKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKSwgYyA9PiBjLmNoYXJDb2RlQXQoMCkpO1xufVxuXG5mdW5jdGlvbiBnZXRLZXlJZEJ5dGVzKHN0cikge1xuICBjb25zdCBrZXlJZGJ5dGVzID0gc3RyVG9VdGY4YXJyYXkoc3RyKS5zdWJhcnJheSgwLCAxNik7XG4gIGNvbnN0IHBhZGRlZGtleUlkYnl0ZXMgPSBuZXcgVWludDhBcnJheSgxNik7XG4gIHBhZGRlZGtleUlkYnl0ZXMuc2V0KGtleUlkYnl0ZXMsIDE2IC0ga2V5SWRieXRlcy5sZW5ndGgpO1xuICByZXR1cm4gcGFkZGVka2V5SWRieXRlcztcbn1cbmZ1bmN0aW9uIGNoYW5nZUVuZGlhbm5lc3Moa2V5SWQpIHtcbiAgY29uc3Qgc3dhcCA9IGZ1bmN0aW9uIHN3YXAoYXJyYXksIGZyb20sIHRvKSB7XG4gICAgY29uc3QgY3VyID0gYXJyYXlbZnJvbV07XG4gICAgYXJyYXlbZnJvbV0gPSBhcnJheVt0b107XG4gICAgYXJyYXlbdG9dID0gY3VyO1xuICB9O1xuICBzd2FwKGtleUlkLCAwLCAzKTtcbiAgc3dhcChrZXlJZCwgMSwgMik7XG4gIHN3YXAoa2V5SWQsIDQsIDUpO1xuICBzd2FwKGtleUlkLCA2LCA3KTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnREYXRhVXJpVG9BcnJheUJ5dGVzKHVyaSkge1xuICAvLyBkYXRhOls8bWVkaWEgdHlwZV1bO2F0dHJpYnV0ZT12YWx1ZV1bO2Jhc2U2NF0sPGRhdGE+XG4gIGNvbnN0IGNvbG9uc3BsaXQgPSB1cmkuc3BsaXQoJzonKTtcbiAgbGV0IGtleWRhdGEgPSBudWxsO1xuICBpZiAoY29sb25zcGxpdFswXSA9PT0gJ2RhdGEnICYmIGNvbG9uc3BsaXQubGVuZ3RoID09PSAyKSB7XG4gICAgY29uc3Qgc2VtaWNvbG9uc3BsaXQgPSBjb2xvbnNwbGl0WzFdLnNwbGl0KCc7Jyk7XG4gICAgY29uc3QgY29tbWFzcGxpdCA9IHNlbWljb2xvbnNwbGl0W3NlbWljb2xvbnNwbGl0Lmxlbmd0aCAtIDFdLnNwbGl0KCcsJyk7XG4gICAgaWYgKGNvbW1hc3BsaXQubGVuZ3RoID09PSAyKSB7XG4gICAgICBjb25zdCBpc2Jhc2U2NCA9IGNvbW1hc3BsaXRbMF0gPT09ICdiYXNlNjQnO1xuICAgICAgY29uc3QgZGF0YSA9IGNvbW1hc3BsaXRbMV07XG4gICAgICBpZiAoaXNiYXNlNjQpIHtcbiAgICAgICAgc2VtaWNvbG9uc3BsaXQuc3BsaWNlKC0xLCAxKTsgLy8gcmVtb3ZlIGZyb20gcHJvY2Vzc2luZ1xuICAgICAgICBrZXlkYXRhID0gYmFzZTY0RGVjb2RlKGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5ZGF0YSA9IGdldEtleUlkQnl0ZXMoZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBrZXlkYXRhO1xufVxuXG4vKiogcmV0dXJucyBgdW5kZWZpbmVkYCBpcyBgc2VsZmAgaXMgbWlzc2luZywgZS5nLiBpbiBub2RlICovXG5jb25zdCBvcHRpb25hbFNlbGYgPSB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05hdmlnYXRvci9yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NcbiAqL1xudmFyIEtleVN5c3RlbXMgPSB7XG4gIENMRUFSS0VZOiBcIm9yZy53My5jbGVhcmtleVwiLFxuICBGQUlSUExBWTogXCJjb20uYXBwbGUuZnBzXCIsXG4gIFBMQVlSRUFEWTogXCJjb20ubWljcm9zb2Z0LnBsYXlyZWFkeVwiLFxuICBXSURFVklORTogXCJjb20ud2lkZXZpbmUuYWxwaGFcIlxufTtcblxuLy8gUGxheWxpc3QgI0VYVC1YLUtFWSBLRVlGT1JNQVQgdmFsdWVzXG52YXIgS2V5U3lzdGVtRm9ybWF0cyA9IHtcbiAgQ0xFQVJLRVk6IFwib3JnLnczLmNsZWFya2V5XCIsXG4gIEZBSVJQTEFZOiBcImNvbS5hcHBsZS5zdHJlYW1pbmdrZXlkZWxpdmVyeVwiLFxuICBQTEFZUkVBRFk6IFwiY29tLm1pY3Jvc29mdC5wbGF5cmVhZHlcIixcbiAgV0lERVZJTkU6IFwidXJuOnV1aWQ6ZWRlZjhiYTktNzlkNi00YWNlLWEzYzgtMjdkY2Q1MWQyMWVkXCJcbn07XG5mdW5jdGlvbiBrZXlTeXN0ZW1Gb3JtYXRUb0tleVN5c3RlbURvbWFpbihmb3JtYXQpIHtcbiAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICBjYXNlIEtleVN5c3RlbUZvcm1hdHMuRkFJUlBMQVk6XG4gICAgICByZXR1cm4gS2V5U3lzdGVtcy5GQUlSUExBWTtcbiAgICBjYXNlIEtleVN5c3RlbUZvcm1hdHMuUExBWVJFQURZOlxuICAgICAgcmV0dXJuIEtleVN5c3RlbXMuUExBWVJFQURZO1xuICAgIGNhc2UgS2V5U3lzdGVtRm9ybWF0cy5XSURFVklORTpcbiAgICAgIHJldHVybiBLZXlTeXN0ZW1zLldJREVWSU5FO1xuICAgIGNhc2UgS2V5U3lzdGVtRm9ybWF0cy5DTEVBUktFWTpcbiAgICAgIHJldHVybiBLZXlTeXN0ZW1zLkNMRUFSS0VZO1xuICB9XG59XG5mdW5jdGlvbiBrZXlTeXN0ZW1Eb21haW5Ub0tleVN5c3RlbUZvcm1hdChrZXlTeXN0ZW0pIHtcbiAgc3dpdGNoIChrZXlTeXN0ZW0pIHtcbiAgICBjYXNlIEtleVN5c3RlbXMuRkFJUlBMQVk6XG4gICAgICByZXR1cm4gS2V5U3lzdGVtRm9ybWF0cy5GQUlSUExBWTtcbiAgICBjYXNlIEtleVN5c3RlbXMuUExBWVJFQURZOlxuICAgICAgcmV0dXJuIEtleVN5c3RlbUZvcm1hdHMuUExBWVJFQURZO1xuICAgIGNhc2UgS2V5U3lzdGVtcy5XSURFVklORTpcbiAgICAgIHJldHVybiBLZXlTeXN0ZW1Gb3JtYXRzLldJREVWSU5FO1xuICAgIGNhc2UgS2V5U3lzdGVtcy5DTEVBUktFWTpcbiAgICAgIHJldHVybiBLZXlTeXN0ZW1Gb3JtYXRzLkNMRUFSS0VZO1xuICB9XG59XG5mdW5jdGlvbiBnZXRLZXlTeXN0ZW1zRm9yQ29uZmlnKGNvbmZpZykge1xuICBjb25zdCB7XG4gICAgZHJtU3lzdGVtcyxcbiAgICB3aWRldmluZUxpY2Vuc2VVcmxcbiAgfSA9IGNvbmZpZztcbiAgY29uc3Qga2V5U3lzdGVtc1RvQXR0ZW1wdCA9IGRybVN5c3RlbXMgPyBbS2V5U3lzdGVtcy5GQUlSUExBWSwgS2V5U3lzdGVtcy5XSURFVklORSwgS2V5U3lzdGVtcy5QTEFZUkVBRFksIEtleVN5c3RlbXMuQ0xFQVJLRVldLmZpbHRlcihrZXlTeXN0ZW0gPT4gISFkcm1TeXN0ZW1zW2tleVN5c3RlbV0pIDogW107XG4gIGlmICgha2V5U3lzdGVtc1RvQXR0ZW1wdFtLZXlTeXN0ZW1zLldJREVWSU5FXSAmJiB3aWRldmluZUxpY2Vuc2VVcmwpIHtcbiAgICBrZXlTeXN0ZW1zVG9BdHRlbXB0LnB1c2goS2V5U3lzdGVtcy5XSURFVklORSk7XG4gIH1cbiAgcmV0dXJuIGtleVN5c3RlbXNUb0F0dGVtcHQ7XG59XG5jb25zdCByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgPSBmdW5jdGlvbiAoX29wdGlvbmFsU2VsZiRuYXZpZ2F0KSB7XG4gIGlmIChvcHRpb25hbFNlbGYgIT0gbnVsbCAmJiAoX29wdGlvbmFsU2VsZiRuYXZpZ2F0ID0gb3B0aW9uYWxTZWxmLm5hdmlnYXRvcikgIT0gbnVsbCAmJiBfb3B0aW9uYWxTZWxmJG5hdmlnYXQucmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzKSB7XG4gICAgcmV0dXJuIHNlbGYubmF2aWdhdG9yLnJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzcy5iaW5kKHNlbGYubmF2aWdhdG9yKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufSgpO1xuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhS2V5U3lzdGVtQ29uZmlndXJhdGlvblxuICovXG5mdW5jdGlvbiBnZXRTdXBwb3J0ZWRNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25zKGtleVN5c3RlbSwgYXVkaW9Db2RlY3MsIHZpZGVvQ29kZWNzLCBkcm1TeXN0ZW1PcHRpb25zKSB7XG4gIGxldCBpbml0RGF0YVR5cGVzO1xuICBzd2l0Y2ggKGtleVN5c3RlbSkge1xuICAgIGNhc2UgS2V5U3lzdGVtcy5GQUlSUExBWTpcbiAgICAgIGluaXREYXRhVHlwZXMgPSBbJ2NlbmMnLCAnc2luZiddO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBLZXlTeXN0ZW1zLldJREVWSU5FOlxuICAgIGNhc2UgS2V5U3lzdGVtcy5QTEFZUkVBRFk6XG4gICAgICBpbml0RGF0YVR5cGVzID0gWydjZW5jJ107XG4gICAgICBicmVhaztcbiAgICBjYXNlIEtleVN5c3RlbXMuQ0xFQVJLRVk6XG4gICAgICBpbml0RGF0YVR5cGVzID0gWydjZW5jJywgJ2tleWlkcyddO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBrZXktc3lzdGVtOiAke2tleVN5c3RlbX1gKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9ucyhpbml0RGF0YVR5cGVzLCBhdWRpb0NvZGVjcywgdmlkZW9Db2RlY3MsIGRybVN5c3RlbU9wdGlvbnMpO1xufVxuZnVuY3Rpb24gY3JlYXRlTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9ucyhpbml0RGF0YVR5cGVzLCBhdWRpb0NvZGVjcywgdmlkZW9Db2RlY3MsIGRybVN5c3RlbU9wdGlvbnMpIHtcbiAgY29uc3QgYmFzZUNvbmZpZyA9IHtcbiAgICBpbml0RGF0YVR5cGVzOiBpbml0RGF0YVR5cGVzLFxuICAgIHBlcnNpc3RlbnRTdGF0ZTogZHJtU3lzdGVtT3B0aW9ucy5wZXJzaXN0ZW50U3RhdGUgfHwgJ29wdGlvbmFsJyxcbiAgICBkaXN0aW5jdGl2ZUlkZW50aWZpZXI6IGRybVN5c3RlbU9wdGlvbnMuZGlzdGluY3RpdmVJZGVudGlmaWVyIHx8ICdvcHRpb25hbCcsXG4gICAgc2Vzc2lvblR5cGVzOiBkcm1TeXN0ZW1PcHRpb25zLnNlc3Npb25UeXBlcyB8fCBbZHJtU3lzdGVtT3B0aW9ucy5zZXNzaW9uVHlwZSB8fCAndGVtcG9yYXJ5J10sXG4gICAgYXVkaW9DYXBhYmlsaXRpZXM6IGF1ZGlvQ29kZWNzLm1hcChjb2RlYyA9PiAoe1xuICAgICAgY29udGVudFR5cGU6IGBhdWRpby9tcDQ7IGNvZGVjcz0ke2NvZGVjfWAsXG4gICAgICByb2J1c3RuZXNzOiBkcm1TeXN0ZW1PcHRpb25zLmF1ZGlvUm9idXN0bmVzcyB8fCAnJyxcbiAgICAgIGVuY3J5cHRpb25TY2hlbWU6IGRybVN5c3RlbU9wdGlvbnMuYXVkaW9FbmNyeXB0aW9uU2NoZW1lIHx8IG51bGxcbiAgICB9KSksXG4gICAgdmlkZW9DYXBhYmlsaXRpZXM6IHZpZGVvQ29kZWNzLm1hcChjb2RlYyA9PiAoe1xuICAgICAgY29udGVudFR5cGU6IGB2aWRlby9tcDQ7IGNvZGVjcz0ke2NvZGVjfWAsXG4gICAgICByb2J1c3RuZXNzOiBkcm1TeXN0ZW1PcHRpb25zLnZpZGVvUm9idXN0bmVzcyB8fCAnJyxcbiAgICAgIGVuY3J5cHRpb25TY2hlbWU6IGRybVN5c3RlbU9wdGlvbnMudmlkZW9FbmNyeXB0aW9uU2NoZW1lIHx8IG51bGxcbiAgICB9KSlcbiAgfTtcbiAgcmV0dXJuIFtiYXNlQ29uZmlnXTtcbn1cbmZ1bmN0aW9uIGlzUGVyc2lzdGVudFNlc3Npb25UeXBlKGRybVN5c3RlbU9wdGlvbnMpIHtcbiAgdmFyIF9kcm1TeXN0ZW1PcHRpb25zJHNlcztcbiAgcmV0dXJuIGRybVN5c3RlbU9wdGlvbnMuc2Vzc2lvblR5cGUgPT09ICdwZXJzaXN0ZW50LWxpY2Vuc2UnIHx8ICEhKChfZHJtU3lzdGVtT3B0aW9ucyRzZXMgPSBkcm1TeXN0ZW1PcHRpb25zLnNlc3Npb25UeXBlcykgIT0gbnVsbCAmJiBfZHJtU3lzdGVtT3B0aW9ucyRzZXMuc29tZSh0eXBlID0+IHR5cGUgPT09ICdwZXJzaXN0ZW50LWxpY2Vuc2UnKSk7XG59XG5mdW5jdGlvbiBwYXJzZVBsYXlSZWFkeVdSTShrZXlCeXRlcykge1xuICBjb25zdCBrZXlCeXRlc1V0ZjE2ID0gbmV3IFVpbnQxNkFycmF5KGtleUJ5dGVzLmJ1ZmZlciwga2V5Qnl0ZXMuYnl0ZU9mZnNldCwga2V5Qnl0ZXMuYnl0ZUxlbmd0aCAvIDIpO1xuICBjb25zdCBrZXlCeXRlU3RyID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBBcnJheS5mcm9tKGtleUJ5dGVzVXRmMTYpKTtcblxuICAvLyBQYXJzZSBQbGF5cmVhZHkgV1JNSGVhZGVyIFhNTFxuICBjb25zdCB4bWxLZXlCeXRlcyA9IGtleUJ5dGVTdHIuc3Vic3RyaW5nKGtleUJ5dGVTdHIuaW5kZXhPZignPCcpLCBrZXlCeXRlU3RyLmxlbmd0aCk7XG4gIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgY29uc3QgeG1sRG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyh4bWxLZXlCeXRlcywgJ3RleHQveG1sJyk7XG4gIGNvbnN0IGtleURhdGEgPSB4bWxEb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ0tJRCcpWzBdO1xuICBpZiAoa2V5RGF0YSkge1xuICAgIGNvbnN0IGtleUlkID0ga2V5RGF0YS5jaGlsZE5vZGVzWzBdID8ga2V5RGF0YS5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZSA6IGtleURhdGEuZ2V0QXR0cmlidXRlKCdWQUxVRScpO1xuICAgIGlmIChrZXlJZCkge1xuICAgICAgY29uc3Qga2V5SWRBcnJheSA9IGJhc2U2NERlY29kZShrZXlJZCkuc3ViYXJyYXkoMCwgMTYpO1xuICAgICAgLy8gS0lEIHZhbHVlIGluIFBSTyBpcyBhIGJhc2U2NC1lbmNvZGVkIGxpdHRsZSBlbmRpYW4gR1VJRCBpbnRlcnByZXRhdGlvbiBvZiBVVUlEXG4gICAgICAvLyBLSUQgdmFsdWUgaW4g4oCYdGVuY+KAmSBpcyBhIGJpZyBlbmRpYW4gVVVJRCBHVUlEIGludGVycHJldGF0aW9uIG9mIFVVSURcbiAgICAgIGNoYW5nZUVuZGlhbm5lc3Moa2V5SWRBcnJheSk7XG4gICAgICByZXR1cm4ga2V5SWRBcnJheTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmxldCBrZXlVcmlUb0tleUlkTWFwID0ge307XG5jbGFzcyBMZXZlbEtleSB7XG4gIHN0YXRpYyBjbGVhcktleVVyaVRvS2V5SWRNYXAoKSB7XG4gICAga2V5VXJpVG9LZXlJZE1hcCA9IHt9O1xuICB9XG4gIGNvbnN0cnVjdG9yKG1ldGhvZCwgdXJpLCBmb3JtYXQsIGZvcm1hdHZlcnNpb25zID0gWzFdLCBpdiA9IG51bGwsIGtleUlkKSB7XG4gICAgdGhpcy51cmkgPSB2b2lkIDA7XG4gICAgdGhpcy5tZXRob2QgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXlGb3JtYXQgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXlGb3JtYXRWZXJzaW9ucyA9IHZvaWQgMDtcbiAgICB0aGlzLmVuY3J5cHRlZCA9IHZvaWQgMDtcbiAgICB0aGlzLmlzQ29tbW9uRW5jcnlwdGlvbiA9IHZvaWQgMDtcbiAgICB0aGlzLml2ID0gbnVsbDtcbiAgICB0aGlzLmtleSA9IG51bGw7XG4gICAgdGhpcy5rZXlJZCA9IG51bGw7XG4gICAgdGhpcy5wc3NoID0gbnVsbDtcbiAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgICB0aGlzLnVyaSA9IHVyaTtcbiAgICB0aGlzLmtleUZvcm1hdCA9IGZvcm1hdDtcbiAgICB0aGlzLmtleUZvcm1hdFZlcnNpb25zID0gZm9ybWF0dmVyc2lvbnM7XG4gICAgdGhpcy5pdiA9IGl2O1xuICAgIHRoaXMuZW5jcnlwdGVkID0gbWV0aG9kID8gbWV0aG9kICE9PSAnTk9ORScgOiBmYWxzZTtcbiAgICB0aGlzLmlzQ29tbW9uRW5jcnlwdGlvbiA9IHRoaXMuZW5jcnlwdGVkICYmICFpc0Z1bGxTZWdtZW50RW5jcnlwdGlvbihtZXRob2QpO1xuICAgIGlmIChrZXlJZCAhPSBudWxsICYmIGtleUlkLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgIHRoaXMua2V5SWQgPSBuZXcgVWludDhBcnJheShoZXhUb0FycmF5QnVmZmVyKGtleUlkKSk7XG4gICAgfVxuICB9XG4gIG1hdGNoZXMoa2V5KSB7XG4gICAgdmFyIF9rZXkkaXYsIF90aGlzJGl2O1xuICAgIHJldHVybiBrZXkudXJpID09PSB0aGlzLnVyaSAmJiBrZXkubWV0aG9kID09PSB0aGlzLm1ldGhvZCAmJiBrZXkuZW5jcnlwdGVkID09PSB0aGlzLmVuY3J5cHRlZCAmJiBrZXkua2V5Rm9ybWF0ID09PSB0aGlzLmtleUZvcm1hdCAmJiBrZXkua2V5Rm9ybWF0VmVyc2lvbnMuam9pbignLCcpID09PSB0aGlzLmtleUZvcm1hdFZlcnNpb25zLmpvaW4oJywnKSAmJiAoKF9rZXkkaXYgPSBrZXkuaXYpID09IG51bGwgPyB2b2lkIDAgOiBfa2V5JGl2LmpvaW4oJywnKSkgPT09ICgoX3RoaXMkaXYgPSB0aGlzLml2KSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkaXYuam9pbignLCcpKTtcbiAgfVxuICBpc1N1cHBvcnRlZCgpIHtcbiAgICAvLyBJZiBpdCdzIFNlZ21lbnQgZW5jcnlwdGlvbiBvciBObyBlbmNyeXB0aW9uLCBqdXN0IHNlbGVjdCB0aGF0IGtleSBzeXN0ZW1cbiAgICBpZiAodGhpcy5tZXRob2QpIHtcbiAgICAgIGlmIChpc0Z1bGxTZWdtZW50RW5jcnlwdGlvbih0aGlzLm1ldGhvZCkgfHwgdGhpcy5tZXRob2QgPT09ICdOT05FJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmtleUZvcm1hdCA9PT0gJ2lkZW50aXR5Jykge1xuICAgICAgICAvLyBNYWludGFpbiBzdXBwb3J0IGZvciBjbGVhciBTQU1QTEUtQUVTIHdpdGggTVBFRy0zIFRTXG4gICAgICAgIHJldHVybiB0aGlzLm1ldGhvZCA9PT0gJ1NBTVBMRS1BRVMnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmtleUZvcm1hdCkge1xuICAgICAgICAgIGNhc2UgS2V5U3lzdGVtRm9ybWF0cy5GQUlSUExBWTpcbiAgICAgICAgICBjYXNlIEtleVN5c3RlbUZvcm1hdHMuV0lERVZJTkU6XG4gICAgICAgICAgY2FzZSBLZXlTeXN0ZW1Gb3JtYXRzLlBMQVlSRUFEWTpcbiAgICAgICAgICBjYXNlIEtleVN5c3RlbUZvcm1hdHMuQ0xFQVJLRVk6XG4gICAgICAgICAgICByZXR1cm4gWydJU08tMjMwMDEtNycsICdTQU1QTEUtQUVTJywgJ1NBTVBMRS1BRVMtQ0VOQycsICdTQU1QTEUtQUVTLUNUUiddLmluZGV4T2YodGhpcy5tZXRob2QpICE9PSAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZ2V0RGVjcnlwdERhdGEoc24pIHtcbiAgICBpZiAoIXRoaXMuZW5jcnlwdGVkIHx8ICF0aGlzLnVyaSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChpc0Z1bGxTZWdtZW50RW5jcnlwdGlvbih0aGlzLm1ldGhvZCkgJiYgdGhpcy51cmkgJiYgIXRoaXMuaXYpIHtcbiAgICAgIGlmICh0eXBlb2Ygc24gIT09ICdudW1iZXInKSB7XG4gICAgICAgIC8vIFdlIGFyZSBmZXRjaGluZyBkZWNyeXB0aW9uIGRhdGEgZm9yIGEgaW5pdGlhbGl6YXRpb24gc2VnbWVudFxuICAgICAgICAvLyBJZiB0aGUgc2VnbWVudCB3YXMgZW5jcnlwdGVkIHdpdGggQUVTLTEyOC8yNTZcbiAgICAgICAgLy8gSXQgbXVzdCBoYXZlIGFuIElWIGRlZmluZWQuIFdlIGNhbm5vdCBzdWJzdGl0dXRlIHRoZSBTZWdtZW50IE51bWJlciBpbi5cbiAgICAgICAgbG9nZ2VyLndhcm4oYG1pc3NpbmcgSVYgZm9yIGluaXRpYWxpemF0aW9uIHNlZ21lbnQgd2l0aCBtZXRob2Q9XCIke3RoaXMubWV0aG9kfVwiIC0gY29tcGxpYW5jZSBpc3N1ZWApO1xuXG4gICAgICAgIC8vIEV4cGxpY2l0bHkgc2V0IHNuIHRvIHJlc3VsdGluZyB2YWx1ZSBmcm9tIGltcGxpY2l0IGNvbnZlcnNpb25zICdpbml0U2VnbWVudCcgdmFsdWVzIGZvciBJViBnZW5lcmF0aW9uLlxuICAgICAgICBzbiA9IDA7XG4gICAgICB9XG4gICAgICBjb25zdCBpdiA9IGNyZWF0ZUluaXRpYWxpemF0aW9uVmVjdG9yKHNuKTtcbiAgICAgIGNvbnN0IGRlY3J5cHRkYXRhID0gbmV3IExldmVsS2V5KHRoaXMubWV0aG9kLCB0aGlzLnVyaSwgJ2lkZW50aXR5JywgdGhpcy5rZXlGb3JtYXRWZXJzaW9ucywgaXYpO1xuICAgICAgcmV0dXJuIGRlY3J5cHRkYXRhO1xuICAgIH1cbiAgICBpZiAodGhpcy5wc3NoICYmIHRoaXMua2V5SWQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUga2V5SWQgaWYgcG9zc2libGVcbiAgICBjb25zdCBrZXlCeXRlcyA9IGNvbnZlcnREYXRhVXJpVG9BcnJheUJ5dGVzKHRoaXMudXJpKTtcbiAgICBpZiAoa2V5Qnl0ZXMpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5rZXlGb3JtYXQpIHtcbiAgICAgICAgY2FzZSBLZXlTeXN0ZW1Gb3JtYXRzLldJREVWSU5FOlxuICAgICAgICAgIC8vIFNldHRpbmcgYHBzc2hgIG9uIHRoaXMgTGV2ZWxLZXkvRGVjcnlwdERhdGEgYWxsb3dzIEhMUy5qcyB0byBnZW5lcmF0ZSBhIHNlc3Npb24gdXNpbmdcbiAgICAgICAgICAvLyB0aGUgcGxheWxpc3Qta2V5IGJlZm9yZSB0aGUgXCJlbmNyeXB0ZWRcIiBldmVudC4gKENvbW1lbnQgb3V0IHRvIG9ubHkgdXNlIFwiZW5jcnlwdGVkXCIgcGF0aC4pXG4gICAgICAgICAgdGhpcy5wc3NoID0ga2V5Qnl0ZXM7XG4gICAgICAgICAgLy8gSW4gY2FzZSBvZiBXaWRldmluZSwgaWYgS0VZSUQgaXMgbm90IGluIHRoZSBwbGF5bGlzdCwgYXNzdW1lIG9ubHkgdHdvIGZpZWxkcyBpbiB0aGUgcHNzaCBLRVkgdGFnIFVSSS5cbiAgICAgICAgICBpZiAoIXRoaXMua2V5SWQgJiYga2V5Qnl0ZXMubGVuZ3RoID49IDIyKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBrZXlCeXRlcy5sZW5ndGggLSAyMjtcbiAgICAgICAgICAgIHRoaXMua2V5SWQgPSBrZXlCeXRlcy5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDE2KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgS2V5U3lzdGVtRm9ybWF0cy5QTEFZUkVBRFk6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgUGxheVJlYWR5S2V5U3lzdGVtVVVJRCA9IG5ldyBVaW50OEFycmF5KFsweDlhLCAweDA0LCAweGYwLCAweDc5LCAweDk4LCAweDQwLCAweDQyLCAweDg2LCAweGFiLCAweDkyLCAweGU2LCAweDViLCAweGUwLCAweDg4LCAweDVmLCAweDk1XSk7XG5cbiAgICAgICAgICAgIC8vIFNldHRpbmcgYHBzc2hgIG9uIHRoaXMgTGV2ZWxLZXkvRGVjcnlwdERhdGEgYWxsb3dzIEhMUy5qcyB0byBnZW5lcmF0ZSBhIHNlc3Npb24gdXNpbmdcbiAgICAgICAgICAgIC8vIHRoZSBwbGF5bGlzdC1rZXkgYmVmb3JlIHRoZSBcImVuY3J5cHRlZFwiIGV2ZW50LiAoQ29tbWVudCBvdXQgdG8gb25seSB1c2UgXCJlbmNyeXB0ZWRcIiBwYXRoLilcbiAgICAgICAgICAgIHRoaXMucHNzaCA9IG1wNHBzc2goUGxheVJlYWR5S2V5U3lzdGVtVVVJRCwgbnVsbCwga2V5Qnl0ZXMpO1xuICAgICAgICAgICAgdGhpcy5rZXlJZCA9IHBhcnNlUGxheVJlYWR5V1JNKGtleUJ5dGVzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBsZXQga2V5ZGF0YSA9IGtleUJ5dGVzLnN1YmFycmF5KDAsIDE2KTtcbiAgICAgICAgICAgIGlmIChrZXlkYXRhLmxlbmd0aCAhPT0gMTYpIHtcbiAgICAgICAgICAgICAgY29uc3QgcGFkZGVkID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgICAgICAgICAgICBwYWRkZWQuc2V0KGtleWRhdGEsIDE2IC0ga2V5ZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgICBrZXlkYXRhID0gcGFkZGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5rZXlJZCA9IGtleWRhdGE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCBiZWhhdmlvcjogYXNzaWduIGEgbmV3IGtleUlkIGZvciBlYWNoIHVyaVxuICAgIGlmICghdGhpcy5rZXlJZCB8fCB0aGlzLmtleUlkLmJ5dGVMZW5ndGggIT09IDE2KSB7XG4gICAgICBsZXQga2V5SWQgPSBrZXlVcmlUb0tleUlkTWFwW3RoaXMudXJpXTtcbiAgICAgIGlmICgha2V5SWQpIHtcbiAgICAgICAgY29uc3QgdmFsID0gT2JqZWN0LmtleXMoa2V5VXJpVG9LZXlJZE1hcCkubGVuZ3RoICUgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgIGtleUlkID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgICAgICBjb25zdCBkdiA9IG5ldyBEYXRhVmlldyhrZXlJZC5idWZmZXIsIDEyLCA0KTsgLy8gSnVzdCBzZXQgdGhlIGxhc3QgNCBieXRlc1xuICAgICAgICBkdi5zZXRVaW50MzIoMCwgdmFsKTtcbiAgICAgICAga2V5VXJpVG9LZXlJZE1hcFt0aGlzLnVyaV0gPSBrZXlJZDtcbiAgICAgIH1cbiAgICAgIHRoaXMua2V5SWQgPSBrZXlJZDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUluaXRpYWxpemF0aW9uVmVjdG9yKHNlZ21lbnROdW1iZXIpIHtcbiAgY29uc3QgdWludDhWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICBmb3IgKGxldCBpID0gMTI7IGkgPCAxNjsgaSsrKSB7XG4gICAgdWludDhWaWV3W2ldID0gc2VnbWVudE51bWJlciA+PiA4ICogKDE1IC0gaSkgJiAweGZmO1xuICB9XG4gIHJldHVybiB1aW50OFZpZXc7XG59XG5cbmNvbnN0IE1BU1RFUl9QTEFZTElTVF9SRUdFWCA9IC8jRVhULVgtU1RSRUFNLUlORjooW15cXHJcXG5dKikoPzpbXFxyXFxuXSg/OiNbXlxcclxcbl0qKT8pKihbXlxcclxcbl0rKXwjRVhULVgtKFNFU1NJT04tREFUQXxTRVNTSU9OLUtFWXxERUZJTkV8Q09OVEVOVC1TVEVFUklOR3xTVEFSVCk6KFteXFxyXFxuXSopW1xcclxcbl0rL2c7XG5jb25zdCBNQVNURVJfUExBWUxJU1RfTUVESUFfUkVHRVggPSAvI0VYVC1YLU1FRElBOiguKikvZztcbmNvbnN0IElTX01FRElBX1BMQVlMSVNUID0gL14jRVhUKD86SU5GfC1YLVRBUkdFVERVUkFUSU9OKTovbTsgLy8gSGFuZGxlIGVtcHR5IE1lZGlhIFBsYXlsaXN0IChmaXJzdCBFWFRJTkYgbm90IHNpZ25hbGVkLCBidXQgVEFSR0VURFVSQVRJT04gcHJlc2VudClcblxuY29uc3QgTEVWRUxfUExBWUxJU1RfUkVHRVhfRkFTVCA9IG5ldyBSZWdFeHAoWy8jRVhUSU5GOlxccyooXFxkKig/OlxcLlxcZCspPykoPzosKC4qKVxccyspPy8uc291cmNlLFxuLy8gZHVyYXRpb24gKCNFWFRJTkY6PGR1cmF0aW9uPiw8dGl0bGU+KSwgZ3JvdXAgMSA9PiBkdXJhdGlvbiwgZ3JvdXAgMiA9PiB0aXRsZVxuLyg/ISMpICooXFxTW15cXHJcXG5dKikvLnNvdXJjZSxcbi8vIHNlZ21lbnQgVVJJLCBncm91cCAzID0+IHRoZSBVUkkgKG5vdGUgbmV3bGluZSBpcyBub3QgZWF0ZW4pXG4vIy4qLy5zb3VyY2UgLy8gQWxsIG90aGVyIG5vbi1zZWdtZW50IG9yaWVudGVkIHRhZ3Mgd2lsbCBtYXRjaCB3aXRoIGFsbCBncm91cHMgZW1wdHlcbl0uam9pbignfCcpLCAnZycpO1xuY29uc3QgTEVWRUxfUExBWUxJU1RfUkVHRVhfU0xPVyA9IG5ldyBSZWdFeHAoWy8jRVhULVgtKFBST0dSQU0tREFURS1USU1FfEJZVEVSQU5HRXxEQVRFUkFOR0V8REVGSU5FfEtFWXxNQVB8UEFSVHxQQVJULUlORnxQTEFZTElTVC1UWVBFfFBSRUxPQUQtSElOVHxSRU5ESVRJT04tUkVQT1JUfFNFUlZFUi1DT05UUk9MfFNLSVB8U1RBUlQpOiguKykvLnNvdXJjZSwgLyNFWFQtWC0oQklUUkFURXxESVNDT05USU5VSVRZLVNFUVVFTkNFfE1FRElBLVNFUVVFTkNFfFRBUkdFVERVUkFUSU9OfFZFUlNJT04pOiAqKFxcZCspLy5zb3VyY2UsIC8jRVhULVgtKERJU0NPTlRJTlVJVFl8RU5ETElTVHxHQVB8SU5ERVBFTkRFTlQtU0VHTUVOVFMpLy5zb3VyY2UsIC8oIykoW146XSopOiguKikvLnNvdXJjZSwgLygjKSguKikoPzouKilcXHI/XFxuPy8uc291cmNlXS5qb2luKCd8JykpO1xuY2xhc3MgTTNVOFBhcnNlciB7XG4gIHN0YXRpYyBmaW5kR3JvdXAoZ3JvdXBzLCBtZWRpYUdyb3VwSWQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZ3JvdXAgPSBncm91cHNbaV07XG4gICAgICBpZiAoZ3JvdXAuaWQgPT09IG1lZGlhR3JvdXBJZCkge1xuICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0YXRpYyByZXNvbHZlKHVybCwgYmFzZVVybCkge1xuICAgIHJldHVybiB1cmxUb29sa2l0RXhwb3J0cy5idWlsZEFic29sdXRlVVJMKGJhc2VVcmwsIHVybCwge1xuICAgICAgYWx3YXlzTm9ybWFsaXplOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGlzTWVkaWFQbGF5bGlzdChzdHIpIHtcbiAgICByZXR1cm4gSVNfTUVESUFfUExBWUxJU1QudGVzdChzdHIpO1xuICB9XG4gIHN0YXRpYyBwYXJzZU1hc3RlclBsYXlsaXN0KHN0cmluZywgYmFzZXVybCkge1xuICAgIGNvbnN0IGhhc1ZhcmlhYmxlUmVmcyA9IGhhc1ZhcmlhYmxlUmVmZXJlbmNlcyhzdHJpbmcpIDtcbiAgICBjb25zdCBwYXJzZWQgPSB7XG4gICAgICBjb250ZW50U3RlZXJpbmc6IG51bGwsXG4gICAgICBsZXZlbHM6IFtdLFxuICAgICAgcGxheWxpc3RQYXJzaW5nRXJyb3I6IG51bGwsXG4gICAgICBzZXNzaW9uRGF0YTogbnVsbCxcbiAgICAgIHNlc3Npb25LZXlzOiBudWxsLFxuICAgICAgc3RhcnRUaW1lT2Zmc2V0OiBudWxsLFxuICAgICAgdmFyaWFibGVMaXN0OiBudWxsLFxuICAgICAgaGFzVmFyaWFibGVSZWZzXG4gICAgfTtcbiAgICBjb25zdCBsZXZlbHNXaXRoS25vd25Db2RlY3MgPSBbXTtcbiAgICBNQVNURVJfUExBWUxJU1RfUkVHRVgubGFzdEluZGV4ID0gMDtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHdoaWxlICgocmVzdWx0ID0gTUFTVEVSX1BMQVlMSVNUX1JFR0VYLmV4ZWMoc3RyaW5nKSkgIT0gbnVsbCkge1xuICAgICAgaWYgKHJlc3VsdFsxXSkge1xuICAgICAgICB2YXIgX2xldmVsJHVua25vd25Db2RlY3M7XG4gICAgICAgIC8vICcjRVhULVgtU1RSRUFNLUlORicgaXMgZm91bmQsIHBhcnNlIGxldmVsIHRhZyAgaW4gZ3JvdXAgMVxuICAgICAgICBjb25zdCBhdHRycyA9IG5ldyBBdHRyTGlzdChyZXN1bHRbMV0sIHBhcnNlZCk7XG4gICAgICAgIGNvbnN0IHVyaSA9IHN1YnN0aXR1dGVWYXJpYWJsZXMocGFyc2VkLCByZXN1bHRbMl0pIDtcbiAgICAgICAgY29uc3QgbGV2ZWwgPSB7XG4gICAgICAgICAgYXR0cnMsXG4gICAgICAgICAgYml0cmF0ZTogYXR0cnMuZGVjaW1hbEludGVnZXIoJ0JBTkRXSURUSCcpIHx8IGF0dHJzLmRlY2ltYWxJbnRlZ2VyKCdBVkVSQUdFLUJBTkRXSURUSCcpLFxuICAgICAgICAgIG5hbWU6IGF0dHJzLk5BTUUsXG4gICAgICAgICAgdXJsOiBNM1U4UGFyc2VyLnJlc29sdmUodXJpLCBiYXNldXJsKVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNvbHV0aW9uID0gYXR0cnMuZGVjaW1hbFJlc29sdXRpb24oJ1JFU09MVVRJT04nKTtcbiAgICAgICAgaWYgKHJlc29sdXRpb24pIHtcbiAgICAgICAgICBsZXZlbC53aWR0aCA9IHJlc29sdXRpb24ud2lkdGg7XG4gICAgICAgICAgbGV2ZWwuaGVpZ2h0ID0gcmVzb2x1dGlvbi5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgc2V0Q29kZWNzKGF0dHJzLkNPREVDUywgbGV2ZWwpO1xuICAgICAgICBjb25zdCBzdXBwbGVtZW50YWxDb2RlY3MgPSBhdHRyc1snU1VQUExFTUVOVEFMLUNPREVDUyddO1xuICAgICAgICBpZiAoc3VwcGxlbWVudGFsQ29kZWNzKSB7XG4gICAgICAgICAgbGV2ZWwuc3VwcGxlbWVudGFsID0ge307XG4gICAgICAgICAgc2V0Q29kZWNzKHN1cHBsZW1lbnRhbENvZGVjcywgbGV2ZWwuc3VwcGxlbWVudGFsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgoX2xldmVsJHVua25vd25Db2RlY3MgPSBsZXZlbC51bmtub3duQ29kZWNzKSAhPSBudWxsICYmIF9sZXZlbCR1bmtub3duQ29kZWNzLmxlbmd0aCkpIHtcbiAgICAgICAgICBsZXZlbHNXaXRoS25vd25Db2RlY3MucHVzaChsZXZlbCk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VkLmxldmVscy5wdXNoKGxldmVsKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0WzNdKSB7XG4gICAgICAgIGNvbnN0IHRhZyA9IHJlc3VsdFszXTtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHJlc3VsdFs0XTtcbiAgICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgICBjYXNlICdTRVNTSU9OLURBVEEnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAvLyAjRVhULVgtU0VTU0lPTi1EQVRBXG4gICAgICAgICAgICAgIGNvbnN0IHNlc3Npb25BdHRycyA9IG5ldyBBdHRyTGlzdChhdHRyaWJ1dGVzLCBwYXJzZWQpO1xuICAgICAgICAgICAgICBjb25zdCBkYXRhSWQgPSBzZXNzaW9uQXR0cnNbJ0RBVEEtSUQnXTtcbiAgICAgICAgICAgICAgaWYgKGRhdGFJZCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWQuc2Vzc2lvbkRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHBhcnNlZC5zZXNzaW9uRGF0YSA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJzZWQuc2Vzc2lvbkRhdGFbZGF0YUlkXSA9IHNlc3Npb25BdHRycztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdTRVNTSU9OLUtFWSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC8vICNFWFQtWC1TRVNTSU9OLUtFWVxuICAgICAgICAgICAgICBjb25zdCBzZXNzaW9uS2V5ID0gcGFyc2VLZXkoYXR0cmlidXRlcywgYmFzZXVybCwgcGFyc2VkKTtcbiAgICAgICAgICAgICAgaWYgKHNlc3Npb25LZXkuZW5jcnlwdGVkICYmIHNlc3Npb25LZXkuaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWQuc2Vzc2lvbktleXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHBhcnNlZC5zZXNzaW9uS2V5cyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJzZWQuc2Vzc2lvbktleXMucHVzaChzZXNzaW9uS2V5KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgW0tleXNdIElnbm9yaW5nIGludmFsaWQgRVhULVgtU0VTU0lPTi1LRVkgdGFnOiBcIiR7YXR0cmlidXRlc31cImApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ0RFRklORSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC8vICNFWFQtWC1ERUZJTkVcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlQXR0cmlidXRlcyA9IG5ldyBBdHRyTGlzdChhdHRyaWJ1dGVzLCBwYXJzZWQpO1xuICAgICAgICAgICAgICAgIGFkZFZhcmlhYmxlRGVmaW5pdGlvbihwYXJzZWQsIHZhcmlhYmxlQXR0cmlidXRlcywgYmFzZXVybCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnQ09OVEVOVC1TVEVFUklORyc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC8vICNFWFQtWC1DT05URU5ULVNURUVSSU5HXG4gICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRTdGVlcmluZ0F0dHJpYnV0ZXMgPSBuZXcgQXR0ckxpc3QoYXR0cmlidXRlcywgcGFyc2VkKTtcbiAgICAgICAgICAgICAgcGFyc2VkLmNvbnRlbnRTdGVlcmluZyA9IHtcbiAgICAgICAgICAgICAgICB1cmk6IE0zVThQYXJzZXIucmVzb2x2ZShjb250ZW50U3RlZXJpbmdBdHRyaWJ1dGVzWydTRVJWRVItVVJJJ10sIGJhc2V1cmwpLFxuICAgICAgICAgICAgICAgIHBhdGh3YXlJZDogY29udGVudFN0ZWVyaW5nQXR0cmlidXRlc1snUEFUSFdBWS1JRCddIHx8ICcuJ1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdTVEFSVCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC8vICNFWFQtWC1TVEFSVFxuICAgICAgICAgICAgICBwYXJzZWQuc3RhcnRUaW1lT2Zmc2V0ID0gcGFyc2VTdGFydFRpbWVPZmZzZXQoYXR0cmlidXRlcyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEZpbHRlciBvdXQgbGV2ZWxzIHdpdGggdW5rbm93biBjb2RlY3MgaWYgaXQgZG9lcyBub3QgcmVtb3ZlIGFsbCBsZXZlbHNcbiAgICBjb25zdCBzdHJpcFVua25vd25Db2RlY0xldmVscyA9IGxldmVsc1dpdGhLbm93bkNvZGVjcy5sZW5ndGggPiAwICYmIGxldmVsc1dpdGhLbm93bkNvZGVjcy5sZW5ndGggPCBwYXJzZWQubGV2ZWxzLmxlbmd0aDtcbiAgICBwYXJzZWQubGV2ZWxzID0gc3RyaXBVbmtub3duQ29kZWNMZXZlbHMgPyBsZXZlbHNXaXRoS25vd25Db2RlY3MgOiBwYXJzZWQubGV2ZWxzO1xuICAgIGlmIChwYXJzZWQubGV2ZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcGFyc2VkLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKCdubyBsZXZlbHMgZm91bmQgaW4gbWFuaWZlc3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBzdGF0aWMgcGFyc2VNYXN0ZXJQbGF5bGlzdE1lZGlhKHN0cmluZywgYmFzZXVybCwgcGFyc2VkKSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBjb25zdCByZXN1bHRzID0ge307XG4gICAgY29uc3QgbGV2ZWxzID0gcGFyc2VkLmxldmVscztcbiAgICBjb25zdCBncm91cHNCeVR5cGUgPSB7XG4gICAgICBBVURJTzogbGV2ZWxzLm1hcChsZXZlbCA9PiAoe1xuICAgICAgICBpZDogbGV2ZWwuYXR0cnMuQVVESU8sXG4gICAgICAgIGF1ZGlvQ29kZWM6IGxldmVsLmF1ZGlvQ29kZWNcbiAgICAgIH0pKSxcbiAgICAgIFNVQlRJVExFUzogbGV2ZWxzLm1hcChsZXZlbCA9PiAoe1xuICAgICAgICBpZDogbGV2ZWwuYXR0cnMuU1VCVElUTEVTLFxuICAgICAgICB0ZXh0Q29kZWM6IGxldmVsLnRleHRDb2RlY1xuICAgICAgfSkpLFxuICAgICAgJ0NMT1NFRC1DQVBUSU9OUyc6IFtdXG4gICAgfTtcbiAgICBsZXQgaWQgPSAwO1xuICAgIE1BU1RFUl9QTEFZTElTVF9NRURJQV9SRUdFWC5sYXN0SW5kZXggPSAwO1xuICAgIHdoaWxlICgocmVzdWx0ID0gTUFTVEVSX1BMQVlMSVNUX01FRElBX1JFR0VYLmV4ZWMoc3RyaW5nKSkgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGF0dHJzID0gbmV3IEF0dHJMaXN0KHJlc3VsdFsxXSwgcGFyc2VkKTtcbiAgICAgIGNvbnN0IHR5cGUgPSBhdHRycy5UWVBFO1xuICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgY29uc3QgZ3JvdXBzID0gZ3JvdXBzQnlUeXBlW3R5cGVdO1xuICAgICAgICBjb25zdCBtZWRpYXMgPSByZXN1bHRzW3R5cGVdIHx8IFtdO1xuICAgICAgICByZXN1bHRzW3R5cGVdID0gbWVkaWFzO1xuICAgICAgICBjb25zdCBsYW5nID0gYXR0cnMuTEFOR1VBR0U7XG4gICAgICAgIGNvbnN0IGFzc29jTGFuZyA9IGF0dHJzWydBU1NPQy1MQU5HVUFHRSddO1xuICAgICAgICBjb25zdCBjaGFubmVscyA9IGF0dHJzLkNIQU5ORUxTO1xuICAgICAgICBjb25zdCBjaGFyYWN0ZXJpc3RpY3MgPSBhdHRycy5DSEFSQUNURVJJU1RJQ1M7XG4gICAgICAgIGNvbnN0IGluc3RyZWFtSWQgPSBhdHRyc1snSU5TVFJFQU0tSUQnXTtcbiAgICAgICAgY29uc3QgbWVkaWEgPSB7XG4gICAgICAgICAgYXR0cnMsXG4gICAgICAgICAgYml0cmF0ZTogMCxcbiAgICAgICAgICBpZDogaWQrKyxcbiAgICAgICAgICBncm91cElkOiBhdHRyc1snR1JPVVAtSUQnXSB8fCAnJyxcbiAgICAgICAgICBuYW1lOiBhdHRycy5OQU1FIHx8IGxhbmcgfHwgJycsXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBkZWZhdWx0OiBhdHRycy5ib29sKCdERUZBVUxUJyksXG4gICAgICAgICAgYXV0b3NlbGVjdDogYXR0cnMuYm9vbCgnQVVUT1NFTEVDVCcpLFxuICAgICAgICAgIGZvcmNlZDogYXR0cnMuYm9vbCgnRk9SQ0VEJyksXG4gICAgICAgICAgbGFuZyxcbiAgICAgICAgICB1cmw6IGF0dHJzLlVSSSA/IE0zVThQYXJzZXIucmVzb2x2ZShhdHRycy5VUkksIGJhc2V1cmwpIDogJydcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGFzc29jTGFuZykge1xuICAgICAgICAgIG1lZGlhLmFzc29jTGFuZyA9IGFzc29jTGFuZztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbm5lbHMpIHtcbiAgICAgICAgICBtZWRpYS5jaGFubmVscyA9IGNoYW5uZWxzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyYWN0ZXJpc3RpY3MpIHtcbiAgICAgICAgICBtZWRpYS5jaGFyYWN0ZXJpc3RpY3MgPSBjaGFyYWN0ZXJpc3RpY3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluc3RyZWFtSWQpIHtcbiAgICAgICAgICBtZWRpYS5pbnN0cmVhbUlkID0gaW5zdHJlYW1JZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXBzICE9IG51bGwgJiYgZ3JvdXBzLmxlbmd0aCkge1xuICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBhdWRpbyBvciB0ZXh0IGdyb3VwcyBzaWduYWxsZWQgaW4gdGhlIG1hbmlmZXN0LCBsZXQncyBsb29rIGZvciBhIG1hdGNoaW5nIGNvZGVjIHN0cmluZyBmb3IgdGhpcyB0cmFja1xuICAgICAgICAgIC8vIElmIHdlIGRvbid0IGZpbmQgdGhlIHRyYWNrIHNpZ25hbGxlZCwgbGV0cyB1c2UgdGhlIGZpcnN0IGF1ZGlvIGdyb3VwcyBjb2RlYyB3ZSBoYXZlXG4gICAgICAgICAgLy8gQWN0aW5nIGFzIGEgYmVzdCBndWVzc1xuICAgICAgICAgIGNvbnN0IGdyb3VwQ29kZWMgPSBNM1U4UGFyc2VyLmZpbmRHcm91cChncm91cHMsIG1lZGlhLmdyb3VwSWQpIHx8IGdyb3Vwc1swXTtcbiAgICAgICAgICBhc3NpZ25Db2RlYyhtZWRpYSwgZ3JvdXBDb2RlYywgJ2F1ZGlvQ29kZWMnKTtcbiAgICAgICAgICBhc3NpZ25Db2RlYyhtZWRpYSwgZ3JvdXBDb2RlYywgJ3RleHRDb2RlYycpO1xuICAgICAgICB9XG4gICAgICAgIG1lZGlhcy5wdXNoKG1lZGlhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbiAgc3RhdGljIHBhcnNlTGV2ZWxQbGF5bGlzdChzdHJpbmcsIGJhc2V1cmwsIGlkLCB0eXBlLCBsZXZlbFVybElkLCBtdWx0aXZhcmlhbnRWYXJpYWJsZUxpc3QpIHtcbiAgICB2YXIgX0xFVkVMX1BMQVlMSVNUX1JFR0VYO1xuICAgIGNvbnN0IGJhc2UgPSB7XG4gICAgICB1cmw6IGJhc2V1cmxcbiAgICB9O1xuICAgIGNvbnN0IGxldmVsID0gbmV3IExldmVsRGV0YWlscyhiYXNldXJsKTtcbiAgICBjb25zdCBmcmFnbWVudHMgPSBsZXZlbC5mcmFnbWVudHM7XG4gICAgY29uc3QgcHJvZ3JhbURhdGVUaW1lcyA9IFtdO1xuICAgIC8vIFRoZSBtb3N0IHJlY2VudCBpbml0IHNlZ21lbnQgc2VlbiAoYXBwbGllcyB0byBhbGwgc3Vic2VxdWVudCBzZWdtZW50cylcbiAgICBsZXQgY3VycmVudEluaXRTZWdtZW50ID0gbnVsbDtcbiAgICBsZXQgY3VycmVudFNOID0gMDtcbiAgICBsZXQgY3VycmVudFBhcnQgPSAwO1xuICAgIGxldCB0b3RhbGR1cmF0aW9uID0gMDtcbiAgICBsZXQgZGlzY29udGludWl0eUNvdW50ZXIgPSAwO1xuICAgIGxldCBjdXJyZW50Qml0cmF0ZSA9IDA7XG4gICAgbGV0IHByZXZGcmFnID0gbnVsbDtcbiAgICBsZXQgZnJhZyA9IG5ldyBGcmFnbWVudCh0eXBlLCBiYXNlKTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGxldCBpO1xuICAgIGxldCBsZXZlbGtleXM7XG4gICAgbGV0IGZpcnN0UGR0SW5kZXggPSAtMTtcbiAgICBsZXQgY3JlYXRlTmV4dEZyYWcgPSBmYWxzZTtcbiAgICBsZXQgbmV4dEJ5dGVSYW5nZSA9IG51bGw7XG4gICAgbGV0IHNlcnZlckNvbnRyb2xBdHRycztcbiAgICBMRVZFTF9QTEFZTElTVF9SRUdFWF9GQVNULmxhc3RJbmRleCA9IDA7XG4gICAgbGV2ZWwubTN1OCA9IHN0cmluZztcbiAgICBsZXZlbC5oYXNWYXJpYWJsZVJlZnMgPSBoYXNWYXJpYWJsZVJlZmVyZW5jZXMoc3RyaW5nKSA7XG4gICAgaWYgKCgoX0xFVkVMX1BMQVlMSVNUX1JFR0VYID0gTEVWRUxfUExBWUxJU1RfUkVHRVhfRkFTVC5leGVjKHN0cmluZykpID09IG51bGwgPyB2b2lkIDAgOiBfTEVWRUxfUExBWUxJU1RfUkVHRVhbMF0pICE9PSAnI0VYVE0zVScpIHtcbiAgICAgIGxldmVsLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKCdNaXNzaW5nIGZvcm1hdCBpZGVudGlmaWVyICNFWFRNM1UnKTtcbiAgICAgIHJldHVybiBsZXZlbDtcbiAgICB9XG4gICAgd2hpbGUgKChyZXN1bHQgPSBMRVZFTF9QTEFZTElTVF9SRUdFWF9GQVNULmV4ZWMoc3RyaW5nKSkgIT09IG51bGwpIHtcbiAgICAgIGlmIChjcmVhdGVOZXh0RnJhZykge1xuICAgICAgICBjcmVhdGVOZXh0RnJhZyA9IGZhbHNlO1xuICAgICAgICBmcmFnID0gbmV3IEZyYWdtZW50KHR5cGUsIGJhc2UpO1xuICAgICAgICAvLyBzZXR1cCB0aGUgbmV4dCBmcmFnbWVudCBmb3IgcGFydCBsb2FkaW5nXG4gICAgICAgIGZyYWcucGxheWxpc3RPZmZzZXQgPSB0b3RhbGR1cmF0aW9uO1xuICAgICAgICBmcmFnLnN0YXJ0ID0gdG90YWxkdXJhdGlvbjtcbiAgICAgICAgZnJhZy5zbiA9IGN1cnJlbnRTTjtcbiAgICAgICAgZnJhZy5jYyA9IGRpc2NvbnRpbnVpdHlDb3VudGVyO1xuICAgICAgICBpZiAoY3VycmVudEJpdHJhdGUpIHtcbiAgICAgICAgICBmcmFnLmJpdHJhdGUgPSBjdXJyZW50Qml0cmF0ZTtcbiAgICAgICAgfVxuICAgICAgICBmcmFnLmxldmVsID0gaWQ7XG4gICAgICAgIGlmIChjdXJyZW50SW5pdFNlZ21lbnQpIHtcbiAgICAgICAgICBmcmFnLmluaXRTZWdtZW50ID0gY3VycmVudEluaXRTZWdtZW50O1xuICAgICAgICAgIGlmIChjdXJyZW50SW5pdFNlZ21lbnQucmF3UHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgICAgICAgICBmcmFnLnJhd1Byb2dyYW1EYXRlVGltZSA9IGN1cnJlbnRJbml0U2VnbWVudC5yYXdQcm9ncmFtRGF0ZVRpbWU7XG4gICAgICAgICAgICBjdXJyZW50SW5pdFNlZ21lbnQucmF3UHJvZ3JhbURhdGVUaW1lID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5leHRCeXRlUmFuZ2UpIHtcbiAgICAgICAgICAgIGZyYWcuc2V0Qnl0ZVJhbmdlKG5leHRCeXRlUmFuZ2UpO1xuICAgICAgICAgICAgbmV4dEJ5dGVSYW5nZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IHJlc3VsdFsxXTtcbiAgICAgIGlmIChkdXJhdGlvbikge1xuICAgICAgICAvLyBJTkZcbiAgICAgICAgZnJhZy5kdXJhdGlvbiA9IHBhcnNlRmxvYXQoZHVyYXRpb24pO1xuICAgICAgICAvLyBhdm9pZCBzbGljZWQgc3RyaW5ncyAgICBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvOTM5XG4gICAgICAgIGNvbnN0IHRpdGxlID0gKCcgJyArIHJlc3VsdFsyXSkuc2xpY2UoMSk7XG4gICAgICAgIGZyYWcudGl0bGUgPSB0aXRsZSB8fCBudWxsO1xuICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaCh0aXRsZSA/IFsnSU5GJywgZHVyYXRpb24sIHRpdGxlXSA6IFsnSU5GJywgZHVyYXRpb25dKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0WzNdKSB7XG4gICAgICAgIC8vIHVybFxuICAgICAgICBpZiAoaXNGaW5pdGVOdW1iZXIoZnJhZy5kdXJhdGlvbikpIHtcbiAgICAgICAgICBmcmFnLnBsYXlsaXN0T2Zmc2V0ID0gdG90YWxkdXJhdGlvbjtcbiAgICAgICAgICBmcmFnLnN0YXJ0ID0gdG90YWxkdXJhdGlvbjtcbiAgICAgICAgICBpZiAobGV2ZWxrZXlzKSB7XG4gICAgICAgICAgICBzZXRGcmFnTGV2ZWxLZXlzKGZyYWcsIGxldmVsa2V5cywgbGV2ZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmcmFnLnNuID0gY3VycmVudFNOO1xuICAgICAgICAgIGZyYWcubGV2ZWwgPSBpZDtcbiAgICAgICAgICBmcmFnLmNjID0gZGlzY29udGludWl0eUNvdW50ZXI7XG4gICAgICAgICAgZnJhZ21lbnRzLnB1c2goZnJhZyk7XG4gICAgICAgICAgLy8gYXZvaWQgc2xpY2VkIHN0cmluZ3MgICAgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzkzOVxuICAgICAgICAgIGNvbnN0IHVyaSA9ICgnICcgKyByZXN1bHRbM10pLnNsaWNlKDEpO1xuICAgICAgICAgIGZyYWcucmVsdXJsID0gc3Vic3RpdHV0ZVZhcmlhYmxlcyhsZXZlbCwgdXJpKSA7XG4gICAgICAgICAgYXNzaWduUHJvZ3JhbURhdGVUaW1lKGZyYWcsIHByZXZGcmFnLCBwcm9ncmFtRGF0ZVRpbWVzKTtcbiAgICAgICAgICBwcmV2RnJhZyA9IGZyYWc7XG4gICAgICAgICAgdG90YWxkdXJhdGlvbiArPSBmcmFnLmR1cmF0aW9uO1xuICAgICAgICAgIGN1cnJlbnRTTisrO1xuICAgICAgICAgIGN1cnJlbnRQYXJ0ID0gMDtcbiAgICAgICAgICBjcmVhdGVOZXh0RnJhZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdFswXS5tYXRjaChMRVZFTF9QTEFZTElTVF9SRUdFWF9TTE9XKTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICBsb2dnZXIud2FybignTm8gbWF0Y2hlcyBvbiBzbG93IHJlZ2V4IG1hdGNoIGZvciBsZXZlbCBwbGF5bGlzdCEnKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdFtpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhdm9pZCBzbGljZWQgc3RyaW5ncyAgICBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvOTM5XG4gICAgICAgIGNvbnN0IHRhZyA9ICgnICcgKyByZXN1bHRbaV0pLnNsaWNlKDEpO1xuICAgICAgICBjb25zdCB2YWx1ZTEgPSAoJyAnICsgcmVzdWx0W2kgKyAxXSkuc2xpY2UoMSk7XG4gICAgICAgIGNvbnN0IHZhbHVlMiA9IHJlc3VsdFtpICsgMl0gPyAoJyAnICsgcmVzdWx0W2kgKyAyXSkuc2xpY2UoMSkgOiBudWxsO1xuICAgICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICAgIGNhc2UgJ0JZVEVSQU5HRSc6XG4gICAgICAgICAgICBpZiAocHJldkZyYWcpIHtcbiAgICAgICAgICAgICAgZnJhZy5zZXRCeXRlUmFuZ2UodmFsdWUxLCBwcmV2RnJhZyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmcmFnLnNldEJ5dGVSYW5nZSh2YWx1ZTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnUFJPR1JBTS1EQVRFLVRJTUUnOlxuICAgICAgICAgICAgLy8gYXZvaWQgc2xpY2VkIHN0cmluZ3MgICAgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzkzOVxuICAgICAgICAgICAgZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUgPSB2YWx1ZTE7XG4gICAgICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaChbJ1BST0dSQU0tREFURS1USU1FJywgdmFsdWUxXSk7XG4gICAgICAgICAgICBpZiAoZmlyc3RQZHRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgZmlyc3RQZHRJbmRleCA9IGZyYWdtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdQTEFZTElTVC1UWVBFJzpcbiAgICAgICAgICAgIGlmIChsZXZlbC50eXBlKSB7XG4gICAgICAgICAgICAgIGFzc2lnbk11bHRpcGxlTWVkaWFQbGF5bGlzdFRhZ09jY3VyYW5jZUVycm9yKGxldmVsLCB0YWcsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXZlbC50eXBlID0gdmFsdWUxLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdNRURJQS1TRVFVRU5DRSc6XG4gICAgICAgICAgICBpZiAobGV2ZWwuc3RhcnRTTiAhPT0gMCkge1xuICAgICAgICAgICAgICBhc3NpZ25NdWx0aXBsZU1lZGlhUGxheWxpc3RUYWdPY2N1cmFuY2VFcnJvcihsZXZlbCwgdGFnLCByZXN1bHQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmcmFnbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBhc3NpZ25NdXN0QXBwZWFyQmVmb3JlU2VnbWVudHNFcnJvcihsZXZlbCwgdGFnLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudFNOID0gbGV2ZWwuc3RhcnRTTiA9IHBhcnNlSW50KHZhbHVlMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdTS0lQJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWYgKGxldmVsLnNraXBwZWRTZWdtZW50cykge1xuICAgICAgICAgICAgICAgIGFzc2lnbk11bHRpcGxlTWVkaWFQbGF5bGlzdFRhZ09jY3VyYW5jZUVycm9yKGxldmVsLCB0YWcsIHJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3Qgc2tpcEF0dHJzID0gbmV3IEF0dHJMaXN0KHZhbHVlMSwgbGV2ZWwpO1xuICAgICAgICAgICAgICBjb25zdCBza2lwcGVkU2VnbWVudHMgPSBza2lwQXR0cnMuZGVjaW1hbEludGVnZXIoJ1NLSVBQRUQtU0VHTUVOVFMnKTtcbiAgICAgICAgICAgICAgaWYgKGlzRmluaXRlTnVtYmVyKHNraXBwZWRTZWdtZW50cykpIHtcbiAgICAgICAgICAgICAgICBsZXZlbC5za2lwcGVkU2VnbWVudHMgKz0gc2tpcHBlZFNlZ21lbnRzO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCByZXN1bHQgaW4gZnJhZ21lbnRzW10gY29udGFpbmluZyB1bmRlZmluZWQgdmFsdWVzLCB3aGljaCB3ZSB3aWxsIGZpbGwgaW4gd2l0aCBgbWVyZ2VEZXRhaWxzYFxuICAgICAgICAgICAgICAgIGZvciAobGV0IF9pID0gc2tpcHBlZFNlZ21lbnRzOyBfaS0tOykge1xuICAgICAgICAgICAgICAgICAgZnJhZ21lbnRzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRTTiArPSBza2lwcGVkU2VnbWVudHM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgcmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcyA9IHNraXBBdHRycy5lbnVtZXJhdGVkU3RyaW5nKCdSRUNFTlRMWS1SRU1PVkVELURBVEVSQU5HRVMnKTtcbiAgICAgICAgICAgICAgaWYgKHJlY2VudGx5UmVtb3ZlZERhdGVyYW5nZXMpIHtcbiAgICAgICAgICAgICAgICBsZXZlbC5yZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzID0gKGxldmVsLnJlY2VudGx5UmVtb3ZlZERhdGVyYW5nZXMgfHwgW10pLmNvbmNhdChyZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzLnNwbGl0KCdcXHQnKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnVEFSR0VURFVSQVRJT04nOlxuICAgICAgICAgICAgaWYgKGxldmVsLnRhcmdldGR1cmF0aW9uICE9PSAwKSB7XG4gICAgICAgICAgICAgIGFzc2lnbk11bHRpcGxlTWVkaWFQbGF5bGlzdFRhZ09jY3VyYW5jZUVycm9yKGxldmVsLCB0YWcsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXZlbC50YXJnZXRkdXJhdGlvbiA9IE1hdGgubWF4KHBhcnNlSW50KHZhbHVlMSksIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnVkVSU0lPTic6XG4gICAgICAgICAgICBpZiAobGV2ZWwudmVyc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBhc3NpZ25NdWx0aXBsZU1lZGlhUGxheWxpc3RUYWdPY2N1cmFuY2VFcnJvcihsZXZlbCwgdGFnLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV2ZWwudmVyc2lvbiA9IHBhcnNlSW50KHZhbHVlMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdJTkRFUEVOREVOVC1TRUdNRU5UUyc6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdFTkRMSVNUJzpcbiAgICAgICAgICAgIGlmICghbGV2ZWwubGl2ZSkge1xuICAgICAgICAgICAgICBhc3NpZ25NdWx0aXBsZU1lZGlhUGxheWxpc3RUYWdPY2N1cmFuY2VFcnJvcihsZXZlbCwgdGFnLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV2ZWwubGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAgICBpZiAodmFsdWUxIHx8IHZhbHVlMikge1xuICAgICAgICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaCh2YWx1ZTIgPyBbdmFsdWUxLCB2YWx1ZTJdIDogW3ZhbHVlMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnRElTQ09OVElOVUlUWSc6XG4gICAgICAgICAgICBkaXNjb250aW51aXR5Q291bnRlcisrO1xuICAgICAgICAgICAgZnJhZy50YWdMaXN0LnB1c2goWydESVMnXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdHQVAnOlxuICAgICAgICAgICAgZnJhZy5nYXAgPSB0cnVlO1xuICAgICAgICAgICAgZnJhZy50YWdMaXN0LnB1c2goW3RhZ10pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnQklUUkFURSc6XG4gICAgICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaChbdGFnLCB2YWx1ZTFdKTtcbiAgICAgICAgICAgIGN1cnJlbnRCaXRyYXRlID0gcGFyc2VJbnQodmFsdWUxKSAqIDEwMDA7XG4gICAgICAgICAgICBpZiAoaXNGaW5pdGVOdW1iZXIoY3VycmVudEJpdHJhdGUpKSB7XG4gICAgICAgICAgICAgIGZyYWcuYml0cmF0ZSA9IGN1cnJlbnRCaXRyYXRlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY3VycmVudEJpdHJhdGUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnREFURVJBTkdFJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgZGF0ZVJhbmdlQXR0ciA9IG5ldyBBdHRyTGlzdCh2YWx1ZTEsIGxldmVsKTtcbiAgICAgICAgICAgICAgY29uc3QgZGF0ZVJhbmdlID0gbmV3IERhdGVSYW5nZShkYXRlUmFuZ2VBdHRyLCBsZXZlbC5kYXRlUmFuZ2VzW2RhdGVSYW5nZUF0dHIuSURdLCBsZXZlbC5kYXRlUmFuZ2VUYWdDb3VudCk7XG4gICAgICAgICAgICAgIGxldmVsLmRhdGVSYW5nZVRhZ0NvdW50Kys7XG4gICAgICAgICAgICAgIGlmIChkYXRlUmFuZ2UuaXNWYWxpZCB8fCBsZXZlbC5za2lwcGVkU2VnbWVudHMpIHtcbiAgICAgICAgICAgICAgICBsZXZlbC5kYXRlUmFuZ2VzW2RhdGVSYW5nZS5pZF0gPSBkYXRlUmFuZ2U7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYElnbm9yaW5nIGludmFsaWQgREFURVJBTkdFIHRhZzogXCIke3ZhbHVlMX1cImApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIEFkZCB0byBmcmFnbWVudCB0YWcgbGlzdCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgKDwgdjEuMi4wKVxuICAgICAgICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaChbJ0VYVC1YLURBVEVSQU5HRScsIHZhbHVlMV0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdERUZJTkUnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFyaWFibGVBdHRyaWJ1dGVzID0gbmV3IEF0dHJMaXN0KHZhbHVlMSwgbGV2ZWwpO1xuICAgICAgICAgICAgICAgIGlmICgnSU1QT1JUJyBpbiB2YXJpYWJsZUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgIGltcG9ydFZhcmlhYmxlRGVmaW5pdGlvbihsZXZlbCwgdmFyaWFibGVBdHRyaWJ1dGVzLCBtdWx0aXZhcmlhbnRWYXJpYWJsZUxpc3QpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBhZGRWYXJpYWJsZURlZmluaXRpb24obGV2ZWwsIHZhcmlhYmxlQXR0cmlidXRlcywgYmFzZXVybCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ0RJU0NPTlRJTlVJVFktU0VRVUVOQ0UnOlxuICAgICAgICAgICAgaWYgKGxldmVsLnN0YXJ0Q0MgIT09IDApIHtcbiAgICAgICAgICAgICAgYXNzaWduTXVsdGlwbGVNZWRpYVBsYXlsaXN0VGFnT2NjdXJhbmNlRXJyb3IobGV2ZWwsIHRhZywgcmVzdWx0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZnJhZ21lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgYXNzaWduTXVzdEFwcGVhckJlZm9yZVNlZ21lbnRzRXJyb3IobGV2ZWwsIHRhZywgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldmVsLnN0YXJ0Q0MgPSBkaXNjb250aW51aXR5Q291bnRlciA9IHBhcnNlSW50KHZhbHVlMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdLRVknOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCBsZXZlbEtleSA9IHBhcnNlS2V5KHZhbHVlMSwgYmFzZXVybCwgbGV2ZWwpO1xuICAgICAgICAgICAgICBpZiAobGV2ZWxLZXkuaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICAgICAgICAgIGlmIChsZXZlbEtleS5tZXRob2QgPT09ICdOT05FJykge1xuICAgICAgICAgICAgICAgICAgbGV2ZWxrZXlzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghbGV2ZWxrZXlzKSB7XG4gICAgICAgICAgICAgICAgICBsZXZlbGtleXMgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudEtleSA9IGxldmVsa2V5c1tsZXZlbEtleS5rZXlGb3JtYXRdO1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBkdXBsaWNhdGUgcGxheWxpc3QgS0VZIHRhZ3NcbiAgICAgICAgICAgICAgICBpZiAoIShjdXJyZW50S2V5ICE9IG51bGwgJiYgY3VycmVudEtleS5tYXRjaGVzKGxldmVsS2V5KSkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldmVsa2V5cyA9IF9leHRlbmRzKHt9LCBsZXZlbGtleXMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgbGV2ZWxrZXlzW2xldmVsS2V5LmtleUZvcm1hdF0gPSBsZXZlbEtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYFtLZXlzXSBJZ25vcmluZyBpbnZhbGlkIEVYVC1YLUtFWSB0YWc6IFwiJHt2YWx1ZTF9XCJgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdTVEFSVCc6XG4gICAgICAgICAgICBsZXZlbC5zdGFydFRpbWVPZmZzZXQgPSBwYXJzZVN0YXJ0VGltZU9mZnNldCh2YWx1ZTEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnTUFQJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgbWFwQXR0cnMgPSBuZXcgQXR0ckxpc3QodmFsdWUxLCBsZXZlbCk7XG4gICAgICAgICAgICAgIGlmIChmcmFnLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbCBzZWdtZW50IHRhZyBpcyBhZnRlciBzZWdtZW50IGR1cmF0aW9uIHRhZy5cbiAgICAgICAgICAgICAgICAvLyAgICNFWFRJTkY6IDYuMFxuICAgICAgICAgICAgICAgIC8vICAgI0VYVC1YLU1BUDpVUkk9XCJpbml0Lm1wNFxuICAgICAgICAgICAgICAgIGNvbnN0IGluaXQgPSBuZXcgRnJhZ21lbnQodHlwZSwgYmFzZSk7XG4gICAgICAgICAgICAgICAgc2V0SW5pdFNlZ21lbnQoaW5pdCwgbWFwQXR0cnMsIGlkLCBsZXZlbGtleXMpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRJbml0U2VnbWVudCA9IGluaXQ7XG4gICAgICAgICAgICAgICAgZnJhZy5pbml0U2VnbWVudCA9IGN1cnJlbnRJbml0U2VnbWVudDtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEluaXRTZWdtZW50LnJhd1Byb2dyYW1EYXRlVGltZSAmJiAhZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICAgICAgICAgICAgICAgIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lID0gY3VycmVudEluaXRTZWdtZW50LnJhd1Byb2dyYW1EYXRlVGltZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbCBzZWdtZW50IHRhZyBpcyBiZWZvcmUgc2VnbWVudCBkdXJhdGlvbiB0YWdcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgY2FzZSB3aGVyZSBFWFQtWC1NQVAgaXMgZGVjbGFyZWQgYWZ0ZXIgRVhULVgtQllURVJBTkdFXG4gICAgICAgICAgICAgICAgY29uc3QgZW5kID0gZnJhZy5ieXRlUmFuZ2VFbmRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgaWYgKGVuZCkge1xuICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBmcmFnLmJ5dGVSYW5nZVN0YXJ0T2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgbmV4dEJ5dGVSYW5nZSA9IGAke2VuZCAtIHN0YXJ0fUAke3N0YXJ0fWA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG5leHRCeXRlUmFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXRJbml0U2VnbWVudChmcmFnLCBtYXBBdHRycywgaWQsIGxldmVsa2V5cyk7XG4gICAgICAgICAgICAgICAgY3VycmVudEluaXRTZWdtZW50ID0gZnJhZztcbiAgICAgICAgICAgICAgICBjcmVhdGVOZXh0RnJhZyA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3VycmVudEluaXRTZWdtZW50LmNjID0gZGlzY29udGludWl0eUNvdW50ZXI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ1NFUlZFUi1DT05UUk9MJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWYgKHNlcnZlckNvbnRyb2xBdHRycykge1xuICAgICAgICAgICAgICAgIGFzc2lnbk11bHRpcGxlTWVkaWFQbGF5bGlzdFRhZ09jY3VyYW5jZUVycm9yKGxldmVsLCB0YWcsIHJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2VydmVyQ29udHJvbEF0dHJzID0gbmV3IEF0dHJMaXN0KHZhbHVlMSk7XG4gICAgICAgICAgICAgIGxldmVsLmNhbkJsb2NrUmVsb2FkID0gc2VydmVyQ29udHJvbEF0dHJzLmJvb2woJ0NBTi1CTE9DSy1SRUxPQUQnKTtcbiAgICAgICAgICAgICAgbGV2ZWwuY2FuU2tpcFVudGlsID0gc2VydmVyQ29udHJvbEF0dHJzLm9wdGlvbmFsRmxvYXQoJ0NBTi1TS0lQLVVOVElMJywgMCk7XG4gICAgICAgICAgICAgIGxldmVsLmNhblNraXBEYXRlUmFuZ2VzID0gbGV2ZWwuY2FuU2tpcFVudGlsID4gMCAmJiBzZXJ2ZXJDb250cm9sQXR0cnMuYm9vbCgnQ0FOLVNLSVAtREFURVJBTkdFUycpO1xuICAgICAgICAgICAgICBsZXZlbC5wYXJ0SG9sZEJhY2sgPSBzZXJ2ZXJDb250cm9sQXR0cnMub3B0aW9uYWxGbG9hdCgnUEFSVC1IT0xELUJBQ0snLCAwKTtcbiAgICAgICAgICAgICAgbGV2ZWwuaG9sZEJhY2sgPSBzZXJ2ZXJDb250cm9sQXR0cnMub3B0aW9uYWxGbG9hdCgnSE9MRC1CQUNLJywgMCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ1BBUlQtSU5GJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWYgKGxldmVsLnBhcnRUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICBhc3NpZ25NdWx0aXBsZU1lZGlhUGxheWxpc3RUYWdPY2N1cmFuY2VFcnJvcihsZXZlbCwgdGFnLCByZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnRJbmZBdHRycyA9IG5ldyBBdHRyTGlzdCh2YWx1ZTEpO1xuICAgICAgICAgICAgICBsZXZlbC5wYXJ0VGFyZ2V0ID0gcGFydEluZkF0dHJzLmRlY2ltYWxGbG9hdGluZ1BvaW50KCdQQVJULVRBUkdFVCcpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdQQVJUJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbGV0IHBhcnRMaXN0ID0gbGV2ZWwucGFydExpc3Q7XG4gICAgICAgICAgICAgIGlmICghcGFydExpc3QpIHtcbiAgICAgICAgICAgICAgICBwYXJ0TGlzdCA9IGxldmVsLnBhcnRMaXN0ID0gW107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNGcmFnbWVudFBhcnQgPSBjdXJyZW50UGFydCA+IDAgPyBwYXJ0TGlzdFtwYXJ0TGlzdC5sZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBjdXJyZW50UGFydCsrO1xuICAgICAgICAgICAgICBjb25zdCBwYXJ0QXR0cnMgPSBuZXcgQXR0ckxpc3QodmFsdWUxLCBsZXZlbCk7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnQgPSBuZXcgUGFydChwYXJ0QXR0cnMsIGZyYWcsIGJhc2UsIGluZGV4LCBwcmV2aW91c0ZyYWdtZW50UGFydCk7XG4gICAgICAgICAgICAgIHBhcnRMaXN0LnB1c2gocGFydCk7XG4gICAgICAgICAgICAgIGZyYWcuZHVyYXRpb24gKz0gcGFydC5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnUFJFTE9BRC1ISU5UJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgcHJlbG9hZEhpbnRBdHRycyA9IG5ldyBBdHRyTGlzdCh2YWx1ZTEsIGxldmVsKTtcbiAgICAgICAgICAgICAgbGV2ZWwucHJlbG9hZEhpbnQgPSBwcmVsb2FkSGludEF0dHJzO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdSRU5ESVRJT04tUkVQT1JUJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgcmVuZGl0aW9uUmVwb3J0QXR0cnMgPSBuZXcgQXR0ckxpc3QodmFsdWUxLCBsZXZlbCk7XG4gICAgICAgICAgICAgIGxldmVsLnJlbmRpdGlvblJlcG9ydHMgPSBsZXZlbC5yZW5kaXRpb25SZXBvcnRzIHx8IFtdO1xuICAgICAgICAgICAgICBsZXZlbC5yZW5kaXRpb25SZXBvcnRzLnB1c2gocmVuZGl0aW9uUmVwb3J0QXR0cnMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYGxpbmUgcGFyc2VkIGJ1dCBub3QgaGFuZGxlZDogJHtyZXN1bHR9YCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJldkZyYWcgJiYgIXByZXZGcmFnLnJlbHVybCkge1xuICAgICAgZnJhZ21lbnRzLnBvcCgpO1xuICAgICAgdG90YWxkdXJhdGlvbiAtPSBwcmV2RnJhZy5kdXJhdGlvbjtcbiAgICAgIGlmIChsZXZlbC5wYXJ0TGlzdCkge1xuICAgICAgICBsZXZlbC5mcmFnbWVudEhpbnQgPSBwcmV2RnJhZztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxldmVsLnBhcnRMaXN0KSB7XG4gICAgICBhc3NpZ25Qcm9ncmFtRGF0ZVRpbWUoZnJhZywgcHJldkZyYWcsIHByb2dyYW1EYXRlVGltZXMpO1xuICAgICAgZnJhZy5jYyA9IGRpc2NvbnRpbnVpdHlDb3VudGVyO1xuICAgICAgbGV2ZWwuZnJhZ21lbnRIaW50ID0gZnJhZztcbiAgICAgIGlmIChsZXZlbGtleXMpIHtcbiAgICAgICAgc2V0RnJhZ0xldmVsS2V5cyhmcmFnLCBsZXZlbGtleXMsIGxldmVsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFsZXZlbC50YXJnZXRkdXJhdGlvbikge1xuICAgICAgbGV2ZWwucGxheWxpc3RQYXJzaW5nRXJyb3IgPSBuZXcgRXJyb3IoYCNFWFQtWC1UQVJHRVREVVJBVElPTiBpcyByZXF1aXJlZGApO1xuICAgIH1cbiAgICBjb25zdCBmcmFnbWVudExlbmd0aCA9IGZyYWdtZW50cy5sZW5ndGg7XG4gICAgY29uc3QgZmlyc3RGcmFnbWVudCA9IGZyYWdtZW50c1swXTtcbiAgICBjb25zdCBsYXN0RnJhZ21lbnQgPSBmcmFnbWVudHNbZnJhZ21lbnRMZW5ndGggLSAxXTtcbiAgICB0b3RhbGR1cmF0aW9uICs9IGxldmVsLnNraXBwZWRTZWdtZW50cyAqIGxldmVsLnRhcmdldGR1cmF0aW9uO1xuICAgIGlmICh0b3RhbGR1cmF0aW9uID4gMCAmJiBmcmFnbWVudExlbmd0aCAmJiBsYXN0RnJhZ21lbnQpIHtcbiAgICAgIGxldmVsLmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbiA9IHRvdGFsZHVyYXRpb24gLyBmcmFnbWVudExlbmd0aDtcbiAgICAgIGNvbnN0IGxhc3RTbiA9IGxhc3RGcmFnbWVudC5zbjtcbiAgICAgIGxldmVsLmVuZFNOID0gbGFzdFNuICE9PSAnaW5pdFNlZ21lbnQnID8gbGFzdFNuIDogMDtcbiAgICAgIGlmICghbGV2ZWwubGl2ZSkge1xuICAgICAgICBsYXN0RnJhZ21lbnQuZW5kTGlzdCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoZmlyc3RGcmFnbWVudCAmJiBsZXZlbC5zdGFydENDID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV2ZWwuc3RhcnRDQyA9IGZpcnN0RnJhZ21lbnQuY2M7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEJhY2tmaWxsIGFueSBtaXNzaW5nIFBEVCB2YWx1ZXNcbiAgICAgICAqIFwiSWYgdGhlIGZpcnN0IEVYVC1YLVBST0dSQU0tREFURS1USU1FIHRhZyBpbiBhIFBsYXlsaXN0IGFwcGVhcnMgYWZ0ZXJcbiAgICAgICAqIG9uZSBvciBtb3JlIE1lZGlhIFNlZ21lbnQgVVJJcywgdGhlIGNsaWVudCBTSE9VTEQgZXh0cmFwb2xhdGVcbiAgICAgICAqIGJhY2t3YXJkIGZyb20gdGhhdCB0YWcgKHVzaW5nIEVYVElORiBkdXJhdGlvbnMgYW5kL29yIG1lZGlhXG4gICAgICAgKiB0aW1lc3RhbXBzKSB0byBhc3NvY2lhdGUgZGF0ZXMgd2l0aCB0aG9zZSBzZWdtZW50cy5cIlxuICAgICAgICogV2UgaGF2ZSBhbHJlYWR5IGV4dHJhcG9sYXRlZCBmb3J3YXJkLCBidXQgYWxsIGZyYWdtZW50cyB1cCB0byB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgUERUIGRvIG5vdCBoYXZlIHRoZWlyIFBEVHNcbiAgICAgICAqIGNvbXB1dGVkLlxuICAgICAgICovXG4gICAgICBpZiAoZmlyc3RQZHRJbmRleCA+IDApIHtcbiAgICAgICAgYmFja2ZpbGxQcm9ncmFtRGF0ZVRpbWVzKGZyYWdtZW50cywgZmlyc3RQZHRJbmRleCk7XG4gICAgICAgIGlmIChmaXJzdEZyYWdtZW50KSB7XG4gICAgICAgICAgcHJvZ3JhbURhdGVUaW1lcy51bnNoaWZ0KGZpcnN0RnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldmVsLmVuZFNOID0gMDtcbiAgICAgIGxldmVsLnN0YXJ0Q0MgPSAwO1xuICAgIH1cbiAgICBpZiAobGV2ZWwuZnJhZ21lbnRIaW50KSB7XG4gICAgICB0b3RhbGR1cmF0aW9uICs9IGxldmVsLmZyYWdtZW50SGludC5kdXJhdGlvbjtcbiAgICB9XG4gICAgbGV2ZWwudG90YWxkdXJhdGlvbiA9IHRvdGFsZHVyYXRpb247XG4gICAgaWYgKHByb2dyYW1EYXRlVGltZXMubGVuZ3RoICYmIGxldmVsLmRhdGVSYW5nZVRhZ0NvdW50ICYmIGZpcnN0RnJhZ21lbnQpIHtcbiAgICAgIG1hcERhdGVSYW5nZXMocHJvZ3JhbURhdGVUaW1lcywgbGV2ZWwpO1xuICAgIH1cbiAgICBsZXZlbC5lbmRDQyA9IGRpc2NvbnRpbnVpdHlDb3VudGVyO1xuICAgIHJldHVybiBsZXZlbDtcbiAgfVxufVxuZnVuY3Rpb24gbWFwRGF0ZVJhbmdlcyhwcm9ncmFtRGF0ZVRpbWVzLCBkZXRhaWxzKSB7XG4gIC8vIE1ha2Ugc3VyZSBEYXRlUmFuZ2VzIGFyZSBtYXBwZWQgdG8gYSBQcm9ncmFtRGF0ZVRpbWUgdGFnIHRoYXQgYXBwbGllcyBhIGRhdGUgdG8gYSBzZWdtZW50IHRoYXQgb3ZlcmxhcHMgd2l0aCBpdHMgc3RhcnQgZGF0ZVxuICBjb25zdCBwcm9ncmFtRGF0ZVRpbWVDb3VudCA9IHByb2dyYW1EYXRlVGltZXMubGVuZ3RoO1xuICBpZiAoIXByb2dyYW1EYXRlVGltZUNvdW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGxhc3RQcm9ncmFtRGF0ZVRpbWUgPSBwcm9ncmFtRGF0ZVRpbWVzW3Byb2dyYW1EYXRlVGltZUNvdW50IC0gMV07XG4gIGNvbnN0IHBsYXlsaXN0RW5kID0gZGV0YWlscy5saXZlID8gSW5maW5pdHkgOiBkZXRhaWxzLnRvdGFsZHVyYXRpb247XG4gIGNvbnN0IGRhdGVSYW5nZUlkcyA9IE9iamVjdC5rZXlzKGRldGFpbHMuZGF0ZVJhbmdlcyk7XG4gIGZvciAobGV0IGkgPSBkYXRlUmFuZ2VJZHMubGVuZ3RoOyBpLS07KSB7XG4gICAgY29uc3QgZGF0ZVJhbmdlID0gZGV0YWlscy5kYXRlUmFuZ2VzW2RhdGVSYW5nZUlkc1tpXV07XG4gICAgY29uc3Qgc3RhcnREYXRlVGltZSA9IGRhdGVSYW5nZS5zdGFydERhdGUuZ2V0VGltZSgpO1xuICAgIGRhdGVSYW5nZS50YWdBbmNob3IgPSBsYXN0UHJvZ3JhbURhdGVUaW1lLnJlZjtcbiAgICBmb3IgKGxldCBqID0gcHJvZ3JhbURhdGVUaW1lQ291bnQ7IGotLTspIHtcbiAgICAgIGNvbnN0IGZyYWdJbmRleCA9IGZpbmRGcmFnbWVudFdpdGhTdGFydERhdGUoZGV0YWlscywgc3RhcnREYXRlVGltZSwgcHJvZ3JhbURhdGVUaW1lcywgaiwgcGxheWxpc3RFbmQpO1xuICAgICAgaWYgKGZyYWdJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgZGF0ZVJhbmdlLnRhZ0FuY2hvciA9IGRldGFpbHMuZnJhZ21lbnRzW2ZyYWdJbmRleF0ucmVmO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGZpbmRGcmFnbWVudFdpdGhTdGFydERhdGUoZGV0YWlscywgc3RhcnREYXRlVGltZSwgcHJvZ3JhbURhdGVUaW1lcywgaW5kZXgsIGVuZFRpbWUpIHtcbiAgY29uc3QgcGR0RnJhZ21lbnQgPSBwcm9ncmFtRGF0ZVRpbWVzW2luZGV4XTtcbiAgaWYgKHBkdEZyYWdtZW50KSB7XG4gICAgLy8gZmluZCBtYXRjaGluZyByYW5nZSBiZXR3ZWVuIFBEVCB0YWdzXG4gICAgY29uc3QgcGR0U3RhcnQgPSBwZHRGcmFnbWVudC5wcm9ncmFtRGF0ZVRpbWU7XG4gICAgaWYgKHN0YXJ0RGF0ZVRpbWUgPj0gcGR0U3RhcnQgfHwgaW5kZXggPT09IDApIHtcbiAgICAgIHZhciBfcHJvZ3JhbURhdGVUaW1lcztcbiAgICAgIGNvbnN0IGR1cmF0aW9uQmV0d2VlblBkdCA9ICgoKF9wcm9ncmFtRGF0ZVRpbWVzID0gcHJvZ3JhbURhdGVUaW1lc1tpbmRleCArIDFdKSA9PSBudWxsID8gdm9pZCAwIDogX3Byb2dyYW1EYXRlVGltZXMuc3RhcnQpIHx8IGVuZFRpbWUpIC0gcGR0RnJhZ21lbnQuc3RhcnQ7XG4gICAgICBpZiAoc3RhcnREYXRlVGltZSA8PSBwZHRTdGFydCArIGR1cmF0aW9uQmV0d2VlblBkdCAqIDEwMDApIHtcbiAgICAgICAgLy8gbWFwIHRvIGZyYWdtZW50IHdpdGggZGF0ZS10aW1lIHJhbmdlXG4gICAgICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBwcm9ncmFtRGF0ZVRpbWVzW2luZGV4XS5zbiAtIGRldGFpbHMuc3RhcnRTTjtcbiAgICAgICAgY29uc3QgZnJhZ21lbnRzID0gZGV0YWlscy5mcmFnbWVudHM7XG4gICAgICAgIGlmIChmcmFnbWVudHMubGVuZ3RoID4gcHJvZ3JhbURhdGVUaW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBlbmRTZWdtZW50ID0gcHJvZ3JhbURhdGVUaW1lc1tpbmRleCArIDFdIHx8IGZyYWdtZW50c1tmcmFnbWVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgY29uc3QgZW5kSW5kZXggPSBlbmRTZWdtZW50LnNuIC0gZGV0YWlscy5zdGFydFNOO1xuICAgICAgICAgIGZvciAobGV0IGkgPSBlbmRJbmRleDsgaSA+IHN0YXJ0SW5kZXg7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgZnJhZ1N0YXJ0RGF0ZVRpbWUgPSBmcmFnbWVudHNbaV0ucHJvZ3JhbURhdGVUaW1lO1xuICAgICAgICAgICAgaWYgKHN0YXJ0RGF0ZVRpbWUgPj0gZnJhZ1N0YXJ0RGF0ZVRpbWUgJiYgc3RhcnREYXRlVGltZSA8IGZyYWdTdGFydERhdGVUaW1lICsgZnJhZ21lbnRzW2ldLmR1cmF0aW9uICogMTAwMCkge1xuICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXJ0SW5kZXg7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIHBhcnNlS2V5KGtleVRhZ0F0dHJpYnV0ZXMsIGJhc2V1cmwsIHBhcnNlZCkge1xuICB2YXIgX2tleUF0dHJzJE1FVEhPRCwgX2tleUF0dHJzJEtFWUZPUk1BVDtcbiAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzgyMTYjc2VjdGlvbi00LjMuMi40XG4gIGNvbnN0IGtleUF0dHJzID0gbmV3IEF0dHJMaXN0KGtleVRhZ0F0dHJpYnV0ZXMsIHBhcnNlZCk7XG4gIGNvbnN0IGRlY3J5cHRtZXRob2QgPSAoX2tleUF0dHJzJE1FVEhPRCA9IGtleUF0dHJzLk1FVEhPRCkgIT0gbnVsbCA/IF9rZXlBdHRycyRNRVRIT0QgOiAnJztcbiAgY29uc3QgZGVjcnlwdHVyaSA9IGtleUF0dHJzLlVSSTtcbiAgY29uc3QgZGVjcnlwdGl2ID0ga2V5QXR0cnMuaGV4YWRlY2ltYWxJbnRlZ2VyKCdJVicpO1xuICBjb25zdCBkZWNyeXB0a2V5Zm9ybWF0dmVyc2lvbnMgPSBrZXlBdHRycy5LRVlGT1JNQVRWRVJTSU9OUztcbiAgLy8gRnJvbSBSRkM6IFRoaXMgYXR0cmlidXRlIGlzIE9QVElPTkFMOyBpdHMgYWJzZW5jZSBpbmRpY2F0ZXMgYW4gaW1wbGljaXQgdmFsdWUgb2YgXCJpZGVudGl0eVwiLlxuICBjb25zdCBkZWNyeXB0a2V5Zm9ybWF0ID0gKF9rZXlBdHRycyRLRVlGT1JNQVQgPSBrZXlBdHRycy5LRVlGT1JNQVQpICE9IG51bGwgPyBfa2V5QXR0cnMkS0VZRk9STUFUIDogJ2lkZW50aXR5JztcbiAgaWYgKGRlY3J5cHR1cmkgJiYga2V5QXR0cnMuSVYgJiYgIWRlY3J5cHRpdikge1xuICAgIGxvZ2dlci5lcnJvcihgSW52YWxpZCBJVjogJHtrZXlBdHRycy5JVn1gKTtcbiAgfVxuICAvLyBJZiBkZWNyeXB0dXJpIGlzIGEgVVJJIHdpdGggYSBzY2hlbWUsIHRoZW4gYmFzZXVybCB3aWxsIGJlIGlnbm9yZWRcbiAgLy8gTm8gdXJpIGlzIGFsbG93ZWQgd2hlbiBNRVRIT0QgaXMgTk9ORVxuICBjb25zdCByZXNvbHZlZFVyaSA9IGRlY3J5cHR1cmkgPyBNM1U4UGFyc2VyLnJlc29sdmUoZGVjcnlwdHVyaSwgYmFzZXVybCkgOiAnJztcbiAgY29uc3Qga2V5Rm9ybWF0VmVyc2lvbnMgPSAoZGVjcnlwdGtleWZvcm1hdHZlcnNpb25zID8gZGVjcnlwdGtleWZvcm1hdHZlcnNpb25zIDogJzEnKS5zcGxpdCgnLycpLm1hcChOdW1iZXIpLmZpbHRlcihOdW1iZXIuaXNGaW5pdGUpO1xuICByZXR1cm4gbmV3IExldmVsS2V5KGRlY3J5cHRtZXRob2QsIHJlc29sdmVkVXJpLCBkZWNyeXB0a2V5Zm9ybWF0LCBrZXlGb3JtYXRWZXJzaW9ucywgZGVjcnlwdGl2LCBrZXlBdHRycy5LRVlJRCk7XG59XG5mdW5jdGlvbiBwYXJzZVN0YXJ0VGltZU9mZnNldChzdGFydEF0dHJpYnV0ZXMpIHtcbiAgY29uc3Qgc3RhcnRBdHRycyA9IG5ldyBBdHRyTGlzdChzdGFydEF0dHJpYnV0ZXMpO1xuICBjb25zdCBzdGFydFRpbWVPZmZzZXQgPSBzdGFydEF0dHJzLmRlY2ltYWxGbG9hdGluZ1BvaW50KCdUSU1FLU9GRlNFVCcpO1xuICBpZiAoaXNGaW5pdGVOdW1iZXIoc3RhcnRUaW1lT2Zmc2V0KSkge1xuICAgIHJldHVybiBzdGFydFRpbWVPZmZzZXQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBzZXRDb2RlY3MoY29kZWNzQXR0cmlidXRlVmFsdWUsIGxldmVsKSB7XG4gIGxldCBjb2RlY3MgPSAoY29kZWNzQXR0cmlidXRlVmFsdWUgfHwgJycpLnNwbGl0KC9bICxdKy8pLmZpbHRlcihjID0+IGMpO1xuICBbJ3ZpZGVvJywgJ2F1ZGlvJywgJ3RleHQnXS5mb3JFYWNoKHR5cGUgPT4ge1xuICAgIGNvbnN0IGZpbHRlcmVkID0gY29kZWNzLmZpbHRlcihjb2RlYyA9PiBpc0NvZGVjVHlwZShjb2RlYywgdHlwZSkpO1xuICAgIGlmIChmaWx0ZXJlZC5sZW5ndGgpIHtcbiAgICAgIC8vIENvbW1hIHNlcGFyYXRlZCBsaXN0IG9mIGFsbCBjb2RlY3MgZm9yIHR5cGVcbiAgICAgIGxldmVsW2Ake3R5cGV9Q29kZWNgXSA9IGZpbHRlcmVkLm1hcChjID0+IGMuc3BsaXQoJy8nKVswXSkuam9pbignLCcpO1xuICAgICAgLy8gUmVtb3ZlIGtub3duIGNvZGVjcyBzbyB0aGF0IG9ubHkgdW5rbm93bkNvZGVjcyBhcmUgbGVmdCBhZnRlciBpdGVyYXRpbmcgdGhyb3VnaCBlYWNoIHR5cGVcbiAgICAgIGNvZGVjcyA9IGNvZGVjcy5maWx0ZXIoY29kZWMgPT4gZmlsdGVyZWQuaW5kZXhPZihjb2RlYykgPT09IC0xKTtcbiAgICB9XG4gIH0pO1xuICBsZXZlbC51bmtub3duQ29kZWNzID0gY29kZWNzO1xufVxuZnVuY3Rpb24gYXNzaWduQ29kZWMobWVkaWEsIGdyb3VwSXRlbSwgY29kZWNQcm9wZXJ0eSkge1xuICBjb25zdCBjb2RlY1ZhbHVlID0gZ3JvdXBJdGVtW2NvZGVjUHJvcGVydHldO1xuICBpZiAoY29kZWNWYWx1ZSkge1xuICAgIG1lZGlhW2NvZGVjUHJvcGVydHldID0gY29kZWNWYWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gYmFja2ZpbGxQcm9ncmFtRGF0ZVRpbWVzKGZyYWdtZW50cywgZmlyc3RQZHRJbmRleCkge1xuICBsZXQgZnJhZ1ByZXYgPSBmcmFnbWVudHNbZmlyc3RQZHRJbmRleF07XG4gIGZvciAobGV0IGkgPSBmaXJzdFBkdEluZGV4OyBpLS07KSB7XG4gICAgY29uc3QgZnJhZyA9IGZyYWdtZW50c1tpXTtcbiAgICAvLyBFeGl0IG9uIGRlbHRhLXBsYXlsaXN0IHNraXBwZWQgc2VnbWVudHNcbiAgICBpZiAoIWZyYWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZnJhZy5wcm9ncmFtRGF0ZVRpbWUgPSBmcmFnUHJldi5wcm9ncmFtRGF0ZVRpbWUgLSBmcmFnLmR1cmF0aW9uICogMTAwMDtcbiAgICBmcmFnUHJldiA9IGZyYWc7XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2lnblByb2dyYW1EYXRlVGltZShmcmFnLCBwcmV2RnJhZywgcHJvZ3JhbURhdGVUaW1lcykge1xuICBpZiAoZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICBwcm9ncmFtRGF0ZVRpbWVzLnB1c2goZnJhZyk7XG4gIH0gZWxzZSBpZiAocHJldkZyYWcgIT0gbnVsbCAmJiBwcmV2RnJhZy5wcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICBmcmFnLnByb2dyYW1EYXRlVGltZSA9IHByZXZGcmFnLmVuZFByb2dyYW1EYXRlVGltZTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0SW5pdFNlZ21lbnQoZnJhZywgbWFwQXR0cnMsIGlkLCBsZXZlbGtleXMpIHtcbiAgZnJhZy5yZWx1cmwgPSBtYXBBdHRycy5VUkk7XG4gIGlmIChtYXBBdHRycy5CWVRFUkFOR0UpIHtcbiAgICBmcmFnLnNldEJ5dGVSYW5nZShtYXBBdHRycy5CWVRFUkFOR0UpO1xuICB9XG4gIGZyYWcubGV2ZWwgPSBpZDtcbiAgZnJhZy5zbiA9ICdpbml0U2VnbWVudCc7XG4gIGlmIChsZXZlbGtleXMpIHtcbiAgICBmcmFnLmxldmVsa2V5cyA9IGxldmVsa2V5cztcbiAgfVxuICBmcmFnLmluaXRTZWdtZW50ID0gbnVsbDtcbn1cbmZ1bmN0aW9uIHNldEZyYWdMZXZlbEtleXMoZnJhZywgbGV2ZWxrZXlzLCBsZXZlbCkge1xuICBmcmFnLmxldmVsa2V5cyA9IGxldmVsa2V5cztcbiAgY29uc3Qge1xuICAgIGVuY3J5cHRlZEZyYWdtZW50c1xuICB9ID0gbGV2ZWw7XG4gIGlmICgoIWVuY3J5cHRlZEZyYWdtZW50cy5sZW5ndGggfHwgZW5jcnlwdGVkRnJhZ21lbnRzW2VuY3J5cHRlZEZyYWdtZW50cy5sZW5ndGggLSAxXS5sZXZlbGtleXMgIT09IGxldmVsa2V5cykgJiYgT2JqZWN0LmtleXMobGV2ZWxrZXlzKS5zb21lKGZvcm1hdCA9PiBsZXZlbGtleXNbZm9ybWF0XS5pc0NvbW1vbkVuY3J5cHRpb24pKSB7XG4gICAgZW5jcnlwdGVkRnJhZ21lbnRzLnB1c2goZnJhZyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2lnbk11bHRpcGxlTWVkaWFQbGF5bGlzdFRhZ09jY3VyYW5jZUVycm9yKGxldmVsLCB0YWcsIHJlc3VsdCkge1xuICBsZXZlbC5wbGF5bGlzdFBhcnNpbmdFcnJvciA9IG5ldyBFcnJvcihgI0VYVC1YLSR7dGFnfSBtdXN0IG5vdCBhcHBlYXIgbW9yZSB0aGFuIG9uY2UgKCR7cmVzdWx0WzBdfSlgKTtcbn1cbmZ1bmN0aW9uIGFzc2lnbk11c3RBcHBlYXJCZWZvcmVTZWdtZW50c0Vycm9yKGxldmVsLCB0YWcsIHJlc3VsdCkge1xuICBsZXZlbC5wbGF5bGlzdFBhcnNpbmdFcnJvciA9IG5ldyBFcnJvcihgI0VYVC1YLSR7dGFnfSBtdXN0IGFwcGVhciBiZWZvcmUgdGhlIGZpcnN0IE1lZGlhIFNlZ21lbnQgKCR7cmVzdWx0WzBdfSlgKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRnJvbVRvUFRTKGZyYWdGcm9tLCBmcmFnVG8pIHtcbiAgY29uc3QgZnJhZ1RvUFRTID0gZnJhZ1RvLnN0YXJ0UFRTO1xuICAvLyBpZiB3ZSBrbm93IHN0YXJ0UFRTW3RvSWR4XVxuICBpZiAoaXNGaW5pdGVOdW1iZXIoZnJhZ1RvUFRTKSkge1xuICAgIC8vIHVwZGF0ZSBmcmFnbWVudCBkdXJhdGlvbi5cbiAgICAvLyBpdCBoZWxwcyB0byBmaXggZHJpZnRzIGJldHdlZW4gcGxheWxpc3QgcmVwb3J0ZWQgZHVyYXRpb24gYW5kIGZyYWdtZW50IHJlYWwgZHVyYXRpb25cbiAgICBsZXQgZHVyYXRpb24gPSAwO1xuICAgIGxldCBmcmFnO1xuICAgIGlmIChmcmFnVG8uc24gPiBmcmFnRnJvbS5zbikge1xuICAgICAgZHVyYXRpb24gPSBmcmFnVG9QVFMgLSBmcmFnRnJvbS5zdGFydDtcbiAgICAgIGZyYWcgPSBmcmFnRnJvbTtcbiAgICB9IGVsc2Uge1xuICAgICAgZHVyYXRpb24gPSBmcmFnRnJvbS5zdGFydCAtIGZyYWdUb1BUUztcbiAgICAgIGZyYWcgPSBmcmFnVG87XG4gICAgfVxuICAgIGlmIChmcmFnLmR1cmF0aW9uICE9PSBkdXJhdGlvbikge1xuICAgICAgZnJhZy5zZXREdXJhdGlvbihkdXJhdGlvbik7XG4gICAgfVxuICAgIC8vIHdlIGRvbnQga25vdyBzdGFydFBUU1t0b0lkeF1cbiAgfSBlbHNlIGlmIChmcmFnVG8uc24gPiBmcmFnRnJvbS5zbikge1xuICAgIGNvbnN0IGNvbnRpZ3VvdXMgPSBmcmFnRnJvbS5jYyA9PT0gZnJhZ1RvLmNjO1xuICAgIC8vIFRPRE86IFdpdGggcGFydC1sb2FkaW5nIGVuZC9kdXJhdGlvbnMgd2UgbmVlZCB0byBjb25maXJtIHRoZSB3aG9sZSBmcmFnbWVudCBpcyBsb2FkZWQgYmVmb3JlIHVzaW5nIChvciBzZXR0aW5nKSBtaW5FbmRQVFNcbiAgICBpZiAoY29udGlndW91cyAmJiBmcmFnRnJvbS5taW5FbmRQVFMpIHtcbiAgICAgIGZyYWdUby5zZXRTdGFydChmcmFnRnJvbS5zdGFydCArIChmcmFnRnJvbS5taW5FbmRQVFMgLSBmcmFnRnJvbS5zdGFydCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcmFnVG8uc2V0U3RhcnQoZnJhZ0Zyb20uc3RhcnQgKyBmcmFnRnJvbS5kdXJhdGlvbik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZyYWdUby5zZXRTdGFydChNYXRoLm1heChmcmFnRnJvbS5zdGFydCAtIGZyYWdUby5kdXJhdGlvbiwgMCkpO1xuICB9XG59XG5mdW5jdGlvbiB1cGRhdGVGcmFnUFRTRFRTKGRldGFpbHMsIGZyYWcsIHN0YXJ0UFRTLCBlbmRQVFMsIHN0YXJ0RFRTLCBlbmREVFMpIHtcbiAgY29uc3QgcGFyc2VkTWVkaWFEdXJhdGlvbiA9IGVuZFBUUyAtIHN0YXJ0UFRTO1xuICBpZiAocGFyc2VkTWVkaWFEdXJhdGlvbiA8PSAwKSB7XG4gICAgbG9nZ2VyLndhcm4oJ0ZyYWdtZW50IHNob3VsZCBoYXZlIGEgcG9zaXRpdmUgZHVyYXRpb24nLCBmcmFnKTtcbiAgICBlbmRQVFMgPSBzdGFydFBUUyArIGZyYWcuZHVyYXRpb247XG4gICAgZW5kRFRTID0gc3RhcnREVFMgKyBmcmFnLmR1cmF0aW9uO1xuICB9XG4gIGxldCBtYXhTdGFydFBUUyA9IHN0YXJ0UFRTO1xuICBsZXQgbWluRW5kUFRTID0gZW5kUFRTO1xuICBjb25zdCBmcmFnU3RhcnRQdHMgPSBmcmFnLnN0YXJ0UFRTO1xuICBjb25zdCBmcmFnRW5kUHRzID0gZnJhZy5lbmRQVFM7XG4gIGlmIChpc0Zpbml0ZU51bWJlcihmcmFnU3RhcnRQdHMpKSB7XG4gICAgLy8gZGVsdGEgUFRTIGJldHdlZW4gYXVkaW8gYW5kIHZpZGVvXG4gICAgY29uc3QgZGVsdGFQVFMgPSBNYXRoLmFicyhmcmFnU3RhcnRQdHMgLSBzdGFydFBUUyk7XG4gICAgaWYgKCFpc0Zpbml0ZU51bWJlcihmcmFnLmRlbHRhUFRTKSkge1xuICAgICAgZnJhZy5kZWx0YVBUUyA9IGRlbHRhUFRTO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcmFnLmRlbHRhUFRTID0gTWF0aC5tYXgoZGVsdGFQVFMsIGZyYWcuZGVsdGFQVFMpO1xuICAgIH1cbiAgICBtYXhTdGFydFBUUyA9IE1hdGgubWF4KHN0YXJ0UFRTLCBmcmFnU3RhcnRQdHMpO1xuICAgIHN0YXJ0UFRTID0gTWF0aC5taW4oc3RhcnRQVFMsIGZyYWdTdGFydFB0cyk7XG4gICAgc3RhcnREVFMgPSBNYXRoLm1pbihzdGFydERUUywgZnJhZy5zdGFydERUUyk7XG4gICAgbWluRW5kUFRTID0gTWF0aC5taW4oZW5kUFRTLCBmcmFnRW5kUHRzKTtcbiAgICBlbmRQVFMgPSBNYXRoLm1heChlbmRQVFMsIGZyYWdFbmRQdHMpO1xuICAgIGVuZERUUyA9IE1hdGgubWF4KGVuZERUUywgZnJhZy5lbmREVFMpO1xuICB9XG4gIGNvbnN0IGRyaWZ0ID0gc3RhcnRQVFMgLSBmcmFnLnN0YXJ0O1xuICBpZiAoZnJhZy5zdGFydCAhPT0gMCkge1xuICAgIGZyYWcuc2V0U3RhcnQoc3RhcnRQVFMpO1xuICB9XG4gIGZyYWcuc2V0RHVyYXRpb24oZW5kUFRTIC0gZnJhZy5zdGFydCk7XG4gIGZyYWcuc3RhcnRQVFMgPSBzdGFydFBUUztcbiAgZnJhZy5tYXhTdGFydFBUUyA9IG1heFN0YXJ0UFRTO1xuICBmcmFnLnN0YXJ0RFRTID0gc3RhcnREVFM7XG4gIGZyYWcuZW5kUFRTID0gZW5kUFRTO1xuICBmcmFnLm1pbkVuZFBUUyA9IG1pbkVuZFBUUztcbiAgZnJhZy5lbmREVFMgPSBlbmREVFM7XG4gIGNvbnN0IHNuID0gZnJhZy5zbjtcbiAgLy8gZXhpdCBpZiBzbiBvdXQgb2YgcmFuZ2VcbiAgaWYgKCFkZXRhaWxzIHx8IHNuIDwgZGV0YWlscy5zdGFydFNOIHx8IHNuID4gZGV0YWlscy5lbmRTTikge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGxldCBpO1xuICBjb25zdCBmcmFnSWR4ID0gc24gLSBkZXRhaWxzLnN0YXJ0U047XG4gIGNvbnN0IGZyYWdtZW50cyA9IGRldGFpbHMuZnJhZ21lbnRzO1xuICAvLyB1cGRhdGUgZnJhZyByZWZlcmVuY2UgaW4gZnJhZ21lbnRzIGFycmF5XG4gIC8vIHJhdGlvbmFsZSBpcyB0aGF0IGZyYWdtZW50cyBhcnJheSBtaWdodCBub3QgY29udGFpbiB0aGlzIGZyYWcgb2JqZWN0LlxuICAvLyB0aGlzIHdpbGwgaGFwcGVuIGlmIHBsYXlsaXN0IGhhcyBiZWVuIHJlZnJlc2hlZCBiZXR3ZWVuIGZyYWcgbG9hZGluZyBhbmQgY2FsbCB0byB1cGRhdGVGcmFnUFRTRFRTKClcbiAgLy8gaWYgd2UgZG9uJ3QgdXBkYXRlIGZyYWcsIHdlIHdvbid0IGJlIGFibGUgdG8gcHJvcGFnYXRlIFBUUyBpbmZvIG9uIHRoZSBwbGF5bGlzdFxuICAvLyByZXN1bHRpbmcgaW4gaW52YWxpZCBzbGlkaW5nIGNvbXB1dGF0aW9uXG4gIGZyYWdtZW50c1tmcmFnSWR4XSA9IGZyYWc7XG4gIC8vIGFkanVzdCBmcmFnbWVudCBQVFMvZHVyYXRpb24gZnJvbSBzZXFudW0tMSB0byBmcmFnIDBcbiAgZm9yIChpID0gZnJhZ0lkeDsgaSA+IDA7IGktLSkge1xuICAgIHVwZGF0ZUZyb21Ub1BUUyhmcmFnbWVudHNbaV0sIGZyYWdtZW50c1tpIC0gMV0pO1xuICB9XG5cbiAgLy8gYWRqdXN0IGZyYWdtZW50IFBUUy9kdXJhdGlvbiBmcm9tIHNlcW51bSB0byBsYXN0IGZyYWdcbiAgZm9yIChpID0gZnJhZ0lkeDsgaSA8IGZyYWdtZW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICB1cGRhdGVGcm9tVG9QVFMoZnJhZ21lbnRzW2ldLCBmcmFnbWVudHNbaSArIDFdKTtcbiAgfVxuICBpZiAoZGV0YWlscy5mcmFnbWVudEhpbnQpIHtcbiAgICB1cGRhdGVGcm9tVG9QVFMoZnJhZ21lbnRzW2ZyYWdtZW50cy5sZW5ndGggLSAxXSwgZGV0YWlscy5mcmFnbWVudEhpbnQpO1xuICB9XG4gIGRldGFpbHMuUFRTS25vd24gPSBkZXRhaWxzLmFsaWduZWRTbGlkaW5nID0gdHJ1ZTtcbiAgcmV0dXJuIGRyaWZ0O1xufVxuZnVuY3Rpb24gbWVyZ2VEZXRhaWxzKG9sZERldGFpbHMsIG5ld0RldGFpbHMpIHtcbiAgaWYgKG9sZERldGFpbHMgPT09IG5ld0RldGFpbHMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gVHJhY2sgdGhlIGxhc3QgaW5pdFNlZ21lbnQgcHJvY2Vzc2VkLiBJbml0aWFsaXplIGl0IHRvIHRoZSBsYXN0IG9uZSBvbiB0aGUgdGltZWxpbmUuXG4gIGxldCBjdXJyZW50SW5pdFNlZ21lbnQgPSBudWxsO1xuICBjb25zdCBvbGRGcmFnbWVudHMgPSBvbGREZXRhaWxzLmZyYWdtZW50cztcbiAgZm9yIChsZXQgaSA9IG9sZEZyYWdtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IG9sZEluaXQgPSBvbGRGcmFnbWVudHNbaV0uaW5pdFNlZ21lbnQ7XG4gICAgaWYgKG9sZEluaXQpIHtcbiAgICAgIGN1cnJlbnRJbml0U2VnbWVudCA9IG9sZEluaXQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKG9sZERldGFpbHMuZnJhZ21lbnRIaW50KSB7XG4gICAgLy8gcHJldmVudCBQVFMgYW5kIGR1cmF0aW9uIGZyb20gYmVpbmcgYWRqdXN0ZWQgb24gdGhlIG5leHQgaGludFxuICAgIGRlbGV0ZSBvbGREZXRhaWxzLmZyYWdtZW50SGludC5lbmRQVFM7XG4gIH1cbiAgLy8gY2hlY2sgaWYgb2xkL25ldyBwbGF5bGlzdHMgaGF2ZSBmcmFnbWVudHMgaW4gY29tbW9uXG4gIC8vIGxvb3AgdGhyb3VnaCBvdmVybGFwcGluZyBTTiBhbmQgdXBkYXRlIHN0YXJ0UFRTLCBjYywgYW5kIGR1cmF0aW9uIGlmIGFueSBmb3VuZFxuICBsZXQgUFRTRnJhZztcbiAgbWFwRnJhZ21lbnRJbnRlcnNlY3Rpb24ob2xkRGV0YWlscywgbmV3RGV0YWlscywgKG9sZEZyYWcsIG5ld0ZyYWcsIG5ld0ZyYWdJbmRleCwgbmV3RnJhZ21lbnRzKSA9PiB7XG4gICAgaWYgKCghbmV3RGV0YWlscy5zdGFydENDIHx8IG5ld0RldGFpbHMuc2tpcHBlZFNlZ21lbnRzKSAmJiBuZXdGcmFnLmNjICE9PSBvbGRGcmFnLmNjKSB7XG4gICAgICBjb25zdCBjY09mZnNldCA9IG9sZEZyYWcuY2MgLSBuZXdGcmFnLmNjO1xuICAgICAgZm9yIChsZXQgaSA9IG5ld0ZyYWdJbmRleDsgaSA8IG5ld0ZyYWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBuZXdGcmFnbWVudHNbaV0uY2MgKz0gY2NPZmZzZXQ7XG4gICAgICB9XG4gICAgICBuZXdEZXRhaWxzLmVuZENDID0gbmV3RnJhZ21lbnRzW25ld0ZyYWdtZW50cy5sZW5ndGggLSAxXS5jYztcbiAgICB9XG4gICAgaWYgKGlzRmluaXRlTnVtYmVyKG9sZEZyYWcuc3RhcnRQVFMpICYmIGlzRmluaXRlTnVtYmVyKG9sZEZyYWcuZW5kUFRTKSkge1xuICAgICAgbmV3RnJhZy5zZXRTdGFydChuZXdGcmFnLnN0YXJ0UFRTID0gb2xkRnJhZy5zdGFydFBUUyk7XG4gICAgICBuZXdGcmFnLnN0YXJ0RFRTID0gb2xkRnJhZy5zdGFydERUUztcbiAgICAgIG5ld0ZyYWcubWF4U3RhcnRQVFMgPSBvbGRGcmFnLm1heFN0YXJ0UFRTO1xuICAgICAgbmV3RnJhZy5lbmRQVFMgPSBvbGRGcmFnLmVuZFBUUztcbiAgICAgIG5ld0ZyYWcuZW5kRFRTID0gb2xkRnJhZy5lbmREVFM7XG4gICAgICBuZXdGcmFnLm1pbkVuZFBUUyA9IG9sZEZyYWcubWluRW5kUFRTO1xuICAgICAgbmV3RnJhZy5zZXREdXJhdGlvbihvbGRGcmFnLmVuZFBUUyAtIG9sZEZyYWcuc3RhcnRQVFMpO1xuICAgICAgaWYgKG5ld0ZyYWcuZHVyYXRpb24pIHtcbiAgICAgICAgUFRTRnJhZyA9IG5ld0ZyYWc7XG4gICAgICB9XG5cbiAgICAgIC8vIFBUUyBpcyBrbm93biB3aGVuIGFueSBzZWdtZW50IGhhcyBzdGFydFBUUyBhbmQgZW5kUFRTXG4gICAgICBuZXdEZXRhaWxzLlBUU0tub3duID0gbmV3RGV0YWlscy5hbGlnbmVkU2xpZGluZyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChvbGRGcmFnLmhhc1N0cmVhbXMpIHtcbiAgICAgIG5ld0ZyYWcuZWxlbWVudGFyeVN0cmVhbXMgPSBvbGRGcmFnLmVsZW1lbnRhcnlTdHJlYW1zO1xuICAgIH1cbiAgICBuZXdGcmFnLmxvYWRlciA9IG9sZEZyYWcubG9hZGVyO1xuICAgIGlmIChvbGRGcmFnLmhhc1N0YXRzKSB7XG4gICAgICBuZXdGcmFnLnN0YXRzID0gb2xkRnJhZy5zdGF0cztcbiAgICB9XG4gICAgaWYgKG9sZEZyYWcuaW5pdFNlZ21lbnQpIHtcbiAgICAgIG5ld0ZyYWcuaW5pdFNlZ21lbnQgPSBvbGRGcmFnLmluaXRTZWdtZW50O1xuICAgICAgY3VycmVudEluaXRTZWdtZW50ID0gb2xkRnJhZy5pbml0U2VnbWVudDtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBuZXdGcmFnbWVudHMgPSBuZXdEZXRhaWxzLmZyYWdtZW50cztcbiAgY29uc3QgZnJhZ21lbnRzVG9DaGVjayA9IG5ld0RldGFpbHMuZnJhZ21lbnRIaW50ID8gbmV3RnJhZ21lbnRzLmNvbmNhdChuZXdEZXRhaWxzLmZyYWdtZW50SGludCkgOiBuZXdGcmFnbWVudHM7XG4gIGlmIChjdXJyZW50SW5pdFNlZ21lbnQpIHtcbiAgICBmcmFnbWVudHNUb0NoZWNrLmZvckVhY2goZnJhZyA9PiB7XG4gICAgICB2YXIgX2N1cnJlbnRJbml0U2VnbWVudDtcbiAgICAgIGlmIChmcmFnICYmICghZnJhZy5pbml0U2VnbWVudCB8fCBmcmFnLmluaXRTZWdtZW50LnJlbHVybCA9PT0gKChfY3VycmVudEluaXRTZWdtZW50ID0gY3VycmVudEluaXRTZWdtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2N1cnJlbnRJbml0U2VnbWVudC5yZWx1cmwpKSkge1xuICAgICAgICBmcmFnLmluaXRTZWdtZW50ID0gY3VycmVudEluaXRTZWdtZW50O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGlmIChuZXdEZXRhaWxzLnNraXBwZWRTZWdtZW50cykge1xuICAgIG5ld0RldGFpbHMuZGVsdGFVcGRhdGVGYWlsZWQgPSBuZXdGcmFnbWVudHMuc29tZShmcmFnID0+ICFmcmFnKTtcbiAgICBpZiAobmV3RGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCkge1xuICAgICAgbG9nZ2VyLndhcm4oJ1tsZXZlbC1oZWxwZXJdIFByZXZpb3VzIHBsYXlsaXN0IG1pc3Npbmcgc2VnbWVudHMgc2tpcHBlZCBpbiBkZWx0YSBwbGF5bGlzdCcpO1xuICAgICAgZm9yIChsZXQgaSA9IG5ld0RldGFpbHMuc2tpcHBlZFNlZ21lbnRzOyBpLS07KSB7XG4gICAgICAgIG5ld0ZyYWdtZW50cy5zaGlmdCgpO1xuICAgICAgfVxuICAgICAgbmV3RGV0YWlscy5zdGFydFNOID0gbmV3RnJhZ21lbnRzWzBdLnNuO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmV3RGV0YWlscy5jYW5Ta2lwRGF0ZVJhbmdlcykge1xuICAgICAgICBuZXdEZXRhaWxzLmRhdGVSYW5nZXMgPSBtZXJnZURhdGVSYW5nZXMob2xkRGV0YWlscy5kYXRlUmFuZ2VzLCBuZXdEZXRhaWxzKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByb2dyYW1EYXRlVGltZXMgPSBvbGREZXRhaWxzLmZyYWdtZW50cy5maWx0ZXIoZnJhZyA9PiBmcmFnLnJhd1Byb2dyYW1EYXRlVGltZSk7XG4gICAgICBpZiAob2xkRGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUgJiYgIW5ld0RldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZnJhZ21lbnRzVG9DaGVjay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChmcmFnbWVudHNUb0NoZWNrW2ldLnByb2dyYW1EYXRlVGltZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgYXNzaWduUHJvZ3JhbURhdGVUaW1lKGZyYWdtZW50c1RvQ2hlY2tbaV0sIGZyYWdtZW50c1RvQ2hlY2tbaSAtIDFdLCBwcm9ncmFtRGF0ZVRpbWVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1hcERhdGVSYW5nZXMocHJvZ3JhbURhdGVUaW1lcywgbmV3RGV0YWlscyk7XG4gICAgfVxuICAgIG5ld0RldGFpbHMuZW5kQ0MgPSBuZXdGcmFnbWVudHNbbmV3RnJhZ21lbnRzLmxlbmd0aCAtIDFdLmNjO1xuICB9XG4gIGlmICghbmV3RGV0YWlscy5zdGFydENDKSB7XG4gICAgdmFyIF9mcmFnUHJpb3JUb05ld1N0YXJ0JDtcbiAgICBjb25zdCBmcmFnUHJpb3JUb05ld1N0YXJ0ID0gZ2V0RnJhZ21lbnRXaXRoU04ob2xkRGV0YWlscywgbmV3RGV0YWlscy5zdGFydFNOIC0gMSk7XG4gICAgbmV3RGV0YWlscy5zdGFydENDID0gKF9mcmFnUHJpb3JUb05ld1N0YXJ0JCA9IGZyYWdQcmlvclRvTmV3U3RhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IGZyYWdQcmlvclRvTmV3U3RhcnQuY2MpICE9IG51bGwgPyBfZnJhZ1ByaW9yVG9OZXdTdGFydCQgOiBuZXdGcmFnbWVudHNbMF0uY2M7XG4gIH1cblxuICAvLyBNZXJnZSBwYXJ0c1xuICBtYXBQYXJ0SW50ZXJzZWN0aW9uKG9sZERldGFpbHMucGFydExpc3QsIG5ld0RldGFpbHMucGFydExpc3QsIChvbGRQYXJ0LCBuZXdQYXJ0KSA9PiB7XG4gICAgbmV3UGFydC5lbGVtZW50YXJ5U3RyZWFtcyA9IG9sZFBhcnQuZWxlbWVudGFyeVN0cmVhbXM7XG4gICAgbmV3UGFydC5zdGF0cyA9IG9sZFBhcnQuc3RhdHM7XG4gIH0pO1xuXG4gIC8vIGlmIGF0IGxlYXN0IG9uZSBmcmFnbWVudCBjb250YWlucyBQVFMgaW5mbywgcmVjb21wdXRlIFBUUyBpbmZvcm1hdGlvbiBmb3IgYWxsIGZyYWdtZW50c1xuICBpZiAoUFRTRnJhZykge1xuICAgIHVwZGF0ZUZyYWdQVFNEVFMobmV3RGV0YWlscywgUFRTRnJhZywgUFRTRnJhZy5zdGFydFBUUywgUFRTRnJhZy5lbmRQVFMsIFBUU0ZyYWcuc3RhcnREVFMsIFBUU0ZyYWcuZW5kRFRTKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBlbnN1cmUgdGhhdCBkZWx0YSBpcyB3aXRoaW4gb2xkRnJhZ21lbnRzIHJhbmdlXG4gICAgLy8gYWxzbyBhZGp1c3Qgc2xpZGluZyBpbiBjYXNlIGRlbHRhIGlzIDAgKHdlIGNvdWxkIGhhdmUgb2xkPVs1MC02MF0gYW5kIG5ldz1vbGQ9WzUwLTYxXSlcbiAgICAvLyBpbiB0aGF0IGNhc2Ugd2UgYWxzbyBuZWVkIHRvIGFkanVzdCBzdGFydCBvZmZzZXQgb2YgYWxsIGZyYWdtZW50c1xuICAgIGFkanVzdFNsaWRpbmcob2xkRGV0YWlscywgbmV3RGV0YWlscyk7XG4gIH1cbiAgaWYgKG5ld0ZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICBuZXdEZXRhaWxzLnRvdGFsZHVyYXRpb24gPSBuZXdEZXRhaWxzLmVkZ2UgLSBuZXdGcmFnbWVudHNbMF0uc3RhcnQ7XG4gIH1cbiAgbmV3RGV0YWlscy5kcmlmdFN0YXJ0VGltZSA9IG9sZERldGFpbHMuZHJpZnRTdGFydFRpbWU7XG4gIG5ld0RldGFpbHMuZHJpZnRTdGFydCA9IG9sZERldGFpbHMuZHJpZnRTdGFydDtcbiAgY29uc3QgYWR2YW5jZWREYXRlVGltZSA9IG5ld0RldGFpbHMuYWR2YW5jZWREYXRlVGltZTtcbiAgaWYgKG5ld0RldGFpbHMuYWR2YW5jZWQgJiYgYWR2YW5jZWREYXRlVGltZSkge1xuICAgIGNvbnN0IGVkZ2UgPSBuZXdEZXRhaWxzLmVkZ2U7XG4gICAgaWYgKCFuZXdEZXRhaWxzLmRyaWZ0U3RhcnQpIHtcbiAgICAgIG5ld0RldGFpbHMuZHJpZnRTdGFydFRpbWUgPSBhZHZhbmNlZERhdGVUaW1lO1xuICAgICAgbmV3RGV0YWlscy5kcmlmdFN0YXJ0ID0gZWRnZTtcbiAgICB9XG4gICAgbmV3RGV0YWlscy5kcmlmdEVuZFRpbWUgPSBhZHZhbmNlZERhdGVUaW1lO1xuICAgIG5ld0RldGFpbHMuZHJpZnRFbmQgPSBlZGdlO1xuICB9IGVsc2Uge1xuICAgIG5ld0RldGFpbHMuZHJpZnRFbmRUaW1lID0gb2xkRGV0YWlscy5kcmlmdEVuZFRpbWU7XG4gICAgbmV3RGV0YWlscy5kcmlmdEVuZCA9IG9sZERldGFpbHMuZHJpZnRFbmQ7XG4gICAgbmV3RGV0YWlscy5hZHZhbmNlZERhdGVUaW1lID0gb2xkRGV0YWlscy5hZHZhbmNlZERhdGVUaW1lO1xuICB9XG4gIGlmIChuZXdEZXRhaWxzLnJlcXVlc3RTY2hlZHVsZWQgPT09IC0xKSB7XG4gICAgbmV3RGV0YWlscy5yZXF1ZXN0U2NoZWR1bGVkID0gb2xkRGV0YWlscy5yZXF1ZXN0U2NoZWR1bGVkO1xuICB9XG59XG5mdW5jdGlvbiBtZXJnZURhdGVSYW5nZXMob2xkRGF0ZVJhbmdlcywgbmV3RGV0YWlscykge1xuICBjb25zdCB7XG4gICAgZGF0ZVJhbmdlczogZGVsdGFEYXRlUmFuZ2VzLFxuICAgIHJlY2VudGx5UmVtb3ZlZERhdGVyYW5nZXNcbiAgfSA9IG5ld0RldGFpbHM7XG4gIGNvbnN0IGRhdGVSYW5nZXMgPSBfZXh0ZW5kcyh7fSwgb2xkRGF0ZVJhbmdlcyk7XG4gIGlmIChyZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzKSB7XG4gICAgcmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcy5mb3JFYWNoKGlkID0+IHtcbiAgICAgIGRlbGV0ZSBkYXRlUmFuZ2VzW2lkXTtcbiAgICB9KTtcbiAgfVxuICBjb25zdCBtZXJnZUlkcyA9IE9iamVjdC5rZXlzKGRhdGVSYW5nZXMpO1xuICBjb25zdCBtZXJnZUNvdW50ID0gbWVyZ2VJZHMubGVuZ3RoO1xuICBpZiAobWVyZ2VDb3VudCkge1xuICAgIE9iamVjdC5rZXlzKGRlbHRhRGF0ZVJhbmdlcykuZm9yRWFjaChpZCA9PiB7XG4gICAgICBjb25zdCBtZXJnZWREYXRlUmFuZ2UgPSBkYXRlUmFuZ2VzW2lkXTtcbiAgICAgIGNvbnN0IGRhdGVSYW5nZSA9IG5ldyBEYXRlUmFuZ2UoZGVsdGFEYXRlUmFuZ2VzW2lkXS5hdHRyLCBtZXJnZWREYXRlUmFuZ2UpO1xuICAgICAgaWYgKGRhdGVSYW5nZS5pc1ZhbGlkKSB7XG4gICAgICAgIGRhdGVSYW5nZXNbaWRdID0gZGF0ZVJhbmdlO1xuICAgICAgICBpZiAoIW1lcmdlZERhdGVSYW5nZSkge1xuICAgICAgICAgIGRhdGVSYW5nZS50YWdPcmRlciArPSBtZXJnZUNvdW50O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXIud2FybihgSWdub3JpbmcgaW52YWxpZCBQbGF5bGlzdCBEZWx0YSBVcGRhdGUgREFURVJBTkdFIHRhZzogXCIke3N0cmluZ2lmeShkZWx0YURhdGVSYW5nZXNbaWRdLmF0dHIpfVwiYCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGRhdGVSYW5nZXM7XG59XG5mdW5jdGlvbiBtYXBQYXJ0SW50ZXJzZWN0aW9uKG9sZFBhcnRzLCBuZXdQYXJ0cywgaW50ZXJzZWN0aW9uRm4pIHtcbiAgaWYgKG9sZFBhcnRzICYmIG5ld1BhcnRzKSB7XG4gICAgbGV0IGRlbHRhID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gb2xkUGFydHMubGVuZ3RoOyBpIDw9IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBvbGRQYXJ0ID0gb2xkUGFydHNbaV07XG4gICAgICBjb25zdCBuZXdQYXJ0ID0gbmV3UGFydHNbaSArIGRlbHRhXTtcbiAgICAgIGlmIChvbGRQYXJ0ICYmIG5ld1BhcnQgJiYgb2xkUGFydC5pbmRleCA9PT0gbmV3UGFydC5pbmRleCAmJiBvbGRQYXJ0LmZyYWdtZW50LnNuID09PSBuZXdQYXJ0LmZyYWdtZW50LnNuKSB7XG4gICAgICAgIGludGVyc2VjdGlvbkZuKG9sZFBhcnQsIG5ld1BhcnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsdGEtLTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcEZyYWdtZW50SW50ZXJzZWN0aW9uKG9sZERldGFpbHMsIG5ld0RldGFpbHMsIGludGVyc2VjdGlvbkZuKSB7XG4gIGNvbnN0IHNraXBwZWRTZWdtZW50cyA9IG5ld0RldGFpbHMuc2tpcHBlZFNlZ21lbnRzO1xuICBjb25zdCBzdGFydCA9IE1hdGgubWF4KG9sZERldGFpbHMuc3RhcnRTTiwgbmV3RGV0YWlscy5zdGFydFNOKSAtIG5ld0RldGFpbHMuc3RhcnRTTjtcbiAgY29uc3QgZW5kID0gKG9sZERldGFpbHMuZnJhZ21lbnRIaW50ID8gMSA6IDApICsgKHNraXBwZWRTZWdtZW50cyA/IG5ld0RldGFpbHMuZW5kU04gOiBNYXRoLm1pbihvbGREZXRhaWxzLmVuZFNOLCBuZXdEZXRhaWxzLmVuZFNOKSkgLSBuZXdEZXRhaWxzLnN0YXJ0U047XG4gIGNvbnN0IGRlbHRhID0gbmV3RGV0YWlscy5zdGFydFNOIC0gb2xkRGV0YWlscy5zdGFydFNOO1xuICBjb25zdCBuZXdGcmFncyA9IG5ld0RldGFpbHMuZnJhZ21lbnRIaW50ID8gbmV3RGV0YWlscy5mcmFnbWVudHMuY29uY2F0KG5ld0RldGFpbHMuZnJhZ21lbnRIaW50KSA6IG5ld0RldGFpbHMuZnJhZ21lbnRzO1xuICBjb25zdCBvbGRGcmFncyA9IG9sZERldGFpbHMuZnJhZ21lbnRIaW50ID8gb2xkRGV0YWlscy5mcmFnbWVudHMuY29uY2F0KG9sZERldGFpbHMuZnJhZ21lbnRIaW50KSA6IG9sZERldGFpbHMuZnJhZ21lbnRzO1xuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICBjb25zdCBvbGRGcmFnID0gb2xkRnJhZ3NbZGVsdGEgKyBpXTtcbiAgICBsZXQgbmV3RnJhZyA9IG5ld0ZyYWdzW2ldO1xuICAgIGlmIChza2lwcGVkU2VnbWVudHMgJiYgIW5ld0ZyYWcgJiYgb2xkRnJhZykge1xuICAgICAgLy8gRmlsbCBpbiBza2lwcGVkIHNlZ21lbnRzIGluIGRlbHRhIHBsYXlsaXN0XG4gICAgICBuZXdGcmFnID0gbmV3RGV0YWlscy5mcmFnbWVudHNbaV0gPSBvbGRGcmFnO1xuICAgIH1cbiAgICBpZiAob2xkRnJhZyAmJiBuZXdGcmFnKSB7XG4gICAgICBpbnRlcnNlY3Rpb25GbihvbGRGcmFnLCBuZXdGcmFnLCBpLCBuZXdGcmFncyk7XG4gICAgICBpZiAob2xkRnJhZy51cmwgJiYgb2xkRnJhZy51cmwgIT09IG5ld0ZyYWcudXJsKSB7XG4gICAgICAgIG5ld0RldGFpbHMucGxheWxpc3RQYXJzaW5nRXJyb3IgPSBnZXRTZXF1ZW5jZUVycm9yKGBtZWRpYSBzZXF1ZW5jZSBtaXNtYXRjaCAke25ld0ZyYWcuc259OmAsIG9sZERldGFpbHMsIG5ld0RldGFpbHMsIG9sZEZyYWcsIG5ld0ZyYWcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKG9sZEZyYWcuY2MgIT09IG5ld0ZyYWcuY2MpIHtcbiAgICAgICAgbmV3RGV0YWlscy5wbGF5bGlzdFBhcnNpbmdFcnJvciA9IGdldFNlcXVlbmNlRXJyb3IoYGRpc2NvbnRpbnVpdHkgc2VxdWVuY2UgbWlzbWF0Y2ggKCR7b2xkRnJhZy5jY30hPSR7bmV3RnJhZy5jY30pYCwgb2xkRGV0YWlscywgbmV3RGV0YWlscywgb2xkRnJhZywgbmV3RnJhZyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFNlcXVlbmNlRXJyb3IobWVzc2FnZSwgb2xkRGV0YWlscywgbmV3RGV0YWlscywgb2xkRnJhZywgbmV3RnJhZykge1xuICByZXR1cm4gbmV3IEVycm9yKGAke21lc3NhZ2V9ICR7bmV3RnJhZy51cmx9XG5QbGF5bGlzdCBzdGFydGluZyBAJHtvbGREZXRhaWxzLnN0YXJ0U059XG4ke29sZERldGFpbHMubTN1OH1cblxuUGxheWxpc3Qgc3RhcnRpbmcgQCR7bmV3RGV0YWlscy5zdGFydFNOfVxuJHtuZXdEZXRhaWxzLm0zdTh9YCk7XG59XG5mdW5jdGlvbiBhZGp1c3RTbGlkaW5nKG9sZERldGFpbHMsIG5ld0RldGFpbHMsIG1hdGNoaW5nU3RhYmxlVmFyaWFudE9yUmVuZGl0aW9uID0gdHJ1ZSkge1xuICBjb25zdCBkZWx0YSA9IG5ld0RldGFpbHMuc3RhcnRTTiArIG5ld0RldGFpbHMuc2tpcHBlZFNlZ21lbnRzIC0gb2xkRGV0YWlscy5zdGFydFNOO1xuICBjb25zdCBvbGRGcmFnbWVudHMgPSBvbGREZXRhaWxzLmZyYWdtZW50cztcbiAgY29uc3QgYWR2YW5jZWRPclN0YWJsZSA9IGRlbHRhID49IDA7XG4gIGxldCBzbGlkaW5nID0gMDtcbiAgaWYgKGFkdmFuY2VkT3JTdGFibGUgJiYgZGVsdGEgPCBvbGRGcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgc2xpZGluZyA9IG9sZEZyYWdtZW50c1tkZWx0YV0uc3RhcnQ7XG4gIH0gZWxzZSBpZiAoYWR2YW5jZWRPclN0YWJsZSAmJiBuZXdEZXRhaWxzLnN0YXJ0U04gPT09IG9sZERldGFpbHMuZW5kU04gKyAxKSB7XG4gICAgc2xpZGluZyA9IG9sZERldGFpbHMuZnJhZ21lbnRFbmQ7XG4gIH0gZWxzZSBpZiAoYWR2YW5jZWRPclN0YWJsZSAmJiBtYXRjaGluZ1N0YWJsZVZhcmlhbnRPclJlbmRpdGlvbikge1xuICAgIC8vIGFsaWduIHdpdGggZXhwZWN0ZWQgcG9zaXRpb24gKHVwZGF0ZWQgcGxheWxpc3Qgc3RhcnQgc2VxdWVuY2UgaXMgcGFzdCBlbmQgc2VxdWVuY2Ugb2YgbGFzdCB1cGRhdGUpXG4gICAgc2xpZGluZyA9IG9sZERldGFpbHMuZnJhZ21lbnRTdGFydCArIGRlbHRhICogbmV3RGV0YWlscy5sZXZlbFRhcmdldER1cmF0aW9uO1xuICB9IGVsc2UgaWYgKCFuZXdEZXRhaWxzLnNraXBwZWRTZWdtZW50cyAmJiBuZXdEZXRhaWxzLmZyYWdtZW50U3RhcnQgPT09IDApIHtcbiAgICAvLyBhbGlnbiBuZXcgc3RhcnQgd2l0aCBvbGQgKHBsYXlsaXN0IHN3aXRjaCBoYXMgYSBzZXF1ZW5jZSB3aXRoIG5vIG92ZXJsYXAgYW5kIHNob3VsZCBub3QgYmUgdXNlZCBmb3IgYWxpZ25tZW50KVxuICAgIHNsaWRpbmcgPSBvbGREZXRhaWxzLmZyYWdtZW50U3RhcnQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gbmV3IGRldGFpbHMgYWxyZWFkeSBoYXMgYSBzbGlkaW5nIG9mZnNldCBvciBoYXMgc2tpcHBlZCBzZWdtZW50c1xuICAgIHJldHVybjtcbiAgfVxuICBhZGRTbGlkaW5nKG5ld0RldGFpbHMsIHNsaWRpbmcpO1xufVxuZnVuY3Rpb24gYWRkU2xpZGluZyhkZXRhaWxzLCBzbGlkaW5nKSB7XG4gIGlmIChzbGlkaW5nKSB7XG4gICAgY29uc3QgZnJhZ21lbnRzID0gZGV0YWlscy5mcmFnbWVudHM7XG4gICAgZm9yIChsZXQgaSA9IGRldGFpbHMuc2tpcHBlZFNlZ21lbnRzOyBpIDwgZnJhZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmcmFnbWVudHNbaV0uYWRkU3RhcnQoc2xpZGluZyk7XG4gICAgfVxuICAgIGlmIChkZXRhaWxzLmZyYWdtZW50SGludCkge1xuICAgICAgZGV0YWlscy5mcmFnbWVudEhpbnQuYWRkU3RhcnQoc2xpZGluZyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjb21wdXRlUmVsb2FkSW50ZXJ2YWwobmV3RGV0YWlscywgZGlzdGFuY2VUb0xpdmVFZGdlTXMgPSBJbmZpbml0eSkge1xuICBsZXQgcmVsb2FkSW50ZXJ2YWwgPSAxMDAwICogbmV3RGV0YWlscy50YXJnZXRkdXJhdGlvbjtcbiAgaWYgKG5ld0RldGFpbHMudXBkYXRlZCkge1xuICAgIC8vIFVzZSBsYXN0IHNlZ21lbnQgZHVyYXRpb24gd2hlbiBzaG9ydGVyIHRoYW4gdGFyZ2V0IGR1cmF0aW9uIGFuZCBuZWFyIGxpdmUgZWRnZVxuICAgIGNvbnN0IGZyYWdtZW50cyA9IG5ld0RldGFpbHMuZnJhZ21lbnRzO1xuICAgIGNvbnN0IGxpdmVFZGdlTWF4VGFyZ2V0RHVyYXRpb25zID0gNDtcbiAgICBpZiAoZnJhZ21lbnRzLmxlbmd0aCAmJiByZWxvYWRJbnRlcnZhbCAqIGxpdmVFZGdlTWF4VGFyZ2V0RHVyYXRpb25zID4gZGlzdGFuY2VUb0xpdmVFZGdlTXMpIHtcbiAgICAgIGNvbnN0IGxhc3RTZWdtZW50RHVyYXRpb24gPSBmcmFnbWVudHNbZnJhZ21lbnRzLmxlbmd0aCAtIDFdLmR1cmF0aW9uICogMTAwMDtcbiAgICAgIGlmIChsYXN0U2VnbWVudER1cmF0aW9uIDwgcmVsb2FkSW50ZXJ2YWwpIHtcbiAgICAgICAgcmVsb2FkSW50ZXJ2YWwgPSBsYXN0U2VnbWVudER1cmF0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBlc3RpbWF0ZSA9ICdtaXNzIGhhbGYgYXZlcmFnZSc7XG4gICAgLy8gZm9sbG93IEhMUyBTcGVjLCBJZiB0aGUgY2xpZW50IHJlbG9hZHMgYSBQbGF5bGlzdCBmaWxlIGFuZCBmaW5kcyB0aGF0IGl0IGhhcyBub3RcbiAgICAvLyBjaGFuZ2VkIHRoZW4gaXQgTVVTVCB3YWl0IGZvciBhIHBlcmlvZCBvZiBvbmUtaGFsZiB0aGUgdGFyZ2V0XG4gICAgLy8gZHVyYXRpb24gYmVmb3JlIHJldHJ5aW5nLlxuICAgIHJlbG9hZEludGVydmFsIC89IDI7XG4gIH1cbiAgcmV0dXJuIE1hdGgucm91bmQocmVsb2FkSW50ZXJ2YWwpO1xufVxuZnVuY3Rpb24gZ2V0RnJhZ21lbnRXaXRoU04oZGV0YWlscywgc24sIGZyYWdDdXJyZW50KSB7XG4gIGlmICghZGV0YWlscykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxldCBmcmFnbWVudCA9IGRldGFpbHMuZnJhZ21lbnRzW3NuIC0gZGV0YWlscy5zdGFydFNOXTtcbiAgaWYgKGZyYWdtZW50KSB7XG4gICAgcmV0dXJuIGZyYWdtZW50O1xuICB9XG4gIGZyYWdtZW50ID0gZGV0YWlscy5mcmFnbWVudEhpbnQ7XG4gIGlmIChmcmFnbWVudCAmJiBmcmFnbWVudC5zbiA9PT0gc24pIHtcbiAgICByZXR1cm4gZnJhZ21lbnQ7XG4gIH1cbiAgaWYgKHNuIDwgZGV0YWlscy5zdGFydFNOICYmIGZyYWdDdXJyZW50ICYmIGZyYWdDdXJyZW50LnNuID09PSBzbikge1xuICAgIHJldHVybiBmcmFnQ3VycmVudDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFBhcnRXaXRoKGRldGFpbHMsIHNuLCBwYXJ0SW5kZXgpIHtcbiAgaWYgKCFkZXRhaWxzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGZpbmRQYXJ0KGRldGFpbHMucGFydExpc3QsIHNuLCBwYXJ0SW5kZXgpO1xufVxuZnVuY3Rpb24gZmluZFBhcnQocGFydExpc3QsIHNuLCBwYXJ0SW5kZXgpIHtcbiAgaWYgKHBhcnRMaXN0KSB7XG4gICAgZm9yIChsZXQgaSA9IHBhcnRMaXN0Lmxlbmd0aDsgaS0tOykge1xuICAgICAgY29uc3QgcGFydCA9IHBhcnRMaXN0W2ldO1xuICAgICAgaWYgKHBhcnQuaW5kZXggPT09IHBhcnRJbmRleCAmJiBwYXJ0LmZyYWdtZW50LnNuID09PSBzbikge1xuICAgICAgICByZXR1cm4gcGFydDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiByZWFzc2lnbkZyYWdtZW50TGV2ZWxJbmRleGVzKGxldmVscykge1xuICBsZXZlbHMuZm9yRWFjaCgobGV2ZWwsIGluZGV4KSA9PiB7XG4gICAgdmFyIF9sZXZlbCRkZXRhaWxzO1xuICAgIChfbGV2ZWwkZGV0YWlscyA9IGxldmVsLmRldGFpbHMpID09IG51bGwgPyB2b2lkIDAgOiBfbGV2ZWwkZGV0YWlscy5mcmFnbWVudHMuZm9yRWFjaChmcmFnbWVudCA9PiB7XG4gICAgICBmcmFnbWVudC5sZXZlbCA9IGluZGV4O1xuICAgICAgaWYgKGZyYWdtZW50LmluaXRTZWdtZW50KSB7XG4gICAgICAgIGZyYWdtZW50LmluaXRTZWdtZW50LmxldmVsID0gaW5kZXg7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBmaW5kRmlyc3RGcmFnV2l0aENDKGZyYWdtZW50cywgY2MpIHtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGZyYWdtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBfZnJhZ21lbnRzJGk7XG4gICAgaWYgKCgoX2ZyYWdtZW50cyRpID0gZnJhZ21lbnRzW2ldKSA9PSBudWxsID8gdm9pZCAwIDogX2ZyYWdtZW50cyRpLmNjKSA9PT0gY2MpIHtcbiAgICAgIHJldHVybiBmcmFnbWVudHNbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gc2hvdWxkQWxpZ25PbkRpc2NvbnRpbnVpdGllcyhyZWZEZXRhaWxzLCBkZXRhaWxzKSB7XG4gIGlmIChyZWZEZXRhaWxzKSB7XG4gICAgaWYgKGRldGFpbHMuc3RhcnRDQyA8IHJlZkRldGFpbHMuZW5kQ0MgJiYgZGV0YWlscy5lbmRDQyA+IHJlZkRldGFpbHMuc3RhcnRDQykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGFkanVzdEZyYWdtZW50U3RhcnQoZnJhZywgc2xpZGluZykge1xuICBpZiAoZnJhZykge1xuICAgIGNvbnN0IHN0YXJ0ID0gZnJhZy5zdGFydCArIHNsaWRpbmc7XG4gICAgZnJhZy5zdGFydCA9IGZyYWcuc3RhcnRQVFMgPSBzdGFydDtcbiAgICBmcmFnLmVuZFBUUyA9IHN0YXJ0ICsgZnJhZy5kdXJhdGlvbjtcbiAgfVxufVxuZnVuY3Rpb24gYWRqdXN0U2xpZGluZ1N0YXJ0KHNsaWRpbmcsIGRldGFpbHMpIHtcbiAgLy8gVXBkYXRlIHNlZ21lbnRzXG4gIGNvbnN0IGZyYWdtZW50cyA9IGRldGFpbHMuZnJhZ21lbnRzO1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gZnJhZ21lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYWRqdXN0RnJhZ21lbnRTdGFydChmcmFnbWVudHNbaV0sIHNsaWRpbmcpO1xuICB9XG4gIC8vIFVwZGF0ZSBMTC1ITFMgcGFydHMgYXQgdGhlIGVuZCBvZiB0aGUgcGxheWxpc3RcbiAgaWYgKGRldGFpbHMuZnJhZ21lbnRIaW50KSB7XG4gICAgYWRqdXN0RnJhZ21lbnRTdGFydChkZXRhaWxzLmZyYWdtZW50SGludCwgc2xpZGluZyk7XG4gIH1cbiAgZGV0YWlscy5hbGlnbmVkU2xpZGluZyA9IHRydWU7XG59XG5cbi8qKlxuICogVXNpbmcgdGhlIHBhcmFtZXRlcnMgb2YgdGhlIGxhc3QgbGV2ZWwsIHRoaXMgZnVuY3Rpb24gY29tcHV0ZXMgUFRTJyBvZiB0aGUgbmV3IGZyYWdtZW50cyBzbyB0aGF0IHRoZXkgZm9ybSBhXG4gKiBjb250aWd1b3VzIHN0cmVhbSB3aXRoIHRoZSBsYXN0IGZyYWdtZW50cy5cbiAqIFRoZSBQVFMgb2YgYSBmcmFnbWVudCBsZXRzIEhscy5qcyBrbm93IHdoZXJlIGl0IGZpdHMgaW50byBhIHN0cmVhbSAtIGJ5IGtub3dpbmcgZXZlcnkgUFRTLCB3ZSBrbm93IHdoaWNoIGZyYWdtZW50IHRvXG4gKiBkb3dubG9hZCBhdCBhbnkgZ2l2ZW4gdGltZS4gUFRTIGlzIG5vcm1hbGx5IGNvbXB1dGVkIHdoZW4gdGhlIGZyYWdtZW50IGlzIGRlbXV4ZWQsIHNvIHRha2luZyB0aGlzIHN0ZXAgc2F2ZXMgdXMgdGltZVxuICogYW5kIGFuIGV4dHJhIGRvd25sb2FkLlxuICogQHBhcmFtIGxhc3RMZXZlbFxuICogQHBhcmFtIGRldGFpbHNcbiAqL1xuZnVuY3Rpb24gYWxpZ25TdHJlYW0oc3dpdGNoRGV0YWlscywgZGV0YWlscykge1xuICBpZiAoIXN3aXRjaERldGFpbHMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYWxpZ25EaXNjb250aW51aXRpZXMoZGV0YWlscywgc3dpdGNoRGV0YWlscyk7XG4gIGlmICghZGV0YWlscy5hbGlnbmVkU2xpZGluZyAmJiBzd2l0Y2hEZXRhaWxzKSB7XG4gICAgLy8gSWYgdGhlIFBUUyB3YXNuJ3QgZmlndXJlZCBvdXQgdmlhIGRpc2NvbnRpbnVpdHkgc2VxdWVuY2UgdGhhdCBtZWFucyB0aGVyZSB3YXMgbm8gQ0MgaW5jcmVhc2Ugd2l0aGluIHRoZSBsZXZlbC5cbiAgICAvLyBBbGlnbmluZyB2aWEgUHJvZ3JhbSBEYXRlIFRpbWUgc2hvdWxkIHRoZXJlZm9yZSBiZSByZWxpYWJsZSwgc2luY2UgUERUIHNob3VsZCBiZSB0aGUgc2FtZSB3aXRoaW4gdGhlIHNhbWVcbiAgICAvLyBkaXNjb250aW51aXR5IHNlcXVlbmNlLlxuICAgIGFsaWduTWVkaWFQbGF5bGlzdEJ5UERUKGRldGFpbHMsIHN3aXRjaERldGFpbHMpO1xuICB9XG4gIGlmICghZGV0YWlscy5hbGlnbmVkU2xpZGluZyAmJiBzd2l0Y2hEZXRhaWxzICYmICFkZXRhaWxzLnNraXBwZWRTZWdtZW50cykge1xuICAgIC8vIFRyeSB0byBhbGlnbiBvbiBzbiBzbyB0aGF0IHdlIHBpY2sgYSBiZXR0ZXIgc3RhcnQgZnJhZ21lbnQuXG4gICAgLy8gRG8gbm90IHBlcmZvcm0gdGhpcyBvbiBwbGF5bGlzdHMgd2l0aCBkZWx0YSB1cGRhdGVzIGFzIHRoaXMgaXMgb25seSB0byBhbGlnbiBsZXZlbHMgb24gc3dpdGNoXG4gICAgLy8gYW5kIGFkanVzdFNsaWRpbmcgb25seSBhZGp1c3RzIGZyYWdtZW50cyBhZnRlciBza2lwcGVkU2VnbWVudHMuXG4gICAgYWRqdXN0U2xpZGluZyhzd2l0Y2hEZXRhaWxzLCBkZXRhaWxzLCBmYWxzZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBanVzdCB0aGUgc3RhcnQgb2YgZnJhZ21lbnRzIGluIGBkZXRhaWxzYCBieSB0aGUgZGlmZmVyZW5jZSBpbiB0aW1lIGJldHdlZW4gZnJhZ21lbnRzIG9mIHRoZSBsYXRlc3RcbiAqIHNoYXJlZCBkaXNjb250aW51aXR5IHNlcXVlbmNlIGNoYW5nZS5cbiAqIEBwYXJhbSBsYXN0TGV2ZWwgLSBUaGUgZGV0YWlscyBvZiB0aGUgbGFzdCBsb2FkZWQgbGV2ZWxcbiAqIEBwYXJhbSBkZXRhaWxzIC0gVGhlIGRldGFpbHMgb2YgdGhlIG5ldyBsZXZlbFxuICovXG5mdW5jdGlvbiBhbGlnbkRpc2NvbnRpbnVpdGllcyhkZXRhaWxzLCByZWZEZXRhaWxzKSB7XG4gIGlmICghc2hvdWxkQWxpZ25PbkRpc2NvbnRpbnVpdGllcyhyZWZEZXRhaWxzLCBkZXRhaWxzKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0YXJnZXRDQyA9IE1hdGgubWluKHJlZkRldGFpbHMuZW5kQ0MsIGRldGFpbHMuZW5kQ0MpO1xuICBjb25zdCByZWZGcmFnID0gZmluZEZpcnN0RnJhZ1dpdGhDQyhyZWZEZXRhaWxzLmZyYWdtZW50cywgdGFyZ2V0Q0MpO1xuICBjb25zdCBmcmFnID0gZmluZEZpcnN0RnJhZ1dpdGhDQyhkZXRhaWxzLmZyYWdtZW50cywgdGFyZ2V0Q0MpO1xuICBpZiAoIXJlZkZyYWcgfHwgIWZyYWcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbG9nZ2VyLmxvZyhgQWxpZ25pbmcgcGxheWxpc3QgYXQgc3RhcnQgb2YgZGljb250aW51aXR5IHNlcXVlbmNlICR7dGFyZ2V0Q0N9YCk7XG4gIGNvbnN0IGRlbHRhID0gcmVmRnJhZy5zdGFydCAtIGZyYWcuc3RhcnQ7XG4gIGFkanVzdFNsaWRpbmdTdGFydChkZWx0YSwgZGV0YWlscyk7XG59XG5cbi8qKlxuICogRW5zdXJlcyBhcHByb3ByaWF0ZSB0aW1lLWFsaWdubWVudCBiZXR3ZWVuIHJlbmRpdGlvbnMgYmFzZWQgb24gUERULlxuICogVGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoZSB0aW1lbGluZXMgcmVwcmVzZW50ZWQgaW4gYHJlZkRldGFpbHNgIGFyZSBhY2N1cmF0ZSwgaW5jbHVkaW5nIHRoZSBQRFRzXG4gKiBmb3IgdGhlIGxhc3QgZGlzY29udGludWl0eSBzZXF1ZW5jZSBudW1iZXIgc2hhcmVkIGJ5IGJvdGggcGxheWxpc3RzIHdoZW4gcHJlc2VudCxcbiAqIGFuZCB1c2VzIHRoZSBcIndhbGxjbG9ja1wiL1BEVCB0aW1lbGluZSBhcyBhIGNyb3NzLXJlZmVyZW5jZSB0byBgZGV0YWlsc2AsIGFkanVzdGluZyB0aGUgcHJlc2VudGF0aW9uXG4gKiB0aW1lcy90aW1lbGluZXMgb2YgYGRldGFpbHNgIGFjY29yZGluZ2x5LlxuICogR2l2ZW4gdGhlIGFzeW5jaHJvbm91cyBuYXR1cmUgb2YgZmV0Y2hlcyBhbmQgaW5pdGlhbCBsb2FkcyBvZiBsaXZlIGBtYWluYCBhbmQgYXVkaW8vc3VidGl0bGUgdHJhY2tzLFxuICogdGhlIHByaW1hcnkgcHVycG9zZSBvZiB0aGlzIGZ1bmN0aW9uIGlzIHRvIGVuc3VyZSB0aGUgXCJsb2NhbCB0aW1lbGluZXNcIiBvZiBhdWRpby9zdWJ0aXRsZSB0cmFja3NcbiAqIGFyZSBhbGlnbmVkIHRvIHRoZSBtYWluL3ZpZGVvIHRpbWVsaW5lLCB1c2luZyBQRFQgYXMgdGhlIGNyb3NzLXJlZmVyZW5jZS9cImFuY2hvclwiIHRoYXQgc2hvdWxkXG4gKiBiZSBjb25zaXN0ZW50IGFjcm9zcyBwbGF5bGlzdHMsIHBlciB0aGUgSExTIHNwZWMuXG4gKiBAcGFyYW0gZGV0YWlscyAtIFRoZSBkZXRhaWxzIG9mIHRoZSByZW5kaXRpb24geW91J2QgbGlrZSB0byB0aW1lLWFsaWduIChlLmcuIGFuIGF1ZGlvIHJlbmRpdGlvbikuXG4gKiBAcGFyYW0gcmVmRGV0YWlscyAtIFRoZSBkZXRhaWxzIG9mIHRoZSByZWZlcmVuY2UgcmVuZGl0aW9uIHdpdGggc3RhcnQgYW5kIFBEVCB0aW1lcyBmb3IgYWxpZ25tZW50LlxuICovXG5mdW5jdGlvbiBhbGlnbk1lZGlhUGxheWxpc3RCeVBEVChkZXRhaWxzLCByZWZEZXRhaWxzKSB7XG4gIGlmICghZGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUgfHwgIXJlZkRldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGZyYWdtZW50cyA9IGRldGFpbHMuZnJhZ21lbnRzO1xuICBjb25zdCByZWZGcmFnbWVudHMgPSByZWZEZXRhaWxzLmZyYWdtZW50cztcbiAgaWYgKCFmcmFnbWVudHMubGVuZ3RoIHx8ICFyZWZGcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIGEgZGVsdGEgdG8gYXBwbHkgdG8gYWxsIGZyYWdtZW50cyBhY2NvcmRpbmcgdG8gdGhlIGRlbHRhIGluIFBEVCB0aW1lcyBhbmQgc3RhcnQgdGltZXNcbiAgLy8gb2YgYSBmcmFnbWVudCBpbiB0aGUgcmVmZXJlbmNlIGRldGFpbHMsIGFuZCBhIGZyYWdtZW50IGluIHRoZSB0YXJnZXQgZGV0YWlscyBvZiB0aGUgc2FtZSBkaXNjb250aW51aXR5LlxuICAvLyBJZiBhIGZyYWdtZW50IG9mIHRoZSBzYW1lIGRpc2NvbnRpbnVpdHkgd2FzIG5vdCBmb3VuZCB1c2UgdGhlIG1pZGRsZSBmcmFnbWVudCBvZiBib3RoLlxuICBsZXQgcmVmRnJhZztcbiAgbGV0IGZyYWc7XG4gIGNvbnN0IHRhcmdldENDID0gTWF0aC5taW4ocmVmRGV0YWlscy5lbmRDQywgZGV0YWlscy5lbmRDQyk7XG4gIGlmIChyZWZEZXRhaWxzLnN0YXJ0Q0MgPCB0YXJnZXRDQyAmJiBkZXRhaWxzLnN0YXJ0Q0MgPCB0YXJnZXRDQykge1xuICAgIHJlZkZyYWcgPSBmaW5kRmlyc3RGcmFnV2l0aENDKHJlZkZyYWdtZW50cywgdGFyZ2V0Q0MpO1xuICAgIGZyYWcgPSBmaW5kRmlyc3RGcmFnV2l0aENDKGZyYWdtZW50cywgdGFyZ2V0Q0MpO1xuICB9XG4gIGlmICghcmVmRnJhZyB8fCAhZnJhZykge1xuICAgIHJlZkZyYWcgPSByZWZGcmFnbWVudHNbTWF0aC5mbG9vcihyZWZGcmFnbWVudHMubGVuZ3RoIC8gMildO1xuICAgIGZyYWcgPSBmaW5kRmlyc3RGcmFnV2l0aENDKGZyYWdtZW50cywgcmVmRnJhZy5jYykgfHwgZnJhZ21lbnRzW01hdGguZmxvb3IoZnJhZ21lbnRzLmxlbmd0aCAvIDIpXTtcbiAgfVxuICBjb25zdCByZWZQRFQgPSByZWZGcmFnLnByb2dyYW1EYXRlVGltZTtcbiAgY29uc3QgdGFyZ2V0UERUID0gZnJhZy5wcm9ncmFtRGF0ZVRpbWU7XG4gIGlmICghcmVmUERUIHx8ICF0YXJnZXRQRFQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZGVsdGEgPSAodGFyZ2V0UERUIC0gcmVmUERUKSAvIDEwMDAgLSAoZnJhZy5zdGFydCAtIHJlZkZyYWcuc3RhcnQpO1xuICBhZGp1c3RTbGlkaW5nU3RhcnQoZGVsdGEsIGRldGFpbHMpO1xufVxuXG4vKipcbiAqICBUaW1lUmFuZ2VzIHRvIHN0cmluZyBoZWxwZXJcbiAqL1xuXG5jb25zdCBUaW1lUmFuZ2VzID0ge1xuICB0b1N0cmluZzogZnVuY3Rpb24gKHIpIHtcbiAgICBsZXQgbG9nID0gJyc7XG4gICAgY29uc3QgbGVuID0gci5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgbG9nICs9IGBbJHtyLnN0YXJ0KGkpLnRvRml4ZWQoMyl9LSR7ci5lbmQoaSkudG9GaXhlZCgzKX1dYDtcbiAgICB9XG4gICAgcmV0dXJuIGxvZztcbiAgfVxufTtcblxuY29uc3QgU3RhdGUgPSB7XG4gIFNUT1BQRUQ6ICdTVE9QUEVEJyxcbiAgSURMRTogJ0lETEUnLFxuICBLRVlfTE9BRElORzogJ0tFWV9MT0FESU5HJyxcbiAgRlJBR19MT0FESU5HOiAnRlJBR19MT0FESU5HJyxcbiAgRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk6ICdGUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWScsXG4gIFdBSVRJTkdfVFJBQ0s6ICdXQUlUSU5HX1RSQUNLJyxcbiAgUEFSU0lORzogJ1BBUlNJTkcnLFxuICBQQVJTRUQ6ICdQQVJTRUQnLFxuICBFTkRFRDogJ0VOREVEJyxcbiAgRVJST1I6ICdFUlJPUicsXG4gIFdBSVRJTkdfSU5JVF9QVFM6ICdXQUlUSU5HX0lOSVRfUFRTJyxcbiAgV0FJVElOR19MRVZFTDogJ1dBSVRJTkdfTEVWRUwnXG59O1xuY2xhc3MgQmFzZVN0cmVhbUNvbnRyb2xsZXIgZXh0ZW5kcyBUYXNrTG9vcCB7XG4gIGNvbnN0cnVjdG9yKGhscywgZnJhZ21lbnRUcmFja2VyLCBrZXlMb2FkZXIsIGxvZ1ByZWZpeCwgcGxheWxpc3RUeXBlKSB7XG4gICAgc3VwZXIobG9nUHJlZml4LCBobHMubG9nZ2VyKTtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIgPSB2b2lkIDA7XG4gICAgdGhpcy50cmFuc211eGVyID0gbnVsbDtcbiAgICB0aGlzLl9zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gICAgdGhpcy5wbGF5bGlzdFR5cGUgPSB2b2lkIDA7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5tZWRpYUJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy5iaXRyYXRlVGVzdCA9IGZhbHNlO1xuICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSAwO1xuICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IDA7XG4gICAgdGhpcy5zdGFydFRpbWVPZmZzZXQgPSBudWxsO1xuICAgIHRoaXMucmV0cnlEYXRlID0gMDtcbiAgICB0aGlzLmxldmVscyA9IG51bGw7XG4gICAgdGhpcy5mcmFnbWVudExvYWRlciA9IHZvaWQgMDtcbiAgICB0aGlzLmtleUxvYWRlciA9IHZvaWQgMDtcbiAgICB0aGlzLmxldmVsTGFzdExvYWRlZCA9IG51bGw7XG4gICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRlY3J5cHRlciA9IHZvaWQgMDtcbiAgICB0aGlzLmluaXRQVFMgPSBbXTtcbiAgICB0aGlzLmJ1ZmZlcmluZyA9IHRydWU7XG4gICAgdGhpcy5sb2FkaW5nUGFydHMgPSBmYWxzZTtcbiAgICB0aGlzLmxvb3BTbiA9IHZvaWQgMDtcbiAgICB0aGlzLm9uTWVkaWFTZWVraW5nID0gKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb25maWcsXG4gICAgICAgIGZyYWdDdXJyZW50LFxuICAgICAgICBtZWRpYSxcbiAgICAgICAgbWVkaWFCdWZmZXIsXG4gICAgICAgIHN0YXRlXG4gICAgICB9ID0gdGhpcztcbiAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbWVkaWEgPyBtZWRpYS5jdXJyZW50VGltZSA6IDA7XG4gICAgICBjb25zdCBidWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8obWVkaWFCdWZmZXIgPyBtZWRpYUJ1ZmZlciA6IG1lZGlhLCBjdXJyZW50VGltZSwgY29uZmlnLm1heEJ1ZmZlckhvbGUpO1xuICAgICAgY29uc3Qgbm9Gb3dhcmRCdWZmZXIgPSAhYnVmZmVySW5mby5sZW47XG4gICAgICB0aGlzLmxvZyhgTWVkaWEgc2Vla2luZyB0byAke2lzRmluaXRlTnVtYmVyKGN1cnJlbnRUaW1lKSA/IGN1cnJlbnRUaW1lLnRvRml4ZWQoMykgOiBjdXJyZW50VGltZX0sIHN0YXRlOiAke3N0YXRlfSwgJHtub0Zvd2FyZEJ1ZmZlciA/ICdvdXQgb2YnIDogJ2luJ30gYnVmZmVyYCk7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuRU5ERUQpIHtcbiAgICAgICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICAgICAgfSBlbHNlIGlmIChmcmFnQ3VycmVudCkge1xuICAgICAgICAvLyBTZWVraW5nIHdoaWxlIGZyYWcgbG9hZCBpcyBpbiBwcm9ncmVzc1xuICAgICAgICBjb25zdCB0b2xlcmFuY2UgPSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTtcbiAgICAgICAgY29uc3QgZnJhZ1N0YXJ0T2Zmc2V0ID0gZnJhZ0N1cnJlbnQuc3RhcnQgLSB0b2xlcmFuY2U7XG4gICAgICAgIGNvbnN0IGZyYWdFbmRPZmZzZXQgPSBmcmFnQ3VycmVudC5zdGFydCArIGZyYWdDdXJyZW50LmR1cmF0aW9uICsgdG9sZXJhbmNlO1xuICAgICAgICAvLyBpZiBzZWVraW5nIG91dCBvZiBidWZmZXJlZCByYW5nZSBvciBpbnRvIG5ldyBvbmVcbiAgICAgICAgaWYgKG5vRm93YXJkQnVmZmVyIHx8IGZyYWdFbmRPZmZzZXQgPCBidWZmZXJJbmZvLnN0YXJ0IHx8IGZyYWdTdGFydE9mZnNldCA+IGJ1ZmZlckluZm8uZW5kKSB7XG4gICAgICAgICAgY29uc3QgcGFzdEZyYWdtZW50ID0gY3VycmVudFRpbWUgPiBmcmFnRW5kT2Zmc2V0O1xuICAgICAgICAgIC8vIGlmIHRoZSBzZWVrIHBvc2l0aW9uIGlzIG91dHNpZGUgdGhlIGN1cnJlbnQgZnJhZ21lbnQgcmFuZ2VcbiAgICAgICAgICBpZiAoY3VycmVudFRpbWUgPCBmcmFnU3RhcnRPZmZzZXQgfHwgcGFzdEZyYWdtZW50KSB7XG4gICAgICAgICAgICBpZiAocGFzdEZyYWdtZW50ICYmIGZyYWdDdXJyZW50LmxvYWRlcikge1xuICAgICAgICAgICAgICB0aGlzLmxvZyhgQ2FuY2VsbGluZyBmcmFnbWVudCBsb2FkIGZvciBzZWVrIChzbjogJHtmcmFnQ3VycmVudC5zbn0pYCk7XG4gICAgICAgICAgICAgIGZyYWdDdXJyZW50LmFib3J0UmVxdWVzdHMoKTtcbiAgICAgICAgICAgICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIC8vIFJlbW92ZSBnYXAgZnJhZ21lbnRzXG4gICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50c0luUmFuZ2UoY3VycmVudFRpbWUsIEluZmluaXR5LCB0aGlzLnBsYXlsaXN0VHlwZSwgdHJ1ZSk7XG5cbiAgICAgICAgLy8gRG9uJ3Qgc2V0IGxhc3RDdXJyZW50VGltZSB3aXRoIGJhY2t3YXJkIHNlZWtzIChhbGxvd3MgZm9yIGZyYWcgc2VsZWN0aW9uIHdpdGggc3RyaWN0IHRvbGVyYW5jZXMpXG4gICAgICAgIGNvbnN0IGxhc3RDdXJyZW50VGltZSA9IHRoaXMubGFzdEN1cnJlbnRUaW1lO1xuICAgICAgICBpZiAoY3VycmVudFRpbWUgPiBsYXN0Q3VycmVudFRpbWUpIHtcbiAgICAgICAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5sb2FkaW5nUGFydHMpIHtcbiAgICAgICAgICBjb25zdCBidWZmZXJFbmQgPSBNYXRoLm1heChidWZmZXJJbmZvLmVuZCwgY3VycmVudFRpbWUpO1xuICAgICAgICAgIGNvbnN0IHNob3VsZExvYWRQYXJ0cyA9IHRoaXMuc2hvdWxkTG9hZFBhcnRzKHRoaXMuZ2V0TGV2ZWxEZXRhaWxzKCksIGJ1ZmZlckVuZCk7XG4gICAgICAgICAgaWYgKHNob3VsZExvYWRQYXJ0cykge1xuICAgICAgICAgICAgdGhpcy5sb2coYExMLVBhcnQgbG9hZGluZyBPTiBhZnRlciBzZWVraW5nIHRvICR7Y3VycmVudFRpbWUudG9GaXhlZCgyKX0gd2l0aCBidWZmZXIgQCR7YnVmZmVyRW5kLnRvRml4ZWQoMil9YCk7XG4gICAgICAgICAgICB0aGlzLmxvYWRpbmdQYXJ0cyA9IHNob3VsZExvYWRQYXJ0cztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gaW4gY2FzZSBzZWVraW5nIG9jY3VycyBhbHRob3VnaCBubyBtZWRpYSBidWZmZXJlZCwgYWRqdXN0IHN0YXJ0UG9zaXRpb24gYW5kIG5leHRMb2FkUG9zaXRpb24gdG8gc2VlayB0YXJnZXRcbiAgICAgIGlmICghdGhpcy5obHMuaGFzRW5vdWdoVG9TdGFydCkge1xuICAgICAgICB0aGlzLmxvZyhgU2V0dGluZyAke25vRm93YXJkQnVmZmVyID8gJ3N0YXJ0UG9zaXRpb24nIDogJ25leHRMb2FkUG9zaXRpb24nfSB0byAke2N1cnJlbnRUaW1lfSBmb3Igc2VlayB3aXRob3V0IGVub3VnaCB0byBzdGFydGApO1xuICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBjdXJyZW50VGltZTtcbiAgICAgICAgaWYgKG5vRm93YXJkQnVmZmVyKSB7XG4gICAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gY3VycmVudFRpbWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQXN5bmMgdGljayB0byBzcGVlZCB1cCBwcm9jZXNzaW5nXG4gICAgICB0aGlzLnRpY2tJbW1lZGlhdGUoKTtcbiAgICB9O1xuICAgIHRoaXMub25NZWRpYUVuZGVkID0gKCkgPT4ge1xuICAgICAgLy8gcmVzZXQgc3RhcnRQb3NpdGlvbiBhbmQgbGFzdEN1cnJlbnRUaW1lIHRvIHJlc3RhcnQgcGxheWJhY2sgQCBzdHJlYW0gYmVnaW5uaW5nXG4gICAgICB0aGlzLmxvZyhgc2V0dGluZyBzdGFydFBvc2l0aW9uIHRvIDAgYmVjYXVzZSBtZWRpYSBlbmRlZGApO1xuICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICAgIH07XG4gICAgdGhpcy5wbGF5bGlzdFR5cGUgPSBwbGF5bGlzdFR5cGU7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5mcmFnbWVudExvYWRlciA9IG5ldyBGcmFnbWVudExvYWRlcihobHMuY29uZmlnKTtcbiAgICB0aGlzLmtleUxvYWRlciA9IGtleUxvYWRlcjtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlciA9IGZyYWdtZW50VHJhY2tlcjtcbiAgICB0aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgdGhpcy5kZWNyeXB0ZXIgPSBuZXcgRGVjcnlwdGVyKGhscy5jb25maWcpO1xuICB9XG4gIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH1cbiAgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FERUQsIHRoaXMub25NYW5pZmVzdExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH1cbiAgZG9UaWNrKCkge1xuICAgIHRoaXMub25UaWNrRW5kKCk7XG4gIH1cbiAgb25UaWNrRW5kKCkge31cbiAgc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24pIHt9XG4gIHN0b3BMb2FkKCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5TVE9QUEVEKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZnJhZ21lbnRMb2FkZXIuYWJvcnQoKTtcbiAgICB0aGlzLmtleUxvYWRlci5hYm9ydCh0aGlzLnBsYXlsaXN0VHlwZSk7XG4gICAgY29uc3QgZnJhZyA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgaWYgKGZyYWcgIT0gbnVsbCAmJiBmcmFnLmxvYWRlcikge1xuICAgICAgZnJhZy5hYm9ydFJlcXVlc3RzKCk7XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICB9XG4gICAgdGhpcy5yZXNldFRyYW5zbXV4ZXIoKTtcbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgdGhpcy5jbGVhckludGVydmFsKCk7XG4gICAgdGhpcy5jbGVhck5leHRUaWNrKCk7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gIH1cbiAgZ2V0IHN0YXJ0UG9zaXRpb25WYWx1ZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBuZXh0TG9hZFBvc2l0aW9uLFxuICAgICAgc3RhcnRQb3NpdGlvblxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChzdGFydFBvc2l0aW9uID09PSAtMSAmJiBuZXh0TG9hZFBvc2l0aW9uKSB7XG4gICAgICByZXR1cm4gbmV4dExvYWRQb3NpdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXJ0UG9zaXRpb247XG4gIH1cbiAgZ2V0IGJ1ZmZlcmluZ0VuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyaW5nO1xuICB9XG4gIHBhdXNlQnVmZmVyaW5nKCkge1xuICAgIHRoaXMuYnVmZmVyaW5nID0gZmFsc2U7XG4gIH1cbiAgcmVzdW1lQnVmZmVyaW5nKCkge1xuICAgIHRoaXMuYnVmZmVyaW5nID0gdHJ1ZTtcbiAgfVxuICBnZXQgaW5GbGlnaHRGcmFnKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmcmFnOiB0aGlzLmZyYWdDdXJyZW50LFxuICAgICAgc3RhdGU6IHRoaXMuc3RhdGVcbiAgICB9O1xuICB9XG4gIF9zdHJlYW1FbmRlZChidWZmZXJJbmZvLCBsZXZlbERldGFpbHMpIHtcbiAgICAvLyBTdHJlYW0gaXMgbmV2ZXIgXCJlbmRlZFwiIHdoZW4gcGxheWxpc3QgaXMgbGl2ZSBvciBtZWRpYSBpcyBkZXRhY2hlZFxuICAgIGlmIChsZXZlbERldGFpbHMubGl2ZSB8fCAhdGhpcy5tZWRpYSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBTdHJlYW0gaXMgbm90IFwiZW5kZWRcIiB3aGVuIG5vdGhpbmcgaXMgYnVmZmVyZWQgcGFzdCB0aGUgc3RhcnRcbiAgICBjb25zdCBidWZmZXJFbmQgPSBidWZmZXJJbmZvLmVuZCB8fCAwO1xuICAgIGNvbnN0IHRpbWVsaW5lU3RhcnQgPSB0aGlzLmNvbmZpZy50aW1lbGluZU9mZnNldCB8fCAwO1xuICAgIGlmIChidWZmZXJFbmQgPD0gdGltZWxpbmVTdGFydCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBTdHJlYW0gaXMgbm90IFwiZW5kZWRcIiB3aGVuIHRoZXJlIGlzIGEgc2Vjb25kIGJ1ZmZlcmVkIHJhbmdlIHN0YXJ0aW5nIGJlZm9yZSB0aGUgZW5kIG9mIHRoZSBwbGF5bGlzdFxuICAgIGNvbnN0IGJ1ZmZlcmVkUmFuZ2VzID0gYnVmZmVySW5mby5idWZmZXJlZDtcbiAgICBpZiAodGhpcy5jb25maWcubWF4QnVmZmVySG9sZSAmJiBidWZmZXJlZFJhbmdlcyAmJiBidWZmZXJlZFJhbmdlcy5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgYnVmZmVySW5mbyBhY2NvdW50cyBmb3IgYW55IGdhcHNcbiAgICAgIGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVyZWRJbmZvKGJ1ZmZlcmVkUmFuZ2VzLCBidWZmZXJJbmZvLnN0YXJ0LCAwKTtcbiAgICB9XG4gICAgY29uc3QgbmV4dFN0YXJ0ID0gYnVmZmVySW5mby5uZXh0U3RhcnQ7XG4gICAgY29uc3QgaGFzU2Vjb25kQnVmZmVyZWRSYW5nZSA9IG5leHRTdGFydCAmJiBuZXh0U3RhcnQgPiB0aW1lbGluZVN0YXJ0ICYmIG5leHRTdGFydCA8IGxldmVsRGV0YWlscy5lZGdlO1xuICAgIGlmIChoYXNTZWNvbmRCdWZmZXJlZFJhbmdlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIFBsYXloZWFkIGlzIGluIHVuYnVmZmVyZWQgcmVnaW9uLiBNYXJraW5nIEVvUyBub3cgY291bGQgcmVzdWx0IGluIFNhZmFyaSBmYWlsaW5nIHRvIGRpc3BhdGNoIFwiZW5kZWRcIiBldmVudCBmb2xsb3dpbmcgc2VlayBvbiBzdGFydC5cbiAgICBpZiAodGhpcy5tZWRpYS5jdXJyZW50VGltZSA8IGJ1ZmZlckluZm8uc3RhcnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcGFydExpc3QgPSBsZXZlbERldGFpbHMucGFydExpc3Q7XG4gICAgLy8gU2luY2UgdGhlIGxhc3QgcGFydCBpc24ndCBndWFyYW50ZWVkIHRvIGNvcnJlc3BvbmQgdG8gdGhlIGxhc3QgcGxheWxpc3Qgc2VnbWVudCBmb3IgTG93LUxhdGVuY3kgSExTLFxuICAgIC8vIGNoZWNrIGluc3RlYWQgaWYgdGhlIGxhc3QgcGFydCBpcyBidWZmZXJlZC5cbiAgICBpZiAocGFydExpc3QgIT0gbnVsbCAmJiBwYXJ0TGlzdC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGxhc3RQYXJ0ID0gcGFydExpc3RbcGFydExpc3QubGVuZ3RoIC0gMV07XG5cbiAgICAgIC8vIENoZWNraW5nIHRoZSBtaWRwb2ludCBvZiB0aGUgcGFydCBmb3IgcG90ZW50aWFsIG1hcmdpbiBvZiBlcnJvciBhbmQgcmVsYXRlZCBpc3N1ZXMuXG4gICAgICAvLyBOT1RFOiBUZWNobmljYWxseSBJIGJlbGlldmUgcGFydHMgY291bGQgeWllbGQgY29udGVudCB0aGF0IGlzIDwgdGhlIGNvbXB1dGVkIGR1cmF0aW9uIChpbmNsdWRpbmcgcG90ZW50aWFsIGEgZHVyYXRpb24gb2YgMClcbiAgICAgIC8vIGFuZCBzdGlsbCBiZSBzcGVjLWNvbXBsaWFudCwgc28gdGhlcmUgbWF5IHN0aWxsIGJlIGVkZ2UgY2FzZXMgaGVyZS4gTGlrZXdpc2UsIHRoZXJlIGNvdWxkIGJlIGlzc3VlcyBpbiBlbmQgb2Ygc3RyZWFtXG4gICAgICAvLyBwYXJ0IG1pc21hdGNoZXMgZm9yIGluZGVwZW5kZW50IGF1ZGlvIGFuZCB2aWRlbyBwbGF5bGlzdHMvc2VnbWVudHMuXG4gICAgICBjb25zdCBsYXN0UGFydEJ1ZmZlcmVkID0gQnVmZmVySGVscGVyLmlzQnVmZmVyZWQodGhpcy5tZWRpYSwgbGFzdFBhcnQuc3RhcnQgKyBsYXN0UGFydC5kdXJhdGlvbiAvIDIpO1xuICAgICAgcmV0dXJuIGxhc3RQYXJ0QnVmZmVyZWQ7XG4gICAgfVxuICAgIGNvbnN0IHBsYXlsaXN0VHlwZSA9IGxldmVsRGV0YWlscy5mcmFnbWVudHNbbGV2ZWxEZXRhaWxzLmZyYWdtZW50cy5sZW5ndGggLSAxXS50eXBlO1xuICAgIHJldHVybiB0aGlzLmZyYWdtZW50VHJhY2tlci5pc0VuZExpc3RBcHBlbmRlZChwbGF5bGlzdFR5cGUpO1xuICB9XG4gIGdldExldmVsRGV0YWlscygpIHtcbiAgICBpZiAodGhpcy5sZXZlbHMgJiYgdGhpcy5sZXZlbExhc3RMb2FkZWQgIT09IG51bGwpIHtcbiAgICAgIHZhciBfdGhpcyRsZXZlbExhc3RMb2FkZWQ7XG4gICAgICByZXR1cm4gKF90aGlzJGxldmVsTGFzdExvYWRlZCA9IHRoaXMubGV2ZWxMYXN0TG9hZGVkKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbGV2ZWxMYXN0TG9hZGVkLmRldGFpbHM7XG4gICAgfVxuICB9XG4gIGdldCB0aW1lbGluZU9mZnNldCgpIHtcbiAgICBjb25zdCBjb25maWd1cmVkVGltZWxpbmVPZmZzZXQgPSB0aGlzLmNvbmZpZy50aW1lbGluZU9mZnNldDtcbiAgICBpZiAoY29uZmlndXJlZFRpbWVsaW5lT2Zmc2V0KSB7XG4gICAgICB2YXIgX3RoaXMkZ2V0TGV2ZWxEZXRhaWxzO1xuICAgICAgcmV0dXJuICgoX3RoaXMkZ2V0TGV2ZWxEZXRhaWxzID0gdGhpcy5nZXRMZXZlbERldGFpbHMoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGdldExldmVsRGV0YWlscy5hcHBsaWVkVGltZWxpbmVPZmZzZXQpIHx8IGNvbmZpZ3VyZWRUaW1lbGluZU9mZnNldDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgb25NZWRpYUF0dGFjaGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA9IGRhdGEubWVkaWE7XG4gICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vla2luZycsIHRoaXMub25NZWRpYVNlZWtpbmcpO1xuICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5vbk1lZGlhRW5kZWQpO1xuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3NlZWtpbmcnLCB0aGlzLm9uTWVkaWFTZWVraW5nKTtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMub25NZWRpYUVuZGVkKTtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBpZiAodGhpcy5sZXZlbHMgJiYgY29uZmlnLmF1dG9TdGFydExvYWQgJiYgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuU1RPUFBFRCkge1xuICAgICAgdGhpcy5zdGFydExvYWQoY29uZmlnLnN0YXJ0UG9zaXRpb24pO1xuICAgIH1cbiAgfVxuICBvbk1lZGlhRGV0YWNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3QgdHJhbnNmZXJyaW5nTWVkaWEgPSAhIWRhdGEudHJhbnNmZXJNZWRpYTtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgaWYgKG1lZGlhID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChtZWRpYS5lbmRlZCkge1xuICAgICAgdGhpcy5sb2coJ01TRSBkZXRhY2hpbmcgYW5kIHZpZGVvIGVuZGVkLCByZXNldCBzdGFydFBvc2l0aW9uJyk7XG4gICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIHZpZGVvIGxpc3RlbmVyc1xuICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlZWtpbmcnLCB0aGlzLm9uTWVkaWFTZWVraW5nKTtcbiAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMub25NZWRpYUVuZGVkKTtcbiAgICBpZiAodGhpcy5rZXlMb2FkZXIgJiYgIXRyYW5zZmVycmluZ01lZGlhKSB7XG4gICAgICB0aGlzLmtleUxvYWRlci5kZXRhY2goKTtcbiAgICB9XG4gICAgdGhpcy5tZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMubG9vcFNuID0gdW5kZWZpbmVkO1xuICAgIGlmICh0cmFuc2ZlcnJpbmdNZWRpYSkge1xuICAgICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICAgICAgdGhpcy5yZXNldFRyYW5zbXV4ZXIoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sb2FkaW5nUGFydHMgPSBmYWxzZTtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVBbGxGcmFnbWVudHMoKTtcbiAgICB0aGlzLnN0b3BMb2FkKCk7XG4gIH1cbiAgb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgdGhpcy5pbml0UFRTID0gW107XG4gICAgdGhpcy5sZXZlbHMgPSB0aGlzLmxldmVsTGFzdExvYWRlZCA9IHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gdGhpcy5zdGFydFBvc2l0aW9uID0gMDtcbiAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICB9XG4gIG9uRXJyb3IoZXZlbnQsIGRhdGEpIHt9XG4gIG9uTWFuaWZlc3RMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLnN0YXJ0VGltZU9mZnNldCA9IGRhdGEuc3RhcnRUaW1lT2Zmc2V0O1xuICB9XG4gIG9uSGFuZGxlckRlc3Ryb3lpbmcoKSB7XG4gICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgIGlmICh0aGlzLnRyYW5zbXV4ZXIpIHtcbiAgICAgIHRoaXMudHJhbnNtdXhlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLnRyYW5zbXV4ZXIgPSBudWxsO1xuICAgIH1cbiAgICBzdXBlci5vbkhhbmRsZXJEZXN0cm95aW5nKCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuaGxzID0gdGhpcy5vbk1lZGlhU2Vla2luZyA9IHRoaXMub25NZWRpYUVuZGVkID0gbnVsbDtcbiAgfVxuICBvbkhhbmRsZXJEZXN0cm95ZWQoKSB7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gICAgaWYgKHRoaXMuZnJhZ21lbnRMb2FkZXIpIHtcbiAgICAgIHRoaXMuZnJhZ21lbnRMb2FkZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5rZXlMb2FkZXIpIHtcbiAgICAgIHRoaXMua2V5TG9hZGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGVjcnlwdGVyKSB7XG4gICAgICB0aGlzLmRlY3J5cHRlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuaGxzID0gdGhpcy5sb2cgPSB0aGlzLndhcm4gPSB0aGlzLmRlY3J5cHRlciA9IHRoaXMua2V5TG9hZGVyID0gdGhpcy5mcmFnbWVudExvYWRlciA9IHRoaXMuZnJhZ21lbnRUcmFja2VyID0gbnVsbDtcbiAgICBzdXBlci5vbkhhbmRsZXJEZXN0cm95ZWQoKTtcbiAgfVxuICBsb2FkRnJhZ21lbnQoZnJhZywgbGV2ZWwsIHRhcmdldEJ1ZmZlclRpbWUpIHtcbiAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IHRydWU7XG4gICAgdGhpcy5fbG9hZEZyYWdGb3JQbGF5YmFjayhmcmFnLCBsZXZlbCwgdGFyZ2V0QnVmZmVyVGltZSk7XG4gIH1cbiAgX2xvYWRGcmFnRm9yUGxheWJhY2soZnJhZ21lbnQsIGxldmVsLCB0YXJnZXRCdWZmZXJUaW1lKSB7XG4gICAgY29uc3QgcHJvZ3Jlc3NDYWxsYmFjayA9IGRhdGEgPT4ge1xuICAgICAgY29uc3QgZnJhZyA9IGRhdGEuZnJhZztcbiAgICAgIGlmICh0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgICB0aGlzLndhcm4oYCR7ZnJhZy50eXBlfSBzbjogJHtmcmFnLnNufSR7ZGF0YS5wYXJ0ID8gJyBwYXJ0OiAnICsgZGF0YS5wYXJ0LmluZGV4IDogJyd9IG9mICR7dGhpcy5mcmFnSW5mbyhmcmFnLCBmYWxzZSwgZGF0YS5wYXJ0KX0pIHdhcyBkcm9wcGVkIGR1cmluZyBkb3dubG9hZC5gKTtcbiAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZyYWcuc3RhdHMuY2h1bmtDb3VudCsrO1xuICAgICAgdGhpcy5faGFuZGxlRnJhZ21lbnRMb2FkUHJvZ3Jlc3MoZGF0YSk7XG4gICAgfTtcbiAgICB0aGlzLl9kb0ZyYWdMb2FkKGZyYWdtZW50LCBsZXZlbCwgdGFyZ2V0QnVmZmVyVGltZSwgcHJvZ3Jlc3NDYWxsYmFjaykudGhlbihkYXRhID0+IHtcbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAvLyBpZiB3ZSdyZSBoZXJlIHdlIHByb2JhYmx5IG5lZWRlZCB0byBiYWNrdHJhY2sgb3IgYXJlIHdhaXRpbmcgZm9yIG1vcmUgcGFydHNcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3QgZnJhZyA9IGRhdGEuZnJhZztcbiAgICAgIGlmICh0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgICBpZiAoc3RhdGUgPT09IFN0YXRlLkZSQUdfTE9BRElORyB8fCAhdGhpcy5mcmFnQ3VycmVudCAmJiBzdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICgncGF5bG9hZCcgaW4gZGF0YSkge1xuICAgICAgICB0aGlzLmxvZyhgTG9hZGVkICR7ZnJhZy50eXBlfSBzbjogJHtmcmFnLnNufSBvZiAke3RoaXMucGxheWxpc3RMYWJlbCgpfSAke2ZyYWcubGV2ZWx9YCk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfTE9BREVELCBkYXRhKTtcbiAgICAgIH1cblxuICAgICAgLy8gUGFzcyB0aHJvdWdoIHRoZSB3aG9sZSBwYXlsb2FkOyBjb250cm9sbGVycyBub3QgaW1wbGVtZW50aW5nIHByb2dyZXNzaXZlIGxvYWRpbmcgcmVjZWl2ZSBkYXRhIGZyb20gdGhpcyBjYWxsYmFja1xuICAgICAgdGhpcy5faGFuZGxlRnJhZ21lbnRMb2FkQ29tcGxldGUoZGF0YSk7XG4gICAgfSkuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5TVE9QUEVEIHx8IHRoaXMuc3RhdGUgPT09IFN0YXRlLkVSUk9SKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMud2FybihgRnJhZyBlcnJvcjogJHsocmVhc29uID09IG51bGwgPyB2b2lkIDAgOiByZWFzb24ubWVzc2FnZSkgfHwgcmVhc29ufWApO1xuICAgICAgdGhpcy5yZXNldEZyYWdtZW50TG9hZGluZyhmcmFnbWVudCk7XG4gICAgfSk7XG4gIH1cbiAgY2xlYXJUcmFja2VySWZOZWVkZWQoZnJhZykge1xuICAgIHZhciBfdGhpcyRtZWRpYUJ1ZmZlcjtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnbWVudFRyYWNrZXJcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBmcmFnU3RhdGUgPSBmcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZyk7XG4gICAgaWYgKGZyYWdTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5BUFBFTkRJTkcpIHtcbiAgICAgIC8vIExvd2VyIHRoZSBtYXggYnVmZmVyIGxlbmd0aCBhbmQgdHJ5IGFnYWluXG4gICAgICBjb25zdCBwbGF5bGlzdFR5cGUgPSBmcmFnLnR5cGU7XG4gICAgICBjb25zdCBidWZmZXJlZEluZm8gPSB0aGlzLmdldEZ3ZEJ1ZmZlckluZm8odGhpcy5tZWRpYUJ1ZmZlciwgcGxheWxpc3RUeXBlKTtcbiAgICAgIGNvbnN0IG1pbkZvcndhcmRCdWZmZXJMZW5ndGggPSBNYXRoLm1heChmcmFnLmR1cmF0aW9uLCBidWZmZXJlZEluZm8gPyBidWZmZXJlZEluZm8ubGVuIDogdGhpcy5jb25maWcubWF4QnVmZmVyTGVuZ3RoKTtcbiAgICAgIC8vIElmIGJhY2t0cmFja2luZywgYWx3YXlzIHJlbW92ZSBmcm9tIHRoZSB0cmFja2VyIHdpdGhvdXQgcmVkdWNpbmcgbWF4IGJ1ZmZlciBsZW5ndGhcbiAgICAgIGNvbnN0IGJhY2t0cmFja0ZyYWdtZW50ID0gdGhpcy5iYWNrdHJhY2tGcmFnbWVudDtcbiAgICAgIGNvbnN0IGJhY2t0cmFja2VkID0gYmFja3RyYWNrRnJhZ21lbnQgPyBmcmFnLnNuIC0gYmFja3RyYWNrRnJhZ21lbnQuc24gOiAwO1xuICAgICAgaWYgKGJhY2t0cmFja2VkID09PSAxIHx8IHRoaXMucmVkdWNlTWF4QnVmZmVyTGVuZ3RoKG1pbkZvcndhcmRCdWZmZXJMZW5ndGgsIGZyYWcuZHVyYXRpb24pKSB7XG4gICAgICAgIGZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCgoX3RoaXMkbWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhQnVmZmVyKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbWVkaWFCdWZmZXIuYnVmZmVyZWQubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgLy8gU3RvcCBnYXAgZm9yIGJhZCB0cmFja2VyIC8gYnVmZmVyIGZsdXNoIGJlaGF2aW9yXG4gICAgICBmcmFnbWVudFRyYWNrZXIucmVtb3ZlQWxsRnJhZ21lbnRzKCk7XG4gICAgfSBlbHNlIGlmIChmcmFnbWVudFRyYWNrZXIuaGFzUGFydHMoZnJhZy50eXBlKSkge1xuICAgICAgLy8gSW4gbG93IGxhdGVuY3kgbW9kZSwgcmVtb3ZlIGZyYWdtZW50cyBmb3Igd2hpY2ggb25seSBzb21lIHBhcnRzIHdlcmUgYnVmZmVyZWRcbiAgICAgIGZyYWdtZW50VHJhY2tlci5kZXRlY3RQYXJ0aWFsRnJhZ21lbnRzKHtcbiAgICAgICAgZnJhZyxcbiAgICAgICAgcGFydDogbnVsbCxcbiAgICAgICAgc3RhdHM6IGZyYWcuc3RhdHMsXG4gICAgICAgIGlkOiBmcmFnLnR5cGVcbiAgICAgIH0pO1xuICAgICAgaWYgKGZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmcmFnKSA9PT0gRnJhZ21lbnRTdGF0ZS5QQVJUSUFMKSB7XG4gICAgICAgIGZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2hlY2tMaXZlVXBkYXRlKGRldGFpbHMpIHtcbiAgICBpZiAoZGV0YWlscy51cGRhdGVkICYmICFkZXRhaWxzLmxpdmUpIHtcbiAgICAgIC8vIExpdmUgc3RyZWFtIGVuZGVkLCB1cGRhdGUgZnJhZ21lbnQgdHJhY2tlclxuICAgICAgY29uc3QgbGFzdEZyYWdtZW50ID0gZGV0YWlscy5mcmFnbWVudHNbZGV0YWlscy5mcmFnbWVudHMubGVuZ3RoIC0gMV07XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5kZXRlY3RQYXJ0aWFsRnJhZ21lbnRzKHtcbiAgICAgICAgZnJhZzogbGFzdEZyYWdtZW50LFxuICAgICAgICBwYXJ0OiBudWxsLFxuICAgICAgICBzdGF0czogbGFzdEZyYWdtZW50LnN0YXRzLFxuICAgICAgICBpZDogbGFzdEZyYWdtZW50LnR5cGVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIWRldGFpbHMuZnJhZ21lbnRzWzBdKSB7XG4gICAgICBkZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgd2FpdEZvckxpdmUobGV2ZWxJbmZvKSB7XG4gICAgY29uc3QgZGV0YWlscyA9IGxldmVsSW5mby5kZXRhaWxzO1xuICAgIHJldHVybiAoZGV0YWlscyA9PSBudWxsID8gdm9pZCAwIDogZGV0YWlscy5saXZlKSAmJiBkZXRhaWxzLnR5cGUgIT09ICdFVkVOVCcgJiYgKHRoaXMubGV2ZWxMYXN0TG9hZGVkICE9PSBsZXZlbEluZm8gfHwgZGV0YWlscy5leHBpcmVkKTtcbiAgfVxuICBmbHVzaE1haW5CdWZmZXIoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgdHlwZSA9IG51bGwpIHtcbiAgICBpZiAoIShzdGFydE9mZnNldCAtIGVuZE9mZnNldCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gV2hlbiBhbHRlcm5hdGUgYXVkaW8gaXMgcGxheWluZywgdGhlIGF1ZGlvLXN0cmVhbS1jb250cm9sbGVyIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgYXVkaW8gYnVmZmVyLiBPdGhlcndpc2UsXG4gICAgLy8gcGFzc2luZyBhIG51bGwgdHlwZSBmbHVzaGVzIGJvdGggYnVmZmVyc1xuICAgIGNvbnN0IGZsdXNoU2NvcGUgPSB7XG4gICAgICBzdGFydE9mZnNldCxcbiAgICAgIGVuZE9mZnNldCxcbiAgICAgIHR5cGVcbiAgICB9O1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9GTFVTSElORywgZmx1c2hTY29wZSk7XG4gIH1cbiAgX2xvYWRJbml0U2VnbWVudChmcmFnbWVudCwgbGV2ZWwpIHtcbiAgICB0aGlzLl9kb0ZyYWdMb2FkKGZyYWdtZW50LCBsZXZlbCkudGhlbihkYXRhID0+IHtcbiAgICAgIGNvbnN0IGZyYWcgPSBkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmZyYWc7XG4gICAgICBpZiAoIWZyYWcgfHwgdGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykgfHwgIXRoaXMubGV2ZWxzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW5pdCBsb2FkIGFib3J0ZWQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0pLnRoZW4oZGF0YSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGhsc1xuICAgICAgfSA9IHRoaXM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZyYWcsXG4gICAgICAgIHBheWxvYWRcbiAgICAgIH0gPSBkYXRhO1xuICAgICAgY29uc3QgZGVjcnlwdERhdGEgPSBmcmFnLmRlY3J5cHRkYXRhO1xuXG4gICAgICAvLyBjaGVjayB0byBzZWUgaWYgdGhlIHBheWxvYWQgbmVlZHMgdG8gYmUgZGVjcnlwdGVkXG4gICAgICBpZiAocGF5bG9hZCAmJiBwYXlsb2FkLmJ5dGVMZW5ndGggPiAwICYmIGRlY3J5cHREYXRhICE9IG51bGwgJiYgZGVjcnlwdERhdGEua2V5ICYmIGRlY3J5cHREYXRhLml2ICYmIGlzRnVsbFNlZ21lbnRFbmNyeXB0aW9uKGRlY3J5cHREYXRhLm1ldGhvZCkpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgLy8gZGVjcnlwdCBpbml0IHNlZ21lbnQgZGF0YVxuICAgICAgICByZXR1cm4gdGhpcy5kZWNyeXB0ZXIuZGVjcnlwdChuZXcgVWludDhBcnJheShwYXlsb2FkKSwgZGVjcnlwdERhdGEua2V5LmJ1ZmZlciwgZGVjcnlwdERhdGEuaXYuYnVmZmVyLCBnZXRBZXNNb2RlRnJvbUZ1bGxTZWdtZW50TWV0aG9kKGRlY3J5cHREYXRhLm1ldGhvZCkpLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfREVDUllQVF9FUlJPUixcbiAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgICAgICByZWFzb246IGVyci5tZXNzYWdlLFxuICAgICAgICAgICAgZnJhZ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSkudGhlbihkZWNyeXB0ZWREYXRhID0+IHtcbiAgICAgICAgICBjb25zdCBlbmRUaW1lID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuRlJBR19ERUNSWVBURUQsIHtcbiAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICBwYXlsb2FkOiBkZWNyeXB0ZWREYXRhLFxuICAgICAgICAgICAgc3RhdHM6IHtcbiAgICAgICAgICAgICAgdHN0YXJ0OiBzdGFydFRpbWUsXG4gICAgICAgICAgICAgIHRkZWNyeXB0OiBlbmRUaW1lXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGF0YS5wYXlsb2FkID0gZGVjcnlwdGVkRGF0YTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZUluaXRTZWdtZW50TG9hZChkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZUluaXRTZWdtZW50TG9hZChkYXRhKTtcbiAgICB9KS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLlNUT1BQRUQgfHwgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuRVJST1IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy53YXJuKHJlYXNvbik7XG4gICAgICB0aGlzLnJlc2V0RnJhZ21lbnRMb2FkaW5nKGZyYWdtZW50KTtcbiAgICB9KTtcbiAgfVxuICBjb21wbGV0ZUluaXRTZWdtZW50TG9hZChkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWxzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFsZXZlbHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW5pdCBsb2FkIGFib3J0ZWQsIG1pc3NpbmcgbGV2ZWxzJyk7XG4gICAgfVxuICAgIGNvbnN0IHN0YXRzID0gZGF0YS5mcmFnLnN0YXRzO1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSBTdGF0ZS5TVE9QUEVEKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICB9XG4gICAgZGF0YS5mcmFnLmRhdGEgPSBuZXcgVWludDhBcnJheShkYXRhLnBheWxvYWQpO1xuICAgIHN0YXRzLnBhcnNpbmcuc3RhcnQgPSBzdGF0cy5idWZmZXJpbmcuc3RhcnQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHN0YXRzLnBhcnNpbmcuZW5kID0gc3RhdHMuYnVmZmVyaW5nLmVuZCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgdGhpcy50aWNrKCk7XG4gIH1cbiAgZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnQ3VycmVudFxuICAgIH0gPSB0aGlzO1xuICAgIHJldHVybiAhZnJhZyB8fCAhZnJhZ0N1cnJlbnQgfHwgZnJhZy5zbiAhPT0gZnJhZ0N1cnJlbnQuc24gfHwgZnJhZy5sZXZlbCAhPT0gZnJhZ0N1cnJlbnQubGV2ZWw7XG4gIH1cbiAgZnJhZ0J1ZmZlcmVkQ29tcGxldGUoZnJhZywgcGFydCkge1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhO1xuICAgIHRoaXMubG9nKGBCdWZmZXJlZCAke2ZyYWcudHlwZX0gc246ICR7ZnJhZy5zbn0ke3BhcnQgPyAnIHBhcnQ6ICcgKyBwYXJ0LmluZGV4IDogJyd9IG9mICR7dGhpcy5mcmFnSW5mbyhmcmFnLCBmYWxzZSwgcGFydCl9ID4gYnVmZmVyOiR7bWVkaWEgPyBUaW1lUmFuZ2VzLnRvU3RyaW5nKEJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZChtZWRpYSkpIDogJyhkZXRhY2hlZCknfSlgKTtcbiAgICBpZiAoaXNNZWRpYUZyYWdtZW50KGZyYWcpKSB7XG4gICAgICB2YXIgX3RoaXMkbGV2ZWxzO1xuICAgICAgaWYgKGZyYWcudHlwZSAhPT0gUGxheWxpc3RMZXZlbFR5cGUuU1VCVElUTEUpIHtcbiAgICAgICAgY29uc3QgZWwgPSBmcmFnLmVsZW1lbnRhcnlTdHJlYW1zO1xuICAgICAgICBpZiAoIU9iamVjdC5rZXlzKGVsKS5zb21lKHR5cGUgPT4gISFlbFt0eXBlXSkpIHtcbiAgICAgICAgICAvLyBlbXB0eSBzZWdtZW50XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBsZXZlbCA9IChfdGhpcyRsZXZlbHMgPSB0aGlzLmxldmVscykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGxldmVsc1tmcmFnLmxldmVsXTtcbiAgICAgIGlmIChsZXZlbCAhPSBudWxsICYmIGxldmVsLmZyYWdtZW50RXJyb3IpIHtcbiAgICAgICAgdGhpcy5sb2coYFJlc2V0dGluZyBsZXZlbCBmcmFnbWVudCBlcnJvciBjb3VudCBvZiAke2xldmVsLmZyYWdtZW50RXJyb3J9IG9uIGZyYWcgYnVmZmVyZWRgKTtcbiAgICAgICAgbGV2ZWwuZnJhZ21lbnRFcnJvciA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICB9XG4gIF9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZShmcmFnTG9hZGVkRW5kRGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHRyYW5zbXV4ZXJcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIXRyYW5zbXV4ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIHBhcnQsXG4gICAgICBwYXJ0c0xvYWRlZFxuICAgIH0gPSBmcmFnTG9hZGVkRW5kRGF0YTtcbiAgICAvLyBJZiB3ZSBkaWQgbm90IGxvYWQgcGFydHMsIG9yIGxvYWRlZCBhbGwgcGFydHMsIHdlIGhhdmUgY29tcGxldGUgKG5vdCBwYXJ0aWFsKSBmcmFnbWVudCBkYXRhXG4gICAgY29uc3QgY29tcGxldGUgPSAhcGFydHNMb2FkZWQgfHwgcGFydHNMb2FkZWQubGVuZ3RoID09PSAwIHx8IHBhcnRzTG9hZGVkLnNvbWUoZnJhZ0xvYWRlZCA9PiAhZnJhZ0xvYWRlZCk7XG4gICAgY29uc3QgY2h1bmtNZXRhID0gbmV3IENodW5rTWV0YWRhdGEoZnJhZy5sZXZlbCwgZnJhZy5zbiwgZnJhZy5zdGF0cy5jaHVua0NvdW50ICsgMSwgMCwgcGFydCA/IHBhcnQuaW5kZXggOiAtMSwgIWNvbXBsZXRlKTtcbiAgICB0cmFuc211eGVyLmZsdXNoKGNodW5rTWV0YSk7XG4gIH1cbiAgX2hhbmRsZUZyYWdtZW50TG9hZFByb2dyZXNzKGZyYWcpIHt9XG4gIF9kb0ZyYWdMb2FkKGZyYWcsIGxldmVsLCB0YXJnZXRCdWZmZXJUaW1lID0gbnVsbCwgcHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgIHZhciBfZnJhZyRkZWNyeXB0ZGF0YTtcbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gZnJhZztcbiAgICBjb25zdCBkZXRhaWxzID0gbGV2ZWwgPT0gbnVsbCA/IHZvaWQgMCA6IGxldmVsLmRldGFpbHM7XG4gICAgaWYgKCF0aGlzLmxldmVscyB8fCAhZGV0YWlscykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBmcmFnIGxvYWQgYWJvcnRlZCwgbWlzc2luZyBsZXZlbCR7ZGV0YWlscyA/ICcnIDogJyBkZXRhaWwnfXNgKTtcbiAgICB9XG4gICAgbGV0IGtleUxvYWRpbmdQcm9taXNlID0gbnVsbDtcbiAgICBpZiAoZnJhZy5lbmNyeXB0ZWQgJiYgISgoX2ZyYWckZGVjcnlwdGRhdGEgPSBmcmFnLmRlY3J5cHRkYXRhKSAhPSBudWxsICYmIF9mcmFnJGRlY3J5cHRkYXRhLmtleSkpIHtcbiAgICAgIHRoaXMubG9nKGBMb2FkaW5nIGtleSBmb3IgJHtmcmFnLnNufSBvZiBbJHtkZXRhaWxzLnN0YXJ0U059LSR7ZGV0YWlscy5lbmRTTn1dLCAke3RoaXMucGxheWxpc3RMYWJlbCgpfSAke2ZyYWcubGV2ZWx9YCk7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuS0VZX0xPQURJTkc7XG4gICAgICB0aGlzLmZyYWdDdXJyZW50ID0gZnJhZztcbiAgICAgIGtleUxvYWRpbmdQcm9taXNlID0gdGhpcy5rZXlMb2FkZXIubG9hZChmcmFnKS50aGVuKGtleUxvYWRlZERhdGEgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGtleUxvYWRlZERhdGEuZnJhZykpIHtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5LRVlfTE9BREVELCBrZXlMb2FkZWREYXRhKTtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuS0VZX0xPQURJTkcpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ga2V5TG9hZGVkRGF0YTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5LRVlfTE9BRElORywge1xuICAgICAgICBmcmFnXG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLmZyYWdDdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgIGtleUxvYWRpbmdQcm9taXNlID0gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBmcmFnIGxvYWQgYWJvcnRlZCwgY29udGV4dCBjaGFuZ2VkIGluIEtFWV9MT0FESU5HYCkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWZyYWcuZW5jcnlwdGVkKSB7XG4gICAgICBrZXlMb2FkaW5nUHJvbWlzZSA9IHRoaXMua2V5TG9hZGVyLmxvYWRDbGVhcihmcmFnLCBkZXRhaWxzLmVuY3J5cHRlZEZyYWdtZW50cywgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQpO1xuICAgICAgaWYgKGtleUxvYWRpbmdQcm9taXNlKSB7XG4gICAgICAgIHRoaXMubG9nKGBbZW1lXSBibG9ja2luZyBmcmFnIGxvYWQgdW50aWwgbWVkaWEta2V5cyBhY3F1aXJlZGApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmcmFnUHJldmlvdXMgPSB0aGlzLmZyYWdQcmV2aW91cztcbiAgICBpZiAoaXNNZWRpYUZyYWdtZW50KGZyYWcpICYmICghZnJhZ1ByZXZpb3VzIHx8IGZyYWcuc24gIT09IGZyYWdQcmV2aW91cy5zbikpIHtcbiAgICAgIGNvbnN0IHNob3VsZExvYWRQYXJ0cyA9IHRoaXMuc2hvdWxkTG9hZFBhcnRzKGxldmVsLmRldGFpbHMsIGZyYWcuZW5kKTtcbiAgICAgIGlmIChzaG91bGRMb2FkUGFydHMgIT09IHRoaXMubG9hZGluZ1BhcnRzKSB7XG4gICAgICAgIHRoaXMubG9nKGBMTC1QYXJ0IGxvYWRpbmcgJHtzaG91bGRMb2FkUGFydHMgPyAnT04nIDogJ09GRid9IGxvYWRpbmcgc24gJHtmcmFnUHJldmlvdXMgPT0gbnVsbCA/IHZvaWQgMCA6IGZyYWdQcmV2aW91cy5zbn0tPiR7ZnJhZy5zbn1gKTtcbiAgICAgICAgdGhpcy5sb2FkaW5nUGFydHMgPSBzaG91bGRMb2FkUGFydHM7XG4gICAgICB9XG4gICAgfVxuICAgIHRhcmdldEJ1ZmZlclRpbWUgPSBNYXRoLm1heChmcmFnLnN0YXJ0LCB0YXJnZXRCdWZmZXJUaW1lIHx8IDApO1xuICAgIGlmICh0aGlzLmxvYWRpbmdQYXJ0cyAmJiBpc01lZGlhRnJhZ21lbnQoZnJhZykpIHtcbiAgICAgIGNvbnN0IHBhcnRMaXN0ID0gZGV0YWlscy5wYXJ0TGlzdDtcbiAgICAgIGlmIChwYXJ0TGlzdCAmJiBwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0YXJnZXRCdWZmZXJUaW1lID4gZnJhZy5lbmQgJiYgZGV0YWlscy5mcmFnbWVudEhpbnQpIHtcbiAgICAgICAgICBmcmFnID0gZGV0YWlscy5mcmFnbWVudEhpbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFydEluZGV4ID0gdGhpcy5nZXROZXh0UGFydChwYXJ0TGlzdCwgZnJhZywgdGFyZ2V0QnVmZmVyVGltZSk7XG4gICAgICAgIGlmIChwYXJ0SW5kZXggPiAtMSkge1xuICAgICAgICAgIGNvbnN0IHBhcnQgPSBwYXJ0TGlzdFtwYXJ0SW5kZXhdO1xuICAgICAgICAgIGZyYWcgPSB0aGlzLmZyYWdDdXJyZW50ID0gcGFydC5mcmFnbWVudDtcbiAgICAgICAgICB0aGlzLmxvZyhgTG9hZGluZyAke2ZyYWcudHlwZX0gc246ICR7ZnJhZy5zbn0gcGFydDogJHtwYXJ0LmluZGV4fSAoJHtwYXJ0SW5kZXh9LyR7cGFydExpc3QubGVuZ3RoIC0gMX0pIG9mICR7dGhpcy5mcmFnSW5mbyhmcmFnLCBmYWxzZSwgcGFydCl9KSBjYzogJHtmcmFnLmNjfSBbJHtkZXRhaWxzLnN0YXJ0U059LSR7ZGV0YWlscy5lbmRTTn1dLCB0YXJnZXQ6ICR7cGFyc2VGbG9hdCh0YXJnZXRCdWZmZXJUaW1lLnRvRml4ZWQoMykpfWApO1xuICAgICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHBhcnQuc3RhcnQgKyBwYXJ0LmR1cmF0aW9uO1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5GUkFHX0xPQURJTkc7XG4gICAgICAgICAgbGV0IF9yZXN1bHQ7XG4gICAgICAgICAgaWYgKGtleUxvYWRpbmdQcm9taXNlKSB7XG4gICAgICAgICAgICBfcmVzdWx0ID0ga2V5TG9hZGluZ1Byb21pc2UudGhlbihrZXlMb2FkZWREYXRhID0+IHtcbiAgICAgICAgICAgICAgaWYgKCFrZXlMb2FkZWREYXRhIHx8IHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGtleUxvYWRlZERhdGEuZnJhZykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kb0ZyYWdQYXJ0c0xvYWQoZnJhZywgcGFydCwgbGV2ZWwsIHByb2dyZXNzQ2FsbGJhY2spO1xuICAgICAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4gdGhpcy5oYW5kbGVGcmFnTG9hZEVycm9yKGVycm9yKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9yZXN1bHQgPSB0aGlzLmRvRnJhZ1BhcnRzTG9hZChmcmFnLCBwYXJ0LCBsZXZlbCwgcHJvZ3Jlc3NDYWxsYmFjaykuY2F0Y2goZXJyb3IgPT4gdGhpcy5oYW5kbGVGcmFnTG9hZEVycm9yKGVycm9yKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfTE9BRElORywge1xuICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgIHBhcnQsXG4gICAgICAgICAgICB0YXJnZXRCdWZmZXJUaW1lXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHRoaXMuZnJhZ0N1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYGZyYWcgbG9hZCBhYm9ydGVkLCBjb250ZXh0IGNoYW5nZWQgaW4gRlJBR19MT0FESU5HIHBhcnRzYCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3Jlc3VsdDtcbiAgICAgICAgfSBlbHNlIGlmICghZnJhZy51cmwgfHwgdGhpcy5sb2FkZWRFbmRPZlBhcnRzKHBhcnRMaXN0LCB0YXJnZXRCdWZmZXJUaW1lKSkge1xuICAgICAgICAgIC8vIEZyYWdtZW50IGhpbnQgaGFzIG5vIHBhcnRzXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNNZWRpYUZyYWdtZW50KGZyYWcpICYmIHRoaXMubG9hZGluZ1BhcnRzKSB7XG4gICAgICB0aGlzLmxvZyhgTEwtUGFydCBsb2FkaW5nIE9GRiBhZnRlciBuZXh0IHBhcnQgbWlzcyBAJHt0YXJnZXRCdWZmZXJUaW1lLnRvRml4ZWQoMil9YCk7XG4gICAgICB0aGlzLmxvYWRpbmdQYXJ0cyA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoIWZyYWcudXJsKSB7XG4gICAgICAvLyBTZWxlY3RlZCBmcmFnbWVudCBoaW50IGZvciBwYXJ0IGJ1dCBub3QgbG9hZGluZyBwYXJ0c1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICB9XG4gICAgdGhpcy5sb2coYExvYWRpbmcgJHtmcmFnLnR5cGV9IHNuOiAke2ZyYWcuc259IG9mICR7dGhpcy5mcmFnSW5mbyhmcmFnLCBmYWxzZSl9KSBjYzogJHtmcmFnLmNjfSAke2RldGFpbHMgPyAnWycgKyBkZXRhaWxzLnN0YXJ0U04gKyAnLScgKyBkZXRhaWxzLmVuZFNOICsgJ10nIDogJyd9LCB0YXJnZXQ6ICR7cGFyc2VGbG9hdCh0YXJnZXRCdWZmZXJUaW1lLnRvRml4ZWQoMykpfWApO1xuICAgIC8vIERvbid0IHVwZGF0ZSBuZXh0TG9hZFBvc2l0aW9uIGZvciBmcmFnbWVudHMgd2hpY2ggYXJlIG5vdCBidWZmZXJlZFxuICAgIGlmIChpc0Zpbml0ZU51bWJlcihmcmFnLnNuKSAmJiAhdGhpcy5iaXRyYXRlVGVzdCkge1xuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gZnJhZy5zdGFydCArIGZyYWcuZHVyYXRpb247XG4gICAgfVxuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5GUkFHX0xPQURJTkc7XG5cbiAgICAvLyBMb2FkIGtleSBiZWZvcmUgc3RyZWFtaW5nIGZyYWdtZW50IGRhdGFcbiAgICBjb25zdCBkYXRhT25Qcm9ncmVzcyA9IHRoaXMuY29uZmlnLnByb2dyZXNzaXZlO1xuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKGRhdGFPblByb2dyZXNzICYmIGtleUxvYWRpbmdQcm9taXNlKSB7XG4gICAgICByZXN1bHQgPSBrZXlMb2FkaW5nUHJvbWlzZS50aGVuKGtleUxvYWRlZERhdGEgPT4ge1xuICAgICAgICBpZiAoIWtleUxvYWRlZERhdGEgfHwgdGhpcy5mcmFnQ29udGV4dENoYW5nZWQoa2V5TG9hZGVkRGF0YSA9PSBudWxsID8gdm9pZCAwIDoga2V5TG9hZGVkRGF0YS5mcmFnKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZyYWdtZW50TG9hZGVyLmxvYWQoZnJhZywgcHJvZ3Jlc3NDYWxsYmFjayk7XG4gICAgICB9KS5jYXRjaChlcnJvciA9PiB0aGlzLmhhbmRsZUZyYWdMb2FkRXJyb3IoZXJyb3IpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbG9hZCB1bmVuY3J5cHRlZCBmcmFnbWVudCBkYXRhIHdpdGggcHJvZ3Jlc3MgZXZlbnQsXG4gICAgICAvLyBvciBoYW5kbGUgZnJhZ21lbnQgcmVzdWx0IGFmdGVyIGtleSBhbmQgZnJhZ21lbnQgYXJlIGZpbmlzaGVkIGxvYWRpbmdcbiAgICAgIHJlc3VsdCA9IFByb21pc2UuYWxsKFt0aGlzLmZyYWdtZW50TG9hZGVyLmxvYWQoZnJhZywgZGF0YU9uUHJvZ3Jlc3MgPyBwcm9ncmVzc0NhbGxiYWNrIDogdW5kZWZpbmVkKSwga2V5TG9hZGluZ1Byb21pc2VdKS50aGVuKChbZnJhZ0xvYWRlZERhdGFdKSA9PiB7XG4gICAgICAgIGlmICghZGF0YU9uUHJvZ3Jlc3MgJiYgZnJhZ0xvYWRlZERhdGEgJiYgcHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgICAgICAgIHByb2dyZXNzQ2FsbGJhY2soZnJhZ0xvYWRlZERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcmFnTG9hZGVkRGF0YTtcbiAgICAgIH0pLmNhdGNoKGVycm9yID0+IHRoaXMuaGFuZGxlRnJhZ0xvYWRFcnJvcihlcnJvcikpO1xuICAgIH1cbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0xPQURJTkcsIHtcbiAgICAgIGZyYWcsXG4gICAgICB0YXJnZXRCdWZmZXJUaW1lXG4gICAgfSk7XG4gICAgaWYgKHRoaXMuZnJhZ0N1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYGZyYWcgbG9hZCBhYm9ydGVkLCBjb250ZXh0IGNoYW5nZWQgaW4gRlJBR19MT0FESU5HYCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGRvRnJhZ1BhcnRzTG9hZChmcmFnLCBmcm9tUGFydCwgbGV2ZWwsIHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdmFyIF9sZXZlbCRkZXRhaWxzO1xuICAgICAgY29uc3QgcGFydHNMb2FkZWQgPSBbXTtcbiAgICAgIGNvbnN0IGluaXRpYWxQYXJ0TGlzdCA9IChfbGV2ZWwkZGV0YWlscyA9IGxldmVsLmRldGFpbHMpID09IG51bGwgPyB2b2lkIDAgOiBfbGV2ZWwkZGV0YWlscy5wYXJ0TGlzdDtcbiAgICAgIGNvbnN0IGxvYWRQYXJ0ID0gcGFydCA9PiB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRMb2FkZXIubG9hZFBhcnQoZnJhZywgcGFydCwgcHJvZ3Jlc3NDYWxsYmFjaykudGhlbihwYXJ0TG9hZGVkRGF0YSA9PiB7XG4gICAgICAgICAgcGFydHNMb2FkZWRbcGFydC5pbmRleF0gPSBwYXJ0TG9hZGVkRGF0YTtcbiAgICAgICAgICBjb25zdCBsb2FkZWRQYXJ0ID0gcGFydExvYWRlZERhdGEucGFydDtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0xPQURFRCwgcGFydExvYWRlZERhdGEpO1xuICAgICAgICAgIGNvbnN0IG5leHRQYXJ0ID0gZ2V0UGFydFdpdGgobGV2ZWwuZGV0YWlscywgZnJhZy5zbiwgcGFydC5pbmRleCArIDEpIHx8IGZpbmRQYXJ0KGluaXRpYWxQYXJ0TGlzdCwgZnJhZy5zbiwgcGFydC5pbmRleCArIDEpO1xuICAgICAgICAgIGlmIChuZXh0UGFydCkge1xuICAgICAgICAgICAgbG9hZFBhcnQobmV4dFBhcnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh7XG4gICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgIHBhcnQ6IGxvYWRlZFBhcnQsXG4gICAgICAgICAgICAgIHBhcnRzTG9hZGVkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XG4gICAgICB9O1xuICAgICAgbG9hZFBhcnQoZnJvbVBhcnQpO1xuICAgIH0pO1xuICB9XG4gIGhhbmRsZUZyYWdMb2FkRXJyb3IoZXJyb3IpIHtcbiAgICBpZiAoJ2RhdGEnIGluIGVycm9yKSB7XG4gICAgICBjb25zdCBkYXRhID0gZXJyb3IuZGF0YTtcbiAgICAgIGlmIChlcnJvci5kYXRhICYmIGRhdGEuZGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLklOVEVSTkFMX0FCT1JURUQpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVGcmFnTG9hZEFib3J0ZWQoZGF0YS5mcmFnLCBkYXRhLnBhcnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIGRhdGEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuSU5URVJOQUxfRVhDRVBUSU9OLFxuICAgICAgICBlcnI6IGVycm9yLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBfaGFuZGxlVHJhbnNtdXhlckZsdXNoKGNodW5rTWV0YSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdldEN1cnJlbnRDb250ZXh0KGNodW5rTWV0YSk7XG4gICAgaWYgKCFjb250ZXh0IHx8IHRoaXMuc3RhdGUgIT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgIGlmICghdGhpcy5mcmFnQ3VycmVudCAmJiB0aGlzLnN0YXRlICE9PSBTdGF0ZS5TVE9QUEVEICYmIHRoaXMuc3RhdGUgIT09IFN0YXRlLkVSUk9SKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBmcmFnLFxuICAgICAgcGFydCxcbiAgICAgIGxldmVsXG4gICAgfSA9IGNvbnRleHQ7XG4gICAgY29uc3Qgbm93ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICBmcmFnLnN0YXRzLnBhcnNpbmcuZW5kID0gbm93O1xuICAgIGlmIChwYXJ0KSB7XG4gICAgICBwYXJ0LnN0YXRzLnBhcnNpbmcuZW5kID0gbm93O1xuICAgIH1cbiAgICAvLyBTZWUgaWYgcGFydCBsb2FkaW5nIHNob3VsZCBiZSBkaXNhYmxlZC9lbmFibGVkIGJhc2VkIG9uIGJ1ZmZlciBhbmQgcGxheWJhY2sgcG9zaXRpb24uXG4gICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gdGhpcy5nZXRMZXZlbERldGFpbHMoKTtcbiAgICBjb25zdCBsb2FkaW5nUGFydHNBdEVkZ2UgPSBsZXZlbERldGFpbHMgJiYgZnJhZy5zbiA+IGxldmVsRGV0YWlscy5lbmRTTjtcbiAgICBjb25zdCBzaG91bGRMb2FkUGFydHMgPSBsb2FkaW5nUGFydHNBdEVkZ2UgfHwgdGhpcy5zaG91bGRMb2FkUGFydHMobGV2ZWxEZXRhaWxzLCBmcmFnLmVuZCk7XG4gICAgaWYgKHNob3VsZExvYWRQYXJ0cyAhPT0gdGhpcy5sb2FkaW5nUGFydHMpIHtcbiAgICAgIHRoaXMubG9nKGBMTC1QYXJ0IGxvYWRpbmcgJHtzaG91bGRMb2FkUGFydHMgPyAnT04nIDogJ09GRid9IGFmdGVyIHBhcnNpbmcgc2VnbWVudCBlbmRpbmcgQCR7ZnJhZy5lbmQudG9GaXhlZCgyKX1gKTtcbiAgICAgIHRoaXMubG9hZGluZ1BhcnRzID0gc2hvdWxkTG9hZFBhcnRzO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUxldmVsVGltaW5nKGZyYWcsIHBhcnQsIGxldmVsLCBjaHVua01ldGEucGFydGlhbCk7XG4gIH1cbiAgc2hvdWxkTG9hZFBhcnRzKGRldGFpbHMsIGJ1ZmZlckVuZCkge1xuICAgIGlmICh0aGlzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZSkge1xuICAgICAgaWYgKCFkZXRhaWxzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRpbmdQYXJ0cztcbiAgICAgIH1cbiAgICAgIGlmIChkZXRhaWxzICE9IG51bGwgJiYgZGV0YWlscy5wYXJ0TGlzdCkge1xuICAgICAgICB2YXIgX2RldGFpbHMkZnJhZ21lbnRIaW50O1xuICAgICAgICAvLyBCdWZmZXIgbXVzdCBiZSBhaGVhZCBvZiBmaXJzdCBwYXJ0ICsgZHVyYXRpb24gb2YgcGFydHMgYWZ0ZXIgbGFzdCBzZWdtZW50XG4gICAgICAgIC8vIGFuZCBwbGF5YmFjayBtdXN0IGJlIGF0IG9yIHBhc3Qgc2VnbWVudCBhZGphY2VudCB0byBwYXJ0IGxpc3RcbiAgICAgICAgY29uc3QgZmlyc3RQYXJ0ID0gZGV0YWlscy5wYXJ0TGlzdFswXTtcbiAgICAgICAgY29uc3Qgc2FmZVBhcnRTdGFydCA9IGZpcnN0UGFydC5lbmQgKyAoKChfZGV0YWlscyRmcmFnbWVudEhpbnQgPSBkZXRhaWxzLmZyYWdtZW50SGludCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kZXRhaWxzJGZyYWdtZW50SGludC5kdXJhdGlvbikgfHwgMCk7XG4gICAgICAgIGlmIChidWZmZXJFbmQgPj0gc2FmZVBhcnRTdGFydCkge1xuICAgICAgICAgIHZhciBfdGhpcyRtZWRpYTtcbiAgICAgICAgICBjb25zdCBwbGF5aGVhZCA9IHRoaXMuaGxzLmhhc0Vub3VnaFRvU3RhcnQgPyAoKF90aGlzJG1lZGlhID0gdGhpcy5tZWRpYSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG1lZGlhLmN1cnJlbnRUaW1lKSB8fCB0aGlzLmxhc3RDdXJyZW50VGltZSA6IHRoaXMuZ2V0TG9hZFBvc2l0aW9uKCk7XG4gICAgICAgICAgaWYgKHBsYXloZWFkID4gZmlyc3RQYXJ0LnN0YXJ0IC0gZmlyc3RQYXJ0LmZyYWdtZW50LmR1cmF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGdldEN1cnJlbnRDb250ZXh0KGNodW5rTWV0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxldmVscyxcbiAgICAgIGZyYWdDdXJyZW50XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWw6IGxldmVsSW5kZXgsXG4gICAgICBzbixcbiAgICAgIHBhcnQ6IHBhcnRJbmRleFxuICAgIH0gPSBjaHVua01ldGE7XG4gICAgaWYgKCEobGV2ZWxzICE9IG51bGwgJiYgbGV2ZWxzW2xldmVsSW5kZXhdKSkge1xuICAgICAgdGhpcy53YXJuKGBMZXZlbHMgb2JqZWN0IHdhcyB1bnNldCB3aGlsZSBidWZmZXJpbmcgZnJhZ21lbnQgJHtzbn0gb2YgJHt0aGlzLnBsYXlsaXN0TGFiZWwoKX0gJHtsZXZlbEluZGV4fS4gVGhlIGN1cnJlbnQgY2h1bmsgd2lsbCBub3QgYmUgYnVmZmVyZWQuYCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgbGV2ZWwgPSBsZXZlbHNbbGV2ZWxJbmRleF07XG4gICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gbGV2ZWwuZGV0YWlscztcbiAgICBjb25zdCBwYXJ0ID0gcGFydEluZGV4ID4gLTEgPyBnZXRQYXJ0V2l0aChsZXZlbERldGFpbHMsIHNuLCBwYXJ0SW5kZXgpIDogbnVsbDtcbiAgICBjb25zdCBmcmFnID0gcGFydCA/IHBhcnQuZnJhZ21lbnQgOiBnZXRGcmFnbWVudFdpdGhTTihsZXZlbERldGFpbHMsIHNuLCBmcmFnQ3VycmVudCk7XG4gICAgaWYgKCFmcmFnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGZyYWdDdXJyZW50ICYmIGZyYWdDdXJyZW50ICE9PSBmcmFnKSB7XG4gICAgICBmcmFnLnN0YXRzID0gZnJhZ0N1cnJlbnQuc3RhdHM7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBmcmFnLFxuICAgICAgcGFydCxcbiAgICAgIGxldmVsXG4gICAgfTtcbiAgfVxuICBidWZmZXJGcmFnbWVudERhdGEoZGF0YSwgZnJhZywgcGFydCwgY2h1bmtNZXRhLCBub0JhY2t0cmFja2luZykge1xuICAgIHZhciBfYnVmZmVyO1xuICAgIGlmICghZGF0YSB8fCB0aGlzLnN0YXRlICE9PSBTdGF0ZS5QQVJTSU5HKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGRhdGExLFxuICAgICAgZGF0YTJcbiAgICB9ID0gZGF0YTtcbiAgICBsZXQgYnVmZmVyID0gZGF0YTE7XG4gICAgaWYgKGRhdGExICYmIGRhdGEyKSB7XG4gICAgICAvLyBDb21iaW5lIHRoZSBtb29mICsgbWRhdCBzbyB0aGF0IHdlIGJ1ZmZlciB3aXRoIGEgc2luZ2xlIGFwcGVuZFxuICAgICAgYnVmZmVyID0gYXBwZW5kVWludDhBcnJheShkYXRhMSwgZGF0YTIpO1xuICAgIH1cbiAgICBpZiAoISgoX2J1ZmZlciA9IGJ1ZmZlcikgIT0gbnVsbCAmJiBfYnVmZmVyLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb2Zmc2V0VGltZXN0YW1wID0gdGhpcy5pbml0UFRTW2ZyYWcuY2NdO1xuICAgIGNvbnN0IG9mZnNldCA9IG9mZnNldFRpbWVzdGFtcCA/IC1vZmZzZXRUaW1lc3RhbXAuYmFzZVRpbWUgLyBvZmZzZXRUaW1lc3RhbXAudGltZXNjYWxlIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHNlZ21lbnQgPSB7XG4gICAgICB0eXBlOiBkYXRhLnR5cGUsXG4gICAgICBmcmFnLFxuICAgICAgcGFydCxcbiAgICAgIGNodW5rTWV0YSxcbiAgICAgIG9mZnNldCxcbiAgICAgIHBhcmVudDogZnJhZy50eXBlLFxuICAgICAgZGF0YTogYnVmZmVyXG4gICAgfTtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfQVBQRU5ESU5HLCBzZWdtZW50KTtcbiAgICBpZiAoZGF0YS5kcm9wcGVkICYmIGRhdGEuaW5kZXBlbmRlbnQgJiYgIXBhcnQpIHtcbiAgICAgIGlmIChub0JhY2t0cmFja2luZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBDbGVhciBidWZmZXIgc28gdGhhdCB3ZSByZWxvYWQgcHJldmlvdXMgc2VnbWVudHMgc2VxdWVudGlhbGx5IGlmIHJlcXVpcmVkXG4gICAgICB0aGlzLmZsdXNoQnVmZmVyR2FwKGZyYWcpO1xuICAgIH1cbiAgfVxuICBmbHVzaEJ1ZmZlckdhcChmcmFnKSB7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGlmICghbWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgY3VycmVudFRpbWUgaXMgbm90IGJ1ZmZlcmVkLCBjbGVhciB0aGUgYmFjayBidWZmZXIgc28gdGhhdCB3ZSBjYW4gYmFja3RyYWNrIGFzIG11Y2ggYXMgbmVlZGVkXG4gICAgaWYgKCFCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZChtZWRpYSwgbWVkaWEuY3VycmVudFRpbWUpKSB7XG4gICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcigwLCBmcmFnLnN0YXJ0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGJhY2stYnVmZmVyIHdpdGhvdXQgaW50ZXJydXB0aW5nIHBsYXliYWNrIHRvIGFsbG93IGJhY2sgdHJhY2tpbmdcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhtZWRpYSwgY3VycmVudFRpbWUsIDApO1xuICAgIGNvbnN0IGZyYWdEdXJhdGlvbiA9IGZyYWcuZHVyYXRpb247XG4gICAgY29uc3Qgc2VnbWVudEZyYWN0aW9uID0gTWF0aC5taW4odGhpcy5jb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSAqIDIsIGZyYWdEdXJhdGlvbiAqIDAuMjUpO1xuICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoTWF0aC5taW4oZnJhZy5zdGFydCAtIHNlZ21lbnRGcmFjdGlvbiwgYnVmZmVySW5mby5lbmQgLSBzZWdtZW50RnJhY3Rpb24pLCBjdXJyZW50VGltZSArIHNlZ21lbnRGcmFjdGlvbik7XG4gICAgaWYgKGZyYWcuc3RhcnQgLSBzdGFydCA+IHNlZ21lbnRGcmFjdGlvbikge1xuICAgICAgdGhpcy5mbHVzaE1haW5CdWZmZXIoc3RhcnQsIGZyYWcuc3RhcnQpO1xuICAgIH1cbiAgfVxuICBnZXRGd2RCdWZmZXJJbmZvKGJ1ZmZlcmFibGUsIHR5cGUpIHtcbiAgICB2YXIgX3RoaXMkbWVkaWEyO1xuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0TG9hZFBvc2l0aW9uKCk7XG4gICAgaWYgKCFpc0Zpbml0ZU51bWJlcihwb3MpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgYmFja3dhcmRTZWVrID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPiBwb3M7XG4gICAgY29uc3QgbWF4QnVmZmVySG9sZSA9IGJhY2t3YXJkU2VlayB8fCAoX3RoaXMkbWVkaWEyID0gdGhpcy5tZWRpYSkgIT0gbnVsbCAmJiBfdGhpcyRtZWRpYTIucGF1c2VkID8gMCA6IHRoaXMuY29uZmlnLm1heEJ1ZmZlckhvbGU7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RndkQnVmZmVySW5mb0F0UG9zKGJ1ZmZlcmFibGUsIHBvcywgdHlwZSwgbWF4QnVmZmVySG9sZSk7XG4gIH1cbiAgZ2V0RndkQnVmZmVySW5mb0F0UG9zKGJ1ZmZlcmFibGUsIHBvcywgdHlwZSwgbWF4QnVmZmVySG9sZSkge1xuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhidWZmZXJhYmxlLCBwb3MsIG1heEJ1ZmZlckhvbGUpO1xuICAgIC8vIFdvcmthcm91bmQgZmxhdyBpbiBnZXR0aW5nIGZvcndhcmQgYnVmZmVyIHdoZW4gbWF4QnVmZmVySG9sZSBpcyBzbWFsbGVyIHRoYW4gZ2FwIGF0IGN1cnJlbnQgcG9zXG4gICAgaWYgKGJ1ZmZlckluZm8ubGVuID09PSAwICYmIGJ1ZmZlckluZm8ubmV4dFN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGJ1ZmZlcmVkRnJhZ0F0UG9zID0gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0QnVmZmVyZWRGcmFnKHBvcywgdHlwZSk7XG4gICAgICBpZiAoYnVmZmVyZWRGcmFnQXRQb3MgJiYgKGJ1ZmZlckluZm8ubmV4dFN0YXJ0IDw9IGJ1ZmZlcmVkRnJhZ0F0UG9zLmVuZCB8fCBidWZmZXJlZEZyYWdBdFBvcy5nYXApKSB7XG4gICAgICAgIGNvbnN0IGdhcER1cmF0aW9uID0gTWF0aC5tYXgoTWF0aC5taW4oYnVmZmVySW5mby5uZXh0U3RhcnQsIGJ1ZmZlcmVkRnJhZ0F0UG9zLmVuZCkgLSBwb3MsIG1heEJ1ZmZlckhvbGUpO1xuICAgICAgICByZXR1cm4gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8oYnVmZmVyYWJsZSwgcG9zLCBnYXBEdXJhdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBidWZmZXJJbmZvO1xuICB9XG4gIGdldE1heEJ1ZmZlckxlbmd0aChsZXZlbEJpdHJhdGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb25maWdcbiAgICB9ID0gdGhpcztcbiAgICBsZXQgbWF4QnVmTGVuO1xuICAgIGlmIChsZXZlbEJpdHJhdGUpIHtcbiAgICAgIG1heEJ1ZkxlbiA9IE1hdGgubWF4KDggKiBjb25maWcubWF4QnVmZmVyU2l6ZSAvIGxldmVsQml0cmF0ZSwgY29uZmlnLm1heEJ1ZmZlckxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heEJ1ZkxlbiA9IGNvbmZpZy5tYXhCdWZmZXJMZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLm1pbihtYXhCdWZMZW4sIGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGgpO1xuICB9XG4gIHJlZHVjZU1heEJ1ZmZlckxlbmd0aCh0aHJlc2hvbGQsIGZyYWdEdXJhdGlvbikge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGNvbnN0IG1pbkxlbmd0aCA9IE1hdGgubWF4KE1hdGgubWluKHRocmVzaG9sZCAtIGZyYWdEdXJhdGlvbiwgY29uZmlnLm1heEJ1ZmZlckxlbmd0aCksIGZyYWdEdXJhdGlvbik7XG4gICAgY29uc3QgcmVkdWNlZExlbmd0aCA9IE1hdGgubWF4KHRocmVzaG9sZCAtIGZyYWdEdXJhdGlvbiAqIDMsIGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGggLyAyLCBtaW5MZW5ndGgpO1xuICAgIGlmIChyZWR1Y2VkTGVuZ3RoID49IG1pbkxlbmd0aCkge1xuICAgICAgLy8gcmVkdWNlIG1heCBidWZmZXIgbGVuZ3RoIGFzIGl0IG1pZ2h0IGJlIHRvbyBoaWdoLiB3ZSBkbyB0aGlzIHRvIGF2b2lkIGxvb3AgZmx1c2hpbmcgLi4uXG4gICAgICBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoID0gcmVkdWNlZExlbmd0aDtcbiAgICAgIHRoaXMud2FybihgUmVkdWNlIG1heCBidWZmZXIgbGVuZ3RoIHRvICR7cmVkdWNlZExlbmd0aH1zYCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGdldEFwcGVuZGVkRnJhZyhwb3NpdGlvbiwgcGxheWxpc3RUeXBlID0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTikge1xuICAgIHZhciBfdGhpcyRmcmFnbWVudFRyYWNrZXI7XG4gICAgY29uc3QgZnJhZ09yUGFydCA9IChfdGhpcyRmcmFnbWVudFRyYWNrZXIgPSB0aGlzLmZyYWdtZW50VHJhY2tlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGZyYWdtZW50VHJhY2tlci5nZXRBcHBlbmRlZEZyYWcocG9zaXRpb24sIHBsYXlsaXN0VHlwZSk7XG4gICAgaWYgKGZyYWdPclBhcnQgJiYgJ2ZyYWdtZW50JyBpbiBmcmFnT3JQYXJ0KSB7XG4gICAgICByZXR1cm4gZnJhZ09yUGFydC5mcmFnbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIGZyYWdPclBhcnQ7XG4gIH1cbiAgZ2V0TmV4dEZyYWdtZW50KHBvcywgbGV2ZWxEZXRhaWxzKSB7XG4gICAgY29uc3QgZnJhZ21lbnRzID0gbGV2ZWxEZXRhaWxzLmZyYWdtZW50cztcbiAgICBjb25zdCBmcmFnTGVuID0gZnJhZ21lbnRzLmxlbmd0aDtcbiAgICBpZiAoIWZyYWdMZW4pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIGZpbmQgZnJhZ21lbnQgaW5kZXgsIGNvbnRpZ3VvdXMgd2l0aCBlbmQgb2YgYnVmZmVyIHBvc2l0aW9uXG4gICAgY29uc3Qge1xuICAgICAgY29uZmlnXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc3RhcnQgPSBmcmFnbWVudHNbMF0uc3RhcnQ7XG4gICAgY29uc3QgY2FuTG9hZFBhcnRzID0gY29uZmlnLmxvd0xhdGVuY3lNb2RlICYmICEhbGV2ZWxEZXRhaWxzLnBhcnRMaXN0O1xuICAgIGxldCBmcmFnID0gbnVsbDtcbiAgICBpZiAobGV2ZWxEZXRhaWxzLmxpdmUpIHtcbiAgICAgIGNvbnN0IGluaXRpYWxMaXZlTWFuaWZlc3RTaXplID0gY29uZmlnLmluaXRpYWxMaXZlTWFuaWZlc3RTaXplO1xuICAgICAgaWYgKGZyYWdMZW4gPCBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZSkge1xuICAgICAgICB0aGlzLndhcm4oYE5vdCBlbm91Z2ggZnJhZ21lbnRzIHRvIHN0YXJ0IHBsYXliYWNrIChoYXZlOiAke2ZyYWdMZW59LCBuZWVkOiAke2luaXRpYWxMaXZlTWFuaWZlc3RTaXplfSlgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICAvLyBUaGUgcmVhbCBmcmFnbWVudCBzdGFydCB0aW1lcyBmb3IgYSBsaXZlIHN0cmVhbSBhcmUgb25seSBrbm93biBhZnRlciB0aGUgUFRTIHJhbmdlIGZvciB0aGF0IGxldmVsIGlzIGtub3duLlxuICAgICAgLy8gSW4gb3JkZXIgdG8gZGlzY292ZXIgdGhlIHJhbmdlLCB3ZSBsb2FkIHRoZSBiZXN0IG1hdGNoaW5nIGZyYWdtZW50IGZvciB0aGF0IGxldmVsIGFuZCBkZW11eCBpdC5cbiAgICAgIC8vIERvIG5vdCBsb2FkIHVzaW5nIGxpdmUgbG9naWMgaWYgdGhlIHN0YXJ0aW5nIGZyYWcgaXMgcmVxdWVzdGVkIC0gd2Ugd2FudCB0byB1c2UgZ2V0RnJhZ21lbnRBdFBvc2l0aW9uKCkgc28gdGhhdFxuICAgICAgLy8gd2UgZ2V0IHRoZSBmcmFnbWVudCBtYXRjaGluZyB0aGF0IHN0YXJ0IHRpbWVcbiAgICAgIGlmICghbGV2ZWxEZXRhaWxzLlBUU0tub3duICYmICF0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCAmJiB0aGlzLnN0YXJ0UG9zaXRpb24gPT09IC0xIHx8IHBvcyA8IHN0YXJ0KSB7XG4gICAgICAgIHZhciBfZnJhZztcbiAgICAgICAgaWYgKGNhbkxvYWRQYXJ0cyAmJiAhdGhpcy5sb2FkaW5nUGFydHMpIHtcbiAgICAgICAgICB0aGlzLmxvZyhgTEwtUGFydCBsb2FkaW5nIE9OIGZvciBpbml0aWFsIGxpdmUgZnJhZ21lbnRgKTtcbiAgICAgICAgICB0aGlzLmxvYWRpbmdQYXJ0cyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZnJhZyA9IHRoaXMuZ2V0SW5pdGlhbExpdmVGcmFnbWVudChsZXZlbERldGFpbHMpO1xuICAgICAgICBjb25zdCBtYWluU3RhcnQgPSB0aGlzLmhscy5zdGFydFBvc2l0aW9uO1xuICAgICAgICBjb25zdCBsaXZlU3luY1Bvc2l0aW9uID0gdGhpcy5obHMubGl2ZVN5bmNQb3NpdGlvbjtcbiAgICAgICAgY29uc3Qgc3RhcnRQb3NpdGlvbiA9IGZyYWcgPyAobWFpblN0YXJ0ICE9PSAtMSAmJiBtYWluU3RhcnQgPj0gc3RhcnQgPyBtYWluU3RhcnQgOiBsaXZlU3luY1Bvc2l0aW9uKSB8fCBmcmFnLnN0YXJ0IDogcG9zO1xuICAgICAgICB0aGlzLmxvZyhgU2V0dGluZyBzdGFydFBvc2l0aW9uIHRvICR7c3RhcnRQb3NpdGlvbn0gdG8gbWF0Y2ggc3RhcnQgZnJhZyBhdCBsaXZlIGVkZ2UuIG1haW5TdGFydDogJHttYWluU3RhcnR9IGxpdmVTeW5jUG9zaXRpb246ICR7bGl2ZVN5bmNQb3NpdGlvbn0gZnJhZy5zdGFydDogJHsoX2ZyYWcgPSBmcmFnKSA9PSBudWxsID8gdm9pZCAwIDogX2ZyYWcuc3RhcnR9YCk7XG4gICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHN0YXJ0UG9zaXRpb247XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwb3MgPD0gc3RhcnQpIHtcbiAgICAgIC8vIFZvRCBwbGF5bGlzdDogaWYgbG9hZFBvc2l0aW9uIGJlZm9yZSBzdGFydCBvZiBwbGF5bGlzdCwgbG9hZCBmaXJzdCBmcmFnbWVudFxuICAgICAgZnJhZyA9IGZyYWdtZW50c1swXTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBoYXZlbid0IHJ1biBpbnRvIGFueSBzcGVjaWFsIGNhc2VzIGFscmVhZHksIGp1c3QgbG9hZCB0aGUgZnJhZ21lbnQgbW9zdCBjbG9zZWx5IG1hdGNoaW5nIHRoZSByZXF1ZXN0ZWQgcG9zaXRpb25cbiAgICBpZiAoIWZyYWcpIHtcbiAgICAgIGNvbnN0IGVuZCA9IHRoaXMubG9hZGluZ1BhcnRzID8gbGV2ZWxEZXRhaWxzLnBhcnRFbmQgOiBsZXZlbERldGFpbHMuZnJhZ21lbnRFbmQ7XG4gICAgICBmcmFnID0gdGhpcy5nZXRGcmFnbWVudEF0UG9zaXRpb24ocG9zLCBlbmQsIGxldmVsRGV0YWlscyk7XG4gICAgfVxuICAgIGxldCBwcm9ncmFtRnJhZyA9IHRoaXMuZmlsdGVyUmVwbGFjZWRQcmltYXJ5KGZyYWcsIGxldmVsRGV0YWlscyk7XG4gICAgaWYgKCFwcm9ncmFtRnJhZyAmJiBmcmFnKSB7XG4gICAgICBjb25zdCBjdXJTTklkeCA9IGZyYWcuc24gLSBsZXZlbERldGFpbHMuc3RhcnRTTjtcbiAgICAgIHByb2dyYW1GcmFnID0gdGhpcy5maWx0ZXJSZXBsYWNlZFByaW1hcnkoZnJhZ21lbnRzW2N1clNOSWR4ICsgMV0gfHwgbnVsbCwgbGV2ZWxEZXRhaWxzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubWFwVG9Jbml0RnJhZ1doZW5SZXF1aXJlZChwcm9ncmFtRnJhZyk7XG4gIH1cbiAgaXNMb29wTG9hZGluZyhmcmFnLCB0YXJnZXRCdWZmZXJUaW1lKSB7XG4gICAgY29uc3QgdHJhY2tlclN0YXRlID0gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZyk7XG4gICAgcmV0dXJuICh0cmFja2VyU3RhdGUgPT09IEZyYWdtZW50U3RhdGUuT0sgfHwgdHJhY2tlclN0YXRlID09PSBGcmFnbWVudFN0YXRlLlBBUlRJQUwgJiYgISFmcmFnLmdhcCkgJiYgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID4gdGFyZ2V0QnVmZmVyVGltZTtcbiAgfVxuICBnZXROZXh0RnJhZ21lbnRMb29wTG9hZGluZyhmcmFnLCBsZXZlbERldGFpbHMsIGJ1ZmZlckluZm8sIHBsYXlsaXN0VHlwZSwgbWF4QnVmTGVuKSB7XG4gICAgbGV0IG5leHRGcmFnbWVudCA9IG51bGw7XG4gICAgaWYgKGZyYWcuZ2FwKSB7XG4gICAgICBuZXh0RnJhZ21lbnQgPSB0aGlzLmdldE5leHRGcmFnbWVudCh0aGlzLm5leHRMb2FkUG9zaXRpb24sIGxldmVsRGV0YWlscyk7XG4gICAgICBpZiAobmV4dEZyYWdtZW50ICYmICFuZXh0RnJhZ21lbnQuZ2FwICYmIGJ1ZmZlckluZm8ubmV4dFN0YXJ0KSB7XG4gICAgICAgIC8vIE1lZGlhIGJ1ZmZlcmVkIGFmdGVyIEdBUCB0YWdzIHNob3VsZCBub3QgbWFrZSB0aGUgbmV4dCBidWZmZXIgdGltZXJhbmdlIGV4Y2VlZCBmb3J3YXJkIGJ1ZmZlciBsZW5ndGhcbiAgICAgICAgY29uc3QgbmV4dGJ1ZmZlckluZm8gPSB0aGlzLmdldEZ3ZEJ1ZmZlckluZm9BdFBvcyh0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IHRoaXMubWVkaWEsIGJ1ZmZlckluZm8ubmV4dFN0YXJ0LCBwbGF5bGlzdFR5cGUsIDApO1xuICAgICAgICBpZiAobmV4dGJ1ZmZlckluZm8gIT09IG51bGwgJiYgYnVmZmVySW5mby5sZW4gKyBuZXh0YnVmZmVySW5mby5sZW4gPj0gbWF4QnVmTGVuKSB7XG4gICAgICAgICAgLy8gUmV0dXJuaW5nIGhlcmUgbWlnaHQgcmVzdWx0IGluIG5vdCBmaW5kaW5nIGFuIGF1ZGlvIGFuZCB2aWRlbyBjYW5kaWF0ZSB0byBza2lwIHRvXG4gICAgICAgICAgY29uc3Qgc24gPSBuZXh0RnJhZ21lbnQuc247XG4gICAgICAgICAgaWYgKHRoaXMubG9vcFNuICE9PSBzbikge1xuICAgICAgICAgICAgdGhpcy5sb2coYGJ1ZmZlciBmdWxsIGFmdGVyIGdhcHMgaW4gXCIke3BsYXlsaXN0VHlwZX1cIiBwbGF5bGlzdCBzdGFydGluZyBhdCBzbjogJHtzbn1gKTtcbiAgICAgICAgICAgIHRoaXMubG9vcFNuID0gc247XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubG9vcFNuID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBuZXh0RnJhZ21lbnQ7XG4gIH1cbiAgZ2V0IHByaW1hcnlQcmVmZXRjaCgpIHtcbiAgICBpZiAoaW50ZXJzdGl0aWFsc0VuYWJsZWQodGhpcy5obHMuY29uZmlnKSkge1xuICAgICAgdmFyIF90aGlzJGhscyRpbnRlcnN0aXRpYSwgX3RoaXMkaGxzJGludGVyc3RpdGlhMjtcbiAgICAgIGNvbnN0IHBsYXlpbmdJbnRlcnN0aXRpYWwgPSAoX3RoaXMkaGxzJGludGVyc3RpdGlhID0gdGhpcy5obHMuaW50ZXJzdGl0aWFsc01hbmFnZXIpID09IG51bGwgPyB2b2lkIDAgOiAoX3RoaXMkaGxzJGludGVyc3RpdGlhMiA9IF90aGlzJGhscyRpbnRlcnN0aXRpYS5wbGF5aW5nSXRlbSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGhscyRpbnRlcnN0aXRpYTIuZXZlbnQ7XG4gICAgICBpZiAocGxheWluZ0ludGVyc3RpdGlhbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZpbHRlclJlcGxhY2VkUHJpbWFyeShmcmFnLCBkZXRhaWxzKSB7XG4gICAgaWYgKCFmcmFnKSB7XG4gICAgICByZXR1cm4gZnJhZztcbiAgICB9XG4gICAgaWYgKGludGVyc3RpdGlhbHNFbmFibGVkKHRoaXMuaGxzLmNvbmZpZykgJiYgZnJhZy50eXBlICE9PSBQbGF5bGlzdExldmVsVHlwZS5TVUJUSVRMRSkge1xuICAgICAgLy8gRG8gbm90IGxvYWQgZnJhZ21lbnRzIG91dHNpZGUgdGhlIGJ1ZmZlcmluZyBzY2hlZHVsZSBzZWdtZW50XG4gICAgICBjb25zdCBpbnRlcnN0aXRpYWxzID0gdGhpcy5obHMuaW50ZXJzdGl0aWFsc01hbmFnZXI7XG4gICAgICBjb25zdCBidWZmZXJpbmdJdGVtID0gaW50ZXJzdGl0aWFscyA9PSBudWxsID8gdm9pZCAwIDogaW50ZXJzdGl0aWFscy5idWZmZXJpbmdJdGVtO1xuICAgICAgaWYgKGJ1ZmZlcmluZ0l0ZW0pIHtcbiAgICAgICAgY29uc3QgYnVmZmVyaW5nSW50ZXJzdGl0aWFsID0gYnVmZmVyaW5nSXRlbS5ldmVudDtcbiAgICAgICAgaWYgKGJ1ZmZlcmluZ0ludGVyc3RpdGlhbCkge1xuICAgICAgICAgIC8vIERvIG5vdCBzdHJlYW0gZnJhZ21lbnRzIHdoaWxlIGJ1ZmZlcmluZyBJbnRlcnN0aXRpYWwgRXZlbnRzIChleGNlcHQgZm9yIG92ZXJsYXAgYXQgdGhlIHN0YXJ0KVxuICAgICAgICAgIGlmIChidWZmZXJpbmdJbnRlcnN0aXRpYWwuYXBwZW5kSW5QbGFjZSB8fCBNYXRoLmFicyhmcmFnLnN0YXJ0IC0gYnVmZmVyaW5nSXRlbS5zdGFydCkgPiAxIHx8IGJ1ZmZlcmluZ0l0ZW0uc3RhcnQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBMaW1pdCBmcmFnbWVudCBsb2FkaW5nIHRvIG1lZGlhIGluIHNjaGVkdWxlIGl0ZW1cbiAgICAgICAgICBpZiAoZnJhZy5lbmQgPD0gYnVmZmVyaW5nSXRlbS5zdGFydCAmJiAoZGV0YWlscyA9PSBudWxsID8gdm9pZCAwIDogZGV0YWlscy5saXZlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIGZyYWdtZW50IGVuZHMgYnkgc2NoZWR1bGUgaXRlbSBzdGFydFxuICAgICAgICAgICAgLy8gdGhpcy5mcmFnbWVudFRyYWNrZXIuZnJhZ0J1ZmZlcmVkKGZyYWcsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmcmFnLnN0YXJ0ID4gYnVmZmVyaW5nSXRlbS5lbmQgJiYgYnVmZmVyaW5nSXRlbS5uZXh0RXZlbnQpIHtcbiAgICAgICAgICAgIC8vIGZyYWdtZW50IGlzIHBhc3Qgc2NoZWR1bGUgaXRlbSBlbmRcbiAgICAgICAgICAgIC8vIGFsbG93IHNvbWUgb3ZlcmZsb3cgd2hlbiBub3QgYXBwZW5kaW5nIGluIHBsYWNlIHRvIHByZXZlbnQgc3RhbGxzXG4gICAgICAgICAgICBpZiAoYnVmZmVyaW5nSXRlbS5uZXh0RXZlbnQuYXBwZW5kSW5QbGFjZSB8fCBmcmFnLnN0YXJ0IC0gYnVmZmVyaW5nSXRlbS5lbmQgPiAxKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gU2tpcCBsb2FkaW5nIG9mIGZyYWdtZW50cyB0aGF0IG92ZXJsYXAgY29tcGxldGVseSB3aXRoIGFwcGVuZEluUGxhY2UgaW50ZXJzdGl0aWFsc1xuICAgICAgY29uc3QgcGxheWVyUXVldWUgPSBpbnRlcnN0aXRpYWxzID09IG51bGwgPyB2b2lkIDAgOiBpbnRlcnN0aXRpYWxzLnBsYXllclF1ZXVlO1xuICAgICAgaWYgKHBsYXllclF1ZXVlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBwbGF5ZXJRdWV1ZS5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICBjb25zdCBpbnRlcnN0aXRpYWwgPSBwbGF5ZXJRdWV1ZVtpXS5pbnRlcnN0aXRpYWw7XG4gICAgICAgICAgaWYgKGludGVyc3RpdGlhbC5hcHBlbmRJblBsYWNlICYmIGZyYWcuc3RhcnQgPj0gaW50ZXJzdGl0aWFsLnN0YXJ0VGltZSAmJiBmcmFnLmVuZCA8PSBpbnRlcnN0aXRpYWwucmVzdW1lVGltZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcmFnO1xuICB9XG4gIG1hcFRvSW5pdEZyYWdXaGVuUmVxdWlyZWQoZnJhZykge1xuICAgIC8vIElmIGFuIGluaXRTZWdtZW50IGlzIHByZXNlbnQsIGl0IG11c3QgYmUgYnVmZmVyZWQgZmlyc3RcbiAgICBpZiAoZnJhZyAhPSBudWxsICYmIGZyYWcuaW5pdFNlZ21lbnQgJiYgIShmcmFnICE9IG51bGwgJiYgZnJhZy5pbml0U2VnbWVudC5kYXRhKSAmJiAhdGhpcy5iaXRyYXRlVGVzdCkge1xuICAgICAgcmV0dXJuIGZyYWcuaW5pdFNlZ21lbnQ7XG4gICAgfVxuICAgIHJldHVybiBmcmFnO1xuICB9XG4gIGdldE5leHRQYXJ0KHBhcnRMaXN0LCBmcmFnLCB0YXJnZXRCdWZmZXJUaW1lKSB7XG4gICAgbGV0IG5leHRQYXJ0ID0gLTE7XG4gICAgbGV0IGNvbnRpZ3VvdXMgPSBmYWxzZTtcbiAgICBsZXQgaW5kZXBlbmRlbnRBdHRyT21pdHRlZCA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBhcnRMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJ0ID0gcGFydExpc3RbaV07XG4gICAgICBpbmRlcGVuZGVudEF0dHJPbWl0dGVkID0gaW5kZXBlbmRlbnRBdHRyT21pdHRlZCAmJiAhcGFydC5pbmRlcGVuZGVudDtcbiAgICAgIGlmIChuZXh0UGFydCA+IC0xICYmIHRhcmdldEJ1ZmZlclRpbWUgPCBwYXJ0LnN0YXJ0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29uc3QgbG9hZGVkID0gcGFydC5sb2FkZWQ7XG4gICAgICBpZiAobG9hZGVkKSB7XG4gICAgICAgIG5leHRQYXJ0ID0gLTE7XG4gICAgICB9IGVsc2UgaWYgKChjb250aWd1b3VzIHx8IHBhcnQuaW5kZXBlbmRlbnQgfHwgaW5kZXBlbmRlbnRBdHRyT21pdHRlZCkgJiYgcGFydC5mcmFnbWVudCA9PT0gZnJhZykge1xuICAgICAgICBuZXh0UGFydCA9IGk7XG4gICAgICB9XG4gICAgICBjb250aWd1b3VzID0gbG9hZGVkO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dFBhcnQ7XG4gIH1cbiAgbG9hZGVkRW5kT2ZQYXJ0cyhwYXJ0TGlzdCwgdGFyZ2V0QnVmZmVyVGltZSkge1xuICAgIGNvbnN0IGxhc3RQYXJ0ID0gcGFydExpc3RbcGFydExpc3QubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIGxhc3RQYXJ0ICYmIHRhcmdldEJ1ZmZlclRpbWUgPiBsYXN0UGFydC5zdGFydCAmJiBsYXN0UGFydC5sb2FkZWQ7XG4gIH1cblxuICAvKlxuICAgVGhpcyBtZXRob2QgaXMgdXNlZCBmaW5kIHRoZSBiZXN0IG1hdGNoaW5nIGZpcnN0IGZyYWdtZW50IGZvciBhIGxpdmUgcGxheWxpc3QuIFRoaXMgZnJhZ21lbnQgaXMgdXNlZCB0byBjYWxjdWxhdGUgdGhlXG4gICBcInNsaWRpbmdcIiBvZiB0aGUgcGxheWxpc3QsIHdoaWNoIGlzIGl0cyBvZmZzZXQgZnJvbSB0aGUgc3RhcnQgb2YgcGxheWJhY2suIEFmdGVyIHNsaWRpbmcgd2UgY2FuIGNvbXB1dGUgdGhlIHJlYWxcbiAgIHN0YXJ0IGFuZCBlbmQgdGltZXMgZm9yIGVhY2ggZnJhZ21lbnQgaW4gdGhlIHBsYXlsaXN0IChhZnRlciB3aGljaCB0aGlzIG1ldGhvZCB3aWxsIG5vdCBuZWVkIHRvIGJlIGNhbGxlZCkuXG4gICovXG4gIGdldEluaXRpYWxMaXZlRnJhZ21lbnQobGV2ZWxEZXRhaWxzKSB7XG4gICAgY29uc3QgZnJhZ21lbnRzID0gbGV2ZWxEZXRhaWxzLmZyYWdtZW50cztcbiAgICBjb25zdCBmcmFnUHJldmlvdXMgPSB0aGlzLmZyYWdQcmV2aW91cztcbiAgICBsZXQgZnJhZyA9IG51bGw7XG4gICAgaWYgKGZyYWdQcmV2aW91cykge1xuICAgICAgaWYgKGxldmVsRGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICAgICAgLy8gUHJlZmVyIHVzaW5nIFBEVCwgYmVjYXVzZSBpdCBjYW4gYmUgYWNjdXJhdGUgZW5vdWdoIHRvIGNob29zZSB0aGUgY29ycmVjdCBmcmFnbWVudCB3aXRob3V0IGtub3dpbmcgdGhlIGxldmVsIHNsaWRpbmdcbiAgICAgICAgdGhpcy5sb2coYExpdmUgcGxheWxpc3QsIHN3aXRjaGluZyBwbGF5bGlzdCwgbG9hZCBmcmFnIHdpdGggc2FtZSBQRFQ6ICR7ZnJhZ1ByZXZpb3VzLnByb2dyYW1EYXRlVGltZX1gKTtcbiAgICAgICAgZnJhZyA9IGZpbmRGcmFnbWVudEJ5UERUKGZyYWdtZW50cywgZnJhZ1ByZXZpb3VzLmVuZFByb2dyYW1EYXRlVGltZSwgdGhpcy5jb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSk7XG4gICAgICB9XG4gICAgICBpZiAoIWZyYWcpIHtcbiAgICAgICAgLy8gU04gZG9lcyBub3QgbmVlZCB0byBiZSBhY2N1cmF0ZSBiZXR3ZWVuIHJlbmRpdGlvbnMsIGJ1dCBkZXBlbmRpbmcgb24gdGhlIHBhY2thZ2luZyBpdCBtYXkgYmUgc28uXG4gICAgICAgIGNvbnN0IHRhcmdldFNOID0gZnJhZ1ByZXZpb3VzLnNuICsgMTtcbiAgICAgICAgaWYgKHRhcmdldFNOID49IGxldmVsRGV0YWlscy5zdGFydFNOICYmIHRhcmdldFNOIDw9IGxldmVsRGV0YWlscy5lbmRTTikge1xuICAgICAgICAgIGNvbnN0IGZyYWdOZXh0ID0gZnJhZ21lbnRzW3RhcmdldFNOIC0gbGV2ZWxEZXRhaWxzLnN0YXJ0U05dO1xuICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IHdlJ3JlIHN0YXlpbmcgd2l0aGluIHRoZSBjb250aW51aXR5IHJhbmdlLCBzaW5jZSBQVFMgcmVzZXRzIHVwb24gYSBuZXcgcmFuZ2VcbiAgICAgICAgICBpZiAoZnJhZ1ByZXZpb3VzLmNjID09PSBmcmFnTmV4dC5jYykge1xuICAgICAgICAgICAgZnJhZyA9IGZyYWdOZXh0O1xuICAgICAgICAgICAgdGhpcy5sb2coYExpdmUgcGxheWxpc3QsIHN3aXRjaGluZyBwbGF5bGlzdCwgbG9hZCBmcmFnIHdpdGggbmV4dCBTTjogJHtmcmFnLnNufWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJdCdzIGltcG9ydGFudCB0byBzdGF5IHdpdGhpbiB0aGUgY29udGludWl0eSByYW5nZSBpZiBhdmFpbGFibGU7IG90aGVyd2lzZSB0aGUgZnJhZ21lbnRzIGluIHRoZSBwbGF5bGlzdFxuICAgICAgICAvLyB3aWxsIGhhdmUgdGhlIHdyb25nIHN0YXJ0IHRpbWVzXG4gICAgICAgIGlmICghZnJhZykge1xuICAgICAgICAgIGZyYWcgPSBmaW5kTmVhcmVzdFdpdGhDQyhsZXZlbERldGFpbHMsIGZyYWdQcmV2aW91cy5jYywgZnJhZ1ByZXZpb3VzLmVuZCk7XG4gICAgICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKGBMaXZlIHBsYXlsaXN0LCBzd2l0Y2hpbmcgcGxheWxpc3QsIGxvYWQgZnJhZyB3aXRoIHNhbWUgQ0M6ICR7ZnJhZy5zbn1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmluZCBhIG5ldyBzdGFydCBmcmFnbWVudCB3aGVuIGZyYWdQcmV2aW91cyBpcyBudWxsXG4gICAgICBjb25zdCBsaXZlU3RhcnQgPSB0aGlzLmhscy5saXZlU3luY1Bvc2l0aW9uO1xuICAgICAgaWYgKGxpdmVTdGFydCAhPT0gbnVsbCkge1xuICAgICAgICBmcmFnID0gdGhpcy5nZXRGcmFnbWVudEF0UG9zaXRpb24obGl2ZVN0YXJ0LCB0aGlzLmJpdHJhdGVUZXN0ID8gbGV2ZWxEZXRhaWxzLmZyYWdtZW50RW5kIDogbGV2ZWxEZXRhaWxzLmVkZ2UsIGxldmVsRGV0YWlscyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcmFnO1xuICB9XG5cbiAgLypcbiAgVGhpcyBtZXRob2QgZmluZHMgdGhlIGJlc3QgbWF0Y2hpbmcgZnJhZ21lbnQgZ2l2ZW4gdGhlIHByb3ZpZGVkIHBvc2l0aW9uLlxuICAgKi9cbiAgZ2V0RnJhZ21lbnRBdFBvc2l0aW9uKGJ1ZmZlckVuZCwgZW5kLCBsZXZlbERldGFpbHMpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb25maWdcbiAgICB9ID0gdGhpcztcbiAgICBsZXQge1xuICAgICAgZnJhZ1ByZXZpb3VzXG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHtcbiAgICAgIGZyYWdtZW50cyxcbiAgICAgIGVuZFNOXG4gICAgfSA9IGxldmVsRGV0YWlscztcbiAgICBjb25zdCB7XG4gICAgICBmcmFnbWVudEhpbnRcbiAgICB9ID0gbGV2ZWxEZXRhaWxzO1xuICAgIGNvbnN0IHtcbiAgICAgIG1heEZyYWdMb29rVXBUb2xlcmFuY2VcbiAgICB9ID0gY29uZmlnO1xuICAgIGNvbnN0IHBhcnRMaXN0ID0gbGV2ZWxEZXRhaWxzLnBhcnRMaXN0O1xuICAgIGNvbnN0IGxvYWRpbmdQYXJ0cyA9ICEhKHRoaXMubG9hZGluZ1BhcnRzICYmIHBhcnRMaXN0ICE9IG51bGwgJiYgcGFydExpc3QubGVuZ3RoICYmIGZyYWdtZW50SGludCk7XG4gICAgaWYgKGxvYWRpbmdQYXJ0cyAmJiBmcmFnbWVudEhpbnQgJiYgIXRoaXMuYml0cmF0ZVRlc3QgJiYgcGFydExpc3RbcGFydExpc3QubGVuZ3RoIC0gMV0uZnJhZ21lbnQuc24gPT09IGZyYWdtZW50SGludC5zbikge1xuICAgICAgLy8gSW5jbHVkZSBpbmNvbXBsZXRlIGZyYWdtZW50IHdpdGggcGFydHMgYXQgZW5kXG4gICAgICBmcmFnbWVudHMgPSBmcmFnbWVudHMuY29uY2F0KGZyYWdtZW50SGludCk7XG4gICAgICBlbmRTTiA9IGZyYWdtZW50SGludC5zbjtcbiAgICB9XG4gICAgbGV0IGZyYWc7XG4gICAgaWYgKGJ1ZmZlckVuZCA8IGVuZCkge1xuICAgICAgdmFyIF90aGlzJG1lZGlhMztcbiAgICAgIGNvbnN0IGJhY2t3YXJkU2VlayA9IGJ1ZmZlckVuZCA8IHRoaXMubGFzdEN1cnJlbnRUaW1lO1xuICAgICAgY29uc3QgbG9va3VwVG9sZXJhbmNlID0gYmFja3dhcmRTZWVrIHx8IGJ1ZmZlckVuZCA+IGVuZCAtIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgfHwgKF90aGlzJG1lZGlhMyA9IHRoaXMubWVkaWEpICE9IG51bGwgJiYgX3RoaXMkbWVkaWEzLnBhdXNlZCB8fCAhdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPyAwIDogbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTtcbiAgICAgIC8vIFJlbW92ZSB0aGUgdG9sZXJhbmNlIGlmIGl0IHdvdWxkIHB1dCB0aGUgYnVmZmVyRW5kIHBhc3QgdGhlIGFjdHVhbCBlbmQgb2Ygc3RyZWFtXG4gICAgICAvLyBVc2VzIGJ1ZmZlciBhbmQgc2VxdWVuY2UgbnVtYmVyIHRvIGNhbGN1bGF0ZSBzd2l0Y2ggc2VnbWVudCAocmVxdWlyZWQgaWYgdXNpbmcgRVhULVgtRElTQ09OVElOVUlUWS1TRVFVRU5DRSlcbiAgICAgIGZyYWcgPSBmaW5kRnJhZ21lbnRCeVBUUyhmcmFnUHJldmlvdXMsIGZyYWdtZW50cywgYnVmZmVyRW5kLCBsb29rdXBUb2xlcmFuY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZWFjaCBlbmQgb2YgcGxheWxpc3RcbiAgICAgIGZyYWcgPSBmcmFnbWVudHNbZnJhZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBpZiAoZnJhZykge1xuICAgICAgY29uc3QgY3VyU05JZHggPSBmcmFnLnNuIC0gbGV2ZWxEZXRhaWxzLnN0YXJ0U047XG4gICAgICAvLyBNb3ZlIGZyYWdQcmV2aW91cyBmb3J3YXJkIHRvIHN1cHBvcnQgZm9yY2luZyB0aGUgbmV4dCBmcmFnbWVudCB0byBsb2FkXG4gICAgICAvLyB3aGVuIHRoZSBidWZmZXIgY2F0Y2hlcyB1cCB0byBhIHByZXZpb3VzbHkgYnVmZmVyZWQgcmFuZ2UuXG4gICAgICBjb25zdCBmcmFnU3RhdGUgPSB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmcmFnKTtcbiAgICAgIGlmIChmcmFnU3RhdGUgPT09IEZyYWdtZW50U3RhdGUuT0sgfHwgZnJhZ1N0YXRlID09PSBGcmFnbWVudFN0YXRlLlBBUlRJQUwgJiYgZnJhZy5nYXApIHtcbiAgICAgICAgZnJhZ1ByZXZpb3VzID0gZnJhZztcbiAgICAgIH1cbiAgICAgIGlmIChmcmFnUHJldmlvdXMgJiYgZnJhZy5zbiA9PT0gZnJhZ1ByZXZpb3VzLnNuICYmICghbG9hZGluZ1BhcnRzIHx8IHBhcnRMaXN0WzBdLmZyYWdtZW50LnNuID4gZnJhZy5zbiB8fCAhbGV2ZWxEZXRhaWxzLmxpdmUgJiYgIWxvYWRpbmdQYXJ0cykpIHtcbiAgICAgICAgLy8gRm9yY2UgdGhlIG5leHQgZnJhZ21lbnQgdG8gbG9hZCBpZiB0aGUgcHJldmlvdXMgb25lIHdhcyBhbHJlYWR5IHNlbGVjdGVkLiBUaGlzIGNhbiBvY2Nhc2lvbmFsbHkgaGFwcGVuIHdpdGhcbiAgICAgICAgLy8gbm9uLXVuaWZvcm0gZnJhZ21lbnQgZHVyYXRpb25zXG4gICAgICAgIGNvbnN0IHNhbWVMZXZlbCA9IGZyYWdQcmV2aW91cyAmJiBmcmFnLmxldmVsID09PSBmcmFnUHJldmlvdXMubGV2ZWw7XG4gICAgICAgIGlmIChzYW1lTGV2ZWwpIHtcbiAgICAgICAgICBjb25zdCBuZXh0RnJhZyA9IGZyYWdtZW50c1tjdXJTTklkeCArIDFdO1xuICAgICAgICAgIGlmIChmcmFnLnNuIDwgZW5kU04gJiYgdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUobmV4dEZyYWcpICE9PSBGcmFnbWVudFN0YXRlLk9LKSB7XG4gICAgICAgICAgICBmcmFnID0gbmV4dEZyYWc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyYWcgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnJhZztcbiAgfVxuICBhbGlnblBsYXlsaXN0cyhkZXRhaWxzLCBwcmV2aW91c0RldGFpbHMsIHN3aXRjaERldGFpbHMpIHtcbiAgICAvLyBUT0RPOiBJZiBub3QgZm9yIGBzaG91bGRBbGlnbk9uRGlzY29udGludWl0aWVzYCByZXF1aXJpbmcgZnJhZ1ByZXZpb3VzLmNjLFxuICAgIC8vICB0aGlzIGNvdWxkIGFsbCBnbyBpbiBsZXZlbC1oZWxwZXIgbWVyZ2VEZXRhaWxzKClcbiAgICBjb25zdCBsZW5ndGggPSBkZXRhaWxzLmZyYWdtZW50cy5sZW5ndGg7XG4gICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgIHRoaXMud2FybihgTm8gZnJhZ21lbnRzIGluIGxpdmUgcGxheWxpc3RgKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb25zdCBzbGlkaW5nU3RhcnQgPSBkZXRhaWxzLmZyYWdtZW50U3RhcnQ7XG4gICAgY29uc3QgZmlyc3RMZXZlbExvYWQgPSAhcHJldmlvdXNEZXRhaWxzO1xuICAgIGNvbnN0IGFsaWduZWQgPSBkZXRhaWxzLmFsaWduZWRTbGlkaW5nICYmIGlzRmluaXRlTnVtYmVyKHNsaWRpbmdTdGFydCk7XG4gICAgaWYgKGZpcnN0TGV2ZWxMb2FkIHx8ICFhbGlnbmVkICYmICFzbGlkaW5nU3RhcnQpIHtcbiAgICAgIGFsaWduU3RyZWFtKHN3aXRjaERldGFpbHMsIGRldGFpbHMpO1xuICAgICAgY29uc3QgYWxpZ25lZFNsaWRpbmdTdGFydCA9IGRldGFpbHMuZnJhZ21lbnRTdGFydDtcbiAgICAgIHRoaXMubG9nKGBMaXZlIHBsYXlsaXN0IHNsaWRpbmc6ICR7YWxpZ25lZFNsaWRpbmdTdGFydC50b0ZpeGVkKDIpfSBzdGFydC1zbjogJHtwcmV2aW91c0RldGFpbHMgPyBwcmV2aW91c0RldGFpbHMuc3RhcnRTTiA6ICduYSd9LT4ke2RldGFpbHMuc3RhcnRTTn0gZnJhZ21lbnRzOiAke2xlbmd0aH1gKTtcbiAgICAgIHJldHVybiBhbGlnbmVkU2xpZGluZ1N0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gc2xpZGluZ1N0YXJ0O1xuICB9XG4gIHdhaXRGb3JDZG5UdW5lSW4oZGV0YWlscykge1xuICAgIC8vIFdhaXQgZm9yIExvdy1MYXRlbmN5IENETiBUdW5lLWluIHRvIGdldCBhbiB1cGRhdGVkIHBsYXlsaXN0XG4gICAgY29uc3QgYWR2YW5jZVBhcnRMaW1pdCA9IDM7XG4gICAgcmV0dXJuIGRldGFpbHMubGl2ZSAmJiBkZXRhaWxzLmNhbkJsb2NrUmVsb2FkICYmIGRldGFpbHMucGFydFRhcmdldCAmJiBkZXRhaWxzLnR1bmVJbkdvYWwgPiBNYXRoLm1heChkZXRhaWxzLnBhcnRIb2xkQmFjaywgZGV0YWlscy5wYXJ0VGFyZ2V0ICogYWR2YW5jZVBhcnRMaW1pdCk7XG4gIH1cbiAgc2V0U3RhcnRQb3NpdGlvbihkZXRhaWxzLCBzbGlkaW5nKSB7XG4gICAgLy8gY29tcHV0ZSBzdGFydCBwb3NpdGlvbiBpZiBzZXQgdG8gLTEuIHVzZSBpdCBzdHJhaWdodCBhd2F5IGlmIHZhbHVlIGlzIGRlZmluZWRcbiAgICBsZXQgc3RhcnRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICBpZiAoc3RhcnRQb3NpdGlvbiA8IHNsaWRpbmcpIHtcbiAgICAgIHN0YXJ0UG9zaXRpb24gPSAtMTtcbiAgICB9XG4gICAgY29uc3QgdGltZWxpbmVPZmZzZXQgPSB0aGlzLnRpbWVsaW5lT2Zmc2V0O1xuICAgIGlmIChzdGFydFBvc2l0aW9uID09PSAtMSkge1xuICAgICAgLy8gVXNlIFBsYXlsaXN0IEVYVC1YLVNUQVJUOlRJTUUtT0ZGU0VUIHdoZW4gc2V0XG4gICAgICAvLyBQcmlvcml0aXplIE11bHRpdmFyaWFudCBQbGF5bGlzdCBvZmZzZXQgc28gdGhhdCBtYWluLCBhdWRpbywgYW5kIHN1YnRpdGxlIHN0cmVhbS1jb250cm9sbGVyIHN0YXJ0IHRpbWVzIG1hdGNoXG4gICAgICBjb25zdCBvZmZzZXRJbk11bHRpdmFyaWFudFBsYXlsaXN0ID0gdGhpcy5zdGFydFRpbWVPZmZzZXQgIT09IG51bGw7XG4gICAgICBjb25zdCBzdGFydFRpbWVPZmZzZXQgPSBvZmZzZXRJbk11bHRpdmFyaWFudFBsYXlsaXN0ID8gdGhpcy5zdGFydFRpbWVPZmZzZXQgOiBkZXRhaWxzLnN0YXJ0VGltZU9mZnNldDtcbiAgICAgIGlmIChzdGFydFRpbWVPZmZzZXQgIT09IG51bGwgJiYgaXNGaW5pdGVOdW1iZXIoc3RhcnRUaW1lT2Zmc2V0KSkge1xuICAgICAgICBzdGFydFBvc2l0aW9uID0gc2xpZGluZyArIHN0YXJ0VGltZU9mZnNldDtcbiAgICAgICAgaWYgKHN0YXJ0VGltZU9mZnNldCA8IDApIHtcbiAgICAgICAgICBzdGFydFBvc2l0aW9uICs9IGRldGFpbHMuZWRnZTtcbiAgICAgICAgfVxuICAgICAgICBzdGFydFBvc2l0aW9uID0gTWF0aC5taW4oTWF0aC5tYXgoc2xpZGluZywgc3RhcnRQb3NpdGlvbiksIHNsaWRpbmcgKyBkZXRhaWxzLnRvdGFsZHVyYXRpb24pO1xuICAgICAgICB0aGlzLmxvZyhgU2V0dGluZyBzdGFydFBvc2l0aW9uIHRvICR7c3RhcnRQb3NpdGlvbn0gZm9yIHN0YXJ0IHRpbWUgb2Zmc2V0ICR7c3RhcnRUaW1lT2Zmc2V0fSBmb3VuZCBpbiAke29mZnNldEluTXVsdGl2YXJpYW50UGxheWxpc3QgPyAnbXVsdGl2YXJpYW50JyA6ICdtZWRpYSd9IHBsYXlsaXN0YCk7XG4gICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHN0YXJ0UG9zaXRpb247XG4gICAgICB9IGVsc2UgaWYgKGRldGFpbHMubGl2ZSkge1xuICAgICAgICAvLyBMZWF2ZSB0aGlzLnN0YXJ0UG9zaXRpb24gYXQgLTEsIHNvIHRoYXQgd2UgY2FuIHVzZSBgZ2V0SW5pdGlhbExpdmVGcmFnbWVudGAgbG9naWMgd2hlbiBzdGFydFBvc2l0aW9uIGhhc1xuICAgICAgICAvLyBub3QgYmVlbiBzcGVjaWZpZWQgdmlhIHRoZSBjb25maWcgb3IgYW4gYXMgYW4gYXJndW1lbnQgdG8gc3RhcnRMb2FkICgjMzczNikuXG4gICAgICAgIHN0YXJ0UG9zaXRpb24gPSB0aGlzLmhscy5saXZlU3luY1Bvc2l0aW9uIHx8IHNsaWRpbmc7XG4gICAgICAgIHRoaXMubG9nKGBTZXR0aW5nIHN0YXJ0UG9zaXRpb24gdG8gLTEgdG8gc3RhcnQgYXQgbGl2ZSBlZGdlICR7c3RhcnRQb3NpdGlvbn1gKTtcbiAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZyhgc2V0dGluZyBzdGFydFBvc2l0aW9uIHRvIDAgYnkgZGVmYXVsdGApO1xuICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBzdGFydFBvc2l0aW9uID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gc3RhcnRQb3NpdGlvbiArIHRpbWVsaW5lT2Zmc2V0O1xuICAgIH1cbiAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBzdGFydFBvc2l0aW9uICsgdGltZWxpbmVPZmZzZXQ7XG4gIH1cbiAgZ2V0TG9hZFBvc2l0aW9uKCkge1xuICAgIHZhciBfdGhpcyRobHM7XG4gICAgY29uc3Qge1xuICAgICAgbWVkaWFcbiAgICB9ID0gdGhpcztcbiAgICAvLyBpZiB3ZSBoYXZlIG5vdCB5ZXQgbG9hZGVkIGFueSBmcmFnbWVudCwgc3RhcnQgbG9hZGluZyBmcm9tIHN0YXJ0IHBvc2l0aW9uXG4gICAgbGV0IHBvcyA9IDA7XG4gICAgaWYgKChfdGhpcyRobHMgPSB0aGlzLmhscykgIT0gbnVsbCAmJiBfdGhpcyRobHMuaGFzRW5vdWdoVG9TdGFydCAmJiBtZWRpYSkge1xuICAgICAgcG9zID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLm5leHRMb2FkUG9zaXRpb24gPj0gMCkge1xuICAgICAgcG9zID0gdGhpcy5uZXh0TG9hZFBvc2l0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gcG9zO1xuICB9XG4gIGhhbmRsZUZyYWdMb2FkQWJvcnRlZChmcmFnLCBwYXJ0KSB7XG4gICAgaWYgKHRoaXMudHJhbnNtdXhlciAmJiBmcmFnLnR5cGUgPT09IHRoaXMucGxheWxpc3RUeXBlICYmIGlzTWVkaWFGcmFnbWVudChmcmFnKSAmJiBmcmFnLnN0YXRzLmFib3J0ZWQpIHtcbiAgICAgIHRoaXMubG9nKGBGcmFnbWVudCAke2ZyYWcuc259JHtwYXJ0ID8gJyBwYXJ0ICcgKyBwYXJ0LmluZGV4IDogJyd9IG9mICR7dGhpcy5wbGF5bGlzdExhYmVsKCl9ICR7ZnJhZy5sZXZlbH0gd2FzIGFib3J0ZWRgKTtcbiAgICAgIHRoaXMucmVzZXRGcmFnbWVudExvYWRpbmcoZnJhZyk7XG4gICAgfVxuICB9XG4gIHJlc2V0RnJhZ21lbnRMb2FkaW5nKGZyYWcpIHtcbiAgICBpZiAoIXRoaXMuZnJhZ0N1cnJlbnQgfHwgIXRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpICYmIHRoaXMuc3RhdGUgIT09IFN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICB9XG4gIH1cbiAgb25GcmFnbWVudE9yS2V5TG9hZEVycm9yKGZpbHRlclR5cGUsIGRhdGEpIHtcbiAgICBpZiAoZGF0YS5jaHVua01ldGEgJiYgIWRhdGEuZnJhZykge1xuICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ2V0Q3VycmVudENvbnRleHQoZGF0YS5jaHVua01ldGEpO1xuICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgZGF0YS5mcmFnID0gY29udGV4dC5mcmFnO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmcmFnID0gZGF0YS5mcmFnO1xuICAgIC8vIEhhbmRsZSBmcmFnIGVycm9yIHJlbGF0ZWQgdG8gY2FsbGVyJ3MgZmlsdGVyVHlwZVxuICAgIGlmICghZnJhZyB8fCBmcmFnLnR5cGUgIT09IGZpbHRlclR5cGUgfHwgIXRoaXMubGV2ZWxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgdmFyIF90aGlzJGZyYWdDdXJyZW50O1xuICAgICAgdGhpcy53YXJuKGBGcmFnIGxvYWQgZXJyb3IgbXVzdCBtYXRjaCBjdXJyZW50IGZyYWcgdG8gcmV0cnkgJHtmcmFnLnVybH0gPiAkeyhfdGhpcyRmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRmcmFnQ3VycmVudC51cmx9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGdhcFRhZ0VuY291bnRlcmVkID0gZGF0YS5kZXRhaWxzID09PSBFcnJvckRldGFpbHMuRlJBR19HQVA7XG4gICAgaWYgKGdhcFRhZ0VuY291bnRlcmVkKSB7XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5mcmFnQnVmZmVyZWQoZnJhZywgdHJ1ZSk7XG4gICAgfVxuICAgIC8vIGtlZXAgcmV0cnlpbmcgdW50aWwgdGhlIGxpbWl0IHdpbGwgYmUgcmVhY2hlZFxuICAgIGNvbnN0IGVycm9yQWN0aW9uID0gZGF0YS5lcnJvckFjdGlvbjtcbiAgICBjb25zdCB7XG4gICAgICBhY3Rpb24sXG4gICAgICBmbGFncyxcbiAgICAgIHJldHJ5Q291bnQgPSAwLFxuICAgICAgcmV0cnlDb25maWdcbiAgICB9ID0gZXJyb3JBY3Rpb24gfHwge307XG4gICAgY29uc3QgY291bGRSZXRyeSA9ICEhZXJyb3JBY3Rpb24gJiYgISFyZXRyeUNvbmZpZztcbiAgICBjb25zdCByZXRyeSA9IGNvdWxkUmV0cnkgJiYgYWN0aW9uID09PSBOZXR3b3JrRXJyb3JBY3Rpb24uUmV0cnlSZXF1ZXN0O1xuICAgIGNvbnN0IG5vQWx0ZXJuYXRlID0gY291bGRSZXRyeSAmJiAhZXJyb3JBY3Rpb24ucmVzb2x2ZWQgJiYgZmxhZ3MgPT09IEVycm9yQWN0aW9uRmxhZ3MuTW92ZUFsbEFsdGVybmF0ZXNNYXRjaGluZ0hvc3Q7XG4gICAgaWYgKCFyZXRyeSAmJiBub0FsdGVybmF0ZSAmJiBpc01lZGlhRnJhZ21lbnQoZnJhZykgJiYgIWZyYWcuZW5kTGlzdCkge1xuICAgICAgdGhpcy5yZXNldEZyYWdtZW50RXJyb3JzKGZpbHRlclR5cGUpO1xuICAgICAgdGhpcy50cmVhdEFzR2FwKGZyYWcpO1xuICAgICAgZXJyb3JBY3Rpb24ucmVzb2x2ZWQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoKHJldHJ5IHx8IG5vQWx0ZXJuYXRlKSAmJiByZXRyeUNvdW50IDwgcmV0cnlDb25maWcubWF4TnVtUmV0cnkpIHtcbiAgICAgIHRoaXMucmVzZXRTdGFydFdoZW5Ob3RMb2FkZWQodGhpcy5sZXZlbExhc3RMb2FkZWQpO1xuICAgICAgY29uc3QgZGVsYXkgPSBnZXRSZXRyeURlbGF5KHJldHJ5Q29uZmlnLCByZXRyeUNvdW50KTtcbiAgICAgIHRoaXMud2FybihgRnJhZ21lbnQgJHtmcmFnLnNufSBvZiAke2ZpbHRlclR5cGV9ICR7ZnJhZy5sZXZlbH0gZXJyb3JlZCB3aXRoICR7ZGF0YS5kZXRhaWxzfSwgcmV0cnlpbmcgbG9hZGluZyAke3JldHJ5Q291bnQgKyAxfS8ke3JldHJ5Q29uZmlnLm1heE51bVJldHJ5fSBpbiAke2RlbGF5fW1zYCk7XG4gICAgICBlcnJvckFjdGlvbi5yZXNvbHZlZCA9IHRydWU7XG4gICAgICB0aGlzLnJldHJ5RGF0ZSA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCkgKyBkZWxheTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTtcbiAgICB9IGVsc2UgaWYgKHJldHJ5Q29uZmlnICYmIGVycm9yQWN0aW9uKSB7XG4gICAgICB0aGlzLnJlc2V0RnJhZ21lbnRFcnJvcnMoZmlsdGVyVHlwZSk7XG4gICAgICBpZiAocmV0cnlDb3VudCA8IHJldHJ5Q29uZmlnLm1heE51bVJldHJ5KSB7XG4gICAgICAgIC8vIE5ldHdvcmsgcmV0cnkgaXMgc2tpcHBlZCB3aGVuIGxldmVsIHN3aXRjaCBpcyBwcmVmZXJyZWRcbiAgICAgICAgaWYgKCFnYXBUYWdFbmNvdW50ZXJlZCAmJiBhY3Rpb24gIT09IE5ldHdvcmtFcnJvckFjdGlvbi5SZW1vdmVBbHRlcm5hdGVQZXJtYW5lbnRseSkge1xuICAgICAgICAgIGVycm9yQWN0aW9uLnJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy53YXJuKGAke2RhdGEuZGV0YWlsc30gcmVhY2hlZCBvciBleGNlZWRlZCBtYXggcmV0cnkgKCR7cmV0cnlDb3VudH0pYCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFjdGlvbiA9PT0gTmV0d29ya0Vycm9yQWN0aW9uLlNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3gpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5XQUlUSU5HX0xFVkVMO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRVJST1I7XG4gICAgfVxuICAgIC8vIFBlcmZvcm0gbmV4dCBhc3luYyB0aWNrIHNvb25lciB0byBzcGVlZCB1cCBlcnJvciBhY3Rpb24gcmVzb2x1dGlvblxuICAgIHRoaXMudGlja0ltbWVkaWF0ZSgpO1xuICB9XG4gIHJlZHVjZUxlbmd0aEFuZEZsdXNoQnVmZmVyKGRhdGEpIHtcbiAgICAvLyBpZiBpbiBhcHBlbmRpbmcgc3RhdGVcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORyB8fCB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTRUQpIHtcbiAgICAgIGNvbnN0IGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgICBjb25zdCBwbGF5bGlzdFR5cGUgPSBkYXRhLnBhcmVudDtcbiAgICAgIGNvbnN0IGJ1ZmZlcmVkSW5mbyA9IHRoaXMuZ2V0RndkQnVmZmVySW5mbyh0aGlzLm1lZGlhQnVmZmVyLCBwbGF5bGlzdFR5cGUpO1xuICAgICAgLy8gMC41IDogdG9sZXJhbmNlIG5lZWRlZCBhcyBzb21lIGJyb3dzZXJzIHN0YWxscyBwbGF5YmFjayBiZWZvcmUgcmVhY2hpbmcgYnVmZmVyZWQgZW5kXG4gICAgICAvLyByZWR1Y2UgbWF4IGJ1ZiBsZW4gaWYgY3VycmVudCBwb3NpdGlvbiBpcyBidWZmZXJlZFxuICAgICAgY29uc3QgYnVmZmVyZWQgPSBidWZmZXJlZEluZm8gJiYgYnVmZmVyZWRJbmZvLmxlbiA+IDAuNTtcbiAgICAgIGlmIChidWZmZXJlZCkge1xuICAgICAgICB0aGlzLnJlZHVjZU1heEJ1ZmZlckxlbmd0aChidWZmZXJlZEluZm8ubGVuLCAoZnJhZyA9PSBudWxsID8gdm9pZCAwIDogZnJhZy5kdXJhdGlvbikgfHwgMTApO1xuICAgICAgfVxuICAgICAgY29uc3QgZmx1c2hCdWZmZXIgPSAhYnVmZmVyZWQ7XG4gICAgICBpZiAoZmx1c2hCdWZmZXIpIHtcbiAgICAgICAgLy8gY3VycmVudCBwb3NpdGlvbiBpcyBub3QgYnVmZmVyZWQsIGJ1dCBicm93c2VyIGlzIHN0aWxsIGNvbXBsYWluaW5nIGFib3V0IGJ1ZmZlciBmdWxsIGVycm9yXG4gICAgICAgIC8vIHRoaXMgaGFwcGVucyBvbiBJRS9FZGdlLCByZWZlciB0byBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9wdWxsLzcwOFxuICAgICAgICAvLyBpbiB0aGF0IGNhc2UgZmx1c2ggdGhlIHdob2xlIGF1ZGlvIGJ1ZmZlciB0byByZWNvdmVyXG4gICAgICAgIHRoaXMud2FybihgQnVmZmVyIGZ1bGwgZXJyb3Igd2hpbGUgbWVkaWEuY3VycmVudFRpbWUgaXMgbm90IGJ1ZmZlcmVkLCBmbHVzaCAke3BsYXlsaXN0VHlwZX0gYnVmZmVyYCk7XG4gICAgICB9XG4gICAgICBpZiAoZnJhZykge1xuICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gZnJhZy5zdGFydDtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICAgIHJldHVybiBmbHVzaEJ1ZmZlcjtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJlc2V0RnJhZ21lbnRFcnJvcnMoZmlsdGVyVHlwZSkge1xuICAgIGlmIChmaWx0ZXJUeXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5BVURJTykge1xuICAgICAgLy8gUmVzZXQgY3VycmVudCBmcmFnbWVudCBzaW5jZSBhdWRpbyB0cmFjayBhdWRpbyBpcyBlc3NlbnRpYWwgYW5kIG1heSBub3QgaGF2ZSBhIGZhaWwtb3ZlciB0cmFja1xuICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgfVxuICAgIC8vIEZyYWdtZW50IGVycm9ycyB0aGF0IHJlc3VsdCBpbiBhIGxldmVsIHN3aXRjaCBvciByZWR1bmRhbnQgZmFpbC1vdmVyXG4gICAgLy8gc2hvdWxkIHJlc2V0IHRoZSBzdHJlYW0gY29udHJvbGxlciBzdGF0ZSB0byBpZGxlXG4gICAgaWYgKCF0aGlzLmhscy5oYXNFbm91Z2hUb1N0YXJ0KSB7XG4gICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU3RhdGUuU1RPUFBFRCkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgfVxuICB9XG4gIGFmdGVyQnVmZmVyRmx1c2hlZChtZWRpYSwgYnVmZmVyVHlwZSwgcGxheWxpc3RUeXBlKSB7XG4gICAgaWYgKCFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBBZnRlciBzdWNjZXNzZnVsIGJ1ZmZlciBmbHVzaGluZywgZmlsdGVyIGZsdXNoZWQgZnJhZ21lbnRzIGZyb20gYnVmZmVyZWRGcmFncyB1c2UgbWVkaWFCdWZmZXJlZCBpbnN0ZWFkIG9mIG1lZGlhXG4gICAgLy8gKHNvIHRoYXQgd2Ugd2lsbCBjaGVjayBhZ2FpbnN0IHZpZGVvLmJ1ZmZlcmVkIHJhbmdlcyBpbiBjYXNlIG9mIGFsdCBhdWRpbyB0cmFjaylcbiAgICBjb25zdCBidWZmZXJlZFRpbWVSYW5nZXMgPSBCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQobWVkaWEpO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLmRldGVjdEV2aWN0ZWRGcmFnbWVudHMoYnVmZmVyVHlwZSwgYnVmZmVyZWRUaW1lUmFuZ2VzLCBwbGF5bGlzdFR5cGUpO1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5FTkRFRCkge1xuICAgICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICAgIH1cbiAgfVxuICByZXNldExvYWRpbmdTdGF0ZSgpIHtcbiAgICB0aGlzLmxvZygnUmVzZXQgbG9hZGluZyBzdGF0ZScpO1xuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU3RhdGUuU1RPUFBFRCkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgfVxuICB9XG4gIHJlc2V0U3RhcnRXaGVuTm90TG9hZGVkKGxldmVsKSB7XG4gICAgLy8gaWYgbG9hZGVkbWV0YWRhdGEgaXMgbm90IHNldCwgaXQgbWVhbnMgdGhhdCBmaXJzdCBmcmFnIHJlcXVlc3QgZmFpbGVkXG4gICAgLy8gaW4gdGhhdCBjYXNlLCByZXNldCBzdGFydEZyYWdSZXF1ZXN0ZWQgZmxhZ1xuICAgIGlmICghdGhpcy5obHMuaGFzRW5vdWdoVG9TdGFydCkge1xuICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGRldGFpbHMgPSBsZXZlbCA/IGxldmVsLmRldGFpbHMgOiBudWxsO1xuICAgICAgaWYgKGRldGFpbHMgIT0gbnVsbCAmJiBkZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBzdGFydCBwb3NpdGlvbiBhbmQgcmV0dXJuIHRvIElETEUgdG8gcmVjb3ZlciBsaXZlIHN0YXJ0XG4gICAgICAgIHRoaXMubG9nKGByZXNldHRpbmcgc3RhcnRQb3NpdGlvbiBmb3IgbGl2ZSBzdGFydGApO1xuICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSAtMTtcbiAgICAgICAgdGhpcy5zZXRTdGFydFBvc2l0aW9uKGRldGFpbHMsIGRldGFpbHMuZnJhZ21lbnRTdGFydCk7XG4gICAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVzZXRXaGVuTWlzc2luZ0NvbnRleHQoY2h1bmtNZXRhKSB7XG4gICAgdGhpcy53YXJuKGBUaGUgbG9hZGluZyBjb250ZXh0IGNoYW5nZWQgd2hpbGUgYnVmZmVyaW5nIGZyYWdtZW50ICR7Y2h1bmtNZXRhLnNufSBvZiAke3RoaXMucGxheWxpc3RMYWJlbCgpfSAke2NodW5rTWV0YS5sZXZlbH0uIFRoaXMgY2h1bmsgd2lsbCBub3QgYmUgYnVmZmVyZWQuYCk7XG4gICAgdGhpcy5yZW1vdmVVbmJ1ZmZlcmVkRnJhZ3MoKTtcbiAgICB0aGlzLnJlc2V0U3RhcnRXaGVuTm90TG9hZGVkKHRoaXMubGV2ZWxMYXN0TG9hZGVkKTtcbiAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gIH1cbiAgcmVtb3ZlVW5idWZmZXJlZEZyYWdzKHN0YXJ0ID0gMCkge1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50c0luUmFuZ2Uoc3RhcnQsIEluZmluaXR5LCB0aGlzLnBsYXlsaXN0VHlwZSwgZmFsc2UsIHRydWUpO1xuICB9XG4gIHVwZGF0ZUxldmVsVGltaW5nKGZyYWcsIHBhcnQsIGxldmVsLCBwYXJ0aWFsKSB7XG4gICAgY29uc3QgZGV0YWlscyA9IGxldmVsLmRldGFpbHM7XG4gICAgaWYgKCFkZXRhaWxzKSB7XG4gICAgICB0aGlzLndhcm4oJ2xldmVsLmRldGFpbHMgdW5kZWZpbmVkJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZCA9IE9iamVjdC5rZXlzKGZyYWcuZWxlbWVudGFyeVN0cmVhbXMpLnJlZHVjZSgocmVzdWx0LCB0eXBlKSA9PiB7XG4gICAgICBjb25zdCBpbmZvID0gZnJhZy5lbGVtZW50YXJ5U3RyZWFtc1t0eXBlXTtcbiAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZER1cmF0aW9uID0gaW5mby5lbmRQVFMgLSBpbmZvLnN0YXJ0UFRTO1xuICAgICAgICBpZiAocGFyc2VkRHVyYXRpb24gPD0gMCkge1xuICAgICAgICAgIC8vIERlc3Ryb3kgdGhlIHRyYW5zbXV4ZXIgYWZ0ZXIgaXQncyBuZXh0IHRpbWUgb2Zmc2V0IGZhaWxlZCB0byBhZHZhbmNlIGJlY2F1c2UgZHVyYXRpb24gd2FzIDw9IDAuXG4gICAgICAgICAgLy8gVGhlIG5ldyB0cmFuc211eGVyIHdpbGwgYmUgY29uZmlndXJlZCB3aXRoIGEgdGltZSBvZmZzZXQgbWF0Y2hpbmcgdGhlIG5leHQgZnJhZ21lbnQgc3RhcnQsXG4gICAgICAgICAgLy8gcHJldmVudGluZyB0aGUgdGltZWxpbmUgZnJvbSBzaGlmdGluZy5cbiAgICAgICAgICB0aGlzLndhcm4oYENvdWxkIG5vdCBwYXJzZSBmcmFnbWVudCAke2ZyYWcuc259ICR7dHlwZX0gZHVyYXRpb24gcmVsaWFibHkgKCR7cGFyc2VkRHVyYXRpb259KWApO1xuICAgICAgICAgIHJldHVybiByZXN1bHQgfHwgZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZHJpZnQgPSBwYXJ0aWFsID8gMCA6IHVwZGF0ZUZyYWdQVFNEVFMoZGV0YWlscywgZnJhZywgaW5mby5zdGFydFBUUywgaW5mby5lbmRQVFMsIGluZm8uc3RhcnREVFMsIGluZm8uZW5kRFRTKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTEVWRUxfUFRTX1VQREFURUQsIHtcbiAgICAgICAgICBkZXRhaWxzLFxuICAgICAgICAgIGxldmVsLFxuICAgICAgICAgIGRyaWZ0LFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgZnJhZyxcbiAgICAgICAgICBzdGFydDogaW5mby5zdGFydFBUUyxcbiAgICAgICAgICBlbmQ6IGluZm8uZW5kUFRTXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgZmFsc2UpO1xuICAgIGlmICghcGFyc2VkKSB7XG4gICAgICB2YXIgX3RoaXMkdHJhbnNtdXhlcjtcbiAgICAgIGlmIChsZXZlbC5mcmFnbWVudEVycm9yID09PSAwKSB7XG4gICAgICAgIC8vIE1hcmsgYW5kIHRyYWNrIHRoZSBvZGQgZW1wdHkgc2VnbWVudCBhcyBhIGdhcCB0byBhdm9pZCByZWxvYWRpbmdcbiAgICAgICAgdGhpcy50cmVhdEFzR2FwKGZyYWcsIGxldmVsKTtcbiAgICAgIH1cbiAgICAgIGlmICgoKF90aGlzJHRyYW5zbXV4ZXIgPSB0aGlzLnRyYW5zbXV4ZXIpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyR0cmFuc211eGVyLmVycm9yKSA9PT0gbnVsbCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgRm91bmQgbm8gbWVkaWEgaW4gZnJhZ21lbnQgJHtmcmFnLnNufSBvZiAke3RoaXMucGxheWxpc3RMYWJlbCgpfSAke2ZyYWcubGV2ZWx9IHJlc2V0dGluZyB0cmFuc211eGVyIHRvIGZhbGxiYWNrIHRvIHBsYXlsaXN0IHRpbWluZ2ApO1xuICAgICAgICB0aGlzLndhcm4oZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLFxuICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICBmcmFnLFxuICAgICAgICAgIHJlYXNvbjogYEZvdW5kIG5vIG1lZGlhIGluIG1zbiAke2ZyYWcuc259IG9mICR7dGhpcy5wbGF5bGlzdExhYmVsKCl9IFwiJHtsZXZlbC51cmx9XCJgXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXRoaXMuaGxzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzZXRUcmFuc211eGVyKCk7XG4gICAgICB9XG4gICAgICAvLyBGb3IgdGhpcyBlcnJvciBmYWxsdGhyb3VnaC4gTWFya2luZyBwYXJzZWQgd2lsbCBhbGxvdyBhZHZhbmNpbmcgdG8gbmV4dCBmcmFnbWVudC5cbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBUlNFRDtcbiAgICB0aGlzLmxvZyhgUGFyc2VkICR7ZnJhZy50eXBlfSBzbjogJHtmcmFnLnNufSR7cGFydCA/ICcgcGFydDogJyArIHBhcnQuaW5kZXggOiAnJ30gb2YgJHt0aGlzLmZyYWdJbmZvKGZyYWcsIGZhbHNlLCBwYXJ0KX0pYCk7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRlJBR19QQVJTRUQsIHtcbiAgICAgIGZyYWcsXG4gICAgICBwYXJ0XG4gICAgfSk7XG4gIH1cbiAgcGxheWxpc3RMYWJlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5wbGF5bGlzdFR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4gPyAnbGV2ZWwnIDogJ3RyYWNrJztcbiAgfVxuICBmcmFnSW5mbyhmcmFnLCBwdHMgPSB0cnVlLCBwYXJ0KSB7XG4gICAgdmFyIF9yZWYsIF9yZWYyO1xuICAgIHJldHVybiBgJHt0aGlzLnBsYXlsaXN0TGFiZWwoKX0gJHtmcmFnLmxldmVsfSAoJHtwYXJ0ID8gJ3BhcnQnIDogJ2ZyYWcnfTpbJHsoKF9yZWYgPSBwdHMgJiYgIXBhcnQgPyBmcmFnLnN0YXJ0UFRTIDogKHBhcnQgfHwgZnJhZykuc3RhcnQpICE9IG51bGwgPyBfcmVmIDogTmFOKS50b0ZpeGVkKDMpfS0keygoX3JlZjIgPSBwdHMgJiYgIXBhcnQgPyBmcmFnLmVuZFBUUyA6IChwYXJ0IHx8IGZyYWcpLmVuZCkgIT0gbnVsbCA/IF9yZWYyIDogTmFOKS50b0ZpeGVkKDMpfV0ke3BhcnQgJiYgZnJhZy50eXBlID09PSAnbWFpbicgPyAnSU5ERVBFTkRFTlQ9JyArIChwYXJ0LmluZGVwZW5kZW50ID8gJ1lFUycgOiAnTk8nKSA6ICcnfWA7XG4gIH1cbiAgdHJlYXRBc0dhcChmcmFnLCBsZXZlbCkge1xuICAgIGlmIChsZXZlbCkge1xuICAgICAgbGV2ZWwuZnJhZ21lbnRFcnJvcisrO1xuICAgIH1cbiAgICBmcmFnLmdhcCA9IHRydWU7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIuZnJhZ0J1ZmZlcmVkKGZyYWcsIHRydWUpO1xuICB9XG4gIHJlc2V0VHJhbnNtdXhlcigpIHtcbiAgICB2YXIgX3RoaXMkdHJhbnNtdXhlcjI7XG4gICAgKF90aGlzJHRyYW5zbXV4ZXIyID0gdGhpcy50cmFuc211eGVyKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkdHJhbnNtdXhlcjIucmVzZXQoKTtcbiAgfVxuICByZWNvdmVyV29ya2VyRXJyb3IoZGF0YSkge1xuICAgIGlmIChkYXRhLmV2ZW50ID09PSAnZGVtdXhlcldvcmtlcicpIHtcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUFsbEZyYWdtZW50cygpO1xuICAgICAgaWYgKHRoaXMudHJhbnNtdXhlcikge1xuICAgICAgICB0aGlzLnRyYW5zbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnRyYW5zbXV4ZXIgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXNldFN0YXJ0V2hlbk5vdExvYWRlZCh0aGlzLmxldmVsTGFzdExvYWRlZCk7XG4gICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgfVxuICB9XG4gIHNldCBzdGF0ZShuZXh0U3RhdGUpIHtcbiAgICBjb25zdCBwcmV2aW91c1N0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgaWYgKHByZXZpb3VzU3RhdGUgIT09IG5leHRTdGF0ZSkge1xuICAgICAgdGhpcy5fc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICB0aGlzLmxvZyhgJHtwcmV2aW91c1N0YXRlfS0+JHtuZXh0U3RhdGV9YCk7XG4gICAgfVxuICB9XG4gIGdldCBzdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gIH1cbn1cbmZ1bmN0aW9uIGludGVyc3RpdGlhbHNFbmFibGVkKGNvbmZpZykge1xuICByZXR1cm4gISFjb25maWcuaW50ZXJzdGl0aWFsc0NvbnRyb2xsZXIgJiYgY29uZmlnLmVuYWJsZUludGVyc3RpdGlhbFBsYXliYWNrICE9PSBmYWxzZTtcbn1cblxuY2xhc3MgQ2h1bmtDYWNoZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgdGhpcy5kYXRhTGVuZ3RoID0gMDtcbiAgfVxuICBwdXNoKGNodW5rKSB7XG4gICAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG4gICAgdGhpcy5kYXRhTGVuZ3RoICs9IGNodW5rLmxlbmd0aDtcbiAgfVxuICBmbHVzaCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBjaHVua3MsXG4gICAgICBkYXRhTGVuZ3RoXG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAoIWNodW5rcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgICB9IGVsc2UgaWYgKGNodW5rcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJlc3VsdCA9IGNodW5rc1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gY29uY2F0VWludDhBcnJheXMoY2h1bmtzLCBkYXRhTGVuZ3RoKTtcbiAgICB9XG4gICAgdGhpcy5yZXNldCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5jaHVua3MubGVuZ3RoID0gMDtcbiAgICB0aGlzLmRhdGFMZW5ndGggPSAwO1xuICB9XG59XG5mdW5jdGlvbiBjb25jYXRVaW50OEFycmF5cyhjaHVua3MsIGRhdGFMZW5ndGgpIHtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YUxlbmd0aCk7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNodW5rcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNodW5rID0gY2h1bmtzW2ldO1xuICAgIHJlc3VsdC5zZXQoY2h1bmssIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IGNodW5rLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgZXZlbnRlbWl0dGVyMyA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBoYXNSZXF1aXJlZEV2ZW50ZW1pdHRlcjM7XG5cbmZ1bmN0aW9uIHJlcXVpcmVFdmVudGVtaXR0ZXIzICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkRXZlbnRlbWl0dGVyMykgcmV0dXJuIGV2ZW50ZW1pdHRlcjMuZXhwb3J0cztcblx0aGFzUmVxdWlyZWRFdmVudGVtaXR0ZXIzID0gMTtcblx0KGZ1bmN0aW9uIChtb2R1bGUpIHtcblxuXHRcdHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG5cdFx0ICAsIHByZWZpeCA9ICd+JztcblxuXHRcdC8qKlxuXHRcdCAqIENvbnN0cnVjdG9yIHRvIGNyZWF0ZSBhIHN0b3JhZ2UgZm9yIG91ciBgRUVgIG9iamVjdHMuXG5cdFx0ICogQW4gYEV2ZW50c2AgaW5zdGFuY2UgaXMgYSBwbGFpbiBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyBhcmUgZXZlbnQgbmFtZXMuXG5cdFx0ICpcblx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIEV2ZW50cygpIHt9XG5cblx0XHQvL1xuXHRcdC8vIFdlIHRyeSB0byBub3QgaW5oZXJpdCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC4gSW4gc29tZSBlbmdpbmVzIGNyZWF0aW5nIGFuXG5cdFx0Ly8gaW5zdGFuY2UgaW4gdGhpcyB3YXkgaXMgZmFzdGVyIHRoYW4gY2FsbGluZyBgT2JqZWN0LmNyZWF0ZShudWxsKWAgZGlyZWN0bHkuXG5cdFx0Ly8gSWYgYE9iamVjdC5jcmVhdGUobnVsbClgIGlzIG5vdCBzdXBwb3J0ZWQgd2UgcHJlZml4IHRoZSBldmVudCBuYW1lcyB3aXRoIGFcblx0XHQvLyBjaGFyYWN0ZXIgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGJ1aWx0LWluIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3Rcblx0XHQvLyBvdmVycmlkZGVuIG9yIHVzZWQgYXMgYW4gYXR0YWNrIHZlY3Rvci5cblx0XHQvL1xuXHRcdGlmIChPYmplY3QuY3JlYXRlKSB7XG5cdFx0ICBFdmVudHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuXHRcdCAgLy9cblx0XHQgIC8vIFRoaXMgaGFjayBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgYF9fcHJvdG9fX2AgcHJvcGVydHkgaXMgc3RpbGwgaW5oZXJpdGVkIGluXG5cdFx0ICAvLyBzb21lIG9sZCBicm93c2VycyBsaWtlIEFuZHJvaWQgNCwgaVBob25lIDUuMSwgT3BlcmEgMTEgYW5kIFNhZmFyaSA1LlxuXHRcdCAgLy9cblx0XHQgIGlmICghbmV3IEV2ZW50cygpLl9fcHJvdG9fXykgcHJlZml4ID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogUmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG5cdFx0ICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtvbmNlPWZhbHNlXSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuXHRcdCAqIEBjb25zdHJ1Y3RvclxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gRUUoZm4sIGNvbnRleHQsIG9uY2UpIHtcblx0XHQgIHRoaXMuZm4gPSBmbjtcblx0XHQgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG5cdFx0ICB0aGlzLm9uY2UgPSBvbmNlIHx8IGZhbHNlO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cblx0XHQgKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuXHRcdCAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBvbmNlIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG5cdFx0ICogQHJldHVybnMge0V2ZW50RW1pdHRlcn1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGFkZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuXHRcdCAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdCAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cdFx0ICB9XG5cblx0XHQgIHZhciBsaXN0ZW5lciA9IG5ldyBFRShmbiwgY29udGV4dCB8fCBlbWl0dGVyLCBvbmNlKVxuXHRcdCAgICAsIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cblx0XHQgIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0pIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gbGlzdGVuZXIsIGVtaXR0ZXIuX2V2ZW50c0NvdW50Kys7XG5cdFx0ICBlbHNlIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0uZm4pIGVtaXR0ZXIuX2V2ZW50c1tldnRdLnB1c2gobGlzdGVuZXIpO1xuXHRcdCAgZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IFtlbWl0dGVyLl9ldmVudHNbZXZ0XSwgbGlzdGVuZXJdO1xuXG5cdFx0ICByZXR1cm4gZW1pdHRlcjtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBDbGVhciBldmVudCBieSBuYW1lLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cblx0XHQgKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZ0IFRoZSBFdmVudCBuYW1lLlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gY2xlYXJFdmVudChlbWl0dGVyLCBldnQpIHtcblx0XHQgIGlmICgtLWVtaXR0ZXIuX2V2ZW50c0NvdW50ID09PSAwKSBlbWl0dGVyLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG5cdFx0ICBlbHNlIGRlbGV0ZSBlbWl0dGVyLl9ldmVudHNbZXZ0XTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBNaW5pbWFsIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZSB0aGF0IGlzIG1vbGRlZCBhZ2FpbnN0IHRoZSBOb2RlLmpzXG5cdFx0ICogYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlLlxuXHRcdCAqXG5cdFx0ICogQGNvbnN0cnVjdG9yXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcblx0XHQgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcblx0XHQgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm4gYW4gYXJyYXkgbGlzdGluZyB0aGUgZXZlbnRzIGZvciB3aGljaCB0aGUgZW1pdHRlciBoYXMgcmVnaXN0ZXJlZFxuXHRcdCAqIGxpc3RlbmVycy5cblx0XHQgKlxuXHRcdCAqIEByZXR1cm5zIHtBcnJheX1cblx0XHQgKiBAcHVibGljXG5cdFx0ICovXG5cdFx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcblx0XHQgIHZhciBuYW1lcyA9IFtdXG5cdFx0ICAgICwgZXZlbnRzXG5cdFx0ICAgICwgbmFtZTtcblxuXHRcdCAgaWYgKHRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSByZXR1cm4gbmFtZXM7XG5cblx0XHQgIGZvciAobmFtZSBpbiAoZXZlbnRzID0gdGhpcy5fZXZlbnRzKSkge1xuXHRcdCAgICBpZiAoaGFzLmNhbGwoZXZlbnRzLCBuYW1lKSkgbmFtZXMucHVzaChwcmVmaXggPyBuYW1lLnNsaWNlKDEpIDogbmFtZSk7XG5cdFx0ICB9XG5cblx0XHQgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0ICAgIHJldHVybiBuYW1lcy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhldmVudHMpKTtcblx0XHQgIH1cblxuXHRcdCAgcmV0dXJuIG5hbWVzO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm4gdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuXHRcdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHJlZ2lzdGVyZWQgbGlzdGVuZXJzLlxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKi9cblx0XHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhldmVudCkge1xuXHRcdCAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcblx0XHQgICAgLCBoYW5kbGVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG5cdFx0ICBpZiAoIWhhbmRsZXJzKSByZXR1cm4gW107XG5cdFx0ICBpZiAoaGFuZGxlcnMuZm4pIHJldHVybiBbaGFuZGxlcnMuZm5dO1xuXG5cdFx0ICBmb3IgKHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aCwgZWUgPSBuZXcgQXJyYXkobCk7IGkgPCBsOyBpKyspIHtcblx0XHQgICAgZWVbaV0gPSBoYW5kbGVyc1tpXS5mbjtcblx0XHQgIH1cblxuXHRcdCAgcmV0dXJuIGVlO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm4gdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgbGlzdGVuaW5nIHRvIGEgZ2l2ZW4gZXZlbnQuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG5cdFx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWJlciBvZiBsaXN0ZW5lcnMuXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqL1xuXHRcdEV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcblx0XHQgIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG5cdFx0ICAgICwgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cblx0XHQgIGlmICghbGlzdGVuZXJzKSByZXR1cm4gMDtcblx0XHQgIGlmIChsaXN0ZW5lcnMuZm4pIHJldHVybiAxO1xuXHRcdCAgcmV0dXJuIGxpc3RlbmVycy5sZW5ndGg7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIENhbGxzIGVhY2ggb2YgdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuXHRcdCAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGhhZCBsaXN0ZW5lcnMsIGVsc2UgYGZhbHNlYC5cblx0XHQgKiBAcHVibGljXG5cdFx0ICovXG5cdFx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChldmVudCwgYTEsIGEyLCBhMywgYTQsIGE1KSB7XG5cdFx0ICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuXHRcdCAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0ICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF1cblx0XHQgICAgLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoXG5cdFx0ICAgICwgYXJnc1xuXHRcdCAgICAsIGk7XG5cblx0XHQgIGlmIChsaXN0ZW5lcnMuZm4pIHtcblx0XHQgICAgaWYgKGxpc3RlbmVycy5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnMuZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cblx0XHQgICAgc3dpdGNoIChsZW4pIHtcblx0XHQgICAgICBjYXNlIDE6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCksIHRydWU7XG5cdFx0ICAgICAgY2FzZSAyOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExKSwgdHJ1ZTtcblx0XHQgICAgICBjYXNlIDM6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyKSwgdHJ1ZTtcblx0XHQgICAgICBjYXNlIDQ6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMyksIHRydWU7XG5cdFx0ICAgICAgY2FzZSA1OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0KSwgdHJ1ZTtcblx0XHQgICAgICBjYXNlIDY6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQsIGE1KSwgdHJ1ZTtcblx0XHQgICAgfVxuXG5cdFx0ICAgIGZvciAoaSA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0ICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cdFx0ICAgIH1cblxuXHRcdCAgICBsaXN0ZW5lcnMuZm4uYXBwbHkobGlzdGVuZXJzLmNvbnRleHQsIGFyZ3MpO1xuXHRcdCAgfSBlbHNlIHtcblx0XHQgICAgdmFyIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGhcblx0XHQgICAgICAsIGo7XG5cblx0XHQgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0ICAgICAgaWYgKGxpc3RlbmVyc1tpXS5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbaV0uZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cblx0XHQgICAgICBzd2l0Y2ggKGxlbikge1xuXHRcdCAgICAgICAgY2FzZSAxOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCk7IGJyZWFrO1xuXHRcdCAgICAgICAgY2FzZSAyOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEpOyBicmVhaztcblx0XHQgICAgICAgIGNhc2UgMzogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMik7IGJyZWFrO1xuXHRcdCAgICAgICAgY2FzZSA0OiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyLCBhMyk7IGJyZWFrO1xuXHRcdCAgICAgICAgZGVmYXVsdDpcblx0XHQgICAgICAgICAgaWYgKCFhcmdzKSBmb3IgKGogPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGogPCBsZW47IGorKykge1xuXHRcdCAgICAgICAgICAgIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xuXHRcdCAgICAgICAgICB9XG5cblx0XHQgICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhcmdzKTtcblx0XHQgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgIH1cblxuXHRcdCAgcmV0dXJuIHRydWU7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuXHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cblx0XHQgKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cblx0XHQgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqL1xuXHRcdEV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldmVudCwgZm4sIGNvbnRleHQpIHtcblx0XHQgIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIGZhbHNlKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogQWRkIGEgb25lLXRpbWUgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuXHRcdCAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuXHRcdCAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cblx0XHQgKiBAcHVibGljXG5cdFx0ICovXG5cdFx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZShldmVudCwgZm4sIGNvbnRleHQpIHtcblx0XHQgIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIHRydWUpO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBSZW1vdmUgdGhlIGxpc3RlbmVycyBvZiBhIGdpdmVuIGV2ZW50LlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuXHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBtYXRjaCB0aGlzIGZ1bmN0aW9uLlxuXHRcdCAqIEBwYXJhbSB7Kn0gY29udGV4dCBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgaGF2ZSB0aGlzIGNvbnRleHQuXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBvbmNlIE9ubHkgcmVtb3ZlIG9uZS10aW1lIGxpc3RlbmVycy5cblx0XHQgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqL1xuXHRcdEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcblx0XHQgIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG5cdFx0ICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gdGhpcztcblx0XHQgIGlmICghZm4pIHtcblx0XHQgICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuXHRcdCAgICByZXR1cm4gdGhpcztcblx0XHQgIH1cblxuXHRcdCAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG5cdFx0ICBpZiAobGlzdGVuZXJzLmZuKSB7XG5cdFx0ICAgIGlmIChcblx0XHQgICAgICBsaXN0ZW5lcnMuZm4gPT09IGZuICYmXG5cdFx0ICAgICAgKCFvbmNlIHx8IGxpc3RlbmVycy5vbmNlKSAmJlxuXHRcdCAgICAgICghY29udGV4dCB8fCBsaXN0ZW5lcnMuY29udGV4dCA9PT0gY29udGV4dClcblx0XHQgICAgKSB7XG5cdFx0ICAgICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuXHRcdCAgICB9XG5cdFx0ICB9IGVsc2Uge1xuXHRcdCAgICBmb3IgKHZhciBpID0gMCwgZXZlbnRzID0gW10sIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdCAgICAgIGlmIChcblx0XHQgICAgICAgIGxpc3RlbmVyc1tpXS5mbiAhPT0gZm4gfHxcblx0XHQgICAgICAgIChvbmNlICYmICFsaXN0ZW5lcnNbaV0ub25jZSkgfHxcblx0XHQgICAgICAgIChjb250ZXh0ICYmIGxpc3RlbmVyc1tpXS5jb250ZXh0ICE9PSBjb250ZXh0KVxuXHRcdCAgICAgICkge1xuXHRcdCAgICAgICAgZXZlbnRzLnB1c2gobGlzdGVuZXJzW2ldKTtcblx0XHQgICAgICB9XG5cdFx0ICAgIH1cblxuXHRcdCAgICAvL1xuXHRcdCAgICAvLyBSZXNldCB0aGUgYXJyYXksIG9yIHJlbW92ZSBpdCBjb21wbGV0ZWx5IGlmIHdlIGhhdmUgbm8gbW9yZSBsaXN0ZW5lcnMuXG5cdFx0ICAgIC8vXG5cdFx0ICAgIGlmIChldmVudHMubGVuZ3RoKSB0aGlzLl9ldmVudHNbZXZ0XSA9IGV2ZW50cy5sZW5ndGggPT09IDEgPyBldmVudHNbMF0gOiBldmVudHM7XG5cdFx0ICAgIGVsc2UgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuXHRcdCAgfVxuXG5cdFx0ICByZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMsIG9yIHRob3NlIG9mIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gW2V2ZW50XSBUaGUgZXZlbnQgbmFtZS5cblx0XHQgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqL1xuXHRcdEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG5cdFx0ICB2YXIgZXZ0O1xuXG5cdFx0ICBpZiAoZXZlbnQpIHtcblx0XHQgICAgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblx0XHQgICAgaWYgKHRoaXMuX2V2ZW50c1tldnRdKSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG5cdFx0ICB9IGVsc2Uge1xuXHRcdCAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG5cdFx0ICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcblx0XHQgIH1cblxuXHRcdCAgcmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdC8vXG5cdFx0Ly8gQWxpYXMgbWV0aG9kcyBuYW1lcyBiZWNhdXNlIHBlb3BsZSByb2xsIGxpa2UgdGhhdC5cblx0XHQvL1xuXHRcdEV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblx0XHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcblxuXHRcdC8vXG5cdFx0Ly8gRXhwb3NlIHRoZSBwcmVmaXguXG5cdFx0Ly9cblx0XHRFdmVudEVtaXR0ZXIucHJlZml4ZWQgPSBwcmVmaXg7XG5cblx0XHQvL1xuXHRcdC8vIEFsbG93IGBFdmVudEVtaXR0ZXJgIHRvIGJlIGltcG9ydGVkIGFzIG1vZHVsZSBuYW1lc3BhY2UuXG5cdFx0Ly9cblx0XHRFdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5cdFx0Ly9cblx0XHQvLyBFeHBvc2UgdGhlIG1vZHVsZS5cblx0XHQvL1xuXHRcdHtcblx0XHQgIG1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXHRcdH0gXG5cdH0gKGV2ZW50ZW1pdHRlcjMpKTtcblx0cmV0dXJuIGV2ZW50ZW1pdHRlcjMuZXhwb3J0cztcbn1cblxudmFyIGV2ZW50ZW1pdHRlcjNFeHBvcnRzID0gcmVxdWlyZUV2ZW50ZW1pdHRlcjMoKTtcbnZhciBFdmVudEVtaXR0ZXIgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoZXZlbnRlbWl0dGVyM0V4cG9ydHMpO1xuXG5jb25zdCB2ZXJzaW9uID0gXCIxLjYuN1wiO1xuXG4vLyBlbnN1cmUgdGhlIHdvcmtlciBlbmRzIHVwIGluIHRoZSBidW5kbGVcbi8vIElmIHRoZSB3b3JrZXIgc2hvdWxkIG5vdCBiZSBpbmNsdWRlZCB0aGlzIGdldHMgYWxpYXNlZCB0byBlbXB0eS5qc1xuY29uc3Qgd29ya2VyU3RvcmUgPSB7fTtcbmZ1bmN0aW9uIGhhc1VNRFdvcmtlcigpIHtcbiAgcmV0dXJuIHR5cGVvZiBfX0hMU19XT1JLRVJfQlVORExFX18gPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBpbmplY3RXb3JrZXIoKSB7XG4gIGNvbnN0IHdvcmtlckNvbnRleHQgPSB3b3JrZXJTdG9yZVt2ZXJzaW9uXTtcbiAgaWYgKHdvcmtlckNvbnRleHQpIHtcbiAgICB3b3JrZXJDb250ZXh0LmNsaWVudENvdW50Kys7XG4gICAgcmV0dXJuIHdvcmtlckNvbnRleHQ7XG4gIH1cbiAgY29uc3QgYmxvYiA9IG5ldyBzZWxmLkJsb2IoW2B2YXIgZXhwb3J0cz17fTt2YXIgbW9kdWxlPXtleHBvcnRzOmV4cG9ydHN9O2Z1bmN0aW9uIGRlZmluZShmKXtmKCl9O2RlZmluZS5hbWQ9dHJ1ZTsoJHtfX0hMU19XT1JLRVJfQlVORExFX18udG9TdHJpbmcoKX0pKHRydWUpO2BdLCB7XG4gICAgdHlwZTogJ3RleHQvamF2YXNjcmlwdCdcbiAgfSk7XG4gIGNvbnN0IG9iamVjdFVSTCA9IHNlbGYuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgY29uc3Qgd29ya2VyID0gbmV3IHNlbGYuV29ya2VyKG9iamVjdFVSTCk7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICB3b3JrZXIsXG4gICAgb2JqZWN0VVJMLFxuICAgIGNsaWVudENvdW50OiAxXG4gIH07XG4gIHdvcmtlclN0b3JlW3ZlcnNpb25dID0gcmVzdWx0O1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbG9hZFdvcmtlcihwYXRoKSB7XG4gIGNvbnN0IHdvcmtlckNvbnRleHQgPSB3b3JrZXJTdG9yZVtwYXRoXTtcbiAgaWYgKHdvcmtlckNvbnRleHQpIHtcbiAgICB3b3JrZXJDb250ZXh0LmNsaWVudENvdW50Kys7XG4gICAgcmV0dXJuIHdvcmtlckNvbnRleHQ7XG4gIH1cbiAgY29uc3Qgc2NyaXB0VVJMID0gbmV3IHNlbGYuVVJMKHBhdGgsIHNlbGYubG9jYXRpb24uaHJlZikuaHJlZjtcbiAgY29uc3Qgd29ya2VyID0gbmV3IHNlbGYuV29ya2VyKHNjcmlwdFVSTCk7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICB3b3JrZXIsXG4gICAgc2NyaXB0VVJMLFxuICAgIGNsaWVudENvdW50OiAxXG4gIH07XG4gIHdvcmtlclN0b3JlW3BhdGhdID0gcmVzdWx0O1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcmVtb3ZlV29ya2VyRnJvbVN0b3JlKHBhdGgpIHtcbiAgY29uc3Qgd29ya2VyQ29udGV4dCA9IHdvcmtlclN0b3JlW3BhdGggfHwgdmVyc2lvbl07XG4gIGlmICh3b3JrZXJDb250ZXh0KSB7XG4gICAgY29uc3QgY2xpZW50Q291bnQgPSB3b3JrZXJDb250ZXh0LmNsaWVudENvdW50LS07XG4gICAgaWYgKGNsaWVudENvdW50ID09PSAxKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHdvcmtlcixcbiAgICAgICAgb2JqZWN0VVJMXG4gICAgICB9ID0gd29ya2VyQ29udGV4dDtcbiAgICAgIGRlbGV0ZSB3b3JrZXJTdG9yZVtwYXRoIHx8IHZlcnNpb25dO1xuICAgICAgaWYgKG9iamVjdFVSTCkge1xuICAgICAgICAvLyByZXZva2UgdGhlIE9iamVjdCBVUkwgdGhhdCB3YXMgdXNlZCB0byBjcmVhdGUgdHJhbnNtdXhlciB3b3JrZXIsIHNvIGFzIG5vdCB0byBsZWFrIGl0XG4gICAgICAgIHNlbGYuVVJMLnJldm9rZU9iamVjdFVSTChvYmplY3RVUkwpO1xuICAgICAgfVxuICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhbiBJRDMgZm9vdGVyIGNhbiBiZSBmb3VuZCBhdCBvZmZzZXQgaW4gZGF0YVxuICpcbiAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gc2VhcmNoIGluXG4gKiBAcGFyYW0gb2Zmc2V0IC0gVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCBzZWFyY2hpbmdcbiAqXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgYW4gSUQzIGZvb3RlciBpcyBmb3VuZFxuICpcbiAqIEBpbnRlcm5hbFxuICpcbiAqIEBncm91cCBJRDNcbiAqL1xuZnVuY3Rpb24gaXNJZDNGb290ZXIoZGF0YSwgb2Zmc2V0KSB7XG4gIC8qXG4gICAqIFRoZSBmb290ZXIgaXMgYSBjb3B5IG9mIHRoZSBoZWFkZXIsIGJ1dCB3aXRoIGEgZGlmZmVyZW50IGlkZW50aWZpZXJcbiAgICovXG4gIGlmIChvZmZzZXQgKyAxMCA8PSBkYXRhLmxlbmd0aCkge1xuICAgIC8vIGxvb2sgZm9yICczREknIGlkZW50aWZpZXJcbiAgICBpZiAoZGF0YVtvZmZzZXRdID09PSAweDMzICYmIGRhdGFbb2Zmc2V0ICsgMV0gPT09IDB4NDQgJiYgZGF0YVtvZmZzZXQgKyAyXSA9PT0gMHg0OSkge1xuICAgICAgLy8gY2hlY2sgdmVyc2lvbiBpcyB3aXRoaW4gcmFuZ2VcbiAgICAgIGlmIChkYXRhW29mZnNldCArIDNdIDwgMHhmZiAmJiBkYXRhW29mZnNldCArIDRdIDwgMHhmZikge1xuICAgICAgICAvLyBjaGVjayBzaXplIGlzIHdpdGhpbiByYW5nZVxuICAgICAgICBpZiAoZGF0YVtvZmZzZXQgKyA2XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA3XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA4XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA5XSA8IDB4ODApIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGFuIElEMyBoZWFkZXIgY2FuIGJlIGZvdW5kIGF0IG9mZnNldCBpbiBkYXRhXG4gKlxuICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byBzZWFyY2ggaW5cbiAqIEBwYXJhbSBvZmZzZXQgLSBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRvIHN0YXJ0IHNlYXJjaGluZ1xuICpcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiBhbiBJRDMgaGVhZGVyIGlzIGZvdW5kXG4gKlxuICogQGludGVybmFsXG4gKlxuICogQGdyb3VwIElEM1xuICovXG5mdW5jdGlvbiBpc0lkM0hlYWRlcihkYXRhLCBvZmZzZXQpIHtcbiAgLypcbiAgICogaHR0cDovL2lkMy5vcmcvaWQzdjIuMy4wXG4gICAqIFswXSAgICAgPSAnSSdcbiAgICogWzFdICAgICA9ICdEJ1xuICAgKiBbMl0gICAgID0gJzMnXG4gICAqIFszLDRdICAgPSB7VmVyc2lvbn1cbiAgICogWzVdICAgICA9IHtGbGFnc31cbiAgICogWzYtOV0gICA9IHtJRDMgU2l6ZX1cbiAgICpcbiAgICogQW4gSUQzdjIgdGFnIGNhbiBiZSBkZXRlY3RlZCB3aXRoIHRoZSBmb2xsb3dpbmcgcGF0dGVybjpcbiAgICogICQ0OSA0NCAzMyB5eSB5eSB4eCB6eiB6eiB6eiB6elxuICAgKiBXaGVyZSB5eSBpcyBsZXNzIHRoYW4gJEZGLCB4eCBpcyB0aGUgJ2ZsYWdzJyBieXRlIGFuZCB6eiBpcyBsZXNzIHRoYW4gJDgwXG4gICAqL1xuICBpZiAob2Zmc2V0ICsgMTAgPD0gZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBsb29rIGZvciAnSUQzJyBpZGVudGlmaWVyXG4gICAgaWYgKGRhdGFbb2Zmc2V0XSA9PT0gMHg0OSAmJiBkYXRhW29mZnNldCArIDFdID09PSAweDQ0ICYmIGRhdGFbb2Zmc2V0ICsgMl0gPT09IDB4MzMpIHtcbiAgICAgIC8vIGNoZWNrIHZlcnNpb24gaXMgd2l0aGluIHJhbmdlXG4gICAgICBpZiAoZGF0YVtvZmZzZXQgKyAzXSA8IDB4ZmYgJiYgZGF0YVtvZmZzZXQgKyA0XSA8IDB4ZmYpIHtcbiAgICAgICAgLy8gY2hlY2sgc2l6ZSBpcyB3aXRoaW4gcmFuZ2VcbiAgICAgICAgaWYgKGRhdGFbb2Zmc2V0ICsgNl0gPCAweDgwICYmIGRhdGFbb2Zmc2V0ICsgN10gPCAweDgwICYmIGRhdGFbb2Zmc2V0ICsgOF0gPCAweDgwICYmIGRhdGFbb2Zmc2V0ICsgOV0gPCAweDgwKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJlYWQgSUQzIHNpemVcbiAqXG4gKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIHJlYWQgZnJvbVxuICogQHBhcmFtIG9mZnNldCAtIFRoZSBvZmZzZXQgYXQgd2hpY2ggdG8gc3RhcnQgcmVhZGluZ1xuICpcbiAqIEByZXR1cm5zIFRoZSBzaXplXG4gKlxuICogQGludGVybmFsXG4gKlxuICogQGdyb3VwIElEM1xuICovXG5mdW5jdGlvbiByZWFkSWQzU2l6ZShkYXRhLCBvZmZzZXQpIHtcbiAgbGV0IHNpemUgPSAwO1xuICBzaXplID0gKGRhdGFbb2Zmc2V0XSAmIDB4N2YpIDw8IDIxO1xuICBzaXplIHw9IChkYXRhW29mZnNldCArIDFdICYgMHg3ZikgPDwgMTQ7XG4gIHNpemUgfD0gKGRhdGFbb2Zmc2V0ICsgMl0gJiAweDdmKSA8PCA3O1xuICBzaXplIHw9IGRhdGFbb2Zmc2V0ICsgM10gJiAweDdmO1xuICByZXR1cm4gc2l6ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFueSBhZGphY2VudCBJRDMgdGFncyBmb3VuZCBpbiBkYXRhIHN0YXJ0aW5nIGF0IG9mZnNldCwgYXMgb25lIGJsb2NrIG9mIGRhdGFcbiAqXG4gKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIHNlYXJjaCBpblxuICogQHBhcmFtIG9mZnNldCAtIFRoZSBvZmZzZXQgYXQgd2hpY2ggdG8gc3RhcnQgc2VhcmNoaW5nXG4gKlxuICogQHJldHVybnMgVGhlIGJsb2NrIG9mIGRhdGEgY29udGFpbmluZyBhbnkgSUQzIHRhZ3MgZm91bmRcbiAqIG9yIGB1bmRlZmluZWRgIGlmIG5vIGhlYWRlciBpcyBmb3VuZCBhdCB0aGUgc3RhcnRpbmcgb2Zmc2V0XG4gKlxuICogQGludGVybmFsXG4gKlxuICogQGdyb3VwIElEM1xuICovXG5mdW5jdGlvbiBnZXRJZDNEYXRhKGRhdGEsIG9mZnNldCkge1xuICBjb25zdCBmcm9udCA9IG9mZnNldDtcbiAgbGV0IGxlbmd0aCA9IDA7XG4gIHdoaWxlIChpc0lkM0hlYWRlcihkYXRhLCBvZmZzZXQpKSB7XG4gICAgLy8gSUQzIGhlYWRlciBpcyAxMCBieXRlc1xuICAgIGxlbmd0aCArPSAxMDtcbiAgICBjb25zdCBzaXplID0gcmVhZElkM1NpemUoZGF0YSwgb2Zmc2V0ICsgNik7XG4gICAgbGVuZ3RoICs9IHNpemU7XG4gICAgaWYgKGlzSWQzRm9vdGVyKGRhdGEsIG9mZnNldCArIDEwKSkge1xuICAgICAgLy8gSUQzIGZvb3RlciBpcyAxMCBieXRlc1xuICAgICAgbGVuZ3RoICs9IDEwO1xuICAgIH1cbiAgICBvZmZzZXQgKz0gbGVuZ3RoO1xuICB9XG4gIGlmIChsZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGRhdGEuc3ViYXJyYXkoZnJvbnQsIGZyb250ICsgbGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBnZXRBdWRpb0NvbmZpZyhvYnNlcnZlciwgZGF0YSwgb2Zmc2V0LCBtYW5pZmVzdENvZGVjKSB7XG4gIGNvbnN0IGFkdHNTYW1wbGluZ1JhdGVzID0gWzk2MDAwLCA4ODIwMCwgNjQwMDAsIDQ4MDAwLCA0NDEwMCwgMzIwMDAsIDI0MDAwLCAyMjA1MCwgMTYwMDAsIDEyMDAwLCAxMTAyNSwgODAwMCwgNzM1MF07XG4gIGNvbnN0IGJ5dGUyID0gZGF0YVtvZmZzZXQgKyAyXTtcbiAgY29uc3QgYWR0c1NhbXBsaW5nSW5kZXggPSBieXRlMiA+PiAyICYgMHhmO1xuICBpZiAoYWR0c1NhbXBsaW5nSW5kZXggPiAxMikge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBpbnZhbGlkIEFEVFMgc2FtcGxpbmcgaW5kZXg6JHthZHRzU2FtcGxpbmdJbmRleH1gKTtcbiAgICBvYnNlcnZlci5lbWl0KEV2ZW50cy5FUlJPUiwgRXZlbnRzLkVSUk9SLCB7XG4gICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUixcbiAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgZXJyb3IsXG4gICAgICByZWFzb246IGVycm9yLm1lc3NhZ2VcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gTVBFRy00IEF1ZGlvIE9iamVjdCBUeXBlIChwcm9maWxlX09iamVjdFR5cGUrMSlcbiAgY29uc3QgYWR0c09iamVjdFR5cGUgPSAoYnl0ZTIgPj4gNiAmIDB4MykgKyAxO1xuICBjb25zdCBjaGFubmVsQ291bnQgPSBkYXRhW29mZnNldCArIDNdID4+IDYgJiAweDMgfCAoYnl0ZTIgJiAxKSA8PCAyO1xuICBjb25zdCBjb2RlYyA9ICdtcDRhLjQwLicgKyBhZHRzT2JqZWN0VHlwZTtcbiAgLyogcmVmZXIgdG8gaHR0cDovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9TVBFRy00X0F1ZGlvI0F1ZGlvX1NwZWNpZmljX0NvbmZpZ1xuICAgICAgSVNPL0lFQyAxNDQ5Ni0zIC0gVGFibGUgMS4xMyDigJQgU3ludGF4IG9mIEF1ZGlvU3BlY2lmaWNDb25maWcoKVxuICAgIEF1ZGlvIFByb2ZpbGUgLyBBdWRpbyBPYmplY3QgVHlwZVxuICAgIDA6IE51bGxcbiAgICAxOiBBQUMgTWFpblxuICAgIDI6IEFBQyBMQyAoTG93IENvbXBsZXhpdHkpXG4gICAgMzogQUFDIFNTUiAoU2NhbGFibGUgU2FtcGxlIFJhdGUpXG4gICAgNDogQUFDIExUUCAoTG9uZyBUZXJtIFByZWRpY3Rpb24pXG4gICAgNTogU0JSIChTcGVjdHJhbCBCYW5kIFJlcGxpY2F0aW9uKVxuICAgIDY6IEFBQyBTY2FsYWJsZVxuICAgc2FtcGxpbmcgZnJlcVxuICAgIDA6IDk2MDAwIEh6XG4gICAgMTogODgyMDAgSHpcbiAgICAyOiA2NDAwMCBIelxuICAgIDM6IDQ4MDAwIEh6XG4gICAgNDogNDQxMDAgSHpcbiAgICA1OiAzMjAwMCBIelxuICAgIDY6IDI0MDAwIEh6XG4gICAgNzogMjIwNTAgSHpcbiAgICA4OiAxNjAwMCBIelxuICAgIDk6IDEyMDAwIEh6XG4gICAgMTA6IDExMDI1IEh6XG4gICAgMTE6IDgwMDAgSHpcbiAgICAxMjogNzM1MCBIelxuICAgIDEzOiBSZXNlcnZlZFxuICAgIDE0OiBSZXNlcnZlZFxuICAgIDE1OiBmcmVxdWVuY3kgaXMgd3JpdHRlbiBleHBsaWN0bHlcbiAgICBDaGFubmVsIENvbmZpZ3VyYXRpb25zXG4gICAgVGhlc2UgYXJlIHRoZSBjaGFubmVsIGNvbmZpZ3VyYXRpb25zOlxuICAgIDA6IERlZmluZWQgaW4gQU9UIFNwZWNpZmMgQ29uZmlnXG4gICAgMTogMSBjaGFubmVsOiBmcm9udC1jZW50ZXJcbiAgICAyOiAyIGNoYW5uZWxzOiBmcm9udC1sZWZ0LCBmcm9udC1yaWdodFxuICAqL1xuICAvLyBhdWRpb09iamVjdFR5cGUgPSBwcm9maWxlID0+IHByb2ZpbGUsIHRoZSBNUEVHLTQgQXVkaW8gT2JqZWN0IFR5cGUgbWludXMgMVxuICBjb25zdCBzYW1wbGVyYXRlID0gYWR0c1NhbXBsaW5nUmF0ZXNbYWR0c1NhbXBsaW5nSW5kZXhdO1xuICBsZXQgYWFjU2FtcGxlSW5kZXggPSBhZHRzU2FtcGxpbmdJbmRleDtcbiAgaWYgKGFkdHNPYmplY3RUeXBlID09PSA1IHx8IGFkdHNPYmplY3RUeXBlID09PSAyOSkge1xuICAgIC8vIEhFLUFBQyB1c2VzIFNCUiAoU3BlY3RyYWwgQmFuZCBSZXBsaWNhdGlvbikgLCBoaWdoIGZyZXF1ZW5jaWVzIGFyZSBjb25zdHJ1Y3RlZCBmcm9tIGxvdyBmcmVxdWVuY2llc1xuICAgIC8vIHRoZXJlIGlzIGEgZmFjdG9yIDIgYmV0d2VlbiBmcmFtZSBzYW1wbGUgcmF0ZSBhbmQgb3V0cHV0IHNhbXBsZSByYXRlXG4gICAgLy8gbXVsdGlwbHkgZnJlcXVlbmN5IGJ5IDIgKHNlZSB0YWJsZSBhYm92ZSwgZXF1aXZhbGVudCB0byBzdWJzdHJhY3QgMylcbiAgICBhYWNTYW1wbGVJbmRleCAtPSAzO1xuICB9XG4gIGNvbnN0IGNvbmZpZyA9IFthZHRzT2JqZWN0VHlwZSA8PCAzIHwgKGFhY1NhbXBsZUluZGV4ICYgMHgwZSkgPj4gMSwgKGFhY1NhbXBsZUluZGV4ICYgMHgwMSkgPDwgNyB8IGNoYW5uZWxDb3VudCA8PCAzXTtcbiAgbG9nZ2VyLmxvZyhgbWFuaWZlc3QgY29kZWM6JHttYW5pZmVzdENvZGVjfSwgcGFyc2VkIGNvZGVjOiR7Y29kZWN9LCBjaGFubmVsczoke2NoYW5uZWxDb3VudH0sIHJhdGU6JHtzYW1wbGVyYXRlfSAoQURUUyBvYmplY3QgdHlwZToke2FkdHNPYmplY3RUeXBlfSBzYW1wbGluZyBpbmRleDoke2FkdHNTYW1wbGluZ0luZGV4fSlgKTtcbiAgcmV0dXJuIHtcbiAgICBjb25maWcsXG4gICAgc2FtcGxlcmF0ZSxcbiAgICBjaGFubmVsQ291bnQsXG4gICAgY29kZWMsXG4gICAgcGFyc2VkQ29kZWM6IGNvZGVjLFxuICAgIG1hbmlmZXN0Q29kZWNcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzSGVhZGVyUGF0dGVybiQxKGRhdGEsIG9mZnNldCkge1xuICByZXR1cm4gZGF0YVtvZmZzZXRdID09PSAweGZmICYmIChkYXRhW29mZnNldCArIDFdICYgMHhmNikgPT09IDB4ZjA7XG59XG5mdW5jdGlvbiBnZXRIZWFkZXJMZW5ndGgoZGF0YSwgb2Zmc2V0KSB7XG4gIHJldHVybiBkYXRhW29mZnNldCArIDFdICYgMHgwMSA/IDcgOiA5O1xufVxuZnVuY3Rpb24gZ2V0RnVsbEZyYW1lTGVuZ3RoKGRhdGEsIG9mZnNldCkge1xuICByZXR1cm4gKGRhdGFbb2Zmc2V0ICsgM10gJiAweDAzKSA8PCAxMSB8IGRhdGFbb2Zmc2V0ICsgNF0gPDwgMyB8IChkYXRhW29mZnNldCArIDVdICYgMHhlMCkgPj4+IDU7XG59XG5mdW5jdGlvbiBjYW5HZXRGcmFtZUxlbmd0aChkYXRhLCBvZmZzZXQpIHtcbiAgcmV0dXJuIG9mZnNldCArIDUgPCBkYXRhLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGlzSGVhZGVyJDEoZGF0YSwgb2Zmc2V0KSB7XG4gIC8vIExvb2sgZm9yIEFEVFMgaGVhZGVyIHwgMTExMSAxMTExIHwgMTExMSBYMDBYIHwgd2hlcmUgWCBjYW4gYmUgZWl0aGVyIDAgb3IgMVxuICAvLyBMYXllciBiaXRzIChwb3NpdGlvbiAxNCBhbmQgMTUpIGluIGhlYWRlciBzaG91bGQgYmUgYWx3YXlzIDAgZm9yIEFEVFNcbiAgLy8gTW9yZSBpbmZvIGh0dHBzOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1BRFRTXG4gIHJldHVybiBvZmZzZXQgKyAxIDwgZGF0YS5sZW5ndGggJiYgaXNIZWFkZXJQYXR0ZXJuJDEoZGF0YSwgb2Zmc2V0KTtcbn1cbmZ1bmN0aW9uIGNhblBhcnNlJDEoZGF0YSwgb2Zmc2V0KSB7XG4gIHJldHVybiBjYW5HZXRGcmFtZUxlbmd0aChkYXRhLCBvZmZzZXQpICYmIGlzSGVhZGVyUGF0dGVybiQxKGRhdGEsIG9mZnNldCkgJiYgZ2V0RnVsbEZyYW1lTGVuZ3RoKGRhdGEsIG9mZnNldCkgPD0gZGF0YS5sZW5ndGggLSBvZmZzZXQ7XG59XG5mdW5jdGlvbiBwcm9iZSQxKGRhdGEsIG9mZnNldCkge1xuICAvLyBzYW1lIGFzIGlzSGVhZGVyIGJ1dCB3ZSBhbHNvIGNoZWNrIHRoYXQgQURUUyBmcmFtZSBmb2xsb3dzIGxhc3QgQURUUyBmcmFtZVxuICAvLyBvciBlbmQgb2YgZGF0YSBpcyByZWFjaGVkXG4gIGlmIChpc0hlYWRlciQxKGRhdGEsIG9mZnNldCkpIHtcbiAgICAvLyBBRFRTIGhlYWRlciBMZW5ndGhcbiAgICBjb25zdCBoZWFkZXJMZW5ndGggPSBnZXRIZWFkZXJMZW5ndGgoZGF0YSwgb2Zmc2V0KTtcbiAgICBpZiAob2Zmc2V0ICsgaGVhZGVyTGVuZ3RoID49IGRhdGEubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIEFEVFMgZnJhbWUgTGVuZ3RoXG4gICAgY29uc3QgZnJhbWVMZW5ndGggPSBnZXRGdWxsRnJhbWVMZW5ndGgoZGF0YSwgb2Zmc2V0KTtcbiAgICBpZiAoZnJhbWVMZW5ndGggPD0gaGVhZGVyTGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG5ld09mZnNldCA9IG9mZnNldCArIGZyYW1lTGVuZ3RoO1xuICAgIHJldHVybiBuZXdPZmZzZXQgPT09IGRhdGEubGVuZ3RoIHx8IGlzSGVhZGVyJDEoZGF0YSwgbmV3T2Zmc2V0KTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpbml0VHJhY2tDb25maWcodHJhY2ssIG9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIGF1ZGlvQ29kZWMpIHtcbiAgaWYgKCF0cmFjay5zYW1wbGVyYXRlKSB7XG4gICAgY29uc3QgY29uZmlnID0gZ2V0QXVkaW9Db25maWcob2JzZXJ2ZXIsIGRhdGEsIG9mZnNldCwgYXVkaW9Db2RlYyk7XG4gICAgaWYgKCFjb25maWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgX2V4dGVuZHModHJhY2ssIGNvbmZpZyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEZyYW1lRHVyYXRpb24oc2FtcGxlcmF0ZSkge1xuICByZXR1cm4gMTAyNCAqIDkwMDAwIC8gc2FtcGxlcmF0ZTtcbn1cbmZ1bmN0aW9uIHBhcnNlRnJhbWVIZWFkZXIoZGF0YSwgb2Zmc2V0KSB7XG4gIC8vIFRoZSBwcm90ZWN0aW9uIHNraXAgYml0IHRlbGxzIHVzIGlmIHdlIGhhdmUgMiBieXRlcyBvZiBDUkMgZGF0YSBhdCB0aGUgZW5kIG9mIHRoZSBBRFRTIGhlYWRlclxuICBjb25zdCBoZWFkZXJMZW5ndGggPSBnZXRIZWFkZXJMZW5ndGgoZGF0YSwgb2Zmc2V0KTtcbiAgaWYgKG9mZnNldCArIGhlYWRlckxlbmd0aCA8PSBkYXRhLmxlbmd0aCkge1xuICAgIC8vIHJldHJpZXZlIGZyYW1lIHNpemVcbiAgICBjb25zdCBmcmFtZUxlbmd0aCA9IGdldEZ1bGxGcmFtZUxlbmd0aChkYXRhLCBvZmZzZXQpIC0gaGVhZGVyTGVuZ3RoO1xuICAgIGlmIChmcmFtZUxlbmd0aCA+IDApIHtcbiAgICAgIC8vIGxvZ2dlci5sb2coYEFBQyBmcmFtZSwgb2Zmc2V0L2xlbmd0aC90b3RhbC9wdHM6JHtvZmZzZXQraGVhZGVyTGVuZ3RofS8ke2ZyYW1lTGVuZ3RofS8ke2RhdGEuYnl0ZUxlbmd0aH1gKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhlYWRlckxlbmd0aCxcbiAgICAgICAgZnJhbWVMZW5ndGhcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhcHBlbmRGcmFtZSQyKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHB0cywgZnJhbWVJbmRleCkge1xuICBjb25zdCBmcmFtZUR1cmF0aW9uID0gZ2V0RnJhbWVEdXJhdGlvbih0cmFjay5zYW1wbGVyYXRlKTtcbiAgY29uc3Qgc3RhbXAgPSBwdHMgKyBmcmFtZUluZGV4ICogZnJhbWVEdXJhdGlvbjtcbiAgY29uc3QgaGVhZGVyID0gcGFyc2VGcmFtZUhlYWRlcihkYXRhLCBvZmZzZXQpO1xuICBsZXQgdW5pdDtcbiAgaWYgKGhlYWRlcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYW1lTGVuZ3RoLFxuICAgICAgaGVhZGVyTGVuZ3RoXG4gICAgfSA9IGhlYWRlcjtcbiAgICBjb25zdCBfbGVuZ3RoID0gaGVhZGVyTGVuZ3RoICsgZnJhbWVMZW5ndGg7XG4gICAgY29uc3QgbWlzc2luZyA9IE1hdGgubWF4KDAsIG9mZnNldCArIF9sZW5ndGggLSBkYXRhLmxlbmd0aCk7XG4gICAgLy8gbG9nZ2VyLmxvZyhgQUFDIGZyYW1lICR7ZnJhbWVJbmRleH0sIHB0czoke3N0YW1wfSBsZW5ndGhAb2Zmc2V0L3RvdGFsOiAke2ZyYW1lTGVuZ3RofUAke29mZnNldCtoZWFkZXJMZW5ndGh9LyR7ZGF0YS5ieXRlTGVuZ3RofSBtaXNzaW5nOiAke21pc3Npbmd9YCk7XG4gICAgaWYgKG1pc3NpbmcpIHtcbiAgICAgIHVuaXQgPSBuZXcgVWludDhBcnJheShfbGVuZ3RoIC0gaGVhZGVyTGVuZ3RoKTtcbiAgICAgIHVuaXQuc2V0KGRhdGEuc3ViYXJyYXkob2Zmc2V0ICsgaGVhZGVyTGVuZ3RoLCBkYXRhLmxlbmd0aCksIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bml0ID0gZGF0YS5zdWJhcnJheShvZmZzZXQgKyBoZWFkZXJMZW5ndGgsIG9mZnNldCArIF9sZW5ndGgpO1xuICAgIH1cbiAgICBjb25zdCBfc2FtcGxlID0ge1xuICAgICAgdW5pdCxcbiAgICAgIHB0czogc3RhbXBcbiAgICB9O1xuICAgIGlmICghbWlzc2luZykge1xuICAgICAgdHJhY2suc2FtcGxlcy5wdXNoKF9zYW1wbGUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc2FtcGxlOiBfc2FtcGxlLFxuICAgICAgbGVuZ3RoOiBfbGVuZ3RoLFxuICAgICAgbWlzc2luZ1xuICAgIH07XG4gIH1cbiAgLy8gb3ZlcmZsb3cgaW5jb21wbGV0ZSBoZWFkZXJcbiAgY29uc3QgbGVuZ3RoID0gZGF0YS5sZW5ndGggLSBvZmZzZXQ7XG4gIHVuaXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICB1bml0LnNldChkYXRhLnN1YmFycmF5KG9mZnNldCwgZGF0YS5sZW5ndGgpLCAwKTtcbiAgY29uc3Qgc2FtcGxlID0ge1xuICAgIHVuaXQsXG4gICAgcHRzOiBzdGFtcFxuICB9O1xuICByZXR1cm4ge1xuICAgIHNhbXBsZSxcbiAgICBsZW5ndGgsXG4gICAgbWlzc2luZzogLTFcbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGRhdGEgY29udGFpbnMgYW4gSUQzIHRhZy5cbiAqXG4gKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIGNoZWNrXG4gKiBAcGFyYW0gb2Zmc2V0IC0gVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCBjaGVja2luZ1xuICpcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiBhbiBJRDMgdGFnIGlzIGZvdW5kXG4gKlxuICogQGdyb3VwIElEM1xuICpcbiAqIEBiZXRhXG4gKi9cbmZ1bmN0aW9uIGNhblBhcnNlSWQzKGRhdGEsIG9mZnNldCkge1xuICByZXR1cm4gaXNJZDNIZWFkZXIoZGF0YSwgb2Zmc2V0KSAmJiByZWFkSWQzU2l6ZShkYXRhLCBvZmZzZXQgKyA2KSArIDEwIDw9IGRhdGEubGVuZ3RoIC0gb2Zmc2V0O1xufVxuXG5mdW5jdGlvbiB0b0FycmF5QnVmZmVyKHZpZXcpIHtcbiAgaWYgKHZpZXcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiB2aWV3O1xuICB9IGVsc2Uge1xuICAgIGlmICh2aWV3LmJ5dGVPZmZzZXQgPT0gMCAmJiB2aWV3LmJ5dGVMZW5ndGggPT0gdmlldy5idWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgICAgLy8gVGhpcyBpcyBhIFR5cGVkQXJyYXkgb3ZlciB0aGUgd2hvbGUgYnVmZmVyLlxuICAgICAgcmV0dXJuIHZpZXcuYnVmZmVyO1xuICAgIH1cbiAgICAvLyBUaGlzIGlzIGEgJ3ZpZXcnIG9uIHRoZSBidWZmZXIuICBDcmVhdGUgYSBuZXcgYnVmZmVyIHRoYXQgb25seSBjb250YWluc1xuICAgIC8vIHRoZSBkYXRhLiAgTm90ZSB0aGF0IHNpbmNlIHRoaXMgaXNuJ3QgYW4gQXJyYXlCdWZmZXIsIHRoZSAnbmV3JyBjYWxsXG4gICAgLy8gd2lsbCBhbGxvY2F0ZSBhIG5ldyBidWZmZXIgdG8gaG9sZCB0aGUgY29weS5cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodmlldykuYnVmZmVyO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRvVWludDgoZGF0YSwgb2Zmc2V0ID0gMCwgbGVuZ3RoID0gSW5maW5pdHkpIHtcbiAgcmV0dXJuIHZpZXcoZGF0YSwgb2Zmc2V0LCBsZW5ndGgsIFVpbnQ4QXJyYXkpO1xufVxuZnVuY3Rpb24gdmlldyhkYXRhLCBvZmZzZXQsIGxlbmd0aCwgVHlwZSkge1xuICBjb25zdCBidWZmZXIgPSB1bnNhZmVHZXRBcnJheUJ1ZmZlcihkYXRhKTtcbiAgbGV0IGJ5dGVzUGVyRWxlbWVudCA9IDE7XG4gIGlmICgnQllURVNfUEVSX0VMRU1FTlQnIGluIFR5cGUpIHtcbiAgICBieXRlc1BlckVsZW1lbnQgPSBUeXBlLkJZVEVTX1BFUl9FTEVNRU5UO1xuICB9XG4gIC8vIEFic29sdXRlIGVuZCBvZiB0aGUgfGRhdGF8IHZpZXcgd2l0aGluIHxidWZmZXJ8LlxuICBjb25zdCBkYXRhT2Zmc2V0ID0gaXNBcnJheUJ1ZmZlclZpZXcoZGF0YSkgPyBkYXRhLmJ5dGVPZmZzZXQgOiAwO1xuICBjb25zdCBkYXRhRW5kID0gKGRhdGFPZmZzZXQgKyBkYXRhLmJ5dGVMZW5ndGgpIC8gYnl0ZXNQZXJFbGVtZW50O1xuICAvLyBBYnNvbHV0ZSBzdGFydCBvZiB0aGUgcmVzdWx0IHdpdGhpbiB8YnVmZmVyfC5cbiAgY29uc3QgcmF3U3RhcnQgPSAoZGF0YU9mZnNldCArIG9mZnNldCkgLyBieXRlc1BlckVsZW1lbnQ7XG4gIGNvbnN0IHN0YXJ0ID0gTWF0aC5mbG9vcihNYXRoLm1heCgwLCBNYXRoLm1pbihyYXdTdGFydCwgZGF0YUVuZCkpKTtcbiAgLy8gQWJzb2x1dGUgZW5kIG9mIHRoZSByZXN1bHQgd2l0aGluIHxidWZmZXJ8LlxuICBjb25zdCBlbmQgPSBNYXRoLmZsb29yKE1hdGgubWluKHN0YXJ0ICsgTWF0aC5tYXgobGVuZ3RoLCAwKSwgZGF0YUVuZCkpO1xuICByZXR1cm4gbmV3IFR5cGUoYnVmZmVyLCBzdGFydCwgZW5kIC0gc3RhcnQpO1xufVxuZnVuY3Rpb24gdW5zYWZlR2V0QXJyYXlCdWZmZXIodmlldykge1xuICBpZiAodmlldyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIHZpZXc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZpZXcuYnVmZmVyO1xuICB9XG59XG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyhvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgJiYgb2JqLmJ5dGVMZW5ndGggIT09IHVuZGVmaW5lZCAmJiBvYmouYnl0ZU9mZnNldCAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVJZDNJbWFnZUZyYW1lKGZyYW1lKSB7XG4gIGNvbnN0IG1ldGFkYXRhRnJhbWUgPSB7XG4gICAga2V5OiBmcmFtZS50eXBlLFxuICAgIGRlc2NyaXB0aW9uOiAnJyxcbiAgICBkYXRhOiAnJyxcbiAgICBtaW1lVHlwZTogbnVsbCxcbiAgICBwaWN0dXJlVHlwZTogbnVsbFxuICB9O1xuICBjb25zdCB1dGY4RW5jb2RpbmcgPSAweDAzO1xuICBpZiAoZnJhbWUuc2l6ZSA8IDIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChmcmFtZS5kYXRhWzBdICE9PSB1dGY4RW5jb2RpbmcpIHtcbiAgICBjb25zb2xlLmxvZygnSWdub3JlIGZyYW1lIHdpdGggdW5yZWNvZ25pemVkIGNoYXJhY3RlciAnICsgJ2VuY29kaW5nJyk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCBtaW1lVHlwZUVuZEluZGV4ID0gZnJhbWUuZGF0YS5zdWJhcnJheSgxKS5pbmRleE9mKDApO1xuICBpZiAobWltZVR5cGVFbmRJbmRleCA9PT0gLTEpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGNvbnN0IG1pbWVUeXBlID0gdXRmOEFycmF5VG9TdHIodG9VaW50OChmcmFtZS5kYXRhLCAxLCBtaW1lVHlwZUVuZEluZGV4KSk7XG4gIGNvbnN0IHBpY3R1cmVUeXBlID0gZnJhbWUuZGF0YVsyICsgbWltZVR5cGVFbmRJbmRleF07XG4gIGNvbnN0IGRlc2NyaXB0aW9uRW5kSW5kZXggPSBmcmFtZS5kYXRhLnN1YmFycmF5KDMgKyBtaW1lVHlwZUVuZEluZGV4KS5pbmRleE9mKDApO1xuICBpZiAoZGVzY3JpcHRpb25FbmRJbmRleCA9PT0gLTEpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gdXRmOEFycmF5VG9TdHIodG9VaW50OChmcmFtZS5kYXRhLCAzICsgbWltZVR5cGVFbmRJbmRleCwgZGVzY3JpcHRpb25FbmRJbmRleCkpO1xuICBsZXQgZGF0YTtcbiAgaWYgKG1pbWVUeXBlID09PSAnLS0+Jykge1xuICAgIGRhdGEgPSB1dGY4QXJyYXlUb1N0cih0b1VpbnQ4KGZyYW1lLmRhdGEsIDQgKyBtaW1lVHlwZUVuZEluZGV4ICsgZGVzY3JpcHRpb25FbmRJbmRleCkpO1xuICB9IGVsc2Uge1xuICAgIGRhdGEgPSB0b0FycmF5QnVmZmVyKGZyYW1lLmRhdGEuc3ViYXJyYXkoNCArIG1pbWVUeXBlRW5kSW5kZXggKyBkZXNjcmlwdGlvbkVuZEluZGV4KSk7XG4gIH1cbiAgbWV0YWRhdGFGcmFtZS5taW1lVHlwZSA9IG1pbWVUeXBlO1xuICBtZXRhZGF0YUZyYW1lLnBpY3R1cmVUeXBlID0gcGljdHVyZVR5cGU7XG4gIG1ldGFkYXRhRnJhbWUuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgbWV0YWRhdGFGcmFtZS5kYXRhID0gZGF0YTtcbiAgcmV0dXJuIG1ldGFkYXRhRnJhbWU7XG59XG5cbi8qKlxuICogRGVjb2RlIGFuIElEMyBQUklWIGZyYW1lLlxuICpcbiAqIEBwYXJhbSBmcmFtZSAtIHRoZSBJRDMgUFJJViBmcmFtZVxuICpcbiAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIElEMyBQUklWIGZyYW1lXG4gKlxuICogQGludGVybmFsXG4gKlxuICogQGdyb3VwIElEM1xuICovXG5mdW5jdGlvbiBkZWNvZGVJZDNQcml2RnJhbWUoZnJhbWUpIHtcbiAgLypcbiAgRm9ybWF0OiA8dGV4dCBzdHJpbmc+XFwwPGJpbmFyeSBkYXRhPlxuICAqL1xuICBpZiAoZnJhbWUuc2l6ZSA8IDIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGNvbnN0IG93bmVyID0gdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YSwgdHJ1ZSk7XG4gIGNvbnN0IHByaXZhdGVEYXRhID0gbmV3IFVpbnQ4QXJyYXkoZnJhbWUuZGF0YS5zdWJhcnJheShvd25lci5sZW5ndGggKyAxKSk7XG4gIHJldHVybiB7XG4gICAga2V5OiBmcmFtZS50eXBlLFxuICAgIGluZm86IG93bmVyLFxuICAgIGRhdGE6IHByaXZhdGVEYXRhLmJ1ZmZlclxuICB9O1xufVxuXG4vKipcbiAqIERlY29kZXMgYW4gSUQzIHRleHQgZnJhbWVcbiAqXG4gKiBAcGFyYW0gZnJhbWUgLSB0aGUgSUQzIHRleHQgZnJhbWVcbiAqXG4gKiBAcmV0dXJucyBUaGUgZGVjb2RlZCBJRDMgdGV4dCBmcmFtZVxuICpcbiAqIEBpbnRlcm5hbFxuICpcbiAqIEBncm91cCBJRDNcbiAqL1xuZnVuY3Rpb24gZGVjb2RlSWQzVGV4dEZyYW1lKGZyYW1lKSB7XG4gIGlmIChmcmFtZS5zaXplIDwgMikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGZyYW1lLnR5cGUgPT09ICdUWFhYJykge1xuICAgIC8qXG4gICAgRm9ybWF0OlxuICAgIFswXSAgID0ge1RleHQgRW5jb2Rpbmd9XG4gICAgWzEtP10gPSB7RGVzY3JpcHRpb259XFwwe1ZhbHVlfVxuICAgICovXG4gICAgbGV0IGluZGV4ID0gMTtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoaW5kZXgpLCB0cnVlKTtcbiAgICBpbmRleCArPSBkZXNjcmlwdGlvbi5sZW5ndGggKyAxO1xuICAgIGNvbnN0IHZhbHVlID0gdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YS5zdWJhcnJheShpbmRleCkpO1xuICAgIHJldHVybiB7XG4gICAgICBrZXk6IGZyYW1lLnR5cGUsXG4gICAgICBpbmZvOiBkZXNjcmlwdGlvbixcbiAgICAgIGRhdGE6IHZhbHVlXG4gICAgfTtcbiAgfVxuICAvKlxuICBGb3JtYXQ6XG4gIFswXSAgID0ge1RleHQgRW5jb2Rpbmd9XG4gIFsxLT9dID0ge1ZhbHVlfVxuICAqL1xuICBjb25zdCB0ZXh0ID0gdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YS5zdWJhcnJheSgxKSk7XG4gIHJldHVybiB7XG4gICAga2V5OiBmcmFtZS50eXBlLFxuICAgIGluZm86ICcnLFxuICAgIGRhdGE6IHRleHRcbiAgfTtcbn1cblxuLyoqXG4gKiBEZWNvZGUgYSBVUkwgZnJhbWVcbiAqXG4gKiBAcGFyYW0gZnJhbWUgLSB0aGUgSUQzIFVSTCBmcmFtZVxuICpcbiAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIElEMyBVUkwgZnJhbWVcbiAqXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBAZ3JvdXAgSUQzXG4gKi9cbmZ1bmN0aW9uIGRlY29kZUlkM1VybEZyYW1lKGZyYW1lKSB7XG4gIGlmIChmcmFtZS50eXBlID09PSAnV1hYWCcpIHtcbiAgICAvKlxuICAgIEZvcm1hdDpcbiAgICBbMF0gICA9IHtUZXh0IEVuY29kaW5nfVxuICAgIFsxLT9dID0ge0Rlc2NyaXB0aW9ufVxcMHtVUkx9XG4gICAgKi9cbiAgICBpZiAoZnJhbWUuc2l6ZSA8IDIpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGxldCBpbmRleCA9IDE7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSB1dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLnN1YmFycmF5KGluZGV4KSwgdHJ1ZSk7XG4gICAgaW5kZXggKz0gZGVzY3JpcHRpb24ubGVuZ3RoICsgMTtcbiAgICBjb25zdCB2YWx1ZSA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoaW5kZXgpKTtcbiAgICByZXR1cm4ge1xuICAgICAga2V5OiBmcmFtZS50eXBlLFxuICAgICAgaW5mbzogZGVzY3JpcHRpb24sXG4gICAgICBkYXRhOiB2YWx1ZVxuICAgIH07XG4gIH1cbiAgLypcbiAgRm9ybWF0OlxuICBbMC0/XSA9IHtVUkx9XG4gICovXG4gIGNvbnN0IHVybCA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEpO1xuICByZXR1cm4ge1xuICAgIGtleTogZnJhbWUudHlwZSxcbiAgICBpbmZvOiAnJyxcbiAgICBkYXRhOiB1cmxcbiAgfTtcbn1cblxuLyoqXG4gKiBEZWNvZGUgYW4gSUQzIGZyYW1lLlxuICpcbiAqIEBwYXJhbSBmcmFtZSAtIHRoZSBJRDMgZnJhbWVcbiAqXG4gKiBAcmV0dXJucyBUaGUgZGVjb2RlZCBJRDMgZnJhbWVcbiAqXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBAZ3JvdXAgSUQzXG4gKi9cbmZ1bmN0aW9uIGRlY29kZUlkM0ZyYW1lKGZyYW1lKSB7XG4gIGlmIChmcmFtZS50eXBlID09PSAnUFJJVicpIHtcbiAgICByZXR1cm4gZGVjb2RlSWQzUHJpdkZyYW1lKGZyYW1lKTtcbiAgfSBlbHNlIGlmIChmcmFtZS50eXBlWzBdID09PSAnVycpIHtcbiAgICByZXR1cm4gZGVjb2RlSWQzVXJsRnJhbWUoZnJhbWUpO1xuICB9IGVsc2UgaWYgKGZyYW1lLnR5cGUgPT09ICdBUElDJykge1xuICAgIHJldHVybiBkZWNvZGVJZDNJbWFnZUZyYW1lKGZyYW1lKTtcbiAgfVxuICByZXR1cm4gZGVjb2RlSWQzVGV4dEZyYW1lKGZyYW1lKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkYXRhIG9mIGFuIElEMyBmcmFtZS5cbiAqXG4gKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIHJlYWQgZnJvbVxuICpcbiAqIEByZXR1cm5zIFRoZSBkYXRhIG9mIHRoZSBJRDMgZnJhbWVcbiAqXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBAZ3JvdXAgSUQzXG4gKi9cbmZ1bmN0aW9uIGdldElkM0ZyYW1lRGF0YShkYXRhKSB7XG4gIC8qXG4gIEZyYW1lIElEICAgICAgICR4eCB4eCB4eCB4eCAoZm91ciBjaGFyYWN0ZXJzKVxuICBTaXplICAgICAgICAgICAkeHggeHggeHggeHhcbiAgRmxhZ3MgICAgICAgICAgJHh4IHh4XG4gICovXG4gIGNvbnN0IHR5cGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFbMF0sIGRhdGFbMV0sIGRhdGFbMl0sIGRhdGFbM10pO1xuICBjb25zdCBzaXplID0gcmVhZElkM1NpemUoZGF0YSwgNCk7XG4gIC8vIHNraXAgZnJhbWUgaWQsIHNpemUsIGFuZCBmbGFnc1xuICBjb25zdCBvZmZzZXQgPSAxMDtcbiAgcmV0dXJuIHtcbiAgICB0eXBlLFxuICAgIHNpemUsXG4gICAgZGF0YTogZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIHNpemUpXG4gIH07XG59XG5cbmNvbnN0IEhFQURFUl9GT09URVJfU0laRSA9IDEwO1xuY29uc3QgRlJBTUVfU0laRSA9IDEwO1xuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIElEMyBmcmFtZXMgZm91bmQgaW4gYWxsIHRoZSBJRDMgdGFncyBpbiB0aGUgaWQzRGF0YVxuICpcbiAqIEBwYXJhbSBpZDNEYXRhIC0gVGhlIElEMyBkYXRhIGNvbnRhaW5pbmcgb25lIG9yIG1vcmUgSUQzIHRhZ3NcbiAqXG4gKiBAcmV0dXJucyBBcnJheSBvZiBJRDMgZnJhbWUgb2JqZWN0c1xuICpcbiAqIEBncm91cCBJRDNcbiAqXG4gKiBAYmV0YVxuICovXG5mdW5jdGlvbiBnZXRJZDNGcmFtZXMoaWQzRGF0YSkge1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgY29uc3QgZnJhbWVzID0gW107XG4gIHdoaWxlIChpc0lkM0hlYWRlcihpZDNEYXRhLCBvZmZzZXQpKSB7XG4gICAgY29uc3Qgc2l6ZSA9IHJlYWRJZDNTaXplKGlkM0RhdGEsIG9mZnNldCArIDYpO1xuICAgIGlmIChpZDNEYXRhW29mZnNldCArIDVdID4+IDYgJiAxKSB7XG4gICAgICAvLyBza2lwIGV4dGVuZGVkIGhlYWRlclxuICAgICAgb2Zmc2V0ICs9IEhFQURFUl9GT09URVJfU0laRTtcbiAgICB9XG4gICAgLy8gc2tpcCBwYXN0IElEMyBoZWFkZXJcbiAgICBvZmZzZXQgKz0gSEVBREVSX0ZPT1RFUl9TSVpFO1xuICAgIGNvbnN0IGVuZCA9IG9mZnNldCArIHNpemU7XG4gICAgLy8gbG9vcCB0aHJvdWdoIGZyYW1lcyBpbiB0aGUgSUQzIHRhZ1xuICAgIHdoaWxlIChvZmZzZXQgKyBGUkFNRV9TSVpFIDwgZW5kKSB7XG4gICAgICBjb25zdCBmcmFtZURhdGEgPSBnZXRJZDNGcmFtZURhdGEoaWQzRGF0YS5zdWJhcnJheShvZmZzZXQpKTtcbiAgICAgIGNvbnN0IGZyYW1lID0gZGVjb2RlSWQzRnJhbWUoZnJhbWVEYXRhKTtcbiAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICBmcmFtZXMucHVzaChmcmFtZSk7XG4gICAgICB9XG4gICAgICAvLyBza2lwIGZyYW1lIGhlYWRlciBhbmQgZnJhbWUgZGF0YVxuICAgICAgb2Zmc2V0ICs9IGZyYW1lRGF0YS5zaXplICsgSEVBREVSX0ZPT1RFUl9TSVpFO1xuICAgIH1cbiAgICBpZiAoaXNJZDNGb290ZXIoaWQzRGF0YSwgb2Zmc2V0KSkge1xuICAgICAgb2Zmc2V0ICs9IEhFQURFUl9GT09URVJfU0laRTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZyYW1lcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIElEMyBmcmFtZSBpcyBhbiBFbGVtZW50YXJ5IFN0cmVhbSB0aW1lc3RhbXAgZnJhbWVcbiAqXG4gKiBAcGFyYW0gZnJhbWUgLSB0aGUgSUQzIGZyYW1lXG4gKlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBJRDMgZnJhbWUgaXMgYW4gRWxlbWVudGFyeSBTdHJlYW0gdGltZXN0YW1wIGZyYW1lXG4gKlxuICogQGludGVybmFsXG4gKlxuICogQGdyb3VwIElEM1xuICovXG5mdW5jdGlvbiBpc0lkM1RpbWVzdGFtcEZyYW1lKGZyYW1lKSB7XG4gIHJldHVybiBmcmFtZSAmJiBmcmFtZS5rZXkgPT09ICdQUklWJyAmJiBmcmFtZS5pbmZvID09PSAnY29tLmFwcGxlLnN0cmVhbWluZy50cmFuc3BvcnRTdHJlYW1UaW1lc3RhbXAnO1xufVxuXG4vKipcbiAqIFJlYWQgYSAzMyBiaXQgdGltZXN0YW1wIGZyb20gYW4gSUQzIGZyYW1lLlxuICpcbiAqIEBwYXJhbSB0aW1lU3RhbXBGcmFtZSAtIHRoZSBJRDMgZnJhbWVcbiAqXG4gKiBAcmV0dXJucyBUaGUgdGltZXN0YW1wXG4gKlxuICogQGludGVybmFsXG4gKlxuICogQGdyb3VwIElEM1xuICovXG5mdW5jdGlvbiByZWFkSWQzVGltZXN0YW1wKHRpbWVTdGFtcEZyYW1lKSB7XG4gIGlmICh0aW1lU3RhbXBGcmFtZS5kYXRhLmJ5dGVMZW5ndGggPT09IDgpIHtcbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodGltZVN0YW1wRnJhbWUuZGF0YSk7XG4gICAgLy8gdGltZXN0YW1wIGlzIDMzIGJpdCBleHByZXNzZWQgYXMgYSBiaWctZW5kaWFuIGVpZ2h0LW9jdGV0IG51bWJlcixcbiAgICAvLyB3aXRoIHRoZSB1cHBlciAzMSBiaXRzIHNldCB0byB6ZXJvLlxuICAgIGNvbnN0IHB0czMzQml0ID0gZGF0YVszXSAmIDB4MTtcbiAgICBsZXQgdGltZXN0YW1wID0gKGRhdGFbNF0gPDwgMjMpICsgKGRhdGFbNV0gPDwgMTUpICsgKGRhdGFbNl0gPDwgNykgKyBkYXRhWzddO1xuICAgIHRpbWVzdGFtcCAvPSA0NTtcbiAgICBpZiAocHRzMzNCaXQpIHtcbiAgICAgIHRpbWVzdGFtcCArPSA0NzcyMTg1OC44NDtcbiAgICB9IC8vIDJeMzIgLyA5MFxuICAgIHJldHVybiBNYXRoLnJvdW5kKHRpbWVzdGFtcCk7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBTZWFyY2hlcyBmb3IgdGhlIEVsZW1lbnRhcnkgU3RyZWFtIHRpbWVzdGFtcCBmb3VuZCBpbiB0aGUgSUQzIGRhdGEgY2h1bmtcbiAqXG4gKiBAcGFyYW0gZGF0YSAtIEJsb2NrIG9mIGRhdGEgY29udGFpbmluZyBvbmUgb3IgbW9yZSBJRDMgdGFnc1xuICpcbiAqIEByZXR1cm5zIFRoZSB0aW1lc3RhbXBcbiAqXG4gKiBAZ3JvdXAgSUQzXG4gKlxuICogQGJldGFcbiAqL1xuZnVuY3Rpb24gZ2V0SWQzVGltZXN0YW1wKGRhdGEpIHtcbiAgY29uc3QgZnJhbWVzID0gZ2V0SWQzRnJhbWVzKGRhdGEpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGZyYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGZyYW1lID0gZnJhbWVzW2ldO1xuICAgIGlmIChpc0lkM1RpbWVzdGFtcEZyYW1lKGZyYW1lKSkge1xuICAgICAgcmV0dXJuIHJlYWRJZDNUaW1lc3RhbXAoZnJhbWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5sZXQgTWV0YWRhdGFTY2hlbWEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKE1ldGFkYXRhU2NoZW1hKSB7XG4gIE1ldGFkYXRhU2NoZW1hW1wiYXVkaW9JZDNcIl0gPSBcIm9yZy5pZDNcIjtcbiAgTWV0YWRhdGFTY2hlbWFbXCJkYXRlUmFuZ2VcIl0gPSBcImNvbS5hcHBsZS5xdWlja3RpbWUuSExTXCI7XG4gIE1ldGFkYXRhU2NoZW1hW1wiZW1zZ1wiXSA9IFwiaHR0cHM6Ly9hb21lZGlhLm9yZy9lbXNnL0lEM1wiO1xuICBNZXRhZGF0YVNjaGVtYVtcIm1pc2JrbHZcIl0gPSBcInVybjptaXNiOktMVjpiaW46MTkxMC4xXCI7XG4gIHJldHVybiBNZXRhZGF0YVNjaGVtYTtcbn0oe30pO1xuXG5mdW5jdGlvbiBkdW1teVRyYWNrKHR5cGUgPSAnJywgaW5wdXRUaW1lU2NhbGUgPSA5MDAwMCkge1xuICByZXR1cm4ge1xuICAgIHR5cGUsXG4gICAgaWQ6IC0xLFxuICAgIHBpZDogLTEsXG4gICAgaW5wdXRUaW1lU2NhbGUsXG4gICAgc2VxdWVuY2VOdW1iZXI6IC0xLFxuICAgIHNhbXBsZXM6IFtdLFxuICAgIGRyb3BwZWQ6IDBcbiAgfTtcbn1cblxuY2xhc3MgQmFzZUF1ZGlvRGVtdXhlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5faWQzVHJhY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5mcmFtZUluZGV4ID0gMDtcbiAgICB0aGlzLmNhY2hlZERhdGEgPSBudWxsO1xuICAgIHRoaXMuYmFzZVBUUyA9IG51bGw7XG4gICAgdGhpcy5pbml0UFRTID0gbnVsbDtcbiAgICB0aGlzLmxhc3RQVFMgPSBudWxsO1xuICB9XG4gIHJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRyYWNrRHVyYXRpb24pIHtcbiAgICB0aGlzLl9pZDNUcmFjayA9IHtcbiAgICAgIHR5cGU6ICdpZDMnLFxuICAgICAgaWQ6IDMsXG4gICAgICBwaWQ6IC0xLFxuICAgICAgaW5wdXRUaW1lU2NhbGU6IDkwMDAwLFxuICAgICAgc2VxdWVuY2VOdW1iZXI6IDAsXG4gICAgICBzYW1wbGVzOiBbXSxcbiAgICAgIGRyb3BwZWQ6IDBcbiAgICB9O1xuICB9XG4gIHJlc2V0VGltZVN0YW1wKGRlYXVsdFRpbWVzdGFtcCkge1xuICAgIHRoaXMuaW5pdFBUUyA9IGRlYXVsdFRpbWVzdGFtcDtcbiAgICB0aGlzLnJlc2V0Q29udGlndWl0eSgpO1xuICB9XG4gIHJlc2V0Q29udGlndWl0eSgpIHtcbiAgICB0aGlzLmJhc2VQVFMgPSBudWxsO1xuICAgIHRoaXMubGFzdFBUUyA9IG51bGw7XG4gICAgdGhpcy5mcmFtZUluZGV4ID0gMDtcbiAgfVxuICBjYW5QYXJzZShkYXRhLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCkge31cblxuICAvLyBmZWVkIGluY29taW5nIGRhdGEgdG8gdGhlIGZyb250IG9mIHRoZSBwYXJzaW5nIHBpcGVsaW5lXG4gIGRlbXV4KGRhdGEsIHRpbWVPZmZzZXQpIHtcbiAgICBpZiAodGhpcy5jYWNoZWREYXRhKSB7XG4gICAgICBkYXRhID0gYXBwZW5kVWludDhBcnJheSh0aGlzLmNhY2hlZERhdGEsIGRhdGEpO1xuICAgICAgdGhpcy5jYWNoZWREYXRhID0gbnVsbDtcbiAgICB9XG4gICAgbGV0IGlkM0RhdGEgPSBnZXRJZDNEYXRhKGRhdGEsIDApO1xuICAgIGxldCBvZmZzZXQgPSBpZDNEYXRhID8gaWQzRGF0YS5sZW5ndGggOiAwO1xuICAgIGxldCBsYXN0RGF0YUluZGV4O1xuICAgIGNvbnN0IHRyYWNrID0gdGhpcy5fYXVkaW9UcmFjaztcbiAgICBjb25zdCBpZDNUcmFjayA9IHRoaXMuX2lkM1RyYWNrO1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IGlkM0RhdGEgPyBnZXRJZDNUaW1lc3RhbXAoaWQzRGF0YSkgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgaWYgKHRoaXMuYmFzZVBUUyA9PT0gbnVsbCB8fCB0aGlzLmZyYW1lSW5kZXggPT09IDAgJiYgaXNGaW5pdGVOdW1iZXIodGltZXN0YW1wKSkge1xuICAgICAgdGhpcy5iYXNlUFRTID0gaW5pdFBUU0ZuKHRpbWVzdGFtcCwgdGltZU9mZnNldCwgdGhpcy5pbml0UFRTKTtcbiAgICAgIHRoaXMubGFzdFBUUyA9IHRoaXMuYmFzZVBUUztcbiAgICB9XG4gICAgaWYgKHRoaXMubGFzdFBUUyA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5sYXN0UFRTID0gdGhpcy5iYXNlUFRTO1xuICAgIH1cblxuICAgIC8vIG1vcmUgZXhwcmVzc2l2ZSB0aGFuIGFsdGVybmF0aXZlOiBpZDNEYXRhPy5sZW5ndGhcbiAgICBpZiAoaWQzRGF0YSAmJiBpZDNEYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgIGlkM1RyYWNrLnNhbXBsZXMucHVzaCh7XG4gICAgICAgIHB0czogdGhpcy5sYXN0UFRTLFxuICAgICAgICBkdHM6IHRoaXMubGFzdFBUUyxcbiAgICAgICAgZGF0YTogaWQzRGF0YSxcbiAgICAgICAgdHlwZTogTWV0YWRhdGFTY2hlbWEuYXVkaW9JZDMsXG4gICAgICAgIGR1cmF0aW9uOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlcbiAgICAgIH0pO1xuICAgIH1cbiAgICB3aGlsZSAob2Zmc2V0IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5jYW5QYXJzZShkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgIGNvbnN0IGZyYW1lID0gdGhpcy5hcHBlbmRGcmFtZSh0cmFjaywgZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgICAgdGhpcy5mcmFtZUluZGV4Kys7XG4gICAgICAgICAgdGhpcy5sYXN0UFRTID0gZnJhbWUuc2FtcGxlLnB0cztcbiAgICAgICAgICBvZmZzZXQgKz0gZnJhbWUubGVuZ3RoO1xuICAgICAgICAgIGxhc3REYXRhSW5kZXggPSBvZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Zmc2V0ID0gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNhblBhcnNlSWQzKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgLy8gYWZ0ZXIgYSBjYW5QYXJzZSwgYSBjYWxsIHRvIGdldElkM0RhdGEgKnNob3VsZCogYWx3YXlzIHJldHVybnMgc29tZSBkYXRhXG4gICAgICAgIGlkM0RhdGEgPSBnZXRJZDNEYXRhKGRhdGEsIG9mZnNldCk7XG4gICAgICAgIGlkM1RyYWNrLnNhbXBsZXMucHVzaCh7XG4gICAgICAgICAgcHRzOiB0aGlzLmxhc3RQVFMsXG4gICAgICAgICAgZHRzOiB0aGlzLmxhc3RQVFMsXG4gICAgICAgICAgZGF0YTogaWQzRGF0YSxcbiAgICAgICAgICB0eXBlOiBNZXRhZGF0YVNjaGVtYS5hdWRpb0lkMyxcbiAgICAgICAgICBkdXJhdGlvbjogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG4gICAgICAgIH0pO1xuICAgICAgICBvZmZzZXQgKz0gaWQzRGF0YS5sZW5ndGg7XG4gICAgICAgIGxhc3REYXRhSW5kZXggPSBvZmZzZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgIH1cbiAgICAgIGlmIChvZmZzZXQgPT09IGxlbmd0aCAmJiBsYXN0RGF0YUluZGV4ICE9PSBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcGFydGlhbERhdGEgPSBkYXRhLnNsaWNlKGxhc3REYXRhSW5kZXgpO1xuICAgICAgICBpZiAodGhpcy5jYWNoZWREYXRhKSB7XG4gICAgICAgICAgdGhpcy5jYWNoZWREYXRhID0gYXBwZW5kVWludDhBcnJheSh0aGlzLmNhY2hlZERhdGEsIHBhcnRpYWxEYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNhY2hlZERhdGEgPSBwYXJ0aWFsRGF0YTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgYXVkaW9UcmFjazogdHJhY2ssXG4gICAgICB2aWRlb1RyYWNrOiBkdW1teVRyYWNrKCksXG4gICAgICBpZDNUcmFjayxcbiAgICAgIHRleHRUcmFjazogZHVtbXlUcmFjaygpXG4gICAgfTtcbiAgfVxuICBkZW11eFNhbXBsZUFlcyhkYXRhLCBrZXlEYXRhLCB0aW1lT2Zmc2V0KSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgWyR7dGhpc31dIFRoaXMgZGVtdXhlciBkb2VzIG5vdCBzdXBwb3J0IFNhbXBsZS1BRVMgZGVjcnlwdGlvbmApKTtcbiAgfVxuICBmbHVzaCh0aW1lT2Zmc2V0KSB7XG4gICAgLy8gUGFyc2UgY2FjaGUgaW4gY2FzZSBvZiByZW1haW5pbmcgZnJhbWVzLlxuICAgIGNvbnN0IGNhY2hlZERhdGEgPSB0aGlzLmNhY2hlZERhdGE7XG4gICAgaWYgKGNhY2hlZERhdGEpIHtcbiAgICAgIHRoaXMuY2FjaGVkRGF0YSA9IG51bGw7XG4gICAgICB0aGlzLmRlbXV4KGNhY2hlZERhdGEsIDApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgYXVkaW9UcmFjazogdGhpcy5fYXVkaW9UcmFjayxcbiAgICAgIHZpZGVvVHJhY2s6IGR1bW15VHJhY2soKSxcbiAgICAgIGlkM1RyYWNrOiB0aGlzLl9pZDNUcmFjayxcbiAgICAgIHRleHRUcmFjazogZHVtbXlUcmFjaygpXG4gICAgfTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuY2FjaGVkRGF0YSA9IG51bGw7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSB0aGlzLl9pZDNUcmFjayA9IHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIEluaXRpYWxpemUgUFRTXG4gKiA8cD5cbiAqICAgIHVzZSB0aW1lc3RhbXAgdW5sZXNzIGl0IGlzIHVuZGVmaW5lZCwgTmFOIG9yIEluZmluaXR5XG4gKiA8L3A+XG4gKi9cbmNvbnN0IGluaXRQVFNGbiA9ICh0aW1lc3RhbXAsIHRpbWVPZmZzZXQsIGluaXRQVFMpID0+IHtcbiAgaWYgKGlzRmluaXRlTnVtYmVyKHRpbWVzdGFtcCkpIHtcbiAgICByZXR1cm4gdGltZXN0YW1wICogOTA7XG4gIH1cbiAgY29uc3QgaW5pdDkwa0h6ID0gaW5pdFBUUyA/IGluaXRQVFMuYmFzZVRpbWUgKiA5MDAwMCAvIGluaXRQVFMudGltZXNjYWxlIDogMDtcbiAgcmV0dXJuIHRpbWVPZmZzZXQgKiA5MDAwMCArIGluaXQ5MGtIejtcbn07XG5cbi8qKlxuICogIE1QRUcgcGFyc2VyIGhlbHBlclxuICovXG5cbmxldCBjaHJvbWVWZXJzaW9uJDEgPSBudWxsO1xuY29uc3QgQml0cmF0ZXNNYXAgPSBbMzIsIDY0LCA5NiwgMTI4LCAxNjAsIDE5MiwgMjI0LCAyNTYsIDI4OCwgMzIwLCAzNTIsIDM4NCwgNDE2LCA0NDgsIDMyLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNjAsIDE5MiwgMjI0LCAyNTYsIDMyMCwgMzg0LCAzMiwgNDAsIDQ4LCA1NiwgNjQsIDgwLCA5NiwgMTEyLCAxMjgsIDE2MCwgMTkyLCAyMjQsIDI1NiwgMzIwLCAzMiwgNDgsIDU2LCA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTQ0LCAxNjAsIDE3NiwgMTkyLCAyMjQsIDI1NiwgOCwgMTYsIDI0LCAzMiwgNDAsIDQ4LCA1NiwgNjQsIDgwLCA5NiwgMTEyLCAxMjgsIDE0NCwgMTYwXTtcbmNvbnN0IFNhbXBsaW5nUmF0ZU1hcCA9IFs0NDEwMCwgNDgwMDAsIDMyMDAwLCAyMjA1MCwgMjQwMDAsIDE2MDAwLCAxMTAyNSwgMTIwMDAsIDgwMDBdO1xuY29uc3QgU2FtcGxlc0NvZWZmaWNpZW50cyA9IFtcbi8vIE1QRUcgMi41XG5bMCxcbi8vIFJlc2VydmVkXG43Mixcbi8vIExheWVyM1xuMTQ0LFxuLy8gTGF5ZXIyXG4xMiAvLyBMYXllcjFcbl0sXG4vLyBSZXNlcnZlZFxuWzAsXG4vLyBSZXNlcnZlZFxuMCxcbi8vIExheWVyM1xuMCxcbi8vIExheWVyMlxuMCAvLyBMYXllcjFcbl0sXG4vLyBNUEVHIDJcblswLFxuLy8gUmVzZXJ2ZWRcbjcyLFxuLy8gTGF5ZXIzXG4xNDQsXG4vLyBMYXllcjJcbjEyIC8vIExheWVyMVxuXSxcbi8vIE1QRUcgMVxuWzAsXG4vLyBSZXNlcnZlZFxuMTQ0LFxuLy8gTGF5ZXIzXG4xNDQsXG4vLyBMYXllcjJcbjEyIC8vIExheWVyMVxuXV07XG5jb25zdCBCeXRlc0luU2xvdCA9IFswLFxuLy8gUmVzZXJ2ZWRcbjEsXG4vLyBMYXllcjNcbjEsXG4vLyBMYXllcjJcbjQgLy8gTGF5ZXIxXG5dO1xuZnVuY3Rpb24gYXBwZW5kRnJhbWUkMSh0cmFjaywgZGF0YSwgb2Zmc2V0LCBwdHMsIGZyYW1lSW5kZXgpIHtcbiAgLy8gVXNpbmcgaHR0cDovL3d3dy5kYXRhdm95YWdlLmNvbS9tcGdzY3JpcHQvbXBlZ2hkci5odG0gYXMgYSByZWZlcmVuY2VcbiAgaWYgKG9mZnNldCArIDI0ID4gZGF0YS5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaGVhZGVyID0gcGFyc2VIZWFkZXIoZGF0YSwgb2Zmc2V0KTtcbiAgaWYgKGhlYWRlciAmJiBvZmZzZXQgKyBoZWFkZXIuZnJhbWVMZW5ndGggPD0gZGF0YS5sZW5ndGgpIHtcbiAgICBjb25zdCBmcmFtZUR1cmF0aW9uID0gaGVhZGVyLnNhbXBsZXNQZXJGcmFtZSAqIDkwMDAwIC8gaGVhZGVyLnNhbXBsZVJhdGU7XG4gICAgY29uc3Qgc3RhbXAgPSBwdHMgKyBmcmFtZUluZGV4ICogZnJhbWVEdXJhdGlvbjtcbiAgICBjb25zdCBzYW1wbGUgPSB7XG4gICAgICB1bml0OiBkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgaGVhZGVyLmZyYW1lTGVuZ3RoKSxcbiAgICAgIHB0czogc3RhbXAsXG4gICAgICBkdHM6IHN0YW1wXG4gICAgfTtcbiAgICB0cmFjay5jb25maWcgPSBbXTtcbiAgICB0cmFjay5jaGFubmVsQ291bnQgPSBoZWFkZXIuY2hhbm5lbENvdW50O1xuICAgIHRyYWNrLnNhbXBsZXJhdGUgPSBoZWFkZXIuc2FtcGxlUmF0ZTtcbiAgICB0cmFjay5zYW1wbGVzLnB1c2goc2FtcGxlKTtcbiAgICByZXR1cm4ge1xuICAgICAgc2FtcGxlLFxuICAgICAgbGVuZ3RoOiBoZWFkZXIuZnJhbWVMZW5ndGgsXG4gICAgICBtaXNzaW5nOiAwXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VIZWFkZXIoZGF0YSwgb2Zmc2V0KSB7XG4gIGNvbnN0IG1wZWdWZXJzaW9uID0gZGF0YVtvZmZzZXQgKyAxXSA+PiAzICYgMztcbiAgY29uc3QgbXBlZ0xheWVyID0gZGF0YVtvZmZzZXQgKyAxXSA+PiAxICYgMztcbiAgY29uc3QgYml0UmF0ZUluZGV4ID0gZGF0YVtvZmZzZXQgKyAyXSA+PiA0ICYgMTU7XG4gIGNvbnN0IHNhbXBsZVJhdGVJbmRleCA9IGRhdGFbb2Zmc2V0ICsgMl0gPj4gMiAmIDM7XG4gIGlmIChtcGVnVmVyc2lvbiAhPT0gMSAmJiBiaXRSYXRlSW5kZXggIT09IDAgJiYgYml0UmF0ZUluZGV4ICE9PSAxNSAmJiBzYW1wbGVSYXRlSW5kZXggIT09IDMpIHtcbiAgICBjb25zdCBwYWRkaW5nQml0ID0gZGF0YVtvZmZzZXQgKyAyXSA+PiAxICYgMTtcbiAgICBjb25zdCBjaGFubmVsTW9kZSA9IGRhdGFbb2Zmc2V0ICsgM10gPj4gNjtcbiAgICBjb25zdCBjb2x1bW5JbkJpdHJhdGVzID0gbXBlZ1ZlcnNpb24gPT09IDMgPyAzIC0gbXBlZ0xheWVyIDogbXBlZ0xheWVyID09PSAzID8gMyA6IDQ7XG4gICAgY29uc3QgYml0UmF0ZSA9IEJpdHJhdGVzTWFwW2NvbHVtbkluQml0cmF0ZXMgKiAxNCArIGJpdFJhdGVJbmRleCAtIDFdICogMTAwMDtcbiAgICBjb25zdCBjb2x1bW5JblNhbXBsZVJhdGVzID0gbXBlZ1ZlcnNpb24gPT09IDMgPyAwIDogbXBlZ1ZlcnNpb24gPT09IDIgPyAxIDogMjtcbiAgICBjb25zdCBzYW1wbGVSYXRlID0gU2FtcGxpbmdSYXRlTWFwW2NvbHVtbkluU2FtcGxlUmF0ZXMgKiAzICsgc2FtcGxlUmF0ZUluZGV4XTtcbiAgICBjb25zdCBjaGFubmVsQ291bnQgPSBjaGFubmVsTW9kZSA9PT0gMyA/IDEgOiAyOyAvLyBJZiBiaXRzIG9mIGNoYW5uZWwgbW9kZSBhcmUgYDExYCB0aGVuIGl0IGlzIGEgc2luZ2xlIGNoYW5uZWwgKE1vbm8pXG4gICAgY29uc3Qgc2FtcGxlQ29lZmZpY2llbnQgPSBTYW1wbGVzQ29lZmZpY2llbnRzW21wZWdWZXJzaW9uXVttcGVnTGF5ZXJdO1xuICAgIGNvbnN0IGJ5dGVzSW5TbG90ID0gQnl0ZXNJblNsb3RbbXBlZ0xheWVyXTtcbiAgICBjb25zdCBzYW1wbGVzUGVyRnJhbWUgPSBzYW1wbGVDb2VmZmljaWVudCAqIDggKiBieXRlc0luU2xvdDtcbiAgICBjb25zdCBmcmFtZUxlbmd0aCA9IE1hdGguZmxvb3Ioc2FtcGxlQ29lZmZpY2llbnQgKiBiaXRSYXRlIC8gc2FtcGxlUmF0ZSArIHBhZGRpbmdCaXQpICogYnl0ZXNJblNsb3Q7XG4gICAgaWYgKGNocm9tZVZlcnNpb24kMSA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJztcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspL2kpO1xuICAgICAgY2hyb21lVmVyc2lvbiQxID0gcmVzdWx0ID8gcGFyc2VJbnQocmVzdWx0WzFdKSA6IDA7XG4gICAgfVxuICAgIGNvbnN0IG5lZWRDaHJvbWVGaXggPSAhIWNocm9tZVZlcnNpb24kMSAmJiBjaHJvbWVWZXJzaW9uJDEgPD0gODc7XG4gICAgaWYgKG5lZWRDaHJvbWVGaXggJiYgbXBlZ0xheWVyID09PSAyICYmIGJpdFJhdGUgPj0gMjI0MDAwICYmIGNoYW5uZWxNb2RlID09PSAwKSB7XG4gICAgICAvLyBXb3JrIGFyb3VuZCBidWcgaW4gQ2hyb21pdW0gYnkgc2V0dGluZyBjaGFubmVsTW9kZSB0byBkdWFsLWNoYW5uZWwgKDAxKSBpbnN0ZWFkIG9mIHN0ZXJlbyAoMDApXG4gICAgICBkYXRhW29mZnNldCArIDNdID0gZGF0YVtvZmZzZXQgKyAzXSB8IDB4ODA7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzYW1wbGVSYXRlLFxuICAgICAgY2hhbm5lbENvdW50LFxuICAgICAgZnJhbWVMZW5ndGgsXG4gICAgICBzYW1wbGVzUGVyRnJhbWVcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBpc0hlYWRlclBhdHRlcm4oZGF0YSwgb2Zmc2V0KSB7XG4gIHJldHVybiBkYXRhW29mZnNldF0gPT09IDB4ZmYgJiYgKGRhdGFbb2Zmc2V0ICsgMV0gJiAweGUwKSA9PT0gMHhlMCAmJiAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4MDYpICE9PSAweDAwO1xufVxuZnVuY3Rpb24gaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSB7XG4gIC8vIExvb2sgZm9yIE1QRUcgaGVhZGVyIHwgMTExMSAxMTExIHwgMTExWCBYWVpYIHwgd2hlcmUgWCBjYW4gYmUgZWl0aGVyIDAgb3IgMSBhbmQgWSBvciBaIHNob3VsZCBiZSAxXG4gIC8vIExheWVyIGJpdHMgKHBvc2l0aW9uIDE0IGFuZCAxNSkgaW4gaGVhZGVyIHNob3VsZCBiZSBhbHdheXMgZGlmZmVyZW50IGZyb20gMCAoTGF5ZXIgSSBvciBMYXllciBJSSBvciBMYXllciBJSUkpXG4gIC8vIE1vcmUgaW5mbyBodHRwOi8vd3d3Lm1wMy10ZWNoLm9yZy9wcm9ncmFtbWVyL2ZyYW1lX2hlYWRlci5odG1sXG4gIHJldHVybiBvZmZzZXQgKyAxIDwgZGF0YS5sZW5ndGggJiYgaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG9mZnNldCk7XG59XG5mdW5jdGlvbiBjYW5QYXJzZShkYXRhLCBvZmZzZXQpIHtcbiAgY29uc3QgaGVhZGVyU2l6ZSA9IDQ7XG4gIHJldHVybiBpc0hlYWRlclBhdHRlcm4oZGF0YSwgb2Zmc2V0KSAmJiBoZWFkZXJTaXplIDw9IGRhdGEubGVuZ3RoIC0gb2Zmc2V0O1xufVxuZnVuY3Rpb24gcHJvYmUoZGF0YSwgb2Zmc2V0KSB7XG4gIC8vIHNhbWUgYXMgaXNIZWFkZXIgYnV0IHdlIGFsc28gY2hlY2sgdGhhdCBNUEVHIGZyYW1lIGZvbGxvd3MgbGFzdCBNUEVHIGZyYW1lXG4gIC8vIG9yIGVuZCBvZiBkYXRhIGlzIHJlYWNoZWRcbiAgaWYgKG9mZnNldCArIDEgPCBkYXRhLmxlbmd0aCAmJiBpc0hlYWRlclBhdHRlcm4oZGF0YSwgb2Zmc2V0KSkge1xuICAgIC8vIE1QRUcgaGVhZGVyIExlbmd0aFxuICAgIGNvbnN0IGhlYWRlckxlbmd0aCA9IDQ7XG4gICAgLy8gTVBFRyBmcmFtZSBMZW5ndGhcbiAgICBjb25zdCBoZWFkZXIgPSBwYXJzZUhlYWRlcihkYXRhLCBvZmZzZXQpO1xuICAgIGxldCBmcmFtZUxlbmd0aCA9IGhlYWRlckxlbmd0aDtcbiAgICBpZiAoaGVhZGVyICE9IG51bGwgJiYgaGVhZGVyLmZyYW1lTGVuZ3RoKSB7XG4gICAgICBmcmFtZUxlbmd0aCA9IGhlYWRlci5mcmFtZUxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgbmV3T2Zmc2V0ID0gb2Zmc2V0ICsgZnJhbWVMZW5ndGg7XG4gICAgcmV0dXJuIG5ld09mZnNldCA9PT0gZGF0YS5sZW5ndGggfHwgaXNIZWFkZXIoZGF0YSwgbmV3T2Zmc2V0KTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQUFDIGRlbXV4ZXJcbiAqL1xuY2xhc3MgQUFDRGVtdXhlciBleHRlbmRzIEJhc2VBdWRpb0RlbXV4ZXIge1xuICBjb25zdHJ1Y3RvcihvYnNlcnZlciwgY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm9ic2VydmVyID0gdm9pZCAwO1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgfVxuICByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0cmFja0R1cmF0aW9uKSB7XG4gICAgc3VwZXIucmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbik7XG4gICAgdGhpcy5fYXVkaW9UcmFjayA9IHtcbiAgICAgIGNvbnRhaW5lcjogJ2F1ZGlvL2FkdHMnLFxuICAgICAgdHlwZTogJ2F1ZGlvJyxcbiAgICAgIGlkOiAyLFxuICAgICAgcGlkOiAtMSxcbiAgICAgIHNlcXVlbmNlTnVtYmVyOiAwLFxuICAgICAgc2VnbWVudENvZGVjOiAnYWFjJyxcbiAgICAgIHNhbXBsZXM6IFtdLFxuICAgICAgbWFuaWZlc3RDb2RlYzogYXVkaW9Db2RlYyxcbiAgICAgIGR1cmF0aW9uOiB0cmFja0R1cmF0aW9uLFxuICAgICAgaW5wdXRUaW1lU2NhbGU6IDkwMDAwLFxuICAgICAgZHJvcHBlZDogMFxuICAgIH07XG4gIH1cblxuICAvLyBTb3VyY2UgZm9yIHByb2JlIGluZm8gLSBodHRwczovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9QURUU1xuICBzdGF0aWMgcHJvYmUoZGF0YSwgbG9nZ2VyKSB7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIHRoZSBBRFRTIHN5bmMgd29yZFxuICAgIC8vIExvb2sgZm9yIEFEVFMgaGVhZGVyIHwgMTExMSAxMTExIHwgMTExMSBYMDBYIHwgd2hlcmUgWCBjYW4gYmUgZWl0aGVyIDAgb3IgMVxuICAgIC8vIExheWVyIGJpdHMgKHBvc2l0aW9uIDE0IGFuZCAxNSkgaW4gaGVhZGVyIHNob3VsZCBiZSBhbHdheXMgMCBmb3IgQURUU1xuICAgIC8vIE1vcmUgaW5mbyBodHRwczovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9QURUU1xuICAgIGNvbnN0IGlkM0RhdGEgPSBnZXRJZDNEYXRhKGRhdGEsIDApO1xuICAgIGxldCBvZmZzZXQgPSAoaWQzRGF0YSA9PSBudWxsID8gdm9pZCAwIDogaWQzRGF0YS5sZW5ndGgpIHx8IDA7XG4gICAgaWYgKHByb2JlKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgbGVuZ3RoID0gZGF0YS5sZW5ndGg7IG9mZnNldCA8IGxlbmd0aDsgb2Zmc2V0KyspIHtcbiAgICAgIGlmIChwcm9iZSQxKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnQURUUyBzeW5jIHdvcmQgZm91bmQgIScpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNhblBhcnNlKGRhdGEsIG9mZnNldCkge1xuICAgIHJldHVybiBjYW5QYXJzZSQxKGRhdGEsIG9mZnNldCk7XG4gIH1cbiAgYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCkge1xuICAgIGluaXRUcmFja0NvbmZpZyh0cmFjaywgdGhpcy5vYnNlcnZlciwgZGF0YSwgb2Zmc2V0LCB0cmFjay5tYW5pZmVzdENvZGVjKTtcbiAgICBjb25zdCBmcmFtZSA9IGFwcGVuZEZyYW1lJDIodHJhY2ssIGRhdGEsIG9mZnNldCwgdGhpcy5iYXNlUFRTLCB0aGlzLmZyYW1lSW5kZXgpO1xuICAgIGlmIChmcmFtZSAmJiBmcmFtZS5taXNzaW5nID09PSAwKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IGdldEF1ZGlvQlNJRCA9IChkYXRhLCBvZmZzZXQpID0+IHtcbiAgLy8gY2hlY2sgdGhlIGJzaWQgdG8gY29uZmlybSBhYy0zIHwgZWMtM1xuICBsZXQgYnNpZCA9IDA7XG4gIGxldCBudW1CaXRzID0gNTtcbiAgb2Zmc2V0ICs9IG51bUJpdHM7XG4gIGNvbnN0IHRlbXAgPSBuZXcgVWludDMyQXJyYXkoMSk7IC8vIHVuc2lnbmVkIDMyIGJpdCBmb3IgdGVtcG9yYXJ5IHN0b3JhZ2VcbiAgY29uc3QgbWFzayA9IG5ldyBVaW50MzJBcnJheSgxKTsgLy8gdW5zaWduZWQgMzIgYml0IG1hc2sgdmFsdWVcbiAgY29uc3QgYnl0ZSA9IG5ldyBVaW50OEFycmF5KDEpOyAvLyB1bnNpZ25lZCA4IGJpdCBmb3IgdGVtcG9yYXJ5IHN0b3JhZ2VcbiAgd2hpbGUgKG51bUJpdHMgPiAwKSB7XG4gICAgYnl0ZVswXSA9IGRhdGFbb2Zmc2V0XTtcbiAgICAvLyByZWFkIHJlbWFpbmluZyBiaXRzLCB1cHRvIDggYml0cyBhdCBhIHRpbWVcbiAgICBjb25zdCBiaXRzID0gTWF0aC5taW4obnVtQml0cywgOCk7XG4gICAgY29uc3Qgc2hpZnQgPSA4IC0gYml0cztcbiAgICBtYXNrWzBdID0gMHhmZjAwMDAwMCA+Pj4gMjQgKyBzaGlmdCA8PCBzaGlmdDtcbiAgICB0ZW1wWzBdID0gKGJ5dGVbMF0gJiBtYXNrWzBdKSA+PiBzaGlmdDtcbiAgICBic2lkID0gIWJzaWQgPyB0ZW1wWzBdIDogYnNpZCA8PCBiaXRzIHwgdGVtcFswXTtcbiAgICBvZmZzZXQgKz0gMTtcbiAgICBudW1CaXRzIC09IGJpdHM7XG4gIH1cbiAgcmV0dXJuIGJzaWQ7XG59O1xuXG5jbGFzcyBBQzNEZW11eGVyIGV4dGVuZHMgQmFzZUF1ZGlvRGVtdXhlciB7XG4gIGNvbnN0cnVjdG9yKG9ic2VydmVyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm9ic2VydmVyID0gdm9pZCAwO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgfVxuICByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0cmFja0R1cmF0aW9uKSB7XG4gICAgc3VwZXIucmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbik7XG4gICAgdGhpcy5fYXVkaW9UcmFjayA9IHtcbiAgICAgIGNvbnRhaW5lcjogJ2F1ZGlvL2FjLTMnLFxuICAgICAgdHlwZTogJ2F1ZGlvJyxcbiAgICAgIGlkOiAyLFxuICAgICAgcGlkOiAtMSxcbiAgICAgIHNlcXVlbmNlTnVtYmVyOiAwLFxuICAgICAgc2VnbWVudENvZGVjOiAnYWMzJyxcbiAgICAgIHNhbXBsZXM6IFtdLFxuICAgICAgbWFuaWZlc3RDb2RlYzogYXVkaW9Db2RlYyxcbiAgICAgIGR1cmF0aW9uOiB0cmFja0R1cmF0aW9uLFxuICAgICAgaW5wdXRUaW1lU2NhbGU6IDkwMDAwLFxuICAgICAgZHJvcHBlZDogMFxuICAgIH07XG4gIH1cbiAgY2FuUGFyc2UoZGF0YSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIG9mZnNldCArIDY0IDwgZGF0YS5sZW5ndGg7XG4gIH1cbiAgYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCkge1xuICAgIGNvbnN0IGZyYW1lTGVuZ3RoID0gYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCwgdGhpcy5iYXNlUFRTLCB0aGlzLmZyYW1lSW5kZXgpO1xuICAgIGlmIChmcmFtZUxlbmd0aCAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IHNhbXBsZSA9IHRyYWNrLnNhbXBsZXNbdHJhY2suc2FtcGxlcy5sZW5ndGggLSAxXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNhbXBsZSxcbiAgICAgICAgbGVuZ3RoOiBmcmFtZUxlbmd0aCxcbiAgICAgICAgbWlzc2luZzogMFxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIHByb2JlKGRhdGEpIHtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgaWQzRGF0YSA9IGdldElkM0RhdGEoZGF0YSwgMCk7XG4gICAgaWYgKCFpZDNEYXRhKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gbG9vayBmb3IgdGhlIGFjLTMgc3luYyBieXRlc1xuICAgIGNvbnN0IG9mZnNldCA9IGlkM0RhdGEubGVuZ3RoO1xuICAgIGlmIChkYXRhW29mZnNldF0gPT09IDB4MGIgJiYgZGF0YVtvZmZzZXQgKyAxXSA9PT0gMHg3NyAmJiBnZXRJZDNUaW1lc3RhbXAoaWQzRGF0YSkgIT09IHVuZGVmaW5lZCAmJlxuICAgIC8vIGNoZWNrIHRoZSBic2lkIHRvIGNvbmZpcm0gYWMtM1xuICAgIGdldEF1ZGlvQlNJRChkYXRhLCBvZmZzZXQpIDwgMTYpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBzdGFydCwgcHRzLCBmcmFtZUluZGV4KSB7XG4gIGlmIChzdGFydCArIDggPiBkYXRhLmxlbmd0aCkge1xuICAgIHJldHVybiAtMTsgLy8gbm90IGVub3VnaCBieXRlcyBsZWZ0XG4gIH1cbiAgaWYgKGRhdGFbc3RhcnRdICE9PSAweDBiIHx8IGRhdGFbc3RhcnQgKyAxXSAhPT0gMHg3Nykge1xuICAgIHJldHVybiAtMTsgLy8gaW52YWxpZCBtYWdpY1xuICB9XG5cbiAgLy8gZ2V0IHNhbXBsZSByYXRlXG4gIGNvbnN0IHNhbXBsaW5nUmF0ZUNvZGUgPSBkYXRhW3N0YXJ0ICsgNF0gPj4gNjtcbiAgaWYgKHNhbXBsaW5nUmF0ZUNvZGUgPj0gMykge1xuICAgIHJldHVybiAtMTsgLy8gaW52YWxpZCBzYW1wbGluZyByYXRlXG4gIH1cbiAgY29uc3Qgc2FtcGxpbmdSYXRlTWFwID0gWzQ4MDAwLCA0NDEwMCwgMzIwMDBdO1xuICBjb25zdCBzYW1wbGVSYXRlID0gc2FtcGxpbmdSYXRlTWFwW3NhbXBsaW5nUmF0ZUNvZGVdO1xuXG4gIC8vIGdldCBmcmFtZSBzaXplXG4gIGNvbnN0IGZyYW1lU2l6ZUNvZGUgPSBkYXRhW3N0YXJ0ICsgNF0gJiAweDNmO1xuICBjb25zdCBmcmFtZVNpemVNYXAgPSBbNjQsIDY5LCA5NiwgNjQsIDcwLCA5NiwgODAsIDg3LCAxMjAsIDgwLCA4OCwgMTIwLCA5NiwgMTA0LCAxNDQsIDk2LCAxMDUsIDE0NCwgMTEyLCAxMjEsIDE2OCwgMTEyLCAxMjIsIDE2OCwgMTI4LCAxMzksIDE5MiwgMTI4LCAxNDAsIDE5MiwgMTYwLCAxNzQsIDI0MCwgMTYwLCAxNzUsIDI0MCwgMTkyLCAyMDgsIDI4OCwgMTkyLCAyMDksIDI4OCwgMjI0LCAyNDMsIDMzNiwgMjI0LCAyNDQsIDMzNiwgMjU2LCAyNzgsIDM4NCwgMjU2LCAyNzksIDM4NCwgMzIwLCAzNDgsIDQ4MCwgMzIwLCAzNDksIDQ4MCwgMzg0LCA0MTcsIDU3NiwgMzg0LCA0MTgsIDU3NiwgNDQ4LCA0ODcsIDY3MiwgNDQ4LCA0ODgsIDY3MiwgNTEyLCA1NTcsIDc2OCwgNTEyLCA1NTgsIDc2OCwgNjQwLCA2OTYsIDk2MCwgNjQwLCA2OTcsIDk2MCwgNzY4LCA4MzUsIDExNTIsIDc2OCwgODM2LCAxMTUyLCA4OTYsIDk3NSwgMTM0NCwgODk2LCA5NzYsIDEzNDQsIDEwMjQsIDExMTQsIDE1MzYsIDEwMjQsIDExMTUsIDE1MzYsIDExNTIsIDEyNTMsIDE3MjgsIDExNTIsIDEyNTQsIDE3MjgsIDEyODAsIDEzOTMsIDE5MjAsIDEyODAsIDEzOTQsIDE5MjBdO1xuICBjb25zdCBmcmFtZUxlbmd0aCA9IGZyYW1lU2l6ZU1hcFtmcmFtZVNpemVDb2RlICogMyArIHNhbXBsaW5nUmF0ZUNvZGVdICogMjtcbiAgaWYgKHN0YXJ0ICsgZnJhbWVMZW5ndGggPiBkYXRhLmxlbmd0aCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8vIGdldCBjaGFubmVsIGNvdW50XG4gIGNvbnN0IGNoYW5uZWxNb2RlID0gZGF0YVtzdGFydCArIDZdID4+IDU7XG4gIGxldCBza2lwQ291bnQgPSAwO1xuICBpZiAoY2hhbm5lbE1vZGUgPT09IDIpIHtcbiAgICBza2lwQ291bnQgKz0gMjtcbiAgfSBlbHNlIHtcbiAgICBpZiAoY2hhbm5lbE1vZGUgJiAxICYmIGNoYW5uZWxNb2RlICE9PSAxKSB7XG4gICAgICBza2lwQ291bnQgKz0gMjtcbiAgICB9XG4gICAgaWYgKGNoYW5uZWxNb2RlICYgNCkge1xuICAgICAgc2tpcENvdW50ICs9IDI7XG4gICAgfVxuICB9XG4gIGNvbnN0IGxmZW9uID0gKGRhdGFbc3RhcnQgKyA2XSA8PCA4IHwgZGF0YVtzdGFydCArIDddKSA+PiAxMiAtIHNraXBDb3VudCAmIDE7XG4gIGNvbnN0IGNoYW5uZWxzTWFwID0gWzIsIDEsIDIsIDMsIDMsIDQsIDQsIDVdO1xuICBjb25zdCBjaGFubmVsQ291bnQgPSBjaGFubmVsc01hcFtjaGFubmVsTW9kZV0gKyBsZmVvbjtcblxuICAvLyBidWlsZCBkYWMzIGJveFxuICBjb25zdCBic2lkID0gZGF0YVtzdGFydCArIDVdID4+IDM7XG4gIGNvbnN0IGJzbW9kID0gZGF0YVtzdGFydCArIDVdICYgNztcbiAgY29uc3QgY29uZmlnID0gbmV3IFVpbnQ4QXJyYXkoW3NhbXBsaW5nUmF0ZUNvZGUgPDwgNiB8IGJzaWQgPDwgMSB8IGJzbW9kID4+IDIsIChic21vZCAmIDMpIDw8IDYgfCBjaGFubmVsTW9kZSA8PCAzIHwgbGZlb24gPDwgMiB8IGZyYW1lU2l6ZUNvZGUgPj4gNCwgZnJhbWVTaXplQ29kZSA8PCA0ICYgMHhlMF0pO1xuICBjb25zdCBmcmFtZUR1cmF0aW9uID0gMTUzNiAvIHNhbXBsZVJhdGUgKiA5MDAwMDtcbiAgY29uc3Qgc3RhbXAgPSBwdHMgKyBmcmFtZUluZGV4ICogZnJhbWVEdXJhdGlvbjtcbiAgY29uc3QgdW5pdCA9IGRhdGEuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgZnJhbWVMZW5ndGgpO1xuICB0cmFjay5jb25maWcgPSBjb25maWc7XG4gIHRyYWNrLmNoYW5uZWxDb3VudCA9IGNoYW5uZWxDb3VudDtcbiAgdHJhY2suc2FtcGxlcmF0ZSA9IHNhbXBsZVJhdGU7XG4gIHRyYWNrLnNhbXBsZXMucHVzaCh7XG4gICAgdW5pdCxcbiAgICBwdHM6IHN0YW1wXG4gIH0pO1xuICByZXR1cm4gZnJhbWVMZW5ndGg7XG59XG5cbi8qKlxuICogTVAzIGRlbXV4ZXJcbiAqL1xuY2xhc3MgTVAzRGVtdXhlciBleHRlbmRzIEJhc2VBdWRpb0RlbXV4ZXIge1xuICByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0cmFja0R1cmF0aW9uKSB7XG4gICAgc3VwZXIucmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbik7XG4gICAgdGhpcy5fYXVkaW9UcmFjayA9IHtcbiAgICAgIGNvbnRhaW5lcjogJ2F1ZGlvL21wZWcnLFxuICAgICAgdHlwZTogJ2F1ZGlvJyxcbiAgICAgIGlkOiAyLFxuICAgICAgcGlkOiAtMSxcbiAgICAgIHNlcXVlbmNlTnVtYmVyOiAwLFxuICAgICAgc2VnbWVudENvZGVjOiAnbXAzJyxcbiAgICAgIHNhbXBsZXM6IFtdLFxuICAgICAgbWFuaWZlc3RDb2RlYzogYXVkaW9Db2RlYyxcbiAgICAgIGR1cmF0aW9uOiB0cmFja0R1cmF0aW9uLFxuICAgICAgaW5wdXRUaW1lU2NhbGU6IDkwMDAwLFxuICAgICAgZHJvcHBlZDogMFxuICAgIH07XG4gIH1cbiAgc3RhdGljIHByb2JlKGRhdGEpIHtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiBkYXRhIGNvbnRhaW5zIElEMyB0aW1lc3RhbXAgYW5kIE1QRUcgc3luYyB3b3JkXG4gICAgLy8gTG9vayBmb3IgTVBFRyBoZWFkZXIgfCAxMTExIDExMTEgfCAxMTFYIFhZWlggfCB3aGVyZSBYIGNhbiBiZSBlaXRoZXIgMCBvciAxIGFuZCBZIG9yIFogc2hvdWxkIGJlIDFcbiAgICAvLyBMYXllciBiaXRzIChwb3NpdGlvbiAxNCBhbmQgMTUpIGluIGhlYWRlciBzaG91bGQgYmUgYWx3YXlzIGRpZmZlcmVudCBmcm9tIDAgKExheWVyIEkgb3IgTGF5ZXIgSUkgb3IgTGF5ZXIgSUlJKVxuICAgIC8vIE1vcmUgaW5mbyBodHRwOi8vd3d3Lm1wMy10ZWNoLm9yZy9wcm9ncmFtbWVyL2ZyYW1lX2hlYWRlci5odG1sXG4gICAgY29uc3QgaWQzRGF0YSA9IGdldElkM0RhdGEoZGF0YSwgMCk7XG4gICAgbGV0IG9mZnNldCA9IChpZDNEYXRhID09IG51bGwgPyB2b2lkIDAgOiBpZDNEYXRhLmxlbmd0aCkgfHwgMDtcblxuICAgIC8vIENoZWNrIGZvciBhYy0zfGVjLTMgc3luYyBieXRlcyBhbmQgcmV0dXJuIGZhbHNlIGlmIHByZXNlbnRcbiAgICBpZiAoaWQzRGF0YSAmJiBkYXRhW29mZnNldF0gPT09IDB4MGIgJiYgZGF0YVtvZmZzZXQgKyAxXSA9PT0gMHg3NyAmJiBnZXRJZDNUaW1lc3RhbXAoaWQzRGF0YSkgIT09IHVuZGVmaW5lZCAmJlxuICAgIC8vIGNoZWNrIHRoZSBic2lkIHRvIGNvbmZpcm0gYWMtMyBvciBlYy0zIChub3QgbXAzKVxuICAgIGdldEF1ZGlvQlNJRChkYXRhLCBvZmZzZXQpIDw9IDE2KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGxlbmd0aCA9IGRhdGEubGVuZ3RoOyBvZmZzZXQgPCBsZW5ndGg7IG9mZnNldCsrKSB7XG4gICAgICBpZiAocHJvYmUoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICBsb2dnZXIubG9nKCdNUEVHIEF1ZGlvIHN5bmMgd29yZCBmb3VuZCAhJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY2FuUGFyc2UoZGF0YSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGNhblBhcnNlKGRhdGEsIG9mZnNldCk7XG4gIH1cbiAgYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCkge1xuICAgIGlmICh0aGlzLmJhc2VQVFMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIGFwcGVuZEZyYW1lJDEodHJhY2ssIGRhdGEsIG9mZnNldCwgdGhpcy5iYXNlUFRTLCB0aGlzLmZyYW1lSW5kZXgpO1xuICB9XG59XG5cbmNvbnN0IGVtc2dTY2hlbWVQYXR0ZXJuID0gL1xcL2Vtc2dbLS9dSUQzL2k7XG5jbGFzcyBNUDREZW11eGVyIHtcbiAgY29uc3RydWN0b3Iob2JzZXJ2ZXIsIGNvbmZpZykge1xuICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgdGhpcy50aW1lT2Zmc2V0ID0gMDtcbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLnZpZGVvVHJhY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5hdWRpb1RyYWNrID0gdm9pZCAwO1xuICAgIHRoaXMuaWQzVHJhY2sgPSB2b2lkIDA7XG4gICAgdGhpcy50eHRUcmFjayA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgfVxuICByZXNldFRpbWVTdGFtcCgpIHt9XG4gIHJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRyYWNrRHVyYXRpb24pIHtcbiAgICBjb25zdCB2aWRlb1RyYWNrID0gdGhpcy52aWRlb1RyYWNrID0gZHVtbXlUcmFjaygndmlkZW8nLCAxKTtcbiAgICBjb25zdCBhdWRpb1RyYWNrID0gdGhpcy5hdWRpb1RyYWNrID0gZHVtbXlUcmFjaygnYXVkaW8nLCAxKTtcbiAgICBjb25zdCBjYXB0aW9uVHJhY2sgPSB0aGlzLnR4dFRyYWNrID0gZHVtbXlUcmFjaygndGV4dCcsIDEpO1xuICAgIHRoaXMuaWQzVHJhY2sgPSBkdW1teVRyYWNrKCdpZDMnLCAxKTtcbiAgICB0aGlzLnRpbWVPZmZzZXQgPSAwO1xuICAgIGlmICghKGluaXRTZWdtZW50ICE9IG51bGwgJiYgaW5pdFNlZ21lbnQuYnl0ZUxlbmd0aCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5pdERhdGEgPSBwYXJzZUluaXRTZWdtZW50KGluaXRTZWdtZW50KTtcbiAgICBpZiAoaW5pdERhdGEudmlkZW8pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaWQsXG4gICAgICAgIHRpbWVzY2FsZSxcbiAgICAgICAgY29kZWMsXG4gICAgICAgIHN1cHBsZW1lbnRhbFxuICAgICAgfSA9IGluaXREYXRhLnZpZGVvO1xuICAgICAgdmlkZW9UcmFjay5pZCA9IGlkO1xuICAgICAgdmlkZW9UcmFjay50aW1lc2NhbGUgPSBjYXB0aW9uVHJhY2sudGltZXNjYWxlID0gdGltZXNjYWxlO1xuICAgICAgdmlkZW9UcmFjay5jb2RlYyA9IGNvZGVjO1xuICAgICAgdmlkZW9UcmFjay5zdXBwbGVtZW50YWwgPSBzdXBwbGVtZW50YWw7XG4gICAgfVxuICAgIGlmIChpbml0RGF0YS5hdWRpbykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBpZCxcbiAgICAgICAgdGltZXNjYWxlLFxuICAgICAgICBjb2RlY1xuICAgICAgfSA9IGluaXREYXRhLmF1ZGlvO1xuICAgICAgYXVkaW9UcmFjay5pZCA9IGlkO1xuICAgICAgYXVkaW9UcmFjay50aW1lc2NhbGUgPSB0aW1lc2NhbGU7XG4gICAgICBhdWRpb1RyYWNrLmNvZGVjID0gY29kZWM7XG4gICAgfVxuICAgIGNhcHRpb25UcmFjay5pZCA9IFJlbXV4ZXJUcmFja0lkQ29uZmlnLnRleHQ7XG4gICAgdmlkZW9UcmFjay5zYW1wbGVEdXJhdGlvbiA9IDA7XG4gICAgdmlkZW9UcmFjay5kdXJhdGlvbiA9IGF1ZGlvVHJhY2suZHVyYXRpb24gPSB0cmFja0R1cmF0aW9uO1xuICB9XG4gIHJlc2V0Q29udGlndWl0eSgpIHtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICB9XG4gIHN0YXRpYyBwcm9iZShkYXRhKSB7XG4gICAgcmV0dXJuIGhhc01vb2ZEYXRhKGRhdGEpO1xuICB9XG4gIGRlbXV4KGRhdGEsIHRpbWVPZmZzZXQpIHtcbiAgICB0aGlzLnRpbWVPZmZzZXQgPSB0aW1lT2Zmc2V0O1xuICAgIC8vIExvYWQgYWxsIGRhdGEgaW50byB0aGUgYXZjIHRyYWNrLiBUaGUgQ01BRiByZW11eGVyIHdpbGwgbG9vayBmb3IgdGhlIGRhdGEgaW4gdGhlIHNhbXBsZXMgb2JqZWN0OyB0aGUgcmVzdCBvZiB0aGUgZmllbGRzIGRvIG5vdCBtYXR0ZXJcbiAgICBsZXQgdmlkZW9TYW1wbGVzID0gZGF0YTtcbiAgICBjb25zdCB2aWRlb1RyYWNrID0gdGhpcy52aWRlb1RyYWNrO1xuICAgIGNvbnN0IHRleHRUcmFjayA9IHRoaXMudHh0VHJhY2s7XG4gICAgaWYgKHRoaXMuY29uZmlnLnByb2dyZXNzaXZlKSB7XG4gICAgICAvLyBTcGxpdCB0aGUgYnl0ZXN0cmVhbSBpbnRvIHR3byByYW5nZXM6IG9uZSBlbmNvbXBhc3NpbmcgYWxsIGRhdGEgdXAgdW50aWwgdGhlIHN0YXJ0IG9mIHRoZSBsYXN0IG1vb2YsIGFuZCBldmVyeXRoaW5nIGVsc2UuXG4gICAgICAvLyBUaGlzIGlzIGRvbmUgdG8gZ3VhcmFudGVlIHRoYXQgd2UncmUgc2VuZGluZyB2YWxpZCBkYXRhIHRvIE1TRSAtIHdoZW4gZGVtdXhpbmcgcHJvZ3Jlc3NpdmVseSwgd2UgaGF2ZSBubyBndWFyYW50ZWVcbiAgICAgIC8vIHRoYXQgdGhlIGZldGNoIGxvYWRlciBnaXZlcyB1cyBmbHVzaCBtb29mK21kYXQgcGFpcnMuIElmIHdlIHB1c2ggamFnZ2VkIGRhdGEgdG8gTVNFLCBpdCB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbi5cbiAgICAgIGlmICh0aGlzLnJlbWFpbmRlckRhdGEpIHtcbiAgICAgICAgdmlkZW9TYW1wbGVzID0gYXBwZW5kVWludDhBcnJheSh0aGlzLnJlbWFpbmRlckRhdGEsIGRhdGEpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2VnbWVudGVkRGF0YSA9IHNlZ21lbnRWYWxpZFJhbmdlKHZpZGVvU2FtcGxlcyk7XG4gICAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBzZWdtZW50ZWREYXRhLnJlbWFpbmRlcjtcbiAgICAgIHZpZGVvVHJhY2suc2FtcGxlcyA9IHNlZ21lbnRlZERhdGEudmFsaWQgfHwgbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmlkZW9UcmFjay5zYW1wbGVzID0gdmlkZW9TYW1wbGVzO1xuICAgIH1cbiAgICBjb25zdCBpZDNUcmFjayA9IHRoaXMuZXh0cmFjdElEM1RyYWNrKHZpZGVvVHJhY2ssIHRpbWVPZmZzZXQpO1xuICAgIHRleHRUcmFjay5zYW1wbGVzID0gcGFyc2VTYW1wbGVzKHRpbWVPZmZzZXQsIHZpZGVvVHJhY2spO1xuICAgIHJldHVybiB7XG4gICAgICB2aWRlb1RyYWNrLFxuICAgICAgYXVkaW9UcmFjazogdGhpcy5hdWRpb1RyYWNrLFxuICAgICAgaWQzVHJhY2ssXG4gICAgICB0ZXh0VHJhY2s6IHRoaXMudHh0VHJhY2tcbiAgICB9O1xuICB9XG4gIGZsdXNoKCkge1xuICAgIGNvbnN0IHRpbWVPZmZzZXQgPSB0aGlzLnRpbWVPZmZzZXQ7XG4gICAgY29uc3QgdmlkZW9UcmFjayA9IHRoaXMudmlkZW9UcmFjaztcbiAgICBjb25zdCB0ZXh0VHJhY2sgPSB0aGlzLnR4dFRyYWNrO1xuICAgIHZpZGVvVHJhY2suc2FtcGxlcyA9IHRoaXMucmVtYWluZGVyRGF0YSB8fCBuZXcgVWludDhBcnJheSgpO1xuICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgY29uc3QgaWQzVHJhY2sgPSB0aGlzLmV4dHJhY3RJRDNUcmFjayh2aWRlb1RyYWNrLCB0aGlzLnRpbWVPZmZzZXQpO1xuICAgIHRleHRUcmFjay5zYW1wbGVzID0gcGFyc2VTYW1wbGVzKHRpbWVPZmZzZXQsIHZpZGVvVHJhY2spO1xuICAgIHJldHVybiB7XG4gICAgICB2aWRlb1RyYWNrLFxuICAgICAgYXVkaW9UcmFjazogZHVtbXlUcmFjaygpLFxuICAgICAgaWQzVHJhY2ssXG4gICAgICB0ZXh0VHJhY2s6IGR1bW15VHJhY2soKVxuICAgIH07XG4gIH1cbiAgZXh0cmFjdElEM1RyYWNrKHZpZGVvVHJhY2ssIHRpbWVPZmZzZXQpIHtcbiAgICBjb25zdCBpZDNUcmFjayA9IHRoaXMuaWQzVHJhY2s7XG4gICAgaWYgKHZpZGVvVHJhY2suc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGVtc2dzID0gZmluZEJveCh2aWRlb1RyYWNrLnNhbXBsZXMsIFsnZW1zZyddKTtcbiAgICAgIGlmIChlbXNncykge1xuICAgICAgICBlbXNncy5mb3JFYWNoKGRhdGEgPT4ge1xuICAgICAgICAgIGNvbnN0IGVtc2dJbmZvID0gcGFyc2VFbXNnKGRhdGEpO1xuICAgICAgICAgIGlmIChlbXNnU2NoZW1lUGF0dGVybi50ZXN0KGVtc2dJbmZvLnNjaGVtZUlkVXJpKSkge1xuICAgICAgICAgICAgY29uc3QgcHRzID0gZ2V0RW1zZ1N0YXJ0VGltZShlbXNnSW5mbywgdGltZU9mZnNldCk7XG4gICAgICAgICAgICBsZXQgZHVyYXRpb24gPSBlbXNnSW5mby5ldmVudER1cmF0aW9uID09PSAweGZmZmZmZmZmID8gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIDogZW1zZ0luZm8uZXZlbnREdXJhdGlvbiAvIGVtc2dJbmZvLnRpbWVTY2FsZTtcbiAgICAgICAgICAgIC8vIFNhZmFyaSB0YWtlcyBhbnl0aGluZyA8PSAwLjAwMSBzZWNvbmRzIGFuZCBtYXBzIGl0IHRvIEluZmluaXR5XG4gICAgICAgICAgICBpZiAoZHVyYXRpb24gPD0gMC4wMDEpIHtcbiAgICAgICAgICAgICAgZHVyYXRpb24gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gZW1zZ0luZm8ucGF5bG9hZDtcbiAgICAgICAgICAgIGlkM1RyYWNrLnNhbXBsZXMucHVzaCh7XG4gICAgICAgICAgICAgIGRhdGE6IHBheWxvYWQsXG4gICAgICAgICAgICAgIGxlbjogcGF5bG9hZC5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgICBkdHM6IHB0cyxcbiAgICAgICAgICAgICAgcHRzOiBwdHMsXG4gICAgICAgICAgICAgIHR5cGU6IE1ldGFkYXRhU2NoZW1hLmVtc2csXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNvbmZpZy5lbmFibGVFbXNnS0xWTWV0YWRhdGEgJiYgZW1zZ0luZm8uc2NoZW1lSWRVcmkuc3RhcnRzV2l0aCgndXJuOm1pc2I6S0xWOmJpbjoxOTEwLjEnKSkge1xuICAgICAgICAgICAgY29uc3QgcHRzID0gZ2V0RW1zZ1N0YXJ0VGltZShlbXNnSW5mbywgdGltZU9mZnNldCk7XG4gICAgICAgICAgICBpZDNUcmFjay5zYW1wbGVzLnB1c2goe1xuICAgICAgICAgICAgICBkYXRhOiBlbXNnSW5mby5wYXlsb2FkLFxuICAgICAgICAgICAgICBsZW46IGVtc2dJbmZvLnBheWxvYWQuYnl0ZUxlbmd0aCxcbiAgICAgICAgICAgICAgZHRzOiBwdHMsXG4gICAgICAgICAgICAgIHB0czogcHRzLFxuICAgICAgICAgICAgICB0eXBlOiBNZXRhZGF0YVNjaGVtYS5taXNia2x2LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaWQzVHJhY2s7XG4gIH1cbiAgZGVtdXhTYW1wbGVBZXMoZGF0YSwga2V5RGF0YSwgdGltZU9mZnNldCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1RoZSBNUDQgZGVtdXhlciBkb2VzIG5vdCBzdXBwb3J0IFNBTVBMRS1BRVMgZGVjcnlwdGlvbicpKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmNvbmZpZyA9IG51bGw7XG4gICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgICB0aGlzLnZpZGVvVHJhY2sgPSB0aGlzLmF1ZGlvVHJhY2sgPSB0aGlzLmlkM1RyYWNrID0gdGhpcy50eHRUcmFjayA9IHVuZGVmaW5lZDtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0RW1zZ1N0YXJ0VGltZShlbXNnSW5mbywgdGltZU9mZnNldCkge1xuICByZXR1cm4gaXNGaW5pdGVOdW1iZXIoZW1zZ0luZm8ucHJlc2VudGF0aW9uVGltZSkgPyBlbXNnSW5mby5wcmVzZW50YXRpb25UaW1lIC8gZW1zZ0luZm8udGltZVNjYWxlIDogdGltZU9mZnNldCArIGVtc2dJbmZvLnByZXNlbnRhdGlvblRpbWVEZWx0YSAvIGVtc2dJbmZvLnRpbWVTY2FsZTtcbn1cblxuLyoqXG4gKiBTQU1QTEUtQUVTIGRlY3J5cHRlclxuICovXG5cbmNsYXNzIFNhbXBsZUFlc0RlY3J5cHRlciB7XG4gIGNvbnN0cnVjdG9yKG9ic2VydmVyLCBjb25maWcsIGtleURhdGEpIHtcbiAgICB0aGlzLmtleURhdGEgPSB2b2lkIDA7XG4gICAgdGhpcy5kZWNyeXB0ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXlEYXRhID0ga2V5RGF0YTtcbiAgICB0aGlzLmRlY3J5cHRlciA9IG5ldyBEZWNyeXB0ZXIoY29uZmlnLCB7XG4gICAgICByZW1vdmVQS0NTN1BhZGRpbmc6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgZGVjcnlwdEJ1ZmZlcihlbmNyeXB0ZWREYXRhKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVjcnlwdGVyLmRlY3J5cHQoZW5jcnlwdGVkRGF0YSwgdGhpcy5rZXlEYXRhLmtleS5idWZmZXIsIHRoaXMua2V5RGF0YS5pdi5idWZmZXIsIERlY3J5cHRlckFlc01vZGUuY2JjKTtcbiAgfVxuXG4gIC8vIEFBQyAtIGVuY3J5cHQgYWxsIGZ1bGwgMTYgYnl0ZXMgYmxvY2tzIHN0YXJ0aW5nIGZyb20gb2Zmc2V0IDE2XG4gIGRlY3J5cHRBYWNTYW1wbGUoc2FtcGxlcywgc2FtcGxlSW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgY3VyVW5pdCA9IHNhbXBsZXNbc2FtcGxlSW5kZXhdLnVuaXQ7XG4gICAgaWYgKGN1clVuaXQubGVuZ3RoIDw9IDE2KSB7XG4gICAgICAvLyBObyBlbmNyeXB0ZWQgcG9ydGlvbiBpbiB0aGlzIHNhbXBsZSAoZmlyc3QgMTYgYnl0ZXMgaXMgbm90XG4gICAgICAvLyBlbmNyeXB0ZWQsIHNlZSBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vbGlicmFyeS9hcmNoaXZlL2RvY3VtZW50YXRpb24vQXVkaW9WaWRlby9Db25jZXB0dWFsL0hMU19TYW1wbGVfRW5jcnlwdGlvbi9FbmNyeXB0aW9uL0VuY3J5cHRpb24uaHRtbCksXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVuY3J5cHRlZERhdGEgPSBjdXJVbml0LnN1YmFycmF5KDE2LCBjdXJVbml0Lmxlbmd0aCAtIGN1clVuaXQubGVuZ3RoICUgMTYpO1xuICAgIGNvbnN0IGVuY3J5cHRlZEJ1ZmZlciA9IGVuY3J5cHRlZERhdGEuYnVmZmVyLnNsaWNlKGVuY3J5cHRlZERhdGEuYnl0ZU9mZnNldCwgZW5jcnlwdGVkRGF0YS5ieXRlT2Zmc2V0ICsgZW5jcnlwdGVkRGF0YS5sZW5ndGgpO1xuICAgIHRoaXMuZGVjcnlwdEJ1ZmZlcihlbmNyeXB0ZWRCdWZmZXIpLnRoZW4oZGVjcnlwdGVkQnVmZmVyID0+IHtcbiAgICAgIGNvbnN0IGRlY3J5cHRlZERhdGEgPSBuZXcgVWludDhBcnJheShkZWNyeXB0ZWRCdWZmZXIpO1xuICAgICAgY3VyVW5pdC5zZXQoZGVjcnlwdGVkRGF0YSwgMTYpO1xuICAgICAgaWYgKCF0aGlzLmRlY3J5cHRlci5pc1N5bmMoKSkge1xuICAgICAgICB0aGlzLmRlY3J5cHRBYWNTYW1wbGVzKHNhbXBsZXMsIHNhbXBsZUluZGV4ICsgMSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGRlY3J5cHRBYWNTYW1wbGVzKHNhbXBsZXMsIHNhbXBsZUluZGV4LCBjYWxsYmFjaykge1xuICAgIGZvciAoOzsgc2FtcGxlSW5kZXgrKykge1xuICAgICAgaWYgKHNhbXBsZUluZGV4ID49IHNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChzYW1wbGVzW3NhbXBsZUluZGV4XS51bml0Lmxlbmd0aCA8IDMyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5kZWNyeXB0QWFjU2FtcGxlKHNhbXBsZXMsIHNhbXBsZUluZGV4LCBjYWxsYmFjayk7XG4gICAgICBpZiAoIXRoaXMuZGVjcnlwdGVyLmlzU3luYygpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBBVkMgLSBlbmNyeXB0IG9uZSAxNiBieXRlcyBibG9jayBvdXQgb2YgdGVuLCBzdGFydGluZyBmcm9tIG9mZnNldCAzMlxuICBnZXRBdmNFbmNyeXB0ZWREYXRhKGRlY29kZWREYXRhKSB7XG4gICAgY29uc3QgZW5jcnlwdGVkRGF0YUxlbiA9IE1hdGguZmxvb3IoKGRlY29kZWREYXRhLmxlbmd0aCAtIDQ4KSAvIDE2MCkgKiAxNiArIDE2O1xuICAgIGNvbnN0IGVuY3J5cHRlZERhdGEgPSBuZXcgSW50OEFycmF5KGVuY3J5cHRlZERhdGFMZW4pO1xuICAgIGxldCBvdXRwdXRQb3MgPSAwO1xuICAgIGZvciAobGV0IGlucHV0UG9zID0gMzI7IGlucHV0UG9zIDwgZGVjb2RlZERhdGEubGVuZ3RoIC0gMTY7IGlucHV0UG9zICs9IDE2MCwgb3V0cHV0UG9zICs9IDE2KSB7XG4gICAgICBlbmNyeXB0ZWREYXRhLnNldChkZWNvZGVkRGF0YS5zdWJhcnJheShpbnB1dFBvcywgaW5wdXRQb3MgKyAxNiksIG91dHB1dFBvcyk7XG4gICAgfVxuICAgIHJldHVybiBlbmNyeXB0ZWREYXRhO1xuICB9XG4gIGdldEF2Y0RlY3J5cHRlZFVuaXQoZGVjb2RlZERhdGEsIGRlY3J5cHRlZERhdGEpIHtcbiAgICBjb25zdCB1aW50OERlY3J5cHRlZERhdGEgPSBuZXcgVWludDhBcnJheShkZWNyeXB0ZWREYXRhKTtcbiAgICBsZXQgaW5wdXRQb3MgPSAwO1xuICAgIGZvciAobGV0IG91dHB1dFBvcyA9IDMyOyBvdXRwdXRQb3MgPCBkZWNvZGVkRGF0YS5sZW5ndGggLSAxNjsgb3V0cHV0UG9zICs9IDE2MCwgaW5wdXRQb3MgKz0gMTYpIHtcbiAgICAgIGRlY29kZWREYXRhLnNldCh1aW50OERlY3J5cHRlZERhdGEuc3ViYXJyYXkoaW5wdXRQb3MsIGlucHV0UG9zICsgMTYpLCBvdXRwdXRQb3MpO1xuICAgIH1cbiAgICByZXR1cm4gZGVjb2RlZERhdGE7XG4gIH1cbiAgZGVjcnlwdEF2Y1NhbXBsZShzYW1wbGVzLCBzYW1wbGVJbmRleCwgdW5pdEluZGV4LCBjYWxsYmFjaywgY3VyVW5pdCkge1xuICAgIGNvbnN0IGRlY29kZWREYXRhID0gZGlzY2FyZEVQQihjdXJVbml0LmRhdGEpO1xuICAgIGNvbnN0IGVuY3J5cHRlZERhdGEgPSB0aGlzLmdldEF2Y0VuY3J5cHRlZERhdGEoZGVjb2RlZERhdGEpO1xuICAgIHRoaXMuZGVjcnlwdEJ1ZmZlcihlbmNyeXB0ZWREYXRhLmJ1ZmZlcikudGhlbihkZWNyeXB0ZWRCdWZmZXIgPT4ge1xuICAgICAgY3VyVW5pdC5kYXRhID0gdGhpcy5nZXRBdmNEZWNyeXB0ZWRVbml0KGRlY29kZWREYXRhLCBkZWNyeXB0ZWRCdWZmZXIpO1xuICAgICAgaWYgKCF0aGlzLmRlY3J5cHRlci5pc1N5bmMoKSkge1xuICAgICAgICB0aGlzLmRlY3J5cHRBdmNTYW1wbGVzKHNhbXBsZXMsIHNhbXBsZUluZGV4LCB1bml0SW5kZXggKyAxLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZGVjcnlwdEF2Y1NhbXBsZXMoc2FtcGxlcywgc2FtcGxlSW5kZXgsIHVuaXRJbmRleCwgY2FsbGJhY2spIHtcbiAgICBpZiAoc2FtcGxlcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGRlY3J5cHQgc2FtcGxlcyBvZiB0eXBlIFVpbnQ4QXJyYXknKTtcbiAgICB9XG4gICAgZm9yICg7OyBzYW1wbGVJbmRleCsrLCB1bml0SW5kZXggPSAwKSB7XG4gICAgICBpZiAoc2FtcGxlSW5kZXggPj0gc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY3VyVW5pdHMgPSBzYW1wbGVzW3NhbXBsZUluZGV4XS51bml0cztcbiAgICAgIGZvciAoOzsgdW5pdEluZGV4KyspIHtcbiAgICAgICAgaWYgKHVuaXRJbmRleCA+PSBjdXJVbml0cy5sZW5ndGgpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJVbml0ID0gY3VyVW5pdHNbdW5pdEluZGV4XTtcbiAgICAgICAgaWYgKGN1clVuaXQuZGF0YS5sZW5ndGggPD0gNDggfHwgY3VyVW5pdC50eXBlICE9PSAxICYmIGN1clVuaXQudHlwZSAhPT0gNSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVjcnlwdEF2Y1NhbXBsZShzYW1wbGVzLCBzYW1wbGVJbmRleCwgdW5pdEluZGV4LCBjYWxsYmFjaywgY3VyVW5pdCk7XG4gICAgICAgIGlmICghdGhpcy5kZWNyeXB0ZXIuaXNTeW5jKCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgQmFzZVZpZGVvUGFyc2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5WaWRlb1NhbXBsZSA9IG51bGw7XG4gIH1cbiAgY3JlYXRlVmlkZW9TYW1wbGUoa2V5LCBwdHMsIGR0cykge1xuICAgIHJldHVybiB7XG4gICAgICBrZXksXG4gICAgICBmcmFtZTogZmFsc2UsXG4gICAgICBwdHMsXG4gICAgICBkdHMsXG4gICAgICB1bml0czogW10sXG4gICAgICBsZW5ndGg6IDBcbiAgICB9O1xuICB9XG4gIGdldExhc3ROYWxVbml0KHNhbXBsZXMpIHtcbiAgICB2YXIgX1ZpZGVvU2FtcGxlO1xuICAgIGxldCBWaWRlb1NhbXBsZSA9IHRoaXMuVmlkZW9TYW1wbGU7XG4gICAgbGV0IGxhc3RVbml0O1xuICAgIC8vIHRyeSB0byBmYWxsYmFjayB0byBwcmV2aW91cyBzYW1wbGUgaWYgY3VycmVudCBvbmUgaXMgZW1wdHlcbiAgICBpZiAoIVZpZGVvU2FtcGxlIHx8IFZpZGVvU2FtcGxlLnVuaXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgVmlkZW9TYW1wbGUgPSBzYW1wbGVzW3NhbXBsZXMubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIGlmICgoX1ZpZGVvU2FtcGxlID0gVmlkZW9TYW1wbGUpICE9IG51bGwgJiYgX1ZpZGVvU2FtcGxlLnVuaXRzKSB7XG4gICAgICBjb25zdCB1bml0cyA9IFZpZGVvU2FtcGxlLnVuaXRzO1xuICAgICAgbGFzdFVuaXQgPSB1bml0c1t1bml0cy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgcmV0dXJuIGxhc3RVbml0O1xuICB9XG4gIHB1c2hBY2Nlc3NVbml0KFZpZGVvU2FtcGxlLCB2aWRlb1RyYWNrKSB7XG4gICAgaWYgKFZpZGVvU2FtcGxlLnVuaXRzLmxlbmd0aCAmJiBWaWRlb1NhbXBsZS5mcmFtZSkge1xuICAgICAgLy8gaWYgc2FtcGxlIGRvZXMgbm90IGhhdmUgUFRTL0RUUywgcGF0Y2ggd2l0aCBsYXN0IHNhbXBsZSBQVFMvRFRTXG4gICAgICBpZiAoVmlkZW9TYW1wbGUucHRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3Qgc2FtcGxlcyA9IHZpZGVvVHJhY2suc2FtcGxlcztcbiAgICAgICAgY29uc3QgbmJTYW1wbGVzID0gc2FtcGxlcy5sZW5ndGg7XG4gICAgICAgIGlmIChuYlNhbXBsZXMpIHtcbiAgICAgICAgICBjb25zdCBsYXN0U2FtcGxlID0gc2FtcGxlc1tuYlNhbXBsZXMgLSAxXTtcbiAgICAgICAgICBWaWRlb1NhbXBsZS5wdHMgPSBsYXN0U2FtcGxlLnB0cztcbiAgICAgICAgICBWaWRlb1NhbXBsZS5kdHMgPSBsYXN0U2FtcGxlLmR0cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBkcm9wcGluZyBzYW1wbGVzLCBubyB0aW1lc3RhbXAgZm91bmRcbiAgICAgICAgICB2aWRlb1RyYWNrLmRyb3BwZWQrKztcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZpZGVvVHJhY2suc2FtcGxlcy5wdXNoKFZpZGVvU2FtcGxlKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VOQUx1KHRyYWNrLCBhcnJheSwgZW5kT2ZTZWdtZW50KSB7XG4gICAgY29uc3QgbGVuID0gYXJyYXkuYnl0ZUxlbmd0aDtcbiAgICBsZXQgc3RhdGUgPSB0cmFjay5uYWx1U3RhdGUgfHwgMDtcbiAgICBjb25zdCBsYXN0U3RhdGUgPSBzdGF0ZTtcbiAgICBjb25zdCB1bml0cyA9IFtdO1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgdmFsdWU7XG4gICAgbGV0IG92ZXJmbG93O1xuICAgIGxldCB1bml0VHlwZTtcbiAgICBsZXQgbGFzdFVuaXRTdGFydCA9IC0xO1xuICAgIGxldCBsYXN0VW5pdFR5cGUgPSAwO1xuICAgIC8vIGxvZ2dlci5sb2coJ1BFUzonICsgSGV4LmhleER1bXAoYXJyYXkpKTtcblxuICAgIGlmIChzdGF0ZSA9PT0gLTEpIHtcbiAgICAgIC8vIHNwZWNpYWwgdXNlIGNhc2Ugd2hlcmUgd2UgZm91bmQgMyBvciA0LWJ5dGUgc3RhcnQgY29kZXMgZXhhY3RseSBhdCB0aGUgZW5kIG9mIHByZXZpb3VzIFBFUyBwYWNrZXRcbiAgICAgIGxhc3RVbml0U3RhcnQgPSAwO1xuICAgICAgLy8gTkFMdSB0eXBlIGlzIHZhbHVlIHJlYWQgZnJvbSBvZmZzZXQgMFxuICAgICAgbGFzdFVuaXRUeXBlID0gdGhpcy5nZXROQUx1VHlwZShhcnJheSwgMCk7XG4gICAgICBzdGF0ZSA9IDA7XG4gICAgICBpID0gMTtcbiAgICB9XG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIHZhbHVlID0gYXJyYXlbaSsrXTtcbiAgICAgIC8vIG9wdGltaXphdGlvbi4gc3RhdGUgMCBhbmQgMSBhcmUgdGhlIHByZWRvbWluYW50IGNhc2UuIGxldCdzIGhhbmRsZSB0aGVtIG91dHNpZGUgb2YgdGhlIHN3aXRjaC9jYXNlXG4gICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgIHN0YXRlID0gdmFsdWUgPyAwIDogMTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUgPT09IDEpIHtcbiAgICAgICAgc3RhdGUgPSB2YWx1ZSA/IDAgOiAyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIGhlcmUgd2UgaGF2ZSBzdGF0ZSBlaXRoZXIgZXF1YWwgdG8gMiBvciAzXG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHN0YXRlID0gMztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDEpIHtcbiAgICAgICAgb3ZlcmZsb3cgPSBpIC0gc3RhdGUgLSAxO1xuICAgICAgICBpZiAobGFzdFVuaXRTdGFydCA+PSAwKSB7XG4gICAgICAgICAgY29uc3QgdW5pdCA9IHtcbiAgICAgICAgICAgIGRhdGE6IGFycmF5LnN1YmFycmF5KGxhc3RVbml0U3RhcnQsIG92ZXJmbG93KSxcbiAgICAgICAgICAgIHR5cGU6IGxhc3RVbml0VHlwZVxuICAgICAgICAgIH07XG4gICAgICAgICAgLy8gbG9nZ2VyLmxvZygncHVzaGluZyBOQUxVLCB0eXBlL3NpemU6JyArIHVuaXQudHlwZSArICcvJyArIHVuaXQuZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICB1bml0cy5wdXNoKHVuaXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGxhc3RVbml0U3RhcnQgaXMgdW5kZWZpbmVkID0+IHRoaXMgaXMgdGhlIGZpcnN0IHN0YXJ0IGNvZGUgZm91bmQgaW4gdGhpcyBQRVMgcGFja2V0XG4gICAgICAgICAgLy8gZmlyc3QgY2hlY2sgaWYgc3RhcnQgY29kZSBkZWxpbWl0ZXIgaXMgb3ZlcmxhcHBpbmcgYmV0d2VlbiAyIFBFUyBwYWNrZXRzLFxuICAgICAgICAgIC8vIGllIGl0IHN0YXJ0ZWQgaW4gbGFzdCBwYWNrZXQgKGxhc3RTdGF0ZSBub3QgemVybylcbiAgICAgICAgICAvLyBhbmQgZW5kZWQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGlzIFBFUyBwYWNrZXQgKGkgPD0gNCAtIGxhc3RTdGF0ZSlcbiAgICAgICAgICBjb25zdCBsYXN0VW5pdCA9IHRoaXMuZ2V0TGFzdE5hbFVuaXQodHJhY2suc2FtcGxlcyk7XG4gICAgICAgICAgaWYgKGxhc3RVbml0KSB7XG4gICAgICAgICAgICBpZiAobGFzdFN0YXRlICYmIGkgPD0gNCAtIGxhc3RTdGF0ZSkge1xuICAgICAgICAgICAgICAvLyBzdGFydCBkZWxpbWl0ZXIgb3ZlcmxhcHBpbmcgYmV0d2VlbiBQRVMgcGFja2V0c1xuICAgICAgICAgICAgICAvLyBzdHJpcCBzdGFydCBkZWxpbWl0ZXIgYnl0ZXMgZnJvbSB0aGUgZW5kIG9mIGxhc3QgTkFMIHVuaXRcbiAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgbGFzdFVuaXQgaGFkIGEgc3RhdGUgZGlmZmVyZW50IGZyb20gemVyb1xuICAgICAgICAgICAgICBpZiAobGFzdFVuaXQuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBzdHJpcCBsYXN0IGJ5dGVzXG4gICAgICAgICAgICAgICAgbGFzdFVuaXQuZGF0YSA9IGxhc3RVbml0LmRhdGEuc3ViYXJyYXkoMCwgbGFzdFVuaXQuZGF0YS5ieXRlTGVuZ3RoIC0gbGFzdFN0YXRlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgTkFMIHVuaXRzIGFyZSBub3Qgc3RhcnRpbmcgcmlnaHQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgUEVTIHBhY2tldCwgcHVzaCBwcmVjZWRpbmcgZGF0YSBpbnRvIHByZXZpb3VzIE5BTCB1bml0LlxuXG4gICAgICAgICAgICBpZiAob3ZlcmZsb3cgPiAwKSB7XG4gICAgICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ2ZpcnN0IE5BTFUgZm91bmQgd2l0aCBvdmVyZmxvdzonICsgb3ZlcmZsb3cpO1xuICAgICAgICAgICAgICBsYXN0VW5pdC5kYXRhID0gYXBwZW5kVWludDhBcnJheShsYXN0VW5pdC5kYXRhLCBhcnJheS5zdWJhcnJheSgwLCBvdmVyZmxvdykpO1xuICAgICAgICAgICAgICBsYXN0VW5pdC5zdGF0ZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIGNhbiByZWFkIHVuaXQgdHlwZVxuICAgICAgICBpZiAoaSA8IGxlbikge1xuICAgICAgICAgIHVuaXRUeXBlID0gdGhpcy5nZXROQUx1VHlwZShhcnJheSwgaSk7XG4gICAgICAgICAgLy8gbG9nZ2VyLmxvZygnZmluZCBOQUxVIEAgb2Zmc2V0OicgKyBpICsgJyx0eXBlOicgKyB1bml0VHlwZSk7XG4gICAgICAgICAgbGFzdFVuaXRTdGFydCA9IGk7XG4gICAgICAgICAgbGFzdFVuaXRUeXBlID0gdW5pdFR5cGU7XG4gICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG5vdCBlbm91Z2ggYnl0ZSB0byByZWFkIHVuaXQgdHlwZS4gbGV0J3MgcmVhZCBpdCBvbiBuZXh0IFBFUyBwYXJzaW5nXG4gICAgICAgICAgc3RhdGUgPSAtMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGFzdFVuaXRTdGFydCA+PSAwICYmIHN0YXRlID49IDApIHtcbiAgICAgIGNvbnN0IHVuaXQgPSB7XG4gICAgICAgIGRhdGE6IGFycmF5LnN1YmFycmF5KGxhc3RVbml0U3RhcnQsIGxlbiksXG4gICAgICAgIHR5cGU6IGxhc3RVbml0VHlwZSxcbiAgICAgICAgc3RhdGU6IHN0YXRlXG4gICAgICB9O1xuICAgICAgdW5pdHMucHVzaCh1bml0KTtcbiAgICAgIC8vIGxvZ2dlci5sb2coJ3B1c2hpbmcgTkFMVSwgdHlwZS9zaXplL3N0YXRlOicgKyB1bml0LnR5cGUgKyAnLycgKyB1bml0LmRhdGEuYnl0ZUxlbmd0aCArICcvJyArIHN0YXRlKTtcbiAgICB9XG4gICAgLy8gbm8gTkFMdSBmb3VuZFxuICAgIGlmICh1bml0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIGFwcGVuZCBwZXMuZGF0YSB0byBwcmV2aW91cyBOQUwgdW5pdFxuICAgICAgY29uc3QgbGFzdFVuaXQgPSB0aGlzLmdldExhc3ROYWxVbml0KHRyYWNrLnNhbXBsZXMpO1xuICAgICAgaWYgKGxhc3RVbml0KSB7XG4gICAgICAgIGxhc3RVbml0LmRhdGEgPSBhcHBlbmRVaW50OEFycmF5KGxhc3RVbml0LmRhdGEsIGFycmF5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJhY2submFsdVN0YXRlID0gc3RhdGU7XG4gICAgcmV0dXJuIHVuaXRzO1xuICB9XG59XG5cbi8qKlxuICogUGFyc2VyIGZvciBleHBvbmVudGlhbCBHb2xvbWIgY29kZXMsIGEgdmFyaWFibGUtYml0d2lkdGggbnVtYmVyIGVuY29kaW5nIHNjaGVtZSB1c2VkIGJ5IGgyNjQuXG4gKi9cblxuY2xhc3MgRXhwR29sb21iIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHRoaXMuZGF0YSA9IHZvaWQgMDtcbiAgICB0aGlzLmJ5dGVzQXZhaWxhYmxlID0gdm9pZCAwO1xuICAgIHRoaXMud29yZCA9IHZvaWQgMDtcbiAgICB0aGlzLmJpdHNBdmFpbGFibGUgPSB2b2lkIDA7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAvLyB0aGUgbnVtYmVyIG9mIGJ5dGVzIGxlZnQgdG8gZXhhbWluZSBpbiB0aGlzLmRhdGFcbiAgICB0aGlzLmJ5dGVzQXZhaWxhYmxlID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgIC8vIHRoZSBjdXJyZW50IHdvcmQgYmVpbmcgZXhhbWluZWRcbiAgICB0aGlzLndvcmQgPSAwOyAvLyA6dWludFxuICAgIC8vIHRoZSBudW1iZXIgb2YgYml0cyBsZWZ0IHRvIGV4YW1pbmUgaW4gdGhlIGN1cnJlbnQgd29yZFxuICAgIHRoaXMuYml0c0F2YWlsYWJsZSA9IDA7IC8vIDp1aW50XG4gIH1cblxuICAvLyAoKTp2b2lkXG4gIGxvYWRXb3JkKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3QgYnl0ZXNBdmFpbGFibGUgPSB0aGlzLmJ5dGVzQXZhaWxhYmxlO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gZGF0YS5ieXRlTGVuZ3RoIC0gYnl0ZXNBdmFpbGFibGU7XG4gICAgY29uc3Qgd29ya2luZ0J5dGVzID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgY29uc3QgYXZhaWxhYmxlQnl0ZXMgPSBNYXRoLm1pbig0LCBieXRlc0F2YWlsYWJsZSk7XG4gICAgaWYgKGF2YWlsYWJsZUJ5dGVzID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGJ5dGVzIGF2YWlsYWJsZScpO1xuICAgIH1cbiAgICB3b3JraW5nQnl0ZXMuc2V0KGRhdGEuc3ViYXJyYXkocG9zaXRpb24sIHBvc2l0aW9uICsgYXZhaWxhYmxlQnl0ZXMpKTtcbiAgICB0aGlzLndvcmQgPSBuZXcgRGF0YVZpZXcod29ya2luZ0J5dGVzLmJ1ZmZlcikuZ2V0VWludDMyKDApO1xuICAgIC8vIHRyYWNrIHRoZSBhbW91bnQgb2YgdGhpcy5kYXRhIHRoYXQgaGFzIGJlZW4gcHJvY2Vzc2VkXG4gICAgdGhpcy5iaXRzQXZhaWxhYmxlID0gYXZhaWxhYmxlQnl0ZXMgKiA4O1xuICAgIHRoaXMuYnl0ZXNBdmFpbGFibGUgLT0gYXZhaWxhYmxlQnl0ZXM7XG4gIH1cblxuICAvLyAoY291bnQ6aW50KTp2b2lkXG4gIHNraXBCaXRzKGNvdW50KSB7XG4gICAgbGV0IHNraXBCeXRlczsgLy8gOmludFxuICAgIGNvdW50ID0gTWF0aC5taW4oY291bnQsIHRoaXMuYnl0ZXNBdmFpbGFibGUgKiA4ICsgdGhpcy5iaXRzQXZhaWxhYmxlKTtcbiAgICBpZiAodGhpcy5iaXRzQXZhaWxhYmxlID4gY291bnQpIHtcbiAgICAgIHRoaXMud29yZCA8PD0gY291bnQ7XG4gICAgICB0aGlzLmJpdHNBdmFpbGFibGUgLT0gY291bnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50IC09IHRoaXMuYml0c0F2YWlsYWJsZTtcbiAgICAgIHNraXBCeXRlcyA9IGNvdW50ID4+IDM7XG4gICAgICBjb3VudCAtPSBza2lwQnl0ZXMgPDwgMztcbiAgICAgIHRoaXMuYnl0ZXNBdmFpbGFibGUgLT0gc2tpcEJ5dGVzO1xuICAgICAgdGhpcy5sb2FkV29yZCgpO1xuICAgICAgdGhpcy53b3JkIDw8PSBjb3VudDtcbiAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBjb3VudDtcbiAgICB9XG4gIH1cblxuICAvLyAoc2l6ZTppbnQpOnVpbnRcbiAgcmVhZEJpdHMoc2l6ZSkge1xuICAgIGxldCBiaXRzID0gTWF0aC5taW4odGhpcy5iaXRzQXZhaWxhYmxlLCBzaXplKTsgLy8gOnVpbnRcbiAgICBjb25zdCB2YWx1ID0gdGhpcy53b3JkID4+PiAzMiAtIGJpdHM7IC8vIDp1aW50XG4gICAgaWYgKHNpemUgPiAzMikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdDYW5ub3QgcmVhZCBtb3JlIHRoYW4gMzIgYml0cyBhdCBhIHRpbWUnKTtcbiAgICB9XG4gICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGJpdHM7XG4gICAgaWYgKHRoaXMuYml0c0F2YWlsYWJsZSA+IDApIHtcbiAgICAgIHRoaXMud29yZCA8PD0gYml0cztcbiAgICB9IGVsc2UgaWYgKHRoaXMuYnl0ZXNBdmFpbGFibGUgPiAwKSB7XG4gICAgICB0aGlzLmxvYWRXb3JkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gYml0cyBhdmFpbGFibGUnKTtcbiAgICB9XG4gICAgYml0cyA9IHNpemUgLSBiaXRzO1xuICAgIGlmIChiaXRzID4gMCAmJiB0aGlzLmJpdHNBdmFpbGFibGUpIHtcbiAgICAgIHJldHVybiB2YWx1IDw8IGJpdHMgfCB0aGlzLnJlYWRCaXRzKGJpdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsdTtcbiAgICB9XG4gIH1cblxuICAvLyAoKTp1aW50XG4gIHNraXBMWigpIHtcbiAgICBsZXQgbGVhZGluZ1plcm9Db3VudDsgLy8gOnVpbnRcbiAgICBmb3IgKGxlYWRpbmdaZXJvQ291bnQgPSAwOyBsZWFkaW5nWmVyb0NvdW50IDwgdGhpcy5iaXRzQXZhaWxhYmxlOyArK2xlYWRpbmdaZXJvQ291bnQpIHtcbiAgICAgIGlmICgodGhpcy53b3JkICYgMHg4MDAwMDAwMCA+Pj4gbGVhZGluZ1plcm9Db3VudCkgIT09IDApIHtcbiAgICAgICAgLy8gdGhlIGZpcnN0IGJpdCBvZiB3b3JraW5nIHdvcmQgaXMgMVxuICAgICAgICB0aGlzLndvcmQgPDw9IGxlYWRpbmdaZXJvQ291bnQ7XG4gICAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBsZWFkaW5nWmVyb0NvdW50O1xuICAgICAgICByZXR1cm4gbGVhZGluZ1plcm9Db3VudDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gd2UgZXhoYXVzdGVkIHdvcmQgYW5kIHN0aWxsIGhhdmUgbm90IGZvdW5kIGEgMVxuICAgIHRoaXMubG9hZFdvcmQoKTtcbiAgICByZXR1cm4gbGVhZGluZ1plcm9Db3VudCArIHRoaXMuc2tpcExaKCk7XG4gIH1cblxuICAvLyAoKTp2b2lkXG4gIHNraXBVRUcoKSB7XG4gICAgdGhpcy5za2lwQml0cygxICsgdGhpcy5za2lwTFooKSk7XG4gIH1cblxuICAvLyAoKTp2b2lkXG4gIHNraXBFRygpIHtcbiAgICB0aGlzLnNraXBCaXRzKDEgKyB0aGlzLnNraXBMWigpKTtcbiAgfVxuXG4gIC8vICgpOnVpbnRcbiAgcmVhZFVFRygpIHtcbiAgICBjb25zdCBjbHogPSB0aGlzLnNraXBMWigpOyAvLyA6dWludFxuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKGNseiArIDEpIC0gMTtcbiAgfVxuXG4gIC8vICgpOmludFxuICByZWFkRUcoKSB7XG4gICAgY29uc3QgdmFsdSA9IHRoaXMucmVhZFVFRygpOyAvLyA6aW50XG4gICAgaWYgKDB4MDEgJiB2YWx1KSB7XG4gICAgICAvLyB0aGUgbnVtYmVyIGlzIG9kZCBpZiB0aGUgbG93IG9yZGVyIGJpdCBpcyBzZXRcbiAgICAgIHJldHVybiAxICsgdmFsdSA+Pj4gMTsgLy8gYWRkIDEgdG8gbWFrZSBpdCBldmVuLCBhbmQgZGl2aWRlIGJ5IDJcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIC0xICogKHZhbHUgPj4+IDEpOyAvLyBkaXZpZGUgYnkgdHdvIHRoZW4gbWFrZSBpdCBuZWdhdGl2ZVxuICAgIH1cbiAgfVxuXG4gIC8vIFNvbWUgY29udmVuaWVuY2UgZnVuY3Rpb25zXG4gIC8vIDpCb29sZWFuXG4gIHJlYWRCb29sZWFuKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDEpID09PSAxO1xuICB9XG5cbiAgLy8gKCk6aW50XG4gIHJlYWRVQnl0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkQml0cyg4KTtcbiAgfVxuXG4gIC8vICgpOmludFxuICByZWFkVVNob3J0KCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDE2KTtcbiAgfVxuXG4gIC8vICgpOmludFxuICByZWFkVUludCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkQml0cygzMik7XG4gIH1cbn1cblxuY2xhc3MgQXZjVmlkZW9QYXJzZXIgZXh0ZW5kcyBCYXNlVmlkZW9QYXJzZXIge1xuICBwYXJzZVBFUyh0cmFjaywgdGV4dFRyYWNrLCBwZXMsIGVuZE9mU2VnbWVudCkge1xuICAgIGNvbnN0IHVuaXRzID0gdGhpcy5wYXJzZU5BTHUodHJhY2ssIHBlcy5kYXRhLCBlbmRPZlNlZ21lbnQpO1xuICAgIGxldCBWaWRlb1NhbXBsZSA9IHRoaXMuVmlkZW9TYW1wbGU7XG4gICAgbGV0IHB1c2g7XG4gICAgbGV0IHNwc2ZvdW5kID0gZmFsc2U7XG4gICAgLy8gZnJlZSBwZXMuZGF0YSB0byBzYXZlIHVwIHNvbWUgbWVtb3J5XG4gICAgcGVzLmRhdGEgPSBudWxsO1xuXG4gICAgLy8gaWYgbmV3IE5BTCB1bml0cyBmb3VuZCBhbmQgbGFzdCBzYW1wbGUgc3RpbGwgdGhlcmUsIGxldCdzIHB1c2ggLi4uXG4gICAgLy8gdGhpcyBoZWxwcyBwYXJzaW5nIHN0cmVhbXMgd2l0aCBtaXNzaW5nIEFVRCAob25seSBkbyB0aGlzIGlmIEFVRCBuZXZlciBmb3VuZClcbiAgICBpZiAoVmlkZW9TYW1wbGUgJiYgdW5pdHMubGVuZ3RoICYmICF0cmFjay5hdWRGb3VuZCkge1xuICAgICAgdGhpcy5wdXNoQWNjZXNzVW5pdChWaWRlb1NhbXBsZSwgdHJhY2spO1xuICAgICAgVmlkZW9TYW1wbGUgPSB0aGlzLlZpZGVvU2FtcGxlID0gdGhpcy5jcmVhdGVWaWRlb1NhbXBsZShmYWxzZSwgcGVzLnB0cywgcGVzLmR0cyk7XG4gICAgfVxuICAgIHVuaXRzLmZvckVhY2godW5pdCA9PiB7XG4gICAgICB2YXIgX1ZpZGVvU2FtcGxlMiwgX1ZpZGVvU2FtcGxlMztcbiAgICAgIHN3aXRjaCAodW5pdC50eXBlKSB7XG4gICAgICAgIC8vIE5EUlxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAge1xuICAgICAgICAgICAgbGV0IGlza2V5ID0gZmFsc2U7XG4gICAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB1bml0LmRhdGE7XG4gICAgICAgICAgICAvLyBvbmx5IGNoZWNrIHNsaWNlIHR5cGUgdG8gZGV0ZWN0IEtGIGluIGNhc2UgU1BTIGZvdW5kIGluIHNhbWUgcGFja2V0IChhbnkga2V5ZnJhbWUgaXMgcHJlY2VkZWQgYnkgU1BTIC4uLilcbiAgICAgICAgICAgIGlmIChzcHNmb3VuZCAmJiBkYXRhLmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgICAgLy8gcmV0cmlldmUgc2xpY2UgdHlwZSBieSBwYXJzaW5nIGJlZ2lubmluZyBvZiBOQUwgdW5pdCAoZm9sbG93IEgyNjQgc3BlYywgc2xpY2VfaGVhZGVyIGRlZmluaXRpb24pIHRvIGRldGVjdCBrZXlmcmFtZSBlbWJlZGRlZCBpbiBORFJcbiAgICAgICAgICAgICAgY29uc3Qgc2xpY2VUeXBlID0gdGhpcy5yZWFkU2xpY2VUeXBlKGRhdGEpO1xuICAgICAgICAgICAgICAvLyAyIDogSSBzbGljZSwgNCA6IFNJIHNsaWNlLCA3IDogSSBzbGljZSwgOTogU0kgc2xpY2VcbiAgICAgICAgICAgICAgLy8gU0kgc2xpY2UgOiBBIHNsaWNlIHRoYXQgaXMgY29kZWQgdXNpbmcgaW50cmEgcHJlZGljdGlvbiBvbmx5IGFuZCB1c2luZyBxdWFudGlzYXRpb24gb2YgdGhlIHByZWRpY3Rpb24gc2FtcGxlcy5cbiAgICAgICAgICAgICAgLy8gQW4gU0kgc2xpY2UgY2FuIGJlIGNvZGVkIHN1Y2ggdGhhdCBpdHMgZGVjb2RlZCBzYW1wbGVzIGNhbiBiZSBjb25zdHJ1Y3RlZCBpZGVudGljYWxseSB0byBhbiBTUCBzbGljZS5cbiAgICAgICAgICAgICAgLy8gSSBzbGljZTogQSBzbGljZSB0aGF0IGlzIG5vdCBhbiBTSSBzbGljZSB0aGF0IGlzIGRlY29kZWQgdXNpbmcgaW50cmEgcHJlZGljdGlvbiBvbmx5LlxuICAgICAgICAgICAgICAvLyBpZiAoc2xpY2VUeXBlID09PSAyIHx8IHNsaWNlVHlwZSA9PT0gNykge1xuICAgICAgICAgICAgICBpZiAoc2xpY2VUeXBlID09PSAyIHx8IHNsaWNlVHlwZSA9PT0gNCB8fCBzbGljZVR5cGUgPT09IDcgfHwgc2xpY2VUeXBlID09PSA5KSB7XG4gICAgICAgICAgICAgICAgaXNrZXkgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNrZXkpIHtcbiAgICAgICAgICAgICAgdmFyIF9WaWRlb1NhbXBsZTtcbiAgICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBub24ta2V5ZnJhbWUgZGF0YSBhbHJlYWR5LCB0aGF0IGNhbm5vdCBiZWxvbmcgdG8gdGhlIHNhbWUgZnJhbWUgYXMgYSBrZXlmcmFtZSwgc28gZm9yY2UgYSBwdXNoXG4gICAgICAgICAgICAgIGlmICgoX1ZpZGVvU2FtcGxlID0gVmlkZW9TYW1wbGUpICE9IG51bGwgJiYgX1ZpZGVvU2FtcGxlLmZyYW1lICYmICFWaWRlb1NhbXBsZS5rZXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2hBY2Nlc3NVbml0KFZpZGVvU2FtcGxlLCB0cmFjayk7XG4gICAgICAgICAgICAgICAgVmlkZW9TYW1wbGUgPSB0aGlzLlZpZGVvU2FtcGxlID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFWaWRlb1NhbXBsZSkge1xuICAgICAgICAgICAgICBWaWRlb1NhbXBsZSA9IHRoaXMuVmlkZW9TYW1wbGUgPSB0aGlzLmNyZWF0ZVZpZGVvU2FtcGxlKHRydWUsIHBlcy5wdHMsIHBlcy5kdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgVmlkZW9TYW1wbGUuZnJhbWUgPSB0cnVlO1xuICAgICAgICAgICAgVmlkZW9TYW1wbGUua2V5ID0gaXNrZXk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIElEUlxuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgIC8vIGhhbmRsZSBQRVMgbm90IHN0YXJ0aW5nIHdpdGggQVVEXG4gICAgICAgICAgLy8gaWYgd2UgaGF2ZSBmcmFtZSBkYXRhIGFscmVhZHksIHRoYXQgY2Fubm90IGJlbG9uZyB0byB0aGUgc2FtZSBmcmFtZSwgc28gZm9yY2UgYSBwdXNoXG4gICAgICAgICAgaWYgKChfVmlkZW9TYW1wbGUyID0gVmlkZW9TYW1wbGUpICE9IG51bGwgJiYgX1ZpZGVvU2FtcGxlMi5mcmFtZSAmJiAhVmlkZW9TYW1wbGUua2V5KSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hBY2Nlc3NVbml0KFZpZGVvU2FtcGxlLCB0cmFjayk7XG4gICAgICAgICAgICBWaWRlb1NhbXBsZSA9IHRoaXMuVmlkZW9TYW1wbGUgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIVZpZGVvU2FtcGxlKSB7XG4gICAgICAgICAgICBWaWRlb1NhbXBsZSA9IHRoaXMuVmlkZW9TYW1wbGUgPSB0aGlzLmNyZWF0ZVZpZGVvU2FtcGxlKHRydWUsIHBlcy5wdHMsIHBlcy5kdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBWaWRlb1NhbXBsZS5rZXkgPSB0cnVlO1xuICAgICAgICAgIFZpZGVvU2FtcGxlLmZyYW1lID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gU0VJXG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIHBhcnNlU0VJTWVzc2FnZUZyb21OQUx1KHVuaXQuZGF0YSwgMSwgcGVzLnB0cywgdGV4dFRyYWNrLnNhbXBsZXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBTUFNcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX3RyYWNrJHBpeGVsUmF0aW8sIF90cmFjayRwaXhlbFJhdGlvMjtcbiAgICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgICAgc3BzZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3Qgc3BzID0gdW5pdC5kYXRhO1xuICAgICAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5yZWFkU1BTKHNwcyk7XG4gICAgICAgICAgICBpZiAoIXRyYWNrLnNwcyB8fCB0cmFjay53aWR0aCAhPT0gY29uZmlnLndpZHRoIHx8IHRyYWNrLmhlaWdodCAhPT0gY29uZmlnLmhlaWdodCB8fCAoKF90cmFjayRwaXhlbFJhdGlvID0gdHJhY2sucGl4ZWxSYXRpbykgPT0gbnVsbCA/IHZvaWQgMCA6IF90cmFjayRwaXhlbFJhdGlvWzBdKSAhPT0gY29uZmlnLnBpeGVsUmF0aW9bMF0gfHwgKChfdHJhY2skcGl4ZWxSYXRpbzIgPSB0cmFjay5waXhlbFJhdGlvKSA9PSBudWxsID8gdm9pZCAwIDogX3RyYWNrJHBpeGVsUmF0aW8yWzFdKSAhPT0gY29uZmlnLnBpeGVsUmF0aW9bMV0pIHtcbiAgICAgICAgICAgICAgdHJhY2sud2lkdGggPSBjb25maWcud2lkdGg7XG4gICAgICAgICAgICAgIHRyYWNrLmhlaWdodCA9IGNvbmZpZy5oZWlnaHQ7XG4gICAgICAgICAgICAgIHRyYWNrLnBpeGVsUmF0aW8gPSBjb25maWcucGl4ZWxSYXRpbztcbiAgICAgICAgICAgICAgdHJhY2suc3BzID0gW3Nwc107XG4gICAgICAgICAgICAgIGNvbnN0IGNvZGVjYXJyYXkgPSBzcHMuc3ViYXJyYXkoMSwgNCk7XG4gICAgICAgICAgICAgIGxldCBjb2RlY3N0cmluZyA9ICdhdmMxLic7XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGggPSBjb2RlY2FycmF5W2ldLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgICAgICBpZiAoaC5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgICBoID0gJzAnICsgaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29kZWNzdHJpbmcgKz0gaDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0cmFjay5jb2RlYyA9IGNvZGVjc3RyaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAvLyBQUFNcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgIHRyYWNrLnBwcyA9IFt1bml0LmRhdGFdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBBVURcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgIHRyYWNrLmF1ZEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoKF9WaWRlb1NhbXBsZTMgPSBWaWRlb1NhbXBsZSkgIT0gbnVsbCAmJiBfVmlkZW9TYW1wbGUzLmZyYW1lKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hBY2Nlc3NVbml0KFZpZGVvU2FtcGxlLCB0cmFjayk7XG4gICAgICAgICAgICBWaWRlb1NhbXBsZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghVmlkZW9TYW1wbGUpIHtcbiAgICAgICAgICAgIFZpZGVvU2FtcGxlID0gdGhpcy5WaWRlb1NhbXBsZSA9IHRoaXMuY3JlYXRlVmlkZW9TYW1wbGUoZmFsc2UsIHBlcy5wdHMsIHBlcy5kdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gRmlsbGVyIERhdGFcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXNoID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoVmlkZW9TYW1wbGUgJiYgcHVzaCkge1xuICAgICAgICBjb25zdCB1bml0cyA9IFZpZGVvU2FtcGxlLnVuaXRzO1xuICAgICAgICB1bml0cy5wdXNoKHVuaXQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIGlmIGxhc3QgUEVTIHBhY2tldCwgcHVzaCBzYW1wbGVzXG4gICAgaWYgKGVuZE9mU2VnbWVudCAmJiBWaWRlb1NhbXBsZSkge1xuICAgICAgdGhpcy5wdXNoQWNjZXNzVW5pdChWaWRlb1NhbXBsZSwgdHJhY2spO1xuICAgICAgdGhpcy5WaWRlb1NhbXBsZSA9IG51bGw7XG4gICAgfVxuICB9XG4gIGdldE5BTHVUeXBlKGRhdGEsIG9mZnNldCkge1xuICAgIHJldHVybiBkYXRhW29mZnNldF0gJiAweDFmO1xuICB9XG4gIHJlYWRTbGljZVR5cGUoZGF0YSkge1xuICAgIGNvbnN0IGVnID0gbmV3IEV4cEdvbG9tYihkYXRhKTtcbiAgICAvLyBza2lwIE5BTHUgdHlwZVxuICAgIGVnLnJlYWRVQnl0ZSgpO1xuICAgIC8vIGRpc2NhcmQgZmlyc3RfbWJfaW5fc2xpY2VcbiAgICBlZy5yZWFkVUVHKCk7XG4gICAgLy8gcmV0dXJuIHNsaWNlX3R5cGVcbiAgICByZXR1cm4gZWcucmVhZFVFRygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBzY2FsaW5nIGxpc3QgaXMgb3B0aW9uYWxseSB0cmFuc21pdHRlZCBhcyBwYXJ0IG9mIGEgc2VxdWVuY2UgcGFyYW1ldGVyXG4gICAqIHNldCBhbmQgaXMgbm90IHJlbGV2YW50IHRvIHRyYW5zbXV4aW5nLlxuICAgKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBlbnRyaWVzIGluIHRoaXMgc2NhbGluZyBsaXN0XG4gICAqIEBzZWUgUmVjb21tZW5kYXRpb24gSVRVLVQgSC4yNjQsIFNlY3Rpb24gNy4zLjIuMS4xLjFcbiAgICovXG4gIHNraXBTY2FsaW5nTGlzdChjb3VudCwgcmVhZGVyKSB7XG4gICAgbGV0IGxhc3RTY2FsZSA9IDg7XG4gICAgbGV0IG5leHRTY2FsZSA9IDg7XG4gICAgbGV0IGRlbHRhU2NhbGU7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICBpZiAobmV4dFNjYWxlICE9PSAwKSB7XG4gICAgICAgIGRlbHRhU2NhbGUgPSByZWFkZXIucmVhZEVHKCk7XG4gICAgICAgIG5leHRTY2FsZSA9IChsYXN0U2NhbGUgKyBkZWx0YVNjYWxlICsgMjU2KSAlIDI1NjtcbiAgICAgIH1cbiAgICAgIGxhc3RTY2FsZSA9IG5leHRTY2FsZSA9PT0gMCA/IGxhc3RTY2FsZSA6IG5leHRTY2FsZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVhZCBhIHNlcXVlbmNlIHBhcmFtZXRlciBzZXQgYW5kIHJldHVybiBzb21lIGludGVyZXN0aW5nIHZpZGVvXG4gICAqIHByb3BlcnRpZXMuIEEgc2VxdWVuY2UgcGFyYW1ldGVyIHNldCBpcyB0aGUgSDI2NCBtZXRhZGF0YSB0aGF0XG4gICAqIGRlc2NyaWJlcyB0aGUgcHJvcGVydGllcyBvZiB1cGNvbWluZyB2aWRlbyBmcmFtZXMuXG4gICAqIEByZXR1cm5zIGFuIG9iamVjdCB3aXRoIGNvbmZpZ3VyYXRpb24gcGFyc2VkIGZyb20gdGhlXG4gICAqIHNlcXVlbmNlIHBhcmFtZXRlciBzZXQsIGluY2x1ZGluZyB0aGUgZGltZW5zaW9ucyBvZiB0aGVcbiAgICogYXNzb2NpYXRlZCB2aWRlbyBmcmFtZXMuXG4gICAqL1xuICByZWFkU1BTKHNwcykge1xuICAgIGNvbnN0IGVnID0gbmV3IEV4cEdvbG9tYihzcHMpO1xuICAgIGxldCBmcmFtZUNyb3BMZWZ0T2Zmc2V0ID0gMDtcbiAgICBsZXQgZnJhbWVDcm9wUmlnaHRPZmZzZXQgPSAwO1xuICAgIGxldCBmcmFtZUNyb3BUb3BPZmZzZXQgPSAwO1xuICAgIGxldCBmcmFtZUNyb3BCb3R0b21PZmZzZXQgPSAwO1xuICAgIGxldCBudW1SZWZGcmFtZXNJblBpY09yZGVyQ250Q3ljbGU7XG4gICAgbGV0IHNjYWxpbmdMaXN0Q291bnQ7XG4gICAgbGV0IGk7XG4gICAgY29uc3QgcmVhZFVCeXRlID0gZWcucmVhZFVCeXRlLmJpbmQoZWcpO1xuICAgIGNvbnN0IHJlYWRCaXRzID0gZWcucmVhZEJpdHMuYmluZChlZyk7XG4gICAgY29uc3QgcmVhZFVFRyA9IGVnLnJlYWRVRUcuYmluZChlZyk7XG4gICAgY29uc3QgcmVhZEJvb2xlYW4gPSBlZy5yZWFkQm9vbGVhbi5iaW5kKGVnKTtcbiAgICBjb25zdCBza2lwQml0cyA9IGVnLnNraXBCaXRzLmJpbmQoZWcpO1xuICAgIGNvbnN0IHNraXBFRyA9IGVnLnNraXBFRy5iaW5kKGVnKTtcbiAgICBjb25zdCBza2lwVUVHID0gZWcuc2tpcFVFRy5iaW5kKGVnKTtcbiAgICBjb25zdCBza2lwU2NhbGluZ0xpc3QgPSB0aGlzLnNraXBTY2FsaW5nTGlzdC5iaW5kKHRoaXMpO1xuICAgIHJlYWRVQnl0ZSgpO1xuICAgIGNvbnN0IHByb2ZpbGVJZGMgPSByZWFkVUJ5dGUoKTsgLy8gcHJvZmlsZV9pZGNcbiAgICByZWFkQml0cyg1KTsgLy8gcHJvZmlsZUNvbXBhdCBjb25zdHJhaW50X3NldFswLTRdX2ZsYWcsIHUoNSlcbiAgICBza2lwQml0cygzKTsgLy8gcmVzZXJ2ZWRfemVyb18zYml0cyB1KDMpLFxuICAgIHJlYWRVQnl0ZSgpOyAvLyBsZXZlbF9pZGMgdSg4KVxuICAgIHNraXBVRUcoKTsgLy8gc2VxX3BhcmFtZXRlcl9zZXRfaWRcbiAgICAvLyBzb21lIHByb2ZpbGVzIGhhdmUgbW9yZSBvcHRpb25hbCBkYXRhIHdlIGRvbid0IG5lZWRcbiAgICBpZiAocHJvZmlsZUlkYyA9PT0gMTAwIHx8IHByb2ZpbGVJZGMgPT09IDExMCB8fCBwcm9maWxlSWRjID09PSAxMjIgfHwgcHJvZmlsZUlkYyA9PT0gMjQ0IHx8IHByb2ZpbGVJZGMgPT09IDQ0IHx8IHByb2ZpbGVJZGMgPT09IDgzIHx8IHByb2ZpbGVJZGMgPT09IDg2IHx8IHByb2ZpbGVJZGMgPT09IDExOCB8fCBwcm9maWxlSWRjID09PSAxMjgpIHtcbiAgICAgIGNvbnN0IGNocm9tYUZvcm1hdElkYyA9IHJlYWRVRUcoKTtcbiAgICAgIGlmIChjaHJvbWFGb3JtYXRJZGMgPT09IDMpIHtcbiAgICAgICAgc2tpcEJpdHMoMSk7XG4gICAgICB9IC8vIHNlcGFyYXRlX2NvbG91cl9wbGFuZV9mbGFnXG5cbiAgICAgIHNraXBVRUcoKTsgLy8gYml0X2RlcHRoX2x1bWFfbWludXM4XG4gICAgICBza2lwVUVHKCk7IC8vIGJpdF9kZXB0aF9jaHJvbWFfbWludXM4XG4gICAgICBza2lwQml0cygxKTsgLy8gcXBwcmltZV95X3plcm9fdHJhbnNmb3JtX2J5cGFzc19mbGFnXG4gICAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgICAvLyBzZXFfc2NhbGluZ19tYXRyaXhfcHJlc2VudF9mbGFnXG4gICAgICAgIHNjYWxpbmdMaXN0Q291bnQgPSBjaHJvbWFGb3JtYXRJZGMgIT09IDMgPyA4IDogMTI7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzY2FsaW5nTGlzdENvdW50OyBpKyspIHtcbiAgICAgICAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgICAgICAgLy8gc2VxX3NjYWxpbmdfbGlzdF9wcmVzZW50X2ZsYWdbIGkgXVxuICAgICAgICAgICAgaWYgKGkgPCA2KSB7XG4gICAgICAgICAgICAgIHNraXBTY2FsaW5nTGlzdCgxNiwgZWcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2tpcFNjYWxpbmdMaXN0KDY0LCBlZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHNraXBVRUcoKTsgLy8gbG9nMl9tYXhfZnJhbWVfbnVtX21pbnVzNFxuICAgIGNvbnN0IHBpY09yZGVyQ250VHlwZSA9IHJlYWRVRUcoKTtcbiAgICBpZiAocGljT3JkZXJDbnRUeXBlID09PSAwKSB7XG4gICAgICByZWFkVUVHKCk7IC8vIGxvZzJfbWF4X3BpY19vcmRlcl9jbnRfbHNiX21pbnVzNFxuICAgIH0gZWxzZSBpZiAocGljT3JkZXJDbnRUeXBlID09PSAxKSB7XG4gICAgICBza2lwQml0cygxKTsgLy8gZGVsdGFfcGljX29yZGVyX2Fsd2F5c196ZXJvX2ZsYWdcbiAgICAgIHNraXBFRygpOyAvLyBvZmZzZXRfZm9yX25vbl9yZWZfcGljXG4gICAgICBza2lwRUcoKTsgLy8gb2Zmc2V0X2Zvcl90b3BfdG9fYm90dG9tX2ZpZWxkXG4gICAgICBudW1SZWZGcmFtZXNJblBpY09yZGVyQ250Q3ljbGUgPSByZWFkVUVHKCk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlOyBpKyspIHtcbiAgICAgICAgc2tpcEVHKCk7XG4gICAgICB9IC8vIG9mZnNldF9mb3JfcmVmX2ZyYW1lWyBpIF1cbiAgICB9XG4gICAgc2tpcFVFRygpOyAvLyBtYXhfbnVtX3JlZl9mcmFtZXNcbiAgICBza2lwQml0cygxKTsgLy8gZ2Fwc19pbl9mcmFtZV9udW1fdmFsdWVfYWxsb3dlZF9mbGFnXG4gICAgY29uc3QgcGljV2lkdGhJbk1ic01pbnVzMSA9IHJlYWRVRUcoKTtcbiAgICBjb25zdCBwaWNIZWlnaHRJbk1hcFVuaXRzTWludXMxID0gcmVhZFVFRygpO1xuICAgIGNvbnN0IGZyYW1lTWJzT25seUZsYWcgPSByZWFkQml0cygxKTtcbiAgICBpZiAoZnJhbWVNYnNPbmx5RmxhZyA9PT0gMCkge1xuICAgICAgc2tpcEJpdHMoMSk7XG4gICAgfSAvLyBtYl9hZGFwdGl2ZV9mcmFtZV9maWVsZF9mbGFnXG5cbiAgICBza2lwQml0cygxKTsgLy8gZGlyZWN0Xzh4OF9pbmZlcmVuY2VfZmxhZ1xuICAgIGlmIChyZWFkQm9vbGVhbigpKSB7XG4gICAgICAvLyBmcmFtZV9jcm9wcGluZ19mbGFnXG4gICAgICBmcmFtZUNyb3BMZWZ0T2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgICAgZnJhbWVDcm9wUmlnaHRPZmZzZXQgPSByZWFkVUVHKCk7XG4gICAgICBmcmFtZUNyb3BUb3BPZmZzZXQgPSByZWFkVUVHKCk7XG4gICAgICBmcmFtZUNyb3BCb3R0b21PZmZzZXQgPSByZWFkVUVHKCk7XG4gICAgfVxuICAgIGxldCBwaXhlbFJhdGlvID0gWzEsIDFdO1xuICAgIGlmIChyZWFkQm9vbGVhbigpKSB7XG4gICAgICAvLyB2dWlfcGFyYW1ldGVyc19wcmVzZW50X2ZsYWdcbiAgICAgIGlmIChyZWFkQm9vbGVhbigpKSB7XG4gICAgICAgIC8vIGFzcGVjdF9yYXRpb19pbmZvX3ByZXNlbnRfZmxhZ1xuICAgICAgICBjb25zdCBhc3BlY3RSYXRpb0lkYyA9IHJlYWRVQnl0ZSgpO1xuICAgICAgICBzd2l0Y2ggKGFzcGVjdFJhdGlvSWRjKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxLCAxXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMTIsIDExXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMTAsIDExXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMTYsIDExXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbNDAsIDMzXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMjQsIDExXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMjAsIDExXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMzIsIDExXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbODAsIDMzXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzE4LCAxMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxNSwgMTFdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbNjQsIDMzXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzE2MCwgOTldO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbNCwgM107XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFszLCAyXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzIsIDFdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyNTU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbcmVhZFVCeXRlKCkgPDwgOCB8IHJlYWRVQnl0ZSgpLCByZWFkVUJ5dGUoKSA8PCA4IHwgcmVhZFVCeXRlKCldO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IE1hdGguY2VpbCgocGljV2lkdGhJbk1ic01pbnVzMSArIDEpICogMTYgLSBmcmFtZUNyb3BMZWZ0T2Zmc2V0ICogMiAtIGZyYW1lQ3JvcFJpZ2h0T2Zmc2V0ICogMiksXG4gICAgICBoZWlnaHQ6ICgyIC0gZnJhbWVNYnNPbmx5RmxhZykgKiAocGljSGVpZ2h0SW5NYXBVbml0c01pbnVzMSArIDEpICogMTYgLSAoZnJhbWVNYnNPbmx5RmxhZyA/IDIgOiA0KSAqIChmcmFtZUNyb3BUb3BPZmZzZXQgKyBmcmFtZUNyb3BCb3R0b21PZmZzZXQpLFxuICAgICAgcGl4ZWxSYXRpbzogcGl4ZWxSYXRpb1xuICAgIH07XG4gIH1cbn1cblxuY2xhc3MgSGV2Y1ZpZGVvUGFyc2VyIGV4dGVuZHMgQmFzZVZpZGVvUGFyc2VyIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIHRoaXMuaW5pdFZQUyA9IG51bGw7XG4gIH1cbiAgcGFyc2VQRVModHJhY2ssIHRleHRUcmFjaywgcGVzLCBlbmRPZlNlZ21lbnQpIHtcbiAgICBjb25zdCB1bml0cyA9IHRoaXMucGFyc2VOQUx1KHRyYWNrLCBwZXMuZGF0YSwgZW5kT2ZTZWdtZW50KTtcbiAgICBsZXQgVmlkZW9TYW1wbGUgPSB0aGlzLlZpZGVvU2FtcGxlO1xuICAgIGxldCBwdXNoO1xuICAgIGxldCBzcHNmb3VuZCA9IGZhbHNlO1xuICAgIC8vIGZyZWUgcGVzLmRhdGEgdG8gc2F2ZSB1cCBzb21lIG1lbW9yeVxuICAgIHBlcy5kYXRhID0gbnVsbDtcblxuICAgIC8vIGlmIG5ldyBOQUwgdW5pdHMgZm91bmQgYW5kIGxhc3Qgc2FtcGxlIHN0aWxsIHRoZXJlLCBsZXQncyBwdXNoIC4uLlxuICAgIC8vIHRoaXMgaGVscHMgcGFyc2luZyBzdHJlYW1zIHdpdGggbWlzc2luZyBBVUQgKG9ubHkgZG8gdGhpcyBpZiBBVUQgbmV2ZXIgZm91bmQpXG4gICAgaWYgKFZpZGVvU2FtcGxlICYmIHVuaXRzLmxlbmd0aCAmJiAhdHJhY2suYXVkRm91bmQpIHtcbiAgICAgIHRoaXMucHVzaEFjY2Vzc1VuaXQoVmlkZW9TYW1wbGUsIHRyYWNrKTtcbiAgICAgIFZpZGVvU2FtcGxlID0gdGhpcy5WaWRlb1NhbXBsZSA9IHRoaXMuY3JlYXRlVmlkZW9TYW1wbGUoZmFsc2UsIHBlcy5wdHMsIHBlcy5kdHMpO1xuICAgIH1cbiAgICB1bml0cy5mb3JFYWNoKHVuaXQgPT4ge1xuICAgICAgdmFyIF9WaWRlb1NhbXBsZTIsIF9WaWRlb1NhbXBsZTM7XG4gICAgICBzd2l0Y2ggKHVuaXQudHlwZSkge1xuICAgICAgICAvLyBOT04tSURSLCBOT04gUkFORE9NIEFDQ0VTUyBTTElDRVxuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBjYXNlIDM6XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICBjYXNlIDY6XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgaWYgKCFWaWRlb1NhbXBsZSkge1xuICAgICAgICAgICAgVmlkZW9TYW1wbGUgPSB0aGlzLlZpZGVvU2FtcGxlID0gdGhpcy5jcmVhdGVWaWRlb1NhbXBsZShmYWxzZSwgcGVzLnB0cywgcGVzLmR0cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFZpZGVvU2FtcGxlLmZyYW1lID0gdHJ1ZTtcbiAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICAvLyBDUkEsIEJMQSAocmFuZG9tIGFjY2VzcyBwaWN0dXJlKVxuICAgICAgICBjYXNlIDE2OlxuICAgICAgICBjYXNlIDE3OlxuICAgICAgICBjYXNlIDE4OlxuICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgIGlmIChzcHNmb3VuZCkge1xuICAgICAgICAgICAgdmFyIF9WaWRlb1NhbXBsZTtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBQRVMgbm90IHN0YXJ0aW5nIHdpdGggQVVEXG4gICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGZyYW1lIGRhdGEgYWxyZWFkeSwgdGhhdCBjYW5ub3QgYmVsb25nIHRvIHRoZSBzYW1lIGZyYW1lLCBzbyBmb3JjZSBhIHB1c2hcbiAgICAgICAgICAgIGlmICgoX1ZpZGVvU2FtcGxlID0gVmlkZW9TYW1wbGUpICE9IG51bGwgJiYgX1ZpZGVvU2FtcGxlLmZyYW1lICYmICFWaWRlb1NhbXBsZS5rZXkpIHtcbiAgICAgICAgICAgICAgdGhpcy5wdXNoQWNjZXNzVW5pdChWaWRlb1NhbXBsZSwgdHJhY2spO1xuICAgICAgICAgICAgICBWaWRlb1NhbXBsZSA9IHRoaXMuVmlkZW9TYW1wbGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIVZpZGVvU2FtcGxlKSB7XG4gICAgICAgICAgICBWaWRlb1NhbXBsZSA9IHRoaXMuVmlkZW9TYW1wbGUgPSB0aGlzLmNyZWF0ZVZpZGVvU2FtcGxlKHRydWUsIHBlcy5wdHMsIHBlcy5kdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBWaWRlb1NhbXBsZS5rZXkgPSB0cnVlO1xuICAgICAgICAgIFZpZGVvU2FtcGxlLmZyYW1lID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICAvLyBJRFJcbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICAvLyBoYW5kbGUgUEVTIG5vdCBzdGFydGluZyB3aXRoIEFVRFxuICAgICAgICAgIC8vIGlmIHdlIGhhdmUgZnJhbWUgZGF0YSBhbHJlYWR5LCB0aGF0IGNhbm5vdCBiZWxvbmcgdG8gdGhlIHNhbWUgZnJhbWUsIHNvIGZvcmNlIGEgcHVzaFxuICAgICAgICAgIGlmICgoX1ZpZGVvU2FtcGxlMiA9IFZpZGVvU2FtcGxlKSAhPSBudWxsICYmIF9WaWRlb1NhbXBsZTIuZnJhbWUgJiYgIVZpZGVvU2FtcGxlLmtleSkge1xuICAgICAgICAgICAgdGhpcy5wdXNoQWNjZXNzVW5pdChWaWRlb1NhbXBsZSwgdHJhY2spO1xuICAgICAgICAgICAgVmlkZW9TYW1wbGUgPSB0aGlzLlZpZGVvU2FtcGxlID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFWaWRlb1NhbXBsZSkge1xuICAgICAgICAgICAgVmlkZW9TYW1wbGUgPSB0aGlzLlZpZGVvU2FtcGxlID0gdGhpcy5jcmVhdGVWaWRlb1NhbXBsZSh0cnVlLCBwZXMucHRzLCBwZXMuZHRzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgVmlkZW9TYW1wbGUua2V5ID0gdHJ1ZTtcbiAgICAgICAgICBWaWRlb1NhbXBsZS5mcmFtZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gU0VJXG4gICAgICAgIGNhc2UgMzk6XG4gICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgcGFyc2VTRUlNZXNzYWdlRnJvbU5BTHUodW5pdC5kYXRhLCAyLFxuICAgICAgICAgIC8vIE5BTHUgaGVhZGVyIHNpemVcbiAgICAgICAgICBwZXMucHRzLCB0ZXh0VHJhY2suc2FtcGxlcyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gVlBTXG4gICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgaWYgKCF0cmFjay52cHMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdHJhY2sucGFyYW1zICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICB0cmFjay5wYXJhbXMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNrLnBhcmFtcyA9IF9leHRlbmRzKHRyYWNrLnBhcmFtcywgdGhpcy5yZWFkVlBTKHVuaXQuZGF0YSkpO1xuICAgICAgICAgICAgdGhpcy5pbml0VlBTID0gdW5pdC5kYXRhO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cmFjay52cHMgPSBbdW5pdC5kYXRhXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICAvLyBTUFNcbiAgICAgICAgY2FzZSAzMzpcbiAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICBzcHNmb3VuZCA9IHRydWU7XG4gICAgICAgICAgaWYgKHRyYWNrLnZwcyAhPT0gdW5kZWZpbmVkICYmIHRyYWNrLnZwc1swXSAhPT0gdGhpcy5pbml0VlBTICYmIHRyYWNrLnNwcyAhPT0gdW5kZWZpbmVkICYmICF0aGlzLm1hdGNoU1BTKHRyYWNrLnNwc1swXSwgdW5pdC5kYXRhKSkge1xuICAgICAgICAgICAgdGhpcy5pbml0VlBTID0gdHJhY2sudnBzWzBdO1xuICAgICAgICAgICAgdHJhY2suc3BzID0gdHJhY2sucHBzID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRyYWNrLnNwcykge1xuICAgICAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5yZWFkU1BTKHVuaXQuZGF0YSk7XG4gICAgICAgICAgICB0cmFjay53aWR0aCA9IGNvbmZpZy53aWR0aDtcbiAgICAgICAgICAgIHRyYWNrLmhlaWdodCA9IGNvbmZpZy5oZWlnaHQ7XG4gICAgICAgICAgICB0cmFjay5waXhlbFJhdGlvID0gY29uZmlnLnBpeGVsUmF0aW87XG4gICAgICAgICAgICB0cmFjay5jb2RlYyA9IGNvbmZpZy5jb2RlY1N0cmluZztcbiAgICAgICAgICAgIHRyYWNrLnNwcyA9IFtdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0cmFjay5wYXJhbXMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgIHRyYWNrLnBhcmFtcyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIGNvbmZpZy5wYXJhbXMpIHtcbiAgICAgICAgICAgICAgdHJhY2sucGFyYW1zW3Byb3BdID0gY29uZmlnLnBhcmFtc1twcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5wdXNoUGFyYW1ldGVyU2V0KHRyYWNrLnNwcywgdW5pdC5kYXRhLCB0cmFjay52cHMpO1xuICAgICAgICAgIGlmICghVmlkZW9TYW1wbGUpIHtcbiAgICAgICAgICAgIFZpZGVvU2FtcGxlID0gdGhpcy5WaWRlb1NhbXBsZSA9IHRoaXMuY3JlYXRlVmlkZW9TYW1wbGUodHJ1ZSwgcGVzLnB0cywgcGVzLmR0cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFZpZGVvU2FtcGxlLmtleSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gUFBTXG4gICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0cmFjay5wYXJhbXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAoIXRyYWNrLnBwcykge1xuICAgICAgICAgICAgICB0cmFjay5wcHMgPSBbXTtcbiAgICAgICAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5yZWFkUFBTKHVuaXQuZGF0YSk7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBjb25maWcpIHtcbiAgICAgICAgICAgICAgICB0cmFjay5wYXJhbXNbcHJvcF0gPSBjb25maWdbcHJvcF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHVzaFBhcmFtZXRlclNldCh0cmFjay5wcHMsIHVuaXQuZGF0YSwgdHJhY2sudnBzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gQUNDRVNTIFVOSVQgREVMSU1JVEVSXG4gICAgICAgIGNhc2UgMzU6XG4gICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgdHJhY2suYXVkRm91bmQgPSB0cnVlO1xuICAgICAgICAgIGlmICgoX1ZpZGVvU2FtcGxlMyA9IFZpZGVvU2FtcGxlKSAhPSBudWxsICYmIF9WaWRlb1NhbXBsZTMuZnJhbWUpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaEFjY2Vzc1VuaXQoVmlkZW9TYW1wbGUsIHRyYWNrKTtcbiAgICAgICAgICAgIFZpZGVvU2FtcGxlID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFWaWRlb1NhbXBsZSkge1xuICAgICAgICAgICAgVmlkZW9TYW1wbGUgPSB0aGlzLlZpZGVvU2FtcGxlID0gdGhpcy5jcmVhdGVWaWRlb1NhbXBsZShmYWxzZSwgcGVzLnB0cywgcGVzLmR0cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2ggPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChWaWRlb1NhbXBsZSAmJiBwdXNoKSB7XG4gICAgICAgIGNvbnN0IHVuaXRzID0gVmlkZW9TYW1wbGUudW5pdHM7XG4gICAgICAgIHVuaXRzLnB1c2godW5pdCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gaWYgbGFzdCBQRVMgcGFja2V0LCBwdXNoIHNhbXBsZXNcbiAgICBpZiAoZW5kT2ZTZWdtZW50ICYmIFZpZGVvU2FtcGxlKSB7XG4gICAgICB0aGlzLnB1c2hBY2Nlc3NVbml0KFZpZGVvU2FtcGxlLCB0cmFjayk7XG4gICAgICB0aGlzLlZpZGVvU2FtcGxlID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgcHVzaFBhcmFtZXRlclNldChwYXJhbWV0ZXJTZXRzLCBkYXRhLCB2cHMpIHtcbiAgICBpZiAodnBzICYmIHZwc1swXSA9PT0gdGhpcy5pbml0VlBTIHx8ICF2cHMgJiYgIXBhcmFtZXRlclNldHMubGVuZ3RoKSB7XG4gICAgICBwYXJhbWV0ZXJTZXRzLnB1c2goZGF0YSk7XG4gICAgfVxuICB9XG4gIGdldE5BTHVUeXBlKGRhdGEsIG9mZnNldCkge1xuICAgIHJldHVybiAoZGF0YVtvZmZzZXRdICYgMHg3ZSkgPj4+IDE7XG4gIH1cbiAgZWJzcDJyYnNwKGFycikge1xuICAgIGNvbnN0IGRzdCA9IG5ldyBVaW50OEFycmF5KGFyci5ieXRlTGVuZ3RoKTtcbiAgICBsZXQgZHN0SWR4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5ieXRlTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChpID49IDIpIHtcbiAgICAgICAgLy8gVW5lc2NhcGU6IFNraXAgMHgwMyBhZnRlciAwMCAwMFxuICAgICAgICBpZiAoYXJyW2ldID09PSAweDAzICYmIGFycltpIC0gMV0gPT09IDB4MDAgJiYgYXJyW2kgLSAyXSA9PT0gMHgwMCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkc3RbZHN0SWR4XSA9IGFycltpXTtcbiAgICAgIGRzdElkeCsrO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZHN0LmJ1ZmZlciwgMCwgZHN0SWR4KTtcbiAgfVxuICBwdXNoQWNjZXNzVW5pdChWaWRlb1NhbXBsZSwgdmlkZW9UcmFjaykge1xuICAgIHN1cGVyLnB1c2hBY2Nlc3NVbml0KFZpZGVvU2FtcGxlLCB2aWRlb1RyYWNrKTtcbiAgICBpZiAodGhpcy5pbml0VlBTKSB7XG4gICAgICB0aGlzLmluaXRWUFMgPSBudWxsOyAvLyBudWxsIGluaXRWUFMgdG8gcHJldmVudCBwb3NzaWJsZSB0cmFjaydzIHNwcy9wcHMgZ3Jvd3RoIHVudGlsIG5leHQgVlBTXG4gICAgfVxuICB9XG4gIHJlYWRWUFModnBzKSB7XG4gICAgY29uc3QgZWcgPSBuZXcgRXhwR29sb21iKHZwcyk7XG4gICAgLy8gcmVtb3ZlIGhlYWRlclxuICAgIGVnLnJlYWRVQnl0ZSgpO1xuICAgIGVnLnJlYWRVQnl0ZSgpO1xuICAgIGVnLnJlYWRCaXRzKDQpOyAvLyB2aWRlb19wYXJhbWV0ZXJfc2V0X2lkXG4gICAgZWcuc2tpcEJpdHMoMik7XG4gICAgZWcucmVhZEJpdHMoNik7IC8vIG1heF9sYXllcnNfbWludXMxXG4gICAgY29uc3QgbWF4X3N1Yl9sYXllcnNfbWludXMxID0gZWcucmVhZEJpdHMoMyk7XG4gICAgY29uc3QgdGVtcG9yYWxfaWRfbmVzdGluZ19mbGFnID0gZWcucmVhZEJvb2xlYW4oKTtcbiAgICAvLyAuLi52dWkgZnBzIGNhbiBiZSBoZXJlLCBidXQgZW1wdHkgZnBzIHZhbHVlIGlzIG5vdCBjcml0aWNhbCBmb3IgbWV0YWRhdGFcblxuICAgIHJldHVybiB7XG4gICAgICBudW1UZW1wb3JhbExheWVyczogbWF4X3N1Yl9sYXllcnNfbWludXMxICsgMSxcbiAgICAgIHRlbXBvcmFsSWROZXN0ZWQ6IHRlbXBvcmFsX2lkX25lc3RpbmdfZmxhZ1xuICAgIH07XG4gIH1cbiAgcmVhZFNQUyhzcHMpIHtcbiAgICBjb25zdCBlZyA9IG5ldyBFeHBHb2xvbWIodGhpcy5lYnNwMnJic3Aoc3BzKSk7XG4gICAgZWcucmVhZFVCeXRlKCk7XG4gICAgZWcucmVhZFVCeXRlKCk7XG4gICAgZWcucmVhZEJpdHMoNCk7IC8vdmlkZW9fcGFyYW1ldGVyX3NldF9pZFxuICAgIGNvbnN0IG1heF9zdWJfbGF5ZXJzX21pbnVzMSA9IGVnLnJlYWRCaXRzKDMpO1xuICAgIGVnLnJlYWRCb29sZWFuKCk7IC8vIHRlbXBvcmFsX2lkX25lc3RpbmdfZmxhZ1xuXG4gICAgLy8gcHJvZmlsZV90aWVyX2xldmVsXG4gICAgY29uc3QgZ2VuZXJhbF9wcm9maWxlX3NwYWNlID0gZWcucmVhZEJpdHMoMik7XG4gICAgY29uc3QgZ2VuZXJhbF90aWVyX2ZsYWcgPSBlZy5yZWFkQm9vbGVhbigpO1xuICAgIGNvbnN0IGdlbmVyYWxfcHJvZmlsZV9pZGMgPSBlZy5yZWFkQml0cyg1KTtcbiAgICBjb25zdCBnZW5lcmFsX3Byb2ZpbGVfY29tcGF0aWJpbGl0eV9mbGFnc18xID0gZWcucmVhZFVCeXRlKCk7XG4gICAgY29uc3QgZ2VuZXJhbF9wcm9maWxlX2NvbXBhdGliaWxpdHlfZmxhZ3NfMiA9IGVnLnJlYWRVQnl0ZSgpO1xuICAgIGNvbnN0IGdlbmVyYWxfcHJvZmlsZV9jb21wYXRpYmlsaXR5X2ZsYWdzXzMgPSBlZy5yZWFkVUJ5dGUoKTtcbiAgICBjb25zdCBnZW5lcmFsX3Byb2ZpbGVfY29tcGF0aWJpbGl0eV9mbGFnc180ID0gZWcucmVhZFVCeXRlKCk7XG4gICAgY29uc3QgZ2VuZXJhbF9jb25zdHJhaW50X2luZGljYXRvcl9mbGFnc18xID0gZWcucmVhZFVCeXRlKCk7XG4gICAgY29uc3QgZ2VuZXJhbF9jb25zdHJhaW50X2luZGljYXRvcl9mbGFnc18yID0gZWcucmVhZFVCeXRlKCk7XG4gICAgY29uc3QgZ2VuZXJhbF9jb25zdHJhaW50X2luZGljYXRvcl9mbGFnc18zID0gZWcucmVhZFVCeXRlKCk7XG4gICAgY29uc3QgZ2VuZXJhbF9jb25zdHJhaW50X2luZGljYXRvcl9mbGFnc180ID0gZWcucmVhZFVCeXRlKCk7XG4gICAgY29uc3QgZ2VuZXJhbF9jb25zdHJhaW50X2luZGljYXRvcl9mbGFnc181ID0gZWcucmVhZFVCeXRlKCk7XG4gICAgY29uc3QgZ2VuZXJhbF9jb25zdHJhaW50X2luZGljYXRvcl9mbGFnc182ID0gZWcucmVhZFVCeXRlKCk7XG4gICAgY29uc3QgZ2VuZXJhbF9sZXZlbF9pZGMgPSBlZy5yZWFkVUJ5dGUoKTtcbiAgICBjb25zdCBzdWJfbGF5ZXJfcHJvZmlsZV9wcmVzZW50X2ZsYWdzID0gW107XG4gICAgY29uc3Qgc3ViX2xheWVyX2xldmVsX3ByZXNlbnRfZmxhZ3MgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heF9zdWJfbGF5ZXJzX21pbnVzMTsgaSsrKSB7XG4gICAgICBzdWJfbGF5ZXJfcHJvZmlsZV9wcmVzZW50X2ZsYWdzLnB1c2goZWcucmVhZEJvb2xlYW4oKSk7XG4gICAgICBzdWJfbGF5ZXJfbGV2ZWxfcHJlc2VudF9mbGFncy5wdXNoKGVnLnJlYWRCb29sZWFuKCkpO1xuICAgIH1cbiAgICBpZiAobWF4X3N1Yl9sYXllcnNfbWludXMxID4gMCkge1xuICAgICAgZm9yIChsZXQgaSA9IG1heF9zdWJfbGF5ZXJzX21pbnVzMTsgaSA8IDg7IGkrKykge1xuICAgICAgICBlZy5yZWFkQml0cygyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhfc3ViX2xheWVyc19taW51czE7IGkrKykge1xuICAgICAgaWYgKHN1Yl9sYXllcl9wcm9maWxlX3ByZXNlbnRfZmxhZ3NbaV0pIHtcbiAgICAgICAgZWcucmVhZFVCeXRlKCk7IC8vIHN1Yl9sYXllcl9wcm9maWxlX3NwYWNlLCBzdWJfbGF5ZXJfdGllcl9mbGFnLCBzdWJfbGF5ZXJfcHJvZmlsZV9pZGNcbiAgICAgICAgZWcucmVhZFVCeXRlKCk7XG4gICAgICAgIGVnLnJlYWRVQnl0ZSgpO1xuICAgICAgICBlZy5yZWFkVUJ5dGUoKTtcbiAgICAgICAgZWcucmVhZFVCeXRlKCk7IC8vIHN1Yl9sYXllcl9wcm9maWxlX2NvbXBhdGliaWxpdHlfZmxhZ1xuICAgICAgICBlZy5yZWFkVUJ5dGUoKTtcbiAgICAgICAgZWcucmVhZFVCeXRlKCk7XG4gICAgICAgIGVnLnJlYWRVQnl0ZSgpO1xuICAgICAgICBlZy5yZWFkVUJ5dGUoKTtcbiAgICAgICAgZWcucmVhZFVCeXRlKCk7XG4gICAgICAgIGVnLnJlYWRVQnl0ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKHN1Yl9sYXllcl9sZXZlbF9wcmVzZW50X2ZsYWdzW2ldKSB7XG4gICAgICAgIGVnLnJlYWRVQnl0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBlZy5yZWFkVUVHKCk7IC8vIHNlcV9wYXJhbWV0ZXJfc2V0X2lkXG4gICAgY29uc3QgY2hyb21hX2Zvcm1hdF9pZGMgPSBlZy5yZWFkVUVHKCk7XG4gICAgaWYgKGNocm9tYV9mb3JtYXRfaWRjID09IDMpIHtcbiAgICAgIGVnLnNraXBCaXRzKDEpOyAvL3NlcGFyYXRlX2NvbG91cl9wbGFuZV9mbGFnXG4gICAgfVxuICAgIGNvbnN0IHBpY193aWR0aF9pbl9sdW1hX3NhbXBsZXMgPSBlZy5yZWFkVUVHKCk7XG4gICAgY29uc3QgcGljX2hlaWdodF9pbl9sdW1hX3NhbXBsZXMgPSBlZy5yZWFkVUVHKCk7XG4gICAgY29uc3QgY29uZm9ybWFuY2Vfd2luZG93X2ZsYWcgPSBlZy5yZWFkQm9vbGVhbigpO1xuICAgIGxldCBwaWNfbGVmdF9vZmZzZXQgPSAwLFxuICAgICAgcGljX3JpZ2h0X29mZnNldCA9IDAsXG4gICAgICBwaWNfdG9wX29mZnNldCA9IDAsXG4gICAgICBwaWNfYm90dG9tX29mZnNldCA9IDA7XG4gICAgaWYgKGNvbmZvcm1hbmNlX3dpbmRvd19mbGFnKSB7XG4gICAgICBwaWNfbGVmdF9vZmZzZXQgKz0gZWcucmVhZFVFRygpO1xuICAgICAgcGljX3JpZ2h0X29mZnNldCArPSBlZy5yZWFkVUVHKCk7XG4gICAgICBwaWNfdG9wX29mZnNldCArPSBlZy5yZWFkVUVHKCk7XG4gICAgICBwaWNfYm90dG9tX29mZnNldCArPSBlZy5yZWFkVUVHKCk7XG4gICAgfVxuICAgIGNvbnN0IGJpdF9kZXB0aF9sdW1hX21pbnVzOCA9IGVnLnJlYWRVRUcoKTtcbiAgICBjb25zdCBiaXRfZGVwdGhfY2hyb21hX21pbnVzOCA9IGVnLnJlYWRVRUcoKTtcbiAgICBjb25zdCBsb2cyX21heF9waWNfb3JkZXJfY250X2xzYl9taW51czQgPSBlZy5yZWFkVUVHKCk7XG4gICAgY29uc3Qgc3ViX2xheWVyX29yZGVyaW5nX2luZm9fcHJlc2VudF9mbGFnID0gZWcucmVhZEJvb2xlYW4oKTtcbiAgICBmb3IgKGxldCBpID0gc3ViX2xheWVyX29yZGVyaW5nX2luZm9fcHJlc2VudF9mbGFnID8gMCA6IG1heF9zdWJfbGF5ZXJzX21pbnVzMTsgaSA8PSBtYXhfc3ViX2xheWVyc19taW51czE7IGkrKykge1xuICAgICAgZWcuc2tpcFVFRygpOyAvLyBtYXhfZGVjX3BpY19idWZmZXJpbmdfbWludXMxW2ldXG4gICAgICBlZy5za2lwVUVHKCk7IC8vIG1heF9udW1fcmVvcmRlcl9waWNzW2ldXG4gICAgICBlZy5za2lwVUVHKCk7IC8vIG1heF9sYXRlbmN5X2luY3JlYXNlX3BsdXMxW2ldXG4gICAgfVxuICAgIGVnLnNraXBVRUcoKTsgLy8gbG9nMl9taW5fbHVtYV9jb2RpbmdfYmxvY2tfc2l6ZV9taW51czNcbiAgICBlZy5za2lwVUVHKCk7IC8vIGxvZzJfZGlmZl9tYXhfbWluX2x1bWFfY29kaW5nX2Jsb2NrX3NpemVcbiAgICBlZy5za2lwVUVHKCk7IC8vIGxvZzJfbWluX3RyYW5zZm9ybV9ibG9ja19zaXplX21pbnVzMlxuICAgIGVnLnNraXBVRUcoKTsgLy8gbG9nMl9kaWZmX21heF9taW5fdHJhbnNmb3JtX2Jsb2NrX3NpemVcbiAgICBlZy5za2lwVUVHKCk7IC8vIG1heF90cmFuc2Zvcm1faGllcmFyY2h5X2RlcHRoX2ludGVyXG4gICAgZWcuc2tpcFVFRygpOyAvLyBtYXhfdHJhbnNmb3JtX2hpZXJhcmNoeV9kZXB0aF9pbnRyYVxuICAgIGNvbnN0IHNjYWxpbmdfbGlzdF9lbmFibGVkX2ZsYWcgPSBlZy5yZWFkQm9vbGVhbigpO1xuICAgIGlmIChzY2FsaW5nX2xpc3RfZW5hYmxlZF9mbGFnKSB7XG4gICAgICBjb25zdCBzcHNfc2NhbGluZ19saXN0X2RhdGFfcHJlc2VudF9mbGFnID0gZWcucmVhZEJvb2xlYW4oKTtcbiAgICAgIGlmIChzcHNfc2NhbGluZ19saXN0X2RhdGFfcHJlc2VudF9mbGFnKSB7XG4gICAgICAgIGZvciAobGV0IHNpemVJZCA9IDA7IHNpemVJZCA8IDQ7IHNpemVJZCsrKSB7XG4gICAgICAgICAgZm9yIChsZXQgbWF0cml4SWQgPSAwOyBtYXRyaXhJZCA8IChzaXplSWQgPT09IDMgPyAyIDogNik7IG1hdHJpeElkKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxpbmdfbGlzdF9wcmVkX21vZGVfZmxhZyA9IGVnLnJlYWRCb29sZWFuKCk7XG4gICAgICAgICAgICBpZiAoIXNjYWxpbmdfbGlzdF9wcmVkX21vZGVfZmxhZykge1xuICAgICAgICAgICAgICBlZy5yZWFkVUVHKCk7IC8vIHNjYWxpbmdfbGlzdF9wcmVkX21hdHJpeF9pZF9kZWx0YVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgY29lZk51bSA9IE1hdGgubWluKDY0LCAxIDw8IDQgKyAoc2l6ZUlkIDw8IDEpKTtcbiAgICAgICAgICAgICAgaWYgKHNpemVJZCA+IDEpIHtcbiAgICAgICAgICAgICAgICBlZy5yZWFkRUcoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvZWZOdW07IGkrKykge1xuICAgICAgICAgICAgICAgIGVnLnJlYWRFRygpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGVnLnJlYWRCb29sZWFuKCk7IC8vIGFtcF9lbmFibGVkX2ZsYWdcbiAgICBlZy5yZWFkQm9vbGVhbigpOyAvLyBzYW1wbGVfYWRhcHRpdmVfb2Zmc2V0X2VuYWJsZWRfZmxhZ1xuICAgIGNvbnN0IHBjbV9lbmFibGVkX2ZsYWcgPSBlZy5yZWFkQm9vbGVhbigpO1xuICAgIGlmIChwY21fZW5hYmxlZF9mbGFnKSB7XG4gICAgICBlZy5yZWFkVUJ5dGUoKTtcbiAgICAgIGVnLnNraXBVRUcoKTtcbiAgICAgIGVnLnNraXBVRUcoKTtcbiAgICAgIGVnLnJlYWRCb29sZWFuKCk7XG4gICAgfVxuICAgIGNvbnN0IG51bV9zaG9ydF90ZXJtX3JlZl9waWNfc2V0cyA9IGVnLnJlYWRVRUcoKTtcbiAgICBsZXQgbnVtX2RlbHRhX3BvY3MgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtX3Nob3J0X3Rlcm1fcmVmX3BpY19zZXRzOyBpKyspIHtcbiAgICAgIGxldCBpbnRlcl9yZWZfcGljX3NldF9wcmVkaWN0aW9uX2ZsYWcgPSBmYWxzZTtcbiAgICAgIGlmIChpICE9PSAwKSB7XG4gICAgICAgIGludGVyX3JlZl9waWNfc2V0X3ByZWRpY3Rpb25fZmxhZyA9IGVnLnJlYWRCb29sZWFuKCk7XG4gICAgICB9XG4gICAgICBpZiAoaW50ZXJfcmVmX3BpY19zZXRfcHJlZGljdGlvbl9mbGFnKSB7XG4gICAgICAgIGlmIChpID09PSBudW1fc2hvcnRfdGVybV9yZWZfcGljX3NldHMpIHtcbiAgICAgICAgICBlZy5yZWFkVUVHKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWcucmVhZEJvb2xlYW4oKTtcbiAgICAgICAgZWcucmVhZFVFRygpO1xuICAgICAgICBsZXQgbmV4dF9udW1fZGVsdGFfcG9jcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDw9IG51bV9kZWx0YV9wb2NzOyBqKyspIHtcbiAgICAgICAgICBjb25zdCB1c2VkX2J5X2N1cnJfcGljX2ZsYWcgPSBlZy5yZWFkQm9vbGVhbigpO1xuICAgICAgICAgIGxldCB1c2VfZGVsdGFfZmxhZyA9IGZhbHNlO1xuICAgICAgICAgIGlmICghdXNlZF9ieV9jdXJyX3BpY19mbGFnKSB7XG4gICAgICAgICAgICB1c2VfZGVsdGFfZmxhZyA9IGVnLnJlYWRCb29sZWFuKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh1c2VkX2J5X2N1cnJfcGljX2ZsYWcgfHwgdXNlX2RlbHRhX2ZsYWcpIHtcbiAgICAgICAgICAgIG5leHRfbnVtX2RlbHRhX3BvY3MrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbnVtX2RlbHRhX3BvY3MgPSBuZXh0X251bV9kZWx0YV9wb2NzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbnVtX25lZ2F0aXZlX3BpY3MgPSBlZy5yZWFkVUVHKCk7XG4gICAgICAgIGNvbnN0IG51bV9wb3NpdGl2ZV9waWNzID0gZWcucmVhZFVFRygpO1xuICAgICAgICBudW1fZGVsdGFfcG9jcyA9IG51bV9uZWdhdGl2ZV9waWNzICsgbnVtX3Bvc2l0aXZlX3BpY3M7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtX25lZ2F0aXZlX3BpY3M7IGorKykge1xuICAgICAgICAgIGVnLnJlYWRVRUcoKTtcbiAgICAgICAgICBlZy5yZWFkQm9vbGVhbigpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtX3Bvc2l0aXZlX3BpY3M7IGorKykge1xuICAgICAgICAgIGVnLnJlYWRVRUcoKTtcbiAgICAgICAgICBlZy5yZWFkQm9vbGVhbigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxvbmdfdGVybV9yZWZfcGljc19wcmVzZW50X2ZsYWcgPSBlZy5yZWFkQm9vbGVhbigpO1xuICAgIGlmIChsb25nX3Rlcm1fcmVmX3BpY3NfcHJlc2VudF9mbGFnKSB7XG4gICAgICBjb25zdCBudW1fbG9uZ190ZXJtX3JlZl9waWNzX3NwcyA9IGVnLnJlYWRVRUcoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtX2xvbmdfdGVybV9yZWZfcGljc19zcHM7IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxvZzJfbWF4X3BpY19vcmRlcl9jbnRfbHNiX21pbnVzNCArIDQ7IGorKykge1xuICAgICAgICAgIGVnLnJlYWRCaXRzKDEpO1xuICAgICAgICB9XG4gICAgICAgIGVnLnJlYWRCaXRzKDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgbWluX3NwYXRpYWxfc2VnbWVudGF0aW9uX2lkYyA9IDA7XG4gICAgbGV0IHNhcl93aWR0aCA9IDEsXG4gICAgICBzYXJfaGVpZ2h0ID0gMTtcbiAgICBsZXQgZnBzX2ZpeGVkID0gdHJ1ZSxcbiAgICAgIGZwc19kZW4gPSAxLFxuICAgICAgZnBzX251bSA9IDA7XG4gICAgZWcucmVhZEJvb2xlYW4oKTsgLy8gc3BzX3RlbXBvcmFsX212cF9lbmFibGVkX2ZsYWdcbiAgICBlZy5yZWFkQm9vbGVhbigpOyAvLyBzdHJvbmdfaW50cmFfc21vb3RoaW5nX2VuYWJsZWRfZmxhZ1xuICAgIGxldCBkZWZhdWx0X2Rpc3BsYXlfd2luZG93X2ZsYWcgPSBmYWxzZTtcbiAgICBjb25zdCB2dWlfcGFyYW1ldGVyc19wcmVzZW50X2ZsYWcgPSBlZy5yZWFkQm9vbGVhbigpO1xuICAgIGlmICh2dWlfcGFyYW1ldGVyc19wcmVzZW50X2ZsYWcpIHtcbiAgICAgIGNvbnN0IGFzcGVjdF9yYXRpb19pbmZvX3ByZXNlbnRfZmxhZyA9IGVnLnJlYWRCb29sZWFuKCk7XG4gICAgICBpZiAoYXNwZWN0X3JhdGlvX2luZm9fcHJlc2VudF9mbGFnKSB7XG4gICAgICAgIGNvbnN0IGFzcGVjdF9yYXRpb19pZGMgPSBlZy5yZWFkVUJ5dGUoKTtcbiAgICAgICAgY29uc3Qgc2FyX3dpZHRoX3RhYmxlID0gWzEsIDEyLCAxMCwgMTYsIDQwLCAyNCwgMjAsIDMyLCA4MCwgMTgsIDE1LCA2NCwgMTYwLCA0LCAzLCAyXTtcbiAgICAgICAgY29uc3Qgc2FyX2hlaWdodF90YWJsZSA9IFsxLCAxMSwgMTEsIDExLCAzMywgMTEsIDExLCAxMSwgMzMsIDExLCAxMSwgMzMsIDk5LCAzLCAyLCAxXTtcbiAgICAgICAgaWYgKGFzcGVjdF9yYXRpb19pZGMgPiAwICYmIGFzcGVjdF9yYXRpb19pZGMgPCAxNikge1xuICAgICAgICAgIHNhcl93aWR0aCA9IHNhcl93aWR0aF90YWJsZVthc3BlY3RfcmF0aW9faWRjIC0gMV07XG4gICAgICAgICAgc2FyX2hlaWdodCA9IHNhcl9oZWlnaHRfdGFibGVbYXNwZWN0X3JhdGlvX2lkYyAtIDFdO1xuICAgICAgICB9IGVsc2UgaWYgKGFzcGVjdF9yYXRpb19pZGMgPT09IDI1NSkge1xuICAgICAgICAgIHNhcl93aWR0aCA9IGVnLnJlYWRCaXRzKDE2KTtcbiAgICAgICAgICBzYXJfaGVpZ2h0ID0gZWcucmVhZEJpdHMoMTYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBvdmVyc2Nhbl9pbmZvX3ByZXNlbnRfZmxhZyA9IGVnLnJlYWRCb29sZWFuKCk7XG4gICAgICBpZiAob3ZlcnNjYW5faW5mb19wcmVzZW50X2ZsYWcpIHtcbiAgICAgICAgZWcucmVhZEJvb2xlYW4oKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZpZGVvX3NpZ25hbF90eXBlX3ByZXNlbnRfZmxhZyA9IGVnLnJlYWRCb29sZWFuKCk7XG4gICAgICBpZiAodmlkZW9fc2lnbmFsX3R5cGVfcHJlc2VudF9mbGFnKSB7XG4gICAgICAgIGVnLnJlYWRCaXRzKDMpO1xuICAgICAgICBlZy5yZWFkQm9vbGVhbigpO1xuICAgICAgICBjb25zdCBjb2xvdXJfZGVzY3JpcHRpb25fcHJlc2VudF9mbGFnID0gZWcucmVhZEJvb2xlYW4oKTtcbiAgICAgICAgaWYgKGNvbG91cl9kZXNjcmlwdGlvbl9wcmVzZW50X2ZsYWcpIHtcbiAgICAgICAgICBlZy5yZWFkVUJ5dGUoKTtcbiAgICAgICAgICBlZy5yZWFkVUJ5dGUoKTtcbiAgICAgICAgICBlZy5yZWFkVUJ5dGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgY2hyb21hX2xvY19pbmZvX3ByZXNlbnRfZmxhZyA9IGVnLnJlYWRCb29sZWFuKCk7XG4gICAgICBpZiAoY2hyb21hX2xvY19pbmZvX3ByZXNlbnRfZmxhZykge1xuICAgICAgICBlZy5yZWFkVUVHKCk7XG4gICAgICAgIGVnLnJlYWRVRUcoKTtcbiAgICAgIH1cbiAgICAgIGVnLnJlYWRCb29sZWFuKCk7IC8vIG5ldXRyYWxfY2hyb21hX2luZGljYXRpb25fZmxhZ1xuICAgICAgZWcucmVhZEJvb2xlYW4oKTsgLy8gZmllbGRfc2VxX2ZsYWdcbiAgICAgIGVnLnJlYWRCb29sZWFuKCk7IC8vIGZyYW1lX2ZpZWxkX2luZm9fcHJlc2VudF9mbGFnXG4gICAgICBkZWZhdWx0X2Rpc3BsYXlfd2luZG93X2ZsYWcgPSBlZy5yZWFkQm9vbGVhbigpO1xuICAgICAgaWYgKGRlZmF1bHRfZGlzcGxheV93aW5kb3dfZmxhZykge1xuICAgICAgICBwaWNfbGVmdF9vZmZzZXQgKz0gZWcucmVhZFVFRygpO1xuICAgICAgICBwaWNfcmlnaHRfb2Zmc2V0ICs9IGVnLnJlYWRVRUcoKTtcbiAgICAgICAgcGljX3RvcF9vZmZzZXQgKz0gZWcucmVhZFVFRygpO1xuICAgICAgICBwaWNfYm90dG9tX29mZnNldCArPSBlZy5yZWFkVUVHKCk7XG4gICAgICB9XG4gICAgICBjb25zdCB2dWlfdGltaW5nX2luZm9fcHJlc2VudF9mbGFnID0gZWcucmVhZEJvb2xlYW4oKTtcbiAgICAgIGlmICh2dWlfdGltaW5nX2luZm9fcHJlc2VudF9mbGFnKSB7XG4gICAgICAgIGZwc19kZW4gPSBlZy5yZWFkQml0cygzMik7XG4gICAgICAgIGZwc19udW0gPSBlZy5yZWFkQml0cygzMik7XG4gICAgICAgIGNvbnN0IHZ1aV9wb2NfcHJvcG9ydGlvbmFsX3RvX3RpbWluZ19mbGFnID0gZWcucmVhZEJvb2xlYW4oKTtcbiAgICAgICAgaWYgKHZ1aV9wb2NfcHJvcG9ydGlvbmFsX3RvX3RpbWluZ19mbGFnKSB7XG4gICAgICAgICAgZWcucmVhZFVFRygpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZ1aV9ocmRfcGFyYW1ldGVyc19wcmVzZW50X2ZsYWcgPSBlZy5yZWFkQm9vbGVhbigpO1xuICAgICAgICBpZiAodnVpX2hyZF9wYXJhbWV0ZXJzX3ByZXNlbnRfZmxhZykge1xuICAgICAgICAgIC8vY29uc3QgY29tbW9uSW5mUHJlc2VudEZsYWcgPSB0cnVlO1xuICAgICAgICAgIC8vaWYgKGNvbW1vbkluZlByZXNlbnRGbGFnKSB7XG4gICAgICAgICAgY29uc3QgbmFsX2hyZF9wYXJhbWV0ZXJzX3ByZXNlbnRfZmxhZyA9IGVnLnJlYWRCb29sZWFuKCk7XG4gICAgICAgICAgY29uc3QgdmNsX2hyZF9wYXJhbWV0ZXJzX3ByZXNlbnRfZmxhZyA9IGVnLnJlYWRCb29sZWFuKCk7XG4gICAgICAgICAgbGV0IHN1Yl9waWNfaHJkX3BhcmFtc19wcmVzZW50X2ZsYWcgPSBmYWxzZTtcbiAgICAgICAgICBpZiAobmFsX2hyZF9wYXJhbWV0ZXJzX3ByZXNlbnRfZmxhZyB8fCB2Y2xfaHJkX3BhcmFtZXRlcnNfcHJlc2VudF9mbGFnKSB7XG4gICAgICAgICAgICBzdWJfcGljX2hyZF9wYXJhbXNfcHJlc2VudF9mbGFnID0gZWcucmVhZEJvb2xlYW4oKTtcbiAgICAgICAgICAgIGlmIChzdWJfcGljX2hyZF9wYXJhbXNfcHJlc2VudF9mbGFnKSB7XG4gICAgICAgICAgICAgIGVnLnJlYWRVQnl0ZSgpO1xuICAgICAgICAgICAgICBlZy5yZWFkQml0cyg1KTtcbiAgICAgICAgICAgICAgZWcucmVhZEJvb2xlYW4oKTtcbiAgICAgICAgICAgICAgZWcucmVhZEJpdHMoNSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlZy5yZWFkQml0cyg0KTsgLy8gYml0X3JhdGVfc2NhbGVcbiAgICAgICAgICAgIGVnLnJlYWRCaXRzKDQpOyAvLyBjcGJfc2l6ZV9zY2FsZVxuICAgICAgICAgICAgaWYgKHN1Yl9waWNfaHJkX3BhcmFtc19wcmVzZW50X2ZsYWcpIHtcbiAgICAgICAgICAgICAgZWcucmVhZEJpdHMoNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlZy5yZWFkQml0cyg1KTtcbiAgICAgICAgICAgIGVnLnJlYWRCaXRzKDUpO1xuICAgICAgICAgICAgZWcucmVhZEJpdHMoNSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vfVxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG1heF9zdWJfbGF5ZXJzX21pbnVzMTsgaSsrKSB7XG4gICAgICAgICAgICBmcHNfZml4ZWQgPSBlZy5yZWFkQm9vbGVhbigpOyAvLyBmaXhlZF9waWNfcmF0ZV9nZW5lcmFsX2ZsYWdcbiAgICAgICAgICAgIGNvbnN0IGZpeGVkX3BpY19yYXRlX3dpdGhpbl9jdnNfZmxhZyA9IGZwc19maXhlZCB8fCBlZy5yZWFkQm9vbGVhbigpO1xuICAgICAgICAgICAgbGV0IGxvd19kZWxheV9ocmRfZmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGZpeGVkX3BpY19yYXRlX3dpdGhpbl9jdnNfZmxhZykge1xuICAgICAgICAgICAgICBlZy5yZWFkRUcoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxvd19kZWxheV9ocmRfZmxhZyA9IGVnLnJlYWRCb29sZWFuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjcGJfY250ID0gbG93X2RlbGF5X2hyZF9mbGFnID8gMSA6IGVnLnJlYWRVRUcoKSArIDE7XG4gICAgICAgICAgICBpZiAobmFsX2hyZF9wYXJhbWV0ZXJzX3ByZXNlbnRfZmxhZykge1xuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNwYl9jbnQ7IGorKykge1xuICAgICAgICAgICAgICAgIGVnLnJlYWRVRUcoKTtcbiAgICAgICAgICAgICAgICBlZy5yZWFkVUVHKCk7XG4gICAgICAgICAgICAgICAgaWYgKHN1Yl9waWNfaHJkX3BhcmFtc19wcmVzZW50X2ZsYWcpIHtcbiAgICAgICAgICAgICAgICAgIGVnLnJlYWRVRUcoKTtcbiAgICAgICAgICAgICAgICAgIGVnLnJlYWRVRUcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWcuc2tpcEJpdHMoMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2Y2xfaHJkX3BhcmFtZXRlcnNfcHJlc2VudF9mbGFnKSB7XG4gICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY3BiX2NudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgZWcucmVhZFVFRygpO1xuICAgICAgICAgICAgICAgIGVnLnJlYWRVRUcoKTtcbiAgICAgICAgICAgICAgICBpZiAoc3ViX3BpY19ocmRfcGFyYW1zX3ByZXNlbnRfZmxhZykge1xuICAgICAgICAgICAgICAgICAgZWcucmVhZFVFRygpO1xuICAgICAgICAgICAgICAgICAgZWcucmVhZFVFRygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlZy5za2lwQml0cygxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgYml0c3RyZWFtX3Jlc3RyaWN0aW9uX2ZsYWcgPSBlZy5yZWFkQm9vbGVhbigpO1xuICAgICAgaWYgKGJpdHN0cmVhbV9yZXN0cmljdGlvbl9mbGFnKSB7XG4gICAgICAgIGVnLnJlYWRCb29sZWFuKCk7IC8vIHRpbGVzX2ZpeGVkX3N0cnVjdHVyZV9mbGFnXG4gICAgICAgIGVnLnJlYWRCb29sZWFuKCk7IC8vIG1vdGlvbl92ZWN0b3JzX292ZXJfcGljX2JvdW5kYXJpZXNfZmxhZ1xuICAgICAgICBlZy5yZWFkQm9vbGVhbigpOyAvLyByZXN0cmljdGVkX3JlZl9waWNfbGlzdHNfZmxhZ1xuICAgICAgICBtaW5fc3BhdGlhbF9zZWdtZW50YXRpb25faWRjID0gZWcucmVhZFVFRygpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgd2lkdGggPSBwaWNfd2lkdGhfaW5fbHVtYV9zYW1wbGVzLFxuICAgICAgaGVpZ2h0ID0gcGljX2hlaWdodF9pbl9sdW1hX3NhbXBsZXM7XG4gICAgaWYgKGNvbmZvcm1hbmNlX3dpbmRvd19mbGFnIHx8IGRlZmF1bHRfZGlzcGxheV93aW5kb3dfZmxhZykge1xuICAgICAgbGV0IGNocm9tYV9zY2FsZV93ID0gMSxcbiAgICAgICAgY2hyb21hX3NjYWxlX2ggPSAxO1xuICAgICAgaWYgKGNocm9tYV9mb3JtYXRfaWRjID09PSAxKSB7XG4gICAgICAgIC8vIFlVViA0MjBcbiAgICAgICAgY2hyb21hX3NjYWxlX3cgPSBjaHJvbWFfc2NhbGVfaCA9IDI7XG4gICAgICB9IGVsc2UgaWYgKGNocm9tYV9mb3JtYXRfaWRjID09IDIpIHtcbiAgICAgICAgLy8gWVVWIDQyMlxuICAgICAgICBjaHJvbWFfc2NhbGVfdyA9IDI7XG4gICAgICB9XG4gICAgICB3aWR0aCA9IHBpY193aWR0aF9pbl9sdW1hX3NhbXBsZXMgLSBjaHJvbWFfc2NhbGVfdyAqIHBpY19yaWdodF9vZmZzZXQgLSBjaHJvbWFfc2NhbGVfdyAqIHBpY19sZWZ0X29mZnNldDtcbiAgICAgIGhlaWdodCA9IHBpY19oZWlnaHRfaW5fbHVtYV9zYW1wbGVzIC0gY2hyb21hX3NjYWxlX2ggKiBwaWNfYm90dG9tX29mZnNldCAtIGNocm9tYV9zY2FsZV9oICogcGljX3RvcF9vZmZzZXQ7XG4gICAgfVxuICAgIGNvbnN0IHByb2ZpbGVfc3BhY2Vfc3RyaW5nID0gZ2VuZXJhbF9wcm9maWxlX3NwYWNlID8gWydBJywgJ0InLCAnQyddW2dlbmVyYWxfcHJvZmlsZV9zcGFjZV0gOiAnJztcbiAgICBjb25zdCBwcm9maWxlX2NvbXBhdGliaWxpdHlfYnVmID0gZ2VuZXJhbF9wcm9maWxlX2NvbXBhdGliaWxpdHlfZmxhZ3NfMSA8PCAyNCB8IGdlbmVyYWxfcHJvZmlsZV9jb21wYXRpYmlsaXR5X2ZsYWdzXzIgPDwgMTYgfCBnZW5lcmFsX3Byb2ZpbGVfY29tcGF0aWJpbGl0eV9mbGFnc18zIDw8IDggfCBnZW5lcmFsX3Byb2ZpbGVfY29tcGF0aWJpbGl0eV9mbGFnc180O1xuICAgIGxldCBwcm9maWxlX2NvbXBhdGliaWxpdHlfcmV2ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICAgIHByb2ZpbGVfY29tcGF0aWJpbGl0eV9yZXYgPSAocHJvZmlsZV9jb21wYXRpYmlsaXR5X3JldiB8IChwcm9maWxlX2NvbXBhdGliaWxpdHlfYnVmID4+IGkgJiAxKSA8PCAzMSAtIGkpID4+PiAwOyAvLyByZXZlcnNlIGJpdCBwb3NpdGlvbiAoYW5kIGNhc3QgYXMgVUludDMyKVxuICAgIH1cbiAgICBsZXQgcHJvZmlsZV9jb21wYXRpYmlsaXR5X2ZsYWdzX3N0cmluZyA9IHByb2ZpbGVfY29tcGF0aWJpbGl0eV9yZXYudG9TdHJpbmcoMTYpO1xuICAgIGlmIChnZW5lcmFsX3Byb2ZpbGVfaWRjID09PSAxICYmIHByb2ZpbGVfY29tcGF0aWJpbGl0eV9mbGFnc19zdHJpbmcgPT09ICcyJykge1xuICAgICAgcHJvZmlsZV9jb21wYXRpYmlsaXR5X2ZsYWdzX3N0cmluZyA9ICc2JztcbiAgICB9XG4gICAgY29uc3QgdGllcl9mbGFnX3N0cmluZyA9IGdlbmVyYWxfdGllcl9mbGFnID8gJ0gnIDogJ0wnO1xuICAgIHJldHVybiB7XG4gICAgICBjb2RlY1N0cmluZzogYGh2YzEuJHtwcm9maWxlX3NwYWNlX3N0cmluZ30ke2dlbmVyYWxfcHJvZmlsZV9pZGN9LiR7cHJvZmlsZV9jb21wYXRpYmlsaXR5X2ZsYWdzX3N0cmluZ30uJHt0aWVyX2ZsYWdfc3RyaW5nfSR7Z2VuZXJhbF9sZXZlbF9pZGN9LkIwYCxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBnZW5lcmFsX3RpZXJfZmxhZyxcbiAgICAgICAgZ2VuZXJhbF9wcm9maWxlX2lkYyxcbiAgICAgICAgZ2VuZXJhbF9wcm9maWxlX3NwYWNlLFxuICAgICAgICBnZW5lcmFsX3Byb2ZpbGVfY29tcGF0aWJpbGl0eV9mbGFnczogW2dlbmVyYWxfcHJvZmlsZV9jb21wYXRpYmlsaXR5X2ZsYWdzXzEsIGdlbmVyYWxfcHJvZmlsZV9jb21wYXRpYmlsaXR5X2ZsYWdzXzIsIGdlbmVyYWxfcHJvZmlsZV9jb21wYXRpYmlsaXR5X2ZsYWdzXzMsIGdlbmVyYWxfcHJvZmlsZV9jb21wYXRpYmlsaXR5X2ZsYWdzXzRdLFxuICAgICAgICBnZW5lcmFsX2NvbnN0cmFpbnRfaW5kaWNhdG9yX2ZsYWdzOiBbZ2VuZXJhbF9jb25zdHJhaW50X2luZGljYXRvcl9mbGFnc18xLCBnZW5lcmFsX2NvbnN0cmFpbnRfaW5kaWNhdG9yX2ZsYWdzXzIsIGdlbmVyYWxfY29uc3RyYWludF9pbmRpY2F0b3JfZmxhZ3NfMywgZ2VuZXJhbF9jb25zdHJhaW50X2luZGljYXRvcl9mbGFnc180LCBnZW5lcmFsX2NvbnN0cmFpbnRfaW5kaWNhdG9yX2ZsYWdzXzUsIGdlbmVyYWxfY29uc3RyYWludF9pbmRpY2F0b3JfZmxhZ3NfNl0sXG4gICAgICAgIGdlbmVyYWxfbGV2ZWxfaWRjLFxuICAgICAgICBiaXRfZGVwdGg6IGJpdF9kZXB0aF9sdW1hX21pbnVzOCArIDgsXG4gICAgICAgIGJpdF9kZXB0aF9sdW1hX21pbnVzOCxcbiAgICAgICAgYml0X2RlcHRoX2Nocm9tYV9taW51czgsXG4gICAgICAgIG1pbl9zcGF0aWFsX3NlZ21lbnRhdGlvbl9pZGMsXG4gICAgICAgIGNocm9tYV9mb3JtYXRfaWRjOiBjaHJvbWFfZm9ybWF0X2lkYyxcbiAgICAgICAgZnJhbWVfcmF0ZToge1xuICAgICAgICAgIGZpeGVkOiBmcHNfZml4ZWQsXG4gICAgICAgICAgZnBzOiBmcHNfbnVtIC8gZnBzX2RlblxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBwaXhlbFJhdGlvOiBbc2FyX3dpZHRoLCBzYXJfaGVpZ2h0XVxuICAgIH07XG4gIH1cbiAgcmVhZFBQUyhwcHMpIHtcbiAgICBjb25zdCBlZyA9IG5ldyBFeHBHb2xvbWIodGhpcy5lYnNwMnJic3AocHBzKSk7XG4gICAgZWcucmVhZFVCeXRlKCk7XG4gICAgZWcucmVhZFVCeXRlKCk7XG4gICAgZWcuc2tpcFVFRygpOyAvLyBwaWNfcGFyYW1ldGVyX3NldF9pZFxuICAgIGVnLnNraXBVRUcoKTsgLy8gc2VxX3BhcmFtZXRlcl9zZXRfaWRcbiAgICBlZy5za2lwQml0cygyKTsgLy8gZGVwZW5kZW50X3NsaWNlX3NlZ21lbnRzX2VuYWJsZWRfZmxhZywgb3V0cHV0X2ZsYWdfcHJlc2VudF9mbGFnXG4gICAgZWcuc2tpcEJpdHMoMyk7IC8vIG51bV9leHRyYV9zbGljZV9oZWFkZXJfYml0c1xuICAgIGVnLnNraXBCaXRzKDIpOyAvLyBzaWduX2RhdGFfaGlkaW5nX2VuYWJsZWRfZmxhZywgY2FiYWNfaW5pdF9wcmVzZW50X2ZsYWdcbiAgICBlZy5za2lwVUVHKCk7XG4gICAgZWcuc2tpcFVFRygpO1xuICAgIGVnLnNraXBFRygpOyAvLyBpbml0X3FwX21pbnVzMjZcbiAgICBlZy5za2lwQml0cygyKTsgLy8gY29uc3RyYWluZWRfaW50cmFfcHJlZF9mbGFnLCB0cmFuc2Zvcm1fc2tpcF9lbmFibGVkX2ZsYWdcbiAgICBjb25zdCBjdV9xcF9kZWx0YV9lbmFibGVkX2ZsYWcgPSBlZy5yZWFkQm9vbGVhbigpO1xuICAgIGlmIChjdV9xcF9kZWx0YV9lbmFibGVkX2ZsYWcpIHtcbiAgICAgIGVnLnNraXBVRUcoKTtcbiAgICB9XG4gICAgZWcuc2tpcEVHKCk7IC8vIGNiX3FwX29mZnNldFxuICAgIGVnLnNraXBFRygpOyAvLyBjcl9xcF9vZmZzZXRcbiAgICBlZy5za2lwQml0cyg0KTsgLy8gcHBzX3NsaWNlX2Nocm9tYV9xcF9vZmZzZXRzX3ByZXNlbnRfZmxhZywgd2VpZ2h0ZWRfcHJlZF9mbGFnLCB3ZWlnaHRlZF9iaXByZWRfZmxhZywgdHJhbnNxdWFudF9ieXBhc3NfZW5hYmxlZF9mbGFnXG4gICAgY29uc3QgdGlsZXNfZW5hYmxlZF9mbGFnID0gZWcucmVhZEJvb2xlYW4oKTtcbiAgICBjb25zdCBlbnRyb3B5X2NvZGluZ19zeW5jX2VuYWJsZWRfZmxhZyA9IGVnLnJlYWRCb29sZWFuKCk7XG4gICAgbGV0IHBhcmFsbGVsaXNtVHlwZSA9IDE7IC8vIHNsaWNlLWJhc2VkIHBhcmFsbGVsIGRlY29kaW5nXG4gICAgaWYgKGVudHJvcHlfY29kaW5nX3N5bmNfZW5hYmxlZF9mbGFnICYmIHRpbGVzX2VuYWJsZWRfZmxhZykge1xuICAgICAgcGFyYWxsZWxpc21UeXBlID0gMDsgLy8gbWl4ZWQtdHlwZSBwYXJhbGxlbCBkZWNvZGluZ1xuICAgIH0gZWxzZSBpZiAoZW50cm9weV9jb2Rpbmdfc3luY19lbmFibGVkX2ZsYWcpIHtcbiAgICAgIHBhcmFsbGVsaXNtVHlwZSA9IDM7IC8vIHdhdmVmcm9udC1iYXNlZCBwYXJhbGxlbCBkZWNvZGluZ1xuICAgIH0gZWxzZSBpZiAodGlsZXNfZW5hYmxlZF9mbGFnKSB7XG4gICAgICBwYXJhbGxlbGlzbVR5cGUgPSAyOyAvLyB0aWxlLWJhc2VkIHBhcmFsbGVsIGRlY29kaW5nXG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBwYXJhbGxlbGlzbVR5cGVcbiAgICB9O1xuICB9XG4gIG1hdGNoU1BTKHNwczEsIHNwczIpIHtcbiAgICAvLyBjb21wYXJlIHdpdGhvdXQgaGVhZGVycyBhbmQgVlBTIHJlbGF0ZWQgcGFyYW1zXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgc3BzMSkuc3Vic3RyKDMpID09PSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIHNwczIpLnN1YnN0cigzKTtcbiAgfVxufVxuXG5jb25zdCBQQUNLRVRfTEVOR1RIID0gMTg4O1xuY2xhc3MgVFNEZW11eGVyIHtcbiAgY29uc3RydWN0b3Iob2JzZXJ2ZXIsIGNvbmZpZywgdHlwZVN1cHBvcnRlZCwgbG9nZ2VyKSB7XG4gICAgdGhpcy5sb2dnZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5vYnNlcnZlciA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB2b2lkIDA7XG4gICAgdGhpcy5zYW1wbGVBZXMgPSBudWxsO1xuICAgIHRoaXMucG10UGFyc2VkID0gZmFsc2U7XG4gICAgdGhpcy5hdWRpb0NvZGVjID0gdm9pZCAwO1xuICAgIHRoaXMudmlkZW9Db2RlYyA9IHZvaWQgMDtcbiAgICB0aGlzLl9wbXRJZCA9IC0xO1xuICAgIHRoaXMuX3ZpZGVvVHJhY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5fYXVkaW9UcmFjayA9IHZvaWQgMDtcbiAgICB0aGlzLl9pZDNUcmFjayA9IHZvaWQgMDtcbiAgICB0aGlzLl90eHRUcmFjayA9IHZvaWQgMDtcbiAgICB0aGlzLmFhY092ZXJGbG93ID0gbnVsbDtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIHRoaXMudmlkZW9QYXJzZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHR5cGVTdXBwb3J0ZWQ7XG4gICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgdGhpcy52aWRlb1BhcnNlciA9IG51bGw7XG4gIH1cbiAgc3RhdGljIHByb2JlKGRhdGEsIGxvZ2dlcikge1xuICAgIGNvbnN0IHN5bmNPZmZzZXQgPSBUU0RlbXV4ZXIuc3luY09mZnNldChkYXRhKTtcbiAgICBpZiAoc3luY09mZnNldCA+IDApIHtcbiAgICAgIGxvZ2dlci53YXJuKGBNUEVHMi1UUyBkZXRlY3RlZCBidXQgZmlyc3Qgc3luYyB3b3JkIGZvdW5kIEAgb2Zmc2V0ICR7c3luY09mZnNldH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHN5bmNPZmZzZXQgIT09IC0xO1xuICB9XG4gIHN0YXRpYyBzeW5jT2Zmc2V0KGRhdGEpIHtcbiAgICBjb25zdCBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICBsZXQgc2NhbndpbmRvdyA9IE1hdGgubWluKFBBQ0tFVF9MRU5HVEggKiA1LCBsZW5ndGggLSBQQUNLRVRfTEVOR1RIKSArIDE7XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc2NhbndpbmRvdykge1xuICAgICAgLy8gYSBUUyBpbml0IHNlZ21lbnQgc2hvdWxkIGNvbnRhaW4gYXQgbGVhc3QgMiBUUyBwYWNrZXRzOiBQQVQgYW5kIFBNVCwgZWFjaCBzdGFydGluZyB3aXRoIDB4NDdcbiAgICAgIGxldCBmb3VuZFBhdCA9IGZhbHNlO1xuICAgICAgbGV0IHBhY2tldFN0YXJ0ID0gLTE7XG4gICAgICBsZXQgdHNQYWNrZXRzID0gMDtcbiAgICAgIGZvciAobGV0IGogPSBpOyBqIDwgbGVuZ3RoOyBqICs9IFBBQ0tFVF9MRU5HVEgpIHtcbiAgICAgICAgaWYgKGRhdGFbal0gPT09IDB4NDcgJiYgKGxlbmd0aCAtIGogPT09IFBBQ0tFVF9MRU5HVEggfHwgZGF0YVtqICsgUEFDS0VUX0xFTkdUSF0gPT09IDB4NDcpKSB7XG4gICAgICAgICAgdHNQYWNrZXRzKys7XG4gICAgICAgICAgaWYgKHBhY2tldFN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgICAgcGFja2V0U3RhcnQgPSBqO1xuICAgICAgICAgICAgLy8gRmlyc3Qgc3luYyB3b3JkIGZvdW5kIGF0IG9mZnNldCwgaW5jcmVhc2Ugc2NhbiBsZW5ndGggKCM1MjUxKVxuICAgICAgICAgICAgaWYgKHBhY2tldFN0YXJ0ICE9PSAwKSB7XG4gICAgICAgICAgICAgIHNjYW53aW5kb3cgPSBNYXRoLm1pbihwYWNrZXRTdGFydCArIFBBQ0tFVF9MRU5HVEggKiA5OSwgZGF0YS5sZW5ndGggLSBQQUNLRVRfTEVOR1RIKSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZm91bmRQYXQpIHtcbiAgICAgICAgICAgIGZvdW5kUGF0ID0gcGFyc2VQSUQoZGF0YSwgaikgPT09IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFN5bmMgd29yZCBmb3VuZCBhdCAwIHdpdGggMyBwYWNrZXRzLCBvciBmb3VuZCBhdCBvZmZzZXQgbGVhc3QgMiBwYWNrZXRzIHVwIHRvIHNjYW53aW5kb3cgKCM1NTAxKVxuICAgICAgICAgIGlmIChmb3VuZFBhdCAmJiB0c1BhY2tldHMgPiAxICYmIChwYWNrZXRTdGFydCA9PT0gMCAmJiB0c1BhY2tldHMgPiAyIHx8IGogKyBQQUNLRVRfTEVOR1RIID4gc2NhbndpbmRvdykpIHtcbiAgICAgICAgICAgIHJldHVybiBwYWNrZXRTdGFydDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHNQYWNrZXRzKSB7XG4gICAgICAgICAgLy8gRXhpdCBpZiBzeW5jIHdvcmQgZm91bmQsIGJ1dCBkb2VzIG5vdCBjb250YWluIGNvbnRpZ3VvdXMgcGFja2V0c1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHRyYWNrIG1vZGVsIGludGVybmFsIHRvIGRlbXV4ZXIgdXNlZCB0byBkcml2ZSByZW11eGluZyBpbnB1dFxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZVRyYWNrKHR5cGUsIGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRhaW5lcjogdHlwZSA9PT0gJ3ZpZGVvJyB8fCB0eXBlID09PSAnYXVkaW8nID8gJ3ZpZGVvL21wMnQnIDogdW5kZWZpbmVkLFxuICAgICAgdHlwZSxcbiAgICAgIGlkOiBSZW11eGVyVHJhY2tJZENvbmZpZ1t0eXBlXSxcbiAgICAgIHBpZDogLTEsXG4gICAgICBpbnB1dFRpbWVTY2FsZTogOTAwMDAsXG4gICAgICBzZXF1ZW5jZU51bWJlcjogMCxcbiAgICAgIHNhbXBsZXM6IFtdLFxuICAgICAgZHJvcHBlZDogMCxcbiAgICAgIGR1cmF0aW9uOiB0eXBlID09PSAnYXVkaW8nID8gZHVyYXRpb24gOiB1bmRlZmluZWRcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGEgbmV3IGluaXQgc2VnbWVudCBvbiB0aGUgZGVtdXhlci9yZW11eGVyIGludGVyZmFjZS4gTmVlZGVkIGZvciBkaXNjb250aW51aXRpZXMvdHJhY2stc3dpdGNoZXMgKG9yIGF0IHN0cmVhbSBzdGFydClcbiAgICogUmVzZXRzIGFsbCBpbnRlcm5hbCB0cmFjayBpbnN0YW5jZXMgb2YgdGhlIGRlbXV4ZXIuXG4gICAqL1xuICByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0cmFja0R1cmF0aW9uKSB7XG4gICAgdGhpcy5wbXRQYXJzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wbXRJZCA9IC0xO1xuICAgIHRoaXMuX3ZpZGVvVHJhY2sgPSBUU0RlbXV4ZXIuY3JlYXRlVHJhY2soJ3ZpZGVvJyk7XG4gICAgdGhpcy5fdmlkZW9UcmFjay5kdXJhdGlvbiA9IHRyYWNrRHVyYXRpb247XG4gICAgdGhpcy5fYXVkaW9UcmFjayA9IFRTRGVtdXhlci5jcmVhdGVUcmFjaygnYXVkaW8nLCB0cmFja0R1cmF0aW9uKTtcbiAgICB0aGlzLl9pZDNUcmFjayA9IFRTRGVtdXhlci5jcmVhdGVUcmFjaygnaWQzJyk7XG4gICAgdGhpcy5fdHh0VHJhY2sgPSBUU0RlbXV4ZXIuY3JlYXRlVHJhY2soJ3RleHQnKTtcbiAgICB0aGlzLl9hdWRpb1RyYWNrLnNlZ21lbnRDb2RlYyA9ICdhYWMnO1xuXG4gICAgLy8gZmx1c2ggYW55IHBhcnRpYWwgY29udGVudFxuICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBudWxsO1xuICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgdGhpcy5hdWRpb0NvZGVjID0gYXVkaW9Db2RlYztcbiAgICB0aGlzLnZpZGVvQ29kZWMgPSB2aWRlb0NvZGVjO1xuICB9XG4gIHJlc2V0VGltZVN0YW1wKCkge31cbiAgcmVzZXRDb250aWd1aXR5KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIF9hdWRpb1RyYWNrLFxuICAgICAgX3ZpZGVvVHJhY2ssXG4gICAgICBfaWQzVHJhY2tcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoX2F1ZGlvVHJhY2spIHtcbiAgICAgIF9hdWRpb1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoX3ZpZGVvVHJhY2spIHtcbiAgICAgIF92aWRlb1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoX2lkM1RyYWNrKSB7XG4gICAgICBfaWQzVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBudWxsO1xuICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gIH1cbiAgZGVtdXgoZGF0YSwgdGltZU9mZnNldCwgaXNTYW1wbGVBZXMgPSBmYWxzZSwgZmx1c2ggPSBmYWxzZSkge1xuICAgIGlmICghaXNTYW1wbGVBZXMpIHtcbiAgICAgIHRoaXMuc2FtcGxlQWVzID0gbnVsbDtcbiAgICB9XG4gICAgbGV0IHBlcztcbiAgICBjb25zdCB2aWRlb1RyYWNrID0gdGhpcy5fdmlkZW9UcmFjaztcbiAgICBjb25zdCBhdWRpb1RyYWNrID0gdGhpcy5fYXVkaW9UcmFjaztcbiAgICBjb25zdCBpZDNUcmFjayA9IHRoaXMuX2lkM1RyYWNrO1xuICAgIGNvbnN0IHRleHRUcmFjayA9IHRoaXMuX3R4dFRyYWNrO1xuICAgIGxldCB2aWRlb1BpZCA9IHZpZGVvVHJhY2sucGlkO1xuICAgIGxldCB2aWRlb0RhdGEgPSB2aWRlb1RyYWNrLnBlc0RhdGE7XG4gICAgbGV0IGF1ZGlvUGlkID0gYXVkaW9UcmFjay5waWQ7XG4gICAgbGV0IGlkM1BpZCA9IGlkM1RyYWNrLnBpZDtcbiAgICBsZXQgYXVkaW9EYXRhID0gYXVkaW9UcmFjay5wZXNEYXRhO1xuICAgIGxldCBpZDNEYXRhID0gaWQzVHJhY2sucGVzRGF0YTtcbiAgICBsZXQgdW5rbm93blBJRCA9IG51bGw7XG4gICAgbGV0IHBtdFBhcnNlZCA9IHRoaXMucG10UGFyc2VkO1xuICAgIGxldCBwbXRJZCA9IHRoaXMuX3BtdElkO1xuICAgIGxldCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICBpZiAodGhpcy5yZW1haW5kZXJEYXRhKSB7XG4gICAgICBkYXRhID0gYXBwZW5kVWludDhBcnJheSh0aGlzLnJlbWFpbmRlckRhdGEsIGRhdGEpO1xuICAgICAgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIH1cbiAgICBpZiAobGVuIDwgUEFDS0VUX0xFTkdUSCAmJiAhZmx1c2gpIHtcbiAgICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IGRhdGE7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdWRpb1RyYWNrLFxuICAgICAgICB2aWRlb1RyYWNrLFxuICAgICAgICBpZDNUcmFjayxcbiAgICAgICAgdGV4dFRyYWNrXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBzeW5jT2Zmc2V0ID0gTWF0aC5tYXgoMCwgVFNEZW11eGVyLnN5bmNPZmZzZXQoZGF0YSkpO1xuICAgIGxlbiAtPSAobGVuIC0gc3luY09mZnNldCkgJSBQQUNLRVRfTEVOR1RIO1xuICAgIGlmIChsZW4gPCBkYXRhLmJ5dGVMZW5ndGggJiYgIWZsdXNoKSB7XG4gICAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgbGVuLCBkYXRhLmJ1ZmZlci5ieXRlTGVuZ3RoIC0gbGVuKTtcbiAgICB9XG5cbiAgICAvLyBsb29wIHRocm91Z2ggVFMgcGFja2V0c1xuICAgIGxldCB0c1BhY2tldEVycm9ycyA9IDA7XG4gICAgZm9yIChsZXQgc3RhcnQgPSBzeW5jT2Zmc2V0OyBzdGFydCA8IGxlbjsgc3RhcnQgKz0gUEFDS0VUX0xFTkdUSCkge1xuICAgICAgaWYgKGRhdGFbc3RhcnRdID09PSAweDQ3KSB7XG4gICAgICAgIGNvbnN0IHN0dCA9ICEhKGRhdGFbc3RhcnQgKyAxXSAmIDB4NDApO1xuICAgICAgICBjb25zdCBwaWQgPSBwYXJzZVBJRChkYXRhLCBzdGFydCk7XG4gICAgICAgIGNvbnN0IGF0ZiA9IChkYXRhW3N0YXJ0ICsgM10gJiAweDMwKSA+PiA0O1xuXG4gICAgICAgIC8vIGlmIGFuIGFkYXB0aW9uIGZpZWxkIGlzIHByZXNlbnQsIGl0cyBsZW5ndGggaXMgc3BlY2lmaWVkIGJ5IHRoZSBmaWZ0aCBieXRlIG9mIHRoZSBUUyBwYWNrZXQgaGVhZGVyLlxuICAgICAgICBsZXQgb2Zmc2V0O1xuICAgICAgICBpZiAoYXRmID4gMSkge1xuICAgICAgICAgIG9mZnNldCA9IHN0YXJ0ICsgNSArIGRhdGFbc3RhcnQgKyA0XTtcbiAgICAgICAgICAvLyBjb250aW51ZSBpZiB0aGVyZSBpcyBvbmx5IGFkYXB0YXRpb24gZmllbGRcbiAgICAgICAgICBpZiAob2Zmc2V0ID09PSBzdGFydCArIFBBQ0tFVF9MRU5HVEgpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmZzZXQgPSBzdGFydCArIDQ7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChwaWQpIHtcbiAgICAgICAgICBjYXNlIHZpZGVvUGlkOlxuICAgICAgICAgICAgaWYgKHN0dCkge1xuICAgICAgICAgICAgICBpZiAodmlkZW9EYXRhICYmIChwZXMgPSBwYXJzZVBFUyh2aWRlb0RhdGEsIHRoaXMubG9nZ2VyKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52aWRlb1BhcnNlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgc3dpdGNoICh2aWRlb1RyYWNrLnNlZ21lbnRDb2RlYykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdhdmMnOlxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlkZW9QYXJzZXIgPSBuZXcgQXZjVmlkZW9QYXJzZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaGV2Yyc6XG4gICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52aWRlb1BhcnNlciA9IG5ldyBIZXZjVmlkZW9QYXJzZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZGVvUGFyc2VyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnZpZGVvUGFyc2VyLnBhcnNlUEVTKHZpZGVvVHJhY2ssIHRleHRUcmFjaywgcGVzLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZpZGVvRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICAgICAgICBzaXplOiAwXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmlkZW9EYXRhKSB7XG4gICAgICAgICAgICAgIHZpZGVvRGF0YS5kYXRhLnB1c2goZGF0YS5zdWJhcnJheShvZmZzZXQsIHN0YXJ0ICsgUEFDS0VUX0xFTkdUSCkpO1xuICAgICAgICAgICAgICB2aWRlb0RhdGEuc2l6ZSArPSBzdGFydCArIFBBQ0tFVF9MRU5HVEggLSBvZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGF1ZGlvUGlkOlxuICAgICAgICAgICAgaWYgKHN0dCkge1xuICAgICAgICAgICAgICBpZiAoYXVkaW9EYXRhICYmIChwZXMgPSBwYXJzZVBFUyhhdWRpb0RhdGEsIHRoaXMubG9nZ2VyKSkpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGF1ZGlvVHJhY2suc2VnbWVudENvZGVjKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlICdhYWMnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlQUFDUEVTKGF1ZGlvVHJhY2ssIHBlcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAnbXAzJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZU1QRUdQRVMoYXVkaW9UcmFjaywgcGVzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlICdhYzMnOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZUFDM1BFUyhhdWRpb1RyYWNrLCBwZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhdWRpb0RhdGEgPSB7XG4gICAgICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICAgICAgc2l6ZTogMFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF1ZGlvRGF0YSkge1xuICAgICAgICAgICAgICBhdWRpb0RhdGEuZGF0YS5wdXNoKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBzdGFydCArIFBBQ0tFVF9MRU5HVEgpKTtcbiAgICAgICAgICAgICAgYXVkaW9EYXRhLnNpemUgKz0gc3RhcnQgKyBQQUNLRVRfTEVOR1RIIC0gb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZDNQaWQ6XG4gICAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICAgIGlmIChpZDNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhpZDNEYXRhLCB0aGlzLmxvZ2dlcikpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZUlEM1BFUyhpZDNUcmFjaywgcGVzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZDNEYXRhID0ge1xuICAgICAgICAgICAgICAgIGRhdGE6IFtdLFxuICAgICAgICAgICAgICAgIHNpemU6IDBcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpZDNEYXRhKSB7XG4gICAgICAgICAgICAgIGlkM0RhdGEuZGF0YS5wdXNoKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBzdGFydCArIFBBQ0tFVF9MRU5HVEgpKTtcbiAgICAgICAgICAgICAgaWQzRGF0YS5zaXplICs9IHN0YXJ0ICsgUEFDS0VUX0xFTkdUSCAtIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgb2Zmc2V0ICs9IGRhdGFbb2Zmc2V0XSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwbXRJZCA9IHRoaXMuX3BtdElkID0gcGFyc2VQQVQoZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIC8vIHRoaXMubG9nZ2VyLmxvZygnUE1UIFBJRDonICArIHRoaXMuX3BtdElkKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgcG10SWQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gZGF0YVtvZmZzZXRdICsgMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBwYXJzZWRQSURzID0gcGFyc2VQTVQoZGF0YSwgb2Zmc2V0LCB0aGlzLnR5cGVTdXBwb3J0ZWQsIGlzU2FtcGxlQWVzLCB0aGlzLm9ic2VydmVyLCB0aGlzLmxvZ2dlcik7XG5cbiAgICAgICAgICAgICAgLy8gb25seSB1cGRhdGUgdHJhY2sgaWQgaWYgdHJhY2sgUElEIGZvdW5kIHdoaWxlIHBhcnNpbmcgUE1UXG4gICAgICAgICAgICAgIC8vIHRoaXMgaXMgdG8gYXZvaWQgcmVzZXR0aW5nIHRoZSBQSUQgdG8gLTEgaW4gY2FzZVxuICAgICAgICAgICAgICAvLyB0cmFjayBQSUQgdHJhbnNpZW50bHkgZGlzYXBwZWFycyBmcm9tIHRoZSBzdHJlYW1cbiAgICAgICAgICAgICAgLy8gdGhpcyBjb3VsZCBoYXBwZW4gaW4gY2FzZSBvZiB0cmFuc2llbnQgbWlzc2luZyBhdWRpbyBzYW1wbGVzIGZvciBleGFtcGxlXG4gICAgICAgICAgICAgIC8vIE5PVEUgdGhpcyBpcyBvbmx5IHRoZSBQSUQgb2YgdGhlIHRyYWNrIGFzIGZvdW5kIGluIFRTLFxuICAgICAgICAgICAgICAvLyBidXQgd2UgYXJlIG5vdCB1c2luZyB0aGlzIGZvciBNUDQgdHJhY2sgSURzLlxuICAgICAgICAgICAgICB2aWRlb1BpZCA9IHBhcnNlZFBJRHMudmlkZW9QaWQ7XG4gICAgICAgICAgICAgIGlmICh2aWRlb1BpZCA+IDApIHtcbiAgICAgICAgICAgICAgICB2aWRlb1RyYWNrLnBpZCA9IHZpZGVvUGlkO1xuICAgICAgICAgICAgICAgIHZpZGVvVHJhY2suc2VnbWVudENvZGVjID0gcGFyc2VkUElEcy5zZWdtZW50VmlkZW9Db2RlYztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhdWRpb1BpZCA9IHBhcnNlZFBJRHMuYXVkaW9QaWQ7XG4gICAgICAgICAgICAgIGlmIChhdWRpb1BpZCA+IDApIHtcbiAgICAgICAgICAgICAgICBhdWRpb1RyYWNrLnBpZCA9IGF1ZGlvUGlkO1xuICAgICAgICAgICAgICAgIGF1ZGlvVHJhY2suc2VnbWVudENvZGVjID0gcGFyc2VkUElEcy5zZWdtZW50QXVkaW9Db2RlYztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZDNQaWQgPSBwYXJzZWRQSURzLmlkM1BpZDtcbiAgICAgICAgICAgICAgaWYgKGlkM1BpZCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZDNUcmFjay5waWQgPSBpZDNQaWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHVua25vd25QSUQgIT09IG51bGwgJiYgIXBtdFBhcnNlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYE1QRUctVFMgUE1UIGZvdW5kIGF0ICR7c3RhcnR9IGFmdGVyIHVua25vd24gUElEICcke3Vua25vd25QSUR9Jy4gQmFja3RyYWNraW5nIHRvIHN5bmMgYnl0ZSBAJHtzeW5jT2Zmc2V0fSB0byBwYXJzZSBhbGwgVFMgcGFja2V0cy5gKTtcbiAgICAgICAgICAgICAgICB1bmtub3duUElEID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyB3ZSBzZXQgaXQgdG8gLTE4OCwgdGhlICs9IDE4OCBpbiB0aGUgZm9yIGxvb3Agd2lsbCByZXNldCBzdGFydCB0byAwXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBzeW5jT2Zmc2V0IC0gMTg4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHBtdFBhcnNlZCA9IHRoaXMucG10UGFyc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAweDExOlxuICAgICAgICAgIGNhc2UgMHgxZmZmOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHVua25vd25QSUQgPSBwaWQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHNQYWNrZXRFcnJvcnMrKztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRzUGFja2V0RXJyb3JzID4gMCkge1xuICAgICAgZW1pdFBhcnNpbmdFcnJvcih0aGlzLm9ic2VydmVyLCBuZXcgRXJyb3IoYEZvdW5kICR7dHNQYWNrZXRFcnJvcnN9IFRTIHBhY2tldC9zIHRoYXQgZG8gbm90IHN0YXJ0IHdpdGggMHg0N2ApLCB1bmRlZmluZWQsIHRoaXMubG9nZ2VyKTtcbiAgICB9XG4gICAgdmlkZW9UcmFjay5wZXNEYXRhID0gdmlkZW9EYXRhO1xuICAgIGF1ZGlvVHJhY2sucGVzRGF0YSA9IGF1ZGlvRGF0YTtcbiAgICBpZDNUcmFjay5wZXNEYXRhID0gaWQzRGF0YTtcbiAgICBjb25zdCBkZW11eFJlc3VsdCA9IHtcbiAgICAgIGF1ZGlvVHJhY2ssXG4gICAgICB2aWRlb1RyYWNrLFxuICAgICAgaWQzVHJhY2ssXG4gICAgICB0ZXh0VHJhY2tcbiAgICB9O1xuICAgIGlmIChmbHVzaCkge1xuICAgICAgdGhpcy5leHRyYWN0UmVtYWluaW5nU2FtcGxlcyhkZW11eFJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiBkZW11eFJlc3VsdDtcbiAgfVxuICBmbHVzaCgpIHtcbiAgICBjb25zdCB7XG4gICAgICByZW1haW5kZXJEYXRhXG4gICAgfSA9IHRoaXM7XG4gICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmIChyZW1haW5kZXJEYXRhKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLmRlbXV4KHJlbWFpbmRlckRhdGEsIC0xLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgdmlkZW9UcmFjazogdGhpcy5fdmlkZW9UcmFjayxcbiAgICAgICAgYXVkaW9UcmFjazogdGhpcy5fYXVkaW9UcmFjayxcbiAgICAgICAgaWQzVHJhY2s6IHRoaXMuX2lkM1RyYWNrLFxuICAgICAgICB0ZXh0VHJhY2s6IHRoaXMuX3R4dFRyYWNrXG4gICAgICB9O1xuICAgIH1cbiAgICB0aGlzLmV4dHJhY3RSZW1haW5pbmdTYW1wbGVzKHJlc3VsdCk7XG4gICAgaWYgKHRoaXMuc2FtcGxlQWVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWNyeXB0KHJlc3VsdCwgdGhpcy5zYW1wbGVBZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGV4dHJhY3RSZW1haW5pbmdTYW1wbGVzKGRlbXV4UmVzdWx0KSB7XG4gICAgY29uc3Qge1xuICAgICAgYXVkaW9UcmFjayxcbiAgICAgIHZpZGVvVHJhY2ssXG4gICAgICBpZDNUcmFjayxcbiAgICAgIHRleHRUcmFja1xuICAgIH0gPSBkZW11eFJlc3VsdDtcbiAgICBjb25zdCB2aWRlb0RhdGEgPSB2aWRlb1RyYWNrLnBlc0RhdGE7XG4gICAgY29uc3QgYXVkaW9EYXRhID0gYXVkaW9UcmFjay5wZXNEYXRhO1xuICAgIGNvbnN0IGlkM0RhdGEgPSBpZDNUcmFjay5wZXNEYXRhO1xuICAgIC8vIHRyeSB0byBwYXJzZSBsYXN0IFBFUyBwYWNrZXRzXG4gICAgbGV0IHBlcztcbiAgICBpZiAodmlkZW9EYXRhICYmIChwZXMgPSBwYXJzZVBFUyh2aWRlb0RhdGEsIHRoaXMubG9nZ2VyKSkpIHtcbiAgICAgIGlmICh0aGlzLnZpZGVvUGFyc2VyID09PSBudWxsKSB7XG4gICAgICAgIHN3aXRjaCAodmlkZW9UcmFjay5zZWdtZW50Q29kZWMpIHtcbiAgICAgICAgICBjYXNlICdhdmMnOlxuICAgICAgICAgICAgdGhpcy52aWRlb1BhcnNlciA9IG5ldyBBdmNWaWRlb1BhcnNlcigpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnaGV2Yyc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRoaXMudmlkZW9QYXJzZXIgPSBuZXcgSGV2Y1ZpZGVvUGFyc2VyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMudmlkZW9QYXJzZXIgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy52aWRlb1BhcnNlci5wYXJzZVBFUyh2aWRlb1RyYWNrLCB0ZXh0VHJhY2ssIHBlcywgdHJ1ZSk7XG4gICAgICAgIHZpZGVvVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVpdGhlciBhdmNEYXRhIG51bGwgb3IgUEVTIHRydW5jYXRlZCwga2VlcCBpdCBmb3IgbmV4dCBmcmFnIHBhcnNpbmdcbiAgICAgIHZpZGVvVHJhY2sucGVzRGF0YSA9IHZpZGVvRGF0YTtcbiAgICB9XG4gICAgaWYgKGF1ZGlvRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoYXVkaW9EYXRhLCB0aGlzLmxvZ2dlcikpKSB7XG4gICAgICBzd2l0Y2ggKGF1ZGlvVHJhY2suc2VnbWVudENvZGVjKSB7XG4gICAgICAgIGNhc2UgJ2FhYyc6XG4gICAgICAgICAgdGhpcy5wYXJzZUFBQ1BFUyhhdWRpb1RyYWNrLCBwZXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtcDMnOlxuICAgICAgICAgIHRoaXMucGFyc2VNUEVHUEVTKGF1ZGlvVHJhY2ssIHBlcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2FjMyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5wYXJzZUFDM1BFUyhhdWRpb1RyYWNrLCBwZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGF1ZGlvVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhdWRpb0RhdGEgIT0gbnVsbCAmJiBhdWRpb0RhdGEuc2l6ZSkge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coJ2xhc3QgQUFDIFBFUyBwYWNrZXQgdHJ1bmNhdGVkLG1pZ2h0IG92ZXJsYXAgYmV0d2VlbiBmcmFnbWVudHMnKTtcbiAgICAgIH1cblxuICAgICAgLy8gZWl0aGVyIGF1ZGlvRGF0YSBudWxsIG9yIFBFUyB0cnVuY2F0ZWQsIGtlZXAgaXQgZm9yIG5leHQgZnJhZyBwYXJzaW5nXG4gICAgICBhdWRpb1RyYWNrLnBlc0RhdGEgPSBhdWRpb0RhdGE7XG4gICAgfVxuICAgIGlmIChpZDNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhpZDNEYXRhLCB0aGlzLmxvZ2dlcikpKSB7XG4gICAgICB0aGlzLnBhcnNlSUQzUEVTKGlkM1RyYWNrLCBwZXMpO1xuICAgICAgaWQzVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVpdGhlciBpZDNEYXRhIG51bGwgb3IgUEVTIHRydW5jYXRlZCwga2VlcCBpdCBmb3IgbmV4dCBmcmFnIHBhcnNpbmdcbiAgICAgIGlkM1RyYWNrLnBlc0RhdGEgPSBpZDNEYXRhO1xuICAgIH1cbiAgfVxuICBkZW11eFNhbXBsZUFlcyhkYXRhLCBrZXlEYXRhLCB0aW1lT2Zmc2V0KSB7XG4gICAgY29uc3QgZGVtdXhSZXN1bHQgPSB0aGlzLmRlbXV4KGRhdGEsIHRpbWVPZmZzZXQsIHRydWUsICF0aGlzLmNvbmZpZy5wcm9ncmVzc2l2ZSk7XG4gICAgY29uc3Qgc2FtcGxlQWVzID0gdGhpcy5zYW1wbGVBZXMgPSBuZXcgU2FtcGxlQWVzRGVjcnlwdGVyKHRoaXMub2JzZXJ2ZXIsIHRoaXMuY29uZmlnLCBrZXlEYXRhKTtcbiAgICByZXR1cm4gdGhpcy5kZWNyeXB0KGRlbXV4UmVzdWx0LCBzYW1wbGVBZXMpO1xuICB9XG4gIGRlY3J5cHQoZGVtdXhSZXN1bHQsIHNhbXBsZUFlcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYXVkaW9UcmFjayxcbiAgICAgICAgdmlkZW9UcmFja1xuICAgICAgfSA9IGRlbXV4UmVzdWx0O1xuICAgICAgaWYgKGF1ZGlvVHJhY2suc2FtcGxlcyAmJiBhdWRpb1RyYWNrLnNlZ21lbnRDb2RlYyA9PT0gJ2FhYycpIHtcbiAgICAgICAgc2FtcGxlQWVzLmRlY3J5cHRBYWNTYW1wbGVzKGF1ZGlvVHJhY2suc2FtcGxlcywgMCwgKCkgPT4ge1xuICAgICAgICAgIGlmICh2aWRlb1RyYWNrLnNhbXBsZXMpIHtcbiAgICAgICAgICAgIHNhbXBsZUFlcy5kZWNyeXB0QXZjU2FtcGxlcyh2aWRlb1RyYWNrLnNhbXBsZXMsIDAsIDAsICgpID0+IHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShkZW11eFJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShkZW11eFJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAodmlkZW9UcmFjay5zYW1wbGVzKSB7XG4gICAgICAgIHNhbXBsZUFlcy5kZWNyeXB0QXZjU2FtcGxlcyh2aWRlb1RyYWNrLnNhbXBsZXMsIDAsIDAsICgpID0+IHtcbiAgICAgICAgICByZXNvbHZlKGRlbXV4UmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5vYnNlcnZlcikge1xuICAgICAgdGhpcy5vYnNlcnZlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuY29uZmlnID0gdGhpcy5sb2dnZXIgPSB0aGlzLm9ic2VydmVyID0gbnVsbDtcbiAgICB0aGlzLmFhY092ZXJGbG93ID0gdGhpcy52aWRlb1BhcnNlciA9IHRoaXMucmVtYWluZGVyRGF0YSA9IHRoaXMuc2FtcGxlQWVzID0gbnVsbDtcbiAgICB0aGlzLl92aWRlb1RyYWNrID0gdGhpcy5fYXVkaW9UcmFjayA9IHRoaXMuX2lkM1RyYWNrID0gdGhpcy5fdHh0VHJhY2sgPSB1bmRlZmluZWQ7XG4gIH1cbiAgcGFyc2VBQUNQRVModHJhY2ssIHBlcykge1xuICAgIGxldCBzdGFydE9mZnNldCA9IDA7XG4gICAgY29uc3QgYWFjT3ZlckZsb3cgPSB0aGlzLmFhY092ZXJGbG93O1xuICAgIGxldCBkYXRhID0gcGVzLmRhdGE7XG4gICAgaWYgKGFhY092ZXJGbG93KSB7XG4gICAgICB0aGlzLmFhY092ZXJGbG93ID0gbnVsbDtcbiAgICAgIGNvbnN0IGZyYW1lTWlzc2luZ0J5dGVzID0gYWFjT3ZlckZsb3cubWlzc2luZztcbiAgICAgIGNvbnN0IHNhbXBsZUxlbmd0aCA9IGFhY092ZXJGbG93LnNhbXBsZS51bml0LmJ5dGVMZW5ndGg7XG4gICAgICAvLyBsb2dnZXIubG9nKGBBQUM6IGFwcGVuZCBvdmVyZmxvd2luZyAke3NhbXBsZUxlbmd0aH0gYnl0ZXMgdG8gYmVnaW5uaW5nIG9mIG5ldyBQRVNgKTtcbiAgICAgIGlmIChmcmFtZU1pc3NpbmdCeXRlcyA9PT0gLTEpIHtcbiAgICAgICAgZGF0YSA9IGFwcGVuZFVpbnQ4QXJyYXkoYWFjT3ZlckZsb3cuc2FtcGxlLnVuaXQsIGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZnJhbWVPdmVyZmxvd0J5dGVzID0gc2FtcGxlTGVuZ3RoIC0gZnJhbWVNaXNzaW5nQnl0ZXM7XG4gICAgICAgIGFhY092ZXJGbG93LnNhbXBsZS51bml0LnNldChkYXRhLnN1YmFycmF5KDAsIGZyYW1lTWlzc2luZ0J5dGVzKSwgZnJhbWVPdmVyZmxvd0J5dGVzKTtcbiAgICAgICAgdHJhY2suc2FtcGxlcy5wdXNoKGFhY092ZXJGbG93LnNhbXBsZSk7XG4gICAgICAgIHN0YXJ0T2Zmc2V0ID0gYWFjT3ZlckZsb3cubWlzc2luZztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gbG9vayBmb3IgQURUUyBoZWFkZXIgKDB4RkZGeClcbiAgICBsZXQgb2Zmc2V0O1xuICAgIGxldCBsZW47XG4gICAgZm9yIChvZmZzZXQgPSBzdGFydE9mZnNldCwgbGVuID0gZGF0YS5sZW5ndGg7IG9mZnNldCA8IGxlbiAtIDE7IG9mZnNldCsrKSB7XG4gICAgICBpZiAoaXNIZWFkZXIkMShkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiBBRFRTIGhlYWRlciBkb2VzIG5vdCBzdGFydCBzdHJhaWdodCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIFBFUyBwYXlsb2FkLCByYWlzZSBhbiBlcnJvclxuICAgIGlmIChvZmZzZXQgIT09IHN0YXJ0T2Zmc2V0KSB7XG4gICAgICBsZXQgcmVhc29uO1xuICAgICAgY29uc3QgcmVjb3ZlcmFibGUgPSBvZmZzZXQgPCBsZW4gLSAxO1xuICAgICAgaWYgKHJlY292ZXJhYmxlKSB7XG4gICAgICAgIHJlYXNvbiA9IGBBQUMgUEVTIGRpZCBub3Qgc3RhcnQgd2l0aCBBRFRTIGhlYWRlcixvZmZzZXQ6JHtvZmZzZXR9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlYXNvbiA9ICdObyBBRFRTIGhlYWRlciBmb3VuZCBpbiBBQUMgUEVTJztcbiAgICAgIH1cbiAgICAgIGVtaXRQYXJzaW5nRXJyb3IodGhpcy5vYnNlcnZlciwgbmV3IEVycm9yKHJlYXNvbiksIHJlY292ZXJhYmxlLCB0aGlzLmxvZ2dlcik7XG4gICAgICBpZiAoIXJlY292ZXJhYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaW5pdFRyYWNrQ29uZmlnKHRyYWNrLCB0aGlzLm9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIHRoaXMuYXVkaW9Db2RlYyk7XG4gICAgbGV0IHB0cztcbiAgICBpZiAocGVzLnB0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwdHMgPSBwZXMucHRzO1xuICAgIH0gZWxzZSBpZiAoYWFjT3ZlckZsb3cpIHtcbiAgICAgIC8vIGlmIGxhc3QgQUFDIGZyYW1lIGlzIG92ZXJmbG93aW5nLCB3ZSBzaG91bGQgZW5zdXJlIHRpbWVzdGFtcHMgYXJlIGNvbnRpZ3VvdXM6XG4gICAgICAvLyBmaXJzdCBzYW1wbGUgUFRTIHNob3VsZCBiZSBlcXVhbCB0byBsYXN0IHNhbXBsZSBQVFMgKyBmcmFtZUR1cmF0aW9uXG4gICAgICBjb25zdCBmcmFtZUR1cmF0aW9uID0gZ2V0RnJhbWVEdXJhdGlvbih0cmFjay5zYW1wbGVyYXRlKTtcbiAgICAgIHB0cyA9IGFhY092ZXJGbG93LnNhbXBsZS5wdHMgKyBmcmFtZUR1cmF0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKCdbdHNkZW11eGVyXTogQUFDIFBFUyB1bmtub3duIFBUUycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHNjYW4gZm9yIGFhYyBzYW1wbGVzXG4gICAgbGV0IGZyYW1lSW5kZXggPSAwO1xuICAgIGxldCBmcmFtZTtcbiAgICB3aGlsZSAob2Zmc2V0IDwgbGVuKSB7XG4gICAgICBmcmFtZSA9IGFwcGVuZEZyYW1lJDIodHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KTtcbiAgICAgIG9mZnNldCArPSBmcmFtZS5sZW5ndGg7XG4gICAgICBpZiAoIWZyYW1lLm1pc3NpbmcpIHtcbiAgICAgICAgZnJhbWVJbmRleCsrO1xuICAgICAgICBmb3IgKDsgb2Zmc2V0IDwgbGVuIC0gMTsgb2Zmc2V0KyspIHtcbiAgICAgICAgICBpZiAoaXNIZWFkZXIkMShkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBmcmFtZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBhcnNlTVBFR1BFUyh0cmFjaywgcGVzKSB7XG4gICAgY29uc3QgZGF0YSA9IHBlcy5kYXRhO1xuICAgIGNvbnN0IGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgIGxldCBmcmFtZUluZGV4ID0gMDtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBjb25zdCBwdHMgPSBwZXMucHRzO1xuICAgIGlmIChwdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybignW3RzZGVtdXhlcl06IE1QRUcgUEVTIHVua25vd24gUFRTJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdoaWxlIChvZmZzZXQgPCBsZW5ndGgpIHtcbiAgICAgIGlmIChpc0hlYWRlcihkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgIGNvbnN0IGZyYW1lID0gYXBwZW5kRnJhbWUkMSh0cmFjaywgZGF0YSwgb2Zmc2V0LCBwdHMsIGZyYW1lSW5kZXgpO1xuICAgICAgICBpZiAoZnJhbWUpIHtcbiAgICAgICAgICBvZmZzZXQgKz0gZnJhbWUubGVuZ3RoO1xuICAgICAgICAgIGZyYW1lSW5kZXgrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBsb2dnZXIubG9nKCdVbmFibGUgdG8gcGFyc2UgTXBlZyBhdWRpbyBmcmFtZScpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBub3RoaW5nIGZvdW5kLCBrZWVwIGxvb2tpbmdcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBhcnNlQUMzUEVTKHRyYWNrLCBwZXMpIHtcbiAgICB7XG4gICAgICBjb25zdCBkYXRhID0gcGVzLmRhdGE7XG4gICAgICBjb25zdCBwdHMgPSBwZXMucHRzO1xuICAgICAgaWYgKHB0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ1t0c2RlbXV4ZXJdOiBBQzMgUEVTIHVua25vd24gUFRTJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgbGV0IGZyYW1lSW5kZXggPSAwO1xuICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICBsZXQgcGFyc2VkO1xuICAgICAgd2hpbGUgKG9mZnNldCA8IGxlbmd0aCAmJiAocGFyc2VkID0gYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KyspKSA+IDApIHtcbiAgICAgICAgb2Zmc2V0ICs9IHBhcnNlZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcGFyc2VJRDNQRVMoaWQzVHJhY2ssIHBlcykge1xuICAgIGlmIChwZXMucHRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ1t0c2RlbXV4ZXJdOiBJRDMgUEVTIHVua25vd24gUFRTJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlkM1NhbXBsZSA9IF9leHRlbmRzKHt9LCBwZXMsIHtcbiAgICAgIHR5cGU6IHRoaXMuX3ZpZGVvVHJhY2sgPyBNZXRhZGF0YVNjaGVtYS5lbXNnIDogTWV0YWRhdGFTY2hlbWEuYXVkaW9JZDMsXG4gICAgICBkdXJhdGlvbjogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG4gICAgfSk7XG4gICAgaWQzVHJhY2suc2FtcGxlcy5wdXNoKGlkM1NhbXBsZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlUElEKGRhdGEsIG9mZnNldCkge1xuICAvLyBwaWQgaXMgYSAxMy1iaXQgZmllbGQgc3RhcnRpbmcgYXQgdGhlIGxhc3QgYml0IG9mIFRTWzFdXG4gIHJldHVybiAoKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDFmKSA8PCA4KSArIGRhdGFbb2Zmc2V0ICsgMl07XG59XG5mdW5jdGlvbiBwYXJzZVBBVChkYXRhLCBvZmZzZXQpIHtcbiAgLy8gc2tpcCB0aGUgUFNJIGhlYWRlciBhbmQgcGFyc2UgdGhlIGZpcnN0IFBNVCBlbnRyeVxuICByZXR1cm4gKGRhdGFbb2Zmc2V0ICsgMTBdICYgMHgxZikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgMTFdO1xufVxuZnVuY3Rpb24gcGFyc2VQTVQoZGF0YSwgb2Zmc2V0LCB0eXBlU3VwcG9ydGVkLCBpc1NhbXBsZUFlcywgb2JzZXJ2ZXIsIGxvZ2dlcikge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgYXVkaW9QaWQ6IC0xLFxuICAgIHZpZGVvUGlkOiAtMSxcbiAgICBpZDNQaWQ6IC0xLFxuICAgIHNlZ21lbnRWaWRlb0NvZGVjOiAnYXZjJyxcbiAgICBzZWdtZW50QXVkaW9Db2RlYzogJ2FhYydcbiAgfTtcbiAgY29uc3Qgc2VjdGlvbkxlbmd0aCA9IChkYXRhW29mZnNldCArIDFdICYgMHgwZikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgMl07XG4gIGNvbnN0IHRhYmxlRW5kID0gb2Zmc2V0ICsgMyArIHNlY3Rpb25MZW5ndGggLSA0O1xuICAvLyB0byBkZXRlcm1pbmUgd2hlcmUgdGhlIHRhYmxlIGlzLCB3ZSBoYXZlIHRvIGZpZ3VyZSBvdXQgaG93XG4gIC8vIGxvbmcgdGhlIHByb2dyYW0gaW5mbyBkZXNjcmlwdG9ycyBhcmVcbiAgY29uc3QgcHJvZ3JhbUluZm9MZW5ndGggPSAoZGF0YVtvZmZzZXQgKyAxMF0gJiAweDBmKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyAxMV07XG4gIC8vIGFkdmFuY2UgdGhlIG9mZnNldCB0byB0aGUgZmlyc3QgZW50cnkgaW4gdGhlIG1hcHBpbmcgdGFibGVcbiAgb2Zmc2V0ICs9IDEyICsgcHJvZ3JhbUluZm9MZW5ndGg7XG4gIHdoaWxlIChvZmZzZXQgPCB0YWJsZUVuZCkge1xuICAgIGNvbnN0IHBpZCA9IHBhcnNlUElEKGRhdGEsIG9mZnNldCk7XG4gICAgY29uc3QgZXNJbmZvTGVuZ3RoID0gKGRhdGFbb2Zmc2V0ICsgM10gJiAweDBmKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyA0XTtcbiAgICBzd2l0Y2ggKGRhdGFbb2Zmc2V0XSkge1xuICAgICAgY2FzZSAweGNmOlxuICAgICAgICAvLyBTQU1QTEUtQUVTIEFBQ1xuICAgICAgICBpZiAoIWlzU2FtcGxlQWVzKSB7XG4gICAgICAgICAgbG9nRW5jcnlwdGVkU2FtcGxlc0ZvdW5kSW5VbmVuY3J5cHRlZFN0cmVhbSgnQURUUyBBQUMnLCBsb2dnZXIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIDB4MGY6XG4gICAgICAgIC8vIElTTy9JRUMgMTM4MTgtNyBBRFRTIEFBQyAoTVBFRy0yIGxvd2VyIGJpdC1yYXRlIGF1ZGlvKVxuICAgICAgICAvLyBsb2dnZXIubG9nKCdBQUMgUElEOicgICsgcGlkKTtcbiAgICAgICAgaWYgKHJlc3VsdC5hdWRpb1BpZCA9PT0gLTEpIHtcbiAgICAgICAgICByZXN1bHQuYXVkaW9QaWQgPSBwaWQ7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIC8vIFBhY2tldGl6ZWQgbWV0YWRhdGEgKElEMylcbiAgICAgIGNhc2UgMHgxNTpcbiAgICAgICAgLy8gbG9nZ2VyLmxvZygnSUQzIFBJRDonICArIHBpZCk7XG4gICAgICAgIGlmIChyZXN1bHQuaWQzUGlkID09PSAtMSkge1xuICAgICAgICAgIHJlc3VsdC5pZDNQaWQgPSBwaWQ7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDB4ZGI6XG4gICAgICAgIC8vIFNBTVBMRS1BRVMgQVZDXG4gICAgICAgIGlmICghaXNTYW1wbGVBZXMpIHtcbiAgICAgICAgICBsb2dFbmNyeXB0ZWRTYW1wbGVzRm91bmRJblVuZW5jcnlwdGVkU3RyZWFtKCdILjI2NCcsIGxvZ2dlcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgMHgxYjpcbiAgICAgICAgLy8gSVRVLVQgUmVjLiBILjI2NCBhbmQgSVNPL0lFQyAxNDQ5Ni0xMCAobG93ZXIgYml0LXJhdGUgdmlkZW8pXG4gICAgICAgIC8vIGxvZ2dlci5sb2coJ0FWQyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICBpZiAocmVzdWx0LnZpZGVvUGlkID09PSAtMSkge1xuICAgICAgICAgIHJlc3VsdC52aWRlb1BpZCA9IHBpZDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgLy8gSVNPL0lFQyAxMTE3Mi0zIChNUEVHLTEgYXVkaW8pXG4gICAgICAvLyBvciBJU08vSUVDIDEzODE4LTMgKE1QRUctMiBoYWx2ZWQgc2FtcGxlIHJhdGUgYXVkaW8pXG4gICAgICBjYXNlIDB4MDM6XG4gICAgICBjYXNlIDB4MDQ6XG4gICAgICAgIC8vIGxvZ2dlci5sb2coJ01QRUcgUElEOicgICsgcGlkKTtcbiAgICAgICAgaWYgKCF0eXBlU3VwcG9ydGVkLm1wZWcgJiYgIXR5cGVTdXBwb3J0ZWQubXAzKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZygnTVBFRyBhdWRpbyBmb3VuZCwgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQuYXVkaW9QaWQgPT09IC0xKSB7XG4gICAgICAgICAgcmVzdWx0LmF1ZGlvUGlkID0gcGlkO1xuICAgICAgICAgIHJlc3VsdC5zZWdtZW50QXVkaW9Db2RlYyA9ICdtcDMnO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAweGMxOlxuICAgICAgICAvLyBTQU1QTEUtQUVTIEFDM1xuICAgICAgICBpZiAoIWlzU2FtcGxlQWVzKSB7XG4gICAgICAgICAgbG9nRW5jcnlwdGVkU2FtcGxlc0ZvdW5kSW5VbmVuY3J5cHRlZFN0cmVhbSgnQUMtMycsIGxvZ2dlcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgMHg4MTpcbiAgICAgICAge1xuICAgICAgICAgIGlmICghdHlwZVN1cHBvcnRlZC5hYzMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ0FDLTMgYXVkaW8gZm91bmQsIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQuYXVkaW9QaWQgPT09IC0xKSB7XG4gICAgICAgICAgICByZXN1bHQuYXVkaW9QaWQgPSBwaWQ7XG4gICAgICAgICAgICByZXN1bHQuc2VnbWVudEF1ZGlvQ29kZWMgPSAnYWMzJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDB4MDY6XG4gICAgICAgIC8vIHN0cmVhbV90eXBlIDYgY2FuIG1lYW4gYSBsb3Qgb2YgZGlmZmVyZW50IHRoaW5ncyBpbiBjYXNlIG9mIERWQi5cbiAgICAgICAgLy8gV2UgbmVlZCB0byBsb29rIGF0IHRoZSBkZXNjcmlwdG9ycy4gUmlnaHQgbm93LCB3ZSdyZSBvbmx5IGludGVyZXN0ZWRcbiAgICAgICAgLy8gaW4gQUMtMyBhdWRpbywgc28gd2UgZG8gdGhlIGRlc2NyaXB0b3IgcGFyc2luZyBvbmx5IHdoZW4gd2UgZG9uJ3QgaGF2ZVxuICAgICAgICAvLyBhbiBhdWRpbyBQSUQgeWV0LlxuICAgICAgICBpZiAocmVzdWx0LmF1ZGlvUGlkID09PSAtMSAmJiBlc0luZm9MZW5ndGggPiAwKSB7XG4gICAgICAgICAgbGV0IHBhcnNlUG9zID0gb2Zmc2V0ICsgNTtcbiAgICAgICAgICBsZXQgcmVtYWluaW5nID0gZXNJbmZvTGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChyZW1haW5pbmcgPiAyKSB7XG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdG9ySWQgPSBkYXRhW3BhcnNlUG9zXTtcbiAgICAgICAgICAgIHN3aXRjaCAoZGVzY3JpcHRvcklkKSB7XG4gICAgICAgICAgICAgIGNhc2UgMHg2YTpcbiAgICAgICAgICAgICAgICAvLyBEVkIgRGVzY3JpcHRvciBmb3IgQUMtM1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlU3VwcG9ydGVkLmFjMyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKCdBQy0zIGF1ZGlvIGZvdW5kLCBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlciBmb3Igbm93Jyk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXVkaW9QaWQgPSBwaWQ7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZWdtZW50QXVkaW9Db2RlYyA9ICdhYzMnO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0b3JMZW4gPSBkYXRhW3BhcnNlUG9zICsgMV0gKyAyO1xuICAgICAgICAgICAgcGFyc2VQb3MgKz0gZGVzY3JpcHRvckxlbjtcbiAgICAgICAgICAgIHJlbWFpbmluZyAtPSBkZXNjcmlwdG9yTGVuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMHhjMjogLy8gU0FNUExFLUFFUyBFQzNcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgMHg4NzpcbiAgICAgICAgZW1pdFBhcnNpbmdFcnJvcihvYnNlcnZlciwgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBFQy0zIGluIE0yVFMgZm91bmQnKSwgdW5kZWZpbmVkLCBsb2dnZXIpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgY2FzZSAweDI0OlxuICAgICAgICAvLyBJVFUtVCBSZWMuIEguMjY1IGFuZCBJU08vSUVDIDIzMDA4LTIgKEhFVkMpXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAocmVzdWx0LnZpZGVvUGlkID09PSAtMSkge1xuICAgICAgICAgICAgcmVzdWx0LnZpZGVvUGlkID0gcGlkO1xuICAgICAgICAgICAgcmVzdWx0LnNlZ21lbnRWaWRlb0NvZGVjID0gJ2hldmMnO1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygnSEVWQyBpbiBNMlRTIGZvdW5kJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBtb3ZlIHRvIHRoZSBuZXh0IHRhYmxlIGVudHJ5XG4gICAgLy8gc2tpcCBwYXN0IHRoZSBlbGVtZW50YXJ5IHN0cmVhbSBkZXNjcmlwdG9ycywgaWYgcHJlc2VudFxuICAgIG9mZnNldCArPSBlc0luZm9MZW5ndGggKyA1O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBlbWl0UGFyc2luZ0Vycm9yKG9ic2VydmVyLCBlcnJvciwgbGV2ZWxSZXRyeSwgbG9nZ2VyKSB7XG4gIGxvZ2dlci53YXJuKGBwYXJzaW5nIGVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gIG9ic2VydmVyLmVtaXQoRXZlbnRzLkVSUk9SLCBFdmVudHMuRVJST1IsIHtcbiAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsXG4gICAgZmF0YWw6IGZhbHNlLFxuICAgIGxldmVsUmV0cnksXG4gICAgZXJyb3IsXG4gICAgcmVhc29uOiBlcnJvci5tZXNzYWdlXG4gIH0pO1xufVxuZnVuY3Rpb24gbG9nRW5jcnlwdGVkU2FtcGxlc0ZvdW5kSW5VbmVuY3J5cHRlZFN0cmVhbSh0eXBlLCBsb2dnZXIpIHtcbiAgbG9nZ2VyLmxvZyhgJHt0eXBlfSB3aXRoIEFFUy0xMjgtQ0JDIGVuY3J5cHRpb24gZm91bmQgaW4gdW5lbmNyeXB0ZWQgc3RyZWFtYCk7XG59XG5mdW5jdGlvbiBwYXJzZVBFUyhzdHJlYW0sIGxvZ2dlcikge1xuICBsZXQgaSA9IDA7XG4gIGxldCBmcmFnO1xuICBsZXQgcGVzTGVuO1xuICBsZXQgcGVzSGRyTGVuO1xuICBsZXQgcGVzUHRzO1xuICBsZXQgcGVzRHRzO1xuICBjb25zdCBkYXRhID0gc3RyZWFtLmRhdGE7XG4gIC8vIHNhZmV0eSBjaGVja1xuICBpZiAoIXN0cmVhbSB8fCBzdHJlYW0uc2l6ZSA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gd2UgbWlnaHQgbmVlZCB1cCB0byAxOSBieXRlcyB0byByZWFkIFBFUyBoZWFkZXJcbiAgLy8gaWYgZmlyc3QgY2h1bmsgb2YgZGF0YSBpcyBsZXNzIHRoYW4gMTkgYnl0ZXMsIGxldCdzIG1lcmdlIGl0IHdpdGggZm9sbG93aW5nIG9uZXMgdW50aWwgd2UgZ2V0IDE5IGJ5dGVzXG4gIC8vIHVzdWFsbHkgb25seSBvbmUgbWVyZ2UgaXMgbmVlZGVkIChhbmQgdGhpcyBpcyByYXJlIC4uLilcbiAgd2hpbGUgKGRhdGFbMF0ubGVuZ3RoIDwgMTkgJiYgZGF0YS5sZW5ndGggPiAxKSB7XG4gICAgZGF0YVswXSA9IGFwcGVuZFVpbnQ4QXJyYXkoZGF0YVswXSwgZGF0YVsxXSk7XG4gICAgZGF0YS5zcGxpY2UoMSwgMSk7XG4gIH1cbiAgLy8gcmV0cmlldmUgUFRTL0RUUyBmcm9tIGZpcnN0IGZyYWdtZW50XG4gIGZyYWcgPSBkYXRhWzBdO1xuICBjb25zdCBwZXNQcmVmaXggPSAoZnJhZ1swXSA8PCAxNikgKyAoZnJhZ1sxXSA8PCA4KSArIGZyYWdbMl07XG4gIGlmIChwZXNQcmVmaXggPT09IDEpIHtcbiAgICBwZXNMZW4gPSAoZnJhZ1s0XSA8PCA4KSArIGZyYWdbNV07XG4gICAgLy8gaWYgUEVTIHBhcnNlZCBsZW5ndGggaXMgbm90IHplcm8gYW5kIGdyZWF0ZXIgdGhhbiB0b3RhbCByZWNlaXZlZCBsZW5ndGgsIHN0b3AgcGFyc2luZy4gUEVTIG1pZ2h0IGJlIHRydW5jYXRlZFxuICAgIC8vIG1pbnVzIDYgOiBQRVMgaGVhZGVyIHNpemVcbiAgICBpZiAocGVzTGVuICYmIHBlc0xlbiA+IHN0cmVhbS5zaXplIC0gNikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHBlc0ZsYWdzID0gZnJhZ1s3XTtcbiAgICBpZiAocGVzRmxhZ3MgJiAweGMwKSB7XG4gICAgICAvKiBQRVMgaGVhZGVyIGRlc2NyaWJlZCBoZXJlIDogaHR0cDovL2R2ZC5zb3VyY2Vmb3JnZS5uZXQvZHZkaW5mby9wZXMtaGRyLmh0bWxcbiAgICAgICAgICBhcyBQVFMgLyBEVFMgaXMgMzMgYml0IHdlIGNhbm5vdCB1c2UgYml0d2lzZSBvcGVyYXRvciBpbiBKUyxcbiAgICAgICAgICBhcyBCaXR3aXNlIG9wZXJhdG9ycyB0cmVhdCB0aGVpciBvcGVyYW5kcyBhcyBhIHNlcXVlbmNlIG9mIDMyIGJpdHMgKi9cbiAgICAgIHBlc1B0cyA9IChmcmFnWzldICYgMHgwZSkgKiA1MzY4NzA5MTIgK1xuICAgICAgLy8gMSA8PCAyOVxuICAgICAgKGZyYWdbMTBdICYgMHhmZikgKiA0MTk0MzA0ICtcbiAgICAgIC8vIDEgPDwgMjJcbiAgICAgIChmcmFnWzExXSAmIDB4ZmUpICogMTYzODQgK1xuICAgICAgLy8gMSA8PCAxNFxuICAgICAgKGZyYWdbMTJdICYgMHhmZikgKiAxMjggK1xuICAgICAgLy8gMSA8PCA3XG4gICAgICAoZnJhZ1sxM10gJiAweGZlKSAvIDI7XG4gICAgICBpZiAocGVzRmxhZ3MgJiAweDQwKSB7XG4gICAgICAgIHBlc0R0cyA9IChmcmFnWzE0XSAmIDB4MGUpICogNTM2ODcwOTEyICtcbiAgICAgICAgLy8gMSA8PCAyOVxuICAgICAgICAoZnJhZ1sxNV0gJiAweGZmKSAqIDQxOTQzMDQgK1xuICAgICAgICAvLyAxIDw8IDIyXG4gICAgICAgIChmcmFnWzE2XSAmIDB4ZmUpICogMTYzODQgK1xuICAgICAgICAvLyAxIDw8IDE0XG4gICAgICAgIChmcmFnWzE3XSAmIDB4ZmYpICogMTI4ICtcbiAgICAgICAgLy8gMSA8PCA3XG4gICAgICAgIChmcmFnWzE4XSAmIDB4ZmUpIC8gMjtcbiAgICAgICAgaWYgKHBlc1B0cyAtIHBlc0R0cyA+IDYwICogOTAwMDApIHtcbiAgICAgICAgICBsb2dnZXIud2FybihgJHtNYXRoLnJvdW5kKChwZXNQdHMgLSBwZXNEdHMpIC8gOTAwMDApfXMgZGVsdGEgYmV0d2VlbiBQVFMgYW5kIERUUywgYWxpZ24gdGhlbWApO1xuICAgICAgICAgIHBlc1B0cyA9IHBlc0R0cztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVzRHRzID0gcGVzUHRzO1xuICAgICAgfVxuICAgIH1cbiAgICBwZXNIZHJMZW4gPSBmcmFnWzhdO1xuICAgIC8vIDkgYnl0ZXMgOiA2IGJ5dGVzIGZvciBQRVMgaGVhZGVyICsgMyBieXRlcyBmb3IgUEVTIGV4dGVuc2lvblxuICAgIGxldCBwYXlsb2FkU3RhcnRPZmZzZXQgPSBwZXNIZHJMZW4gKyA5O1xuICAgIGlmIChzdHJlYW0uc2l6ZSA8PSBwYXlsb2FkU3RhcnRPZmZzZXQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdHJlYW0uc2l6ZSAtPSBwYXlsb2FkU3RhcnRPZmZzZXQ7XG4gICAgLy8gcmVhc3NlbWJsZSBQRVMgcGFja2V0XG4gICAgY29uc3QgcGVzRGF0YSA9IG5ldyBVaW50OEFycmF5KHN0cmVhbS5zaXplKTtcbiAgICBmb3IgKGxldCBqID0gMCwgZGF0YUxlbiA9IGRhdGEubGVuZ3RoOyBqIDwgZGF0YUxlbjsgaisrKSB7XG4gICAgICBmcmFnID0gZGF0YVtqXTtcbiAgICAgIGxldCBsZW4gPSBmcmFnLmJ5dGVMZW5ndGg7XG4gICAgICBpZiAocGF5bG9hZFN0YXJ0T2Zmc2V0KSB7XG4gICAgICAgIGlmIChwYXlsb2FkU3RhcnRPZmZzZXQgPiBsZW4pIHtcbiAgICAgICAgICAvLyB0cmltIGZ1bGwgZnJhZyBpZiBQRVMgaGVhZGVyIGJpZ2dlciB0aGFuIGZyYWdcbiAgICAgICAgICBwYXlsb2FkU3RhcnRPZmZzZXQgLT0gbGVuO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRyaW0gcGFydGlhbCBmcmFnIGlmIFBFUyBoZWFkZXIgc21hbGxlciB0aGFuIGZyYWdcbiAgICAgICAgICBmcmFnID0gZnJhZy5zdWJhcnJheShwYXlsb2FkU3RhcnRPZmZzZXQpO1xuICAgICAgICAgIGxlbiAtPSBwYXlsb2FkU3RhcnRPZmZzZXQ7XG4gICAgICAgICAgcGF5bG9hZFN0YXJ0T2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGVzRGF0YS5zZXQoZnJhZywgaSk7XG4gICAgICBpICs9IGxlbjtcbiAgICB9XG4gICAgaWYgKHBlc0xlbikge1xuICAgICAgLy8gcGF5bG9hZCBzaXplIDogcmVtb3ZlIFBFUyBoZWFkZXIgKyBQRVMgZXh0ZW5zaW9uXG4gICAgICBwZXNMZW4gLT0gcGVzSGRyTGVuICsgMztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IHBlc0RhdGEsXG4gICAgICBwdHM6IHBlc1B0cyxcbiAgICAgIGR0czogcGVzRHRzLFxuICAgICAgbGVuOiBwZXNMZW5cbiAgICB9O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqICBBQUMgaGVscGVyXG4gKi9cblxuY2xhc3MgQUFDIHtcbiAgc3RhdGljIGdldFNpbGVudEZyYW1lKGNvZGVjLCBjaGFubmVsQ291bnQpIHtcbiAgICBzd2l0Y2ggKGNvZGVjKSB7XG4gICAgICBjYXNlICdtcDRhLjQwLjInOlxuICAgICAgICBpZiAoY2hhbm5lbENvdW50ID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIzLCAweDgwXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDIxLCAweDAwLCAweDQ5LCAweDkwLCAweDAyLCAweDE5LCAweDAwLCAweDIzLCAweDgwXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDhlXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA0KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDgwLCAweDJjLCAweDgwLCAweDA4LCAweDAyLCAweDM4XSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA1KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDgyLCAweDMwLCAweDA0LCAweDk5LCAweDAwLCAweDIxLCAweDkwLCAweDAyLCAweDM4XSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA2KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDgyLCAweDMwLCAweDA0LCAweDk5LCAweDAwLCAweDIxLCAweDkwLCAweDAyLCAweDAwLCAweGIyLCAweDAwLCAweDIwLCAweDA4LCAweGUwXSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBoYW5kbGUgSEUtQUFDIGJlbG93IChtcDRhLjQwLjUgLyBtcDRhLjQwLjI5KVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGNoYW5uZWxDb3VudCA9PT0gMSkge1xuICAgICAgICAgIC8vIGZmbXBlZyAteSAtZiBsYXZmaSAtaSBcImFldmFsc3JjPTA6ZD0wLjA1XCIgLWM6YSBsaWJmZGtfYWFjIC1wcm9maWxlOmEgYWFjX2hlIC1iOmEgNGsgb3V0cHV0LmFhYyAmJiBoZXhkdW1wIC12IC1lICcxNi8xIFwiMHgleCxcIiBcIlxcblwiJyAtdiBvdXRwdXQuYWFjXG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDEsIDB4NDAsIDB4MjIsIDB4ODAsIDB4YTMsIDB4NGUsIDB4ZTYsIDB4ODAsIDB4YmEsIDB4OCwgMHgwLCAweDAsIDB4MCwgMHgxYywgMHg2LCAweGYxLCAweGMxLCAweGEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWVdKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDIpIHtcbiAgICAgICAgICAvLyBmZm1wZWcgLXkgLWYgbGF2ZmkgLWkgXCJhZXZhbHNyYz0wfDA6ZD0wLjA1XCIgLWM6YSBsaWJmZGtfYWFjIC1wcm9maWxlOmEgYWFjX2hlX3YyIC1iOmEgNGsgb3V0cHV0LmFhYyAmJiBoZXhkdW1wIC12IC1lICcxNi8xIFwiMHgleCxcIiBcIlxcblwiJyAtdiBvdXRwdXQuYWFjXG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDEsIDB4NDAsIDB4MjIsIDB4ODAsIDB4YTMsIDB4NWUsIDB4ZTYsIDB4ODAsIDB4YmEsIDB4OCwgMHgwLCAweDAsIDB4MCwgMHgwLCAweDk1LCAweDAsIDB4NiwgMHhmMSwgMHhhMSwgMHhhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVlXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAzKSB7XG4gICAgICAgICAgLy8gZmZtcGVnIC15IC1mIGxhdmZpIC1pIFwiYWV2YWxzcmM9MHwwfDA6ZD0wLjA1XCIgLWM6YSBsaWJmZGtfYWFjIC1wcm9maWxlOmEgYWFjX2hlX3YyIC1iOmEgNGsgb3V0cHV0LmFhYyAmJiBoZXhkdW1wIC12IC1lICcxNi8xIFwiMHgleCxcIiBcIlxcblwiJyAtdiBvdXRwdXQuYWFjXG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDEsIDB4NDAsIDB4MjIsIDB4ODAsIDB4YTMsIDB4NWUsIDB4ZTYsIDB4ODAsIDB4YmEsIDB4OCwgMHgwLCAweDAsIDB4MCwgMHgwLCAweDk1LCAweDAsIDB4NiwgMHhmMSwgMHhhMSwgMHhhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVlXSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBNUDQgQm94XG4gKi9cblxuY29uc3QgVUlOVDMyX01BWCA9IE1hdGgucG93KDIsIDMyKSAtIDE7XG5jbGFzcyBNUDQge1xuICBzdGF0aWMgaW5pdCgpIHtcbiAgICBNUDQudHlwZXMgPSB7XG4gICAgICBhdmMxOiBbXSxcbiAgICAgIC8vIGNvZGluZ25hbWVcbiAgICAgIGF2Y0M6IFtdLFxuICAgICAgaHZjMTogW10sXG4gICAgICBodmNDOiBbXSxcbiAgICAgIGJ0cnQ6IFtdLFxuICAgICAgZGluZjogW10sXG4gICAgICBkcmVmOiBbXSxcbiAgICAgIGVzZHM6IFtdLFxuICAgICAgZnR5cDogW10sXG4gICAgICBoZGxyOiBbXSxcbiAgICAgIG1kYXQ6IFtdLFxuICAgICAgbWRoZDogW10sXG4gICAgICBtZGlhOiBbXSxcbiAgICAgIG1maGQ6IFtdLFxuICAgICAgbWluZjogW10sXG4gICAgICBtb29mOiBbXSxcbiAgICAgIG1vb3Y6IFtdLFxuICAgICAgbXA0YTogW10sXG4gICAgICAnLm1wMyc6IFtdLFxuICAgICAgZGFjMzogW10sXG4gICAgICAnYWMtMyc6IFtdLFxuICAgICAgbXZleDogW10sXG4gICAgICBtdmhkOiBbXSxcbiAgICAgIHBhc3A6IFtdLFxuICAgICAgc2R0cDogW10sXG4gICAgICBzdGJsOiBbXSxcbiAgICAgIHN0Y286IFtdLFxuICAgICAgc3RzYzogW10sXG4gICAgICBzdHNkOiBbXSxcbiAgICAgIHN0c3o6IFtdLFxuICAgICAgc3R0czogW10sXG4gICAgICB0ZmR0OiBbXSxcbiAgICAgIHRmaGQ6IFtdLFxuICAgICAgdHJhZjogW10sXG4gICAgICB0cmFrOiBbXSxcbiAgICAgIHRydW46IFtdLFxuICAgICAgdHJleDogW10sXG4gICAgICB0a2hkOiBbXSxcbiAgICAgIHZtaGQ6IFtdLFxuICAgICAgc21oZDogW11cbiAgICB9O1xuICAgIGxldCBpO1xuICAgIGZvciAoaSBpbiBNUDQudHlwZXMpIHtcbiAgICAgIGlmIChNUDQudHlwZXMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgTVA0LnR5cGVzW2ldID0gW2kuY2hhckNvZGVBdCgwKSwgaS5jaGFyQ29kZUF0KDEpLCBpLmNoYXJDb2RlQXQoMiksIGkuY2hhckNvZGVBdCgzKV07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHZpZGVvSGRsciA9IG5ldyBVaW50OEFycmF5KFsweDAwLFxuICAgIC8vIHZlcnNpb24gMFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gZmxhZ3NcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHByZV9kZWZpbmVkXG4gICAgMHg3NiwgMHg2OSwgMHg2NCwgMHg2NSxcbiAgICAvLyBoYW5kbGVyX3R5cGU6ICd2aWRlJ1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4NTYsIDB4NjksIDB4NjQsIDB4NjUsIDB4NmYsIDB4NDgsIDB4NjEsIDB4NmUsIDB4NjQsIDB4NmMsIDB4NjUsIDB4NzIsIDB4MDAgLy8gbmFtZTogJ1ZpZGVvSGFuZGxlcidcbiAgICBdKTtcbiAgICBjb25zdCBhdWRpb0hkbHIgPSBuZXcgVWludDhBcnJheShbMHgwMCxcbiAgICAvLyB2ZXJzaW9uIDBcbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIGZsYWdzXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBwcmVfZGVmaW5lZFxuICAgIDB4NzMsIDB4NmYsIDB4NzUsIDB4NmUsXG4gICAgLy8gaGFuZGxlcl90eXBlOiAnc291bidcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDUzLCAweDZmLCAweDc1LCAweDZlLCAweDY0LCAweDQ4LCAweDYxLCAweDZlLCAweDY0LCAweDZjLCAweDY1LCAweDcyLCAweDAwIC8vIG5hbWU6ICdTb3VuZEhhbmRsZXInXG4gICAgXSk7XG4gICAgTVA0LkhETFJfVFlQRVMgPSB7XG4gICAgICB2aWRlbzogdmlkZW9IZGxyLFxuICAgICAgYXVkaW86IGF1ZGlvSGRsclxuICAgIH07XG4gICAgY29uc3QgZHJlZiA9IG5ldyBVaW50OEFycmF5KFsweDAwLFxuICAgIC8vIHZlcnNpb24gMFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gZmxhZ3NcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAxLFxuICAgIC8vIGVudHJ5X2NvdW50XG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwYyxcbiAgICAvLyBlbnRyeV9zaXplXG4gICAgMHg3NSwgMHg3MiwgMHg2YywgMHgyMCxcbiAgICAvLyAndXJsJyB0eXBlXG4gICAgMHgwMCxcbiAgICAvLyB2ZXJzaW9uIDBcbiAgICAweDAwLCAweDAwLCAweDAxIC8vIGVudHJ5X2ZsYWdzXG4gICAgXSk7XG4gICAgY29uc3Qgc3RjbyA9IG5ldyBVaW50OEFycmF5KFsweDAwLFxuICAgIC8vIHZlcnNpb25cbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIGZsYWdzXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCAvLyBlbnRyeV9jb3VudFxuICAgIF0pO1xuICAgIE1QNC5TVFRTID0gTVA0LlNUU0MgPSBNUDQuU1RDTyA9IHN0Y287XG4gICAgTVA0LlNUU1ogPSBuZXcgVWludDhBcnJheShbMHgwMCxcbiAgICAvLyB2ZXJzaW9uXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gc2FtcGxlX3NpemVcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwIC8vIHNhbXBsZV9jb3VudFxuICAgIF0pO1xuICAgIE1QNC5WTUhEID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgLy8gdmVyc2lvblxuICAgIDB4MDAsIDB4MDAsIDB4MDEsXG4gICAgLy8gZmxhZ3NcbiAgICAweDAwLCAweDAwLFxuICAgIC8vIGdyYXBoaWNzbW9kZVxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAgLy8gb3Bjb2xvclxuICAgIF0pO1xuICAgIE1QNC5TTUhEID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgLy8gdmVyc2lvblxuICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gZmxhZ3NcbiAgICAweDAwLCAweDAwLFxuICAgIC8vIGJhbGFuY2VcbiAgICAweDAwLCAweDAwIC8vIHJlc2VydmVkXG4gICAgXSk7XG4gICAgTVA0LlNUU0QgPSBuZXcgVWludDhBcnJheShbMHgwMCxcbiAgICAvLyB2ZXJzaW9uIDBcbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIGZsYWdzXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMV0pOyAvLyBlbnRyeV9jb3VudFxuXG4gICAgY29uc3QgbWFqb3JCcmFuZCA9IG5ldyBVaW50OEFycmF5KFsxMDUsIDExNSwgMTExLCAxMDldKTsgLy8gaXNvbVxuICAgIGNvbnN0IGF2YzFCcmFuZCA9IG5ldyBVaW50OEFycmF5KFs5NywgMTE4LCA5OSwgNDldKTsgLy8gYXZjMVxuICAgIGNvbnN0IG1pbm9yVmVyc2lvbiA9IG5ldyBVaW50OEFycmF5KFswLCAwLCAwLCAxXSk7XG4gICAgTVA0LkZUWVAgPSBNUDQuYm94KE1QNC50eXBlcy5mdHlwLCBtYWpvckJyYW5kLCBtaW5vclZlcnNpb24sIG1ham9yQnJhbmQsIGF2YzFCcmFuZCk7XG4gICAgTVA0LkRJTkYgPSBNUDQuYm94KE1QNC50eXBlcy5kaW5mLCBNUDQuYm94KE1QNC50eXBlcy5kcmVmLCBkcmVmKSk7XG4gIH1cbiAgc3RhdGljIGJveCh0eXBlLCAuLi5wYXlsb2FkKSB7XG4gICAgbGV0IHNpemUgPSA4O1xuICAgIGxldCBpID0gcGF5bG9hZC5sZW5ndGg7XG4gICAgY29uc3QgbGVuID0gaTtcbiAgICAvLyBjYWxjdWxhdGUgdGhlIHRvdGFsIHNpemUgd2UgbmVlZCB0byBhbGxvY2F0ZVxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHNpemUgKz0gcGF5bG9hZFtpXS5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICByZXN1bHRbMF0gPSBzaXplID4+IDI0ICYgMHhmZjtcbiAgICByZXN1bHRbMV0gPSBzaXplID4+IDE2ICYgMHhmZjtcbiAgICByZXN1bHRbMl0gPSBzaXplID4+IDggJiAweGZmO1xuICAgIHJlc3VsdFszXSA9IHNpemUgJiAweGZmO1xuICAgIHJlc3VsdC5zZXQodHlwZSwgNCk7XG4gICAgLy8gY29weSB0aGUgcGF5bG9hZCBpbnRvIHRoZSByZXN1bHRcbiAgICBmb3IgKGkgPSAwLCBzaXplID0gODsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAvLyBjb3B5IHBheWxvYWRbaV0gYXJyYXkgQCBvZmZzZXQgc2l6ZVxuICAgICAgcmVzdWx0LnNldChwYXlsb2FkW2ldLCBzaXplKTtcbiAgICAgIHNpemUgKz0gcGF5bG9hZFtpXS5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHN0YXRpYyBoZGxyKHR5cGUpIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuaGRsciwgTVA0LkhETFJfVFlQRVNbdHlwZV0pO1xuICB9XG4gIHN0YXRpYyBtZGF0KGRhdGEpIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWRhdCwgZGF0YSk7XG4gIH1cbiAgc3RhdGljIG1kaGQodGltZXNjYWxlLCBkdXJhdGlvbikge1xuICAgIGR1cmF0aW9uICo9IHRpbWVzY2FsZTtcbiAgICBjb25zdCB1cHBlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gLyAoVUlOVDMyX01BWCArIDEpKTtcbiAgICBjb25zdCBsb3dlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gJSAoVUlOVDMyX01BWCArIDEpKTtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWRoZCwgbmV3IFVpbnQ4QXJyYXkoWzB4MDEsXG4gICAgLy8gdmVyc2lvbiAxXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDIsXG4gICAgLy8gY3JlYXRpb25fdGltZVxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDMsXG4gICAgLy8gbW9kaWZpY2F0aW9uX3RpbWVcbiAgICB0aW1lc2NhbGUgPj4gMjQgJiAweGZmLCB0aW1lc2NhbGUgPj4gMTYgJiAweGZmLCB0aW1lc2NhbGUgPj4gOCAmIDB4ZmYsIHRpbWVzY2FsZSAmIDB4ZmYsXG4gICAgLy8gdGltZXNjYWxlXG4gICAgdXBwZXJXb3JkRHVyYXRpb24gPj4gMjQsIHVwcGVyV29yZER1cmF0aW9uID4+IDE2ICYgMHhmZiwgdXBwZXJXb3JkRHVyYXRpb24gPj4gOCAmIDB4ZmYsIHVwcGVyV29yZER1cmF0aW9uICYgMHhmZiwgbG93ZXJXb3JkRHVyYXRpb24gPj4gMjQsIGxvd2VyV29yZER1cmF0aW9uID4+IDE2ICYgMHhmZiwgbG93ZXJXb3JkRHVyYXRpb24gPj4gOCAmIDB4ZmYsIGxvd2VyV29yZER1cmF0aW9uICYgMHhmZiwgMHg1NSwgMHhjNCxcbiAgICAvLyAndW5kJyBsYW5ndWFnZSAodW5kZXRlcm1pbmVkKVxuICAgIDB4MDAsIDB4MDBdKSk7XG4gIH1cbiAgc3RhdGljIG1kaWEodHJhY2spIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWRpYSwgTVA0Lm1kaGQodHJhY2sudGltZXNjYWxlIHx8IDAsIHRyYWNrLmR1cmF0aW9uIHx8IDApLCBNUDQuaGRscih0cmFjay50eXBlKSwgTVA0Lm1pbmYodHJhY2spKTtcbiAgfVxuICBzdGF0aWMgbWZoZChzZXF1ZW5jZU51bWJlcikge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZmhkLCBuZXcgVWludDhBcnJheShbMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIHNlcXVlbmNlTnVtYmVyID4+IDI0LCBzZXF1ZW5jZU51bWJlciA+PiAxNiAmIDB4ZmYsIHNlcXVlbmNlTnVtYmVyID4+IDggJiAweGZmLCBzZXF1ZW5jZU51bWJlciAmIDB4ZmYgLy8gc2VxdWVuY2VfbnVtYmVyXG4gICAgXSkpO1xuICB9XG4gIHN0YXRpYyBtaW5mKHRyYWNrKSB7XG4gICAgaWYgKHRyYWNrLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5taW5mLCBNUDQuYm94KE1QNC50eXBlcy5zbWhkLCBNUDQuU01IRCksIE1QNC5ESU5GLCBNUDQuc3RibCh0cmFjaykpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWluZiwgTVA0LmJveChNUDQudHlwZXMudm1oZCwgTVA0LlZNSEQpLCBNUDQuRElORiwgTVA0LnN0YmwodHJhY2spKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIG1vb2Yoc24sIGJhc2VNZWRpYURlY29kZVRpbWUsIHRyYWNrKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1vb2YsIE1QNC5tZmhkKHNuKSwgTVA0LnRyYWYodHJhY2ssIGJhc2VNZWRpYURlY29kZVRpbWUpKTtcbiAgfVxuICBzdGF0aWMgbW9vdih0cmFja3MpIHtcbiAgICBsZXQgaSA9IHRyYWNrcy5sZW5ndGg7XG4gICAgY29uc3QgYm94ZXMgPSBbXTtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBib3hlc1tpXSA9IE1QNC50cmFrKHRyYWNrc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBNUDQuYm94LmFwcGx5KG51bGwsIFtNUDQudHlwZXMubW9vdiwgTVA0Lm12aGQodHJhY2tzWzBdLnRpbWVzY2FsZSB8fCAwLCB0cmFja3NbMF0uZHVyYXRpb24gfHwgMCldLmNvbmNhdChib3hlcykuY29uY2F0KE1QNC5tdmV4KHRyYWNrcykpKTtcbiAgfVxuICBzdGF0aWMgbXZleCh0cmFja3MpIHtcbiAgICBsZXQgaSA9IHRyYWNrcy5sZW5ndGg7XG4gICAgY29uc3QgYm94ZXMgPSBbXTtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBib3hlc1tpXSA9IE1QNC50cmV4KHRyYWNrc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBNUDQuYm94LmFwcGx5KG51bGwsIFtNUDQudHlwZXMubXZleCwgLi4uYm94ZXNdKTtcbiAgfVxuICBzdGF0aWMgbXZoZCh0aW1lc2NhbGUsIGR1cmF0aW9uKSB7XG4gICAgZHVyYXRpb24gKj0gdGltZXNjYWxlO1xuICAgIGNvbnN0IHVwcGVyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAvIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIGNvbnN0IGxvd2VyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAlIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDEsXG4gICAgLy8gdmVyc2lvbiAxXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDIsXG4gICAgLy8gY3JlYXRpb25fdGltZVxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDMsXG4gICAgLy8gbW9kaWZpY2F0aW9uX3RpbWVcbiAgICB0aW1lc2NhbGUgPj4gMjQgJiAweGZmLCB0aW1lc2NhbGUgPj4gMTYgJiAweGZmLCB0aW1lc2NhbGUgPj4gOCAmIDB4ZmYsIHRpbWVzY2FsZSAmIDB4ZmYsXG4gICAgLy8gdGltZXNjYWxlXG4gICAgdXBwZXJXb3JkRHVyYXRpb24gPj4gMjQsIHVwcGVyV29yZER1cmF0aW9uID4+IDE2ICYgMHhmZiwgdXBwZXJXb3JkRHVyYXRpb24gPj4gOCAmIDB4ZmYsIHVwcGVyV29yZER1cmF0aW9uICYgMHhmZiwgbG93ZXJXb3JkRHVyYXRpb24gPj4gMjQsIGxvd2VyV29yZER1cmF0aW9uID4+IDE2ICYgMHhmZiwgbG93ZXJXb3JkRHVyYXRpb24gPj4gOCAmIDB4ZmYsIGxvd2VyV29yZER1cmF0aW9uICYgMHhmZiwgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCxcbiAgICAvLyAxLjAgcmF0ZVxuICAgIDB4MDEsIDB4MDAsXG4gICAgLy8gMS4wIHZvbHVtZVxuICAgIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4NDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gdHJhbnNmb3JtYXRpb246IHVuaXR5IG1hdHJpeFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcHJlX2RlZmluZWRcbiAgICAweGZmLCAweGZmLCAweGZmLCAweGZmIC8vIG5leHRfdHJhY2tfSURcbiAgICBdKTtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubXZoZCwgYnl0ZXMpO1xuICB9XG4gIHN0YXRpYyBzZHRwKHRyYWNrKSB7XG4gICAgY29uc3Qgc2FtcGxlcyA9IHRyYWNrLnNhbXBsZXMgfHwgW107XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheSg0ICsgc2FtcGxlcy5sZW5ndGgpO1xuICAgIGxldCBpO1xuICAgIGxldCBmbGFncztcbiAgICAvLyBsZWF2ZSB0aGUgZnVsbCBib3ggaGVhZGVyICg0IGJ5dGVzKSBhbGwgemVyb1xuICAgIC8vIHdyaXRlIHRoZSBzYW1wbGUgdGFibGVcbiAgICBmb3IgKGkgPSAwOyBpIDwgc2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgZmxhZ3MgPSBzYW1wbGVzW2ldLmZsYWdzO1xuICAgICAgYnl0ZXNbaSArIDRdID0gZmxhZ3MuZGVwZW5kc09uIDw8IDQgfCBmbGFncy5pc0RlcGVuZGVkT24gPDwgMiB8IGZsYWdzLmhhc1JlZHVuZGFuY3k7XG4gICAgfVxuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zZHRwLCBieXRlcyk7XG4gIH1cbiAgc3RhdGljIHN0YmwodHJhY2spIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RibCwgTVA0LnN0c2QodHJhY2spLCBNUDQuYm94KE1QNC50eXBlcy5zdHRzLCBNUDQuU1RUUyksIE1QNC5ib3goTVA0LnR5cGVzLnN0c2MsIE1QNC5TVFNDKSwgTVA0LmJveChNUDQudHlwZXMuc3RzeiwgTVA0LlNUU1opLCBNUDQuYm94KE1QNC50eXBlcy5zdGNvLCBNUDQuU1RDTykpO1xuICB9XG4gIHN0YXRpYyBhdmMxKHRyYWNrKSB7XG4gICAgbGV0IHNwcyA9IFtdO1xuICAgIGxldCBwcHMgPSBbXTtcbiAgICBsZXQgaTtcbiAgICBsZXQgZGF0YTtcbiAgICBsZXQgbGVuO1xuICAgIC8vIGFzc2VtYmxlIHRoZSBTUFNzXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdHJhY2suc3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkYXRhID0gdHJhY2suc3BzW2ldO1xuICAgICAgbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgc3BzLnB1c2gobGVuID4+PiA4ICYgMHhmZik7XG4gICAgICBzcHMucHVzaChsZW4gJiAweGZmKTtcblxuICAgICAgLy8gU1BTXG4gICAgICBzcHMgPSBzcHMuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRhdGEpKTtcbiAgICB9XG5cbiAgICAvLyBhc3NlbWJsZSB0aGUgUFBTc1xuICAgIGZvciAoaSA9IDA7IGkgPCB0cmFjay5wcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGEgPSB0cmFjay5wcHNbaV07XG4gICAgICBsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICBwcHMucHVzaChsZW4gPj4+IDggJiAweGZmKTtcbiAgICAgIHBwcy5wdXNoKGxlbiAmIDB4ZmYpO1xuICAgICAgcHBzID0gcHBzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGF2Y2MgPSBNUDQuYm94KE1QNC50eXBlcy5hdmNDLCBuZXcgVWludDhBcnJheShbMHgwMSxcbiAgICAvLyB2ZXJzaW9uXG4gICAgc3BzWzNdLFxuICAgIC8vIHByb2ZpbGVcbiAgICBzcHNbNF0sXG4gICAgLy8gcHJvZmlsZSBjb21wYXRcbiAgICBzcHNbNV0sXG4gICAgLy8gbGV2ZWxcbiAgICAweGZjIHwgMyxcbiAgICAvLyBsZW5ndGhTaXplTWludXNPbmUsIGhhcmQtY29kZWQgdG8gNCBieXRlc1xuICAgIDB4ZTAgfCB0cmFjay5zcHMubGVuZ3RoIC8vIDNiaXQgcmVzZXJ2ZWQgKDExMSkgKyBudW1PZlNlcXVlbmNlUGFyYW1ldGVyU2V0c1xuICAgIF0uY29uY2F0KHNwcykuY29uY2F0KFt0cmFjay5wcHMubGVuZ3RoIC8vIG51bU9mUGljdHVyZVBhcmFtZXRlclNldHNcbiAgICBdKS5jb25jYXQocHBzKSkpOyAvLyBcIlBQU1wiXG4gICAgY29uc3Qgd2lkdGggPSB0cmFjay53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSB0cmFjay5oZWlnaHQ7XG4gICAgY29uc3QgaFNwYWNpbmcgPSB0cmFjay5waXhlbFJhdGlvWzBdO1xuICAgIGNvbnN0IHZTcGFjaW5nID0gdHJhY2sucGl4ZWxSYXRpb1sxXTtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuYXZjMSwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMSxcbiAgICAvLyBkYXRhX3JlZmVyZW5jZV9pbmRleFxuICAgIDB4MDAsIDB4MDAsXG4gICAgLy8gcHJlX2RlZmluZWRcbiAgICAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBwcmVfZGVmaW5lZFxuICAgIHdpZHRoID4+IDggJiAweGZmLCB3aWR0aCAmIDB4ZmYsXG4gICAgLy8gd2lkdGhcbiAgICBoZWlnaHQgPj4gOCAmIDB4ZmYsIGhlaWdodCAmIDB4ZmYsXG4gICAgLy8gaGVpZ2h0XG4gICAgMHgwMCwgMHg0OCwgMHgwMCwgMHgwMCxcbiAgICAvLyBob3JpenJlc29sdXRpb25cbiAgICAweDAwLCAweDQ4LCAweDAwLCAweDAwLFxuICAgIC8vIHZlcnRyZXNvbHV0aW9uXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDEsXG4gICAgLy8gZnJhbWVfY291bnRcbiAgICAweDEyLCAweDY0LCAweDYxLCAweDY5LCAweDZjLFxuICAgIC8vIGRhaWx5bW90aW9uL2hscy5qc1xuICAgIDB4NzksIDB4NmQsIDB4NmYsIDB4NzQsIDB4NjksIDB4NmYsIDB4NmUsIDB4MmYsIDB4NjgsIDB4NmMsIDB4NzMsIDB4MmUsIDB4NmEsIDB4NzMsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gY29tcHJlc3Nvcm5hbWVcbiAgICAweDAwLCAweDE4LFxuICAgIC8vIGRlcHRoID0gMjRcbiAgICAweDExLCAweDExXSksXG4gICAgLy8gcHJlX2RlZmluZWQgPSAtMVxuICAgIGF2Y2MsIE1QNC5ib3goTVA0LnR5cGVzLmJ0cnQsIG5ldyBVaW50OEFycmF5KFsweDAwLCAweDFjLCAweDljLCAweDgwLFxuICAgIC8vIGJ1ZmZlclNpemVEQlxuICAgIDB4MDAsIDB4MmQsIDB4YzYsIDB4YzAsXG4gICAgLy8gbWF4Qml0cmF0ZVxuICAgIDB4MDAsIDB4MmQsIDB4YzYsIDB4YzBdKSksXG4gICAgLy8gYXZnQml0cmF0ZVxuICAgIE1QNC5ib3goTVA0LnR5cGVzLnBhc3AsIG5ldyBVaW50OEFycmF5KFtoU3BhY2luZyA+PiAyNCxcbiAgICAvLyBoU3BhY2luZ1xuICAgIGhTcGFjaW5nID4+IDE2ICYgMHhmZiwgaFNwYWNpbmcgPj4gOCAmIDB4ZmYsIGhTcGFjaW5nICYgMHhmZiwgdlNwYWNpbmcgPj4gMjQsXG4gICAgLy8gdlNwYWNpbmdcbiAgICB2U3BhY2luZyA+PiAxNiAmIDB4ZmYsIHZTcGFjaW5nID4+IDggJiAweGZmLCB2U3BhY2luZyAmIDB4ZmZdKSkpO1xuICB9XG4gIHN0YXRpYyBlc2RzKHRyYWNrKSB7XG4gICAgY29uc3QgY29uZmlnID0gdHJhY2suY29uZmlnO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCxcbiAgICAvLyB2ZXJzaW9uIDBcbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIGZsYWdzXG5cbiAgICAweDAzLFxuICAgIC8vIGRlc2NyaXB0b3JfdHlwZVxuICAgIDB4MTksXG4gICAgLy8gbGVuZ3RoXG5cbiAgICAweDAwLCAweDAxLFxuICAgIC8vIGVzX2lkXG5cbiAgICAweDAwLFxuICAgIC8vIHN0cmVhbV9wcmlvcml0eVxuXG4gICAgMHgwNCxcbiAgICAvLyBkZXNjcmlwdG9yX3R5cGVcbiAgICAweDExLFxuICAgIC8vIGxlbmd0aFxuICAgIDB4NDAsXG4gICAgLy8gY29kZWMgOiBtcGVnNF9hdWRpb1xuICAgIDB4MTUsXG4gICAgLy8gc3RyZWFtX3R5cGVcbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIGJ1ZmZlcl9zaXplXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBtYXhCaXRyYXRlXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBhdmdCaXRyYXRlXG5cbiAgICAweDA1LFxuICAgIC8vIGRlc2NyaXB0b3JfdHlwZVxuICAgIDB4MDIsXG4gICAgLy8gbGVuZ3RoXG4gICAgLi4uY29uZmlnLCAweDA2LCAweDAxLCAweDAyIC8vIEdBU3BlY2lmaWNDb25maWcpKTsgLy8gbGVuZ3RoICsgYXVkaW8gY29uZmlnIGRlc2NyaXB0b3JcbiAgICBdKTtcbiAgfVxuICBzdGF0aWMgYXVkaW9TdHNkKHRyYWNrKSB7XG4gICAgY29uc3Qgc2FtcGxlcmF0ZSA9IHRyYWNrLnNhbXBsZXJhdGUgfHwgMDtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMSxcbiAgICAvLyBkYXRhX3JlZmVyZW5jZV9pbmRleFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCB0cmFjay5jaGFubmVsQ291bnQgfHwgMCxcbiAgICAvLyBjaGFubmVsY291bnRcbiAgICAweDAwLCAweDEwLFxuICAgIC8vIHNhbXBsZVNpemU6MTZiaXRzXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZDJcbiAgICBzYW1wbGVyYXRlID4+IDggJiAweGZmLCBzYW1wbGVyYXRlICYgMHhmZixcbiAgICAvL1xuICAgIDB4MDAsIDB4MDBdKTtcbiAgfVxuICBzdGF0aWMgbXA0YSh0cmFjaykge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tcDRhLCBNUDQuYXVkaW9TdHNkKHRyYWNrKSwgTVA0LmJveChNUDQudHlwZXMuZXNkcywgTVA0LmVzZHModHJhY2spKSk7XG4gIH1cbiAgc3RhdGljIG1wMyh0cmFjaykge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlc1snLm1wMyddLCBNUDQuYXVkaW9TdHNkKHRyYWNrKSk7XG4gIH1cbiAgc3RhdGljIGFjMyh0cmFjaykge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlc1snYWMtMyddLCBNUDQuYXVkaW9TdHNkKHRyYWNrKSwgTVA0LmJveChNUDQudHlwZXMuZGFjMywgdHJhY2suY29uZmlnKSk7XG4gIH1cbiAgc3RhdGljIHN0c2QodHJhY2spIHtcbiAgICBjb25zdCB7XG4gICAgICBzZWdtZW50Q29kZWNcbiAgICB9ID0gdHJhY2s7XG4gICAgaWYgKHRyYWNrLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgIGlmIChzZWdtZW50Q29kZWMgPT09ICdhYWMnKSB7XG4gICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdHNkLCBNUDQuU1RTRCwgTVA0Lm1wNGEodHJhY2spKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWdtZW50Q29kZWMgPT09ICdhYzMnICYmIHRyYWNrLmNvbmZpZykge1xuICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RzZCwgTVA0LlNUU0QsIE1QNC5hYzModHJhY2spKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWdtZW50Q29kZWMgPT09ICdtcDMnICYmIHRyYWNrLmNvZGVjID09PSAnbXAzJykge1xuICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RzZCwgTVA0LlNUU0QsIE1QNC5tcDModHJhY2spKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRyYWNrLnBwcyAmJiB0cmFjay5zcHMpIHtcbiAgICAgICAgaWYgKHNlZ21lbnRDb2RlYyA9PT0gJ2F2YycpIHtcbiAgICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RzZCwgTVA0LlNUU0QsIE1QNC5hdmMxKHRyYWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlZ21lbnRDb2RlYyA9PT0gJ2hldmMnICYmIHRyYWNrLnZwcykge1xuICAgICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdHNkLCBNUDQuU1RTRCwgTVA0Lmh2YzEodHJhY2spKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB2aWRlbyB0cmFjayBtaXNzaW5nIHBwcyBvciBzcHNgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCAke3RyYWNrLnR5cGV9IHNlZ21lbnQgY29kZWMgKCR7c2VnbWVudENvZGVjfS8ke3RyYWNrLmNvZGVjfSlgKTtcbiAgfVxuICBzdGF0aWMgdGtoZCh0cmFjaykge1xuICAgIGNvbnN0IGlkID0gdHJhY2suaWQ7XG4gICAgY29uc3QgZHVyYXRpb24gPSAodHJhY2suZHVyYXRpb24gfHwgMCkgKiAodHJhY2sudGltZXNjYWxlIHx8IDApO1xuICAgIGNvbnN0IHdpZHRoID0gdHJhY2sud2lkdGggfHwgMDtcbiAgICBjb25zdCBoZWlnaHQgPSB0cmFjay5oZWlnaHQgfHwgMDtcbiAgICBjb25zdCB1cHBlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gLyAoVUlOVDMyX01BWCArIDEpKTtcbiAgICBjb25zdCBsb3dlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gJSAoVUlOVDMyX01BWCArIDEpKTtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudGtoZCwgbmV3IFVpbnQ4QXJyYXkoWzB4MDEsXG4gICAgLy8gdmVyc2lvbiAxXG4gICAgMHgwMCwgMHgwMCwgMHgwNyxcbiAgICAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDIsXG4gICAgLy8gY3JlYXRpb25fdGltZVxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDMsXG4gICAgLy8gbW9kaWZpY2F0aW9uX3RpbWVcbiAgICBpZCA+PiAyNCAmIDB4ZmYsIGlkID4+IDE2ICYgMHhmZiwgaWQgPj4gOCAmIDB4ZmYsIGlkICYgMHhmZixcbiAgICAvLyB0cmFja19JRFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICB1cHBlcldvcmREdXJhdGlvbiA+PiAyNCwgdXBwZXJXb3JkRHVyYXRpb24gPj4gMTYgJiAweGZmLCB1cHBlcldvcmREdXJhdGlvbiA+PiA4ICYgMHhmZiwgdXBwZXJXb3JkRHVyYXRpb24gJiAweGZmLCBsb3dlcldvcmREdXJhdGlvbiA+PiAyNCwgbG93ZXJXb3JkRHVyYXRpb24gPj4gMTYgJiAweGZmLCBsb3dlcldvcmREdXJhdGlvbiA+PiA4ICYgMHhmZiwgbG93ZXJXb3JkRHVyYXRpb24gJiAweGZmLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCxcbiAgICAvLyBsYXllclxuICAgIDB4MDAsIDB4MDAsXG4gICAgLy8gYWx0ZXJuYXRlX2dyb3VwXG4gICAgMHgwMCwgMHgwMCxcbiAgICAvLyBub24tYXVkaW8gdHJhY2sgdm9sdW1lXG4gICAgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4NDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gdHJhbnNmb3JtYXRpb246IHVuaXR5IG1hdHJpeFxuICAgIHdpZHRoID4+IDggJiAweGZmLCB3aWR0aCAmIDB4ZmYsIDB4MDAsIDB4MDAsXG4gICAgLy8gd2lkdGhcbiAgICBoZWlnaHQgPj4gOCAmIDB4ZmYsIGhlaWdodCAmIDB4ZmYsIDB4MDAsIDB4MDAgLy8gaGVpZ2h0XG4gICAgXSkpO1xuICB9XG4gIHN0YXRpYyB0cmFmKHRyYWNrLCBiYXNlTWVkaWFEZWNvZGVUaW1lKSB7XG4gICAgY29uc3Qgc2FtcGxlRGVwZW5kZW5jeVRhYmxlID0gTVA0LnNkdHAodHJhY2spO1xuICAgIGNvbnN0IGlkID0gdHJhY2suaWQ7XG4gICAgY29uc3QgdXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA9IE1hdGguZmxvb3IoYmFzZU1lZGlhRGVjb2RlVGltZSAvIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIGNvbnN0IGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPSBNYXRoLmZsb29yKGJhc2VNZWRpYURlY29kZVRpbWUgJSAoVUlOVDMyX01BWCArIDEpKTtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJhZiwgTVA0LmJveChNUDQudHlwZXMudGZoZCwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgLy8gdmVyc2lvbiAwXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIGlkID4+IDI0LCBpZCA+PiAxNiAmIDB4ZmYsIGlkID4+IDggJiAweGZmLCBpZCAmIDB4ZmYgLy8gdHJhY2tfSURcbiAgICBdKSksIE1QNC5ib3goTVA0LnR5cGVzLnRmZHQsIG5ldyBVaW50OEFycmF5KFsweDAxLFxuICAgIC8vIHZlcnNpb24gMVxuICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gZmxhZ3NcbiAgICB1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDI0LCB1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDE2ICYgMHhmZiwgdXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiA4ICYgMHhmZiwgdXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSAmIDB4ZmYsIGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gMjQsIGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gMTYgJiAweGZmLCBsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDggJiAweGZmLCBsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lICYgMHhmZl0pKSwgTVA0LnRydW4odHJhY2ssIHNhbXBsZURlcGVuZGVuY3lUYWJsZS5sZW5ndGggKyAxNiArXG4gICAgLy8gdGZoZFxuICAgIDIwICtcbiAgICAvLyB0ZmR0XG4gICAgOCArXG4gICAgLy8gdHJhZiBoZWFkZXJcbiAgICAxNiArXG4gICAgLy8gbWZoZFxuICAgIDggK1xuICAgIC8vIG1vb2YgaGVhZGVyXG4gICAgOCksXG4gICAgLy8gbWRhdCBoZWFkZXJcbiAgICBzYW1wbGVEZXBlbmRlbmN5VGFibGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhY2sgYm94LlxuICAgKiBAcGFyYW0gdHJhY2sgYSB0cmFjayBkZWZpbml0aW9uXG4gICAqL1xuICBzdGF0aWMgdHJhayh0cmFjaykge1xuICAgIHRyYWNrLmR1cmF0aW9uID0gdHJhY2suZHVyYXRpb24gfHwgMHhmZmZmZmZmZjtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJhaywgTVA0LnRraGQodHJhY2spLCBNUDQubWRpYSh0cmFjaykpO1xuICB9XG4gIHN0YXRpYyB0cmV4KHRyYWNrKSB7XG4gICAgY29uc3QgaWQgPSB0cmFjay5pZDtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJleCwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgLy8gdmVyc2lvbiAwXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIGlkID4+IDI0LCBpZCA+PiAxNiAmIDB4ZmYsIGlkID4+IDggJiAweGZmLCBpZCAmIDB4ZmYsXG4gICAgLy8gdHJhY2tfSURcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAxLFxuICAgIC8vIGRlZmF1bHRfc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4XG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBkZWZhdWx0X3NhbXBsZV9kdXJhdGlvblxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gZGVmYXVsdF9zYW1wbGVfc2l6ZVxuICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDEgLy8gZGVmYXVsdF9zYW1wbGVfZmxhZ3NcbiAgICBdKSk7XG4gIH1cbiAgc3RhdGljIHRydW4odHJhY2ssIG9mZnNldCkge1xuICAgIGNvbnN0IHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzIHx8IFtdO1xuICAgIGNvbnN0IGxlbiA9IHNhbXBsZXMubGVuZ3RoO1xuICAgIGNvbnN0IGFycmF5bGVuID0gMTIgKyAxNiAqIGxlbjtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5bGVuKTtcbiAgICBsZXQgaTtcbiAgICBsZXQgc2FtcGxlO1xuICAgIGxldCBkdXJhdGlvbjtcbiAgICBsZXQgc2l6ZTtcbiAgICBsZXQgZmxhZ3M7XG4gICAgbGV0IGN0cztcbiAgICBvZmZzZXQgKz0gOCArIGFycmF5bGVuO1xuICAgIGFycmF5LnNldChbdHJhY2sudHlwZSA9PT0gJ3ZpZGVvJyA/IDB4MDEgOiAweDAwLFxuICAgIC8vIHZlcnNpb24gMSBmb3IgdmlkZW8gd2l0aCBzaWduZWQtaW50IHNhbXBsZV9jb21wb3NpdGlvbl90aW1lX29mZnNldFxuICAgIDB4MDAsIDB4MGYsIDB4MDEsXG4gICAgLy8gZmxhZ3NcbiAgICBsZW4gPj4+IDI0ICYgMHhmZiwgbGVuID4+PiAxNiAmIDB4ZmYsIGxlbiA+Pj4gOCAmIDB4ZmYsIGxlbiAmIDB4ZmYsXG4gICAgLy8gc2FtcGxlX2NvdW50XG4gICAgb2Zmc2V0ID4+PiAyNCAmIDB4ZmYsIG9mZnNldCA+Pj4gMTYgJiAweGZmLCBvZmZzZXQgPj4+IDggJiAweGZmLCBvZmZzZXQgJiAweGZmIC8vIGRhdGFfb2Zmc2V0XG4gICAgXSwgMCk7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBzYW1wbGUgPSBzYW1wbGVzW2ldO1xuICAgICAgZHVyYXRpb24gPSBzYW1wbGUuZHVyYXRpb247XG4gICAgICBzaXplID0gc2FtcGxlLnNpemU7XG4gICAgICBmbGFncyA9IHNhbXBsZS5mbGFncztcbiAgICAgIGN0cyA9IHNhbXBsZS5jdHM7XG4gICAgICBhcnJheS5zZXQoW2R1cmF0aW9uID4+PiAyNCAmIDB4ZmYsIGR1cmF0aW9uID4+PiAxNiAmIDB4ZmYsIGR1cmF0aW9uID4+PiA4ICYgMHhmZiwgZHVyYXRpb24gJiAweGZmLFxuICAgICAgLy8gc2FtcGxlX2R1cmF0aW9uXG4gICAgICBzaXplID4+PiAyNCAmIDB4ZmYsIHNpemUgPj4+IDE2ICYgMHhmZiwgc2l6ZSA+Pj4gOCAmIDB4ZmYsIHNpemUgJiAweGZmLFxuICAgICAgLy8gc2FtcGxlX3NpemVcbiAgICAgIGZsYWdzLmlzTGVhZGluZyA8PCAyIHwgZmxhZ3MuZGVwZW5kc09uLCBmbGFncy5pc0RlcGVuZGVkT24gPDwgNiB8IGZsYWdzLmhhc1JlZHVuZGFuY3kgPDwgNCB8IGZsYWdzLnBhZGRpbmdWYWx1ZSA8PCAxIHwgZmxhZ3MuaXNOb25TeW5jLCBmbGFncy5kZWdyYWRQcmlvICYgMHhmMCA8PCA4LCBmbGFncy5kZWdyYWRQcmlvICYgMHgwZixcbiAgICAgIC8vIHNhbXBsZV9mbGFnc1xuICAgICAgY3RzID4+PiAyNCAmIDB4ZmYsIGN0cyA+Pj4gMTYgJiAweGZmLCBjdHMgPj4+IDggJiAweGZmLCBjdHMgJiAweGZmIC8vIHNhbXBsZV9jb21wb3NpdGlvbl90aW1lX29mZnNldFxuICAgICAgXSwgMTIgKyAxNiAqIGkpO1xuICAgIH1cbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJ1biwgYXJyYXkpO1xuICB9XG4gIHN0YXRpYyBpbml0U2VnbWVudCh0cmFja3MpIHtcbiAgICBpZiAoIU1QNC50eXBlcykge1xuICAgICAgTVA0LmluaXQoKTtcbiAgICB9XG4gICAgY29uc3QgbW92aWUgPSBNUDQubW9vdih0cmFja3MpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGFwcGVuZFVpbnQ4QXJyYXkoTVA0LkZUWVAsIG1vdmllKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHN0YXRpYyBodmMxKHRyYWNrKSB7XG4gICAgY29uc3QgcHMgPSB0cmFjay5wYXJhbXM7XG4gICAgY29uc3QgdW5pdHMgPSBbdHJhY2sudnBzLCB0cmFjay5zcHMsIHRyYWNrLnBwc107XG4gICAgY29uc3QgTkFMdUxlbmd0aFNpemUgPSA0O1xuICAgIGNvbnN0IGNvbmZpZyA9IG5ldyBVaW50OEFycmF5KFsweDAxLCBwcy5nZW5lcmFsX3Byb2ZpbGVfc3BhY2UgPDwgNiB8IChwcy5nZW5lcmFsX3RpZXJfZmxhZyA/IDMyIDogMCkgfCBwcy5nZW5lcmFsX3Byb2ZpbGVfaWRjLCBwcy5nZW5lcmFsX3Byb2ZpbGVfY29tcGF0aWJpbGl0eV9mbGFnc1swXSwgcHMuZ2VuZXJhbF9wcm9maWxlX2NvbXBhdGliaWxpdHlfZmxhZ3NbMV0sIHBzLmdlbmVyYWxfcHJvZmlsZV9jb21wYXRpYmlsaXR5X2ZsYWdzWzJdLCBwcy5nZW5lcmFsX3Byb2ZpbGVfY29tcGF0aWJpbGl0eV9mbGFnc1szXSwgcHMuZ2VuZXJhbF9jb25zdHJhaW50X2luZGljYXRvcl9mbGFnc1swXSwgcHMuZ2VuZXJhbF9jb25zdHJhaW50X2luZGljYXRvcl9mbGFnc1sxXSwgcHMuZ2VuZXJhbF9jb25zdHJhaW50X2luZGljYXRvcl9mbGFnc1syXSwgcHMuZ2VuZXJhbF9jb25zdHJhaW50X2luZGljYXRvcl9mbGFnc1szXSwgcHMuZ2VuZXJhbF9jb25zdHJhaW50X2luZGljYXRvcl9mbGFnc1s0XSwgcHMuZ2VuZXJhbF9jb25zdHJhaW50X2luZGljYXRvcl9mbGFnc1s1XSwgcHMuZ2VuZXJhbF9sZXZlbF9pZGMsIDI0MCB8IHBzLm1pbl9zcGF0aWFsX3NlZ21lbnRhdGlvbl9pZGMgPj4gOCwgMjU1ICYgcHMubWluX3NwYXRpYWxfc2VnbWVudGF0aW9uX2lkYywgMjUyIHwgcHMucGFyYWxsZWxpc21UeXBlLCAyNTIgfCBwcy5jaHJvbWFfZm9ybWF0X2lkYywgMjQ4IHwgcHMuYml0X2RlcHRoX2x1bWFfbWludXM4LCAyNDggfCBwcy5iaXRfZGVwdGhfY2hyb21hX21pbnVzOCwgMHgwMCwgcGFyc2VJbnQocHMuZnJhbWVfcmF0ZS5mcHMpLCBOQUx1TGVuZ3RoU2l6ZSAtIDEgfCBwcy50ZW1wb3JhbF9pZF9uZXN0ZWQgPDwgMiB8IHBzLm51bV90ZW1wb3JhbF9sYXllcnMgPDwgMyB8IChwcy5mcmFtZV9yYXRlLmZpeGVkID8gNjQgOiAwKSwgdW5pdHMubGVuZ3RoXSk7XG5cbiAgICAvLyBjb21wdXRlIGh2Y0Mgc2l6ZSBpbiBieXRlc1xuICAgIGxldCBsZW5ndGggPSBjb25maWcubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdW5pdHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGxlbmd0aCArPSAzO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB1bml0c1tpXS5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICBsZW5ndGggKz0gMiArIHVuaXRzW2ldW2pdLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaHZjQyA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgaHZjQy5zZXQoY29uZmlnLCAwKTtcbiAgICBsZW5ndGggPSBjb25maWcubGVuZ3RoO1xuICAgIC8vIGFwcGVuZCBwYXJhbWV0ZXIgc2V0IHVuaXRzOiBvbmUgdnBzLCBvbmUgb3IgbW9yZSBzcHMgYW5kIHBwc1xuICAgIGNvbnN0IGlNYXggPSB1bml0cy5sZW5ndGggLSAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdW5pdHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGh2Y0Muc2V0KG5ldyBVaW50OEFycmF5KFszMiArIGkgfCAoaSA9PT0gaU1heCA/IDEyOCA6IDApLCAweDAwLCB1bml0c1tpXS5sZW5ndGhdKSwgbGVuZ3RoKTtcbiAgICAgIGxlbmd0aCArPSAzO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB1bml0c1tpXS5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICBodmNDLnNldChuZXcgVWludDhBcnJheShbdW5pdHNbaV1bal0ubGVuZ3RoID4+IDgsIHVuaXRzW2ldW2pdLmxlbmd0aCAmIDI1NV0pLCBsZW5ndGgpO1xuICAgICAgICBsZW5ndGggKz0gMjtcbiAgICAgICAgaHZjQy5zZXQodW5pdHNbaV1bal0sIGxlbmd0aCk7XG4gICAgICAgIGxlbmd0aCArPSB1bml0c1tpXVtqXS5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGh2Y2MgPSBNUDQuYm94KE1QNC50eXBlcy5odmNDLCBodmNDKTtcbiAgICBjb25zdCB3aWR0aCA9IHRyYWNrLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHRyYWNrLmhlaWdodDtcbiAgICBjb25zdCBoU3BhY2luZyA9IHRyYWNrLnBpeGVsUmF0aW9bMF07XG4gICAgY29uc3QgdlNwYWNpbmcgPSB0cmFjay5waXhlbFJhdGlvWzFdO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5odmMxLCBuZXcgVWludDhBcnJheShbMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAxLFxuICAgIC8vIGRhdGFfcmVmZXJlbmNlX2luZGV4XG4gICAgMHgwMCwgMHgwMCxcbiAgICAvLyBwcmVfZGVmaW5lZFxuICAgIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHByZV9kZWZpbmVkXG4gICAgd2lkdGggPj4gOCAmIDB4ZmYsIHdpZHRoICYgMHhmZixcbiAgICAvLyB3aWR0aFxuICAgIGhlaWdodCA+PiA4ICYgMHhmZiwgaGVpZ2h0ICYgMHhmZixcbiAgICAvLyBoZWlnaHRcbiAgICAweDAwLCAweDQ4LCAweDAwLCAweDAwLFxuICAgIC8vIGhvcml6cmVzb2x1dGlvblxuICAgIDB4MDAsIDB4NDgsIDB4MDAsIDB4MDAsXG4gICAgLy8gdmVydHJlc29sdXRpb25cbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMSxcbiAgICAvLyBmcmFtZV9jb3VudFxuICAgIDB4MTIsIDB4NjQsIDB4NjEsIDB4NjksIDB4NmMsXG4gICAgLy8gZGFpbHltb3Rpb24vaGxzLmpzXG4gICAgMHg3OSwgMHg2ZCwgMHg2ZiwgMHg3NCwgMHg2OSwgMHg2ZiwgMHg2ZSwgMHgyZiwgMHg2OCwgMHg2YywgMHg3MywgMHgyZSwgMHg2YSwgMHg3MywgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBjb21wcmVzc29ybmFtZVxuICAgIDB4MDAsIDB4MTgsXG4gICAgLy8gZGVwdGggPSAyNFxuICAgIDB4MTEsIDB4MTFdKSxcbiAgICAvLyBwcmVfZGVmaW5lZCA9IC0xXG4gICAgaHZjYywgTVA0LmJveChNUDQudHlwZXMuYnRydCwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4MWMsIDB4OWMsIDB4ODAsXG4gICAgLy8gYnVmZmVyU2l6ZURCXG4gICAgMHgwMCwgMHgyZCwgMHhjNiwgMHhjMCxcbiAgICAvLyBtYXhCaXRyYXRlXG4gICAgMHgwMCwgMHgyZCwgMHhjNiwgMHhjMF0pKSxcbiAgICAvLyBhdmdCaXRyYXRlXG4gICAgTVA0LmJveChNUDQudHlwZXMucGFzcCwgbmV3IFVpbnQ4QXJyYXkoW2hTcGFjaW5nID4+IDI0LFxuICAgIC8vIGhTcGFjaW5nXG4gICAgaFNwYWNpbmcgPj4gMTYgJiAweGZmLCBoU3BhY2luZyA+PiA4ICYgMHhmZiwgaFNwYWNpbmcgJiAweGZmLCB2U3BhY2luZyA+PiAyNCxcbiAgICAvLyB2U3BhY2luZ1xuICAgIHZTcGFjaW5nID4+IDE2ICYgMHhmZiwgdlNwYWNpbmcgPj4gOCAmIDB4ZmYsIHZTcGFjaW5nICYgMHhmZl0pKSk7XG4gIH1cbn1cbk1QNC50eXBlcyA9IHZvaWQgMDtcbk1QNC5IRExSX1RZUEVTID0gdm9pZCAwO1xuTVA0LlNUVFMgPSB2b2lkIDA7XG5NUDQuU1RTQyA9IHZvaWQgMDtcbk1QNC5TVENPID0gdm9pZCAwO1xuTVA0LlNUU1ogPSB2b2lkIDA7XG5NUDQuVk1IRCA9IHZvaWQgMDtcbk1QNC5TTUhEID0gdm9pZCAwO1xuTVA0LlNUU0QgPSB2b2lkIDA7XG5NUDQuRlRZUCA9IHZvaWQgMDtcbk1QNC5ESU5GID0gdm9pZCAwO1xuXG5jb25zdCBNUEVHX1RTX0NMT0NLX0ZSRVFfSFogPSA5MDAwMDtcbmZ1bmN0aW9uIHRvVGltZXNjYWxlRnJvbUJhc2UoYmFzZVRpbWUsIGRlc3RTY2FsZSwgc3JjQmFzZSA9IDEsIHJvdW5kID0gZmFsc2UpIHtcbiAgY29uc3QgcmVzdWx0ID0gYmFzZVRpbWUgKiBkZXN0U2NhbGUgKiBzcmNCYXNlOyAvLyBlcXVpdmFsZW50IHRvIGAodmFsdWUgKiBzY2FsZSkgLyAoMSAvIGJhc2UpYFxuICByZXR1cm4gcm91bmQgPyBNYXRoLnJvdW5kKHJlc3VsdCkgOiByZXN1bHQ7XG59XG5mdW5jdGlvbiB0b1RpbWVzY2FsZUZyb21TY2FsZShiYXNlVGltZSwgZGVzdFNjYWxlLCBzcmNTY2FsZSA9IDEsIHJvdW5kID0gZmFsc2UpIHtcbiAgcmV0dXJuIHRvVGltZXNjYWxlRnJvbUJhc2UoYmFzZVRpbWUsIGRlc3RTY2FsZSwgMSAvIHNyY1NjYWxlLCByb3VuZCk7XG59XG5mdW5jdGlvbiB0b01zRnJvbU1wZWdUc0Nsb2NrKGJhc2VUaW1lLCByb3VuZCA9IGZhbHNlKSB7XG4gIHJldHVybiB0b1RpbWVzY2FsZUZyb21CYXNlKGJhc2VUaW1lLCAxMDAwLCAxIC8gTVBFR19UU19DTE9DS19GUkVRX0haLCByb3VuZCk7XG59XG5mdW5jdGlvbiB0b01wZWdUc0Nsb2NrRnJvbVRpbWVzY2FsZShiYXNlVGltZSwgc3JjU2NhbGUgPSAxKSB7XG4gIHJldHVybiB0b1RpbWVzY2FsZUZyb21CYXNlKGJhc2VUaW1lLCBNUEVHX1RTX0NMT0NLX0ZSRVFfSFosIDEgLyBzcmNTY2FsZSk7XG59XG5cbmNvbnN0IE1BWF9TSUxFTlRfRlJBTUVfRFVSQVRJT04gPSAxMCAqIDEwMDA7IC8vIDEwIHNlY29uZHNcbmNvbnN0IEFBQ19TQU1QTEVTX1BFUl9GUkFNRSA9IDEwMjQ7XG5jb25zdCBNUEVHX0FVRElPX1NBTVBMRV9QRVJfRlJBTUUgPSAxMTUyO1xuY29uc3QgQUMzX1NBTVBMRVNfUEVSX0ZSQU1FID0gMTUzNjtcbmxldCBjaHJvbWVWZXJzaW9uID0gbnVsbDtcbmxldCBzYWZhcmlXZWJraXRWZXJzaW9uID0gbnVsbDtcbmZ1bmN0aW9uIGNyZWF0ZU1wNFNhbXBsZShpc0tleWZyYW1lLCBkdXJhdGlvbiwgc2l6ZSwgY3RzKSB7XG4gIHJldHVybiB7XG4gICAgZHVyYXRpb24sXG4gICAgc2l6ZSxcbiAgICBjdHMsXG4gICAgZmxhZ3M6IHtcbiAgICAgIGlzTGVhZGluZzogMCxcbiAgICAgIGlzRGVwZW5kZWRPbjogMCxcbiAgICAgIGhhc1JlZHVuZGFuY3k6IDAsXG4gICAgICBkZWdyYWRQcmlvOiAwLFxuICAgICAgZGVwZW5kc09uOiBpc0tleWZyYW1lID8gMiA6IDEsXG4gICAgICBpc05vblN5bmM6IGlzS2V5ZnJhbWUgPyAwIDogMVxuICAgIH1cbiAgfTtcbn1cbmNsYXNzIE1QNFJlbXV4ZXIgZXh0ZW5kcyBMb2dnZXIge1xuICBjb25zdHJ1Y3RvcihvYnNlcnZlciwgY29uZmlnLCB0eXBlU3VwcG9ydGVkLCBsb2dnZXIpIHtcbiAgICBzdXBlcignbXA0LXJlbXV4ZXInLCBsb2dnZXIpO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy50eXBlU3VwcG9ydGVkID0gdm9pZCAwO1xuICAgIHRoaXMuSVNHZW5lcmF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9pbml0UFRTID0gbnVsbDtcbiAgICB0aGlzLl9pbml0RFRTID0gbnVsbDtcbiAgICB0aGlzLm5leHRWaWRlb1RzID0gbnVsbDtcbiAgICB0aGlzLm5leHRBdWRpb1RzID0gbnVsbDtcbiAgICB0aGlzLnZpZGVvU2FtcGxlRHVyYXRpb24gPSBudWxsO1xuICAgIHRoaXMuaXNBdWRpb0NvbnRpZ3VvdXMgPSBmYWxzZTtcbiAgICB0aGlzLmlzVmlkZW9Db250aWd1b3VzID0gZmFsc2U7XG4gICAgdGhpcy52aWRlb1RyYWNrQ29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB0eXBlU3VwcG9ydGVkO1xuICAgIHRoaXMuSVNHZW5lcmF0ZWQgPSBmYWxzZTtcbiAgICBpZiAoY2hyb21lVmVyc2lvbiA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJztcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspL2kpO1xuICAgICAgY2hyb21lVmVyc2lvbiA9IHJlc3VsdCA/IHBhcnNlSW50KHJlc3VsdFsxXSkgOiAwO1xuICAgIH1cbiAgICBpZiAoc2FmYXJpV2Via2l0VmVyc2lvbiA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvU2FmYXJpXFwvKFxcZCspL2kpO1xuICAgICAgc2FmYXJpV2Via2l0VmVyc2lvbiA9IHJlc3VsdCA/IHBhcnNlSW50KHJlc3VsdFsxXSkgOiAwO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmNvbmZpZyA9IHRoaXMudmlkZW9UcmFja0NvbmZpZyA9IHRoaXMuX2luaXRQVFMgPSB0aGlzLl9pbml0RFRTID0gbnVsbDtcbiAgfVxuICByZXNldFRpbWVTdGFtcChkZWZhdWx0VGltZVN0YW1wKSB7XG4gICAgdGhpcy5sb2coJ2luaXRQVFMgJiBpbml0RFRTIHJlc2V0Jyk7XG4gICAgdGhpcy5faW5pdFBUUyA9IHRoaXMuX2luaXREVFMgPSBkZWZhdWx0VGltZVN0YW1wO1xuICB9XG4gIHJlc2V0TmV4dFRpbWVzdGFtcCgpIHtcbiAgICB0aGlzLmxvZygncmVzZXQgbmV4dCB0aW1lc3RhbXAnKTtcbiAgICB0aGlzLmlzVmlkZW9Db250aWd1b3VzID0gZmFsc2U7XG4gICAgdGhpcy5pc0F1ZGlvQ29udGlndW91cyA9IGZhbHNlO1xuICB9XG4gIHJlc2V0SW5pdFNlZ21lbnQoKSB7XG4gICAgdGhpcy5sb2coJ0lTR2VuZXJhdGVkIGZsYWcgcmVzZXQnKTtcbiAgICB0aGlzLklTR2VuZXJhdGVkID0gZmFsc2U7XG4gICAgdGhpcy52aWRlb1RyYWNrQ29uZmlnID0gdW5kZWZpbmVkO1xuICB9XG4gIGdldFZpZGVvU3RhcnRQdHModmlkZW9TYW1wbGVzKSB7XG4gICAgLy8gR2V0IHRoZSBtaW5pbXVtIFBUUyB2YWx1ZSByZWxhdGl2ZSB0byB0aGUgZmlyc3Qgc2FtcGxlJ3MgUFRTLCBub3JtYWxpemVkIGZvciAzMy1iaXQgd3JhcHBpbmdcbiAgICBsZXQgcm9sbG92ZXJEZXRlY3RlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGZpcnN0UHRzID0gdmlkZW9TYW1wbGVzWzBdLnB0cztcbiAgICBjb25zdCBzdGFydFBUUyA9IHZpZGVvU2FtcGxlcy5yZWR1Y2UoKG1pblBUUywgc2FtcGxlKSA9PiB7XG4gICAgICBsZXQgcHRzID0gc2FtcGxlLnB0cztcbiAgICAgIGxldCBkZWx0YSA9IHB0cyAtIG1pblBUUztcbiAgICAgIGlmIChkZWx0YSA8IC00Mjk0OTY3Mjk2KSB7XG4gICAgICAgIC8vIDJeMzIsIHNlZSBQVFNOb3JtYWxpemUgZm9yIHJlYXNvbmluZywgYnV0IHdlJ3JlIGhpdHRpbmcgYSByb2xsb3ZlciBoZXJlLCBhbmQgd2UgZG9uJ3Qgd2FudCB0aGF0IHRvIGltcGFjdCB0aGUgdGltZU9mZnNldCBjYWxjdWxhdGlvblxuICAgICAgICByb2xsb3ZlckRldGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgcHRzID0gbm9ybWFsaXplUHRzKHB0cywgZmlyc3RQdHMpO1xuICAgICAgICBkZWx0YSA9IHB0cyAtIG1pblBUUztcbiAgICAgIH1cbiAgICAgIGlmIChkZWx0YSA+IDApIHtcbiAgICAgICAgcmV0dXJuIG1pblBUUztcbiAgICAgIH1cbiAgICAgIHJldHVybiBwdHM7XG4gICAgfSwgZmlyc3RQdHMpO1xuICAgIGlmIChyb2xsb3ZlckRldGVjdGVkKSB7XG4gICAgICB0aGlzLmRlYnVnKCdQVFMgcm9sbG92ZXIgZGV0ZWN0ZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXJ0UFRTO1xuICB9XG4gIHJlbXV4KGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgZmx1c2gsIHBsYXlsaXN0VHlwZSkge1xuICAgIGxldCB2aWRlbztcbiAgICBsZXQgYXVkaW87XG4gICAgbGV0IGluaXRTZWdtZW50O1xuICAgIGxldCB0ZXh0O1xuICAgIGxldCBpZDM7XG4gICAgbGV0IGluZGVwZW5kZW50O1xuICAgIGxldCBhdWRpb1RpbWVPZmZzZXQgPSB0aW1lT2Zmc2V0O1xuICAgIGxldCB2aWRlb1RpbWVPZmZzZXQgPSB0aW1lT2Zmc2V0O1xuXG4gICAgLy8gSWYgd2UncmUgcmVtdXhpbmcgYXVkaW8gYW5kIHZpZGVvIHByb2dyZXNzaXZlbHksIHdhaXQgdW50aWwgd2UndmUgcmVjZWl2ZWQgZW5vdWdoIHNhbXBsZXMgZm9yIGVhY2ggdHJhY2sgYmVmb3JlIHByb2NlZWRpbmcuXG4gICAgLy8gVGhpcyBpcyBkb25lIHRvIHN5bmNocm9uaXplIHRoZSBhdWRpbyBhbmQgdmlkZW8gc3RyZWFtcy4gV2Uga25vdyBpZiB0aGUgY3VycmVudCBzZWdtZW50IHdpbGwgaGF2ZSBzYW1wbGVzIGlmIHRoZSBcInBpZFwiXG4gICAgLy8gcGFyYW1ldGVyIGlzIGdyZWF0ZXIgdGhhbiAtMS4gVGhlIHBpZCBpcyBzZXQgd2hlbiB0aGUgUE1UIGlzIHBhcnNlZCwgd2hpY2ggY29udGFpbnMgdGhlIHRyYWNrcyBsaXN0LlxuICAgIC8vIEhvd2V2ZXIsIGlmIHRoZSBpbml0U2VnbWVudCBoYXMgYWxyZWFkeSBiZWVuIGdlbmVyYXRlZCwgb3Igd2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIGEgc2VnbWVudCAoZmx1c2gpLFxuICAgIC8vIHRoZW4gd2UgY2FuIHJlbXV4IG9uZSB0cmFjayB3aXRob3V0IHdhaXRpbmcgZm9yIHRoZSBvdGhlci5cbiAgICBjb25zdCBoYXNBdWRpbyA9IGF1ZGlvVHJhY2sucGlkID4gLTE7XG4gICAgY29uc3QgaGFzVmlkZW8gPSB2aWRlb1RyYWNrLnBpZCA+IC0xO1xuICAgIGNvbnN0IGxlbmd0aCA9IHZpZGVvVHJhY2suc2FtcGxlcy5sZW5ndGg7XG4gICAgY29uc3QgZW5vdWdoQXVkaW9TYW1wbGVzID0gYXVkaW9UcmFjay5zYW1wbGVzLmxlbmd0aCA+IDA7XG4gICAgY29uc3QgZW5vdWdoVmlkZW9TYW1wbGVzID0gZmx1c2ggJiYgbGVuZ3RoID4gMCB8fCBsZW5ndGggPiAxO1xuICAgIGNvbnN0IGNhblJlbXV4QXZjID0gKCFoYXNBdWRpbyB8fCBlbm91Z2hBdWRpb1NhbXBsZXMpICYmICghaGFzVmlkZW8gfHwgZW5vdWdoVmlkZW9TYW1wbGVzKSB8fCB0aGlzLklTR2VuZXJhdGVkIHx8IGZsdXNoO1xuICAgIGlmIChjYW5SZW11eEF2Yykge1xuICAgICAgaWYgKHRoaXMuSVNHZW5lcmF0ZWQpIHtcbiAgICAgICAgdmFyIF92aWRlb1RyYWNrJHBpeGVsUmF0aSwgX2NvbmZpZyRwaXhlbFJhdGlvLCBfdmlkZW9UcmFjayRwaXhlbFJhdGkyLCBfY29uZmlnJHBpeGVsUmF0aW8yO1xuICAgICAgICBjb25zdCBjb25maWcgPSB0aGlzLnZpZGVvVHJhY2tDb25maWc7XG4gICAgICAgIGlmIChjb25maWcgJiYgKHZpZGVvVHJhY2sud2lkdGggIT09IGNvbmZpZy53aWR0aCB8fCB2aWRlb1RyYWNrLmhlaWdodCAhPT0gY29uZmlnLmhlaWdodCB8fCAoKF92aWRlb1RyYWNrJHBpeGVsUmF0aSA9IHZpZGVvVHJhY2sucGl4ZWxSYXRpbykgPT0gbnVsbCA/IHZvaWQgMCA6IF92aWRlb1RyYWNrJHBpeGVsUmF0aVswXSkgIT09ICgoX2NvbmZpZyRwaXhlbFJhdGlvID0gY29uZmlnLnBpeGVsUmF0aW8pID09IG51bGwgPyB2b2lkIDAgOiBfY29uZmlnJHBpeGVsUmF0aW9bMF0pIHx8ICgoX3ZpZGVvVHJhY2skcGl4ZWxSYXRpMiA9IHZpZGVvVHJhY2sucGl4ZWxSYXRpbykgPT0gbnVsbCA/IHZvaWQgMCA6IF92aWRlb1RyYWNrJHBpeGVsUmF0aTJbMV0pICE9PSAoKF9jb25maWckcGl4ZWxSYXRpbzIgPSBjb25maWcucGl4ZWxSYXRpbykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jb25maWckcGl4ZWxSYXRpbzJbMV0pKSB8fCAhY29uZmlnICYmIGVub3VnaFZpZGVvU2FtcGxlcyB8fCB0aGlzLm5leHRBdWRpb1RzID09PSBudWxsICYmIGVub3VnaEF1ZGlvU2FtcGxlcykge1xuICAgICAgICAgIHRoaXMucmVzZXRJbml0U2VnbWVudCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuSVNHZW5lcmF0ZWQpIHtcbiAgICAgICAgaW5pdFNlZ21lbnQgPSB0aGlzLmdlbmVyYXRlSVMoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzVmlkZW9Db250aWd1b3VzID0gdGhpcy5pc1ZpZGVvQ29udGlndW91cztcbiAgICAgIGxldCBmaXJzdEtleUZyYW1lSW5kZXggPSAtMTtcbiAgICAgIGxldCBmaXJzdEtleUZyYW1lUFRTO1xuICAgICAgaWYgKGVub3VnaFZpZGVvU2FtcGxlcykge1xuICAgICAgICBmaXJzdEtleUZyYW1lSW5kZXggPSBmaW5kS2V5ZnJhbWVJbmRleCh2aWRlb1RyYWNrLnNhbXBsZXMpO1xuICAgICAgICBpZiAoIWlzVmlkZW9Db250aWd1b3VzICYmIHRoaXMuY29uZmlnLmZvcmNlS2V5RnJhbWVPbkRpc2NvbnRpbnVpdHkpIHtcbiAgICAgICAgICBpbmRlcGVuZGVudCA9IHRydWU7XG4gICAgICAgICAgaWYgKGZpcnN0S2V5RnJhbWVJbmRleCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMud2FybihgRHJvcHBlZCAke2ZpcnN0S2V5RnJhbWVJbmRleH0gb3V0IG9mICR7bGVuZ3RofSB2aWRlbyBzYW1wbGVzIGR1ZSB0byBhIG1pc3Npbmcga2V5ZnJhbWVgKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0UFRTID0gdGhpcy5nZXRWaWRlb1N0YXJ0UHRzKHZpZGVvVHJhY2suc2FtcGxlcyk7XG4gICAgICAgICAgICB2aWRlb1RyYWNrLnNhbXBsZXMgPSB2aWRlb1RyYWNrLnNhbXBsZXMuc2xpY2UoZmlyc3RLZXlGcmFtZUluZGV4KTtcbiAgICAgICAgICAgIHZpZGVvVHJhY2suZHJvcHBlZCArPSBmaXJzdEtleUZyYW1lSW5kZXg7XG4gICAgICAgICAgICB2aWRlb1RpbWVPZmZzZXQgKz0gKHZpZGVvVHJhY2suc2FtcGxlc1swXS5wdHMgLSBzdGFydFBUUykgLyB2aWRlb1RyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgICAgICAgICAgZmlyc3RLZXlGcmFtZVBUUyA9IHZpZGVvVGltZU9mZnNldDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZpcnN0S2V5RnJhbWVJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMud2FybihgTm8ga2V5ZnJhbWUgZm91bmQgb3V0IG9mICR7bGVuZ3RofSB2aWRlbyBzYW1wbGVzYCk7XG4gICAgICAgICAgICBpbmRlcGVuZGVudCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuSVNHZW5lcmF0ZWQpIHtcbiAgICAgICAgaWYgKGVub3VnaEF1ZGlvU2FtcGxlcyAmJiBlbm91Z2hWaWRlb1NhbXBsZXMpIHtcbiAgICAgICAgICAvLyB0aW1lT2Zmc2V0IGlzIGV4cGVjdGVkIHRvIGJlIHRoZSBvZmZzZXQgb2YgdGhlIGZpcnN0IHRpbWVzdGFtcCBvZiB0aGlzIGZyYWdtZW50IChmaXJzdCBEVFMpXG4gICAgICAgICAgLy8gaWYgZmlyc3QgYXVkaW8gRFRTIGlzIG5vdCBhbGlnbmVkIHdpdGggZmlyc3QgdmlkZW8gRFRTIHRoZW4gd2UgbmVlZCB0byB0YWtlIHRoYXQgaW50byBhY2NvdW50XG4gICAgICAgICAgLy8gd2hlbiBwcm92aWRpbmcgdGltZU9mZnNldCB0byByZW11eEF1ZGlvIC8gcmVtdXhWaWRlby4gaWYgd2UgZG9uJ3QgZG8gdGhhdCwgdGhlcmUgbWlnaHQgYmUgYSBwZXJtYW5lbnQgLyBzbWFsbFxuICAgICAgICAgIC8vIGRyaWZ0IGJldHdlZW4gYXVkaW8gYW5kIHZpZGVvIHN0cmVhbXNcbiAgICAgICAgICBjb25zdCBzdGFydFBUUyA9IHRoaXMuZ2V0VmlkZW9TdGFydFB0cyh2aWRlb1RyYWNrLnNhbXBsZXMpO1xuICAgICAgICAgIGNvbnN0IHRzRGVsdGEgPSBub3JtYWxpemVQdHMoYXVkaW9UcmFjay5zYW1wbGVzWzBdLnB0cywgc3RhcnRQVFMpIC0gc3RhcnRQVFM7XG4gICAgICAgICAgY29uc3QgYXVkaW92aWRlb1RpbWVzdGFtcERlbHRhID0gdHNEZWx0YSAvIHZpZGVvVHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgICAgICAgYXVkaW9UaW1lT2Zmc2V0ICs9IE1hdGgubWF4KDAsIGF1ZGlvdmlkZW9UaW1lc3RhbXBEZWx0YSk7XG4gICAgICAgICAgdmlkZW9UaW1lT2Zmc2V0ICs9IE1hdGgubWF4KDAsIC1hdWRpb3ZpZGVvVGltZXN0YW1wRGVsdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHVycG9zZWZ1bGx5IHJlbXV4aW5nIGF1ZGlvIGJlZm9yZSB2aWRlbywgc28gdGhhdCByZW11eFZpZGVvIGNhbiB1c2UgbmV4dEF1ZGlvUHRzLCB3aGljaCBpcyBjYWxjdWxhdGVkIGluIHJlbXV4QXVkaW8uXG4gICAgICAgIGlmIChlbm91Z2hBdWRpb1NhbXBsZXMpIHtcbiAgICAgICAgICAvLyBpZiBpbml0U2VnbWVudCB3YXMgZ2VuZXJhdGVkIHdpdGhvdXQgYXVkaW8gc2FtcGxlcywgcmVnZW5lcmF0ZSBpdCBhZ2FpblxuICAgICAgICAgIGlmICghYXVkaW9UcmFjay5zYW1wbGVyYXRlKSB7XG4gICAgICAgICAgICB0aGlzLndhcm4oJ3JlZ2VuZXJhdGUgSW5pdFNlZ21lbnQgYXMgYXVkaW8gZGV0ZWN0ZWQnKTtcbiAgICAgICAgICAgIGluaXRTZWdtZW50ID0gdGhpcy5nZW5lcmF0ZUlTKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF1ZGlvID0gdGhpcy5yZW11eEF1ZGlvKGF1ZGlvVHJhY2ssIGF1ZGlvVGltZU9mZnNldCwgdGhpcy5pc0F1ZGlvQ29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0LCBoYXNWaWRlbyB8fCBlbm91Z2hWaWRlb1NhbXBsZXMgfHwgcGxheWxpc3RUeXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5BVURJTyA/IHZpZGVvVGltZU9mZnNldCA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgaWYgKGVub3VnaFZpZGVvU2FtcGxlcykge1xuICAgICAgICAgICAgY29uc3QgYXVkaW9UcmFja0xlbmd0aCA9IGF1ZGlvID8gYXVkaW8uZW5kUFRTIC0gYXVkaW8uc3RhcnRQVFMgOiAwO1xuICAgICAgICAgICAgLy8gaWYgaW5pdFNlZ21lbnQgd2FzIGdlbmVyYXRlZCB3aXRob3V0IHZpZGVvIHNhbXBsZXMsIHJlZ2VuZXJhdGUgaXQgYWdhaW5cbiAgICAgICAgICAgIGlmICghdmlkZW9UcmFjay5pbnB1dFRpbWVTY2FsZSkge1xuICAgICAgICAgICAgICB0aGlzLndhcm4oJ3JlZ2VuZXJhdGUgSW5pdFNlZ21lbnQgYXMgdmlkZW8gZGV0ZWN0ZWQnKTtcbiAgICAgICAgICAgICAgaW5pdFNlZ21lbnQgPSB0aGlzLmdlbmVyYXRlSVMoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZpZGVvID0gdGhpcy5yZW11eFZpZGVvKHZpZGVvVHJhY2ssIHZpZGVvVGltZU9mZnNldCwgaXNWaWRlb0NvbnRpZ3VvdXMsIGF1ZGlvVHJhY2tMZW5ndGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChlbm91Z2hWaWRlb1NhbXBsZXMpIHtcbiAgICAgICAgICB2aWRlbyA9IHRoaXMucmVtdXhWaWRlbyh2aWRlb1RyYWNrLCB2aWRlb1RpbWVPZmZzZXQsIGlzVmlkZW9Db250aWd1b3VzLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmlkZW8pIHtcbiAgICAgICAgICB2aWRlby5maXJzdEtleUZyYW1lID0gZmlyc3RLZXlGcmFtZUluZGV4O1xuICAgICAgICAgIHZpZGVvLmluZGVwZW5kZW50ID0gZmlyc3RLZXlGcmFtZUluZGV4ICE9PSAtMTtcbiAgICAgICAgICB2aWRlby5maXJzdEtleUZyYW1lUFRTID0gZmlyc3RLZXlGcmFtZVBUUztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFsbG93IElEMyBhbmQgdGV4dCB0byByZW11eCwgZXZlbiBpZiBtb3JlIGF1ZGlvL3ZpZGVvIHNhbXBsZXMgYXJlIHJlcXVpcmVkXG4gICAgaWYgKHRoaXMuSVNHZW5lcmF0ZWQgJiYgdGhpcy5faW5pdFBUUyAmJiB0aGlzLl9pbml0RFRTKSB7XG4gICAgICBpZiAoaWQzVHJhY2suc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgaWQzID0gZmx1c2hUZXh0VHJhY2tNZXRhZGF0YUN1ZVNhbXBsZXMoaWQzVHJhY2ssIHRpbWVPZmZzZXQsIHRoaXMuX2luaXRQVFMsIHRoaXMuX2luaXREVFMpO1xuICAgICAgfVxuICAgICAgaWYgKHRleHRUcmFjay5zYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICB0ZXh0ID0gZmx1c2hUZXh0VHJhY2tVc2VyZGF0YUN1ZVNhbXBsZXModGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCB0aGlzLl9pbml0UFRTKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGF1ZGlvLFxuICAgICAgdmlkZW8sXG4gICAgICBpbml0U2VnbWVudCxcbiAgICAgIGluZGVwZW5kZW50LFxuICAgICAgdGV4dCxcbiAgICAgIGlkM1xuICAgIH07XG4gIH1cbiAgZ2VuZXJhdGVJUyhhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQpIHtcbiAgICBjb25zdCBhdWRpb1NhbXBsZXMgPSBhdWRpb1RyYWNrLnNhbXBsZXM7XG4gICAgY29uc3QgdmlkZW9TYW1wbGVzID0gdmlkZW9UcmFjay5zYW1wbGVzO1xuICAgIGNvbnN0IHR5cGVTdXBwb3J0ZWQgPSB0aGlzLnR5cGVTdXBwb3J0ZWQ7XG4gICAgY29uc3QgdHJhY2tzID0ge307XG4gICAgY29uc3QgX2luaXRQVFMgPSB0aGlzLl9pbml0UFRTO1xuICAgIGxldCBjb21wdXRlUFRTRFRTID0gIV9pbml0UFRTIHx8IGFjY3VyYXRlVGltZU9mZnNldDtcbiAgICBsZXQgY29udGFpbmVyID0gJ2F1ZGlvL21wNCc7XG4gICAgbGV0IGluaXRQVFM7XG4gICAgbGV0IGluaXREVFM7XG4gICAgbGV0IHRpbWVzY2FsZTtcbiAgICBsZXQgdHJhY2tJZDtcbiAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xuICAgICAgaW5pdFBUUyA9IGluaXREVFMgPSBJbmZpbml0eTtcbiAgICB9XG4gICAgaWYgKGF1ZGlvVHJhY2suY29uZmlnICYmIGF1ZGlvU2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIC8vIGxldCdzIHVzZSBhdWRpbyBzYW1wbGluZyByYXRlIGFzIE1QNCB0aW1lIHNjYWxlLlxuICAgICAgLy8gcmF0aW9uYWxlIGlzIHRoYXQgdGhlcmUgaXMgYSBpbnRlZ2VyIG5iIG9mIGF1ZGlvIGZyYW1lcyBwZXIgYXVkaW8gc2FtcGxlICgxMDI0IGZvciBBQUMpXG4gICAgICAvLyB1c2luZyBhdWRpbyBzYW1wbGluZyByYXRlIGhlcmUgaGVscHMgaGF2aW5nIGFuIGludGVnZXIgTVA0IGZyYW1lIGR1cmF0aW9uXG4gICAgICAvLyB0aGlzIGF2b2lkcyBwb3RlbnRpYWwgcm91bmRpbmcgaXNzdWUgYW5kIEFWIHN5bmMgaXNzdWVcbiAgICAgIGF1ZGlvVHJhY2sudGltZXNjYWxlID0gYXVkaW9UcmFjay5zYW1wbGVyYXRlO1xuICAgICAgc3dpdGNoIChhdWRpb1RyYWNrLnNlZ21lbnRDb2RlYykge1xuICAgICAgICBjYXNlICdtcDMnOlxuICAgICAgICAgIGlmICh0eXBlU3VwcG9ydGVkLm1wZWcpIHtcbiAgICAgICAgICAgIC8vIENocm9tZSBhbmQgU2FmYXJpXG4gICAgICAgICAgICBjb250YWluZXIgPSAnYXVkaW8vbXBlZyc7XG4gICAgICAgICAgICBhdWRpb1RyYWNrLmNvZGVjID0gJyc7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlU3VwcG9ydGVkLm1wMykge1xuICAgICAgICAgICAgLy8gRmlyZWZveFxuICAgICAgICAgICAgYXVkaW9UcmFjay5jb2RlYyA9ICdtcDMnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYWMzJzpcbiAgICAgICAgICBhdWRpb1RyYWNrLmNvZGVjID0gJ2FjLTMnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdHJhY2tzLmF1ZGlvID0ge1xuICAgICAgICBpZDogJ2F1ZGlvJyxcbiAgICAgICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICAgIGNvZGVjOiBhdWRpb1RyYWNrLmNvZGVjLFxuICAgICAgICBpbml0U2VnbWVudDogYXVkaW9UcmFjay5zZWdtZW50Q29kZWMgPT09ICdtcDMnICYmIHR5cGVTdXBwb3J0ZWQubXBlZyA/IG5ldyBVaW50OEFycmF5KDApIDogTVA0LmluaXRTZWdtZW50KFthdWRpb1RyYWNrXSksXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgY2hhbm5lbENvdW50OiBhdWRpb1RyYWNrLmNoYW5uZWxDb3VudFxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKGNvbXB1dGVQVFNEVFMpIHtcbiAgICAgICAgdHJhY2tJZCA9IGF1ZGlvVHJhY2suaWQ7XG4gICAgICAgIHRpbWVzY2FsZSA9IGF1ZGlvVHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgICAgIGlmICghX2luaXRQVFMgfHwgdGltZXNjYWxlICE9PSBfaW5pdFBUUy50aW1lc2NhbGUpIHtcbiAgICAgICAgICAvLyByZW1lbWJlciBmaXJzdCBQVFMgb2YgdGhpcyBkZW11eGluZyBjb250ZXh0LiBmb3IgYXVkaW8sIFBUUyA9IERUU1xuICAgICAgICAgIGluaXRQVFMgPSBpbml0RFRTID0gYXVkaW9TYW1wbGVzWzBdLnB0cyAtIE1hdGgucm91bmQodGltZXNjYWxlICogdGltZU9mZnNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29tcHV0ZVBUU0RUUyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2aWRlb1RyYWNrLnNwcyAmJiB2aWRlb1RyYWNrLnBwcyAmJiB2aWRlb1NhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAvLyBsZXQncyB1c2UgaW5wdXQgdGltZSBzY2FsZSBhcyBNUDQgdmlkZW8gdGltZXNjYWxlXG4gICAgICAvLyB3ZSB1c2UgaW5wdXQgdGltZSBzY2FsZSBzdHJhaWdodCBhd2F5IHRvIGF2b2lkIHJvdW5kaW5nIGlzc3VlcyBvbiBmcmFtZSBkdXJhdGlvbiAvIGN0cyBjb21wdXRhdGlvblxuICAgICAgdmlkZW9UcmFjay50aW1lc2NhbGUgPSB2aWRlb1RyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgICAgdHJhY2tzLnZpZGVvID0ge1xuICAgICAgICBpZDogJ21haW4nLFxuICAgICAgICBjb250YWluZXI6ICd2aWRlby9tcDQnLFxuICAgICAgICBjb2RlYzogdmlkZW9UcmFjay5jb2RlYyxcbiAgICAgICAgaW5pdFNlZ21lbnQ6IE1QNC5pbml0U2VnbWVudChbdmlkZW9UcmFja10pLFxuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIHdpZHRoOiB2aWRlb1RyYWNrLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogdmlkZW9UcmFjay5oZWlnaHRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XG4gICAgICAgIHRyYWNrSWQgPSB2aWRlb1RyYWNrLmlkO1xuICAgICAgICB0aW1lc2NhbGUgPSB2aWRlb1RyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgICAgICBpZiAoIV9pbml0UFRTIHx8IHRpbWVzY2FsZSAhPT0gX2luaXRQVFMudGltZXNjYWxlKSB7XG4gICAgICAgICAgY29uc3Qgc3RhcnRQVFMgPSB0aGlzLmdldFZpZGVvU3RhcnRQdHModmlkZW9TYW1wbGVzKTtcbiAgICAgICAgICBjb25zdCBzdGFydE9mZnNldCA9IE1hdGgucm91bmQodGltZXNjYWxlICogdGltZU9mZnNldCk7XG4gICAgICAgICAgaW5pdERUUyA9IE1hdGgubWluKGluaXREVFMsIG5vcm1hbGl6ZVB0cyh2aWRlb1NhbXBsZXNbMF0uZHRzLCBzdGFydFBUUykgLSBzdGFydE9mZnNldCk7XG4gICAgICAgICAgaW5pdFBUUyA9IE1hdGgubWluKGluaXRQVFMsIHN0YXJ0UFRTIC0gc3RhcnRPZmZzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbXB1dGVQVFNEVFMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy52aWRlb1RyYWNrQ29uZmlnID0ge1xuICAgICAgICB3aWR0aDogdmlkZW9UcmFjay53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB2aWRlb1RyYWNrLmhlaWdodCxcbiAgICAgICAgcGl4ZWxSYXRpbzogdmlkZW9UcmFjay5waXhlbFJhdGlvXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXModHJhY2tzKS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuSVNHZW5lcmF0ZWQgPSB0cnVlO1xuICAgICAgaWYgKGNvbXB1dGVQVFNEVFMpIHtcbiAgICAgICAgdGhpcy5faW5pdFBUUyA9IHtcbiAgICAgICAgICBiYXNlVGltZTogaW5pdFBUUyxcbiAgICAgICAgICB0aW1lc2NhbGU6IHRpbWVzY2FsZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9pbml0RFRTID0ge1xuICAgICAgICAgIGJhc2VUaW1lOiBpbml0RFRTLFxuICAgICAgICAgIHRpbWVzY2FsZTogdGltZXNjYWxlXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbml0UFRTID0gdGltZXNjYWxlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHJhY2tzLFxuICAgICAgICBpbml0UFRTLFxuICAgICAgICB0aW1lc2NhbGUsXG4gICAgICAgIHRyYWNrSWRcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHJlbXV4VmlkZW8odHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGF1ZGlvVHJhY2tMZW5ndGgpIHtcbiAgICBjb25zdCB0aW1lU2NhbGUgPSB0cmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICBjb25zdCBpbnB1dFNhbXBsZXMgPSB0cmFjay5zYW1wbGVzO1xuICAgIGNvbnN0IG91dHB1dFNhbXBsZXMgPSBbXTtcbiAgICBjb25zdCBuYlNhbXBsZXMgPSBpbnB1dFNhbXBsZXMubGVuZ3RoO1xuICAgIGNvbnN0IGluaXRQVFMgPSB0aGlzLl9pbml0UFRTO1xuICAgIGNvbnN0IGluaXRUaW1lID0gaW5pdFBUUy5iYXNlVGltZSAqIHRpbWVTY2FsZSAvIGluaXRQVFMudGltZXNjYWxlO1xuICAgIGxldCBuZXh0VmlkZW9UcyA9IHRoaXMubmV4dFZpZGVvVHM7XG4gICAgbGV0IG9mZnNldCA9IDg7XG4gICAgbGV0IG1wNFNhbXBsZUR1cmF0aW9uID0gdGhpcy52aWRlb1NhbXBsZUR1cmF0aW9uO1xuICAgIGxldCBmaXJzdERUUztcbiAgICBsZXQgbGFzdERUUztcbiAgICBsZXQgbWluUFRTID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGxldCBtYXhQVFMgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IHNvcnRTYW1wbGVzID0gZmFsc2U7XG5cbiAgICAvLyBpZiBwYXJzZWQgZnJhZ21lbnQgaXMgY29udGlndW91cyB3aXRoIGxhc3Qgb25lLCBsZXQncyB1c2UgbGFzdCBEVFMgdmFsdWUgYXMgcmVmZXJlbmNlXG4gICAgaWYgKCFjb250aWd1b3VzIHx8IG5leHRWaWRlb1RzID09PSBudWxsKSB7XG4gICAgICBjb25zdCBwdHMgPSBpbml0VGltZSArIHRpbWVPZmZzZXQgKiB0aW1lU2NhbGU7XG4gICAgICBjb25zdCBjdHMgPSBpbnB1dFNhbXBsZXNbMF0ucHRzIC0gbm9ybWFsaXplUHRzKGlucHV0U2FtcGxlc1swXS5kdHMsIGlucHV0U2FtcGxlc1swXS5wdHMpO1xuICAgICAgaWYgKGNocm9tZVZlcnNpb24gJiYgbmV4dFZpZGVvVHMgIT09IG51bGwgJiYgTWF0aC5hYnMocHRzIC0gY3RzIC0gKG5leHRWaWRlb1RzICsgaW5pdFRpbWUpKSA8IDE1MDAwKSB7XG4gICAgICAgIC8vIHRyZWF0IGFzIGNvbnRpZ291cyB0byBhZGp1c3Qgc2FtcGxlcyB0aGF0IHdvdWxkIG90aGVyd2lzZSBwcm9kdWNlIHZpZGVvIGJ1ZmZlciBnYXBzIGluIENocm9tZVxuICAgICAgICBjb250aWd1b3VzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIG5vdCBjb250aWd1b3VzLCBsZXQncyB1c2UgdGFyZ2V0IHRpbWVPZmZzZXRcbiAgICAgICAgbmV4dFZpZGVvVHMgPSBwdHMgLSBjdHMgLSBpbml0VGltZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQVFMgaXMgY29kZWQgb24gMzNiaXRzLCBhbmQgY2FuIGxvb3AgZnJvbSAtMl4zMiB0byAyXjMyXG4gICAgLy8gUFRTTm9ybWFsaXplIHdpbGwgbWFrZSBQVFMvRFRTIHZhbHVlIG1vbm90b25pYywgd2UgdXNlIGxhc3Qga25vd24gRFRTIHZhbHVlIGFzIHJlZmVyZW5jZSB2YWx1ZVxuICAgIGNvbnN0IG5leHRWaWRlb1B0cyA9IG5leHRWaWRlb1RzICsgaW5pdFRpbWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYlNhbXBsZXM7IGkrKykge1xuICAgICAgY29uc3Qgc2FtcGxlID0gaW5wdXRTYW1wbGVzW2ldO1xuICAgICAgc2FtcGxlLnB0cyA9IG5vcm1hbGl6ZVB0cyhzYW1wbGUucHRzLCBuZXh0VmlkZW9QdHMpO1xuICAgICAgc2FtcGxlLmR0cyA9IG5vcm1hbGl6ZVB0cyhzYW1wbGUuZHRzLCBuZXh0VmlkZW9QdHMpO1xuICAgICAgaWYgKHNhbXBsZS5kdHMgPCBpbnB1dFNhbXBsZXNbaSA+IDAgPyBpIC0gMSA6IGldLmR0cykge1xuICAgICAgICBzb3J0U2FtcGxlcyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc29ydCB2aWRlbyBzYW1wbGVzIGJ5IERUUyB0aGVuIFBUUyB0aGVuIGRlbXV4IGlkIG9yZGVyXG4gICAgaWYgKHNvcnRTYW1wbGVzKSB7XG4gICAgICBpbnB1dFNhbXBsZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICBjb25zdCBkZWx0YWR0cyA9IGEuZHRzIC0gYi5kdHM7XG4gICAgICAgIGNvbnN0IGRlbHRhcHRzID0gYS5wdHMgLSBiLnB0cztcbiAgICAgICAgcmV0dXJuIGRlbHRhZHRzIHx8IGRlbHRhcHRzO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gR2V0IGZpcnN0L2xhc3QgRFRTXG4gICAgZmlyc3REVFMgPSBpbnB1dFNhbXBsZXNbMF0uZHRzO1xuICAgIGxhc3REVFMgPSBpbnB1dFNhbXBsZXNbaW5wdXRTYW1wbGVzLmxlbmd0aCAtIDFdLmR0cztcblxuICAgIC8vIFNhbXBsZSBkdXJhdGlvbiAoYXMgZXhwZWN0ZWQgYnkgdHJ1biBNUDQgYm94ZXMpLCBzaG91bGQgYmUgdGhlIGRlbHRhIGJldHdlZW4gc2FtcGxlIERUU1xuICAgIC8vIHNldCB0aGlzIGNvbnN0YW50IGR1cmF0aW9uIGFzIGJlaW5nIHRoZSBhdmcgZGVsdGEgYmV0d2VlbiBjb25zZWN1dGl2ZSBEVFMuXG4gICAgY29uc3QgaW5wdXREdXJhdGlvbiA9IGxhc3REVFMgLSBmaXJzdERUUztcbiAgICBjb25zdCBhdmVyYWdlU2FtcGxlRHVyYXRpb24gPSBpbnB1dER1cmF0aW9uID8gTWF0aC5yb3VuZChpbnB1dER1cmF0aW9uIC8gKG5iU2FtcGxlcyAtIDEpKSA6IG1wNFNhbXBsZUR1cmF0aW9uIHx8IHRyYWNrLmlucHV0VGltZVNjYWxlIC8gMzA7XG5cbiAgICAvLyBpZiBmcmFnbWVudCBhcmUgY29udGlndW91cywgZGV0ZWN0IGhvbGUvb3ZlcmxhcHBpbmcgYmV0d2VlbiBmcmFnbWVudHNcbiAgICBpZiAoY29udGlndW91cykge1xuICAgICAgLy8gY2hlY2sgdGltZXN0YW1wIGNvbnRpbnVpdHkgYWNyb3NzIGNvbnNlY3V0aXZlIGZyYWdtZW50cyAodGhpcyBpcyB0byByZW1vdmUgaW50ZXItZnJhZ21lbnQgZ2FwL2hvbGUpXG4gICAgICBjb25zdCBkZWx0YSA9IGZpcnN0RFRTIC0gbmV4dFZpZGVvUHRzO1xuICAgICAgY29uc3QgZm91bmRIb2xlID0gZGVsdGEgPiBhdmVyYWdlU2FtcGxlRHVyYXRpb247XG4gICAgICBjb25zdCBmb3VuZE92ZXJsYXAgPSBkZWx0YSA8IC0xO1xuICAgICAgaWYgKGZvdW5kSG9sZSB8fCBmb3VuZE92ZXJsYXApIHtcbiAgICAgICAgaWYgKGZvdW5kSG9sZSkge1xuICAgICAgICAgIHRoaXMud2FybihgJHsodHJhY2suc2VnbWVudENvZGVjIHx8ICcnKS50b1VwcGVyQ2FzZSgpfTogJHt0b01zRnJvbU1wZWdUc0Nsb2NrKGRlbHRhLCB0cnVlKX0gbXMgKCR7ZGVsdGF9ZHRzKSBob2xlIGJldHdlZW4gZnJhZ21lbnRzIGRldGVjdGVkIGF0ICR7dGltZU9mZnNldC50b0ZpeGVkKDMpfWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMud2FybihgJHsodHJhY2suc2VnbWVudENvZGVjIHx8ICcnKS50b1VwcGVyQ2FzZSgpfTogJHt0b01zRnJvbU1wZWdUc0Nsb2NrKC1kZWx0YSwgdHJ1ZSl9IG1zICgke2RlbHRhfWR0cykgb3ZlcmxhcHBpbmcgYmV0d2VlbiBmcmFnbWVudHMgZGV0ZWN0ZWQgYXQgJHt0aW1lT2Zmc2V0LnRvRml4ZWQoMyl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmb3VuZE92ZXJsYXAgfHwgbmV4dFZpZGVvUHRzID49IGlucHV0U2FtcGxlc1swXS5wdHMgfHwgY2hyb21lVmVyc2lvbikge1xuICAgICAgICAgIGZpcnN0RFRTID0gbmV4dFZpZGVvUHRzO1xuICAgICAgICAgIGNvbnN0IGZpcnN0UFRTID0gaW5wdXRTYW1wbGVzWzBdLnB0cyAtIGRlbHRhO1xuICAgICAgICAgIGlmIChmb3VuZEhvbGUpIHtcbiAgICAgICAgICAgIGlucHV0U2FtcGxlc1swXS5kdHMgPSBmaXJzdERUUztcbiAgICAgICAgICAgIGlucHV0U2FtcGxlc1swXS5wdHMgPSBmaXJzdFBUUztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGlzUFRTT3JkZXJSZXRhaW5lZCA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0U2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoaW5wdXRTYW1wbGVzW2ldLmR0cyA+IGZpcnN0UFRTICYmIGlzUFRTT3JkZXJSZXRhaW5lZCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IHByZXZQVFMgPSBpbnB1dFNhbXBsZXNbaV0ucHRzO1xuICAgICAgICAgICAgICBpbnB1dFNhbXBsZXNbaV0uZHRzIC09IGRlbHRhO1xuICAgICAgICAgICAgICBpbnB1dFNhbXBsZXNbaV0ucHRzIC09IGRlbHRhO1xuXG4gICAgICAgICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiB0aGlzIHNhbXBsZSdzIFBUUyBvcmRlciBoYXMgY2hhbmdlZFxuICAgICAgICAgICAgICAvLyByZWxhdGl2ZSB0byB0aGUgbmV4dCBvbmVcbiAgICAgICAgICAgICAgaWYgKGkgPCBpbnB1dFNhbXBsZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRTYW1wbGVQVFMgPSBpbnB1dFNhbXBsZXNbaSArIDFdLnB0cztcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50U2FtcGxlUFRTID0gaW5wdXRTYW1wbGVzW2ldLnB0cztcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50T3JkZXIgPSBuZXh0U2FtcGxlUFRTIDw9IGN1cnJlbnRTYW1wbGVQVFM7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldk9yZGVyID0gbmV4dFNhbXBsZVBUUyA8PSBwcmV2UFRTO1xuICAgICAgICAgICAgICAgIGlzUFRTT3JkZXJSZXRhaW5lZCA9IGN1cnJlbnRPcmRlciA9PSBwcmV2T3JkZXI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5sb2coYFZpZGVvOiBJbml0aWFsIFBUUy9EVFMgYWRqdXN0ZWQ6ICR7dG9Nc0Zyb21NcGVnVHNDbG9jayhmaXJzdFBUUywgdHJ1ZSl9LyR7dG9Nc0Zyb21NcGVnVHNDbG9jayhmaXJzdERUUywgdHJ1ZSl9LCBkZWx0YTogJHt0b01zRnJvbU1wZWdUc0Nsb2NrKGRlbHRhLCB0cnVlKX0gbXNgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmaXJzdERUUyA9IE1hdGgubWF4KDAsIGZpcnN0RFRTKTtcbiAgICBsZXQgbmJOYWx1ID0gMDtcbiAgICBsZXQgbmFsdUxlbiA9IDA7XG4gICAgbGV0IGR0c1N0ZXAgPSBmaXJzdERUUztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5iU2FtcGxlczsgaSsrKSB7XG4gICAgICAvLyBjb21wdXRlIHRvdGFsL2F2YyBzYW1wbGUgbGVuZ3RoIGFuZCBuYiBvZiBOQUwgdW5pdHNcbiAgICAgIGNvbnN0IHNhbXBsZSA9IGlucHV0U2FtcGxlc1tpXTtcbiAgICAgIGNvbnN0IHVuaXRzID0gc2FtcGxlLnVuaXRzO1xuICAgICAgY29uc3QgbmJVbml0cyA9IHVuaXRzLmxlbmd0aDtcbiAgICAgIGxldCBzYW1wbGVMZW4gPSAwO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBuYlVuaXRzOyBqKyspIHtcbiAgICAgICAgc2FtcGxlTGVuICs9IHVuaXRzW2pdLmRhdGEubGVuZ3RoO1xuICAgICAgfVxuICAgICAgbmFsdUxlbiArPSBzYW1wbGVMZW47XG4gICAgICBuYk5hbHUgKz0gbmJVbml0cztcbiAgICAgIHNhbXBsZS5sZW5ndGggPSBzYW1wbGVMZW47XG5cbiAgICAgIC8vIGVuc3VyZSBzYW1wbGUgbW9ub3RvbmljIERUU1xuICAgICAgaWYgKHNhbXBsZS5kdHMgPCBkdHNTdGVwKSB7XG4gICAgICAgIHNhbXBsZS5kdHMgPSBkdHNTdGVwO1xuICAgICAgICBkdHNTdGVwICs9IGF2ZXJhZ2VTYW1wbGVEdXJhdGlvbiAvIDQgfCAwIHx8IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkdHNTdGVwID0gc2FtcGxlLmR0cztcbiAgICAgIH1cbiAgICAgIG1pblBUUyA9IE1hdGgubWluKHNhbXBsZS5wdHMsIG1pblBUUyk7XG4gICAgICBtYXhQVFMgPSBNYXRoLm1heChzYW1wbGUucHRzLCBtYXhQVFMpO1xuICAgIH1cbiAgICBsYXN0RFRTID0gaW5wdXRTYW1wbGVzW25iU2FtcGxlcyAtIDFdLmR0cztcblxuICAgIC8qIGNvbmNhdGVuYXRlIHRoZSB2aWRlbyBkYXRhIGFuZCBjb25zdHJ1Y3QgdGhlIG1kYXQgaW4gcGxhY2VcbiAgICAgIChuZWVkIDggbW9yZSBieXRlcyB0byBmaWxsIGxlbmd0aCBhbmQgbXBkYXQgdHlwZSkgKi9cbiAgICBjb25zdCBtZGF0U2l6ZSA9IG5hbHVMZW4gKyA0ICogbmJOYWx1ICsgODtcbiAgICBsZXQgbWRhdDtcbiAgICB0cnkge1xuICAgICAgbWRhdCA9IG5ldyBVaW50OEFycmF5KG1kYXRTaXplKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMub2JzZXJ2ZXIuZW1pdChFdmVudHMuRVJST1IsIEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1VWF9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLlJFTVVYX0FMTE9DX0VSUk9SLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgIGJ5dGVzOiBtZGF0U2l6ZSxcbiAgICAgICAgcmVhc29uOiBgZmFpbCBhbGxvY2F0aW5nIHZpZGVvIG1kYXQgJHttZGF0U2l6ZX1gXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhtZGF0LmJ1ZmZlcik7XG4gICAgdmlldy5zZXRVaW50MzIoMCwgbWRhdFNpemUpO1xuICAgIG1kYXQuc2V0KE1QNC50eXBlcy5tZGF0LCA0KTtcbiAgICBsZXQgc3RyZXRjaGVkTGFzdEZyYW1lID0gZmFsc2U7XG4gICAgbGV0IG1pbkR0c0RlbHRhID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGxldCBtaW5QdHNEZWx0YSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgbWF4RHRzRGVsdGEgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IG1heFB0c0RlbHRhID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmJTYW1wbGVzOyBpKyspIHtcbiAgICAgIGNvbnN0IFZpZGVvU2FtcGxlID0gaW5wdXRTYW1wbGVzW2ldO1xuICAgICAgY29uc3QgVmlkZW9TYW1wbGVVbml0cyA9IFZpZGVvU2FtcGxlLnVuaXRzO1xuICAgICAgbGV0IG1wNFNhbXBsZUxlbmd0aCA9IDA7XG4gICAgICAvLyBjb252ZXJ0IE5BTFUgYml0c3RyZWFtIHRvIE1QNCBmb3JtYXQgKHByZXBlbmQgTkFMVSB3aXRoIHNpemUgZmllbGQpXG4gICAgICBmb3IgKGxldCBqID0gMCwgbmJVbml0cyA9IFZpZGVvU2FtcGxlVW5pdHMubGVuZ3RoOyBqIDwgbmJVbml0czsgaisrKSB7XG4gICAgICAgIGNvbnN0IHVuaXQgPSBWaWRlb1NhbXBsZVVuaXRzW2pdO1xuICAgICAgICBjb25zdCB1bml0RGF0YSA9IHVuaXQuZGF0YTtcbiAgICAgICAgY29uc3QgdW5pdERhdGFMZW4gPSB1bml0LmRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0LCB1bml0RGF0YUxlbik7XG4gICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICBtZGF0LnNldCh1bml0RGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IHVuaXREYXRhTGVuO1xuICAgICAgICBtcDRTYW1wbGVMZW5ndGggKz0gNCArIHVuaXREYXRhTGVuO1xuICAgICAgfVxuXG4gICAgICAvLyBleHBlY3RlZCBzYW1wbGUgZHVyYXRpb24gaXMgdGhlIERlY29kaW5nIFRpbWVzdGFtcCBkaWZmIG9mIGNvbnNlY3V0aXZlIHNhbXBsZXNcbiAgICAgIGxldCBwdHNEZWx0YTtcbiAgICAgIGlmIChpIDwgbmJTYW1wbGVzIC0gMSkge1xuICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGlucHV0U2FtcGxlc1tpICsgMV0uZHRzIC0gVmlkZW9TYW1wbGUuZHRzO1xuICAgICAgICBwdHNEZWx0YSA9IGlucHV0U2FtcGxlc1tpICsgMV0ucHRzIC0gVmlkZW9TYW1wbGUucHRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICAgIGNvbnN0IGxhc3RGcmFtZUR1cmF0aW9uID0gaSA+IDAgPyBWaWRlb1NhbXBsZS5kdHMgLSBpbnB1dFNhbXBsZXNbaSAtIDFdLmR0cyA6IGF2ZXJhZ2VTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgcHRzRGVsdGEgPSBpID4gMCA/IFZpZGVvU2FtcGxlLnB0cyAtIGlucHV0U2FtcGxlc1tpIC0gMV0ucHRzIDogYXZlcmFnZVNhbXBsZUR1cmF0aW9uO1xuICAgICAgICBpZiAoY29uZmlnLnN0cmV0Y2hTaG9ydFZpZGVvVHJhY2sgJiYgdGhpcy5uZXh0QXVkaW9UcyAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIEluIHNvbWUgY2FzZXMsIGEgc2VnbWVudCdzIGF1ZGlvIHRyYWNrIGR1cmF0aW9uIG1heSBleGNlZWQgdGhlIHZpZGVvIHRyYWNrIGR1cmF0aW9uLlxuICAgICAgICAgIC8vIFNpbmNlIHdlJ3ZlIGFscmVhZHkgcmVtdXhlZCBhdWRpbywgYW5kIHdlIGtub3cgaG93IGxvbmcgdGhlIGF1ZGlvIHRyYWNrIGlzLCB3ZSBsb29rIHRvXG4gICAgICAgICAgLy8gc2VlIGlmIHRoZSBkZWx0YSB0byB0aGUgbmV4dCBzZWdtZW50IGlzIGxvbmdlciB0aGFuIG1heEJ1ZmZlckhvbGUuXG4gICAgICAgICAgLy8gSWYgc28sIHBsYXliYWNrIHdvdWxkIHBvdGVudGlhbGx5IGdldCBzdHVjaywgc28gd2UgYXJ0aWZpY2lhbGx5IGluZmxhdGVcbiAgICAgICAgICAvLyB0aGUgZHVyYXRpb24gb2YgdGhlIGxhc3QgZnJhbWUgdG8gbWluaW1pemUgYW55IHBvdGVudGlhbCBnYXAgYmV0d2VlbiBzZWdtZW50cy5cbiAgICAgICAgICBjb25zdCBnYXBUb2xlcmFuY2UgPSBNYXRoLmZsb29yKGNvbmZpZy5tYXhCdWZmZXJIb2xlICogdGltZVNjYWxlKTtcbiAgICAgICAgICBjb25zdCBkZWx0YVRvRnJhbWVFbmQgPSAoYXVkaW9UcmFja0xlbmd0aCA/IG1pblBUUyArIGF1ZGlvVHJhY2tMZW5ndGggKiB0aW1lU2NhbGUgOiB0aGlzLm5leHRBdWRpb1RzICsgaW5pdFRpbWUpIC0gVmlkZW9TYW1wbGUucHRzO1xuICAgICAgICAgIGlmIChkZWx0YVRvRnJhbWVFbmQgPiBnYXBUb2xlcmFuY2UpIHtcbiAgICAgICAgICAgIC8vIFdlIHN1YnRyYWN0IGxhc3RGcmFtZUR1cmF0aW9uIGZyb20gZGVsdGFUb0ZyYW1lRW5kIHRvIHRyeSB0byBwcmV2ZW50IGFueSB2aWRlb1xuICAgICAgICAgICAgLy8gZnJhbWUgb3ZlcmxhcC4gbWF4QnVmZmVySG9sZSBzaG91bGQgYmUgPj4gbGFzdEZyYW1lRHVyYXRpb24gYW55d2F5LlxuICAgICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBkZWx0YVRvRnJhbWVFbmQgLSBsYXN0RnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICAgIGlmIChtcDRTYW1wbGVEdXJhdGlvbiA8IDApIHtcbiAgICAgICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBsYXN0RnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0cmV0Y2hlZExhc3RGcmFtZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxvZyhgSXQgaXMgYXBwcm94aW1hdGVseSAke2RlbHRhVG9GcmFtZUVuZCAvIDkwfSBtcyB0byB0aGUgbmV4dCBzZWdtZW50OyB1c2luZyBkdXJhdGlvbiAke21wNFNhbXBsZUR1cmF0aW9uIC8gOTB9IG1zIGZvciB0aGUgbGFzdCB2aWRlbyBmcmFtZS5gKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBsYXN0RnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBsYXN0RnJhbWVEdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgY29tcG9zaXRpb25UaW1lT2Zmc2V0ID0gTWF0aC5yb3VuZChWaWRlb1NhbXBsZS5wdHMgLSBWaWRlb1NhbXBsZS5kdHMpO1xuICAgICAgbWluRHRzRGVsdGEgPSBNYXRoLm1pbihtaW5EdHNEZWx0YSwgbXA0U2FtcGxlRHVyYXRpb24pO1xuICAgICAgbWF4RHRzRGVsdGEgPSBNYXRoLm1heChtYXhEdHNEZWx0YSwgbXA0U2FtcGxlRHVyYXRpb24pO1xuICAgICAgbWluUHRzRGVsdGEgPSBNYXRoLm1pbihtaW5QdHNEZWx0YSwgcHRzRGVsdGEpO1xuICAgICAgbWF4UHRzRGVsdGEgPSBNYXRoLm1heChtYXhQdHNEZWx0YSwgcHRzRGVsdGEpO1xuICAgICAgb3V0cHV0U2FtcGxlcy5wdXNoKGNyZWF0ZU1wNFNhbXBsZShWaWRlb1NhbXBsZS5rZXksIG1wNFNhbXBsZUR1cmF0aW9uLCBtcDRTYW1wbGVMZW5ndGgsIGNvbXBvc2l0aW9uVGltZU9mZnNldCkpO1xuICAgIH1cbiAgICBpZiAob3V0cHV0U2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIGlmIChjaHJvbWVWZXJzaW9uKSB7XG4gICAgICAgIGlmIChjaHJvbWVWZXJzaW9uIDwgNzApIHtcbiAgICAgICAgICAvLyBDaHJvbWUgd29ya2Fyb3VuZCwgbWFyayBmaXJzdCBzYW1wbGUgYXMgYmVpbmcgYSBSYW5kb20gQWNjZXNzIFBvaW50IChrZXlmcmFtZSkgdG8gYXZvaWQgc291cmNlYnVmZmVyIGFwcGVuZCBpc3N1ZVxuICAgICAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yMjk0MTJcbiAgICAgICAgICBjb25zdCBmbGFncyA9IG91dHB1dFNhbXBsZXNbMF0uZmxhZ3M7XG4gICAgICAgICAgZmxhZ3MuZGVwZW5kc09uID0gMjtcbiAgICAgICAgICBmbGFncy5pc05vblN5bmMgPSAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNhZmFyaVdlYmtpdFZlcnNpb24pIHtcbiAgICAgICAgLy8gRml4IGZvciBcIkNOTiBzcGVjaWFsIHJlcG9ydCwgd2l0aCBDQ1wiIGluIHRlc3Qtc3RyZWFtcyAoU2FmYXJpIGJyb3dzZXIgb25seSlcbiAgICAgICAgLy8gSWdub3JlIERUUyB3aGVuIGZyYW1lIGR1cmF0aW9ucyBhcmUgaXJyZWd1bGFyLiBTYWZhcmkgTVNFIGRvZXMgbm90IGhhbmRsZSB0aGlzIGxlYWRpbmcgdG8gZ2Fwcy5cbiAgICAgICAgaWYgKG1heFB0c0RlbHRhIC0gbWluUHRzRGVsdGEgPCBtYXhEdHNEZWx0YSAtIG1pbkR0c0RlbHRhICYmIGF2ZXJhZ2VTYW1wbGVEdXJhdGlvbiAvIG1heER0c0RlbHRhIDwgMC4wMjUgJiYgb3V0cHV0U2FtcGxlc1swXS5jdHMgPT09IDApIHtcbiAgICAgICAgICB0aGlzLndhcm4oJ0ZvdW5kIGlycmVndWxhciBnYXBzIGluIHNhbXBsZSBkdXJhdGlvbi4gVXNpbmcgUFRTIGluc3RlYWQgb2YgRFRTIHRvIGRldGVybWluZSBNUDQgc2FtcGxlIGR1cmF0aW9uLicpO1xuICAgICAgICAgIGxldCBkdHMgPSBmaXJzdERUUztcbiAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gb3V0cHV0U2FtcGxlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbmV4dER0cyA9IGR0cyArIG91dHB1dFNhbXBsZXNbaV0uZHVyYXRpb247XG4gICAgICAgICAgICBjb25zdCBwdHMgPSBkdHMgKyBvdXRwdXRTYW1wbGVzW2ldLmN0cztcbiAgICAgICAgICAgIGlmIChpIDwgbGVuIC0gMSkge1xuICAgICAgICAgICAgICBjb25zdCBuZXh0UHRzID0gbmV4dER0cyArIG91dHB1dFNhbXBsZXNbaSArIDFdLmN0cztcbiAgICAgICAgICAgICAgb3V0cHV0U2FtcGxlc1tpXS5kdXJhdGlvbiA9IG5leHRQdHMgLSBwdHM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdXRwdXRTYW1wbGVzW2ldLmR1cmF0aW9uID0gaSA/IG91dHB1dFNhbXBsZXNbaSAtIDFdLmR1cmF0aW9uIDogYXZlcmFnZVNhbXBsZUR1cmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0U2FtcGxlc1tpXS5jdHMgPSAwO1xuICAgICAgICAgICAgZHRzID0gbmV4dER0cztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gbmV4dCBBVkMvSEVWQyBzYW1wbGUgRFRTIHNob3VsZCBiZSBlcXVhbCB0byBsYXN0IHNhbXBsZSBEVFMgKyBsYXN0IHNhbXBsZSBkdXJhdGlvbiAoaW4gUEVTIHRpbWVzY2FsZSlcbiAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IHN0cmV0Y2hlZExhc3RGcmFtZSB8fCAhbXA0U2FtcGxlRHVyYXRpb24gPyBhdmVyYWdlU2FtcGxlRHVyYXRpb24gOiBtcDRTYW1wbGVEdXJhdGlvbjtcbiAgICBjb25zdCBlbmREVFMgPSBsYXN0RFRTICsgbXA0U2FtcGxlRHVyYXRpb247XG4gICAgdGhpcy5uZXh0VmlkZW9UcyA9IG5leHRWaWRlb1RzID0gZW5kRFRTIC0gaW5pdFRpbWU7XG4gICAgdGhpcy52aWRlb1NhbXBsZUR1cmF0aW9uID0gbXA0U2FtcGxlRHVyYXRpb247XG4gICAgdGhpcy5pc1ZpZGVvQ29udGlndW91cyA9IHRydWU7XG4gICAgY29uc3QgbW9vZiA9IE1QNC5tb29mKHRyYWNrLnNlcXVlbmNlTnVtYmVyKyssIGZpcnN0RFRTLCBfZXh0ZW5kcyh0cmFjaywge1xuICAgICAgc2FtcGxlczogb3V0cHV0U2FtcGxlc1xuICAgIH0pKTtcbiAgICBjb25zdCB0eXBlID0gJ3ZpZGVvJztcbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgZGF0YTE6IG1vb2YsXG4gICAgICBkYXRhMjogbWRhdCxcbiAgICAgIHN0YXJ0UFRTOiAobWluUFRTIC0gaW5pdFRpbWUpIC8gdGltZVNjYWxlLFxuICAgICAgZW5kUFRTOiAobWF4UFRTICsgbXA0U2FtcGxlRHVyYXRpb24gLSBpbml0VGltZSkgLyB0aW1lU2NhbGUsXG4gICAgICBzdGFydERUUzogKGZpcnN0RFRTIC0gaW5pdFRpbWUpIC8gdGltZVNjYWxlLFxuICAgICAgZW5kRFRTOiBuZXh0VmlkZW9UcyAvIHRpbWVTY2FsZSxcbiAgICAgIHR5cGUsXG4gICAgICBoYXNBdWRpbzogZmFsc2UsXG4gICAgICBoYXNWaWRlbzogdHJ1ZSxcbiAgICAgIG5iOiBvdXRwdXRTYW1wbGVzLmxlbmd0aCxcbiAgICAgIGRyb3BwZWQ6IHRyYWNrLmRyb3BwZWRcbiAgICB9O1xuICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcbiAgICB0cmFjay5kcm9wcGVkID0gMDtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBnZXRTYW1wbGVzUGVyRnJhbWUodHJhY2spIHtcbiAgICBzd2l0Y2ggKHRyYWNrLnNlZ21lbnRDb2RlYykge1xuICAgICAgY2FzZSAnbXAzJzpcbiAgICAgICAgcmV0dXJuIE1QRUdfQVVESU9fU0FNUExFX1BFUl9GUkFNRTtcbiAgICAgIGNhc2UgJ2FjMyc6XG4gICAgICAgIHJldHVybiBBQzNfU0FNUExFU19QRVJfRlJBTUU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gQUFDX1NBTVBMRVNfUEVSX0ZSQU1FO1xuICAgIH1cbiAgfVxuICByZW11eEF1ZGlvKHRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIHZpZGVvVGltZU9mZnNldCkge1xuICAgIGNvbnN0IGlucHV0VGltZVNjYWxlID0gdHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgY29uc3QgbXA0dGltZVNjYWxlID0gdHJhY2suc2FtcGxlcmF0ZSA/IHRyYWNrLnNhbXBsZXJhdGUgOiBpbnB1dFRpbWVTY2FsZTtcbiAgICBjb25zdCBzY2FsZUZhY3RvciA9IGlucHV0VGltZVNjYWxlIC8gbXA0dGltZVNjYWxlO1xuICAgIGNvbnN0IG1wNFNhbXBsZUR1cmF0aW9uID0gdGhpcy5nZXRTYW1wbGVzUGVyRnJhbWUodHJhY2spO1xuICAgIGNvbnN0IGlucHV0U2FtcGxlRHVyYXRpb24gPSBtcDRTYW1wbGVEdXJhdGlvbiAqIHNjYWxlRmFjdG9yO1xuICAgIGNvbnN0IGluaXRQVFMgPSB0aGlzLl9pbml0UFRTO1xuICAgIGNvbnN0IHJhd01QRUcgPSB0cmFjay5zZWdtZW50Q29kZWMgPT09ICdtcDMnICYmIHRoaXMudHlwZVN1cHBvcnRlZC5tcGVnO1xuICAgIGNvbnN0IG91dHB1dFNhbXBsZXMgPSBbXTtcbiAgICBjb25zdCBhbGlnbmVkV2l0aFZpZGVvID0gdmlkZW9UaW1lT2Zmc2V0ICE9PSB1bmRlZmluZWQ7XG4gICAgbGV0IGlucHV0U2FtcGxlcyA9IHRyYWNrLnNhbXBsZXM7XG4gICAgbGV0IG9mZnNldCA9IHJhd01QRUcgPyAwIDogODtcbiAgICBsZXQgbmV4dEF1ZGlvVHMgPSB0aGlzLm5leHRBdWRpb1RzIHx8IC0xO1xuXG4gICAgLy8gd2luZG93LmF1ZGlvU2FtcGxlcyA/IHdpbmRvdy5hdWRpb1NhbXBsZXMucHVzaChpbnB1dFNhbXBsZXMubWFwKHMgPT4gcy5wdHMpKSA6ICh3aW5kb3cuYXVkaW9TYW1wbGVzID0gW2lucHV0U2FtcGxlcy5tYXAocyA9PiBzLnB0cyldKTtcblxuICAgIC8vIGZvciBhdWRpbyBzYW1wbGVzLCBhbHNvIGNvbnNpZGVyIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBhcyBiZWluZyBjb250aWd1b3VzIChldmVuIGlmIGEgbGV2ZWwgc3dpdGNoIG9jY3VycyksXG4gICAgLy8gZm9yIHNha2Ugb2YgY2xhcml0eTpcbiAgICAvLyBjb25zZWN1dGl2ZSBmcmFnbWVudHMgYXJlIGZyYWdzIHdpdGhcbiAgICAvLyAgLSBsZXNzIHRoYW4gMTAwbXMgZ2FwcyBiZXR3ZWVuIG5ldyB0aW1lIG9mZnNldCAoaWYgYWNjdXJhdGUpIGFuZCBuZXh0IGV4cGVjdGVkIFBUUyBPUlxuICAgIC8vICAtIGxlc3MgdGhhbiAyMCBhdWRpbyBmcmFtZXMgZGlzdGFuY2VcbiAgICAvLyBjb250aWd1b3VzIGZyYWdtZW50cyBhcmUgY29uc2VjdXRpdmUgZnJhZ21lbnRzIGZyb20gc2FtZSBxdWFsaXR5IGxldmVsIChzYW1lIGxldmVsLCBuZXcgU04gPSBvbGQgU04gKyAxKVxuICAgIC8vIHRoaXMgaGVscHMgZW5zdXJpbmcgYXVkaW8gY29udGludWl0eVxuICAgIC8vIGFuZCB0aGlzIGFsc28gYXZvaWRzIGF1ZGlvIGdsaXRjaGVzL2N1dCB3aGVuIHN3aXRjaGluZyBxdWFsaXR5LCBvciByZXBvcnRpbmcgd3JvbmcgZHVyYXRpb24gb24gZmlyc3QgYXVkaW8gZnJhbWVcbiAgICBjb25zdCBpbml0VGltZSA9IGluaXRQVFMuYmFzZVRpbWUgKiBpbnB1dFRpbWVTY2FsZSAvIGluaXRQVFMudGltZXNjYWxlO1xuICAgIGNvbnN0IHRpbWVPZmZzZXRNcGVnVFMgPSBpbml0VGltZSArIHRpbWVPZmZzZXQgKiBpbnB1dFRpbWVTY2FsZTtcbiAgICB0aGlzLmlzQXVkaW9Db250aWd1b3VzID0gY29udGlndW91cyA9IGNvbnRpZ3VvdXMgfHwgaW5wdXRTYW1wbGVzLmxlbmd0aCAmJiBuZXh0QXVkaW9UcyA+IDAgJiYgKGFjY3VyYXRlVGltZU9mZnNldCAmJiBNYXRoLmFicyh0aW1lT2Zmc2V0TXBlZ1RTIC0gKG5leHRBdWRpb1RzICsgaW5pdFRpbWUpKSA8IDkwMDAgfHwgTWF0aC5hYnMobm9ybWFsaXplUHRzKGlucHV0U2FtcGxlc1swXS5wdHMsIHRpbWVPZmZzZXRNcGVnVFMpIC0gKG5leHRBdWRpb1RzICsgaW5pdFRpbWUpKSA8IDIwICogaW5wdXRTYW1wbGVEdXJhdGlvbik7XG5cbiAgICAvLyBjb21wdXRlIG5vcm1hbGl6ZWQgUFRTXG4gICAgaW5wdXRTYW1wbGVzLmZvckVhY2goZnVuY3Rpb24gKHNhbXBsZSkge1xuICAgICAgc2FtcGxlLnB0cyA9IG5vcm1hbGl6ZVB0cyhzYW1wbGUucHRzLCB0aW1lT2Zmc2V0TXBlZ1RTKTtcbiAgICB9KTtcbiAgICBpZiAoIWNvbnRpZ3VvdXMgfHwgbmV4dEF1ZGlvVHMgPCAwKSB7XG4gICAgICAvLyBmaWx0ZXIgb3V0IHNhbXBsZSB3aXRoIG5lZ2F0aXZlIFBUUyB0aGF0IGFyZSBub3QgcGxheWFibGUgYW55d2F5XG4gICAgICAvLyBpZiB3ZSBkb24ndCByZW1vdmUgdGhlc2UgbmVnYXRpdmUgc2FtcGxlcywgdGhleSB3aWxsIHNoaWZ0IGFsbCBhdWRpbyBzYW1wbGVzIGZvcndhcmQuXG4gICAgICAvLyBsZWFkaW5nIHRvIGF1ZGlvIG92ZXJsYXAgYmV0d2VlbiBjdXJyZW50IC8gbmV4dCBmcmFnbWVudFxuICAgICAgaW5wdXRTYW1wbGVzID0gaW5wdXRTYW1wbGVzLmZpbHRlcihzYW1wbGUgPT4gc2FtcGxlLnB0cyA+PSAwKTtcblxuICAgICAgLy8gaW4gY2FzZSBhbGwgc2FtcGxlcyBoYXZlIG5lZ2F0aXZlIFBUUywgYW5kIGhhdmUgYmVlbiBmaWx0ZXJlZCBvdXQsIHJldHVybiBub3dcbiAgICAgIGlmICghaW5wdXRTYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodmlkZW9UaW1lT2Zmc2V0ID09PSAwKSB7XG4gICAgICAgIC8vIFNldCB0aGUgc3RhcnQgdG8gbWF0Y2ggdmlkZW8gc28gdGhhdCBzdGFydCBnYXBzIGxhcmdlciB0aGFuIGlucHV0U2FtcGxlRHVyYXRpb24gYXJlIGZpbGxlZCB3aXRoIHNpbGVuY2VcbiAgICAgICAgbmV4dEF1ZGlvVHMgPSAwO1xuICAgICAgfSBlbHNlIGlmIChhY2N1cmF0ZVRpbWVPZmZzZXQgJiYgIWFsaWduZWRXaXRoVmlkZW8pIHtcbiAgICAgICAgLy8gV2hlbiBub3Qgc2Vla2luZywgbm90IGxpdmUsIGFuZCBMZXZlbERldGFpbHMuUFRTS25vd24sIHVzZSBmcmFnbWVudCBzdGFydCBhcyBwcmVkaWN0ZWQgbmV4dCBhdWRpbyBQVFNcbiAgICAgICAgbmV4dEF1ZGlvVHMgPSBNYXRoLm1heCgwLCB0aW1lT2Zmc2V0TXBlZ1RTIC0gaW5pdFRpbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgZnJhZ3MgYXJlIG5vdCBjb250aWd1b3VzIGFuZCBpZiB3ZSBjYW50IHRydXN0IHRpbWUgb2Zmc2V0LCBsZXQncyB1c2UgZmlyc3Qgc2FtcGxlIFBUUyBhcyBuZXh0IGF1ZGlvIFBUU1xuICAgICAgICBuZXh0QXVkaW9UcyA9IGlucHV0U2FtcGxlc1swXS5wdHMgLSBpbml0VGltZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgYXVkaW8gdHJhY2sgaXMgbWlzc2luZyBzYW1wbGVzLCB0aGUgZnJhbWVzIHNlZW0gdG8gZ2V0IFwibGVmdC1zaGlmdGVkXCIgd2l0aGluIHRoZVxuICAgIC8vIHJlc3VsdGluZyBtcDQgc2VnbWVudCwgY2F1c2luZyBzeW5jIGlzc3VlcyBhbmQgbGVhdmluZyBnYXBzIGF0IHRoZSBlbmQgb2YgdGhlIGF1ZGlvIHNlZ21lbnQuXG4gICAgLy8gSW4gYW4gZWZmb3J0IHRvIHByZXZlbnQgdGhpcyBmcm9tIGhhcHBlbmluZywgd2UgaW5qZWN0IGZyYW1lcyBoZXJlIHdoZXJlIHRoZXJlIGFyZSBnYXBzLlxuICAgIC8vIFdoZW4gcG9zc2libGUsIHdlIGluamVjdCBhIHNpbGVudCBmcmFtZTsgd2hlbiB0aGF0J3Mgbm90IHBvc3NpYmxlLCB3ZSBkdXBsaWNhdGUgdGhlIGxhc3RcbiAgICAvLyBmcmFtZS5cblxuICAgIGlmICh0cmFjay5zZWdtZW50Q29kZWMgPT09ICdhYWMnKSB7XG4gICAgICBjb25zdCBtYXhBdWRpb0ZyYW1lc0RyaWZ0ID0gdGhpcy5jb25maWcubWF4QXVkaW9GcmFtZXNEcmlmdDtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBuZXh0UHRzID0gbmV4dEF1ZGlvVHMgKyBpbml0VGltZTsgaSA8IGlucHV0U2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBGaXJzdCwgbGV0J3Mgc2VlIGhvdyBmYXIgb2ZmIHRoaXMgZnJhbWUgaXMgZnJvbSB3aGVyZSB3ZSBleHBlY3QgaXQgdG8gYmVcbiAgICAgICAgY29uc3Qgc2FtcGxlID0gaW5wdXRTYW1wbGVzW2ldO1xuICAgICAgICBjb25zdCBwdHMgPSBzYW1wbGUucHRzO1xuICAgICAgICBjb25zdCBkZWx0YSA9IHB0cyAtIG5leHRQdHM7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gTWF0aC5hYnMoMTAwMCAqIGRlbHRhIC8gaW5wdXRUaW1lU2NhbGUpO1xuXG4gICAgICAgIC8vIFdoZW4gcmVtdXhpbmcgd2l0aCB2aWRlbywgaWYgd2UncmUgb3ZlcmxhcHBpbmcgYnkgbW9yZSB0aGFuIGEgZHVyYXRpb24sIGRyb3AgdGhpcyBzYW1wbGUgdG8gc3RheSBpbiBzeW5jXG4gICAgICAgIGlmIChkZWx0YSA8PSAtbWF4QXVkaW9GcmFtZXNEcmlmdCAqIGlucHV0U2FtcGxlRHVyYXRpb24gJiYgYWxpZ25lZFdpdGhWaWRlbykge1xuICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLndhcm4oYEF1ZGlvIGZyYW1lIEAgJHsocHRzIC8gaW5wdXRUaW1lU2NhbGUpLnRvRml4ZWQoMyl9cyBvdmVybGFwcyBtYXJrZXIgYnkgJHtNYXRoLnJvdW5kKDEwMDAgKiBkZWx0YSAvIGlucHV0VGltZVNjYWxlKX0gbXMuYCk7XG4gICAgICAgICAgICB0aGlzLm5leHRBdWRpb1RzID0gbmV4dEF1ZGlvVHMgPSBwdHMgLSBpbml0VGltZTtcbiAgICAgICAgICAgIG5leHRQdHMgPSBwdHM7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYnJhY2Utc3R5bGVcblxuICAgICAgICAvLyBJbnNlcnQgbWlzc2luZyBmcmFtZXMgaWY6XG4gICAgICAgIC8vIDE6IFdlJ3JlIG1vcmUgdGhhbiBtYXhBdWRpb0ZyYW1lc0RyaWZ0IGZyYW1lIGF3YXlcbiAgICAgICAgLy8gMjogTm90IG1vcmUgdGhhbiBNQVhfU0lMRU5UX0ZSQU1FX0RVUkFUSU9OIGF3YXlcbiAgICAgICAgLy8gMzogY3VycmVudFRpbWUgKGFrYSBuZXh0UHRzTm9ybSkgaXMgbm90IDBcbiAgICAgICAgLy8gNDogcmVtdXhpbmcgd2l0aCB2aWRlbyAodmlkZW9UaW1lT2Zmc2V0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgIGVsc2UgaWYgKGRlbHRhID49IG1heEF1ZGlvRnJhbWVzRHJpZnQgKiBpbnB1dFNhbXBsZUR1cmF0aW9uICYmIGR1cmF0aW9uIDwgTUFYX1NJTEVOVF9GUkFNRV9EVVJBVElPTiAmJiBhbGlnbmVkV2l0aFZpZGVvKSB7XG4gICAgICAgICAgbGV0IG1pc3NpbmcgPSBNYXRoLnJvdW5kKGRlbHRhIC8gaW5wdXRTYW1wbGVEdXJhdGlvbik7XG4gICAgICAgICAgLy8gQWRqdXN0IG5leHRQdHMgc28gdGhhdCBzaWxlbnQgc2FtcGxlcyBhcmUgYWxpZ25lZCB3aXRoIG1lZGlhIHB0cy4gVGhpcyB3aWxsIHByZXZlbnQgbWVkaWEgc2FtcGxlcyBmcm9tXG4gICAgICAgICAgLy8gbGF0ZXIgYmVpbmcgc2hpZnRlZCBpZiBuZXh0UHRzIGlzIGJhc2VkIG9uIHRpbWVPZmZzZXQgYW5kIGRlbHRhIGlzIG5vdCBhIG11bHRpcGxlIG9mIGlucHV0U2FtcGxlRHVyYXRpb24uXG4gICAgICAgICAgbmV4dFB0cyA9IHB0cyAtIG1pc3NpbmcgKiBpbnB1dFNhbXBsZUR1cmF0aW9uO1xuICAgICAgICAgIHdoaWxlIChuZXh0UHRzIDwgMCAmJiBtaXNzaW5nICYmIGlucHV0U2FtcGxlRHVyYXRpb24pIHtcbiAgICAgICAgICAgIG1pc3NpbmctLTtcbiAgICAgICAgICAgIG5leHRQdHMgKz0gaW5wdXRTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMubmV4dEF1ZGlvVHMgPSBuZXh0QXVkaW9UcyA9IG5leHRQdHMgLSBpbml0VGltZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy53YXJuKGBJbmplY3RpbmcgJHttaXNzaW5nfSBhdWRpbyBmcmFtZXMgQCAkeygobmV4dFB0cyAtIGluaXRUaW1lKSAvIGlucHV0VGltZVNjYWxlKS50b0ZpeGVkKDMpfXMgZHVlIHRvICR7TWF0aC5yb3VuZCgxMDAwICogZGVsdGEgLyBpbnB1dFRpbWVTY2FsZSl9IG1zIGdhcC5gKTtcbiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1pc3Npbmc7IGorKykge1xuICAgICAgICAgICAgbGV0IGZpbGxGcmFtZSA9IEFBQy5nZXRTaWxlbnRGcmFtZSh0cmFjay5wYXJzZWRDb2RlYyB8fCB0cmFjay5tYW5pZmVzdENvZGVjIHx8IHRyYWNrLmNvZGVjLCB0cmFjay5jaGFubmVsQ291bnQpO1xuICAgICAgICAgICAgaWYgKCFmaWxsRnJhbWUpIHtcbiAgICAgICAgICAgICAgdGhpcy5sb2coJ1VuYWJsZSB0byBnZXQgc2lsZW50IGZyYW1lIGZvciBnaXZlbiBhdWRpbyBjb2RlYzsgZHVwbGljYXRpbmcgbGFzdCBmcmFtZSBpbnN0ZWFkLicpO1xuICAgICAgICAgICAgICBmaWxsRnJhbWUgPSBzYW1wbGUudW5pdC5zdWJhcnJheSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5wdXRTYW1wbGVzLnNwbGljZShpLCAwLCB7XG4gICAgICAgICAgICAgIHVuaXQ6IGZpbGxGcmFtZSxcbiAgICAgICAgICAgICAgcHRzOiBuZXh0UHRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5leHRQdHMgKz0gaW5wdXRTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2FtcGxlLnB0cyA9IG5leHRQdHM7XG4gICAgICAgIG5leHRQdHMgKz0gaW5wdXRTYW1wbGVEdXJhdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGZpcnN0UFRTID0gbnVsbDtcbiAgICBsZXQgbGFzdFBUUyA9IG51bGw7XG4gICAgbGV0IG1kYXQ7XG4gICAgbGV0IG1kYXRTaXplID0gMDtcbiAgICBsZXQgc2FtcGxlTGVuZ3RoID0gaW5wdXRTYW1wbGVzLmxlbmd0aDtcbiAgICB3aGlsZSAoc2FtcGxlTGVuZ3RoLS0pIHtcbiAgICAgIG1kYXRTaXplICs9IGlucHV0U2FtcGxlc1tzYW1wbGVMZW5ndGhdLnVuaXQuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IDAsIF9uYlNhbXBsZXMgPSBpbnB1dFNhbXBsZXMubGVuZ3RoOyBqIDwgX25iU2FtcGxlczsgaisrKSB7XG4gICAgICBjb25zdCBhdWRpb1NhbXBsZSA9IGlucHV0U2FtcGxlc1tqXTtcbiAgICAgIGNvbnN0IHVuaXQgPSBhdWRpb1NhbXBsZS51bml0O1xuICAgICAgbGV0IHB0cyA9IGF1ZGlvU2FtcGxlLnB0cztcbiAgICAgIGlmIChsYXN0UFRTICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgbW9yZSB0aGFuIG9uZSBzYW1wbGUsIHNldCB0aGUgZHVyYXRpb24gb2YgdGhlIHNhbXBsZSB0byB0aGUgXCJyZWFsXCIgZHVyYXRpb247IHRoZSBQVFMgZGlmZiB3aXRoXG4gICAgICAgIC8vIHRoZSBwcmV2aW91cyBzYW1wbGVcbiAgICAgICAgY29uc3QgcHJldlNhbXBsZSA9IG91dHB1dFNhbXBsZXNbaiAtIDFdO1xuICAgICAgICBwcmV2U2FtcGxlLmR1cmF0aW9uID0gTWF0aC5yb3VuZCgocHRzIC0gbGFzdFBUUykgLyBzY2FsZUZhY3Rvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY29udGlndW91cyAmJiB0cmFjay5zZWdtZW50Q29kZWMgPT09ICdhYWMnKSB7XG4gICAgICAgICAgLy8gc2V0IFBUUy9EVFMgdG8gZXhwZWN0ZWQgUFRTL0RUU1xuICAgICAgICAgIHB0cyA9IG5leHRBdWRpb1RzICsgaW5pdFRpbWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtZW1iZXIgZmlyc3QgUFRTIG9mIG91ciBhdWRpb1NhbXBsZXNcbiAgICAgICAgZmlyc3RQVFMgPSBwdHM7XG4gICAgICAgIGlmIChtZGF0U2l6ZSA+IDApIHtcbiAgICAgICAgICAvKiBjb25jYXRlbmF0ZSB0aGUgYXVkaW8gZGF0YSBhbmQgY29uc3RydWN0IHRoZSBtZGF0IGluIHBsYWNlXG4gICAgICAgICAgICAobmVlZCA4IG1vcmUgYnl0ZXMgdG8gZmlsbCBsZW5ndGggYW5kIG1kYXQgdHlwZSkgKi9cbiAgICAgICAgICBtZGF0U2l6ZSArPSBvZmZzZXQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1kYXQgPSBuZXcgVWludDhBcnJheShtZGF0U2l6ZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLmVtaXQoRXZlbnRzLkVSUk9SLCBFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NVVhfRVJST1IsXG4gICAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5SRU1VWF9BTExPQ19FUlJPUixcbiAgICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgICBlcnJvcjogZXJyLFxuICAgICAgICAgICAgICBieXRlczogbWRhdFNpemUsXG4gICAgICAgICAgICAgIHJlYXNvbjogYGZhaWwgYWxsb2NhdGluZyBhdWRpbyBtZGF0ICR7bWRhdFNpemV9YFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmF3TVBFRykge1xuICAgICAgICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhtZGF0LmJ1ZmZlcik7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQzMigwLCBtZGF0U2l6ZSk7XG4gICAgICAgICAgICBtZGF0LnNldChNUDQudHlwZXMubWRhdCwgNCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG5vIGF1ZGlvIHNhbXBsZXNcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1kYXQuc2V0KHVuaXQsIG9mZnNldCk7XG4gICAgICBjb25zdCB1bml0TGVuID0gdW5pdC5ieXRlTGVuZ3RoO1xuICAgICAgb2Zmc2V0ICs9IHVuaXRMZW47XG4gICAgICAvLyBEZWZhdWx0IHRoZSBzYW1wbGUncyBkdXJhdGlvbiB0byB0aGUgY29tcHV0ZWQgbXA0U2FtcGxlRHVyYXRpb24sIHdoaWNoIHdpbGwgZWl0aGVyIGJlIDEwMjQgZm9yIEFBQyBvciAxMTUyIGZvciBNUEVHXG4gICAgICAvLyBJbiB0aGUgY2FzZSB0aGF0IHdlIGhhdmUgMSBzYW1wbGUsIHRoaXMgd2lsbCBiZSB0aGUgZHVyYXRpb24uIElmIHdlIGhhdmUgbW9yZSB0aGFuIG9uZSBzYW1wbGUsIHRoZSBkdXJhdGlvblxuICAgICAgLy8gYmVjb21lcyB0aGUgUFRTIGRpZmYgd2l0aCB0aGUgcHJldmlvdXMgc2FtcGxlXG4gICAgICBvdXRwdXRTYW1wbGVzLnB1c2goY3JlYXRlTXA0U2FtcGxlKHRydWUsIG1wNFNhbXBsZUR1cmF0aW9uLCB1bml0TGVuLCAwKSk7XG4gICAgICBsYXN0UFRTID0gcHRzO1xuICAgIH1cblxuICAgIC8vIFdlIGNvdWxkIGVuZCB1cCB3aXRoIG5vIGF1ZGlvIHNhbXBsZXMgaWYgYWxsIGlucHV0IHNhbXBsZXMgd2VyZSBvdmVybGFwcGluZyB3aXRoIHRoZSBwcmV2aW91c2x5IHJlbXV4ZWQgb25lc1xuICAgIGNvbnN0IG5iU2FtcGxlcyA9IG91dHB1dFNhbXBsZXMubGVuZ3RoO1xuICAgIGlmICghbmJTYW1wbGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVGhlIG5leHQgYXVkaW8gc2FtcGxlIFBUUyBzaG91bGQgYmUgZXF1YWwgdG8gbGFzdCBzYW1wbGUgUFRTICsgZHVyYXRpb25cbiAgICBjb25zdCBsYXN0U2FtcGxlID0gb3V0cHV0U2FtcGxlc1tvdXRwdXRTYW1wbGVzLmxlbmd0aCAtIDFdO1xuICAgIG5leHRBdWRpb1RzID0gbGFzdFBUUyAtIGluaXRUaW1lO1xuICAgIHRoaXMubmV4dEF1ZGlvVHMgPSBuZXh0QXVkaW9UcyArIHNjYWxlRmFjdG9yICogbGFzdFNhbXBsZS5kdXJhdGlvbjtcblxuICAgIC8vIFNldCB0aGUgdHJhY2sgc2FtcGxlcyBmcm9tIGlucHV0U2FtcGxlcyB0byBvdXRwdXRTYW1wbGVzIGJlZm9yZSByZW11eGluZ1xuICAgIGNvbnN0IG1vb2YgPSByYXdNUEVHID8gbmV3IFVpbnQ4QXJyYXkoMCkgOiBNUDQubW9vZih0cmFjay5zZXF1ZW5jZU51bWJlcisrLCBmaXJzdFBUUyAvIHNjYWxlRmFjdG9yLCBfZXh0ZW5kcyh7fSwgdHJhY2ssIHtcbiAgICAgIHNhbXBsZXM6IG91dHB1dFNhbXBsZXNcbiAgICB9KSk7XG5cbiAgICAvLyBDbGVhciB0aGUgdHJhY2sgc2FtcGxlcy4gVGhpcyBhbHNvIGNsZWFycyB0aGUgc2FtcGxlcyBhcnJheSBpbiB0aGUgZGVtdXhlciwgc2luY2UgdGhlIHJlZmVyZW5jZSBpcyBzaGFyZWRcbiAgICB0cmFjay5zYW1wbGVzID0gW107XG4gICAgY29uc3Qgc3RhcnQgPSAoZmlyc3RQVFMgLSBpbml0VGltZSkgLyBpbnB1dFRpbWVTY2FsZTtcbiAgICBjb25zdCBlbmQgPSBuZXh0QXVkaW9UcyAvIGlucHV0VGltZVNjYWxlO1xuICAgIGNvbnN0IHR5cGUgPSAnYXVkaW8nO1xuICAgIGNvbnN0IGF1ZGlvRGF0YSA9IHtcbiAgICAgIGRhdGExOiBtb29mLFxuICAgICAgZGF0YTI6IG1kYXQsXG4gICAgICBzdGFydFBUUzogc3RhcnQsXG4gICAgICBlbmRQVFM6IGVuZCxcbiAgICAgIHN0YXJ0RFRTOiBzdGFydCxcbiAgICAgIGVuZERUUzogZW5kLFxuICAgICAgdHlwZSxcbiAgICAgIGhhc0F1ZGlvOiB0cnVlLFxuICAgICAgaGFzVmlkZW86IGZhbHNlLFxuICAgICAgbmI6IG5iU2FtcGxlc1xuICAgIH07XG4gICAgdGhpcy5pc0F1ZGlvQ29udGlndW91cyA9IHRydWU7XG4gICAgcmV0dXJuIGF1ZGlvRGF0YTtcbiAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplUHRzKHZhbHVlLCByZWZlcmVuY2UpIHtcbiAgbGV0IG9mZnNldDtcbiAgaWYgKHJlZmVyZW5jZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAocmVmZXJlbmNlIDwgdmFsdWUpIHtcbiAgICAvLyAtIDJeMzNcbiAgICBvZmZzZXQgPSAtODU4OTkzNDU5MjtcbiAgfSBlbHNlIHtcbiAgICAvLyArIDJeMzNcbiAgICBvZmZzZXQgPSA4NTg5OTM0NTkyO1xuICB9XG4gIC8qIFBUUyBpcyAzM2JpdCAoZnJvbSAwIHRvIDJeMzMgLTEpXG4gICAgaWYgZGlmZiBiZXR3ZWVuIHZhbHVlIGFuZCByZWZlcmVuY2UgaXMgYmlnZ2VyIHRoYW4gaGFsZiBvZiB0aGUgYW1wbGl0dWRlICgyXjMyKSB0aGVuIGl0IG1lYW5zIHRoYXRcbiAgICBQVFMgbG9vcGluZyBvY2N1cmVkLiBmaWxsIHRoZSBnYXAgKi9cbiAgd2hpbGUgKE1hdGguYWJzKHZhbHVlIC0gcmVmZXJlbmNlKSA+IDQyOTQ5NjcyOTYpIHtcbiAgICB2YWx1ZSArPSBvZmZzZXQ7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZmluZEtleWZyYW1lSW5kZXgoc2FtcGxlcykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc2FtcGxlc1tpXS5rZXkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5mdW5jdGlvbiBmbHVzaFRleHRUcmFja01ldGFkYXRhQ3VlU2FtcGxlcyh0cmFjaywgdGltZU9mZnNldCwgaW5pdFBUUywgaW5pdERUUykge1xuICBjb25zdCBsZW5ndGggPSB0cmFjay5zYW1wbGVzLmxlbmd0aDtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaW5wdXRUaW1lU2NhbGUgPSB0cmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNvbnN0IHNhbXBsZSA9IHRyYWNrLnNhbXBsZXNbaW5kZXhdO1xuICAgIC8vIHNldHRpbmcgaWQzIHB0cywgZHRzIHRvIHJlbGF0aXZlIHRpbWVcbiAgICAvLyB1c2luZyB0aGlzLl9pbml0UFRTIGFuZCB0aGlzLl9pbml0RFRTIHRvIGNhbGN1bGF0ZSByZWxhdGl2ZSB0aW1lXG4gICAgc2FtcGxlLnB0cyA9IG5vcm1hbGl6ZVB0cyhzYW1wbGUucHRzIC0gaW5pdFBUUy5iYXNlVGltZSAqIGlucHV0VGltZVNjYWxlIC8gaW5pdFBUUy50aW1lc2NhbGUsIHRpbWVPZmZzZXQgKiBpbnB1dFRpbWVTY2FsZSkgLyBpbnB1dFRpbWVTY2FsZTtcbiAgICBzYW1wbGUuZHRzID0gbm9ybWFsaXplUHRzKHNhbXBsZS5kdHMgLSBpbml0RFRTLmJhc2VUaW1lICogaW5wdXRUaW1lU2NhbGUgLyBpbml0RFRTLnRpbWVzY2FsZSwgdGltZU9mZnNldCAqIGlucHV0VGltZVNjYWxlKSAvIGlucHV0VGltZVNjYWxlO1xuICB9XG4gIGNvbnN0IHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzO1xuICB0cmFjay5zYW1wbGVzID0gW107XG4gIHJldHVybiB7XG4gICAgc2FtcGxlc1xuICB9O1xufVxuZnVuY3Rpb24gZmx1c2hUZXh0VHJhY2tVc2VyZGF0YUN1ZVNhbXBsZXModHJhY2ssIHRpbWVPZmZzZXQsIGluaXRQVFMpIHtcbiAgY29uc3QgbGVuZ3RoID0gdHJhY2suc2FtcGxlcy5sZW5ndGg7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGlucHV0VGltZVNjYWxlID0gdHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBzYW1wbGUgPSB0cmFjay5zYW1wbGVzW2luZGV4XTtcbiAgICAvLyBzZXR0aW5nIHRleHQgcHRzLCBkdHMgdG8gcmVsYXRpdmUgdGltZVxuICAgIC8vIHVzaW5nIHRoaXMuX2luaXRQVFMgYW5kIHRoaXMuX2luaXREVFMgdG8gY2FsY3VsYXRlIHJlbGF0aXZlIHRpbWVcbiAgICBzYW1wbGUucHRzID0gbm9ybWFsaXplUHRzKHNhbXBsZS5wdHMgLSBpbml0UFRTLmJhc2VUaW1lICogaW5wdXRUaW1lU2NhbGUgLyBpbml0UFRTLnRpbWVzY2FsZSwgdGltZU9mZnNldCAqIGlucHV0VGltZVNjYWxlKSAvIGlucHV0VGltZVNjYWxlO1xuICB9XG4gIHRyYWNrLnNhbXBsZXMuc29ydCgoYSwgYikgPT4gYS5wdHMgLSBiLnB0cyk7XG4gIGNvbnN0IHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzO1xuICB0cmFjay5zYW1wbGVzID0gW107XG4gIHJldHVybiB7XG4gICAgc2FtcGxlc1xuICB9O1xufVxuXG5jbGFzcyBQYXNzVGhyb3VnaFJlbXV4ZXIgZXh0ZW5kcyBMb2dnZXIge1xuICBjb25zdHJ1Y3RvcihvYnNlcnZlciwgY29uZmlnLCB0eXBlU3VwcG9ydGVkLCBsb2dnZXIpIHtcbiAgICBzdXBlcigncGFzc3Rocm91Z2gtcmVtdXhlcicsIGxvZ2dlcik7XG4gICAgdGhpcy5lbWl0SW5pdFNlZ21lbnQgPSBmYWxzZTtcbiAgICB0aGlzLmF1ZGlvQ29kZWMgPSB2b2lkIDA7XG4gICAgdGhpcy52aWRlb0NvZGVjID0gdm9pZCAwO1xuICAgIHRoaXMuaW5pdERhdGEgPSB2b2lkIDA7XG4gICAgdGhpcy5pbml0UFRTID0gbnVsbDtcbiAgICB0aGlzLmluaXRUcmFja3MgPSB2b2lkIDA7XG4gICAgdGhpcy5sYXN0RW5kVGltZSA9IG51bGw7XG4gICAgdGhpcy5pc1ZpZGVvQ29udGlndW91cyA9IGZhbHNlO1xuICB9XG4gIGRlc3Ryb3koKSB7fVxuICByZXNldFRpbWVTdGFtcChkZWZhdWx0SW5pdFBUUykge1xuICAgIHRoaXMubGFzdEVuZFRpbWUgPSBudWxsO1xuICAgIGNvbnN0IGluaXRQVFMgPSB0aGlzLmluaXRQVFM7XG4gICAgaWYgKGluaXRQVFMgJiYgZGVmYXVsdEluaXRQVFMpIHtcbiAgICAgIGlmIChpbml0UFRTLmJhc2VUaW1lID09PSBkZWZhdWx0SW5pdFBUUy5iYXNlVGltZSAmJiBpbml0UFRTLnRpbWVzY2FsZSA9PT0gZGVmYXVsdEluaXRQVFMudGltZXNjYWxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5pbml0UFRTID0gZGVmYXVsdEluaXRQVFM7XG4gIH1cbiAgcmVzZXROZXh0VGltZXN0YW1wKCkge1xuICAgIHRoaXMuaXNWaWRlb0NvbnRpZ3VvdXMgPSBmYWxzZTtcbiAgICB0aGlzLmxhc3RFbmRUaW1lID0gbnVsbDtcbiAgfVxuICByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBkZWNyeXB0ZGF0YSkge1xuICAgIHRoaXMuYXVkaW9Db2RlYyA9IGF1ZGlvQ29kZWM7XG4gICAgdGhpcy52aWRlb0NvZGVjID0gdmlkZW9Db2RlYztcbiAgICB0aGlzLmdlbmVyYXRlSW5pdFNlZ21lbnQocGF0Y2hFbmN5cHRpb25EYXRhKGluaXRTZWdtZW50LCBkZWNyeXB0ZGF0YSkpO1xuICAgIHRoaXMuZW1pdEluaXRTZWdtZW50ID0gdHJ1ZTtcbiAgfVxuICBnZW5lcmF0ZUluaXRTZWdtZW50KGluaXRTZWdtZW50KSB7XG4gICAgbGV0IHtcbiAgICAgIGF1ZGlvQ29kZWMsXG4gICAgICB2aWRlb0NvZGVjXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCEoaW5pdFNlZ21lbnQgIT0gbnVsbCAmJiBpbml0U2VnbWVudC5ieXRlTGVuZ3RoKSkge1xuICAgICAgdGhpcy5pbml0VHJhY2tzID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5pbml0RGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5pdERhdGEgPSB0aGlzLmluaXREYXRhID0gcGFyc2VJbml0U2VnbWVudChpbml0U2VnbWVudCk7XG5cbiAgICAvLyBHZXQgY29kZWMgZnJvbSBpbml0U2VnbWVudFxuICAgIGlmIChpbml0RGF0YS5hdWRpbykge1xuICAgICAgYXVkaW9Db2RlYyA9IGdldFBhcnNlZFRyYWNrQ29kZWMoaW5pdERhdGEuYXVkaW8sIEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJTywgdGhpcyk7XG4gICAgfVxuICAgIGlmIChpbml0RGF0YS52aWRlbykge1xuICAgICAgdmlkZW9Db2RlYyA9IGdldFBhcnNlZFRyYWNrQ29kZWMoaW5pdERhdGEudmlkZW8sIEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFTywgdGhpcyk7XG4gICAgfVxuICAgIGNvbnN0IHRyYWNrcyA9IHt9O1xuICAgIGlmIChpbml0RGF0YS5hdWRpbyAmJiBpbml0RGF0YS52aWRlbykge1xuICAgICAgdHJhY2tzLmF1ZGlvdmlkZW8gPSB7XG4gICAgICAgIGNvbnRhaW5lcjogJ3ZpZGVvL21wNCcsXG4gICAgICAgIGNvZGVjOiBhdWRpb0NvZGVjICsgJywnICsgdmlkZW9Db2RlYyxcbiAgICAgICAgc3VwcGxlbWVudGFsOiBpbml0RGF0YS52aWRlby5zdXBwbGVtZW50YWwsXG4gICAgICAgIGluaXRTZWdtZW50LFxuICAgICAgICBpZDogJ21haW4nXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoaW5pdERhdGEuYXVkaW8pIHtcbiAgICAgIHRyYWNrcy5hdWRpbyA9IHtcbiAgICAgICAgY29udGFpbmVyOiAnYXVkaW8vbXA0JyxcbiAgICAgICAgY29kZWM6IGF1ZGlvQ29kZWMsXG4gICAgICAgIGluaXRTZWdtZW50LFxuICAgICAgICBpZDogJ2F1ZGlvJ1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGluaXREYXRhLnZpZGVvKSB7XG4gICAgICB0cmFja3MudmlkZW8gPSB7XG4gICAgICAgIGNvbnRhaW5lcjogJ3ZpZGVvL21wNCcsXG4gICAgICAgIGNvZGVjOiB2aWRlb0NvZGVjLFxuICAgICAgICBzdXBwbGVtZW50YWw6IGluaXREYXRhLnZpZGVvLnN1cHBsZW1lbnRhbCxcbiAgICAgICAgaW5pdFNlZ21lbnQsXG4gICAgICAgIGlkOiAnbWFpbidcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2FybignaW5pdFNlZ21lbnQgZG9lcyBub3QgY29udGFpbiBtb292IG9yIHRyYWsgYm94ZXMuJyk7XG4gICAgfVxuICAgIHRoaXMuaW5pdFRyYWNrcyA9IHRyYWNrcztcbiAgfVxuICByZW11eChhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQpIHtcbiAgICB2YXIgX2luaXREYXRhLCBfaW5pdERhdGEyO1xuICAgIGxldCB7XG4gICAgICBpbml0UFRTLFxuICAgICAgbGFzdEVuZFRpbWVcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBhdWRpbzogdW5kZWZpbmVkLFxuICAgICAgdmlkZW86IHVuZGVmaW5lZCxcbiAgICAgIHRleHQ6IHRleHRUcmFjayxcbiAgICAgIGlkMzogaWQzVHJhY2ssXG4gICAgICBpbml0U2VnbWVudDogdW5kZWZpbmVkXG4gICAgfTtcblxuICAgIC8vIElmIHdlIGhhdmVuJ3QgeWV0IHNldCBhIGxhc3RFbmREVFMsIG9yIGl0IHdhcyByZXNldCwgc2V0IGl0IHRvIHRoZSBwcm92aWRlZCB0aW1lT2Zmc2V0LiBXZSB3YW50IHRvIHVzZSB0aGVcbiAgICAvLyBsYXN0RW5kRFRTIG92ZXIgdGltZU9mZnNldCB3aGVuZXZlciBwb3NzaWJsZTsgZHVyaW5nIHByb2dyZXNzaXZlIHBsYXliYWNrLCB0aGUgbWVkaWEgc291cmNlIHdpbGwgbm90IHVwZGF0ZVxuICAgIC8vIHRoZSBtZWRpYSBkdXJhdGlvbiAod2hpY2ggaXMgd2hhdCB0aW1lT2Zmc2V0IGlzIHByb3ZpZGVkIGFzKSBiZWZvcmUgd2UgbmVlZCB0byBwcm9jZXNzIHRoZSBuZXh0IGNodW5rLlxuICAgIGlmICghaXNGaW5pdGVOdW1iZXIobGFzdEVuZFRpbWUpKSB7XG4gICAgICBsYXN0RW5kVGltZSA9IHRoaXMubGFzdEVuZFRpbWUgPSB0aW1lT2Zmc2V0IHx8IDA7XG4gICAgfVxuXG4gICAgLy8gVGhlIGJpbmFyeSBzZWdtZW50IGRhdGEgaXMgYWRkZWQgdG8gdGhlIHZpZGVvVHJhY2sgaW4gdGhlIG1wNGRlbXV4ZXIuIFdlIGRvbid0IGNoZWNrIHRvIHNlZSBpZiB0aGUgZGF0YSBpcyBvbmx5XG4gICAgLy8gYXVkaW8gb3IgdmlkZW8gKG9yIGJvdGgpOyBhZGRpbmcgaXQgdG8gdmlkZW8gd2FzIGFuIGFyYml0cmFyeSBjaG9pY2UuXG4gICAgY29uc3QgZGF0YSA9IHZpZGVvVHJhY2suc2FtcGxlcztcbiAgICBpZiAoIShkYXRhICE9IG51bGwgJiYgZGF0YS5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCBpbml0U2VnbWVudCA9IHtcbiAgICAgIGluaXRQVFM6IHVuZGVmaW5lZCxcbiAgICAgIHRpbWVzY2FsZTogdW5kZWZpbmVkLFxuICAgICAgdHJhY2tJZDogdW5kZWZpbmVkXG4gICAgfTtcbiAgICBsZXQgaW5pdERhdGEgPSB0aGlzLmluaXREYXRhO1xuICAgIGlmICghKChfaW5pdERhdGEgPSBpbml0RGF0YSkgIT0gbnVsbCAmJiBfaW5pdERhdGEubGVuZ3RoKSkge1xuICAgICAgdGhpcy5nZW5lcmF0ZUluaXRTZWdtZW50KGRhdGEpO1xuICAgICAgaW5pdERhdGEgPSB0aGlzLmluaXREYXRhO1xuICAgIH1cbiAgICBpZiAoISgoX2luaXREYXRhMiA9IGluaXREYXRhKSAhPSBudWxsICYmIF9pbml0RGF0YTIubGVuZ3RoKSkge1xuICAgICAgLy8gV2UgY2FuJ3QgcmVtdXggaWYgdGhlIGluaXRTZWdtZW50IGNvdWxkIG5vdCBiZSBnZW5lcmF0ZWRcbiAgICAgIHRoaXMud2FybignRmFpbGVkIHRvIGdlbmVyYXRlIGluaXRTZWdtZW50LicpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHRoaXMuZW1pdEluaXRTZWdtZW50KSB7XG4gICAgICBpbml0U2VnbWVudC50cmFja3MgPSB0aGlzLmluaXRUcmFja3M7XG4gICAgICB0aGlzLmVtaXRJbml0U2VnbWVudCA9IGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB0cmFja1NhbXBsZURhdGEgPSBnZXRTYW1wbGVEYXRhKGRhdGEsIGluaXREYXRhLCB0aGlzKTtcbiAgICBjb25zdCBhdWRpb1NhbXBsZVRpbWVzdGFtcHMgPSBpbml0RGF0YS5hdWRpbyA/IHRyYWNrU2FtcGxlRGF0YVtpbml0RGF0YS5hdWRpby5pZF0gOiBudWxsO1xuICAgIGNvbnN0IHZpZGVvU2FtcGxlVGltZXN0YW1wcyA9IGluaXREYXRhLnZpZGVvID8gdHJhY2tTYW1wbGVEYXRhW2luaXREYXRhLnZpZGVvLmlkXSA6IG51bGw7XG4gICAgY29uc3QgdmlkZW9TdGFydFRpbWUgPSB0b1N0YXJ0RW5kT3JEZWZhdWx0KHZpZGVvU2FtcGxlVGltZXN0YW1wcywgSW5maW5pdHkpO1xuICAgIGNvbnN0IGF1ZGlvU3RhcnRUaW1lID0gdG9TdGFydEVuZE9yRGVmYXVsdChhdWRpb1NhbXBsZVRpbWVzdGFtcHMsIEluZmluaXR5KTtcbiAgICBjb25zdCB2aWRlb0VuZFRpbWUgPSB0b1N0YXJ0RW5kT3JEZWZhdWx0KHZpZGVvU2FtcGxlVGltZXN0YW1wcywgMCwgdHJ1ZSk7XG4gICAgY29uc3QgYXVkaW9FbmRUaW1lID0gdG9TdGFydEVuZE9yRGVmYXVsdChhdWRpb1NhbXBsZVRpbWVzdGFtcHMsIDAsIHRydWUpO1xuICAgIGxldCBiYXNlT2Zmc2V0U2FtcGxlcztcbiAgICBsZXQgZGVjb2RlVGltZSA9IHRpbWVPZmZzZXQ7XG4gICAgbGV0IGR1cmF0aW9uID0gMDtcbiAgICBpZiAoYXVkaW9TYW1wbGVUaW1lc3RhbXBzICYmICghdmlkZW9TYW1wbGVUaW1lc3RhbXBzIHx8ICFpbml0UFRTICYmIGF1ZGlvU3RhcnRUaW1lIDwgdmlkZW9TdGFydFRpbWUgfHwgaW5pdFBUUyAmJiBpbml0UFRTLnRyYWNrSWQgPT09IGluaXREYXRhLmF1ZGlvLmlkKSkge1xuICAgICAgaW5pdFNlZ21lbnQudHJhY2tJZCA9IGluaXREYXRhLmF1ZGlvLmlkO1xuICAgICAgYmFzZU9mZnNldFNhbXBsZXMgPSBhdWRpb1NhbXBsZVRpbWVzdGFtcHM7XG4gICAgICBkdXJhdGlvbiA9IGF1ZGlvRW5kVGltZSAtIGF1ZGlvU3RhcnRUaW1lO1xuICAgIH0gZWxzZSBpZiAodmlkZW9TYW1wbGVUaW1lc3RhbXBzKSB7XG4gICAgICBpbml0U2VnbWVudC50cmFja0lkID0gaW5pdERhdGEudmlkZW8uaWQ7XG4gICAgICBiYXNlT2Zmc2V0U2FtcGxlcyA9IHZpZGVvU2FtcGxlVGltZXN0YW1wcztcbiAgICAgIGR1cmF0aW9uID0gdmlkZW9FbmRUaW1lIC0gdmlkZW9TdGFydFRpbWU7XG4gICAgfVxuICAgIGlmIChiYXNlT2Zmc2V0U2FtcGxlcykge1xuICAgICAgY29uc3QgdGltZXNjYWxlID0gYmFzZU9mZnNldFNhbXBsZXMudGltZXNjYWxlO1xuICAgICAgZGVjb2RlVGltZSA9IGJhc2VPZmZzZXRTYW1wbGVzLnN0YXJ0IC8gdGltZXNjYWxlO1xuICAgICAgaW5pdFNlZ21lbnQuaW5pdFBUUyA9IGJhc2VPZmZzZXRTYW1wbGVzLnN0YXJ0IC0gdGltZU9mZnNldCAqIHRpbWVzY2FsZTtcbiAgICAgIGluaXRTZWdtZW50LnRpbWVzY2FsZSA9IHRpbWVzY2FsZTtcbiAgICAgIGlmICghaW5pdFBUUykge1xuICAgICAgICB0aGlzLmluaXRQVFMgPSBpbml0UFRTID0ge1xuICAgICAgICAgIGJhc2VUaW1lOiBpbml0U2VnbWVudC5pbml0UFRTLFxuICAgICAgICAgIHRpbWVzY2FsZSxcbiAgICAgICAgICB0cmFja0lkOiBpbml0U2VnbWVudC50cmFja0lkXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgoYWNjdXJhdGVUaW1lT2Zmc2V0IHx8ICFpbml0UFRTKSAmJiAoaXNJbnZhbGlkSW5pdFB0cyhpbml0UFRTLCBkZWNvZGVUaW1lLCB0aW1lT2Zmc2V0LCBkdXJhdGlvbikgfHwgaW5pdFNlZ21lbnQudGltZXNjYWxlICE9PSBpbml0UFRTLnRpbWVzY2FsZSkpIHtcbiAgICAgIGluaXRTZWdtZW50LmluaXRQVFMgPSBkZWNvZGVUaW1lIC0gdGltZU9mZnNldDtcbiAgICAgIGluaXRTZWdtZW50LnRpbWVzY2FsZSA9IDE7XG4gICAgICBpZiAoaW5pdFBUUyAmJiBpbml0UFRTLnRpbWVzY2FsZSA9PT0gMSkge1xuICAgICAgICB0aGlzLndhcm4oYEFkanVzdGluZyBpbml0UFRTIEAke3RpbWVPZmZzZXR9IGZyb20gJHtpbml0UFRTLmJhc2VUaW1lIC8gaW5pdFBUUy50aW1lc2NhbGV9IHRvICR7aW5pdFNlZ21lbnQuaW5pdFBUU31gKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5pdFBUUyA9IGluaXRQVFMgPSB7XG4gICAgICAgIGJhc2VUaW1lOiBpbml0U2VnbWVudC5pbml0UFRTLFxuICAgICAgICB0aW1lc2NhbGU6IDFcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IGF1ZGlvVHJhY2sgPyBkZWNvZGVUaW1lIC0gaW5pdFBUUy5iYXNlVGltZSAvIGluaXRQVFMudGltZXNjYWxlIDogbGFzdEVuZFRpbWU7XG4gICAgY29uc3QgZW5kVGltZSA9IHN0YXJ0VGltZSArIGR1cmF0aW9uO1xuICAgIGlmIChkdXJhdGlvbiA+IDApIHtcbiAgICAgIHRoaXMubGFzdEVuZFRpbWUgPSBlbmRUaW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndhcm4oJ0R1cmF0aW9uIHBhcnNlZCBmcm9tIG1wNCBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIHplcm8nKTtcbiAgICAgIHRoaXMucmVzZXROZXh0VGltZXN0YW1wKCk7XG4gICAgfVxuICAgIGNvbnN0IGhhc0F1ZGlvID0gISFpbml0RGF0YS5hdWRpbztcbiAgICBjb25zdCBoYXNWaWRlbyA9ICEhaW5pdERhdGEudmlkZW87XG4gICAgbGV0IHR5cGUgPSAnJztcbiAgICBpZiAoaGFzQXVkaW8pIHtcbiAgICAgIHR5cGUgKz0gJ2F1ZGlvJztcbiAgICB9XG4gICAgaWYgKGhhc1ZpZGVvKSB7XG4gICAgICB0eXBlICs9ICd2aWRlbyc7XG4gICAgfVxuICAgIGNvbnN0IHRyYWNrID0ge1xuICAgICAgZGF0YTE6IGRhdGEsXG4gICAgICBzdGFydFBUUzogc3RhcnRUaW1lLFxuICAgICAgc3RhcnREVFM6IHN0YXJ0VGltZSxcbiAgICAgIGVuZFBUUzogZW5kVGltZSxcbiAgICAgIGVuZERUUzogZW5kVGltZSxcbiAgICAgIHR5cGUsXG4gICAgICBoYXNBdWRpbyxcbiAgICAgIGhhc1ZpZGVvLFxuICAgICAgbmI6IDEsXG4gICAgICBkcm9wcGVkOiAwXG4gICAgfTtcbiAgICByZXN1bHQuYXVkaW8gPSBoYXNBdWRpbyAmJiAhaGFzVmlkZW8gPyB0cmFjayA6IHVuZGVmaW5lZDtcbiAgICByZXN1bHQudmlkZW8gPSBoYXNWaWRlbyA/IHRyYWNrIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHZpZGVvU2FtcGxlQ291bnQgPSB2aWRlb1NhbXBsZVRpbWVzdGFtcHMgPT0gbnVsbCA/IHZvaWQgMCA6IHZpZGVvU2FtcGxlVGltZXN0YW1wcy5zYW1wbGVDb3VudDtcbiAgICBpZiAodmlkZW9TYW1wbGVDb3VudCkge1xuICAgICAgY29uc3QgZmlyc3RLZXlGcmFtZSA9IHZpZGVvU2FtcGxlVGltZXN0YW1wcy5rZXlGcmFtZUluZGV4O1xuICAgICAgY29uc3QgaW5kZXBlbmRlbnQgPSBmaXJzdEtleUZyYW1lICE9PSAtMTtcbiAgICAgIHRyYWNrLm5iID0gdmlkZW9TYW1wbGVDb3VudDtcbiAgICAgIHRyYWNrLmRyb3BwZWQgPSBmaXJzdEtleUZyYW1lID09PSAwIHx8IHRoaXMuaXNWaWRlb0NvbnRpZ3VvdXMgPyAwIDogaW5kZXBlbmRlbnQgPyBmaXJzdEtleUZyYW1lIDogdmlkZW9TYW1wbGVDb3VudDtcbiAgICAgIHRyYWNrLmluZGVwZW5kZW50ID0gaW5kZXBlbmRlbnQ7XG4gICAgICB0cmFjay5maXJzdEtleUZyYW1lID0gZmlyc3RLZXlGcmFtZTtcbiAgICAgIGlmIChpbmRlcGVuZGVudCAmJiB2aWRlb1NhbXBsZVRpbWVzdGFtcHMua2V5RnJhbWVTdGFydCkge1xuICAgICAgICB0cmFjay5maXJzdEtleUZyYW1lUFRTID0gKHZpZGVvU2FtcGxlVGltZXN0YW1wcy5rZXlGcmFtZVN0YXJ0IC0gaW5pdFBUUy5iYXNlVGltZSkgLyBpbml0UFRTLnRpbWVzY2FsZTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5pc1ZpZGVvQ29udGlndW91cykge1xuICAgICAgICByZXN1bHQuaW5kZXBlbmRlbnQgPSBpbmRlcGVuZGVudDtcbiAgICAgIH1cbiAgICAgIHRoaXMuaXNWaWRlb0NvbnRpZ3VvdXMgfHwgKHRoaXMuaXNWaWRlb0NvbnRpZ3VvdXMgPSBpbmRlcGVuZGVudCk7XG4gICAgICBpZiAodHJhY2suZHJvcHBlZCkge1xuICAgICAgICB0aGlzLndhcm4oYGZtcDQgZG9lcyBub3Qgc3RhcnQgd2l0aCBJRFI6IGZpcnN0SURSICR7Zmlyc3RLZXlGcmFtZX0vJHt2aWRlb1NhbXBsZUNvdW50fSBkcm9wcGVkOiAke3RyYWNrLmRyb3BwZWR9IHN0YXJ0OiAke3RyYWNrLmZpcnN0S2V5RnJhbWVQVFMgfHwgJ05BJ31gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LmluaXRTZWdtZW50ID0gaW5pdFNlZ21lbnQ7XG4gICAgcmVzdWx0LmlkMyA9IGZsdXNoVGV4dFRyYWNrTWV0YWRhdGFDdWVTYW1wbGVzKGlkM1RyYWNrLCB0aW1lT2Zmc2V0LCBpbml0UFRTLCBpbml0UFRTKTtcbiAgICBpZiAodGV4dFRyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICByZXN1bHQudGV4dCA9IGZsdXNoVGV4dFRyYWNrVXNlcmRhdGFDdWVTYW1wbGVzKHRleHRUcmFjaywgdGltZU9mZnNldCwgaW5pdFBUUyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHRvU3RhcnRFbmRPckRlZmF1bHQodHJhY2tUaW1lcywgZGVmYXVsdFZhbHVlLCBlbmQgPSBmYWxzZSkge1xuICByZXR1cm4gKHRyYWNrVGltZXMgPT0gbnVsbCA/IHZvaWQgMCA6IHRyYWNrVGltZXMuc3RhcnQpICE9PSB1bmRlZmluZWQgPyAodHJhY2tUaW1lcy5zdGFydCArIChlbmQgPyB0cmFja1RpbWVzLmR1cmF0aW9uIDogMCkpIC8gdHJhY2tUaW1lcy50aW1lc2NhbGUgOiBkZWZhdWx0VmFsdWU7XG59XG5mdW5jdGlvbiBpc0ludmFsaWRJbml0UHRzKGluaXRQVFMsIHN0YXJ0RFRTLCB0aW1lT2Zmc2V0LCBkdXJhdGlvbikge1xuICBpZiAoaW5pdFBUUyA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIEluaXRQVFMgaXMgaW52YWxpZCB3aGVuIGRpc3RhbmNlIGZyb20gcHJvZ3JhbSB3b3VsZCBiZSBtb3JlIHRoYW4gc2VnbWVudCBkdXJhdGlvbiBvciBhIG1pbmltdW0gb2Ygb25lIHNlY29uZFxuICBjb25zdCBtaW5EdXJhdGlvbiA9IE1hdGgubWF4KGR1cmF0aW9uLCAxKTtcbiAgY29uc3Qgc3RhcnRUaW1lID0gc3RhcnREVFMgLSBpbml0UFRTLmJhc2VUaW1lIC8gaW5pdFBUUy50aW1lc2NhbGU7XG4gIHJldHVybiBNYXRoLmFicyhzdGFydFRpbWUgLSB0aW1lT2Zmc2V0KSA+IG1pbkR1cmF0aW9uO1xufVxuZnVuY3Rpb24gZ2V0UGFyc2VkVHJhY2tDb2RlYyh0cmFjaywgdHlwZSwgbG9nZ2VyKSB7XG4gIGNvbnN0IHBhcnNlZENvZGVjID0gdHJhY2sgPT0gbnVsbCA/IHZvaWQgMCA6IHRyYWNrLmNvZGVjO1xuICBpZiAocGFyc2VkQ29kZWMgJiYgcGFyc2VkQ29kZWMubGVuZ3RoID4gNCkge1xuICAgIHJldHVybiBwYXJzZWRDb2RlYztcbiAgfVxuICBpZiAodHlwZSA9PT0gRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPKSB7XG4gICAgaWYgKHBhcnNlZENvZGVjID09PSAnZWMtMycgfHwgcGFyc2VkQ29kZWMgPT09ICdhYy0zJyB8fCBwYXJzZWRDb2RlYyA9PT0gJ2FsYWMnKSB7XG4gICAgICByZXR1cm4gcGFyc2VkQ29kZWM7XG4gICAgfVxuICAgIGlmIChwYXJzZWRDb2RlYyA9PT0gJ2ZMYUMnIHx8IHBhcnNlZENvZGVjID09PSAnT3B1cycpIHtcbiAgICAgIC8vIE9wdGluZyBub3QgdG8gZ2V0IGBwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2VgIGZyb20gcGxheWVyIGNvbmZpZyBmb3IgaXNTdXBwb3J0ZWQoKSBjaGVjayBmb3Igc2ltcGxpY2l0eVxuICAgICAgY29uc3QgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlID0gZmFsc2U7XG4gICAgICByZXR1cm4gZ2V0Q29kZWNDb21wYXRpYmxlTmFtZShwYXJzZWRDb2RlYywgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlKTtcbiAgICB9XG4gICAgbG9nZ2VyLndhcm4oYFVuaGFuZGxlZCBhdWRpbyBjb2RlYyBcIiR7cGFyc2VkQ29kZWN9XCIgaW4gbXA0IE1BUGApO1xuICAgIHJldHVybiBwYXJzZWRDb2RlYyB8fCAnbXA0YSc7XG4gIH1cbiAgLy8gUHJvdmlkZSBkZWZhdWx0cyBiYXNlZCBvbiBjb2RlYyB0eXBlXG4gIC8vIFRoaXMgYWxsb3dzIGZvciBzb21lIHBsYXliYWNrIG9mIHNvbWUgZm1wNCBwbGF5bGlzdHMgd2l0aG91dCBDT0RFQ1MgZGVmaW5lZCBpbiBtYW5pZmVzdFxuICBsb2dnZXIud2FybihgVW5oYW5kbGVkIHZpZGVvIGNvZGVjIFwiJHtwYXJzZWRDb2RlY31cIiBpbiBtcDQgTUFQYCk7XG4gIHJldHVybiBwYXJzZWRDb2RlYyB8fCAnYXZjMSc7XG59XG5cbmxldCBub3c7XG4vLyBwZXJmb3JtYW5jZS5ub3coKSBub3QgYXZhaWxhYmxlIG9uIFdlYldvcmtlciwgYXQgbGVhc3Qgb24gU2FmYXJpIERlc2t0b3BcbnRyeSB7XG4gIG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93LmJpbmQoc2VsZi5wZXJmb3JtYW5jZSk7XG59IGNhdGNoIChlcnIpIHtcbiAgbm93ID0gRGF0ZS5ub3c7XG59XG5jb25zdCBtdXhDb25maWcgPSBbe1xuICBkZW11eDogTVA0RGVtdXhlcixcbiAgcmVtdXg6IFBhc3NUaHJvdWdoUmVtdXhlclxufSwge1xuICBkZW11eDogVFNEZW11eGVyLFxuICByZW11eDogTVA0UmVtdXhlclxufSwge1xuICBkZW11eDogQUFDRGVtdXhlcixcbiAgcmVtdXg6IE1QNFJlbXV4ZXJcbn0sIHtcbiAgZGVtdXg6IE1QM0RlbXV4ZXIsXG4gIHJlbXV4OiBNUDRSZW11eGVyXG59XTtcbntcbiAgbXV4Q29uZmlnLnNwbGljZSgyLCAwLCB7XG4gICAgZGVtdXg6IEFDM0RlbXV4ZXIsXG4gICAgcmVtdXg6IE1QNFJlbXV4ZXJcbiAgfSk7XG59XG5jbGFzcyBUcmFuc211eGVyIHtcbiAgY29uc3RydWN0b3Iob2JzZXJ2ZXIsIHR5cGVTdXBwb3J0ZWQsIGNvbmZpZywgdmVuZG9yLCBpZCwgbG9nZ2VyKSB7XG4gICAgdGhpcy5hc3luY1Jlc3VsdCA9IGZhbHNlO1xuICAgIHRoaXMubG9nZ2VyID0gdm9pZCAwO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy50eXBlU3VwcG9ydGVkID0gdm9pZCAwO1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMuaWQgPSB2b2lkIDA7XG4gICAgdGhpcy5kZW11eGVyID0gdm9pZCAwO1xuICAgIHRoaXMucmVtdXhlciA9IHZvaWQgMDtcbiAgICB0aGlzLmRlY3J5cHRlciA9IHZvaWQgMDtcbiAgICB0aGlzLnByb2JlID0gdm9pZCAwO1xuICAgIHRoaXMuZGVjcnlwdGlvblByb21pc2UgPSBudWxsO1xuICAgIHRoaXMudHJhbnNtdXhDb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy5jdXJyZW50VHJhbnNtdXhTdGF0ZSA9IHZvaWQgMDtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy50eXBlU3VwcG9ydGVkID0gdHlwZVN1cHBvcnRlZDtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gIH1cbiAgY29uZmlndXJlKHRyYW5zbXV4Q29uZmlnKSB7XG4gICAgdGhpcy50cmFuc211eENvbmZpZyA9IHRyYW5zbXV4Q29uZmlnO1xuICAgIGlmICh0aGlzLmRlY3J5cHRlcikge1xuICAgICAgdGhpcy5kZWNyeXB0ZXIucmVzZXQoKTtcbiAgICB9XG4gIH1cbiAgcHVzaChkYXRhLCBkZWNyeXB0ZGF0YSwgY2h1bmtNZXRhLCBzdGF0ZSkge1xuICAgIGNvbnN0IHN0YXRzID0gY2h1bmtNZXRhLnRyYW5zbXV4aW5nO1xuICAgIHN0YXRzLmV4ZWN1dGVTdGFydCA9IG5vdygpO1xuICAgIGxldCB1aW50RGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICAgIGNvbnN0IHtcbiAgICAgIGN1cnJlbnRUcmFuc211eFN0YXRlLFxuICAgICAgdHJhbnNtdXhDb25maWdcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoc3RhdGUpIHtcbiAgICAgIHRoaXMuY3VycmVudFRyYW5zbXV4U3RhdGUgPSBzdGF0ZTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY29udGlndW91cyxcbiAgICAgIGRpc2NvbnRpbnVpdHksXG4gICAgICB0cmFja1N3aXRjaCxcbiAgICAgIGFjY3VyYXRlVGltZU9mZnNldCxcbiAgICAgIHRpbWVPZmZzZXQsXG4gICAgICBpbml0U2VnbWVudENoYW5nZVxuICAgIH0gPSBzdGF0ZSB8fCBjdXJyZW50VHJhbnNtdXhTdGF0ZTtcbiAgICBjb25zdCB7XG4gICAgICBhdWRpb0NvZGVjLFxuICAgICAgdmlkZW9Db2RlYyxcbiAgICAgIGRlZmF1bHRJbml0UHRzLFxuICAgICAgZHVyYXRpb24sXG4gICAgICBpbml0U2VnbWVudERhdGFcbiAgICB9ID0gdHJhbnNtdXhDb25maWc7XG4gICAgY29uc3Qga2V5RGF0YSA9IGdldEVuY3J5cHRpb25UeXBlKHVpbnREYXRhLCBkZWNyeXB0ZGF0YSk7XG4gICAgaWYgKGtleURhdGEgJiYgaXNGdWxsU2VnbWVudEVuY3J5cHRpb24oa2V5RGF0YS5tZXRob2QpKSB7XG4gICAgICBjb25zdCBkZWNyeXB0ZXIgPSB0aGlzLmdldERlY3J5cHRlcigpO1xuICAgICAgY29uc3QgYWVzTW9kZSA9IGdldEFlc01vZGVGcm9tRnVsbFNlZ21lbnRNZXRob2Qoa2V5RGF0YS5tZXRob2QpO1xuXG4gICAgICAvLyBTb2Z0d2FyZSBkZWNyeXB0aW9uIGlzIHN5bmNocm9ub3VzOyB3ZWJDcnlwdG8gaXMgbm90XG4gICAgICBpZiAoZGVjcnlwdGVyLmlzU3luYygpKSB7XG4gICAgICAgIC8vIFNvZnR3YXJlIGRlY3J5cHRpb24gaXMgcHJvZ3Jlc3NpdmUuIFByb2dyZXNzaXZlIGRlY3J5cHRpb24gbWF5IG5vdCByZXR1cm4gYSByZXN1bHQgb24gZWFjaCBjYWxsLiBBbnkgY2FjaGVkXG4gICAgICAgIC8vIGRhdGEgaXMgaGFuZGxlZCBpbiB0aGUgZmx1c2goKSBjYWxsXG4gICAgICAgIGxldCBkZWNyeXB0ZWREYXRhID0gZGVjcnlwdGVyLnNvZnR3YXJlRGVjcnlwdCh1aW50RGF0YSwga2V5RGF0YS5rZXkuYnVmZmVyLCBrZXlEYXRhLml2LmJ1ZmZlciwgYWVzTW9kZSk7XG4gICAgICAgIC8vIEZvciBMb3ctTGF0ZW5jeSBITFMgUGFydHMsIGRlY3J5cHQgaW4gcGxhY2UsIHNpbmNlIHBhcnQgcGFyc2luZyBpcyBleHBlY3RlZCBvbiBwdXNoIHByb2dyZXNzXG4gICAgICAgIGNvbnN0IGxvYWRpbmdQYXJ0cyA9IGNodW5rTWV0YS5wYXJ0ID4gLTE7XG4gICAgICAgIGlmIChsb2FkaW5nUGFydHMpIHtcbiAgICAgICAgICBjb25zdCBfZGF0YSA9IGRlY3J5cHRlci5mbHVzaCgpO1xuICAgICAgICAgIGRlY3J5cHRlZERhdGEgPSBfZGF0YSA/IF9kYXRhLmJ1ZmZlciA6IF9kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVjcnlwdGVkRGF0YSkge1xuICAgICAgICAgIHN0YXRzLmV4ZWN1dGVFbmQgPSBub3coKTtcbiAgICAgICAgICByZXR1cm4gZW1wdHlSZXN1bHQoY2h1bmtNZXRhKTtcbiAgICAgICAgfVxuICAgICAgICB1aW50RGF0YSA9IG5ldyBVaW50OEFycmF5KGRlY3J5cHRlZERhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hc3luY1Jlc3VsdCA9IHRydWU7XG4gICAgICAgIHRoaXMuZGVjcnlwdGlvblByb21pc2UgPSBkZWNyeXB0ZXIud2ViQ3J5cHRvRGVjcnlwdCh1aW50RGF0YSwga2V5RGF0YS5rZXkuYnVmZmVyLCBrZXlEYXRhLml2LmJ1ZmZlciwgYWVzTW9kZSkudGhlbihkZWNyeXB0ZWREYXRhID0+IHtcbiAgICAgICAgICAvLyBDYWxsaW5nIHB1c2ggaGVyZSBpcyBpbXBvcnRhbnQ7IGlmIGZsdXNoKCkgaXMgY2FsbGVkIHdoaWxlIHRoaXMgaXMgc3RpbGwgcmVzb2x2aW5nLCB0aGlzIGVuc3VyZXMgdGhhdFxuICAgICAgICAgIC8vIHRoZSBkZWNyeXB0ZWQgZGF0YSBoYXMgYmVlbiB0cmFuc211eGVkXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5wdXNoKGRlY3J5cHRlZERhdGEsIG51bGwsIGNodW5rTWV0YSk7XG4gICAgICAgICAgdGhpcy5kZWNyeXB0aW9uUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmRlY3J5cHRpb25Qcm9taXNlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXNldE11eGVycyA9IHRoaXMubmVlZHNQcm9iaW5nKGRpc2NvbnRpbnVpdHksIHRyYWNrU3dpdGNoKTtcbiAgICBpZiAocmVzZXRNdXhlcnMpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jb25maWd1cmVUcmFuc211eGVyKHVpbnREYXRhKTtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBbdHJhbnNtdXhlcl0gJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB0aGlzLm9ic2VydmVyLmVtaXQoRXZlbnRzLkVSUk9SLCBFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsXG4gICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZVxuICAgICAgICB9KTtcbiAgICAgICAgc3RhdHMuZXhlY3V0ZUVuZCA9IG5vdygpO1xuICAgICAgICByZXR1cm4gZW1wdHlSZXN1bHQoY2h1bmtNZXRhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRpc2NvbnRpbnVpdHkgfHwgdHJhY2tTd2l0Y2ggfHwgaW5pdFNlZ21lbnRDaGFuZ2UgfHwgcmVzZXRNdXhlcnMpIHtcbiAgICAgIHRoaXMucmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudERhdGEsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGR1cmF0aW9uLCBkZWNyeXB0ZGF0YSk7XG4gICAgfVxuICAgIGlmIChkaXNjb250aW51aXR5IHx8IGluaXRTZWdtZW50Q2hhbmdlIHx8IHJlc2V0TXV4ZXJzKSB7XG4gICAgICB0aGlzLnJlc2V0SW5pdGlhbFRpbWVzdGFtcChkZWZhdWx0SW5pdFB0cyk7XG4gICAgfVxuICAgIGlmICghY29udGlndW91cykge1xuICAgICAgdGhpcy5yZXNldENvbnRpZ3VpdHkoKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy50cmFuc211eCh1aW50RGF0YSwga2V5RGF0YSwgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBjaHVua01ldGEpO1xuICAgIHRoaXMuYXN5bmNSZXN1bHQgPSBpc1Byb21pc2UocmVzdWx0KTtcbiAgICBjb25zdCBjdXJyZW50U3RhdGUgPSB0aGlzLmN1cnJlbnRUcmFuc211eFN0YXRlO1xuICAgIGN1cnJlbnRTdGF0ZS5jb250aWd1b3VzID0gdHJ1ZTtcbiAgICBjdXJyZW50U3RhdGUuZGlzY29udGludWl0eSA9IGZhbHNlO1xuICAgIGN1cnJlbnRTdGF0ZS50cmFja1N3aXRjaCA9IGZhbHNlO1xuICAgIHN0YXRzLmV4ZWN1dGVFbmQgPSBub3coKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gRHVlIHRvIGRhdGEgY2FjaGluZywgZmx1c2ggY2FsbHMgY2FuIHByb2R1Y2UgbW9yZSB0aGFuIG9uZSBUcmFuc211eGVyUmVzdWx0IChoZW5jZSB0aGUgQXJyYXkgdHlwZSlcbiAgZmx1c2goY2h1bmtNZXRhKSB7XG4gICAgY29uc3Qgc3RhdHMgPSBjaHVua01ldGEudHJhbnNtdXhpbmc7XG4gICAgc3RhdHMuZXhlY3V0ZVN0YXJ0ID0gbm93KCk7XG4gICAgY29uc3Qge1xuICAgICAgZGVjcnlwdGVyLFxuICAgICAgY3VycmVudFRyYW5zbXV4U3RhdGUsXG4gICAgICBkZWNyeXB0aW9uUHJvbWlzZVxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChkZWNyeXB0aW9uUHJvbWlzZSkge1xuICAgICAgdGhpcy5hc3luY1Jlc3VsdCA9IHRydWU7XG4gICAgICAvLyBVcG9uIHJlc29sdXRpb24sIHRoZSBkZWNyeXB0aW9uIHByb21pc2UgY2FsbHMgcHVzaCgpIGFuZCByZXR1cm5zIGl0cyBUcmFuc211eGVyUmVzdWx0IHVwIHRoZSBzdGFjay4gVGhlcmVmb3JlXG4gICAgICAvLyBvbmx5IGZsdXNoaW5nIGlzIHJlcXVpcmVkIGZvciBhc3luYyBkZWNyeXB0aW9uXG4gICAgICByZXR1cm4gZGVjcnlwdGlvblByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsdXNoKGNodW5rTWV0YSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgdHJhbnNtdXhSZXN1bHRzID0gW107XG4gICAgY29uc3Qge1xuICAgICAgdGltZU9mZnNldFxuICAgIH0gPSBjdXJyZW50VHJhbnNtdXhTdGF0ZTtcbiAgICBpZiAoZGVjcnlwdGVyKSB7XG4gICAgICAvLyBUaGUgZGVjcnlwdGVyIG1heSBoYXZlIGRhdGEgY2FjaGVkLCB3aGljaCBuZWVkcyB0byBiZSBkZW11eGVkLiBJbiB0aGlzIGNhc2Ugd2UnbGwgaGF2ZSB0d28gVHJhbnNtdXhSZXN1bHRzXG4gICAgICAvLyBUaGlzIGhhcHBlbnMgaW4gdGhlIGNhc2UgdGhhdCB3ZSByZWNlaXZlIG9ubHkgMSBwdXNoIGNhbGwgZm9yIGEgc2VnbWVudCAoZWl0aGVyIGZvciBub24tcHJvZ3Jlc3NpdmUgZG93bmxvYWRzLFxuICAgICAgLy8gb3IgZm9yIHByb2dyZXNzaXZlIGRvd25sb2FkcyB3aXRoIHNtYWxsIHNlZ21lbnRzKVxuICAgICAgY29uc3QgZGVjcnlwdGVkRGF0YSA9IGRlY3J5cHRlci5mbHVzaCgpO1xuICAgICAgaWYgKGRlY3J5cHRlZERhdGEpIHtcbiAgICAgICAgLy8gUHVzaCBhbHdheXMgcmV0dXJucyBhIFRyYW5zbXV4ZXJSZXN1bHQgaWYgZGVjcnlwdGRhdGEgaXMgbnVsbFxuICAgICAgICB0cmFuc211eFJlc3VsdHMucHVzaCh0aGlzLnB1c2goZGVjcnlwdGVkRGF0YS5idWZmZXIsIG51bGwsIGNodW5rTWV0YSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBkZW11eGVyLFxuICAgICAgcmVtdXhlclxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghZGVtdXhlciB8fCAhcmVtdXhlcikge1xuICAgICAgLy8gSWYgcHJvYmluZyBmYWlsZWQsIHRoZW4gSGxzLmpzIGhhcyBiZWVuIGdpdmVuIGNvbnRlbnQgaXRzIG5vdCBhYmxlIHRvIGhhbmRsZVxuICAgICAgc3RhdHMuZXhlY3V0ZUVuZCA9IG5vdygpO1xuICAgICAgY29uc3QgZW1wdHlSZXN1bHRzID0gW2VtcHR5UmVzdWx0KGNodW5rTWV0YSldO1xuICAgICAgaWYgKHRoaXMuYXN5bmNSZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShlbXB0eVJlc3VsdHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVtcHR5UmVzdWx0cztcbiAgICB9XG4gICAgY29uc3QgZGVtdXhSZXN1bHRPclByb21pc2UgPSBkZW11eGVyLmZsdXNoKHRpbWVPZmZzZXQpO1xuICAgIGlmIChpc1Byb21pc2UoZGVtdXhSZXN1bHRPclByb21pc2UpKSB7XG4gICAgICB0aGlzLmFzeW5jUmVzdWx0ID0gdHJ1ZTtcbiAgICAgIC8vIERlY3J5cHQgZmluYWwgU0FNUExFLUFFUyBzYW1wbGVzXG4gICAgICByZXR1cm4gZGVtdXhSZXN1bHRPclByb21pc2UudGhlbihkZW11eFJlc3VsdCA9PiB7XG4gICAgICAgIHRoaXMuZmx1c2hSZW11eCh0cmFuc211eFJlc3VsdHMsIGRlbXV4UmVzdWx0LCBjaHVua01ldGEpO1xuICAgICAgICByZXR1cm4gdHJhbnNtdXhSZXN1bHRzO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuZmx1c2hSZW11eCh0cmFuc211eFJlc3VsdHMsIGRlbXV4UmVzdWx0T3JQcm9taXNlLCBjaHVua01ldGEpO1xuICAgIGlmICh0aGlzLmFzeW5jUmVzdWx0KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRyYW5zbXV4UmVzdWx0cyk7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc211eFJlc3VsdHM7XG4gIH1cbiAgZmx1c2hSZW11eCh0cmFuc211eFJlc3VsdHMsIGRlbXV4UmVzdWx0LCBjaHVua01ldGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBhdWRpb1RyYWNrLFxuICAgICAgdmlkZW9UcmFjayxcbiAgICAgIGlkM1RyYWNrLFxuICAgICAgdGV4dFRyYWNrXG4gICAgfSA9IGRlbXV4UmVzdWx0O1xuICAgIGNvbnN0IHtcbiAgICAgIGFjY3VyYXRlVGltZU9mZnNldCxcbiAgICAgIHRpbWVPZmZzZXRcbiAgICB9ID0gdGhpcy5jdXJyZW50VHJhbnNtdXhTdGF0ZTtcbiAgICB0aGlzLmxvZ2dlci5sb2coYFt0cmFuc211eGVyLnRzXTogRmx1c2hlZCAke3RoaXMuaWR9IHNuOiAke2NodW5rTWV0YS5zbn0ke2NodW5rTWV0YS5wYXJ0ID4gLTEgPyAnIHBhcnQ6ICcgKyBjaHVua01ldGEucGFydCA6ICcnfSBvZiAke3RoaXMuaWQgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4gPyAnbGV2ZWwnIDogJ3RyYWNrJ30gJHtjaHVua01ldGEubGV2ZWx9YCk7XG4gICAgY29uc3QgcmVtdXhSZXN1bHQgPSB0aGlzLnJlbXV4ZXIucmVtdXgoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0LCB0cnVlLCB0aGlzLmlkKTtcbiAgICB0cmFuc211eFJlc3VsdHMucHVzaCh7XG4gICAgICByZW11eFJlc3VsdCxcbiAgICAgIGNodW5rTWV0YVxuICAgIH0pO1xuICAgIGNodW5rTWV0YS50cmFuc211eGluZy5leGVjdXRlRW5kID0gbm93KCk7XG4gIH1cbiAgcmVzZXRJbml0aWFsVGltZXN0YW1wKGRlZmF1bHRJbml0UHRzKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGVtdXhlcixcbiAgICAgIHJlbXV4ZXJcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWRlbXV4ZXIgfHwgIXJlbXV4ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVtdXhlci5yZXNldFRpbWVTdGFtcChkZWZhdWx0SW5pdFB0cyk7XG4gICAgcmVtdXhlci5yZXNldFRpbWVTdGFtcChkZWZhdWx0SW5pdFB0cyk7XG4gIH1cbiAgcmVzZXRDb250aWd1aXR5KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRlbXV4ZXIsXG4gICAgICByZW11eGVyXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFkZW11eGVyIHx8ICFyZW11eGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlbXV4ZXIucmVzZXRDb250aWd1aXR5KCk7XG4gICAgcmVtdXhlci5yZXNldE5leHRUaW1lc3RhbXAoKTtcbiAgfVxuICByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50RGF0YSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbiwgZGVjcnlwdGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBkZW11eGVyLFxuICAgICAgcmVtdXhlclxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghZGVtdXhlciB8fCAhcmVtdXhlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZW11eGVyLnJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnREYXRhLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0cmFja0R1cmF0aW9uKTtcbiAgICByZW11eGVyLnJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnREYXRhLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBkZWNyeXB0ZGF0YSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5kZW11eGVyKSB7XG4gICAgICB0aGlzLmRlbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5kZW11eGVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZW11eGVyKSB7XG4gICAgICB0aGlzLnJlbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5yZW11eGVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICB0cmFuc211eChkYXRhLCBrZXlEYXRhLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGNodW5rTWV0YSkge1xuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKGtleURhdGEgJiYga2V5RGF0YS5tZXRob2QgPT09ICdTQU1QTEUtQUVTJykge1xuICAgICAgcmVzdWx0ID0gdGhpcy50cmFuc211eFNhbXBsZUFlcyhkYXRhLCBrZXlEYXRhLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGNodW5rTWV0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMudHJhbnNtdXhVbmVuY3J5cHRlZChkYXRhLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGNodW5rTWV0YSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdHJhbnNtdXhVbmVuY3J5cHRlZChkYXRhLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGNodW5rTWV0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGF1ZGlvVHJhY2ssXG4gICAgICB2aWRlb1RyYWNrLFxuICAgICAgaWQzVHJhY2ssXG4gICAgICB0ZXh0VHJhY2tcbiAgICB9ID0gdGhpcy5kZW11eGVyLmRlbXV4KGRhdGEsIHRpbWVPZmZzZXQsIGZhbHNlLCAhdGhpcy5jb25maWcucHJvZ3Jlc3NpdmUpO1xuICAgIGNvbnN0IHJlbXV4UmVzdWx0ID0gdGhpcy5yZW11eGVyLnJlbXV4KGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgZmFsc2UsIHRoaXMuaWQpO1xuICAgIHJldHVybiB7XG4gICAgICByZW11eFJlc3VsdCxcbiAgICAgIGNodW5rTWV0YVxuICAgIH07XG4gIH1cbiAgdHJhbnNtdXhTYW1wbGVBZXMoZGF0YSwgZGVjcnlwdERhdGEsIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVtdXhlci5kZW11eFNhbXBsZUFlcyhkYXRhLCBkZWNyeXB0RGF0YSwgdGltZU9mZnNldCkudGhlbihkZW11eFJlc3VsdCA9PiB7XG4gICAgICBjb25zdCByZW11eFJlc3VsdCA9IHRoaXMucmVtdXhlci5yZW11eChkZW11eFJlc3VsdC5hdWRpb1RyYWNrLCBkZW11eFJlc3VsdC52aWRlb1RyYWNrLCBkZW11eFJlc3VsdC5pZDNUcmFjaywgZGVtdXhSZXN1bHQudGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGZhbHNlLCB0aGlzLmlkKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbXV4UmVzdWx0LFxuICAgICAgICBjaHVua01ldGFcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgY29uZmlndXJlVHJhbnNtdXhlcihkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29uZmlnLFxuICAgICAgb2JzZXJ2ZXIsXG4gICAgICB0eXBlU3VwcG9ydGVkXG4gICAgfSA9IHRoaXM7XG4gICAgLy8gcHJvYmUgZm9yIGNvbnRlbnQgdHlwZVxuICAgIGxldCBtdXg7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG11eENvbmZpZy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIF9tdXhDb25maWckaSRkZW11eDtcbiAgICAgIGlmICgoX211eENvbmZpZyRpJGRlbXV4ID0gbXV4Q29uZmlnW2ldLmRlbXV4KSAhPSBudWxsICYmIF9tdXhDb25maWckaSRkZW11eC5wcm9iZShkYXRhLCB0aGlzLmxvZ2dlcikpIHtcbiAgICAgICAgbXV4ID0gbXV4Q29uZmlnW2ldO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFtdXgpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmaW5kIGRlbXV4ZXIgYnkgcHJvYmluZyBmcmFnbWVudCBkYXRhJyk7XG4gICAgfVxuICAgIC8vIHNvIGxldCdzIGNoZWNrIHRoYXQgY3VycmVudCByZW11eGVyIGFuZCBkZW11eGVyIGFyZSBzdGlsbCB2YWxpZFxuICAgIGNvbnN0IGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXI7XG4gICAgY29uc3QgcmVtdXhlciA9IHRoaXMucmVtdXhlcjtcbiAgICBjb25zdCBSZW11eGVyID0gbXV4LnJlbXV4O1xuICAgIGNvbnN0IERlbXV4ZXIgPSBtdXguZGVtdXg7XG4gICAgaWYgKCFyZW11eGVyIHx8ICEocmVtdXhlciBpbnN0YW5jZW9mIFJlbXV4ZXIpKSB7XG4gICAgICB0aGlzLnJlbXV4ZXIgPSBuZXcgUmVtdXhlcihvYnNlcnZlciwgY29uZmlnLCB0eXBlU3VwcG9ydGVkLCB0aGlzLmxvZ2dlcik7XG4gICAgfVxuICAgIGlmICghZGVtdXhlciB8fCAhKGRlbXV4ZXIgaW5zdGFuY2VvZiBEZW11eGVyKSkge1xuICAgICAgdGhpcy5kZW11eGVyID0gbmV3IERlbXV4ZXIob2JzZXJ2ZXIsIGNvbmZpZywgdHlwZVN1cHBvcnRlZCwgdGhpcy5sb2dnZXIpO1xuICAgICAgdGhpcy5wcm9iZSA9IERlbXV4ZXIucHJvYmU7XG4gICAgfVxuICB9XG4gIG5lZWRzUHJvYmluZyhkaXNjb250aW51aXR5LCB0cmFja1N3aXRjaCkge1xuICAgIC8vIGluIGNhc2Ugb2YgY29udGludWl0eSBjaGFuZ2UsIG9yIHRyYWNrIHN3aXRjaFxuICAgIC8vIHdlIG1pZ2h0IHN3aXRjaCBmcm9tIGNvbnRlbnQgdHlwZSAoQUFDIGNvbnRhaW5lciB0byBUUyBjb250YWluZXIsIG9yIFRTIHRvIGZtcDQgZm9yIGV4YW1wbGUpXG4gICAgcmV0dXJuICF0aGlzLmRlbXV4ZXIgfHwgIXRoaXMucmVtdXhlciB8fCBkaXNjb250aW51aXR5IHx8IHRyYWNrU3dpdGNoO1xuICB9XG4gIGdldERlY3J5cHRlcigpIHtcbiAgICBsZXQgZGVjcnlwdGVyID0gdGhpcy5kZWNyeXB0ZXI7XG4gICAgaWYgKCFkZWNyeXB0ZXIpIHtcbiAgICAgIGRlY3J5cHRlciA9IHRoaXMuZGVjcnlwdGVyID0gbmV3IERlY3J5cHRlcih0aGlzLmNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiBkZWNyeXB0ZXI7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEVuY3J5cHRpb25UeXBlKGRhdGEsIGRlY3J5cHREYXRhKSB7XG4gIGxldCBlbmNyeXB0aW9uVHlwZSA9IG51bGw7XG4gIGlmIChkYXRhLmJ5dGVMZW5ndGggPiAwICYmIChkZWNyeXB0RGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGVjcnlwdERhdGEua2V5KSAhPSBudWxsICYmIGRlY3J5cHREYXRhLml2ICE9PSBudWxsICYmIGRlY3J5cHREYXRhLm1ldGhvZCAhPSBudWxsKSB7XG4gICAgZW5jcnlwdGlvblR5cGUgPSBkZWNyeXB0RGF0YTtcbiAgfVxuICByZXR1cm4gZW5jcnlwdGlvblR5cGU7XG59XG5jb25zdCBlbXB0eVJlc3VsdCA9IGNodW5rTWV0YSA9PiAoe1xuICByZW11eFJlc3VsdDoge30sXG4gIGNodW5rTWV0YVxufSk7XG5mdW5jdGlvbiBpc1Byb21pc2UocCkge1xuICByZXR1cm4gJ3RoZW4nIGluIHAgJiYgcC50aGVuIGluc3RhbmNlb2YgRnVuY3Rpb247XG59XG5jbGFzcyBUcmFuc211eENvbmZpZyB7XG4gIGNvbnN0cnVjdG9yKGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGluaXRTZWdtZW50RGF0YSwgZHVyYXRpb24sIGRlZmF1bHRJbml0UHRzKSB7XG4gICAgdGhpcy5hdWRpb0NvZGVjID0gdm9pZCAwO1xuICAgIHRoaXMudmlkZW9Db2RlYyA9IHZvaWQgMDtcbiAgICB0aGlzLmluaXRTZWdtZW50RGF0YSA9IHZvaWQgMDtcbiAgICB0aGlzLmR1cmF0aW9uID0gdm9pZCAwO1xuICAgIHRoaXMuZGVmYXVsdEluaXRQdHMgPSB2b2lkIDA7XG4gICAgdGhpcy5hdWRpb0NvZGVjID0gYXVkaW9Db2RlYztcbiAgICB0aGlzLnZpZGVvQ29kZWMgPSB2aWRlb0NvZGVjO1xuICAgIHRoaXMuaW5pdFNlZ21lbnREYXRhID0gaW5pdFNlZ21lbnREYXRhO1xuICAgIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICB0aGlzLmRlZmF1bHRJbml0UHRzID0gZGVmYXVsdEluaXRQdHMgfHwgbnVsbDtcbiAgfVxufVxuY2xhc3MgVHJhbnNtdXhTdGF0ZSB7XG4gIGNvbnN0cnVjdG9yKGRpc2NvbnRpbnVpdHksIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCwgdHJhY2tTd2l0Y2gsIHRpbWVPZmZzZXQsIGluaXRTZWdtZW50Q2hhbmdlKSB7XG4gICAgdGhpcy5kaXNjb250aW51aXR5ID0gdm9pZCAwO1xuICAgIHRoaXMuY29udGlndW91cyA9IHZvaWQgMDtcbiAgICB0aGlzLmFjY3VyYXRlVGltZU9mZnNldCA9IHZvaWQgMDtcbiAgICB0aGlzLnRyYWNrU3dpdGNoID0gdm9pZCAwO1xuICAgIHRoaXMudGltZU9mZnNldCA9IHZvaWQgMDtcbiAgICB0aGlzLmluaXRTZWdtZW50Q2hhbmdlID0gdm9pZCAwO1xuICAgIHRoaXMuZGlzY29udGludWl0eSA9IGRpc2NvbnRpbnVpdHk7XG4gICAgdGhpcy5jb250aWd1b3VzID0gY29udGlndW91cztcbiAgICB0aGlzLmFjY3VyYXRlVGltZU9mZnNldCA9IGFjY3VyYXRlVGltZU9mZnNldDtcbiAgICB0aGlzLnRyYWNrU3dpdGNoID0gdHJhY2tTd2l0Y2g7XG4gICAgdGhpcy50aW1lT2Zmc2V0ID0gdGltZU9mZnNldDtcbiAgICB0aGlzLmluaXRTZWdtZW50Q2hhbmdlID0gaW5pdFNlZ21lbnRDaGFuZ2U7XG4gIH1cbn1cblxubGV0IHRyYW5zbXV4ZXJJbnN0YW5jZUNvdW50ID0gMDtcbmNsYXNzIFRyYW5zbXV4ZXJJbnRlcmZhY2Uge1xuICBjb25zdHJ1Y3RvcihfaGxzLCBpZCwgb25UcmFuc211eENvbXBsZXRlLCBvbkZsdXNoKSB7XG4gICAgdGhpcy5lcnJvciA9IG51bGw7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5pZCA9IHZvaWQgMDtcbiAgICB0aGlzLmluc3RhbmNlTm8gPSB0cmFuc211eGVySW5zdGFuY2VDb3VudCsrO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5mcmFnID0gbnVsbDtcbiAgICB0aGlzLnBhcnQgPSBudWxsO1xuICAgIHRoaXMudXNlV29ya2VyID0gdm9pZCAwO1xuICAgIHRoaXMud29ya2VyQ29udGV4dCA9IG51bGw7XG4gICAgdGhpcy50cmFuc211eGVyID0gbnVsbDtcbiAgICB0aGlzLm9uVHJhbnNtdXhDb21wbGV0ZSA9IHZvaWQgMDtcbiAgICB0aGlzLm9uRmx1c2ggPSB2b2lkIDA7XG4gICAgdGhpcy5vbldvcmtlck1lc3NhZ2UgPSBldmVudCA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gZXZlbnQuZGF0YTtcbiAgICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgICAgaWYgKCFobHMgfHwgIShkYXRhICE9IG51bGwgJiYgZGF0YS5ldmVudCkgfHwgZGF0YS5pbnN0YW5jZU5vICE9PSB0aGlzLmluc3RhbmNlTm8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChkYXRhLmV2ZW50KSB7XG4gICAgICAgIGNhc2UgJ2luaXQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyR3b3JrZXJDb250ZXh0O1xuICAgICAgICAgICAgY29uc3Qgb2JqZWN0VVJMID0gKF90aGlzJHdvcmtlckNvbnRleHQgPSB0aGlzLndvcmtlckNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyR3b3JrZXJDb250ZXh0Lm9iamVjdFVSTDtcbiAgICAgICAgICAgIGlmIChvYmplY3RVUkwpIHtcbiAgICAgICAgICAgICAgLy8gcmV2b2tlIHRoZSBPYmplY3QgVVJMIHRoYXQgd2FzIHVzZWQgdG8gY3JlYXRlIHRyYW5zbXV4ZXIgd29ya2VyLCBzbyBhcyBub3QgdG8gbGVhayBpdFxuICAgICAgICAgICAgICBzZWxmLlVSTC5yZXZva2VPYmplY3RVUkwob2JqZWN0VVJMKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAndHJhbnNtdXhDb21wbGV0ZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVUcmFuc211eENvbXBsZXRlKGRhdGEuZGF0YSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2ZsdXNoJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLm9uRmx1c2goZGF0YS5kYXRhKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAvLyBwYXNzIGxvZ3MgZnJvbSB0aGUgd29ya2VyIHRocmVhZCB0byB0aGUgbWFpbiBsb2dnZXJcbiAgICAgICAgY2FzZSAnd29ya2VyTG9nJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoaGxzLmxvZ2dlcltkYXRhLmRhdGEubG9nVHlwZV0pIHtcbiAgICAgICAgICAgICAgaGxzLmxvZ2dlcltkYXRhLmRhdGEubG9nVHlwZV0oZGF0YS5kYXRhLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGRhdGEuZGF0YSA9IGRhdGEuZGF0YSB8fCB7fTtcbiAgICAgICAgICAgIGRhdGEuZGF0YS5mcmFnID0gdGhpcy5mcmFnO1xuICAgICAgICAgICAgZGF0YS5kYXRhLnBhcnQgPSB0aGlzLnBhcnQ7XG4gICAgICAgICAgICBkYXRhLmRhdGEuaWQgPSB0aGlzLmlkO1xuICAgICAgICAgICAgaGxzLnRyaWdnZXIoZGF0YS5ldmVudCwgZGF0YS5kYXRhKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMub25Xb3JrZXJFcnJvciA9IGV2ZW50ID0+IHtcbiAgICAgIGlmICghdGhpcy5obHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYCR7ZXZlbnQubWVzc2FnZX0gICgke2V2ZW50LmZpbGVuYW1lfToke2V2ZW50LmxpbmVub30pYCk7XG4gICAgICB0aGlzLmhscy5jb25maWcuZW5hYmxlV29ya2VyID0gZmFsc2U7XG4gICAgICB0aGlzLmhscy5sb2dnZXIud2FybihgRXJyb3IgaW4gXCIke3RoaXMuaWR9XCIgV2ViIFdvcmtlciwgZmFsbGJhY2sgdG8gaW5saW5lYCk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuSU5URVJOQUxfRVhDRVBUSU9OLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIGV2ZW50OiAnZGVtdXhlcldvcmtlcicsXG4gICAgICAgIGVycm9yXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGNvbmZpZyA9IF9obHMuY29uZmlnO1xuICAgIHRoaXMuaGxzID0gX2hscztcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy51c2VXb3JrZXIgPSAhIWNvbmZpZy5lbmFibGVXb3JrZXI7XG4gICAgdGhpcy5vblRyYW5zbXV4Q29tcGxldGUgPSBvblRyYW5zbXV4Q29tcGxldGU7XG4gICAgdGhpcy5vbkZsdXNoID0gb25GbHVzaDtcbiAgICBjb25zdCBmb3J3YXJkTWVzc2FnZSA9IChldiwgZGF0YSkgPT4ge1xuICAgICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgICBkYXRhLmZyYWcgPSB0aGlzLmZyYWcgfHwgdW5kZWZpbmVkO1xuICAgICAgaWYgKGV2ID09PSBFdmVudHMuRVJST1IpIHtcbiAgICAgICAgZGF0YSA9IGRhdGE7XG4gICAgICAgIGRhdGEucGFyZW50ID0gdGhpcy5pZDtcbiAgICAgICAgZGF0YS5wYXJ0ID0gdGhpcy5wYXJ0O1xuICAgICAgICB0aGlzLmVycm9yID0gZGF0YS5lcnJvcjtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoZXYsIGRhdGEpO1xuICAgIH07XG5cbiAgICAvLyBmb3J3YXJkIGV2ZW50cyB0byBtYWluIHRocmVhZFxuICAgIHRoaXMub2JzZXJ2ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgdGhpcy5vYnNlcnZlci5vbihFdmVudHMuRlJBR19ERUNSWVBURUQsIGZvcndhcmRNZXNzYWdlKTtcbiAgICB0aGlzLm9ic2VydmVyLm9uKEV2ZW50cy5FUlJPUiwgZm9yd2FyZE1lc3NhZ2UpO1xuICAgIGNvbnN0IG0ydHNUeXBlU3VwcG9ydGVkID0gZ2V0TTJUU1N1cHBvcnRlZEF1ZGlvVHlwZXMoY29uZmlnLnByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSk7XG4gICAgaWYgKHRoaXMudXNlV29ya2VyICYmIHR5cGVvZiBXb3JrZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zdCBsb2dnZXIgPSB0aGlzLmhscy5sb2dnZXI7XG4gICAgICBjb25zdCBjYW5DcmVhdGVXb3JrZXIgPSBjb25maWcud29ya2VyUGF0aCB8fCBoYXNVTURXb3JrZXIoKTtcbiAgICAgIGlmIChjYW5DcmVhdGVXb3JrZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoY29uZmlnLndvcmtlclBhdGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coYGxvYWRpbmcgV2ViIFdvcmtlciAke2NvbmZpZy53b3JrZXJQYXRofSBmb3IgXCIke2lkfVwiYCk7XG4gICAgICAgICAgICB0aGlzLndvcmtlckNvbnRleHQgPSBsb2FkV29ya2VyKGNvbmZpZy53b3JrZXJQYXRoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgaW5qZWN0aW5nIFdlYiBXb3JrZXIgZm9yIFwiJHtpZH1cImApO1xuICAgICAgICAgICAgdGhpcy53b3JrZXJDb250ZXh0ID0gaW5qZWN0V29ya2VyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHdvcmtlclxuICAgICAgICAgIH0gPSB0aGlzLndvcmtlckNvbnRleHQ7XG4gICAgICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLm9uV29ya2VyTWVzc2FnZSk7XG4gICAgICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5vbldvcmtlckVycm9yKTtcbiAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgaW5zdGFuY2VObzogdGhpcy5pbnN0YW5jZU5vLFxuICAgICAgICAgICAgY21kOiAnaW5pdCcsXG4gICAgICAgICAgICB0eXBlU3VwcG9ydGVkOiBtMnRzVHlwZVN1cHBvcnRlZCxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgY29uZmlnOiBzdHJpbmdpZnkoY29uZmlnKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBsb2dnZXIud2FybihgRXJyb3Igc2V0dGluZyB1cCBcIiR7aWR9XCIgV2ViIFdvcmtlciwgZmFsbGJhY2sgdG8gaW5saW5lYCwgZXJyKTtcbiAgICAgICAgICB0aGlzLnRlcm1pbmF0ZVdvcmtlcigpO1xuICAgICAgICAgIHRoaXMuZXJyb3IgPSBudWxsO1xuICAgICAgICAgIHRoaXMudHJhbnNtdXhlciA9IG5ldyBUcmFuc211eGVyKHRoaXMub2JzZXJ2ZXIsIG0ydHNUeXBlU3VwcG9ydGVkLCBjb25maWcsICcnLCBpZCwgX2hscy5sb2dnZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy50cmFuc211eGVyID0gbmV3IFRyYW5zbXV4ZXIodGhpcy5vYnNlcnZlciwgbTJ0c1R5cGVTdXBwb3J0ZWQsIGNvbmZpZywgJycsIGlkLCBfaGxzLmxvZ2dlcik7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5mcmFnID0gbnVsbDtcbiAgICB0aGlzLnBhcnQgPSBudWxsO1xuICAgIGlmICh0aGlzLndvcmtlckNvbnRleHQpIHtcbiAgICAgIGNvbnN0IGluc3RhbmNlTm8gPSB0aGlzLmluc3RhbmNlTm87XG4gICAgICB0aGlzLmluc3RhbmNlTm8gPSB0cmFuc211eGVySW5zdGFuY2VDb3VudCsrO1xuICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuICAgICAgY29uc3QgbTJ0c1R5cGVTdXBwb3J0ZWQgPSBnZXRNMlRTU3VwcG9ydGVkQXVkaW9UeXBlcyhjb25maWcucHJlZmVyTWFuYWdlZE1lZGlhU291cmNlKTtcbiAgICAgIHRoaXMud29ya2VyQ29udGV4dC53b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBpbnN0YW5jZU5vOiB0aGlzLmluc3RhbmNlTm8sXG4gICAgICAgIGNtZDogJ3Jlc2V0JyxcbiAgICAgICAgcmVzZXRObzogaW5zdGFuY2VObyxcbiAgICAgICAgdHlwZVN1cHBvcnRlZDogbTJ0c1R5cGVTdXBwb3J0ZWQsXG4gICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICBjb25maWc6IHN0cmluZ2lmeShjb25maWcpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgdGVybWluYXRlV29ya2VyKCkge1xuICAgIGlmICh0aGlzLndvcmtlckNvbnRleHQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgd29ya2VyXG4gICAgICB9ID0gdGhpcy53b3JrZXJDb250ZXh0O1xuICAgICAgdGhpcy53b3JrZXJDb250ZXh0ID0gbnVsbDtcbiAgICAgIHdvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5vbldvcmtlck1lc3NhZ2UpO1xuICAgICAgd29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5vbldvcmtlckVycm9yKTtcbiAgICAgIHJlbW92ZVdvcmtlckZyb21TdG9yZSh0aGlzLmhscy5jb25maWcud29ya2VyUGF0aCk7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMud29ya2VyQ29udGV4dCkge1xuICAgICAgdGhpcy50ZXJtaW5hdGVXb3JrZXIoKTtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMub25Xb3JrZXJNZXNzYWdlID0gdGhpcy5vbldvcmtlckVycm9yID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdHJhbnNtdXhlciA9IHRoaXMudHJhbnNtdXhlcjtcbiAgICAgIGlmICh0cmFuc211eGVyKSB7XG4gICAgICAgIHRyYW5zbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnRyYW5zbXV4ZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXI7XG4gICAgaWYgKG9ic2VydmVyKSB7XG4gICAgICBvYnNlcnZlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgdGhpcy5mcmFnID0gbnVsbDtcbiAgICB0aGlzLnBhcnQgPSBudWxsO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLm9ic2VydmVyID0gbnVsbDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSBudWxsO1xuICB9XG4gIHB1c2goZGF0YSwgaW5pdFNlZ21lbnREYXRhLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBmcmFnLCBwYXJ0LCBkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBjaHVua01ldGEsIGRlZmF1bHRJbml0UFRTKSB7XG4gICAgdmFyIF9mcmFnJGluaXRTZWdtZW50LCBfbGFzdEZyYWckaW5pdFNlZ21lbnQ7XG4gICAgY2h1bmtNZXRhLnRyYW5zbXV4aW5nLnN0YXJ0ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCB7XG4gICAgICBpbnN0YW5jZU5vLFxuICAgICAgdHJhbnNtdXhlclxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHRpbWVPZmZzZXQgPSBwYXJ0ID8gcGFydC5zdGFydCA6IGZyYWcuc3RhcnQ7XG4gICAgLy8gVE9ETzogcHVzaCBcImNsZWFyLWxlYWRcIiBkZWNyeXB0IGRhdGEgZm9yIHVuZW5jcnlwdGVkIGZyYWdtZW50cyBpbiBzdHJlYW1zIHdpdGggZW5jcnlwdGVkIG9uZXNcbiAgICBjb25zdCBkZWNyeXB0ZGF0YSA9IGZyYWcuZGVjcnlwdGRhdGE7XG4gICAgY29uc3QgbGFzdEZyYWcgPSB0aGlzLmZyYWc7XG4gICAgY29uc3QgZGlzY29udGludWl0eSA9ICEobGFzdEZyYWcgJiYgZnJhZy5jYyA9PT0gbGFzdEZyYWcuY2MpO1xuICAgIGNvbnN0IHRyYWNrU3dpdGNoID0gIShsYXN0RnJhZyAmJiBjaHVua01ldGEubGV2ZWwgPT09IGxhc3RGcmFnLmxldmVsKTtcbiAgICBjb25zdCBzbkRpZmYgPSBsYXN0RnJhZyA/IGNodW5rTWV0YS5zbiAtIGxhc3RGcmFnLnNuIDogLTE7XG4gICAgY29uc3QgcGFydERpZmYgPSB0aGlzLnBhcnQgPyBjaHVua01ldGEucGFydCAtIHRoaXMucGFydC5pbmRleCA6IC0xO1xuICAgIGNvbnN0IHByb2dyZXNzaXZlID0gc25EaWZmID09PSAwICYmIGNodW5rTWV0YS5pZCA+IDEgJiYgY2h1bmtNZXRhLmlkID09PSAobGFzdEZyYWcgPT0gbnVsbCA/IHZvaWQgMCA6IGxhc3RGcmFnLnN0YXRzLmNodW5rQ291bnQpO1xuICAgIGNvbnN0IGNvbnRpZ3VvdXMgPSAhdHJhY2tTd2l0Y2ggJiYgKHNuRGlmZiA9PT0gMSB8fCBzbkRpZmYgPT09IDAgJiYgKHBhcnREaWZmID09PSAxIHx8IHByb2dyZXNzaXZlICYmIHBhcnREaWZmIDw9IDApKTtcbiAgICBjb25zdCBub3cgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGlmICh0cmFja1N3aXRjaCB8fCBzbkRpZmYgfHwgZnJhZy5zdGF0cy5wYXJzaW5nLnN0YXJ0ID09PSAwKSB7XG4gICAgICBmcmFnLnN0YXRzLnBhcnNpbmcuc3RhcnQgPSBub3c7XG4gICAgfVxuICAgIGlmIChwYXJ0ICYmIChwYXJ0RGlmZiB8fCAhY29udGlndW91cykpIHtcbiAgICAgIHBhcnQuc3RhdHMucGFyc2luZy5zdGFydCA9IG5vdztcbiAgICB9XG4gICAgY29uc3QgaW5pdFNlZ21lbnRDaGFuZ2UgPSAhKGxhc3RGcmFnICYmICgoX2ZyYWckaW5pdFNlZ21lbnQgPSBmcmFnLmluaXRTZWdtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2ZyYWckaW5pdFNlZ21lbnQudXJsKSA9PT0gKChfbGFzdEZyYWckaW5pdFNlZ21lbnQgPSBsYXN0RnJhZy5pbml0U2VnbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9sYXN0RnJhZyRpbml0U2VnbWVudC51cmwpKTtcbiAgICBjb25zdCBzdGF0ZSA9IG5ldyBUcmFuc211eFN0YXRlKGRpc2NvbnRpbnVpdHksIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCwgdHJhY2tTd2l0Y2gsIHRpbWVPZmZzZXQsIGluaXRTZWdtZW50Q2hhbmdlKTtcbiAgICBpZiAoIWNvbnRpZ3VvdXMgfHwgZGlzY29udGludWl0eSB8fCBpbml0U2VnbWVudENoYW5nZSkge1xuICAgICAgdGhpcy5obHMubG9nZ2VyLmxvZyhgW3RyYW5zbXV4ZXItaW50ZXJmYWNlXTogU3RhcnRpbmcgbmV3IHRyYW5zbXV4IHNlc3Npb24gZm9yICR7ZnJhZy50eXBlfSBzbjogJHtjaHVua01ldGEuc259JHtjaHVua01ldGEucGFydCA+IC0xID8gJyBwYXJ0OiAnICsgY2h1bmtNZXRhLnBhcnQgOiAnJ30gJHt0aGlzLmlkID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOID8gJ2xldmVsJyA6ICd0cmFjayd9OiAke2NodW5rTWV0YS5sZXZlbH0gaWQ6ICR7Y2h1bmtNZXRhLmlkfVxuICAgICAgICBkaXNjb250aW51aXR5OiAke2Rpc2NvbnRpbnVpdHl9XG4gICAgICAgIHRyYWNrU3dpdGNoOiAke3RyYWNrU3dpdGNofVxuICAgICAgICBjb250aWd1b3VzOiAke2NvbnRpZ3VvdXN9XG4gICAgICAgIGFjY3VyYXRlVGltZU9mZnNldDogJHthY2N1cmF0ZVRpbWVPZmZzZXR9XG4gICAgICAgIHRpbWVPZmZzZXQ6ICR7dGltZU9mZnNldH1cbiAgICAgICAgaW5pdFNlZ21lbnRDaGFuZ2U6ICR7aW5pdFNlZ21lbnRDaGFuZ2V9YCk7XG4gICAgICBjb25zdCBjb25maWcgPSBuZXcgVHJhbnNtdXhDb25maWcoYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgaW5pdFNlZ21lbnREYXRhLCBkdXJhdGlvbiwgZGVmYXVsdEluaXRQVFMpO1xuICAgICAgdGhpcy5jb25maWd1cmVUcmFuc211eGVyKGNvbmZpZyk7XG4gICAgfVxuICAgIHRoaXMuZnJhZyA9IGZyYWc7XG4gICAgdGhpcy5wYXJ0ID0gcGFydDtcblxuICAgIC8vIEZyYWdzIHdpdGggc24gb2YgJ2luaXRTZWdtZW50JyBhcmUgbm90IHRyYW5zbXV4ZWRcbiAgICBpZiAodGhpcy53b3JrZXJDb250ZXh0KSB7XG4gICAgICAvLyBwb3N0IGZyYWdtZW50IHBheWxvYWQgYXMgdHJhbnNmZXJhYmxlIG9iamVjdHMgZm9yIEFycmF5QnVmZmVyIChubyBjb3B5KVxuICAgICAgdGhpcy53b3JrZXJDb250ZXh0Lndvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgIGluc3RhbmNlTm8sXG4gICAgICAgIGNtZDogJ2RlbXV4JyxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgZGVjcnlwdGRhdGEsXG4gICAgICAgIGNodW5rTWV0YSxcbiAgICAgICAgc3RhdGVcbiAgICAgIH0sIGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IFtkYXRhXSA6IFtdKTtcbiAgICB9IGVsc2UgaWYgKHRyYW5zbXV4ZXIpIHtcbiAgICAgIGNvbnN0IHRyYW5zbXV4UmVzdWx0ID0gdHJhbnNtdXhlci5wdXNoKGRhdGEsIGRlY3J5cHRkYXRhLCBjaHVua01ldGEsIHN0YXRlKTtcbiAgICAgIGlmIChpc1Byb21pc2UodHJhbnNtdXhSZXN1bHQpKSB7XG4gICAgICAgIHRyYW5zbXV4UmVzdWx0LnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVUcmFuc211eENvbXBsZXRlKGRhdGEpO1xuICAgICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgdGhpcy50cmFuc211eGVyRXJyb3IoZXJyb3IsIGNodW5rTWV0YSwgJ3RyYW5zbXV4ZXItaW50ZXJmYWNlIHB1c2ggZXJyb3InKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhbmRsZVRyYW5zbXV4Q29tcGxldGUodHJhbnNtdXhSZXN1bHQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmbHVzaChjaHVua01ldGEpIHtcbiAgICBjaHVua01ldGEudHJhbnNtdXhpbmcuc3RhcnQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnN0IHtcbiAgICAgIGluc3RhbmNlTm8sXG4gICAgICB0cmFuc211eGVyXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKHRoaXMud29ya2VyQ29udGV4dCkge1xuICAgICAgdGhpcy53b3JrZXJDb250ZXh0Lndvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgIGluc3RhbmNlTm8sXG4gICAgICAgIGNtZDogJ2ZsdXNoJyxcbiAgICAgICAgY2h1bmtNZXRhXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRyYW5zbXV4ZXIpIHtcbiAgICAgIGNvbnN0IHRyYW5zbXV4UmVzdWx0ID0gdHJhbnNtdXhlci5mbHVzaChjaHVua01ldGEpO1xuICAgICAgaWYgKGlzUHJvbWlzZSh0cmFuc211eFJlc3VsdCkpIHtcbiAgICAgICAgdHJhbnNtdXhSZXN1bHQudGhlbihkYXRhID0+IHtcbiAgICAgICAgICB0aGlzLmhhbmRsZUZsdXNoUmVzdWx0KGRhdGEsIGNodW5rTWV0YSk7XG4gICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICB0aGlzLnRyYW5zbXV4ZXJFcnJvcihlcnJvciwgY2h1bmtNZXRhLCAndHJhbnNtdXhlci1pbnRlcmZhY2UgZmx1c2ggZXJyb3InKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhbmRsZUZsdXNoUmVzdWx0KHRyYW5zbXV4UmVzdWx0LCBjaHVua01ldGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0cmFuc211eGVyRXJyb3IoZXJyb3IsIGNodW5rTWV0YSwgcmVhc29uKSB7XG4gICAgaWYgKCF0aGlzLmhscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLFxuICAgICAgY2h1bmtNZXRhLFxuICAgICAgZnJhZzogdGhpcy5mcmFnIHx8IHVuZGVmaW5lZCxcbiAgICAgIHBhcnQ6IHRoaXMucGFydCB8fCB1bmRlZmluZWQsXG4gICAgICBmYXRhbDogZmFsc2UsXG4gICAgICBlcnJvcixcbiAgICAgIGVycjogZXJyb3IsXG4gICAgICByZWFzb25cbiAgICB9KTtcbiAgfVxuICBoYW5kbGVGbHVzaFJlc3VsdChyZXN1bHRzLCBjaHVua01ldGEpIHtcbiAgICByZXN1bHRzLmZvckVhY2gocmVzdWx0ID0+IHtcbiAgICAgIHRoaXMuaGFuZGxlVHJhbnNtdXhDb21wbGV0ZShyZXN1bHQpO1xuICAgIH0pO1xuICAgIHRoaXMub25GbHVzaChjaHVua01ldGEpO1xuICB9XG4gIGNvbmZpZ3VyZVRyYW5zbXV4ZXIoY29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgaW5zdGFuY2VObyxcbiAgICAgIHRyYW5zbXV4ZXJcbiAgICB9ID0gdGhpcztcbiAgICBpZiAodGhpcy53b3JrZXJDb250ZXh0KSB7XG4gICAgICB0aGlzLndvcmtlckNvbnRleHQud29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgaW5zdGFuY2VObyxcbiAgICAgICAgY21kOiAnY29uZmlndXJlJyxcbiAgICAgICAgY29uZmlnXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRyYW5zbXV4ZXIpIHtcbiAgICAgIHRyYW5zbXV4ZXIuY29uZmlndXJlKGNvbmZpZyk7XG4gICAgfVxuICB9XG4gIGhhbmRsZVRyYW5zbXV4Q29tcGxldGUocmVzdWx0KSB7XG4gICAgcmVzdWx0LmNodW5rTWV0YS50cmFuc211eGluZy5lbmQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHRoaXMub25UcmFuc211eENvbXBsZXRlKHJlc3VsdCk7XG4gIH1cbn1cblxuY29uc3QgVElDS19JTlRFUlZBTCQzID0gMTAwOyAvLyBob3cgb2Z0ZW4gdG8gdGljayBpbiBtc1xuXG5jbGFzcyBBdWRpb1N0cmVhbUNvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlU3RyZWFtQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGhscywgZnJhZ21lbnRUcmFja2VyLCBrZXlMb2FkZXIpIHtcbiAgICBzdXBlcihobHMsIGZyYWdtZW50VHJhY2tlciwga2V5TG9hZGVyLCAnYXVkaW8tc3RyZWFtLWNvbnRyb2xsZXInLCBQbGF5bGlzdExldmVsVHlwZS5BVURJTyk7XG4gICAgdGhpcy5tYWluQW5jaG9yID0gbnVsbDtcbiAgICB0aGlzLm1haW5GcmFnTG9hZGluZyA9IG51bGw7XG4gICAgdGhpcy5hdWRpb09ubHkgPSBmYWxzZTtcbiAgICB0aGlzLmJ1ZmZlcmVkVHJhY2sgPSBudWxsO1xuICAgIHRoaXMuc3dpdGNoaW5nVHJhY2sgPSBudWxsO1xuICAgIHRoaXMudHJhY2tJZCA9IC0xO1xuICAgIHRoaXMud2FpdGluZ0RhdGEgPSBudWxsO1xuICAgIHRoaXMubWFpbkRldGFpbHMgPSBudWxsO1xuICAgIHRoaXMuZmx1c2hpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmJ1ZmZlckZsdXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhY2hlZFRyYWNrTG9hZGVkRGF0YSA9IG51bGw7XG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIG9uSGFuZGxlckRlc3Ryb3lpbmcoKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgc3VwZXIub25IYW5kbGVyRGVzdHJveWluZygpO1xuICAgIHRoaXMucmVzZXRJdGVtKCk7XG4gIH1cbiAgcmVzZXRJdGVtKCkge1xuICAgIHRoaXMubWFpbkRldGFpbHMgPSB0aGlzLm1haW5BbmNob3IgPSB0aGlzLm1haW5GcmFnTG9hZGluZyA9IHRoaXMuYnVmZmVyZWRUcmFjayA9IHRoaXMuc3dpdGNoaW5nVHJhY2sgPSB0aGlzLndhaXRpbmdEYXRhID0gdGhpcy5jYWNoZWRUcmFja0xvYWRlZERhdGEgPSBudWxsO1xuICB9XG4gIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHN1cGVyLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5BVURJT19UUkFDS1NfVVBEQVRFRCwgdGhpcy5vbkF1ZGlvVHJhY2tzVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hJTkcsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkFVRElPX1RSQUNLX0xPQURFRCwgdGhpcy5vbkF1ZGlvVHJhY2tMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX1JFU0VULCB0aGlzLm9uQnVmZmVyUmVzZXQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0NSRUFURUQsIHRoaXMub25CdWZmZXJDcmVhdGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9GTFVTSEVELCB0aGlzLm9uQnVmZmVyRmx1c2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5JTklUX1BUU19GT1VORCwgdGhpcy5vbkluaXRQdHNGb3VuZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX0xPQURJTkcsIHRoaXMub25GcmFnTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgfVxuICB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmICghaGxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQVVESU9fVFJBQ0tTX1VQREFURUQsIHRoaXMub25BdWRpb1RyYWNrc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSElORywgdGhpcy5vbkF1ZGlvVHJhY2tTd2l0Y2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkFVRElPX1RSQUNLX0xPQURFRCwgdGhpcy5vbkF1ZGlvVHJhY2tMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9SRVNFVCwgdGhpcy5vbkJ1ZmZlclJlc2V0LCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfQ1JFQVRFRCwgdGhpcy5vbkJ1ZmZlckNyZWF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfRkxVU0hFRCwgdGhpcy5vbkJ1ZmZlckZsdXNoZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLklOSVRfUFRTX0ZPVU5ELCB0aGlzLm9uSW5pdFB0c0ZvdW5kLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0xPQURJTkcsIHRoaXMub25GcmFnTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gIH1cblxuICAvLyBJTklUX1BUU19GT1VORCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgdmlkZW8gdHJhY2sgcGFyc2VkIGluIHRoZSBzdHJlYW0tY29udHJvbGxlciBoYXMgYSBuZXcgUFRTIHZhbHVlXG4gIG9uSW5pdFB0c0ZvdW5kKGV2ZW50LCB7XG4gICAgZnJhZyxcbiAgICBpZCxcbiAgICBpbml0UFRTLFxuICAgIHRpbWVzY2FsZVxuICB9KSB7XG4gICAgLy8gQWx3YXlzIHVwZGF0ZSB0aGUgbmV3IElOSVQgUFRTXG4gICAgLy8gQ2FuIGNoYW5nZSBkdWUgbGV2ZWwgc3dpdGNoXG4gICAgaWYgKGlkID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOKSB7XG4gICAgICBjb25zdCBjYyA9IGZyYWcuY2M7XG4gICAgICBjb25zdCBpbkZsaWdodEZyYWcgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgdGhpcy5pbml0UFRTW2NjXSA9IHtcbiAgICAgICAgYmFzZVRpbWU6IGluaXRQVFMsXG4gICAgICAgIHRpbWVzY2FsZVxuICAgICAgfTtcbiAgICAgIHRoaXMubG9nKGBJbml0UFRTIGZvciBjYzogJHtjY30gZm91bmQgZnJvbSBtYWluOiAke2luaXRQVFN9LyR7dGltZXNjYWxlfWApO1xuICAgICAgdGhpcy5tYWluQW5jaG9yID0gZnJhZztcbiAgICAgIC8vIElmIHdlIGFyZSB3YWl0aW5nLCB0aWNrIGltbWVkaWF0ZWx5IHRvIHVuYmxvY2sgYXVkaW8gZnJhZ21lbnQgdHJhbnNtdXhpbmdcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5XQUlUSU5HX0lOSVRfUFRTKSB7XG4gICAgICAgIGNvbnN0IHdhaXRpbmdEYXRhID0gdGhpcy53YWl0aW5nRGF0YTtcbiAgICAgICAgaWYgKCF3YWl0aW5nRGF0YSAmJiAhdGhpcy5sb2FkaW5nUGFydHMgfHwgd2FpdGluZ0RhdGEgJiYgd2FpdGluZ0RhdGEuZnJhZy5jYyAhPT0gY2MpIHtcbiAgICAgICAgICB0aGlzLnN5bmNXaXRoQW5jaG9yKGZyYWcsIHdhaXRpbmdEYXRhID09IG51bGwgPyB2b2lkIDAgOiB3YWl0aW5nRGF0YS5mcmFnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghdGhpcy5obHMuaGFzRW5vdWdoVG9TdGFydCAmJiBpbkZsaWdodEZyYWcgJiYgaW5GbGlnaHRGcmFnLmNjICE9PSBjYykge1xuICAgICAgICBpbkZsaWdodEZyYWcuYWJvcnRSZXF1ZXN0cygpO1xuICAgICAgICB0aGlzLnN5bmNXaXRoQW5jaG9yKGZyYWcsIGluRmxpZ2h0RnJhZyk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLklETEUpIHtcbiAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldExvYWRQb3NpdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkICYmIHRoaXMubmV4dExvYWRQb3NpdGlvbiA+PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5uZXh0TG9hZFBvc2l0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuZ2V0TG9hZFBvc2l0aW9uKCk7XG4gIH1cbiAgc3luY1dpdGhBbmNob3IobWFpbkFuY2hvciwgd2FpdGluZ1RvQXBwZW5kKSB7XG4gICAgdmFyIF90aGlzJG1haW5GcmFnTG9hZGluZztcbiAgICAvLyBEcm9wIHdhaXRpbmcgZnJhZ21lbnQgaWYgdmlkZW9UcmFja0NDIGhhcyBjaGFuZ2VkIHNpbmNlIHdhaXRpbmdGcmFnbWVudCB3YXMgc2V0IGFuZCBpbml0UFRTIHdhcyBub3QgZm91bmRcbiAgICBjb25zdCBtYWluRnJhZ0xvYWRpbmcgPSAoKF90aGlzJG1haW5GcmFnTG9hZGluZyA9IHRoaXMubWFpbkZyYWdMb2FkaW5nKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbWFpbkZyYWdMb2FkaW5nLmZyYWcpIHx8IG51bGw7XG4gICAgaWYgKHdhaXRpbmdUb0FwcGVuZCkge1xuICAgICAgaWYgKChtYWluRnJhZ0xvYWRpbmcgPT0gbnVsbCA/IHZvaWQgMCA6IG1haW5GcmFnTG9hZGluZy5jYykgPT09IHdhaXRpbmdUb0FwcGVuZC5jYykge1xuICAgICAgICAvLyBXYWl0IGZvciBsb2FkaW5nIGZyYWcgdG8gY29tcGxldGUgYW5kIElOSVRfUFRTX0ZPVU5EXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0RGlzY29udGludWl0eSA9IChtYWluRnJhZ0xvYWRpbmcgfHwgbWFpbkFuY2hvcikuY2M7XG4gICAgY29uc3QgdHJhY2tEZXRhaWxzID0gdGhpcy5nZXRMZXZlbERldGFpbHMoKTtcbiAgICBjb25zdCBwb3MgPSB0aGlzLmdldExvYWRQb3NpdGlvbigpO1xuICAgIGNvbnN0IHN5bmNGcmFnID0gZmluZE5lYXJlc3RXaXRoQ0ModHJhY2tEZXRhaWxzLCB0YXJnZXREaXNjb250aW51aXR5LCBwb3MpO1xuICAgIC8vIE9ubHkgc3RvcCB3YWl0aW5nIGZvciBhdWRpb0ZyYWcuY2MgaWYgYW4gYXVkaW8gc2VnbWVudCBvZiB0aGUgc2FtZSBkaXNjb250aW51aXR5IGRvbWFpbiAoY2MpIGlzIGZvdW5kXG4gICAgaWYgKHN5bmNGcmFnKSB7XG4gICAgICB0aGlzLmxvZyhgU3luY2luZyB3aXRoIG1haW4gZnJhZyBhdCAke3N5bmNGcmFnLnN0YXJ0fSBjYyAke3N5bmNGcmFnLmNjfWApO1xuICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHN5bmNGcmFnLnN0YXJ0O1xuICAgICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLklETEUpIHtcbiAgICAgICAgdGhpcy5kb1RpY2tJZGxlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0YXJ0TG9hZChzdGFydFBvc2l0aW9uLCBza2lwU2Vla1RvU3RhcnRQb3NpdGlvbikge1xuICAgIGlmICghdGhpcy5sZXZlbHMpIHtcbiAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHN0YXJ0UG9zaXRpb247XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGFzdEN1cnJlbnRUaW1lID0gdGhpcy5sYXN0Q3VycmVudFRpbWU7XG4gICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgIHRoaXMuc2V0SW50ZXJ2YWwoVElDS19JTlRFUlZBTCQzKTtcbiAgICBpZiAobGFzdEN1cnJlbnRUaW1lID4gMCAmJiBzdGFydFBvc2l0aW9uID09PSAtMSkge1xuICAgICAgdGhpcy5sb2coYE92ZXJyaWRlIHN0YXJ0UG9zaXRpb24gd2l0aCBsYXN0Q3VycmVudFRpbWUgQCR7bGFzdEN1cnJlbnRUaW1lLnRvRml4ZWQoMyl9YCk7XG4gICAgICBzdGFydFBvc2l0aW9uID0gbGFzdEN1cnJlbnRUaW1lO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5XQUlUSU5HX1RSQUNLO1xuICAgIH1cbiAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IHN0YXJ0UG9zaXRpb24gKyB0aGlzLnRpbWVsaW5lT2Zmc2V0O1xuICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHNraXBTZWVrVG9TdGFydFBvc2l0aW9uID8gLTEgOiBzdGFydFBvc2l0aW9uO1xuICAgIHRoaXMudGljaygpO1xuICB9XG4gIGRvVGljaygpIHtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgU3RhdGUuSURMRTpcbiAgICAgICAgdGhpcy5kb1RpY2tJZGxlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdGF0ZS5XQUlUSU5HX1RSQUNLOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgbGV2ZWxzLFxuICAgICAgICAgICAgdHJhY2tJZFxuICAgICAgICAgIH0gPSB0aGlzO1xuICAgICAgICAgIGNvbnN0IGN1cnJlblRyYWNrID0gbGV2ZWxzID09IG51bGwgPyB2b2lkIDAgOiBsZXZlbHNbdHJhY2tJZF07XG4gICAgICAgICAgY29uc3QgZGV0YWlscyA9IGN1cnJlblRyYWNrID09IG51bGwgPyB2b2lkIDAgOiBjdXJyZW5UcmFjay5kZXRhaWxzO1xuICAgICAgICAgIGlmIChkZXRhaWxzICYmICF0aGlzLndhaXRGb3JMaXZlKGN1cnJlblRyYWNrKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMud2FpdEZvckNkblR1bmVJbihkZXRhaWxzKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5XQUlUSU5HX0lOSVRfUFRTO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfdGhpcyRtZWRpYTtcbiAgICAgICAgICBjb25zdCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICBjb25zdCByZXRyeURhdGUgPSB0aGlzLnJldHJ5RGF0ZTtcbiAgICAgICAgICAvLyBpZiBjdXJyZW50IHRpbWUgaXMgZ3QgdGhhbiByZXRyeURhdGUsIG9yIGlmIG1lZGlhIHNlZWtpbmcgbGV0J3Mgc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gcmV0cnkgbG9hZGluZ1xuICAgICAgICAgIGlmICghcmV0cnlEYXRlIHx8IG5vdyA+PSByZXRyeURhdGUgfHwgKF90aGlzJG1lZGlhID0gdGhpcy5tZWRpYSkgIT0gbnVsbCAmJiBfdGhpcyRtZWRpYS5zZWVraW5nKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGxldmVscyxcbiAgICAgICAgICAgICAgdHJhY2tJZFxuICAgICAgICAgICAgfSA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmxvZygnUmV0cnlEYXRlIHJlYWNoZWQsIHN3aXRjaCBiYWNrIHRvIElETEUgc3RhdGUnKTtcbiAgICAgICAgICAgIHRoaXMucmVzZXRTdGFydFdoZW5Ob3RMb2FkZWQoKGxldmVscyA9PSBudWxsID8gdm9pZCAwIDogbGV2ZWxzW3RyYWNrSWRdKSB8fCBudWxsKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBTdGF0ZS5XQUlUSU5HX0lOSVRfUFRTOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gRW5zdXJlIHdlIGRvbid0IGdldCBzdHVjayBpbiB0aGUgV0FJVElOR19JTklUX1BUUyBzdGF0ZSBpZiB0aGUgd2FpdGluZyBmcmFnIENDIGRvZXNuJ3QgbWF0Y2ggYW55IGluaXRQVFNcbiAgICAgICAgICBjb25zdCB3YWl0aW5nRGF0YSA9IHRoaXMud2FpdGluZ0RhdGE7XG4gICAgICAgICAgaWYgKHdhaXRpbmdEYXRhKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgIHBhcnQsXG4gICAgICAgICAgICAgIGNhY2hlLFxuICAgICAgICAgICAgICBjb21wbGV0ZVxuICAgICAgICAgICAgfSA9IHdhaXRpbmdEYXRhO1xuICAgICAgICAgICAgY29uc3QgbWFpbkFuY2hvciA9IHRoaXMubWFpbkFuY2hvcjtcbiAgICAgICAgICAgIGlmICh0aGlzLmluaXRQVFNbZnJhZy5jY10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0aGlzLndhaXRpbmdEYXRhID0gbnVsbDtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkZSQUdfTE9BRElORztcbiAgICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGNhY2hlLmZsdXNoKCkuYnVmZmVyO1xuICAgICAgICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgICAgcGFydCxcbiAgICAgICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBudWxsXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHRoaXMuX2hhbmRsZUZyYWdtZW50TG9hZFByb2dyZXNzKGRhdGEpO1xuICAgICAgICAgICAgICBpZiAoY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBzdXBlci5faGFuZGxlRnJhZ21lbnRMb2FkQ29tcGxldGUoZGF0YSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWFpbkFuY2hvciAmJiBtYWluQW5jaG9yLmNjICE9PSB3YWl0aW5nRGF0YS5mcmFnLmNjKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3luY1dpdGhBbmNob3IobWFpbkFuY2hvciwgd2FpdGluZ0RhdGEuZnJhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm9uVGlja0VuZCgpO1xuICB9XG4gIHJlc2V0TG9hZGluZ1N0YXRlKCkge1xuICAgIGNvbnN0IHdhaXRpbmdEYXRhID0gdGhpcy53YWl0aW5nRGF0YTtcbiAgICBpZiAod2FpdGluZ0RhdGEpIHtcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KHdhaXRpbmdEYXRhLmZyYWcpO1xuICAgICAgdGhpcy53YWl0aW5nRGF0YSA9IG51bGw7XG4gICAgfVxuICAgIHN1cGVyLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gIH1cbiAgb25UaWNrRW5kKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lZGlhXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCEobWVkaWEgIT0gbnVsbCAmJiBtZWRpYS5yZWFkeVN0YXRlKSkge1xuICAgICAgLy8gRXhpdCBlYXJseSBpZiB3ZSBkb24ndCBoYXZlIG1lZGlhIG9yIGlmIHRoZSBtZWRpYSBoYXNuJ3QgYnVmZmVyZWQgYW55dGhpbmcgeWV0IChyZWFkeVN0YXRlIDApXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gIH1cbiAgZG9UaWNrSWRsZSgpIHtcbiAgICB2YXIgX3RoaXMkbWFpbkZyYWdMb2FkaW5nMjtcbiAgICBjb25zdCB7XG4gICAgICBobHMsXG4gICAgICBsZXZlbHMsXG4gICAgICBtZWRpYSxcbiAgICAgIHRyYWNrSWRcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBjb25maWcgPSBobHMuY29uZmlnO1xuXG4gICAgLy8gMS4gaWYgYnVmZmVyaW5nIGlzIHN1c3BlbmRlZFxuICAgIC8vIDIuIGlmIHZpZGVvIG5vdCBhdHRhY2hlZCBBTkRcbiAgICAvLyAgICBzdGFydCBmcmFnbWVudCBhbHJlYWR5IHJlcXVlc3RlZCBPUiBzdGFydCBmcmFnIHByZWZldGNoIG5vdCBlbmFibGVkXG4gICAgLy8gMy4gaWYgdHJhY2tzIG9yIHRyYWNrIG5vdCBsb2FkZWQgYW5kIHNlbGVjdGVkXG4gICAgLy8gdGhlbiBleGl0IGxvb3BcbiAgICAvLyA9PiBpZiBtZWRpYSBub3QgYXR0YWNoZWQgYnV0IHN0YXJ0IGZyYWcgcHJlZmV0Y2ggaXMgZW5hYmxlZCBhbmQgc3RhcnQgZnJhZyBub3QgcmVxdWVzdGVkIHlldCwgd2Ugd2lsbCBub3QgZXhpdCBsb29wXG4gICAgaWYgKCF0aGlzLmJ1ZmZlcmluZyB8fCAhbWVkaWEgJiYgIXRoaXMucHJpbWFyeVByZWZldGNoICYmICh0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCB8fCAhY29uZmlnLnN0YXJ0RnJhZ1ByZWZldGNoKSB8fCAhKGxldmVscyAhPSBudWxsICYmIGxldmVsc1t0cmFja0lkXSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGV2ZWxJbmZvID0gbGV2ZWxzW3RyYWNrSWRdO1xuICAgIGNvbnN0IHRyYWNrRGV0YWlscyA9IGxldmVsSW5mby5kZXRhaWxzO1xuICAgIGlmICghdHJhY2tEZXRhaWxzIHx8IHRoaXMud2FpdEZvckxpdmUobGV2ZWxJbmZvKSB8fCB0aGlzLndhaXRGb3JDZG5UdW5lSW4odHJhY2tEZXRhaWxzKSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLldBSVRJTkdfVFJBQ0s7XG4gICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBidWZmZXJhYmxlID0gdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhO1xuICAgIGlmICh0aGlzLmJ1ZmZlckZsdXNoZWQgJiYgYnVmZmVyYWJsZSkge1xuICAgICAgdGhpcy5idWZmZXJGbHVzaGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmFmdGVyQnVmZmVyRmx1c2hlZChidWZmZXJhYmxlLCBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU8sIFBsYXlsaXN0TGV2ZWxUeXBlLkFVRElPKTtcbiAgICB9XG4gICAgY29uc3QgYnVmZmVySW5mbyA9IHRoaXMuZ2V0RndkQnVmZmVySW5mbyhidWZmZXJhYmxlLCBQbGF5bGlzdExldmVsVHlwZS5BVURJTyk7XG4gICAgaWYgKGJ1ZmZlckluZm8gPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnN3aXRjaGluZ1RyYWNrICYmIHRoaXMuX3N0cmVhbUVuZGVkKGJ1ZmZlckluZm8sIHRyYWNrRGV0YWlscykpIHtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfRU9TLCB7XG4gICAgICAgIHR5cGU6ICdhdWRpbydcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVOREVEO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBidWZmZXJMZW4gPSBidWZmZXJJbmZvLmxlbjtcbiAgICBjb25zdCBtYXhCdWZMZW4gPSBobHMubWF4QnVmZmVyTGVuZ3RoO1xuICAgIGNvbnN0IGZyYWdtZW50cyA9IHRyYWNrRGV0YWlscy5mcmFnbWVudHM7XG4gICAgY29uc3Qgc3RhcnQgPSBmcmFnbWVudHNbMF0uc3RhcnQ7XG4gICAgY29uc3QgbG9hZFBvc2l0aW9uID0gdGhpcy5nZXRMb2FkUG9zaXRpb24oKTtcbiAgICBjb25zdCB0YXJnZXRCdWZmZXJUaW1lID0gdGhpcy5mbHVzaGluZyA/IGxvYWRQb3NpdGlvbiA6IGJ1ZmZlckluZm8uZW5kO1xuICAgIGlmICh0aGlzLnN3aXRjaGluZ1RyYWNrICYmIG1lZGlhKSB7XG4gICAgICBjb25zdCBwb3MgPSBsb2FkUG9zaXRpb247XG4gICAgICAvLyBpZiBjdXJyZW50VGltZSAocG9zKSBpcyBsZXNzIHRoYW4gYWx0IGF1ZGlvIHBsYXlsaXN0IHN0YXJ0IHRpbWUsIGl0IG1lYW5zIHRoYXQgYWx0IGF1ZGlvIGlzIGFoZWFkIG9mIGN1cnJlbnRUaW1lXG4gICAgICBpZiAodHJhY2tEZXRhaWxzLlBUU0tub3duICYmIHBvcyA8IHN0YXJ0KSB7XG4gICAgICAgIC8vIGlmIGV2ZXJ5dGhpbmcgaXMgYnVmZmVyZWQgZnJvbSBwb3MgdG8gc3RhcnQgb3IgaWYgYXVkaW8gYnVmZmVyIHVwZnJvbnQsIGxldCdzIHNlZWsgdG8gc3RhcnRcbiAgICAgICAgaWYgKGJ1ZmZlckluZm8uZW5kID4gc3RhcnQgfHwgYnVmZmVySW5mby5uZXh0U3RhcnQpIHtcbiAgICAgICAgICB0aGlzLmxvZygnQWx0IGF1ZGlvIHRyYWNrIGFoZWFkIG9mIG1haW4gdHJhY2ssIHNlZWsgdG8gc3RhcnQgb2YgYWx0IGF1ZGlvIHRyYWNrJyk7XG4gICAgICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSBzdGFydCArIDAuMDU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiBidWZmZXIgbGVuZ3RoIGlzIGxlc3MgdGhhbiBtYXhCdWZMZW4sIG9yIG5lYXIgdGhlIGVuZCwgZmluZCBhIGZyYWdtZW50IHRvIGxvYWRcbiAgICBpZiAoYnVmZmVyTGVuID49IG1heEJ1ZkxlbiAmJiAhdGhpcy5zd2l0Y2hpbmdUcmFjayAmJiB0YXJnZXRCdWZmZXJUaW1lIDwgZnJhZ21lbnRzW2ZyYWdtZW50cy5sZW5ndGggLSAxXS5zdGFydCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgZnJhZyA9IHRoaXMuZ2V0TmV4dEZyYWdtZW50KHRhcmdldEJ1ZmZlclRpbWUsIHRyYWNrRGV0YWlscyk7XG4gICAgLy8gQXZvaWQgbG9vcCBsb2FkaW5nIGJ5IHVzaW5nIG5leHRMb2FkUG9zaXRpb24gc2V0IGZvciBiYWNrdHJhY2tpbmcgYW5kIHNraXBwaW5nIGNvbnNlY3V0aXZlIEdBUCB0YWdzXG4gICAgaWYgKGZyYWcgJiYgdGhpcy5pc0xvb3BMb2FkaW5nKGZyYWcsIHRhcmdldEJ1ZmZlclRpbWUpKSB7XG4gICAgICBmcmFnID0gdGhpcy5nZXROZXh0RnJhZ21lbnRMb29wTG9hZGluZyhmcmFnLCB0cmFja0RldGFpbHMsIGJ1ZmZlckluZm8sIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4sIG1heEJ1Zkxlbik7XG4gICAgfVxuICAgIGlmICghZnJhZykge1xuICAgICAgdGhpcy5idWZmZXJGbHVzaGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBSZXF1ZXN0IGF1ZGlvIHNlZ21lbnRzIHVwIHRvIG9uZSBmcmFnbWVudCBhaGVhZCBvZiBtYWluIHN0cmVhbS1jb250cm9sbGVyXG4gICAgbGV0IG1haW5GcmFnTG9hZGluZyA9ICgoX3RoaXMkbWFpbkZyYWdMb2FkaW5nMiA9IHRoaXMubWFpbkZyYWdMb2FkaW5nKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbWFpbkZyYWdMb2FkaW5nMi5mcmFnKSB8fCBudWxsO1xuICAgIGlmICghdGhpcy5hdWRpb09ubHkgJiYgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgJiYgbWFpbkZyYWdMb2FkaW5nICYmIGlzTWVkaWFGcmFnbWVudChmcmFnKSAmJiAhZnJhZy5lbmRMaXN0ICYmICghdHJhY2tEZXRhaWxzLmxpdmUgfHwgIXRoaXMubG9hZGluZ1BhcnRzICYmIHRhcmdldEJ1ZmZlclRpbWUgPCB0aGlzLmhscy5saXZlU3luY1Bvc2l0aW9uKSkge1xuICAgICAgaWYgKHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKG1haW5GcmFnTG9hZGluZykgPT09IEZyYWdtZW50U3RhdGUuT0spIHtcbiAgICAgICAgdGhpcy5tYWluRnJhZ0xvYWRpbmcgPSBtYWluRnJhZ0xvYWRpbmcgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKG1haW5GcmFnTG9hZGluZyAmJiBpc01lZGlhRnJhZ21lbnQobWFpbkZyYWdMb2FkaW5nKSkge1xuICAgICAgICBpZiAoZnJhZy5zdGFydCA+IG1haW5GcmFnTG9hZGluZy5lbmQpIHtcbiAgICAgICAgICAvLyBHZXQgYnVmZmVyZWQgZnJhZyBhdCB0YXJnZXQgcG9zaXRpb24gZnJvbSB0cmFja2VyIChsb2FkZWQgb3V0IG9mIHNlcXVlbmNlKVxuICAgICAgICAgIGNvbnN0IG1haW5GcmFnQXRQb3MgPSB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRGcmFnQXRQb3ModGFyZ2V0QnVmZmVyVGltZSwgUGxheWxpc3RMZXZlbFR5cGUuTUFJTik7XG4gICAgICAgICAgaWYgKG1haW5GcmFnQXRQb3MgJiYgbWFpbkZyYWdBdFBvcy5lbmQgPiBtYWluRnJhZ0xvYWRpbmcuZW5kKSB7XG4gICAgICAgICAgICBtYWluRnJhZ0xvYWRpbmcgPSBtYWluRnJhZ0F0UG9zO1xuICAgICAgICAgICAgdGhpcy5tYWluRnJhZ0xvYWRpbmcgPSB7XG4gICAgICAgICAgICAgIGZyYWc6IG1haW5GcmFnQXRQb3MsXG4gICAgICAgICAgICAgIHRhcmdldEJ1ZmZlclRpbWU6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF0QnVmZmVyU3luY0xpbWl0ID0gZnJhZy5zdGFydCA+IG1haW5GcmFnTG9hZGluZy5lbmQ7XG4gICAgICAgIGlmIChhdEJ1ZmZlclN5bmNMaW1pdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxvYWRGcmFnbWVudChmcmFnLCBsZXZlbEluZm8sIHRhcmdldEJ1ZmZlclRpbWUpO1xuICB9XG4gIG9uTWVkaWFEZXRhY2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLmJ1ZmZlckZsdXNoZWQgPSB0aGlzLmZsdXNoaW5nID0gZmFsc2U7XG4gICAgc3VwZXIub25NZWRpYURldGFjaGluZyhldmVudCwgZGF0YSk7XG4gIH1cbiAgb25BdWRpb1RyYWNrc1VwZGF0ZWQoZXZlbnQsIHtcbiAgICBhdWRpb1RyYWNrc1xuICB9KSB7XG4gICAgLy8gUmVzZXQgdHJhbnhtdXhlciBpcyBlc3NlbnRpYWwgZm9yIGxhcmdlIGNvbnRleHQgc3dpdGNoZXMgKENvbnRlbnQgU3RlZXJpbmcpXG4gICAgdGhpcy5yZXNldFRyYW5zbXV4ZXIoKTtcbiAgICB0aGlzLmxldmVscyA9IGF1ZGlvVHJhY2tzLm1hcChtZWRpYVBsYXlsaXN0ID0+IG5ldyBMZXZlbChtZWRpYVBsYXlsaXN0KSk7XG4gIH1cbiAgb25BdWRpb1RyYWNrU3dpdGNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgLy8gaWYgYW55IFVSTCBmb3VuZCBvbiBuZXcgYXVkaW8gdHJhY2ssIGl0IGlzIGFuIGFsdGVybmF0ZSBhdWRpbyB0cmFja1xuICAgIGNvbnN0IGFsdEF1ZGlvID0gISFkYXRhLnVybDtcbiAgICB0aGlzLnRyYWNrSWQgPSBkYXRhLmlkO1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWdDdXJyZW50XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGZyYWdDdXJyZW50KSB7XG4gICAgICBmcmFnQ3VycmVudC5hYm9ydFJlcXVlc3RzKCk7XG4gICAgICB0aGlzLnJlbW92ZVVuYnVmZmVyZWRGcmFncyhmcmFnQ3VycmVudC5zdGFydCk7XG4gICAgfVxuICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcblxuICAgIC8vIHNob3VsZCB3ZSBzd2l0Y2ggdHJhY2tzID9cbiAgICBpZiAoYWx0QXVkaW8pIHtcbiAgICAgIHRoaXMuc3dpdGNoaW5nVHJhY2sgPSBkYXRhO1xuICAgICAgLy8gbWFpbiBhdWRpbyB0cmFjayBhcmUgaGFuZGxlZCBieSBzdHJlYW0tY29udHJvbGxlciwganVzdCBkbyBzb21ldGhpbmcgaWYgc3dpdGNoaW5nIHRvIGFsdCBhdWRpbyB0cmFja1xuICAgICAgdGhpcy5mbHVzaEF1ZGlvSWZOZWVkZWQoZGF0YSk7XG4gICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU3RhdGUuU1RPUFBFRCkge1xuICAgICAgICAvLyBzd2l0Y2hpbmcgdG8gYXVkaW8gdHJhY2ssIHN0YXJ0IHRpbWVyIGlmIG5vdCBhbHJlYWR5IHN0YXJ0ZWRcbiAgICAgICAgdGhpcy5zZXRJbnRlcnZhbChUSUNLX0lOVEVSVkFMJDMpO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGRlc3Ryb3kgdXNlbGVzcyB0cmFuc211eGVyIHdoZW4gc3dpdGNoaW5nIGF1ZGlvIHRvIG1haW5cbiAgICAgIHRoaXMucmVzZXRUcmFuc211eGVyKCk7XG4gICAgICB0aGlzLnN3aXRjaGluZ1RyYWNrID0gbnVsbDtcbiAgICAgIHRoaXMuYnVmZmVyZWRUcmFjayA9IGRhdGE7XG4gICAgICB0aGlzLmNsZWFySW50ZXJ2YWwoKTtcbiAgICB9XG4gIH1cbiAgb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgc3VwZXIub25NYW5pZmVzdExvYWRpbmcoKTtcbiAgICB0aGlzLmJ1ZmZlckZsdXNoZWQgPSB0aGlzLmZsdXNoaW5nID0gdGhpcy5hdWRpb09ubHkgPSBmYWxzZTtcbiAgICB0aGlzLnJlc2V0SXRlbSgpO1xuICAgIHRoaXMudHJhY2tJZCA9IC0xO1xuICB9XG4gIG9uTGV2ZWxMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLm1haW5EZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuICAgIGNvbnN0IGNhY2hlZFRyYWNrTG9hZGVkRGF0YSA9IHRoaXMuY2FjaGVkVHJhY2tMb2FkZWREYXRhO1xuICAgIGlmIChjYWNoZWRUcmFja0xvYWRlZERhdGEpIHtcbiAgICAgIHRoaXMuY2FjaGVkVHJhY2tMb2FkZWREYXRhID0gbnVsbDtcbiAgICAgIHRoaXMub25BdWRpb1RyYWNrTG9hZGVkKEV2ZW50cy5BVURJT19UUkFDS19MT0FERUQsIGNhY2hlZFRyYWNrTG9hZGVkRGF0YSk7XG4gICAgfVxuICB9XG4gIG9uQXVkaW9UcmFja0xvYWRlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBfdHJhY2tMZXZlbCRkZXRhaWxzO1xuICAgIGNvbnN0IHtcbiAgICAgIGxldmVsc1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIGRldGFpbHM6IG5ld0RldGFpbHMsXG4gICAgICBpZDogdHJhY2tJZCxcbiAgICAgIGdyb3VwSWQsXG4gICAgICB0cmFja1xuICAgIH0gPSBkYXRhO1xuICAgIGlmICghbGV2ZWxzKSB7XG4gICAgICB0aGlzLndhcm4oYEF1ZGlvIHRyYWNrcyByZXNldCB3aGlsZSBsb2FkaW5nIHRyYWNrICR7dHJhY2tJZH0gXCIke3RyYWNrLm5hbWV9XCIgb2YgXCIke2dyb3VwSWR9XCJgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWFpbkRldGFpbHMgPSB0aGlzLm1haW5EZXRhaWxzO1xuICAgIGlmICghbWFpbkRldGFpbHMgfHwgbmV3RGV0YWlscy5lbmRDQyA+IG1haW5EZXRhaWxzLmVuZENDIHx8IG1haW5EZXRhaWxzLmV4cGlyZWQpIHtcbiAgICAgIHRoaXMuY2FjaGVkVHJhY2tMb2FkZWREYXRhID0gZGF0YTtcbiAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTdGF0ZS5TVE9QUEVEKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5XQUlUSU5HX1RSQUNLO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmNhY2hlZFRyYWNrTG9hZGVkRGF0YSA9IG51bGw7XG4gICAgdGhpcy5sb2coYEF1ZGlvIHRyYWNrICR7dHJhY2tJZH0gXCIke3RyYWNrLm5hbWV9XCIgb2YgXCIke2dyb3VwSWR9XCIgbG9hZGVkIFske25ld0RldGFpbHMuc3RhcnRTTn0sJHtuZXdEZXRhaWxzLmVuZFNOfV0ke25ld0RldGFpbHMubGFzdFBhcnRTbiA/IGBbcGFydC0ke25ld0RldGFpbHMubGFzdFBhcnRTbn0tJHtuZXdEZXRhaWxzLmxhc3RQYXJ0SW5kZXh9XWAgOiAnJ30sZHVyYXRpb246JHtuZXdEZXRhaWxzLnRvdGFsZHVyYXRpb259YCk7XG4gICAgY29uc3QgdHJhY2tMZXZlbCA9IGxldmVsc1t0cmFja0lkXTtcbiAgICBsZXQgc2xpZGluZyA9IDA7XG4gICAgaWYgKG5ld0RldGFpbHMubGl2ZSB8fCAoX3RyYWNrTGV2ZWwkZGV0YWlscyA9IHRyYWNrTGV2ZWwuZGV0YWlscykgIT0gbnVsbCAmJiBfdHJhY2tMZXZlbCRkZXRhaWxzLmxpdmUpIHtcbiAgICAgIHRoaXMuY2hlY2tMaXZlVXBkYXRlKG5ld0RldGFpbHMpO1xuICAgICAgaWYgKG5ld0RldGFpbHMuZGVsdGFVcGRhdGVGYWlsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRyYWNrTGV2ZWwuZGV0YWlscykge1xuICAgICAgICB2YXIgX3RoaXMkbGV2ZWxMYXN0TG9hZGVkO1xuICAgICAgICBzbGlkaW5nID0gdGhpcy5hbGlnblBsYXlsaXN0cyhuZXdEZXRhaWxzLCB0cmFja0xldmVsLmRldGFpbHMsIChfdGhpcyRsZXZlbExhc3RMb2FkZWQgPSB0aGlzLmxldmVsTGFzdExvYWRlZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGxldmVsTGFzdExvYWRlZC5kZXRhaWxzKTtcbiAgICAgIH1cbiAgICAgIGlmICghbmV3RGV0YWlscy5hbGlnbmVkU2xpZGluZykge1xuICAgICAgICAvLyBBbGlnbiBhdWRpbyByZW5kaXRpb24gd2l0aCB0aGUgXCJtYWluXCIgcGxheWxpc3Qgb24gZGlzY29udGludWl0eSBjaGFuZ2VcbiAgICAgICAgLy8gb3IgcHJvZ3JhbS1kYXRlLXRpbWUgKFBEVClcbiAgICAgICAgYWxpZ25EaXNjb250aW51aXRpZXMobmV3RGV0YWlscywgbWFpbkRldGFpbHMpO1xuICAgICAgICBpZiAoIW5ld0RldGFpbHMuYWxpZ25lZFNsaWRpbmcpIHtcbiAgICAgICAgICBhbGlnbk1lZGlhUGxheWxpc3RCeVBEVChuZXdEZXRhaWxzLCBtYWluRGV0YWlscyk7XG4gICAgICAgIH1cbiAgICAgICAgc2xpZGluZyA9IG5ld0RldGFpbHMuZnJhZ21lbnRTdGFydDtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJhY2tMZXZlbC5kZXRhaWxzID0gbmV3RGV0YWlscztcbiAgICB0aGlzLmxldmVsTGFzdExvYWRlZCA9IHRyYWNrTGV2ZWw7XG5cbiAgICAvLyBjb21wdXRlIHN0YXJ0IHBvc2l0aW9uIGlmIHdlIGFyZSBhbGlnbmVkIHdpdGggdGhlIG1haW4gcGxheWxpc3RcbiAgICBpZiAoIXRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkKSB7XG4gICAgICB0aGlzLnNldFN0YXJ0UG9zaXRpb24obWFpbkRldGFpbHMsIHNsaWRpbmcpO1xuICAgIH1cbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5BVURJT19UUkFDS19VUERBVEVELCB7XG4gICAgICBkZXRhaWxzOiBuZXdEZXRhaWxzLFxuICAgICAgaWQ6IHRyYWNrSWQsXG4gICAgICBncm91cElkOiBkYXRhLmdyb3VwSWRcbiAgICB9KTtcblxuICAgIC8vIG9ubHkgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZSBpZiB3ZSB3ZXJlIHdhaXRpbmcgZm9yIHRyYWNrIHRvIHN0YXJ0IGRvd25sb2FkaW5nIGEgbmV3IGZyYWdtZW50XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLldBSVRJTkdfVFJBQ0sgJiYgIXRoaXMud2FpdEZvckNkblR1bmVJbihuZXdEZXRhaWxzKSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgfVxuXG4gICAgLy8gdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgIHRoaXMudGljaygpO1xuICB9XG4gIF9oYW5kbGVGcmFnbWVudExvYWRQcm9ncmVzcyhkYXRhKSB7XG4gICAgdmFyIF9mcmFnJGluaXRTZWdtZW50O1xuICAgIGNvbnN0IGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgY29uc3Qge1xuICAgICAgcGFydCxcbiAgICAgIHBheWxvYWRcbiAgICB9ID0gZGF0YTtcbiAgICBjb25zdCB7XG4gICAgICBjb25maWcsXG4gICAgICB0cmFja0lkLFxuICAgICAgbGV2ZWxzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFsZXZlbHMpIHtcbiAgICAgIHRoaXMud2FybihgQXVkaW8gdHJhY2tzIHdlcmUgcmVzZXQgd2hpbGUgZnJhZ21lbnQgbG9hZCB3YXMgaW4gcHJvZ3Jlc3MuIEZyYWdtZW50ICR7ZnJhZy5zbn0gb2YgbGV2ZWwgJHtmcmFnLmxldmVsfSB3aWxsIG5vdCBiZSBidWZmZXJlZGApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0cmFjayA9IGxldmVsc1t0cmFja0lkXTtcbiAgICBpZiAoIXRyYWNrKSB7XG4gICAgICB0aGlzLndhcm4oJ0F1ZGlvIHRyYWNrIGlzIHVuZGVmaW5lZCBvbiBmcmFnbWVudCBsb2FkIHByb2dyZXNzJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRldGFpbHMgPSB0cmFjay5kZXRhaWxzO1xuICAgIGlmICghZGV0YWlscykge1xuICAgICAgdGhpcy53YXJuKCdBdWRpbyB0cmFjayBkZXRhaWxzIHVuZGVmaW5lZCBvbiBmcmFnbWVudCBsb2FkIHByb2dyZXNzJyk7XG4gICAgICB0aGlzLnJlbW92ZVVuYnVmZmVyZWRGcmFncyhmcmFnLnN0YXJ0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYXVkaW9Db2RlYyA9IGNvbmZpZy5kZWZhdWx0QXVkaW9Db2RlYyB8fCB0cmFjay5hdWRpb0NvZGVjIHx8ICdtcDRhLjQwLjInO1xuICAgIGxldCB0cmFuc211eGVyID0gdGhpcy50cmFuc211eGVyO1xuICAgIGlmICghdHJhbnNtdXhlcikge1xuICAgICAgdHJhbnNtdXhlciA9IHRoaXMudHJhbnNtdXhlciA9IG5ldyBUcmFuc211eGVySW50ZXJmYWNlKHRoaXMuaGxzLCBQbGF5bGlzdExldmVsVHlwZS5BVURJTywgdGhpcy5faGFuZGxlVHJhbnNtdXhDb21wbGV0ZS5iaW5kKHRoaXMpLCB0aGlzLl9oYW5kbGVUcmFuc211eGVyRmx1c2guYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSB2aWRlbyBpbml0UFRTXG4gICAgLy8gSWYgbm90IHdlIG5lZWQgdG8gd2FpdCBmb3IgaXRcbiAgICBjb25zdCBpbml0UFRTID0gdGhpcy5pbml0UFRTW2ZyYWcuY2NdO1xuICAgIGNvbnN0IGluaXRTZWdtZW50RGF0YSA9IChfZnJhZyRpbml0U2VnbWVudCA9IGZyYWcuaW5pdFNlZ21lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZnJhZyRpbml0U2VnbWVudC5kYXRhO1xuICAgIGlmIChpbml0UFRTICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHRoaXMubG9nKGBUcmFuc211eGluZyAke3NufSBvZiBbJHtkZXRhaWxzLnN0YXJ0U059ICwke2RldGFpbHMuZW5kU059XSx0cmFjayAke3RyYWNrSWR9YCk7XG4gICAgICAvLyB0aW1lIE9mZnNldCBpcyBhY2N1cmF0ZSBpZiBsZXZlbCBQVFMgaXMga25vd24sIG9yIGlmIHBsYXlsaXN0IGlzIG5vdCBzbGlkaW5nIChub3QgbGl2ZSlcbiAgICAgIGNvbnN0IGFjY3VyYXRlVGltZU9mZnNldCA9IGZhbHNlOyAvLyBkZXRhaWxzLlBUU0tub3duIHx8ICFkZXRhaWxzLmxpdmU7XG4gICAgICBjb25zdCBwYXJ0SW5kZXggPSBwYXJ0ID8gcGFydC5pbmRleCA6IC0xO1xuICAgICAgY29uc3QgcGFydGlhbCA9IHBhcnRJbmRleCAhPT0gLTE7XG4gICAgICBjb25zdCBjaHVua01ldGEgPSBuZXcgQ2h1bmtNZXRhZGF0YShmcmFnLmxldmVsLCBmcmFnLnNuLCBmcmFnLnN0YXRzLmNodW5rQ291bnQsIHBheWxvYWQuYnl0ZUxlbmd0aCwgcGFydEluZGV4LCBwYXJ0aWFsKTtcbiAgICAgIHRyYW5zbXV4ZXIucHVzaChwYXlsb2FkLCBpbml0U2VnbWVudERhdGEsIGF1ZGlvQ29kZWMsICcnLCBmcmFnLCBwYXJ0LCBkZXRhaWxzLnRvdGFsZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhLCBpbml0UFRTKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2coYFVua25vd24gdmlkZW8gUFRTIGZvciBjYyAke2ZyYWcuY2N9LCB3YWl0aW5nIGZvciB2aWRlbyBQVFMgYmVmb3JlIGRlbXV4aW5nIGF1ZGlvIGZyYWcgJHtmcmFnLnNufSBvZiBbJHtkZXRhaWxzLnN0YXJ0U059ICwke2RldGFpbHMuZW5kU059XSx0cmFjayAke3RyYWNrSWR9YCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNhY2hlXG4gICAgICB9ID0gdGhpcy53YWl0aW5nRGF0YSA9IHRoaXMud2FpdGluZ0RhdGEgfHwge1xuICAgICAgICBmcmFnLFxuICAgICAgICBwYXJ0LFxuICAgICAgICBjYWNoZTogbmV3IENodW5rQ2FjaGUoKSxcbiAgICAgICAgY29tcGxldGU6IGZhbHNlXG4gICAgICB9O1xuICAgICAgY2FjaGUucHVzaChuZXcgVWludDhBcnJheShwYXlsb2FkKSk7XG4gICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU3RhdGUuU1RPUFBFRCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19JTklUX1BUUztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2hhbmRsZUZyYWdtZW50TG9hZENvbXBsZXRlKGZyYWdMb2FkZWREYXRhKSB7XG4gICAgaWYgKHRoaXMud2FpdGluZ0RhdGEpIHtcbiAgICAgIHRoaXMud2FpdGluZ0RhdGEuY29tcGxldGUgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5faGFuZGxlRnJhZ21lbnRMb2FkQ29tcGxldGUoZnJhZ0xvYWRlZERhdGEpO1xuICB9XG4gIG9uQnVmZmVyUmVzZXQoLyogZXZlbnQ6IEV2ZW50cy5CVUZGRVJfUkVTRVQgKi9cbiAgKSB7XG4gICAgLy8gcmVzZXQgcmVmZXJlbmNlIHRvIHNvdXJjZWJ1ZmZlcnNcbiAgICB0aGlzLm1lZGlhQnVmZmVyID0gbnVsbDtcbiAgfVxuICBvbkJ1ZmZlckNyZWF0ZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLmJ1ZmZlckZsdXNoZWQgPSB0aGlzLmZsdXNoaW5nID0gZmFsc2U7XG4gICAgY29uc3QgYXVkaW9UcmFjayA9IGRhdGEudHJhY2tzLmF1ZGlvO1xuICAgIGlmIChhdWRpb1RyYWNrKSB7XG4gICAgICB0aGlzLm1lZGlhQnVmZmVyID0gYXVkaW9UcmFjay5idWZmZXIgfHwgbnVsbDtcbiAgICB9XG4gIH1cbiAgb25GcmFnTG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgIGlmICghdGhpcy5hdWRpb09ubHkgJiYgZGF0YS5mcmFnLnR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4gJiYgaXNNZWRpYUZyYWdtZW50KGRhdGEuZnJhZykpIHtcbiAgICAgIHRoaXMubWFpbkZyYWdMb2FkaW5nID0gZGF0YTtcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5JRExFKSB7XG4gICAgICAgIHRoaXMudGljaygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBvbkZyYWdCdWZmZXJlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWcsXG4gICAgICBwYXJ0XG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKGZyYWcudHlwZSAhPT0gUGxheWxpc3RMZXZlbFR5cGUuQVVESU8pIHtcbiAgICAgIGlmICghdGhpcy5hdWRpb09ubHkgJiYgZnJhZy50eXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOICYmICFmcmFnLmVsZW1lbnRhcnlTdHJlYW1zLnZpZGVvICYmICFmcmFnLmVsZW1lbnRhcnlTdHJlYW1zLmF1ZGlvdmlkZW8pIHtcbiAgICAgICAgdGhpcy5hdWRpb09ubHkgPSB0cnVlO1xuICAgICAgICB0aGlzLm1haW5GcmFnTG9hZGluZyA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgLy8gSWYgYSBsZXZlbCBzd2l0Y2ggd2FzIHJlcXVlc3RlZCB3aGlsZSBhIGZyYWdtZW50IHdhcyBidWZmZXJpbmcsIGl0IHdpbGwgZW1pdCB0aGUgRlJBR19CVUZGRVJFRCBldmVudCB1cG9uIGNvbXBsZXRpb25cbiAgICAgIC8vIEF2b2lkIHNldHRpbmcgc3RhdGUgYmFjayB0byBJRExFIG9yIGNvbmNsdWRpbmcgdGhlIGF1ZGlvIHN3aXRjaDsgb3RoZXJ3aXNlLCB0aGUgc3dpdGNoZWQtdG8gdHJhY2sgd2lsbCBub3QgYnVmZmVyXG4gICAgICB0aGlzLndhcm4oYEZyYWdtZW50ICR7ZnJhZy5zbn0ke3BhcnQgPyAnIHA6ICcgKyBwYXJ0LmluZGV4IDogJyd9IG9mIGxldmVsICR7ZnJhZy5sZXZlbH0gZmluaXNoZWQgYnVmZmVyaW5nLCBidXQgd2FzIGFib3J0ZWQuIHN0YXRlOiAke3RoaXMuc3RhdGV9LCBhdWRpb1N3aXRjaDogJHt0aGlzLnN3aXRjaGluZ1RyYWNrID8gdGhpcy5zd2l0Y2hpbmdUcmFjay5uYW1lIDogJ2ZhbHNlJ31gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzTWVkaWFGcmFnbWVudChmcmFnKSkge1xuICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBmcmFnO1xuICAgICAgY29uc3QgdHJhY2sgPSB0aGlzLnN3aXRjaGluZ1RyYWNrO1xuICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyZWRUcmFjayA9IHRyYWNrO1xuICAgICAgICB0aGlzLnN3aXRjaGluZ1RyYWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENIRUQsIF9vYmplY3RTcHJlYWQyKHt9LCB0cmFjaykpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmZyYWdCdWZmZXJlZENvbXBsZXRlKGZyYWcsIHBhcnQpO1xuICAgIGlmICh0aGlzLm1lZGlhKSB7XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9XG4gIH1cbiAgb25FcnJvcihldmVudCwgZGF0YSkge1xuICAgIHZhciBfZGF0YSRjb250ZXh0O1xuICAgIGlmIChkYXRhLmZhdGFsKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRVJST1I7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaCAoZGF0YS5kZXRhaWxzKSB7XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0dBUDpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfREVDUllQVF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5LRVlfTE9BRF9USU1FT1VUOlxuICAgICAgICB0aGlzLm9uRnJhZ21lbnRPcktleUxvYWRFcnJvcihQbGF5bGlzdExldmVsVHlwZS5BVURJTywgZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfVElNRU9VVDpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX1BBUlNJTkdfRVJST1I6XG4gICAgICAgIC8vIGluIGNhc2Ugb2Ygbm9uIGZhdGFsIGVycm9yIHdoaWxlIGxvYWRpbmcgdHJhY2ssIGlmIG5vdCByZXRyeWluZyB0byBsb2FkIHRyYWNrLCBzd2l0Y2ggYmFjayB0byBJRExFXG4gICAgICAgIGlmICghZGF0YS5sZXZlbFJldHJ5ICYmIHRoaXMuc3RhdGUgPT09IFN0YXRlLldBSVRJTkdfVFJBQ0sgJiYgKChfZGF0YSRjb250ZXh0ID0gZGF0YS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGEkY29udGV4dC50eXBlKSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSykge1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0FERF9DT0RFQ19FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRfRVJST1I6XG4gICAgICAgIGlmIChkYXRhLnBhcmVudCAhPT0gJ2F1ZGlvJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMucmVkdWNlTGVuZ3RoQW5kRmx1c2hCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfRlVMTF9FUlJPUjpcbiAgICAgICAgaWYgKGRhdGEucGFyZW50ICE9PSAnYXVkaW8nKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlZHVjZUxlbmd0aEFuZEZsdXNoQnVmZmVyKGRhdGEpKSB7XG4gICAgICAgICAgdGhpcy5idWZmZXJlZFRyYWNrID0gbnVsbDtcbiAgICAgICAgICBzdXBlci5mbHVzaE1haW5CdWZmZXIoMCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCAnYXVkaW8nKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLklOVEVSTkFMX0VYQ0VQVElPTjpcbiAgICAgICAgdGhpcy5yZWNvdmVyV29ya2VyRXJyb3IoZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBvbkJ1ZmZlckZsdXNoaW5nKGV2ZW50LCB7XG4gICAgdHlwZVxuICB9KSB7XG4gICAgaWYgKHR5cGUgIT09IEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFTykge1xuICAgICAgdGhpcy5mbHVzaGluZyA9IHRydWU7XG4gICAgfVxuICB9XG4gIG9uQnVmZmVyRmx1c2hlZChldmVudCwge1xuICAgIHR5cGVcbiAgfSkge1xuICAgIGlmICh0eXBlICE9PSBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU8pIHtcbiAgICAgIHRoaXMuZmx1c2hpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuYnVmZmVyRmx1c2hlZCA9IHRydWU7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuRU5ERUQpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB9XG4gICAgICBjb25zdCBtZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWFCdWZmZXIgfHwgdGhpcy5tZWRpYTtcbiAgICAgIGlmIChtZWRpYUJ1ZmZlcikge1xuICAgICAgICB0aGlzLmFmdGVyQnVmZmVyRmx1c2hlZChtZWRpYUJ1ZmZlciwgdHlwZSwgUGxheWxpc3RMZXZlbFR5cGUuQVVESU8pO1xuICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2hhbmRsZVRyYW5zbXV4Q29tcGxldGUodHJhbnNtdXhSZXN1bHQpIHtcbiAgICB2YXIgX2lkMyRzYW1wbGVzO1xuICAgIGNvbnN0IGlkID0gJ2F1ZGlvJztcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICByZW11eFJlc3VsdCxcbiAgICAgIGNodW5rTWV0YVxuICAgIH0gPSB0cmFuc211eFJlc3VsdDtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5nZXRDdXJyZW50Q29udGV4dChjaHVua01ldGEpO1xuICAgIGlmICghY29udGV4dCkge1xuICAgICAgdGhpcy5yZXNldFdoZW5NaXNzaW5nQ29udGV4dChjaHVua01ldGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBmcmFnLFxuICAgICAgcGFydCxcbiAgICAgIGxldmVsXG4gICAgfSA9IGNvbnRleHQ7XG4gICAgY29uc3Qge1xuICAgICAgZGV0YWlsc1xuICAgIH0gPSBsZXZlbDtcbiAgICBjb25zdCB7XG4gICAgICBhdWRpbyxcbiAgICAgIHRleHQsXG4gICAgICBpZDMsXG4gICAgICBpbml0U2VnbWVudFxuICAgIH0gPSByZW11eFJlc3VsdDtcblxuICAgIC8vIENoZWNrIGlmIHRoZSBjdXJyZW50IGZyYWdtZW50IGhhcyBiZWVuIGFib3J0ZWQuIFdlIGNoZWNrIHRoaXMgYnkgZmlyc3Qgc2VlaW5nIGlmIHdlJ3JlIHN0aWxsIHBsYXlpbmcgdGhlIGN1cnJlbnQgbGV2ZWwuXG4gICAgLy8gSWYgd2UgYXJlLCBzdWJzZXF1ZW50bHkgY2hlY2sgaWYgdGhlIGN1cnJlbnRseSBsb2FkaW5nIGZyYWdtZW50IChmcmFnQ3VycmVudCkgaGFzIGNoYW5nZWQuXG4gICAgaWYgKHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpIHx8ICFkZXRhaWxzKSB7XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBUlNJTkc7XG4gICAgaWYgKHRoaXMuc3dpdGNoaW5nVHJhY2sgJiYgYXVkaW8pIHtcbiAgICAgIHRoaXMuY29tcGxldGVBdWRpb1N3aXRjaCh0aGlzLnN3aXRjaGluZ1RyYWNrKTtcbiAgICB9XG4gICAgaWYgKGluaXRTZWdtZW50ICE9IG51bGwgJiYgaW5pdFNlZ21lbnQudHJhY2tzKSB7XG4gICAgICBjb25zdCBtYXBGcmFnbWVudCA9IGZyYWcuaW5pdFNlZ21lbnQgfHwgZnJhZztcbiAgICAgIHRoaXMuX2J1ZmZlckluaXRTZWdtZW50KGxldmVsLCBpbml0U2VnbWVudC50cmFja3MsIG1hcEZyYWdtZW50LCBjaHVua01ldGEpO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsIHtcbiAgICAgICAgZnJhZzogbWFwRnJhZ21lbnQsXG4gICAgICAgIGlkLFxuICAgICAgICB0cmFja3M6IGluaXRTZWdtZW50LnRyYWNrc1xuICAgICAgfSk7XG4gICAgICAvLyBPbmx5IGZsdXNoIGF1ZGlvIGZyb20gb2xkIGF1ZGlvIHRyYWNrcyB3aGVuIFBUUyBpcyBrbm93biBvbiBuZXcgYXVkaW8gdHJhY2tcbiAgICB9XG4gICAgaWYgKGF1ZGlvKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHN0YXJ0UFRTLFxuICAgICAgICBlbmRQVFMsXG4gICAgICAgIHN0YXJ0RFRTLFxuICAgICAgICBlbmREVFNcbiAgICAgIH0gPSBhdWRpbztcbiAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgIHBhcnQuZWxlbWVudGFyeVN0cmVhbXNbRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPXSA9IHtcbiAgICAgICAgICBzdGFydFBUUyxcbiAgICAgICAgICBlbmRQVFMsXG4gICAgICAgICAgc3RhcnREVFMsXG4gICAgICAgICAgZW5kRFRTXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBmcmFnLnNldEVsZW1lbnRhcnlTdHJlYW1JbmZvKEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJTywgc3RhcnRQVFMsIGVuZFBUUywgc3RhcnREVFMsIGVuZERUUyk7XG4gICAgICB0aGlzLmJ1ZmZlckZyYWdtZW50RGF0YShhdWRpbywgZnJhZywgcGFydCwgY2h1bmtNZXRhKTtcbiAgICB9XG4gICAgaWYgKGlkMyAhPSBudWxsICYmIChfaWQzJHNhbXBsZXMgPSBpZDMuc2FtcGxlcykgIT0gbnVsbCAmJiBfaWQzJHNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBlbWl0dGVkSUQzID0gX2V4dGVuZHMoe1xuICAgICAgICBpZCxcbiAgICAgICAgZnJhZyxcbiAgICAgICAgZGV0YWlsc1xuICAgICAgfSwgaWQzKTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX1BBUlNJTkdfTUVUQURBVEEsIGVtaXR0ZWRJRDMpO1xuICAgIH1cbiAgICBpZiAodGV4dCkge1xuICAgICAgY29uc3QgZW1pdHRlZFRleHQgPSBfZXh0ZW5kcyh7XG4gICAgICAgIGlkLFxuICAgICAgICBmcmFnLFxuICAgICAgICBkZXRhaWxzXG4gICAgICB9LCB0ZXh0KTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsIGVtaXR0ZWRUZXh0KTtcbiAgICB9XG4gIH1cbiAgX2J1ZmZlckluaXRTZWdtZW50KGN1cnJlbnRMZXZlbCwgdHJhY2tzLCBmcmFnLCBjaHVua01ldGEpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBkZWxldGUgYW55IHZpZGVvIHRyYWNrIGZvdW5kIG9uIGF1ZGlvIHRyYW5zbXV4ZXJcbiAgICBpZiAodHJhY2tzLnZpZGVvKSB7XG4gICAgICBkZWxldGUgdHJhY2tzLnZpZGVvO1xuICAgIH1cbiAgICBpZiAodHJhY2tzLmF1ZGlvdmlkZW8pIHtcbiAgICAgIGRlbGV0ZSB0cmFja3MuYXVkaW92aWRlbztcbiAgICB9XG5cbiAgICAvLyBpbmNsdWRlIGxldmVsQ29kZWMgaW4gYXVkaW8gYW5kIHZpZGVvIHRyYWNrc1xuICAgIGlmICghdHJhY2tzLmF1ZGlvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRyYWNrID0gdHJhY2tzLmF1ZGlvO1xuICAgIHRyYWNrLmlkID0gUGxheWxpc3RMZXZlbFR5cGUuQVVESU87XG4gICAgY29uc3QgdmFyaWFudEF1ZGlvQ29kZWNzID0gY3VycmVudExldmVsLmF1ZGlvQ29kZWM7XG4gICAgdGhpcy5sb2coYEluaXQgYXVkaW8gYnVmZmVyLCBjb250YWluZXI6JHt0cmFjay5jb250YWluZXJ9LCBjb2RlY3NbbGV2ZWwvcGFyc2VkXT1bJHt2YXJpYW50QXVkaW9Db2RlY3N9LyR7dHJhY2suY29kZWN9XWApO1xuICAgIC8vIFNvdXJjZUJ1ZmZlciB3aWxsIHVzZSB0cmFjay5sZXZlbENvZGVjIGlmIGRlZmluZWRcbiAgICBpZiAodmFyaWFudEF1ZGlvQ29kZWNzICYmIHZhcmlhbnRBdWRpb0NvZGVjcy5zcGxpdCgnLCcpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdHJhY2subGV2ZWxDb2RlYyA9IHZhcmlhbnRBdWRpb0NvZGVjcztcbiAgICB9XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0NPREVDUywgdHJhY2tzKTtcbiAgICBjb25zdCBpbml0U2VnbWVudCA9IHRyYWNrLmluaXRTZWdtZW50O1xuICAgIGlmIChpbml0U2VnbWVudCAhPSBudWxsICYmIGluaXRTZWdtZW50LmJ5dGVMZW5ndGgpIHtcbiAgICAgIGNvbnN0IHNlZ21lbnQgPSB7XG4gICAgICAgIHR5cGU6ICdhdWRpbycsXG4gICAgICAgIGZyYWcsXG4gICAgICAgIHBhcnQ6IG51bGwsXG4gICAgICAgIGNodW5rTWV0YSxcbiAgICAgICAgcGFyZW50OiBmcmFnLnR5cGUsXG4gICAgICAgIGRhdGE6IGluaXRTZWdtZW50XG4gICAgICB9O1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0FQUEVORElORywgc2VnbWVudCk7XG4gICAgfVxuICAgIC8vIHRyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICB0aGlzLnRpY2tJbW1lZGlhdGUoKTtcbiAgfVxuICBsb2FkRnJhZ21lbnQoZnJhZywgdHJhY2ssIHRhcmdldEJ1ZmZlclRpbWUpIHtcbiAgICAvLyBvbmx5IGxvYWQgaWYgZnJhZ21lbnQgaXMgbm90IGxvYWRlZCBvciBpZiBpbiBhdWRpbyBzd2l0Y2hcbiAgICBjb25zdCBmcmFnU3RhdGUgPSB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmcmFnKTtcblxuICAgIC8vIHdlIGZvcmNlIGEgZnJhZyBsb2FkaW5nIGluIGF1ZGlvIHN3aXRjaCBhcyBmcmFnbWVudCB0cmFja2VyIG1pZ2h0IG5vdCBoYXZlIGV2aWN0ZWQgcHJldmlvdXMgZnJhZ3MgaW4gY2FzZSBvZiBxdWljayBhdWRpbyBzd2l0Y2hcbiAgICBpZiAodGhpcy5zd2l0Y2hpbmdUcmFjayB8fCBmcmFnU3RhdGUgPT09IEZyYWdtZW50U3RhdGUuTk9UX0xPQURFRCB8fCBmcmFnU3RhdGUgPT09IEZyYWdtZW50U3RhdGUuUEFSVElBTCkge1xuICAgICAgdmFyIF90cmFjayRkZXRhaWxzO1xuICAgICAgaWYgKCFpc01lZGlhRnJhZ21lbnQoZnJhZykpIHtcbiAgICAgICAgdGhpcy5fbG9hZEluaXRTZWdtZW50KGZyYWcsIHRyYWNrKTtcbiAgICAgIH0gZWxzZSBpZiAoKF90cmFjayRkZXRhaWxzID0gdHJhY2suZGV0YWlscykgIT0gbnVsbCAmJiBfdHJhY2skZGV0YWlscy5saXZlICYmICF0aGlzLmluaXRQVFNbZnJhZy5jY10pIHtcbiAgICAgICAgdGhpcy5sb2coYFdhaXRpbmcgZm9yIHZpZGVvIFBUUyBpbiBjb250aW51aXR5IGNvdW50ZXIgJHtmcmFnLmNjfSBvZiBsaXZlIHN0cmVhbSBiZWZvcmUgbG9hZGluZyBhdWRpbyBmcmFnbWVudCAke2ZyYWcuc259IG9mIGxldmVsICR7dGhpcy50cmFja0lkfWApO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19JTklUX1BUUztcbiAgICAgICAgY29uc3QgbWFpbkRldGFpbHMgPSB0aGlzLm1haW5EZXRhaWxzO1xuICAgICAgICBpZiAobWFpbkRldGFpbHMgJiYgbWFpbkRldGFpbHMuZnJhZ21lbnRTdGFydCAhPT0gdHJhY2suZGV0YWlscy5mcmFnbWVudFN0YXJ0KSB7XG4gICAgICAgICAgYWxpZ25NZWRpYVBsYXlsaXN0QnlQRFQodHJhY2suZGV0YWlscywgbWFpbkRldGFpbHMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdXBlci5sb2FkRnJhZ21lbnQoZnJhZywgdHJhY2ssIHRhcmdldEJ1ZmZlclRpbWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNsZWFyVHJhY2tlcklmTmVlZGVkKGZyYWcpO1xuICAgIH1cbiAgfVxuICBmbHVzaEF1ZGlvSWZOZWVkZWQoc3dpdGNoaW5nVHJhY2spIHtcbiAgICBpZiAodGhpcy5tZWRpYSAmJiB0aGlzLmJ1ZmZlcmVkVHJhY2spIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgbGFuZyxcbiAgICAgICAgYXNzb2NMYW5nLFxuICAgICAgICBjaGFyYWN0ZXJpc3RpY3MsXG4gICAgICAgIGF1ZGlvQ29kZWMsXG4gICAgICAgIGNoYW5uZWxzXG4gICAgICB9ID0gdGhpcy5idWZmZXJlZFRyYWNrO1xuICAgICAgaWYgKCFtYXRjaGVzT3B0aW9uKHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgbGFuZyxcbiAgICAgICAgYXNzb2NMYW5nLFxuICAgICAgICBjaGFyYWN0ZXJpc3RpY3MsXG4gICAgICAgIGF1ZGlvQ29kZWMsXG4gICAgICAgIGNoYW5uZWxzXG4gICAgICB9LCBzd2l0Y2hpbmdUcmFjaywgYXVkaW9NYXRjaFByZWRpY2F0ZSkpIHtcbiAgICAgICAgaWYgKHVzZUFsdGVybmF0ZUF1ZGlvKHN3aXRjaGluZ1RyYWNrLnVybCwgdGhpcy5obHMpKSB7XG4gICAgICAgICAgdGhpcy5sb2coJ1N3aXRjaGluZyBhdWRpbyB0cmFjayA6IGZsdXNoaW5nIGFsbCBhdWRpbycpO1xuICAgICAgICAgIHN1cGVyLmZsdXNoTWFpbkJ1ZmZlcigwLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksICdhdWRpbycpO1xuICAgICAgICAgIHRoaXMuYnVmZmVyZWRUcmFjayA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTWFpbiBpcyBiZWluZyBidWZmZXJlZC4gU2V0IGJ1ZmZlcmVkVHJhY2sgc28gdGhhdCBpdCBpcyBmbHVzaGVkIHdoZW4gc3dpdGNoaW5nIGJhY2sgdG8gYWx0LWF1ZGlvXG4gICAgICAgICAgdGhpcy5idWZmZXJlZFRyYWNrID0gc3dpdGNoaW5nVHJhY2s7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29tcGxldGVBdWRpb1N3aXRjaChzd2l0Y2hpbmdUcmFjaykge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIHRoaXMuZmx1c2hBdWRpb0lmTmVlZGVkKHN3aXRjaGluZ1RyYWNrKTtcbiAgICB0aGlzLmJ1ZmZlcmVkVHJhY2sgPSBzd2l0Y2hpbmdUcmFjaztcbiAgICB0aGlzLnN3aXRjaGluZ1RyYWNrID0gbnVsbDtcbiAgICBobHMudHJpZ2dlcihFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENIRUQsIF9vYmplY3RTcHJlYWQyKHt9LCBzd2l0Y2hpbmdUcmFjaykpO1xuICB9XG59XG5cbmNsYXNzIEJhc2VQbGF5bGlzdENvbnRyb2xsZXIgZXh0ZW5kcyBMb2dnZXIge1xuICBjb25zdHJ1Y3RvcihobHMsIGxvZ1ByZWZpeCkge1xuICAgIHN1cGVyKGxvZ1ByZWZpeCwgaGxzLmxvZ2dlcik7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5jYW5Mb2FkID0gZmFsc2U7XG4gICAgdGhpcy50aW1lciA9IC0xO1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuaGxzID0gdGhpcy5sb2cgPSB0aGlzLndhcm4gPSBudWxsO1xuICB9XG4gIGNsZWFyVGltZXIoKSB7XG4gICAgaWYgKHRoaXMudGltZXIgIT09IC0xKSB7XG4gICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICAgIHRoaXMudGltZXIgPSAtMTtcbiAgICB9XG4gIH1cbiAgc3RhcnRMb2FkKCkge1xuICAgIHRoaXMuY2FuTG9hZCA9IHRydWU7XG4gICAgdGhpcy5sb2FkUGxheWxpc3QoKTtcbiAgfVxuICBzdG9wTG9hZCgpIHtcbiAgICB0aGlzLmNhbkxvYWQgPSBmYWxzZTtcbiAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgfVxuICBzd2l0Y2hQYXJhbXMocGxheWxpc3RVcmksIHByZXZpb3VzLCBjdXJyZW50KSB7XG4gICAgY29uc3QgcmVuZGl0aW9uUmVwb3J0cyA9IHByZXZpb3VzID09IG51bGwgPyB2b2lkIDAgOiBwcmV2aW91cy5yZW5kaXRpb25SZXBvcnRzO1xuICAgIGlmIChyZW5kaXRpb25SZXBvcnRzKSB7XG4gICAgICBsZXQgZm91bmRJbmRleCA9IC0xO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW5kaXRpb25SZXBvcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGF0dHIgPSByZW5kaXRpb25SZXBvcnRzW2ldO1xuICAgICAgICBsZXQgdXJpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHVyaSA9IG5ldyBzZWxmLlVSTChhdHRyLlVSSSwgcHJldmlvdXMudXJsKS5ocmVmO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRoaXMud2FybihgQ291bGQgbm90IGNvbnN0cnVjdCBuZXcgVVJMIGZvciBSZW5kaXRpb24gUmVwb3J0OiAke2Vycm9yfWApO1xuICAgICAgICAgIHVyaSA9IGF0dHIuVVJJIHx8ICcnO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVzZSBleGFjdCBtYXRjaC4gT3RoZXJ3aXNlLCB0aGUgbGFzdCBwYXJ0aWFsIG1hdGNoLCBpZiBhbnksIHdpbGwgYmUgdXNlZFxuICAgICAgICAvLyAoUGxheWxpc3QgVVJJIGluY2x1ZGVzIGEgcXVlcnkgc3RyaW5nIHRoYXQgdGhlIFJlbmRpdGlvbiBSZXBvcnQgZG9lcyBub3QpXG4gICAgICAgIGlmICh1cmkgPT09IHBsYXlsaXN0VXJpKSB7XG4gICAgICAgICAgZm91bmRJbmRleCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAodXJpID09PSBwbGF5bGlzdFVyaS5zdWJzdHJpbmcoMCwgdXJpLmxlbmd0aCkpIHtcbiAgICAgICAgICBmb3VuZEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSB7XG4gICAgICAgIGNvbnN0IGF0dHIgPSByZW5kaXRpb25SZXBvcnRzW2ZvdW5kSW5kZXhdO1xuICAgICAgICBjb25zdCBtc24gPSBwYXJzZUludChhdHRyWydMQVNULU1TTiddKSB8fCAocHJldmlvdXMgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZpb3VzLmxhc3RQYXJ0U24pO1xuICAgICAgICBsZXQgcGFydCA9IHBhcnNlSW50KGF0dHJbJ0xBU1QtUEFSVCddKSB8fCAocHJldmlvdXMgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZpb3VzLmxhc3RQYXJ0SW5kZXgpO1xuICAgICAgICBpZiAodGhpcy5obHMuY29uZmlnLmxvd0xhdGVuY3lNb2RlKSB7XG4gICAgICAgICAgY29uc3QgY3VycmVudEdvYWwgPSBNYXRoLm1pbihwcmV2aW91cy5hZ2UgLSBwcmV2aW91cy5wYXJ0VGFyZ2V0LCBwcmV2aW91cy50YXJnZXRkdXJhdGlvbik7XG4gICAgICAgICAgaWYgKHBhcnQgPj0gMCAmJiBjdXJyZW50R29hbCA+IHByZXZpb3VzLnBhcnRUYXJnZXQpIHtcbiAgICAgICAgICAgIHBhcnQgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2tpcCA9IGN1cnJlbnQgJiYgZ2V0U2tpcFZhbHVlKGN1cnJlbnQpO1xuICAgICAgICByZXR1cm4gbmV3IEhsc1VybFBhcmFtZXRlcnMobXNuLCBwYXJ0ID49IDAgPyBwYXJ0IDogdW5kZWZpbmVkLCBza2lwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbG9hZFBsYXlsaXN0KGhsc1VybFBhcmFtZXRlcnMpIHtcbiAgICAvLyBMb2FkaW5nIGlzIGhhbmRsZWQgYnkgdGhlIHN1YmNsYXNzZXNcbiAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgfVxuICBsb2FkaW5nUGxheWxpc3QocGxheWxpc3QsIGhsc1VybFBhcmFtZXRlcnMpIHtcbiAgICAvLyBMb2FkaW5nIGlzIGhhbmRsZWQgYnkgdGhlIHN1YmNsYXNzZXNcbiAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgfVxuICBzaG91bGRMb2FkUGxheWxpc3QocGxheWxpc3QpIHtcbiAgICByZXR1cm4gdGhpcy5jYW5Mb2FkICYmICEhcGxheWxpc3QgJiYgISFwbGF5bGlzdC51cmwgJiYgKCFwbGF5bGlzdC5kZXRhaWxzIHx8IHBsYXlsaXN0LmRldGFpbHMubGl2ZSk7XG4gIH1cbiAgZ2V0VXJsV2l0aERpcmVjdGl2ZXModXJpLCBobHNVcmxQYXJhbWV0ZXJzKSB7XG4gICAgaWYgKGhsc1VybFBhcmFtZXRlcnMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBobHNVcmxQYXJhbWV0ZXJzLmFkZERpcmVjdGl2ZXModXJpKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRoaXMud2FybihgQ291bGQgbm90IGNvbnN0cnVjdCBuZXcgVVJMIHdpdGggSExTIERlbGl2ZXJ5IERpcmVjdGl2ZXM6ICR7ZXJyb3J9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1cmk7XG4gIH1cbiAgcGxheWxpc3RMb2FkZWQoaW5kZXgsIGRhdGEsIHByZXZpb3VzRGV0YWlscykge1xuICAgIGNvbnN0IHtcbiAgICAgIGRldGFpbHMsXG4gICAgICBzdGF0c1xuICAgIH0gPSBkYXRhO1xuXG4gICAgLy8gU2V0IGxhc3QgdXBkYXRlZCBkYXRlLXRpbWVcbiAgICBjb25zdCBub3cgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnN0IGVsYXBzZWQgPSBzdGF0cy5sb2FkaW5nLmZpcnN0ID8gTWF0aC5tYXgoMCwgbm93IC0gc3RhdHMubG9hZGluZy5maXJzdCkgOiAwO1xuICAgIGRldGFpbHMuYWR2YW5jZWREYXRlVGltZSA9IERhdGUubm93KCkgLSBlbGFwc2VkO1xuXG4gICAgLy8gc2hpZnQgZnJhZ21lbnQgc3RhcnRzIHdpdGggdGltZWxpbmVPZmZzZXRcbiAgICBjb25zdCB0aW1lbGluZU9mZnNldCA9IHRoaXMuaGxzLmNvbmZpZy50aW1lbGluZU9mZnNldDtcbiAgICBpZiAodGltZWxpbmVPZmZzZXQgIT09IGRldGFpbHMuYXBwbGllZFRpbWVsaW5lT2Zmc2V0KSB7XG4gICAgICBjb25zdCBvZmZzZXQgPSBNYXRoLm1heCh0aW1lbGluZU9mZnNldCB8fCAwLCAwKTtcbiAgICAgIGRldGFpbHMuYXBwbGllZFRpbWVsaW5lT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgZGV0YWlscy5mcmFnbWVudHMuZm9yRWFjaChmcmFnID0+IHtcbiAgICAgICAgZnJhZy5zdGFydCA9IGZyYWcucGxheWxpc3RPZmZzZXQgKyBvZmZzZXQ7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBpZiBjdXJyZW50IHBsYXlsaXN0IGlzIGEgbGl2ZSBwbGF5bGlzdCwgYXJtIGEgdGltZXIgdG8gcmVsb2FkIGl0XG4gICAgaWYgKGRldGFpbHMubGl2ZSB8fCBwcmV2aW91c0RldGFpbHMgIT0gbnVsbCAmJiBwcmV2aW91c0RldGFpbHMubGl2ZSkge1xuICAgICAgY29uc3QgbGV2ZWxPclRyYWNrID0gJ2xldmVsSW5mbycgaW4gZGF0YSA/IGRhdGEubGV2ZWxJbmZvIDogZGF0YS50cmFjaztcbiAgICAgIGRldGFpbHMucmVsb2FkZWQocHJldmlvdXNEZXRhaWxzKTtcbiAgICAgIC8vIE1lcmdlIGxpdmUgcGxheWxpc3RzIHRvIGFkanVzdCBmcmFnbWVudCBzdGFydHMgYW5kIGZpbGwgaW4gZGVsdGEgcGxheWxpc3Qgc2tpcHBlZCBzZWdtZW50c1xuICAgICAgaWYgKHByZXZpb3VzRGV0YWlscyAmJiBkZXRhaWxzLmZyYWdtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG1lcmdlRGV0YWlscyhwcmV2aW91c0RldGFpbHMsIGRldGFpbHMpO1xuICAgICAgICBjb25zdCBlcnJvciA9IGRldGFpbHMucGxheWxpc3RQYXJzaW5nRXJyb3I7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHRoaXMud2FybihlcnJvcik7XG4gICAgICAgICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgICAgICAgaWYgKCFobHMuY29uZmlnLmlnbm9yZVBsYXlsaXN0UGFyc2luZ0Vycm9ycykge1xuICAgICAgICAgICAgdmFyIF9kZXRhaWxzJGZyYWdtZW50cyQ7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzXG4gICAgICAgICAgICB9ID0gZGF0YTtcbiAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5MRVZFTF9QQVJTSU5HX0VSUk9SLFxuICAgICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICAgIHVybDogZGV0YWlscy51cmwsXG4gICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICByZWFzb246IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICAgIGxldmVsOiBkYXRhLmxldmVsIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgcGFyZW50OiAoX2RldGFpbHMkZnJhZ21lbnRzJCA9IGRldGFpbHMuZnJhZ21lbnRzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2RldGFpbHMkZnJhZ21lbnRzJC50eXBlLFxuICAgICAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICAgICAgc3RhdHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZXRhaWxzLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRldGFpbHMucmVxdWVzdFNjaGVkdWxlZCA9PT0gLTEpIHtcbiAgICAgICAgZGV0YWlscy5yZXF1ZXN0U2NoZWR1bGVkID0gc3RhdHMubG9hZGluZy5zdGFydDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJ1ZmZlckluZm8gPSB0aGlzLmhscy5tYWluRm9yd2FyZEJ1ZmZlckluZm87XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGJ1ZmZlckluZm8gPyBidWZmZXJJbmZvLmVuZCAtIGJ1ZmZlckluZm8ubGVuIDogMDtcbiAgICAgIGNvbnN0IGRpc3RhbmNlVG9MaXZlRWRnZU1zID0gKGRldGFpbHMuZWRnZSAtIHBvc2l0aW9uKSAqIDEwMDA7XG4gICAgICBjb25zdCByZWxvYWRJbnRlcnZhbCA9IGNvbXB1dGVSZWxvYWRJbnRlcnZhbChkZXRhaWxzLCBkaXN0YW5jZVRvTGl2ZUVkZ2VNcyk7XG4gICAgICBpZiAoZGV0YWlscy5yZXF1ZXN0U2NoZWR1bGVkICsgcmVsb2FkSW50ZXJ2YWwgPCBub3cpIHtcbiAgICAgICAgZGV0YWlscy5yZXF1ZXN0U2NoZWR1bGVkID0gbm93O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGV0YWlscy5yZXF1ZXN0U2NoZWR1bGVkICs9IHJlbG9hZEludGVydmFsO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2coYGxpdmUgcGxheWxpc3QgJHtpbmRleH0gJHtkZXRhaWxzLmFkdmFuY2VkID8gJ1JFRlJFU0hFRCAnICsgZGV0YWlscy5sYXN0UGFydFNuICsgJy0nICsgZGV0YWlscy5sYXN0UGFydEluZGV4IDogZGV0YWlscy51cGRhdGVkID8gJ1VQREFURUQnIDogJ01JU1NFRCd9YCk7XG4gICAgICBpZiAoIXRoaXMuY2FuTG9hZCB8fCAhZGV0YWlscy5saXZlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBkZWxpdmVyeURpcmVjdGl2ZXM7XG4gICAgICBsZXQgbXNuID0gdW5kZWZpbmVkO1xuICAgICAgbGV0IHBhcnQgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAoZGV0YWlscy5jYW5CbG9ja1JlbG9hZCAmJiBkZXRhaWxzLmVuZFNOICYmIGRldGFpbHMuYWR2YW5jZWQpIHtcbiAgICAgICAgLy8gTG9hZCBsZXZlbCB3aXRoIExMLUhMUyBkZWxpdmVyeSBkaXJlY3RpdmVzXG4gICAgICAgIGNvbnN0IGxvd0xhdGVuY3lNb2RlID0gdGhpcy5obHMuY29uZmlnLmxvd0xhdGVuY3lNb2RlO1xuICAgICAgICBjb25zdCBsYXN0UGFydFNuID0gZGV0YWlscy5sYXN0UGFydFNuO1xuICAgICAgICBjb25zdCBlbmRTbiA9IGRldGFpbHMuZW5kU047XG4gICAgICAgIGNvbnN0IGxhc3RQYXJ0SW5kZXggPSBkZXRhaWxzLmxhc3RQYXJ0SW5kZXg7XG4gICAgICAgIGNvbnN0IGhhc1BhcnRzID0gbGFzdFBhcnRJbmRleCAhPT0gLTE7XG4gICAgICAgIGNvbnN0IGF0TGFzdFBhcnRPZlNlZ21lbnQgPSBsYXN0UGFydFNuID09PSBlbmRTbjtcbiAgICAgICAgaWYgKGhhc1BhcnRzKSB7XG4gICAgICAgICAgLy8gV2hlbiBsb3cgbGF0ZW5jeSBtb2RlIGlzIGRpc2FibGVkLCByZXF1ZXN0IHRoZSBsYXN0IHBhcnQgb2YgdGhlIG5leHQgc2VnbWVudFxuICAgICAgICAgIGlmIChhdExhc3RQYXJ0T2ZTZWdtZW50KSB7XG4gICAgICAgICAgICBtc24gPSBlbmRTbiArIDE7XG4gICAgICAgICAgICBwYXJ0ID0gbG93TGF0ZW5jeU1vZGUgPyAwIDogbGFzdFBhcnRJbmRleDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbXNuID0gbGFzdFBhcnRTbjtcbiAgICAgICAgICAgIHBhcnQgPSBsb3dMYXRlbmN5TW9kZSA/IGxhc3RQYXJ0SW5kZXggKyAxIDogZGV0YWlscy5tYXhQYXJ0SW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1zbiA9IGVuZFNuICsgMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBMb3ctTGF0ZW5jeSBDRE4gVHVuZS1pbjogXCJhZ2VcIiBoZWFkZXIgYW5kIHRpbWUgc2luY2UgbG9hZCBpbmRpY2F0ZXMgd2UncmUgYmVoaW5kIGJ5IG1vcmUgdGhhbiBvbmUgcGFydFxuICAgICAgICAvLyBVcGRhdGUgZGlyZWN0aXZlcyB0byBvYnRhaW4gdGhlIFBsYXlsaXN0IHRoYXQgaGFzIHRoZSBlc3RpbWF0ZWQgYWRkaXRpb25hbCBkdXJhdGlvbiBvZiBtZWRpYVxuICAgICAgICBjb25zdCBsYXN0QWR2YW5jZWQgPSBkZXRhaWxzLmFnZTtcbiAgICAgICAgY29uc3QgY2RuQWdlID0gbGFzdEFkdmFuY2VkICsgZGV0YWlscy5hZ2VIZWFkZXI7XG4gICAgICAgIGxldCBjdXJyZW50R29hbCA9IE1hdGgubWluKGNkbkFnZSAtIGRldGFpbHMucGFydFRhcmdldCwgZGV0YWlscy50YXJnZXRkdXJhdGlvbiAqIDEuNSk7XG4gICAgICAgIGlmIChjdXJyZW50R29hbCA+IDApIHtcbiAgICAgICAgICBpZiAoY2RuQWdlID4gZGV0YWlscy50YXJnZXRkdXJhdGlvbiAqIDMpIHtcbiAgICAgICAgICAgIC8vIE9taXQgc2VnbWVudCBhbmQgcGFydCBkaXJlY3RpdmVzIHdoZW4gdGhlIGxhc3QgcmVzcG9uc2Ugd2FzIG1vcmUgdGhhbiAzIHRhcmdldCBkdXJhdGlvbnMgYWdvLFxuICAgICAgICAgICAgdGhpcy5sb2coYFBsYXlsaXN0IGxhc3QgYWR2YW5jZWQgJHtsYXN0QWR2YW5jZWQudG9GaXhlZCgyKX1zIGFnby4gT21pdHRpbmcgc2VnbWVudCBhbmQgcGFydCBkaXJlY3RpdmVzLmApO1xuICAgICAgICAgICAgbXNuID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcGFydCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByZXZpb3VzRGV0YWlscyAhPSBudWxsICYmIHByZXZpb3VzRGV0YWlscy50dW5lSW5Hb2FsICYmIGNkbkFnZSAtIGRldGFpbHMucGFydFRhcmdldCA+IHByZXZpb3VzRGV0YWlscy50dW5lSW5Hb2FsKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBhdHRlbXB0ZWQgdG8gZ2V0IHRoZSBuZXh0IG9yIGxhdGVzdCBwbGF5bGlzdCB1cGRhdGUsIGJ1dCBjdXJyZW50R29hbCBpbmNyZWFzZWQsXG4gICAgICAgICAgICAvLyB0aGVuIHdlIGVpdGhlciBjYW4ndCBjYXRjaHVwLCBvciB0aGUgXCJhZ2VcIiBoZWFkZXIgY2Fubm90IGJlIHRydXN0ZWQuXG4gICAgICAgICAgICB0aGlzLndhcm4oYENETiBUdW5lLWluIGdvYWwgaW5jcmVhc2VkIGZyb206ICR7cHJldmlvdXNEZXRhaWxzLnR1bmVJbkdvYWx9IHRvOiAke2N1cnJlbnRHb2FsfSB3aXRoIHBsYXlsaXN0IGFnZTogJHtkZXRhaWxzLmFnZX1gKTtcbiAgICAgICAgICAgIGN1cnJlbnRHb2FsID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2VnbWVudHMgPSBNYXRoLmZsb29yKGN1cnJlbnRHb2FsIC8gZGV0YWlscy50YXJnZXRkdXJhdGlvbik7XG4gICAgICAgICAgICBtc24gKz0gc2VnbWVudHM7XG4gICAgICAgICAgICBpZiAocGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gTWF0aC5yb3VuZChjdXJyZW50R29hbCAlIGRldGFpbHMudGFyZ2V0ZHVyYXRpb24gLyBkZXRhaWxzLnBhcnRUYXJnZXQpO1xuICAgICAgICAgICAgICBwYXJ0ICs9IHBhcnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sb2coYENETiBUdW5lLWluIGFnZTogJHtkZXRhaWxzLmFnZUhlYWRlcn1zIGxhc3QgYWR2YW5jZWQgJHtsYXN0QWR2YW5jZWQudG9GaXhlZCgyKX1zIGdvYWw6ICR7Y3VycmVudEdvYWx9IHNraXAgc24gJHtzZWdtZW50c30gdG8gcGFydCAke3BhcnR9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRldGFpbHMudHVuZUluR29hbCA9IGN1cnJlbnRHb2FsO1xuICAgICAgICB9XG4gICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlcyA9IHRoaXMuZ2V0RGVsaXZlcnlEaXJlY3RpdmVzKGRldGFpbHMsIGRhdGEuZGVsaXZlcnlEaXJlY3RpdmVzLCBtc24sIHBhcnQpO1xuICAgICAgICBpZiAobG93TGF0ZW5jeU1vZGUgfHwgIWF0TGFzdFBhcnRPZlNlZ21lbnQpIHtcbiAgICAgICAgICBkZXRhaWxzLnJlcXVlc3RTY2hlZHVsZWQgPSBub3c7XG4gICAgICAgICAgdGhpcy5sb2FkaW5nUGxheWxpc3QobGV2ZWxPclRyYWNrLCBkZWxpdmVyeURpcmVjdGl2ZXMpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkZXRhaWxzLmNhbkJsb2NrUmVsb2FkIHx8IGRldGFpbHMuY2FuU2tpcFVudGlsKSB7XG4gICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlcyA9IHRoaXMuZ2V0RGVsaXZlcnlEaXJlY3RpdmVzKGRldGFpbHMsIGRhdGEuZGVsaXZlcnlEaXJlY3RpdmVzLCBtc24sIHBhcnQpO1xuICAgICAgfVxuICAgICAgaWYgKGRlbGl2ZXJ5RGlyZWN0aXZlcyAmJiBtc24gIT09IHVuZGVmaW5lZCAmJiBkZXRhaWxzLmNhbkJsb2NrUmVsb2FkKSB7XG4gICAgICAgIGRldGFpbHMucmVxdWVzdFNjaGVkdWxlZCA9IHN0YXRzLmxvYWRpbmcuZmlyc3QgKyBNYXRoLm1heChyZWxvYWRJbnRlcnZhbCAtIGVsYXBzZWQgKiAyLCByZWxvYWRJbnRlcnZhbCAvIDIpO1xuICAgICAgfVxuICAgICAgdGhpcy5zY2hlZHVsZUxvYWRpbmcobGV2ZWxPclRyYWNrLCBkZWxpdmVyeURpcmVjdGl2ZXMsIGRldGFpbHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICB9XG4gIH1cbiAgc2NoZWR1bGVMb2FkaW5nKGxldmVsT3JUcmFjaywgZGVsaXZlcnlEaXJlY3RpdmVzLCB1cGRhdGVkRGV0YWlscykge1xuICAgIGNvbnN0IGRldGFpbHMgPSB1cGRhdGVkRGV0YWlscyB8fCBsZXZlbE9yVHJhY2suZGV0YWlscztcbiAgICBpZiAoIWRldGFpbHMpIHtcbiAgICAgIHRoaXMubG9hZGluZ1BsYXlsaXN0KGxldmVsT3JUcmFjaywgZGVsaXZlcnlEaXJlY3RpdmVzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgbm93ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCByZXF1ZXN0U2NoZWR1bGVkID0gZGV0YWlscy5yZXF1ZXN0U2NoZWR1bGVkO1xuICAgIGlmIChub3cgPj0gcmVxdWVzdFNjaGVkdWxlZCkge1xuICAgICAgdGhpcy5sb2FkaW5nUGxheWxpc3QobGV2ZWxPclRyYWNrLCBkZWxpdmVyeURpcmVjdGl2ZXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlc3RpbWF0ZWRUaW1lVW50aWxVcGRhdGUgPSByZXF1ZXN0U2NoZWR1bGVkIC0gbm93O1xuICAgIHRoaXMubG9nKGByZWxvYWQgbGl2ZSBwbGF5bGlzdCAke2xldmVsT3JUcmFjay5uYW1lIHx8IGxldmVsT3JUcmFjay5iaXRyYXRlICsgJ2Jwcyd9IGluICR7TWF0aC5yb3VuZChlc3RpbWF0ZWRUaW1lVW50aWxVcGRhdGUpfSBtc2ApO1xuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgIHRoaXMudGltZXIgPSBzZWxmLnNldFRpbWVvdXQoKCkgPT4gdGhpcy5sb2FkaW5nUGxheWxpc3QobGV2ZWxPclRyYWNrLCBkZWxpdmVyeURpcmVjdGl2ZXMpLCBlc3RpbWF0ZWRUaW1lVW50aWxVcGRhdGUpO1xuICB9XG4gIGdldERlbGl2ZXJ5RGlyZWN0aXZlcyhkZXRhaWxzLCBwcmV2aW91c0RlbGl2ZXJ5RGlyZWN0aXZlcywgbXNuLCBwYXJ0KSB7XG4gICAgbGV0IHNraXAgPSBnZXRTa2lwVmFsdWUoZGV0YWlscyk7XG4gICAgaWYgKHByZXZpb3VzRGVsaXZlcnlEaXJlY3RpdmVzICE9IG51bGwgJiYgcHJldmlvdXNEZWxpdmVyeURpcmVjdGl2ZXMuc2tpcCAmJiBkZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkKSB7XG4gICAgICBtc24gPSBwcmV2aW91c0RlbGl2ZXJ5RGlyZWN0aXZlcy5tc247XG4gICAgICBwYXJ0ID0gcHJldmlvdXNEZWxpdmVyeURpcmVjdGl2ZXMucGFydDtcbiAgICAgIHNraXAgPSBIbHNTa2lwLk5vO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEhsc1VybFBhcmFtZXRlcnMobXNuLCBwYXJ0LCBza2lwKTtcbiAgfVxuICBjaGVja1JldHJ5KGVycm9yRXZlbnQpIHtcbiAgICBjb25zdCBlcnJvckRldGFpbHMgPSBlcnJvckV2ZW50LmRldGFpbHM7XG4gICAgY29uc3QgaXNUaW1lb3V0ID0gaXNUaW1lb3V0RXJyb3IoZXJyb3JFdmVudCk7XG4gICAgY29uc3QgZXJyb3JBY3Rpb24gPSBlcnJvckV2ZW50LmVycm9yQWN0aW9uO1xuICAgIGNvbnN0IHtcbiAgICAgIGFjdGlvbixcbiAgICAgIHJldHJ5Q291bnQgPSAwLFxuICAgICAgcmV0cnlDb25maWdcbiAgICB9ID0gZXJyb3JBY3Rpb24gfHwge307XG4gICAgY29uc3QgcmV0cnkgPSAhIWVycm9yQWN0aW9uICYmICEhcmV0cnlDb25maWcgJiYgKGFjdGlvbiA9PT0gTmV0d29ya0Vycm9yQWN0aW9uLlJldHJ5UmVxdWVzdCB8fCAhZXJyb3JBY3Rpb24ucmVzb2x2ZWQgJiYgYWN0aW9uID09PSBOZXR3b3JrRXJyb3JBY3Rpb24uU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveCk7XG4gICAgaWYgKHJldHJ5KSB7XG4gICAgICB2YXIgX2Vycm9yRXZlbnQkY29udGV4dDtcbiAgICAgIGlmIChyZXRyeUNvdW50ID49IHJldHJ5Q29uZmlnLm1heE51bVJldHJ5KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1RpbWVvdXQgJiYgKF9lcnJvckV2ZW50JGNvbnRleHQgPSBlcnJvckV2ZW50LmNvbnRleHQpICE9IG51bGwgJiYgX2Vycm9yRXZlbnQkY29udGV4dC5kZWxpdmVyeURpcmVjdGl2ZXMpIHtcbiAgICAgICAgLy8gVGhlIExMLUhMUyByZXF1ZXN0IGFscmVhZHkgdGltZWQgb3V0IHNvIHJldHJ5IGltbWVkaWF0ZWx5XG4gICAgICAgIHRoaXMud2FybihgUmV0cnlpbmcgcGxheWxpc3QgbG9hZGluZyAke3JldHJ5Q291bnQgKyAxfS8ke3JldHJ5Q29uZmlnLm1heE51bVJldHJ5fSBhZnRlciBcIiR7ZXJyb3JEZXRhaWxzfVwiIHdpdGhvdXQgZGVsaXZlcnktZGlyZWN0aXZlc2ApO1xuICAgICAgICB0aGlzLmxvYWRQbGF5bGlzdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZGVsYXkgPSBnZXRSZXRyeURlbGF5KHJldHJ5Q29uZmlnLCByZXRyeUNvdW50KTtcbiAgICAgICAgLy8gU2NoZWR1bGUgbGV2ZWwvdHJhY2sgcmVsb2FkXG4gICAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgICB0aGlzLnRpbWVyID0gc2VsZi5zZXRUaW1lb3V0KCgpID0+IHRoaXMubG9hZFBsYXlsaXN0KCksIGRlbGF5KTtcbiAgICAgICAgdGhpcy53YXJuKGBSZXRyeWluZyBwbGF5bGlzdCBsb2FkaW5nICR7cmV0cnlDb3VudCArIDF9LyR7cmV0cnlDb25maWcubWF4TnVtUmV0cnl9IGFmdGVyIFwiJHtlcnJvckRldGFpbHN9XCIgaW4gJHtkZWxheX1tc2ApO1xuICAgICAgfVxuICAgICAgLy8gYGxldmVsUmV0cnkgPSB0cnVlYCB1c2VkIHRvIGluZm9ybSBvdGhlciBjb250cm9sbGVycyB0aGF0IGEgcmV0cnkgaXMgaGFwcGVuaW5nXG4gICAgICBlcnJvckV2ZW50LmxldmVsUmV0cnkgPSB0cnVlO1xuICAgICAgZXJyb3JBY3Rpb24ucmVzb2x2ZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcmV0cnk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3VidGl0bGVPcHRpb25zSWRlbnRpY2FsKHRyYWNrTGlzdDEsIHRyYWNrTGlzdDIpIHtcbiAgaWYgKHRyYWNrTGlzdDEubGVuZ3RoICE9PSB0cmFja0xpc3QyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYWNrTGlzdDEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIW1lZGlhQXR0cmlidXRlc0lkZW50aWNhbCh0cmFja0xpc3QxW2ldLmF0dHJzLCB0cmFja0xpc3QyW2ldLmF0dHJzKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG1lZGlhQXR0cmlidXRlc0lkZW50aWNhbChhdHRyczEsIGF0dHJzMiwgY3VzdG9tQXR0cmlidXRlcykge1xuICAvLyBNZWRpYSBvcHRpb25zIHdpdGggdGhlIHNhbWUgcmVuZGl0aW9uIElEIG11c3QgYmUgYml0IGlkZW50aWNhbFxuICBjb25zdCBzdGFibGVSZW5kaXRpb25JZCA9IGF0dHJzMVsnU1RBQkxFLVJFTkRJVElPTi1JRCddO1xuICBpZiAoc3RhYmxlUmVuZGl0aW9uSWQgJiYgIWN1c3RvbUF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gc3RhYmxlUmVuZGl0aW9uSWQgPT09IGF0dHJzMlsnU1RBQkxFLVJFTkRJVElPTi1JRCddO1xuICB9XG4gIC8vIFdoZW4gcmVuZGl0aW9uIElEIGlzIG5vdCBwcmVzZW50LCBjb21wYXJlIGF0dHJpYnV0ZXNcbiAgcmV0dXJuICEoY3VzdG9tQXR0cmlidXRlcyB8fCBbJ0xBTkdVQUdFJywgJ05BTUUnLCAnQ0hBUkFDVEVSSVNUSUNTJywgJ0FVVE9TRUxFQ1QnLCAnREVGQVVMVCcsICdGT1JDRUQnLCAnQVNTT0MtTEFOR1VBR0UnXSkuc29tZShzdWJ0aXRsZUF0dHJpYnV0ZSA9PiBhdHRyczFbc3VidGl0bGVBdHRyaWJ1dGVdICE9PSBhdHRyczJbc3VidGl0bGVBdHRyaWJ1dGVdKTtcbn1cbmZ1bmN0aW9uIHN1YnRpdGxlVHJhY2tNYXRjaGVzVGV4dFRyYWNrKHN1YnRpdGxlVHJhY2ssIHRleHRUcmFjaykge1xuICByZXR1cm4gdGV4dFRyYWNrLmxhYmVsLnRvTG93ZXJDYXNlKCkgPT09IHN1YnRpdGxlVHJhY2submFtZS50b0xvd2VyQ2FzZSgpICYmICghdGV4dFRyYWNrLmxhbmd1YWdlIHx8IHRleHRUcmFjay5sYW5ndWFnZS50b0xvd2VyQ2FzZSgpID09PSAoc3VidGl0bGVUcmFjay5sYW5nIHx8ICcnKS50b0xvd2VyQ2FzZSgpKTtcbn1cblxuY2xhc3MgQXVkaW9UcmFja0NvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlUGxheWxpc3RDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgc3VwZXIoaGxzLCAnYXVkaW8tdHJhY2stY29udHJvbGxlcicpO1xuICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgdGhpcy5ncm91cElkcyA9IG51bGw7XG4gICAgdGhpcy50cmFja3NJbkdyb3VwID0gW107XG4gICAgdGhpcy50cmFja0lkID0gLTE7XG4gICAgdGhpcy5jdXJyZW50VHJhY2sgPSBudWxsO1xuICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gdHJ1ZTtcbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX0xPQURJTkcsIHRoaXMub25MZXZlbExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxfU1dJVENISU5HLCB0aGlzLm9uTGV2ZWxTd2l0Y2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQVVESU9fVFJBQ0tfTE9BREVELCB0aGlzLm9uQXVkaW9UcmFja0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfVxuICB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9TV0lUQ0hJTkcsIHRoaXMub25MZXZlbFN3aXRjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQVVESU9fVFJBQ0tfTE9BREVELCB0aGlzLm9uQXVkaW9UcmFja0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLnRyYWNrcy5sZW5ndGggPSAwO1xuICAgIHRoaXMudHJhY2tzSW5Hcm91cC5sZW5ndGggPSAwO1xuICAgIHRoaXMuY3VycmVudFRyYWNrID0gbnVsbDtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gIH1cbiAgb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgdGhpcy50cmFja3MgPSBbXTtcbiAgICB0aGlzLnRyYWNrc0luR3JvdXAgPSBbXTtcbiAgICB0aGlzLmdyb3VwSWRzID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRUcmFjayA9IG51bGw7XG4gICAgdGhpcy50cmFja0lkID0gLTE7XG4gICAgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSB0cnVlO1xuICB9XG4gIG9uTWFuaWZlc3RQYXJzZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLnRyYWNrcyA9IGRhdGEuYXVkaW9UcmFja3MgfHwgW107XG4gIH1cbiAgb25BdWRpb1RyYWNrTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgaWQsXG4gICAgICBncm91cElkLFxuICAgICAgZGV0YWlsc1xuICAgIH0gPSBkYXRhO1xuICAgIGNvbnN0IHRyYWNrSW5BY3RpdmVHcm91cCA9IHRoaXMudHJhY2tzSW5Hcm91cFtpZF07XG4gICAgaWYgKCF0cmFja0luQWN0aXZlR3JvdXAgfHwgdHJhY2tJbkFjdGl2ZUdyb3VwLmdyb3VwSWQgIT09IGdyb3VwSWQpIHtcbiAgICAgIHRoaXMud2FybihgQXVkaW8gdHJhY2sgd2l0aCBpZDoke2lkfSBhbmQgZ3JvdXA6JHtncm91cElkfSBub3QgZm91bmQgaW4gYWN0aXZlIGdyb3VwICR7dHJhY2tJbkFjdGl2ZUdyb3VwID09IG51bGwgPyB2b2lkIDAgOiB0cmFja0luQWN0aXZlR3JvdXAuZ3JvdXBJZH1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VyRGV0YWlscyA9IHRyYWNrSW5BY3RpdmVHcm91cC5kZXRhaWxzO1xuICAgIHRyYWNrSW5BY3RpdmVHcm91cC5kZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuICAgIHRoaXMubG9nKGBBdWRpbyB0cmFjayAke2lkfSBcIiR7dHJhY2tJbkFjdGl2ZUdyb3VwLm5hbWV9XCIgbGFuZzoke3RyYWNrSW5BY3RpdmVHcm91cC5sYW5nfSBncm91cDoke2dyb3VwSWR9IGxvYWRlZCBbJHtkZXRhaWxzLnN0YXJ0U059LSR7ZGV0YWlscy5lbmRTTn1dYCk7XG4gICAgaWYgKGlkID09PSB0aGlzLnRyYWNrSWQpIHtcbiAgICAgIHRoaXMucGxheWxpc3RMb2FkZWQoaWQsIGRhdGEsIGN1ckRldGFpbHMpO1xuICAgIH1cbiAgfVxuICBvbkxldmVsTG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgIHRoaXMuc3dpdGNoTGV2ZWwoZGF0YS5sZXZlbCk7XG4gIH1cbiAgb25MZXZlbFN3aXRjaGluZyhldmVudCwgZGF0YSkge1xuICAgIHRoaXMuc3dpdGNoTGV2ZWwoZGF0YS5sZXZlbCk7XG4gIH1cbiAgc3dpdGNoTGV2ZWwobGV2ZWxJbmRleCkge1xuICAgIGNvbnN0IGxldmVsSW5mbyA9IHRoaXMuaGxzLmxldmVsc1tsZXZlbEluZGV4XTtcbiAgICBpZiAoIWxldmVsSW5mbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhdWRpb0dyb3VwcyA9IGxldmVsSW5mby5hdWRpb0dyb3VwcyB8fCBudWxsO1xuICAgIGNvbnN0IGN1cnJlbnRHcm91cHMgPSB0aGlzLmdyb3VwSWRzO1xuICAgIGxldCBjdXJyZW50VHJhY2sgPSB0aGlzLmN1cnJlbnRUcmFjaztcbiAgICBpZiAoIWF1ZGlvR3JvdXBzIHx8IChjdXJyZW50R3JvdXBzID09IG51bGwgPyB2b2lkIDAgOiBjdXJyZW50R3JvdXBzLmxlbmd0aCkgIT09IChhdWRpb0dyb3VwcyA9PSBudWxsID8gdm9pZCAwIDogYXVkaW9Hcm91cHMubGVuZ3RoKSB8fCBhdWRpb0dyb3VwcyAhPSBudWxsICYmIGF1ZGlvR3JvdXBzLnNvbWUoZ3JvdXBJZCA9PiAoY3VycmVudEdyb3VwcyA9PSBudWxsID8gdm9pZCAwIDogY3VycmVudEdyb3Vwcy5pbmRleE9mKGdyb3VwSWQpKSA9PT0gLTEpKSB7XG4gICAgICB0aGlzLmdyb3VwSWRzID0gYXVkaW9Hcm91cHM7XG4gICAgICB0aGlzLnRyYWNrSWQgPSAtMTtcbiAgICAgIHRoaXMuY3VycmVudFRyYWNrID0gbnVsbDtcbiAgICAgIGNvbnN0IGF1ZGlvVHJhY2tzID0gdGhpcy50cmFja3MuZmlsdGVyKHRyYWNrID0+ICFhdWRpb0dyb3VwcyB8fCBhdWRpb0dyb3Vwcy5pbmRleE9mKHRyYWNrLmdyb3VwSWQpICE9PSAtMSk7XG4gICAgICBpZiAoYXVkaW9UcmFja3MubGVuZ3RoKSB7XG4gICAgICAgIC8vIERpc2FibGUgc2VsZWN0RGVmYXVsdFRyYWNrIGlmIHRoZXJlIGFyZSBubyBkZWZhdWx0IHRyYWNrc1xuICAgICAgICBpZiAodGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgJiYgIWF1ZGlvVHJhY2tzLnNvbWUodHJhY2sgPT4gdHJhY2suZGVmYXVsdCkpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRyYWNrLmlkIHNob3VsZCBtYXRjaCBobHMuYXVkaW9UcmFja3MgaW5kZXhcbiAgICAgICAgYXVkaW9UcmFja3MuZm9yRWFjaCgodHJhY2ssIGkpID0+IHtcbiAgICAgICAgICB0cmFjay5pZCA9IGk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICghY3VycmVudFRyYWNrICYmICF0aGlzLnRyYWNrc0luR3JvdXAubGVuZ3RoKSB7XG4gICAgICAgIC8vIERvIG5vdCBkaXNwYXRjaCBBVURJT19UUkFDS1NfVVBEQVRFRCB3aGVuIHRoZXJlIHdlcmUgYW5kIGFyZSBubyB0cmFja3NcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy50cmFja3NJbkdyb3VwID0gYXVkaW9UcmFja3M7XG5cbiAgICAgIC8vIEZpbmQgcHJlZmVycmVkIHRyYWNrXG4gICAgICBjb25zdCBhdWRpb1ByZWZlcmVuY2UgPSB0aGlzLmhscy5jb25maWcuYXVkaW9QcmVmZXJlbmNlO1xuICAgICAgaWYgKCFjdXJyZW50VHJhY2sgJiYgYXVkaW9QcmVmZXJlbmNlKSB7XG4gICAgICAgIGNvbnN0IGdyb3VwSW5kZXggPSBmaW5kTWF0Y2hpbmdPcHRpb24oYXVkaW9QcmVmZXJlbmNlLCBhdWRpb1RyYWNrcywgYXVkaW9NYXRjaFByZWRpY2F0ZSk7XG4gICAgICAgIGlmIChncm91cEluZGV4ID4gLTEpIHtcbiAgICAgICAgICBjdXJyZW50VHJhY2sgPSBhdWRpb1RyYWNrc1tncm91cEluZGV4XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBhbGxJbmRleCA9IGZpbmRNYXRjaGluZ09wdGlvbihhdWRpb1ByZWZlcmVuY2UsIHRoaXMudHJhY2tzKTtcbiAgICAgICAgICBjdXJyZW50VHJhY2sgPSB0aGlzLnRyYWNrc1thbGxJbmRleF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gU2VsZWN0IGluaXRpYWwgdHJhY2tcbiAgICAgIGxldCB0cmFja0lkID0gdGhpcy5maW5kVHJhY2tJZChjdXJyZW50VHJhY2spO1xuICAgICAgaWYgKHRyYWNrSWQgPT09IC0xICYmIGN1cnJlbnRUcmFjaykge1xuICAgICAgICB0cmFja0lkID0gdGhpcy5maW5kVHJhY2tJZChudWxsKTtcbiAgICAgIH1cblxuICAgICAgLy8gRGlzcGF0Y2ggZXZlbnRzIGFuZCBsb2FkIHRyYWNrIGlmIG5lZWRlZFxuICAgICAgY29uc3QgYXVkaW9UcmFja3NVcGRhdGVkID0ge1xuICAgICAgICBhdWRpb1RyYWNrc1xuICAgICAgfTtcbiAgICAgIHRoaXMubG9nKGBVcGRhdGluZyBhdWRpbyB0cmFja3MsICR7YXVkaW9UcmFja3MubGVuZ3RofSB0cmFjayhzKSBmb3VuZCBpbiBncm91cChzKTogJHthdWRpb0dyb3VwcyA9PSBudWxsID8gdm9pZCAwIDogYXVkaW9Hcm91cHMuam9pbignLCcpfWApO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQVVESU9fVFJBQ0tTX1VQREFURUQsIGF1ZGlvVHJhY2tzVXBkYXRlZCk7XG4gICAgICBjb25zdCBzZWxlY3RlZFRyYWNrSWQgPSB0aGlzLnRyYWNrSWQ7XG4gICAgICBpZiAodHJhY2tJZCAhPT0gLTEgJiYgc2VsZWN0ZWRUcmFja0lkID09PSAtMSkge1xuICAgICAgICB0aGlzLnNldEF1ZGlvVHJhY2sodHJhY2tJZCk7XG4gICAgICB9IGVsc2UgaWYgKGF1ZGlvVHJhY2tzLmxlbmd0aCAmJiBzZWxlY3RlZFRyYWNrSWQgPT09IC0xKSB7XG4gICAgICAgIHZhciBfdGhpcyRncm91cElkcztcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYE5vIGF1ZGlvIHRyYWNrIHNlbGVjdGVkIGZvciBjdXJyZW50IGF1ZGlvIGdyb3VwLUlEKHMpOiAkeyhfdGhpcyRncm91cElkcyA9IHRoaXMuZ3JvdXBJZHMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRncm91cElkcy5qb2luKCcsJyl9IHRyYWNrIGNvdW50OiAke2F1ZGlvVHJhY2tzLmxlbmd0aH1gKTtcbiAgICAgICAgdGhpcy53YXJuKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfRVJST1IsXG4gICAgICAgICAgZmF0YWw6IHRydWUsXG4gICAgICAgICAgZXJyb3JcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG9uRXJyb3IoZXZlbnQsIGRhdGEpIHtcbiAgICBpZiAoZGF0YS5mYXRhbCB8fCAhZGF0YS5jb250ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkYXRhLmNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSyAmJiBkYXRhLmNvbnRleHQuaWQgPT09IHRoaXMudHJhY2tJZCAmJiAoIXRoaXMuZ3JvdXBJZHMgfHwgdGhpcy5ncm91cElkcy5pbmRleE9mKGRhdGEuY29udGV4dC5ncm91cElkKSAhPT0gLTEpKSB7XG4gICAgICB0aGlzLmNoZWNrUmV0cnkoZGF0YSk7XG4gICAgfVxuICB9XG4gIGdldCBhbGxBdWRpb1RyYWNrcygpIHtcbiAgICByZXR1cm4gdGhpcy50cmFja3M7XG4gIH1cbiAgZ2V0IGF1ZGlvVHJhY2tzKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrc0luR3JvdXA7XG4gIH1cbiAgZ2V0IGF1ZGlvVHJhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2tJZDtcbiAgfVxuICBzZXQgYXVkaW9UcmFjayhuZXdJZCkge1xuICAgIC8vIElmIGF1ZGlvIHRyYWNrIGlzIHNlbGVjdGVkIGZyb20gQVBJIHRoZW4gZG9uJ3QgY2hvb3NlIGZyb20gdGhlIG1hbmlmZXN0IGRlZmF1bHQgdHJhY2tcbiAgICB0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IGZhbHNlO1xuICAgIHRoaXMuc2V0QXVkaW9UcmFjayhuZXdJZCk7XG4gIH1cbiAgc2V0QXVkaW9PcHRpb24oYXVkaW9PcHRpb24pIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBobHMuY29uZmlnLmF1ZGlvUHJlZmVyZW5jZSA9IGF1ZGlvT3B0aW9uO1xuICAgIGlmIChhdWRpb09wdGlvbikge1xuICAgICAgY29uc3QgYWxsQXVkaW9UcmFja3MgPSB0aGlzLmFsbEF1ZGlvVHJhY2tzO1xuICAgICAgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSBmYWxzZTtcbiAgICAgIGlmIChhbGxBdWRpb1RyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gRmlyc3Qgc2VlIGlmIGN1cnJlbnQgb3B0aW9uIG1hdGNoZXMgKG5vIHN3aXRjaCBvcClcbiAgICAgICAgY29uc3QgY3VycmVudFRyYWNrID0gdGhpcy5jdXJyZW50VHJhY2s7XG4gICAgICAgIGlmIChjdXJyZW50VHJhY2sgJiYgbWF0Y2hlc09wdGlvbihhdWRpb09wdGlvbiwgY3VycmVudFRyYWNrLCBhdWRpb01hdGNoUHJlZGljYXRlKSkge1xuICAgICAgICAgIHJldHVybiBjdXJyZW50VHJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluZCBvcHRpb24gaW4gYXZhaWxhYmxlIHRyYWNrcyAodHJhY2tzSW5Hcm91cClcbiAgICAgICAgY29uc3QgZ3JvdXBJbmRleCA9IGZpbmRNYXRjaGluZ09wdGlvbihhdWRpb09wdGlvbiwgdGhpcy50cmFja3NJbkdyb3VwLCBhdWRpb01hdGNoUHJlZGljYXRlKTtcbiAgICAgICAgaWYgKGdyb3VwSW5kZXggPiAtMSkge1xuICAgICAgICAgIGNvbnN0IHRyYWNrID0gdGhpcy50cmFja3NJbkdyb3VwW2dyb3VwSW5kZXhdO1xuICAgICAgICAgIHRoaXMuc2V0QXVkaW9UcmFjayhncm91cEluZGV4KTtcbiAgICAgICAgICByZXR1cm4gdHJhY2s7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFRyYWNrKSB7XG4gICAgICAgICAgLy8gRmluZCBvcHRpb24gaW4gbmVhcmVzdCBsZXZlbCBhdWRpbyBncm91cFxuICAgICAgICAgIGxldCBzZWFyY2hJbmRleCA9IGhscy5sb2FkTGV2ZWw7XG4gICAgICAgICAgaWYgKHNlYXJjaEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgc2VhcmNoSW5kZXggPSBobHMuZmlyc3RBdXRvTGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHN3aXRjaEluZGV4ID0gZmluZENsb3Nlc3RMZXZlbFdpdGhBdWRpb0dyb3VwKGF1ZGlvT3B0aW9uLCBobHMubGV2ZWxzLCBhbGxBdWRpb1RyYWNrcywgc2VhcmNoSW5kZXgsIGF1ZGlvTWF0Y2hQcmVkaWNhdGUpO1xuICAgICAgICAgIGlmIChzd2l0Y2hJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIGNvdWxkIG5vdCBmaW5kIG1hdGNoaW5nIHZhcmlhbnRcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBhbmQgc3dpdGNoIGxldmVsIHRvIGFjaGVpdmUgdGhlIGF1ZGlvIGdyb3VwIHN3aXRjaFxuICAgICAgICAgIGhscy5uZXh0TG9hZExldmVsID0gc3dpdGNoSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF1ZGlvT3B0aW9uLmNoYW5uZWxzIHx8IGF1ZGlvT3B0aW9uLmF1ZGlvQ29kZWMpIHtcbiAgICAgICAgICAvLyBDb3VsZCBub3QgZmluZCBhIG1hdGNoIHdpdGggY29kZWMgLyBjaGFubmVscyBwcmVkaWNhdGVcbiAgICAgICAgICAvLyBGaW5kIGEgbWF0Y2ggd2l0aG91dCBjaGFubmVscyBvciBjb2RlY1xuICAgICAgICAgIGNvbnN0IHdpdGhvdXRDb2RlY0FuZENoYW5uZWxzTWF0Y2ggPSBmaW5kTWF0Y2hpbmdPcHRpb24oYXVkaW9PcHRpb24sIGFsbEF1ZGlvVHJhY2tzKTtcbiAgICAgICAgICBpZiAod2l0aG91dENvZGVjQW5kQ2hhbm5lbHNNYXRjaCA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gYWxsQXVkaW9UcmFja3Nbd2l0aG91dENvZGVjQW5kQ2hhbm5lbHNNYXRjaF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHNldEF1ZGlvVHJhY2sobmV3SWQpIHtcbiAgICBjb25zdCB0cmFja3MgPSB0aGlzLnRyYWNrc0luR3JvdXA7XG5cbiAgICAvLyBjaGVjayBpZiBsZXZlbCBpZHggaXMgdmFsaWRcbiAgICBpZiAobmV3SWQgPCAwIHx8IG5ld0lkID49IHRyYWNrcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMud2FybihgSW52YWxpZCBhdWRpbyB0cmFjayBpZDogJHtuZXdJZH1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSBmYWxzZTtcbiAgICBjb25zdCBsYXN0VHJhY2sgPSB0aGlzLmN1cnJlbnRUcmFjaztcbiAgICBjb25zdCB0cmFjayA9IHRyYWNrc1tuZXdJZF07XG4gICAgY29uc3QgdHJhY2tMb2FkZWQgPSB0cmFjay5kZXRhaWxzICYmICF0cmFjay5kZXRhaWxzLmxpdmU7XG4gICAgaWYgKG5ld0lkID09PSB0aGlzLnRyYWNrSWQgJiYgdHJhY2sgPT09IGxhc3RUcmFjayAmJiB0cmFja0xvYWRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxvZyhgU3dpdGNoaW5nIHRvIGF1ZGlvLXRyYWNrICR7bmV3SWR9IFwiJHt0cmFjay5uYW1lfVwiIGxhbmc6JHt0cmFjay5sYW5nfSBncm91cDoke3RyYWNrLmdyb3VwSWR9IGNoYW5uZWxzOiR7dHJhY2suY2hhbm5lbHN9YCk7XG4gICAgdGhpcy50cmFja0lkID0gbmV3SWQ7XG4gICAgdGhpcy5jdXJyZW50VHJhY2sgPSB0cmFjaztcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hJTkcsIF9vYmplY3RTcHJlYWQyKHt9LCB0cmFjaykpO1xuICAgIC8vIERvIG5vdCByZWxvYWQgdHJhY2sgdW5sZXNzIGxpdmVcbiAgICBpZiAodHJhY2tMb2FkZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaGxzVXJsUGFyYW1ldGVycyA9IHRoaXMuc3dpdGNoUGFyYW1zKHRyYWNrLnVybCwgbGFzdFRyYWNrID09IG51bGwgPyB2b2lkIDAgOiBsYXN0VHJhY2suZGV0YWlscywgdHJhY2suZGV0YWlscyk7XG4gICAgdGhpcy5sb2FkUGxheWxpc3QoaGxzVXJsUGFyYW1ldGVycyk7XG4gIH1cbiAgZmluZFRyYWNrSWQoY3VycmVudFRyYWNrKSB7XG4gICAgY29uc3QgYXVkaW9UcmFja3MgPSB0aGlzLnRyYWNrc0luR3JvdXA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdWRpb1RyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdHJhY2sgPSBhdWRpb1RyYWNrc1tpXTtcbiAgICAgIGlmICh0aGlzLnNlbGVjdERlZmF1bHRUcmFjayAmJiAhdHJhY2suZGVmYXVsdCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghY3VycmVudFRyYWNrIHx8IG1hdGNoZXNPcHRpb24oY3VycmVudFRyYWNrLCB0cmFjaywgYXVkaW9NYXRjaFByZWRpY2F0ZSkpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjdXJyZW50VHJhY2spIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgbGFuZyxcbiAgICAgICAgYXNzb2NMYW5nLFxuICAgICAgICBjaGFyYWN0ZXJpc3RpY3MsXG4gICAgICAgIGF1ZGlvQ29kZWMsXG4gICAgICAgIGNoYW5uZWxzXG4gICAgICB9ID0gY3VycmVudFRyYWNrO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdWRpb1RyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB0cmFjayA9IGF1ZGlvVHJhY2tzW2ldO1xuICAgICAgICBpZiAobWF0Y2hlc09wdGlvbih7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBsYW5nLFxuICAgICAgICAgIGFzc29jTGFuZyxcbiAgICAgICAgICBjaGFyYWN0ZXJpc3RpY3MsXG4gICAgICAgICAgYXVkaW9Db2RlYyxcbiAgICAgICAgICBjaGFubmVsc1xuICAgICAgICB9LCB0cmFjaywgYXVkaW9NYXRjaFByZWRpY2F0ZSkpIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdWRpb1RyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB0cmFjayA9IGF1ZGlvVHJhY2tzW2ldO1xuICAgICAgICBpZiAobWVkaWFBdHRyaWJ1dGVzSWRlbnRpY2FsKGN1cnJlbnRUcmFjay5hdHRycywgdHJhY2suYXR0cnMsIFsnTEFOR1VBR0UnLCAnQVNTT0MtTEFOR1VBR0UnLCAnQ0hBUkFDVEVSSVNUSUNTJ10pKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXVkaW9UcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdHJhY2sgPSBhdWRpb1RyYWNrc1tpXTtcbiAgICAgICAgaWYgKG1lZGlhQXR0cmlidXRlc0lkZW50aWNhbChjdXJyZW50VHJhY2suYXR0cnMsIHRyYWNrLmF0dHJzLCBbJ0xBTkdVQUdFJ10pKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGxvYWRQbGF5bGlzdChobHNVcmxQYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIubG9hZFBsYXlsaXN0KCk7XG4gICAgY29uc3QgYXVkaW9UcmFjayA9IHRoaXMuY3VycmVudFRyYWNrO1xuICAgIGlmICghdGhpcy5zaG91bGRMb2FkUGxheWxpc3QoYXVkaW9UcmFjaykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gRG8gbm90IGxvYWQgYXVkaW8gcmVuZGl0aW9uIHdpdGggVVJJIG1hdGNoaW5nIG1haW4gdmFyaWFudCBVUklcbiAgICBpZiAodXNlQWx0ZXJuYXRlQXVkaW8oYXVkaW9UcmFjay51cmwsIHRoaXMuaGxzKSkge1xuICAgICAgdGhpcy5zY2hlZHVsZUxvYWRpbmcoYXVkaW9UcmFjaywgaGxzVXJsUGFyYW1ldGVycyk7XG4gICAgfVxuICB9XG4gIGxvYWRpbmdQbGF5bGlzdChhdWRpb1RyYWNrLCBobHNVcmxQYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIubG9hZGluZ1BsYXlsaXN0KGF1ZGlvVHJhY2ssIGhsc1VybFBhcmFtZXRlcnMpO1xuICAgIGNvbnN0IGlkID0gYXVkaW9UcmFjay5pZDtcbiAgICBjb25zdCBncm91cElkID0gYXVkaW9UcmFjay5ncm91cElkO1xuICAgIGNvbnN0IHVybCA9IHRoaXMuZ2V0VXJsV2l0aERpcmVjdGl2ZXMoYXVkaW9UcmFjay51cmwsIGhsc1VybFBhcmFtZXRlcnMpO1xuICAgIGNvbnN0IGRldGFpbHMgPSBhdWRpb1RyYWNrLmRldGFpbHM7XG4gICAgY29uc3QgYWdlID0gZGV0YWlscyA9PSBudWxsID8gdm9pZCAwIDogZGV0YWlscy5hZ2U7XG4gICAgdGhpcy5sb2coYExvYWRpbmcgYXVkaW8tdHJhY2sgJHtpZH0gXCIke2F1ZGlvVHJhY2submFtZX1cIiBsYW5nOiR7YXVkaW9UcmFjay5sYW5nfSBncm91cDoke2dyb3VwSWR9JHsoaGxzVXJsUGFyYW1ldGVycyA9PSBudWxsID8gdm9pZCAwIDogaGxzVXJsUGFyYW1ldGVycy5tc24pICE9PSB1bmRlZmluZWQgPyAnIGF0IHNuICcgKyBobHNVcmxQYXJhbWV0ZXJzLm1zbiArICcgcGFydCAnICsgaGxzVXJsUGFyYW1ldGVycy5wYXJ0IDogJyd9JHthZ2UgJiYgZGV0YWlscy5saXZlID8gJyBhZ2UgJyArIGFnZS50b0ZpeGVkKDEpICsgKGRldGFpbHMudHlwZSA/ICcgJyArIGRldGFpbHMudHlwZSB8fCAnJyA6ICcnKSA6ICcnfSAke3VybH1gKTtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5BVURJT19UUkFDS19MT0FESU5HLCB7XG4gICAgICB1cmwsXG4gICAgICBpZCxcbiAgICAgIGdyb3VwSWQsXG4gICAgICBkZWxpdmVyeURpcmVjdGl2ZXM6IGhsc1VybFBhcmFtZXRlcnMgfHwgbnVsbCxcbiAgICAgIHRyYWNrOiBhdWRpb1RyYWNrXG4gICAgfSk7XG4gIH1cbn1cblxuY2xhc3MgQnVmZmVyT3BlcmF0aW9uUXVldWUge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2VCdWZmZXJSZWZlcmVuY2UpIHtcbiAgICB0aGlzLnRyYWNrcyA9IHZvaWQgMDtcbiAgICB0aGlzLnF1ZXVlcyA9IHtcbiAgICAgIHZpZGVvOiBbXSxcbiAgICAgIGF1ZGlvOiBbXSxcbiAgICAgIGF1ZGlvdmlkZW86IFtdXG4gICAgfTtcbiAgICB0aGlzLnRyYWNrcyA9IHNvdXJjZUJ1ZmZlclJlZmVyZW5jZTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMudHJhY2tzID0gdGhpcy5xdWV1ZXMgPSBudWxsO1xuICB9XG4gIGFwcGVuZChvcGVyYXRpb24sIHR5cGUsIHBlbmRpbmcpIHtcbiAgICBpZiAodGhpcy5xdWV1ZXMgPT09IG51bGwgfHwgdGhpcy50cmFja3MgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcXVldWUgPSB0aGlzLnF1ZXVlc1t0eXBlXTtcbiAgICBxdWV1ZS5wdXNoKG9wZXJhdGlvbik7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhcGVuZGluZykge1xuICAgICAgdGhpcy5leGVjdXRlTmV4dCh0eXBlKTtcbiAgICB9XG4gIH1cbiAgYXBwZW5kQmxvY2tlcih0eXBlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgY29uc3Qgb3BlcmF0aW9uID0ge1xuICAgICAgICBsYWJlbDogJ2FzeW5jLWJsb2NrZXInLFxuICAgICAgICBleGVjdXRlOiByZXNvbHZlLFxuICAgICAgICBvblN0YXJ0OiAoKSA9PiB7fSxcbiAgICAgICAgb25Db21wbGV0ZTogKCkgPT4ge30sXG4gICAgICAgIG9uRXJyb3I6ICgpID0+IHt9XG4gICAgICB9O1xuICAgICAgdGhpcy5hcHBlbmQob3BlcmF0aW9uLCB0eXBlKTtcbiAgICB9KTtcbiAgfVxuICBwcmVwZW5kQmxvY2tlcih0eXBlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgaWYgKHRoaXMucXVldWVzKSB7XG4gICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IHtcbiAgICAgICAgICBsYWJlbDogJ2FzeW5jLWJsb2NrZXItcHJlcGVuZCcsXG4gICAgICAgICAgZXhlY3V0ZTogcmVzb2x2ZSxcbiAgICAgICAgICBvblN0YXJ0OiAoKSA9PiB7fSxcbiAgICAgICAgICBvbkNvbXBsZXRlOiAoKSA9PiB7fSxcbiAgICAgICAgICBvbkVycm9yOiAoKSA9PiB7fVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnF1ZXVlc1t0eXBlXS51bnNoaWZ0KG9wZXJhdGlvbik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmVtb3ZlQmxvY2tlcnMoKSB7XG4gICAgaWYgKHRoaXMucXVldWVzID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFt0aGlzLnF1ZXVlcy52aWRlbywgdGhpcy5xdWV1ZXMuYXVkaW8sIHRoaXMucXVldWVzLmF1ZGlvdmlkZW9dLmZvckVhY2gocXVldWUgPT4ge1xuICAgICAgdmFyIF9xdWV1ZSQ7XG4gICAgICBjb25zdCBsYWJlbCA9IChfcXVldWUkID0gcXVldWVbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfcXVldWUkLmxhYmVsO1xuICAgICAgaWYgKGxhYmVsID09PSAnYXN5bmMtYmxvY2tlcicgfHwgbGFiZWwgPT09ICdhc3luYy1ibG9ja2VyLXByZXBlbmQnKSB7XG4gICAgICAgIHF1ZXVlWzBdLmV4ZWN1dGUoKTtcbiAgICAgICAgcXVldWUuc3BsaWNlKDAsIDEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHVuYmxvY2tBdWRpbyhvcCkge1xuICAgIGlmICh0aGlzLnF1ZXVlcyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBxdWV1ZSA9IHRoaXMucXVldWVzLmF1ZGlvO1xuICAgIGlmIChxdWV1ZVswXSA9PT0gb3ApIHtcbiAgICAgIHRoaXMuc2hpZnRBbmRFeGVjdXRlTmV4dCgnYXVkaW8nKTtcbiAgICB9XG4gIH1cbiAgZXhlY3V0ZU5leHQodHlwZSkge1xuICAgIGlmICh0aGlzLnF1ZXVlcyA9PT0gbnVsbCB8fCB0aGlzLnRyYWNrcyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBxdWV1ZSA9IHRoaXMucXVldWVzW3R5cGVdO1xuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IHF1ZXVlWzBdO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gT3BlcmF0aW9ucyBhcmUgZXhwZWN0ZWQgdG8gcmVzdWx0IGluIGFuICd1cGRhdGVlbmQnIGV2ZW50IGJlaW5nIGZpcmVkLiBJZiBub3QsIHRoZSBxdWV1ZSB3aWxsIGxvY2suIE9wZXJhdGlvbnNcbiAgICAgICAgLy8gd2hpY2ggZG8gbm90IGVuZCB3aXRoIHRoaXMgZXZlbnQgbXVzdCBjYWxsIF9vblNCVXBkYXRlRW5kIG1hbnVhbGx5XG4gICAgICAgIG9wZXJhdGlvbi5leGVjdXRlKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB2YXIgX3RoaXMkdHJhY2tzJHR5cGU7XG4gICAgICAgIG9wZXJhdGlvbi5vbkVycm9yKGVycm9yKTtcbiAgICAgICAgaWYgKHRoaXMucXVldWVzID09PSBudWxsIHx8IHRoaXMudHJhY2tzID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT25seSBzaGlmdCB0aGUgY3VycmVudCBvcGVyYXRpb24gb2ZmLCBvdGhlcndpc2UgdGhlIHVwZGF0ZWVuZCBoYW5kbGVyIHdpbGwgZG8gdGhpcyBmb3IgdXNcbiAgICAgICAgY29uc3Qgc2IgPSAoX3RoaXMkdHJhY2tzJHR5cGUgPSB0aGlzLnRyYWNrc1t0eXBlXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHRyYWNrcyR0eXBlLmJ1ZmZlcjtcbiAgICAgICAgaWYgKCEoc2IgIT0gbnVsbCAmJiBzYi51cGRhdGluZykpIHtcbiAgICAgICAgICB0aGlzLnNoaWZ0QW5kRXhlY3V0ZU5leHQodHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2hpZnRBbmRFeGVjdXRlTmV4dCh0eXBlKSB7XG4gICAgaWYgKHRoaXMucXVldWVzID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucXVldWVzW3R5cGVdLnNoaWZ0KCk7XG4gICAgdGhpcy5leGVjdXRlTmV4dCh0eXBlKTtcbiAgfVxuICBjdXJyZW50KHR5cGUpIHtcbiAgICB2YXIgX3RoaXMkcXVldWVzO1xuICAgIHJldHVybiAoKF90aGlzJHF1ZXVlcyA9IHRoaXMucXVldWVzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkcXVldWVzW3R5cGVdWzBdKSB8fCBudWxsO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHF1ZXVlcyxcbiAgICAgIHRyYWNrc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmIChxdWV1ZXMgPT09IG51bGwgfHwgdHJhY2tzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gYDxkZXN0cm95ZWQ+YDtcbiAgICB9XG4gICAgcmV0dXJuIGBcbiR7dGhpcy5saXN0KCd2aWRlbycpfVxuJHt0aGlzLmxpc3QoJ2F1ZGlvJyl9XG4ke3RoaXMubGlzdCgnYXVkaW92aWRlbycpfX1gO1xuICB9XG4gIGxpc3QodHlwZSkge1xuICAgIHZhciBfdGhpcyRxdWV1ZXMyLCBfdGhpcyR0cmFja3M7XG4gICAgcmV0dXJuIChfdGhpcyRxdWV1ZXMyID0gdGhpcy5xdWV1ZXMpICE9IG51bGwgJiYgX3RoaXMkcXVldWVzMlt0eXBlXSB8fCAoX3RoaXMkdHJhY2tzID0gdGhpcy50cmFja3MpICE9IG51bGwgJiYgX3RoaXMkdHJhY2tzW3R5cGVdID8gYCR7dHlwZX06ICgke3RoaXMubGlzdFNiSW5mbyh0eXBlKX0pICR7dGhpcy5saXN0T3BzKHR5cGUpfWAgOiAnJztcbiAgfVxuICBsaXN0U2JJbmZvKHR5cGUpIHtcbiAgICB2YXIgX3RoaXMkdHJhY2tzMjtcbiAgICBjb25zdCB0cmFjayA9IChfdGhpcyR0cmFja3MyID0gdGhpcy50cmFja3MpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyR0cmFja3MyW3R5cGVdO1xuICAgIGNvbnN0IHNiID0gdHJhY2sgPT0gbnVsbCA/IHZvaWQgMCA6IHRyYWNrLmJ1ZmZlcjtcbiAgICBpZiAoIXNiKSB7XG4gICAgICByZXR1cm4gJ25vbmUnO1xuICAgIH1cbiAgICByZXR1cm4gYFNvdXJjZUJ1ZmZlciR7c2IudXBkYXRpbmcgPyAnIHVwZGF0aW5nJyA6ICcnfSR7dHJhY2suZW5kZWQgPyAnIGVuZGVkJyA6ICcnfSR7dHJhY2suZW5kaW5nID8gJyBlbmRpbmcnIDogJyd9YDtcbiAgfVxuICBsaXN0T3BzKHR5cGUpIHtcbiAgICB2YXIgX3RoaXMkcXVldWVzMztcbiAgICByZXR1cm4gKChfdGhpcyRxdWV1ZXMzID0gdGhpcy5xdWV1ZXMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRxdWV1ZXMzW3R5cGVdLm1hcChvcCA9PiBvcC5sYWJlbCkuam9pbignLCAnKSkgfHwgJyc7XG4gIH1cbn1cblxuY29uc3QgVklERU9fQ09ERUNfUFJPRklMRV9SRVBMQUNFID0gLyhhdmNbMTIzNF18aHZjMXxoZXYxfGR2aFsxZV18dnAwOXxhdjAxKSg/OlxcLlteLixdKykrLztcbmNvbnN0IFRSQUNLX1JFTU9WRURfRVJST1JfTkFNRSA9ICdIbHNKc1RyYWNrUmVtb3ZlZEVycm9yJztcbmNsYXNzIEhsc0pzVHJhY2tSZW1vdmVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBUUkFDS19SRU1PVkVEX0VSUk9SX05BTUU7XG4gIH1cbn1cbmNsYXNzIEJ1ZmZlckNvbnRyb2xsZXIgZXh0ZW5kcyBMb2dnZXIge1xuICBjb25zdHJ1Y3RvcihobHMsIGZyYWdtZW50VHJhY2tlcikge1xuICAgIHN1cGVyKCdidWZmZXItY29udHJvbGxlcicsIGhscy5sb2dnZXIpO1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyID0gdm9pZCAwO1xuICAgIC8vIFRoZSBsZXZlbCBkZXRhaWxzIHVzZWQgdG8gZGV0ZXJtaW5lIGR1cmF0aW9uLCB0YXJnZXQtZHVyYXRpb24gYW5kIGxpdmVcbiAgICB0aGlzLmRldGFpbHMgPSBudWxsO1xuICAgIC8vIGNhY2hlIHRoZSBzZWxmIGdlbmVyYXRlZCBvYmplY3QgdXJsIHRvIGRldGVjdCBoaWphY2sgb2YgdmlkZW8gdGFnXG4gICAgdGhpcy5fb2JqZWN0VXJsID0gbnVsbDtcbiAgICAvLyBBIHF1ZXVlIG9mIGJ1ZmZlciBvcGVyYXRpb25zIHdoaWNoIHJlcXVpcmUgdGhlIFNvdXJjZUJ1ZmZlciB0byBub3QgYmUgdXBkYXRpbmcgdXBvbiBleGVjdXRpb25cbiAgICB0aGlzLm9wZXJhdGlvblF1ZXVlID0gbnVsbDtcbiAgICAvLyBUaGUgdG90YWwgbnVtYmVyIHRyYWNrIGNvZGVjcyBleHBlY3RlZCBiZWZvcmUgYW55IHNvdXJjZUJ1ZmZlcnMgYXJlIGNyZWF0ZWQgKDI6IGF1ZGlvIGFuZCB2aWRlbyBvciAxOiBhdWRpb3ZpZGVvIHwgYXVkaW8gfCB2aWRlbylcbiAgICB0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzVG90YWwgPSAwO1xuICAgIC8vIEEgcmVmZXJlbmNlIHRvIHRoZSBhdHRhY2hlZCBtZWRpYSBlbGVtZW50XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgLy8gQSByZWZlcmVuY2UgdG8gdGhlIGFjdGl2ZSBtZWRpYSBzb3VyY2VcbiAgICB0aGlzLm1lZGlhU291cmNlID0gbnVsbDtcbiAgICAvLyBMYXN0IE1QMyBhdWRpbyBjaHVuayBhcHBlbmRlZFxuICAgIHRoaXMubGFzdE1wZWdBdWRpb0NodW5rID0gbnVsbDtcbiAgICAvLyBBdWRpbyBmcmFnbWVudCBibG9ja2VkIGZyb20gYXBwZW5kaW5nIHVudGlsIGNvcnJlc3BvbmRpbmcgdmlkZW8gYXBwZW5kcyBvciBjb250ZXh0IGNoYW5nZXNcbiAgICB0aGlzLmJsb2NrZWRBdWRpb0FwcGVuZCA9IG51bGw7XG4gICAgLy8gS2VlcCB0cmFjayBvZiB2aWRlbyBhcHBlbmQgcG9zaXRpb24gZm9yIHVuYmxvY2tpbmcgYXVkaW9cbiAgICB0aGlzLmxhc3RWaWRlb0FwcGVuZEVuZCA9IDA7XG4gICAgLy8gV2hldGhlciBvciBub3QgdG8gdXNlIE1hbmFnZWRNZWRpYVNvdXJjZSBBUEkgYW5kIGFwcGVuZCBzb3VyY2UgZWxlbWVudCB0byBtZWRpYSBlbGVtZW50LlxuICAgIHRoaXMuYXBwZW5kU291cmNlID0gdm9pZCAwO1xuICAgIC8vIFRyYW5zZmVycmVkIE1lZGlhU291cmNlIGluZm9ybWF0aW9uIHVzZWQgdG8gZGV0bWVyaW5lIGlmIGR1cmF0aW9uIGVuZCBlbmRzdHJlYW0gbWF5IGJlIGFwcGVuZGVkXG4gICAgdGhpcy50cmFuc2ZlckRhdGEgPSB2b2lkIDA7XG4gICAgLy8gRGlyZWN0aXZlcyB1c2VkIHRvIG92ZXJyaWRlIGRlZmF1bHQgTWVkaWFTb3VyY2UgaGFuZGxpbmdcbiAgICB0aGlzLm92ZXJyaWRlcyA9IHZvaWQgMDtcbiAgICAvLyBFcnJvciBjb3VudGVyc1xuICAgIHRoaXMuYXBwZW5kRXJyb3JzID0ge1xuICAgICAgYXVkaW86IDAsXG4gICAgICB2aWRlbzogMCxcbiAgICAgIGF1ZGlvdmlkZW86IDBcbiAgICB9O1xuICAgIC8vIFJlY29yZCBvZiByZXF1aXJlZCBvciBjcmVhdGVkIGJ1ZmZlcnMgYnkgdHlwZS4gU291cmNlQnVmZmVyIGlzIHN0b3JlZCBpbiBUcmFjay5idWZmZXIgb25jZSBjcmVhdGVkLlxuICAgIHRoaXMudHJhY2tzID0ge307XG4gICAgLy8gQXJyYXkgb2YgU291cmNlQnVmZmVyIHR5cGUgYW5kIFNvdXJjZUJ1ZmZlciAob3IgbnVsbCkuIE9uZSBlbnRyeSBwZXIgVHJhY2tTZXQgaW4gdGhpcy50cmFja3MuXG4gICAgdGhpcy5zb3VyY2VCdWZmZXJzID0gW1tudWxsLCBudWxsXSwgW251bGwsIG51bGxdXTtcbiAgICB0aGlzLl9vbkVuZFN0cmVhbWluZyA9IGV2ZW50ID0+IHtcbiAgICAgIHZhciBfdGhpcyRtZWRpYVNvdXJjZTtcbiAgICAgIGlmICghdGhpcy5obHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCgoX3RoaXMkbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbWVkaWFTb3VyY2UucmVhZHlTdGF0ZSkgIT09ICdvcGVuJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmhscy5wYXVzZUJ1ZmZlcmluZygpO1xuICAgIH07XG4gICAgdGhpcy5fb25TdGFydFN0cmVhbWluZyA9IGV2ZW50ID0+IHtcbiAgICAgIGlmICghdGhpcy5obHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5obHMucmVzdW1lQnVmZmVyaW5nKCk7XG4gICAgfTtcbiAgICAvLyBLZWVwIGFzIGFycm93IGZ1bmN0aW9ucyBzbyB0aGF0IHdlIGNhbiBkaXJlY3RseSByZWZlcmVuY2UgdGhlc2UgZnVuY3Rpb25zIGRpcmVjdGx5IGFzIGV2ZW50IGxpc3RlbmVyc1xuICAgIHRoaXMuX29uTWVkaWFTb3VyY2VPcGVuID0gZSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1lZGlhLFxuICAgICAgICBtZWRpYVNvdXJjZVxuICAgICAgfSA9IHRoaXM7XG4gICAgICBpZiAoZSkge1xuICAgICAgICB0aGlzLmxvZygnTWVkaWEgc291cmNlIG9wZW5lZCcpO1xuICAgICAgfVxuICAgICAgaWYgKCFtZWRpYSB8fCAhbWVkaWFTb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gb25jZSByZWNlaXZlZCwgZG9uJ3QgbGlzdGVuIGFueW1vcmUgdG8gc291cmNlb3BlbiBldmVudFxuICAgICAgbWVkaWFTb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIHRoaXMuX29uTWVkaWFTb3VyY2VPcGVuKTtcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VtcHRpZWQnLCB0aGlzLl9vbk1lZGlhRW1wdGllZCk7XG4gICAgICB0aGlzLnVwZGF0ZUR1cmF0aW9uKCk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwge1xuICAgICAgICBtZWRpYSxcbiAgICAgICAgbWVkaWFTb3VyY2U6IG1lZGlhU291cmNlXG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLm1lZGlhU291cmNlICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuY2hlY2tQZW5kaW5nVHJhY2tzKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9vbk1lZGlhU291cmNlQ2xvc2UgPSAoKSA9PiB7XG4gICAgICB0aGlzLmxvZygnTWVkaWEgc291cmNlIGNsb3NlZCcpO1xuICAgIH07XG4gICAgdGhpcy5fb25NZWRpYVNvdXJjZUVuZGVkID0gKCkgPT4ge1xuICAgICAgdGhpcy5sb2coJ01lZGlhIHNvdXJjZSBlbmRlZCcpO1xuICAgIH07XG4gICAgdGhpcy5fb25NZWRpYUVtcHRpZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1lZGlhU3JjLFxuICAgICAgICBfb2JqZWN0VXJsXG4gICAgICB9ID0gdGhpcztcbiAgICAgIGlmIChtZWRpYVNyYyAhPT0gX29iamVjdFVybCkge1xuICAgICAgICB0aGlzLmVycm9yKGBNZWRpYSBlbGVtZW50IHNyYyB3YXMgc2V0IHdoaWxlIGF0dGFjaGluZyBNZWRpYVNvdXJjZSAoJHtfb2JqZWN0VXJsfSA+ICR7bWVkaWFTcmN9KWApO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIgPSBmcmFnbWVudFRyYWNrZXI7XG4gICAgdGhpcy5hcHBlbmRTb3VyY2UgPSBpc01hbmFnZWRNZWRpYVNvdXJjZShnZXRNZWRpYVNvdXJjZShobHMuY29uZmlnLnByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSkpO1xuICAgIHRoaXMuaW5pdFRyYWNrcygpO1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICBoYXNTb3VyY2VUeXBlcygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy50cmFja3MpLmxlbmd0aCA+IDA7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmRldGFpbHMgPSBudWxsO1xuICAgIHRoaXMubGFzdE1wZWdBdWRpb0NodW5rID0gdGhpcy5ibG9ja2VkQXVkaW9BcHBlbmQgPSBudWxsO1xuICAgIHRoaXMudHJhbnNmZXJEYXRhID0gdGhpcy5vdmVycmlkZXMgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHRoaXMub3BlcmF0aW9uUXVldWUpIHtcbiAgICAgIHRoaXMub3BlcmF0aW9uUXVldWUuZGVzdHJveSgpO1xuICAgICAgdGhpcy5vcGVyYXRpb25RdWV1ZSA9IG51bGw7XG4gICAgfVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmhscyA9IHRoaXMuZnJhZ21lbnRUcmFja2VyID0gbnVsbDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5fb25NZWRpYVNvdXJjZU9wZW4gPSB0aGlzLl9vbk1lZGlhU291cmNlQ2xvc2UgPSBudWxsO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLl9vbk1lZGlhU291cmNlRW5kZWQgPSBudWxsO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLl9vblN0YXJ0U3RyZWFtaW5nID0gdGhpcy5fb25FbmRTdHJlYW1pbmcgPSBudWxsO1xuICB9XG4gIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfUkVTRVQsIHRoaXMub25CdWZmZXJSZXNldCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfQVBQRU5ESU5HLCB0aGlzLm9uQnVmZmVyQXBwZW5kaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9DT0RFQ1MsIHRoaXMub25CdWZmZXJDb2RlY3MsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0VPUywgdGhpcy5vbkJ1ZmZlckVvcywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfUEFSU0VELCB0aGlzLm9uRnJhZ1BhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX0NIQU5HRUQsIHRoaXMub25GcmFnQ2hhbmdlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfVxuICB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9SRVNFVCwgdGhpcy5vbkJ1ZmZlclJlc2V0LCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfQVBQRU5ESU5HLCB0aGlzLm9uQnVmZmVyQXBwZW5kaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfQ09ERUNTLCB0aGlzLm9uQnVmZmVyQ29kZWNzLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfRU9TLCB0aGlzLm9uQnVmZmVyRW9zLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxfVVBEQVRFRCwgdGhpcy5vbkxldmVsVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19QQVJTRUQsIHRoaXMub25GcmFnUGFyc2VkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0NIQU5HRUQsIHRoaXMub25GcmFnQ2hhbmdlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH1cbiAgdHJhbnNmZXJNZWRpYSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBtZWRpYSxcbiAgICAgIG1lZGlhU291cmNlXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFtZWRpYSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHRyYWNrcyA9IHt9O1xuICAgIGlmICh0aGlzLm9wZXJhdGlvblF1ZXVlKSB7XG4gICAgICBjb25zdCB1cGRhdGluZyA9IHRoaXMuaXNVcGRhdGluZygpO1xuICAgICAgaWYgKCF1cGRhdGluZykge1xuICAgICAgICB0aGlzLm9wZXJhdGlvblF1ZXVlLnJlbW92ZUJsb2NrZXJzKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBxdWV1ZWQgPSB0aGlzLmlzUXVldWVkKCk7XG4gICAgICBpZiAodXBkYXRpbmcgfHwgcXVldWVkKSB7XG4gICAgICAgIHRoaXMud2FybihgVHJhbnNmZXJpbmcgTWVkaWFTb3VyY2Ugd2l0aCR7cXVldWVkID8gJyBvcGVyYXRpb25zIGluIHF1ZXVlJyA6ICcnfSR7dXBkYXRpbmcgPyAnIHVwZGF0aW5nIFNvdXJjZUJ1ZmZlcihzKScgOiAnJ30gJHt0aGlzLm9wZXJhdGlvblF1ZXVlfWApO1xuICAgICAgfVxuICAgICAgdGhpcy5vcGVyYXRpb25RdWV1ZS5kZXN0cm95KCk7XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zZmVyRGF0YSA9IHRoaXMudHJhbnNmZXJEYXRhO1xuICAgIGlmICghdGhpcy5zb3VyY2VCdWZmZXJDb3VudCAmJiB0cmFuc2ZlckRhdGEgJiYgdHJhbnNmZXJEYXRhLm1lZGlhU291cmNlID09PSBtZWRpYVNvdXJjZSkge1xuICAgICAgX2V4dGVuZHModHJhY2tzLCB0cmFuc2ZlckRhdGEudHJhY2tzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zb3VyY2VCdWZmZXJzLmZvckVhY2godHVwbGUgPT4ge1xuICAgICAgICBjb25zdCBbdHlwZV0gPSB0dXBsZTtcbiAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICB0cmFja3NbdHlwZV0gPSBfZXh0ZW5kcyh7fSwgdGhpcy50cmFja3NbdHlwZV0pO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQnVmZmVyKHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHR1cGxlWzBdID0gdHVwbGVbMV0gPSBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBtZWRpYSxcbiAgICAgIG1lZGlhU291cmNlLFxuICAgICAgdHJhY2tzXG4gICAgfTtcbiAgfVxuICBpbml0VHJhY2tzKCkge1xuICAgIGNvbnN0IHRyYWNrcyA9IHt9O1xuICAgIHRoaXMuc291cmNlQnVmZmVycyA9IFtbbnVsbCwgbnVsbF0sIFtudWxsLCBudWxsXV07XG4gICAgdGhpcy50cmFja3MgPSB0cmFja3M7XG4gICAgdGhpcy5yZXNldFF1ZXVlKCk7XG4gICAgdGhpcy5yZXNldEFwcGVuZEVycm9ycygpO1xuICAgIHRoaXMubGFzdE1wZWdBdWRpb0NodW5rID0gdGhpcy5ibG9ja2VkQXVkaW9BcHBlbmQgPSBudWxsO1xuICAgIHRoaXMubGFzdFZpZGVvQXBwZW5kRW5kID0gMDtcbiAgfVxuICBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzVG90YWwgPSAwO1xuICAgIHRoaXMuZGV0YWlscyA9IG51bGw7XG4gIH1cbiAgb25NYW5pZmVzdFBhcnNlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBfdGhpcyR0cmFuc2ZlckRhdGE7XG4gICAgLy8gaW4gY2FzZSBvZiBhbHQgYXVkaW8gMiBCVUZGRVJfQ09ERUNTIGV2ZW50cyB3aWxsIGJlIHRyaWdnZXJlZCwgb25lIHBlciBzdHJlYW0gY29udHJvbGxlclxuICAgIC8vIHNvdXJjZWJ1ZmZlcnMgd2lsbCBiZSBjcmVhdGVkIGFsbCBhdCBvbmNlIHdoZW4gdGhlIGV4cGVjdGVkIG5iIG9mIHRyYWNrcyB3aWxsIGJlIHJlYWNoZWRcbiAgICAvLyBpbiBjYXNlIGFsdCBhdWRpbyBpcyBub3QgdXNlZCwgb25seSBvbmUgQlVGRkVSX0NPREVDIGV2ZW50IHdpbGwgYmUgZmlyZWQgZnJvbSBtYWluIHN0cmVhbSBjb250cm9sbGVyXG4gICAgLy8gaXQgd2lsbCBjb250YWluIHRoZSBleHBlY3RlZCBuYiBvZiBzb3VyY2UgYnVmZmVycywgbm8gbmVlZCB0byBjb21wdXRlIGl0XG4gICAgbGV0IGNvZGVjRXZlbnRzID0gMjtcbiAgICBpZiAoZGF0YS5hdWRpbyAmJiAhZGF0YS52aWRlbyB8fCAhZGF0YS5hbHRBdWRpbykge1xuICAgICAgY29kZWNFdmVudHMgPSAxO1xuICAgIH1cbiAgICB0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzVG90YWwgPSBjb2RlY0V2ZW50cztcbiAgICB0aGlzLmxvZyhgJHtjb2RlY0V2ZW50c30gYnVmZmVyQ29kZWMgZXZlbnQocykgZXhwZWN0ZWQuYCk7XG4gICAgaWYgKChfdGhpcyR0cmFuc2ZlckRhdGEgPSB0aGlzLnRyYW5zZmVyRGF0YSkgIT0gbnVsbCAmJiBfdGhpcyR0cmFuc2ZlckRhdGEubWVkaWFTb3VyY2UgJiYgdGhpcy5zb3VyY2VCdWZmZXJDb3VudCAmJiBjb2RlY0V2ZW50cykge1xuICAgICAgdGhpcy5idWZmZXJDcmVhdGVkKCk7XG4gICAgfVxuICB9XG4gIG9uTWVkaWFBdHRhY2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuICAgIGNvbnN0IE1lZGlhU291cmNlID0gZ2V0TWVkaWFTb3VyY2UodGhpcy5hcHBlbmRTb3VyY2UpO1xuICAgIHRoaXMudHJhbnNmZXJEYXRhID0gdGhpcy5vdmVycmlkZXMgPSB1bmRlZmluZWQ7XG4gICAgaWYgKG1lZGlhICYmIE1lZGlhU291cmNlKSB7XG4gICAgICBjb25zdCB0cmFuc2ZlcnJpbmdNZWRpYSA9ICEhZGF0YS5tZWRpYVNvdXJjZTtcbiAgICAgIGlmICh0cmFuc2ZlcnJpbmdNZWRpYSB8fCBkYXRhLm92ZXJyaWRlcykge1xuICAgICAgICB0aGlzLnRyYW5zZmVyRGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMub3ZlcnJpZGVzID0gZGF0YS5vdmVycmlkZXM7XG4gICAgICB9XG4gICAgICBjb25zdCBtcyA9IHRoaXMubWVkaWFTb3VyY2UgPSBkYXRhLm1lZGlhU291cmNlIHx8IG5ldyBNZWRpYVNvdXJjZSgpO1xuICAgICAgdGhpcy5hc3NpZ25NZWRpYVNvdXJjZShtcyk7XG4gICAgICBpZiAodHJhbnNmZXJyaW5nTWVkaWEpIHtcbiAgICAgICAgdGhpcy5fb2JqZWN0VXJsID0gbWVkaWEuc3JjO1xuICAgICAgICB0aGlzLmF0dGFjaFRyYW5zZmVycmVkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjYWNoZSB0aGUgbG9jYWxseSBnZW5lcmF0ZWQgb2JqZWN0IHVybFxuICAgICAgICBjb25zdCBvYmplY3RVcmwgPSB0aGlzLl9vYmplY3RVcmwgPSBzZWxmLlVSTC5jcmVhdGVPYmplY3RVUkwobXMpO1xuICAgICAgICAvLyBsaW5rIHZpZGVvIGFuZCBtZWRpYSBTb3VyY2VcbiAgICAgICAgaWYgKHRoaXMuYXBwZW5kU291cmNlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1lZGlhLnJlbW92ZUF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgICAgICAgICAvLyBNYW5hZ2VkTWVkaWFTb3VyY2Ugd2lsbCBub3Qgb3BlbiB3aXRob3V0IGRpc2FibGVSZW1vdGVQbGF5YmFjayBzZXQgdG8gZmFsc2Ugb3Igc291cmNlIGFsdGVybmF0aXZlc1xuICAgICAgICAgICAgY29uc3QgTU1TID0gc2VsZi5NYW5hZ2VkTWVkaWFTb3VyY2U7XG4gICAgICAgICAgICBtZWRpYS5kaXNhYmxlUmVtb3RlUGxheWJhY2sgPSBtZWRpYS5kaXNhYmxlUmVtb3RlUGxheWJhY2sgfHwgTU1TICYmIG1zIGluc3RhbmNlb2YgTU1TO1xuICAgICAgICAgICAgcmVtb3ZlU291cmNlQ2hpbGRyZW4obWVkaWEpO1xuICAgICAgICAgICAgYWRkU291cmNlKG1lZGlhLCBvYmplY3RVcmwpO1xuICAgICAgICAgICAgbWVkaWEubG9hZCgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBtZWRpYS5zcmMgPSBvYmplY3RVcmw7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1lZGlhLnNyYyA9IG9iamVjdFVybDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignZW1wdGllZCcsIHRoaXMuX29uTWVkaWFFbXB0aWVkKTtcbiAgICB9XG4gIH1cbiAgYXNzaWduTWVkaWFTb3VyY2UobXMpIHtcbiAgICB2YXIgX3RoaXMkdHJhbnNmZXJEYXRhMiwgX21zJGNvbnN0cnVjdG9yO1xuICAgIHRoaXMubG9nKGAkeygoX3RoaXMkdHJhbnNmZXJEYXRhMiA9IHRoaXMudHJhbnNmZXJEYXRhKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkdHJhbnNmZXJEYXRhMi5tZWRpYVNvdXJjZSkgPT09IG1zID8gJ3RyYW5zZmVycmVkJyA6ICdjcmVhdGVkJ30gbWVkaWEgc291cmNlOiAkeyhfbXMkY29uc3RydWN0b3IgPSBtcy5jb25zdHJ1Y3RvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9tcyRjb25zdHJ1Y3Rvci5uYW1lfWApO1xuICAgIC8vIE1lZGlhU291cmNlIGxpc3RlbmVycyBhcmUgYXJyb3cgZnVuY3Rpb25zIHdpdGggYSBsZXhpY2FsIHNjb3BlLCBhbmQgZG8gbm90IG5lZWQgdG8gYmUgYm91bmRcbiAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgdGhpcy5fb25NZWRpYVNvdXJjZU9wZW4pO1xuICAgIG1zLmFkZEV2ZW50TGlzdGVuZXIoJ3NvdXJjZWVuZGVkJywgdGhpcy5fb25NZWRpYVNvdXJjZUVuZGVkKTtcbiAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VjbG9zZScsIHRoaXMuX29uTWVkaWFTb3VyY2VDbG9zZSk7XG4gICAgaWYgKHRoaXMuYXBwZW5kU291cmNlKSB7XG4gICAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzdGFydHN0cmVhbWluZycsIHRoaXMuX29uU3RhcnRTdHJlYW1pbmcpO1xuICAgICAgbXMuYWRkRXZlbnRMaXN0ZW5lcignZW5kc3RyZWFtaW5nJywgdGhpcy5fb25FbmRTdHJlYW1pbmcpO1xuICAgIH1cbiAgfVxuICBhdHRhY2hUcmFuc2ZlcnJlZCgpIHtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMudHJhbnNmZXJEYXRhO1xuICAgIGlmICghZGF0YSB8fCAhbWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVxdWlyZWRUcmFja3MgPSB0aGlzLnRyYWNrcztcbiAgICBjb25zdCB0cmFuc2ZlcnJlZFRyYWNrcyA9IGRhdGEudHJhY2tzO1xuICAgIGNvbnN0IHRyYWNrTmFtZXMgPSB0cmFuc2ZlcnJlZFRyYWNrcyA/IE9iamVjdC5rZXlzKHRyYW5zZmVycmVkVHJhY2tzKSA6IG51bGw7XG4gICAgY29uc3QgdHJhY2tDb3VudCA9IHRyYWNrTmFtZXMgPyB0cmFja05hbWVzLmxlbmd0aCA6IDA7XG4gICAgY29uc3QgbWVkaWFTb3VyY2VPcGVuQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5tZWRpYSAmJiB0aGlzLm1lZGlhU291cmNlT3Blbk9yRW5kZWQpIHtcbiAgICAgICAgdGhpcy5fb25NZWRpYVNvdXJjZU9wZW4oKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmICh0cmFuc2ZlcnJlZFRyYWNrcyAmJiB0cmFja05hbWVzICYmIHRyYWNrQ291bnQpIHtcbiAgICAgIGlmICghdGhpcy50cmFja3NSZWFkeSkge1xuICAgICAgICAvLyBXYWl0IGZvciBDT0RFQ1MgZXZlbnQocylcbiAgICAgICAgdGhpcy5obHMuY29uZmlnLnN0YXJ0RnJhZ1ByZWZldGNoID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sb2coYGF0dGFjaFRyYW5zZmVycmVkOiB3YWl0aW5nIGZvciBTb3VyY2VCdWZmZXIgdHJhY2sgaW5mb2ApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmxvZyhgYXR0YWNoVHJhbnNmZXJyZWQ6IChidWZmZXJDb2RlY0V2ZW50c1RvdGFsICR7dGhpcy5idWZmZXJDb2RlY0V2ZW50c1RvdGFsfSlcbnJlcXVpcmVkIHRyYWNrczogJHtzdHJpbmdpZnkocmVxdWlyZWRUcmFja3MsIChrZXksIHZhbHVlKSA9PiBrZXkgPT09ICdpbml0U2VnbWVudCcgPyB1bmRlZmluZWQgOiB2YWx1ZSl9O1xudHJhbnNmZXIgdHJhY2tzOiAke3N0cmluZ2lmeSh0cmFuc2ZlcnJlZFRyYWNrcywgKGtleSwgdmFsdWUpID0+IGtleSA9PT0gJ2luaXRTZWdtZW50JyA/IHVuZGVmaW5lZCA6IHZhbHVlKX19YCk7XG4gICAgICBpZiAoIWlzQ29tcGF0aWJsZVRyYWNrQ2hhbmdlKHRyYW5zZmVycmVkVHJhY2tzLCByZXF1aXJlZFRyYWNrcykpIHtcbiAgICAgICAgLy8gZGVzdHJveSBhdHRhY2hpbmcgbWVkaWEgc291cmNlXG4gICAgICAgIGRhdGEubWVkaWFTb3VyY2UgPSBudWxsO1xuICAgICAgICBkYXRhLnRyYWNrcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICAgICAgY29uc3QgZGV0YWlscyA9IHRoaXMuZGV0YWlscztcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gTWF0aC5tYXgoY3VycmVudFRpbWUsIChkZXRhaWxzID09IG51bGwgPyB2b2lkIDAgOiBkZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydCkgfHwgMCk7XG4gICAgICAgIGlmIChzdGFydFRpbWUgLSBjdXJyZW50VGltZSA+IDEpIHtcbiAgICAgICAgICB0aGlzLmxvZyhgYXR0YWNoVHJhbnNmZXJyZWQ6IHdhaXRpbmcgZm9yIHBsYXliYWNrIHRvIHJlYWNoIG5ldyB0cmFja3Mgc3RhcnQgdGltZSAke2N1cnJlbnRUaW1lfSAtPiAke3N0YXJ0VGltZX1gKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53YXJuKGBhdHRhY2hUcmFuc2ZlcnJlZDogcmVzZXR0aW5nIE1lZGlhU291cmNlIGZvciBpbmNvbXBhdGlibGUgdHJhY2tzIChcIiR7T2JqZWN0LmtleXModHJhbnNmZXJyZWRUcmFja3MpfVwiLT5cIiR7T2JqZWN0LmtleXMocmVxdWlyZWRUcmFja3MpfVwiKSBzdGFydCB0aW1lOiAke3N0YXJ0VGltZX0gY3VycmVudFRpbWU6ICR7Y3VycmVudFRpbWV9YCk7XG4gICAgICAgIHRoaXMub25NZWRpYURldGFjaGluZyhFdmVudHMuTUVESUFfREVUQUNISU5HLCB7fSk7XG4gICAgICAgIHRoaXMub25NZWRpYUF0dGFjaGluZyhFdmVudHMuTUVESUFfQVRUQUNISU5HLCBkYXRhKTtcbiAgICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSBzdGFydFRpbWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMudHJhbnNmZXJEYXRhID0gdW5kZWZpbmVkO1xuICAgICAgdHJhY2tOYW1lcy5mb3JFYWNoKHRyYWNrTmFtZSA9PiB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0cmFja05hbWU7XG4gICAgICAgIGNvbnN0IHRyYWNrID0gdHJhbnNmZXJyZWRUcmFja3NbdHlwZV07XG4gICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgIGNvbnN0IHNiID0gdHJhY2suYnVmZmVyO1xuICAgICAgICAgIGlmIChzYikge1xuICAgICAgICAgICAgLy8gUHVyZ2UgZnJhZ21lbnQgdHJhY2tlciBvZiBlamVjdGVkIHNlZ21lbnRzIGZvciBleGlzdGluZyBidWZmZXJcbiAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50VHJhY2tlciA9IHRoaXMuZnJhZ21lbnRUcmFja2VyO1xuICAgICAgICAgICAgY29uc3QgcGxheWxpc3RUeXBlID0gdHJhY2suaWQ7XG4gICAgICAgICAgICBpZiAoZnJhZ21lbnRUcmFja2VyLmhhc0ZyYWdtZW50cyhwbGF5bGlzdFR5cGUpIHx8IGZyYWdtZW50VHJhY2tlci5oYXNQYXJ0cyhwbGF5bGlzdFR5cGUpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlcmVkVGltZVJhbmdlcyA9IEJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZChzYik7XG4gICAgICAgICAgICAgIGZyYWdtZW50VHJhY2tlci5kZXRlY3RFdmljdGVkRnJhZ21lbnRzKHR5cGUsIGJ1ZmZlcmVkVGltZVJhbmdlcywgcGxheWxpc3RUeXBlLCBudWxsLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRyYW5zZmVyIFNvdXJjZUJ1ZmZlclxuICAgICAgICAgICAgY29uc3Qgc2JJbmRleCA9IHNvdXJjZUJ1ZmZlck5hbWVUb0luZGV4KHR5cGUpO1xuICAgICAgICAgICAgY29uc3Qgc2JUdXBsZSA9IFt0eXBlLCBzYl07XG4gICAgICAgICAgICB0aGlzLnNvdXJjZUJ1ZmZlcnNbc2JJbmRleF0gPSBzYlR1cGxlO1xuICAgICAgICAgICAgaWYgKHNiLnVwZGF0aW5nICYmIHRoaXMub3BlcmF0aW9uUXVldWUpIHtcbiAgICAgICAgICAgICAgdGhpcy5vcGVyYXRpb25RdWV1ZS5wcmVwZW5kQmxvY2tlcih0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJhY2tTb3VyY2VCdWZmZXIodHlwZSwgdHJhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBtZWRpYVNvdXJjZU9wZW5DYWxsYmFjaygpO1xuICAgICAgdGhpcy5idWZmZXJDcmVhdGVkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nKGBhdHRhY2hUcmFuc2ZlcnJlZDogTWVkaWFTb3VyY2Ugdy9vIFNvdXJjZUJ1ZmZlcnNgKTtcbiAgICAgIG1lZGlhU291cmNlT3BlbkNhbGxiYWNrKCk7XG4gICAgfVxuICB9XG4gIGdldCBtZWRpYVNvdXJjZU9wZW5PckVuZGVkKCkge1xuICAgIHZhciBfdGhpcyRtZWRpYVNvdXJjZTI7XG4gICAgY29uc3QgcmVhZHlTdGF0ZSA9IChfdGhpcyRtZWRpYVNvdXJjZTIgPSB0aGlzLm1lZGlhU291cmNlKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbWVkaWFTb3VyY2UyLnJlYWR5U3RhdGU7XG4gICAgcmV0dXJuIHJlYWR5U3RhdGUgPT09ICdvcGVuJyB8fCByZWFkeVN0YXRlID09PSAnZW5kZWQnO1xuICB9XG4gIG9uTWVkaWFEZXRhY2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB0cmFuc2ZlcnJpbmdNZWRpYSA9ICEhZGF0YS50cmFuc2Zlck1lZGlhO1xuICAgIHRoaXMudHJhbnNmZXJEYXRhID0gdGhpcy5vdmVycmlkZXMgPSB1bmRlZmluZWQ7XG4gICAgY29uc3Qge1xuICAgICAgbWVkaWEsXG4gICAgICBtZWRpYVNvdXJjZSxcbiAgICAgIF9vYmplY3RVcmxcbiAgICB9ID0gdGhpcztcbiAgICBpZiAobWVkaWFTb3VyY2UpIHtcbiAgICAgIHRoaXMubG9nKGBtZWRpYSBzb3VyY2UgJHt0cmFuc2ZlcnJpbmdNZWRpYSA/ICd0cmFuc2ZlcnJpbmcnIDogJ2RldGFjaGluZyd9YCk7XG4gICAgICBpZiAodHJhbnNmZXJyaW5nTWVkaWEpIHtcbiAgICAgICAgLy8gRGV0YWNoIFNvdXJjZUJ1ZmZlcnMgd2l0aG91dCByZW1vdmluZyBmcm9tIE1lZGlhU291cmNlXG4gICAgICAgIC8vIGFuZCBsZWF2ZSBgdHJhY2tzYCAocmVxdWlyZWQgU291cmNlQnVmZmVycyBjb25maWd1cmF0aW9uKVxuICAgICAgICB0aGlzLnNvdXJjZUJ1ZmZlcnMuZm9yRWFjaCgoW3R5cGVdKSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQnVmZmVyKHR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVzZXRRdWV1ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMubWVkaWFTb3VyY2VPcGVuT3JFbmRlZCkge1xuICAgICAgICAgIGNvbnN0IG9wZW4gPSBtZWRpYVNvdXJjZS5yZWFkeVN0YXRlID09PSAnb3Blbic7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZUJ1ZmZlcnMgPSBtZWRpYVNvdXJjZS5zb3VyY2VCdWZmZXJzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHNvdXJjZUJ1ZmZlcnMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICAgICAgc291cmNlQnVmZmVyc1tpXS5hYm9ydCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG1lZGlhU291cmNlLnJlbW92ZVNvdXJjZUJ1ZmZlcihzb3VyY2VCdWZmZXJzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICAgIC8vIGVuZE9mU3RyZWFtIGNvdWxkIHRyaWdnZXIgZXhjZXB0aW9uIGlmIGFueSBzb3VyY2VidWZmZXIgaXMgaW4gdXBkYXRpbmcgc3RhdGVcbiAgICAgICAgICAgICAgLy8gd2UgZG9uJ3QgcmVhbGx5IGNhcmUgYWJvdXQgY2hlY2tpbmcgc291cmNlYnVmZmVyIHN0YXRlIGhlcmUsXG4gICAgICAgICAgICAgIC8vIGFzIHdlIGFyZSBhbnl3YXkgZGV0YWNoaW5nIHRoZSBNZWRpYVNvdXJjZVxuICAgICAgICAgICAgICAvLyBsZXQncyBqdXN0IGF2b2lkIHRoaXMgZXhjZXB0aW9uIHRvIHByb3BhZ2F0ZVxuICAgICAgICAgICAgICBtZWRpYVNvdXJjZS5lbmRPZlN0cmVhbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy53YXJuKGBvbk1lZGlhRGV0YWNoaW5nOiAke2Vyci5tZXNzYWdlfSB3aGlsZSBjYWxsaW5nIGVuZE9mU3RyZWFtYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENsZWFuIHVwIHRoZSBTb3VyY2VCdWZmZXJzIGJ5IGludm9raW5nIG9uQnVmZmVyUmVzZXRcbiAgICAgICAgaWYgKHRoaXMuc291cmNlQnVmZmVyQ291bnQpIHtcbiAgICAgICAgICB0aGlzLm9uQnVmZmVyUmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWVkaWFTb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIHRoaXMuX29uTWVkaWFTb3VyY2VPcGVuKTtcbiAgICAgIG1lZGlhU291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZWVuZGVkJywgdGhpcy5fb25NZWRpYVNvdXJjZUVuZGVkKTtcbiAgICAgIG1lZGlhU291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZWNsb3NlJywgdGhpcy5fb25NZWRpYVNvdXJjZUNsb3NlKTtcbiAgICAgIGlmICh0aGlzLmFwcGVuZFNvdXJjZSkge1xuICAgICAgICBtZWRpYVNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdzdGFydHN0cmVhbWluZycsIHRoaXMuX29uU3RhcnRTdHJlYW1pbmcpO1xuICAgICAgICBtZWRpYVNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRzdHJlYW1pbmcnLCB0aGlzLl9vbkVuZFN0cmVhbWluZyk7XG4gICAgICB9XG4gICAgICB0aGlzLm1lZGlhU291cmNlID0gbnVsbDtcbiAgICAgIHRoaXMuX29iamVjdFVybCA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gRGV0YWNoIHByb3Blcmx5IHRoZSBNZWRpYVNvdXJjZSBmcm9tIHRoZSBIVE1MTWVkaWFFbGVtZW50IGFzXG4gICAgLy8gc3VnZ2VzdGVkIGluIGh0dHBzOi8vZ2l0aHViLmNvbS93M2MvbWVkaWEtc291cmNlL2lzc3Vlcy81My5cbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VtcHRpZWQnLCB0aGlzLl9vbk1lZGlhRW1wdGllZCk7XG4gICAgICBpZiAoIXRyYW5zZmVycmluZ01lZGlhKSB7XG4gICAgICAgIGlmIChfb2JqZWN0VXJsKSB7XG4gICAgICAgICAgc2VsZi5VUkwucmV2b2tlT2JqZWN0VVJMKF9vYmplY3RVcmwpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYW4gdXAgdmlkZW8gdGFnIHNyYyBvbmx5IGlmIGl0J3Mgb3VyIG93biB1cmwuIHNvbWUgZXh0ZXJuYWwgbGlicmFyaWVzIG1pZ2h0XG4gICAgICAgIC8vIGhpamFjayB0aGUgdmlkZW8gdGFnIGFuZCBjaGFuZ2UgaXRzICdzcmMnIHdpdGhvdXQgZGVzdHJveWluZyB0aGUgSGxzIGluc3RhbmNlIGZpcnN0XG4gICAgICAgIGlmICh0aGlzLm1lZGlhU3JjID09PSBfb2JqZWN0VXJsKSB7XG4gICAgICAgICAgbWVkaWEucmVtb3ZlQXR0cmlidXRlKCdzcmMnKTtcbiAgICAgICAgICBpZiAodGhpcy5hcHBlbmRTb3VyY2UpIHtcbiAgICAgICAgICAgIHJlbW92ZVNvdXJjZUNoaWxkcmVuKG1lZGlhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWVkaWEubG9hZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMud2FybignbWVkaWF8c291cmNlLnNyYyB3YXMgY2hhbmdlZCBieSBhIHRoaXJkIHBhcnR5IC0gc2tpcCBjbGVhbnVwJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5NRURJQV9ERVRBQ0hFRCwgZGF0YSk7XG4gIH1cbiAgb25CdWZmZXJSZXNldCgpIHtcbiAgICB0aGlzLnNvdXJjZUJ1ZmZlcnMuZm9yRWFjaCgoW3R5cGVdKSA9PiB7XG4gICAgICBpZiAodHlwZSkge1xuICAgICAgICB0aGlzLnJlc2V0QnVmZmVyKHR5cGUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuaW5pdFRyYWNrcygpO1xuICB9XG4gIHJlc2V0QnVmZmVyKHR5cGUpIHtcbiAgICB2YXIgX3RoaXMkdHJhY2tzJHR5cGU7XG4gICAgY29uc3Qgc2IgPSAoX3RoaXMkdHJhY2tzJHR5cGUgPSB0aGlzLnRyYWNrc1t0eXBlXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHRyYWNrcyR0eXBlLmJ1ZmZlcjtcbiAgICB0aGlzLnJlbW92ZUJ1ZmZlcih0eXBlKTtcbiAgICBpZiAoc2IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBfdGhpcyRtZWRpYVNvdXJjZTM7XG4gICAgICAgIGlmICgoX3RoaXMkbWVkaWFTb3VyY2UzID0gdGhpcy5tZWRpYVNvdXJjZSkgIT0gbnVsbCAmJiBfdGhpcyRtZWRpYVNvdXJjZTMuc291cmNlQnVmZmVycy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLm1lZGlhU291cmNlLnJlbW92ZVNvdXJjZUJ1ZmZlcihzYik7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLndhcm4oYG9uQnVmZmVyUmVzZXQgJHt0eXBlfWAsIGVycik7XG4gICAgICB9XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLnRyYWNrc1t0eXBlXTtcbiAgfVxuICByZW1vdmVCdWZmZXIodHlwZSkge1xuICAgIHRoaXMucmVtb3ZlQnVmZmVyTGlzdGVuZXJzKHR5cGUpO1xuICAgIHRoaXMuc291cmNlQnVmZmVyc1tzb3VyY2VCdWZmZXJOYW1lVG9JbmRleCh0eXBlKV0gPSBbbnVsbCwgbnVsbF07XG4gICAgY29uc3QgdHJhY2sgPSB0aGlzLnRyYWNrc1t0eXBlXTtcbiAgICBpZiAodHJhY2spIHtcbiAgICAgIHRyYWNrLmJ1ZmZlciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgcmVzZXRRdWV1ZSgpIHtcbiAgICBpZiAodGhpcy5vcGVyYXRpb25RdWV1ZSkge1xuICAgICAgdGhpcy5vcGVyYXRpb25RdWV1ZS5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMub3BlcmF0aW9uUXVldWUgPSBuZXcgQnVmZmVyT3BlcmF0aW9uUXVldWUodGhpcy50cmFja3MpO1xuICB9XG4gIG9uQnVmZmVyQ29kZWNzKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3QgdHJhY2tzID0gdGhpcy50cmFja3M7XG4gICAgY29uc3QgdHJhY2tOYW1lcyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgIHRoaXMubG9nKGBCVUZGRVJfQ09ERUNTOiBcIiR7dHJhY2tOYW1lc31cIiAoY3VycmVudCBTQiBjb3VudCAke3RoaXMuc291cmNlQnVmZmVyQ291bnR9KWApO1xuICAgIGNvbnN0IHVubXV4ZWRUb011eGVkID0gJ2F1ZGlvdmlkZW8nIGluIGRhdGEgJiYgKHRyYWNrcy5hdWRpbyB8fCB0cmFja3MudmlkZW8pIHx8IHRyYWNrcy5hdWRpb3ZpZGVvICYmICgnYXVkaW8nIGluIGRhdGEgfHwgJ3ZpZGVvJyBpbiBkYXRhKTtcbiAgICBjb25zdCBtdXhlZFRvVW5tdXhlZCA9ICF1bm11eGVkVG9NdXhlZCAmJiB0aGlzLnNvdXJjZUJ1ZmZlckNvdW50ICYmIHRoaXMubWVkaWEgJiYgdHJhY2tOYW1lcy5zb21lKHNiTmFtZSA9PiAhdHJhY2tzW3NiTmFtZV0pO1xuICAgIGlmICh1bm11eGVkVG9NdXhlZCB8fCBtdXhlZFRvVW5tdXhlZCkge1xuICAgICAgdGhpcy53YXJuKGBVbnN1cHBvcnRlZCB0cmFuc2l0aW9uIGJldHdlZW4gXCIke09iamVjdC5rZXlzKHRyYWNrcyl9XCIgYW5kIFwiJHt0cmFja05hbWVzfVwiIFNvdXJjZUJ1ZmZlcnNgKTtcbiAgICAgIC8vIERvIG5vdCBhZGQgaW5jb21wYXRpYmxlIHRyYWNrICgnYXVkaW92aWRlbycgPC0+ICd2aWRlbycvJ2F1ZGlvJykuXG4gICAgICAvLyBBbGxvdyBmb2xsb3dpbmcgb25CdWZmZXJBcHBlbmRpbmcgaGFuZGxlIHRvIHRyaWdnZXIgQlVGRkVSX0FQUEVORF9FUlJPUi5cbiAgICAgIC8vIFRoaXMgd2lsbCBlaXRoZXIgYmUgcmVzb2x2ZWQgYnkgbGV2ZWwgc3dpdGNoIG9yIGNvdWxkIGJlIGhhbmRsZWQgd2l0aCByZWNvdmVyTWVkaWFFcnJvcigpLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cmFja05hbWVzLmZvckVhY2godHJhY2tOYW1lID0+IHtcbiAgICAgIHZhciBfdGhpcyR0cmFuc2ZlckRhdGEzLCBfdGhpcyR0cmFuc2ZlckRhdGEzJHQsIF90cmFja0NvZGVjO1xuICAgICAgY29uc3QgcGFyc2VkVHJhY2sgPSBkYXRhW3RyYWNrTmFtZV07XG4gICAgICBjb25zdCB7XG4gICAgICAgIGlkLFxuICAgICAgICBjb2RlYyxcbiAgICAgICAgbGV2ZWxDb2RlYyxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgc3VwcGxlbWVudGFsXG4gICAgICB9ID0gcGFyc2VkVHJhY2s7XG4gICAgICBsZXQgdHJhY2sgPSB0cmFja3NbdHJhY2tOYW1lXTtcbiAgICAgIGNvbnN0IHRyYW5zZmVycmVkVHJhY2sgPSAoX3RoaXMkdHJhbnNmZXJEYXRhMyA9IHRoaXMudHJhbnNmZXJEYXRhKSA9PSBudWxsID8gdm9pZCAwIDogKF90aGlzJHRyYW5zZmVyRGF0YTMkdCA9IF90aGlzJHRyYW5zZmVyRGF0YTMudHJhY2tzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkdHJhbnNmZXJEYXRhMyR0W3RyYWNrTmFtZV07XG4gICAgICBjb25zdCBzYlRyYWNrID0gdHJhbnNmZXJyZWRUcmFjayAhPSBudWxsICYmIHRyYW5zZmVycmVkVHJhY2suYnVmZmVyID8gdHJhbnNmZXJyZWRUcmFjayA6IHRyYWNrO1xuICAgICAgY29uc3Qgc2JDb2RlYyA9IChzYlRyYWNrID09IG51bGwgPyB2b2lkIDAgOiBzYlRyYWNrLnBlbmRpbmdDb2RlYykgfHwgKHNiVHJhY2sgPT0gbnVsbCA/IHZvaWQgMCA6IHNiVHJhY2suY29kZWMpO1xuICAgICAgY29uc3QgdHJhY2tMZXZlbENvZGVjID0gc2JUcmFjayA9PSBudWxsID8gdm9pZCAwIDogc2JUcmFjay5sZXZlbENvZGVjO1xuICAgICAgaWYgKCF0cmFjaykge1xuICAgICAgICB0cmFjayA9IHRyYWNrc1t0cmFja05hbWVdID0ge1xuICAgICAgICAgIGJ1ZmZlcjogdW5kZWZpbmVkLFxuICAgICAgICAgIGxpc3RlbmVyczogW10sXG4gICAgICAgICAgY29kZWMsXG4gICAgICAgICAgc3VwcGxlbWVudGFsLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBsZXZlbENvZGVjLFxuICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgIGlkXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICAvLyBjaGVjayBpZiBTb3VyY2VCdWZmZXIgY29kZWMgbmVlZHMgdG8gY2hhbmdlXG4gICAgICBjb25zdCBjdXJyZW50Q29kZWNGdWxsID0gcGlja01vc3RDb21wbGV0ZUNvZGVjTmFtZShzYkNvZGVjLCB0cmFja0xldmVsQ29kZWMpO1xuICAgICAgY29uc3QgY3VycmVudENvZGVjID0gY3VycmVudENvZGVjRnVsbCA9PSBudWxsID8gdm9pZCAwIDogY3VycmVudENvZGVjRnVsbC5yZXBsYWNlKFZJREVPX0NPREVDX1BST0ZJTEVfUkVQTEFDRSwgJyQxJyk7XG4gICAgICBsZXQgdHJhY2tDb2RlYyA9IHBpY2tNb3N0Q29tcGxldGVDb2RlY05hbWUoY29kZWMsIGxldmVsQ29kZWMpO1xuICAgICAgY29uc3QgbmV4dENvZGVjID0gKF90cmFja0NvZGVjID0gdHJhY2tDb2RlYykgPT0gbnVsbCA/IHZvaWQgMCA6IF90cmFja0NvZGVjLnJlcGxhY2UoVklERU9fQ09ERUNfUFJPRklMRV9SRVBMQUNFLCAnJDEnKTtcbiAgICAgIGlmICh0cmFja0NvZGVjICYmIGN1cnJlbnRDb2RlY0Z1bGwgJiYgY3VycmVudENvZGVjICE9PSBuZXh0Q29kZWMpIHtcbiAgICAgICAgaWYgKHRyYWNrTmFtZS5zbGljZSgwLCA1KSA9PT0gJ2F1ZGlvJykge1xuICAgICAgICAgIHRyYWNrQ29kZWMgPSBnZXRDb2RlY0NvbXBhdGlibGVOYW1lKHRyYWNrQ29kZWMsIHRoaXMuYXBwZW5kU291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZyhgc3dpdGNoaW5nIGNvZGVjICR7c2JDb2RlY30gdG8gJHt0cmFja0NvZGVjfWApO1xuICAgICAgICBpZiAodHJhY2tDb2RlYyAhPT0gKHRyYWNrLnBlbmRpbmdDb2RlYyB8fCB0cmFjay5jb2RlYykpIHtcbiAgICAgICAgICB0cmFjay5wZW5kaW5nQ29kZWMgPSB0cmFja0NvZGVjO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNrLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGFuZ2VUeXBlKHRyYWNrTmFtZSwgY29udGFpbmVyLCB0cmFja0NvZGVjKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAodGhpcy50cmFja3NSZWFkeSB8fCB0aGlzLnNvdXJjZUJ1ZmZlckNvdW50KSB7XG4gICAgICBkYXRhLnRyYWNrcyA9IHRoaXMuc291cmNlQnVmZmVyVHJhY2tzO1xuICAgIH1cblxuICAgIC8vIGlmIHNvdXJjZWJ1ZmZlcnMgYWxyZWFkeSBjcmVhdGVkLCBkbyBub3RoaW5nIC4uLlxuICAgIGlmICh0aGlzLnNvdXJjZUJ1ZmZlckNvdW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLm1lZGlhU291cmNlT3Blbk9yRW5kZWQpIHtcbiAgICAgIHRoaXMuY2hlY2tQZW5kaW5nVHJhY2tzKCk7XG4gICAgfVxuICB9XG4gIGdldCBzb3VyY2VCdWZmZXJUcmFja3MoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMudHJhY2tzKS5yZWR1Y2UoKGJhc2VUcmFja3MsIHR5cGUpID0+IHtcbiAgICAgIGNvbnN0IHRyYWNrID0gdGhpcy50cmFja3NbdHlwZV07XG4gICAgICBiYXNlVHJhY2tzW3R5cGVdID0ge1xuICAgICAgICBpZDogdHJhY2suaWQsXG4gICAgICAgIGNvbnRhaW5lcjogdHJhY2suY29udGFpbmVyLFxuICAgICAgICBjb2RlYzogdHJhY2suY29kZWMsXG4gICAgICAgIGxldmVsQ29kZWM6IHRyYWNrLmxldmVsQ29kZWNcbiAgICAgIH07XG4gICAgICByZXR1cm4gYmFzZVRyYWNrcztcbiAgICB9LCB7fSk7XG4gIH1cbiAgYXBwZW5kQ2hhbmdlVHlwZSh0eXBlLCBjb250YWluZXIsIGNvZGVjKSB7XG4gICAgY29uc3QgbWltZVR5cGUgPSBgJHtjb250YWluZXJ9O2NvZGVjcz0ke2NvZGVjfWA7XG4gICAgY29uc3Qgb3BlcmF0aW9uID0ge1xuICAgICAgbGFiZWw6IGBjaGFuZ2UtdHlwZT0ke21pbWVUeXBlfWAsXG4gICAgICBleGVjdXRlOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRyYWNrID0gdGhpcy50cmFja3NbdHlwZV07XG4gICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgIGNvbnN0IHNiID0gdHJhY2suYnVmZmVyO1xuICAgICAgICAgIGlmIChzYiAhPSBudWxsICYmIHNiLmNoYW5nZVR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKGBjaGFuZ2luZyAke3R5cGV9IHNvdXJjZUJ1ZmZlciB0eXBlIHRvICR7bWltZVR5cGV9YCk7XG4gICAgICAgICAgICBzYi5jaGFuZ2VUeXBlKG1pbWVUeXBlKTtcbiAgICAgICAgICAgIHRyYWNrLmNvZGVjID0gY29kZWM7XG4gICAgICAgICAgICB0cmFjay5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2hpZnRBbmRFeGVjdXRlTmV4dCh0eXBlKTtcbiAgICAgIH0sXG4gICAgICBvblN0YXJ0OiAoKSA9PiB7fSxcbiAgICAgIG9uQ29tcGxldGU6ICgpID0+IHt9LFxuICAgICAgb25FcnJvcjogZXJyb3IgPT4ge1xuICAgICAgICB0aGlzLndhcm4oYEZhaWxlZCB0byBjaGFuZ2UgJHt0eXBlfSBTb3VyY2VCdWZmZXIgdHlwZWAsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYXBwZW5kKG9wZXJhdGlvbiwgdHlwZSwgdGhpcy5pc1BlbmRpbmcodGhpcy50cmFja3NbdHlwZV0pKTtcbiAgfVxuICBibG9ja0F1ZGlvKHBhcnRPckZyYWcpIHtcbiAgICB2YXIgX3RoaXMkZnJhZ21lbnRUcmFja2VyO1xuICAgIGNvbnN0IHBTdGFydCA9IHBhcnRPckZyYWcuc3RhcnQ7XG4gICAgY29uc3QgcFRpbWUgPSBwU3RhcnQgKyBwYXJ0T3JGcmFnLmR1cmF0aW9uICogMC4wNTtcbiAgICBjb25zdCBhdEdhcCA9ICgoX3RoaXMkZnJhZ21lbnRUcmFja2VyID0gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0QXBwZW5kZWRGcmFnKHBTdGFydCwgUGxheWxpc3RMZXZlbFR5cGUuTUFJTikpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRmcmFnbWVudFRyYWNrZXIuZ2FwKSA9PT0gdHJ1ZTtcbiAgICBpZiAoYXRHYXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb3AgPSB7XG4gICAgICBsYWJlbDogJ2Jsb2NrLWF1ZGlvJyxcbiAgICAgIGV4ZWN1dGU6ICgpID0+IHtcbiAgICAgICAgdmFyIF90aGlzJGZyYWdtZW50VHJhY2tlcjI7XG4gICAgICAgIGNvbnN0IHZpZGVvVHJhY2sgPSB0aGlzLnRyYWNrcy52aWRlbztcbiAgICAgICAgaWYgKHRoaXMubGFzdFZpZGVvQXBwZW5kRW5kID4gcFRpbWUgfHwgdmlkZW9UcmFjayAhPSBudWxsICYmIHZpZGVvVHJhY2suYnVmZmVyICYmIEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKHZpZGVvVHJhY2suYnVmZmVyLCBwVGltZSkgfHwgKChfdGhpcyRmcmFnbWVudFRyYWNrZXIyID0gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0QXBwZW5kZWRGcmFnKHBUaW1lLCBQbGF5bGlzdExldmVsVHlwZS5NQUlOKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGZyYWdtZW50VHJhY2tlcjIuZ2FwKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuYmxvY2tlZEF1ZGlvQXBwZW5kID0gbnVsbDtcbiAgICAgICAgICB0aGlzLnNoaWZ0QW5kRXhlY3V0ZU5leHQoJ2F1ZGlvJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvblN0YXJ0OiAoKSA9PiB7fSxcbiAgICAgIG9uQ29tcGxldGU6ICgpID0+IHt9LFxuICAgICAgb25FcnJvcjogZXJyb3IgPT4ge1xuICAgICAgICB0aGlzLndhcm4oJ0Vycm9yIGV4ZWN1dGluZyBibG9jay1hdWRpbyBvcGVyYXRpb24nLCBlcnJvcik7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmJsb2NrZWRBdWRpb0FwcGVuZCA9IHtcbiAgICAgIG9wLFxuICAgICAgZnJhZzogcGFydE9yRnJhZ1xuICAgIH07XG4gICAgdGhpcy5hcHBlbmQob3AsICdhdWRpbycsIHRydWUpO1xuICB9XG4gIHVuYmxvY2tBdWRpbygpIHtcbiAgICBjb25zdCB7XG4gICAgICBibG9ja2VkQXVkaW9BcHBlbmQsXG4gICAgICBvcGVyYXRpb25RdWV1ZVxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChibG9ja2VkQXVkaW9BcHBlbmQgJiYgb3BlcmF0aW9uUXVldWUpIHtcbiAgICAgIHRoaXMuYmxvY2tlZEF1ZGlvQXBwZW5kID0gbnVsbDtcbiAgICAgIG9wZXJhdGlvblF1ZXVlLnVuYmxvY2tBdWRpbyhibG9ja2VkQXVkaW9BcHBlbmQub3ApO1xuICAgIH1cbiAgfVxuICBvbkJ1ZmZlckFwcGVuZGluZyhldmVudCwgZXZlbnREYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHJhY2tzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YSxcbiAgICAgIHR5cGUsXG4gICAgICBwYXJlbnQsXG4gICAgICBmcmFnLFxuICAgICAgcGFydCxcbiAgICAgIGNodW5rTWV0YSxcbiAgICAgIG9mZnNldFxuICAgIH0gPSBldmVudERhdGE7XG4gICAgY29uc3QgY2h1bmtTdGF0cyA9IGNodW5rTWV0YS5idWZmZXJpbmdbdHlwZV07XG4gICAgY29uc3Qge1xuICAgICAgc24sXG4gICAgICBjY1xuICAgIH0gPSBmcmFnO1xuICAgIGNvbnN0IGJ1ZmZlckFwcGVuZGluZ1N0YXJ0ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjaHVua1N0YXRzLnN0YXJ0ID0gYnVmZmVyQXBwZW5kaW5nU3RhcnQ7XG4gICAgY29uc3QgZnJhZ0J1ZmZlcmluZyA9IGZyYWcuc3RhdHMuYnVmZmVyaW5nO1xuICAgIGNvbnN0IHBhcnRCdWZmZXJpbmcgPSBwYXJ0ID8gcGFydC5zdGF0cy5idWZmZXJpbmcgOiBudWxsO1xuICAgIGlmIChmcmFnQnVmZmVyaW5nLnN0YXJ0ID09PSAwKSB7XG4gICAgICBmcmFnQnVmZmVyaW5nLnN0YXJ0ID0gYnVmZmVyQXBwZW5kaW5nU3RhcnQ7XG4gICAgfVxuICAgIGlmIChwYXJ0QnVmZmVyaW5nICYmIHBhcnRCdWZmZXJpbmcuc3RhcnQgPT09IDApIHtcbiAgICAgIHBhcnRCdWZmZXJpbmcuc3RhcnQgPSBidWZmZXJBcHBlbmRpbmdTdGFydDtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBPbmx5IHVwZGF0ZSB0aW1lc3RhbXBPZmZzZXQgd2hlbiBhdWRpby9tcGVnIGZyYWdtZW50IG9yIHBhcnQgaXMgbm90IGNvbnRpZ3VvdXMgd2l0aCBwcmV2aW91c2x5IGFwcGVuZGVkXG4gICAgLy8gQWRqdXN0aW5nIGBTb3VyY2VCdWZmZXIudGltZXN0YW1wT2Zmc2V0YCAoZGVzaXJlZCBwb2ludCBpbiB0aGUgdGltZWxpbmUgd2hlcmUgdGhlIG5leHQgZnJhbWVzIHNob3VsZCBiZSBhcHBlbmRlZClcbiAgICAvLyBpbiBDaHJvbWUgYnJvd3NlciB3aGVuIHdlIGRldGVjdCBNUEVHIGF1ZGlvIGNvbnRhaW5lciBhbmQgdGltZSBkZWx0YSBiZXR3ZWVuIGxldmVsIFBUUyBhbmQgYFNvdXJjZUJ1ZmZlci50aW1lc3RhbXBPZmZzZXRgXG4gICAgLy8gaXMgZ3JlYXRlciB0aGFuIDEwMG1zICh0aGlzIGlzIGVub3VnaCB0byBoYW5kbGUgc2VlayBmb3IgVk9EIG9yIGxldmVsIGNoYW5nZSBmb3IgTElWRSB2aWRlb3MpLlxuICAgIC8vIE1vcmUgaW5mbyBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvMzMyI2lzc3VlY29tbWVudC0yNTc5ODY0ODZcbiAgICBjb25zdCBhdWRpb1RyYWNrID0gdHJhY2tzLmF1ZGlvO1xuICAgIGxldCBjaGVja1RpbWVzdGFtcE9mZnNldCA9IGZhbHNlO1xuICAgIGlmICh0eXBlID09PSAnYXVkaW8nICYmIChhdWRpb1RyYWNrID09IG51bGwgPyB2b2lkIDAgOiBhdWRpb1RyYWNrLmNvbnRhaW5lcikgPT09ICdhdWRpby9tcGVnJykge1xuICAgICAgY2hlY2tUaW1lc3RhbXBPZmZzZXQgPSAhdGhpcy5sYXN0TXBlZ0F1ZGlvQ2h1bmsgfHwgY2h1bmtNZXRhLmlkID09PSAxIHx8IHRoaXMubGFzdE1wZWdBdWRpb0NodW5rLnNuICE9PSBjaHVua01ldGEuc247XG4gICAgICB0aGlzLmxhc3RNcGVnQXVkaW9DaHVuayA9IGNodW5rTWV0YTtcbiAgICB9XG5cbiAgICAvLyBCbG9jayBhdWRpbyBhcHBlbmQgdW50aWwgb3ZlcmxhcHBpbmcgdmlkZW8gYXBwZW5kXG4gICAgY29uc3QgdmlkZW9UcmFjayA9IHRyYWNrcy52aWRlbztcbiAgICBjb25zdCB2aWRlb1NiID0gdmlkZW9UcmFjayA9PSBudWxsID8gdm9pZCAwIDogdmlkZW9UcmFjay5idWZmZXI7XG4gICAgaWYgKHZpZGVvU2IgJiYgc24gIT09ICdpbml0U2VnbWVudCcpIHtcbiAgICAgIGNvbnN0IHBhcnRPckZyYWcgPSBwYXJ0IHx8IGZyYWc7XG4gICAgICBjb25zdCBibG9ja2VkQXVkaW9BcHBlbmQgPSB0aGlzLmJsb2NrZWRBdWRpb0FwcGVuZDtcbiAgICAgIGlmICh0eXBlID09PSAnYXVkaW8nICYmIHBhcmVudCAhPT0gJ21haW4nICYmICF0aGlzLmJsb2NrZWRBdWRpb0FwcGVuZCkge1xuICAgICAgICBjb25zdCBwU3RhcnQgPSBwYXJ0T3JGcmFnLnN0YXJ0O1xuICAgICAgICBjb25zdCBwVGltZSA9IHBTdGFydCArIHBhcnRPckZyYWcuZHVyYXRpb24gKiAwLjA1O1xuICAgICAgICBjb25zdCB2YnVmZmVyZWQgPSB2aWRlb1NiLmJ1ZmZlcmVkO1xuICAgICAgICBjb25zdCB2YXBwZW5kaW5nID0gdGhpcy5jdXJyZW50T3AoJ3ZpZGVvJyk7XG4gICAgICAgIGlmICghdmJ1ZmZlcmVkLmxlbmd0aCAmJiAhdmFwcGVuZGluZykge1xuICAgICAgICAgIC8vIHdhaXQgZm9yIHZpZGVvIGJlZm9yZSBhcHBlbmRpbmcgYXVkaW9cbiAgICAgICAgICB0aGlzLmJsb2NrQXVkaW8ocGFydE9yRnJhZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXZhcHBlbmRpbmcgJiYgIUJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKHZpZGVvU2IsIHBUaW1lKSAmJiB0aGlzLmxhc3RWaWRlb0FwcGVuZEVuZCA8IHBUaW1lKSB7XG4gICAgICAgICAgLy8gYXVkaW8gaXMgYWhlYWQgb2YgdmlkZW9cbiAgICAgICAgICB0aGlzLmJsb2NrQXVkaW8ocGFydE9yRnJhZyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICBjb25zdCB2aWRlb0FwcGVuZEVuZCA9IHBhcnRPckZyYWcuZW5kO1xuICAgICAgICBpZiAoYmxvY2tlZEF1ZGlvQXBwZW5kKSB7XG4gICAgICAgICAgY29uc3QgYXVkaW9TdGFydCA9IGJsb2NrZWRBdWRpb0FwcGVuZC5mcmFnLnN0YXJ0O1xuICAgICAgICAgIGlmICh2aWRlb0FwcGVuZEVuZCA+IGF1ZGlvU3RhcnQgfHwgdmlkZW9BcHBlbmRFbmQgPCB0aGlzLmxhc3RWaWRlb0FwcGVuZEVuZCB8fCBCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZCh2aWRlb1NiLCBhdWRpb1N0YXJ0KSkge1xuICAgICAgICAgICAgdGhpcy51bmJsb2NrQXVkaW8oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0VmlkZW9BcHBlbmRFbmQgPSB2aWRlb0FwcGVuZEVuZDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZnJhZ1N0YXJ0ID0gKHBhcnQgfHwgZnJhZykuc3RhcnQ7XG4gICAgY29uc3Qgb3BlcmF0aW9uID0ge1xuICAgICAgbGFiZWw6IGBhcHBlbmQtJHt0eXBlfWAsXG4gICAgICBleGVjdXRlOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGhpcyR0cmFja3MkdHlwZTI7XG4gICAgICAgIGNodW5rU3RhdHMuZXhlY3V0ZVN0YXJ0ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgY29uc3Qgc2IgPSAoX3RoaXMkdHJhY2tzJHR5cGUyID0gdGhpcy50cmFja3NbdHlwZV0pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyR0cmFja3MkdHlwZTIuYnVmZmVyO1xuICAgICAgICBpZiAoc2IpIHtcbiAgICAgICAgICBpZiAoY2hlY2tUaW1lc3RhbXBPZmZzZXQpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVGltZXN0YW1wT2Zmc2V0KHNiLCBmcmFnU3RhcnQsIDAuMSwgdHlwZSwgc24sIGNjKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIGlzRmluaXRlTnVtYmVyKG9mZnNldCkpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVGltZXN0YW1wT2Zmc2V0KHNiLCBvZmZzZXQsIDAuMDAwMDAxLCB0eXBlLCBzbiwgY2MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwcGVuZEV4ZWN1dG9yKGRhdGEsIHR5cGUpO1xuICAgICAgfSxcbiAgICAgIG9uU3RhcnQ6ICgpID0+IHtcbiAgICAgICAgLy8gbG9nZ2VyLmRlYnVnKGBbYnVmZmVyLWNvbnRyb2xsZXJdOiAke3R5cGV9IFNvdXJjZUJ1ZmZlciB1cGRhdGVzdGFydGApO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgLy8gbG9nZ2VyLmRlYnVnKGBbYnVmZmVyLWNvbnRyb2xsZXJdOiAke3R5cGV9IFNvdXJjZUJ1ZmZlciB1cGRhdGVlbmRgKTtcbiAgICAgICAgY29uc3QgZW5kID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgY2h1bmtTdGF0cy5leGVjdXRlRW5kID0gY2h1bmtTdGF0cy5lbmQgPSBlbmQ7XG4gICAgICAgIGlmIChmcmFnQnVmZmVyaW5nLmZpcnN0ID09PSAwKSB7XG4gICAgICAgICAgZnJhZ0J1ZmZlcmluZy5maXJzdCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydEJ1ZmZlcmluZyAmJiBwYXJ0QnVmZmVyaW5nLmZpcnN0ID09PSAwKSB7XG4gICAgICAgICAgcGFydEJ1ZmZlcmluZy5maXJzdCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aW1lUmFuZ2VzID0ge307XG4gICAgICAgIHRoaXMuc291cmNlQnVmZmVycy5mb3JFYWNoKChbdHlwZSwgc2JdKSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgIHRpbWVSYW5nZXNbdHlwZV0gPSBCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQoc2IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYXBwZW5kRXJyb3JzW3R5cGVdID0gMDtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdhdWRpbycgfHwgdHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgIHRoaXMuYXBwZW5kRXJyb3JzLmF1ZGlvdmlkZW8gPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYXBwZW5kRXJyb3JzLmF1ZGlvID0gMDtcbiAgICAgICAgICB0aGlzLmFwcGVuZEVycm9ycy52aWRlbyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0FQUEVOREVELCB7XG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBmcmFnLFxuICAgICAgICAgIHBhcnQsXG4gICAgICAgICAgY2h1bmtNZXRhLFxuICAgICAgICAgIHBhcmVudDogZnJhZy50eXBlLFxuICAgICAgICAgIHRpbWVSYW5nZXNcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgb25FcnJvcjogZXJyb3IgPT4ge1xuICAgICAgICB2YXIgX3RoaXMkbWVkaWE7XG4gICAgICAgIC8vIGluIGNhc2UgYW55IGVycm9yIG9jY3VyZWQgd2hpbGUgYXBwZW5kaW5nLCBwdXQgYmFjayBzZWdtZW50IGluIHNlZ21lbnRzIHRhYmxlXG4gICAgICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgcGFyZW50OiBmcmFnLnR5cGUsXG4gICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRfRVJST1IsXG4gICAgICAgICAgc291cmNlQnVmZmVyTmFtZTogdHlwZSxcbiAgICAgICAgICBmcmFnLFxuICAgICAgICAgIHBhcnQsXG4gICAgICAgICAgY2h1bmtNZXRhLFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIGVycjogZXJyb3IsXG4gICAgICAgICAgZmF0YWw6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1lZGlhRXJyb3IgPSAoX3RoaXMkbWVkaWEgPSB0aGlzLm1lZGlhKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbWVkaWEuZXJyb3I7XG4gICAgICAgIGlmIChlcnJvci5jb2RlID09PSBET01FeGNlcHRpb24uUVVPVEFfRVhDRUVERURfRVJSIHx8IGVycm9yLm5hbWUgPT0gJ1F1b3RhRXhjZWVkZWRFcnJvcicgfHwgYHF1b3RhYCBpbiBlcnJvcikge1xuICAgICAgICAgIC8vIFF1b3RhRXhjZWVkZWRFcnJvcjogaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNxdW90YWV4Y2VlZGVkZXJyb3JcbiAgICAgICAgICAvLyBsZXQncyBzdG9wIGFwcGVuZGluZyBhbnkgc2VnbWVudHMsIGFuZCByZXBvcnQgQlVGRkVSX0ZVTExfRVJST1IgZXJyb3JcbiAgICAgICAgICBldmVudC5kZXRhaWxzID0gRXJyb3JEZXRhaWxzLkJVRkZFUl9GVUxMX0VSUk9SO1xuICAgICAgICB9IGVsc2UgaWYgKGVycm9yLmNvZGUgPT09IERPTUV4Y2VwdGlvbi5JTlZBTElEX1NUQVRFX0VSUiAmJiB0aGlzLm1lZGlhU291cmNlT3Blbk9yRW5kZWQgJiYgIW1lZGlhRXJyb3IpIHtcbiAgICAgICAgICAvLyBBbGxvdyByZXRyeSBmb3IgXCJGYWlsZWQgdG8gZXhlY3V0ZSAnYXBwZW5kQnVmZmVyJyBvbiAnU291cmNlQnVmZmVyJzogVGhpcyBTb3VyY2VCdWZmZXIgaXMgc3RpbGwgcHJvY2Vzc2luZ1wiIGVycm9yc1xuICAgICAgICAgIGV2ZW50LmVycm9yQWN0aW9uID0gY3JlYXRlRG9Ob3RoaW5nRXJyb3JBY3Rpb24odHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gVFJBQ0tfUkVNT1ZFRF9FUlJPUl9OQU1FICYmIHRoaXMuc291cmNlQnVmZmVyQ291bnQgPT09IDApIHtcbiAgICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHNvdXJjZUJ1ZmZlcnMgd2VyZSByZW1vdmVkIChtZWRpYSBpcyBkZXRhY2hlZCBhbmQgYXBwZW5kIHdhcyBub3QgYWJvcnRlZClcbiAgICAgICAgICBldmVudC5lcnJvckFjdGlvbiA9IGNyZWF0ZURvTm90aGluZ0Vycm9yQWN0aW9uKHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGFwcGVuZEVycm9yQ291bnQgPSArK3RoaXMuYXBwZW5kRXJyb3JzW3R5cGVdO1xuICAgICAgICAgIC8qIHdpdGggVUhEIGNvbnRlbnQsIHdlIGNvdWxkIGdldCBsb29wIG9mIHF1b3RhIGV4Y2VlZGVkIGVycm9yIHVudGlsXG4gICAgICAgICAgICBicm93c2VyIGlzIGFibGUgdG8gZXZpY3Qgc29tZSBkYXRhIGZyb20gc291cmNlYnVmZmVyLiBSZXRyeWluZyBjYW4gaGVscCByZWNvdmVyLlxuICAgICAgICAgICovXG4gICAgICAgICAgdGhpcy53YXJuKGBGYWlsZWQgJHthcHBlbmRFcnJvckNvdW50fS8ke3RoaXMuaGxzLmNvbmZpZy5hcHBlbmRFcnJvck1heFJldHJ5fSB0aW1lcyB0byBhcHBlbmQgc2VnbWVudCBpbiBcIiR7dHlwZX1cIiBzb3VyY2VCdWZmZXIgKCR7bWVkaWFFcnJvciA/IG1lZGlhRXJyb3IgOiAnbm8gbWVkaWEgZXJyb3InfSlgKTtcbiAgICAgICAgICBpZiAoYXBwZW5kRXJyb3JDb3VudCA+PSB0aGlzLmhscy5jb25maWcuYXBwZW5kRXJyb3JNYXhSZXRyeSB8fCAhIW1lZGlhRXJyb3IpIHtcbiAgICAgICAgICAgIGV2ZW50LmZhdGFsID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIGV2ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYXBwZW5kKG9wZXJhdGlvbiwgdHlwZSwgdGhpcy5pc1BlbmRpbmcodGhpcy50cmFja3NbdHlwZV0pKTtcbiAgfVxuICBnZXRGbHVzaE9wKHR5cGUsIHN0YXJ0LCBlbmQpIHtcbiAgICB0aGlzLmxvZyhgcXVldWluZyBcIiR7dHlwZX1cIiByZW1vdmUgJHtzdGFydH0tJHtlbmR9YCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiAncmVtb3ZlJyxcbiAgICAgIGV4ZWN1dGU6ICgpID0+IHtcbiAgICAgICAgdGhpcy5yZW1vdmVFeGVjdXRvcih0eXBlLCBzdGFydCwgZW5kKTtcbiAgICAgIH0sXG4gICAgICBvblN0YXJ0OiAoKSA9PiB7XG4gICAgICAgIC8vIGxvZ2dlci5kZWJ1ZyhgW2J1ZmZlci1jb250cm9sbGVyXTogU3RhcnRlZCBmbHVzaGluZyAke2RhdGEuc3RhcnRPZmZzZXR9IC0+ICR7ZGF0YS5lbmRPZmZzZXR9IGZvciAke3R5cGV9IFNvdXJjZSBCdWZmZXJgKTtcbiAgICAgIH0sXG4gICAgICBvbkNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgIC8vIGxvZ2dlci5kZWJ1ZyhgW2J1ZmZlci1jb250cm9sbGVyXTogRmluaXNoZWQgZmx1c2hpbmcgJHtkYXRhLnN0YXJ0T2Zmc2V0fSAtPiAke2RhdGEuZW5kT2Zmc2V0fSBmb3IgJHt0eXBlfSBTb3VyY2UgQnVmZmVyYCk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9GTFVTSEVELCB7XG4gICAgICAgICAgdHlwZVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBvbkVycm9yOiBlcnJvciA9PiB7XG4gICAgICAgIHRoaXMud2FybihgRmFpbGVkIHRvIHJlbW92ZSAke3N0YXJ0fS0ke2VuZH0gZnJvbSBcIiR7dHlwZX1cIiBTb3VyY2VCdWZmZXJgLCBlcnJvcik7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBvbkJ1ZmZlckZsdXNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZSxcbiAgICAgIHN0YXJ0T2Zmc2V0LFxuICAgICAgZW5kT2Zmc2V0XG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIHRoaXMuYXBwZW5kKHRoaXMuZ2V0Rmx1c2hPcCh0eXBlLCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0KSwgdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc291cmNlQnVmZmVycy5mb3JFYWNoKChbdHlwZV0pID0+IHtcbiAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICB0aGlzLmFwcGVuZCh0aGlzLmdldEZsdXNoT3AodHlwZSwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCksIHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgb25GcmFnUGFyc2VkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIHBhcnRcbiAgICB9ID0gZGF0YTtcbiAgICBjb25zdCBidWZmZXJzQXBwZW5kZWRUbyA9IFtdO1xuICAgIGNvbnN0IGVsZW1lbnRhcnlTdHJlYW1zID0gcGFydCA/IHBhcnQuZWxlbWVudGFyeVN0cmVhbXMgOiBmcmFnLmVsZW1lbnRhcnlTdHJlYW1zO1xuICAgIGlmIChlbGVtZW50YXJ5U3RyZWFtc1tFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU9WSURFT10pIHtcbiAgICAgIGJ1ZmZlcnNBcHBlbmRlZFRvLnB1c2goJ2F1ZGlvdmlkZW8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVsZW1lbnRhcnlTdHJlYW1zW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJT10pIHtcbiAgICAgICAgYnVmZmVyc0FwcGVuZGVkVG8ucHVzaCgnYXVkaW8nKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50YXJ5U3RyZWFtc1tFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU9dKSB7XG4gICAgICAgIGJ1ZmZlcnNBcHBlbmRlZFRvLnB1c2goJ3ZpZGVvJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG9uVW5ibG9ja2VkID0gKCkgPT4ge1xuICAgICAgY29uc3Qgbm93ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGZyYWcuc3RhdHMuYnVmZmVyaW5nLmVuZCA9IG5vdztcbiAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgIHBhcnQuc3RhdHMuYnVmZmVyaW5nLmVuZCA9IG5vdztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXRzID0gcGFydCA/IHBhcnQuc3RhdHMgOiBmcmFnLnN0YXRzO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRlJBR19CVUZGRVJFRCwge1xuICAgICAgICBmcmFnLFxuICAgICAgICBwYXJ0LFxuICAgICAgICBzdGF0cyxcbiAgICAgICAgaWQ6IGZyYWcudHlwZVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBpZiAoYnVmZmVyc0FwcGVuZGVkVG8ubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLndhcm4oYEZyYWdtZW50cyBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIEVsZW1lbnRhcnlTdHJlYW1UeXBlIHNldC4gdHlwZTogJHtmcmFnLnR5cGV9IGxldmVsOiAke2ZyYWcubGV2ZWx9IHNuOiAke2ZyYWcuc259YCk7XG4gICAgfVxuICAgIHRoaXMuYmxvY2tCdWZmZXJzKG9uVW5ibG9ja2VkLCBidWZmZXJzQXBwZW5kZWRUbykuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgdGhpcy53YXJuKGBGcmFnbWVudCBidWZmZXJlZCBjYWxsYmFjayAke2Vycm9yfWApO1xuICAgICAgdGhpcy5zdGVwT3BlcmF0aW9uUXVldWUodGhpcy5zb3VyY2VCdWZmZXJUeXBlcyk7XG4gICAgfSk7XG4gIH1cbiAgb25GcmFnQ2hhbmdlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMudHJpbUJ1ZmZlcnMoKTtcbiAgfVxuICBnZXQgYnVmZmVyZWRUb0VuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2VCdWZmZXJDb3VudCA+IDAgJiYgIXRoaXMuc291cmNlQnVmZmVycy5zb21lKChbdHlwZV0pID0+IHtcbiAgICAgIHZhciBfdGhpcyR0cmFja3MkdHlwZTMsIF90aGlzJHRyYWNrcyR0eXBlNDtcbiAgICAgIHJldHVybiB0eXBlICYmICghKChfdGhpcyR0cmFja3MkdHlwZTMgPSB0aGlzLnRyYWNrc1t0eXBlXSkgIT0gbnVsbCAmJiBfdGhpcyR0cmFja3MkdHlwZTMuZW5kZWQpIHx8ICgoX3RoaXMkdHJhY2tzJHR5cGU0ID0gdGhpcy50cmFja3NbdHlwZV0pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyR0cmFja3MkdHlwZTQuZW5kaW5nKSk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBvbiBCVUZGRVJfRU9TIG1hcmsgbWF0Y2hpbmcgc291cmNlYnVmZmVyKHMpIGFzIFwiZW5kaW5nXCIgYW5kIFwiZW5kZWRcIiBhbmQgcXVldWUgZW5kT2ZTdHJlYW0gYWZ0ZXIgcmVtYWluaW5nIG9wZXJhdGlvbnMocylcbiAgLy8gYW4gdW5kZWZpbmVkIGRhdGEudHlwZSB3aWxsIG1hcmsgYWxsIGJ1ZmZlcnMgYXMgRU9TLlxuICBvbkJ1ZmZlckVvcyhldmVudCwgZGF0YSkge1xuICAgIHZhciBfdGhpcyRvdmVycmlkZXM7XG4gICAgdGhpcy5zb3VyY2VCdWZmZXJzLmZvckVhY2goKFt0eXBlXSkgPT4ge1xuICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgY29uc3QgdHJhY2sgPSB0aGlzLnRyYWNrc1t0eXBlXTtcbiAgICAgICAgaWYgKCFkYXRhLnR5cGUgfHwgZGF0YS50eXBlID09PSB0eXBlKSB7XG4gICAgICAgICAgdHJhY2suZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoIXRyYWNrLmVuZGVkKSB7XG4gICAgICAgICAgICB0cmFjay5lbmRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmxvZyhgJHt0eXBlfSBidWZmZXIgcmVhY2hlZCBFT1NgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBhbGxvd0VuZE9mU3RyZWFtID0gKChfdGhpcyRvdmVycmlkZXMgPSB0aGlzLm92ZXJyaWRlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG92ZXJyaWRlcy5lbmRPZlN0cmVhbSkgIT09IGZhbHNlO1xuICAgIGNvbnN0IGFsbFRyYWNrc0VuZGluZyA9IHRoaXMuc291cmNlQnVmZmVyQ291bnQgPiAwICYmICF0aGlzLnNvdXJjZUJ1ZmZlcnMuc29tZSgoW3R5cGVdKSA9PiB7XG4gICAgICB2YXIgX3RoaXMkdHJhY2tzJHR5cGU1O1xuICAgICAgcmV0dXJuIHR5cGUgJiYgISgoX3RoaXMkdHJhY2tzJHR5cGU1ID0gdGhpcy50cmFja3NbdHlwZV0pICE9IG51bGwgJiYgX3RoaXMkdHJhY2tzJHR5cGU1LmVuZGVkKTtcbiAgICB9KTtcbiAgICBpZiAoYWxsVHJhY2tzRW5kaW5nKSB7XG4gICAgICBpZiAoYWxsb3dFbmRPZlN0cmVhbSkge1xuICAgICAgICB0aGlzLmxvZyhgUXVldWVpbmcgRU9TYCk7XG4gICAgICAgIHRoaXMuYmxvY2tVbnRpbE9wZW4oKCkgPT4ge1xuICAgICAgICAgIHRoaXMudHJhY2tzRW5kZWQoKTtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBtZWRpYVNvdXJjZVxuICAgICAgICAgIH0gPSB0aGlzO1xuICAgICAgICAgIGlmICghbWVkaWFTb3VyY2UgfHwgbWVkaWFTb3VyY2UucmVhZHlTdGF0ZSAhPT0gJ29wZW4nKSB7XG4gICAgICAgICAgICBpZiAobWVkaWFTb3VyY2UpIHtcbiAgICAgICAgICAgICAgdGhpcy5sb2coYENvdWxkIG5vdCBjYWxsIG1lZGlhU291cmNlLmVuZE9mU3RyZWFtKCkuIG1lZGlhU291cmNlLnJlYWR5U3RhdGU6ICR7bWVkaWFTb3VyY2UucmVhZHlTdGF0ZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5sb2coYENhbGxpbmcgbWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oKWApO1xuICAgICAgICAgIC8vIEFsbG93IHRoaXMgdG8gdGhyb3cgYW5kIGJlIGNhdWdodCBieSB0aGUgZW5xdWV1ZWluZyBmdW5jdGlvblxuICAgICAgICAgIG1lZGlhU291cmNlLmVuZE9mU3RyZWFtKCk7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSRURfVE9fRU5ELCB1bmRlZmluZWQpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudHJhY2tzRW5kZWQoKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSRURfVE9fRU5ELCB1bmRlZmluZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0cmFja3NFbmRlZCgpIHtcbiAgICB0aGlzLnNvdXJjZUJ1ZmZlcnMuZm9yRWFjaCgoW3R5cGVdKSA9PiB7XG4gICAgICBpZiAodHlwZSAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCB0cmFjayA9IHRoaXMudHJhY2tzW3R5cGVdO1xuICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICB0cmFjay5lbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG9uTGV2ZWxVcGRhdGVkKGV2ZW50LCB7XG4gICAgZGV0YWlsc1xuICB9KSB7XG4gICAgaWYgKCFkZXRhaWxzLmZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgICB0aGlzLnVwZGF0ZUR1cmF0aW9uKCk7XG4gIH1cbiAgdXBkYXRlRHVyYXRpb24oKSB7XG4gICAgdGhpcy5ibG9ja1VudGlsT3BlbigoKSA9PiB7XG4gICAgICBjb25zdCBkdXJhdGlvbkFuZFJhbmdlID0gdGhpcy5nZXREdXJhdGlvbkFuZFJhbmdlKCk7XG4gICAgICBpZiAoIWR1cmF0aW9uQW5kUmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVNZWRpYVNvdXJjZShkdXJhdGlvbkFuZFJhbmdlKTtcbiAgICB9KTtcbiAgfVxuICBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKGRhdGEuZGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRfRVJST1IgJiYgZGF0YS5mcmFnKSB7XG4gICAgICB2YXIgX2RhdGEkZXJyb3JBY3Rpb247XG4gICAgICBjb25zdCBuZXh0QXV0b0xldmVsID0gKF9kYXRhJGVycm9yQWN0aW9uID0gZGF0YS5lcnJvckFjdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhJGVycm9yQWN0aW9uLm5leHRBdXRvTGV2ZWw7XG4gICAgICBpZiAoaXNGaW5pdGVOdW1iZXIobmV4dEF1dG9MZXZlbCkgJiYgbmV4dEF1dG9MZXZlbCAhPT0gZGF0YS5mcmFnLmxldmVsKSB7XG4gICAgICAgIHRoaXMucmVzZXRBcHBlbmRFcnJvcnMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVzZXRBcHBlbmRFcnJvcnMoKSB7XG4gICAgdGhpcy5hcHBlbmRFcnJvcnMgPSB7XG4gICAgICBhdWRpbzogMCxcbiAgICAgIHZpZGVvOiAwLFxuICAgICAgYXVkaW92aWRlbzogMFxuICAgIH07XG4gIH1cbiAgdHJpbUJ1ZmZlcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzLFxuICAgICAgZGV0YWlscyxcbiAgICAgIG1lZGlhXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFtZWRpYSB8fCBkZXRhaWxzID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5zb3VyY2VCdWZmZXJDb3VudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjb25maWcgPSBobHMuY29uZmlnO1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgY29uc3QgdGFyZ2V0RHVyYXRpb24gPSBkZXRhaWxzLmxldmVsVGFyZ2V0RHVyYXRpb247XG5cbiAgICAvLyBTdXBwb3J0IGZvciBkZXByZWNhdGVkIGxpdmVCYWNrQnVmZmVyTGVuZ3RoXG4gICAgY29uc3QgYmFja0J1ZmZlckxlbmd0aCA9IGRldGFpbHMubGl2ZSAmJiBjb25maWcubGl2ZUJhY2tCdWZmZXJMZW5ndGggIT09IG51bGwgPyBjb25maWcubGl2ZUJhY2tCdWZmZXJMZW5ndGggOiBjb25maWcuYmFja0J1ZmZlckxlbmd0aDtcbiAgICBpZiAoaXNGaW5pdGVOdW1iZXIoYmFja0J1ZmZlckxlbmd0aCkgJiYgYmFja0J1ZmZlckxlbmd0aCA+PSAwKSB7XG4gICAgICBjb25zdCBtYXhCYWNrQnVmZmVyTGVuZ3RoID0gTWF0aC5tYXgoYmFja0J1ZmZlckxlbmd0aCwgdGFyZ2V0RHVyYXRpb24pO1xuICAgICAgY29uc3QgdGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uID0gTWF0aC5mbG9vcihjdXJyZW50VGltZSAvIHRhcmdldER1cmF0aW9uKSAqIHRhcmdldER1cmF0aW9uIC0gbWF4QmFja0J1ZmZlckxlbmd0aDtcbiAgICAgIHRoaXMuZmx1c2hCYWNrQnVmZmVyKGN1cnJlbnRUaW1lLCB0YXJnZXREdXJhdGlvbiwgdGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uKTtcbiAgICB9XG4gICAgaWYgKGlzRmluaXRlTnVtYmVyKGNvbmZpZy5mcm9udEJ1ZmZlckZsdXNoVGhyZXNob2xkKSAmJiBjb25maWcuZnJvbnRCdWZmZXJGbHVzaFRocmVzaG9sZCA+IDApIHtcbiAgICAgIGNvbnN0IGZyb250QnVmZmVyTGVuZ3RoID0gTWF0aC5tYXgoY29uZmlnLm1heEJ1ZmZlckxlbmd0aCwgY29uZmlnLmZyb250QnVmZmVyRmx1c2hUaHJlc2hvbGQpO1xuICAgICAgY29uc3QgbWF4RnJvbnRCdWZmZXJMZW5ndGggPSBNYXRoLm1heChmcm9udEJ1ZmZlckxlbmd0aCwgdGFyZ2V0RHVyYXRpb24pO1xuICAgICAgY29uc3QgdGFyZ2V0RnJvbnRCdWZmZXJQb3NpdGlvbiA9IE1hdGguZmxvb3IoY3VycmVudFRpbWUgLyB0YXJnZXREdXJhdGlvbikgKiB0YXJnZXREdXJhdGlvbiArIG1heEZyb250QnVmZmVyTGVuZ3RoO1xuICAgICAgdGhpcy5mbHVzaEZyb250QnVmZmVyKGN1cnJlbnRUaW1lLCB0YXJnZXREdXJhdGlvbiwgdGFyZ2V0RnJvbnRCdWZmZXJQb3NpdGlvbik7XG4gICAgfVxuICB9XG4gIGZsdXNoQmFja0J1ZmZlcihjdXJyZW50VGltZSwgdGFyZ2V0RHVyYXRpb24sIHRhcmdldEJhY2tCdWZmZXJQb3NpdGlvbikge1xuICAgIHRoaXMuc291cmNlQnVmZmVycy5mb3JFYWNoKChbdHlwZSwgc2JdKSA9PiB7XG4gICAgICBpZiAoc2IpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyZWQgPSBCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQoc2IpO1xuICAgICAgICAvLyB3aGVuIHRhcmdldCBidWZmZXIgc3RhcnQgZXhjZWVkcyBhY3R1YWwgYnVmZmVyIHN0YXJ0XG4gICAgICAgIGlmIChidWZmZXJlZC5sZW5ndGggPiAwICYmIHRhcmdldEJhY2tCdWZmZXJQb3NpdGlvbiA+IGJ1ZmZlcmVkLnN0YXJ0KDApKSB7XG4gICAgICAgICAgdmFyIF90aGlzJGRldGFpbHM7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQkFDS19CVUZGRVJfUkVBQ0hFRCwge1xuICAgICAgICAgICAgYnVmZmVyRW5kOiB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb25cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIFN1cHBvcnQgZm9yIGRlcHJlY2F0ZWQgZXZlbnQ6XG4gICAgICAgICAgY29uc3QgdHJhY2sgPSB0aGlzLnRyYWNrc1t0eXBlXTtcbiAgICAgICAgICBpZiAoKF90aGlzJGRldGFpbHMgPSB0aGlzLmRldGFpbHMpICE9IG51bGwgJiYgX3RoaXMkZGV0YWlscy5saXZlKSB7XG4gICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5MSVZFX0JBQ0tfQlVGRkVSX1JFQUNIRUQsIHtcbiAgICAgICAgICAgICAgYnVmZmVyRW5kOiB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHJhY2sgIT0gbnVsbCAmJiB0cmFjay5lbmRlZCkge1xuICAgICAgICAgICAgdGhpcy5sb2coYENhbm5vdCBmbHVzaCAke3R5cGV9IGJhY2sgYnVmZmVyIHdoaWxlIFNvdXJjZUJ1ZmZlciBpcyBpbiBlbmRlZCBzdGF0ZWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHtcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiAwLFxuICAgICAgICAgICAgZW5kT2Zmc2V0OiB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb24sXG4gICAgICAgICAgICB0eXBlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmbHVzaEZyb250QnVmZmVyKGN1cnJlbnRUaW1lLCB0YXJnZXREdXJhdGlvbiwgdGFyZ2V0RnJvbnRCdWZmZXJQb3NpdGlvbikge1xuICAgIHRoaXMuc291cmNlQnVmZmVycy5mb3JFYWNoKChbdHlwZSwgc2JdKSA9PiB7XG4gICAgICBpZiAoc2IpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyZWQgPSBCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQoc2IpO1xuICAgICAgICBjb25zdCBudW1CdWZmZXJlZFJhbmdlcyA9IGJ1ZmZlcmVkLmxlbmd0aDtcbiAgICAgICAgLy8gVGhlIGJ1ZmZlciBpcyBlaXRoZXIgZW1wdHkgb3IgY29udGlndW91c1xuICAgICAgICBpZiAobnVtQnVmZmVyZWRSYW5nZXMgPCAyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1ZmZlclN0YXJ0ID0gYnVmZmVyZWQuc3RhcnQobnVtQnVmZmVyZWRSYW5nZXMgLSAxKTtcbiAgICAgICAgY29uc3QgYnVmZmVyRW5kID0gYnVmZmVyZWQuZW5kKG51bUJ1ZmZlcmVkUmFuZ2VzIC0gMSk7XG4gICAgICAgIC8vIE5vIGZsdXNoIGlmIHdlIGNhbiB0b2xlcmF0ZSB0aGUgY3VycmVudCBidWZmZXIgbGVuZ3RoIG9yIHRoZSBjdXJyZW50IGJ1ZmZlciByYW5nZSB3ZSB3b3VsZCBmbHVzaCBpcyBjb250aWd1b3VzIHdpdGggY3VycmVudCBwb3NpdGlvblxuICAgICAgICBpZiAodGFyZ2V0RnJvbnRCdWZmZXJQb3NpdGlvbiA+IGJ1ZmZlclN0YXJ0IHx8IGN1cnJlbnRUaW1lID49IGJ1ZmZlclN0YXJ0ICYmIGN1cnJlbnRUaW1lIDw9IGJ1ZmZlckVuZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHtcbiAgICAgICAgICBzdGFydE9mZnNldDogYnVmZmVyU3RhcnQsXG4gICAgICAgICAgZW5kT2Zmc2V0OiBJbmZpbml0eSxcbiAgICAgICAgICB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBNZWRpYSBTb3VyY2UgZHVyYXRpb24gdG8gY3VycmVudCBsZXZlbCBkdXJhdGlvbiBvciBvdmVycmlkZSB0byBJbmZpbml0eSBpZiBjb25maWd1cmF0aW9uIHBhcmFtZXRlclxuICAgKiAnbGl2ZUR1cmF0aW9uSW5maW5pdHlgIGlzIHNldCB0byBgdHJ1ZWBcbiAgICogTW9yZSBkZXRhaWxzOiBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvMzU1XG4gICAqL1xuICBnZXREdXJhdGlvbkFuZFJhbmdlKCkge1xuICAgIHZhciBfdGhpcyRvdmVycmlkZXMyO1xuICAgIGNvbnN0IHtcbiAgICAgIGRldGFpbHMsXG4gICAgICBtZWRpYVNvdXJjZVxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghZGV0YWlscyB8fCAhdGhpcy5tZWRpYSB8fCAobWVkaWFTb3VyY2UgPT0gbnVsbCA/IHZvaWQgMCA6IG1lZGlhU291cmNlLnJlYWR5U3RhdGUpICE9PSAnb3BlbicpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBwbGF5bGlzdEVuZCA9IGRldGFpbHMuZWRnZTtcbiAgICBpZiAoZGV0YWlscy5saXZlICYmIHRoaXMuaGxzLmNvbmZpZy5saXZlRHVyYXRpb25JbmZpbml0eSkge1xuICAgICAgY29uc3QgbGVuID0gZGV0YWlscy5mcmFnbWVudHMubGVuZ3RoO1xuICAgICAgaWYgKGxlbiAmJiBkZXRhaWxzLmxpdmUgJiYgISFtZWRpYVNvdXJjZS5zZXRMaXZlU2Vla2FibGVSYW5nZSkge1xuICAgICAgICBjb25zdCBzdGFydCA9IE1hdGgubWF4KDAsIGRldGFpbHMuZnJhZ21lbnRTdGFydCk7XG4gICAgICAgIGNvbnN0IGVuZCA9IE1hdGgubWF4KHN0YXJ0LCBwbGF5bGlzdEVuZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZHVyYXRpb246IEluZmluaXR5LFxuICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgIGVuZFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZHVyYXRpb246IEluZmluaXR5XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBvdmVycmlkZUR1cmF0aW9uID0gKF90aGlzJG92ZXJyaWRlczIgPSB0aGlzLm92ZXJyaWRlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG92ZXJyaWRlczIuZHVyYXRpb247XG4gICAgaWYgKG92ZXJyaWRlRHVyYXRpb24pIHtcbiAgICAgIGlmICghaXNGaW5pdGVOdW1iZXIob3ZlcnJpZGVEdXJhdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkdXJhdGlvbjogb3ZlcnJpZGVEdXJhdGlvblxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgbWVkaWFEdXJhdGlvbiA9IHRoaXMubWVkaWEuZHVyYXRpb247XG4gICAgY29uc3QgbXNEdXJhdGlvbiA9IGlzRmluaXRlTnVtYmVyKG1lZGlhU291cmNlLmR1cmF0aW9uKSA/IG1lZGlhU291cmNlLmR1cmF0aW9uIDogMDtcbiAgICBpZiAocGxheWxpc3RFbmQgPiBtc0R1cmF0aW9uICYmIHBsYXlsaXN0RW5kID4gbWVkaWFEdXJhdGlvbiB8fCAhaXNGaW5pdGVOdW1iZXIobWVkaWFEdXJhdGlvbikpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGR1cmF0aW9uOiBwbGF5bGlzdEVuZFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdXBkYXRlTWVkaWFTb3VyY2Uoe1xuICAgIGR1cmF0aW9uLFxuICAgIHN0YXJ0LFxuICAgIGVuZFxuICB9KSB7XG4gICAgY29uc3QgbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlO1xuICAgIGlmICghdGhpcy5tZWRpYSB8fCAhbWVkaWFTb3VyY2UgfHwgbWVkaWFTb3VyY2UucmVhZHlTdGF0ZSAhPT0gJ29wZW4nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChtZWRpYVNvdXJjZS5kdXJhdGlvbiAhPT0gZHVyYXRpb24pIHtcbiAgICAgIGlmIChpc0Zpbml0ZU51bWJlcihkdXJhdGlvbikpIHtcbiAgICAgICAgdGhpcy5sb2coYFVwZGF0aW5nIE1lZGlhU291cmNlIGR1cmF0aW9uIHRvICR7ZHVyYXRpb24udG9GaXhlZCgzKX1gKTtcbiAgICAgIH1cbiAgICAgIG1lZGlhU291cmNlLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgfVxuICAgIGlmIChzdGFydCAhPT0gdW5kZWZpbmVkICYmIGVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmxvZyhgTWVkaWFTb3VyY2UgZHVyYXRpb24gaXMgc2V0IHRvICR7bWVkaWFTb3VyY2UuZHVyYXRpb259LiBTZXR0aW5nIHNlZWthYmxlIHJhbmdlIHRvICR7c3RhcnR9LSR7ZW5kfS5gKTtcbiAgICAgIG1lZGlhU291cmNlLnNldExpdmVTZWVrYWJsZVJhbmdlKHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgfVxuICBnZXQgdHJhY2tzUmVhZHkoKSB7XG4gICAgY29uc3QgcGVuZGluZ1RyYWNrQ291bnQgPSB0aGlzLnBlbmRpbmdUcmFja0NvdW50O1xuICAgIHJldHVybiBwZW5kaW5nVHJhY2tDb3VudCA+IDAgJiYgKHBlbmRpbmdUcmFja0NvdW50ID49IHRoaXMuYnVmZmVyQ29kZWNFdmVudHNUb3RhbCB8fCB0aGlzLmlzUGVuZGluZyh0aGlzLnRyYWNrcy5hdWRpb3ZpZGVvKSk7XG4gIH1cbiAgY2hlY2tQZW5kaW5nVHJhY2tzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGJ1ZmZlckNvZGVjRXZlbnRzVG90YWwsXG4gICAgICBwZW5kaW5nVHJhY2tDb3VudCxcbiAgICAgIHRyYWNrc1xuICAgIH0gPSB0aGlzO1xuICAgIHRoaXMubG9nKGBjaGVja1BlbmRpbmdUcmFja3MgKHBlbmRpbmc6ICR7cGVuZGluZ1RyYWNrQ291bnR9IGNvZGVjIGV2ZW50cyBleHBlY3RlZDogJHtidWZmZXJDb2RlY0V2ZW50c1RvdGFsfSkgJHtzdHJpbmdpZnkodHJhY2tzKX1gKTtcbiAgICAvLyBDaGVjayBpZiB3ZSd2ZSByZWNlaXZlZCBhbGwgb2YgdGhlIGV4cGVjdGVkIGJ1ZmZlckNvZGVjIGV2ZW50cy4gV2hlbiBub25lIHJlbWFpbiwgY3JlYXRlIGFsbCB0aGUgc291cmNlQnVmZmVycyBhdCBvbmNlLlxuICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IGJlY2F1c2UgdGhlIE1TRSBzcGVjIGFsbG93cyBpbXBsZW1lbnRhdGlvbnMgdG8gdGhyb3cgUXVvdGFFeGNlZWRlZEVycm9ycyBpZiBjcmVhdGluZyBuZXcgc291cmNlQnVmZmVycyBhZnRlclxuICAgIC8vIGRhdGEgaGFzIGJlZW4gYXBwZW5kZWQgdG8gZXhpc3Rpbmcgb25lcy5cbiAgICAvLyAyIHRyYWNrcyBpcyB0aGUgbWF4IChvbmUgZm9yIGF1ZGlvLCBvbmUgZm9yIHZpZGVvKS4gSWYgd2UndmUgcmVhY2ggdGhpcyBtYXggZ28gYWhlYWQgYW5kIGNyZWF0ZSB0aGUgYnVmZmVycy5cbiAgICBpZiAodGhpcy50cmFja3NSZWFkeSkge1xuICAgICAgdmFyIF90aGlzJHRyYW5zZmVyRGF0YTQ7XG4gICAgICBjb25zdCB0cmFuc2ZlcnJlZFRyYWNrcyA9IChfdGhpcyR0cmFuc2ZlckRhdGE0ID0gdGhpcy50cmFuc2ZlckRhdGEpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyR0cmFuc2ZlckRhdGE0LnRyYWNrcztcbiAgICAgIGlmICh0cmFuc2ZlcnJlZFRyYWNrcyAmJiBPYmplY3Qua2V5cyh0cmFuc2ZlcnJlZFRyYWNrcykubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuYXR0YWNoVHJhbnNmZXJyZWQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG9rLCBsZXQncyBjcmVhdGUgdGhlbSBub3cgIVxuICAgICAgICB0aGlzLmNyZWF0ZVNvdXJjZUJ1ZmZlcnMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYnVmZmVyQ3JlYXRlZCgpIHtcbiAgICBpZiAodGhpcy5zb3VyY2VCdWZmZXJDb3VudCkge1xuICAgICAgY29uc3QgdHJhY2tzID0ge307XG4gICAgICB0aGlzLnNvdXJjZUJ1ZmZlcnMuZm9yRWFjaCgoW3R5cGUsIGJ1ZmZlcl0pID0+IHtcbiAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICBjb25zdCB0cmFjayA9IHRoaXMudHJhY2tzW3R5cGVdO1xuICAgICAgICAgIHRyYWNrc1t0eXBlXSA9IHtcbiAgICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICAgIGNvbnRhaW5lcjogdHJhY2suY29udGFpbmVyLFxuICAgICAgICAgICAgY29kZWM6IHRyYWNrLmNvZGVjLFxuICAgICAgICAgICAgc3VwcGxlbWVudGFsOiB0cmFjay5zdXBwbGVtZW50YWwsXG4gICAgICAgICAgICBsZXZlbENvZGVjOiB0cmFjay5sZXZlbENvZGVjLFxuICAgICAgICAgICAgaWQ6IHRyYWNrLmlkLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHRyYWNrLm1ldGFkYXRhXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfQ1JFQVRFRCwge1xuICAgICAgICB0cmFja3NcbiAgICAgIH0pO1xuICAgICAgdGhpcy5sb2coYFNvdXJjZUJ1ZmZlcnMgY3JlYXRlZC4gUnVubmluZyBxdWV1ZTogJHt0aGlzLm9wZXJhdGlvblF1ZXVlfWApO1xuICAgICAgdGhpcy5zb3VyY2VCdWZmZXJzLmZvckVhY2goKFt0eXBlXSkgPT4ge1xuICAgICAgICB0aGlzLmV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdjb3VsZCBub3QgY3JlYXRlIHNvdXJjZSBidWZmZXIgZm9yIG1lZGlhIGNvZGVjKHMpJyk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX0lOQ09NUEFUSUJMRV9DT0RFQ1NfRVJST1IsXG4gICAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgcmVhc29uOiBlcnJvci5tZXNzYWdlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgY3JlYXRlU291cmNlQnVmZmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICB0cmFja3MsXG4gICAgICBzb3VyY2VCdWZmZXJzLFxuICAgICAgbWVkaWFTb3VyY2VcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIW1lZGlhU291cmNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyZWF0ZVNvdXJjZUJ1ZmZlcnMgY2FsbGVkIHdoZW4gbWVkaWFTb3VyY2Ugd2FzIG51bGwnKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB0cmFja05hbWUgaW4gdHJhY2tzKSB7XG4gICAgICBjb25zdCB0eXBlID0gdHJhY2tOYW1lO1xuICAgICAgY29uc3QgdHJhY2sgPSB0cmFja3NbdHlwZV07XG4gICAgICBpZiAodGhpcy5pc1BlbmRpbmcodHJhY2spKSB7XG4gICAgICAgIGNvbnN0IGNvZGVjID0gdGhpcy5nZXRUcmFja0NvZGVjKHRyYWNrLCB0eXBlKTtcbiAgICAgICAgY29uc3QgbWltZVR5cGUgPSBgJHt0cmFjay5jb250YWluZXJ9O2NvZGVjcz0ke2NvZGVjfWA7XG4gICAgICAgIHRyYWNrLmNvZGVjID0gY29kZWM7XG4gICAgICAgIHRoaXMubG9nKGBjcmVhdGluZyBzb3VyY2VCdWZmZXIoJHttaW1lVHlwZX0pJHt0aGlzLmN1cnJlbnRPcCh0eXBlKSA/ICcgUXVldWVkJyA6ICcnfSAke3N0cmluZ2lmeSh0cmFjayl9YCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgc2IgPSBtZWRpYVNvdXJjZS5hZGRTb3VyY2VCdWZmZXIobWltZVR5cGUpO1xuICAgICAgICAgIGNvbnN0IHNiSW5kZXggPSBzb3VyY2VCdWZmZXJOYW1lVG9JbmRleCh0eXBlKTtcbiAgICAgICAgICBjb25zdCBzYlR1cGxlID0gW3R5cGUsIHNiXTtcbiAgICAgICAgICBzb3VyY2VCdWZmZXJzW3NiSW5kZXhdID0gc2JUdXBsZTtcbiAgICAgICAgICB0cmFjay5idWZmZXIgPSBzYjtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB2YXIgX3RoaXMkb3BlcmF0aW9uUXVldWU7XG4gICAgICAgICAgdGhpcy5lcnJvcihgZXJyb3Igd2hpbGUgdHJ5aW5nIHRvIGFkZCBzb3VyY2VCdWZmZXI6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAvLyByZW1vdmUgaW5pdCBzZWdtZW50IGZyb20gcXVldWUgYW5kIGRlbGV0ZSB0cmFjayBpbmZvXG4gICAgICAgICAgdGhpcy5zaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgICAgICAgIChfdGhpcyRvcGVyYXRpb25RdWV1ZSA9IHRoaXMub3BlcmF0aW9uUXVldWUpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRvcGVyYXRpb25RdWV1ZS5yZW1vdmVCbG9ja2VycygpO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnRyYWNrc1t0eXBlXTtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfQUREX0NPREVDX0VSUk9SLFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICBzb3VyY2VCdWZmZXJOYW1lOiB0eXBlLFxuICAgICAgICAgICAgbWltZVR5cGU6IG1pbWVUeXBlLFxuICAgICAgICAgICAgcGFyZW50OiB0cmFjay5pZFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYWNrU291cmNlQnVmZmVyKHR5cGUsIHRyYWNrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5idWZmZXJDcmVhdGVkKCk7XG4gIH1cbiAgZ2V0VHJhY2tDb2RlYyh0cmFjaywgdHJhY2tOYW1lKSB7XG4gICAgLy8gVXNlIHN1cHBsZW1lbnRhbCB2aWRlbyBjb2RlYyB3aGVuIHN1cHBvcnRlZCB3aGVuIGFkZGluZyBTb3VyY2VCdWZmZXIgKCM1NTU4KVxuICAgIGNvbnN0IHN1cHBsZW1lbnRhbENvZGVjID0gdHJhY2suc3VwcGxlbWVudGFsO1xuICAgIGxldCB0cmFja0NvZGVjID0gdHJhY2suY29kZWM7XG4gICAgaWYgKHN1cHBsZW1lbnRhbENvZGVjICYmICh0cmFja05hbWUgPT09ICd2aWRlbycgfHwgdHJhY2tOYW1lID09PSAnYXVkaW92aWRlbycpICYmIGFyZUNvZGVjc01lZGlhU291cmNlU3VwcG9ydGVkKHN1cHBsZW1lbnRhbENvZGVjLCAndmlkZW8nKSkge1xuICAgICAgdHJhY2tDb2RlYyA9IHJlcGxhY2VWaWRlb0NvZGVjKHRyYWNrQ29kZWMsIHN1cHBsZW1lbnRhbENvZGVjKTtcbiAgICB9XG4gICAgY29uc3QgY29kZWMgPSBwaWNrTW9zdENvbXBsZXRlQ29kZWNOYW1lKHRyYWNrQ29kZWMsIHRyYWNrLmxldmVsQ29kZWMpO1xuICAgIGlmIChjb2RlYykge1xuICAgICAgaWYgKHRyYWNrTmFtZS5zbGljZSgwLCA1KSA9PT0gJ2F1ZGlvJykge1xuICAgICAgICByZXR1cm4gZ2V0Q29kZWNDb21wYXRpYmxlTmFtZShjb2RlYywgdGhpcy5hcHBlbmRTb3VyY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvZGVjO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgdHJhY2tTb3VyY2VCdWZmZXIodHlwZSwgdHJhY2spIHtcbiAgICBjb25zdCBidWZmZXIgPSB0cmFjay5idWZmZXI7XG4gICAgaWYgKCFidWZmZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY29kZWMgPSB0aGlzLmdldFRyYWNrQ29kZWModHJhY2ssIHR5cGUpO1xuICAgIHRoaXMudHJhY2tzW3R5cGVdID0ge1xuICAgICAgYnVmZmVyLFxuICAgICAgY29kZWMsXG4gICAgICBjb250YWluZXI6IHRyYWNrLmNvbnRhaW5lcixcbiAgICAgIGxldmVsQ29kZWM6IHRyYWNrLmxldmVsQ29kZWMsXG4gICAgICBzdXBwbGVtZW50YWw6IHRyYWNrLnN1cHBsZW1lbnRhbCxcbiAgICAgIG1ldGFkYXRhOiB0cmFjay5tZXRhZGF0YSxcbiAgICAgIGlkOiB0cmFjay5pZCxcbiAgICAgIGxpc3RlbmVyczogW11cbiAgICB9O1xuICAgIHRoaXMucmVtb3ZlQnVmZmVyTGlzdGVuZXJzKHR5cGUpO1xuICAgIHRoaXMuYWRkQnVmZmVyTGlzdGVuZXIodHlwZSwgJ3VwZGF0ZXN0YXJ0JywgdGhpcy5vblNCVXBkYXRlU3RhcnQpO1xuICAgIHRoaXMuYWRkQnVmZmVyTGlzdGVuZXIodHlwZSwgJ3VwZGF0ZWVuZCcsIHRoaXMub25TQlVwZGF0ZUVuZCk7XG4gICAgdGhpcy5hZGRCdWZmZXJMaXN0ZW5lcih0eXBlLCAnZXJyb3InLCB0aGlzLm9uU0JVcGRhdGVFcnJvcik7XG4gICAgLy8gTWFuYWdlZFNvdXJjZUJ1ZmZlciBidWZmZXJlZGNoYW5nZSBldmVudFxuICAgIGlmICh0aGlzLmFwcGVuZFNvdXJjZSkge1xuICAgICAgdGhpcy5hZGRCdWZmZXJMaXN0ZW5lcih0eXBlLCAnYnVmZmVyZWRjaGFuZ2UnLCAodHlwZSwgZXZlbnQpID0+IHtcbiAgICAgICAgLy8gSWYgbWVkaWEgd2FzIGVqZWN0ZWQgY2hlY2sgZm9yIGEgY2hhbmdlLiBBZGRlZCByYW5nZXMgYXJlIHJlZHVuZGFudCB3aXRoIGNoYW5nZXMgb24gJ3VwZGF0ZWVuZCcgZXZlbnQuXG4gICAgICAgIGNvbnN0IHJlbW92ZWRSYW5nZXMgPSBldmVudC5yZW1vdmVkUmFuZ2VzO1xuICAgICAgICBpZiAocmVtb3ZlZFJhbmdlcyAhPSBudWxsICYmIHJlbW92ZWRSYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0ZMVVNIRUQsIHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldCBtZWRpYVNyYygpIHtcbiAgICB2YXIgX3RoaXMkbWVkaWEyLCBfdGhpcyRtZWRpYTIkcXVlcnlTZWw7XG4gICAgY29uc3QgbWVkaWEgPSAoKF90aGlzJG1lZGlhMiA9IHRoaXMubWVkaWEpID09IG51bGwgPyB2b2lkIDAgOiAoX3RoaXMkbWVkaWEyJHF1ZXJ5U2VsID0gX3RoaXMkbWVkaWEyLnF1ZXJ5U2VsZWN0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRtZWRpYTIkcXVlcnlTZWwuY2FsbChfdGhpcyRtZWRpYTIsICdzb3VyY2UnKSkgfHwgdGhpcy5tZWRpYTtcbiAgICByZXR1cm4gbWVkaWEgPT0gbnVsbCA/IHZvaWQgMCA6IG1lZGlhLnNyYztcbiAgfVxuICBvblNCVXBkYXRlU3RhcnQodHlwZSkge1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHRoaXMuY3VycmVudE9wKHR5cGUpO1xuICAgIGlmICghb3BlcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG9wZXJhdGlvbi5vblN0YXJ0KCk7XG4gIH1cbiAgb25TQlVwZGF0ZUVuZCh0eXBlKSB7XG4gICAgdmFyIF90aGlzJG1lZGlhU291cmNlNDtcbiAgICBpZiAoKChfdGhpcyRtZWRpYVNvdXJjZTQgPSB0aGlzLm1lZGlhU291cmNlKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbWVkaWFTb3VyY2U0LnJlYWR5U3RhdGUpID09PSAnY2xvc2VkJykge1xuICAgICAgdGhpcy5yZXNldEJ1ZmZlcih0eXBlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb3BlcmF0aW9uID0gdGhpcy5jdXJyZW50T3AodHlwZSk7XG4gICAgaWYgKCFvcGVyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgb3BlcmF0aW9uLm9uQ29tcGxldGUoKTtcbiAgICB0aGlzLnNoaWZ0QW5kRXhlY3V0ZU5leHQodHlwZSk7XG4gIH1cbiAgb25TQlVwZGF0ZUVycm9yKHR5cGUsIGV2ZW50KSB7XG4gICAgdmFyIF90aGlzJG1lZGlhU291cmNlNTtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgJHt0eXBlfSBTb3VyY2VCdWZmZXIgZXJyb3IuIE1lZGlhU291cmNlIHJlYWR5U3RhdGU6ICR7KF90aGlzJG1lZGlhU291cmNlNSA9IHRoaXMubWVkaWFTb3VyY2UpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRtZWRpYVNvdXJjZTUucmVhZHlTdGF0ZX1gKTtcbiAgICB0aGlzLmVycm9yKGAke2Vycm9yfWAsIGV2ZW50KTtcbiAgICAvLyBhY2NvcmRpbmcgdG8gaHR0cDovL3d3dy53My5vcmcvVFIvbWVkaWEtc291cmNlLyNzb3VyY2VidWZmZXItYXBwZW5kLWVycm9yXG4gICAgLy8gU291cmNlQnVmZmVyIGVycm9ycyBhcmUgbm90IG5lY2Vzc2FyaWx5IGZhdGFsOyBpZiBzbywgdGhlIEhUTUxNZWRpYUVsZW1lbnQgd2lsbCBmaXJlIGFuIGVycm9yIGV2ZW50XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORElOR19FUlJPUixcbiAgICAgIHNvdXJjZUJ1ZmZlck5hbWU6IHR5cGUsXG4gICAgICBlcnJvcixcbiAgICAgIGZhdGFsOiBmYWxzZVxuICAgIH0pO1xuICAgIC8vIHVwZGF0ZWVuZCBpcyBhbHdheXMgZmlyZWQgYWZ0ZXIgZXJyb3IsIHNvIHdlJ2xsIGFsbG93IHRoYXQgdG8gc2hpZnQgdGhlIGN1cnJlbnQgb3BlcmF0aW9uIG9mZiBvZiB0aGUgcXVldWVcbiAgICBjb25zdCBvcGVyYXRpb24gPSB0aGlzLmN1cnJlbnRPcCh0eXBlKTtcbiAgICBpZiAob3BlcmF0aW9uKSB7XG4gICAgICBvcGVyYXRpb24ub25FcnJvcihlcnJvcik7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVRpbWVzdGFtcE9mZnNldChzYiwgdGltZXN0YW1wT2Zmc2V0LCB0b2xlcmFuY2UsIHR5cGUsIHNuLCBjYykge1xuICAgIGNvbnN0IGRlbHRhID0gdGltZXN0YW1wT2Zmc2V0IC0gc2IudGltZXN0YW1wT2Zmc2V0O1xuICAgIGlmIChNYXRoLmFicyhkZWx0YSkgPj0gdG9sZXJhbmNlKSB7XG4gICAgICB0aGlzLmxvZyhgVXBkYXRpbmcgJHt0eXBlfSBTb3VyY2VCdWZmZXIgdGltZXN0YW1wT2Zmc2V0IHRvICR7dGltZXN0YW1wT2Zmc2V0fSAoc246ICR7c259IGNjOiAke2NjfSlgKTtcbiAgICAgIHNiLnRpbWVzdGFtcE9mZnNldCA9IHRpbWVzdGFtcE9mZnNldDtcbiAgICB9XG4gIH1cblxuICAvLyBUaGlzIG1ldGhvZCBtdXN0IHJlc3VsdCBpbiBhbiB1cGRhdGVlbmQgZXZlbnQ7IGlmIHJlbW92ZSBpcyBub3QgY2FsbGVkLCBvblNCVXBkYXRlRW5kIG11c3QgYmUgY2FsbGVkIG1hbnVhbGx5XG4gIHJlbW92ZUV4ZWN1dG9yKHR5cGUsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpIHtcbiAgICBjb25zdCB7XG4gICAgICBtZWRpYSxcbiAgICAgIG1lZGlhU291cmNlXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgdHJhY2sgPSB0aGlzLnRyYWNrc1t0eXBlXTtcbiAgICBjb25zdCBzYiA9IHRyYWNrID09IG51bGwgPyB2b2lkIDAgOiB0cmFjay5idWZmZXI7XG4gICAgaWYgKCFtZWRpYSB8fCAhbWVkaWFTb3VyY2UgfHwgIXNiKSB7XG4gICAgICB0aGlzLndhcm4oYEF0dGVtcHRpbmcgdG8gcmVtb3ZlIGZyb20gdGhlICR7dHlwZX0gU291cmNlQnVmZmVyLCBidXQgaXQgZG9lcyBub3QgZXhpc3RgKTtcbiAgICAgIHRoaXMuc2hpZnRBbmRFeGVjdXRlTmV4dCh0eXBlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWVkaWFEdXJhdGlvbiA9IGlzRmluaXRlTnVtYmVyKG1lZGlhLmR1cmF0aW9uKSA/IG1lZGlhLmR1cmF0aW9uIDogSW5maW5pdHk7XG4gICAgY29uc3QgbXNEdXJhdGlvbiA9IGlzRmluaXRlTnVtYmVyKG1lZGlhU291cmNlLmR1cmF0aW9uKSA/IG1lZGlhU291cmNlLmR1cmF0aW9uIDogSW5maW5pdHk7XG4gICAgY29uc3QgcmVtb3ZlU3RhcnQgPSBNYXRoLm1heCgwLCBzdGFydE9mZnNldCk7XG4gICAgY29uc3QgcmVtb3ZlRW5kID0gTWF0aC5taW4oZW5kT2Zmc2V0LCBtZWRpYUR1cmF0aW9uLCBtc0R1cmF0aW9uKTtcbiAgICBpZiAocmVtb3ZlRW5kID4gcmVtb3ZlU3RhcnQgJiYgKCF0cmFjay5lbmRpbmcgfHwgdHJhY2suZW5kZWQpKSB7XG4gICAgICB0cmFjay5lbmRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5sb2coYFJlbW92aW5nIFske3JlbW92ZVN0YXJ0fSwke3JlbW92ZUVuZH1dIGZyb20gdGhlICR7dHlwZX0gU291cmNlQnVmZmVyYCk7XG4gICAgICBzYi5yZW1vdmUocmVtb3ZlU3RhcnQsIHJlbW92ZUVuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEN5Y2xlIHRoZSBxdWV1ZVxuICAgICAgdGhpcy5zaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRoaXMgbWV0aG9kIG11c3QgcmVzdWx0IGluIGFuIHVwZGF0ZWVuZCBldmVudDsgaWYgYXBwZW5kIGlzIG5vdCBjYWxsZWQsIG9uU0JVcGRhdGVFbmQgbXVzdCBiZSBjYWxsZWQgbWFudWFsbHlcbiAgYXBwZW5kRXhlY3V0b3IoZGF0YSwgdHlwZSkge1xuICAgIGNvbnN0IHRyYWNrID0gdGhpcy50cmFja3NbdHlwZV07XG4gICAgY29uc3Qgc2IgPSB0cmFjayA9PSBudWxsID8gdm9pZCAwIDogdHJhY2suYnVmZmVyO1xuICAgIGlmICghc2IpIHtcbiAgICAgIHRocm93IG5ldyBIbHNKc1RyYWNrUmVtb3ZlZEVycm9yKGBBdHRlbXB0aW5nIHRvIGFwcGVuZCB0byB0aGUgJHt0eXBlfSBTb3VyY2VCdWZmZXIsIGJ1dCBpdCBkb2VzIG5vdCBleGlzdGApO1xuICAgIH1cbiAgICB0cmFjay5lbmRpbmcgPSBmYWxzZTtcbiAgICB0cmFjay5lbmRlZCA9IGZhbHNlO1xuICAgIHNiLmFwcGVuZEJ1ZmZlcihkYXRhKTtcbiAgfVxuICBibG9ja1VudGlsT3BlbihjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLmlzVXBkYXRpbmcoKSB8fCB0aGlzLmlzUXVldWVkKCkpIHtcbiAgICAgIHRoaXMuYmxvY2tCdWZmZXJzKGNhbGxiYWNrKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIHRoaXMud2FybihgU291cmNlQnVmZmVyIGJsb2NrZWQgY2FsbGJhY2sgJHtlcnJvcn1gKTtcbiAgICAgICAgdGhpcy5zdGVwT3BlcmF0aW9uUXVldWUodGhpcy5zb3VyY2VCdWZmZXJUeXBlcyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRoaXMud2FybihgQ2FsbGJhY2sgcnVuIHdpdGhvdXQgYmxvY2tpbmcgJHt0aGlzLm9wZXJhdGlvblF1ZXVlfSAke2Vycm9yfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpc1VwZGF0aW5nKCkge1xuICAgIHJldHVybiB0aGlzLnNvdXJjZUJ1ZmZlcnMuc29tZSgoW3R5cGUsIHNiXSkgPT4gdHlwZSAmJiBzYi51cGRhdGluZyk7XG4gIH1cbiAgaXNRdWV1ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlQnVmZmVycy5zb21lKChbdHlwZV0pID0+IHR5cGUgJiYgISF0aGlzLmN1cnJlbnRPcCh0eXBlKSk7XG4gIH1cbiAgaXNQZW5kaW5nKHRyYWNrKSB7XG4gICAgcmV0dXJuICEhdHJhY2sgJiYgIXRyYWNrLmJ1ZmZlcjtcbiAgfVxuXG4gIC8vIEVucXVldWVzIGFuIG9wZXJhdGlvbiB0byBlYWNoIFNvdXJjZUJ1ZmZlciBxdWV1ZSB3aGljaCwgdXBvbiBleGVjdXRpb24sIHJlc29sdmVzIGEgcHJvbWlzZS4gV2hlbiBhbGwgcHJvbWlzZXNcbiAgLy8gcmVzb2x2ZSwgdGhlIG9uVW5ibG9ja2VkIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkLiBGdW5jdGlvbnMgY2FsbGluZyB0aGlzIG1ldGhvZCBkbyBub3QgbmVlZCB0byB1bmJsb2NrIHRoZSBxdWV1ZVxuICAvLyB1cG9uIGNvbXBsZXRpb24sIHNpbmNlIHdlIGFscmVhZHkgZG8gaXQgaGVyZVxuICBibG9ja0J1ZmZlcnMob25VbmJsb2NrZWQsIGJ1ZmZlck5hbWVzID0gdGhpcy5zb3VyY2VCdWZmZXJUeXBlcykge1xuICAgIGlmICghYnVmZmVyTmFtZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmxvZygnQmxvY2tpbmcgb3BlcmF0aW9uIHJlcXVlc3RlZCwgYnV0IG5vIFNvdXJjZUJ1ZmZlcnMgZXhpc3QnKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKG9uVW5ibG9ja2VkKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgb3BlcmF0aW9uUXVldWVcbiAgICB9ID0gdGhpcztcblxuICAgIC8vIGxvZ2dlci5kZWJ1ZyhgW2J1ZmZlci1jb250cm9sbGVyXTogQmxvY2tpbmcgJHtidWZmZXJzfSBTb3VyY2VCdWZmZXJgKTtcbiAgICBjb25zdCBibG9ja2luZ09wZXJhdGlvbnMgPSBidWZmZXJOYW1lcy5tYXAodHlwZSA9PiB0aGlzLmFwcGVuZEJsb2NrZXIodHlwZSkpO1xuICAgIGNvbnN0IGF1ZGlvQmxvY2tlZCA9IGJ1ZmZlck5hbWVzLmxlbmd0aCA+IDEgJiYgISF0aGlzLmJsb2NrZWRBdWRpb0FwcGVuZDtcbiAgICBpZiAoYXVkaW9CbG9ja2VkKSB7XG4gICAgICB0aGlzLnVuYmxvY2tBdWRpbygpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoYmxvY2tpbmdPcGVyYXRpb25zKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICBpZiAob3BlcmF0aW9uUXVldWUgIT09IHRoaXMub3BlcmF0aW9uUXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gbG9nZ2VyLmRlYnVnKGBbYnVmZmVyLWNvbnRyb2xsZXJdOiBCbG9ja2luZyBvcGVyYXRpb24gcmVzb2x2ZWQ7IHVuYmxvY2tpbmcgJHtidWZmZXJzfSBTb3VyY2VCdWZmZXJgKTtcbiAgICAgIG9uVW5ibG9ja2VkKCk7XG4gICAgICB0aGlzLnN0ZXBPcGVyYXRpb25RdWV1ZSh0aGlzLnNvdXJjZUJ1ZmZlclR5cGVzKTtcbiAgICB9KTtcbiAgfVxuICBzdGVwT3BlcmF0aW9uUXVldWUoYnVmZmVyTmFtZXMpIHtcbiAgICBidWZmZXJOYW1lcy5mb3JFYWNoKHR5cGUgPT4ge1xuICAgICAgdmFyIF90aGlzJHRyYWNrcyR0eXBlNjtcbiAgICAgIGNvbnN0IHNiID0gKF90aGlzJHRyYWNrcyR0eXBlNiA9IHRoaXMudHJhY2tzW3R5cGVdKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkdHJhY2tzJHR5cGU2LmJ1ZmZlcjtcbiAgICAgIC8vIE9ubHkgY3ljbGUgdGhlIHF1ZXVlIGlmIHRoZSBTQiBpcyBub3QgdXBkYXRpbmcuIFRoZXJlJ3MgYSBidWcgaW4gQ2hyb21lIHdoaWNoIHNldHMgdGhlIFNCIHVwZGF0aW5nIGZsYWcgdG9cbiAgICAgIC8vIHRydWUgd2hlbiBjaGFuZ2luZyB0aGUgTWVkaWFTb3VyY2UgZHVyYXRpb24gKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTk1OTM1OSZjYW49MiZxPW1lZGlhc291cmNlJTIwZHVyYXRpb24pXG4gICAgICAvLyBXaGlsZSB0aGlzIGlzIGEgd29ya2Fyb3VuZCwgaXQncyBwcm9iYWJseSB1c2VmdWwgdG8gaGF2ZSBhcm91bmRcbiAgICAgIGlmICghc2IgfHwgc2IudXBkYXRpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgIH0pO1xuICB9XG4gIGFwcGVuZChvcGVyYXRpb24sIHR5cGUsIHBlbmRpbmcpIHtcbiAgICBpZiAodGhpcy5vcGVyYXRpb25RdWV1ZSkge1xuICAgICAgdGhpcy5vcGVyYXRpb25RdWV1ZS5hcHBlbmQob3BlcmF0aW9uLCB0eXBlLCBwZW5kaW5nKTtcbiAgICB9XG4gIH1cbiAgYXBwZW5kQmxvY2tlcih0eXBlKSB7XG4gICAgaWYgKHRoaXMub3BlcmF0aW9uUXVldWUpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wZXJhdGlvblF1ZXVlLmFwcGVuZEJsb2NrZXIodHlwZSk7XG4gICAgfVxuICB9XG4gIGN1cnJlbnRPcCh0eXBlKSB7XG4gICAgaWYgKHRoaXMub3BlcmF0aW9uUXVldWUpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wZXJhdGlvblF1ZXVlLmN1cnJlbnQodHlwZSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGV4ZWN1dGVOZXh0KHR5cGUpIHtcbiAgICBpZiAodHlwZSAmJiB0aGlzLm9wZXJhdGlvblF1ZXVlKSB7XG4gICAgICB0aGlzLm9wZXJhdGlvblF1ZXVlLmV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgIH1cbiAgfVxuICBzaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpIHtcbiAgICBpZiAodGhpcy5vcGVyYXRpb25RdWV1ZSkge1xuICAgICAgdGhpcy5vcGVyYXRpb25RdWV1ZS5zaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgIH1cbiAgfVxuICBnZXQgcGVuZGluZ1RyYWNrQ291bnQoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMudHJhY2tzKS5yZWR1Y2UoKGFjYywgdHlwZSkgPT4gYWNjICsgKHRoaXMuaXNQZW5kaW5nKHRoaXMudHJhY2tzW3R5cGVdKSA/IDEgOiAwKSwgMCk7XG4gIH1cbiAgZ2V0IHNvdXJjZUJ1ZmZlckNvdW50KCkge1xuICAgIHJldHVybiB0aGlzLnNvdXJjZUJ1ZmZlcnMucmVkdWNlKChhY2MsIFt0eXBlXSkgPT4gYWNjICsgKHR5cGUgPyAxIDogMCksIDApO1xuICB9XG4gIGdldCBzb3VyY2VCdWZmZXJUeXBlcygpIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2VCdWZmZXJzLm1hcCgoW3R5cGVdKSA9PiB0eXBlKS5maWx0ZXIodHlwZSA9PiAhIXR5cGUpO1xuICB9XG4gIGFkZEJ1ZmZlckxpc3RlbmVyKHR5cGUsIGV2ZW50LCBmbikge1xuICAgIGNvbnN0IHRyYWNrID0gdGhpcy50cmFja3NbdHlwZV07XG4gICAgaWYgKCF0cmFjaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBidWZmZXIgPSB0cmFjay5idWZmZXI7XG4gICAgaWYgKCFidWZmZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGlzdGVuZXIgPSBmbi5iaW5kKHRoaXMsIHR5cGUpO1xuICAgIHRyYWNrLmxpc3RlbmVycy5wdXNoKHtcbiAgICAgIGV2ZW50LFxuICAgICAgbGlzdGVuZXJcbiAgICB9KTtcbiAgICBidWZmZXIuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpO1xuICB9XG4gIHJlbW92ZUJ1ZmZlckxpc3RlbmVycyh0eXBlKSB7XG4gICAgY29uc3QgdHJhY2sgPSB0aGlzLnRyYWNrc1t0eXBlXTtcbiAgICBpZiAoIXRyYWNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlciA9IHRyYWNrLmJ1ZmZlcjtcbiAgICBpZiAoIWJ1ZmZlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cmFjay5saXN0ZW5lcnMuZm9yRWFjaChsID0+IHtcbiAgICAgIGJ1ZmZlci5yZW1vdmVFdmVudExpc3RlbmVyKGwuZXZlbnQsIGwubGlzdGVuZXIpO1xuICAgIH0pO1xuICAgIHRyYWNrLmxpc3RlbmVycy5sZW5ndGggPSAwO1xuICB9XG59XG5mdW5jdGlvbiByZW1vdmVTb3VyY2VDaGlsZHJlbihub2RlKSB7XG4gIGNvbnN0IHNvdXJjZUNoaWxkcmVuID0gbm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdzb3VyY2UnKTtcbiAgW10uc2xpY2UuY2FsbChzb3VyY2VDaGlsZHJlbikuZm9yRWFjaChzb3VyY2UgPT4ge1xuICAgIG5vZGUucmVtb3ZlQ2hpbGQoc291cmNlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBhZGRTb3VyY2UobWVkaWEsIHVybCkge1xuICBjb25zdCBzb3VyY2UgPSBzZWxmLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NvdXJjZScpO1xuICBzb3VyY2UudHlwZSA9ICd2aWRlby9tcDQnO1xuICBzb3VyY2Uuc3JjID0gdXJsO1xuICBtZWRpYS5hcHBlbmRDaGlsZChzb3VyY2UpO1xufVxuZnVuY3Rpb24gc291cmNlQnVmZmVyTmFtZVRvSW5kZXgodHlwZSkge1xuICByZXR1cm4gdHlwZSA9PT0gJ2F1ZGlvJyA/IDEgOiAwO1xufVxuXG5jbGFzcyBDYXBMZXZlbENvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSB2b2lkIDA7XG4gICAgdGhpcy5maXJzdExldmVsID0gdm9pZCAwO1xuICAgIHRoaXMubWVkaWEgPSB2b2lkIDA7XG4gICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzID0gdm9pZCAwO1xuICAgIHRoaXMudGltZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jbGllbnRSZWN0ID0gdm9pZCAwO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgdGhpcy5maXJzdExldmVsID0gLTE7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzID0gW107XG4gICAgdGhpcy50aW1lciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNsaWVudFJlY3QgPSBudWxsO1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICBzZXRTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXIpIHtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIgPSBzdHJlYW1Db250cm9sbGVyO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuaGxzKSB7XG4gICAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcigpO1xuICAgIH1cbiAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgdGhpcy5zdG9wQ2FwcGluZygpO1xuICAgIH1cbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLmNsaWVudFJlY3QgPSBudWxsO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmhscyA9IHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IG51bGw7XG4gIH1cbiAgcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9uKEV2ZW50cy5GUFNfRFJPUF9MRVZFTF9DQVBQSU5HLCB0aGlzLm9uRnBzRHJvcExldmVsQ2FwcGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTFNfVVBEQVRFRCwgdGhpcy5vbkxldmVsc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0NPREVDUywgdGhpcy5vbkJ1ZmZlckNvZGVjcywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gIH1cbiAgdW5yZWdpc3Rlckxpc3RlbmVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vZmYoRXZlbnRzLkZQU19EUk9QX0xFVkVMX0NBUFBJTkcsIHRoaXMub25GcHNEcm9wTGV2ZWxDYXBwaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMU19VUERBVEVELCB0aGlzLm9uTGV2ZWxzVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0NPREVDUywgdGhpcy5vbkJ1ZmZlckNvZGVjcywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICB9XG4gIG9uRnBzRHJvcExldmVsQ2FwcGluZyhldmVudCwgZGF0YSkge1xuICAgIC8vIERvbid0IGFkZCBhIHJlc3RyaWN0ZWQgbGV2ZWwgbW9yZSB0aGFuIG9uY2VcbiAgICBjb25zdCBsZXZlbCA9IHRoaXMuaGxzLmxldmVsc1tkYXRhLmRyb3BwZWRMZXZlbF07XG4gICAgaWYgKHRoaXMuaXNMZXZlbEFsbG93ZWQobGV2ZWwpKSB7XG4gICAgICB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMucHVzaCh7XG4gICAgICAgIGJpdHJhdGU6IGxldmVsLmJpdHJhdGUsXG4gICAgICAgIGhlaWdodDogbGV2ZWwuaGVpZ2h0LFxuICAgICAgICB3aWR0aDogbGV2ZWwud2lkdGhcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBvbk1lZGlhQXR0YWNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5tZWRpYSA9IGRhdGEubWVkaWEgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50ID8gZGF0YS5tZWRpYSA6IG51bGw7XG4gICAgdGhpcy5jbGllbnRSZWN0ID0gbnVsbDtcbiAgICBpZiAodGhpcy50aW1lciAmJiB0aGlzLmhscy5sZXZlbHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmRldGVjdFBsYXllclNpemUoKTtcbiAgICB9XG4gIH1cbiAgb25NYW5pZmVzdFBhcnNlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIHRoaXMucmVzdHJpY3RlZExldmVscyA9IFtdO1xuICAgIHRoaXMuZmlyc3RMZXZlbCA9IGRhdGEuZmlyc3RMZXZlbDtcbiAgICBpZiAoaGxzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSAmJiBkYXRhLnZpZGVvKSB7XG4gICAgICAvLyBTdGFydCBjYXBwaW5nIGltbWVkaWF0ZWx5IGlmIHRoZSBtYW5pZmVzdCBoYXMgc2lnbmFsZWQgdmlkZW8gY29kZWNzXG4gICAgICB0aGlzLnN0YXJ0Q2FwcGluZygpO1xuICAgIH1cbiAgfVxuICBvbkxldmVsc1VwZGF0ZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBpZiAodGhpcy50aW1lciAmJiBpc0Zpbml0ZU51bWJlcih0aGlzLmF1dG9MZXZlbENhcHBpbmcpKSB7XG4gICAgICB0aGlzLmRldGVjdFBsYXllclNpemUoKTtcbiAgICB9XG4gIH1cblxuICAvLyBPbmx5IGFjdGl2YXRlIGNhcHBpbmcgd2hlbiBwbGF5aW5nIGEgdmlkZW8gc3RyZWFtOyBvdGhlcndpc2UsIG11bHRpLWJpdHJhdGUgYXVkaW8tb25seSBzdHJlYW1zIHdpbGwgYmUgcmVzdHJpY3RlZFxuICAvLyB0byB0aGUgZmlyc3QgbGV2ZWxcbiAgb25CdWZmZXJDb2RlY3MoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBpZiAoaGxzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSAmJiBkYXRhLnZpZGVvKSB7XG4gICAgICAvLyBJZiB0aGUgbWFuaWZlc3QgZGlkIG5vdCBzaWduYWwgYSB2aWRlbyBjb2RlYyBjYXBwaW5nIGhhcyBiZWVuIGRlZmVycmVkIHVudGlsIHdlJ3JlIGNlcnRhaW4gdmlkZW8gaXMgcHJlc2VudFxuICAgICAgdGhpcy5zdGFydENhcHBpbmcoKTtcbiAgICB9XG4gIH1cbiAgb25NZWRpYURldGFjaGluZygpIHtcbiAgICB0aGlzLnN0b3BDYXBwaW5nKCk7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gIH1cbiAgZGV0ZWN0UGxheWVyU2l6ZSgpIHtcbiAgICBpZiAodGhpcy5tZWRpYSkge1xuICAgICAgaWYgKHRoaXMubWVkaWFIZWlnaHQgPD0gMCB8fCB0aGlzLm1lZGlhV2lkdGggPD0gMCkge1xuICAgICAgICB0aGlzLmNsaWVudFJlY3QgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBsZXZlbHMgPSB0aGlzLmhscy5sZXZlbHM7XG4gICAgICBpZiAobGV2ZWxzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICAgICAgY29uc3QgbWF4TGV2ZWwgPSB0aGlzLmdldE1heExldmVsKGxldmVscy5sZW5ndGggLSAxKTtcbiAgICAgICAgaWYgKG1heExldmVsICE9PSB0aGlzLmF1dG9MZXZlbENhcHBpbmcpIHtcbiAgICAgICAgICBobHMubG9nZ2VyLmxvZyhgU2V0dGluZyBhdXRvTGV2ZWxDYXBwaW5nIHRvICR7bWF4TGV2ZWx9OiAke2xldmVsc1ttYXhMZXZlbF0uaGVpZ2h0fXBAJHtsZXZlbHNbbWF4TGV2ZWxdLmJpdHJhdGV9IGZvciBtZWRpYSAke3RoaXMubWVkaWFXaWR0aH14JHt0aGlzLm1lZGlhSGVpZ2h0fWApO1xuICAgICAgICB9XG4gICAgICAgIGhscy5hdXRvTGV2ZWxDYXBwaW5nID0gbWF4TGV2ZWw7XG4gICAgICAgIGlmIChobHMuYXV0b0xldmVsRW5hYmxlZCAmJiBobHMuYXV0b0xldmVsQ2FwcGluZyA+IHRoaXMuYXV0b0xldmVsQ2FwcGluZyAmJiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAvLyBpZiBhdXRvIGxldmVsIGNhcHBpbmcgaGFzIGEgaGlnaGVyIHZhbHVlIGZvciB0aGUgcHJldmlvdXMgb25lLCBmbHVzaCB0aGUgYnVmZmVyIHVzaW5nIG5leHRMZXZlbFN3aXRjaFxuICAgICAgICAgIC8vIHVzdWFsbHkgaGFwcGVuIHdoZW4gdGhlIHVzZXIgZ28gdG8gdGhlIGZ1bGxzY3JlZW4gbW9kZS5cbiAgICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gaGxzLmF1dG9MZXZlbENhcHBpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLypcbiAgICogcmV0dXJucyBsZXZlbCBzaG91bGQgYmUgdGhlIG9uZSB3aXRoIHRoZSBkaW1lbnNpb25zIGVxdWFsIG9yIGdyZWF0ZXIgdGhhbiB0aGUgbWVkaWEgKHBsYXllcikgZGltZW5zaW9ucyAoc28gdGhlIHZpZGVvIHdpbGwgYmUgZG93bnNjYWxlZClcbiAgICovXG4gIGdldE1heExldmVsKGNhcExldmVsSW5kZXgpIHtcbiAgICBjb25zdCBsZXZlbHMgPSB0aGlzLmhscy5sZXZlbHM7XG4gICAgaWYgKCFsZXZlbHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGNvbnN0IHZhbGlkTGV2ZWxzID0gbGV2ZWxzLmZpbHRlcigobGV2ZWwsIGluZGV4KSA9PiB0aGlzLmlzTGV2ZWxBbGxvd2VkKGxldmVsKSAmJiBpbmRleCA8PSBjYXBMZXZlbEluZGV4KTtcbiAgICB0aGlzLmNsaWVudFJlY3QgPSBudWxsO1xuICAgIHJldHVybiBDYXBMZXZlbENvbnRyb2xsZXIuZ2V0TWF4TGV2ZWxCeU1lZGlhU2l6ZSh2YWxpZExldmVscywgdGhpcy5tZWRpYVdpZHRoLCB0aGlzLm1lZGlhSGVpZ2h0KTtcbiAgfVxuICBzdGFydENhcHBpbmcoKSB7XG4gICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgIC8vIERvbid0IHJlc2V0IGNhcHBpbmcgaWYgc3RhcnRlZCB0d2ljZTsgdGhpcyBjYW4gaGFwcGVuIGlmIHRoZSBtYW5pZmVzdCBzaWduYWxzIGEgdmlkZW8gY29kZWNcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICB0aGlzLnRpbWVyID0gc2VsZi5zZXRJbnRlcnZhbCh0aGlzLmRldGVjdFBsYXllclNpemUuYmluZCh0aGlzKSwgMTAwMCk7XG4gICAgdGhpcy5kZXRlY3RQbGF5ZXJTaXplKCk7XG4gIH1cbiAgc3RvcENhcHBpbmcoKSB7XG4gICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzID0gW107XG4gICAgdGhpcy5maXJzdExldmVsID0gLTE7XG4gICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICBzZWxmLmNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICB0aGlzLnRpbWVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICBnZXREaW1lbnNpb25zKCkge1xuICAgIGlmICh0aGlzLmNsaWVudFJlY3QpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsaWVudFJlY3Q7XG4gICAgfVxuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBjb25zdCBib3VuZHNSZWN0ID0ge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgY29uc3QgY2xpZW50UmVjdCA9IG1lZGlhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgYm91bmRzUmVjdC53aWR0aCA9IGNsaWVudFJlY3Qud2lkdGg7XG4gICAgICBib3VuZHNSZWN0LmhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0O1xuICAgICAgaWYgKCFib3VuZHNSZWN0LndpZHRoICYmICFib3VuZHNSZWN0LmhlaWdodCkge1xuICAgICAgICAvLyBXaGVuIHRoZSBtZWRpYSBlbGVtZW50IGhhcyBubyB3aWR0aCBvciBoZWlnaHQgKGVxdWl2YWxlbnQgdG8gbm90IGJlaW5nIGluIHRoZSBET00pLFxuICAgICAgICAvLyB0aGVuIHVzZSBpdHMgd2lkdGggYW5kIGhlaWdodCBhdHRyaWJ1dGVzIChtZWRpYS53aWR0aCwgbWVkaWEuaGVpZ2h0KVxuICAgICAgICBib3VuZHNSZWN0LndpZHRoID0gY2xpZW50UmVjdC5yaWdodCAtIGNsaWVudFJlY3QubGVmdCB8fCBtZWRpYS53aWR0aCB8fCAwO1xuICAgICAgICBib3VuZHNSZWN0LmhlaWdodCA9IGNsaWVudFJlY3QuYm90dG9tIC0gY2xpZW50UmVjdC50b3AgfHwgbWVkaWEuaGVpZ2h0IHx8IDA7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY2xpZW50UmVjdCA9IGJvdW5kc1JlY3Q7XG4gICAgcmV0dXJuIGJvdW5kc1JlY3Q7XG4gIH1cbiAgZ2V0IG1lZGlhV2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGltZW5zaW9ucygpLndpZHRoICogdGhpcy5jb250ZW50U2NhbGVGYWN0b3I7XG4gIH1cbiAgZ2V0IG1lZGlhSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmdldERpbWVuc2lvbnMoKS5oZWlnaHQgKiB0aGlzLmNvbnRlbnRTY2FsZUZhY3RvcjtcbiAgfVxuICBnZXQgY29udGVudFNjYWxlRmFjdG9yKCkge1xuICAgIGxldCBwaXhlbFJhdGlvID0gMTtcbiAgICBpZiAoIXRoaXMuaGxzLmNvbmZpZy5pZ25vcmVEZXZpY2VQaXhlbFJhdGlvKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwaXhlbFJhdGlvID0gc2VsZi5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvKiBuby1vcCAqL1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gTWF0aC5taW4ocGl4ZWxSYXRpbywgdGhpcy5obHMuY29uZmlnLm1heERldmljZVBpeGVsUmF0aW8pO1xuICB9XG4gIGlzTGV2ZWxBbGxvd2VkKGxldmVsKSB7XG4gICAgY29uc3QgcmVzdHJpY3RlZExldmVscyA9IHRoaXMucmVzdHJpY3RlZExldmVscztcbiAgICByZXR1cm4gIXJlc3RyaWN0ZWRMZXZlbHMuc29tZShyZXN0cmljdGVkTGV2ZWwgPT4ge1xuICAgICAgcmV0dXJuIGxldmVsLmJpdHJhdGUgPT09IHJlc3RyaWN0ZWRMZXZlbC5iaXRyYXRlICYmIGxldmVsLndpZHRoID09PSByZXN0cmljdGVkTGV2ZWwud2lkdGggJiYgbGV2ZWwuaGVpZ2h0ID09PSByZXN0cmljdGVkTGV2ZWwuaGVpZ2h0O1xuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXRNYXhMZXZlbEJ5TWVkaWFTaXplKGxldmVscywgd2lkdGgsIGhlaWdodCkge1xuICAgIGlmICghKGxldmVscyAhPSBudWxsICYmIGxldmVscy5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLy8gTGV2ZWxzIGNhbiBoYXZlIHRoZSBzYW1lIGRpbWVuc2lvbnMgYnV0IGRpZmZlcmluZyBiYW5kd2lkdGhzIC0gc2luY2UgbGV2ZWxzIGFyZSBvcmRlcmVkLCB3ZSBjYW4gbG9vayB0byB0aGUgbmV4dFxuICAgIC8vIHRvIGRldGVybWluZSB3aGV0aGVyIHdlJ3ZlIGNob3NlbiB0aGUgZ3JlYXRlc3QgYmFuZHdpZHRoIGZvciB0aGUgbWVkaWEncyBkaW1lbnNpb25zXG4gICAgY29uc3QgYXRHcmVhdGVzdEJhbmR3aWR0aCA9IChjdXJMZXZlbCwgbmV4dExldmVsKSA9PiB7XG4gICAgICBpZiAoIW5leHRMZXZlbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdXJMZXZlbC53aWR0aCAhPT0gbmV4dExldmVsLndpZHRoIHx8IGN1ckxldmVsLmhlaWdodCAhPT0gbmV4dExldmVsLmhlaWdodDtcbiAgICB9O1xuXG4gICAgLy8gSWYgd2UgcnVuIHRocm91Z2ggdGhlIGxvb3Agd2l0aG91dCBicmVha2luZywgdGhlIG1lZGlhJ3MgZGltZW5zaW9ucyBhcmUgZ3JlYXRlciB0aGFuIGV2ZXJ5IGxldmVsLCBzbyBkZWZhdWx0IHRvXG4gICAgLy8gdGhlIG1heCBsZXZlbFxuICAgIGxldCBtYXhMZXZlbEluZGV4ID0gbGV2ZWxzLmxlbmd0aCAtIDE7XG4gICAgLy8gUHJldmVudCBjaGFuZ2VzIGluIGFzcGVjdC1yYXRpbyBmcm9tIGNhdXNpbmcgY2FwcGluZyB0byB0b2dnbGUgYmFjayBhbmQgZm9ydGhcbiAgICBjb25zdCBzcXVhcmVTaXplID0gTWF0aC5tYXgod2lkdGgsIGhlaWdodCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IGxldmVsID0gbGV2ZWxzW2ldO1xuICAgICAgaWYgKChsZXZlbC53aWR0aCA+PSBzcXVhcmVTaXplIHx8IGxldmVsLmhlaWdodCA+PSBzcXVhcmVTaXplKSAmJiBhdEdyZWF0ZXN0QmFuZHdpZHRoKGxldmVsLCBsZXZlbHNbaSArIDFdKSkge1xuICAgICAgICBtYXhMZXZlbEluZGV4ID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXhMZXZlbEluZGV4O1xuICB9XG59XG5cbi8qKlxuICogQ29tbW9uIE1lZGlhIE9iamVjdCBUeXBlXG4gKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IENtT2JqZWN0VHlwZSA9IHtcbiAgLyoqXG4gICAqIHRleHQgZmlsZSwgc3VjaCBhcyBhIG1hbmlmZXN0IG9yIHBsYXlsaXN0XG4gICAqL1xuICBNQU5JRkVTVDogJ20nLFxuICAvKipcbiAgICogYXVkaW8gb25seVxuICAgKi9cbiAgQVVESU86ICdhJyxcbiAgLyoqXG4gICAqIHZpZGVvIG9ubHlcbiAgICovXG4gIFZJREVPOiAndicsXG4gIC8qKlxuICAgKiBtdXhlZCBhdWRpbyBhbmQgdmlkZW9cbiAgICovXG4gIE1VWEVEOiAnYXYnLFxuICAvKipcbiAgICogaW5pdCBzZWdtZW50XG4gICAqL1xuICBJTklUOiAnaScsXG4gIC8qKlxuICAgKiBjYXB0aW9uIG9yIHN1YnRpdGxlXG4gICAqL1xuICBDQVBUSU9OOiAnYycsXG4gIC8qKlxuICAgKiBJU09CTUZGIHRpbWVkIHRleHQgdHJhY2tcbiAgICovXG4gIFRJTUVEX1RFWFQ6ICd0dCcsXG4gIC8qKlxuICAgKiBjcnlwdG9ncmFwaGljIGtleSwgbGljZW5zZSBvciBjZXJ0aWZpY2F0ZS5cbiAgICovXG4gIEtFWTogJ2snLFxuICAvKipcbiAgICogb3RoZXJcbiAgICovXG4gIE9USEVSOiAnbydcbn07XG5cbi8qKlxuICogQ29tbW9uIE1lZGlhIENsaWVudCBEYXRhIE9iamVjdCBUeXBlXG4gKlxuICogQGdyb3VwIENNQ0RcbiAqXG4gKiBAYmV0YVxuICpcbiAqIEBlbnVtXG4gKi9cbmNvbnN0IENtY2RPYmplY3RUeXBlID0gQ21PYmplY3RUeXBlO1xuXG4vKipcbiAqIENvbW1vbiBNZWRpYSBTdHJlYW1pbmcgRm9ybWF0XG4gKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IENtU3RyZWFtaW5nRm9ybWF0ID0ge1xuICAvKipcbiAgICogSFRUUCBMaXZlIFN0cmVhbWluZyAoSExTKVxuICAgKi9cbiAgSExTOiAnaCd9O1xuXG4vKipcbiAqIENvbW1vbiBNZWRpYSBDbGllbnQgRGF0YSBTdHJlYW1pbmcgRm9ybWF0XG4gKlxuICogQGdyb3VwIENNQ0RcbiAqXG4gKiBAZW51bVxuICpcbiAqIEBiZXRhXG4gKi9cbmNvbnN0IENtY2RTdHJlYW1pbmdGb3JtYXQgPSBDbVN0cmVhbWluZ0Zvcm1hdDtcblxuLyoqXG4gKiBDTUNEIG9iamVjdCBoZWFkZXIgbmFtZS5cbiAqXG4gKiBAZ3JvdXAgQ01DRFxuICpcbiAqIEBiZXRhXG4gKi9cbmNvbnN0IENNQ0RfT0JKRUNUID0gJ0NNQ0QtT2JqZWN0JztcblxuLyoqXG4gKiBDTUNEIHJlcXVlc3QgaGVhZGVyIG5hbWUuXG4gKlxuICogQGdyb3VwIENNQ0RcbiAqXG4gKiBAYmV0YVxuICovXG5jb25zdCBDTUNEX1JFUVVFU1QgPSAnQ01DRC1SZXF1ZXN0JztcblxuLyoqXG4gKiBDTUNEIHNlc3Npb24gaGVhZGVyIG5hbWUuXG4gKlxuICogQGdyb3VwIENNQ0RcbiAqXG4gKiBAYmV0YVxuICovXG5jb25zdCBDTUNEX1NFU1NJT04gPSAnQ01DRC1TZXNzaW9uJztcblxuLyoqXG4gKiBDTUNEIHN0YXR1cyBoZWFkZXIgbmFtZS5cbiAqXG4gKiBAZ3JvdXAgQ01DRFxuICpcbiAqIEBiZXRhXG4gKi9cbmNvbnN0IENNQ0RfU1RBVFVTID0gJ0NNQ0QtU3RhdHVzJztcblxuLyoqXG4gKiBDTUNEIGhlYWRlciBmaWVsZHMuXG4gKlxuICogQGdyb3VwIENNQ0RcbiAqXG4gKiBAZW51bVxuICpcbiAqIEBiZXRhXG4gKi9cbmNvbnN0IENtY2RIZWFkZXJGaWVsZCA9IHtcbiAgLyoqXG4gICAqIGtleXMgd2hvc2UgdmFsdWVzIHZhcnkgd2l0aCB0aGUgb2JqZWN0IGJlaW5nIHJlcXVlc3RlZC5cbiAgICovXG4gIE9CSkVDVDogQ01DRF9PQkpFQ1QsXG4gIC8qKlxuICAgKiBrZXlzIHdob3NlIHZhbHVlcyB2YXJ5IHdpdGggZWFjaCByZXF1ZXN0LlxuICAgKi9cbiAgUkVRVUVTVDogQ01DRF9SRVFVRVNULFxuICAvKipcbiAgICoga2V5cyB3aG9zZSB2YWx1ZXMgYXJlIGV4cGVjdGVkIHRvIGJlIGludmFyaWFudCBvdmVyIHRoZSBsaWZlIG9mIHRoZSBzZXNzaW9uLlxuICAgKi9cbiAgU0VTU0lPTjogQ01DRF9TRVNTSU9OLFxuICAvKipcbiAgICoga2V5cyB3aG9zZSB2YWx1ZXMgZG8gbm90IHZhcnkgd2l0aCBldmVyeSByZXF1ZXN0IG9yIG9iamVjdC5cbiAgICovXG4gIFNUQVRVUzogQ01DRF9TVEFUVVNcbn07XG5cbi8qKlxuICogVGhlIG1hcCBvZiBDTUNEIGhlYWRlciBmaWVsZHMgdG8gb2ZmaWNpYWwgQ01DRCBrZXlzLlxuICpcbiAqIEBpbnRlcm5hbFxuICpcbiAqIEBncm91cCBDTUNEXG4gKi9cbmNvbnN0IENtY2RIZWFkZXJNYXAgPSB7XG4gIFtDbWNkSGVhZGVyRmllbGQuT0JKRUNUXTogWydicicsICdhYicsICdkJywgJ290JywgJ3RiJywgJ3RwYicsICdsYicsICd0YWInLCAnbGFiJywgJ3VybCddLFxuICBbQ21jZEhlYWRlckZpZWxkLlJFUVVFU1RdOiBbJ3BiJywgJ2JsJywgJ3RibCcsICdkbCcsICdsdGMnLCAnbXRwJywgJ25vcicsICducnInLCAncmMnLCAnc24nLCAnc3RhJywgJ3N1JywgJ3R0ZmInLCAndHRmYmInLCAndHRsYicsICdjbXNkZCcsICdjbXNkcycsICdzbXJ0JywgJ2RmJywgJ2NzJ10sXG4gIFtDbWNkSGVhZGVyRmllbGQuU0VTU0lPTl06IFsnY2lkJywgJ3ByJywgJ3NmJywgJ3NpZCcsICdzdCcsICd2JywgJ21zZCddLFxuICBbQ21jZEhlYWRlckZpZWxkLlNUQVRVU106IFsnYnMnLCAnYnNkJywgJ2NkbicsICdydHAnLCAnYmcnLCAncHQnLCAnZWMnLCAnZSddXG59O1xuXG4vKipcbiAqIFN0cnVjdHVyZWQgRmllbGQgSXRlbVxuICpcbiAqIEBncm91cCBTdHJ1Y3R1cmVkIEZpZWxkXG4gKlxuICogQGJldGFcbiAqL1xuY2xhc3MgU2ZJdGVtIHtcbiAgY29uc3RydWN0b3IodmFsdWUsIHBhcmFtcykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAodiA9PiB2IGluc3RhbmNlb2YgU2ZJdGVtID8gdiA6IG5ldyBTZkl0ZW0odikpO1xuICAgIH1cbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gIH1cbn1cblxuY29uc3QgRElDVCA9ICdEaWN0JztcblxuZnVuY3Rpb24gZm9ybWF0KHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gIH1cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgcmV0dXJuICdNYXB7fSc7XG4gIH1cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgcmV0dXJuICdTZXR7fSc7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICB9XG4gIHJldHVybiBTdHJpbmcodmFsdWUpO1xufVxuZnVuY3Rpb24gdGhyb3dFcnJvcihhY3Rpb24sIHNyYywgdHlwZSwgY2F1c2UpIHtcbiAgcmV0dXJuIG5ldyBFcnJvcihgZmFpbGVkIHRvICR7YWN0aW9ufSBcIiR7Zm9ybWF0KHNyYyl9XCIgYXMgJHt0eXBlfWAsIHtcbiAgICBjYXVzZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplRXJyb3Ioc3JjLCB0eXBlLCBjYXVzZSkge1xuICByZXR1cm4gdGhyb3dFcnJvcignc2VyaWFsaXplJywgc3JjLCB0eXBlLCBjYXVzZSk7XG59XG5cbi8qKlxuICogQSBjbGFzcyB0byByZXByZXNlbnQgc3RydWN0dXJlZCBmaWVsZCB0b2tlbnMgd2hlbiBgU3ltYm9sYCBpcyBub3QgYXZhaWxhYmxlLlxuICpcbiAqIEBncm91cCBTdHJ1Y3R1cmVkIEZpZWxkXG4gKlxuICogQGJldGFcbiAqL1xuY2xhc3MgU2ZUb2tlbiB7XG4gIGNvbnN0cnVjdG9yKGRlc2NyaXB0aW9uKSB7XG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICB9XG59XG5cbmNvbnN0IEJBUkVfSVRFTSA9ICdCYXJlIEl0ZW0nO1xuXG5jb25zdCBCT09MRUFOID0gJ0Jvb2xlYW4nO1xuXG4vLyA0LjEuOS4gIFNlcmlhbGl6aW5nIGEgQm9vbGVhblxuLy9cbi8vIEdpdmVuIGEgQm9vbGVhbiBhcyBpbnB1dF9ib29sZWFuLCByZXR1cm4gYW4gQVNDSUkgc3RyaW5nIHN1aXRhYmxlIGZvclxuLy8gdXNlIGluIGEgSFRUUCBmaWVsZCB2YWx1ZS5cbi8vXG4vLyAxLiAgSWYgaW5wdXRfYm9vbGVhbiBpcyBub3QgYSBib29sZWFuLCBmYWlsIHNlcmlhbGl6YXRpb24uXG4vL1xuLy8gMi4gIExldCBvdXRwdXQgYmUgYW4gZW1wdHkgc3RyaW5nLlxuLy9cbi8vIDMuICBBcHBlbmQgXCI/XCIgdG8gb3V0cHV0LlxuLy9cbi8vIDQuICBJZiBpbnB1dF9ib29sZWFuIGlzIHRydWUsIGFwcGVuZCBcIjFcIiB0byBvdXRwdXQuXG4vL1xuLy8gNS4gIElmIGlucHV0X2Jvb2xlYW4gaXMgZmFsc2UsIGFwcGVuZCBcIjBcIiB0byBvdXRwdXQuXG4vL1xuLy8gNi4gIFJldHVybiBvdXRwdXQuXG5mdW5jdGlvbiBzZXJpYWxpemVCb29sZWFuKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJykge1xuICAgIHRocm93IHNlcmlhbGl6ZUVycm9yKHZhbHVlLCBCT09MRUFOKTtcbiAgfVxuICByZXR1cm4gdmFsdWUgPyAnPzEnIDogJz8wJztcbn1cblxuLyoqXG4gKiBFbmNvZGVzIGJpbmFyeSBkYXRhIHRvIGJhc2U2NFxuICpcbiAqIEBwYXJhbSBiaW5hcnkgLSBUaGUgYmluYXJ5IGRhdGEgdG8gZW5jb2RlXG4gKiBAcmV0dXJucyBUaGUgYmFzZTY0IGVuY29kZWQgc3RyaW5nXG4gKlxuICogQGdyb3VwIFV0aWxzXG4gKlxuICogQGJldGFcbiAqL1xuZnVuY3Rpb24gZW5jb2RlQmFzZTY0KGJpbmFyeSkge1xuICByZXR1cm4gYnRvYShTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLmJpbmFyeSkpO1xufVxuXG5jb25zdCBCWVRFUyA9ICdCeXRlIFNlcXVlbmNlJztcblxuLy8gNC4xLjguICBTZXJpYWxpemluZyBhIEJ5dGUgU2VxdWVuY2Vcbi8vXG4vLyBHaXZlbiBhIEJ5dGUgU2VxdWVuY2UgYXMgaW5wdXRfYnl0ZXMsIHJldHVybiBhbiBBU0NJSSBzdHJpbmcgc3VpdGFibGVcbi8vIGZvciB1c2UgaW4gYSBIVFRQIGZpZWxkIHZhbHVlLlxuLy9cbi8vIDEuICBJZiBpbnB1dF9ieXRlcyBpcyBub3QgYSBzZXF1ZW5jZSBvZiBieXRlcywgZmFpbCBzZXJpYWxpemF0aW9uLlxuLy9cbi8vIDIuICBMZXQgb3V0cHV0IGJlIGFuIGVtcHR5IHN0cmluZy5cbi8vXG4vLyAzLiAgQXBwZW5kIFwiOlwiIHRvIG91dHB1dC5cbi8vXG4vLyA0LiAgQXBwZW5kIHRoZSByZXN1bHQgb2YgYmFzZTY0LWVuY29kaW5nIGlucHV0X2J5dGVzIGFzIHBlclxuLy8gICAgIFtSRkM0NjQ4XSwgU2VjdGlvbiA0LCB0YWtpbmcgYWNjb3VudCBvZiB0aGUgcmVxdWlyZW1lbnRzIGJlbG93LlxuLy9cbi8vIDUuICBBcHBlbmQgXCI6XCIgdG8gb3V0cHV0LlxuLy9cbi8vIDYuICBSZXR1cm4gb3V0cHV0LlxuLy9cbi8vIFRoZSBlbmNvZGVkIGRhdGEgaXMgcmVxdWlyZWQgdG8gYmUgcGFkZGVkIHdpdGggXCI9XCIsIGFzIHBlciBbUkZDNDY0OF0sXG4vLyBTZWN0aW9uIDMuMi5cbi8vXG4vLyBMaWtld2lzZSwgZW5jb2RlZCBkYXRhIFNIT1VMRCBoYXZlIHBhZCBiaXRzIHNldCB0byB6ZXJvLCBhcyBwZXJcbi8vIFtSRkM0NjQ4XSwgU2VjdGlvbiAzLjUsIHVubGVzcyBpdCBpcyBub3QgcG9zc2libGUgdG8gZG8gc28gZHVlIHRvXG4vLyBpbXBsZW1lbnRhdGlvbiBjb25zdHJhaW50cy5cbmZ1bmN0aW9uIHNlcmlhbGl6ZUJ5dGVTZXF1ZW5jZSh2YWx1ZSkge1xuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBzZXJpYWxpemVFcnJvcih2YWx1ZSwgQllURVMpO1xuICB9XG4gIHJldHVybiBgOiR7ZW5jb2RlQmFzZTY0KHZhbHVlKX06YDtcbn1cblxuY29uc3QgSU5URUdFUiA9ICdJbnRlZ2VyJztcblxuZnVuY3Rpb24gaXNJbnZhbGlkSW50KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA8IC05OTk5OTk5OTk5OTk5OTkgfHwgOTk5OTk5OTk5OTk5OTk5IDwgdmFsdWU7XG59XG5cbi8vIDQuMS40LiAgU2VyaWFsaXppbmcgYW4gSW50ZWdlclxuLy9cbi8vIEdpdmVuIGFuIEludGVnZXIgYXMgaW5wdXRfaW50ZWdlciwgcmV0dXJuIGFuIEFTQ0lJIHN0cmluZyBzdWl0YWJsZVxuLy8gZm9yIHVzZSBpbiBhIEhUVFAgZmllbGQgdmFsdWUuXG4vL1xuLy8gMS4gIElmIGlucHV0X2ludGVnZXIgaXMgbm90IGFuIGludGVnZXIgaW4gdGhlIHJhbmdlIG9mXG4vLyAgICAgLTk5OSw5OTksOTk5LDk5OSw5OTkgdG8gOTk5LDk5OSw5OTksOTk5LDk5OSBpbmNsdXNpdmUsIGZhaWxcbi8vICAgICBzZXJpYWxpemF0aW9uLlxuLy9cbi8vIDIuICBMZXQgb3V0cHV0IGJlIGFuIGVtcHR5IHN0cmluZy5cbi8vXG4vLyAzLiAgSWYgaW5wdXRfaW50ZWdlciBpcyBsZXNzIHRoYW4gKGJ1dCBub3QgZXF1YWwgdG8pIDAsIGFwcGVuZCBcIi1cIiB0b1xuLy8gICAgIG91dHB1dC5cbi8vXG4vLyA0LiAgQXBwZW5kIGlucHV0X2ludGVnZXIncyBudW1lcmljIHZhbHVlIHJlcHJlc2VudGVkIGluIGJhc2UgMTAgdXNpbmdcbi8vICAgICBvbmx5IGRlY2ltYWwgZGlnaXRzIHRvIG91dHB1dC5cbi8vXG4vLyA1LiAgUmV0dXJuIG91dHB1dC5cbmZ1bmN0aW9uIHNlcmlhbGl6ZUludGVnZXIodmFsdWUpIHtcbiAgaWYgKGlzSW52YWxpZEludCh2YWx1ZSkpIHtcbiAgICB0aHJvdyBzZXJpYWxpemVFcnJvcih2YWx1ZSwgSU5URUdFUik7XG4gIH1cbiAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG59XG5cbi8vIDQuMS4xMC4gIFNlcmlhbGl6aW5nIGEgRGF0ZVxuLy9cbi8vIEdpdmVuIGEgRGF0ZSBhcyBpbnB1dF9pbnRlZ2VyLCByZXR1cm4gYW4gQVNDSUkgc3RyaW5nIHN1aXRhYmxlIGZvclxuLy8gdXNlIGluIGFuIEhUVFAgZmllbGQgdmFsdWUuXG4vLyAxLiAgTGV0IG91dHB1dCBiZSBcIkBcIi5cbi8vIDIuICBBcHBlbmQgdG8gb3V0cHV0IHRoZSByZXN1bHQgb2YgcnVubmluZyBTZXJpYWxpemluZyBhbiBJbnRlZ2VyXG4vLyAgICAgd2l0aCBpbnB1dF9kYXRlIChTZWN0aW9uIDQuMS40KS5cbi8vIDMuICBSZXR1cm4gb3V0cHV0LlxuZnVuY3Rpb24gc2VyaWFsaXplRGF0ZSh2YWx1ZSkge1xuICByZXR1cm4gYEAke3NlcmlhbGl6ZUludGVnZXIodmFsdWUuZ2V0VGltZSgpIC8gMTAwMCl9YDtcbn1cblxuLyoqXG4gKiBUaGlzIGltcGxlbWVudHMgdGhlIHJvdW5kaW5nIHByb2NlZHVyZSBkZXNjcmliZWQgaW4gc3RlcCAyIG9mIHRoZSBcIlNlcmlhbGl6aW5nIGEgRGVjaW1hbFwiIHNwZWNpZmljYXRpb24uXG4gKiBUaGlzIHJvdW5kaW5nIHN0eWxlIGlzIGtub3duIGFzIFwiZXZlbiByb3VuZGluZ1wiLCBcImJhbmtlcidzIHJvdW5kaW5nXCIsIG9yIFwiY29tbWVyY2lhbCByb3VuZGluZ1wiLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byByb3VuZFxuICogQHBhcmFtIHByZWNpc2lvbiAtIFRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdG8gcm91bmQgdG9cbiAqIEByZXR1cm5zIFRoZSByb3VuZGVkIHZhbHVlXG4gKlxuICogQGdyb3VwIFV0aWxzXG4gKlxuICogQGJldGFcbiAqL1xuZnVuY3Rpb24gcm91bmRUb0V2ZW4odmFsdWUsIHByZWNpc2lvbikge1xuICBpZiAodmFsdWUgPCAwKSB7XG4gICAgcmV0dXJuIC1yb3VuZFRvRXZlbigtdmFsdWUsIHByZWNpc2lvbik7XG4gIH1cbiAgY29uc3QgZGVjaW1hbFNoaWZ0ID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbik7XG4gIGNvbnN0IGlzRXF1aWRpc3RhbnQgPSBNYXRoLmFicyh2YWx1ZSAqIGRlY2ltYWxTaGlmdCAlIDEgLSAwLjUpIDwgTnVtYmVyLkVQU0lMT047XG4gIGlmIChpc0VxdWlkaXN0YW50KSB7XG4gICAgLy8gSWYgdGhlIHRhaWwgb2YgdGhlIGRlY2ltYWwgcGxhY2UgaXMgJ2VxdWlkaXN0YW50JyB3ZSByb3VuZCB0byB0aGUgbmVhcmVzdCBldmVuIHZhbHVlXG4gICAgY29uc3QgZmxvb3JlZFZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSAqIGRlY2ltYWxTaGlmdCk7XG4gICAgcmV0dXJuIChmbG9vcmVkVmFsdWUgJSAyID09PSAwID8gZmxvb3JlZFZhbHVlIDogZmxvb3JlZFZhbHVlICsgMSkgLyBkZWNpbWFsU2hpZnQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlLCBwcm9jZWVkIGFzIG5vcm1hbFxuICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogZGVjaW1hbFNoaWZ0KSAvIGRlY2ltYWxTaGlmdDtcbiAgfVxufVxuXG5jb25zdCBERUNJTUFMID0gJ0RlY2ltYWwnO1xuXG4vLyA0LjEuNS4gIFNlcmlhbGl6aW5nIGEgRGVjaW1hbFxuLy9cbi8vIEdpdmVuIGEgZGVjaW1hbCBudW1iZXIgYXMgaW5wdXRfZGVjaW1hbCwgcmV0dXJuIGFuIEFTQ0lJIHN0cmluZ1xuLy8gc3VpdGFibGUgZm9yIHVzZSBpbiBhIEhUVFAgZmllbGQgdmFsdWUuXG4vL1xuLy8gMS4gICBJZiBpbnB1dF9kZWNpbWFsIGlzIG5vdCBhIGRlY2ltYWwgbnVtYmVyLCBmYWlsIHNlcmlhbGl6YXRpb24uXG4vL1xuLy8gMi4gICBJZiBpbnB1dF9kZWNpbWFsIGhhcyBtb3JlIHRoYW4gdGhyZWUgc2lnbmlmaWNhbnQgZGlnaXRzIHRvIHRoZVxuLy8gICAgICByaWdodCBvZiB0aGUgZGVjaW1hbCBwb2ludCwgcm91bmQgaXQgdG8gdGhyZWUgZGVjaW1hbCBwbGFjZXMsXG4vLyAgICAgIHJvdW5kaW5nIHRoZSBmaW5hbCBkaWdpdCB0byB0aGUgbmVhcmVzdCB2YWx1ZSwgb3IgdG8gdGhlIGV2ZW5cbi8vICAgICAgdmFsdWUgaWYgaXQgaXMgZXF1aWRpc3RhbnQuXG4vL1xuLy8gMy4gICBJZiBpbnB1dF9kZWNpbWFsIGhhcyBtb3JlIHRoYW4gMTIgc2lnbmlmaWNhbnQgZGlnaXRzIHRvIHRoZSBsZWZ0XG4vLyAgICAgIG9mIHRoZSBkZWNpbWFsIHBvaW50IGFmdGVyIHJvdW5kaW5nLCBmYWlsIHNlcmlhbGl6YXRpb24uXG4vL1xuLy8gNC4gICBMZXQgb3V0cHV0IGJlIGFuIGVtcHR5IHN0cmluZy5cbi8vXG4vLyA1LiAgIElmIGlucHV0X2RlY2ltYWwgaXMgbGVzcyB0aGFuIChidXQgbm90IGVxdWFsIHRvKSAwLCBhcHBlbmQgXCItXCJcbi8vICAgICAgdG8gb3V0cHV0LlxuLy9cbi8vIDYuICAgQXBwZW5kIGlucHV0X2RlY2ltYWwncyBpbnRlZ2VyIGNvbXBvbmVudCByZXByZXNlbnRlZCBpbiBiYXNlIDEwXG4vLyAgICAgICh1c2luZyBvbmx5IGRlY2ltYWwgZGlnaXRzKSB0byBvdXRwdXQ7IGlmIGl0IGlzIHplcm8sIGFwcGVuZFxuLy8gICAgICBcIjBcIi5cbi8vXG4vLyA3LiAgIEFwcGVuZCBcIi5cIiB0byBvdXRwdXQuXG4vL1xuLy8gOC4gICBJZiBpbnB1dF9kZWNpbWFsJ3MgZnJhY3Rpb25hbCBjb21wb25lbnQgaXMgemVybywgYXBwZW5kIFwiMFwiIHRvXG4vLyAgICAgIG91dHB1dC5cbi8vXG4vLyA5LiAgIE90aGVyd2lzZSwgYXBwZW5kIHRoZSBzaWduaWZpY2FudCBkaWdpdHMgb2YgaW5wdXRfZGVjaW1hbCdzXG4vLyAgICAgIGZyYWN0aW9uYWwgY29tcG9uZW50IHJlcHJlc2VudGVkIGluIGJhc2UgMTAgKHVzaW5nIG9ubHkgZGVjaW1hbFxuLy8gICAgICBkaWdpdHMpIHRvIG91dHB1dC5cbi8vXG4vLyAxMC4gIFJldHVybiBvdXRwdXQuXG5mdW5jdGlvbiBzZXJpYWxpemVEZWNpbWFsKHZhbHVlKSB7XG4gIGNvbnN0IHJvdW5kZWRWYWx1ZSA9IHJvdW5kVG9FdmVuKHZhbHVlLCAzKTsgLy8gcm91bmQgdG8gMyBkZWNpbWFsIHBsYWNlc1xuICBpZiAoTWF0aC5mbG9vcihNYXRoLmFicyhyb3VuZGVkVmFsdWUpKS50b1N0cmluZygpLmxlbmd0aCA+IDEyKSB7XG4gICAgdGhyb3cgc2VyaWFsaXplRXJyb3IodmFsdWUsIERFQ0lNQUwpO1xuICB9XG4gIGNvbnN0IHN0cmluZ1ZhbHVlID0gcm91bmRlZFZhbHVlLnRvU3RyaW5nKCk7XG4gIHJldHVybiBzdHJpbmdWYWx1ZS5pbmNsdWRlcygnLicpID8gc3RyaW5nVmFsdWUgOiBgJHtzdHJpbmdWYWx1ZX0uMGA7XG59XG5cbmNvbnN0IFNUUklORyA9ICdTdHJpbmcnO1xuXG5jb25zdCBTVFJJTkdfUkVHRVggPSAvW1xceDAwLVxceDFmXFx4N2ZdKy87XG5cbi8vIDQuMS42LiAgU2VyaWFsaXppbmcgYSBTdHJpbmdcbi8vXG4vLyBHaXZlbiBhIFN0cmluZyBhcyBpbnB1dF9zdHJpbmcsIHJldHVybiBhbiBBU0NJSSBzdHJpbmcgc3VpdGFibGUgZm9yXG4vLyB1c2UgaW4gYSBIVFRQIGZpZWxkIHZhbHVlLlxuLy9cbi8vIDEuICBDb252ZXJ0IGlucHV0X3N0cmluZyBpbnRvIGEgc2VxdWVuY2Ugb2YgQVNDSUkgY2hhcmFjdGVyczsgaWZcbi8vICAgICBjb252ZXJzaW9uIGZhaWxzLCBmYWlsIHNlcmlhbGl6YXRpb24uXG4vL1xuLy8gMi4gIElmIGlucHV0X3N0cmluZyBjb250YWlucyBjaGFyYWN0ZXJzIGluIHRoZSByYW5nZSAleDAwLTFmIG9yICV4N2Zcbi8vICAgICAoaS5lLiwgbm90IGluIFZDSEFSIG9yIFNQKSwgZmFpbCBzZXJpYWxpemF0aW9uLlxuLy9cbi8vIDMuICBMZXQgb3V0cHV0IGJlIHRoZSBzdHJpbmcgRFFVT1RFLlxuLy9cbi8vIDQuICBGb3IgZWFjaCBjaGFyYWN0ZXIgY2hhciBpbiBpbnB1dF9zdHJpbmc6XG4vL1xuLy8gICAgIDEuICBJZiBjaGFyIGlzIFwiXFxcIiBvciBEUVVPVEU6XG4vL1xuLy8gICAgICAgICAxLiAgQXBwZW5kIFwiXFxcIiB0byBvdXRwdXQuXG4vL1xuLy8gICAgIDIuICBBcHBlbmQgY2hhciB0byBvdXRwdXQuXG4vL1xuLy8gNS4gIEFwcGVuZCBEUVVPVEUgdG8gb3V0cHV0LlxuLy9cbi8vIDYuICBSZXR1cm4gb3V0cHV0LlxuZnVuY3Rpb24gc2VyaWFsaXplU3RyaW5nKHZhbHVlKSB7XG4gIGlmIChTVFJJTkdfUkVHRVgudGVzdCh2YWx1ZSkpIHtcbiAgICB0aHJvdyBzZXJpYWxpemVFcnJvcih2YWx1ZSwgU1RSSU5HKTtcbiAgfVxuICByZXR1cm4gYFwiJHt2YWx1ZS5yZXBsYWNlKC9cXFxcL2csIGBcXFxcXFxcXGApLnJlcGxhY2UoL1wiL2csIGBcXFxcXCJgKX1cImA7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBzeW1ib2wgdG8gYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHN5bWJvbCAtIFRoZSBzeW1ib2wgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJucyBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzeW1ib2wuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHN5bWJvbFRvU3RyKHN5bWJvbCkge1xuICByZXR1cm4gc3ltYm9sLmRlc2NyaXB0aW9uIHx8IHN5bWJvbC50b1N0cmluZygpLnNsaWNlKDcsIC0xKTtcbn1cblxuY29uc3QgVE9LRU4gPSAnVG9rZW4nO1xuXG5mdW5jdGlvbiBzZXJpYWxpemVUb2tlbih0b2tlbikge1xuICBjb25zdCB2YWx1ZSA9IHN5bWJvbFRvU3RyKHRva2VuKTtcbiAgaWYgKC9eKFthLXpBLVoqXSkoWyEjJCUmJyorXFwtLl5fYHx+XFx3Oi9dKikkLy50ZXN0KHZhbHVlKSA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBzZXJpYWxpemVFcnJvcih2YWx1ZSwgVE9LRU4pO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLy8gNC4xLjMuMS4gIFNlcmlhbGl6aW5nIGEgQmFyZSBJdGVtXG4vL1xuLy8gR2l2ZW4gYW4gSXRlbSBhcyBpbnB1dF9pdGVtLCByZXR1cm4gYW4gQVNDSUkgc3RyaW5nIHN1aXRhYmxlIGZvciB1c2Vcbi8vIGluIGEgSFRUUCBmaWVsZCB2YWx1ZS5cbi8vXG4vLyAxLiAgSWYgaW5wdXRfaXRlbSBpcyBhbiBJbnRlZ2VyLCByZXR1cm4gdGhlIHJlc3VsdCBvZiBydW5uaW5nXG4vLyAgICAgU2VyaWFsaXppbmcgYW4gSW50ZWdlciAoU2VjdGlvbiA0LjEuNCkgd2l0aCBpbnB1dF9pdGVtLlxuLy9cbi8vIDIuICBJZiBpbnB1dF9pdGVtIGlzIGEgRGVjaW1hbCwgcmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZ1xuLy8gICAgIFNlcmlhbGl6aW5nIGEgRGVjaW1hbCAoU2VjdGlvbiA0LjEuNSkgd2l0aCBpbnB1dF9pdGVtLlxuLy9cbi8vIDMuICBJZiBpbnB1dF9pdGVtIGlzIGEgU3RyaW5nLCByZXR1cm4gdGhlIHJlc3VsdCBvZiBydW5uaW5nXG4vLyAgICAgU2VyaWFsaXppbmcgYSBTdHJpbmcgKFNlY3Rpb24gNC4xLjYpIHdpdGggaW5wdXRfaXRlbS5cbi8vXG4vLyA0LiAgSWYgaW5wdXRfaXRlbSBpcyBhIFRva2VuLCByZXR1cm4gdGhlIHJlc3VsdCBvZiBydW5uaW5nXG4vLyAgICAgU2VyaWFsaXppbmcgYSBUb2tlbiAoU2VjdGlvbiA0LjEuNykgd2l0aCBpbnB1dF9pdGVtLlxuLy9cbi8vIDUuICBJZiBpbnB1dF9pdGVtIGlzIGEgQm9vbGVhbiwgcmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZ1xuLy8gICAgIFNlcmlhbGl6aW5nIGEgQm9vbGVhbiAoU2VjdGlvbiA0LjEuOSkgd2l0aCBpbnB1dF9pdGVtLlxuLy9cbi8vIDYuICBJZiBpbnB1dF9pdGVtIGlzIGEgQnl0ZSBTZXF1ZW5jZSwgcmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZ1xuLy8gICAgIFNlcmlhbGl6aW5nIGEgQnl0ZSBTZXF1ZW5jZSAoU2VjdGlvbiA0LjEuOCkgd2l0aCBpbnB1dF9pdGVtLlxuLy9cbi8vIDcuICBJZiBpbnB1dF9pdGVtIGlzIGEgRGF0ZSwgcmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZyBTZXJpYWxpemluZ1xuLy8gICAgIGEgRGF0ZSAoU2VjdGlvbiA0LjEuMTApIHdpdGggaW5wdXRfaXRlbS5cbi8vXG4vLyA4LiAgT3RoZXJ3aXNlLCBmYWlsIHNlcmlhbGl6YXRpb24uXG5mdW5jdGlvbiBzZXJpYWxpemVCYXJlSXRlbSh2YWx1ZSkge1xuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBpZiAoIWlzRmluaXRlTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBzZXJpYWxpemVFcnJvcih2YWx1ZSwgQkFSRV9JVEVNKTtcbiAgICAgIH1cbiAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplSW50ZWdlcih2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VyaWFsaXplRGVjaW1hbCh2YWx1ZSk7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiBzZXJpYWxpemVTdHJpbmcodmFsdWUpO1xuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICByZXR1cm4gc2VyaWFsaXplVG9rZW4odmFsdWUpO1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHNlcmlhbGl6ZUJvb2xlYW4odmFsdWUpO1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVEYXRlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZUJ5dGVTZXF1ZW5jZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTZlRva2VuKSB7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVUb2tlbih2YWx1ZSk7XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGZhaWxcbiAgICAgIHRocm93IHNlcmlhbGl6ZUVycm9yKHZhbHVlLCBCQVJFX0lURU0pO1xuICB9XG59XG5cbmNvbnN0IEtFWSA9ICdLZXknO1xuXG4vLyA0LjEuMS4zLiAgU2VyaWFsaXppbmcgYSBLZXlcbi8vXG4vLyBHaXZlbiBhIGtleSBhcyBpbnB1dF9rZXksIHJldHVybiBhbiBBU0NJSSBzdHJpbmcgc3VpdGFibGUgZm9yIHVzZSBpblxuLy8gYSBIVFRQIGZpZWxkIHZhbHVlLlxuLy9cbi8vIDEuICBDb252ZXJ0IGlucHV0X2tleSBpbnRvIGEgc2VxdWVuY2Ugb2YgQVNDSUkgY2hhcmFjdGVyczsgaWZcbi8vICAgICBjb252ZXJzaW9uIGZhaWxzLCBmYWlsIHNlcmlhbGl6YXRpb24uXG4vL1xuLy8gMi4gIElmIGlucHV0X2tleSBjb250YWlucyBjaGFyYWN0ZXJzIG5vdCBpbiBsY2FscGhhLCBESUdJVCwgXCJfXCIsIFwiLVwiLFxuLy8gICAgIFwiLlwiLCBvciBcIipcIiBmYWlsIHNlcmlhbGl6YXRpb24uXG4vL1xuLy8gMy4gIElmIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgaW5wdXRfa2V5IGlzIG5vdCBsY2FscGhhIG9yIFwiKlwiLCBmYWlsXG4vLyAgICAgc2VyaWFsaXphdGlvbi5cbi8vXG4vLyA0LiAgTGV0IG91dHB1dCBiZSBhbiBlbXB0eSBzdHJpbmcuXG4vL1xuLy8gNS4gIEFwcGVuZCBpbnB1dF9rZXkgdG8gb3V0cHV0LlxuLy9cbi8vIDYuICBSZXR1cm4gb3V0cHV0LlxuZnVuY3Rpb24gc2VyaWFsaXplS2V5KHZhbHVlKSB7XG4gIGlmICgvXlthLXoqXVthLXowLTlcXC1fLipdKiQvLnRlc3QodmFsdWUpID09PSBmYWxzZSkge1xuICAgIHRocm93IHNlcmlhbGl6ZUVycm9yKHZhbHVlLCBLRVkpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLy8gNC4xLjEuMi4gIFNlcmlhbGl6aW5nIFBhcmFtZXRlcnNcbi8vXG4vLyBHaXZlbiBhbiBvcmRlcmVkIERpY3Rpb25hcnkgYXMgaW5wdXRfcGFyYW1ldGVycyAoZWFjaCBtZW1iZXIgaGF2aW5nIGFcbi8vIHBhcmFtX25hbWUgYW5kIGEgcGFyYW1fdmFsdWUpLCByZXR1cm4gYW4gQVNDSUkgc3RyaW5nIHN1aXRhYmxlIGZvclxuLy8gdXNlIGluIGEgSFRUUCBmaWVsZCB2YWx1ZS5cbi8vXG4vLyAxLiAgTGV0IG91dHB1dCBiZSBhbiBlbXB0eSBzdHJpbmcuXG4vL1xuLy8gMi4gIEZvciBlYWNoIHBhcmFtX25hbWUgd2l0aCBhIHZhbHVlIG9mIHBhcmFtX3ZhbHVlIGluXG4vLyAgICAgaW5wdXRfcGFyYW1ldGVyczpcbi8vXG4vLyAgICAgMS4gIEFwcGVuZCBcIjtcIiB0byBvdXRwdXQuXG4vL1xuLy8gICAgIDIuICBBcHBlbmQgdGhlIHJlc3VsdCBvZiBydW5uaW5nIFNlcmlhbGl6aW5nIGEgS2V5XG4vLyAgICAgICAgIChTZWN0aW9uIDQuMS4xLjMpIHdpdGggcGFyYW1fbmFtZSB0byBvdXRwdXQuXG4vL1xuLy8gICAgIDMuICBJZiBwYXJhbV92YWx1ZSBpcyBub3QgQm9vbGVhbiB0cnVlOlxuLy9cbi8vICAgICAgICAgMS4gIEFwcGVuZCBcIj1cIiB0byBvdXRwdXQuXG4vL1xuLy8gICAgICAgICAyLiAgQXBwZW5kIHRoZSByZXN1bHQgb2YgcnVubmluZyBTZXJpYWxpemluZyBhIGJhcmUgSXRlbVxuLy8gICAgICAgICAgICAgKFNlY3Rpb24gNC4xLjMuMSkgd2l0aCBwYXJhbV92YWx1ZSB0byBvdXRwdXQuXG4vL1xuLy8gMy4gIFJldHVybiBvdXRwdXQuXG5mdW5jdGlvbiBzZXJpYWxpemVQYXJhbXMocGFyYW1zKSB7XG4gIGlmIChwYXJhbXMgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocGFyYW1zKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGA7JHtzZXJpYWxpemVLZXkoa2V5KX1gOyAvLyBvbWl0IHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGA7JHtzZXJpYWxpemVLZXkoa2V5KX09JHtzZXJpYWxpemVCYXJlSXRlbSh2YWx1ZSl9YDtcbiAgfSkuam9pbignJyk7XG59XG5cbi8vIDQuMS4zLiAgU2VyaWFsaXppbmcgYW4gSXRlbVxuLy9cbi8vIEdpdmVuIGFuIEl0ZW0gYXMgYmFyZV9pdGVtIGFuZCBQYXJhbWV0ZXJzIGFzIGl0ZW1fcGFyYW1ldGVycywgcmV0dXJuXG4vLyBhbiBBU0NJSSBzdHJpbmcgc3VpdGFibGUgZm9yIHVzZSBpbiBhIEhUVFAgZmllbGQgdmFsdWUuXG4vL1xuLy8gMS4gIExldCBvdXRwdXQgYmUgYW4gZW1wdHkgc3RyaW5nLlxuLy9cbi8vIDIuICBBcHBlbmQgdGhlIHJlc3VsdCBvZiBydW5uaW5nIFNlcmlhbGl6aW5nIGEgQmFyZSBJdGVtXG4vLyAgICAgU2VjdGlvbiA0LjEuMy4xIHdpdGggYmFyZV9pdGVtIHRvIG91dHB1dC5cbi8vXG4vLyAzLiAgQXBwZW5kIHRoZSByZXN1bHQgb2YgcnVubmluZyBTZXJpYWxpemluZyBQYXJhbWV0ZXJzXG4vLyAgICAgU2VjdGlvbiA0LjEuMS4yIHdpdGggaXRlbV9wYXJhbWV0ZXJzIHRvIG91dHB1dC5cbi8vXG4vLyA0LiAgUmV0dXJuIG91dHB1dC5cbmZ1bmN0aW9uIHNlcmlhbGl6ZUl0ZW0odmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2ZJdGVtKSB7XG4gICAgcmV0dXJuIGAke3NlcmlhbGl6ZUJhcmVJdGVtKHZhbHVlLnZhbHVlKX0ke3NlcmlhbGl6ZVBhcmFtcyh2YWx1ZS5wYXJhbXMpfWA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZUJhcmVJdGVtKHZhbHVlKTtcbiAgfVxufVxuXG4vLyA0LjEuMS4xLiAgU2VyaWFsaXppbmcgYW4gSW5uZXIgTGlzdFxuLy9cbi8vIEdpdmVuIGFuIGFycmF5IG9mIChtZW1iZXJfdmFsdWUsIHBhcmFtZXRlcnMpIHR1cGxlcyBhcyBpbm5lcl9saXN0LFxuLy8gYW5kIHBhcmFtZXRlcnMgYXMgbGlzdF9wYXJhbWV0ZXJzLCByZXR1cm4gYW4gQVNDSUkgc3RyaW5nIHN1aXRhYmxlXG4vLyBmb3IgdXNlIGluIGEgSFRUUCBmaWVsZCB2YWx1ZS5cbi8vXG4vLyAxLiAgTGV0IG91dHB1dCBiZSB0aGUgc3RyaW5nIFwiKFwiLlxuLy9cbi8vIDIuICBGb3IgZWFjaCAobWVtYmVyX3ZhbHVlLCBwYXJhbWV0ZXJzKSBvZiBpbm5lcl9saXN0OlxuLy9cbi8vICAgICAxLiAgQXBwZW5kIHRoZSByZXN1bHQgb2YgcnVubmluZyBTZXJpYWxpemluZyBhbiBJdGVtXG4vLyAgICAgICAgIChTZWN0aW9uIDQuMS4zKSB3aXRoIChtZW1iZXJfdmFsdWUsIHBhcmFtZXRlcnMpIHRvIG91dHB1dC5cbi8vXG4vLyAgICAgMi4gIElmIG1vcmUgdmFsdWVzIHJlbWFpbiBpbiBpbm5lcl9saXN0LCBhcHBlbmQgYSBzaW5nbGUgU1AgdG9cbi8vICAgICAgICAgb3V0cHV0LlxuLy9cbi8vIDMuICBBcHBlbmQgXCIpXCIgdG8gb3V0cHV0LlxuLy9cbi8vIDQuICBBcHBlbmQgdGhlIHJlc3VsdCBvZiBydW5uaW5nIFNlcmlhbGl6aW5nIFBhcmFtZXRlcnNcbi8vICAgICAoU2VjdGlvbiA0LjEuMS4yKSB3aXRoIGxpc3RfcGFyYW1ldGVycyB0byBvdXRwdXQuXG4vL1xuLy8gNS4gIFJldHVybiBvdXRwdXQuXG5mdW5jdGlvbiBzZXJpYWxpemVJbm5lckxpc3QodmFsdWUpIHtcbiAgcmV0dXJuIGAoJHt2YWx1ZS52YWx1ZS5tYXAoc2VyaWFsaXplSXRlbSkuam9pbignICcpfSkke3NlcmlhbGl6ZVBhcmFtcyh2YWx1ZS5wYXJhbXMpfWA7XG59XG5cbi8vIDQuMS4yLiAgU2VyaWFsaXppbmcgYSBEaWN0aW9uYXJ5XG4vL1xuLy8gR2l2ZW4gYW4gb3JkZXJlZCBEaWN0aW9uYXJ5IGFzIGlucHV0X2RpY3Rpb25hcnkgKGVhY2ggbWVtYmVyIGhhdmluZyBhXG4vLyBtZW1iZXJfbmFtZSBhbmQgYSB0dXBsZSB2YWx1ZSBvZiAobWVtYmVyX3ZhbHVlLCBwYXJhbWV0ZXJzKSksIHJldHVyblxuLy8gYW4gQVNDSUkgc3RyaW5nIHN1aXRhYmxlIGZvciB1c2UgaW4gYSBIVFRQIGZpZWxkIHZhbHVlLlxuLy9cbi8vIDEuICBMZXQgb3V0cHV0IGJlIGFuIGVtcHR5IHN0cmluZy5cbi8vXG4vLyAyLiAgRm9yIGVhY2ggbWVtYmVyX25hbWUgd2l0aCBhIHZhbHVlIG9mIChtZW1iZXJfdmFsdWUsIHBhcmFtZXRlcnMpXG4vLyAgICAgaW4gaW5wdXRfZGljdGlvbmFyeTpcbi8vXG4vLyAgICAgMS4gIEFwcGVuZCB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgU2VyaWFsaXppbmcgYSBLZXlcbi8vICAgICAgICAgKFNlY3Rpb24gNC4xLjEuMykgd2l0aCBtZW1iZXIncyBtZW1iZXJfbmFtZSB0byBvdXRwdXQuXG4vL1xuLy8gICAgIDIuICBJZiBtZW1iZXJfdmFsdWUgaXMgQm9vbGVhbiB0cnVlOlxuLy9cbi8vICAgICAgICAgMS4gIEFwcGVuZCB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgU2VyaWFsaXppbmcgUGFyYW1ldGVyc1xuLy8gICAgICAgICAgICAgKFNlY3Rpb24gNC4xLjEuMikgd2l0aCBwYXJhbWV0ZXJzIHRvIG91dHB1dC5cbi8vXG4vLyAgICAgMy4gIE90aGVyd2lzZTpcbi8vXG4vLyAgICAgICAgIDEuICBBcHBlbmQgXCI9XCIgdG8gb3V0cHV0LlxuLy9cbi8vICAgICAgICAgMi4gIElmIG1lbWJlcl92YWx1ZSBpcyBhbiBhcnJheSwgYXBwZW5kIHRoZSByZXN1bHQgb2YgcnVubmluZ1xuLy8gICAgICAgICAgICAgU2VyaWFsaXppbmcgYW4gSW5uZXIgTGlzdCAoU2VjdGlvbiA0LjEuMS4xKSB3aXRoXG4vLyAgICAgICAgICAgICAobWVtYmVyX3ZhbHVlLCBwYXJhbWV0ZXJzKSB0byBvdXRwdXQuXG4vL1xuLy8gICAgICAgICAzLiAgT3RoZXJ3aXNlLCBhcHBlbmQgdGhlIHJlc3VsdCBvZiBydW5uaW5nIFNlcmlhbGl6aW5nIGFuXG4vLyAgICAgICAgICAgICBJdGVtIChTZWN0aW9uIDQuMS4zKSB3aXRoIChtZW1iZXJfdmFsdWUsIHBhcmFtZXRlcnMpIHRvXG4vLyAgICAgICAgICAgICBvdXRwdXQuXG4vL1xuLy8gICAgIDQuICBJZiBtb3JlIG1lbWJlcnMgcmVtYWluIGluIGlucHV0X2RpY3Rpb25hcnk6XG4vL1xuLy8gICAgICAgICAxLiAgQXBwZW5kIFwiLFwiIHRvIG91dHB1dC5cbi8vXG4vLyAgICAgICAgIDIuICBBcHBlbmQgYSBzaW5nbGUgU1AgdG8gb3V0cHV0LlxuLy9cbi8vIDMuICBSZXR1cm4gb3V0cHV0LlxuZnVuY3Rpb24gc2VyaWFsaXplRGljdChkaWN0LCBvcHRpb25zID0ge1xuICB3aGl0ZXNwYWNlOiB0cnVlXG59KSB7XG4gIGlmICh0eXBlb2YgZGljdCAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBzZXJpYWxpemVFcnJvcihkaWN0LCBESUNUKTtcbiAgfVxuICBjb25zdCBlbnRyaWVzID0gZGljdCBpbnN0YW5jZW9mIE1hcCA/IGRpY3QuZW50cmllcygpIDogT2JqZWN0LmVudHJpZXMoZGljdCk7XG4gIGNvbnN0IG9wdGlvbmFsV2hpdGVTcGFjZSA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMud2hpdGVzcGFjZSkgPyAnICcgOiAnJztcbiAgcmV0dXJuIEFycmF5LmZyb20oZW50cmllcykubWFwKChba2V5LCBpdGVtXSkgPT4ge1xuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgU2ZJdGVtID09PSBmYWxzZSkge1xuICAgICAgaXRlbSA9IG5ldyBTZkl0ZW0oaXRlbSk7XG4gICAgfVxuICAgIGxldCBvdXRwdXQgPSBzZXJpYWxpemVLZXkoa2V5KTtcbiAgICBpZiAoaXRlbS52YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgb3V0cHV0ICs9IHNlcmlhbGl6ZVBhcmFtcyhpdGVtLnBhcmFtcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dCArPSAnPSc7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtLnZhbHVlKSkge1xuICAgICAgICBvdXRwdXQgKz0gc2VyaWFsaXplSW5uZXJMaXN0KGl0ZW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0ICs9IHNlcmlhbGl6ZUl0ZW0oaXRlbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH0pLmpvaW4oYCwke29wdGlvbmFsV2hpdGVTcGFjZX1gKTtcbn1cblxuLyoqXG4gKiBFbmNvZGUgYW4gb2JqZWN0IGludG8gYSBzdHJ1Y3R1cmVkIGZpZWxkIGRpY3Rpb25hcnlcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgc3RydWN0dXJlZCBmaWVsZCBkaWN0aW9uYXJ5IHRvIGVuY29kZVxuICogQHBhcmFtIG9wdGlvbnMgLSBFbmNvZGluZyBvcHRpb25zXG4gKlxuICogQHJldHVybnMgVGhlIHN0cnVjdHVyZWQgZmllbGQgc3RyaW5nXG4gKlxuICogQGdyb3VwIFN0cnVjdHVyZWQgRmllbGRcbiAqXG4gKiBAYmV0YVxuICovXG5mdW5jdGlvbiBlbmNvZGVTZkRpY3QodmFsdWUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHNlcmlhbGl6ZURpY3QodmFsdWUsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4ga2V5IGlzIGEgdG9rZW4gZmllbGQuXG4gKlxuICogQHBhcmFtIGtleSAtIFRoZSBrZXkgdG8gY2hlY2suXG4gKlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBrZXkgaXMgYSB0b2tlbiBmaWVsZC5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaXNUb2tlbkZpZWxkKGtleSkge1xuICByZXR1cm4gWydvdCcsICdzZicsICdzdCcsICdlJywgJ3N0YSddLmluY2x1ZGVzKGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyB2YWxpZFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGtleSBpcyBhIHZhbHVlIGlzIHZhbGlkLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBpc1ZhbGlkKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGlzRmluaXRlTnVtYmVyKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSAhPT0gJycgJiYgdmFsdWUgIT09IGZhbHNlO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSByZWxhdGl2ZSBwYXRoIGZyb20gYSBVUkwuXG4gKlxuICogQHBhcmFtIHVybCAtIFRoZSBkZXN0aW5hdGlvbiBVUkxcbiAqIEBwYXJhbSBiYXNlIC0gVGhlIGJhc2UgVVJMXG4gKiBAcmV0dXJucyBUaGUgcmVsYXRpdmUgcGF0aFxuICpcbiAqIEBncm91cCBVdGlsc1xuICpcbiAqIEBiZXRhXG4gKi9cbmZ1bmN0aW9uIHVybFRvUmVsYXRpdmVQYXRoKHVybCwgYmFzZSkge1xuICBjb25zdCB0byA9IG5ldyBVUkwodXJsKTtcbiAgY29uc3QgZnJvbSA9IG5ldyBVUkwoYmFzZSk7XG4gIGlmICh0by5vcmlnaW4gIT09IGZyb20ub3JpZ2luKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICBjb25zdCB0b1BhdGggPSB0by5wYXRobmFtZS5zcGxpdCgnLycpLnNsaWNlKDEpO1xuICBjb25zdCBmcm9tUGF0aCA9IGZyb20ucGF0aG5hbWUuc3BsaXQoJy8nKS5zbGljZSgxLCAtMSk7XG4gIC8vIHJlbW92ZSBjb21tb24gcGFyZW50c1xuICB3aGlsZSAodG9QYXRoWzBdID09PSBmcm9tUGF0aFswXSkge1xuICAgIHRvUGF0aC5zaGlmdCgpO1xuICAgIGZyb21QYXRoLnNoaWZ0KCk7XG4gIH1cbiAgLy8gYWRkIGJhY2sgcGF0aHNcbiAgd2hpbGUgKGZyb21QYXRoLmxlbmd0aCkge1xuICAgIGZyb21QYXRoLnNoaWZ0KCk7XG4gICAgdG9QYXRoLnVuc2hpZnQoJy4uJyk7XG4gIH1cbiAgcmV0dXJuIHRvUGF0aC5qb2luKCcvJyk7XG59XG5cbmNvbnN0IHRvUm91bmRlZCA9IHZhbHVlID0+IE1hdGgucm91bmQodmFsdWUpO1xuY29uc3QgdG9VcmxTYWZlID0gKHZhbHVlLCBvcHRpb25zKSA9PiB7XG4gIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYmFzZVVybCkge1xuICAgIHZhbHVlID0gdXJsVG9SZWxhdGl2ZVBhdGgodmFsdWUsIG9wdGlvbnMuYmFzZVVybCk7XG4gIH1cbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG59O1xuY29uc3QgdG9IdW5kcmVkID0gdmFsdWUgPT4gdG9Sb3VuZGVkKHZhbHVlIC8gMTAwKSAqIDEwMDtcbi8qKlxuICogVGhlIGRlZmF1bHQgZm9ybWF0dGVycyBmb3IgQ01DRCB2YWx1ZXMuXG4gKlxuICogQGdyb3VwIENNQ0RcbiAqXG4gKiBAYmV0YVxuICovXG5jb25zdCBDbWNkRm9ybWF0dGVycyA9IHtcbiAgLyoqXG4gICAqIEJpdHJhdGUgKGticHMpIHJvdW5kZWQgaW50ZWdlclxuICAgKi9cbiAgYnI6IHRvUm91bmRlZCxcbiAgLyoqXG4gICAqIER1cmF0aW9uIChtaWxsaXNlY29uZHMpIHJvdW5kZWQgaW50ZWdlclxuICAgKi9cbiAgZDogdG9Sb3VuZGVkLFxuICAvKipcbiAgICogQnVmZmVyIExlbmd0aCAobWlsbGlzZWNvbmRzKSByb3VuZGVkIG5lYXJlc3QgMTAwbXNcbiAgICovXG4gIGJsOiB0b0h1bmRyZWQsXG4gIC8qKlxuICAgKiBEZWFkbGluZSAobWlsbGlzZWNvbmRzKSByb3VuZGVkIG5lYXJlc3QgMTAwbXNcbiAgICovXG4gIGRsOiB0b0h1bmRyZWQsXG4gIC8qKlxuICAgKiBNZWFzdXJlZCBUaHJvdWdocHV0IChrYnBzKSByb3VuZGVkIG5lYXJlc3QgMTAwa2Jwc1xuICAgKi9cbiAgbXRwOiB0b0h1bmRyZWQsXG4gIC8qKlxuICAgKiBOZXh0IE9iamVjdCBSZXF1ZXN0IFVSTCBlbmNvZGVkXG4gICAqL1xuICBub3I6IHRvVXJsU2FmZSxcbiAgLyoqXG4gICAqIFJlcXVlc3RlZCBtYXhpbXVtIHRocm91Z2hwdXQgKGticHMpIHJvdW5kZWQgbmVhcmVzdCAxMDBrYnBzXG4gICAqL1xuICBydHA6IHRvSHVuZHJlZCxcbiAgLyoqXG4gICAqIFRvcCBCaXRyYXRlIChrYnBzKSByb3VuZGVkIGludGVnZXJcbiAgICovXG4gIHRiOiB0b1JvdW5kZWRcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgQ01DRCBwcm9jZXNzaW5nIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSBvYmogLSBUaGUgQ01DRCBvYmplY3QgdG8gcHJvY2Vzcy5cbiAqIEBwYXJhbSBtYXAgLSBUaGUgbWFwcGluZyBmdW5jdGlvbiB0byB1c2UuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIGVuY29kaW5nLlxuICpcbiAqIEBpbnRlcm5hbFxuICpcbiAqIEBncm91cCBDTUNEXG4gKi9cbmZ1bmN0aW9uIHByb2Nlc3NDbWNkKG9iaiwgb3B0aW9ucykge1xuICBjb25zdCByZXN1bHRzID0ge307XG4gIGlmIChvYmogPT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopLnNvcnQoKTtcbiAgY29uc3QgZm9ybWF0dGVycyA9IF9leHRlbmRzKHt9LCBDbWNkRm9ybWF0dGVycywgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmZvcm1hdHRlcnMpO1xuICBjb25zdCBmaWx0ZXIgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZmlsdGVyO1xuICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICBpZiAoKGZpbHRlciA9PT0gbnVsbCB8fCBmaWx0ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpbHRlcihrZXkpKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHZhbHVlID0gb2JqW2tleV07XG4gICAgY29uc3QgZm9ybWF0dGVyID0gZm9ybWF0dGVyc1trZXldO1xuICAgIGlmIChmb3JtYXR0ZXIpIHtcbiAgICAgIHZhbHVlID0gZm9ybWF0dGVyKHZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gVmVyc2lvbiBzaG91bGQgb25seSBiZSByZXBvcnRlZCBpZiBub3QgZXF1YWwgdG8gMS5cbiAgICBpZiAoa2V5ID09PSAndicgJiYgdmFsdWUgPT09IDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gUGxheWJhY2sgcmF0ZSBzaG91bGQgb25seSBiZSBzZW50IGlmIG5vdCBlcXVhbCB0byAxLlxuICAgIGlmIChrZXkgPT0gJ3ByJyAmJiB2YWx1ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBpZ25vcmUgaW52YWxpZCB2YWx1ZXNcbiAgICBpZiAoIWlzVmFsaWQodmFsdWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc1Rva2VuRmllbGQoa2V5KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IG5ldyBTZlRva2VuKHZhbHVlKTtcbiAgICB9XG4gICAgcmVzdWx0c1trZXldID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0cztcbn1cblxuLyoqXG4gKiBFbmNvZGUgYSBDTUNEIG9iamVjdCB0byBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gY21jZCAtIFRoZSBDTUNEIG9iamVjdCB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIGVuY29kaW5nLlxuICpcbiAqIEByZXR1cm5zIFRoZSBlbmNvZGVkIENNQ0Qgc3RyaW5nLlxuICpcbiAqIEBncm91cCBDTUNEXG4gKlxuICogQGJldGFcbiAqL1xuZnVuY3Rpb24gZW5jb2RlQ21jZChjbWNkLCBvcHRpb25zID0ge30pIHtcbiAgaWYgKCFjbWNkKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiBlbmNvZGVTZkRpY3QocHJvY2Vzc0NtY2QoY21jZCwgb3B0aW9ucyksIF9leHRlbmRzKHtcbiAgICB3aGl0ZXNwYWNlOiBmYWxzZVxuICB9LCBvcHRpb25zKSk7XG59XG5cbi8qKlxuICogQ29udmVydCBhIENNQ0QgZGF0YSBvYmplY3QgdG8gcmVxdWVzdCBoZWFkZXJzXG4gKlxuICogQHBhcmFtIGNtY2QgLSBUaGUgQ01DRCBkYXRhIG9iamVjdCB0byBjb252ZXJ0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciBlbmNvZGluZyB0aGUgQ01DRCBvYmplY3QuXG4gKlxuICogQHJldHVybnMgVGhlIENNQ0QgaGVhZGVyIHNoYXJkcy5cbiAqXG4gKiBAZ3JvdXAgQ01DRFxuICpcbiAqIEBiZXRhXG4gKi9cbmZ1bmN0aW9uIHRvQ21jZEhlYWRlcnMoY21jZCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBpZiAoIWNtY2QpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhjbWNkKTtcbiAgY29uc3QgaGVhZGVyTWFwID0gT2JqZWN0LmVudHJpZXMoQ21jZEhlYWRlck1hcCkuY29uY2F0KE9iamVjdC5lbnRyaWVzKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY3VzdG9tSGVhZGVyTWFwKSB8fCB7fSkpO1xuICBjb25zdCBzaGFyZHMgPSBlbnRyaWVzLnJlZHVjZSgoYWNjLCBlbnRyeSkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgW2tleSwgdmFsdWVdID0gZW50cnk7XG4gICAgY29uc3QgZmllbGQgPSAoKF9hID0gaGVhZGVyTWFwLmZpbmQoZW50cnkgPT4gZW50cnlbMV0uaW5jbHVkZXMoa2V5KSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgfHwgQ21jZEhlYWRlckZpZWxkLlJFUVVFU1Q7XG4gICAgKF9iID0gYWNjW2ZpZWxkXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogYWNjW2ZpZWxkXSA9IHt9O1xuICAgIGFjY1tmaWVsZF1ba2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHNoYXJkcykucmVkdWNlKChhY2MsIFtmaWVsZCwgdmFsdWVdKSA9PiB7XG4gICAgYWNjW2ZpZWxkXSA9IGVuY29kZUNtY2QodmFsdWUsIG9wdGlvbnMpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHJlc3VsdCk7XG59XG5cbi8qKlxuICogQXBwZW5kIENNQ0QgcXVlcnkgYXJncyB0byBhIGhlYWRlciBvYmplY3QuXG4gKlxuICogQHBhcmFtIGhlYWRlcnMgLSBUaGUgaGVhZGVycyB0byBhcHBlbmQgdG8uXG4gKiBAcGFyYW0gY21jZCAtIFRoZSBDTUNEIG9iamVjdCB0byBhcHBlbmQuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEVuY29kZSBvcHRpb25zLlxuICpcbiAqIEByZXR1cm5zIFRoZSBoZWFkZXJzIHdpdGggdGhlIENNQ0QgaGVhZGVyIHNoYXJkcyBhcHBlbmRlZC5cbiAqXG4gKiBAZ3JvdXAgQ01DRFxuICpcbiAqIEBiZXRhXG4gKi9cbmZ1bmN0aW9uIGFwcGVuZENtY2RIZWFkZXJzKGhlYWRlcnMsIGNtY2QsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIF9leHRlbmRzKGhlYWRlcnMsIHRvQ21jZEhlYWRlcnMoY21jZCwgb3B0aW9ucykpO1xufVxuXG4vKipcbiAqIENNQ0QgcGFyYW1ldGVyIG5hbWUuXG4gKlxuICogQGdyb3VwIENNQ0RcbiAqXG4gKiBAYmV0YVxuICovXG5jb25zdCBDTUNEX1BBUkFNID0gJ0NNQ0QnO1xuXG4vKipcbiAqIENvbnZlcnQgYSBDTUNEIGRhdGEgb2JqZWN0IHRvIGEgcXVlcnkgYXJnLlxuICpcbiAqIEBwYXJhbSBjbWNkIC0gVGhlIENNQ0Qgb2JqZWN0IHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIGVuY29kaW5nIHRoZSBDTUNEIG9iamVjdC5cbiAqXG4gKiBAcmV0dXJucyBUaGUgQ01DRCBxdWVyeSBhcmcuXG4gKlxuICogQGdyb3VwIENNQ0RcbiAqXG4gKiBAYmV0YVxuICovXG5mdW5jdGlvbiB0b0NtY2RRdWVyeShjbWNkLCBvcHRpb25zID0ge30pIHtcbiAgaWYgKCFjbWNkKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGNvbnN0IHBhcmFtcyA9IGVuY29kZUNtY2QoY21jZCwgb3B0aW9ucyk7XG4gIHJldHVybiBgJHtDTUNEX1BBUkFNfT0ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMpfWA7XG59XG5cbmNvbnN0IFJFR0VYID0gL0NNQ0Q9W14mI10rLztcbi8qKlxuICogQXBwZW5kIENNQ0QgcXVlcnkgYXJncyB0byBhIFVSTC5cbiAqXG4gKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCB0byBhcHBlbmQgdG8uXG4gKiBAcGFyYW0gY21jZCAtIFRoZSBDTUNEIG9iamVjdCB0byBhcHBlbmQuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIGVuY29kaW5nIHRoZSBDTUNEIG9iamVjdC5cbiAqXG4gKiBAcmV0dXJucyBUaGUgVVJMIHdpdGggdGhlIENNQ0QgcXVlcnkgYXJncyBhcHBlbmRlZC5cbiAqXG4gKiBAZ3JvdXAgQ01DRFxuICpcbiAqIEBiZXRhXG4gKi9cbmZ1bmN0aW9uIGFwcGVuZENtY2RRdWVyeSh1cmwsIGNtY2QsIG9wdGlvbnMpIHtcbiAgLy8gVE9ETzogUmVwbGFjZSB3aXRoIFVSTFNlYXJjaFBhcmFtcyBvbmNlIHdlIGRyb3AgU2FmYXJpIDwgMTAuMSAmIENocm9tZSA8IDQ5IHN1cHBvcnQuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9VUkxTZWFyY2hQYXJhbXNcbiAgY29uc3QgcXVlcnkgPSB0b0NtY2RRdWVyeShjbWNkLCBvcHRpb25zKTtcbiAgaWYgKCFxdWVyeSkge1xuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgaWYgKFJFR0VYLnRlc3QodXJsKSkge1xuICAgIHJldHVybiB1cmwucmVwbGFjZShSRUdFWCwgcXVlcnkpO1xuICB9XG4gIGNvbnN0IHNlcGFyYXRvciA9IHVybC5pbmNsdWRlcygnPycpID8gJyYnIDogJz8nO1xuICByZXR1cm4gYCR7dXJsfSR7c2VwYXJhdG9yfSR7cXVlcnl9YDtcbn1cblxuLyoqXG4gKiBDb250cm9sbGVyIHRvIGRlYWwgd2l0aCBDb21tb24gTWVkaWEgQ2xpZW50IERhdGEgKENNQ0QpXG4gKiBAc2VlIGh0dHBzOi8vY2RuLmN0YS50ZWNoL2N0YS9tZWRpYS9tZWRpYS9yZXNvdXJjZXMvc3RhbmRhcmRzL3BkZnMvY3RhLTUwMDQtZmluYWwucGRmXG4gKi9cbmNsYXNzIENNQ0RDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy5tZWRpYSA9IHZvaWQgMDtcbiAgICB0aGlzLnNpZCA9IHZvaWQgMDtcbiAgICB0aGlzLmNpZCA9IHZvaWQgMDtcbiAgICB0aGlzLnVzZUhlYWRlcnMgPSBmYWxzZTtcbiAgICB0aGlzLmluY2x1ZGVLZXlzID0gdm9pZCAwO1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXJ2ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmJ1ZmZlcmluZyA9IHRydWU7XG4gICAgdGhpcy5hdWRpb0J1ZmZlciA9IHZvaWQgMDtcbiAgICB0aGlzLnZpZGVvQnVmZmVyID0gdm9pZCAwO1xuICAgIHRoaXMub25XYWl0aW5nID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdGhpcy5zdGFydmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYnVmZmVyaW5nID0gdHJ1ZTtcbiAgICB9O1xuICAgIHRoaXMub25QbGF5aW5nID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5idWZmZXJpbmcgPSBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFwcGx5IENNQ0QgZGF0YSB0byBhIG1hbmlmZXN0IHJlcXVlc3QuXG4gICAgICovXG4gICAgdGhpcy5hcHBseVBsYXlsaXN0RGF0YSA9IGNvbnRleHQgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5hcHBseShjb250ZXh0LCB7XG4gICAgICAgICAgb3Q6IENtY2RPYmplY3RUeXBlLk1BTklGRVNULFxuICAgICAgICAgIHN1OiAhdGhpcy5pbml0aWFsaXplZFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRoaXMuaGxzLmxvZ2dlci53YXJuKCdDb3VsZCBub3QgZ2VuZXJhdGUgbWFuaWZlc3QgQ01DRCBkYXRhLicsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFwcGx5IENNQ0QgZGF0YSB0byBhIHNlZ21lbnQgcmVxdWVzdFxuICAgICAqL1xuICAgIHRoaXMuYXBwbHlGcmFnbWVudERhdGEgPSBjb250ZXh0ID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBmcmFnLFxuICAgICAgICAgIHBhcnRcbiAgICAgICAgfSA9IGNvbnRleHQ7XG4gICAgICAgIGNvbnN0IGxldmVsID0gdGhpcy5obHMubGV2ZWxzW2ZyYWcubGV2ZWxdO1xuICAgICAgICBjb25zdCBvdCA9IHRoaXMuZ2V0T2JqZWN0VHlwZShmcmFnKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICBkOiAocGFydCB8fCBmcmFnKS5kdXJhdGlvbiAqIDEwMDAsXG4gICAgICAgICAgb3RcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG90ID09PSBDbWNkT2JqZWN0VHlwZS5WSURFTyB8fCBvdCA9PT0gQ21jZE9iamVjdFR5cGUuQVVESU8gfHwgb3QgPT0gQ21jZE9iamVjdFR5cGUuTVVYRUQpIHtcbiAgICAgICAgICBkYXRhLmJyID0gbGV2ZWwuYml0cmF0ZSAvIDEwMDA7XG4gICAgICAgICAgZGF0YS50YiA9IHRoaXMuZ2V0VG9wQmFuZHdpZHRoKG90KSAvIDEwMDA7XG4gICAgICAgICAgZGF0YS5ibCA9IHRoaXMuZ2V0QnVmZmVyTGVuZ3RoKG90KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0ID0gcGFydCA/IHRoaXMuZ2V0TmV4dFBhcnQocGFydCkgOiB0aGlzLmdldE5leHRGcmFnKGZyYWcpO1xuICAgICAgICBpZiAobmV4dCAhPSBudWxsICYmIG5leHQudXJsICYmIG5leHQudXJsICE9PSBmcmFnLnVybCkge1xuICAgICAgICAgIGRhdGEubm9yID0gbmV4dC51cmw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcHBseShjb250ZXh0LCBkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRoaXMuaGxzLmxvZ2dlci53YXJuKCdDb3VsZCBub3QgZ2VuZXJhdGUgc2VnbWVudCBDTUNEIGRhdGEuJywgZXJyb3IpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgIGNvbnN0IHtcbiAgICAgIGNtY2RcbiAgICB9ID0gY29uZmlnO1xuICAgIGlmIChjbWNkICE9IG51bGwpIHtcbiAgICAgIGNvbmZpZy5wTG9hZGVyID0gdGhpcy5jcmVhdGVQbGF5bGlzdExvYWRlcigpO1xuICAgICAgY29uZmlnLmZMb2FkZXIgPSB0aGlzLmNyZWF0ZUZyYWdtZW50TG9hZGVyKCk7XG4gICAgICB0aGlzLnNpZCA9IGNtY2Quc2Vzc2lvbklkIHx8IGhscy5zZXNzaW9uSWQ7XG4gICAgICB0aGlzLmNpZCA9IGNtY2QuY29udGVudElkO1xuICAgICAgdGhpcy51c2VIZWFkZXJzID0gY21jZC51c2VIZWFkZXJzID09PSB0cnVlO1xuICAgICAgdGhpcy5pbmNsdWRlS2V5cyA9IGNtY2QuaW5jbHVkZUtleXM7XG4gICAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgfVxuICB9XG4gIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0RFVEFDSEVELCB0aGlzLm9uTWVkaWFEZXRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfQ1JFQVRFRCwgdGhpcy5vbkJ1ZmZlckNyZWF0ZWQsIHRoaXMpO1xuICB9XG4gIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9ERVRBQ0hFRCwgdGhpcy5vbk1lZGlhRGV0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9DUkVBVEVELCB0aGlzLm9uQnVmZmVyQ3JlYXRlZCwgdGhpcyk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLm9uTWVkaWFEZXRhY2hlZCgpO1xuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuaGxzID0gdGhpcy5jb25maWcgPSB0aGlzLmF1ZGlvQnVmZmVyID0gdGhpcy52aWRlb0J1ZmZlciA9IG51bGw7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMub25XYWl0aW5nID0gdGhpcy5vblBsYXlpbmcgPSB0aGlzLm1lZGlhID0gbnVsbDtcbiAgfVxuICBvbk1lZGlhQXR0YWNoZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICB0aGlzLm1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3dhaXRpbmcnLCB0aGlzLm9uV2FpdGluZyk7XG4gICAgdGhpcy5tZWRpYS5hZGRFdmVudExpc3RlbmVyKCdwbGF5aW5nJywgdGhpcy5vblBsYXlpbmcpO1xuICB9XG4gIG9uTWVkaWFEZXRhY2hlZCgpIHtcbiAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5tZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCd3YWl0aW5nJywgdGhpcy5vbldhaXRpbmcpO1xuICAgIHRoaXMubWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGxheWluZycsIHRoaXMub25QbGF5aW5nKTtcblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgfVxuICBvbkJ1ZmZlckNyZWF0ZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgX2RhdGEkdHJhY2tzJGF1ZGlvLCBfZGF0YSR0cmFja3MkdmlkZW87XG4gICAgdGhpcy5hdWRpb0J1ZmZlciA9IChfZGF0YSR0cmFja3MkYXVkaW8gPSBkYXRhLnRyYWNrcy5hdWRpbykgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhJHRyYWNrcyRhdWRpby5idWZmZXI7XG4gICAgdGhpcy52aWRlb0J1ZmZlciA9IChfZGF0YSR0cmFja3MkdmlkZW8gPSBkYXRhLnRyYWNrcy52aWRlbykgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhJHRyYWNrcyR2aWRlby5idWZmZXI7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBiYXNlbGluZSBDTUNEIGRhdGFcbiAgICovXG4gIGNyZWF0ZURhdGEoKSB7XG4gICAgdmFyIF90aGlzJG1lZGlhO1xuICAgIHJldHVybiB7XG4gICAgICB2OiAxLFxuICAgICAgc2Y6IENtY2RTdHJlYW1pbmdGb3JtYXQuSExTLFxuICAgICAgc2lkOiB0aGlzLnNpZCxcbiAgICAgIGNpZDogdGhpcy5jaWQsXG4gICAgICBwcjogKF90aGlzJG1lZGlhID0gdGhpcy5tZWRpYSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG1lZGlhLnBsYXliYWNrUmF0ZSxcbiAgICAgIG10cDogdGhpcy5obHMuYmFuZHdpZHRoRXN0aW1hdGUgLyAxMDAwXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBseSBDTUNEIGRhdGEgdG8gYSByZXF1ZXN0LlxuICAgKi9cbiAgYXBwbHkoY29udGV4dCwgZGF0YSA9IHt9KSB7XG4gICAgLy8gYXBwbHkgYmFzZWxpbmUgZGF0YVxuICAgIF9leHRlbmRzKGRhdGEsIHRoaXMuY3JlYXRlRGF0YSgpKTtcbiAgICBjb25zdCBpc1ZpZGVvID0gZGF0YS5vdCA9PT0gQ21jZE9iamVjdFR5cGUuSU5JVCB8fCBkYXRhLm90ID09PSBDbWNkT2JqZWN0VHlwZS5WSURFTyB8fCBkYXRhLm90ID09PSBDbWNkT2JqZWN0VHlwZS5NVVhFRDtcbiAgICBpZiAodGhpcy5zdGFydmVkICYmIGlzVmlkZW8pIHtcbiAgICAgIGRhdGEuYnMgPSB0cnVlO1xuICAgICAgZGF0YS5zdSA9IHRydWU7XG4gICAgICB0aGlzLnN0YXJ2ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRhdGEuc3UgPT0gbnVsbCkge1xuICAgICAgZGF0YS5zdSA9IHRoaXMuYnVmZmVyaW5nO1xuICAgIH1cblxuICAgIC8vIFRPRE86IEltcGxlbWVudCBydHAsIG5yciwgZGxcblxuICAgIGNvbnN0IHtcbiAgICAgIGluY2x1ZGVLZXlzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGluY2x1ZGVLZXlzKSB7XG4gICAgICBkYXRhID0gT2JqZWN0LmtleXMoZGF0YSkucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgICAgICBpbmNsdWRlS2V5cy5pbmNsdWRlcyhrZXkpICYmIChhY2Nba2V5XSA9IGRhdGFba2V5XSk7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LCB7fSk7XG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBiYXNlVXJsOiBjb250ZXh0LnVybFxuICAgIH07XG4gICAgaWYgKHRoaXMudXNlSGVhZGVycykge1xuICAgICAgaWYgKCFjb250ZXh0LmhlYWRlcnMpIHtcbiAgICAgICAgY29udGV4dC5oZWFkZXJzID0ge307XG4gICAgICB9XG4gICAgICBhcHBlbmRDbWNkSGVhZGVycyhjb250ZXh0LmhlYWRlcnMsIGRhdGEsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LnVybCA9IGFwcGVuZENtY2RRdWVyeShjb250ZXh0LnVybCwgZGF0YSwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIGdldE5leHRGcmFnKGZyYWdtZW50KSB7XG4gICAgdmFyIF90aGlzJGhscyRsZXZlbHMkZnJhZztcbiAgICBjb25zdCBsZXZlbERldGFpbHMgPSAoX3RoaXMkaGxzJGxldmVscyRmcmFnID0gdGhpcy5obHMubGV2ZWxzW2ZyYWdtZW50LmxldmVsXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGhscyRsZXZlbHMkZnJhZy5kZXRhaWxzO1xuICAgIGlmIChsZXZlbERldGFpbHMpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gZnJhZ21lbnQuc24gLSBsZXZlbERldGFpbHMuc3RhcnRTTjtcbiAgICAgIHJldHVybiBsZXZlbERldGFpbHMuZnJhZ21lbnRzW2luZGV4ICsgMV07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgZ2V0TmV4dFBhcnQocGFydCkge1xuICAgIHZhciBfdGhpcyRobHMkbGV2ZWxzJGZyYWcyLCBfdGhpcyRobHMkbGV2ZWxzJGZyYWczO1xuICAgIGNvbnN0IHtcbiAgICAgIGluZGV4LFxuICAgICAgZnJhZ21lbnRcbiAgICB9ID0gcGFydDtcbiAgICBjb25zdCBwYXJ0TGlzdCA9IChfdGhpcyRobHMkbGV2ZWxzJGZyYWcyID0gdGhpcy5obHMubGV2ZWxzW2ZyYWdtZW50LmxldmVsXSkgPT0gbnVsbCA/IHZvaWQgMCA6IChfdGhpcyRobHMkbGV2ZWxzJGZyYWczID0gX3RoaXMkaGxzJGxldmVscyRmcmFnMi5kZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkaGxzJGxldmVscyRmcmFnMy5wYXJ0TGlzdDtcbiAgICBpZiAocGFydExpc3QpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc25cbiAgICAgIH0gPSBmcmFnbWVudDtcbiAgICAgIGZvciAobGV0IGkgPSBwYXJ0TGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBwID0gcGFydExpc3RbaV07XG4gICAgICAgIGlmIChwLmluZGV4ID09PSBpbmRleCAmJiBwLmZyYWdtZW50LnNuID09PSBzbikge1xuICAgICAgICAgIHJldHVybiBwYXJ0TGlzdFtpICsgMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgQ01DRCBvYmplY3QgdHlwZS5cbiAgICovXG4gIGdldE9iamVjdFR5cGUoZnJhZ21lbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlXG4gICAgfSA9IGZyYWdtZW50O1xuICAgIGlmICh0eXBlID09PSAnc3VidGl0bGUnKSB7XG4gICAgICByZXR1cm4gQ21jZE9iamVjdFR5cGUuVElNRURfVEVYVDtcbiAgICB9XG4gICAgaWYgKGZyYWdtZW50LnNuID09PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICByZXR1cm4gQ21jZE9iamVjdFR5cGUuSU5JVDtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgIHJldHVybiBDbWNkT2JqZWN0VHlwZS5BVURJTztcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdtYWluJykge1xuICAgICAgaWYgKCF0aGlzLmhscy5hdWRpb1RyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIENtY2RPYmplY3RUeXBlLk1VWEVEO1xuICAgICAgfVxuICAgICAgcmV0dXJuIENtY2RPYmplY3RUeXBlLlZJREVPO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaGlnaGVzdCBiaXRyYXRlLlxuICAgKi9cbiAgZ2V0VG9wQmFuZHdpZHRoKHR5cGUpIHtcbiAgICBsZXQgYml0cmF0ZSA9IDA7XG4gICAgbGV0IGxldmVscztcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBpZiAodHlwZSA9PT0gQ21jZE9iamVjdFR5cGUuQVVESU8pIHtcbiAgICAgIGxldmVscyA9IGhscy5hdWRpb1RyYWNrcztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbWF4ID0gaGxzLm1heEF1dG9MZXZlbDtcbiAgICAgIGNvbnN0IGxlbiA9IG1heCA+IC0xID8gbWF4ICsgMSA6IGhscy5sZXZlbHMubGVuZ3RoO1xuICAgICAgbGV2ZWxzID0gaGxzLmxldmVscy5zbGljZSgwLCBsZW4pO1xuICAgIH1cbiAgICBsZXZlbHMuZm9yRWFjaChsZXZlbCA9PiB7XG4gICAgICBpZiAobGV2ZWwuYml0cmF0ZSA+IGJpdHJhdGUpIHtcbiAgICAgICAgYml0cmF0ZSA9IGxldmVsLmJpdHJhdGU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGJpdHJhdGUgPiAwID8gYml0cmF0ZSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGJ1ZmZlciBsZW5ndGggZm9yIGEgbWVkaWEgdHlwZSBpbiBtaWxsaXNlY29uZHNcbiAgICovXG4gIGdldEJ1ZmZlckxlbmd0aCh0eXBlKSB7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGNvbnN0IGJ1ZmZlciA9IHR5cGUgPT09IENtY2RPYmplY3RUeXBlLkFVRElPID8gdGhpcy5hdWRpb0J1ZmZlciA6IHRoaXMudmlkZW9CdWZmZXI7XG4gICAgaWYgKCFidWZmZXIgfHwgIW1lZGlhKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICBjb25zdCBpbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8oYnVmZmVyLCBtZWRpYS5jdXJyZW50VGltZSwgdGhpcy5jb25maWcubWF4QnVmZmVySG9sZSk7XG4gICAgcmV0dXJuIGluZm8ubGVuICogMTAwMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBwbGF5bGlzdCBsb2FkZXJcbiAgICovXG4gIGNyZWF0ZVBsYXlsaXN0TG9hZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBMb2FkZXJcbiAgICB9ID0gdGhpcy5jb25maWc7XG4gICAgY29uc3QgYXBwbHkgPSB0aGlzLmFwcGx5UGxheWxpc3REYXRhO1xuICAgIGNvbnN0IEN0b3IgPSBwTG9hZGVyIHx8IHRoaXMuY29uZmlnLmxvYWRlcjtcbiAgICByZXR1cm4gY2xhc3MgQ21jZFBsYXlsaXN0TG9hZGVyIHtcbiAgICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICB0aGlzLmxvYWRlciA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgQ3Rvcihjb25maWcpO1xuICAgICAgfVxuICAgICAgZ2V0IHN0YXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkZXIuc3RhdHM7XG4gICAgICB9XG4gICAgICBnZXQgY29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZGVyLmNvbnRleHQ7XG4gICAgICB9XG4gICAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmxvYWRlci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgICBhYm9ydCgpIHtcbiAgICAgICAgdGhpcy5sb2FkZXIuYWJvcnQoKTtcbiAgICAgIH1cbiAgICAgIGxvYWQoY29udGV4dCwgY29uZmlnLCBjYWxsYmFja3MpIHtcbiAgICAgICAgYXBwbHkoY29udGV4dCk7XG4gICAgICAgIHRoaXMubG9hZGVyLmxvYWQoY29udGV4dCwgY29uZmlnLCBjYWxsYmFja3MpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgcGxheWxpc3QgbG9hZGVyXG4gICAqL1xuICBjcmVhdGVGcmFnbWVudExvYWRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBmTG9hZGVyXG4gICAgfSA9IHRoaXMuY29uZmlnO1xuICAgIGNvbnN0IGFwcGx5ID0gdGhpcy5hcHBseUZyYWdtZW50RGF0YTtcbiAgICBjb25zdCBDdG9yID0gZkxvYWRlciB8fCB0aGlzLmNvbmZpZy5sb2FkZXI7XG4gICAgcmV0dXJuIGNsYXNzIENtY2RGcmFnbWVudExvYWRlciB7XG4gICAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdGhpcy5sb2FkZXIgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IEN0b3IoY29uZmlnKTtcbiAgICAgIH1cbiAgICAgIGdldCBzdGF0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZGVyLnN0YXRzO1xuICAgICAgfVxuICAgICAgZ2V0IGNvbnRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRlci5jb250ZXh0O1xuICAgICAgfVxuICAgICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5sb2FkZXIuZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgYWJvcnQoKSB7XG4gICAgICAgIHRoaXMubG9hZGVyLmFib3J0KCk7XG4gICAgICB9XG4gICAgICBsb2FkKGNvbnRleHQsIGNvbmZpZywgY2FsbGJhY2tzKSB7XG4gICAgICAgIGFwcGx5KGNvbnRleHQpO1xuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKGNvbnRleHQsIGNvbmZpZywgY2FsbGJhY2tzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5cbmNvbnN0IFBBVEhXQVlfUEVOQUxUWV9EVVJBVElPTl9NUyA9IDMwMDAwMDtcbmNsYXNzIENvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXIgZXh0ZW5kcyBMb2dnZXIge1xuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICBzdXBlcignY29udGVudC1zdGVlcmluZycsIGhscy5sb2dnZXIpO1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgICB0aGlzLnVyaSA9IG51bGw7XG4gICAgdGhpcy5wYXRod2F5SWQgPSAnLic7XG4gICAgdGhpcy5fcGF0aHdheVByaW9yaXR5ID0gbnVsbDtcbiAgICB0aGlzLnRpbWVUb0xvYWQgPSAzMDA7XG4gICAgdGhpcy5yZWxvYWRUaW1lciA9IC0xO1xuICAgIHRoaXMudXBkYXRlZCA9IDA7XG4gICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLmxldmVscyA9IG51bGw7XG4gICAgdGhpcy5hdWRpb1RyYWNrcyA9IG51bGw7XG4gICAgdGhpcy5zdWJ0aXRsZVRyYWNrcyA9IG51bGw7XG4gICAgdGhpcy5wZW5hbGl6ZWRQYXRod2F5cyA9IHt9O1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH1cbiAgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBpZiAoIWhscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FERUQsIHRoaXMub25NYW5pZmVzdExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9XG4gIHBhdGh3YXlzKCkge1xuICAgIHJldHVybiAodGhpcy5sZXZlbHMgfHwgW10pLnJlZHVjZSgocGF0aHdheXMsIGxldmVsKSA9PiB7XG4gICAgICBpZiAocGF0aHdheXMuaW5kZXhPZihsZXZlbC5wYXRod2F5SWQpID09PSAtMSkge1xuICAgICAgICBwYXRod2F5cy5wdXNoKGxldmVsLnBhdGh3YXlJZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGF0aHdheXM7XG4gICAgfSwgW10pO1xuICB9XG4gIGdldCBwYXRod2F5UHJpb3JpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhdGh3YXlQcmlvcml0eTtcbiAgfVxuICBzZXQgcGF0aHdheVByaW9yaXR5KHBhdGh3YXlQcmlvcml0eSkge1xuICAgIHRoaXMudXBkYXRlUGF0aHdheVByaW9yaXR5KHBhdGh3YXlQcmlvcml0eSk7XG4gIH1cbiAgc3RhcnRMb2FkKCkge1xuICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgICBpZiAodGhpcy5lbmFibGVkICYmIHRoaXMudXJpKSB7XG4gICAgICBpZiAodGhpcy51cGRhdGVkKSB7XG4gICAgICAgIGNvbnN0IHR0bCA9IHRoaXMudGltZVRvTG9hZCAqIDEwMDAgLSAocGVyZm9ybWFuY2Uubm93KCkgLSB0aGlzLnVwZGF0ZWQpO1xuICAgICAgICBpZiAodHRsID4gMCkge1xuICAgICAgICAgIHRoaXMuc2NoZWR1bGVSZWZyZXNoKHRoaXMudXJpLCB0dGwpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5sb2FkU3RlZXJpbmdNYW5pZmVzdCh0aGlzLnVyaSk7XG4gICAgfVxuICB9XG4gIHN0b3BMb2FkKCkge1xuICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLmxvYWRlcikge1xuICAgICAgdGhpcy5sb2FkZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5sb2FkZXIgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICB9XG4gIGNsZWFyVGltZW91dCgpIHtcbiAgICBpZiAodGhpcy5yZWxvYWRUaW1lciAhPT0gLTEpIHtcbiAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVsb2FkVGltZXIpO1xuICAgICAgdGhpcy5yZWxvYWRUaW1lciA9IC0xO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSBudWxsO1xuICAgIHRoaXMubGV2ZWxzID0gdGhpcy5hdWRpb1RyYWNrcyA9IHRoaXMuc3VidGl0bGVUcmFja3MgPSBudWxsO1xuICB9XG4gIHJlbW92ZUxldmVsKGxldmVsVG9SZW1vdmUpIHtcbiAgICBjb25zdCBsZXZlbHMgPSB0aGlzLmxldmVscztcbiAgICBpZiAobGV2ZWxzKSB7XG4gICAgICB0aGlzLmxldmVscyA9IGxldmVscy5maWx0ZXIobGV2ZWwgPT4gbGV2ZWwgIT09IGxldmVsVG9SZW1vdmUpO1xuICAgIH1cbiAgfVxuICBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLnRpbWVUb0xvYWQgPSAzMDA7XG4gICAgdGhpcy51cGRhdGVkID0gMDtcbiAgICB0aGlzLnVyaSA9IG51bGw7XG4gICAgdGhpcy5wYXRod2F5SWQgPSAnLic7XG4gICAgdGhpcy5sZXZlbHMgPSB0aGlzLmF1ZGlvVHJhY2tzID0gdGhpcy5zdWJ0aXRsZVRyYWNrcyA9IG51bGw7XG4gIH1cbiAgb25NYW5pZmVzdExvYWRlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRlbnRTdGVlcmluZ1xuICAgIH0gPSBkYXRhO1xuICAgIGlmIChjb250ZW50U3RlZXJpbmcgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wYXRod2F5SWQgPSBjb250ZW50U3RlZXJpbmcucGF0aHdheUlkO1xuICAgIHRoaXMudXJpID0gY29udGVudFN0ZWVyaW5nLnVyaTtcbiAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICB0aGlzLnN0YXJ0TG9hZCgpO1xuICAgIH1cbiAgfVxuICBvbk1hbmlmZXN0UGFyc2VkKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5hdWRpb1RyYWNrcyA9IGRhdGEuYXVkaW9UcmFja3M7XG4gICAgdGhpcy5zdWJ0aXRsZVRyYWNrcyA9IGRhdGEuc3VidGl0bGVUcmFja3M7XG4gIH1cbiAgb25FcnJvcihldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVycm9yQWN0aW9uXG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKChlcnJvckFjdGlvbiA9PSBudWxsID8gdm9pZCAwIDogZXJyb3JBY3Rpb24uYWN0aW9uKSA9PT0gTmV0d29ya0Vycm9yQWN0aW9uLlNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3ggJiYgZXJyb3JBY3Rpb24uZmxhZ3MgPT09IEVycm9yQWN0aW9uRmxhZ3MuTW92ZUFsbEFsdGVybmF0ZXNNYXRjaGluZ0hvc3QpIHtcbiAgICAgIGNvbnN0IGxldmVscyA9IHRoaXMubGV2ZWxzO1xuICAgICAgbGV0IHBhdGh3YXlQcmlvcml0eSA9IHRoaXMuX3BhdGh3YXlQcmlvcml0eTtcbiAgICAgIGxldCBlcnJvclBhdGh3YXkgPSB0aGlzLnBhdGh3YXlJZDtcbiAgICAgIGlmIChkYXRhLmNvbnRleHQpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGdyb3VwSWQsXG4gICAgICAgICAgcGF0aHdheUlkLFxuICAgICAgICAgIHR5cGVcbiAgICAgICAgfSA9IGRhdGEuY29udGV4dDtcbiAgICAgICAgaWYgKGdyb3VwSWQgJiYgbGV2ZWxzKSB7XG4gICAgICAgICAgZXJyb3JQYXRod2F5ID0gdGhpcy5nZXRQYXRod2F5Rm9yR3JvdXBJZChncm91cElkLCB0eXBlLCBlcnJvclBhdGh3YXkpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhdGh3YXlJZCkge1xuICAgICAgICAgIGVycm9yUGF0aHdheSA9IHBhdGh3YXlJZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCEoZXJyb3JQYXRod2F5IGluIHRoaXMucGVuYWxpemVkUGF0aHdheXMpKSB7XG4gICAgICAgIHRoaXMucGVuYWxpemVkUGF0aHdheXNbZXJyb3JQYXRod2F5XSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgfVxuICAgICAgaWYgKCFwYXRod2F5UHJpb3JpdHkgJiYgbGV2ZWxzKSB7XG4gICAgICAgIC8vIElmIFBBVEhXQVktUFJJT1JJVFkgd2FzIG5vdCBwcm92aWRlZCwgbGlzdCBwYXRod2F5cyBmb3IgZXJyb3IgaGFuZGxpbmdcbiAgICAgICAgcGF0aHdheVByaW9yaXR5ID0gdGhpcy5wYXRod2F5cygpO1xuICAgICAgfVxuICAgICAgaWYgKHBhdGh3YXlQcmlvcml0eSAmJiBwYXRod2F5UHJpb3JpdHkubGVuZ3RoID4gMSkge1xuICAgICAgICB0aGlzLnVwZGF0ZVBhdGh3YXlQcmlvcml0eShwYXRod2F5UHJpb3JpdHkpO1xuICAgICAgICBlcnJvckFjdGlvbi5yZXNvbHZlZCA9IHRoaXMucGF0aHdheUlkICE9PSBlcnJvclBhdGh3YXk7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YS5kZXRhaWxzID09PSBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORF9FUlJPUiAmJiAhZGF0YS5mYXRhbCkge1xuICAgICAgICAvLyBFcnJvciB3aWxsIGJlY29tZSBmYXRhbCBpbiBidWZmZXItY29udHJvbGxlciB3aGVuIHJlYWNoaW5nIGBhcHBlbmRFcnJvck1heFJldHJ5YFxuICAgICAgICAvLyBTdHJlYW0tY29udHJvbGxlcnMgYXJlIGV4cGVjdGVkIHRvIHJlZHVjZSBidWZmZXIgbGVuZ3RoIGV2ZW4gaWYgdGhpcyBpcyBub3QgZGVlbWVkIGEgUXVvdGFFeGNlZWRlZEVycm9yXG4gICAgICAgIGVycm9yQWN0aW9uLnJlc29sdmVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoIWVycm9yQWN0aW9uLnJlc29sdmVkKSB7XG4gICAgICAgIHRoaXMud2FybihgQ291bGQgbm90IHJlc29sdmUgJHtkYXRhLmRldGFpbHN9IChcIiR7ZGF0YS5lcnJvci5tZXNzYWdlfVwiKSB3aXRoIGNvbnRlbnQtc3RlZXJpbmcgZm9yIFBhdGh3YXk6ICR7ZXJyb3JQYXRod2F5fSBsZXZlbHM6ICR7bGV2ZWxzID8gbGV2ZWxzLmxlbmd0aCA6IGxldmVsc30gcHJpb3JpdGllczogJHtzdHJpbmdpZnkocGF0aHdheVByaW9yaXR5KX0gcGVuYWxpemVkOiAke3N0cmluZ2lmeSh0aGlzLnBlbmFsaXplZFBhdGh3YXlzKX1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZmlsdGVyUGFyc2VkTGV2ZWxzKGxldmVscykge1xuICAgIC8vIEZpbHRlciBsZXZlbHMgdG8gb25seSBpbmNsdWRlIHRob3NlIHRoYXQgYXJlIGluIHRoZSBpbml0aWFsIHBhdGh3YXlcbiAgICB0aGlzLmxldmVscyA9IGxldmVscztcbiAgICBsZXQgcGF0aHdheUxldmVscyA9IHRoaXMuZ2V0TGV2ZWxzRm9yUGF0aHdheSh0aGlzLnBhdGh3YXlJZCk7XG4gICAgaWYgKHBhdGh3YXlMZXZlbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zdCBwYXRod2F5SWQgPSBsZXZlbHNbMF0ucGF0aHdheUlkO1xuICAgICAgdGhpcy5sb2coYE5vIGxldmVscyBmb3VuZCBpbiBQYXRod2F5ICR7dGhpcy5wYXRod2F5SWR9LiBTZXR0aW5nIGluaXRpYWwgUGF0aHdheSB0byBcIiR7cGF0aHdheUlkfVwiYCk7XG4gICAgICBwYXRod2F5TGV2ZWxzID0gdGhpcy5nZXRMZXZlbHNGb3JQYXRod2F5KHBhdGh3YXlJZCk7XG4gICAgICB0aGlzLnBhdGh3YXlJZCA9IHBhdGh3YXlJZDtcbiAgICB9XG4gICAgaWYgKHBhdGh3YXlMZXZlbHMubGVuZ3RoICE9PSBsZXZlbHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmxvZyhgRm91bmQgJHtwYXRod2F5TGV2ZWxzLmxlbmd0aH0vJHtsZXZlbHMubGVuZ3RofSBsZXZlbHMgaW4gUGF0aHdheSBcIiR7dGhpcy5wYXRod2F5SWR9XCJgKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGh3YXlMZXZlbHM7XG4gIH1cbiAgZ2V0TGV2ZWxzRm9yUGF0aHdheShwYXRod2F5SWQpIHtcbiAgICBpZiAodGhpcy5sZXZlbHMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxzLmZpbHRlcihsZXZlbCA9PiBwYXRod2F5SWQgPT09IGxldmVsLnBhdGh3YXlJZCk7XG4gIH1cbiAgdXBkYXRlUGF0aHdheVByaW9yaXR5KHBhdGh3YXlQcmlvcml0eSkge1xuICAgIHRoaXMuX3BhdGh3YXlQcmlvcml0eSA9IHBhdGh3YXlQcmlvcml0eTtcbiAgICBsZXQgbGV2ZWxzO1xuXG4gICAgLy8gRXZhbHVhdGUgaWYgd2Ugc2hvdWxkIHJlbW92ZSB0aGUgcGF0aHdheSBmcm9tIHRoZSBwZW5hbGl6ZWQgbGlzdFxuICAgIGNvbnN0IHBlbmFsaXplZFBhdGh3YXlzID0gdGhpcy5wZW5hbGl6ZWRQYXRod2F5cztcbiAgICBjb25zdCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBPYmplY3Qua2V5cyhwZW5hbGl6ZWRQYXRod2F5cykuZm9yRWFjaChwYXRod2F5SWQgPT4ge1xuICAgICAgaWYgKG5vdyAtIHBlbmFsaXplZFBhdGh3YXlzW3BhdGh3YXlJZF0gPiBQQVRIV0FZX1BFTkFMVFlfRFVSQVRJT05fTVMpIHtcbiAgICAgICAgZGVsZXRlIHBlbmFsaXplZFBhdGh3YXlzW3BhdGh3YXlJZF07XG4gICAgICB9XG4gICAgfSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRod2F5UHJpb3JpdHkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBhdGh3YXlJZCA9IHBhdGh3YXlQcmlvcml0eVtpXTtcbiAgICAgIGlmIChwYXRod2F5SWQgaW4gcGVuYWxpemVkUGF0aHdheXMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocGF0aHdheUlkID09PSB0aGlzLnBhdGh3YXlJZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzZWxlY3RlZEluZGV4ID0gdGhpcy5obHMubmV4dExvYWRMZXZlbDtcbiAgICAgIGNvbnN0IHNlbGVjdGVkTGV2ZWwgPSB0aGlzLmhscy5sZXZlbHNbc2VsZWN0ZWRJbmRleF07XG4gICAgICBsZXZlbHMgPSB0aGlzLmdldExldmVsc0ZvclBhdGh3YXkocGF0aHdheUlkKTtcbiAgICAgIGlmIChsZXZlbHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmxvZyhgU2V0dGluZyBQYXRod2F5IHRvIFwiJHtwYXRod2F5SWR9XCJgKTtcbiAgICAgICAgdGhpcy5wYXRod2F5SWQgPSBwYXRod2F5SWQ7XG4gICAgICAgIHJlYXNzaWduRnJhZ21lbnRMZXZlbEluZGV4ZXMobGV2ZWxzKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTEVWRUxTX1VQREFURUQsIHtcbiAgICAgICAgICBsZXZlbHNcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFNldCBMZXZlbENvbnRyb2xsZXIncyBsZXZlbCB0byB0cmlnZ2VyIExFVkVMX1NXSVRDSElORyB3aGljaCBsb2FkcyBwbGF5bGlzdCBpZiBuZWVkZWRcbiAgICAgICAgY29uc3QgbGV2ZWxBZnRlckNoYW5nZSA9IHRoaXMuaGxzLmxldmVsc1tzZWxlY3RlZEluZGV4XTtcbiAgICAgICAgaWYgKHNlbGVjdGVkTGV2ZWwgJiYgbGV2ZWxBZnRlckNoYW5nZSAmJiB0aGlzLmxldmVscykge1xuICAgICAgICAgIGlmIChsZXZlbEFmdGVyQ2hhbmdlLmF0dHJzWydTVEFCTEUtVkFSSUFOVC1JRCddICE9PSBzZWxlY3RlZExldmVsLmF0dHJzWydTVEFCTEUtVkFSSUFOVC1JRCddICYmIGxldmVsQWZ0ZXJDaGFuZ2UuYml0cmF0ZSAhPT0gc2VsZWN0ZWRMZXZlbC5iaXRyYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZyhgVW5zdGFibGUgUGF0aHdheXMgY2hhbmdlIGZyb20gYml0cmF0ZSAke3NlbGVjdGVkTGV2ZWwuYml0cmF0ZX0gdG8gJHtsZXZlbEFmdGVyQ2hhbmdlLmJpdHJhdGV9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuaGxzLm5leHRMb2FkTGV2ZWwgPSBzZWxlY3RlZEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXRQYXRod2F5Rm9yR3JvdXBJZChncm91cElkLCB0eXBlLCBkZWZhdWx0UGF0aHdheSkge1xuICAgIGNvbnN0IGxldmVscyA9IHRoaXMuZ2V0TGV2ZWxzRm9yUGF0aHdheShkZWZhdWx0UGF0aHdheSkuY29uY2F0KHRoaXMubGV2ZWxzIHx8IFtdKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0sgJiYgbGV2ZWxzW2ldLmhhc0F1ZGlvR3JvdXAoZ3JvdXBJZCkgfHwgdHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSyAmJiBsZXZlbHNbaV0uaGFzU3VidGl0bGVHcm91cChncm91cElkKSkge1xuICAgICAgICByZXR1cm4gbGV2ZWxzW2ldLnBhdGh3YXlJZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRQYXRod2F5O1xuICB9XG4gIGNsb25lUGF0aHdheXMocGF0aHdheUNsb25lcykge1xuICAgIGNvbnN0IGxldmVscyA9IHRoaXMubGV2ZWxzO1xuICAgIGlmICghbGV2ZWxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGF1ZGlvR3JvdXBDbG9uZU1hcCA9IHt9O1xuICAgIGNvbnN0IHN1YnRpdGxlR3JvdXBDbG9uZU1hcCA9IHt9O1xuICAgIHBhdGh3YXlDbG9uZXMuZm9yRWFjaChwYXRod2F5Q2xvbmUgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBJRDogY2xvbmVJZCxcbiAgICAgICAgJ0JBU0UtSUQnOiBiYXNlSWQsXG4gICAgICAgICdVUkktUkVQTEFDRU1FTlQnOiB1cmlSZXBsYWNlbWVudFxuICAgICAgfSA9IHBhdGh3YXlDbG9uZTtcbiAgICAgIGlmIChsZXZlbHMuc29tZShsZXZlbCA9PiBsZXZlbC5wYXRod2F5SWQgPT09IGNsb25lSWQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNsb25lZFZhcmlhbnRzID0gdGhpcy5nZXRMZXZlbHNGb3JQYXRod2F5KGJhc2VJZCkubWFwKGJhc2VMZXZlbCA9PiB7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBuZXcgQXR0ckxpc3QoYmFzZUxldmVsLmF0dHJzKTtcbiAgICAgICAgYXR0cmlidXRlc1snUEFUSFdBWS1JRCddID0gY2xvbmVJZDtcbiAgICAgICAgY29uc3QgY2xvbmVkQXVkaW9Hcm91cElkID0gYXR0cmlidXRlcy5BVURJTyAmJiBgJHthdHRyaWJ1dGVzLkFVRElPfV9jbG9uZV8ke2Nsb25lSWR9YDtcbiAgICAgICAgY29uc3QgY2xvbmVkU3VidGl0bGVHcm91cElkID0gYXR0cmlidXRlcy5TVUJUSVRMRVMgJiYgYCR7YXR0cmlidXRlcy5TVUJUSVRMRVN9X2Nsb25lXyR7Y2xvbmVJZH1gO1xuICAgICAgICBpZiAoY2xvbmVkQXVkaW9Hcm91cElkKSB7XG4gICAgICAgICAgYXVkaW9Hcm91cENsb25lTWFwW2F0dHJpYnV0ZXMuQVVESU9dID0gY2xvbmVkQXVkaW9Hcm91cElkO1xuICAgICAgICAgIGF0dHJpYnV0ZXMuQVVESU8gPSBjbG9uZWRBdWRpb0dyb3VwSWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsb25lZFN1YnRpdGxlR3JvdXBJZCkge1xuICAgICAgICAgIHN1YnRpdGxlR3JvdXBDbG9uZU1hcFthdHRyaWJ1dGVzLlNVQlRJVExFU10gPSBjbG9uZWRTdWJ0aXRsZUdyb3VwSWQ7XG4gICAgICAgICAgYXR0cmlidXRlcy5TVUJUSVRMRVMgPSBjbG9uZWRTdWJ0aXRsZUdyb3VwSWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsID0gcGVyZm9ybVVyaVJlcGxhY2VtZW50KGJhc2VMZXZlbC51cmksIGF0dHJpYnV0ZXNbJ1NUQUJMRS1WQVJJQU5ULUlEJ10sICdQRVItVkFSSUFOVC1VUklTJywgdXJpUmVwbGFjZW1lbnQpO1xuICAgICAgICBjb25zdCBjbG9uZWRMZXZlbCA9IG5ldyBMZXZlbCh7XG4gICAgICAgICAgYXR0cnM6IGF0dHJpYnV0ZXMsXG4gICAgICAgICAgYXVkaW9Db2RlYzogYmFzZUxldmVsLmF1ZGlvQ29kZWMsXG4gICAgICAgICAgYml0cmF0ZTogYmFzZUxldmVsLmJpdHJhdGUsXG4gICAgICAgICAgaGVpZ2h0OiBiYXNlTGV2ZWwuaGVpZ2h0LFxuICAgICAgICAgIG5hbWU6IGJhc2VMZXZlbC5uYW1lLFxuICAgICAgICAgIHVybCxcbiAgICAgICAgICB2aWRlb0NvZGVjOiBiYXNlTGV2ZWwudmlkZW9Db2RlYyxcbiAgICAgICAgICB3aWR0aDogYmFzZUxldmVsLndpZHRoXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYmFzZUxldmVsLmF1ZGlvR3JvdXBzKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBiYXNlTGV2ZWwuYXVkaW9Hcm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNsb25lZExldmVsLmFkZEdyb3VwSWQoJ2F1ZGlvJywgYCR7YmFzZUxldmVsLmF1ZGlvR3JvdXBzW2ldfV9jbG9uZV8ke2Nsb25lSWR9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlTGV2ZWwuc3VidGl0bGVHcm91cHMpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGJhc2VMZXZlbC5zdWJ0aXRsZUdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2xvbmVkTGV2ZWwuYWRkR3JvdXBJZCgndGV4dCcsIGAke2Jhc2VMZXZlbC5zdWJ0aXRsZUdyb3Vwc1tpXX1fY2xvbmVfJHtjbG9uZUlkfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xvbmVkTGV2ZWw7XG4gICAgICB9KTtcbiAgICAgIGxldmVscy5wdXNoKC4uLmNsb25lZFZhcmlhbnRzKTtcbiAgICAgIGNsb25lUmVuZGl0aW9uR3JvdXBzKHRoaXMuYXVkaW9UcmFja3MsIGF1ZGlvR3JvdXBDbG9uZU1hcCwgdXJpUmVwbGFjZW1lbnQsIGNsb25lSWQpO1xuICAgICAgY2xvbmVSZW5kaXRpb25Hcm91cHModGhpcy5zdWJ0aXRsZVRyYWNrcywgc3VidGl0bGVHcm91cENsb25lTWFwLCB1cmlSZXBsYWNlbWVudCwgY2xvbmVJZCk7XG4gICAgfSk7XG4gIH1cbiAgbG9hZFN0ZWVyaW5nTWFuaWZlc3QodXJpKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuICAgIGNvbnN0IExvYWRlciA9IGNvbmZpZy5sb2FkZXI7XG4gICAgaWYgKHRoaXMubG9hZGVyKSB7XG4gICAgICB0aGlzLmxvYWRlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMubG9hZGVyID0gbmV3IExvYWRlcihjb25maWcpO1xuICAgIGxldCB1cmw7XG4gICAgdHJ5IHtcbiAgICAgIHVybCA9IG5ldyBzZWxmLlVSTCh1cmkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMubG9nKGBGYWlsZWQgdG8gcGFyc2UgU3RlZXJpbmcgTWFuaWZlc3QgVVJJOiAke3VyaX1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHVybC5wcm90b2NvbCAhPT0gJ2RhdGE6Jykge1xuICAgICAgY29uc3QgdGhyb3VnaHB1dCA9ICh0aGlzLmhscy5iYW5kd2lkdGhFc3RpbWF0ZSB8fCBjb25maWcuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZSkgfCAwO1xuICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ19ITFNfcGF0aHdheScsIHRoaXMucGF0aHdheUlkKTtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdfSExTX3Rocm91Z2hwdXQnLCAnJyArIHRocm91Z2hwdXQpO1xuICAgIH1cbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgICB1cmw6IHVybC5ocmVmXG4gICAgfTtcbiAgICBjb25zdCBsb2FkUG9saWN5ID0gY29uZmlnLnN0ZWVyaW5nTWFuaWZlc3RMb2FkUG9saWN5LmRlZmF1bHQ7XG4gICAgY29uc3QgbGVnYWN5UmV0cnlDb21wYXRpYmlsaXR5ID0gbG9hZFBvbGljeS5lcnJvclJldHJ5IHx8IGxvYWRQb2xpY3kudGltZW91dFJldHJ5IHx8IHt9O1xuICAgIGNvbnN0IGxvYWRlckNvbmZpZyA9IHtcbiAgICAgIGxvYWRQb2xpY3ksXG4gICAgICB0aW1lb3V0OiBsb2FkUG9saWN5Lm1heExvYWRUaW1lTXMsXG4gICAgICBtYXhSZXRyeTogbGVnYWN5UmV0cnlDb21wYXRpYmlsaXR5Lm1heE51bVJldHJ5IHx8IDAsXG4gICAgICByZXRyeURlbGF5OiBsZWdhY3lSZXRyeUNvbXBhdGliaWxpdHkucmV0cnlEZWxheU1zIHx8IDAsXG4gICAgICBtYXhSZXRyeURlbGF5OiBsZWdhY3lSZXRyeUNvbXBhdGliaWxpdHkubWF4UmV0cnlEZWxheU1zIHx8IDBcbiAgICB9O1xuICAgIGNvbnN0IGNhbGxiYWNrcyA9IHtcbiAgICAgIG9uU3VjY2VzczogKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpID0+IHtcbiAgICAgICAgdGhpcy5sb2coYExvYWRlZCBzdGVlcmluZyBtYW5pZmVzdDogXCIke3VybH1cImApO1xuICAgICAgICBjb25zdCBzdGVlcmluZ0RhdGEgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICBpZiAoKHN0ZWVyaW5nRGF0YSA9PSBudWxsID8gdm9pZCAwIDogc3RlZXJpbmdEYXRhLlZFUlNJT04pICE9PSAxKSB7XG4gICAgICAgICAgdGhpcy5sb2coYFN0ZWVyaW5nIFZFUlNJT04gJHtzdGVlcmluZ0RhdGEuVkVSU0lPTn0gbm90IHN1cHBvcnRlZCFgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVkID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHRoaXMudGltZVRvTG9hZCA9IHN0ZWVyaW5nRGF0YS5UVEw7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAnUkVMT0FELVVSSSc6IHJlbG9hZFVyaSxcbiAgICAgICAgICAnUEFUSFdBWS1DTE9ORVMnOiBwYXRod2F5Q2xvbmVzLFxuICAgICAgICAgICdQQVRIV0FZLVBSSU9SSVRZJzogcGF0aHdheVByaW9yaXR5XG4gICAgICAgIH0gPSBzdGVlcmluZ0RhdGE7XG4gICAgICAgIGlmIChyZWxvYWRVcmkpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy51cmkgPSBuZXcgc2VsZi5VUkwocmVsb2FkVXJpLCB1cmwpLmhyZWY7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5sb2coYEZhaWxlZCB0byBwYXJzZSBTdGVlcmluZyBNYW5pZmVzdCBSRUxPQUQtVVJJOiAke3JlbG9hZFVyaX1gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY2hlZHVsZVJlZnJlc2godGhpcy51cmkgfHwgY29udGV4dC51cmwpO1xuICAgICAgICBpZiAocGF0aHdheUNsb25lcykge1xuICAgICAgICAgIHRoaXMuY2xvbmVQYXRod2F5cyhwYXRod2F5Q2xvbmVzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsb2FkZWRTdGVlcmluZ0RhdGEgPSB7XG4gICAgICAgICAgc3RlZXJpbmdNYW5pZmVzdDogc3RlZXJpbmdEYXRhLFxuICAgICAgICAgIHVybDogdXJsLnRvU3RyaW5nKClcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuU1RFRVJJTkdfTUFOSUZFU1RfTE9BREVELCBsb2FkZWRTdGVlcmluZ0RhdGEpO1xuICAgICAgICBpZiAocGF0aHdheVByaW9yaXR5KSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVQYXRod2F5UHJpb3JpdHkocGF0aHdheVByaW9yaXR5KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uRXJyb3I6IChlcnJvciwgY29udGV4dCwgbmV0d29ya0RldGFpbHMsIHN0YXRzKSA9PiB7XG4gICAgICAgIHRoaXMubG9nKGBFcnJvciBsb2FkaW5nIHN0ZWVyaW5nIG1hbmlmZXN0OiAke2Vycm9yLmNvZGV9ICR7ZXJyb3IudGV4dH0gKCR7Y29udGV4dC51cmx9KWApO1xuICAgICAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgICAgIGlmIChlcnJvci5jb2RlID09PSA0MTApIHtcbiAgICAgICAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmxvZyhgU3RlZXJpbmcgbWFuaWZlc3QgJHtjb250ZXh0LnVybH0gbm8gbG9uZ2VyIGF2YWlsYWJsZWApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdHRsID0gdGhpcy50aW1lVG9Mb2FkICogMTAwMDtcbiAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IDQyOSkge1xuICAgICAgICAgIGNvbnN0IGxvYWRlciA9IHRoaXMubG9hZGVyO1xuICAgICAgICAgIGlmICh0eXBlb2YgKGxvYWRlciA9PSBudWxsID8gdm9pZCAwIDogbG9hZGVyLmdldFJlc3BvbnNlSGVhZGVyKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc3QgcmV0cnlBZnRlciA9IGxvYWRlci5nZXRSZXNwb25zZUhlYWRlcignUmV0cnktQWZ0ZXInKTtcbiAgICAgICAgICAgIGlmIChyZXRyeUFmdGVyKSB7XG4gICAgICAgICAgICAgIHR0bCA9IHBhcnNlRmxvYXQocmV0cnlBZnRlcikgKiAxMDAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmxvZyhgU3RlZXJpbmcgbWFuaWZlc3QgJHtjb250ZXh0LnVybH0gcmF0ZSBsaW1pdGVkYCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2NoZWR1bGVSZWZyZXNoKHRoaXMudXJpIHx8IGNvbnRleHQudXJsLCB0dGwpO1xuICAgICAgfSxcbiAgICAgIG9uVGltZW91dDogKHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICB0aGlzLmxvZyhgVGltZW91dCBsb2FkaW5nIHN0ZWVyaW5nIG1hbmlmZXN0ICgke2NvbnRleHQudXJsfSlgKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZVJlZnJlc2godGhpcy51cmkgfHwgY29udGV4dC51cmwpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5sb2coYFJlcXVlc3Rpbmcgc3RlZXJpbmcgbWFuaWZlc3Q6ICR7dXJsfWApO1xuICAgIHRoaXMubG9hZGVyLmxvYWQoY29udGV4dCwgbG9hZGVyQ29uZmlnLCBjYWxsYmFja3MpO1xuICB9XG4gIHNjaGVkdWxlUmVmcmVzaCh1cmksIHR0bE1zID0gdGhpcy50aW1lVG9Mb2FkICogMTAwMCkge1xuICAgIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG4gICAgdGhpcy5yZWxvYWRUaW1lciA9IHNlbGYuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB2YXIgX3RoaXMkaGxzO1xuICAgICAgY29uc3QgbWVkaWEgPSAoX3RoaXMkaGxzID0gdGhpcy5obHMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRobHMubWVkaWE7XG4gICAgICBpZiAobWVkaWEgJiYgIW1lZGlhLmVuZGVkKSB7XG4gICAgICAgIHRoaXMubG9hZFN0ZWVyaW5nTWFuaWZlc3QodXJpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zY2hlZHVsZVJlZnJlc2godXJpLCB0aGlzLnRpbWVUb0xvYWQgKiAxMDAwKTtcbiAgICB9LCB0dGxNcyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsb25lUmVuZGl0aW9uR3JvdXBzKHRyYWNrcywgZ3JvdXBDbG9uZU1hcCwgdXJpUmVwbGFjZW1lbnQsIGNsb25lSWQpIHtcbiAgaWYgKCF0cmFja3MpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgT2JqZWN0LmtleXMoZ3JvdXBDbG9uZU1hcCkuZm9yRWFjaChhdWRpb0dyb3VwSWQgPT4ge1xuICAgIGNvbnN0IGNsb25lZFRyYWNrcyA9IHRyYWNrcy5maWx0ZXIodHJhY2sgPT4gdHJhY2suZ3JvdXBJZCA9PT0gYXVkaW9Hcm91cElkKS5tYXAodHJhY2sgPT4ge1xuICAgICAgY29uc3QgY2xvbmVkVHJhY2sgPSBfZXh0ZW5kcyh7fSwgdHJhY2spO1xuICAgICAgY2xvbmVkVHJhY2suZGV0YWlscyA9IHVuZGVmaW5lZDtcbiAgICAgIGNsb25lZFRyYWNrLmF0dHJzID0gbmV3IEF0dHJMaXN0KGNsb25lZFRyYWNrLmF0dHJzKTtcbiAgICAgIGNsb25lZFRyYWNrLnVybCA9IGNsb25lZFRyYWNrLmF0dHJzLlVSSSA9IHBlcmZvcm1VcmlSZXBsYWNlbWVudCh0cmFjay51cmwsIHRyYWNrLmF0dHJzWydTVEFCTEUtUkVORElUSU9OLUlEJ10sICdQRVItUkVORElUSU9OLVVSSVMnLCB1cmlSZXBsYWNlbWVudCk7XG4gICAgICBjbG9uZWRUcmFjay5ncm91cElkID0gY2xvbmVkVHJhY2suYXR0cnNbJ0dST1VQLUlEJ10gPSBncm91cENsb25lTWFwW2F1ZGlvR3JvdXBJZF07XG4gICAgICBjbG9uZWRUcmFjay5hdHRyc1snUEFUSFdBWS1JRCddID0gY2xvbmVJZDtcbiAgICAgIHJldHVybiBjbG9uZWRUcmFjaztcbiAgICB9KTtcbiAgICB0cmFja3MucHVzaCguLi5jbG9uZWRUcmFja3MpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHBlcmZvcm1VcmlSZXBsYWNlbWVudCh1cmksIHN0YWJsZUlkLCBwZXJPcHRpb25LZXksIHVyaVJlcGxhY2VtZW50KSB7XG4gIGNvbnN0IHtcbiAgICBIT1NUOiBob3N0LFxuICAgIFBBUkFNUzogcGFyYW1zLFxuICAgIFtwZXJPcHRpb25LZXldOiBwZXJPcHRpb25VcmlzXG4gIH0gPSB1cmlSZXBsYWNlbWVudDtcbiAgbGV0IHBlclZhcmlhbnRVcmk7XG4gIGlmIChzdGFibGVJZCkge1xuICAgIHBlclZhcmlhbnRVcmkgPSBwZXJPcHRpb25VcmlzID09IG51bGwgPyB2b2lkIDAgOiBwZXJPcHRpb25VcmlzW3N0YWJsZUlkXTtcbiAgICBpZiAocGVyVmFyaWFudFVyaSkge1xuICAgICAgdXJpID0gcGVyVmFyaWFudFVyaTtcbiAgICB9XG4gIH1cbiAgY29uc3QgdXJsID0gbmV3IHNlbGYuVVJMKHVyaSk7XG4gIGlmIChob3N0ICYmICFwZXJWYXJpYW50VXJpKSB7XG4gICAgdXJsLmhvc3QgPSBob3N0O1xuICB9XG4gIGlmIChwYXJhbXMpIHtcbiAgICBPYmplY3Qua2V5cyhwYXJhbXMpLnNvcnQoKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KGtleSwgcGFyYW1zW2tleV0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiB1cmwuaHJlZjtcbn1cblxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihlbCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbCwgdHlwZSwgbGlzdGVuZXIpO1xuICBlbC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWwsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpO1xufVxuXG4vKipcbiAqIENvbnRyb2xsZXIgdG8gZGVhbCB3aXRoIGVuY3J5cHRlZCBtZWRpYSBleHRlbnNpb25zIChFTUUpXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbmNyeXB0ZWRfTWVkaWFfRXh0ZW5zaW9uc19BUElcbiAqXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBFTUVDb250cm9sbGVyIGV4dGVuZHMgTG9nZ2VyIHtcbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgc3VwZXIoJ2VtZScsIGhscy5sb2dnZXIpO1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMua2V5Rm9ybWF0UHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5rZXlTeXN0ZW1BY2Nlc3NQcm9taXNlcyA9IHt9O1xuICAgIHRoaXMuX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50ID0gMDtcbiAgICB0aGlzLm1lZGlhS2V5U2Vzc2lvbnMgPSBbXTtcbiAgICB0aGlzLmtleUlkVG9LZXlTZXNzaW9uUHJvbWlzZSA9IHt9O1xuICAgIHRoaXMubWVkaWFLZXlzID0gbnVsbDtcbiAgICB0aGlzLnNldE1lZGlhS2V5c1F1ZXVlID0gRU1FQ29udHJvbGxlci5DRE1DbGVhbnVwUHJvbWlzZSA/IFtFTUVDb250cm9sbGVyLkNETUNsZWFudXBQcm9taXNlXSA6IFtdO1xuICAgIHRoaXMub25XYWl0aW5nRm9yS2V5ID0gZXZlbnQgPT4ge1xuICAgICAgdGhpcy5sb2coYFwiJHtldmVudC50eXBlfVwiIGV2ZW50YCk7XG4gICAgfTtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5vbkRlc3Ryb3lpbmcoKTtcbiAgICB0aGlzLm9uTWVkaWFEZXRhY2hlZCgpO1xuICAgIC8vIFJlbW92ZSBhbnkgcmVmZXJlbmNlcyB0aGF0IGNvdWxkIGJlIGhlbGQgaW4gY29uZmlnIG9wdGlvbnMgb3IgY2FsbGJhY2tzXG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgY29uZmlnLnJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc0Z1bmMgPSBudWxsO1xuICAgIGNvbmZpZy5saWNlbnNlWGhyU2V0dXAgPSBjb25maWcubGljZW5zZVJlc3BvbnNlQ2FsbGJhY2sgPSB1bmRlZmluZWQ7XG4gICAgY29uZmlnLmRybVN5c3RlbXMgPSBjb25maWcuZHJtU3lzdGVtT3B0aW9ucyA9IHt9O1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmhscyA9IHRoaXMuY29uZmlnID0gdGhpcy5rZXlJZFRvS2V5U2Vzc2lvblByb21pc2UgPSBudWxsO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLm9uV2FpdGluZ0ZvcktleSA9IG51bGw7XG4gIH1cbiAgcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5obHMub24oRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgdGhpcy5obHMub24oRXZlbnRzLk1FRElBX0RFVEFDSEVELCB0aGlzLm9uTWVkaWFEZXRhY2hlZCwgdGhpcyk7XG4gICAgdGhpcy5obHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FERUQsIHRoaXMub25NYW5pZmVzdExvYWRlZCwgdGhpcyk7XG4gICAgdGhpcy5obHMub24oRXZlbnRzLkRFU1RST1lJTkcsIHRoaXMub25EZXN0cm95aW5nLCB0aGlzKTtcbiAgfVxuICB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHRoaXMuaGxzLm9mZihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vZmYoRXZlbnRzLk1FRElBX0RFVEFDSEVELCB0aGlzLm9uTWVkaWFEZXRhY2hlZCwgdGhpcyk7XG4gICAgdGhpcy5obHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURFRCwgdGhpcy5vbk1hbmlmZXN0TG9hZGVkLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vZmYoRXZlbnRzLkRFU1RST1lJTkcsIHRoaXMub25EZXN0cm95aW5nLCB0aGlzKTtcbiAgfVxuICBnZXRMaWNlbnNlU2VydmVyVXJsKGtleVN5c3RlbSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRybVN5c3RlbXMsXG4gICAgICB3aWRldmluZUxpY2Vuc2VVcmxcbiAgICB9ID0gdGhpcy5jb25maWc7XG4gICAgY29uc3Qga2V5U3lzdGVtQ29uZmlndXJhdGlvbiA9IGRybVN5c3RlbXNba2V5U3lzdGVtXTtcbiAgICBpZiAoa2V5U3lzdGVtQ29uZmlndXJhdGlvbikge1xuICAgICAgcmV0dXJuIGtleVN5c3RlbUNvbmZpZ3VyYXRpb24ubGljZW5zZVVybDtcbiAgICB9XG5cbiAgICAvLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgIGlmIChrZXlTeXN0ZW0gPT09IEtleVN5c3RlbXMuV0lERVZJTkUgJiYgd2lkZXZpbmVMaWNlbnNlVXJsKSB7XG4gICAgICByZXR1cm4gd2lkZXZpbmVMaWNlbnNlVXJsO1xuICAgIH1cbiAgfVxuICBnZXRMaWNlbnNlU2VydmVyVXJsT3JUaHJvdyhrZXlTeXN0ZW0pIHtcbiAgICBjb25zdCB1cmwgPSB0aGlzLmdldExpY2Vuc2VTZXJ2ZXJVcmwoa2V5U3lzdGVtKTtcbiAgICBpZiAodXJsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gbGljZW5zZSBzZXJ2ZXIgVVJMIGNvbmZpZ3VyZWQgZm9yIGtleS1zeXN0ZW0gXCIke2tleVN5c3RlbX1cImApO1xuICAgIH1cbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIGdldFNlcnZlckNlcnRpZmljYXRlVXJsKGtleVN5c3RlbSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRybVN5c3RlbXNcbiAgICB9ID0gdGhpcy5jb25maWc7XG4gICAgY29uc3Qga2V5U3lzdGVtQ29uZmlndXJhdGlvbiA9IGRybVN5c3RlbXNba2V5U3lzdGVtXTtcbiAgICBpZiAoa2V5U3lzdGVtQ29uZmlndXJhdGlvbikge1xuICAgICAgcmV0dXJuIGtleVN5c3RlbUNvbmZpZ3VyYXRpb24uc2VydmVyQ2VydGlmaWNhdGVVcmw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nKGBObyBTZXJ2ZXIgQ2VydGlmaWNhdGUgaW4gY29uZmlnLmRybVN5c3RlbXNbXCIke2tleVN5c3RlbX1cIl1gKTtcbiAgICB9XG4gIH1cbiAgYXR0ZW1wdEtleVN5c3RlbUFjY2VzcyhrZXlTeXN0ZW1zVG9BdHRlbXB0KSB7XG4gICAgY29uc3QgbGV2ZWxzID0gdGhpcy5obHMubGV2ZWxzO1xuICAgIGNvbnN0IHVuaXF1ZUNvZGVjID0gKHZhbHVlLCBpLCBhKSA9PiAhIXZhbHVlICYmIGEuaW5kZXhPZih2YWx1ZSkgPT09IGk7XG4gICAgY29uc3QgYXVkaW9Db2RlY3MgPSBsZXZlbHMubWFwKGxldmVsID0+IGxldmVsLmF1ZGlvQ29kZWMpLmZpbHRlcih1bmlxdWVDb2RlYyk7XG4gICAgY29uc3QgdmlkZW9Db2RlY3MgPSBsZXZlbHMubWFwKGxldmVsID0+IGxldmVsLnZpZGVvQ29kZWMpLmZpbHRlcih1bmlxdWVDb2RlYyk7XG4gICAgaWYgKGF1ZGlvQ29kZWNzLmxlbmd0aCArIHZpZGVvQ29kZWNzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdmlkZW9Db2RlY3MucHVzaCgnYXZjMS40MmUwMWUnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGF0dGVtcHQgPSBrZXlTeXN0ZW1zID0+IHtcbiAgICAgICAgY29uc3Qga2V5U3lzdGVtID0ga2V5U3lzdGVtcy5zaGlmdCgpO1xuICAgICAgICB0aGlzLmdldE1lZGlhS2V5c1Byb21pc2Uoa2V5U3lzdGVtLCBhdWRpb0NvZGVjcywgdmlkZW9Db2RlY3MpLnRoZW4obWVkaWFLZXlzID0+IHJlc29sdmUoe1xuICAgICAgICAgIGtleVN5c3RlbSxcbiAgICAgICAgICBtZWRpYUtleXNcbiAgICAgICAgfSkpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICBpZiAoa2V5U3lzdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGF0dGVtcHQoa2V5U3lzdGVtcyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChlcnJvciBpbnN0YW5jZW9mIEVNRUtleUVycm9yKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVNRUtleUVycm9yKHtcbiAgICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9OT19BQ0NFU1MsXG4gICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgICAgICAgfSwgZXJyb3IubWVzc2FnZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgYXR0ZW1wdChrZXlTeXN0ZW1zVG9BdHRlbXB0KTtcbiAgICB9KTtcbiAgfVxuICByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3Moa2V5U3lzdGVtLCBzdXBwb3J0ZWRDb25maWd1cmF0aW9ucykge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc0Z1bmNcbiAgICB9ID0gdGhpcy5jb25maWc7XG4gICAgaWYgKCEodHlwZW9mIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc0Z1bmMgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICBsZXQgZXJyTWVzc2FnZSA9IGBDb25maWd1cmVkIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyBpcyBub3QgYSBmdW5jdGlvbiAke3JlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc0Z1bmN9YDtcbiAgICAgIGlmIChyZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgPT09IG51bGwgJiYgc2VsZi5sb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2h0dHA6Jykge1xuICAgICAgICBlcnJNZXNzYWdlID0gYG5hdmlnYXRvci5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgaXMgbm90IGF2YWlsYWJsZSBvdmVyIGluc2VjdXJlIHByb3RvY29sICR7bG9jYXRpb24ucHJvdG9jb2x9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoZXJyTWVzc2FnZSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzRnVuYyhrZXlTeXN0ZW0sIHN1cHBvcnRlZENvbmZpZ3VyYXRpb25zKTtcbiAgfVxuICBnZXRNZWRpYUtleXNQcm9taXNlKGtleVN5c3RlbSwgYXVkaW9Db2RlY3MsIHZpZGVvQ29kZWNzKSB7XG4gICAgLy8gVGhpcyBjYW4gdGhyb3csIGJ1dCBpcyBjYXVnaHQgaW4gZXZlbnQgaGFuZGxlciBjYWxscGF0aFxuICAgIGNvbnN0IG1lZGlhS2V5U3lzdGVtQ29uZmlncyA9IGdldFN1cHBvcnRlZE1lZGlhS2V5U3lzdGVtQ29uZmlndXJhdGlvbnMoa2V5U3lzdGVtLCBhdWRpb0NvZGVjcywgdmlkZW9Db2RlY3MsIHRoaXMuY29uZmlnLmRybVN5c3RlbU9wdGlvbnMpO1xuICAgIGNvbnN0IGtleVN5c3RlbUFjY2Vzc1Byb21pc2VzID0gdGhpcy5rZXlTeXN0ZW1BY2Nlc3NQcm9taXNlc1trZXlTeXN0ZW1dO1xuICAgIGxldCBrZXlTeXN0ZW1BY2Nlc3MgPSBrZXlTeXN0ZW1BY2Nlc3NQcm9taXNlcyA9PSBudWxsID8gdm9pZCAwIDoga2V5U3lzdGVtQWNjZXNzUHJvbWlzZXMua2V5U3lzdGVtQWNjZXNzO1xuICAgIGlmICgha2V5U3lzdGVtQWNjZXNzKSB7XG4gICAgICB0aGlzLmxvZyhgUmVxdWVzdGluZyBlbmNyeXB0ZWQgbWVkaWEgXCIke2tleVN5c3RlbX1cIiBrZXktc3lzdGVtIGFjY2VzcyB3aXRoIGNvbmZpZzogJHtzdHJpbmdpZnkobWVkaWFLZXlTeXN0ZW1Db25maWdzKX1gKTtcbiAgICAgIGtleVN5c3RlbUFjY2VzcyA9IHRoaXMucmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzKGtleVN5c3RlbSwgbWVkaWFLZXlTeXN0ZW1Db25maWdzKTtcbiAgICAgIGNvbnN0IF9rZXlTeXN0ZW1BY2Nlc3NQcm9taXNlcyA9IHRoaXMua2V5U3lzdGVtQWNjZXNzUHJvbWlzZXNba2V5U3lzdGVtXSA9IHtcbiAgICAgICAga2V5U3lzdGVtQWNjZXNzXG4gICAgICB9O1xuICAgICAga2V5U3lzdGVtQWNjZXNzLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgdGhpcy5sb2coYEZhaWxlZCB0byBvYnRhaW4gYWNjZXNzIHRvIGtleS1zeXN0ZW0gXCIke2tleVN5c3RlbX1cIjogJHtlcnJvcn1gKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGtleVN5c3RlbUFjY2Vzcy50aGVuKG1lZGlhS2V5U3lzdGVtQWNjZXNzID0+IHtcbiAgICAgICAgdGhpcy5sb2coYEFjY2VzcyBmb3Iga2V5LXN5c3RlbSBcIiR7bWVkaWFLZXlTeXN0ZW1BY2Nlc3Mua2V5U3lzdGVtfVwiIG9idGFpbmVkYCk7XG4gICAgICAgIGNvbnN0IGNlcnRpZmljYXRlUmVxdWVzdCA9IHRoaXMuZmV0Y2hTZXJ2ZXJDZXJ0aWZpY2F0ZShrZXlTeXN0ZW0pO1xuICAgICAgICB0aGlzLmxvZyhgQ3JlYXRlIG1lZGlhLWtleXMgZm9yIFwiJHtrZXlTeXN0ZW19XCJgKTtcbiAgICAgICAgX2tleVN5c3RlbUFjY2Vzc1Byb21pc2VzLm1lZGlhS2V5cyA9IG1lZGlhS2V5U3lzdGVtQWNjZXNzLmNyZWF0ZU1lZGlhS2V5cygpLnRoZW4obWVkaWFLZXlzID0+IHtcbiAgICAgICAgICB0aGlzLmxvZyhgTWVkaWEta2V5cyBjcmVhdGVkIGZvciBcIiR7a2V5U3lzdGVtfVwiYCk7XG4gICAgICAgICAgX2tleVN5c3RlbUFjY2Vzc1Byb21pc2VzLmhhc01lZGlhS2V5cyA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGNlcnRpZmljYXRlUmVxdWVzdC50aGVuKGNlcnRpZmljYXRlID0+IHtcbiAgICAgICAgICAgIGlmIChjZXJ0aWZpY2F0ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRNZWRpYUtleXNTZXJ2ZXJDZXJ0aWZpY2F0ZShtZWRpYUtleXMsIGtleVN5c3RlbSwgY2VydGlmaWNhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lZGlhS2V5cztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIF9rZXlTeXN0ZW1BY2Nlc3NQcm9taXNlcy5tZWRpYUtleXMuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgIHRoaXMuZXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgbWVkaWEta2V5cyBmb3IgXCIke2tleVN5c3RlbX1cIn06ICR7ZXJyb3J9YCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX2tleVN5c3RlbUFjY2Vzc1Byb21pc2VzLm1lZGlhS2V5cztcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ga2V5U3lzdGVtQWNjZXNzLnRoZW4oKCkgPT4ga2V5U3lzdGVtQWNjZXNzUHJvbWlzZXMubWVkaWFLZXlzKTtcbiAgfVxuICBjcmVhdGVNZWRpYUtleVNlc3Npb25Db250ZXh0KHtcbiAgICBkZWNyeXB0ZGF0YSxcbiAgICBrZXlTeXN0ZW0sXG4gICAgbWVkaWFLZXlzXG4gIH0pIHtcbiAgICB0aGlzLmxvZyhgQ3JlYXRpbmcga2V5LXN5c3RlbSBzZXNzaW9uIFwiJHtrZXlTeXN0ZW19XCIga2V5SWQ6ICR7SGV4LmhleER1bXAoZGVjcnlwdGRhdGEua2V5SWQgfHwgW10pfWApO1xuICAgIGNvbnN0IG1lZGlhS2V5c1Nlc3Npb24gPSBtZWRpYUtleXMuY3JlYXRlU2Vzc2lvbigpO1xuICAgIGNvbnN0IG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQgPSB7XG4gICAgICBkZWNyeXB0ZGF0YSxcbiAgICAgIGtleVN5c3RlbSxcbiAgICAgIG1lZGlhS2V5cyxcbiAgICAgIG1lZGlhS2V5c1Nlc3Npb24sXG4gICAgICBrZXlTdGF0dXM6ICdzdGF0dXMtcGVuZGluZydcbiAgICB9O1xuICAgIHRoaXMubWVkaWFLZXlTZXNzaW9ucy5wdXNoKG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQpO1xuICAgIHJldHVybiBtZWRpYUtleVNlc3Npb25Db250ZXh0O1xuICB9XG4gIHJlbmV3S2V5U2Vzc2lvbihtZWRpYUtleVNlc3Npb25Db250ZXh0KSB7XG4gICAgY29uc3QgZGVjcnlwdGRhdGEgPSBtZWRpYUtleVNlc3Npb25Db250ZXh0LmRlY3J5cHRkYXRhO1xuICAgIGlmIChkZWNyeXB0ZGF0YS5wc3NoKSB7XG4gICAgICBjb25zdCBrZXlTZXNzaW9uQ29udGV4dCA9IHRoaXMuY3JlYXRlTWVkaWFLZXlTZXNzaW9uQ29udGV4dChtZWRpYUtleVNlc3Npb25Db250ZXh0KTtcbiAgICAgIGNvbnN0IGtleUlkID0gdGhpcy5nZXRLZXlJZFN0cmluZyhkZWNyeXB0ZGF0YSk7XG4gICAgICBjb25zdCBzY2hlbWUgPSAnY2VuYyc7XG4gICAgICB0aGlzLmtleUlkVG9LZXlTZXNzaW9uUHJvbWlzZVtrZXlJZF0gPSB0aGlzLmdlbmVyYXRlUmVxdWVzdFdpdGhQcmVmZXJyZWRLZXlTZXNzaW9uKGtleVNlc3Npb25Db250ZXh0LCBzY2hlbWUsIGRlY3J5cHRkYXRhLnBzc2guYnVmZmVyLCAnZXhwaXJlZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndhcm4oYENvdWxkIG5vdCByZW5ldyBleHBpcmVkIHNlc3Npb24uIE1pc3NpbmcgcHNzaCBpbml0RGF0YS5gKTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVTZXNzaW9uKG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQpO1xuICB9XG4gIGdldEtleUlkU3RyaW5nKGRlY3J5cHRkYXRhKSB7XG4gICAgaWYgKCFkZWNyeXB0ZGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgcmVhZCBrZXlJZCBvZiB1bmRlZmluZWQgZGVjcnlwdGRhdGEnKTtcbiAgICB9XG4gICAgaWYgKGRlY3J5cHRkYXRhLmtleUlkID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2tleUlkIGlzIG51bGwnKTtcbiAgICB9XG4gICAgcmV0dXJuIEhleC5oZXhEdW1wKGRlY3J5cHRkYXRhLmtleUlkKTtcbiAgfVxuICB1cGRhdGVLZXlTZXNzaW9uKG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQsIGRhdGEpIHtcbiAgICB2YXIgX21lZGlhS2V5U2Vzc2lvbkNvbnRlO1xuICAgIGNvbnN0IGtleVNlc3Npb24gPSBtZWRpYUtleVNlc3Npb25Db250ZXh0Lm1lZGlhS2V5c1Nlc3Npb247XG4gICAgdGhpcy5sb2coYFVwZGF0aW5nIGtleS1zZXNzaW9uIFwiJHtrZXlTZXNzaW9uLnNlc3Npb25JZH1cIiBmb3Iga2V5SUQgJHtIZXguaGV4RHVtcCgoKF9tZWRpYUtleVNlc3Npb25Db250ZSA9IG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQuZGVjcnlwdGRhdGEpID09IG51bGwgPyB2b2lkIDAgOiBfbWVkaWFLZXlTZXNzaW9uQ29udGUua2V5SWQpIHx8IFtdKX1cbiAgICAgIH0gKGRhdGEgbGVuZ3RoOiAke2RhdGEgPyBkYXRhLmJ5dGVMZW5ndGggOiBkYXRhfSlgKTtcbiAgICByZXR1cm4ga2V5U2Vzc2lvbi51cGRhdGUoZGF0YSk7XG4gIH1cbiAgZ2V0U2VsZWN0ZWRLZXlTeXN0ZW1Gb3JtYXRzKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmtleVN5c3RlbUFjY2Vzc1Byb21pc2VzKS5tYXAoa2V5U3lzdGVtID0+ICh7XG4gICAgICBrZXlTeXN0ZW0sXG4gICAgICBoYXNNZWRpYUtleXM6IHRoaXMua2V5U3lzdGVtQWNjZXNzUHJvbWlzZXNba2V5U3lzdGVtXS5oYXNNZWRpYUtleXNcbiAgICB9KSkuZmlsdGVyKCh7XG4gICAgICBoYXNNZWRpYUtleXNcbiAgICB9KSA9PiAhIWhhc01lZGlhS2V5cykubWFwKCh7XG4gICAgICBrZXlTeXN0ZW1cbiAgICB9KSA9PiBrZXlTeXN0ZW1Eb21haW5Ub0tleVN5c3RlbUZvcm1hdChrZXlTeXN0ZW0pKS5maWx0ZXIoa2V5U3lzdGVtID0+ICEha2V5U3lzdGVtKTtcbiAgfVxuICBnZXRLZXlTeXN0ZW1BY2Nlc3Moa2V5U3lzdGVtc1RvQXR0ZW1wdCkge1xuICAgIHJldHVybiB0aGlzLmdldEtleVN5c3RlbVNlbGVjdGlvblByb21pc2Uoa2V5U3lzdGVtc1RvQXR0ZW1wdCkudGhlbigoe1xuICAgICAga2V5U3lzdGVtLFxuICAgICAgbWVkaWFLZXlzXG4gICAgfSkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0ZW1wdFNldE1lZGlhS2V5cyhrZXlTeXN0ZW0sIG1lZGlhS2V5cyk7XG4gICAgfSk7XG4gIH1cbiAgc2VsZWN0S2V5U3lzdGVtKGtleVN5c3RlbXNUb0F0dGVtcHQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0S2V5U3lzdGVtU2VsZWN0aW9uUHJvbWlzZShrZXlTeXN0ZW1zVG9BdHRlbXB0KS50aGVuKCh7XG4gICAgICAgIGtleVN5c3RlbVxuICAgICAgfSkgPT4ge1xuICAgICAgICBjb25zdCBrZXlTeXN0ZW1Gb3JtYXQgPSBrZXlTeXN0ZW1Eb21haW5Ub0tleVN5c3RlbUZvcm1hdChrZXlTeXN0ZW0pO1xuICAgICAgICBpZiAoa2V5U3lzdGVtRm9ybWF0KSB7XG4gICAgICAgICAgcmVzb2x2ZShrZXlTeXN0ZW1Gb3JtYXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYFVuYWJsZSB0byBmaW5kIGZvcm1hdCBmb3Iga2V5LXN5c3RlbSBcIiR7a2V5U3lzdGVtfVwiYCkpO1xuICAgICAgICB9XG4gICAgICB9KS5jYXRjaChyZWplY3QpO1xuICAgIH0pO1xuICB9XG4gIHNlbGVjdEtleVN5c3RlbUZvcm1hdChmcmFnKSB7XG4gICAgY29uc3Qga2V5Rm9ybWF0cyA9IE9iamVjdC5rZXlzKGZyYWcubGV2ZWxrZXlzIHx8IHt9KTtcbiAgICBpZiAoIXRoaXMua2V5Rm9ybWF0UHJvbWlzZSkge1xuICAgICAgdGhpcy5sb2coYFNlbGVjdGluZyBrZXktc3lzdGVtIGZyb20gZnJhZ21lbnQgKHNuOiAke2ZyYWcuc259ICR7ZnJhZy50eXBlfTogJHtmcmFnLmxldmVsfSkga2V5IGZvcm1hdHMgJHtrZXlGb3JtYXRzLmpvaW4oJywgJyl9YCk7XG4gICAgICB0aGlzLmtleUZvcm1hdFByb21pc2UgPSB0aGlzLmdldEtleUZvcm1hdFByb21pc2Uoa2V5Rm9ybWF0cyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmtleUZvcm1hdFByb21pc2U7XG4gIH1cbiAgZ2V0S2V5Rm9ybWF0UHJvbWlzZShrZXlGb3JtYXRzKSB7XG4gICAgY29uc3Qga2V5U3lzdGVtc0luQ29uZmlnID0gZ2V0S2V5U3lzdGVtc0ZvckNvbmZpZyh0aGlzLmNvbmZpZyk7XG4gICAgY29uc3Qga2V5U3lzdGVtc1RvQXR0ZW1wdCA9IGtleUZvcm1hdHMubWFwKGtleVN5c3RlbUZvcm1hdFRvS2V5U3lzdGVtRG9tYWluKS5maWx0ZXIodmFsdWUgPT4gISF2YWx1ZSAmJiBrZXlTeXN0ZW1zSW5Db25maWcuaW5kZXhPZih2YWx1ZSkgIT09IC0xKTtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3RLZXlTeXN0ZW0oa2V5U3lzdGVtc1RvQXR0ZW1wdCk7XG4gIH1cbiAgbG9hZEtleShkYXRhKSB7XG4gICAgY29uc3QgZGVjcnlwdGRhdGEgPSBkYXRhLmtleUluZm8uZGVjcnlwdGRhdGE7XG4gICAgY29uc3Qga2V5SWQgPSB0aGlzLmdldEtleUlkU3RyaW5nKGRlY3J5cHRkYXRhKTtcbiAgICBjb25zdCBrZXlEZXRhaWxzID0gYChrZXlJZDogJHtrZXlJZH0gZm9ybWF0OiBcIiR7ZGVjcnlwdGRhdGEua2V5Rm9ybWF0fVwiIG1ldGhvZDogJHtkZWNyeXB0ZGF0YS5tZXRob2R9IHVyaTogJHtkZWNyeXB0ZGF0YS51cml9KWA7XG4gICAgdGhpcy5sb2coYFN0YXJ0aW5nIHNlc3Npb24gZm9yIGtleSAke2tleURldGFpbHN9YCk7XG4gICAgbGV0IGtleUNvbnRleHRQcm9taXNlID0gdGhpcy5rZXlJZFRvS2V5U2Vzc2lvblByb21pc2Vba2V5SWRdO1xuICAgIGlmICgha2V5Q29udGV4dFByb21pc2UpIHtcbiAgICAgIGtleUNvbnRleHRQcm9taXNlID0gdGhpcy5nZXRLZXlTeXN0ZW1Gb3JLZXlQcm9taXNlKGRlY3J5cHRkYXRhKS50aGVuKCh7XG4gICAgICAgIGtleVN5c3RlbSxcbiAgICAgICAgbWVkaWFLZXlzXG4gICAgICB9KSA9PiB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICB0aGlzLmxvZyhgSGFuZGxlIGVuY3J5cHRlZCBtZWRpYSBzbjogJHtkYXRhLmZyYWcuc259ICR7ZGF0YS5mcmFnLnR5cGV9OiAke2RhdGEuZnJhZy5sZXZlbH0gdXNpbmcga2V5ICR7a2V5RGV0YWlsc31gKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0ZW1wdFNldE1lZGlhS2V5cyhrZXlTeXN0ZW0sIG1lZGlhS2V5cykudGhlbigoKSA9PiB7XG4gICAgICAgICAgdGhpcy50aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTWVkaWFLZXlTZXNzaW9uQ29udGV4dCh7XG4gICAgICAgICAgICBrZXlTeXN0ZW0sXG4gICAgICAgICAgICBtZWRpYUtleXMsXG4gICAgICAgICAgICBkZWNyeXB0ZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgY29uc3Qga2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlID0gdGhpcy5rZXlJZFRvS2V5U2Vzc2lvblByb21pc2Vba2V5SWRdID0ga2V5Q29udGV4dFByb21pc2UudGhlbihrZXlTZXNzaW9uQ29udGV4dCA9PiB7XG4gICAgICAgIGNvbnN0IHNjaGVtZSA9ICdjZW5jJztcbiAgICAgICAgY29uc3QgaW5pdERhdGEgPSBkZWNyeXB0ZGF0YS5wc3NoID8gZGVjcnlwdGRhdGEucHNzaC5idWZmZXIgOiBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZVJlcXVlc3RXaXRoUHJlZmVycmVkS2V5U2Vzc2lvbihrZXlTZXNzaW9uQ29udGV4dCwgc2NoZW1lLCBpbml0RGF0YSwgJ3BsYXlsaXN0LWtleScpO1xuICAgICAgfSk7XG4gICAgICBrZXlTZXNzaW9uQ29udGV4dFByb21pc2UuY2F0Y2goZXJyb3IgPT4gdGhpcy5oYW5kbGVFcnJvcihlcnJvcikpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5Q29udGV4dFByb21pc2U7XG4gIH1cbiAgdGhyb3dJZkRlc3Ryb3llZChtZXNzYWdlID0gJ0ludmFsaWQgc3RhdGUnKSB7XG4gICAgaWYgKCF0aGlzLmhscykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHN0YXRlJyk7XG4gICAgfVxuICB9XG4gIGhhbmRsZUVycm9yKGVycm9yKSB7XG4gICAgaWYgKCF0aGlzLmhscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVNRUtleUVycm9yKSB7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwgZXJyb3IuZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fTk9fS0VZUyxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0S2V5U3lzdGVtRm9yS2V5UHJvbWlzZShkZWNyeXB0ZGF0YSkge1xuICAgIGNvbnN0IGtleUlkID0gdGhpcy5nZXRLZXlJZFN0cmluZyhkZWNyeXB0ZGF0YSk7XG4gICAgY29uc3QgbWVkaWFLZXlTZXNzaW9uQ29udGV4dCA9IHRoaXMua2V5SWRUb0tleVNlc3Npb25Qcm9taXNlW2tleUlkXTtcbiAgICBpZiAoIW1lZGlhS2V5U2Vzc2lvbkNvbnRleHQpIHtcbiAgICAgIGNvbnN0IGtleVN5c3RlbSA9IGtleVN5c3RlbUZvcm1hdFRvS2V5U3lzdGVtRG9tYWluKGRlY3J5cHRkYXRhLmtleUZvcm1hdCk7XG4gICAgICBjb25zdCBrZXlTeXN0ZW1zVG9BdHRlbXB0ID0ga2V5U3lzdGVtID8gW2tleVN5c3RlbV0gOiBnZXRLZXlTeXN0ZW1zRm9yQ29uZmlnKHRoaXMuY29uZmlnKTtcbiAgICAgIHJldHVybiB0aGlzLmF0dGVtcHRLZXlTeXN0ZW1BY2Nlc3Moa2V5U3lzdGVtc1RvQXR0ZW1wdCk7XG4gICAgfVxuICAgIHJldHVybiBtZWRpYUtleVNlc3Npb25Db250ZXh0O1xuICB9XG4gIGdldEtleVN5c3RlbVNlbGVjdGlvblByb21pc2Uoa2V5U3lzdGVtc1RvQXR0ZW1wdCkge1xuICAgIGlmICgha2V5U3lzdGVtc1RvQXR0ZW1wdC5sZW5ndGgpIHtcbiAgICAgIGtleVN5c3RlbXNUb0F0dGVtcHQgPSBnZXRLZXlTeXN0ZW1zRm9yQ29uZmlnKHRoaXMuY29uZmlnKTtcbiAgICB9XG4gICAgaWYgKGtleVN5c3RlbXNUb0F0dGVtcHQubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRU1FS2V5RXJyb3Ioe1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX05PX0NPTkZJR1VSRURfTElDRU5TRSxcbiAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgIH0sIGBNaXNzaW5nIGtleS1zeXN0ZW0gbGljZW5zZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgJHtzdHJpbmdpZnkoe1xuICAgICAgICBkcm1TeXN0ZW1zOiB0aGlzLmNvbmZpZy5kcm1TeXN0ZW1zXG4gICAgICB9KX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYXR0ZW1wdEtleVN5c3RlbUFjY2VzcyhrZXlTeXN0ZW1zVG9BdHRlbXB0KTtcbiAgfVxuICBhdHRlbXB0U2V0TWVkaWFLZXlzKGtleVN5c3RlbSwgbWVkaWFLZXlzKSB7XG4gICAgaWYgKHRoaXMubWVkaWFLZXlzID09PSBtZWRpYUtleXMpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgcXVldWUgPSB0aGlzLnNldE1lZGlhS2V5c1F1ZXVlLnNsaWNlKCk7XG4gICAgdGhpcy5sb2coYFNldHRpbmcgbWVkaWEta2V5cyBmb3IgXCIke2tleVN5c3RlbX1cImApO1xuICAgIC8vIE9ubHkgb25lIHNldE1lZGlhS2V5cygpIGNhbiBydW4gYXQgb25lIHRpbWUsIGFuZCBtdWx0aXBsZSBzZXRNZWRpYUtleXMoKSBvcGVyYXRpb25zXG4gICAgLy8gY2FuIGJlIHF1ZXVlZCBmb3IgZXhlY3V0aW9uIGZvciBtdWx0aXBsZSBrZXkgc2Vzc2lvbnMuXG4gICAgY29uc3Qgc2V0TWVkaWFLZXlzUHJvbWlzZSA9IFByb21pc2UuYWxsKHF1ZXVlKS50aGVuKCgpID0+IHtcbiAgICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgICB0aGlzLm1lZGlhS2V5cyA9IG51bGw7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIHNldCBtZWRpYUtleXMgd2l0aG91dCBtZWRpYSBlbGVtZW50IGF0dGFjaGVkJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5tZWRpYS5zZXRNZWRpYUtleXMobWVkaWFLZXlzKTtcbiAgICB9KTtcbiAgICB0aGlzLm1lZGlhS2V5cyA9IG1lZGlhS2V5cztcbiAgICB0aGlzLnNldE1lZGlhS2V5c1F1ZXVlLnB1c2goc2V0TWVkaWFLZXlzUHJvbWlzZSk7XG4gICAgcmV0dXJuIHNldE1lZGlhS2V5c1Byb21pc2UudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLmxvZyhgTWVkaWEta2V5cyBzZXQgZm9yIFwiJHtrZXlTeXN0ZW19XCJgKTtcbiAgICAgIHF1ZXVlLnB1c2goc2V0TWVkaWFLZXlzUHJvbWlzZSk7XG4gICAgICB0aGlzLnNldE1lZGlhS2V5c1F1ZXVlID0gdGhpcy5zZXRNZWRpYUtleXNRdWV1ZS5maWx0ZXIocCA9PiBxdWV1ZS5pbmRleE9mKHApID09PSAtMSk7XG4gICAgfSk7XG4gIH1cbiAgZ2VuZXJhdGVSZXF1ZXN0V2l0aFByZWZlcnJlZEtleVNlc3Npb24oY29udGV4dCwgaW5pdERhdGFUeXBlLCBpbml0RGF0YSwgcmVhc29uKSB7XG4gICAgdmFyIF90aGlzJGNvbmZpZyRkcm1TeXN0ZSwgX3RoaXMkY29uZmlnJGRybVN5c3RlMjtcbiAgICBjb25zdCBnZW5lcmF0ZVJlcXVlc3RGaWx0ZXIgPSAoX3RoaXMkY29uZmlnJGRybVN5c3RlID0gdGhpcy5jb25maWcuZHJtU3lzdGVtcykgPT0gbnVsbCA/IHZvaWQgMCA6IChfdGhpcyRjb25maWckZHJtU3lzdGUyID0gX3RoaXMkY29uZmlnJGRybVN5c3RlW2NvbnRleHQua2V5U3lzdGVtXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGNvbmZpZyRkcm1TeXN0ZTIuZ2VuZXJhdGVSZXF1ZXN0O1xuICAgIGlmIChnZW5lcmF0ZVJlcXVlc3RGaWx0ZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG1hcHBlZEluaXREYXRhID0gZ2VuZXJhdGVSZXF1ZXN0RmlsdGVyLmNhbGwodGhpcy5obHMsIGluaXREYXRhVHlwZSwgaW5pdERhdGEsIGNvbnRleHQpO1xuICAgICAgICBpZiAoIW1hcHBlZEluaXREYXRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJlc3BvbnNlIGZyb20gY29uZmlndXJlZCBnZW5lcmF0ZVJlcXVlc3QgZmlsdGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaW5pdERhdGFUeXBlID0gbWFwcGVkSW5pdERhdGEuaW5pdERhdGFUeXBlO1xuICAgICAgICBpbml0RGF0YSA9IG1hcHBlZEluaXREYXRhLmluaXREYXRhID8gbWFwcGVkSW5pdERhdGEuaW5pdERhdGEgOiBudWxsO1xuICAgICAgICBjb250ZXh0LmRlY3J5cHRkYXRhLnBzc2ggPSBpbml0RGF0YSA/IG5ldyBVaW50OEFycmF5KGluaXREYXRhKSA6IG51bGw7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB2YXIgX3RoaXMkaGxzO1xuICAgICAgICB0aGlzLndhcm4oZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIGlmICgoX3RoaXMkaGxzID0gdGhpcy5obHMpICE9IG51bGwgJiYgX3RoaXMkaGxzLmNvbmZpZy5kZWJ1Zykge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpbml0RGF0YSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5sb2coYFNraXBwaW5nIGtleS1zZXNzaW9uIHJlcXVlc3QgZm9yIFwiJHtyZWFzb259XCIgKG5vIGluaXREYXRhKWApO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjb250ZXh0KTtcbiAgICB9XG4gICAgY29uc3Qga2V5SWQgPSB0aGlzLmdldEtleUlkU3RyaW5nKGNvbnRleHQuZGVjcnlwdGRhdGEpO1xuICAgIHRoaXMubG9nKGBHZW5lcmF0aW5nIGtleS1zZXNzaW9uIHJlcXVlc3QgZm9yIFwiJHtyZWFzb259XCI6ICR7a2V5SWR9IChpbml0IGRhdGEgdHlwZTogJHtpbml0RGF0YVR5cGV9IGxlbmd0aDogJHtpbml0RGF0YSA/IGluaXREYXRhLmJ5dGVMZW5ndGggOiBudWxsfSlgKTtcbiAgICBjb25zdCBsaWNlbnNlU3RhdHVzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIGNvbnN0IG9ubWVzc2FnZSA9IGNvbnRleHQuX29ubWVzc2FnZSA9IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGtleVNlc3Npb24gPSBjb250ZXh0Lm1lZGlhS2V5c1Nlc3Npb247XG4gICAgICBpZiAoIWtleVNlc3Npb24pIHtcbiAgICAgICAgbGljZW5zZVN0YXR1cy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignaW52YWxpZCBzdGF0ZScpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBtZXNzYWdlVHlwZSxcbiAgICAgICAgbWVzc2FnZVxuICAgICAgfSA9IGV2ZW50O1xuICAgICAgdGhpcy5sb2coYFwiJHttZXNzYWdlVHlwZX1cIiBtZXNzYWdlIGV2ZW50IGZvciBzZXNzaW9uIFwiJHtrZXlTZXNzaW9uLnNlc3Npb25JZH1cIiBtZXNzYWdlIHNpemU6ICR7bWVzc2FnZS5ieXRlTGVuZ3RofWApO1xuICAgICAgaWYgKG1lc3NhZ2VUeXBlID09PSAnbGljZW5zZS1yZXF1ZXN0JyB8fCBtZXNzYWdlVHlwZSA9PT0gJ2xpY2Vuc2UtcmVuZXdhbCcpIHtcbiAgICAgICAgdGhpcy5yZW5ld0xpY2Vuc2UoY29udGV4dCwgbWVzc2FnZSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgIGlmIChsaWNlbnNlU3RhdHVzLmV2ZW50TmFtZXMoKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxpY2Vuc2VTdGF0dXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKG1lc3NhZ2VUeXBlID09PSAnbGljZW5zZS1yZWxlYXNlJykge1xuICAgICAgICBpZiAoY29udGV4dC5rZXlTeXN0ZW0gPT09IEtleVN5c3RlbXMuRkFJUlBMQVkpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUtleVNlc3Npb24oY29udGV4dCwgc3RyVG9VdGY4YXJyYXkoJ2Fja25vd2xlZGdlZCcpKTtcbiAgICAgICAgICB0aGlzLnJlbW92ZVNlc3Npb24oY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud2FybihgdW5oYW5kbGVkIG1lZGlhIGtleSBtZXNzYWdlIHR5cGUgXCIke21lc3NhZ2VUeXBlfVwiYCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBvbmtleXN0YXR1c2VzY2hhbmdlID0gY29udGV4dC5fb25rZXlzdGF0dXNlc2NoYW5nZSA9IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGtleVNlc3Npb24gPSBjb250ZXh0Lm1lZGlhS2V5c1Nlc3Npb247XG4gICAgICBpZiAoIWtleVNlc3Npb24pIHtcbiAgICAgICAgbGljZW5zZVN0YXR1cy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignaW52YWxpZCBzdGF0ZScpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5vbktleVN0YXR1c0NoYW5nZShjb250ZXh0KTtcbiAgICAgIGNvbnN0IGtleVN0YXR1cyA9IGNvbnRleHQua2V5U3RhdHVzO1xuICAgICAgbGljZW5zZVN0YXR1cy5lbWl0KCdrZXlTdGF0dXMnLCBrZXlTdGF0dXMpO1xuICAgICAgaWYgKGtleVN0YXR1cyA9PT0gJ2V4cGlyZWQnKSB7XG4gICAgICAgIHRoaXMud2FybihgJHtjb250ZXh0LmtleVN5c3RlbX0gZXhwaXJlZCBmb3Iga2V5ICR7a2V5SWR9YCk7XG4gICAgICAgIHRoaXMucmVuZXdLZXlTZXNzaW9uKGNvbnRleHQpO1xuICAgICAgfVxuICAgIH07XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihjb250ZXh0Lm1lZGlhS2V5c1Nlc3Npb24sICdtZXNzYWdlJywgb25tZXNzYWdlKTtcbiAgICBhZGRFdmVudExpc3RlbmVyKGNvbnRleHQubWVkaWFLZXlzU2Vzc2lvbiwgJ2tleXN0YXR1c2VzY2hhbmdlJywgb25rZXlzdGF0dXNlc2NoYW5nZSk7XG4gICAgY29uc3Qga2V5VXNhYmxlUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxpY2Vuc2VTdGF0dXMub24oJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgIGxpY2Vuc2VTdGF0dXMub24oJ2tleVN0YXR1cycsIGtleVN0YXR1cyA9PiB7XG4gICAgICAgIGlmIChrZXlTdGF0dXMuc3RhcnRzV2l0aCgndXNhYmxlJykpIHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5U3RhdHVzID09PSAnb3V0cHV0LXJlc3RyaWN0ZWQnKSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFTUVLZXlFcnJvcih7XG4gICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9TVEFUVVNfT1VUUFVUX1JFU1RSSUNURUQsXG4gICAgICAgICAgICBmYXRhbDogZmFsc2VcbiAgICAgICAgICB9LCAnSERDUCBsZXZlbCBvdXRwdXQgcmVzdHJpY3RlZCcpKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXlTdGF0dXMgPT09ICdpbnRlcm5hbC1lcnJvcicpIHtcbiAgICAgICAgICByZWplY3QobmV3IEVNRUtleUVycm9yKHtcbiAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX1NUQVRVU19JTlRFUk5BTF9FUlJPUixcbiAgICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgICAgfSwgYGtleSBzdGF0dXMgY2hhbmdlZCB0byBcIiR7a2V5U3RhdHVzfVwiYCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGtleVN0YXR1cyA9PT0gJ2V4cGlyZWQnKSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcigna2V5IGV4cGlyZWQgd2hpbGUgZ2VuZXJhdGluZyByZXF1ZXN0JykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMud2FybihgdW5oYW5kbGVkIGtleSBzdGF0dXMgY2hhbmdlIFwiJHtrZXlTdGF0dXN9XCJgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbnRleHQubWVkaWFLZXlzU2Vzc2lvbi5nZW5lcmF0ZVJlcXVlc3QoaW5pdERhdGFUeXBlLCBpbml0RGF0YSkudGhlbigoKSA9PiB7XG4gICAgICB2YXIgX2NvbnRleHQkbWVkaWFLZXlzU2VzO1xuICAgICAgdGhpcy5sb2coYFJlcXVlc3QgZ2VuZXJhdGVkIGZvciBrZXktc2Vzc2lvbiBcIiR7KF9jb250ZXh0JG1lZGlhS2V5c1NlcyA9IGNvbnRleHQubWVkaWFLZXlzU2Vzc2lvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jb250ZXh0JG1lZGlhS2V5c1Nlcy5zZXNzaW9uSWR9XCIga2V5SWQ6ICR7a2V5SWR9YCk7XG4gICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVNRUtleUVycm9yKHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9OT19TRVNTSU9OLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgZmF0YWw6IGZhbHNlXG4gICAgICB9LCBgRXJyb3IgZ2VuZXJhdGluZyBrZXktc2Vzc2lvbiByZXF1ZXN0OiAke2Vycm9yfWApO1xuICAgIH0pLnRoZW4oKCkgPT4ga2V5VXNhYmxlUHJvbWlzZSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgbGljZW5zZVN0YXR1cy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMucmVtb3ZlU2Vzc2lvbihjb250ZXh0KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgbGljZW5zZVN0YXR1cy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH0pO1xuICB9XG4gIG9uS2V5U3RhdHVzQ2hhbmdlKG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQpIHtcbiAgICBtZWRpYUtleVNlc3Npb25Db250ZXh0Lm1lZGlhS2V5c1Nlc3Npb24ua2V5U3RhdHVzZXMuZm9yRWFjaCgoc3RhdHVzLCBrZXlJZCkgPT4ge1xuICAgICAgLy8ga2V5U3RhdHVzZXMuZm9yRWFjaCBpcyBub3Qgc3RhbmRhcmQgQVBJIHNvIHRoZSBjYWxsYmFjayB2YWx1ZSBsb29rcyB3ZWlyZCBvbiB4Ym94b25lXG4gICAgICAvLyB4Ym94b25lIGNhbGxiYWNrKGtleUlkLCBzdGF0dXMpIHNvIHdlIG5lZWQgdG8gZXhjaGFuZ2UgdGhlbVxuICAgICAgaWYgKHR5cGVvZiBrZXlJZCA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHN0YXR1cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgY29uc3QgdGVtcCA9IGtleUlkO1xuICAgICAgICBrZXlJZCA9IHN0YXR1cztcbiAgICAgICAgc3RhdHVzID0gdGVtcDtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nKGBrZXkgc3RhdHVzIGNoYW5nZSBcIiR7c3RhdHVzfVwiIGZvciBrZXlTdGF0dXNlcyBrZXlJZDogJHtIZXguaGV4RHVtcCgnYnVmZmVyJyBpbiBrZXlJZCA/IG5ldyBVaW50OEFycmF5KGtleUlkLmJ1ZmZlciwga2V5SWQuYnl0ZU9mZnNldCwga2V5SWQuYnl0ZUxlbmd0aCkgOiBuZXcgVWludDhBcnJheShrZXlJZCkpfSBzZXNzaW9uIGtleUlkOiAke0hleC5oZXhEdW1wKG5ldyBVaW50OEFycmF5KG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQuZGVjcnlwdGRhdGEua2V5SWQgfHwgW10pKX0gdXJpOiAke21lZGlhS2V5U2Vzc2lvbkNvbnRleHQuZGVjcnlwdGRhdGEudXJpfWApO1xuICAgICAgbWVkaWFLZXlTZXNzaW9uQ29udGV4dC5rZXlTdGF0dXMgPSBzdGF0dXM7XG4gICAgfSk7XG4gIH1cbiAgZmV0Y2hTZXJ2ZXJDZXJ0aWZpY2F0ZShrZXlTeXN0ZW0pIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBjb25zdCBMb2FkZXIgPSBjb25maWcubG9hZGVyO1xuICAgIGNvbnN0IGNlcnRMb2FkZXIgPSBuZXcgTG9hZGVyKGNvbmZpZyk7XG4gICAgY29uc3QgdXJsID0gdGhpcy5nZXRTZXJ2ZXJDZXJ0aWZpY2F0ZVVybChrZXlTeXN0ZW0pO1xuICAgIGlmICghdXJsKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHRoaXMubG9nKGBGZXRjaGluZyBzZXJ2ZXIgY2VydGlmaWNhdGUgZm9yIFwiJHtrZXlTeXN0ZW19XCJgKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgbG9hZGVyQ29udGV4dCA9IHtcbiAgICAgICAgcmVzcG9uc2VUeXBlOiAnYXJyYXlidWZmZXInLFxuICAgICAgICB1cmxcbiAgICAgIH07XG4gICAgICBjb25zdCBsb2FkUG9saWN5ID0gY29uZmlnLmNlcnRMb2FkUG9saWN5LmRlZmF1bHQ7XG4gICAgICBjb25zdCBsb2FkZXJDb25maWcgPSB7XG4gICAgICAgIGxvYWRQb2xpY3ksXG4gICAgICAgIHRpbWVvdXQ6IGxvYWRQb2xpY3kubWF4TG9hZFRpbWVNcyxcbiAgICAgICAgbWF4UmV0cnk6IDAsXG4gICAgICAgIHJldHJ5RGVsYXk6IDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXk6IDBcbiAgICAgIH07XG4gICAgICBjb25zdCBsb2FkZXJDYWxsYmFja3MgPSB7XG4gICAgICAgIG9uU3VjY2VzczogKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpID0+IHtcbiAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlLmRhdGEpO1xuICAgICAgICB9LFxuICAgICAgICBvbkVycm9yOiAocmVzcG9uc2UsIGNvbnRleCwgbmV0d29ya0RldGFpbHMsIHN0YXRzKSA9PiB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFTUVLZXlFcnJvcih7XG4gICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9TRVJWRVJfQ0VSVElGSUNBVEVfUkVRVUVTVF9GQUlMRUQsXG4gICAgICAgICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgcmVzcG9uc2U6IF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgICAgICAgdXJsOiBsb2FkZXJDb250ZXh0LnVybCxcbiAgICAgICAgICAgICAgZGF0YTogdW5kZWZpbmVkXG4gICAgICAgICAgICB9LCByZXNwb25zZSlcbiAgICAgICAgICB9LCBgXCIke2tleVN5c3RlbX1cIiBjZXJ0aWZpY2F0ZSByZXF1ZXN0IGZhaWxlZCAoJHt1cmx9KS4gU3RhdHVzOiAke3Jlc3BvbnNlLmNvZGV9ICgke3Jlc3BvbnNlLnRleHR9KWApKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25UaW1lb3V0OiAoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFTUVLZXlFcnJvcih7XG4gICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9TRVJWRVJfQ0VSVElGSUNBVEVfUkVRVUVTVF9GQUlMRUQsXG4gICAgICAgICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgdXJsOiBsb2FkZXJDb250ZXh0LnVybCxcbiAgICAgICAgICAgICAgZGF0YTogdW5kZWZpbmVkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgYFwiJHtrZXlTeXN0ZW19XCIgY2VydGlmaWNhdGUgcmVxdWVzdCB0aW1lZCBvdXQgKCR7dXJsfSlgKSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQWJvcnQ6IChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpID0+IHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdhYm9ydGVkJykpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY2VydExvYWRlci5sb2FkKGxvYWRlckNvbnRleHQsIGxvYWRlckNvbmZpZywgbG9hZGVyQ2FsbGJhY2tzKTtcbiAgICB9KTtcbiAgfVxuICBzZXRNZWRpYUtleXNTZXJ2ZXJDZXJ0aWZpY2F0ZShtZWRpYUtleXMsIGtleVN5c3RlbSwgY2VydCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBtZWRpYUtleXMuc2V0U2VydmVyQ2VydGlmaWNhdGUoY2VydCkudGhlbihzdWNjZXNzID0+IHtcbiAgICAgICAgdGhpcy5sb2coYHNldFNlcnZlckNlcnRpZmljYXRlICR7c3VjY2VzcyA/ICdzdWNjZXNzJyA6ICdub3Qgc3VwcG9ydGVkIGJ5IENETSd9ICgke2NlcnQgPT0gbnVsbCA/IHZvaWQgMCA6IGNlcnQuYnl0ZUxlbmd0aH0pIG9uIFwiJHtrZXlTeXN0ZW19XCJgKTtcbiAgICAgICAgcmVzb2x2ZShtZWRpYUtleXMpO1xuICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICByZWplY3QobmV3IEVNRUtleUVycm9yKHtcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fU0VSVkVSX0NFUlRJRklDQVRFX1VQREFURV9GQUlMRUQsXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgICAgfSwgZXJyb3IubWVzc2FnZSkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmVuZXdMaWNlbnNlKGNvbnRleHQsIGtleU1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0TGljZW5zZShjb250ZXh0LCBuZXcgVWludDhBcnJheShrZXlNZXNzYWdlKSkudGhlbihkYXRhID0+IHtcbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUtleVNlc3Npb24oY29udGV4dCwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVNRUtleUVycm9yKHtcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fU0VTU0lPTl9VUERBVEVfRkFJTEVELFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgIH0sIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgdW5wYWNrUGxheVJlYWR5S2V5TWVzc2FnZSh4aHIsIGxpY2Vuc2VDaGFsbGVuZ2UpIHtcbiAgICAvLyBPbiBFZGdlLCB0aGUgcmF3IGxpY2Vuc2UgbWVzc2FnZSBpcyBVVEYtMTYtZW5jb2RlZCBYTUwuICBXZSBuZWVkXG4gICAgLy8gdG8gdW5wYWNrIHRoZSBDaGFsbGVuZ2UgZWxlbWVudCAoYmFzZTY0LWVuY29kZWQgc3RyaW5nIGNvbnRhaW5pbmcgdGhlXG4gICAgLy8gYWN0dWFsIGxpY2Vuc2UgcmVxdWVzdCkgYW5kIGFueSBIdHRwSGVhZGVyIGVsZW1lbnRzIChzZW50IGFzIHJlcXVlc3RcbiAgICAvLyBoZWFkZXJzKS5cbiAgICAvLyBGb3IgUGxheVJlYWR5IENETXMsIHdlIG5lZWQgdG8gZGlnIHRoZSBDaGFsbGVuZ2Ugb3V0IG9mIHRoZSBYTUwuXG4gICAgY29uc3QgeG1sU3RyaW5nID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDE2QXJyYXkobGljZW5zZUNoYWxsZW5nZS5idWZmZXIpKTtcbiAgICBpZiAoIXhtbFN0cmluZy5pbmNsdWRlcygnUGxheVJlYWR5S2V5TWVzc2FnZScpKSB7XG4gICAgICAvLyBUaGlzIGRvZXMgbm90IGFwcGVhciB0byBiZSBhIHdyYXBwZWQgbWVzc2FnZSBhcyBvbiBFZGdlLiAgU29tZVxuICAgICAgLy8gY2xpZW50cyBkbyBub3QgbmVlZCB0aGlzIHVud3JhcHBpbmcsIHNvIHdlIHdpbGwgYXNzdW1lIHRoaXMgaXMgb25lIG9mXG4gICAgICAvLyB0aGVtLiAgTm90ZSB0aGF0IFwieG1sXCIgYXQgdGhpcyBwb2ludCBwcm9iYWJseSBsb29rcyBsaWtlIHJhbmRvbVxuICAgICAgLy8gZ2FyYmFnZSwgc2luY2Ugd2UgaW50ZXJwcmV0ZWQgVVRGLTggYXMgVVRGLTE2LlxuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICd0ZXh0L3htbDsgY2hhcnNldD11dGYtOCcpO1xuICAgICAgcmV0dXJuIGxpY2Vuc2VDaGFsbGVuZ2U7XG4gICAgfVxuICAgIGNvbnN0IGtleU1lc3NhZ2VYbWwgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHhtbFN0cmluZywgJ2FwcGxpY2F0aW9uL3htbCcpO1xuICAgIC8vIFNldCByZXF1ZXN0IGhlYWRlcnMuXG4gICAgY29uc3QgaGVhZGVycyA9IGtleU1lc3NhZ2VYbWwucXVlcnlTZWxlY3RvckFsbCgnSHR0cEhlYWRlcicpO1xuICAgIGlmIChoZWFkZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIGxldCBoZWFkZXI7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gaGVhZGVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgX2hlYWRlciRxdWVyeVNlbGVjdG9yLCBfaGVhZGVyJHF1ZXJ5U2VsZWN0b3IyO1xuICAgICAgICBoZWFkZXIgPSBoZWFkZXJzW2ldO1xuICAgICAgICBjb25zdCBuYW1lID0gKF9oZWFkZXIkcXVlcnlTZWxlY3RvciA9IGhlYWRlci5xdWVyeVNlbGVjdG9yKCduYW1lJykpID09IG51bGwgPyB2b2lkIDAgOiBfaGVhZGVyJHF1ZXJ5U2VsZWN0b3IudGV4dENvbnRlbnQ7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gKF9oZWFkZXIkcXVlcnlTZWxlY3RvcjIgPSBoZWFkZXIucXVlcnlTZWxlY3RvcigndmFsdWUnKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9oZWFkZXIkcXVlcnlTZWxlY3RvcjIudGV4dENvbnRlbnQ7XG4gICAgICAgIGlmIChuYW1lICYmIHZhbHVlKSB7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNoYWxsZW5nZUVsZW1lbnQgPSBrZXlNZXNzYWdlWG1sLnF1ZXJ5U2VsZWN0b3IoJ0NoYWxsZW5nZScpO1xuICAgIGNvbnN0IGNoYWxsZW5nZVRleHQgPSBjaGFsbGVuZ2VFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBjaGFsbGVuZ2VFbGVtZW50LnRleHRDb250ZW50O1xuICAgIGlmICghY2hhbGxlbmdlVGV4dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZmluZCA8Q2hhbGxlbmdlPiBpbiBrZXkgbWVzc2FnZWApO1xuICAgIH1cbiAgICByZXR1cm4gc3RyVG9VdGY4YXJyYXkoYXRvYihjaGFsbGVuZ2VUZXh0KSk7XG4gIH1cbiAgc2V0dXBMaWNlbnNlWEhSKHhociwgdXJsLCBrZXlzTGlzdEl0ZW0sIGxpY2Vuc2VDaGFsbGVuZ2UpIHtcbiAgICBjb25zdCBsaWNlbnNlWGhyU2V0dXAgPSB0aGlzLmNvbmZpZy5saWNlbnNlWGhyU2V0dXA7XG4gICAgaWYgKCFsaWNlbnNlWGhyU2V0dXApIHtcbiAgICAgIHhoci5vcGVuKCdQT1NUJywgdXJsLCB0cnVlKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICB4aHIsXG4gICAgICAgIGxpY2Vuc2VDaGFsbGVuZ2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICBpZiAoIWtleXNMaXN0SXRlbS5kZWNyeXB0ZGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleSByZW1vdmVkJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGljZW5zZVhoclNldHVwLmNhbGwodGhpcy5obHMsIHhociwgdXJsLCBrZXlzTGlzdEl0ZW0sIGxpY2Vuc2VDaGFsbGVuZ2UpO1xuICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgIGlmICgha2V5c0xpc3RJdGVtLmRlY3J5cHRkYXRhKSB7XG4gICAgICAgIC8vIEtleSBzZXNzaW9uIHJlbW92ZWQuIENhbmNlbCBsaWNlbnNlIHJlcXVlc3QuXG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgLy8gbGV0J3MgdHJ5IHRvIG9wZW4gYmVmb3JlIHJ1bm5pbmcgc2V0dXBcbiAgICAgIHhoci5vcGVuKCdQT1NUJywgdXJsLCB0cnVlKTtcbiAgICAgIHJldHVybiBsaWNlbnNlWGhyU2V0dXAuY2FsbCh0aGlzLmhscywgeGhyLCB1cmwsIGtleXNMaXN0SXRlbSwgbGljZW5zZUNoYWxsZW5nZSk7XG4gICAgfSkudGhlbihsaWNlbnNlWGhyU2V0dXBSZXN1bHQgPT4ge1xuICAgICAgLy8gaWYgbGljZW5zZVhoclNldHVwIGRpZCBub3QgeWV0IGNhbGwgb3BlbiwgbGV0J3MgZG8gaXQgbm93XG4gICAgICBpZiAoIXhoci5yZWFkeVN0YXRlKSB7XG4gICAgICAgIHhoci5vcGVuKCdQT1NUJywgdXJsLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZpbmFsTGljZW5zZUNoYWxsZW5nZSA9IGxpY2Vuc2VYaHJTZXR1cFJlc3VsdCA/IGxpY2Vuc2VYaHJTZXR1cFJlc3VsdCA6IGxpY2Vuc2VDaGFsbGVuZ2U7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4aHIsXG4gICAgICAgIGxpY2Vuc2VDaGFsbGVuZ2U6IGZpbmFsTGljZW5zZUNoYWxsZW5nZVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICByZXF1ZXN0TGljZW5zZShrZXlTZXNzaW9uQ29udGV4dCwgbGljZW5zZUNoYWxsZW5nZSkge1xuICAgIGNvbnN0IGtleUxvYWRQb2xpY3kgPSB0aGlzLmNvbmZpZy5rZXlMb2FkUG9saWN5LmRlZmF1bHQ7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHVybCA9IHRoaXMuZ2V0TGljZW5zZVNlcnZlclVybE9yVGhyb3coa2V5U2Vzc2lvbkNvbnRleHQua2V5U3lzdGVtKTtcbiAgICAgIHRoaXMubG9nKGBTZW5kaW5nIGxpY2Vuc2UgcmVxdWVzdCB0byBVUkw6ICR7dXJsfWApO1xuICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5obHMgfHwgIWtleVNlc3Npb25Db250ZXh0Lm1lZGlhS2V5c1Nlc3Npb24pIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignaW52YWxpZCBzdGF0ZScpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCA9IDA7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHhoci5yZXNwb25zZTtcbiAgICAgICAgICAgIHRoaXMubG9nKGBMaWNlbnNlIHJlY2VpdmVkICR7ZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gZGF0YS5ieXRlTGVuZ3RoIDogZGF0YX1gKTtcbiAgICAgICAgICAgIGNvbnN0IGxpY2Vuc2VSZXNwb25zZUNhbGxiYWNrID0gdGhpcy5jb25maWcubGljZW5zZVJlc3BvbnNlQ2FsbGJhY2s7XG4gICAgICAgICAgICBpZiAobGljZW5zZVJlc3BvbnNlQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkYXRhID0gbGljZW5zZVJlc3BvbnNlQ2FsbGJhY2suY2FsbCh0aGlzLmhscywgeGhyLCB1cmwsIGtleVNlc3Npb25Db250ZXh0KTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmV0cnlDb25maWcgPSBrZXlMb2FkUG9saWN5LmVycm9yUmV0cnk7XG4gICAgICAgICAgICBjb25zdCBtYXhOdW1SZXRyeSA9IHJldHJ5Q29uZmlnID8gcmV0cnlDb25maWcubWF4TnVtUmV0cnkgOiAwO1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdExpY2Vuc2VGYWlsdXJlQ291bnQrKztcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCA+IG1heE51bVJldHJ5IHx8IHhoci5zdGF0dXMgPj0gNDAwICYmIHhoci5zdGF0dXMgPCA1MDApIHtcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFTUVLZXlFcnJvcih7XG4gICAgICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX0xJQ0VOU0VfUkVRVUVTVF9GQUlMRUQsXG4gICAgICAgICAgICAgICAgZmF0YWw6IHRydWUsXG4gICAgICAgICAgICAgICAgbmV0d29ya0RldGFpbHM6IHhocixcbiAgICAgICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgICAgZGF0YTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgY29kZTogeGhyLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgIHRleHQ6IHhoci5zdGF0dXNUZXh0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LCBgTGljZW5zZSBSZXF1ZXN0IFhIUiBmYWlsZWQgKCR7dXJsfSkuIFN0YXR1czogJHt4aHIuc3RhdHVzfSAoJHt4aHIuc3RhdHVzVGV4dH0pYCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgYXR0ZW1wdHNMZWZ0ID0gbWF4TnVtUmV0cnkgLSB0aGlzLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCArIDE7XG4gICAgICAgICAgICAgIHRoaXMud2FybihgUmV0cnlpbmcgbGljZW5zZSByZXF1ZXN0LCAke2F0dGVtcHRzTGVmdH0gYXR0ZW1wdHMgbGVmdGApO1xuICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RMaWNlbnNlKGtleVNlc3Npb25Db250ZXh0LCBsaWNlbnNlQ2hhbGxlbmdlKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKGtleVNlc3Npb25Db250ZXh0LmxpY2Vuc2VYaHIgJiYga2V5U2Vzc2lvbkNvbnRleHQubGljZW5zZVhoci5yZWFkeVN0YXRlICE9PSBYTUxIdHRwUmVxdWVzdC5ET05FKSB7XG4gICAgICAgIGtleVNlc3Npb25Db250ZXh0LmxpY2Vuc2VYaHIuYWJvcnQoKTtcbiAgICAgIH1cbiAgICAgIGtleVNlc3Npb25Db250ZXh0LmxpY2Vuc2VYaHIgPSB4aHI7XG4gICAgICB0aGlzLnNldHVwTGljZW5zZVhIUih4aHIsIHVybCwga2V5U2Vzc2lvbkNvbnRleHQsIGxpY2Vuc2VDaGFsbGVuZ2UpLnRoZW4oKHtcbiAgICAgICAgeGhyLFxuICAgICAgICBsaWNlbnNlQ2hhbGxlbmdlXG4gICAgICB9KSA9PiB7XG4gICAgICAgIGlmIChrZXlTZXNzaW9uQ29udGV4dC5rZXlTeXN0ZW0gPT0gS2V5U3lzdGVtcy5QTEFZUkVBRFkpIHtcbiAgICAgICAgICBsaWNlbnNlQ2hhbGxlbmdlID0gdGhpcy51bnBhY2tQbGF5UmVhZHlLZXlNZXNzYWdlKHhociwgbGljZW5zZUNoYWxsZW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgeGhyLnNlbmQobGljZW5zZUNoYWxsZW5nZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBvbkRlc3Ryb3lpbmcoKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fY2xlYXIoKTtcbiAgfVxuICBvbk1lZGlhQXR0YWNoZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuY29uZmlnLmVtZUVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWVkaWEgPSBkYXRhLm1lZGlhO1xuXG4gICAgLy8ga2VlcCByZWZlcmVuY2Ugb2YgbWVkaWFcbiAgICB0aGlzLm1lZGlhID0gbWVkaWE7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihtZWRpYSwgJ3dhaXRpbmdmb3JrZXknLCB0aGlzLm9uV2FpdGluZ0ZvcktleSk7XG4gIH1cbiAgb25NZWRpYURldGFjaGVkKCkge1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIobWVkaWEsICd3YWl0aW5nZm9ya2V5JywgdGhpcy5vbldhaXRpbmdGb3JLZXkpO1xuICAgICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgICB0aGlzLm1lZGlhS2V5cyA9IG51bGw7XG4gICAgfVxuICB9XG4gIF9jbGVhcigpIHtcbiAgICB2YXIgX21lZGlhJHNldE1lZGlhS2V5cztcbiAgICB0aGlzLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCA9IDA7XG4gICAgdGhpcy5rZXlJZFRvS2V5U2Vzc2lvblByb21pc2UgPSB7fTtcbiAgICBpZiAoIXRoaXMubWVkaWFLZXlzICYmICF0aGlzLm1lZGlhS2V5U2Vzc2lvbnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBjb25zdCBtZWRpYUtleXNMaXN0ID0gdGhpcy5tZWRpYUtleVNlc3Npb25zLnNsaWNlKCk7XG4gICAgdGhpcy5tZWRpYUtleVNlc3Npb25zID0gW107XG4gICAgdGhpcy5tZWRpYUtleXMgPSBudWxsO1xuICAgIExldmVsS2V5LmNsZWFyS2V5VXJpVG9LZXlJZE1hcCgpO1xuXG4gICAgLy8gQ2xvc2UgYWxsIHNlc3Npb25zIGFuZCByZW1vdmUgbWVkaWEga2V5cyBmcm9tIHRoZSB2aWRlbyBlbGVtZW50LlxuICAgIGNvbnN0IGtleVNlc3Npb25Db3VudCA9IG1lZGlhS2V5c0xpc3QubGVuZ3RoO1xuICAgIEVNRUNvbnRyb2xsZXIuQ0RNQ2xlYW51cFByb21pc2UgPSBQcm9taXNlLmFsbChtZWRpYUtleXNMaXN0Lm1hcChtZWRpYUtleVNlc3Npb25Db250ZXh0ID0+IHRoaXMucmVtb3ZlU2Vzc2lvbihtZWRpYUtleVNlc3Npb25Db250ZXh0KSkuY29uY2F0KG1lZGlhID09IG51bGwgPyB2b2lkIDAgOiAoX21lZGlhJHNldE1lZGlhS2V5cyA9IG1lZGlhLnNldE1lZGlhS2V5cyhudWxsKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9tZWRpYSRzZXRNZWRpYUtleXMuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgdmFyIF90aGlzJGhsczI7XG4gICAgICB0aGlzLmxvZyhgQ291bGQgbm90IGNsZWFyIG1lZGlhIGtleXM6ICR7ZXJyb3J9YCk7XG4gICAgICAoX3RoaXMkaGxzMiA9IHRoaXMuaGxzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkaGxzMi50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9ERVNUUk9ZX01FRElBX0tFWVNfRVJST1IsXG4gICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihgQ291bGQgbm90IGNsZWFyIG1lZGlhIGtleXM6ICR7ZXJyb3J9YClcbiAgICAgIH0pO1xuICAgIH0pKSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgdmFyIF90aGlzJGhsczM7XG4gICAgICB0aGlzLmxvZyhgQ291bGQgbm90IGNsb3NlIHNlc3Npb25zIGFuZCBjbGVhciBtZWRpYSBrZXlzOiAke2Vycm9yfWApO1xuICAgICAgKF90aGlzJGhsczMgPSB0aGlzLmhscykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGhsczMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5PVEhFUl9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fREVTVFJPWV9DTE9TRV9TRVNTSU9OX0VSUk9SLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIGVycm9yOiBuZXcgRXJyb3IoYENvdWxkIG5vdCBjbG9zZSBzZXNzaW9ucyBhbmQgY2xlYXIgbWVkaWEga2V5czogJHtlcnJvcn1gKVxuICAgICAgfSk7XG4gICAgfSkudGhlbigoKSA9PiB7XG4gICAgICBpZiAoa2V5U2Vzc2lvbkNvdW50KSB7XG4gICAgICAgIHRoaXMubG9nKCdmaW5pc2hlZCBjbG9zaW5nIGtleSBzZXNzaW9ucyBhbmQgY2xlYXJpbmcgbWVkaWEga2V5cycpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHRoaXMua2V5Rm9ybWF0UHJvbWlzZSA9IG51bGw7XG4gIH1cbiAgb25NYW5pZmVzdExvYWRlZChldmVudCwge1xuICAgIHNlc3Npb25LZXlzXG4gIH0pIHtcbiAgICBpZiAoIXNlc3Npb25LZXlzIHx8ICF0aGlzLmNvbmZpZy5lbWVFbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5rZXlGb3JtYXRQcm9taXNlKSB7XG4gICAgICBjb25zdCBrZXlGb3JtYXRzID0gc2Vzc2lvbktleXMucmVkdWNlKChmb3JtYXRzLCBzZXNzaW9uS2V5KSA9PiB7XG4gICAgICAgIGlmIChmb3JtYXRzLmluZGV4T2Yoc2Vzc2lvbktleS5rZXlGb3JtYXQpID09PSAtMSkge1xuICAgICAgICAgIGZvcm1hdHMucHVzaChzZXNzaW9uS2V5LmtleUZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdHM7XG4gICAgICB9LCBbXSk7XG4gICAgICB0aGlzLmxvZyhgU2VsZWN0aW5nIGtleS1zeXN0ZW0gZnJvbSBzZXNzaW9uLWtleXMgJHtrZXlGb3JtYXRzLmpvaW4oJywgJyl9YCk7XG4gICAgICB0aGlzLmtleUZvcm1hdFByb21pc2UgPSB0aGlzLmdldEtleUZvcm1hdFByb21pc2Uoa2V5Rm9ybWF0cyk7XG4gICAgfVxuICB9XG4gIHJlbW92ZVNlc3Npb24obWVkaWFLZXlTZXNzaW9uQ29udGV4dCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lZGlhS2V5c1Nlc3Npb24sXG4gICAgICBsaWNlbnNlWGhyXG4gICAgfSA9IG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQ7XG4gICAgaWYgKG1lZGlhS2V5c1Nlc3Npb24pIHtcbiAgICAgIHRoaXMubG9nKGBSZW1vdmUgbGljZW5zZXMgYW5kIGtleXMgYW5kIGNsb3NlIHNlc3Npb24gJHttZWRpYUtleXNTZXNzaW9uLnNlc3Npb25JZH1gKTtcbiAgICAgIGlmIChtZWRpYUtleVNlc3Npb25Db250ZXh0Ll9vbm1lc3NhZ2UpIHtcbiAgICAgICAgbWVkaWFLZXlzU2Vzc2lvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbWVkaWFLZXlTZXNzaW9uQ29udGV4dC5fb25tZXNzYWdlKTtcbiAgICAgICAgbWVkaWFLZXlTZXNzaW9uQ29udGV4dC5fb25tZXNzYWdlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQuX29ua2V5c3RhdHVzZXNjaGFuZ2UpIHtcbiAgICAgICAgbWVkaWFLZXlzU2Vzc2lvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlzdGF0dXNlc2NoYW5nZScsIG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQuX29ua2V5c3RhdHVzZXNjaGFuZ2UpO1xuICAgICAgICBtZWRpYUtleVNlc3Npb25Db250ZXh0Ll9vbmtleXN0YXR1c2VzY2hhbmdlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKGxpY2Vuc2VYaHIgJiYgbGljZW5zZVhoci5yZWFkeVN0YXRlICE9PSBYTUxIdHRwUmVxdWVzdC5ET05FKSB7XG4gICAgICAgIGxpY2Vuc2VYaHIuYWJvcnQoKTtcbiAgICAgIH1cbiAgICAgIG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQubWVkaWFLZXlzU2Vzc2lvbiA9IG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQuZGVjcnlwdGRhdGEgPSBtZWRpYUtleVNlc3Npb25Db250ZXh0LmxpY2Vuc2VYaHIgPSB1bmRlZmluZWQ7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMubWVkaWFLZXlTZXNzaW9ucy5pbmRleE9mKG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQpO1xuICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgdGhpcy5tZWRpYUtleVNlc3Npb25zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRybVN5c3RlbU9wdGlvbnNcbiAgICAgIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgIGNvbnN0IHJlbW92ZVByb21pc2UgPSBpc1BlcnNpc3RlbnRTZXNzaW9uVHlwZShkcm1TeXN0ZW1PcHRpb25zKSA/IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgc2VsZi5zZXRUaW1lb3V0KCgpID0+IHJlamVjdChuZXcgRXJyb3IoYE1lZGlhS2V5U2Vzc2lvbi5yZW1vdmUoKSB0aW1lb3V0YCkpLCA4MDAwKTtcbiAgICAgICAgbWVkaWFLZXlzU2Vzc2lvbi5yZW1vdmUoKS50aGVuKHJlc29sdmUpO1xuICAgICAgfSkgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIHJldHVybiByZW1vdmVQcm9taXNlLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgdmFyIF90aGlzJGhsczQ7XG4gICAgICAgIHRoaXMubG9nKGBDb3VsZCBub3QgcmVtb3ZlIHNlc3Npb246ICR7ZXJyb3J9YCk7XG4gICAgICAgIChfdGhpcyRobHM0ID0gdGhpcy5obHMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRobHM0LnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5PVEhFUl9FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9ERVNUUk9ZX1JFTU9WRV9TRVNTSU9OX0VSUk9SLFxuICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKGBDb3VsZCBub3QgcmVtb3ZlIHNlc3Npb246ICR7ZXJyb3J9YClcbiAgICAgICAgfSk7XG4gICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIG1lZGlhS2V5c1Nlc3Npb24uY2xvc2UoKTtcbiAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgdmFyIF90aGlzJGhsczU7XG4gICAgICAgIHRoaXMubG9nKGBDb3VsZCBub3QgY2xvc2Ugc2Vzc2lvbjogJHtlcnJvcn1gKTtcbiAgICAgICAgKF90aGlzJGhsczUgPSB0aGlzLmhscykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGhsczUudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX0RFU1RST1lfQ0xPU0VfU0VTU0lPTl9FUlJPUixcbiAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihgQ291bGQgbm90IGNsb3NlIHNlc3Npb246ICR7ZXJyb3J9YClcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbkVNRUNvbnRyb2xsZXIuQ0RNQ2xlYW51cFByb21pc2UgPSB2b2lkIDA7XG5jbGFzcyBFTUVLZXlFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoZGF0YSwgbWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuZGF0YSA9IHZvaWQgMDtcbiAgICBkYXRhLmVycm9yIHx8IChkYXRhLmVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpKTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIGRhdGEuZXJyID0gZGF0YS5lcnJvcjtcbiAgfVxufVxuXG5jbGFzcyBGUFNDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tRdWFsaXR5QXZhaWxhYmxlID0gZmFsc2U7XG4gICAgdGhpcy50aW1lciA9IHZvaWQgMDtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLmxhc3RUaW1lID0gdm9pZCAwO1xuICAgIHRoaXMubGFzdERyb3BwZWRGcmFtZXMgPSAwO1xuICAgIHRoaXMubGFzdERlY29kZWRGcmFtZXMgPSAwO1xuICAgIC8vIHN0cmVhbSBjb250cm9sbGVyIG11c3QgYmUgcHJvdmlkZWQgYXMgYSBkZXBlbmRlbmN5IVxuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgc2V0U3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyKSB7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyID0gc3RyZWFtQ29udHJvbGxlcjtcbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB0aGlzLmhscy5vbihFdmVudHMuTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9uKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gIH1cbiAgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB0aGlzLmhscy5vZmYoRXZlbnRzLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vZmYoRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgIH1cbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgfVxuICBvbk1lZGlhQXR0YWNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuICAgIGlmIChjb25maWcuY2FwTGV2ZWxPbkZQU0Ryb3ApIHtcbiAgICAgIGNvbnN0IG1lZGlhID0gZGF0YS5tZWRpYSBpbnN0YW5jZW9mIHNlbGYuSFRNTFZpZGVvRWxlbWVudCA/IGRhdGEubWVkaWEgOiBudWxsO1xuICAgICAgdGhpcy5tZWRpYSA9IG1lZGlhO1xuICAgICAgaWYgKG1lZGlhICYmIHR5cGVvZiBtZWRpYS5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLmlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgc2VsZi5jbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgdGhpcy50aW1lciA9IHNlbGYuc2V0SW50ZXJ2YWwodGhpcy5jaGVja0ZQU0ludGVydmFsLmJpbmQodGhpcyksIGNvbmZpZy5mcHNEcm9wcGVkTW9uaXRvcmluZ1BlcmlvZCk7XG4gICAgfVxuICB9XG4gIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gIH1cbiAgY2hlY2tGUFModmlkZW8sIGRlY29kZWRGcmFtZXMsIGRyb3BwZWRGcmFtZXMpIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGlmIChkZWNvZGVkRnJhbWVzKSB7XG4gICAgICBpZiAodGhpcy5sYXN0VGltZSkge1xuICAgICAgICBjb25zdCBjdXJyZW50UGVyaW9kID0gY3VycmVudFRpbWUgLSB0aGlzLmxhc3RUaW1lO1xuICAgICAgICBjb25zdCBjdXJyZW50RHJvcHBlZCA9IGRyb3BwZWRGcmFtZXMgLSB0aGlzLmxhc3REcm9wcGVkRnJhbWVzO1xuICAgICAgICBjb25zdCBjdXJyZW50RGVjb2RlZCA9IGRlY29kZWRGcmFtZXMgLSB0aGlzLmxhc3REZWNvZGVkRnJhbWVzO1xuICAgICAgICBjb25zdCBkcm9wcGVkRlBTID0gMTAwMCAqIGN1cnJlbnREcm9wcGVkIC8gY3VycmVudFBlcmlvZDtcbiAgICAgICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUFNfRFJPUCwge1xuICAgICAgICAgIGN1cnJlbnREcm9wcGVkOiBjdXJyZW50RHJvcHBlZCxcbiAgICAgICAgICBjdXJyZW50RGVjb2RlZDogY3VycmVudERlY29kZWQsXG4gICAgICAgICAgdG90YWxEcm9wcGVkRnJhbWVzOiBkcm9wcGVkRnJhbWVzXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZHJvcHBlZEZQUyA+IDApIHtcbiAgICAgICAgICAvLyBobHMubG9nZ2VyLmxvZygnY2hlY2tGUFMgOiBkcm9wcGVkRlBTL2RlY29kZWRGUFM6JyArIGRyb3BwZWRGUFMvKDEwMDAgKiBjdXJyZW50RGVjb2RlZCAvIGN1cnJlbnRQZXJpb2QpKTtcbiAgICAgICAgICBpZiAoY3VycmVudERyb3BwZWQgPiBobHMuY29uZmlnLmZwc0Ryb3BwZWRNb25pdG9yaW5nVGhyZXNob2xkICogY3VycmVudERlY29kZWQpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50TGV2ZWwgPSBobHMuY3VycmVudExldmVsO1xuICAgICAgICAgICAgaGxzLmxvZ2dlci53YXJuKCdkcm9wIEZQUyByYXRpbyBncmVhdGVyIHRoYW4gbWF4IGFsbG93ZWQgdmFsdWUgZm9yIGN1cnJlbnRMZXZlbDogJyArIGN1cnJlbnRMZXZlbCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudExldmVsID4gMCAmJiAoaGxzLmF1dG9MZXZlbENhcHBpbmcgPT09IC0xIHx8IGhscy5hdXRvTGV2ZWxDYXBwaW5nID49IGN1cnJlbnRMZXZlbCkpIHtcbiAgICAgICAgICAgICAgY3VycmVudExldmVsID0gY3VycmVudExldmVsIC0gMTtcbiAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkZQU19EUk9QX0xFVkVMX0NBUFBJTkcsIHtcbiAgICAgICAgICAgICAgICBsZXZlbDogY3VycmVudExldmVsLFxuICAgICAgICAgICAgICAgIGRyb3BwZWRMZXZlbDogaGxzLmN1cnJlbnRMZXZlbFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaGxzLmF1dG9MZXZlbENhcHBpbmcgPSBjdXJyZW50TGV2ZWw7XG4gICAgICAgICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWxTd2l0Y2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgIHRoaXMubGFzdERyb3BwZWRGcmFtZXMgPSBkcm9wcGVkRnJhbWVzO1xuICAgICAgdGhpcy5sYXN0RGVjb2RlZEZyYW1lcyA9IGRlY29kZWRGcmFtZXM7XG4gICAgfVxuICB9XG4gIGNoZWNrRlBTSW50ZXJ2YWwoKSB7XG4gICAgY29uc3QgdmlkZW8gPSB0aGlzLm1lZGlhO1xuICAgIGlmICh2aWRlbykge1xuICAgICAgaWYgKHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSkge1xuICAgICAgICBjb25zdCB2aWRlb1BsYXliYWNrUXVhbGl0eSA9IHZpZGVvLmdldFZpZGVvUGxheWJhY2tRdWFsaXR5KCk7XG4gICAgICAgIHRoaXMuY2hlY2tGUFModmlkZW8sIHZpZGVvUGxheWJhY2tRdWFsaXR5LnRvdGFsVmlkZW9GcmFtZXMsIHZpZGVvUGxheWJhY2tRdWFsaXR5LmRyb3BwZWRWaWRlb0ZyYW1lcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBIVE1MVmlkZW9FbGVtZW50IGRvZXNuJ3QgaW5jbHVkZSB0aGUgd2Via2l0IHR5cGVzXG4gICAgICAgIHRoaXMuY2hlY2tGUFModmlkZW8sIHZpZGVvLndlYmtpdERlY29kZWRGcmFtZUNvdW50LCB2aWRlby53ZWJraXREcm9wcGVkRnJhbWVDb3VudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNlbmRBZGRUcmFja0V2ZW50KHRyYWNrLCB2aWRlb0VsKSB7XG4gIGxldCBldmVudDtcbiAgdHJ5IHtcbiAgICBldmVudCA9IG5ldyBFdmVudCgnYWRkdHJhY2snKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gZm9yIElFMTFcbiAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGV2ZW50LmluaXRFdmVudCgnYWRkdHJhY2snLCBmYWxzZSwgZmFsc2UpO1xuICB9XG4gIGV2ZW50LnRyYWNrID0gdHJhY2s7XG4gIHZpZGVvRWwuZGlzcGF0Y2hFdmVudChldmVudCk7XG59XG5mdW5jdGlvbiBhZGRDdWVUb1RyYWNrKHRyYWNrLCBjdWUpIHtcbiAgLy8gU29tZXRpbWVzIHRoZXJlIGFyZSBjdWUgb3ZlcmxhcHMgb24gc2VnbWVudGVkIHZ0dHMgc28gdGhlIHNhbWVcbiAgLy8gY3VlIGNhbiBhcHBlYXIgbW9yZSB0aGFuIG9uY2UgaW4gZGlmZmVyZW50IHZ0dCBmaWxlcy5cbiAgLy8gVGhpcyBhdm9pZCBzaG93aW5nIGR1cGxpY2F0ZWQgY3VlcyB3aXRoIHNhbWUgdGltZWNvZGUgYW5kIHRleHQuXG4gIGNvbnN0IG1vZGUgPSB0cmFjay5tb2RlO1xuICBpZiAobW9kZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgIHRyYWNrLm1vZGUgPSAnaGlkZGVuJztcbiAgfVxuICBpZiAodHJhY2suY3VlcyAmJiAhdHJhY2suY3Vlcy5nZXRDdWVCeUlkKGN1ZS5pZCkpIHtcbiAgICB0cnkge1xuICAgICAgdHJhY2suYWRkQ3VlKGN1ZSk7XG4gICAgICBpZiAoIXRyYWNrLmN1ZXMuZ2V0Q3VlQnlJZChjdWUuaWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYWRkQ3VlIGlzIGZhaWxlZCBmb3I6ICR7Y3VlfWApO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nZ2VyLmRlYnVnKGBbdGV4dHRyYWNrLXV0aWxzXTogJHtlcnJ9YCk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB0ZXh0VHJhY2tDdWUgPSBuZXcgc2VsZi5UZXh0VHJhY2tDdWUoY3VlLnN0YXJ0VGltZSwgY3VlLmVuZFRpbWUsIGN1ZS50ZXh0KTtcbiAgICAgICAgdGV4dFRyYWNrQ3VlLmlkID0gY3VlLmlkO1xuICAgICAgICB0cmFjay5hZGRDdWUodGV4dFRyYWNrQ3VlKTtcbiAgICAgIH0gY2F0Y2ggKGVycjIpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBbdGV4dHRyYWNrLXV0aWxzXTogTGVnYWN5IFRleHRUcmFja0N1ZSBmYWxsYmFjayBmYWlsZWQ6ICR7ZXJyMn1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG1vZGUgPT09ICdkaXNhYmxlZCcpIHtcbiAgICB0cmFjay5tb2RlID0gbW9kZTtcbiAgfVxufVxuZnVuY3Rpb24gY2xlYXJDdXJyZW50Q3Vlcyh0cmFjaywgZW50ZXJIYW5kbGVyKSB7XG4gIC8vIFdoZW4gdHJhY2subW9kZSBpcyBkaXNhYmxlZCwgdHJhY2suY3VlcyB3aWxsIGJlIG51bGwuXG4gIC8vIFRvIGd1YXJhbnRlZSB0aGUgcmVtb3ZhbCBvZiBjdWVzLCB3ZSBuZWVkIHRvIHRlbXBvcmFyaWx5XG4gIC8vIGNoYW5nZSB0aGUgbW9kZSB0byBoaWRkZW5cbiAgY29uc3QgbW9kZSA9IHRyYWNrLm1vZGU7XG4gIGlmIChtb2RlID09PSAnZGlzYWJsZWQnKSB7XG4gICAgdHJhY2subW9kZSA9ICdoaWRkZW4nO1xuICB9XG4gIGlmICh0cmFjay5jdWVzKSB7XG4gICAgZm9yIChsZXQgaSA9IHRyYWNrLmN1ZXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICBpZiAoZW50ZXJIYW5kbGVyKSB7XG4gICAgICAgIHRyYWNrLmN1ZXNbaV0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW50ZXInLCBlbnRlckhhbmRsZXIpO1xuICAgICAgfVxuICAgICAgdHJhY2sucmVtb3ZlQ3VlKHRyYWNrLmN1ZXNbaV0pO1xuICAgIH1cbiAgfVxuICBpZiAobW9kZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgIHRyYWNrLm1vZGUgPSBtb2RlO1xuICB9XG59XG5mdW5jdGlvbiByZW1vdmVDdWVzSW5SYW5nZSh0cmFjaywgc3RhcnQsIGVuZCwgcHJlZGljYXRlKSB7XG4gIGNvbnN0IG1vZGUgPSB0cmFjay5tb2RlO1xuICBpZiAobW9kZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgIHRyYWNrLm1vZGUgPSAnaGlkZGVuJztcbiAgfVxuICBpZiAodHJhY2suY3VlcyAmJiB0cmFjay5jdWVzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBjdWVzID0gZ2V0Q3Vlc0luUmFuZ2UodHJhY2suY3Vlcywgc3RhcnQsIGVuZCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXByZWRpY2F0ZSB8fCBwcmVkaWNhdGUoY3Vlc1tpXSkpIHtcbiAgICAgICAgdHJhY2sucmVtb3ZlQ3VlKGN1ZXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAobW9kZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgIHRyYWNrLm1vZGUgPSBtb2RlO1xuICB9XG59XG5cbi8vIEZpbmQgZmlyc3QgY3VlIHN0YXJ0aW5nIGF0IG9yIGFmdGVyIGdpdmVuIHRpbWUuXG4vLyBNb2RpZmllZCB2ZXJzaW9uIG9mIGJpbmFyeSBzZWFyY2ggTyhsb2cobikpLlxuZnVuY3Rpb24gZ2V0Rmlyc3RDdWVJbmRleEZyb21UaW1lKGN1ZXMsIHRpbWUpIHtcbiAgLy8gSWYgZmlyc3QgY3VlIHN0YXJ0cyBhdCBvciBhZnRlciB0aW1lLCBzdGFydCB0aGVyZVxuICBpZiAodGltZSA8PSBjdWVzWzBdLnN0YXJ0VGltZSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIC8vIElmIHRoZSBsYXN0IGN1ZSBlbmRzIGJlZm9yZSB0aW1lIHRoZXJlIGlzIG5vIG92ZXJsYXBcbiAgY29uc3QgbGVuID0gY3Vlcy5sZW5ndGggLSAxO1xuICBpZiAodGltZSA+IGN1ZXNbbGVuXS5lbmRUaW1lKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGxldCBsZWZ0ID0gMDtcbiAgbGV0IHJpZ2h0ID0gbGVuO1xuICBsZXQgbWlkO1xuICB3aGlsZSAobGVmdCA8PSByaWdodCkge1xuICAgIG1pZCA9IE1hdGguZmxvb3IoKHJpZ2h0ICsgbGVmdCkgLyAyKTtcbiAgICBpZiAodGltZSA8IGN1ZXNbbWlkXS5zdGFydFRpbWUpIHtcbiAgICAgIHJpZ2h0ID0gbWlkIC0gMTtcbiAgICB9IGVsc2UgaWYgKHRpbWUgPiBjdWVzW21pZF0uc3RhcnRUaW1lICYmIGxlZnQgPCBsZW4pIHtcbiAgICAgIGxlZnQgPSBtaWQgKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBpdCdzIG5vdCBsb3dlciBvciBoaWdoZXIsIGl0IG11c3QgYmUgZXF1YWwuXG4gICAgICByZXR1cm4gbWlkO1xuICAgIH1cbiAgfVxuICAvLyBBdCB0aGlzIHBvaW50LCBsZWZ0IGFuZCByaWdodCBoYXZlIHN3YXBwZWQuXG4gIC8vIE5vIGRpcmVjdCBtYXRjaCB3YXMgZm91bmQsIGxlZnQgb3IgcmlnaHQgZWxlbWVudCBtdXN0IGJlIHRoZSBjbG9zZXN0LiBDaGVjayB3aGljaCBvbmUgaGFzIHRoZSBzbWFsbGVzdCBkaWZmLlxuICByZXR1cm4gY3Vlc1tsZWZ0XS5zdGFydFRpbWUgLSB0aW1lIDwgdGltZSAtIGN1ZXNbcmlnaHRdLnN0YXJ0VGltZSA/IGxlZnQgOiByaWdodDtcbn1cbmZ1bmN0aW9uIGdldEN1ZXNJblJhbmdlKGN1ZXMsIHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgY3Vlc0ZvdW5kID0gW107XG4gIGNvbnN0IGZpcnN0Q3VlSW5SYW5nZSA9IGdldEZpcnN0Q3VlSW5kZXhGcm9tVGltZShjdWVzLCBzdGFydCk7XG4gIGlmIChmaXJzdEN1ZUluUmFuZ2UgPiAtMSkge1xuICAgIGZvciAobGV0IGkgPSBmaXJzdEN1ZUluUmFuZ2UsIGxlbiA9IGN1ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGN1ZSA9IGN1ZXNbaV07XG4gICAgICBpZiAoY3VlLnN0YXJ0VGltZSA+PSBzdGFydCAmJiBjdWUuZW5kVGltZSA8PSBlbmQpIHtcbiAgICAgICAgY3Vlc0ZvdW5kLnB1c2goY3VlKTtcbiAgICAgIH0gZWxzZSBpZiAoY3VlLnN0YXJ0VGltZSA+IGVuZCkge1xuICAgICAgICByZXR1cm4gY3Vlc0ZvdW5kO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY3Vlc0ZvdW5kO1xufVxuZnVuY3Rpb24gZmlsdGVyU3VidGl0bGVUcmFja3ModGV4dFRyYWNrTGlzdCkge1xuICBjb25zdCB0cmFja3MgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0VHJhY2tMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdHJhY2sgPSB0ZXh0VHJhY2tMaXN0W2ldO1xuICAgIC8vIEVkZ2UgYWRkcyBhIHRyYWNrIHdpdGhvdXQgYSBsYWJlbDsgd2UgZG9uJ3Qgd2FudCB0byB1c2UgaXRcbiAgICBpZiAoKHRyYWNrLmtpbmQgPT09ICdzdWJ0aXRsZXMnIHx8IHRyYWNrLmtpbmQgPT09ICdjYXB0aW9ucycpICYmIHRyYWNrLmxhYmVsKSB7XG4gICAgICB0cmFja3MucHVzaCh0ZXh0VHJhY2tMaXN0W2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRyYWNrcztcbn1cblxuY2xhc3MgU3VidGl0bGVUcmFja0NvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlUGxheWxpc3RDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgc3VwZXIoaGxzLCAnc3VidGl0bGUtdHJhY2stY29udHJvbGxlcicpO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgdGhpcy5ncm91cElkcyA9IG51bGw7XG4gICAgdGhpcy50cmFja3NJbkdyb3VwID0gW107XG4gICAgdGhpcy50cmFja0lkID0gLTE7XG4gICAgdGhpcy5jdXJyZW50VHJhY2sgPSBudWxsO1xuICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gdHJ1ZTtcbiAgICB0aGlzLnF1ZXVlZERlZmF1bHRUcmFjayA9IC0xO1xuICAgIHRoaXMudXNlVGV4dFRyYWNrUG9sbGluZyA9IGZhbHNlO1xuICAgIHRoaXMuc3VidGl0bGVQb2xsaW5nSW50ZXJ2YWwgPSAtMTtcbiAgICB0aGlzLl9zdWJ0aXRsZURpc3BsYXkgPSB0cnVlO1xuICAgIHRoaXMuYXN5bmNQb2xsVHJhY2tDaGFuZ2UgPSAoKSA9PiB0aGlzLnBvbGxUcmFja0NoYW5nZSgwKTtcbiAgICB0aGlzLm9uVGV4dFRyYWNrc0NoYW5nZWQgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMudXNlVGV4dFRyYWNrUG9sbGluZykge1xuICAgICAgICBzZWxmLmNsZWFySW50ZXJ2YWwodGhpcy5zdWJ0aXRsZVBvbGxpbmdJbnRlcnZhbCk7XG4gICAgICB9XG4gICAgICAvLyBNZWRpYSBpcyB1bmRlZmluZWQgd2hlbiBzd2l0Y2hpbmcgc3RyZWFtcyB2aWEgbG9hZFNvdXJjZSgpXG4gICAgICBpZiAoIXRoaXMubWVkaWEgfHwgIXRoaXMuaGxzLmNvbmZpZy5yZW5kZXJUZXh0VHJhY2tzTmF0aXZlbHkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHRleHRUcmFjayA9IG51bGw7XG4gICAgICBjb25zdCB0cmFja3MgPSBmaWx0ZXJTdWJ0aXRsZVRyYWNrcyh0aGlzLm1lZGlhLnRleHRUcmFja3MpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRyYWNrc1tpXS5tb2RlID09PSAnaGlkZGVuJykge1xuICAgICAgICAgIC8vIERvIG5vdCBicmVhayBpbiBjYXNlIHRoZXJlIGlzIGEgZm9sbG93aW5nIHRyYWNrIHdpdGggc2hvd2luZy5cbiAgICAgICAgICB0ZXh0VHJhY2sgPSB0cmFja3NbaV07XG4gICAgICAgIH0gZWxzZSBpZiAodHJhY2tzW2ldLm1vZGUgPT09ICdzaG93aW5nJykge1xuICAgICAgICAgIHRleHRUcmFjayA9IHRyYWNrc1tpXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBGaW5kIGludGVybmFsIHRyYWNrIGluZGV4IGZvciBUZXh0VHJhY2tcbiAgICAgIGNvbnN0IHRyYWNrSWQgPSB0aGlzLmZpbmRUcmFja0ZvclRleHRUcmFjayh0ZXh0VHJhY2spO1xuICAgICAgaWYgKHRoaXMuc3VidGl0bGVUcmFjayAhPT0gdHJhY2tJZCkge1xuICAgICAgICB0aGlzLnNldFN1YnRpdGxlVHJhY2sodHJhY2tJZCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLnRyYWNrcy5sZW5ndGggPSAwO1xuICAgIHRoaXMudHJhY2tzSW5Hcm91cC5sZW5ndGggPSAwO1xuICAgIHRoaXMuY3VycmVudFRyYWNrID0gbnVsbDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5vblRleHRUcmFja3NDaGFuZ2VkID0gdGhpcy5hc3luY1BvbGxUcmFja0NoYW5nZSA9IG51bGw7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICB9XG4gIGdldCBzdWJ0aXRsZURpc3BsYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N1YnRpdGxlRGlzcGxheTtcbiAgfVxuICBzZXQgc3VidGl0bGVEaXNwbGF5KHZhbHVlKSB7XG4gICAgdGhpcy5fc3VidGl0bGVEaXNwbGF5ID0gdmFsdWU7XG4gICAgaWYgKHRoaXMudHJhY2tJZCA+IC0xKSB7XG4gICAgICB0aGlzLnRvZ2dsZVRyYWNrTW9kZXMoKTtcbiAgICB9XG4gIH1cbiAgcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX1NXSVRDSElORywgdGhpcy5vbkxldmVsU3dpdGNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLlNVQlRJVExFX1RSQUNLX0xPQURFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH1cbiAgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxfTE9BRElORywgdGhpcy5vbkxldmVsTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxfU1dJVENISU5HLCB0aGlzLm9uTGV2ZWxTd2l0Y2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLlNVQlRJVExFX1RSQUNLX0xPQURFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9XG5cbiAgLy8gTGlzdGVuIGZvciBzdWJ0aXRsZSB0cmFjayBjaGFuZ2UsIHRoZW4gZXh0cmFjdCB0aGUgY3VycmVudCB0cmFjayBJRC5cbiAgb25NZWRpYUF0dGFjaGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnF1ZXVlZERlZmF1bHRUcmFjayA+IC0xKSB7XG4gICAgICB0aGlzLnN1YnRpdGxlVHJhY2sgPSB0aGlzLnF1ZXVlZERlZmF1bHRUcmFjaztcbiAgICAgIHRoaXMucXVldWVkRGVmYXVsdFRyYWNrID0gLTE7XG4gICAgfVxuICAgIHRoaXMudXNlVGV4dFRyYWNrUG9sbGluZyA9ICEodGhpcy5tZWRpYS50ZXh0VHJhY2tzICYmICdvbmNoYW5nZScgaW4gdGhpcy5tZWRpYS50ZXh0VHJhY2tzKTtcbiAgICBpZiAodGhpcy51c2VUZXh0VHJhY2tQb2xsaW5nKSB7XG4gICAgICB0aGlzLnBvbGxUcmFja0NoYW5nZSg1MDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1lZGlhLnRleHRUcmFja3MuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5hc3luY1BvbGxUcmFja0NoYW5nZSk7XG4gICAgfVxuICB9XG4gIHBvbGxUcmFja0NoYW5nZSh0aW1lb3V0KSB7XG4gICAgc2VsZi5jbGVhckludGVydmFsKHRoaXMuc3VidGl0bGVQb2xsaW5nSW50ZXJ2YWwpO1xuICAgIHRoaXMuc3VidGl0bGVQb2xsaW5nSW50ZXJ2YWwgPSBzZWxmLnNldEludGVydmFsKHRoaXMub25UZXh0VHJhY2tzQ2hhbmdlZCwgdGltZW91dCk7XG4gIH1cbiAgb25NZWRpYURldGFjaGluZyhldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAoIW1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zZmVycmluZ01lZGlhID0gISFkYXRhLnRyYW5zZmVyTWVkaWE7XG4gICAgc2VsZi5jbGVhckludGVydmFsKHRoaXMuc3VidGl0bGVQb2xsaW5nSW50ZXJ2YWwpO1xuICAgIGlmICghdGhpcy51c2VUZXh0VHJhY2tQb2xsaW5nKSB7XG4gICAgICBtZWRpYS50ZXh0VHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuYXN5bmNQb2xsVHJhY2tDaGFuZ2UpO1xuICAgIH1cbiAgICBpZiAodGhpcy50cmFja0lkID4gLTEpIHtcbiAgICAgIHRoaXMucXVldWVkRGVmYXVsdFRyYWNrID0gdGhpcy50cmFja0lkO1xuICAgIH1cblxuICAgIC8vIERpc2FibGUgYWxsIHN1YnRpdGxlIHRyYWNrcyBiZWZvcmUgZGV0YWNobWVudCBzbyB3aGVuIHJlYXR0YWNoZWQgb25seSB0cmFja3MgaW4gdGhhdCBjb250ZW50IGFyZSBlbmFibGVkLlxuICAgIHRoaXMuc3VidGl0bGVUcmFjayA9IC0xO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIGlmICh0cmFuc2ZlcnJpbmdNZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0VHJhY2tzID0gZmlsdGVyU3VidGl0bGVUcmFja3MobWVkaWEudGV4dFRyYWNrcyk7XG4gICAgLy8gQ2xlYXIgbG9hZGVkIGN1ZXMgb24gbWVkaWEgZGV0YWNobWVudCBmcm9tIHRyYWNrc1xuICAgIHRleHRUcmFja3MuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICBjbGVhckN1cnJlbnRDdWVzKHRyYWNrKTtcbiAgICB9KTtcbiAgfVxuICBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLnRyYWNrcyA9IFtdO1xuICAgIHRoaXMuZ3JvdXBJZHMgPSBudWxsO1xuICAgIHRoaXMudHJhY2tzSW5Hcm91cCA9IFtdO1xuICAgIHRoaXMudHJhY2tJZCA9IC0xO1xuICAgIHRoaXMuY3VycmVudFRyYWNrID0gbnVsbDtcbiAgICB0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IHRydWU7XG4gIH1cblxuICAvLyBGaXJlZCB3aGVuZXZlciBhIG5ldyBtYW5pZmVzdCBpcyBsb2FkZWQuXG4gIG9uTWFuaWZlc3RQYXJzZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLnRyYWNrcyA9IGRhdGEuc3VidGl0bGVUcmFja3M7XG4gIH1cbiAgb25TdWJ0aXRsZVRyYWNrTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgaWQsXG4gICAgICBncm91cElkLFxuICAgICAgZGV0YWlsc1xuICAgIH0gPSBkYXRhO1xuICAgIGNvbnN0IHRyYWNrSW5BY3RpdmVHcm91cCA9IHRoaXMudHJhY2tzSW5Hcm91cFtpZF07XG4gICAgaWYgKCF0cmFja0luQWN0aXZlR3JvdXAgfHwgdHJhY2tJbkFjdGl2ZUdyb3VwLmdyb3VwSWQgIT09IGdyb3VwSWQpIHtcbiAgICAgIHRoaXMud2FybihgU3VidGl0bGUgdHJhY2sgd2l0aCBpZDoke2lkfSBhbmQgZ3JvdXA6JHtncm91cElkfSBub3QgZm91bmQgaW4gYWN0aXZlIGdyb3VwICR7dHJhY2tJbkFjdGl2ZUdyb3VwID09IG51bGwgPyB2b2lkIDAgOiB0cmFja0luQWN0aXZlR3JvdXAuZ3JvdXBJZH1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VyRGV0YWlscyA9IHRyYWNrSW5BY3RpdmVHcm91cC5kZXRhaWxzO1xuICAgIHRyYWNrSW5BY3RpdmVHcm91cC5kZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuICAgIHRoaXMubG9nKGBTdWJ0aXRsZSB0cmFjayAke2lkfSBcIiR7dHJhY2tJbkFjdGl2ZUdyb3VwLm5hbWV9XCIgbGFuZzoke3RyYWNrSW5BY3RpdmVHcm91cC5sYW5nfSBncm91cDoke2dyb3VwSWR9IGxvYWRlZCBbJHtkZXRhaWxzLnN0YXJ0U059LSR7ZGV0YWlscy5lbmRTTn1dYCk7XG4gICAgaWYgKGlkID09PSB0aGlzLnRyYWNrSWQpIHtcbiAgICAgIHRoaXMucGxheWxpc3RMb2FkZWQoaWQsIGRhdGEsIGN1ckRldGFpbHMpO1xuICAgIH1cbiAgfVxuICBvbkxldmVsTG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgIHRoaXMuc3dpdGNoTGV2ZWwoZGF0YS5sZXZlbCk7XG4gIH1cbiAgb25MZXZlbFN3aXRjaGluZyhldmVudCwgZGF0YSkge1xuICAgIHRoaXMuc3dpdGNoTGV2ZWwoZGF0YS5sZXZlbCk7XG4gIH1cbiAgc3dpdGNoTGV2ZWwobGV2ZWxJbmRleCkge1xuICAgIGNvbnN0IGxldmVsSW5mbyA9IHRoaXMuaGxzLmxldmVsc1tsZXZlbEluZGV4XTtcbiAgICBpZiAoIWxldmVsSW5mbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdWJ0aXRsZUdyb3VwcyA9IGxldmVsSW5mby5zdWJ0aXRsZUdyb3VwcyB8fCBudWxsO1xuICAgIGNvbnN0IGN1cnJlbnRHcm91cHMgPSB0aGlzLmdyb3VwSWRzO1xuICAgIGxldCBjdXJyZW50VHJhY2sgPSB0aGlzLmN1cnJlbnRUcmFjaztcbiAgICBpZiAoIXN1YnRpdGxlR3JvdXBzIHx8IChjdXJyZW50R3JvdXBzID09IG51bGwgPyB2b2lkIDAgOiBjdXJyZW50R3JvdXBzLmxlbmd0aCkgIT09IChzdWJ0aXRsZUdyb3VwcyA9PSBudWxsID8gdm9pZCAwIDogc3VidGl0bGVHcm91cHMubGVuZ3RoKSB8fCBzdWJ0aXRsZUdyb3VwcyAhPSBudWxsICYmIHN1YnRpdGxlR3JvdXBzLnNvbWUoZ3JvdXBJZCA9PiAoY3VycmVudEdyb3VwcyA9PSBudWxsID8gdm9pZCAwIDogY3VycmVudEdyb3Vwcy5pbmRleE9mKGdyb3VwSWQpKSA9PT0gLTEpKSB7XG4gICAgICB0aGlzLmdyb3VwSWRzID0gc3VidGl0bGVHcm91cHM7XG4gICAgICB0aGlzLnRyYWNrSWQgPSAtMTtcbiAgICAgIHRoaXMuY3VycmVudFRyYWNrID0gbnVsbDtcbiAgICAgIGNvbnN0IHN1YnRpdGxlVHJhY2tzID0gdGhpcy50cmFja3MuZmlsdGVyKHRyYWNrID0+ICFzdWJ0aXRsZUdyb3VwcyB8fCBzdWJ0aXRsZUdyb3Vwcy5pbmRleE9mKHRyYWNrLmdyb3VwSWQpICE9PSAtMSk7XG4gICAgICBpZiAoc3VidGl0bGVUcmFja3MubGVuZ3RoKSB7XG4gICAgICAgIC8vIERpc2FibGUgc2VsZWN0RGVmYXVsdFRyYWNrIGlmIHRoZXJlIGFyZSBubyBkZWZhdWx0IHRyYWNrc1xuICAgICAgICBpZiAodGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgJiYgIXN1YnRpdGxlVHJhY2tzLnNvbWUodHJhY2sgPT4gdHJhY2suZGVmYXVsdCkpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRyYWNrLmlkIHNob3VsZCBtYXRjaCBobHMuYXVkaW9UcmFja3MgaW5kZXhcbiAgICAgICAgc3VidGl0bGVUcmFja3MuZm9yRWFjaCgodHJhY2ssIGkpID0+IHtcbiAgICAgICAgICB0cmFjay5pZCA9IGk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICghY3VycmVudFRyYWNrICYmICF0aGlzLnRyYWNrc0luR3JvdXAubGVuZ3RoKSB7XG4gICAgICAgIC8vIERvIG5vdCBkaXNwYXRjaCBTVUJUSVRMRV9UUkFDS1NfVVBEQVRFRCB3aGVuIHRoZXJlIHdlcmUgYW5kIGFyZSBubyB0cmFja3NcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy50cmFja3NJbkdyb3VwID0gc3VidGl0bGVUcmFja3M7XG5cbiAgICAgIC8vIEZpbmQgcHJlZmVycmVkIHRyYWNrXG4gICAgICBjb25zdCBzdWJ0aXRsZVByZWZlcmVuY2UgPSB0aGlzLmhscy5jb25maWcuc3VidGl0bGVQcmVmZXJlbmNlO1xuICAgICAgaWYgKCFjdXJyZW50VHJhY2sgJiYgc3VidGl0bGVQcmVmZXJlbmNlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGdyb3VwSW5kZXggPSBmaW5kTWF0Y2hpbmdPcHRpb24oc3VidGl0bGVQcmVmZXJlbmNlLCBzdWJ0aXRsZVRyYWNrcyk7XG4gICAgICAgIGlmIChncm91cEluZGV4ID4gLTEpIHtcbiAgICAgICAgICBjdXJyZW50VHJhY2sgPSBzdWJ0aXRsZVRyYWNrc1tncm91cEluZGV4XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBhbGxJbmRleCA9IGZpbmRNYXRjaGluZ09wdGlvbihzdWJ0aXRsZVByZWZlcmVuY2UsIHRoaXMudHJhY2tzKTtcbiAgICAgICAgICBjdXJyZW50VHJhY2sgPSB0aGlzLnRyYWNrc1thbGxJbmRleF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gU2VsZWN0IGluaXRpYWwgdHJhY2tcbiAgICAgIGxldCB0cmFja0lkID0gdGhpcy5maW5kVHJhY2tJZChjdXJyZW50VHJhY2spO1xuICAgICAgaWYgKHRyYWNrSWQgPT09IC0xICYmIGN1cnJlbnRUcmFjaykge1xuICAgICAgICB0cmFja0lkID0gdGhpcy5maW5kVHJhY2tJZChudWxsKTtcbiAgICAgIH1cblxuICAgICAgLy8gRGlzcGF0Y2ggZXZlbnRzIGFuZCBsb2FkIHRyYWNrIGlmIG5lZWRlZFxuICAgICAgY29uc3Qgc3VidGl0bGVUcmFja3NVcGRhdGVkID0ge1xuICAgICAgICBzdWJ0aXRsZVRyYWNrc1xuICAgICAgfTtcbiAgICAgIHRoaXMubG9nKGBVcGRhdGluZyBzdWJ0aXRsZSB0cmFja3MsICR7c3VidGl0bGVUcmFja3MubGVuZ3RofSB0cmFjayhzKSBmb3VuZCBpbiBcIiR7c3VidGl0bGVHcm91cHMgPT0gbnVsbCA/IHZvaWQgMCA6IHN1YnRpdGxlR3JvdXBzLmpvaW4oJywnKX1cIiBncm91cC1pZGApO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuU1VCVElUTEVfVFJBQ0tTX1VQREFURUQsIHN1YnRpdGxlVHJhY2tzVXBkYXRlZCk7XG4gICAgICBpZiAodHJhY2tJZCAhPT0gLTEgJiYgdGhpcy50cmFja0lkID09PSAtMSkge1xuICAgICAgICB0aGlzLnNldFN1YnRpdGxlVHJhY2sodHJhY2tJZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZpbmRUcmFja0lkKGN1cnJlbnRUcmFjaykge1xuICAgIGNvbnN0IHRyYWNrcyA9IHRoaXMudHJhY2tzSW5Hcm91cDtcbiAgICBjb25zdCBzZWxlY3REZWZhdWx0ID0gdGhpcy5zZWxlY3REZWZhdWx0VHJhY2s7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRyYWNrID0gdHJhY2tzW2ldO1xuICAgICAgaWYgKHNlbGVjdERlZmF1bHQgJiYgIXRyYWNrLmRlZmF1bHQgfHwgIXNlbGVjdERlZmF1bHQgJiYgIWN1cnJlbnRUcmFjaykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghY3VycmVudFRyYWNrIHx8IG1hdGNoZXNPcHRpb24odHJhY2ssIGN1cnJlbnRUcmFjaykpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjdXJyZW50VHJhY2spIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRyYWNrID0gdHJhY2tzW2ldO1xuICAgICAgICBpZiAobWVkaWFBdHRyaWJ1dGVzSWRlbnRpY2FsKGN1cnJlbnRUcmFjay5hdHRycywgdHJhY2suYXR0cnMsIFsnTEFOR1VBR0UnLCAnQVNTT0MtTEFOR1VBR0UnLCAnQ0hBUkFDVEVSSVNUSUNTJ10pKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRyYWNrID0gdHJhY2tzW2ldO1xuICAgICAgICBpZiAobWVkaWFBdHRyaWJ1dGVzSWRlbnRpY2FsKGN1cnJlbnRUcmFjay5hdHRycywgdHJhY2suYXR0cnMsIFsnTEFOR1VBR0UnXSkpIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgZmluZFRyYWNrRm9yVGV4dFRyYWNrKHRleHRUcmFjaykge1xuICAgIGlmICh0ZXh0VHJhY2spIHtcbiAgICAgIGNvbnN0IHRyYWNrcyA9IHRoaXMudHJhY2tzSW5Hcm91cDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRyYWNrID0gdHJhY2tzW2ldO1xuICAgICAgICBpZiAoc3VidGl0bGVUcmFja01hdGNoZXNUZXh0VHJhY2sodHJhY2ssIHRleHRUcmFjaykpIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgb25FcnJvcihldmVudCwgZGF0YSkge1xuICAgIGlmIChkYXRhLmZhdGFsIHx8ICFkYXRhLmNvbnRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRhdGEuY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLICYmIGRhdGEuY29udGV4dC5pZCA9PT0gdGhpcy50cmFja0lkICYmICghdGhpcy5ncm91cElkcyB8fCB0aGlzLmdyb3VwSWRzLmluZGV4T2YoZGF0YS5jb250ZXh0Lmdyb3VwSWQpICE9PSAtMSkpIHtcbiAgICAgIHRoaXMuY2hlY2tSZXRyeShkYXRhKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGFsbFN1YnRpdGxlVHJhY2tzKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrcztcbiAgfVxuXG4gIC8qKiBnZXQgYWx0ZXJuYXRlIHN1YnRpdGxlIHRyYWNrcyBsaXN0IGZyb20gcGxheWxpc3QgKiovXG4gIGdldCBzdWJ0aXRsZVRyYWNrcygpIHtcbiAgICByZXR1cm4gdGhpcy50cmFja3NJbkdyb3VwO1xuICB9XG5cbiAgLyoqIGdldC9zZXQgaW5kZXggb2YgdGhlIHNlbGVjdGVkIHN1YnRpdGxlIHRyYWNrIChiYXNlZCBvbiBpbmRleCBpbiBzdWJ0aXRsZSB0cmFjayBsaXN0cykgKiovXG4gIGdldCBzdWJ0aXRsZVRyYWNrKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrSWQ7XG4gIH1cbiAgc2V0IHN1YnRpdGxlVHJhY2sobmV3SWQpIHtcbiAgICB0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IGZhbHNlO1xuICAgIHRoaXMuc2V0U3VidGl0bGVUcmFjayhuZXdJZCk7XG4gIH1cbiAgc2V0U3VidGl0bGVPcHRpb24oc3VidGl0bGVPcHRpb24pIHtcbiAgICB0aGlzLmhscy5jb25maWcuc3VidGl0bGVQcmVmZXJlbmNlID0gc3VidGl0bGVPcHRpb247XG4gICAgaWYgKHN1YnRpdGxlT3B0aW9uKSB7XG4gICAgICBpZiAoc3VidGl0bGVPcHRpb24uaWQgPT09IC0xKSB7XG4gICAgICAgIHRoaXMuc2V0U3VidGl0bGVUcmFjaygtMSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgYWxsU3VidGl0bGVUcmFja3MgPSB0aGlzLmFsbFN1YnRpdGxlVHJhY2tzO1xuICAgICAgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSBmYWxzZTtcbiAgICAgIGlmIChhbGxTdWJ0aXRsZVRyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gRmlyc3Qgc2VlIGlmIGN1cnJlbnQgb3B0aW9uIG1hdGNoZXMgKG5vIHN3aXRjaCBvcClcbiAgICAgICAgY29uc3QgY3VycmVudFRyYWNrID0gdGhpcy5jdXJyZW50VHJhY2s7XG4gICAgICAgIGlmIChjdXJyZW50VHJhY2sgJiYgbWF0Y2hlc09wdGlvbihzdWJ0aXRsZU9wdGlvbiwgY3VycmVudFRyYWNrKSkge1xuICAgICAgICAgIHJldHVybiBjdXJyZW50VHJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluZCBvcHRpb24gaW4gY3VycmVudCBncm91cFxuICAgICAgICBjb25zdCBncm91cEluZGV4ID0gZmluZE1hdGNoaW5nT3B0aW9uKHN1YnRpdGxlT3B0aW9uLCB0aGlzLnRyYWNrc0luR3JvdXApO1xuICAgICAgICBpZiAoZ3JvdXBJbmRleCA+IC0xKSB7XG4gICAgICAgICAgY29uc3QgdHJhY2sgPSB0aGlzLnRyYWNrc0luR3JvdXBbZ3JvdXBJbmRleF07XG4gICAgICAgICAgdGhpcy5zZXRTdWJ0aXRsZVRyYWNrKGdyb3VwSW5kZXgpO1xuICAgICAgICAgIHJldHVybiB0cmFjaztcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50VHJhY2spIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIGlzIG5vdCB0aGUgaW5pdGlhbCBzZWxlY3Rpb24gcmV0dXJuIG51bGxcbiAgICAgICAgICAvLyBvcHRpb24gc2hvdWxkIGhhdmUgbWF0Y2hlZCBvbmUgaW4gYWN0aXZlIGdyb3VwXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRmluZCB0aGUgb3B0aW9uIGluIGFsbCB0cmFja3MgZm9yIGluaXRpYWwgc2VsZWN0aW9uXG4gICAgICAgICAgY29uc3QgYWxsSW5kZXggPSBmaW5kTWF0Y2hpbmdPcHRpb24oc3VidGl0bGVPcHRpb24sIGFsbFN1YnRpdGxlVHJhY2tzKTtcbiAgICAgICAgICBpZiAoYWxsSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGFsbFN1YnRpdGxlVHJhY2tzW2FsbEluZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbG9hZFBsYXlsaXN0KGhsc1VybFBhcmFtZXRlcnMpIHtcbiAgICBzdXBlci5sb2FkUGxheWxpc3QoKTtcbiAgICBpZiAodGhpcy5zaG91bGRMb2FkUGxheWxpc3QodGhpcy5jdXJyZW50VHJhY2spKSB7XG4gICAgICB0aGlzLnNjaGVkdWxlTG9hZGluZyh0aGlzLmN1cnJlbnRUcmFjaywgaGxzVXJsUGFyYW1ldGVycyk7XG4gICAgfVxuICB9XG4gIGxvYWRpbmdQbGF5bGlzdChjdXJyZW50VHJhY2ssIGhsc1VybFBhcmFtZXRlcnMpIHtcbiAgICBzdXBlci5sb2FkaW5nUGxheWxpc3QoY3VycmVudFRyYWNrLCBobHNVcmxQYXJhbWV0ZXJzKTtcbiAgICBjb25zdCBpZCA9IGN1cnJlbnRUcmFjay5pZDtcbiAgICBjb25zdCBncm91cElkID0gY3VycmVudFRyYWNrLmdyb3VwSWQ7XG4gICAgY29uc3QgdXJsID0gdGhpcy5nZXRVcmxXaXRoRGlyZWN0aXZlcyhjdXJyZW50VHJhY2sudXJsLCBobHNVcmxQYXJhbWV0ZXJzKTtcbiAgICBjb25zdCBkZXRhaWxzID0gY3VycmVudFRyYWNrLmRldGFpbHM7XG4gICAgY29uc3QgYWdlID0gZGV0YWlscyA9PSBudWxsID8gdm9pZCAwIDogZGV0YWlscy5hZ2U7XG4gICAgdGhpcy5sb2coYExvYWRpbmcgc3VidGl0bGUgJHtpZH0gXCIke2N1cnJlbnRUcmFjay5uYW1lfVwiIGxhbmc6JHtjdXJyZW50VHJhY2subGFuZ30gZ3JvdXA6JHtncm91cElkfSR7KGhsc1VybFBhcmFtZXRlcnMgPT0gbnVsbCA/IHZvaWQgMCA6IGhsc1VybFBhcmFtZXRlcnMubXNuKSAhPT0gdW5kZWZpbmVkID8gJyBhdCBzbiAnICsgaGxzVXJsUGFyYW1ldGVycy5tc24gKyAnIHBhcnQgJyArIGhsc1VybFBhcmFtZXRlcnMucGFydCA6ICcnfSR7YWdlICYmIGRldGFpbHMubGl2ZSA/ICcgYWdlICcgKyBhZ2UudG9GaXhlZCgxKSArIChkZXRhaWxzLnR5cGUgPyAnICcgKyBkZXRhaWxzLnR5cGUgfHwgJycgOiAnJykgOiAnJ30gJHt1cmx9YCk7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuU1VCVElUTEVfVFJBQ0tfTE9BRElORywge1xuICAgICAgdXJsLFxuICAgICAgaWQsXG4gICAgICBncm91cElkLFxuICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzOiBobHNVcmxQYXJhbWV0ZXJzIHx8IG51bGwsXG4gICAgICB0cmFjazogY3VycmVudFRyYWNrXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGlzYWJsZXMgdGhlIG9sZCBzdWJ0aXRsZVRyYWNrIGFuZCBzZXRzIGN1cnJlbnQgbW9kZSBvbiB0aGUgbmV4dCBzdWJ0aXRsZVRyYWNrLlxuICAgKiBUaGlzIG9wZXJhdGVzIG9uIHRoZSBET00gdGV4dFRyYWNrcy5cbiAgICogQSB2YWx1ZSBvZiAtMSB3aWxsIGRpc2FibGUgYWxsIHN1YnRpdGxlIHRyYWNrcy5cbiAgICovXG4gIHRvZ2dsZVRyYWNrTW9kZXMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbWVkaWFcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIW1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRleHRUcmFja3MgPSBmaWx0ZXJTdWJ0aXRsZVRyYWNrcyhtZWRpYS50ZXh0VHJhY2tzKTtcbiAgICBjb25zdCBjdXJyZW50VHJhY2sgPSB0aGlzLmN1cnJlbnRUcmFjaztcbiAgICBsZXQgbmV4dFRyYWNrO1xuICAgIGlmIChjdXJyZW50VHJhY2spIHtcbiAgICAgIG5leHRUcmFjayA9IHRleHRUcmFja3MuZmlsdGVyKHRleHRUcmFjayA9PiBzdWJ0aXRsZVRyYWNrTWF0Y2hlc1RleHRUcmFjayhjdXJyZW50VHJhY2ssIHRleHRUcmFjaykpWzBdO1xuICAgICAgaWYgKCFuZXh0VHJhY2spIHtcbiAgICAgICAgdGhpcy53YXJuKGBVbmFibGUgdG8gZmluZCBzdWJ0aXRsZSBUZXh0VHJhY2sgd2l0aCBuYW1lIFwiJHtjdXJyZW50VHJhY2submFtZX1cIiBhbmQgbGFuZ3VhZ2UgXCIke2N1cnJlbnRUcmFjay5sYW5nfVwiYCk7XG4gICAgICB9XG4gICAgfVxuICAgIFtdLnNsaWNlLmNhbGwodGV4dFRyYWNrcykuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICBpZiAodHJhY2subW9kZSAhPT0gJ2Rpc2FibGVkJyAmJiB0cmFjayAhPT0gbmV4dFRyYWNrKSB7XG4gICAgICAgIHRyYWNrLm1vZGUgPSAnZGlzYWJsZWQnO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChuZXh0VHJhY2spIHtcbiAgICAgIGNvbnN0IG1vZGUgPSB0aGlzLnN1YnRpdGxlRGlzcGxheSA/ICdzaG93aW5nJyA6ICdoaWRkZW4nO1xuICAgICAgaWYgKG5leHRUcmFjay5tb2RlICE9PSBtb2RlKSB7XG4gICAgICAgIG5leHRUcmFjay5tb2RlID0gbW9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgcmVzcG9uc2libGUgZm9yIHZhbGlkYXRpbmcgdGhlIHN1YnRpdGxlIGluZGV4IGFuZCBwZXJpb2RpY2FsbHkgcmVsb2FkaW5nIGlmIGxpdmUuXG4gICAqIERpc3BhdGNoZXMgdGhlIFNVQlRJVExFX1RSQUNLX1NXSVRDSCBldmVudCwgd2hpY2ggaW5zdHJ1Y3RzIHRoZSBzdWJ0aXRsZS1zdHJlYW0tY29udHJvbGxlciB0byBsb2FkIHRoZSBzZWxlY3RlZCB0cmFjay5cbiAgICovXG4gIHNldFN1YnRpdGxlVHJhY2sobmV3SWQpIHtcbiAgICBjb25zdCB0cmFja3MgPSB0aGlzLnRyYWNrc0luR3JvdXA7XG5cbiAgICAvLyBzZXR0aW5nIHRoaXMuc3VidGl0bGVUcmFjayB3aWxsIHRyaWdnZXIgaW50ZXJuYWwgbG9naWNcbiAgICAvLyBpZiBtZWRpYSBoYXMgbm90IGJlZW4gYXR0YWNoZWQgeWV0LCBpdCB3aWxsIGZhaWxcbiAgICAvLyB3ZSBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBkZWZhdWx0IHRyYWNrIGlkXG4gICAgLy8gYW5kIHdlJ2xsIHNldCBzdWJ0aXRsZVRyYWNrIHdoZW4gb25NZWRpYUF0dGFjaGVkIGlzIHRyaWdnZXJlZFxuICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgdGhpcy5xdWV1ZWREZWZhdWx0VHJhY2sgPSBuZXdJZDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBleGl0IGlmIHRyYWNrIGlkIGFzIGFscmVhZHkgc2V0IG9yIGludmFsaWRcbiAgICBpZiAobmV3SWQgPCAtMSB8fCBuZXdJZCA+PSB0cmFja3MubGVuZ3RoIHx8ICFpc0Zpbml0ZU51bWJlcihuZXdJZCkpIHtcbiAgICAgIHRoaXMud2FybihgSW52YWxpZCBzdWJ0aXRsZSB0cmFjayBpZDogJHtuZXdJZH1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSBmYWxzZTtcbiAgICBjb25zdCBsYXN0VHJhY2sgPSB0aGlzLmN1cnJlbnRUcmFjaztcbiAgICBjb25zdCB0cmFjayA9IHRyYWNrc1tuZXdJZF0gfHwgbnVsbDtcbiAgICB0aGlzLnRyYWNrSWQgPSBuZXdJZDtcbiAgICB0aGlzLmN1cnJlbnRUcmFjayA9IHRyYWNrO1xuICAgIHRoaXMudG9nZ2xlVHJhY2tNb2RlcygpO1xuICAgIGlmICghdHJhY2spIHtcbiAgICAgIC8vIHN3aXRjaCB0byAtMVxuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuU1VCVElUTEVfVFJBQ0tfU1dJVENILCB7XG4gICAgICAgIGlkOiBuZXdJZFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRyYWNrTG9hZGVkID0gISF0cmFjay5kZXRhaWxzICYmICF0cmFjay5kZXRhaWxzLmxpdmU7XG4gICAgaWYgKG5ld0lkID09PSB0aGlzLnRyYWNrSWQgJiYgdHJhY2sgPT09IGxhc3RUcmFjayAmJiB0cmFja0xvYWRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxvZyhgU3dpdGNoaW5nIHRvIHN1YnRpdGxlLXRyYWNrICR7bmV3SWR9YCArICh0cmFjayA/IGAgXCIke3RyYWNrLm5hbWV9XCIgbGFuZzoke3RyYWNrLmxhbmd9IGdyb3VwOiR7dHJhY2suZ3JvdXBJZH1gIDogJycpKTtcbiAgICBjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIGdyb3VwSWQgPSAnJyxcbiAgICAgIG5hbWUsXG4gICAgICB0eXBlLFxuICAgICAgdXJsXG4gICAgfSA9IHRyYWNrO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLlNVQlRJVExFX1RSQUNLX1NXSVRDSCwge1xuICAgICAgaWQsXG4gICAgICBncm91cElkLFxuICAgICAgbmFtZSxcbiAgICAgIHR5cGUsXG4gICAgICB1cmxcbiAgICB9KTtcbiAgICBjb25zdCBobHNVcmxQYXJhbWV0ZXJzID0gdGhpcy5zd2l0Y2hQYXJhbXModHJhY2sudXJsLCBsYXN0VHJhY2sgPT0gbnVsbCA/IHZvaWQgMCA6IGxhc3RUcmFjay5kZXRhaWxzLCB0cmFjay5kZXRhaWxzKTtcbiAgICB0aGlzLmxvYWRQbGF5bGlzdChobHNVcmxQYXJhbWV0ZXJzKTtcbiAgfVxufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgcmFuZG9tIHY0IFVVSURcbiAqXG4gKiBAcmV0dXJucyBBIHJhbmRvbSB2NCBVVUlEXG4gKlxuICogQGdyb3VwIFV0aWxzXG4gKlxuICogQGJldGFcbiAqL1xuZnVuY3Rpb24gdXVpZCgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gY3J5cHRvLnJhbmRvbVVVSUQoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYigpKTtcbiAgICAgIGNvbnN0IHV1aWQgPSB1cmwudG9TdHJpbmcoKTtcbiAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcbiAgICAgIHJldHVybiB1dWlkLnNsaWNlKHV1aWQubGFzdEluZGV4T2YoJy8nKSArIDEpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsZXQgZHQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgIGNvbnN0IHV1aWQgPSAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGMgPT4ge1xuICAgICAgICBjb25zdCByID0gKGR0ICsgTWF0aC5yYW5kb20oKSAqIDE2KSAlIDE2IHwgMDtcbiAgICAgICAgZHQgPSBNYXRoLmZsb29yKGR0IC8gMTYpO1xuICAgICAgICByZXR1cm4gKGMgPT0gJ3gnID8gciA6IHIgJiAweDMgfCAweDgpLnRvU3RyaW5nKDE2KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHV1aWQ7XG4gICAgfVxuICB9XG59XG5cbi8vIEZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Rhcmtza3lhcHAvc3RyaW5nLWhhc2hcbmZ1bmN0aW9uIGhhc2godGV4dCkge1xuICBsZXQgaGFzaCA9IDUzODE7XG4gIGxldCBpID0gdGV4dC5sZW5ndGg7XG4gIHdoaWxlIChpKSB7XG4gICAgaGFzaCA9IGhhc2ggKiAzMyBeIHRleHQuY2hhckNvZGVBdCgtLWkpO1xuICB9XG4gIHJldHVybiAoaGFzaCA+Pj4gMCkudG9TdHJpbmcoKTtcbn1cblxuY29uc3QgQUxJR05FRF9FTkRfVEhSRVNIT0xEX1NFQ09ORFMgPSAwLjAyNTtcbmxldCBUaW1lbGluZU9jY3VwYW5jeSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoVGltZWxpbmVPY2N1cGFuY3kpIHtcbiAgVGltZWxpbmVPY2N1cGFuY3lbVGltZWxpbmVPY2N1cGFuY3lbXCJQb2ludFwiXSA9IDBdID0gXCJQb2ludFwiO1xuICBUaW1lbGluZU9jY3VwYW5jeVtUaW1lbGluZU9jY3VwYW5jeVtcIlJhbmdlXCJdID0gMV0gPSBcIlJhbmdlXCI7XG4gIHJldHVybiBUaW1lbGluZU9jY3VwYW5jeTtcbn0oe30pO1xuZnVuY3Rpb24gZ2VuZXJhdGVBc3NldElkZW50aWZpZXIoaW50ZXJzdGl0aWFsLCB1cmksIGFzc2V0TGlzdEluZGV4KSB7XG4gIHJldHVybiBgJHtpbnRlcnN0aXRpYWwuaWRlbnRpZmllcn0tJHthc3NldExpc3RJbmRleCArIDF9LSR7aGFzaCh1cmkpfWA7XG59XG5jbGFzcyBJbnRlcnN0aXRpYWxFdmVudCB7XG4gIGNvbnN0cnVjdG9yKGRhdGVSYW5nZSwgYmFzZSkge1xuICAgIHRoaXMuYmFzZSA9IHZvaWQgMDtcbiAgICB0aGlzLl9kdXJhdGlvbiA9IG51bGw7XG4gICAgdGhpcy5fdGltZWxpbmVTdGFydCA9IG51bGw7XG4gICAgdGhpcy5hcHBlbmRJblBsYWNlRGlzYWJsZWQgPSB2b2lkIDA7XG4gICAgdGhpcy5hcHBlbmRJblBsYWNlU3RhcnRlZCA9IHZvaWQgMDtcbiAgICB0aGlzLmRhdGVSYW5nZSA9IHZvaWQgMDtcbiAgICB0aGlzLmhhc1BsYXllZCA9IGZhbHNlO1xuICAgIHRoaXMuY3VtdWxhdGl2ZUR1cmF0aW9uID0gMDtcbiAgICB0aGlzLnJlc3VtZU9mZnNldCA9IE5hTjtcbiAgICB0aGlzLnBsYXlvdXRMaW1pdCA9IE5hTjtcbiAgICB0aGlzLnJlc3RyaWN0aW9ucyA9IHtcbiAgICAgIHNraXA6IGZhbHNlLFxuICAgICAganVtcDogZmFsc2VcbiAgICB9O1xuICAgIHRoaXMuc25hcE9wdGlvbnMgPSB7XG4gICAgICBvdXQ6IGZhbHNlLFxuICAgICAgaW46IGZhbHNlXG4gICAgfTtcbiAgICB0aGlzLmFzc2V0TGlzdCA9IFtdO1xuICAgIHRoaXMuYXNzZXRMaXN0TG9hZGVyID0gdm9pZCAwO1xuICAgIHRoaXMuYXNzZXRMaXN0UmVzcG9uc2UgPSBudWxsO1xuICAgIHRoaXMucmVzdW1lQW5jaG9yID0gdm9pZCAwO1xuICAgIHRoaXMuZXJyb3IgPSB2b2lkIDA7XG4gICAgdGhpcy5yZXNldE9uUmVzdW1lID0gdm9pZCAwO1xuICAgIHRoaXMuYmFzZSA9IGJhc2U7XG4gICAgdGhpcy5kYXRlUmFuZ2UgPSBkYXRlUmFuZ2U7XG4gICAgdGhpcy5zZXREYXRlUmFuZ2UoZGF0ZVJhbmdlKTtcbiAgfVxuICBzZXREYXRlUmFuZ2UoZGF0ZVJhbmdlKSB7XG4gICAgdGhpcy5kYXRlUmFuZ2UgPSBkYXRlUmFuZ2U7XG4gICAgdGhpcy5yZXN1bWVPZmZzZXQgPSBkYXRlUmFuZ2UuYXR0ci5vcHRpb25hbEZsb2F0KCdYLVJFU1VNRS1PRkZTRVQnLCB0aGlzLnJlc3VtZU9mZnNldCk7XG4gICAgdGhpcy5wbGF5b3V0TGltaXQgPSBkYXRlUmFuZ2UuYXR0ci5vcHRpb25hbEZsb2F0KCdYLVBMQVlPVVQtTElNSVQnLCB0aGlzLnBsYXlvdXRMaW1pdCk7XG4gICAgdGhpcy5yZXN0cmljdGlvbnMgPSBkYXRlUmFuZ2UuYXR0ci5lbnVtZXJhdGVkU3RyaW5nTGlzdCgnWC1SRVNUUklDVCcsIHRoaXMucmVzdHJpY3Rpb25zKTtcbiAgICB0aGlzLnNuYXBPcHRpb25zID0gZGF0ZVJhbmdlLmF0dHIuZW51bWVyYXRlZFN0cmluZ0xpc3QoJ1gtU05BUCcsIHRoaXMuc25hcE9wdGlvbnMpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHZhciBfdGhpcyRhc3NldExpc3RMb2FkZXI7XG4gICAgdGhpcy5hcHBlbmRJblBsYWNlU3RhcnRlZCA9IGZhbHNlO1xuICAgIChfdGhpcyRhc3NldExpc3RMb2FkZXIgPSB0aGlzLmFzc2V0TGlzdExvYWRlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGFzc2V0TGlzdExvYWRlci5kZXN0cm95KCk7XG4gICAgdGhpcy5hc3NldExpc3RMb2FkZXIgPSB1bmRlZmluZWQ7XG4gICAgaWYgKCF0aGlzLnN1cHBsZW1lbnRzUHJpbWFyeSkge1xuICAgICAgdGhpcy5hc3NldExpc3RSZXNwb25zZSA9IG51bGw7XG4gICAgICB0aGlzLmFzc2V0TGlzdCA9IFtdO1xuICAgICAgdGhpcy5fZHVyYXRpb24gPSBudWxsO1xuICAgIH1cbiAgICAvLyBgZXJyb3I/YCBpcyByZXNldCB3aGVuIHNlZWtpbmcgYmFjayBvdmVyIGludGVyc3RpdGlhbCBgc3RhcnRPZmZzZXRgXG4gICAgLy8gIHVzaW5nIGBzY2hlZHVsZS5yZXNldEVycm9yc0luUmFuZ2Uoc3RhcnQsIGVuZClgLlxuICB9XG4gIGlzQXNzZXRQYXN0UGxheW91dExpbWl0KGFzc2V0SW5kZXgpIHtcbiAgICB2YXIgX3RoaXMkYXNzZXRMaXN0JGFzc2V0O1xuICAgIGlmIChhc3NldEluZGV4ID4gMCAmJiBhc3NldEluZGV4ID49IHRoaXMuYXNzZXRMaXN0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHBsYXlvdXRMaW1pdCA9IHRoaXMucGxheW91dExpbWl0O1xuICAgIGlmIChhc3NldEluZGV4IDw9IDAgfHwgaXNOYU4ocGxheW91dExpbWl0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAocGxheW91dExpbWl0ID09PSAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgYXNzZXRPZmZzZXQgPSAoKF90aGlzJGFzc2V0TGlzdCRhc3NldCA9IHRoaXMuYXNzZXRMaXN0W2Fzc2V0SW5kZXhdKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkYXNzZXRMaXN0JGFzc2V0LnN0YXJ0T2Zmc2V0KSB8fCAwO1xuICAgIHJldHVybiBhc3NldE9mZnNldCA+IHBsYXlvdXRMaW1pdDtcbiAgfVxuICBmaW5kQXNzZXRJbmRleChhc3NldCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5hc3NldExpc3QuaW5kZXhPZihhc3NldCk7XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG4gIGdldCBpZGVudGlmaWVyKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGVSYW5nZS5pZDtcbiAgfVxuICBnZXQgc3RhcnREYXRlKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGVSYW5nZS5zdGFydERhdGU7XG4gIH1cbiAgZ2V0IHN0YXJ0VGltZSgpIHtcbiAgICAvLyBQcmltYXJ5IG1lZGlhIHRpbWVsaW5lIHN0YXJ0IHRpbWVcbiAgICBjb25zdCBzdGFydFRpbWUgPSB0aGlzLmRhdGVSYW5nZS5zdGFydFRpbWU7XG4gICAgaWYgKHRoaXMuc25hcE9wdGlvbnMub3V0KSB7XG4gICAgICBjb25zdCBmcmFnID0gdGhpcy5kYXRlUmFuZ2UudGFnQW5jaG9yO1xuICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgcmV0dXJuIGdldFNuYXBUb0ZyYWdtZW50VGltZShzdGFydFRpbWUsIGZyYWcpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhcnRUaW1lO1xuICB9XG4gIGdldCBzdGFydE9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdWUucHJlID8gMCA6IHRoaXMuc3RhcnRUaW1lO1xuICB9XG4gIGdldCBzdGFydElzQWxpZ25lZCgpIHtcbiAgICBpZiAodGhpcy5zdGFydFRpbWUgPT09IDAgfHwgdGhpcy5zbmFwT3B0aW9ucy5vdXQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBmcmFnID0gdGhpcy5kYXRlUmFuZ2UudGFnQW5jaG9yO1xuICAgIGlmIChmcmFnKSB7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSB0aGlzLmRhdGVSYW5nZS5zdGFydFRpbWU7XG4gICAgICBjb25zdCBzbmFwcGVkU3RhcnQgPSBnZXRTbmFwVG9GcmFnbWVudFRpbWUoc3RhcnRUaW1lLCBmcmFnKTtcbiAgICAgIHJldHVybiBzdGFydFRpbWUgLSBzbmFwcGVkU3RhcnQgPCAwLjE7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBnZXQgcmVzdW1wdGlvbk9mZnNldCgpIHtcbiAgICBjb25zdCByZXN1bWVPZmZzZXQgPSB0aGlzLnJlc3VtZU9mZnNldDtcbiAgICBjb25zdCBvZmZzZXQgPSBpc0Zpbml0ZU51bWJlcihyZXN1bWVPZmZzZXQpID8gcmVzdW1lT2Zmc2V0IDogdGhpcy5kdXJhdGlvbjtcbiAgICByZXR1cm4gdGhpcy5jdW11bGF0aXZlRHVyYXRpb24gKyBvZmZzZXQ7XG4gIH1cbiAgZ2V0IHJlc3VtZVRpbWUoKSB7XG4gICAgLy8gUHJpbWFyeSBtZWRpYSB0aW1lbGluZSByZXN1bXB0aW9uIHRpbWVcbiAgICBjb25zdCByZXN1bWVUaW1lID0gdGhpcy5zdGFydE9mZnNldCArIHRoaXMucmVzdW1wdGlvbk9mZnNldDtcbiAgICBpZiAodGhpcy5zbmFwT3B0aW9ucy5pbikge1xuICAgICAgY29uc3QgZnJhZyA9IHRoaXMucmVzdW1lQW5jaG9yO1xuICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgcmV0dXJuIGdldFNuYXBUb0ZyYWdtZW50VGltZShyZXN1bWVUaW1lLCBmcmFnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VtZVRpbWU7XG4gIH1cbiAgZ2V0IGFwcGVuZEluUGxhY2UoKSB7XG4gICAgaWYgKHRoaXMuYXBwZW5kSW5QbGFjZVN0YXJ0ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5hcHBlbmRJblBsYWNlRGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmN1ZS5vbmNlICYmICF0aGlzLmN1ZS5wcmUgJiZcbiAgICAvLyBwcmVyb2xsIHN0YXJ0cyBhdCBzdGFydFBvc2l0aW9uIGJlZm9yZSBzdGFydFBvc2l0aW9uIGlzIGtub3duIChsaXZlKVxuICAgIHRoaXMuc3RhcnRJc0FsaWduZWQgJiYgKGlzTmFOKHRoaXMucGxheW91dExpbWl0KSAmJiBpc05hTih0aGlzLnJlc3VtZU9mZnNldCkgfHwgdGhpcy5yZXN1bWVPZmZzZXQgJiYgdGhpcy5kdXJhdGlvbiAmJiBNYXRoLmFicyh0aGlzLnJlc3VtZU9mZnNldCAtIHRoaXMuZHVyYXRpb24pIDwgQUxJR05FRF9FTkRfVEhSRVNIT0xEX1NFQ09ORFMpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHNldCBhcHBlbmRJblBsYWNlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuYXBwZW5kSW5QbGFjZVN0YXJ0ZWQpIHtcbiAgICAgIHRoaXMucmVzZXRPblJlc3VtZSA9ICF2YWx1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5hcHBlbmRJblBsYWNlRGlzYWJsZWQgPSAhdmFsdWU7XG4gIH1cblxuICAvLyBFeHRlbmRlZCB0aW1lbGluZSBzdGFydCB0aW1lXG4gIGdldCB0aW1lbGluZVN0YXJ0KCkge1xuICAgIGlmICh0aGlzLl90aW1lbGluZVN0YXJ0ICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdGltZWxpbmVTdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3RhcnRUaW1lO1xuICB9XG4gIHNldCB0aW1lbGluZVN0YXJ0KHZhbHVlKSB7XG4gICAgdGhpcy5fdGltZWxpbmVTdGFydCA9IHZhbHVlO1xuICB9XG4gIGdldCBkdXJhdGlvbigpIHtcbiAgICBjb25zdCBwbGF5b3V0TGltaXQgPSB0aGlzLnBsYXlvdXRMaW1pdDtcbiAgICBsZXQgZHVyYXRpb247XG4gICAgaWYgKHRoaXMuX2R1cmF0aW9uICE9PSBudWxsKSB7XG4gICAgICBkdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uO1xuICAgIH0gZWxzZSBpZiAodGhpcy5kYXRlUmFuZ2UuZHVyYXRpb24pIHtcbiAgICAgIGR1cmF0aW9uID0gdGhpcy5kYXRlUmFuZ2UuZHVyYXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIGR1cmF0aW9uID0gdGhpcy5kYXRlUmFuZ2UucGxhbm5lZER1cmF0aW9uIHx8IDA7XG4gICAgfVxuICAgIGlmICghaXNOYU4ocGxheW91dExpbWl0KSAmJiBwbGF5b3V0TGltaXQgPCBkdXJhdGlvbikge1xuICAgICAgZHVyYXRpb24gPSBwbGF5b3V0TGltaXQ7XG4gICAgfVxuICAgIHJldHVybiBkdXJhdGlvbjtcbiAgfVxuICBzZXQgZHVyYXRpb24odmFsdWUpIHtcbiAgICB0aGlzLl9kdXJhdGlvbiA9IHZhbHVlO1xuICB9XG4gIGdldCBjdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0ZVJhbmdlLmN1ZTtcbiAgfVxuICBnZXQgdGltZWxpbmVPY2N1cGFuY3koKSB7XG4gICAgaWYgKHRoaXMuZGF0ZVJhbmdlLmF0dHJbJ1gtVElNRUxJTkUtT0NDVVBJRVMnXSA9PT0gJ1JBTkdFJykge1xuICAgICAgcmV0dXJuIFRpbWVsaW5lT2NjdXBhbmN5LlJhbmdlO1xuICAgIH1cbiAgICByZXR1cm4gVGltZWxpbmVPY2N1cGFuY3kuUG9pbnQ7XG4gIH1cbiAgZ2V0IHN1cHBsZW1lbnRzUHJpbWFyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlUmFuZ2UuYXR0clsnWC1USU1FTElORS1TVFlMRSddID09PSAnUFJJTUFSWSc7XG4gIH1cbiAgZ2V0IGNvbnRlbnRNYXlWYXJ5KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGVSYW5nZS5hdHRyWydYLUNPTlRFTlQtTUFZLVZBUlknXSAhPT0gJ05PJztcbiAgfVxuICBnZXQgYXNzZXRVcmwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0ZVJhbmdlLmF0dHJbJ1gtQVNTRVQtVVJJJ107XG4gIH1cbiAgZ2V0IGFzc2V0TGlzdFVybCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlUmFuZ2UuYXR0clsnWC1BU1NFVC1MSVNUJ107XG4gIH1cbiAgZ2V0IGJhc2VVcmwoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFzZS51cmw7XG4gIH1cbiAgZ2V0IGFzc2V0TGlzdExvYWRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5hc3NldExpc3QubGVuZ3RoID4gMCB8fCB0aGlzLmFzc2V0TGlzdFJlc3BvbnNlICE9PSBudWxsO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBldmVudFRvU3RyaW5nKHRoaXMpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRTbmFwVG9GcmFnbWVudFRpbWUodGltZSwgZnJhZykge1xuICByZXR1cm4gdGltZSAtIGZyYWcuc3RhcnQgPCBmcmFnLmR1cmF0aW9uIC8gMiAmJiAhKE1hdGguYWJzKHRpbWUgLSAoZnJhZy5zdGFydCArIGZyYWcuZHVyYXRpb24pKSA8IEFMSUdORURfRU5EX1RIUkVTSE9MRF9TRUNPTkRTKSA/IGZyYWcuc3RhcnQgOiBmcmFnLnN0YXJ0ICsgZnJhZy5kdXJhdGlvbjtcbn1cbmZ1bmN0aW9uIGdldEludGVyc3RpdGlhbFVybCh1cmksIHNlc3Npb25JZCwgYmFzZVVybCkge1xuICBjb25zdCB1cmwgPSBuZXcgc2VsZi5VUkwodXJpLCBiYXNlVXJsKTtcbiAgaWYgKHVybC5wcm90b2NvbCAhPT0gJ2RhdGE6Jykge1xuICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdfSExTX3ByaW1hcnlfaWQnLCBzZXNzaW9uSWQpO1xuICB9XG4gIHJldHVybiB1cmw7XG59XG5mdW5jdGlvbiBnZXROZXh0QXNzZXRJbmRleChpbnRlcnN0aXRpYWwsIGFzc2V0TGlzdEluZGV4KSB7XG4gIHdoaWxlICgoX2ludGVyc3RpdGlhbCRhc3NldExpID0gaW50ZXJzdGl0aWFsLmFzc2V0TGlzdFsrK2Fzc2V0TGlzdEluZGV4XSkgIT0gbnVsbCAmJiBfaW50ZXJzdGl0aWFsJGFzc2V0TGkuZXJyb3IpIHtcbiAgICB2YXIgX2ludGVyc3RpdGlhbCRhc3NldExpO1xuICB9IC8qIG5vLW9wICovXG4gIHJldHVybiBhc3NldExpc3RJbmRleDtcbn1cbmZ1bmN0aW9uIGV2ZW50VG9TdHJpbmcoaW50ZXJzdGl0aWFsKSB7XG4gIHJldHVybiBgW1wiJHtpbnRlcnN0aXRpYWwuaWRlbnRpZmllcn1cIiAke2ludGVyc3RpdGlhbC5jdWUucHJlID8gJzxwcmU+JyA6IGludGVyc3RpdGlhbC5jdWUucG9zdCA/ICc8cG9zdD4nIDogJyd9JHtpbnRlcnN0aXRpYWwudGltZWxpbmVTdGFydC50b0ZpeGVkKDIpfS0ke2ludGVyc3RpdGlhbC5yZXN1bWVUaW1lLnRvRml4ZWQoMil9XWA7XG59XG5mdW5jdGlvbiBldmVudEFzc2V0VG9TdHJpbmcoYXNzZXQpIHtcbiAgY29uc3Qgc3RhcnQgPSBhc3NldC50aW1lbGluZVN0YXJ0O1xuICBjb25zdCBkdXJhdGlvbiA9IGFzc2V0LmR1cmF0aW9uIHx8IDA7XG4gIHJldHVybiBgW1wiJHthc3NldC5pZGVudGlmaWVyfVwiICR7c3RhcnQudG9GaXhlZCgyKX0tJHsoc3RhcnQgKyBkdXJhdGlvbikudG9GaXhlZCgyKX1dYDtcbn1cblxuY2xhc3MgSGxzQXNzZXRQbGF5ZXIge1xuICBjb25zdHJ1Y3RvcihIbHNQbGF5ZXJDbGFzcywgdXNlckNvbmZpZywgaW50ZXJzdGl0aWFsLCBhc3NldEl0ZW0pIHtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmludGVyc3RpdGlhbCA9IHZvaWQgMDtcbiAgICB0aGlzLmFzc2V0SXRlbSA9IHZvaWQgMDtcbiAgICB0aGlzLnRyYWNrcyA9IG51bGw7XG4gICAgdGhpcy5oYXNEZXRhaWxzID0gZmFsc2U7XG4gICAgdGhpcy5tZWRpYUF0dGFjaGVkID0gbnVsbDtcbiAgICB0aGlzLl9jdXJyZW50VGltZSA9IHZvaWQgMDtcbiAgICB0aGlzLl9idWZmZXJlZEVvc1RpbWUgPSB2b2lkIDA7XG4gICAgdGhpcy5jaGVja1BsYXlvdXQgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5yZWFjaGVkUGxheW91dCh0aGlzLmN1cnJlbnRUaW1lKSkge1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5QTEFZT1VUX0xJTUlUX1JFQUNIRUQsIHt9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzID0gbmV3IEhsc1BsYXllckNsYXNzKHVzZXJDb25maWcpO1xuICAgIHRoaXMuaW50ZXJzdGl0aWFsID0gaW50ZXJzdGl0aWFsO1xuICAgIHRoaXMuYXNzZXRJdGVtID0gYXNzZXRJdGVtO1xuICAgIGxldCB1cmkgPSBhc3NldEl0ZW0udXJpO1xuICAgIHRyeSB7XG4gICAgICB1cmkgPSBnZXRJbnRlcnN0aXRpYWxVcmwodXJpLCB1c2VyQ29uZmlnLnByaW1hcnlTZXNzaW9uSWQpLmhyZWY7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIElnbm9yZSBlcnJvciBwYXJzaW5nIEFTU0VUX1VSSSBvciBhZGRpbmcgX0hMU19wcmltYXJ5X2lkIHRvIGl0LiBUaGVcbiAgICAgIC8vIGlzc3VlIHNob3VsZCBzdXJmYWNlIGFzIGFuIElOVEVSU1RJVElBTF9BU1NFVF9FUlJPUiBsb2FkaW5nIHRoZSBhc3NldC5cbiAgICB9XG4gICAgaGxzLmxvYWRTb3VyY2UodXJpKTtcbiAgICBjb25zdCBkZXRhaWxzTG9hZGVkID0gKCkgPT4ge1xuICAgICAgdGhpcy5oYXNEZXRhaWxzID0gdHJ1ZTtcbiAgICB9O1xuICAgIGhscy5vbmNlKEV2ZW50cy5MRVZFTF9MT0FERUQsIGRldGFpbHNMb2FkZWQpO1xuICAgIGhscy5vbmNlKEV2ZW50cy5BVURJT19UUkFDS19MT0FERUQsIGRldGFpbHNMb2FkZWQpO1xuICAgIGhscy5vbmNlKEV2ZW50cy5TVUJUSVRMRV9UUkFDS19MT0FERUQsIGRldGFpbHNMb2FkZWQpO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfQVRUQUNISU5HLCAobmFtZSwge1xuICAgICAgbWVkaWFcbiAgICB9KSA9PiB7XG4gICAgICB0aGlzLnJlbW92ZU1lZGlhTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLm1lZGlhQXR0YWNoZWQgPSBtZWRpYTtcbiAgICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5pbnRlcnN0aXRpYWw7XG4gICAgICBpZiAoZXZlbnQucGxheW91dExpbWl0KSB7XG4gICAgICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3RpbWV1cGRhdGUnLCB0aGlzLmNoZWNrUGxheW91dCk7XG4gICAgICAgIGlmICh0aGlzLmFwcGVuZEluUGxhY2UpIHtcbiAgICAgICAgICBobHMub24oRXZlbnRzLkJVRkZFUl9BUFBFTkRFRCwgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyZWRFbmQgPSB0aGlzLmJ1ZmZlcmVkRW5kO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhY2hlZFBsYXlvdXQoYnVmZmVyZWRFbmQpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2J1ZmZlcmVkRW9zVGltZSA9IGJ1ZmZlcmVkRW5kO1xuICAgICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuQlVGRkVSRURfVE9fRU5ELCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0IGFwcGVuZEluUGxhY2UoKSB7XG4gICAgdmFyIF90aGlzJGludGVyc3RpdGlhbDtcbiAgICByZXR1cm4gKChfdGhpcyRpbnRlcnN0aXRpYWwgPSB0aGlzLmludGVyc3RpdGlhbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGludGVyc3RpdGlhbC5hcHBlbmRJblBsYWNlKSB8fCBmYWxzZTtcbiAgfVxuICBidWZmZXJlZEluUGxhY2VUb0VuZChtZWRpYSkge1xuICAgIHZhciBfdGhpcyRobHM7XG4gICAgaWYgKCF0aGlzLmFwcGVuZEluUGxhY2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKChfdGhpcyRobHMgPSB0aGlzLmhscykgIT0gbnVsbCAmJiBfdGhpcyRobHMuYnVmZmVyZWRUb0VuZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghbWVkaWEgfHwgIXRoaXMuX2J1ZmZlcmVkRW9zVGltZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBzdGFydCA9IHRoaXMudGltZWxpbmVPZmZzZXQ7XG4gICAgY29uc3QgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKG1lZGlhLCBzdGFydCwgMCk7XG4gICAgY29uc3QgYnVmZmVyZWRFbmQgPSB0aGlzLmdldEFzc2V0VGltZShidWZmZXJJbmZvLmVuZCk7XG4gICAgcmV0dXJuIGJ1ZmZlcmVkRW5kID49IHRoaXMuX2J1ZmZlcmVkRW9zVGltZSAtIDAuMDI7XG4gIH1cbiAgcmVhY2hlZFBsYXlvdXQodGltZSkge1xuICAgIGNvbnN0IGludGVyc3RpdGlhbCA9IHRoaXMuaW50ZXJzdGl0aWFsO1xuICAgIGNvbnN0IHBsYXlvdXRMaW1pdCA9IGludGVyc3RpdGlhbC5wbGF5b3V0TGltaXQ7XG4gICAgcmV0dXJuIHRoaXMuc3RhcnRPZmZzZXQgKyB0aW1lID49IHBsYXlvdXRMaW1pdDtcbiAgfVxuICBnZXQgZGVzdHJveWVkKCkge1xuICAgIHZhciBfdGhpcyRobHMyO1xuICAgIHJldHVybiAhKChfdGhpcyRobHMyID0gdGhpcy5obHMpICE9IG51bGwgJiYgX3RoaXMkaGxzMi51c2VyQ29uZmlnKTtcbiAgfVxuICBnZXQgYXNzZXRJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5hc3NldEl0ZW0uaWRlbnRpZmllcjtcbiAgfVxuICBnZXQgaW50ZXJzdGl0aWFsSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXNzZXRJdGVtLnBhcmVudElkZW50aWZpZXI7XG4gIH1cbiAgZ2V0IG1lZGlhKCkge1xuICAgIHZhciBfdGhpcyRobHMzO1xuICAgIHJldHVybiAoKF90aGlzJGhsczMgPSB0aGlzLmhscykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGhsczMubWVkaWEpIHx8IG51bGw7XG4gIH1cbiAgZ2V0IGJ1ZmZlcmVkRW5kKCkge1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYSB8fCB0aGlzLm1lZGlhQXR0YWNoZWQ7XG4gICAgaWYgKCFtZWRpYSkge1xuICAgICAgaWYgKHRoaXMuX2J1ZmZlcmVkRW9zVGltZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyZWRFb3NUaW1lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFRpbWU7XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhtZWRpYSwgbWVkaWEuY3VycmVudFRpbWUsIDAuMDAxKTtcbiAgICByZXR1cm4gdGhpcy5nZXRBc3NldFRpbWUoYnVmZmVySW5mby5lbmQpO1xuICB9XG4gIGdldCBjdXJyZW50VGltZSgpIHtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWEgfHwgdGhpcy5tZWRpYUF0dGFjaGVkO1xuICAgIGlmICghbWVkaWEpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50VGltZSB8fCAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRBc3NldFRpbWUobWVkaWEuY3VycmVudFRpbWUpO1xuICB9XG4gIGdldCBkdXJhdGlvbigpIHtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHRoaXMuYXNzZXRJdGVtLmR1cmF0aW9uO1xuICAgIGlmICghZHVyYXRpb24pIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gZHVyYXRpb247XG4gIH1cbiAgZ2V0IHJlbWFpbmluZygpIHtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHRoaXMuZHVyYXRpb247XG4gICAgaWYgKCFkdXJhdGlvbikge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLm1heCgwLCBkdXJhdGlvbiAtIHRoaXMuY3VycmVudFRpbWUpO1xuICB9XG4gIGdldCBzdGFydE9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5hc3NldEl0ZW0uc3RhcnRPZmZzZXQ7XG4gIH1cbiAgZ2V0IHRpbWVsaW5lT2Zmc2V0KCkge1xuICAgIHZhciBfdGhpcyRobHM0O1xuICAgIHJldHVybiAoKF90aGlzJGhsczQgPSB0aGlzLmhscykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGhsczQuY29uZmlnLnRpbWVsaW5lT2Zmc2V0KSB8fCAwO1xuICB9XG4gIHNldCB0aW1lbGluZU9mZnNldCh2YWx1ZSkge1xuICAgIGNvbnN0IHRpbWVsaW5lT2Zmc2V0ID0gdGhpcy50aW1lbGluZU9mZnNldDtcbiAgICBpZiAodmFsdWUgIT09IHRpbWVsaW5lT2Zmc2V0KSB7XG4gICAgICBjb25zdCBkaWZmID0gdmFsdWUgLSB0aW1lbGluZU9mZnNldDtcbiAgICAgIGlmIChNYXRoLmFicyhkaWZmKSA+IDEgLyA5MDAwMCkge1xuICAgICAgICBpZiAodGhpcy5oYXNEZXRhaWxzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgc2V0IHRpbWVsaW5lT2Zmc2V0IGFmdGVyIHBsYXlsaXN0cyBhcmUgbG9hZGVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5obHMuY29uZmlnLnRpbWVsaW5lT2Zmc2V0ID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldEFzc2V0VGltZSh0aW1lKSB7XG4gICAgY29uc3QgdGltZWxpbmVPZmZzZXQgPSB0aGlzLnRpbWVsaW5lT2Zmc2V0O1xuICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5kdXJhdGlvbjtcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgoMCwgdGltZSAtIHRpbWVsaW5lT2Zmc2V0KSwgZHVyYXRpb24pO1xuICB9XG4gIHJlbW92ZU1lZGlhTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYUF0dGFjaGVkO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgdGhpcy5fY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICAgIHRoaXMuYnVmZmVyU25hcFNob3QoKTtcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RpbWV1cGRhdGUnLCB0aGlzLmNoZWNrUGxheW91dCk7XG4gICAgfVxuICB9XG4gIGJ1ZmZlclNuYXBTaG90KCkge1xuICAgIGlmICh0aGlzLm1lZGlhQXR0YWNoZWQpIHtcbiAgICAgIHZhciBfdGhpcyRobHM1O1xuICAgICAgaWYgKChfdGhpcyRobHM1ID0gdGhpcy5obHMpICE9IG51bGwgJiYgX3RoaXMkaGxzNS5idWZmZXJlZFRvRW5kKSB7XG4gICAgICAgIHRoaXMuX2J1ZmZlcmVkRW9zVGltZSA9IHRoaXMuYnVmZmVyZWRFbmQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW1vdmVNZWRpYUxpc3RlbmVycygpO1xuICAgIHRoaXMuaGxzLmRlc3Ryb3koKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSB0aGlzLmludGVyc3RpdGlhbCA9IG51bGw7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMudHJhY2tzID0gdGhpcy5tZWRpYUF0dGFjaGVkID0gdGhpcy5jaGVja1BsYXlvdXQgPSBudWxsO1xuICB9XG4gIGF0dGFjaE1lZGlhKGRhdGEpIHtcbiAgICB0aGlzLmhscy5hdHRhY2hNZWRpYShkYXRhKTtcbiAgfVxuICBkZXRhY2hNZWRpYSgpIHtcbiAgICB0aGlzLnJlbW92ZU1lZGlhTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5tZWRpYUF0dGFjaGVkID0gbnVsbDtcbiAgICB0aGlzLmhscy5kZXRhY2hNZWRpYSgpO1xuICB9XG4gIHJlc3VtZUJ1ZmZlcmluZygpIHtcbiAgICB0aGlzLmhscy5yZXN1bWVCdWZmZXJpbmcoKTtcbiAgfVxuICBwYXVzZUJ1ZmZlcmluZygpIHtcbiAgICB0aGlzLmhscy5wYXVzZUJ1ZmZlcmluZygpO1xuICB9XG4gIHRyYW5zZmVyTWVkaWEoKSB7XG4gICAgdGhpcy5idWZmZXJTbmFwU2hvdCgpO1xuICAgIHJldHVybiB0aGlzLmhscy50cmFuc2Zlck1lZGlhKCk7XG4gIH1cbiAgcmVzZXREZXRhaWxzKCkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGlmICh0aGlzLmhhc0RldGFpbHMpIHtcbiAgICAgIGhscy5zdG9wTG9hZCgpO1xuICAgICAgY29uc3QgZGVsZXRlRGV0YWlscyA9IG9iaiA9PiBkZWxldGUgb2JqLmRldGFpbHM7XG4gICAgICBobHMubGV2ZWxzLmZvckVhY2goZGVsZXRlRGV0YWlscyk7XG4gICAgICBobHMuYWxsQXVkaW9UcmFja3MuZm9yRWFjaChkZWxldGVEZXRhaWxzKTtcbiAgICAgIGhscy5hbGxTdWJ0aXRsZVRyYWNrcy5mb3JFYWNoKGRlbGV0ZURldGFpbHMpO1xuICAgICAgdGhpcy5oYXNEZXRhaWxzID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIG9uKGV2ZW50LCBsaXN0ZW5lciwgY29udGV4dCkge1xuICAgIHRoaXMuaGxzLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gIH1cbiAgb25jZShldmVudCwgbGlzdGVuZXIsIGNvbnRleHQpIHtcbiAgICB0aGlzLmhscy5vbmNlKGV2ZW50LCBsaXN0ZW5lcik7XG4gIH1cbiAgb2ZmKGV2ZW50LCBsaXN0ZW5lciwgY29udGV4dCkge1xuICAgIHRoaXMuaGxzLm9mZihldmVudCwgbGlzdGVuZXIpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHZhciBfdGhpcyRobHM2O1xuICAgIHJldHVybiBgSGxzQXNzZXRQbGF5ZXI6ICR7ZXZlbnRBc3NldFRvU3RyaW5nKHRoaXMuYXNzZXRJdGVtKX0gJHsoX3RoaXMkaGxzNiA9IHRoaXMuaGxzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkaGxzNi5zZXNzaW9uSWR9ICR7dGhpcy5hcHBlbmRJblBsYWNlID8gJ2FwcGVuZC1pbi1wbGFjZScgOiAnJ31gO1xuICB9XG59XG5cbmNvbnN0IEFCVVRUSU5HX1RIUkVTSE9MRF9TRUNPTkRTID0gMC4wMzM7XG5jbGFzcyBJbnRlcnN0aXRpYWxzU2NoZWR1bGUgZXh0ZW5kcyBMb2dnZXIge1xuICBjb25zdHJ1Y3RvcihvblNjaGVkdWxlVXBkYXRlLCBsb2dnZXIpIHtcbiAgICBzdXBlcignaW50ZXJzdGl0aWFscy1zY2hlZCcsIGxvZ2dlcik7XG4gICAgdGhpcy5vblNjaGVkdWxlVXBkYXRlID0gdm9pZCAwO1xuICAgIHRoaXMuZXZlbnRNYXAgPSB7fTtcbiAgICB0aGlzLmV2ZW50cyA9IG51bGw7XG4gICAgdGhpcy5pdGVtcyA9IG51bGw7XG4gICAgdGhpcy5kdXJhdGlvbnMgPSB7XG4gICAgICBwcmltYXJ5OiAwLFxuICAgICAgcGxheW91dDogMCxcbiAgICAgIGludGVncmF0ZWQ6IDBcbiAgICB9O1xuICAgIHRoaXMub25TY2hlZHVsZVVwZGF0ZSA9IG9uU2NoZWR1bGVVcGRhdGU7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlc2V0KCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMub25TY2hlZHVsZVVwZGF0ZSA9IG51bGw7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5ldmVudE1hcCA9IHt9O1xuICAgIHRoaXMuc2V0RHVyYXRpb25zKDAsIDAsIDApO1xuICAgIGlmICh0aGlzLmV2ZW50cykge1xuICAgICAgdGhpcy5ldmVudHMuZm9yRWFjaChpbnRlcnN0aXRpYWwgPT4gaW50ZXJzdGl0aWFsLnJlc2V0KCkpO1xuICAgIH1cbiAgICB0aGlzLmV2ZW50cyA9IHRoaXMuaXRlbXMgPSBudWxsO1xuICB9XG4gIHJlc2V0RXJyb3JzSW5SYW5nZShzdGFydCwgZW5kKSB7XG4gICAgaWYgKHRoaXMuZXZlbnRzKSB7XG4gICAgICByZXR1cm4gdGhpcy5ldmVudHMucmVkdWNlKChjb3VudCwgaW50ZXJzdGl0aWFsKSA9PiB7XG4gICAgICAgIGlmIChzdGFydCA8PSBpbnRlcnN0aXRpYWwuc3RhcnRPZmZzZXQgJiYgZW5kID4gaW50ZXJzdGl0aWFsLnN0YXJ0T2Zmc2V0KSB7XG4gICAgICAgICAgZGVsZXRlIGludGVyc3RpdGlhbC5lcnJvcjtcbiAgICAgICAgICByZXR1cm4gY291bnQgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICBnZXQgZHVyYXRpb24oKSB7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgIHJldHVybiBpdGVtcyA/IGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdLmVuZCA6IDA7XG4gIH1cbiAgZ2V0IGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtcyA/IHRoaXMuaXRlbXMubGVuZ3RoIDogMDtcbiAgfVxuICBnZXRFdmVudChpZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIGlkZW50aWZpZXIgPyB0aGlzLmV2ZW50TWFwW2lkZW50aWZpZXJdIHx8IG51bGwgOiBudWxsO1xuICB9XG4gIGhhc0V2ZW50KGlkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gaWRlbnRpZmllciBpbiB0aGlzLmV2ZW50TWFwO1xuICB9XG4gIGZpbmRJdGVtSW5kZXgoaXRlbSwgdGltZSkge1xuICAgIGlmIChpdGVtLmV2ZW50KSB7XG4gICAgICAvLyBGaW5kIEV2ZW50IEl0ZW1cbiAgICAgIHJldHVybiB0aGlzLmZpbmRFdmVudEluZGV4KGl0ZW0uZXZlbnQuaWRlbnRpZmllcik7XG4gICAgfVxuICAgIC8vIEZpbmQgUHJpbWFyeSBJdGVtXG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgaWYgKGl0ZW0ubmV4dEV2ZW50KSB7XG4gICAgICBpbmRleCA9IHRoaXMuZmluZEV2ZW50SW5kZXgoaXRlbS5uZXh0RXZlbnQuaWRlbnRpZmllcikgLSAxO1xuICAgIH0gZWxzZSBpZiAoaXRlbS5wcmV2aW91c0V2ZW50KSB7XG4gICAgICBpbmRleCA9IHRoaXMuZmluZEV2ZW50SW5kZXgoaXRlbS5wcmV2aW91c0V2ZW50LmlkZW50aWZpZXIpICsgMTtcbiAgICB9XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgIGlmIChpdGVtcykge1xuICAgICAgaWYgKCFpdGVtc1tpbmRleF0pIHtcbiAgICAgICAgaWYgKHRpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRpbWUgPSBpdGVtLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gdGhpcy5maW5kSXRlbUluZGV4QXRUaW1lKHRpbWUpO1xuICAgICAgfVxuICAgICAgLy8gT25seSByZXR1cm4gaW5kZXggb2YgYSBQcmltYXJ5IEl0ZW1cbiAgICAgIHdoaWxlIChpbmRleCA+PSAwICYmIChfaXRlbXMkaW5kZXggPSBpdGVtc1tpbmRleF0pICE9IG51bGwgJiYgX2l0ZW1zJGluZGV4LmV2ZW50KSB7XG4gICAgICAgIHZhciBfaXRlbXMkaW5kZXg7XG4gICAgICAgIC8vIElmIGluZGV4IGZvdW5kIGlzIGFuIGludGVyc3RpdGlhbCBpdCBpcyBub3QgYSB2YWxpZCByZXN1bHQgYXMgaXQgc2hvdWxkIGhhdmUgYmVlbiBtYXRjaGVkIHVwIHRvcFxuICAgICAgICAvLyBkZWNyZW1lbnQgdW50aWwgcmVzdWx0IGlzIG5lZ2F0aXZlIChub3QgZm91bmQpIG9yIGEgcHJpbWFyeSBzZWdtZW50XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuICBmaW5kSXRlbUluZGV4QXRUaW1lKHRpbWVsaW5lUG9zLCB0aW1lbGluZVR5cGUpIHtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuaXRlbXM7XG4gICAgaWYgKGl0ZW1zKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCB0aW1lUmFuZ2UgPSBpdGVtc1tpXTtcbiAgICAgICAgaWYgKHRpbWVsaW5lVHlwZSAmJiB0aW1lbGluZVR5cGUgIT09ICdwcmltYXJ5Jykge1xuICAgICAgICAgIHRpbWVSYW5nZSA9IHRpbWVSYW5nZVt0aW1lbGluZVR5cGVdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lbGluZVBvcyA9PT0gdGltZVJhbmdlLnN0YXJ0IHx8IHRpbWVsaW5lUG9zID4gdGltZVJhbmdlLnN0YXJ0ICYmIHRpbWVsaW5lUG9zIDwgdGltZVJhbmdlLmVuZCkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICBmaW5kSnVtcFJlc3RyaWN0ZWRJbmRleChzdGFydEluZGV4LCBlbmRJbmRleCkge1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5pdGVtcztcbiAgICBpZiAoaXRlbXMpIHtcbiAgICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDw9IGVuZEluZGV4OyBpKyspIHtcbiAgICAgICAgaWYgKCFpdGVtc1tpXSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gaXRlbXNbaV0uZXZlbnQ7XG4gICAgICAgIGlmIChldmVudCAhPSBudWxsICYmIGV2ZW50LnJlc3RyaWN0aW9ucy5qdW1wICYmICFldmVudC5hcHBlbmRJblBsYWNlKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGZpbmRFdmVudEluZGV4KGlkZW50aWZpZXIpIHtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuaXRlbXM7XG4gICAgaWYgKGl0ZW1zKSB7XG4gICAgICBmb3IgKGxldCBpID0gaXRlbXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgIHZhciBfaXRlbXMkaSRldmVudDtcbiAgICAgICAgaWYgKCgoX2l0ZW1zJGkkZXZlbnQgPSBpdGVtc1tpXS5ldmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9pdGVtcyRpJGV2ZW50LmlkZW50aWZpZXIpID09PSBpZGVudGlmaWVyKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGZpbmRBc3NldEluZGV4KGV2ZW50LCB0aW1lbGluZVBvcykge1xuICAgIGNvbnN0IGFzc2V0TGlzdCA9IGV2ZW50LmFzc2V0TGlzdDtcbiAgICBjb25zdCBsZW5ndGggPSBhc3NldExpc3QubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPiAxKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFzc2V0ID0gYXNzZXRMaXN0W2ldO1xuICAgICAgICBpZiAoIWFzc2V0LmVycm9yKSB7XG4gICAgICAgICAgY29uc3QgdGltZWxpbmVTdGFydCA9IGFzc2V0LnRpbWVsaW5lU3RhcnQ7XG4gICAgICAgICAgaWYgKHRpbWVsaW5lUG9zID09PSB0aW1lbGluZVN0YXJ0IHx8IHRpbWVsaW5lUG9zID4gdGltZWxpbmVTdGFydCAmJiB0aW1lbGluZVBvcyA8IHRpbWVsaW5lU3RhcnQgKyAoYXNzZXQuZHVyYXRpb24gfHwgMCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICBnZXQgYXNzZXRJZEF0RW5kKCkge1xuICAgIHZhciBfdGhpcyRpdGVtcywgX3RoaXMkaXRlbXMyO1xuICAgIGNvbnN0IGludGVyc3RpdGlhbEF0RW5kID0gKF90aGlzJGl0ZW1zID0gdGhpcy5pdGVtcykgPT0gbnVsbCA/IHZvaWQgMCA6IChfdGhpcyRpdGVtczIgPSBfdGhpcyRpdGVtc1t0aGlzLmxlbmd0aCAtIDFdKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkaXRlbXMyLmV2ZW50O1xuICAgIGlmIChpbnRlcnN0aXRpYWxBdEVuZCkge1xuICAgICAgY29uc3QgYXNzZXRMaXN0ID0gaW50ZXJzdGl0aWFsQXRFbmQuYXNzZXRMaXN0O1xuICAgICAgY29uc3QgYXNzZXRBdEVuZCA9IGFzc2V0TGlzdFthc3NldExpc3QubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoYXNzZXRBdEVuZCkge1xuICAgICAgICByZXR1cm4gYXNzZXRBdEVuZC5pZGVudGlmaWVyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBwYXJzZUludGVyc3RpdGlhbERhdGVSYW5nZXMobWVkaWFTZWxlY3Rpb24sIGVuYWJsZUFwcGVuZEluUGxhY2UpIHtcbiAgICBjb25zdCBkZXRhaWxzID0gbWVkaWFTZWxlY3Rpb24ubWFpbi5kZXRhaWxzO1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGVSYW5nZXNcbiAgICB9ID0gZGV0YWlscztcbiAgICBjb25zdCBwcmV2aW91c0ludGVyc3RpdGlhbEV2ZW50cyA9IHRoaXMuZXZlbnRzO1xuICAgIGNvbnN0IGludGVyc3RpdGlhbEV2ZW50cyA9IHRoaXMucGFyc2VEYXRlUmFuZ2VzKGRhdGVSYW5nZXMsIHtcbiAgICAgIHVybDogZGV0YWlscy51cmxcbiAgICB9LCBlbmFibGVBcHBlbmRJblBsYWNlKTtcbiAgICBjb25zdCBpZHMgPSBPYmplY3Qua2V5cyhkYXRlUmFuZ2VzKTtcbiAgICBjb25zdCByZW1vdmVkSW50ZXJzdGl0aWFscyA9IHByZXZpb3VzSW50ZXJzdGl0aWFsRXZlbnRzID8gcHJldmlvdXNJbnRlcnN0aXRpYWxFdmVudHMuZmlsdGVyKGV2ZW50ID0+ICFpZHMuaW5jbHVkZXMoZXZlbnQuaWRlbnRpZmllcikpIDogW107XG4gICAgaWYgKGludGVyc3RpdGlhbEV2ZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIHByZS1yb2xscywgcG9zdC1yb2xscywgYW5kIGV2ZW50cyB3aXRoIHRoZSBzYW1lIHN0YXJ0IHRpbWUgYXJlIHBsYXllZCBpbiBwbGF5bGlzdCB0YWcgb3JkZXJcbiAgICAgIC8vIGFsbCBvdGhlciBldmVudHMgYXJlIG9yZGVyZWQgYnkgc3RhcnQgdGltZVxuICAgICAgaW50ZXJzdGl0aWFsRXZlbnRzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgY29uc3QgYVByZSA9IGEuY3VlLnByZTtcbiAgICAgICAgY29uc3QgYVBvc3QgPSBhLmN1ZS5wb3N0O1xuICAgICAgICBjb25zdCBiUHJlID0gYi5jdWUucHJlO1xuICAgICAgICBjb25zdCBiUG9zdCA9IGIuY3VlLnBvc3Q7XG4gICAgICAgIGlmIChhUHJlICYmICFiUHJlKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiUHJlICYmICFhUHJlKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFQb3N0ICYmICFiUG9zdCkge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiUG9zdCAmJiAhYVBvc3QpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhUHJlICYmICFiUHJlICYmICFhUG9zdCAmJiAhYlBvc3QpIHtcbiAgICAgICAgICBjb25zdCBzdGFydEEgPSBhLnN0YXJ0VGltZTtcbiAgICAgICAgICBjb25zdCBzdGFydEIgPSBiLnN0YXJ0VGltZTtcbiAgICAgICAgICBpZiAoc3RhcnRBICE9PSBzdGFydEIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFydEEgLSBzdGFydEI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhLmRhdGVSYW5nZS50YWdPcmRlciAtIGIuZGF0ZVJhbmdlLnRhZ09yZGVyO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuZXZlbnRzID0gaW50ZXJzdGl0aWFsRXZlbnRzO1xuXG4gICAgLy8gQ2xlYXIgcmVtb3ZlZCBEYXRlUmFuZ2VzIGZyb20gYnVmZmVyZWQgbGlzdCAoa2lsbHMgcGxheWJhY2sgb2YgYWN0aXZlIEludGVyc3RpdGlhbHMpXG4gICAgcmVtb3ZlZEludGVyc3RpdGlhbHMuZm9yRWFjaChpbnRlcnN0aXRpYWwgPT4ge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudChpbnRlcnN0aXRpYWwpO1xuICAgIH0pO1xuICAgIHRoaXMudXBkYXRlU2NoZWR1bGUobWVkaWFTZWxlY3Rpb24sIHJlbW92ZWRJbnRlcnN0aXRpYWxzKTtcbiAgfVxuICB1cGRhdGVTY2hlZHVsZShtZWRpYVNlbGVjdGlvbiwgcmVtb3ZlZEludGVyc3RpdGlhbHMgPSBbXSkge1xuICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMuZXZlbnRzIHx8IFtdO1xuICAgIGlmIChldmVudHMubGVuZ3RoIHx8IHJlbW92ZWRJbnRlcnN0aXRpYWxzLmxlbmd0aCB8fCB0aGlzLmxlbmd0aCA8IDIpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRJdGVtcyA9IHRoaXMuaXRlbXM7XG4gICAgICBjb25zdCB1cGRhdGVkSXRlbXMgPSB0aGlzLnBhcnNlU2NoZWR1bGUoZXZlbnRzLCBtZWRpYVNlbGVjdGlvbik7XG4gICAgICBjb25zdCB1cGRhdGVkID0gcmVtb3ZlZEludGVyc3RpdGlhbHMubGVuZ3RoIHx8IChjdXJyZW50SXRlbXMgPT0gbnVsbCA/IHZvaWQgMCA6IGN1cnJlbnRJdGVtcy5sZW5ndGgpICE9PSB1cGRhdGVkSXRlbXMubGVuZ3RoIHx8IHVwZGF0ZWRJdGVtcy5zb21lKChpdGVtLCBpKSA9PiB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyhpdGVtLnBsYXlvdXQuc3RhcnQgLSBjdXJyZW50SXRlbXNbaV0ucGxheW91dC5zdGFydCkgPiAwLjAwNSB8fCBNYXRoLmFicyhpdGVtLnBsYXlvdXQuZW5kIC0gY3VycmVudEl0ZW1zW2ldLnBsYXlvdXQuZW5kKSA+IDAuMDA1O1xuICAgICAgfSk7XG4gICAgICBpZiAodXBkYXRlZCkge1xuICAgICAgICB0aGlzLml0ZW1zID0gdXBkYXRlZEl0ZW1zO1xuICAgICAgICAvLyBjYWxsIGludGVyc3RpdGlhbHMtY29udHJvbGxlciBvblNjaGVkdWxlVXBkYXRlZCgpXG4gICAgICAgIHRoaXMub25TY2hlZHVsZVVwZGF0ZShyZW1vdmVkSW50ZXJzdGl0aWFscywgY3VycmVudEl0ZW1zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcGFyc2VEYXRlUmFuZ2VzKGRhdGVSYW5nZXMsIGJhc2VEYXRhLCBlbmFibGVBcHBlbmRJblBsYWNlKSB7XG4gICAgY29uc3QgaW50ZXJzdGl0aWFsRXZlbnRzID0gW107XG4gICAgY29uc3QgaWRzID0gT2JqZWN0LmtleXMoZGF0ZVJhbmdlcyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGlkID0gaWRzW2ldO1xuICAgICAgY29uc3QgZGF0ZVJhbmdlID0gZGF0ZVJhbmdlc1tpZF07XG4gICAgICBpZiAoZGF0ZVJhbmdlLmlzSW50ZXJzdGl0aWFsKSB7XG4gICAgICAgIGxldCBpbnRlcnN0aXRpYWwgPSB0aGlzLmV2ZW50TWFwW2lkXTtcbiAgICAgICAgaWYgKGludGVyc3RpdGlhbCkge1xuICAgICAgICAgIC8vIFVwZGF0ZSBJbnRlcnN0aXRpYWxFdmVudCBhbHJlYWR5IHBhcnNlZCBhbmQgbWFwcGVkXG4gICAgICAgICAgLy8gVGhpcyByZXRhaW5zIGFscmVhZHkgbG9hZGVkIGR1cmF0aW9uIGFuZCBsb2FkZWQgYXNzZXQgbGlzdCBpbmZvXG4gICAgICAgICAgaW50ZXJzdGl0aWFsLnNldERhdGVSYW5nZShkYXRlUmFuZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGludGVyc3RpdGlhbCA9IG5ldyBJbnRlcnN0aXRpYWxFdmVudChkYXRlUmFuZ2UsIGJhc2VEYXRhKTtcbiAgICAgICAgICB0aGlzLmV2ZW50TWFwW2lkXSA9IGludGVyc3RpdGlhbDtcbiAgICAgICAgICBpZiAoZW5hYmxlQXBwZW5kSW5QbGFjZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGludGVyc3RpdGlhbC5hcHBlbmRJblBsYWNlID0gZW5hYmxlQXBwZW5kSW5QbGFjZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW50ZXJzdGl0aWFsRXZlbnRzLnB1c2goaW50ZXJzdGl0aWFsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGludGVyc3RpdGlhbEV2ZW50cztcbiAgfVxuICBwYXJzZVNjaGVkdWxlKGludGVyc3RpdGlhbEV2ZW50cywgbWVkaWFTZWxlY3Rpb24pIHtcbiAgICBjb25zdCBzY2hlZHVsZSA9IFtdO1xuICAgIGNvbnN0IGRldGFpbHMgPSBtZWRpYVNlbGVjdGlvbi5tYWluLmRldGFpbHM7XG4gICAgY29uc3QgcHJpbWFyeUR1cmF0aW9uID0gZGV0YWlscy5saXZlID8gSW5maW5pdHkgOiBkZXRhaWxzLmVkZ2U7XG4gICAgbGV0IHBsYXlvdXREdXJhdGlvbiA9IDA7XG5cbiAgICAvLyBGaWx0ZXIgZXZlbnRzIHRoYXQgaGF2ZSBlcnJvcmVkIGZyb20gdGhlIHNjaGVkdWxlIChQcmltYXJ5IGZhbGxiYWNrKVxuICAgIGludGVyc3RpdGlhbEV2ZW50cyA9IGludGVyc3RpdGlhbEV2ZW50cy5maWx0ZXIoZXZlbnQgPT4gIWV2ZW50LmVycm9yICYmICEoZXZlbnQuY3VlLm9uY2UgJiYgZXZlbnQuaGFzUGxheWVkKSk7XG4gICAgaWYgKGludGVyc3RpdGlhbEV2ZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIFVwZGF0ZSBTY2hlZHVsZVxuICAgICAgdGhpcy5yZXNvbHZlT2Zmc2V0cyhpbnRlcnN0aXRpYWxFdmVudHMsIG1lZGlhU2VsZWN0aW9uKTtcblxuICAgICAgLy8gUG9wdWxhdGUgU2NoZWR1bGUgd2l0aCBJbnRlcnN0aXRpYWwgRXZlbnQgYW5kIFByaW1hcnkgU2VnbWVudCBJdGVtc1xuICAgICAgbGV0IHByaW1hcnlQb3NpdGlvbiA9IDA7XG4gICAgICBsZXQgaW50ZWdyYXRlZFRpbWUgPSAwO1xuICAgICAgaW50ZXJzdGl0aWFsRXZlbnRzLmZvckVhY2goKGludGVyc3RpdGlhbCwgaSkgPT4ge1xuICAgICAgICBjb25zdCBwcmVyb2xsID0gaW50ZXJzdGl0aWFsLmN1ZS5wcmU7XG4gICAgICAgIGNvbnN0IHBvc3Ryb2xsID0gaW50ZXJzdGl0aWFsLmN1ZS5wb3N0O1xuICAgICAgICBjb25zdCBwcmV2aW91c0V2ZW50ID0gaW50ZXJzdGl0aWFsRXZlbnRzW2kgLSAxXSB8fCBudWxsO1xuICAgICAgICBjb25zdCBhcHBlbmRJblBsYWNlID0gaW50ZXJzdGl0aWFsLmFwcGVuZEluUGxhY2U7XG4gICAgICAgIGNvbnN0IGV2ZW50U3RhcnQgPSBwb3N0cm9sbCA/IHByaW1hcnlEdXJhdGlvbiA6IGludGVyc3RpdGlhbC5zdGFydE9mZnNldDtcbiAgICAgICAgY29uc3QgaW50ZXJzdGl0aWFsRHVyYXRpb24gPSBpbnRlcnN0aXRpYWwuZHVyYXRpb247XG4gICAgICAgIGNvbnN0IHRpbWVsaW5lRHVyYXRpb24gPSBpbnRlcnN0aXRpYWwudGltZWxpbmVPY2N1cGFuY3kgPT09IFRpbWVsaW5lT2NjdXBhbmN5LlJhbmdlID8gaW50ZXJzdGl0aWFsRHVyYXRpb24gOiAwO1xuICAgICAgICBjb25zdCByZXN1bXB0aW9uT2Zmc2V0ID0gaW50ZXJzdGl0aWFsLnJlc3VtcHRpb25PZmZzZXQ7XG4gICAgICAgIGNvbnN0IGluU2FtZVN0YXJ0VGltZVNlcXVlbmNlID0gKHByZXZpb3VzRXZlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZpb3VzRXZlbnQuc3RhcnRUaW1lKSA9PT0gZXZlbnRTdGFydDtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBldmVudFN0YXJ0ICsgaW50ZXJzdGl0aWFsLmN1bXVsYXRpdmVEdXJhdGlvbjtcbiAgICAgICAgbGV0IGVuZCA9IGFwcGVuZEluUGxhY2UgPyBzdGFydCArIGludGVyc3RpdGlhbER1cmF0aW9uIDogZXZlbnRTdGFydCArIHJlc3VtcHRpb25PZmZzZXQ7XG4gICAgICAgIGlmIChwcmVyb2xsIHx8ICFwb3N0cm9sbCAmJiBldmVudFN0YXJ0IDw9IDApIHtcbiAgICAgICAgICAvLyBwcmVyb2xsIG9yIGluLXByb2dyZXNzIG1pZHJvbGxcbiAgICAgICAgICBjb25zdCBpbnRlZ3JhdGVkU3RhcnQgPSBpbnRlZ3JhdGVkVGltZTtcbiAgICAgICAgICBpbnRlZ3JhdGVkVGltZSArPSB0aW1lbGluZUR1cmF0aW9uO1xuICAgICAgICAgIGludGVyc3RpdGlhbC50aW1lbGluZVN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgY29uc3QgcGxheW91dFN0YXJ0ID0gcGxheW91dER1cmF0aW9uO1xuICAgICAgICAgIHBsYXlvdXREdXJhdGlvbiArPSBpbnRlcnN0aXRpYWxEdXJhdGlvbjtcbiAgICAgICAgICBzY2hlZHVsZS5wdXNoKHtcbiAgICAgICAgICAgIGV2ZW50OiBpbnRlcnN0aXRpYWwsXG4gICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIGVuZCxcbiAgICAgICAgICAgIHBsYXlvdXQ6IHtcbiAgICAgICAgICAgICAgc3RhcnQ6IHBsYXlvdXRTdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBwbGF5b3V0RHVyYXRpb25cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbnRlZ3JhdGVkOiB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBpbnRlZ3JhdGVkU3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogaW50ZWdyYXRlZFRpbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudFN0YXJ0IDw9IHByaW1hcnlEdXJhdGlvbikge1xuICAgICAgICAgIGlmICghaW5TYW1lU3RhcnRUaW1lU2VxdWVuY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlZ21lbnREdXJhdGlvbiA9IGV2ZW50U3RhcnQgLSBwcmltYXJ5UG9zaXRpb247XG4gICAgICAgICAgICAvLyBEbyBub3Qgc2NoZWR1bGUgYSBwcmltYXJ5IHNlZ21lbnQgaWYgaW50ZXJzdGl0aWFscyBhcmUgYWJ1dHRpbmcgYnkgbGVzcyB0aGFuIEFCVVRUSU5HX1RIUkVTSE9MRF9TRUNPTkRTXG4gICAgICAgICAgICBpZiAoc2VnbWVudER1cmF0aW9uID4gQUJVVFRJTkdfVEhSRVNIT0xEX1NFQ09ORFMpIHtcbiAgICAgICAgICAgICAgLy8gcHJpbWFyeSBzZWdtZW50XG4gICAgICAgICAgICAgIGNvbnN0IHRpbWVsaW5lU3RhcnQgPSBwcmltYXJ5UG9zaXRpb247XG4gICAgICAgICAgICAgIGNvbnN0IF9pbnRlZ3JhdGVkU3RhcnQgPSBpbnRlZ3JhdGVkVGltZTtcbiAgICAgICAgICAgICAgaW50ZWdyYXRlZFRpbWUgKz0gc2VnbWVudER1cmF0aW9uO1xuICAgICAgICAgICAgICBjb25zdCBfcGxheW91dFN0YXJ0ID0gcGxheW91dER1cmF0aW9uO1xuICAgICAgICAgICAgICBwbGF5b3V0RHVyYXRpb24gKz0gc2VnbWVudER1cmF0aW9uO1xuICAgICAgICAgICAgICBjb25zdCBwcmltYXJ5U2VnbWVudCA9IHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c0V2ZW50OiBpbnRlcnN0aXRpYWxFdmVudHNbaSAtIDFdIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgbmV4dEV2ZW50OiBpbnRlcnN0aXRpYWwsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IHRpbWVsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kOiB0aW1lbGluZVN0YXJ0ICsgc2VnbWVudER1cmF0aW9uLFxuICAgICAgICAgICAgICAgIHBsYXlvdXQ6IHtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0OiBfcGxheW91dFN0YXJ0LFxuICAgICAgICAgICAgICAgICAgZW5kOiBwbGF5b3V0RHVyYXRpb25cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGludGVncmF0ZWQ6IHtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0OiBfaW50ZWdyYXRlZFN0YXJ0LFxuICAgICAgICAgICAgICAgICAgZW5kOiBpbnRlZ3JhdGVkVGltZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgc2NoZWR1bGUucHVzaChwcmltYXJ5U2VnbWVudCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlZ21lbnREdXJhdGlvbiA+IDAgJiYgcHJldmlvdXNFdmVudCkge1xuICAgICAgICAgICAgICAvLyBBZGQgcHJldmlvdXMgZXZlbnQgYHJlc3VtZVRpbWVgIChiYXNlZCBvbiBkdXJhdGlvbiBvciByZXN1bWVPZmZzZXQpIHNvIHRoYXQgaXQgZW5kcyBhbGlnbmVkIHdpdGggdGhpcyBvbmVcbiAgICAgICAgICAgICAgcHJldmlvdXNFdmVudC5jdW11bGF0aXZlRHVyYXRpb24gKz0gc2VnbWVudER1cmF0aW9uO1xuICAgICAgICAgICAgICBzY2hlZHVsZVtzY2hlZHVsZS5sZW5ndGggLSAxXS5lbmQgPSBldmVudFN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBtaWRyb2xsIC8gcG9zdHJvbGxcbiAgICAgICAgICBpZiAocG9zdHJvbGwpIHtcbiAgICAgICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbnRlcnN0aXRpYWwudGltZWxpbmVTdGFydCA9IHN0YXJ0O1xuICAgICAgICAgIGNvbnN0IGludGVncmF0ZWRTdGFydCA9IGludGVncmF0ZWRUaW1lO1xuICAgICAgICAgIGludGVncmF0ZWRUaW1lICs9IHRpbWVsaW5lRHVyYXRpb247XG4gICAgICAgICAgY29uc3QgcGxheW91dFN0YXJ0ID0gcGxheW91dER1cmF0aW9uO1xuICAgICAgICAgIHBsYXlvdXREdXJhdGlvbiArPSBpbnRlcnN0aXRpYWxEdXJhdGlvbjtcbiAgICAgICAgICBzY2hlZHVsZS5wdXNoKHtcbiAgICAgICAgICAgIGV2ZW50OiBpbnRlcnN0aXRpYWwsXG4gICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIGVuZCxcbiAgICAgICAgICAgIHBsYXlvdXQ6IHtcbiAgICAgICAgICAgICAgc3RhcnQ6IHBsYXlvdXRTdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBwbGF5b3V0RHVyYXRpb25cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbnRlZ3JhdGVkOiB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBpbnRlZ3JhdGVkU3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogaW50ZWdyYXRlZFRpbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJbnRlcnN0aXRpYWwgc3RhcnRzIGFmdGVyIGVuZCBvZiBwcmltYXJ5IFZPRCAtIG5vdCBpbmNsdWRlZCBpbiBzY2hlZHVsZVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bWVUaW1lID0gaW50ZXJzdGl0aWFsLnJlc3VtZVRpbWU7XG4gICAgICAgIGlmIChwb3N0cm9sbCB8fCByZXN1bWVUaW1lID4gcHJpbWFyeUR1cmF0aW9uKSB7XG4gICAgICAgICAgcHJpbWFyeVBvc2l0aW9uID0gcHJpbWFyeUR1cmF0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByaW1hcnlQb3NpdGlvbiA9IHJlc3VtZVRpbWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHByaW1hcnlQb3NpdGlvbiA8IHByaW1hcnlEdXJhdGlvbikge1xuICAgICAgICB2YXIgX3NjaGVkdWxlO1xuICAgICAgICAvLyBsYXN0IHByaW1hcnkgc2VnbWVudFxuICAgICAgICBjb25zdCB0aW1lbGluZVN0YXJ0ID0gcHJpbWFyeVBvc2l0aW9uO1xuICAgICAgICBjb25zdCBpbnRlZ3JhdGVkU3RhcnQgPSBpbnRlZ3JhdGVkVGltZTtcbiAgICAgICAgY29uc3Qgc2VnbWVudER1cmF0aW9uID0gcHJpbWFyeUR1cmF0aW9uIC0gcHJpbWFyeVBvc2l0aW9uO1xuICAgICAgICBpbnRlZ3JhdGVkVGltZSArPSBzZWdtZW50RHVyYXRpb247XG4gICAgICAgIGNvbnN0IHBsYXlvdXRTdGFydCA9IHBsYXlvdXREdXJhdGlvbjtcbiAgICAgICAgcGxheW91dER1cmF0aW9uICs9IHNlZ21lbnREdXJhdGlvbjtcbiAgICAgICAgc2NoZWR1bGUucHVzaCh7XG4gICAgICAgICAgcHJldmlvdXNFdmVudDogKChfc2NoZWR1bGUgPSBzY2hlZHVsZVtzY2hlZHVsZS5sZW5ndGggLSAxXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9zY2hlZHVsZS5ldmVudCkgfHwgbnVsbCxcbiAgICAgICAgICBuZXh0RXZlbnQ6IG51bGwsXG4gICAgICAgICAgc3RhcnQ6IHByaW1hcnlQb3NpdGlvbixcbiAgICAgICAgICBlbmQ6IHRpbWVsaW5lU3RhcnQgKyBzZWdtZW50RHVyYXRpb24sXG4gICAgICAgICAgcGxheW91dDoge1xuICAgICAgICAgICAgc3RhcnQ6IHBsYXlvdXRTdGFydCxcbiAgICAgICAgICAgIGVuZDogcGxheW91dER1cmF0aW9uXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbnRlZ3JhdGVkOiB7XG4gICAgICAgICAgICBzdGFydDogaW50ZWdyYXRlZFN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBpbnRlZ3JhdGVkVGltZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldER1cmF0aW9ucyhwcmltYXJ5RHVyYXRpb24sIHBsYXlvdXREdXJhdGlvbiwgaW50ZWdyYXRlZFRpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBubyBpbnRlcnN0aWFscyAtIHNjaGVkdWxlIGlzIG9uZSBwcmltYXJ5IHNlZ21lbnRcbiAgICAgIGNvbnN0IHN0YXJ0ID0gMDtcbiAgICAgIHNjaGVkdWxlLnB1c2goe1xuICAgICAgICBwcmV2aW91c0V2ZW50OiBudWxsLFxuICAgICAgICBuZXh0RXZlbnQ6IG51bGwsXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBlbmQ6IHByaW1hcnlEdXJhdGlvbixcbiAgICAgICAgcGxheW91dDoge1xuICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgIGVuZDogcHJpbWFyeUR1cmF0aW9uXG4gICAgICAgIH0sXG4gICAgICAgIGludGVncmF0ZWQ6IHtcbiAgICAgICAgICBzdGFydCxcbiAgICAgICAgICBlbmQ6IHByaW1hcnlEdXJhdGlvblxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2V0RHVyYXRpb25zKHByaW1hcnlEdXJhdGlvbiwgcHJpbWFyeUR1cmF0aW9uLCBwcmltYXJ5RHVyYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gc2NoZWR1bGU7XG4gIH1cbiAgc2V0RHVyYXRpb25zKHByaW1hcnksIHBsYXlvdXQsIGludGVncmF0ZWQpIHtcbiAgICB0aGlzLmR1cmF0aW9ucyA9IHtcbiAgICAgIHByaW1hcnksXG4gICAgICBwbGF5b3V0LFxuICAgICAgaW50ZWdyYXRlZFxuICAgIH07XG4gIH1cbiAgcmVzb2x2ZU9mZnNldHMoaW50ZXJzdGl0aWFsRXZlbnRzLCBtZWRpYVNlbGVjdGlvbikge1xuICAgIGNvbnN0IGRldGFpbHMgPSBtZWRpYVNlbGVjdGlvbi5tYWluLmRldGFpbHM7XG4gICAgY29uc3QgcHJpbWFyeUR1cmF0aW9uID0gZGV0YWlscy5saXZlID8gSW5maW5pdHkgOiBkZXRhaWxzLmVkZ2U7XG5cbiAgICAvLyBGaXJzdCByZXNvbHZlIGN1bXVsYXRpdmUgcmVzdW1wdGlvbiBvZmZzZXRzIGZvciBJbnRlcnN0aXRpYWxzIHRoYXQgc3RhcnQgYXQgdGhlIHNhbWUgRGF0ZVRpbWVcbiAgICBsZXQgY3VtdWxhdGl2ZUR1cmF0aW9uID0gMDtcbiAgICBsZXQgbGFzdFNjaGVkdWxlZFN0YXJ0ID0gLTE7XG4gICAgaW50ZXJzdGl0aWFsRXZlbnRzLmZvckVhY2goKGludGVyc3RpdGlhbCwgaSkgPT4ge1xuICAgICAgY29uc3QgcHJlcm9sbCA9IGludGVyc3RpdGlhbC5jdWUucHJlO1xuICAgICAgY29uc3QgcG9zdHJvbGwgPSBpbnRlcnN0aXRpYWwuY3VlLnBvc3Q7XG4gICAgICBjb25zdCBldmVudFN0YXJ0ID0gcHJlcm9sbCA/IDAgOiBwb3N0cm9sbCA/IHByaW1hcnlEdXJhdGlvbiA6IGludGVyc3RpdGlhbC5zdGFydFRpbWU7XG4gICAgICB0aGlzLnVwZGF0ZUFzc2V0RHVyYXRpb25zKGludGVyc3RpdGlhbCk7XG5cbiAgICAgIC8vIFgtUkVTVU1FLU9GRlNFVCB2YWx1ZXMgb2YgaW50ZXJzdGl0aWFscyBzY2hlZHVsZWQgYXQgdGhlIHNhbWUgdGltZSBhcmUgY3VtdWxhdGl2ZVxuICAgICAgY29uc3QgaW5TYW1lU3RhcnRUaW1lU2VxdWVuY2UgPSBsYXN0U2NoZWR1bGVkU3RhcnQgPT09IGV2ZW50U3RhcnQ7XG4gICAgICBpZiAoaW5TYW1lU3RhcnRUaW1lU2VxdWVuY2UpIHtcbiAgICAgICAgaW50ZXJzdGl0aWFsLmN1bXVsYXRpdmVEdXJhdGlvbiA9IGN1bXVsYXRpdmVEdXJhdGlvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1bXVsYXRpdmVEdXJhdGlvbiA9IDA7XG4gICAgICAgIGxhc3RTY2hlZHVsZWRTdGFydCA9IGV2ZW50U3RhcnQ7XG4gICAgICB9XG4gICAgICBpZiAoIXBvc3Ryb2xsICYmIGludGVyc3RpdGlhbC5zbmFwT3B0aW9ucy5pbikge1xuICAgICAgICAvLyBGSVhNRTogSW5jbHVkZSBhdWRpbyBwbGF5bGlzdCBpbiBzbmFwcGluZ1xuICAgICAgICBpbnRlcnN0aXRpYWwucmVzdW1lQW5jaG9yID0gZmluZEZyYWdtZW50QnlQVFMobnVsbCwgZGV0YWlscy5mcmFnbWVudHMsIGludGVyc3RpdGlhbC5zdGFydE9mZnNldCArIGludGVyc3RpdGlhbC5yZXN1bXB0aW9uT2Zmc2V0LCAwLCAwKSB8fCB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICAvLyBDaGVjayBpZiBwcmltYXJ5IGZyYWdtZW50cyBhbGlnbiB3aXRoIHJlc3VtcHRpb24gb2Zmc2V0IGFuZCBkaXNhYmxlIGFwcGVuZEluUGxhY2UgaWYgdGhleSBkbyBub3RcbiAgICAgIGlmIChpbnRlcnN0aXRpYWwuYXBwZW5kSW5QbGFjZSAmJiAhaW50ZXJzdGl0aWFsLmFwcGVuZEluUGxhY2VTdGFydGVkKSB7XG4gICAgICAgIGNvbnN0IGFsaWduZWRTZWdtZW50U3RhcnQgPSB0aGlzLnByaW1hcnlDYW5SZXN1bWVJblBsYWNlQXQoaW50ZXJzdGl0aWFsLCBtZWRpYVNlbGVjdGlvbik7XG4gICAgICAgIGlmICghYWxpZ25lZFNlZ21lbnRTdGFydCkge1xuICAgICAgICAgIGludGVyc3RpdGlhbC5hcHBlbmRJblBsYWNlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghaW50ZXJzdGl0aWFsLmFwcGVuZEluUGxhY2UgJiYgaSArIDEgPCBpbnRlcnN0aXRpYWxFdmVudHMubGVuZ3RoKSB7XG4gICAgICAgIC8vIGFidXR0aW5nIEludGVyc3RpdGlhbHMgbXVzdCB1c2UgdGhlIHNhbWUgTWVkaWFTb3VyY2Ugc3RyYXRlZ3ksIHRoaXMgYXBwbGllcyB0byBhbGwgd2hldGhlciBvciBub3QgdGhleSBhcmUgYmFjayB0byBiYWNrOlxuICAgICAgICBjb25zdCB0aW1lQmV0d2VlbiA9IGludGVyc3RpdGlhbEV2ZW50c1tpICsgMV0uc3RhcnRUaW1lIC0gaW50ZXJzdGl0aWFsRXZlbnRzW2ldLnJlc3VtZVRpbWU7XG4gICAgICAgIGlmICh0aW1lQmV0d2VlbiA8IEFCVVRUSU5HX1RIUkVTSE9MRF9TRUNPTkRTKSB7XG4gICAgICAgICAgaW50ZXJzdGl0aWFsRXZlbnRzW2kgKyAxXS5hcHBlbmRJblBsYWNlID0gZmFsc2U7XG4gICAgICAgICAgaWYgKGludGVyc3RpdGlhbEV2ZW50c1tpICsgMV0uYXBwZW5kSW5QbGFjZSkge1xuICAgICAgICAgICAgdGhpcy53YXJuKGBDb3VsZCBub3QgY2hhbmdlIGFwcGVuZCBzdHJhdGVneSBmb3IgYWJ1dHRpbmcgZXZlbnQgJHtpbnRlcnN0aXRpYWx9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBVcGRhdGUgY3VtdWxhdGl2ZUR1cmF0aW9uIGZvciBuZXh0IGFidXR0aW5nIGludGVyc3RpdGlhbCB3aXRoIHRoZSBzYW1lIHN0YXJ0IGRhdGVcbiAgICAgIGNvbnN0IHJlc3VtZU9mZnNldCA9IGlzRmluaXRlTnVtYmVyKGludGVyc3RpdGlhbC5yZXN1bWVPZmZzZXQpID8gaW50ZXJzdGl0aWFsLnJlc3VtZU9mZnNldCA6IGludGVyc3RpdGlhbC5kdXJhdGlvbjtcbiAgICAgIGN1bXVsYXRpdmVEdXJhdGlvbiArPSByZXN1bWVPZmZzZXQ7XG4gICAgfSk7XG4gIH1cbiAgcHJpbWFyeUNhblJlc3VtZUluUGxhY2VBdChpbnRlcnN0aXRpYWwsIG1lZGlhU2VsZWN0aW9uKSB7XG4gICAgY29uc3QgcmVzdW1lVGltZSA9IGludGVyc3RpdGlhbC5yZXN1bWVUaW1lO1xuICAgIGNvbnN0IHJlc3VtZXNJblBsYWNlQXQgPSBpbnRlcnN0aXRpYWwuc3RhcnRUaW1lICsgaW50ZXJzdGl0aWFsLnJlc3VtcHRpb25PZmZzZXQ7XG4gICAgaWYgKE1hdGguYWJzKHJlc3VtZVRpbWUgLSByZXN1bWVzSW5QbGFjZUF0KSA+IEFMSUdORURfRU5EX1RIUkVTSE9MRF9TRUNPTkRTKSB7XG4gICAgICB0aGlzLmxvZyhgXCIke2ludGVyc3RpdGlhbC5pZGVudGlmaWVyfVwiIHJlc3VtcHRpb24gJHtyZXN1bWVUaW1lfSBub3QgYWxpZ25lZCB3aXRoIGVzdGltYXRlZCB0aW1lbGluZSBlbmQgJHtyZXN1bWVzSW5QbGFjZUF0fWApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIW1lZGlhU2VsZWN0aW9uKSB7XG4gICAgICB0aGlzLmxvZyhgXCIke2ludGVyc3RpdGlhbC5pZGVudGlmaWVyfVwiIHJlc3VtcHRpb24gJHtyZXN1bWVUaW1lfSBjYW4gbm90IGJlIGFsaWduZWQgd2l0aCBtZWRpYSAobm9uZSBzZWxlY3RlZClgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcGxheWxpc3RzID0gT2JqZWN0LmtleXMobWVkaWFTZWxlY3Rpb24pO1xuICAgIHJldHVybiAhcGxheWxpc3RzLnNvbWUocGxheWxpc3RUeXBlID0+IHtcbiAgICAgIGNvbnN0IGRldGFpbHMgPSBtZWRpYVNlbGVjdGlvbltwbGF5bGlzdFR5cGVdLmRldGFpbHM7XG4gICAgICBjb25zdCBwbGF5bGlzdEVuZCA9IGRldGFpbHMuZWRnZTtcbiAgICAgIGlmIChyZXN1bWVUaW1lID49IHBsYXlsaXN0RW5kKSB7XG4gICAgICAgIC8vIExpdmUgcGxheWJhY2sgLSByZXN1bXB0aW9uIHNlZ21lbnRzIGFyZSBub3QgeWV0IGF2YWlsYWJsZVxuICAgICAgICB0aGlzLmxvZyhgXCIke2ludGVyc3RpdGlhbC5pZGVudGlmaWVyfVwiIHJlc3VtcHRpb24gJHtyZXN1bWVUaW1lfSBwYXN0ICR7cGxheWxpc3RUeXBlfSBwbGF5bGlzdCBlbmQgJHtwbGF5bGlzdEVuZH1gKTtcbiAgICAgICAgLy8gQXNzdW1lIGFsaWdubWVudCBpcyBwb3NzaWJsZSAob3IgcmVzZXQgY2FuIHRha2UgcGxhY2UpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXJ0RnJhZ21lbnQgPSBmaW5kRnJhZ21lbnRCeVBUUyhudWxsLCBkZXRhaWxzLmZyYWdtZW50cywgcmVzdW1lVGltZSk7XG4gICAgICBpZiAoIXN0YXJ0RnJhZ21lbnQpIHtcbiAgICAgICAgdGhpcy5sb2coYFwiJHtpbnRlcnN0aXRpYWwuaWRlbnRpZmllcn1cIiByZXN1bXB0aW9uICR7cmVzdW1lVGltZX0gZG9lcyBub3QgYWxpZ24gd2l0aCBhbnkgZnJhZ21lbnRzIGluICR7cGxheWxpc3RUeXBlfSBwbGF5bGlzdCAoJHtkZXRhaWxzLmZyYWdTdGFydH0tJHtkZXRhaWxzLmZyYWdtZW50RW5kfSlgKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCBhbGxvd2FuY2UgPSBwbGF5bGlzdFR5cGUgPT09ICdhdWRpbycgPyAwLjE3NSA6IDA7XG4gICAgICBjb25zdCBhbGlnbmVkV2l0aFNlZ21lbnQgPSBNYXRoLmFicyhzdGFydEZyYWdtZW50LnN0YXJ0IC0gcmVzdW1lVGltZSkgPCBBTElHTkVEX0VORF9USFJFU0hPTERfU0VDT05EUyArIGFsbG93YW5jZSB8fCBNYXRoLmFicyhzdGFydEZyYWdtZW50LmVuZCAtIHJlc3VtZVRpbWUpIDwgQUxJR05FRF9FTkRfVEhSRVNIT0xEX1NFQ09ORFMgKyBhbGxvd2FuY2U7XG4gICAgICBpZiAoIWFsaWduZWRXaXRoU2VnbWVudCkge1xuICAgICAgICB0aGlzLmxvZyhgXCIke2ludGVyc3RpdGlhbC5pZGVudGlmaWVyfVwiIHJlc3VtcHRpb24gJHtyZXN1bWVUaW1lfSBub3QgYWxpZ25lZCB3aXRoICR7cGxheWxpc3RUeXBlfSBmcmFnbWVudCBib3VuZHMgKCR7c3RhcnRGcmFnbWVudC5zdGFydH0tJHtzdGFydEZyYWdtZW50LmVuZH0gc246ICR7c3RhcnRGcmFnbWVudC5zbn0gY2M6ICR7c3RhcnRGcmFnbWVudC5jY30pYCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZUFzc2V0RHVyYXRpb25zKGludGVyc3RpdGlhbCkge1xuICAgIGlmICghaW50ZXJzdGl0aWFsLmFzc2V0TGlzdExvYWRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBldmVudFN0YXJ0ID0gaW50ZXJzdGl0aWFsLnRpbWVsaW5lU3RhcnQ7XG4gICAgbGV0IHN1bUR1cmF0aW9uID0gMDtcbiAgICBsZXQgaGFzVW5rbm93bkR1cmF0aW9uID0gZmFsc2U7XG4gICAgbGV0IGhhc0Vycm9ycyA9IGZhbHNlO1xuICAgIGludGVyc3RpdGlhbC5hc3NldExpc3QuZm9yRWFjaCgoYXNzZXQsIGkpID0+IHtcbiAgICAgIGNvbnN0IHRpbWVsaW5lU3RhcnQgPSBldmVudFN0YXJ0ICsgc3VtRHVyYXRpb247XG4gICAgICBhc3NldC5zdGFydE9mZnNldCA9IHN1bUR1cmF0aW9uO1xuICAgICAgYXNzZXQudGltZWxpbmVTdGFydCA9IHRpbWVsaW5lU3RhcnQ7XG4gICAgICBoYXNVbmtub3duRHVyYXRpb24gfHwgKGhhc1Vua25vd25EdXJhdGlvbiA9IGFzc2V0LmR1cmF0aW9uID09PSBudWxsKTtcbiAgICAgIGhhc0Vycm9ycyB8fCAoaGFzRXJyb3JzID0gISFhc3NldC5lcnJvcik7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IGFzc2V0LmVycm9yID8gMCA6IGFzc2V0LmR1cmF0aW9uIHx8IDA7XG4gICAgICBzdW1EdXJhdGlvbiArPSBkdXJhdGlvbjtcbiAgICB9KTtcbiAgICAvLyBVc2UgdGhlIHN1bSBvZiBrbm93biBkdXJhdGlvbnMgd2hlbiBpdCBpcyBncmVhdGVyIHRoYW4gdGhlIHN0YXRlZCBkdXJhdGlvblxuICAgIGlmIChoYXNVbmtub3duRHVyYXRpb24gJiYgIWhhc0Vycm9ycykge1xuICAgICAgaW50ZXJzdGl0aWFsLmR1cmF0aW9uID0gTWF0aC5tYXgoc3VtRHVyYXRpb24sIGludGVyc3RpdGlhbC5kdXJhdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludGVyc3RpdGlhbC5kdXJhdGlvbiA9IHN1bUR1cmF0aW9uO1xuICAgIH1cbiAgfVxuICByZW1vdmVFdmVudChpbnRlcnN0aXRpYWwpIHtcbiAgICBpbnRlcnN0aXRpYWwucmVzZXQoKTtcbiAgICBkZWxldGUgdGhpcy5ldmVudE1hcFtpbnRlcnN0aXRpYWwuaWRlbnRpZmllcl07XG4gIH1cbn1cbmZ1bmN0aW9uIHNlZ21lbnRUb1N0cmluZyhzZWdtZW50KSB7XG4gIHJldHVybiBgWyR7c2VnbWVudC5ldmVudCA/ICdcIicgKyBzZWdtZW50LmV2ZW50LmlkZW50aWZpZXIgKyAnXCInIDogJ3ByaW1hcnknfTogJHtzZWdtZW50LnN0YXJ0LnRvRml4ZWQoMil9LSR7c2VnbWVudC5lbmQudG9GaXhlZCgyKX1dYDtcbn1cblxuY2xhc3MgQXNzZXRMaXN0TG9hZGVyIHtcbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSBudWxsO1xuICB9XG4gIGxvYWRBc3NldExpc3QoaW50ZXJzdGl0aWFsLCBobHNTdGFydE9mZnNldCkge1xuICAgIGNvbnN0IGFzc2V0TGlzdFVybCA9IGludGVyc3RpdGlhbC5hc3NldExpc3RVcmw7XG4gICAgbGV0IHVybDtcbiAgICB0cnkge1xuICAgICAgdXJsID0gZ2V0SW50ZXJzdGl0aWFsVXJsKGFzc2V0TGlzdFVybCwgdGhpcy5obHMuc2Vzc2lvbklkLCBpbnRlcnN0aXRpYWwuYmFzZVVybCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IGVycm9yRGF0YSA9IHRoaXMuYXNzaWduQXNzZXRMaXN0RXJyb3IoaW50ZXJzdGl0aWFsLCBFcnJvckRldGFpbHMuQVNTRVRfTElTVF9MT0FEX0VSUk9SLCBlcnJvciwgYXNzZXRMaXN0VXJsKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCBlcnJvckRhdGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaGxzU3RhcnRPZmZzZXQgJiYgdXJsLnByb3RvY29sICE9PSAnZGF0YTonKSB7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnX0hMU19zdGFydF9vZmZzZXQnLCAnJyArIGhsc1N0YXJ0T2Zmc2V0KTtcbiAgICB9XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuICAgIGNvbnN0IExvYWRlciA9IGNvbmZpZy5sb2FkZXI7XG4gICAgY29uc3QgbG9hZGVyID0gbmV3IExvYWRlcihjb25maWcpO1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcbiAgICAgIHVybDogdXJsLmhyZWZcbiAgICB9O1xuICAgIGNvbnN0IGxvYWRQb2xpY3kgPSBjb25maWcuaW50ZXJzdGl0aWFsQXNzZXRMaXN0TG9hZFBvbGljeS5kZWZhdWx0O1xuICAgIGNvbnN0IGxvYWRlckNvbmZpZyA9IHtcbiAgICAgIGxvYWRQb2xpY3ksXG4gICAgICB0aW1lb3V0OiBsb2FkUG9saWN5Lm1heExvYWRUaW1lTXMsXG4gICAgICBtYXhSZXRyeTogMCxcbiAgICAgIHJldHJ5RGVsYXk6IDAsXG4gICAgICBtYXhSZXRyeURlbGF5OiAwXG4gICAgfTtcbiAgICBjb25zdCBjYWxsYmFja3MgPSB7XG4gICAgICBvblN1Y2Nlc3M6IChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgIGNvbnN0IGFzc2V0TGlzdFJlc3BvbnNlID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgY29uc3QgYXNzZXRzID0gYXNzZXRMaXN0UmVzcG9uc2UgPT0gbnVsbCA/IHZvaWQgMCA6IGFzc2V0TGlzdFJlc3BvbnNlLkFTU0VUUztcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFzc2V0cykpIHtcbiAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSB0aGlzLmFzc2lnbkFzc2V0TGlzdEVycm9yKGludGVyc3RpdGlhbCwgRXJyb3JEZXRhaWxzLkFTU0VUX0xJU1RfUEFSU0lOR19FUlJPUiwgbmV3IEVycm9yKGBJbnZhbGlkIGludGVyc3RpdGlhbCBhc3NldCBsaXN0YCksIGNvbnRleHQudXJsLCBzdGF0cywgbmV0d29ya0RldGFpbHMpO1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCBlcnJvckRhdGEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpbnRlcnN0aXRpYWwuYXNzZXRMaXN0UmVzcG9uc2UgPSBhc3NldExpc3RSZXNwb25zZTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQVNTRVRfTElTVF9MT0FERUQsIHtcbiAgICAgICAgICBldmVudDogaW50ZXJzdGl0aWFsLFxuICAgICAgICAgIGFzc2V0TGlzdFJlc3BvbnNlLFxuICAgICAgICAgIG5ldHdvcmtEZXRhaWxzXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIG9uRXJyb3I6IChlcnJvciwgY29udGV4dCwgbmV0d29ya0RldGFpbHMsIHN0YXRzKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IHRoaXMuYXNzaWduQXNzZXRMaXN0RXJyb3IoaW50ZXJzdGl0aWFsLCBFcnJvckRldGFpbHMuQVNTRVRfTElTVF9MT0FEX0VSUk9SLCBuZXcgRXJyb3IoYEVycm9yIGxvYWRpbmcgWC1BU1NFVC1MSVNUOiBIVFRQIHN0YXR1cyAke2Vycm9yLmNvZGV9ICR7ZXJyb3IudGV4dH0gKCR7Y29udGV4dC51cmx9KWApLCBjb250ZXh0LnVybCwgc3RhdHMsIG5ldHdvcmtEZXRhaWxzKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIGVycm9yRGF0YSk7XG4gICAgICB9LFxuICAgICAgb25UaW1lb3V0OiAoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IHRoaXMuYXNzaWduQXNzZXRMaXN0RXJyb3IoaW50ZXJzdGl0aWFsLCBFcnJvckRldGFpbHMuQVNTRVRfTElTVF9MT0FEX1RJTUVPVVQsIG5ldyBFcnJvcihgVGltZW91dCBsb2FkaW5nIFgtQVNTRVQtTElTVCAoJHtjb250ZXh0LnVybH0pYCksIGNvbnRleHQudXJsLCBzdGF0cywgbmV0d29ya0RldGFpbHMpO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwgZXJyb3JEYXRhKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGxvYWRlci5sb2FkKGNvbnRleHQsIGxvYWRlckNvbmZpZywgY2FsbGJhY2tzKTtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5BU1NFVF9MSVNUX0xPQURJTkcsIHtcbiAgICAgIGV2ZW50OiBpbnRlcnN0aXRpYWxcbiAgICB9KTtcbiAgICByZXR1cm4gbG9hZGVyO1xuICB9XG4gIGFzc2lnbkFzc2V0TGlzdEVycm9yKGludGVyc3RpdGlhbCwgZGV0YWlscywgZXJyb3IsIHVybCwgc3RhdHMsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgaW50ZXJzdGl0aWFsLmVycm9yID0gZXJyb3I7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgIGRldGFpbHMsXG4gICAgICBmYXRhbDogZmFsc2UsXG4gICAgICBpbnRlcnN0aXRpYWwsXG4gICAgICB1cmwsXG4gICAgICBlcnJvcixcbiAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgc3RhdHNcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHBsYXlXaXRoQ2F0Y2gobWVkaWEpIHtcbiAgbWVkaWEgPT0gbnVsbCA/IHZvaWQgMCA6IG1lZGlhLnBsYXkoKS5jYXRjaCgoKSA9PiB7XG4gICAgLyogbm8tb3AgKi9cbiAgfSk7XG59XG5jbGFzcyBJbnRlcnN0aXRpYWxzQ29udHJvbGxlciBleHRlbmRzIExvZ2dlciB7XG4gIGNvbnN0cnVjdG9yKGhscywgSGxzUGxheWVyQ2xhc3MpIHtcbiAgICBzdXBlcignaW50ZXJzdGl0aWFscycsIGhscy5sb2dnZXIpO1xuICAgIHRoaXMuSGxzUGxheWVyQ2xhc3MgPSB2b2lkIDA7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5hc3NldExpc3RMb2FkZXIgPSB2b2lkIDA7XG4gICAgLy8gTGFzdCB1cGRhdGVkIExldmVsRGV0YWlsc1xuICAgIHRoaXMubWVkaWFTZWxlY3Rpb24gPSBudWxsO1xuICAgIHRoaXMuYWx0U2VsZWN0aW9uID0gbnVsbDtcbiAgICAvLyBNZWRpYSBhbmQgTWVkaWFTb3VyY2UvU291cmNlQnVmZmVyc1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMuZGV0YWNoZWREYXRhID0gbnVsbDtcbiAgICB0aGlzLnJlcXVpcmVkVHJhY2tzID0gbnVsbDtcbiAgICAvLyBQdWJsaWMgSW50ZXJmYWNlIGZvciBJbnRlcnN0aXRpYWwgcGxheWJhY2sgc3RhdGUgYW5kIGNvbnRyb2xcbiAgICB0aGlzLm1hbmFnZXIgPSBudWxsO1xuICAgIC8vIEludGVyc3RpdGlhbCBBc3NldCBQbGF5ZXJzXG4gICAgdGhpcy5wbGF5ZXJRdWV1ZSA9IFtdO1xuICAgIC8vIFRpbWVsaW5lIHBvc2l0aW9uIHRyYWNraW5nXG4gICAgdGhpcy5idWZmZXJlZFBvcyA9IC0xO1xuICAgIHRoaXMudGltZWxpbmVQb3MgPSAtMTtcbiAgICAvLyBTY2hlZHVsZVxuICAgIHRoaXMuc2NoZWR1bGUgPSB2b2lkIDA7XG4gICAgLy8gU2NoZWR1bGUgcGxheWJhY2sgYW5kIGJ1ZmZlcmluZyBzdGF0ZVxuICAgIHRoaXMucGxheWluZ0l0ZW0gPSBudWxsO1xuICAgIHRoaXMuYnVmZmVyaW5nSXRlbSA9IG51bGw7XG4gICAgdGhpcy53YWl0aW5nSXRlbSA9IG51bGw7XG4gICAgdGhpcy5lbmRlZEl0ZW0gPSBudWxsO1xuICAgIHRoaXMucGxheWluZ0Fzc2V0ID0gbnVsbDtcbiAgICB0aGlzLmVuZGVkQXNzZXQgPSBudWxsO1xuICAgIHRoaXMuYnVmZmVyaW5nQXNzZXQgPSBudWxsO1xuICAgIHRoaXMuc2hvdWxkUGxheSA9IGZhbHNlO1xuICAgIHRoaXMub25QbGF5ID0gKCkgPT4ge1xuICAgICAgdGhpcy5zaG91bGRQbGF5ID0gdHJ1ZTtcbiAgICB9O1xuICAgIHRoaXMub25QYXVzZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuc2hvdWxkUGxheSA9IGZhbHNlO1xuICAgIH07XG4gICAgdGhpcy5vblNlZWtpbmcgPSAoKSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50VGltZSA9IHRoaXMuY3VycmVudFRpbWU7XG4gICAgICBpZiAoY3VycmVudFRpbWUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLnBsYXliYWNrRGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZGlmZiA9IGN1cnJlbnRUaW1lIC0gdGhpcy50aW1lbGluZVBvcztcbiAgICAgIGNvbnN0IHJvdW5kaW5nRXJyb3IgPSBNYXRoLmFicyhkaWZmKSA8IDEgLyA3MDU2MDAwMDA7IC8vIG9uZSBmbGlja1xuICAgICAgaWYgKHJvdW5kaW5nRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgYmFja3dhcmRTZWVrID0gZGlmZiA8PSAtMC4wMTtcbiAgICAgIHRoaXMudGltZWxpbmVQb3MgPSBjdXJyZW50VGltZTtcbiAgICAgIHRoaXMuYnVmZmVyZWRQb3MgPSBjdXJyZW50VGltZTtcblxuICAgICAgLy8gQ2hlY2sgaWYgc2Vla2luZyBvdXQgb2YgYW4gaXRlbVxuICAgICAgY29uc3QgcGxheWluZ0l0ZW0gPSB0aGlzLnBsYXlpbmdJdGVtO1xuICAgICAgaWYgKCFwbGF5aW5nSXRlbSkge1xuICAgICAgICB0aGlzLmNoZWNrQnVmZmVyKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChiYWNrd2FyZFNlZWspIHtcbiAgICAgICAgY29uc3QgcmVzZXRDb3VudCA9IHRoaXMuc2NoZWR1bGUucmVzZXRFcnJvcnNJblJhbmdlKGN1cnJlbnRUaW1lLCBjdXJyZW50VGltZSAtIGRpZmYpO1xuICAgICAgICBpZiAocmVzZXRDb3VudCkge1xuICAgICAgICAgIHRoaXMudXBkYXRlU2NoZWR1bGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5jaGVja0J1ZmZlcigpO1xuICAgICAgaWYgKGJhY2t3YXJkU2VlayAmJiBjdXJyZW50VGltZSA8IHBsYXlpbmdJdGVtLnN0YXJ0IHx8IGN1cnJlbnRUaW1lID49IHBsYXlpbmdJdGVtLmVuZCkge1xuICAgICAgICB2YXIgX3RoaXMkbWVkaWE7XG4gICAgICAgIGNvbnN0IHNjaGVkdWxlSW5kZXggPSB0aGlzLnNjaGVkdWxlLmZpbmRJdGVtSW5kZXhBdFRpbWUodGhpcy50aW1lbGluZVBvcyk7XG4gICAgICAgIGlmICghdGhpcy5pc0ludGVyc3RpdGlhbChwbGF5aW5nSXRlbSkgJiYgKF90aGlzJG1lZGlhID0gdGhpcy5tZWRpYSkgIT0gbnVsbCAmJiBfdGhpcyRtZWRpYS5wYXVzZWQpIHtcbiAgICAgICAgICB0aGlzLnNob3VsZFBsYXkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWJhY2t3YXJkU2Vlaykge1xuICAgICAgICAgIC8vIGNoZWNrIGlmIGFuIEludGVyc3RpdGlhbCBiZXR3ZWVuIHRoZSBjdXJyZW50IGl0ZW0gYW5kIHRhcmdldCBpdGVtIGhhcyBhbiBYLVJFU1RSSUNUIEpVTVAgcmVzdHJpY3Rpb25cbiAgICAgICAgICBjb25zdCBwbGF5aW5nSW5kZXggPSB0aGlzLmZpbmRJdGVtSW5kZXgocGxheWluZ0l0ZW0pO1xuICAgICAgICAgIGlmIChzY2hlZHVsZUluZGV4ID4gcGxheWluZ0luZGV4KSB7XG4gICAgICAgICAgICBjb25zdCBqdW1wSW5kZXggPSB0aGlzLnNjaGVkdWxlLmZpbmRKdW1wUmVzdHJpY3RlZEluZGV4KHBsYXlpbmdJbmRleCArIDEsIHNjaGVkdWxlSW5kZXgpO1xuICAgICAgICAgICAgaWYgKGp1bXBJbmRleCA+IHBsYXlpbmdJbmRleCkge1xuICAgICAgICAgICAgICB0aGlzLnNldFNjaGVkdWxlUG9zaXRpb24oanVtcEluZGV4KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFNjaGVkdWxlUG9zaXRpb24oc2NoZWR1bGVJbmRleCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIGlmIHNlZWtpbmcgb3V0IG9mIGFuIGFzc2V0IChhc3N1bWVzIHNhbWUgaXRlbSBmb2xsb3dpbmcgYWJvdmUgY2hlY2spXG4gICAgICBjb25zdCBwbGF5aW5nQXNzZXQgPSB0aGlzLnBsYXlpbmdBc3NldDtcbiAgICAgIGlmICghcGxheWluZ0Fzc2V0KSB7XG4gICAgICAgIC8vIHJlc3RhcnQgSW50ZXJzdGl0aWFsIGF0IGVuZFxuICAgICAgICBpZiAodGhpcy5wbGF5aW5nTGFzdEl0ZW0gJiYgdGhpcy5pc0ludGVyc3RpdGlhbChwbGF5aW5nSXRlbSkpIHtcbiAgICAgICAgICBjb25zdCByZXN0YXJ0QXNzZXQgPSBwbGF5aW5nSXRlbS5ldmVudC5hc3NldExpc3RbMF07XG4gICAgICAgICAgaWYgKHJlc3RhcnRBc3NldCkge1xuICAgICAgICAgICAgdGhpcy5lbmRlZEl0ZW0gPSB0aGlzLnBsYXlpbmdJdGVtO1xuICAgICAgICAgICAgdGhpcy5wbGF5aW5nSXRlbSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnNldFNjaGVkdWxlVG9Bc3NldEF0VGltZShjdXJyZW50VGltZSwgcmVzdGFydEFzc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhcnQgPSBwbGF5aW5nQXNzZXQudGltZWxpbmVTdGFydDtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gcGxheWluZ0Fzc2V0LmR1cmF0aW9uIHx8IDA7XG4gICAgICBpZiAoYmFja3dhcmRTZWVrICYmIGN1cnJlbnRUaW1lIDwgc3RhcnQgfHwgY3VycmVudFRpbWUgPj0gc3RhcnQgKyBkdXJhdGlvbikge1xuICAgICAgICB0aGlzLnNldFNjaGVkdWxlVG9Bc3NldEF0VGltZShjdXJyZW50VGltZSwgcGxheWluZ0Fzc2V0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMub25UaW1ldXBkYXRlID0gKCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudFRpbWUgPSB0aGlzLmN1cnJlbnRUaW1lO1xuICAgICAgaWYgKGN1cnJlbnRUaW1lID09PSB1bmRlZmluZWQgfHwgdGhpcy5wbGF5YmFja0Rpc2FibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gT25seSBhbGxvdyB0aW1ldXBkYXRlIHRvIGFkdmFuY2UgcHJpbWFyeSBwb3NpdGlvbiwgc2Vla2luZyBpcyB1c2VkIGZvciBqdW1waW5nIGJhY2tcbiAgICAgIC8vIHRoaXMgcHJldmVudHMgcHJpbWFyeVBvcyBmcm9tIGJlaW5nIHJlc2V0IHRvIDAgYWZ0ZXIgcmUtYXR0YWNoXG4gICAgICBpZiAoY3VycmVudFRpbWUgPiB0aGlzLnRpbWVsaW5lUG9zKSB7XG4gICAgICAgIHRoaXMudGltZWxpbmVQb3MgPSBjdXJyZW50VGltZTtcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lID4gdGhpcy5idWZmZXJlZFBvcykge1xuICAgICAgICAgIHRoaXMuY2hlY2tCdWZmZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiBwbGF5YmFjayBoYXMgZW50ZXJlZCB0aGUgbmV4dCBpdGVtXG4gICAgICBjb25zdCBwbGF5aW5nSXRlbSA9IHRoaXMucGxheWluZ0l0ZW07XG4gICAgICBpZiAoIXBsYXlpbmdJdGVtIHx8IHRoaXMucGxheWluZ0xhc3RJdGVtKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50VGltZSA+PSBwbGF5aW5nSXRlbS5lbmQpIHtcbiAgICAgICAgdGhpcy50aW1lbGluZVBvcyA9IHBsYXlpbmdJdGVtLmVuZDtcbiAgICAgICAgY29uc3QgcGxheWluZ0luZGV4ID0gdGhpcy5maW5kSXRlbUluZGV4KHBsYXlpbmdJdGVtKTtcbiAgICAgICAgdGhpcy5zZXRTY2hlZHVsZVBvc2l0aW9uKHBsYXlpbmdJbmRleCArIDEpO1xuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgaWYgcGxheWJhY2sgaGFzIGVudGVyZWQgdGhlIG5leHQgYXNzZXRcbiAgICAgIGNvbnN0IHBsYXlpbmdBc3NldCA9IHRoaXMucGxheWluZ0Fzc2V0O1xuICAgICAgaWYgKCFwbGF5aW5nQXNzZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZW5kID0gcGxheWluZ0Fzc2V0LnRpbWVsaW5lU3RhcnQgKyAocGxheWluZ0Fzc2V0LmR1cmF0aW9uIHx8IDApO1xuICAgICAgaWYgKGN1cnJlbnRUaW1lID49IGVuZCkge1xuICAgICAgICB0aGlzLnNldFNjaGVkdWxlVG9Bc3NldEF0VGltZShjdXJyZW50VGltZSwgcGxheWluZ0Fzc2V0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIC8vIFNjaGVkdWxlIHVwZGF0ZSBjYWxsYmFja1xuICAgIHRoaXMub25TY2hlZHVsZVVwZGF0ZSA9IChyZW1vdmVkSW50ZXJzdGl0aWFscywgcHJldmlvdXNJdGVtcykgPT4ge1xuICAgICAgY29uc3Qgc2NoZWR1bGUgPSB0aGlzLnNjaGVkdWxlO1xuICAgICAgY29uc3QgcGxheWluZ0l0ZW0gPSB0aGlzLnBsYXlpbmdJdGVtO1xuICAgICAgY29uc3QgaW50ZXJzdGl0aWFsRXZlbnRzID0gc2NoZWR1bGUuZXZlbnRzIHx8IFtdO1xuICAgICAgY29uc3Qgc2NoZWR1bGVJdGVtcyA9IHNjaGVkdWxlLml0ZW1zIHx8IFtdO1xuICAgICAgY29uc3QgZHVyYXRpb25zID0gc2NoZWR1bGUuZHVyYXRpb25zO1xuICAgICAgY29uc3QgcmVtb3ZlZElkcyA9IHJlbW92ZWRJbnRlcnN0aXRpYWxzLm1hcChpbnRlcnN0aXRpYWwgPT4gaW50ZXJzdGl0aWFsLmlkZW50aWZpZXIpO1xuICAgICAgY29uc3QgaW50ZXJzdGl0aWFsc1VwZGF0ZWQgPSAhIShpbnRlcnN0aXRpYWxFdmVudHMubGVuZ3RoIHx8IHJlbW92ZWRJZHMubGVuZ3RoKTtcbiAgICAgIGlmIChpbnRlcnN0aXRpYWxzVXBkYXRlZCB8fCBwcmV2aW91c0l0ZW1zKSB7XG4gICAgICAgIHRoaXMubG9nKGBJTlRFUlNUSVRJQUxTX1VQREFURUQgKCR7aW50ZXJzdGl0aWFsRXZlbnRzLmxlbmd0aH0pOiAke2ludGVyc3RpdGlhbEV2ZW50c31cblNjaGVkdWxlOiAke3NjaGVkdWxlSXRlbXMubWFwKHNlZyA9PiBzZWdtZW50VG9TdHJpbmcoc2VnKSl9IHBvczogJHt0aGlzLnRpbWVsaW5lUG9zfWApO1xuICAgICAgfVxuICAgICAgaWYgKHJlbW92ZWRJZHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMubG9nKGBSZW1vdmVkIGV2ZW50cyAke3JlbW92ZWRJZHN9YCk7XG4gICAgICB9XG4gICAgICB0aGlzLnBsYXllclF1ZXVlLmZvckVhY2gocGxheWVyID0+IHtcbiAgICAgICAgaWYgKHBsYXllci5pbnRlcnN0aXRpYWwuYXBwZW5kSW5QbGFjZSkge1xuICAgICAgICAgIGNvbnN0IHRpbWVsaW5lU3RhcnQgPSBwbGF5ZXIuYXNzZXRJdGVtLnRpbWVsaW5lU3RhcnQ7XG4gICAgICAgICAgY29uc3QgZGlmZiA9IHBsYXllci50aW1lbGluZU9mZnNldCAtIHRpbWVsaW5lU3RhcnQ7XG4gICAgICAgICAgaWYgKGRpZmYpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHBsYXllci50aW1lbGluZU9mZnNldCA9IHRpbWVsaW5lU3RhcnQ7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGlmIChNYXRoLmFicyhkaWZmKSA+IEFMSUdORURfRU5EX1RIUkVTSE9MRF9TRUNPTkRTKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53YXJuKGAke2V9IChcIiR7cGxheWVyLmFzc2V0SWR9XCIgJHtwbGF5ZXIudGltZWxpbmVPZmZzZXR9LT4ke3RpbWVsaW5lU3RhcnR9KWApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gVXBkYXRlIHNjaGVkdWxlIGl0ZW0gcmVmZXJlbmNlc1xuICAgICAgLy8gRG8gbm90IHJlcGxhY2UgSW50ZXJzdGl0aWFsIHBsYXlpbmdJdGVtIHdpdGhvdXQgYSBtYXRjaCAtIHVzZWQgZm9yIElOVEVSU1RJVElBTF9BU1NFVF9FTkRFRCBhbmQgSU5URVJTVElUSUFMX0VOREVEXG4gICAgICBsZXQgdHJpbUluUGxhY2VGb3JQbGF5b3V0ID0gbnVsbDtcbiAgICAgIGlmIChwbGF5aW5nSXRlbSkge1xuICAgICAgICBjb25zdCB1cGRhdGVkUGxheWluZ0l0ZW0gPSB0aGlzLnVwZGF0ZUl0ZW0ocGxheWluZ0l0ZW0sIHRoaXMudGltZWxpbmVQb3MpO1xuICAgICAgICBpZiAodGhpcy5pdGVtc01hdGNoKHBsYXlpbmdJdGVtLCB1cGRhdGVkUGxheWluZ0l0ZW0pKSB7XG4gICAgICAgICAgdGhpcy5wbGF5aW5nSXRlbSA9IHVwZGF0ZWRQbGF5aW5nSXRlbTtcbiAgICAgICAgICB0aGlzLndhaXRpbmdJdGVtID0gdGhpcy5lbmRlZEl0ZW0gPSBudWxsO1xuICAgICAgICAgIHRyaW1JblBsYWNlRm9yUGxheW91dCA9ICgpID0+IHRoaXMudHJpbUluUGxhY2UodXBkYXRlZFBsYXlpbmdJdGVtLCBwbGF5aW5nSXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENsZWFyIHdhaXRpbmdJdGVtIGlmIGl0IGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgc2NoZWR1bGVcbiAgICAgICAgdGhpcy53YWl0aW5nSXRlbSA9IHRoaXMudXBkYXRlSXRlbSh0aGlzLndhaXRpbmdJdGVtKTtcbiAgICAgICAgdGhpcy5lbmRlZEl0ZW0gPSB0aGlzLnVwZGF0ZUl0ZW0odGhpcy5lbmRlZEl0ZW0pO1xuICAgICAgfVxuICAgICAgLy8gRG8gbm90IHJlcGxhY2UgSW50ZXJzdGl0aWFsIGJ1ZmZlcmluZ0l0ZW0gd2l0aG91dCBhIG1hdGNoIC0gdXNlZCBmb3IgdHJhbnNmZXJpbmcgbWVkaWEgZWxlbWVudCBvciBzb3VyY2VcbiAgICAgIGNvbnN0IGJ1ZmZlcmluZ0l0ZW0gPSB0aGlzLmJ1ZmZlcmluZ0l0ZW07XG4gICAgICBpZiAoYnVmZmVyaW5nSXRlbSkge1xuICAgICAgICBjb25zdCB1cGRhdGVkQnVmZmVyaW5nSXRlbSA9IHRoaXMudXBkYXRlSXRlbShidWZmZXJpbmdJdGVtLCB0aGlzLmJ1ZmZlcmVkUG9zKTtcbiAgICAgICAgaWYgKHRoaXMuaXRlbXNNYXRjaChidWZmZXJpbmdJdGVtLCB1cGRhdGVkQnVmZmVyaW5nSXRlbSkpIHtcbiAgICAgICAgICB0aGlzLmJ1ZmZlcmluZ0l0ZW0gPSB1cGRhdGVkQnVmZmVyaW5nSXRlbTtcbiAgICAgICAgICB0cmltSW5QbGFjZUZvclBsYXlvdXQgfHwgKHRyaW1JblBsYWNlRm9yUGxheW91dCA9ICgpID0+IHRoaXMudHJpbUluUGxhY2UodXBkYXRlZEJ1ZmZlcmluZ0l0ZW0sIGJ1ZmZlcmluZ0l0ZW0pKTtcbiAgICAgICAgfSBlbHNlIGlmIChidWZmZXJpbmdJdGVtLmV2ZW50KSB7XG4gICAgICAgICAgLy8gSW50ZXJzdGl0aWFsIHJlbW92ZWQgZnJvbSBzY2hlZHVsZSAoTGl2ZSAtPiBWT0Qgb3Igb3RoZXIgc2NlbmFyaW8gd2hlcmUgU3RhcnQgRGF0ZSBpcyBvdXRzaWRlIHRoZSByYW5nZSBvZiBWT0QgUGxheWxpc3QpXG4gICAgICAgICAgdGhpcy5idWZmZXJpbmdJdGVtID0gdGhpcy5wbGF5aW5nSXRlbTtcbiAgICAgICAgICB0aGlzLmNsZWFySW50ZXJzdGl0aWFsKGJ1ZmZlcmluZ0l0ZW0uZXZlbnQsIG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZW1vdmVkSW50ZXJzdGl0aWFscy5mb3JFYWNoKGludGVyc3RpdGlhbCA9PiB7XG4gICAgICAgIGludGVyc3RpdGlhbC5hc3NldExpc3QuZm9yRWFjaChhc3NldCA9PiB7XG4gICAgICAgICAgdGhpcy5jbGVhckFzc2V0UGxheWVyKGFzc2V0LmlkZW50aWZpZXIsIG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGludGVyc3RpdGlhbHNVcGRhdGVkIHx8IHByZXZpb3VzSXRlbXMpIHtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuSU5URVJTVElUSUFMU19VUERBVEVELCB7XG4gICAgICAgICAgZXZlbnRzOiBpbnRlcnN0aXRpYWxFdmVudHMuc2xpY2UoMCksXG4gICAgICAgICAgc2NoZWR1bGU6IHNjaGVkdWxlSXRlbXMuc2xpY2UoMCksXG4gICAgICAgICAgZHVyYXRpb25zLFxuICAgICAgICAgIHJlbW92ZWRJZHNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmlzSW50ZXJzdGl0aWFsKHBsYXlpbmdJdGVtKSAmJiByZW1vdmVkSWRzLmluY2x1ZGVzKHBsYXlpbmdJdGVtLmV2ZW50LmlkZW50aWZpZXIpKSB7XG4gICAgICAgICAgdGhpcy53YXJuKGBJbnRlcnN0aXRpYWwgXCIke3BsYXlpbmdJdGVtLmV2ZW50LmlkZW50aWZpZXJ9XCIgcmVtb3ZlZCB3aGlsZSBwbGF5aW5nYCk7XG4gICAgICAgICAgdGhpcy5wcmltYXJ5RmFsbGJhY2socGxheWluZ0l0ZW0uZXZlbnQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJpbUluUGxhY2VGb3JQbGF5b3V0KSB7XG4gICAgICAgICAgdHJpbUluUGxhY2VGb3JQbGF5b3V0KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpcyBidWZmZXJlZCB0byBuZXcgSW50ZXJzdGl0aWFsIGV2ZW50IGJvdW5kYXJ5XG4gICAgICAgIC8vIChMaXZlIHVwZGF0ZSBwdWJsaXNoZXMgSW50ZXJzdGl0aWFsIHdpdGggbmV3IHNlZ21lbnQpXG4gICAgICAgIHRoaXMuY2hlY2tCdWZmZXIoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMuSGxzUGxheWVyQ2xhc3MgPSBIbHNQbGF5ZXJDbGFzcztcbiAgICB0aGlzLmFzc2V0TGlzdExvYWRlciA9IG5ldyBBc3NldExpc3RMb2FkZXIoaGxzKTtcbiAgICB0aGlzLnNjaGVkdWxlID0gbmV3IEludGVyc3RpdGlhbHNTY2hlZHVsZSh0aGlzLm9uU2NoZWR1bGVVcGRhdGUsIGhscy5sb2dnZXIpO1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX1VQREFURUQsIHRoaXMub25MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENISU5HLCB0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5BVURJT19UUkFDS19VUERBVEVELCB0aGlzLm9uQXVkaW9UcmFja1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuU1VCVElUTEVfVFJBQ0tfU1dJVENILCB0aGlzLm9uU3VidGl0bGVUcmFja1N3aXRjaCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5TVUJUSVRMRV9UUkFDS19VUERBVEVELCB0aGlzLm9uU3VidGl0bGVUcmFja1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRVZFTlRfQ1VFX0VOVEVSLCB0aGlzLm9uSW50ZXJzdGl0aWFsQ3VlRW50ZXIsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQVNTRVRfTElTVF9MT0FERUQsIHRoaXMub25Bc3NldExpc3RMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0FQUEVOREVELCB0aGlzLm9uQnVmZmVyQXBwZW5kZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0ZMVVNIRUQsIHRoaXMub25CdWZmZXJGbHVzaGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUkVEX1RPX0VORCwgdGhpcy5vbkJ1ZmZlcmVkVG9FbmQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfRU5ERUQsIHRoaXMub25NZWRpYUVuZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuREVTVFJPWUlORywgdGhpcy5vbkRlc3Ryb3lpbmcsIHRoaXMpO1xuICB9XG4gIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgaWYgKCFobHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX1VQREFURUQsIHRoaXMub25MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSElORywgdGhpcy5vbkF1ZGlvVHJhY2tTd2l0Y2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkFVRElPX1RSQUNLX1VQREFURUQsIHRoaXMub25BdWRpb1RyYWNrVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuU1VCVElUTEVfVFJBQ0tfU1dJVENILCB0aGlzLm9uU3VidGl0bGVUcmFja1N3aXRjaCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuU1VCVElUTEVfVFJBQ0tfVVBEQVRFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5FVkVOVF9DVUVfRU5URVIsIHRoaXMub25JbnRlcnN0aXRpYWxDdWVFbnRlciwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQVNTRVRfTElTVF9MT0FERUQsIHRoaXMub25Bc3NldExpc3RMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9DT0RFQ1MsIHRoaXMub25CdWZmZXJDb2RlY3MsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9BUFBFTkRFRCwgdGhpcy5vbkJ1ZmZlckFwcGVuZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfRkxVU0hFRCwgdGhpcy5vbkJ1ZmZlckZsdXNoZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUkVEX1RPX0VORCwgdGhpcy5vbkJ1ZmZlcmVkVG9FbmQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0VOREVELCB0aGlzLm9uTWVkaWFFbmRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuREVTVFJPWUlORywgdGhpcy5vbkRlc3Ryb3lpbmcsIHRoaXMpO1xuICB9XG4gIHN0YXJ0TG9hZCgpIHtcbiAgICAvLyBUT0RPOiBzdGFydExvYWQgLSBjaGVjayBmb3Igd2FpdGluZ0l0ZW0gYW5kIHJldHJ5IGJ5IHJlc2V0dGluZyBzY2hlZHVsZVxuICAgIHRoaXMucmVzdW1lQnVmZmVyaW5nKCk7XG4gIH1cbiAgc3RvcExvYWQoKSB7XG4gICAgLy8gVE9ETzogc3RvcExvYWQgLSBzdG9wIGFsbCBzY2hldWxlLmV2ZW50c1tdLmFzc2V0TGlzdExvYWRlcj8uYWJvcnQoKSB0aGVuIGRlbGV0ZSB0aGUgbG9hZGVyc1xuICAgIHRoaXMucGF1c2VCdWZmZXJpbmcoKTtcbiAgfVxuICByZXN1bWVCdWZmZXJpbmcoKSB7XG4gICAgdmFyIF90aGlzJGdldEJ1ZmZlcmluZ1BsYTtcbiAgICAoX3RoaXMkZ2V0QnVmZmVyaW5nUGxhID0gdGhpcy5nZXRCdWZmZXJpbmdQbGF5ZXIoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGdldEJ1ZmZlcmluZ1BsYS5yZXN1bWVCdWZmZXJpbmcoKTtcbiAgfVxuICBwYXVzZUJ1ZmZlcmluZygpIHtcbiAgICB2YXIgX3RoaXMkZ2V0QnVmZmVyaW5nUGxhMjtcbiAgICAoX3RoaXMkZ2V0QnVmZmVyaW5nUGxhMiA9IHRoaXMuZ2V0QnVmZmVyaW5nUGxheWVyKCkpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRnZXRCdWZmZXJpbmdQbGEyLnBhdXNlQnVmZmVyaW5nKCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgaWYgKHRoaXMuYXNzZXRMaXN0TG9hZGVyKSB7XG4gICAgICB0aGlzLmFzc2V0TGlzdExvYWRlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuZW1wdHlQbGF5ZXJRdWV1ZSgpO1xuICAgIHRoaXMuY2xlYXJTY2hlZHVsZVN0YXRlKCk7XG4gICAgaWYgKHRoaXMuc2NoZWR1bGUpIHtcbiAgICAgIHRoaXMuc2NoZWR1bGUuZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLm1lZGlhID0gdGhpcy5kZXRhY2hlZERhdGEgPSB0aGlzLm1lZGlhU2VsZWN0aW9uID0gdGhpcy5yZXF1aXJlZFRyYWNrcyA9IHRoaXMuYWx0U2VsZWN0aW9uID0gdGhpcy5tYW5hZ2VyID0gbnVsbDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSB0aGlzLkhsc1BsYXllckNsYXNzID0gdGhpcy5zY2hlZHVsZSA9IHRoaXMubG9nID0gbnVsbDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5hc3NldExpc3RMb2FkZXIgPSBudWxsO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLm9uUGxheSA9IHRoaXMub25QYXVzZSA9IHRoaXMub25TZWVraW5nID0gdGhpcy5vblRpbWV1cGRhdGUgPSBudWxsO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLm9uU2NoZWR1bGVVcGRhdGUgPSBudWxsO1xuICB9XG4gIG9uRGVzdHJveWluZygpIHtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMucHJpbWFyeU1lZGlhIHx8IHRoaXMubWVkaWE7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICB0aGlzLnJlbW92ZU1lZGlhTGlzdGVuZXJzKG1lZGlhKTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlTWVkaWFMaXN0ZW5lcnMobWVkaWEpIHtcbiAgICByZW1vdmVFdmVudExpc3RlbmVyKG1lZGlhLCAncGxheScsIHRoaXMub25QbGF5KTtcbiAgICByZW1vdmVFdmVudExpc3RlbmVyKG1lZGlhLCAncGF1c2UnLCB0aGlzLm9uUGF1c2UpO1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIobWVkaWEsICdzZWVraW5nJywgdGhpcy5vblNlZWtpbmcpO1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIobWVkaWEsICd0aW1ldXBkYXRlJywgdGhpcy5vblRpbWV1cGRhdGUpO1xuICB9XG4gIG9uTWVkaWFBdHRhY2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuICAgIGFkZEV2ZW50TGlzdGVuZXIobWVkaWEsICdzZWVraW5nJywgdGhpcy5vblNlZWtpbmcpO1xuICAgIGFkZEV2ZW50TGlzdGVuZXIobWVkaWEsICd0aW1ldXBkYXRlJywgdGhpcy5vblRpbWV1cGRhdGUpO1xuICAgIGFkZEV2ZW50TGlzdGVuZXIobWVkaWEsICdwbGF5JywgdGhpcy5vblBsYXkpO1xuICAgIGFkZEV2ZW50TGlzdGVuZXIobWVkaWEsICdwYXVzZScsIHRoaXMub25QYXVzZSk7XG4gIH1cbiAgb25NZWRpYUF0dGFjaGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3QgcGxheWluZ0l0ZW0gPSB0aGlzLmVmZmVjdGl2ZVBsYXlpbmdJdGVtO1xuICAgIGNvbnN0IGRldGFjaGVkTWVkaWEgPSB0aGlzLmRldGFjaGVkRGF0YTtcbiAgICB0aGlzLmRldGFjaGVkRGF0YSA9IG51bGw7XG4gICAgaWYgKHBsYXlpbmdJdGVtID09PSBudWxsKSB7XG4gICAgICB0aGlzLmNoZWNrU3RhcnQoKTtcbiAgICB9IGVsc2UgaWYgKCFkZXRhY2hlZE1lZGlhKSB7XG4gICAgICAvLyBSZXN1bWUgc2NoZWR1bGUgYWZ0ZXIgZGV0YWNoZWQgZXh0ZXJuYWxseVxuICAgICAgdGhpcy5jbGVhclNjaGVkdWxlU3RhdGUoKTtcbiAgICAgIGNvbnN0IHBsYXlpbmdJbmRleCA9IHRoaXMuZmluZEl0ZW1JbmRleChwbGF5aW5nSXRlbSk7XG4gICAgICB0aGlzLnNldFNjaGVkdWxlUG9zaXRpb24ocGxheWluZ0luZGV4KTtcbiAgICB9XG4gIH1cbiAgY2xlYXJTY2hlZHVsZVN0YXRlKCkge1xuICAgIHRoaXMucGxheWluZ0l0ZW0gPSB0aGlzLmJ1ZmZlcmluZ0l0ZW0gPSB0aGlzLndhaXRpbmdJdGVtID0gdGhpcy5lbmRlZEl0ZW0gPSB0aGlzLnBsYXlpbmdBc3NldCA9IHRoaXMuZW5kZWRBc3NldCA9IHRoaXMuYnVmZmVyaW5nQXNzZXQgPSBudWxsO1xuICB9XG4gIG9uTWVkaWFEZXRhY2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB0cmFuc2ZlcnJpbmdNZWRpYSA9ICEhZGF0YS50cmFuc2Zlck1lZGlhO1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICBpZiAodHJhbnNmZXJyaW5nTWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICB0aGlzLnJlbW92ZU1lZGlhTGlzdGVuZXJzKG1lZGlhKTtcbiAgICB9XG4gICAgLy8gSWYgZGV0YWNoTWVkaWEgaXMgY2FsbGVkIHdoaWxlIGluIGFuIEludGVyc3RpdGlhbCwgZGV0YWNoIHRoZSBhc3NldCBwbGF5ZXIgYXMgd2VsbCBhbmQgcmVzZXQgdGhlIHNjaGVkdWxlIHBvc2l0aW9uXG4gICAgaWYgKHRoaXMuZGV0YWNoZWREYXRhKSB7XG4gICAgICBjb25zdCBwbGF5ZXIgPSB0aGlzLmdldEJ1ZmZlcmluZ1BsYXllcigpO1xuICAgICAgaWYgKHBsYXllcikge1xuICAgICAgICB0aGlzLnBsYXlpbmdBc3NldCA9IHRoaXMuZW5kZWRBc3NldCA9IHRoaXMuYnVmZmVyaW5nQXNzZXQgPSB0aGlzLmJ1ZmZlcmluZ0l0ZW0gPSB0aGlzLndhaXRpbmdJdGVtID0gdGhpcy5kZXRhY2hlZERhdGEgPSBudWxsO1xuICAgICAgICBwbGF5ZXIuZGV0YWNoTWVkaWEoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2hvdWxkUGxheSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBnZXQgaW50ZXJzdGl0aWFsc01hbmFnZXIoKSB7XG4gICAgaWYgKCF0aGlzLm1hbmFnZXIpIHtcbiAgICAgIGlmICghdGhpcy5obHMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBjID0gdGhpcztcbiAgICAgIGNvbnN0IGVmZmVjdGl2ZUJ1ZmZlcmluZ0l0ZW0gPSAoKSA9PiBjLmJ1ZmZlcmluZ0l0ZW0gfHwgYy53YWl0aW5nSXRlbTtcbiAgICAgIGNvbnN0IGdldEFzc2V0UGxheWVyID0gYXNzZXQgPT4gYXNzZXQgPyBjLmdldEFzc2V0UGxheWVyKGFzc2V0LmlkZW50aWZpZXIpIDogYXNzZXQ7XG4gICAgICBjb25zdCBnZXRNYXBwZWRUaW1lID0gKGl0ZW0sIHRpbWVsaW5lVHlwZSwgYXNzZXQsIGNvbnRyb2xsZXJGaWVsZCwgYXNzZXRQbGF5ZXJGaWVsZCkgPT4ge1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgIGxldCB0aW1lID0gaXRlbVt0aW1lbGluZVR5cGVdLnN0YXJ0O1xuICAgICAgICAgIGNvbnN0IGludGVyc3RpdGlhbCA9IGl0ZW0uZXZlbnQ7XG4gICAgICAgICAgaWYgKGludGVyc3RpdGlhbCkge1xuICAgICAgICAgICAgaWYgKHRpbWVsaW5lVHlwZSA9PT0gJ3BsYXlvdXQnIHx8IGludGVyc3RpdGlhbC50aW1lbGluZU9jY3VwYW5jeSAhPT0gVGltZWxpbmVPY2N1cGFuY3kuUG9pbnQpIHtcbiAgICAgICAgICAgICAgY29uc3QgYXNzZXRQbGF5ZXIgPSBnZXRBc3NldFBsYXllcihhc3NldCk7XG4gICAgICAgICAgICAgIGlmICgoYXNzZXRQbGF5ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGFzc2V0UGxheWVyLmludGVyc3RpdGlhbCkgPT09IGludGVyc3RpdGlhbCkge1xuICAgICAgICAgICAgICAgIHRpbWUgKz0gYXNzZXRQbGF5ZXIuYXNzZXRJdGVtLnN0YXJ0T2Zmc2V0ICsgYXNzZXRQbGF5ZXJbYXNzZXRQbGF5ZXJGaWVsZF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjb250cm9sbGVyRmllbGQgPT09ICdidWZmZXJlZFBvcycgPyBnZXRCdWZmZXJlZEVuZCgpIDogY1tjb250cm9sbGVyRmllbGRdO1xuICAgICAgICAgICAgdGltZSArPSB2YWx1ZSAtIGl0ZW0uc3RhcnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGZpbmRNYXBwZWRUaW1lID0gKHByaW1hcnlUaW1lLCB0aW1lbGluZVR5cGUpID0+IHtcbiAgICAgICAgaWYgKHByaW1hcnlUaW1lICE9PSAwICYmIHRpbWVsaW5lVHlwZSAhPT0gJ3ByaW1hcnknICYmIGMuc2NoZWR1bGUubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIF9jJHNjaGVkdWxlJGl0ZW1zO1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gYy5zY2hlZHVsZS5maW5kSXRlbUluZGV4QXRUaW1lKHByaW1hcnlUaW1lKTtcbiAgICAgICAgICBjb25zdCBpdGVtID0gKF9jJHNjaGVkdWxlJGl0ZW1zID0gYy5zY2hlZHVsZS5pdGVtcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jJHNjaGVkdWxlJGl0ZW1zW2luZGV4XTtcbiAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgY29uc3QgZGlmZiA9IGl0ZW1bdGltZWxpbmVUeXBlXS5zdGFydCAtIGl0ZW0uc3RhcnQ7XG4gICAgICAgICAgICByZXR1cm4gcHJpbWFyeVRpbWUgKyBkaWZmO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJpbWFyeVRpbWU7XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0QnVmZmVyZWRFbmQgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYy5idWZmZXJlZFBvcztcbiAgICAgICAgaWYgKHZhbHVlID09PSBOdW1iZXIuTUFYX1ZBTFVFKSB7XG4gICAgICAgICAgcmV0dXJuIGdldE1hcHBlZER1cmF0aW9uKCdwcmltYXJ5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHZhbHVlLCAwKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBnZXRNYXBwZWREdXJhdGlvbiA9IHRpbWVsaW5lVHlwZSA9PiB7XG4gICAgICAgIHZhciBfYyRwcmltYXJ5RGV0YWlscztcbiAgICAgICAgaWYgKChfYyRwcmltYXJ5RGV0YWlscyA9IGMucHJpbWFyeURldGFpbHMpICE9IG51bGwgJiYgX2MkcHJpbWFyeURldGFpbHMubGl2ZSkge1xuICAgICAgICAgIC8vIHJldHVybiBlbmQgb2YgbGFzdCBldmVudCBpdGVtIG9yIHBsYXlsaXN0XG4gICAgICAgICAgcmV0dXJuIGMucHJpbWFyeURldGFpbHMuZWRnZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYy5zY2hlZHVsZS5kdXJhdGlvbnNbdGltZWxpbmVUeXBlXTtcbiAgICAgIH07XG4gICAgICBjb25zdCBzZWVrVG8gPSAodGltZSwgdGltZWxpbmVUeXBlKSA9PiB7XG4gICAgICAgIHZhciBfaXRlbSRldmVudCwgX2Mkc2NoZWR1bGUkaXRlbXMyO1xuICAgICAgICBjb25zdCBpdGVtID0gYy5lZmZlY3RpdmVQbGF5aW5nSXRlbTtcbiAgICAgICAgaWYgKGl0ZW0gIT0gbnVsbCAmJiAoX2l0ZW0kZXZlbnQgPSBpdGVtLmV2ZW50KSAhPSBudWxsICYmIF9pdGVtJGV2ZW50LnJlc3RyaWN0aW9ucy5za2lwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGMubG9nKGBzZWVrIHRvICR7dGltZX0gXCIke3RpbWVsaW5lVHlwZX1cImApO1xuICAgICAgICBjb25zdCBwbGF5aW5nSXRlbSA9IGMuZWZmZWN0aXZlUGxheWluZ0l0ZW07XG4gICAgICAgIGNvbnN0IHRhcmdldEluZGV4ID0gYy5zY2hlZHVsZS5maW5kSXRlbUluZGV4QXRUaW1lKHRpbWUsIHRpbWVsaW5lVHlwZSk7XG4gICAgICAgIGNvbnN0IHRhcmdldEl0ZW0gPSAoX2Mkc2NoZWR1bGUkaXRlbXMyID0gYy5zY2hlZHVsZS5pdGVtcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jJHNjaGVkdWxlJGl0ZW1zMlt0YXJnZXRJbmRleF07XG4gICAgICAgIGNvbnN0IGJ1ZmZlcmluZ1BsYXllciA9IGMuZ2V0QnVmZmVyaW5nUGxheWVyKCk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlcmluZ0ludGVyc3RpdGlhbCA9IGJ1ZmZlcmluZ1BsYXllciA9PSBudWxsID8gdm9pZCAwIDogYnVmZmVyaW5nUGxheWVyLmludGVyc3RpdGlhbDtcbiAgICAgICAgY29uc3QgYXBwZW5kSW5QbGFjZSA9IGJ1ZmZlcmluZ0ludGVyc3RpdGlhbCA9PSBudWxsID8gdm9pZCAwIDogYnVmZmVyaW5nSW50ZXJzdGl0aWFsLmFwcGVuZEluUGxhY2U7XG4gICAgICAgIGNvbnN0IHNlZWtJbkl0ZW0gPSBwbGF5aW5nSXRlbSAmJiBjLml0ZW1zTWF0Y2gocGxheWluZ0l0ZW0sIHRhcmdldEl0ZW0pO1xuICAgICAgICBpZiAocGxheWluZ0l0ZW0gJiYgKGFwcGVuZEluUGxhY2UgfHwgc2Vla0luSXRlbSkpIHtcbiAgICAgICAgICAvLyBzZWVrIGluIGFzc2V0IHBsYXllciBvciBwcmltYXJ5IG1lZGlhIChhcHBlbmRJblBsYWNlKVxuICAgICAgICAgIGNvbnN0IGFzc2V0UGxheWVyID0gZ2V0QXNzZXRQbGF5ZXIoYy5wbGF5aW5nQXNzZXQpO1xuICAgICAgICAgIGNvbnN0IG1lZGlhID0gKGFzc2V0UGxheWVyID09IG51bGwgPyB2b2lkIDAgOiBhc3NldFBsYXllci5tZWRpYSkgfHwgYy5wcmltYXJ5TWVkaWE7XG4gICAgICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9IHRpbWVsaW5lVHlwZSA9PT0gJ3ByaW1hcnknID8gbWVkaWEuY3VycmVudFRpbWUgOiBnZXRNYXBwZWRUaW1lKHBsYXlpbmdJdGVtLCB0aW1lbGluZVR5cGUsIGMucGxheWluZ0Fzc2V0LCAndGltZWxpbmVQb3MnLCAnY3VycmVudFRpbWUnKTtcbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSB0aW1lIC0gY3VycmVudFRpbWU7XG4gICAgICAgICAgICBjb25zdCBzZWVrVG9UaW1lID0gKGFwcGVuZEluUGxhY2UgPyBjdXJyZW50VGltZSA6IG1lZGlhLmN1cnJlbnRUaW1lKSArIGRpZmY7XG4gICAgICAgICAgICBpZiAoc2Vla1RvVGltZSA+PSAwICYmICghYXNzZXRQbGF5ZXIgfHwgYXBwZW5kSW5QbGFjZSB8fCBzZWVrVG9UaW1lIDw9IGFzc2V0UGxheWVyLmR1cmF0aW9uKSkge1xuICAgICAgICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IHNlZWtUb1RpbWU7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2VlayBvdXQgb2YgaXRlbSBvciBhc3NldFxuICAgICAgICBpZiAodGFyZ2V0SXRlbSkge1xuICAgICAgICAgIGxldCBzZWVrVG9UaW1lID0gdGltZTtcbiAgICAgICAgICBpZiAodGltZWxpbmVUeXBlICE9PSAncHJpbWFyeScpIHtcbiAgICAgICAgICAgIGNvbnN0IHByaW1hcnlTZWdtZW50U3RhcnQgPSB0YXJnZXRJdGVtW3RpbWVsaW5lVHlwZV0uc3RhcnQ7XG4gICAgICAgICAgICBjb25zdCBkaWZmID0gdGltZSAtIHByaW1hcnlTZWdtZW50U3RhcnQ7XG4gICAgICAgICAgICBzZWVrVG9UaW1lID0gdGFyZ2V0SXRlbS5zdGFydCArIGRpZmY7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHRhcmdldElzUHJpbWFyeSA9ICFjLmlzSW50ZXJzdGl0aWFsKHRhcmdldEl0ZW0pO1xuICAgICAgICAgIGlmICgoIWMuaXNJbnRlcnN0aXRpYWwocGxheWluZ0l0ZW0pIHx8IHBsYXlpbmdJdGVtLmV2ZW50LmFwcGVuZEluUGxhY2UpICYmICh0YXJnZXRJc1ByaW1hcnkgfHwgdGFyZ2V0SXRlbS5ldmVudC5hcHBlbmRJblBsYWNlKSkge1xuICAgICAgICAgICAgY29uc3QgbWVkaWEgPSBjLm1lZGlhIHx8IChhcHBlbmRJblBsYWNlID8gYnVmZmVyaW5nUGxheWVyID09IG51bGwgPyB2b2lkIDAgOiBidWZmZXJpbmdQbGF5ZXIubWVkaWEgOiBudWxsKTtcbiAgICAgICAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IHNlZWtUb1RpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChwbGF5aW5nSXRlbSkge1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgYW4gSW50ZXJzdGl0aWFsIGJldHdlZW4gdGhlIGN1cnJlbnQgaXRlbSBhbmQgdGFyZ2V0IGl0ZW0gaGFzIGFuIFgtUkVTVFJJQ1QgSlVNUCByZXN0cmljdGlvblxuICAgICAgICAgICAgY29uc3QgcGxheWluZ0luZGV4ID0gYy5maW5kSXRlbUluZGV4KHBsYXlpbmdJdGVtKTtcbiAgICAgICAgICAgIGlmICh0YXJnZXRJbmRleCA+IHBsYXlpbmdJbmRleCkge1xuICAgICAgICAgICAgICBjb25zdCBqdW1wSW5kZXggPSBjLnNjaGVkdWxlLmZpbmRKdW1wUmVzdHJpY3RlZEluZGV4KHBsYXlpbmdJbmRleCArIDEsIHRhcmdldEluZGV4KTtcbiAgICAgICAgICAgICAgaWYgKGp1bXBJbmRleCA+IHBsYXlpbmdJbmRleCkge1xuICAgICAgICAgICAgICAgIGMuc2V0U2NoZWR1bGVQb3NpdGlvbihqdW1wSW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGFzc2V0SW5kZXggPSAwO1xuICAgICAgICAgICAgaWYgKHRhcmdldElzUHJpbWFyeSkge1xuICAgICAgICAgICAgICBjLnRpbWVsaW5lUG9zID0gc2Vla1RvVGltZTtcbiAgICAgICAgICAgICAgYy5jaGVja0J1ZmZlcigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIF90YXJnZXRJdGVtJGV2ZW50O1xuICAgICAgICAgICAgICBjb25zdCBhc3NldExpc3QgPSB0YXJnZXRJdGVtID09IG51bGwgPyB2b2lkIDAgOiAoX3RhcmdldEl0ZW0kZXZlbnQgPSB0YXJnZXRJdGVtLmV2ZW50KSA9PSBudWxsID8gdm9pZCAwIDogX3RhcmdldEl0ZW0kZXZlbnQuYXNzZXRMaXN0O1xuICAgICAgICAgICAgICBpZiAoYXNzZXRMaXN0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnRUaW1lID0gdGltZSAtICh0YXJnZXRJdGVtW3RpbWVsaW5lVHlwZV0gfHwgdGFyZ2V0SXRlbSkuc3RhcnQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGFzc2V0TGlzdC5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGFzc2V0ID0gYXNzZXRMaXN0W2ldO1xuICAgICAgICAgICAgICAgICAgaWYgKGFzc2V0LmR1cmF0aW9uICYmIGV2ZW50VGltZSA+PSBhc3NldC5zdGFydE9mZnNldCAmJiBldmVudFRpbWUgPCBhc3NldC5zdGFydE9mZnNldCArIGFzc2V0LmR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2V0SW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGMuc2V0U2NoZWR1bGVQb3NpdGlvbih0YXJnZXRJbmRleCwgYXNzZXRJbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0QWN0aXZlSW50ZXJzdGl0aWFsID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBwbGF5aW5nSXRlbSA9IGMuZWZmZWN0aXZlUGxheWluZ0l0ZW07XG4gICAgICAgIGlmIChjLmlzSW50ZXJzdGl0aWFsKHBsYXlpbmdJdGVtKSkge1xuICAgICAgICAgIHJldHVybiBwbGF5aW5nSXRlbTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWZmZXJpbmdJdGVtID0gZWZmZWN0aXZlQnVmZmVyaW5nSXRlbSgpO1xuICAgICAgICBpZiAoYy5pc0ludGVyc3RpdGlhbChidWZmZXJpbmdJdGVtKSkge1xuICAgICAgICAgIHJldHVybiBidWZmZXJpbmdJdGVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGludGVyc3RpdGlhbFBsYXllciA9IHtcbiAgICAgICAgZ2V0IGN1cnJlbnRUaW1lKCkge1xuICAgICAgICAgIGNvbnN0IGludGVyc3RpdGlhbEl0ZW0gPSBnZXRBY3RpdmVJbnRlcnN0aXRpYWwoKTtcbiAgICAgICAgICBjb25zdCBwbGF5aW5nSXRlbSA9IGMuZWZmZWN0aXZlUGxheWluZ0l0ZW07XG4gICAgICAgICAgaWYgKHBsYXlpbmdJdGVtICYmIHBsYXlpbmdJdGVtID09PSBpbnRlcnN0aXRpYWxJdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0TWFwcGVkVGltZShwbGF5aW5nSXRlbSwgJ3BsYXlvdXQnLCBjLmVmZmVjdGl2ZVBsYXlpbmdBc3NldCwgJ3RpbWVsaW5lUG9zJywgJ2N1cnJlbnRUaW1lJykgLSBwbGF5aW5nSXRlbS5wbGF5b3V0LnN0YXJ0O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IGN1cnJlbnRUaW1lKHRpbWUpIHtcbiAgICAgICAgICBjb25zdCBpbnRlcnN0aXRpYWxJdGVtID0gZ2V0QWN0aXZlSW50ZXJzdGl0aWFsKCk7XG4gICAgICAgICAgY29uc3QgcGxheWluZ0l0ZW0gPSBjLmVmZmVjdGl2ZVBsYXlpbmdJdGVtO1xuICAgICAgICAgIGlmIChwbGF5aW5nSXRlbSAmJiBwbGF5aW5nSXRlbSA9PT0gaW50ZXJzdGl0aWFsSXRlbSkge1xuICAgICAgICAgICAgc2Vla1RvKHRpbWUgKyBwbGF5aW5nSXRlbS5wbGF5b3V0LnN0YXJ0LCAncGxheW91dCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGR1cmF0aW9uKCkge1xuICAgICAgICAgIGNvbnN0IGludGVyc3RpdGlhbEl0ZW0gPSBnZXRBY3RpdmVJbnRlcnN0aXRpYWwoKTtcbiAgICAgICAgICBpZiAoaW50ZXJzdGl0aWFsSXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGludGVyc3RpdGlhbEl0ZW0ucGxheW91dC5lbmQgLSBpbnRlcnN0aXRpYWxJdGVtLnBsYXlvdXQuc3RhcnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgYXNzZXRQbGF5ZXJzKCkge1xuICAgICAgICAgIHZhciBfZ2V0QWN0aXZlSW50ZXJzdGl0aWE7XG4gICAgICAgICAgY29uc3QgYXNzZXRMaXN0ID0gKF9nZXRBY3RpdmVJbnRlcnN0aXRpYSA9IGdldEFjdGl2ZUludGVyc3RpdGlhbCgpKSA9PSBudWxsID8gdm9pZCAwIDogX2dldEFjdGl2ZUludGVyc3RpdGlhLmV2ZW50LmFzc2V0TGlzdDtcbiAgICAgICAgICBpZiAoYXNzZXRMaXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gYXNzZXRMaXN0Lm1hcChhc3NldCA9PiBjLmdldEFzc2V0UGxheWVyKGFzc2V0LmlkZW50aWZpZXIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgcGxheWluZ0luZGV4KCkge1xuICAgICAgICAgIHZhciBfZ2V0QWN0aXZlSW50ZXJzdGl0aWEyO1xuICAgICAgICAgIGNvbnN0IGludGVyc3RpdGlhbCA9IChfZ2V0QWN0aXZlSW50ZXJzdGl0aWEyID0gZ2V0QWN0aXZlSW50ZXJzdGl0aWFsKCkpID09IG51bGwgPyB2b2lkIDAgOiBfZ2V0QWN0aXZlSW50ZXJzdGl0aWEyLmV2ZW50O1xuICAgICAgICAgIGlmIChpbnRlcnN0aXRpYWwgJiYgYy5lZmZlY3RpdmVQbGF5aW5nQXNzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcnN0aXRpYWwuZmluZEFzc2V0SW5kZXgoYy5lZmZlY3RpdmVQbGF5aW5nQXNzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBzY2hlZHVsZUl0ZW0oKSB7XG4gICAgICAgICAgcmV0dXJuIGdldEFjdGl2ZUludGVyc3RpdGlhbCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5tYW5hZ2VyID0ge1xuICAgICAgICBnZXQgZXZlbnRzKCkge1xuICAgICAgICAgIHZhciBfYyRzY2hlZHVsZSwgX2Mkc2NoZWR1bGUkZXZlbnRzO1xuICAgICAgICAgIHJldHVybiAoKF9jJHNjaGVkdWxlID0gYy5zY2hlZHVsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IChfYyRzY2hlZHVsZSRldmVudHMgPSBfYyRzY2hlZHVsZS5ldmVudHMpID09IG51bGwgPyB2b2lkIDAgOiBfYyRzY2hlZHVsZSRldmVudHMuc2xpY2UoMCkpIHx8IFtdO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgc2NoZWR1bGUoKSB7XG4gICAgICAgICAgdmFyIF9jJHNjaGVkdWxlMiwgX2Mkc2NoZWR1bGUyJGl0ZW1zO1xuICAgICAgICAgIHJldHVybiAoKF9jJHNjaGVkdWxlMiA9IGMuc2NoZWR1bGUpID09IG51bGwgPyB2b2lkIDAgOiAoX2Mkc2NoZWR1bGUyJGl0ZW1zID0gX2Mkc2NoZWR1bGUyLml0ZW1zKSA9PSBudWxsID8gdm9pZCAwIDogX2Mkc2NoZWR1bGUyJGl0ZW1zLnNsaWNlKDApKSB8fCBbXTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGludGVyc3RpdGlhbFBsYXllcigpIHtcbiAgICAgICAgICBpZiAoZ2V0QWN0aXZlSW50ZXJzdGl0aWFsKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcnN0aXRpYWxQbGF5ZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgcGxheWVyUXVldWUoKSB7XG4gICAgICAgICAgcmV0dXJuIGMucGxheWVyUXVldWUuc2xpY2UoMCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBidWZmZXJpbmdBc3NldCgpIHtcbiAgICAgICAgICByZXR1cm4gYy5idWZmZXJpbmdBc3NldDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGJ1ZmZlcmluZ0l0ZW0oKSB7XG4gICAgICAgICAgcmV0dXJuIGVmZmVjdGl2ZUJ1ZmZlcmluZ0l0ZW0oKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGJ1ZmZlcmluZ0luZGV4KCkge1xuICAgICAgICAgIGNvbnN0IGl0ZW0gPSBlZmZlY3RpdmVCdWZmZXJpbmdJdGVtKCk7XG4gICAgICAgICAgcmV0dXJuIGMuZmluZEl0ZW1JbmRleChpdGVtKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHBsYXlpbmdBc3NldCgpIHtcbiAgICAgICAgICByZXR1cm4gYy5lZmZlY3RpdmVQbGF5aW5nQXNzZXQ7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBwbGF5aW5nSXRlbSgpIHtcbiAgICAgICAgICByZXR1cm4gYy5lZmZlY3RpdmVQbGF5aW5nSXRlbTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHBsYXlpbmdJbmRleCgpIHtcbiAgICAgICAgICBjb25zdCBpdGVtID0gYy5lZmZlY3RpdmVQbGF5aW5nSXRlbTtcbiAgICAgICAgICByZXR1cm4gYy5maW5kSXRlbUluZGV4KGl0ZW0pO1xuICAgICAgICB9LFxuICAgICAgICBwcmltYXJ5OiB7XG4gICAgICAgICAgZ2V0IGJ1ZmZlcmVkRW5kKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEJ1ZmZlcmVkRW5kKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgY3VycmVudFRpbWUoKSB7XG4gICAgICAgICAgICBjb25zdCB0aW1lbGluZVBvcyA9IGMudGltZWxpbmVQb3M7XG4gICAgICAgICAgICByZXR1cm4gdGltZWxpbmVQb3MgPiAwID8gdGltZWxpbmVQb3MgOiAwO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0IGN1cnJlbnRUaW1lKHRpbWUpIHtcbiAgICAgICAgICAgIHNlZWtUbyh0aW1lLCAncHJpbWFyeScpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IGR1cmF0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldE1hcHBlZER1cmF0aW9uKCdwcmltYXJ5Jyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgc2Vla2FibGVTdGFydCgpIHtcbiAgICAgICAgICAgIHZhciBfYyRwcmltYXJ5RGV0YWlsczI7XG4gICAgICAgICAgICByZXR1cm4gKChfYyRwcmltYXJ5RGV0YWlsczIgPSBjLnByaW1hcnlEZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX2MkcHJpbWFyeURldGFpbHMyLmZyYWdtZW50U3RhcnQpIHx8IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpbnRlZ3JhdGVkOiB7XG4gICAgICAgICAgZ2V0IGJ1ZmZlcmVkRW5kKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldE1hcHBlZFRpbWUoZWZmZWN0aXZlQnVmZmVyaW5nSXRlbSgpLCAnaW50ZWdyYXRlZCcsIGMuYnVmZmVyaW5nQXNzZXQsICdidWZmZXJlZFBvcycsICdidWZmZXJlZEVuZCcpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IGN1cnJlbnRUaW1lKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldE1hcHBlZFRpbWUoYy5lZmZlY3RpdmVQbGF5aW5nSXRlbSwgJ2ludGVncmF0ZWQnLCBjLmVmZmVjdGl2ZVBsYXlpbmdBc3NldCwgJ3RpbWVsaW5lUG9zJywgJ2N1cnJlbnRUaW1lJyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQgY3VycmVudFRpbWUodGltZSkge1xuICAgICAgICAgICAgc2Vla1RvKHRpbWUsICdpbnRlZ3JhdGVkJyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgZHVyYXRpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0TWFwcGVkRHVyYXRpb24oJ2ludGVncmF0ZWQnKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBzZWVrYWJsZVN0YXJ0KCkge1xuICAgICAgICAgICAgdmFyIF9jJHByaW1hcnlEZXRhaWxzMztcbiAgICAgICAgICAgIHJldHVybiBmaW5kTWFwcGVkVGltZSgoKF9jJHByaW1hcnlEZXRhaWxzMyA9IGMucHJpbWFyeURldGFpbHMpID09IG51bGwgPyB2b2lkIDAgOiBfYyRwcmltYXJ5RGV0YWlsczMuZnJhZ21lbnRTdGFydCkgfHwgMCwgJ2ludGVncmF0ZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNraXA6ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBpdGVtID0gYy5lZmZlY3RpdmVQbGF5aW5nSXRlbTtcbiAgICAgICAgICBjb25zdCBldmVudCA9IGl0ZW0gPT0gbnVsbCA/IHZvaWQgMCA6IGl0ZW0uZXZlbnQ7XG4gICAgICAgICAgaWYgKGV2ZW50ICYmICFldmVudC5yZXN0cmljdGlvbnMuc2tpcCkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBjLmZpbmRJdGVtSW5kZXgoaXRlbSk7XG4gICAgICAgICAgICBpZiAoZXZlbnQuYXBwZW5kSW5QbGFjZSkge1xuICAgICAgICAgICAgICBjb25zdCB0aW1lID0gaXRlbS5wbGF5b3V0LnN0YXJ0ICsgaXRlbS5ldmVudC5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgc2Vla1RvKHRpbWUgKyAwLjAwMSwgJ3BsYXlvdXQnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGMuYWR2YW5jZUFmdGVyQXNzZXRFbmRlZChldmVudCwgaW5kZXgsIEluZmluaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1hbmFnZXI7XG4gIH1cblxuICAvLyBTY2hlZHVsZSBnZXR0ZXJzXG4gIGdldCBlZmZlY3RpdmVQbGF5aW5nSXRlbSgpIHtcbiAgICByZXR1cm4gdGhpcy53YWl0aW5nSXRlbSB8fCB0aGlzLnBsYXlpbmdJdGVtIHx8IHRoaXMuZW5kZWRJdGVtO1xuICB9XG4gIGdldCBlZmZlY3RpdmVQbGF5aW5nQXNzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMucGxheWluZ0Fzc2V0IHx8IHRoaXMuZW5kZWRBc3NldDtcbiAgfVxuICBnZXQgcGxheWluZ0xhc3RJdGVtKCkge1xuICAgIHZhciBfdGhpcyRzY2hlZHVsZTtcbiAgICBjb25zdCBwbGF5aW5nSXRlbSA9IHRoaXMucGxheWluZ0l0ZW07XG4gICAgY29uc3QgaXRlbXMgPSAoX3RoaXMkc2NoZWR1bGUgPSB0aGlzLnNjaGVkdWxlKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkc2NoZWR1bGUuaXRlbXM7XG4gICAgaWYgKCF0aGlzLnBsYXliYWNrU3RhcnRlZCB8fCAhcGxheWluZ0l0ZW0gfHwgIWl0ZW1zKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmRJdGVtSW5kZXgocGxheWluZ0l0ZW0pID09PSBpdGVtcy5sZW5ndGggLSAxO1xuICB9XG4gIGdldCBwbGF5YmFja1N0YXJ0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWZmZWN0aXZlUGxheWluZ0l0ZW0gIT09IG51bGw7XG4gIH1cblxuICAvLyBNZWRpYSBnZXR0ZXJzIGFuZCBldmVudCBjYWxsYmFja3NcbiAgZ2V0IGN1cnJlbnRUaW1lKCkge1xuICAgIHZhciBfdGhpcyRidWZmZXJpbmdJdGVtLCBfdGhpcyRidWZmZXJpbmdJdGVtJGUsIF9tZWRpYTtcbiAgICBpZiAodGhpcy5tZWRpYVNlbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgICAgLy8gRG8gbm90IGFkdmFuY2UgYmVmb3JlIHNjaGVkdWxlIGlzIGtub3duXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBJZ25vcmUgY3VycmVudFRpbWUgd2hlbiBkZXRhY2hlZCBmb3IgSW50ZXJzdGl0aWFsIHBsYXliYWNrIHdpdGggc291cmNlIHJlc2V0XG4gICAgY29uc3QgcXVldWVkRm9yUGxheWJhY2sgPSB0aGlzLndhaXRpbmdJdGVtIHx8IHRoaXMucGxheWluZ0l0ZW07XG4gICAgaWYgKHRoaXMuaXNJbnRlcnN0aXRpYWwocXVldWVkRm9yUGxheWJhY2spICYmICFxdWV1ZWRGb3JQbGF5YmFjay5ldmVudC5hcHBlbmRJblBsYWNlKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGlmICghbWVkaWEgJiYgKF90aGlzJGJ1ZmZlcmluZ0l0ZW0gPSB0aGlzLmJ1ZmZlcmluZ0l0ZW0pICE9IG51bGwgJiYgKF90aGlzJGJ1ZmZlcmluZ0l0ZW0kZSA9IF90aGlzJGJ1ZmZlcmluZ0l0ZW0uZXZlbnQpICE9IG51bGwgJiYgX3RoaXMkYnVmZmVyaW5nSXRlbSRlLmFwcGVuZEluUGxhY2UpIHtcbiAgICAgIC8vIE9ic2VydmUgZGV0YWNoZWQgbWVkaWEgY3VycmVudFRpbWUgd2hlbiBhcHBlbmRpbmcgaW4gcGxhY2VcbiAgICAgIG1lZGlhID0gdGhpcy5wcmltYXJ5TWVkaWE7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gKF9tZWRpYSA9IG1lZGlhKSA9PSBudWxsID8gdm9pZCAwIDogX21lZGlhLmN1cnJlbnRUaW1lO1xuICAgIGlmIChjdXJyZW50VGltZSA9PT0gdW5kZWZpbmVkIHx8ICFpc0Zpbml0ZU51bWJlcihjdXJyZW50VGltZSkpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50VGltZTtcbiAgfVxuICBnZXQgcHJpbWFyeU1lZGlhKCkge1xuICAgIHZhciBfdGhpcyRkZXRhY2hlZERhdGE7XG4gICAgcmV0dXJuIHRoaXMubWVkaWEgfHwgKChfdGhpcyRkZXRhY2hlZERhdGEgPSB0aGlzLmRldGFjaGVkRGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGRldGFjaGVkRGF0YS5tZWRpYSkgfHwgbnVsbDtcbiAgfVxuICBpc0ludGVyc3RpdGlhbChpdGVtKSB7XG4gICAgcmV0dXJuICEhKGl0ZW0gIT0gbnVsbCAmJiBpdGVtLmV2ZW50KTtcbiAgfVxuICByZXRyZWl2ZU1lZGlhU291cmNlKGFzc2V0SWQsIHRvU2VnbWVudCkge1xuICAgIGNvbnN0IHBsYXllciA9IHRoaXMuZ2V0QXNzZXRQbGF5ZXIoYXNzZXRJZCk7XG4gICAgaWYgKHBsYXllcikge1xuICAgICAgdGhpcy50cmFuc2Zlck1lZGlhRnJvbVBsYXllcihwbGF5ZXIsIHRvU2VnbWVudCk7XG4gICAgfVxuICB9XG4gIHRyYW5zZmVyTWVkaWFGcm9tUGxheWVyKHBsYXllciwgdG9TZWdtZW50KSB7XG4gICAgY29uc3QgYXBwZW5kSW5QbGFjZSA9IHBsYXllci5pbnRlcnN0aXRpYWwuYXBwZW5kSW5QbGFjZTtcbiAgICBjb25zdCBwbGF5ZXJNZWRpYSA9IHBsYXllci5tZWRpYTtcbiAgICBpZiAoYXBwZW5kSW5QbGFjZSAmJiBwbGF5ZXJNZWRpYSA9PT0gdGhpcy5wcmltYXJ5TWVkaWEpIHtcbiAgICAgIHRoaXMuYnVmZmVyaW5nQXNzZXQgPSBudWxsO1xuICAgICAgaWYgKCF0b1NlZ21lbnQgfHwgdGhpcy5pc0ludGVyc3RpdGlhbCh0b1NlZ21lbnQpICYmICF0b1NlZ21lbnQuZXZlbnQuYXBwZW5kSW5QbGFjZSkge1xuICAgICAgICAvLyBNZWRpYVNvdXJjZSBjYW5ub3QgYmUgdHJhbnNmZXJlZCBiYWNrIHRvIGFuIEludGVyc3RpdGlhbCB0aGF0IHJlcXVpcmVzIGEgc291cmNlIHJlc2V0XG4gICAgICAgIC8vIG5vLW9wIHdoZW4gdG9TZWdtZW50IGlzIHVuZGVmaW5lZFxuICAgICAgICBpZiAodG9TZWdtZW50ICYmIHBsYXllck1lZGlhKSB7XG4gICAgICAgICAgdGhpcy5kZXRhY2hlZERhdGEgPSB7XG4gICAgICAgICAgICBtZWRpYTogcGxheWVyTWVkaWFcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgYXR0YWNoTWVkaWFTb3VyY2VEYXRhID0gcGxheWVyLnRyYW5zZmVyTWVkaWEoKTtcbiAgICAgIHRoaXMubG9nKGB0cmFuc2ZlciBNZWRpYVNvdXJjZSBmcm9tICR7cGxheWVyfSAke3N0cmluZ2lmeShhdHRhY2hNZWRpYVNvdXJjZURhdGEpfWApO1xuICAgICAgdGhpcy5kZXRhY2hlZERhdGEgPSBhdHRhY2hNZWRpYVNvdXJjZURhdGE7XG4gICAgfSBlbHNlIGlmICh0b1NlZ21lbnQgJiYgcGxheWVyTWVkaWEpIHtcbiAgICAgIHRoaXMuc2hvdWxkUGxheSB8fCAodGhpcy5zaG91bGRQbGF5ID0gIXBsYXllck1lZGlhLnBhdXNlZCk7XG4gICAgfVxuICB9XG4gIHRyYW5zZmVyTWVkaWFUbyhwbGF5ZXIsIG1lZGlhKSB7XG4gICAgdmFyIF90aGlzJGRldGFjaGVkRGF0YTIsIF9hdHRhY2hNZWRpYVNvdXJjZURhdDtcbiAgICBpZiAocGxheWVyLm1lZGlhID09PSBtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgYXR0YWNoTWVkaWFTb3VyY2VEYXRhID0gbnVsbDtcbiAgICBjb25zdCBwcmltYXJ5UGxheWVyID0gdGhpcy5obHM7XG4gICAgY29uc3QgaXNBc3NldFBsYXllciA9IHBsYXllciAhPT0gcHJpbWFyeVBsYXllcjtcbiAgICBjb25zdCBhcHBlbmRJblBsYWNlID0gaXNBc3NldFBsYXllciAmJiBwbGF5ZXIuaW50ZXJzdGl0aWFsLmFwcGVuZEluUGxhY2U7XG4gICAgY29uc3QgZGV0YWNoZWRNZWRpYVNvdXJjZSA9IChfdGhpcyRkZXRhY2hlZERhdGEyID0gdGhpcy5kZXRhY2hlZERhdGEpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRkZXRhY2hlZERhdGEyLm1lZGlhU291cmNlO1xuICAgIGxldCBsb2dGcm9tU291cmNlO1xuICAgIGlmIChwcmltYXJ5UGxheWVyLm1lZGlhKSB7XG4gICAgICBpZiAoYXBwZW5kSW5QbGFjZSkge1xuICAgICAgICBhdHRhY2hNZWRpYVNvdXJjZURhdGEgPSBwcmltYXJ5UGxheWVyLnRyYW5zZmVyTWVkaWEoKTtcbiAgICAgICAgdGhpcy5kZXRhY2hlZERhdGEgPSBhdHRhY2hNZWRpYVNvdXJjZURhdGE7XG4gICAgICB9XG4gICAgICBsb2dGcm9tU291cmNlID0gYFByaW1hcnlgO1xuICAgIH0gZWxzZSBpZiAoZGV0YWNoZWRNZWRpYVNvdXJjZSkge1xuICAgICAgY29uc3QgYnVmZmVyaW5nUGxheWVyID0gdGhpcy5nZXRCdWZmZXJpbmdQbGF5ZXIoKTtcbiAgICAgIGlmIChidWZmZXJpbmdQbGF5ZXIpIHtcbiAgICAgICAgYXR0YWNoTWVkaWFTb3VyY2VEYXRhID0gYnVmZmVyaW5nUGxheWVyLnRyYW5zZmVyTWVkaWEoKTtcbiAgICAgICAgbG9nRnJvbVNvdXJjZSA9IGAke2J1ZmZlcmluZ1BsYXllcn1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nRnJvbVNvdXJjZSA9IGBkZXRhY2hlZCBNZWRpYVNvdXJjZWA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ0Zyb21Tb3VyY2UgPSBgZGV0YWNoZWQgbWVkaWFgO1xuICAgIH1cbiAgICBpZiAoIWF0dGFjaE1lZGlhU291cmNlRGF0YSkge1xuICAgICAgaWYgKGRldGFjaGVkTWVkaWFTb3VyY2UpIHtcbiAgICAgICAgYXR0YWNoTWVkaWFTb3VyY2VEYXRhID0gdGhpcy5kZXRhY2hlZERhdGE7XG4gICAgICAgIHRoaXMubG9nKGB1c2luZyBkZXRhY2hlZERhdGE6IE1lZGlhU291cmNlICR7c3RyaW5naWZ5KGF0dGFjaE1lZGlhU291cmNlRGF0YSl9YCk7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLmRldGFjaGVkRGF0YSB8fCBwcmltYXJ5UGxheWVyLm1lZGlhID09PSBtZWRpYSkge1xuICAgICAgICAvLyBLZWVwIGludGVyc3RpdGlhbCBtZWRpYSB0cmFuc2l0aW9uIGNvbnNpc3RlbnRcbiAgICAgICAgY29uc3QgcGxheWVyUXVldWUgPSB0aGlzLnBsYXllclF1ZXVlO1xuICAgICAgICBpZiAocGxheWVyUXVldWUubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHBsYXllclF1ZXVlLmZvckVhY2gocXVldWVkUGxheWVyID0+IHtcbiAgICAgICAgICAgIGlmIChpc0Fzc2V0UGxheWVyICYmIHF1ZXVlZFBsYXllci5pbnRlcnN0aXRpYWwuYXBwZW5kSW5QbGFjZSAhPT0gYXBwZW5kSW5QbGFjZSkge1xuICAgICAgICAgICAgICBjb25zdCBpbnRlcnN0aXRpYWwgPSBxdWV1ZWRQbGF5ZXIuaW50ZXJzdGl0aWFsO1xuICAgICAgICAgICAgICB0aGlzLmNsZWFySW50ZXJzdGl0aWFsKHF1ZXVlZFBsYXllci5pbnRlcnN0aXRpYWwsIG51bGwpO1xuICAgICAgICAgICAgICBpbnRlcnN0aXRpYWwuYXBwZW5kSW5QbGFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgICBpZiAoaW50ZXJzdGl0aWFsLmFwcGVuZEluUGxhY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndhcm4oYENvdWxkIG5vdCBjaGFuZ2UgYXBwZW5kIHN0cmF0ZWd5IGZvciBxdWV1ZWQgYXNzZXRzICR7aW50ZXJzdGl0aWFsfWApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5obHMuZGV0YWNoTWVkaWEoKTtcbiAgICAgICAgdGhpcy5kZXRhY2hlZERhdGEgPSB7XG4gICAgICAgICAgbWVkaWFcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdHJhbnNmZXJyaW5nID0gYXR0YWNoTWVkaWFTb3VyY2VEYXRhICYmICdtZWRpYVNvdXJjZScgaW4gYXR0YWNoTWVkaWFTb3VyY2VEYXRhICYmICgoX2F0dGFjaE1lZGlhU291cmNlRGF0ID0gYXR0YWNoTWVkaWFTb3VyY2VEYXRhLm1lZGlhU291cmNlKSA9PSBudWxsID8gdm9pZCAwIDogX2F0dGFjaE1lZGlhU291cmNlRGF0LnJlYWR5U3RhdGUpICE9PSAnY2xvc2VkJztcbiAgICBjb25zdCBkYXRhVG9BdHRhY2ggPSB0cmFuc2ZlcnJpbmcgJiYgYXR0YWNoTWVkaWFTb3VyY2VEYXRhID8gYXR0YWNoTWVkaWFTb3VyY2VEYXRhIDogbWVkaWE7XG4gICAgdGhpcy5sb2coYCR7dHJhbnNmZXJyaW5nID8gJ3RyYW5zZmVyaW5nIE1lZGlhU291cmNlJyA6ICdhdHRhY2hpbmcgbWVkaWEnfSB0byAke2lzQXNzZXRQbGF5ZXIgPyBwbGF5ZXIgOiAnUHJpbWFyeSd9IGZyb20gJHtsb2dGcm9tU291cmNlfWApO1xuICAgIGlmIChkYXRhVG9BdHRhY2ggPT09IGF0dGFjaE1lZGlhU291cmNlRGF0YSkge1xuICAgICAgY29uc3QgaXNBc3NldEF0RW5kT2ZTY2hlZHVsZSA9IGlzQXNzZXRQbGF5ZXIgJiYgcGxheWVyLmFzc2V0SWQgPT09IHRoaXMuc2NoZWR1bGUuYXNzZXRJZEF0RW5kO1xuICAgICAgLy8gUHJldmVudCBhc3NldCBwbGF5ZXJzIGZyb20gbWFya2luZyBFb1Mgb24gdHJhbnNmZXJyZWQgTWVkaWFTb3VyY2VcbiAgICAgIGRhdGFUb0F0dGFjaC5vdmVycmlkZXMgPSB7XG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLnNjaGVkdWxlLmR1cmF0aW9uLFxuICAgICAgICBlbmRPZlN0cmVhbTogIWlzQXNzZXRQbGF5ZXIgfHwgaXNBc3NldEF0RW5kT2ZTY2hlZHVsZSxcbiAgICAgICAgY3VlUmVtb3ZhbDogIWlzQXNzZXRQbGF5ZXJcbiAgICAgIH07XG4gICAgfVxuICAgIHBsYXllci5hdHRhY2hNZWRpYShkYXRhVG9BdHRhY2gpO1xuICB9XG4gIG9uSW50ZXJzdGl0aWFsQ3VlRW50ZXIoKSB7XG4gICAgdGhpcy5vblRpbWV1cGRhdGUoKTtcbiAgfVxuICAvLyBTY2hlZHVsaW5nIG1ldGhvZHNcbiAgY2hlY2tTdGFydCgpIHtcbiAgICBjb25zdCBzY2hlZHVsZSA9IHRoaXMuc2NoZWR1bGU7XG4gICAgY29uc3QgaW50ZXJzdGl0aWFsRXZlbnRzID0gc2NoZWR1bGUuZXZlbnRzO1xuICAgIGlmICghaW50ZXJzdGl0aWFsRXZlbnRzIHx8IHRoaXMucGxheWJhY2tEaXNhYmxlZCB8fCAhdGhpcy5tZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBDaGVjayBidWZmZXJlZCB0byBwcmUtcm9sbFxuICAgIGlmICh0aGlzLmJ1ZmZlcmVkUG9zID09PSAtMSkge1xuICAgICAgdGhpcy5idWZmZXJlZFBvcyA9IDA7XG4gICAgfVxuICAgIC8vIFN0YXJ0IHN0ZXBwaW5nIHRocm91Z2ggc2NoZWR1bGUgd2hlbiBwbGF5YmFjayBiZWdpbnMgZm9yIHRoZSBmaXJzdCB0aW1lIGFuZCB3ZSBoYXZlIGEgcHJlLXJvbGxcbiAgICBjb25zdCB0aW1lbGluZVBvcyA9IHRoaXMudGltZWxpbmVQb3M7XG4gICAgY29uc3QgZWZmZWN0aXZlUGxheWluZ0l0ZW0gPSB0aGlzLmVmZmVjdGl2ZVBsYXlpbmdJdGVtO1xuICAgIGlmICh0aW1lbGluZVBvcyA9PT0gLTEpIHtcbiAgICAgIGNvbnN0IHN0YXJ0UG9zaXRpb24gPSB0aGlzLmhscy5zdGFydFBvc2l0aW9uO1xuICAgICAgdGhpcy50aW1lbGluZVBvcyA9IHN0YXJ0UG9zaXRpb247XG4gICAgICBpZiAoaW50ZXJzdGl0aWFsRXZlbnRzLmxlbmd0aCAmJiBpbnRlcnN0aXRpYWxFdmVudHNbMF0uY3VlLnByZSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHNjaGVkdWxlLmZpbmRFdmVudEluZGV4KGludGVyc3RpdGlhbEV2ZW50c1swXS5pZGVudGlmaWVyKTtcbiAgICAgICAgdGhpcy5zZXRTY2hlZHVsZVBvc2l0aW9uKGluZGV4KTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnRQb3NpdGlvbiA+PSAwIHx8ICF0aGlzLnByaW1hcnlMaXZlKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy50aW1lbGluZVBvcyA9IHN0YXJ0UG9zaXRpb24gPiAwID8gc3RhcnRQb3NpdGlvbiA6IDA7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gc2NoZWR1bGUuZmluZEl0ZW1JbmRleEF0VGltZShzdGFydCk7XG4gICAgICAgIHRoaXMuc2V0U2NoZWR1bGVQb3NpdGlvbihpbmRleCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlZmZlY3RpdmVQbGF5aW5nSXRlbSAmJiAhdGhpcy5wbGF5aW5nSXRlbSkge1xuICAgICAgY29uc3QgaW5kZXggPSBzY2hlZHVsZS5maW5kSXRlbUluZGV4KGVmZmVjdGl2ZVBsYXlpbmdJdGVtKTtcbiAgICAgIHRoaXMuc2V0U2NoZWR1bGVQb3NpdGlvbihpbmRleCk7XG4gICAgfVxuICB9XG4gIGFkdmFuY2VBZnRlckFzc2V0RW5kZWQoaW50ZXJzdGl0aWFsLCBpbmRleCwgYXNzZXRMaXN0SW5kZXgpIHtcbiAgICBjb25zdCBuZXh0QXNzZXRJbmRleCA9IGdldE5leHRBc3NldEluZGV4KGludGVyc3RpdGlhbCwgYXNzZXRMaXN0SW5kZXgpO1xuICAgIGlmICghaW50ZXJzdGl0aWFsLmlzQXNzZXRQYXN0UGxheW91dExpbWl0KG5leHRBc3NldEluZGV4KSkge1xuICAgICAgLy8gQWR2YW5jZSB0byBuZXh0IGFzc2V0IGxpc3QgaXRlbVxuICAgICAgdGhpcy5zZXRTY2hlZHVsZVBvc2l0aW9uKGluZGV4LCBuZXh0QXNzZXRJbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFkdmFuY2UgdG8gbmV4dCBzY2hlZHVsZSBzZWdtZW50XG4gICAgICAvLyBjaGVjayBpZiB3ZSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIHByb2dyYW1cbiAgICAgIGNvbnN0IHNjaGVkdWxlSXRlbXMgPSB0aGlzLnNjaGVkdWxlLml0ZW1zO1xuICAgICAgaWYgKHNjaGVkdWxlSXRlbXMpIHtcbiAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgICBjb25zdCBzY2hlZHVsZUxlbmd0aCA9IHNjaGVkdWxlSXRlbXMubGVuZ3RoO1xuICAgICAgICBpZiAobmV4dEluZGV4ID49IHNjaGVkdWxlTGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5zZXRTY2hlZHVsZVBvc2l0aW9uKC0xKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdW1wdGlvblRpbWUgPSBpbnRlcnN0aXRpYWwucmVzdW1lVGltZTtcbiAgICAgICAgaWYgKHRoaXMudGltZWxpbmVQb3MgPCByZXN1bXB0aW9uVGltZSkge1xuICAgICAgICAgIHRoaXMudGltZWxpbmVQb3MgPSByZXN1bXB0aW9uVGltZTtcbiAgICAgICAgICB0aGlzLmNoZWNrQnVmZmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRTY2hlZHVsZVBvc2l0aW9uKG5leHRJbmRleCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNldFNjaGVkdWxlVG9Bc3NldEF0VGltZSh0aW1lLCBwbGF5aW5nQXNzZXQpIHtcbiAgICBjb25zdCBzY2hlZHVsZSA9IHRoaXMuc2NoZWR1bGU7XG4gICAgY29uc3QgcGFyZW50SWRlbnRpZmllciA9IHBsYXlpbmdBc3NldC5wYXJlbnRJZGVudGlmaWVyO1xuICAgIGNvbnN0IGludGVyc3RpdGlhbCA9IHNjaGVkdWxlLmdldEV2ZW50KHBhcmVudElkZW50aWZpZXIpO1xuICAgIGlmIChpbnRlcnN0aXRpYWwpIHtcbiAgICAgIGNvbnN0IGl0ZW1JbmRleCA9IHNjaGVkdWxlLmZpbmRFdmVudEluZGV4KHBhcmVudElkZW50aWZpZXIpO1xuICAgICAgY29uc3QgYXNzZXRMaXN0SW5kZXggPSBzY2hlZHVsZS5maW5kQXNzZXRJbmRleChpbnRlcnN0aXRpYWwsIHRpbWUpO1xuICAgICAgdGhpcy5hZHZhbmNlQWZ0ZXJBc3NldEVuZGVkKGludGVyc3RpdGlhbCwgaXRlbUluZGV4LCBhc3NldExpc3RJbmRleCAtIDEpO1xuICAgIH1cbiAgfVxuICBzZXRTY2hlZHVsZVBvc2l0aW9uKGluZGV4LCBhc3NldExpc3RJbmRleCkge1xuICAgIGNvbnN0IHNjaGVkdWxlSXRlbXMgPSB0aGlzLnNjaGVkdWxlLml0ZW1zO1xuICAgIGlmICghc2NoZWR1bGVJdGVtcyB8fCB0aGlzLnBsYXliYWNrRGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sb2coYHNldFNjaGVkdWxlUG9zaXRpb24gJHtpbmRleH0sICR7YXNzZXRMaXN0SW5kZXh9YCk7XG4gICAgY29uc3Qgc2NoZWR1bGVkSXRlbSA9IGluZGV4ID49IDAgPyBzY2hlZHVsZUl0ZW1zW2luZGV4XSA6IG51bGw7XG4gICAgLy8gQ2xlYW51cCBjdXJyZW50IGl0ZW0gLyBhc3NldFxuICAgIGNvbnN0IGN1cnJlbnRJdGVtID0gdGhpcy5wbGF5aW5nSXRlbTtcbiAgICBjb25zdCBwbGF5aW5nTGFzdEl0ZW0gPSB0aGlzLnBsYXlpbmdMYXN0SXRlbTtcbiAgICBpZiAodGhpcy5pc0ludGVyc3RpdGlhbChjdXJyZW50SXRlbSkpIHtcbiAgICAgIHZhciBfaW50ZXJzdGl0aWFsJGFzc2V0TGk7XG4gICAgICBjb25zdCBpbnRlcnN0aXRpYWwgPSBjdXJyZW50SXRlbS5ldmVudDtcbiAgICAgIGNvbnN0IHBsYXlpbmdBc3NldCA9IHRoaXMucGxheWluZ0Fzc2V0O1xuICAgICAgY29uc3QgYXNzZXRJZCA9IHBsYXlpbmdBc3NldCA9PSBudWxsID8gdm9pZCAwIDogcGxheWluZ0Fzc2V0LmlkZW50aWZpZXI7XG4gICAgICBjb25zdCBwbGF5ZXIgPSBhc3NldElkID8gdGhpcy5nZXRBc3NldFBsYXllcihhc3NldElkKSA6IG51bGw7XG4gICAgICBpZiAocGxheWVyICYmIGFzc2V0SWQgJiYgKCF0aGlzLmV2ZW50SXRlbXNNYXRjaChjdXJyZW50SXRlbSwgc2NoZWR1bGVkSXRlbSkgfHwgYXNzZXRMaXN0SW5kZXggIT09IHVuZGVmaW5lZCAmJiBhc3NldElkICE9PSAoKF9pbnRlcnN0aXRpYWwkYXNzZXRMaSA9IGludGVyc3RpdGlhbC5hc3NldExpc3QpID09IG51bGwgPyB2b2lkIDAgOiBfaW50ZXJzdGl0aWFsJGFzc2V0TGlbYXNzZXRMaXN0SW5kZXhdLmlkZW50aWZpZXIpKSkge1xuICAgICAgICB2YXIgX3RoaXMkZGV0YWNoZWREYXRhMztcbiAgICAgICAgY29uc3QgcGxheWluZ0Fzc2V0TGlzdEluZGV4ID0gaW50ZXJzdGl0aWFsLmZpbmRBc3NldEluZGV4KHBsYXlpbmdBc3NldCk7XG4gICAgICAgIHRoaXMubG9nKGBJTlRFUlNUSVRJQUxfQVNTRVRfRU5ERUQgJHtwbGF5aW5nQXNzZXRMaXN0SW5kZXggKyAxfS8ke2ludGVyc3RpdGlhbC5hc3NldExpc3QubGVuZ3RofSAke2V2ZW50QXNzZXRUb1N0cmluZyhwbGF5aW5nQXNzZXQpfWApO1xuICAgICAgICB0aGlzLmVuZGVkQXNzZXQgPSBwbGF5aW5nQXNzZXQ7XG4gICAgICAgIHRoaXMucGxheWluZ0Fzc2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuSU5URVJTVElUSUFMX0FTU0VUX0VOREVELCB7XG4gICAgICAgICAgYXNzZXQ6IHBsYXlpbmdBc3NldCxcbiAgICAgICAgICBhc3NldExpc3RJbmRleDogcGxheWluZ0Fzc2V0TGlzdEluZGV4LFxuICAgICAgICAgIGV2ZW50OiBpbnRlcnN0aXRpYWwsXG4gICAgICAgICAgc2NoZWR1bGU6IHNjaGVkdWxlSXRlbXMuc2xpY2UoMCksXG4gICAgICAgICAgc2NoZWR1bGVJbmRleDogaW5kZXgsXG4gICAgICAgICAgcGxheWVyXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY3VycmVudEl0ZW0gIT09IHRoaXMucGxheWluZ0l0ZW0pIHtcbiAgICAgICAgICAvLyBTY2hlZHVsZSBjaGFuZ2Ugb2NjdXJlZCBvbiBJTlRFUlNUSVRJQUxfQVNTRVRfRU5ERURcbiAgICAgICAgICBpZiAodGhpcy5pdGVtc01hdGNoKGN1cnJlbnRJdGVtLCB0aGlzLnBsYXlpbmdJdGVtKSAmJiAhdGhpcy5wbGF5aW5nQXNzZXQpIHtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZUFmdGVyQXNzZXRFbmRlZChpbnRlcnN0aXRpYWwsIHRoaXMuZmluZEl0ZW1JbmRleCh0aGlzLnBsYXlpbmdJdGVtKSwgcGxheWluZ0Fzc2V0TGlzdEluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gTmF2aWdhdGlvbiBvY2N1cmVkIG9uIElOVEVSU1RJVElBTF9BU1NFVF9FTkRFRFxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJldHJlaXZlTWVkaWFTb3VyY2UoYXNzZXRJZCwgc2NoZWR1bGVkSXRlbSk7XG4gICAgICAgIGlmIChwbGF5ZXIubWVkaWEgJiYgISgoX3RoaXMkZGV0YWNoZWREYXRhMyA9IHRoaXMuZGV0YWNoZWREYXRhKSAhPSBudWxsICYmIF90aGlzJGRldGFjaGVkRGF0YTMubWVkaWFTb3VyY2UpKSB7XG4gICAgICAgICAgcGxheWVyLmRldGFjaE1lZGlhKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5ldmVudEl0ZW1zTWF0Y2goY3VycmVudEl0ZW0sIHNjaGVkdWxlZEl0ZW0pKSB7XG4gICAgICAgIHRoaXMuZW5kZWRJdGVtID0gY3VycmVudEl0ZW07XG4gICAgICAgIHRoaXMucGxheWluZ0l0ZW0gPSBudWxsO1xuICAgICAgICB0aGlzLmxvZyhgSU5URVJTVElUSUFMX0VOREVEICR7aW50ZXJzdGl0aWFsfSAke3NlZ21lbnRUb1N0cmluZyhjdXJyZW50SXRlbSl9YCk7XG4gICAgICAgIGludGVyc3RpdGlhbC5oYXNQbGF5ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5JTlRFUlNUSVRJQUxfRU5ERUQsIHtcbiAgICAgICAgICBldmVudDogaW50ZXJzdGl0aWFsLFxuICAgICAgICAgIHNjaGVkdWxlOiBzY2hlZHVsZUl0ZW1zLnNsaWNlKDApLFxuICAgICAgICAgIHNjaGVkdWxlSW5kZXg6IGluZGV4XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBFeGl0aW5nIGFuIEludGVyc3RpdGlhbFxuICAgICAgICBpZiAoaW50ZXJzdGl0aWFsLmN1ZS5vbmNlKSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIGludGVyc3RpdGlhbCB3aXRoIENVRSBhdHRyaWJ1dGUgdmFsdWUgb2YgT05DRSBhZnRlciBpdCBoYXMgcGxheWVkXG4gICAgICAgICAgdGhpcy51cGRhdGVTY2hlZHVsZSgpO1xuICAgICAgICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5zY2hlZHVsZS5pdGVtcztcbiAgICAgICAgICBpZiAoc2NoZWR1bGVkSXRlbSAmJiBpdGVtcykge1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZEluZGV4ID0gdGhpcy5maW5kSXRlbUluZGV4KHNjaGVkdWxlZEl0ZW0pO1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlU2NoZWR1bGUodXBkYXRlZEluZGV4LCBpdGVtcywgYXNzZXRMaXN0SW5kZXgsIGN1cnJlbnRJdGVtLCBwbGF5aW5nTGFzdEl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5hZHZhbmNlU2NoZWR1bGUoaW5kZXgsIHNjaGVkdWxlSXRlbXMsIGFzc2V0TGlzdEluZGV4LCBjdXJyZW50SXRlbSwgcGxheWluZ0xhc3RJdGVtKTtcbiAgfVxuICBhZHZhbmNlU2NoZWR1bGUoaW5kZXgsIHNjaGVkdWxlSXRlbXMsIGFzc2V0TGlzdEluZGV4LCBjdXJyZW50SXRlbSwgcGxheWVkTGFzdEl0ZW0pIHtcbiAgICBjb25zdCBzY2hlZHVsZWRJdGVtID0gaW5kZXggPj0gMCA/IHNjaGVkdWxlSXRlbXNbaW5kZXhdIDogbnVsbDtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMucHJpbWFyeU1lZGlhO1xuICAgIC8vIENsZWFudXAgb3V0IG9mIHJhbmdlIEludGVyc3RpdGlhbHNcbiAgICBjb25zdCBwbGF5ZXJRdWV1ZSA9IHRoaXMucGxheWVyUXVldWU7XG4gICAgaWYgKHBsYXllclF1ZXVlLmxlbmd0aCkge1xuICAgICAgcGxheWVyUXVldWUuZm9yRWFjaChwbGF5ZXIgPT4ge1xuICAgICAgICBjb25zdCBpbnRlcnN0aXRpYWwgPSBwbGF5ZXIuaW50ZXJzdGl0aWFsO1xuICAgICAgICBjb25zdCBxdWV1ZWRJbmRleCA9IHRoaXMuc2NoZWR1bGUuZmluZEV2ZW50SW5kZXgoaW50ZXJzdGl0aWFsLmlkZW50aWZpZXIpO1xuICAgICAgICBpZiAocXVldWVkSW5kZXggPCBpbmRleCB8fCBxdWV1ZWRJbmRleCA+IGluZGV4ICsgMSkge1xuICAgICAgICAgIHRoaXMuY2xlYXJJbnRlcnN0aXRpYWwoaW50ZXJzdGl0aWFsLCBzY2hlZHVsZWRJdGVtKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFNldHVwIHNjaGVkdWxlZCBpdGVtXG4gICAgaWYgKHRoaXMuaXNJbnRlcnN0aXRpYWwoc2NoZWR1bGVkSXRlbSkpIHtcbiAgICAgIHRoaXMudGltZWxpbmVQb3MgPSBNYXRoLm1pbihNYXRoLm1heCh0aGlzLnRpbWVsaW5lUG9zLCBzY2hlZHVsZWRJdGVtLnN0YXJ0KSwgc2NoZWR1bGVkSXRlbS5lbmQpO1xuICAgICAgLy8gSGFuZGxlIEludGVyc3RpdGlhbFxuICAgICAgY29uc3QgaW50ZXJzdGl0aWFsID0gc2NoZWR1bGVkSXRlbS5ldmVudDtcbiAgICAgIC8vIGZpbmQgYXNzZXQgaW5kZXhcbiAgICAgIGlmIChhc3NldExpc3RJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFzc2V0TGlzdEluZGV4ID0gdGhpcy5zY2hlZHVsZS5maW5kQXNzZXRJbmRleChpbnRlcnN0aXRpYWwsIHRoaXMudGltZWxpbmVQb3MpO1xuICAgICAgICBjb25zdCBhc3NldEluZGV4Q2FuZGlkYXRlID0gZ2V0TmV4dEFzc2V0SW5kZXgoaW50ZXJzdGl0aWFsLCBhc3NldExpc3RJbmRleCAtIDEpO1xuICAgICAgICBpZiAoaW50ZXJzdGl0aWFsLmlzQXNzZXRQYXN0UGxheW91dExpbWl0KGFzc2V0SW5kZXhDYW5kaWRhdGUpKSB7XG4gICAgICAgICAgdGhpcy5hZHZhbmNlQWZ0ZXJBc3NldEVuZGVkKGludGVyc3RpdGlhbCwgaW5kZXgsIGFzc2V0TGlzdEluZGV4KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXRMaXN0SW5kZXggPSBhc3NldEluZGV4Q2FuZGlkYXRlO1xuICAgICAgfVxuICAgICAgLy8gRW5zdXJlIEludGVyc3RpdGlhbCBpcyBlbnF1ZXVlZFxuICAgICAgY29uc3Qgd2FpdGluZ0l0ZW0gPSB0aGlzLndhaXRpbmdJdGVtO1xuICAgICAgaWYgKCF0aGlzLmFzc2V0c0J1ZmZlcmVkKHNjaGVkdWxlZEl0ZW0sIG1lZGlhKSkge1xuICAgICAgICB0aGlzLnNldEJ1ZmZlcmluZ0l0ZW0oc2NoZWR1bGVkSXRlbSk7XG4gICAgICB9XG4gICAgICBsZXQgcGxheWVyID0gdGhpcy5wcmVsb2FkQXNzZXRzKGludGVyc3RpdGlhbCwgYXNzZXRMaXN0SW5kZXgpO1xuICAgICAgaWYgKCF0aGlzLmV2ZW50SXRlbXNNYXRjaChzY2hlZHVsZWRJdGVtLCB3YWl0aW5nSXRlbSB8fCBjdXJyZW50SXRlbSkpIHtcbiAgICAgICAgdGhpcy53YWl0aW5nSXRlbSA9IHNjaGVkdWxlZEl0ZW07XG4gICAgICAgIHRoaXMubG9nKGBJTlRFUlNUSVRJQUxfU1RBUlRFRCAke3NlZ21lbnRUb1N0cmluZyhzY2hlZHVsZWRJdGVtKX0gJHtpbnRlcnN0aXRpYWwuYXBwZW5kSW5QbGFjZSA/ICdhcHBlbmQgaW4gcGxhY2UnIDogJyd9YCk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLklOVEVSU1RJVElBTF9TVEFSVEVELCB7XG4gICAgICAgICAgZXZlbnQ6IGludGVyc3RpdGlhbCxcbiAgICAgICAgICBzY2hlZHVsZTogc2NoZWR1bGVJdGVtcy5zbGljZSgwKSxcbiAgICAgICAgICBzY2hlZHVsZUluZGV4OiBpbmRleFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghaW50ZXJzdGl0aWFsLmFzc2V0TGlzdExvYWRlZCkge1xuICAgICAgICAvLyBXYWl0aW5nIGF0IGVuZCBvZiBwcmltYXJ5IGNvbnRlbnQgc2VnbWVudFxuICAgICAgICAvLyBFeHBlY3Qgc2V0U2NoZWR1bGVQb3NpdGlvbiB0byBiZSBjYWxsZWQgYWdhaW4gb25jZSBBU1NFVC1MSVNUIGlzIGxvYWRlZFxuICAgICAgICB0aGlzLmxvZyhgV2FpdGluZyBmb3IgQVNTRVQtTElTVCB0byBjb21wbGV0ZSBsb2FkaW5nICR7aW50ZXJzdGl0aWFsfWApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaW50ZXJzdGl0aWFsLmFzc2V0TGlzdExvYWRlcikge1xuICAgICAgICBpbnRlcnN0aXRpYWwuYXNzZXRMaXN0TG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgICAgaW50ZXJzdGl0aWFsLmFzc2V0TGlzdExvYWRlciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmICghbWVkaWEpIHtcbiAgICAgICAgdGhpcy5sb2coYFdhaXRpbmcgZm9yIGF0dGFjaE1lZGlhIHRvIHN0YXJ0IEludGVyc3RpdGlhbCAke2ludGVyc3RpdGlhbH1gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gVXBkYXRlIHNjaGVkdWxlIGFuZCBhc3NldCBsaXN0IHBvc2l0aW9uIG5vdyB0aGF0IGl0IGNhbiBzdGFydFxuICAgICAgdGhpcy53YWl0aW5nSXRlbSA9IHRoaXMuZW5kZWRJdGVtID0gbnVsbDtcbiAgICAgIHRoaXMucGxheWluZ0l0ZW0gPSBzY2hlZHVsZWRJdGVtO1xuXG4gICAgICAvLyBJZiBhc3NldC1saXN0IGlzIGVtcHR5IG9yIG1pc3NpbmcgYXNzZXQgaW5kZXgsIGFkdmFuY2UgdG8gbmV4dCBpdGVtXG4gICAgICBjb25zdCBhc3NldEl0ZW0gPSBpbnRlcnN0aXRpYWwuYXNzZXRMaXN0W2Fzc2V0TGlzdEluZGV4XTtcbiAgICAgIGlmICghYXNzZXRJdGVtKSB7XG4gICAgICAgIGNvbnN0IG5leHRJdGVtID0gc2NoZWR1bGVJdGVtc1tpbmRleCArIDFdO1xuICAgICAgICBjb25zdCBfbWVkaWEyID0gdGhpcy5tZWRpYTtcbiAgICAgICAgaWYgKG5leHRJdGVtICYmIF9tZWRpYTIgJiYgIXRoaXMuaXNJbnRlcnN0aXRpYWwobmV4dEl0ZW0pICYmIF9tZWRpYTIuY3VycmVudFRpbWUgPCBuZXh0SXRlbS5zdGFydCkge1xuICAgICAgICAgIF9tZWRpYTIuY3VycmVudFRpbWUgPSB0aGlzLnRpbWVsaW5lUG9zID0gbmV4dEl0ZW0uc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZHZhbmNlQWZ0ZXJBc3NldEVuZGVkKGludGVyc3RpdGlhbCwgaW5kZXgsIGFzc2V0TGlzdEluZGV4IHx8IDApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFN0YXJ0IEludGVyc3RpdGlhbCBQbGF5YmFja1xuICAgICAgaWYgKCFwbGF5ZXIpIHtcbiAgICAgICAgcGxheWVyID0gdGhpcy5nZXRBc3NldFBsYXllcihhc3NldEl0ZW0uaWRlbnRpZmllcik7XG4gICAgICB9XG4gICAgICBpZiAocGxheWVyID09PSBudWxsIHx8IHBsYXllci5kZXN0cm95ZWQpIHtcbiAgICAgICAgY29uc3QgYXNzZXRMaXN0TGVuZ3RoID0gaW50ZXJzdGl0aWFsLmFzc2V0TGlzdC5sZW5ndGg7XG4gICAgICAgIHRoaXMud2FybihgYXNzZXQgJHthc3NldExpc3RJbmRleCArIDF9LyR7YXNzZXRMaXN0TGVuZ3RofSBwbGF5ZXIgZGVzdHJveWVkICR7aW50ZXJzdGl0aWFsfWApO1xuICAgICAgICBwbGF5ZXIgPSB0aGlzLmNyZWF0ZUFzc2V0UGxheWVyKGludGVyc3RpdGlhbCwgYXNzZXRJdGVtLCBhc3NldExpc3RJbmRleCk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuZXZlbnRJdGVtc01hdGNoKHNjaGVkdWxlZEl0ZW0sIHRoaXMuYnVmZmVyaW5nSXRlbSkpIHtcbiAgICAgICAgaWYgKGludGVyc3RpdGlhbC5hcHBlbmRJblBsYWNlICYmIHRoaXMuaXNBc3NldEJ1ZmZlcmVkKGFzc2V0SXRlbSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhcnRBc3NldFBsYXllcihwbGF5ZXIsIGFzc2V0TGlzdEluZGV4LCBzY2hlZHVsZUl0ZW1zLCBpbmRleCwgbWVkaWEpO1xuICAgICAgaWYgKHRoaXMuc2hvdWxkUGxheSkge1xuICAgICAgICBwbGF5V2l0aENhdGNoKHBsYXllci5tZWRpYSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzY2hlZHVsZWRJdGVtICE9PSBudWxsKSB7XG4gICAgICB0aGlzLnJlc3VtZVByaW1hcnkoc2NoZWR1bGVkSXRlbSwgaW5kZXgsIGN1cnJlbnRJdGVtKTtcbiAgICAgIGlmICh0aGlzLnNob3VsZFBsYXkpIHtcbiAgICAgICAgcGxheVdpdGhDYXRjaCh0aGlzLmhscy5tZWRpYSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwbGF5ZWRMYXN0SXRlbSAmJiB0aGlzLmlzSW50ZXJzdGl0aWFsKGN1cnJlbnRJdGVtKSkge1xuICAgICAgLy8gTWFpbnRhaW4gcGxheWluZ0l0ZW0gc3RhdGUgYXQgZW5kIG9mIHNjaGVkdWxlIChzZXRTY2hlZHVsZVBvc2l0aW9uKC0xKSBjYWxsZWQgdG8gZW5kIHByb2dyYW0pXG4gICAgICAvLyB0aGlzIGFsbG93cyBvblNlZWtpbmcgaGFuZGxlciB0byB1cGRhdGUgc2NoZWR1bGUgcG9zaXRpb25cbiAgICAgIHRoaXMuZW5kZWRJdGVtID0gbnVsbDtcbiAgICAgIHRoaXMucGxheWluZ0l0ZW0gPSBjdXJyZW50SXRlbTtcbiAgICAgIGlmICghY3VycmVudEl0ZW0uZXZlbnQuYXBwZW5kSW5QbGFjZSkge1xuICAgICAgICAvLyBNZWRpYSBtdXN0IGJlIHJlLWF0dGFjaGVkIHRvIHJlc3VtZSBwcmltYXJ5IHNjaGVkdWxlIGlmIG5vdCBzaGFyaW5nIHNvdXJjZVxuICAgICAgICB0aGlzLmF0dGFjaFByaW1hcnkodGhpcy5zY2hlZHVsZS5kdXJhdGlvbnMucHJpbWFyeSwgbnVsbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBwbGF5YmFja0Rpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmhscy5jb25maWcuZW5hYmxlSW50ZXJzdGl0aWFsUGxheWJhY2sgPT09IGZhbHNlO1xuICB9XG4gIGdldCBwcmltYXJ5RGV0YWlscygpIHtcbiAgICB2YXIgX3RoaXMkbWVkaWFTZWxlY3Rpb24sIF90aGlzJG1lZGlhU2VsZWN0aW9uJDtcbiAgICByZXR1cm4gKF90aGlzJG1lZGlhU2VsZWN0aW9uID0gdGhpcy5tZWRpYVNlbGVjdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IChfdGhpcyRtZWRpYVNlbGVjdGlvbiQgPSBfdGhpcyRtZWRpYVNlbGVjdGlvbi5tYWluKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbWVkaWFTZWxlY3Rpb24kLmRldGFpbHM7XG4gIH1cbiAgZ2V0IHByaW1hcnlMaXZlKCkge1xuICAgIHZhciBfdGhpcyRwcmltYXJ5RGV0YWlscztcbiAgICByZXR1cm4gISEoKF90aGlzJHByaW1hcnlEZXRhaWxzID0gdGhpcy5wcmltYXJ5RGV0YWlscykgIT0gbnVsbCAmJiBfdGhpcyRwcmltYXJ5RGV0YWlscy5saXZlKTtcbiAgfVxuICByZXN1bWVQcmltYXJ5KHNjaGVkdWxlZEl0ZW0sIGluZGV4LCBmcm9tSXRlbSkge1xuICAgIHZhciBfdGhpcyRkZXRhY2hlZERhdGE0O1xuICAgIHRoaXMucGxheWluZ0l0ZW0gPSBzY2hlZHVsZWRJdGVtO1xuICAgIHRoaXMucGxheWluZ0Fzc2V0ID0gdGhpcy5lbmRlZEFzc2V0ID0gbnVsbDtcbiAgICB0aGlzLndhaXRpbmdJdGVtID0gdGhpcy5lbmRlZEl0ZW0gPSBudWxsO1xuICAgIHRoaXMuYnVmZmVyZWRUb0l0ZW0oc2NoZWR1bGVkSXRlbSk7XG4gICAgdGhpcy5sb2coYHJlc3VtaW5nICR7c2VnbWVudFRvU3RyaW5nKHNjaGVkdWxlZEl0ZW0pfWApO1xuICAgIGlmICghKChfdGhpcyRkZXRhY2hlZERhdGE0ID0gdGhpcy5kZXRhY2hlZERhdGEpICE9IG51bGwgJiYgX3RoaXMkZGV0YWNoZWREYXRhNC5tZWRpYVNvdXJjZSkpIHtcbiAgICAgIGxldCB0aW1lbGluZVBvcyA9IHRoaXMudGltZWxpbmVQb3M7XG4gICAgICBpZiAodGltZWxpbmVQb3MgPCBzY2hlZHVsZWRJdGVtLnN0YXJ0IHx8IHRpbWVsaW5lUG9zID49IHNjaGVkdWxlZEl0ZW0uZW5kKSB7XG4gICAgICAgIHRpbWVsaW5lUG9zID0gdGhpcy5nZXRQcmltYXJ5UmVzdW1wdGlvbihzY2hlZHVsZWRJdGVtLCBpbmRleCk7XG4gICAgICAgIHRoaXMudGltZWxpbmVQb3MgPSB0aW1lbGluZVBvcztcbiAgICAgIH1cbiAgICAgIHRoaXMuYXR0YWNoUHJpbWFyeSh0aW1lbGluZVBvcywgc2NoZWR1bGVkSXRlbSk7XG4gICAgfVxuICAgIGlmICghZnJvbUl0ZW0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2NoZWR1bGVJdGVtcyA9IHRoaXMuc2NoZWR1bGUuaXRlbXM7XG4gICAgaWYgKCFzY2hlZHVsZUl0ZW1zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubG9nKGBJTlRFUlNUSVRJQUxTX1BSSU1BUllfUkVTVU1FRCAke3NlZ21lbnRUb1N0cmluZyhzY2hlZHVsZWRJdGVtKX1gKTtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5JTlRFUlNUSVRJQUxTX1BSSU1BUllfUkVTVU1FRCwge1xuICAgICAgc2NoZWR1bGU6IHNjaGVkdWxlSXRlbXMuc2xpY2UoMCksXG4gICAgICBzY2hlZHVsZUluZGV4OiBpbmRleFxuICAgIH0pO1xuICAgIHRoaXMuY2hlY2tCdWZmZXIoKTtcbiAgfVxuICBnZXRQcmltYXJ5UmVzdW1wdGlvbihzY2hlZHVsZWRJdGVtLCBpbmRleCkge1xuICAgIGNvbnN0IGl0ZW1TdGFydCA9IHNjaGVkdWxlZEl0ZW0uc3RhcnQ7XG4gICAgaWYgKHRoaXMucHJpbWFyeUxpdmUpIHtcbiAgICAgIGNvbnN0IGRldGFpbHMgPSB0aGlzLnByaW1hcnlEZXRhaWxzO1xuICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhscy5zdGFydFBvc2l0aW9uO1xuICAgICAgfSBlbHNlIGlmIChkZXRhaWxzICYmIChpdGVtU3RhcnQgPCBkZXRhaWxzLmZyYWdtZW50U3RhcnQgfHwgaXRlbVN0YXJ0ID4gZGV0YWlscy5lZGdlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5obHMubGl2ZVN5bmNQb3NpdGlvbiB8fCAtMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGl0ZW1TdGFydDtcbiAgfVxuICBpc0Fzc2V0QnVmZmVyZWQoYXNzZXQpIHtcbiAgICBjb25zdCBwbGF5ZXIgPSB0aGlzLmdldEFzc2V0UGxheWVyKGFzc2V0LmlkZW50aWZpZXIpO1xuICAgIGlmIChwbGF5ZXIgIT0gbnVsbCAmJiBwbGF5ZXIuaGxzKSB7XG4gICAgICByZXR1cm4gcGxheWVyLmhscy5idWZmZXJlZFRvRW5kO1xuICAgIH1cbiAgICBjb25zdCBidWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8odGhpcy5wcmltYXJ5TWVkaWEsIHRoaXMudGltZWxpbmVQb3MsIDApO1xuICAgIHJldHVybiBidWZmZXJJbmZvLmVuZCArIDEgPj0gYXNzZXQudGltZWxpbmVTdGFydCArIChhc3NldC5kdXJhdGlvbiB8fCAwKTtcbiAgfVxuICBhdHRhY2hQcmltYXJ5KHRpbWVsaW5lUG9zLCBpdGVtLCBza2lwU2Vla1RvU3RhcnRQb3NpdGlvbikge1xuICAgIGlmIChpdGVtKSB7XG4gICAgICB0aGlzLnNldEJ1ZmZlcmluZ0l0ZW0oaXRlbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYnVmZmVyaW5nSXRlbSA9IHRoaXMucGxheWluZ0l0ZW07XG4gICAgfVxuICAgIHRoaXMuYnVmZmVyaW5nQXNzZXQgPSBudWxsO1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5wcmltYXJ5TWVkaWE7XG4gICAgaWYgKCFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBpZiAoaGxzLm1lZGlhKSB7XG4gICAgICB0aGlzLmNoZWNrQnVmZmVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudHJhbnNmZXJNZWRpYVRvKGhscywgbWVkaWEpO1xuICAgICAgaWYgKHNraXBTZWVrVG9TdGFydFBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuc3RhcnRMb2FkaW5nUHJpbWFyeUF0KHRpbWVsaW5lUG9zLCBza2lwU2Vla1RvU3RhcnRQb3NpdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghc2tpcFNlZWtUb1N0YXJ0UG9zaXRpb24pIHtcbiAgICAgIC8vIFNldCBwcmltYXJ5IHBvc2l0aW9uIHRvIHJlc3VtZSB0aW1lXG4gICAgICB0aGlzLnRpbWVsaW5lUG9zID0gdGltZWxpbmVQb3M7XG4gICAgICB0aGlzLnN0YXJ0TG9hZGluZ1ByaW1hcnlBdCh0aW1lbGluZVBvcywgc2tpcFNlZWtUb1N0YXJ0UG9zaXRpb24pO1xuICAgIH1cbiAgfVxuICBzdGFydExvYWRpbmdQcmltYXJ5QXQodGltZWxpbmVQb3MsIHNraXBTZWVrVG9TdGFydFBvc2l0aW9uKSB7XG4gICAgdmFyIF9obHMkbWFpbkZvcndhcmRCdWZmZTtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBpZiAoIWhscy5sb2FkaW5nRW5hYmxlZCB8fCAhaGxzLm1lZGlhIHx8IE1hdGguYWJzKCgoKF9obHMkbWFpbkZvcndhcmRCdWZmZSA9IGhscy5tYWluRm9yd2FyZEJ1ZmZlckluZm8pID09IG51bGwgPyB2b2lkIDAgOiBfaGxzJG1haW5Gb3J3YXJkQnVmZmUuc3RhcnQpIHx8IGhscy5tZWRpYS5jdXJyZW50VGltZSkgLSB0aW1lbGluZVBvcykgPiAwLjUpIHtcbiAgICAgIGhscy5zdGFydExvYWQodGltZWxpbmVQb3MsIHNraXBTZWVrVG9TdGFydFBvc2l0aW9uKTtcbiAgICB9IGVsc2UgaWYgKCFobHMuYnVmZmVyaW5nRW5hYmxlZCkge1xuICAgICAgaGxzLnJlc3VtZUJ1ZmZlcmluZygpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEhMUy5qcyBldmVudCBjYWxsYmFja3NcbiAgb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgIHRoaXMuc2NoZWR1bGUucmVzZXQoKTtcbiAgICB0aGlzLmVtcHR5UGxheWVyUXVldWUoKTtcbiAgICB0aGlzLmNsZWFyU2NoZWR1bGVTdGF0ZSgpO1xuICAgIHRoaXMuc2hvdWxkUGxheSA9IGZhbHNlO1xuICAgIHRoaXMuYnVmZmVyZWRQb3MgPSB0aGlzLnRpbWVsaW5lUG9zID0gLTE7XG4gICAgdGhpcy5tZWRpYVNlbGVjdGlvbiA9IHRoaXMuYWx0U2VsZWN0aW9uID0gdGhpcy5tYW5hZ2VyID0gdGhpcy5yZXF1aXJlZFRyYWNrcyA9IG51bGw7XG4gICAgLy8gQlVGRkVSX0NPREVDUyBsaXN0ZW5lciBhZGRlZCBoZXJlIGZvciBidWZmZXItY29udHJvbGxlciB0byBoYW5kbGUgaXQgZmlyc3Qgd2hlcmUgaXQgYWRkcyB0cmFja3NcbiAgICB0aGlzLmhscy5vZmYoRXZlbnRzLkJVRkZFUl9DT0RFQ1MsIHRoaXMub25CdWZmZXJDb2RlY3MsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9uKEV2ZW50cy5CVUZGRVJfQ09ERUNTLCB0aGlzLm9uQnVmZmVyQ29kZWNzLCB0aGlzKTtcbiAgfVxuICBvbkxldmVsVXBkYXRlZChldmVudCwgZGF0YSkge1xuICAgIGlmIChkYXRhLmxldmVsID09PSAtMSkge1xuICAgICAgLy8gbGV2ZWwgd2FzIHJlbW92ZWRcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWFpbiA9IHRoaXMuaGxzLmxldmVsc1tkYXRhLmxldmVsXTtcbiAgICBjb25zdCBjdXJyZW50U2VsZWN0aW9uID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHRoaXMubWVkaWFTZWxlY3Rpb24gfHwgdGhpcy5hbHRTZWxlY3Rpb24pLCB7fSwge1xuICAgICAgbWFpblxuICAgIH0pO1xuICAgIHRoaXMubWVkaWFTZWxlY3Rpb24gPSBjdXJyZW50U2VsZWN0aW9uO1xuICAgIHRoaXMuc2NoZWR1bGUucGFyc2VJbnRlcnN0aXRpYWxEYXRlUmFuZ2VzKGN1cnJlbnRTZWxlY3Rpb24sIHRoaXMuaGxzLmNvbmZpZy5pbnRlcnN0aXRpYWxBcHBlbmRJblBsYWNlKTtcbiAgICBpZiAoIXRoaXMuZWZmZWN0aXZlUGxheWluZ0l0ZW0gJiYgdGhpcy5zY2hlZHVsZS5pdGVtcykge1xuICAgICAgdGhpcy5jaGVja1N0YXJ0KCk7XG4gICAgfVxuICB9XG4gIG9uQXVkaW9UcmFja1VwZGF0ZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCBhdWRpbyA9IHRoaXMuaGxzLmF1ZGlvVHJhY2tzW2RhdGEuaWRdO1xuICAgIGNvbnN0IHByZXZpb3VzU2VsZWN0aW9uID0gdGhpcy5tZWRpYVNlbGVjdGlvbjtcbiAgICBpZiAoIXByZXZpb3VzU2VsZWN0aW9uKSB7XG4gICAgICB0aGlzLmFsdFNlbGVjdGlvbiA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCB0aGlzLmFsdFNlbGVjdGlvbiksIHt9LCB7XG4gICAgICAgIGF1ZGlvXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFNlbGVjdGlvbiA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBwcmV2aW91c1NlbGVjdGlvbiksIHt9LCB7XG4gICAgICBhdWRpb1xuICAgIH0pO1xuICAgIHRoaXMubWVkaWFTZWxlY3Rpb24gPSBjdXJyZW50U2VsZWN0aW9uO1xuICB9XG4gIG9uU3VidGl0bGVUcmFja1VwZGF0ZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCBzdWJ0aXRsZXMgPSB0aGlzLmhscy5zdWJ0aXRsZVRyYWNrc1tkYXRhLmlkXTtcbiAgICBjb25zdCBwcmV2aW91c1NlbGVjdGlvbiA9IHRoaXMubWVkaWFTZWxlY3Rpb247XG4gICAgaWYgKCFwcmV2aW91c1NlbGVjdGlvbikge1xuICAgICAgdGhpcy5hbHRTZWxlY3Rpb24gPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgdGhpcy5hbHRTZWxlY3Rpb24pLCB7fSwge1xuICAgICAgICBzdWJ0aXRsZXNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50U2VsZWN0aW9uID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHByZXZpb3VzU2VsZWN0aW9uKSwge30sIHtcbiAgICAgIHN1YnRpdGxlc1xuICAgIH0pO1xuICAgIHRoaXMubWVkaWFTZWxlY3Rpb24gPSBjdXJyZW50U2VsZWN0aW9uO1xuICB9XG4gIG9uQXVkaW9UcmFja1N3aXRjaGluZyhldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IGF1ZGlvT3B0aW9uID0gZ2V0QmFzaWNTZWxlY3Rpb25PcHRpb24oZGF0YSk7XG4gICAgdGhpcy5wbGF5ZXJRdWV1ZS5mb3JFYWNoKHBsYXllciA9PiBwbGF5ZXIuaGxzLnNldEF1ZGlvT3B0aW9uKGRhdGEpIHx8IHBsYXllci5obHMuc2V0QXVkaW9PcHRpb24oYXVkaW9PcHRpb24pKTtcbiAgfVxuICBvblN1YnRpdGxlVHJhY2tTd2l0Y2goZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCBzdWJ0aXRsZU9wdGlvbiA9IGdldEJhc2ljU2VsZWN0aW9uT3B0aW9uKGRhdGEpO1xuICAgIHRoaXMucGxheWVyUXVldWUuZm9yRWFjaChwbGF5ZXIgPT4gcGxheWVyLmhscy5zZXRTdWJ0aXRsZU9wdGlvbihkYXRhKSB8fCBkYXRhLmlkICE9PSAtMSAmJiBwbGF5ZXIuaGxzLnNldFN1YnRpdGxlT3B0aW9uKHN1YnRpdGxlT3B0aW9uKSk7XG4gIH1cbiAgb25CdWZmZXJDb2RlY3MoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXF1aXJlZFRyYWNrcyA9IGRhdGEudHJhY2tzO1xuICAgIGlmIChyZXF1aXJlZFRyYWNrcykge1xuICAgICAgdGhpcy5yZXF1aXJlZFRyYWNrcyA9IHJlcXVpcmVkVHJhY2tzO1xuICAgIH1cbiAgfVxuICBvbkJ1ZmZlckFwcGVuZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5jaGVja0J1ZmZlcigpO1xuICB9XG4gIG9uQnVmZmVyRmx1c2hlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHBsYXlpbmdJdGVtID0gdGhpcy5wbGF5aW5nSXRlbTtcbiAgICBpZiAocGxheWluZ0l0ZW0gJiYgIXRoaXMuaXRlbXNNYXRjaChwbGF5aW5nSXRlbSwgdGhpcy5idWZmZXJpbmdJdGVtKSAmJiAhdGhpcy5pc0ludGVyc3RpdGlhbChwbGF5aW5nSXRlbSkpIHtcbiAgICAgIGNvbnN0IHRpbWVsaW5lUG9zID0gdGhpcy50aW1lbGluZVBvcztcbiAgICAgIHRoaXMuYnVmZmVyZWRQb3MgPSB0aW1lbGluZVBvcztcbiAgICAgIHRoaXMuY2hlY2tCdWZmZXIoKTtcbiAgICB9XG4gIH1cbiAgb25CdWZmZXJlZFRvRW5kKGV2ZW50KSB7XG4gICAgLy8gQnVmZmVyZWQgdG8gcG9zdC1yb2xsXG4gICAgY29uc3QgaW50ZXJzdGl0aWFsRXZlbnRzID0gdGhpcy5zY2hlZHVsZS5ldmVudHM7XG4gICAgaWYgKHRoaXMuYnVmZmVyZWRQb3MgPCBOdW1iZXIuTUFYX1ZBTFVFICYmIGludGVyc3RpdGlhbEV2ZW50cykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnRlcnN0aXRpYWxFdmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaW50ZXJzdGl0aWFsID0gaW50ZXJzdGl0aWFsRXZlbnRzW2ldO1xuICAgICAgICBpZiAoaW50ZXJzdGl0aWFsLmN1ZS5wb3N0KSB7XG4gICAgICAgICAgdmFyIF90aGlzJHNjaGVkdWxlJGl0ZW1zO1xuICAgICAgICAgIGNvbnN0IHNjaGVkdWxlSW5kZXggPSB0aGlzLnNjaGVkdWxlLmZpbmRFdmVudEluZGV4KGludGVyc3RpdGlhbC5pZGVudGlmaWVyKTtcbiAgICAgICAgICBjb25zdCBpdGVtID0gKF90aGlzJHNjaGVkdWxlJGl0ZW1zID0gdGhpcy5zY2hlZHVsZS5pdGVtcykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHNjaGVkdWxlJGl0ZW1zW3NjaGVkdWxlSW5kZXhdO1xuICAgICAgICAgIGlmICh0aGlzLmlzSW50ZXJzdGl0aWFsKGl0ZW0pICYmIHRoaXMuZXZlbnRJdGVtc01hdGNoKGl0ZW0sIHRoaXMuYnVmZmVyaW5nSXRlbSkpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyZWRUb0l0ZW0oaXRlbSwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmJ1ZmZlcmVkUG9zID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB9XG4gIH1cbiAgb25NZWRpYUVuZGVkKGV2ZW50KSB7XG4gICAgY29uc3QgcGxheWluZ0l0ZW0gPSB0aGlzLnBsYXlpbmdJdGVtO1xuICAgIGlmICghdGhpcy5wbGF5aW5nTGFzdEl0ZW0gJiYgcGxheWluZ0l0ZW0pIHtcbiAgICAgIGNvbnN0IHBsYXlpbmdJbmRleCA9IHRoaXMuZmluZEl0ZW1JbmRleChwbGF5aW5nSXRlbSk7XG4gICAgICB0aGlzLnNldFNjaGVkdWxlUG9zaXRpb24ocGxheWluZ0luZGV4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2hvdWxkUGxheSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICB1cGRhdGVJdGVtKHByZXZpb3VzSXRlbSwgdGltZSkge1xuICAgIC8vIGZpbmQgaXRlbSBpbiB0aGlzLnNjaGVkdWxlLml0ZW1zO1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5zY2hlZHVsZS5pdGVtcztcbiAgICBpZiAocHJldmlvdXNJdGVtICYmIGl0ZW1zKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuZmluZEl0ZW1JbmRleChwcmV2aW91c0l0ZW0sIHRpbWUpO1xuICAgICAgcmV0dXJuIGl0ZW1zW2luZGV4XSB8fCBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0cmltSW5QbGFjZSh1cGRhdGVkSXRlbSwgaXRlbUJlZm9yZVVwZGF0ZSkge1xuICAgIGlmICh0aGlzLmlzSW50ZXJzdGl0aWFsKHVwZGF0ZWRJdGVtKSAmJiB1cGRhdGVkSXRlbS5ldmVudC5hcHBlbmRJblBsYWNlICYmIGl0ZW1CZWZvcmVVcGRhdGUuZW5kIC0gdXBkYXRlZEl0ZW0uZW5kID4gMC4yNSkge1xuICAgICAgdXBkYXRlZEl0ZW0uZXZlbnQuYXNzZXRMaXN0LmZvckVhY2goKGFzc2V0LCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAodXBkYXRlZEl0ZW0uZXZlbnQuaXNBc3NldFBhc3RQbGF5b3V0TGltaXQoaW5kZXgpKSB7XG4gICAgICAgICAgdGhpcy5jbGVhckFzc2V0UGxheWVyKGFzc2V0LmlkZW50aWZpZXIsIG51bGwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGZsdXNoU3RhcnQgPSB1cGRhdGVkSXRlbS5lbmQgKyAwLjI1O1xuICAgICAgY29uc3QgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKHRoaXMucHJpbWFyeU1lZGlhLCBmbHVzaFN0YXJ0LCAwKTtcbiAgICAgIGlmIChidWZmZXJJbmZvLmVuZCA+IGZsdXNoU3RhcnQgfHwgKGJ1ZmZlckluZm8ubmV4dFN0YXJ0IHx8IDApID4gZmx1c2hTdGFydCkge1xuICAgICAgICB0aGlzLmF0dGFjaFByaW1hcnkoZmx1c2hTdGFydCwgbnVsbCk7XG4gICAgICAgIHRoaXMuZmx1c2hGcm9udEJ1ZmZlcihmbHVzaFN0YXJ0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaXRlbXNNYXRjaChhLCBiKSB7XG4gICAgcmV0dXJuICEhYiAmJiAoYSA9PT0gYiB8fCBhLmV2ZW50ICYmIGIuZXZlbnQgJiYgdGhpcy5ldmVudEl0ZW1zTWF0Y2goYSwgYikgfHwgIWEuZXZlbnQgJiYgIWIuZXZlbnQgJiYgdGhpcy5maW5kSXRlbUluZGV4KGEpID09PSB0aGlzLmZpbmRJdGVtSW5kZXgoYikpO1xuICB9XG4gIGV2ZW50SXRlbXNNYXRjaChhLCBiKSB7XG4gICAgdmFyIF9iJGV2ZW50O1xuICAgIHJldHVybiAhIWIgJiYgKGEgPT09IGIgfHwgYS5ldmVudC5pZGVudGlmaWVyID09PSAoKF9iJGV2ZW50ID0gYi5ldmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iJGV2ZW50LmlkZW50aWZpZXIpKTtcbiAgfVxuICBmaW5kSXRlbUluZGV4KGl0ZW0sIHRpbWUpIHtcbiAgICByZXR1cm4gaXRlbSA/IHRoaXMuc2NoZWR1bGUuZmluZEl0ZW1JbmRleChpdGVtLCB0aW1lKSA6IC0xO1xuICB9XG4gIHVwZGF0ZVNjaGVkdWxlKCkge1xuICAgIGNvbnN0IG1lZGlhU2VsZWN0aW9uID0gdGhpcy5tZWRpYVNlbGVjdGlvbjtcbiAgICBpZiAoIW1lZGlhU2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2NoZWR1bGUudXBkYXRlU2NoZWR1bGUobWVkaWFTZWxlY3Rpb24sIFtdKTtcbiAgfVxuXG4gIC8vIFNjaGVkdWxlIGJ1ZmZlciBjb250cm9sXG4gIGNoZWNrQnVmZmVyKHN0YXJ2ZWQpIHtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuc2NoZWR1bGUuaXRlbXM7XG4gICAgaWYgKCFpdGVtcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBGaW5kIHdoZW4gY29tYmluZWQgZm9yd2FyZCBidWZmZXIgY2hhbmdlIHJlYWNoZXMgbmV4dCBzY2hlZHVsZSBzZWdtZW50XG4gICAgY29uc3QgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKHRoaXMucHJpbWFyeU1lZGlhLCB0aGlzLnRpbWVsaW5lUG9zLCAwKTtcbiAgICBpZiAoc3RhcnZlZCkge1xuICAgICAgdGhpcy5idWZmZXJlZFBvcyA9IHRoaXMudGltZWxpbmVQb3M7XG4gICAgfVxuICAgIHN0YXJ2ZWQgfHwgKHN0YXJ2ZWQgPSBidWZmZXJJbmZvLmxlbiA8IDEpO1xuICAgIHRoaXMudXBkYXRlQnVmZmVyZWRQb3MoYnVmZmVySW5mby5lbmQsIGl0ZW1zLCBzdGFydmVkKTtcbiAgfVxuICB1cGRhdGVCdWZmZXJlZFBvcyhidWZmZXJFbmQsIGl0ZW1zLCBidWZmZXJJc0VtcHR5KSB7XG4gICAgY29uc3Qgc2NoZWR1bGUgPSB0aGlzLnNjaGVkdWxlO1xuICAgIGNvbnN0IGJ1ZmZlcmluZ0l0ZW0gPSB0aGlzLmJ1ZmZlcmluZ0l0ZW07XG4gICAgaWYgKHRoaXMuYnVmZmVyZWRQb3MgPiBidWZmZXJFbmQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMSAmJiB0aGlzLml0ZW1zTWF0Y2goaXRlbXNbMF0sIGJ1ZmZlcmluZ0l0ZW0pKSB7XG4gICAgICB0aGlzLmJ1ZmZlcmVkUG9zID0gYnVmZmVyRW5kO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwbGF5aW5nSXRlbSA9IHRoaXMucGxheWluZ0l0ZW07XG4gICAgY29uc3QgcGxheWluZ0luZGV4ID0gdGhpcy5maW5kSXRlbUluZGV4KHBsYXlpbmdJdGVtKTtcbiAgICBsZXQgYnVmZmVyRW5kSW5kZXggPSBzY2hlZHVsZS5maW5kSXRlbUluZGV4QXRUaW1lKGJ1ZmZlckVuZCk7XG4gICAgaWYgKHRoaXMuYnVmZmVyZWRQb3MgPCBidWZmZXJFbmQpIHtcbiAgICAgIHZhciBfbmV4dEl0ZW1Ub0J1ZmZlciRldmUsIF9idWZmZXJpbmdJdGVtJGV2ZW50O1xuICAgICAgY29uc3QgYnVmZmVyaW5nSW5kZXggPSB0aGlzLmZpbmRJdGVtSW5kZXgoYnVmZmVyaW5nSXRlbSk7XG4gICAgICBjb25zdCBuZXh0VG9CdWZmZXJJbmRleCA9IE1hdGgubWluKGJ1ZmZlcmluZ0luZGV4ICsgMSwgaXRlbXMubGVuZ3RoIC0gMSk7XG4gICAgICBjb25zdCBuZXh0SXRlbVRvQnVmZmVyID0gaXRlbXNbbmV4dFRvQnVmZmVySW5kZXhdO1xuICAgICAgaWYgKGJ1ZmZlckVuZEluZGV4ID09PSAtMSAmJiBidWZmZXJpbmdJdGVtICYmIGJ1ZmZlckVuZCA+PSBidWZmZXJpbmdJdGVtLmVuZCB8fCAoX25leHRJdGVtVG9CdWZmZXIkZXZlID0gbmV4dEl0ZW1Ub0J1ZmZlci5ldmVudCkgIT0gbnVsbCAmJiBfbmV4dEl0ZW1Ub0J1ZmZlciRldmUuYXBwZW5kSW5QbGFjZSAmJiBidWZmZXJFbmQgKyAwLjAxID49IG5leHRJdGVtVG9CdWZmZXIuc3RhcnQpIHtcbiAgICAgICAgYnVmZmVyRW5kSW5kZXggPSBuZXh0VG9CdWZmZXJJbmRleDtcbiAgICAgIH1cbiAgICAgIGlmIChuZXh0VG9CdWZmZXJJbmRleCAtIHBsYXlpbmdJbmRleCA+IDEgJiYgKGJ1ZmZlcmluZ0l0ZW0gPT0gbnVsbCA/IHZvaWQgMCA6IChfYnVmZmVyaW5nSXRlbSRldmVudCA9IGJ1ZmZlcmluZ0l0ZW0uZXZlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYnVmZmVyaW5nSXRlbSRldmVudC5hcHBlbmRJblBsYWNlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy8gZG8gbm90IGFkdmFuY2UgYnVmZmVyaW5nIGl0ZW0gcGFzdCBJbnRlcnN0aXRpYWwgdGhhdCByZXF1aXJlcyBzb3VyY2UgcmVzZXRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5idWZmZXJlZFBvcyA9IGJ1ZmZlckVuZDtcbiAgICAgIGlmIChidWZmZXJFbmRJbmRleCA+IGJ1ZmZlcmluZ0luZGV4ICYmIGJ1ZmZlckVuZEluZGV4ID4gcGxheWluZ0luZGV4KSB7XG4gICAgICAgIHRoaXMuYnVmZmVyZWRUb0l0ZW0obmV4dEl0ZW1Ub0J1ZmZlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBhbGxvdyBtb3JlIHRpbWUgdGhhbiBkaXN0YW5jZSBmcm9tIGVkZ2UgZm9yIGFzc2V0cyB0byBsb2FkXG4gICAgICAgIGNvbnN0IGRldGFpbHMgPSB0aGlzLnByaW1hcnlEZXRhaWxzO1xuICAgICAgICBpZiAodGhpcy5wcmltYXJ5TGl2ZSAmJiBkZXRhaWxzICYmIGJ1ZmZlckVuZCA+IGRldGFpbHMuZWRnZSAtIGRldGFpbHMudGFyZ2V0ZHVyYXRpb24gJiYgbmV4dEl0ZW1Ub0J1ZmZlci5zdGFydCA8IGRldGFpbHMuZWRnZSArIHRoaXMuaGxzLmNvbmZpZy5pbnRlcnN0aXRpYWxMaXZlTG9va0FoZWFkICYmIHRoaXMuaXNJbnRlcnN0aXRpYWwobmV4dEl0ZW1Ub0J1ZmZlcikpIHtcbiAgICAgICAgICB0aGlzLnByZWxvYWRBc3NldHMobmV4dEl0ZW1Ub0J1ZmZlci5ldmVudCwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGJ1ZmZlcklzRW1wdHkgJiYgcGxheWluZ0l0ZW0gJiYgIXRoaXMuaXRlbXNNYXRjaChwbGF5aW5nSXRlbSwgYnVmZmVyaW5nSXRlbSkpIHtcbiAgICAgIGlmIChidWZmZXJFbmRJbmRleCA9PT0gcGxheWluZ0luZGV4KSB7XG4gICAgICAgIHRoaXMuYnVmZmVyZWRUb0l0ZW0ocGxheWluZ0l0ZW0pO1xuICAgICAgfSBlbHNlIGlmIChidWZmZXJFbmRJbmRleCA9PT0gcGxheWluZ0luZGV4ICsgMSkge1xuICAgICAgICB0aGlzLmJ1ZmZlcmVkVG9JdGVtKGl0ZW1zW2J1ZmZlckVuZEluZGV4XSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFzc2V0c0J1ZmZlcmVkKGl0ZW0sIG1lZGlhKSB7XG4gICAgY29uc3QgYXNzZXRMaXN0ID0gaXRlbS5ldmVudC5hc3NldExpc3Q7XG4gICAgaWYgKGFzc2V0TGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuICFpdGVtLmV2ZW50LmFzc2V0TGlzdC5zb21lKGFzc2V0ID0+IHtcbiAgICAgIGNvbnN0IHBsYXllciA9IHRoaXMuZ2V0QXNzZXRQbGF5ZXIoYXNzZXQuaWRlbnRpZmllcik7XG4gICAgICByZXR1cm4gIShwbGF5ZXIgIT0gbnVsbCAmJiBwbGF5ZXIuYnVmZmVyZWRJblBsYWNlVG9FbmQobWVkaWEpKTtcbiAgICB9KTtcbiAgfVxuICBzZXRCdWZmZXJpbmdJdGVtKGl0ZW0pIHtcbiAgICBjb25zdCBidWZmZXJpbmdMYXN0ID0gdGhpcy5idWZmZXJpbmdJdGVtO1xuICAgIGNvbnN0IHNjaGVkdWxlID0gdGhpcy5zY2hlZHVsZTtcbiAgICBpZiAoIXRoaXMuaXRlbXNNYXRjaChpdGVtLCBidWZmZXJpbmdMYXN0KSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBpdGVtcyxcbiAgICAgICAgZXZlbnRzXG4gICAgICB9ID0gc2NoZWR1bGU7XG4gICAgICBpZiAoIWl0ZW1zIHx8ICFldmVudHMpIHtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcmluZ0xhc3Q7XG4gICAgICB9XG4gICAgICBjb25zdCBpc0ludGVyc3RpdGlhbCA9IHRoaXMuaXNJbnRlcnN0aXRpYWwoaXRlbSk7XG4gICAgICBjb25zdCBidWZmZXJpbmdQbGF5ZXIgPSB0aGlzLmdldEJ1ZmZlcmluZ1BsYXllcigpO1xuICAgICAgdGhpcy5idWZmZXJpbmdJdGVtID0gaXRlbTtcbiAgICAgIHRoaXMuYnVmZmVyZWRQb3MgPSBNYXRoLm1heChpdGVtLnN0YXJ0LCBNYXRoLm1pbihpdGVtLmVuZCwgdGhpcy50aW1lbGluZVBvcykpO1xuICAgICAgY29uc3QgdGltZVJlbWFpbmluZyA9IGJ1ZmZlcmluZ1BsYXllciA/IGJ1ZmZlcmluZ1BsYXllci5yZW1haW5pbmcgOiBidWZmZXJpbmdMYXN0ID8gYnVmZmVyaW5nTGFzdC5lbmQgLSB0aGlzLnRpbWVsaW5lUG9zIDogMDtcbiAgICAgIHRoaXMubG9nKGBJTlRFUlNUSVRJQUxTX0JVRkZFUkVEX1RPX0JPVU5EQVJZICR7c2VnbWVudFRvU3RyaW5nKGl0ZW0pfWAgKyAoYnVmZmVyaW5nTGFzdCA/IGAgKCR7dGltZVJlbWFpbmluZy50b0ZpeGVkKDIpfSByZW1haW5pbmcpYCA6ICcnKSk7XG4gICAgICBpZiAoIXRoaXMucGxheWJhY2tEaXNhYmxlZCkge1xuICAgICAgICBpZiAoaXNJbnRlcnN0aXRpYWwpIHtcbiAgICAgICAgICAvLyBwcmltYXJ5IGZyYWdtZW50IGxvYWRpbmcgd2lsbCBleGl0IGVhcmx5IGluIGJhc2Utc3RyZWFtLWNvbnRyb2xsZXIgd2hpbGUgYGJ1ZmZlcmluZ0l0ZW1gIGlzIHNldCB0byBhbiBJbnRlcnN0aXRpYWwgYmxvY2tcbiAgICAgICAgICBpdGVtLmV2ZW50LmFzc2V0TGlzdC5mb3JFYWNoKGFzc2V0ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBsYXllciA9IHRoaXMuZ2V0QXNzZXRQbGF5ZXIoYXNzZXQuaWRlbnRpZmllcik7XG4gICAgICAgICAgICBpZiAocGxheWVyKSB7XG4gICAgICAgICAgICAgIHBsYXllci5yZXN1bWVCdWZmZXJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmhscy5yZXN1bWVCdWZmZXJpbmcoKTtcbiAgICAgICAgICB0aGlzLnBsYXllclF1ZXVlLmZvckVhY2gocGxheWVyID0+IHBsYXllci5wYXVzZUJ1ZmZlcmluZygpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuSU5URVJTVElUSUFMU19CVUZGRVJFRF9UT19CT1VOREFSWSwge1xuICAgICAgICBldmVudHM6IGV2ZW50cy5zbGljZSgwKSxcbiAgICAgICAgc2NoZWR1bGU6IGl0ZW1zLnNsaWNlKDApLFxuICAgICAgICBidWZmZXJpbmdJbmRleDogdGhpcy5maW5kSXRlbUluZGV4KGl0ZW0pLFxuICAgICAgICBwbGF5aW5nSW5kZXg6IHRoaXMuZmluZEl0ZW1JbmRleCh0aGlzLnBsYXlpbmdJdGVtKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmJ1ZmZlcmluZ0l0ZW0gIT09IGl0ZW0pIHtcbiAgICAgIHRoaXMuYnVmZmVyaW5nSXRlbSA9IGl0ZW07XG4gICAgfVxuICAgIHJldHVybiBidWZmZXJpbmdMYXN0O1xuICB9XG4gIGJ1ZmZlcmVkVG9JdGVtKGl0ZW0sIGFzc2V0TGlzdEluZGV4ID0gMCkge1xuICAgIGNvbnN0IGJ1ZmZlcmluZ0xhc3QgPSB0aGlzLnNldEJ1ZmZlcmluZ0l0ZW0oaXRlbSk7XG4gICAgaWYgKHRoaXMucGxheWJhY2tEaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0ludGVyc3RpdGlhbChpdGVtKSkge1xuICAgICAgLy8gRW5zdXJlIGFzc2V0IGxpc3QgaXMgbG9hZGVkXG4gICAgICB0aGlzLmJ1ZmZlcmVkVG9FdmVudChpdGVtLCBhc3NldExpc3RJbmRleCk7XG4gICAgfSBlbHNlIGlmIChidWZmZXJpbmdMYXN0ICE9PSBudWxsKSB7XG4gICAgICAvLyBJZiBwcmltYXJ5IHBsYXllciBpcyBkZXRhY2hlZCwgaXQgaXMgYWxzbyBzdG9wcGVkLCByZXN0YXJ0IGxvYWRpbmcgYXQgcHJpbWFyeSBwb3NpdGlvblxuICAgICAgdGhpcy5idWZmZXJpbmdBc3NldCA9IG51bGw7XG4gICAgICBjb25zdCBkZXRhY2hlZERhdGEgPSB0aGlzLmRldGFjaGVkRGF0YTtcbiAgICAgIGlmIChkZXRhY2hlZERhdGEpIHtcbiAgICAgICAgaWYgKGRldGFjaGVkRGF0YS5tZWRpYVNvdXJjZSkge1xuICAgICAgICAgIGNvbnN0IHNraXBTZWVrVG9TdGFydFBvc2l0aW9uID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmF0dGFjaFByaW1hcnkoaXRlbS5zdGFydCwgaXRlbSwgc2tpcFNlZWtUb1N0YXJ0UG9zaXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucHJlbG9hZFByaW1hcnkoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIG5vdCBkZXRhY2hlZCBzZWVrIHRvIHJlc3VtcHRpb24gcG9pbnRcbiAgICAgICAgdGhpcy5wcmVsb2FkUHJpbWFyeShpdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcHJlbG9hZFByaW1hcnkoaXRlbSkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5maW5kSXRlbUluZGV4KGl0ZW0pO1xuICAgIGNvbnN0IHRpbWVsaW5lUG9zID0gdGhpcy5nZXRQcmltYXJ5UmVzdW1wdGlvbihpdGVtLCBpbmRleCk7XG4gICAgdGhpcy5zdGFydExvYWRpbmdQcmltYXJ5QXQodGltZWxpbmVQb3MpO1xuICB9XG4gIGJ1ZmZlcmVkVG9FdmVudChpdGVtLCBhc3NldExpc3RJbmRleCkge1xuICAgIGNvbnN0IGludGVyc3RpdGlhbCA9IGl0ZW0uZXZlbnQ7XG4gICAgY29uc3QgbmV2ZXJMb2FkZWQgPSBpbnRlcnN0aXRpYWwuYXNzZXRMaXN0Lmxlbmd0aCA9PT0gMCAmJiAhaW50ZXJzdGl0aWFsLmFzc2V0TGlzdExvYWRlcjtcbiAgICBjb25zdCBwbGF5T25jZSA9IGludGVyc3RpdGlhbC5jdWUub25jZTtcbiAgICBpZiAobmV2ZXJMb2FkZWQgfHwgIXBsYXlPbmNlKSB7XG4gICAgICAvLyBCdWZmZXJlZCB0byBJbnRlcnN0aXRpYWwgYm91bmRhcnlcbiAgICAgIGNvbnN0IHBsYXllciA9IHRoaXMucHJlbG9hZEFzc2V0cyhpbnRlcnN0aXRpYWwsIGFzc2V0TGlzdEluZGV4KTtcbiAgICAgIGlmIChwbGF5ZXIgIT0gbnVsbCAmJiBwbGF5ZXIuaW50ZXJzdGl0aWFsLmFwcGVuZEluUGxhY2UpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBsYXllciBhbmQgYXNzZXQgbGlzdCBpbmZvLCBzdGFydCBidWZmZXJpbmdcbiAgICAgICAgY29uc3QgYXNzZXRJdGVtID0gaW50ZXJzdGl0aWFsLmFzc2V0TGlzdFthc3NldExpc3RJbmRleF07XG4gICAgICAgIGNvbnN0IG1lZGlhID0gdGhpcy5wcmltYXJ5TWVkaWE7XG4gICAgICAgIGlmIChhc3NldEl0ZW0gJiYgbWVkaWEpIHtcbiAgICAgICAgICB0aGlzLmJ1ZmZlckFzc2V0UGxheWVyKHBsYXllciwgbWVkaWEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHByZWxvYWRBc3NldHMoaW50ZXJzdGl0aWFsLCBhc3NldExpc3RJbmRleCkge1xuICAgIGNvbnN0IHVyaSA9IGludGVyc3RpdGlhbC5hc3NldFVybDtcbiAgICBjb25zdCBhc3NldExpc3RMZW5ndGggPSBpbnRlcnN0aXRpYWwuYXNzZXRMaXN0Lmxlbmd0aDtcbiAgICBjb25zdCBuZXZlckxvYWRlZCA9IGFzc2V0TGlzdExlbmd0aCA9PT0gMCAmJiAhaW50ZXJzdGl0aWFsLmFzc2V0TGlzdExvYWRlcjtcbiAgICBjb25zdCBwbGF5T25jZSA9IGludGVyc3RpdGlhbC5jdWUub25jZTtcbiAgICBpZiAobmV2ZXJMb2FkZWQpIHtcbiAgICAgIGNvbnN0IHRpbWVsaW5lU3RhcnQgPSBpbnRlcnN0aXRpYWwudGltZWxpbmVTdGFydDtcbiAgICAgIGlmIChpbnRlcnN0aXRpYWwuYXBwZW5kSW5QbGFjZSkge1xuICAgICAgICB2YXIgX3BsYXlpbmdJdGVtJG5leHRFdmVuO1xuICAgICAgICBjb25zdCBwbGF5aW5nSXRlbSA9IHRoaXMucGxheWluZ0l0ZW07XG4gICAgICAgIGlmICghdGhpcy5pc0ludGVyc3RpdGlhbChwbGF5aW5nSXRlbSkgJiYgKHBsYXlpbmdJdGVtID09IG51bGwgPyB2b2lkIDAgOiAoX3BsYXlpbmdJdGVtJG5leHRFdmVuID0gcGxheWluZ0l0ZW0ubmV4dEV2ZW50KSA9PSBudWxsID8gdm9pZCAwIDogX3BsYXlpbmdJdGVtJG5leHRFdmVuLmlkZW50aWZpZXIpID09PSBpbnRlcnN0aXRpYWwuaWRlbnRpZmllcikge1xuICAgICAgICAgIHRoaXMuZmx1c2hGcm9udEJ1ZmZlcih0aW1lbGluZVN0YXJ0ICsgMC4yNSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBobHNTdGFydE9mZnNldDtcbiAgICAgIGxldCBsaXZlU3RhcnRQb3NpdGlvbiA9IDA7XG4gICAgICBpZiAoIXRoaXMucGxheWluZ0l0ZW0gJiYgdGhpcy5wcmltYXJ5TGl2ZSkge1xuICAgICAgICBsaXZlU3RhcnRQb3NpdGlvbiA9IHRoaXMuaGxzLnN0YXJ0UG9zaXRpb247XG4gICAgICAgIGlmIChsaXZlU3RhcnRQb3NpdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgICBsaXZlU3RhcnRQb3NpdGlvbiA9IHRoaXMuaGxzLmxpdmVTeW5jUG9zaXRpb24gfHwgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxpdmVTdGFydFBvc2l0aW9uICYmICEoaW50ZXJzdGl0aWFsLmN1ZS5wcmUgfHwgaW50ZXJzdGl0aWFsLmN1ZS5wb3N0KSkge1xuICAgICAgICBjb25zdCBzdGFydE9mZnNldCA9IGxpdmVTdGFydFBvc2l0aW9uIC0gdGltZWxpbmVTdGFydDtcbiAgICAgICAgaWYgKHN0YXJ0T2Zmc2V0ID4gMCkge1xuICAgICAgICAgIGhsc1N0YXJ0T2Zmc2V0ID0gTWF0aC5yb3VuZChzdGFydE9mZnNldCAqIDEwMDApIC8gMTAwMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5sb2coYExvYWQgaW50ZXJzdGl0aWFsIGFzc2V0ICR7YXNzZXRMaXN0SW5kZXggKyAxfS8ke3VyaSA/IDEgOiBhc3NldExpc3RMZW5ndGh9ICR7aW50ZXJzdGl0aWFsfSR7aGxzU3RhcnRPZmZzZXQgPyBgIGxpdmUtc3RhcnQ6ICR7bGl2ZVN0YXJ0UG9zaXRpb259IHN0YXJ0LW9mZnNldDogJHtobHNTdGFydE9mZnNldH1gIDogJyd9YCk7XG4gICAgICBpZiAodXJpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUFzc2V0KGludGVyc3RpdGlhbCwgMCwgMCwgdGltZWxpbmVTdGFydCwgaW50ZXJzdGl0aWFsLmR1cmF0aW9uLCB1cmkpO1xuICAgICAgfVxuICAgICAgY29uc3QgYXNzZXRMaXN0TG9hZGVyID0gdGhpcy5hc3NldExpc3RMb2FkZXIubG9hZEFzc2V0TGlzdChpbnRlcnN0aXRpYWwsIGhsc1N0YXJ0T2Zmc2V0KTtcbiAgICAgIGlmIChhc3NldExpc3RMb2FkZXIpIHtcbiAgICAgICAgaW50ZXJzdGl0aWFsLmFzc2V0TGlzdExvYWRlciA9IGFzc2V0TGlzdExvYWRlcjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFwbGF5T25jZSAmJiBhc3NldExpc3RMZW5ndGgpIHtcbiAgICAgIC8vIFJlLWJ1ZmZlcmVkIHRvIEludGVyc3RpdGlhbCBib3VuZGFyeSwgcmUtY3JlYXRlIGFzc2V0IHBsYXllcihzKVxuICAgICAgZm9yIChsZXQgaSA9IGFzc2V0TGlzdEluZGV4OyBpIDwgYXNzZXRMaXN0TGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYXNzZXQgPSBpbnRlcnN0aXRpYWwuYXNzZXRMaXN0W2ldO1xuICAgICAgICBjb25zdCBwbGF5ZXJJbmRleCA9IHRoaXMuZ2V0QXNzZXRQbGF5ZXJRdWV1ZUluZGV4KGFzc2V0LmlkZW50aWZpZXIpO1xuICAgICAgICBpZiAoKHBsYXllckluZGV4ID09PSAtMSB8fCB0aGlzLnBsYXllclF1ZXVlW3BsYXllckluZGV4XS5kZXN0cm95ZWQpICYmICFhc3NldC5lcnJvcikge1xuICAgICAgICAgIHRoaXMuY3JlYXRlQXNzZXRQbGF5ZXIoaW50ZXJzdGl0aWFsLCBhc3NldCwgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmdldEFzc2V0UGxheWVyKGludGVyc3RpdGlhbC5hc3NldExpc3RbYXNzZXRMaXN0SW5kZXhdLmlkZW50aWZpZXIpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmbHVzaEZyb250QnVmZmVyKHN0YXJ0T2Zmc2V0KSB7XG4gICAgLy8gRm9yY2UgcXVldWVkIGZsdXNoaW5nIG9mIGFsbCBidWZmZXJzXG4gICAgY29uc3QgcmVxdWlyZWRUcmFja3MgPSB0aGlzLnJlcXVpcmVkVHJhY2tzO1xuICAgIGlmICghcmVxdWlyZWRUcmFja3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sb2coYFJlbW92aW5nIGZyb250IGJ1ZmZlciBzdGFydGluZyBhdCAke3N0YXJ0T2Zmc2V0fWApO1xuICAgIGNvbnN0IHNvdXJjZUJ1ZmZlck5hbWVzID0gT2JqZWN0LmtleXMocmVxdWlyZWRUcmFja3MpO1xuICAgIHNvdXJjZUJ1ZmZlck5hbWVzLmZvckVhY2godHlwZSA9PiB7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHtcbiAgICAgICAgc3RhcnRPZmZzZXQsXG4gICAgICAgIGVuZE9mZnNldDogSW5maW5pdHksXG4gICAgICAgIHR5cGVcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gSW50ZXJzdGl0aWFsIEFzc2V0IFBsYXllciBjb250cm9sXG4gIGdldEFzc2V0UGxheWVyUXVldWVJbmRleChhc3NldElkKSB7XG4gICAgY29uc3QgcGxheWVyUXVldWUgPSB0aGlzLnBsYXllclF1ZXVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGxheWVyUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhc3NldElkID09PSBwbGF5ZXJRdWV1ZVtpXS5hc3NldElkKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgZ2V0QXNzZXRQbGF5ZXIoYXNzZXRJZCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5nZXRBc3NldFBsYXllclF1ZXVlSW5kZXgoYXNzZXRJZCk7XG4gICAgcmV0dXJuIHRoaXMucGxheWVyUXVldWVbaW5kZXhdIHx8IG51bGw7XG4gIH1cbiAgZ2V0QnVmZmVyaW5nUGxheWVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBsYXllclF1ZXVlLFxuICAgICAgcHJpbWFyeU1lZGlhXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKHByaW1hcnlNZWRpYSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbGF5ZXJRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocGxheWVyUXVldWVbaV0ubWVkaWEgPT09IHByaW1hcnlNZWRpYSkge1xuICAgICAgICAgIHJldHVybiBwbGF5ZXJRdWV1ZVtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjcmVhdGVBc3NldChpbnRlcnN0aXRpYWwsIGFzc2V0TGlzdEluZGV4LCBzdGFydE9mZnNldCwgdGltZWxpbmVTdGFydCwgZHVyYXRpb24sIHVyaSkge1xuICAgIGNvbnN0IGFzc2V0SXRlbSA9IHtcbiAgICAgIHBhcmVudElkZW50aWZpZXI6IGludGVyc3RpdGlhbC5pZGVudGlmaWVyLFxuICAgICAgaWRlbnRpZmllcjogZ2VuZXJhdGVBc3NldElkZW50aWZpZXIoaW50ZXJzdGl0aWFsLCB1cmksIGFzc2V0TGlzdEluZGV4KSxcbiAgICAgIGR1cmF0aW9uLFxuICAgICAgc3RhcnRPZmZzZXQsXG4gICAgICB0aW1lbGluZVN0YXJ0LFxuICAgICAgdXJpXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVBc3NldFBsYXllcihpbnRlcnN0aXRpYWwsIGFzc2V0SXRlbSwgYXNzZXRMaXN0SW5kZXgpO1xuICB9XG4gIGNyZWF0ZUFzc2V0UGxheWVyKGludGVyc3RpdGlhbCwgYXNzZXRJdGVtLCBhc3NldExpc3RJbmRleCkge1xuICAgIGNvbnN0IHByaW1hcnkgPSB0aGlzLmhscztcbiAgICBjb25zdCB1c2VyQ29uZmlnID0gcHJpbWFyeS51c2VyQ29uZmlnO1xuICAgIGxldCB2aWRlb1ByZWZlcmVuY2UgPSB1c2VyQ29uZmlnLnZpZGVvUHJlZmVyZW5jZTtcbiAgICBjb25zdCBjdXJyZW50TGV2ZWwgPSBwcmltYXJ5LmxvYWRMZXZlbE9iaiB8fCBwcmltYXJ5LmxldmVsc1twcmltYXJ5LmN1cnJlbnRMZXZlbF07XG4gICAgaWYgKHZpZGVvUHJlZmVyZW5jZSB8fCBjdXJyZW50TGV2ZWwpIHtcbiAgICAgIHZpZGVvUHJlZmVyZW5jZSA9IF9leHRlbmRzKHt9LCB2aWRlb1ByZWZlcmVuY2UpO1xuICAgICAgaWYgKGN1cnJlbnRMZXZlbC52aWRlb0NvZGVjKSB7XG4gICAgICAgIHZpZGVvUHJlZmVyZW5jZS52aWRlb0NvZGVjID0gY3VycmVudExldmVsLnZpZGVvQ29kZWM7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudExldmVsLnZpZGVvUmFuZ2UpIHtcbiAgICAgICAgdmlkZW9QcmVmZXJlbmNlLmFsbG93ZWRWaWRlb1JhbmdlcyA9IFtjdXJyZW50TGV2ZWwudmlkZW9SYW5nZV07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdGVkQXVkaW8gPSBwcmltYXJ5LmF1ZGlvVHJhY2tzW3ByaW1hcnkuYXVkaW9UcmFja107XG4gICAgY29uc3Qgc2VsZWN0ZWRTdWJ0aXRsZSA9IHByaW1hcnkuc3VidGl0bGVUcmFja3NbcHJpbWFyeS5zdWJ0aXRsZVRyYWNrXTtcbiAgICBsZXQgc3RhcnRQb3NpdGlvbiA9IDA7XG4gICAgaWYgKHRoaXMucHJpbWFyeUxpdmUgfHwgaW50ZXJzdGl0aWFsLmFwcGVuZEluUGxhY2UpIHtcbiAgICAgIGNvbnN0IHRpbWVQYXN0U3RhcnQgPSB0aGlzLnRpbWVsaW5lUG9zIC0gYXNzZXRJdGVtLnRpbWVsaW5lU3RhcnQ7XG4gICAgICBpZiAodGltZVBhc3RTdGFydCA+IDEpIHtcbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSBhc3NldEl0ZW0uZHVyYXRpb247XG4gICAgICAgIGlmIChkdXJhdGlvbiAmJiB0aW1lUGFzdFN0YXJ0IDwgZHVyYXRpb24pIHtcbiAgICAgICAgICBzdGFydFBvc2l0aW9uID0gdGltZVBhc3RTdGFydDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBhc3NldElkID0gYXNzZXRJdGVtLmlkZW50aWZpZXI7XG4gICAgY29uc3QgcGxheWVyQ29uZmlnID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHVzZXJDb25maWcpLCB7fSwge1xuICAgICAgYXV0b1N0YXJ0TG9hZDogdHJ1ZSxcbiAgICAgIHN0YXJ0RnJhZ1ByZWZldGNoOiB0cnVlLFxuICAgICAgcHJpbWFyeVNlc3Npb25JZDogcHJpbWFyeS5zZXNzaW9uSWQsXG4gICAgICBhc3NldFBsYXllcklkOiBhc3NldElkLFxuICAgICAgYWJyRXdtYURlZmF1bHRFc3RpbWF0ZTogcHJpbWFyeS5iYW5kd2lkdGhFc3RpbWF0ZSxcbiAgICAgIGludGVyc3RpdGlhbHNDb250cm9sbGVyOiB1bmRlZmluZWQsXG4gICAgICBzdGFydFBvc2l0aW9uLFxuICAgICAgbGl2ZUR1cmF0aW9uSW5maW5pdHk6IGZhbHNlLFxuICAgICAgdGVzdEJhbmR3aWR0aDogZmFsc2UsXG4gICAgICB2aWRlb1ByZWZlcmVuY2UsXG4gICAgICBhdWRpb1ByZWZlcmVuY2U6IHNlbGVjdGVkQXVkaW8gfHwgdXNlckNvbmZpZy5hdWRpb1ByZWZlcmVuY2UsXG4gICAgICBzdWJ0aXRsZVByZWZlcmVuY2U6IHNlbGVjdGVkU3VidGl0bGUgfHwgdXNlckNvbmZpZy5zdWJ0aXRsZVByZWZlcmVuY2VcbiAgICB9KTtcbiAgICBpZiAoaW50ZXJzdGl0aWFsLmFwcGVuZEluUGxhY2UpIHtcbiAgICAgIGludGVyc3RpdGlhbC5hcHBlbmRJblBsYWNlU3RhcnRlZCA9IHRydWU7XG4gICAgICBpZiAoYXNzZXRJdGVtLnRpbWVsaW5lU3RhcnQpIHtcbiAgICAgICAgcGxheWVyQ29uZmlnLnRpbWVsaW5lT2Zmc2V0ID0gYXNzZXRJdGVtLnRpbWVsaW5lU3RhcnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNtY2QgPSBwbGF5ZXJDb25maWcuY21jZDtcbiAgICBpZiAoY21jZCAhPSBudWxsICYmIGNtY2Quc2Vzc2lvbklkICYmIGNtY2QuY29udGVudElkKSB7XG4gICAgICBwbGF5ZXJDb25maWcuY21jZCA9IF9leHRlbmRzKHt9LCBjbWNkLCB7XG4gICAgICAgIGNvbnRlbnRJZDogaGFzaChhc3NldEl0ZW0udXJpKVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmdldEFzc2V0UGxheWVyKGFzc2V0SWQpKSB7XG4gICAgICB0aGlzLndhcm4oYER1cGxpY2F0ZSBkYXRlIHJhbmdlIGlkZW50aWZpZXIgJHtpbnRlcnN0aXRpYWx9IGFuZCBhc3NldCAke2Fzc2V0SWR9YCk7XG4gICAgfVxuICAgIGNvbnN0IHBsYXllciA9IG5ldyBIbHNBc3NldFBsYXllcih0aGlzLkhsc1BsYXllckNsYXNzLCBwbGF5ZXJDb25maWcsIGludGVyc3RpdGlhbCwgYXNzZXRJdGVtKTtcbiAgICB0aGlzLnBsYXllclF1ZXVlLnB1c2gocGxheWVyKTtcbiAgICBpbnRlcnN0aXRpYWwuYXNzZXRMaXN0W2Fzc2V0TGlzdEluZGV4XSA9IGFzc2V0SXRlbTtcbiAgICAvLyBMaXN0ZW4gZm9yIExldmVsRGV0YWlscyBhbmQgUFRTIGNoYW5nZSB0byB1cGRhdGUgZHVyYXRpb25cbiAgICBjb25zdCB1cGRhdGVBc3NldFBsYXllckRldGFpbHMgPSBkZXRhaWxzID0+IHtcbiAgICAgIGlmIChkZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYEludGVyc3RpdGlhbHMgTVVTVCBiZSBWT0QgYXNzZXRzICR7aW50ZXJzdGl0aWFsfWApO1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSB7XG4gICAgICAgICAgZmF0YWw6IHRydWUsXG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5PVEhFUl9FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuSU5URVJTVElUSUFMX0FTU0VUX0lURU1fRVJST1IsXG4gICAgICAgICAgZXJyb3JcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVBc3NldEl0ZW1FcnJvcihlcnJvckRhdGEsIGludGVyc3RpdGlhbCwgdGhpcy5zY2hlZHVsZS5maW5kRXZlbnRJbmRleChpbnRlcnN0aXRpYWwuaWRlbnRpZmllciksIGFzc2V0TGlzdEluZGV4LCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gR2V0IHRpbWUgYXQgZW5kIG9mIGxhc3QgZnJhZ21lbnRcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gZGV0YWlscy5lZGdlIC0gZGV0YWlscy5mcmFnbWVudFN0YXJ0O1xuICAgICAgY29uc3QgY3VycmVudEFzc2V0RHVyYXRpb24gPSBhc3NldEl0ZW0uZHVyYXRpb247XG4gICAgICBpZiAoY3VycmVudEFzc2V0RHVyYXRpb24gPT09IG51bGwgfHwgZHVyYXRpb24gPiBjdXJyZW50QXNzZXREdXJhdGlvbikge1xuICAgICAgICB0aGlzLmxvZyhgSW50ZXJzdGl0aWFsIGFzc2V0IFwiJHthc3NldElkfVwiIGR1cmF0aW9uIGNoYW5nZSAke2N1cnJlbnRBc3NldER1cmF0aW9ufSA+ICR7ZHVyYXRpb259YCk7XG4gICAgICAgIGFzc2V0SXRlbS5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgICAvLyBVcGRhdGUgc2NoZWR1bGUgd2l0aCBuZXcgZXZlbnQgYW5kIGFzc2V0IGR1cmF0aW9uXG4gICAgICAgIHRoaXMudXBkYXRlU2NoZWR1bGUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHBsYXllci5vbihFdmVudHMuTEVWRUxfVVBEQVRFRCwgKGV2ZW50LCB7XG4gICAgICBkZXRhaWxzXG4gICAgfSkgPT4gdXBkYXRlQXNzZXRQbGF5ZXJEZXRhaWxzKGRldGFpbHMpKTtcbiAgICBwbGF5ZXIub24oRXZlbnRzLkxFVkVMX1BUU19VUERBVEVELCAoZXZlbnQsIHtcbiAgICAgIGRldGFpbHNcbiAgICB9KSA9PiB1cGRhdGVBc3NldFBsYXllckRldGFpbHMoZGV0YWlscykpO1xuICAgIGNvbnN0IG9uQnVmZmVyQ29kZWNzID0gKGV2ZW50LCBkYXRhKSA9PiB7XG4gICAgICBjb25zdCBpblF1ZXVQbGF5ZXIgPSB0aGlzLmdldEFzc2V0UGxheWVyKGFzc2V0SWQpO1xuICAgICAgaWYgKGluUXVldVBsYXllciAmJiBkYXRhLnRyYWNrcykge1xuICAgICAgICBpblF1ZXVQbGF5ZXIub2ZmKEV2ZW50cy5CVUZGRVJfQ09ERUNTLCBvbkJ1ZmZlckNvZGVjcyk7XG4gICAgICAgIGluUXVldVBsYXllci50cmFja3MgPSBkYXRhLnRyYWNrcztcbiAgICAgICAgY29uc3QgbWVkaWEgPSB0aGlzLnByaW1hcnlNZWRpYTtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyaW5nQXNzZXQgPT09IGluUXVldVBsYXllci5hc3NldEl0ZW0gJiYgbWVkaWEgJiYgIWluUXVldVBsYXllci5tZWRpYSkge1xuICAgICAgICAgIHRoaXMuYnVmZmVyQXNzZXRQbGF5ZXIoaW5RdWV1UGxheWVyLCBtZWRpYSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHBsYXllci5vbihFdmVudHMuQlVGRkVSX0NPREVDUywgb25CdWZmZXJDb2RlY3MpO1xuICAgIGNvbnN0IGJ1ZmZlcmVkVG9FbmQgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RoaXMkc2NoZWR1bGUkaXRlbXMyO1xuICAgICAgY29uc3QgaW5RdWV1UGxheWVyID0gdGhpcy5nZXRBc3NldFBsYXllcihhc3NldElkKTtcbiAgICAgIHRoaXMubG9nKGBidWZmZXJlZCB0byBlbmQgb2YgYXNzZXQgJHtpblF1ZXVQbGF5ZXJ9YCk7XG4gICAgICBpZiAoIWluUXVldVBsYXllcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBQcmVsb2FkIGF0IGVuZCBvZiBhc3NldFxuICAgICAgY29uc3Qgc2NoZWR1bGVJbmRleCA9IHRoaXMuc2NoZWR1bGUuZmluZEV2ZW50SW5kZXgoaW50ZXJzdGl0aWFsLmlkZW50aWZpZXIpO1xuICAgICAgY29uc3QgaXRlbSA9IChfdGhpcyRzY2hlZHVsZSRpdGVtczIgPSB0aGlzLnNjaGVkdWxlLml0ZW1zKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkc2NoZWR1bGUkaXRlbXMyW3NjaGVkdWxlSW5kZXhdO1xuICAgICAgaWYgKHRoaXMuaXNJbnRlcnN0aXRpYWwoaXRlbSkpIHtcbiAgICAgICAgY29uc3QgYXNzZXRMaXN0SW5kZXggPSBpbnRlcnN0aXRpYWwuZmluZEFzc2V0SW5kZXgoYXNzZXRJdGVtKTtcbiAgICAgICAgY29uc3QgbmV4dEFzc2V0SW5kZXggPSBnZXROZXh0QXNzZXRJbmRleChpbnRlcnN0aXRpYWwsIGFzc2V0TGlzdEluZGV4KTtcbiAgICAgICAgaWYgKCFpbnRlcnN0aXRpYWwuaXNBc3NldFBhc3RQbGF5b3V0TGltaXQobmV4dEFzc2V0SW5kZXgpKSB7XG4gICAgICAgICAgdGhpcy5idWZmZXJlZFRvSXRlbShpdGVtLCBuZXh0QXNzZXRJbmRleCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF90aGlzJHNjaGVkdWxlJGl0ZW1zMztcbiAgICAgICAgICBjb25zdCBuZXh0SXRlbSA9IChfdGhpcyRzY2hlZHVsZSRpdGVtczMgPSB0aGlzLnNjaGVkdWxlLml0ZW1zKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkc2NoZWR1bGUkaXRlbXMzW3NjaGVkdWxlSW5kZXggKyAxXTtcbiAgICAgICAgICBpZiAobmV4dEl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyZWRUb0l0ZW0obmV4dEl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcGxheWVyLm9uKEV2ZW50cy5CVUZGRVJFRF9UT19FTkQsIGJ1ZmZlcmVkVG9FbmQpO1xuICAgIGNvbnN0IGVuZGVkV2l0aEFzc2V0SW5kZXggPSBhc3NldEluZGV4ID0+IHtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGluUXVldVBsYXllciA9IHRoaXMuZ2V0QXNzZXRQbGF5ZXIoYXNzZXRJZCk7XG4gICAgICAgIGlmICghaW5RdWV1UGxheWVyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2hvdWxkUGxheSA9IHRydWU7XG4gICAgICAgIGNvbnN0IHNjaGVkdWxlSW5kZXggPSB0aGlzLnNjaGVkdWxlLmZpbmRFdmVudEluZGV4KGludGVyc3RpdGlhbC5pZGVudGlmaWVyKTtcbiAgICAgICAgdGhpcy5hZHZhbmNlQWZ0ZXJBc3NldEVuZGVkKGludGVyc3RpdGlhbCwgc2NoZWR1bGVJbmRleCwgYXNzZXRJbmRleCk7XG4gICAgICB9O1xuICAgIH07XG4gICAgcGxheWVyLm9uY2UoRXZlbnRzLk1FRElBX0VOREVELCBlbmRlZFdpdGhBc3NldEluZGV4KGFzc2V0TGlzdEluZGV4KSk7XG4gICAgcGxheWVyLm9uY2UoRXZlbnRzLlBMQVlPVVRfTElNSVRfUkVBQ0hFRCwgZW5kZWRXaXRoQXNzZXRJbmRleChJbmZpbml0eSkpO1xuICAgIHBsYXllci5vbihFdmVudHMuRVJST1IsIChldmVudCwgZGF0YSkgPT4ge1xuICAgICAgY29uc3QgaW5RdWV1UGxheWVyID0gdGhpcy5nZXRBc3NldFBsYXllcihhc3NldElkKTtcbiAgICAgIGlmIChkYXRhLmRldGFpbHMgPT09IEVycm9yRGV0YWlscy5CVUZGRVJfU1RBTExFRF9FUlJPUikge1xuICAgICAgICBpZiAoaW5RdWV1UGxheWVyICE9IG51bGwgJiYgaW5RdWV1UGxheWVyLm1lZGlhKSB7XG4gICAgICAgICAgY29uc3QgYXNzZXRDdXJyZW50VGltZSA9IGluUXVldVBsYXllci5jdXJyZW50VGltZTtcbiAgICAgICAgICBjb25zdCBkaXN0YW5jZUZyb21FbmQgPSBpblF1ZXVQbGF5ZXIuZHVyYXRpb24gLSBhc3NldEN1cnJlbnRUaW1lO1xuICAgICAgICAgIGlmIChhc3NldEN1cnJlbnRUaW1lICYmIGludGVyc3RpdGlhbC5hcHBlbmRJblBsYWNlICYmIGRpc3RhbmNlRnJvbUVuZCAvIGluUXVldVBsYXllci5tZWRpYS5wbGF5YmFja1JhdGUgPCAwLjUpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKGBBZHZhbmNpbmcgYnVmZmVyIHBhc3QgZW5kIG9mIGFzc2V0ICR7YXNzZXRJZH0gJHtpbnRlcnN0aXRpYWx9IGF0ICR7aW5RdWV1UGxheWVyLm1lZGlhLmN1cnJlbnRUaW1lfWApO1xuICAgICAgICAgICAgYnVmZmVyZWRUb0VuZCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndhcm4oYFN0YWxsZWQgYXQgJHthc3NldEN1cnJlbnRUaW1lfSBvZiAke2Fzc2V0Q3VycmVudFRpbWUgKyBkaXN0YW5jZUZyb21FbmR9IGluIGFzc2V0ICR7YXNzZXRJZH0gJHtpbnRlcnN0aXRpYWx9YCk7XG4gICAgICAgICAgICB0aGlzLm9uVGltZXVwZGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5jaGVja0J1ZmZlcih0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5oYW5kbGVBc3NldEl0ZW1FcnJvcihkYXRhLCBpbnRlcnN0aXRpYWwsIHRoaXMuc2NoZWR1bGUuZmluZEV2ZW50SW5kZXgoaW50ZXJzdGl0aWFsLmlkZW50aWZpZXIpLCBhc3NldExpc3RJbmRleCwgYEFzc2V0IHBsYXllciBlcnJvciAke2RhdGEuZXJyb3J9ICR7aW50ZXJzdGl0aWFsfWApO1xuICAgIH0pO1xuICAgIHBsYXllci5vbihFdmVudHMuREVTVFJPWUlORywgKCkgPT4ge1xuICAgICAgY29uc3QgaW5RdWV1UGxheWVyID0gdGhpcy5nZXRBc3NldFBsYXllcihhc3NldElkKTtcbiAgICAgIGlmICghaW5RdWV1UGxheWVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBBc3NldCBwbGF5ZXIgZGVzdHJveWVkIHVuZXhwZWN0ZWRseSAke2Fzc2V0SWR9YCk7XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSB7XG4gICAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuSU5URVJTVElUSUFMX0FTU0VUX0lURU1fRVJST1IsXG4gICAgICAgIGVycm9yXG4gICAgICB9O1xuICAgICAgdGhpcy5oYW5kbGVBc3NldEl0ZW1FcnJvcihlcnJvckRhdGEsIGludGVyc3RpdGlhbCwgdGhpcy5zY2hlZHVsZS5maW5kRXZlbnRJbmRleChpbnRlcnN0aXRpYWwuaWRlbnRpZmllciksIGFzc2V0TGlzdEluZGV4LCBlcnJvci5tZXNzYWdlKTtcbiAgICB9KTtcbiAgICB0aGlzLmxvZyhgSU5URVJTVElUSUFMX0FTU0VUX1BMQVlFUl9DUkVBVEVEICR7ZXZlbnRBc3NldFRvU3RyaW5nKGFzc2V0SXRlbSl9YCk7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuSU5URVJTVElUSUFMX0FTU0VUX1BMQVlFUl9DUkVBVEVELCB7XG4gICAgICBhc3NldDogYXNzZXRJdGVtLFxuICAgICAgYXNzZXRMaXN0SW5kZXgsXG4gICAgICBldmVudDogaW50ZXJzdGl0aWFsLFxuICAgICAgcGxheWVyXG4gICAgfSk7XG4gICAgcmV0dXJuIHBsYXllcjtcbiAgfVxuICBjbGVhckludGVyc3RpdGlhbChpbnRlcnN0aXRpYWwsIHRvU2VnbWVudCkge1xuICAgIGludGVyc3RpdGlhbC5hc3NldExpc3QuZm9yRWFjaChhc3NldCA9PiB7XG4gICAgICB0aGlzLmNsZWFyQXNzZXRQbGF5ZXIoYXNzZXQuaWRlbnRpZmllciwgdG9TZWdtZW50KTtcbiAgICB9KTtcbiAgICAvLyBSZW1vdmUgYXNzZXQgbGlzdCBhbmQgcmVzb2x2ZWQgZHVyYXRpb25cbiAgICBpbnRlcnN0aXRpYWwucmVzZXQoKTtcbiAgfVxuICByZXNldEFzc2V0UGxheWVyKGFzc2V0SWQpIHtcbiAgICAvLyBSZXNldCBhc3NldCBwbGF5ZXIgc28gdGhhdCBpdCdzIHRpbWVsaW5lIGNhbiBiZSBhZGp1c3RlZCB3aXRob3V0IHJlbG9hZGluZyB0aGUgTVZQXG4gICAgY29uc3QgcGxheWVySW5kZXggPSB0aGlzLmdldEFzc2V0UGxheWVyUXVldWVJbmRleChhc3NldElkKTtcbiAgICBpZiAocGxheWVySW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLmxvZyhgcmVzZXQgYXNzZXQgcGxheWVyIFwiJHthc3NldElkfVwiIGFmdGVyIGVycm9yYCk7XG4gICAgICBjb25zdCBwbGF5ZXIgPSB0aGlzLnBsYXllclF1ZXVlW3BsYXllckluZGV4XTtcbiAgICAgIHRoaXMudHJhbnNmZXJNZWRpYUZyb21QbGF5ZXIocGxheWVyLCBudWxsKTtcbiAgICAgIHBsYXllci5yZXNldERldGFpbHMoKTtcbiAgICB9XG4gIH1cbiAgY2xlYXJBc3NldFBsYXllcihhc3NldElkLCB0b1NlZ21lbnQpIHtcbiAgICBjb25zdCBwbGF5ZXJJbmRleCA9IHRoaXMuZ2V0QXNzZXRQbGF5ZXJRdWV1ZUluZGV4KGFzc2V0SWQpO1xuICAgIGlmIChwbGF5ZXJJbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMubG9nKGBjbGVhciBhc3NldCBwbGF5ZXIgXCIke2Fzc2V0SWR9XCIgdG9TZWdtZW50OiAke3RvU2VnbWVudCA/IHNlZ21lbnRUb1N0cmluZyh0b1NlZ21lbnQpIDogdG9TZWdtZW50fWApO1xuICAgICAgY29uc3QgcGxheWVyID0gdGhpcy5wbGF5ZXJRdWV1ZVtwbGF5ZXJJbmRleF07XG4gICAgICB0aGlzLnRyYW5zZmVyTWVkaWFGcm9tUGxheWVyKHBsYXllciwgdG9TZWdtZW50KTtcbiAgICAgIHRoaXMucGxheWVyUXVldWUuc3BsaWNlKHBsYXllckluZGV4LCAxKTtcbiAgICAgIHBsYXllci5kZXN0cm95KCk7XG4gICAgfVxuICB9XG4gIGVtcHR5UGxheWVyUXVldWUoKSB7XG4gICAgbGV0IHBsYXllcjtcbiAgICB3aGlsZSAocGxheWVyID0gdGhpcy5wbGF5ZXJRdWV1ZS5wb3AoKSkge1xuICAgICAgcGxheWVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5wbGF5ZXJRdWV1ZSA9IFtdO1xuICB9XG4gIHN0YXJ0QXNzZXRQbGF5ZXIocGxheWVyLCBhc3NldExpc3RJbmRleCwgc2NoZWR1bGVJdGVtcywgc2NoZWR1bGVJbmRleCwgbWVkaWEpIHtcbiAgICBjb25zdCB7XG4gICAgICBpbnRlcnN0aXRpYWwsXG4gICAgICBhc3NldEl0ZW0sXG4gICAgICBhc3NldElkXG4gICAgfSA9IHBsYXllcjtcbiAgICBjb25zdCBhc3NldExpc3RMZW5ndGggPSBpbnRlcnN0aXRpYWwuYXNzZXRMaXN0Lmxlbmd0aDtcbiAgICBjb25zdCBwbGF5aW5nQXNzZXQgPSB0aGlzLnBsYXlpbmdBc3NldDtcbiAgICB0aGlzLmVuZGVkQXNzZXQgPSBudWxsO1xuICAgIHRoaXMucGxheWluZ0Fzc2V0ID0gYXNzZXRJdGVtO1xuICAgIGlmICghcGxheWluZ0Fzc2V0IHx8IHBsYXlpbmdBc3NldC5pZGVudGlmaWVyICE9PSBhc3NldElkKSB7XG4gICAgICBpZiAocGxheWluZ0Fzc2V0KSB7XG4gICAgICAgIC8vIEV4aXRpbmcgYW5vdGhlciBJbnRlcnN0aXRpYWwgYXNzZXRcbiAgICAgICAgdGhpcy5jbGVhckFzc2V0UGxheWVyKHBsYXlpbmdBc3NldC5pZGVudGlmaWVyLCBzY2hlZHVsZUl0ZW1zW3NjaGVkdWxlSW5kZXhdKTtcbiAgICAgICAgZGVsZXRlIHBsYXlpbmdBc3NldC5lcnJvcjtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nKGBJTlRFUlNUSVRJQUxfQVNTRVRfU1RBUlRFRCAke2Fzc2V0TGlzdEluZGV4ICsgMX0vJHthc3NldExpc3RMZW5ndGh9ICR7ZXZlbnRBc3NldFRvU3RyaW5nKGFzc2V0SXRlbSl9YCk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5JTlRFUlNUSVRJQUxfQVNTRVRfU1RBUlRFRCwge1xuICAgICAgICBhc3NldDogYXNzZXRJdGVtLFxuICAgICAgICBhc3NldExpc3RJbmRleCxcbiAgICAgICAgZXZlbnQ6IGludGVyc3RpdGlhbCxcbiAgICAgICAgc2NoZWR1bGU6IHNjaGVkdWxlSXRlbXMuc2xpY2UoMCksXG4gICAgICAgIHNjaGVkdWxlSW5kZXgsXG4gICAgICAgIHBsYXllclxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gZGV0YWNoIG1lZGlhIGFuZCBhdHRhY2ggdG8gaW50ZXJzdGl0aWFsIHBsYXllciBpZiBpdCBkb2VzIG5vdCBoYXZlIGFub3RoZXIgZWxlbWVudCBhdHRhY2hlZFxuICAgIHRoaXMuYnVmZmVyQXNzZXRQbGF5ZXIocGxheWVyLCBtZWRpYSk7XG4gIH1cbiAgYnVmZmVyQXNzZXRQbGF5ZXIocGxheWVyLCBtZWRpYSkge1xuICAgIHZhciBfdGhpcyRzY2hlZHVsZSRpdGVtczQsIF90aGlzJGRldGFjaGVkRGF0YTU7XG4gICAgY29uc3Qge1xuICAgICAgaW50ZXJzdGl0aWFsLFxuICAgICAgYXNzZXRJdGVtXG4gICAgfSA9IHBsYXllcjtcbiAgICBjb25zdCBzY2hlZHVsZUluZGV4ID0gdGhpcy5zY2hlZHVsZS5maW5kRXZlbnRJbmRleChpbnRlcnN0aXRpYWwuaWRlbnRpZmllcik7XG4gICAgY29uc3QgaXRlbSA9IChfdGhpcyRzY2hlZHVsZSRpdGVtczQgPSB0aGlzLnNjaGVkdWxlLml0ZW1zKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkc2NoZWR1bGUkaXRlbXM0W3NjaGVkdWxlSW5kZXhdO1xuICAgIGlmICghaXRlbSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNldEJ1ZmZlcmluZ0l0ZW0oaXRlbSk7XG4gICAgdGhpcy5idWZmZXJpbmdBc3NldCA9IGFzc2V0SXRlbTtcbiAgICBjb25zdCBidWZmZXJpbmdQbGF5ZXIgPSB0aGlzLmdldEJ1ZmZlcmluZ1BsYXllcigpO1xuICAgIGlmIChidWZmZXJpbmdQbGF5ZXIgPT09IHBsYXllcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhcHBlbmRJblBsYWNlTmV4dCA9IGludGVyc3RpdGlhbC5hcHBlbmRJblBsYWNlO1xuICAgIGlmIChhcHBlbmRJblBsYWNlTmV4dCAmJiAoYnVmZmVyaW5nUGxheWVyID09IG51bGwgPyB2b2lkIDAgOiBidWZmZXJpbmdQbGF5ZXIuaW50ZXJzdGl0aWFsLmFwcGVuZEluUGxhY2UpID09PSBmYWxzZSkge1xuICAgICAgLy8gTWVkaWEgaXMgZGV0YWNoZWQgYW5kIG5vdCBhdmFpbGFibGUgdG8gYXBwZW5kIGluIHBsYWNlXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFjdGl2ZVRyYWNrcyA9IChidWZmZXJpbmdQbGF5ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGJ1ZmZlcmluZ1BsYXllci50cmFja3MpIHx8ICgoX3RoaXMkZGV0YWNoZWREYXRhNSA9IHRoaXMuZGV0YWNoZWREYXRhKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkZGV0YWNoZWREYXRhNS50cmFja3MpIHx8IHRoaXMucmVxdWlyZWRUcmFja3M7XG4gICAgaWYgKGFwcGVuZEluUGxhY2VOZXh0ICYmIGFzc2V0SXRlbSAhPT0gdGhpcy5wbGF5aW5nQXNzZXQpIHtcbiAgICAgIC8vIERvIG5vdCBidWZmZXIgYW5vdGhlciBpdGVtIGlmIHRyYWNrcyBhcmUgdW5rbm93biBvciBpbmNvbXBhdGlibGVcbiAgICAgIGlmICghcGxheWVyLnRyYWNrcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoYWN0aXZlVHJhY2tzICYmICFpc0NvbXBhdGlibGVUcmFja0NoYW5nZShhY3RpdmVUcmFja3MsIHBsYXllci50cmFja3MpKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBBc3NldCAke2V2ZW50QXNzZXRUb1N0cmluZyhhc3NldEl0ZW0pfSBTb3VyY2VCdWZmZXIgdHJhY2tzICgnJHtPYmplY3Qua2V5cyhwbGF5ZXIudHJhY2tzKX0nKSBhcmUgbm90IGNvbXBhdGlibGUgd2l0aCBwcmltYXJ5IGNvbnRlbnQgdHJhY2tzICgnJHtPYmplY3Qua2V5cyhhY3RpdmVUcmFja3MpfScpYCk7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IHtcbiAgICAgICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5JTlRFUlNUSVRJQUxfQVNTRVRfSVRFTV9FUlJPUixcbiAgICAgICAgICBlcnJvclxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhc3NldExpc3RJbmRleCA9IGludGVyc3RpdGlhbC5maW5kQXNzZXRJbmRleChhc3NldEl0ZW0pO1xuICAgICAgICB0aGlzLmhhbmRsZUFzc2V0SXRlbUVycm9yKGVycm9yRGF0YSwgaW50ZXJzdGl0aWFsLCBzY2hlZHVsZUluZGV4LCBhc3NldExpc3RJbmRleCwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy50cmFuc2Zlck1lZGlhVG8ocGxheWVyLCBtZWRpYSk7XG4gIH1cbiAgaGFuZGxlQXNzZXRJdGVtRXJyb3IoZGF0YSwgaW50ZXJzdGl0aWFsLCBzY2hlZHVsZUluZGV4LCBhc3NldExpc3RJbmRleCwgZXJyb3JNZXNzYWdlKSB7XG4gICAgaWYgKGRhdGEuZGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLkJVRkZFUl9TVEFMTEVEX0VSUk9SKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFzc2V0SXRlbSA9IGludGVyc3RpdGlhbC5hc3NldExpc3RbYXNzZXRMaXN0SW5kZXhdO1xuICAgIHRoaXMud2FybihgSU5URVJTVElUSUFMX0FTU0VUX0VSUk9SICR7YXNzZXRJdGVtID8gZXZlbnRBc3NldFRvU3RyaW5nKGFzc2V0SXRlbSkgOiBhc3NldEl0ZW19ICR7ZGF0YS5lcnJvcn1gKTtcbiAgICBjb25zdCBhc3NldElkID0gYXNzZXRJdGVtID09IG51bGwgPyB2b2lkIDAgOiBhc3NldEl0ZW0uaWRlbnRpZmllcjtcbiAgICBjb25zdCBwbGF5ZXJJbmRleCA9IHRoaXMuZ2V0QXNzZXRQbGF5ZXJRdWV1ZUluZGV4KGFzc2V0SWQpO1xuICAgIGNvbnN0IHBsYXllciA9IHRoaXMucGxheWVyUXVldWVbcGxheWVySW5kZXhdIHx8IG51bGw7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLnNjaGVkdWxlLml0ZW1zO1xuICAgIGNvbnN0IGludGVyc3RpdGlhbEFzc2V0RXJyb3IgPSBfZXh0ZW5kcyh7fSwgZGF0YSwge1xuICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgZXJyb3JBY3Rpb246IGNyZWF0ZURvTm90aGluZ0Vycm9yQWN0aW9uKHRydWUpLFxuICAgICAgYXNzZXQ6IGFzc2V0SXRlbSxcbiAgICAgIGFzc2V0TGlzdEluZGV4LFxuICAgICAgZXZlbnQ6IGludGVyc3RpdGlhbCxcbiAgICAgIHNjaGVkdWxlOiBpdGVtcyxcbiAgICAgIHNjaGVkdWxlSW5kZXgsXG4gICAgICBwbGF5ZXJcbiAgICB9KTtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5JTlRFUlNUSVRJQUxfQVNTRVRfRVJST1IsIGludGVyc3RpdGlhbEFzc2V0RXJyb3IpO1xuICAgIGlmICghZGF0YS5mYXRhbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwbGF5aW5nQXNzZXQgPSB0aGlzLnBsYXlpbmdBc3NldDtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgIGlmIChhc3NldEl0ZW0pIHtcbiAgICAgIHRoaXMuY2xlYXJBc3NldFBsYXllcihhc3NldElkLCBudWxsKTtcbiAgICAgIGFzc2V0SXRlbS5lcnJvciA9IGVycm9yO1xuICAgIH1cblxuICAgIC8vIElmIGFsbCBhc3NldHMgaW4gaW50ZXJzdGl0aWFsIGZhaWwsIG1hcmsgdGhlIGludGVyc3RpdGlhbCB3aXRoIGFuIGVycm9yXG4gICAgaWYgKCFpbnRlcnN0aXRpYWwuYXNzZXRMaXN0LnNvbWUoYXNzZXQgPT4gIWFzc2V0LmVycm9yKSkge1xuICAgICAgaW50ZXJzdGl0aWFsLmVycm9yID0gZXJyb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlc2V0IGxldmVsIGRldGFpbHMgYW5kIHJlbG9hZC9wYXJzZSBtZWRpYSBwbGF5bGlzdHMgdG8gYWxpZ24gd2l0aCB1cGRhdGVkIHNjaGVkdWxlXG4gICAgICBmb3IgKGxldCBpID0gYXNzZXRMaXN0SW5kZXg7IGkgPCBpbnRlcnN0aXRpYWwuYXNzZXRMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMucmVzZXRBc3NldFBsYXllcihpbnRlcnN0aXRpYWwuYXNzZXRMaXN0W2ldLmlkZW50aWZpZXIpO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVTY2hlZHVsZSgpO1xuICAgIH1cbiAgICBpZiAoaW50ZXJzdGl0aWFsLmVycm9yKSB7XG4gICAgICB0aGlzLnByaW1hcnlGYWxsYmFjayhpbnRlcnN0aXRpYWwpO1xuICAgIH0gZWxzZSBpZiAocGxheWluZ0Fzc2V0ICYmIHBsYXlpbmdBc3NldC5pZGVudGlmaWVyID09PSBhc3NldElkKSB7XG4gICAgICB0aGlzLmFkdmFuY2VBZnRlckFzc2V0RW5kZWQoaW50ZXJzdGl0aWFsLCBzY2hlZHVsZUluZGV4LCBhc3NldExpc3RJbmRleCk7XG4gICAgfVxuICB9XG4gIHByaW1hcnlGYWxsYmFjayhpbnRlcnN0aXRpYWwpIHtcbiAgICAvLyBGYWxsYmFjayB0byBQcmltYXJ5IGJ5IG9uIGN1cnJlbnQgb3IgZnV0dXJlIGV2ZW50cyBieSB1cGRhdGluZyBzY2hlZHVsZSB0byBza2lwIGVycm9yZWQgaW50ZXJzdGl0aWFscy9hc3NldHNcbiAgICBjb25zdCBmbHVzaFN0YXJ0ID0gaW50ZXJzdGl0aWFsLnRpbWVsaW5lU3RhcnQ7XG4gICAgY29uc3QgcGxheWluZ0l0ZW0gPSB0aGlzLmVmZmVjdGl2ZVBsYXlpbmdJdGVtO1xuICAgIC8vIFVwZGF0ZSBzY2hlZHVsZSBub3cgdGhhdCBpbnRlcnN0aXRpYWwvYXNzZXRzIGFyZSBmbGFnZ2VkIHdpdGggYGVycm9yYCBmb3IgZmFsbGJhY2tcbiAgICB0aGlzLnVwZGF0ZVNjaGVkdWxlKCk7XG4gICAgaWYgKHBsYXlpbmdJdGVtKSB7XG4gICAgICB0aGlzLmxvZyhgRmFsbGJhY2sgdG8gcHJpbWFyeSBmcm9tIGV2ZW50IFwiJHtpbnRlcnN0aXRpYWwuaWRlbnRpZmllcn1cIiBzdGFydDogJHtmbHVzaFN0YXJ0fSBwb3M6ICR7dGhpcy50aW1lbGluZVBvc30gcGxheWluZzogJHtwbGF5aW5nSXRlbSA/IHNlZ21lbnRUb1N0cmluZyhwbGF5aW5nSXRlbSkgOiAnPG5vbmU+J30gZXJyb3I6ICR7aW50ZXJzdGl0aWFsLmVycm9yfWApO1xuICAgICAgbGV0IHRpbWVsaW5lUG9zID0gdGhpcy50aW1lbGluZVBvcztcbiAgICAgIGlmICh0aW1lbGluZVBvcyA9PT0gLTEpIHtcbiAgICAgICAgdGltZWxpbmVQb3MgPSB0aGlzLmhscy5zdGFydFBvc2l0aW9uO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV3UGxheWluZ0l0ZW0gPSB0aGlzLnVwZGF0ZUl0ZW0ocGxheWluZ0l0ZW0sIHRpbWVsaW5lUG9zKTtcbiAgICAgIGlmICh0aGlzLml0ZW1zTWF0Y2gocGxheWluZ0l0ZW0sIG5ld1BsYXlpbmdJdGVtKSkge1xuICAgICAgICB0aGlzLmNsZWFySW50ZXJzdGl0aWFsKGludGVyc3RpdGlhbCwgbnVsbCk7XG4gICAgICB9XG4gICAgICBpZiAoaW50ZXJzdGl0aWFsLmFwcGVuZEluUGxhY2UpIHtcbiAgICAgICAgdGhpcy5hdHRhY2hQcmltYXJ5KGZsdXNoU3RhcnQsIG51bGwpO1xuICAgICAgICB0aGlzLmZsdXNoRnJvbnRCdWZmZXIoZmx1c2hTdGFydCk7XG4gICAgICB9XG4gICAgICBjb25zdCBzY2hlZHVsZUluZGV4ID0gdGhpcy5zY2hlZHVsZS5maW5kSXRlbUluZGV4QXRUaW1lKHRpbWVsaW5lUG9zKTtcbiAgICAgIHRoaXMuc2V0U2NoZWR1bGVQb3NpdGlvbihzY2hlZHVsZUluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jaGVja1N0YXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgLy8gQXNzZXQgTGlzdCBsb2FkaW5nXG4gIG9uQXNzZXRMaXN0TG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF90aGlzJGJ1ZmZlcmluZ0l0ZW0yO1xuICAgIGNvbnN0IGludGVyc3RpdGlhbCA9IGRhdGEuZXZlbnQ7XG4gICAgY29uc3QgaW50ZXJzdGl0aWFsSWQgPSBpbnRlcnN0aXRpYWwuaWRlbnRpZmllcjtcbiAgICBjb25zdCBhc3NldHMgPSBkYXRhLmFzc2V0TGlzdFJlc3BvbnNlLkFTU0VUUztcbiAgICBpZiAoIXRoaXMuc2NoZWR1bGUuaGFzRXZlbnQoaW50ZXJzdGl0aWFsSWQpKSB7XG4gICAgICAvLyBJbnRlcnN0aXRpYWwgd2l0aCBpZCB3YXMgcmVtb3ZlZFxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBldmVudFN0YXJ0ID0gaW50ZXJzdGl0aWFsLnRpbWVsaW5lU3RhcnQ7XG4gICAgY29uc3QgcHJldmlvdXNEdXJhdGlvbiA9IGludGVyc3RpdGlhbC5kdXJhdGlvbjtcbiAgICBsZXQgc3VtRHVyYXRpb24gPSAwO1xuICAgIGFzc2V0cy5mb3JFYWNoKChhc3NldCwgYXNzZXRMaXN0SW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gcGFyc2VGbG9hdChhc3NldC5EVVJBVElPTik7XG4gICAgICB0aGlzLmNyZWF0ZUFzc2V0KGludGVyc3RpdGlhbCwgYXNzZXRMaXN0SW5kZXgsIHN1bUR1cmF0aW9uLCBldmVudFN0YXJ0ICsgc3VtRHVyYXRpb24sIGR1cmF0aW9uLCBhc3NldC5VUkkpO1xuICAgICAgc3VtRHVyYXRpb24gKz0gZHVyYXRpb247XG4gICAgfSk7XG4gICAgaW50ZXJzdGl0aWFsLmR1cmF0aW9uID0gc3VtRHVyYXRpb247XG4gICAgdGhpcy5sb2coYExvYWRlZCBhc3NldC1saXN0IHdpdGggZHVyYXRpb246ICR7c3VtRHVyYXRpb259ICh3YXM6ICR7cHJldmlvdXNEdXJhdGlvbn0pICR7aW50ZXJzdGl0aWFsfWApO1xuICAgIGNvbnN0IHdhaXRpbmdJdGVtID0gdGhpcy53YWl0aW5nSXRlbTtcbiAgICBjb25zdCB3YWl0aW5nRm9ySXRlbSA9ICh3YWl0aW5nSXRlbSA9PSBudWxsID8gdm9pZCAwIDogd2FpdGluZ0l0ZW0uZXZlbnQuaWRlbnRpZmllcikgPT09IGludGVyc3RpdGlhbElkO1xuXG4gICAgLy8gVXBkYXRlIHNjaGVkdWxlIG5vdyB0aGF0IGFzc2V0LkRVUkFUSU9OKHMpIGFyZSBwYXJzZWRcbiAgICB0aGlzLnVwZGF0ZVNjaGVkdWxlKCk7XG4gICAgY29uc3QgYnVmZmVyaW5nRXZlbnQgPSAoX3RoaXMkYnVmZmVyaW5nSXRlbTIgPSB0aGlzLmJ1ZmZlcmluZ0l0ZW0pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRidWZmZXJpbmdJdGVtMi5ldmVudDtcblxuICAgIC8vIElmIGJ1ZmZlciByZWFjaGVkIEludGVyc3RpdGlhbCwgc3RhcnQgYnVmZmVyaW5nIGZpcnN0IGFzc2V0XG4gICAgaWYgKHdhaXRpbmdGb3JJdGVtKSB7XG4gICAgICB2YXIgX3RoaXMkc2NoZWR1bGUkaXRlbXM1O1xuICAgICAgLy8gQWR2YW5jZSBzY2hlZHVsZSB3aGVuIHdhaXRpbmcgZm9yIGFzc2V0IGxpc3QgZGF0YSB0byBwbGF5XG4gICAgICBjb25zdCBzY2hlZHVsZUluZGV4ID0gdGhpcy5zY2hlZHVsZS5maW5kRXZlbnRJbmRleChpbnRlcnN0aXRpYWxJZCk7XG4gICAgICBjb25zdCBpdGVtID0gKF90aGlzJHNjaGVkdWxlJGl0ZW1zNSA9IHRoaXMuc2NoZWR1bGUuaXRlbXMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRzY2hlZHVsZSRpdGVtczVbc2NoZWR1bGVJbmRleF07XG4gICAgICBpZiAoaXRlbSkge1xuICAgICAgICBpZiAoIXRoaXMucGxheWluZ0l0ZW0gJiYgdGhpcy50aW1lbGluZVBvcyA+IGl0ZW0uZW5kKSB7XG4gICAgICAgICAgLy8gQWJhbmRvbiBpZiBuZXcgZHVyYXRpb24gaXMgcmVkdWNlZCBlbm91Z2ggdG8gbGFuZCBwbGF5YmFjayBpbiBwcmltYXJ5IHN0YXJ0XG4gICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnNjaGVkdWxlLmZpbmRJdGVtSW5kZXhBdFRpbWUodGhpcy50aW1lbGluZVBvcyk7XG4gICAgICAgICAgaWYgKGluZGV4ICE9PSBzY2hlZHVsZUluZGV4KSB7XG4gICAgICAgICAgICBpbnRlcnN0aXRpYWwuZXJyb3IgPSBuZXcgRXJyb3IoYEludGVyc3RpdGlhbCBubyBsb25nZXIgd2l0aGluIHBsYXliYWNrIHJhbmdlICR7dGhpcy50aW1lbGluZVBvc30gJHtpbnRlcnN0aXRpYWx9YCk7XG4gICAgICAgICAgICB0aGlzLnByaW1hcnlGYWxsYmFjayhpbnRlcnN0aXRpYWwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldEJ1ZmZlcmluZ0l0ZW0oaXRlbSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFNjaGVkdWxlUG9zaXRpb24oc2NoZWR1bGVJbmRleCk7XG4gICAgfSBlbHNlIGlmICgoYnVmZmVyaW5nRXZlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGJ1ZmZlcmluZ0V2ZW50LmlkZW50aWZpZXIpID09PSBpbnRlcnN0aXRpYWxJZCAmJiBidWZmZXJpbmdFdmVudC5hcHBlbmRJblBsYWNlKSB7XG4gICAgICAvLyBJZiBidWZmZXJpbmcgKGJ1dCBub3QgcGxheWJhY2spIGhhcyByZWFjaGVkIHRoaXMgaXRlbSB0cmFuc2ZlciBtZWRpYS1zb3VyY2VcbiAgICAgIGNvbnN0IGFzc2V0SXRlbSA9IGludGVyc3RpdGlhbC5hc3NldExpc3RbMF07XG4gICAgICBjb25zdCBwbGF5ZXIgPSB0aGlzLmdldEFzc2V0UGxheWVyKGFzc2V0SXRlbS5pZGVudGlmaWVyKTtcbiAgICAgIGNvbnN0IG1lZGlhID0gdGhpcy5wcmltYXJ5TWVkaWE7XG4gICAgICBpZiAoYXNzZXRJdGVtICYmIHBsYXllciAmJiBtZWRpYSkge1xuICAgICAgICB0aGlzLmJ1ZmZlckFzc2V0UGxheWVyKHBsYXllciwgbWVkaWEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgc3dpdGNoIChkYXRhLmRldGFpbHMpIHtcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkFTU0VUX0xJU1RfUEFSU0lOR19FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkFTU0VUX0xJU1RfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkFTU0VUX0xJU1RfTE9BRF9USU1FT1VUOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgaW50ZXJzdGl0aWFsID0gZGF0YS5pbnRlcnN0aXRpYWw7XG4gICAgICAgICAgaWYgKGludGVyc3RpdGlhbCkge1xuICAgICAgICAgICAgdGhpcy5wcmltYXJ5RmFsbGJhY2soaW50ZXJzdGl0aWFsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9TVEFMTEVEX0VSUk9SOlxuICAgICAgICB7XG4gICAgICAgICAgdGhpcy5vblRpbWV1cGRhdGUoKTtcbiAgICAgICAgICB0aGlzLmNoZWNrQnVmZmVyKHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IFRJQ0tfSU5URVJWQUwkMiA9IDUwMDsgLy8gaG93IG9mdGVuIHRvIHRpY2sgaW4gbXNcblxuY2xhc3MgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyIGV4dGVuZHMgQmFzZVN0cmVhbUNvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihobHMsIGZyYWdtZW50VHJhY2tlciwga2V5TG9hZGVyKSB7XG4gICAgc3VwZXIoaGxzLCBmcmFnbWVudFRyYWNrZXIsIGtleUxvYWRlciwgJ3N1YnRpdGxlLXN0cmVhbS1jb250cm9sbGVyJywgUGxheWxpc3RMZXZlbFR5cGUuU1VCVElUTEUpO1xuICAgIHRoaXMuY3VycmVudFRyYWNrSWQgPSAtMTtcbiAgICB0aGlzLnRyYWNrc0J1ZmZlcmVkID0gW107XG4gICAgdGhpcy5tYWluRGV0YWlscyA9IG51bGw7XG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIG9uSGFuZGxlckRlc3Ryb3lpbmcoKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgc3VwZXIub25IYW5kbGVyRGVzdHJveWluZygpO1xuICAgIHRoaXMubWFpbkRldGFpbHMgPSBudWxsO1xuICB9XG4gIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHN1cGVyLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5TVUJUSVRMRV9UUkFDS1NfVVBEQVRFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tzVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5TVUJUSVRMRV9UUkFDS19TV0lUQ0gsIHRoaXMub25TdWJ0aXRsZVRyYWNrU3dpdGNoLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLlNVQlRJVExFX1RSQUNLX0xPQURFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHRoaXMub25TdWJ0aXRsZUZyYWdQcm9jZXNzZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0ZMVVNISU5HLCB0aGlzLm9uQnVmZmVyRmx1c2hpbmcsIHRoaXMpO1xuICB9XG4gIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgc3VwZXIudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5TVUJUSVRMRV9UUkFDS1NfVVBEQVRFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tzVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuU1VCVElUTEVfVFJBQ0tfU1dJVENILCB0aGlzLm9uU3VidGl0bGVUcmFja1N3aXRjaCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuU1VCVElUTEVfVFJBQ0tfTE9BREVELCB0aGlzLm9uU3VidGl0bGVUcmFja0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHRoaXMub25TdWJ0aXRsZUZyYWdQcm9jZXNzZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgfVxuICBzdGFydExvYWQoc3RhcnRQb3NpdGlvbiwgc2tpcFNlZWtUb1N0YXJ0UG9zaXRpb24pIHtcbiAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgdGhpcy5zZXRJbnRlcnZhbChUSUNLX0lOVEVSVkFMJDIpO1xuICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gc3RhcnRQb3NpdGlvbiArIHRoaXMudGltZWxpbmVPZmZzZXQ7XG4gICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc2tpcFNlZWtUb1N0YXJ0UG9zaXRpb24gPyAtMSA6IHN0YXJ0UG9zaXRpb247XG4gICAgdGhpcy50aWNrKCk7XG4gIH1cbiAgb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgc3VwZXIub25NYW5pZmVzdExvYWRpbmcoKTtcbiAgICB0aGlzLm1haW5EZXRhaWxzID0gbnVsbDtcbiAgfVxuICBvbk1lZGlhRGV0YWNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy50cmFja3NCdWZmZXJlZCA9IFtdO1xuICAgIHN1cGVyLm9uTWVkaWFEZXRhY2hpbmcoZXZlbnQsIGRhdGEpO1xuICB9XG4gIG9uTGV2ZWxMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLm1haW5EZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuICB9XG4gIG9uU3VidGl0bGVGcmFnUHJvY2Vzc2VkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIHN1Y2Nlc3NcbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoIXRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpKSB7XG4gICAgICBpZiAoaXNNZWRpYUZyYWdtZW50KGZyYWcpKSB7XG4gICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gZnJhZztcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIH1cbiAgICBpZiAoIXN1Y2Nlc3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYnVmZmVyZWQgPSB0aGlzLnRyYWNrc0J1ZmZlcmVkW3RoaXMuY3VycmVudFRyYWNrSWRdO1xuICAgIGlmICghYnVmZmVyZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUvdXBkYXRlIGEgYnVmZmVyZWQgYXJyYXkgbWF0Y2hpbmcgdGhlIGludGVyZmFjZSB1c2VkIGJ5IEJ1ZmZlckhlbHBlci5idWZmZXJlZEluZm9cbiAgICAvLyBzbyB3ZSBjYW4gcmUtdXNlIHRoZSBsb2dpYyB1c2VkIHRvIGRldGVjdCBob3cgbXVjaCBoYXMgYmVlbiBidWZmZXJlZFxuICAgIGxldCB0aW1lUmFuZ2U7XG4gICAgY29uc3QgZnJhZ1N0YXJ0ID0gZnJhZy5zdGFydDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZnJhZ1N0YXJ0ID49IGJ1ZmZlcmVkW2ldLnN0YXJ0ICYmIGZyYWdTdGFydCA8PSBidWZmZXJlZFtpXS5lbmQpIHtcbiAgICAgICAgdGltZVJhbmdlID0gYnVmZmVyZWRbaV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmcmFnRW5kID0gZnJhZy5zdGFydCArIGZyYWcuZHVyYXRpb247XG4gICAgaWYgKHRpbWVSYW5nZSkge1xuICAgICAgdGltZVJhbmdlLmVuZCA9IGZyYWdFbmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVSYW5nZSA9IHtcbiAgICAgICAgc3RhcnQ6IGZyYWdTdGFydCxcbiAgICAgICAgZW5kOiBmcmFnRW5kXG4gICAgICB9O1xuICAgICAgYnVmZmVyZWQucHVzaCh0aW1lUmFuZ2UpO1xuICAgIH1cbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5mcmFnQnVmZmVyZWQoZnJhZyk7XG4gICAgdGhpcy5mcmFnQnVmZmVyZWRDb21wbGV0ZShmcmFnLCBudWxsKTtcbiAgICBpZiAodGhpcy5tZWRpYSkge1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfVxuICB9XG4gIG9uQnVmZmVyRmx1c2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFydE9mZnNldCxcbiAgICAgIGVuZE9mZnNldFxuICAgIH0gPSBkYXRhO1xuICAgIGlmIChzdGFydE9mZnNldCA9PT0gMCAmJiBlbmRPZmZzZXQgIT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkge1xuICAgICAgY29uc3QgZW5kT2Zmc2V0U3VidGl0bGVzID0gZW5kT2Zmc2V0IC0gMTtcbiAgICAgIGlmIChlbmRPZmZzZXRTdWJ0aXRsZXMgPD0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkYXRhLmVuZE9mZnNldFN1YnRpdGxlcyA9IE1hdGgubWF4KDAsIGVuZE9mZnNldFN1YnRpdGxlcyk7XG4gICAgICB0aGlzLnRyYWNrc0J1ZmZlcmVkLmZvckVhY2goYnVmZmVyZWQgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDspIHtcbiAgICAgICAgICBpZiAoYnVmZmVyZWRbaV0uZW5kIDw9IGVuZE9mZnNldFN1YnRpdGxlcykge1xuICAgICAgICAgICAgYnVmZmVyZWQuc2hpZnQoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYnVmZmVyZWRbaV0uc3RhcnQgPCBlbmRPZmZzZXRTdWJ0aXRsZXMpIHtcbiAgICAgICAgICAgIGJ1ZmZlcmVkW2ldLnN0YXJ0ID0gZW5kT2Zmc2V0U3VidGl0bGVzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50c0luUmFuZ2Uoc3RhcnRPZmZzZXQsIGVuZE9mZnNldFN1YnRpdGxlcywgUGxheWxpc3RMZXZlbFR5cGUuU1VCVElUTEUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHNvbWV0aGluZyBnb2VzIHdyb25nLCBwcm9jZWVkIHRvIG5leHQgZnJhZywgaWYgd2Ugd2VyZSBwcm9jZXNzaW5nIG9uZS5cbiAgb25FcnJvcihldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgaWYgKChmcmFnID09IG51bGwgPyB2b2lkIDAgOiBmcmFnLnR5cGUpID09PSBQbGF5bGlzdExldmVsVHlwZS5TVUJUSVRMRSkge1xuICAgICAgaWYgKGRhdGEuZGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLkZSQUdfR0FQKSB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLmZyYWdCdWZmZXJlZChmcmFnLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmZyYWdDdXJyZW50KSB7XG4gICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQuYWJvcnRSZXF1ZXN0cygpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFN0YXRlLlNUT1BQRUQpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gR290IGFsbCBuZXcgc3VidGl0bGUgbGV2ZWxzLlxuICBvblN1YnRpdGxlVHJhY2tzVXBkYXRlZChldmVudCwge1xuICAgIHN1YnRpdGxlVHJhY2tzXG4gIH0pIHtcbiAgICBpZiAodGhpcy5sZXZlbHMgJiYgc3VidGl0bGVPcHRpb25zSWRlbnRpY2FsKHRoaXMubGV2ZWxzLCBzdWJ0aXRsZVRyYWNrcykpIHtcbiAgICAgIHRoaXMubGV2ZWxzID0gc3VidGl0bGVUcmFja3MubWFwKG1lZGlhUGxheWxpc3QgPT4gbmV3IExldmVsKG1lZGlhUGxheWxpc3QpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy50cmFja3NCdWZmZXJlZCA9IFtdO1xuICAgIHRoaXMubGV2ZWxzID0gc3VidGl0bGVUcmFja3MubWFwKG1lZGlhUGxheWxpc3QgPT4ge1xuICAgICAgY29uc3QgbGV2ZWwgPSBuZXcgTGV2ZWwobWVkaWFQbGF5bGlzdCk7XG4gICAgICB0aGlzLnRyYWNrc0J1ZmZlcmVkW2xldmVsLmlkXSA9IFtdO1xuICAgICAgcmV0dXJuIGxldmVsO1xuICAgIH0pO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50c0luUmFuZ2UoMCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBQbGF5bGlzdExldmVsVHlwZS5TVUJUSVRMRSk7XG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgIHRoaXMubWVkaWFCdWZmZXIgPSBudWxsO1xuICB9XG4gIG9uU3VidGl0bGVUcmFja1N3aXRjaChldmVudCwgZGF0YSkge1xuICAgIHZhciBfdGhpcyRsZXZlbHM7XG4gICAgdGhpcy5jdXJyZW50VHJhY2tJZCA9IGRhdGEuaWQ7XG4gICAgaWYgKCEoKF90aGlzJGxldmVscyA9IHRoaXMubGV2ZWxzKSAhPSBudWxsICYmIF90aGlzJGxldmVscy5sZW5ndGgpIHx8IHRoaXMuY3VycmVudFRyYWNrSWQgPT09IC0xKSB7XG4gICAgICB0aGlzLmNsZWFySW50ZXJ2YWwoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0cmFjayBoYXMgdGhlIG5lY2Vzc2FyeSBkZXRhaWxzIHRvIGxvYWQgZnJhZ21lbnRzXG4gICAgY29uc3QgY3VycmVudFRyYWNrID0gdGhpcy5sZXZlbHNbdGhpcy5jdXJyZW50VHJhY2tJZF07XG4gICAgaWYgKGN1cnJlbnRUcmFjayAhPSBudWxsICYmIGN1cnJlbnRUcmFjay5kZXRhaWxzKSB7XG4gICAgICB0aGlzLm1lZGlhQnVmZmVyID0gdGhpcy5tZWRpYUJ1ZmZlclRpbWVSYW5nZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFRyYWNrICYmIHRoaXMuc3RhdGUgIT09IFN0YXRlLlNUT1BQRUQpIHtcbiAgICAgIHRoaXMuc2V0SW50ZXJ2YWwoVElDS19JTlRFUlZBTCQyKTtcbiAgICB9XG4gIH1cblxuICAvLyBHb3QgYSBuZXcgc2V0IG9mIHN1YnRpdGxlIGZyYWdtZW50cy5cbiAgb25TdWJ0aXRsZVRyYWNrTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF90cmFjayRkZXRhaWxzO1xuICAgIGNvbnN0IHtcbiAgICAgIGN1cnJlbnRUcmFja0lkLFxuICAgICAgbGV2ZWxzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgZGV0YWlsczogbmV3RGV0YWlscyxcbiAgICAgIGlkOiB0cmFja0lkXG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKCFsZXZlbHMpIHtcbiAgICAgIHRoaXMud2FybihgU3VidGl0bGUgdHJhY2tzIHdlcmUgcmVzZXQgd2hpbGUgbG9hZGluZyBsZXZlbCAke3RyYWNrSWR9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRyYWNrID0gbGV2ZWxzW3RyYWNrSWRdO1xuICAgIGlmICh0cmFja0lkID49IGxldmVscy5sZW5ndGggfHwgIXRyYWNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubG9nKGBTdWJ0aXRsZSB0cmFjayAke3RyYWNrSWR9IGxvYWRlZCBbJHtuZXdEZXRhaWxzLnN0YXJ0U059LCR7bmV3RGV0YWlscy5lbmRTTn1dJHtuZXdEZXRhaWxzLmxhc3RQYXJ0U24gPyBgW3BhcnQtJHtuZXdEZXRhaWxzLmxhc3RQYXJ0U259LSR7bmV3RGV0YWlscy5sYXN0UGFydEluZGV4fV1gIDogJyd9LGR1cmF0aW9uOiR7bmV3RGV0YWlscy50b3RhbGR1cmF0aW9ufWApO1xuICAgIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhQnVmZmVyVGltZVJhbmdlcztcbiAgICBsZXQgc2xpZGluZyA9IDA7XG4gICAgaWYgKG5ld0RldGFpbHMubGl2ZSB8fCAoX3RyYWNrJGRldGFpbHMgPSB0cmFjay5kZXRhaWxzKSAhPSBudWxsICYmIF90cmFjayRkZXRhaWxzLmxpdmUpIHtcbiAgICAgIGlmIChuZXdEZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1haW5EZXRhaWxzID0gdGhpcy5tYWluRGV0YWlscztcbiAgICAgIGlmICghbWFpbkRldGFpbHMpIHtcbiAgICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbWFpblNsaWRpbmdTdGFydEZyYWdtZW50ID0gbWFpbkRldGFpbHMuZnJhZ21lbnRzWzBdO1xuICAgICAgaWYgKCF0cmFjay5kZXRhaWxzKSB7XG4gICAgICAgIGlmIChuZXdEZXRhaWxzLmhhc1Byb2dyYW1EYXRlVGltZSAmJiBtYWluRGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICAgICAgICBhbGlnbk1lZGlhUGxheWxpc3RCeVBEVChuZXdEZXRhaWxzLCBtYWluRGV0YWlscyk7XG4gICAgICAgICAgc2xpZGluZyA9IG5ld0RldGFpbHMuZnJhZ21lbnRTdGFydDtcbiAgICAgICAgfSBlbHNlIGlmIChtYWluU2xpZGluZ1N0YXJ0RnJhZ21lbnQpIHtcbiAgICAgICAgICAvLyBsaW5lIHVwIGxpdmUgcGxheWxpc3Qgd2l0aCBtYWluIHNvIHRoYXQgZnJhZ21lbnRzIGluIHJhbmdlIGFyZSBsb2FkZWRcbiAgICAgICAgICBzbGlkaW5nID0gbWFpblNsaWRpbmdTdGFydEZyYWdtZW50LnN0YXJ0O1xuICAgICAgICAgIGFkZFNsaWRpbmcobmV3RGV0YWlscywgc2xpZGluZyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfdGhpcyRsZXZlbExhc3RMb2FkZWQ7XG4gICAgICAgIHNsaWRpbmcgPSB0aGlzLmFsaWduUGxheWxpc3RzKG5ld0RldGFpbHMsIHRyYWNrLmRldGFpbHMsIChfdGhpcyRsZXZlbExhc3RMb2FkZWQgPSB0aGlzLmxldmVsTGFzdExvYWRlZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGxldmVsTGFzdExvYWRlZC5kZXRhaWxzKTtcbiAgICAgICAgaWYgKHNsaWRpbmcgPT09IDAgJiYgbWFpblNsaWRpbmdTdGFydEZyYWdtZW50KSB7XG4gICAgICAgICAgLy8gcmVhbGlnbiB3aXRoIG1haW4gd2hlbiB0aGVyZSBpcyBubyBvdmVybGFwIHdpdGggbGFzdCByZWZyZXNoXG4gICAgICAgICAgc2xpZGluZyA9IG1haW5TbGlkaW5nU3RhcnRGcmFnbWVudC5zdGFydDtcbiAgICAgICAgICBhZGRTbGlkaW5nKG5ld0RldGFpbHMsIHNsaWRpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBjb21wdXRlIHN0YXJ0IHBvc2l0aW9uIGlmIHdlIGFyZSBhbGlnbmVkIHdpdGggdGhlIG1haW4gcGxheWxpc3RcbiAgICAgIGlmIChtYWluRGV0YWlscyAmJiAhdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQpIHtcbiAgICAgICAgdGhpcy5zZXRTdGFydFBvc2l0aW9uKG1haW5EZXRhaWxzLCBzbGlkaW5nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJhY2suZGV0YWlscyA9IG5ld0RldGFpbHM7XG4gICAgdGhpcy5sZXZlbExhc3RMb2FkZWQgPSB0cmFjaztcbiAgICBpZiAodHJhY2tJZCAhPT0gY3VycmVudFRyYWNrSWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuU1VCVElUTEVfVFJBQ0tfVVBEQVRFRCwge1xuICAgICAgZGV0YWlsczogbmV3RGV0YWlscyxcbiAgICAgIGlkOiB0cmFja0lkLFxuICAgICAgZ3JvdXBJZDogZGF0YS5ncm91cElkXG4gICAgfSk7XG5cbiAgICAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgdGhpcy50aWNrKCk7XG5cbiAgICAvLyBJZiBwbGF5bGlzdCBpcyBtaXNhbGlnbmVkIGJlY2F1c2Ugb2YgYmFkIFBEVCBvciBkcmlmdCwgZGVsZXRlIGRldGFpbHMgdG8gcmVzeW5jIHdpdGggbWFpbiBvbiByZWxvYWRcbiAgICBpZiAobmV3RGV0YWlscy5saXZlICYmICF0aGlzLmZyYWdDdXJyZW50ICYmIHRoaXMubWVkaWEgJiYgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuSURMRSkge1xuICAgICAgY29uc3QgZm91bmRGcmFnID0gZmluZEZyYWdtZW50QnlQVFMobnVsbCwgbmV3RGV0YWlscy5mcmFnbWVudHMsIHRoaXMubWVkaWEuY3VycmVudFRpbWUsIDApO1xuICAgICAgaWYgKCFmb3VuZEZyYWcpIHtcbiAgICAgICAgdGhpcy53YXJuKCdTdWJ0aXRsZSBwbGF5bGlzdCBub3QgYWxpZ25lZCB3aXRoIHBsYXliYWNrJyk7XG4gICAgICAgIHRyYWNrLmRldGFpbHMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZShmcmFnTG9hZGVkRGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWcsXG4gICAgICBwYXlsb2FkXG4gICAgfSA9IGZyYWdMb2FkZWREYXRhO1xuICAgIGNvbnN0IGRlY3J5cHREYXRhID0gZnJhZy5kZWNyeXB0ZGF0YTtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBpZiAodGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gY2hlY2sgdG8gc2VlIGlmIHRoZSBwYXlsb2FkIG5lZWRzIHRvIGJlIGRlY3J5cHRlZFxuICAgIGlmIChwYXlsb2FkICYmIHBheWxvYWQuYnl0ZUxlbmd0aCA+IDAgJiYgZGVjcnlwdERhdGEgIT0gbnVsbCAmJiBkZWNyeXB0RGF0YS5rZXkgJiYgZGVjcnlwdERhdGEuaXYgJiYgaXNGdWxsU2VnbWVudEVuY3J5cHRpb24oZGVjcnlwdERhdGEubWV0aG9kKSkge1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAvLyBkZWNyeXB0IHRoZSBzdWJ0aXRsZXNcbiAgICAgIHRoaXMuZGVjcnlwdGVyLmRlY3J5cHQobmV3IFVpbnQ4QXJyYXkocGF5bG9hZCksIGRlY3J5cHREYXRhLmtleS5idWZmZXIsIGRlY3J5cHREYXRhLml2LmJ1ZmZlciwgZ2V0QWVzTW9kZUZyb21GdWxsU2VnbWVudE1ldGhvZChkZWNyeXB0RGF0YS5tZXRob2QpKS5jYXRjaChlcnIgPT4ge1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0RFQ1JZUFRfRVJST1IsXG4gICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgICAgcmVhc29uOiBlcnIubWVzc2FnZSxcbiAgICAgICAgICBmcmFnXG4gICAgICAgIH0pO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9KS50aGVuKGRlY3J5cHRlZERhdGEgPT4ge1xuICAgICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0RFQ1JZUFRFRCwge1xuICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgcGF5bG9hZDogZGVjcnlwdGVkRGF0YSxcbiAgICAgICAgICBzdGF0czoge1xuICAgICAgICAgICAgdHN0YXJ0OiBzdGFydFRpbWUsXG4gICAgICAgICAgICB0ZGVjcnlwdDogZW5kVGltZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICB0aGlzLndhcm4oYCR7ZXJyLm5hbWV9OiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBkb1RpY2soKSB7XG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLklETEUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY3VycmVudFRyYWNrSWQsXG4gICAgICAgIGxldmVsc1xuICAgICAgfSA9IHRoaXM7XG4gICAgICBjb25zdCB0cmFjayA9IGxldmVscyA9PSBudWxsID8gdm9pZCAwIDogbGV2ZWxzW2N1cnJlbnRUcmFja0lkXTtcbiAgICAgIGlmICghdHJhY2sgfHwgIWxldmVscy5sZW5ndGggfHwgIXRyYWNrLmRldGFpbHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMud2FpdEZvckxpdmUodHJhY2spKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29uZmlnXG4gICAgICB9ID0gdGhpcztcbiAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gdGhpcy5nZXRMb2FkUG9zaXRpb24oKTtcbiAgICAgIGNvbnN0IGJ1ZmZlcmVkSW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJlZEluZm8odGhpcy50cmFja3NCdWZmZXJlZFt0aGlzLmN1cnJlbnRUcmFja0lkXSB8fCBbXSwgY3VycmVudFRpbWUsIGNvbmZpZy5tYXhCdWZmZXJIb2xlKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZW5kOiB0YXJnZXRCdWZmZXJUaW1lLFxuICAgICAgICBsZW46IGJ1ZmZlckxlblxuICAgICAgfSA9IGJ1ZmZlcmVkSW5mbztcbiAgICAgIGNvbnN0IHRyYWNrRGV0YWlscyA9IHRyYWNrLmRldGFpbHM7XG4gICAgICBjb25zdCBtYXhCdWZMZW4gPSB0aGlzLmhscy5tYXhCdWZmZXJMZW5ndGggKyB0cmFja0RldGFpbHMubGV2ZWxUYXJnZXREdXJhdGlvbjtcbiAgICAgIGlmIChidWZmZXJMZW4gPiBtYXhCdWZMZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZnJhZ21lbnRzID0gdHJhY2tEZXRhaWxzLmZyYWdtZW50cztcbiAgICAgIGNvbnN0IGZyYWdMZW4gPSBmcmFnbWVudHMubGVuZ3RoO1xuICAgICAgY29uc3QgZW5kID0gdHJhY2tEZXRhaWxzLmVkZ2U7XG4gICAgICBsZXQgZm91bmRGcmFnID0gbnVsbDtcbiAgICAgIGNvbnN0IGZyYWdQcmV2aW91cyA9IHRoaXMuZnJhZ1ByZXZpb3VzO1xuICAgICAgaWYgKHRhcmdldEJ1ZmZlclRpbWUgPCBlbmQpIHtcbiAgICAgICAgY29uc3QgdG9sZXJhbmNlID0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2U7XG4gICAgICAgIGNvbnN0IGxvb2t1cFRvbGVyYW5jZSA9IHRhcmdldEJ1ZmZlclRpbWUgPiBlbmQgLSB0b2xlcmFuY2UgPyAwIDogdG9sZXJhbmNlO1xuICAgICAgICBmb3VuZEZyYWcgPSBmaW5kRnJhZ21lbnRCeVBUUyhmcmFnUHJldmlvdXMsIGZyYWdtZW50cywgTWF0aC5tYXgoZnJhZ21lbnRzWzBdLnN0YXJ0LCB0YXJnZXRCdWZmZXJUaW1lKSwgbG9va3VwVG9sZXJhbmNlKTtcbiAgICAgICAgaWYgKCFmb3VuZEZyYWcgJiYgZnJhZ1ByZXZpb3VzICYmIGZyYWdQcmV2aW91cy5zdGFydCA8IGZyYWdtZW50c1swXS5zdGFydCkge1xuICAgICAgICAgIGZvdW5kRnJhZyA9IGZyYWdtZW50c1swXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm91bmRGcmFnID0gZnJhZ21lbnRzW2ZyYWdMZW4gLSAxXTtcbiAgICAgIH1cbiAgICAgIGZvdW5kRnJhZyA9IHRoaXMuZmlsdGVyUmVwbGFjZWRQcmltYXJ5KGZvdW5kRnJhZywgdHJhY2suZGV0YWlscyk7XG4gICAgICBpZiAoIWZvdW5kRnJhZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBMb2FkIGVhcmxpZXIgZnJhZ21lbnQgaW4gc2FtZSBkaXNjb250aW51aXR5IHRvIG1ha2UgdXAgZm9yIG1pc2FsaWduZWQgcGxheWxpc3RzIGFuZCBjdWVzIHRoYXQgZXh0ZW5kIGJleW9uZCBlbmQgb2Ygc2VnbWVudFxuICAgICAgY29uc3QgY3VyU05JZHggPSBmb3VuZEZyYWcuc24gLSB0cmFja0RldGFpbHMuc3RhcnRTTjtcbiAgICAgIGNvbnN0IHByZXZGcmFnID0gZnJhZ21lbnRzW2N1clNOSWR4IC0gMV07XG4gICAgICBpZiAocHJldkZyYWcgJiYgcHJldkZyYWcuY2MgPT09IGZvdW5kRnJhZy5jYyAmJiB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShwcmV2RnJhZykgPT09IEZyYWdtZW50U3RhdGUuTk9UX0xPQURFRCkge1xuICAgICAgICBmb3VuZEZyYWcgPSBwcmV2RnJhZztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmb3VuZEZyYWcpID09PSBGcmFnbWVudFN0YXRlLk5PVF9MT0FERUQpIHtcbiAgICAgICAgLy8gb25seSBsb2FkIGlmIGZyYWdtZW50IGlzIG5vdCBsb2FkZWRcbiAgICAgICAgY29uc3QgZnJhZ1RvTG9hZCA9IHRoaXMubWFwVG9Jbml0RnJhZ1doZW5SZXF1aXJlZChmb3VuZEZyYWcpO1xuICAgICAgICBpZiAoZnJhZ1RvTG9hZCkge1xuICAgICAgICAgIHRoaXMubG9hZEZyYWdtZW50KGZyYWdUb0xvYWQsIHRyYWNrLCB0YXJnZXRCdWZmZXJUaW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBsb2FkRnJhZ21lbnQoZnJhZywgbGV2ZWwsIHRhcmdldEJ1ZmZlclRpbWUpIHtcbiAgICBpZiAoIWlzTWVkaWFGcmFnbWVudChmcmFnKSkge1xuICAgICAgdGhpcy5fbG9hZEluaXRTZWdtZW50KGZyYWcsIGxldmVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VwZXIubG9hZEZyYWdtZW50KGZyYWcsIGxldmVsLCB0YXJnZXRCdWZmZXJUaW1lKTtcbiAgICB9XG4gIH1cbiAgZ2V0IG1lZGlhQnVmZmVyVGltZVJhbmdlcygpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcmFibGVJbnN0YW5jZSh0aGlzLnRyYWNrc0J1ZmZlcmVkW3RoaXMuY3VycmVudFRyYWNrSWRdIHx8IFtdKTtcbiAgfVxufVxuY2xhc3MgQnVmZmVyYWJsZUluc3RhbmNlIHtcbiAgY29uc3RydWN0b3IodGltZXJhbmdlcykge1xuICAgIHRoaXMuYnVmZmVyZWQgPSB2b2lkIDA7XG4gICAgY29uc3QgZ2V0UmFuZ2UgPSAobmFtZSwgaW5kZXgsIGxlbmd0aCkgPT4ge1xuICAgICAgaW5kZXggPSBpbmRleCA+Pj4gMDtcbiAgICAgIGlmIChpbmRleCA+IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihgRmFpbGVkIHRvIGV4ZWN1dGUgJyR7bmFtZX0nIG9uICdUaW1lUmFuZ2VzJzogVGhlIGluZGV4IHByb3ZpZGVkICgke2luZGV4fSkgaXMgZ3JlYXRlciB0aGFuIHRoZSBtYXhpbXVtIGJvdW5kICgke2xlbmd0aH0pYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGltZXJhbmdlc1tpbmRleF1bbmFtZV07XG4gICAgfTtcbiAgICB0aGlzLmJ1ZmZlcmVkID0ge1xuICAgICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRpbWVyYW5nZXMubGVuZ3RoO1xuICAgICAgfSxcbiAgICAgIGVuZChpbmRleCkge1xuICAgICAgICByZXR1cm4gZ2V0UmFuZ2UoJ2VuZCcsIGluZGV4LCB0aW1lcmFuZ2VzLmxlbmd0aCk7XG4gICAgICB9LFxuICAgICAgc3RhcnQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGdldFJhbmdlKCdzdGFydCcsIGluZGV4LCB0aW1lcmFuZ2VzLmxlbmd0aCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqXG4gKiBUaGlzIGNvZGUgd2FzIHBvcnRlZCBmcm9tIHRoZSBkYXNoLmpzIHByb2plY3QgYXQ6XG4gKiAgIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXNoLUluZHVzdHJ5LUZvcnVtL2Rhc2guanMvYmxvYi9kZXZlbG9wbWVudC9leHRlcm5hbHMvY2VhNjA4LXBhcnNlci5qc1xuICogICBodHRwczovL2dpdGh1Yi5jb20vRGFzaC1JbmR1c3RyeS1Gb3J1bS9kYXNoLmpzL2NvbW1pdC84MjY5YjI2YTc2MWUwODUzYmIyMWQ3ODc4MGVkOTQ1MTQ0ZWNkZDRkI2RpZmYtNzFiYzI5NWEyZDZiNmI3MDkzYTFkMzI5MGQ1M2E0YjJcbiAqXG4gKiBUaGUgb3JpZ2luYWwgY29weXJpZ2h0IGFwcGVhcnMgYmVsb3c6XG4gKlxuICogVGhlIGNvcHlyaWdodCBpbiB0aGlzIHNvZnR3YXJlIGlzIGJlaW5nIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZSBCU0QgTGljZW5zZSxcbiAqIGluY2x1ZGVkIGJlbG93LiBUaGlzIHNvZnR3YXJlIG1heSBiZSBzdWJqZWN0IHRvIG90aGVyIHRoaXJkIHBhcnR5IGFuZCBjb250cmlidXRvclxuICogcmlnaHRzLCBpbmNsdWRpbmcgcGF0ZW50IHJpZ2h0cywgYW5kIG5vIHN1Y2ggcmlnaHRzIGFyZSBncmFudGVkIHVuZGVyIHRoaXMgbGljZW5zZS5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtMjAxNiwgREFTSCBJbmR1c3RyeSBGb3J1bS5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbiAqIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAqICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vclxuICogIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKiAgMi4gTmVpdGhlciB0aGUgbmFtZSBvZiBEYXNoIEluZHVzdHJ5IEZvcnVtIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZVxuICogIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIEFTIElTIEFORCBBTllcbiAqICBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG4gKiAgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELlxuICogIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsXG4gKiAgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVFxuICogIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqICBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSxcbiAqICBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4gKiAgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiAqICBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuLyoqXG4gKiAgRXhjZXB0aW9ucyBmcm9tIHJlZ3VsYXIgQVNDSUkuIENvZGVQb2ludHMgYXJlIG1hcHBlZCB0byBVVEYtMTYgY29kZXNcbiAqL1xuXG5jb25zdCBzcGVjaWFsQ2VhNjA4Q2hhcnNDb2RlcyA9IHtcbiAgMHgyYTogMHhlMSxcbiAgLy8gbG93ZXJjYXNlIGEsIGFjdXRlIGFjY2VudFxuICAweDVjOiAweGU5LFxuICAvLyBsb3dlcmNhc2UgZSwgYWN1dGUgYWNjZW50XG4gIDB4NWU6IDB4ZWQsXG4gIC8vIGxvd2VyY2FzZSBpLCBhY3V0ZSBhY2NlbnRcbiAgMHg1ZjogMHhmMyxcbiAgLy8gbG93ZXJjYXNlIG8sIGFjdXRlIGFjY2VudFxuICAweDYwOiAweGZhLFxuICAvLyBsb3dlcmNhc2UgdSwgYWN1dGUgYWNjZW50XG4gIDB4N2I6IDB4ZTcsXG4gIC8vIGxvd2VyY2FzZSBjIHdpdGggY2VkaWxsYVxuICAweDdjOiAweGY3LFxuICAvLyBkaXZpc2lvbiBzeW1ib2xcbiAgMHg3ZDogMHhkMSxcbiAgLy8gdXBwZXJjYXNlIE4gdGlsZGVcbiAgMHg3ZTogMHhmMSxcbiAgLy8gbG93ZXJjYXNlIG4gdGlsZGVcbiAgMHg3ZjogMHgyNTg4LFxuICAvLyBGdWxsIGJsb2NrXG4gIC8vIFRISVMgQkxPQ0sgSU5DTFVERVMgVEhFIDE2IEVYVEVOREVEIChUV08tQllURSkgTElORSAyMSBDSEFSQUNURVJTXG4gIC8vIFRIQVQgQ09NRSBGUk9NIEhJIEJZVEU9MHgxMSBBTkQgTE9XIEJFVFdFRU4gMHgzMCBBTkQgMHgzRlxuICAvLyBUSElTIE1FQU5TIFRIQVQgXFx4NTAgTVVTVCBCRSBBRERFRCBUTyBUSEUgVkFMVUVTXG4gIDB4ODA6IDB4YWUsXG4gIC8vIFJlZ2lzdGVyZWQgc3ltYm9sIChSKVxuICAweDgxOiAweGIwLFxuICAvLyBkZWdyZWUgc2lnblxuICAweDgyOiAweGJkLFxuICAvLyAxLzIgc3ltYm9sXG4gIDB4ODM6IDB4YmYsXG4gIC8vIEludmVydGVkIChvcGVuKSBxdWVzdGlvbiBtYXJrXG4gIDB4ODQ6IDB4MjEyMixcbiAgLy8gVHJhZGVtYXJrIHN5bWJvbCAoVE0pXG4gIDB4ODU6IDB4YTIsXG4gIC8vIENlbnRzIHN5bWJvbFxuICAweDg2OiAweGEzLFxuICAvLyBQb3VuZHMgc3RlcmxpbmdcbiAgMHg4NzogMHgyNjZhLFxuICAvLyBNdXNpYyA4J3RoIG5vdGVcbiAgMHg4ODogMHhlMCxcbiAgLy8gbG93ZXJjYXNlIGEsIGdyYXZlIGFjY2VudFxuICAweDg5OiAweDIwLFxuICAvLyB0cmFuc3BhcmVudCBzcGFjZSAocmVndWxhcilcbiAgMHg4YTogMHhlOCxcbiAgLy8gbG93ZXJjYXNlIGUsIGdyYXZlIGFjY2VudFxuICAweDhiOiAweGUyLFxuICAvLyBsb3dlcmNhc2UgYSwgY2lyY3VtZmxleCBhY2NlbnRcbiAgMHg4YzogMHhlYSxcbiAgLy8gbG93ZXJjYXNlIGUsIGNpcmN1bWZsZXggYWNjZW50XG4gIDB4OGQ6IDB4ZWUsXG4gIC8vIGxvd2VyY2FzZSBpLCBjaXJjdW1mbGV4IGFjY2VudFxuICAweDhlOiAweGY0LFxuICAvLyBsb3dlcmNhc2UgbywgY2lyY3VtZmxleCBhY2NlbnRcbiAgMHg4ZjogMHhmYixcbiAgLy8gbG93ZXJjYXNlIHUsIGNpcmN1bWZsZXggYWNjZW50XG4gIC8vIFRISVMgQkxPQ0sgSU5DTFVERVMgVEhFIDMyIEVYVEVOREVEIChUV08tQllURSkgTElORSAyMSBDSEFSQUNURVJTXG4gIC8vIFRIQVQgQ09NRSBGUk9NIEhJIEJZVEU9MHgxMiBBTkQgTE9XIEJFVFdFRU4gMHgyMCBBTkQgMHgzRlxuICAweDkwOiAweGMxLFxuICAvLyBjYXBpdGFsIGxldHRlciBBIHdpdGggYWN1dGVcbiAgMHg5MTogMHhjOSxcbiAgLy8gY2FwaXRhbCBsZXR0ZXIgRSB3aXRoIGFjdXRlXG4gIDB4OTI6IDB4ZDMsXG4gIC8vIGNhcGl0YWwgbGV0dGVyIE8gd2l0aCBhY3V0ZVxuICAweDkzOiAweGRhLFxuICAvLyBjYXBpdGFsIGxldHRlciBVIHdpdGggYWN1dGVcbiAgMHg5NDogMHhkYyxcbiAgLy8gY2FwaXRhbCBsZXR0ZXIgVSB3aXRoIGRpYXJlc2lzXG4gIDB4OTU6IDB4ZmMsXG4gIC8vIGxvd2VyY2FzZSBsZXR0ZXIgVSB3aXRoIGRpYWVyZXNpc1xuICAweDk2OiAweDIwMTgsXG4gIC8vIG9wZW5pbmcgc2luZ2xlIHF1b3RlXG4gIDB4OTc6IDB4YTEsXG4gIC8vIGludmVydGVkIGV4Y2xhbWF0aW9uIG1hcmtcbiAgMHg5ODogMHgyYSxcbiAgLy8gYXN0ZXJpc2tcbiAgMHg5OTogMHgyMDE5LFxuICAvLyBjbG9zaW5nIHNpbmdsZSBxdW90ZVxuICAweDlhOiAweDI1MDEsXG4gIC8vIGJveCBkcmF3aW5ncyBoZWF2eSBob3Jpem9udGFsXG4gIDB4OWI6IDB4YTksXG4gIC8vIGNvcHlyaWdodCBzaWduXG4gIDB4OWM6IDB4MjEyMCxcbiAgLy8gU2VydmljZSBtYXJrXG4gIDB4OWQ6IDB4MjAyMixcbiAgLy8gKHJvdW5kKSBidWxsZXRcbiAgMHg5ZTogMHgyMDFjLFxuICAvLyBMZWZ0IGRvdWJsZSBxdW90YXRpb24gbWFya1xuICAweDlmOiAweDIwMWQsXG4gIC8vIFJpZ2h0IGRvdWJsZSBxdW90YXRpb24gbWFya1xuICAweGEwOiAweGMwLFxuICAvLyB1cHBlcmNhc2UgQSwgZ3JhdmUgYWNjZW50XG4gIDB4YTE6IDB4YzIsXG4gIC8vIHVwcGVyY2FzZSBBLCBjaXJjdW1mbGV4XG4gIDB4YTI6IDB4YzcsXG4gIC8vIHVwcGVyY2FzZSBDIHdpdGggY2VkaWxsYVxuICAweGEzOiAweGM4LFxuICAvLyB1cHBlcmNhc2UgRSwgZ3JhdmUgYWNjZW50XG4gIDB4YTQ6IDB4Y2EsXG4gIC8vIHVwcGVyY2FzZSBFLCBjaXJjdW1mbGV4XG4gIDB4YTU6IDB4Y2IsXG4gIC8vIGNhcGl0YWwgbGV0dGVyIEUgd2l0aCBkaWFyZXNpc1xuICAweGE2OiAweGViLFxuICAvLyBsb3dlcmNhc2UgbGV0dGVyIGUgd2l0aCBkaWFyZXNpc1xuICAweGE3OiAweGNlLFxuICAvLyB1cHBlcmNhc2UgSSwgY2lyY3VtZmxleFxuICAweGE4OiAweGNmLFxuICAvLyB1cHBlcmNhc2UgSSwgd2l0aCBkaWFyZXNpc1xuICAweGE5OiAweGVmLFxuICAvLyBsb3dlcmNhc2UgaSwgd2l0aCBkaWFyZXNpc1xuICAweGFhOiAweGQ0LFxuICAvLyB1cHBlcmNhc2UgTywgY2lyY3VtZmxleFxuICAweGFiOiAweGQ5LFxuICAvLyB1cHBlcmNhc2UgVSwgZ3JhdmUgYWNjZW50XG4gIDB4YWM6IDB4ZjksXG4gIC8vIGxvd2VyY2FzZSB1LCBncmF2ZSBhY2NlbnRcbiAgMHhhZDogMHhkYixcbiAgLy8gdXBwZXJjYXNlIFUsIGNpcmN1bWZsZXhcbiAgMHhhZTogMHhhYixcbiAgLy8gbGVmdC1wb2ludGluZyBkb3VibGUgYW5nbGUgcXVvdGF0aW9uIG1hcmtcbiAgMHhhZjogMHhiYixcbiAgLy8gcmlnaHQtcG9pbnRpbmcgZG91YmxlIGFuZ2xlIHF1b3RhdGlvbiBtYXJrXG4gIC8vIFRISVMgQkxPQ0sgSU5DTFVERVMgVEhFIDMyIEVYVEVOREVEIChUV08tQllURSkgTElORSAyMSBDSEFSQUNURVJTXG4gIC8vIFRIQVQgQ09NRSBGUk9NIEhJIEJZVEU9MHgxMyBBTkQgTE9XIEJFVFdFRU4gMHgyMCBBTkQgMHgzRlxuICAweGIwOiAweGMzLFxuICAvLyBVcHBlcmNhc2UgQSwgdGlsZGVcbiAgMHhiMTogMHhlMyxcbiAgLy8gTG93ZXJjYXNlIGEsIHRpbGRlXG4gIDB4YjI6IDB4Y2QsXG4gIC8vIFVwcGVyY2FzZSBJLCBhY3V0ZSBhY2NlbnRcbiAgMHhiMzogMHhjYyxcbiAgLy8gVXBwZXJjYXNlIEksIGdyYXZlIGFjY2VudFxuICAweGI0OiAweGVjLFxuICAvLyBMb3dlcmNhc2UgaSwgZ3JhdmUgYWNjZW50XG4gIDB4YjU6IDB4ZDIsXG4gIC8vIFVwcGVyY2FzZSBPLCBncmF2ZSBhY2NlbnRcbiAgMHhiNjogMHhmMixcbiAgLy8gTG93ZXJjYXNlIG8sIGdyYXZlIGFjY2VudFxuICAweGI3OiAweGQ1LFxuICAvLyBVcHBlcmNhc2UgTywgdGlsZGVcbiAgMHhiODogMHhmNSxcbiAgLy8gTG93ZXJjYXNlIG8sIHRpbGRlXG4gIDB4Yjk6IDB4N2IsXG4gIC8vIE9wZW4gY3VybHkgYnJhY2VcbiAgMHhiYTogMHg3ZCxcbiAgLy8gQ2xvc2luZyBjdXJseSBicmFjZVxuICAweGJiOiAweDVjLFxuICAvLyBCYWNrc2xhc2hcbiAgMHhiYzogMHg1ZSxcbiAgLy8gQ2FyZXRcbiAgMHhiZDogMHg1ZixcbiAgLy8gVW5kZXJzY29yZVxuICAweGJlOiAweDdjLFxuICAvLyBQaXBlICh2ZXJ0aWNhbCBsaW5lKVxuICAweGJmOiAweDIyM2MsXG4gIC8vIFRpbGRlIG9wZXJhdG9yXG4gIDB4YzA6IDB4YzQsXG4gIC8vIFVwcGVyY2FzZSBBLCB1bWxhdXRcbiAgMHhjMTogMHhlNCxcbiAgLy8gTG93ZXJjYXNlIEEsIHVtbGF1dFxuICAweGMyOiAweGQ2LFxuICAvLyBVcHBlcmNhc2UgTywgdW1sYXV0XG4gIDB4YzM6IDB4ZjYsXG4gIC8vIExvd2VyY2FzZSBvLCB1bWxhdXRcbiAgMHhjNDogMHhkZixcbiAgLy8gRXNzemV0dCAoc2hhcnAgUylcbiAgMHhjNTogMHhhNSxcbiAgLy8gWWVuIHN5bWJvbFxuICAweGM2OiAweGE0LFxuICAvLyBHZW5lcmljIGN1cnJlbmN5IHNpZ25cbiAgMHhjNzogMHgyNTAzLFxuICAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgdmVydGljYWxcbiAgMHhjODogMHhjNSxcbiAgLy8gVXBwZXJjYXNlIEEsIHJpbmdcbiAgMHhjOTogMHhlNSxcbiAgLy8gTG93ZXJjYXNlIEEsIHJpbmdcbiAgMHhjYTogMHhkOCxcbiAgLy8gVXBwZXJjYXNlIE8sIHN0cm9rZVxuICAweGNiOiAweGY4LFxuICAvLyBMb3dlcmNhc2Ugbywgc3Ryb2tcbiAgMHhjYzogMHgyNTBmLFxuICAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgZG93biBhbmQgcmlnaHRcbiAgMHhjZDogMHgyNTEzLFxuICAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgZG93biBhbmQgbGVmdFxuICAweGNlOiAweDI1MTcsXG4gIC8vIEJveCBkcmF3aW5ncyBoZWF2eSB1cCBhbmQgcmlnaHRcbiAgMHhjZjogMHgyNTFiIC8vIEJveCBkcmF3aW5ncyBoZWF2eSB1cCBhbmQgbGVmdFxufTtcblxuLyoqXG4gKiBVdGlsc1xuICovXG5jb25zdCBnZXRDaGFyRm9yQnl0ZSA9IGJ5dGUgPT4gU3RyaW5nLmZyb21DaGFyQ29kZShzcGVjaWFsQ2VhNjA4Q2hhcnNDb2Rlc1tieXRlXSB8fCBieXRlKTtcbmNvbnN0IE5SX1JPV1MgPSAxNTtcbmNvbnN0IE5SX0NPTFMgPSAxMDA7XG4vLyBUYWJsZXMgdG8gbG9vayB1cCByb3cgZnJvbSBQQUMgZGF0YVxuY29uc3Qgcm93c0xvd0NoMSA9IHtcbiAgMHgxMTogMSxcbiAgMHgxMjogMyxcbiAgMHgxNTogNSxcbiAgMHgxNjogNyxcbiAgMHgxNzogOSxcbiAgMHgxMDogMTEsXG4gIDB4MTM6IDEyLFxuICAweDE0OiAxNFxufTtcbmNvbnN0IHJvd3NIaWdoQ2gxID0ge1xuICAweDExOiAyLFxuICAweDEyOiA0LFxuICAweDE1OiA2LFxuICAweDE2OiA4LFxuICAweDE3OiAxMCxcbiAgMHgxMzogMTMsXG4gIDB4MTQ6IDE1XG59O1xuY29uc3Qgcm93c0xvd0NoMiA9IHtcbiAgMHgxOTogMSxcbiAgMHgxYTogMyxcbiAgMHgxZDogNSxcbiAgMHgxZTogNyxcbiAgMHgxZjogOSxcbiAgMHgxODogMTEsXG4gIDB4MWI6IDEyLFxuICAweDFjOiAxNFxufTtcbmNvbnN0IHJvd3NIaWdoQ2gyID0ge1xuICAweDE5OiAyLFxuICAweDFhOiA0LFxuICAweDFkOiA2LFxuICAweDFlOiA4LFxuICAweDFmOiAxMCxcbiAgMHgxYjogMTMsXG4gIDB4MWM6IDE1XG59O1xuY29uc3QgYmFja2dyb3VuZENvbG9ycyA9IFsnd2hpdGUnLCAnZ3JlZW4nLCAnYmx1ZScsICdjeWFuJywgJ3JlZCcsICd5ZWxsb3cnLCAnbWFnZW50YScsICdibGFjaycsICd0cmFuc3BhcmVudCddO1xuY2xhc3MgQ2FwdGlvbnNMb2dnZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnRpbWUgPSBudWxsO1xuICAgIHRoaXMudmVyYm9zZUxldmVsID0gMDtcbiAgfVxuICBsb2coc2V2ZXJpdHksIG1zZykge1xuICAgIGlmICh0aGlzLnZlcmJvc2VMZXZlbCA+PSBzZXZlcml0eSkge1xuICAgICAgY29uc3QgbSA9IHR5cGVvZiBtc2cgPT09ICdmdW5jdGlvbicgPyBtc2coKSA6IG1zZztcbiAgICAgIGxvZ2dlci5sb2coYCR7dGhpcy50aW1lfSBbJHtzZXZlcml0eX1dICR7bX1gKTtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IG51bUFycmF5VG9IZXhBcnJheSA9IGZ1bmN0aW9uIG51bUFycmF5VG9IZXhBcnJheShudW1BcnJheSkge1xuICBjb25zdCBoZXhBcnJheSA9IFtdO1xuICBmb3IgKGxldCBqID0gMDsgaiA8IG51bUFycmF5Lmxlbmd0aDsgaisrKSB7XG4gICAgaGV4QXJyYXkucHVzaChudW1BcnJheVtqXS50b1N0cmluZygxNikpO1xuICB9XG4gIHJldHVybiBoZXhBcnJheTtcbn07XG5jbGFzcyBQZW5TdGF0ZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZm9yZWdyb3VuZCA9ICd3aGl0ZSc7XG4gICAgdGhpcy51bmRlcmxpbmUgPSBmYWxzZTtcbiAgICB0aGlzLml0YWxpY3MgPSBmYWxzZTtcbiAgICB0aGlzLmJhY2tncm91bmQgPSAnYmxhY2snO1xuICAgIHRoaXMuZmxhc2ggPSBmYWxzZTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLmZvcmVncm91bmQgPSAnd2hpdGUnO1xuICAgIHRoaXMudW5kZXJsaW5lID0gZmFsc2U7XG4gICAgdGhpcy5pdGFsaWNzID0gZmFsc2U7XG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gJ2JsYWNrJztcbiAgICB0aGlzLmZsYXNoID0gZmFsc2U7XG4gIH1cbiAgc2V0U3R5bGVzKHN0eWxlcykge1xuICAgIGNvbnN0IGF0dHJpYnMgPSBbJ2ZvcmVncm91bmQnLCAndW5kZXJsaW5lJywgJ2l0YWxpY3MnLCAnYmFja2dyb3VuZCcsICdmbGFzaCddO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXR0cmlicy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc3R5bGUgPSBhdHRyaWJzW2ldO1xuICAgICAgaWYgKHN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZSkpIHtcbiAgICAgICAgdGhpc1tzdHlsZV0gPSBzdHlsZXNbc3R5bGVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpc0RlZmF1bHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yZWdyb3VuZCA9PT0gJ3doaXRlJyAmJiAhdGhpcy51bmRlcmxpbmUgJiYgIXRoaXMuaXRhbGljcyAmJiB0aGlzLmJhY2tncm91bmQgPT09ICdibGFjaycgJiYgIXRoaXMuZmxhc2g7XG4gIH1cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yZWdyb3VuZCA9PT0gb3RoZXIuZm9yZWdyb3VuZCAmJiB0aGlzLnVuZGVybGluZSA9PT0gb3RoZXIudW5kZXJsaW5lICYmIHRoaXMuaXRhbGljcyA9PT0gb3RoZXIuaXRhbGljcyAmJiB0aGlzLmJhY2tncm91bmQgPT09IG90aGVyLmJhY2tncm91bmQgJiYgdGhpcy5mbGFzaCA9PT0gb3RoZXIuZmxhc2g7XG4gIH1cbiAgY29weShuZXdQZW5TdGF0ZSkge1xuICAgIHRoaXMuZm9yZWdyb3VuZCA9IG5ld1BlblN0YXRlLmZvcmVncm91bmQ7XG4gICAgdGhpcy51bmRlcmxpbmUgPSBuZXdQZW5TdGF0ZS51bmRlcmxpbmU7XG4gICAgdGhpcy5pdGFsaWNzID0gbmV3UGVuU3RhdGUuaXRhbGljcztcbiAgICB0aGlzLmJhY2tncm91bmQgPSBuZXdQZW5TdGF0ZS5iYWNrZ3JvdW5kO1xuICAgIHRoaXMuZmxhc2ggPSBuZXdQZW5TdGF0ZS5mbGFzaDtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ2NvbG9yPScgKyB0aGlzLmZvcmVncm91bmQgKyAnLCB1bmRlcmxpbmU9JyArIHRoaXMudW5kZXJsaW5lICsgJywgaXRhbGljcz0nICsgdGhpcy5pdGFsaWNzICsgJywgYmFja2dyb3VuZD0nICsgdGhpcy5iYWNrZ3JvdW5kICsgJywgZmxhc2g9JyArIHRoaXMuZmxhc2g7XG4gIH1cbn1cblxuLyoqXG4gKiBVbmljb2RlIGNoYXJhY3RlciB3aXRoIHN0eWxpbmcgYW5kIGJhY2tncm91bmQuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgU3R5bGVkVW5pY29kZUNoYXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnVjaGFyID0gJyAnO1xuICAgIHRoaXMucGVuU3RhdGUgPSBuZXcgUGVuU3RhdGUoKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLnVjaGFyID0gJyAnO1xuICAgIHRoaXMucGVuU3RhdGUucmVzZXQoKTtcbiAgfVxuICBzZXRDaGFyKHVjaGFyLCBuZXdQZW5TdGF0ZSkge1xuICAgIHRoaXMudWNoYXIgPSB1Y2hhcjtcbiAgICB0aGlzLnBlblN0YXRlLmNvcHkobmV3UGVuU3RhdGUpO1xuICB9XG4gIHNldFBlblN0YXRlKG5ld1BlblN0YXRlKSB7XG4gICAgdGhpcy5wZW5TdGF0ZS5jb3B5KG5ld1BlblN0YXRlKTtcbiAgfVxuICBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy51Y2hhciA9PT0gb3RoZXIudWNoYXIgJiYgdGhpcy5wZW5TdGF0ZS5lcXVhbHMob3RoZXIucGVuU3RhdGUpO1xuICB9XG4gIGNvcHkobmV3Q2hhcikge1xuICAgIHRoaXMudWNoYXIgPSBuZXdDaGFyLnVjaGFyO1xuICAgIHRoaXMucGVuU3RhdGUuY29weShuZXdDaGFyLnBlblN0YXRlKTtcbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLnVjaGFyID09PSAnICcgJiYgdGhpcy5wZW5TdGF0ZS5pc0RlZmF1bHQoKTtcbiAgfVxufVxuXG4vKipcbiAqIENFQS02MDggcm93IGNvbnNpc3Rpbmcgb2YgTlJfQ09MUyBpbnN0YW5jZXMgb2YgU3R5bGVkVW5pY29kZUNoYXIuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgUm93IHtcbiAgY29uc3RydWN0b3IobG9nZ2VyKSB7XG4gICAgdGhpcy5jaGFycyA9IFtdO1xuICAgIHRoaXMucG9zID0gMDtcbiAgICB0aGlzLmN1cnJQZW5TdGF0ZSA9IG5ldyBQZW5TdGF0ZSgpO1xuICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gbnVsbDtcbiAgICB0aGlzLmxvZ2dlciA9IHZvaWQgMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgdGhpcy5jaGFycy5wdXNoKG5ldyBTdHlsZWRVbmljb2RlQ2hhcigpKTtcbiAgICB9XG4gICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gIH1cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9DT0xTOyBpKyspIHtcbiAgICAgIGlmICghdGhpcy5jaGFyc1tpXS5lcXVhbHMob3RoZXIuY2hhcnNbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29weShvdGhlcikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfQ09MUzsgaSsrKSB7XG4gICAgICB0aGlzLmNoYXJzW2ldLmNvcHkob3RoZXIuY2hhcnNbaV0pO1xuICAgIH1cbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIGxldCBlbXB0eSA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9DT0xTOyBpKyspIHtcbiAgICAgIGlmICghdGhpcy5jaGFyc1tpXS5pc0VtcHR5KCkpIHtcbiAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbXB0eTtcbiAgfVxuXG4gIC8qKlxuICAgKiAgU2V0IHRoZSBjdXJzb3IgdG8gYSB2YWxpZCBjb2x1bW4uXG4gICAqL1xuICBzZXRDdXJzb3IoYWJzUG9zKSB7XG4gICAgaWYgKHRoaXMucG9zICE9PSBhYnNQb3MpIHtcbiAgICAgIHRoaXMucG9zID0gYWJzUG9zO1xuICAgIH1cbiAgICBpZiAodGhpcy5wb3MgPCAwKSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coMywgJ05lZ2F0aXZlIGN1cnNvciBwb3NpdGlvbiAnICsgdGhpcy5wb3MpO1xuICAgICAgdGhpcy5wb3MgPSAwO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wb3MgPiBOUl9DT0xTKSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coMywgJ1RvbyBsYXJnZSBjdXJzb3IgcG9zaXRpb24gJyArIHRoaXMucG9zKTtcbiAgICAgIHRoaXMucG9zID0gTlJfQ09MUztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTW92ZSB0aGUgY3Vyc29yIHJlbGF0aXZlIHRvIGN1cnJlbnQgcG9zaXRpb24uXG4gICAqL1xuICBtb3ZlQ3Vyc29yKHJlbFBvcykge1xuICAgIGNvbnN0IG5ld1BvcyA9IHRoaXMucG9zICsgcmVsUG9zO1xuICAgIGlmIChyZWxQb3MgPiAxKSB7XG4gICAgICBmb3IgKGxldCBpID0gdGhpcy5wb3MgKyAxOyBpIDwgbmV3UG9zICsgMTsgaSsrKSB7XG4gICAgICAgIHRoaXMuY2hhcnNbaV0uc2V0UGVuU3RhdGUodGhpcy5jdXJyUGVuU3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNldEN1cnNvcihuZXdQb3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJhY2tzcGFjZSwgbW92ZSBvbmUgc3RlcCBiYWNrIGFuZCBjbGVhciBjaGFyYWN0ZXIuXG4gICAqL1xuICBiYWNrU3BhY2UoKSB7XG4gICAgdGhpcy5tb3ZlQ3Vyc29yKC0xKTtcbiAgICB0aGlzLmNoYXJzW3RoaXMucG9zXS5zZXRDaGFyKCcgJywgdGhpcy5jdXJyUGVuU3RhdGUpO1xuICB9XG4gIGluc2VydENoYXIoYnl0ZSkge1xuICAgIGlmIChieXRlID49IDB4OTApIHtcbiAgICAgIC8vIEV4dGVuZGVkIGNoYXJcbiAgICAgIHRoaXMuYmFja1NwYWNlKCk7XG4gICAgfVxuICAgIGNvbnN0IGNoYXIgPSBnZXRDaGFyRm9yQnl0ZShieXRlKTtcbiAgICBpZiAodGhpcy5wb3MgPj0gTlJfQ09MUykge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKDAsICgpID0+ICdDYW5ub3QgaW5zZXJ0ICcgKyBieXRlLnRvU3RyaW5nKDE2KSArICcgKCcgKyBjaGFyICsgJykgYXQgcG9zaXRpb24gJyArIHRoaXMucG9zICsgJy4gU2tpcHBpbmcgaXQhJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY2hhcnNbdGhpcy5wb3NdLnNldENoYXIoY2hhciwgdGhpcy5jdXJyUGVuU3RhdGUpO1xuICAgIHRoaXMubW92ZUN1cnNvcigxKTtcbiAgfVxuICBjbGVhckZyb21Qb3Moc3RhcnRQb3MpIHtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSBzdGFydFBvczsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgdGhpcy5jaGFyc1tpXS5yZXNldCgpO1xuICAgIH1cbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLmNsZWFyRnJvbVBvcygwKTtcbiAgICB0aGlzLnBvcyA9IDA7XG4gICAgdGhpcy5jdXJyUGVuU3RhdGUucmVzZXQoKTtcbiAgfVxuICBjbGVhclRvRW5kT2ZSb3coKSB7XG4gICAgdGhpcy5jbGVhckZyb21Qb3ModGhpcy5wb3MpO1xuICB9XG4gIGdldFRleHRTdHJpbmcoKSB7XG4gICAgY29uc3QgY2hhcnMgPSBbXTtcbiAgICBsZXQgZW1wdHkgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfQ09MUzsgaSsrKSB7XG4gICAgICBjb25zdCBjaGFyID0gdGhpcy5jaGFyc1tpXS51Y2hhcjtcbiAgICAgIGlmIChjaGFyICE9PSAnICcpIHtcbiAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNoYXJzLnB1c2goY2hhcik7XG4gICAgfVxuICAgIGlmIChlbXB0eSkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY2hhcnMuam9pbignJyk7XG4gICAgfVxuICB9XG4gIHNldFBlblN0eWxlcyhzdHlsZXMpIHtcbiAgICB0aGlzLmN1cnJQZW5TdGF0ZS5zZXRTdHlsZXMoc3R5bGVzKTtcbiAgICBjb25zdCBjdXJyQ2hhciA9IHRoaXMuY2hhcnNbdGhpcy5wb3NdO1xuICAgIGN1cnJDaGFyLnNldFBlblN0YXRlKHRoaXMuY3VyclBlblN0YXRlKTtcbiAgfVxufVxuXG4vKipcbiAqIEtlZXAgYSBDRUEtNjA4IHNjcmVlbiBvZiAzMngxNSBzdHlsZWQgY2hhcmFjdGVyc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIENhcHRpb25TY3JlZW4ge1xuICBjb25zdHJ1Y3Rvcihsb2dnZXIpIHtcbiAgICB0aGlzLnJvd3MgPSBbXTtcbiAgICB0aGlzLmN1cnJSb3cgPSBOUl9ST1dTIC0gMTtcbiAgICB0aGlzLm5yUm9sbFVwUm93cyA9IG51bGw7XG4gICAgdGhpcy5sYXN0T3V0cHV0U2NyZWVuID0gbnVsbDtcbiAgICB0aGlzLmxvZ2dlciA9IHZvaWQgMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgdGhpcy5yb3dzLnB1c2gobmV3IFJvdyhsb2dnZXIpKTtcbiAgICB9XG4gICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgIHRoaXMucm93c1tpXS5jbGVhcigpO1xuICAgIH1cbiAgICB0aGlzLmN1cnJSb3cgPSBOUl9ST1dTIC0gMTtcbiAgfVxuICBlcXVhbHMob3RoZXIpIHtcbiAgICBsZXQgZXF1YWwgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICBpZiAoIXRoaXMucm93c1tpXS5lcXVhbHMob3RoZXIucm93c1tpXSkpIHtcbiAgICAgICAgZXF1YWwgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlcXVhbDtcbiAgfVxuICBjb3B5KG90aGVyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgIHRoaXMucm93c1tpXS5jb3B5KG90aGVyLnJvd3NbaV0pO1xuICAgIH1cbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIGxldCBlbXB0eSA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgIGlmICghdGhpcy5yb3dzW2ldLmlzRW1wdHkoKSkge1xuICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVtcHR5O1xuICB9XG4gIGJhY2tTcGFjZSgpIHtcbiAgICBjb25zdCByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICByb3cuYmFja1NwYWNlKCk7XG4gIH1cbiAgY2xlYXJUb0VuZE9mUm93KCkge1xuICAgIGNvbnN0IHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgIHJvdy5jbGVhclRvRW5kT2ZSb3coKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnQgYSBjaGFyYWN0ZXIgKHdpdGhvdXQgc3R5bGluZykgaW4gdGhlIGN1cnJlbnQgcm93LlxuICAgKi9cbiAgaW5zZXJ0Q2hhcihjaGFyKSB7XG4gICAgY29uc3Qgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgcm93Lmluc2VydENoYXIoY2hhcik7XG4gIH1cbiAgc2V0UGVuKHN0eWxlcykge1xuICAgIGNvbnN0IHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgIHJvdy5zZXRQZW5TdHlsZXMoc3R5bGVzKTtcbiAgfVxuICBtb3ZlQ3Vyc29yKHJlbFBvcykge1xuICAgIGNvbnN0IHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgIHJvdy5tb3ZlQ3Vyc29yKHJlbFBvcyk7XG4gIH1cbiAgc2V0Q3Vyc29yKGFic1Bvcykge1xuICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnc2V0Q3Vyc29yOiAnICsgYWJzUG9zKTtcbiAgICBjb25zdCByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICByb3cuc2V0Q3Vyc29yKGFic1Bvcyk7XG4gIH1cbiAgc2V0UEFDKHBhY0RhdGEpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgKCkgPT4gJ3BhY0RhdGEgPSAnICsgc3RyaW5naWZ5KHBhY0RhdGEpKTtcbiAgICBsZXQgbmV3Um93ID0gcGFjRGF0YS5yb3cgLSAxO1xuICAgIGlmICh0aGlzLm5yUm9sbFVwUm93cyAmJiBuZXdSb3cgPCB0aGlzLm5yUm9sbFVwUm93cyAtIDEpIHtcbiAgICAgIG5ld1JvdyA9IHRoaXMubnJSb2xsVXBSb3dzIC0gMTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhpcyBvbmx5IGFmZmVjdHMgUm9sbC11cCBDYXB0aW9ucyBieSBjaGVja2luZyB0aGlzLm5yUm9sbFVwUm93c1xuICAgIGlmICh0aGlzLm5yUm9sbFVwUm93cyAmJiB0aGlzLmN1cnJSb3cgIT09IG5ld1Jvdykge1xuICAgICAgLy8gY2xlYXIgYWxsIHJvd3MgZmlyc3RcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICAgIHRoaXMucm93c1tpXS5jbGVhcigpO1xuICAgICAgfVxuXG4gICAgICAvLyBDb3B5IHRoaXMubnJSb2xsVXBSb3dzIHJvd3MgZnJvbSBsYXN0T3V0cHV0U2NyZWVuIGFuZCBwbGFjZSBpdCBpbiB0aGUgbmV3Um93IGxvY2F0aW9uXG4gICAgICAvLyB0b3BSb3dJbmRleCAtIHRoZSBzdGFydCBvZiByb3dzIHRvIGNvcHkgKGluY2x1c2l2ZSBpbmRleClcbiAgICAgIGNvbnN0IHRvcFJvd0luZGV4ID0gdGhpcy5jdXJyUm93ICsgMSAtIHRoaXMubnJSb2xsVXBSb3dzO1xuICAgICAgLy8gV2Ugb25seSBjb3B5IGlmIHRoZSBsYXN0IHBvc2l0aW9uIHdhcyBhbHJlYWR5IHNob3duLlxuICAgICAgLy8gV2UgdXNlIHRoZSBjdWVTdGFydFRpbWUgdmFsdWUgdG8gY2hlY2sgdGhpcy5cbiAgICAgIGNvbnN0IGxhc3RPdXRwdXRTY3JlZW4gPSB0aGlzLmxhc3RPdXRwdXRTY3JlZW47XG4gICAgICBpZiAobGFzdE91dHB1dFNjcmVlbikge1xuICAgICAgICBjb25zdCBwcmV2TGluZVRpbWUgPSBsYXN0T3V0cHV0U2NyZWVuLnJvd3NbdG9wUm93SW5kZXhdLmN1ZVN0YXJ0VGltZTtcbiAgICAgICAgY29uc3QgdGltZSA9IHRoaXMubG9nZ2VyLnRpbWU7XG4gICAgICAgIGlmIChwcmV2TGluZVRpbWUgIT09IG51bGwgJiYgdGltZSAhPT0gbnVsbCAmJiBwcmV2TGluZVRpbWUgPCB0aW1lKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm5yUm9sbFVwUm93czsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnJvd3NbbmV3Um93IC0gdGhpcy5uclJvbGxVcFJvd3MgKyBpICsgMV0uY29weShsYXN0T3V0cHV0U2NyZWVuLnJvd3NbdG9wUm93SW5kZXggKyBpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY3VyclJvdyA9IG5ld1JvdztcbiAgICBjb25zdCByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICBpZiAocGFjRGF0YS5pbmRlbnQgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGluZGVudCA9IHBhY0RhdGEuaW5kZW50O1xuICAgICAgY29uc3QgcHJldlBvcyA9IE1hdGgubWF4KGluZGVudCAtIDEsIDApO1xuICAgICAgcm93LnNldEN1cnNvcihwYWNEYXRhLmluZGVudCk7XG4gICAgICBwYWNEYXRhLmNvbG9yID0gcm93LmNoYXJzW3ByZXZQb3NdLnBlblN0YXRlLmZvcmVncm91bmQ7XG4gICAgfVxuICAgIGNvbnN0IHN0eWxlcyA9IHtcbiAgICAgIGZvcmVncm91bmQ6IHBhY0RhdGEuY29sb3IsXG4gICAgICB1bmRlcmxpbmU6IHBhY0RhdGEudW5kZXJsaW5lLFxuICAgICAgaXRhbGljczogcGFjRGF0YS5pdGFsaWNzLFxuICAgICAgYmFja2dyb3VuZDogJ2JsYWNrJyxcbiAgICAgIGZsYXNoOiBmYWxzZVxuICAgIH07XG4gICAgdGhpcy5zZXRQZW4oc3R5bGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYmFja2dyb3VuZC9leHRyYSBmb3JlZ3JvdW5kLCBidXQgZmlyc3QgZG8gYmFja19zcGFjZSwgYW5kIHRoZW4gaW5zZXJ0IHNwYWNlIChiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSkuXG4gICAqL1xuICBzZXRCa2dEYXRhKGJrZ0RhdGEpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgKCkgPT4gJ2JrZ0RhdGEgPSAnICsgc3RyaW5naWZ5KGJrZ0RhdGEpKTtcbiAgICB0aGlzLmJhY2tTcGFjZSgpO1xuICAgIHRoaXMuc2V0UGVuKGJrZ0RhdGEpO1xuICAgIHRoaXMuaW5zZXJ0Q2hhcigweDIwKTsgLy8gU3BhY2VcbiAgfVxuICBzZXRSb2xsVXBSb3dzKG5yUm93cykge1xuICAgIHRoaXMubnJSb2xsVXBSb3dzID0gbnJSb3dzO1xuICB9XG4gIHJvbGxVcCgpIHtcbiAgICBpZiAodGhpcy5uclJvbGxVcFJvd3MgPT09IG51bGwpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygzLCAncm9sbF91cCBidXQgbnJSb2xsVXBSb3dzIG5vdCBzZXQgeWV0Jyk7XG4gICAgICByZXR1cm47IC8vIE5vdCBwcm9wZXJseSBzZXR1cFxuICAgIH1cbiAgICB0aGlzLmxvZ2dlci5sb2coMSwgKCkgPT4gdGhpcy5nZXREaXNwbGF5VGV4dCgpKTtcbiAgICBjb25zdCB0b3BSb3dJbmRleCA9IHRoaXMuY3VyclJvdyArIDEgLSB0aGlzLm5yUm9sbFVwUm93cztcbiAgICBjb25zdCB0b3BSb3cgPSB0aGlzLnJvd3Muc3BsaWNlKHRvcFJvd0luZGV4LCAxKVswXTtcbiAgICB0b3BSb3cuY2xlYXIoKTtcbiAgICB0aGlzLnJvd3Muc3BsaWNlKHRoaXMuY3VyclJvdywgMCwgdG9wUm93KTtcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ1JvbGxpbmcgdXAnKTtcbiAgICAvLyB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLlRFWFQsIHRoaXMuZ2V0X2Rpc3BsYXlfdGV4dCgpKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgbm9uLWVtcHR5IHJvd3Mgd2l0aCBhcyB1bmljb2RlIHRleHQuXG4gICAqL1xuICBnZXREaXNwbGF5VGV4dChhc09uZVJvdykge1xuICAgIGFzT25lUm93ID0gYXNPbmVSb3cgfHwgZmFsc2U7XG4gICAgY29uc3QgZGlzcGxheVRleHQgPSBbXTtcbiAgICBsZXQgdGV4dCA9ICcnO1xuICAgIGxldCByb3dOciA9IC0xO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICBjb25zdCByb3dUZXh0ID0gdGhpcy5yb3dzW2ldLmdldFRleHRTdHJpbmcoKTtcbiAgICAgIGlmIChyb3dUZXh0KSB7XG4gICAgICAgIHJvd05yID0gaSArIDE7XG4gICAgICAgIGlmIChhc09uZVJvdykge1xuICAgICAgICAgIGRpc3BsYXlUZXh0LnB1c2goJ1JvdyAnICsgcm93TnIgKyBcIjogJ1wiICsgcm93VGV4dCArIFwiJ1wiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkaXNwbGF5VGV4dC5wdXNoKHJvd1RleHQudHJpbSgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGlzcGxheVRleHQubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKGFzT25lUm93KSB7XG4gICAgICAgIHRleHQgPSAnWycgKyBkaXNwbGF5VGV4dC5qb2luKCcgfCAnKSArICddJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQgPSBkaXNwbGF5VGV4dC5qb2luKCdcXG4nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cbiAgZ2V0VGV4dEFuZEZvcm1hdCgpIHtcbiAgICByZXR1cm4gdGhpcy5yb3dzO1xuICB9XG59XG5cbi8vIHZhciBtb2RlcyA9IFsnTU9ERV9ST0xMLVVQJywgJ01PREVfUE9QLU9OJywgJ01PREVfUEFJTlQtT04nLCAnTU9ERV9URVhUJ107XG5cbmNsYXNzIENlYTYwOENoYW5uZWwge1xuICBjb25zdHJ1Y3RvcihjaGFubmVsTnVtYmVyLCBvdXRwdXRGaWx0ZXIsIGxvZ2dlcikge1xuICAgIHRoaXMuY2hOciA9IHZvaWQgMDtcbiAgICB0aGlzLm91dHB1dEZpbHRlciA9IHZvaWQgMDtcbiAgICB0aGlzLm1vZGUgPSB2b2lkIDA7XG4gICAgdGhpcy52ZXJib3NlID0gdm9pZCAwO1xuICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5ID0gdm9pZCAwO1xuICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5ID0gdm9pZCAwO1xuICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbiA9IHZvaWQgMDtcbiAgICB0aGlzLmN1cnJSb2xsVXBSb3cgPSB2b2lkIDA7XG4gICAgdGhpcy53cml0ZVNjcmVlbiA9IHZvaWQgMDtcbiAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IHZvaWQgMDtcbiAgICB0aGlzLmxvZ2dlciA9IHZvaWQgMDtcbiAgICB0aGlzLmNoTnIgPSBjaGFubmVsTnVtYmVyO1xuICAgIHRoaXMub3V0cHV0RmlsdGVyID0gb3V0cHV0RmlsdGVyO1xuICAgIHRoaXMubW9kZSA9IG51bGw7XG4gICAgdGhpcy52ZXJib3NlID0gMDtcbiAgICB0aGlzLmRpc3BsYXllZE1lbW9yeSA9IG5ldyBDYXB0aW9uU2NyZWVuKGxvZ2dlcik7XG4gICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkgPSBuZXcgQ2FwdGlvblNjcmVlbihsb2dnZXIpO1xuICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbiA9IG5ldyBDYXB0aW9uU2NyZWVuKGxvZ2dlcik7XG4gICAgdGhpcy5jdXJyUm9sbFVwUm93ID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkucm93c1tOUl9ST1dTIC0gMV07XG4gICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgIHRoaXMubW9kZSA9IG51bGw7XG4gICAgdGhpcy5jdWVTdGFydFRpbWUgPSBudWxsOyAvLyBLZWVwcyB0cmFjayBvZiB3aGVyZSBhIGN1ZSBzdGFydGVkLlxuICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMubW9kZSA9IG51bGw7XG4gICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkucmVzZXQoKTtcbiAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbi5yZXNldCgpO1xuICAgIHRoaXMub3V0cHV0RmlsdGVyLnJlc2V0KCk7XG4gICAgdGhpcy5jdXJyUm9sbFVwUm93ID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkucm93c1tOUl9ST1dTIC0gMV07XG4gICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgIHRoaXMubW9kZSA9IG51bGw7XG4gICAgdGhpcy5jdWVTdGFydFRpbWUgPSBudWxsO1xuICB9XG4gIGdldEhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0RmlsdGVyO1xuICB9XG4gIHNldEhhbmRsZXIobmV3SGFuZGxlcikge1xuICAgIHRoaXMub3V0cHV0RmlsdGVyID0gbmV3SGFuZGxlcjtcbiAgfVxuICBzZXRQQUMocGFjRGF0YSkge1xuICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0UEFDKHBhY0RhdGEpO1xuICB9XG4gIHNldEJrZ0RhdGEoYmtnRGF0YSkge1xuICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0QmtnRGF0YShia2dEYXRhKTtcbiAgfVxuICBzZXRNb2RlKG5ld01vZGUpIHtcbiAgICBpZiAobmV3TW9kZSA9PT0gdGhpcy5tb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubW9kZSA9IG5ld01vZGU7XG4gICAgdGhpcy5sb2dnZXIubG9nKDIsICgpID0+ICdNT0RFPScgKyBuZXdNb2RlKTtcbiAgICBpZiAodGhpcy5tb2RlID09PSAnTU9ERV9QT1AtT04nKSB7XG4gICAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICAgIHRoaXMud3JpdGVTY3JlZW4ucmVzZXQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubW9kZSAhPT0gJ01PREVfUk9MTC1VUCcpIHtcbiAgICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5Lm5yUm9sbFVwUm93cyA9IG51bGw7XG4gICAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeS5uclJvbGxVcFJvd3MgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLm1vZGUgPSBuZXdNb2RlO1xuICB9XG4gIGluc2VydENoYXJzKGNoYXJzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53cml0ZVNjcmVlbi5pbnNlcnRDaGFyKGNoYXJzW2ldKTtcbiAgICB9XG4gICAgY29uc3Qgc2NyZWVuID0gdGhpcy53cml0ZVNjcmVlbiA9PT0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkgPyAnRElTUCcgOiAnTk9OX0RJU1AnO1xuICAgIHRoaXMubG9nZ2VyLmxvZygyLCAoKSA9PiBzY3JlZW4gKyAnOiAnICsgdGhpcy53cml0ZVNjcmVlbi5nZXREaXNwbGF5VGV4dCh0cnVlKSk7XG4gICAgaWYgKHRoaXMubW9kZSA9PT0gJ01PREVfUEFJTlQtT04nIHx8IHRoaXMubW9kZSA9PT0gJ01PREVfUk9MTC1VUCcpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygxLCAoKSA9PiAnRElTUExBWUVEOiAnICsgdGhpcy5kaXNwbGF5ZWRNZW1vcnkuZ2V0RGlzcGxheVRleHQodHJ1ZSkpO1xuICAgICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XG4gICAgfVxuICB9XG4gIGNjUkNMKCkge1xuICAgIC8vIFJlc3VtZSBDYXB0aW9uIExvYWRpbmcgKHN3aXRjaCBtb2RlIHRvIFBvcCBPbilcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ1JDTCAtIFJlc3VtZSBDYXB0aW9uIExvYWRpbmcnKTtcbiAgICB0aGlzLnNldE1vZGUoJ01PREVfUE9QLU9OJyk7XG4gIH1cbiAgY2NCUygpIHtcbiAgICAvLyBCYWNrU3BhY2VcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ0JTIC0gQmFja1NwYWNlJyk7XG4gICAgaWYgKHRoaXMubW9kZSA9PT0gJ01PREVfVEVYVCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy53cml0ZVNjcmVlbi5iYWNrU3BhY2UoKTtcbiAgICBpZiAodGhpcy53cml0ZVNjcmVlbiA9PT0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkpIHtcbiAgICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSgpO1xuICAgIH1cbiAgfVxuICBjY0FPRigpIHtcbiAgICAvLyBSZXNlcnZlZCAoZm9ybWVybHkgQWxhcm0gT2ZmKVxuICB9XG4gIGNjQU9OKCkge1xuICAgIC8vIFJlc2VydmVkIChmb3JtZXJseSBBbGFybSBPbilcbiAgfVxuICBjY0RFUigpIHtcbiAgICAvLyBEZWxldGUgdG8gRW5kIG9mIFJvd1xuICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnREVSLSBEZWxldGUgdG8gRW5kIG9mIFJvdycpO1xuICAgIHRoaXMud3JpdGVTY3JlZW4uY2xlYXJUb0VuZE9mUm93KCk7XG4gICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XG4gIH1cbiAgY2NSVShuclJvd3MpIHtcbiAgICAvLyBSb2xsLVVwIENhcHRpb25zLTIsMyxvciA0IFJvd3NcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ1JVKCcgKyBuclJvd3MgKyAnKSAtIFJvbGwgVXAnKTtcbiAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XG4gICAgdGhpcy5zZXRNb2RlKCdNT0RFX1JPTEwtVVAnKTtcbiAgICB0aGlzLndyaXRlU2NyZWVuLnNldFJvbGxVcFJvd3MobnJSb3dzKTtcbiAgfVxuICBjY0ZPTigpIHtcbiAgICAvLyBGbGFzaCBPblxuICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnRk9OIC0gRmxhc2ggT24nKTtcbiAgICB0aGlzLndyaXRlU2NyZWVuLnNldFBlbih7XG4gICAgICBmbGFzaDogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGNjUkRDKCkge1xuICAgIC8vIFJlc3VtZSBEaXJlY3QgQ2FwdGlvbmluZyAoc3dpdGNoIG1vZGUgdG8gUGFpbnRPbilcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ1JEQyAtIFJlc3VtZSBEaXJlY3QgQ2FwdGlvbmluZycpO1xuICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9QQUlOVC1PTicpO1xuICB9XG4gIGNjVFIoKSB7XG4gICAgLy8gVGV4dCBSZXN0YXJ0IGluIHRleHQgbW9kZSAobm90IHN1cHBvcnRlZCwgaG93ZXZlcilcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ1RSJyk7XG4gICAgdGhpcy5zZXRNb2RlKCdNT0RFX1RFWFQnKTtcbiAgfVxuICBjY1JURCgpIHtcbiAgICAvLyBSZXN1bWUgVGV4dCBEaXNwbGF5IGluIFRleHQgbW9kZSAobm90IHN1cHBvcnRlZCwgaG93ZXZlcilcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ1JURCcpO1xuICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9URVhUJyk7XG4gIH1cbiAgY2NFRE0oKSB7XG4gICAgLy8gRXJhc2UgRGlzcGxheWVkIE1lbW9yeVxuICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnRURNIC0gRXJhc2UgRGlzcGxheWVkIE1lbW9yeScpO1xuICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5LnJlc2V0KCk7XG4gICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKHRydWUpO1xuICB9XG4gIGNjQ1IoKSB7XG4gICAgLy8gQ2FycmlhZ2UgUmV0dXJuXG4gICAgdGhpcy5sb2dnZXIubG9nKDIsICdDUiAtIENhcnJpYWdlIFJldHVybicpO1xuICAgIHRoaXMud3JpdGVTY3JlZW4ucm9sbFVwKCk7XG4gICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKHRydWUpO1xuICB9XG4gIGNjRU5NKCkge1xuICAgIC8vIEVyYXNlIE5vbi1EaXNwbGF5ZWQgTWVtb3J5XG4gICAgdGhpcy5sb2dnZXIubG9nKDIsICdFTk0gLSBFcmFzZSBOb24tZGlzcGxheWVkIE1lbW9yeScpO1xuICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5LnJlc2V0KCk7XG4gIH1cbiAgY2NFT0MoKSB7XG4gICAgLy8gRW5kIG9mIENhcHRpb24gKEZsaXAgTWVtb3JpZXMpXG4gICAgdGhpcy5sb2dnZXIubG9nKDIsICdFT0MgLSBFbmQgT2YgQ2FwdGlvbicpO1xuICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1BPUC1PTicpIHtcbiAgICAgIGNvbnN0IHRtcCA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkgPSB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeTtcbiAgICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5ID0gdG1wO1xuICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMubm9uRGlzcGxheWVkTWVtb3J5O1xuICAgICAgdGhpcy5sb2dnZXIubG9nKDEsICgpID0+ICdESVNQOiAnICsgdGhpcy5kaXNwbGF5ZWRNZW1vcnkuZ2V0RGlzcGxheVRleHQoKSk7XG4gICAgfVxuICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSh0cnVlKTtcbiAgfVxuICBjY1RPKG5yQ29scykge1xuICAgIC8vIFRhYiBPZmZzZXQgMSwyLCBvciAzIGNvbHVtbnNcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ1RPKCcgKyBuckNvbHMgKyAnKSAtIFRhYiBPZmZzZXQnKTtcbiAgICB0aGlzLndyaXRlU2NyZWVuLm1vdmVDdXJzb3IobnJDb2xzKTtcbiAgfVxuICBjY01JRFJPVyhzZWNvbmRCeXRlKSB7XG4gICAgLy8gUGFyc2UgTUlEUk9XIGNvbW1hbmRcbiAgICBjb25zdCBzdHlsZXMgPSB7XG4gICAgICBmbGFzaDogZmFsc2VcbiAgICB9O1xuICAgIHN0eWxlcy51bmRlcmxpbmUgPSBzZWNvbmRCeXRlICUgMiA9PT0gMTtcbiAgICBzdHlsZXMuaXRhbGljcyA9IHNlY29uZEJ5dGUgPj0gMHgyZTtcbiAgICBpZiAoIXN0eWxlcy5pdGFsaWNzKSB7XG4gICAgICBjb25zdCBjb2xvckluZGV4ID0gTWF0aC5mbG9vcihzZWNvbmRCeXRlIC8gMikgLSAweDEwO1xuICAgICAgY29uc3QgY29sb3JzID0gWyd3aGl0ZScsICdncmVlbicsICdibHVlJywgJ2N5YW4nLCAncmVkJywgJ3llbGxvdycsICdtYWdlbnRhJ107XG4gICAgICBzdHlsZXMuZm9yZWdyb3VuZCA9IGNvbG9yc1tjb2xvckluZGV4XTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzLmZvcmVncm91bmQgPSAnd2hpdGUnO1xuICAgIH1cbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ01JRFJPVzogJyArIHN0cmluZ2lmeShzdHlsZXMpKTtcbiAgICB0aGlzLndyaXRlU2NyZWVuLnNldFBlbihzdHlsZXMpO1xuICB9XG4gIG91dHB1dERhdGFVcGRhdGUoZGlzcGF0Y2ggPSBmYWxzZSkge1xuICAgIGNvbnN0IHRpbWUgPSB0aGlzLmxvZ2dlci50aW1lO1xuICAgIGlmICh0aW1lID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLm91dHB1dEZpbHRlcikge1xuICAgICAgaWYgKHRoaXMuY3VlU3RhcnRUaW1lID09PSBudWxsICYmICF0aGlzLmRpc3BsYXllZE1lbW9yeS5pc0VtcHR5KCkpIHtcbiAgICAgICAgLy8gU3RhcnQgb2YgYSBuZXcgY3VlXG4gICAgICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gdGltZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdGhpcy5kaXNwbGF5ZWRNZW1vcnkuZXF1YWxzKHRoaXMubGFzdE91dHB1dFNjcmVlbikpIHtcbiAgICAgICAgICB0aGlzLm91dHB1dEZpbHRlci5uZXdDdWUodGhpcy5jdWVTdGFydFRpbWUsIHRpbWUsIHRoaXMubGFzdE91dHB1dFNjcmVlbik7XG4gICAgICAgICAgaWYgKGRpc3BhdGNoICYmIHRoaXMub3V0cHV0RmlsdGVyLmRpc3BhdGNoQ3VlKSB7XG4gICAgICAgICAgICB0aGlzLm91dHB1dEZpbHRlci5kaXNwYXRjaEN1ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IHRoaXMuZGlzcGxheWVkTWVtb3J5LmlzRW1wdHkoKSA/IG51bGwgOiB0aW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4uY29weSh0aGlzLmRpc3BsYXllZE1lbW9yeSk7XG4gICAgfVxuICB9XG4gIGN1ZVNwbGl0QXRUaW1lKHQpIHtcbiAgICBpZiAodGhpcy5vdXRwdXRGaWx0ZXIpIHtcbiAgICAgIGlmICghdGhpcy5kaXNwbGF5ZWRNZW1vcnkuaXNFbXB0eSgpKSB7XG4gICAgICAgIGlmICh0aGlzLm91dHB1dEZpbHRlci5uZXdDdWUpIHtcbiAgICAgICAgICB0aGlzLm91dHB1dEZpbHRlci5uZXdDdWUodGhpcy5jdWVTdGFydFRpbWUsIHQsIHRoaXMuZGlzcGxheWVkTWVtb3J5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIFdpbGwgYmUgMSBvciAyIHdoZW4gcGFyc2luZyBjYXB0aW9uc1xuXG5jbGFzcyBDZWE2MDhQYXJzZXIge1xuICBjb25zdHJ1Y3RvcihmaWVsZCwgb3V0MSwgb3V0Mikge1xuICAgIHRoaXMuY2hhbm5lbHMgPSB2b2lkIDA7XG4gICAgdGhpcy5jdXJyZW50Q2hhbm5lbCA9IDA7XG4gICAgdGhpcy5jbWRIaXN0b3J5ID0gY3JlYXRlQ21kSGlzdG9yeSgpO1xuICAgIHRoaXMubG9nZ2VyID0gdm9pZCAwO1xuICAgIGNvbnN0IGxvZ2dlciA9IHRoaXMubG9nZ2VyID0gbmV3IENhcHRpb25zTG9nZ2VyKCk7XG4gICAgdGhpcy5jaGFubmVscyA9IFtudWxsLCBuZXcgQ2VhNjA4Q2hhbm5lbChmaWVsZCwgb3V0MSwgbG9nZ2VyKSwgbmV3IENlYTYwOENoYW5uZWwoZmllbGQgKyAxLCBvdXQyLCBsb2dnZXIpXTtcbiAgfVxuICBnZXRIYW5kbGVyKGNoYW5uZWwpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsc1tjaGFubmVsXS5nZXRIYW5kbGVyKCk7XG4gIH1cbiAgc2V0SGFuZGxlcihjaGFubmVsLCBuZXdIYW5kbGVyKSB7XG4gICAgdGhpcy5jaGFubmVsc1tjaGFubmVsXS5zZXRIYW5kbGVyKG5ld0hhbmRsZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBkYXRhIGZvciB0aW1lIHQgaW4gZm9ybXMgb2YgbGlzdCBvZiBieXRlcyAodW5zaWduZWQgaW50cykuIFRoZSBieXRlcyBhcmUgdHJlYXRlZCBhcyBwYWlycy5cbiAgICovXG4gIGFkZERhdGEodGltZSwgYnl0ZUxpc3QpIHtcbiAgICB0aGlzLmxvZ2dlci50aW1lID0gdGltZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVMaXN0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBjb25zdCBhID0gYnl0ZUxpc3RbaV0gJiAweDdmO1xuICAgICAgY29uc3QgYiA9IGJ5dGVMaXN0W2kgKyAxXSAmIDB4N2Y7XG4gICAgICBsZXQgY21kRm91bmQgPSBmYWxzZTtcbiAgICAgIGxldCBjaGFyc0ZvdW5kID0gbnVsbDtcbiAgICAgIGlmIChhID09PSAwICYmIGIgPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coMywgKCkgPT4gJ1snICsgbnVtQXJyYXlUb0hleEFycmF5KFtieXRlTGlzdFtpXSwgYnl0ZUxpc3RbaSArIDFdXSkgKyAnXSAtPiAoJyArIG51bUFycmF5VG9IZXhBcnJheShbYSwgYl0pICsgJyknKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNtZEhpc3RvcnkgPSB0aGlzLmNtZEhpc3Rvcnk7XG4gICAgICBjb25zdCBpc0NvbnRyb2xDb2RlID0gYSA+PSAweDEwICYmIGEgPD0gMHgxZjtcbiAgICAgIGlmIChpc0NvbnRyb2xDb2RlKSB7XG4gICAgICAgIC8vIFNraXAgcmVkdW5kYW50IGNvbnRyb2wgY29kZXNcbiAgICAgICAgaWYgKGhhc0NtZFJlcGVhdGVkKGEsIGIsIGNtZEhpc3RvcnkpKSB7XG4gICAgICAgICAgc2V0TGFzdENtZChudWxsLCBudWxsLCBjbWRIaXN0b3J5KTtcbiAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coMywgKCkgPT4gJ1JlcGVhdGVkIGNvbW1hbmQgKCcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2EsIGJdKSArICcpIGlzIGRyb3BwZWQnKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBzZXRMYXN0Q21kKGEsIGIsIHRoaXMuY21kSGlzdG9yeSk7XG4gICAgICAgIGNtZEZvdW5kID0gdGhpcy5wYXJzZUNtZChhLCBiKTtcbiAgICAgICAgaWYgKCFjbWRGb3VuZCkge1xuICAgICAgICAgIGNtZEZvdW5kID0gdGhpcy5wYXJzZU1pZHJvdyhhLCBiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNtZEZvdW5kKSB7XG4gICAgICAgICAgY21kRm91bmQgPSB0aGlzLnBhcnNlUEFDKGEsIGIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY21kRm91bmQpIHtcbiAgICAgICAgICBjbWRGb3VuZCA9IHRoaXMucGFyc2VCYWNrZ3JvdW5kQXR0cmlidXRlcyhhLCBiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0TGFzdENtZChudWxsLCBudWxsLCBjbWRIaXN0b3J5KTtcbiAgICAgIH1cbiAgICAgIGlmICghY21kRm91bmQpIHtcbiAgICAgICAgY2hhcnNGb3VuZCA9IHRoaXMucGFyc2VDaGFycyhhLCBiKTtcbiAgICAgICAgaWYgKGNoYXJzRm91bmQpIHtcbiAgICAgICAgICBjb25zdCBjdXJyQ2hOciA9IHRoaXMuY3VycmVudENoYW5uZWw7XG4gICAgICAgICAgaWYgKGN1cnJDaE5yICYmIGN1cnJDaE5yID4gMCkge1xuICAgICAgICAgICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY3VyckNoTnJdO1xuICAgICAgICAgICAgY2hhbm5lbC5pbnNlcnRDaGFycyhjaGFyc0ZvdW5kKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKDIsICdObyBjaGFubmVsIGZvdW5kIHlldC4gVEVYVC1NT0RFPycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFjbWRGb3VuZCAmJiAhY2hhcnNGb3VuZCkge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coMiwgKCkgPT4gXCJDb3VsZG4ndCBwYXJzZSBjbGVhbmVkIGRhdGEgXCIgKyBudW1BcnJheVRvSGV4QXJyYXkoW2EsIGJdKSArICcgb3JpZzogJyArIG51bUFycmF5VG9IZXhBcnJheShbYnl0ZUxpc3RbaV0sIGJ5dGVMaXN0W2kgKyAxXV0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgQ29tbWFuZC5cbiAgICogQHJldHVybnMgVHJ1ZSBpZiBhIGNvbW1hbmQgd2FzIGZvdW5kXG4gICAqL1xuICBwYXJzZUNtZChhLCBiKSB7XG4gICAgY29uc3QgY29uZDEgPSAoYSA9PT0gMHgxNCB8fCBhID09PSAweDFjIHx8IGEgPT09IDB4MTUgfHwgYSA9PT0gMHgxZCkgJiYgYiA+PSAweDIwICYmIGIgPD0gMHgyZjtcbiAgICBjb25zdCBjb25kMiA9IChhID09PSAweDE3IHx8IGEgPT09IDB4MWYpICYmIGIgPj0gMHgyMSAmJiBiIDw9IDB4MjM7XG4gICAgaWYgKCEoY29uZDEgfHwgY29uZDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGNoTnIgPSBhID09PSAweDE0IHx8IGEgPT09IDB4MTUgfHwgYSA9PT0gMHgxNyA/IDEgOiAyO1xuICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2NoTnJdO1xuICAgIGlmIChhID09PSAweDE0IHx8IGEgPT09IDB4MTUgfHwgYSA9PT0gMHgxYyB8fCBhID09PSAweDFkKSB7XG4gICAgICBpZiAoYiA9PT0gMHgyMCkge1xuICAgICAgICBjaGFubmVsLmNjUkNMKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjEpIHtcbiAgICAgICAgY2hhbm5lbC5jY0JTKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjIpIHtcbiAgICAgICAgY2hhbm5lbC5jY0FPRigpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDIzKSB7XG4gICAgICAgIGNoYW5uZWwuY2NBT04oKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNCkge1xuICAgICAgICBjaGFubmVsLmNjREVSKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjUpIHtcbiAgICAgICAgY2hhbm5lbC5jY1JVKDIpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDI2KSB7XG4gICAgICAgIGNoYW5uZWwuY2NSVSgzKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNykge1xuICAgICAgICBjaGFubmVsLmNjUlUoNCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjgpIHtcbiAgICAgICAgY2hhbm5lbC5jY0ZPTigpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDI5KSB7XG4gICAgICAgIGNoYW5uZWwuY2NSREMoKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyYSkge1xuICAgICAgICBjaGFubmVsLmNjVFIoKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyYikge1xuICAgICAgICBjaGFubmVsLmNjUlREKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MmMpIHtcbiAgICAgICAgY2hhbm5lbC5jY0VETSgpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDJkKSB7XG4gICAgICAgIGNoYW5uZWwuY2NDUigpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDJlKSB7XG4gICAgICAgIGNoYW5uZWwuY2NFTk0oKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyZikge1xuICAgICAgICBjaGFubmVsLmNjRU9DKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGEgPT0gMHgxNyB8fCBhID09IDB4MUZcbiAgICAgIGNoYW5uZWwuY2NUTyhiIC0gMHgyMCk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudENoYW5uZWwgPSBjaE5yO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIG1pZHJvdyBzdHlsaW5nIGNvbW1hbmRcbiAgICovXG4gIHBhcnNlTWlkcm93KGEsIGIpIHtcbiAgICBsZXQgY2hOciA9IDA7XG4gICAgaWYgKChhID09PSAweDExIHx8IGEgPT09IDB4MTkpICYmIGIgPj0gMHgyMCAmJiBiIDw9IDB4MmYpIHtcbiAgICAgIGlmIChhID09PSAweDExKSB7XG4gICAgICAgIGNoTnIgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hOciA9IDI7XG4gICAgICB9XG4gICAgICBpZiAoY2hOciAhPT0gdGhpcy5jdXJyZW50Q2hhbm5lbCkge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coMCwgJ01pc21hdGNoIGNoYW5uZWwgaW4gbWlkcm93IHBhcnNpbmcnKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY2hOcl07XG4gICAgICBpZiAoIWNoYW5uZWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY2hhbm5lbC5jY01JRFJPVyhiKTtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygzLCAoKSA9PiAnTUlEUk9XICgnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnKScpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBQcmVhYmxlIEFjY2VzcyBDb2RlcyAoVGFibGUgNTMpLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVGVsbHMgaWYgUEFDIGZvdW5kXG4gICAqL1xuICBwYXJzZVBBQyhhLCBiKSB7XG4gICAgbGV0IHJvdztcbiAgICBjb25zdCBjYXNlMSA9IChhID49IDB4MTEgJiYgYSA8PSAweDE3IHx8IGEgPj0gMHgxOSAmJiBhIDw9IDB4MWYpICYmIGIgPj0gMHg0MCAmJiBiIDw9IDB4N2Y7XG4gICAgY29uc3QgY2FzZTIgPSAoYSA9PT0gMHgxMCB8fCBhID09PSAweDE4KSAmJiBiID49IDB4NDAgJiYgYiA8PSAweDVmO1xuICAgIGlmICghKGNhc2UxIHx8IGNhc2UyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBjaE5yID0gYSA8PSAweDE3ID8gMSA6IDI7XG4gICAgaWYgKGIgPj0gMHg0MCAmJiBiIDw9IDB4NWYpIHtcbiAgICAgIHJvdyA9IGNoTnIgPT09IDEgPyByb3dzTG93Q2gxW2FdIDogcm93c0xvd0NoMlthXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gMHg2MCA8PSBiIDw9IDB4N0ZcbiAgICAgIHJvdyA9IGNoTnIgPT09IDEgPyByb3dzSGlnaENoMVthXSA6IHJvd3NIaWdoQ2gyW2FdO1xuICAgIH1cbiAgICBjb25zdCBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaE5yXTtcbiAgICBpZiAoIWNoYW5uZWwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY2hhbm5lbC5zZXRQQUModGhpcy5pbnRlcnByZXRQQUMocm93LCBiKSk7XG4gICAgdGhpcy5jdXJyZW50Q2hhbm5lbCA9IGNoTnI7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJwcmV0IHRoZSBzZWNvbmQgYnl0ZSBvZiB0aGUgcGFjLCBhbmQgcmV0dXJuIHRoZSBpbmZvcm1hdGlvbi5cbiAgICogQHJldHVybnMgcGFjRGF0YSB3aXRoIHN0eWxlIHBhcmFtZXRlcnNcbiAgICovXG4gIGludGVycHJldFBBQyhyb3csIGJ5dGUpIHtcbiAgICBsZXQgcGFjSW5kZXg7XG4gICAgY29uc3QgcGFjRGF0YSA9IHtcbiAgICAgIGNvbG9yOiBudWxsLFxuICAgICAgaXRhbGljczogZmFsc2UsXG4gICAgICBpbmRlbnQ6IG51bGwsXG4gICAgICB1bmRlcmxpbmU6IGZhbHNlLFxuICAgICAgcm93OiByb3dcbiAgICB9O1xuICAgIGlmIChieXRlID4gMHg1Zikge1xuICAgICAgcGFjSW5kZXggPSBieXRlIC0gMHg2MDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFjSW5kZXggPSBieXRlIC0gMHg0MDtcbiAgICB9XG4gICAgcGFjRGF0YS51bmRlcmxpbmUgPSAocGFjSW5kZXggJiAxKSA9PT0gMTtcbiAgICBpZiAocGFjSW5kZXggPD0gMHhkKSB7XG4gICAgICBwYWNEYXRhLmNvbG9yID0gWyd3aGl0ZScsICdncmVlbicsICdibHVlJywgJ2N5YW4nLCAncmVkJywgJ3llbGxvdycsICdtYWdlbnRhJywgJ3doaXRlJ11bTWF0aC5mbG9vcihwYWNJbmRleCAvIDIpXTtcbiAgICB9IGVsc2UgaWYgKHBhY0luZGV4IDw9IDB4Zikge1xuICAgICAgcGFjRGF0YS5pdGFsaWNzID0gdHJ1ZTtcbiAgICAgIHBhY0RhdGEuY29sb3IgPSAnd2hpdGUnO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWNEYXRhLmluZGVudCA9IE1hdGguZmxvb3IoKHBhY0luZGV4IC0gMHgxMCkgLyAyKSAqIDQ7XG4gICAgfVxuICAgIHJldHVybiBwYWNEYXRhOyAvLyBOb3RlIHRoYXQgcm93IGhhcyB6ZXJvIG9mZnNldC4gVGhlIHNwZWMgdXNlcyAxLlxuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGNoYXJhY3RlcnMuXG4gICAqIEByZXR1cm5zIEFuIGFycmF5IHdpdGggMSB0byAyIGNvZGVzIGNvcnJlc3BvbmRpbmcgdG8gY2hhcnMsIGlmIGZvdW5kLiBudWxsIG90aGVyd2lzZS5cbiAgICovXG4gIHBhcnNlQ2hhcnMoYSwgYikge1xuICAgIGxldCBjaGFubmVsTnI7XG4gICAgbGV0IGNoYXJDb2RlcyA9IG51bGw7XG4gICAgbGV0IGNoYXJDb2RlMSA9IG51bGw7XG4gICAgaWYgKGEgPj0gMHgxOSkge1xuICAgICAgY2hhbm5lbE5yID0gMjtcbiAgICAgIGNoYXJDb2RlMSA9IGEgLSA4O1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGFubmVsTnIgPSAxO1xuICAgICAgY2hhckNvZGUxID0gYTtcbiAgICB9XG4gICAgaWYgKGNoYXJDb2RlMSA+PSAweDExICYmIGNoYXJDb2RlMSA8PSAweDEzKSB7XG4gICAgICAvLyBTcGVjaWFsIGNoYXJhY3RlclxuICAgICAgbGV0IG9uZUNvZGU7XG4gICAgICBpZiAoY2hhckNvZGUxID09PSAweDExKSB7XG4gICAgICAgIG9uZUNvZGUgPSBiICsgMHg1MDtcbiAgICAgIH0gZWxzZSBpZiAoY2hhckNvZGUxID09PSAweDEyKSB7XG4gICAgICAgIG9uZUNvZGUgPSBiICsgMHg3MDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uZUNvZGUgPSBiICsgMHg5MDtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nZ2VyLmxvZygyLCAoKSA9PiBcIlNwZWNpYWwgY2hhciAnXCIgKyBnZXRDaGFyRm9yQnl0ZShvbmVDb2RlKSArIFwiJyBpbiBjaGFubmVsIFwiICsgY2hhbm5lbE5yKTtcbiAgICAgIGNoYXJDb2RlcyA9IFtvbmVDb2RlXTtcbiAgICB9IGVsc2UgaWYgKGEgPj0gMHgyMCAmJiBhIDw9IDB4N2YpIHtcbiAgICAgIGNoYXJDb2RlcyA9IGIgPT09IDAgPyBbYV0gOiBbYSwgYl07XG4gICAgfVxuICAgIGlmIChjaGFyQ29kZXMpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygzLCAoKSA9PiAnQ2hhciBjb2RlcyA9ICAnICsgbnVtQXJyYXlUb0hleEFycmF5KGNoYXJDb2Rlcykuam9pbignLCcpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJDb2RlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBleHRlbmRlZCBiYWNrZ3JvdW5kIGF0dHJpYnV0ZXMgYXMgd2VsbCBhcyBuZXcgZm9yZWdyb3VuZCBjb2xvciBibGFjay5cbiAgICogQHJldHVybnMgVHJ1ZSBpZiBiYWNrZ3JvdW5kIGF0dHJpYnV0ZXMgYXJlIGZvdW5kXG4gICAqL1xuICBwYXJzZUJhY2tncm91bmRBdHRyaWJ1dGVzKGEsIGIpIHtcbiAgICBjb25zdCBjYXNlMSA9IChhID09PSAweDEwIHx8IGEgPT09IDB4MTgpICYmIGIgPj0gMHgyMCAmJiBiIDw9IDB4MmY7XG4gICAgY29uc3QgY2FzZTIgPSAoYSA9PT0gMHgxNyB8fCBhID09PSAweDFmKSAmJiBiID49IDB4MmQgJiYgYiA8PSAweDJmO1xuICAgIGlmICghKGNhc2UxIHx8IGNhc2UyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgaW5kZXg7XG4gICAgY29uc3QgYmtnRGF0YSA9IHt9O1xuICAgIGlmIChhID09PSAweDEwIHx8IGEgPT09IDB4MTgpIHtcbiAgICAgIGluZGV4ID0gTWF0aC5mbG9vcigoYiAtIDB4MjApIC8gMik7XG4gICAgICBia2dEYXRhLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kQ29sb3JzW2luZGV4XTtcbiAgICAgIGlmIChiICUgMiA9PT0gMSkge1xuICAgICAgICBia2dEYXRhLmJhY2tncm91bmQgPSBia2dEYXRhLmJhY2tncm91bmQgKyAnX3NlbWknO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyZCkge1xuICAgICAgYmtnRGF0YS5iYWNrZ3JvdW5kID0gJ3RyYW5zcGFyZW50JztcbiAgICB9IGVsc2Uge1xuICAgICAgYmtnRGF0YS5mb3JlZ3JvdW5kID0gJ2JsYWNrJztcbiAgICAgIGlmIChiID09PSAweDJmKSB7XG4gICAgICAgIGJrZ0RhdGEudW5kZXJsaW5lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY2hOciA9IGEgPD0gMHgxNyA/IDEgOiAyO1xuICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2NoTnJdO1xuICAgIGNoYW5uZWwuc2V0QmtnRGF0YShia2dEYXRhKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCBzdGF0ZSBvZiBwYXJzZXIgYW5kIGl0cyBjaGFubmVscy5cbiAgICovXG4gIHJlc2V0KCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgT2JqZWN0LmtleXModGhpcy5jaGFubmVscykubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2ldO1xuICAgICAgaWYgKGNoYW5uZWwpIHtcbiAgICAgICAgY2hhbm5lbC5yZXNldCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBzZXRMYXN0Q21kKG51bGwsIG51bGwsIHRoaXMuY21kSGlzdG9yeSk7XG4gIH1cblxuICAvKipcbiAgICogVHJpZ2dlciB0aGUgZ2VuZXJhdGlvbiBvZiBhIGN1ZSwgYW5kIHRoZSBzdGFydCBvZiBhIG5ldyBvbmUgaWYgZGlzcGxheVNjcmVlbnMgYXJlIG5vdCBlbXB0eS5cbiAgICovXG4gIGN1ZVNwbGl0QXRUaW1lKHQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hhbm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2ldO1xuICAgICAgaWYgKGNoYW5uZWwpIHtcbiAgICAgICAgY2hhbm5lbC5jdWVTcGxpdEF0VGltZSh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNldExhc3RDbWQoYSwgYiwgY21kSGlzdG9yeSkge1xuICBjbWRIaXN0b3J5LmEgPSBhO1xuICBjbWRIaXN0b3J5LmIgPSBiO1xufVxuZnVuY3Rpb24gaGFzQ21kUmVwZWF0ZWQoYSwgYiwgY21kSGlzdG9yeSkge1xuICByZXR1cm4gY21kSGlzdG9yeS5hID09PSBhICYmIGNtZEhpc3RvcnkuYiA9PT0gYjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNtZEhpc3RvcnkoKSB7XG4gIHJldHVybiB7XG4gICAgYTogbnVsbCxcbiAgICBiOiBudWxsXG4gIH07XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMTMgdnR0LmpzIENvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG52YXIgVlRUQ3VlID0gKGZ1bmN0aW9uICgpIHtcbiAgaWYgKG9wdGlvbmFsU2VsZiAhPSBudWxsICYmIG9wdGlvbmFsU2VsZi5WVFRDdWUpIHtcbiAgICByZXR1cm4gc2VsZi5WVFRDdWU7XG4gIH1cbiAgY29uc3QgQWxsb3dlZERpcmVjdGlvbnMgPSBbJycsICdscicsICdybCddO1xuICBjb25zdCBBbGxvd2VkQWxpZ25tZW50cyA9IFsnc3RhcnQnLCAnbWlkZGxlJywgJ2VuZCcsICdsZWZ0JywgJ3JpZ2h0J107XG4gIGZ1bmN0aW9uIGlzQWxsb3dlZFZhbHVlKGFsbG93ZWQsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gbmVjZXNzYXJ5IGZvciBhc3N1cmluZyB0aGUgZ2VuZXJpYyBjb25mb3JtcyB0byB0aGUgQXJyYXkgaW50ZXJmYWNlXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFsbG93ZWQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIHJlc2V0IHRoZSB0eXBlIHNvIHRoYXQgdGhlIG5leHQgbmFycm93aW5nIHdvcmtzIHdlbGxcbiAgICBjb25zdCBsY1ZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAvLyB1c2UgdGhlIGFsbG93IGxpc3QgdG8gbmFycm93IHRoZSB0eXBlIHRvIGEgc3BlY2lmaWMgc3Vic2V0IG9mIHN0cmluZ3NcbiAgICBpZiAofmFsbG93ZWQuaW5kZXhPZihsY1ZhbHVlKSkge1xuICAgICAgcmV0dXJuIGxjVmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBmaW5kRGlyZWN0aW9uU2V0dGluZyh2YWx1ZSkge1xuICAgIHJldHVybiBpc0FsbG93ZWRWYWx1ZShBbGxvd2VkRGlyZWN0aW9ucywgdmFsdWUpO1xuICB9XG4gIGZ1bmN0aW9uIGZpbmRBbGlnblNldHRpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gaXNBbGxvd2VkVmFsdWUoQWxsb3dlZEFsaWdubWVudHMsIHZhbHVlKTtcbiAgfVxuICBmdW5jdGlvbiBleHRlbmQob2JqLCAuLi5yZXN0KSB7XG4gICAgbGV0IGkgPSAxO1xuICAgIGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjb2JqID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yIChjb25zdCBwIGluIGNvYmopIHtcbiAgICAgICAgb2JqW3BdID0gY29ialtwXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICBmdW5jdGlvbiBWVFRDdWUoc3RhcnRUaW1lLCBlbmRUaW1lLCB0ZXh0KSB7XG4gICAgY29uc3QgY3VlID0gdGhpcztcbiAgICBjb25zdCBiYXNlT2JqID0ge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2hpbSBpbXBsZW1lbnRhdGlvbiBzcGVjaWZpYyBwcm9wZXJ0aWVzLiBUaGVzZSBwcm9wZXJ0aWVzIGFyZSBub3QgaW5cbiAgICAgKiB0aGUgc3BlYy5cbiAgICAgKi9cblxuICAgIC8vIExldHMgdXMga25vdyB3aGVuIHRoZSBWVFRDdWUncyBkYXRhIGhhcyBjaGFuZ2VkIGluIHN1Y2ggYSB3YXkgdGhhdCB3ZSBuZWVkXG4gICAgLy8gdG8gcmVjb21wdXRlIGl0cyBkaXNwbGF5IHN0YXRlLiBUaGlzIGxldHMgdXMgY29tcHV0ZSBpdHMgZGlzcGxheSBzdGF0ZVxuICAgIC8vIGxhemlseS5cbiAgICBjdWUuaGFzQmVlblJlc2V0ID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBWVFRDdWUgYW5kIFRleHRUcmFja0N1ZSBwcm9wZXJ0aWVzXG4gICAgICogaHR0cDovL2Rldi53My5vcmcvaHRtbDUvd2VidnR0LyN2dHRjdWUtaW50ZXJmYWNlXG4gICAgICovXG5cbiAgICBsZXQgX2lkID0gJyc7XG4gICAgbGV0IF9wYXVzZU9uRXhpdCA9IGZhbHNlO1xuICAgIGxldCBfc3RhcnRUaW1lID0gc3RhcnRUaW1lO1xuICAgIGxldCBfZW5kVGltZSA9IGVuZFRpbWU7XG4gICAgbGV0IF90ZXh0ID0gdGV4dDtcbiAgICBsZXQgX3JlZ2lvbiA9IG51bGw7XG4gICAgbGV0IF92ZXJ0aWNhbCA9ICcnO1xuICAgIGxldCBfc25hcFRvTGluZXMgPSB0cnVlO1xuICAgIGxldCBfbGluZSA9ICdhdXRvJztcbiAgICBsZXQgX2xpbmVBbGlnbiA9ICdzdGFydCc7XG4gICAgbGV0IF9wb3NpdGlvbiA9IDUwO1xuICAgIGxldCBfcG9zaXRpb25BbGlnbiA9ICdtaWRkbGUnO1xuICAgIGxldCBfc2l6ZSA9IDUwO1xuICAgIGxldCBfYWxpZ24gPSAnbWlkZGxlJztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnaWQnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2lkO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIF9pZCA9ICcnICsgdmFsdWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdwYXVzZU9uRXhpdCcsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfcGF1c2VPbkV4aXQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgX3BhdXNlT25FeGl0ID0gISF2YWx1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3N0YXJ0VGltZScsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfc3RhcnRUaW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3RhcnQgdGltZSBtdXN0IGJlIHNldCB0byBhIG51bWJlci4nKTtcbiAgICAgICAgfVxuICAgICAgICBfc3RhcnRUaW1lID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ2VuZFRpbWUnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2VuZFRpbWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFbmQgdGltZSBtdXN0IGJlIHNldCB0byBhIG51bWJlci4nKTtcbiAgICAgICAgfVxuICAgICAgICBfZW5kVGltZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICd0ZXh0JywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90ZXh0O1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIF90ZXh0ID0gJycgKyB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIC8vIHRvZG86IGltcGxlbWVudCBWVFRSZWdpb24gcG9seWZpbGw/XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3JlZ2lvbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfcmVnaW9uO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIF9yZWdpb24gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAndmVydGljYWwnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3ZlcnRpY2FsO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHNldHRpbmcgPSBmaW5kRGlyZWN0aW9uU2V0dGluZyh2YWx1ZSk7XG4gICAgICAgIC8vIEhhdmUgdG8gY2hlY2sgZm9yIGZhbHNlIGJlY2F1c2UgdGhlIHNldHRpbmcgYW4gYmUgYW4gZW1wdHkgc3RyaW5nLlxuICAgICAgICBpZiAoc2V0dGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBfdmVydGljYWwgPSBzZXR0aW5nO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdzbmFwVG9MaW5lcycsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfc25hcFRvTGluZXM7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgX3NuYXBUb0xpbmVzID0gISF2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnbGluZScsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfbGluZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyAmJiB2YWx1ZSAhPT0gJ2F1dG8nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG51bWJlciBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgICB9XG4gICAgICAgIF9saW5lID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ2xpbmVBbGlnbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfbGluZUFsaWduO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHNldHRpbmcgPSBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKTtcbiAgICAgICAgaWYgKCFzZXR0aW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX2xpbmVBbGlnbiA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3Bvc2l0aW9uJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9wb3NpdGlvbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb3NpdGlvbiBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLicpO1xuICAgICAgICB9XG4gICAgICAgIF9wb3NpdGlvbiA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdwb3NpdGlvbkFsaWduJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9wb3NpdGlvbkFsaWduO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHNldHRpbmcgPSBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKTtcbiAgICAgICAgaWYgKCFzZXR0aW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX3Bvc2l0aW9uQWxpZ24gPSBzZXR0aW5nO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdzaXplJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9zaXplO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPiAxMDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NpemUgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwMC4nKTtcbiAgICAgICAgfVxuICAgICAgICBfc2l6ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdhbGlnbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfYWxpZ247XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY29uc3Qgc2V0dGluZyA9IGZpbmRBbGlnblNldHRpbmcodmFsdWUpO1xuICAgICAgICBpZiAoIXNldHRpbmcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBfYWxpZ24gPSBzZXR0aW5nO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgLyoqXG4gICAgICogT3RoZXIgPHRyYWNrPiBzcGVjIGRlZmluZWQgcHJvcGVydGllc1xuICAgICAqL1xuXG4gICAgLy8gaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLXZpZGVvLWVsZW1lbnQuaHRtbCN0ZXh0LXRyYWNrLWN1ZS1kaXNwbGF5LXN0YXRlXG4gICAgY3VlLmRpc3BsYXlTdGF0ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBWVFRDdWUgbWV0aG9kc1xuICAgKi9cblxuICBWVFRDdWUucHJvdG90eXBlLmdldEN1ZUFzSFRNTCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBBc3N1bWUgV2ViVlRULmNvbnZlcnRDdWVUb0RPTVRyZWUgaXMgb24gdGhlIGdsb2JhbC5cbiAgICBjb25zdCBXZWJWVFQgPSBzZWxmLldlYlZUVDtcbiAgICByZXR1cm4gV2ViVlRULmNvbnZlcnRDdWVUb0RPTVRyZWUoc2VsZiwgdGhpcy50ZXh0KTtcbiAgfTtcbiAgLy8gdGhpcyBpcyBhIHBvbHlmaWxsIGhhY2tcbiAgcmV0dXJuIFZUVEN1ZTtcbn0pKCk7XG5cbi8qXG4gKiBTb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3Z0dC5qcy9ibG9iL21hc3Rlci9kaXN0L3Z0dC5qc1xuICovXG5cbmNsYXNzIFN0cmluZ0RlY29kZXIge1xuICBkZWNvZGUoZGF0YSwgb3B0aW9ucykge1xuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIC0gZXhwZWN0ZWQgc3RyaW5nIGRhdGEuJyk7XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZW5jb2RlVVJJQ29tcG9uZW50KGRhdGEpKTtcbiAgfVxufVxuXG4vLyBUcnkgdG8gcGFyc2UgaW5wdXQgYXMgYSB0aW1lIHN0YW1wLlxuZnVuY3Rpb24gcGFyc2VUaW1lU3RhbXAoaW5wdXQpIHtcbiAgZnVuY3Rpb24gY29tcHV0ZVNlY29uZHMoaCwgbSwgcywgZikge1xuICAgIHJldHVybiAoaCB8IDApICogMzYwMCArIChtIHwgMCkgKiA2MCArIChzIHwgMCkgKyBwYXJzZUZsb2F0KGYgfHwgMCk7XG4gIH1cbiAgY29uc3QgbSA9IGlucHV0Lm1hdGNoKC9eKD86KFxcZCspOik/KFxcZHsyfSk6KFxcZHsyfSkoXFwuXFxkKyk/Lyk7XG4gIGlmICghbSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChwYXJzZUZsb2F0KG1bMl0pID4gNTkpIHtcbiAgICAvLyBUaW1lc3RhbXAgdGFrZXMgdGhlIGZvcm0gb2YgW2hvdXJzXTpbbWludXRlc10uW21pbGxpc2Vjb25kc11cbiAgICAvLyBGaXJzdCBwb3NpdGlvbiBpcyBob3VycyBhcyBpdCdzIG92ZXIgNTkuXG4gICAgcmV0dXJuIGNvbXB1dGVTZWNvbmRzKG1bMl0sIG1bM10sIDAsIG1bNF0pO1xuICB9XG4gIC8vIFRpbWVzdGFtcCB0YWtlcyB0aGUgZm9ybSBvZiBbaG91cnMgKG9wdGlvbmFsKV06W21pbnV0ZXNdOltzZWNvbmRzXS5bbWlsbGlzZWNvbmRzXVxuICByZXR1cm4gY29tcHV0ZVNlY29uZHMobVsxXSwgbVsyXSwgbVszXSwgbVs0XSk7XG59XG5cbi8vIEEgc2V0dGluZ3Mgb2JqZWN0IGhvbGRzIGtleS92YWx1ZSBwYWlycyBhbmQgd2lsbCBpZ25vcmUgYW55dGhpbmcgYnV0IHRoZSBmaXJzdFxuLy8gYXNzaWdubWVudCB0byBhIHNwZWNpZmljIGtleS5cbmNsYXNzIFNldHRpbmdzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy52YWx1ZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIC8vIE9ubHkgYWNjZXB0IHRoZSBmaXJzdCBhc3NpZ25tZW50IHRvIGFueSBrZXkuXG4gIHNldChrLCB2KSB7XG4gICAgaWYgKCF0aGlzLmdldChrKSAmJiB2ICE9PSAnJykge1xuICAgICAgdGhpcy52YWx1ZXNba10gPSB2O1xuICAgIH1cbiAgfVxuICAvLyBSZXR1cm4gdGhlIHZhbHVlIGZvciBhIGtleSwgb3IgYSBkZWZhdWx0IHZhbHVlLlxuICAvLyBJZiAnZGVmYXVsdEtleScgaXMgcGFzc2VkIHRoZW4gJ2RmbHQnIGlzIGFzc3VtZWQgdG8gYmUgYW4gb2JqZWN0IHdpdGhcbiAgLy8gYSBudW1iZXIgb2YgcG9zc2libGUgZGVmYXVsdCB2YWx1ZXMgYXMgcHJvcGVydGllcyB3aGVyZSAnZGVmYXVsdEtleScgaXNcbiAgLy8gdGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdGhhdCB3aWxsIGJlIGNob3Nlbjsgb3RoZXJ3aXNlIGl0J3MgYXNzdW1lZCB0byBiZVxuICAvLyBhIHNpbmdsZSB2YWx1ZS5cbiAgZ2V0KGssIGRmbHQsIGRlZmF1bHRLZXkpIHtcbiAgICBpZiAoZGVmYXVsdEtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFzKGspID8gdGhpcy52YWx1ZXNba10gOiBkZmx0W2RlZmF1bHRLZXldO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5oYXMoaykgPyB0aGlzLnZhbHVlc1trXSA6IGRmbHQ7XG4gIH1cbiAgLy8gQ2hlY2sgd2hldGhlciB3ZSBoYXZlIGEgdmFsdWUgZm9yIGEga2V5LlxuICBoYXMoaykge1xuICAgIHJldHVybiBrIGluIHRoaXMudmFsdWVzO1xuICB9XG4gIC8vIEFjY2VwdCBhIHNldHRpbmcgaWYgaXRzIG9uZSBvZiB0aGUgZ2l2ZW4gYWx0ZXJuYXRpdmVzLlxuICBhbHQoaywgdiwgYSkge1xuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgYS5sZW5ndGg7ICsrbikge1xuICAgICAgaWYgKHYgPT09IGFbbl0pIHtcbiAgICAgICAgdGhpcy5zZXQoaywgdik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBhIHZhbGlkIChzaWduZWQpIGludGVnZXIuXG4gIGludGVnZXIoaywgdikge1xuICAgIGlmICgvXi0/XFxkKyQvLnRlc3QodikpIHtcbiAgICAgIC8vIGludGVnZXJcbiAgICAgIHRoaXMuc2V0KGssIHBhcnNlSW50KHYsIDEwKSk7XG4gICAgfVxuICB9XG4gIC8vIEFjY2VwdCBhIHNldHRpbmcgaWYgaXRzIGEgdmFsaWQgcGVyY2VudGFnZS5cbiAgcGVyY2VudChrLCB2KSB7XG4gICAgaWYgKC9eKFtcXGRdezEsM30pKFxcLltcXGRdKik/JSQvLnRlc3QodikpIHtcbiAgICAgIGNvbnN0IHBlcmNlbnQgPSBwYXJzZUZsb2F0KHYpO1xuICAgICAgaWYgKHBlcmNlbnQgPj0gMCAmJiBwZXJjZW50IDw9IDEwMCkge1xuICAgICAgICB0aGlzLnNldChrLCBwZXJjZW50KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gcGFyc2UgaW5wdXQgaW50byBncm91cHMgc2VwYXJhdGVkIGJ5ICdncm91cERlbGltJywgYW5kXG4vLyBpbnRlcnByZXQgZWFjaCBncm91cCBhcyBhIGtleS92YWx1ZSBwYWlyIHNlcGFyYXRlZCBieSAna2V5VmFsdWVEZWxpbScuXG5mdW5jdGlvbiBwYXJzZU9wdGlvbnMoaW5wdXQsIGNhbGxiYWNrLCBrZXlWYWx1ZURlbGltLCBncm91cERlbGltKSB7XG4gIGNvbnN0IGdyb3VwcyA9IGdyb3VwRGVsaW0gPyBpbnB1dC5zcGxpdChncm91cERlbGltKSA6IFtpbnB1dF07XG4gIGZvciAoY29uc3QgaSBpbiBncm91cHMpIHtcbiAgICBpZiAodHlwZW9mIGdyb3Vwc1tpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBrdiA9IGdyb3Vwc1tpXS5zcGxpdChrZXlWYWx1ZURlbGltKTtcbiAgICBpZiAoa3YubGVuZ3RoICE9PSAyKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgayA9IGt2WzBdO1xuICAgIGNvbnN0IHYgPSBrdlsxXTtcbiAgICBjYWxsYmFjayhrLCB2KTtcbiAgfVxufVxuY29uc3QgZGVmYXVsdHMgPSBuZXcgVlRUQ3VlKDAsIDAsICcnKTtcbi8vICdtaWRkbGUnIHdhcyBjaGFuZ2VkIHRvICdjZW50ZXInIGluIHRoZSBzcGVjOiBodHRwczovL2dpdGh1Yi5jb20vdzNjL3dlYnZ0dC9wdWxsLzI0NFxuLy8gIFNhZmFyaSBkb2Vzbid0IHlldCBzdXBwb3J0IHRoaXMgY2hhbmdlLCBidXQgRkYgYW5kIENocm9tZSBkby5cbmNvbnN0IGNlbnRlciA9IGRlZmF1bHRzLmFsaWduID09PSAnbWlkZGxlJyA/ICdtaWRkbGUnIDogJ2NlbnRlcic7XG5mdW5jdGlvbiBwYXJzZUN1ZShpbnB1dCwgY3VlLCByZWdpb25MaXN0KSB7XG4gIC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCBpbnB1dCBpZiB3ZSBuZWVkIHRvIHRocm93IGFuIGVycm9yLlxuICBjb25zdCBvSW5wdXQgPSBpbnB1dDtcbiAgLy8gNC4xIFdlYlZUVCB0aW1lc3RhbXBcbiAgZnVuY3Rpb24gY29uc3VtZVRpbWVTdGFtcCgpIHtcbiAgICBjb25zdCB0cyA9IHBhcnNlVGltZVN0YW1wKGlucHV0KTtcbiAgICBpZiAodHMgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIHRpbWVzdGFtcDogJyArIG9JbnB1dCk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIHRpbWUgc3RhbXAgZnJvbSBpbnB1dC5cbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL15bXlxcc2EtekEtWi1dKy8sICcnKTtcbiAgICByZXR1cm4gdHM7XG4gIH1cblxuICAvLyA0LjQuMiBXZWJWVFQgY3VlIHNldHRpbmdzXG4gIGZ1bmN0aW9uIGNvbnN1bWVDdWVTZXR0aW5ncyhpbnB1dCwgY3VlKSB7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSBuZXcgU2V0dGluZ3MoKTtcbiAgICBwYXJzZU9wdGlvbnMoaW5wdXQsIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICBsZXQgdmFscztcbiAgICAgIHN3aXRjaCAoaykge1xuICAgICAgICBjYXNlICdyZWdpb24nOlxuICAgICAgICAgIC8vIEZpbmQgdGhlIGxhc3QgcmVnaW9uIHdlIHBhcnNlZCB3aXRoIHRoZSBzYW1lIHJlZ2lvbiBpZC5cbiAgICAgICAgICBmb3IgKGxldCBpID0gcmVnaW9uTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKHJlZ2lvbkxpc3RbaV0uaWQgPT09IHYpIHtcbiAgICAgICAgICAgICAgc2V0dGluZ3Muc2V0KGssIHJlZ2lvbkxpc3RbaV0ucmVnaW9uKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd2ZXJ0aWNhbCc6XG4gICAgICAgICAgc2V0dGluZ3MuYWx0KGssIHYsIFsncmwnLCAnbHInXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2xpbmUnOlxuICAgICAgICAgIHZhbHMgPSB2LnNwbGl0KCcsJyk7XG4gICAgICAgICAgc2V0dGluZ3MuaW50ZWdlcihrLCB2YWxzWzBdKTtcbiAgICAgICAgICBpZiAoc2V0dGluZ3MucGVyY2VudChrLCB2YWxzWzBdKSkge1xuICAgICAgICAgICAgc2V0dGluZ3Muc2V0KCdzbmFwVG9MaW5lcycsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2V0dGluZ3MuYWx0KGssIHZhbHNbMF0sIFsnYXV0byddKTtcbiAgICAgICAgICBpZiAodmFscy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLmFsdCgnbGluZUFsaWduJywgdmFsc1sxXSwgWydzdGFydCcsIGNlbnRlciwgJ2VuZCddKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3Bvc2l0aW9uJzpcbiAgICAgICAgICB2YWxzID0gdi5zcGxpdCgnLCcpO1xuICAgICAgICAgIHNldHRpbmdzLnBlcmNlbnQoaywgdmFsc1swXSk7XG4gICAgICAgICAgaWYgKHZhbHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5hbHQoJ3Bvc2l0aW9uQWxpZ24nLCB2YWxzWzFdLCBbJ3N0YXJ0JywgY2VudGVyLCAnZW5kJywgJ2xpbmUtbGVmdCcsICdsaW5lLXJpZ2h0JywgJ2F1dG8nXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzaXplJzpcbiAgICAgICAgICBzZXR0aW5ncy5wZXJjZW50KGssIHYpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdhbGlnbic6XG4gICAgICAgICAgc2V0dGluZ3MuYWx0KGssIHYsIFsnc3RhcnQnLCBjZW50ZXIsICdlbmQnLCAnbGVmdCcsICdyaWdodCddKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9LCAvOi8sIC9cXHMvKTtcblxuICAgIC8vIEFwcGx5IGRlZmF1bHQgdmFsdWVzIGZvciBhbnkgbWlzc2luZyBmaWVsZHMuXG4gICAgY3VlLnJlZ2lvbiA9IHNldHRpbmdzLmdldCgncmVnaW9uJywgbnVsbCk7XG4gICAgY3VlLnZlcnRpY2FsID0gc2V0dGluZ3MuZ2V0KCd2ZXJ0aWNhbCcsICcnKTtcbiAgICBsZXQgbGluZSA9IHNldHRpbmdzLmdldCgnbGluZScsICdhdXRvJyk7XG4gICAgaWYgKGxpbmUgPT09ICdhdXRvJyAmJiBkZWZhdWx0cy5saW5lID09PSAtMSkge1xuICAgICAgLy8gc2V0IG51bWVyaWMgbGluZSBudW1iZXIgZm9yIFNhZmFyaVxuICAgICAgbGluZSA9IC0xO1xuICAgIH1cbiAgICBjdWUubGluZSA9IGxpbmU7XG4gICAgY3VlLmxpbmVBbGlnbiA9IHNldHRpbmdzLmdldCgnbGluZUFsaWduJywgJ3N0YXJ0Jyk7XG4gICAgY3VlLnNuYXBUb0xpbmVzID0gc2V0dGluZ3MuZ2V0KCdzbmFwVG9MaW5lcycsIHRydWUpO1xuICAgIGN1ZS5zaXplID0gc2V0dGluZ3MuZ2V0KCdzaXplJywgMTAwKTtcbiAgICBjdWUuYWxpZ24gPSBzZXR0aW5ncy5nZXQoJ2FsaWduJywgY2VudGVyKTtcbiAgICBsZXQgcG9zaXRpb24gPSBzZXR0aW5ncy5nZXQoJ3Bvc2l0aW9uJywgJ2F1dG8nKTtcbiAgICBpZiAocG9zaXRpb24gPT09ICdhdXRvJyAmJiBkZWZhdWx0cy5wb3NpdGlvbiA9PT0gNTApIHtcbiAgICAgIC8vIHNldCBudW1lcmljIHBvc2l0aW9uIGZvciBTYWZhcmlcbiAgICAgIHBvc2l0aW9uID0gY3VlLmFsaWduID09PSAnc3RhcnQnIHx8IGN1ZS5hbGlnbiA9PT0gJ2xlZnQnID8gMCA6IGN1ZS5hbGlnbiA9PT0gJ2VuZCcgfHwgY3VlLmFsaWduID09PSAncmlnaHQnID8gMTAwIDogNTA7XG4gICAgfVxuICAgIGN1ZS5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICB9XG4gIGZ1bmN0aW9uIHNraXBXaGl0ZXNwYWNlKCkge1xuICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvXlxccysvLCAnJyk7XG4gIH1cblxuICAvLyA0LjEgV2ViVlRUIGN1ZSB0aW1pbmdzLlxuICBza2lwV2hpdGVzcGFjZSgpO1xuICBjdWUuc3RhcnRUaW1lID0gY29uc3VtZVRpbWVTdGFtcCgpOyAvLyAoMSkgY29sbGVjdCBjdWUgc3RhcnQgdGltZVxuICBza2lwV2hpdGVzcGFjZSgpO1xuICBpZiAoaW5wdXQuc2xpY2UoMCwgMykgIT09ICctLT4nKSB7XG4gICAgLy8gKDMpIG5leHQgY2hhcmFjdGVycyBtdXN0IG1hdGNoICctLT4nXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIHRpbWUgc3RhbXAgKHRpbWUgc3RhbXBzIG11c3QgYmUgc2VwYXJhdGVkIGJ5ICctLT4nKTogXCIgKyBvSW5wdXQpO1xuICB9XG4gIGlucHV0ID0gaW5wdXQuc2xpY2UoMyk7XG4gIHNraXBXaGl0ZXNwYWNlKCk7XG4gIGN1ZS5lbmRUaW1lID0gY29uc3VtZVRpbWVTdGFtcCgpOyAvLyAoNSkgY29sbGVjdCBjdWUgZW5kIHRpbWVcblxuICAvLyA0LjEgV2ViVlRUIGN1ZSBzZXR0aW5ncyBsaXN0LlxuICBza2lwV2hpdGVzcGFjZSgpO1xuICBjb25zdW1lQ3VlU2V0dGluZ3MoaW5wdXQsIGN1ZSk7XG59XG5mdW5jdGlvbiBmaXhMaW5lQnJlYWtzKGlucHV0KSB7XG4gIHJldHVybiBpbnB1dC5yZXBsYWNlKC88YnIoPzogXFwvKT8+L2dpLCAnXFxuJyk7XG59XG5jbGFzcyBWVFRQYXJzZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnN0YXRlID0gJ0lOSVRJQUwnO1xuICAgIHRoaXMuYnVmZmVyID0gJyc7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoKTtcbiAgICB0aGlzLnJlZ2lvbkxpc3QgPSBbXTtcbiAgICB0aGlzLmN1ZSA9IG51bGw7XG4gICAgdGhpcy5vbmN1ZSA9IHZvaWQgMDtcbiAgICB0aGlzLm9ucGFyc2luZ2Vycm9yID0gdm9pZCAwO1xuICAgIHRoaXMub25mbHVzaCA9IHZvaWQgMDtcbiAgfVxuICBwYXJzZShkYXRhKSB7XG4gICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gZGF0YSB0aGVuIHdlIHdvbid0IGRlY29kZSBpdCwgYnV0IHdpbGwganVzdCB0cnkgdG8gcGFyc2VcbiAgICAvLyB3aGF0ZXZlciBpcyBpbiBidWZmZXIgYWxyZWFkeS4gVGhpcyBtYXkgb2NjdXIgaW4gY2lyY3Vtc3RhbmNlcywgZm9yXG4gICAgLy8gZXhhbXBsZSB3aGVuIGZsdXNoKCkgaXMgY2FsbGVkLlxuICAgIGlmIChkYXRhKSB7XG4gICAgICAvLyBUcnkgdG8gZGVjb2RlIHRoZSBkYXRhIHRoYXQgd2UgcmVjZWl2ZWQuXG4gICAgICBfdGhpcy5idWZmZXIgKz0gX3RoaXMuZGVjb2Rlci5kZWNvZGUoZGF0YSwge1xuICAgICAgICBzdHJlYW06IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb2xsZWN0TmV4dExpbmUoKSB7XG4gICAgICBsZXQgYnVmZmVyID0gX3RoaXMuYnVmZmVyO1xuICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICBidWZmZXIgPSBmaXhMaW5lQnJlYWtzKGJ1ZmZlcik7XG4gICAgICB3aGlsZSAocG9zIDwgYnVmZmVyLmxlbmd0aCAmJiBidWZmZXJbcG9zXSAhPT0gJ1xccicgJiYgYnVmZmVyW3Bvc10gIT09ICdcXG4nKSB7XG4gICAgICAgICsrcG9zO1xuICAgICAgfVxuICAgICAgY29uc3QgbGluZSA9IGJ1ZmZlci5zbGljZSgwLCBwb3MpO1xuICAgICAgLy8gQWR2YW5jZSB0aGUgYnVmZmVyIGVhcmx5IGluIGNhc2Ugd2UgZmFpbCBiZWxvdy5cbiAgICAgIGlmIChidWZmZXJbcG9zXSA9PT0gJ1xccicpIHtcbiAgICAgICAgKytwb3M7XG4gICAgICB9XG4gICAgICBpZiAoYnVmZmVyW3Bvc10gPT09ICdcXG4nKSB7XG4gICAgICAgICsrcG9zO1xuICAgICAgfVxuICAgICAgX3RoaXMuYnVmZmVyID0gYnVmZmVyLnNsaWNlKHBvcyk7XG4gICAgICByZXR1cm4gbGluZTtcbiAgICB9XG5cbiAgICAvLyAzLjIgV2ViVlRUIG1ldGFkYXRhIGhlYWRlciBzeW50YXhcbiAgICBmdW5jdGlvbiBwYXJzZUhlYWRlcihpbnB1dCkge1xuICAgICAgcGFyc2VPcHRpb25zKGlucHV0LCBmdW5jdGlvbiAoaywgdikge1xuICAgICAgICAvLyBzd2l0Y2ggKGspIHtcbiAgICAgICAgLy8gY2FzZSAncmVnaW9uJzpcbiAgICAgICAgLy8gMy4zIFdlYlZUVCByZWdpb24gbWV0YWRhdGEgaGVhZGVyIHN5bnRheFxuICAgICAgICAvLyBjb25zb2xlLmxvZygncGFyc2UgcmVnaW9uJywgdik7XG4gICAgICAgIC8vIHBhcnNlUmVnaW9uKHYpO1xuICAgICAgICAvLyBicmVhaztcbiAgICAgICAgLy8gfVxuICAgICAgfSwgLzovKTtcbiAgICB9XG5cbiAgICAvLyA1LjEgV2ViVlRUIGZpbGUgcGFyc2luZy5cbiAgICB0cnkge1xuICAgICAgbGV0IGxpbmUgPSAnJztcbiAgICAgIGlmIChfdGhpcy5zdGF0ZSA9PT0gJ0lOSVRJQUwnKSB7XG4gICAgICAgIC8vIFdlIGNhbid0IHN0YXJ0IHBhcnNpbmcgdW50aWwgd2UgaGF2ZSB0aGUgZmlyc3QgbGluZS5cbiAgICAgICAgaWYgKCEvXFxyXFxufFxcbi8udGVzdChfdGhpcy5idWZmZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgbGluZSA9IGNvbGxlY3ROZXh0TGluZSgpO1xuICAgICAgICAvLyBzdHJpcCBvZiBVVEYtOCBCT00gaWYgYW55XG4gICAgICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0J5dGVfb3JkZXJfbWFyayNVVEYtOFxuICAgICAgICBjb25zdCBtID0gbGluZS5tYXRjaCgvXijDr8K7wr8pP1dFQlZUVChbIFxcdF0uKik/JC8pO1xuICAgICAgICBpZiAoIShtICE9IG51bGwgJiYgbVswXSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBXZWJWVFQgc2lnbmF0dXJlLicpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLnN0YXRlID0gJ0hFQURFUic7XG4gICAgICB9XG4gICAgICBsZXQgYWxyZWFkeUNvbGxlY3RlZExpbmUgPSBmYWxzZTtcbiAgICAgIHdoaWxlIChfdGhpcy5idWZmZXIpIHtcbiAgICAgICAgLy8gV2UgY2FuJ3QgcGFyc2UgYSBsaW5lIHVudGlsIHdlIGhhdmUgdGhlIGZ1bGwgbGluZS5cbiAgICAgICAgaWYgKCEvXFxyXFxufFxcbi8udGVzdChfdGhpcy5idWZmZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhbHJlYWR5Q29sbGVjdGVkTGluZSkge1xuICAgICAgICAgIGxpbmUgPSBjb2xsZWN0TmV4dExpbmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbHJlYWR5Q29sbGVjdGVkTGluZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoX3RoaXMuc3RhdGUpIHtcbiAgICAgICAgICBjYXNlICdIRUFERVInOlxuICAgICAgICAgICAgLy8gMTMtMTggLSBBbGxvdyBhIGhlYWRlciAobWV0YWRhdGEpIHVuZGVyIHRoZSBXRUJWVFQgbGluZS5cbiAgICAgICAgICAgIGlmICgvOi8udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICBwYXJzZUhlYWRlcihsaW5lKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgICAgLy8gQW4gZW1wdHkgbGluZSB0ZXJtaW5hdGVzIHRoZSBoZWFkZXIgYW5kIHN0YXJ0cyB0aGUgYm9keSAoY3VlcykuXG4gICAgICAgICAgICAgIF90aGlzLnN0YXRlID0gJ0lEJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgJ05PVEUnOlxuICAgICAgICAgICAgLy8gSWdub3JlIE5PVEUgYmxvY2tzLlxuICAgICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAgIF90aGlzLnN0YXRlID0gJ0lEJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgJ0lEJzpcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciB0aGUgc3RhcnQgb2YgTk9URSBibG9ja3MuXG4gICAgICAgICAgICBpZiAoL15OT1RFKCR8WyBcXHRdKS8udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdOT1RFJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAxOS0yOSAtIEFsbG93IGFueSBudW1iZXIgb2YgbGluZSB0ZXJtaW5hdG9ycywgdGhlbiBpbml0aWFsaXplIG5ldyBjdWUgdmFsdWVzLlxuICAgICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuY3VlID0gbmV3IFZUVEN1ZSgwLCAwLCAnJyk7XG4gICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdDVUUnO1xuICAgICAgICAgICAgLy8gMzAtMzkgLSBDaGVjayBpZiBzZWxmIGxpbmUgY29udGFpbnMgYW4gb3B0aW9uYWwgaWRlbnRpZmllciBvciB0aW1pbmcgZGF0YS5cbiAgICAgICAgICAgIGlmIChsaW5lLmluZGV4T2YoJy0tPicpID09PSAtMSkge1xuICAgICAgICAgICAgICBfdGhpcy5jdWUuaWQgPSBsaW5lO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAvLyBQcm9jZXNzIGxpbmUgYXMgc3RhcnQgb2YgYSBjdWUuXG4gICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgIGNhc2UgJ0NVRSc6XG4gICAgICAgICAgICAvLyA0MCAtIENvbGxlY3QgY3VlIHRpbWluZ3MgYW5kIHNldHRpbmdzLlxuICAgICAgICAgICAgaWYgKCFfdGhpcy5jdWUpIHtcbiAgICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSAnQkFEQ1VFJztcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBwYXJzZUN1ZShsaW5lLCBfdGhpcy5jdWUsIF90aGlzLnJlZ2lvbkxpc3QpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAvLyBJbiBjYXNlIG9mIGFuIGVycm9yIGlnbm9yZSByZXN0IG9mIHRoZSBjdWUuXG4gICAgICAgICAgICAgIF90aGlzLmN1ZSA9IG51bGw7XG4gICAgICAgICAgICAgIF90aGlzLnN0YXRlID0gJ0JBRENVRSc7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSAnQ1VFVEVYVCc7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlICdDVUVURVhUJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgaGFzU3Vic3RyaW5nID0gbGluZS5pbmRleE9mKCctLT4nKSAhPT0gLTE7XG4gICAgICAgICAgICAgIC8vIDM0IC0gSWYgd2UgaGF2ZSBhbiBlbXB0eSBsaW5lIHRoZW4gcmVwb3J0IHRoZSBjdWUuXG4gICAgICAgICAgICAgIC8vIDM1IC0gSWYgd2UgaGF2ZSB0aGUgc3BlY2lhbCBzdWJzdHJpbmcgJy0tPicgdGhlbiByZXBvcnQgdGhlIGN1ZSxcbiAgICAgICAgICAgICAgLy8gYnV0IGRvIG5vdCBjb2xsZWN0IHRoZSBsaW5lIGFzIHdlIG5lZWQgdG8gcHJvY2VzcyB0aGUgY3VycmVudFxuICAgICAgICAgICAgICAvLyBvbmUgYXMgYSBuZXcgY3VlLlxuICAgICAgICAgICAgICBpZiAoIWxpbmUgfHwgaGFzU3Vic3RyaW5nICYmIChhbHJlYWR5Q29sbGVjdGVkTGluZSA9IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgYXJlIGRvbmUgcGFyc2luZyBzZWxmIGN1ZS5cbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMub25jdWUgJiYgX3RoaXMuY3VlKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpcy5vbmN1ZShfdGhpcy5jdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5jdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIF90aGlzLnN0YXRlID0gJ0lEJztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoX3RoaXMuY3VlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKF90aGlzLmN1ZS50ZXh0KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY3VlLnRleHQgKz0gJ1xcbic7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX3RoaXMuY3VlLnRleHQgKz0gbGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgJ0JBRENVRSc6XG4gICAgICAgICAgICAvLyA1NC02MiAtIENvbGxlY3QgYW5kIGRpc2NhcmQgdGhlIHJlbWFpbmluZyBjdWUuXG4gICAgICAgICAgICBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSAnSUQnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBwYXJzaW5nIGEgY3VlLCByZXBvcnQgd2hhdCB3ZSBoYXZlLlxuICAgICAgaWYgKF90aGlzLnN0YXRlID09PSAnQ1VFVEVYVCcgJiYgX3RoaXMuY3VlICYmIF90aGlzLm9uY3VlKSB7XG4gICAgICAgIF90aGlzLm9uY3VlKF90aGlzLmN1ZSk7XG4gICAgICB9XG4gICAgICBfdGhpcy5jdWUgPSBudWxsO1xuICAgICAgLy8gRW50ZXIgQkFEV0VCVlRUIHN0YXRlIGlmIGhlYWRlciB3YXMgbm90IHBhcnNlZCBjb3JyZWN0bHkgb3RoZXJ3aXNlXG4gICAgICAvLyBhbm90aGVyIGV4Y2VwdGlvbiBvY2N1cnJlZCBzbyBlbnRlciBCQURDVUUgc3RhdGUuXG4gICAgICBfdGhpcy5zdGF0ZSA9IF90aGlzLnN0YXRlID09PSAnSU5JVElBTCcgPyAnQkFEV0VCVlRUJyA6ICdCQURDVUUnO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBmbHVzaCgpIHtcbiAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEZpbmlzaCBkZWNvZGluZyB0aGUgc3RyZWFtLlxuICAgICAgLy8gX3RoaXMuYnVmZmVyICs9IF90aGlzLmRlY29kZXIuZGVjb2RlKCk7XG4gICAgICAvLyBTeW50aGVzaXplIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgY3VlIG9yIHJlZ2lvbi5cbiAgICAgIGlmIChfdGhpcy5jdWUgfHwgX3RoaXMuc3RhdGUgPT09ICdIRUFERVInKSB7XG4gICAgICAgIF90aGlzLmJ1ZmZlciArPSAnXFxuXFxuJztcbiAgICAgICAgX3RoaXMucGFyc2UoKTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHdlJ3ZlIGZsdXNoZWQsIHBhcnNlZCwgYW5kIHdlJ3JlIHN0aWxsIG9uIHRoZSBJTklUSUFMIHN0YXRlIHRoZW5cbiAgICAgIC8vIHRoYXQgbWVhbnMgd2UgZG9uJ3QgaGF2ZSBlbm91Z2ggb2YgdGhlIHN0cmVhbSB0byBwYXJzZSB0aGUgZmlyc3RcbiAgICAgIC8vIGxpbmUuXG4gICAgICBpZiAoX3RoaXMuc3RhdGUgPT09ICdJTklUSUFMJyB8fCBfdGhpcy5zdGF0ZSA9PT0gJ0JBRFdFQlZUVCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgV2ViVlRUIHNpZ25hdHVyZS4nKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoX3RoaXMub25wYXJzaW5nZXJyb3IpIHtcbiAgICAgICAgX3RoaXMub25wYXJzaW5nZXJyb3IoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChfdGhpcy5vbmZsdXNoKSB7XG4gICAgICBfdGhpcy5vbmZsdXNoKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbmNvbnN0IExJTkVCUkVBS1MgPSAvXFxyXFxufFxcblxccnxcXG58XFxyL2c7XG5cbi8vIFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aCBpcyBub3Qgc3VwcG9ydGVkIGluIElFMTFcbmNvbnN0IHN0YXJ0c1dpdGggPSBmdW5jdGlvbiBzdGFydHNXaXRoKGlucHV0U3RyaW5nLCBzZWFyY2hTdHJpbmcsIHBvc2l0aW9uID0gMCkge1xuICByZXR1cm4gaW5wdXRTdHJpbmcuc2xpY2UocG9zaXRpb24sIHBvc2l0aW9uICsgc2VhcmNoU3RyaW5nLmxlbmd0aCkgPT09IHNlYXJjaFN0cmluZztcbn07XG5jb25zdCBjdWVTdHJpbmcybWlsbGlzID0gZnVuY3Rpb24gY3VlU3RyaW5nMm1pbGxpcyh0aW1lU3RyaW5nKSB7XG4gIGxldCB0cyA9IHBhcnNlSW50KHRpbWVTdHJpbmcuc2xpY2UoLTMpKTtcbiAgY29uc3Qgc2VjcyA9IHBhcnNlSW50KHRpbWVTdHJpbmcuc2xpY2UoLTYsIC00KSk7XG4gIGNvbnN0IG1pbnMgPSBwYXJzZUludCh0aW1lU3RyaW5nLnNsaWNlKC05LCAtNykpO1xuICBjb25zdCBob3VycyA9IHRpbWVTdHJpbmcubGVuZ3RoID4gOSA/IHBhcnNlSW50KHRpbWVTdHJpbmcuc3Vic3RyaW5nKDAsIHRpbWVTdHJpbmcuaW5kZXhPZignOicpKSkgOiAwO1xuICBpZiAoIWlzRmluaXRlTnVtYmVyKHRzKSB8fCAhaXNGaW5pdGVOdW1iZXIoc2VjcykgfHwgIWlzRmluaXRlTnVtYmVyKG1pbnMpIHx8ICFpc0Zpbml0ZU51bWJlcihob3VycykpIHtcbiAgICB0aHJvdyBFcnJvcihgTWFsZm9ybWVkIFgtVElNRVNUQU1QLU1BUDogTG9jYWw6JHt0aW1lU3RyaW5nfWApO1xuICB9XG4gIHRzICs9IDEwMDAgKiBzZWNzO1xuICB0cyArPSA2MCAqIDEwMDAgKiBtaW5zO1xuICB0cyArPSA2MCAqIDYwICogMTAwMCAqIGhvdXJzO1xuICByZXR1cm4gdHM7XG59O1xuXG4vLyBDcmVhdGUgYSB1bmlxdWUgaGFzaCBpZCBmb3IgYSBjdWUgYmFzZWQgb24gc3RhcnQvZW5kIHRpbWVzIGFuZCB0ZXh0LlxuLy8gVGhpcyBoZWxwcyB0aW1lbGluZS1jb250cm9sbGVyIHRvIGF2b2lkIHNob3dpbmcgcmVwZWF0ZWQgY2FwdGlvbnMuXG5mdW5jdGlvbiBnZW5lcmF0ZUN1ZUlkKHN0YXJ0VGltZSwgZW5kVGltZSwgdGV4dCkge1xuICByZXR1cm4gaGFzaChzdGFydFRpbWUudG9TdHJpbmcoKSkgKyBoYXNoKGVuZFRpbWUudG9TdHJpbmcoKSkgKyBoYXNoKHRleHQpO1xufVxuY29uc3QgY2FsY3VsYXRlT2Zmc2V0ID0gZnVuY3Rpb24gY2FsY3VsYXRlT2Zmc2V0KHZ0dENDcywgY2MsIHByZXNlbnRhdGlvblRpbWUpIHtcbiAgbGV0IGN1cnJDQyA9IHZ0dENDc1tjY107XG4gIGxldCBwcmV2Q0MgPSB2dHRDQ3NbY3VyckNDLnByZXZDQ107XG5cbiAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgZGlzY29udGludWl0eSBvciBjdWVzIGhhdmUgYmVlbiBwcm9jZXNzZWQgc2luY2UgdGhlIGxhc3QgZGlzY29udGludWl0eVxuICAvLyBPZmZzZXQgPSBjdXJyZW50IGRpc2NvbnRpbnVpdHkgdGltZVxuICBpZiAoIXByZXZDQyB8fCAhcHJldkNDLm5ldyAmJiBjdXJyQ0MubmV3KSB7XG4gICAgdnR0Q0NzLmNjT2Zmc2V0ID0gdnR0Q0NzLnByZXNlbnRhdGlvbk9mZnNldCA9IGN1cnJDQy5zdGFydDtcbiAgICBjdXJyQ0MubmV3ID0gZmFsc2U7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gVGhlcmUgaGF2ZSBiZWVuIGRpc2NvbnRpbnVpdGllcyBzaW5jZSBjdWVzIHdlcmUgbGFzdCBwYXJzZWQuXG4gIC8vIE9mZnNldCA9IHRpbWUgZWxhcHNlZFxuICB3aGlsZSAoKF9wcmV2Q0MgPSBwcmV2Q0MpICE9IG51bGwgJiYgX3ByZXZDQy5uZXcpIHtcbiAgICB2YXIgX3ByZXZDQztcbiAgICB2dHRDQ3MuY2NPZmZzZXQgKz0gY3VyckNDLnN0YXJ0IC0gcHJldkNDLnN0YXJ0O1xuICAgIGN1cnJDQy5uZXcgPSBmYWxzZTtcbiAgICBjdXJyQ0MgPSBwcmV2Q0M7XG4gICAgcHJldkNDID0gdnR0Q0NzW2N1cnJDQy5wcmV2Q0NdO1xuICB9XG4gIHZ0dENDcy5wcmVzZW50YXRpb25PZmZzZXQgPSBwcmVzZW50YXRpb25UaW1lO1xufTtcbmZ1bmN0aW9uIHBhcnNlV2ViVlRUKHZ0dEJ5dGVBcnJheSwgaW5pdFBUUywgdnR0Q0NzLCBjYywgdGltZU9mZnNldCwgY2FsbEJhY2ssIGVycm9yQ2FsbEJhY2spIHtcbiAgY29uc3QgcGFyc2VyID0gbmV3IFZUVFBhcnNlcigpO1xuICAvLyBDb252ZXJ0IGJ5dGVBcnJheSBpbnRvIHN0cmluZywgcmVwbGFjaW5nIGFueSBzb21ld2hhdCBleG90aWMgbGluZWZlZWRzIHdpdGggXCJcXG5cIiwgdGhlbiBzcGxpdCBvbiB0aGF0IGNoYXJhY3Rlci5cbiAgLy8gVWludDhBcnJheS5wcm90b3R5cGUucmVkdWNlIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiBJRTExXG4gIGNvbnN0IHZ0dExpbmVzID0gdXRmOEFycmF5VG9TdHIobmV3IFVpbnQ4QXJyYXkodnR0Qnl0ZUFycmF5KSkudHJpbSgpLnJlcGxhY2UoTElORUJSRUFLUywgJ1xcbicpLnNwbGl0KCdcXG4nKTtcbiAgY29uc3QgY3VlcyA9IFtdO1xuICBjb25zdCBpbml0OTBrSHogPSBpbml0UFRTID8gdG9NcGVnVHNDbG9ja0Zyb21UaW1lc2NhbGUoaW5pdFBUUy5iYXNlVGltZSwgaW5pdFBUUy50aW1lc2NhbGUpIDogMDtcbiAgbGV0IGN1ZVRpbWUgPSAnMDA6MDAuMDAwJztcbiAgbGV0IHRpbWVzdGFtcE1hcE1QRUdUUyA9IDA7XG4gIGxldCB0aW1lc3RhbXBNYXBMT0NBTCA9IDA7XG4gIGxldCBwYXJzaW5nRXJyb3I7XG4gIGxldCBpbkhlYWRlciA9IHRydWU7XG4gIHBhcnNlci5vbmN1ZSA9IGZ1bmN0aW9uIChjdWUpIHtcbiAgICAvLyBBZGp1c3QgY3VlIHRpbWluZzsgY2xhbXAgY3VlcyB0byBzdGFydCBubyBlYXJsaWVyIHRoYW4gLSBhbmQgZHJvcCBjdWVzIHRoYXQgZG9uJ3QgZW5kIGFmdGVyIC0gMCBvbiB0aW1lbGluZS5cbiAgICBjb25zdCBjdXJyQ0MgPSB2dHRDQ3NbY2NdO1xuICAgIGxldCBjdWVPZmZzZXQgPSB2dHRDQ3MuY2NPZmZzZXQ7XG5cbiAgICAvLyBDYWxjdWxhdGUgc3VidGl0bGUgUFRTIG9mZnNldFxuICAgIGNvbnN0IHdlYlZ0dE1wZWdUc01hcE9mZnNldCA9ICh0aW1lc3RhbXBNYXBNUEVHVFMgLSBpbml0OTBrSHopIC8gOTAwMDA7XG5cbiAgICAvLyBVcGRhdGUgb2Zmc2V0cyBmb3IgbmV3IGRpc2NvbnRpbnVpdGllc1xuICAgIGlmIChjdXJyQ0MgIT0gbnVsbCAmJiBjdXJyQ0MubmV3KSB7XG4gICAgICBpZiAodGltZXN0YW1wTWFwTE9DQUwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBXaGVuIGxvY2FsIHRpbWUgaXMgcHJvdmlkZWQsIG9mZnNldCA9IGRpc2NvbnRpbnVpdHkgc3RhcnQgdGltZSAtIGxvY2FsIHRpbWVcbiAgICAgICAgY3VlT2Zmc2V0ID0gdnR0Q0NzLmNjT2Zmc2V0ID0gY3VyckNDLnN0YXJ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsY3VsYXRlT2Zmc2V0KHZ0dENDcywgY2MsIHdlYlZ0dE1wZWdUc01hcE9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh3ZWJWdHRNcGVnVHNNYXBPZmZzZXQpIHtcbiAgICAgIGlmICghaW5pdFBUUykge1xuICAgICAgICBwYXJzaW5nRXJyb3IgPSBuZXcgRXJyb3IoJ01pc3NpbmcgaW5pdFBUUyBmb3IgVlRUIE1QRUdUUycpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBJZiB3ZSBoYXZlIE1QRUdUUywgb2Zmc2V0ID0gcHJlc2VudGF0aW9uIHRpbWUgKyBkaXNjb250aW51aXR5IG9mZnNldFxuICAgICAgY3VlT2Zmc2V0ID0gd2ViVnR0TXBlZ1RzTWFwT2Zmc2V0IC0gdnR0Q0NzLnByZXNlbnRhdGlvbk9mZnNldDtcbiAgICB9XG4gICAgY29uc3QgZHVyYXRpb24gPSBjdWUuZW5kVGltZSAtIGN1ZS5zdGFydFRpbWU7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gbm9ybWFsaXplUHRzKChjdWUuc3RhcnRUaW1lICsgY3VlT2Zmc2V0IC0gdGltZXN0YW1wTWFwTE9DQUwpICogOTAwMDAsIHRpbWVPZmZzZXQgKiA5MDAwMCkgLyA5MDAwMDtcbiAgICBjdWUuc3RhcnRUaW1lID0gTWF0aC5tYXgoc3RhcnRUaW1lLCAwKTtcbiAgICBjdWUuZW5kVGltZSA9IE1hdGgubWF4KHN0YXJ0VGltZSArIGR1cmF0aW9uLCAwKTtcblxuICAgIC8vdHJpbSB0cmFpbGluZyB3ZWJ2dHQgYmxvY2sgd2hpdGVzcGFjZXNcbiAgICBjb25zdCB0ZXh0ID0gY3VlLnRleHQudHJpbSgpO1xuXG4gICAgLy8gRml4IGVuY29kaW5nIG9mIHNwZWNpYWwgY2hhcmFjdGVyc1xuICAgIGN1ZS50ZXh0ID0gZGVjb2RlVVJJQ29tcG9uZW50KGVuY29kZVVSSUNvbXBvbmVudCh0ZXh0KSk7XG5cbiAgICAvLyBJZiB0aGUgY3VlIHdhcyBub3QgYXNzaWduZWQgYW4gaWQgZnJvbSB0aGUgVlRUIGZpbGUgKGxpbmUgYWJvdmUgdGhlIGNvbnRlbnQpLCBjcmVhdGUgb25lLlxuICAgIGlmICghY3VlLmlkKSB7XG4gICAgICBjdWUuaWQgPSBnZW5lcmF0ZUN1ZUlkKGN1ZS5zdGFydFRpbWUsIGN1ZS5lbmRUaW1lLCB0ZXh0KTtcbiAgICB9XG4gICAgaWYgKGN1ZS5lbmRUaW1lID4gMCkge1xuICAgICAgY3Vlcy5wdXNoKGN1ZSk7XG4gICAgfVxuICB9O1xuICBwYXJzZXIub25wYXJzaW5nZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICBwYXJzaW5nRXJyb3IgPSBlcnJvcjtcbiAgfTtcbiAgcGFyc2VyLm9uZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHBhcnNpbmdFcnJvcikge1xuICAgICAgZXJyb3JDYWxsQmFjayhwYXJzaW5nRXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsQmFjayhjdWVzKTtcbiAgfTtcblxuICAvLyBHbyB0aHJvdWdoIGNvbnRlbnRzIGxpbmUgYnkgbGluZS5cbiAgdnR0TGluZXMuZm9yRWFjaChsaW5lID0+IHtcbiAgICBpZiAoaW5IZWFkZXIpIHtcbiAgICAgIC8vIExvb2sgZm9yIFgtVElNRVNUQU1QLU1BUCBpbiBoZWFkZXIuXG4gICAgICBpZiAoc3RhcnRzV2l0aChsaW5lLCAnWC1USU1FU1RBTVAtTUFQPScpKSB7XG4gICAgICAgIC8vIE9uY2UgZm91bmQsIG5vIG1vcmUgYXJlIGFsbG93ZWQgYW55d2F5LCBzbyBzdG9wIHNlYXJjaGluZy5cbiAgICAgICAgaW5IZWFkZXIgPSBmYWxzZTtcbiAgICAgICAgLy8gRXh0cmFjdCBMT0NBTCBhbmQgTVBFR1RTLlxuICAgICAgICBsaW5lLnNsaWNlKDE2KS5zcGxpdCgnLCcpLmZvckVhY2godGltZXN0YW1wID0+IHtcbiAgICAgICAgICBpZiAoc3RhcnRzV2l0aCh0aW1lc3RhbXAsICdMT0NBTDonKSkge1xuICAgICAgICAgICAgY3VlVGltZSA9IHRpbWVzdGFtcC5zbGljZSg2KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0c1dpdGgodGltZXN0YW1wLCAnTVBFR1RTOicpKSB7XG4gICAgICAgICAgICB0aW1lc3RhbXBNYXBNUEVHVFMgPSBwYXJzZUludCh0aW1lc3RhbXAuc2xpY2UoNykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gQ29udmVydCBjdWUgdGltZSB0byBzZWNvbmRzXG4gICAgICAgICAgdGltZXN0YW1wTWFwTE9DQUwgPSBjdWVTdHJpbmcybWlsbGlzKGN1ZVRpbWUpIC8gMTAwMDtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBwYXJzaW5nRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gd2l0aG91dCBwYXJzaW5nIFgtVElNRVNUQU1QLU1BUCBsaW5lLlxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKGxpbmUgPT09ICcnKSB7XG4gICAgICAgIGluSGVhZGVyID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFBhcnNlIGxpbmUgYnkgZGVmYXVsdC5cbiAgICBwYXJzZXIucGFyc2UobGluZSArICdcXG4nKTtcbiAgfSk7XG4gIHBhcnNlci5mbHVzaCgpO1xufVxuXG5jb25zdCBJTVNDMV9DT0RFQyA9ICdzdHBwLnR0bWwuaW0xdCc7XG5cbi8vIFRpbWUgZm9ybWF0OiBoOm06czpmcmFtZXMoLnN1YmZyYW1lcylcbmNvbnN0IEhNU0ZfUkVHRVggPSAvXihcXGR7Mix9KTooXFxkezJ9KTooXFxkezJ9KTooXFxkezJ9KVxcLj8oXFxkKyk/JC87XG5cbi8vIFRpbWUgZm9ybWF0OiBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBmcmFtZXMsIHRpY2tzXG5jb25zdCBUSU1FX1VOSVRfUkVHRVggPSAvXihcXGQqKD86XFwuXFxkKik/KShofG18c3xtc3xmfHQpJC87XG5jb25zdCB0ZXh0QWxpZ25Ub0xpbmVBbGlnbiA9IHtcbiAgbGVmdDogJ3N0YXJ0JyxcbiAgY2VudGVyOiAnY2VudGVyJyxcbiAgcmlnaHQ6ICdlbmQnLFxuICBzdGFydDogJ3N0YXJ0JyxcbiAgZW5kOiAnZW5kJ1xufTtcbmZ1bmN0aW9uIHBhcnNlSU1TQzEocGF5bG9hZCwgaW5pdFBUUywgY2FsbEJhY2ssIGVycm9yQ2FsbEJhY2spIHtcbiAgY29uc3QgcmVzdWx0cyA9IGZpbmRCb3gobmV3IFVpbnQ4QXJyYXkocGF5bG9hZCksIFsnbWRhdCddKTtcbiAgaWYgKHJlc3VsdHMubGVuZ3RoID09PSAwKSB7XG4gICAgZXJyb3JDYWxsQmFjayhuZXcgRXJyb3IoJ0NvdWxkIG5vdCBwYXJzZSBJTVNDMSBtZGF0JykpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0dG1sTGlzdCA9IHJlc3VsdHMubWFwKG1kYXQgPT4gdXRmOEFycmF5VG9TdHIobWRhdCkpO1xuICBjb25zdCBzeW5jVGltZSA9IHRvVGltZXNjYWxlRnJvbVNjYWxlKGluaXRQVFMuYmFzZVRpbWUsIDEsIGluaXRQVFMudGltZXNjYWxlKTtcbiAgdHJ5IHtcbiAgICB0dG1sTGlzdC5mb3JFYWNoKHR0bWwgPT4gY2FsbEJhY2socGFyc2VUVE1MKHR0bWwsIHN5bmNUaW1lKSkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGVycm9yQ2FsbEJhY2soZXJyb3IpO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZVRUTUwodHRtbCwgc3luY1RpbWUpIHtcbiAgY29uc3QgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICBjb25zdCB4bWxEb2MgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHR0bWwsICd0ZXh0L3htbCcpO1xuICBjb25zdCB0dCA9IHhtbERvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgndHQnKVswXTtcbiAgaWYgKCF0dCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0dG1sJyk7XG4gIH1cbiAgY29uc3QgZGVmYXVsdFJhdGVJbmZvID0ge1xuICAgIGZyYW1lUmF0ZTogMzAsXG4gICAgc3ViRnJhbWVSYXRlOiAxLFxuICAgIGZyYW1lUmF0ZU11bHRpcGxpZXI6IDAsXG4gICAgdGlja1JhdGU6IDBcbiAgfTtcbiAgY29uc3QgcmF0ZUluZm8gPSBPYmplY3Qua2V5cyhkZWZhdWx0UmF0ZUluZm8pLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IHtcbiAgICByZXN1bHRba2V5XSA9IHR0LmdldEF0dHJpYnV0ZShgdHRwOiR7a2V5fWApIHx8IGRlZmF1bHRSYXRlSW5mb1trZXldO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIHt9KTtcbiAgY29uc3QgdHJpbSA9IHR0LmdldEF0dHJpYnV0ZSgneG1sOnNwYWNlJykgIT09ICdwcmVzZXJ2ZSc7XG4gIGNvbnN0IHN0eWxlRWxlbWVudHMgPSBjb2xsZWN0aW9uVG9EaWN0aW9uYXJ5KGdldEVsZW1lbnRDb2xsZWN0aW9uKHR0LCAnc3R5bGluZycsICdzdHlsZScpKTtcbiAgY29uc3QgcmVnaW9uRWxlbWVudHMgPSBjb2xsZWN0aW9uVG9EaWN0aW9uYXJ5KGdldEVsZW1lbnRDb2xsZWN0aW9uKHR0LCAnbGF5b3V0JywgJ3JlZ2lvbicpKTtcbiAgY29uc3QgY3VlRWxlbWVudHMgPSBnZXRFbGVtZW50Q29sbGVjdGlvbih0dCwgJ2JvZHknLCAnW2JlZ2luXScpO1xuICByZXR1cm4gW10ubWFwLmNhbGwoY3VlRWxlbWVudHMsIGN1ZUVsZW1lbnQgPT4ge1xuICAgIGNvbnN0IGN1ZVRleHQgPSBnZXRUZXh0Q29udGVudChjdWVFbGVtZW50LCB0cmltKTtcbiAgICBpZiAoIWN1ZVRleHQgfHwgIWN1ZUVsZW1lbnQuaGFzQXR0cmlidXRlKCdiZWdpbicpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gcGFyc2VUdG1sVGltZShjdWVFbGVtZW50LmdldEF0dHJpYnV0ZSgnYmVnaW4nKSwgcmF0ZUluZm8pO1xuICAgIGNvbnN0IGR1cmF0aW9uID0gcGFyc2VUdG1sVGltZShjdWVFbGVtZW50LmdldEF0dHJpYnV0ZSgnZHVyJyksIHJhdGVJbmZvKTtcbiAgICBsZXQgZW5kVGltZSA9IHBhcnNlVHRtbFRpbWUoY3VlRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2VuZCcpLCByYXRlSW5mbyk7XG4gICAgaWYgKHN0YXJ0VGltZSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgdGltZXN0YW1wUGFyc2luZ0Vycm9yKGN1ZUVsZW1lbnQpO1xuICAgIH1cbiAgICBpZiAoZW5kVGltZSA9PT0gbnVsbCkge1xuICAgICAgaWYgKGR1cmF0aW9uID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IHRpbWVzdGFtcFBhcnNpbmdFcnJvcihjdWVFbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIGVuZFRpbWUgPSBzdGFydFRpbWUgKyBkdXJhdGlvbjtcbiAgICB9XG4gICAgY29uc3QgY3VlID0gbmV3IFZUVEN1ZShzdGFydFRpbWUgLSBzeW5jVGltZSwgZW5kVGltZSAtIHN5bmNUaW1lLCBjdWVUZXh0KTtcbiAgICBjdWUuaWQgPSBnZW5lcmF0ZUN1ZUlkKGN1ZS5zdGFydFRpbWUsIGN1ZS5lbmRUaW1lLCBjdWUudGV4dCk7XG4gICAgY29uc3QgcmVnaW9uID0gcmVnaW9uRWxlbWVudHNbY3VlRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JlZ2lvbicpXTtcbiAgICBjb25zdCBzdHlsZSA9IHN0eWxlRWxlbWVudHNbY3VlRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyldO1xuXG4gICAgLy8gQXBwbHkgc3R5bGVzIHRvIGN1ZVxuICAgIGNvbnN0IHN0eWxlcyA9IGdldFR0bWxTdHlsZXMocmVnaW9uLCBzdHlsZSwgc3R5bGVFbGVtZW50cyk7XG4gICAgY29uc3Qge1xuICAgICAgdGV4dEFsaWduXG4gICAgfSA9IHN0eWxlcztcbiAgICBpZiAodGV4dEFsaWduKSB7XG4gICAgICAvLyBjdWUucG9zaXRpb25BbGlnbiBub3Qgc2V0dGFibGUgaW4gRkZ+MjAxNlxuICAgICAgY29uc3QgbGluZUFsaWduID0gdGV4dEFsaWduVG9MaW5lQWxpZ25bdGV4dEFsaWduXTtcbiAgICAgIGlmIChsaW5lQWxpZ24pIHtcbiAgICAgICAgY3VlLmxpbmVBbGlnbiA9IGxpbmVBbGlnbjtcbiAgICAgIH1cbiAgICAgIGN1ZS5hbGlnbiA9IHRleHRBbGlnbjtcbiAgICB9XG4gICAgX2V4dGVuZHMoY3VlLCBzdHlsZXMpO1xuICAgIHJldHVybiBjdWU7XG4gIH0pLmZpbHRlcihjdWUgPT4gY3VlICE9PSBudWxsKTtcbn1cbmZ1bmN0aW9uIGdldEVsZW1lbnRDb2xsZWN0aW9uKGZyb21FbGVtZW50LCBwYXJlbnROYW1lLCBjaGlsZE5hbWUpIHtcbiAgY29uc3QgcGFyZW50ID0gZnJvbUVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUocGFyZW50TmFtZSlbMF07XG4gIGlmIChwYXJlbnQpIHtcbiAgICByZXR1cm4gW10uc2xpY2UuY2FsbChwYXJlbnQucXVlcnlTZWxlY3RvckFsbChjaGlsZE5hbWUpKTtcbiAgfVxuICByZXR1cm4gW107XG59XG5mdW5jdGlvbiBjb2xsZWN0aW9uVG9EaWN0aW9uYXJ5KGVsZW1lbnRzV2l0aElkKSB7XG4gIHJldHVybiBlbGVtZW50c1dpdGhJZC5yZWR1Y2UoKGRpY3QsIGVsZW1lbnQpID0+IHtcbiAgICBjb25zdCBpZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd4bWw6aWQnKTtcbiAgICBpZiAoaWQpIHtcbiAgICAgIGRpY3RbaWRdID0gZWxlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIGRpY3Q7XG4gIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIGdldFRleHRDb250ZW50KGVsZW1lbnQsIHRyaW0pIHtcbiAgcmV0dXJuIFtdLnNsaWNlLmNhbGwoZWxlbWVudC5jaGlsZE5vZGVzKS5yZWR1Y2UoKHN0ciwgbm9kZSwgaSkgPT4ge1xuICAgIHZhciBfbm9kZSRjaGlsZE5vZGVzO1xuICAgIGlmIChub2RlLm5vZGVOYW1lID09PSAnYnInICYmIGkpIHtcbiAgICAgIHJldHVybiBzdHIgKyAnXFxuJztcbiAgICB9XG4gICAgaWYgKChfbm9kZSRjaGlsZE5vZGVzID0gbm9kZS5jaGlsZE5vZGVzKSAhPSBudWxsICYmIF9ub2RlJGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZ2V0VGV4dENvbnRlbnQobm9kZSwgdHJpbSk7XG4gICAgfSBlbHNlIGlmICh0cmltKSB7XG4gICAgICByZXR1cm4gc3RyICsgbm9kZS50ZXh0Q29udGVudC50cmltKCkucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyICsgbm9kZS50ZXh0Q29udGVudDtcbiAgfSwgJycpO1xufVxuZnVuY3Rpb24gZ2V0VHRtbFN0eWxlcyhyZWdpb24sIHN0eWxlLCBzdHlsZUVsZW1lbnRzKSB7XG4gIGNvbnN0IHR0c05zID0gJ2h0dHA6Ly93d3cudzMub3JnL25zL3R0bWwjc3R5bGluZyc7XG4gIGxldCByZWdpb25TdHlsZSA9IG51bGw7XG4gIGNvbnN0IHN0eWxlQXR0cmlidXRlcyA9IFsnZGlzcGxheUFsaWduJywgJ3RleHRBbGlnbicsICdjb2xvcicsICdiYWNrZ3JvdW5kQ29sb3InLCAnZm9udFNpemUnLCAnZm9udEZhbWlseSdcbiAgLy8gJ2ZvbnRXZWlnaHQnLFxuICAvLyAnbGluZUhlaWdodCcsXG4gIC8vICd3cmFwT3B0aW9uJyxcbiAgLy8gJ2ZvbnRTdHlsZScsXG4gIC8vICdkaXJlY3Rpb24nLFxuICAvLyAnd3JpdGluZ01vZGUnXG4gIF07XG4gIGNvbnN0IHJlZ2lvblN0eWxlTmFtZSA9IHJlZ2lvbiAhPSBudWxsICYmIHJlZ2lvbi5oYXNBdHRyaWJ1dGUoJ3N0eWxlJykgPyByZWdpb24uZ2V0QXR0cmlidXRlKCdzdHlsZScpIDogbnVsbDtcbiAgaWYgKHJlZ2lvblN0eWxlTmFtZSAmJiBzdHlsZUVsZW1lbnRzLmhhc093blByb3BlcnR5KHJlZ2lvblN0eWxlTmFtZSkpIHtcbiAgICByZWdpb25TdHlsZSA9IHN0eWxlRWxlbWVudHNbcmVnaW9uU3R5bGVOYW1lXTtcbiAgfVxuICByZXR1cm4gc3R5bGVBdHRyaWJ1dGVzLnJlZHVjZSgoc3R5bGVzLCBuYW1lKSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRBdHRyaWJ1dGVOUyhzdHlsZSwgdHRzTnMsIG5hbWUpIHx8IGdldEF0dHJpYnV0ZU5TKHJlZ2lvbiwgdHRzTnMsIG5hbWUpIHx8IGdldEF0dHJpYnV0ZU5TKHJlZ2lvblN0eWxlLCB0dHNOcywgbmFtZSk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBzdHlsZXNbbmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlcztcbiAgfSwge30pO1xufVxuZnVuY3Rpb24gZ2V0QXR0cmlidXRlTlMoZWxlbWVudCwgbnMsIG5hbWUpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQuaGFzQXR0cmlidXRlTlMobnMsIG5hbWUpID8gZWxlbWVudC5nZXRBdHRyaWJ1dGVOUyhucywgbmFtZSkgOiBudWxsO1xufVxuZnVuY3Rpb24gdGltZXN0YW1wUGFyc2luZ0Vycm9yKG5vZGUpIHtcbiAgcmV0dXJuIG5ldyBFcnJvcihgQ291bGQgbm90IHBhcnNlIHR0bWwgdGltZXN0YW1wICR7bm9kZX1gKTtcbn1cbmZ1bmN0aW9uIHBhcnNlVHRtbFRpbWUodGltZUF0dHJpYnV0ZVZhbHVlLCByYXRlSW5mbykge1xuICBpZiAoIXRpbWVBdHRyaWJ1dGVWYWx1ZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxldCBzZWNvbmRzID0gcGFyc2VUaW1lU3RhbXAodGltZUF0dHJpYnV0ZVZhbHVlKTtcbiAgaWYgKHNlY29uZHMgPT09IG51bGwpIHtcbiAgICBpZiAoSE1TRl9SRUdFWC50ZXN0KHRpbWVBdHRyaWJ1dGVWYWx1ZSkpIHtcbiAgICAgIHNlY29uZHMgPSBwYXJzZUhvdXJzTWludXRlc1NlY29uZHNGcmFtZXModGltZUF0dHJpYnV0ZVZhbHVlLCByYXRlSW5mbyk7XG4gICAgfSBlbHNlIGlmIChUSU1FX1VOSVRfUkVHRVgudGVzdCh0aW1lQXR0cmlidXRlVmFsdWUpKSB7XG4gICAgICBzZWNvbmRzID0gcGFyc2VUaW1lVW5pdHModGltZUF0dHJpYnV0ZVZhbHVlLCByYXRlSW5mbyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZWNvbmRzO1xufVxuZnVuY3Rpb24gcGFyc2VIb3Vyc01pbnV0ZXNTZWNvbmRzRnJhbWVzKHRpbWVBdHRyaWJ1dGVWYWx1ZSwgcmF0ZUluZm8pIHtcbiAgY29uc3QgbSA9IEhNU0ZfUkVHRVguZXhlYyh0aW1lQXR0cmlidXRlVmFsdWUpO1xuICBjb25zdCBmcmFtZXMgPSAobVs0XSB8IDApICsgKG1bNV0gfCAwKSAvIHJhdGVJbmZvLnN1YkZyYW1lUmF0ZTtcbiAgcmV0dXJuIChtWzFdIHwgMCkgKiAzNjAwICsgKG1bMl0gfCAwKSAqIDYwICsgKG1bM10gfCAwKSArIGZyYW1lcyAvIHJhdGVJbmZvLmZyYW1lUmF0ZTtcbn1cbmZ1bmN0aW9uIHBhcnNlVGltZVVuaXRzKHRpbWVBdHRyaWJ1dGVWYWx1ZSwgcmF0ZUluZm8pIHtcbiAgY29uc3QgbSA9IFRJTUVfVU5JVF9SRUdFWC5leGVjKHRpbWVBdHRyaWJ1dGVWYWx1ZSk7XG4gIGNvbnN0IHZhbHVlID0gTnVtYmVyKG1bMV0pO1xuICBjb25zdCB1bml0ID0gbVsyXTtcbiAgc3dpdGNoICh1bml0KSB7XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gdmFsdWUgKiAzNjAwO1xuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIHZhbHVlICogNjA7XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIHZhbHVlICogMTAwMDtcbiAgICBjYXNlICdmJzpcbiAgICAgIHJldHVybiB2YWx1ZSAvIHJhdGVJbmZvLmZyYW1lUmF0ZTtcbiAgICBjYXNlICd0JzpcbiAgICAgIHJldHVybiB2YWx1ZSAvIHJhdGVJbmZvLnRpY2tSYXRlO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuY2xhc3MgT3V0cHV0RmlsdGVyIHtcbiAgY29uc3RydWN0b3IodGltZWxpbmVDb250cm9sbGVyLCB0cmFja05hbWUpIHtcbiAgICB0aGlzLnRpbWVsaW5lQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLmN1ZVJhbmdlcyA9IFtdO1xuICAgIHRoaXMudHJhY2tOYW1lID0gdm9pZCAwO1xuICAgIHRoaXMuc3RhcnRUaW1lID0gbnVsbDtcbiAgICB0aGlzLmVuZFRpbWUgPSBudWxsO1xuICAgIHRoaXMuc2NyZWVuID0gbnVsbDtcbiAgICB0aGlzLnRpbWVsaW5lQ29udHJvbGxlciA9IHRpbWVsaW5lQ29udHJvbGxlcjtcbiAgICB0aGlzLnRyYWNrTmFtZSA9IHRyYWNrTmFtZTtcbiAgfVxuICBkaXNwYXRjaEN1ZSgpIHtcbiAgICBpZiAodGhpcy5zdGFydFRpbWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy50aW1lbGluZUNvbnRyb2xsZXIuYWRkQ3Vlcyh0aGlzLnRyYWNrTmFtZSwgdGhpcy5zdGFydFRpbWUsIHRoaXMuZW5kVGltZSwgdGhpcy5zY3JlZW4sIHRoaXMuY3VlUmFuZ2VzKTtcbiAgICB0aGlzLnN0YXJ0VGltZSA9IG51bGw7XG4gIH1cbiAgbmV3Q3VlKHN0YXJ0VGltZSwgZW5kVGltZSwgc2NyZWVuKSB7XG4gICAgaWYgKHRoaXMuc3RhcnRUaW1lID09PSBudWxsIHx8IHRoaXMuc3RhcnRUaW1lID4gc3RhcnRUaW1lKSB7XG4gICAgICB0aGlzLnN0YXJ0VGltZSA9IHN0YXJ0VGltZTtcbiAgICB9XG4gICAgdGhpcy5lbmRUaW1lID0gZW5kVGltZTtcbiAgICB0aGlzLnNjcmVlbiA9IHNjcmVlbjtcbiAgICB0aGlzLnRpbWVsaW5lQ29udHJvbGxlci5jcmVhdGVDYXB0aW9uc1RyYWNrKHRoaXMudHJhY2tOYW1lKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLmN1ZVJhbmdlcyA9IFtdO1xuICAgIHRoaXMuc3RhcnRUaW1lID0gbnVsbDtcbiAgfVxufVxuXG5jbGFzcyBUaW1lbGluZUNvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMuQ3VlcyA9IHZvaWQgMDtcbiAgICB0aGlzLnRleHRUcmFja3MgPSBbXTtcbiAgICB0aGlzLnRyYWNrcyA9IFtdO1xuICAgIHRoaXMuaW5pdFBUUyA9IFtdO1xuICAgIHRoaXMudW5wYXJzZWRWdHRGcmFncyA9IFtdO1xuICAgIHRoaXMuY2FwdGlvbnNUcmFja3MgPSB7fTtcbiAgICB0aGlzLm5vbk5hdGl2ZUNhcHRpb25zVHJhY2tzID0ge307XG4gICAgdGhpcy5jZWE2MDhQYXJzZXIxID0gdm9pZCAwO1xuICAgIHRoaXMuY2VhNjA4UGFyc2VyMiA9IHZvaWQgMDtcbiAgICB0aGlzLmxhc3RDYyA9IC0xO1xuICAgIC8vIExhc3QgdmlkZW8gKENFQS02MDgpIGZyYWdtZW50IENDXG4gICAgdGhpcy5sYXN0U24gPSAtMTtcbiAgICAvLyBMYXN0IHZpZGVvIChDRUEtNjA4KSBmcmFnbWVudCBNU05cbiAgICB0aGlzLmxhc3RQYXJ0SW5kZXggPSAtMTtcbiAgICAvLyBMYXN0IHZpZGVvIChDRUEtNjA4KSBmcmFnbWVudCBQYXJ0IEluZGV4XG4gICAgdGhpcy5wcmV2Q0MgPSAtMTtcbiAgICAvLyBMYXN0IHN1YnRpdGxlIGZyYWdtZW50IENDXG4gICAgdGhpcy52dHRDQ3MgPSBuZXdWVFRDQ3MoKTtcbiAgICB0aGlzLmNhcHRpb25zUHJvcGVydGllcyA9IHZvaWQgMDtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgdGhpcy5DdWVzID0gaGxzLmNvbmZpZy5jdWVIYW5kbGVyO1xuICAgIHRoaXMuY2FwdGlvbnNQcm9wZXJ0aWVzID0ge1xuICAgICAgdGV4dFRyYWNrMToge1xuICAgICAgICBsYWJlbDogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2sxTGFiZWwsXG4gICAgICAgIGxhbmd1YWdlQ29kZTogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2sxTGFuZ3VhZ2VDb2RlXG4gICAgICB9LFxuICAgICAgdGV4dFRyYWNrMjoge1xuICAgICAgICBsYWJlbDogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2syTGFiZWwsXG4gICAgICAgIGxhbmd1YWdlQ29kZTogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2syTGFuZ3VhZ2VDb2RlXG4gICAgICB9LFxuICAgICAgdGV4dFRyYWNrMzoge1xuICAgICAgICBsYWJlbDogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2szTGFiZWwsXG4gICAgICAgIGxhbmd1YWdlQ29kZTogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2szTGFuZ3VhZ2VDb2RlXG4gICAgICB9LFxuICAgICAgdGV4dFRyYWNrNDoge1xuICAgICAgICBsYWJlbDogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2s0TGFiZWwsXG4gICAgICAgIGxhbmd1YWdlQ29kZTogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2s0TGFuZ3VhZ2VDb2RlXG4gICAgICB9XG4gICAgfTtcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuU1VCVElUTEVfVFJBQ0tTX1VQREFURUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19MT0FESU5HLCB0aGlzLm9uRnJhZ0xvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19MT0FERUQsIHRoaXMub25GcmFnTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfUEFSU0lOR19VU0VSREFUQSwgdGhpcy5vbkZyYWdQYXJzaW5nVXNlcmRhdGEsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19ERUNSWVBURUQsIHRoaXMub25GcmFnRGVjcnlwdGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLklOSVRfUFRTX0ZPVU5ELCB0aGlzLm9uSW5pdFB0c0ZvdW5kLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLlNVQlRJVExFX1RSQUNLU19DTEVBUkVELCB0aGlzLm9uU3VidGl0bGVUcmFja3NDbGVhcmVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLlNVQlRJVExFX1RSQUNLU19VUERBVEVELCB0aGlzLm9uU3VidGl0bGVUcmFja3NVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0xPQURJTkcsIHRoaXMub25GcmFnTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19MT0FERUQsIHRoaXMub25GcmFnTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsIHRoaXMub25GcmFnUGFyc2luZ1VzZXJkYXRhLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0RFQ1JZUFRFRCwgdGhpcy5vbkZyYWdEZWNyeXB0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLklOSVRfUFRTX0ZPVU5ELCB0aGlzLm9uSW5pdFB0c0ZvdW5kLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5TVUJUSVRMRV9UUkFDS1NfQ0xFQVJFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tzQ2xlYXJlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0ZMVVNISU5HLCB0aGlzLm9uQnVmZmVyRmx1c2hpbmcsIHRoaXMpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmhscyA9IHRoaXMuY29uZmlnID0gdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5jZWE2MDhQYXJzZXIxID0gdGhpcy5jZWE2MDhQYXJzZXIyID0gdW5kZWZpbmVkO1xuICB9XG4gIGluaXRDZWE2MDhQYXJzZXJzKCkge1xuICAgIGNvbnN0IGNoYW5uZWwxID0gbmV3IE91dHB1dEZpbHRlcih0aGlzLCAndGV4dFRyYWNrMScpO1xuICAgIGNvbnN0IGNoYW5uZWwyID0gbmV3IE91dHB1dEZpbHRlcih0aGlzLCAndGV4dFRyYWNrMicpO1xuICAgIGNvbnN0IGNoYW5uZWwzID0gbmV3IE91dHB1dEZpbHRlcih0aGlzLCAndGV4dFRyYWNrMycpO1xuICAgIGNvbnN0IGNoYW5uZWw0ID0gbmV3IE91dHB1dEZpbHRlcih0aGlzLCAndGV4dFRyYWNrNCcpO1xuICAgIHRoaXMuY2VhNjA4UGFyc2VyMSA9IG5ldyBDZWE2MDhQYXJzZXIoMSwgY2hhbm5lbDEsIGNoYW5uZWwyKTtcbiAgICB0aGlzLmNlYTYwOFBhcnNlcjIgPSBuZXcgQ2VhNjA4UGFyc2VyKDMsIGNoYW5uZWwzLCBjaGFubmVsNCk7XG4gIH1cbiAgYWRkQ3Vlcyh0cmFja05hbWUsIHN0YXJ0VGltZSwgZW5kVGltZSwgc2NyZWVuLCBjdWVSYW5nZXMpIHtcbiAgICAvLyBza2lwIGN1ZXMgd2hpY2ggb3ZlcmxhcCBtb3JlIHRoYW4gNTAlIHdpdGggcHJldmlvdXNseSBwYXJzZWQgdGltZSByYW5nZXNcbiAgICBsZXQgbWVyZ2VkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IGN1ZVJhbmdlcy5sZW5ndGg7IGktLTspIHtcbiAgICAgIGNvbnN0IGN1ZVJhbmdlID0gY3VlUmFuZ2VzW2ldO1xuICAgICAgY29uc3Qgb3ZlcmxhcCA9IGludGVyc2VjdGlvbihjdWVSYW5nZVswXSwgY3VlUmFuZ2VbMV0sIHN0YXJ0VGltZSwgZW5kVGltZSk7XG4gICAgICBpZiAob3ZlcmxhcCA+PSAwKSB7XG4gICAgICAgIGN1ZVJhbmdlWzBdID0gTWF0aC5taW4oY3VlUmFuZ2VbMF0sIHN0YXJ0VGltZSk7XG4gICAgICAgIGN1ZVJhbmdlWzFdID0gTWF0aC5tYXgoY3VlUmFuZ2VbMV0sIGVuZFRpbWUpO1xuICAgICAgICBtZXJnZWQgPSB0cnVlO1xuICAgICAgICBpZiAob3ZlcmxhcCAvIChlbmRUaW1lIC0gc3RhcnRUaW1lKSA+IDAuNSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW1lcmdlZCkge1xuICAgICAgY3VlUmFuZ2VzLnB1c2goW3N0YXJ0VGltZSwgZW5kVGltZV0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb25maWcucmVuZGVyVGV4dFRyYWNrc05hdGl2ZWx5KSB7XG4gICAgICBjb25zdCB0cmFjayA9IHRoaXMuY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXTtcbiAgICAgIHRoaXMuQ3Vlcy5uZXdDdWUodHJhY2ssIHN0YXJ0VGltZSwgZW5kVGltZSwgc2NyZWVuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY3VlcyA9IHRoaXMuQ3Vlcy5uZXdDdWUobnVsbCwgc3RhcnRUaW1lLCBlbmRUaW1lLCBzY3JlZW4pO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQ1VFU19QQVJTRUQsIHtcbiAgICAgICAgdHlwZTogJ2NhcHRpb25zJyxcbiAgICAgICAgY3VlcyxcbiAgICAgICAgdHJhY2s6IHRyYWNrTmFtZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gVHJpZ2dlcmVkIHdoZW4gYW4gaW5pdGlhbCBQVFMgaXMgZm91bmQ7IHVzZWQgZm9yIHN5bmNocm9uaXNhdGlvbiBvZiBXZWJWVFQuXG4gIG9uSW5pdFB0c0ZvdW5kKGV2ZW50LCB7XG4gICAgZnJhZyxcbiAgICBpZCxcbiAgICBpbml0UFRTLFxuICAgIHRpbWVzY2FsZVxuICB9KSB7XG4gICAgY29uc3Qge1xuICAgICAgdW5wYXJzZWRWdHRGcmFnc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmIChpZCA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTikge1xuICAgICAgdGhpcy5pbml0UFRTW2ZyYWcuY2NdID0ge1xuICAgICAgICBiYXNlVGltZTogaW5pdFBUUyxcbiAgICAgICAgdGltZXNjYWxlXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIER1ZSB0byBhc3luY2hyb25vdXMgcHJvY2Vzc2luZywgaW5pdGlhbCBQVFMgbWF5IGFycml2ZSBsYXRlciB0aGFuIHRoZSBmaXJzdCBWVFQgZnJhZ21lbnRzIGFyZSBsb2FkZWQuXG4gICAgLy8gUGFyc2UgYW55IHVucGFyc2VkIGZyYWdtZW50cyB1cG9uIHJlY2VpdmluZyB0aGUgaW5pdGlhbCBQVFMuXG4gICAgaWYgKHVucGFyc2VkVnR0RnJhZ3MubGVuZ3RoKSB7XG4gICAgICB0aGlzLnVucGFyc2VkVnR0RnJhZ3MgPSBbXTtcbiAgICAgIHVucGFyc2VkVnR0RnJhZ3MuZm9yRWFjaChkYXRhID0+IHtcbiAgICAgICAgaWYgKHRoaXMuaW5pdFBUU1tkYXRhLmZyYWcuY2NdKSB7XG4gICAgICAgICAgdGhpcy5vbkZyYWdMb2FkZWQoRXZlbnRzLkZSQUdfTE9BREVELCBkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBmcmFnOiBkYXRhLmZyYWcsXG4gICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKCdTdWJ0aXRsZSBkaXNjb250aW51aXR5IGRvbWFpbiBkb2VzIG5vdCBtYXRjaCBtYWluJylcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldEV4aXN0aW5nVHJhY2sobGFiZWwsIGxhbmd1YWdlKSB7XG4gICAgY29uc3Qge1xuICAgICAgbWVkaWFcbiAgICB9ID0gdGhpcztcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVkaWEudGV4dFRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB0ZXh0VHJhY2sgPSBtZWRpYS50ZXh0VHJhY2tzW2ldO1xuICAgICAgICBpZiAoY2FuUmV1c2VWdHRUZXh0VHJhY2sodGV4dFRyYWNrLCB7XG4gICAgICAgICAgbmFtZTogbGFiZWwsXG4gICAgICAgICAgbGFuZzogbGFuZ3VhZ2UsXG4gICAgICAgICAgY2hhcmFjdGVyaXN0aWNzOiAndHJhbnNjcmliZXMtc3Bva2VuLWRpYWxvZyxkZXNjcmliZXMtbXVzaWMtYW5kLXNvdW5kJ30pKSB7XG4gICAgICAgICAgcmV0dXJuIHRleHRUcmFjaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjcmVhdGVDYXB0aW9uc1RyYWNrKHRyYWNrTmFtZSkge1xuICAgIGlmICh0aGlzLmNvbmZpZy5yZW5kZXJUZXh0VHJhY2tzTmF0aXZlbHkpIHtcbiAgICAgIHRoaXMuY3JlYXRlTmF0aXZlVHJhY2sodHJhY2tOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jcmVhdGVOb25OYXRpdmVUcmFjayh0cmFja05hbWUpO1xuICAgIH1cbiAgfVxuICBjcmVhdGVOYXRpdmVUcmFjayh0cmFja05hbWUpIHtcbiAgICBpZiAodGhpcy5jYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNhcHRpb25zUHJvcGVydGllcyxcbiAgICAgIGNhcHRpb25zVHJhY2tzLFxuICAgICAgbWVkaWFcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBsYWJlbCxcbiAgICAgIGxhbmd1YWdlQ29kZVxuICAgIH0gPSBjYXB0aW9uc1Byb3BlcnRpZXNbdHJhY2tOYW1lXTtcbiAgICAvLyBFbmFibGUgcmV1c2Ugb2YgZXhpc3RpbmcgdGV4dCB0cmFjay5cbiAgICBjb25zdCBleGlzdGluZ1RyYWNrID0gdGhpcy5nZXRFeGlzdGluZ1RyYWNrKGxhYmVsLCBsYW5ndWFnZUNvZGUpO1xuICAgIGlmICghZXhpc3RpbmdUcmFjaykge1xuICAgICAgY29uc3QgdGV4dFRyYWNrID0gdGhpcy5jcmVhdGVUZXh0VHJhY2soJ2NhcHRpb25zJywgbGFiZWwsIGxhbmd1YWdlQ29kZSk7XG4gICAgICBpZiAodGV4dFRyYWNrKSB7XG4gICAgICAgIC8vIFNldCBhIHNwZWNpYWwgcHJvcGVydHkgb24gdGhlIHRyYWNrIHNvIHdlIGtub3cgaXQncyBtYW5hZ2VkIGJ5IEhscy5qc1xuICAgICAgICB0ZXh0VHJhY2tbdHJhY2tOYW1lXSA9IHRydWU7XG4gICAgICAgIGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0gPSB0ZXh0VHJhY2s7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0gPSBleGlzdGluZ1RyYWNrO1xuICAgICAgY2xlYXJDdXJyZW50Q3VlcyhjYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdKTtcbiAgICAgIHNlbmRBZGRUcmFja0V2ZW50KGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0sIG1lZGlhKTtcbiAgICB9XG4gIH1cbiAgY3JlYXRlTm9uTmF0aXZlVHJhY2sodHJhY2tOYW1lKSB7XG4gICAgaWYgKHRoaXMubm9uTmF0aXZlQ2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgYSBsaXN0IG9mIGEgc2luZ2xlIHRyYWNrIGZvciB0aGUgcHJvdmlkZXIgdG8gY29uc3VtZVxuICAgIGNvbnN0IHRyYWNrUHJvcGVydGllcyA9IHRoaXMuY2FwdGlvbnNQcm9wZXJ0aWVzW3RyYWNrTmFtZV07XG4gICAgaWYgKCF0cmFja1Byb3BlcnRpZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGFiZWwgPSB0cmFja1Byb3BlcnRpZXMubGFiZWw7XG4gICAgY29uc3QgdHJhY2sgPSB7XG4gICAgICBfaWQ6IHRyYWNrTmFtZSxcbiAgICAgIGxhYmVsLFxuICAgICAga2luZDogJ2NhcHRpb25zJyxcbiAgICAgIGRlZmF1bHQ6IHRyYWNrUHJvcGVydGllcy5tZWRpYSA/ICEhdHJhY2tQcm9wZXJ0aWVzLm1lZGlhLmRlZmF1bHQgOiBmYWxzZSxcbiAgICAgIGNsb3NlZENhcHRpb25zOiB0cmFja1Byb3BlcnRpZXMubWVkaWFcbiAgICB9O1xuICAgIHRoaXMubm9uTmF0aXZlQ2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSA9IHRyYWNrO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLk5PTl9OQVRJVkVfVEVYVF9UUkFDS1NfRk9VTkQsIHtcbiAgICAgIHRyYWNrczogW3RyYWNrXVxuICAgIH0pO1xuICB9XG4gIGNyZWF0ZVRleHRUcmFjayhraW5kLCBsYWJlbCwgbGFuZykge1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAoIW1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBtZWRpYS5hZGRUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmcpO1xuICB9XG4gIG9uTWVkaWFBdHRhY2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICBpZiAoIWRhdGEubWVkaWFTb3VyY2UpIHtcbiAgICAgIHRoaXMuX2NsZWFuVHJhY2tzKCk7XG4gICAgfVxuICB9XG4gIG9uTWVkaWFEZXRhY2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB0cmFuc2ZlcnJpbmdNZWRpYSA9ICEhZGF0YS50cmFuc2Zlck1lZGlhO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIGlmICh0cmFuc2ZlcnJpbmdNZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjYXB0aW9uc1RyYWNrc1xuICAgIH0gPSB0aGlzO1xuICAgIE9iamVjdC5rZXlzKGNhcHRpb25zVHJhY2tzKS5mb3JFYWNoKHRyYWNrTmFtZSA9PiB7XG4gICAgICBjbGVhckN1cnJlbnRDdWVzKGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0pO1xuICAgICAgZGVsZXRlIGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV07XG4gICAgfSk7XG4gICAgdGhpcy5ub25OYXRpdmVDYXB0aW9uc1RyYWNrcyA9IHt9O1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIC8vIERldGVjdCBkaXNjb250aW51aXR5IGluIHZpZGVvIGZyYWdtZW50IChDRUEtNjA4KSBwYXJzaW5nXG4gICAgdGhpcy5sYXN0Q2MgPSAtMTtcbiAgICB0aGlzLmxhc3RTbiA9IC0xO1xuICAgIHRoaXMubGFzdFBhcnRJbmRleCA9IC0xO1xuICAgIC8vIERldGVjdCBkaXNjb250aW51aXR5IGluIHN1YnRpdGxlIG1hbmlmZXN0c1xuICAgIHRoaXMucHJldkNDID0gLTE7XG4gICAgdGhpcy52dHRDQ3MgPSBuZXdWVFRDQ3MoKTtcbiAgICAvLyBSZXNldCB0cmFja3NcbiAgICB0aGlzLl9jbGVhblRyYWNrcygpO1xuICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgdGhpcy5jYXB0aW9uc1RyYWNrcyA9IHt9O1xuICAgIHRoaXMubm9uTmF0aXZlQ2FwdGlvbnNUcmFja3MgPSB7fTtcbiAgICB0aGlzLnRleHRUcmFja3MgPSBbXTtcbiAgICB0aGlzLnVucGFyc2VkVnR0RnJhZ3MgPSBbXTtcbiAgICB0aGlzLmluaXRQVFMgPSBbXTtcbiAgICBpZiAodGhpcy5jZWE2MDhQYXJzZXIxICYmIHRoaXMuY2VhNjA4UGFyc2VyMikge1xuICAgICAgdGhpcy5jZWE2MDhQYXJzZXIxLnJlc2V0KCk7XG4gICAgICB0aGlzLmNlYTYwOFBhcnNlcjIucmVzZXQoKTtcbiAgICB9XG4gIH1cbiAgX2NsZWFuVHJhY2tzKCkge1xuICAgIC8vIGNsZWFyIG91dGRhdGVkIHN1YnRpdGxlc1xuICAgIGNvbnN0IHtcbiAgICAgIG1lZGlhXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0VHJhY2tzID0gbWVkaWEudGV4dFRyYWNrcztcbiAgICBpZiAodGV4dFRyYWNrcykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0VHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNsZWFyQ3VycmVudEN1ZXModGV4dFRyYWNrc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG9uU3VidGl0bGVUcmFja3NVcGRhdGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3QgdHJhY2tzID0gZGF0YS5zdWJ0aXRsZVRyYWNrcyB8fCBbXTtcbiAgICBjb25zdCBoYXNJTVNDMSA9IHRyYWNrcy5zb21lKHRyYWNrID0+IHRyYWNrLnRleHRDb2RlYyA9PT0gSU1TQzFfQ09ERUMpO1xuICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVXZWJWVFQgfHwgaGFzSU1TQzEgJiYgdGhpcy5jb25maWcuZW5hYmxlSU1TQzEpIHtcbiAgICAgIGNvbnN0IGxpc3RJc0lkZW50aWNhbCA9IHN1YnRpdGxlT3B0aW9uc0lkZW50aWNhbCh0aGlzLnRyYWNrcywgdHJhY2tzKTtcbiAgICAgIGlmIChsaXN0SXNJZGVudGljYWwpIHtcbiAgICAgICAgdGhpcy50cmFja3MgPSB0cmFja3M7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMudGV4dFRyYWNrcyA9IFtdO1xuICAgICAgdGhpcy50cmFja3MgPSB0cmFja3M7XG4gICAgICBpZiAodGhpcy5jb25maWcucmVuZGVyVGV4dFRyYWNrc05hdGl2ZWx5KSB7XG4gICAgICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgICAgY29uc3QgaW5Vc2VUcmFja3MgPSBtZWRpYSA/IGZpbHRlclN1YnRpdGxlVHJhY2tzKG1lZGlhLnRleHRUcmFja3MpIDogbnVsbDtcbiAgICAgICAgdGhpcy50cmFja3MuZm9yRWFjaCgodHJhY2ssIGluZGV4KSA9PiB7XG4gICAgICAgICAgLy8gUmV1c2UgdHJhY2tzIHdpdGggdGhlIHNhbWUgbGFiZWwgYW5kIGxhbmcsIGJ1dCBkbyBub3QgcmV1c2UgNjA4LzcwOCB0cmFja3NcbiAgICAgICAgICBsZXQgdGV4dFRyYWNrO1xuICAgICAgICAgIGlmIChpblVzZVRyYWNrcykge1xuICAgICAgICAgICAgbGV0IGluVXNlVHJhY2sgPSBudWxsO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpblVzZVRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoaW5Vc2VUcmFja3NbaV0gJiYgY2FuUmV1c2VWdHRUZXh0VHJhY2soaW5Vc2VUcmFja3NbaV0sIHRyYWNrKSkge1xuICAgICAgICAgICAgICAgIGluVXNlVHJhY2sgPSBpblVzZVRyYWNrc1tpXTtcbiAgICAgICAgICAgICAgICBpblVzZVRyYWNrc1tpXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpblVzZVRyYWNrKSB7XG4gICAgICAgICAgICAgIHRleHRUcmFjayA9IGluVXNlVHJhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0ZXh0VHJhY2spIHtcbiAgICAgICAgICAgIGNsZWFyQ3VycmVudEN1ZXModGV4dFRyYWNrKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdGV4dFRyYWNrS2luZCA9IGNhcHRpb25zT3JTdWJ0aXRsZXNGcm9tQ2hhcmFjdGVyaXN0aWNzKHRyYWNrKTtcbiAgICAgICAgICAgIHRleHRUcmFjayA9IHRoaXMuY3JlYXRlVGV4dFRyYWNrKHRleHRUcmFja0tpbmQsIHRyYWNrLm5hbWUsIHRyYWNrLmxhbmcpO1xuICAgICAgICAgICAgaWYgKHRleHRUcmFjaykge1xuICAgICAgICAgICAgICB0ZXh0VHJhY2subW9kZSA9ICdkaXNhYmxlZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0ZXh0VHJhY2spIHtcbiAgICAgICAgICAgIHRoaXMudGV4dFRyYWNrcy5wdXNoKHRleHRUcmFjayk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gV2FybiB3aGVuIHZpZGVvIGVsZW1lbnQgaGFzIGNhcHRpb25zIG9yIHN1YnRpdGxlIFRleHRUcmFja3MgY2FycmllZCBvdmVyIGZyb20gYW5vdGhlciBzb3VyY2VcbiAgICAgICAgaWYgKGluVXNlVHJhY2tzICE9IG51bGwgJiYgaW5Vc2VUcmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgdW51c2VkVGV4dFRyYWNrcyA9IGluVXNlVHJhY2tzLmZpbHRlcih0ID0+IHQgIT09IG51bGwpLm1hcCh0ID0+IHQubGFiZWwpO1xuICAgICAgICAgIGlmICh1bnVzZWRUZXh0VHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5obHMubG9nZ2VyLndhcm4oYE1lZGlhIGVsZW1lbnQgY29udGFpbnMgdW51c2VkIHN1YnRpdGxlIHRyYWNrczogJHt1bnVzZWRUZXh0VHJhY2tzLmpvaW4oJywgJyl9LiBSZXBsYWNlIG1lZGlhIGVsZW1lbnQgZm9yIGVhY2ggc291cmNlIHRvIGNsZWFyIFRleHRUcmFja3MgYW5kIGNhcHRpb25zIG1lbnUuYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAvLyBDcmVhdGUgYSBsaXN0IG9mIHRyYWNrcyBmb3IgdGhlIHByb3ZpZGVyIHRvIGNvbnN1bWVcbiAgICAgICAgY29uc3QgdHJhY2tzTGlzdCA9IHRoaXMudHJhY2tzLm1hcCh0cmFjayA9PiB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxhYmVsOiB0cmFjay5uYW1lLFxuICAgICAgICAgICAga2luZDogdHJhY2sudHlwZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgZGVmYXVsdDogdHJhY2suZGVmYXVsdCxcbiAgICAgICAgICAgIHN1YnRpdGxlVHJhY2s6IHRyYWNrXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLk5PTl9OQVRJVkVfVEVYVF9UUkFDS1NfRk9VTkQsIHtcbiAgICAgICAgICB0cmFja3M6IHRyYWNrc0xpc3RcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG9uTWFuaWZlc3RMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlQ0VBNzA4Q2FwdGlvbnMgJiYgZGF0YS5jYXB0aW9ucykge1xuICAgICAgZGF0YS5jYXB0aW9ucy5mb3JFYWNoKGNhcHRpb25zVHJhY2sgPT4ge1xuICAgICAgICBjb25zdCBpbnN0cmVhbUlkTWF0Y2ggPSAvKD86Q0N8U0VSVklDRSkoWzEtNF0pLy5leGVjKGNhcHRpb25zVHJhY2suaW5zdHJlYW1JZCk7XG4gICAgICAgIGlmICghaW5zdHJlYW1JZE1hdGNoKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYWNrTmFtZSA9IGB0ZXh0VHJhY2ske2luc3RyZWFtSWRNYXRjaFsxXX1gO1xuICAgICAgICBjb25zdCB0cmFja1Byb3BlcnRpZXMgPSB0aGlzLmNhcHRpb25zUHJvcGVydGllc1t0cmFja05hbWVdO1xuICAgICAgICBpZiAoIXRyYWNrUHJvcGVydGllcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cmFja1Byb3BlcnRpZXMubGFiZWwgPSBjYXB0aW9uc1RyYWNrLm5hbWU7XG4gICAgICAgIGlmIChjYXB0aW9uc1RyYWNrLmxhbmcpIHtcbiAgICAgICAgICAvLyBvcHRpb25hbCBhdHRyaWJ1dGVcbiAgICAgICAgICB0cmFja1Byb3BlcnRpZXMubGFuZ3VhZ2VDb2RlID0gY2FwdGlvbnNUcmFjay5sYW5nO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNrUHJvcGVydGllcy5tZWRpYSA9IGNhcHRpb25zVHJhY2s7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgY2xvc2VkQ2FwdGlvbnNGb3JMZXZlbChmcmFnKSB7XG4gICAgY29uc3QgbGV2ZWwgPSB0aGlzLmhscy5sZXZlbHNbZnJhZy5sZXZlbF07XG4gICAgcmV0dXJuIGxldmVsID09IG51bGwgPyB2b2lkIDAgOiBsZXZlbC5hdHRyc1snQ0xPU0VELUNBUFRJT05TJ107XG4gIH1cbiAgb25GcmFnTG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgIC8vIGlmIHRoaXMgZnJhZyBpc24ndCBjb250aWd1b3VzLCBjbGVhciB0aGUgcGFyc2VyIHNvIGN1ZXMgd2l0aCBiYWQgc3RhcnQvZW5kIHRpbWVzIGFyZW4ndCBhZGRlZCB0byB0aGUgdGV4dFRyYWNrXG4gICAgaWYgKHRoaXMuZW5hYmxlZCAmJiBkYXRhLmZyYWcudHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTikge1xuICAgICAgdmFyIF9kYXRhJHBhcnQkaW5kZXgsIF9kYXRhJHBhcnQ7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNlYTYwOFBhcnNlcjEsXG4gICAgICAgIGNlYTYwOFBhcnNlcjIsXG4gICAgICAgIGxhc3RTblxuICAgICAgfSA9IHRoaXM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNjLFxuICAgICAgICBzblxuICAgICAgfSA9IGRhdGEuZnJhZztcbiAgICAgIGNvbnN0IHBhcnRJbmRleCA9IChfZGF0YSRwYXJ0JGluZGV4ID0gKF9kYXRhJHBhcnQgPSBkYXRhLnBhcnQpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YSRwYXJ0LmluZGV4KSAhPSBudWxsID8gX2RhdGEkcGFydCRpbmRleCA6IC0xO1xuICAgICAgaWYgKGNlYTYwOFBhcnNlcjEgJiYgY2VhNjA4UGFyc2VyMikge1xuICAgICAgICBpZiAoc24gIT09IGxhc3RTbiArIDEgfHwgc24gPT09IGxhc3RTbiAmJiBwYXJ0SW5kZXggIT09IHRoaXMubGFzdFBhcnRJbmRleCArIDEgfHwgY2MgIT09IHRoaXMubGFzdENjKSB7XG4gICAgICAgICAgY2VhNjA4UGFyc2VyMS5yZXNldCgpO1xuICAgICAgICAgIGNlYTYwOFBhcnNlcjIucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5sYXN0Q2MgPSBjYztcbiAgICAgIHRoaXMubGFzdFNuID0gc247XG4gICAgICB0aGlzLmxhc3RQYXJ0SW5kZXggPSBwYXJ0SW5kZXg7XG4gICAgfVxuICB9XG4gIG9uRnJhZ0xvYWRlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWcsXG4gICAgICBwYXlsb2FkXG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKGZyYWcudHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuU1VCVElUTEUpIHtcbiAgICAgIC8vIElmIGZyYWdtZW50IGlzIHN1YnRpdGxlIHR5cGUsIHBhcnNlIGFzIFdlYlZUVC5cbiAgICAgIGlmIChwYXlsb2FkLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZGVjcnlwdERhdGEgPSBmcmFnLmRlY3J5cHRkYXRhO1xuICAgICAgICAvLyBmcmFnbWVudCBhZnRlciBkZWNyeXB0aW9uIGhhcyBhIHN0YXRzIG9iamVjdFxuICAgICAgICBjb25zdCBkZWNyeXB0ZWQgPSAnc3RhdHMnIGluIGRhdGE7XG4gICAgICAgIC8vIElmIHRoZSBzdWJ0aXRsZXMgYXJlIG5vdCBlbmNyeXB0ZWQsIHBhcnNlIFZUVHMgbm93LiBPdGhlcndpc2UsIHdlIG5lZWQgdG8gd2FpdC5cbiAgICAgICAgaWYgKGRlY3J5cHREYXRhID09IG51bGwgfHwgIWRlY3J5cHREYXRhLmVuY3J5cHRlZCB8fCBkZWNyeXB0ZWQpIHtcbiAgICAgICAgICBjb25zdCB0cmFja1BsYXlsaXN0TWVkaWEgPSB0aGlzLnRyYWNrc1tmcmFnLmxldmVsXTtcbiAgICAgICAgICBjb25zdCB2dHRDQ3MgPSB0aGlzLnZ0dENDcztcbiAgICAgICAgICBpZiAoIXZ0dENDc1tmcmFnLmNjXSkge1xuICAgICAgICAgICAgdnR0Q0NzW2ZyYWcuY2NdID0ge1xuICAgICAgICAgICAgICBzdGFydDogZnJhZy5zdGFydCxcbiAgICAgICAgICAgICAgcHJldkNDOiB0aGlzLnByZXZDQyxcbiAgICAgICAgICAgICAgbmV3OiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5wcmV2Q0MgPSBmcmFnLmNjO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHJhY2tQbGF5bGlzdE1lZGlhICYmIHRyYWNrUGxheWxpc3RNZWRpYS50ZXh0Q29kZWMgPT09IElNU0MxX0NPREVDKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZUlNU0MxKGZyYWcsIHBheWxvYWQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZVZUVHMoZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJbiBjYXNlIHRoZXJlIGlzIG5vIHBheWxvYWQsIGZpbmlzaCB1bnN1Y2Nlc3NmdWxseS5cbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBmcmFnLFxuICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3IoJ0VtcHR5IHN1YnRpdGxlIHBheWxvYWQnKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3BhcnNlSU1TQzEoZnJhZywgcGF5bG9hZCkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIHBhcnNlSU1TQzEocGF5bG9hZCwgdGhpcy5pbml0UFRTW2ZyYWcuY2NdLCBjdWVzID0+IHtcbiAgICAgIHRoaXMuX2FwcGVuZEN1ZXMoY3VlcywgZnJhZy5sZXZlbCk7XG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZnJhZzogZnJhZ1xuICAgICAgfSk7XG4gICAgfSwgZXJyb3IgPT4ge1xuICAgICAgaGxzLmxvZ2dlci5sb2coYEZhaWxlZCB0byBwYXJzZSBJTVNDMTogJHtlcnJvcn1gKTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgZXJyb3JcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIF9wYXJzZVZUVHMoZGF0YSkge1xuICAgIHZhciBfZnJhZyRpbml0U2VnbWVudDtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnLFxuICAgICAgcGF5bG9hZFxuICAgIH0gPSBkYXRhO1xuICAgIC8vIFdlIG5lZWQgYW4gaW5pdGlhbCBzeW5jaHJvbmlzYXRpb24gUFRTLiBTdG9yZSBmcmFnbWVudHMgYXMgbG9uZyBhcyBub25lIGhhcyBhcnJpdmVkXG4gICAgY29uc3Qge1xuICAgICAgaW5pdFBUUyxcbiAgICAgIHVucGFyc2VkVnR0RnJhZ3NcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBtYXhBdkNDID0gaW5pdFBUUy5sZW5ndGggLSAxO1xuICAgIGlmICghaW5pdFBUU1tmcmFnLmNjXSAmJiBtYXhBdkNDID09PSAtMSkge1xuICAgICAgdW5wYXJzZWRWdHRGcmFncy5wdXNoKGRhdGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICAvLyBQYXJzZSB0aGUgV2ViVlRUIGZpbGUgY29udGVudHMuXG4gICAgY29uc3QgcGF5bG9hZFdlYlZUVCA9IChfZnJhZyRpbml0U2VnbWVudCA9IGZyYWcuaW5pdFNlZ21lbnQpICE9IG51bGwgJiYgX2ZyYWckaW5pdFNlZ21lbnQuZGF0YSA/IGFwcGVuZFVpbnQ4QXJyYXkoZnJhZy5pbml0U2VnbWVudC5kYXRhLCBuZXcgVWludDhBcnJheShwYXlsb2FkKSkuYnVmZmVyIDogcGF5bG9hZDtcbiAgICBwYXJzZVdlYlZUVChwYXlsb2FkV2ViVlRULCB0aGlzLmluaXRQVFNbZnJhZy5jY10sIHRoaXMudnR0Q0NzLCBmcmFnLmNjLCBmcmFnLnN0YXJ0LCBjdWVzID0+IHtcbiAgICAgIHRoaXMuX2FwcGVuZEN1ZXMoY3VlcywgZnJhZy5sZXZlbCk7XG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZnJhZzogZnJhZ1xuICAgICAgfSk7XG4gICAgfSwgZXJyb3IgPT4ge1xuICAgICAgY29uc3QgbWlzc2luZ0luaXRQVFMgPSBlcnJvci5tZXNzYWdlID09PSAnTWlzc2luZyBpbml0UFRTIGZvciBWVFQgTVBFR1RTJztcbiAgICAgIGlmIChtaXNzaW5nSW5pdFBUUykge1xuICAgICAgICB1bnBhcnNlZFZ0dEZyYWdzLnB1c2goZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9mYWxsYmFja1RvSU1TQzEoZnJhZywgcGF5bG9hZCk7XG4gICAgICB9XG4gICAgICAvLyBTb21ldGhpbmcgd2VudCB3cm9uZyB3aGlsZSBwYXJzaW5nLiBUcmlnZ2VyIGV2ZW50IHdpdGggc3VjY2VzcyBmYWxzZS5cbiAgICAgIGhscy5sb2dnZXIubG9nKGBGYWlsZWQgdG8gcGFyc2UgVlRUIGN1ZTogJHtlcnJvcn1gKTtcbiAgICAgIGlmIChtaXNzaW5nSW5pdFBUUyAmJiBtYXhBdkNDID4gZnJhZy5jYykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgIGVycm9yXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfZmFsbGJhY2tUb0lNU0MxKGZyYWcsIHBheWxvYWQpIHtcbiAgICAvLyBJZiB0ZXh0Q29kZWMgaXMgdW5rbm93biwgdHJ5IHBhcnNpbmcgYXMgSU1TQzEuIFNldCB0ZXh0Q29kZWMgYmFzZWQgb24gdGhlIHJlc3VsdFxuICAgIGNvbnN0IHRyYWNrUGxheWxpc3RNZWRpYSA9IHRoaXMudHJhY2tzW2ZyYWcubGV2ZWxdO1xuICAgIGlmICghdHJhY2tQbGF5bGlzdE1lZGlhLnRleHRDb2RlYykge1xuICAgICAgcGFyc2VJTVNDMShwYXlsb2FkLCB0aGlzLmluaXRQVFNbZnJhZy5jY10sICgpID0+IHtcbiAgICAgICAgdHJhY2tQbGF5bGlzdE1lZGlhLnRleHRDb2RlYyA9IElNU0MxX0NPREVDO1xuICAgICAgICB0aGlzLl9wYXJzZUlNU0MxKGZyYWcsIHBheWxvYWQpO1xuICAgICAgfSwgKCkgPT4ge1xuICAgICAgICB0cmFja1BsYXlsaXN0TWVkaWEudGV4dENvZGVjID0gJ3d2dHQnO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIF9hcHBlbmRDdWVzKGN1ZXMsIGZyYWdMZXZlbCkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGlmICh0aGlzLmNvbmZpZy5yZW5kZXJUZXh0VHJhY2tzTmF0aXZlbHkpIHtcbiAgICAgIGNvbnN0IHRleHRUcmFjayA9IHRoaXMudGV4dFRyYWNrc1tmcmFnTGV2ZWxdO1xuICAgICAgLy8gV2ViVlRUUGFyc2VyLnBhcnNlIGlzIGFuIGFzeW5jIG1ldGhvZCBhbmQgaWYgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCB0ZXh0IHRyYWNrIG1vZGUgaXMgc2V0IHRvIFwiZGlzYWJsZWRcIlxuICAgICAgLy8gYmVmb3JlIHBhcnNpbmcgaXMgZG9uZSB0aGVuIGRvbid0IHRyeSB0byBhY2Nlc3MgY3VycmVudFRyYWNrLmN1ZXMuZ2V0Q3VlQnlJZCBhcyBjdWVzIHdpbGwgYmUgbnVsbFxuICAgICAgLy8gYW5kIHRyeWluZyB0byBhY2Nlc3MgZ2V0Q3VlQnlJZCBtZXRob2Qgb2YgY3VlcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvblxuICAgICAgLy8gQmVjYXVzZSB3ZSBjaGVjayBpZiB0aGUgbW9kZSBpcyBkaXNhYmxlZCwgd2UgY2FuIGZvcmNlIGNoZWNrIGBjdWVzYCBiZWxvdy4gVGhleSBjYW4ndCBiZSBudWxsLlxuICAgICAgaWYgKCF0ZXh0VHJhY2sgfHwgdGV4dFRyYWNrLm1vZGUgPT09ICdkaXNhYmxlZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3Vlcy5mb3JFYWNoKGN1ZSA9PiBhZGRDdWVUb1RyYWNrKHRleHRUcmFjaywgY3VlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRUcmFjayA9IHRoaXMudHJhY2tzW2ZyYWdMZXZlbF07XG4gICAgICBpZiAoIWN1cnJlbnRUcmFjaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB0cmFjayA9IGN1cnJlbnRUcmFjay5kZWZhdWx0ID8gJ2RlZmF1bHQnIDogJ3N1YnRpdGxlcycgKyBmcmFnTGV2ZWw7XG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuQ1VFU19QQVJTRUQsIHtcbiAgICAgICAgdHlwZTogJ3N1YnRpdGxlcycsXG4gICAgICAgIGN1ZXMsXG4gICAgICAgIHRyYWNrXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgb25GcmFnRGVjcnlwdGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZ1xuICAgIH0gPSBkYXRhO1xuICAgIGlmIChmcmFnLnR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLlNVQlRJVExFKSB7XG4gICAgICB0aGlzLm9uRnJhZ0xvYWRlZChFdmVudHMuRlJBR19MT0FERUQsIGRhdGEpO1xuICAgIH1cbiAgfVxuICBvblN1YnRpdGxlVHJhY2tzQ2xlYXJlZCgpIHtcbiAgICB0aGlzLnRyYWNrcyA9IFtdO1xuICAgIHRoaXMuY2FwdGlvbnNUcmFja3MgPSB7fTtcbiAgfVxuICBvbkZyYWdQYXJzaW5nVXNlcmRhdGEoZXZlbnQsIGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZCB8fCAhdGhpcy5jb25maWcuZW5hYmxlQ0VBNzA4Q2FwdGlvbnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIHNhbXBsZXNcbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoZnJhZy50eXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOICYmIHRoaXMuY2xvc2VkQ2FwdGlvbnNGb3JMZXZlbChmcmFnKSA9PT0gJ05PTkUnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIElmIHRoZSBldmVudCBjb250YWlucyBjYXB0aW9ucyAoZm91bmQgaW4gdGhlIGJ5dGVzIHByb3BlcnR5KSwgcHVzaCBhbGwgYnl0ZXMgaW50byB0aGUgcGFyc2VyIGltbWVkaWF0ZWx5XG4gICAgLy8gSXQgd2lsbCBjcmVhdGUgdGhlIHByb3BlciB0aW1lc3RhbXBzIGJhc2VkIG9uIHRoZSBQVFMgdmFsdWVcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNjQnl0ZXMgPSBzYW1wbGVzW2ldLmJ5dGVzO1xuICAgICAgaWYgKGNjQnl0ZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNlYTYwOFBhcnNlcjEpIHtcbiAgICAgICAgICB0aGlzLmluaXRDZWE2MDhQYXJzZXJzKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2NkYXRhcyA9IHRoaXMuZXh0cmFjdENlYTYwOERhdGEoY2NCeXRlcyk7XG4gICAgICAgIHRoaXMuY2VhNjA4UGFyc2VyMS5hZGREYXRhKHNhbXBsZXNbaV0ucHRzLCBjY2RhdGFzWzBdKTtcbiAgICAgICAgdGhpcy5jZWE2MDhQYXJzZXIyLmFkZERhdGEoc2FtcGxlc1tpXS5wdHMsIGNjZGF0YXNbMV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBvbkJ1ZmZlckZsdXNoaW5nKGV2ZW50LCB7XG4gICAgc3RhcnRPZmZzZXQsXG4gICAgZW5kT2Zmc2V0LFxuICAgIGVuZE9mZnNldFN1YnRpdGxlcyxcbiAgICB0eXBlXG4gIH0pIHtcbiAgICBjb25zdCB7XG4gICAgICBtZWRpYVxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghbWVkaWEgfHwgbWVkaWEuY3VycmVudFRpbWUgPCBlbmRPZmZzZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQ2xlYXIgNjA4IGNhcHRpb24gY3VlcyBmcm9tIHRoZSBjYXB0aW9ucyBUZXh0VHJhY2tzIHdoZW4gdGhlIHZpZGVvIGJhY2sgYnVmZmVyIGlzIGZsdXNoZWRcbiAgICAvLyBGb3J3YXJkIGN1ZXMgYXJlIG5ldmVyIHJlbW92ZWQgYmVjYXVzZSB3ZSBjYW4gbG9vc2Ugc3RyZWFtZWQgNjA4IGNvbnRlbnQgZnJvbSByZWNlbnQgZnJhZ21lbnRzXG4gICAgaWYgKCF0eXBlIHx8IHR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2FwdGlvbnNUcmFja3NcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgT2JqZWN0LmtleXMoY2FwdGlvbnNUcmFja3MpLmZvckVhY2godHJhY2tOYW1lID0+IHJlbW92ZUN1ZXNJblJhbmdlKGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0sIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29uZmlnLnJlbmRlclRleHRUcmFja3NOYXRpdmVseSkge1xuICAgICAgLy8gQ2xlYXIgVlRUL0lNU0MxIHN1YnRpdGxlIGN1ZXMgZnJvbSB0aGUgc3VidGl0bGUgVGV4dFRyYWNrcyB3aGVuIHRoZSBiYWNrIGJ1ZmZlciBpcyBmbHVzaGVkXG4gICAgICBpZiAoc3RhcnRPZmZzZXQgPT09IDAgJiYgZW5kT2Zmc2V0U3VidGl0bGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHRleHRUcmFja3NcbiAgICAgICAgfSA9IHRoaXM7XG4gICAgICAgIE9iamVjdC5rZXlzKHRleHRUcmFja3MpLmZvckVhY2godHJhY2tOYW1lID0+IHJlbW92ZUN1ZXNJblJhbmdlKHRleHRUcmFja3NbdHJhY2tOYW1lXSwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldFN1YnRpdGxlcykpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBleHRyYWN0Q2VhNjA4RGF0YShieXRlQXJyYXkpIHtcbiAgICBjb25zdCBhY3R1YWxDQ0J5dGVzID0gW1tdLCBbXV07XG4gICAgY29uc3QgY291bnQgPSBieXRlQXJyYXlbMF0gJiAweDFmO1xuICAgIGxldCBwb3NpdGlvbiA9IDI7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICBjb25zdCB0bXBCeXRlID0gYnl0ZUFycmF5W3Bvc2l0aW9uKytdO1xuICAgICAgY29uc3QgY2NieXRlMSA9IDB4N2YgJiBieXRlQXJyYXlbcG9zaXRpb24rK107XG4gICAgICBjb25zdCBjY2J5dGUyID0gMHg3ZiAmIGJ5dGVBcnJheVtwb3NpdGlvbisrXTtcbiAgICAgIGlmIChjY2J5dGUxID09PSAwICYmIGNjYnl0ZTIgPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBjY1ZhbGlkID0gKDB4MDQgJiB0bXBCeXRlKSAhPT0gMDsgLy8gU3VwcG9ydCBhbGwgZm91ciBjaGFubmVsc1xuICAgICAgaWYgKGNjVmFsaWQpIHtcbiAgICAgICAgY29uc3QgY2NUeXBlID0gMHgwMyAmIHRtcEJ5dGU7XG4gICAgICAgIGlmICgweDAwIC8qIENFQTYwOCBmaWVsZDEqLyA9PT0gY2NUeXBlIHx8IDB4MDEgLyogQ0VBNjA4IGZpZWxkMiovID09PSBjY1R5cGUpIHtcbiAgICAgICAgICAvLyBFeGNsdWRlIENFQTcwOCBDQyBkYXRhLlxuICAgICAgICAgIGFjdHVhbENDQnl0ZXNbY2NUeXBlXS5wdXNoKGNjYnl0ZTEpO1xuICAgICAgICAgIGFjdHVhbENDQnl0ZXNbY2NUeXBlXS5wdXNoKGNjYnl0ZTIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhY3R1YWxDQ0J5dGVzO1xuICB9XG59XG5mdW5jdGlvbiBjYXB0aW9uc09yU3VidGl0bGVzRnJvbUNoYXJhY3RlcmlzdGljcyh0cmFjaykge1xuICBpZiAodHJhY2suY2hhcmFjdGVyaXN0aWNzKSB7XG4gICAgaWYgKC90cmFuc2NyaWJlcy1zcG9rZW4tZGlhbG9nL2dpLnRlc3QodHJhY2suY2hhcmFjdGVyaXN0aWNzKSAmJiAvZGVzY3JpYmVzLW11c2ljLWFuZC1zb3VuZC9naS50ZXN0KHRyYWNrLmNoYXJhY3RlcmlzdGljcykpIHtcbiAgICAgIHJldHVybiAnY2FwdGlvbnMnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJ3N1YnRpdGxlcyc7XG59XG5mdW5jdGlvbiBjYW5SZXVzZVZ0dFRleHRUcmFjayhpblVzZVRyYWNrLCBtYW5pZmVzdFRyYWNrKSB7XG4gIHJldHVybiAhIWluVXNlVHJhY2sgJiYgaW5Vc2VUcmFjay5raW5kID09PSBjYXB0aW9uc09yU3VidGl0bGVzRnJvbUNoYXJhY3RlcmlzdGljcyhtYW5pZmVzdFRyYWNrKSAmJiBzdWJ0aXRsZVRyYWNrTWF0Y2hlc1RleHRUcmFjayhtYW5pZmVzdFRyYWNrLCBpblVzZVRyYWNrKTtcbn1cbmZ1bmN0aW9uIGludGVyc2VjdGlvbih4MSwgeDIsIHkxLCB5Mikge1xuICByZXR1cm4gTWF0aC5taW4oeDIsIHkyKSAtIE1hdGgubWF4KHgxLCB5MSk7XG59XG5mdW5jdGlvbiBuZXdWVFRDQ3MoKSB7XG4gIHJldHVybiB7XG4gICAgY2NPZmZzZXQ6IDAsXG4gICAgcHJlc2VudGF0aW9uT2Zmc2V0OiAwLFxuICAgIDA6IHtcbiAgICAgIHN0YXJ0OiAwLFxuICAgICAgcHJldkNDOiAtMSxcbiAgICAgIG5ldzogdHJ1ZVxuICAgIH1cbiAgfTtcbn1cblxuY29uc3QgV0hJVEVTUEFDRV9DSEFSID0gL1xccy87XG5jb25zdCBDdWVzID0ge1xuICBuZXdDdWUodHJhY2ssIHN0YXJ0VGltZSwgZW5kVGltZSwgY2FwdGlvblNjcmVlbikge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCByb3c7XG4gICAgLy8gdGhlIHR5cGUgZGF0YSBzdGF0ZXMgdGhpcyBpcyBWVFRDdWUsIGJ1dCBpdCBjYW4gcG90ZW50aWFsbHkgYmUgYSBUZXh0VHJhY2tDdWUgb24gb2xkIGJyb3dzZXJzXG4gICAgbGV0IGN1ZTtcbiAgICBsZXQgaW5kZW50aW5nO1xuICAgIGxldCBpbmRlbnQ7XG4gICAgbGV0IHRleHQ7XG4gICAgY29uc3QgQ3VlID0gc2VsZi5WVFRDdWUgfHwgc2VsZi5UZXh0VHJhY2tDdWU7XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCBjYXB0aW9uU2NyZWVuLnJvd3MubGVuZ3RoOyByKyspIHtcbiAgICAgIHJvdyA9IGNhcHRpb25TY3JlZW4ucm93c1tyXTtcbiAgICAgIGluZGVudGluZyA9IHRydWU7XG4gICAgICBpbmRlbnQgPSAwO1xuICAgICAgdGV4dCA9ICcnO1xuICAgICAgaWYgKCFyb3cuaXNFbXB0eSgpKSB7XG4gICAgICAgIHZhciBfdHJhY2skY3VlcztcbiAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCByb3cuY2hhcnMubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICBpZiAoV0hJVEVTUEFDRV9DSEFSLnRlc3Qocm93LmNoYXJzW2NdLnVjaGFyKSAmJiBpbmRlbnRpbmcpIHtcbiAgICAgICAgICAgIGluZGVudCsrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0ICs9IHJvdy5jaGFyc1tjXS51Y2hhcjtcbiAgICAgICAgICAgIGluZGVudGluZyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUbyBiZSB1c2VkIGZvciBjbGVhbmluZy11cCBvcnBoYW5lZCByb2xsLXVwIGNhcHRpb25zXG4gICAgICAgIHJvdy5jdWVTdGFydFRpbWUgPSBzdGFydFRpbWU7XG5cbiAgICAgICAgLy8gR2l2ZSBhIHNsaWdodCBidW1wIHRvIHRoZSBlbmRUaW1lIGlmIGl0J3MgZXF1YWwgdG8gc3RhcnRUaW1lIHRvIGF2b2lkIGEgU3ludGF4RXJyb3IgaW4gSUVcbiAgICAgICAgaWYgKHN0YXJ0VGltZSA9PT0gZW5kVGltZSkge1xuICAgICAgICAgIGVuZFRpbWUgKz0gMC4wMDAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRlbnQgPj0gMTYpIHtcbiAgICAgICAgICBpbmRlbnQtLTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmRlbnQrKztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdWVUZXh0ID0gZml4TGluZUJyZWFrcyh0ZXh0LnRyaW0oKSk7XG4gICAgICAgIGNvbnN0IGlkID0gZ2VuZXJhdGVDdWVJZChzdGFydFRpbWUsIGVuZFRpbWUsIGN1ZVRleHQpO1xuXG4gICAgICAgIC8vIElmIHRoaXMgY3VlIGFscmVhZHkgZXhpc3RzIGluIHRoZSB0cmFjayBkbyBub3QgcHVzaCBpdFxuICAgICAgICBpZiAoISh0cmFjayAhPSBudWxsICYmIChfdHJhY2skY3VlcyA9IHRyYWNrLmN1ZXMpICE9IG51bGwgJiYgX3RyYWNrJGN1ZXMuZ2V0Q3VlQnlJZChpZCkpKSB7XG4gICAgICAgICAgY3VlID0gbmV3IEN1ZShzdGFydFRpbWUsIGVuZFRpbWUsIGN1ZVRleHQpO1xuICAgICAgICAgIGN1ZS5pZCA9IGlkO1xuICAgICAgICAgIGN1ZS5saW5lID0gciArIDE7XG4gICAgICAgICAgY3VlLmFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgIC8vIENsYW1wIHRoZSBwb3NpdGlvbiBiZXR3ZWVuIDEwIGFuZCA4MCBwZXJjZW50IChDRUEtNjA4IFBBQyBpbmRlbnQgY29kZSlcbiAgICAgICAgICAvLyBodHRwczovL2R2Y3MudzMub3JnL2hnL3RleHQtdHJhY2tzL3Jhdy1maWxlL2RlZmF1bHQvNjA4dG9WVFQvNjA4dG9WVFQuaHRtbCNwb3NpdGlvbmluZy1pbi1jZWEtNjA4XG4gICAgICAgICAgLy8gRmlyZWZveCB0aHJvd3MgYW4gZXhjZXB0aW9uIGFuZCBjYXB0aW9ucyBicmVhayB3aXRoIG91dCBvZiBib3VuZHMgMC0xMDAgdmFsdWVzXG4gICAgICAgICAgY3VlLnBvc2l0aW9uID0gMTAgKyBNYXRoLm1pbig4MCwgTWF0aC5mbG9vcihpbmRlbnQgKiA4IC8gMzIpICogMTApO1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGN1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRyYWNrICYmIHJlc3VsdC5sZW5ndGgpIHtcbiAgICAgIC8vIFNvcnQgYm90dG9tIGN1ZXMgaW4gcmV2ZXJzZSBvcmRlciBzbyB0aGF0IHRoZXkgcmVuZGVyIGluIGxpbmUgb3JkZXIgd2hlbiBvdmVybGFwcGluZyBpbiBDaHJvbWVcbiAgICAgIHJlc3VsdC5zb3J0KChjdWVBLCBjdWVCKSA9PiB7XG4gICAgICAgIGlmIChjdWVBLmxpbmUgPT09ICdhdXRvJyB8fCBjdWVCLmxpbmUgPT09ICdhdXRvJykge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdWVBLmxpbmUgPiA4ICYmIGN1ZUIubGluZSA+IDgpIHtcbiAgICAgICAgICByZXR1cm4gY3VlQi5saW5lIC0gY3VlQS5saW5lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdWVBLmxpbmUgLSBjdWVCLmxpbmU7XG4gICAgICB9KTtcbiAgICAgIHJlc3VsdC5mb3JFYWNoKGN1ZSA9PiBhZGRDdWVUb1RyYWNrKHRyYWNrLCBjdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcblxuZnVuY3Rpb24gZmV0Y2hTdXBwb3J0ZWQoKSB7XG4gIGlmIChcbiAgLy8gQHRzLWlnbm9yZVxuICBzZWxmLmZldGNoICYmIHNlbGYuQWJvcnRDb250cm9sbGVyICYmIHNlbGYuUmVhZGFibGVTdHJlYW0gJiYgc2VsZi5SZXF1ZXN0KSB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBzZWxmLlJlYWRhYmxlU3RyZWFtKHt9KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8qIG5vb3AgKi9cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuY29uc3QgQllURVJBTkdFID0gLyhcXGQrKS0oXFxkKylcXC8oXFxkKykvO1xuY2xhc3MgRmV0Y2hMb2FkZXIge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLmZldGNoU2V0dXAgPSB2b2lkIDA7XG4gICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IHZvaWQgMDtcbiAgICB0aGlzLnJlcXVlc3QgPSBudWxsO1xuICAgIHRoaXMucmVzcG9uc2UgPSBudWxsO1xuICAgIHRoaXMuY29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICAgIHRoaXMuY29uZmlnID0gbnVsbDtcbiAgICB0aGlzLmNhbGxiYWNrcyA9IG51bGw7XG4gICAgdGhpcy5zdGF0cyA9IHZvaWQgMDtcbiAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgdGhpcy5mZXRjaFNldHVwID0gY29uZmlnLmZldGNoU2V0dXAgfHwgZ2V0UmVxdWVzdDtcbiAgICB0aGlzLmNvbnRyb2xsZXIgPSBuZXcgc2VsZi5BYm9ydENvbnRyb2xsZXIoKTtcbiAgICB0aGlzLnN0YXRzID0gbmV3IExvYWRTdGF0cygpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5sb2FkZXIgPSB0aGlzLmNhbGxiYWNrcyA9IHRoaXMuY29udGV4dCA9IHRoaXMuY29uZmlnID0gdGhpcy5yZXF1ZXN0ID0gbnVsbDtcbiAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgICB0aGlzLnJlc3BvbnNlID0gbnVsbDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5mZXRjaFNldHVwID0gdGhpcy5jb250cm9sbGVyID0gdGhpcy5zdGF0cyA9IG51bGw7XG4gIH1cbiAgYWJvcnRJbnRlcm5hbCgpIHtcbiAgICBpZiAodGhpcy5jb250cm9sbGVyICYmICF0aGlzLnN0YXRzLmxvYWRpbmcuZW5kKSB7XG4gICAgICB0aGlzLnN0YXRzLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5jb250cm9sbGVyLmFib3J0KCk7XG4gICAgfVxuICB9XG4gIGFib3J0KCkge1xuICAgIHZhciBfdGhpcyRjYWxsYmFja3M7XG4gICAgdGhpcy5hYm9ydEludGVybmFsKCk7XG4gICAgaWYgKChfdGhpcyRjYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrcykgIT0gbnVsbCAmJiBfdGhpcyRjYWxsYmFja3Mub25BYm9ydCkge1xuICAgICAgdGhpcy5jYWxsYmFja3Mub25BYm9ydCh0aGlzLnN0YXRzLCB0aGlzLmNvbnRleHQsIHRoaXMucmVzcG9uc2UpO1xuICAgIH1cbiAgfVxuICBsb2FkKGNvbnRleHQsIGNvbmZpZywgY2FsbGJhY2tzKSB7XG4gICAgY29uc3Qgc3RhdHMgPSB0aGlzLnN0YXRzO1xuICAgIGlmIChzdGF0cy5sb2FkaW5nLnN0YXJ0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvYWRlciBjYW4gb25seSBiZSB1c2VkIG9uY2UuJyk7XG4gICAgfVxuICAgIHN0YXRzLmxvYWRpbmcuc3RhcnQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnN0IGluaXRQYXJhbXMgPSBnZXRSZXF1ZXN0UGFyYW1ldGVycyhjb250ZXh0LCB0aGlzLmNvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICBjb25zdCBpc0FycmF5QnVmZmVyID0gY29udGV4dC5yZXNwb25zZVR5cGUgPT09ICdhcnJheWJ1ZmZlcic7XG4gICAgY29uc3QgTEVOR1RIID0gaXNBcnJheUJ1ZmZlciA/ICdieXRlTGVuZ3RoJyA6ICdsZW5ndGgnO1xuICAgIGNvbnN0IHtcbiAgICAgIG1heFRpbWVUb0ZpcnN0Qnl0ZU1zLFxuICAgICAgbWF4TG9hZFRpbWVNc1xuICAgIH0gPSBjb25maWcubG9hZFBvbGljeTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICAgIHRoaXMucmVxdWVzdCA9IHRoaXMuZmV0Y2hTZXR1cChjb250ZXh0LCBpbml0UGFyYW1zKTtcbiAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICBjb25maWcudGltZW91dCA9IG1heFRpbWVUb0ZpcnN0Qnl0ZU1zICYmIGlzRmluaXRlTnVtYmVyKG1heFRpbWVUb0ZpcnN0Qnl0ZU1zKSA/IG1heFRpbWVUb0ZpcnN0Qnl0ZU1zIDogbWF4TG9hZFRpbWVNcztcbiAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gc2VsZi5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmNhbGxiYWNrcykge1xuICAgICAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgICAgICAgdGhpcy5jYWxsYmFja3Mub25UaW1lb3V0KHN0YXRzLCBjb250ZXh0LCB0aGlzLnJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9LCBjb25maWcudGltZW91dCk7XG4gICAgY29uc3QgZmV0Y2hQcm9taXNlID0gaXNQcm9taXNlKHRoaXMucmVxdWVzdCkgPyB0aGlzLnJlcXVlc3QudGhlbihzZWxmLmZldGNoKSA6IHNlbGYuZmV0Y2godGhpcy5yZXF1ZXN0KTtcbiAgICBmZXRjaFByb21pc2UudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICB2YXIgX3RoaXMkY2FsbGJhY2tzMjtcbiAgICAgIHRoaXMucmVzcG9uc2UgPSB0aGlzLmxvYWRlciA9IHJlc3BvbnNlO1xuICAgICAgY29uc3QgZmlyc3QgPSBNYXRoLm1heChzZWxmLnBlcmZvcm1hbmNlLm5vdygpLCBzdGF0cy5sb2FkaW5nLnN0YXJ0KTtcbiAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgICAgY29uZmlnLnRpbWVvdXQgPSBtYXhMb2FkVGltZU1zO1xuICAgICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IHNlbGYuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmNhbGxiYWNrcykge1xuICAgICAgICAgIHRoaXMuYWJvcnRJbnRlcm5hbCgpO1xuICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLm9uVGltZW91dChzdGF0cywgY29udGV4dCwgdGhpcy5yZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIG1heExvYWRUaW1lTXMgLSAoZmlyc3QgLSBzdGF0cy5sb2FkaW5nLnN0YXJ0KSk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dFxuICAgICAgICB9ID0gcmVzcG9uc2U7XG4gICAgICAgIHRocm93IG5ldyBGZXRjaEVycm9yKHN0YXR1c1RleHQgfHwgJ2ZldGNoLCBiYWQgbmV0d29yayByZXNwb25zZScsIHN0YXR1cywgcmVzcG9uc2UpO1xuICAgICAgfVxuICAgICAgc3RhdHMubG9hZGluZy5maXJzdCA9IGZpcnN0O1xuICAgICAgc3RhdHMudG90YWwgPSBnZXRDb250ZW50TGVuZ3RoKHJlc3BvbnNlLmhlYWRlcnMpIHx8IHN0YXRzLnRvdGFsO1xuICAgICAgY29uc3Qgb25Qcm9ncmVzcyA9IChfdGhpcyRjYWxsYmFja3MyID0gdGhpcy5jYWxsYmFja3MpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRjYWxsYmFja3MyLm9uUHJvZ3Jlc3M7XG4gICAgICBpZiAob25Qcm9ncmVzcyAmJiBpc0Zpbml0ZU51bWJlcihjb25maWcuaGlnaFdhdGVyTWFyaykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZFByb2dyZXNzaXZlbHkocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBjb25maWcuaGlnaFdhdGVyTWFyaywgb25Qcm9ncmVzcyk7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb250ZXh0LnJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICAgIH0pLnRoZW4ocmVzcG9uc2VEYXRhID0+IHtcbiAgICAgIHZhciBfdGhpcyRjYWxsYmFja3MzLCBfdGhpcyRjYWxsYmFja3M0O1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSB0aGlzLnJlc3BvbnNlO1xuICAgICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xvYWRlciBkZXN0cm95ZWQnKTtcbiAgICAgIH1cbiAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgICAgc3RhdHMubG9hZGluZy5lbmQgPSBNYXRoLm1heChzZWxmLnBlcmZvcm1hbmNlLm5vdygpLCBzdGF0cy5sb2FkaW5nLmZpcnN0KTtcbiAgICAgIGNvbnN0IHRvdGFsID0gcmVzcG9uc2VEYXRhW0xFTkdUSF07XG4gICAgICBpZiAodG90YWwpIHtcbiAgICAgICAgc3RhdHMubG9hZGVkID0gc3RhdHMudG90YWwgPSB0b3RhbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxvYWRlclJlc3BvbnNlID0ge1xuICAgICAgICB1cmw6IHJlc3BvbnNlLnVybCxcbiAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICBjb2RlOiByZXNwb25zZS5zdGF0dXNcbiAgICAgIH07XG4gICAgICBjb25zdCBvblByb2dyZXNzID0gKF90aGlzJGNhbGxiYWNrczMgPSB0aGlzLmNhbGxiYWNrcykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGNhbGxiYWNrczMub25Qcm9ncmVzcztcbiAgICAgIGlmIChvblByb2dyZXNzICYmICFpc0Zpbml0ZU51bWJlcihjb25maWcuaGlnaFdhdGVyTWFyaykpIHtcbiAgICAgICAgb25Qcm9ncmVzcyhzdGF0cywgY29udGV4dCwgcmVzcG9uc2VEYXRhLCByZXNwb25zZSk7XG4gICAgICB9XG4gICAgICAoX3RoaXMkY2FsbGJhY2tzNCA9IHRoaXMuY2FsbGJhY2tzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkY2FsbGJhY2tzNC5vblN1Y2Nlc3MobG9hZGVyUmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCByZXNwb25zZSk7XG4gICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgdmFyIF90aGlzJGNhbGxiYWNrczU7XG4gICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICAgIGlmIChzdGF0cy5hYm9ydGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIENPUlMgZXJyb3JzIHJlc3VsdCBpbiBhbiB1bmRlZmluZWQgY29kZS4gU2V0IGl0IHRvIDAgaGVyZSB0byBhbGlnbiB3aXRoIFhIUidzIGJlaGF2aW9yXG4gICAgICAvLyB3aGVuIGRlc3Ryb3lpbmcsICdlcnJvcicgaXRzZWxmIGNhbiBiZSB1bmRlZmluZWRcbiAgICAgIGNvbnN0IGNvZGUgPSAhZXJyb3IgPyAwIDogZXJyb3IuY29kZSB8fCAwO1xuICAgICAgY29uc3QgdGV4dCA9ICFlcnJvciA/IG51bGwgOiBlcnJvci5tZXNzYWdlO1xuICAgICAgKF90aGlzJGNhbGxiYWNrczUgPSB0aGlzLmNhbGxiYWNrcykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGNhbGxiYWNrczUub25FcnJvcih7XG4gICAgICAgIGNvZGUsXG4gICAgICAgIHRleHRcbiAgICAgIH0sIGNvbnRleHQsIGVycm9yID8gZXJyb3IuZGV0YWlscyA6IG51bGwsIHN0YXRzKTtcbiAgICB9KTtcbiAgfVxuICBnZXRDYWNoZUFnZSgpIHtcbiAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICBpZiAodGhpcy5yZXNwb25zZSkge1xuICAgICAgY29uc3QgYWdlSGVhZGVyID0gdGhpcy5yZXNwb25zZS5oZWFkZXJzLmdldCgnYWdlJyk7XG4gICAgICByZXN1bHQgPSBhZ2VIZWFkZXIgPyBwYXJzZUZsb2F0KGFnZUhlYWRlcikgOiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGdldFJlc3BvbnNlSGVhZGVyKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNwb25zZSA/IHRoaXMucmVzcG9uc2UuaGVhZGVycy5nZXQobmFtZSkgOiBudWxsO1xuICB9XG4gIGxvYWRQcm9ncmVzc2l2ZWx5KHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgaGlnaFdhdGVyTWFyayA9IDAsIG9uUHJvZ3Jlc3MpIHtcbiAgICBjb25zdCBjaHVua0NhY2hlID0gbmV3IENodW5rQ2FjaGUoKTtcbiAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICAgIGNvbnN0IHB1bXAgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gcmVhZGVyLnJlYWQoKS50aGVuKGRhdGEgPT4ge1xuICAgICAgICBpZiAoZGF0YS5kb25lKSB7XG4gICAgICAgICAgaWYgKGNodW5rQ2FjaGUuZGF0YUxlbmd0aCkge1xuICAgICAgICAgICAgb25Qcm9ncmVzcyhzdGF0cywgY29udGV4dCwgY2h1bmtDYWNoZS5mbHVzaCgpLmJ1ZmZlciwgcmVzcG9uc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBBcnJheUJ1ZmZlcigwKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2h1bmsgPSBkYXRhLnZhbHVlO1xuICAgICAgICBjb25zdCBsZW4gPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIHN0YXRzLmxvYWRlZCArPSBsZW47XG4gICAgICAgIGlmIChsZW4gPCBoaWdoV2F0ZXJNYXJrIHx8IGNodW5rQ2FjaGUuZGF0YUxlbmd0aCkge1xuICAgICAgICAgIC8vIFRoZSBjdXJyZW50IGNodW5rIGlzIHRvbyBzbWFsbCB0byB0byBiZSBlbWl0dGVkIG9yIHRoZSBjYWNoZSBhbHJlYWR5IGhhcyBkYXRhXG4gICAgICAgICAgLy8gUHVzaCBpdCB0byB0aGUgY2FjaGVcbiAgICAgICAgICBjaHVua0NhY2hlLnB1c2goY2h1bmspO1xuICAgICAgICAgIGlmIChjaHVua0NhY2hlLmRhdGFMZW5ndGggPj0gaGlnaFdhdGVyTWFyaykge1xuICAgICAgICAgICAgLy8gZmx1c2ggaW4gb3JkZXIgdG8gam9pbiB0aGUgdHlwZWQgYXJyYXlzXG4gICAgICAgICAgICBvblByb2dyZXNzKHN0YXRzLCBjb250ZXh0LCBjaHVua0NhY2hlLmZsdXNoKCkuYnVmZmVyLCByZXNwb25zZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIHRoZXJlJ3Mgbm90aGluZyBjYWNoZWQgYWxyZWFkeSwgYW5kIHRoZSBjaGFjaGUgaXMgbGFyZ2UgZW5vdWdoXG4gICAgICAgICAgLy8ganVzdCBlbWl0IHRoZSBwcm9ncmVzcyBldmVudFxuICAgICAgICAgIG9uUHJvZ3Jlc3Moc3RhdHMsIGNvbnRleHQsIGNodW5rLmJ1ZmZlciwgcmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwdW1wKCk7XG4gICAgICB9KS5jYXRjaCgoKSA9PiB7XG4gICAgICAgIC8qIGFib3J0ZWQgKi9cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBwdW1wKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFJlcXVlc3RQYXJhbWV0ZXJzKGNvbnRleHQsIHNpZ25hbCkge1xuICBjb25zdCBpbml0UGFyYW1zID0ge1xuICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgbW9kZTogJ2NvcnMnLFxuICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nLFxuICAgIHNpZ25hbCxcbiAgICBoZWFkZXJzOiBuZXcgc2VsZi5IZWFkZXJzKF9leHRlbmRzKHt9LCBjb250ZXh0LmhlYWRlcnMpKVxuICB9O1xuICBpZiAoY29udGV4dC5yYW5nZUVuZCkge1xuICAgIGluaXRQYXJhbXMuaGVhZGVycy5zZXQoJ1JhbmdlJywgJ2J5dGVzPScgKyBjb250ZXh0LnJhbmdlU3RhcnQgKyAnLScgKyBTdHJpbmcoY29udGV4dC5yYW5nZUVuZCAtIDEpKTtcbiAgfVxuICByZXR1cm4gaW5pdFBhcmFtcztcbn1cbmZ1bmN0aW9uIGdldEJ5dGVSYW5nZUxlbmd0aChieXRlUmFuZ2VIZWFkZXIpIHtcbiAgY29uc3QgcmVzdWx0ID0gQllURVJBTkdFLmV4ZWMoYnl0ZVJhbmdlSGVhZGVyKTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIHJldHVybiBwYXJzZUludChyZXN1bHRbMl0pIC0gcGFyc2VJbnQocmVzdWx0WzFdKSArIDE7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldENvbnRlbnRMZW5ndGgoaGVhZGVycykge1xuICBjb25zdCBjb250ZW50UmFuZ2UgPSBoZWFkZXJzLmdldCgnQ29udGVudC1SYW5nZScpO1xuICBpZiAoY29udGVudFJhbmdlKSB7XG4gICAgY29uc3QgYnl0ZVJhbmdlTGVuZ3RoID0gZ2V0Qnl0ZVJhbmdlTGVuZ3RoKGNvbnRlbnRSYW5nZSk7XG4gICAgaWYgKGlzRmluaXRlTnVtYmVyKGJ5dGVSYW5nZUxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBieXRlUmFuZ2VMZW5ndGg7XG4gICAgfVxuICB9XG4gIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBoZWFkZXJzLmdldCgnQ29udGVudC1MZW5ndGgnKTtcbiAgaWYgKGNvbnRlbnRMZW5ndGgpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQoY29udGVudExlbmd0aCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFJlcXVlc3QoY29udGV4dCwgaW5pdFBhcmFtcykge1xuICByZXR1cm4gbmV3IHNlbGYuUmVxdWVzdChjb250ZXh0LnVybCwgaW5pdFBhcmFtcyk7XG59XG5jbGFzcyBGZXRjaEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjb2RlLCBkZXRhaWxzKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5jb2RlID0gdm9pZCAwO1xuICAgIHRoaXMuZGV0YWlscyA9IHZvaWQgMDtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gIH1cbn1cblxuY29uc3QgQUdFX0hFQURFUl9MSU5FX1JFR0VYID0gL15hZ2U6XFxzKltcXGQuXStcXHMqJC9pbTtcbmNsYXNzIFhockxvYWRlciB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHRoaXMueGhyU2V0dXAgPSB2b2lkIDA7XG4gICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IHZvaWQgMDtcbiAgICB0aGlzLnJldHJ5VGltZW91dCA9IHZvaWQgMDtcbiAgICB0aGlzLnJldHJ5RGVsYXkgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25maWcgPSBudWxsO1xuICAgIHRoaXMuY2FsbGJhY2tzID0gbnVsbDtcbiAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgICB0aGlzLnN0YXRzID0gdm9pZCAwO1xuICAgIHRoaXMueGhyU2V0dXAgPSBjb25maWcgPyBjb25maWcueGhyU2V0dXAgfHwgbnVsbCA6IG51bGw7XG4gICAgdGhpcy5zdGF0cyA9IG5ldyBMb2FkU3RhdHMoKTtcbiAgICB0aGlzLnJldHJ5RGVsYXkgPSAwO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jYWxsYmFja3MgPSBudWxsO1xuICAgIHRoaXMuYWJvcnRJbnRlcm5hbCgpO1xuICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgICB0aGlzLmNvbmZpZyA9IG51bGw7XG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLnhoclNldHVwID0gbnVsbDtcbiAgfVxuICBhYm9ydEludGVybmFsKCkge1xuICAgIGNvbnN0IGxvYWRlciA9IHRoaXMubG9hZGVyO1xuICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmV0cnlUaW1lb3V0KTtcbiAgICBpZiAobG9hZGVyKSB7XG4gICAgICBsb2FkZXIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgIGxvYWRlci5vbnByb2dyZXNzID0gbnVsbDtcbiAgICAgIGlmIChsb2FkZXIucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgICB0aGlzLnN0YXRzLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYWJvcnQoKSB7XG4gICAgdmFyIF90aGlzJGNhbGxiYWNrcztcbiAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgICBpZiAoKF90aGlzJGNhbGxiYWNrcyA9IHRoaXMuY2FsbGJhY2tzKSAhPSBudWxsICYmIF90aGlzJGNhbGxiYWNrcy5vbkFib3J0KSB7XG4gICAgICB0aGlzLmNhbGxiYWNrcy5vbkFib3J0KHRoaXMuc3RhdHMsIHRoaXMuY29udGV4dCwgdGhpcy5sb2FkZXIpO1xuICAgIH1cbiAgfVxuICBsb2FkKGNvbnRleHQsIGNvbmZpZywgY2FsbGJhY2tzKSB7XG4gICAgaWYgKHRoaXMuc3RhdHMubG9hZGluZy5zdGFydCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb2FkZXIgY2FuIG9ubHkgYmUgdXNlZCBvbmNlLicpO1xuICAgIH1cbiAgICB0aGlzLnN0YXRzLmxvYWRpbmcuc3RhcnQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5jYWxsYmFja3MgPSBjYWxsYmFja3M7XG4gICAgdGhpcy5sb2FkSW50ZXJuYWwoKTtcbiAgfVxuICBsb2FkSW50ZXJuYWwoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29uZmlnLFxuICAgICAgY29udGV4dFxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghY29uZmlnIHx8ICFjb250ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHhociA9IHRoaXMubG9hZGVyID0gbmV3IHNlbGYuWE1MSHR0cFJlcXVlc3QoKTtcbiAgICBjb25zdCBzdGF0cyA9IHRoaXMuc3RhdHM7XG4gICAgc3RhdHMubG9hZGluZy5maXJzdCA9IDA7XG4gICAgc3RhdHMubG9hZGVkID0gMDtcbiAgICBzdGF0cy5hYm9ydGVkID0gZmFsc2U7XG4gICAgY29uc3QgeGhyU2V0dXAgPSB0aGlzLnhoclNldHVwO1xuICAgIGlmICh4aHJTZXR1cCkge1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmxvYWRlciAhPT0geGhyIHx8IHRoaXMuc3RhdHMuYWJvcnRlZCkgcmV0dXJuO1xuICAgICAgICByZXR1cm4geGhyU2V0dXAoeGhyLCBjb250ZXh0LnVybCk7XG4gICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIGlmICh0aGlzLmxvYWRlciAhPT0geGhyIHx8IHRoaXMuc3RhdHMuYWJvcnRlZCkgcmV0dXJuO1xuICAgICAgICB4aHIub3BlbignR0VUJywgY29udGV4dC51cmwsIHRydWUpO1xuICAgICAgICByZXR1cm4geGhyU2V0dXAoeGhyLCBjb250ZXh0LnVybCk7XG4gICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMubG9hZGVyICE9PSB4aHIgfHwgdGhpcy5zdGF0cy5hYm9ydGVkKSByZXR1cm47XG4gICAgICAgIHRoaXMub3BlbkFuZFNlbmRYaHIoeGhyLCBjb250ZXh0LCBjb25maWcpO1xuICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICB2YXIgX3RoaXMkY2FsbGJhY2tzMjtcbiAgICAgICAgLy8gSUUxMSB0aHJvd3MgYW4gZXhjZXB0aW9uIG9uIHhoci5vcGVuIGlmIGF0dGVtcHRpbmcgdG8gYWNjZXNzIGFuIEhUVFAgcmVzb3VyY2Ugb3ZlciBIVFRQU1xuICAgICAgICAoX3RoaXMkY2FsbGJhY2tzMiA9IHRoaXMuY2FsbGJhY2tzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkY2FsbGJhY2tzMi5vbkVycm9yKHtcbiAgICAgICAgICBjb2RlOiB4aHIuc3RhdHVzLFxuICAgICAgICAgIHRleHQ6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgfSwgY29udGV4dCwgeGhyLCBzdGF0cyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9wZW5BbmRTZW5kWGhyKHhociwgY29udGV4dCwgY29uZmlnKTtcbiAgICB9XG4gIH1cbiAgb3BlbkFuZFNlbmRYaHIoeGhyLCBjb250ZXh0LCBjb25maWcpIHtcbiAgICBpZiAoIXhoci5yZWFkeVN0YXRlKSB7XG4gICAgICB4aHIub3BlbignR0VUJywgY29udGV4dC51cmwsIHRydWUpO1xuICAgIH1cbiAgICBjb25zdCBoZWFkZXJzID0gY29udGV4dC5oZWFkZXJzO1xuICAgIGNvbnN0IHtcbiAgICAgIG1heFRpbWVUb0ZpcnN0Qnl0ZU1zLFxuICAgICAgbWF4TG9hZFRpbWVNc1xuICAgIH0gPSBjb25maWcubG9hZFBvbGljeTtcbiAgICBpZiAoaGVhZGVycykge1xuICAgICAgZm9yIChjb25zdCBoZWFkZXIgaW4gaGVhZGVycykge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXIsIGhlYWRlcnNbaGVhZGVyXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb250ZXh0LnJhbmdlRW5kKSB7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignUmFuZ2UnLCAnYnl0ZXM9JyArIGNvbnRleHQucmFuZ2VTdGFydCArICctJyArIChjb250ZXh0LnJhbmdlRW5kIC0gMSkpO1xuICAgIH1cbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gdGhpcy5yZWFkeXN0YXRlY2hhbmdlLmJpbmQodGhpcyk7XG4gICAgeGhyLm9ucHJvZ3Jlc3MgPSB0aGlzLmxvYWRwcm9ncmVzcy5iaW5kKHRoaXMpO1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSBjb250ZXh0LnJlc3BvbnNlVHlwZTtcbiAgICAvLyBzZXR1cCB0aW1lb3V0IGJlZm9yZSB3ZSBwZXJmb3JtIHJlcXVlc3RcbiAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICBjb25maWcudGltZW91dCA9IG1heFRpbWVUb0ZpcnN0Qnl0ZU1zICYmIGlzRmluaXRlTnVtYmVyKG1heFRpbWVUb0ZpcnN0Qnl0ZU1zKSA/IG1heFRpbWVUb0ZpcnN0Qnl0ZU1zIDogbWF4TG9hZFRpbWVNcztcbiAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gc2VsZi5zZXRUaW1lb3V0KHRoaXMubG9hZHRpbWVvdXQuYmluZCh0aGlzKSwgY29uZmlnLnRpbWVvdXQpO1xuICAgIHhoci5zZW5kKCk7XG4gIH1cbiAgcmVhZHlzdGF0ZWNoYW5nZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250ZXh0LFxuICAgICAgbG9hZGVyOiB4aHIsXG4gICAgICBzdGF0c1xuICAgIH0gPSB0aGlzO1xuICAgIGlmICghY29udGV4dCB8fCAheGhyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlYWR5U3RhdGUgPSB4aHIucmVhZHlTdGF0ZTtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcblxuICAgIC8vIGRvbid0IHByb2NlZWQgaWYgeGhyIGhhcyBiZWVuIGFib3J0ZWRcbiAgICBpZiAoc3RhdHMuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vID49IEhFQURFUlNfUkVDRUlWRURcbiAgICBpZiAocmVhZHlTdGF0ZSA+PSAyKSB7XG4gICAgICBpZiAoc3RhdHMubG9hZGluZy5maXJzdCA9PT0gMCkge1xuICAgICAgICBzdGF0cy5sb2FkaW5nLmZpcnN0ID0gTWF0aC5tYXgoc2VsZi5wZXJmb3JtYW5jZS5ub3coKSwgc3RhdHMubG9hZGluZy5zdGFydCk7XG4gICAgICAgIC8vIHJlYWR5U3RhdGUgPj0gMiBBTkQgcmVhZHlTdGF0ZSAhPT00IChyZWFkeVN0YXRlID0gSEVBREVSU19SRUNFSVZFRCB8fCBMT0FESU5HKSByZWFybSB0aW1lb3V0IGFzIHhociBub3QgZmluaXNoZWQgeWV0XG4gICAgICAgIGlmIChjb25maWcudGltZW91dCAhPT0gY29uZmlnLmxvYWRQb2xpY3kubWF4TG9hZFRpbWVNcykge1xuICAgICAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgICAgICAgIGNvbmZpZy50aW1lb3V0ID0gY29uZmlnLmxvYWRQb2xpY3kubWF4TG9hZFRpbWVNcztcbiAgICAgICAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gc2VsZi5zZXRUaW1lb3V0KHRoaXMubG9hZHRpbWVvdXQuYmluZCh0aGlzKSwgY29uZmlnLmxvYWRQb2xpY3kubWF4TG9hZFRpbWVNcyAtIChzdGF0cy5sb2FkaW5nLmZpcnN0IC0gc3RhdHMubG9hZGluZy5zdGFydCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgIHhoci5vbnByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0geGhyLnN0YXR1cztcbiAgICAgICAgLy8gaHR0cCBzdGF0dXMgYmV0d2VlbiAyMDAgdG8gMjk5IGFyZSBhbGwgc3VjY2Vzc2Z1bFxuICAgICAgICBjb25zdCB1c2VSZXNwb25zZVRleHQgPSB4aHIucmVzcG9uc2VUeXBlID09PSAndGV4dCcgPyB4aHIucmVzcG9uc2VUZXh0IDogbnVsbDtcbiAgICAgICAgaWYgKHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwKSB7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IHVzZVJlc3BvbnNlVGV4dCAhPSBudWxsID8gdXNlUmVzcG9uc2VUZXh0IDogeGhyLnJlc3BvbnNlO1xuICAgICAgICAgIGlmIChkYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyRjYWxsYmFja3MzLCBfdGhpcyRjYWxsYmFja3M0O1xuICAgICAgICAgICAgc3RhdHMubG9hZGluZy5lbmQgPSBNYXRoLm1heChzZWxmLnBlcmZvcm1hbmNlLm5vdygpLCBzdGF0cy5sb2FkaW5nLmZpcnN0KTtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IHhoci5yZXNwb25zZVR5cGUgPT09ICdhcnJheWJ1ZmZlcicgPyBkYXRhLmJ5dGVMZW5ndGggOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIHN0YXRzLmxvYWRlZCA9IHN0YXRzLnRvdGFsID0gbGVuO1xuICAgICAgICAgICAgc3RhdHMuYndFc3RpbWF0ZSA9IHN0YXRzLnRvdGFsICogODAwMCAvIChzdGF0cy5sb2FkaW5nLmVuZCAtIHN0YXRzLmxvYWRpbmcuZmlyc3QpO1xuICAgICAgICAgICAgY29uc3Qgb25Qcm9ncmVzcyA9IChfdGhpcyRjYWxsYmFja3MzID0gdGhpcy5jYWxsYmFja3MpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRjYWxsYmFja3MzLm9uUHJvZ3Jlc3M7XG4gICAgICAgICAgICBpZiAob25Qcm9ncmVzcykge1xuICAgICAgICAgICAgICBvblByb2dyZXNzKHN0YXRzLCBjb250ZXh0LCBkYXRhLCB4aHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgX3Jlc3BvbnNlID0ge1xuICAgICAgICAgICAgICB1cmw6IHhoci5yZXNwb25zZVVSTCxcbiAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgY29kZTogc3RhdHVzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgKF90aGlzJGNhbGxiYWNrczQgPSB0aGlzLmNhbGxiYWNrcykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGNhbGxiYWNrczQub25TdWNjZXNzKF9yZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIHhocik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIGJhZCBzdGF0dXMgb3IgbnVsbGlzaCByZXNwb25zZVxuICAgICAgICBjb25zdCByZXRyeUNvbmZpZyA9IGNvbmZpZy5sb2FkUG9saWN5LmVycm9yUmV0cnk7XG4gICAgICAgIGNvbnN0IHJldHJ5Q291bnQgPSBzdGF0cy5yZXRyeTtcbiAgICAgICAgLy8gaWYgbWF4IG5iIG9mIHJldHJpZXMgcmVhY2hlZCBvciBpZiBodHRwIHN0YXR1cyBiZXR3ZWVuIDQwMCBhbmQgNDk5IChzdWNoIGVycm9yIGNhbm5vdCBiZSByZWNvdmVyZWQsIHJldHJ5aW5nIGlzIHVzZWxlc3MpLCByZXR1cm4gZXJyb3JcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgdXJsOiBjb250ZXh0LnVybCxcbiAgICAgICAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgICAgICAgY29kZTogc3RhdHVzXG4gICAgICAgIH07XG4gICAgICAgIGlmIChzaG91bGRSZXRyeShyZXRyeUNvbmZpZywgcmV0cnlDb3VudCwgZmFsc2UsIHJlc3BvbnNlKSkge1xuICAgICAgICAgIHRoaXMucmV0cnkocmV0cnlDb25maWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfdGhpcyRjYWxsYmFja3M1O1xuICAgICAgICAgIGxvZ2dlci5lcnJvcihgJHtzdGF0dXN9IHdoaWxlIGxvYWRpbmcgJHtjb250ZXh0LnVybH1gKTtcbiAgICAgICAgICAoX3RoaXMkY2FsbGJhY2tzNSA9IHRoaXMuY2FsbGJhY2tzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkY2FsbGJhY2tzNS5vbkVycm9yKHtcbiAgICAgICAgICAgIGNvZGU6IHN0YXR1cyxcbiAgICAgICAgICAgIHRleHQ6IHhoci5zdGF0dXNUZXh0XG4gICAgICAgICAgfSwgY29udGV4dCwgeGhyLCBzdGF0cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbG9hZHRpbWVvdXQoKSB7XG4gICAgaWYgKCF0aGlzLmNvbmZpZykgcmV0dXJuO1xuICAgIGNvbnN0IHJldHJ5Q29uZmlnID0gdGhpcy5jb25maWcubG9hZFBvbGljeS50aW1lb3V0UmV0cnk7XG4gICAgY29uc3QgcmV0cnlDb3VudCA9IHRoaXMuc3RhdHMucmV0cnk7XG4gICAgaWYgKHNob3VsZFJldHJ5KHJldHJ5Q29uZmlnLCByZXRyeUNvdW50LCB0cnVlKSkge1xuICAgICAgdGhpcy5yZXRyeShyZXRyeUNvbmZpZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfdGhpcyRjb250ZXh0O1xuICAgICAgbG9nZ2VyLndhcm4oYHRpbWVvdXQgd2hpbGUgbG9hZGluZyAkeyhfdGhpcyRjb250ZXh0ID0gdGhpcy5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkY29udGV4dC51cmx9YCk7XG4gICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrcztcbiAgICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICAgdGhpcy5hYm9ydEludGVybmFsKCk7XG4gICAgICAgIGNhbGxiYWNrcy5vblRpbWVvdXQodGhpcy5zdGF0cywgdGhpcy5jb250ZXh0LCB0aGlzLmxvYWRlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHJ5KHJldHJ5Q29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dCxcbiAgICAgIHN0YXRzXG4gICAgfSA9IHRoaXM7XG4gICAgdGhpcy5yZXRyeURlbGF5ID0gZ2V0UmV0cnlEZWxheShyZXRyeUNvbmZpZywgc3RhdHMucmV0cnkpO1xuICAgIHN0YXRzLnJldHJ5Kys7XG4gICAgbG9nZ2VyLndhcm4oYCR7c3RhdHVzID8gJ0hUVFAgU3RhdHVzICcgKyBzdGF0dXMgOiAnVGltZW91dCd9IHdoaWxlIGxvYWRpbmcgJHtjb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiBjb250ZXh0LnVybH0sIHJldHJ5aW5nICR7c3RhdHMucmV0cnl9LyR7cmV0cnlDb25maWcubWF4TnVtUmV0cnl9IGluICR7dGhpcy5yZXRyeURlbGF5fW1zYCk7XG4gICAgLy8gYWJvcnQgYW5kIHJlc2V0IGludGVybmFsIHN0YXRlXG4gICAgdGhpcy5hYm9ydEludGVybmFsKCk7XG4gICAgdGhpcy5sb2FkZXIgPSBudWxsO1xuICAgIC8vIHNjaGVkdWxlIHJldHJ5XG4gICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXRyeVRpbWVvdXQpO1xuICAgIHRoaXMucmV0cnlUaW1lb3V0ID0gc2VsZi5zZXRUaW1lb3V0KHRoaXMubG9hZEludGVybmFsLmJpbmQodGhpcyksIHRoaXMucmV0cnlEZWxheSk7XG4gIH1cbiAgbG9hZHByb2dyZXNzKGV2ZW50KSB7XG4gICAgY29uc3Qgc3RhdHMgPSB0aGlzLnN0YXRzO1xuICAgIHN0YXRzLmxvYWRlZCA9IGV2ZW50LmxvYWRlZDtcbiAgICBpZiAoZXZlbnQubGVuZ3RoQ29tcHV0YWJsZSkge1xuICAgICAgc3RhdHMudG90YWwgPSBldmVudC50b3RhbDtcbiAgICB9XG4gIH1cbiAgZ2V0Q2FjaGVBZ2UoKSB7XG4gICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgaWYgKHRoaXMubG9hZGVyICYmIEFHRV9IRUFERVJfTElORV9SRUdFWC50ZXN0KHRoaXMubG9hZGVyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSkge1xuICAgICAgY29uc3QgYWdlSGVhZGVyID0gdGhpcy5sb2FkZXIuZ2V0UmVzcG9uc2VIZWFkZXIoJ2FnZScpO1xuICAgICAgcmVzdWx0ID0gYWdlSGVhZGVyID8gcGFyc2VGbG9hdChhZ2VIZWFkZXIpIDogbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBnZXRSZXNwb25zZUhlYWRlcihuYW1lKSB7XG4gICAgaWYgKHRoaXMubG9hZGVyICYmIG5ldyBSZWdFeHAoYF4ke25hbWV9OlxcXFxzKltcXFxcZC5dK1xcXFxzKiRgLCAnaW0nKS50ZXN0KHRoaXMubG9hZGVyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSkge1xuICAgICAgcmV0dXJuIHRoaXMubG9hZGVyLmdldFJlc3BvbnNlSGVhZGVyKG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIHVzZSBmcmFnTG9hZFBvbGljeS5kZWZhdWx0XG4gKi9cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCB1c2UgbWFuaWZlc3RMb2FkUG9saWN5LmRlZmF1bHQgYW5kIHBsYXlsaXN0TG9hZFBvbGljeS5kZWZhdWx0XG4gKi9cblxuY29uc3QgZGVmYXVsdExvYWRQb2xpY3kgPSB7XG4gIG1heFRpbWVUb0ZpcnN0Qnl0ZU1zOiA4MDAwLFxuICBtYXhMb2FkVGltZU1zOiAyMDAwMCxcbiAgdGltZW91dFJldHJ5OiBudWxsLFxuICBlcnJvclJldHJ5OiBudWxsXG59O1xuXG4vKipcbiAqIEBpZ25vcmVcbiAqIElmIHBvc3NpYmxlLCBrZWVwIGhsc0RlZmF1bHRDb25maWcgc2hhbGxvd1xuICogSXQgaXMgY2xvbmVkIHdoZW5ldmVyIGEgbmV3IEhscyBpbnN0YW5jZSBpcyBjcmVhdGVkLCBieSBrZWVwaW5nIHRoZSBjb25maWdcbiAqIHNoYWxsb3cgdGhlIHByb3BlcnRpZXMgYXJlIGNsb25lZCwgYW5kIHdlIGRvbid0IGVuZCB1cCBtYW5pcHVsYXRpbmcgdGhlIGRlZmF1bHRcbiAqL1xuY29uc3QgaGxzRGVmYXVsdENvbmZpZyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHtcbiAgYXV0b1N0YXJ0TG9hZDogdHJ1ZSxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBzdGFydFBvc2l0aW9uOiAtMSxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBkZWZhdWx0QXVkaW9Db2RlYzogdW5kZWZpbmVkLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGRlYnVnOiBmYWxzZSxcbiAgLy8gdXNlZCBieSBsb2dnZXJcbiAgY2FwTGV2ZWxPbkZQU0Ryb3A6IGZhbHNlLFxuICAvLyB1c2VkIGJ5IGZwcy1jb250cm9sbGVyXG4gIGNhcExldmVsVG9QbGF5ZXJTaXplOiBmYWxzZSxcbiAgLy8gdXNlZCBieSBjYXAtbGV2ZWwtY29udHJvbGxlclxuICBpZ25vcmVEZXZpY2VQaXhlbFJhdGlvOiBmYWxzZSxcbiAgLy8gdXNlZCBieSBjYXAtbGV2ZWwtY29udHJvbGxlclxuICBtYXhEZXZpY2VQaXhlbFJhdGlvOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gIC8vIHVzZWQgYnkgY2FwLWxldmVsLWNvbnRyb2xsZXJcbiAgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlOiB0cnVlLFxuICBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZTogMSxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBtYXhCdWZmZXJMZW5ndGg6IDMwLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGJhY2tCdWZmZXJMZW5ndGg6IEluZmluaXR5LFxuICAvLyB1c2VkIGJ5IGJ1ZmZlci1jb250cm9sbGVyXG4gIGZyb250QnVmZmVyRmx1c2hUaHJlc2hvbGQ6IEluZmluaXR5LFxuICBzdGFydE9uU2VnbWVudEJvdW5kYXJ5OiBmYWxzZSxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBtYXhCdWZmZXJTaXplOiA2MCAqIDEwMDAgKiAxMDAwLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIG1heEZyYWdMb29rVXBUb2xlcmFuY2U6IDAuMjUsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgbWF4QnVmZmVySG9sZTogMC4xLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyIGFuZCBnYXAtY29udHJvbGxlclxuICBkZXRlY3RTdGFsbFdpdGhDdXJyZW50VGltZU1zOiAxMjUwLFxuICAvLyB1c2VkIGJ5IGdhcC1jb250cm9sbGVyXG4gIGhpZ2hCdWZmZXJXYXRjaGRvZ1BlcmlvZDogMixcbiAgLy8gdXNlZCBieSBnYXAtY29udHJvbGxlclxuICBudWRnZU9mZnNldDogMC4xLFxuICAvLyB1c2VkIGJ5IGdhcC1jb250cm9sbGVyXG4gIG51ZGdlTWF4UmV0cnk6IDMsXG4gIC8vIHVzZWQgYnkgZ2FwLWNvbnRyb2xsZXJcbiAgbnVkZ2VPblZpZGVvSG9sZTogdHJ1ZSxcbiAgLy8gdXNlZCBieSBnYXAtY29udHJvbGxlclxuICBsaXZlU3luY01vZGU6ICdlZGdlJyxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBsaXZlU3luY0R1cmF0aW9uQ291bnQ6IDMsXG4gIC8vIHVzZWQgYnkgbGF0ZW5jeS1jb250cm9sbGVyXG4gIGxpdmVTeW5jT25TdGFsbEluY3JlYXNlOiAxLFxuICAvLyB1c2VkIGJ5IGxhdGVuY3ktY29udHJvbGxlclxuICBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQ6IEluZmluaXR5LFxuICAvLyB1c2VkIGJ5IGxhdGVuY3ktY29udHJvbGxlclxuICBsaXZlU3luY0R1cmF0aW9uOiB1bmRlZmluZWQsXG4gIC8vIHVzZWQgYnkgbGF0ZW5jeS1jb250cm9sbGVyXG4gIGxpdmVNYXhMYXRlbmN5RHVyYXRpb246IHVuZGVmaW5lZCxcbiAgLy8gdXNlZCBieSBsYXRlbmN5LWNvbnRyb2xsZXJcbiAgbWF4TGl2ZVN5bmNQbGF5YmFja1JhdGU6IDEsXG4gIC8vIHVzZWQgYnkgbGF0ZW5jeS1jb250cm9sbGVyXG4gIGxpdmVEdXJhdGlvbkluZmluaXR5OiBmYWxzZSxcbiAgLy8gdXNlZCBieSBidWZmZXItY29udHJvbGxlclxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGJhY2tCdWZmZXJMZW5ndGhcbiAgICovXG4gIGxpdmVCYWNrQnVmZmVyTGVuZ3RoOiBudWxsLFxuICAvLyB1c2VkIGJ5IGJ1ZmZlci1jb250cm9sbGVyXG4gIG1heE1heEJ1ZmZlckxlbmd0aDogNjAwLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGVuYWJsZVdvcmtlcjogdHJ1ZSxcbiAgLy8gdXNlZCBieSB0cmFuc211eGVyXG4gIHdvcmtlclBhdGg6IG51bGwsXG4gIC8vIHVzZWQgYnkgdHJhbnNtdXhlclxuICBlbmFibGVTb2Z0d2FyZUFFUzogdHJ1ZSxcbiAgLy8gdXNlZCBieSBkZWNyeXB0ZXJcbiAgc3RhcnRMZXZlbDogdW5kZWZpbmVkLFxuICAvLyB1c2VkIGJ5IGxldmVsLWNvbnRyb2xsZXJcbiAgc3RhcnRGcmFnUHJlZmV0Y2g6IGZhbHNlLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGZwc0Ryb3BwZWRNb25pdG9yaW5nUGVyaW9kOiA1MDAwLFxuICAvLyB1c2VkIGJ5IGZwcy1jb250cm9sbGVyXG4gIGZwc0Ryb3BwZWRNb25pdG9yaW5nVGhyZXNob2xkOiAwLjIsXG4gIC8vIHVzZWQgYnkgZnBzLWNvbnRyb2xsZXJcbiAgYXBwZW5kRXJyb3JNYXhSZXRyeTogMyxcbiAgLy8gdXNlZCBieSBidWZmZXItY29udHJvbGxlclxuICBpZ25vcmVQbGF5bGlzdFBhcnNpbmdFcnJvcnM6IGZhbHNlLFxuICBsb2FkZXI6IFhockxvYWRlcixcbiAgLy8gbG9hZGVyOiBGZXRjaExvYWRlcixcbiAgZkxvYWRlcjogdW5kZWZpbmVkLFxuICAvLyB1c2VkIGJ5IGZyYWdtZW50LWxvYWRlclxuICBwTG9hZGVyOiB1bmRlZmluZWQsXG4gIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXG4gIHhoclNldHVwOiB1bmRlZmluZWQsXG4gIC8vIHVzZWQgYnkgeGhyLWxvYWRlclxuICBsaWNlbnNlWGhyU2V0dXA6IHVuZGVmaW5lZCxcbiAgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICBsaWNlbnNlUmVzcG9uc2VDYWxsYmFjazogdW5kZWZpbmVkLFxuICAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gIGFickNvbnRyb2xsZXI6IEFickNvbnRyb2xsZXIsXG4gIGJ1ZmZlckNvbnRyb2xsZXI6IEJ1ZmZlckNvbnRyb2xsZXIsXG4gIGNhcExldmVsQ29udHJvbGxlcjogQ2FwTGV2ZWxDb250cm9sbGVyLFxuICBlcnJvckNvbnRyb2xsZXI6IEVycm9yQ29udHJvbGxlcixcbiAgZnBzQ29udHJvbGxlcjogRlBTQ29udHJvbGxlcixcbiAgc3RyZXRjaFNob3J0VmlkZW9UcmFjazogZmFsc2UsXG4gIC8vIHVzZWQgYnkgbXA0LXJlbXV4ZXJcbiAgbWF4QXVkaW9GcmFtZXNEcmlmdDogMSxcbiAgLy8gdXNlZCBieSBtcDQtcmVtdXhlclxuICBmb3JjZUtleUZyYW1lT25EaXNjb250aW51aXR5OiB0cnVlLFxuICAvLyB1c2VkIGJ5IHRzLWRlbXV4ZXJcbiAgYWJyRXdtYUZhc3RMaXZlOiAzLFxuICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIGFickV3bWFTbG93TGl2ZTogOSxcbiAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJFd21hRmFzdFZvRDogMyxcbiAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJFd21hU2xvd1ZvRDogOSxcbiAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJFd21hRGVmYXVsdEVzdGltYXRlOiA1ZTUsXG4gIC8vIDUwMCBrYnBzICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIGFickV3bWFEZWZhdWx0RXN0aW1hdGVNYXg6IDVlNixcbiAgLy8gNSBtYnBzXG4gIGFickJhbmRXaWR0aEZhY3RvcjogMC45NSxcbiAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJCYW5kV2lkdGhVcEZhY3RvcjogMC43LFxuICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIGFick1heFdpdGhSZWFsQml0cmF0ZTogZmFsc2UsXG4gIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgbWF4U3RhcnZhdGlvbkRlbGF5OiA0LFxuICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIG1heExvYWRpbmdEZWxheTogNCxcbiAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBtaW5BdXRvQml0cmF0ZTogMCxcbiAgLy8gdXNlZCBieSBobHNcbiAgZW1lRW5hYmxlZDogZmFsc2UsXG4gIC8vIHVzZWQgYnkgZW1lLWNvbnRyb2xsZXJcbiAgd2lkZXZpbmVMaWNlbnNlVXJsOiB1bmRlZmluZWQsXG4gIC8vIHVzZWQgYnkgZW1lLWNvbnRyb2xsZXJcbiAgZHJtU3lzdGVtczoge30sXG4gIC8vIHVzZWQgYnkgZW1lLWNvbnRyb2xsZXJcbiAgZHJtU3lzdGVtT3B0aW9uczoge30sXG4gIC8vIHVzZWQgYnkgZW1lLWNvbnRyb2xsZXJcbiAgcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzRnVuYzogcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzICxcbiAgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICByZXF1aXJlS2V5U3lzdGVtQWNjZXNzT25TdGFydDogZmFsc2UsXG4gIC8vIHVzZWQgYnkgZW1lLWNvbnRyb2xsZXJcbiAgdGVzdEJhbmR3aWR0aDogdHJ1ZSxcbiAgcHJvZ3Jlc3NpdmU6IGZhbHNlLFxuICBsb3dMYXRlbmN5TW9kZTogdHJ1ZSxcbiAgY21jZDogdW5kZWZpbmVkLFxuICBlbmFibGVEYXRlUmFuZ2VNZXRhZGF0YUN1ZXM6IHRydWUsXG4gIGVuYWJsZUVtc2dNZXRhZGF0YUN1ZXM6IHRydWUsXG4gIGVuYWJsZUVtc2dLTFZNZXRhZGF0YTogZmFsc2UsXG4gIGVuYWJsZUlEM01ldGFkYXRhQ3VlczogdHJ1ZSxcbiAgZW5hYmxlSW50ZXJzdGl0aWFsUGxheWJhY2s6IHRydWUsXG4gIGludGVyc3RpdGlhbEFwcGVuZEluUGxhY2U6IHRydWUsXG4gIGludGVyc3RpdGlhbExpdmVMb29rQWhlYWQ6IDEwLFxuICB1c2VNZWRpYUNhcGFiaWxpdGllczogdHJ1ZSxcbiAgcHJlc2VydmVNYW51YWxMZXZlbE9uRXJyb3I6IGZhbHNlLFxuICBjZXJ0TG9hZFBvbGljeToge1xuICAgIGRlZmF1bHQ6IGRlZmF1bHRMb2FkUG9saWN5XG4gIH0sXG4gIGtleUxvYWRQb2xpY3k6IHtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBtYXhUaW1lVG9GaXJzdEJ5dGVNczogODAwMCxcbiAgICAgIG1heExvYWRUaW1lTXM6IDIwMDAwLFxuICAgICAgdGltZW91dFJldHJ5OiB7XG4gICAgICAgIG1heE51bVJldHJ5OiAxLFxuICAgICAgICByZXRyeURlbGF5TXM6IDEwMDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXlNczogMjAwMDAsXG4gICAgICAgIGJhY2tvZmY6ICdsaW5lYXInXG4gICAgICB9LFxuICAgICAgZXJyb3JSZXRyeToge1xuICAgICAgICBtYXhOdW1SZXRyeTogOCxcbiAgICAgICAgcmV0cnlEZWxheU1zOiAxMDAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDIwMDAwLFxuICAgICAgICBiYWNrb2ZmOiAnbGluZWFyJ1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbWFuaWZlc3RMb2FkUG9saWN5OiB7XG4gICAgZGVmYXVsdDoge1xuICAgICAgbWF4VGltZVRvRmlyc3RCeXRlTXM6IEluZmluaXR5LFxuICAgICAgbWF4TG9hZFRpbWVNczogMjAwMDAsXG4gICAgICB0aW1lb3V0UmV0cnk6IHtcbiAgICAgICAgbWF4TnVtUmV0cnk6IDIsXG4gICAgICAgIHJldHJ5RGVsYXlNczogMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheU1zOiAwXG4gICAgICB9LFxuICAgICAgZXJyb3JSZXRyeToge1xuICAgICAgICBtYXhOdW1SZXRyeTogMSxcbiAgICAgICAgcmV0cnlEZWxheU1zOiAxMDAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDgwMDBcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHBsYXlsaXN0TG9hZFBvbGljeToge1xuICAgIGRlZmF1bHQ6IHtcbiAgICAgIG1heFRpbWVUb0ZpcnN0Qnl0ZU1zOiAxMDAwMCxcbiAgICAgIG1heExvYWRUaW1lTXM6IDIwMDAwLFxuICAgICAgdGltZW91dFJldHJ5OiB7XG4gICAgICAgIG1heE51bVJldHJ5OiAyLFxuICAgICAgICByZXRyeURlbGF5TXM6IDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXlNczogMFxuICAgICAgfSxcbiAgICAgIGVycm9yUmV0cnk6IHtcbiAgICAgICAgbWF4TnVtUmV0cnk6IDIsXG4gICAgICAgIHJldHJ5RGVsYXlNczogMTAwMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheU1zOiA4MDAwXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBmcmFnTG9hZFBvbGljeToge1xuICAgIGRlZmF1bHQ6IHtcbiAgICAgIG1heFRpbWVUb0ZpcnN0Qnl0ZU1zOiAxMDAwMCxcbiAgICAgIG1heExvYWRUaW1lTXM6IDEyMDAwMCxcbiAgICAgIHRpbWVvdXRSZXRyeToge1xuICAgICAgICBtYXhOdW1SZXRyeTogNCxcbiAgICAgICAgcmV0cnlEZWxheU1zOiAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDBcbiAgICAgIH0sXG4gICAgICBlcnJvclJldHJ5OiB7XG4gICAgICAgIG1heE51bVJldHJ5OiA2LFxuICAgICAgICByZXRyeURlbGF5TXM6IDEwMDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXlNczogODAwMFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgc3RlZXJpbmdNYW5pZmVzdExvYWRQb2xpY3k6IHtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBtYXhUaW1lVG9GaXJzdEJ5dGVNczogMTAwMDAsXG4gICAgICBtYXhMb2FkVGltZU1zOiAyMDAwMCxcbiAgICAgIHRpbWVvdXRSZXRyeToge1xuICAgICAgICBtYXhOdW1SZXRyeTogMixcbiAgICAgICAgcmV0cnlEZWxheU1zOiAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDBcbiAgICAgIH0sXG4gICAgICBlcnJvclJldHJ5OiB7XG4gICAgICAgIG1heE51bVJldHJ5OiAxLFxuICAgICAgICByZXRyeURlbGF5TXM6IDEwMDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXlNczogODAwMFxuICAgICAgfVxuICAgIH0gXG4gIH0sXG4gIGludGVyc3RpdGlhbEFzc2V0TGlzdExvYWRQb2xpY3k6IHtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBtYXhUaW1lVG9GaXJzdEJ5dGVNczogMTAwMDAsXG4gICAgICBtYXhMb2FkVGltZU1zOiAzMDAwMCxcbiAgICAgIHRpbWVvdXRSZXRyeToge1xuICAgICAgICBtYXhOdW1SZXRyeTogMCxcbiAgICAgICAgcmV0cnlEZWxheU1zOiAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDBcbiAgICAgIH0sXG4gICAgICBlcnJvclJldHJ5OiB7XG4gICAgICAgIG1heE51bVJldHJ5OiAwLFxuICAgICAgICByZXRyeURlbGF5TXM6IDEwMDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXlNczogODAwMFxuICAgICAgfVxuICAgIH0gXG4gIH0sXG4gIC8vIFRoZXNlIGRlZmF1bHQgc2V0dGluZ3MgYXJlIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgdGhlIGFib3ZlIHBvbGljaWVzXG4gIC8vIGFuZCBhcmUgbWFpbnRhaW5lZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgbWFuaWZlc3RMb2FkaW5nVGltZU91dDogMTAwMDAsXG4gIG1hbmlmZXN0TG9hZGluZ01heFJldHJ5OiAxLFxuICBtYW5pZmVzdExvYWRpbmdSZXRyeURlbGF5OiAxMDAwLFxuICBtYW5pZmVzdExvYWRpbmdNYXhSZXRyeVRpbWVvdXQ6IDY0MDAwLFxuICBsZXZlbExvYWRpbmdUaW1lT3V0OiAxMDAwMCxcbiAgbGV2ZWxMb2FkaW5nTWF4UmV0cnk6IDQsXG4gIGxldmVsTG9hZGluZ1JldHJ5RGVsYXk6IDEwMDAsXG4gIGxldmVsTG9hZGluZ01heFJldHJ5VGltZW91dDogNjQwMDAsXG4gIGZyYWdMb2FkaW5nVGltZU91dDogMjAwMDAsXG4gIGZyYWdMb2FkaW5nTWF4UmV0cnk6IDYsXG4gIGZyYWdMb2FkaW5nUmV0cnlEZWxheTogMTAwMCxcbiAgZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXQ6IDY0MDAwXG59LCB0aW1lbGluZUNvbmZpZygpKSwge30sIHtcbiAgc3VidGl0bGVTdHJlYW1Db250cm9sbGVyOiBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIgLFxuICBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjogU3VidGl0bGVUcmFja0NvbnRyb2xsZXIgLFxuICB0aW1lbGluZUNvbnRyb2xsZXI6IFRpbWVsaW5lQ29udHJvbGxlciAsXG4gIGF1ZGlvU3RyZWFtQ29udHJvbGxlcjogQXVkaW9TdHJlYW1Db250cm9sbGVyICxcbiAgYXVkaW9UcmFja0NvbnRyb2xsZXI6IEF1ZGlvVHJhY2tDb250cm9sbGVyICxcbiAgZW1lQ29udHJvbGxlcjogRU1FQ29udHJvbGxlciAsXG4gIGNtY2RDb250cm9sbGVyOiBDTUNEQ29udHJvbGxlciAsXG4gIGNvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXI6IENvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXIgLFxuICBpbnRlcnN0aXRpYWxzQ29udHJvbGxlcjogSW50ZXJzdGl0aWFsc0NvbnRyb2xsZXIgXG59KTtcbmZ1bmN0aW9uIHRpbWVsaW5lQ29uZmlnKCkge1xuICByZXR1cm4ge1xuICAgIGN1ZUhhbmRsZXI6IEN1ZXMsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgZW5hYmxlV2ViVlRUOiB0cnVlLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGVuYWJsZUlNU0MxOiB0cnVlLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGVuYWJsZUNFQTcwOENhcHRpb25zOiB0cnVlLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrMUxhYmVsOiAnRW5nbGlzaCcsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgY2FwdGlvbnNUZXh0VHJhY2sxTGFuZ3VhZ2VDb2RlOiAnZW4nLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrMkxhYmVsOiAnU3BhbmlzaCcsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgY2FwdGlvbnNUZXh0VHJhY2syTGFuZ3VhZ2VDb2RlOiAnZXMnLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrM0xhYmVsOiAnVW5rbm93biBDQycsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgY2FwdGlvbnNUZXh0VHJhY2szTGFuZ3VhZ2VDb2RlOiAnJyxcbiAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBjYXB0aW9uc1RleHRUcmFjazRMYWJlbDogJ1Vua25vd24gQ0MnLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrNExhbmd1YWdlQ29kZTogJycsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgcmVuZGVyVGV4dFRyYWNrc05hdGl2ZWx5OiB0cnVlXG4gIH07XG59XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBtZXJnZUNvbmZpZyhkZWZhdWx0Q29uZmlnLCB1c2VyQ29uZmlnLCBsb2dnZXIpIHtcbiAgaWYgKCh1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCB8fCB1c2VyQ29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCkgJiYgKHVzZXJDb25maWcubGl2ZVN5bmNEdXJhdGlvbiB8fCB1c2VyQ29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBobHMuanMgY29uZmlnOiBkb24ndCBtaXggdXAgbGl2ZVN5bmNEdXJhdGlvbkNvdW50L2xpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCBhbmQgbGl2ZVN5bmNEdXJhdGlvbi9saXZlTWF4TGF0ZW5jeUR1cmF0aW9uXCIpO1xuICB9XG4gIGlmICh1c2VyQ29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCAhPT0gdW5kZWZpbmVkICYmICh1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCA9PT0gdW5kZWZpbmVkIHx8IHVzZXJDb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50IDw9IHVzZXJDb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBobHMuanMgY29uZmlnOiBcImxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudFwiIG11c3QgYmUgZ3JlYXRlciB0aGFuIFwibGl2ZVN5bmNEdXJhdGlvbkNvdW50XCInKTtcbiAgfVxuICBpZiAodXNlckNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uICE9PSB1bmRlZmluZWQgJiYgKHVzZXJDb25maWcubGl2ZVN5bmNEdXJhdGlvbiA9PT0gdW5kZWZpbmVkIHx8IHVzZXJDb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiA8PSB1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb24pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGhscy5qcyBjb25maWc6IFwibGl2ZU1heExhdGVuY3lEdXJhdGlvblwiIG11c3QgYmUgZ3JlYXRlciB0aGFuIFwibGl2ZVN5bmNEdXJhdGlvblwiJyk7XG4gIH1cbiAgY29uc3QgZGVmYXVsdHNDb3B5ID0gZGVlcENweShkZWZhdWx0Q29uZmlnKTtcblxuICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIGRlcHJlY2F0ZWQgY29uZmlnIHZhbHVlc1xuICBjb25zdCBkZXByZWNhdGVkU2V0dGluZ1R5cGVzID0gWydtYW5pZmVzdCcsICdsZXZlbCcsICdmcmFnJ107XG4gIGNvbnN0IGRlcHJlY2F0ZWRTZXR0aW5ncyA9IFsnVGltZU91dCcsICdNYXhSZXRyeScsICdSZXRyeURlbGF5JywgJ01heFJldHJ5VGltZW91dCddO1xuICBkZXByZWNhdGVkU2V0dGluZ1R5cGVzLmZvckVhY2godHlwZSA9PiB7XG4gICAgY29uc3QgcG9saWN5TmFtZSA9IGAke3R5cGUgPT09ICdsZXZlbCcgPyAncGxheWxpc3QnIDogdHlwZX1Mb2FkUG9saWN5YDtcbiAgICBjb25zdCBwb2xpY3lOb3RTZXQgPSB1c2VyQ29uZmlnW3BvbGljeU5hbWVdID09PSB1bmRlZmluZWQ7XG4gICAgY29uc3QgcmVwb3J0ID0gW107XG4gICAgZGVwcmVjYXRlZFNldHRpbmdzLmZvckVhY2goc2V0dGluZyA9PiB7XG4gICAgICBjb25zdCBkZXByZWNhdGVkU2V0dGluZyA9IGAke3R5cGV9TG9hZGluZyR7c2V0dGluZ31gO1xuICAgICAgY29uc3QgdmFsdWUgPSB1c2VyQ29uZmlnW2RlcHJlY2F0ZWRTZXR0aW5nXTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHBvbGljeU5vdFNldCkge1xuICAgICAgICByZXBvcnQucHVzaChkZXByZWNhdGVkU2V0dGluZyk7XG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gZGVmYXVsdHNDb3B5W3BvbGljeU5hbWVdLmRlZmF1bHQ7XG4gICAgICAgIHVzZXJDb25maWdbcG9saWN5TmFtZV0gPSB7XG4gICAgICAgICAgZGVmYXVsdDogc2V0dGluZ3NcbiAgICAgICAgfTtcbiAgICAgICAgc3dpdGNoIChzZXR0aW5nKSB7XG4gICAgICAgICAgY2FzZSAnVGltZU91dCc6XG4gICAgICAgICAgICBzZXR0aW5ncy5tYXhMb2FkVGltZU1zID0gdmFsdWU7XG4gICAgICAgICAgICBzZXR0aW5ncy5tYXhUaW1lVG9GaXJzdEJ5dGVNcyA9IHZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnTWF4UmV0cnknOlxuICAgICAgICAgICAgc2V0dGluZ3MuZXJyb3JSZXRyeS5tYXhOdW1SZXRyeSA9IHZhbHVlO1xuICAgICAgICAgICAgc2V0dGluZ3MudGltZW91dFJldHJ5Lm1heE51bVJldHJ5ID0gdmFsdWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdSZXRyeURlbGF5JzpcbiAgICAgICAgICAgIHNldHRpbmdzLmVycm9yUmV0cnkucmV0cnlEZWxheU1zID0gdmFsdWU7XG4gICAgICAgICAgICBzZXR0aW5ncy50aW1lb3V0UmV0cnkucmV0cnlEZWxheU1zID0gdmFsdWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdNYXhSZXRyeVRpbWVvdXQnOlxuICAgICAgICAgICAgc2V0dGluZ3MuZXJyb3JSZXRyeS5tYXhSZXRyeURlbGF5TXMgPSB2YWx1ZTtcbiAgICAgICAgICAgIHNldHRpbmdzLnRpbWVvdXRSZXRyeS5tYXhSZXRyeURlbGF5TXMgPSB2YWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHJlcG9ydC5sZW5ndGgpIHtcbiAgICAgIGxvZ2dlci53YXJuKGBobHMuanMgY29uZmlnOiBcIiR7cmVwb3J0LmpvaW4oJ1wiLCBcIicpfVwiIHNldHRpbmcocykgYXJlIGRlcHJlY2F0ZWQsIHVzZSBcIiR7cG9saWN5TmFtZX1cIjogJHtzdHJpbmdpZnkodXNlckNvbmZpZ1twb2xpY3lOYW1lXSl9YCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBkZWZhdWx0c0NvcHkpLCB1c2VyQ29uZmlnKTtcbn1cbmZ1bmN0aW9uIGRlZXBDcHkob2JqKSB7XG4gIGlmIChvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICByZXR1cm4gb2JqLm1hcChkZWVwQ3B5KTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikucmVkdWNlKChyZXN1bHQsIGtleSkgPT4ge1xuICAgICAgcmVzdWx0W2tleV0gPSBkZWVwQ3B5KG9ialtrZXldKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwge30pO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBlbmFibGVTdHJlYW1pbmdNb2RlKGNvbmZpZywgbG9nZ2VyKSB7XG4gIGNvbnN0IGN1cnJlbnRMb2FkZXIgPSBjb25maWcubG9hZGVyO1xuICBpZiAoY3VycmVudExvYWRlciAhPT0gRmV0Y2hMb2FkZXIgJiYgY3VycmVudExvYWRlciAhPT0gWGhyTG9hZGVyKSB7XG4gICAgLy8gSWYgYSBkZXZlbG9wZXIgaGFzIGNvbmZpZ3VyZWQgdGhlaXIgb3duIGxvYWRlciwgcmVzcGVjdCB0aGF0IGNob2ljZVxuICAgIGxvZ2dlci5sb2coJ1tjb25maWddOiBDdXN0b20gbG9hZGVyIGRldGVjdGVkLCBjYW5ub3QgZW5hYmxlIHByb2dyZXNzaXZlIHN0cmVhbWluZycpO1xuICAgIGNvbmZpZy5wcm9ncmVzc2l2ZSA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNhblN0cmVhbVByb2dyZXNzaXZlbHkgPSBmZXRjaFN1cHBvcnRlZCgpO1xuICAgIGlmIChjYW5TdHJlYW1Qcm9ncmVzc2l2ZWx5KSB7XG4gICAgICBjb25maWcubG9hZGVyID0gRmV0Y2hMb2FkZXI7XG4gICAgICBjb25maWcucHJvZ3Jlc3NpdmUgPSB0cnVlO1xuICAgICAgY29uZmlnLmVuYWJsZVNvZnR3YXJlQUVTID0gdHJ1ZTtcbiAgICAgIGxvZ2dlci5sb2coJ1tjb25maWddOiBQcm9ncmVzc2l2ZSBzdHJlYW1pbmcgZW5hYmxlZCwgdXNpbmcgRmV0Y2hMb2FkZXInKTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgTUFYX1NUQVJUX0dBUF9KVU1QID0gMi4wO1xuY29uc3QgU0tJUF9CVUZGRVJfSE9MRV9TVEVQX1NFQ09ORFMgPSAwLjE7XG5jb25zdCBTS0lQX0JVRkZFUl9SQU5HRV9TVEFSVCA9IDAuMDU7XG5jb25zdCBUSUNLX0lOVEVSVkFMJDEgPSAxMDA7XG5jbGFzcyBHYXBDb250cm9sbGVyIGV4dGVuZHMgVGFza0xvb3Age1xuICBjb25zdHJ1Y3RvcihobHMsIGZyYWdtZW50VHJhY2tlcikge1xuICAgIHN1cGVyKCdnYXAtY29udHJvbGxlcicsIGhscy5sb2dnZXIpO1xuICAgIHRoaXMuaGxzID0gbnVsbDtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlciA9IG51bGw7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5tZWRpYVNvdXJjZSA9IHZvaWQgMDtcbiAgICB0aGlzLm51ZGdlUmV0cnkgPSAwO1xuICAgIHRoaXMuc3RhbGxSZXBvcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuc3RhbGxlZCA9IG51bGw7XG4gICAgdGhpcy5tb3ZlZCA9IGZhbHNlO1xuICAgIHRoaXMuc2Vla2luZyA9IGZhbHNlO1xuICAgIHRoaXMuYnVmZmVyZWQgPSB7fTtcbiAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XG4gICAgdGhpcy5lbmRlZCA9IDA7XG4gICAgdGhpcy53YWl0aW5nID0gMDtcbiAgICB0aGlzLm9uTWVkaWFQbGF5aW5nID0gKCkgPT4ge1xuICAgICAgdGhpcy5lbmRlZCA9IDA7XG4gICAgICB0aGlzLndhaXRpbmcgPSAwO1xuICAgIH07XG4gICAgdGhpcy5vbk1lZGlhV2FpdGluZyA9ICgpID0+IHtcbiAgICAgIHZhciBfdGhpcyRtZWRpYTtcbiAgICAgIGlmICgoX3RoaXMkbWVkaWEgPSB0aGlzLm1lZGlhKSAhPSBudWxsICYmIF90aGlzJG1lZGlhLnNlZWtpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy53YWl0aW5nID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH07XG4gICAgdGhpcy5vbk1lZGlhRW5kZWQgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5obHMpIHtcbiAgICAgICAgdmFyIF90aGlzJG1lZGlhMjtcbiAgICAgICAgLy8gZW5kZWQgaXMgc2V0IHdoZW4gdHJpZ2dlcmluZyBNRURJQV9FTkRFRCBzbyB0aGF0IHdlIGRvIG5vdCB0cmlnZ2VyIGl0IGFnYWluIG9uIHN0YWxsIG9yIG9uIHRpY2sgd2l0aCBtZWRpYS5lbmRlZFxuICAgICAgICB0aGlzLmVuZGVkID0gKChfdGhpcyRtZWRpYTIgPSB0aGlzLm1lZGlhKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbWVkaWEyLmN1cnJlbnRUaW1lKSB8fCAxO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5NRURJQV9FTkRFRCwge1xuICAgICAgICAgIHN0YWxsZWQ6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIgPSBmcmFnbWVudFRyYWNrZXI7XG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmIChobHMpIHtcbiAgICAgIGhscy5vbihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfQVBQRU5ERUQsIHRoaXMub25CdWZmZXJBcHBlbmRlZCwgdGhpcyk7XG4gICAgfVxuICB9XG4gIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGhscykge1xuICAgICAgaGxzLm9mZihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9BUFBFTkRFRCwgdGhpcy5vbkJ1ZmZlckFwcGVuZGVkLCB0aGlzKTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5tZWRpYSA9IHRoaXMuaGxzID0gdGhpcy5mcmFnbWVudFRyYWNrZXIgPSBudWxsO1xuICAgIHRoaXMubWVkaWFTb3VyY2UgPSB1bmRlZmluZWQ7XG4gIH1cbiAgb25NZWRpYUF0dGFjaGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5zZXRJbnRlcnZhbChUSUNLX0lOVEVSVkFMJDEpO1xuICAgIHRoaXMubWVkaWFTb3VyY2UgPSBkYXRhLm1lZGlhU291cmNlO1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihtZWRpYSwgJ3BsYXlpbmcnLCB0aGlzLm9uTWVkaWFQbGF5aW5nKTtcbiAgICBhZGRFdmVudExpc3RlbmVyKG1lZGlhLCAnd2FpdGluZycsIHRoaXMub25NZWRpYVdhaXRpbmcpO1xuICAgIGFkZEV2ZW50TGlzdGVuZXIobWVkaWEsICdlbmRlZCcsIHRoaXMub25NZWRpYUVuZGVkKTtcbiAgfVxuICBvbk1lZGlhRGV0YWNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5jbGVhckludGVydmFsKCk7XG4gICAgY29uc3Qge1xuICAgICAgbWVkaWFcbiAgICB9ID0gdGhpcztcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIobWVkaWEsICdwbGF5aW5nJywgdGhpcy5vbk1lZGlhUGxheWluZyk7XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKG1lZGlhLCAnd2FpdGluZycsIHRoaXMub25NZWRpYVdhaXRpbmcpO1xuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihtZWRpYSwgJ2VuZGVkJywgdGhpcy5vbk1lZGlhRW5kZWQpO1xuICAgICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMubWVkaWFTb3VyY2UgPSB1bmRlZmluZWQ7XG4gIH1cbiAgb25CdWZmZXJBcHBlbmRlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMuYnVmZmVyZWQgPSBkYXRhLnRpbWVSYW5nZXM7XG4gIH1cbiAgZ2V0IGhhc0J1ZmZlcmVkKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmJ1ZmZlcmVkKS5sZW5ndGggPiAwO1xuICB9XG4gIHRpY2soKSB7XG4gICAgdmFyIF90aGlzJG1lZGlhMztcbiAgICBpZiAoISgoX3RoaXMkbWVkaWEzID0gdGhpcy5tZWRpYSkgIT0gbnVsbCAmJiBfdGhpcyRtZWRpYTMucmVhZHlTdGF0ZSkgfHwgIXRoaXMuaGFzQnVmZmVyZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIHRoaXMucG9sbChjdXJyZW50VGltZSwgdGhpcy5sYXN0Q3VycmVudFRpbWUpO1xuICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBwbGF5aGVhZCBpcyBzdHVjayB3aXRoaW4gYSBnYXAsIGFuZCBpZiBzbywgYXR0ZW1wdHMgdG8gZnJlZSBpdC5cbiAgICogQSBnYXAgaXMgYW4gdW5idWZmZXJlZCByYW5nZSBiZXR3ZWVuIHR3byBidWZmZXJlZCByYW5nZXMgKG9yIHRoZSBzdGFydCBhbmQgdGhlIGZpcnN0IGJ1ZmZlcmVkIHJhbmdlKS5cbiAgICpcbiAgICogQHBhcmFtIGxhc3RDdXJyZW50VGltZSAtIFByZXZpb3VzbHkgcmVhZCBwbGF5aGVhZCBwb3NpdGlvblxuICAgKi9cbiAgcG9sbChjdXJyZW50VGltZSwgbGFzdEN1cnJlbnRUaW1lKSB7XG4gICAgdmFyIF90aGlzJGhscywgX3RoaXMkaGxzMjtcbiAgICBjb25zdCBjb25maWcgPSAoX3RoaXMkaGxzID0gdGhpcy5obHMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRobHMuY29uZmlnO1xuICAgIGlmICghY29uZmlnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAoIW1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHNlZWtpbmdcbiAgICB9ID0gbWVkaWE7XG4gICAgY29uc3Qgc2Vla2VkID0gdGhpcy5zZWVraW5nICYmICFzZWVraW5nO1xuICAgIGNvbnN0IGJlZ2luU2VlayA9ICF0aGlzLnNlZWtpbmcgJiYgc2Vla2luZztcbiAgICBjb25zdCBwYXVzZWRFbmRlZE9ySGFsdGVkID0gbWVkaWEucGF1c2VkICYmICFzZWVraW5nIHx8IG1lZGlhLmVuZGVkIHx8IG1lZGlhLnBsYXliYWNrUmF0ZSA9PT0gMDtcbiAgICB0aGlzLnNlZWtpbmcgPSBzZWVraW5nO1xuXG4gICAgLy8gVGhlIHBsYXloZWFkIGlzIG1vdmluZywgbm8tb3BcbiAgICBpZiAoY3VycmVudFRpbWUgIT09IGxhc3RDdXJyZW50VGltZSkge1xuICAgICAgaWYgKGxhc3RDdXJyZW50VGltZSkge1xuICAgICAgICB0aGlzLmVuZGVkID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMubW92ZWQgPSB0cnVlO1xuICAgICAgaWYgKCFzZWVraW5nKSB7XG4gICAgICAgIHRoaXMubnVkZ2VSZXRyeSA9IDA7XG4gICAgICAgIC8vIFdoZW4gY3Jvc3NpbmcgYmV0d2VlbiBidWZmZXJlZCB2aWRlbyB0aW1lIHJhbmdlcywgYnV0IG5vdCBhdWRpbywgZmx1c2ggcGlwZWxpbmUgd2l0aCBzZWVrIChDaHJvbWUpXG4gICAgICAgIGlmIChjb25maWcubnVkZ2VPblZpZGVvSG9sZSAmJiAhcGF1c2VkRW5kZWRPckhhbHRlZCAmJiBjdXJyZW50VGltZSA+IGxhc3RDdXJyZW50VGltZSkge1xuICAgICAgICAgIHRoaXMubnVkZ2VPblZpZGVvSG9sZShjdXJyZW50VGltZSwgbGFzdEN1cnJlbnRUaW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMud2FpdGluZyA9PT0gMCkge1xuICAgICAgICB0aGlzLnN0YWxsUmVzb2x2ZWQoY3VycmVudFRpbWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENsZWFyIHN0YWxsZWQgc3RhdGUgd2hlbiBiZWdpbm5pbmcgb3IgZmluaXNoaW5nIHNlZWtpbmcgc28gdGhhdCB3ZSBkb24ndCByZXBvcnQgc3RhbGxzIGNvbWluZyBvdXQgb2YgYSBzZWVrXG4gICAgaWYgKGJlZ2luU2VlayB8fCBzZWVrZWQpIHtcbiAgICAgIGlmIChzZWVrZWQpIHtcbiAgICAgICAgdGhpcy5zdGFsbFJlc29sdmVkKGN1cnJlbnRUaW1lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUaGUgcGxheWhlYWQgc2hvdWxkIG5vdCBiZSBtb3ZpbmdcbiAgICBpZiAocGF1c2VkRW5kZWRPckhhbHRlZCkge1xuICAgICAgdGhpcy5udWRnZVJldHJ5ID0gMDtcbiAgICAgIHRoaXMuc3RhbGxSZXNvbHZlZChjdXJyZW50VGltZSk7XG4gICAgICAvLyBGaXJlIE1FRElBX0VOREVEIHRvIHdvcmthcm91bmQgZXZlbnQgbm90IGJlaW5nIGRpc3BhdGNoZWQgYnkgYnJvd3NlclxuICAgICAgaWYgKCF0aGlzLmVuZGVkICYmIG1lZGlhLmVuZGVkICYmIHRoaXMuaGxzKSB7XG4gICAgICAgIHRoaXMuZW5kZWQgPSBjdXJyZW50VGltZSB8fCAxO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5NRURJQV9FTkRFRCwge1xuICAgICAgICAgIHN0YWxsZWQ6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIUJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZChtZWRpYSkubGVuZ3RoKSB7XG4gICAgICB0aGlzLm51ZGdlUmV0cnkgPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFJlc29sdmUgc3RhbGxzIGF0IGJ1ZmZlciBob2xlcyB1c2luZyB0aGUgbWFpbiBidWZmZXIsIHdob3NlIHJhbmdlcyBhcmUgdGhlIGludGVyc2VjdGlvbnMgb2YgdGhlIEEvViBzb3VyY2VidWZmZXJzXG4gICAgY29uc3QgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKG1lZGlhLCBjdXJyZW50VGltZSwgMCk7XG4gICAgY29uc3QgbmV4dFN0YXJ0ID0gYnVmZmVySW5mby5uZXh0U3RhcnQgfHwgMDtcbiAgICBjb25zdCBmcmFnbWVudFRyYWNrZXIgPSB0aGlzLmZyYWdtZW50VHJhY2tlcjtcbiAgICBpZiAoc2Vla2luZyAmJiBmcmFnbWVudFRyYWNrZXIgJiYgdGhpcy5obHMpIHtcbiAgICAgIC8vIElzIHRoZXJlIGEgZnJhZ21lbnQgbG9hZGluZy9wYXJzaW5nL2FwcGVuZGluZyBiZWZvcmUgY3VycmVudFRpbWU/XG4gICAgICBjb25zdCBpbkZsaWdodERlcGVuZGVuY3kgPSBnZXRJbkZsaWdodERlcGVuZGVuY3kodGhpcy5obHMuaW5GbGlnaHRGcmFnbWVudHMsIGN1cnJlbnRUaW1lKTtcblxuICAgICAgLy8gV2FpdGluZyBmb3Igc2Vla2luZyBpbiBhIGJ1ZmZlcmVkIHJhbmdlIHRvIGNvbXBsZXRlXG4gICAgICBjb25zdCBoYXNFbm91Z2hCdWZmZXIgPSBidWZmZXJJbmZvLmxlbiA+IE1BWF9TVEFSVF9HQVBfSlVNUDtcbiAgICAgIC8vIE5leHQgYnVmZmVyZWQgcmFuZ2UgaXMgdG9vIGZhciBhaGVhZCB0byBqdW1wIHRvIHdoaWxlIHN0aWxsIHNlZWtpbmdcbiAgICAgIGNvbnN0IG5vQnVmZmVySG9sZSA9ICFuZXh0U3RhcnQgfHwgaW5GbGlnaHREZXBlbmRlbmN5IHx8IG5leHRTdGFydCAtIGN1cnJlbnRUaW1lID4gTUFYX1NUQVJUX0dBUF9KVU1QICYmICFmcmFnbWVudFRyYWNrZXIuZ2V0UGFydGlhbEZyYWdtZW50KGN1cnJlbnRUaW1lKTtcbiAgICAgIGlmIChoYXNFbm91Z2hCdWZmZXIgfHwgbm9CdWZmZXJIb2xlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFJlc2V0IG1vdmVkIHN0YXRlIHdoZW4gc2Vla2luZyB0byBhIHBvaW50IGluIG9yIGJlZm9yZSBhIGdhcC9ob2xlXG4gICAgICB0aGlzLm1vdmVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gU2tpcCBzdGFydCBnYXBzIGlmIHdlIGhhdmVuJ3QgcGxheWVkLCBidXQgdGhlIGxhc3QgcG9sbCBkZXRlY3RlZCB0aGUgc3RhcnQgb2YgYSBzdGFsbFxuICAgIC8vIFRoZSBhZGRpdGlvbiBwb2xsIGdpdmVzIHRoZSBicm93c2VyIGEgY2hhbmNlIHRvIGp1bXAgdGhlIGdhcCBmb3IgdXNcbiAgICBjb25zdCBsZXZlbERldGFpbHMgPSAoX3RoaXMkaGxzMiA9IHRoaXMuaGxzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkaGxzMi5sYXRlc3RMZXZlbERldGFpbHM7XG4gICAgaWYgKCF0aGlzLm1vdmVkICYmIHRoaXMuc3RhbGxlZCAhPT0gbnVsbCAmJiBmcmFnbWVudFRyYWNrZXIpIHtcbiAgICAgIC8vIFRoZXJlIGlzIG5vIHBsYXlhYmxlIGJ1ZmZlciAoc2Vla2VkLCB3YWl0aW5nIGZvciBidWZmZXIpXG4gICAgICBjb25zdCBpc0J1ZmZlcmVkID0gYnVmZmVySW5mby5sZW4gPiAwO1xuICAgICAgaWYgKCFpc0J1ZmZlcmVkICYmICFuZXh0U3RhcnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gSnVtcCBzdGFydCBnYXBzIHdpdGhpbiBqdW1wIHRocmVzaG9sZFxuICAgICAgY29uc3Qgc3RhcnRKdW1wID0gTWF0aC5tYXgobmV4dFN0YXJ0LCBidWZmZXJJbmZvLnN0YXJ0IHx8IDApIC0gY3VycmVudFRpbWU7XG5cbiAgICAgIC8vIFdoZW4gam9pbmluZyBhIGxpdmUgc3RyZWFtIHdpdGggYXVkaW8gdHJhY2tzLCBhY2NvdW50IGZvciBsaXZlIHBsYXlsaXN0IHdpbmRvdyBzbGlkaW5nIGJ5IGFsbG93aW5nXG4gICAgICAvLyBhIGxhcmdlciBqdW1wIG92ZXIgc3RhcnQgZ2FwcyBjYXVzZWQgYnkgdGhlIGF1ZGlvLXN0cmVhbS1jb250cm9sbGVyIGJ1ZmZlcmluZyBhIHN0YXJ0IGZyYWdtZW50XG4gICAgICAvLyB0aGF0IGJlZ2lucyBvdmVyIDEgdGFyZ2V0IGR1cmF0aW9uIGFmdGVyIHRoZSB2aWRlbyBzdGFydCBwb3NpdGlvbi5cbiAgICAgIGNvbnN0IGlzTGl2ZSA9ICEhKGxldmVsRGV0YWlscyAhPSBudWxsICYmIGxldmVsRGV0YWlscy5saXZlKTtcbiAgICAgIGNvbnN0IG1heFN0YXJ0R2FwSnVtcCA9IGlzTGl2ZSA/IGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbiAqIDIgOiBNQVhfU1RBUlRfR0FQX0pVTVA7XG4gICAgICBjb25zdCBwYXJ0aWFsT3JHYXAgPSBmcmFnbWVudFRyYWNrZXIuZ2V0UGFydGlhbEZyYWdtZW50KGN1cnJlbnRUaW1lKTtcbiAgICAgIGlmIChzdGFydEp1bXAgPiAwICYmIChzdGFydEp1bXAgPD0gbWF4U3RhcnRHYXBKdW1wIHx8IHBhcnRpYWxPckdhcCkpIHtcbiAgICAgICAgaWYgKCFtZWRpYS5wYXVzZWQpIHtcbiAgICAgICAgICB0aGlzLl90cnlTa2lwQnVmZmVySG9sZShwYXJ0aWFsT3JHYXApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTdGFydCB0cmFja2luZyBzdGFsbCB0aW1lXG4gICAgY29uc3QgZGV0ZWN0U3RhbGxXaXRoQ3VycmVudFRpbWVNcyA9IGNvbmZpZy5kZXRlY3RTdGFsbFdpdGhDdXJyZW50VGltZU1zO1xuICAgIGNvbnN0IHRub3cgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnN0IHRXYWl0aW5nID0gdGhpcy53YWl0aW5nO1xuICAgIGxldCBzdGFsbGVkID0gdGhpcy5zdGFsbGVkO1xuICAgIGlmIChzdGFsbGVkID09PSBudWxsKSB7XG4gICAgICAvLyBVc2UgdGltZSBvZiByZWNlbnQgXCJ3YWl0aW5nXCIgZXZlbnRcbiAgICAgIGlmICh0V2FpdGluZyA+IDAgJiYgdG5vdyAtIHRXYWl0aW5nIDwgZGV0ZWN0U3RhbGxXaXRoQ3VycmVudFRpbWVNcykge1xuICAgICAgICBzdGFsbGVkID0gdGhpcy5zdGFsbGVkID0gdFdhaXRpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YWxsZWQgPSB0bm93O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHN0YWxsZWREdXJhdGlvbiA9IHRub3cgLSBzdGFsbGVkO1xuICAgIGlmICghc2Vla2luZyAmJiAoc3RhbGxlZER1cmF0aW9uID49IGRldGVjdFN0YWxsV2l0aEN1cnJlbnRUaW1lTXMgfHwgdFdhaXRpbmcpICYmIHRoaXMuaGxzKSB7XG4gICAgICB2YXIgX3RoaXMkbWVkaWFTb3VyY2U7XG4gICAgICAvLyBEaXNwYXRjaCBNRURJQV9FTkRFRCB3aGVuIG1lZGlhLmVuZGVkL2VuZGVkIGV2ZW50IGlzIG5vdCBzaWduYWxsZWQgYXQgZW5kIG9mIHN0cmVhbVxuICAgICAgaWYgKCgoX3RoaXMkbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbWVkaWFTb3VyY2UucmVhZHlTdGF0ZSkgPT09ICdlbmRlZCcgJiYgIShsZXZlbERldGFpbHMgIT0gbnVsbCAmJiBsZXZlbERldGFpbHMubGl2ZSkgJiYgTWF0aC5hYnMoY3VycmVudFRpbWUgLSAoKGxldmVsRGV0YWlscyA9PSBudWxsID8gdm9pZCAwIDogbGV2ZWxEZXRhaWxzLmVkZ2UpIHx8IDApKSA8IDEpIHtcbiAgICAgICAgaWYgKHRoaXMuZW5kZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbmRlZCA9IGN1cnJlbnRUaW1lIHx8IDE7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLk1FRElBX0VOREVELCB7XG4gICAgICAgICAgc3RhbGxlZDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gUmVwb3J0IHN0YWxsaW5nIGFmdGVyIHRyeWluZyB0byBmaXhcbiAgICAgIHRoaXMuX3JlcG9ydFN0YWxsKGJ1ZmZlckluZm8pO1xuICAgICAgaWYgKCF0aGlzLm1lZGlhIHx8ICF0aGlzLmhscykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlcmVkV2l0aEhvbGVzID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8obWVkaWEsIGN1cnJlbnRUaW1lLCBjb25maWcubWF4QnVmZmVySG9sZSk7XG4gICAgdGhpcy5fdHJ5Rml4QnVmZmVyU3RhbGwoYnVmZmVyZWRXaXRoSG9sZXMsIHN0YWxsZWREdXJhdGlvbiwgY3VycmVudFRpbWUpO1xuICB9XG4gIHN0YWxsUmVzb2x2ZWQoY3VycmVudFRpbWUpIHtcbiAgICBjb25zdCBzdGFsbGVkID0gdGhpcy5zdGFsbGVkO1xuICAgIGlmIChzdGFsbGVkICYmIHRoaXMuaGxzKSB7XG4gICAgICB0aGlzLnN0YWxsZWQgPSBudWxsO1xuICAgICAgLy8gVGhlIHBsYXloZWFkIGlzIG5vdyBtb3ZpbmcsIGJ1dCB3YXMgcHJldmlvdXNseSBzdGFsbGVkXG4gICAgICBpZiAodGhpcy5zdGFsbFJlcG9ydGVkKSB7XG4gICAgICAgIGNvbnN0IHN0YWxsZWREdXJhdGlvbiA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCkgLSBzdGFsbGVkO1xuICAgICAgICB0aGlzLmxvZyhgcGxheWJhY2sgbm90IHN0dWNrIGFueW1vcmUgQCR7Y3VycmVudFRpbWV9LCBhZnRlciAke01hdGgucm91bmQoc3RhbGxlZER1cmF0aW9uKX1tc2ApO1xuICAgICAgICB0aGlzLnN0YWxsUmVwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy53YWl0aW5nID0gMDtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuU1RBTExfUkVTT0xWRUQsIHt9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbnVkZ2VPblZpZGVvSG9sZShjdXJyZW50VGltZSwgbGFzdEN1cnJlbnRUaW1lKSB7XG4gICAgdmFyIF90aGlzJGJ1ZmZlcmVkJGF1ZGlvO1xuICAgIC8vIENocm9tZSB3aWxsIHBsYXkgb25lIHNlY29uZCBwYXN0IGEgaG9sZSBpbiB2aWRlbyBidWZmZXJlZCB0aW1lIHJhbmdlcyB3aXRob3V0IHJlbmRlcmluZyBhbnkgdmlkZW8gZnJvbSB0aGUgc3Vic2VxdWVudCByYW5nZSBhbmQgdGhlbiBzdGFsbCBhcyBsb25nIGFzIGF1ZGlvIGlzIGJ1ZmZlcmVkOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy81NjMxXG4gICAgLy8gaHR0cHM6Ly9pc3N1ZXMuY2hyb21pdW0ub3JnL2lzc3Vlcy80MDI4MDYxMyNjb21tZW50MTBcbiAgICAvLyBEZXRlY3QgdGhlIHBvdGVudGlhbCBmb3IgdGhpcyBzaXR1YXRpb24gYW5kIHByb2FjdGl2ZWx5IHNlZWsgdG8gZmx1c2ggdGhlIHZpZGVvIHBpcGVsaW5lIG9uY2UgdGhlIHBsYXloZWFkIHBhc3NlcyB0aGUgc3RhcnQgb2YgdGhlIHZpZGVvIGhvbGUuXG4gICAgLy8gV2hlbiB0aGVyZSBhcmUgYXVkaW8gYW5kIHZpZGVvIGJ1ZmZlcnMgYW5kIGN1cnJlbnRUaW1lIGlzIHBhc3QgdGhlIGVuZCBvZiB0aGUgZmlyc3QgdmlkZW8gYnVmZmVyZWQgcmFuZ2UuLi5cbiAgICBjb25zdCB2aWRlb1NvdXJjZUJ1ZmZlcmVkID0gdGhpcy5idWZmZXJlZC52aWRlbztcbiAgICBpZiAodGhpcy5obHMgJiYgdGhpcy5tZWRpYSAmJiB0aGlzLmZyYWdtZW50VHJhY2tlciAmJiAoX3RoaXMkYnVmZmVyZWQkYXVkaW8gPSB0aGlzLmJ1ZmZlcmVkLmF1ZGlvKSAhPSBudWxsICYmIF90aGlzJGJ1ZmZlcmVkJGF1ZGlvLmxlbmd0aCAmJiB2aWRlb1NvdXJjZUJ1ZmZlcmVkICYmIHZpZGVvU291cmNlQnVmZmVyZWQubGVuZ3RoID4gMSAmJiBjdXJyZW50VGltZSA+IHZpZGVvU291cmNlQnVmZmVyZWQuZW5kKDApKSB7XG4gICAgICAvLyBhbmQgYXVkaW8gaXMgYnVmZmVyZWQgYXQgdGhlIHBsYXloZWFkXG4gICAgICBjb25zdCBhdWRpb0J1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVyZWRJbmZvKEJ1ZmZlckhlbHBlci50aW1lUmFuZ2VzVG9BcnJheSh0aGlzLmJ1ZmZlcmVkLmF1ZGlvKSwgY3VycmVudFRpbWUsIDApO1xuICAgICAgaWYgKGF1ZGlvQnVmZmVySW5mby5sZW4gPiAxICYmIGxhc3RDdXJyZW50VGltZSA+PSBhdWRpb0J1ZmZlckluZm8uc3RhcnQpIHtcbiAgICAgICAgY29uc3QgdmlkZW9UaW1lcyA9IEJ1ZmZlckhlbHBlci50aW1lUmFuZ2VzVG9BcnJheSh2aWRlb1NvdXJjZUJ1ZmZlcmVkKTtcbiAgICAgICAgY29uc3QgbGFzdEJ1ZmZlcmVkSW5kZXggPSBCdWZmZXJIZWxwZXIuYnVmZmVyZWRJbmZvKHZpZGVvVGltZXMsIGxhc3RDdXJyZW50VGltZSwgMCkuYnVmZmVyZWRJbmRleDtcbiAgICAgICAgLy8gbnVkZ2Ugd2hlbiBjcm9zc2luZyBpbnRvIGFub3RoZXIgdmlkZW8gYnVmZmVyZWQgcmFuZ2UgKGhvbGUpLlxuICAgICAgICBpZiAobGFzdEJ1ZmZlcmVkSW5kZXggPiAtMSAmJiBsYXN0QnVmZmVyZWRJbmRleCA8IHZpZGVvVGltZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIGNvbnN0IGJ1ZmZlcmVkSW5kZXggPSBCdWZmZXJIZWxwZXIuYnVmZmVyZWRJbmZvKHZpZGVvVGltZXMsIGN1cnJlbnRUaW1lLCAwKS5idWZmZXJlZEluZGV4O1xuICAgICAgICAgIGNvbnN0IGhvbGVTdGFydCA9IHZpZGVvVGltZXNbbGFzdEJ1ZmZlcmVkSW5kZXhdLmVuZDtcbiAgICAgICAgICBjb25zdCBob2xlRW5kID0gdmlkZW9UaW1lc1tsYXN0QnVmZmVyZWRJbmRleCArIDFdLnN0YXJ0O1xuICAgICAgICAgIGlmICgoYnVmZmVyZWRJbmRleCA9PT0gLTEgfHwgYnVmZmVyZWRJbmRleCA+IGxhc3RCdWZmZXJlZEluZGV4KSAmJiBob2xlRW5kIC0gaG9sZVN0YXJ0IDwgMSAmJlxuICAgICAgICAgIC8vIGBtYXhCdWZmZXJIb2xlYCBtYXkgYmUgdG9vIHNtYWxsIGFuZCBzZXR0aW5nIGl0IHRvIDAgc2hvdWxkIG5vdCBkaXNhYmxlIHRoaXMgZmVhdHVyZVxuICAgICAgICAgIGN1cnJlbnRUaW1lIC0gaG9sZVN0YXJ0IDwgMikge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYG51ZGdpbmcgcGxheWhlYWQgdG8gZmx1c2ggcGlwZWxpbmUgYWZ0ZXIgdmlkZW8gaG9sZS4gY3VycmVudFRpbWU6ICR7Y3VycmVudFRpbWV9IGhvbGU6ICR7aG9sZVN0YXJ0fSAtPiAke2hvbGVFbmR9IGJ1ZmZlcmVkIGluZGV4OiAke2J1ZmZlcmVkSW5kZXh9YCk7XG4gICAgICAgICAgICB0aGlzLndhcm4oZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAvLyBNYWdpYyBudW1iZXIgdG8gZmx1c2ggdGhlIHBpcGVsaW5lIHdpdGhvdXQgaW50ZXJ1cHRpb24gdG8gYXVkaW8gcGxheWJhY2s6XG4gICAgICAgICAgICB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lICs9IDAuMDAwMDAxO1xuICAgICAgICAgICAgY29uc3QgZnJhZyA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFBhcnRpYWxGcmFnbWVudChjdXJyZW50VGltZSkgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKHRoaXMubWVkaWEsIGN1cnJlbnRUaW1lLCAwKTtcbiAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfU0VFS19PVkVSX0hPTEUsXG4gICAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgICAgYnVmZmVyOiBidWZmZXJJbmZvLmxlbixcbiAgICAgICAgICAgICAgYnVmZmVySW5mb1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERldGVjdHMgYW5kIGF0dGVtcHRzIHRvIGZpeCBrbm93biBidWZmZXIgc3RhbGxpbmcgaXNzdWVzLlxuICAgKiBAcGFyYW0gYnVmZmVySW5mbyAtIFRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IGJ1ZmZlci5cbiAgICogQHBhcmFtIHN0YWxsZWREdXJhdGlvbk1zIC0gVGhlIGFtb3VudCBvZiB0aW1lIEhscy5qcyBoYXMgYmVlbiBzdGFsbGluZyBmb3IuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdHJ5Rml4QnVmZmVyU3RhbGwoYnVmZmVySW5mbywgc3RhbGxlZER1cmF0aW9uTXMsIGN1cnJlbnRUaW1lKSB7XG4gICAgdmFyIF90aGlzJGhsczMsIF90aGlzJGhsczQ7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZ21lbnRUcmFja2VyLFxuICAgICAgbWVkaWFcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBjb25maWcgPSAoX3RoaXMkaGxzMyA9IHRoaXMuaGxzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkaGxzMy5jb25maWc7XG4gICAgaWYgKCFtZWRpYSB8fCAhZnJhZ21lbnRUcmFja2VyIHx8ICFjb25maWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gKF90aGlzJGhsczQgPSB0aGlzLmhscykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGhsczQubGF0ZXN0TGV2ZWxEZXRhaWxzO1xuICAgIGNvbnN0IHBhcnRpYWwgPSBmcmFnbWVudFRyYWNrZXIuZ2V0UGFydGlhbEZyYWdtZW50KGN1cnJlbnRUaW1lKTtcbiAgICBpZiAocGFydGlhbCB8fCBsZXZlbERldGFpbHMgIT0gbnVsbCAmJiBsZXZlbERldGFpbHMubGl2ZSAmJiBjdXJyZW50VGltZSA8IGxldmVsRGV0YWlscy5mcmFnbWVudFN0YXJ0KSB7XG4gICAgICAvLyBUcnkgdG8gc2tpcCBvdmVyIHRoZSBidWZmZXIgaG9sZSBjYXVzZWQgYnkgYSBwYXJ0aWFsIGZyYWdtZW50XG4gICAgICAvLyBUaGlzIG1ldGhvZCBpc24ndCBsaW1pdGVkIGJ5IHRoZSBzaXplIG9mIHRoZSBnYXAgYmV0d2VlbiBidWZmZXJlZCByYW5nZXNcbiAgICAgIGNvbnN0IHRhcmdldFRpbWUgPSB0aGlzLl90cnlTa2lwQnVmZmVySG9sZShwYXJ0aWFsKTtcbiAgICAgIC8vIHdlIHJldHVybiBoZXJlIGluIHRoaXMgY2FzZSwgbWVhbmluZ1xuICAgICAgLy8gdGhlIGJyYW5jaCBiZWxvdyBvbmx5IGV4ZWN1dGVzIHdoZW4gd2UgaGF2ZW4ndCBzZWVrZWQgdG8gYSBuZXcgcG9zaXRpb25cbiAgICAgIGlmICh0YXJnZXRUaW1lIHx8ICF0aGlzLm1lZGlhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiB3ZSBoYXZlbid0IGhhZCB0byBza2lwIG92ZXIgYSBidWZmZXIgaG9sZSBvZiBhIHBhcnRpYWwgZnJhZ21lbnRcbiAgICAvLyB3ZSBtYXkganVzdCBoYXZlIHRvIFwibnVkZ2VcIiB0aGUgcGxheWxpc3QgYXMgdGhlIGJyb3dzZXIgZGVjb2RpbmcvcmVuZGVyaW5nIGVuZ2luZVxuICAgIC8vIG5lZWRzIHRvIGNyb3NzIHNvbWUgc29ydCBvZiB0aHJlc2hvbGQgY292ZXJpbmcgYWxsIHNvdXJjZS1idWZmZXJzIGNvbnRlbnRcbiAgICAvLyB0byBzdGFydCBwbGF5aW5nIHByb3Blcmx5LlxuICAgIGNvbnN0IGJ1ZmZlcmVkUmFuZ2VzID0gYnVmZmVySW5mby5idWZmZXJlZDtcbiAgICBjb25zdCBhZGphY2VudFRyYXZlcnNhbCA9IHRoaXMuYWRqYWNlbnRUcmF2ZXJzYWwoYnVmZmVySW5mbywgY3VycmVudFRpbWUpO1xuICAgIGlmICgoYnVmZmVyZWRSYW5nZXMgJiYgYnVmZmVyZWRSYW5nZXMubGVuZ3RoID4gMSAmJiBidWZmZXJJbmZvLmxlbiA+IGNvbmZpZy5tYXhCdWZmZXJIb2xlIHx8IGJ1ZmZlckluZm8ubmV4dFN0YXJ0ICYmIChidWZmZXJJbmZvLm5leHRTdGFydCAtIGN1cnJlbnRUaW1lIDwgY29uZmlnLm1heEJ1ZmZlckhvbGUgfHwgYWRqYWNlbnRUcmF2ZXJzYWwpKSAmJiAoc3RhbGxlZER1cmF0aW9uTXMgPiBjb25maWcuaGlnaEJ1ZmZlcldhdGNoZG9nUGVyaW9kICogMTAwMCB8fCB0aGlzLndhaXRpbmcpKSB7XG4gICAgICB0aGlzLndhcm4oJ1RyeWluZyB0byBudWRnZSBwbGF5aGVhZCBvdmVyIGJ1ZmZlci1ob2xlJyk7XG4gICAgICAvLyBUcnkgdG8gbnVkZ2UgY3VycmVudFRpbWUgb3ZlciBhIGJ1ZmZlciBob2xlIGlmIHdlJ3ZlIGJlZW4gc3RhbGxpbmcgZm9yIHRoZSBjb25maWd1cmVkIGFtb3VudCBvZiBzZWNvbmRzXG4gICAgICAvLyBXZSBvbmx5IHRyeSB0byBqdW1wIHRoZSBob2xlIGlmIGl0J3MgdW5kZXIgdGhlIGNvbmZpZ3VyZWQgc2l6ZVxuICAgICAgdGhpcy5fdHJ5TnVkZ2VCdWZmZXIoYnVmZmVySW5mbyk7XG4gICAgfVxuICB9XG4gIGFkamFjZW50VHJhdmVyc2FsKGJ1ZmZlckluZm8sIGN1cnJlbnRUaW1lKSB7XG4gICAgY29uc3QgZnJhZ21lbnRUcmFja2VyID0gdGhpcy5mcmFnbWVudFRyYWNrZXI7XG4gICAgY29uc3QgbmV4dFN0YXJ0ID0gYnVmZmVySW5mby5uZXh0U3RhcnQ7XG4gICAgaWYgKGZyYWdtZW50VHJhY2tlciAmJiBuZXh0U3RhcnQpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSBmcmFnbWVudFRyYWNrZXIuZ2V0RnJhZ0F0UG9zKGN1cnJlbnRUaW1lLCBQbGF5bGlzdExldmVsVHlwZS5NQUlOKTtcbiAgICAgIGNvbnN0IG5leHQgPSBmcmFnbWVudFRyYWNrZXIuZ2V0RnJhZ0F0UG9zKG5leHRTdGFydCwgUGxheWxpc3RMZXZlbFR5cGUuTUFJTik7XG4gICAgICBpZiAoY3VycmVudCAmJiBuZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXh0LnNuIC0gY3VycmVudC5zbiA8IDI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlnZ2VycyBhIEJVRkZFUl9TVEFMTEVEX0VSUk9SIGV2ZW50LCBidXQgb25seSBvbmNlIHBlciBzdGFsbCBwZXJpb2QuXG4gICAqIEBwYXJhbSBidWZmZXJMZW4gLSBUaGUgcGxheWhlYWQgZGlzdGFuY2UgZnJvbSB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGJ1ZmZlciBzZWdtZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlcG9ydFN0YWxsKGJ1ZmZlckluZm8pIHtcbiAgICBjb25zdCB7XG4gICAgICBobHMsXG4gICAgICBtZWRpYSxcbiAgICAgIHN0YWxsUmVwb3J0ZWQsXG4gICAgICBzdGFsbGVkXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFzdGFsbFJlcG9ydGVkICYmIHN0YWxsZWQgIT09IG51bGwgJiYgbWVkaWEgJiYgaGxzKSB7XG4gICAgICAvLyBSZXBvcnQgc3RhbGxlZCBlcnJvciBvbmNlXG4gICAgICB0aGlzLnN0YWxsUmVwb3J0ZWQgPSB0cnVlO1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYFBsYXliYWNrIHN0YWxsaW5nIGF0IEAke21lZGlhLmN1cnJlbnRUaW1lfSBkdWUgdG8gbG93IGJ1ZmZlciAoJHtzdHJpbmdpZnkoYnVmZmVySW5mbyl9KWApO1xuICAgICAgdGhpcy53YXJuKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfU1RBTExFRF9FUlJPUixcbiAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgYnVmZmVyOiBidWZmZXJJbmZvLmxlbixcbiAgICAgICAgYnVmZmVySW5mbyxcbiAgICAgICAgc3RhbGxlZDoge1xuICAgICAgICAgIHN0YXJ0OiBzdGFsbGVkXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBmaXggYnVmZmVyIHN0YWxscyBieSBqdW1waW5nIG92ZXIga25vd24gZ2FwcyBjYXVzZWQgYnkgcGFydGlhbCBmcmFnbWVudHNcbiAgICogQHBhcmFtIHBhcnRpYWwgLSBUaGUgcGFydGlhbCBmcmFnbWVudCBmb3VuZCBhdCB0aGUgY3VycmVudCB0aW1lICh3aGVyZSBwbGF5YmFjayBpcyBzdGFsbGluZykuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdHJ5U2tpcEJ1ZmZlckhvbGUocGFydGlhbCkge1xuICAgIHZhciBfdGhpcyRobHM1O1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWdtZW50VHJhY2tlcixcbiAgICAgIG1lZGlhXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgY29uZmlnID0gKF90aGlzJGhsczUgPSB0aGlzLmhscykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGhsczUuY29uZmlnO1xuICAgIGlmICghbWVkaWEgfHwgIWZyYWdtZW50VHJhY2tlciB8fCAhY29uZmlnKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBjdXJyZW50VGltZSBpcyBiZXR3ZWVuIHVuYnVmZmVyZWQgcmVnaW9ucyBvZiBwYXJ0aWFsIGZyYWdtZW50c1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgY29uc3QgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKG1lZGlhLCBjdXJyZW50VGltZSwgMCk7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gY3VycmVudFRpbWUgPCBidWZmZXJJbmZvLnN0YXJ0ID8gYnVmZmVySW5mby5zdGFydCA6IGJ1ZmZlckluZm8ubmV4dFN0YXJ0O1xuICAgIGlmIChzdGFydFRpbWUgJiYgdGhpcy5obHMpIHtcbiAgICAgIGNvbnN0IGJ1ZmZlclN0YXJ2ZWQgPSBidWZmZXJJbmZvLmxlbiA8PSBjb25maWcubWF4QnVmZmVySG9sZTtcbiAgICAgIGNvbnN0IHdhaXRpbmcgPSBidWZmZXJJbmZvLmxlbiA+IDAgJiYgYnVmZmVySW5mby5sZW4gPCAxICYmIG1lZGlhLnJlYWR5U3RhdGUgPCAzO1xuICAgICAgY29uc3QgZ2FwTGVuZ3RoID0gc3RhcnRUaW1lIC0gY3VycmVudFRpbWU7XG4gICAgICBpZiAoZ2FwTGVuZ3RoID4gMCAmJiAoYnVmZmVyU3RhcnZlZCB8fCB3YWl0aW5nKSkge1xuICAgICAgICAvLyBPbmx5IGFsbG93IGxhcmdlIGdhcHMgdG8gYmUgc2tpcHBlZCBpZiBpdCBpcyBhIHN0YXJ0IGdhcCwgb3IgYWxsIGZyYWdtZW50cyBpbiBza2lwIHJhbmdlIGFyZSBwYXJ0aWFsXG4gICAgICAgIGlmIChnYXBMZW5ndGggPiBjb25maWcubWF4QnVmZmVySG9sZSkge1xuICAgICAgICAgIGxldCBzdGFydEdhcCA9IGZhbHNlO1xuICAgICAgICAgIGlmIChjdXJyZW50VGltZSA9PT0gMCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRGcmFnID0gZnJhZ21lbnRUcmFja2VyLmdldEFwcGVuZGVkRnJhZygwLCBQbGF5bGlzdExldmVsVHlwZS5NQUlOKTtcbiAgICAgICAgICAgIGlmIChzdGFydEZyYWcgJiYgc3RhcnRUaW1lIDwgc3RhcnRGcmFnLmVuZCkge1xuICAgICAgICAgICAgICBzdGFydEdhcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghc3RhcnRHYXApIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0UHJvdmlzaW9uZWQgPSBwYXJ0aWFsIHx8IGZyYWdtZW50VHJhY2tlci5nZXRBcHBlbmRlZEZyYWcoY3VycmVudFRpbWUsIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pO1xuICAgICAgICAgICAgaWYgKHN0YXJ0UHJvdmlzaW9uZWQpIHtcbiAgICAgICAgICAgICAgdmFyIF90aGlzJGhscyRsb2FkTGV2ZWxPYjtcbiAgICAgICAgICAgICAgLy8gRG8gbm90IHNlZWsgd2hlbiBzZWxlY3RlZCB2YXJpYW50IHBsYXlsaXN0IGlzIHVubG9hZGVkXG4gICAgICAgICAgICAgIGlmICghKChfdGhpcyRobHMkbG9hZExldmVsT2IgPSB0aGlzLmhscy5sb2FkTGV2ZWxPYmopICE9IG51bGwgJiYgX3RoaXMkaGxzJGxvYWRMZXZlbE9iLmRldGFpbHMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gRG8gbm90IHNlZWsgd2hlbiByZXF1aXJlZCBmcmFnbWVudHMgYXJlIGluZmxpZ2h0IG9yIGFwcGVuZGluZ1xuICAgICAgICAgICAgICBjb25zdCBpbkZsaWdodERlcGVuZGVuY3kgPSBnZXRJbkZsaWdodERlcGVuZGVuY3kodGhpcy5obHMuaW5GbGlnaHRGcmFnbWVudHMsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgIGlmIChpbkZsaWdodERlcGVuZGVuY3kpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBEbyBub3Qgc2VlayBpZiB3ZSBjYW4ndCB3YWxrIHRyYWNrZWQgZnJhZ21lbnRzIHRvIGVuZCBvZiBnYXBcbiAgICAgICAgICAgICAgbGV0IG1vcmVUb0xvYWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgbGV0IHBvcyA9IHN0YXJ0UHJvdmlzaW9uZWQuZW5kO1xuICAgICAgICAgICAgICB3aGlsZSAocG9zIDwgc3RhcnRUaW1lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvdmlzaW9uZWQgPSBmcmFnbWVudFRyYWNrZXIuZ2V0QXBwZW5kZWRGcmFnKHBvcywgUGxheWxpc3RMZXZlbFR5cGUuTUFJTikgfHwgZnJhZ21lbnRUcmFja2VyLmdldFBhcnRpYWxGcmFnbWVudChwb3MpO1xuICAgICAgICAgICAgICAgIGlmIChwcm92aXNpb25lZCkge1xuICAgICAgICAgICAgICAgICAgcG9zICs9IHByb3Zpc2lvbmVkLmR1cmF0aW9uO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBtb3JlVG9Mb2FkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobW9yZVRvTG9hZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldFRpbWUgPSBNYXRoLm1heChzdGFydFRpbWUgKyBTS0lQX0JVRkZFUl9SQU5HRV9TVEFSVCwgY3VycmVudFRpbWUgKyBTS0lQX0JVRkZFUl9IT0xFX1NURVBfU0VDT05EUyk7XG4gICAgICAgIHRoaXMud2Fybihgc2tpcHBpbmcgaG9sZSwgYWRqdXN0aW5nIGN1cnJlbnRUaW1lIGZyb20gJHtjdXJyZW50VGltZX0gdG8gJHt0YXJnZXRUaW1lfWApO1xuICAgICAgICB0aGlzLm1vdmVkID0gdHJ1ZTtcbiAgICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSB0YXJnZXRUaW1lO1xuICAgICAgICBpZiAoIShwYXJ0aWFsICE9IG51bGwgJiYgcGFydGlhbC5nYXApKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGZyYWdtZW50IGxvYWRlZCB3aXRoIGJ1ZmZlciBob2xlcywgc2Vla2luZyBmcm9tICR7Y3VycmVudFRpbWV9IHRvICR7dGFyZ2V0VGltZX1gKTtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfU0VFS19PVkVSX0hPTEUsXG4gICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgIGZyYWc6IHBhcnRpYWwgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgYnVmZmVyOiBidWZmZXJJbmZvLmxlbixcbiAgICAgICAgICAgIGJ1ZmZlckluZm9cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0VGltZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gZml4IGJ1ZmZlciBzdGFsbHMgYnkgYWR2YW5jaW5nIHRoZSBtZWRpYUVsZW1lbnQncyBjdXJyZW50IHRpbWUgYnkgYSBzbWFsbCBhbW91bnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdHJ5TnVkZ2VCdWZmZXIoYnVmZmVySW5mbykge1xuICAgIGNvbnN0IHtcbiAgICAgIGhscyxcbiAgICAgIG1lZGlhLFxuICAgICAgbnVkZ2VSZXRyeVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGNvbmZpZyA9IGhscyA9PSBudWxsID8gdm9pZCAwIDogaGxzLmNvbmZpZztcbiAgICBpZiAoIW1lZGlhIHx8ICFjb25maWcpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIHRoaXMubnVkZ2VSZXRyeSsrO1xuICAgIGlmIChudWRnZVJldHJ5IDwgY29uZmlnLm51ZGdlTWF4UmV0cnkpIHtcbiAgICAgIGNvbnN0IHRhcmdldFRpbWUgPSBjdXJyZW50VGltZSArIChudWRnZVJldHJ5ICsgMSkgKiBjb25maWcubnVkZ2VPZmZzZXQ7XG4gICAgICAvLyBwbGF5YmFjayBzdGFsbGVkIGluIGJ1ZmZlcmVkIGFyZWEgLi4uIGxldCdzIG51ZGdlIGN1cnJlbnRUaW1lIHRvIHRyeSB0byBvdmVyY29tZSB0aGlzXG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgTnVkZ2luZyAnY3VycmVudFRpbWUnIGZyb20gJHtjdXJyZW50VGltZX0gdG8gJHt0YXJnZXRUaW1lfWApO1xuICAgICAgdGhpcy53YXJuKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSB0YXJnZXRUaW1lO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfTlVER0VfT05fU1RBTEwsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIGJ1ZmZlcjogYnVmZmVySW5mby5sZW4sXG4gICAgICAgIGJ1ZmZlckluZm9cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgUGxheWhlYWQgc3RpbGwgbm90IG1vdmluZyB3aGlsZSBlbm91Z2ggZGF0YSBidWZmZXJlZCBAJHtjdXJyZW50VGltZX0gYWZ0ZXIgJHtjb25maWcubnVkZ2VNYXhSZXRyeX0gbnVkZ2VzYCk7XG4gICAgICB0aGlzLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfU1RBTExFRF9FUlJPUixcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgICBidWZmZXI6IGJ1ZmZlckluZm8ubGVuLFxuICAgICAgICBidWZmZXJJbmZvXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEluRmxpZ2h0RGVwZW5kZW5jeShpbkZsaWdodEZyYWdtZW50cywgY3VycmVudFRpbWUpIHtcbiAgY29uc3QgbWFpbiA9IGluRmxpZ2h0KGluRmxpZ2h0RnJhZ21lbnRzLm1haW4pO1xuICBpZiAobWFpbiAmJiBtYWluLnN0YXJ0IDw9IGN1cnJlbnRUaW1lKSB7XG4gICAgcmV0dXJuIG1haW47XG4gIH1cbiAgY29uc3QgYXVkaW8gPSBpbkZsaWdodChpbkZsaWdodEZyYWdtZW50cy5hdWRpbyk7XG4gIGlmIChhdWRpbyAmJiBhdWRpby5zdGFydCA8PSBjdXJyZW50VGltZSkge1xuICAgIHJldHVybiBhdWRpbztcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGluRmxpZ2h0KGluRmxpZ2h0RGF0YSkge1xuICBpZiAoIWluRmxpZ2h0RGF0YSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHN3aXRjaCAoaW5GbGlnaHREYXRhLnN0YXRlKSB7XG4gICAgY2FzZSBTdGF0ZS5JRExFOlxuICAgIGNhc2UgU3RhdGUuU1RPUFBFRDpcbiAgICBjYXNlIFN0YXRlLkVOREVEOlxuICAgIGNhc2UgU3RhdGUuRVJST1I6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gaW5GbGlnaHREYXRhLmZyYWc7XG59XG5cbmNvbnN0IE1JTl9DVUVfRFVSQVRJT04gPSAwLjI1O1xuZnVuY3Rpb24gZ2V0Q3VlQ2xhc3MoKSB7XG4gIGlmICh0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiB1bmRlZmluZWQ7XG4gIHJldHVybiBzZWxmLlZUVEN1ZSB8fCBzZWxmLlRleHRUcmFja0N1ZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUN1ZVdpdGhEYXRhRmllbGRzKEN1ZSwgc3RhcnRUaW1lLCBlbmRUaW1lLCBkYXRhLCB0eXBlKSB7XG4gIGxldCBjdWUgPSBuZXcgQ3VlKHN0YXJ0VGltZSwgZW5kVGltZSwgJycpO1xuICB0cnkge1xuICAgIGN1ZS52YWx1ZSA9IGRhdGE7XG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIGN1ZS50eXBlID0gdHlwZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjdWUgPSBuZXcgQ3VlKHN0YXJ0VGltZSwgZW5kVGltZSwgc3RyaW5naWZ5KHR5cGUgPyBfb2JqZWN0U3ByZWFkMih7XG4gICAgICB0eXBlXG4gICAgfSwgZGF0YSkgOiBkYXRhKSk7XG4gIH1cbiAgcmV0dXJuIGN1ZTtcbn1cblxuLy8gVlRUQ3VlIGxhdGVzdCBkcmFmdCBhbGxvd3MgYW4gaW5maW5pdGUgZHVyYXRpb24sIGZhbGxiYWNrXG4vLyB0byBNQVhfVkFMVUUgaWYgbmVjZXNzYXJ5XG5jb25zdCBNQVhfQ1VFX0VORFRJTUUgPSAoKCkgPT4ge1xuICBjb25zdCBDdWUgPSBnZXRDdWVDbGFzcygpO1xuICB0cnkge1xuICAgIEN1ZSAmJiBuZXcgQ3VlKDAsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgJycpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7XG4gIH1cbiAgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbn0pKCk7XG5jbGFzcyBJRDNUcmFja0NvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmlkM1RyYWNrID0gbnVsbDtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLmRhdGVSYW5nZUN1ZXNBcHBlbmRlZCA9IHt9O1xuICAgIHRoaXMucmVtb3ZlQ3VlcyA9IHRydWU7XG4gICAgdGhpcy5vbkV2ZW50Q3VlRW50ZXIgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuaGxzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVWRU5UX0NVRV9FTlRFUiwge30pO1xuICAgIH07XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmlkM1RyYWNrID0gbnVsbDtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLmRhdGVSYW5nZUN1ZXNBcHBlbmRlZCA9IHt9O1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmhscyA9IHRoaXMub25FdmVudEN1ZUVudGVyID0gbnVsbDtcbiAgfVxuICBfcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX1BBUlNJTkdfTUVUQURBVEEsIHRoaXMub25GcmFnUGFyc2luZ01ldGFkYXRhLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX1VQREFURUQsIHRoaXMub25MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxfUFRTX1VQREFURUQsIHRoaXMub25MZXZlbFB0c1VwZGF0ZWQsIHRoaXMpO1xuICB9XG4gIF91bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX1BBUlNJTkdfTUVUQURBVEEsIHRoaXMub25GcmFnUGFyc2luZ01ldGFkYXRhLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxfVVBEQVRFRCwgdGhpcy5vbkxldmVsVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxfUFRTX1VQREFURUQsIHRoaXMub25MZXZlbFB0c1VwZGF0ZWQsIHRoaXMpO1xuICB9XG4gIC8vIEFkZCBJRDMgbWV0YXRhZGF0YSB0ZXh0IHRyYWNrLlxuICBvbk1lZGlhQXR0YWNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF9kYXRhJG92ZXJyaWRlcztcbiAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICBpZiAoKChfZGF0YSRvdmVycmlkZXMgPSBkYXRhLm92ZXJyaWRlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhJG92ZXJyaWRlcy5jdWVSZW1vdmFsKSA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMucmVtb3ZlQ3VlcyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBvbk1lZGlhQXR0YWNoZWQoKSB7XG4gICAgY29uc3QgZGV0YWlscyA9IHRoaXMuaGxzLmxhdGVzdExldmVsRGV0YWlscztcbiAgICBpZiAoZGV0YWlscykge1xuICAgICAgdGhpcy51cGRhdGVEYXRlUmFuZ2VDdWVzKGRldGFpbHMpO1xuICAgIH1cbiAgfVxuICBvbk1lZGlhRGV0YWNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgY29uc3QgdHJhbnNmZXJyaW5nTWVkaWEgPSAhIWRhdGEudHJhbnNmZXJNZWRpYTtcbiAgICBpZiAodHJhbnNmZXJyaW5nTWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaWQzVHJhY2spIHtcbiAgICAgIGlmICh0aGlzLnJlbW92ZUN1ZXMpIHtcbiAgICAgICAgY2xlYXJDdXJyZW50Q3Vlcyh0aGlzLmlkM1RyYWNrLCB0aGlzLm9uRXZlbnRDdWVFbnRlcik7XG4gICAgICB9XG4gICAgICB0aGlzLmlkM1RyYWNrID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5kYXRlUmFuZ2VDdWVzQXBwZW5kZWQgPSB7fTtcbiAgfVxuICBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLmRhdGVSYW5nZUN1ZXNBcHBlbmRlZCA9IHt9O1xuICB9XG4gIGNyZWF0ZVRyYWNrKG1lZGlhKSB7XG4gICAgY29uc3QgdHJhY2sgPSB0aGlzLmdldElEM1RyYWNrKG1lZGlhLnRleHRUcmFja3MpO1xuICAgIHRyYWNrLm1vZGUgPSAnaGlkZGVuJztcbiAgICByZXR1cm4gdHJhY2s7XG4gIH1cbiAgZ2V0SUQzVHJhY2sodGV4dFRyYWNrcykge1xuICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHRUcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRleHRUcmFjayA9IHRleHRUcmFja3NbaV07XG4gICAgICBpZiAodGV4dFRyYWNrLmtpbmQgPT09ICdtZXRhZGF0YScgJiYgdGV4dFRyYWNrLmxhYmVsID09PSAnaWQzJykge1xuICAgICAgICAvLyBzZW5kICdhZGR0cmFjaycgd2hlbiByZXVzaW5nIHRoZSB0ZXh0VHJhY2sgZm9yIG1ldGFkYXRhLFxuICAgICAgICAvLyBzYW1lIGFzIHdoYXQgd2UgZG8gZm9yIGNhcHRpb25zXG4gICAgICAgIHNlbmRBZGRUcmFja0V2ZW50KHRleHRUcmFjaywgdGhpcy5tZWRpYSk7XG4gICAgICAgIHJldHVybiB0ZXh0VHJhY2s7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1lZGlhLmFkZFRleHRUcmFjaygnbWV0YWRhdGEnLCAnaWQzJyk7XG4gIH1cbiAgb25GcmFnUGFyc2luZ01ldGFkYXRhKGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGhsczoge1xuICAgICAgICBjb25maWc6IHtcbiAgICAgICAgICBlbmFibGVFbXNnTWV0YWRhdGFDdWVzLFxuICAgICAgICAgIGVuYWJsZUlEM01ldGFkYXRhQ3Vlc1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFlbmFibGVFbXNnTWV0YWRhdGFDdWVzICYmICFlbmFibGVJRDNNZXRhZGF0YUN1ZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgc2FtcGxlc1xuICAgIH0gPSBkYXRhO1xuXG4gICAgLy8gY3JlYXRlIHRyYWNrIGR5bmFtaWNhbGx5XG4gICAgaWYgKCF0aGlzLmlkM1RyYWNrKSB7XG4gICAgICB0aGlzLmlkM1RyYWNrID0gdGhpcy5jcmVhdGVUcmFjayh0aGlzLm1lZGlhKTtcbiAgICB9XG4gICAgY29uc3QgQ3VlID0gZ2V0Q3VlQ2xhc3MoKTtcbiAgICBpZiAoIUN1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBzYW1wbGVzW2ldLnR5cGU7XG4gICAgICBpZiAodHlwZSA9PT0gTWV0YWRhdGFTY2hlbWEuZW1zZyAmJiAhZW5hYmxlRW1zZ01ldGFkYXRhQ3VlcyB8fCAhZW5hYmxlSUQzTWV0YWRhdGFDdWVzKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgZnJhbWVzID0gZ2V0SWQzRnJhbWVzKHNhbXBsZXNbaV0uZGF0YSk7XG4gICAgICBpZiAoZnJhbWVzKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHNhbXBsZXNbaV0ucHRzO1xuICAgICAgICBsZXQgZW5kVGltZSA9IHN0YXJ0VGltZSArIHNhbXBsZXNbaV0uZHVyYXRpb247XG4gICAgICAgIGlmIChlbmRUaW1lID4gTUFYX0NVRV9FTkRUSU1FKSB7XG4gICAgICAgICAgZW5kVGltZSA9IE1BWF9DVUVfRU5EVElNRTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aW1lRGlmZiA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICAgIGlmICh0aW1lRGlmZiA8PSAwKSB7XG4gICAgICAgICAgZW5kVGltZSA9IHN0YXJ0VGltZSArIE1JTl9DVUVfRFVSQVRJT047XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBmcmFtZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBmcmFtZSA9IGZyYW1lc1tqXTtcbiAgICAgICAgICAvLyBTYWZhcmkgZG9lc24ndCBwdXQgdGhlIHRpbWVzdGFtcCBmcmFtZSBpbiB0aGUgVGV4dFRyYWNrXG4gICAgICAgICAgaWYgKCFpc0lkM1RpbWVzdGFtcEZyYW1lKGZyYW1lKSkge1xuICAgICAgICAgICAgLy8gYWRkIGEgYm91bmRzIHRvIGFueSB1bmJvdW5kZWQgY3Vlc1xuICAgICAgICAgICAgdGhpcy51cGRhdGVJZDNDdWVFbmRzKHN0YXJ0VGltZSwgdHlwZSk7XG4gICAgICAgICAgICBjb25zdCBjdWUgPSBjcmVhdGVDdWVXaXRoRGF0YUZpZWxkcyhDdWUsIHN0YXJ0VGltZSwgZW5kVGltZSwgZnJhbWUsIHR5cGUpO1xuICAgICAgICAgICAgaWYgKGN1ZSkge1xuICAgICAgICAgICAgICB0aGlzLmlkM1RyYWNrLmFkZEN1ZShjdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB1cGRhdGVJZDNDdWVFbmRzKHN0YXJ0VGltZSwgdHlwZSkge1xuICAgIHZhciBfdGhpcyRpZDNUcmFjaztcbiAgICBjb25zdCBjdWVzID0gKF90aGlzJGlkM1RyYWNrID0gdGhpcy5pZDNUcmFjaykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGlkM1RyYWNrLmN1ZXM7XG4gICAgaWYgKGN1ZXMpIHtcbiAgICAgIGZvciAobGV0IGkgPSBjdWVzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICBjb25zdCBjdWUgPSBjdWVzW2ldO1xuICAgICAgICBpZiAoY3VlLnR5cGUgPT09IHR5cGUgJiYgY3VlLnN0YXJ0VGltZSA8IHN0YXJ0VGltZSAmJiBjdWUuZW5kVGltZSA9PT0gTUFYX0NVRV9FTkRUSU1FKSB7XG4gICAgICAgICAgY3VlLmVuZFRpbWUgPSBzdGFydFRpbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgb25CdWZmZXJGbHVzaGluZyhldmVudCwge1xuICAgIHN0YXJ0T2Zmc2V0LFxuICAgIGVuZE9mZnNldCxcbiAgICB0eXBlXG4gIH0pIHtcbiAgICBjb25zdCB7XG4gICAgICBpZDNUcmFjayxcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmICghaGxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNvbmZpZzoge1xuICAgICAgICBlbmFibGVFbXNnTWV0YWRhdGFDdWVzLFxuICAgICAgICBlbmFibGVJRDNNZXRhZGF0YUN1ZXNcbiAgICAgIH1cbiAgICB9ID0gaGxzO1xuICAgIGlmIChpZDNUcmFjayAmJiAoZW5hYmxlRW1zZ01ldGFkYXRhQ3VlcyB8fCBlbmFibGVJRDNNZXRhZGF0YUN1ZXMpKSB7XG4gICAgICBsZXQgcHJlZGljYXRlO1xuICAgICAgaWYgKHR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgcHJlZGljYXRlID0gY3VlID0+IGN1ZS50eXBlID09PSBNZXRhZGF0YVNjaGVtYS5hdWRpb0lkMyAmJiBlbmFibGVJRDNNZXRhZGF0YUN1ZXM7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgcHJlZGljYXRlID0gY3VlID0+IGN1ZS50eXBlID09PSBNZXRhZGF0YVNjaGVtYS5lbXNnICYmIGVuYWJsZUVtc2dNZXRhZGF0YUN1ZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmVkaWNhdGUgPSBjdWUgPT4gY3VlLnR5cGUgPT09IE1ldGFkYXRhU2NoZW1hLmF1ZGlvSWQzICYmIGVuYWJsZUlEM01ldGFkYXRhQ3VlcyB8fCBjdWUudHlwZSA9PT0gTWV0YWRhdGFTY2hlbWEuZW1zZyAmJiBlbmFibGVFbXNnTWV0YWRhdGFDdWVzO1xuICAgICAgfVxuICAgICAgcmVtb3ZlQ3Vlc0luUmFuZ2UoaWQzVHJhY2ssIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQsIHByZWRpY2F0ZSk7XG4gICAgfVxuICB9XG4gIG9uTGV2ZWxVcGRhdGVkKGV2ZW50LCB7XG4gICAgZGV0YWlsc1xuICB9KSB7XG4gICAgdGhpcy51cGRhdGVEYXRlUmFuZ2VDdWVzKGRldGFpbHMsIHRydWUpO1xuICB9XG4gIG9uTGV2ZWxQdHNVcGRhdGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKE1hdGguYWJzKGRhdGEuZHJpZnQpID4gMC4wMSkge1xuICAgICAgdGhpcy51cGRhdGVEYXRlUmFuZ2VDdWVzKGRhdGEuZGV0YWlscyk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZURhdGVSYW5nZUN1ZXMoZGV0YWlscywgcmVtb3ZlT2xkQ3Vlcykge1xuICAgIGlmICghdGhpcy5tZWRpYSB8fCAhZGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUgfHwgIXRoaXMuaGxzLmNvbmZpZy5lbmFibGVEYXRlUmFuZ2VNZXRhZGF0YUN1ZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgaWQzVHJhY2tcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBkYXRlUmFuZ2VzXG4gICAgfSA9IGRldGFpbHM7XG4gICAgY29uc3QgaWRzID0gT2JqZWN0LmtleXMoZGF0ZVJhbmdlcyk7XG4gICAgbGV0IGRhdGVSYW5nZUN1ZXNBcHBlbmRlZCA9IHRoaXMuZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkO1xuICAgIC8vIFJlbW92ZSBjdWVzIGZyb20gdHJhY2sgbm90IGZvdW5kIGluIGRldGFpbHMuZGF0ZVJhbmdlc1xuICAgIGlmIChpZDNUcmFjayAmJiByZW1vdmVPbGRDdWVzKSB7XG4gICAgICB2YXIgX2lkM1RyYWNrJGN1ZXM7XG4gICAgICBpZiAoKF9pZDNUcmFjayRjdWVzID0gaWQzVHJhY2suY3VlcykgIT0gbnVsbCAmJiBfaWQzVHJhY2skY3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgaWRzVG9SZW1vdmUgPSBPYmplY3Qua2V5cyhkYXRlUmFuZ2VDdWVzQXBwZW5kZWQpLmZpbHRlcihpZCA9PiAhaWRzLmluY2x1ZGVzKGlkKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSBpZHNUb1JlbW92ZS5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICBjb25zdCBpZCA9IGlkc1RvUmVtb3ZlW2ldO1xuICAgICAgICAgIGNvbnN0IGN1ZXMgPSBkYXRlUmFuZ2VDdWVzQXBwZW5kZWRbaWRdLmN1ZXM7XG4gICAgICAgICAgZGVsZXRlIGRhdGVSYW5nZUN1ZXNBcHBlbmRlZFtpZF07XG4gICAgICAgICAgT2JqZWN0LmtleXMoY3VlcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgY3VlID0gY3Vlc1trZXldO1xuICAgICAgICAgICAgICBjdWUucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW50ZXInLCB0aGlzLm9uRXZlbnRDdWVFbnRlcik7XG4gICAgICAgICAgICAgIGlkM1RyYWNrLnJlbW92ZUN1ZShjdWUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAvKiBuby1vcCAqL1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRlUmFuZ2VDdWVzQXBwZW5kZWQgPSB0aGlzLmRhdGVSYW5nZUN1ZXNBcHBlbmRlZCA9IHt9O1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBFeGl0IGlmIHRoZSBwbGF5bGlzdCBkb2VzIG5vdCBoYXZlIERhdGUgUmFuZ2VzIG9yIGRvZXMgbm90IGhhdmUgUHJvZ3JhbSBEYXRlIFRpbWVcbiAgICBjb25zdCBsYXN0RnJhZ21lbnQgPSBkZXRhaWxzLmZyYWdtZW50c1tkZXRhaWxzLmZyYWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICBpZiAoaWRzLmxlbmd0aCA9PT0gMCB8fCAhaXNGaW5pdGVOdW1iZXIobGFzdEZyYWdtZW50ID09IG51bGwgPyB2b2lkIDAgOiBsYXN0RnJhZ21lbnQucHJvZ3JhbURhdGVUaW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaWQzVHJhY2spIHtcbiAgICAgIHRoaXMuaWQzVHJhY2sgPSB0aGlzLmNyZWF0ZVRyYWNrKHRoaXMubWVkaWEpO1xuICAgIH1cbiAgICBjb25zdCBDdWUgPSBnZXRDdWVDbGFzcygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpZCA9IGlkc1tpXTtcbiAgICAgIGNvbnN0IGRhdGVSYW5nZSA9IGRhdGVSYW5nZXNbaWRdO1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gZGF0ZVJhbmdlLnN0YXJ0VGltZTtcblxuICAgICAgLy8gUHJvY2VzcyBEYXRlUmFuZ2VzIHRvIGRldGVybWluZSBlbmQtdGltZSAoa25vd24gRFVSQVRJT04sIEVORC1EQVRFLCBvciBFTkQtT04tTkVYVClcbiAgICAgIGNvbnN0IGFwcGVuZGVkRGF0ZVJhbmdlQ3VlcyA9IGRhdGVSYW5nZUN1ZXNBcHBlbmRlZFtpZF07XG4gICAgICBjb25zdCBjdWVzID0gKGFwcGVuZGVkRGF0ZVJhbmdlQ3VlcyA9PSBudWxsID8gdm9pZCAwIDogYXBwZW5kZWREYXRlUmFuZ2VDdWVzLmN1ZXMpIHx8IHt9O1xuICAgICAgbGV0IGR1cmF0aW9uS25vd24gPSAoYXBwZW5kZWREYXRlUmFuZ2VDdWVzID09IG51bGwgPyB2b2lkIDAgOiBhcHBlbmRlZERhdGVSYW5nZUN1ZXMuZHVyYXRpb25Lbm93bikgfHwgZmFsc2U7XG4gICAgICBsZXQgZW5kVGltZSA9IE1BWF9DVUVfRU5EVElNRTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIGVuZERhdGVcbiAgICAgIH0gPSBkYXRlUmFuZ2U7XG4gICAgICBpZiAoZW5kRGF0ZSAmJiBkdXJhdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICBlbmRUaW1lID0gc3RhcnRUaW1lICsgZHVyYXRpb247XG4gICAgICAgIGR1cmF0aW9uS25vd24gPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChkYXRlUmFuZ2UuZW5kT25OZXh0ICYmICFkdXJhdGlvbktub3duKSB7XG4gICAgICAgIGNvbnN0IG5leHREYXRlUmFuZ2VXaXRoU2FtZUNsYXNzID0gaWRzLnJlZHVjZSgoY2FuZGlkYXRlRGF0ZVJhbmdlLCBpZCkgPT4ge1xuICAgICAgICAgIGlmIChpZCAhPT0gZGF0ZVJhbmdlLmlkKSB7XG4gICAgICAgICAgICBjb25zdCBvdGhlckRhdGVSYW5nZSA9IGRhdGVSYW5nZXNbaWRdO1xuICAgICAgICAgICAgaWYgKG90aGVyRGF0ZVJhbmdlLmNsYXNzID09PSBkYXRlUmFuZ2UuY2xhc3MgJiYgb3RoZXJEYXRlUmFuZ2Uuc3RhcnREYXRlID4gZGF0ZVJhbmdlLnN0YXJ0RGF0ZSAmJiAoIWNhbmRpZGF0ZURhdGVSYW5nZSB8fCBkYXRlUmFuZ2Uuc3RhcnREYXRlIDwgY2FuZGlkYXRlRGF0ZVJhbmdlLnN0YXJ0RGF0ZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG90aGVyRGF0ZVJhbmdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2FuZGlkYXRlRGF0ZVJhbmdlO1xuICAgICAgICB9LCBudWxsKTtcbiAgICAgICAgaWYgKG5leHREYXRlUmFuZ2VXaXRoU2FtZUNsYXNzKSB7XG4gICAgICAgICAgZW5kVGltZSA9IG5leHREYXRlUmFuZ2VXaXRoU2FtZUNsYXNzLnN0YXJ0VGltZTtcbiAgICAgICAgICBkdXJhdGlvbktub3duID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgVGV4dFRyYWNrIEN1ZXMgZm9yIGVhY2ggTWV0YWRhdGFHcm91cCBJdGVtIChzZWxlY3QgRGF0ZVJhbmdlIGF0dHJpYnV0ZSlcbiAgICAgIC8vIFRoaXMgaXMgdG8gZW11bGF0ZSBTYWZhcmkgSExTIHBsYXliYWNrIGhhbmRsaW5nIG9mIERhdGVSYW5nZSB0YWdzXG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gT2JqZWN0LmtleXMoZGF0ZVJhbmdlLmF0dHIpO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBhdHRyaWJ1dGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGF0dHJpYnV0ZXNbal07XG4gICAgICAgIGlmICghaXNEYXRlUmFuZ2VDdWVBdHRyaWJ1dGUoa2V5KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1ZSA9IGN1ZXNba2V5XTtcbiAgICAgICAgaWYgKGN1ZSkge1xuICAgICAgICAgIGlmIChkdXJhdGlvbktub3duICYmICFhcHBlbmRlZERhdGVSYW5nZUN1ZXMuZHVyYXRpb25Lbm93bikge1xuICAgICAgICAgICAgY3VlLmVuZFRpbWUgPSBlbmRUaW1lO1xuICAgICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoY3VlLnN0YXJ0VGltZSAtIHN0YXJ0VGltZSkgPiAwLjAxKSB7XG4gICAgICAgICAgICBjdWUuc3RhcnRUaW1lID0gc3RhcnRUaW1lO1xuICAgICAgICAgICAgY3VlLmVuZFRpbWUgPSBlbmRUaW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChDdWUpIHtcbiAgICAgICAgICBsZXQgZGF0YSA9IGRhdGVSYW5nZS5hdHRyW2tleV07XG4gICAgICAgICAgaWYgKGlzU0NURTM1QXR0cmlidXRlKGtleSkpIHtcbiAgICAgICAgICAgIGRhdGEgPSBoZXhUb0FycmF5QnVmZmVyKGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgZGF0YVxuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgX2N1ZSA9IGNyZWF0ZUN1ZVdpdGhEYXRhRmllbGRzKEN1ZSwgc3RhcnRUaW1lLCBlbmRUaW1lLCBwYXlsb2FkLCBNZXRhZGF0YVNjaGVtYS5kYXRlUmFuZ2UpO1xuICAgICAgICAgIGlmIChfY3VlKSB7XG4gICAgICAgICAgICBfY3VlLmlkID0gaWQ7XG4gICAgICAgICAgICB0aGlzLmlkM1RyYWNrLmFkZEN1ZShfY3VlKTtcbiAgICAgICAgICAgIGN1ZXNba2V5XSA9IF9jdWU7XG4gICAgICAgICAgICBpZiAodGhpcy5obHMuY29uZmlnLmludGVyc3RpdGlhbHNDb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgIGlmIChrZXkgPT09ICdYLUFTU0VULUxJU1QnIHx8IGtleSA9PT0gJ1gtQVNTRVQtVVJMJykge1xuICAgICAgICAgICAgICAgIF9jdWUuYWRkRXZlbnRMaXN0ZW5lcignZW50ZXInLCB0aGlzLm9uRXZlbnRDdWVFbnRlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gS2VlcCB0cmFjayBvZiBwcm9jZXNzZWQgRGF0ZVJhbmdlcyBieSBJRCBmb3IgdXBkYXRpbmcgY3VlcyB3aXRoIG5ldyBEYXRlUmFuZ2UgdGFnIGF0dHJpYnV0ZXNcbiAgICAgIGRhdGVSYW5nZUN1ZXNBcHBlbmRlZFtpZF0gPSB7XG4gICAgICAgIGN1ZXMsXG4gICAgICAgIGRhdGVSYW5nZSxcbiAgICAgICAgZHVyYXRpb25Lbm93blxuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgTGF0ZW5jeUNvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gMDtcbiAgICB0aGlzLnN0YWxsQ291bnQgPSAwO1xuICAgIHRoaXMuX2xhdGVuY3kgPSBudWxsO1xuICAgIHRoaXMuX3RhcmdldExhdGVuY3lVcGRhdGVkID0gZmFsc2U7XG4gICAgdGhpcy5vblRpbWV1cGRhdGUgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1lZGlhXG4gICAgICB9ID0gdGhpcztcbiAgICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IHRoaXMubGV2ZWxEZXRhaWxzO1xuICAgICAgaWYgKCFtZWRpYSB8fCAhbGV2ZWxEZXRhaWxzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICAgIGNvbnN0IGxhdGVuY3kgPSB0aGlzLmNvbXB1dGVMYXRlbmN5KCk7XG4gICAgICBpZiAobGF0ZW5jeSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9sYXRlbmN5ID0gbGF0ZW5jeTtcblxuICAgICAgLy8gQWRhcHQgcGxheWJhY2tSYXRlIHRvIG1lZXQgdGFyZ2V0IGxhdGVuY3kgaW4gbG93LWxhdGVuY3kgbW9kZVxuICAgICAgY29uc3Qge1xuICAgICAgICBsb3dMYXRlbmN5TW9kZSxcbiAgICAgICAgbWF4TGl2ZVN5bmNQbGF5YmFja1JhdGVcbiAgICAgIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgIGlmICghbG93TGF0ZW5jeU1vZGUgfHwgbWF4TGl2ZVN5bmNQbGF5YmFja1JhdGUgPT09IDEgfHwgIWxldmVsRGV0YWlscy5saXZlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhcmdldExhdGVuY3kgPSB0aGlzLnRhcmdldExhdGVuY3k7XG4gICAgICBpZiAodGFyZ2V0TGF0ZW5jeSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBkaXN0YW5jZUZyb21UYXJnZXQgPSBsYXRlbmN5IC0gdGFyZ2V0TGF0ZW5jeTtcbiAgICAgIC8vIE9ubHkgYWRqdXN0IHBsYXliYWNrUmF0ZSB3aGVuIHdpdGhpbiBvbmUgdGFyZ2V0IGR1cmF0aW9uIG9mIHRhcmdldExhdGVuY3lcbiAgICAgIC8vIGFuZCBtb3JlIHRoYW4gb25lIHNlY29uZCBmcm9tIHVuZGVyLWJ1ZmZlcmluZy5cbiAgICAgIC8vIFBsYXliYWNrIGZ1cnRoZXIgdGhhbiBvbmUgdGFyZ2V0IGR1cmF0aW9uIGZyb20gdGFyZ2V0IGNhbiBiZSBjb25zaWRlcmVkIERWUiBwbGF5YmFjay5cbiAgICAgIGNvbnN0IGxpdmVNaW5MYXRlbmN5RHVyYXRpb24gPSBNYXRoLm1pbih0aGlzLm1heExhdGVuY3ksIHRhcmdldExhdGVuY3kgKyBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb24pO1xuICAgICAgY29uc3QgaW5MaXZlUmFuZ2UgPSBkaXN0YW5jZUZyb21UYXJnZXQgPCBsaXZlTWluTGF0ZW5jeUR1cmF0aW9uO1xuICAgICAgaWYgKGluTGl2ZVJhbmdlICYmIGRpc3RhbmNlRnJvbVRhcmdldCA+IDAuMDUgJiYgdGhpcy5mb3J3YXJkQnVmZmVyTGVuZ3RoID4gMSkge1xuICAgICAgICBjb25zdCBtYXggPSBNYXRoLm1pbigyLCBNYXRoLm1heCgxLjAsIG1heExpdmVTeW5jUGxheWJhY2tSYXRlKSk7XG4gICAgICAgIGNvbnN0IHJhdGUgPSBNYXRoLnJvdW5kKDIgLyAoMSArIE1hdGguZXhwKC0wLjc1ICogZGlzdGFuY2VGcm9tVGFyZ2V0IC0gdGhpcy5lZGdlU3RhbGxlZCkpICogMjApIC8gMjA7XG4gICAgICAgIGNvbnN0IHBsYXliYWNrUmF0ZSA9IE1hdGgubWluKG1heCwgTWF0aC5tYXgoMSwgcmF0ZSkpO1xuICAgICAgICB0aGlzLmNoYW5nZU1lZGlhUGxheWJhY2tSYXRlKG1lZGlhLCBwbGF5YmFja1JhdGUpO1xuICAgICAgfSBlbHNlIGlmIChtZWRpYS5wbGF5YmFja1JhdGUgIT09IDEgJiYgbWVkaWEucGxheWJhY2tSYXRlICE9PSAwKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlTWVkaWFQbGF5YmFja1JhdGUobWVkaWEsIDEpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICBnZXQgbGV2ZWxEZXRhaWxzKCkge1xuICAgIHZhciBfdGhpcyRobHM7XG4gICAgcmV0dXJuICgoX3RoaXMkaGxzID0gdGhpcy5obHMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRobHMubGF0ZXN0TGV2ZWxEZXRhaWxzKSB8fCBudWxsO1xuICB9XG4gIGdldCBsYXRlbmN5KCkge1xuICAgIHJldHVybiB0aGlzLl9sYXRlbmN5IHx8IDA7XG4gIH1cbiAgZ2V0IG1heExhdGVuY3koKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29uZmlnXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbjtcbiAgICB9XG4gICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gdGhpcy5sZXZlbERldGFpbHM7XG4gICAgcmV0dXJuIGxldmVsRGV0YWlscyA/IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgKiBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb24gOiAwO1xuICB9XG4gIGdldCB0YXJnZXRMYXRlbmN5KCkge1xuICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IHRoaXMubGV2ZWxEZXRhaWxzO1xuICAgIGlmIChsZXZlbERldGFpbHMgPT09IG51bGwgfHwgdGhpcy5obHMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBob2xkQmFjayxcbiAgICAgIHBhcnRIb2xkQmFjayxcbiAgICAgIHRhcmdldGR1cmF0aW9uXG4gICAgfSA9IGxldmVsRGV0YWlscztcbiAgICBjb25zdCB7XG4gICAgICBsaXZlU3luY0R1cmF0aW9uLFxuICAgICAgbGl2ZVN5bmNEdXJhdGlvbkNvdW50LFxuICAgICAgbG93TGF0ZW5jeU1vZGVcbiAgICB9ID0gdGhpcy5jb25maWc7XG4gICAgY29uc3QgdXNlckNvbmZpZyA9IHRoaXMuaGxzLnVzZXJDb25maWc7XG4gICAgbGV0IHRhcmdldExhdGVuY3kgPSBsb3dMYXRlbmN5TW9kZSA/IHBhcnRIb2xkQmFjayB8fCBob2xkQmFjayA6IGhvbGRCYWNrO1xuICAgIGlmICh0aGlzLl90YXJnZXRMYXRlbmN5VXBkYXRlZCB8fCB1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb24gfHwgdXNlckNvbmZpZy5saXZlU3luY0R1cmF0aW9uQ291bnQgfHwgdGFyZ2V0TGF0ZW5jeSA9PT0gMCkge1xuICAgICAgdGFyZ2V0TGF0ZW5jeSA9IGxpdmVTeW5jRHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IGxpdmVTeW5jRHVyYXRpb24gOiBsaXZlU3luY0R1cmF0aW9uQ291bnQgKiB0YXJnZXRkdXJhdGlvbjtcbiAgICB9XG4gICAgY29uc3QgbWF4TGl2ZVN5bmNPblN0YWxsSW5jcmVhc2UgPSB0YXJnZXRkdXJhdGlvbjtcbiAgICByZXR1cm4gdGFyZ2V0TGF0ZW5jeSArIE1hdGgubWluKHRoaXMuc3RhbGxDb3VudCAqIHRoaXMuY29uZmlnLmxpdmVTeW5jT25TdGFsbEluY3JlYXNlLCBtYXhMaXZlU3luY09uU3RhbGxJbmNyZWFzZSk7XG4gIH1cbiAgc2V0IHRhcmdldExhdGVuY3kobGF0ZW5jeSkge1xuICAgIHRoaXMuc3RhbGxDb3VudCA9IDA7XG4gICAgdGhpcy5jb25maWcubGl2ZVN5bmNEdXJhdGlvbiA9IGxhdGVuY3k7XG4gICAgdGhpcy5fdGFyZ2V0TGF0ZW5jeVVwZGF0ZWQgPSB0cnVlO1xuICB9XG4gIGdldCBsaXZlU3luY1Bvc2l0aW9uKCkge1xuICAgIGNvbnN0IGxpdmVFZGdlID0gdGhpcy5lc3RpbWF0ZUxpdmVFZGdlKCk7XG4gICAgY29uc3QgdGFyZ2V0TGF0ZW5jeSA9IHRoaXMudGFyZ2V0TGF0ZW5jeTtcbiAgICBpZiAobGl2ZUVkZ2UgPT09IG51bGwgfHwgdGFyZ2V0TGF0ZW5jeSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IHRoaXMubGV2ZWxEZXRhaWxzO1xuICAgIGlmIChsZXZlbERldGFpbHMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBlZGdlID0gbGV2ZWxEZXRhaWxzLmVkZ2U7XG4gICAgY29uc3Qgc3luY1Bvc2l0aW9uID0gbGl2ZUVkZ2UgLSB0YXJnZXRMYXRlbmN5IC0gdGhpcy5lZGdlU3RhbGxlZDtcbiAgICBjb25zdCBtaW4gPSBlZGdlIC0gbGV2ZWxEZXRhaWxzLnRvdGFsZHVyYXRpb247XG4gICAgY29uc3QgbWF4ID0gZWRnZSAtICh0aGlzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZSAmJiBsZXZlbERldGFpbHMucGFydFRhcmdldCB8fCBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb24pO1xuICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChtaW4sIHN5bmNQb3NpdGlvbiksIG1heCk7XG4gIH1cbiAgZ2V0IGRyaWZ0KCkge1xuICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IHRoaXMubGV2ZWxEZXRhaWxzO1xuICAgIGlmIChsZXZlbERldGFpbHMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gbGV2ZWxEZXRhaWxzLmRyaWZ0O1xuICB9XG4gIGdldCBlZGdlU3RhbGxlZCgpIHtcbiAgICBjb25zdCBsZXZlbERldGFpbHMgPSB0aGlzLmxldmVsRGV0YWlscztcbiAgICBpZiAobGV2ZWxEZXRhaWxzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29uc3QgbWF4TGV2ZWxVcGRhdGVBZ2UgPSAodGhpcy5jb25maWcubG93TGF0ZW5jeU1vZGUgJiYgbGV2ZWxEZXRhaWxzLnBhcnRUYXJnZXQgfHwgbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uKSAqIDM7XG4gICAgcmV0dXJuIE1hdGgubWF4KGxldmVsRGV0YWlscy5hZ2UgLSBtYXhMZXZlbFVwZGF0ZUFnZSwgMCk7XG4gIH1cbiAgZ2V0IGZvcndhcmRCdWZmZXJMZW5ndGgoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbWVkaWFcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBsZXZlbERldGFpbHMgPSB0aGlzLmxldmVsRGV0YWlscztcbiAgICBpZiAoIW1lZGlhIHx8ICFsZXZlbERldGFpbHMpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb25zdCBidWZmZXJlZFJhbmdlcyA9IG1lZGlhLmJ1ZmZlcmVkLmxlbmd0aDtcbiAgICByZXR1cm4gKGJ1ZmZlcmVkUmFuZ2VzID8gbWVkaWEuYnVmZmVyZWQuZW5kKGJ1ZmZlcmVkUmFuZ2VzIC0gMSkgOiBsZXZlbERldGFpbHMuZWRnZSkgLSB0aGlzLmN1cnJlbnRUaW1lO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5vbk1lZGlhRGV0YWNoaW5nKCk7XG4gICAgdGhpcy5obHMgPSBudWxsO1xuICB9XG4gIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmICghaGxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGhscy5vbihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxfVVBEQVRFRCwgdGhpcy5vbkxldmVsVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfVxuICB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmICghaGxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX1VQREFURUQsIHRoaXMub25MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9XG4gIG9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuICAgIHRoaXMubWVkaWEuYWRkRXZlbnRMaXN0ZW5lcigndGltZXVwZGF0ZScsIHRoaXMub25UaW1ldXBkYXRlKTtcbiAgfVxuICBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgIGlmICh0aGlzLm1lZGlhKSB7XG4gICAgICB0aGlzLm1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RpbWV1cGRhdGUnLCB0aGlzLm9uVGltZXVwZGF0ZSk7XG4gICAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgdGhpcy5fbGF0ZW5jeSA9IG51bGw7XG4gICAgdGhpcy5zdGFsbENvdW50ID0gMDtcbiAgfVxuICBvbkxldmVsVXBkYXRlZChldmVudCwge1xuICAgIGRldGFpbHNcbiAgfSkge1xuICAgIGlmIChkZXRhaWxzLmFkdmFuY2VkKSB7XG4gICAgICB0aGlzLm9uVGltZXVwZGF0ZSgpO1xuICAgIH1cbiAgICBpZiAoIWRldGFpbHMubGl2ZSAmJiB0aGlzLm1lZGlhKSB7XG4gICAgICB0aGlzLm1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RpbWV1cGRhdGUnLCB0aGlzLm9uVGltZXVwZGF0ZSk7XG4gICAgfVxuICB9XG4gIG9uRXJyb3IoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgX3RoaXMkbGV2ZWxEZXRhaWxzO1xuICAgIGlmIChkYXRhLmRldGFpbHMgIT09IEVycm9yRGV0YWlscy5CVUZGRVJfU1RBTExFRF9FUlJPUikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnN0YWxsQ291bnQrKztcbiAgICBpZiAodGhpcy5obHMgJiYgKF90aGlzJGxldmVsRGV0YWlscyA9IHRoaXMubGV2ZWxEZXRhaWxzKSAhPSBudWxsICYmIF90aGlzJGxldmVsRGV0YWlscy5saXZlKSB7XG4gICAgICB0aGlzLmhscy5sb2dnZXIud2FybignW2xhdGVuY3ktY29udHJvbGxlcl06IFN0YWxsIGRldGVjdGVkLCBhZGp1c3RpbmcgdGFyZ2V0IGxhdGVuY3knKTtcbiAgICB9XG4gIH1cbiAgY2hhbmdlTWVkaWFQbGF5YmFja1JhdGUobWVkaWEsIHBsYXliYWNrUmF0ZSkge1xuICAgIHZhciBfdGhpcyRobHMyLCBfdGhpcyR0YXJnZXRMYXRlbmN5O1xuICAgIGlmIChtZWRpYS5wbGF5YmFja1JhdGUgPT09IHBsYXliYWNrUmF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAoX3RoaXMkaGxzMiA9IHRoaXMuaGxzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkaGxzMi5sb2dnZXIuZGVidWcoYFtsYXRlbmN5LWNvbnRyb2xsZXJdOiBsYXRlbmN5PSR7dGhpcy5sYXRlbmN5LnRvRml4ZWQoMyl9LCB0YXJnZXRMYXRlbmN5PSR7KF90aGlzJHRhcmdldExhdGVuY3kgPSB0aGlzLnRhcmdldExhdGVuY3kpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyR0YXJnZXRMYXRlbmN5LnRvRml4ZWQoMyl9LCBmb3J3YXJkQnVmZmVyTGVuZ3RoPSR7dGhpcy5mb3J3YXJkQnVmZmVyTGVuZ3RoLnRvRml4ZWQoMyl9OiBhZGp1c3RpbmcgcGxheWJhY2sgcmF0ZSBmcm9tICR7bWVkaWEucGxheWJhY2tSYXRlfSB0byAke3BsYXliYWNrUmF0ZX1gKTtcbiAgICBtZWRpYS5wbGF5YmFja1JhdGUgPSBwbGF5YmFja1JhdGU7XG4gIH1cbiAgZXN0aW1hdGVMaXZlRWRnZSgpIHtcbiAgICBjb25zdCBsZXZlbERldGFpbHMgPSB0aGlzLmxldmVsRGV0YWlscztcbiAgICBpZiAobGV2ZWxEZXRhaWxzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGxldmVsRGV0YWlscy5lZGdlICsgbGV2ZWxEZXRhaWxzLmFnZTtcbiAgfVxuICBjb21wdXRlTGF0ZW5jeSgpIHtcbiAgICBjb25zdCBsaXZlRWRnZSA9IHRoaXMuZXN0aW1hdGVMaXZlRWRnZSgpO1xuICAgIGlmIChsaXZlRWRnZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBsaXZlRWRnZSAtIHRoaXMuY3VycmVudFRpbWU7XG4gIH1cbn1cblxuY2xhc3MgTGV2ZWxDb250cm9sbGVyIGV4dGVuZHMgQmFzZVBsYXlsaXN0Q29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGhscywgY29udGVudFN0ZWVyaW5nQ29udHJvbGxlcikge1xuICAgIHN1cGVyKGhscywgJ2xldmVsLWNvbnRyb2xsZXInKTtcbiAgICB0aGlzLl9sZXZlbHMgPSBbXTtcbiAgICB0aGlzLl9maXJzdExldmVsID0gLTE7XG4gICAgdGhpcy5fbWF4QXV0b0xldmVsID0gLTE7XG4gICAgdGhpcy5fc3RhcnRMZXZlbCA9IHZvaWQgMDtcbiAgICB0aGlzLmN1cnJlbnRMZXZlbCA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50TGV2ZWxJbmRleCA9IC0xO1xuICAgIHRoaXMubWFudWFsTGV2ZWxJbmRleCA9IC0xO1xuICAgIHRoaXMuc3RlZXJpbmcgPSB2b2lkIDA7XG4gICAgdGhpcy5vblBhcnNlZENvbXBsZXRlID0gdm9pZCAwO1xuICAgIHRoaXMuc3RlZXJpbmcgPSBjb250ZW50U3RlZXJpbmdDb250cm9sbGVyO1xuICAgIHRoaXMuX3JlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgX3JlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FERUQsIHRoaXMub25NYW5pZmVzdExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTFNfVVBEQVRFRCwgdGhpcy5vbkxldmVsc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfVxuICBfdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FERUQsIHRoaXMub25NYW5pZmVzdExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMU19VUERBVEVELCB0aGlzLm9uTGV2ZWxzVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl91bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5zdGVlcmluZyA9IG51bGw7XG4gICAgdGhpcy5yZXNldExldmVscygpO1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgfVxuICBzdG9wTG9hZCgpIHtcbiAgICBjb25zdCBsZXZlbHMgPSB0aGlzLl9sZXZlbHM7XG5cbiAgICAvLyBjbGVhbiB1cCBsaXZlIGxldmVsIGRldGFpbHMgdG8gZm9yY2UgcmVsb2FkIHRoZW0sIGFuZCByZXNldCBsb2FkIGVycm9yc1xuICAgIGxldmVscy5mb3JFYWNoKGxldmVsID0+IHtcbiAgICAgIGxldmVsLmxvYWRFcnJvciA9IDA7XG4gICAgICBsZXZlbC5mcmFnbWVudEVycm9yID0gMDtcbiAgICB9KTtcbiAgICBzdXBlci5zdG9wTG9hZCgpO1xuICB9XG4gIHJlc2V0TGV2ZWxzKCkge1xuICAgIHRoaXMuX3N0YXJ0TGV2ZWwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYW51YWxMZXZlbEluZGV4ID0gLTE7XG4gICAgdGhpcy5jdXJyZW50TGV2ZWxJbmRleCA9IC0xO1xuICAgIHRoaXMuY3VycmVudExldmVsID0gbnVsbDtcbiAgICB0aGlzLl9sZXZlbHMgPSBbXTtcbiAgICB0aGlzLl9tYXhBdXRvTGV2ZWwgPSAtMTtcbiAgfVxuICBvbk1hbmlmZXN0TG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgIHRoaXMucmVzZXRMZXZlbHMoKTtcbiAgfVxuICBvbk1hbmlmZXN0TG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3QgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlID0gdGhpcy5obHMuY29uZmlnLnByZWZlck1hbmFnZWRNZWRpYVNvdXJjZTtcbiAgICBjb25zdCBsZXZlbHMgPSBbXTtcbiAgICBjb25zdCByZWR1bmRhbnRTZXQgPSB7fTtcbiAgICBjb25zdCBnZW5lcmF0ZVBhdGh3YXlTZXQgPSB7fTtcbiAgICBsZXQgcmVzb2x1dGlvbkZvdW5kID0gZmFsc2U7XG4gICAgbGV0IHZpZGVvQ29kZWNGb3VuZCA9IGZhbHNlO1xuICAgIGxldCBhdWRpb0NvZGVjRm91bmQgPSBmYWxzZTtcbiAgICBkYXRhLmxldmVscy5mb3JFYWNoKGxldmVsUGFyc2VkID0+IHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBsZXZlbFBhcnNlZC5hdHRycztcbiAgICAgIGxldCB7XG4gICAgICAgIGF1ZGlvQ29kZWMsXG4gICAgICAgIHZpZGVvQ29kZWNcbiAgICAgIH0gPSBsZXZlbFBhcnNlZDtcbiAgICAgIGlmIChhdWRpb0NvZGVjKSB7XG4gICAgICAgIC8vIFJldHVybnMgZW1wdHkgYW5kIHNldCB0byB1bmRlZmluZWQgZm9yICdtcDRhLjQwLjM0JyB3aXRoIGZhbGxiYWNrIHRvICdhdWRpby9tcGVnJyBTb3VyY2VCdWZmZXJcbiAgICAgICAgbGV2ZWxQYXJzZWQuYXVkaW9Db2RlYyA9IGF1ZGlvQ29kZWMgPSBnZXRDb2RlY0NvbXBhdGlibGVOYW1lKGF1ZGlvQ29kZWMsIHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSkgfHwgdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKHZpZGVvQ29kZWMpIHtcbiAgICAgICAgdmlkZW9Db2RlYyA9IGxldmVsUGFyc2VkLnZpZGVvQ29kZWMgPSBjb252ZXJ0QVZDMVRvQVZDT1RJKHZpZGVvQ29kZWMpO1xuICAgICAgfVxuXG4gICAgICAvLyBvbmx5IGtlZXAgbGV2ZWxzIHdpdGggc3VwcG9ydGVkIGF1ZGlvL3ZpZGVvIGNvZGVjc1xuICAgICAgY29uc3Qge1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICB1bmtub3duQ29kZWNzXG4gICAgICB9ID0gbGV2ZWxQYXJzZWQ7XG4gICAgICBsZXQgdW5rbm93blVuc3VwcG9ydGVkQ29kZWNDb3VudCA9IHVua25vd25Db2RlY3MgPyB1bmtub3duQ29kZWNzLmxlbmd0aCA6IDA7XG4gICAgICBpZiAodW5rbm93bkNvZGVjcykge1xuICAgICAgICAvLyBUcmVhdCB1bmtub3duIGNvZGVjIGFzIGF1ZGlvIG9yIHZpZGVvIGNvZGVjIGJhc2VkIG9uIHBhc3NpbmcgYGlzVHlwZVN1cHBvcnRlZGAgY2hlY2tcbiAgICAgICAgLy8gKGFsbG93cyBmb3IgcGxheWJhY2sgb2YgYW55IHN1cHBvcnRlZCBjb2RlYyBldmVuIGlmIG5vdCBpbmRleGVkIGluIHV0aWxzL2NvZGVjcylcbiAgICAgICAgZm9yIChsZXQgaSA9IHVua25vd25VbnN1cHBvcnRlZENvZGVjQ291bnQ7IGktLTspIHtcbiAgICAgICAgICBjb25zdCB1bmtub3duQ29kZWMgPSB1bmtub3duQ29kZWNzW2ldO1xuICAgICAgICAgIGlmICh0aGlzLmlzQXVkaW9TdXBwb3J0ZWQodW5rbm93bkNvZGVjKSkge1xuICAgICAgICAgICAgbGV2ZWxQYXJzZWQuYXVkaW9Db2RlYyA9IGF1ZGlvQ29kZWMgPSBhdWRpb0NvZGVjID8gYCR7YXVkaW9Db2RlY30sJHt1bmtub3duQ29kZWN9YCA6IHVua25vd25Db2RlYztcbiAgICAgICAgICAgIHVua25vd25VbnN1cHBvcnRlZENvZGVjQ291bnQtLTtcbiAgICAgICAgICAgIHNhbXBsZUVudHJ5Q29kZXNJU08uYXVkaW9bYXVkaW9Db2RlYy5zdWJzdHJpbmcoMCwgNCldID0gMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNWaWRlb1N1cHBvcnRlZCh1bmtub3duQ29kZWMpKSB7XG4gICAgICAgICAgICBsZXZlbFBhcnNlZC52aWRlb0NvZGVjID0gdmlkZW9Db2RlYyA9IHZpZGVvQ29kZWMgPyBgJHt2aWRlb0NvZGVjfSwke3Vua25vd25Db2RlY31gIDogdW5rbm93bkNvZGVjO1xuICAgICAgICAgICAgdW5rbm93blVuc3VwcG9ydGVkQ29kZWNDb3VudC0tO1xuICAgICAgICAgICAgc2FtcGxlRW50cnlDb2Rlc0lTTy52aWRlb1t2aWRlb0NvZGVjLnN1YnN0cmluZygwLCA0KV0gPSAyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzb2x1dGlvbkZvdW5kIHx8IChyZXNvbHV0aW9uRm91bmQgPSAhISh3aWR0aCAmJiBoZWlnaHQpKTtcbiAgICAgIHZpZGVvQ29kZWNGb3VuZCB8fCAodmlkZW9Db2RlY0ZvdW5kID0gISF2aWRlb0NvZGVjKTtcbiAgICAgIGF1ZGlvQ29kZWNGb3VuZCB8fCAoYXVkaW9Db2RlY0ZvdW5kID0gISFhdWRpb0NvZGVjKTtcbiAgICAgIGlmICh1bmtub3duVW5zdXBwb3J0ZWRDb2RlY0NvdW50IHx8IGF1ZGlvQ29kZWMgJiYgIXRoaXMuaXNBdWRpb1N1cHBvcnRlZChhdWRpb0NvZGVjKSB8fCB2aWRlb0NvZGVjICYmICF0aGlzLmlzVmlkZW9TdXBwb3J0ZWQodmlkZW9Db2RlYykpIHtcbiAgICAgICAgdGhpcy5sb2coYFNvbWUgb3IgYWxsIENPREVDUyBub3Qgc3VwcG9ydGVkIFwiJHthdHRyaWJ1dGVzLkNPREVDU31cImApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIENPREVDUyxcbiAgICAgICAgJ0ZSQU1FLVJBVEUnOiBGUkFNRVJBVEUsXG4gICAgICAgICdIRENQLUxFVkVMJzogSERDUCxcbiAgICAgICAgJ1BBVEhXQVktSUQnOiBQQVRIV0FZLFxuICAgICAgICBSRVNPTFVUSU9OLFxuICAgICAgICAnVklERU8tUkFOR0UnOiBWSURFT19SQU5HRVxuICAgICAgfSA9IGF0dHJpYnV0ZXM7XG4gICAgICBjb25zdCBjb250ZW50U3RlZXJpbmdQcmVmaXggPSBgJHtQQVRIV0FZIHx8ICcuJ30tYDtcbiAgICAgIGNvbnN0IGxldmVsS2V5ID0gYCR7Y29udGVudFN0ZWVyaW5nUHJlZml4fSR7bGV2ZWxQYXJzZWQuYml0cmF0ZX0tJHtSRVNPTFVUSU9OfS0ke0ZSQU1FUkFURX0tJHtDT0RFQ1N9LSR7VklERU9fUkFOR0V9LSR7SERDUH1gO1xuICAgICAgaWYgKCFyZWR1bmRhbnRTZXRbbGV2ZWxLZXldKSB7XG4gICAgICAgIGNvbnN0IGxldmVsID0gdGhpcy5jcmVhdGVMZXZlbChsZXZlbFBhcnNlZCk7XG4gICAgICAgIHJlZHVuZGFudFNldFtsZXZlbEtleV0gPSBsZXZlbDtcbiAgICAgICAgZ2VuZXJhdGVQYXRod2F5U2V0W2xldmVsS2V5XSA9IDE7XG4gICAgICAgIGxldmVscy5wdXNoKGxldmVsKTtcbiAgICAgIH0gZWxzZSBpZiAocmVkdW5kYW50U2V0W2xldmVsS2V5XS51cmkgIT09IGxldmVsUGFyc2VkLnVybCAmJiAhbGV2ZWxQYXJzZWQuYXR0cnNbJ1BBVEhXQVktSUQnXSkge1xuICAgICAgICAvLyBBc3NpZ24gUGF0aHdheSBJRHMgdG8gUmVkdW5kYW50IFN0cmVhbXMgKGRlZmF1bHQgUGF0aHdheXMgaXMgXCIuXCIuIFJlZHVuZGFudCBTdHJlYW1zIFwiLi5cIiwgXCIuLi5cIiwgYW5kIHNvIG9uLilcbiAgICAgICAgLy8gQ29udGVudCBTdGVlcmluZyBjb250cm9sbGVyIHRvIGhhbmRsZXMgUGF0aHdheSBmYWxsYmFjayBvbiBlcnJvclxuICAgICAgICBjb25zdCBwYXRod2F5Q291bnQgPSBnZW5lcmF0ZVBhdGh3YXlTZXRbbGV2ZWxLZXldICs9IDE7XG4gICAgICAgIGxldmVsUGFyc2VkLmF0dHJzWydQQVRIV0FZLUlEJ10gPSBuZXcgQXJyYXkocGF0aHdheUNvdW50ICsgMSkuam9pbignLicpO1xuICAgICAgICBjb25zdCBsZXZlbCA9IHRoaXMuY3JlYXRlTGV2ZWwobGV2ZWxQYXJzZWQpO1xuICAgICAgICByZWR1bmRhbnRTZXRbbGV2ZWxLZXldID0gbGV2ZWw7XG4gICAgICAgIGxldmVscy5wdXNoKGxldmVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZHVuZGFudFNldFtsZXZlbEtleV0uYWRkR3JvdXBJZCgnYXVkaW8nLCBhdHRyaWJ1dGVzLkFVRElPKTtcbiAgICAgICAgcmVkdW5kYW50U2V0W2xldmVsS2V5XS5hZGRHcm91cElkKCd0ZXh0JywgYXR0cmlidXRlcy5TVUJUSVRMRVMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZmlsdGVyQW5kU29ydE1lZGlhT3B0aW9ucyhsZXZlbHMsIGRhdGEsIHJlc29sdXRpb25Gb3VuZCwgdmlkZW9Db2RlY0ZvdW5kLCBhdWRpb0NvZGVjRm91bmQpO1xuICB9XG4gIGNyZWF0ZUxldmVsKGxldmVsUGFyc2VkKSB7XG4gICAgY29uc3QgbGV2ZWwgPSBuZXcgTGV2ZWwobGV2ZWxQYXJzZWQpO1xuICAgIGNvbnN0IHN1cHBsZW1lbnRhbCA9IGxldmVsUGFyc2VkLnN1cHBsZW1lbnRhbDtcbiAgICBpZiAoc3VwcGxlbWVudGFsICE9IG51bGwgJiYgc3VwcGxlbWVudGFsLnZpZGVvQ29kZWMgJiYgIXRoaXMuaXNWaWRlb1N1cHBvcnRlZChzdXBwbGVtZW50YWwudmlkZW9Db2RlYykpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBTVVBQTEVNRU5UQUwtQ09ERUNTIG5vdCBzdXBwb3J0ZWQgXCIke3N1cHBsZW1lbnRhbC52aWRlb0NvZGVjfVwiYCk7XG4gICAgICB0aGlzLmxvZyhlcnJvci5tZXNzYWdlKTtcbiAgICAgIGxldmVsLnN1cHBvcnRlZFJlc3VsdCA9IGdldFVuc3VwcG9ydGVkUmVzdWx0KGVycm9yLCBbXSk7XG4gICAgfVxuICAgIHJldHVybiBsZXZlbDtcbiAgfVxuICBpc0F1ZGlvU3VwcG9ydGVkKGNvZGVjKSB7XG4gICAgcmV0dXJuIGFyZUNvZGVjc01lZGlhU291cmNlU3VwcG9ydGVkKGNvZGVjLCAnYXVkaW8nLCB0aGlzLmhscy5jb25maWcucHJlZmVyTWFuYWdlZE1lZGlhU291cmNlKTtcbiAgfVxuICBpc1ZpZGVvU3VwcG9ydGVkKGNvZGVjKSB7XG4gICAgcmV0dXJuIGFyZUNvZGVjc01lZGlhU291cmNlU3VwcG9ydGVkKGNvZGVjLCAndmlkZW8nLCB0aGlzLmhscy5jb25maWcucHJlZmVyTWFuYWdlZE1lZGlhU291cmNlKTtcbiAgfVxuICBmaWx0ZXJBbmRTb3J0TWVkaWFPcHRpb25zKGZpbHRlcmVkTGV2ZWxzLCBkYXRhLCByZXNvbHV0aW9uRm91bmQsIHZpZGVvQ29kZWNGb3VuZCwgYXVkaW9Db2RlY0ZvdW5kKSB7XG4gICAgbGV0IGF1ZGlvVHJhY2tzID0gW107XG4gICAgbGV0IHN1YnRpdGxlVHJhY2tzID0gW107XG4gICAgbGV0IGxldmVscyA9IGZpbHRlcmVkTGV2ZWxzO1xuXG4gICAgLy8gcmVtb3ZlIGF1ZGlvLW9ubHkgYW5kIGludmFsaWQgdmlkZW8tcmFuZ2UgbGV2ZWxzIGlmIHdlIGFsc28gaGF2ZSBsZXZlbHMgd2l0aCB2aWRlbyBjb2RlY3Mgb3IgUkVTT0xVVElPTiBzaWduYWxsZWRcbiAgICBpZiAoKHJlc29sdXRpb25Gb3VuZCB8fCB2aWRlb0NvZGVjRm91bmQpICYmIGF1ZGlvQ29kZWNGb3VuZCkge1xuICAgICAgbGV2ZWxzID0gbGV2ZWxzLmZpbHRlcigoe1xuICAgICAgICB2aWRlb0NvZGVjLFxuICAgICAgICB2aWRlb1JhbmdlLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9KSA9PiAoISF2aWRlb0NvZGVjIHx8ICEhKHdpZHRoICYmIGhlaWdodCkpICYmIGlzVmlkZW9SYW5nZSh2aWRlb1JhbmdlKSk7XG4gICAgfVxuICAgIGlmIChsZXZlbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBEaXNwYXRjaCBlcnJvciBhZnRlciBNQU5JRkVTVF9MT0FERUQgaXMgZG9uZSBwcm9wYWdhdGluZ1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmhscykge1xuICAgICAgICAgIGxldCBtZXNzYWdlID0gJ25vIGxldmVsIHdpdGggY29tcGF0aWJsZSBjb2RlY3MgZm91bmQgaW4gbWFuaWZlc3QnO1xuICAgICAgICAgIGxldCByZWFzb24gPSBtZXNzYWdlO1xuICAgICAgICAgIGlmIChkYXRhLmxldmVscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlYXNvbiA9IGBvbmUgb3IgbW9yZSBDT0RFQ1MgaW4gdmFyaWFudCBub3Qgc3VwcG9ydGVkOiAke3N0cmluZ2lmeShkYXRhLmxldmVscy5tYXAobGV2ZWwgPT4gbGV2ZWwuYXR0cnMuQ09ERUNTKS5maWx0ZXIoKHZhbHVlLCBpbmRleCwgYXJyYXkpID0+IGFycmF5LmluZGV4T2YodmFsdWUpID09PSBpbmRleCkpfWA7XG4gICAgICAgICAgICB0aGlzLndhcm4ocmVhc29uKTtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gYCAoJHtyZWFzb259KWA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLk1BTklGRVNUX0lOQ09NUEFUSUJMRV9DT0RFQ1NfRVJST1IsXG4gICAgICAgICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgICAgICAgIHVybDogZGF0YS51cmwsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIHJlYXNvblxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRhdGEuYXVkaW9UcmFja3MpIHtcbiAgICAgIGF1ZGlvVHJhY2tzID0gZGF0YS5hdWRpb1RyYWNrcy5maWx0ZXIodHJhY2sgPT4gIXRyYWNrLmF1ZGlvQ29kZWMgfHwgdGhpcy5pc0F1ZGlvU3VwcG9ydGVkKHRyYWNrLmF1ZGlvQ29kZWMpKTtcbiAgICAgIC8vIEFzc2lnbiBpZHMgYWZ0ZXIgZmlsdGVyaW5nIGFzIGFycmF5IGluZGljZXMgYnkgZ3JvdXAtaWRcbiAgICAgIGFzc2lnblRyYWNrSWRzQnlHcm91cChhdWRpb1RyYWNrcyk7XG4gICAgfVxuICAgIGlmIChkYXRhLnN1YnRpdGxlcykge1xuICAgICAgc3VidGl0bGVUcmFja3MgPSBkYXRhLnN1YnRpdGxlcztcbiAgICAgIGFzc2lnblRyYWNrSWRzQnlHcm91cChzdWJ0aXRsZVRyYWNrcyk7XG4gICAgfVxuICAgIC8vIHN0YXJ0IGJpdHJhdGUgaXMgdGhlIGZpcnN0IGJpdHJhdGUgb2YgdGhlIG1hbmlmZXN0XG4gICAgY29uc3QgdW5zb3J0ZWRMZXZlbHMgPSBsZXZlbHMuc2xpY2UoMCk7XG4gICAgLy8gc29ydCBsZXZlbHMgZnJvbSBsb3dlc3QgdG8gaGlnaGVzdFxuICAgIGxldmVscy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBpZiAoYS5hdHRyc1snSERDUC1MRVZFTCddICE9PSBiLmF0dHJzWydIRENQLUxFVkVMJ10pIHtcbiAgICAgICAgcmV0dXJuIChhLmF0dHJzWydIRENQLUxFVkVMJ10gfHwgJycpID4gKGIuYXR0cnNbJ0hEQ1AtTEVWRUwnXSB8fCAnJykgPyAxIDogLTE7XG4gICAgICB9XG4gICAgICAvLyBzb3J0IG9uIGhlaWdodCBiZWZvcmUgYml0cmF0ZSBmb3IgY2FwLWxldmVsLWNvbnRyb2xsZXJcbiAgICAgIGlmIChyZXNvbHV0aW9uRm91bmQgJiYgYS5oZWlnaHQgIT09IGIuaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBhLmhlaWdodCAtIGIuaGVpZ2h0O1xuICAgICAgfVxuICAgICAgaWYgKGEuZnJhbWVSYXRlICE9PSBiLmZyYW1lUmF0ZSkge1xuICAgICAgICByZXR1cm4gYS5mcmFtZVJhdGUgLSBiLmZyYW1lUmF0ZTtcbiAgICAgIH1cbiAgICAgIGlmIChhLnZpZGVvUmFuZ2UgIT09IGIudmlkZW9SYW5nZSkge1xuICAgICAgICByZXR1cm4gVmlkZW9SYW5nZVZhbHVlcy5pbmRleE9mKGEudmlkZW9SYW5nZSkgLSBWaWRlb1JhbmdlVmFsdWVzLmluZGV4T2YoYi52aWRlb1JhbmdlKTtcbiAgICAgIH1cbiAgICAgIGlmIChhLnZpZGVvQ29kZWMgIT09IGIudmlkZW9Db2RlYykge1xuICAgICAgICBjb25zdCB2YWx1ZUEgPSB2aWRlb0NvZGVjUHJlZmVyZW5jZVZhbHVlKGEudmlkZW9Db2RlYyk7XG4gICAgICAgIGNvbnN0IHZhbHVlQiA9IHZpZGVvQ29kZWNQcmVmZXJlbmNlVmFsdWUoYi52aWRlb0NvZGVjKTtcbiAgICAgICAgaWYgKHZhbHVlQSAhPT0gdmFsdWVCKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlQiAtIHZhbHVlQTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGEudXJpID09PSBiLnVyaSAmJiBhLmNvZGVjU2V0ICE9PSBiLmNvZGVjU2V0KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlQSA9IGNvZGVjc1NldFNlbGVjdGlvblByZWZlcmVuY2VWYWx1ZShhLmNvZGVjU2V0KTtcbiAgICAgICAgY29uc3QgdmFsdWVCID0gY29kZWNzU2V0U2VsZWN0aW9uUHJlZmVyZW5jZVZhbHVlKGIuY29kZWNTZXQpO1xuICAgICAgICBpZiAodmFsdWVBICE9PSB2YWx1ZUIpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWVCIC0gdmFsdWVBO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYS5hdmVyYWdlQml0cmF0ZSAhPT0gYi5hdmVyYWdlQml0cmF0ZSkge1xuICAgICAgICByZXR1cm4gYS5hdmVyYWdlQml0cmF0ZSAtIGIuYXZlcmFnZUJpdHJhdGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9KTtcbiAgICBsZXQgZmlyc3RMZXZlbEluUGxheWxpc3QgPSB1bnNvcnRlZExldmVsc1swXTtcbiAgICBpZiAodGhpcy5zdGVlcmluZykge1xuICAgICAgbGV2ZWxzID0gdGhpcy5zdGVlcmluZy5maWx0ZXJQYXJzZWRMZXZlbHMobGV2ZWxzKTtcbiAgICAgIGlmIChsZXZlbHMubGVuZ3RoICE9PSB1bnNvcnRlZExldmVscy5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1bnNvcnRlZExldmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICh1bnNvcnRlZExldmVsc1tpXS5wYXRod2F5SWQgPT09IGxldmVsc1swXS5wYXRod2F5SWQpIHtcbiAgICAgICAgICAgIGZpcnN0TGV2ZWxJblBsYXlsaXN0ID0gdW5zb3J0ZWRMZXZlbHNbaV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fbGV2ZWxzID0gbGV2ZWxzO1xuXG4gICAgLy8gZmluZCBpbmRleCBvZiBmaXJzdCBsZXZlbCBpbiBzb3J0ZWQgbGV2ZWxzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsZXZlbHNbaV0gPT09IGZpcnN0TGV2ZWxJblBsYXlsaXN0KSB7XG4gICAgICAgIHZhciBfdGhpcyRobHMkdXNlckNvbmZpZztcbiAgICAgICAgdGhpcy5fZmlyc3RMZXZlbCA9IGk7XG4gICAgICAgIGNvbnN0IGZpcnN0TGV2ZWxCaXRyYXRlID0gZmlyc3RMZXZlbEluUGxheWxpc3QuYml0cmF0ZTtcbiAgICAgICAgY29uc3QgYmFuZHdpZHRoRXN0aW1hdGUgPSB0aGlzLmhscy5iYW5kd2lkdGhFc3RpbWF0ZTtcbiAgICAgICAgdGhpcy5sb2coYG1hbmlmZXN0IGxvYWRlZCwgJHtsZXZlbHMubGVuZ3RofSBsZXZlbChzKSBmb3VuZCwgZmlyc3QgYml0cmF0ZTogJHtmaXJzdExldmVsQml0cmF0ZX1gKTtcbiAgICAgICAgLy8gVXBkYXRlIGRlZmF1bHQgYndlIHRvIGZpcnN0IHZhcmlhbnQgYml0cmF0ZSBhcyBsb25nIGl0IGhhcyBub3QgYmVlbiBjb25maWd1cmVkIG9yIHNldFxuICAgICAgICBpZiAoKChfdGhpcyRobHMkdXNlckNvbmZpZyA9IHRoaXMuaGxzLnVzZXJDb25maWcpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRobHMkdXNlckNvbmZpZy5hYnJFd21hRGVmYXVsdEVzdGltYXRlKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29uc3Qgc3RhcnRpbmdCd0VzdGltYXRlID0gTWF0aC5taW4oZmlyc3RMZXZlbEJpdHJhdGUsIHRoaXMuaGxzLmNvbmZpZy5hYnJFd21hRGVmYXVsdEVzdGltYXRlTWF4KTtcbiAgICAgICAgICBpZiAoc3RhcnRpbmdCd0VzdGltYXRlID4gYmFuZHdpZHRoRXN0aW1hdGUgJiYgYmFuZHdpZHRoRXN0aW1hdGUgPT09IHRoaXMuaGxzLmFickV3bWFEZWZhdWx0RXN0aW1hdGUpIHtcbiAgICAgICAgICAgIHRoaXMuaGxzLmJhbmR3aWR0aEVzdGltYXRlID0gc3RhcnRpbmdCd0VzdGltYXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBdWRpbyBpcyBvbmx5IGFsdGVybmF0ZSBpZiBtYW5pZmVzdCBpbmNsdWRlIGEgVVJJIGFsb25nIHdpdGggdGhlIGF1ZGlvIGdyb3VwIHRhZyxcbiAgICAvLyBhbmQgdGhpcyBpcyBub3QgYW4gYXVkaW8tb25seSBzdHJlYW0gd2hlcmUgbGV2ZWxzIGNvbnRhaW4gYXVkaW8tb25seVxuICAgIGNvbnN0IGF1ZGlvT25seSA9IGF1ZGlvQ29kZWNGb3VuZCAmJiAhdmlkZW9Db2RlY0ZvdW5kO1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcbiAgICBjb25zdCBhbHRBdWRpb0VuYWJsZWQgPSAhIShjb25maWcuYXVkaW9TdHJlYW1Db250cm9sbGVyICYmIGNvbmZpZy5hdWRpb1RyYWNrQ29udHJvbGxlcik7XG4gICAgY29uc3QgZWRhdGEgPSB7XG4gICAgICBsZXZlbHMsXG4gICAgICBhdWRpb1RyYWNrcyxcbiAgICAgIHN1YnRpdGxlVHJhY2tzLFxuICAgICAgc2Vzc2lvbkRhdGE6IGRhdGEuc2Vzc2lvbkRhdGEsXG4gICAgICBzZXNzaW9uS2V5czogZGF0YS5zZXNzaW9uS2V5cyxcbiAgICAgIGZpcnN0TGV2ZWw6IHRoaXMuX2ZpcnN0TGV2ZWwsXG4gICAgICBzdGF0czogZGF0YS5zdGF0cyxcbiAgICAgIGF1ZGlvOiBhdWRpb0NvZGVjRm91bmQsXG4gICAgICB2aWRlbzogdmlkZW9Db2RlY0ZvdW5kLFxuICAgICAgYWx0QXVkaW86IGFsdEF1ZGlvRW5hYmxlZCAmJiAhYXVkaW9Pbmx5ICYmIGF1ZGlvVHJhY2tzLnNvbWUodCA9PiAhIXQudXJsKVxuICAgIH07XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCBlZGF0YSk7XG4gIH1cbiAgZ2V0IGxldmVscygpIHtcbiAgICBpZiAodGhpcy5fbGV2ZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9sZXZlbHM7XG4gIH1cbiAgZ2V0IGxvYWRMZXZlbE9iaigpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50TGV2ZWw7XG4gIH1cbiAgZ2V0IGxldmVsKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRMZXZlbEluZGV4O1xuICB9XG4gIHNldCBsZXZlbChuZXdMZXZlbCkge1xuICAgIGNvbnN0IGxldmVscyA9IHRoaXMuX2xldmVscztcbiAgICBpZiAobGV2ZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBjaGVjayBpZiBsZXZlbCBpZHggaXMgdmFsaWRcbiAgICBpZiAobmV3TGV2ZWwgPCAwIHx8IG5ld0xldmVsID49IGxldmVscy5sZW5ndGgpIHtcbiAgICAgIC8vIGludmFsaWQgbGV2ZWwgaWQgZ2l2ZW4sIHRyaWdnZXIgZXJyb3JcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdpbnZhbGlkIGxldmVsIGlkeCcpO1xuICAgICAgY29uc3QgZmF0YWwgPSBuZXdMZXZlbCA8IDA7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuTEVWRUxfU1dJVENIX0VSUk9SLFxuICAgICAgICBsZXZlbDogbmV3TGV2ZWwsXG4gICAgICAgIGZhdGFsLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgcmVhc29uOiBlcnJvci5tZXNzYWdlXG4gICAgICB9KTtcbiAgICAgIGlmIChmYXRhbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBuZXdMZXZlbCA9IE1hdGgubWluKG5ld0xldmVsLCBsZXZlbHMubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIGNvbnN0IGxhc3RMZXZlbEluZGV4ID0gdGhpcy5jdXJyZW50TGV2ZWxJbmRleDtcbiAgICBjb25zdCBsYXN0TGV2ZWwgPSB0aGlzLmN1cnJlbnRMZXZlbDtcbiAgICBjb25zdCBsYXN0UGF0aHdheUlkID0gbGFzdExldmVsID8gbGFzdExldmVsLmF0dHJzWydQQVRIV0FZLUlEJ10gOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgbGV2ZWwgPSBsZXZlbHNbbmV3TGV2ZWxdO1xuICAgIGNvbnN0IHBhdGh3YXlJZCA9IGxldmVsLmF0dHJzWydQQVRIV0FZLUlEJ107XG4gICAgdGhpcy5jdXJyZW50TGV2ZWxJbmRleCA9IG5ld0xldmVsO1xuICAgIHRoaXMuY3VycmVudExldmVsID0gbGV2ZWw7XG4gICAgaWYgKGxhc3RMZXZlbEluZGV4ID09PSBuZXdMZXZlbCAmJiBsYXN0TGV2ZWwgJiYgbGFzdFBhdGh3YXlJZCA9PT0gcGF0aHdheUlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubG9nKGBTd2l0Y2hpbmcgdG8gbGV2ZWwgJHtuZXdMZXZlbH0gKCR7bGV2ZWwuaGVpZ2h0ID8gbGV2ZWwuaGVpZ2h0ICsgJ3AgJyA6ICcnfSR7bGV2ZWwudmlkZW9SYW5nZSA/IGxldmVsLnZpZGVvUmFuZ2UgKyAnICcgOiAnJ30ke2xldmVsLmNvZGVjU2V0ID8gbGV2ZWwuY29kZWNTZXQgKyAnICcgOiAnJ31AJHtsZXZlbC5iaXRyYXRlfSkke3BhdGh3YXlJZCA/ICcgd2l0aCBQYXRod2F5ICcgKyBwYXRod2F5SWQgOiAnJ30gZnJvbSBsZXZlbCAke2xhc3RMZXZlbEluZGV4fSR7bGFzdFBhdGh3YXlJZCA/ICcgd2l0aCBQYXRod2F5ICcgKyBsYXN0UGF0aHdheUlkIDogJyd9YCk7XG4gICAgY29uc3QgbGV2ZWxTd2l0Y2hpbmdEYXRhID0ge1xuICAgICAgbGV2ZWw6IG5ld0xldmVsLFxuICAgICAgYXR0cnM6IGxldmVsLmF0dHJzLFxuICAgICAgZGV0YWlsczogbGV2ZWwuZGV0YWlscyxcbiAgICAgIGJpdHJhdGU6IGxldmVsLmJpdHJhdGUsXG4gICAgICBhdmVyYWdlQml0cmF0ZTogbGV2ZWwuYXZlcmFnZUJpdHJhdGUsXG4gICAgICBtYXhCaXRyYXRlOiBsZXZlbC5tYXhCaXRyYXRlLFxuICAgICAgcmVhbEJpdHJhdGU6IGxldmVsLnJlYWxCaXRyYXRlLFxuICAgICAgd2lkdGg6IGxldmVsLndpZHRoLFxuICAgICAgaGVpZ2h0OiBsZXZlbC5oZWlnaHQsXG4gICAgICBjb2RlY1NldDogbGV2ZWwuY29kZWNTZXQsXG4gICAgICBhdWRpb0NvZGVjOiBsZXZlbC5hdWRpb0NvZGVjLFxuICAgICAgdmlkZW9Db2RlYzogbGV2ZWwudmlkZW9Db2RlYyxcbiAgICAgIGF1ZGlvR3JvdXBzOiBsZXZlbC5hdWRpb0dyb3VwcyxcbiAgICAgIHN1YnRpdGxlR3JvdXBzOiBsZXZlbC5zdWJ0aXRsZUdyb3VwcyxcbiAgICAgIGxvYWRlZDogbGV2ZWwubG9hZGVkLFxuICAgICAgbG9hZEVycm9yOiBsZXZlbC5sb2FkRXJyb3IsXG4gICAgICBmcmFnbWVudEVycm9yOiBsZXZlbC5mcmFnbWVudEVycm9yLFxuICAgICAgbmFtZTogbGV2ZWwubmFtZSxcbiAgICAgIGlkOiBsZXZlbC5pZCxcbiAgICAgIHVyaTogbGV2ZWwudXJpLFxuICAgICAgdXJsOiBsZXZlbC51cmwsXG4gICAgICB1cmxJZDogMCxcbiAgICAgIGF1ZGlvR3JvdXBJZHM6IGxldmVsLmF1ZGlvR3JvdXBJZHMsXG4gICAgICB0ZXh0R3JvdXBJZHM6IGxldmVsLnRleHRHcm91cElkc1xuICAgIH07XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTEVWRUxfU1dJVENISU5HLCBsZXZlbFN3aXRjaGluZ0RhdGEpO1xuICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gbG9hZCBwbGF5bGlzdCBmb3IgdGhpcyBsZXZlbFxuICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IGxldmVsLmRldGFpbHM7XG4gICAgaWYgKCFsZXZlbERldGFpbHMgfHwgbGV2ZWxEZXRhaWxzLmxpdmUpIHtcbiAgICAgIC8vIGxldmVsIG5vdCByZXRyaWV2ZWQgeWV0LCBvciBsaXZlIHBsYXlsaXN0IHdlIG5lZWQgdG8gKHJlKWxvYWQgaXRcbiAgICAgIGNvbnN0IGhsc1VybFBhcmFtZXRlcnMgPSB0aGlzLnN3aXRjaFBhcmFtcyhsZXZlbC51cmksIGxhc3RMZXZlbCA9PSBudWxsID8gdm9pZCAwIDogbGFzdExldmVsLmRldGFpbHMsIGxldmVsRGV0YWlscyk7XG4gICAgICB0aGlzLmxvYWRQbGF5bGlzdChobHNVcmxQYXJhbWV0ZXJzKTtcbiAgICB9XG4gIH1cbiAgZ2V0IG1hbnVhbExldmVsKCkge1xuICAgIHJldHVybiB0aGlzLm1hbnVhbExldmVsSW5kZXg7XG4gIH1cbiAgc2V0IG1hbnVhbExldmVsKG5ld0xldmVsKSB7XG4gICAgdGhpcy5tYW51YWxMZXZlbEluZGV4ID0gbmV3TGV2ZWw7XG4gICAgaWYgKHRoaXMuX3N0YXJ0TGV2ZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fc3RhcnRMZXZlbCA9IG5ld0xldmVsO1xuICAgIH1cbiAgICBpZiAobmV3TGV2ZWwgIT09IC0xKSB7XG4gICAgICB0aGlzLmxldmVsID0gbmV3TGV2ZWw7XG4gICAgfVxuICB9XG4gIGdldCBmaXJzdExldmVsKCkge1xuICAgIHJldHVybiB0aGlzLl9maXJzdExldmVsO1xuICB9XG4gIHNldCBmaXJzdExldmVsKG5ld0xldmVsKSB7XG4gICAgdGhpcy5fZmlyc3RMZXZlbCA9IG5ld0xldmVsO1xuICB9XG4gIGdldCBzdGFydExldmVsKCkge1xuICAgIC8vIFNldHRpbmcgaGxzLnN0YXJ0TGV2ZWwgKHRoaXMuX3N0YXJ0TGV2ZWwpIG92ZXJyaWRlcyBjb25maWcuc3RhcnRMZXZlbFxuICAgIGlmICh0aGlzLl9zdGFydExldmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGNvbmZpZ1N0YXJ0TGV2ZWwgPSB0aGlzLmhscy5jb25maWcuc3RhcnRMZXZlbDtcbiAgICAgIGlmIChjb25maWdTdGFydExldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZ1N0YXJ0TGV2ZWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5obHMuZmlyc3RBdXRvTGV2ZWw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zdGFydExldmVsO1xuICB9XG4gIHNldCBzdGFydExldmVsKG5ld0xldmVsKSB7XG4gICAgdGhpcy5fc3RhcnRMZXZlbCA9IG5ld0xldmVsO1xuICB9XG4gIGdldCBwYXRod2F5cygpIHtcbiAgICBpZiAodGhpcy5zdGVlcmluZykge1xuICAgICAgcmV0dXJuIHRoaXMuc3RlZXJpbmcucGF0aHdheXMoKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGdldCBwYXRod2F5UHJpb3JpdHkoKSB7XG4gICAgaWYgKHRoaXMuc3RlZXJpbmcpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0ZWVyaW5nLnBhdGh3YXlQcmlvcml0eTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgc2V0IHBhdGh3YXlQcmlvcml0eShwYXRod2F5UHJpb3JpdHkpIHtcbiAgICBpZiAodGhpcy5zdGVlcmluZykge1xuICAgICAgY29uc3QgcGF0aHdheXNMaXN0ID0gdGhpcy5zdGVlcmluZy5wYXRod2F5cygpO1xuICAgICAgY29uc3QgZmlsdGVyZWRQYXRod2F5UHJpb3JpdHkgPSBwYXRod2F5UHJpb3JpdHkuZmlsdGVyKHBhdGh3YXlJZCA9PiB7XG4gICAgICAgIHJldHVybiBwYXRod2F5c0xpc3QuaW5kZXhPZihwYXRod2F5SWQpICE9PSAtMTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHBhdGh3YXlQcmlvcml0eS5sZW5ndGggPCAxKSB7XG4gICAgICAgIHRoaXMud2FybihgcGF0aHdheVByaW9yaXR5ICR7cGF0aHdheVByaW9yaXR5fSBzaG91bGQgY29udGFpbiBhdCBsZWFzdCBvbmUgcGF0aHdheSBmcm9tIGxpc3Q6ICR7cGF0aHdheXNMaXN0fWApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnN0ZWVyaW5nLnBhdGh3YXlQcmlvcml0eSA9IGZpbHRlcmVkUGF0aHdheVByaW9yaXR5O1xuICAgIH1cbiAgfVxuICBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKGRhdGEuZmF0YWwgfHwgIWRhdGEuY29udGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGF0YS5jb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuTEVWRUwgJiYgZGF0YS5jb250ZXh0LmxldmVsID09PSB0aGlzLmxldmVsKSB7XG4gICAgICB0aGlzLmNoZWNrUmV0cnkoZGF0YSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcmVzZXQgZXJyb3JzIG9uIHRoZSBzdWNjZXNzZnVsIGxvYWQgb2YgYSBmcmFnbWVudFxuICBvbkZyYWdCdWZmZXJlZChldmVudCwge1xuICAgIGZyYWdcbiAgfSkge1xuICAgIGlmIChmcmFnICE9PSB1bmRlZmluZWQgJiYgZnJhZy50eXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOKSB7XG4gICAgICBjb25zdCBlbCA9IGZyYWcuZWxlbWVudGFyeVN0cmVhbXM7XG4gICAgICBpZiAoIU9iamVjdC5rZXlzKGVsKS5zb21lKHR5cGUgPT4gISFlbFt0eXBlXSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbGV2ZWwgPSB0aGlzLl9sZXZlbHNbZnJhZy5sZXZlbF07XG4gICAgICBpZiAobGV2ZWwgIT0gbnVsbCAmJiBsZXZlbC5sb2FkRXJyb3IpIHtcbiAgICAgICAgdGhpcy5sb2coYFJlc2V0dGluZyBsZXZlbCBlcnJvciBjb3VudCBvZiAke2xldmVsLmxvYWRFcnJvcn0gb24gZnJhZyBidWZmZXJlZGApO1xuICAgICAgICBsZXZlbC5sb2FkRXJyb3IgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBvbkxldmVsTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF9kYXRhJGRlbGl2ZXJ5RGlyZWN0aTI7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWwsXG4gICAgICBkZXRhaWxzXG4gICAgfSA9IGRhdGE7XG4gICAgY29uc3QgY3VyTGV2ZWwgPSBkYXRhLmxldmVsSW5mbztcbiAgICBpZiAoIWN1ckxldmVsKSB7XG4gICAgICB2YXIgX2RhdGEkZGVsaXZlcnlEaXJlY3RpO1xuICAgICAgdGhpcy53YXJuKGBJbnZhbGlkIGxldmVsIGluZGV4ICR7bGV2ZWx9YCk7XG4gICAgICBpZiAoKF9kYXRhJGRlbGl2ZXJ5RGlyZWN0aSA9IGRhdGEuZGVsaXZlcnlEaXJlY3RpdmVzKSAhPSBudWxsICYmIF9kYXRhJGRlbGl2ZXJ5RGlyZWN0aS5za2lwKSB7XG4gICAgICAgIGRldGFpbHMuZGVsdGFVcGRhdGVGYWlsZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIG9ubHkgcHJvY2VzcyBsZXZlbCBsb2FkZWQgZXZlbnRzIG1hdGNoaW5nIHdpdGggZXhwZWN0ZWQgbGV2ZWwgb3IgcHJpb3IgdG8gc3dpdGNoIHdoZW4gbWVkaWEgcGxheWxpc3QgaXMgbG9hZGVkIGRpcmVjdGx5XG4gICAgaWYgKGN1ckxldmVsID09PSB0aGlzLmN1cnJlbnRMZXZlbCB8fCBkYXRhLndpdGhvdXRNdWx0aVZhcmlhbnQpIHtcbiAgICAgIC8vIHJlc2V0IGxldmVsIGxvYWQgZXJyb3IgY291bnRlciBvbiBzdWNjZXNzZnVsIGxldmVsIGxvYWRlZCBvbmx5IGlmIHRoZXJlIGlzIG5vIGlzc3VlcyB3aXRoIGZyYWdtZW50c1xuICAgICAgaWYgKGN1ckxldmVsLmZyYWdtZW50RXJyb3IgPT09IDApIHtcbiAgICAgICAgY3VyTGV2ZWwubG9hZEVycm9yID0gMDtcbiAgICAgIH1cbiAgICAgIC8vIElnbm9yZSBtYXRjaGluZyBkZXRhaWxzIHBvcHVsYXRlZCBieSBsb2FkaW5nIGEgTWVkaWEgUGxheWxpc3QgZGlyZWN0bHlcbiAgICAgIGxldCBwcmV2aW91c0RldGFpbHMgPSBjdXJMZXZlbC5kZXRhaWxzO1xuICAgICAgaWYgKHByZXZpb3VzRGV0YWlscyA9PT0gZGF0YS5kZXRhaWxzICYmIHByZXZpb3VzRGV0YWlscy5hZHZhbmNlZCkge1xuICAgICAgICBwcmV2aW91c0RldGFpbHMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB0aGlzLnBsYXlsaXN0TG9hZGVkKGxldmVsLCBkYXRhLCBwcmV2aW91c0RldGFpbHMpO1xuICAgIH0gZWxzZSBpZiAoKF9kYXRhJGRlbGl2ZXJ5RGlyZWN0aTIgPSBkYXRhLmRlbGl2ZXJ5RGlyZWN0aXZlcykgIT0gbnVsbCAmJiBfZGF0YSRkZWxpdmVyeURpcmVjdGkyLnNraXApIHtcbiAgICAgIC8vIHJlY2VpdmVkIGEgZGVsdGEgcGxheWxpc3QgdXBkYXRlIHRoYXQgY2Fubm90IGJlIG1lcmdlZFxuICAgICAgZGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIGxvYWRQbGF5bGlzdChobHNVcmxQYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIubG9hZFBsYXlsaXN0KCk7XG4gICAgaWYgKHRoaXMuc2hvdWxkTG9hZFBsYXlsaXN0KHRoaXMuY3VycmVudExldmVsKSkge1xuICAgICAgdGhpcy5zY2hlZHVsZUxvYWRpbmcodGhpcy5jdXJyZW50TGV2ZWwsIGhsc1VybFBhcmFtZXRlcnMpO1xuICAgIH1cbiAgfVxuICBsb2FkaW5nUGxheWxpc3QoY3VycmVudExldmVsLCBobHNVcmxQYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIubG9hZGluZ1BsYXlsaXN0KGN1cnJlbnRMZXZlbCwgaGxzVXJsUGFyYW1ldGVycyk7XG4gICAgY29uc3QgdXJsID0gdGhpcy5nZXRVcmxXaXRoRGlyZWN0aXZlcyhjdXJyZW50TGV2ZWwudXJpLCBobHNVcmxQYXJhbWV0ZXJzKTtcbiAgICBjb25zdCBjdXJyZW50TGV2ZWxJbmRleCA9IHRoaXMuY3VycmVudExldmVsSW5kZXg7XG4gICAgY29uc3QgcGF0aHdheUlkID0gY3VycmVudExldmVsLmF0dHJzWydQQVRIV0FZLUlEJ107XG4gICAgY29uc3QgZGV0YWlscyA9IGN1cnJlbnRMZXZlbC5kZXRhaWxzO1xuICAgIGNvbnN0IGFnZSA9IGRldGFpbHMgPT0gbnVsbCA/IHZvaWQgMCA6IGRldGFpbHMuYWdlO1xuICAgIHRoaXMubG9nKGBMb2FkaW5nIGxldmVsIGluZGV4ICR7Y3VycmVudExldmVsSW5kZXh9JHsoaGxzVXJsUGFyYW1ldGVycyA9PSBudWxsID8gdm9pZCAwIDogaGxzVXJsUGFyYW1ldGVycy5tc24pICE9PSB1bmRlZmluZWQgPyAnIGF0IHNuICcgKyBobHNVcmxQYXJhbWV0ZXJzLm1zbiArICcgcGFydCAnICsgaGxzVXJsUGFyYW1ldGVycy5wYXJ0IDogJyd9JHtwYXRod2F5SWQgPyAnIFBhdGh3YXkgJyArIHBhdGh3YXlJZCA6ICcnfSR7YWdlICYmIGRldGFpbHMubGl2ZSA/ICcgYWdlICcgKyBhZ2UudG9GaXhlZCgxKSArIChkZXRhaWxzLnR5cGUgPyAnICcgKyBkZXRhaWxzLnR5cGUgfHwgJycgOiAnJykgOiAnJ30gJHt1cmx9YCk7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTEVWRUxfTE9BRElORywge1xuICAgICAgdXJsLFxuICAgICAgbGV2ZWw6IGN1cnJlbnRMZXZlbEluZGV4LFxuICAgICAgbGV2ZWxJbmZvOiBjdXJyZW50TGV2ZWwsXG4gICAgICBwYXRod2F5SWQ6IGN1cnJlbnRMZXZlbC5hdHRyc1snUEFUSFdBWS1JRCddLFxuICAgICAgaWQ6IDAsXG4gICAgICAvLyBEZXByZWNhdGVkIExldmVsIHVybElkXG4gICAgICBkZWxpdmVyeURpcmVjdGl2ZXM6IGhsc1VybFBhcmFtZXRlcnMgfHwgbnVsbFxuICAgIH0pO1xuICB9XG4gIGdldCBuZXh0TG9hZExldmVsKCkge1xuICAgIGlmICh0aGlzLm1hbnVhbExldmVsSW5kZXggIT09IC0xKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYW51YWxMZXZlbEluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5obHMubmV4dEF1dG9MZXZlbDtcbiAgICB9XG4gIH1cbiAgc2V0IG5leHRMb2FkTGV2ZWwobmV4dExldmVsKSB7XG4gICAgdGhpcy5sZXZlbCA9IG5leHRMZXZlbDtcbiAgICBpZiAodGhpcy5tYW51YWxMZXZlbEluZGV4ID09PSAtMSkge1xuICAgICAgdGhpcy5obHMubmV4dEF1dG9MZXZlbCA9IG5leHRMZXZlbDtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlTGV2ZWwobGV2ZWxJbmRleCkge1xuICAgIHZhciBfdGhpcyRjdXJyZW50TGV2ZWw7XG4gICAgaWYgKHRoaXMuX2xldmVscy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGV2ZWxzID0gdGhpcy5fbGV2ZWxzLmZpbHRlcigobGV2ZWwsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoaW5kZXggIT09IGxldmVsSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdGVlcmluZykge1xuICAgICAgICB0aGlzLnN0ZWVyaW5nLnJlbW92ZUxldmVsKGxldmVsKTtcbiAgICAgIH1cbiAgICAgIGlmIChsZXZlbCA9PT0gdGhpcy5jdXJyZW50TGV2ZWwpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50TGV2ZWwgPSBudWxsO1xuICAgICAgICB0aGlzLmN1cnJlbnRMZXZlbEluZGV4ID0gLTE7XG4gICAgICAgIGlmIChsZXZlbC5kZXRhaWxzKSB7XG4gICAgICAgICAgbGV2ZWwuZGV0YWlscy5mcmFnbWVudHMuZm9yRWFjaChmID0+IGYubGV2ZWwgPSAtMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgICByZWFzc2lnbkZyYWdtZW50TGV2ZWxJbmRleGVzKGxldmVscyk7XG4gICAgdGhpcy5fbGV2ZWxzID0gbGV2ZWxzO1xuICAgIGlmICh0aGlzLmN1cnJlbnRMZXZlbEluZGV4ID4gLTEgJiYgKF90aGlzJGN1cnJlbnRMZXZlbCA9IHRoaXMuY3VycmVudExldmVsKSAhPSBudWxsICYmIF90aGlzJGN1cnJlbnRMZXZlbC5kZXRhaWxzKSB7XG4gICAgICB0aGlzLmN1cnJlbnRMZXZlbEluZGV4ID0gdGhpcy5jdXJyZW50TGV2ZWwuZGV0YWlscy5mcmFnbWVudHNbMF0ubGV2ZWw7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hbnVhbExldmVsSW5kZXggPiAtMSkge1xuICAgICAgdGhpcy5tYW51YWxMZXZlbEluZGV4ID0gdGhpcy5jdXJyZW50TGV2ZWxJbmRleDtcbiAgICB9XG4gICAgY29uc3QgbWF4TGV2ZWwgPSBsZXZlbHMubGVuZ3RoIC0gMTtcbiAgICB0aGlzLl9maXJzdExldmVsID0gTWF0aC5taW4odGhpcy5fZmlyc3RMZXZlbCwgbWF4TGV2ZWwpO1xuICAgIGlmICh0aGlzLl9zdGFydExldmVsKSB7XG4gICAgICB0aGlzLl9zdGFydExldmVsID0gTWF0aC5taW4odGhpcy5fc3RhcnRMZXZlbCwgbWF4TGV2ZWwpO1xuICAgIH1cbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5MRVZFTFNfVVBEQVRFRCwge1xuICAgICAgbGV2ZWxzXG4gICAgfSk7XG4gIH1cbiAgb25MZXZlbHNVcGRhdGVkKGV2ZW50LCB7XG4gICAgbGV2ZWxzXG4gIH0pIHtcbiAgICB0aGlzLl9sZXZlbHMgPSBsZXZlbHM7XG4gIH1cbiAgY2hlY2tNYXhBdXRvVXBkYXRlZCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBhdXRvTGV2ZWxDYXBwaW5nLFxuICAgICAgbWF4QXV0b0xldmVsLFxuICAgICAgbWF4SGRjcExldmVsXG4gICAgfSA9IHRoaXMuaGxzO1xuICAgIGlmICh0aGlzLl9tYXhBdXRvTGV2ZWwgIT09IG1heEF1dG9MZXZlbCkge1xuICAgICAgdGhpcy5fbWF4QXV0b0xldmVsID0gbWF4QXV0b0xldmVsO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTUFYX0FVVE9fTEVWRUxfVVBEQVRFRCwge1xuICAgICAgICBhdXRvTGV2ZWxDYXBwaW5nLFxuICAgICAgICBsZXZlbHM6IHRoaXMubGV2ZWxzLFxuICAgICAgICBtYXhBdXRvTGV2ZWwsXG4gICAgICAgIG1pbkF1dG9MZXZlbDogdGhpcy5obHMubWluQXV0b0xldmVsLFxuICAgICAgICBtYXhIZGNwTGV2ZWxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYXNzaWduVHJhY2tJZHNCeUdyb3VwKHRyYWNrcykge1xuICBjb25zdCBncm91cHMgPSB7fTtcbiAgdHJhY2tzLmZvckVhY2godHJhY2sgPT4ge1xuICAgIGNvbnN0IGdyb3VwSWQgPSB0cmFjay5ncm91cElkIHx8ICcnO1xuICAgIHRyYWNrLmlkID0gZ3JvdXBzW2dyb3VwSWRdID0gZ3JvdXBzW2dyb3VwSWRdIHx8IDA7XG4gICAgZ3JvdXBzW2dyb3VwSWRdKys7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VCdWZmZXIoKSB7XG4gIHJldHVybiBzZWxmLlNvdXJjZUJ1ZmZlciB8fCBzZWxmLldlYktpdFNvdXJjZUJ1ZmZlcjtcbn1cbmZ1bmN0aW9uIGlzTVNFU3VwcG9ydGVkKCkge1xuICBjb25zdCBtZWRpYVNvdXJjZSA9IGdldE1lZGlhU291cmNlKCk7XG4gIGlmICghbWVkaWFTb3VyY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBpZiBTb3VyY2VCdWZmZXIgaXMgZXhwb3NlZCBlbnN1cmUgaXRzIEFQSSBpcyB2YWxpZFxuICAvLyBPbGRlciBicm93c2VycyBkbyBub3QgZXhwb3NlIFNvdXJjZUJ1ZmZlciBnbG9iYWxseSBzbyBjaGVja2luZyBTb3VyY2VCdWZmZXIucHJvdG90eXBlIGlzIGltcG9zc2libGVcbiAgY29uc3Qgc291cmNlQnVmZmVyID0gZ2V0U291cmNlQnVmZmVyKCk7XG4gIHJldHVybiAhc291cmNlQnVmZmVyIHx8IHNvdXJjZUJ1ZmZlci5wcm90b3R5cGUgJiYgdHlwZW9mIHNvdXJjZUJ1ZmZlci5wcm90b3R5cGUuYXBwZW5kQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBzb3VyY2VCdWZmZXIucHJvdG90eXBlLnJlbW92ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIGlzU3VwcG9ydGVkKCkge1xuICBpZiAoIWlzTVNFU3VwcG9ydGVkKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgbWVkaWFTb3VyY2UgPSBnZXRNZWRpYVNvdXJjZSgpO1xuICByZXR1cm4gdHlwZW9mIChtZWRpYVNvdXJjZSA9PSBudWxsID8gdm9pZCAwIDogbWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKSA9PT0gJ2Z1bmN0aW9uJyAmJiAoWydhdmMxLjQyRTAxRSxtcDRhLjQwLjInLCAnYXYwMS4wLjAxTS4wOCcsICd2cDA5LjAwLjUwLjA4J10uc29tZShjb2RlY3NGb3JWaWRlb0NvbnRhaW5lciA9PiBtZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQobWltZVR5cGVGb3JDb2RlYyhjb2RlY3NGb3JWaWRlb0NvbnRhaW5lciwgJ3ZpZGVvJykpKSB8fCBbJ21wNGEuNDAuMicsICdmTGFDJ10uc29tZShjb2RlY0ZvckF1ZGlvQ29udGFpbmVyID0+IG1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZChtaW1lVHlwZUZvckNvZGVjKGNvZGVjRm9yQXVkaW9Db250YWluZXIsICdhdWRpbycpKSkpO1xufVxuZnVuY3Rpb24gY2hhbmdlVHlwZVN1cHBvcnRlZCgpIHtcbiAgdmFyIF9zb3VyY2VCdWZmZXIkcHJvdG90eTtcbiAgY29uc3Qgc291cmNlQnVmZmVyID0gZ2V0U291cmNlQnVmZmVyKCk7XG4gIHJldHVybiB0eXBlb2YgKHNvdXJjZUJ1ZmZlciA9PSBudWxsID8gdm9pZCAwIDogKF9zb3VyY2VCdWZmZXIkcHJvdG90eSA9IHNvdXJjZUJ1ZmZlci5wcm90b3R5cGUpID09IG51bGwgPyB2b2lkIDAgOiBfc291cmNlQnVmZmVyJHByb3RvdHkuY2hhbmdlVHlwZSkgPT09ICdmdW5jdGlvbic7XG59XG5cbmNvbnN0IFRJQ0tfSU5URVJWQUwgPSAxMDA7IC8vIGhvdyBvZnRlbiB0byB0aWNrIGluIG1zXG5cbmNsYXNzIFN0cmVhbUNvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlU3RyZWFtQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGhscywgZnJhZ21lbnRUcmFja2VyLCBrZXlMb2FkZXIpIHtcbiAgICBzdXBlcihobHMsIGZyYWdtZW50VHJhY2tlciwga2V5TG9hZGVyLCAnc3RyZWFtLWNvbnRyb2xsZXInLCBQbGF5bGlzdExldmVsVHlwZS5NQUlOKTtcbiAgICB0aGlzLmF1ZGlvQ29kZWNTd2FwID0gZmFsc2U7XG4gICAgdGhpcy5sZXZlbCA9IC0xO1xuICAgIHRoaXMuX2ZvcmNlU3RhcnRMb2FkID0gZmFsc2U7XG4gICAgdGhpcy5faGFzRW5vdWdoVG9TdGFydCA9IGZhbHNlO1xuICAgIHRoaXMuYWx0QXVkaW8gPSAwO1xuICAgIHRoaXMuYXVkaW9Pbmx5ID0gZmFsc2U7XG4gICAgdGhpcy5mcmFnUGxheWluZyA9IG51bGw7XG4gICAgdGhpcy5mcmFnTGFzdEticHMgPSAwO1xuICAgIHRoaXMuY291bGRCYWNrdHJhY2sgPSBmYWxzZTtcbiAgICB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ID0gbnVsbDtcbiAgICB0aGlzLmF1ZGlvQ29kZWNTd2l0Y2ggPSBmYWxzZTtcbiAgICB0aGlzLnZpZGVvQnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLm9uTWVkaWFQbGF5aW5nID0gKCkgPT4ge1xuICAgICAgLy8gdGljayB0byBzcGVlZCB1cCBGUkFHX0NIQU5HRUQgdHJpZ2dlcmluZ1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfTtcbiAgICB0aGlzLm9uTWVkaWFTZWVrZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICBjb25zdCBjdXJyZW50VGltZSA9IG1lZGlhID8gbWVkaWEuY3VycmVudFRpbWUgOiBudWxsO1xuICAgICAgaWYgKGN1cnJlbnRUaW1lID09PSBudWxsIHx8ICFpc0Zpbml0ZU51bWJlcihjdXJyZW50VGltZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2coYE1lZGlhIHNlZWtlZCB0byAke2N1cnJlbnRUaW1lLnRvRml4ZWQoMyl9YCk7XG5cbiAgICAgIC8vIElmIHNlZWtlZCB3YXMgaXNzdWVkIGJlZm9yZSBidWZmZXIgd2FzIGFwcGVuZGVkIGRvIG5vdCB0aWNrIGltbWVkaWF0ZWx5XG4gICAgICBpZiAoIXRoaXMuZ2V0QnVmZmVyZWRGcmFnKGN1cnJlbnRUaW1lKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBidWZmZXJJbmZvID0gdGhpcy5nZXRGd2RCdWZmZXJJbmZvQXRQb3MobWVkaWEsIGN1cnJlbnRUaW1lLCBQbGF5bGlzdExldmVsVHlwZS5NQUlOLCAwKTtcbiAgICAgIGlmIChidWZmZXJJbmZvID09PSBudWxsIHx8IGJ1ZmZlckluZm8ubGVuID09PSAwKSB7XG4gICAgICAgIHRoaXMud2FybihgTWFpbiBmb3J3YXJkIGJ1ZmZlciBsZW5ndGggYXQgJHtjdXJyZW50VGltZX0gb24gXCJzZWVrZWRcIiBldmVudCAke2J1ZmZlckluZm8gPyBidWZmZXJJbmZvLmxlbiA6ICdlbXB0eSd9KWApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHRpY2sgdG8gc3BlZWQgdXAgRlJBR19DSEFOR0VEIHRyaWdnZXJpbmdcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH07XG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHN1cGVyLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRCwgdGhpcy5vbkZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hJTkcsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSEVELCB0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9DUkVBVEVELCB0aGlzLm9uQnVmZmVyQ3JlYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfRkxVU0hFRCwgdGhpcy5vbkJ1ZmZlckZsdXNoZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxTX1VQREFURUQsIHRoaXMub25MZXZlbHNVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICB9XG4gIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgc3VwZXIudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19MT0FEX0VNRVJHRU5DWV9BQk9SVEVELCB0aGlzLm9uRnJhZ0xvYWRFbWVyZ2VuY3lBYm9ydGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hJTkcsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hFRCwgdGhpcy5vbkF1ZGlvVHJhY2tTd2l0Y2hlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0NSRUFURUQsIHRoaXMub25CdWZmZXJDcmVhdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfRkxVU0hFRCwgdGhpcy5vbkJ1ZmZlckZsdXNoZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMU19VUERBVEVELCB0aGlzLm9uTGV2ZWxzVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gIH1cbiAgb25IYW5kbGVyRGVzdHJveWluZygpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5vbk1lZGlhUGxheWluZyA9IHRoaXMub25NZWRpYVNlZWtlZCA9IG51bGw7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgc3VwZXIub25IYW5kbGVyRGVzdHJveWluZygpO1xuICB9XG4gIHN0YXJ0TG9hZChzdGFydFBvc2l0aW9uLCBza2lwU2Vla1RvU3RhcnRQb3NpdGlvbikge1xuICAgIGlmICh0aGlzLmxldmVscykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBsYXN0Q3VycmVudFRpbWUsXG4gICAgICAgIGhsc1xuICAgICAgfSA9IHRoaXM7XG4gICAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgICB0aGlzLnNldEludGVydmFsKFRJQ0tfSU5URVJWQUwpO1xuICAgICAgdGhpcy5sZXZlbCA9IC0xO1xuICAgICAgaWYgKCF0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCkge1xuICAgICAgICAvLyBkZXRlcm1pbmUgbG9hZCBsZXZlbFxuICAgICAgICBsZXQgc3RhcnRMZXZlbCA9IGhscy5zdGFydExldmVsO1xuICAgICAgICBpZiAoc3RhcnRMZXZlbCA9PT0gLTEpIHtcbiAgICAgICAgICBpZiAoaGxzLmNvbmZpZy50ZXN0QmFuZHdpZHRoICYmIHRoaXMubGV2ZWxzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIC8vIC0xIDogZ3Vlc3Mgc3RhcnQgTGV2ZWwgYnkgZG9pbmcgYSBiaXRyYXRlIHRlc3QgYnkgbG9hZGluZyBmaXJzdCBmcmFnbWVudCBvZiBsb3dlc3QgcXVhbGl0eSBsZXZlbFxuICAgICAgICAgICAgc3RhcnRMZXZlbCA9IDA7XG4gICAgICAgICAgICB0aGlzLmJpdHJhdGVUZXN0ID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRMZXZlbCA9IGhscy5maXJzdEF1dG9MZXZlbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IG5ldyBsZXZlbCB0byBwbGF5bGlzdCBsb2FkZXIgOiB0aGlzIHdpbGwgdHJpZ2dlciBzdGFydCBsZXZlbCBsb2FkXG4gICAgICAgIC8vIGhscy5uZXh0TG9hZExldmVsIHJlbWFpbnMgdW50aWwgaXQgaXMgc2V0IHRvIGEgbmV3IHZhbHVlIG9yIHVudGlsIGEgbmV3IGZyYWcgaXMgc3VjY2Vzc2Z1bGx5IGxvYWRlZFxuICAgICAgICBobHMubmV4dExvYWRMZXZlbCA9IHN0YXJ0TGV2ZWw7XG4gICAgICAgIHRoaXMubGV2ZWwgPSBobHMubG9hZExldmVsO1xuICAgICAgICB0aGlzLl9oYXNFbm91Z2hUb1N0YXJ0ID0gISFza2lwU2Vla1RvU3RhcnRQb3NpdGlvbjtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHN0YXJ0UG9zaXRpb24gdW5kZWZpbmVkIGJ1dCBsYXN0Q3VycmVudFRpbWUgc2V0LCBzZXQgc3RhcnRQb3NpdGlvbiB0byBsYXN0IGN1cnJlbnRUaW1lXG4gICAgICBpZiAobGFzdEN1cnJlbnRUaW1lID4gMCAmJiBzdGFydFBvc2l0aW9uID09PSAtMSAmJiAhc2tpcFNlZWtUb1N0YXJ0UG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5sb2coYE92ZXJyaWRlIHN0YXJ0UG9zaXRpb24gd2l0aCBsYXN0Q3VycmVudFRpbWUgQCR7bGFzdEN1cnJlbnRUaW1lLnRvRml4ZWQoMyl9YCk7XG4gICAgICAgIHN0YXJ0UG9zaXRpb24gPSBsYXN0Q3VycmVudFRpbWU7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gc3RhcnRQb3NpdGlvbiArIHRoaXMudGltZWxpbmVPZmZzZXQ7XG4gICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBza2lwU2Vla1RvU3RhcnRQb3NpdGlvbiA/IC0xIDogc3RhcnRQb3NpdGlvbjtcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9mb3JjZVN0YXJ0TG9hZCA9IHRydWU7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgICB9XG4gIH1cbiAgc3RvcExvYWQoKSB7XG4gICAgdGhpcy5fZm9yY2VTdGFydExvYWQgPSBmYWxzZTtcbiAgICBzdXBlci5zdG9wTG9hZCgpO1xuICB9XG4gIGRvVGljaygpIHtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgU3RhdGUuV0FJVElOR19MRVZFTDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGxldmVscyxcbiAgICAgICAgICAgIGxldmVsXG4gICAgICAgICAgfSA9IHRoaXM7XG4gICAgICAgICAgY29uc3QgY3VycmVudExldmVsID0gbGV2ZWxzID09IG51bGwgPyB2b2lkIDAgOiBsZXZlbHNbbGV2ZWxdO1xuICAgICAgICAgIGNvbnN0IGRldGFpbHMgPSBjdXJyZW50TGV2ZWwgPT0gbnVsbCA/IHZvaWQgMCA6IGN1cnJlbnRMZXZlbC5kZXRhaWxzO1xuICAgICAgICAgIGlmIChkZXRhaWxzICYmICghZGV0YWlscy5saXZlIHx8IHRoaXMubGV2ZWxMYXN0TG9hZGVkID09PSBjdXJyZW50TGV2ZWwgJiYgIXRoaXMud2FpdEZvckxpdmUoY3VycmVudExldmVsKSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLndhaXRGb3JDZG5UdW5lSW4oZGV0YWlscykpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5obHMubmV4dExvYWRMZXZlbCAhPT0gdGhpcy5sZXZlbCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX3RoaXMkbWVkaWE7XG4gICAgICAgICAgY29uc3Qgbm93ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICBjb25zdCByZXRyeURhdGUgPSB0aGlzLnJldHJ5RGF0ZTtcbiAgICAgICAgICAvLyBpZiBjdXJyZW50IHRpbWUgaXMgZ3QgdGhhbiByZXRyeURhdGUsIG9yIGlmIG1lZGlhIHNlZWtpbmcgbGV0J3Mgc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gcmV0cnkgbG9hZGluZ1xuICAgICAgICAgIGlmICghcmV0cnlEYXRlIHx8IG5vdyA+PSByZXRyeURhdGUgfHwgKF90aGlzJG1lZGlhID0gdGhpcy5tZWRpYSkgIT0gbnVsbCAmJiBfdGhpcyRtZWRpYS5zZWVraW5nKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGxldmVscyxcbiAgICAgICAgICAgICAgbGV2ZWxcbiAgICAgICAgICAgIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudExldmVsID0gbGV2ZWxzID09IG51bGwgPyB2b2lkIDAgOiBsZXZlbHNbbGV2ZWxdO1xuICAgICAgICAgICAgdGhpcy5yZXNldFN0YXJ0V2hlbk5vdExvYWRlZChjdXJyZW50TGV2ZWwgfHwgbnVsbCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5JRExFKSB7XG4gICAgICB0aGlzLmRvVGlja0lkbGUoKTtcbiAgICB9XG4gICAgdGhpcy5vblRpY2tFbmQoKTtcbiAgfVxuICBvblRpY2tFbmQoKSB7XG4gICAgdmFyIF90aGlzJG1lZGlhMjtcbiAgICBzdXBlci5vblRpY2tFbmQoKTtcbiAgICBpZiAoKF90aGlzJG1lZGlhMiA9IHRoaXMubWVkaWEpICE9IG51bGwgJiYgX3RoaXMkbWVkaWEyLnJlYWR5U3RhdGUgJiYgdGhpcy5tZWRpYS5zZWVraW5nID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIH1cbiAgICB0aGlzLmNoZWNrRnJhZ21lbnRDaGFuZ2VkKCk7XG4gIH1cbiAgZG9UaWNrSWRsZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHMsXG4gICAgICBsZXZlbExhc3RMb2FkZWQsXG4gICAgICBsZXZlbHMsXG4gICAgICBtZWRpYVxuICAgIH0gPSB0aGlzO1xuXG4gICAgLy8gaWYgc3RhcnQgbGV2ZWwgbm90IHBhcnNlZCB5ZXQgT1JcbiAgICAvLyBpZiB2aWRlbyBub3QgYXR0YWNoZWQgQU5EIHN0YXJ0IGZyYWdtZW50IGFscmVhZHkgcmVxdWVzdGVkIE9SIHN0YXJ0IGZyYWcgcHJlZmV0Y2ggbm90IGVuYWJsZWRcbiAgICAvLyBleGl0IGxvb3AsIGFzIHdlIGVpdGhlciBuZWVkIG1vcmUgaW5mbyAobGV2ZWwgbm90IHBhcnNlZCkgb3Igd2UgbmVlZCBtZWRpYSB0byBiZSBhdHRhY2hlZCB0byBsb2FkIG5ldyBmcmFnbWVudFxuICAgIGlmIChsZXZlbExhc3RMb2FkZWQgPT09IG51bGwgfHwgIW1lZGlhICYmICF0aGlzLnByaW1hcnlQcmVmZXRjaCAmJiAodGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgfHwgIWhscy5jb25maWcuc3RhcnRGcmFnUHJlZmV0Y2gpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIFwibWFpblwiIGxldmVsIGlzIGF1ZGlvLW9ubHkgYnV0IHdlIGFyZSBsb2FkaW5nIGFuIGFsdGVybmF0ZSB0cmFjayBpbiB0aGUgc2FtZSBncm91cCwgZG8gbm90IGxvYWQgYW55dGhpbmdcbiAgICBpZiAodGhpcy5hbHRBdWRpbyAmJiB0aGlzLmF1ZGlvT25seSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsZXZlbCA9IHRoaXMuYnVmZmVyaW5nID8gaGxzLm5leHRMb2FkTGV2ZWwgOiBobHMubG9hZExldmVsO1xuICAgIGlmICghKGxldmVscyAhPSBudWxsICYmIGxldmVsc1tsZXZlbF0pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxldmVsSW5mbyA9IGxldmVsc1tsZXZlbF07XG5cbiAgICAvLyBpZiBidWZmZXIgbGVuZ3RoIGlzIGxlc3MgdGhhbiBtYXhCdWZMZW4gdHJ5IHRvIGxvYWQgYSBuZXcgZnJhZ21lbnRcblxuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSB0aGlzLmdldE1haW5Gd2RCdWZmZXJJbmZvKCk7XG4gICAgaWYgKGJ1ZmZlckluZm8gPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGFzdERldGFpbHMgPSB0aGlzLmdldExldmVsRGV0YWlscygpO1xuICAgIGlmIChsYXN0RGV0YWlscyAmJiB0aGlzLl9zdHJlYW1FbmRlZChidWZmZXJJbmZvLCBsYXN0RGV0YWlscykpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSB7fTtcbiAgICAgIGlmICh0aGlzLmFsdEF1ZGlvID09PSAyKSB7XG4gICAgICAgIGRhdGEudHlwZSA9ICd2aWRlbyc7XG4gICAgICB9XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfRU9TLCBkYXRhKTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5FTkRFRDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmJ1ZmZlcmluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHNldCBuZXh0IGxvYWQgbGV2ZWwgOiB0aGlzIHdpbGwgdHJpZ2dlciBhIHBsYXlsaXN0IGxvYWQgaWYgbmVlZGVkXG4gICAgaWYgKGhscy5sb2FkTGV2ZWwgIT09IGxldmVsICYmIGhscy5tYW51YWxMZXZlbCA9PT0gLTEpIHtcbiAgICAgIHRoaXMubG9nKGBBZGFwdGluZyB0byBsZXZlbCAke2xldmVsfSBmcm9tIGxldmVsICR7dGhpcy5sZXZlbH1gKTtcbiAgICB9XG4gICAgdGhpcy5sZXZlbCA9IGhscy5uZXh0TG9hZExldmVsID0gbGV2ZWw7XG4gICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gbGV2ZWxJbmZvLmRldGFpbHM7XG4gICAgLy8gaWYgbGV2ZWwgaW5mbyBub3QgcmV0cmlldmVkIHlldCwgc3dpdGNoIHN0YXRlIGFuZCB3YWl0IGZvciBsZXZlbCByZXRyaWV2YWxcbiAgICAvLyBpZiBsaXZlIHBsYXlsaXN0LCBlbnN1cmUgdGhhdCBuZXcgcGxheWxpc3QgaGFzIGJlZW4gcmVmcmVzaGVkIHRvIGF2b2lkIGxvYWRpbmcvdHJ5IHRvIGxvYWRcbiAgICAvLyBhIHVzZWxlc3MgYW5kIG91dGRhdGVkIGZyYWdtZW50ICh0aGF0IG1pZ2h0IGV2ZW4gaW50cm9kdWNlIGxvYWQgZXJyb3IgaWYgaXQgaXMgYWxyZWFkeSBvdXQgb2YgdGhlIGxpdmUgcGxheWxpc3QpXG4gICAgaWYgKCFsZXZlbERldGFpbHMgfHwgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19MRVZFTCB8fCB0aGlzLndhaXRGb3JMaXZlKGxldmVsSW5mbykpIHtcbiAgICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5XQUlUSU5HX0xFVkVMO1xuICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYnVmZmVyTGVuID0gYnVmZmVySW5mby5sZW47XG5cbiAgICAvLyBjb21wdXRlIG1heCBCdWZmZXIgTGVuZ3RoIHRoYXQgd2UgY291bGQgZ2V0IGZyb20gdGhpcyBsb2FkIGxldmVsLCBiYXNlZCBvbiBsZXZlbCBiaXRyYXRlLiBkb24ndCBidWZmZXIgbW9yZSB0aGFuIDYwIE1CIGFuZCBtb3JlIHRoYW4gMzBzXG4gICAgY29uc3QgbWF4QnVmTGVuID0gdGhpcy5nZXRNYXhCdWZmZXJMZW5ndGgobGV2ZWxJbmZvLm1heEJpdHJhdGUpO1xuXG4gICAgLy8gU3RheSBpZGxlIGlmIHdlIGFyZSBzdGlsbCB3aXRoIGJ1ZmZlciBtYXJnaW5zXG4gICAgaWYgKGJ1ZmZlckxlbiA+PSBtYXhCdWZMZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgJiYgdGhpcy5iYWNrdHJhY2tGcmFnbWVudC5zdGFydCA+IGJ1ZmZlckluZm8uZW5kKSB7XG4gICAgICB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0QnVmZmVyVGltZSA9IHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgPyB0aGlzLmJhY2t0cmFja0ZyYWdtZW50LnN0YXJ0IDogYnVmZmVySW5mby5lbmQ7XG4gICAgbGV0IGZyYWcgPSB0aGlzLmdldE5leHRGcmFnbWVudCh0YXJnZXRCdWZmZXJUaW1lLCBsZXZlbERldGFpbHMpO1xuICAgIC8vIEF2b2lkIGJhY2t0cmFja2luZyBieSBsb2FkaW5nIGFuIGVhcmxpZXIgc2VnbWVudCBpbiBzdHJlYW1zIHdpdGggc2VnbWVudHMgdGhhdCBkbyBub3Qgc3RhcnQgd2l0aCBhIGtleSBmcmFtZSAoZmxhZ2dlZCBieSBgY291bGRCYWNrdHJhY2tgKVxuICAgIGlmICh0aGlzLmNvdWxkQmFja3RyYWNrICYmICF0aGlzLmZyYWdQcmV2aW91cyAmJiBmcmFnICYmIGlzTWVkaWFGcmFnbWVudChmcmFnKSAmJiB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmcmFnKSAhPT0gRnJhZ21lbnRTdGF0ZS5PSykge1xuICAgICAgdmFyIF90aGlzJGJhY2t0cmFja0ZyYWdtZTtcbiAgICAgIGNvbnN0IGJhY2t0cmFja1NuID0gKChfdGhpcyRiYWNrdHJhY2tGcmFnbWUgPSB0aGlzLmJhY2t0cmFja0ZyYWdtZW50KSAhPSBudWxsID8gX3RoaXMkYmFja3RyYWNrRnJhZ21lIDogZnJhZykuc247XG4gICAgICBjb25zdCBmcmFnSWR4ID0gYmFja3RyYWNrU24gLSBsZXZlbERldGFpbHMuc3RhcnRTTjtcbiAgICAgIGNvbnN0IGJhY2t0cmFja0ZyYWcgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRzW2ZyYWdJZHggLSAxXTtcbiAgICAgIGlmIChiYWNrdHJhY2tGcmFnICYmIGZyYWcuY2MgPT09IGJhY2t0cmFja0ZyYWcuY2MpIHtcbiAgICAgICAgZnJhZyA9IGJhY2t0cmFja0ZyYWc7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGJhY2t0cmFja0ZyYWcpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5iYWNrdHJhY2tGcmFnbWVudCAmJiBidWZmZXJJbmZvLmxlbikge1xuICAgICAgdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IG51bGw7XG4gICAgfVxuICAgIC8vIEF2b2lkIGxvb3AgbG9hZGluZyBieSB1c2luZyBuZXh0TG9hZFBvc2l0aW9uIHNldCBmb3IgYmFja3RyYWNraW5nIGFuZCBza2lwcGluZyBjb25zZWN1dGl2ZSBHQVAgdGFnc1xuICAgIGlmIChmcmFnICYmIHRoaXMuaXNMb29wTG9hZGluZyhmcmFnLCB0YXJnZXRCdWZmZXJUaW1lKSkge1xuICAgICAgY29uc3QgZ2FwU3RhcnQgPSBmcmFnLmdhcDtcbiAgICAgIGlmICghZ2FwU3RhcnQpIHtcbiAgICAgICAgLy8gQ2xlYW51cCB0aGUgZnJhZ21lbnQgdHJhY2tlciBiZWZvcmUgdHJ5aW5nIHRvIGZpbmQgdGhlIG5leHQgdW5idWZmZXJlZCBmcmFnbWVudFxuICAgICAgICBjb25zdCB0eXBlID0gdGhpcy5hdWRpb09ubHkgJiYgIXRoaXMuYWx0QXVkaW8gPyBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU8gOiBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU87XG4gICAgICAgIGNvbnN0IG1lZGlhQnVmZmVyID0gKHR5cGUgPT09IEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFTyA/IHRoaXMudmlkZW9CdWZmZXIgOiB0aGlzLm1lZGlhQnVmZmVyKSB8fCB0aGlzLm1lZGlhO1xuICAgICAgICBpZiAobWVkaWFCdWZmZXIpIHtcbiAgICAgICAgICB0aGlzLmFmdGVyQnVmZmVyRmx1c2hlZChtZWRpYUJ1ZmZlciwgdHlwZSwgUGxheWxpc3RMZXZlbFR5cGUuTUFJTik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZyYWcgPSB0aGlzLmdldE5leHRGcmFnbWVudExvb3BMb2FkaW5nKGZyYWcsIGxldmVsRGV0YWlscywgYnVmZmVySW5mbywgUGxheWxpc3RMZXZlbFR5cGUuTUFJTiwgbWF4QnVmTGVuKTtcbiAgICB9XG4gICAgaWYgKCFmcmFnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChmcmFnLmluaXRTZWdtZW50ICYmICFmcmFnLmluaXRTZWdtZW50LmRhdGEgJiYgIXRoaXMuYml0cmF0ZVRlc3QpIHtcbiAgICAgIGZyYWcgPSBmcmFnLmluaXRTZWdtZW50O1xuICAgIH1cbiAgICB0aGlzLmxvYWRGcmFnbWVudChmcmFnLCBsZXZlbEluZm8sIHRhcmdldEJ1ZmZlclRpbWUpO1xuICB9XG4gIGxvYWRGcmFnbWVudChmcmFnLCBsZXZlbCwgdGFyZ2V0QnVmZmVyVGltZSkge1xuICAgIC8vIENoZWNrIGlmIGZyYWdtZW50IGlzIG5vdCBsb2FkZWRcbiAgICBjb25zdCBmcmFnU3RhdGUgPSB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmcmFnKTtcbiAgICBpZiAoZnJhZ1N0YXRlID09PSBGcmFnbWVudFN0YXRlLk5PVF9MT0FERUQgfHwgZnJhZ1N0YXRlID09PSBGcmFnbWVudFN0YXRlLlBBUlRJQUwpIHtcbiAgICAgIGlmICghaXNNZWRpYUZyYWdtZW50KGZyYWcpKSB7XG4gICAgICAgIHRoaXMuX2xvYWRJbml0U2VnbWVudChmcmFnLCBsZXZlbCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuYml0cmF0ZVRlc3QpIHtcbiAgICAgICAgdGhpcy5sb2coYEZyYWdtZW50ICR7ZnJhZy5zbn0gb2YgbGV2ZWwgJHtmcmFnLmxldmVsfSBpcyBiZWluZyBkb3dubG9hZGVkIHRvIHRlc3QgYml0cmF0ZSBhbmQgd2lsbCBub3QgYmUgYnVmZmVyZWRgKTtcbiAgICAgICAgdGhpcy5fbG9hZEJpdHJhdGVUZXN0RnJhZyhmcmFnLCBsZXZlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdXBlci5sb2FkRnJhZ21lbnQoZnJhZywgbGV2ZWwsIHRhcmdldEJ1ZmZlclRpbWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNsZWFyVHJhY2tlcklmTmVlZGVkKGZyYWcpO1xuICAgIH1cbiAgfVxuICBnZXRCdWZmZXJlZEZyYWcocG9zaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0QnVmZmVyZWRGcmFnKHBvc2l0aW9uLCBQbGF5bGlzdExldmVsVHlwZS5NQUlOKTtcbiAgfVxuICBmb2xsb3dpbmdCdWZmZXJlZEZyYWcoZnJhZykge1xuICAgIGlmIChmcmFnKSB7XG4gICAgICAvLyB0cnkgdG8gZ2V0IHJhbmdlIG9mIG5leHQgZnJhZ21lbnQgKDUwMG1zIGFmdGVyIHRoaXMgcmFuZ2UpXG4gICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXJlZEZyYWcoZnJhZy5lbmQgKyAwLjUpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qXG4gICAgb24gaW1tZWRpYXRlIGxldmVsIHN3aXRjaCA6XG4gICAgIC0gcGF1c2UgcGxheWJhY2sgaWYgcGxheWluZ1xuICAgICAtIGNhbmNlbCBhbnkgcGVuZGluZyBsb2FkIHJlcXVlc3RcbiAgICAgLSBhbmQgdHJpZ2dlciBhIGJ1ZmZlciBmbHVzaFxuICAqL1xuICBpbW1lZGlhdGVMZXZlbFN3aXRjaCgpIHtcbiAgICB0aGlzLmFib3J0Q3VycmVudEZyYWcoKTtcbiAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcigwLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICB9XG5cbiAgLyoqXG4gICAqIHRyeSB0byBzd2l0Y2ggQVNBUCB3aXRob3V0IGJyZWFraW5nIHZpZGVvIHBsYXliYWNrOlxuICAgKiBpbiBvcmRlciB0byBlbnN1cmUgc21vb3RoIGJ1dCBxdWljayBsZXZlbCBzd2l0Y2hpbmcsXG4gICAqIHdlIG5lZWQgdG8gZmluZCB0aGUgbmV4dCBmbHVzaGFibGUgYnVmZmVyIHJhbmdlXG4gICAqIHdlIHNob3VsZCB0YWtlIGludG8gYWNjb3VudCBuZXcgc2VnbWVudCBmZXRjaCB0aW1lXG4gICAqL1xuICBuZXh0TGV2ZWxTd2l0Y2goKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWxzLFxuICAgICAgbWVkaWFcbiAgICB9ID0gdGhpcztcbiAgICAvLyBlbnN1cmUgdGhhdCBtZWRpYSBpcyBkZWZpbmVkIGFuZCB0aGF0IG1ldGFkYXRhIGFyZSBhdmFpbGFibGUgKHRvIHJldHJpZXZlIGN1cnJlbnRUaW1lKVxuICAgIGlmIChtZWRpYSAhPSBudWxsICYmIG1lZGlhLnJlYWR5U3RhdGUpIHtcbiAgICAgIGxldCBmZXRjaGRlbGF5O1xuICAgICAgY29uc3QgZnJhZ1BsYXlpbmdDdXJyZW50ID0gdGhpcy5nZXRBcHBlbmRlZEZyYWcobWVkaWEuY3VycmVudFRpbWUpO1xuICAgICAgaWYgKGZyYWdQbGF5aW5nQ3VycmVudCAmJiBmcmFnUGxheWluZ0N1cnJlbnQuc3RhcnQgPiAxKSB7XG4gICAgICAgIC8vIGZsdXNoIGJ1ZmZlciBwcmVjZWRpbmcgY3VycmVudCBmcmFnbWVudCAoZmx1c2ggdW50aWwgY3VycmVudCBmcmFnbWVudCBzdGFydCBvZmZzZXQpXG4gICAgICAgIC8vIG1pbnVzIDFzIHRvIGF2b2lkIHZpZGVvIGZyZWV6aW5nLCB0aGF0IGNvdWxkIGhhcHBlbiBpZiB3ZSBmbHVzaCBrZXlmcmFtZSBvZiBjdXJyZW50IHZpZGVvIC4uLlxuICAgICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcigwLCBmcmFnUGxheWluZ0N1cnJlbnQuc3RhcnQgLSAxKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IHRoaXMuZ2V0TGV2ZWxEZXRhaWxzKCk7XG4gICAgICBpZiAobGV2ZWxEZXRhaWxzICE9IG51bGwgJiYgbGV2ZWxEZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgY29uc3QgYnVmZmVySW5mbyA9IHRoaXMuZ2V0TWFpbkZ3ZEJ1ZmZlckluZm8oKTtcbiAgICAgICAgLy8gRG8gbm90IGZsdXNoIGluIGxpdmUgc3RyZWFtIHdpdGggbG93IGJ1ZmZlclxuICAgICAgICBpZiAoIWJ1ZmZlckluZm8gfHwgYnVmZmVySW5mby5sZW4gPCBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb24gKiAyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIW1lZGlhLnBhdXNlZCAmJiBsZXZlbHMpIHtcbiAgICAgICAgLy8gYWRkIGEgc2FmZXR5IGRlbGF5IG9mIDFzXG4gICAgICAgIGNvbnN0IG5leHRMZXZlbElkID0gdGhpcy5obHMubmV4dExvYWRMZXZlbDtcbiAgICAgICAgY29uc3QgbmV4dExldmVsID0gbGV2ZWxzW25leHRMZXZlbElkXTtcbiAgICAgICAgY29uc3QgZnJhZ0xhc3RLYnBzID0gdGhpcy5mcmFnTGFzdEticHM7XG4gICAgICAgIGlmIChmcmFnTGFzdEticHMgJiYgdGhpcy5mcmFnQ3VycmVudCkge1xuICAgICAgICAgIGZldGNoZGVsYXkgPSB0aGlzLmZyYWdDdXJyZW50LmR1cmF0aW9uICogbmV4dExldmVsLm1heEJpdHJhdGUgLyAoMTAwMCAqIGZyYWdMYXN0S2JwcykgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZldGNoZGVsYXkgPSAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmZXRjaGRlbGF5ID0gMDtcbiAgICAgIH1cbiAgICAgIC8vIHRoaXMubG9nKCdmZXRjaGRlbGF5OicrZmV0Y2hkZWxheSk7XG4gICAgICAvLyBmaW5kIGJ1ZmZlciByYW5nZSB0aGF0IHdpbGwgYmUgcmVhY2hlZCBvbmNlIG5ldyBmcmFnbWVudCB3aWxsIGJlIGZldGNoZWRcbiAgICAgIGNvbnN0IGJ1ZmZlcmVkRnJhZyA9IHRoaXMuZ2V0QnVmZmVyZWRGcmFnKG1lZGlhLmN1cnJlbnRUaW1lICsgZmV0Y2hkZWxheSk7XG4gICAgICBpZiAoYnVmZmVyZWRGcmFnKSB7XG4gICAgICAgIC8vIHdlIGNhbiBmbHVzaCBidWZmZXIgcmFuZ2UgZm9sbG93aW5nIHRoaXMgb25lIHdpdGhvdXQgc3RhbGxpbmcgcGxheWJhY2tcbiAgICAgICAgY29uc3QgbmV4dEJ1ZmZlcmVkRnJhZyA9IHRoaXMuZm9sbG93aW5nQnVmZmVyZWRGcmFnKGJ1ZmZlcmVkRnJhZyk7XG4gICAgICAgIGlmIChuZXh0QnVmZmVyZWRGcmFnKSB7XG4gICAgICAgICAgLy8gaWYgd2UgYXJlIGhlcmUsIHdlIGNhbiBhbHNvIGNhbmNlbCBhbnkgbG9hZGluZy9kZW11eGluZyBpbiBwcm9ncmVzcywgYXMgdGhleSBhcmUgdXNlbGVzc1xuICAgICAgICAgIHRoaXMuYWJvcnRDdXJyZW50RnJhZygpO1xuICAgICAgICAgIC8vIHN0YXJ0IGZsdXNoIHBvc2l0aW9uIGlzIGluIG5leHQgYnVmZmVyZWQgZnJhZy4gTGVhdmUgc29tZSBwYWRkaW5nIGZvciBub24taW5kZXBlbmRlbnQgc2VnbWVudHMgYW5kIHNtb290aGVyIHBsYXliYWNrLlxuICAgICAgICAgIGNvbnN0IG1heFN0YXJ0ID0gbmV4dEJ1ZmZlcmVkRnJhZy5tYXhTdGFydFBUUyA/IG5leHRCdWZmZXJlZEZyYWcubWF4U3RhcnRQVFMgOiBuZXh0QnVmZmVyZWRGcmFnLnN0YXJ0O1xuICAgICAgICAgIGNvbnN0IGZyYWdEdXJhdGlvbiA9IG5leHRCdWZmZXJlZEZyYWcuZHVyYXRpb247XG4gICAgICAgICAgY29uc3Qgc3RhcnRQdHMgPSBNYXRoLm1heChidWZmZXJlZEZyYWcuZW5kLCBtYXhTdGFydCArIE1hdGgubWluKE1hdGgubWF4KGZyYWdEdXJhdGlvbiAtIHRoaXMuY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGZyYWdEdXJhdGlvbiAqICh0aGlzLmNvdWxkQmFja3RyYWNrID8gMC41IDogMC4xMjUpKSwgZnJhZ0R1cmF0aW9uICogKHRoaXMuY291bGRCYWNrdHJhY2sgPyAwLjc1IDogMC4yNSkpKTtcbiAgICAgICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcihzdGFydFB0cywgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBhYm9ydEN1cnJlbnRGcmFnKCkge1xuICAgIGNvbnN0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ID0gbnVsbDtcbiAgICBpZiAoZnJhZ0N1cnJlbnQpIHtcbiAgICAgIGZyYWdDdXJyZW50LmFib3J0UmVxdWVzdHMoKTtcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWdDdXJyZW50KTtcbiAgICB9XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIFN0YXRlLktFWV9MT0FESU5HOlxuICAgICAgY2FzZSBTdGF0ZS5GUkFHX0xPQURJTkc6XG4gICAgICBjYXNlIFN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZOlxuICAgICAgY2FzZSBTdGF0ZS5QQVJTSU5HOlxuICAgICAgY2FzZSBTdGF0ZS5QQVJTRUQ6XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5nZXRMb2FkUG9zaXRpb24oKTtcbiAgfVxuICBmbHVzaE1haW5CdWZmZXIoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCkge1xuICAgIHN1cGVyLmZsdXNoTWFpbkJ1ZmZlcihzdGFydE9mZnNldCwgZW5kT2Zmc2V0LCB0aGlzLmFsdEF1ZGlvID09PSAyID8gJ3ZpZGVvJyA6IG51bGwpO1xuICB9XG4gIG9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSkge1xuICAgIHN1cGVyLm9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSk7XG4gICAgY29uc3QgbWVkaWEgPSBkYXRhLm1lZGlhO1xuICAgIGFkZEV2ZW50TGlzdGVuZXIobWVkaWEsICdwbGF5aW5nJywgdGhpcy5vbk1lZGlhUGxheWluZyk7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihtZWRpYSwgJ3NlZWtlZCcsIHRoaXMub25NZWRpYVNlZWtlZCk7XG4gIH1cbiAgb25NZWRpYURldGFjaGluZyhldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lZGlhXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKG1lZGlhLCAncGxheWluZycsIHRoaXMub25NZWRpYVBsYXlpbmcpO1xuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihtZWRpYSwgJ3NlZWtlZCcsIHRoaXMub25NZWRpYVNlZWtlZCk7XG4gICAgfVxuICAgIHRoaXMudmlkZW9CdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuZnJhZ1BsYXlpbmcgPSBudWxsO1xuICAgIHN1cGVyLm9uTWVkaWFEZXRhY2hpbmcoZXZlbnQsIGRhdGEpO1xuICAgIGNvbnN0IHRyYW5zZmVycmluZ01lZGlhID0gISFkYXRhLnRyYW5zZmVyTWVkaWE7XG4gICAgaWYgKHRyYW5zZmVycmluZ01lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2hhc0Vub3VnaFRvU3RhcnQgPSBmYWxzZTtcbiAgfVxuICBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICBzdXBlci5vbk1hbmlmZXN0TG9hZGluZygpO1xuICAgIC8vIHJlc2V0IGJ1ZmZlciBvbiBtYW5pZmVzdCBsb2FkaW5nXG4gICAgdGhpcy5sb2coJ1RyaWdnZXIgQlVGRkVSX1JFU0VUJyk7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX1JFU0VULCB1bmRlZmluZWQpO1xuICAgIHRoaXMuY291bGRCYWNrdHJhY2sgPSBmYWxzZTtcbiAgICB0aGlzLmZyYWdMYXN0S2JwcyA9IDA7XG4gICAgdGhpcy5mcmFnUGxheWluZyA9IHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgPSBudWxsO1xuICAgIHRoaXMuYWx0QXVkaW8gPSAwO1xuICAgIHRoaXMuYXVkaW9Pbmx5ID0gZmFsc2U7XG4gIH1cbiAgb25NYW5pZmVzdFBhcnNlZChldmVudCwgZGF0YSkge1xuICAgIC8vIGRldGVjdCBpZiB3ZSBoYXZlIGRpZmZlcmVudCBraW5kIG9mIGF1ZGlvIGNvZGVjcyB1c2VkIGFtb25nc3QgcGxheWxpc3RzXG4gICAgbGV0IGFhYyA9IGZhbHNlO1xuICAgIGxldCBoZWFhYyA9IGZhbHNlO1xuICAgIGRhdGEubGV2ZWxzLmZvckVhY2gobGV2ZWwgPT4ge1xuICAgICAgY29uc3QgY29kZWMgPSBsZXZlbC5hdWRpb0NvZGVjO1xuICAgICAgaWYgKGNvZGVjKSB7XG4gICAgICAgIGFhYyA9IGFhYyB8fCBjb2RlYy5pbmRleE9mKCdtcDRhLjQwLjInKSAhPT0gLTE7XG4gICAgICAgIGhlYWFjID0gaGVhYWMgfHwgY29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09IC0xO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuYXVkaW9Db2RlY1N3aXRjaCA9IGFhYyAmJiBoZWFhYyAmJiAhY2hhbmdlVHlwZVN1cHBvcnRlZCgpO1xuICAgIGlmICh0aGlzLmF1ZGlvQ29kZWNTd2l0Y2gpIHtcbiAgICAgIHRoaXMubG9nKCdCb3RoIEFBQy9IRS1BQUMgYXVkaW8gZm91bmQgaW4gbGV2ZWxzOyBkZWNsYXJpbmcgbGV2ZWwgY29kZWMgYXMgSEUtQUFDJyk7XG4gICAgfVxuICAgIHRoaXMubGV2ZWxzID0gZGF0YS5sZXZlbHM7XG4gICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgfVxuICBvbkxldmVsTG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxldmVsc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmICghbGV2ZWxzIHx8IHRoaXMuc3RhdGUgIT09IFN0YXRlLklETEUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGV2ZWwgPSBkYXRhLmxldmVsSW5mbztcbiAgICBpZiAoIWxldmVsLmRldGFpbHMgfHwgbGV2ZWwuZGV0YWlscy5saXZlICYmICh0aGlzLmxldmVsTGFzdExvYWRlZCAhPT0gbGV2ZWwgfHwgbGV2ZWwuZGV0YWlscy5leHBpcmVkKSB8fCB0aGlzLndhaXRGb3JDZG5UdW5lSW4obGV2ZWwuZGV0YWlscykpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5XQUlUSU5HX0xFVkVMO1xuICAgIH1cbiAgfVxuICBvbkxldmVsTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF9jdXJMZXZlbCRkZXRhaWxzO1xuICAgIGNvbnN0IHtcbiAgICAgIGxldmVscyxcbiAgICAgIHN0YXJ0RnJhZ1JlcXVlc3RlZFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IG5ld0xldmVsSWQgPSBkYXRhLmxldmVsO1xuICAgIGNvbnN0IG5ld0RldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gICAgY29uc3QgZHVyYXRpb24gPSBuZXdEZXRhaWxzLnRvdGFsZHVyYXRpb247XG4gICAgaWYgKCFsZXZlbHMpIHtcbiAgICAgIHRoaXMud2FybihgTGV2ZWxzIHdlcmUgcmVzZXQgd2hpbGUgbG9hZGluZyBsZXZlbCAke25ld0xldmVsSWR9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubG9nKGBMZXZlbCAke25ld0xldmVsSWR9IGxvYWRlZCBbJHtuZXdEZXRhaWxzLnN0YXJ0U059LCR7bmV3RGV0YWlscy5lbmRTTn1dJHtuZXdEZXRhaWxzLmxhc3RQYXJ0U24gPyBgW3BhcnQtJHtuZXdEZXRhaWxzLmxhc3RQYXJ0U259LSR7bmV3RGV0YWlscy5sYXN0UGFydEluZGV4fV1gIDogJyd9LCBjYyBbJHtuZXdEZXRhaWxzLnN0YXJ0Q0N9LCAke25ld0RldGFpbHMuZW5kQ0N9XSBkdXJhdGlvbjoke2R1cmF0aW9ufWApO1xuICAgIGNvbnN0IGN1ckxldmVsID0gZGF0YS5sZXZlbEluZm87XG4gICAgY29uc3QgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgIGlmIChmcmFnQ3VycmVudCAmJiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuRlJBR19MT0FESU5HIHx8IHRoaXMuc3RhdGUgPT09IFN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZKSkge1xuICAgICAgaWYgKGZyYWdDdXJyZW50LmxldmVsICE9PSBkYXRhLmxldmVsICYmIGZyYWdDdXJyZW50LmxvYWRlcikge1xuICAgICAgICB0aGlzLmFib3J0Q3VycmVudEZyYWcoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHNsaWRpbmcgPSAwO1xuICAgIGlmIChuZXdEZXRhaWxzLmxpdmUgfHwgKF9jdXJMZXZlbCRkZXRhaWxzID0gY3VyTGV2ZWwuZGV0YWlscykgIT0gbnVsbCAmJiBfY3VyTGV2ZWwkZGV0YWlscy5saXZlKSB7XG4gICAgICB2YXIgX3RoaXMkbGV2ZWxMYXN0TG9hZGVkO1xuICAgICAgdGhpcy5jaGVja0xpdmVVcGRhdGUobmV3RGV0YWlscyk7XG4gICAgICBpZiAobmV3RGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzbGlkaW5nID0gdGhpcy5hbGlnblBsYXlsaXN0cyhuZXdEZXRhaWxzLCBjdXJMZXZlbC5kZXRhaWxzLCAoX3RoaXMkbGV2ZWxMYXN0TG9hZGVkID0gdGhpcy5sZXZlbExhc3RMb2FkZWQpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRsZXZlbExhc3RMb2FkZWQuZGV0YWlscyk7XG4gICAgfVxuICAgIC8vIG92ZXJyaWRlIGxldmVsIGluZm9cbiAgICBjdXJMZXZlbC5kZXRhaWxzID0gbmV3RGV0YWlscztcbiAgICB0aGlzLmxldmVsTGFzdExvYWRlZCA9IGN1ckxldmVsO1xuICAgIGlmICghc3RhcnRGcmFnUmVxdWVzdGVkKSB7XG4gICAgICB0aGlzLnNldFN0YXJ0UG9zaXRpb24obmV3RGV0YWlscywgc2xpZGluZyk7XG4gICAgfVxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkxFVkVMX1VQREFURUQsIHtcbiAgICAgIGRldGFpbHM6IG5ld0RldGFpbHMsXG4gICAgICBsZXZlbDogbmV3TGV2ZWxJZFxuICAgIH0pO1xuXG4gICAgLy8gb25seSBzd2l0Y2ggYmFjayB0byBJRExFIHN0YXRlIGlmIHdlIHdlcmUgd2FpdGluZyBmb3IgbGV2ZWwgdG8gc3RhcnQgZG93bmxvYWRpbmcgYSBuZXcgZnJhZ21lbnRcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19MRVZFTCkge1xuICAgICAgaWYgKHRoaXMud2FpdEZvckNkblR1bmVJbihuZXdEZXRhaWxzKSkge1xuICAgICAgICAvLyBXYWl0IGZvciBMb3ctTGF0ZW5jeSBDRE4gVHVuZS1pblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICB9XG4gICAgaWYgKHN0YXJ0RnJhZ1JlcXVlc3RlZCAmJiBuZXdEZXRhaWxzLmxpdmUpIHtcbiAgICAgIHRoaXMuc3luY2hyb25pemVUb0xpdmVFZGdlKG5ld0RldGFpbHMpO1xuICAgIH1cblxuICAgIC8vIHRyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuICBzeW5jaHJvbml6ZVRvTGl2ZUVkZ2UobGV2ZWxEZXRhaWxzKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29uZmlnLFxuICAgICAgbWVkaWFcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIW1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxpdmVTeW5jUG9zaXRpb24gPSB0aGlzLmhscy5saXZlU3luY1Bvc2l0aW9uO1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gdGhpcy5nZXRMb2FkUG9zaXRpb24oKTtcbiAgICBjb25zdCBzdGFydCA9IGxldmVsRGV0YWlscy5mcmFnbWVudFN0YXJ0O1xuICAgIGNvbnN0IGVuZCA9IGxldmVsRGV0YWlscy5lZGdlO1xuICAgIGNvbnN0IHdpdGhpblNsaWRpbmdXaW5kb3cgPSBjdXJyZW50VGltZSA+PSBzdGFydCAtIGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlICYmIGN1cnJlbnRUaW1lIDw9IGVuZDtcbiAgICAvLyBDb250aW51ZSBpZiB3ZSBjYW4gc2VlayBmb3J3YXJkIHRvIHN5bmMgcG9zaXRpb24gb3IgaWYgY3VycmVudCB0aW1lIGlzIG91dHNpZGUgb2Ygc2xpZGluZyB3aW5kb3dcbiAgICBpZiAobGl2ZVN5bmNQb3NpdGlvbiAhPT0gbnVsbCAmJiBtZWRpYS5kdXJhdGlvbiA+IGxpdmVTeW5jUG9zaXRpb24gJiYgKGN1cnJlbnRUaW1lIDwgbGl2ZVN5bmNQb3NpdGlvbiB8fCAhd2l0aGluU2xpZGluZ1dpbmRvdykpIHtcbiAgICAgIC8vIENvbnRpbnVlIGlmIGJ1ZmZlciBpcyBzdGFydmluZyBvciBpZiBjdXJyZW50IHRpbWUgaXMgYmVoaW5kIG1heCBsYXRlbmN5XG4gICAgICBjb25zdCBtYXhMYXRlbmN5ID0gY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uIDogY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCAqIGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbjtcbiAgICAgIGlmICghd2l0aGluU2xpZGluZ1dpbmRvdyAmJiBtZWRpYS5yZWFkeVN0YXRlIDwgNCB8fCBjdXJyZW50VGltZSA8IGVuZCAtIG1heExhdGVuY3kpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9oYXNFbm91Z2hUb1N0YXJ0KSB7XG4gICAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gbGl2ZVN5bmNQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IHNlZWsgaWYgcmVhZHkgYW5kIHRoZXJlIGlzIG5vdCBhIHNpZ25pZmljYW50IGZvcndhcmQgYnVmZmVyIGF2YWlsYWJsZSBmb3IgcGxheWJhY2tcbiAgICAgICAgaWYgKG1lZGlhLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICB0aGlzLndhcm4oYFBsYXliYWNrOiAke2N1cnJlbnRUaW1lLnRvRml4ZWQoMyl9IGlzIGxvY2F0ZWQgdG9vIGZhciBmcm9tIHRoZSBlbmQgb2YgbGl2ZSBzbGlkaW5nIHBsYXlsaXN0OiAke2VuZH0sIHJlc2V0IGN1cnJlbnRUaW1lIHRvIDogJHtsaXZlU3luY1Bvc2l0aW9uLnRvRml4ZWQoMyl9YCk7XG4gICAgICAgICAgaWYgKHRoaXMuY29uZmlnLmxpdmVTeW5jTW9kZSA9PT0gJ2J1ZmZlcmVkJykge1xuICAgICAgICAgICAgdmFyIF9idWZmZXJJbmZvJGJ1ZmZlcmVkO1xuICAgICAgICAgICAgY29uc3QgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKG1lZGlhLCBsaXZlU3luY1Bvc2l0aW9uLCAwKTtcbiAgICAgICAgICAgIGlmICghKGJ1ZmZlckluZm8gIT0gbnVsbCAmJiAoX2J1ZmZlckluZm8kYnVmZmVyZWQgPSBidWZmZXJJbmZvLmJ1ZmZlcmVkKSAhPSBudWxsICYmIF9idWZmZXJJbmZvJGJ1ZmZlcmVkLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSBsaXZlU3luY1Bvc2l0aW9uO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpc0xpdmVTeW5jSW5CdWZmZXIgPSBidWZmZXJJbmZvLnN0YXJ0IDw9IGN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgaWYgKGlzTGl2ZVN5bmNJbkJ1ZmZlcikge1xuICAgICAgICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IGxpdmVTeW5jUG9zaXRpb247XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgbmV4dFN0YXJ0XG4gICAgICAgICAgICB9ID0gQnVmZmVySGVscGVyLmJ1ZmZlcmVkSW5mbyhidWZmZXJJbmZvLmJ1ZmZlcmVkLCBjdXJyZW50VGltZSwgMCk7XG4gICAgICAgICAgICBpZiAobmV4dFN0YXJ0KSB7XG4gICAgICAgICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gbmV4dFN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IGxpdmVTeW5jUG9zaXRpb247XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9oYW5kbGVGcmFnbWVudExvYWRQcm9ncmVzcyhkYXRhKSB7XG4gICAgdmFyIF9mcmFnJGluaXRTZWdtZW50O1xuICAgIGNvbnN0IGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgY29uc3Qge1xuICAgICAgcGFydCxcbiAgICAgIHBheWxvYWRcbiAgICB9ID0gZGF0YTtcbiAgICBjb25zdCB7XG4gICAgICBsZXZlbHNcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWxldmVscykge1xuICAgICAgdGhpcy53YXJuKGBMZXZlbHMgd2VyZSByZXNldCB3aGlsZSBmcmFnbWVudCBsb2FkIHdhcyBpbiBwcm9ncmVzcy4gRnJhZ21lbnQgJHtmcmFnLnNufSBvZiBsZXZlbCAke2ZyYWcubGV2ZWx9IHdpbGwgbm90IGJlIGJ1ZmZlcmVkYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRMZXZlbCA9IGxldmVsc1tmcmFnLmxldmVsXTtcbiAgICBpZiAoIWN1cnJlbnRMZXZlbCkge1xuICAgICAgdGhpcy53YXJuKGBMZXZlbCAke2ZyYWcubGV2ZWx9IG5vdCBmb3VuZCBvbiBwcm9ncmVzc2ApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkZXRhaWxzID0gY3VycmVudExldmVsLmRldGFpbHM7XG4gICAgaWYgKCFkZXRhaWxzKSB7XG4gICAgICB0aGlzLndhcm4oYERyb3BwaW5nIGZyYWdtZW50ICR7ZnJhZy5zbn0gb2YgbGV2ZWwgJHtmcmFnLmxldmVsfSBhZnRlciBsZXZlbCBkZXRhaWxzIHdlcmUgcmVzZXRgKTtcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB2aWRlb0NvZGVjID0gY3VycmVudExldmVsLnZpZGVvQ29kZWM7XG5cbiAgICAvLyB0aW1lIE9mZnNldCBpcyBhY2N1cmF0ZSBpZiBsZXZlbCBQVFMgaXMga25vd24sIG9yIGlmIHBsYXlsaXN0IGlzIG5vdCBzbGlkaW5nIChub3QgbGl2ZSlcbiAgICBjb25zdCBhY2N1cmF0ZVRpbWVPZmZzZXQgPSBkZXRhaWxzLlBUU0tub3duIHx8ICFkZXRhaWxzLmxpdmU7XG4gICAgY29uc3QgaW5pdFNlZ21lbnREYXRhID0gKF9mcmFnJGluaXRTZWdtZW50ID0gZnJhZy5pbml0U2VnbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mcmFnJGluaXRTZWdtZW50LmRhdGE7XG4gICAgY29uc3QgYXVkaW9Db2RlYyA9IHRoaXMuX2dldEF1ZGlvQ29kZWMoY3VycmVudExldmVsKTtcblxuICAgIC8vIHRyYW5zbXV4IHRoZSBNUEVHLVRTIGRhdGEgdG8gSVNPLUJNRkYgc2VnbWVudHNcbiAgICAvLyB0aGlzLmxvZyhgVHJhbnNtdXhpbmcgJHtmcmFnLnNufSBvZiBbJHtkZXRhaWxzLnN0YXJ0U059ICwke2RldGFpbHMuZW5kU059XSxsZXZlbCAke2ZyYWcubGV2ZWx9LCBjYyAke2ZyYWcuY2N9YCk7XG4gICAgY29uc3QgdHJhbnNtdXhlciA9IHRoaXMudHJhbnNtdXhlciA9IHRoaXMudHJhbnNtdXhlciB8fCBuZXcgVHJhbnNtdXhlckludGVyZmFjZSh0aGlzLmhscywgUGxheWxpc3RMZXZlbFR5cGUuTUFJTiwgdGhpcy5faGFuZGxlVHJhbnNtdXhDb21wbGV0ZS5iaW5kKHRoaXMpLCB0aGlzLl9oYW5kbGVUcmFuc211eGVyRmx1c2guYmluZCh0aGlzKSk7XG4gICAgY29uc3QgcGFydEluZGV4ID0gcGFydCA/IHBhcnQuaW5kZXggOiAtMTtcbiAgICBjb25zdCBwYXJ0aWFsID0gcGFydEluZGV4ICE9PSAtMTtcbiAgICBjb25zdCBjaHVua01ldGEgPSBuZXcgQ2h1bmtNZXRhZGF0YShmcmFnLmxldmVsLCBmcmFnLnNuLCBmcmFnLnN0YXRzLmNodW5rQ291bnQsIHBheWxvYWQuYnl0ZUxlbmd0aCwgcGFydEluZGV4LCBwYXJ0aWFsKTtcbiAgICBjb25zdCBpbml0UFRTID0gdGhpcy5pbml0UFRTW2ZyYWcuY2NdO1xuICAgIHRyYW5zbXV4ZXIucHVzaChwYXlsb2FkLCBpbml0U2VnbWVudERhdGEsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGZyYWcsIHBhcnQsIGRldGFpbHMudG90YWxkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBjaHVua01ldGEsIGluaXRQVFMpO1xuICB9XG4gIG9uQXVkaW9UcmFja1N3aXRjaGluZyhldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIC8vIGlmIGFueSBVUkwgZm91bmQgb24gbmV3IGF1ZGlvIHRyYWNrLCBpdCBpcyBhbiBhbHRlcm5hdGUgYXVkaW8gdHJhY2tcbiAgICBjb25zdCBmcm9tQWx0QXVkaW8gPSB0aGlzLmFsdEF1ZGlvID09PSAyO1xuICAgIGNvbnN0IGFsdEF1ZGlvID0gdXNlQWx0ZXJuYXRlQXVkaW8oZGF0YS51cmwsIGhscyk7XG4gICAgLy8gaWYgd2Ugc3dpdGNoIG9uIG1haW4gYXVkaW8sIGVuc3VyZSB0aGF0IG1haW4gZnJhZ21lbnQgc2NoZWR1bGluZyBpcyBzeW5jZWQgd2l0aCBtZWRpYS5idWZmZXJlZFxuICAgIC8vIGRvbid0IGRvIGFueXRoaW5nIGlmIHdlIHN3aXRjaCB0byBhbHQgYXVkaW86IGF1ZGlvIHN0cmVhbSBjb250cm9sbGVyIGlzIGhhbmRsaW5nIGl0LlxuICAgIC8vIHdlIHdpbGwganVzdCBoYXZlIHRvIGNoYW5nZSBidWZmZXIgc2NoZWR1bGluZyBvbiBhdWRpb1RyYWNrU3dpdGNoZWRcbiAgICBpZiAoIWFsdEF1ZGlvKSB7XG4gICAgICBpZiAodGhpcy5tZWRpYUJ1ZmZlciAhPT0gdGhpcy5tZWRpYSkge1xuICAgICAgICB0aGlzLmxvZygnU3dpdGNoaW5nIG9uIG1haW4gYXVkaW8sIHVzZSBtZWRpYS5idWZmZXJlZCB0byBzY2hlZHVsZSBtYWluIGZyYWdtZW50IGxvYWRpbmcnKTtcbiAgICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWE7XG4gICAgICAgIGNvbnN0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICAgICAgLy8gd2UgbmVlZCB0byByZWZpbGwgYXVkaW8gYnVmZmVyIGZyb20gbWFpbjogY2FuY2VsIGFueSBmcmFnIGxvYWRpbmcgdG8gc3BlZWQgdXAgYXVkaW8gc3dpdGNoXG4gICAgICAgIGlmIChmcmFnQ3VycmVudCkge1xuICAgICAgICAgIHRoaXMubG9nKCdTd2l0Y2hpbmcgdG8gbWFpbiBhdWRpbyB0cmFjaywgY2FuY2VsIG1haW4gZnJhZ21lbnQgbG9hZCcpO1xuICAgICAgICAgIGZyYWdDdXJyZW50LmFib3J0UmVxdWVzdHMoKTtcbiAgICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnQ3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVzdHJveSB0cmFuc211eGVyIHRvIGZvcmNlIGluaXQgc2VnbWVudCBnZW5lcmF0aW9uIChmb2xsb3dpbmcgYXVkaW8gc3dpdGNoKVxuICAgICAgICB0aGlzLnJlc2V0VHJhbnNtdXhlcigpO1xuICAgICAgICAvLyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byBsb2FkIG5ldyBmcmFnbWVudFxuICAgICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuYXVkaW9Pbmx5KSB7XG4gICAgICAgIC8vIFJlc2V0IGF1ZGlvIHRyYW5zbXV4ZXIgc28gd2hlbiBzd2l0Y2hpbmcgYmFjayB0byBtYWluIGF1ZGlvIHdlJ3JlIG5vdCBzdGlsbCBhcHBlbmRpbmcgd2hlcmUgd2UgbGVmdCBvZmZcbiAgICAgICAgdGhpcy5yZXNldFRyYW5zbXV4ZXIoKTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHN3aXRjaGluZyBmcm9tIGFsdCB0byBtYWluIGF1ZGlvLCBmbHVzaCBhbGwgYXVkaW8gYW5kIHRyaWdnZXIgdHJhY2sgc3dpdGNoZWRcbiAgICAgIGlmIChmcm9tQWx0QXVkaW8pIHtcbiAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlQWxsRnJhZ21lbnRzKCk7XG4gICAgICAgIGhscy5vbmNlKEV2ZW50cy5CVUZGRVJfRkxVU0hFRCwgKCkgPT4ge1xuICAgICAgICAgIHZhciBfdGhpcyRobHM7XG4gICAgICAgICAgKF90aGlzJGhscyA9IHRoaXMuaGxzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkaGxzLnRyaWdnZXIoRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSEVELCBkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHtcbiAgICAgICAgICBzdGFydE9mZnNldDogMCxcbiAgICAgICAgICBlbmRPZmZzZXQ6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICAgICAgICB0eXBlOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENIRUQsIGRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFsdEF1ZGlvID0gMTtcbiAgICB9XG4gIH1cbiAgb25BdWRpb1RyYWNrU3dpdGNoZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCBhbHRBdWRpbyA9IHVzZUFsdGVybmF0ZUF1ZGlvKGRhdGEudXJsLCB0aGlzLmhscyk7XG4gICAgaWYgKGFsdEF1ZGlvKSB7XG4gICAgICBjb25zdCB2aWRlb0J1ZmZlciA9IHRoaXMudmlkZW9CdWZmZXI7XG4gICAgICAvLyBpZiB3ZSBzd2l0Y2hlZCBvbiBhbHRlcm5hdGUgYXVkaW8sIGVuc3VyZSB0aGF0IG1haW4gZnJhZ21lbnQgc2NoZWR1bGluZyBpcyBzeW5jZWQgd2l0aCB2aWRlbyBzb3VyY2VidWZmZXIgYnVmZmVyZWRcbiAgICAgIGlmICh2aWRlb0J1ZmZlciAmJiB0aGlzLm1lZGlhQnVmZmVyICE9PSB2aWRlb0J1ZmZlcikge1xuICAgICAgICB0aGlzLmxvZygnU3dpdGNoaW5nIG9uIGFsdGVybmF0ZSBhdWRpbywgdXNlIHZpZGVvLmJ1ZmZlcmVkIHRvIHNjaGVkdWxlIG1haW4gZnJhZ21lbnQgbG9hZGluZycpO1xuICAgICAgICB0aGlzLm1lZGlhQnVmZmVyID0gdmlkZW9CdWZmZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYWx0QXVkaW8gPSBhbHRBdWRpbyA/IDIgOiAwO1xuICAgIHRoaXMudGljaygpO1xuICB9XG4gIG9uQnVmZmVyQ3JlYXRlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHRyYWNrcyA9IGRhdGEudHJhY2tzO1xuICAgIGxldCBtZWRpYVRyYWNrO1xuICAgIGxldCBuYW1lO1xuICAgIGxldCBhbHRlcm5hdGUgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IHR5cGUgaW4gdHJhY2tzKSB7XG4gICAgICBjb25zdCB0cmFjayA9IHRyYWNrc1t0eXBlXTtcbiAgICAgIGlmICh0cmFjay5pZCA9PT0gJ21haW4nKSB7XG4gICAgICAgIG5hbWUgPSB0eXBlO1xuICAgICAgICBtZWRpYVRyYWNrID0gdHJhY2s7XG4gICAgICAgIC8vIGtlZXAgdmlkZW8gc291cmNlIGJ1ZmZlciByZWZlcmVuY2VcbiAgICAgICAgaWYgKHR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICBjb25zdCB2aWRlb1RyYWNrID0gdHJhY2tzW3R5cGVdO1xuICAgICAgICAgIGlmICh2aWRlb1RyYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnZpZGVvQnVmZmVyID0gdmlkZW9UcmFjay5idWZmZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbHRlcm5hdGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWx0ZXJuYXRlICYmIG1lZGlhVHJhY2spIHtcbiAgICAgIHRoaXMubG9nKGBBbHRlcm5hdGUgdHJhY2sgZm91bmQsIHVzZSAke25hbWV9LmJ1ZmZlcmVkIHRvIHNjaGVkdWxlIG1haW4gZnJhZ21lbnQgbG9hZGluZ2ApO1xuICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IG1lZGlhVHJhY2suYnVmZmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1lZGlhQnVmZmVyID0gdGhpcy5tZWRpYTtcbiAgICB9XG4gIH1cbiAgb25GcmFnQnVmZmVyZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnLFxuICAgICAgcGFydFxuICAgIH0gPSBkYXRhO1xuICAgIGNvbnN0IGJ1ZmZlcmVkTWFpbkZyYWdtZW50ID0gZnJhZy50eXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOO1xuICAgIGlmIChidWZmZXJlZE1haW5GcmFnbWVudCkge1xuICAgICAgaWYgKHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpKSB7XG4gICAgICAgIC8vIElmIGEgbGV2ZWwgc3dpdGNoIHdhcyByZXF1ZXN0ZWQgd2hpbGUgYSBmcmFnbWVudCB3YXMgYnVmZmVyaW5nLCBpdCB3aWxsIGVtaXQgdGhlIEZSQUdfQlVGRkVSRUQgZXZlbnQgdXBvbiBjb21wbGV0aW9uXG4gICAgICAgIC8vIEF2b2lkIHNldHRpbmcgc3RhdGUgYmFjayB0byBJRExFLCBzaW5jZSB0aGF0IHdpbGwgaW50ZXJmZXJlIHdpdGggYSBsZXZlbCBzd2l0Y2hcbiAgICAgICAgdGhpcy53YXJuKGBGcmFnbWVudCAke2ZyYWcuc259JHtwYXJ0ID8gJyBwOiAnICsgcGFydC5pbmRleCA6ICcnfSBvZiBsZXZlbCAke2ZyYWcubGV2ZWx9IGZpbmlzaGVkIGJ1ZmZlcmluZywgYnV0IHdhcyBhYm9ydGVkLiBzdGF0ZTogJHt0aGlzLnN0YXRlfWApO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0VEKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhdHMgPSBwYXJ0ID8gcGFydC5zdGF0cyA6IGZyYWcuc3RhdHM7XG4gICAgICB0aGlzLmZyYWdMYXN0S2JwcyA9IE1hdGgucm91bmQoOCAqIHN0YXRzLnRvdGFsIC8gKHN0YXRzLmJ1ZmZlcmluZy5lbmQgLSBzdGF0cy5sb2FkaW5nLmZpcnN0KSk7XG4gICAgICBpZiAoaXNNZWRpYUZyYWdtZW50KGZyYWcpKSB7XG4gICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gZnJhZztcbiAgICAgIH1cbiAgICAgIHRoaXMuZnJhZ0J1ZmZlcmVkQ29tcGxldGUoZnJhZywgcGFydCk7XG4gICAgfVxuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAoIW1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5faGFzRW5vdWdoVG9TdGFydCAmJiBCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQobWVkaWEpLmxlbmd0aCkge1xuICAgICAgdGhpcy5faGFzRW5vdWdoVG9TdGFydCA9IHRydWU7XG4gICAgICB0aGlzLnNlZWtUb1N0YXJ0UG9zKCk7XG4gICAgfVxuICAgIGlmIChidWZmZXJlZE1haW5GcmFnbWVudCkge1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfVxuICB9XG4gIGdldCBoYXNFbm91Z2hUb1N0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLl9oYXNFbm91Z2hUb1N0YXJ0O1xuICB9XG4gIG9uRXJyb3IoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgX2RhdGEkY29udGV4dDtcbiAgICBpZiAoZGF0YS5mYXRhbCkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVSUk9SO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2ggKGRhdGEuZGV0YWlscykge1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19HQVA6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0RFQ1JZUFRfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVDpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVDpcbiAgICAgICAgdGhpcy5vbkZyYWdtZW50T3JLZXlMb2FkRXJyb3IoUGxheWxpc3RMZXZlbFR5cGUuTUFJTiwgZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfVElNRU9VVDpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX1BBUlNJTkdfRVJST1I6XG4gICAgICAgIC8vIGluIGNhc2Ugb2Ygbm9uIGZhdGFsIGVycm9yIHdoaWxlIGxvYWRpbmcgbGV2ZWwsIGlmIGxldmVsIGNvbnRyb2xsZXIgaXMgbm90IHJldHJ5aW5nIHRvIGxvYWQgbGV2ZWwsIHN3aXRjaCBiYWNrIHRvIElETEVcbiAgICAgICAgaWYgKCFkYXRhLmxldmVsUmV0cnkgJiYgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19MRVZFTCAmJiAoKF9kYXRhJGNvbnRleHQgPSBkYXRhLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YSRjb250ZXh0LnR5cGUpID09PSBQbGF5bGlzdENvbnRleHRUeXBlLkxFVkVMKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfQUREX0NPREVDX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORF9FUlJPUjpcbiAgICAgICAgaWYgKGRhdGEucGFyZW50ICE9PSAnbWFpbicpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVkdWNlTGVuZ3RoQW5kRmx1c2hCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfRlVMTF9FUlJPUjpcbiAgICAgICAgaWYgKGRhdGEucGFyZW50ICE9PSAnbWFpbicpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVkdWNlTGVuZ3RoQW5kRmx1c2hCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcigwLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuSU5URVJOQUxfRVhDRVBUSU9OOlxuICAgICAgICB0aGlzLnJlY292ZXJXb3JrZXJFcnJvcihkYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIG9uRnJhZ0xvYWRFbWVyZ2VuY3lBYm9ydGVkKCkge1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIC8vIGlmIGxvYWRlZG1ldGFkYXRhIGlzIG5vdCBzZXQsIGl0IG1lYW5zIHRoYXQgd2UgYXJlIGVtZXJnZW5jeSBzd2l0Y2ggZG93biBvbiBmaXJzdCBmcmFnXG4gICAgLy8gaW4gdGhhdCBjYXNlLCByZXNldCBzdGFydEZyYWdSZXF1ZXN0ZWQgZmxhZ1xuICAgIGlmICghdGhpcy5faGFzRW5vdWdoVG9TdGFydCkge1xuICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lO1xuICAgIH1cbiAgICB0aGlzLnRpY2tJbW1lZGlhdGUoKTtcbiAgfVxuICBvbkJ1ZmZlckZsdXNoZWQoZXZlbnQsIHtcbiAgICB0eXBlXG4gIH0pIHtcbiAgICBpZiAodHlwZSAhPT0gRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPIHx8ICF0aGlzLmFsdEF1ZGlvKSB7XG4gICAgICBjb25zdCBtZWRpYUJ1ZmZlciA9ICh0eXBlID09PSBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU8gPyB0aGlzLnZpZGVvQnVmZmVyIDogdGhpcy5tZWRpYUJ1ZmZlcikgfHwgdGhpcy5tZWRpYTtcbiAgICAgIGlmIChtZWRpYUJ1ZmZlcikge1xuICAgICAgICB0aGlzLmFmdGVyQnVmZmVyRmx1c2hlZChtZWRpYUJ1ZmZlciwgdHlwZSwgUGxheWxpc3RMZXZlbFR5cGUuTUFJTik7XG4gICAgICAgIHRoaXMudGljaygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBvbkxldmVsc1VwZGF0ZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBpZiAodGhpcy5sZXZlbCA+IC0xICYmIHRoaXMuZnJhZ0N1cnJlbnQpIHtcbiAgICAgIHRoaXMubGV2ZWwgPSB0aGlzLmZyYWdDdXJyZW50LmxldmVsO1xuICAgICAgaWYgKHRoaXMubGV2ZWwgPT09IC0xKSB7XG4gICAgICAgIHRoaXMucmVzZXRXaGVuTWlzc2luZ0NvbnRleHQodGhpcy5mcmFnQ3VycmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubGV2ZWxzID0gZGF0YS5sZXZlbHM7XG4gIH1cbiAgc3dhcEF1ZGlvQ29kZWMoKSB7XG4gICAgdGhpcy5hdWRpb0NvZGVjU3dhcCA9ICF0aGlzLmF1ZGlvQ29kZWNTd2FwO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlZWtzIHRvIHRoZSBzZXQgc3RhcnRQb3NpdGlvbiBpZiBub3QgZXF1YWwgdG8gdGhlIG1lZGlhRWxlbWVudCdzIGN1cnJlbnQgdGltZS5cbiAgICovXG4gIHNlZWtUb1N0YXJ0UG9zKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lZGlhXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIGxldCBzdGFydFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uO1xuICAgIC8vIG9ubHkgYWRqdXN0IGN1cnJlbnRUaW1lIGlmIGRpZmZlcmVudCBmcm9tIHN0YXJ0UG9zaXRpb24gb3IgaWYgc3RhcnRQb3NpdGlvbiBub3QgYnVmZmVyZWRcbiAgICAvLyBhdCB0aGF0IHN0YWdlLCB0aGVyZSBzaG91bGQgYmUgb25seSBvbmUgYnVmZmVyZWQgcmFuZ2UsIGFzIHdlIHJlYWNoIHRoYXQgY29kZSBhZnRlciBmaXJzdCBmcmFnbWVudCBoYXMgYmVlbiBidWZmZXJlZFxuICAgIGlmIChzdGFydFBvc2l0aW9uID49IDAgJiYgY3VycmVudFRpbWUgPCBzdGFydFBvc2l0aW9uKSB7XG4gICAgICBpZiAobWVkaWEuc2Vla2luZykge1xuICAgICAgICB0aGlzLmxvZyhgY291bGQgbm90IHNlZWsgdG8gJHtzdGFydFBvc2l0aW9ufSwgYWxyZWFkeSBzZWVraW5nIGF0ICR7Y3VycmVudFRpbWV9YCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gT2Zmc2V0IHN0YXJ0IHBvc2l0aW9uIGJ5IHRpbWVsaW5lIG9mZnNldFxuICAgICAgY29uc3QgdGltZWxpbmVPZmZzZXQgPSB0aGlzLnRpbWVsaW5lT2Zmc2V0O1xuICAgICAgaWYgKHRpbWVsaW5lT2Zmc2V0ICYmIHN0YXJ0UG9zaXRpb24pIHtcbiAgICAgICAgc3RhcnRQb3NpdGlvbiArPSB0aW1lbGluZU9mZnNldDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRldGFpbHMgPSB0aGlzLmdldExldmVsRGV0YWlscygpO1xuICAgICAgY29uc3QgYnVmZmVyZWQgPSBCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQobWVkaWEpO1xuICAgICAgY29uc3QgYnVmZmVyU3RhcnQgPSBidWZmZXJlZC5sZW5ndGggPyBidWZmZXJlZC5zdGFydCgwKSA6IDA7XG4gICAgICBjb25zdCBkZWx0YSA9IGJ1ZmZlclN0YXJ0IC0gc3RhcnRQb3NpdGlvbjtcbiAgICAgIGNvbnN0IHNraXBUb2xlcmFuY2UgPSBNYXRoLm1heCh0aGlzLmNvbmZpZy5tYXhCdWZmZXJIb2xlLCB0aGlzLmNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlKTtcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5zdGFydE9uU2VnbWVudEJvdW5kYXJ5IHx8IGRlbHRhID4gMCAmJiAoZGVsdGEgPCBza2lwVG9sZXJhbmNlIHx8IHRoaXMubG9hZGluZ1BhcnRzICYmIGRlbHRhIDwgMiAqICgoZGV0YWlscyA9PSBudWxsID8gdm9pZCAwIDogZGV0YWlscy5wYXJ0VGFyZ2V0KSB8fCAwKSkpIHtcbiAgICAgICAgdGhpcy5sb2coYGFkanVzdGluZyBzdGFydCBwb3NpdGlvbiBieSAke2RlbHRhfSB0byBtYXRjaCBidWZmZXIgc3RhcnRgKTtcbiAgICAgICAgc3RhcnRQb3NpdGlvbiArPSBkZWx0YTtcbiAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbjtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50VGltZSA8IHN0YXJ0UG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5sb2coYHNlZWsgdG8gdGFyZ2V0IHN0YXJ0IHBvc2l0aW9uICR7c3RhcnRQb3NpdGlvbn0gZnJvbSBjdXJyZW50IHRpbWUgJHtjdXJyZW50VGltZX0gYnVmZmVyIHN0YXJ0ICR7YnVmZmVyU3RhcnR9YCk7XG4gICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gc3RhcnRQb3NpdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2dldEF1ZGlvQ29kZWMoY3VycmVudExldmVsKSB7XG4gICAgbGV0IGF1ZGlvQ29kZWMgPSB0aGlzLmNvbmZpZy5kZWZhdWx0QXVkaW9Db2RlYyB8fCBjdXJyZW50TGV2ZWwuYXVkaW9Db2RlYztcbiAgICBpZiAodGhpcy5hdWRpb0NvZGVjU3dhcCAmJiBhdWRpb0NvZGVjKSB7XG4gICAgICB0aGlzLmxvZygnU3dhcHBpbmcgYXVkaW8gY29kZWMnKTtcbiAgICAgIGlmIChhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkge1xuICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuMic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuNSc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhdWRpb0NvZGVjO1xuICB9XG4gIF9sb2FkQml0cmF0ZVRlc3RGcmFnKGZyYWdtZW50LCBsZXZlbCkge1xuICAgIGZyYWdtZW50LmJpdHJhdGVUZXN0ID0gdHJ1ZTtcbiAgICB0aGlzLl9kb0ZyYWdMb2FkKGZyYWdtZW50LCBsZXZlbCkudGhlbihkYXRhID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaGxzXG4gICAgICB9ID0gdGhpcztcbiAgICAgIGNvbnN0IGZyYWcgPSBkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmZyYWc7XG4gICAgICBpZiAoIWZyYWcgfHwgdGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV2ZWwuZnJhZ21lbnRFcnJvciA9IDA7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmJpdHJhdGVUZXN0ID0gZmFsc2U7XG4gICAgICBjb25zdCBzdGF0cyA9IGZyYWcuc3RhdHM7XG4gICAgICAvLyBCaXRyYXRlIHRlc3RzIGZyYWdtZW50cyBhcmUgbmVpdGhlciBwYXJzZWQgbm9yIGJ1ZmZlcmVkXG4gICAgICBzdGF0cy5wYXJzaW5nLnN0YXJ0ID0gc3RhdHMucGFyc2luZy5lbmQgPSBzdGF0cy5idWZmZXJpbmcuc3RhcnQgPSBzdGF0cy5idWZmZXJpbmcuZW5kID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0xPQURFRCwgZGF0YSk7XG4gICAgICBmcmFnLmJpdHJhdGVUZXN0ID0gZmFsc2U7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZVRyYW5zbXV4Q29tcGxldGUodHJhbnNtdXhSZXN1bHQpIHtcbiAgICB2YXIgX2lkMyRzYW1wbGVzO1xuICAgIGNvbnN0IGlkID0gdGhpcy5wbGF5bGlzdFR5cGU7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgcmVtdXhSZXN1bHQsXG4gICAgICBjaHVua01ldGFcbiAgICB9ID0gdHJhbnNtdXhSZXN1bHQ7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ2V0Q3VycmVudENvbnRleHQoY2h1bmtNZXRhKTtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgIHRoaXMucmVzZXRXaGVuTWlzc2luZ0NvbnRleHQoY2h1bmtNZXRhKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIHBhcnQsXG4gICAgICBsZXZlbFxuICAgIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IHtcbiAgICAgIHZpZGVvLFxuICAgICAgdGV4dCxcbiAgICAgIGlkMyxcbiAgICAgIGluaXRTZWdtZW50XG4gICAgfSA9IHJlbXV4UmVzdWx0O1xuICAgIGNvbnN0IHtcbiAgICAgIGRldGFpbHNcbiAgICB9ID0gbGV2ZWw7XG4gICAgLy8gVGhlIGF1ZGlvLXN0cmVhbS1jb250cm9sbGVyIGhhbmRsZXMgYXVkaW8gYnVmZmVyaW5nIGlmIEhscy5qcyBpcyBwbGF5aW5nIGFuIGFsdGVybmF0ZSBhdWRpbyB0cmFja1xuICAgIGNvbnN0IGF1ZGlvID0gdGhpcy5hbHRBdWRpbyA/IHVuZGVmaW5lZCA6IHJlbXV4UmVzdWx0LmF1ZGlvO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIGN1cnJlbnQgZnJhZ21lbnQgaGFzIGJlZW4gYWJvcnRlZC4gV2UgY2hlY2sgdGhpcyBieSBmaXJzdCBzZWVpbmcgaWYgd2UncmUgc3RpbGwgcGxheWluZyB0aGUgY3VycmVudCBsZXZlbC5cbiAgICAvLyBJZiB3ZSBhcmUsIHN1YnNlcXVlbnRseSBjaGVjayBpZiB0aGUgY3VycmVudGx5IGxvYWRpbmcgZnJhZ21lbnQgKGZyYWdDdXJyZW50KSBoYXMgY2hhbmdlZC5cbiAgICBpZiAodGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFSU0lORztcbiAgICBpZiAoaW5pdFNlZ21lbnQpIHtcbiAgICAgIGlmIChpbml0U2VnbWVudCAhPSBudWxsICYmIGluaXRTZWdtZW50LnRyYWNrcykge1xuICAgICAgICBjb25zdCBtYXBGcmFnbWVudCA9IGZyYWcuaW5pdFNlZ21lbnQgfHwgZnJhZztcbiAgICAgICAgdGhpcy5fYnVmZmVySW5pdFNlZ21lbnQobGV2ZWwsIGluaXRTZWdtZW50LnRyYWNrcywgbWFwRnJhZ21lbnQsIGNodW5rTWV0YSk7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULCB7XG4gICAgICAgICAgZnJhZzogbWFwRnJhZ21lbnQsXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgdHJhY2tzOiBpbml0U2VnbWVudC50cmFja3NcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoaXMgd291bGQgYmUgbmljZSBpZiBOdW1iZXIuaXNGaW5pdGUgYWN0ZWQgYXMgYSB0eXBlZ3VhcmQsIGJ1dCBpdCBkb2Vzbid0LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMTAwMzhcbiAgICAgIGNvbnN0IGJhc2VUaW1lID0gaW5pdFNlZ21lbnQuaW5pdFBUUztcbiAgICAgIGNvbnN0IHRpbWVzY2FsZSA9IGluaXRTZWdtZW50LnRpbWVzY2FsZTtcbiAgICAgIGNvbnN0IGluaXRQVFMgPSB0aGlzLmluaXRQVFNbZnJhZy5jY107XG4gICAgICBpZiAoaXNGaW5pdGVOdW1iZXIoYmFzZVRpbWUpICYmICghaW5pdFBUUyB8fCBpbml0UFRTLmJhc2VUaW1lICE9PSBiYXNlVGltZSB8fCBpbml0UFRTLnRpbWVzY2FsZSAhPT0gdGltZXNjYWxlKSkge1xuICAgICAgICB0aGlzLmluaXRQVFNbZnJhZy5jY10gPSB7XG4gICAgICAgICAgYmFzZVRpbWUsXG4gICAgICAgICAgdGltZXNjYWxlXG4gICAgICAgIH07XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5JTklUX1BUU19GT1VORCwge1xuICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgaW5pdFBUUzogYmFzZVRpbWUsXG4gICAgICAgICAgdGltZXNjYWxlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEF2b2lkIGJ1ZmZlcmluZyBpZiBiYWNrdHJhY2tpbmcgdGhpcyBmcmFnbWVudFxuICAgIGlmICh2aWRlbyAmJiBkZXRhaWxzKSB7XG4gICAgICBpZiAoYXVkaW8gJiYgdmlkZW8udHlwZSA9PT0gJ2F1ZGlvdmlkZW8nKSB7XG4gICAgICAgIHRoaXMubG9nTXV4ZWRFcnIoZnJhZyk7XG4gICAgICB9XG4gICAgICBjb25zdCBwcmV2RnJhZyA9IGRldGFpbHMuZnJhZ21lbnRzW2ZyYWcuc24gLSAxIC0gZGV0YWlscy5zdGFydFNOXTtcbiAgICAgIGNvbnN0IGlzRmlyc3RGcmFnbWVudCA9IGZyYWcuc24gPT09IGRldGFpbHMuc3RhcnRTTjtcbiAgICAgIGNvbnN0IGlzRmlyc3RJbkRpc2NvbnRpbnVpdHkgPSAhcHJldkZyYWcgfHwgZnJhZy5jYyA+IHByZXZGcmFnLmNjO1xuICAgICAgaWYgKHJlbXV4UmVzdWx0LmluZGVwZW5kZW50ICE9PSBmYWxzZSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc3RhcnRQVFMsXG4gICAgICAgICAgZW5kUFRTLFxuICAgICAgICAgIHN0YXJ0RFRTLFxuICAgICAgICAgIGVuZERUU1xuICAgICAgICB9ID0gdmlkZW87XG4gICAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgICAgcGFydC5lbGVtZW50YXJ5U3RyZWFtc1t2aWRlby50eXBlXSA9IHtcbiAgICAgICAgICAgIHN0YXJ0UFRTLFxuICAgICAgICAgICAgZW5kUFRTLFxuICAgICAgICAgICAgc3RhcnREVFMsXG4gICAgICAgICAgICBlbmREVFNcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh2aWRlby5maXJzdEtleUZyYW1lICYmIHZpZGVvLmluZGVwZW5kZW50ICYmIGNodW5rTWV0YS5pZCA9PT0gMSAmJiAhaXNGaXJzdEluRGlzY29udGludWl0eSkge1xuICAgICAgICAgICAgdGhpcy5jb3VsZEJhY2t0cmFjayA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2aWRlby5kcm9wcGVkICYmIHZpZGVvLmluZGVwZW5kZW50KSB7XG4gICAgICAgICAgICAvLyBCYWNrdHJhY2sgaWYgZHJvcHBlZCBmcmFtZXMgY3JlYXRlIGEgZ2FwIGFmdGVyIGN1cnJlbnRUaW1lXG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlckluZm8gPSB0aGlzLmdldE1haW5Gd2RCdWZmZXJJbmZvKCk7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRCdWZmZXJUaW1lID0gKGJ1ZmZlckluZm8gPyBidWZmZXJJbmZvLmVuZCA6IHRoaXMuZ2V0TG9hZFBvc2l0aW9uKCkpICsgdGhpcy5jb25maWcubWF4QnVmZmVySG9sZTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHZpZGVvLmZpcnN0S2V5RnJhbWVQVFMgPyB2aWRlby5maXJzdEtleUZyYW1lUFRTIDogc3RhcnRQVFM7XG4gICAgICAgICAgICBpZiAoIWlzRmlyc3RGcmFnbWVudCAmJiB0YXJnZXRCdWZmZXJUaW1lIDwgc3RhcnRUaW1lIC0gdGhpcy5jb25maWcubWF4QnVmZmVySG9sZSAmJiAhaXNGaXJzdEluRGlzY29udGludWl0eSkge1xuICAgICAgICAgICAgICB0aGlzLmJhY2t0cmFjayhmcmFnKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0ZpcnN0SW5EaXNjb250aW51aXR5KSB7XG4gICAgICAgICAgICAgIC8vIE1hcmsgc2VnbWVudCB3aXRoIGEgZ2FwIHRvIGF2b2lkIGxvb3AgbG9hZGluZ1xuICAgICAgICAgICAgICBmcmFnLmdhcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXQgdmlkZW8gc3RyZWFtIHN0YXJ0IHRvIGZyYWdtZW50IHN0YXJ0IHNvIHRoYXQgdHJ1bmNhdGVkIHNhbXBsZXMgZG8gbm90IGRpc3RvcnQgdGhlIHRpbWVsaW5lLCBhbmQgbWFyayBpdCBwYXJ0aWFsXG4gICAgICAgICAgICBmcmFnLnNldEVsZW1lbnRhcnlTdHJlYW1JbmZvKHZpZGVvLnR5cGUsIGZyYWcuc3RhcnQsIGVuZFBUUywgZnJhZy5zdGFydCwgZW5kRFRTLCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRmlyc3RGcmFnbWVudCAmJiBzdGFydFBUUyAtIChkZXRhaWxzLmFwcGxpZWRUaW1lbGluZU9mZnNldCB8fCAwKSA+IE1BWF9TVEFSVF9HQVBfSlVNUCkge1xuICAgICAgICAgICAgLy8gTWFyayBzZWdtZW50IHdpdGggYSBnYXAgdG8gc2tpcCBsYXJnZSBzdGFydCBnYXBcbiAgICAgICAgICAgIGZyYWcuZ2FwID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnJhZy5zZXRFbGVtZW50YXJ5U3RyZWFtSW5mbyh2aWRlby50eXBlLCBzdGFydFBUUywgZW5kUFRTLCBzdGFydERUUywgZW5kRFRTKTtcbiAgICAgICAgaWYgKHRoaXMuYmFja3RyYWNrRnJhZ21lbnQpIHtcbiAgICAgICAgICB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ID0gZnJhZztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1ZmZlckZyYWdtZW50RGF0YSh2aWRlbywgZnJhZywgcGFydCwgY2h1bmtNZXRhLCBpc0ZpcnN0RnJhZ21lbnQgfHwgaXNGaXJzdEluRGlzY29udGludWl0eSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRmlyc3RGcmFnbWVudCB8fCBpc0ZpcnN0SW5EaXNjb250aW51aXR5KSB7XG4gICAgICAgIC8vIE1hcmsgc2VnbWVudCB3aXRoIGEgZ2FwIHRvIGF2b2lkIGxvb3AgbG9hZGluZ1xuICAgICAgICBmcmFnLmdhcCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJhY2t0cmFjayhmcmFnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXVkaW8pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3RhcnRQVFMsXG4gICAgICAgIGVuZFBUUyxcbiAgICAgICAgc3RhcnREVFMsXG4gICAgICAgIGVuZERUU1xuICAgICAgfSA9IGF1ZGlvO1xuICAgICAgaWYgKHBhcnQpIHtcbiAgICAgICAgcGFydC5lbGVtZW50YXJ5U3RyZWFtc1tFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU9dID0ge1xuICAgICAgICAgIHN0YXJ0UFRTLFxuICAgICAgICAgIGVuZFBUUyxcbiAgICAgICAgICBzdGFydERUUyxcbiAgICAgICAgICBlbmREVFNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGZyYWcuc2V0RWxlbWVudGFyeVN0cmVhbUluZm8oRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPLCBzdGFydFBUUywgZW5kUFRTLCBzdGFydERUUywgZW5kRFRTKTtcbiAgICAgIHRoaXMuYnVmZmVyRnJhZ21lbnREYXRhKGF1ZGlvLCBmcmFnLCBwYXJ0LCBjaHVua01ldGEpO1xuICAgIH1cbiAgICBpZiAoZGV0YWlscyAmJiBpZDMgIT0gbnVsbCAmJiAoX2lkMyRzYW1wbGVzID0gaWQzLnNhbXBsZXMpICE9IG51bGwgJiYgX2lkMyRzYW1wbGVzLmxlbmd0aCkge1xuICAgICAgY29uc3QgZW1pdHRlZElEMyA9IHtcbiAgICAgICAgaWQsXG4gICAgICAgIGZyYWcsXG4gICAgICAgIGRldGFpbHMsXG4gICAgICAgIHNhbXBsZXM6IGlkMy5zYW1wbGVzXG4gICAgICB9O1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfUEFSU0lOR19NRVRBREFUQSwgZW1pdHRlZElEMyk7XG4gICAgfVxuICAgIGlmIChkZXRhaWxzICYmIHRleHQpIHtcbiAgICAgIGNvbnN0IGVtaXR0ZWRUZXh0ID0ge1xuICAgICAgICBpZCxcbiAgICAgICAgZnJhZyxcbiAgICAgICAgZGV0YWlscyxcbiAgICAgICAgc2FtcGxlczogdGV4dC5zYW1wbGVzXG4gICAgICB9O1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfUEFSU0lOR19VU0VSREFUQSwgZW1pdHRlZFRleHQpO1xuICAgIH1cbiAgfVxuICBsb2dNdXhlZEVycihmcmFnKSB7XG4gICAgdGhpcy53YXJuKGAke2lzTWVkaWFGcmFnbWVudChmcmFnKSA/ICdNZWRpYScgOiAnSW5pdCd9IHNlZ21lbnQgd2l0aCBtdXhlZCBhdWRpb3ZpZGVvIHdoZXJlIG9ubHkgdmlkZW8gZXhwZWN0ZWQ6ICR7ZnJhZy51cmx9YCk7XG4gIH1cbiAgX2J1ZmZlckluaXRTZWdtZW50KGN1cnJlbnRMZXZlbCwgdHJhY2tzLCBmcmFnLCBjaHVua01ldGEpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmF1ZGlvT25seSA9ICEhdHJhY2tzLmF1ZGlvICYmICF0cmFja3MudmlkZW87XG5cbiAgICAvLyBpZiBhdWRpbyB0cmFjayBpcyBleHBlY3RlZCB0byBjb21lIGZyb20gYXVkaW8gc3RyZWFtIGNvbnRyb2xsZXIsIGRpc2NhcmQgYW55IGNvbWluZyBmcm9tIG1haW5cbiAgICBpZiAodGhpcy5hbHRBdWRpbyAmJiAhdGhpcy5hdWRpb09ubHkpIHtcbiAgICAgIGRlbGV0ZSB0cmFja3MuYXVkaW87XG4gICAgICBpZiAodHJhY2tzLmF1ZGlvdmlkZW8pIHtcbiAgICAgICAgdGhpcy5sb2dNdXhlZEVycihmcmFnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaW5jbHVkZSBsZXZlbENvZGVjIGluIGF1ZGlvIGFuZCB2aWRlbyB0cmFja3NcbiAgICBjb25zdCB7XG4gICAgICBhdWRpbyxcbiAgICAgIHZpZGVvLFxuICAgICAgYXVkaW92aWRlb1xuICAgIH0gPSB0cmFja3M7XG4gICAgaWYgKGF1ZGlvKSB7XG4gICAgICBjb25zdCBsZXZlbENvZGVjID0gY3VycmVudExldmVsLmF1ZGlvQ29kZWM7XG4gICAgICBsZXQgYXVkaW9Db2RlYyA9IHBpY2tNb3N0Q29tcGxldGVDb2RlY05hbWUoYXVkaW8uY29kZWMsIGxldmVsQ29kZWMpO1xuICAgICAgLy8gQWRkIGxldmVsIGFuZCBwcm9maWxlIHRvIG1ha2UgdXAgZm9yIHJlbXV4ZXIgbm90IGJlaW5nIGFibGUgdG8gcGFyc2UgZnVsbCBjb2RlY1xuICAgICAgLy8gKGxvZ2dlciB3YXJuaW5nIFwiVW5oYW5kbGVkIGF1ZGlvIGNvZGVjLi4uXCIpXG4gICAgICBpZiAoYXVkaW9Db2RlYyA9PT0gJ21wNGEnKSB7XG4gICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC41JztcbiAgICAgIH1cbiAgICAgIC8vIEhhbmRsZSBgYXVkaW9Db2RlY1N3aXRjaGBcbiAgICAgIGNvbnN0IHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKHRoaXMuYXVkaW9Db2RlY1N3aXRjaCkge1xuICAgICAgICBpZiAoYXVkaW9Db2RlYykge1xuICAgICAgICAgIGlmIChhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkge1xuICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjInO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuNSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEluIHRoZSBjYXNlIHRoYXQgQUFDIGFuZCBIRS1BQUMgYXVkaW8gY29kZWNzIGFyZSBzaWduYWxsZWQgaW4gbWFuaWZlc3QsXG4gICAgICAgIC8vIGZvcmNlIEhFLUFBQywgYXMgaXQgc2VlbXMgdGhhdCBtb3N0IGJyb3dzZXJzIHByZWZlcnMgaXQuXG4gICAgICAgIC8vIGRvbid0IGZvcmNlIEhFLUFBQyBpZiBtb25vIHN0cmVhbSwgb3IgaW4gRmlyZWZveFxuICAgICAgICBjb25zdCBhdWRpb01ldGFkYXRhID0gYXVkaW8ubWV0YWRhdGE7XG4gICAgICAgIGlmIChhdWRpb01ldGFkYXRhICYmICdjaGFubmVsQ291bnQnIGluIGF1ZGlvTWV0YWRhdGEgJiYgKGF1ZGlvTWV0YWRhdGEuY2hhbm5lbENvdW50IHx8IDEpICE9PSAxICYmIHVhLmluZGV4T2YoJ2ZpcmVmb3gnKSA9PT0gLTEpIHtcbiAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuNSc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEhFLUFBQyBpcyBicm9rZW4gb24gQW5kcm9pZCwgYWx3YXlzIHNpZ25hbCBhdWRpbyBjb2RlYyBhcyBBQUMgZXZlbiBpZiB2YXJpYW50IG1hbmlmZXN0IHN0YXRlcyBvdGhlcndpc2VcbiAgICAgIGlmIChhdWRpb0NvZGVjICYmIGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09IC0xICYmIHVhLmluZGV4T2YoJ2FuZHJvaWQnKSAhPT0gLTEgJiYgYXVkaW8uY29udGFpbmVyICE9PSAnYXVkaW8vbXBlZycpIHtcbiAgICAgICAgLy8gRXhjbHVkZSBtcGVnIGF1ZGlvXG4gICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC4yJztcbiAgICAgICAgdGhpcy5sb2coYEFuZHJvaWQ6IGZvcmNlIGF1ZGlvIGNvZGVjIHRvICR7YXVkaW9Db2RlY31gKTtcbiAgICAgIH1cbiAgICAgIGlmIChsZXZlbENvZGVjICYmIGxldmVsQ29kZWMgIT09IGF1ZGlvQ29kZWMpIHtcbiAgICAgICAgdGhpcy5sb2coYFN3YXBwaW5nIG1hbmlmZXN0IGF1ZGlvIGNvZGVjIFwiJHtsZXZlbENvZGVjfVwiIGZvciBcIiR7YXVkaW9Db2RlY31cImApO1xuICAgICAgfVxuICAgICAgYXVkaW8ubGV2ZWxDb2RlYyA9IGF1ZGlvQ29kZWM7XG4gICAgICBhdWRpby5pZCA9IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU47XG4gICAgICB0aGlzLmxvZyhgSW5pdCBhdWRpbyBidWZmZXIsIGNvbnRhaW5lcjoke2F1ZGlvLmNvbnRhaW5lcn0sIGNvZGVjc1tzZWxlY3RlZC9sZXZlbC9wYXJzZWRdPVske2F1ZGlvQ29kZWMgfHwgJyd9LyR7bGV2ZWxDb2RlYyB8fCAnJ30vJHthdWRpby5jb2RlY31dYCk7XG4gICAgICBkZWxldGUgdHJhY2tzLmF1ZGlvdmlkZW87XG4gICAgfVxuICAgIGlmICh2aWRlbykge1xuICAgICAgdmlkZW8ubGV2ZWxDb2RlYyA9IGN1cnJlbnRMZXZlbC52aWRlb0NvZGVjO1xuICAgICAgdmlkZW8uaWQgPSBQbGF5bGlzdExldmVsVHlwZS5NQUlOO1xuICAgICAgY29uc3QgcGFyc2VkVmlkZW9Db2RlYyA9IHZpZGVvLmNvZGVjO1xuICAgICAgaWYgKChwYXJzZWRWaWRlb0NvZGVjID09IG51bGwgPyB2b2lkIDAgOiBwYXJzZWRWaWRlb0NvZGVjLmxlbmd0aCkgPT09IDQpIHtcbiAgICAgICAgLy8gTWFrZSB1cCBmb3IgcGFzc3Rocm91Z2gtcmVtdXhlciBub3QgYmVpbmcgYWJsZSB0byBwYXJzZSBmdWxsIGNvZGVjXG4gICAgICAgIC8vIChsb2dnZXIgd2FybmluZyBcIlVuaGFuZGxlZCB2aWRlbyBjb2RlYy4uLlwiKVxuICAgICAgICBzd2l0Y2ggKHBhcnNlZFZpZGVvQ29kZWMpIHtcbiAgICAgICAgICBjYXNlICdodmMxJzpcbiAgICAgICAgICBjYXNlICdoZXYxJzpcbiAgICAgICAgICAgIHZpZGVvLmNvZGVjID0gJ2h2YzEuMS42LkwxMjAuOTAnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnYXYwMSc6XG4gICAgICAgICAgICB2aWRlby5jb2RlYyA9ICdhdjAxLjAuMDRNLjA4JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2F2YzEnOlxuICAgICAgICAgICAgdmlkZW8uY29kZWMgPSAnYXZjMS40MmUwMWUnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubG9nKGBJbml0IHZpZGVvIGJ1ZmZlciwgY29udGFpbmVyOiR7dmlkZW8uY29udGFpbmVyfSwgY29kZWNzW2xldmVsL3BhcnNlZF09WyR7Y3VycmVudExldmVsLnZpZGVvQ29kZWMgfHwgJyd9LyR7cGFyc2VkVmlkZW9Db2RlY31dJHt2aWRlby5jb2RlYyAhPT0gcGFyc2VkVmlkZW9Db2RlYyA/ICcgcGFyc2VkLWNvcnJlY3RlZD0nICsgdmlkZW8uY29kZWMgOiAnJ30ke3ZpZGVvLnN1cHBsZW1lbnRhbCA/ICcgc3VwcGxlbWVudGFsPScgKyB2aWRlby5zdXBwbGVtZW50YWwgOiAnJ31gKTtcbiAgICAgIGRlbGV0ZSB0cmFja3MuYXVkaW92aWRlbztcbiAgICB9XG4gICAgaWYgKGF1ZGlvdmlkZW8pIHtcbiAgICAgIHRoaXMubG9nKGBJbml0IGF1ZGlvdmlkZW8gYnVmZmVyLCBjb250YWluZXI6JHthdWRpb3ZpZGVvLmNvbnRhaW5lcn0sIGNvZGVjc1tsZXZlbC9wYXJzZWRdPVske2N1cnJlbnRMZXZlbC5jb2RlY3N9LyR7YXVkaW92aWRlby5jb2RlY31dYCk7XG4gICAgICBkZWxldGUgdHJhY2tzLnZpZGVvO1xuICAgICAgZGVsZXRlIHRyYWNrcy5hdWRpbztcbiAgICB9XG4gICAgY29uc3QgdHJhY2tUeXBlcyA9IE9iamVjdC5rZXlzKHRyYWNrcyk7XG4gICAgaWYgKHRyYWNrVHlwZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfQ09ERUNTLCB0cmFja3MpO1xuICAgICAgaWYgKCF0aGlzLmhscykge1xuICAgICAgICAvLyBFeGl0IGFmdGVyIGZhdGFsIHRyYWNrcyBlcnJvclxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBsb29wIHRocm91Z2ggdHJhY2tzIHRoYXQgYXJlIGdvaW5nIHRvIGJlIHByb3ZpZGVkIHRvIGJ1ZmZlckNvbnRyb2xsZXJcbiAgICAgIHRyYWNrVHlwZXMuZm9yRWFjaCh0cmFja05hbWUgPT4ge1xuICAgICAgICBjb25zdCB0cmFjayA9IHRyYWNrc1t0cmFja05hbWVdO1xuICAgICAgICBjb25zdCBpbml0U2VnbWVudCA9IHRyYWNrLmluaXRTZWdtZW50O1xuICAgICAgICBpZiAoaW5pdFNlZ21lbnQgIT0gbnVsbCAmJiBpbml0U2VnbWVudC5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0FQUEVORElORywge1xuICAgICAgICAgICAgdHlwZTogdHJhY2tOYW1lLFxuICAgICAgICAgICAgZGF0YTogaW5pdFNlZ21lbnQsXG4gICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgcGFydDogbnVsbCxcbiAgICAgICAgICAgIGNodW5rTWV0YSxcbiAgICAgICAgICAgIHBhcmVudDogZnJhZy50eXBlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgdGhpcy50aWNrSW1tZWRpYXRlKCk7XG4gIH1cbiAgZ2V0TWFpbkZ3ZEJ1ZmZlckluZm8oKSB7XG4gICAgLy8gT2JzZXJ2ZSB2aWRlbyBTb3VyY2VCdWZmZXIgKHRoaXMubWVkaWFCdWZmZXIpIG9ubHkgd2hlbiBhbHQtYXVkaW8gaXMgdXNlZCwgb3RoZXJ3aXNlIG9ic2VydmUgY29tYmluZWQgbWVkaWEgYnVmZmVyXG4gICAgY29uc3QgYnVmZmVyT3V0cHV0ID0gdGhpcy5tZWRpYUJ1ZmZlciAmJiB0aGlzLmFsdEF1ZGlvID09PSAyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IHRoaXMubWVkaWE7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RndkQnVmZmVySW5mbyhidWZmZXJPdXRwdXQsIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pO1xuICB9XG4gIGdldCBtYXhCdWZmZXJMZW5ndGgoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWxzLFxuICAgICAgbGV2ZWxcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBsZXZlbEluZm8gPSBsZXZlbHMgPT0gbnVsbCA/IHZvaWQgMCA6IGxldmVsc1tsZXZlbF07XG4gICAgaWYgKCFsZXZlbEluZm8pIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5tYXhCdWZmZXJMZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldE1heEJ1ZmZlckxlbmd0aChsZXZlbEluZm8ubWF4Qml0cmF0ZSk7XG4gIH1cbiAgYmFja3RyYWNrKGZyYWcpIHtcbiAgICB0aGlzLmNvdWxkQmFja3RyYWNrID0gdHJ1ZTtcbiAgICAvLyBDYXVzZXMgZmluZEZyYWdtZW50cyB0byBiYWNrdHJhY2sgdGhyb3VnaCBmcmFnbWVudHMgdG8gZmluZCB0aGUga2V5ZnJhbWVcbiAgICB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ID0gZnJhZztcbiAgICB0aGlzLnJlc2V0VHJhbnNtdXhlcigpO1xuICAgIHRoaXMuZmx1c2hCdWZmZXJHYXAoZnJhZyk7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IGZyYWcuc3RhcnQ7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gIH1cbiAgY2hlY2tGcmFnbWVudENoYW5nZWQoKSB7XG4gICAgY29uc3QgdmlkZW8gPSB0aGlzLm1lZGlhO1xuICAgIGxldCBmcmFnUGxheWluZ0N1cnJlbnQgPSBudWxsO1xuICAgIGlmICh2aWRlbyAmJiB2aWRlby5yZWFkeVN0YXRlID4gMSAmJiB2aWRlby5zZWVraW5nID09PSBmYWxzZSkge1xuICAgICAgY29uc3QgY3VycmVudFRpbWUgPSB2aWRlby5jdXJyZW50VGltZTtcbiAgICAgIC8qIGlmIHZpZGVvIGVsZW1lbnQgaXMgaW4gc2Vla2VkIHN0YXRlLCBjdXJyZW50VGltZSBjYW4gb25seSBpbmNyZWFzZS5cbiAgICAgICAgKGFzc3VtaW5nIHRoYXQgcGxheWJhY2sgcmF0ZSBpcyBwb3NpdGl2ZSAuLi4pXG4gICAgICAgIEFzIHNvbWV0aW1lcyBjdXJyZW50VGltZSBqdW1wcyBiYWNrIHRvIHplcm8gYWZ0ZXIgYVxuICAgICAgICBtZWRpYSBkZWNvZGUgZXJyb3IsIGNoZWNrIHRoaXMsIHRvIGF2b2lkIHNlZWtpbmcgYmFjayB0b1xuICAgICAgICB3cm9uZyBwb3NpdGlvbiBhZnRlciBhIG1lZGlhIGRlY29kZSBlcnJvclxuICAgICAgKi9cblxuICAgICAgaWYgKEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKHZpZGVvLCBjdXJyZW50VGltZSkpIHtcbiAgICAgICAgZnJhZ1BsYXlpbmdDdXJyZW50ID0gdGhpcy5nZXRBcHBlbmRlZEZyYWcoY3VycmVudFRpbWUpO1xuICAgICAgfSBlbHNlIGlmIChCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZCh2aWRlbywgY3VycmVudFRpbWUgKyAwLjEpKSB7XG4gICAgICAgIC8qIGVuc3VyZSB0aGF0IEZSQUdfQ0hBTkdFRCBldmVudCBpcyB0cmlnZ2VyZWQgYXQgc3RhcnR1cCxcbiAgICAgICAgICB3aGVuIGZpcnN0IHZpZGVvIGZyYW1lIGlzIGRpc3BsYXllZCBhbmQgcGxheWJhY2sgaXMgcGF1c2VkLlxuICAgICAgICAgIGFkZCBhIHRvbGVyYW5jZSBvZiAxMDBtcywgaW4gY2FzZSBjdXJyZW50IHBvc2l0aW9uIGlzIG5vdCBidWZmZXJlZCxcbiAgICAgICAgICBjaGVjayBpZiBjdXJyZW50IHBvcysxMDBtcyBpcyBidWZmZXJlZCBhbmQgdXNlIHRoYXQgYnVmZmVyIHJhbmdlXG4gICAgICAgICAgZm9yIEZSQUdfQ0hBTkdFRCBldmVudCByZXBvcnRpbmcgKi9cbiAgICAgICAgZnJhZ1BsYXlpbmdDdXJyZW50ID0gdGhpcy5nZXRBcHBlbmRlZEZyYWcoY3VycmVudFRpbWUgKyAwLjEpO1xuICAgICAgfVxuICAgICAgaWYgKGZyYWdQbGF5aW5nQ3VycmVudCkge1xuICAgICAgICB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ID0gbnVsbDtcbiAgICAgICAgY29uc3QgZnJhZ1BsYXlpbmcgPSB0aGlzLmZyYWdQbGF5aW5nO1xuICAgICAgICBjb25zdCBmcmFnQ3VycmVudExldmVsID0gZnJhZ1BsYXlpbmdDdXJyZW50LmxldmVsO1xuICAgICAgICBpZiAoIWZyYWdQbGF5aW5nIHx8IGZyYWdQbGF5aW5nQ3VycmVudC5zbiAhPT0gZnJhZ1BsYXlpbmcuc24gfHwgZnJhZ1BsYXlpbmcubGV2ZWwgIT09IGZyYWdDdXJyZW50TGV2ZWwpIHtcbiAgICAgICAgICB0aGlzLmZyYWdQbGF5aW5nID0gZnJhZ1BsYXlpbmdDdXJyZW50O1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfQ0hBTkdFRCwge1xuICAgICAgICAgICAgZnJhZzogZnJhZ1BsYXlpbmdDdXJyZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKCFmcmFnUGxheWluZyB8fCBmcmFnUGxheWluZy5sZXZlbCAhPT0gZnJhZ0N1cnJlbnRMZXZlbCkge1xuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTEVWRUxfU1dJVENIRUQsIHtcbiAgICAgICAgICAgICAgbGV2ZWw6IGZyYWdDdXJyZW50TGV2ZWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgbmV4dExldmVsKCkge1xuICAgIGNvbnN0IGZyYWcgPSB0aGlzLm5leHRCdWZmZXJlZEZyYWc7XG4gICAgaWYgKGZyYWcpIHtcbiAgICAgIHJldHVybiBmcmFnLmxldmVsO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgZ2V0IGN1cnJlbnRGcmFnKCkge1xuICAgIHZhciBfdGhpcyRtZWRpYTM7XG4gICAgaWYgKHRoaXMuZnJhZ1BsYXlpbmcpIHtcbiAgICAgIHJldHVybiB0aGlzLmZyYWdQbGF5aW5nO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50VGltZSA9ICgoX3RoaXMkbWVkaWEzID0gdGhpcy5tZWRpYSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG1lZGlhMy5jdXJyZW50VGltZSkgfHwgdGhpcy5sYXN0Q3VycmVudFRpbWU7XG4gICAgaWYgKGlzRmluaXRlTnVtYmVyKGN1cnJlbnRUaW1lKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0QXBwZW5kZWRGcmFnKGN1cnJlbnRUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2V0IGN1cnJlbnRQcm9ncmFtRGF0ZVRpbWUoKSB7XG4gICAgdmFyIF90aGlzJG1lZGlhNDtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9ICgoX3RoaXMkbWVkaWE0ID0gdGhpcy5tZWRpYSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG1lZGlhNC5jdXJyZW50VGltZSkgfHwgdGhpcy5sYXN0Q3VycmVudFRpbWU7XG4gICAgaWYgKGlzRmluaXRlTnVtYmVyKGN1cnJlbnRUaW1lKSkge1xuICAgICAgY29uc3QgZGV0YWlscyA9IHRoaXMuZ2V0TGV2ZWxEZXRhaWxzKCk7XG4gICAgICBjb25zdCBmcmFnID0gdGhpcy5jdXJyZW50RnJhZyB8fCAoZGV0YWlscyA/IGZpbmRGcmFnbWVudEJ5UFRTKG51bGwsIGRldGFpbHMuZnJhZ21lbnRzLCBjdXJyZW50VGltZSkgOiBudWxsKTtcbiAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgIGNvbnN0IHByb2dyYW1EYXRlVGltZSA9IGZyYWcucHJvZ3JhbURhdGVUaW1lO1xuICAgICAgICBpZiAocHJvZ3JhbURhdGVUaW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgZXBvY01zID0gcHJvZ3JhbURhdGVUaW1lICsgKGN1cnJlbnRUaW1lIC0gZnJhZy5zdGFydCkgKiAxMDAwO1xuICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShlcG9jTXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdldCBjdXJyZW50TGV2ZWwoKSB7XG4gICAgY29uc3QgZnJhZyA9IHRoaXMuY3VycmVudEZyYWc7XG4gICAgaWYgKGZyYWcpIHtcbiAgICAgIHJldHVybiBmcmFnLmxldmVsO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgZ2V0IG5leHRCdWZmZXJlZEZyYWcoKSB7XG4gICAgY29uc3QgZnJhZyA9IHRoaXMuY3VycmVudEZyYWc7XG4gICAgaWYgKGZyYWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmZvbGxvd2luZ0J1ZmZlcmVkRnJhZyhmcmFnKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2V0IGZvcmNlU3RhcnRMb2FkKCkge1xuICAgIHJldHVybiB0aGlzLl9mb3JjZVN0YXJ0TG9hZDtcbiAgfVxufVxuXG5jbGFzcyBLZXlMb2FkZXIge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLmtleVVyaVRvS2V5SW5mbyA9IHt9O1xuICAgIHRoaXMuZW1lQ29udHJvbGxlciA9IG51bGw7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gIH1cbiAgYWJvcnQodHlwZSkge1xuICAgIGZvciAoY29uc3QgdXJpIGluIHRoaXMua2V5VXJpVG9LZXlJbmZvKSB7XG4gICAgICBjb25zdCBsb2FkZXIgPSB0aGlzLmtleVVyaVRvS2V5SW5mb1t1cmldLmxvYWRlcjtcbiAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgdmFyIF9sb2FkZXIkY29udGV4dDtcbiAgICAgICAgaWYgKHR5cGUgJiYgdHlwZSAhPT0gKChfbG9hZGVyJGNvbnRleHQgPSBsb2FkZXIuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9sb2FkZXIkY29udGV4dC5mcmFnLnR5cGUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkZXRhY2goKSB7XG4gICAgZm9yIChjb25zdCB1cmkgaW4gdGhpcy5rZXlVcmlUb0tleUluZm8pIHtcbiAgICAgIGNvbnN0IGtleUluZm8gPSB0aGlzLmtleVVyaVRvS2V5SW5mb1t1cmldO1xuICAgICAgLy8gUmVtb3ZlIGNhY2hlZCBFTUUga2V5cyBvbiBkZXRhY2hcbiAgICAgIGlmIChrZXlJbmZvLm1lZGlhS2V5U2Vzc2lvbkNvbnRleHQgfHwga2V5SW5mby5kZWNyeXB0ZGF0YS5pc0NvbW1vbkVuY3J5cHRpb24pIHtcbiAgICAgICAgZGVsZXRlIHRoaXMua2V5VXJpVG9LZXlJbmZvW3VyaV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXRhY2goKTtcbiAgICBmb3IgKGNvbnN0IHVyaSBpbiB0aGlzLmtleVVyaVRvS2V5SW5mbykge1xuICAgICAgY29uc3QgbG9hZGVyID0gdGhpcy5rZXlVcmlUb0tleUluZm9bdXJpXS5sb2FkZXI7XG4gICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgIGxvYWRlci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMua2V5VXJpVG9LZXlJbmZvID0ge307XG4gIH1cbiAgY3JlYXRlS2V5TG9hZEVycm9yKGZyYWcsIGRldGFpbHMgPSBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1IsIGVycm9yLCBuZXR3b3JrRGV0YWlscywgcmVzcG9uc2UpIHtcbiAgICByZXR1cm4gbmV3IExvYWRFcnJvcih7XG4gICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICBkZXRhaWxzLFxuICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgZnJhZyxcbiAgICAgIHJlc3BvbnNlLFxuICAgICAgZXJyb3IsXG4gICAgICBuZXR3b3JrRGV0YWlsc1xuICAgIH0pO1xuICB9XG4gIGxvYWRDbGVhcihsb2FkaW5nRnJhZywgZW5jcnlwdGVkRnJhZ21lbnRzLCBzdGFydEZyYWdSZXF1ZXN0ZWQpIHtcbiAgICBpZiAodGhpcy5lbWVDb250cm9sbGVyICYmIHRoaXMuY29uZmlnLmVtZUVuYWJsZWQgJiYgIXRoaXMuZW1lQ29udHJvbGxlci5nZXRTZWxlY3RlZEtleVN5c3RlbUZvcm1hdHMoKS5sZW5ndGgpIHtcbiAgICAgIC8vIEFjY2VzcyBrZXktc3lzdGVtIHdpdGggbmVhcmVzdCBrZXkgb24gc3RhcnQgKGxvYWRpbmcgZnJhZyBpcyB1bmVuY3J5cHRlZClcbiAgICAgIGlmIChlbmNyeXB0ZWRGcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gZW5jcnlwdGVkRnJhZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGZyYWcgPSBlbmNyeXB0ZWRGcmFnbWVudHNbaV07XG4gICAgICAgICAgLy8gTG9hZGluZyBhdCBvciBiZWZvcmUgc2VnbWVudCB3aXRoIEVYVC1YLUtFWSwgb3IgZmlyc3QgZnJhZyBsb2FkaW5nIGFuZCBsYXN0IEVYVC1YLUtFWVxuICAgICAgICAgIGlmIChsb2FkaW5nRnJhZy5jYyA8PSBmcmFnLmNjICYmICghaXNNZWRpYUZyYWdtZW50KGxvYWRpbmdGcmFnKSB8fCAhaXNNZWRpYUZyYWdtZW50KGZyYWcpIHx8IGxvYWRpbmdGcmFnLnNuIDwgZnJhZy5zbikgfHwgIXN0YXJ0RnJhZ1JlcXVlc3RlZCAmJiBpID09IGwgLSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbWVDb250cm9sbGVyLnNlbGVjdEtleVN5c3RlbUZvcm1hdChmcmFnKS50aGVuKGtleVN5c3RlbUZvcm1hdCA9PiB7XG4gICAgICAgICAgICAgIGlmICghdGhpcy5lbWVDb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZyYWcuc2V0S2V5Rm9ybWF0KGtleVN5c3RlbUZvcm1hdCk7XG4gICAgICAgICAgICAgIGNvbnN0IGtleVN5c3RlbSA9IGtleVN5c3RlbUZvcm1hdFRvS2V5U3lzdGVtRG9tYWluKGtleVN5c3RlbUZvcm1hdCk7XG4gICAgICAgICAgICAgIGlmIChrZXlTeXN0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbWVDb250cm9sbGVyLmdldEtleVN5c3RlbUFjY2Vzcyhba2V5U3lzdGVtXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY29uZmlnLnJlcXVpcmVLZXlTeXN0ZW1BY2Nlc3NPblN0YXJ0KSB7XG4gICAgICAgIGNvbnN0IGtleVN5c3RlbXNJbkNvbmZpZyA9IGdldEtleVN5c3RlbXNGb3JDb25maWcodGhpcy5jb25maWcpO1xuICAgICAgICBpZiAoa2V5U3lzdGVtc0luQ29uZmlnLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVtZUNvbnRyb2xsZXIuZ2V0S2V5U3lzdGVtQWNjZXNzKGtleVN5c3RlbXNJbkNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbG9hZChmcmFnKSB7XG4gICAgaWYgKCFmcmFnLmRlY3J5cHRkYXRhICYmIGZyYWcuZW5jcnlwdGVkICYmIHRoaXMuZW1lQ29udHJvbGxlciAmJiB0aGlzLmNvbmZpZy5lbWVFbmFibGVkKSB7XG4gICAgICAvLyBNdWx0aXBsZSBrZXlzLCBidXQgbm9uZSBzZWxlY3RlZCwgcmVzb2x2ZSBpbiBlbWUtY29udHJvbGxlclxuICAgICAgcmV0dXJuIHRoaXMuZW1lQ29udHJvbGxlci5zZWxlY3RLZXlTeXN0ZW1Gb3JtYXQoZnJhZykudGhlbihrZXlTeXN0ZW1Gb3JtYXQgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkSW50ZXJuYWwoZnJhZywga2V5U3lzdGVtRm9ybWF0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5sb2FkSW50ZXJuYWwoZnJhZyk7XG4gIH1cbiAgbG9hZEludGVybmFsKGZyYWcsIGtleVN5c3RlbUZvcm1hdCkge1xuICAgIHZhciBfa2V5SW5mbywgX2tleUluZm8yO1xuICAgIGlmIChrZXlTeXN0ZW1Gb3JtYXQpIHtcbiAgICAgIGZyYWcuc2V0S2V5Rm9ybWF0KGtleVN5c3RlbUZvcm1hdCk7XG4gICAgfVxuICAgIGNvbnN0IGRlY3J5cHRkYXRhID0gZnJhZy5kZWNyeXB0ZGF0YTtcbiAgICBpZiAoIWRlY3J5cHRkYXRhKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihrZXlTeXN0ZW1Gb3JtYXQgPyBgRXhwZWN0ZWQgZnJhZy5kZWNyeXB0ZGF0YSB0byBiZSBkZWZpbmVkIGFmdGVyIHNldHRpbmcgZm9ybWF0ICR7a2V5U3lzdGVtRm9ybWF0fWAgOiAnTWlzc2luZyBkZWNyeXB0aW9uIGRhdGEgb24gZnJhZ21lbnQgaW4gb25LZXlMb2FkaW5nJyk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QodGhpcy5jcmVhdGVLZXlMb2FkRXJyb3IoZnJhZywgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SLCBlcnJvcikpO1xuICAgIH1cbiAgICBjb25zdCB1cmkgPSBkZWNyeXB0ZGF0YS51cmk7XG4gICAgaWYgKCF1cmkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLmNyZWF0ZUtleUxvYWRFcnJvcihmcmFnLCBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1IsIG5ldyBFcnJvcihgSW52YWxpZCBrZXkgVVJJOiBcIiR7dXJpfVwiYCkpKTtcbiAgICB9XG4gICAgbGV0IGtleUluZm8gPSB0aGlzLmtleVVyaVRvS2V5SW5mb1t1cmldO1xuICAgIGlmICgoX2tleUluZm8gPSBrZXlJbmZvKSAhPSBudWxsICYmIF9rZXlJbmZvLmRlY3J5cHRkYXRhLmtleSkge1xuICAgICAgZGVjcnlwdGRhdGEua2V5ID0ga2V5SW5mby5kZWNyeXB0ZGF0YS5rZXk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgZnJhZyxcbiAgICAgICAga2V5SW5mb1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFJldHVybiBrZXkgbG9hZCBwcm9taXNlIGFzIGxvbmcgYXMgaXQgZG9lcyBub3QgaGF2ZSBhIG1lZGlha2V5IHNlc3Npb24gd2l0aCBhbiB1bnVzYWJsZSBrZXkgc3RhdHVzXG4gICAgaWYgKChfa2V5SW5mbzIgPSBrZXlJbmZvKSAhPSBudWxsICYmIF9rZXlJbmZvMi5rZXlMb2FkUHJvbWlzZSkge1xuICAgICAgdmFyIF9rZXlJbmZvJG1lZGlhS2V5U2VzcztcbiAgICAgIHN3aXRjaCAoKF9rZXlJbmZvJG1lZGlhS2V5U2VzcyA9IGtleUluZm8ubWVkaWFLZXlTZXNzaW9uQ29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9rZXlJbmZvJG1lZGlhS2V5U2Vzcy5rZXlTdGF0dXMpIHtcbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIGNhc2UgJ3N0YXR1cy1wZW5kaW5nJzpcbiAgICAgICAgY2FzZSAndXNhYmxlJzpcbiAgICAgICAgY2FzZSAndXNhYmxlLWluLWZ1dHVyZSc6XG4gICAgICAgICAgcmV0dXJuIGtleUluZm8ua2V5TG9hZFByb21pc2UudGhlbihrZXlMb2FkZWREYXRhID0+IHtcbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgY29ycmVjdCBmcmFnbWVudCB3aXRoIHVwZGF0ZWQgZGVjcnlwdGRhdGEga2V5IGFuZCBsb2FkZWQga2V5SW5mb1xuICAgICAgICAgICAgZGVjcnlwdGRhdGEua2V5ID0ga2V5TG9hZGVkRGF0YS5rZXlJbmZvLmRlY3J5cHRkYXRhLmtleTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgIGtleUluZm9cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvLyBJZiB3ZSBoYXZlIGEga2V5IHNlc3Npb24gYW5kIHN0YXR1cyBhbmQgaXQgaXMgbm90IHBlbmRpbmcgb3IgdXNhYmxlLCBjb250aW51ZVxuICAgICAgLy8gVGhpcyB3aWxsIGdvIGJhY2sgdG8gdGhlIGVtZS1jb250cm9sbGVyIGZvciBleHBpcmVkIGtleXMgdG8gZ2V0IGEgbmV3IGtleUxvYWRQcm9taXNlXG4gICAgfVxuXG4gICAgLy8gTG9hZCB0aGUga2V5IG9yIHJldHVybiB0aGUgbG9hZGluZyBwcm9taXNlXG4gICAga2V5SW5mbyA9IHRoaXMua2V5VXJpVG9LZXlJbmZvW3VyaV0gPSB7XG4gICAgICBkZWNyeXB0ZGF0YSxcbiAgICAgIGtleUxvYWRQcm9taXNlOiBudWxsLFxuICAgICAgbG9hZGVyOiBudWxsLFxuICAgICAgbWVkaWFLZXlTZXNzaW9uQ29udGV4dDogbnVsbFxuICAgIH07XG4gICAgc3dpdGNoIChkZWNyeXB0ZGF0YS5tZXRob2QpIHtcbiAgICAgIGNhc2UgJ0lTTy0yMzAwMS03JzpcbiAgICAgIGNhc2UgJ1NBTVBMRS1BRVMnOlxuICAgICAgY2FzZSAnU0FNUExFLUFFUy1DRU5DJzpcbiAgICAgIGNhc2UgJ1NBTVBMRS1BRVMtQ1RSJzpcbiAgICAgICAgaWYgKGRlY3J5cHRkYXRhLmtleUZvcm1hdCA9PT0gJ2lkZW50aXR5Jykge1xuICAgICAgICAgIC8vIGxvYWRLZXlIVFRQIGhhbmRsZXMgaHR0cChzKSBhbmQgZGF0YSBVUkxzXG4gICAgICAgICAgcmV0dXJuIHRoaXMubG9hZEtleUhUVFAoa2V5SW5mbywgZnJhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZEtleUVNRShrZXlJbmZvLCBmcmFnKTtcbiAgICAgIGNhc2UgJ0FFUy0xMjgnOlxuICAgICAgY2FzZSAnQUVTLTI1Nic6XG4gICAgICBjYXNlICdBRVMtMjU2LUNUUic6XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRLZXlIVFRQKGtleUluZm8sIGZyYWcpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHRoaXMuY3JlYXRlS2V5TG9hZEVycm9yKGZyYWcsIEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUiwgbmV3IEVycm9yKGBLZXkgc3VwcGxpZWQgd2l0aCB1bnN1cHBvcnRlZCBNRVRIT0Q6IFwiJHtkZWNyeXB0ZGF0YS5tZXRob2R9XCJgKSkpO1xuICAgIH1cbiAgfVxuICBsb2FkS2V5RU1FKGtleUluZm8sIGZyYWcpIHtcbiAgICBjb25zdCBrZXlMb2FkZWREYXRhID0ge1xuICAgICAgZnJhZyxcbiAgICAgIGtleUluZm9cbiAgICB9O1xuICAgIGlmICh0aGlzLmVtZUNvbnRyb2xsZXIgJiYgdGhpcy5jb25maWcuZW1lRW5hYmxlZCkge1xuICAgICAgY29uc3Qga2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlID0gdGhpcy5lbWVDb250cm9sbGVyLmxvYWRLZXkoa2V5TG9hZGVkRGF0YSk7XG4gICAgICBpZiAoa2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlKSB7XG4gICAgICAgIHJldHVybiAoa2V5SW5mby5rZXlMb2FkUHJvbWlzZSA9IGtleVNlc3Npb25Db250ZXh0UHJvbWlzZS50aGVuKGtleVNlc3Npb25Db250ZXh0ID0+IHtcbiAgICAgICAgICBrZXlJbmZvLm1lZGlhS2V5U2Vzc2lvbkNvbnRleHQgPSBrZXlTZXNzaW9uQ29udGV4dDtcbiAgICAgICAgICByZXR1cm4ga2V5TG9hZGVkRGF0YTtcbiAgICAgICAgfSkpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAvLyBSZW1vdmUgcHJvbWlzZSBmb3IgbGljZW5zZSByZW5ld2FsIG9yIHJldHJ5XG4gICAgICAgICAga2V5SW5mby5rZXlMb2FkUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGtleUxvYWRlZERhdGEpO1xuICB9XG4gIGxvYWRLZXlIVFRQKGtleUluZm8sIGZyYWcpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBjb25zdCBMb2FkZXIgPSBjb25maWcubG9hZGVyO1xuICAgIGNvbnN0IGtleUxvYWRlciA9IG5ldyBMb2FkZXIoY29uZmlnKTtcbiAgICBmcmFnLmtleUxvYWRlciA9IGtleUluZm8ubG9hZGVyID0ga2V5TG9hZGVyO1xuICAgIHJldHVybiBrZXlJbmZvLmtleUxvYWRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgbG9hZGVyQ29udGV4dCA9IHtcbiAgICAgICAga2V5SW5mbyxcbiAgICAgICAgZnJhZyxcbiAgICAgICAgcmVzcG9uc2VUeXBlOiAnYXJyYXlidWZmZXInLFxuICAgICAgICB1cmw6IGtleUluZm8uZGVjcnlwdGRhdGEudXJpXG4gICAgICB9O1xuXG4gICAgICAvLyBtYXhSZXRyeSBpcyAwIHNvIHRoYXQgaW5zdGVhZCBvZiByZXRyeWluZyB0aGUgc2FtZSBrZXkgb24gdGhlIHNhbWUgdmFyaWFudCBtdWx0aXBsZSB0aW1lcyxcbiAgICAgIC8vIGtleS1sb2FkZXIgd2lsbCB0cmlnZ2VyIGFuIGVycm9yIGFuZCByZWx5IG9uIHN0cmVhbS1jb250cm9sbGVyIHRvIGhhbmRsZSByZXRyeSBsb2dpYy5cbiAgICAgIC8vIHRoaXMgd2lsbCBhbHNvIGFsaWduIHJldHJ5IGxvZ2ljIHdpdGggZnJhZ21lbnQtbG9hZGVyXG4gICAgICBjb25zdCBsb2FkUG9saWN5ID0gY29uZmlnLmtleUxvYWRQb2xpY3kuZGVmYXVsdDtcbiAgICAgIGNvbnN0IGxvYWRlckNvbmZpZyA9IHtcbiAgICAgICAgbG9hZFBvbGljeSxcbiAgICAgICAgdGltZW91dDogbG9hZFBvbGljeS5tYXhMb2FkVGltZU1zLFxuICAgICAgICBtYXhSZXRyeTogMCxcbiAgICAgICAgcmV0cnlEZWxheTogMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheTogMFxuICAgICAgfTtcbiAgICAgIGNvbnN0IGxvYWRlckNhbGxiYWNrcyA9IHtcbiAgICAgICAgb25TdWNjZXNzOiAocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICBrZXlJbmZvLFxuICAgICAgICAgICAgdXJsOiB1cmlcbiAgICAgICAgICB9ID0gY29udGV4dDtcbiAgICAgICAgICBpZiAoIWZyYWcuZGVjcnlwdGRhdGEgfHwga2V5SW5mbyAhPT0gdGhpcy5rZXlVcmlUb0tleUluZm9bdXJpXSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdCh0aGlzLmNyZWF0ZUtleUxvYWRFcnJvcihmcmFnLCBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1IsIG5ldyBFcnJvcignYWZ0ZXIga2V5IGxvYWQsIGRlY3J5cHRkYXRhIHVuc2V0IG9yIGNoYW5nZWQnKSwgbmV0d29ya0RldGFpbHMpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAga2V5SW5mby5kZWNyeXB0ZGF0YS5rZXkgPSBmcmFnLmRlY3J5cHRkYXRhLmtleSA9IG5ldyBVaW50OEFycmF5KHJlc3BvbnNlLmRhdGEpO1xuXG4gICAgICAgICAgLy8gZGV0YWNoIGZyYWdtZW50IGtleSBsb2FkZXIgb24gbG9hZCBzdWNjZXNzXG4gICAgICAgICAgZnJhZy5rZXlMb2FkZXIgPSBudWxsO1xuICAgICAgICAgIGtleUluZm8ubG9hZGVyID0gbnVsbDtcbiAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICBrZXlJbmZvXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRXJyb3I6IChyZXNwb25zZSwgY29udGV4dCwgbmV0d29ya0RldGFpbHMsIHN0YXRzKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXNldExvYWRlcihjb250ZXh0KTtcbiAgICAgICAgICByZWplY3QodGhpcy5jcmVhdGVLZXlMb2FkRXJyb3IoZnJhZywgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SLCBuZXcgRXJyb3IoYEhUVFAgRXJyb3IgJHtyZXNwb25zZS5jb2RlfSBsb2FkaW5nIGtleSAke3Jlc3BvbnNlLnRleHR9YCksIG5ldHdvcmtEZXRhaWxzLCBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgICB1cmw6IGxvYWRlckNvbnRleHQudXJsLFxuICAgICAgICAgICAgZGF0YTogdW5kZWZpbmVkXG4gICAgICAgICAgfSwgcmVzcG9uc2UpKSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uVGltZW91dDogKHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoY29udGV4dCk7XG4gICAgICAgICAgcmVqZWN0KHRoaXMuY3JlYXRlS2V5TG9hZEVycm9yKGZyYWcsIEVycm9yRGV0YWlscy5LRVlfTE9BRF9USU1FT1VULCBuZXcgRXJyb3IoJ2tleSBsb2FkaW5nIHRpbWVkIG91dCcpLCBuZXR3b3JrRGV0YWlscykpO1xuICAgICAgICB9LFxuICAgICAgICBvbkFib3J0OiAoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXNldExvYWRlcihjb250ZXh0KTtcbiAgICAgICAgICByZWplY3QodGhpcy5jcmVhdGVLZXlMb2FkRXJyb3IoZnJhZywgRXJyb3JEZXRhaWxzLklOVEVSTkFMX0FCT1JURUQsIG5ldyBFcnJvcigna2V5IGxvYWRpbmcgYWJvcnRlZCcpLCBuZXR3b3JrRGV0YWlscykpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAga2V5TG9hZGVyLmxvYWQobG9hZGVyQ29udGV4dCwgbG9hZGVyQ29uZmlnLCBsb2FkZXJDYWxsYmFja3MpO1xuICAgIH0pO1xuICB9XG4gIHJlc2V0TG9hZGVyKGNvbnRleHQpIHtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnLFxuICAgICAga2V5SW5mbyxcbiAgICAgIHVybDogdXJpXG4gICAgfSA9IGNvbnRleHQ7XG4gICAgY29uc3QgbG9hZGVyID0ga2V5SW5mby5sb2FkZXI7XG4gICAgaWYgKGZyYWcua2V5TG9hZGVyID09PSBsb2FkZXIpIHtcbiAgICAgIGZyYWcua2V5TG9hZGVyID0gbnVsbDtcbiAgICAgIGtleUluZm8ubG9hZGVyID0gbnVsbDtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMua2V5VXJpVG9LZXlJbmZvW3VyaV07XG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgbG9hZGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFwQ29udGV4dFRvTGV2ZWxUeXBlKGNvbnRleHQpIHtcbiAgY29uc3Qge1xuICAgIHR5cGVcbiAgfSA9IGNvbnRleHQ7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSzpcbiAgICAgIHJldHVybiBQbGF5bGlzdExldmVsVHlwZS5BVURJTztcbiAgICBjYXNlIFBsYXlsaXN0Q29udGV4dFR5cGUuU1VCVElUTEVfVFJBQ0s6XG4gICAgICByZXR1cm4gUGxheWxpc3RMZXZlbFR5cGUuU1VCVElUTEU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBQbGF5bGlzdExldmVsVHlwZS5NQUlOO1xuICB9XG59XG5mdW5jdGlvbiBnZXRSZXNwb25zZVVybChyZXNwb25zZSwgY29udGV4dCkge1xuICBsZXQgdXJsID0gcmVzcG9uc2UudXJsO1xuICAvLyByZXNwb25zZVVSTCBub3Qgc3VwcG9ydGVkIG9uIHNvbWUgYnJvd3NlcnMgKGl0IGlzIHVzZWQgdG8gZGV0ZWN0IFVSTCByZWRpcmVjdGlvbilcbiAgLy8gZGF0YS11cmkgbW9kZSBhbHNvIG5vdCBzdXBwb3J0ZWQgKGJ1dCBubyBuZWVkIHRvIGRldGVjdCByZWRpcmVjdGlvbilcbiAgaWYgKHVybCA9PT0gdW5kZWZpbmVkIHx8IHVybC5pbmRleE9mKCdkYXRhOicpID09PSAwKSB7XG4gICAgLy8gZmFsbGJhY2sgdG8gaW5pdGlhbCBVUkxcbiAgICB1cmwgPSBjb250ZXh0LnVybDtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuY2xhc3MgUGxheWxpc3RMb2FkZXIge1xuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmxvYWRlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMudmFyaWFibGVMaXN0ID0gbnVsbDtcbiAgICB0aGlzLm9uTWFuaWZlc3RMb2FkZWQgPSB0aGlzLmNoZWNrQXV0b3N0YXJ0TG9hZDtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24pIHt9XG4gIHN0b3BMb2FkKCkge1xuICAgIHRoaXMuZGVzdHJveUludGVybmFsTG9hZGVycygpO1xuICB9XG4gIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkFVRElPX1RSQUNLX0xPQURJTkcsIHRoaXMub25BdWRpb1RyYWNrTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5TVUJUSVRMRV9UUkFDS19MT0FESU5HLCB0aGlzLm9uU3VidGl0bGVUcmFja0xvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxTX1VQREFURUQsIHRoaXMub25MZXZlbHNVcGRhdGVkLCB0aGlzKTtcbiAgfVxuICB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX0xPQURJTkcsIHRoaXMub25MZXZlbExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkFVRElPX1RSQUNLX0xPQURJTkcsIHRoaXMub25BdWRpb1RyYWNrTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuU1VCVElUTEVfVFJBQ0tfTE9BRElORywgdGhpcy5vblN1YnRpdGxlVHJhY2tMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTFNfVVBEQVRFRCwgdGhpcy5vbkxldmVsc1VwZGF0ZWQsIHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZGVmYXVsdHMgb3IgY29uZmlndXJlZCBsb2FkZXItdHlwZSBvdmVybG9hZHMgKHBMb2FkZXIgYW5kIGxvYWRlciBjb25maWcgcGFyYW1zKVxuICAgKi9cbiAgY3JlYXRlSW50ZXJuYWxMb2FkZXIoY29udGV4dCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcbiAgICBjb25zdCBQTG9hZGVyID0gY29uZmlnLnBMb2FkZXI7XG4gICAgY29uc3QgTG9hZGVyID0gY29uZmlnLmxvYWRlcjtcbiAgICBjb25zdCBJbnRlcm5hbExvYWRlciA9IFBMb2FkZXIgfHwgTG9hZGVyO1xuICAgIGNvbnN0IGxvYWRlciA9IG5ldyBJbnRlcm5hbExvYWRlcihjb25maWcpO1xuICAgIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdID0gbG9hZGVyO1xuICAgIHJldHVybiBsb2FkZXI7XG4gIH1cbiAgZ2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dCkge1xuICAgIHJldHVybiB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXTtcbiAgfVxuICByZXNldEludGVybmFsTG9hZGVyKGNvbnRleHRUeXBlKSB7XG4gICAgaWYgKHRoaXMubG9hZGVyc1tjb250ZXh0VHlwZV0pIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmxvYWRlcnNbY29udGV4dFR5cGVdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsIGBkZXN0cm95YCBvbiBhbGwgaW50ZXJuYWwgbG9hZGVyIGluc3RhbmNlcyBtYXBwZWQgKG9uZSBwZXIgY29udGV4dCB0eXBlKVxuICAgKi9cbiAgZGVzdHJveUludGVybmFsTG9hZGVycygpIHtcbiAgICBmb3IgKGNvbnN0IGNvbnRleHRUeXBlIGluIHRoaXMubG9hZGVycykge1xuICAgICAgY29uc3QgbG9hZGVyID0gdGhpcy5sb2FkZXJzW2NvbnRleHRUeXBlXTtcbiAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgbG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVzZXRJbnRlcm5hbExvYWRlcihjb250ZXh0VHlwZSk7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy52YXJpYWJsZUxpc3QgPSBudWxsO1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHRoaXMuZGVzdHJveUludGVybmFsTG9hZGVycygpO1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgdXJsXG4gICAgfSA9IGRhdGE7XG4gICAgdGhpcy52YXJpYWJsZUxpc3QgPSBudWxsO1xuICAgIHRoaXMubG9hZCh7XG4gICAgICBpZDogbnVsbCxcbiAgICAgIGxldmVsOiAwLFxuICAgICAgcmVzcG9uc2VUeXBlOiAndGV4dCcsXG4gICAgICB0eXBlOiBQbGF5bGlzdENvbnRleHRUeXBlLk1BTklGRVNULFxuICAgICAgdXJsLFxuICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzOiBudWxsLFxuICAgICAgbGV2ZWxPclRyYWNrOiBudWxsXG4gICAgfSk7XG4gIH1cbiAgb25MZXZlbExvYWRpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIGxldmVsLFxuICAgICAgcGF0aHdheUlkLFxuICAgICAgdXJsLFxuICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzLFxuICAgICAgbGV2ZWxJbmZvXG4gICAgfSA9IGRhdGE7XG4gICAgdGhpcy5sb2FkKHtcbiAgICAgIGlkLFxuICAgICAgbGV2ZWwsXG4gICAgICBwYXRod2F5SWQsXG4gICAgICByZXNwb25zZVR5cGU6ICd0ZXh0JyxcbiAgICAgIHR5cGU6IFBsYXlsaXN0Q29udGV4dFR5cGUuTEVWRUwsXG4gICAgICB1cmwsXG4gICAgICBkZWxpdmVyeURpcmVjdGl2ZXMsXG4gICAgICBsZXZlbE9yVHJhY2s6IGxldmVsSW5mb1xuICAgIH0pO1xuICB9XG4gIG9uQXVkaW9UcmFja0xvYWRpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIGdyb3VwSWQsXG4gICAgICB1cmwsXG4gICAgICBkZWxpdmVyeURpcmVjdGl2ZXMsXG4gICAgICB0cmFja1xuICAgIH0gPSBkYXRhO1xuICAgIHRoaXMubG9hZCh7XG4gICAgICBpZCxcbiAgICAgIGdyb3VwSWQsXG4gICAgICBsZXZlbDogbnVsbCxcbiAgICAgIHJlc3BvbnNlVHlwZTogJ3RleHQnLFxuICAgICAgdHlwZTogUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSyxcbiAgICAgIHVybCxcbiAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlcyxcbiAgICAgIGxldmVsT3JUcmFjazogdHJhY2tcbiAgICB9KTtcbiAgfVxuICBvblN1YnRpdGxlVHJhY2tMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgaWQsXG4gICAgICBncm91cElkLFxuICAgICAgdXJsLFxuICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzLFxuICAgICAgdHJhY2tcbiAgICB9ID0gZGF0YTtcbiAgICB0aGlzLmxvYWQoe1xuICAgICAgaWQsXG4gICAgICBncm91cElkLFxuICAgICAgbGV2ZWw6IG51bGwsXG4gICAgICByZXNwb25zZVR5cGU6ICd0ZXh0JyxcbiAgICAgIHR5cGU6IFBsYXlsaXN0Q29udGV4dFR5cGUuU1VCVElUTEVfVFJBQ0ssXG4gICAgICB1cmwsXG4gICAgICBkZWxpdmVyeURpcmVjdGl2ZXMsXG4gICAgICBsZXZlbE9yVHJhY2s6IHRyYWNrXG4gICAgfSk7XG4gIH1cbiAgb25MZXZlbHNVcGRhdGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgLy8gYWJvcnQgYW5kIGRlbGV0ZSBsb2FkZXIgb2YgcmVtb3ZlZCBsZXZlbHNcbiAgICBjb25zdCBsb2FkZXIgPSB0aGlzLmxvYWRlcnNbUGxheWxpc3RDb250ZXh0VHlwZS5MRVZFTF07XG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgY29uc3QgY29udGV4dCA9IGxvYWRlci5jb250ZXh0O1xuICAgICAgaWYgKGNvbnRleHQgJiYgIWRhdGEubGV2ZWxzLnNvbWUobHZsID0+IGx2bCA9PT0gY29udGV4dC5sZXZlbE9yVHJhY2spKSB7XG4gICAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgICBkZWxldGUgdGhpcy5sb2FkZXJzW1BsYXlsaXN0Q29udGV4dFR5cGUuTEVWRUxdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBsb2FkKGNvbnRleHQpIHtcbiAgICB2YXIgX2NvbnRleHQkZGVsaXZlcnlEaXJlO1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcblxuICAgIC8vIGxvZ2dlci5kZWJ1ZyhgW3BsYXlsaXN0LWxvYWRlcl06IExvYWRpbmcgcGxheWxpc3Qgb2YgdHlwZSAke2NvbnRleHQudHlwZX0sIGxldmVsOiAke2NvbnRleHQubGV2ZWx9LCBpZDogJHtjb250ZXh0LmlkfWApO1xuXG4gICAgLy8gQ2hlY2sgaWYgYSBsb2FkZXIgZm9yIHRoaXMgY29udGV4dCBhbHJlYWR5IGV4aXN0c1xuICAgIGxldCBsb2FkZXIgPSB0aGlzLmdldEludGVybmFsTG9hZGVyKGNvbnRleHQpO1xuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGNvbnN0IGxvZ2dlciA9IHRoaXMuaGxzLmxvZ2dlcjtcbiAgICAgIGNvbnN0IGxvYWRlckNvbnRleHQgPSBsb2FkZXIuY29udGV4dDtcbiAgICAgIGlmIChsb2FkZXJDb250ZXh0ICYmIGxvYWRlckNvbnRleHQubGV2ZWxPclRyYWNrID09PSBjb250ZXh0LmxldmVsT3JUcmFjayAmJiAobG9hZGVyQ29udGV4dC51cmwgPT09IGNvbnRleHQudXJsIHx8IGxvYWRlckNvbnRleHQuZGVsaXZlcnlEaXJlY3RpdmVzICYmICFjb250ZXh0LmRlbGl2ZXJ5RGlyZWN0aXZlcykpIHtcbiAgICAgICAgLy8gc2FtZSBVUkwgY2FuJ3Qgb3ZlcmxhcCwgb3Igd2FpdCBmb3IgYmxvY2tpbmcgcmVxdWVzdFxuICAgICAgICBpZiAobG9hZGVyQ29udGV4dC51cmwgPT09IGNvbnRleHQudXJsKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgW3BsYXlsaXN0LWxvYWRlcl06IGlnbm9yZSAke2NvbnRleHQudXJsfSBvbmdvaW5nIHJlcXVlc3RgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dnZXIubG9nKGBbcGxheWxpc3QtbG9hZGVyXTogaWdub3JlICR7Y29udGV4dC51cmx9IGluIGZhdm9yIG9mICR7bG9hZGVyQ29udGV4dC51cmx9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbG9nZ2VyLmxvZyhgW3BsYXlsaXN0LWxvYWRlcl06IGFib3J0aW5nIHByZXZpb3VzIGxvYWRlciBmb3IgdHlwZTogJHtjb250ZXh0LnR5cGV9YCk7XG4gICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBkaWZmZXJlbnQgY29uZmlncyBmb3IgcmV0cmllcyBkZXBlbmRpbmcgb25cbiAgICAvLyBjb250ZXh0IChtYW5pZmVzdCwgbGV2ZWwsIGF1ZGlvL3N1YnMgcGxheWxpc3QpXG4gICAgbGV0IGxvYWRQb2xpY3k7XG4gICAgaWYgKGNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5NQU5JRkVTVCkge1xuICAgICAgbG9hZFBvbGljeSA9IGNvbmZpZy5tYW5pZmVzdExvYWRQb2xpY3kuZGVmYXVsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9hZFBvbGljeSA9IF9leHRlbmRzKHt9LCBjb25maWcucGxheWxpc3RMb2FkUG9saWN5LmRlZmF1bHQsIHtcbiAgICAgICAgdGltZW91dFJldHJ5OiBudWxsLFxuICAgICAgICBlcnJvclJldHJ5OiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gICAgbG9hZGVyID0gdGhpcy5jcmVhdGVJbnRlcm5hbExvYWRlcihjb250ZXh0KTtcblxuICAgIC8vIE92ZXJyaWRlIGxldmVsL3RyYWNrIHRpbWVvdXQgZm9yIExMLUhMUyByZXF1ZXN0c1xuICAgIC8vICh0aGUgZGVmYXVsdCBvZiAxMDAwMG1zIGlzIGNvdW50ZXIgcHJvZHVjdGl2ZSB0byBibG9ja2luZyBwbGF5bGlzdCByZWxvYWQgcmVxdWVzdHMpXG4gICAgaWYgKGlzRmluaXRlTnVtYmVyKChfY29udGV4dCRkZWxpdmVyeURpcmUgPSBjb250ZXh0LmRlbGl2ZXJ5RGlyZWN0aXZlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jb250ZXh0JGRlbGl2ZXJ5RGlyZS5wYXJ0KSkge1xuICAgICAgbGV0IGxldmVsRGV0YWlscztcbiAgICAgIGlmIChjb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuTEVWRUwgJiYgY29udGV4dC5sZXZlbCAhPT0gbnVsbCkge1xuICAgICAgICBsZXZlbERldGFpbHMgPSB0aGlzLmhscy5sZXZlbHNbY29udGV4dC5sZXZlbF0uZGV0YWlscztcbiAgICAgIH0gZWxzZSBpZiAoY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLkFVRElPX1RSQUNLICYmIGNvbnRleHQuaWQgIT09IG51bGwpIHtcbiAgICAgICAgbGV2ZWxEZXRhaWxzID0gdGhpcy5obHMuYXVkaW9UcmFja3NbY29udGV4dC5pZF0uZGV0YWlscztcbiAgICAgIH0gZWxzZSBpZiAoY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLICYmIGNvbnRleHQuaWQgIT09IG51bGwpIHtcbiAgICAgICAgbGV2ZWxEZXRhaWxzID0gdGhpcy5obHMuc3VidGl0bGVUcmFja3NbY29udGV4dC5pZF0uZGV0YWlscztcbiAgICAgIH1cbiAgICAgIGlmIChsZXZlbERldGFpbHMpIHtcbiAgICAgICAgY29uc3QgcGFydFRhcmdldCA9IGxldmVsRGV0YWlscy5wYXJ0VGFyZ2V0O1xuICAgICAgICBjb25zdCB0YXJnZXREdXJhdGlvbiA9IGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbjtcbiAgICAgICAgaWYgKHBhcnRUYXJnZXQgJiYgdGFyZ2V0RHVyYXRpb24pIHtcbiAgICAgICAgICBjb25zdCBtYXhMb3dMYXRlbmN5UGxheWxpc3RSZWZyZXNoID0gTWF0aC5tYXgocGFydFRhcmdldCAqIDMsIHRhcmdldER1cmF0aW9uICogMC44KSAqIDEwMDA7XG4gICAgICAgICAgbG9hZFBvbGljeSA9IF9leHRlbmRzKHt9LCBsb2FkUG9saWN5LCB7XG4gICAgICAgICAgICBtYXhUaW1lVG9GaXJzdEJ5dGVNczogTWF0aC5taW4obWF4TG93TGF0ZW5jeVBsYXlsaXN0UmVmcmVzaCwgbG9hZFBvbGljeS5tYXhUaW1lVG9GaXJzdEJ5dGVNcyksXG4gICAgICAgICAgICBtYXhMb2FkVGltZU1zOiBNYXRoLm1pbihtYXhMb3dMYXRlbmN5UGxheWxpc3RSZWZyZXNoLCBsb2FkUG9saWN5Lm1heFRpbWVUb0ZpcnN0Qnl0ZU1zKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxlZ2FjeVJldHJ5Q29tcGF0aWJpbGl0eSA9IGxvYWRQb2xpY3kuZXJyb3JSZXRyeSB8fCBsb2FkUG9saWN5LnRpbWVvdXRSZXRyeSB8fCB7fTtcbiAgICBjb25zdCBsb2FkZXJDb25maWcgPSB7XG4gICAgICBsb2FkUG9saWN5LFxuICAgICAgdGltZW91dDogbG9hZFBvbGljeS5tYXhMb2FkVGltZU1zLFxuICAgICAgbWF4UmV0cnk6IGxlZ2FjeVJldHJ5Q29tcGF0aWJpbGl0eS5tYXhOdW1SZXRyeSB8fCAwLFxuICAgICAgcmV0cnlEZWxheTogbGVnYWN5UmV0cnlDb21wYXRpYmlsaXR5LnJldHJ5RGVsYXlNcyB8fCAwLFxuICAgICAgbWF4UmV0cnlEZWxheTogbGVnYWN5UmV0cnlDb21wYXRpYmlsaXR5Lm1heFJldHJ5RGVsYXlNcyB8fCAwXG4gICAgfTtcbiAgICBjb25zdCBsb2FkZXJDYWxsYmFja3MgPSB7XG4gICAgICBvblN1Y2Nlc3M6IChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgIGNvbnN0IGxvYWRlciA9IHRoaXMuZ2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dCk7XG4gICAgICAgIHRoaXMucmVzZXRJbnRlcm5hbExvYWRlcihjb250ZXh0LnR5cGUpO1xuICAgICAgICBjb25zdCBzdHJpbmcgPSByZXNwb25zZS5kYXRhO1xuXG4gICAgICAgIC8vIFZhbGlkYXRlIGlmIGl0IGlzIGFuIE0zVTggYXQgYWxsXG4gICAgICAgIGlmIChzdHJpbmcuaW5kZXhPZignI0VYVE0zVScpICE9PSAwKSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVNYW5pZmVzdFBhcnNpbmdFcnJvcihyZXNwb25zZSwgY29udGV4dCwgbmV3IEVycm9yKCdubyBFWFRNM1UgZGVsaW1pdGVyJyksIG5ldHdvcmtEZXRhaWxzIHx8IG51bGwsIHN0YXRzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3RhdHMucGFyc2luZy5zdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBpZiAoTTNVOFBhcnNlci5pc01lZGlhUGxheWxpc3Qoc3RyaW5nKSB8fCBjb250ZXh0LnR5cGUgIT09IFBsYXlsaXN0Q29udGV4dFR5cGUuTUFOSUZFU1QpIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZVRyYWNrT3JMZXZlbFBsYXlsaXN0KHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMgfHwgbnVsbCwgbG9hZGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZU1hc3RlclBsYXlsaXN0KHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25FcnJvcjogKHJlc3BvbnNlLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscywgc3RhdHMpID0+IHtcbiAgICAgICAgdGhpcy5oYW5kbGVOZXR3b3JrRXJyb3IoY29udGV4dCwgbmV0d29ya0RldGFpbHMsIGZhbHNlLCByZXNwb25zZSwgc3RhdHMpO1xuICAgICAgfSxcbiAgICAgIG9uVGltZW91dDogKHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICB0aGlzLmhhbmRsZU5ldHdvcmtFcnJvcihjb250ZXh0LCBuZXR3b3JrRGV0YWlscywgdHJ1ZSwgdW5kZWZpbmVkLCBzdGF0cyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGxvZ2dlci5kZWJ1ZyhgW3BsYXlsaXN0LWxvYWRlcl06IENhbGxpbmcgaW50ZXJuYWwgbG9hZGVyIGRlbGVnYXRlIGZvciBVUkw6ICR7Y29udGV4dC51cmx9YCk7XG5cbiAgICBsb2FkZXIubG9hZChjb250ZXh0LCBsb2FkZXJDb25maWcsIGxvYWRlckNhbGxiYWNrcyk7XG4gIH1cbiAgY2hlY2tBdXRvc3RhcnRMb2FkKCkge1xuICAgIGlmICghdGhpcy5obHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY29uZmlnOiB7XG4gICAgICAgIGF1dG9TdGFydExvYWQsXG4gICAgICAgIHN0YXJ0UG9zaXRpb25cbiAgICAgIH0sXG4gICAgICBmb3JjZVN0YXJ0TG9hZFxuICAgIH0gPSB0aGlzLmhscztcbiAgICBpZiAoYXV0b1N0YXJ0TG9hZCB8fCBmb3JjZVN0YXJ0TG9hZCkge1xuICAgICAgdGhpcy5obHMubG9nZ2VyLmxvZyhgJHthdXRvU3RhcnRMb2FkID8gJ2F1dG8nIDogJ2ZvcmNlJ30gc3RhcnRMb2FkIHdpdGggY29uZmlndXJlZCBzdGFydFBvc2l0aW9uICR7c3RhcnRQb3NpdGlvbn1gKTtcbiAgICAgIHRoaXMuaGxzLnN0YXJ0TG9hZChzdGFydFBvc2l0aW9uKTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlTWFzdGVyUGxheWxpc3QocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGNvbnN0IHN0cmluZyA9IHJlc3BvbnNlLmRhdGE7XG4gICAgY29uc3QgdXJsID0gZ2V0UmVzcG9uc2VVcmwocmVzcG9uc2UsIGNvbnRleHQpO1xuICAgIGNvbnN0IHBhcnNlZFJlc3VsdCA9IE0zVThQYXJzZXIucGFyc2VNYXN0ZXJQbGF5bGlzdChzdHJpbmcsIHVybCk7XG4gICAgaWYgKHBhcnNlZFJlc3VsdC5wbGF5bGlzdFBhcnNpbmdFcnJvcikge1xuICAgICAgdGhpcy5oYW5kbGVNYW5pZmVzdFBhcnNpbmdFcnJvcihyZXNwb25zZSwgY29udGV4dCwgcGFyc2VkUmVzdWx0LnBsYXlsaXN0UGFyc2luZ0Vycm9yLCBuZXR3b3JrRGV0YWlscywgc3RhdHMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjb250ZW50U3RlZXJpbmcsXG4gICAgICBsZXZlbHMsXG4gICAgICBzZXNzaW9uRGF0YSxcbiAgICAgIHNlc3Npb25LZXlzLFxuICAgICAgc3RhcnRUaW1lT2Zmc2V0LFxuICAgICAgdmFyaWFibGVMaXN0XG4gICAgfSA9IHBhcnNlZFJlc3VsdDtcbiAgICB0aGlzLnZhcmlhYmxlTGlzdCA9IHZhcmlhYmxlTGlzdDtcbiAgICBjb25zdCB7XG4gICAgICBBVURJTzogYXVkaW9UcmFja3MgPSBbXSxcbiAgICAgIFNVQlRJVExFUzogc3VidGl0bGVzLFxuICAgICAgJ0NMT1NFRC1DQVBUSU9OUyc6IGNhcHRpb25zXG4gICAgfSA9IE0zVThQYXJzZXIucGFyc2VNYXN0ZXJQbGF5bGlzdE1lZGlhKHN0cmluZywgdXJsLCBwYXJzZWRSZXN1bHQpO1xuICAgIGlmIChhdWRpb1RyYWNrcy5sZW5ndGgpIHtcbiAgICAgIC8vIGNoZWNrIGlmIHdlIGhhdmUgZm91bmQgYW4gYXVkaW8gdHJhY2sgZW1iZWRkZWQgaW4gbWFpbiBwbGF5bGlzdCAoYXVkaW8gdHJhY2sgd2l0aG91dCBVUkkgYXR0cmlidXRlKVxuICAgICAgY29uc3QgZW1iZWRkZWRBdWRpb0ZvdW5kID0gYXVkaW9UcmFja3Muc29tZShhdWRpb1RyYWNrID0+ICFhdWRpb1RyYWNrLnVybCk7XG5cbiAgICAgIC8vIGlmIG5vIGVtYmVkZGVkIGF1ZGlvIHRyYWNrIGRlZmluZWQsIGJ1dCBhdWRpbyBjb2RlYyBzaWduYWxlZCBpbiBxdWFsaXR5IGxldmVsLFxuICAgICAgLy8gd2UgbmVlZCB0byBzaWduYWwgdGhpcyBtYWluIGF1ZGlvIHRyYWNrIHRoaXMgY291bGQgaGFwcGVuIHdpdGggcGxheWxpc3RzIHdpdGhcbiAgICAgIC8vIGFsdCBhdWRpbyByZW5kaXRpb24gaW4gd2hpY2ggcXVhbGl0eSBsZXZlbHMgKG1haW4pXG4gICAgICAvLyBjb250YWlucyBib3RoIGF1ZGlvK3ZpZGVvLiBidXQgd2l0aCBtaXhlZCBhdWRpbyB0cmFjayBub3Qgc2lnbmFsZWRcbiAgICAgIGlmICghZW1iZWRkZWRBdWRpb0ZvdW5kICYmIGxldmVsc1swXS5hdWRpb0NvZGVjICYmICFsZXZlbHNbMF0uYXR0cnMuQVVESU8pIHtcbiAgICAgICAgdGhpcy5obHMubG9nZ2VyLmxvZygnW3BsYXlsaXN0LWxvYWRlcl06IGF1ZGlvIGNvZGVjIHNpZ25hbGVkIGluIHF1YWxpdHkgbGV2ZWwsIGJ1dCBubyBlbWJlZGRlZCBhdWRpbyB0cmFjayBzaWduYWxlZCwgY3JlYXRlIG9uZScpO1xuICAgICAgICBhdWRpb1RyYWNrcy51bnNoaWZ0KHtcbiAgICAgICAgICB0eXBlOiAnbWFpbicsXG4gICAgICAgICAgbmFtZTogJ21haW4nLFxuICAgICAgICAgIGdyb3VwSWQ6ICdtYWluJyxcbiAgICAgICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgICBhdXRvc2VsZWN0OiBmYWxzZSxcbiAgICAgICAgICBmb3JjZWQ6IGZhbHNlLFxuICAgICAgICAgIGlkOiAtMSxcbiAgICAgICAgICBhdHRyczogbmV3IEF0dHJMaXN0KHt9KSxcbiAgICAgICAgICBiaXRyYXRlOiAwLFxuICAgICAgICAgIHVybDogJydcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGhscy50cmlnZ2VyKEV2ZW50cy5NQU5JRkVTVF9MT0FERUQsIHtcbiAgICAgIGxldmVscyxcbiAgICAgIGF1ZGlvVHJhY2tzLFxuICAgICAgc3VidGl0bGVzLFxuICAgICAgY2FwdGlvbnMsXG4gICAgICBjb250ZW50U3RlZXJpbmcsXG4gICAgICB1cmwsXG4gICAgICBzdGF0cyxcbiAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgc2Vzc2lvbkRhdGEsXG4gICAgICBzZXNzaW9uS2V5cyxcbiAgICAgIHN0YXJ0VGltZU9mZnNldCxcbiAgICAgIHZhcmlhYmxlTGlzdFxuICAgIH0pO1xuICB9XG4gIGhhbmRsZVRyYWNrT3JMZXZlbFBsYXlsaXN0KHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMsIGxvYWRlcikge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGNvbnN0IHtcbiAgICAgIGlkLFxuICAgICAgbGV2ZWwsXG4gICAgICB0eXBlXG4gICAgfSA9IGNvbnRleHQ7XG4gICAgY29uc3QgdXJsID0gZ2V0UmVzcG9uc2VVcmwocmVzcG9uc2UsIGNvbnRleHQpO1xuICAgIGNvbnN0IGxldmVsSWQgPSBpc0Zpbml0ZU51bWJlcihsZXZlbCkgPyBsZXZlbCA6IGlzRmluaXRlTnVtYmVyKGlkKSA/IGlkIDogMDtcbiAgICBjb25zdCBsZXZlbFR5cGUgPSBtYXBDb250ZXh0VG9MZXZlbFR5cGUoY29udGV4dCk7XG4gICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gTTNVOFBhcnNlci5wYXJzZUxldmVsUGxheWxpc3QocmVzcG9uc2UuZGF0YSwgdXJsLCBsZXZlbElkLCBsZXZlbFR5cGUsIDAsIHRoaXMudmFyaWFibGVMaXN0KTtcblxuICAgIC8vIFdlIGhhdmUgZG9uZSBvdXIgZmlyc3QgcmVxdWVzdCAoTWFuaWZlc3QtdHlwZSkgYW5kIHJlY2VpdmVcbiAgICAvLyBub3QgYSBtYXN0ZXIgcGxheWxpc3QgYnV0IGEgY2h1bmstbGlzdCAodHJhY2svbGV2ZWwpXG4gICAgLy8gV2UgZmlyZSB0aGUgbWFuaWZlc3QtbG9hZGVkIGV2ZW50IGFueXdheSB3aXRoIHRoZSBwYXJzZWQgbGV2ZWwtZGV0YWlsc1xuICAgIC8vIGJ5IGNyZWF0aW5nIGEgc2luZ2xlLWxldmVsIHN0cnVjdHVyZSBmb3IgaXQuXG4gICAgaWYgKHR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuTUFOSUZFU1QpIHtcbiAgICAgIGNvbnN0IHNpbmdsZUxldmVsID0ge1xuICAgICAgICBhdHRyczogbmV3IEF0dHJMaXN0KHt9KSxcbiAgICAgICAgYml0cmF0ZTogMCxcbiAgICAgICAgZGV0YWlsczogbGV2ZWxEZXRhaWxzLFxuICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgdXJsXG4gICAgICB9O1xuICAgICAgbGV2ZWxEZXRhaWxzLnJlcXVlc3RTY2hlZHVsZWQgPSBzdGF0cy5sb2FkaW5nLnN0YXJ0ICsgY29tcHV0ZVJlbG9hZEludGVydmFsKGxldmVsRGV0YWlscywgMCk7XG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB7XG4gICAgICAgIGxldmVsczogW3NpbmdsZUxldmVsXSxcbiAgICAgICAgYXVkaW9UcmFja3M6IFtdLFxuICAgICAgICB1cmwsXG4gICAgICAgIHN0YXRzLFxuICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgc2Vzc2lvbkRhdGE6IG51bGwsXG4gICAgICAgIHNlc3Npb25LZXlzOiBudWxsLFxuICAgICAgICBjb250ZW50U3RlZXJpbmc6IG51bGwsXG4gICAgICAgIHN0YXJ0VGltZU9mZnNldDogbnVsbCxcbiAgICAgICAgdmFyaWFibGVMaXN0OiBudWxsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBzYXZlIHBhcnNpbmcgdGltZVxuICAgIHN0YXRzLnBhcnNpbmcuZW5kID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICAvLyBleHRlbmQgdGhlIGNvbnRleHQgd2l0aCB0aGUgbmV3IGxldmVsRGV0YWlscyBwcm9wZXJ0eVxuICAgIGNvbnRleHQubGV2ZWxEZXRhaWxzID0gbGV2ZWxEZXRhaWxzO1xuICAgIHRoaXMuaGFuZGxlUGxheWxpc3RMb2FkZWQobGV2ZWxEZXRhaWxzLCByZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCBsb2FkZXIpO1xuICB9XG4gIGhhbmRsZU1hbmlmZXN0UGFyc2luZ0Vycm9yKHJlc3BvbnNlLCBjb250ZXh0LCBlcnJvciwgbmV0d29ya0RldGFpbHMsIHN0YXRzKSB7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5NQU5JRkVTVF9QQVJTSU5HX0VSUk9SLFxuICAgICAgZmF0YWw6IGNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5NQU5JRkVTVCxcbiAgICAgIHVybDogcmVzcG9uc2UudXJsLFxuICAgICAgZXJyOiBlcnJvcixcbiAgICAgIGVycm9yLFxuICAgICAgcmVhc29uOiBlcnJvci5tZXNzYWdlLFxuICAgICAgcmVzcG9uc2UsXG4gICAgICBjb250ZXh0LFxuICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICBzdGF0c1xuICAgIH0pO1xuICB9XG4gIGhhbmRsZU5ldHdvcmtFcnJvcihjb250ZXh0LCBuZXR3b3JrRGV0YWlscywgdGltZW91dCA9IGZhbHNlLCByZXNwb25zZSwgc3RhdHMpIHtcbiAgICBsZXQgbWVzc2FnZSA9IGBBIG5ldHdvcmsgJHt0aW1lb3V0ID8gJ3RpbWVvdXQnIDogJ2Vycm9yJyArIChyZXNwb25zZSA/ICcgKHN0YXR1cyAnICsgcmVzcG9uc2UuY29kZSArICcpJyA6ICcnKX0gb2NjdXJyZWQgd2hpbGUgbG9hZGluZyAke2NvbnRleHQudHlwZX1gO1xuICAgIGlmIChjb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuTEVWRUwpIHtcbiAgICAgIG1lc3NhZ2UgKz0gYDogJHtjb250ZXh0LmxldmVsfSBpZDogJHtjb250ZXh0LmlkfWA7XG4gICAgfSBlbHNlIGlmIChjb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0sgfHwgY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLKSB7XG4gICAgICBtZXNzYWdlICs9IGAgaWQ6ICR7Y29udGV4dC5pZH0gZ3JvdXAtaWQ6IFwiJHtjb250ZXh0Lmdyb3VwSWR9XCJgO1xuICAgIH1cbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB0aGlzLmhscy5sb2dnZXIud2FybihgW3BsYXlsaXN0LWxvYWRlcl06ICR7bWVzc2FnZX1gKTtcbiAgICBsZXQgZGV0YWlscyA9IEVycm9yRGV0YWlscy5VTktOT1dOO1xuICAgIGxldCBmYXRhbCA9IGZhbHNlO1xuICAgIGNvbnN0IGxvYWRlciA9IHRoaXMuZ2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dCk7XG4gICAgc3dpdGNoIChjb250ZXh0LnR5cGUpIHtcbiAgICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5NQU5JRkVTVDpcbiAgICAgICAgZGV0YWlscyA9IHRpbWVvdXQgPyBFcnJvckRldGFpbHMuTUFOSUZFU1RfTE9BRF9USU1FT1VUIDogRXJyb3JEZXRhaWxzLk1BTklGRVNUX0xPQURfRVJST1I7XG4gICAgICAgIGZhdGFsID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBsYXlsaXN0Q29udGV4dFR5cGUuTEVWRUw6XG4gICAgICAgIGRldGFpbHMgPSB0aW1lb3V0ID8gRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfVElNRU9VVCA6IEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX0VSUk9SO1xuICAgICAgICBmYXRhbCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSzpcbiAgICAgICAgZGV0YWlscyA9IHRpbWVvdXQgPyBFcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUIDogRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfRVJST1I7XG4gICAgICAgIGZhdGFsID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLOlxuICAgICAgICBkZXRhaWxzID0gdGltZW91dCA/IEVycm9yRGV0YWlscy5TVUJUSVRMRV9UUkFDS19MT0FEX1RJTUVPVVQgOiBFcnJvckRldGFpbHMuU1VCVElUTEVfTE9BRF9FUlJPUjtcbiAgICAgICAgZmF0YWwgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIHRoaXMucmVzZXRJbnRlcm5hbExvYWRlcihjb250ZXh0LnR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBlcnJvckRhdGEgPSB7XG4gICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICBkZXRhaWxzLFxuICAgICAgZmF0YWwsXG4gICAgICB1cmw6IGNvbnRleHQudXJsLFxuICAgICAgbG9hZGVyLFxuICAgICAgY29udGV4dCxcbiAgICAgIGVycm9yLFxuICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICBzdGF0c1xuICAgIH07XG4gICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICBjb25zdCB1cmwgPSAobmV0d29ya0RldGFpbHMgPT0gbnVsbCA/IHZvaWQgMCA6IG5ldHdvcmtEZXRhaWxzLnVybCkgfHwgY29udGV4dC51cmw7XG4gICAgICBlcnJvckRhdGEucmVzcG9uc2UgPSBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgIHVybCxcbiAgICAgICAgZGF0YTogdW5kZWZpbmVkXG4gICAgICB9LCByZXNwb25zZSk7XG4gICAgfVxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCBlcnJvckRhdGEpO1xuICB9XG4gIGhhbmRsZVBsYXlsaXN0TG9hZGVkKGxldmVsRGV0YWlscywgcmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscywgbG9hZGVyKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZSxcbiAgICAgIGxldmVsLFxuICAgICAgaWQsXG4gICAgICBncm91cElkLFxuICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzXG4gICAgfSA9IGNvbnRleHQ7XG4gICAgY29uc3QgdXJsID0gZ2V0UmVzcG9uc2VVcmwocmVzcG9uc2UsIGNvbnRleHQpO1xuICAgIGNvbnN0IHBhcmVudCA9IG1hcENvbnRleHRUb0xldmVsVHlwZShjb250ZXh0KTtcbiAgICBjb25zdCBsZXZlbEluZGV4ID0gdHlwZW9mIGNvbnRleHQubGV2ZWwgPT09ICdudW1iZXInICYmIHBhcmVudCA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTiA/IGxldmVsIDogdW5kZWZpbmVkO1xuICAgIGlmICghbGV2ZWxEZXRhaWxzLmZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IF9lcnJvciA9IGxldmVsRGV0YWlscy5wbGF5bGlzdFBhcnNpbmdFcnJvciA9IG5ldyBFcnJvcignTm8gU2VnbWVudHMgZm91bmQgaW4gUGxheWxpc3QnKTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5MRVZFTF9FTVBUWV9FUlJPUixcbiAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICB1cmwsXG4gICAgICAgIGVycm9yOiBfZXJyb3IsXG4gICAgICAgIHJlYXNvbjogX2Vycm9yLm1lc3NhZ2UsXG4gICAgICAgIHJlc3BvbnNlLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBsZXZlbDogbGV2ZWxJbmRleCxcbiAgICAgICAgcGFyZW50LFxuICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgc3RhdHNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbikge1xuICAgICAgbGV2ZWxEZXRhaWxzLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKCdNaXNzaW5nIFRhcmdldCBEdXJhdGlvbicpO1xuICAgIH1cbiAgICBjb25zdCBlcnJvciA9IGxldmVsRGV0YWlscy5wbGF5bGlzdFBhcnNpbmdFcnJvcjtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHRoaXMuaGxzLmxvZ2dlci53YXJuKGVycm9yKTtcbiAgICAgIGlmICghaGxzLmNvbmZpZy5pZ25vcmVQbGF5bGlzdFBhcnNpbmdFcnJvcnMpIHtcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5MRVZFTF9QQVJTSU5HX0VSUk9SLFxuICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgcmVhc29uOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgbGV2ZWw6IGxldmVsSW5kZXgsXG4gICAgICAgICAgcGFyZW50LFxuICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgIHN0YXRzXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXZlbERldGFpbHMucGxheWxpc3RQYXJzaW5nRXJyb3IgPSBudWxsO1xuICAgIH1cbiAgICBpZiAobGV2ZWxEZXRhaWxzLmxpdmUgJiYgbG9hZGVyKSB7XG4gICAgICBpZiAobG9hZGVyLmdldENhY2hlQWdlKSB7XG4gICAgICAgIGxldmVsRGV0YWlscy5hZ2VIZWFkZXIgPSBsb2FkZXIuZ2V0Q2FjaGVBZ2UoKSB8fCAwO1xuICAgICAgfVxuICAgICAgaWYgKCFsb2FkZXIuZ2V0Q2FjaGVBZ2UgfHwgaXNOYU4obGV2ZWxEZXRhaWxzLmFnZUhlYWRlcikpIHtcbiAgICAgICAgbGV2ZWxEZXRhaWxzLmFnZUhlYWRlciA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBQbGF5bGlzdENvbnRleHRUeXBlLk1BTklGRVNUOlxuICAgICAgY2FzZSBQbGF5bGlzdENvbnRleHRUeXBlLkxFVkVMOlxuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuTEVWRUxfTE9BREVELCB7XG4gICAgICAgICAgZGV0YWlsczogbGV2ZWxEZXRhaWxzLFxuICAgICAgICAgIGxldmVsSW5mbzogY29udGV4dC5sZXZlbE9yVHJhY2sgfHwgaGxzLmxldmVsc1swXSxcbiAgICAgICAgICBsZXZlbDogbGV2ZWxJbmRleCB8fCAwLFxuICAgICAgICAgIGlkOiBpZCB8fCAwLFxuICAgICAgICAgIHN0YXRzLFxuICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlcyxcbiAgICAgICAgICB3aXRob3V0TXVsdGlWYXJpYW50OiB0eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLk1BTklGRVNUXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSzpcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkFVRElPX1RSQUNLX0xPQURFRCwge1xuICAgICAgICAgIGRldGFpbHM6IGxldmVsRGV0YWlscyxcbiAgICAgICAgICB0cmFjazogY29udGV4dC5sZXZlbE9yVHJhY2ssXG4gICAgICAgICAgaWQ6IGlkIHx8IDAsXG4gICAgICAgICAgZ3JvdXBJZDogZ3JvdXBJZCB8fCAnJyxcbiAgICAgICAgICBzdGF0cyxcbiAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXNcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLOlxuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuU1VCVElUTEVfVFJBQ0tfTE9BREVELCB7XG4gICAgICAgICAgZGV0YWlsczogbGV2ZWxEZXRhaWxzLFxuICAgICAgICAgIHRyYWNrOiBjb250ZXh0LmxldmVsT3JUcmFjayxcbiAgICAgICAgICBpZDogaWQgfHwgMCxcbiAgICAgICAgICBncm91cElkOiBncm91cElkIHx8ICcnLFxuICAgICAgICAgIHN0YXRzLFxuICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlc1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVGhlIGBIbHNgIGNsYXNzIGlzIHRoZSBjb3JlIG9mIHRoZSBITFMuanMgbGlicmFyeSB1c2VkIHRvIGluc3RhbnRpYXRlIHBsYXllciBpbnN0YW5jZXMuXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIEhscyB7XG4gIC8qKlxuICAgKiBHZXQgdGhlIHZpZGVvLWRldi9obHMuanMgcGFja2FnZSB2ZXJzaW9uLlxuICAgKi9cbiAgc3RhdGljIGdldCB2ZXJzaW9uKCkge1xuICAgIHJldHVybiB2ZXJzaW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSByZXF1aXJlZCBNZWRpYVNvdXJjZSBFeHRlbnNpb25zIGFyZSBhdmFpbGFibGUuXG4gICAqL1xuICBzdGF0aWMgaXNNU0VTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIGlzTVNFU3VwcG9ydGVkKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgTWVkaWFTb3VyY2UgRXh0ZW5zaW9ucyBhcmUgYXZhaWxhYmxlIGFuZCBpc1R5cGVTdXBwb3J0ZWQgY2hlY2tzIHBhc3MgZm9yIGFueSBiYXNlbGluZSBjb2RlY3MuXG4gICAqL1xuICBzdGF0aWMgaXNTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIGlzU3VwcG9ydGVkKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBNZWRpYVNvdXJjZSBnbG9iYWwgdXNlZCBmb3IgTVNFIHBsYXliYWNrIChNYW5hZ2VkTWVkaWFTb3VyY2UsIE1lZGlhU291cmNlLCBvciBXZWJLaXRNZWRpYVNvdXJjZSkuXG4gICAqL1xuICBzdGF0aWMgZ2V0TWVkaWFTb3VyY2UoKSB7XG4gICAgcmV0dXJuIGdldE1lZGlhU291cmNlKCk7XG4gIH1cbiAgc3RhdGljIGdldCBFdmVudHMoKSB7XG4gICAgcmV0dXJuIEV2ZW50cztcbiAgfVxuICBzdGF0aWMgZ2V0IE1ldGFkYXRhU2NoZW1hKCkge1xuICAgIHJldHVybiBNZXRhZGF0YVNjaGVtYTtcbiAgfVxuICBzdGF0aWMgZ2V0IEVycm9yVHlwZXMoKSB7XG4gICAgcmV0dXJuIEVycm9yVHlwZXM7XG4gIH1cbiAgc3RhdGljIGdldCBFcnJvckRldGFpbHMoKSB7XG4gICAgcmV0dXJuIEVycm9yRGV0YWlscztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBhcHBsaWVkIHRvIG5ldyBpbnN0YW5jZXMuXG4gICAqL1xuICBzdGF0aWMgZ2V0IERlZmF1bHRDb25maWcoKSB7XG4gICAgaWYgKCFIbHMuZGVmYXVsdENvbmZpZykge1xuICAgICAgcmV0dXJuIGhsc0RlZmF1bHRDb25maWc7XG4gICAgfVxuICAgIHJldHVybiBIbHMuZGVmYXVsdENvbmZpZztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlIHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gYXBwbGllZCB0byBuZXcgaW5zdGFuY2VzLlxuICAgKi9cbiAgc3RhdGljIHNldCBEZWZhdWx0Q29uZmlnKGRlZmF1bHRDb25maWcpIHtcbiAgICBIbHMuZGVmYXVsdENvbmZpZyA9IGRlZmF1bHRDb25maWc7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBhbiBITFMgY2xpZW50IHRoYXQgY2FuIGF0dGFjaCB0byBleGFjdGx5IG9uZSBgSFRNTE1lZGlhRWxlbWVudGAuXG4gICAqIEBwYXJhbSB1c2VyQ29uZmlnIC0gQ29uZmlndXJhdGlvbiBvcHRpb25zIGFwcGxpZWQgb3ZlciBgSGxzLkRlZmF1bHRDb25maWdgXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih1c2VyQ29uZmlnID0ge30pIHtcbiAgICAvKipcbiAgICAgKiBUaGUgcnVudGltZSBjb25maWd1cmF0aW9uIHVzZWQgYnkgdGhlIHBsYXllci4gQXQgaW5zdGFudGlhdGlvbiB0aGlzIGlzIGNvbWJpbmF0aW9uIG9mIGBobHMudXNlckNvbmZpZ2AgbWVyZ2VkIG92ZXIgYEhscy5EZWZhdWx0Q29uZmlnYC5cbiAgICAgKi9cbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QgcHJvdmlkZWQgb24gcGxheWVyIGluc3RhbnRpYXRpb24uXG4gICAgICovXG4gICAgdGhpcy51c2VyQ29uZmlnID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIFRoZSBsb2dnZXIgZnVuY3Rpb25zIHVzZWQgYnkgdGhpcyBwbGF5ZXIgaW5zdGFuY2UsIGNvbmZpZ3VyZWQgb24gcGxheWVyIGluc3RhbnRpYXRpb24uXG4gICAgICovXG4gICAgdGhpcy5sb2dnZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jb3JlQ29tcG9uZW50cyA9IHZvaWQgMDtcbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycyA9IHZvaWQgMDtcbiAgICB0aGlzLl9lbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgPSAtMTtcbiAgICB0aGlzLl9tYXhIZGNwTGV2ZWwgPSBudWxsO1xuICAgIHRoaXMuYWJyQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLmJ1ZmZlckNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jYXBMZXZlbENvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5sYXRlbmN5Q29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5hdWRpb1N0cmVhbUNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5zdWJ0aXRpdGxlU3RyZWFtQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5pbnRlcnN0aXRpYWxzQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLmdhcENvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5lbWVDb250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuY21jZENvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5fbWVkaWEgPSBudWxsO1xuICAgIHRoaXMuX3VybCA9IG51bGw7XG4gICAgdGhpcy5fc2Vzc2lvbklkID0gdm9pZCAwO1xuICAgIHRoaXMudHJpZ2dlcmluZ0V4Y2VwdGlvbiA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICBjb25zdCBsb2dnZXIgPSB0aGlzLmxvZ2dlciA9IGVuYWJsZUxvZ3ModXNlckNvbmZpZy5kZWJ1ZyB8fCBmYWxzZSwgJ0hscyBpbnN0YW5jZScsIHVzZXJDb25maWcuYXNzZXRQbGF5ZXJJZCk7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWcgPSBtZXJnZUNvbmZpZyhIbHMuRGVmYXVsdENvbmZpZywgdXNlckNvbmZpZywgbG9nZ2VyKTtcbiAgICB0aGlzLnVzZXJDb25maWcgPSB1c2VyQ29uZmlnO1xuICAgIGlmIChjb25maWcucHJvZ3Jlc3NpdmUpIHtcbiAgICAgIGVuYWJsZVN0cmVhbWluZ01vZGUoY29uZmlnLCBsb2dnZXIpO1xuICAgIH1cblxuICAgIC8vIGNvcmUgY29udHJvbGxlcnMgYW5kIG5ldHdvcmsgbG9hZGVyc1xuICAgIGNvbnN0IHtcbiAgICAgIGFickNvbnRyb2xsZXI6IF9BYnJDb250cm9sbGVyLFxuICAgICAgYnVmZmVyQ29udHJvbGxlcjogX0J1ZmZlckNvbnRyb2xsZXIsXG4gICAgICBjYXBMZXZlbENvbnRyb2xsZXI6IF9DYXBMZXZlbENvbnRyb2xsZXIsXG4gICAgICBlcnJvckNvbnRyb2xsZXI6IF9FcnJvckNvbnRyb2xsZXIsXG4gICAgICBmcHNDb250cm9sbGVyOiBfRnBzQ29udHJvbGxlclxuICAgIH0gPSBjb25maWc7XG4gICAgY29uc3QgZXJyb3JDb250cm9sbGVyID0gbmV3IF9FcnJvckNvbnRyb2xsZXIodGhpcyk7XG4gICAgY29uc3QgYWJyQ29udHJvbGxlciA9IHRoaXMuYWJyQ29udHJvbGxlciA9IG5ldyBfQWJyQ29udHJvbGxlcih0aGlzKTtcbiAgICAvLyBGcmFnbWVudFRyYWNrZXIgbXVzdCBiZSBkZWZpbmVkIGJlZm9yZSBTdHJlYW1Db250cm9sbGVyIGJlY2F1c2UgdGhlIG9yZGVyIG9mIGV2ZW50IGhhbmRsaW5nIGlzIGltcG9ydGFudFxuICAgIGNvbnN0IGZyYWdtZW50VHJhY2tlciA9IG5ldyBGcmFnbWVudFRyYWNrZXIodGhpcyk7XG4gICAgY29uc3QgX0ludGVyc3RpdGlhbHNDb250cm9sbGVyID0gY29uZmlnLmludGVyc3RpdGlhbHNDb250cm9sbGVyO1xuICAgIGNvbnN0IGludGVyc3RpdGlhbHNDb250cm9sbGVyID0gX0ludGVyc3RpdGlhbHNDb250cm9sbGVyID8gdGhpcy5pbnRlcnN0aXRpYWxzQ29udHJvbGxlciA9IG5ldyBfSW50ZXJzdGl0aWFsc0NvbnRyb2xsZXIodGhpcywgSGxzKSA6IG51bGw7XG4gICAgY29uc3QgYnVmZmVyQ29udHJvbGxlciA9IHRoaXMuYnVmZmVyQ29udHJvbGxlciA9IG5ldyBfQnVmZmVyQ29udHJvbGxlcih0aGlzLCBmcmFnbWVudFRyYWNrZXIpO1xuICAgIGNvbnN0IGNhcExldmVsQ29udHJvbGxlciA9IHRoaXMuY2FwTGV2ZWxDb250cm9sbGVyID0gbmV3IF9DYXBMZXZlbENvbnRyb2xsZXIodGhpcyk7XG4gICAgY29uc3QgZnBzQ29udHJvbGxlciA9IG5ldyBfRnBzQ29udHJvbGxlcih0aGlzKTtcbiAgICBjb25zdCBwbGF5TGlzdExvYWRlciA9IG5ldyBQbGF5bGlzdExvYWRlcih0aGlzKTtcbiAgICBjb25zdCBfQ29udGVudFN0ZWVyaW5nQ29udHJvbGxlciA9IGNvbmZpZy5jb250ZW50U3RlZXJpbmdDb250cm9sbGVyO1xuICAgIC8vIEluc3RhbnRpYXRlIENvbmVudFN0ZWVyaW5nQ29udHJvbGxlciBiZWZvcmUgTGV2ZWxDb250cm9sbGVyIHRvIHJlY2VpdmUgTXVsdGl2YXJpYW50IFBsYXlsaXN0IGV2ZW50cyBmaXJzdFxuICAgIGNvbnN0IGNvbnRlbnRTdGVlcmluZyA9IF9Db250ZW50U3RlZXJpbmdDb250cm9sbGVyID8gbmV3IF9Db250ZW50U3RlZXJpbmdDb250cm9sbGVyKHRoaXMpIDogbnVsbDtcbiAgICBjb25zdCBsZXZlbENvbnRyb2xsZXIgPSB0aGlzLmxldmVsQ29udHJvbGxlciA9IG5ldyBMZXZlbENvbnRyb2xsZXIodGhpcywgY29udGVudFN0ZWVyaW5nKTtcbiAgICBjb25zdCBpZDNUcmFja0NvbnRyb2xsZXIgPSBuZXcgSUQzVHJhY2tDb250cm9sbGVyKHRoaXMpO1xuICAgIGNvbnN0IGtleUxvYWRlciA9IG5ldyBLZXlMb2FkZXIodGhpcy5jb25maWcpO1xuICAgIGNvbnN0IHN0cmVhbUNvbnRyb2xsZXIgPSB0aGlzLnN0cmVhbUNvbnRyb2xsZXIgPSBuZXcgU3RyZWFtQ29udHJvbGxlcih0aGlzLCBmcmFnbWVudFRyYWNrZXIsIGtleUxvYWRlcik7XG4gICAgY29uc3QgZ2FwQ29udHJvbGxlciA9IHRoaXMuZ2FwQ29udHJvbGxlciA9IG5ldyBHYXBDb250cm9sbGVyKHRoaXMsIGZyYWdtZW50VHJhY2tlcik7XG5cbiAgICAvLyBDYXAgbGV2ZWwgY29udHJvbGxlciB1c2VzIHN0cmVhbUNvbnRyb2xsZXIgdG8gZmx1c2ggdGhlIGJ1ZmZlclxuICAgIGNhcExldmVsQ29udHJvbGxlci5zZXRTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXIpO1xuICAgIC8vIGZwc0NvbnRyb2xsZXIgdXNlcyBzdHJlYW1Db250cm9sbGVyIHRvIHN3aXRjaCB3aGVuIGZyYW1lcyBhcmUgYmVpbmcgZHJvcHBlZFxuICAgIGZwc0NvbnRyb2xsZXIuc2V0U3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyKTtcbiAgICBjb25zdCBuZXR3b3JrQ29udHJvbGxlcnMgPSBbcGxheUxpc3RMb2FkZXIsIGxldmVsQ29udHJvbGxlciwgc3RyZWFtQ29udHJvbGxlcl07XG4gICAgaWYgKGludGVyc3RpdGlhbHNDb250cm9sbGVyKSB7XG4gICAgICBuZXR3b3JrQ29udHJvbGxlcnMuc3BsaWNlKDEsIDAsIGludGVyc3RpdGlhbHNDb250cm9sbGVyKTtcbiAgICB9XG4gICAgaWYgKGNvbnRlbnRTdGVlcmluZykge1xuICAgICAgbmV0d29ya0NvbnRyb2xsZXJzLnNwbGljZSgxLCAwLCBjb250ZW50U3RlZXJpbmcpO1xuICAgIH1cbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycyA9IG5ldHdvcmtDb250cm9sbGVycztcbiAgICBjb25zdCBjb3JlQ29tcG9uZW50cyA9IFthYnJDb250cm9sbGVyLCBidWZmZXJDb250cm9sbGVyLCBnYXBDb250cm9sbGVyLCBjYXBMZXZlbENvbnRyb2xsZXIsIGZwc0NvbnRyb2xsZXIsIGlkM1RyYWNrQ29udHJvbGxlciwgZnJhZ21lbnRUcmFja2VyXTtcbiAgICB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyID0gdGhpcy5jcmVhdGVDb250cm9sbGVyKGNvbmZpZy5hdWRpb1RyYWNrQ29udHJvbGxlciwgbmV0d29ya0NvbnRyb2xsZXJzKTtcbiAgICBjb25zdCBBdWRpb1N0cmVhbUNvbnRyb2xsZXJDbGFzcyA9IGNvbmZpZy5hdWRpb1N0cmVhbUNvbnRyb2xsZXI7XG4gICAgaWYgKEF1ZGlvU3RyZWFtQ29udHJvbGxlckNsYXNzKSB7XG4gICAgICBuZXR3b3JrQ29udHJvbGxlcnMucHVzaCh0aGlzLmF1ZGlvU3RyZWFtQ29udHJvbGxlciA9IG5ldyBBdWRpb1N0cmVhbUNvbnRyb2xsZXJDbGFzcyh0aGlzLCBmcmFnbWVudFRyYWNrZXIsIGtleUxvYWRlcikpO1xuICAgIH1cbiAgICAvLyBJbnN0YW50aWF0ZSBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciBiZWZvcmUgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyIHRvIHJlY2VpdmUgbGV2ZWwgZXZlbnRzIGZpcnN0XG4gICAgdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuY3JlYXRlQ29udHJvbGxlcihjb25maWcuc3VidGl0bGVUcmFja0NvbnRyb2xsZXIsIG5ldHdvcmtDb250cm9sbGVycyk7XG4gICAgY29uc3QgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyQ2xhc3MgPSBjb25maWcuc3VidGl0bGVTdHJlYW1Db250cm9sbGVyO1xuICAgIGlmIChTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXJDbGFzcykge1xuICAgICAgbmV0d29ya0NvbnRyb2xsZXJzLnB1c2godGhpcy5zdWJ0aXRpdGxlU3RyZWFtQ29udHJvbGxlciA9IG5ldyBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXJDbGFzcyh0aGlzLCBmcmFnbWVudFRyYWNrZXIsIGtleUxvYWRlcikpO1xuICAgIH1cbiAgICB0aGlzLmNyZWF0ZUNvbnRyb2xsZXIoY29uZmlnLnRpbWVsaW5lQ29udHJvbGxlciwgY29yZUNvbXBvbmVudHMpO1xuICAgIGtleUxvYWRlci5lbWVDb250cm9sbGVyID0gdGhpcy5lbWVDb250cm9sbGVyID0gdGhpcy5jcmVhdGVDb250cm9sbGVyKGNvbmZpZy5lbWVDb250cm9sbGVyLCBjb3JlQ29tcG9uZW50cyk7XG4gICAgdGhpcy5jbWNkQ29udHJvbGxlciA9IHRoaXMuY3JlYXRlQ29udHJvbGxlcihjb25maWcuY21jZENvbnRyb2xsZXIsIGNvcmVDb21wb25lbnRzKTtcbiAgICB0aGlzLmxhdGVuY3lDb250cm9sbGVyID0gdGhpcy5jcmVhdGVDb250cm9sbGVyKExhdGVuY3lDb250cm9sbGVyLCBjb3JlQ29tcG9uZW50cyk7XG4gICAgdGhpcy5jb3JlQ29tcG9uZW50cyA9IGNvcmVDb21wb25lbnRzO1xuXG4gICAgLy8gRXJyb3IgY29udHJvbGxlciBoYW5kbGVzIGVycm9ycyBiZWZvcmUgYW5kIGFmdGVyIGFsbCBvdGhlciBjb250cm9sbGVyc1xuICAgIC8vIFRoaXMgbGlzdGVuZXIgd2lsbCBiZSBpbnZva2VkIGFmdGVyIGFsbCBvdGhlciBjb250cm9sbGVycyBlcnJvciBsaXN0ZW5lcnNcbiAgICBuZXR3b3JrQ29udHJvbGxlcnMucHVzaChlcnJvckNvbnRyb2xsZXIpO1xuICAgIGNvbnN0IG9uRXJyb3JPdXQgPSBlcnJvckNvbnRyb2xsZXIub25FcnJvck91dDtcbiAgICBpZiAodHlwZW9mIG9uRXJyb3JPdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMub24oRXZlbnRzLkVSUk9SLCBvbkVycm9yT3V0LCBlcnJvckNvbnRyb2xsZXIpO1xuICAgIH1cbiAgICAvLyBBdXRvc3RhcnQgbG9hZCBoYW5kbGVyXG4gICAgdGhpcy5vbihFdmVudHMuTUFOSUZFU1RfTE9BREVELCBwbGF5TGlzdExvYWRlci5vbk1hbmlmZXN0TG9hZGVkLCBwbGF5TGlzdExvYWRlcik7XG4gIH1cbiAgY3JlYXRlQ29udHJvbGxlcihDb250cm9sbGVyQ2xhc3MsIGNvbXBvbmVudHMpIHtcbiAgICBpZiAoQ29udHJvbGxlckNsYXNzKSB7XG4gICAgICBjb25zdCBjb250cm9sbGVySW5zdGFuY2UgPSBuZXcgQ29udHJvbGxlckNsYXNzKHRoaXMpO1xuICAgICAgaWYgKGNvbXBvbmVudHMpIHtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKGNvbnRyb2xsZXJJbnN0YW5jZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udHJvbGxlckluc3RhbmNlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIERlbGVnYXRlIHRoZSBFdmVudEVtaXR0ZXIgdGhyb3VnaCB0aGUgcHVibGljIEFQSSBvZiBIbHMuanNcbiAgb24oZXZlbnQsIGxpc3RlbmVyLCBjb250ZXh0ID0gdGhpcykge1xuICAgIHRoaXMuX2VtaXR0ZXIub24oZXZlbnQsIGxpc3RlbmVyLCBjb250ZXh0KTtcbiAgfVxuICBvbmNlKGV2ZW50LCBsaXN0ZW5lciwgY29udGV4dCA9IHRoaXMpIHtcbiAgICB0aGlzLl9lbWl0dGVyLm9uY2UoZXZlbnQsIGxpc3RlbmVyLCBjb250ZXh0KTtcbiAgfVxuICByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICB0aGlzLl9lbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycyhldmVudCk7XG4gIH1cbiAgb2ZmKGV2ZW50LCBsaXN0ZW5lciwgY29udGV4dCA9IHRoaXMsIG9uY2UpIHtcbiAgICB0aGlzLl9lbWl0dGVyLm9mZihldmVudCwgbGlzdGVuZXIsIGNvbnRleHQsIG9uY2UpO1xuICB9XG4gIGxpc3RlbmVycyhldmVudCkge1xuICAgIHJldHVybiB0aGlzLl9lbWl0dGVyLmxpc3RlbmVycyhldmVudCk7XG4gIH1cbiAgZW1pdChldmVudCwgbmFtZSwgZXZlbnRPYmplY3QpIHtcbiAgICByZXR1cm4gdGhpcy5fZW1pdHRlci5lbWl0KGV2ZW50LCBuYW1lLCBldmVudE9iamVjdCk7XG4gIH1cbiAgdHJpZ2dlcihldmVudCwgZXZlbnRPYmplY3QpIHtcbiAgICBpZiAodGhpcy5jb25maWcuZGVidWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmVtaXQoZXZlbnQsIGV2ZW50LCBldmVudE9iamVjdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoZXZlbnQsIGV2ZW50LCBldmVudE9iamVjdCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcignQW4gaW50ZXJuYWwgZXJyb3IgaGFwcGVuZWQgd2hpbGUgaGFuZGxpbmcgZXZlbnQgJyArIGV2ZW50ICsgJy4gRXJyb3IgbWVzc2FnZTogXCInICsgZXJyb3IubWVzc2FnZSArICdcIi4gSGVyZSBpcyBhIHN0YWNrdHJhY2U6JywgZXJyb3IpO1xuICAgICAgICAvLyBQcmV2ZW50IHJlY3Vyc2lvbiBpbiBlcnJvciBldmVudCBoYW5kbGVycyB0aGF0IHRocm93ICM1NDk3XG4gICAgICAgIGlmICghdGhpcy50cmlnZ2VyaW5nRXhjZXB0aW9uKSB7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyaW5nRXhjZXB0aW9uID0gdHJ1ZTtcbiAgICAgICAgICBjb25zdCBmYXRhbCA9IGV2ZW50ID09PSBFdmVudHMuRVJST1I7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5PVEhFUl9FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5JTlRFUk5BTF9FWENFUFRJT04sXG4gICAgICAgICAgICBmYXRhbCxcbiAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnRyaWdnZXJpbmdFeGNlcHRpb24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbGlzdGVuZXJDb3VudChldmVudCkge1xuICAgIHJldHVybiB0aGlzLl9lbWl0dGVyLmxpc3RlbmVyQ291bnQoZXZlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3Bvc2Ugb2YgdGhlIGluc3RhbmNlXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMubG9nZ2VyLmxvZygnZGVzdHJveScpO1xuICAgIHRoaXMudHJpZ2dlcihFdmVudHMuREVTVFJPWUlORywgdW5kZWZpbmVkKTtcbiAgICB0aGlzLmRldGFjaE1lZGlhKCk7XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nID0gLTE7XG4gICAgdGhpcy5fdXJsID0gbnVsbDtcbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycy5mb3JFYWNoKGNvbXBvbmVudCA9PiBjb21wb25lbnQuZGVzdHJveSgpKTtcbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycy5sZW5ndGggPSAwO1xuICAgIHRoaXMuY29yZUNvbXBvbmVudHMuZm9yRWFjaChjb21wb25lbnQgPT4gY29tcG9uZW50LmRlc3Ryb3koKSk7XG4gICAgdGhpcy5jb3JlQ29tcG9uZW50cy5sZW5ndGggPSAwO1xuICAgIC8vIFJlbW92ZSBhbnkgcmVmZXJlbmNlcyB0aGF0IGNvdWxkIGJlIGhlbGQgaW4gY29uZmlnIG9wdGlvbnMgb3IgY2FsbGJhY2tzXG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgY29uZmlnLnhoclNldHVwID0gY29uZmlnLmZldGNoU2V0dXAgPSB1bmRlZmluZWQ7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMudXNlckNvbmZpZyA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQXR0YWNoZXMgSGxzLmpzIHRvIGEgbWVkaWEgZWxlbWVudFxuICAgKi9cbiAgYXR0YWNoTWVkaWEoZGF0YSkge1xuICAgIGlmICghZGF0YSB8fCAnbWVkaWEnIGluIGRhdGEgJiYgIWRhdGEubWVkaWEpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBhdHRhY2hNZWRpYSBmYWlsZWQ6IGludmFsaWQgYXJndW1lbnQgKCR7ZGF0YX0pYCk7XG4gICAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuT1RIRVJfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5BVFRBQ0hfTUVESUFfRVJST1IsXG4gICAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgICBlcnJvclxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubG9nZ2VyLmxvZyhgYXR0YWNoTWVkaWFgKTtcbiAgICBpZiAodGhpcy5fbWVkaWEpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oYG1lZGlhIG11c3QgYmUgZGV0YWNoZWQgYmVmb3JlIGF0dGFjaGluZ2ApO1xuICAgICAgdGhpcy5kZXRhY2hNZWRpYSgpO1xuICAgIH1cbiAgICBjb25zdCBhdHRhY2hNZWRpYVNvdXJjZSA9ICdtZWRpYScgaW4gZGF0YTtcbiAgICBjb25zdCBtZWRpYSA9IGF0dGFjaE1lZGlhU291cmNlID8gZGF0YS5tZWRpYSA6IGRhdGE7XG4gICAgY29uc3QgYXR0YWNoaW5nRGF0YSA9IGF0dGFjaE1lZGlhU291cmNlID8gZGF0YSA6IHtcbiAgICAgIG1lZGlhXG4gICAgfTtcbiAgICB0aGlzLl9tZWRpYSA9IG1lZGlhO1xuICAgIHRoaXMudHJpZ2dlcihFdmVudHMuTUVESUFfQVRUQUNISU5HLCBhdHRhY2hpbmdEYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRhY2ggSGxzLmpzIGZyb20gdGhlIG1lZGlhXG4gICAqL1xuICBkZXRhY2hNZWRpYSgpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coJ2RldGFjaE1lZGlhJyk7XG4gICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHt9KTtcbiAgICB0aGlzLl9tZWRpYSA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogRGV0YWNoIEhUTUxNZWRpYUVsZW1lbnQsIE1lZGlhU291cmNlLCBhbmQgU291cmNlQnVmZmVycyB3aXRob3V0IHJlc2V0LCBmb3IgYXR0YWNoaW5nIHRvIGFub3RoZXIgaW5zdGFuY2VcbiAgICovXG4gIHRyYW5zZmVyTWVkaWEoKSB7XG4gICAgdGhpcy5fbWVkaWEgPSBudWxsO1xuICAgIGNvbnN0IHRyYW5zZmVyTWVkaWEgPSB0aGlzLmJ1ZmZlckNvbnRyb2xsZXIudHJhbnNmZXJNZWRpYSgpO1xuICAgIHRoaXMudHJpZ2dlcihFdmVudHMuTUVESUFfREVUQUNISU5HLCB7XG4gICAgICB0cmFuc2Zlck1lZGlhXG4gICAgfSk7XG4gICAgcmV0dXJuIHRyYW5zZmVyTWVkaWE7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBzb3VyY2UgVVJMLiBDYW4gYmUgcmVsYXRpdmUgb3IgYWJzb2x1dGUuXG4gICAqL1xuICBsb2FkU291cmNlKHVybCkge1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgY29uc3QgbG9hZGVkU291cmNlID0gdGhpcy5fdXJsO1xuICAgIGNvbnN0IGxvYWRpbmdTb3VyY2UgPSB0aGlzLl91cmwgPSB1cmxUb29sa2l0RXhwb3J0cy5idWlsZEFic29sdXRlVVJMKHNlbGYubG9jYXRpb24uaHJlZiwgdXJsLCB7XG4gICAgICBhbHdheXNOb3JtYWxpemU6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nID0gLTE7XG4gICAgdGhpcy5fbWF4SGRjcExldmVsID0gbnVsbDtcbiAgICB0aGlzLmxvZ2dlci5sb2coYGxvYWRTb3VyY2U6JHtsb2FkaW5nU291cmNlfWApO1xuICAgIGlmIChtZWRpYSAmJiBsb2FkZWRTb3VyY2UgJiYgKGxvYWRlZFNvdXJjZSAhPT0gbG9hZGluZ1NvdXJjZSB8fCB0aGlzLmJ1ZmZlckNvbnRyb2xsZXIuaGFzU291cmNlVHlwZXMoKSkpIHtcbiAgICAgIC8vIFJlbW92ZSBhbmQgcmUtY3JlYXRlIE1lZGlhU291cmNlXG4gICAgICB0aGlzLmRldGFjaE1lZGlhKCk7XG4gICAgICB0aGlzLmF0dGFjaE1lZGlhKG1lZGlhKTtcbiAgICB9XG4gICAgLy8gd2hlbiBhdHRhY2hpbmcgdG8gYSBzb3VyY2UgVVJMLCB0cmlnZ2VyIGEgcGxheWxpc3QgbG9hZFxuICAgIHRoaXMudHJpZ2dlcihFdmVudHMuTUFOSUZFU1RfTE9BRElORywge1xuICAgICAgdXJsOiB1cmxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50bHkgbG9hZGVkIFVSTFxuICAgKi9cbiAgZ2V0IHVybCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdXJsO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IGVub3VnaCBoYXMgYmVlbiBidWZmZXJlZCB0byBzZWVrIHRvIHN0YXJ0IHBvc2l0aW9uIG9yIHVzZSBgbWVkaWEuY3VycmVudFRpbWVgIHRvIGRldGVybWluZSBuZXh0IGxvYWQgcG9zaXRpb25cbiAgICovXG4gIGdldCBoYXNFbm91Z2hUb1N0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuaGFzRW5vdWdoVG9TdGFydDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0YXJ0UG9zaXRpb24gc2V0IG9uIHN0YXJ0TG9hZChwb3NpdGlvbikgb3Igb24gYXV0b3N0YXJ0IHdpdGggY29uZmlnLnN0YXJ0UG9zaXRpb25cbiAgICovXG4gIGdldCBzdGFydFBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuc3RhcnRQb3NpdGlvblZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGxvYWRpbmcgZGF0YSBmcm9tIHRoZSBzdHJlYW0gc291cmNlLlxuICAgKiBEZXBlbmRpbmcgb24gZGVmYXVsdCBjb25maWcsIGNsaWVudCBzdGFydHMgbG9hZGluZyBhdXRvbWF0aWNhbGx5IHdoZW4gYSBzb3VyY2UgaXMgc2V0LlxuICAgKlxuICAgKiBAcGFyYW0gc3RhcnRQb3NpdGlvbiAtIFNldCB0aGUgc3RhcnQgcG9zaXRpb24gdG8gc3RyZWFtIGZyb20uXG4gICAqIERlZmF1bHRzIHRvIC0xIChOb25lOiBzdGFydHMgZnJvbSBlYXJsaWVzdCBwb2ludClcbiAgICovXG4gIHN0YXJ0TG9hZChzdGFydFBvc2l0aW9uID0gLTEsIHNraXBTZWVrVG9TdGFydFBvc2l0aW9uKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nKGBzdGFydExvYWQoJHtzdGFydFBvc2l0aW9uICsgKHNraXBTZWVrVG9TdGFydFBvc2l0aW9uID8gJywgPHNraXAgc2VlayB0byBzdGFydD4nIDogJycpfSlgKTtcbiAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgIHRoaXMucmVzdW1lQnVmZmVyaW5nKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm5ldHdvcmtDb250cm9sbGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnNbaV0uc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24sIHNraXBTZWVrVG9TdGFydFBvc2l0aW9uKTtcbiAgICAgIGlmICghdGhpcy5zdGFydGVkIHx8ICF0aGlzLm5ldHdvcmtDb250cm9sbGVycykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RvcCBsb2FkaW5nIG9mIGFueSBzdHJlYW0gZGF0YS5cbiAgICovXG4gIHN0b3BMb2FkKCkge1xuICAgIHRoaXMubG9nZ2VyLmxvZygnc3RvcExvYWQnKTtcbiAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubmV0d29ya0NvbnRyb2xsZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyc1tpXS5zdG9wTG9hZCgpO1xuICAgICAgaWYgKHRoaXMuc3RhcnRlZCB8fCAhdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBsb2FkaW5nLCB0b2dnbGVkIHdpdGggYHN0YXJ0TG9hZCgpYCBhbmQgYHN0b3BMb2FkKClgLCBpcyBhY3RpdmUgb3Igbm90YC5cbiAgICovXG4gIGdldCBsb2FkaW5nRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFydGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgc3RhdGUgb2YgZnJhZ21lbnQgbG9hZGluZyB0b2dnbGVkIGJ5IGNhbGxpbmcgYHBhdXNlQnVmZmVyaW5nKClgIGFuZCBgcmVzdW1lQnVmZmVyaW5nKClgLlxuICAgKi9cbiAgZ2V0IGJ1ZmZlcmluZ0VuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5idWZmZXJpbmdFbmFibGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc3VtZXMgc3RyZWFtIGNvbnRyb2xsZXIgc2VnbWVudCBsb2FkaW5nIGFmdGVyIGBwYXVzZUJ1ZmZlcmluZ2AgaGFzIGJlZW4gY2FsbGVkLlxuICAgKi9cbiAgcmVzdW1lQnVmZmVyaW5nKCkge1xuICAgIGlmICghdGhpcy5idWZmZXJpbmdFbmFibGVkKSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coYHJlc3VtZSBidWZmZXJpbmdgKTtcbiAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzLmZvckVhY2goY29udHJvbGxlciA9PiB7XG4gICAgICAgIGlmIChjb250cm9sbGVyLnJlc3VtZUJ1ZmZlcmluZykge1xuICAgICAgICAgIGNvbnRyb2xsZXIucmVzdW1lQnVmZmVyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQcmV2ZW50cyBzdHJlYW0gY29udHJvbGxlciBmcm9tIGxvYWRpbmcgbmV3IHNlZ21lbnRzIHVudGlsIGByZXN1bWVCdWZmZXJpbmdgIGlzIGNhbGxlZC5cbiAgICogVGhpcyBhbGxvd3MgZm9yIG1lZGlhIGJ1ZmZlcmluZyB0byBiZSBwYXVzZWQgd2l0aG91dCBpbnRlcnVwdGluZyBwbGF5bGlzdCBsb2FkaW5nLlxuICAgKi9cbiAgcGF1c2VCdWZmZXJpbmcoKSB7XG4gICAgaWYgKHRoaXMuYnVmZmVyaW5nRW5hYmxlZCkge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKGBwYXVzZSBidWZmZXJpbmdgKTtcbiAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzLmZvckVhY2goY29udHJvbGxlciA9PiB7XG4gICAgICAgIGlmIChjb250cm9sbGVyLnBhdXNlQnVmZmVyaW5nKSB7XG4gICAgICAgICAgY29udHJvbGxlci5wYXVzZUJ1ZmZlcmluZygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0IGluRmxpZ2h0RnJhZ21lbnRzKCkge1xuICAgIGNvbnN0IGluRmxpZ2h0RGF0YSA9IHtcbiAgICAgIFtQbGF5bGlzdExldmVsVHlwZS5NQUlOXTogdGhpcy5zdHJlYW1Db250cm9sbGVyLmluRmxpZ2h0RnJhZ1xuICAgIH07XG4gICAgaWYgKHRoaXMuYXVkaW9TdHJlYW1Db250cm9sbGVyKSB7XG4gICAgICBpbkZsaWdodERhdGFbUGxheWxpc3RMZXZlbFR5cGUuQVVESU9dID0gdGhpcy5hdWRpb1N0cmVhbUNvbnRyb2xsZXIuaW5GbGlnaHRGcmFnO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdWJ0aXRpdGxlU3RyZWFtQ29udHJvbGxlcikge1xuICAgICAgaW5GbGlnaHREYXRhW1BsYXlsaXN0TGV2ZWxUeXBlLlNVQlRJVExFXSA9IHRoaXMuc3VidGl0aXRsZVN0cmVhbUNvbnRyb2xsZXIuaW5GbGlnaHRGcmFnO1xuICAgIH1cbiAgICByZXR1cm4gaW5GbGlnaHREYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIFN3YXAgdGhyb3VnaCBwb3NzaWJsZSBhdWRpbyBjb2RlY3MgaW4gdGhlIHN0cmVhbSAoZm9yIGV4YW1wbGUgdG8gc3dpdGNoIGZyb20gc3RlcmVvIHRvIDUuMSlcbiAgICovXG4gIHN3YXBBdWRpb0NvZGVjKCkge1xuICAgIHRoaXMubG9nZ2VyLmxvZygnc3dhcEF1ZGlvQ29kZWMnKTtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuc3dhcEF1ZGlvQ29kZWMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBtZWRpYS1lbGVtZW50IGZhaWxzLCB0aGlzIGFsbG93cyB0byBkZXRhY2ggYW5kIHRoZW4gcmUtYXR0YWNoIGl0XG4gICAqIGFzIG9uZSBjYWxsIChjb252ZW5pZW5jZSBtZXRob2QpLlxuICAgKlxuICAgKiBBdXRvbWF0aWMgcmVjb3Zlcnkgb2YgbWVkaWEtZXJyb3JzIGJ5IHRoaXMgcHJvY2VzcyBpcyBjb25maWd1cmFibGUuXG4gICAqL1xuICByZWNvdmVyTWVkaWFFcnJvcigpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coJ3JlY292ZXJNZWRpYUVycm9yJyk7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLl9tZWRpYTtcbiAgICBjb25zdCB0aW1lID0gbWVkaWEgPT0gbnVsbCA/IHZvaWQgMCA6IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIHRoaXMuZGV0YWNoTWVkaWEoKTtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIHRoaXMuYXR0YWNoTWVkaWEobWVkaWEpO1xuICAgICAgaWYgKHRpbWUpIHtcbiAgICAgICAgdGhpcy5zdGFydExvYWQodGltZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlbW92ZUxldmVsKGxldmVsSW5kZXgpIHtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5yZW1vdmVMZXZlbChsZXZlbEluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBhIFVVSUQgZm9yIHRoaXMgcGxheWVyIGluc3RhbmNlXG4gICAqL1xuICBnZXQgc2Vzc2lvbklkKCkge1xuICAgIGxldCBfc2Vzc2lvbklkID0gdGhpcy5fc2Vzc2lvbklkO1xuICAgIGlmICghX3Nlc3Npb25JZCkge1xuICAgICAgX3Nlc3Npb25JZCA9IHRoaXMuX3Nlc3Npb25JZCA9IHV1aWQoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9zZXNzaW9uSWQ7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgYW4gYXJyYXkgb2YgbGV2ZWxzICh2YXJpYW50cykgc29ydGVkIGJ5IEhEQ1AtTEVWRUwsIFJFU09MVVRJT04gKGhlaWdodCksIEZSQU1FLVJBVEUsIENPREVDUywgVklERU8tUkFOR0UsIGFuZCBCQU5EV0lEVEhcbiAgICovXG4gIGdldCBsZXZlbHMoKSB7XG4gICAgY29uc3QgbGV2ZWxzID0gdGhpcy5sZXZlbENvbnRyb2xsZXIubGV2ZWxzO1xuICAgIHJldHVybiBsZXZlbHMgPyBsZXZlbHMgOiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBMZXZlbERldGFpbHMgb2YgbGFzdCBsb2FkZWQgbGV2ZWwgKHZhcmlhbnQpIG9yIGBudWxsYCBwcmlvciB0byBsb2FkaW5nIGEgbWVkaWEgcGxheWxpc3QuXG4gICAqL1xuICBnZXQgbGF0ZXN0TGV2ZWxEZXRhaWxzKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuZ2V0TGV2ZWxEZXRhaWxzKCkgfHwgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBMZXZlbCBvYmplY3Qgb2Ygc2VsZWN0ZWQgbGV2ZWwgKHZhcmlhbnQpIG9yIGBudWxsYCBwcmlvciB0byBzZWxlY3RpbmcgYSBsZXZlbCBvciBvbmNlIHRoZSBsZXZlbCBpcyByZW1vdmVkLlxuICAgKi9cbiAgZ2V0IGxvYWRMZXZlbE9iaigpIHtcbiAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubG9hZExldmVsT2JqO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGV4IG9mIHF1YWxpdHkgbGV2ZWwgKHZhcmlhbnQpIGN1cnJlbnRseSBwbGF5ZWRcbiAgICovXG4gIGdldCBjdXJyZW50TGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5jdXJyZW50TGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHF1YWxpdHkgbGV2ZWwgaW5kZXggaW1tZWRpYXRlbHkuIFRoaXMgd2lsbCBmbHVzaCB0aGUgY3VycmVudCBidWZmZXIgdG8gcmVwbGFjZSB0aGUgcXVhbGl0eSBhc2FwLiBUaGF0IG1lYW5zIHBsYXliYWNrIHdpbGwgaW50ZXJydXB0IGF0IGxlYXN0IHNob3J0bHkgdG8gcmUtYnVmZmVyIGFuZCByZS1zeW5jIGV2ZW50dWFsbHkuIFNldCB0byAtMSBmb3IgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbi5cbiAgICovXG4gIHNldCBjdXJyZW50TGV2ZWwobmV3TGV2ZWwpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coYHNldCBjdXJyZW50TGV2ZWw6JHtuZXdMZXZlbH1gKTtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbCA9IG5ld0xldmVsO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5pbW1lZGlhdGVMZXZlbFN3aXRjaCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGV4IG9mIG5leHQgcXVhbGl0eSBsZXZlbCBsb2FkZWQgYXMgc2NoZWR1bGVkIGJ5IHN0cmVhbSBjb250cm9sbGVyLlxuICAgKi9cbiAgZ2V0IG5leHRMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgcXVhbGl0eSBsZXZlbCBpbmRleCBmb3IgbmV4dCBsb2FkZWQgZGF0YS5cbiAgICogVGhpcyB3aWxsIHN3aXRjaCB0aGUgdmlkZW8gcXVhbGl0eSBhc2FwLCB3aXRob3V0IGludGVycnVwdGluZyBwbGF5YmFjay5cbiAgICogTWF5IGFib3J0IGN1cnJlbnQgbG9hZGluZyBvZiBkYXRhLCBhbmQgZmx1c2ggcGFydHMgb2YgYnVmZmVyIChvdXRzaWRlIGN1cnJlbnRseSBwbGF5ZWQgZnJhZ21lbnQgcmVnaW9uKS5cbiAgICogQHBhcmFtIG5ld0xldmVsIC0gUGFzcyAtMSBmb3IgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvblxuICAgKi9cbiAgc2V0IG5leHRMZXZlbChuZXdMZXZlbCkge1xuICAgIHRoaXMubG9nZ2VyLmxvZyhgc2V0IG5leHRMZXZlbDoke25ld0xldmVsfWApO1xuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsID0gbmV3TGV2ZWw7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbFN3aXRjaCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgcXVhbGl0eSBsZXZlbCBvZiB0aGUgY3VycmVudGx5IG9yIGxhc3QgKG9mIG5vbmUgaXMgbG9hZGVkIGN1cnJlbnRseSkgc2VnbWVudFxuICAgKi9cbiAgZ2V0IGxvYWRMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHF1YWxpdHkgbGV2ZWwgaW5kZXggZm9yIG5leHQgbG9hZGVkIGRhdGEgaW4gYSBjb25zZXJ2YXRpdmUgd2F5LlxuICAgKiBUaGlzIHdpbGwgc3dpdGNoIHRoZSBxdWFsaXR5IHdpdGhvdXQgZmx1c2hpbmcsIGJ1dCBpbnRlcnJ1cHQgY3VycmVudCBsb2FkaW5nLlxuICAgKiBUaHVzIHRoZSBtb21lbnQgd2hlbiB0aGUgcXVhbGl0eSBzd2l0Y2ggd2lsbCBhcHBlYXIgaW4gZWZmZWN0IHdpbGwgb25seSBiZSBhZnRlciB0aGUgYWxyZWFkeSBleGlzdGluZyBidWZmZXIuXG4gICAqIEBwYXJhbSBuZXdMZXZlbCAtIFBhc3MgLTEgZm9yIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb25cbiAgICovXG4gIHNldCBsb2FkTGV2ZWwobmV3TGV2ZWwpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coYHNldCBsb2FkTGV2ZWw6JHtuZXdMZXZlbH1gKTtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbCA9IG5ld0xldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCBuZXh0IHF1YWxpdHkgbGV2ZWwgbG9hZGVkXG4gICAqL1xuICBnZXQgbmV4dExvYWRMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubmV4dExvYWRMZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgcXVhbGl0eSBsZXZlbCBvZiBuZXh0IGxvYWRlZCBzZWdtZW50IGluIGEgZnVsbHkgXCJub24tZGVzdHJ1Y3RpdmVcIiB3YXkuXG4gICAqIFNhbWUgYXMgYGxvYWRMZXZlbGAgYnV0IHdpbGwgd2FpdCBmb3IgbmV4dCBzd2l0Y2ggKHVudGlsIGN1cnJlbnQgbG9hZGluZyBpcyBkb25lKS5cbiAgICovXG4gIHNldCBuZXh0TG9hZExldmVsKGxldmVsKSB7XG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIubmV4dExvYWRMZXZlbCA9IGxldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBcImZpcnN0IGxldmVsXCI6IGxpa2UgYSBkZWZhdWx0IGxldmVsLCBpZiBub3Qgc2V0LFxuICAgKiBmYWxscyBiYWNrIHRvIGluZGV4IG9mIGZpcnN0IGxldmVsIHJlZmVyZW5jZWQgaW4gbWFuaWZlc3RcbiAgICovXG4gIGdldCBmaXJzdExldmVsKCkge1xuICAgIHJldHVybiBNYXRoLm1heCh0aGlzLmxldmVsQ29udHJvbGxlci5maXJzdExldmVsLCB0aGlzLm1pbkF1dG9MZXZlbCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBcImZpcnN0LWxldmVsXCIsIHNlZSBnZXR0ZXIuXG4gICAqL1xuICBzZXQgZmlyc3RMZXZlbChuZXdMZXZlbCkge1xuICAgIHRoaXMubG9nZ2VyLmxvZyhgc2V0IGZpcnN0TGV2ZWw6JHtuZXdMZXZlbH1gKTtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5maXJzdExldmVsID0gbmV3TGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBkZXNpcmVkIHN0YXJ0IGxldmVsIGZvciB0aGUgZmlyc3QgZnJhZ21lbnQgdGhhdCB3aWxsIGJlIGxvYWRlZC5cbiAgICogVGhlIGRlZmF1bHQgdmFsdWUgb2YgLTEgaW5kaWNhdGVzIGF1dG9tYXRpYyBzdGFydCBsZXZlbCBzZWxlY3Rpb24uXG4gICAqIFNldHRpbmcgaGxzLm5leHRBdXRvTGV2ZWwgd2l0aG91dCBzZXR0aW5nIGEgc3RhcnRMZXZlbCB3aWxsIHJlc3VsdCBpblxuICAgKiB0aGUgbmV4dEF1dG9MZXZlbCB2YWx1ZSBiZWluZyB1c2VkIGZvciBvbmUgZnJhZ21lbnQgbG9hZC5cbiAgICovXG4gIGdldCBzdGFydExldmVsKCkge1xuICAgIGNvbnN0IHN0YXJ0TGV2ZWwgPSB0aGlzLmxldmVsQ29udHJvbGxlci5zdGFydExldmVsO1xuICAgIGlmIChzdGFydExldmVsID09PSAtMSAmJiB0aGlzLmFickNvbnRyb2xsZXIuZm9yY2VkQXV0b0xldmVsID4gLTEpIHtcbiAgICAgIHJldHVybiB0aGlzLmFickNvbnRyb2xsZXIuZm9yY2VkQXV0b0xldmVsO1xuICAgIH1cbiAgICByZXR1cm4gc3RhcnRMZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBzZXQgIHN0YXJ0IGxldmVsIChsZXZlbCBvZiBmaXJzdCBmcmFnbWVudCB0aGF0IHdpbGwgYmUgcGxheWVkIGJhY2spXG4gICAqIGlmIG5vdCBvdmVycmlkZWQgYnkgdXNlciwgZmlyc3QgbGV2ZWwgYXBwZWFyaW5nIGluIG1hbmlmZXN0IHdpbGwgYmUgdXNlZCBhcyBzdGFydCBsZXZlbFxuICAgKiBpZiAtMSA6IGF1dG9tYXRpYyBzdGFydCBsZXZlbCBzZWxlY3Rpb24sIHBsYXliYWNrIHdpbGwgc3RhcnQgZnJvbSBsZXZlbCBtYXRjaGluZyBkb3dubG9hZCBiYW5kd2lkdGhcbiAgICogKGRldGVybWluZWQgZnJvbSBkb3dubG9hZCBvZiBmaXJzdCBzZWdtZW50KVxuICAgKi9cbiAgc2V0IHN0YXJ0TGV2ZWwobmV3TGV2ZWwpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coYHNldCBzdGFydExldmVsOiR7bmV3TGV2ZWx9YCk7XG4gICAgLy8gaWYgbm90IGluIGF1dG9tYXRpYyBzdGFydCBsZXZlbCBkZXRlY3Rpb24sIGVuc3VyZSBzdGFydExldmVsIGlzIGdyZWF0ZXIgdGhhbiBtaW5BdXRvTGV2ZWxcbiAgICBpZiAobmV3TGV2ZWwgIT09IC0xKSB7XG4gICAgICBuZXdMZXZlbCA9IE1hdGgubWF4KG5ld0xldmVsLCB0aGlzLm1pbkF1dG9MZXZlbCk7XG4gICAgfVxuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLnN0YXJ0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGxldmVsIGNhcHBpbmcgaXMgZW5hYmxlZC5cbiAgICogRGVmYXVsdCB2YWx1ZSBpcyBzZXQgdmlhIGBjb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemVgLlxuICAgKi9cbiAgZ2V0IGNhcExldmVsVG9QbGF5ZXJTaXplKCkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGVzIG9yIGRpc2FibGVzIGxldmVsIGNhcHBpbmcuIElmIGRpc2FibGVkIGFmdGVyIHByZXZpb3VzbHkgZW5hYmxlZCwgYG5leHRMZXZlbFN3aXRjaGAgd2lsbCBiZSBpbW1lZGlhdGVseSBjYWxsZWQuXG4gICAqL1xuICBzZXQgY2FwTGV2ZWxUb1BsYXllclNpemUoc2hvdWxkU3RhcnRDYXBwaW5nKSB7XG4gICAgY29uc3QgbmV3Q2FwTGV2ZWxUb1BsYXllclNpemUgPSAhIXNob3VsZFN0YXJ0Q2FwcGluZztcbiAgICBpZiAobmV3Q2FwTGV2ZWxUb1BsYXllclNpemUgIT09IHRoaXMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplKSB7XG4gICAgICBpZiAobmV3Q2FwTGV2ZWxUb1BsYXllclNpemUpIHtcbiAgICAgICAgdGhpcy5jYXBMZXZlbENvbnRyb2xsZXIuc3RhcnRDYXBwaW5nKCk7IC8vIElmIGNhcHBpbmcgb2NjdXJzLCBuZXh0TGV2ZWxTd2l0Y2ggd2lsbCBoYXBwZW4gYmFzZWQgb24gc2l6ZS5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2FwTGV2ZWxDb250cm9sbGVyLnN0b3BDYXBwaW5nKCk7XG4gICAgICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IC0xO1xuICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7IC8vIE5vdyB3ZSdyZSB1bmNhcHBlZCwgZ2V0IHRoZSBuZXh0IGxldmVsIGFzYXAuXG4gICAgICB9XG4gICAgICB0aGlzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSA9IG5ld0NhcExldmVsVG9QbGF5ZXJTaXplO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYXBwaW5nL21heCBsZXZlbCB2YWx1ZSB0aGF0IHNob3VsZCBiZSB1c2VkIGJ5IGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb24gYWxnb3JpdGhtIChgQUJSQ29udHJvbGxlcmApXG4gICAqL1xuICBnZXQgYXV0b0xldmVsQ2FwcGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fYXV0b0xldmVsQ2FwcGluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGJhbmR3aWR0aCBlc3RpbWF0ZSBpbiBiaXRzIHBlciBzZWNvbmQsIHdoZW4gYXZhaWxhYmxlLiBPdGhlcndpc2UsIGBOYU5gIGlzIHJldHVybmVkLlxuICAgKi9cbiAgZ2V0IGJhbmR3aWR0aEVzdGltYXRlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGJ3RXN0aW1hdG9yXG4gICAgfSA9IHRoaXMuYWJyQ29udHJvbGxlcjtcbiAgICBpZiAoIWJ3RXN0aW1hdG9yKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICByZXR1cm4gYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGUoKTtcbiAgfVxuICBzZXQgYmFuZHdpZHRoRXN0aW1hdGUoYWJyRXdtYURlZmF1bHRFc3RpbWF0ZSkge1xuICAgIHRoaXMuYWJyQ29udHJvbGxlci5yZXNldEVzdGltYXRvcihhYnJFd21hRGVmYXVsdEVzdGltYXRlKTtcbiAgfVxuICBnZXQgYWJyRXdtYURlZmF1bHRFc3RpbWF0ZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBid0VzdGltYXRvclxuICAgIH0gPSB0aGlzLmFickNvbnRyb2xsZXI7XG4gICAgaWYgKCFid0VzdGltYXRvcikge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgcmV0dXJuIGJ3RXN0aW1hdG9yLmRlZmF1bHRFc3RpbWF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgdGltZSB0byBmaXJzdCBieXRlIGVzdGltYXRlXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgdHRmYkVzdGltYXRlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGJ3RXN0aW1hdG9yXG4gICAgfSA9IHRoaXMuYWJyQ29udHJvbGxlcjtcbiAgICBpZiAoIWJ3RXN0aW1hdG9yKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICByZXR1cm4gYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGVUVEZCKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FwcGluZy9tYXggbGV2ZWwgdmFsdWUgdGhhdCBzaG91bGQgYmUgdXNlZCBieSBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uIGFsZ29yaXRobSAoYEFCUkNvbnRyb2xsZXJgKVxuICAgKi9cbiAgc2V0IGF1dG9MZXZlbENhcHBpbmcobmV3TGV2ZWwpIHtcbiAgICBpZiAodGhpcy5fYXV0b0xldmVsQ2FwcGluZyAhPT0gbmV3TGV2ZWwpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhgc2V0IGF1dG9MZXZlbENhcHBpbmc6JHtuZXdMZXZlbH1gKTtcbiAgICAgIHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgPSBuZXdMZXZlbDtcbiAgICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLmNoZWNrTWF4QXV0b1VwZGF0ZWQoKTtcbiAgICB9XG4gIH1cbiAgZ2V0IG1heEhkY3BMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWF4SGRjcExldmVsO1xuICB9XG4gIHNldCBtYXhIZGNwTGV2ZWwodmFsdWUpIHtcbiAgICBpZiAoaXNIZGNwTGV2ZWwodmFsdWUpICYmIHRoaXMuX21heEhkY3BMZXZlbCAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX21heEhkY3BMZXZlbCA9IHZhbHVlO1xuICAgICAgdGhpcy5sZXZlbENvbnRyb2xsZXIuY2hlY2tNYXhBdXRvVXBkYXRlZCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcnVlIHdoZW4gYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbiBlbmFibGVkXG4gICAqL1xuICBnZXQgYXV0b0xldmVsRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWwgPT09IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIExldmVsIHNldCBtYW51YWxseSAoaWYgYW55KVxuICAgKi9cbiAgZ2V0IG1hbnVhbExldmVsKCkge1xuICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBtaW4gbGV2ZWwgc2VsZWN0YWJsZSBpbiBhdXRvIG1vZGUgYWNjb3JkaW5nIHRvIGNvbmZpZy5taW5BdXRvQml0cmF0ZVxuICAgKi9cbiAgZ2V0IG1pbkF1dG9MZXZlbCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBsZXZlbHMsXG4gICAgICBjb25maWc6IHtcbiAgICAgICAgbWluQXV0b0JpdHJhdGVcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWxldmVscykgcmV0dXJuIDA7XG4gICAgY29uc3QgbGVuID0gbGV2ZWxzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAobGV2ZWxzW2ldLm1heEJpdHJhdGUgPj0gbWluQXV0b0JpdHJhdGUpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIG1heCBsZXZlbCBzZWxlY3RhYmxlIGluIGF1dG8gbW9kZSBhY2NvcmRpbmcgdG8gYXV0b0xldmVsQ2FwcGluZ1xuICAgKi9cbiAgZ2V0IG1heEF1dG9MZXZlbCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBsZXZlbHMsXG4gICAgICBhdXRvTGV2ZWxDYXBwaW5nLFxuICAgICAgbWF4SGRjcExldmVsXG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IG1heEF1dG9MZXZlbDtcbiAgICBpZiAoYXV0b0xldmVsQ2FwcGluZyA9PT0gLTEgJiYgbGV2ZWxzICE9IG51bGwgJiYgbGV2ZWxzLmxlbmd0aCkge1xuICAgICAgbWF4QXV0b0xldmVsID0gbGV2ZWxzLmxlbmd0aCAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heEF1dG9MZXZlbCA9IGF1dG9MZXZlbENhcHBpbmc7XG4gICAgfVxuICAgIGlmIChtYXhIZGNwTGV2ZWwpIHtcbiAgICAgIGZvciAobGV0IGkgPSBtYXhBdXRvTGV2ZWw7IGktLTspIHtcbiAgICAgICAgY29uc3QgaGRjcExldmVsID0gbGV2ZWxzW2ldLmF0dHJzWydIRENQLUxFVkVMJ107XG4gICAgICAgIGlmIChoZGNwTGV2ZWwgJiYgaGRjcExldmVsIDw9IG1heEhkY3BMZXZlbCkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXhBdXRvTGV2ZWw7XG4gIH1cbiAgZ2V0IGZpcnN0QXV0b0xldmVsKCkge1xuICAgIHJldHVybiB0aGlzLmFickNvbnRyb2xsZXIuZmlyc3RBdXRvTGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogbmV4dCBhdXRvbWF0aWNhbGx5IHNlbGVjdGVkIHF1YWxpdHkgbGV2ZWxcbiAgICovXG4gIGdldCBuZXh0QXV0b0xldmVsKCkge1xuICAgIHJldHVybiB0aGlzLmFickNvbnRyb2xsZXIubmV4dEF1dG9MZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiB0aGlzIHNldHRlciBpcyB1c2VkIHRvIGZvcmNlIG5leHQgYXV0byBsZXZlbC5cbiAgICogdGhpcyBpcyB1c2VmdWwgdG8gZm9yY2UgYSBzd2l0Y2ggZG93biBpbiBhdXRvIG1vZGU6XG4gICAqIGluIGNhc2Ugb2YgbG9hZCBlcnJvciBvbiBsZXZlbCBOLCBobHMuanMgY2FuIHNldCBuZXh0QXV0b0xldmVsIHRvIE4tMSBmb3IgZXhhbXBsZSlcbiAgICogZm9yY2VkIHZhbHVlIGlzIHZhbGlkIGZvciBvbmUgZnJhZ21lbnQuIHVwb24gc3VjY2Vzc2Z1bCBmcmFnIGxvYWRpbmcgYXQgZm9yY2VkIGxldmVsLFxuICAgKiB0aGlzIHZhbHVlIHdpbGwgYmUgcmVzZXR0ZWQgdG8gLTEgYnkgQUJSIGNvbnRyb2xsZXIuXG4gICAqL1xuICBzZXQgbmV4dEF1dG9MZXZlbChuZXh0TGV2ZWwpIHtcbiAgICB0aGlzLmFickNvbnRyb2xsZXIubmV4dEF1dG9MZXZlbCA9IG5leHRMZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIGRhdGV0aW1lIHZhbHVlIHJlbGF0aXZlIHRvIG1lZGlhLmN1cnJlbnRUaW1lIGZvciB0aGUgYWN0aXZlIGxldmVsIFByb2dyYW0gRGF0ZSBUaW1lIGlmIHByZXNlbnRcbiAgICovXG4gIGdldCBwbGF5aW5nRGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmN1cnJlbnRQcm9ncmFtRGF0ZVRpbWU7XG4gIH1cbiAgZ2V0IG1haW5Gb3J3YXJkQnVmZmVySW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmdldE1haW5Gd2RCdWZmZXJJbmZvKCk7XG4gIH1cbiAgZ2V0IG1heEJ1ZmZlckxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLm1heEJ1ZmZlckxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIGFuZCBzZWxlY3QgdGhlIGJlc3QgbWF0Y2hpbmcgYXVkaW8gdHJhY2ssIG1ha2luZyBhIGxldmVsIHN3aXRjaCB3aGVuIGEgR3JvdXAgY2hhbmdlIGlzIG5lY2Vzc2FyeS5cbiAgICogVXBkYXRlcyBgaGxzLmNvbmZpZy5hdWRpb1ByZWZlcmVuY2VgLiBSZXR1cm5zIHRoZSBzZWxlY3RlZCB0cmFjaywgb3IgbnVsbCB3aGVuIG5vIG1hdGNoaW5nIHRyYWNrIGlzIGZvdW5kLlxuICAgKi9cbiAgc2V0QXVkaW9PcHRpb24oYXVkaW9PcHRpb24pIHtcbiAgICB2YXIgX3RoaXMkYXVkaW9UcmFja0NvbnRyO1xuICAgIHJldHVybiAoKF90aGlzJGF1ZGlvVHJhY2tDb250ciA9IHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXIpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRhdWRpb1RyYWNrQ29udHIuc2V0QXVkaW9PcHRpb24oYXVkaW9PcHRpb24pKSB8fCBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kIGFuZCBzZWxlY3QgdGhlIGJlc3QgbWF0Y2hpbmcgc3VidGl0bGUgdHJhY2ssIG1ha2luZyBhIGxldmVsIHN3aXRjaCB3aGVuIGEgR3JvdXAgY2hhbmdlIGlzIG5lY2Vzc2FyeS5cbiAgICogVXBkYXRlcyBgaGxzLmNvbmZpZy5zdWJ0aXRsZVByZWZlcmVuY2VgLiBSZXR1cm5zIHRoZSBzZWxlY3RlZCB0cmFjaywgb3IgbnVsbCB3aGVuIG5vIG1hdGNoaW5nIHRyYWNrIGlzIGZvdW5kLlxuICAgKi9cbiAgc2V0U3VidGl0bGVPcHRpb24oc3VidGl0bGVPcHRpb24pIHtcbiAgICB2YXIgX3RoaXMkc3VidGl0bGVUcmFja0NvO1xuICAgIHJldHVybiAoKF90aGlzJHN1YnRpdGxlVHJhY2tDbyA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXIpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRzdWJ0aXRsZVRyYWNrQ28uc2V0U3VidGl0bGVPcHRpb24oc3VidGl0bGVPcHRpb24pKSB8fCBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY29tcGxldGUgbGlzdCBvZiBhdWRpbyB0cmFja3MgYWNyb3NzIGFsbCBtZWRpYSBncm91cHNcbiAgICovXG4gIGdldCBhbGxBdWRpb1RyYWNrcygpIHtcbiAgICBjb25zdCBhdWRpb1RyYWNrQ29udHJvbGxlciA9IHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXI7XG4gICAgcmV0dXJuIGF1ZGlvVHJhY2tDb250cm9sbGVyID8gYXVkaW9UcmFja0NvbnRyb2xsZXIuYWxsQXVkaW9UcmFja3MgOiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxpc3Qgb2Ygc2VsZWN0YWJsZSBhdWRpbyB0cmFja3NcbiAgICovXG4gIGdldCBhdWRpb1RyYWNrcygpIHtcbiAgICBjb25zdCBhdWRpb1RyYWNrQ29udHJvbGxlciA9IHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXI7XG4gICAgcmV0dXJuIGF1ZGlvVHJhY2tDb250cm9sbGVyID8gYXVkaW9UcmFja0NvbnRyb2xsZXIuYXVkaW9UcmFja3MgOiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgYXVkaW8gdHJhY2sgKGluZGV4IGluIGF1ZGlvIHRyYWNrIGxpc3RzKVxuICAgKi9cbiAgZ2V0IGF1ZGlvVHJhY2soKSB7XG4gICAgY29uc3QgYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAgIHJldHVybiBhdWRpb1RyYWNrQ29udHJvbGxlciA/IGF1ZGlvVHJhY2tDb250cm9sbGVyLmF1ZGlvVHJhY2sgOiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBzZWxlY3RzIGFuIGF1ZGlvIHRyYWNrLCBiYXNlZCBvbiBpdHMgaW5kZXggaW4gYXVkaW8gdHJhY2sgbGlzdHNcbiAgICovXG4gIHNldCBhdWRpb1RyYWNrKGF1ZGlvVHJhY2tJZCkge1xuICAgIGNvbnN0IGF1ZGlvVHJhY2tDb250cm9sbGVyID0gdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlcjtcbiAgICBpZiAoYXVkaW9UcmFja0NvbnRyb2xsZXIpIHtcbiAgICAgIGF1ZGlvVHJhY2tDb250cm9sbGVyLmF1ZGlvVHJhY2sgPSBhdWRpb1RyYWNrSWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGdldCB0aGUgY29tcGxldGUgbGlzdCBvZiBzdWJ0aXRsZSB0cmFja3MgYWNyb3NzIGFsbCBtZWRpYSBncm91cHNcbiAgICovXG4gIGdldCBhbGxTdWJ0aXRsZVRyYWNrcygpIHtcbiAgICBjb25zdCBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgcmV0dXJuIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID8gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuYWxsU3VidGl0bGVUcmFja3MgOiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgYWx0ZXJuYXRlIHN1YnRpdGxlIHRyYWNrcyBsaXN0IGZyb20gcGxheWxpc3RcbiAgICovXG4gIGdldCBzdWJ0aXRsZVRyYWNrcygpIHtcbiAgICBjb25zdCBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgcmV0dXJuIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID8gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVUcmFja3MgOiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgc3VidGl0bGUgdHJhY2sgKGluZGV4IGluIHN1YnRpdGxlIHRyYWNrIGxpc3RzKVxuICAgKi9cbiAgZ2V0IHN1YnRpdGxlVHJhY2soKSB7XG4gICAgY29uc3Qgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgIHJldHVybiBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA/IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlVHJhY2sgOiAtMTtcbiAgfVxuICBnZXQgbWVkaWEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lZGlhO1xuICB9XG5cbiAgLyoqXG4gICAqIHNlbGVjdCBhbiBzdWJ0aXRsZSB0cmFjaywgYmFzZWQgb24gaXRzIGluZGV4IGluIHN1YnRpdGxlIHRyYWNrIGxpc3RzXG4gICAqL1xuICBzZXQgc3VidGl0bGVUcmFjayhzdWJ0aXRsZVRyYWNrSWQpIHtcbiAgICBjb25zdCBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgaWYgKHN1YnRpdGxlVHJhY2tDb250cm9sbGVyKSB7XG4gICAgICBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5zdWJ0aXRsZVRyYWNrID0gc3VidGl0bGVUcmFja0lkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHN1YnRpdGxlIGRpc3BsYXkgaXMgZW5hYmxlZCBvciBub3RcbiAgICovXG4gIGdldCBzdWJ0aXRsZURpc3BsYXkoKSB7XG4gICAgY29uc3Qgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgIHJldHVybiBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA/IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlRGlzcGxheSA6IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuYWJsZS9kaXNhYmxlIHN1YnRpdGxlIGRpc3BsYXkgcmVuZGVyaW5nXG4gICAqL1xuICBzZXQgc3VidGl0bGVEaXNwbGF5KHZhbHVlKSB7XG4gICAgY29uc3Qgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgIGlmIChzdWJ0aXRsZVRyYWNrQ29udHJvbGxlcikge1xuICAgICAgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVEaXNwbGF5ID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGdldCBtb2RlIGZvciBMb3ctTGF0ZW5jeSBITFMgbG9hZGluZ1xuICAgKi9cbiAgZ2V0IGxvd0xhdGVuY3lNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGUvZGlzYWJsZSBMb3ctTGF0ZW5jeSBITFMgcGFydCBwbGF5bGlzdCBhbmQgc2VnbWVudCBsb2FkaW5nLCBhbmQgc3RhcnQgbGl2ZSBzdHJlYW1zIGF0IHBsYXlsaXN0IFBBUlQtSE9MRC1CQUNLIHJhdGhlciB0aGFuIEhPTEQtQkFDSy5cbiAgICovXG4gIHNldCBsb3dMYXRlbmN5TW9kZShtb2RlKSB7XG4gICAgdGhpcy5jb25maWcubG93TGF0ZW5jeU1vZGUgPSBtb2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIFBvc2l0aW9uIChpbiBzZWNvbmRzKSBvZiBsaXZlIHN5bmMgcG9pbnQgKGllIGVkZ2Ugb2YgbGl2ZSBwb3NpdGlvbiBtaW51cyBzYWZldHkgZGVsYXkgZGVmaW5lZCBieSBgYGBobHMuY29uZmlnLmxpdmVTeW5jRHVyYXRpb25gYGApXG4gICAqIEByZXR1cm5zIG51bGwgcHJpb3IgdG8gbG9hZGluZyBsaXZlIFBsYXlsaXN0XG4gICAqL1xuICBnZXQgbGl2ZVN5bmNQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5sYXRlbmN5Q29udHJvbGxlci5saXZlU3luY1Bvc2l0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEVzdGltYXRlZCBwb3NpdGlvbiAoaW4gc2Vjb25kcykgb2YgbGl2ZSBlZGdlIChpZSBlZGdlIG9mIGxpdmUgcGxheWxpc3QgcGx1cyB0aW1lIHN5bmMgcGxheWxpc3QgYWR2YW5jZWQpXG4gICAqIEByZXR1cm5zIDAgYmVmb3JlIGZpcnN0IHBsYXlsaXN0IGlzIGxvYWRlZFxuICAgKi9cbiAgZ2V0IGxhdGVuY3koKSB7XG4gICAgcmV0dXJuIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIubGF0ZW5jeTtcbiAgfVxuXG4gIC8qKlxuICAgKiBtYXhpbXVtIGRpc3RhbmNlIGZyb20gdGhlIGVkZ2UgYmVmb3JlIHRoZSBwbGF5ZXIgc2Vla3MgZm9yd2FyZCB0byBgYGBobHMubGl2ZVN5bmNQb3NpdGlvbmBgYFxuICAgKiBjb25maWd1cmVkIHVzaW5nIGBgYGxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudGBgYCAobXVsdGlwbGUgb2YgdGFyZ2V0IGR1cmF0aW9uKSBvciBgYGBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uYGBgXG4gICAqIEByZXR1cm5zIDAgYmVmb3JlIGZpcnN0IHBsYXlsaXN0IGlzIGxvYWRlZFxuICAgKi9cbiAgZ2V0IG1heExhdGVuY3koKSB7XG4gICAgcmV0dXJuIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIubWF4TGF0ZW5jeTtcbiAgfVxuXG4gIC8qKlxuICAgKiB0YXJnZXQgZGlzdGFuY2UgZnJvbSB0aGUgZWRnZSBhcyBjYWxjdWxhdGVkIGJ5IHRoZSBsYXRlbmN5IGNvbnRyb2xsZXJcbiAgICovXG4gIGdldCB0YXJnZXRMYXRlbmN5KCkge1xuICAgIHJldHVybiB0aGlzLmxhdGVuY3lDb250cm9sbGVyLnRhcmdldExhdGVuY3k7XG4gIH1cbiAgc2V0IHRhcmdldExhdGVuY3kobGF0ZW5jeSkge1xuICAgIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIudGFyZ2V0TGF0ZW5jeSA9IGxhdGVuY3k7XG4gIH1cblxuICAvKipcbiAgICogdGhlIHJhdGUgYXQgd2hpY2ggdGhlIGVkZ2Ugb2YgdGhlIGN1cnJlbnQgbGl2ZSBwbGF5bGlzdCBpcyBhZHZhbmNpbmcgb3IgMSBpZiB0aGVyZSBpcyBub25lXG4gICAqL1xuICBnZXQgZHJpZnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIuZHJpZnQ7XG4gIH1cblxuICAvKipcbiAgICogc2V0IHRvIHRydWUgd2hlbiBzdGFydExvYWQgaXMgY2FsbGVkIGJlZm9yZSBNQU5JRkVTVF9QQVJTRUQgZXZlbnRcbiAgICovXG4gIGdldCBmb3JjZVN0YXJ0TG9hZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmZvcmNlU3RhcnRMb2FkO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnRlbnRTdGVlcmluZyBwYXRod2F5cyBnZXR0ZXJcbiAgICovXG4gIGdldCBwYXRod2F5cygpIHtcbiAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIucGF0aHdheXM7XG4gIH1cblxuICAvKipcbiAgICogQ29udGVudFN0ZWVyaW5nIHBhdGh3YXlQcmlvcml0eSBnZXR0ZXIvc2V0dGVyXG4gICAqL1xuICBnZXQgcGF0aHdheVByaW9yaXR5KCkge1xuICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5wYXRod2F5UHJpb3JpdHk7XG4gIH1cbiAgc2V0IHBhdGh3YXlQcmlvcml0eShwYXRod2F5UHJpb3JpdHkpIHtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5wYXRod2F5UHJpb3JpdHkgPSBwYXRod2F5UHJpb3JpdHk7XG4gIH1cblxuICAvKipcbiAgICogcmV0dXJucyB0cnVlIHdoZW4gYWxsIFNvdXJjZUJ1ZmZlcnMgYXJlIGJ1ZmZlcmVkIHRvIHRoZSBlbmRcbiAgICovXG4gIGdldCBidWZmZXJlZFRvRW5kKCkge1xuICAgIHZhciBfdGhpcyRidWZmZXJDb250cm9sbGU7XG4gICAgcmV0dXJuICEhKChfdGhpcyRidWZmZXJDb250cm9sbGUgPSB0aGlzLmJ1ZmZlckNvbnRyb2xsZXIpICE9IG51bGwgJiYgX3RoaXMkYnVmZmVyQ29udHJvbGxlLmJ1ZmZlcmVkVG9FbmQpO1xuICB9XG5cbiAgLyoqXG4gICAqIHJldHVybnMgSW50ZXJzdGl0aWFscyBQcm9ncmFtIE1hbmFnZXJcbiAgICovXG4gIGdldCBpbnRlcnN0aXRpYWxzTWFuYWdlcigpIHtcbiAgICB2YXIgX3RoaXMkaW50ZXJzdGl0aWFsc0NvO1xuICAgIHJldHVybiAoKF90aGlzJGludGVyc3RpdGlhbHNDbyA9IHRoaXMuaW50ZXJzdGl0aWFsc0NvbnRyb2xsZXIpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRpbnRlcnN0aXRpYWxzQ28uaW50ZXJzdGl0aWFsc01hbmFnZXIpIHx8IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogcmV0dXJucyBtZWRpYUNhcGFiaWxpdGllcy5kZWNvZGluZ0luZm8gZm9yIGEgdmFyaWFudC9yZW5kaXRpb25cbiAgICovXG4gIGdldE1lZGlhRGVjb2RpbmdJbmZvKGxldmVsLCBhdWRpb1RyYWNrcyA9IHRoaXMuYWxsQXVkaW9UcmFja3MpIHtcbiAgICBjb25zdCBhdWRpb1RyYWNrc0J5R3JvdXAgPSBnZXRBdWRpb1RyYWNrc0J5R3JvdXAoYXVkaW9UcmFja3MpO1xuICAgIHJldHVybiBnZXRNZWRpYURlY29kaW5nSW5mb1Byb21pc2UobGV2ZWwsIGF1ZGlvVHJhY2tzQnlHcm91cCwgbmF2aWdhdG9yLm1lZGlhQ2FwYWJpbGl0aWVzKTtcbiAgfVxufVxuSGxzLmRlZmF1bHRDb25maWcgPSB2b2lkIDA7XG5cbmV4cG9ydCB7IEFickNvbnRyb2xsZXIsIEF0dHJMaXN0LCBBdWRpb1N0cmVhbUNvbnRyb2xsZXIsIEF1ZGlvVHJhY2tDb250cm9sbGVyLCBCYXNlUGxheWxpc3RDb250cm9sbGVyLCBCYXNlU2VnbWVudCwgQmFzZVN0cmVhbUNvbnRyb2xsZXIsIEJ1ZmZlckNvbnRyb2xsZXIsIENNQ0RDb250cm9sbGVyLCBDYXBMZXZlbENvbnRyb2xsZXIsIENodW5rTWV0YWRhdGEsIENvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXIsIEN1ZXMsIERhdGVSYW5nZSwgRU1FQ29udHJvbGxlciwgRXJyb3JBY3Rpb25GbGFncywgRXJyb3JDb250cm9sbGVyLCBFcnJvckRldGFpbHMsIEVycm9yVHlwZXMsIEV2ZW50cywgRlBTQ29udHJvbGxlciwgRmV0Y2hMb2FkZXIsIEZyYWdtZW50LCBIbHMsIEhsc1NraXAsIEhsc1VybFBhcmFtZXRlcnMsIEtleVN5c3RlbUZvcm1hdHMsIEtleVN5c3RlbXMsIExldmVsLCBMZXZlbERldGFpbHMsIExldmVsS2V5LCBMb2FkU3RhdHMsIE0zVThQYXJzZXIsIE1ldGFkYXRhU2NoZW1hLCBOZXR3b3JrRXJyb3JBY3Rpb24sIFBhcnQsIFBsYXlsaXN0TGV2ZWxUeXBlLCBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIsIFN1YnRpdGxlVHJhY2tDb250cm9sbGVyLCBUaW1lbGluZUNvbnRyb2xsZXIsIFhockxvYWRlciwgSGxzIGFzIGRlZmF1bHQsIGZldGNoU3VwcG9ydGVkLCBnZXRNZWRpYVNvdXJjZSwgaXNNU0VTdXBwb3J0ZWQsIGlzU3VwcG9ydGVkLCByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhscy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/hls.js/dist/hls.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/media-tracks/dist/audio-rendition-list.js":
/*!****************************************************************!*\
  !*** ./node_modules/media-tracks/dist/audio-rendition-list.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AudioRenditionList: () => (/* binding */ AudioRenditionList),\n/* harmony export */   addRendition: () => (/* binding */ addRendition),\n/* harmony export */   removeRendition: () => (/* binding */ removeRendition),\n/* harmony export */   selectedChanged: () => (/* binding */ selectedChanged)\n/* harmony export */ });\n/* harmony import */ var _rendition_event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rendition-event.js */ \"(app-pages-browser)/./node_modules/media-tracks/dist/rendition-event.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/media-tracks/dist/utils.js\");\n\n\nfunction addRendition(track, rendition) {\n  const renditionList = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(track).media.audioRenditions;\n  (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(rendition).media = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(track).media;\n  (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(rendition).track = track;\n  const renditionSet = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(track).renditionSet;\n  renditionSet.add(rendition);\n  const index = renditionSet.size - 1;\n  if (!(index in AudioRenditionList.prototype)) {\n    Object.defineProperty(AudioRenditionList.prototype, index, {\n      get() {\n        return getCurrentRenditions(this)[index];\n      }\n    });\n  }\n  queueMicrotask(() => {\n    if (!track.enabled) return;\n    renditionList.dispatchEvent(new _rendition_event_js__WEBPACK_IMPORTED_MODULE_0__.RenditionEvent(\"addrendition\", { rendition }));\n  });\n}\nfunction removeRendition(rendition) {\n  const renditionList = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(rendition).media.audioRenditions;\n  const track = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(rendition).track;\n  const renditionSet = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(track).renditionSet;\n  renditionSet.delete(rendition);\n  queueMicrotask(() => {\n    const track2 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(rendition).track;\n    if (!track2.enabled) return;\n    renditionList.dispatchEvent(new _rendition_event_js__WEBPACK_IMPORTED_MODULE_0__.RenditionEvent(\"removerendition\", { rendition }));\n  });\n}\nfunction selectedChanged(rendition) {\n  const renditionList = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(rendition).media.audioRenditions;\n  if (!renditionList || (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(renditionList).changeRequested) return;\n  (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(renditionList).changeRequested = true;\n  queueMicrotask(() => {\n    delete (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(renditionList).changeRequested;\n    const track = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(rendition).track;\n    if (!track.enabled) return;\n    renditionList.dispatchEvent(new Event(\"change\"));\n  });\n}\nfunction getCurrentRenditions(renditionList) {\n  const media = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(renditionList).media;\n  return [...media.audioTracks].filter((track) => track.enabled).flatMap((track) => [...(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(track).renditionSet]);\n}\nclass AudioRenditionList extends EventTarget {\n  #addRenditionCallback;\n  #removeRenditionCallback;\n  #changeCallback;\n  [Symbol.iterator]() {\n    return getCurrentRenditions(this).values();\n  }\n  get length() {\n    return getCurrentRenditions(this).length;\n  }\n  getRenditionById(id) {\n    return getCurrentRenditions(this).find((rendition) => `${rendition.id}` === `${id}`) ?? null;\n  }\n  get selectedIndex() {\n    return getCurrentRenditions(this).findIndex((rendition) => rendition.selected);\n  }\n  set selectedIndex(index) {\n    for (const [i, rendition] of getCurrentRenditions(this).entries()) {\n      rendition.selected = i === index;\n    }\n  }\n  get onaddrendition() {\n    return this.#addRenditionCallback;\n  }\n  set onaddrendition(callback) {\n    if (this.#addRenditionCallback) {\n      this.removeEventListener(\"addrendition\", this.#addRenditionCallback);\n      this.#addRenditionCallback = void 0;\n    }\n    if (typeof callback == \"function\") {\n      this.#addRenditionCallback = callback;\n      this.addEventListener(\"addrendition\", callback);\n    }\n  }\n  get onremoverendition() {\n    return this.#removeRenditionCallback;\n  }\n  set onremoverendition(callback) {\n    if (this.#removeRenditionCallback) {\n      this.removeEventListener(\"removerendition\", this.#removeRenditionCallback);\n      this.#removeRenditionCallback = void 0;\n    }\n    if (typeof callback == \"function\") {\n      this.#removeRenditionCallback = callback;\n      this.addEventListener(\"removerendition\", callback);\n    }\n  }\n  get onchange() {\n    return this.#changeCallback;\n  }\n  set onchange(callback) {\n    if (this.#changeCallback) {\n      this.removeEventListener(\"change\", this.#changeCallback);\n      this.#changeCallback = void 0;\n    }\n    if (typeof callback == \"function\") {\n      this.#changeCallback = callback;\n      this.addEventListener(\"change\", callback);\n    }\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZWRpYS10cmFja3MvZGlzdC9hdWRpby1yZW5kaXRpb24tbGlzdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBc0Q7QUFDZDtBQUN4QztBQUNBLHdCQUF3QixxREFBVTtBQUNsQyxFQUFFLHFEQUFVLG9CQUFvQixxREFBVTtBQUMxQyxFQUFFLHFEQUFVO0FBQ1osdUJBQXVCLHFEQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywrREFBYyxtQkFBbUIsV0FBVztBQUNoRixHQUFHO0FBQ0g7QUFDQTtBQUNBLHdCQUF3QixxREFBVTtBQUNsQyxnQkFBZ0IscURBQVU7QUFDMUIsdUJBQXVCLHFEQUFVO0FBQ2pDO0FBQ0E7QUFDQSxtQkFBbUIscURBQVU7QUFDN0I7QUFDQSxvQ0FBb0MsK0RBQWMsc0JBQXNCLFdBQVc7QUFDbkYsR0FBRztBQUNIO0FBQ0E7QUFDQSx3QkFBd0IscURBQVU7QUFDbEMsd0JBQXdCLHFEQUFVO0FBQ2xDLEVBQUUscURBQVU7QUFDWjtBQUNBLFdBQVcscURBQVU7QUFDckIsa0JBQWtCLHFEQUFVO0FBQzVCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdCQUFnQixxREFBVTtBQUMxQix3RkFBd0YscURBQVU7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGFBQWEsU0FBUyxHQUFHO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9FdGhhbkxlZS9EZXNrdG9wL0FkdlgvQUktV2F0Y2gtQnVkZHkvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL21lZGlhLXRyYWNrcy9kaXN0L2F1ZGlvLXJlbmRpdGlvbi1saXN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlbmRpdGlvbkV2ZW50IH0gZnJvbSBcIi4vcmVuZGl0aW9uLWV2ZW50LmpzXCI7XG5pbXBvcnQgeyBnZXRQcml2YXRlIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbmZ1bmN0aW9uIGFkZFJlbmRpdGlvbih0cmFjaywgcmVuZGl0aW9uKSB7XG4gIGNvbnN0IHJlbmRpdGlvbkxpc3QgPSBnZXRQcml2YXRlKHRyYWNrKS5tZWRpYS5hdWRpb1JlbmRpdGlvbnM7XG4gIGdldFByaXZhdGUocmVuZGl0aW9uKS5tZWRpYSA9IGdldFByaXZhdGUodHJhY2spLm1lZGlhO1xuICBnZXRQcml2YXRlKHJlbmRpdGlvbikudHJhY2sgPSB0cmFjaztcbiAgY29uc3QgcmVuZGl0aW9uU2V0ID0gZ2V0UHJpdmF0ZSh0cmFjaykucmVuZGl0aW9uU2V0O1xuICByZW5kaXRpb25TZXQuYWRkKHJlbmRpdGlvbik7XG4gIGNvbnN0IGluZGV4ID0gcmVuZGl0aW9uU2V0LnNpemUgLSAxO1xuICBpZiAoIShpbmRleCBpbiBBdWRpb1JlbmRpdGlvbkxpc3QucHJvdG90eXBlKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBdWRpb1JlbmRpdGlvbkxpc3QucHJvdG90eXBlLCBpbmRleCwge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gZ2V0Q3VycmVudFJlbmRpdGlvbnModGhpcylbaW5kZXhdO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICBpZiAoIXRyYWNrLmVuYWJsZWQpIHJldHVybjtcbiAgICByZW5kaXRpb25MaXN0LmRpc3BhdGNoRXZlbnQobmV3IFJlbmRpdGlvbkV2ZW50KFwiYWRkcmVuZGl0aW9uXCIsIHsgcmVuZGl0aW9uIH0pKTtcbiAgfSk7XG59XG5mdW5jdGlvbiByZW1vdmVSZW5kaXRpb24ocmVuZGl0aW9uKSB7XG4gIGNvbnN0IHJlbmRpdGlvbkxpc3QgPSBnZXRQcml2YXRlKHJlbmRpdGlvbikubWVkaWEuYXVkaW9SZW5kaXRpb25zO1xuICBjb25zdCB0cmFjayA9IGdldFByaXZhdGUocmVuZGl0aW9uKS50cmFjaztcbiAgY29uc3QgcmVuZGl0aW9uU2V0ID0gZ2V0UHJpdmF0ZSh0cmFjaykucmVuZGl0aW9uU2V0O1xuICByZW5kaXRpb25TZXQuZGVsZXRlKHJlbmRpdGlvbik7XG4gIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICBjb25zdCB0cmFjazIgPSBnZXRQcml2YXRlKHJlbmRpdGlvbikudHJhY2s7XG4gICAgaWYgKCF0cmFjazIuZW5hYmxlZCkgcmV0dXJuO1xuICAgIHJlbmRpdGlvbkxpc3QuZGlzcGF0Y2hFdmVudChuZXcgUmVuZGl0aW9uRXZlbnQoXCJyZW1vdmVyZW5kaXRpb25cIiwgeyByZW5kaXRpb24gfSkpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHNlbGVjdGVkQ2hhbmdlZChyZW5kaXRpb24pIHtcbiAgY29uc3QgcmVuZGl0aW9uTGlzdCA9IGdldFByaXZhdGUocmVuZGl0aW9uKS5tZWRpYS5hdWRpb1JlbmRpdGlvbnM7XG4gIGlmICghcmVuZGl0aW9uTGlzdCB8fCBnZXRQcml2YXRlKHJlbmRpdGlvbkxpc3QpLmNoYW5nZVJlcXVlc3RlZCkgcmV0dXJuO1xuICBnZXRQcml2YXRlKHJlbmRpdGlvbkxpc3QpLmNoYW5nZVJlcXVlc3RlZCA9IHRydWU7XG4gIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICBkZWxldGUgZ2V0UHJpdmF0ZShyZW5kaXRpb25MaXN0KS5jaGFuZ2VSZXF1ZXN0ZWQ7XG4gICAgY29uc3QgdHJhY2sgPSBnZXRQcml2YXRlKHJlbmRpdGlvbikudHJhY2s7XG4gICAgaWYgKCF0cmFjay5lbmFibGVkKSByZXR1cm47XG4gICAgcmVuZGl0aW9uTGlzdC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcImNoYW5nZVwiKSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0Q3VycmVudFJlbmRpdGlvbnMocmVuZGl0aW9uTGlzdCkge1xuICBjb25zdCBtZWRpYSA9IGdldFByaXZhdGUocmVuZGl0aW9uTGlzdCkubWVkaWE7XG4gIHJldHVybiBbLi4ubWVkaWEuYXVkaW9UcmFja3NdLmZpbHRlcigodHJhY2spID0+IHRyYWNrLmVuYWJsZWQpLmZsYXRNYXAoKHRyYWNrKSA9PiBbLi4uZ2V0UHJpdmF0ZSh0cmFjaykucmVuZGl0aW9uU2V0XSk7XG59XG5jbGFzcyBBdWRpb1JlbmRpdGlvbkxpc3QgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gICNhZGRSZW5kaXRpb25DYWxsYmFjaztcbiAgI3JlbW92ZVJlbmRpdGlvbkNhbGxiYWNrO1xuICAjY2hhbmdlQ2FsbGJhY2s7XG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiBnZXRDdXJyZW50UmVuZGl0aW9ucyh0aGlzKS52YWx1ZXMoKTtcbiAgfVxuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiBnZXRDdXJyZW50UmVuZGl0aW9ucyh0aGlzKS5sZW5ndGg7XG4gIH1cbiAgZ2V0UmVuZGl0aW9uQnlJZChpZCkge1xuICAgIHJldHVybiBnZXRDdXJyZW50UmVuZGl0aW9ucyh0aGlzKS5maW5kKChyZW5kaXRpb24pID0+IGAke3JlbmRpdGlvbi5pZH1gID09PSBgJHtpZH1gKSA/PyBudWxsO1xuICB9XG4gIGdldCBzZWxlY3RlZEluZGV4KCkge1xuICAgIHJldHVybiBnZXRDdXJyZW50UmVuZGl0aW9ucyh0aGlzKS5maW5kSW5kZXgoKHJlbmRpdGlvbikgPT4gcmVuZGl0aW9uLnNlbGVjdGVkKTtcbiAgfVxuICBzZXQgc2VsZWN0ZWRJbmRleChpbmRleCkge1xuICAgIGZvciAoY29uc3QgW2ksIHJlbmRpdGlvbl0gb2YgZ2V0Q3VycmVudFJlbmRpdGlvbnModGhpcykuZW50cmllcygpKSB7XG4gICAgICByZW5kaXRpb24uc2VsZWN0ZWQgPSBpID09PSBpbmRleDtcbiAgICB9XG4gIH1cbiAgZ2V0IG9uYWRkcmVuZGl0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLiNhZGRSZW5kaXRpb25DYWxsYmFjaztcbiAgfVxuICBzZXQgb25hZGRyZW5kaXRpb24oY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy4jYWRkUmVuZGl0aW9uQ2FsbGJhY2spIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFkZHJlbmRpdGlvblwiLCB0aGlzLiNhZGRSZW5kaXRpb25DYWxsYmFjayk7XG4gICAgICB0aGlzLiNhZGRSZW5kaXRpb25DYWxsYmFjayA9IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRoaXMuI2FkZFJlbmRpdGlvbkNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJhZGRyZW5kaXRpb25cIiwgY2FsbGJhY2spO1xuICAgIH1cbiAgfVxuICBnZXQgb25yZW1vdmVyZW5kaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JlbW92ZVJlbmRpdGlvbkNhbGxiYWNrO1xuICB9XG4gIHNldCBvbnJlbW92ZXJlbmRpdGlvbihjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLiNyZW1vdmVSZW5kaXRpb25DYWxsYmFjaykge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVtb3ZlcmVuZGl0aW9uXCIsIHRoaXMuI3JlbW92ZVJlbmRpdGlvbkNhbGxiYWNrKTtcbiAgICAgIHRoaXMuI3JlbW92ZVJlbmRpdGlvbkNhbGxiYWNrID0gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhpcy4jcmVtb3ZlUmVuZGl0aW9uQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcInJlbW92ZXJlbmRpdGlvblwiLCBjYWxsYmFjayk7XG4gICAgfVxuICB9XG4gIGdldCBvbmNoYW5nZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jY2hhbmdlQ2FsbGJhY2s7XG4gIH1cbiAgc2V0IG9uY2hhbmdlKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuI2NoYW5nZUNhbGxiYWNrKSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgdGhpcy4jY2hhbmdlQ2FsbGJhY2spO1xuICAgICAgdGhpcy4jY2hhbmdlQ2FsbGJhY2sgPSB2b2lkIDA7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aGlzLiNjaGFuZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCB7XG4gIEF1ZGlvUmVuZGl0aW9uTGlzdCxcbiAgYWRkUmVuZGl0aW9uLFxuICByZW1vdmVSZW5kaXRpb24sXG4gIHNlbGVjdGVkQ2hhbmdlZFxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/media-tracks/dist/audio-rendition-list.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/media-tracks/dist/audio-rendition.js":
/*!***********************************************************!*\
  !*** ./node_modules/media-tracks/dist/audio-rendition.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AudioRendition: () => (/* binding */ AudioRendition)\n/* harmony export */ });\n/* harmony import */ var _audio_rendition_list_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./audio-rendition-list.js */ \"(app-pages-browser)/./node_modules/media-tracks/dist/audio-rendition-list.js\");\n\nclass AudioRendition {\n  src;\n  id;\n  bitrate;\n  codec;\n  #selected = false;\n  get selected() {\n    return this.#selected;\n  }\n  set selected(val) {\n    if (this.#selected === val) return;\n    this.#selected = val;\n    (0,_audio_rendition_list_js__WEBPACK_IMPORTED_MODULE_0__.selectedChanged)(this);\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZWRpYS10cmFja3MvZGlzdC9hdWRpby1yZW5kaXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx5RUFBZTtBQUNuQjtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIi9Vc2Vycy9FdGhhbkxlZS9EZXNrdG9wL0FkdlgvQUktV2F0Y2gtQnVkZHkvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL21lZGlhLXRyYWNrcy9kaXN0L2F1ZGlvLXJlbmRpdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzZWxlY3RlZENoYW5nZWQgfSBmcm9tIFwiLi9hdWRpby1yZW5kaXRpb24tbGlzdC5qc1wiO1xuY2xhc3MgQXVkaW9SZW5kaXRpb24ge1xuICBzcmM7XG4gIGlkO1xuICBiaXRyYXRlO1xuICBjb2RlYztcbiAgI3NlbGVjdGVkID0gZmFsc2U7XG4gIGdldCBzZWxlY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy4jc2VsZWN0ZWQ7XG4gIH1cbiAgc2V0IHNlbGVjdGVkKHZhbCkge1xuICAgIGlmICh0aGlzLiNzZWxlY3RlZCA9PT0gdmFsKSByZXR1cm47XG4gICAgdGhpcy4jc2VsZWN0ZWQgPSB2YWw7XG4gICAgc2VsZWN0ZWRDaGFuZ2VkKHRoaXMpO1xuICB9XG59XG5leHBvcnQge1xuICBBdWRpb1JlbmRpdGlvblxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/media-tracks/dist/audio-rendition.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/media-tracks/dist/audio-track-list.js":
/*!************************************************************!*\
  !*** ./node_modules/media-tracks/dist/audio-track-list.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AudioTrackList: () => (/* binding */ AudioTrackList),\n/* harmony export */   addAudioTrack: () => (/* binding */ addAudioTrack),\n/* harmony export */   enabledChanged: () => (/* binding */ enabledChanged),\n/* harmony export */   removeAudioTrack: () => (/* binding */ removeAudioTrack)\n/* harmony export */ });\n/* harmony import */ var _track_event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./track-event.js */ \"(app-pages-browser)/./node_modules/media-tracks/dist/track-event.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/media-tracks/dist/utils.js\");\n\n\nfunction addAudioTrack(media, track) {\n  const trackList = media.audioTracks;\n  (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(track).media = media;\n  if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(track).renditionSet) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(track).renditionSet = /* @__PURE__ */ new Set();\n  }\n  const trackSet = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(trackList).trackSet;\n  trackSet.add(track);\n  const index = trackSet.size - 1;\n  if (!(index in AudioTrackList.prototype)) {\n    Object.defineProperty(AudioTrackList.prototype, index, {\n      get() {\n        return [...(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(this).trackSet][index];\n      }\n    });\n  }\n  queueMicrotask(() => {\n    trackList.dispatchEvent(new _track_event_js__WEBPACK_IMPORTED_MODULE_0__.TrackEvent(\"addtrack\", { track }));\n  });\n}\nfunction removeAudioTrack(track) {\n  const trackList = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(track).media?.audioTracks;\n  if (!trackList) return;\n  const trackSet = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(trackList).trackSet;\n  trackSet.delete(track);\n  queueMicrotask(() => {\n    trackList.dispatchEvent(new _track_event_js__WEBPACK_IMPORTED_MODULE_0__.TrackEvent(\"removetrack\", { track }));\n  });\n}\nfunction enabledChanged(track) {\n  const trackList = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(track).media.audioTracks;\n  if (!trackList || (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(trackList).changeRequested) return;\n  (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(trackList).changeRequested = true;\n  queueMicrotask(() => {\n    delete (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(trackList).changeRequested;\n    trackList.dispatchEvent(new Event(\"change\"));\n  });\n}\nclass AudioTrackList extends EventTarget {\n  #addTrackCallback;\n  #removeTrackCallback;\n  #changeCallback;\n  constructor() {\n    super();\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(this).trackSet = /* @__PURE__ */ new Set();\n  }\n  get #tracks() {\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(this).trackSet;\n  }\n  [Symbol.iterator]() {\n    return this.#tracks.values();\n  }\n  get length() {\n    return this.#tracks.size;\n  }\n  getTrackById(id) {\n    return [...this.#tracks].find((track) => track.id === id) ?? null;\n  }\n  get onaddtrack() {\n    return this.#addTrackCallback;\n  }\n  set onaddtrack(callback) {\n    if (this.#addTrackCallback) {\n      this.removeEventListener(\"addtrack\", this.#addTrackCallback);\n      this.#addTrackCallback = void 0;\n    }\n    if (typeof callback == \"function\") {\n      this.#addTrackCallback = callback;\n      this.addEventListener(\"addtrack\", callback);\n    }\n  }\n  get onremovetrack() {\n    return this.#removeTrackCallback;\n  }\n  set onremovetrack(callback) {\n    if (this.#removeTrackCallback) {\n      this.removeEventListener(\"removetrack\", this.#removeTrackCallback);\n      this.#removeTrackCallback = void 0;\n    }\n    if (typeof callback == \"function\") {\n      this.#removeTrackCallback = callback;\n      this.addEventListener(\"removetrack\", callback);\n    }\n  }\n  get onchange() {\n    return this.#changeCallback;\n  }\n  set onchange(callback) {\n    if (this.#changeCallback) {\n      this.removeEventListener(\"change\", this.#changeCallback);\n      this.#changeCallback = void 0;\n    }\n    if (typeof callback == \"function\") {\n      this.#changeCallback = callback;\n      this.addEventListener(\"change\", callback);\n    }\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZWRpYS10cmFja3MvZGlzdC9hdWRpby10cmFjay1saXN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUE4QztBQUNOO0FBQ3hDO0FBQ0E7QUFDQSxFQUFFLHFEQUFVO0FBQ1osT0FBTyxxREFBVTtBQUNqQixJQUFJLHFEQUFVO0FBQ2Q7QUFDQSxtQkFBbUIscURBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxREFBVTtBQUM3QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0NBQWdDLHVEQUFVLGVBQWUsT0FBTztBQUNoRSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG9CQUFvQixxREFBVTtBQUM5QjtBQUNBLG1CQUFtQixxREFBVTtBQUM3QjtBQUNBO0FBQ0EsZ0NBQWdDLHVEQUFVLGtCQUFrQixPQUFPO0FBQ25FLEdBQUc7QUFDSDtBQUNBO0FBQ0Esb0JBQW9CLHFEQUFVO0FBQzlCLG9CQUFvQixxREFBVTtBQUM5QixFQUFFLHFEQUFVO0FBQ1o7QUFDQSxXQUFXLHFEQUFVO0FBQ3JCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxxREFBVTtBQUNkO0FBQ0E7QUFDQSxXQUFXLHFEQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNRSIsInNvdXJjZXMiOlsiL1VzZXJzL0V0aGFuTGVlL0Rlc2t0b3AvQWR2WC9BSS1XYXRjaC1CdWRkeS9mcm9udGVuZC9ub2RlX21vZHVsZXMvbWVkaWEtdHJhY2tzL2Rpc3QvYXVkaW8tdHJhY2stbGlzdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUcmFja0V2ZW50IH0gZnJvbSBcIi4vdHJhY2stZXZlbnQuanNcIjtcbmltcG9ydCB7IGdldFByaXZhdGUgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuZnVuY3Rpb24gYWRkQXVkaW9UcmFjayhtZWRpYSwgdHJhY2spIHtcbiAgY29uc3QgdHJhY2tMaXN0ID0gbWVkaWEuYXVkaW9UcmFja3M7XG4gIGdldFByaXZhdGUodHJhY2spLm1lZGlhID0gbWVkaWE7XG4gIGlmICghZ2V0UHJpdmF0ZSh0cmFjaykucmVuZGl0aW9uU2V0KSB7XG4gICAgZ2V0UHJpdmF0ZSh0cmFjaykucmVuZGl0aW9uU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgfVxuICBjb25zdCB0cmFja1NldCA9IGdldFByaXZhdGUodHJhY2tMaXN0KS50cmFja1NldDtcbiAgdHJhY2tTZXQuYWRkKHRyYWNrKTtcbiAgY29uc3QgaW5kZXggPSB0cmFja1NldC5zaXplIC0gMTtcbiAgaWYgKCEoaW5kZXggaW4gQXVkaW9UcmFja0xpc3QucHJvdG90eXBlKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBdWRpb1RyYWNrTGlzdC5wcm90b3R5cGUsIGluZGV4LCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBbLi4uZ2V0UHJpdmF0ZSh0aGlzKS50cmFja1NldF1baW5kZXhdO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICB0cmFja0xpc3QuZGlzcGF0Y2hFdmVudChuZXcgVHJhY2tFdmVudChcImFkZHRyYWNrXCIsIHsgdHJhY2sgfSkpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUF1ZGlvVHJhY2sodHJhY2spIHtcbiAgY29uc3QgdHJhY2tMaXN0ID0gZ2V0UHJpdmF0ZSh0cmFjaykubWVkaWE/LmF1ZGlvVHJhY2tzO1xuICBpZiAoIXRyYWNrTGlzdCkgcmV0dXJuO1xuICBjb25zdCB0cmFja1NldCA9IGdldFByaXZhdGUodHJhY2tMaXN0KS50cmFja1NldDtcbiAgdHJhY2tTZXQuZGVsZXRlKHRyYWNrKTtcbiAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgIHRyYWNrTGlzdC5kaXNwYXRjaEV2ZW50KG5ldyBUcmFja0V2ZW50KFwicmVtb3ZldHJhY2tcIiwgeyB0cmFjayB9KSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZW5hYmxlZENoYW5nZWQodHJhY2spIHtcbiAgY29uc3QgdHJhY2tMaXN0ID0gZ2V0UHJpdmF0ZSh0cmFjaykubWVkaWEuYXVkaW9UcmFja3M7XG4gIGlmICghdHJhY2tMaXN0IHx8IGdldFByaXZhdGUodHJhY2tMaXN0KS5jaGFuZ2VSZXF1ZXN0ZWQpIHJldHVybjtcbiAgZ2V0UHJpdmF0ZSh0cmFja0xpc3QpLmNoYW5nZVJlcXVlc3RlZCA9IHRydWU7XG4gIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICBkZWxldGUgZ2V0UHJpdmF0ZSh0cmFja0xpc3QpLmNoYW5nZVJlcXVlc3RlZDtcbiAgICB0cmFja0xpc3QuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJjaGFuZ2VcIikpO1xuICB9KTtcbn1cbmNsYXNzIEF1ZGlvVHJhY2tMaXN0IGV4dGVuZHMgRXZlbnRUYXJnZXQge1xuICAjYWRkVHJhY2tDYWxsYmFjaztcbiAgI3JlbW92ZVRyYWNrQ2FsbGJhY2s7XG4gICNjaGFuZ2VDYWxsYmFjaztcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICBnZXRQcml2YXRlKHRoaXMpLnRyYWNrU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgfVxuICBnZXQgI3RyYWNrcygpIHtcbiAgICByZXR1cm4gZ2V0UHJpdmF0ZSh0aGlzKS50cmFja1NldDtcbiAgfVxuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gdGhpcy4jdHJhY2tzLnZhbHVlcygpO1xuICB9XG4gIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3RyYWNrcy5zaXplO1xuICB9XG4gIGdldFRyYWNrQnlJZChpZCkge1xuICAgIHJldHVybiBbLi4udGhpcy4jdHJhY2tzXS5maW5kKCh0cmFjaykgPT4gdHJhY2suaWQgPT09IGlkKSA/PyBudWxsO1xuICB9XG4gIGdldCBvbmFkZHRyYWNrKCkge1xuICAgIHJldHVybiB0aGlzLiNhZGRUcmFja0NhbGxiYWNrO1xuICB9XG4gIHNldCBvbmFkZHRyYWNrKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuI2FkZFRyYWNrQ2FsbGJhY2spIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFkZHRyYWNrXCIsIHRoaXMuI2FkZFRyYWNrQ2FsbGJhY2spO1xuICAgICAgdGhpcy4jYWRkVHJhY2tDYWxsYmFjayA9IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRoaXMuI2FkZFRyYWNrQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcImFkZHRyYWNrXCIsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cbiAgZ2V0IG9ucmVtb3ZldHJhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JlbW92ZVRyYWNrQ2FsbGJhY2s7XG4gIH1cbiAgc2V0IG9ucmVtb3ZldHJhY2soY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy4jcmVtb3ZlVHJhY2tDYWxsYmFjaykge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVtb3ZldHJhY2tcIiwgdGhpcy4jcmVtb3ZlVHJhY2tDYWxsYmFjayk7XG4gICAgICB0aGlzLiNyZW1vdmVUcmFja0NhbGxiYWNrID0gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhpcy4jcmVtb3ZlVHJhY2tDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKFwicmVtb3ZldHJhY2tcIiwgY2FsbGJhY2spO1xuICAgIH1cbiAgfVxuICBnZXQgb25jaGFuZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NoYW5nZUNhbGxiYWNrO1xuICB9XG4gIHNldCBvbmNoYW5nZShjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLiNjaGFuZ2VDYWxsYmFjaykge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIHRoaXMuI2NoYW5nZUNhbGxiYWNrKTtcbiAgICAgIHRoaXMuI2NoYW5nZUNhbGxiYWNrID0gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhpcy4jY2hhbmdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBjYWxsYmFjayk7XG4gICAgfVxuICB9XG59XG5leHBvcnQge1xuICBBdWRpb1RyYWNrTGlzdCxcbiAgYWRkQXVkaW9UcmFjayxcbiAgZW5hYmxlZENoYW5nZWQsXG4gIHJlbW92ZUF1ZGlvVHJhY2tcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/media-tracks/dist/audio-track-list.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/media-tracks/dist/audio-track.js":
/*!*******************************************************!*\
  !*** ./node_modules/media-tracks/dist/audio-track.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AudioTrack: () => (/* binding */ AudioTrack),\n/* harmony export */   AudioTrackKind: () => (/* binding */ AudioTrackKind)\n/* harmony export */ });\n/* harmony import */ var _audio_rendition_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./audio-rendition.js */ \"(app-pages-browser)/./node_modules/media-tracks/dist/audio-rendition.js\");\n/* harmony import */ var _audio_track_list_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./audio-track-list.js */ \"(app-pages-browser)/./node_modules/media-tracks/dist/audio-track-list.js\");\n/* harmony import */ var _audio_rendition_list_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./audio-rendition-list.js */ \"(app-pages-browser)/./node_modules/media-tracks/dist/audio-rendition-list.js\");\n\n\n\nconst AudioTrackKind = {\n  alternative: \"alternative\",\n  descriptions: \"descriptions\",\n  main: \"main\",\n  \"main-desc\": \"main-desc\",\n  translation: \"translation\",\n  commentary: \"commentary\"\n};\nclass AudioTrack {\n  id;\n  kind;\n  label = \"\";\n  language = \"\";\n  sourceBuffer;\n  #enabled = false;\n  addRendition(src, codec, bitrate) {\n    const rendition = new _audio_rendition_js__WEBPACK_IMPORTED_MODULE_0__.AudioRendition();\n    rendition.src = src;\n    rendition.codec = codec;\n    rendition.bitrate = bitrate;\n    (0,_audio_rendition_list_js__WEBPACK_IMPORTED_MODULE_2__.addRendition)(this, rendition);\n    return rendition;\n  }\n  removeRendition(rendition) {\n    (0,_audio_rendition_list_js__WEBPACK_IMPORTED_MODULE_2__.removeRendition)(rendition);\n  }\n  get enabled() {\n    return this.#enabled;\n  }\n  set enabled(val) {\n    if (this.#enabled === val) return;\n    this.#enabled = val;\n    (0,_audio_track_list_js__WEBPACK_IMPORTED_MODULE_1__.enabledChanged)(this);\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZWRpYS10cmFja3MvZGlzdC9hdWRpby10cmFjay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFzRDtBQUNDO0FBQ21CO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLCtEQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLElBQUksc0VBQVk7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsSUFBSSx5RUFBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksb0VBQWM7QUFDbEI7QUFDQTtBQUlFIiwic291cmNlcyI6WyIvVXNlcnMvRXRoYW5MZWUvRGVza3RvcC9BZHZYL0FJLVdhdGNoLUJ1ZGR5L2Zyb250ZW5kL25vZGVfbW9kdWxlcy9tZWRpYS10cmFja3MvZGlzdC9hdWRpby10cmFjay5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBdWRpb1JlbmRpdGlvbiB9IGZyb20gXCIuL2F1ZGlvLXJlbmRpdGlvbi5qc1wiO1xuaW1wb3J0IHsgZW5hYmxlZENoYW5nZWQgfSBmcm9tIFwiLi9hdWRpby10cmFjay1saXN0LmpzXCI7XG5pbXBvcnQgeyBhZGRSZW5kaXRpb24sIHJlbW92ZVJlbmRpdGlvbiB9IGZyb20gXCIuL2F1ZGlvLXJlbmRpdGlvbi1saXN0LmpzXCI7XG5jb25zdCBBdWRpb1RyYWNrS2luZCA9IHtcbiAgYWx0ZXJuYXRpdmU6IFwiYWx0ZXJuYXRpdmVcIixcbiAgZGVzY3JpcHRpb25zOiBcImRlc2NyaXB0aW9uc1wiLFxuICBtYWluOiBcIm1haW5cIixcbiAgXCJtYWluLWRlc2NcIjogXCJtYWluLWRlc2NcIixcbiAgdHJhbnNsYXRpb246IFwidHJhbnNsYXRpb25cIixcbiAgY29tbWVudGFyeTogXCJjb21tZW50YXJ5XCJcbn07XG5jbGFzcyBBdWRpb1RyYWNrIHtcbiAgaWQ7XG4gIGtpbmQ7XG4gIGxhYmVsID0gXCJcIjtcbiAgbGFuZ3VhZ2UgPSBcIlwiO1xuICBzb3VyY2VCdWZmZXI7XG4gICNlbmFibGVkID0gZmFsc2U7XG4gIGFkZFJlbmRpdGlvbihzcmMsIGNvZGVjLCBiaXRyYXRlKSB7XG4gICAgY29uc3QgcmVuZGl0aW9uID0gbmV3IEF1ZGlvUmVuZGl0aW9uKCk7XG4gICAgcmVuZGl0aW9uLnNyYyA9IHNyYztcbiAgICByZW5kaXRpb24uY29kZWMgPSBjb2RlYztcbiAgICByZW5kaXRpb24uYml0cmF0ZSA9IGJpdHJhdGU7XG4gICAgYWRkUmVuZGl0aW9uKHRoaXMsIHJlbmRpdGlvbik7XG4gICAgcmV0dXJuIHJlbmRpdGlvbjtcbiAgfVxuICByZW1vdmVSZW5kaXRpb24ocmVuZGl0aW9uKSB7XG4gICAgcmVtb3ZlUmVuZGl0aW9uKHJlbmRpdGlvbik7XG4gIH1cbiAgZ2V0IGVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2VuYWJsZWQ7XG4gIH1cbiAgc2V0IGVuYWJsZWQodmFsKSB7XG4gICAgaWYgKHRoaXMuI2VuYWJsZWQgPT09IHZhbCkgcmV0dXJuO1xuICAgIHRoaXMuI2VuYWJsZWQgPSB2YWw7XG4gICAgZW5hYmxlZENoYW5nZWQodGhpcyk7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIEF1ZGlvVHJhY2ssXG4gIEF1ZGlvVHJhY2tLaW5kXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/media-tracks/dist/audio-track.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/media-tracks/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/media-tracks/dist/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AudioRendition: () => (/* reexport safe */ _audio_rendition_js__WEBPACK_IMPORTED_MODULE_7__.AudioRendition),\n/* harmony export */   AudioRenditionList: () => (/* reexport safe */ _audio_rendition_list_js__WEBPACK_IMPORTED_MODULE_8__.AudioRenditionList),\n/* harmony export */   AudioTrack: () => (/* reexport safe */ _audio_track_js__WEBPACK_IMPORTED_MODULE_5__.AudioTrack),\n/* harmony export */   AudioTrackList: () => (/* reexport safe */ _audio_track_list_js__WEBPACK_IMPORTED_MODULE_6__.AudioTrackList),\n/* harmony export */   MediaTracksMixin: () => (/* reexport safe */ _mixin_js__WEBPACK_IMPORTED_MODULE_0__.MediaTracksMixin),\n/* harmony export */   RenditionEvent: () => (/* reexport safe */ _rendition_event_js__WEBPACK_IMPORTED_MODULE_10__.RenditionEvent),\n/* harmony export */   TrackEvent: () => (/* reexport safe */ _track_event_js__WEBPACK_IMPORTED_MODULE_9__.TrackEvent),\n/* harmony export */   VideoRendition: () => (/* reexport safe */ _video_rendition_js__WEBPACK_IMPORTED_MODULE_3__.VideoRendition),\n/* harmony export */   VideoRenditionList: () => (/* reexport safe */ _video_rendition_list_js__WEBPACK_IMPORTED_MODULE_4__.VideoRenditionList),\n/* harmony export */   VideoTrack: () => (/* reexport safe */ _video_track_js__WEBPACK_IMPORTED_MODULE_1__.VideoTrack),\n/* harmony export */   VideoTrackList: () => (/* reexport safe */ _video_track_list_js__WEBPACK_IMPORTED_MODULE_2__.VideoTrackList)\n/* harmony export */ });\n/* harmony import */ var _mixin_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mixin.js */ \"(app-pages-browser)/./node_modules/media-tracks/dist/mixin.js\");\n/* harmony import */ var _video_track_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./video-track.js */ \"(app-pages-browser)/./node_modules/media-tracks/dist/video-track.js\");\n/* harmony import */ var _video_track_list_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./video-track-list.js */ \"(app-pages-browser)/./node_modules/media-tracks/dist/video-track-list.js\");\n/* harmony import */ var _video_rendition_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./video-rendition.js */ \"(app-pages-browser)/./node_modules/media-tracks/dist/video-rendition.js\");\n/* harmony import */ var _video_rendition_list_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./video-rendition-list.js */ \"(app-pages-browser)/./node_modules/media-tracks/dist/video-rendition-list.js\");\n/* harmony import */ var _audio_track_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./audio-track.js */ \"(app-pages-browser)/./node_modules/media-tracks/dist/audio-track.js\");\n/* harmony import */ var _audio_track_list_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./audio-track-list.js */ \"(app-pages-browser)/./node_modules/media-tracks/dist/audio-track-list.js\");\n/* harmony import */ var _audio_rendition_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./audio-rendition.js */ \"(app-pages-browser)/./node_modules/media-tracks/dist/audio-rendition.js\");\n/* harmony import */ var _audio_rendition_list_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./audio-rendition-list.js */ \"(app-pages-browser)/./node_modules/media-tracks/dist/audio-rendition-list.js\");\n/* harmony import */ var _track_event_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./track-event.js */ \"(app-pages-browser)/./node_modules/media-tracks/dist/track-event.js\");\n/* harmony import */ var _rendition_event_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./rendition-event.js */ \"(app-pages-browser)/./node_modules/media-tracks/dist/rendition-event.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZWRpYS10cmFja3MvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTJCO0FBQ21CO0FBQ1M7QUFDRDtBQUNTO0FBQ2pCO0FBQ1M7QUFDRDtBQUNTO0FBQ2pCO0FBQ1E7QUFZcEQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9FdGhhbkxlZS9EZXNrdG9wL0FkdlgvQUktV2F0Y2gtQnVkZHkvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL21lZGlhLXRyYWNrcy9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gXCIuL21peGluLmpzXCI7XG5pbXBvcnQgeyBWaWRlb1RyYWNrIH0gZnJvbSBcIi4vdmlkZW8tdHJhY2suanNcIjtcbmltcG9ydCB7IFZpZGVvVHJhY2tMaXN0IH0gZnJvbSBcIi4vdmlkZW8tdHJhY2stbGlzdC5qc1wiO1xuaW1wb3J0IHsgVmlkZW9SZW5kaXRpb24gfSBmcm9tIFwiLi92aWRlby1yZW5kaXRpb24uanNcIjtcbmltcG9ydCB7IFZpZGVvUmVuZGl0aW9uTGlzdCB9IGZyb20gXCIuL3ZpZGVvLXJlbmRpdGlvbi1saXN0LmpzXCI7XG5pbXBvcnQgeyBBdWRpb1RyYWNrIH0gZnJvbSBcIi4vYXVkaW8tdHJhY2suanNcIjtcbmltcG9ydCB7IEF1ZGlvVHJhY2tMaXN0IH0gZnJvbSBcIi4vYXVkaW8tdHJhY2stbGlzdC5qc1wiO1xuaW1wb3J0IHsgQXVkaW9SZW5kaXRpb24gfSBmcm9tIFwiLi9hdWRpby1yZW5kaXRpb24uanNcIjtcbmltcG9ydCB7IEF1ZGlvUmVuZGl0aW9uTGlzdCB9IGZyb20gXCIuL2F1ZGlvLXJlbmRpdGlvbi1saXN0LmpzXCI7XG5pbXBvcnQgeyBUcmFja0V2ZW50IH0gZnJvbSBcIi4vdHJhY2stZXZlbnQuanNcIjtcbmltcG9ydCB7IFJlbmRpdGlvbkV2ZW50IH0gZnJvbSBcIi4vcmVuZGl0aW9uLWV2ZW50LmpzXCI7XG5leHBvcnQge1xuICBBdWRpb1JlbmRpdGlvbixcbiAgQXVkaW9SZW5kaXRpb25MaXN0LFxuICBBdWRpb1RyYWNrLFxuICBBdWRpb1RyYWNrTGlzdCxcbiAgUmVuZGl0aW9uRXZlbnQsXG4gIFRyYWNrRXZlbnQsXG4gIFZpZGVvUmVuZGl0aW9uLFxuICBWaWRlb1JlbmRpdGlvbkxpc3QsXG4gIFZpZGVvVHJhY2ssXG4gIFZpZGVvVHJhY2tMaXN0XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/media-tracks/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/media-tracks/dist/mixin.js":
/*!*************************************************!*\
  !*** ./node_modules/media-tracks/dist/mixin.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MediaTracksMixin: () => (/* binding */ MediaTracksMixin)\n/* harmony export */ });\n/* harmony import */ var _video_track_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./video-track.js */ \"(app-pages-browser)/./node_modules/media-tracks/dist/video-track.js\");\n/* harmony import */ var _video_track_list_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./video-track-list.js */ \"(app-pages-browser)/./node_modules/media-tracks/dist/video-track-list.js\");\n/* harmony import */ var _audio_track_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./audio-track.js */ \"(app-pages-browser)/./node_modules/media-tracks/dist/audio-track.js\");\n/* harmony import */ var _audio_track_list_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./audio-track-list.js */ \"(app-pages-browser)/./node_modules/media-tracks/dist/audio-track-list.js\");\n/* harmony import */ var _video_rendition_list_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./video-rendition-list.js */ \"(app-pages-browser)/./node_modules/media-tracks/dist/video-rendition-list.js\");\n/* harmony import */ var _audio_rendition_list_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./audio-rendition-list.js */ \"(app-pages-browser)/./node_modules/media-tracks/dist/audio-rendition-list.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/media-tracks/dist/utils.js\");\n\n\n\n\n\n\n\nconst nativeVideoTracksFn = getBaseMediaTracksFn(globalThis.HTMLMediaElement, \"video\");\nconst nativeAudioTracksFn = getBaseMediaTracksFn(globalThis.HTMLMediaElement, \"audio\");\nfunction MediaTracksMixin(MediaElementClass) {\n  if (!MediaElementClass?.prototype) return MediaElementClass;\n  const videoTracksFn = getBaseMediaTracksFn(MediaElementClass, \"video\");\n  if (!videoTracksFn || `${videoTracksFn}`.includes(\"[native code]\")) {\n    Object.defineProperty(MediaElementClass.prototype, \"videoTracks\", {\n      get() {\n        return getVideoTracks(this);\n      }\n    });\n  }\n  const audioTracksFn = getBaseMediaTracksFn(MediaElementClass, \"audio\");\n  if (!audioTracksFn || `${audioTracksFn}`.includes(\"[native code]\")) {\n    Object.defineProperty(MediaElementClass.prototype, \"audioTracks\", {\n      get() {\n        return getAudioTracks(this);\n      }\n    });\n  }\n  if (!(\"addVideoTrack\" in MediaElementClass.prototype)) {\n    MediaElementClass.prototype.addVideoTrack = function(kind, label = \"\", language = \"\") {\n      const track = new _video_track_js__WEBPACK_IMPORTED_MODULE_0__.VideoTrack();\n      track.kind = kind;\n      track.label = label;\n      track.language = language;\n      (0,_video_track_list_js__WEBPACK_IMPORTED_MODULE_1__.addVideoTrack)(this, track);\n      return track;\n    };\n  }\n  if (!(\"removeVideoTrack\" in MediaElementClass.prototype)) {\n    MediaElementClass.prototype.removeVideoTrack = _video_track_list_js__WEBPACK_IMPORTED_MODULE_1__.removeVideoTrack;\n  }\n  if (!(\"addAudioTrack\" in MediaElementClass.prototype)) {\n    MediaElementClass.prototype.addAudioTrack = function(kind, label = \"\", language = \"\") {\n      const track = new _audio_track_js__WEBPACK_IMPORTED_MODULE_2__.AudioTrack();\n      track.kind = kind;\n      track.label = label;\n      track.language = language;\n      (0,_audio_track_list_js__WEBPACK_IMPORTED_MODULE_3__.addAudioTrack)(this, track);\n      return track;\n    };\n  }\n  if (!(\"removeAudioTrack\" in MediaElementClass.prototype)) {\n    MediaElementClass.prototype.removeAudioTrack = _audio_track_list_js__WEBPACK_IMPORTED_MODULE_3__.removeAudioTrack;\n  }\n  if (!(\"videoRenditions\" in MediaElementClass.prototype)) {\n    Object.defineProperty(MediaElementClass.prototype, \"videoRenditions\", {\n      get() {\n        return initVideoRenditions(this);\n      }\n    });\n  }\n  const initVideoRenditions = (media) => {\n    let renditions = (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.getPrivate)(media).videoRenditions;\n    if (!renditions) {\n      renditions = new _video_rendition_list_js__WEBPACK_IMPORTED_MODULE_4__.VideoRenditionList();\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.getPrivate)(renditions).media = media;\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.getPrivate)(media).videoRenditions = renditions;\n    }\n    return renditions;\n  };\n  if (!(\"audioRenditions\" in MediaElementClass.prototype)) {\n    Object.defineProperty(MediaElementClass.prototype, \"audioRenditions\", {\n      get() {\n        return initAudioRenditions(this);\n      }\n    });\n  }\n  const initAudioRenditions = (media) => {\n    let renditions = (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.getPrivate)(media).audioRenditions;\n    if (!renditions) {\n      renditions = new _audio_rendition_list_js__WEBPACK_IMPORTED_MODULE_5__.AudioRenditionList();\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.getPrivate)(renditions).media = media;\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.getPrivate)(media).audioRenditions = renditions;\n    }\n    return renditions;\n  };\n  return MediaElementClass;\n}\nfunction getBaseMediaTracksFn(MediaElementClass, type) {\n  if (MediaElementClass?.prototype) {\n    return Object.getOwnPropertyDescriptor(MediaElementClass.prototype, `${type}Tracks`)?.get;\n  }\n}\nfunction getVideoTracks(media) {\n  let tracks = (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.getPrivate)(media).videoTracks;\n  if (!tracks) {\n    tracks = new _video_track_list_js__WEBPACK_IMPORTED_MODULE_1__.VideoTrackList();\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.getPrivate)(media).videoTracks = tracks;\n    if (nativeVideoTracksFn) {\n      const nativeTracks = nativeVideoTracksFn.call(media.nativeEl ?? media);\n      for (const nativeTrack of nativeTracks) {\n        (0,_video_track_list_js__WEBPACK_IMPORTED_MODULE_1__.addVideoTrack)(media, nativeTrack);\n      }\n      nativeTracks.addEventListener(\"change\", () => {\n        tracks.dispatchEvent(new Event(\"change\"));\n      });\n      nativeTracks.addEventListener(\"addtrack\", (event) => {\n        if ([...tracks].some((t) => t instanceof _video_track_js__WEBPACK_IMPORTED_MODULE_0__.VideoTrack)) {\n          for (const nativeTrack of nativeTracks) {\n            (0,_video_track_list_js__WEBPACK_IMPORTED_MODULE_1__.removeVideoTrack)(nativeTrack);\n          }\n          return;\n        }\n        (0,_video_track_list_js__WEBPACK_IMPORTED_MODULE_1__.addVideoTrack)(media, event.track);\n      });\n      nativeTracks.addEventListener(\"removetrack\", (event) => {\n        (0,_video_track_list_js__WEBPACK_IMPORTED_MODULE_1__.removeVideoTrack)(event.track);\n      });\n    }\n  }\n  return tracks;\n}\nfunction getAudioTracks(media) {\n  let tracks = (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.getPrivate)(media).audioTracks;\n  if (!tracks) {\n    tracks = new _audio_track_list_js__WEBPACK_IMPORTED_MODULE_3__.AudioTrackList();\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.getPrivate)(media).audioTracks = tracks;\n    if (nativeAudioTracksFn) {\n      const nativeTracks = nativeAudioTracksFn.call(media.nativeEl ?? media);\n      for (const nativeTrack of nativeTracks) {\n        (0,_audio_track_list_js__WEBPACK_IMPORTED_MODULE_3__.addAudioTrack)(media, nativeTrack);\n      }\n      nativeTracks.addEventListener(\"change\", () => {\n        tracks.dispatchEvent(new Event(\"change\"));\n      });\n      nativeTracks.addEventListener(\"addtrack\", (event) => {\n        if ([...tracks].some((t) => t instanceof _audio_track_js__WEBPACK_IMPORTED_MODULE_2__.AudioTrack)) {\n          for (const nativeTrack of nativeTracks) {\n            (0,_audio_track_list_js__WEBPACK_IMPORTED_MODULE_3__.removeAudioTrack)(nativeTrack);\n          }\n          return;\n        }\n        (0,_audio_track_list_js__WEBPACK_IMPORTED_MODULE_3__.addAudioTrack)(media, event.track);\n      });\n      nativeTracks.addEventListener(\"removetrack\", (event) => {\n        (0,_audio_track_list_js__WEBPACK_IMPORTED_MODULE_3__.removeAudioTrack)(event.track);\n      });\n    }\n  }\n  return tracks;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZWRpYS10cmFja3MvZGlzdC9taXhpbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUE4QztBQUMwQztBQUMxQztBQUMwQztBQUN6QjtBQUNBO0FBQ3ZCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsY0FBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVEQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLE1BQU0sbUVBQWE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsa0VBQWdCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1REFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQSxNQUFNLG1FQUFhO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGtFQUFnQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFCQUFxQixxREFBVTtBQUMvQjtBQUNBLHVCQUF1Qix3RUFBa0I7QUFDekMsTUFBTSxxREFBVTtBQUNoQixNQUFNLHFEQUFVO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFCQUFxQixxREFBVTtBQUMvQjtBQUNBLHVCQUF1Qix3RUFBa0I7QUFDekMsTUFBTSxxREFBVTtBQUNoQixNQUFNLHFEQUFVO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLEtBQUs7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxREFBVTtBQUN6QjtBQUNBLGlCQUFpQixnRUFBYztBQUMvQixJQUFJLHFEQUFVO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtRUFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxpREFBaUQsdURBQVU7QUFDM0Q7QUFDQSxZQUFZLHNFQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1FQUFhO0FBQ3JCLE9BQU87QUFDUDtBQUNBLFFBQVEsc0VBQWdCO0FBQ3hCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxREFBVTtBQUN6QjtBQUNBLGlCQUFpQixnRUFBYztBQUMvQixJQUFJLHFEQUFVO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtRUFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxpREFBaUQsdURBQVU7QUFDM0Q7QUFDQSxZQUFZLHNFQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1FQUFhO0FBQ3JCLE9BQU87QUFDUDtBQUNBLFFBQVEsc0VBQWdCO0FBQ3hCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUdFIiwic291cmNlcyI6WyIvVXNlcnMvRXRoYW5MZWUvRGVza3RvcC9BZHZYL0FJLVdhdGNoLUJ1ZGR5L2Zyb250ZW5kL25vZGVfbW9kdWxlcy9tZWRpYS10cmFja3MvZGlzdC9taXhpbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBWaWRlb1RyYWNrIH0gZnJvbSBcIi4vdmlkZW8tdHJhY2suanNcIjtcbmltcG9ydCB7IFZpZGVvVHJhY2tMaXN0LCBhZGRWaWRlb1RyYWNrLCByZW1vdmVWaWRlb1RyYWNrIH0gZnJvbSBcIi4vdmlkZW8tdHJhY2stbGlzdC5qc1wiO1xuaW1wb3J0IHsgQXVkaW9UcmFjayB9IGZyb20gXCIuL2F1ZGlvLXRyYWNrLmpzXCI7XG5pbXBvcnQgeyBBdWRpb1RyYWNrTGlzdCwgYWRkQXVkaW9UcmFjaywgcmVtb3ZlQXVkaW9UcmFjayB9IGZyb20gXCIuL2F1ZGlvLXRyYWNrLWxpc3QuanNcIjtcbmltcG9ydCB7IFZpZGVvUmVuZGl0aW9uTGlzdCB9IGZyb20gXCIuL3ZpZGVvLXJlbmRpdGlvbi1saXN0LmpzXCI7XG5pbXBvcnQgeyBBdWRpb1JlbmRpdGlvbkxpc3QgfSBmcm9tIFwiLi9hdWRpby1yZW5kaXRpb24tbGlzdC5qc1wiO1xuaW1wb3J0IHsgZ2V0UHJpdmF0ZSB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5jb25zdCBuYXRpdmVWaWRlb1RyYWNrc0ZuID0gZ2V0QmFzZU1lZGlhVHJhY2tzRm4oZ2xvYmFsVGhpcy5IVE1MTWVkaWFFbGVtZW50LCBcInZpZGVvXCIpO1xuY29uc3QgbmF0aXZlQXVkaW9UcmFja3NGbiA9IGdldEJhc2VNZWRpYVRyYWNrc0ZuKGdsb2JhbFRoaXMuSFRNTE1lZGlhRWxlbWVudCwgXCJhdWRpb1wiKTtcbmZ1bmN0aW9uIE1lZGlhVHJhY2tzTWl4aW4oTWVkaWFFbGVtZW50Q2xhc3MpIHtcbiAgaWYgKCFNZWRpYUVsZW1lbnRDbGFzcz8ucHJvdG90eXBlKSByZXR1cm4gTWVkaWFFbGVtZW50Q2xhc3M7XG4gIGNvbnN0IHZpZGVvVHJhY2tzRm4gPSBnZXRCYXNlTWVkaWFUcmFja3NGbihNZWRpYUVsZW1lbnRDbGFzcywgXCJ2aWRlb1wiKTtcbiAgaWYgKCF2aWRlb1RyYWNrc0ZuIHx8IGAke3ZpZGVvVHJhY2tzRm59YC5pbmNsdWRlcyhcIltuYXRpdmUgY29kZV1cIikpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWVkaWFFbGVtZW50Q2xhc3MucHJvdG90eXBlLCBcInZpZGVvVHJhY2tzXCIsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGdldFZpZGVvVHJhY2tzKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IGF1ZGlvVHJhY2tzRm4gPSBnZXRCYXNlTWVkaWFUcmFja3NGbihNZWRpYUVsZW1lbnRDbGFzcywgXCJhdWRpb1wiKTtcbiAgaWYgKCFhdWRpb1RyYWNrc0ZuIHx8IGAke2F1ZGlvVHJhY2tzRm59YC5pbmNsdWRlcyhcIltuYXRpdmUgY29kZV1cIikpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWVkaWFFbGVtZW50Q2xhc3MucHJvdG90eXBlLCBcImF1ZGlvVHJhY2tzXCIsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGdldEF1ZGlvVHJhY2tzKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGlmICghKFwiYWRkVmlkZW9UcmFja1wiIGluIE1lZGlhRWxlbWVudENsYXNzLnByb3RvdHlwZSkpIHtcbiAgICBNZWRpYUVsZW1lbnRDbGFzcy5wcm90b3R5cGUuYWRkVmlkZW9UcmFjayA9IGZ1bmN0aW9uKGtpbmQsIGxhYmVsID0gXCJcIiwgbGFuZ3VhZ2UgPSBcIlwiKSB7XG4gICAgICBjb25zdCB0cmFjayA9IG5ldyBWaWRlb1RyYWNrKCk7XG4gICAgICB0cmFjay5raW5kID0ga2luZDtcbiAgICAgIHRyYWNrLmxhYmVsID0gbGFiZWw7XG4gICAgICB0cmFjay5sYW5ndWFnZSA9IGxhbmd1YWdlO1xuICAgICAgYWRkVmlkZW9UcmFjayh0aGlzLCB0cmFjayk7XG4gICAgICByZXR1cm4gdHJhY2s7XG4gICAgfTtcbiAgfVxuICBpZiAoIShcInJlbW92ZVZpZGVvVHJhY2tcIiBpbiBNZWRpYUVsZW1lbnRDbGFzcy5wcm90b3R5cGUpKSB7XG4gICAgTWVkaWFFbGVtZW50Q2xhc3MucHJvdG90eXBlLnJlbW92ZVZpZGVvVHJhY2sgPSByZW1vdmVWaWRlb1RyYWNrO1xuICB9XG4gIGlmICghKFwiYWRkQXVkaW9UcmFja1wiIGluIE1lZGlhRWxlbWVudENsYXNzLnByb3RvdHlwZSkpIHtcbiAgICBNZWRpYUVsZW1lbnRDbGFzcy5wcm90b3R5cGUuYWRkQXVkaW9UcmFjayA9IGZ1bmN0aW9uKGtpbmQsIGxhYmVsID0gXCJcIiwgbGFuZ3VhZ2UgPSBcIlwiKSB7XG4gICAgICBjb25zdCB0cmFjayA9IG5ldyBBdWRpb1RyYWNrKCk7XG4gICAgICB0cmFjay5raW5kID0ga2luZDtcbiAgICAgIHRyYWNrLmxhYmVsID0gbGFiZWw7XG4gICAgICB0cmFjay5sYW5ndWFnZSA9IGxhbmd1YWdlO1xuICAgICAgYWRkQXVkaW9UcmFjayh0aGlzLCB0cmFjayk7XG4gICAgICByZXR1cm4gdHJhY2s7XG4gICAgfTtcbiAgfVxuICBpZiAoIShcInJlbW92ZUF1ZGlvVHJhY2tcIiBpbiBNZWRpYUVsZW1lbnRDbGFzcy5wcm90b3R5cGUpKSB7XG4gICAgTWVkaWFFbGVtZW50Q2xhc3MucHJvdG90eXBlLnJlbW92ZUF1ZGlvVHJhY2sgPSByZW1vdmVBdWRpb1RyYWNrO1xuICB9XG4gIGlmICghKFwidmlkZW9SZW5kaXRpb25zXCIgaW4gTWVkaWFFbGVtZW50Q2xhc3MucHJvdG90eXBlKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZWRpYUVsZW1lbnRDbGFzcy5wcm90b3R5cGUsIFwidmlkZW9SZW5kaXRpb25zXCIsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGluaXRWaWRlb1JlbmRpdGlvbnModGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgaW5pdFZpZGVvUmVuZGl0aW9ucyA9IChtZWRpYSkgPT4ge1xuICAgIGxldCByZW5kaXRpb25zID0gZ2V0UHJpdmF0ZShtZWRpYSkudmlkZW9SZW5kaXRpb25zO1xuICAgIGlmICghcmVuZGl0aW9ucykge1xuICAgICAgcmVuZGl0aW9ucyA9IG5ldyBWaWRlb1JlbmRpdGlvbkxpc3QoKTtcbiAgICAgIGdldFByaXZhdGUocmVuZGl0aW9ucykubWVkaWEgPSBtZWRpYTtcbiAgICAgIGdldFByaXZhdGUobWVkaWEpLnZpZGVvUmVuZGl0aW9ucyA9IHJlbmRpdGlvbnM7XG4gICAgfVxuICAgIHJldHVybiByZW5kaXRpb25zO1xuICB9O1xuICBpZiAoIShcImF1ZGlvUmVuZGl0aW9uc1wiIGluIE1lZGlhRWxlbWVudENsYXNzLnByb3RvdHlwZSkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWVkaWFFbGVtZW50Q2xhc3MucHJvdG90eXBlLCBcImF1ZGlvUmVuZGl0aW9uc1wiLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBpbml0QXVkaW9SZW5kaXRpb25zKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IGluaXRBdWRpb1JlbmRpdGlvbnMgPSAobWVkaWEpID0+IHtcbiAgICBsZXQgcmVuZGl0aW9ucyA9IGdldFByaXZhdGUobWVkaWEpLmF1ZGlvUmVuZGl0aW9ucztcbiAgICBpZiAoIXJlbmRpdGlvbnMpIHtcbiAgICAgIHJlbmRpdGlvbnMgPSBuZXcgQXVkaW9SZW5kaXRpb25MaXN0KCk7XG4gICAgICBnZXRQcml2YXRlKHJlbmRpdGlvbnMpLm1lZGlhID0gbWVkaWE7XG4gICAgICBnZXRQcml2YXRlKG1lZGlhKS5hdWRpb1JlbmRpdGlvbnMgPSByZW5kaXRpb25zO1xuICAgIH1cbiAgICByZXR1cm4gcmVuZGl0aW9ucztcbiAgfTtcbiAgcmV0dXJuIE1lZGlhRWxlbWVudENsYXNzO1xufVxuZnVuY3Rpb24gZ2V0QmFzZU1lZGlhVHJhY2tzRm4oTWVkaWFFbGVtZW50Q2xhc3MsIHR5cGUpIHtcbiAgaWYgKE1lZGlhRWxlbWVudENsYXNzPy5wcm90b3R5cGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNZWRpYUVsZW1lbnRDbGFzcy5wcm90b3R5cGUsIGAke3R5cGV9VHJhY2tzYCk/LmdldDtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VmlkZW9UcmFja3MobWVkaWEpIHtcbiAgbGV0IHRyYWNrcyA9IGdldFByaXZhdGUobWVkaWEpLnZpZGVvVHJhY2tzO1xuICBpZiAoIXRyYWNrcykge1xuICAgIHRyYWNrcyA9IG5ldyBWaWRlb1RyYWNrTGlzdCgpO1xuICAgIGdldFByaXZhdGUobWVkaWEpLnZpZGVvVHJhY2tzID0gdHJhY2tzO1xuICAgIGlmIChuYXRpdmVWaWRlb1RyYWNrc0ZuKSB7XG4gICAgICBjb25zdCBuYXRpdmVUcmFja3MgPSBuYXRpdmVWaWRlb1RyYWNrc0ZuLmNhbGwobWVkaWEubmF0aXZlRWwgPz8gbWVkaWEpO1xuICAgICAgZm9yIChjb25zdCBuYXRpdmVUcmFjayBvZiBuYXRpdmVUcmFja3MpIHtcbiAgICAgICAgYWRkVmlkZW9UcmFjayhtZWRpYSwgbmF0aXZlVHJhY2spO1xuICAgICAgfVxuICAgICAgbmF0aXZlVHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgICB0cmFja3MuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJjaGFuZ2VcIikpO1xuICAgICAgfSk7XG4gICAgICBuYXRpdmVUcmFja3MuYWRkRXZlbnRMaXN0ZW5lcihcImFkZHRyYWNrXCIsIChldmVudCkgPT4ge1xuICAgICAgICBpZiAoWy4uLnRyYWNrc10uc29tZSgodCkgPT4gdCBpbnN0YW5jZW9mIFZpZGVvVHJhY2spKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBuYXRpdmVUcmFjayBvZiBuYXRpdmVUcmFja3MpIHtcbiAgICAgICAgICAgIHJlbW92ZVZpZGVvVHJhY2sobmF0aXZlVHJhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYWRkVmlkZW9UcmFjayhtZWRpYSwgZXZlbnQudHJhY2spO1xuICAgICAgfSk7XG4gICAgICBuYXRpdmVUcmFja3MuYWRkRXZlbnRMaXN0ZW5lcihcInJlbW92ZXRyYWNrXCIsIChldmVudCkgPT4ge1xuICAgICAgICByZW1vdmVWaWRlb1RyYWNrKGV2ZW50LnRyYWNrKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJhY2tzO1xufVxuZnVuY3Rpb24gZ2V0QXVkaW9UcmFja3MobWVkaWEpIHtcbiAgbGV0IHRyYWNrcyA9IGdldFByaXZhdGUobWVkaWEpLmF1ZGlvVHJhY2tzO1xuICBpZiAoIXRyYWNrcykge1xuICAgIHRyYWNrcyA9IG5ldyBBdWRpb1RyYWNrTGlzdCgpO1xuICAgIGdldFByaXZhdGUobWVkaWEpLmF1ZGlvVHJhY2tzID0gdHJhY2tzO1xuICAgIGlmIChuYXRpdmVBdWRpb1RyYWNrc0ZuKSB7XG4gICAgICBjb25zdCBuYXRpdmVUcmFja3MgPSBuYXRpdmVBdWRpb1RyYWNrc0ZuLmNhbGwobWVkaWEubmF0aXZlRWwgPz8gbWVkaWEpO1xuICAgICAgZm9yIChjb25zdCBuYXRpdmVUcmFjayBvZiBuYXRpdmVUcmFja3MpIHtcbiAgICAgICAgYWRkQXVkaW9UcmFjayhtZWRpYSwgbmF0aXZlVHJhY2spO1xuICAgICAgfVxuICAgICAgbmF0aXZlVHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgICB0cmFja3MuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJjaGFuZ2VcIikpO1xuICAgICAgfSk7XG4gICAgICBuYXRpdmVUcmFja3MuYWRkRXZlbnRMaXN0ZW5lcihcImFkZHRyYWNrXCIsIChldmVudCkgPT4ge1xuICAgICAgICBpZiAoWy4uLnRyYWNrc10uc29tZSgodCkgPT4gdCBpbnN0YW5jZW9mIEF1ZGlvVHJhY2spKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBuYXRpdmVUcmFjayBvZiBuYXRpdmVUcmFja3MpIHtcbiAgICAgICAgICAgIHJlbW92ZUF1ZGlvVHJhY2sobmF0aXZlVHJhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYWRkQXVkaW9UcmFjayhtZWRpYSwgZXZlbnQudHJhY2spO1xuICAgICAgfSk7XG4gICAgICBuYXRpdmVUcmFja3MuYWRkRXZlbnRMaXN0ZW5lcihcInJlbW92ZXRyYWNrXCIsIChldmVudCkgPT4ge1xuICAgICAgICByZW1vdmVBdWRpb1RyYWNrKGV2ZW50LnRyYWNrKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJhY2tzO1xufVxuZXhwb3J0IHtcbiAgTWVkaWFUcmFja3NNaXhpblxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/media-tracks/dist/mixin.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/media-tracks/dist/rendition-event.js":
/*!***********************************************************!*\
  !*** ./node_modules/media-tracks/dist/rendition-event.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RenditionEvent: () => (/* binding */ RenditionEvent)\n/* harmony export */ });\nclass RenditionEvent extends Event {\n  rendition;\n  constructor(type, init) {\n    super(type);\n    this.rendition = init.rendition;\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZWRpYS10cmFja3MvZGlzdC9yZW5kaXRpb24tZXZlbnQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIi9Vc2Vycy9FdGhhbkxlZS9EZXNrdG9wL0FkdlgvQUktV2F0Y2gtQnVkZHkvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL21lZGlhLXRyYWNrcy9kaXN0L3JlbmRpdGlvbi1ldmVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBSZW5kaXRpb25FdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgcmVuZGl0aW9uO1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBpbml0KSB7XG4gICAgc3VwZXIodHlwZSk7XG4gICAgdGhpcy5yZW5kaXRpb24gPSBpbml0LnJlbmRpdGlvbjtcbiAgfVxufVxuZXhwb3J0IHtcbiAgUmVuZGl0aW9uRXZlbnRcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/media-tracks/dist/rendition-event.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/media-tracks/dist/track-event.js":
/*!*******************************************************!*\
  !*** ./node_modules/media-tracks/dist/track-event.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TrackEvent: () => (/* binding */ TrackEvent)\n/* harmony export */ });\nclass TrackEvent extends Event {\n  track;\n  constructor(type, init) {\n    super(type);\n    this.track = init.track;\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZWRpYS10cmFja3MvZGlzdC90cmFjay1ldmVudC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRSIsInNvdXJjZXMiOlsiL1VzZXJzL0V0aGFuTGVlL0Rlc2t0b3AvQWR2WC9BSS1XYXRjaC1CdWRkeS9mcm9udGVuZC9ub2RlX21vZHVsZXMvbWVkaWEtdHJhY2tzL2Rpc3QvdHJhY2stZXZlbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgVHJhY2tFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgdHJhY2s7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIGluaXQpIHtcbiAgICBzdXBlcih0eXBlKTtcbiAgICB0aGlzLnRyYWNrID0gaW5pdC50cmFjaztcbiAgfVxufVxuZXhwb3J0IHtcbiAgVHJhY2tFdmVudFxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/media-tracks/dist/track-event.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/media-tracks/dist/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/media-tracks/dist/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getPrivate: () => (/* binding */ getPrivate),\n/* harmony export */   setPrivate: () => (/* binding */ setPrivate)\n/* harmony export */ });\nconst privateProps = /* @__PURE__ */ new WeakMap();\nfunction getPrivate(instance) {\n  return privateProps.get(instance) ?? setPrivate(instance, {});\n}\nfunction setPrivate(instance, props) {\n  let saved = privateProps.get(instance);\n  if (!saved) privateProps.set(instance, saved = {});\n  return Object.assign(saved, props);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZWRpYS10cmFja3MvZGlzdC91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFJRSIsInNvdXJjZXMiOlsiL1VzZXJzL0V0aGFuTGVlL0Rlc2t0b3AvQWR2WC9BSS1XYXRjaC1CdWRkeS9mcm9udGVuZC9ub2RlX21vZHVsZXMvbWVkaWEtdHJhY2tzL2Rpc3QvdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcHJpdmF0ZVByb3BzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBnZXRQcml2YXRlKGluc3RhbmNlKSB7XG4gIHJldHVybiBwcml2YXRlUHJvcHMuZ2V0KGluc3RhbmNlKSA/PyBzZXRQcml2YXRlKGluc3RhbmNlLCB7fSk7XG59XG5mdW5jdGlvbiBzZXRQcml2YXRlKGluc3RhbmNlLCBwcm9wcykge1xuICBsZXQgc2F2ZWQgPSBwcml2YXRlUHJvcHMuZ2V0KGluc3RhbmNlKTtcbiAgaWYgKCFzYXZlZCkgcHJpdmF0ZVByb3BzLnNldChpbnN0YW5jZSwgc2F2ZWQgPSB7fSk7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHNhdmVkLCBwcm9wcyk7XG59XG5leHBvcnQge1xuICBnZXRQcml2YXRlLFxuICBzZXRQcml2YXRlXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/media-tracks/dist/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/media-tracks/dist/video-rendition-list.js":
/*!****************************************************************!*\
  !*** ./node_modules/media-tracks/dist/video-rendition-list.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VideoRenditionList: () => (/* binding */ VideoRenditionList),\n/* harmony export */   addRendition: () => (/* binding */ addRendition),\n/* harmony export */   removeRendition: () => (/* binding */ removeRendition),\n/* harmony export */   selectedChanged: () => (/* binding */ selectedChanged)\n/* harmony export */ });\n/* harmony import */ var _rendition_event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rendition-event.js */ \"(app-pages-browser)/./node_modules/media-tracks/dist/rendition-event.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/media-tracks/dist/utils.js\");\n\n\nfunction addRendition(track, rendition) {\n  const renditionList = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(track).media.videoRenditions;\n  (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(rendition).media = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(track).media;\n  (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(rendition).track = track;\n  const renditionSet = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(track).renditionSet;\n  renditionSet.add(rendition);\n  const index = renditionSet.size - 1;\n  if (!(index in VideoRenditionList.prototype)) {\n    Object.defineProperty(VideoRenditionList.prototype, index, {\n      get() {\n        return getCurrentRenditions(this)[index];\n      }\n    });\n  }\n  queueMicrotask(() => {\n    if (!track.selected) return;\n    renditionList.dispatchEvent(new _rendition_event_js__WEBPACK_IMPORTED_MODULE_0__.RenditionEvent(\"addrendition\", { rendition }));\n  });\n}\nfunction removeRendition(rendition) {\n  const renditionList = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(rendition).media.videoRenditions;\n  const track = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(rendition).track;\n  const renditionSet = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(track).renditionSet;\n  renditionSet.delete(rendition);\n  queueMicrotask(() => {\n    const track2 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(rendition).track;\n    if (!track2.selected) return;\n    renditionList.dispatchEvent(new _rendition_event_js__WEBPACK_IMPORTED_MODULE_0__.RenditionEvent(\"removerendition\", { rendition }));\n  });\n}\nfunction selectedChanged(rendition) {\n  const renditionList = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(rendition).media.videoRenditions;\n  if (!renditionList || (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(renditionList).changeRequested) return;\n  (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(renditionList).changeRequested = true;\n  queueMicrotask(() => {\n    delete (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(renditionList).changeRequested;\n    const track = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(rendition).track;\n    if (!track.selected) return;\n    renditionList.dispatchEvent(new Event(\"change\"));\n  });\n}\nfunction getCurrentRenditions(renditionList) {\n  const media = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(renditionList).media;\n  return [...media.videoTracks].filter((track) => track.selected).flatMap((track) => [...(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(track).renditionSet]);\n}\nclass VideoRenditionList extends EventTarget {\n  #addRenditionCallback;\n  #removeRenditionCallback;\n  #changeCallback;\n  [Symbol.iterator]() {\n    return getCurrentRenditions(this).values();\n  }\n  get length() {\n    return getCurrentRenditions(this).length;\n  }\n  getRenditionById(id) {\n    return getCurrentRenditions(this).find((rendition) => `${rendition.id}` === `${id}`) ?? null;\n  }\n  get selectedIndex() {\n    return getCurrentRenditions(this).findIndex((rendition) => rendition.selected);\n  }\n  set selectedIndex(index) {\n    for (const [i, rendition] of getCurrentRenditions(this).entries()) {\n      rendition.selected = i === index;\n    }\n  }\n  get onaddrendition() {\n    return this.#addRenditionCallback;\n  }\n  set onaddrendition(callback) {\n    if (this.#addRenditionCallback) {\n      this.removeEventListener(\"addrendition\", this.#addRenditionCallback);\n      this.#addRenditionCallback = void 0;\n    }\n    if (typeof callback == \"function\") {\n      this.#addRenditionCallback = callback;\n      this.addEventListener(\"addrendition\", callback);\n    }\n  }\n  get onremoverendition() {\n    return this.#removeRenditionCallback;\n  }\n  set onremoverendition(callback) {\n    if (this.#removeRenditionCallback) {\n      this.removeEventListener(\"removerendition\", this.#removeRenditionCallback);\n      this.#removeRenditionCallback = void 0;\n    }\n    if (typeof callback == \"function\") {\n      this.#removeRenditionCallback = callback;\n      this.addEventListener(\"removerendition\", callback);\n    }\n  }\n  get onchange() {\n    return this.#changeCallback;\n  }\n  set onchange(callback) {\n    if (this.#changeCallback) {\n      this.removeEventListener(\"change\", this.#changeCallback);\n      this.#changeCallback = void 0;\n    }\n    if (typeof callback == \"function\") {\n      this.#changeCallback = callback;\n      this.addEventListener(\"change\", callback);\n    }\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZWRpYS10cmFja3MvZGlzdC92aWRlby1yZW5kaXRpb24tbGlzdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBc0Q7QUFDZDtBQUN4QztBQUNBLHdCQUF3QixxREFBVTtBQUNsQyxFQUFFLHFEQUFVLG9CQUFvQixxREFBVTtBQUMxQyxFQUFFLHFEQUFVO0FBQ1osdUJBQXVCLHFEQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywrREFBYyxtQkFBbUIsV0FBVztBQUNoRixHQUFHO0FBQ0g7QUFDQTtBQUNBLHdCQUF3QixxREFBVTtBQUNsQyxnQkFBZ0IscURBQVU7QUFDMUIsdUJBQXVCLHFEQUFVO0FBQ2pDO0FBQ0E7QUFDQSxtQkFBbUIscURBQVU7QUFDN0I7QUFDQSxvQ0FBb0MsK0RBQWMsc0JBQXNCLFdBQVc7QUFDbkYsR0FBRztBQUNIO0FBQ0E7QUFDQSx3QkFBd0IscURBQVU7QUFDbEMsd0JBQXdCLHFEQUFVO0FBQ2xDLEVBQUUscURBQVU7QUFDWjtBQUNBLFdBQVcscURBQVU7QUFDckIsa0JBQWtCLHFEQUFVO0FBQzVCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdCQUFnQixxREFBVTtBQUMxQix5RkFBeUYscURBQVU7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGFBQWEsU0FBUyxHQUFHO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9FdGhhbkxlZS9EZXNrdG9wL0FkdlgvQUktV2F0Y2gtQnVkZHkvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL21lZGlhLXRyYWNrcy9kaXN0L3ZpZGVvLXJlbmRpdGlvbi1saXN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlbmRpdGlvbkV2ZW50IH0gZnJvbSBcIi4vcmVuZGl0aW9uLWV2ZW50LmpzXCI7XG5pbXBvcnQgeyBnZXRQcml2YXRlIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbmZ1bmN0aW9uIGFkZFJlbmRpdGlvbih0cmFjaywgcmVuZGl0aW9uKSB7XG4gIGNvbnN0IHJlbmRpdGlvbkxpc3QgPSBnZXRQcml2YXRlKHRyYWNrKS5tZWRpYS52aWRlb1JlbmRpdGlvbnM7XG4gIGdldFByaXZhdGUocmVuZGl0aW9uKS5tZWRpYSA9IGdldFByaXZhdGUodHJhY2spLm1lZGlhO1xuICBnZXRQcml2YXRlKHJlbmRpdGlvbikudHJhY2sgPSB0cmFjaztcbiAgY29uc3QgcmVuZGl0aW9uU2V0ID0gZ2V0UHJpdmF0ZSh0cmFjaykucmVuZGl0aW9uU2V0O1xuICByZW5kaXRpb25TZXQuYWRkKHJlbmRpdGlvbik7XG4gIGNvbnN0IGluZGV4ID0gcmVuZGl0aW9uU2V0LnNpemUgLSAxO1xuICBpZiAoIShpbmRleCBpbiBWaWRlb1JlbmRpdGlvbkxpc3QucHJvdG90eXBlKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWRlb1JlbmRpdGlvbkxpc3QucHJvdG90eXBlLCBpbmRleCwge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gZ2V0Q3VycmVudFJlbmRpdGlvbnModGhpcylbaW5kZXhdO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICBpZiAoIXRyYWNrLnNlbGVjdGVkKSByZXR1cm47XG4gICAgcmVuZGl0aW9uTGlzdC5kaXNwYXRjaEV2ZW50KG5ldyBSZW5kaXRpb25FdmVudChcImFkZHJlbmRpdGlvblwiLCB7IHJlbmRpdGlvbiB9KSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVtb3ZlUmVuZGl0aW9uKHJlbmRpdGlvbikge1xuICBjb25zdCByZW5kaXRpb25MaXN0ID0gZ2V0UHJpdmF0ZShyZW5kaXRpb24pLm1lZGlhLnZpZGVvUmVuZGl0aW9ucztcbiAgY29uc3QgdHJhY2sgPSBnZXRQcml2YXRlKHJlbmRpdGlvbikudHJhY2s7XG4gIGNvbnN0IHJlbmRpdGlvblNldCA9IGdldFByaXZhdGUodHJhY2spLnJlbmRpdGlvblNldDtcbiAgcmVuZGl0aW9uU2V0LmRlbGV0ZShyZW5kaXRpb24pO1xuICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgY29uc3QgdHJhY2syID0gZ2V0UHJpdmF0ZShyZW5kaXRpb24pLnRyYWNrO1xuICAgIGlmICghdHJhY2syLnNlbGVjdGVkKSByZXR1cm47XG4gICAgcmVuZGl0aW9uTGlzdC5kaXNwYXRjaEV2ZW50KG5ldyBSZW5kaXRpb25FdmVudChcInJlbW92ZXJlbmRpdGlvblwiLCB7IHJlbmRpdGlvbiB9KSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gc2VsZWN0ZWRDaGFuZ2VkKHJlbmRpdGlvbikge1xuICBjb25zdCByZW5kaXRpb25MaXN0ID0gZ2V0UHJpdmF0ZShyZW5kaXRpb24pLm1lZGlhLnZpZGVvUmVuZGl0aW9ucztcbiAgaWYgKCFyZW5kaXRpb25MaXN0IHx8IGdldFByaXZhdGUocmVuZGl0aW9uTGlzdCkuY2hhbmdlUmVxdWVzdGVkKSByZXR1cm47XG4gIGdldFByaXZhdGUocmVuZGl0aW9uTGlzdCkuY2hhbmdlUmVxdWVzdGVkID0gdHJ1ZTtcbiAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgIGRlbGV0ZSBnZXRQcml2YXRlKHJlbmRpdGlvbkxpc3QpLmNoYW5nZVJlcXVlc3RlZDtcbiAgICBjb25zdCB0cmFjayA9IGdldFByaXZhdGUocmVuZGl0aW9uKS50cmFjaztcbiAgICBpZiAoIXRyYWNrLnNlbGVjdGVkKSByZXR1cm47XG4gICAgcmVuZGl0aW9uTGlzdC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcImNoYW5nZVwiKSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0Q3VycmVudFJlbmRpdGlvbnMocmVuZGl0aW9uTGlzdCkge1xuICBjb25zdCBtZWRpYSA9IGdldFByaXZhdGUocmVuZGl0aW9uTGlzdCkubWVkaWE7XG4gIHJldHVybiBbLi4ubWVkaWEudmlkZW9UcmFja3NdLmZpbHRlcigodHJhY2spID0+IHRyYWNrLnNlbGVjdGVkKS5mbGF0TWFwKCh0cmFjaykgPT4gWy4uLmdldFByaXZhdGUodHJhY2spLnJlbmRpdGlvblNldF0pO1xufVxuY2xhc3MgVmlkZW9SZW5kaXRpb25MaXN0IGV4dGVuZHMgRXZlbnRUYXJnZXQge1xuICAjYWRkUmVuZGl0aW9uQ2FsbGJhY2s7XG4gICNyZW1vdmVSZW5kaXRpb25DYWxsYmFjaztcbiAgI2NoYW5nZUNhbGxiYWNrO1xuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gZ2V0Q3VycmVudFJlbmRpdGlvbnModGhpcykudmFsdWVzKCk7XG4gIH1cbiAgZ2V0IGxlbmd0aCgpIHtcbiAgICByZXR1cm4gZ2V0Q3VycmVudFJlbmRpdGlvbnModGhpcykubGVuZ3RoO1xuICB9XG4gIGdldFJlbmRpdGlvbkJ5SWQoaWQpIHtcbiAgICByZXR1cm4gZ2V0Q3VycmVudFJlbmRpdGlvbnModGhpcykuZmluZCgocmVuZGl0aW9uKSA9PiBgJHtyZW5kaXRpb24uaWR9YCA9PT0gYCR7aWR9YCkgPz8gbnVsbDtcbiAgfVxuICBnZXQgc2VsZWN0ZWRJbmRleCgpIHtcbiAgICByZXR1cm4gZ2V0Q3VycmVudFJlbmRpdGlvbnModGhpcykuZmluZEluZGV4KChyZW5kaXRpb24pID0+IHJlbmRpdGlvbi5zZWxlY3RlZCk7XG4gIH1cbiAgc2V0IHNlbGVjdGVkSW5kZXgoaW5kZXgpIHtcbiAgICBmb3IgKGNvbnN0IFtpLCByZW5kaXRpb25dIG9mIGdldEN1cnJlbnRSZW5kaXRpb25zKHRoaXMpLmVudHJpZXMoKSkge1xuICAgICAgcmVuZGl0aW9uLnNlbGVjdGVkID0gaSA9PT0gaW5kZXg7XG4gICAgfVxuICB9XG4gIGdldCBvbmFkZHJlbmRpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy4jYWRkUmVuZGl0aW9uQ2FsbGJhY2s7XG4gIH1cbiAgc2V0IG9uYWRkcmVuZGl0aW9uKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuI2FkZFJlbmRpdGlvbkNhbGxiYWNrKSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhZGRyZW5kaXRpb25cIiwgdGhpcy4jYWRkUmVuZGl0aW9uQ2FsbGJhY2spO1xuICAgICAgdGhpcy4jYWRkUmVuZGl0aW9uQ2FsbGJhY2sgPSB2b2lkIDA7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aGlzLiNhZGRSZW5kaXRpb25DYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKFwiYWRkcmVuZGl0aW9uXCIsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cbiAgZ2V0IG9ucmVtb3ZlcmVuZGl0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLiNyZW1vdmVSZW5kaXRpb25DYWxsYmFjaztcbiAgfVxuICBzZXQgb25yZW1vdmVyZW5kaXRpb24oY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy4jcmVtb3ZlUmVuZGl0aW9uQ2FsbGJhY2spIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlbW92ZXJlbmRpdGlvblwiLCB0aGlzLiNyZW1vdmVSZW5kaXRpb25DYWxsYmFjayk7XG4gICAgICB0aGlzLiNyZW1vdmVSZW5kaXRpb25DYWxsYmFjayA9IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRoaXMuI3JlbW92ZVJlbmRpdGlvbkNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJyZW1vdmVyZW5kaXRpb25cIiwgY2FsbGJhY2spO1xuICAgIH1cbiAgfVxuICBnZXQgb25jaGFuZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NoYW5nZUNhbGxiYWNrO1xuICB9XG4gIHNldCBvbmNoYW5nZShjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLiNjaGFuZ2VDYWxsYmFjaykge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIHRoaXMuI2NoYW5nZUNhbGxiYWNrKTtcbiAgICAgIHRoaXMuI2NoYW5nZUNhbGxiYWNrID0gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhpcy4jY2hhbmdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBjYWxsYmFjayk7XG4gICAgfVxuICB9XG59XG5leHBvcnQge1xuICBWaWRlb1JlbmRpdGlvbkxpc3QsXG4gIGFkZFJlbmRpdGlvbixcbiAgcmVtb3ZlUmVuZGl0aW9uLFxuICBzZWxlY3RlZENoYW5nZWRcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/media-tracks/dist/video-rendition-list.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/media-tracks/dist/video-rendition.js":
/*!***********************************************************!*\
  !*** ./node_modules/media-tracks/dist/video-rendition.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VideoRendition: () => (/* binding */ VideoRendition)\n/* harmony export */ });\n/* harmony import */ var _video_rendition_list_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./video-rendition-list.js */ \"(app-pages-browser)/./node_modules/media-tracks/dist/video-rendition-list.js\");\n\nclass VideoRendition {\n  src;\n  id;\n  width;\n  height;\n  bitrate;\n  frameRate;\n  codec;\n  #selected = false;\n  get selected() {\n    return this.#selected;\n  }\n  set selected(val) {\n    if (this.#selected === val) return;\n    this.#selected = val;\n    (0,_video_rendition_list_js__WEBPACK_IMPORTED_MODULE_0__.selectedChanged)(this);\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZWRpYS10cmFja3MvZGlzdC92aWRlby1yZW5kaXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx5RUFBZTtBQUNuQjtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIi9Vc2Vycy9FdGhhbkxlZS9EZXNrdG9wL0FkdlgvQUktV2F0Y2gtQnVkZHkvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL21lZGlhLXRyYWNrcy9kaXN0L3ZpZGVvLXJlbmRpdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzZWxlY3RlZENoYW5nZWQgfSBmcm9tIFwiLi92aWRlby1yZW5kaXRpb24tbGlzdC5qc1wiO1xuY2xhc3MgVmlkZW9SZW5kaXRpb24ge1xuICBzcmM7XG4gIGlkO1xuICB3aWR0aDtcbiAgaGVpZ2h0O1xuICBiaXRyYXRlO1xuICBmcmFtZVJhdGU7XG4gIGNvZGVjO1xuICAjc2VsZWN0ZWQgPSBmYWxzZTtcbiAgZ2V0IHNlbGVjdGVkKCkge1xuICAgIHJldHVybiB0aGlzLiNzZWxlY3RlZDtcbiAgfVxuICBzZXQgc2VsZWN0ZWQodmFsKSB7XG4gICAgaWYgKHRoaXMuI3NlbGVjdGVkID09PSB2YWwpIHJldHVybjtcbiAgICB0aGlzLiNzZWxlY3RlZCA9IHZhbDtcbiAgICBzZWxlY3RlZENoYW5nZWQodGhpcyk7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIFZpZGVvUmVuZGl0aW9uXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/media-tracks/dist/video-rendition.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/media-tracks/dist/video-track-list.js":
/*!************************************************************!*\
  !*** ./node_modules/media-tracks/dist/video-track-list.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VideoTrackList: () => (/* binding */ VideoTrackList),\n/* harmony export */   addVideoTrack: () => (/* binding */ addVideoTrack),\n/* harmony export */   removeVideoTrack: () => (/* binding */ removeVideoTrack),\n/* harmony export */   selectedChanged: () => (/* binding */ selectedChanged)\n/* harmony export */ });\n/* harmony import */ var _track_event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./track-event.js */ \"(app-pages-browser)/./node_modules/media-tracks/dist/track-event.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/media-tracks/dist/utils.js\");\n\n\nfunction addVideoTrack(media, track) {\n  const trackList = media.videoTracks;\n  (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(track).media = media;\n  if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(track).renditionSet) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(track).renditionSet = /* @__PURE__ */ new Set();\n  }\n  const trackSet = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(trackList).trackSet;\n  trackSet.add(track);\n  const index = trackSet.size - 1;\n  if (!(index in VideoTrackList.prototype)) {\n    Object.defineProperty(VideoTrackList.prototype, index, {\n      get() {\n        return [...(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(this).trackSet][index];\n      }\n    });\n  }\n  queueMicrotask(() => {\n    trackList.dispatchEvent(new _track_event_js__WEBPACK_IMPORTED_MODULE_0__.TrackEvent(\"addtrack\", { track }));\n  });\n}\nfunction removeVideoTrack(track) {\n  const trackList = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(track).media?.videoTracks;\n  if (!trackList) return;\n  const trackSet = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(trackList).trackSet;\n  trackSet.delete(track);\n  queueMicrotask(() => {\n    trackList.dispatchEvent(new _track_event_js__WEBPACK_IMPORTED_MODULE_0__.TrackEvent(\"removetrack\", { track }));\n  });\n}\nfunction selectedChanged(selected) {\n  const trackList = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(selected).media.videoTracks ?? [];\n  let hasUnselected = false;\n  for (const track of trackList) {\n    if (track === selected) continue;\n    track.selected = false;\n    hasUnselected = true;\n  }\n  if (hasUnselected) {\n    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(trackList).changeRequested) return;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(trackList).changeRequested = true;\n    queueMicrotask(() => {\n      delete (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(trackList).changeRequested;\n      trackList.dispatchEvent(new Event(\"change\"));\n    });\n  }\n}\nclass VideoTrackList extends EventTarget {\n  #addTrackCallback;\n  #removeTrackCallback;\n  #changeCallback;\n  constructor() {\n    super();\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(this).trackSet = /* @__PURE__ */ new Set();\n  }\n  get #tracks() {\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPrivate)(this).trackSet;\n  }\n  [Symbol.iterator]() {\n    return this.#tracks.values();\n  }\n  get length() {\n    return this.#tracks.size;\n  }\n  getTrackById(id) {\n    return [...this.#tracks].find((track) => track.id === id) ?? null;\n  }\n  get selectedIndex() {\n    return [...this.#tracks].findIndex((track) => track.selected);\n  }\n  get onaddtrack() {\n    return this.#addTrackCallback;\n  }\n  set onaddtrack(callback) {\n    if (this.#addTrackCallback) {\n      this.removeEventListener(\"addtrack\", this.#addTrackCallback);\n      this.#addTrackCallback = void 0;\n    }\n    if (typeof callback == \"function\") {\n      this.#addTrackCallback = callback;\n      this.addEventListener(\"addtrack\", callback);\n    }\n  }\n  get onremovetrack() {\n    return this.#removeTrackCallback;\n  }\n  set onremovetrack(callback) {\n    if (this.#removeTrackCallback) {\n      this.removeEventListener(\"removetrack\", this.#removeTrackCallback);\n      this.#removeTrackCallback = void 0;\n    }\n    if (typeof callback == \"function\") {\n      this.#removeTrackCallback = callback;\n      this.addEventListener(\"removetrack\", callback);\n    }\n  }\n  get onchange() {\n    return this.#changeCallback;\n  }\n  set onchange(callback) {\n    if (this.#changeCallback) {\n      this.removeEventListener(\"change\", this.#changeCallback);\n      this.#changeCallback = void 0;\n    }\n    if (typeof callback == \"function\") {\n      this.#changeCallback = callback;\n      this.addEventListener(\"change\", callback);\n    }\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZWRpYS10cmFja3MvZGlzdC92aWRlby10cmFjay1saXN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUE4QztBQUNOO0FBQ3hDO0FBQ0E7QUFDQSxFQUFFLHFEQUFVO0FBQ1osT0FBTyxxREFBVTtBQUNqQixJQUFJLHFEQUFVO0FBQ2Q7QUFDQSxtQkFBbUIscURBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxREFBVTtBQUM3QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0NBQWdDLHVEQUFVLGVBQWUsT0FBTztBQUNoRSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG9CQUFvQixxREFBVTtBQUM5QjtBQUNBLG1CQUFtQixxREFBVTtBQUM3QjtBQUNBO0FBQ0EsZ0NBQWdDLHVEQUFVLGtCQUFrQixPQUFPO0FBQ25FLEdBQUc7QUFDSDtBQUNBO0FBQ0Esb0JBQW9CLHFEQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxxREFBVTtBQUNsQixJQUFJLHFEQUFVO0FBQ2Q7QUFDQSxhQUFhLHFEQUFVO0FBQ3ZCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHFEQUFVO0FBQ2Q7QUFDQTtBQUNBLFdBQVcscURBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1FIiwic291cmNlcyI6WyIvVXNlcnMvRXRoYW5MZWUvRGVza3RvcC9BZHZYL0FJLVdhdGNoLUJ1ZGR5L2Zyb250ZW5kL25vZGVfbW9kdWxlcy9tZWRpYS10cmFja3MvZGlzdC92aWRlby10cmFjay1saXN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRyYWNrRXZlbnQgfSBmcm9tIFwiLi90cmFjay1ldmVudC5qc1wiO1xuaW1wb3J0IHsgZ2V0UHJpdmF0ZSB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5mdW5jdGlvbiBhZGRWaWRlb1RyYWNrKG1lZGlhLCB0cmFjaykge1xuICBjb25zdCB0cmFja0xpc3QgPSBtZWRpYS52aWRlb1RyYWNrcztcbiAgZ2V0UHJpdmF0ZSh0cmFjaykubWVkaWEgPSBtZWRpYTtcbiAgaWYgKCFnZXRQcml2YXRlKHRyYWNrKS5yZW5kaXRpb25TZXQpIHtcbiAgICBnZXRQcml2YXRlKHRyYWNrKS5yZW5kaXRpb25TZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICB9XG4gIGNvbnN0IHRyYWNrU2V0ID0gZ2V0UHJpdmF0ZSh0cmFja0xpc3QpLnRyYWNrU2V0O1xuICB0cmFja1NldC5hZGQodHJhY2spO1xuICBjb25zdCBpbmRleCA9IHRyYWNrU2V0LnNpemUgLSAxO1xuICBpZiAoIShpbmRleCBpbiBWaWRlb1RyYWNrTGlzdC5wcm90b3R5cGUpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZGVvVHJhY2tMaXN0LnByb3RvdHlwZSwgaW5kZXgsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIFsuLi5nZXRQcml2YXRlKHRoaXMpLnRyYWNrU2V0XVtpbmRleF07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgIHRyYWNrTGlzdC5kaXNwYXRjaEV2ZW50KG5ldyBUcmFja0V2ZW50KFwiYWRkdHJhY2tcIiwgeyB0cmFjayB9KSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVtb3ZlVmlkZW9UcmFjayh0cmFjaykge1xuICBjb25zdCB0cmFja0xpc3QgPSBnZXRQcml2YXRlKHRyYWNrKS5tZWRpYT8udmlkZW9UcmFja3M7XG4gIGlmICghdHJhY2tMaXN0KSByZXR1cm47XG4gIGNvbnN0IHRyYWNrU2V0ID0gZ2V0UHJpdmF0ZSh0cmFja0xpc3QpLnRyYWNrU2V0O1xuICB0cmFja1NldC5kZWxldGUodHJhY2spO1xuICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgdHJhY2tMaXN0LmRpc3BhdGNoRXZlbnQobmV3IFRyYWNrRXZlbnQoXCJyZW1vdmV0cmFja1wiLCB7IHRyYWNrIH0pKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBzZWxlY3RlZENoYW5nZWQoc2VsZWN0ZWQpIHtcbiAgY29uc3QgdHJhY2tMaXN0ID0gZ2V0UHJpdmF0ZShzZWxlY3RlZCkubWVkaWEudmlkZW9UcmFja3MgPz8gW107XG4gIGxldCBoYXNVbnNlbGVjdGVkID0gZmFsc2U7XG4gIGZvciAoY29uc3QgdHJhY2sgb2YgdHJhY2tMaXN0KSB7XG4gICAgaWYgKHRyYWNrID09PSBzZWxlY3RlZCkgY29udGludWU7XG4gICAgdHJhY2suc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICBoYXNVbnNlbGVjdGVkID0gdHJ1ZTtcbiAgfVxuICBpZiAoaGFzVW5zZWxlY3RlZCkge1xuICAgIGlmIChnZXRQcml2YXRlKHRyYWNrTGlzdCkuY2hhbmdlUmVxdWVzdGVkKSByZXR1cm47XG4gICAgZ2V0UHJpdmF0ZSh0cmFja0xpc3QpLmNoYW5nZVJlcXVlc3RlZCA9IHRydWU7XG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgZGVsZXRlIGdldFByaXZhdGUodHJhY2tMaXN0KS5jaGFuZ2VSZXF1ZXN0ZWQ7XG4gICAgICB0cmFja0xpc3QuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJjaGFuZ2VcIikpO1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBWaWRlb1RyYWNrTGlzdCBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcbiAgI2FkZFRyYWNrQ2FsbGJhY2s7XG4gICNyZW1vdmVUcmFja0NhbGxiYWNrO1xuICAjY2hhbmdlQ2FsbGJhY2s7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgZ2V0UHJpdmF0ZSh0aGlzKS50cmFja1NldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIH1cbiAgZ2V0ICN0cmFja3MoKSB7XG4gICAgcmV0dXJuIGdldFByaXZhdGUodGhpcykudHJhY2tTZXQ7XG4gIH1cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIHRoaXMuI3RyYWNrcy52YWx1ZXMoKTtcbiAgfVxuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLiN0cmFja3Muc2l6ZTtcbiAgfVxuICBnZXRUcmFja0J5SWQoaWQpIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuI3RyYWNrc10uZmluZCgodHJhY2spID0+IHRyYWNrLmlkID09PSBpZCkgPz8gbnVsbDtcbiAgfVxuICBnZXQgc2VsZWN0ZWRJbmRleCgpIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuI3RyYWNrc10uZmluZEluZGV4KCh0cmFjaykgPT4gdHJhY2suc2VsZWN0ZWQpO1xuICB9XG4gIGdldCBvbmFkZHRyYWNrKCkge1xuICAgIHJldHVybiB0aGlzLiNhZGRUcmFja0NhbGxiYWNrO1xuICB9XG4gIHNldCBvbmFkZHRyYWNrKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuI2FkZFRyYWNrQ2FsbGJhY2spIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFkZHRyYWNrXCIsIHRoaXMuI2FkZFRyYWNrQ2FsbGJhY2spO1xuICAgICAgdGhpcy4jYWRkVHJhY2tDYWxsYmFjayA9IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRoaXMuI2FkZFRyYWNrQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcImFkZHRyYWNrXCIsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cbiAgZ2V0IG9ucmVtb3ZldHJhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JlbW92ZVRyYWNrQ2FsbGJhY2s7XG4gIH1cbiAgc2V0IG9ucmVtb3ZldHJhY2soY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy4jcmVtb3ZlVHJhY2tDYWxsYmFjaykge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVtb3ZldHJhY2tcIiwgdGhpcy4jcmVtb3ZlVHJhY2tDYWxsYmFjayk7XG4gICAgICB0aGlzLiNyZW1vdmVUcmFja0NhbGxiYWNrID0gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhpcy4jcmVtb3ZlVHJhY2tDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKFwicmVtb3ZldHJhY2tcIiwgY2FsbGJhY2spO1xuICAgIH1cbiAgfVxuICBnZXQgb25jaGFuZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NoYW5nZUNhbGxiYWNrO1xuICB9XG4gIHNldCBvbmNoYW5nZShjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLiNjaGFuZ2VDYWxsYmFjaykge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIHRoaXMuI2NoYW5nZUNhbGxiYWNrKTtcbiAgICAgIHRoaXMuI2NoYW5nZUNhbGxiYWNrID0gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhpcy4jY2hhbmdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBjYWxsYmFjayk7XG4gICAgfVxuICB9XG59XG5leHBvcnQge1xuICBWaWRlb1RyYWNrTGlzdCxcbiAgYWRkVmlkZW9UcmFjayxcbiAgcmVtb3ZlVmlkZW9UcmFjayxcbiAgc2VsZWN0ZWRDaGFuZ2VkXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/media-tracks/dist/video-track-list.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/media-tracks/dist/video-track.js":
/*!*******************************************************!*\
  !*** ./node_modules/media-tracks/dist/video-track.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VideoTrack: () => (/* binding */ VideoTrack),\n/* harmony export */   VideoTrackKind: () => (/* binding */ VideoTrackKind)\n/* harmony export */ });\n/* harmony import */ var _video_track_list_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./video-track-list.js */ \"(app-pages-browser)/./node_modules/media-tracks/dist/video-track-list.js\");\n/* harmony import */ var _video_rendition_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./video-rendition.js */ \"(app-pages-browser)/./node_modules/media-tracks/dist/video-rendition.js\");\n/* harmony import */ var _video_rendition_list_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./video-rendition-list.js */ \"(app-pages-browser)/./node_modules/media-tracks/dist/video-rendition-list.js\");\n\n\n\nconst VideoTrackKind = {\n  alternative: \"alternative\",\n  captions: \"captions\",\n  main: \"main\",\n  sign: \"sign\",\n  subtitles: \"subtitles\",\n  commentary: \"commentary\"\n};\nclass VideoTrack {\n  id;\n  kind;\n  label = \"\";\n  language = \"\";\n  sourceBuffer;\n  #selected = false;\n  addRendition(src, width, height, codec, bitrate, frameRate) {\n    const rendition = new _video_rendition_js__WEBPACK_IMPORTED_MODULE_1__.VideoRendition();\n    rendition.src = src;\n    rendition.width = width;\n    rendition.height = height;\n    rendition.frameRate = frameRate;\n    rendition.bitrate = bitrate;\n    rendition.codec = codec;\n    (0,_video_rendition_list_js__WEBPACK_IMPORTED_MODULE_2__.addRendition)(this, rendition);\n    return rendition;\n  }\n  removeRendition(rendition) {\n    (0,_video_rendition_list_js__WEBPACK_IMPORTED_MODULE_2__.removeRendition)(rendition);\n  }\n  get selected() {\n    return this.#selected;\n  }\n  set selected(val) {\n    if (this.#selected === val) return;\n    this.#selected = val;\n    if (val !== true) return;\n    (0,_video_track_list_js__WEBPACK_IMPORTED_MODULE_0__.selectedChanged)(this);\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZWRpYS10cmFja3MvZGlzdC92aWRlby10cmFjay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUF3RDtBQUNGO0FBQ29CO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLCtEQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksc0VBQVk7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsSUFBSSx5RUFBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxxRUFBZTtBQUNuQjtBQUNBO0FBSUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9FdGhhbkxlZS9EZXNrdG9wL0FkdlgvQUktV2F0Y2gtQnVkZHkvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL21lZGlhLXRyYWNrcy9kaXN0L3ZpZGVvLXRyYWNrLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNlbGVjdGVkQ2hhbmdlZCB9IGZyb20gXCIuL3ZpZGVvLXRyYWNrLWxpc3QuanNcIjtcbmltcG9ydCB7IFZpZGVvUmVuZGl0aW9uIH0gZnJvbSBcIi4vdmlkZW8tcmVuZGl0aW9uLmpzXCI7XG5pbXBvcnQgeyBhZGRSZW5kaXRpb24sIHJlbW92ZVJlbmRpdGlvbiB9IGZyb20gXCIuL3ZpZGVvLXJlbmRpdGlvbi1saXN0LmpzXCI7XG5jb25zdCBWaWRlb1RyYWNrS2luZCA9IHtcbiAgYWx0ZXJuYXRpdmU6IFwiYWx0ZXJuYXRpdmVcIixcbiAgY2FwdGlvbnM6IFwiY2FwdGlvbnNcIixcbiAgbWFpbjogXCJtYWluXCIsXG4gIHNpZ246IFwic2lnblwiLFxuICBzdWJ0aXRsZXM6IFwic3VidGl0bGVzXCIsXG4gIGNvbW1lbnRhcnk6IFwiY29tbWVudGFyeVwiXG59O1xuY2xhc3MgVmlkZW9UcmFjayB7XG4gIGlkO1xuICBraW5kO1xuICBsYWJlbCA9IFwiXCI7XG4gIGxhbmd1YWdlID0gXCJcIjtcbiAgc291cmNlQnVmZmVyO1xuICAjc2VsZWN0ZWQgPSBmYWxzZTtcbiAgYWRkUmVuZGl0aW9uKHNyYywgd2lkdGgsIGhlaWdodCwgY29kZWMsIGJpdHJhdGUsIGZyYW1lUmF0ZSkge1xuICAgIGNvbnN0IHJlbmRpdGlvbiA9IG5ldyBWaWRlb1JlbmRpdGlvbigpO1xuICAgIHJlbmRpdGlvbi5zcmMgPSBzcmM7XG4gICAgcmVuZGl0aW9uLndpZHRoID0gd2lkdGg7XG4gICAgcmVuZGl0aW9uLmhlaWdodCA9IGhlaWdodDtcbiAgICByZW5kaXRpb24uZnJhbWVSYXRlID0gZnJhbWVSYXRlO1xuICAgIHJlbmRpdGlvbi5iaXRyYXRlID0gYml0cmF0ZTtcbiAgICByZW5kaXRpb24uY29kZWMgPSBjb2RlYztcbiAgICBhZGRSZW5kaXRpb24odGhpcywgcmVuZGl0aW9uKTtcbiAgICByZXR1cm4gcmVuZGl0aW9uO1xuICB9XG4gIHJlbW92ZVJlbmRpdGlvbihyZW5kaXRpb24pIHtcbiAgICByZW1vdmVSZW5kaXRpb24ocmVuZGl0aW9uKTtcbiAgfVxuICBnZXQgc2VsZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NlbGVjdGVkO1xuICB9XG4gIHNldCBzZWxlY3RlZCh2YWwpIHtcbiAgICBpZiAodGhpcy4jc2VsZWN0ZWQgPT09IHZhbCkgcmV0dXJuO1xuICAgIHRoaXMuI3NlbGVjdGVkID0gdmFsO1xuICAgIGlmICh2YWwgIT09IHRydWUpIHJldHVybjtcbiAgICBzZWxlY3RlZENoYW5nZWQodGhpcyk7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIFZpZGVvVHJhY2ssXG4gIFZpZGVvVHJhY2tLaW5kXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/media-tracks/dist/video-track.js\n"));

/***/ })

}]);