"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/castable-video";
exports.ids = ["vendor-chunks/castable-video"];
exports.modules = {

/***/ "(ssr)/./node_modules/castable-video/castable-mixin.js":
/*!*******************************************************!*\
  !*** ./node_modules/castable-video/castable-mixin.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CastableMediaMixin: () => (/* binding */ CastableMediaMixin),\n/* harmony export */   CastableVideoMixin: () => (/* binding */ CastableVideoMixin)\n/* harmony export */ });\n/* harmony import */ var _castable_remote_playback_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./castable-remote-playback.js */ \"(ssr)/./node_modules/castable-video/castable-remote-playback.js\");\n/* harmony import */ var _castable_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./castable-utils.js */ \"(ssr)/./node_modules/castable-video/castable-utils.js\");\n/* global chrome */\n\n\n\n/**\n * CastableMediaMixin\n *\n * This mixin function provides a way to compose multiple classes.\n * @see https://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/\n *\n * @param  {HTMLMediaElement} superclass - HTMLMediaElement or an extended class of it.\n * @return {CastableMedia}\n */\nconst CastableMediaMixin = (superclass) =>\n  class CastableMedia extends superclass {\n\n    static observedAttributes = [\n      ...(superclass.observedAttributes ?? []),\n      'cast-src',\n      'cast-content-type',\n      'cast-stream-type',\n      'cast-receiver',\n    ];\n\n    #localState = { paused: false };\n    #castOptions = (0,_castable_utils_js__WEBPACK_IMPORTED_MODULE_1__.getDefaultCastOptions)();\n    #castCustomData;\n    #remote;\n\n    get remote() {\n      if (this.#remote) return this.#remote;\n\n      if ((0,_castable_utils_js__WEBPACK_IMPORTED_MODULE_1__.requiresCastFramework)()) {\n        // No need to load the Cast framework if it's disabled.\n        if (!this.disableRemotePlayback) {\n          (0,_castable_utils_js__WEBPACK_IMPORTED_MODULE_1__.loadCastFramework)();\n        }\n\n        _castable_utils_js__WEBPACK_IMPORTED_MODULE_1__.privateProps.set(this, {\n          loadOnPrompt: () => this.#loadOnPrompt()\n        });\n\n        return (this.#remote = new _castable_remote_playback_js__WEBPACK_IMPORTED_MODULE_0__.RemotePlayback(this));\n      }\n\n      return super.remote;\n    }\n\n    get #castPlayer() {\n      return _castable_utils_js__WEBPACK_IMPORTED_MODULE_1__.privateProps.get(this.remote)?.getCastPlayer?.();\n    }\n\n    attributeChangedCallback(attrName, oldValue, newValue) {\n      super.attributeChangedCallback(attrName, oldValue, newValue);\n\n      if (attrName === 'cast-receiver' && newValue) {\n        this.#castOptions.receiverApplicationId = newValue;\n        return;\n      }\n\n      if (!this.#castPlayer) return;\n\n      switch (attrName) {\n        case 'cast-stream-type':\n        case 'cast-src':\n          this.load();\n          break;\n      }\n    }\n\n    async #loadOnPrompt() {\n      // Pause locally when the session is created.\n      this.#localState.paused = super.paused;\n      super.pause();\n\n      // Sync over the muted state but not volume, 100% is different on TV's :P\n      this.muted = super.muted;\n\n      try {\n        await this.load();\n      } catch (err) {\n        console.error(err);\n      }\n    }\n\n    async load() {\n      if (!this.#castPlayer) return super.load();\n\n      const mediaInfo = new chrome.cast.media.MediaInfo(this.castSrc, this.castContentType);\n      mediaInfo.customData = this.castCustomData;\n\n      // Manually add text tracks with a `src` attribute.\n      // M3U8's load text tracks in the receiver, handle these in the media loaded event.\n      const subtitles = [...this.querySelectorAll('track')].filter(\n        ({ kind, src }) => src && (kind === 'subtitles' || kind === 'captions')\n      );\n\n      const activeTrackIds = [];\n      let textTrackIdCount = 0;\n\n      if (subtitles.length) {\n        mediaInfo.tracks = subtitles.map((trackEl) => {\n          const trackId = ++textTrackIdCount;\n          // only activate 1 subtitle text track.\n          if (activeTrackIds.length === 0 && trackEl.track.mode === 'showing') {\n            activeTrackIds.push(trackId);\n          }\n\n          const track = new chrome.cast.media.Track(\n            trackId,\n            chrome.cast.media.TrackType.TEXT\n          );\n          track.trackContentId = trackEl.src;\n          track.trackContentType = 'text/vtt';\n          track.subtype =\n            trackEl.kind === 'captions'\n              ? chrome.cast.media.TextTrackType.CAPTIONS\n              : chrome.cast.media.TextTrackType.SUBTITLES;\n          track.name = trackEl.label;\n          track.language = trackEl.srclang;\n          return track;\n        });\n      }\n\n      if (this.castStreamType === 'live') {\n        mediaInfo.streamType = chrome.cast.media.StreamType.LIVE;\n      } else {\n        mediaInfo.streamType = chrome.cast.media.StreamType.BUFFERED;\n      }\n\n      mediaInfo.metadata = new chrome.cast.media.GenericMediaMetadata();\n      mediaInfo.metadata.title = this.title;\n      mediaInfo.metadata.images = [{ url: this.poster }];\n\n      if ((0,_castable_utils_js__WEBPACK_IMPORTED_MODULE_1__.isHls)(this.castSrc)) {\n        const segmentFormat = await (0,_castable_utils_js__WEBPACK_IMPORTED_MODULE_1__.getPlaylistSegmentFormat)(this.castSrc);\n        const isFragmentedMP4 = segmentFormat?.includes('m4s') || segmentFormat?.includes('mp4');\n        if (isFragmentedMP4) {\n          mediaInfo.hlsSegmentFormat = chrome.cast.media.HlsSegmentFormat.FMP4;\n          mediaInfo.hlsVideoSegmentFormat = chrome.cast.media.HlsVideoSegmentFormat.FMP4;\n        }\n      }\n\n      const request = new chrome.cast.media.LoadRequest(mediaInfo);\n      request.currentTime = super.currentTime ?? 0;\n      request.autoplay = !this.#localState.paused;\n      request.activeTrackIds = activeTrackIds;\n\n      await (0,_castable_utils_js__WEBPACK_IMPORTED_MODULE_1__.currentSession)()?.loadMedia(request);\n\n      this.dispatchEvent(new Event('volumechange'));\n    }\n\n    play() {\n      if (this.#castPlayer) {\n        if (this.#castPlayer.isPaused) {\n          this.#castPlayer.controller?.playOrPause();\n        }\n        return;\n      }\n      return super.play();\n    }\n\n    pause() {\n      if (this.#castPlayer) {\n        if (!this.#castPlayer.isPaused) {\n          this.#castPlayer.controller?.playOrPause();\n        }\n        return;\n      }\n      super.pause();\n    }\n\n    /**\n     * @see https://developers.google.com/cast/docs/reference/web_sender/cast.framework.CastOptions\n     * @readonly\n     *\n     * @typedef {Object} CastOptions\n     * @property {string} [receiverApplicationId='CC1AD845'] - The app id of the cast receiver.\n     * @property {string} [autoJoinPolicy='origin_scoped'] - The auto join policy.\n     * @property {string} [language='en-US'] - The language to use for the cast receiver.\n     * @property {boolean} [androidReceiverCompatible=false] - Whether to use the Cast Connect.\n     * @property {boolean} [resumeSavedSession=true] - Whether to resume the last session.\n     *\n     * @return {CastOptions}\n     */\n    get castOptions() {\n      return this.#castOptions;\n    }\n\n    get castReceiver() {\n      return this.getAttribute('cast-receiver') ?? undefined;\n    }\n\n    set castReceiver(val) {\n      if (this.castReceiver == val) return;\n      this.setAttribute('cast-receiver', `${val}`);\n    }\n\n    // Allow the cast source url to be different than <video src>, could be a blob.\n    get castSrc() {\n      // Try the first <source src> for usage with even more native markup.\n      return (\n        this.getAttribute('cast-src') ??\n        this.querySelector('source')?.src ??\n        this.currentSrc\n      );\n    }\n\n    set castSrc(val) {\n      if (this.castSrc == val) return;\n      this.setAttribute('cast-src', `${val}`);\n    }\n\n    get castContentType() {\n      return this.getAttribute('cast-content-type') ?? undefined;\n    }\n\n    set castContentType(val) {\n      this.setAttribute('cast-content-type', `${val}`);\n    }\n\n    get castStreamType() {\n      // NOTE: Per https://github.com/video-dev/media-ui-extensions/issues/3 `streamType` may yield `\"unknown\"`\n      return this.getAttribute('cast-stream-type') ?? this.streamType ?? undefined;\n    }\n\n    set castStreamType(val) {\n      this.setAttribute('cast-stream-type', `${val}`);\n    }\n\n    get castCustomData() {\n      return this.#castCustomData;\n    }\n\n    set castCustomData(val) {\n      const valType = typeof val;\n      if (!['object', 'undefined'].includes(valType)) {\n        console.error(`castCustomData must be nullish or an object but value was of type ${valType}`);\n        return;\n      }\n\n      this.#castCustomData = val;\n    }\n\n    get readyState() {\n      if (this.#castPlayer) {\n        switch (this.#castPlayer.playerState) {\n          case chrome.cast.media.PlayerState.IDLE:\n            return 0;\n          case chrome.cast.media.PlayerState.BUFFERING:\n            return 2;\n          default:\n            return 3;\n        }\n      }\n      return super.readyState;\n    }\n\n    get paused() {\n      if (this.#castPlayer) return this.#castPlayer.isPaused;\n      return super.paused;\n    }\n\n    get muted() {\n      if (this.#castPlayer) return this.#castPlayer?.isMuted;\n      return super.muted;\n    }\n\n    set muted(val) {\n      if (this.#castPlayer) {\n        if (\n          (val && !this.#castPlayer.isMuted) ||\n          (!val && this.#castPlayer.isMuted)\n        ) {\n          this.#castPlayer.controller?.muteOrUnmute();\n        }\n        return;\n      }\n      super.muted = val;\n    }\n\n    get volume() {\n      if (this.#castPlayer) return this.#castPlayer?.volumeLevel ?? 1;\n      return super.volume;\n    }\n\n    set volume(val) {\n      if (this.#castPlayer) {\n        this.#castPlayer.volumeLevel = +val;\n        this.#castPlayer.controller?.setVolumeLevel();\n        return;\n      }\n      super.volume = val;\n    }\n\n    get duration() {\n      // castPlayer duration returns `0` when no media is loaded.\n      if (this.#castPlayer && this.#castPlayer?.isMediaLoaded) {\n        return this.#castPlayer?.duration ?? NaN;\n      }\n      return super.duration;\n    }\n\n    get currentTime() {\n      if (this.#castPlayer && this.#castPlayer?.isMediaLoaded) {\n        return this.#castPlayer?.currentTime ?? 0;\n      }\n      return super.currentTime;\n    }\n\n    set currentTime(val) {\n      if (this.#castPlayer) {\n        this.#castPlayer.currentTime = val;\n        this.#castPlayer.controller?.seek();\n        return;\n      }\n      super.currentTime = val;\n    }\n  };\n\nconst CastableVideoMixin = CastableMediaMixin;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2FzdGFibGUtdmlkZW8vY2FzdGFibGUtbWl4aW4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQytEO0FBU2xDOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QixZQUFZO0FBQ1o7QUFDTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQixtQkFBbUIseUVBQXFCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxVQUFVLHlFQUFxQjtBQUMvQjtBQUNBO0FBQ0EsVUFBVSxxRUFBaUI7QUFDM0I7O0FBRUEsUUFBUSw0REFBWTtBQUNwQjtBQUNBLFNBQVM7O0FBRVQsbUNBQW1DLHdFQUFjO0FBQ2pEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLDREQUFZO0FBQ3pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUMsa0JBQWtCOztBQUV2RCxVQUFVLHlEQUFLO0FBQ2Ysb0NBQW9DLDRFQUF3QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxrRUFBYzs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekIsa0JBQWtCLFFBQVE7QUFDMUIsa0JBQWtCLFFBQVE7QUFDMUIsa0JBQWtCLFFBQVE7QUFDMUIsa0JBQWtCLFNBQVM7QUFDM0Isa0JBQWtCLFNBQVM7QUFDM0I7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEMsSUFBSTtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QyxJQUFJO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRCxJQUFJO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDLElBQUk7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRixRQUFRO0FBQ25HO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPIiwic291cmNlcyI6WyIvVXNlcnMvRXRoYW5MZWUvRGVza3RvcC9BZHZYL0FJLVdhdGNoLUJ1ZGR5L2Zyb250ZW5kL25vZGVfbW9kdWxlcy9jYXN0YWJsZS12aWRlby9jYXN0YWJsZS1taXhpbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWwgY2hyb21lICovXG5pbXBvcnQgeyBSZW1vdGVQbGF5YmFjayB9IGZyb20gJy4vY2FzdGFibGUtcmVtb3RlLXBsYXliYWNrLmpzJztcbmltcG9ydCB7XG4gIHByaXZhdGVQcm9wcyxcbiAgcmVxdWlyZXNDYXN0RnJhbWV3b3JrLFxuICBsb2FkQ2FzdEZyYW1ld29yayxcbiAgY3VycmVudFNlc3Npb24sXG4gIGdldERlZmF1bHRDYXN0T3B0aW9ucyxcbiAgaXNIbHMsXG4gIGdldFBsYXlsaXN0U2VnbWVudEZvcm1hdFxufSBmcm9tICcuL2Nhc3RhYmxlLXV0aWxzLmpzJztcblxuLyoqXG4gKiBDYXN0YWJsZU1lZGlhTWl4aW5cbiAqXG4gKiBUaGlzIG1peGluIGZ1bmN0aW9uIHByb3ZpZGVzIGEgd2F5IHRvIGNvbXBvc2UgbXVsdGlwbGUgY2xhc3Nlcy5cbiAqIEBzZWUgaHR0cHM6Ly9qdXN0aW5mYWduYW5pLmNvbS8yMDE1LzEyLzIxL3JlYWwtbWl4aW5zLXdpdGgtamF2YXNjcmlwdC1jbGFzc2VzL1xuICpcbiAqIEBwYXJhbSAge0hUTUxNZWRpYUVsZW1lbnR9IHN1cGVyY2xhc3MgLSBIVE1MTWVkaWFFbGVtZW50IG9yIGFuIGV4dGVuZGVkIGNsYXNzIG9mIGl0LlxuICogQHJldHVybiB7Q2FzdGFibGVNZWRpYX1cbiAqL1xuZXhwb3J0IGNvbnN0IENhc3RhYmxlTWVkaWFNaXhpbiA9IChzdXBlcmNsYXNzKSA9PlxuICBjbGFzcyBDYXN0YWJsZU1lZGlhIGV4dGVuZHMgc3VwZXJjbGFzcyB7XG5cbiAgICBzdGF0aWMgb2JzZXJ2ZWRBdHRyaWJ1dGVzID0gW1xuICAgICAgLi4uKHN1cGVyY2xhc3Mub2JzZXJ2ZWRBdHRyaWJ1dGVzID8/IFtdKSxcbiAgICAgICdjYXN0LXNyYycsXG4gICAgICAnY2FzdC1jb250ZW50LXR5cGUnLFxuICAgICAgJ2Nhc3Qtc3RyZWFtLXR5cGUnLFxuICAgICAgJ2Nhc3QtcmVjZWl2ZXInLFxuICAgIF07XG5cbiAgICAjbG9jYWxTdGF0ZSA9IHsgcGF1c2VkOiBmYWxzZSB9O1xuICAgICNjYXN0T3B0aW9ucyA9IGdldERlZmF1bHRDYXN0T3B0aW9ucygpO1xuICAgICNjYXN0Q3VzdG9tRGF0YTtcbiAgICAjcmVtb3RlO1xuXG4gICAgZ2V0IHJlbW90ZSgpIHtcbiAgICAgIGlmICh0aGlzLiNyZW1vdGUpIHJldHVybiB0aGlzLiNyZW1vdGU7XG5cbiAgICAgIGlmIChyZXF1aXJlc0Nhc3RGcmFtZXdvcmsoKSkge1xuICAgICAgICAvLyBObyBuZWVkIHRvIGxvYWQgdGhlIENhc3QgZnJhbWV3b3JrIGlmIGl0J3MgZGlzYWJsZWQuXG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlUmVtb3RlUGxheWJhY2spIHtcbiAgICAgICAgICBsb2FkQ2FzdEZyYW1ld29yaygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJpdmF0ZVByb3BzLnNldCh0aGlzLCB7XG4gICAgICAgICAgbG9hZE9uUHJvbXB0OiAoKSA9PiB0aGlzLiNsb2FkT25Qcm9tcHQoKVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gKHRoaXMuI3JlbW90ZSA9IG5ldyBSZW1vdGVQbGF5YmFjayh0aGlzKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdXBlci5yZW1vdGU7XG4gICAgfVxuXG4gICAgZ2V0ICNjYXN0UGxheWVyKCkge1xuICAgICAgcmV0dXJuIHByaXZhdGVQcm9wcy5nZXQodGhpcy5yZW1vdGUpPy5nZXRDYXN0UGxheWVyPy4oKTtcbiAgICB9XG5cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0ck5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgICAgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGF0dHJOYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpO1xuXG4gICAgICBpZiAoYXR0ck5hbWUgPT09ICdjYXN0LXJlY2VpdmVyJyAmJiBuZXdWYWx1ZSkge1xuICAgICAgICB0aGlzLiNjYXN0T3B0aW9ucy5yZWNlaXZlckFwcGxpY2F0aW9uSWQgPSBuZXdWYWx1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuI2Nhc3RQbGF5ZXIpIHJldHVybjtcblxuICAgICAgc3dpdGNoIChhdHRyTmFtZSkge1xuICAgICAgICBjYXNlICdjYXN0LXN0cmVhbS10eXBlJzpcbiAgICAgICAgY2FzZSAnY2FzdC1zcmMnOlxuICAgICAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jICNsb2FkT25Qcm9tcHQoKSB7XG4gICAgICAvLyBQYXVzZSBsb2NhbGx5IHdoZW4gdGhlIHNlc3Npb24gaXMgY3JlYXRlZC5cbiAgICAgIHRoaXMuI2xvY2FsU3RhdGUucGF1c2VkID0gc3VwZXIucGF1c2VkO1xuICAgICAgc3VwZXIucGF1c2UoKTtcblxuICAgICAgLy8gU3luYyBvdmVyIHRoZSBtdXRlZCBzdGF0ZSBidXQgbm90IHZvbHVtZSwgMTAwJSBpcyBkaWZmZXJlbnQgb24gVFYncyA6UFxuICAgICAgdGhpcy5tdXRlZCA9IHN1cGVyLm11dGVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWQoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgbG9hZCgpIHtcbiAgICAgIGlmICghdGhpcy4jY2FzdFBsYXllcikgcmV0dXJuIHN1cGVyLmxvYWQoKTtcblxuICAgICAgY29uc3QgbWVkaWFJbmZvID0gbmV3IGNocm9tZS5jYXN0Lm1lZGlhLk1lZGlhSW5mbyh0aGlzLmNhc3RTcmMsIHRoaXMuY2FzdENvbnRlbnRUeXBlKTtcbiAgICAgIG1lZGlhSW5mby5jdXN0b21EYXRhID0gdGhpcy5jYXN0Q3VzdG9tRGF0YTtcblxuICAgICAgLy8gTWFudWFsbHkgYWRkIHRleHQgdHJhY2tzIHdpdGggYSBgc3JjYCBhdHRyaWJ1dGUuXG4gICAgICAvLyBNM1U4J3MgbG9hZCB0ZXh0IHRyYWNrcyBpbiB0aGUgcmVjZWl2ZXIsIGhhbmRsZSB0aGVzZSBpbiB0aGUgbWVkaWEgbG9hZGVkIGV2ZW50LlxuICAgICAgY29uc3Qgc3VidGl0bGVzID0gWy4uLnRoaXMucXVlcnlTZWxlY3RvckFsbCgndHJhY2snKV0uZmlsdGVyKFxuICAgICAgICAoeyBraW5kLCBzcmMgfSkgPT4gc3JjICYmIChraW5kID09PSAnc3VidGl0bGVzJyB8fCBraW5kID09PSAnY2FwdGlvbnMnKVxuICAgICAgKTtcblxuICAgICAgY29uc3QgYWN0aXZlVHJhY2tJZHMgPSBbXTtcbiAgICAgIGxldCB0ZXh0VHJhY2tJZENvdW50ID0gMDtcblxuICAgICAgaWYgKHN1YnRpdGxlcy5sZW5ndGgpIHtcbiAgICAgICAgbWVkaWFJbmZvLnRyYWNrcyA9IHN1YnRpdGxlcy5tYXAoKHRyYWNrRWwpID0+IHtcbiAgICAgICAgICBjb25zdCB0cmFja0lkID0gKyt0ZXh0VHJhY2tJZENvdW50O1xuICAgICAgICAgIC8vIG9ubHkgYWN0aXZhdGUgMSBzdWJ0aXRsZSB0ZXh0IHRyYWNrLlxuICAgICAgICAgIGlmIChhY3RpdmVUcmFja0lkcy5sZW5ndGggPT09IDAgJiYgdHJhY2tFbC50cmFjay5tb2RlID09PSAnc2hvd2luZycpIHtcbiAgICAgICAgICAgIGFjdGl2ZVRyYWNrSWRzLnB1c2godHJhY2tJZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgdHJhY2sgPSBuZXcgY2hyb21lLmNhc3QubWVkaWEuVHJhY2soXG4gICAgICAgICAgICB0cmFja0lkLFxuICAgICAgICAgICAgY2hyb21lLmNhc3QubWVkaWEuVHJhY2tUeXBlLlRFWFRcbiAgICAgICAgICApO1xuICAgICAgICAgIHRyYWNrLnRyYWNrQ29udGVudElkID0gdHJhY2tFbC5zcmM7XG4gICAgICAgICAgdHJhY2sudHJhY2tDb250ZW50VHlwZSA9ICd0ZXh0L3Z0dCc7XG4gICAgICAgICAgdHJhY2suc3VidHlwZSA9XG4gICAgICAgICAgICB0cmFja0VsLmtpbmQgPT09ICdjYXB0aW9ucydcbiAgICAgICAgICAgICAgPyBjaHJvbWUuY2FzdC5tZWRpYS5UZXh0VHJhY2tUeXBlLkNBUFRJT05TXG4gICAgICAgICAgICAgIDogY2hyb21lLmNhc3QubWVkaWEuVGV4dFRyYWNrVHlwZS5TVUJUSVRMRVM7XG4gICAgICAgICAgdHJhY2submFtZSA9IHRyYWNrRWwubGFiZWw7XG4gICAgICAgICAgdHJhY2subGFuZ3VhZ2UgPSB0cmFja0VsLnNyY2xhbmc7XG4gICAgICAgICAgcmV0dXJuIHRyYWNrO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY2FzdFN0cmVhbVR5cGUgPT09ICdsaXZlJykge1xuICAgICAgICBtZWRpYUluZm8uc3RyZWFtVHlwZSA9IGNocm9tZS5jYXN0Lm1lZGlhLlN0cmVhbVR5cGUuTElWRTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lZGlhSW5mby5zdHJlYW1UeXBlID0gY2hyb21lLmNhc3QubWVkaWEuU3RyZWFtVHlwZS5CVUZGRVJFRDtcbiAgICAgIH1cblxuICAgICAgbWVkaWFJbmZvLm1ldGFkYXRhID0gbmV3IGNocm9tZS5jYXN0Lm1lZGlhLkdlbmVyaWNNZWRpYU1ldGFkYXRhKCk7XG4gICAgICBtZWRpYUluZm8ubWV0YWRhdGEudGl0bGUgPSB0aGlzLnRpdGxlO1xuICAgICAgbWVkaWFJbmZvLm1ldGFkYXRhLmltYWdlcyA9IFt7IHVybDogdGhpcy5wb3N0ZXIgfV07XG5cbiAgICAgIGlmIChpc0hscyh0aGlzLmNhc3RTcmMpKSB7XG4gICAgICAgIGNvbnN0IHNlZ21lbnRGb3JtYXQgPSBhd2FpdCBnZXRQbGF5bGlzdFNlZ21lbnRGb3JtYXQodGhpcy5jYXN0U3JjKTtcbiAgICAgICAgY29uc3QgaXNGcmFnbWVudGVkTVA0ID0gc2VnbWVudEZvcm1hdD8uaW5jbHVkZXMoJ200cycpIHx8IHNlZ21lbnRGb3JtYXQ/LmluY2x1ZGVzKCdtcDQnKTtcbiAgICAgICAgaWYgKGlzRnJhZ21lbnRlZE1QNCkge1xuICAgICAgICAgIG1lZGlhSW5mby5obHNTZWdtZW50Rm9ybWF0ID0gY2hyb21lLmNhc3QubWVkaWEuSGxzU2VnbWVudEZvcm1hdC5GTVA0O1xuICAgICAgICAgIG1lZGlhSW5mby5obHNWaWRlb1NlZ21lbnRGb3JtYXQgPSBjaHJvbWUuY2FzdC5tZWRpYS5IbHNWaWRlb1NlZ21lbnRGb3JtYXQuRk1QNDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IGNocm9tZS5jYXN0Lm1lZGlhLkxvYWRSZXF1ZXN0KG1lZGlhSW5mbyk7XG4gICAgICByZXF1ZXN0LmN1cnJlbnRUaW1lID0gc3VwZXIuY3VycmVudFRpbWUgPz8gMDtcbiAgICAgIHJlcXVlc3QuYXV0b3BsYXkgPSAhdGhpcy4jbG9jYWxTdGF0ZS5wYXVzZWQ7XG4gICAgICByZXF1ZXN0LmFjdGl2ZVRyYWNrSWRzID0gYWN0aXZlVHJhY2tJZHM7XG5cbiAgICAgIGF3YWl0IGN1cnJlbnRTZXNzaW9uKCk/LmxvYWRNZWRpYShyZXF1ZXN0KTtcblxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgndm9sdW1lY2hhbmdlJykpO1xuICAgIH1cblxuICAgIHBsYXkoKSB7XG4gICAgICBpZiAodGhpcy4jY2FzdFBsYXllcikge1xuICAgICAgICBpZiAodGhpcy4jY2FzdFBsYXllci5pc1BhdXNlZCkge1xuICAgICAgICAgIHRoaXMuI2Nhc3RQbGF5ZXIuY29udHJvbGxlcj8ucGxheU9yUGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gc3VwZXIucGxheSgpO1xuICAgIH1cblxuICAgIHBhdXNlKCkge1xuICAgICAgaWYgKHRoaXMuI2Nhc3RQbGF5ZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLiNjYXN0UGxheWVyLmlzUGF1c2VkKSB7XG4gICAgICAgICAgdGhpcy4jY2FzdFBsYXllci5jb250cm9sbGVyPy5wbGF5T3JQYXVzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN1cGVyLnBhdXNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9jYXN0L2RvY3MvcmVmZXJlbmNlL3dlYl9zZW5kZXIvY2FzdC5mcmFtZXdvcmsuQ2FzdE9wdGlvbnNcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IENhc3RPcHRpb25zXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtyZWNlaXZlckFwcGxpY2F0aW9uSWQ9J0NDMUFEODQ1J10gLSBUaGUgYXBwIGlkIG9mIHRoZSBjYXN0IHJlY2VpdmVyLlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYXV0b0pvaW5Qb2xpY3k9J29yaWdpbl9zY29wZWQnXSAtIFRoZSBhdXRvIGpvaW4gcG9saWN5LlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2VuLVVTJ10gLSBUaGUgbGFuZ3VhZ2UgdG8gdXNlIGZvciB0aGUgY2FzdCByZWNlaXZlci5cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFthbmRyb2lkUmVjZWl2ZXJDb21wYXRpYmxlPWZhbHNlXSAtIFdoZXRoZXIgdG8gdXNlIHRoZSBDYXN0IENvbm5lY3QuXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcmVzdW1lU2F2ZWRTZXNzaW9uPXRydWVdIC0gV2hldGhlciB0byByZXN1bWUgdGhlIGxhc3Qgc2Vzc2lvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Nhc3RPcHRpb25zfVxuICAgICAqL1xuICAgIGdldCBjYXN0T3B0aW9ucygpIHtcbiAgICAgIHJldHVybiB0aGlzLiNjYXN0T3B0aW9ucztcbiAgICB9XG5cbiAgICBnZXQgY2FzdFJlY2VpdmVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdjYXN0LXJlY2VpdmVyJykgPz8gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHNldCBjYXN0UmVjZWl2ZXIodmFsKSB7XG4gICAgICBpZiAodGhpcy5jYXN0UmVjZWl2ZXIgPT0gdmFsKSByZXR1cm47XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnY2FzdC1yZWNlaXZlcicsIGAke3ZhbH1gKTtcbiAgICB9XG5cbiAgICAvLyBBbGxvdyB0aGUgY2FzdCBzb3VyY2UgdXJsIHRvIGJlIGRpZmZlcmVudCB0aGFuIDx2aWRlbyBzcmM+LCBjb3VsZCBiZSBhIGJsb2IuXG4gICAgZ2V0IGNhc3RTcmMoKSB7XG4gICAgICAvLyBUcnkgdGhlIGZpcnN0IDxzb3VyY2Ugc3JjPiBmb3IgdXNhZ2Ugd2l0aCBldmVuIG1vcmUgbmF0aXZlIG1hcmt1cC5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKCdjYXN0LXNyYycpID8/XG4gICAgICAgIHRoaXMucXVlcnlTZWxlY3Rvcignc291cmNlJyk/LnNyYyA/P1xuICAgICAgICB0aGlzLmN1cnJlbnRTcmNcbiAgICAgICk7XG4gICAgfVxuXG4gICAgc2V0IGNhc3RTcmModmFsKSB7XG4gICAgICBpZiAodGhpcy5jYXN0U3JjID09IHZhbCkgcmV0dXJuO1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2Nhc3Qtc3JjJywgYCR7dmFsfWApO1xuICAgIH1cblxuICAgIGdldCBjYXN0Q29udGVudFR5cGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2Nhc3QtY29udGVudC10eXBlJykgPz8gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHNldCBjYXN0Q29udGVudFR5cGUodmFsKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnY2FzdC1jb250ZW50LXR5cGUnLCBgJHt2YWx9YCk7XG4gICAgfVxuXG4gICAgZ2V0IGNhc3RTdHJlYW1UeXBlKCkge1xuICAgICAgLy8gTk9URTogUGVyIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvbWVkaWEtdWktZXh0ZW5zaW9ucy9pc3N1ZXMvMyBgc3RyZWFtVHlwZWAgbWF5IHlpZWxkIGBcInVua25vd25cImBcbiAgICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnY2FzdC1zdHJlYW0tdHlwZScpID8/IHRoaXMuc3RyZWFtVHlwZSA/PyB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgc2V0IGNhc3RTdHJlYW1UeXBlKHZhbCkge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2Nhc3Qtc3RyZWFtLXR5cGUnLCBgJHt2YWx9YCk7XG4gICAgfVxuXG4gICAgZ2V0IGNhc3RDdXN0b21EYXRhKCkge1xuICAgICAgcmV0dXJuIHRoaXMuI2Nhc3RDdXN0b21EYXRhO1xuICAgIH1cblxuICAgIHNldCBjYXN0Q3VzdG9tRGF0YSh2YWwpIHtcbiAgICAgIGNvbnN0IHZhbFR5cGUgPSB0eXBlb2YgdmFsO1xuICAgICAgaWYgKCFbJ29iamVjdCcsICd1bmRlZmluZWQnXS5pbmNsdWRlcyh2YWxUeXBlKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBjYXN0Q3VzdG9tRGF0YSBtdXN0IGJlIG51bGxpc2ggb3IgYW4gb2JqZWN0IGJ1dCB2YWx1ZSB3YXMgb2YgdHlwZSAke3ZhbFR5cGV9YCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy4jY2FzdEN1c3RvbURhdGEgPSB2YWw7XG4gICAgfVxuXG4gICAgZ2V0IHJlYWR5U3RhdGUoKSB7XG4gICAgICBpZiAodGhpcy4jY2FzdFBsYXllcikge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuI2Nhc3RQbGF5ZXIucGxheWVyU3RhdGUpIHtcbiAgICAgICAgICBjYXNlIGNocm9tZS5jYXN0Lm1lZGlhLlBsYXllclN0YXRlLklETEU6XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICBjYXNlIGNocm9tZS5jYXN0Lm1lZGlhLlBsYXllclN0YXRlLkJVRkZFUklORzpcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gMztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN1cGVyLnJlYWR5U3RhdGU7XG4gICAgfVxuXG4gICAgZ2V0IHBhdXNlZCgpIHtcbiAgICAgIGlmICh0aGlzLiNjYXN0UGxheWVyKSByZXR1cm4gdGhpcy4jY2FzdFBsYXllci5pc1BhdXNlZDtcbiAgICAgIHJldHVybiBzdXBlci5wYXVzZWQ7XG4gICAgfVxuXG4gICAgZ2V0IG11dGVkKCkge1xuICAgICAgaWYgKHRoaXMuI2Nhc3RQbGF5ZXIpIHJldHVybiB0aGlzLiNjYXN0UGxheWVyPy5pc011dGVkO1xuICAgICAgcmV0dXJuIHN1cGVyLm11dGVkO1xuICAgIH1cblxuICAgIHNldCBtdXRlZCh2YWwpIHtcbiAgICAgIGlmICh0aGlzLiNjYXN0UGxheWVyKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAodmFsICYmICF0aGlzLiNjYXN0UGxheWVyLmlzTXV0ZWQpIHx8XG4gICAgICAgICAgKCF2YWwgJiYgdGhpcy4jY2FzdFBsYXllci5pc011dGVkKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLiNjYXN0UGxheWVyLmNvbnRyb2xsZXI/Lm11dGVPclVubXV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN1cGVyLm11dGVkID0gdmFsO1xuICAgIH1cblxuICAgIGdldCB2b2x1bWUoKSB7XG4gICAgICBpZiAodGhpcy4jY2FzdFBsYXllcikgcmV0dXJuIHRoaXMuI2Nhc3RQbGF5ZXI/LnZvbHVtZUxldmVsID8/IDE7XG4gICAgICByZXR1cm4gc3VwZXIudm9sdW1lO1xuICAgIH1cblxuICAgIHNldCB2b2x1bWUodmFsKSB7XG4gICAgICBpZiAodGhpcy4jY2FzdFBsYXllcikge1xuICAgICAgICB0aGlzLiNjYXN0UGxheWVyLnZvbHVtZUxldmVsID0gK3ZhbDtcbiAgICAgICAgdGhpcy4jY2FzdFBsYXllci5jb250cm9sbGVyPy5zZXRWb2x1bWVMZXZlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzdXBlci52b2x1bWUgPSB2YWw7XG4gICAgfVxuXG4gICAgZ2V0IGR1cmF0aW9uKCkge1xuICAgICAgLy8gY2FzdFBsYXllciBkdXJhdGlvbiByZXR1cm5zIGAwYCB3aGVuIG5vIG1lZGlhIGlzIGxvYWRlZC5cbiAgICAgIGlmICh0aGlzLiNjYXN0UGxheWVyICYmIHRoaXMuI2Nhc3RQbGF5ZXI/LmlzTWVkaWFMb2FkZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2Nhc3RQbGF5ZXI/LmR1cmF0aW9uID8/IE5hTjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdXBlci5kdXJhdGlvbjtcbiAgICB9XG5cbiAgICBnZXQgY3VycmVudFRpbWUoKSB7XG4gICAgICBpZiAodGhpcy4jY2FzdFBsYXllciAmJiB0aGlzLiNjYXN0UGxheWVyPy5pc01lZGlhTG9hZGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNjYXN0UGxheWVyPy5jdXJyZW50VGltZSA/PyAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN1cGVyLmN1cnJlbnRUaW1lO1xuICAgIH1cblxuICAgIHNldCBjdXJyZW50VGltZSh2YWwpIHtcbiAgICAgIGlmICh0aGlzLiNjYXN0UGxheWVyKSB7XG4gICAgICAgIHRoaXMuI2Nhc3RQbGF5ZXIuY3VycmVudFRpbWUgPSB2YWw7XG4gICAgICAgIHRoaXMuI2Nhc3RQbGF5ZXIuY29udHJvbGxlcj8uc2VlaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzdXBlci5jdXJyZW50VGltZSA9IHZhbDtcbiAgICB9XG4gIH07XG5cbmV4cG9ydCBjb25zdCBDYXN0YWJsZVZpZGVvTWl4aW4gPSBDYXN0YWJsZU1lZGlhTWl4aW47XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/castable-video/castable-mixin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/castable-video/castable-remote-playback.js":
/*!*****************************************************************!*\
  !*** ./node_modules/castable-video/castable-remote-playback.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RemotePlayback: () => (/* binding */ RemotePlayback)\n/* harmony export */ });\n/* harmony import */ var _castable_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./castable-utils.js */ \"(ssr)/./node_modules/castable-video/castable-utils.js\");\n/* global chrome, cast */\n\n\nconst remoteInstances = new _castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.IterableWeakSet();\nconst castElementRef = new WeakSet();\n\nlet cf;\n\n(0,_castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.onCastApiAvailable)(() => {\n  if (!globalThis.chrome?.cast?.isAvailable) {\n    // Useful to see in verbose logs if this shows undefined or false.\n    console.debug('chrome.cast.isAvailable', globalThis.chrome?.cast?.isAvailable);\n    return;\n  }\n\n  if (!cf) {\n    cf = cast.framework;\n\n    (0,_castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.castContext)().addEventListener(cf.CastContextEventType.CAST_STATE_CHANGED, (e) => {\n      remoteInstances.forEach((r) => _castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.privateProps.get(r).onCastStateChanged?.(e));\n    });\n\n    (0,_castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.castContext)().addEventListener(cf.CastContextEventType.SESSION_STATE_CHANGED, (e) => {\n      remoteInstances.forEach((r) => _castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.privateProps.get(r).onSessionStateChanged?.(e));\n    });\n\n    remoteInstances.forEach((r) => _castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.privateProps.get(r).init?.());\n  }\n});\n\n\nlet remotePlaybackCallbackIdCount = 0;\n\n/**\n * Remote Playback shim for the Google cast SDK.\n * https://w3c.github.io/remote-playback/\n */\nclass RemotePlayback extends EventTarget {\n  #media;\n  #isInit;\n  #remotePlayer;\n  #remoteListeners;\n  #state = 'disconnected';\n  #available = false;\n  #callbacks = new Set();\n  #callbackIds = new WeakMap();\n\n  constructor(media) {\n    super();\n\n    this.#media = media;\n\n    remoteInstances.add(this);\n    _castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.privateProps.set(this, {\n      init: () => this.#init(),\n      onCastStateChanged: () => this.#onCastStateChanged(),\n      onSessionStateChanged: () => this.#onSessionStateChanged(),\n      getCastPlayer: () => this.#castPlayer,\n    });\n\n    this.#init();\n  }\n\n  get #castPlayer() {\n    if (castElementRef.has(this.#media)) return this.#remotePlayer;\n    return undefined;\n  }\n\n  /**\n   * https://developer.mozilla.org/en-US/docs/Web/API/RemotePlayback/state\n   * @return {'disconnected'|'connecting'|'connected'}\n   */\n  get state() {\n    return this.#state;\n  }\n\n  async watchAvailability(callback) {\n    if (this.#media.disableRemotePlayback) {\n      throw new _castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.InvalidStateError('disableRemotePlayback attribute is present.');\n    }\n\n    this.#callbackIds.set(callback, ++remotePlaybackCallbackIdCount);\n    this.#callbacks.add(callback);\n\n    // https://w3c.github.io/remote-playback/#getting-the-remote-playback-devices-availability-information\n    queueMicrotask(() => callback(this.#hasDevicesAvailable()));\n\n    return remotePlaybackCallbackIdCount;\n  }\n\n  async cancelWatchAvailability(callback) {\n    if (this.#media.disableRemotePlayback) {\n      throw new _castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.InvalidStateError('disableRemotePlayback attribute is present.');\n    }\n\n    if (callback) {\n      this.#callbacks.delete(callback);\n    } else {\n      this.#callbacks.clear();\n    }\n  }\n\n  async prompt() {\n    if (this.#media.disableRemotePlayback) {\n      throw new _castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.InvalidStateError('disableRemotePlayback attribute is present.');\n    }\n\n    if (!globalThis.chrome?.cast?.isAvailable) {\n      throw new _castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.NotSupportedError('The RemotePlayback API is disabled on this platform.');\n    }\n\n    const willDisconnect = castElementRef.has(this.#media);\n    castElementRef.add(this.#media);\n\n    (0,_castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.setCastOptions)(this.#media.castOptions);\n\n    Object.entries(this.#remoteListeners).forEach(([event, listener]) => {\n      this.#remotePlayer.controller.addEventListener(event, listener);\n    });\n\n    try {\n      // Open browser cast menu.\n      await (0,_castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.castContext)().requestSession();\n    } catch (err) {\n      // If there will be no disconnect, reset some state here.\n      if (!willDisconnect) {\n        castElementRef.delete(this.#media);\n      }\n\n      // Don't throw an error if disconnecting or cancelling.\n      if (err === 'cancel') {\n        return;\n      }\n\n      throw new Error(err);\n    }\n\n    _castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.privateProps.get(this.#media)?.loadOnPrompt?.();\n  }\n\n  #disconnect() {\n    if (!castElementRef.has(this.#media)) return;\n\n    Object.entries(this.#remoteListeners).forEach(([event, listener]) => {\n      this.#remotePlayer.controller.removeEventListener(event, listener);\n    });\n\n    castElementRef.delete(this.#media);\n\n    // isMuted is not in savedPlayerState. should we sync this back to local?\n    this.#media.muted = this.#remotePlayer.isMuted;\n    this.#media.currentTime = this.#remotePlayer.savedPlayerState.currentTime;\n    if (this.#remotePlayer.savedPlayerState.isPaused === false) {\n      this.#media.play();\n    }\n  }\n\n  #hasDevicesAvailable() {\n    // Cast state: NO_DEVICES_AVAILABLE, NOT_CONNECTED, CONNECTING, CONNECTED\n    // https://developers.google.com/cast/docs/reference/web_sender/cast.framework#.CastState\n    const castState = (0,_castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.castContext)()?.getCastState();\n    return castState && castState !== 'NO_DEVICES_AVAILABLE';\n  }\n\n  #onCastStateChanged() {\n    // Cast state: NO_DEVICES_AVAILABLE, NOT_CONNECTED, CONNECTING, CONNECTED\n    // https://developers.google.com/cast/docs/reference/web_sender/cast.framework#.CastState\n    const castState = (0,_castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.castContext)().getCastState();\n\n    if (castElementRef.has(this.#media)) {\n      if (castState === 'CONNECTING') {\n        this.#state = 'connecting';\n        this.dispatchEvent(new Event('connecting'));\n      }\n    }\n\n    if (!this.#available && castState?.includes('CONNECT')) {\n      this.#available = true;\n      for (let callback of this.#callbacks) callback(true);\n    }\n    else if (this.#available && (!castState || castState === 'NO_DEVICES_AVAILABLE')) {\n      this.#available = false;\n      for (let callback of this.#callbacks) callback(false);\n    }\n  }\n\n  async #onSessionStateChanged() {\n    // Session states: NO_SESSION, SESSION_STARTING, SESSION_STARTED, SESSION_START_FAILED,\n    //                 SESSION_ENDING, SESSION_ENDED, SESSION_RESUMED\n    // https://developers.google.com/cast/docs/reference/web_sender/cast.framework#.SessionState\n\n    const { SESSION_RESUMED } = cf.SessionState;\n    if ((0,_castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.castContext)().getSessionState() === SESSION_RESUMED) {\n      /**\n       * Figure out if this was the video that started the resumed session.\n       * @TODO make this more specific than just checking against the video src!! (WL)\n       *\n       * If this video element can get the same unique id on each browser refresh\n       * it would be possible to pass this unique id w/ `LoadRequest.customData`\n       * and verify against currentMedia().customData below.\n       */\n      if (this.#media.castSrc === (0,_castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.currentMedia)()?.media.contentId) {\n        castElementRef.add(this.#media);\n\n        Object.entries(this.#remoteListeners).forEach(([event, listener]) => {\n          this.#remotePlayer.controller.addEventListener(event, listener);\n        });\n\n        /**\n         * There is cast framework resume session bug when you refresh the page a few\n         * times the this.#remotePlayer.currentTime will not be in sync with the receiver :(\n         * The below status request syncs it back up.\n         */\n        try {\n          await (0,_castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.getMediaStatus)(new chrome.cast.media.GetStatusRequest());\n        } catch (error) {\n          console.error(error);\n        }\n\n        // Dispatch the play, playing events manually to sync remote playing state.\n        this.#remoteListeners[cf.RemotePlayerEventType.IS_PAUSED_CHANGED]();\n        this.#remoteListeners[cf.RemotePlayerEventType.PLAYER_STATE_CHANGED]();\n      }\n    }\n  }\n\n  #init() {\n    if (!cf || this.#isInit) return;\n    this.#isInit = true;\n\n    (0,_castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.setCastOptions)(this.#media.castOptions);\n\n    /**\n     * @TODO add listeners for addtrack, removetrack (WL)\n     * This only has an impact on <track> with a `src` because these have to be\n     * loaded manually in the load() method. This will require a new load() call\n     * for each added/removed track w/ src.\n     */\n    this.#media.textTracks.addEventListener('change', () => this.#updateRemoteTextTrack());\n\n    this.#onCastStateChanged();\n\n    this.#remotePlayer = new cf.RemotePlayer();\n    new cf.RemotePlayerController(this.#remotePlayer);\n\n    this.#remoteListeners = {\n      [cf.RemotePlayerEventType.IS_CONNECTED_CHANGED]: ({ value }) => {\n        if (value === true) {\n          this.#state = 'connected';\n          this.dispatchEvent(new Event('connect'));\n        } else {\n          this.#disconnect();\n          this.#state = 'disconnected';\n          this.dispatchEvent(new Event('disconnect'));\n        }\n      },\n      [cf.RemotePlayerEventType.DURATION_CHANGED]: () => {\n        this.#media.dispatchEvent(new Event('durationchange'));\n      },\n      [cf.RemotePlayerEventType.VOLUME_LEVEL_CHANGED]: () => {\n        this.#media.dispatchEvent(new Event('volumechange'));\n      },\n      [cf.RemotePlayerEventType.IS_MUTED_CHANGED]: () => {\n        this.#media.dispatchEvent(new Event('volumechange'));\n      },\n      [cf.RemotePlayerEventType.CURRENT_TIME_CHANGED]: () => {\n        if (!this.#castPlayer?.isMediaLoaded) return;\n        this.#media.dispatchEvent(new Event('timeupdate'));\n      },\n      [cf.RemotePlayerEventType.VIDEO_INFO_CHANGED]: () => {\n        this.#media.dispatchEvent(new Event('resize'));\n      },\n      [cf.RemotePlayerEventType.IS_PAUSED_CHANGED]: () => {\n        this.#media.dispatchEvent(new Event(this.paused ? 'pause' : 'play'));\n      },\n      [cf.RemotePlayerEventType.PLAYER_STATE_CHANGED]: () => {\n        // Player states: IDLE, PLAYING, PAUSED, BUFFERING\n        // https://developers.google.com/cast/docs/reference/web_sender/chrome.cast.media#.PlayerState\n\n        // pause event is handled above.\n        if (this.#castPlayer?.playerState === chrome.cast.media.PlayerState.PAUSED) {\n          return;\n        }\n\n        this.#media.dispatchEvent(\n          new Event(\n            {\n              [chrome.cast.media.PlayerState.PLAYING]: 'playing',\n              [chrome.cast.media.PlayerState.BUFFERING]: 'waiting',\n              [chrome.cast.media.PlayerState.IDLE]: 'emptied',\n            }[this.#castPlayer?.playerState]\n          )\n        );\n      },\n      [cf.RemotePlayerEventType.IS_MEDIA_LOADED_CHANGED]: async () => {\n        if (!this.#castPlayer?.isMediaLoaded) return;\n\n        // mediaInfo is not immediately available due to a bug? wait one tick\n        await Promise.resolve();\n        this.#onRemoteMediaLoaded();\n      },\n    };\n  }\n\n  #onRemoteMediaLoaded() {\n    this.#updateRemoteTextTrack();\n  }\n\n  async #updateRemoteTextTrack() {\n    if (!this.#castPlayer) return;\n\n    // Get the tracks w/ trackId's that have been loaded; manually or via a playlist like a M3U8 or MPD.\n    const remoteTracks = this.#remotePlayer.mediaInfo?.tracks ?? [];\n    const remoteSubtitles = remoteTracks.filter(\n      ({ type }) => type === chrome.cast.media.TrackType.TEXT\n    );\n\n    const localSubtitles = [...this.#media.textTracks].filter(\n      ({ kind }) => kind === 'subtitles' || kind === 'captions'\n    );\n\n    // Create a new array from the local subs w/ the trackId's from the remote subs.\n    const subtitles = remoteSubtitles\n      .map(({ language, name, trackId }) => {\n        // Find the corresponding local text track and assign the trackId.\n        const { mode } =\n          localSubtitles.find(\n            (local) => local.language === language && local.label === name\n          ) ?? {};\n        if (mode) return { mode, trackId };\n        return false;\n      })\n      .filter(Boolean);\n\n    const hiddenSubtitles = subtitles.filter(\n      ({ mode }) => mode !== 'showing'\n    );\n    const hiddenTrackIds = hiddenSubtitles.map(({ trackId }) => trackId);\n    const showingSubtitle = subtitles.find(({ mode }) => mode === 'showing');\n\n    // Note this could also include audio or video tracks, diff against local state.\n    const activeTrackIds =\n      (0,_castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.currentSession)()?.getSessionObj().media[0]\n        ?.activeTrackIds ?? [];\n    let requestTrackIds = activeTrackIds;\n\n    if (activeTrackIds.length) {\n      // Filter out all local hidden subtitle trackId's.\n      requestTrackIds = requestTrackIds.filter(\n        (id) => !hiddenTrackIds.includes(id)\n      );\n    }\n\n    if (showingSubtitle?.trackId) {\n      requestTrackIds = [...requestTrackIds, showingSubtitle.trackId];\n    }\n\n    // Remove duplicate ids.\n    requestTrackIds = [...new Set(requestTrackIds)];\n\n    const arrayEquals = (a, b) =>\n      a.length === b.length && a.every((a) => b.includes(a));\n    if (!arrayEquals(activeTrackIds, requestTrackIds)) {\n      try {\n        const request = new chrome.cast.media.EditTracksInfoRequest(\n          requestTrackIds\n        );\n        await (0,_castable_utils_js__WEBPACK_IMPORTED_MODULE_0__.editTracksInfo)(request);\n      } catch (error) {\n        console.error(error);\n      }\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2FzdGFibGUtdmlkZW8vY2FzdGFibGUtcmVtb3RlLXBsYXliYWNrLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFhNkI7O0FBRTdCLDRCQUE0QiwrREFBZTtBQUMzQzs7QUFFQTs7QUFFQSxzRUFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUksK0RBQVc7QUFDZixxQ0FBcUMsNERBQVk7QUFDakQsS0FBSzs7QUFFTCxJQUFJLCtEQUFXO0FBQ2YscUNBQXFDLDREQUFZO0FBQ2pELEtBQUs7O0FBRUwsbUNBQW1DLDREQUFZO0FBQy9DO0FBQ0EsQ0FBQzs7O0FBR0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLElBQUksNERBQVk7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGlFQUFpQjtBQUNqQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGlFQUFpQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGlFQUFpQjtBQUNqQzs7QUFFQTtBQUNBLGdCQUFnQixpRUFBaUI7QUFDakM7O0FBRUE7QUFDQTs7QUFFQSxJQUFJLGtFQUFjOztBQUVsQjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsWUFBWSwrREFBVztBQUN2QixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJLDREQUFZO0FBQ2hCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLCtEQUFXO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLCtEQUFXOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksa0JBQWtCO0FBQzlCLFFBQVEsK0RBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxnRUFBWTtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0VBQWM7QUFDOUIsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGtFQUFjOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMERBQTBELE9BQU87QUFDakU7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQSxTQUFTLE1BQU07QUFDZjs7QUFFQTtBQUNBLFNBQVMsTUFBTTtBQUNmOztBQUVBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QjtBQUN2QztBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLFNBQVMsTUFBTTtBQUNmO0FBQ0Esa0RBQWtELFNBQVM7QUFDM0QsOENBQThDLE1BQU07O0FBRXBEO0FBQ0E7QUFDQSxNQUFNLGtFQUFjO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrRUFBYztBQUM1QixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL0V0aGFuTGVlL0Rlc2t0b3AvQWR2WC9BSS1XYXRjaC1CdWRkeS9mcm9udGVuZC9ub2RlX21vZHVsZXMvY2FzdGFibGUtdmlkZW8vY2FzdGFibGUtcmVtb3RlLXBsYXliYWNrLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbCBjaHJvbWUsIGNhc3QgKi9cbmltcG9ydCB7XG4gIHByaXZhdGVQcm9wcyxcbiAgSXRlcmFibGVXZWFrU2V0LFxuICBJbnZhbGlkU3RhdGVFcnJvcixcbiAgTm90U3VwcG9ydGVkRXJyb3IsXG4gIG9uQ2FzdEFwaUF2YWlsYWJsZSxcbiAgY2FzdENvbnRleHQsXG4gIGN1cnJlbnRTZXNzaW9uLFxuICBjdXJyZW50TWVkaWEsXG4gIGVkaXRUcmFja3NJbmZvLFxuICBnZXRNZWRpYVN0YXR1cyxcbiAgc2V0Q2FzdE9wdGlvbnNcbn0gZnJvbSAnLi9jYXN0YWJsZS11dGlscy5qcyc7XG5cbmNvbnN0IHJlbW90ZUluc3RhbmNlcyA9IG5ldyBJdGVyYWJsZVdlYWtTZXQoKTtcbmNvbnN0IGNhc3RFbGVtZW50UmVmID0gbmV3IFdlYWtTZXQoKTtcblxubGV0IGNmO1xuXG5vbkNhc3RBcGlBdmFpbGFibGUoKCkgPT4ge1xuICBpZiAoIWdsb2JhbFRoaXMuY2hyb21lPy5jYXN0Py5pc0F2YWlsYWJsZSkge1xuICAgIC8vIFVzZWZ1bCB0byBzZWUgaW4gdmVyYm9zZSBsb2dzIGlmIHRoaXMgc2hvd3MgdW5kZWZpbmVkIG9yIGZhbHNlLlxuICAgIGNvbnNvbGUuZGVidWcoJ2Nocm9tZS5jYXN0LmlzQXZhaWxhYmxlJywgZ2xvYmFsVGhpcy5jaHJvbWU/LmNhc3Q/LmlzQXZhaWxhYmxlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIWNmKSB7XG4gICAgY2YgPSBjYXN0LmZyYW1ld29yaztcblxuICAgIGNhc3RDb250ZXh0KCkuYWRkRXZlbnRMaXN0ZW5lcihjZi5DYXN0Q29udGV4dEV2ZW50VHlwZS5DQVNUX1NUQVRFX0NIQU5HRUQsIChlKSA9PiB7XG4gICAgICByZW1vdGVJbnN0YW5jZXMuZm9yRWFjaCgocikgPT4gcHJpdmF0ZVByb3BzLmdldChyKS5vbkNhc3RTdGF0ZUNoYW5nZWQ/LihlKSk7XG4gICAgfSk7XG5cbiAgICBjYXN0Q29udGV4dCgpLmFkZEV2ZW50TGlzdGVuZXIoY2YuQ2FzdENvbnRleHRFdmVudFR5cGUuU0VTU0lPTl9TVEFURV9DSEFOR0VELCAoZSkgPT4ge1xuICAgICAgcmVtb3RlSW5zdGFuY2VzLmZvckVhY2goKHIpID0+IHByaXZhdGVQcm9wcy5nZXQocikub25TZXNzaW9uU3RhdGVDaGFuZ2VkPy4oZSkpO1xuICAgIH0pO1xuXG4gICAgcmVtb3RlSW5zdGFuY2VzLmZvckVhY2goKHIpID0+IHByaXZhdGVQcm9wcy5nZXQocikuaW5pdD8uKCkpO1xuICB9XG59KTtcblxuXG5sZXQgcmVtb3RlUGxheWJhY2tDYWxsYmFja0lkQ291bnQgPSAwO1xuXG4vKipcbiAqIFJlbW90ZSBQbGF5YmFjayBzaGltIGZvciB0aGUgR29vZ2xlIGNhc3QgU0RLLlxuICogaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3JlbW90ZS1wbGF5YmFjay9cbiAqL1xuZXhwb3J0IGNsYXNzIFJlbW90ZVBsYXliYWNrIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xuICAjbWVkaWE7XG4gICNpc0luaXQ7XG4gICNyZW1vdGVQbGF5ZXI7XG4gICNyZW1vdGVMaXN0ZW5lcnM7XG4gICNzdGF0ZSA9ICdkaXNjb25uZWN0ZWQnO1xuICAjYXZhaWxhYmxlID0gZmFsc2U7XG4gICNjYWxsYmFja3MgPSBuZXcgU2V0KCk7XG4gICNjYWxsYmFja0lkcyA9IG5ldyBXZWFrTWFwKCk7XG5cbiAgY29uc3RydWN0b3IobWVkaWEpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy4jbWVkaWEgPSBtZWRpYTtcblxuICAgIHJlbW90ZUluc3RhbmNlcy5hZGQodGhpcyk7XG4gICAgcHJpdmF0ZVByb3BzLnNldCh0aGlzLCB7XG4gICAgICBpbml0OiAoKSA9PiB0aGlzLiNpbml0KCksXG4gICAgICBvbkNhc3RTdGF0ZUNoYW5nZWQ6ICgpID0+IHRoaXMuI29uQ2FzdFN0YXRlQ2hhbmdlZCgpLFxuICAgICAgb25TZXNzaW9uU3RhdGVDaGFuZ2VkOiAoKSA9PiB0aGlzLiNvblNlc3Npb25TdGF0ZUNoYW5nZWQoKSxcbiAgICAgIGdldENhc3RQbGF5ZXI6ICgpID0+IHRoaXMuI2Nhc3RQbGF5ZXIsXG4gICAgfSk7XG5cbiAgICB0aGlzLiNpbml0KCk7XG4gIH1cblxuICBnZXQgI2Nhc3RQbGF5ZXIoKSB7XG4gICAgaWYgKGNhc3RFbGVtZW50UmVmLmhhcyh0aGlzLiNtZWRpYSkpIHJldHVybiB0aGlzLiNyZW1vdGVQbGF5ZXI7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUmVtb3RlUGxheWJhY2svc3RhdGVcbiAgICogQHJldHVybiB7J2Rpc2Nvbm5lY3RlZCd8J2Nvbm5lY3RpbmcnfCdjb25uZWN0ZWQnfVxuICAgKi9cbiAgZ2V0IHN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLiNzdGF0ZTtcbiAgfVxuXG4gIGFzeW5jIHdhdGNoQXZhaWxhYmlsaXR5KGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuI21lZGlhLmRpc2FibGVSZW1vdGVQbGF5YmFjaykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRTdGF0ZUVycm9yKCdkaXNhYmxlUmVtb3RlUGxheWJhY2sgYXR0cmlidXRlIGlzIHByZXNlbnQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy4jY2FsbGJhY2tJZHMuc2V0KGNhbGxiYWNrLCArK3JlbW90ZVBsYXliYWNrQ2FsbGJhY2tJZENvdW50KTtcbiAgICB0aGlzLiNjYWxsYmFja3MuYWRkKGNhbGxiYWNrKTtcblxuICAgIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9yZW1vdGUtcGxheWJhY2svI2dldHRpbmctdGhlLXJlbW90ZS1wbGF5YmFjay1kZXZpY2VzLWF2YWlsYWJpbGl0eS1pbmZvcm1hdGlvblxuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGNhbGxiYWNrKHRoaXMuI2hhc0RldmljZXNBdmFpbGFibGUoKSkpO1xuXG4gICAgcmV0dXJuIHJlbW90ZVBsYXliYWNrQ2FsbGJhY2tJZENvdW50O1xuICB9XG5cbiAgYXN5bmMgY2FuY2VsV2F0Y2hBdmFpbGFiaWxpdHkoY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy4jbWVkaWEuZGlzYWJsZVJlbW90ZVBsYXliYWNrKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFN0YXRlRXJyb3IoJ2Rpc2FibGVSZW1vdGVQbGF5YmFjayBhdHRyaWJ1dGUgaXMgcHJlc2VudC4nKTtcbiAgICB9XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuI2NhbGxiYWNrcy5kZWxldGUoY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNjYWxsYmFja3MuY2xlYXIoKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBwcm9tcHQoKSB7XG4gICAgaWYgKHRoaXMuI21lZGlhLmRpc2FibGVSZW1vdGVQbGF5YmFjaykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRTdGF0ZUVycm9yKCdkaXNhYmxlUmVtb3RlUGxheWJhY2sgYXR0cmlidXRlIGlzIHByZXNlbnQuJyk7XG4gICAgfVxuXG4gICAgaWYgKCFnbG9iYWxUaGlzLmNocm9tZT8uY2FzdD8uaXNBdmFpbGFibGUpIHtcbiAgICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWRFcnJvcignVGhlIFJlbW90ZVBsYXliYWNrIEFQSSBpcyBkaXNhYmxlZCBvbiB0aGlzIHBsYXRmb3JtLicpO1xuICAgIH1cblxuICAgIGNvbnN0IHdpbGxEaXNjb25uZWN0ID0gY2FzdEVsZW1lbnRSZWYuaGFzKHRoaXMuI21lZGlhKTtcbiAgICBjYXN0RWxlbWVudFJlZi5hZGQodGhpcy4jbWVkaWEpO1xuXG4gICAgc2V0Q2FzdE9wdGlvbnModGhpcy4jbWVkaWEuY2FzdE9wdGlvbnMpO1xuXG4gICAgT2JqZWN0LmVudHJpZXModGhpcy4jcmVtb3RlTGlzdGVuZXJzKS5mb3JFYWNoKChbZXZlbnQsIGxpc3RlbmVyXSkgPT4ge1xuICAgICAgdGhpcy4jcmVtb3RlUGxheWVyLmNvbnRyb2xsZXIuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpO1xuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIE9wZW4gYnJvd3NlciBjYXN0IG1lbnUuXG4gICAgICBhd2FpdCBjYXN0Q29udGV4dCgpLnJlcXVlc3RTZXNzaW9uKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBJZiB0aGVyZSB3aWxsIGJlIG5vIGRpc2Nvbm5lY3QsIHJlc2V0IHNvbWUgc3RhdGUgaGVyZS5cbiAgICAgIGlmICghd2lsbERpc2Nvbm5lY3QpIHtcbiAgICAgICAgY2FzdEVsZW1lbnRSZWYuZGVsZXRlKHRoaXMuI21lZGlhKTtcbiAgICAgIH1cblxuICAgICAgLy8gRG9uJ3QgdGhyb3cgYW4gZXJyb3IgaWYgZGlzY29ubmVjdGluZyBvciBjYW5jZWxsaW5nLlxuICAgICAgaWYgKGVyciA9PT0gJ2NhbmNlbCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyKTtcbiAgICB9XG5cbiAgICBwcml2YXRlUHJvcHMuZ2V0KHRoaXMuI21lZGlhKT8ubG9hZE9uUHJvbXB0Py4oKTtcbiAgfVxuXG4gICNkaXNjb25uZWN0KCkge1xuICAgIGlmICghY2FzdEVsZW1lbnRSZWYuaGFzKHRoaXMuI21lZGlhKSkgcmV0dXJuO1xuXG4gICAgT2JqZWN0LmVudHJpZXModGhpcy4jcmVtb3RlTGlzdGVuZXJzKS5mb3JFYWNoKChbZXZlbnQsIGxpc3RlbmVyXSkgPT4ge1xuICAgICAgdGhpcy4jcmVtb3RlUGxheWVyLmNvbnRyb2xsZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpO1xuICAgIH0pO1xuXG4gICAgY2FzdEVsZW1lbnRSZWYuZGVsZXRlKHRoaXMuI21lZGlhKTtcblxuICAgIC8vIGlzTXV0ZWQgaXMgbm90IGluIHNhdmVkUGxheWVyU3RhdGUuIHNob3VsZCB3ZSBzeW5jIHRoaXMgYmFjayB0byBsb2NhbD9cbiAgICB0aGlzLiNtZWRpYS5tdXRlZCA9IHRoaXMuI3JlbW90ZVBsYXllci5pc011dGVkO1xuICAgIHRoaXMuI21lZGlhLmN1cnJlbnRUaW1lID0gdGhpcy4jcmVtb3RlUGxheWVyLnNhdmVkUGxheWVyU3RhdGUuY3VycmVudFRpbWU7XG4gICAgaWYgKHRoaXMuI3JlbW90ZVBsYXllci5zYXZlZFBsYXllclN0YXRlLmlzUGF1c2VkID09PSBmYWxzZSkge1xuICAgICAgdGhpcy4jbWVkaWEucGxheSgpO1xuICAgIH1cbiAgfVxuXG4gICNoYXNEZXZpY2VzQXZhaWxhYmxlKCkge1xuICAgIC8vIENhc3Qgc3RhdGU6IE5PX0RFVklDRVNfQVZBSUxBQkxFLCBOT1RfQ09OTkVDVEVELCBDT05ORUNUSU5HLCBDT05ORUNURURcbiAgICAvLyBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9jYXN0L2RvY3MvcmVmZXJlbmNlL3dlYl9zZW5kZXIvY2FzdC5mcmFtZXdvcmsjLkNhc3RTdGF0ZVxuICAgIGNvbnN0IGNhc3RTdGF0ZSA9IGNhc3RDb250ZXh0KCk/LmdldENhc3RTdGF0ZSgpO1xuICAgIHJldHVybiBjYXN0U3RhdGUgJiYgY2FzdFN0YXRlICE9PSAnTk9fREVWSUNFU19BVkFJTEFCTEUnO1xuICB9XG5cbiAgI29uQ2FzdFN0YXRlQ2hhbmdlZCgpIHtcbiAgICAvLyBDYXN0IHN0YXRlOiBOT19ERVZJQ0VTX0FWQUlMQUJMRSwgTk9UX0NPTk5FQ1RFRCwgQ09OTkVDVElORywgQ09OTkVDVEVEXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vY2FzdC9kb2NzL3JlZmVyZW5jZS93ZWJfc2VuZGVyL2Nhc3QuZnJhbWV3b3JrIy5DYXN0U3RhdGVcbiAgICBjb25zdCBjYXN0U3RhdGUgPSBjYXN0Q29udGV4dCgpLmdldENhc3RTdGF0ZSgpO1xuXG4gICAgaWYgKGNhc3RFbGVtZW50UmVmLmhhcyh0aGlzLiNtZWRpYSkpIHtcbiAgICAgIGlmIChjYXN0U3RhdGUgPT09ICdDT05ORUNUSU5HJykge1xuICAgICAgICB0aGlzLiNzdGF0ZSA9ICdjb25uZWN0aW5nJztcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY29ubmVjdGluZycpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuI2F2YWlsYWJsZSAmJiBjYXN0U3RhdGU/LmluY2x1ZGVzKCdDT05ORUNUJykpIHtcbiAgICAgIHRoaXMuI2F2YWlsYWJsZSA9IHRydWU7XG4gICAgICBmb3IgKGxldCBjYWxsYmFjayBvZiB0aGlzLiNjYWxsYmFja3MpIGNhbGxiYWNrKHRydWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLiNhdmFpbGFibGUgJiYgKCFjYXN0U3RhdGUgfHwgY2FzdFN0YXRlID09PSAnTk9fREVWSUNFU19BVkFJTEFCTEUnKSkge1xuICAgICAgdGhpcy4jYXZhaWxhYmxlID0gZmFsc2U7XG4gICAgICBmb3IgKGxldCBjYWxsYmFjayBvZiB0aGlzLiNjYWxsYmFja3MpIGNhbGxiYWNrKGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyAjb25TZXNzaW9uU3RhdGVDaGFuZ2VkKCkge1xuICAgIC8vIFNlc3Npb24gc3RhdGVzOiBOT19TRVNTSU9OLCBTRVNTSU9OX1NUQVJUSU5HLCBTRVNTSU9OX1NUQVJURUQsIFNFU1NJT05fU1RBUlRfRkFJTEVELFxuICAgIC8vICAgICAgICAgICAgICAgICBTRVNTSU9OX0VORElORywgU0VTU0lPTl9FTkRFRCwgU0VTU0lPTl9SRVNVTUVEXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vY2FzdC9kb2NzL3JlZmVyZW5jZS93ZWJfc2VuZGVyL2Nhc3QuZnJhbWV3b3JrIy5TZXNzaW9uU3RhdGVcblxuICAgIGNvbnN0IHsgU0VTU0lPTl9SRVNVTUVEIH0gPSBjZi5TZXNzaW9uU3RhdGU7XG4gICAgaWYgKGNhc3RDb250ZXh0KCkuZ2V0U2Vzc2lvblN0YXRlKCkgPT09IFNFU1NJT05fUkVTVU1FRCkge1xuICAgICAgLyoqXG4gICAgICAgKiBGaWd1cmUgb3V0IGlmIHRoaXMgd2FzIHRoZSB2aWRlbyB0aGF0IHN0YXJ0ZWQgdGhlIHJlc3VtZWQgc2Vzc2lvbi5cbiAgICAgICAqIEBUT0RPIG1ha2UgdGhpcyBtb3JlIHNwZWNpZmljIHRoYW4ganVzdCBjaGVja2luZyBhZ2FpbnN0IHRoZSB2aWRlbyBzcmMhISAoV0wpXG4gICAgICAgKlxuICAgICAgICogSWYgdGhpcyB2aWRlbyBlbGVtZW50IGNhbiBnZXQgdGhlIHNhbWUgdW5pcXVlIGlkIG9uIGVhY2ggYnJvd3NlciByZWZyZXNoXG4gICAgICAgKiBpdCB3b3VsZCBiZSBwb3NzaWJsZSB0byBwYXNzIHRoaXMgdW5pcXVlIGlkIHcvIGBMb2FkUmVxdWVzdC5jdXN0b21EYXRhYFxuICAgICAgICogYW5kIHZlcmlmeSBhZ2FpbnN0IGN1cnJlbnRNZWRpYSgpLmN1c3RvbURhdGEgYmVsb3cuXG4gICAgICAgKi9cbiAgICAgIGlmICh0aGlzLiNtZWRpYS5jYXN0U3JjID09PSBjdXJyZW50TWVkaWEoKT8ubWVkaWEuY29udGVudElkKSB7XG4gICAgICAgIGNhc3RFbGVtZW50UmVmLmFkZCh0aGlzLiNtZWRpYSk7XG5cbiAgICAgICAgT2JqZWN0LmVudHJpZXModGhpcy4jcmVtb3RlTGlzdGVuZXJzKS5mb3JFYWNoKChbZXZlbnQsIGxpc3RlbmVyXSkgPT4ge1xuICAgICAgICAgIHRoaXMuI3JlbW90ZVBsYXllci5jb250cm9sbGVyLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZXJlIGlzIGNhc3QgZnJhbWV3b3JrIHJlc3VtZSBzZXNzaW9uIGJ1ZyB3aGVuIHlvdSByZWZyZXNoIHRoZSBwYWdlIGEgZmV3XG4gICAgICAgICAqIHRpbWVzIHRoZSB0aGlzLiNyZW1vdGVQbGF5ZXIuY3VycmVudFRpbWUgd2lsbCBub3QgYmUgaW4gc3luYyB3aXRoIHRoZSByZWNlaXZlciA6KFxuICAgICAgICAgKiBUaGUgYmVsb3cgc3RhdHVzIHJlcXVlc3Qgc3luY3MgaXQgYmFjayB1cC5cbiAgICAgICAgICovXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgZ2V0TWVkaWFTdGF0dXMobmV3IGNocm9tZS5jYXN0Lm1lZGlhLkdldFN0YXR1c1JlcXVlc3QoKSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEaXNwYXRjaCB0aGUgcGxheSwgcGxheWluZyBldmVudHMgbWFudWFsbHkgdG8gc3luYyByZW1vdGUgcGxheWluZyBzdGF0ZS5cbiAgICAgICAgdGhpcy4jcmVtb3RlTGlzdGVuZXJzW2NmLlJlbW90ZVBsYXllckV2ZW50VHlwZS5JU19QQVVTRURfQ0hBTkdFRF0oKTtcbiAgICAgICAgdGhpcy4jcmVtb3RlTGlzdGVuZXJzW2NmLlJlbW90ZVBsYXllckV2ZW50VHlwZS5QTEFZRVJfU1RBVEVfQ0hBTkdFRF0oKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAjaW5pdCgpIHtcbiAgICBpZiAoIWNmIHx8IHRoaXMuI2lzSW5pdCkgcmV0dXJuO1xuICAgIHRoaXMuI2lzSW5pdCA9IHRydWU7XG5cbiAgICBzZXRDYXN0T3B0aW9ucyh0aGlzLiNtZWRpYS5jYXN0T3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAVE9ETyBhZGQgbGlzdGVuZXJzIGZvciBhZGR0cmFjaywgcmVtb3ZldHJhY2sgKFdMKVxuICAgICAqIFRoaXMgb25seSBoYXMgYW4gaW1wYWN0IG9uIDx0cmFjaz4gd2l0aCBhIGBzcmNgIGJlY2F1c2UgdGhlc2UgaGF2ZSB0byBiZVxuICAgICAqIGxvYWRlZCBtYW51YWxseSBpbiB0aGUgbG9hZCgpIG1ldGhvZC4gVGhpcyB3aWxsIHJlcXVpcmUgYSBuZXcgbG9hZCgpIGNhbGxcbiAgICAgKiBmb3IgZWFjaCBhZGRlZC9yZW1vdmVkIHRyYWNrIHcvIHNyYy5cbiAgICAgKi9cbiAgICB0aGlzLiNtZWRpYS50ZXh0VHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICgpID0+IHRoaXMuI3VwZGF0ZVJlbW90ZVRleHRUcmFjaygpKTtcblxuICAgIHRoaXMuI29uQ2FzdFN0YXRlQ2hhbmdlZCgpO1xuXG4gICAgdGhpcy4jcmVtb3RlUGxheWVyID0gbmV3IGNmLlJlbW90ZVBsYXllcigpO1xuICAgIG5ldyBjZi5SZW1vdGVQbGF5ZXJDb250cm9sbGVyKHRoaXMuI3JlbW90ZVBsYXllcik7XG5cbiAgICB0aGlzLiNyZW1vdGVMaXN0ZW5lcnMgPSB7XG4gICAgICBbY2YuUmVtb3RlUGxheWVyRXZlbnRUeXBlLklTX0NPTk5FQ1RFRF9DSEFOR0VEXTogKHsgdmFsdWUgfSkgPT4ge1xuICAgICAgICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLiNzdGF0ZSA9ICdjb25uZWN0ZWQnO1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2Nvbm5lY3QnKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy4jZGlzY29ubmVjdCgpO1xuICAgICAgICAgIHRoaXMuI3N0YXRlID0gJ2Rpc2Nvbm5lY3RlZCc7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnZGlzY29ubmVjdCcpKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFtjZi5SZW1vdGVQbGF5ZXJFdmVudFR5cGUuRFVSQVRJT05fQ0hBTkdFRF06ICgpID0+IHtcbiAgICAgICAgdGhpcy4jbWVkaWEuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2R1cmF0aW9uY2hhbmdlJykpO1xuICAgICAgfSxcbiAgICAgIFtjZi5SZW1vdGVQbGF5ZXJFdmVudFR5cGUuVk9MVU1FX0xFVkVMX0NIQU5HRURdOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuI21lZGlhLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCd2b2x1bWVjaGFuZ2UnKSk7XG4gICAgICB9LFxuICAgICAgW2NmLlJlbW90ZVBsYXllckV2ZW50VHlwZS5JU19NVVRFRF9DSEFOR0VEXTogKCkgPT4ge1xuICAgICAgICB0aGlzLiNtZWRpYS5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgndm9sdW1lY2hhbmdlJykpO1xuICAgICAgfSxcbiAgICAgIFtjZi5SZW1vdGVQbGF5ZXJFdmVudFR5cGUuQ1VSUkVOVF9USU1FX0NIQU5HRURdOiAoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy4jY2FzdFBsYXllcj8uaXNNZWRpYUxvYWRlZCkgcmV0dXJuO1xuICAgICAgICB0aGlzLiNtZWRpYS5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgndGltZXVwZGF0ZScpKTtcbiAgICAgIH0sXG4gICAgICBbY2YuUmVtb3RlUGxheWVyRXZlbnRUeXBlLlZJREVPX0lORk9fQ0hBTkdFRF06ICgpID0+IHtcbiAgICAgICAgdGhpcy4jbWVkaWEuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ3Jlc2l6ZScpKTtcbiAgICAgIH0sXG4gICAgICBbY2YuUmVtb3RlUGxheWVyRXZlbnRUeXBlLklTX1BBVVNFRF9DSEFOR0VEXTogKCkgPT4ge1xuICAgICAgICB0aGlzLiNtZWRpYS5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCh0aGlzLnBhdXNlZCA/ICdwYXVzZScgOiAncGxheScpKTtcbiAgICAgIH0sXG4gICAgICBbY2YuUmVtb3RlUGxheWVyRXZlbnRUeXBlLlBMQVlFUl9TVEFURV9DSEFOR0VEXTogKCkgPT4ge1xuICAgICAgICAvLyBQbGF5ZXIgc3RhdGVzOiBJRExFLCBQTEFZSU5HLCBQQVVTRUQsIEJVRkZFUklOR1xuICAgICAgICAvLyBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9jYXN0L2RvY3MvcmVmZXJlbmNlL3dlYl9zZW5kZXIvY2hyb21lLmNhc3QubWVkaWEjLlBsYXllclN0YXRlXG5cbiAgICAgICAgLy8gcGF1c2UgZXZlbnQgaXMgaGFuZGxlZCBhYm92ZS5cbiAgICAgICAgaWYgKHRoaXMuI2Nhc3RQbGF5ZXI/LnBsYXllclN0YXRlID09PSBjaHJvbWUuY2FzdC5tZWRpYS5QbGF5ZXJTdGF0ZS5QQVVTRUQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiNtZWRpYS5kaXNwYXRjaEV2ZW50KFxuICAgICAgICAgIG5ldyBFdmVudChcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgW2Nocm9tZS5jYXN0Lm1lZGlhLlBsYXllclN0YXRlLlBMQVlJTkddOiAncGxheWluZycsXG4gICAgICAgICAgICAgIFtjaHJvbWUuY2FzdC5tZWRpYS5QbGF5ZXJTdGF0ZS5CVUZGRVJJTkddOiAnd2FpdGluZycsXG4gICAgICAgICAgICAgIFtjaHJvbWUuY2FzdC5tZWRpYS5QbGF5ZXJTdGF0ZS5JRExFXTogJ2VtcHRpZWQnLFxuICAgICAgICAgICAgfVt0aGlzLiNjYXN0UGxheWVyPy5wbGF5ZXJTdGF0ZV1cbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgW2NmLlJlbW90ZVBsYXllckV2ZW50VHlwZS5JU19NRURJQV9MT0FERURfQ0hBTkdFRF06IGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLiNjYXN0UGxheWVyPy5pc01lZGlhTG9hZGVkKSByZXR1cm47XG5cbiAgICAgICAgLy8gbWVkaWFJbmZvIGlzIG5vdCBpbW1lZGlhdGVseSBhdmFpbGFibGUgZHVlIHRvIGEgYnVnPyB3YWl0IG9uZSB0aWNrXG4gICAgICAgIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB0aGlzLiNvblJlbW90ZU1lZGlhTG9hZGVkKCk7XG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICAjb25SZW1vdGVNZWRpYUxvYWRlZCgpIHtcbiAgICB0aGlzLiN1cGRhdGVSZW1vdGVUZXh0VHJhY2soKTtcbiAgfVxuXG4gIGFzeW5jICN1cGRhdGVSZW1vdGVUZXh0VHJhY2soKSB7XG4gICAgaWYgKCF0aGlzLiNjYXN0UGxheWVyKSByZXR1cm47XG5cbiAgICAvLyBHZXQgdGhlIHRyYWNrcyB3LyB0cmFja0lkJ3MgdGhhdCBoYXZlIGJlZW4gbG9hZGVkOyBtYW51YWxseSBvciB2aWEgYSBwbGF5bGlzdCBsaWtlIGEgTTNVOCBvciBNUEQuXG4gICAgY29uc3QgcmVtb3RlVHJhY2tzID0gdGhpcy4jcmVtb3RlUGxheWVyLm1lZGlhSW5mbz8udHJhY2tzID8/IFtdO1xuICAgIGNvbnN0IHJlbW90ZVN1YnRpdGxlcyA9IHJlbW90ZVRyYWNrcy5maWx0ZXIoXG4gICAgICAoeyB0eXBlIH0pID0+IHR5cGUgPT09IGNocm9tZS5jYXN0Lm1lZGlhLlRyYWNrVHlwZS5URVhUXG4gICAgKTtcblxuICAgIGNvbnN0IGxvY2FsU3VidGl0bGVzID0gWy4uLnRoaXMuI21lZGlhLnRleHRUcmFja3NdLmZpbHRlcihcbiAgICAgICh7IGtpbmQgfSkgPT4ga2luZCA9PT0gJ3N1YnRpdGxlcycgfHwga2luZCA9PT0gJ2NhcHRpb25zJ1xuICAgICk7XG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgYXJyYXkgZnJvbSB0aGUgbG9jYWwgc3VicyB3LyB0aGUgdHJhY2tJZCdzIGZyb20gdGhlIHJlbW90ZSBzdWJzLlxuICAgIGNvbnN0IHN1YnRpdGxlcyA9IHJlbW90ZVN1YnRpdGxlc1xuICAgICAgLm1hcCgoeyBsYW5ndWFnZSwgbmFtZSwgdHJhY2tJZCB9KSA9PiB7XG4gICAgICAgIC8vIEZpbmQgdGhlIGNvcnJlc3BvbmRpbmcgbG9jYWwgdGV4dCB0cmFjayBhbmQgYXNzaWduIHRoZSB0cmFja0lkLlxuICAgICAgICBjb25zdCB7IG1vZGUgfSA9XG4gICAgICAgICAgbG9jYWxTdWJ0aXRsZXMuZmluZChcbiAgICAgICAgICAgIChsb2NhbCkgPT4gbG9jYWwubGFuZ3VhZ2UgPT09IGxhbmd1YWdlICYmIGxvY2FsLmxhYmVsID09PSBuYW1lXG4gICAgICAgICAgKSA/PyB7fTtcbiAgICAgICAgaWYgKG1vZGUpIHJldHVybiB7IG1vZGUsIHRyYWNrSWQgfTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSlcbiAgICAgIC5maWx0ZXIoQm9vbGVhbik7XG5cbiAgICBjb25zdCBoaWRkZW5TdWJ0aXRsZXMgPSBzdWJ0aXRsZXMuZmlsdGVyKFxuICAgICAgKHsgbW9kZSB9KSA9PiBtb2RlICE9PSAnc2hvd2luZydcbiAgICApO1xuICAgIGNvbnN0IGhpZGRlblRyYWNrSWRzID0gaGlkZGVuU3VidGl0bGVzLm1hcCgoeyB0cmFja0lkIH0pID0+IHRyYWNrSWQpO1xuICAgIGNvbnN0IHNob3dpbmdTdWJ0aXRsZSA9IHN1YnRpdGxlcy5maW5kKCh7IG1vZGUgfSkgPT4gbW9kZSA9PT0gJ3Nob3dpbmcnKTtcblxuICAgIC8vIE5vdGUgdGhpcyBjb3VsZCBhbHNvIGluY2x1ZGUgYXVkaW8gb3IgdmlkZW8gdHJhY2tzLCBkaWZmIGFnYWluc3QgbG9jYWwgc3RhdGUuXG4gICAgY29uc3QgYWN0aXZlVHJhY2tJZHMgPVxuICAgICAgY3VycmVudFNlc3Npb24oKT8uZ2V0U2Vzc2lvbk9iaigpLm1lZGlhWzBdXG4gICAgICAgID8uYWN0aXZlVHJhY2tJZHMgPz8gW107XG4gICAgbGV0IHJlcXVlc3RUcmFja0lkcyA9IGFjdGl2ZVRyYWNrSWRzO1xuXG4gICAgaWYgKGFjdGl2ZVRyYWNrSWRzLmxlbmd0aCkge1xuICAgICAgLy8gRmlsdGVyIG91dCBhbGwgbG9jYWwgaGlkZGVuIHN1YnRpdGxlIHRyYWNrSWQncy5cbiAgICAgIHJlcXVlc3RUcmFja0lkcyA9IHJlcXVlc3RUcmFja0lkcy5maWx0ZXIoXG4gICAgICAgIChpZCkgPT4gIWhpZGRlblRyYWNrSWRzLmluY2x1ZGVzKGlkKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoc2hvd2luZ1N1YnRpdGxlPy50cmFja0lkKSB7XG4gICAgICByZXF1ZXN0VHJhY2tJZHMgPSBbLi4ucmVxdWVzdFRyYWNrSWRzLCBzaG93aW5nU3VidGl0bGUudHJhY2tJZF07XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGR1cGxpY2F0ZSBpZHMuXG4gICAgcmVxdWVzdFRyYWNrSWRzID0gWy4uLm5ldyBTZXQocmVxdWVzdFRyYWNrSWRzKV07XG5cbiAgICBjb25zdCBhcnJheUVxdWFscyA9IChhLCBiKSA9PlxuICAgICAgYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuZXZlcnkoKGEpID0+IGIuaW5jbHVkZXMoYSkpO1xuICAgIGlmICghYXJyYXlFcXVhbHMoYWN0aXZlVHJhY2tJZHMsIHJlcXVlc3RUcmFja0lkcykpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgY2hyb21lLmNhc3QubWVkaWEuRWRpdFRyYWNrc0luZm9SZXF1ZXN0KFxuICAgICAgICAgIHJlcXVlc3RUcmFja0lkc1xuICAgICAgICApO1xuICAgICAgICBhd2FpdCBlZGl0VHJhY2tzSW5mbyhyZXF1ZXN0KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/castable-video/castable-remote-playback.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/castable-video/castable-utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/castable-video/castable-utils.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidStateError: () => (/* binding */ InvalidStateError),\n/* harmony export */   IterableWeakSet: () => (/* binding */ IterableWeakSet),\n/* harmony export */   NotFoundError: () => (/* binding */ NotFoundError),\n/* harmony export */   NotSupportedError: () => (/* binding */ NotSupportedError),\n/* harmony export */   castContext: () => (/* binding */ castContext),\n/* harmony export */   currentMedia: () => (/* binding */ currentMedia),\n/* harmony export */   currentSession: () => (/* binding */ currentSession),\n/* harmony export */   editTracksInfo: () => (/* binding */ editTracksInfo),\n/* harmony export */   getDefaultCastOptions: () => (/* binding */ getDefaultCastOptions),\n/* harmony export */   getMediaStatus: () => (/* binding */ getMediaStatus),\n/* harmony export */   getPlaylistSegmentFormat: () => (/* binding */ getPlaylistSegmentFormat),\n/* harmony export */   isHls: () => (/* binding */ isHls),\n/* harmony export */   loadCastFramework: () => (/* binding */ loadCastFramework),\n/* harmony export */   onCastApiAvailable: () => (/* binding */ onCastApiAvailable),\n/* harmony export */   privateProps: () => (/* binding */ privateProps),\n/* harmony export */   requiresCastFramework: () => (/* binding */ requiresCastFramework),\n/* harmony export */   setCastOptions: () => (/* binding */ setCastOptions)\n/* harmony export */ });\n/* global WeakRef */\n\nconst privateProps = new WeakMap();\n\nclass InvalidStateError extends Error {}\nclass NotSupportedError extends Error {}\nclass NotFoundError extends Error {}\n\nconst HLS_RESPONSE_HEADERS = ['application/x-mpegURL','application/vnd.apple.mpegurl','audio/mpegurl']\n\n// Fallback to a plain Set if WeakRef is not available.\nconst IterableWeakSet = globalThis.WeakRef ?\n  class extends Set {\n    add(el) {\n      super.add(new WeakRef(el));\n    }\n    forEach(fn) {\n      super.forEach((ref) => {\n        const value = ref.deref();\n        if (value) fn(value);\n      });\n    }\n  } : Set;\n\nfunction onCastApiAvailable(callback) {\n  if (!globalThis.chrome?.cast?.isAvailable) {\n    globalThis.__onGCastApiAvailable = () => {\n      // The globalThis.__onGCastApiAvailable callback alone is not reliable for\n      // the added cast.framework. It's loaded in a separate JS file.\n      // https://www.gstatic.com/eureka/clank/101/cast_sender.js\n      // https://www.gstatic.com/cast/sdk/libs/sender/1.0/cast_framework.js\n      customElements\n        .whenDefined('google-cast-button')\n        .then(callback);\n    };\n  } else if (!globalThis.cast?.framework) {\n    customElements\n      .whenDefined('google-cast-button')\n      .then(callback);\n  } else {\n    callback();\n  }\n}\n\nfunction requiresCastFramework() {\n  // todo: exclude for Android>=56 which supports the Remote Playback API natively.\n  return globalThis.chrome;\n}\n\nfunction loadCastFramework() {\n  const sdkUrl = 'https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1';\n  if (globalThis.chrome?.cast || document.querySelector(`script[src=\"${sdkUrl}\"]`)) return;\n\n  const script = document.createElement('script');\n  script.src = sdkUrl;\n  document.head.append(script);\n}\n\nfunction castContext() {\n  return globalThis.cast?.framework?.CastContext.getInstance();\n}\n\nfunction currentSession() {\n  return castContext()?.getCurrentSession();\n}\n\nfunction currentMedia() {\n  return currentSession()?.getSessionObj().media[0];\n}\n\nfunction editTracksInfo(request) {\n  return new Promise((resolve, reject) => {\n    currentMedia().editTracksInfo(request, resolve, reject);\n  });\n}\n\nfunction getMediaStatus(request) {\n  return new Promise((resolve, reject) => {\n    currentMedia().getStatus(request, resolve, reject);\n  });\n}\n\nfunction setCastOptions(options) {\n  return castContext().setOptions({\n    ...getDefaultCastOptions(),\n    ...options,\n  });\n}\n\nfunction getDefaultCastOptions() {\n  return {\n    // Set the receiver application ID to your own (created in the\n    // Google Cast Developer Console), or optionally\n    // use the chrome.cast.media.DEFAULT_MEDIA_RECEIVER_APP_ID\n    receiverApplicationId: 'CC1AD845',\n\n    // Auto join policy can be one of the following three:\n    // ORIGIN_SCOPED - Auto connect from same appId and page origin\n    // TAB_AND_ORIGIN_SCOPED - Auto connect from same appId, page origin, and tab\n    // PAGE_SCOPED - No auto connect\n    autoJoinPolicy: 'origin_scoped',\n\n    // The following flag enables Cast Connect(requires Chrome 87 or higher)\n    // https://developers.googleblog.com/2020/08/introducing-cast-connect-android-tv.html\n    androidReceiverCompatible: false,\n\n    language: 'en-US',\n    resumeSavedSession: true,\n  };\n}\n\n//Get the segment format given the end of the URL (.m4s, .ts, etc)\nfunction getFormat(segment) {\n  if (!segment) return undefined;\n\n  const regex = /\\.([a-zA-Z0-9]+)(?:\\?.*)?$/;\n  const match = segment.match(regex);\n  return match ? match[1] : null;\n}\n\nfunction parsePlaylistUrls(playlistContent) {\n  const lines = playlistContent.split('\\n');\n  const urls = [];\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n\n    // Locate available video playlists and get the next line which is the URI (https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-17#section-4.4.6.2)\n    if (line.startsWith('#EXT-X-STREAM-INF')) {\n      const nextLine = lines[i + 1] ? lines[i + 1].trim() : '';\n      if (nextLine && !nextLine.startsWith('#')) {\n        urls.push(nextLine);\n      }\n    }\n  }\n\n  return urls;\n}\n\nfunction parseSegment(playlistContent){\n  const lines = playlistContent.split('\\n');\n\n  const url = lines.find(line => !line.trim().startsWith('#') && line.trim() !== '');\n\n  return url;\n}\n\nasync function isHls(url) {\n  try {\n    const response = await fetch(url, {method: 'HEAD'});\n    const contentType = response.headers.get('Content-Type');\n\n    return HLS_RESPONSE_HEADERS.some((header) => contentType === header);\n  } catch (err) {\n    console.error('Error while trying to get the Content-Type of the manifest', err);\n    return false;\n  }\n}\n\nasync function getPlaylistSegmentFormat(url) {\n  try {\n    const mainManifestContent = await (await fetch(url)).text();\n    let availableChunksContent = mainManifestContent;\n\n    const playlists = parsePlaylistUrls(mainManifestContent);\n    if (playlists.length > 0) {    \n      const chosenPlaylistUrl = new URL(playlists[0], url).toString();\n      availableChunksContent = await (await fetch(chosenPlaylistUrl)).text();\n    }\n\n    const segment = parseSegment(availableChunksContent);\n    const format = getFormat(segment);\n    return format\n  } catch (err) {\n    console.error('Error while trying to parse the manifest playlist', err);\n    return undefined;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2FzdGFibGUtdmlkZW8vY2FzdGFibGUtdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFFTzs7QUFFQTtBQUNBO0FBQ0E7O0FBRVA7O0FBRUE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxJQUFJOztBQUVHO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0EsdUVBQXVFLE9BQU87O0FBRTlFO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGtCQUFrQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7QUFDQSx1Q0FBdUMsZUFBZTtBQUN0RDs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL0V0aGFuTGVlL0Rlc2t0b3AvQWR2WC9BSS1XYXRjaC1CdWRkeS9mcm9udGVuZC9ub2RlX21vZHVsZXMvY2FzdGFibGUtdmlkZW8vY2FzdGFibGUtdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFsIFdlYWtSZWYgKi9cblxuZXhwb3J0IGNvbnN0IHByaXZhdGVQcm9wcyA9IG5ldyBXZWFrTWFwKCk7XG5cbmV4cG9ydCBjbGFzcyBJbnZhbGlkU3RhdGVFcnJvciBleHRlbmRzIEVycm9yIHt9XG5leHBvcnQgY2xhc3MgTm90U3VwcG9ydGVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuZXhwb3J0IGNsYXNzIE5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuXG5jb25zdCBITFNfUkVTUE9OU0VfSEVBREVSUyA9IFsnYXBwbGljYXRpb24veC1tcGVnVVJMJywnYXBwbGljYXRpb24vdm5kLmFwcGxlLm1wZWd1cmwnLCdhdWRpby9tcGVndXJsJ11cblxuLy8gRmFsbGJhY2sgdG8gYSBwbGFpbiBTZXQgaWYgV2Vha1JlZiBpcyBub3QgYXZhaWxhYmxlLlxuZXhwb3J0IGNvbnN0IEl0ZXJhYmxlV2Vha1NldCA9IGdsb2JhbFRoaXMuV2Vha1JlZiA/XG4gIGNsYXNzIGV4dGVuZHMgU2V0IHtcbiAgICBhZGQoZWwpIHtcbiAgICAgIHN1cGVyLmFkZChuZXcgV2Vha1JlZihlbCkpO1xuICAgIH1cbiAgICBmb3JFYWNoKGZuKSB7XG4gICAgICBzdXBlci5mb3JFYWNoKChyZWYpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSByZWYuZGVyZWYoKTtcbiAgICAgICAgaWYgKHZhbHVlKSBmbih2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0gOiBTZXQ7XG5cbmV4cG9ydCBmdW5jdGlvbiBvbkNhc3RBcGlBdmFpbGFibGUoY2FsbGJhY2spIHtcbiAgaWYgKCFnbG9iYWxUaGlzLmNocm9tZT8uY2FzdD8uaXNBdmFpbGFibGUpIHtcbiAgICBnbG9iYWxUaGlzLl9fb25HQ2FzdEFwaUF2YWlsYWJsZSA9ICgpID0+IHtcbiAgICAgIC8vIFRoZSBnbG9iYWxUaGlzLl9fb25HQ2FzdEFwaUF2YWlsYWJsZSBjYWxsYmFjayBhbG9uZSBpcyBub3QgcmVsaWFibGUgZm9yXG4gICAgICAvLyB0aGUgYWRkZWQgY2FzdC5mcmFtZXdvcmsuIEl0J3MgbG9hZGVkIGluIGEgc2VwYXJhdGUgSlMgZmlsZS5cbiAgICAgIC8vIGh0dHBzOi8vd3d3LmdzdGF0aWMuY29tL2V1cmVrYS9jbGFuay8xMDEvY2FzdF9zZW5kZXIuanNcbiAgICAgIC8vIGh0dHBzOi8vd3d3LmdzdGF0aWMuY29tL2Nhc3Qvc2RrL2xpYnMvc2VuZGVyLzEuMC9jYXN0X2ZyYW1ld29yay5qc1xuICAgICAgY3VzdG9tRWxlbWVudHNcbiAgICAgICAgLndoZW5EZWZpbmVkKCdnb29nbGUtY2FzdC1idXR0b24nKVxuICAgICAgICAudGhlbihjYWxsYmFjayk7XG4gICAgfTtcbiAgfSBlbHNlIGlmICghZ2xvYmFsVGhpcy5jYXN0Py5mcmFtZXdvcmspIHtcbiAgICBjdXN0b21FbGVtZW50c1xuICAgICAgLndoZW5EZWZpbmVkKCdnb29nbGUtY2FzdC1idXR0b24nKVxuICAgICAgLnRoZW4oY2FsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlcXVpcmVzQ2FzdEZyYW1ld29yaygpIHtcbiAgLy8gdG9kbzogZXhjbHVkZSBmb3IgQW5kcm9pZD49NTYgd2hpY2ggc3VwcG9ydHMgdGhlIFJlbW90ZSBQbGF5YmFjayBBUEkgbmF0aXZlbHkuXG4gIHJldHVybiBnbG9iYWxUaGlzLmNocm9tZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRDYXN0RnJhbWV3b3JrKCkge1xuICBjb25zdCBzZGtVcmwgPSAnaHR0cHM6Ly93d3cuZ3N0YXRpYy5jb20vY3YvanMvc2VuZGVyL3YxL2Nhc3Rfc2VuZGVyLmpzP2xvYWRDYXN0RnJhbWV3b3JrPTEnO1xuICBpZiAoZ2xvYmFsVGhpcy5jaHJvbWU/LmNhc3QgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihgc2NyaXB0W3NyYz1cIiR7c2RrVXJsfVwiXWApKSByZXR1cm47XG5cbiAgY29uc3Qgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gIHNjcmlwdC5zcmMgPSBzZGtVcmw7XG4gIGRvY3VtZW50LmhlYWQuYXBwZW5kKHNjcmlwdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYXN0Q29udGV4dCgpIHtcbiAgcmV0dXJuIGdsb2JhbFRoaXMuY2FzdD8uZnJhbWV3b3JrPy5DYXN0Q29udGV4dC5nZXRJbnN0YW5jZSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3VycmVudFNlc3Npb24oKSB7XG4gIHJldHVybiBjYXN0Q29udGV4dCgpPy5nZXRDdXJyZW50U2Vzc2lvbigpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3VycmVudE1lZGlhKCkge1xuICByZXR1cm4gY3VycmVudFNlc3Npb24oKT8uZ2V0U2Vzc2lvbk9iaigpLm1lZGlhWzBdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZWRpdFRyYWNrc0luZm8ocmVxdWVzdCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGN1cnJlbnRNZWRpYSgpLmVkaXRUcmFja3NJbmZvKHJlcXVlc3QsIHJlc29sdmUsIHJlamVjdCk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWVkaWFTdGF0dXMocmVxdWVzdCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGN1cnJlbnRNZWRpYSgpLmdldFN0YXR1cyhyZXF1ZXN0LCByZXNvbHZlLCByZWplY3QpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldENhc3RPcHRpb25zKG9wdGlvbnMpIHtcbiAgcmV0dXJuIGNhc3RDb250ZXh0KCkuc2V0T3B0aW9ucyh7XG4gICAgLi4uZ2V0RGVmYXVsdENhc3RPcHRpb25zKCksXG4gICAgLi4ub3B0aW9ucyxcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0Q2FzdE9wdGlvbnMoKSB7XG4gIHJldHVybiB7XG4gICAgLy8gU2V0IHRoZSByZWNlaXZlciBhcHBsaWNhdGlvbiBJRCB0byB5b3VyIG93biAoY3JlYXRlZCBpbiB0aGVcbiAgICAvLyBHb29nbGUgQ2FzdCBEZXZlbG9wZXIgQ29uc29sZSksIG9yIG9wdGlvbmFsbHlcbiAgICAvLyB1c2UgdGhlIGNocm9tZS5jYXN0Lm1lZGlhLkRFRkFVTFRfTUVESUFfUkVDRUlWRVJfQVBQX0lEXG4gICAgcmVjZWl2ZXJBcHBsaWNhdGlvbklkOiAnQ0MxQUQ4NDUnLFxuXG4gICAgLy8gQXV0byBqb2luIHBvbGljeSBjYW4gYmUgb25lIG9mIHRoZSBmb2xsb3dpbmcgdGhyZWU6XG4gICAgLy8gT1JJR0lOX1NDT1BFRCAtIEF1dG8gY29ubmVjdCBmcm9tIHNhbWUgYXBwSWQgYW5kIHBhZ2Ugb3JpZ2luXG4gICAgLy8gVEFCX0FORF9PUklHSU5fU0NPUEVEIC0gQXV0byBjb25uZWN0IGZyb20gc2FtZSBhcHBJZCwgcGFnZSBvcmlnaW4sIGFuZCB0YWJcbiAgICAvLyBQQUdFX1NDT1BFRCAtIE5vIGF1dG8gY29ubmVjdFxuICAgIGF1dG9Kb2luUG9saWN5OiAnb3JpZ2luX3Njb3BlZCcsXG5cbiAgICAvLyBUaGUgZm9sbG93aW5nIGZsYWcgZW5hYmxlcyBDYXN0IENvbm5lY3QocmVxdWlyZXMgQ2hyb21lIDg3IG9yIGhpZ2hlcilcbiAgICAvLyBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlYmxvZy5jb20vMjAyMC8wOC9pbnRyb2R1Y2luZy1jYXN0LWNvbm5lY3QtYW5kcm9pZC10di5odG1sXG4gICAgYW5kcm9pZFJlY2VpdmVyQ29tcGF0aWJsZTogZmFsc2UsXG5cbiAgICBsYW5ndWFnZTogJ2VuLVVTJyxcbiAgICByZXN1bWVTYXZlZFNlc3Npb246IHRydWUsXG4gIH07XG59XG5cbi8vR2V0IHRoZSBzZWdtZW50IGZvcm1hdCBnaXZlbiB0aGUgZW5kIG9mIHRoZSBVUkwgKC5tNHMsIC50cywgZXRjKVxuZnVuY3Rpb24gZ2V0Rm9ybWF0KHNlZ21lbnQpIHtcbiAgaWYgKCFzZWdtZW50KSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gIGNvbnN0IHJlZ2V4ID0gL1xcLihbYS16QS1aMC05XSspKD86XFw/LiopPyQvO1xuICBjb25zdCBtYXRjaCA9IHNlZ21lbnQubWF0Y2gocmVnZXgpO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIHBhcnNlUGxheWxpc3RVcmxzKHBsYXlsaXN0Q29udGVudCkge1xuICBjb25zdCBsaW5lcyA9IHBsYXlsaXN0Q29udGVudC5zcGxpdCgnXFxuJyk7XG4gIGNvbnN0IHVybHMgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbGluZSA9IGxpbmVzW2ldLnRyaW0oKTtcblxuICAgIC8vIExvY2F0ZSBhdmFpbGFibGUgdmlkZW8gcGxheWxpc3RzIGFuZCBnZXQgdGhlIG5leHQgbGluZSB3aGljaCBpcyB0aGUgVVJJIChodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LXBhbnRvcy1obHMtcmZjODIxNmJpcy0xNyNzZWN0aW9uLTQuNC42LjIpXG4gICAgaWYgKGxpbmUuc3RhcnRzV2l0aCgnI0VYVC1YLVNUUkVBTS1JTkYnKSkge1xuICAgICAgY29uc3QgbmV4dExpbmUgPSBsaW5lc1tpICsgMV0gPyBsaW5lc1tpICsgMV0udHJpbSgpIDogJyc7XG4gICAgICBpZiAobmV4dExpbmUgJiYgIW5leHRMaW5lLnN0YXJ0c1dpdGgoJyMnKSkge1xuICAgICAgICB1cmxzLnB1c2gobmV4dExpbmUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1cmxzO1xufVxuXG5mdW5jdGlvbiBwYXJzZVNlZ21lbnQocGxheWxpc3RDb250ZW50KXtcbiAgY29uc3QgbGluZXMgPSBwbGF5bGlzdENvbnRlbnQuc3BsaXQoJ1xcbicpO1xuXG4gIGNvbnN0IHVybCA9IGxpbmVzLmZpbmQobGluZSA9PiAhbGluZS50cmltKCkuc3RhcnRzV2l0aCgnIycpICYmIGxpbmUudHJpbSgpICE9PSAnJyk7XG5cbiAgcmV0dXJuIHVybDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGlzSGxzKHVybCkge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7bWV0aG9kOiAnSEVBRCd9KTtcbiAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKTtcblxuICAgIHJldHVybiBITFNfUkVTUE9OU0VfSEVBREVSUy5zb21lKChoZWFkZXIpID0+IGNvbnRlbnRUeXBlID09PSBoZWFkZXIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB3aGlsZSB0cnlpbmcgdG8gZ2V0IHRoZSBDb250ZW50LVR5cGUgb2YgdGhlIG1hbmlmZXN0JywgZXJyKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFBsYXlsaXN0U2VnbWVudEZvcm1hdCh1cmwpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBtYWluTWFuaWZlc3RDb250ZW50ID0gYXdhaXQgKGF3YWl0IGZldGNoKHVybCkpLnRleHQoKTtcbiAgICBsZXQgYXZhaWxhYmxlQ2h1bmtzQ29udGVudCA9IG1haW5NYW5pZmVzdENvbnRlbnQ7XG5cbiAgICBjb25zdCBwbGF5bGlzdHMgPSBwYXJzZVBsYXlsaXN0VXJscyhtYWluTWFuaWZlc3RDb250ZW50KTtcbiAgICBpZiAocGxheWxpc3RzLmxlbmd0aCA+IDApIHsgICAgXG4gICAgICBjb25zdCBjaG9zZW5QbGF5bGlzdFVybCA9IG5ldyBVUkwocGxheWxpc3RzWzBdLCB1cmwpLnRvU3RyaW5nKCk7XG4gICAgICBhdmFpbGFibGVDaHVua3NDb250ZW50ID0gYXdhaXQgKGF3YWl0IGZldGNoKGNob3NlblBsYXlsaXN0VXJsKSkudGV4dCgpO1xuICAgIH1cblxuICAgIGNvbnN0IHNlZ21lbnQgPSBwYXJzZVNlZ21lbnQoYXZhaWxhYmxlQ2h1bmtzQ29udGVudCk7XG4gICAgY29uc3QgZm9ybWF0ID0gZ2V0Rm9ybWF0KHNlZ21lbnQpO1xuICAgIHJldHVybiBmb3JtYXRcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3Igd2hpbGUgdHJ5aW5nIHRvIHBhcnNlIHRoZSBtYW5pZmVzdCBwbGF5bGlzdCcsIGVycik7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufSJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/castable-video/castable-utils.js\n");

/***/ })

};
;