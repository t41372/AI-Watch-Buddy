"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/hls.js";
exports.ids = ["vendor-chunks/hls.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/hls.js/dist/hls.mjs":
/*!******************************************!*\
  !*** ./node_modules/hls.js/dist/hls.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbrController: () => (/* binding */ AbrController),\n/* harmony export */   AttrList: () => (/* binding */ AttrList),\n/* harmony export */   AudioStreamController: () => (/* binding */ AudioStreamController),\n/* harmony export */   AudioTrackController: () => (/* binding */ AudioTrackController),\n/* harmony export */   BasePlaylistController: () => (/* binding */ BasePlaylistController),\n/* harmony export */   BaseSegment: () => (/* binding */ BaseSegment),\n/* harmony export */   BaseStreamController: () => (/* binding */ BaseStreamController),\n/* harmony export */   BufferController: () => (/* binding */ BufferController),\n/* harmony export */   CMCDController: () => (/* binding */ CMCDController),\n/* harmony export */   CapLevelController: () => (/* binding */ CapLevelController),\n/* harmony export */   ChunkMetadata: () => (/* binding */ ChunkMetadata),\n/* harmony export */   ContentSteeringController: () => (/* binding */ ContentSteeringController),\n/* harmony export */   Cues: () => (/* binding */ Cues),\n/* harmony export */   DateRange: () => (/* binding */ DateRange),\n/* harmony export */   EMEController: () => (/* binding */ EMEController),\n/* harmony export */   ErrorActionFlags: () => (/* binding */ ErrorActionFlags),\n/* harmony export */   ErrorController: () => (/* binding */ ErrorController),\n/* harmony export */   ErrorDetails: () => (/* binding */ ErrorDetails),\n/* harmony export */   ErrorTypes: () => (/* binding */ ErrorTypes),\n/* harmony export */   Events: () => (/* binding */ Events),\n/* harmony export */   FPSController: () => (/* binding */ FPSController),\n/* harmony export */   FetchLoader: () => (/* binding */ FetchLoader),\n/* harmony export */   Fragment: () => (/* binding */ Fragment),\n/* harmony export */   Hls: () => (/* binding */ Hls),\n/* harmony export */   HlsSkip: () => (/* binding */ HlsSkip),\n/* harmony export */   HlsUrlParameters: () => (/* binding */ HlsUrlParameters),\n/* harmony export */   KeySystemFormats: () => (/* binding */ KeySystemFormats),\n/* harmony export */   KeySystems: () => (/* binding */ KeySystems),\n/* harmony export */   Level: () => (/* binding */ Level),\n/* harmony export */   LevelDetails: () => (/* binding */ LevelDetails),\n/* harmony export */   LevelKey: () => (/* binding */ LevelKey),\n/* harmony export */   LoadStats: () => (/* binding */ LoadStats),\n/* harmony export */   M3U8Parser: () => (/* binding */ M3U8Parser),\n/* harmony export */   MetadataSchema: () => (/* binding */ MetadataSchema),\n/* harmony export */   NetworkErrorAction: () => (/* binding */ NetworkErrorAction),\n/* harmony export */   Part: () => (/* binding */ Part),\n/* harmony export */   PlaylistLevelType: () => (/* binding */ PlaylistLevelType),\n/* harmony export */   SubtitleStreamController: () => (/* binding */ SubtitleStreamController),\n/* harmony export */   SubtitleTrackController: () => (/* binding */ SubtitleTrackController),\n/* harmony export */   TimelineController: () => (/* binding */ TimelineController),\n/* harmony export */   XhrLoader: () => (/* binding */ XhrLoader),\n/* harmony export */   \"default\": () => (/* binding */ Hls),\n/* harmony export */   fetchSupported: () => (/* binding */ fetchSupported),\n/* harmony export */   getMediaSource: () => (/* binding */ getMediaSource),\n/* harmony export */   isMSESupported: () => (/* binding */ isMSESupported),\n/* harmony export */   isSupported: () => (/* binding */ isSupported),\n/* harmony export */   requestMediaKeySystemAccess: () => (/* binding */ requestMediaKeySystemAccess)\n/* harmony export */ });\n// https://caniuse.com/mdn-javascript_builtins_number_isfinite\nconst isFiniteNumber = Number.isFinite || function (value) {\n  return typeof value === 'number' && isFinite(value);\n};\n\n// https://caniuse.com/mdn-javascript_builtins_number_issafeinteger\nconst isSafeInteger = Number.isSafeInteger || function (value) {\n  return typeof value === 'number' && Math.abs(value) <= MAX_SAFE_INTEGER;\n};\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\n\nlet ErrorTypes = /*#__PURE__*/function (ErrorTypes) {\n  // Identifier for a network error (loading error / timeout ...)\n  ErrorTypes[\"NETWORK_ERROR\"] = \"networkError\";\n  // Identifier for a media Error (video/parsing/mediasource error)\n  ErrorTypes[\"MEDIA_ERROR\"] = \"mediaError\";\n  // EME (encrypted media extensions) errors\n  ErrorTypes[\"KEY_SYSTEM_ERROR\"] = \"keySystemError\";\n  // Identifier for a mux Error (demuxing/remuxing)\n  ErrorTypes[\"MUX_ERROR\"] = \"muxError\";\n  // Identifier for all other errors\n  ErrorTypes[\"OTHER_ERROR\"] = \"otherError\";\n  return ErrorTypes;\n}({});\nlet ErrorDetails = /*#__PURE__*/function (ErrorDetails) {\n  ErrorDetails[\"KEY_SYSTEM_NO_KEYS\"] = \"keySystemNoKeys\";\n  ErrorDetails[\"KEY_SYSTEM_NO_ACCESS\"] = \"keySystemNoAccess\";\n  ErrorDetails[\"KEY_SYSTEM_NO_SESSION\"] = \"keySystemNoSession\";\n  ErrorDetails[\"KEY_SYSTEM_NO_CONFIGURED_LICENSE\"] = \"keySystemNoConfiguredLicense\";\n  ErrorDetails[\"KEY_SYSTEM_LICENSE_REQUEST_FAILED\"] = \"keySystemLicenseRequestFailed\";\n  ErrorDetails[\"KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED\"] = \"keySystemServerCertificateRequestFailed\";\n  ErrorDetails[\"KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED\"] = \"keySystemServerCertificateUpdateFailed\";\n  ErrorDetails[\"KEY_SYSTEM_SESSION_UPDATE_FAILED\"] = \"keySystemSessionUpdateFailed\";\n  ErrorDetails[\"KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED\"] = \"keySystemStatusOutputRestricted\";\n  ErrorDetails[\"KEY_SYSTEM_STATUS_INTERNAL_ERROR\"] = \"keySystemStatusInternalError\";\n  ErrorDetails[\"KEY_SYSTEM_DESTROY_MEDIA_KEYS_ERROR\"] = \"keySystemDestroyMediaKeysError\";\n  ErrorDetails[\"KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR\"] = \"keySystemDestroyCloseSessionError\";\n  ErrorDetails[\"KEY_SYSTEM_DESTROY_REMOVE_SESSION_ERROR\"] = \"keySystemDestroyRemoveSessionError\";\n  // Identifier for a manifest load error - data: { url : faulty URL, response : { code: error code, text: error text }}\n  ErrorDetails[\"MANIFEST_LOAD_ERROR\"] = \"manifestLoadError\";\n  // Identifier for a manifest load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}\n  ErrorDetails[\"MANIFEST_LOAD_TIMEOUT\"] = \"manifestLoadTimeOut\";\n  // Identifier for a manifest parsing error - data: { url : faulty URL, reason : error reason}\n  ErrorDetails[\"MANIFEST_PARSING_ERROR\"] = \"manifestParsingError\";\n  // Identifier for a manifest with only incompatible codecs error - data: { url : faulty URL, reason : error reason}\n  ErrorDetails[\"MANIFEST_INCOMPATIBLE_CODECS_ERROR\"] = \"manifestIncompatibleCodecsError\";\n  // Identifier for a level which contains no fragments - data: { url: faulty URL, reason: \"no fragments found in level\", level: index of the bad level }\n  ErrorDetails[\"LEVEL_EMPTY_ERROR\"] = \"levelEmptyError\";\n  // Identifier for a level load error - data: { url : faulty URL, response : { code: error code, text: error text }}\n  ErrorDetails[\"LEVEL_LOAD_ERROR\"] = \"levelLoadError\";\n  // Identifier for a level load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}\n  ErrorDetails[\"LEVEL_LOAD_TIMEOUT\"] = \"levelLoadTimeOut\";\n  // Identifier for a level parse error - data: { url : faulty URL, error: Error, reason: error message }\n  ErrorDetails[\"LEVEL_PARSING_ERROR\"] = \"levelParsingError\";\n  // Identifier for a level switch error - data: { level : faulty level Id, event : error description}\n  ErrorDetails[\"LEVEL_SWITCH_ERROR\"] = \"levelSwitchError\";\n  // Identifier for an audio track load error - data: { url : faulty URL, response : { code: error code, text: error text }}\n  ErrorDetails[\"AUDIO_TRACK_LOAD_ERROR\"] = \"audioTrackLoadError\";\n  // Identifier for an audio track load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}\n  ErrorDetails[\"AUDIO_TRACK_LOAD_TIMEOUT\"] = \"audioTrackLoadTimeOut\";\n  // Identifier for a subtitle track load error - data: { url : faulty URL, response : { code: error code, text: error text }}\n  ErrorDetails[\"SUBTITLE_LOAD_ERROR\"] = \"subtitleTrackLoadError\";\n  // Identifier for a subtitle track load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}\n  ErrorDetails[\"SUBTITLE_TRACK_LOAD_TIMEOUT\"] = \"subtitleTrackLoadTimeOut\";\n  // Identifier for fragment load error - data: { frag : fragment object, response : { code: error code, text: error text }}\n  ErrorDetails[\"FRAG_LOAD_ERROR\"] = \"fragLoadError\";\n  // Identifier for fragment load timeout error - data: { frag : fragment object}\n  ErrorDetails[\"FRAG_LOAD_TIMEOUT\"] = \"fragLoadTimeOut\";\n  // Identifier for a fragment decryption error event - data: {id : demuxer Id,frag: fragment object, reason : parsing error description }\n  ErrorDetails[\"FRAG_DECRYPT_ERROR\"] = \"fragDecryptError\";\n  // Identifier for a fragment parsing error event - data: { id : demuxer Id, reason : parsing error description }\n  // will be renamed DEMUX_PARSING_ERROR and switched to MUX_ERROR in the next major release\n  ErrorDetails[\"FRAG_PARSING_ERROR\"] = \"fragParsingError\";\n  // Identifier for a fragment or part load skipped because of a GAP tag or attribute\n  ErrorDetails[\"FRAG_GAP\"] = \"fragGap\";\n  // Identifier for a remux alloc error event - data: { id : demuxer Id, frag : fragment object, bytes : nb of bytes on which allocation failed , reason : error text }\n  ErrorDetails[\"REMUX_ALLOC_ERROR\"] = \"remuxAllocError\";\n  // Identifier for decrypt key load error - data: { frag : fragment object, response : { code: error code, text: error text }}\n  ErrorDetails[\"KEY_LOAD_ERROR\"] = \"keyLoadError\";\n  // Identifier for decrypt key load timeout error - data: { frag : fragment object}\n  ErrorDetails[\"KEY_LOAD_TIMEOUT\"] = \"keyLoadTimeOut\";\n  // Triggered when an exception occurs while adding a sourceBuffer to MediaSource - data : { error : exception , mimeType : mimeType }\n  ErrorDetails[\"BUFFER_ADD_CODEC_ERROR\"] = \"bufferAddCodecError\";\n  // Triggered when source buffer(s) could not be created using level (manifest CODECS attribute), parsed media, or best guess codec(s) - data: { reason : error reason }\n  ErrorDetails[\"BUFFER_INCOMPATIBLE_CODECS_ERROR\"] = \"bufferIncompatibleCodecsError\";\n  // Identifier for a buffer append error - data: append error description\n  ErrorDetails[\"BUFFER_APPEND_ERROR\"] = \"bufferAppendError\";\n  // Identifier for a buffer appending error event - data: appending error description\n  ErrorDetails[\"BUFFER_APPENDING_ERROR\"] = \"bufferAppendingError\";\n  // Identifier for a buffer stalled error event\n  ErrorDetails[\"BUFFER_STALLED_ERROR\"] = \"bufferStalledError\";\n  // Identifier for a buffer full event\n  ErrorDetails[\"BUFFER_FULL_ERROR\"] = \"bufferFullError\";\n  // Identifier for a buffer seek over hole event\n  ErrorDetails[\"BUFFER_SEEK_OVER_HOLE\"] = \"bufferSeekOverHole\";\n  // Identifier for a buffer nudge on stall (playback is stuck although currentTime is in a buffered area)\n  ErrorDetails[\"BUFFER_NUDGE_ON_STALL\"] = \"bufferNudgeOnStall\";\n  // Identifier for a Interstitial Asset List load error - data: { url: faulty URL, response: { code: error code, text: error text } }\n  ErrorDetails[\"ASSET_LIST_LOAD_ERROR\"] = \"assetListLoadError\";\n  // Identifier for a Interstitial Asset List load timeout - data: { url: faulty URL, response: { code: error code, text: error text } }\n  ErrorDetails[\"ASSET_LIST_LOAD_TIMEOUT\"] = \"assetListLoadTimeout\";\n  // Identifier for a Interstitial Asset List parsing error - data: { url : faulty URL, reason : error reason, response : { code: error code, text: error text }}\n  ErrorDetails[\"ASSET_LIST_PARSING_ERROR\"] = \"assetListParsingError\";\n  // Identifier for a Interstitial Asset List parsing error - data: { url : faulty URL, reason : error reason, response : { code: error code, text: error text }}\n  ErrorDetails[\"INTERSTITIAL_ASSET_ITEM_ERROR\"] = \"interstitialAssetItemError\";\n  // Identifier for an internal exception happening inside hls.js while handling an event\n  ErrorDetails[\"INTERNAL_EXCEPTION\"] = \"internalException\";\n  // Identifier for an internal call to abort a loader\n  ErrorDetails[\"INTERNAL_ABORTED\"] = \"aborted\";\n  // Triggered when attachMedia fails\n  ErrorDetails[\"ATTACH_MEDIA_ERROR\"] = \"attachMediaError\";\n  // Uncategorized error\n  ErrorDetails[\"UNKNOWN\"] = \"unknown\";\n  return ErrorDetails;\n}({});\n\nlet Events = /*#__PURE__*/function (Events) {\n  // Fired before MediaSource is attaching to media element\n  Events[\"MEDIA_ATTACHING\"] = \"hlsMediaAttaching\";\n  // Fired when MediaSource has been successfully attached to media element\n  Events[\"MEDIA_ATTACHED\"] = \"hlsMediaAttached\";\n  // Fired before detaching MediaSource from media element\n  Events[\"MEDIA_DETACHING\"] = \"hlsMediaDetaching\";\n  // Fired when MediaSource has been detached from media element\n  Events[\"MEDIA_DETACHED\"] = \"hlsMediaDetached\";\n  // Fired when HTMLMediaElement dispatches \"ended\" event, or stalls at end of VOD program\n  Events[\"MEDIA_ENDED\"] = \"hlsMediaEnded\";\n  // Fired after playback stall is resolved with playing, seeked, or ended event following BUFFER_STALLED_ERROR\n  Events[\"STALL_RESOLVED\"] = \"hlsStallResolved\";\n  // Fired when the buffer is going to be reset\n  Events[\"BUFFER_RESET\"] = \"hlsBufferReset\";\n  // Fired when we know about the codecs that we need buffers for to push into - data: {tracks : { container, codec, levelCodec, initSegment, metadata }}\n  Events[\"BUFFER_CODECS\"] = \"hlsBufferCodecs\";\n  // fired when sourcebuffers have been created - data: { tracks : tracks }\n  Events[\"BUFFER_CREATED\"] = \"hlsBufferCreated\";\n  // fired when we append a segment to the buffer - data: { segment: segment object }\n  Events[\"BUFFER_APPENDING\"] = \"hlsBufferAppending\";\n  // fired when we are done with appending a media segment to the buffer - data : { parent : segment parent that triggered BUFFER_APPENDING, pending : nb of segments waiting for appending for this segment parent}\n  Events[\"BUFFER_APPENDED\"] = \"hlsBufferAppended\";\n  // fired when the stream is finished and we want to notify the media buffer that there will be no more data - data: { }\n  Events[\"BUFFER_EOS\"] = \"hlsBufferEos\";\n  // fired when all buffers are full to the end of the program, after calling MediaSource.endOfStream() (unless restricted)\n  Events[\"BUFFERED_TO_END\"] = \"hlsBufferedToEnd\";\n  // fired when the media buffer should be flushed - data { startOffset, endOffset }\n  Events[\"BUFFER_FLUSHING\"] = \"hlsBufferFlushing\";\n  // fired when the media buffer has been flushed - data: { }\n  Events[\"BUFFER_FLUSHED\"] = \"hlsBufferFlushed\";\n  // fired to signal that a manifest loading starts - data: { url : manifestURL}\n  Events[\"MANIFEST_LOADING\"] = \"hlsManifestLoading\";\n  // fired after manifest has been loaded - data: { levels : [available quality levels], audioTracks : [ available audio tracks ], url : manifestURL, stats : LoaderStats }\n  Events[\"MANIFEST_LOADED\"] = \"hlsManifestLoaded\";\n  // fired after manifest has been parsed - data: { levels : [available quality levels], firstLevel : index of first quality level appearing in Manifest}\n  Events[\"MANIFEST_PARSED\"] = \"hlsManifestParsed\";\n  // fired when a level switch is requested - data: { level : id of new level }\n  Events[\"LEVEL_SWITCHING\"] = \"hlsLevelSwitching\";\n  // fired when a level switch is effective - data: { level : id of new level }\n  Events[\"LEVEL_SWITCHED\"] = \"hlsLevelSwitched\";\n  // fired when a level playlist loading starts - data: { url : level URL, level : id of level being loaded}\n  Events[\"LEVEL_LOADING\"] = \"hlsLevelLoading\";\n  // fired when a level playlist loading finishes - data: { details : levelDetails object, level : id of loaded level, stats : LoaderStats }\n  Events[\"LEVEL_LOADED\"] = \"hlsLevelLoaded\";\n  // fired when a level's details have been updated based on previous details, after it has been loaded - data: { details : levelDetails object, level : id of updated level }\n  Events[\"LEVEL_UPDATED\"] = \"hlsLevelUpdated\";\n  // fired when a level's PTS information has been updated after parsing a fragment - data: { details : levelDetails object, level : id of updated level, drift: PTS drift observed when parsing last fragment }\n  Events[\"LEVEL_PTS_UPDATED\"] = \"hlsLevelPtsUpdated\";\n  // fired to notify that levels have changed after removing a level - data: { levels : [available quality levels] }\n  Events[\"LEVELS_UPDATED\"] = \"hlsLevelsUpdated\";\n  // fired to notify that audio track lists has been updated - data: { audioTracks : audioTracks }\n  Events[\"AUDIO_TRACKS_UPDATED\"] = \"hlsAudioTracksUpdated\";\n  // fired when an audio track switching is requested - data: { id : audio track id }\n  Events[\"AUDIO_TRACK_SWITCHING\"] = \"hlsAudioTrackSwitching\";\n  // fired when an audio track switch actually occurs - data: { id : audio track id }\n  Events[\"AUDIO_TRACK_SWITCHED\"] = \"hlsAudioTrackSwitched\";\n  // fired when an audio track loading starts - data: { url : audio track URL, id : audio track id }\n  Events[\"AUDIO_TRACK_LOADING\"] = \"hlsAudioTrackLoading\";\n  // fired when an audio track loading finishes - data: { details : levelDetails object, id : audio track id, stats : LoaderStats }\n  Events[\"AUDIO_TRACK_LOADED\"] = \"hlsAudioTrackLoaded\";\n  // fired when an audio tracks's details have been updated based on previous details, after it has been loaded - data: { details : levelDetails object, id : track id }\n  Events[\"AUDIO_TRACK_UPDATED\"] = \"hlsAudioTrackUpdated\";\n  // fired to notify that subtitle track lists has been updated - data: { subtitleTracks : subtitleTracks }\n  Events[\"SUBTITLE_TRACKS_UPDATED\"] = \"hlsSubtitleTracksUpdated\";\n  // fired to notify that subtitle tracks were cleared as a result of stopping the media\n  Events[\"SUBTITLE_TRACKS_CLEARED\"] = \"hlsSubtitleTracksCleared\";\n  // fired when an subtitle track switch occurs - data: { id : subtitle track id }\n  Events[\"SUBTITLE_TRACK_SWITCH\"] = \"hlsSubtitleTrackSwitch\";\n  // fired when a subtitle track loading starts - data: { url : subtitle track URL, id : subtitle track id }\n  Events[\"SUBTITLE_TRACK_LOADING\"] = \"hlsSubtitleTrackLoading\";\n  // fired when a subtitle track loading finishes - data: { details : levelDetails object, id : subtitle track id, stats : LoaderStats }\n  Events[\"SUBTITLE_TRACK_LOADED\"] = \"hlsSubtitleTrackLoaded\";\n  // fired when a subtitle  racks's details have been updated based on previous details, after it has been loaded - data: { details : levelDetails object, id : track id }\n  Events[\"SUBTITLE_TRACK_UPDATED\"] = \"hlsSubtitleTrackUpdated\";\n  // fired when a subtitle fragment has been processed - data: { success : boolean, frag : the processed frag }\n  Events[\"SUBTITLE_FRAG_PROCESSED\"] = \"hlsSubtitleFragProcessed\";\n  // fired when a set of VTTCues to be managed externally has been parsed - data: { type: string, track: string, cues: [ VTTCue ] }\n  Events[\"CUES_PARSED\"] = \"hlsCuesParsed\";\n  // fired when a text track to be managed externally is found - data: { tracks: [ { label: string, kind: string, default: boolean } ] }\n  Events[\"NON_NATIVE_TEXT_TRACKS_FOUND\"] = \"hlsNonNativeTextTracksFound\";\n  // fired when the first timestamp is found - data: { id : demuxer id, initPTS: initPTS, timescale: timescale, frag : fragment object }\n  Events[\"INIT_PTS_FOUND\"] = \"hlsInitPtsFound\";\n  // fired when a fragment loading starts - data: { frag : fragment object }\n  Events[\"FRAG_LOADING\"] = \"hlsFragLoading\";\n  // fired when a fragment loading is progressing - data: { frag : fragment object, { trequest, tfirst, loaded } }\n  // FRAG_LOAD_PROGRESS = 'hlsFragLoadProgress',\n  // Identifier for fragment load aborting for emergency switch down - data: { frag : fragment object }\n  Events[\"FRAG_LOAD_EMERGENCY_ABORTED\"] = \"hlsFragLoadEmergencyAborted\";\n  // fired when a fragment loading is completed - data: { frag : fragment object, payload : fragment payload, stats : LoaderStats }\n  Events[\"FRAG_LOADED\"] = \"hlsFragLoaded\";\n  // fired when a fragment has finished decrypting - data: { id : demuxer id, frag: fragment object, payload : fragment payload, stats : { tstart, tdecrypt } }\n  Events[\"FRAG_DECRYPTED\"] = \"hlsFragDecrypted\";\n  // fired when Init Segment has been extracted from fragment - data: { id : demuxer id, frag: fragment object, moov : moov MP4 box, codecs : codecs found while parsing fragment }\n  Events[\"FRAG_PARSING_INIT_SEGMENT\"] = \"hlsFragParsingInitSegment\";\n  // fired when parsing sei text is completed - data: { id : demuxer id, frag: fragment object, samples : [ sei samples pes ] }\n  Events[\"FRAG_PARSING_USERDATA\"] = \"hlsFragParsingUserdata\";\n  // fired when parsing id3 is completed - data: { id : demuxer id, frag: fragment object, samples : [ id3 samples pes ] }\n  Events[\"FRAG_PARSING_METADATA\"] = \"hlsFragParsingMetadata\";\n  // fired when data have been extracted from fragment - data: { id : demuxer id, frag: fragment object, data1 : moof MP4 box or TS fragments, data2 : mdat MP4 box or null}\n  // FRAG_PARSING_DATA = 'hlsFragParsingData',\n  // fired when fragment parsing is completed - data: { id : demuxer id, frag: fragment object }\n  Events[\"FRAG_PARSED\"] = \"hlsFragParsed\";\n  // fired when fragment remuxed MP4 boxes have all been appended into SourceBuffer - data: { id : demuxer id, frag : fragment object, stats : LoaderStats }\n  Events[\"FRAG_BUFFERED\"] = \"hlsFragBuffered\";\n  // fired when fragment matching with current media position is changing - data : { id : demuxer id, frag : fragment object }\n  Events[\"FRAG_CHANGED\"] = \"hlsFragChanged\";\n  // Identifier for a FPS drop event - data: { currentDropped, currentDecoded, totalDroppedFrames }\n  Events[\"FPS_DROP\"] = \"hlsFpsDrop\";\n  // triggered when FPS drop triggers auto level capping - data: { level, droppedLevel }\n  Events[\"FPS_DROP_LEVEL_CAPPING\"] = \"hlsFpsDropLevelCapping\";\n  // triggered when maxAutoLevel changes - data { autoLevelCapping, levels, maxAutoLevel, minAutoLevel, maxHdcpLevel }\n  Events[\"MAX_AUTO_LEVEL_UPDATED\"] = \"hlsMaxAutoLevelUpdated\";\n  // Identifier for an error event - data: { type : error type, details : error details, fatal : if true, hls.js cannot/will not try to recover, if false, hls.js will try to recover,other error specific data }\n  Events[\"ERROR\"] = \"hlsError\";\n  // fired when hls.js instance starts destroying. Different from MEDIA_DETACHED as one could want to detach and reattach a media to the instance of hls.js to handle mid-rolls for example - data: { }\n  Events[\"DESTROYING\"] = \"hlsDestroying\";\n  // fired when a decrypt key loading starts - data: { frag : fragment object }\n  Events[\"KEY_LOADING\"] = \"hlsKeyLoading\";\n  // fired when a decrypt key loading is completed - data: { frag : fragment object, keyInfo : KeyLoaderInfo }\n  Events[\"KEY_LOADED\"] = \"hlsKeyLoaded\";\n  // deprecated; please use BACK_BUFFER_REACHED - data : { bufferEnd: number }\n  Events[\"LIVE_BACK_BUFFER_REACHED\"] = \"hlsLiveBackBufferReached\";\n  // fired when the back buffer is reached as defined by the backBufferLength config option - data : { bufferEnd: number }\n  Events[\"BACK_BUFFER_REACHED\"] = \"hlsBackBufferReached\";\n  // fired after steering manifest has been loaded - data: { steeringManifest: SteeringManifest object, url: steering manifest URL }\n  Events[\"STEERING_MANIFEST_LOADED\"] = \"hlsSteeringManifestLoaded\";\n  // fired when asset list has begun loading\n  Events[\"ASSET_LIST_LOADING\"] = \"hlsAssetListLoading\";\n  // fired when a valid asset list is loaded\n  Events[\"ASSET_LIST_LOADED\"] = \"hlsAssetListLoaded\";\n  // fired when the list of Interstitial Events and Interstitial Schedule is updated\n  Events[\"INTERSTITIALS_UPDATED\"] = \"hlsInterstitialsUpdated\";\n  // fired when the buffer reaches an Interstitial Schedule boundary (both Primary segments and Interstitial Assets)\n  Events[\"INTERSTITIALS_BUFFERED_TO_BOUNDARY\"] = \"hlsInterstitialsBufferedToBoundary\";\n  // fired when a player instance for an Interstitial Asset has been created\n  Events[\"INTERSTITIAL_ASSET_PLAYER_CREATED\"] = \"hlsInterstitialAssetPlayerCreated\";\n  // Interstitial playback started\n  Events[\"INTERSTITIAL_STARTED\"] = \"hlsInterstitialStarted\";\n  // InterstitialAsset playback started\n  Events[\"INTERSTITIAL_ASSET_STARTED\"] = \"hlsInterstitialAssetStarted\";\n  // InterstitialAsset playback ended\n  Events[\"INTERSTITIAL_ASSET_ENDED\"] = \"hlsInterstitialAssetEnded\";\n  // InterstitialAsset playback errored\n  Events[\"INTERSTITIAL_ASSET_ERROR\"] = \"hlsInterstitialAssetError\";\n  // Interstitial playback ended\n  Events[\"INTERSTITIAL_ENDED\"] = \"hlsInterstitialEnded\";\n  // Interstitial schedule resumed primary playback\n  Events[\"INTERSTITIALS_PRIMARY_RESUMED\"] = \"hlsInterstitialsPrimaryResumed\";\n  // Interstitial players dispatch this event when playout limit is reached\n  Events[\"PLAYOUT_LIMIT_REACHED\"] = \"hlsPlayoutLimitReached\";\n  // Event DateRange cue \"enter\" event dispatched\n  Events[\"EVENT_CUE_ENTER\"] = \"hlsEventCueEnter\";\n  return Events;\n}({});\n\n/**\n * Defines each Event type and payload by Event name. Used in {@link hls.js#HlsEventEmitter} to strongly type the event listener API.\n */\n\nvar PlaylistContextType = {\n  MANIFEST: \"manifest\",\n  LEVEL: \"level\",\n  AUDIO_TRACK: \"audioTrack\",\n  SUBTITLE_TRACK: \"subtitleTrack\"\n};\nvar PlaylistLevelType = {\n  MAIN: \"main\",\n  AUDIO: \"audio\",\n  SUBTITLE: \"subtitle\"\n};\n\n/*\n * compute an Exponential Weighted moving average\n * - https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average\n *  - heavily inspired from shaka-player\n */\n\nclass EWMA {\n  //  About half of the estimated value will be from the last |halfLife| samples by weight.\n  constructor(halfLife, estimate = 0, weight = 0) {\n    this.halfLife = void 0;\n    this.alpha_ = void 0;\n    this.estimate_ = void 0;\n    this.totalWeight_ = void 0;\n    this.halfLife = halfLife;\n    // Larger values of alpha expire historical data more slowly.\n    this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;\n    this.estimate_ = estimate;\n    this.totalWeight_ = weight;\n  }\n  sample(weight, value) {\n    const adjAlpha = Math.pow(this.alpha_, weight);\n    this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;\n    this.totalWeight_ += weight;\n  }\n  getTotalWeight() {\n    return this.totalWeight_;\n  }\n  getEstimate() {\n    if (this.alpha_) {\n      const zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);\n      if (zeroFactor) {\n        return this.estimate_ / zeroFactor;\n      }\n    }\n    return this.estimate_;\n  }\n}\n\n/*\n * EWMA Bandwidth Estimator\n *  - heavily inspired from shaka-player\n * Tracks bandwidth samples and estimates available bandwidth.\n * Based on the minimum of two exponentially-weighted moving averages with\n * different half-lives.\n */\n\nclass EwmaBandWidthEstimator {\n  constructor(slow, fast, defaultEstimate, defaultTTFB = 100) {\n    this.defaultEstimate_ = void 0;\n    this.minWeight_ = void 0;\n    this.minDelayMs_ = void 0;\n    this.slow_ = void 0;\n    this.fast_ = void 0;\n    this.defaultTTFB_ = void 0;\n    this.ttfb_ = void 0;\n    this.defaultEstimate_ = defaultEstimate;\n    this.minWeight_ = 0.001;\n    this.minDelayMs_ = 50;\n    this.slow_ = new EWMA(slow);\n    this.fast_ = new EWMA(fast);\n    this.defaultTTFB_ = defaultTTFB;\n    this.ttfb_ = new EWMA(slow);\n  }\n  update(slow, fast) {\n    const {\n      slow_,\n      fast_,\n      ttfb_\n    } = this;\n    if (slow_.halfLife !== slow) {\n      this.slow_ = new EWMA(slow, slow_.getEstimate(), slow_.getTotalWeight());\n    }\n    if (fast_.halfLife !== fast) {\n      this.fast_ = new EWMA(fast, fast_.getEstimate(), fast_.getTotalWeight());\n    }\n    if (ttfb_.halfLife !== slow) {\n      this.ttfb_ = new EWMA(slow, ttfb_.getEstimate(), ttfb_.getTotalWeight());\n    }\n  }\n  sample(durationMs, numBytes) {\n    durationMs = Math.max(durationMs, this.minDelayMs_);\n    const numBits = 8 * numBytes;\n    // weight is duration in seconds\n    const durationS = durationMs / 1000;\n    // value is bandwidth in bits/s\n    const bandwidthInBps = numBits / durationS;\n    this.fast_.sample(durationS, bandwidthInBps);\n    this.slow_.sample(durationS, bandwidthInBps);\n  }\n  sampleTTFB(ttfb) {\n    // weight is frequency curve applied to TTFB in seconds\n    // (longer times have less weight with expected input under 1 second)\n    const seconds = ttfb / 1000;\n    const weight = Math.sqrt(2) * Math.exp(-Math.pow(seconds, 2) / 2);\n    this.ttfb_.sample(weight, Math.max(ttfb, 5));\n  }\n  canEstimate() {\n    return this.fast_.getTotalWeight() >= this.minWeight_;\n  }\n  getEstimate() {\n    if (this.canEstimate()) {\n      // console.log('slow estimate:'+ Math.round(this.slow_.getEstimate()));\n      // console.log('fast estimate:'+ Math.round(this.fast_.getEstimate()));\n      // Take the minimum of these two estimates.  This should have the effect of\n      // adapting down quickly, but up more slowly.\n      return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());\n    } else {\n      return this.defaultEstimate_;\n    }\n  }\n  getEstimateTTFB() {\n    if (this.ttfb_.getTotalWeight() >= this.minWeight_) {\n      return this.ttfb_.getEstimate();\n    } else {\n      return this.defaultTTFB_;\n    }\n  }\n  get defaultEstimate() {\n    return this.defaultEstimate_;\n  }\n  destroy() {}\n}\n\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: true,\n    configurable: true,\n    writable: true\n  }) : e[r] = t, e;\n}\nfunction _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), true).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r);\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\n\nclass Logger {\n  constructor(label, logger) {\n    this.trace = void 0;\n    this.debug = void 0;\n    this.log = void 0;\n    this.warn = void 0;\n    this.info = void 0;\n    this.error = void 0;\n    const lb = `[${label}]:`;\n    this.trace = noop;\n    this.debug = logger.debug.bind(null, lb);\n    this.log = logger.log.bind(null, lb);\n    this.warn = logger.warn.bind(null, lb);\n    this.info = logger.info.bind(null, lb);\n    this.error = logger.error.bind(null, lb);\n  }\n}\nconst noop = function noop() {};\nconst fakeLogger = {\n  trace: noop,\n  debug: noop,\n  log: noop,\n  warn: noop,\n  info: noop,\n  error: noop\n};\nfunction createLogger() {\n  return _extends({}, fakeLogger);\n}\n\n// let lastCallTime;\n// function formatMsgWithTimeInfo(type, msg) {\n//   const now = Date.now();\n//   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';\n//   lastCallTime = now;\n//   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';\n//   return msg;\n// }\n\nfunction consolePrintFn(type, id) {\n  const func = self.console[type];\n  return func ? func.bind(self.console, `${id ? '[' + id + '] ' : ''}[${type}] >`) : noop;\n}\nfunction getLoggerFn(key, debugConfig, id) {\n  return debugConfig[key] ? debugConfig[key].bind(debugConfig) : consolePrintFn(key, id);\n}\nconst exportedLogger = createLogger();\nfunction enableLogs(debugConfig, context, id) {\n  // check that console is available\n  const newLogger = createLogger();\n  if (typeof console === 'object' && debugConfig === true || typeof debugConfig === 'object') {\n    const keys = [\n    // Remove out from list here to hard-disable a log-level\n    // 'trace',\n    'debug', 'log', 'info', 'warn', 'error'];\n    keys.forEach(key => {\n      newLogger[key] = getLoggerFn(key, debugConfig, id);\n    });\n    // Some browsers don't allow to use bind on console object anyway\n    // fallback to default if needed\n    try {\n      newLogger.log(`Debug logs enabled for \"${context}\" in hls.js version ${\"1.6.7\"}`);\n    } catch (e) {\n      /* log fn threw an exception. All logger methods are no-ops. */\n      return createLogger();\n    }\n    // global exported logger uses the same functions as new logger without `id`\n    keys.forEach(key => {\n      exportedLogger[key] = getLoggerFn(key, debugConfig);\n    });\n  } else {\n    // Reset global exported logger\n    _extends(exportedLogger, newLogger);\n  }\n  return newLogger;\n}\nconst logger = exportedLogger;\n\nfunction getMediaSource(preferManagedMediaSource = true) {\n  if (typeof self === 'undefined') return undefined;\n  const mms = (preferManagedMediaSource || !self.MediaSource) && self.ManagedMediaSource;\n  return mms || self.MediaSource || self.WebKitMediaSource;\n}\nfunction isManagedMediaSource(source) {\n  return typeof self !== 'undefined' && source === self.ManagedMediaSource;\n}\nfunction isCompatibleTrackChange(currentTracks, requiredTracks) {\n  const trackNames = Object.keys(currentTracks);\n  const requiredTrackNames = Object.keys(requiredTracks);\n  const trackCount = trackNames.length;\n  const requiredTrackCount = requiredTrackNames.length;\n  return !trackCount || !requiredTrackCount || trackCount === requiredTrackCount && !trackNames.some(name => requiredTrackNames.indexOf(name) === -1);\n}\n\n// http://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript/22373197\n// http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt\n/* utf.js - UTF-8 <=> UTF-16 convertion\n *\n * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\n * Version: 1.0\n * LastModified: Dec 25 1999\n * This library is free.  You can redistribute it and/or modify it.\n */\n/**\n * Converts a UTF-8 array to a string.\n *\n * @param array - The UTF-8 array to convert\n *\n * @returns The string\n *\n * @group Utils\n *\n * @beta\n */\nfunction utf8ArrayToStr(array, exitOnNull = false) {\n  if (typeof TextDecoder !== 'undefined') {\n    const decoder = new TextDecoder('utf-8');\n    const decoded = decoder.decode(array);\n    if (exitOnNull) {\n      // grab up to the first null\n      const idx = decoded.indexOf('\\0');\n      return idx !== -1 ? decoded.substring(0, idx) : decoded;\n    }\n    // remove any null characters\n    return decoded.replace(/\\0/g, '');\n  }\n  const len = array.length;\n  let c;\n  let char2;\n  let char3;\n  let out = '';\n  let i = 0;\n  while (i < len) {\n    c = array[i++];\n    if (c === 0x00 && exitOnNull) {\n      return out;\n    } else if (c === 0x00 || c === 0x03) {\n      // If the character is 3 (END_OF_TEXT) or 0 (NULL) then skip it\n      continue;\n    }\n    switch (c >> 4) {\n      case 0:\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n        // 0xxxxxxx\n        out += String.fromCharCode(c);\n        break;\n      case 12:\n      case 13:\n        // 110x xxxx   10xx xxxx\n        char2 = array[i++];\n        out += String.fromCharCode((c & 0x1f) << 6 | char2 & 0x3f);\n        break;\n      case 14:\n        // 1110 xxxx  10xx xxxx  10xx xxxx\n        char2 = array[i++];\n        char3 = array[i++];\n        out += String.fromCharCode((c & 0x0f) << 12 | (char2 & 0x3f) << 6 | (char3 & 0x3f) << 0);\n        break;\n    }\n  }\n  return out;\n}\n\n/**\n *  hex dump helper class\n */\n\nconst Hex = {\n  hexDump: function (array) {\n    let str = '';\n    for (let i = 0; i < array.length; i++) {\n      let h = array[i].toString(16);\n      if (h.length < 2) {\n        h = '0' + h;\n      }\n      str += h;\n    }\n    return str;\n  }\n};\nfunction hexToArrayBuffer(str) {\n  return Uint8Array.from(str.replace(/^0x/, '').replace(/([\\da-fA-F]{2}) ?/g, '0x$1 ').replace(/ +$/, '').split(' ')).buffer;\n}\n\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nvar urlToolkit = {exports: {}};\n\nvar hasRequiredUrlToolkit;\n\nfunction requireUrlToolkit () {\n\tif (hasRequiredUrlToolkit) return urlToolkit.exports;\n\thasRequiredUrlToolkit = 1;\n\t(function (module, exports) {\n\t\t// see https://tools.ietf.org/html/rfc1808\n\n\t\t(function (root) {\n\t\t  var URL_REGEX =\n\t\t    /^(?=((?:[a-zA-Z0-9+\\-.]+:)?))\\1(?=((?:\\/\\/[^\\/?#]*)?))\\2(?=((?:(?:[^?#\\/]*\\/)*[^;?#\\/]*)?))\\3((?:;[^?#]*)?)(\\?[^#]*)?(#[^]*)?$/;\n\t\t  var FIRST_SEGMENT_REGEX = /^(?=([^\\/?#]*))\\1([^]*)$/;\n\t\t  var SLASH_DOT_REGEX = /(?:\\/|^)\\.(?=\\/)/g;\n\t\t  var SLASH_DOT_DOT_REGEX = /(?:\\/|^)\\.\\.\\/(?!\\.\\.\\/)[^\\/]*(?=\\/)/g;\n\n\t\t  var URLToolkit = {\n\t\t    // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //\n\t\t    // E.g\n\t\t    // With opts.alwaysNormalize = false (default, spec compliant)\n\t\t    // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g\n\t\t    // With opts.alwaysNormalize = true (not spec compliant)\n\t\t    // http://a.com/b/cd + /e/f/../g => http://a.com/e/g\n\t\t    buildAbsoluteURL: function (baseURL, relativeURL, opts) {\n\t\t      opts = opts || {};\n\t\t      // remove any remaining space and CRLF\n\t\t      baseURL = baseURL.trim();\n\t\t      relativeURL = relativeURL.trim();\n\t\t      if (!relativeURL) {\n\t\t        // 2a) If the embedded URL is entirely empty, it inherits the\n\t\t        // entire base URL (i.e., is set equal to the base URL)\n\t\t        // and we are done.\n\t\t        if (!opts.alwaysNormalize) {\n\t\t          return baseURL;\n\t\t        }\n\t\t        var basePartsForNormalise = URLToolkit.parseURL(baseURL);\n\t\t        if (!basePartsForNormalise) {\n\t\t          throw new Error('Error trying to parse base URL.');\n\t\t        }\n\t\t        basePartsForNormalise.path = URLToolkit.normalizePath(\n\t\t          basePartsForNormalise.path\n\t\t        );\n\t\t        return URLToolkit.buildURLFromParts(basePartsForNormalise);\n\t\t      }\n\t\t      var relativeParts = URLToolkit.parseURL(relativeURL);\n\t\t      if (!relativeParts) {\n\t\t        throw new Error('Error trying to parse relative URL.');\n\t\t      }\n\t\t      if (relativeParts.scheme) {\n\t\t        // 2b) If the embedded URL starts with a scheme name, it is\n\t\t        // interpreted as an absolute URL and we are done.\n\t\t        if (!opts.alwaysNormalize) {\n\t\t          return relativeURL;\n\t\t        }\n\t\t        relativeParts.path = URLToolkit.normalizePath(relativeParts.path);\n\t\t        return URLToolkit.buildURLFromParts(relativeParts);\n\t\t      }\n\t\t      var baseParts = URLToolkit.parseURL(baseURL);\n\t\t      if (!baseParts) {\n\t\t        throw new Error('Error trying to parse base URL.');\n\t\t      }\n\t\t      if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {\n\t\t        // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc\n\t\t        // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'\n\t\t        var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);\n\t\t        baseParts.netLoc = pathParts[1];\n\t\t        baseParts.path = pathParts[2];\n\t\t      }\n\t\t      if (baseParts.netLoc && !baseParts.path) {\n\t\t        baseParts.path = '/';\n\t\t      }\n\t\t      var builtParts = {\n\t\t        // 2c) Otherwise, the embedded URL inherits the scheme of\n\t\t        // the base URL.\n\t\t        scheme: baseParts.scheme,\n\t\t        netLoc: relativeParts.netLoc,\n\t\t        path: null,\n\t\t        params: relativeParts.params,\n\t\t        query: relativeParts.query,\n\t\t        fragment: relativeParts.fragment,\n\t\t      };\n\t\t      if (!relativeParts.netLoc) {\n\t\t        // 3) If the embedded URL's <net_loc> is non-empty, we skip to\n\t\t        // Step 7.  Otherwise, the embedded URL inherits the <net_loc>\n\t\t        // (if any) of the base URL.\n\t\t        builtParts.netLoc = baseParts.netLoc;\n\t\t        // 4) If the embedded URL path is preceded by a slash \"/\", the\n\t\t        // path is not relative and we skip to Step 7.\n\t\t        if (relativeParts.path[0] !== '/') {\n\t\t          if (!relativeParts.path) {\n\t\t            // 5) If the embedded URL path is empty (and not preceded by a\n\t\t            // slash), then the embedded URL inherits the base URL path\n\t\t            builtParts.path = baseParts.path;\n\t\t            // 5a) if the embedded URL's <params> is non-empty, we skip to\n\t\t            // step 7; otherwise, it inherits the <params> of the base\n\t\t            // URL (if any) and\n\t\t            if (!relativeParts.params) {\n\t\t              builtParts.params = baseParts.params;\n\t\t              // 5b) if the embedded URL's <query> is non-empty, we skip to\n\t\t              // step 7; otherwise, it inherits the <query> of the base\n\t\t              // URL (if any) and we skip to step 7.\n\t\t              if (!relativeParts.query) {\n\t\t                builtParts.query = baseParts.query;\n\t\t              }\n\t\t            }\n\t\t          } else {\n\t\t            // 6) The last segment of the base URL's path (anything\n\t\t            // following the rightmost slash \"/\", or the entire path if no\n\t\t            // slash is present) is removed and the embedded URL's path is\n\t\t            // appended in its place.\n\t\t            var baseURLPath = baseParts.path;\n\t\t            var newPath =\n\t\t              baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) +\n\t\t              relativeParts.path;\n\t\t            builtParts.path = URLToolkit.normalizePath(newPath);\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t      if (builtParts.path === null) {\n\t\t        builtParts.path = opts.alwaysNormalize\n\t\t          ? URLToolkit.normalizePath(relativeParts.path)\n\t\t          : relativeParts.path;\n\t\t      }\n\t\t      return URLToolkit.buildURLFromParts(builtParts);\n\t\t    },\n\t\t    parseURL: function (url) {\n\t\t      var parts = URL_REGEX.exec(url);\n\t\t      if (!parts) {\n\t\t        return null;\n\t\t      }\n\t\t      return {\n\t\t        scheme: parts[1] || '',\n\t\t        netLoc: parts[2] || '',\n\t\t        path: parts[3] || '',\n\t\t        params: parts[4] || '',\n\t\t        query: parts[5] || '',\n\t\t        fragment: parts[6] || '',\n\t\t      };\n\t\t    },\n\t\t    normalizePath: function (path) {\n\t\t      // The following operations are\n\t\t      // then applied, in order, to the new path:\n\t\t      // 6a) All occurrences of \"./\", where \".\" is a complete path\n\t\t      // segment, are removed.\n\t\t      // 6b) If the path ends with \".\" as a complete path segment,\n\t\t      // that \".\" is removed.\n\t\t      path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');\n\t\t      // 6c) All occurrences of \"<segment>/../\", where <segment> is a\n\t\t      // complete path segment not equal to \"..\", are removed.\n\t\t      // Removal of these path segments is performed iteratively,\n\t\t      // removing the leftmost matching pattern on each iteration,\n\t\t      // until no matching pattern remains.\n\t\t      // 6d) If the path ends with \"<segment>/..\", where <segment> is a\n\t\t      // complete path segment not equal to \"..\", that\n\t\t      // \"<segment>/..\" is removed.\n\t\t      while (\n\t\t        path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length\n\t\t      ) {}\n\t\t      return path.split('').reverse().join('');\n\t\t    },\n\t\t    buildURLFromParts: function (parts) {\n\t\t      return (\n\t\t        parts.scheme +\n\t\t        parts.netLoc +\n\t\t        parts.path +\n\t\t        parts.params +\n\t\t        parts.query +\n\t\t        parts.fragment\n\t\t      );\n\t\t    },\n\t\t  };\n\n\t\t  module.exports = URLToolkit;\n\t\t})(); \n\t} (urlToolkit));\n\treturn urlToolkit.exports;\n}\n\nvar urlToolkitExports = requireUrlToolkit();\n\nclass LoadStats {\n  constructor() {\n    this.aborted = false;\n    this.loaded = 0;\n    this.retry = 0;\n    this.total = 0;\n    this.chunkCount = 0;\n    this.bwEstimate = 0;\n    this.loading = {\n      start: 0,\n      first: 0,\n      end: 0\n    };\n    this.parsing = {\n      start: 0,\n      end: 0\n    };\n    this.buffering = {\n      start: 0,\n      first: 0,\n      end: 0\n    };\n  }\n}\n\nvar ElementaryStreamTypes = {\n  AUDIO: \"audio\",\n  VIDEO: \"video\",\n  AUDIOVIDEO: \"audiovideo\"\n};\nclass BaseSegment {\n  constructor(base) {\n    this._byteRange = null;\n    this._url = null;\n    this._stats = null;\n    this._streams = null;\n    // baseurl is the URL to the playlist\n    this.base = void 0;\n    // relurl is the portion of the URL that comes from inside the playlist.\n    this.relurl = void 0;\n    if (typeof base === 'string') {\n      base = {\n        url: base\n      };\n    }\n    this.base = base;\n    makeEnumerable(this, 'stats');\n  }\n\n  // setByteRange converts a EXT-X-BYTERANGE attribute into a two element array\n  setByteRange(value, previous) {\n    const params = value.split('@', 2);\n    let start;\n    if (params.length === 1) {\n      start = (previous == null ? void 0 : previous.byteRangeEndOffset) || 0;\n    } else {\n      start = parseInt(params[1]);\n    }\n    this._byteRange = [start, parseInt(params[0]) + start];\n  }\n  get baseurl() {\n    return this.base.url;\n  }\n  get byteRange() {\n    if (this._byteRange === null) {\n      return [];\n    }\n    return this._byteRange;\n  }\n  get byteRangeStartOffset() {\n    return this.byteRange[0];\n  }\n  get byteRangeEndOffset() {\n    return this.byteRange[1];\n  }\n  get elementaryStreams() {\n    if (this._streams === null) {\n      this._streams = {\n        [ElementaryStreamTypes.AUDIO]: null,\n        [ElementaryStreamTypes.VIDEO]: null,\n        [ElementaryStreamTypes.AUDIOVIDEO]: null\n      };\n    }\n    return this._streams;\n  }\n  set elementaryStreams(value) {\n    this._streams = value;\n  }\n  get hasStats() {\n    return this._stats !== null;\n  }\n  get hasStreams() {\n    return this._streams !== null;\n  }\n  get stats() {\n    if (this._stats === null) {\n      this._stats = new LoadStats();\n    }\n    return this._stats;\n  }\n  set stats(value) {\n    this._stats = value;\n  }\n  get url() {\n    if (!this._url && this.baseurl && this.relurl) {\n      this._url = urlToolkitExports.buildAbsoluteURL(this.baseurl, this.relurl, {\n        alwaysNormalize: true\n      });\n    }\n    return this._url || '';\n  }\n  set url(value) {\n    this._url = value;\n  }\n  clearElementaryStreamInfo() {\n    const {\n      elementaryStreams\n    } = this;\n    elementaryStreams[ElementaryStreamTypes.AUDIO] = null;\n    elementaryStreams[ElementaryStreamTypes.VIDEO] = null;\n    elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO] = null;\n  }\n}\nfunction isMediaFragment(frag) {\n  return frag.sn !== 'initSegment';\n}\n\n/**\n * Object representing parsed data from an HLS Segment. Found in {@link hls.js#LevelDetails.fragments}.\n */\nclass Fragment extends BaseSegment {\n  constructor(type, base) {\n    super(base);\n    this._decryptdata = null;\n    this._programDateTime = null;\n    this._ref = null;\n    // Approximate bit rate of the fragment expressed in bits per second (bps) as indicated by the last EXT-X-BITRATE (kbps) tag\n    this._bitrate = void 0;\n    this.rawProgramDateTime = null;\n    this.tagList = [];\n    // EXTINF has to be present for a m3u8 to be considered valid\n    this.duration = 0;\n    // sn notates the sequence number for a segment, and if set to a string can be 'initSegment'\n    this.sn = 0;\n    // levelkeys are the EXT-X-KEY tags that apply to this segment for decryption\n    // core difference from the private field _decryptdata is the lack of the initialized IV\n    // _decryptdata will set the IV for this segment based on the segment number in the fragment\n    this.levelkeys = void 0;\n    // A string representing the fragment type\n    this.type = void 0;\n    // A reference to the loader. Set while the fragment is loading, and removed afterwards. Used to abort fragment loading\n    this.loader = null;\n    // A reference to the key loader. Set while the key is loading, and removed afterwards. Used to abort key loading\n    this.keyLoader = null;\n    // The level/track index to which the fragment belongs\n    this.level = -1;\n    // The continuity counter of the fragment\n    this.cc = 0;\n    // The starting Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.\n    this.startPTS = void 0;\n    // The ending Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.\n    this.endPTS = void 0;\n    // The starting Decode Time Stamp (DTS) of the fragment. Set after transmux complete.\n    this.startDTS = void 0;\n    // The ending Decode Time Stamp (DTS) of the fragment. Set after transmux complete.\n    this.endDTS = void 0;\n    // The start time of the fragment, as listed in the manifest. Updated after transmux complete.\n    this.start = 0;\n    // The offset time (seconds) of the fragment from the start of the Playlist\n    this.playlistOffset = 0;\n    // Set by `updateFragPTSDTS` in level-helper\n    this.deltaPTS = void 0;\n    // The maximum starting Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.\n    this.maxStartPTS = void 0;\n    // The minimum ending Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.\n    this.minEndPTS = void 0;\n    // Init Segment bytes (unset for media segments)\n    this.data = void 0;\n    // A flag indicating whether the segment was downloaded in order to test bitrate, and was not buffered\n    this.bitrateTest = false;\n    // #EXTINF  segment title\n    this.title = null;\n    // The Media Initialization Section for this segment\n    this.initSegment = null;\n    // Fragment is the last fragment in the media playlist\n    this.endList = void 0;\n    // Fragment is marked by an EXT-X-GAP tag indicating that it does not contain media data and should not be loaded\n    this.gap = void 0;\n    // Deprecated\n    this.urlId = 0;\n    this.type = type;\n  }\n  get byteLength() {\n    if (this.hasStats) {\n      const total = this.stats.total;\n      if (total) {\n        return total;\n      }\n    }\n    if (this.byteRange) {\n      const start = this.byteRange[0];\n      const end = this.byteRange[1];\n      if (isFiniteNumber(start) && isFiniteNumber(end)) {\n        return end - start;\n      }\n    }\n    return null;\n  }\n  get bitrate() {\n    if (this.byteLength) {\n      return this.byteLength * 8 / this.duration;\n    }\n    if (this._bitrate) {\n      return this._bitrate;\n    }\n    return null;\n  }\n  set bitrate(value) {\n    this._bitrate = value;\n  }\n  get decryptdata() {\n    const {\n      levelkeys\n    } = this;\n    if (!levelkeys && !this._decryptdata) {\n      return null;\n    }\n    if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {\n      const key = this.levelkeys.identity;\n      if (key) {\n        this._decryptdata = key.getDecryptData(this.sn);\n      } else {\n        const keyFormats = Object.keys(this.levelkeys);\n        if (keyFormats.length === 1) {\n          return this._decryptdata = this.levelkeys[keyFormats[0]].getDecryptData(this.sn);\n        }\n      }\n    }\n    return this._decryptdata;\n  }\n  get end() {\n    return this.start + this.duration;\n  }\n  get endProgramDateTime() {\n    if (this.programDateTime === null) {\n      return null;\n    }\n    const duration = !isFiniteNumber(this.duration) ? 0 : this.duration;\n    return this.programDateTime + duration * 1000;\n  }\n  get encrypted() {\n    var _this$_decryptdata;\n    // At the m3u8-parser level we need to add support for manifest signalled keyformats\n    // when we want the fragment to start reporting that it is encrypted.\n    // Currently, keyFormat will only be set for identity keys\n    if ((_this$_decryptdata = this._decryptdata) != null && _this$_decryptdata.encrypted) {\n      return true;\n    } else if (this.levelkeys) {\n      const keyFormats = Object.keys(this.levelkeys);\n      const len = keyFormats.length;\n      if (len > 1 || len === 1 && this.levelkeys[keyFormats[0]].encrypted) {\n        return true;\n      }\n    }\n    return false;\n  }\n  get programDateTime() {\n    if (this._programDateTime === null && this.rawProgramDateTime) {\n      this.programDateTime = Date.parse(this.rawProgramDateTime);\n    }\n    return this._programDateTime;\n  }\n  set programDateTime(value) {\n    if (!isFiniteNumber(value)) {\n      this._programDateTime = this.rawProgramDateTime = null;\n      return;\n    }\n    this._programDateTime = value;\n  }\n  get ref() {\n    if (!isMediaFragment(this)) {\n      return null;\n    }\n    if (!this._ref) {\n      this._ref = {\n        base: this.base,\n        start: this.start,\n        duration: this.duration,\n        sn: this.sn,\n        programDateTime: this.programDateTime\n      };\n    }\n    return this._ref;\n  }\n  addStart(value) {\n    this.setStart(this.start + value);\n  }\n  setStart(value) {\n    this.start = value;\n    if (this._ref) {\n      this._ref.start = value;\n    }\n  }\n  setDuration(value) {\n    this.duration = value;\n    if (this._ref) {\n      this._ref.duration = value;\n    }\n  }\n  setKeyFormat(keyFormat) {\n    if (this.levelkeys) {\n      const key = this.levelkeys[keyFormat];\n      if (key && !this._decryptdata) {\n        this._decryptdata = key.getDecryptData(this.sn);\n      }\n    }\n  }\n  abortRequests() {\n    var _this$loader, _this$keyLoader;\n    (_this$loader = this.loader) == null ? void 0 : _this$loader.abort();\n    (_this$keyLoader = this.keyLoader) == null ? void 0 : _this$keyLoader.abort();\n  }\n  setElementaryStreamInfo(type, startPTS, endPTS, startDTS, endDTS, partial = false) {\n    const {\n      elementaryStreams\n    } = this;\n    const info = elementaryStreams[type];\n    if (!info) {\n      elementaryStreams[type] = {\n        startPTS,\n        endPTS,\n        startDTS,\n        endDTS,\n        partial\n      };\n      return;\n    }\n    info.startPTS = Math.min(info.startPTS, startPTS);\n    info.endPTS = Math.max(info.endPTS, endPTS);\n    info.startDTS = Math.min(info.startDTS, startDTS);\n    info.endDTS = Math.max(info.endDTS, endDTS);\n  }\n}\n\n/**\n * Object representing parsed data from an HLS Partial Segment. Found in {@link hls.js#LevelDetails.partList}.\n */\nclass Part extends BaseSegment {\n  constructor(partAttrs, frag, base, index, previous) {\n    super(base);\n    this.fragOffset = 0;\n    this.duration = 0;\n    this.gap = false;\n    this.independent = false;\n    this.relurl = void 0;\n    this.fragment = void 0;\n    this.index = void 0;\n    this.duration = partAttrs.decimalFloatingPoint('DURATION');\n    this.gap = partAttrs.bool('GAP');\n    this.independent = partAttrs.bool('INDEPENDENT');\n    this.relurl = partAttrs.enumeratedString('URI');\n    this.fragment = frag;\n    this.index = index;\n    const byteRange = partAttrs.enumeratedString('BYTERANGE');\n    if (byteRange) {\n      this.setByteRange(byteRange, previous);\n    }\n    if (previous) {\n      this.fragOffset = previous.fragOffset + previous.duration;\n    }\n  }\n  get start() {\n    return this.fragment.start + this.fragOffset;\n  }\n  get end() {\n    return this.start + this.duration;\n  }\n  get loaded() {\n    const {\n      elementaryStreams\n    } = this;\n    return !!(elementaryStreams.audio || elementaryStreams.video || elementaryStreams.audiovideo);\n  }\n}\nfunction getOwnPropertyDescriptorFromPrototypeChain(object, property) {\n  const prototype = Object.getPrototypeOf(object);\n  if (prototype) {\n    const propertyDescriptor = Object.getOwnPropertyDescriptor(prototype, property);\n    if (propertyDescriptor) {\n      return propertyDescriptor;\n    }\n    return getOwnPropertyDescriptorFromPrototypeChain(prototype, property);\n  }\n}\nfunction makeEnumerable(object, property) {\n  const d = getOwnPropertyDescriptorFromPrototypeChain(object, property);\n  if (d) {\n    d.enumerable = true;\n    Object.defineProperty(object, property, d);\n  }\n}\n\nconst UINT32_MAX$1 = Math.pow(2, 32) - 1;\nconst push = [].push;\n\n// We are using fixed track IDs for driving the MP4 remuxer\n// instead of following the TS PIDs.\n// There is no reason not to do this and some browsers/SourceBuffer-demuxers\n// may not like if there are TrackID \"switches\"\n// See https://github.com/video-dev/hls.js/issues/1331\n// Here we are mapping our internal track types to constant MP4 track IDs\n// With MSE currently one can only have one track of each, and we are muxing\n// whatever video/audio rendition in them.\nconst RemuxerTrackIdConfig = {\n  video: 1,\n  audio: 2,\n  id3: 3,\n  text: 4\n};\nfunction bin2str(data) {\n  return String.fromCharCode.apply(null, data);\n}\nfunction readUint16(buffer, offset) {\n  const val = buffer[offset] << 8 | buffer[offset + 1];\n  return val < 0 ? 65536 + val : val;\n}\nfunction readUint32(buffer, offset) {\n  const val = readSint32(buffer, offset);\n  return val < 0 ? 4294967296 + val : val;\n}\nfunction readUint64(buffer, offset) {\n  let result = readUint32(buffer, offset);\n  result *= Math.pow(2, 32);\n  result += readUint32(buffer, offset + 4);\n  return result;\n}\nfunction readSint32(buffer, offset) {\n  return buffer[offset] << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3];\n}\n\n// Find \"moof\" box\nfunction hasMoofData(data) {\n  const end = data.byteLength;\n  for (let i = 0; i < end;) {\n    const size = readUint32(data, i);\n    if (size > 8 && data[i + 4] === 0x6d && data[i + 5] === 0x6f && data[i + 6] === 0x6f && data[i + 7] === 0x66) {\n      return true;\n    }\n    i = size > 1 ? i + size : end;\n  }\n  return false;\n}\n\n// Find the data for a box specified by its path\nfunction findBox(data, path) {\n  const results = [];\n  if (!path.length) {\n    // short-circuit the search for empty paths\n    return results;\n  }\n  const end = data.byteLength;\n  for (let i = 0; i < end;) {\n    const size = readUint32(data, i);\n    const type = bin2str(data.subarray(i + 4, i + 8));\n    const endbox = size > 1 ? i + size : end;\n    if (type === path[0]) {\n      if (path.length === 1) {\n        // this is the end of the path and we've found the box we were\n        // looking for\n        results.push(data.subarray(i + 8, endbox));\n      } else {\n        // recursively search for the next box along the path\n        const subresults = findBox(data.subarray(i + 8, endbox), path.slice(1));\n        if (subresults.length) {\n          push.apply(results, subresults);\n        }\n      }\n    }\n    i = endbox;\n  }\n\n  // we've finished searching all of data\n  return results;\n}\nfunction parseSegmentIndex(sidx) {\n  const references = [];\n  const version = sidx[0];\n\n  // set initial offset, we skip the reference ID (not needed)\n  let index = 8;\n  const timescale = readUint32(sidx, index);\n  index += 4;\n  let earliestPresentationTime = 0;\n  let firstOffset = 0;\n  if (version === 0) {\n    earliestPresentationTime = readUint32(sidx, index);\n    firstOffset = readUint32(sidx, index + 4);\n    index += 8;\n  } else {\n    earliestPresentationTime = readUint64(sidx, index);\n    firstOffset = readUint64(sidx, index + 8);\n    index += 16;\n  }\n\n  // skip reserved\n  index += 2;\n  let startByte = sidx.length + firstOffset;\n  const referencesCount = readUint16(sidx, index);\n  index += 2;\n  for (let i = 0; i < referencesCount; i++) {\n    let referenceIndex = index;\n    const referenceInfo = readUint32(sidx, referenceIndex);\n    referenceIndex += 4;\n    const referenceSize = referenceInfo & 0x7fffffff;\n    const referenceType = (referenceInfo & 0x80000000) >>> 31;\n    if (referenceType === 1) {\n      logger.warn('SIDX has hierarchical references (not supported)');\n      return null;\n    }\n    const subsegmentDuration = readUint32(sidx, referenceIndex);\n    referenceIndex += 4;\n    references.push({\n      referenceSize,\n      subsegmentDuration,\n      // unscaled\n      info: {\n        duration: subsegmentDuration / timescale,\n        start: startByte,\n        end: startByte + referenceSize - 1\n      }\n    });\n    startByte += referenceSize;\n\n    // Skipping 1 bit for |startsWithSap|, 3 bits for |sapType|, and 28 bits\n    // for |sapDelta|.\n    referenceIndex += 4;\n\n    // skip to next ref\n    index = referenceIndex;\n  }\n  return {\n    earliestPresentationTime,\n    timescale,\n    version,\n    referencesCount,\n    references\n  };\n}\n\n/**\n * Parses an MP4 initialization segment and extracts stream type and\n * timescale values for any declared tracks. Timescale values indicate the\n * number of clock ticks per second to assume for time-based values\n * elsewhere in the MP4.\n *\n * To determine the start time of an MP4, you need two pieces of\n * information: the timescale unit and the earliest base media decode\n * time. Multiple timescales can be specified within an MP4 but the\n * base media decode time is always expressed in the timescale from\n * the media header box for the track:\n * ```\n * moov > trak > mdia > mdhd.timescale\n * moov > trak > mdia > hdlr\n * ```\n * @param initSegment the bytes of the init segment\n * @returns a hash of track type to timescale values or null if\n * the init segment is malformed.\n */\n\nfunction parseInitSegment(initSegment) {\n  const result = [];\n  const traks = findBox(initSegment, ['moov', 'trak']);\n  for (let i = 0; i < traks.length; i++) {\n    const trak = traks[i];\n    const tkhd = findBox(trak, ['tkhd'])[0];\n    if (tkhd) {\n      let version = tkhd[0];\n      const trackId = readUint32(tkhd, version === 0 ? 12 : 20);\n      const mdhd = findBox(trak, ['mdia', 'mdhd'])[0];\n      if (mdhd) {\n        version = mdhd[0];\n        const timescale = readUint32(mdhd, version === 0 ? 12 : 20);\n        const hdlr = findBox(trak, ['mdia', 'hdlr'])[0];\n        if (hdlr) {\n          const hdlrType = bin2str(hdlr.subarray(8, 12));\n          const type = {\n            soun: ElementaryStreamTypes.AUDIO,\n            vide: ElementaryStreamTypes.VIDEO\n          }[hdlrType];\n          // Parse codec details\n          const stsdBox = findBox(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];\n          const stsd = parseStsd(stsdBox);\n          if (type) {\n            // Add 'audio', 'video', and 'audiovideo' track records that will map to SourceBuffers\n            result[trackId] = {\n              timescale,\n              type,\n              stsd\n            };\n            result[type] = _objectSpread2({\n              timescale,\n              id: trackId\n            }, stsd);\n          } else {\n            // Add 'meta' and other track records\n            result[trackId] = {\n              timescale,\n              type: hdlrType,\n              stsd\n            };\n          }\n        }\n      }\n    }\n  }\n  const trex = findBox(initSegment, ['moov', 'mvex', 'trex']);\n  trex.forEach(trex => {\n    const trackId = readUint32(trex, 4);\n    const track = result[trackId];\n    if (track) {\n      track.default = {\n        duration: readUint32(trex, 12),\n        flags: readUint32(trex, 20)\n      };\n    }\n  });\n  return result;\n}\nfunction parseStsd(stsd) {\n  const sampleEntries = stsd.subarray(8);\n  const sampleEntriesEnd = sampleEntries.subarray(8 + 78);\n  const fourCC = bin2str(sampleEntries.subarray(4, 8));\n  let codec = fourCC;\n  let supplemental;\n  const encrypted = fourCC === 'enca' || fourCC === 'encv';\n  if (encrypted) {\n    const encBox = findBox(sampleEntries, [fourCC])[0];\n    const encBoxChildren = encBox.subarray(fourCC === 'enca' ? 28 : 78);\n    const sinfs = findBox(encBoxChildren, ['sinf']);\n    sinfs.forEach(sinf => {\n      const schm = findBox(sinf, ['schm'])[0];\n      if (schm) {\n        const scheme = bin2str(schm.subarray(4, 8));\n        if (scheme === 'cbcs' || scheme === 'cenc') {\n          const frma = findBox(sinf, ['frma'])[0];\n          if (frma) {\n            // for encrypted content codec fourCC will be in frma\n            codec = bin2str(frma);\n          }\n        }\n      }\n    });\n  }\n  const codecFourCC = codec;\n  switch (codec) {\n    case 'avc1':\n    case 'avc2':\n    case 'avc3':\n    case 'avc4':\n      {\n        // extract profile + compatibility + level out of avcC box\n        const avcCBox = findBox(sampleEntriesEnd, ['avcC'])[0];\n        if (avcCBox && avcCBox.length > 3) {\n          codec += '.' + toHex(avcCBox[1]) + toHex(avcCBox[2]) + toHex(avcCBox[3]);\n          supplemental = parseSupplementalDoViCodec(codecFourCC === 'avc1' ? 'dva1' : 'dvav', sampleEntriesEnd);\n        }\n        break;\n      }\n    case 'mp4a':\n      {\n        const codecBox = findBox(sampleEntries, [fourCC])[0];\n        const esdsBox = findBox(codecBox.subarray(28), ['esds'])[0];\n        if (esdsBox && esdsBox.length > 7) {\n          let i = 4;\n          // ES Descriptor tag\n          if (esdsBox[i++] !== 0x03) {\n            break;\n          }\n          i = skipBERInteger(esdsBox, i);\n          i += 2; // skip es_id;\n          const flags = esdsBox[i++];\n          if (flags & 0x80) {\n            i += 2; // skip dependency es_id\n          }\n          if (flags & 0x40) {\n            i += esdsBox[i++]; // skip URL\n          }\n          // Decoder config descriptor\n          if (esdsBox[i++] !== 0x04) {\n            break;\n          }\n          i = skipBERInteger(esdsBox, i);\n          const objectType = esdsBox[i++];\n          if (objectType === 0x40) {\n            codec += '.' + toHex(objectType);\n          } else {\n            break;\n          }\n          i += 12;\n          // Decoder specific info\n          if (esdsBox[i++] !== 0x05) {\n            break;\n          }\n          i = skipBERInteger(esdsBox, i);\n          const firstByte = esdsBox[i++];\n          let audioObjectType = (firstByte & 0xf8) >> 3;\n          if (audioObjectType === 31) {\n            audioObjectType += 1 + ((firstByte & 0x7) << 3) + ((esdsBox[i] & 0xe0) >> 5);\n          }\n          codec += '.' + audioObjectType;\n        }\n        break;\n      }\n    case 'hvc1':\n    case 'hev1':\n      {\n        const hvcCBox = findBox(sampleEntriesEnd, ['hvcC'])[0];\n        if (hvcCBox && hvcCBox.length > 12) {\n          const profileByte = hvcCBox[1];\n          const profileSpace = ['', 'A', 'B', 'C'][profileByte >> 6];\n          const generalProfileIdc = profileByte & 0x1f;\n          const profileCompat = readUint32(hvcCBox, 2);\n          const tierFlag = (profileByte & 0x20) >> 5 ? 'H' : 'L';\n          const levelIDC = hvcCBox[12];\n          const constraintIndicator = hvcCBox.subarray(6, 12);\n          codec += '.' + profileSpace + generalProfileIdc;\n          codec += '.' + reverse32BitInt(profileCompat).toString(16).toUpperCase();\n          codec += '.' + tierFlag + levelIDC;\n          let constraintString = '';\n          for (let i = constraintIndicator.length; i--;) {\n            const byte = constraintIndicator[i];\n            if (byte || constraintString) {\n              const encodedByte = byte.toString(16).toUpperCase();\n              constraintString = '.' + encodedByte + constraintString;\n            }\n          }\n          codec += constraintString;\n        }\n        supplemental = parseSupplementalDoViCodec(codecFourCC == 'hev1' ? 'dvhe' : 'dvh1', sampleEntriesEnd);\n        break;\n      }\n    case 'dvh1':\n    case 'dvhe':\n    case 'dvav':\n    case 'dva1':\n    case 'dav1':\n      {\n        codec = parseSupplementalDoViCodec(codec, sampleEntriesEnd) || codec;\n        break;\n      }\n    case 'vp09':\n      {\n        const vpcCBox = findBox(sampleEntriesEnd, ['vpcC'])[0];\n        if (vpcCBox && vpcCBox.length > 6) {\n          const profile = vpcCBox[4];\n          const level = vpcCBox[5];\n          const bitDepth = vpcCBox[6] >> 4 & 0x0f;\n          codec += '.' + addLeadingZero(profile) + '.' + addLeadingZero(level) + '.' + addLeadingZero(bitDepth);\n        }\n        break;\n      }\n    case 'av01':\n      {\n        const av1CBox = findBox(sampleEntriesEnd, ['av1C'])[0];\n        if (av1CBox && av1CBox.length > 2) {\n          const profile = av1CBox[1] >>> 5;\n          const level = av1CBox[1] & 0x1f;\n          const tierFlag = av1CBox[2] >>> 7 ? 'H' : 'M';\n          const highBitDepth = (av1CBox[2] & 0x40) >> 6;\n          const twelveBit = (av1CBox[2] & 0x20) >> 5;\n          const bitDepth = profile === 2 && highBitDepth ? twelveBit ? 12 : 10 : highBitDepth ? 10 : 8;\n          const monochrome = (av1CBox[2] & 0x10) >> 4;\n          const chromaSubsamplingX = (av1CBox[2] & 0x08) >> 3;\n          const chromaSubsamplingY = (av1CBox[2] & 0x04) >> 2;\n          const chromaSamplePosition = av1CBox[2] & 0x03;\n          // TODO: parse color_description_present_flag\n          // default it to BT.709/limited range for now\n          // more info https://aomediacodec.github.io/av1-isobmff/#av1codecconfigurationbox-syntax\n          const colorPrimaries = 1;\n          const transferCharacteristics = 1;\n          const matrixCoefficients = 1;\n          const videoFullRangeFlag = 0;\n          codec += '.' + profile + '.' + addLeadingZero(level) + tierFlag + '.' + addLeadingZero(bitDepth) + '.' + monochrome + '.' + chromaSubsamplingX + chromaSubsamplingY + chromaSamplePosition + '.' + addLeadingZero(colorPrimaries) + '.' + addLeadingZero(transferCharacteristics) + '.' + addLeadingZero(matrixCoefficients) + '.' + videoFullRangeFlag;\n          supplemental = parseSupplementalDoViCodec('dav1', sampleEntriesEnd);\n        }\n        break;\n      }\n  }\n  return {\n    codec,\n    encrypted,\n    supplemental\n  };\n}\nfunction parseSupplementalDoViCodec(fourCC, sampleEntriesEnd) {\n  const dvvCResult = findBox(sampleEntriesEnd, ['dvvC']); // used by DoVi Profile 8 to 10\n  const dvXCBox = dvvCResult.length ? dvvCResult[0] : findBox(sampleEntriesEnd, ['dvcC'])[0]; // used by DoVi Profiles up to 7 and 20\n  if (dvXCBox) {\n    const doViProfile = dvXCBox[2] >> 1 & 0x7f;\n    const doViLevel = dvXCBox[2] << 5 & 0x20 | dvXCBox[3] >> 3 & 0x1f;\n    return fourCC + '.' + addLeadingZero(doViProfile) + '.' + addLeadingZero(doViLevel);\n  }\n}\nfunction reverse32BitInt(val) {\n  let result = 0;\n  for (let i = 0; i < 32; i++) {\n    result |= (val >> i & 1) << 32 - 1 - i;\n  }\n  return result >>> 0;\n}\nfunction skipBERInteger(bytes, i) {\n  const limit = i + 5;\n  while (bytes[i++] & 0x80 && i < limit) {\n    /* do nothing */\n  }\n  return i;\n}\nfunction toHex(x) {\n  return ('0' + x.toString(16).toUpperCase()).slice(-2);\n}\nfunction addLeadingZero(num) {\n  return (num < 10 ? '0' : '') + num;\n}\nfunction patchEncyptionData(initSegment, decryptdata) {\n  if (!initSegment || !decryptdata) {\n    return initSegment;\n  }\n  const keyId = decryptdata.keyId;\n  if (keyId && decryptdata.isCommonEncryption) {\n    const traks = findBox(initSegment, ['moov', 'trak']);\n    traks.forEach(trak => {\n      const stsd = findBox(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];\n\n      // skip the sample entry count\n      const sampleEntries = stsd.subarray(8);\n      let encBoxes = findBox(sampleEntries, ['enca']);\n      const isAudio = encBoxes.length > 0;\n      if (!isAudio) {\n        encBoxes = findBox(sampleEntries, ['encv']);\n      }\n      encBoxes.forEach(enc => {\n        const encBoxChildren = isAudio ? enc.subarray(28) : enc.subarray(78);\n        const sinfBoxes = findBox(encBoxChildren, ['sinf']);\n        sinfBoxes.forEach(sinf => {\n          const tenc = parseSinf(sinf);\n          if (tenc) {\n            // Look for default key id (keyID offset is always 8 within the tenc box):\n            const tencKeyId = tenc.subarray(8, 24);\n            if (!tencKeyId.some(b => b !== 0)) {\n              logger.log(`[eme] Patching keyId in 'enc${isAudio ? 'a' : 'v'}>sinf>>tenc' box: ${Hex.hexDump(tencKeyId)} -> ${Hex.hexDump(keyId)}`);\n              tenc.set(keyId, 8);\n            }\n          }\n        });\n      });\n    });\n  }\n  return initSegment;\n}\nfunction parseSinf(sinf) {\n  const schm = findBox(sinf, ['schm'])[0];\n  if (schm) {\n    const scheme = bin2str(schm.subarray(4, 8));\n    if (scheme === 'cbcs' || scheme === 'cenc') {\n      return findBox(sinf, ['schi', 'tenc'])[0];\n    }\n  }\n  return null;\n}\n\n/*\n  For Reference:\n  aligned(8) class TrackFragmentHeaderBox\n           extends FullBox(tfhd, 0, tf_flags){\n     unsigned int(32)  track_ID;\n     // all the following are optional fields\n     unsigned int(64)  base_data_offset;\n     unsigned int(32)  sample_description_index;\n     unsigned int(32)  default_sample_duration;\n     unsigned int(32)  default_sample_size;\n     unsigned int(32)  default_sample_flags\n  }\n */\n\nfunction getSampleData(data, initData, logger) {\n  const tracks = {};\n  const trafs = findBox(data, ['moof', 'traf']);\n  for (let i = 0; i < trafs.length; i++) {\n    const traf = trafs[i];\n    // There is only one tfhd & trun per traf\n    // This is true for CMAF style content, and we should perhaps check the ftyp\n    // and only look for a single trun then, but for ISOBMFF we should check\n    // for multiple track runs.\n    const tfhd = findBox(traf, ['tfhd'])[0];\n    // get the track id from the tfhd\n    const id = readUint32(tfhd, 4);\n    const track = initData[id];\n    if (!track) {\n      continue;\n    }\n    const trackTimes = tracks[id] || (tracks[id] = {\n      start: NaN,\n      duration: 0,\n      sampleCount: 0,\n      timescale: track.timescale,\n      type: track.type\n    });\n    // get start DTS\n    const tfdt = findBox(traf, ['tfdt'])[0];\n    if (tfdt) {\n      const version = tfdt[0];\n      let baseTime = readUint32(tfdt, 4);\n      if (version === 1) {\n        // If value is too large, assume signed 64-bit. Negative track fragment decode times are invalid, but they exist in the wild.\n        // This prevents large values from being used for initPTS, which can cause playlist sync issues.\n        // https://github.com/video-dev/hls.js/issues/5303\n        if (baseTime === UINT32_MAX$1) {\n          logger.warn(`[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time`);\n        } else {\n          baseTime *= UINT32_MAX$1 + 1;\n          baseTime += readUint32(tfdt, 8);\n        }\n      }\n      if (isFiniteNumber(baseTime) && (!isFiniteNumber(trackTimes.start) || baseTime < trackTimes.start)) {\n        trackTimes.start = baseTime;\n      }\n    }\n    const trackDefault = track.default;\n    const tfhdFlags = readUint32(tfhd, 0) | (trackDefault == null ? void 0 : trackDefault.flags);\n    let defaultSampleDuration = (trackDefault == null ? void 0 : trackDefault.duration) || 0;\n    if (tfhdFlags & 0x000008) {\n      // 0x000008 indicates the presence of the default_sample_duration field\n      if (tfhdFlags & 0x000002) {\n        // 0x000002 indicates the presence of the sample_description_index field, which precedes default_sample_duration\n        // If present, the default_sample_duration exists at byte offset 12\n        defaultSampleDuration = readUint32(tfhd, 12);\n      } else {\n        // Otherwise, the duration is at byte offset 8\n        defaultSampleDuration = readUint32(tfhd, 8);\n      }\n    }\n    const truns = findBox(traf, ['trun']);\n    let sampleDTS = trackTimes.start || 0;\n    let rawDuration = 0;\n    let sampleDuration = defaultSampleDuration;\n    for (let j = 0; j < truns.length; j++) {\n      const trun = truns[j];\n      const sampleCount = readUint32(trun, 4);\n      const sampleIndex = trackTimes.sampleCount;\n      trackTimes.sampleCount += sampleCount;\n      // Get duration from samples\n      const dataOffsetPresent = trun[3] & 0x01;\n      const firstSampleFlagsPresent = trun[3] & 0x04;\n      const sampleDurationPresent = trun[2] & 0x01;\n      const sampleSizePresent = trun[2] & 0x02;\n      const sampleFlagsPresent = trun[2] & 0x04;\n      const sampleCompositionTimeOffsetPresent = trun[2] & 0x08;\n      let offset = 8;\n      let remaining = sampleCount;\n      if (dataOffsetPresent) {\n        offset += 4;\n      }\n      if (firstSampleFlagsPresent && sampleCount) {\n        const isNonSyncSample = trun[offset + 1] & 0x01;\n        if (!isNonSyncSample && trackTimes.keyFrameIndex === undefined) {\n          trackTimes.keyFrameIndex = sampleIndex;\n        }\n        offset += 4;\n        if (sampleDurationPresent) {\n          sampleDuration = readUint32(trun, offset);\n          offset += 4;\n        } else {\n          sampleDuration = defaultSampleDuration;\n        }\n        if (sampleSizePresent) {\n          offset += 4;\n        }\n        if (sampleCompositionTimeOffsetPresent) {\n          offset += 4;\n        }\n        sampleDTS += sampleDuration;\n        rawDuration += sampleDuration;\n        remaining--;\n      }\n      while (remaining--) {\n        if (sampleDurationPresent) {\n          sampleDuration = readUint32(trun, offset);\n          offset += 4;\n        } else {\n          sampleDuration = defaultSampleDuration;\n        }\n        if (sampleSizePresent) {\n          offset += 4;\n        }\n        if (sampleFlagsPresent) {\n          const isNonSyncSample = trun[offset + 1] & 0x01;\n          if (!isNonSyncSample) {\n            if (trackTimes.keyFrameIndex === undefined) {\n              trackTimes.keyFrameIndex = trackTimes.sampleCount - (remaining + 1);\n              trackTimes.keyFrameStart = sampleDTS;\n            }\n          }\n          offset += 4;\n        }\n        if (sampleCompositionTimeOffsetPresent) {\n          offset += 4;\n        }\n        sampleDTS += sampleDuration;\n        rawDuration += sampleDuration;\n      }\n      if (!rawDuration && defaultSampleDuration) {\n        rawDuration += defaultSampleDuration * sampleCount;\n      }\n    }\n    trackTimes.duration += rawDuration;\n  }\n  if (!Object.keys(tracks).some(trackId => tracks[trackId].duration)) {\n    // If duration samples are not available in the traf use sidx subsegment_duration\n    let sidxMinStart = Infinity;\n    let sidxMaxEnd = 0;\n    const sidxs = findBox(data, ['sidx']);\n    for (let i = 0; i < sidxs.length; i++) {\n      const sidx = parseSegmentIndex(sidxs[i]);\n      if (sidx != null && sidx.references) {\n        sidxMinStart = Math.min(sidxMinStart, sidx.earliestPresentationTime / sidx.timescale);\n        const subSegmentDuration = sidx.references.reduce((dur, ref) => dur + ref.info.duration || 0, 0);\n        sidxMaxEnd = Math.max(sidxMaxEnd, subSegmentDuration + sidx.earliestPresentationTime / sidx.timescale);\n      }\n    }\n    if (sidxMaxEnd && isFiniteNumber(sidxMaxEnd)) {\n      Object.keys(tracks).forEach(trackId => {\n        if (!tracks[trackId].duration) {\n          tracks[trackId].duration = sidxMaxEnd * tracks[trackId].timescale - tracks[trackId].start;\n        }\n      });\n    }\n  }\n  return tracks;\n}\n\n// TODO: Check if the last moof+mdat pair is part of the valid range\nfunction segmentValidRange(data) {\n  const segmentedRange = {\n    valid: null,\n    remainder: null\n  };\n  const moofs = findBox(data, ['moof']);\n  if (moofs.length < 2) {\n    segmentedRange.remainder = data;\n    return segmentedRange;\n  }\n  const last = moofs[moofs.length - 1];\n  // Offset by 8 bytes; findBox offsets the start by as much\n  segmentedRange.valid = data.slice(0, last.byteOffset - 8);\n  segmentedRange.remainder = data.slice(last.byteOffset - 8);\n  return segmentedRange;\n}\nfunction appendUint8Array(data1, data2) {\n  const temp = new Uint8Array(data1.length + data2.length);\n  temp.set(data1);\n  temp.set(data2, data1.length);\n  return temp;\n}\nfunction parseSamples(timeOffset, track) {\n  const seiSamples = [];\n  const videoData = track.samples;\n  const timescale = track.timescale;\n  const trackId = track.id;\n  let isHEVCFlavor = false;\n  const moofs = findBox(videoData, ['moof']);\n  moofs.map(moof => {\n    const moofOffset = moof.byteOffset - 8;\n    const trafs = findBox(moof, ['traf']);\n    trafs.map(traf => {\n      // get the base media decode time from the tfdt\n      const baseTime = findBox(traf, ['tfdt']).map(tfdt => {\n        const version = tfdt[0];\n        let result = readUint32(tfdt, 4);\n        if (version === 1) {\n          result *= Math.pow(2, 32);\n          result += readUint32(tfdt, 8);\n        }\n        return result / timescale;\n      })[0];\n      if (baseTime !== undefined) {\n        timeOffset = baseTime;\n      }\n      return findBox(traf, ['tfhd']).map(tfhd => {\n        const id = readUint32(tfhd, 4);\n        const tfhdFlags = readUint32(tfhd, 0) & 0xffffff;\n        const baseDataOffsetPresent = (tfhdFlags & 0x000001) !== 0;\n        const sampleDescriptionIndexPresent = (tfhdFlags & 0x000002) !== 0;\n        const defaultSampleDurationPresent = (tfhdFlags & 0x000008) !== 0;\n        let defaultSampleDuration = 0;\n        const defaultSampleSizePresent = (tfhdFlags & 0x000010) !== 0;\n        let defaultSampleSize = 0;\n        const defaultSampleFlagsPresent = (tfhdFlags & 0x000020) !== 0;\n        let tfhdOffset = 8;\n        if (id === trackId) {\n          if (baseDataOffsetPresent) {\n            tfhdOffset += 8;\n          }\n          if (sampleDescriptionIndexPresent) {\n            tfhdOffset += 4;\n          }\n          if (defaultSampleDurationPresent) {\n            defaultSampleDuration = readUint32(tfhd, tfhdOffset);\n            tfhdOffset += 4;\n          }\n          if (defaultSampleSizePresent) {\n            defaultSampleSize = readUint32(tfhd, tfhdOffset);\n            tfhdOffset += 4;\n          }\n          if (defaultSampleFlagsPresent) {\n            tfhdOffset += 4;\n          }\n          if (track.type === 'video') {\n            isHEVCFlavor = isHEVC(track.codec);\n          }\n          findBox(traf, ['trun']).map(trun => {\n            const version = trun[0];\n            const flags = readUint32(trun, 0) & 0xffffff;\n            const dataOffsetPresent = (flags & 0x000001) !== 0;\n            let dataOffset = 0;\n            const firstSampleFlagsPresent = (flags & 0x000004) !== 0;\n            const sampleDurationPresent = (flags & 0x000100) !== 0;\n            let sampleDuration = 0;\n            const sampleSizePresent = (flags & 0x000200) !== 0;\n            let sampleSize = 0;\n            const sampleFlagsPresent = (flags & 0x000400) !== 0;\n            const sampleCompositionOffsetsPresent = (flags & 0x000800) !== 0;\n            let compositionOffset = 0;\n            const sampleCount = readUint32(trun, 4);\n            let trunOffset = 8; // past version, flags, and sample count\n\n            if (dataOffsetPresent) {\n              dataOffset = readUint32(trun, trunOffset);\n              trunOffset += 4;\n            }\n            if (firstSampleFlagsPresent) {\n              trunOffset += 4;\n            }\n            let sampleOffset = dataOffset + moofOffset;\n            for (let ix = 0; ix < sampleCount; ix++) {\n              if (sampleDurationPresent) {\n                sampleDuration = readUint32(trun, trunOffset);\n                trunOffset += 4;\n              } else {\n                sampleDuration = defaultSampleDuration;\n              }\n              if (sampleSizePresent) {\n                sampleSize = readUint32(trun, trunOffset);\n                trunOffset += 4;\n              } else {\n                sampleSize = defaultSampleSize;\n              }\n              if (sampleFlagsPresent) {\n                trunOffset += 4;\n              }\n              if (sampleCompositionOffsetsPresent) {\n                if (version === 0) {\n                  compositionOffset = readUint32(trun, trunOffset);\n                } else {\n                  compositionOffset = readSint32(trun, trunOffset);\n                }\n                trunOffset += 4;\n              }\n              if (track.type === ElementaryStreamTypes.VIDEO) {\n                let naluTotalSize = 0;\n                while (naluTotalSize < sampleSize) {\n                  const naluSize = readUint32(videoData, sampleOffset);\n                  sampleOffset += 4;\n                  if (isSEIMessage(isHEVCFlavor, videoData[sampleOffset])) {\n                    const data = videoData.subarray(sampleOffset, sampleOffset + naluSize);\n                    parseSEIMessageFromNALu(data, isHEVCFlavor ? 2 : 1, timeOffset + compositionOffset / timescale, seiSamples);\n                  }\n                  sampleOffset += naluSize;\n                  naluTotalSize += naluSize + 4;\n                }\n              }\n              timeOffset += sampleDuration / timescale;\n            }\n          });\n        }\n      });\n    });\n  });\n  return seiSamples;\n}\nfunction isHEVC(codec) {\n  if (!codec) {\n    return false;\n  }\n  const baseCodec = codec.substring(0, 4);\n  return baseCodec === 'hvc1' || baseCodec === 'hev1' ||\n  // Dolby Vision\n  baseCodec === 'dvh1' || baseCodec === 'dvhe';\n}\nfunction isSEIMessage(isHEVCFlavor, naluHeader) {\n  if (isHEVCFlavor) {\n    const naluType = naluHeader >> 1 & 0x3f;\n    return naluType === 39 || naluType === 40;\n  } else {\n    const naluType = naluHeader & 0x1f;\n    return naluType === 6;\n  }\n}\nfunction parseSEIMessageFromNALu(unescapedData, headerSize, pts, samples) {\n  const data = discardEPB(unescapedData);\n  let seiPtr = 0;\n  // skip nal header\n  seiPtr += headerSize;\n  let payloadType = 0;\n  let payloadSize = 0;\n  let b = 0;\n  while (seiPtr < data.length) {\n    payloadType = 0;\n    do {\n      if (seiPtr >= data.length) {\n        break;\n      }\n      b = data[seiPtr++];\n      payloadType += b;\n    } while (b === 0xff);\n\n    // Parse payload size.\n    payloadSize = 0;\n    do {\n      if (seiPtr >= data.length) {\n        break;\n      }\n      b = data[seiPtr++];\n      payloadSize += b;\n    } while (b === 0xff);\n    const leftOver = data.length - seiPtr;\n    // Create a variable to process the payload\n    let payPtr = seiPtr;\n\n    // Increment the seiPtr to the end of the payload\n    if (payloadSize < leftOver) {\n      seiPtr += payloadSize;\n    } else if (payloadSize > leftOver) {\n      // Some type of corruption has happened?\n      logger.error(`Malformed SEI payload. ${payloadSize} is too small, only ${leftOver} bytes left to parse.`);\n      // We might be able to parse some data, but let's be safe and ignore it.\n      break;\n    }\n    if (payloadType === 4) {\n      const countryCode = data[payPtr++];\n      if (countryCode === 181) {\n        const providerCode = readUint16(data, payPtr);\n        payPtr += 2;\n        if (providerCode === 49) {\n          const userStructure = readUint32(data, payPtr);\n          payPtr += 4;\n          if (userStructure === 0x47413934) {\n            const userDataType = data[payPtr++];\n\n            // Raw CEA-608 bytes wrapped in CEA-708 packet\n            if (userDataType === 3) {\n              const firstByte = data[payPtr++];\n              const totalCCs = 0x1f & firstByte;\n              const enabled = 0x40 & firstByte;\n              const totalBytes = enabled ? 2 + totalCCs * 3 : 0;\n              const byteArray = new Uint8Array(totalBytes);\n              if (enabled) {\n                byteArray[0] = firstByte;\n                for (let i = 1; i < totalBytes; i++) {\n                  byteArray[i] = data[payPtr++];\n                }\n              }\n              samples.push({\n                type: userDataType,\n                payloadType,\n                pts,\n                bytes: byteArray\n              });\n            }\n          }\n        }\n      }\n    } else if (payloadType === 5) {\n      if (payloadSize > 16) {\n        const uuidStrArray = [];\n        for (let i = 0; i < 16; i++) {\n          const _b = data[payPtr++].toString(16);\n          uuidStrArray.push(_b.length == 1 ? '0' + _b : _b);\n          if (i === 3 || i === 5 || i === 7 || i === 9) {\n            uuidStrArray.push('-');\n          }\n        }\n        const length = payloadSize - 16;\n        const userDataBytes = new Uint8Array(length);\n        for (let i = 0; i < length; i++) {\n          userDataBytes[i] = data[payPtr++];\n        }\n        samples.push({\n          payloadType,\n          pts,\n          uuid: uuidStrArray.join(''),\n          userData: utf8ArrayToStr(userDataBytes),\n          userDataBytes\n        });\n      }\n    }\n  }\n}\n\n/**\n * remove Emulation Prevention bytes from a RBSP\n */\nfunction discardEPB(data) {\n  const length = data.byteLength;\n  const EPBPositions = [];\n  let i = 1;\n\n  // Find all `Emulation Prevention Bytes`\n  while (i < length - 2) {\n    if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n      EPBPositions.push(i + 2);\n      i += 2;\n    } else {\n      i++;\n    }\n  }\n\n  // If no Emulation Prevention Bytes were found just return the original\n  // array\n  if (EPBPositions.length === 0) {\n    return data;\n  }\n\n  // Create a new array to hold the NAL unit data\n  const newLength = length - EPBPositions.length;\n  const newData = new Uint8Array(newLength);\n  let sourceIndex = 0;\n  for (i = 0; i < newLength; sourceIndex++, i++) {\n    if (sourceIndex === EPBPositions[0]) {\n      // Skip this byte\n      sourceIndex++;\n      // Remove this position index\n      EPBPositions.shift();\n    }\n    newData[i] = data[sourceIndex];\n  }\n  return newData;\n}\nfunction parseEmsg(data) {\n  const version = data[0];\n  let schemeIdUri = '';\n  let value = '';\n  let timeScale = 0;\n  let presentationTimeDelta = 0;\n  let presentationTime = 0;\n  let eventDuration = 0;\n  let id = 0;\n  let offset = 0;\n  if (version === 0) {\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n      schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n    schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n    offset += 1;\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n      value += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n    value += bin2str(data.subarray(offset, offset + 1));\n    offset += 1;\n    timeScale = readUint32(data, 12);\n    presentationTimeDelta = readUint32(data, 16);\n    eventDuration = readUint32(data, 20);\n    id = readUint32(data, 24);\n    offset = 28;\n  } else if (version === 1) {\n    offset += 4;\n    timeScale = readUint32(data, offset);\n    offset += 4;\n    const leftPresentationTime = readUint32(data, offset);\n    offset += 4;\n    const rightPresentationTime = readUint32(data, offset);\n    offset += 4;\n    presentationTime = 2 ** 32 * leftPresentationTime + rightPresentationTime;\n    if (!isSafeInteger(presentationTime)) {\n      presentationTime = Number.MAX_SAFE_INTEGER;\n      logger.warn('Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box');\n    }\n    eventDuration = readUint32(data, offset);\n    offset += 4;\n    id = readUint32(data, offset);\n    offset += 4;\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n      schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n    schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n    offset += 1;\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n      value += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n    value += bin2str(data.subarray(offset, offset + 1));\n    offset += 1;\n  }\n  const payload = data.subarray(offset, data.byteLength);\n  return {\n    schemeIdUri,\n    value,\n    timeScale,\n    presentationTime,\n    presentationTimeDelta,\n    eventDuration,\n    id,\n    payload\n  };\n}\nfunction mp4Box(type, ...payload) {\n  const len = payload.length;\n  let size = 8;\n  let i = len;\n  while (i--) {\n    size += payload[i].byteLength;\n  }\n  const result = new Uint8Array(size);\n  result[0] = size >> 24 & 0xff;\n  result[1] = size >> 16 & 0xff;\n  result[2] = size >> 8 & 0xff;\n  result[3] = size & 0xff;\n  result.set(type, 4);\n  for (i = 0, size = 8; i < len; i++) {\n    result.set(payload[i], size);\n    size += payload[i].byteLength;\n  }\n  return result;\n}\nfunction mp4pssh(systemId, keyids, data) {\n  if (systemId.byteLength !== 16) {\n    throw new RangeError('Invalid system id');\n  }\n  let version;\n  let kids;\n  {\n    version = 0;\n    kids = new Uint8Array();\n  }\n  let kidCount;\n  if (version > 0) {\n    kidCount = new Uint8Array(4);\n    if (keyids.length > 0) {\n      new DataView(kidCount.buffer).setUint32(0, keyids.length, false);\n    }\n  } else {\n    kidCount = new Uint8Array();\n  }\n  const dataSize = new Uint8Array(4);\n  if (data && data.byteLength > 0) {\n    new DataView(dataSize.buffer).setUint32(0, data.byteLength, false);\n  }\n  return mp4Box([112, 115, 115, 104], new Uint8Array([version, 0x00, 0x00, 0x00 // Flags\n  ]), systemId,\n  // 16 bytes\n  kidCount, kids, dataSize, data || new Uint8Array());\n}\n\nconst userAgentHevcSupportIsInaccurate = () => {\n  return /\\(Windows.+Firefox\\//i.test(navigator.userAgent);\n};\n\n// from http://mp4ra.org/codecs.html\n// values indicate codec selection preference (lower is higher priority)\nconst sampleEntryCodesISO = {\n  audio: {\n    a3ds: 1,\n    'ac-3': 0.95,\n    'ac-4': 1,\n    alac: 0.9,\n    alaw: 1,\n    dra1: 1,\n    'dts+': 1,\n    'dts-': 1,\n    dtsc: 1,\n    dtse: 1,\n    dtsh: 1,\n    'ec-3': 0.9,\n    enca: 1,\n    fLaC: 0.9,\n    // MP4-RA listed codec entry for FLAC\n    flac: 0.9,\n    // legacy browser codec name for FLAC\n    FLAC: 0.9,\n    // some manifests may list \"FLAC\" with Apple's tools\n    g719: 1,\n    g726: 1,\n    m4ae: 1,\n    mha1: 1,\n    mha2: 1,\n    mhm1: 1,\n    mhm2: 1,\n    mlpa: 1,\n    mp4a: 1,\n    'raw ': 1,\n    Opus: 1,\n    opus: 1,\n    // browsers expect this to be lowercase despite MP4RA says 'Opus'\n    samr: 1,\n    sawb: 1,\n    sawp: 1,\n    sevc: 1,\n    sqcp: 1,\n    ssmv: 1,\n    twos: 1,\n    ulaw: 1\n  },\n  video: {\n    avc1: 1,\n    avc2: 1,\n    avc3: 1,\n    avc4: 1,\n    avcp: 1,\n    av01: 0.8,\n    dav1: 0.8,\n    drac: 1,\n    dva1: 1,\n    dvav: 1,\n    dvh1: 0.7,\n    dvhe: 0.7,\n    encv: 1,\n    hev1: 0.75,\n    hvc1: 0.75,\n    mjp2: 1,\n    mp4v: 1,\n    mvc1: 1,\n    mvc2: 1,\n    mvc3: 1,\n    mvc4: 1,\n    resv: 1,\n    rv60: 1,\n    s263: 1,\n    svc1: 1,\n    svc2: 1,\n    'vc-1': 1,\n    vp08: 1,\n    vp09: 0.9\n  },\n  text: {\n    stpp: 1,\n    wvtt: 1\n  }\n};\nfunction isCodecType(codec, type) {\n  const typeCodes = sampleEntryCodesISO[type];\n  return !!typeCodes && !!typeCodes[codec.slice(0, 4)];\n}\nfunction areCodecsMediaSourceSupported(codecs, type, preferManagedMediaSource = true) {\n  return !codecs.split(',').some(codec => !isCodecMediaSourceSupported(codec, type, preferManagedMediaSource));\n}\nfunction isCodecMediaSourceSupported(codec, type, preferManagedMediaSource = true) {\n  var _MediaSource$isTypeSu;\n  const MediaSource = getMediaSource(preferManagedMediaSource);\n  return (_MediaSource$isTypeSu = MediaSource == null ? void 0 : MediaSource.isTypeSupported(mimeTypeForCodec(codec, type))) != null ? _MediaSource$isTypeSu : false;\n}\nfunction mimeTypeForCodec(codec, type) {\n  return `${type}/mp4;codecs=${codec}`;\n}\nfunction videoCodecPreferenceValue(videoCodec) {\n  if (videoCodec) {\n    const fourCC = videoCodec.substring(0, 4);\n    return sampleEntryCodesISO.video[fourCC];\n  }\n  return 2;\n}\nfunction codecsSetSelectionPreferenceValue(codecSet) {\n  const limitedHevcSupport = userAgentHevcSupportIsInaccurate();\n  return codecSet.split(',').reduce((num, fourCC) => {\n    const lowerPriority = limitedHevcSupport && isHEVC(fourCC);\n    const preferenceValue = lowerPriority ? 9 : sampleEntryCodesISO.video[fourCC];\n    if (preferenceValue) {\n      return (preferenceValue * 2 + num) / (num ? 3 : 2);\n    }\n    return (sampleEntryCodesISO.audio[fourCC] + num) / (num ? 2 : 1);\n  }, 0);\n}\nconst CODEC_COMPATIBLE_NAMES = {};\nfunction getCodecCompatibleNameLower(lowerCaseCodec, preferManagedMediaSource = true) {\n  if (CODEC_COMPATIBLE_NAMES[lowerCaseCodec]) {\n    return CODEC_COMPATIBLE_NAMES[lowerCaseCodec];\n  }\n  const codecsToCheck = {\n    // Idealy fLaC and Opus would be first (spec-compliant) but\n    // some browsers will report that fLaC is supported then fail.\n    // see: https://bugs.chromium.org/p/chromium/issues/detail?id=1422728\n    flac: ['flac', 'fLaC', 'FLAC'],\n    opus: ['opus', 'Opus'],\n    // Replace audio codec info if browser does not support mp4a.40.34,\n    // and demuxer can fallback to 'audio/mpeg' or 'audio/mp4;codecs=\"mp3\"'\n    'mp4a.40.34': ['mp3']\n  }[lowerCaseCodec];\n  for (let i = 0; i < codecsToCheck.length; i++) {\n    var _getMediaSource;\n    if (isCodecMediaSourceSupported(codecsToCheck[i], 'audio', preferManagedMediaSource)) {\n      CODEC_COMPATIBLE_NAMES[lowerCaseCodec] = codecsToCheck[i];\n      return codecsToCheck[i];\n    } else if (codecsToCheck[i] === 'mp3' && (_getMediaSource = getMediaSource(preferManagedMediaSource)) != null && _getMediaSource.isTypeSupported('audio/mpeg')) {\n      return '';\n    }\n  }\n  return lowerCaseCodec;\n}\nconst AUDIO_CODEC_REGEXP = /flac|opus|mp4a\\.40\\.34/i;\nfunction getCodecCompatibleName(codec, preferManagedMediaSource = true) {\n  return codec.replace(AUDIO_CODEC_REGEXP, m => getCodecCompatibleNameLower(m.toLowerCase(), preferManagedMediaSource));\n}\nfunction replaceVideoCodec(originalCodecs, newVideoCodec) {\n  const codecs = [];\n  if (originalCodecs) {\n    const allCodecs = originalCodecs.split(',');\n    for (let i = 0; i < allCodecs.length; i++) {\n      if (!isCodecType(allCodecs[i], 'video')) {\n        codecs.push(allCodecs[i]);\n      }\n    }\n  }\n  if (newVideoCodec) {\n    codecs.push(newVideoCodec);\n  }\n  return codecs.join(',');\n}\nfunction pickMostCompleteCodecName(parsedCodec, levelCodec) {\n  // Parsing of mp4a codecs strings in mp4-tools from media is incomplete as of d8c6c7a\n  // so use level codec is parsed codec is unavailable or incomplete\n  if (parsedCodec && (parsedCodec.length > 4 || ['ac-3', 'ec-3', 'alac', 'fLaC', 'Opus'].indexOf(parsedCodec) !== -1)) {\n    if (isCodecSupportedAsType(parsedCodec, 'audio') || isCodecSupportedAsType(parsedCodec, 'video')) {\n      return parsedCodec;\n    }\n  }\n  if (levelCodec) {\n    const levelCodecs = levelCodec.split(',');\n    if (levelCodecs.length > 1) {\n      if (parsedCodec) {\n        for (let i = levelCodecs.length; i--;) {\n          if (levelCodecs[i].substring(0, 4) === parsedCodec.substring(0, 4)) {\n            return levelCodecs[i];\n          }\n        }\n      }\n      return levelCodecs[0];\n    }\n  }\n  return levelCodec || parsedCodec;\n}\nfunction isCodecSupportedAsType(codec, type) {\n  return isCodecType(codec, type) && isCodecMediaSourceSupported(codec, type);\n}\nfunction convertAVC1ToAVCOTI(videoCodecs) {\n  // Convert avc1 codec string from RFC-4281 to RFC-6381 for MediaSource.isTypeSupported\n  // Examples: avc1.66.30 to avc1.42001e and avc1.77.30,avc1.66.30 to avc1.4d001e,avc1.42001e.\n  const codecs = videoCodecs.split(',');\n  for (let i = 0; i < codecs.length; i++) {\n    const avcdata = codecs[i].split('.');\n    // only convert codec strings starting with avc1 (Examples: avc1.64001f,dvh1.05.07)\n    if (avcdata.length > 2 && avcdata[0] === 'avc1') {\n      codecs[i] = `avc1.${parseInt(avcdata[1]).toString(16)}${('000' + parseInt(avcdata[2]).toString(16)).slice(-4)}`;\n    }\n  }\n  return codecs.join(',');\n}\nfunction fillInMissingAV01Params(videoCodec) {\n  // Used to fill in incomplete AV1 playlist CODECS strings for mediaCapabilities.decodingInfo queries\n  if (videoCodec.startsWith('av01.')) {\n    const av1params = videoCodec.split('.');\n    const placeholders = ['0', '111', '01', '01', '01', '0'];\n    for (let i = av1params.length; i > 4 && i < 10; i++) {\n      av1params[i] = placeholders[i - 4];\n    }\n    return av1params.join('.');\n  }\n  return videoCodec;\n}\nfunction getM2TSSupportedAudioTypes(preferManagedMediaSource) {\n  const MediaSource = getMediaSource(preferManagedMediaSource) || {\n    isTypeSupported: () => false\n  };\n  return {\n    mpeg: MediaSource.isTypeSupported('audio/mpeg'),\n    mp3: MediaSource.isTypeSupported('audio/mp4; codecs=\"mp3\"'),\n    ac3: MediaSource.isTypeSupported('audio/mp4; codecs=\"ac-3\"') \n  };\n}\nfunction getCodecsForMimeType(mimeType) {\n  return mimeType.replace(/^.+codecs=[\"']?([^\"']+).*$/, '$1');\n}\n\nconst SUPPORTED_INFO_DEFAULT = {\n  supported: true,\n  configurations: [],\n  decodingInfoResults: [{\n    supported: true,\n    powerEfficient: true,\n    smooth: true\n  }]\n};\nfunction getUnsupportedResult(error, configurations) {\n  return {\n    supported: false,\n    configurations,\n    decodingInfoResults: [{\n      supported: false,\n      smooth: false,\n      powerEfficient: false\n    }],\n    error\n  };\n}\nfunction requiresMediaCapabilitiesDecodingInfo(level, audioTracksByGroup, currentVideoRange, currentFrameRate, currentBw, audioPreference) {\n  // Only test support when configuration is exceeds minimum options\n  const videoCodecs = level.videoCodec;\n  const audioGroups = level.audioCodec ? level.audioGroups : null;\n  const audioCodecPreference = audioPreference == null ? void 0 : audioPreference.audioCodec;\n  const channelsPreference = audioPreference == null ? void 0 : audioPreference.channels;\n  const maxChannels = channelsPreference ? parseInt(channelsPreference) : audioCodecPreference ? Infinity : 2;\n  let audioChannels = null;\n  if (audioGroups != null && audioGroups.length) {\n    try {\n      if (audioGroups.length === 1 && audioGroups[0]) {\n        audioChannels = audioTracksByGroup.groups[audioGroups[0]].channels;\n      } else {\n        audioChannels = audioGroups.reduce((acc, groupId) => {\n          if (groupId) {\n            const audioTrackGroup = audioTracksByGroup.groups[groupId];\n            if (!audioTrackGroup) {\n              throw new Error(`Audio track group ${groupId} not found`);\n            }\n            // Sum all channel key values\n            Object.keys(audioTrackGroup.channels).forEach(key => {\n              acc[key] = (acc[key] || 0) + audioTrackGroup.channels[key];\n            });\n          }\n          return acc;\n        }, {\n          2: 0\n        });\n      }\n    } catch (error) {\n      return true;\n    }\n  }\n  return videoCodecs !== undefined && (\n  // Force media capabilities check for HEVC to avoid failure on Windows\n  videoCodecs.split(',').some(videoCodec => isHEVC(videoCodec)) || level.width > 1920 && level.height > 1088 || level.height > 1920 && level.width > 1088 || level.frameRate > Math.max(currentFrameRate, 30) || level.videoRange !== 'SDR' && level.videoRange !== currentVideoRange || level.bitrate > Math.max(currentBw, 8e6)) || !!audioChannels && isFiniteNumber(maxChannels) && Object.keys(audioChannels).some(channels => parseInt(channels) > maxChannels);\n}\nfunction getMediaDecodingInfoPromise(level, audioTracksByGroup, mediaCapabilities, cache = {}) {\n  const videoCodecs = level.videoCodec;\n  if (!videoCodecs && !level.audioCodec || !mediaCapabilities) {\n    return Promise.resolve(SUPPORTED_INFO_DEFAULT);\n  }\n  const configurations = [];\n  const videoDecodeList = makeVideoConfigurations(level);\n  const videoCount = videoDecodeList.length;\n  const audioDecodeList = makeAudioConfigurations(level, audioTracksByGroup, videoCount > 0);\n  const audioCount = audioDecodeList.length;\n  for (let i = videoCount || 1 * audioCount || 1; i--;) {\n    const configuration = {\n      type: 'media-source'\n    };\n    if (videoCount) {\n      configuration.video = videoDecodeList[i % videoCount];\n    }\n    if (audioCount) {\n      configuration.audio = audioDecodeList[i % audioCount];\n      const audioBitrate = configuration.audio.bitrate;\n      if (configuration.video && audioBitrate) {\n        configuration.video.bitrate -= audioBitrate;\n      }\n    }\n    configurations.push(configuration);\n  }\n  if (videoCodecs) {\n    // Override Windows Firefox HEVC MediaCapabilities result (https://github.com/video-dev/hls.js/issues/7046)\n    const ua = navigator.userAgent;\n    if (videoCodecs.split(',').some(videoCodec => isHEVC(videoCodec)) && userAgentHevcSupportIsInaccurate()) {\n      return Promise.resolve(getUnsupportedResult(new Error(`Overriding Windows Firefox HEVC MediaCapabilities result based on user-agent string: (${ua})`), configurations));\n    }\n  }\n  return Promise.all(configurations.map(configuration => {\n    // Cache MediaCapabilities promises\n    const decodingInfoKey = getMediaDecodingInfoKey(configuration);\n    return cache[decodingInfoKey] || (cache[decodingInfoKey] = mediaCapabilities.decodingInfo(configuration));\n  })).then(decodingInfoResults => ({\n    supported: !decodingInfoResults.some(info => !info.supported),\n    configurations,\n    decodingInfoResults\n  })).catch(error => ({\n    supported: false,\n    configurations,\n    decodingInfoResults: [],\n    error\n  }));\n}\nfunction makeVideoConfigurations(level) {\n  var _level$videoCodec;\n  const videoCodecs = (_level$videoCodec = level.videoCodec) == null ? void 0 : _level$videoCodec.split(',');\n  const bitrate = getVariantDecodingBitrate(level);\n  const width = level.width || 640;\n  const height = level.height || 480;\n  // Assume a framerate of 30fps since MediaCapabilities will not accept Level default of 0.\n  const framerate = level.frameRate || 30;\n  const videoRange = level.videoRange.toLowerCase();\n  return videoCodecs ? videoCodecs.map(videoCodec => {\n    const videoConfiguration = {\n      contentType: mimeTypeForCodec(fillInMissingAV01Params(videoCodec), 'video'),\n      width,\n      height,\n      bitrate,\n      framerate\n    };\n    if (videoRange !== 'sdr') {\n      videoConfiguration.transferFunction = videoRange;\n    }\n    return videoConfiguration;\n  }) : [];\n}\nfunction makeAudioConfigurations(level, audioTracksByGroup, hasVideo) {\n  var _level$audioCodec;\n  const audioCodecs = (_level$audioCodec = level.audioCodec) == null ? void 0 : _level$audioCodec.split(',');\n  const combinedBitrate = getVariantDecodingBitrate(level);\n  if (audioCodecs && level.audioGroups) {\n    return level.audioGroups.reduce((configurations, audioGroupId) => {\n      var _audioTracksByGroup$g;\n      const tracks = audioGroupId ? (_audioTracksByGroup$g = audioTracksByGroup.groups[audioGroupId]) == null ? void 0 : _audioTracksByGroup$g.tracks : null;\n      if (tracks) {\n        return tracks.reduce((configs, audioTrack) => {\n          if (audioTrack.groupId === audioGroupId) {\n            const channelsNumber = parseFloat(audioTrack.channels || '');\n            audioCodecs.forEach(audioCodec => {\n              const audioConfiguration = {\n                contentType: mimeTypeForCodec(audioCodec, 'audio'),\n                bitrate: hasVideo ? estimatedAudioBitrate(audioCodec, combinedBitrate) : combinedBitrate\n              };\n              if (channelsNumber) {\n                audioConfiguration.channels = '' + channelsNumber;\n              }\n              configs.push(audioConfiguration);\n            });\n          }\n          return configs;\n        }, configurations);\n      }\n      return configurations;\n    }, []);\n  }\n  return [];\n}\nfunction estimatedAudioBitrate(audioCodec, levelBitrate) {\n  if (levelBitrate <= 1) {\n    return 1;\n  }\n  let audioBitrate = 128000;\n  if (audioCodec === 'ec-3') {\n    audioBitrate = 768000;\n  } else if (audioCodec === 'ac-3') {\n    audioBitrate = 640000;\n  }\n  return Math.min(levelBitrate / 2, audioBitrate); // Don't exceed some % of level bitrate\n}\nfunction getVariantDecodingBitrate(level) {\n  return Math.ceil(Math.max(level.bitrate * 0.9, level.averageBitrate) / 1000) * 1000 || 1;\n}\nfunction getMediaDecodingInfoKey(config) {\n  let key = '';\n  const {\n    audio,\n    video\n  } = config;\n  if (video) {\n    const codec = getCodecsForMimeType(video.contentType);\n    key += `${codec}_r${video.height}x${video.width}f${Math.ceil(video.framerate)}${video.transferFunction || 'sd'}_${Math.ceil(video.bitrate / 1e5)}`;\n  }\n  if (audio) {\n    const codec = getCodecsForMimeType(audio.contentType);\n    key += `${video ? '_' : ''}${codec}_c${audio.channels}`;\n  }\n  return key;\n}\n\nconst HdcpLevels = ['NONE', 'TYPE-0', 'TYPE-1', null];\nfunction isHdcpLevel(value) {\n  return HdcpLevels.indexOf(value) > -1;\n}\nconst VideoRangeValues = ['SDR', 'PQ', 'HLG'];\nfunction isVideoRange(value) {\n  return !!value && VideoRangeValues.indexOf(value) > -1;\n}\nvar HlsSkip = {\n  No: \"\",\n  Yes: \"YES\",\n  v2: \"v2\"\n};\nfunction getSkipValue(details) {\n  const {\n    canSkipUntil,\n    canSkipDateRanges,\n    age\n  } = details;\n  // A Client SHOULD NOT request a Playlist Delta Update unless it already\n  // has a version of the Playlist that is no older than one-half of the Skip Boundary.\n  // @see: https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis#section-6.3.7\n  const playlistRecentEnough = age < canSkipUntil / 2;\n  if (canSkipUntil && playlistRecentEnough) {\n    if (canSkipDateRanges) {\n      return HlsSkip.v2;\n    }\n    return HlsSkip.Yes;\n  }\n  return HlsSkip.No;\n}\nclass HlsUrlParameters {\n  constructor(msn, part, skip) {\n    this.msn = void 0;\n    this.part = void 0;\n    this.skip = void 0;\n    this.msn = msn;\n    this.part = part;\n    this.skip = skip;\n  }\n  addDirectives(uri) {\n    const url = new self.URL(uri);\n    if (this.msn !== undefined) {\n      url.searchParams.set('_HLS_msn', this.msn.toString());\n    }\n    if (this.part !== undefined) {\n      url.searchParams.set('_HLS_part', this.part.toString());\n    }\n    if (this.skip) {\n      url.searchParams.set('_HLS_skip', this.skip);\n    }\n    return url.href;\n  }\n}\nclass Level {\n  constructor(data) {\n    this._attrs = void 0;\n    this.audioCodec = void 0;\n    this.bitrate = void 0;\n    this.codecSet = void 0;\n    this.url = void 0;\n    this.frameRate = void 0;\n    this.height = void 0;\n    this.id = void 0;\n    this.name = void 0;\n    this.supplemental = void 0;\n    this.videoCodec = void 0;\n    this.width = void 0;\n    this.details = void 0;\n    this.fragmentError = 0;\n    this.loadError = 0;\n    this.loaded = void 0;\n    this.realBitrate = 0;\n    this.supportedPromise = void 0;\n    this.supportedResult = void 0;\n    this._avgBitrate = 0;\n    this._audioGroups = void 0;\n    this._subtitleGroups = void 0;\n    // Deprecated (retained for backwards compatibility)\n    this._urlId = 0;\n    this.url = [data.url];\n    this._attrs = [data.attrs];\n    this.bitrate = data.bitrate;\n    if (data.details) {\n      this.details = data.details;\n    }\n    this.id = data.id || 0;\n    this.name = data.name;\n    this.width = data.width || 0;\n    this.height = data.height || 0;\n    this.frameRate = data.attrs.optionalFloat('FRAME-RATE', 0);\n    this._avgBitrate = data.attrs.decimalInteger('AVERAGE-BANDWIDTH');\n    this.audioCodec = data.audioCodec;\n    this.videoCodec = data.videoCodec;\n    this.codecSet = [data.videoCodec, data.audioCodec].filter(c => !!c).map(s => s.substring(0, 4)).join(',');\n    if ('supplemental' in data) {\n      var _data$supplemental;\n      this.supplemental = data.supplemental;\n      const supplementalVideo = (_data$supplemental = data.supplemental) == null ? void 0 : _data$supplemental.videoCodec;\n      if (supplementalVideo && supplementalVideo !== data.videoCodec) {\n        this.codecSet += `,${supplementalVideo.substring(0, 4)}`;\n      }\n    }\n    this.addGroupId('audio', data.attrs.AUDIO);\n    this.addGroupId('text', data.attrs.SUBTITLES);\n  }\n  get maxBitrate() {\n    return Math.max(this.realBitrate, this.bitrate);\n  }\n  get averageBitrate() {\n    return this._avgBitrate || this.realBitrate || this.bitrate;\n  }\n  get attrs() {\n    return this._attrs[0];\n  }\n  get codecs() {\n    return this.attrs.CODECS || '';\n  }\n  get pathwayId() {\n    return this.attrs['PATHWAY-ID'] || '.';\n  }\n  get videoRange() {\n    return this.attrs['VIDEO-RANGE'] || 'SDR';\n  }\n  get score() {\n    return this.attrs.optionalFloat('SCORE', 0);\n  }\n  get uri() {\n    return this.url[0] || '';\n  }\n  hasAudioGroup(groupId) {\n    return hasGroup(this._audioGroups, groupId);\n  }\n  hasSubtitleGroup(groupId) {\n    return hasGroup(this._subtitleGroups, groupId);\n  }\n  get audioGroups() {\n    return this._audioGroups;\n  }\n  get subtitleGroups() {\n    return this._subtitleGroups;\n  }\n  addGroupId(type, groupId) {\n    if (!groupId) {\n      return;\n    }\n    if (type === 'audio') {\n      let audioGroups = this._audioGroups;\n      if (!audioGroups) {\n        audioGroups = this._audioGroups = [];\n      }\n      if (audioGroups.indexOf(groupId) === -1) {\n        audioGroups.push(groupId);\n      }\n    } else if (type === 'text') {\n      let subtitleGroups = this._subtitleGroups;\n      if (!subtitleGroups) {\n        subtitleGroups = this._subtitleGroups = [];\n      }\n      if (subtitleGroups.indexOf(groupId) === -1) {\n        subtitleGroups.push(groupId);\n      }\n    }\n  }\n\n  // Deprecated methods (retained for backwards compatibility)\n  get urlId() {\n    return 0;\n  }\n  set urlId(value) {}\n  get audioGroupIds() {\n    return this.audioGroups ? [this.audioGroupId] : undefined;\n  }\n  get textGroupIds() {\n    return this.subtitleGroups ? [this.textGroupId] : undefined;\n  }\n  get audioGroupId() {\n    var _this$audioGroups;\n    return (_this$audioGroups = this.audioGroups) == null ? void 0 : _this$audioGroups[0];\n  }\n  get textGroupId() {\n    var _this$subtitleGroups;\n    return (_this$subtitleGroups = this.subtitleGroups) == null ? void 0 : _this$subtitleGroups[0];\n  }\n  addFallback() {}\n}\nfunction hasGroup(groups, groupId) {\n  if (!groupId || !groups) {\n    return false;\n  }\n  return groups.indexOf(groupId) !== -1;\n}\n\n/**\n * @returns Whether we can detect and validate HDR capability within the window context\n */\nfunction isHdrSupported() {\n  if (typeof matchMedia === 'function') {\n    const mediaQueryList = matchMedia('(dynamic-range: high)');\n    const badQuery = matchMedia('bad query');\n    if (mediaQueryList.media !== badQuery.media) {\n      return mediaQueryList.matches === true;\n    }\n  }\n  return false;\n}\n\n/**\n * Sanitizes inputs to return the active video selection options for HDR/SDR.\n * When both inputs are null:\n *\n *    `{ preferHDR: false, allowedVideoRanges: [] }`\n *\n * When `currentVideoRange` non-null, maintain the active range:\n *\n *    `{ preferHDR: currentVideoRange !== 'SDR', allowedVideoRanges: [currentVideoRange] }`\n *\n * When VideoSelectionOption non-null:\n *\n *  - Allow all video ranges if `allowedVideoRanges` unspecified.\n *  - If `preferHDR` is non-null use the value to filter `allowedVideoRanges`.\n *  - Else check window for HDR support and set `preferHDR` to the result.\n *\n * @param currentVideoRange\n * @param videoPreference\n */\nfunction getVideoSelectionOptions(currentVideoRange, videoPreference) {\n  let preferHDR = false;\n  let allowedVideoRanges = [];\n  if (currentVideoRange) {\n    preferHDR = currentVideoRange !== 'SDR';\n    allowedVideoRanges = [currentVideoRange];\n  }\n  if (videoPreference) {\n    allowedVideoRanges = videoPreference.allowedVideoRanges || VideoRangeValues.slice(0);\n    const allowAutoPreferHDR = allowedVideoRanges.join('') !== 'SDR' && !videoPreference.videoCodec;\n    preferHDR = videoPreference.preferHDR !== undefined ? videoPreference.preferHDR : allowAutoPreferHDR && isHdrSupported();\n    if (!preferHDR) {\n      allowedVideoRanges = ['SDR'];\n    }\n  }\n  return {\n    preferHDR,\n    allowedVideoRanges\n  };\n}\n\nconst omitCircularRefsReplacer = replacer => {\n  const known = new WeakSet();\n  return (_, value) => {\n    if (replacer) {\n      value = replacer(_, value);\n    }\n    if (typeof value === 'object' && value !== null) {\n      if (known.has(value)) {\n        return;\n      }\n      known.add(value);\n    }\n    return value;\n  };\n};\nconst stringify = (object, replacer) => JSON.stringify(object, omitCircularRefsReplacer(replacer));\n\nfunction getStartCodecTier(codecTiers, currentVideoRange, currentBw, audioPreference, videoPreference) {\n  const codecSets = Object.keys(codecTiers);\n  const channelsPreference = audioPreference == null ? void 0 : audioPreference.channels;\n  const audioCodecPreference = audioPreference == null ? void 0 : audioPreference.audioCodec;\n  const videoCodecPreference = videoPreference == null ? void 0 : videoPreference.videoCodec;\n  const preferStereo = channelsPreference && parseInt(channelsPreference) === 2;\n  // Use first level set to determine stereo, and minimum resolution and framerate\n  let hasStereo = false;\n  let hasCurrentVideoRange = false;\n  let minHeight = Infinity;\n  let minFramerate = Infinity;\n  let minBitrate = Infinity;\n  let minIndex = Infinity;\n  let selectedScore = 0;\n  let videoRanges = [];\n  const {\n    preferHDR,\n    allowedVideoRanges\n  } = getVideoSelectionOptions(currentVideoRange, videoPreference);\n  for (let i = codecSets.length; i--;) {\n    const tier = codecTiers[codecSets[i]];\n    hasStereo || (hasStereo = tier.channels[2] > 0);\n    minHeight = Math.min(minHeight, tier.minHeight);\n    minFramerate = Math.min(minFramerate, tier.minFramerate);\n    minBitrate = Math.min(minBitrate, tier.minBitrate);\n    const matchingVideoRanges = allowedVideoRanges.filter(range => tier.videoRanges[range] > 0);\n    if (matchingVideoRanges.length > 0) {\n      hasCurrentVideoRange = true;\n    }\n  }\n  minHeight = isFiniteNumber(minHeight) ? minHeight : 0;\n  minFramerate = isFiniteNumber(minFramerate) ? minFramerate : 0;\n  const maxHeight = Math.max(1080, minHeight);\n  const maxFramerate = Math.max(30, minFramerate);\n  minBitrate = isFiniteNumber(minBitrate) ? minBitrate : currentBw;\n  currentBw = Math.max(minBitrate, currentBw);\n  // If there are no variants with matching preference, set currentVideoRange to undefined\n  if (!hasCurrentVideoRange) {\n    currentVideoRange = undefined;\n  }\n  const hasMultipleSets = codecSets.length > 1;\n  const codecSet = codecSets.reduce((selected, candidate) => {\n    // Remove candiates which do not meet bitrate, default audio, stereo or channels preference, 1080p or lower, 30fps or lower, or SDR/HDR selection if present\n    const candidateTier = codecTiers[candidate];\n    if (candidate === selected) {\n      return selected;\n    }\n    videoRanges = hasCurrentVideoRange ? allowedVideoRanges.filter(range => candidateTier.videoRanges[range] > 0) : [];\n    if (hasMultipleSets) {\n      if (candidateTier.minBitrate > currentBw) {\n        logStartCodecCandidateIgnored(candidate, `min bitrate of ${candidateTier.minBitrate} > current estimate of ${currentBw}`);\n        return selected;\n      }\n      if (!candidateTier.hasDefaultAudio) {\n        logStartCodecCandidateIgnored(candidate, `no renditions with default or auto-select sound found`);\n        return selected;\n      }\n      if (audioCodecPreference && candidate.indexOf(audioCodecPreference.substring(0, 4)) % 5 !== 0) {\n        logStartCodecCandidateIgnored(candidate, `audio codec preference \"${audioCodecPreference}\" not found`);\n        return selected;\n      }\n      if (channelsPreference && !preferStereo) {\n        if (!candidateTier.channels[channelsPreference]) {\n          logStartCodecCandidateIgnored(candidate, `no renditions with ${channelsPreference} channel sound found (channels options: ${Object.keys(candidateTier.channels)})`);\n          return selected;\n        }\n      } else if ((!audioCodecPreference || preferStereo) && hasStereo && candidateTier.channels['2'] === 0) {\n        logStartCodecCandidateIgnored(candidate, `no renditions with stereo sound found`);\n        return selected;\n      }\n      if (candidateTier.minHeight > maxHeight) {\n        logStartCodecCandidateIgnored(candidate, `min resolution of ${candidateTier.minHeight} > maximum of ${maxHeight}`);\n        return selected;\n      }\n      if (candidateTier.minFramerate > maxFramerate) {\n        logStartCodecCandidateIgnored(candidate, `min framerate of ${candidateTier.minFramerate} > maximum of ${maxFramerate}`);\n        return selected;\n      }\n      if (!videoRanges.some(range => candidateTier.videoRanges[range] > 0)) {\n        logStartCodecCandidateIgnored(candidate, `no variants with VIDEO-RANGE of ${stringify(videoRanges)} found`);\n        return selected;\n      }\n      if (videoCodecPreference && candidate.indexOf(videoCodecPreference.substring(0, 4)) % 5 !== 0) {\n        logStartCodecCandidateIgnored(candidate, `video codec preference \"${videoCodecPreference}\" not found`);\n        return selected;\n      }\n      if (candidateTier.maxScore < selectedScore) {\n        logStartCodecCandidateIgnored(candidate, `max score of ${candidateTier.maxScore} < selected max of ${selectedScore}`);\n        return selected;\n      }\n    }\n    // Remove candiates with less preferred codecs or more errors\n    if (selected && (codecsSetSelectionPreferenceValue(candidate) >= codecsSetSelectionPreferenceValue(selected) || candidateTier.fragmentError > codecTiers[selected].fragmentError)) {\n      return selected;\n    }\n    minIndex = candidateTier.minIndex;\n    selectedScore = candidateTier.maxScore;\n    return candidate;\n  }, undefined);\n  return {\n    codecSet,\n    videoRanges,\n    preferHDR,\n    minFramerate,\n    minBitrate,\n    minIndex\n  };\n}\nfunction logStartCodecCandidateIgnored(codeSet, reason) {\n  logger.log(`[abr] start candidates with \"${codeSet}\" ignored because ${reason}`);\n}\nfunction getAudioTracksByGroup(allAudioTracks) {\n  return allAudioTracks.reduce((audioTracksByGroup, track) => {\n    let trackGroup = audioTracksByGroup.groups[track.groupId];\n    if (!trackGroup) {\n      trackGroup = audioTracksByGroup.groups[track.groupId] = {\n        tracks: [],\n        channels: {\n          2: 0\n        },\n        hasDefault: false,\n        hasAutoSelect: false\n      };\n    }\n    trackGroup.tracks.push(track);\n    const channelsKey = track.channels || '2';\n    trackGroup.channels[channelsKey] = (trackGroup.channels[channelsKey] || 0) + 1;\n    trackGroup.hasDefault = trackGroup.hasDefault || track.default;\n    trackGroup.hasAutoSelect = trackGroup.hasAutoSelect || track.autoselect;\n    if (trackGroup.hasDefault) {\n      audioTracksByGroup.hasDefaultAudio = true;\n    }\n    if (trackGroup.hasAutoSelect) {\n      audioTracksByGroup.hasAutoSelectAudio = true;\n    }\n    return audioTracksByGroup;\n  }, {\n    hasDefaultAudio: false,\n    hasAutoSelectAudio: false,\n    groups: {}\n  });\n}\nfunction getCodecTiers(levels, audioTracksByGroup, minAutoLevel, maxAutoLevel) {\n  return levels.slice(minAutoLevel, maxAutoLevel + 1).reduce((tiers, level, index) => {\n    if (!level.codecSet) {\n      return tiers;\n    }\n    const audioGroups = level.audioGroups;\n    let tier = tiers[level.codecSet];\n    if (!tier) {\n      tiers[level.codecSet] = tier = {\n        minBitrate: Infinity,\n        minHeight: Infinity,\n        minFramerate: Infinity,\n        minIndex: index,\n        maxScore: 0,\n        videoRanges: {\n          SDR: 0\n        },\n        channels: {\n          '2': 0\n        },\n        hasDefaultAudio: !audioGroups,\n        fragmentError: 0\n      };\n    }\n    tier.minBitrate = Math.min(tier.minBitrate, level.bitrate);\n    const lesserWidthOrHeight = Math.min(level.height, level.width);\n    tier.minHeight = Math.min(tier.minHeight, lesserWidthOrHeight);\n    tier.minFramerate = Math.min(tier.minFramerate, level.frameRate);\n    tier.minIndex = Math.min(tier.minIndex, index);\n    tier.maxScore = Math.max(tier.maxScore, level.score);\n    tier.fragmentError += level.fragmentError;\n    tier.videoRanges[level.videoRange] = (tier.videoRanges[level.videoRange] || 0) + 1;\n    if (audioGroups) {\n      audioGroups.forEach(audioGroupId => {\n        if (!audioGroupId) {\n          return;\n        }\n        const audioGroup = audioTracksByGroup.groups[audioGroupId];\n        if (!audioGroup) {\n          return;\n        }\n        // Default audio is any group with DEFAULT=YES, or if missing then any group with AUTOSELECT=YES, or all variants\n        tier.hasDefaultAudio = tier.hasDefaultAudio || audioTracksByGroup.hasDefaultAudio ? audioGroup.hasDefault : audioGroup.hasAutoSelect || !audioTracksByGroup.hasDefaultAudio && !audioTracksByGroup.hasAutoSelectAudio;\n        Object.keys(audioGroup.channels).forEach(channels => {\n          tier.channels[channels] = (tier.channels[channels] || 0) + audioGroup.channels[channels];\n        });\n      });\n    }\n    return tiers;\n  }, {});\n}\nfunction getBasicSelectionOption(option) {\n  if (!option) {\n    return option;\n  }\n  const {\n    lang,\n    assocLang,\n    characteristics,\n    channels,\n    audioCodec\n  } = option;\n  return {\n    lang,\n    assocLang,\n    characteristics,\n    channels,\n    audioCodec\n  };\n}\nfunction findMatchingOption(option, tracks, matchPredicate) {\n  if ('attrs' in option) {\n    const index = tracks.indexOf(option);\n    if (index !== -1) {\n      return index;\n    }\n  }\n  for (let i = 0; i < tracks.length; i++) {\n    const track = tracks[i];\n    if (matchesOption(option, track, matchPredicate)) {\n      return i;\n    }\n  }\n  return -1;\n}\nfunction matchesOption(option, track, matchPredicate) {\n  const {\n    groupId,\n    name,\n    lang,\n    assocLang,\n    default: isDefault\n  } = option;\n  const forced = option.forced;\n  return (groupId === undefined || track.groupId === groupId) && (name === undefined || track.name === name) && (lang === undefined || languagesMatch(lang, track.lang)) && (lang === undefined || track.assocLang === assocLang) && (isDefault === undefined || track.default === isDefault) && (forced === undefined || track.forced === forced) && (!('characteristics' in option) || characteristicsMatch(option.characteristics || '', track.characteristics)) && (matchPredicate === undefined || matchPredicate(option, track));\n}\nfunction languagesMatch(languageA, languageB = '--') {\n  if (languageA.length === languageB.length) {\n    return languageA === languageB;\n  }\n  return languageA.startsWith(languageB) || languageB.startsWith(languageA);\n}\nfunction characteristicsMatch(characteristicsA, characteristicsB = '') {\n  const arrA = characteristicsA.split(',');\n  const arrB = characteristicsB.split(',');\n  // Expects each item to be unique:\n  return arrA.length === arrB.length && !arrA.some(el => arrB.indexOf(el) === -1);\n}\nfunction audioMatchPredicate(option, track) {\n  const {\n    audioCodec,\n    channels\n  } = option;\n  return (audioCodec === undefined || (track.audioCodec || '').substring(0, 4) === audioCodec.substring(0, 4)) && (channels === undefined || channels === (track.channels || '2'));\n}\nfunction findClosestLevelWithAudioGroup(option, levels, allAudioTracks, searchIndex, matchPredicate) {\n  const currentLevel = levels[searchIndex];\n  // Are there variants with same URI as current level?\n  // If so, find a match that does not require any level URI change\n  const variants = levels.reduce((variantMap, level, index) => {\n    const uri = level.uri;\n    const renditions = variantMap[uri] || (variantMap[uri] = []);\n    renditions.push(index);\n    return variantMap;\n  }, {});\n  const renditions = variants[currentLevel.uri];\n  if (renditions.length > 1) {\n    searchIndex = Math.max.apply(Math, renditions);\n  }\n  // Find best match\n  const currentVideoRange = currentLevel.videoRange;\n  const currentFrameRate = currentLevel.frameRate;\n  const currentVideoCodec = currentLevel.codecSet.substring(0, 4);\n  const matchingVideo = searchDownAndUpList(levels, searchIndex, level => {\n    if (level.videoRange !== currentVideoRange || level.frameRate !== currentFrameRate || level.codecSet.substring(0, 4) !== currentVideoCodec) {\n      return false;\n    }\n    const audioGroups = level.audioGroups;\n    const tracks = allAudioTracks.filter(track => !audioGroups || audioGroups.indexOf(track.groupId) !== -1);\n    return findMatchingOption(option, tracks, matchPredicate) > -1;\n  });\n  if (matchingVideo > -1) {\n    return matchingVideo;\n  }\n  return searchDownAndUpList(levels, searchIndex, level => {\n    const audioGroups = level.audioGroups;\n    const tracks = allAudioTracks.filter(track => !audioGroups || audioGroups.indexOf(track.groupId) !== -1);\n    return findMatchingOption(option, tracks, matchPredicate) > -1;\n  });\n}\nfunction searchDownAndUpList(arr, searchIndex, predicate) {\n  for (let i = searchIndex; i > -1; i--) {\n    if (predicate(arr[i])) {\n      return i;\n    }\n  }\n  for (let i = searchIndex + 1; i < arr.length; i++) {\n    if (predicate(arr[i])) {\n      return i;\n    }\n  }\n  return -1;\n}\nfunction useAlternateAudio(audioTrackUrl, hls) {\n  var _hls$loadLevelObj;\n  return !!audioTrackUrl && audioTrackUrl !== ((_hls$loadLevelObj = hls.loadLevelObj) == null ? void 0 : _hls$loadLevelObj.uri);\n}\n\nclass AbrController extends Logger {\n  constructor(_hls) {\n    super('abr', _hls.logger);\n    this.hls = void 0;\n    this.lastLevelLoadSec = 0;\n    this.lastLoadedFragLevel = -1;\n    this.firstSelection = -1;\n    this._nextAutoLevel = -1;\n    this.nextAutoLevelKey = '';\n    this.audioTracksByGroup = null;\n    this.codecTiers = null;\n    this.timer = -1;\n    this.fragCurrent = null;\n    this.partCurrent = null;\n    this.bitrateTestDelay = 0;\n    this.rebufferNotice = -1;\n    this.supportedCache = {};\n    this.bwEstimator = void 0;\n    /*\n        This method monitors the download rate of the current fragment, and will downswitch if that fragment will not load\n        quickly enough to prevent underbuffering\n      */\n    this._abandonRulesCheck = levelLoaded => {\n      var _ref;\n      const {\n        fragCurrent: frag,\n        partCurrent: part,\n        hls\n      } = this;\n      const {\n        autoLevelEnabled,\n        media\n      } = hls;\n      if (!frag || !media) {\n        return;\n      }\n      const now = performance.now();\n      const stats = part ? part.stats : frag.stats;\n      const duration = part ? part.duration : frag.duration;\n      const timeLoading = now - stats.loading.start;\n      const minAutoLevel = hls.minAutoLevel;\n      const loadingFragForLevel = frag.level;\n      const currentAutoLevel = this._nextAutoLevel;\n      // If frag loading is aborted, complete, or from lowest level, stop timer and return\n      if (stats.aborted || stats.loaded && stats.loaded === stats.total || loadingFragForLevel <= minAutoLevel) {\n        this.clearTimer();\n        // reset forced auto level value so that next level will be selected\n        this._nextAutoLevel = -1;\n        return;\n      }\n\n      // This check only runs if we're in ABR mode\n      if (!autoLevelEnabled) {\n        return;\n      }\n\n      // Must be loading/loaded a new level or be in a playing state\n      const fragBlockingSwitch = currentAutoLevel > -1 && currentAutoLevel !== loadingFragForLevel;\n      const levelChange = !!levelLoaded || fragBlockingSwitch;\n      if (!levelChange && (media.paused || !media.playbackRate || !media.readyState)) {\n        return;\n      }\n      const bufferInfo = hls.mainForwardBufferInfo;\n      if (!levelChange && bufferInfo === null) {\n        return;\n      }\n      const ttfbEstimate = this.bwEstimator.getEstimateTTFB();\n      const playbackRate = Math.abs(media.playbackRate);\n      // To maintain stable adaptive playback, only begin monitoring frag loading after half or more of its playback duration has passed\n      if (timeLoading <= Math.max(ttfbEstimate, 1000 * (duration / (playbackRate * 2)))) {\n        return;\n      }\n\n      // bufferStarvationDelay is an estimate of the amount time (in seconds) it will take to exhaust the buffer\n      const bufferStarvationDelay = bufferInfo ? bufferInfo.len / playbackRate : 0;\n      const ttfb = stats.loading.first ? stats.loading.first - stats.loading.start : -1;\n      const loadedFirstByte = stats.loaded && ttfb > -1;\n      const bwEstimate = this.getBwEstimate();\n      const levels = hls.levels;\n      const level = levels[loadingFragForLevel];\n      const expectedLen = Math.max(stats.loaded, Math.round(duration * (frag.bitrate || level.averageBitrate) / 8));\n      let timeStreaming = loadedFirstByte ? timeLoading - ttfb : timeLoading;\n      if (timeStreaming < 1 && loadedFirstByte) {\n        timeStreaming = Math.min(timeLoading, stats.loaded * 8 / bwEstimate);\n      }\n      const loadRate = loadedFirstByte ? stats.loaded * 1000 / timeStreaming : 0;\n      // fragLoadDelay is an estimate of the time (in seconds) it will take to buffer the remainder of the fragment\n      const ttfbSeconds = ttfbEstimate / 1000;\n      const fragLoadedDelay = loadRate ? (expectedLen - stats.loaded) / loadRate : expectedLen * 8 / bwEstimate + ttfbSeconds;\n      // Only downswitch if the time to finish loading the current fragment is greater than the amount of buffer left\n      if (fragLoadedDelay <= bufferStarvationDelay) {\n        return;\n      }\n      const bwe = loadRate ? loadRate * 8 : bwEstimate;\n      const live = ((_ref = (levelLoaded == null ? void 0 : levelLoaded.details) || this.hls.latestLevelDetails) == null ? void 0 : _ref.live) === true;\n      const abrBandWidthUpFactor = this.hls.config.abrBandWidthUpFactor;\n      let fragLevelNextLoadedDelay = Number.POSITIVE_INFINITY;\n      let nextLoadLevel;\n      // Iterate through lower level and try to find the largest one that avoids rebuffering\n      for (nextLoadLevel = loadingFragForLevel - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) {\n        // compute time to load next fragment at lower level\n        // 8 = bits per byte (bps/Bps)\n        const levelNextBitrate = levels[nextLoadLevel].maxBitrate;\n        const requiresLevelLoad = !levels[nextLoadLevel].details || live;\n        fragLevelNextLoadedDelay = this.getTimeToLoadFrag(ttfbSeconds, bwe, duration * levelNextBitrate, requiresLevelLoad);\n        if (fragLevelNextLoadedDelay < Math.min(bufferStarvationDelay, duration + ttfbSeconds)) {\n          break;\n        }\n      }\n      // Only emergency switch down if it takes less time to load a new fragment at lowest level instead of continuing\n      // to load the current one\n      if (fragLevelNextLoadedDelay >= fragLoadedDelay) {\n        return;\n      }\n\n      // if estimated load time of new segment is completely unreasonable, ignore and do not emergency switch down\n      if (fragLevelNextLoadedDelay > duration * 10) {\n        return;\n      }\n      if (loadedFirstByte) {\n        // If there has been loading progress, sample bandwidth using loading time offset by minimum TTFB time\n        this.bwEstimator.sample(timeLoading - Math.min(ttfbEstimate, ttfb), stats.loaded);\n      } else {\n        // If there has been no loading progress, sample TTFB\n        this.bwEstimator.sampleTTFB(timeLoading);\n      }\n      const nextLoadLevelBitrate = levels[nextLoadLevel].maxBitrate;\n      if (this.getBwEstimate() * abrBandWidthUpFactor > nextLoadLevelBitrate) {\n        this.resetEstimator(nextLoadLevelBitrate);\n      }\n      const bestSwitchLevel = this.findBestLevel(nextLoadLevelBitrate, minAutoLevel, nextLoadLevel, 0, bufferStarvationDelay, 1, 1);\n      if (bestSwitchLevel > -1) {\n        nextLoadLevel = bestSwitchLevel;\n      }\n      this.warn(`Fragment ${frag.sn}${part ? ' part ' + part.index : ''} of level ${loadingFragForLevel} is loading too slowly;\n      Fragment duration: ${frag.duration.toFixed(3)}\n      Time to underbuffer: ${bufferStarvationDelay.toFixed(3)} s\n      Estimated load time for current fragment: ${fragLoadedDelay.toFixed(3)} s\n      Estimated load time for down switch fragment: ${fragLevelNextLoadedDelay.toFixed(3)} s\n      TTFB estimate: ${ttfb | 0} ms\n      Current BW estimate: ${isFiniteNumber(bwEstimate) ? bwEstimate | 0 : 'Unknown'} bps\n      New BW estimate: ${this.getBwEstimate() | 0} bps\n      Switching to level ${nextLoadLevel} @ ${nextLoadLevelBitrate | 0} bps`);\n      hls.nextLoadLevel = hls.nextAutoLevel = nextLoadLevel;\n      this.clearTimer();\n      const abortAndSwitch = () => {\n        // Are nextLoadLevel details available or is stream-controller still in \"WAITING_LEVEL\" state?\n        this.clearTimer();\n        if (this.fragCurrent === frag && this.hls.loadLevel === nextLoadLevel && nextLoadLevel > 0) {\n          const bufferStarvationDelay = this.getStarvationDelay();\n          this.warn(`Aborting inflight request ${nextLoadLevel > 0 ? 'and switching down' : ''}\n      Fragment duration: ${frag.duration.toFixed(3)} s\n      Time to underbuffer: ${bufferStarvationDelay.toFixed(3)} s`);\n          frag.abortRequests();\n          this.fragCurrent = this.partCurrent = null;\n          if (nextLoadLevel > minAutoLevel) {\n            let lowestSwitchLevel = this.findBestLevel(this.hls.levels[minAutoLevel].bitrate, minAutoLevel, nextLoadLevel, 0, bufferStarvationDelay, 1, 1);\n            if (lowestSwitchLevel === -1) {\n              lowestSwitchLevel = minAutoLevel;\n            }\n            this.hls.nextLoadLevel = this.hls.nextAutoLevel = lowestSwitchLevel;\n            this.resetEstimator(this.hls.levels[lowestSwitchLevel].bitrate);\n          }\n        }\n      };\n      if (fragBlockingSwitch || fragLoadedDelay > fragLevelNextLoadedDelay * 2) {\n        abortAndSwitch();\n      } else {\n        this.timer = self.setInterval(abortAndSwitch, fragLevelNextLoadedDelay * 1000);\n      }\n      hls.trigger(Events.FRAG_LOAD_EMERGENCY_ABORTED, {\n        frag,\n        part,\n        stats\n      });\n    };\n    this.hls = _hls;\n    this.bwEstimator = this.initEstimator();\n    this.registerListeners();\n  }\n  resetEstimator(abrEwmaDefaultEstimate) {\n    if (abrEwmaDefaultEstimate) {\n      this.log(`setting initial bwe to ${abrEwmaDefaultEstimate}`);\n      this.hls.config.abrEwmaDefaultEstimate = abrEwmaDefaultEstimate;\n    }\n    this.firstSelection = -1;\n    this.bwEstimator = this.initEstimator();\n  }\n  initEstimator() {\n    const config = this.hls.config;\n    return new EwmaBandWidthEstimator(config.abrEwmaSlowVoD, config.abrEwmaFastVoD, config.abrEwmaDefaultEstimate);\n  }\n  registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.FRAG_LOADING, this.onFragLoading, this);\n    hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);\n    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.on(Events.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this);\n    hls.on(Events.ERROR, this.onError, this);\n  }\n  unregisterListeners() {\n    const {\n      hls\n    } = this;\n    if (!hls) {\n      return;\n    }\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.FRAG_LOADING, this.onFragLoading, this);\n    hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);\n    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.off(Events.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this);\n    hls.off(Events.ERROR, this.onError, this);\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.clearTimer();\n    // @ts-ignore\n    this.hls = this._abandonRulesCheck = this.supportedCache = null;\n    this.fragCurrent = this.partCurrent = null;\n  }\n  onManifestLoading(event, data) {\n    this.lastLoadedFragLevel = -1;\n    this.firstSelection = -1;\n    this.lastLevelLoadSec = 0;\n    this.supportedCache = {};\n    this.fragCurrent = this.partCurrent = null;\n    this.onLevelsUpdated();\n    this.clearTimer();\n  }\n  onLevelsUpdated() {\n    if (this.lastLoadedFragLevel > -1 && this.fragCurrent) {\n      this.lastLoadedFragLevel = this.fragCurrent.level;\n    }\n    this._nextAutoLevel = -1;\n    this.onMaxAutoLevelUpdated();\n    this.codecTiers = null;\n    this.audioTracksByGroup = null;\n  }\n  onMaxAutoLevelUpdated() {\n    this.firstSelection = -1;\n    this.nextAutoLevelKey = '';\n  }\n  onFragLoading(event, data) {\n    const frag = data.frag;\n    if (this.ignoreFragment(frag)) {\n      return;\n    }\n    if (!frag.bitrateTest) {\n      var _data$part;\n      this.fragCurrent = frag;\n      this.partCurrent = (_data$part = data.part) != null ? _data$part : null;\n    }\n    this.clearTimer();\n    this.timer = self.setInterval(this._abandonRulesCheck, 100);\n  }\n  onLevelSwitching(event, data) {\n    this.clearTimer();\n  }\n  onError(event, data) {\n    if (data.fatal) {\n      return;\n    }\n    switch (data.details) {\n      case ErrorDetails.BUFFER_ADD_CODEC_ERROR:\n      case ErrorDetails.BUFFER_APPEND_ERROR:\n        // Reset last loaded level so that a new selection can be made after calling recoverMediaError\n        this.lastLoadedFragLevel = -1;\n        this.firstSelection = -1;\n        break;\n      case ErrorDetails.FRAG_LOAD_TIMEOUT:\n        {\n          const frag = data.frag;\n          const {\n            fragCurrent,\n            partCurrent: part\n          } = this;\n          if (frag && fragCurrent && frag.sn === fragCurrent.sn && frag.level === fragCurrent.level) {\n            const now = performance.now();\n            const stats = part ? part.stats : frag.stats;\n            const timeLoading = now - stats.loading.start;\n            const ttfb = stats.loading.first ? stats.loading.first - stats.loading.start : -1;\n            const loadedFirstByte = stats.loaded && ttfb > -1;\n            if (loadedFirstByte) {\n              const ttfbEstimate = this.bwEstimator.getEstimateTTFB();\n              this.bwEstimator.sample(timeLoading - Math.min(ttfbEstimate, ttfb), stats.loaded);\n            } else {\n              this.bwEstimator.sampleTTFB(timeLoading);\n            }\n          }\n          break;\n        }\n    }\n  }\n  getTimeToLoadFrag(timeToFirstByteSec, bandwidth, fragSizeBits, isSwitch) {\n    const fragLoadSec = timeToFirstByteSec + fragSizeBits / bandwidth;\n    const playlistLoadSec = isSwitch ? timeToFirstByteSec + this.lastLevelLoadSec : 0;\n    return fragLoadSec + playlistLoadSec;\n  }\n  onLevelLoaded(event, data) {\n    const config = this.hls.config;\n    const {\n      loading\n    } = data.stats;\n    const timeLoadingMs = loading.end - loading.first;\n    if (isFiniteNumber(timeLoadingMs)) {\n      this.lastLevelLoadSec = timeLoadingMs / 1000;\n    }\n    if (data.details.live) {\n      this.bwEstimator.update(config.abrEwmaSlowLive, config.abrEwmaFastLive);\n    } else {\n      this.bwEstimator.update(config.abrEwmaSlowVoD, config.abrEwmaFastVoD);\n    }\n    if (this.timer > -1) {\n      this._abandonRulesCheck(data.levelInfo);\n    }\n  }\n  onFragLoaded(event, {\n    frag,\n    part\n  }) {\n    const stats = part ? part.stats : frag.stats;\n    if (frag.type === PlaylistLevelType.MAIN) {\n      this.bwEstimator.sampleTTFB(stats.loading.first - stats.loading.start);\n    }\n    if (this.ignoreFragment(frag)) {\n      return;\n    }\n    // stop monitoring bw once frag loaded\n    this.clearTimer();\n    // reset forced auto level value so that next level will be selected\n    if (frag.level === this._nextAutoLevel) {\n      this._nextAutoLevel = -1;\n    }\n    this.firstSelection = -1;\n\n    // compute level average bitrate\n    if (this.hls.config.abrMaxWithRealBitrate) {\n      const duration = part ? part.duration : frag.duration;\n      const level = this.hls.levels[frag.level];\n      const loadedBytes = (level.loaded ? level.loaded.bytes : 0) + stats.loaded;\n      const loadedDuration = (level.loaded ? level.loaded.duration : 0) + duration;\n      level.loaded = {\n        bytes: loadedBytes,\n        duration: loadedDuration\n      };\n      level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);\n    }\n    if (frag.bitrateTest) {\n      const fragBufferedData = {\n        stats,\n        frag,\n        part,\n        id: frag.type\n      };\n      this.onFragBuffered(Events.FRAG_BUFFERED, fragBufferedData);\n      frag.bitrateTest = false;\n    } else {\n      // store level id after successful fragment load for playback\n      this.lastLoadedFragLevel = frag.level;\n    }\n  }\n  onFragBuffered(event, data) {\n    const {\n      frag,\n      part\n    } = data;\n    const stats = part != null && part.stats.loaded ? part.stats : frag.stats;\n    if (stats.aborted) {\n      return;\n    }\n    if (this.ignoreFragment(frag)) {\n      return;\n    }\n    // Use the difference between parsing and request instead of buffering and request to compute fragLoadingProcessing;\n    // rationale is that buffer appending only happens once media is attached. This can happen when config.startFragPrefetch\n    // is used. If we used buffering in that case, our BW estimate sample will be very large.\n    const processingMs = stats.parsing.end - stats.loading.start - Math.min(stats.loading.first - stats.loading.start, this.bwEstimator.getEstimateTTFB());\n    this.bwEstimator.sample(processingMs, stats.loaded);\n    stats.bwEstimate = this.getBwEstimate();\n    if (frag.bitrateTest) {\n      this.bitrateTestDelay = processingMs / 1000;\n    } else {\n      this.bitrateTestDelay = 0;\n    }\n  }\n  ignoreFragment(frag) {\n    // Only count non-alt-audio frags which were actually buffered in our BW calculations\n    return frag.type !== PlaylistLevelType.MAIN || frag.sn === 'initSegment';\n  }\n  clearTimer() {\n    if (this.timer > -1) {\n      self.clearInterval(this.timer);\n      this.timer = -1;\n    }\n  }\n  get firstAutoLevel() {\n    const {\n      maxAutoLevel,\n      minAutoLevel\n    } = this.hls;\n    const bwEstimate = this.getBwEstimate();\n    const maxStartDelay = this.hls.config.maxStarvationDelay;\n    const abrAutoLevel = this.findBestLevel(bwEstimate, minAutoLevel, maxAutoLevel, 0, maxStartDelay, 1, 1);\n    if (abrAutoLevel > -1) {\n      return abrAutoLevel;\n    }\n    const firstLevel = this.hls.firstLevel;\n    const clamped = Math.min(Math.max(firstLevel, minAutoLevel), maxAutoLevel);\n    this.warn(`Could not find best starting auto level. Defaulting to first in playlist ${firstLevel} clamped to ${clamped}`);\n    return clamped;\n  }\n  get forcedAutoLevel() {\n    if (this.nextAutoLevelKey) {\n      return -1;\n    }\n    return this._nextAutoLevel;\n  }\n\n  // return next auto level\n  get nextAutoLevel() {\n    const forcedAutoLevel = this.forcedAutoLevel;\n    const bwEstimator = this.bwEstimator;\n    const useEstimate = bwEstimator.canEstimate();\n    const loadedFirstFrag = this.lastLoadedFragLevel > -1;\n    // in case next auto level has been forced, and bw not available or not reliable, return forced value\n    if (forcedAutoLevel !== -1 && (!useEstimate || !loadedFirstFrag || this.nextAutoLevelKey === this.getAutoLevelKey())) {\n      return forcedAutoLevel;\n    }\n\n    // compute next level using ABR logic\n    const nextABRAutoLevel = useEstimate && loadedFirstFrag ? this.getNextABRAutoLevel() : this.firstAutoLevel;\n\n    // use forced auto level while it hasn't errored more than ABR selection\n    if (forcedAutoLevel !== -1) {\n      const levels = this.hls.levels;\n      if (levels.length > Math.max(forcedAutoLevel, nextABRAutoLevel) && levels[forcedAutoLevel].loadError <= levels[nextABRAutoLevel].loadError) {\n        return forcedAutoLevel;\n      }\n    }\n\n    // save result until state has changed\n    this._nextAutoLevel = nextABRAutoLevel;\n    this.nextAutoLevelKey = this.getAutoLevelKey();\n    return nextABRAutoLevel;\n  }\n  getAutoLevelKey() {\n    return `${this.getBwEstimate()}_${this.getStarvationDelay().toFixed(2)}`;\n  }\n  getNextABRAutoLevel() {\n    const {\n      fragCurrent,\n      partCurrent,\n      hls\n    } = this;\n    if (hls.levels.length <= 1) {\n      return hls.loadLevel;\n    }\n    const {\n      maxAutoLevel,\n      config,\n      minAutoLevel\n    } = hls;\n    const currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;\n    const avgbw = this.getBwEstimate();\n    // bufferStarvationDelay is the wall-clock time left until the playback buffer is exhausted.\n    const bufferStarvationDelay = this.getStarvationDelay();\n    let bwFactor = config.abrBandWidthFactor;\n    let bwUpFactor = config.abrBandWidthUpFactor;\n\n    // First, look to see if we can find a level matching with our avg bandwidth AND that could also guarantee no rebuffering at all\n    if (bufferStarvationDelay) {\n      const _bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, 0, bwFactor, bwUpFactor);\n      if (_bestLevel >= 0) {\n        this.rebufferNotice = -1;\n        return _bestLevel;\n      }\n    }\n    // not possible to get rid of rebuffering... try to find level that will guarantee less than maxStarvationDelay of rebuffering\n    let maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay;\n    if (!bufferStarvationDelay) {\n      // in case buffer is empty, let's check if previous fragment was loaded to perform a bitrate test\n      const bitrateTestDelay = this.bitrateTestDelay;\n      if (bitrateTestDelay) {\n        // if it is the case, then we need to adjust our max starvation delay using maxLoadingDelay config value\n        // max video loading delay used in  automatic start level selection :\n        // in that mode ABR controller will ensure that video loading time (ie the time to fetch the first fragment at lowest quality level +\n        // the time to fetch the fragment at the appropriate quality level is less than ```maxLoadingDelay``` )\n        // cap maxLoadingDelay and ensure it is not bigger 'than bitrate test' frag duration\n        const maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;\n        maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;\n        this.info(`bitrate test took ${Math.round(1000 * bitrateTestDelay)}ms, set first fragment max fetchDuration to ${Math.round(1000 * maxStarvationDelay)} ms`);\n        // don't use conservative factor on bitrate test\n        bwFactor = bwUpFactor = 1;\n      }\n    }\n    const bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, maxStarvationDelay, bwFactor, bwUpFactor);\n    if (this.rebufferNotice !== bestLevel) {\n      this.rebufferNotice = bestLevel;\n      this.info(`${bufferStarvationDelay ? 'rebuffering expected' : 'buffer is empty'}, optimal quality level ${bestLevel}`);\n    }\n    if (bestLevel > -1) {\n      return bestLevel;\n    }\n    // If no matching level found, see if min auto level would be a better option\n    const minLevel = hls.levels[minAutoLevel];\n    const autoLevel = hls.loadLevelObj;\n    if (autoLevel && (minLevel == null ? void 0 : minLevel.bitrate) < autoLevel.bitrate) {\n      return minAutoLevel;\n    }\n    // or if bitrate is not lower, continue to use loadLevel\n    return hls.loadLevel;\n  }\n  getStarvationDelay() {\n    const hls = this.hls;\n    const media = hls.media;\n    if (!media) {\n      return Infinity;\n    }\n    // playbackRate is the absolute value of the playback rate; if media.playbackRate is 0, we use 1 to load as\n    // if we're playing back at the normal rate.\n    const playbackRate = media && media.playbackRate !== 0 ? Math.abs(media.playbackRate) : 1.0;\n    const bufferInfo = hls.mainForwardBufferInfo;\n    return (bufferInfo ? bufferInfo.len : 0) / playbackRate;\n  }\n  getBwEstimate() {\n    return this.bwEstimator.canEstimate() ? this.bwEstimator.getEstimate() : this.hls.config.abrEwmaDefaultEstimate;\n  }\n  findBestLevel(currentBw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, maxStarvationDelay, bwFactor, bwUpFactor) {\n    var _this$hls$latestLevel;\n    const maxFetchDuration = bufferStarvationDelay + maxStarvationDelay;\n    const lastLoadedFragLevel = this.lastLoadedFragLevel;\n    const selectionBaseLevel = lastLoadedFragLevel === -1 ? this.hls.firstLevel : lastLoadedFragLevel;\n    const {\n      fragCurrent,\n      partCurrent\n    } = this;\n    const {\n      levels,\n      allAudioTracks,\n      loadLevel,\n      config\n    } = this.hls;\n    if (levels.length === 1) {\n      return 0;\n    }\n    const level = levels[selectionBaseLevel];\n    const live = !!((_this$hls$latestLevel = this.hls.latestLevelDetails) != null && _this$hls$latestLevel.live);\n    const firstSelection = loadLevel === -1 || lastLoadedFragLevel === -1;\n    let currentCodecSet;\n    let currentVideoRange = 'SDR';\n    let currentFrameRate = (level == null ? void 0 : level.frameRate) || 0;\n    const {\n      audioPreference,\n      videoPreference\n    } = config;\n    const audioTracksByGroup = this.audioTracksByGroup || (this.audioTracksByGroup = getAudioTracksByGroup(allAudioTracks));\n    let minStartIndex = -1;\n    if (firstSelection) {\n      if (this.firstSelection !== -1) {\n        return this.firstSelection;\n      }\n      const codecTiers = this.codecTiers || (this.codecTiers = getCodecTiers(levels, audioTracksByGroup, minAutoLevel, maxAutoLevel));\n      const startTier = getStartCodecTier(codecTiers, currentVideoRange, currentBw, audioPreference, videoPreference);\n      const {\n        codecSet,\n        videoRanges,\n        minFramerate,\n        minBitrate,\n        minIndex,\n        preferHDR\n      } = startTier;\n      minStartIndex = minIndex;\n      currentCodecSet = codecSet;\n      currentVideoRange = preferHDR ? videoRanges[videoRanges.length - 1] : videoRanges[0];\n      currentFrameRate = minFramerate;\n      currentBw = Math.max(currentBw, minBitrate);\n      this.log(`picked start tier ${stringify(startTier)}`);\n    } else {\n      currentCodecSet = level == null ? void 0 : level.codecSet;\n      currentVideoRange = level == null ? void 0 : level.videoRange;\n    }\n    const currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;\n    const ttfbEstimateSec = this.bwEstimator.getEstimateTTFB() / 1000;\n    const levelsSkipped = [];\n    for (let i = maxAutoLevel; i >= minAutoLevel; i--) {\n      var _levelInfo$supportedR, _levelInfo$supportedR2;\n      const levelInfo = levels[i];\n      const upSwitch = i > selectionBaseLevel;\n      if (!levelInfo) {\n        continue;\n      }\n      if (config.useMediaCapabilities && !levelInfo.supportedResult && !levelInfo.supportedPromise) {\n        const mediaCapabilities = navigator.mediaCapabilities;\n        if (typeof (mediaCapabilities == null ? void 0 : mediaCapabilities.decodingInfo) === 'function' && requiresMediaCapabilitiesDecodingInfo(levelInfo, audioTracksByGroup, currentVideoRange, currentFrameRate, currentBw, audioPreference)) {\n          levelInfo.supportedPromise = getMediaDecodingInfoPromise(levelInfo, audioTracksByGroup, mediaCapabilities, this.supportedCache);\n          levelInfo.supportedPromise.then(decodingInfo => {\n            if (!this.hls) {\n              return;\n            }\n            levelInfo.supportedResult = decodingInfo;\n            const levels = this.hls.levels;\n            const index = levels.indexOf(levelInfo);\n            if (decodingInfo.error) {\n              this.warn(`MediaCapabilities decodingInfo error: \"${decodingInfo.error}\" for level ${index} ${stringify(decodingInfo)}`);\n            } else if (!decodingInfo.supported) {\n              this.warn(`Unsupported MediaCapabilities decodingInfo result for level ${index} ${stringify(decodingInfo)}`);\n              if (index > -1 && levels.length > 1) {\n                this.log(`Removing unsupported level ${index}`);\n                this.hls.removeLevel(index);\n                if (this.hls.loadLevel === -1) {\n                  this.hls.nextLoadLevel = 0;\n                }\n              }\n            } else if (decodingInfo.decodingInfoResults.some(info => info.smooth === false || info.powerEfficient === false)) {\n              this.log(`MediaCapabilities decodingInfo for level ${index} not smooth or powerEfficient: ${stringify(decodingInfo)}`);\n            }\n          });\n        } else {\n          levelInfo.supportedResult = SUPPORTED_INFO_DEFAULT;\n        }\n      }\n\n      // skip candidates which change codec-family or video-range,\n      // and which decrease or increase frame-rate for up and down-switch respectfully\n      if (currentCodecSet && levelInfo.codecSet !== currentCodecSet || currentVideoRange && levelInfo.videoRange !== currentVideoRange || upSwitch && currentFrameRate > levelInfo.frameRate || !upSwitch && currentFrameRate > 0 && currentFrameRate < levelInfo.frameRate || (_levelInfo$supportedR = levelInfo.supportedResult) != null && (_levelInfo$supportedR2 = _levelInfo$supportedR.decodingInfoResults) != null && _levelInfo$supportedR2.some(info => info.smooth === false)) {\n        if (!firstSelection || i !== minStartIndex) {\n          levelsSkipped.push(i);\n          continue;\n        }\n      }\n      const levelDetails = levelInfo.details;\n      const avgDuration = (partCurrent ? levelDetails == null ? void 0 : levelDetails.partTarget : levelDetails == null ? void 0 : levelDetails.averagetargetduration) || currentFragDuration;\n      let adjustedbw;\n      // follow algorithm captured from stagefright :\n      // https://android.googlesource.com/platform/frameworks/av/+/master/media/libstagefright/httplive/LiveSession.cpp\n      // Pick the highest bandwidth stream below or equal to estimated bandwidth.\n      // consider only 80% of the available bandwidth, but if we are switching up,\n      // be even more conservative (70%) to avoid overestimating and immediately\n      // switching back.\n      if (!upSwitch) {\n        adjustedbw = bwFactor * currentBw;\n      } else {\n        adjustedbw = bwUpFactor * currentBw;\n      }\n\n      // Use average bitrate when starvation delay (buffer length) is gt or eq two segment durations and rebuffering is not expected (maxStarvationDelay > 0)\n      const bitrate = currentFragDuration && bufferStarvationDelay >= currentFragDuration * 2 && maxStarvationDelay === 0 ? levelInfo.averageBitrate : levelInfo.maxBitrate;\n      const fetchDuration = this.getTimeToLoadFrag(ttfbEstimateSec, adjustedbw, bitrate * avgDuration, levelDetails === undefined);\n      const canSwitchWithinTolerance =\n      // if adjusted bw is greater than level bitrate AND\n      adjustedbw >= bitrate && (\n      // no level change, or new level has no error history\n      i === lastLoadedFragLevel || levelInfo.loadError === 0 && levelInfo.fragmentError === 0) && (\n      // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches\n      // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...\n      // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that findBestLevel will return -1\n      fetchDuration <= ttfbEstimateSec || !isFiniteNumber(fetchDuration) || live && !this.bitrateTestDelay || fetchDuration < maxFetchDuration);\n      if (canSwitchWithinTolerance) {\n        const forcedAutoLevel = this.forcedAutoLevel;\n        if (i !== loadLevel && (forcedAutoLevel === -1 || forcedAutoLevel !== loadLevel)) {\n          if (levelsSkipped.length) {\n            this.trace(`Skipped level(s) ${levelsSkipped.join(',')} of ${maxAutoLevel} max with CODECS and VIDEO-RANGE:\"${levels[levelsSkipped[0]].codecs}\" ${levels[levelsSkipped[0]].videoRange}; not compatible with \"${currentCodecSet}\" ${currentVideoRange}`);\n          }\n          this.info(`switch candidate:${selectionBaseLevel}->${i} adjustedbw(${Math.round(adjustedbw)})-bitrate=${Math.round(adjustedbw - bitrate)} ttfb:${ttfbEstimateSec.toFixed(1)} avgDuration:${avgDuration.toFixed(1)} maxFetchDuration:${maxFetchDuration.toFixed(1)} fetchDuration:${fetchDuration.toFixed(1)} firstSelection:${firstSelection} codecSet:${levelInfo.codecSet} videoRange:${levelInfo.videoRange} hls.loadLevel:${loadLevel}`);\n        }\n        if (firstSelection) {\n          this.firstSelection = i;\n        }\n        // as we are looping from highest to lowest, this will return the best achievable quality level\n        return i;\n      }\n    }\n    // not enough time budget even with quality level 0 ... rebuffering might happen\n    return -1;\n  }\n  set nextAutoLevel(nextLevel) {\n    const value = this.deriveNextAutoLevel(nextLevel);\n    if (this._nextAutoLevel !== value) {\n      this.nextAutoLevelKey = '';\n      this._nextAutoLevel = value;\n    }\n  }\n  deriveNextAutoLevel(nextLevel) {\n    const {\n      maxAutoLevel,\n      minAutoLevel\n    } = this.hls;\n    return Math.min(Math.max(nextLevel, minAutoLevel), maxAutoLevel);\n  }\n}\n\nconst BinarySearch = {\n  /**\n   * Searches for an item in an array which matches a certain condition.\n   * This requires the condition to only match one item in the array,\n   * and for the array to be ordered.\n   *\n   * @param list The array to search.\n   * @param comparisonFn\n   *      Called and provided a candidate item as the first argument.\n   *      Should return:\n   *          > -1 if the item should be located at a lower index than the provided item.\n   *          > 1 if the item should be located at a higher index than the provided item.\n   *          > 0 if the item is the item you're looking for.\n   *\n   * @returns the object if found, otherwise returns null\n   */\n  search: function (list, comparisonFn) {\n    let minIndex = 0;\n    let maxIndex = list.length - 1;\n    let currentIndex = null;\n    let currentElement = null;\n    while (minIndex <= maxIndex) {\n      currentIndex = (minIndex + maxIndex) / 2 | 0;\n      currentElement = list[currentIndex];\n      const comparisonResult = comparisonFn(currentElement);\n      if (comparisonResult > 0) {\n        minIndex = currentIndex + 1;\n      } else if (comparisonResult < 0) {\n        maxIndex = currentIndex - 1;\n      } else {\n        return currentElement;\n      }\n    }\n    return null;\n  }\n};\n\n/**\n * Returns first fragment whose endPdt value exceeds the given PDT, or null.\n * @param fragments - The array of candidate fragments\n * @param PDTValue - The PDT value which must be exceeded\n * @param maxFragLookUpTolerance - The amount of time that a fragment's start/end can be within in order to be considered contiguous\n */\nfunction findFragmentByPDT(fragments, PDTValue, maxFragLookUpTolerance) {\n  if (PDTValue === null || !Array.isArray(fragments) || !fragments.length || !isFiniteNumber(PDTValue)) {\n    return null;\n  }\n\n  // if less than start\n  const startPDT = fragments[0].programDateTime;\n  if (PDTValue < (startPDT || 0)) {\n    return null;\n  }\n  const endPDT = fragments[fragments.length - 1].endProgramDateTime;\n  if (PDTValue >= (endPDT || 0)) {\n    return null;\n  }\n  for (let seg = 0; seg < fragments.length; ++seg) {\n    const frag = fragments[seg];\n    if (pdtWithinToleranceTest(PDTValue, maxFragLookUpTolerance, frag)) {\n      return frag;\n    }\n  }\n  return null;\n}\n\n/**\n * Finds a fragment based on the SN of the previous fragment; or based on the needs of the current buffer.\n * This method compensates for small buffer gaps by applying a tolerance to the start of any candidate fragment, thus\n * breaking any traps which would cause the same fragment to be continuously selected within a small range.\n * @param fragPrevious - The last frag successfully appended\n * @param fragments - The array of candidate fragments\n * @param bufferEnd - The end of the contiguous buffered range the playhead is currently within\n * @param maxFragLookUpTolerance - The amount of time that a fragment's start/end can be within in order to be considered contiguous\n * @returns a matching fragment or null\n */\nfunction findFragmentByPTS(fragPrevious, fragments, bufferEnd = 0, maxFragLookUpTolerance = 0, nextFragLookupTolerance = 0.005) {\n  let fragNext = null;\n  if (fragPrevious) {\n    fragNext = fragments[1 + fragPrevious.sn - fragments[0].sn] || null;\n    // check for buffer-end rounding error\n    const bufferEdgeError = fragPrevious.endDTS - bufferEnd;\n    if (bufferEdgeError > 0 && bufferEdgeError < 0.0000015) {\n      bufferEnd += 0.0000015;\n    }\n    if (fragNext && fragPrevious.level !== fragNext.level && fragNext.end <= fragPrevious.end) {\n      fragNext = fragments[2 + fragPrevious.sn - fragments[0].sn] || null;\n    }\n  } else if (bufferEnd === 0 && fragments[0].start === 0) {\n    fragNext = fragments[0];\n  }\n  // Prefer the next fragment if it's within tolerance\n  if (fragNext && ((!fragPrevious || fragPrevious.level === fragNext.level) && fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, fragNext) === 0 || fragmentWithinFastStartSwitch(fragNext, fragPrevious, Math.min(nextFragLookupTolerance, maxFragLookUpTolerance)))) {\n    return fragNext;\n  }\n  // We might be seeking past the tolerance so find the best match\n  const foundFragment = BinarySearch.search(fragments, fragmentWithinToleranceTest.bind(null, bufferEnd, maxFragLookUpTolerance));\n  if (foundFragment && (foundFragment !== fragPrevious || !fragNext)) {\n    return foundFragment;\n  }\n  // If no match was found return the next fragment after fragPrevious, or null\n  return fragNext;\n}\nfunction fragmentWithinFastStartSwitch(fragNext, fragPrevious, nextFragLookupTolerance) {\n  if (fragPrevious && fragPrevious.start === 0 && fragPrevious.level < fragNext.level && (fragPrevious.endPTS || 0) > 0) {\n    const firstDuration = fragPrevious.tagList.reduce((duration, tag) => {\n      if (tag[0] === 'INF') {\n        duration += parseFloat(tag[1]);\n      }\n      return duration;\n    }, nextFragLookupTolerance);\n    return fragNext.start <= firstDuration;\n  }\n  return false;\n}\n\n/**\n * The test function used by the findFragmentBySn's BinarySearch to look for the best match to the current buffer conditions.\n * @param candidate - The fragment to test\n * @param bufferEnd - The end of the current buffered range the playhead is currently within\n * @param maxFragLookUpTolerance - The amount of time that a fragment's start can be within in order to be considered contiguous\n * @returns 0 if it matches, 1 if too low, -1 if too high\n */\nfunction fragmentWithinToleranceTest(bufferEnd = 0, maxFragLookUpTolerance = 0, candidate) {\n  // eagerly accept an accurate match (no tolerance)\n  if (candidate.start <= bufferEnd && candidate.start + candidate.duration > bufferEnd) {\n    return 0;\n  }\n  // offset should be within fragment boundary - config.maxFragLookUpTolerance\n  // this is to cope with situations like\n  // bufferEnd = 9.991\n  // frag[] : [0,10]\n  // frag[1] : [10,20]\n  // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here\n  //              frag start               frag start+duration\n  //                  |-----------------------------|\n  //              <--->                         <--->\n  //  ...--------><-----------------------------><---------....\n  // previous frag         matching fragment         next frag\n  //  return -1             return 0                 return 1\n  // logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);\n  // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments\n  const candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0));\n  if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {\n    return 1;\n  } else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {\n    // if maxFragLookUpTolerance will have negative value then don't return -1 for first element\n    return -1;\n  }\n  return 0;\n}\n\n/**\n * The test function used by the findFragmentByPdt's BinarySearch to look for the best match to the current buffer conditions.\n * This function tests the candidate's program date time values, as represented in Unix time\n * @param candidate - The fragment to test\n * @param pdtBufferEnd - The Unix time representing the end of the current buffered range\n * @param maxFragLookUpTolerance - The amount of time that a fragment's start can be within in order to be considered contiguous\n * @returns true if contiguous, false otherwise\n */\nfunction pdtWithinToleranceTest(pdtBufferEnd, maxFragLookUpTolerance, candidate) {\n  const candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0)) * 1000;\n\n  // endProgramDateTime can be null, default to zero\n  const endProgramDateTime = candidate.endProgramDateTime || 0;\n  return endProgramDateTime - candidateLookupTolerance > pdtBufferEnd;\n}\nfunction findNearestWithCC(details, cc, pos) {\n  if (details) {\n    if (details.startCC <= cc && details.endCC >= cc) {\n      let fragments = details.fragments;\n      const {\n        fragmentHint\n      } = details;\n      if (fragmentHint) {\n        fragments = fragments.concat(fragmentHint);\n      }\n      let closest;\n      BinarySearch.search(fragments, candidate => {\n        if (candidate.cc < cc) {\n          return 1;\n        }\n        if (candidate.cc > cc) {\n          return -1;\n        }\n        closest = candidate;\n        if (candidate.end <= pos) {\n          return 1;\n        }\n        if (candidate.start > pos) {\n          return -1;\n        }\n        return 0;\n      });\n      return closest || null;\n    }\n  }\n  return null;\n}\n\nfunction isTimeoutError(error) {\n  switch (error.details) {\n    case ErrorDetails.FRAG_LOAD_TIMEOUT:\n    case ErrorDetails.KEY_LOAD_TIMEOUT:\n    case ErrorDetails.LEVEL_LOAD_TIMEOUT:\n    case ErrorDetails.MANIFEST_LOAD_TIMEOUT:\n      return true;\n  }\n  return false;\n}\nfunction getRetryConfig(loadPolicy, error) {\n  const isTimeout = isTimeoutError(error);\n  return loadPolicy.default[`${isTimeout ? 'timeout' : 'error'}Retry`];\n}\nfunction getRetryDelay(retryConfig, retryCount) {\n  // exponential backoff capped to max retry delay\n  const backoffFactor = retryConfig.backoff === 'linear' ? 1 : Math.pow(2, retryCount);\n  return Math.min(backoffFactor * retryConfig.retryDelayMs, retryConfig.maxRetryDelayMs);\n}\nfunction getLoaderConfigWithoutReties(loderConfig) {\n  return _objectSpread2(_objectSpread2({}, loderConfig), {\n    errorRetry: null,\n    timeoutRetry: null\n  });\n}\nfunction shouldRetry(retryConfig, retryCount, isTimeout, loaderResponse) {\n  if (!retryConfig) {\n    return false;\n  }\n  const httpStatus = loaderResponse == null ? void 0 : loaderResponse.code;\n  const retry = retryCount < retryConfig.maxNumRetry && (retryForHttpStatus(httpStatus) || !!isTimeout);\n  return retryConfig.shouldRetry ? retryConfig.shouldRetry(retryConfig, retryCount, isTimeout, loaderResponse, retry) : retry;\n}\nfunction retryForHttpStatus(httpStatus) {\n  // Do not retry on status 4xx, status 0 (CORS error), or undefined (decrypt/gap/parse error)\n  return httpStatus === 0 && navigator.onLine === false || !!httpStatus && (httpStatus < 400 || httpStatus > 499);\n}\n\nvar NetworkErrorAction = {\n  DoNothing: 0,\n  SendEndCallback: 1,\n  SendAlternateToPenaltyBox: 2,\n  RemoveAlternatePermanently: 3,\n  InsertDiscontinuity: 4,\n  RetryRequest: 5\n};\nvar ErrorActionFlags = {\n  None: 0,\n  MoveAllAlternatesMatchingHost: 1,\n  MoveAllAlternatesMatchingHDCP: 2,\n  SwitchToSDR: 4\n};\nclass ErrorController extends Logger {\n  constructor(hls) {\n    super('error-controller', hls.logger);\n    this.hls = void 0;\n    this.playlistError = 0;\n    this.penalizedRenditions = {};\n    this.hls = hls;\n    this.registerListeners();\n  }\n  registerListeners() {\n    const hls = this.hls;\n    hls.on(Events.ERROR, this.onError, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n  }\n  unregisterListeners() {\n    const hls = this.hls;\n    if (!hls) {\n      return;\n    }\n    hls.off(Events.ERROR, this.onError, this);\n    hls.off(Events.ERROR, this.onErrorOut, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n  }\n  destroy() {\n    this.unregisterListeners();\n    // @ts-ignore\n    this.hls = null;\n    this.penalizedRenditions = {};\n  }\n  startLoad(startPosition) {}\n  stopLoad() {\n    this.playlistError = 0;\n  }\n  getVariantLevelIndex(frag) {\n    return (frag == null ? void 0 : frag.type) === PlaylistLevelType.MAIN ? frag.level : this.hls.loadLevel;\n  }\n  onManifestLoading() {\n    this.playlistError = 0;\n    this.penalizedRenditions = {};\n  }\n  onLevelUpdated() {\n    this.playlistError = 0;\n  }\n  onError(event, data) {\n    var _data$frag;\n    if (data.fatal) {\n      return;\n    }\n    const hls = this.hls;\n    const context = data.context;\n    switch (data.details) {\n      case ErrorDetails.FRAG_LOAD_ERROR:\n      case ErrorDetails.FRAG_LOAD_TIMEOUT:\n      case ErrorDetails.KEY_LOAD_ERROR:\n      case ErrorDetails.KEY_LOAD_TIMEOUT:\n        data.errorAction = this.getFragRetryOrSwitchAction(data);\n        return;\n      case ErrorDetails.FRAG_PARSING_ERROR:\n        // ignore empty segment errors marked as gap\n        if ((_data$frag = data.frag) != null && _data$frag.gap) {\n          data.errorAction = createDoNothingErrorAction();\n          return;\n        }\n      // falls through\n      case ErrorDetails.FRAG_GAP:\n      case ErrorDetails.FRAG_DECRYPT_ERROR:\n        {\n          // Switch level if possible, otherwise allow retry count to reach max error retries\n          data.errorAction = this.getFragRetryOrSwitchAction(data);\n          data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;\n          return;\n        }\n      case ErrorDetails.LEVEL_EMPTY_ERROR:\n      case ErrorDetails.LEVEL_PARSING_ERROR:\n        {\n          var _data$context, _data$context$levelDe;\n          // Only retry when empty and live\n          const levelIndex = data.parent === PlaylistLevelType.MAIN ? data.level : hls.loadLevel;\n          if (data.details === ErrorDetails.LEVEL_EMPTY_ERROR && !!((_data$context = data.context) != null && (_data$context$levelDe = _data$context.levelDetails) != null && _data$context$levelDe.live)) {\n            data.errorAction = this.getPlaylistRetryOrSwitchAction(data, levelIndex);\n          } else {\n            // Escalate to fatal if not retrying or switching\n            data.levelRetry = false;\n            data.errorAction = this.getLevelSwitchAction(data, levelIndex);\n          }\n        }\n        return;\n      case ErrorDetails.LEVEL_LOAD_ERROR:\n      case ErrorDetails.LEVEL_LOAD_TIMEOUT:\n        if (typeof (context == null ? void 0 : context.level) === 'number') {\n          data.errorAction = this.getPlaylistRetryOrSwitchAction(data, context.level);\n        }\n        return;\n      case ErrorDetails.AUDIO_TRACK_LOAD_ERROR:\n      case ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:\n      case ErrorDetails.SUBTITLE_LOAD_ERROR:\n      case ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT:\n        if (context) {\n          const level = hls.loadLevelObj;\n          if (level && (context.type === PlaylistContextType.AUDIO_TRACK && level.hasAudioGroup(context.groupId) || context.type === PlaylistContextType.SUBTITLE_TRACK && level.hasSubtitleGroup(context.groupId))) {\n            // Perform Pathway switch or Redundant failover if possible for fastest recovery\n            // otherwise allow playlist retry count to reach max error retries\n            data.errorAction = this.getPlaylistRetryOrSwitchAction(data, hls.loadLevel);\n            data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;\n            data.errorAction.flags = ErrorActionFlags.MoveAllAlternatesMatchingHost;\n            return;\n          }\n        }\n        return;\n      case ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:\n        {\n          const level = hls.loadLevelObj;\n          const restrictedHdcpLevel = level == null ? void 0 : level.attrs['HDCP-LEVEL'];\n          if (restrictedHdcpLevel) {\n            data.errorAction = {\n              action: NetworkErrorAction.SendAlternateToPenaltyBox,\n              flags: ErrorActionFlags.MoveAllAlternatesMatchingHDCP,\n              hdcpLevel: restrictedHdcpLevel\n            };\n          } else {\n            this.keySystemError(data);\n          }\n        }\n        return;\n      case ErrorDetails.BUFFER_ADD_CODEC_ERROR:\n      case ErrorDetails.REMUX_ALLOC_ERROR:\n      case ErrorDetails.BUFFER_APPEND_ERROR:\n        // Buffer-controller can set errorAction when append errors can be ignored or resolved locally\n        if (!data.errorAction) {\n          var _data$level;\n          data.errorAction = this.getLevelSwitchAction(data, (_data$level = data.level) != null ? _data$level : hls.loadLevel);\n        }\n        return;\n      case ErrorDetails.INTERNAL_EXCEPTION:\n      case ErrorDetails.BUFFER_APPENDING_ERROR:\n      case ErrorDetails.BUFFER_FULL_ERROR:\n      case ErrorDetails.LEVEL_SWITCH_ERROR:\n      case ErrorDetails.BUFFER_STALLED_ERROR:\n      case ErrorDetails.BUFFER_SEEK_OVER_HOLE:\n      case ErrorDetails.BUFFER_NUDGE_ON_STALL:\n        data.errorAction = createDoNothingErrorAction();\n        return;\n    }\n    if (data.type === ErrorTypes.KEY_SYSTEM_ERROR) {\n      this.keySystemError(data);\n    }\n  }\n  keySystemError(data) {\n    const levelIndex = this.getVariantLevelIndex(data.frag);\n    // Do not retry level. Escalate to fatal if switching levels fails.\n    data.levelRetry = false;\n    data.errorAction = this.getLevelSwitchAction(data, levelIndex);\n  }\n  getPlaylistRetryOrSwitchAction(data, levelIndex) {\n    const hls = this.hls;\n    const retryConfig = getRetryConfig(hls.config.playlistLoadPolicy, data);\n    const retryCount = this.playlistError++;\n    const retry = shouldRetry(retryConfig, retryCount, isTimeoutError(data), data.response);\n    if (retry) {\n      return {\n        action: NetworkErrorAction.RetryRequest,\n        flags: ErrorActionFlags.None,\n        retryConfig,\n        retryCount\n      };\n    }\n    const errorAction = this.getLevelSwitchAction(data, levelIndex);\n    if (retryConfig) {\n      errorAction.retryConfig = retryConfig;\n      errorAction.retryCount = retryCount;\n    }\n    return errorAction;\n  }\n  getFragRetryOrSwitchAction(data) {\n    const hls = this.hls;\n    // Share fragment error count accross media options (main, audio, subs)\n    // This allows for level based rendition switching when media option assets fail\n    const variantLevelIndex = this.getVariantLevelIndex(data.frag);\n    const level = hls.levels[variantLevelIndex];\n    const {\n      fragLoadPolicy,\n      keyLoadPolicy\n    } = hls.config;\n    const retryConfig = getRetryConfig(data.details.startsWith('key') ? keyLoadPolicy : fragLoadPolicy, data);\n    const fragmentErrors = hls.levels.reduce((acc, level) => acc + level.fragmentError, 0);\n    // Switch levels when out of retried or level index out of bounds\n    if (level) {\n      if (data.details !== ErrorDetails.FRAG_GAP) {\n        level.fragmentError++;\n      }\n      const retry = shouldRetry(retryConfig, fragmentErrors, isTimeoutError(data), data.response);\n      if (retry) {\n        return {\n          action: NetworkErrorAction.RetryRequest,\n          flags: ErrorActionFlags.None,\n          retryConfig,\n          retryCount: fragmentErrors\n        };\n      }\n    }\n    // Reach max retry count, or Missing level reference\n    // Switch to valid index\n    const errorAction = this.getLevelSwitchAction(data, variantLevelIndex);\n    // Add retry details to allow skipping of FRAG_PARSING_ERROR\n    if (retryConfig) {\n      errorAction.retryConfig = retryConfig;\n      errorAction.retryCount = fragmentErrors;\n    }\n    return errorAction;\n  }\n  getLevelSwitchAction(data, levelIndex) {\n    const hls = this.hls;\n    if (levelIndex === null || levelIndex === undefined) {\n      levelIndex = hls.loadLevel;\n    }\n    const level = this.hls.levels[levelIndex];\n    if (level) {\n      var _data$frag2, _data$context2;\n      const errorDetails = data.details;\n      level.loadError++;\n      if (errorDetails === ErrorDetails.BUFFER_APPEND_ERROR) {\n        level.fragmentError++;\n      }\n      // Search for next level to retry\n      let nextLevel = -1;\n      const {\n        levels,\n        loadLevel,\n        minAutoLevel,\n        maxAutoLevel\n      } = hls;\n      if (!hls.autoLevelEnabled && !hls.config.preserveManualLevelOnError) {\n        hls.loadLevel = -1;\n      }\n      const fragErrorType = (_data$frag2 = data.frag) == null ? void 0 : _data$frag2.type;\n      // Find alternate audio codec if available on audio codec error\n      const isAudioCodecError = fragErrorType === PlaylistLevelType.AUDIO && errorDetails === ErrorDetails.FRAG_PARSING_ERROR || data.sourceBufferName === 'audio' && (errorDetails === ErrorDetails.BUFFER_ADD_CODEC_ERROR || errorDetails === ErrorDetails.BUFFER_APPEND_ERROR);\n      const findAudioCodecAlternate = isAudioCodecError && levels.some(({\n        audioCodec\n      }) => level.audioCodec !== audioCodec);\n      // Find alternate video codec if available on video codec error\n      const isVideoCodecError = data.sourceBufferName === 'video' && (errorDetails === ErrorDetails.BUFFER_ADD_CODEC_ERROR || errorDetails === ErrorDetails.BUFFER_APPEND_ERROR);\n      const findVideoCodecAlternate = isVideoCodecError && levels.some(({\n        codecSet,\n        audioCodec\n      }) => level.codecSet !== codecSet && level.audioCodec === audioCodec);\n      const {\n        type: playlistErrorType,\n        groupId: playlistErrorGroupId\n      } = (_data$context2 = data.context) != null ? _data$context2 : {};\n      for (let i = levels.length; i--;) {\n        const candidate = (i + loadLevel) % levels.length;\n        if (candidate !== loadLevel && candidate >= minAutoLevel && candidate <= maxAutoLevel && levels[candidate].loadError === 0) {\n          var _level$audioGroups, _level$subtitleGroups;\n          const levelCandidate = levels[candidate];\n          // Skip level switch if GAP tag is found in next level at same position\n          if (errorDetails === ErrorDetails.FRAG_GAP && fragErrorType === PlaylistLevelType.MAIN && data.frag) {\n            const levelDetails = levels[candidate].details;\n            if (levelDetails) {\n              const fragCandidate = findFragmentByPTS(data.frag, levelDetails.fragments, data.frag.start);\n              if (fragCandidate != null && fragCandidate.gap) {\n                continue;\n              }\n            }\n          } else if (playlistErrorType === PlaylistContextType.AUDIO_TRACK && levelCandidate.hasAudioGroup(playlistErrorGroupId) || playlistErrorType === PlaylistContextType.SUBTITLE_TRACK && levelCandidate.hasSubtitleGroup(playlistErrorGroupId)) {\n            // For audio/subs playlist errors find another group ID or fallthrough to redundant fail-over\n            continue;\n          } else if (fragErrorType === PlaylistLevelType.AUDIO && (_level$audioGroups = level.audioGroups) != null && _level$audioGroups.some(groupId => levelCandidate.hasAudioGroup(groupId)) || fragErrorType === PlaylistLevelType.SUBTITLE && (_level$subtitleGroups = level.subtitleGroups) != null && _level$subtitleGroups.some(groupId => levelCandidate.hasSubtitleGroup(groupId)) || findAudioCodecAlternate && level.audioCodec === levelCandidate.audioCodec || !findAudioCodecAlternate && level.audioCodec !== levelCandidate.audioCodec || findVideoCodecAlternate && level.codecSet === levelCandidate.codecSet) {\n            // For video/audio/subs frag errors find another group ID or fallthrough to redundant fail-over\n            continue;\n          }\n          nextLevel = candidate;\n          break;\n        }\n      }\n      if (nextLevel > -1 && hls.loadLevel !== nextLevel) {\n        data.levelRetry = true;\n        this.playlistError = 0;\n        return {\n          action: NetworkErrorAction.SendAlternateToPenaltyBox,\n          flags: ErrorActionFlags.None,\n          nextAutoLevel: nextLevel\n        };\n      }\n    }\n    // No levels to switch / Manual level selection / Level not found\n    // Resolve with Pathway switch, Redundant fail-over, or stay on lowest Level\n    return {\n      action: NetworkErrorAction.SendAlternateToPenaltyBox,\n      flags: ErrorActionFlags.MoveAllAlternatesMatchingHost\n    };\n  }\n  onErrorOut(event, data) {\n    var _data$errorAction;\n    switch ((_data$errorAction = data.errorAction) == null ? void 0 : _data$errorAction.action) {\n      case NetworkErrorAction.DoNothing:\n        break;\n      case NetworkErrorAction.SendAlternateToPenaltyBox:\n        this.sendAlternateToPenaltyBox(data);\n        if (!data.errorAction.resolved && data.details !== ErrorDetails.FRAG_GAP) {\n          data.fatal = true;\n        } else if (/MediaSource readyState: ended/.test(data.error.message)) {\n          this.warn(`MediaSource ended after \"${data.sourceBufferName}\" sourceBuffer append error. Attempting to recover from media error.`);\n          this.hls.recoverMediaError();\n        }\n        break;\n      case NetworkErrorAction.RetryRequest:\n        // handled by stream and playlist/level controllers\n        break;\n    }\n    if (data.fatal) {\n      this.hls.stopLoad();\n      return;\n    }\n  }\n  sendAlternateToPenaltyBox(data) {\n    const hls = this.hls;\n    const errorAction = data.errorAction;\n    if (!errorAction) {\n      return;\n    }\n    const {\n      flags,\n      hdcpLevel,\n      nextAutoLevel\n    } = errorAction;\n    switch (flags) {\n      case ErrorActionFlags.None:\n        this.switchLevel(data, nextAutoLevel);\n        break;\n      case ErrorActionFlags.MoveAllAlternatesMatchingHDCP:\n        if (hdcpLevel) {\n          hls.maxHdcpLevel = HdcpLevels[HdcpLevels.indexOf(hdcpLevel) - 1];\n          errorAction.resolved = true;\n        }\n        this.warn(`Restricting playback to HDCP-LEVEL of \"${hls.maxHdcpLevel}\" or lower`);\n        break;\n    }\n    // If not resolved by previous actions try to switch to next level\n    if (!errorAction.resolved) {\n      this.switchLevel(data, nextAutoLevel);\n    }\n  }\n  switchLevel(data, levelIndex) {\n    if (levelIndex !== undefined && data.errorAction) {\n      this.warn(`switching to level ${levelIndex} after ${data.details}`);\n      this.hls.nextAutoLevel = levelIndex;\n      data.errorAction.resolved = true;\n      // Stream controller is responsible for this but won't switch on false start\n      this.hls.nextLoadLevel = this.hls.nextAutoLevel;\n      if (data.details === ErrorDetails.BUFFER_ADD_CODEC_ERROR && data.mimeType && data.sourceBufferName !== 'audiovideo') {\n        const codec = getCodecsForMimeType(data.mimeType);\n        const levels = this.hls.levels;\n        for (let i = levels.length; i--;) {\n          if (levels[i][`${data.sourceBufferName}Codec`] === codec) {\n            this.hls.removeLevel(i);\n          }\n        }\n      }\n    }\n  }\n}\nfunction createDoNothingErrorAction(resolved) {\n  const errorAction = {\n    action: NetworkErrorAction.DoNothing,\n    flags: ErrorActionFlags.None\n  };\n  if (resolved) {\n    errorAction.resolved = true;\n  }\n  return errorAction;\n}\n\nvar FragmentState = {\n  NOT_LOADED: \"NOT_LOADED\",\n  APPENDING: \"APPENDING\",\n  PARTIAL: \"PARTIAL\",\n  OK: \"OK\"\n};\nclass FragmentTracker {\n  constructor(hls) {\n    this.activePartLists = Object.create(null);\n    this.endListFragments = Object.create(null);\n    this.fragments = Object.create(null);\n    this.timeRanges = Object.create(null);\n    this.bufferPadding = 0.2;\n    this.hls = void 0;\n    this.hasGaps = false;\n    this.hls = hls;\n    this._registerListeners();\n  }\n  _registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.BUFFER_APPENDED, this.onBufferAppended, this);\n    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);\n  }\n  _unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.BUFFER_APPENDED, this.onBufferAppended, this);\n    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);\n  }\n  destroy() {\n    this._unregisterListeners();\n    // @ts-ignore\n    this.fragments =\n    // @ts-ignore\n    this.activePartLists =\n    // @ts-ignore\n    this.endListFragments = this.timeRanges = null;\n  }\n\n  /**\n   * Return a Fragment or Part with an appended range that matches the position and levelType\n   * Otherwise, return null\n   */\n  getAppendedFrag(position, levelType) {\n    const activeParts = this.activePartLists[levelType];\n    if (activeParts) {\n      for (let i = activeParts.length; i--;) {\n        const activePart = activeParts[i];\n        if (!activePart) {\n          break;\n        }\n        const appendedPTS = activePart.end;\n        if (activePart.start <= position && appendedPTS !== null && position <= appendedPTS) {\n          return activePart;\n        }\n      }\n    }\n    return this.getBufferedFrag(position, levelType);\n  }\n\n  /**\n   * Return a buffered Fragment that matches the position and levelType.\n   * A buffered Fragment is one whose loading, parsing and appending is done (completed or \"partial\" meaning aborted).\n   * If not found any Fragment, return null\n   */\n  getBufferedFrag(position, levelType) {\n    return this.getFragAtPos(position, levelType, true);\n  }\n  getFragAtPos(position, levelType, buffered) {\n    const {\n      fragments\n    } = this;\n    const keys = Object.keys(fragments);\n    for (let i = keys.length; i--;) {\n      const fragmentEntity = fragments[keys[i]];\n      if ((fragmentEntity == null ? void 0 : fragmentEntity.body.type) === levelType && (!buffered || fragmentEntity.buffered)) {\n        const frag = fragmentEntity.body;\n        if (frag.start <= position && position <= frag.end) {\n          return frag;\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Partial fragments effected by coded frame eviction will be removed\n   * The browser will unload parts of the buffer to free up memory for new buffer data\n   * Fragments will need to be reloaded when the buffer is freed up, removing partial fragments will allow them to reload(since there might be parts that are still playable)\n   */\n  detectEvictedFragments(elementaryStream, timeRange, playlistType, appendedPart, removeAppending) {\n    if (this.timeRanges) {\n      this.timeRanges[elementaryStream] = timeRange;\n    }\n    // Check if any flagged fragments have been unloaded\n    // excluding anything newer than appendedPartSn\n    const appendedPartSn = (appendedPart == null ? void 0 : appendedPart.fragment.sn) || -1;\n    Object.keys(this.fragments).forEach(key => {\n      const fragmentEntity = this.fragments[key];\n      if (!fragmentEntity) {\n        return;\n      }\n      if (appendedPartSn >= fragmentEntity.body.sn) {\n        return;\n      }\n      if (!fragmentEntity.buffered && (!fragmentEntity.loaded || removeAppending)) {\n        if (fragmentEntity.body.type === playlistType) {\n          this.removeFragment(fragmentEntity.body);\n        }\n        return;\n      }\n      const esData = fragmentEntity.range[elementaryStream];\n      if (!esData) {\n        return;\n      }\n      if (esData.time.length === 0) {\n        this.removeFragment(fragmentEntity.body);\n        return;\n      }\n      esData.time.some(time => {\n        const isNotBuffered = !this.isTimeBuffered(time.startPTS, time.endPTS, timeRange);\n        if (isNotBuffered) {\n          // Unregister partial fragment as it needs to load again to be reused\n          this.removeFragment(fragmentEntity.body);\n        }\n        return isNotBuffered;\n      });\n    });\n  }\n\n  /**\n   * Checks if the fragment passed in is loaded in the buffer properly\n   * Partially loaded fragments will be registered as a partial fragment\n   */\n  detectPartialFragments(data) {\n    const timeRanges = this.timeRanges;\n    if (!timeRanges || data.frag.sn === 'initSegment') {\n      return;\n    }\n    const frag = data.frag;\n    const fragKey = getFragmentKey(frag);\n    const fragmentEntity = this.fragments[fragKey];\n    if (!fragmentEntity || fragmentEntity.buffered && frag.gap) {\n      return;\n    }\n    const isFragHint = !frag.relurl;\n    Object.keys(timeRanges).forEach(elementaryStream => {\n      const streamInfo = frag.elementaryStreams[elementaryStream];\n      if (!streamInfo) {\n        return;\n      }\n      const timeRange = timeRanges[elementaryStream];\n      const partial = isFragHint || streamInfo.partial === true;\n      fragmentEntity.range[elementaryStream] = this.getBufferedTimes(frag, data.part, partial, timeRange);\n    });\n    fragmentEntity.loaded = null;\n    if (Object.keys(fragmentEntity.range).length) {\n      fragmentEntity.buffered = true;\n      const endList = fragmentEntity.body.endList = frag.endList || fragmentEntity.body.endList;\n      if (endList) {\n        this.endListFragments[fragmentEntity.body.type] = fragmentEntity;\n      }\n      if (!isPartial(fragmentEntity)) {\n        // Remove older fragment parts from lookup after frag is tracked as buffered\n        this.removeParts(frag.sn - 1, frag.type);\n      }\n    } else {\n      // remove fragment if nothing was appended\n      this.removeFragment(fragmentEntity.body);\n    }\n  }\n  removeParts(snToKeep, levelType) {\n    const activeParts = this.activePartLists[levelType];\n    if (!activeParts) {\n      return;\n    }\n    this.activePartLists[levelType] = filterParts(activeParts, part => part.fragment.sn >= snToKeep);\n  }\n  fragBuffered(frag, force) {\n    const fragKey = getFragmentKey(frag);\n    let fragmentEntity = this.fragments[fragKey];\n    if (!fragmentEntity && force) {\n      fragmentEntity = this.fragments[fragKey] = {\n        body: frag,\n        appendedPTS: null,\n        loaded: null,\n        buffered: false,\n        range: Object.create(null)\n      };\n      if (frag.gap) {\n        this.hasGaps = true;\n      }\n    }\n    if (fragmentEntity) {\n      fragmentEntity.loaded = null;\n      fragmentEntity.buffered = true;\n    }\n  }\n  getBufferedTimes(fragment, part, partial, timeRange) {\n    const buffered = {\n      time: [],\n      partial\n    };\n    const startPTS = fragment.start;\n    const endPTS = fragment.end;\n    const minEndPTS = fragment.minEndPTS || endPTS;\n    const maxStartPTS = fragment.maxStartPTS || startPTS;\n    for (let i = 0; i < timeRange.length; i++) {\n      const startTime = timeRange.start(i) - this.bufferPadding;\n      const endTime = timeRange.end(i) + this.bufferPadding;\n      if (maxStartPTS >= startTime && minEndPTS <= endTime) {\n        // Fragment is entirely contained in buffer\n        // No need to check the other timeRange times since it's completely playable\n        buffered.time.push({\n          startPTS: Math.max(startPTS, timeRange.start(i)),\n          endPTS: Math.min(endPTS, timeRange.end(i))\n        });\n        break;\n      } else if (startPTS < endTime && endPTS > startTime) {\n        const start = Math.max(startPTS, timeRange.start(i));\n        const end = Math.min(endPTS, timeRange.end(i));\n        if (end > start) {\n          buffered.partial = true;\n          // Check for intersection with buffer\n          // Get playable sections of the fragment\n          buffered.time.push({\n            startPTS: start,\n            endPTS: end\n          });\n        }\n      } else if (endPTS <= startTime) {\n        // No need to check the rest of the timeRange as it is in order\n        break;\n      }\n    }\n    return buffered;\n  }\n\n  /**\n   * Gets the partial fragment for a certain time\n   */\n  getPartialFragment(time) {\n    let bestFragment = null;\n    let timePadding;\n    let startTime;\n    let endTime;\n    let bestOverlap = 0;\n    const {\n      bufferPadding,\n      fragments\n    } = this;\n    Object.keys(fragments).forEach(key => {\n      const fragmentEntity = fragments[key];\n      if (!fragmentEntity) {\n        return;\n      }\n      if (isPartial(fragmentEntity)) {\n        startTime = fragmentEntity.body.start - bufferPadding;\n        endTime = fragmentEntity.body.end + bufferPadding;\n        if (time >= startTime && time <= endTime) {\n          // Use the fragment that has the most padding from start and end time\n          timePadding = Math.min(time - startTime, endTime - time);\n          if (bestOverlap <= timePadding) {\n            bestFragment = fragmentEntity.body;\n            bestOverlap = timePadding;\n          }\n        }\n      }\n    });\n    return bestFragment;\n  }\n  isEndListAppended(type) {\n    const lastFragmentEntity = this.endListFragments[type];\n    return lastFragmentEntity !== undefined && (lastFragmentEntity.buffered || isPartial(lastFragmentEntity));\n  }\n  getState(fragment) {\n    const fragKey = getFragmentKey(fragment);\n    const fragmentEntity = this.fragments[fragKey];\n    if (fragmentEntity) {\n      if (!fragmentEntity.buffered) {\n        return FragmentState.APPENDING;\n      } else if (isPartial(fragmentEntity)) {\n        return FragmentState.PARTIAL;\n      } else {\n        return FragmentState.OK;\n      }\n    }\n    return FragmentState.NOT_LOADED;\n  }\n  isTimeBuffered(startPTS, endPTS, timeRange) {\n    let startTime;\n    let endTime;\n    for (let i = 0; i < timeRange.length; i++) {\n      startTime = timeRange.start(i) - this.bufferPadding;\n      endTime = timeRange.end(i) + this.bufferPadding;\n      if (startPTS >= startTime && endPTS <= endTime) {\n        return true;\n      }\n      if (endPTS <= startTime) {\n        // No need to check the rest of the timeRange as it is in order\n        return false;\n      }\n    }\n    return false;\n  }\n  onManifestLoading() {\n    this.removeAllFragments();\n  }\n  onFragLoaded(event, data) {\n    // don't track initsegment (for which sn is not a number)\n    // don't track frags used for bitrateTest, they're irrelevant.\n    if (data.frag.sn === 'initSegment' || data.frag.bitrateTest) {\n      return;\n    }\n    const frag = data.frag;\n    // Fragment entity `loaded` FragLoadedData is null when loading parts\n    const loaded = data.part ? null : data;\n    const fragKey = getFragmentKey(frag);\n    this.fragments[fragKey] = {\n      body: frag,\n      appendedPTS: null,\n      loaded,\n      buffered: false,\n      range: Object.create(null)\n    };\n  }\n  onBufferAppended(event, data) {\n    const {\n      frag,\n      part,\n      timeRanges,\n      type\n    } = data;\n    if (frag.sn === 'initSegment') {\n      return;\n    }\n    const playlistType = frag.type;\n    if (part) {\n      let activeParts = this.activePartLists[playlistType];\n      if (!activeParts) {\n        this.activePartLists[playlistType] = activeParts = [];\n      }\n      activeParts.push(part);\n    }\n    // Store the latest timeRanges loaded in the buffer\n    this.timeRanges = timeRanges;\n    const timeRange = timeRanges[type];\n    this.detectEvictedFragments(type, timeRange, playlistType, part);\n  }\n  onFragBuffered(event, data) {\n    this.detectPartialFragments(data);\n  }\n  hasFragment(fragment) {\n    const fragKey = getFragmentKey(fragment);\n    return !!this.fragments[fragKey];\n  }\n  hasFragments(type) {\n    const {\n      fragments\n    } = this;\n    const keys = Object.keys(fragments);\n    if (!type) {\n      return keys.length > 0;\n    }\n    for (let i = keys.length; i--;) {\n      const fragmentEntity = fragments[keys[i]];\n      if ((fragmentEntity == null ? void 0 : fragmentEntity.body.type) === type) {\n        return true;\n      }\n    }\n    return false;\n  }\n  hasParts(type) {\n    var _this$activePartLists;\n    return !!((_this$activePartLists = this.activePartLists[type]) != null && _this$activePartLists.length);\n  }\n  removeFragmentsInRange(start, end, playlistType, withGapOnly, unbufferedOnly) {\n    if (withGapOnly && !this.hasGaps) {\n      return;\n    }\n    Object.keys(this.fragments).forEach(key => {\n      const fragmentEntity = this.fragments[key];\n      if (!fragmentEntity) {\n        return;\n      }\n      const frag = fragmentEntity.body;\n      if (frag.type !== playlistType || withGapOnly && !frag.gap) {\n        return;\n      }\n      if (frag.start < end && frag.end > start && (fragmentEntity.buffered || unbufferedOnly)) {\n        this.removeFragment(frag);\n      }\n    });\n  }\n  removeFragment(fragment) {\n    const fragKey = getFragmentKey(fragment);\n    fragment.clearElementaryStreamInfo();\n    const activeParts = this.activePartLists[fragment.type];\n    if (activeParts) {\n      const snToRemove = fragment.sn;\n      this.activePartLists[fragment.type] = filterParts(activeParts, part => part.fragment.sn !== snToRemove);\n    }\n    delete this.fragments[fragKey];\n    if (fragment.endList) {\n      delete this.endListFragments[fragment.type];\n    }\n  }\n  removeAllFragments() {\n    var _this$hls, _this$hls$latestLevel;\n    this.fragments = Object.create(null);\n    this.endListFragments = Object.create(null);\n    this.activePartLists = Object.create(null);\n    this.hasGaps = false;\n    const partlist = (_this$hls = this.hls) == null ? void 0 : (_this$hls$latestLevel = _this$hls.latestLevelDetails) == null ? void 0 : _this$hls$latestLevel.partList;\n    if (partlist) {\n      partlist.forEach(part => part.clearElementaryStreamInfo());\n    }\n  }\n}\nfunction isPartial(fragmentEntity) {\n  var _fragmentEntity$range, _fragmentEntity$range2, _fragmentEntity$range3;\n  return fragmentEntity.buffered && (fragmentEntity.body.gap || ((_fragmentEntity$range = fragmentEntity.range.video) == null ? void 0 : _fragmentEntity$range.partial) || ((_fragmentEntity$range2 = fragmentEntity.range.audio) == null ? void 0 : _fragmentEntity$range2.partial) || ((_fragmentEntity$range3 = fragmentEntity.range.audiovideo) == null ? void 0 : _fragmentEntity$range3.partial));\n}\nfunction getFragmentKey(fragment) {\n  return `${fragment.type}_${fragment.level}_${fragment.sn}`;\n}\nfunction filterParts(partList, predicate) {\n  return partList.filter(part => {\n    const keep = predicate(part);\n    if (!keep) {\n      part.clearElementaryStreamInfo();\n    }\n    return keep;\n  });\n}\n\nvar DecrypterAesMode = {\n  cbc: 0,\n  ctr: 1\n};\n\nclass AESCrypto {\n  constructor(subtle, iv, aesMode) {\n    this.subtle = void 0;\n    this.aesIV = void 0;\n    this.aesMode = void 0;\n    this.subtle = subtle;\n    this.aesIV = iv;\n    this.aesMode = aesMode;\n  }\n  decrypt(data, key) {\n    switch (this.aesMode) {\n      case DecrypterAesMode.cbc:\n        return this.subtle.decrypt({\n          name: 'AES-CBC',\n          iv: this.aesIV\n        }, key, data);\n      case DecrypterAesMode.ctr:\n        return this.subtle.decrypt({\n          name: 'AES-CTR',\n          counter: this.aesIV,\n          length: 64\n        },\n        //64 : NIST SP800-38A standard suggests that the counter should occupy half of the counter block\n        key, data);\n      default:\n        throw new Error(`[AESCrypto] invalid aes mode ${this.aesMode}`);\n    }\n  }\n}\n\n// PKCS7\nfunction removePadding(array) {\n  const outputBytes = array.byteLength;\n  const paddingBytes = outputBytes && new DataView(array.buffer).getUint8(outputBytes - 1);\n  if (paddingBytes) {\n    return array.slice(0, outputBytes - paddingBytes);\n  }\n  return array;\n}\nclass AESDecryptor {\n  constructor() {\n    this.rcon = [0x0, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\n    this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];\n    this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];\n    this.sBox = new Uint32Array(256);\n    this.invSBox = new Uint32Array(256);\n    this.key = new Uint32Array(0);\n    this.ksRows = 0;\n    this.keySize = 0;\n    this.keySchedule = void 0;\n    this.invKeySchedule = void 0;\n    this.initTable();\n  }\n\n  // Using view.getUint32() also swaps the byte order.\n  uint8ArrayToUint32Array_(arrayBuffer) {\n    const view = new DataView(arrayBuffer);\n    const newArray = new Uint32Array(4);\n    for (let i = 0; i < 4; i++) {\n      newArray[i] = view.getUint32(i * 4);\n    }\n    return newArray;\n  }\n  initTable() {\n    const sBox = this.sBox;\n    const invSBox = this.invSBox;\n    const subMix = this.subMix;\n    const subMix0 = subMix[0];\n    const subMix1 = subMix[1];\n    const subMix2 = subMix[2];\n    const subMix3 = subMix[3];\n    const invSubMix = this.invSubMix;\n    const invSubMix0 = invSubMix[0];\n    const invSubMix1 = invSubMix[1];\n    const invSubMix2 = invSubMix[2];\n    const invSubMix3 = invSubMix[3];\n    const d = new Uint32Array(256);\n    let x = 0;\n    let xi = 0;\n    let i = 0;\n    for (i = 0; i < 256; i++) {\n      if (i < 128) {\n        d[i] = i << 1;\n      } else {\n        d[i] = i << 1 ^ 0x11b;\n      }\n    }\n    for (i = 0; i < 256; i++) {\n      let sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;\n      sx = sx >>> 8 ^ sx & 0xff ^ 0x63;\n      sBox[x] = sx;\n      invSBox[sx] = x;\n\n      // Compute multiplication\n      const x2 = d[x];\n      const x4 = d[x2];\n      const x8 = d[x4];\n\n      // Compute sub/invSub bytes, mix columns tables\n      let t = d[sx] * 0x101 ^ sx * 0x1010100;\n      subMix0[x] = t << 24 | t >>> 8;\n      subMix1[x] = t << 16 | t >>> 16;\n      subMix2[x] = t << 8 | t >>> 24;\n      subMix3[x] = t;\n\n      // Compute inv sub bytes, inv mix columns tables\n      t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;\n      invSubMix0[sx] = t << 24 | t >>> 8;\n      invSubMix1[sx] = t << 16 | t >>> 16;\n      invSubMix2[sx] = t << 8 | t >>> 24;\n      invSubMix3[sx] = t;\n\n      // Compute next counter\n      if (!x) {\n        x = xi = 1;\n      } else {\n        x = x2 ^ d[d[d[x8 ^ x2]]];\n        xi ^= d[d[xi]];\n      }\n    }\n  }\n  expandKey(keyBuffer) {\n    // convert keyBuffer to Uint32Array\n    const key = this.uint8ArrayToUint32Array_(keyBuffer);\n    let sameKey = true;\n    let offset = 0;\n    while (offset < key.length && sameKey) {\n      sameKey = key[offset] === this.key[offset];\n      offset++;\n    }\n    if (sameKey) {\n      return;\n    }\n    this.key = key;\n    const keySize = this.keySize = key.length;\n    if (keySize !== 4 && keySize !== 6 && keySize !== 8) {\n      throw new Error('Invalid aes key size=' + keySize);\n    }\n    const ksRows = this.ksRows = (keySize + 6 + 1) * 4;\n    let ksRow;\n    let invKsRow;\n    const keySchedule = this.keySchedule = new Uint32Array(ksRows);\n    const invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);\n    const sbox = this.sBox;\n    const rcon = this.rcon;\n    const invSubMix = this.invSubMix;\n    const invSubMix0 = invSubMix[0];\n    const invSubMix1 = invSubMix[1];\n    const invSubMix2 = invSubMix[2];\n    const invSubMix3 = invSubMix[3];\n    let prev;\n    let t;\n    for (ksRow = 0; ksRow < ksRows; ksRow++) {\n      if (ksRow < keySize) {\n        prev = keySchedule[ksRow] = key[ksRow];\n        continue;\n      }\n      t = prev;\n      if (ksRow % keySize === 0) {\n        // Rot word\n        t = t << 8 | t >>> 24;\n\n        // Sub word\n        t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];\n\n        // Mix Rcon\n        t ^= rcon[ksRow / keySize | 0] << 24;\n      } else if (keySize > 6 && ksRow % keySize === 4) {\n        // Sub word\n        t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];\n      }\n      keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;\n    }\n    for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {\n      ksRow = ksRows - invKsRow;\n      if (invKsRow & 3) {\n        t = keySchedule[ksRow];\n      } else {\n        t = keySchedule[ksRow - 4];\n      }\n      if (invKsRow < 4 || ksRow <= 4) {\n        invKeySchedule[invKsRow] = t;\n      } else {\n        invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 0xff]] ^ invSubMix2[sbox[t >>> 8 & 0xff]] ^ invSubMix3[sbox[t & 0xff]];\n      }\n      invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;\n    }\n  }\n\n  // Adding this as a method greatly improves performance.\n  networkToHostOrderSwap(word) {\n    return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;\n  }\n  decrypt(inputArrayBuffer, offset, aesIV) {\n    const nRounds = this.keySize + 6;\n    const invKeySchedule = this.invKeySchedule;\n    const invSBOX = this.invSBox;\n    const invSubMix = this.invSubMix;\n    const invSubMix0 = invSubMix[0];\n    const invSubMix1 = invSubMix[1];\n    const invSubMix2 = invSubMix[2];\n    const invSubMix3 = invSubMix[3];\n    const initVector = this.uint8ArrayToUint32Array_(aesIV);\n    let initVector0 = initVector[0];\n    let initVector1 = initVector[1];\n    let initVector2 = initVector[2];\n    let initVector3 = initVector[3];\n    const inputInt32 = new Int32Array(inputArrayBuffer);\n    const outputInt32 = new Int32Array(inputInt32.length);\n    let t0, t1, t2, t3;\n    let s0, s1, s2, s3;\n    let inputWords0, inputWords1, inputWords2, inputWords3;\n    let ksRow, i;\n    const swapWord = this.networkToHostOrderSwap;\n    while (offset < inputInt32.length) {\n      inputWords0 = swapWord(inputInt32[offset]);\n      inputWords1 = swapWord(inputInt32[offset + 1]);\n      inputWords2 = swapWord(inputInt32[offset + 2]);\n      inputWords3 = swapWord(inputInt32[offset + 3]);\n      s0 = inputWords0 ^ invKeySchedule[0];\n      s1 = inputWords3 ^ invKeySchedule[1];\n      s2 = inputWords2 ^ invKeySchedule[2];\n      s3 = inputWords1 ^ invKeySchedule[3];\n      ksRow = 4;\n\n      // Iterate through the rounds of decryption\n      for (i = 1; i < nRounds; i++) {\n        t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 0xff] ^ invSubMix2[s2 >> 8 & 0xff] ^ invSubMix3[s3 & 0xff] ^ invKeySchedule[ksRow];\n        t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 0xff] ^ invSubMix2[s3 >> 8 & 0xff] ^ invSubMix3[s0 & 0xff] ^ invKeySchedule[ksRow + 1];\n        t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 0xff] ^ invSubMix2[s0 >> 8 & 0xff] ^ invSubMix3[s1 & 0xff] ^ invKeySchedule[ksRow + 2];\n        t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 0xff] ^ invSubMix2[s1 >> 8 & 0xff] ^ invSubMix3[s2 & 0xff] ^ invKeySchedule[ksRow + 3];\n        // Update state\n        s0 = t0;\n        s1 = t1;\n        s2 = t2;\n        s3 = t3;\n        ksRow = ksRow + 4;\n      }\n\n      // Shift rows, sub bytes, add round key\n      t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 0xff] << 16 ^ invSBOX[s2 >> 8 & 0xff] << 8 ^ invSBOX[s3 & 0xff] ^ invKeySchedule[ksRow];\n      t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 0xff] << 16 ^ invSBOX[s3 >> 8 & 0xff] << 8 ^ invSBOX[s0 & 0xff] ^ invKeySchedule[ksRow + 1];\n      t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 0xff] << 16 ^ invSBOX[s0 >> 8 & 0xff] << 8 ^ invSBOX[s1 & 0xff] ^ invKeySchedule[ksRow + 2];\n      t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 0xff] << 16 ^ invSBOX[s1 >> 8 & 0xff] << 8 ^ invSBOX[s2 & 0xff] ^ invKeySchedule[ksRow + 3];\n\n      // Write\n      outputInt32[offset] = swapWord(t0 ^ initVector0);\n      outputInt32[offset + 1] = swapWord(t3 ^ initVector1);\n      outputInt32[offset + 2] = swapWord(t2 ^ initVector2);\n      outputInt32[offset + 3] = swapWord(t1 ^ initVector3);\n\n      // reset initVector to last 4 unsigned int\n      initVector0 = inputWords0;\n      initVector1 = inputWords1;\n      initVector2 = inputWords2;\n      initVector3 = inputWords3;\n      offset = offset + 4;\n    }\n    return outputInt32.buffer;\n  }\n}\n\nclass FastAESKey {\n  constructor(subtle, key, aesMode) {\n    this.subtle = void 0;\n    this.key = void 0;\n    this.aesMode = void 0;\n    this.subtle = subtle;\n    this.key = key;\n    this.aesMode = aesMode;\n  }\n  expandKey() {\n    const subtleAlgoName = getSubtleAlgoName(this.aesMode);\n    return this.subtle.importKey('raw', this.key, {\n      name: subtleAlgoName\n    }, false, ['encrypt', 'decrypt']);\n  }\n}\nfunction getSubtleAlgoName(aesMode) {\n  switch (aesMode) {\n    case DecrypterAesMode.cbc:\n      return 'AES-CBC';\n    case DecrypterAesMode.ctr:\n      return 'AES-CTR';\n    default:\n      throw new Error(`[FastAESKey] invalid aes mode ${aesMode}`);\n  }\n}\n\nconst CHUNK_SIZE = 16; // 16 bytes, 128 bits\n\nclass Decrypter {\n  constructor(config, {\n    removePKCS7Padding = true\n  } = {}) {\n    this.logEnabled = true;\n    this.removePKCS7Padding = void 0;\n    this.subtle = null;\n    this.softwareDecrypter = null;\n    this.key = null;\n    this.fastAesKey = null;\n    this.remainderData = null;\n    this.currentIV = null;\n    this.currentResult = null;\n    this.useSoftware = void 0;\n    this.enableSoftwareAES = void 0;\n    this.enableSoftwareAES = config.enableSoftwareAES;\n    this.removePKCS7Padding = removePKCS7Padding;\n    // built in decryptor expects PKCS7 padding\n    if (removePKCS7Padding) {\n      try {\n        const browserCrypto = self.crypto;\n        if (browserCrypto) {\n          this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\n        }\n      } catch (e) {\n        /* no-op */\n      }\n    }\n    this.useSoftware = !this.subtle;\n  }\n  destroy() {\n    this.subtle = null;\n    this.softwareDecrypter = null;\n    this.key = null;\n    this.fastAesKey = null;\n    this.remainderData = null;\n    this.currentIV = null;\n    this.currentResult = null;\n  }\n  isSync() {\n    return this.useSoftware;\n  }\n  flush() {\n    const {\n      currentResult,\n      remainderData\n    } = this;\n    if (!currentResult || remainderData) {\n      this.reset();\n      return null;\n    }\n    const data = new Uint8Array(currentResult);\n    this.reset();\n    if (this.removePKCS7Padding) {\n      return removePadding(data);\n    }\n    return data;\n  }\n  reset() {\n    this.currentResult = null;\n    this.currentIV = null;\n    this.remainderData = null;\n    if (this.softwareDecrypter) {\n      this.softwareDecrypter = null;\n    }\n  }\n  decrypt(data, key, iv, aesMode) {\n    if (this.useSoftware) {\n      return new Promise((resolve, reject) => {\n        const dataView = ArrayBuffer.isView(data) ? data : new Uint8Array(data);\n        this.softwareDecrypt(dataView, key, iv, aesMode);\n        const decryptResult = this.flush();\n        if (decryptResult) {\n          resolve(decryptResult.buffer);\n        } else {\n          reject(new Error('[softwareDecrypt] Failed to decrypt data'));\n        }\n      });\n    }\n    return this.webCryptoDecrypt(new Uint8Array(data), key, iv, aesMode);\n  }\n\n  // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached\n  // data is handled in the flush() call\n  softwareDecrypt(data, key, iv, aesMode) {\n    const {\n      currentIV,\n      currentResult,\n      remainderData\n    } = this;\n    if (aesMode !== DecrypterAesMode.cbc || key.byteLength !== 16) {\n      logger.warn('SoftwareDecrypt: can only handle AES-128-CBC');\n      return null;\n    }\n    this.logOnce('JS AES decrypt');\n    // The output is staggered during progressive parsing - the current result is cached, and emitted on the next call\n    // This is done in order to strip PKCS7 padding, which is found at the end of each segment. We only know we've reached\n    // the end on flush(), but by that time we have already received all bytes for the segment.\n    // Progressive decryption does not work with WebCrypto\n\n    if (remainderData) {\n      data = appendUint8Array(remainderData, data);\n      this.remainderData = null;\n    }\n\n    // Byte length must be a multiple of 16 (AES-128 = 128 bit blocks = 16 bytes)\n    const currentChunk = this.getValidChunk(data);\n    if (!currentChunk.length) {\n      return null;\n    }\n    if (currentIV) {\n      iv = currentIV;\n    }\n    let softwareDecrypter = this.softwareDecrypter;\n    if (!softwareDecrypter) {\n      softwareDecrypter = this.softwareDecrypter = new AESDecryptor();\n    }\n    softwareDecrypter.expandKey(key);\n    const result = currentResult;\n    this.currentResult = softwareDecrypter.decrypt(currentChunk.buffer, 0, iv);\n    this.currentIV = currentChunk.slice(-16).buffer;\n    if (!result) {\n      return null;\n    }\n    return result;\n  }\n  webCryptoDecrypt(data, key, iv, aesMode) {\n    if (this.key !== key || !this.fastAesKey) {\n      if (!this.subtle) {\n        return Promise.resolve(this.onWebCryptoError(data, key, iv, aesMode));\n      }\n      this.key = key;\n      this.fastAesKey = new FastAESKey(this.subtle, key, aesMode);\n    }\n    return this.fastAesKey.expandKey().then(aesKey => {\n      // decrypt using web crypto\n      if (!this.subtle) {\n        return Promise.reject(new Error('web crypto not initialized'));\n      }\n      this.logOnce('WebCrypto AES decrypt');\n      const crypto = new AESCrypto(this.subtle, new Uint8Array(iv), aesMode);\n      return crypto.decrypt(data.buffer, aesKey);\n    }).catch(err => {\n      logger.warn(`[decrypter]: WebCrypto Error, disable WebCrypto API, ${err.name}: ${err.message}`);\n      return this.onWebCryptoError(data, key, iv, aesMode);\n    });\n  }\n  onWebCryptoError(data, key, iv, aesMode) {\n    const enableSoftwareAES = this.enableSoftwareAES;\n    if (enableSoftwareAES) {\n      this.useSoftware = true;\n      this.logEnabled = true;\n      this.softwareDecrypt(data, key, iv, aesMode);\n      const decryptResult = this.flush();\n      if (decryptResult) {\n        return decryptResult.buffer;\n      }\n    }\n    throw new Error('WebCrypto' + (enableSoftwareAES ? ' and softwareDecrypt' : '') + ': failed to decrypt data');\n  }\n  getValidChunk(data) {\n    let currentChunk = data;\n    const splitPoint = data.length - data.length % CHUNK_SIZE;\n    if (splitPoint !== data.length) {\n      currentChunk = data.slice(0, splitPoint);\n      this.remainderData = data.slice(splitPoint);\n    }\n    return currentChunk;\n  }\n  logOnce(msg) {\n    if (!this.logEnabled) {\n      return;\n    }\n    logger.log(`[decrypter]: ${msg}`);\n    this.logEnabled = false;\n  }\n}\n\nconst MIN_CHUNK_SIZE = Math.pow(2, 17); // 128kb\n\nclass FragmentLoader {\n  constructor(config) {\n    this.config = void 0;\n    this.loader = null;\n    this.partLoadTimeout = -1;\n    this.config = config;\n  }\n  destroy() {\n    if (this.loader) {\n      this.loader.destroy();\n      this.loader = null;\n    }\n  }\n  abort() {\n    if (this.loader) {\n      // Abort the loader for current fragment. Only one may load at any given time\n      this.loader.abort();\n    }\n  }\n  load(frag, onProgress) {\n    const url = frag.url;\n    if (!url) {\n      return Promise.reject(new LoadError({\n        type: ErrorTypes.NETWORK_ERROR,\n        details: ErrorDetails.FRAG_LOAD_ERROR,\n        fatal: false,\n        frag,\n        error: new Error(`Fragment does not have a ${url ? 'part list' : 'url'}`),\n        networkDetails: null\n      }));\n    }\n    this.abort();\n    const config = this.config;\n    const FragmentILoader = config.fLoader;\n    const DefaultILoader = config.loader;\n    return new Promise((resolve, reject) => {\n      if (this.loader) {\n        this.loader.destroy();\n      }\n      if (frag.gap) {\n        if (frag.tagList.some(tags => tags[0] === 'GAP')) {\n          reject(createGapLoadError(frag));\n          return;\n        } else {\n          // Reset temporary treatment as GAP tag\n          frag.gap = false;\n        }\n      }\n      const loader = this.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);\n      const loaderContext = createLoaderContext(frag);\n      frag.loader = loader;\n      const loadPolicy = getLoaderConfigWithoutReties(config.fragLoadPolicy.default);\n      const loaderConfig = {\n        loadPolicy,\n        timeout: loadPolicy.maxLoadTimeMs,\n        maxRetry: 0,\n        retryDelay: 0,\n        maxRetryDelay: 0,\n        highWaterMark: frag.sn === 'initSegment' ? Infinity : MIN_CHUNK_SIZE\n      };\n      // Assign frag stats to the loader's stats reference\n      frag.stats = loader.stats;\n      const callbacks = {\n        onSuccess: (response, stats, context, networkDetails) => {\n          this.resetLoader(frag, loader);\n          let payload = response.data;\n          if (context.resetIV && frag.decryptdata) {\n            frag.decryptdata.iv = new Uint8Array(payload.slice(0, 16));\n            payload = payload.slice(16);\n          }\n          resolve({\n            frag,\n            part: null,\n            payload,\n            networkDetails\n          });\n        },\n        onError: (response, context, networkDetails, stats) => {\n          this.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.FRAG_LOAD_ERROR,\n            fatal: false,\n            frag,\n            response: _objectSpread2({\n              url,\n              data: undefined\n            }, response),\n            error: new Error(`HTTP Error ${response.code} ${response.text}`),\n            networkDetails,\n            stats\n          }));\n        },\n        onAbort: (stats, context, networkDetails) => {\n          this.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.INTERNAL_ABORTED,\n            fatal: false,\n            frag,\n            error: new Error('Aborted'),\n            networkDetails,\n            stats\n          }));\n        },\n        onTimeout: (stats, context, networkDetails) => {\n          this.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.FRAG_LOAD_TIMEOUT,\n            fatal: false,\n            frag,\n            error: new Error(`Timeout after ${loaderConfig.timeout}ms`),\n            networkDetails,\n            stats\n          }));\n        }\n      };\n      if (onProgress) {\n        callbacks.onProgress = (stats, context, data, networkDetails) => onProgress({\n          frag,\n          part: null,\n          payload: data,\n          networkDetails\n        });\n      }\n      loader.load(loaderContext, loaderConfig, callbacks);\n    });\n  }\n  loadPart(frag, part, onProgress) {\n    this.abort();\n    const config = this.config;\n    const FragmentILoader = config.fLoader;\n    const DefaultILoader = config.loader;\n    return new Promise((resolve, reject) => {\n      if (this.loader) {\n        this.loader.destroy();\n      }\n      if (frag.gap || part.gap) {\n        reject(createGapLoadError(frag, part));\n        return;\n      }\n      const loader = this.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);\n      const loaderContext = createLoaderContext(frag, part);\n      frag.loader = loader;\n      // Should we define another load policy for parts?\n      const loadPolicy = getLoaderConfigWithoutReties(config.fragLoadPolicy.default);\n      const loaderConfig = {\n        loadPolicy,\n        timeout: loadPolicy.maxLoadTimeMs,\n        maxRetry: 0,\n        retryDelay: 0,\n        maxRetryDelay: 0,\n        highWaterMark: MIN_CHUNK_SIZE\n      };\n      // Assign part stats to the loader's stats reference\n      part.stats = loader.stats;\n      loader.load(loaderContext, loaderConfig, {\n        onSuccess: (response, stats, context, networkDetails) => {\n          this.resetLoader(frag, loader);\n          this.updateStatsFromPart(frag, part);\n          const partLoadedData = {\n            frag,\n            part,\n            payload: response.data,\n            networkDetails\n          };\n          onProgress(partLoadedData);\n          resolve(partLoadedData);\n        },\n        onError: (response, context, networkDetails, stats) => {\n          this.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.FRAG_LOAD_ERROR,\n            fatal: false,\n            frag,\n            part,\n            response: _objectSpread2({\n              url: loaderContext.url,\n              data: undefined\n            }, response),\n            error: new Error(`HTTP Error ${response.code} ${response.text}`),\n            networkDetails,\n            stats\n          }));\n        },\n        onAbort: (stats, context, networkDetails) => {\n          frag.stats.aborted = part.stats.aborted;\n          this.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.INTERNAL_ABORTED,\n            fatal: false,\n            frag,\n            part,\n            error: new Error('Aborted'),\n            networkDetails,\n            stats\n          }));\n        },\n        onTimeout: (stats, context, networkDetails) => {\n          this.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.FRAG_LOAD_TIMEOUT,\n            fatal: false,\n            frag,\n            part,\n            error: new Error(`Timeout after ${loaderConfig.timeout}ms`),\n            networkDetails,\n            stats\n          }));\n        }\n      });\n    });\n  }\n  updateStatsFromPart(frag, part) {\n    const fragStats = frag.stats;\n    const partStats = part.stats;\n    const partTotal = partStats.total;\n    fragStats.loaded += partStats.loaded;\n    if (partTotal) {\n      const estTotalParts = Math.round(frag.duration / part.duration);\n      const estLoadedParts = Math.min(Math.round(fragStats.loaded / partTotal), estTotalParts);\n      const estRemainingParts = estTotalParts - estLoadedParts;\n      const estRemainingBytes = estRemainingParts * Math.round(fragStats.loaded / estLoadedParts);\n      fragStats.total = fragStats.loaded + estRemainingBytes;\n    } else {\n      fragStats.total = Math.max(fragStats.loaded, fragStats.total);\n    }\n    const fragLoading = fragStats.loading;\n    const partLoading = partStats.loading;\n    if (fragLoading.start) {\n      // add to fragment loader latency\n      fragLoading.first += partLoading.first - partLoading.start;\n    } else {\n      fragLoading.start = partLoading.start;\n      fragLoading.first = partLoading.first;\n    }\n    fragLoading.end = partLoading.end;\n  }\n  resetLoader(frag, loader) {\n    frag.loader = null;\n    if (this.loader === loader) {\n      self.clearTimeout(this.partLoadTimeout);\n      this.loader = null;\n    }\n    loader.destroy();\n  }\n}\nfunction createLoaderContext(frag, part = null) {\n  const segment = part || frag;\n  const loaderContext = {\n    frag,\n    part,\n    responseType: 'arraybuffer',\n    url: segment.url,\n    headers: {},\n    rangeStart: 0,\n    rangeEnd: 0\n  };\n  const start = segment.byteRangeStartOffset;\n  const end = segment.byteRangeEndOffset;\n  if (isFiniteNumber(start) && isFiniteNumber(end)) {\n    var _frag$decryptdata;\n    let byteRangeStart = start;\n    let byteRangeEnd = end;\n    if (frag.sn === 'initSegment' && isMethodFullSegmentAesCbc((_frag$decryptdata = frag.decryptdata) == null ? void 0 : _frag$decryptdata.method)) {\n      // MAP segment encrypted with method 'AES-128' or 'AES-256' (cbc), when served with HTTP Range,\n      // has the unencrypted size specified in the range.\n      // Ref: https://tools.ietf.org/html/draft-pantos-hls-rfc8216bis-08#section-6.3.6\n      const fragmentLen = end - start;\n      if (fragmentLen % 16) {\n        byteRangeEnd = end + (16 - fragmentLen % 16);\n      }\n      if (start !== 0) {\n        loaderContext.resetIV = true;\n        byteRangeStart = start - 16;\n      }\n    }\n    loaderContext.rangeStart = byteRangeStart;\n    loaderContext.rangeEnd = byteRangeEnd;\n  }\n  return loaderContext;\n}\nfunction createGapLoadError(frag, part) {\n  const error = new Error(`GAP ${frag.gap ? 'tag' : 'attribute'} found`);\n  const errorData = {\n    type: ErrorTypes.MEDIA_ERROR,\n    details: ErrorDetails.FRAG_GAP,\n    fatal: false,\n    frag,\n    error,\n    networkDetails: null\n  };\n  if (part) {\n    errorData.part = part;\n  }\n  (part ? part : frag).stats.aborted = true;\n  return new LoadError(errorData);\n}\nfunction isMethodFullSegmentAesCbc(method) {\n  return method === 'AES-128' || method === 'AES-256';\n}\nclass LoadError extends Error {\n  constructor(data) {\n    super(data.error.message);\n    this.data = void 0;\n    this.data = data;\n  }\n}\n\n/**\n * @ignore\n * Sub-class specialization of EventHandler base class.\n *\n * TaskLoop allows to schedule a task function being called (optionnaly repeatedly) on the main loop,\n * scheduled asynchroneously, avoiding recursive calls in the same tick.\n *\n * The task itself is implemented in `doTick`. It can be requested and called for single execution\n * using the `tick` method.\n *\n * It will be assured that the task execution method (`tick`) only gets called once per main loop \"tick\",\n * no matter how often it gets requested for execution. Execution in further ticks will be scheduled accordingly.\n *\n * If further execution requests have already been scheduled on the next tick, it can be checked with `hasNextTick`,\n * and cancelled with `clearNextTick`.\n *\n * The task can be scheduled as an interval repeatedly with a period as parameter (see `setInterval`, `clearInterval`).\n *\n * Sub-classes need to implement the `doTick` method which will effectively have the task execution routine.\n *\n * Further explanations:\n *\n * The baseclass has a `tick` method that will schedule the doTick call. It may be called synchroneously\n * only for a stack-depth of one. On re-entrant calls, sub-sequent calls are scheduled for next main loop ticks.\n *\n * When the task execution (`tick` method) is called in re-entrant way this is detected and\n * we are limiting the task execution per call stack to exactly one, but scheduling/post-poning further\n * task processing on the next main loop iteration (also known as \"next tick\" in the Node/JS runtime lingo).\n */\nclass TaskLoop extends Logger {\n  constructor(label, logger) {\n    super(label, logger);\n    this._boundTick = void 0;\n    this._tickTimer = null;\n    this._tickInterval = null;\n    this._tickCallCount = 0;\n    this._boundTick = this.tick.bind(this);\n  }\n  destroy() {\n    this.onHandlerDestroying();\n    this.onHandlerDestroyed();\n  }\n  onHandlerDestroying() {\n    // clear all timers before unregistering from event bus\n    this.clearNextTick();\n    this.clearInterval();\n  }\n  onHandlerDestroyed() {}\n  hasInterval() {\n    return !!this._tickInterval;\n  }\n  hasNextTick() {\n    return !!this._tickTimer;\n  }\n\n  /**\n   * @param millis - Interval time (ms)\n   * @eturns True when interval has been scheduled, false when already scheduled (no effect)\n   */\n  setInterval(millis) {\n    if (!this._tickInterval) {\n      this._tickCallCount = 0;\n      this._tickInterval = self.setInterval(this._boundTick, millis);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @returns True when interval was cleared, false when none was set (no effect)\n   */\n  clearInterval() {\n    if (this._tickInterval) {\n      self.clearInterval(this._tickInterval);\n      this._tickInterval = null;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @returns True when timeout was cleared, false when none was set (no effect)\n   */\n  clearNextTick() {\n    if (this._tickTimer) {\n      self.clearTimeout(this._tickTimer);\n      this._tickTimer = null;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Will call the subclass doTick implementation in this main loop tick\n   * or in the next one (via setTimeout(,0)) in case it has already been called\n   * in this tick (in case this is a re-entrant call).\n   */\n  tick() {\n    this._tickCallCount++;\n    if (this._tickCallCount === 1) {\n      this.doTick();\n      // re-entrant call to tick from previous doTick call stack\n      // -> schedule a call on the next main loop iteration to process this task processing request\n      if (this._tickCallCount > 1) {\n        // make sure only one timer exists at any time at max\n        this.tickImmediate();\n      }\n      this._tickCallCount = 0;\n    }\n  }\n  tickImmediate() {\n    this.clearNextTick();\n    this._tickTimer = self.setTimeout(this._boundTick, 0);\n  }\n\n  /**\n   * For subclass to implement task logic\n   * @abstract\n   */\n  doTick() {}\n}\n\nclass ChunkMetadata {\n  constructor(level, sn, id, size = 0, part = -1, partial = false) {\n    this.level = void 0;\n    this.sn = void 0;\n    this.part = void 0;\n    this.id = void 0;\n    this.size = void 0;\n    this.partial = void 0;\n    this.transmuxing = getNewPerformanceTiming();\n    this.buffering = {\n      audio: getNewPerformanceTiming(),\n      video: getNewPerformanceTiming(),\n      audiovideo: getNewPerformanceTiming()\n    };\n    this.level = level;\n    this.sn = sn;\n    this.id = id;\n    this.size = size;\n    this.part = part;\n    this.partial = partial;\n  }\n}\nfunction getNewPerformanceTiming() {\n  return {\n    start: 0,\n    executeStart: 0,\n    executeEnd: 0,\n    end: 0\n  };\n}\n\n/**\n * Provides methods dealing with buffer length retrieval for example.\n *\n * In general, a helper around HTML5 MediaElement TimeRanges gathered from `buffered` property.\n *\n * Also @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/buffered\n */\n\nconst noopBuffered = {\n  length: 0,\n  start: () => 0,\n  end: () => 0\n};\nclass BufferHelper {\n  /**\n   * Return true if `media`'s buffered include `position`\n   */\n  static isBuffered(media, position) {\n    if (media) {\n      const buffered = BufferHelper.getBuffered(media);\n      for (let i = buffered.length; i--;) {\n        if (position >= buffered.start(i) && position <= buffered.end(i)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  static bufferedRanges(media) {\n    if (media) {\n      const timeRanges = BufferHelper.getBuffered(media);\n      return BufferHelper.timeRangesToArray(timeRanges);\n    }\n    return [];\n  }\n  static timeRangesToArray(timeRanges) {\n    const buffered = [];\n    for (let i = 0; i < timeRanges.length; i++) {\n      buffered.push({\n        start: timeRanges.start(i),\n        end: timeRanges.end(i)\n      });\n    }\n    return buffered;\n  }\n  static bufferInfo(media, pos, maxHoleDuration) {\n    if (media) {\n      const buffered = BufferHelper.bufferedRanges(media);\n      if (buffered.length) {\n        return BufferHelper.bufferedInfo(buffered, pos, maxHoleDuration);\n      }\n    }\n    return {\n      len: 0,\n      start: pos,\n      end: pos,\n      bufferedIndex: -1\n    };\n  }\n  static bufferedInfo(buffered, pos, maxHoleDuration) {\n    pos = Math.max(0, pos);\n    // sort on buffer.start/smaller end (IE does not always return sorted buffered range)\n    if (buffered.length > 1) {\n      buffered.sort((a, b) => a.start - b.start || b.end - a.end);\n    }\n    let bufferedIndex = -1;\n    let buffered2 = [];\n    if (maxHoleDuration) {\n      // there might be some small holes between buffer time range\n      // consider that holes smaller than maxHoleDuration are irrelevant and build another\n      // buffer time range representations that discards those holes\n      for (let i = 0; i < buffered.length; i++) {\n        if (pos >= buffered[i].start && pos <= buffered[i].end) {\n          bufferedIndex = i;\n        }\n        const buf2len = buffered2.length;\n        if (buf2len) {\n          const buf2end = buffered2[buf2len - 1].end;\n          // if small hole (value between 0 or maxHoleDuration ) or overlapping (negative)\n          if (buffered[i].start - buf2end < maxHoleDuration) {\n            // merge overlapping time ranges\n            // update lastRange.end only if smaller than item.end\n            // e.g.  [ 1, 15] with  [ 2,8] => [ 1,15] (no need to modify lastRange.end)\n            // whereas [ 1, 8] with  [ 2,15] => [ 1,15] ( lastRange should switch from [1,8] to [1,15])\n            if (buffered[i].end > buf2end) {\n              buffered2[buf2len - 1].end = buffered[i].end;\n            }\n          } else {\n            // big hole\n            buffered2.push(buffered[i]);\n          }\n        } else {\n          // first value\n          buffered2.push(buffered[i]);\n        }\n      }\n    } else {\n      buffered2 = buffered;\n    }\n    let bufferLen = 0;\n    let nextStart;\n\n    // bufferStart and bufferEnd are buffer boundaries around current playback position (pos)\n    let bufferStart = pos;\n    let bufferEnd = pos;\n    for (let i = 0; i < buffered2.length; i++) {\n      const start = buffered2[i].start;\n      const end = buffered2[i].end;\n      // logger.log('buf start/end:' + buffered.start(i) + '/' + buffered.end(i));\n      if (bufferedIndex === -1 && pos >= start && pos <= end) {\n        bufferedIndex = i;\n      }\n      if (pos + maxHoleDuration >= start && pos < end) {\n        // play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length\n        bufferStart = start;\n        bufferEnd = end;\n        bufferLen = bufferEnd - pos;\n      } else if (pos + maxHoleDuration < start) {\n        nextStart = start;\n        break;\n      }\n    }\n    return {\n      len: bufferLen,\n      start: bufferStart || 0,\n      end: bufferEnd || 0,\n      nextStart,\n      buffered,\n      bufferedIndex\n    };\n  }\n\n  /**\n   * Safe method to get buffered property.\n   * SourceBuffer.buffered may throw if SourceBuffer is removed from it's MediaSource\n   */\n  static getBuffered(media) {\n    try {\n      return media.buffered || noopBuffered;\n    } catch (e) {\n      logger.log('failed to get media.buffered', e);\n      return noopBuffered;\n    }\n  }\n}\n\nconst VARIABLE_REPLACEMENT_REGEX = /\\{\\$([a-zA-Z0-9-_]+)\\}/g;\nfunction hasVariableReferences(str) {\n  return VARIABLE_REPLACEMENT_REGEX.test(str);\n}\nfunction substituteVariables(parsed, value) {\n  if (parsed.variableList !== null || parsed.hasVariableRefs) {\n    const variableList = parsed.variableList;\n    return value.replace(VARIABLE_REPLACEMENT_REGEX, variableReference => {\n      const variableName = variableReference.substring(2, variableReference.length - 1);\n      const variableValue = variableList == null ? void 0 : variableList[variableName];\n      if (variableValue === undefined) {\n        parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`Missing preceding EXT-X-DEFINE tag for Variable Reference: \"${variableName}\"`));\n        return variableReference;\n      }\n      return variableValue;\n    });\n  }\n  return value;\n}\nfunction addVariableDefinition(parsed, attr, parentUrl) {\n  let variableList = parsed.variableList;\n  if (!variableList) {\n    parsed.variableList = variableList = {};\n  }\n  let NAME;\n  let VALUE;\n  if ('QUERYPARAM' in attr) {\n    NAME = attr.QUERYPARAM;\n    try {\n      const searchParams = new self.URL(parentUrl).searchParams;\n      if (searchParams.has(NAME)) {\n        VALUE = searchParams.get(NAME);\n      } else {\n        throw new Error(`\"${NAME}\" does not match any query parameter in URI: \"${parentUrl}\"`);\n      }\n    } catch (error) {\n      parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`EXT-X-DEFINE QUERYPARAM: ${error.message}`));\n    }\n  } else {\n    NAME = attr.NAME;\n    VALUE = attr.VALUE;\n  }\n  if (NAME in variableList) {\n    parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`EXT-X-DEFINE duplicate Variable Name declarations: \"${NAME}\"`));\n  } else {\n    variableList[NAME] = VALUE || '';\n  }\n}\nfunction importVariableDefinition(parsed, attr, sourceVariableList) {\n  const IMPORT = attr.IMPORT;\n  if (sourceVariableList && IMPORT in sourceVariableList) {\n    let variableList = parsed.variableList;\n    if (!variableList) {\n      parsed.variableList = variableList = {};\n    }\n    variableList[IMPORT] = sourceVariableList[IMPORT];\n  } else {\n    parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: \"${IMPORT}\"`));\n  }\n}\n\nconst DECIMAL_RESOLUTION_REGEX = /^(\\d+)x(\\d+)$/;\nconst ATTR_LIST_REGEX = /(.+?)=(\".*?\"|.*?)(?:,|$)/g;\n\n// adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js\nclass AttrList {\n  constructor(attrs, parsed) {\n    if (typeof attrs === 'string') {\n      attrs = AttrList.parseAttrList(attrs, parsed);\n    }\n    _extends(this, attrs);\n  }\n  get clientAttrs() {\n    return Object.keys(this).filter(attr => attr.substring(0, 2) === 'X-');\n  }\n  decimalInteger(attrName) {\n    const intValue = parseInt(this[attrName], 10);\n    if (intValue > Number.MAX_SAFE_INTEGER) {\n      return Infinity;\n    }\n    return intValue;\n  }\n  hexadecimalInteger(attrName) {\n    if (this[attrName]) {\n      let stringValue = (this[attrName] || '0x').slice(2);\n      stringValue = (stringValue.length & 1 ? '0' : '') + stringValue;\n      const value = new Uint8Array(stringValue.length / 2);\n      for (let i = 0; i < stringValue.length / 2; i++) {\n        value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);\n      }\n      return value;\n    }\n    return null;\n  }\n  hexadecimalIntegerAsNumber(attrName) {\n    const intValue = parseInt(this[attrName], 16);\n    if (intValue > Number.MAX_SAFE_INTEGER) {\n      return Infinity;\n    }\n    return intValue;\n  }\n  decimalFloatingPoint(attrName) {\n    return parseFloat(this[attrName]);\n  }\n  optionalFloat(attrName, defaultValue) {\n    const value = this[attrName];\n    return value ? parseFloat(value) : defaultValue;\n  }\n  enumeratedString(attrName) {\n    return this[attrName];\n  }\n  enumeratedStringList(attrName, dict) {\n    const attrValue = this[attrName];\n    return (attrValue ? attrValue.split(/[ ,]+/) : []).reduce((result, identifier) => {\n      result[identifier.toLowerCase()] = true;\n      return result;\n    }, dict);\n  }\n  bool(attrName) {\n    return this[attrName] === 'YES';\n  }\n  decimalResolution(attrName) {\n    const res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);\n    if (res === null) {\n      return undefined;\n    }\n    return {\n      width: parseInt(res[1], 10),\n      height: parseInt(res[2], 10)\n    };\n  }\n  static parseAttrList(input, parsed) {\n    let match;\n    const attrs = {};\n    const quote = '\"';\n    ATTR_LIST_REGEX.lastIndex = 0;\n    while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {\n      const name = match[1].trim();\n      let value = match[2];\n      const quotedString = value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1;\n      let hexadecimalSequence = false;\n      if (quotedString) {\n        value = value.slice(1, -1);\n      } else {\n        switch (name) {\n          case 'IV':\n          case 'SCTE35-CMD':\n          case 'SCTE35-IN':\n          case 'SCTE35-OUT':\n            hexadecimalSequence = true;\n        }\n      }\n      if (parsed && (quotedString || hexadecimalSequence)) {\n        {\n          value = substituteVariables(parsed, value);\n        }\n      } else if (!hexadecimalSequence && !quotedString) {\n        switch (name) {\n          case 'CLOSED-CAPTIONS':\n            if (value === 'NONE') {\n              break;\n            }\n          // falls through\n          case 'ALLOWED-CPC':\n          case 'CLASS':\n          case 'ASSOC-LANGUAGE':\n          case 'AUDIO':\n          case 'BYTERANGE':\n          case 'CHANNELS':\n          case 'CHARACTERISTICS':\n          case 'CODECS':\n          case 'DATA-ID':\n          case 'END-DATE':\n          case 'GROUP-ID':\n          case 'ID':\n          case 'IMPORT':\n          case 'INSTREAM-ID':\n          case 'KEYFORMAT':\n          case 'KEYFORMATVERSIONS':\n          case 'LANGUAGE':\n          case 'NAME':\n          case 'PATHWAY-ID':\n          case 'QUERYPARAM':\n          case 'RECENTLY-REMOVED-DATERANGES':\n          case 'SERVER-URI':\n          case 'STABLE-RENDITION-ID':\n          case 'STABLE-VARIANT-ID':\n          case 'START-DATE':\n          case 'SUBTITLES':\n          case 'SUPPLEMENTAL-CODECS':\n          case 'URI':\n          case 'VALUE':\n          case 'VIDEO':\n          case 'X-ASSET-LIST':\n          case 'X-ASSET-URI':\n            // Since we are not checking tag:attribute combination, just warn rather than ignoring attribute\n            logger.warn(`${input}: attribute ${name} is missing quotes`);\n          // continue;\n        }\n      }\n      attrs[name] = value;\n    }\n    return attrs;\n  }\n}\n\n// Avoid exporting const enum so that these values can be inlined\n\nconst CLASS_INTERSTITIAL = 'com.apple.hls.interstitial';\nfunction isDateRangeCueAttribute(attrName) {\n  return attrName !== \"ID\" && attrName !== \"CLASS\" && attrName !== \"CUE\" && attrName !== \"START-DATE\" && attrName !== \"DURATION\" && attrName !== \"END-DATE\" && attrName !== \"END-ON-NEXT\";\n}\nfunction isSCTE35Attribute(attrName) {\n  return attrName === \"SCTE35-OUT\" || attrName === \"SCTE35-IN\" || attrName === \"SCTE35-CMD\";\n}\nclass DateRange {\n  constructor(dateRangeAttr, dateRangeWithSameId, tagCount = 0) {\n    var _dateRangeWithSameId$;\n    this.attr = void 0;\n    this.tagAnchor = void 0;\n    this.tagOrder = void 0;\n    this._startDate = void 0;\n    this._endDate = void 0;\n    this._dateAtEnd = void 0;\n    this._cue = void 0;\n    this._badValueForSameId = void 0;\n    this.tagAnchor = (dateRangeWithSameId == null ? void 0 : dateRangeWithSameId.tagAnchor) || null;\n    this.tagOrder = (_dateRangeWithSameId$ = dateRangeWithSameId == null ? void 0 : dateRangeWithSameId.tagOrder) != null ? _dateRangeWithSameId$ : tagCount;\n    if (dateRangeWithSameId) {\n      const previousAttr = dateRangeWithSameId.attr;\n      for (const key in previousAttr) {\n        if (Object.prototype.hasOwnProperty.call(dateRangeAttr, key) && dateRangeAttr[key] !== previousAttr[key]) {\n          logger.warn(`DATERANGE tag attribute: \"${key}\" does not match for tags with ID: \"${dateRangeAttr.ID}\"`);\n          this._badValueForSameId = key;\n          break;\n        }\n      }\n      // Merge DateRange tags with the same ID\n      dateRangeAttr = _extends(new AttrList({}), previousAttr, dateRangeAttr);\n    }\n    this.attr = dateRangeAttr;\n    if (dateRangeWithSameId) {\n      this._startDate = dateRangeWithSameId._startDate;\n      this._cue = dateRangeWithSameId._cue;\n      this._endDate = dateRangeWithSameId._endDate;\n      this._dateAtEnd = dateRangeWithSameId._dateAtEnd;\n    } else {\n      this._startDate = new Date(dateRangeAttr[\"START-DATE\"]);\n    }\n    if (\"END-DATE\" in this.attr) {\n      const endDate = (dateRangeWithSameId == null ? void 0 : dateRangeWithSameId.endDate) || new Date(this.attr[\"END-DATE\"]);\n      if (isFiniteNumber(endDate.getTime())) {\n        this._endDate = endDate;\n      }\n    }\n  }\n  get id() {\n    return this.attr.ID;\n  }\n  get class() {\n    return this.attr.CLASS;\n  }\n  get cue() {\n    const _cue = this._cue;\n    if (_cue === undefined) {\n      return this._cue = this.attr.enumeratedStringList(this.attr.CUE ? 'CUE' : 'X-CUE', {\n        pre: false,\n        post: false,\n        once: false\n      });\n    }\n    return _cue;\n  }\n  get startTime() {\n    const {\n      tagAnchor\n    } = this;\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (tagAnchor === null || tagAnchor.programDateTime === null) {\n      logger.warn(`Expected tagAnchor Fragment with PDT set for DateRange \"${this.id}\": ${tagAnchor}`);\n      return NaN;\n    }\n    return tagAnchor.start + (this.startDate.getTime() - tagAnchor.programDateTime) / 1000;\n  }\n  get startDate() {\n    return this._startDate;\n  }\n  get endDate() {\n    const dateAtEnd = this._endDate || this._dateAtEnd;\n    if (dateAtEnd) {\n      return dateAtEnd;\n    }\n    const duration = this.duration;\n    if (duration !== null) {\n      return this._dateAtEnd = new Date(this._startDate.getTime() + duration * 1000);\n    }\n    return null;\n  }\n  get duration() {\n    if (\"DURATION\" in this.attr) {\n      const duration = this.attr.decimalFloatingPoint(\"DURATION\");\n      if (isFiniteNumber(duration)) {\n        return duration;\n      }\n    } else if (this._endDate) {\n      return (this._endDate.getTime() - this._startDate.getTime()) / 1000;\n    }\n    return null;\n  }\n  get plannedDuration() {\n    if (\"PLANNED-DURATION\" in this.attr) {\n      return this.attr.decimalFloatingPoint(\"PLANNED-DURATION\");\n    }\n    return null;\n  }\n  get endOnNext() {\n    return this.attr.bool(\"END-ON-NEXT\");\n  }\n  get isInterstitial() {\n    return this.class === CLASS_INTERSTITIAL;\n  }\n  get isValid() {\n    return !!this.id && !this._badValueForSameId && isFiniteNumber(this.startDate.getTime()) && (this.duration === null || this.duration >= 0) && (!this.endOnNext || !!this.class) && (!this.attr.CUE || !this.cue.pre && !this.cue.post || this.cue.pre !== this.cue.post) && (!this.isInterstitial || 'X-ASSET-URI' in this.attr || 'X-ASSET-LIST' in this.attr);\n  }\n}\n\nconst DEFAULT_TARGET_DURATION = 10;\n\n/**\n * Object representing parsed data from an HLS Media Playlist. Found in {@link hls.js#Level.details}.\n */\nclass LevelDetails {\n  constructor(baseUrl) {\n    this.PTSKnown = false;\n    this.alignedSliding = false;\n    this.averagetargetduration = void 0;\n    this.endCC = 0;\n    this.endSN = 0;\n    this.fragments = void 0;\n    this.fragmentHint = void 0;\n    this.partList = null;\n    this.dateRanges = void 0;\n    this.dateRangeTagCount = 0;\n    this.live = true;\n    this.requestScheduled = -1;\n    this.ageHeader = 0;\n    this.advancedDateTime = void 0;\n    this.updated = true;\n    this.advanced = true;\n    this.misses = 0;\n    this.startCC = 0;\n    this.startSN = 0;\n    this.startTimeOffset = null;\n    this.targetduration = 0;\n    this.totalduration = 0;\n    this.type = null;\n    this.url = void 0;\n    this.m3u8 = '';\n    this.version = null;\n    this.canBlockReload = false;\n    this.canSkipUntil = 0;\n    this.canSkipDateRanges = false;\n    this.skippedSegments = 0;\n    this.recentlyRemovedDateranges = void 0;\n    this.partHoldBack = 0;\n    this.holdBack = 0;\n    this.partTarget = 0;\n    this.preloadHint = void 0;\n    this.renditionReports = void 0;\n    this.tuneInGoal = 0;\n    this.deltaUpdateFailed = void 0;\n    this.driftStartTime = 0;\n    this.driftEndTime = 0;\n    this.driftStart = 0;\n    this.driftEnd = 0;\n    this.encryptedFragments = void 0;\n    this.playlistParsingError = null;\n    this.variableList = null;\n    this.hasVariableRefs = false;\n    this.appliedTimelineOffset = void 0;\n    this.fragments = [];\n    this.encryptedFragments = [];\n    this.dateRanges = {};\n    this.url = baseUrl;\n  }\n  reloaded(previous) {\n    if (!previous) {\n      this.advanced = true;\n      this.updated = true;\n      return;\n    }\n    const partSnDiff = this.lastPartSn - previous.lastPartSn;\n    const partIndexDiff = this.lastPartIndex - previous.lastPartIndex;\n    this.updated = this.endSN !== previous.endSN || !!partIndexDiff || !!partSnDiff || !this.live;\n    this.advanced = this.endSN > previous.endSN || partSnDiff > 0 || partSnDiff === 0 && partIndexDiff > 0;\n    if (this.updated || this.advanced) {\n      this.misses = Math.floor(previous.misses * 0.6);\n    } else {\n      this.misses = previous.misses + 1;\n    }\n  }\n  get hasProgramDateTime() {\n    if (this.fragments.length) {\n      return isFiniteNumber(this.fragments[this.fragments.length - 1].programDateTime);\n    }\n    return false;\n  }\n  get levelTargetDuration() {\n    return this.averagetargetduration || this.targetduration || DEFAULT_TARGET_DURATION;\n  }\n  get drift() {\n    const runTime = this.driftEndTime - this.driftStartTime;\n    if (runTime > 0) {\n      const runDuration = this.driftEnd - this.driftStart;\n      return runDuration * 1000 / runTime;\n    }\n    return 1;\n  }\n  get edge() {\n    return this.partEnd || this.fragmentEnd;\n  }\n  get partEnd() {\n    var _this$partList;\n    if ((_this$partList = this.partList) != null && _this$partList.length) {\n      return this.partList[this.partList.length - 1].end;\n    }\n    return this.fragmentEnd;\n  }\n  get fragmentEnd() {\n    var _this$fragments;\n    if ((_this$fragments = this.fragments) != null && _this$fragments.length) {\n      return this.fragments[this.fragments.length - 1].end;\n    }\n    return 0;\n  }\n  get fragmentStart() {\n    var _this$fragments2;\n    if ((_this$fragments2 = this.fragments) != null && _this$fragments2.length) {\n      return this.fragments[0].start;\n    }\n    return 0;\n  }\n  get age() {\n    if (this.advancedDateTime) {\n      return Math.max(Date.now() - this.advancedDateTime, 0) / 1000;\n    }\n    return 0;\n  }\n  get lastPartIndex() {\n    var _this$partList2;\n    if ((_this$partList2 = this.partList) != null && _this$partList2.length) {\n      return this.partList[this.partList.length - 1].index;\n    }\n    return -1;\n  }\n  get maxPartIndex() {\n    const partList = this.partList;\n    if (partList) {\n      const lastIndex = this.lastPartIndex;\n      if (lastIndex !== -1) {\n        for (let i = partList.length; i--;) {\n          if (partList[i].index > lastIndex) {\n            return partList[i].index;\n          }\n        }\n        return lastIndex;\n      }\n    }\n    return 0;\n  }\n  get lastPartSn() {\n    var _this$partList3;\n    if ((_this$partList3 = this.partList) != null && _this$partList3.length) {\n      return this.partList[this.partList.length - 1].fragment.sn;\n    }\n    return this.endSN;\n  }\n  get expired() {\n    if (this.live && this.age && this.misses < 3) {\n      const playlistWindowDuration = this.partEnd - this.fragmentStart;\n      return this.age > Math.max(playlistWindowDuration, this.totalduration) + this.levelTargetDuration;\n    }\n    return false;\n  }\n}\n\nfunction isFullSegmentEncryption(method) {\n  return method === 'AES-128' || method === 'AES-256' || method === 'AES-256-CTR';\n}\nfunction getAesModeFromFullSegmentMethod(method) {\n  switch (method) {\n    case 'AES-128':\n    case 'AES-256':\n      return DecrypterAesMode.cbc;\n    case 'AES-256-CTR':\n      return DecrypterAesMode.ctr;\n    default:\n      throw new Error(`invalid full segment method ${method}`);\n  }\n}\n\nfunction base64Decode(base64encodedStr) {\n  return Uint8Array.from(atob(base64encodedStr), c => c.charCodeAt(0));\n}\n\n// breaking up those two types in order to clarify what is happening in the decoding path.\n\n// http://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript/22373197\n// http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt\n/* utf.js - UTF-8 <=> UTF-16 convertion\n *\n * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\n * Version: 1.0\n * LastModified: Dec 25 1999\n * This library is free.  You can redistribute it and/or modify it.\n */\n\nfunction strToUtf8array(str) {\n  return Uint8Array.from(unescape(encodeURIComponent(str)), c => c.charCodeAt(0));\n}\n\nfunction getKeyIdBytes(str) {\n  const keyIdbytes = strToUtf8array(str).subarray(0, 16);\n  const paddedkeyIdbytes = new Uint8Array(16);\n  paddedkeyIdbytes.set(keyIdbytes, 16 - keyIdbytes.length);\n  return paddedkeyIdbytes;\n}\nfunction changeEndianness(keyId) {\n  const swap = function swap(array, from, to) {\n    const cur = array[from];\n    array[from] = array[to];\n    array[to] = cur;\n  };\n  swap(keyId, 0, 3);\n  swap(keyId, 1, 2);\n  swap(keyId, 4, 5);\n  swap(keyId, 6, 7);\n}\nfunction convertDataUriToArrayBytes(uri) {\n  // data:[<media type][;attribute=value][;base64],<data>\n  const colonsplit = uri.split(':');\n  let keydata = null;\n  if (colonsplit[0] === 'data' && colonsplit.length === 2) {\n    const semicolonsplit = colonsplit[1].split(';');\n    const commasplit = semicolonsplit[semicolonsplit.length - 1].split(',');\n    if (commasplit.length === 2) {\n      const isbase64 = commasplit[0] === 'base64';\n      const data = commasplit[1];\n      if (isbase64) {\n        semicolonsplit.splice(-1, 1); // remove from processing\n        keydata = base64Decode(data);\n      } else {\n        keydata = getKeyIdBytes(data);\n      }\n    }\n  }\n  return keydata;\n}\n\n/** returns `undefined` is `self` is missing, e.g. in node */\nconst optionalSelf = typeof self !== 'undefined' ? self : undefined;\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess\n */\nvar KeySystems = {\n  CLEARKEY: \"org.w3.clearkey\",\n  FAIRPLAY: \"com.apple.fps\",\n  PLAYREADY: \"com.microsoft.playready\",\n  WIDEVINE: \"com.widevine.alpha\"\n};\n\n// Playlist #EXT-X-KEY KEYFORMAT values\nvar KeySystemFormats = {\n  CLEARKEY: \"org.w3.clearkey\",\n  FAIRPLAY: \"com.apple.streamingkeydelivery\",\n  PLAYREADY: \"com.microsoft.playready\",\n  WIDEVINE: \"urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed\"\n};\nfunction keySystemFormatToKeySystemDomain(format) {\n  switch (format) {\n    case KeySystemFormats.FAIRPLAY:\n      return KeySystems.FAIRPLAY;\n    case KeySystemFormats.PLAYREADY:\n      return KeySystems.PLAYREADY;\n    case KeySystemFormats.WIDEVINE:\n      return KeySystems.WIDEVINE;\n    case KeySystemFormats.CLEARKEY:\n      return KeySystems.CLEARKEY;\n  }\n}\nfunction keySystemDomainToKeySystemFormat(keySystem) {\n  switch (keySystem) {\n    case KeySystems.FAIRPLAY:\n      return KeySystemFormats.FAIRPLAY;\n    case KeySystems.PLAYREADY:\n      return KeySystemFormats.PLAYREADY;\n    case KeySystems.WIDEVINE:\n      return KeySystemFormats.WIDEVINE;\n    case KeySystems.CLEARKEY:\n      return KeySystemFormats.CLEARKEY;\n  }\n}\nfunction getKeySystemsForConfig(config) {\n  const {\n    drmSystems,\n    widevineLicenseUrl\n  } = config;\n  const keySystemsToAttempt = drmSystems ? [KeySystems.FAIRPLAY, KeySystems.WIDEVINE, KeySystems.PLAYREADY, KeySystems.CLEARKEY].filter(keySystem => !!drmSystems[keySystem]) : [];\n  if (!keySystemsToAttempt[KeySystems.WIDEVINE] && widevineLicenseUrl) {\n    keySystemsToAttempt.push(KeySystems.WIDEVINE);\n  }\n  return keySystemsToAttempt;\n}\nconst requestMediaKeySystemAccess = function (_optionalSelf$navigat) {\n  if (optionalSelf != null && (_optionalSelf$navigat = optionalSelf.navigator) != null && _optionalSelf$navigat.requestMediaKeySystemAccess) {\n    return self.navigator.requestMediaKeySystemAccess.bind(self.navigator);\n  } else {\n    return null;\n  }\n}();\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/MediaKeySystemConfiguration\n */\nfunction getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, drmSystemOptions) {\n  let initDataTypes;\n  switch (keySystem) {\n    case KeySystems.FAIRPLAY:\n      initDataTypes = ['cenc', 'sinf'];\n      break;\n    case KeySystems.WIDEVINE:\n    case KeySystems.PLAYREADY:\n      initDataTypes = ['cenc'];\n      break;\n    case KeySystems.CLEARKEY:\n      initDataTypes = ['cenc', 'keyids'];\n      break;\n    default:\n      throw new Error(`Unknown key-system: ${keySystem}`);\n  }\n  return createMediaKeySystemConfigurations(initDataTypes, audioCodecs, videoCodecs, drmSystemOptions);\n}\nfunction createMediaKeySystemConfigurations(initDataTypes, audioCodecs, videoCodecs, drmSystemOptions) {\n  const baseConfig = {\n    initDataTypes: initDataTypes,\n    persistentState: drmSystemOptions.persistentState || 'optional',\n    distinctiveIdentifier: drmSystemOptions.distinctiveIdentifier || 'optional',\n    sessionTypes: drmSystemOptions.sessionTypes || [drmSystemOptions.sessionType || 'temporary'],\n    audioCapabilities: audioCodecs.map(codec => ({\n      contentType: `audio/mp4; codecs=${codec}`,\n      robustness: drmSystemOptions.audioRobustness || '',\n      encryptionScheme: drmSystemOptions.audioEncryptionScheme || null\n    })),\n    videoCapabilities: videoCodecs.map(codec => ({\n      contentType: `video/mp4; codecs=${codec}`,\n      robustness: drmSystemOptions.videoRobustness || '',\n      encryptionScheme: drmSystemOptions.videoEncryptionScheme || null\n    }))\n  };\n  return [baseConfig];\n}\nfunction isPersistentSessionType(drmSystemOptions) {\n  var _drmSystemOptions$ses;\n  return drmSystemOptions.sessionType === 'persistent-license' || !!((_drmSystemOptions$ses = drmSystemOptions.sessionTypes) != null && _drmSystemOptions$ses.some(type => type === 'persistent-license'));\n}\nfunction parsePlayReadyWRM(keyBytes) {\n  const keyBytesUtf16 = new Uint16Array(keyBytes.buffer, keyBytes.byteOffset, keyBytes.byteLength / 2);\n  const keyByteStr = String.fromCharCode.apply(null, Array.from(keyBytesUtf16));\n\n  // Parse Playready WRMHeader XML\n  const xmlKeyBytes = keyByteStr.substring(keyByteStr.indexOf('<'), keyByteStr.length);\n  const parser = new DOMParser();\n  const xmlDoc = parser.parseFromString(xmlKeyBytes, 'text/xml');\n  const keyData = xmlDoc.getElementsByTagName('KID')[0];\n  if (keyData) {\n    const keyId = keyData.childNodes[0] ? keyData.childNodes[0].nodeValue : keyData.getAttribute('VALUE');\n    if (keyId) {\n      const keyIdArray = base64Decode(keyId).subarray(0, 16);\n      // KID value in PRO is a base64-encoded little endian GUID interpretation of UUID\n      // KID value in tenc is a big endian UUID GUID interpretation of UUID\n      changeEndianness(keyIdArray);\n      return keyIdArray;\n    }\n  }\n  return null;\n}\n\nlet keyUriToKeyIdMap = {};\nclass LevelKey {\n  static clearKeyUriToKeyIdMap() {\n    keyUriToKeyIdMap = {};\n  }\n  constructor(method, uri, format, formatversions = [1], iv = null, keyId) {\n    this.uri = void 0;\n    this.method = void 0;\n    this.keyFormat = void 0;\n    this.keyFormatVersions = void 0;\n    this.encrypted = void 0;\n    this.isCommonEncryption = void 0;\n    this.iv = null;\n    this.key = null;\n    this.keyId = null;\n    this.pssh = null;\n    this.method = method;\n    this.uri = uri;\n    this.keyFormat = format;\n    this.keyFormatVersions = formatversions;\n    this.iv = iv;\n    this.encrypted = method ? method !== 'NONE' : false;\n    this.isCommonEncryption = this.encrypted && !isFullSegmentEncryption(method);\n    if (keyId != null && keyId.startsWith('0x')) {\n      this.keyId = new Uint8Array(hexToArrayBuffer(keyId));\n    }\n  }\n  matches(key) {\n    var _key$iv, _this$iv;\n    return key.uri === this.uri && key.method === this.method && key.encrypted === this.encrypted && key.keyFormat === this.keyFormat && key.keyFormatVersions.join(',') === this.keyFormatVersions.join(',') && ((_key$iv = key.iv) == null ? void 0 : _key$iv.join(',')) === ((_this$iv = this.iv) == null ? void 0 : _this$iv.join(','));\n  }\n  isSupported() {\n    // If it's Segment encryption or No encryption, just select that key system\n    if (this.method) {\n      if (isFullSegmentEncryption(this.method) || this.method === 'NONE') {\n        return true;\n      }\n      if (this.keyFormat === 'identity') {\n        // Maintain support for clear SAMPLE-AES with MPEG-3 TS\n        return this.method === 'SAMPLE-AES';\n      } else {\n        switch (this.keyFormat) {\n          case KeySystemFormats.FAIRPLAY:\n          case KeySystemFormats.WIDEVINE:\n          case KeySystemFormats.PLAYREADY:\n          case KeySystemFormats.CLEARKEY:\n            return ['ISO-23001-7', 'SAMPLE-AES', 'SAMPLE-AES-CENC', 'SAMPLE-AES-CTR'].indexOf(this.method) !== -1;\n        }\n      }\n    }\n    return false;\n  }\n  getDecryptData(sn) {\n    if (!this.encrypted || !this.uri) {\n      return null;\n    }\n    if (isFullSegmentEncryption(this.method) && this.uri && !this.iv) {\n      if (typeof sn !== 'number') {\n        // We are fetching decryption data for a initialization segment\n        // If the segment was encrypted with AES-128/256\n        // It must have an IV defined. We cannot substitute the Segment Number in.\n        logger.warn(`missing IV for initialization segment with method=\"${this.method}\" - compliance issue`);\n\n        // Explicitly set sn to resulting value from implicit conversions 'initSegment' values for IV generation.\n        sn = 0;\n      }\n      const iv = createInitializationVector(sn);\n      const decryptdata = new LevelKey(this.method, this.uri, 'identity', this.keyFormatVersions, iv);\n      return decryptdata;\n    }\n    if (this.pssh && this.keyId) {\n      return this;\n    }\n\n    // Initialize keyId if possible\n    const keyBytes = convertDataUriToArrayBytes(this.uri);\n    if (keyBytes) {\n      switch (this.keyFormat) {\n        case KeySystemFormats.WIDEVINE:\n          // Setting `pssh` on this LevelKey/DecryptData allows HLS.js to generate a session using\n          // the playlist-key before the \"encrypted\" event. (Comment out to only use \"encrypted\" path.)\n          this.pssh = keyBytes;\n          // In case of Widevine, if KEYID is not in the playlist, assume only two fields in the pssh KEY tag URI.\n          if (!this.keyId && keyBytes.length >= 22) {\n            const offset = keyBytes.length - 22;\n            this.keyId = keyBytes.subarray(offset, offset + 16);\n          }\n          break;\n        case KeySystemFormats.PLAYREADY:\n          {\n            const PlayReadyKeySystemUUID = new Uint8Array([0x9a, 0x04, 0xf0, 0x79, 0x98, 0x40, 0x42, 0x86, 0xab, 0x92, 0xe6, 0x5b, 0xe0, 0x88, 0x5f, 0x95]);\n\n            // Setting `pssh` on this LevelKey/DecryptData allows HLS.js to generate a session using\n            // the playlist-key before the \"encrypted\" event. (Comment out to only use \"encrypted\" path.)\n            this.pssh = mp4pssh(PlayReadyKeySystemUUID, null, keyBytes);\n            this.keyId = parsePlayReadyWRM(keyBytes);\n            break;\n          }\n        default:\n          {\n            let keydata = keyBytes.subarray(0, 16);\n            if (keydata.length !== 16) {\n              const padded = new Uint8Array(16);\n              padded.set(keydata, 16 - keydata.length);\n              keydata = padded;\n            }\n            this.keyId = keydata;\n            break;\n          }\n      }\n    }\n\n    // Default behavior: assign a new keyId for each uri\n    if (!this.keyId || this.keyId.byteLength !== 16) {\n      let keyId = keyUriToKeyIdMap[this.uri];\n      if (!keyId) {\n        const val = Object.keys(keyUriToKeyIdMap).length % Number.MAX_SAFE_INTEGER;\n        keyId = new Uint8Array(16);\n        const dv = new DataView(keyId.buffer, 12, 4); // Just set the last 4 bytes\n        dv.setUint32(0, val);\n        keyUriToKeyIdMap[this.uri] = keyId;\n      }\n      this.keyId = keyId;\n    }\n    return this;\n  }\n}\nfunction createInitializationVector(segmentNumber) {\n  const uint8View = new Uint8Array(16);\n  for (let i = 12; i < 16; i++) {\n    uint8View[i] = segmentNumber >> 8 * (15 - i) & 0xff;\n  }\n  return uint8View;\n}\n\nconst MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\\r\\n]*)(?:[\\r\\n](?:#[^\\r\\n]*)?)*([^\\r\\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\\r\\n]*)[\\r\\n]+/g;\nconst MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;\nconst IS_MEDIA_PLAYLIST = /^#EXT(?:INF|-X-TARGETDURATION):/m; // Handle empty Media Playlist (first EXTINF not signaled, but TARGETDURATION present)\n\nconst LEVEL_PLAYLIST_REGEX_FAST = new RegExp([/#EXTINF:\\s*(\\d*(?:\\.\\d+)?)(?:,(.*)\\s+)?/.source,\n// duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title\n/(?!#) *(\\S[^\\r\\n]*)/.source,\n// segment URI, group 3 => the URI (note newline is not eaten)\n/#.*/.source // All other non-segment oriented tags will match with all groups empty\n].join('|'), 'g');\nconst LEVEL_PLAYLIST_REGEX_SLOW = new RegExp([/#EXT-X-(PROGRAM-DATE-TIME|BYTERANGE|DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP|INDEPENDENT-SEGMENTS)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\\r?\\n?/.source].join('|'));\nclass M3U8Parser {\n  static findGroup(groups, mediaGroupId) {\n    for (let i = 0; i < groups.length; i++) {\n      const group = groups[i];\n      if (group.id === mediaGroupId) {\n        return group;\n      }\n    }\n  }\n  static resolve(url, baseUrl) {\n    return urlToolkitExports.buildAbsoluteURL(baseUrl, url, {\n      alwaysNormalize: true\n    });\n  }\n  static isMediaPlaylist(str) {\n    return IS_MEDIA_PLAYLIST.test(str);\n  }\n  static parseMasterPlaylist(string, baseurl) {\n    const hasVariableRefs = hasVariableReferences(string) ;\n    const parsed = {\n      contentSteering: null,\n      levels: [],\n      playlistParsingError: null,\n      sessionData: null,\n      sessionKeys: null,\n      startTimeOffset: null,\n      variableList: null,\n      hasVariableRefs\n    };\n    const levelsWithKnownCodecs = [];\n    MASTER_PLAYLIST_REGEX.lastIndex = 0;\n    let result;\n    while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {\n      if (result[1]) {\n        var _level$unknownCodecs;\n        // '#EXT-X-STREAM-INF' is found, parse level tag  in group 1\n        const attrs = new AttrList(result[1], parsed);\n        const uri = substituteVariables(parsed, result[2]) ;\n        const level = {\n          attrs,\n          bitrate: attrs.decimalInteger('BANDWIDTH') || attrs.decimalInteger('AVERAGE-BANDWIDTH'),\n          name: attrs.NAME,\n          url: M3U8Parser.resolve(uri, baseurl)\n        };\n        const resolution = attrs.decimalResolution('RESOLUTION');\n        if (resolution) {\n          level.width = resolution.width;\n          level.height = resolution.height;\n        }\n        setCodecs(attrs.CODECS, level);\n        const supplementalCodecs = attrs['SUPPLEMENTAL-CODECS'];\n        if (supplementalCodecs) {\n          level.supplemental = {};\n          setCodecs(supplementalCodecs, level.supplemental);\n        }\n        if (!((_level$unknownCodecs = level.unknownCodecs) != null && _level$unknownCodecs.length)) {\n          levelsWithKnownCodecs.push(level);\n        }\n        parsed.levels.push(level);\n      } else if (result[3]) {\n        const tag = result[3];\n        const attributes = result[4];\n        switch (tag) {\n          case 'SESSION-DATA':\n            {\n              // #EXT-X-SESSION-DATA\n              const sessionAttrs = new AttrList(attributes, parsed);\n              const dataId = sessionAttrs['DATA-ID'];\n              if (dataId) {\n                if (parsed.sessionData === null) {\n                  parsed.sessionData = {};\n                }\n                parsed.sessionData[dataId] = sessionAttrs;\n              }\n              break;\n            }\n          case 'SESSION-KEY':\n            {\n              // #EXT-X-SESSION-KEY\n              const sessionKey = parseKey(attributes, baseurl, parsed);\n              if (sessionKey.encrypted && sessionKey.isSupported()) {\n                if (parsed.sessionKeys === null) {\n                  parsed.sessionKeys = [];\n                }\n                parsed.sessionKeys.push(sessionKey);\n              } else {\n                logger.warn(`[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: \"${attributes}\"`);\n              }\n              break;\n            }\n          case 'DEFINE':\n            {\n              // #EXT-X-DEFINE\n              {\n                const variableAttributes = new AttrList(attributes, parsed);\n                addVariableDefinition(parsed, variableAttributes, baseurl);\n              }\n              break;\n            }\n          case 'CONTENT-STEERING':\n            {\n              // #EXT-X-CONTENT-STEERING\n              const contentSteeringAttributes = new AttrList(attributes, parsed);\n              parsed.contentSteering = {\n                uri: M3U8Parser.resolve(contentSteeringAttributes['SERVER-URI'], baseurl),\n                pathwayId: contentSteeringAttributes['PATHWAY-ID'] || '.'\n              };\n              break;\n            }\n          case 'START':\n            {\n              // #EXT-X-START\n              parsed.startTimeOffset = parseStartTimeOffset(attributes);\n              break;\n            }\n        }\n      }\n    }\n    // Filter out levels with unknown codecs if it does not remove all levels\n    const stripUnknownCodecLevels = levelsWithKnownCodecs.length > 0 && levelsWithKnownCodecs.length < parsed.levels.length;\n    parsed.levels = stripUnknownCodecLevels ? levelsWithKnownCodecs : parsed.levels;\n    if (parsed.levels.length === 0) {\n      parsed.playlistParsingError = new Error('no levels found in manifest');\n    }\n    return parsed;\n  }\n  static parseMasterPlaylistMedia(string, baseurl, parsed) {\n    let result;\n    const results = {};\n    const levels = parsed.levels;\n    const groupsByType = {\n      AUDIO: levels.map(level => ({\n        id: level.attrs.AUDIO,\n        audioCodec: level.audioCodec\n      })),\n      SUBTITLES: levels.map(level => ({\n        id: level.attrs.SUBTITLES,\n        textCodec: level.textCodec\n      })),\n      'CLOSED-CAPTIONS': []\n    };\n    let id = 0;\n    MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;\n    while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) !== null) {\n      const attrs = new AttrList(result[1], parsed);\n      const type = attrs.TYPE;\n      if (type) {\n        const groups = groupsByType[type];\n        const medias = results[type] || [];\n        results[type] = medias;\n        const lang = attrs.LANGUAGE;\n        const assocLang = attrs['ASSOC-LANGUAGE'];\n        const channels = attrs.CHANNELS;\n        const characteristics = attrs.CHARACTERISTICS;\n        const instreamId = attrs['INSTREAM-ID'];\n        const media = {\n          attrs,\n          bitrate: 0,\n          id: id++,\n          groupId: attrs['GROUP-ID'] || '',\n          name: attrs.NAME || lang || '',\n          type,\n          default: attrs.bool('DEFAULT'),\n          autoselect: attrs.bool('AUTOSELECT'),\n          forced: attrs.bool('FORCED'),\n          lang,\n          url: attrs.URI ? M3U8Parser.resolve(attrs.URI, baseurl) : ''\n        };\n        if (assocLang) {\n          media.assocLang = assocLang;\n        }\n        if (channels) {\n          media.channels = channels;\n        }\n        if (characteristics) {\n          media.characteristics = characteristics;\n        }\n        if (instreamId) {\n          media.instreamId = instreamId;\n        }\n        if (groups != null && groups.length) {\n          // If there are audio or text groups signalled in the manifest, let's look for a matching codec string for this track\n          // If we don't find the track signalled, lets use the first audio groups codec we have\n          // Acting as a best guess\n          const groupCodec = M3U8Parser.findGroup(groups, media.groupId) || groups[0];\n          assignCodec(media, groupCodec, 'audioCodec');\n          assignCodec(media, groupCodec, 'textCodec');\n        }\n        medias.push(media);\n      }\n    }\n    return results;\n  }\n  static parseLevelPlaylist(string, baseurl, id, type, levelUrlId, multivariantVariableList) {\n    var _LEVEL_PLAYLIST_REGEX;\n    const base = {\n      url: baseurl\n    };\n    const level = new LevelDetails(baseurl);\n    const fragments = level.fragments;\n    const programDateTimes = [];\n    // The most recent init segment seen (applies to all subsequent segments)\n    let currentInitSegment = null;\n    let currentSN = 0;\n    let currentPart = 0;\n    let totalduration = 0;\n    let discontinuityCounter = 0;\n    let currentBitrate = 0;\n    let prevFrag = null;\n    let frag = new Fragment(type, base);\n    let result;\n    let i;\n    let levelkeys;\n    let firstPdtIndex = -1;\n    let createNextFrag = false;\n    let nextByteRange = null;\n    let serverControlAttrs;\n    LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;\n    level.m3u8 = string;\n    level.hasVariableRefs = hasVariableReferences(string) ;\n    if (((_LEVEL_PLAYLIST_REGEX = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) == null ? void 0 : _LEVEL_PLAYLIST_REGEX[0]) !== '#EXTM3U') {\n      level.playlistParsingError = new Error('Missing format identifier #EXTM3U');\n      return level;\n    }\n    while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {\n      if (createNextFrag) {\n        createNextFrag = false;\n        frag = new Fragment(type, base);\n        // setup the next fragment for part loading\n        frag.playlistOffset = totalduration;\n        frag.start = totalduration;\n        frag.sn = currentSN;\n        frag.cc = discontinuityCounter;\n        if (currentBitrate) {\n          frag.bitrate = currentBitrate;\n        }\n        frag.level = id;\n        if (currentInitSegment) {\n          frag.initSegment = currentInitSegment;\n          if (currentInitSegment.rawProgramDateTime) {\n            frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;\n            currentInitSegment.rawProgramDateTime = null;\n          }\n          if (nextByteRange) {\n            frag.setByteRange(nextByteRange);\n            nextByteRange = null;\n          }\n        }\n      }\n      const duration = result[1];\n      if (duration) {\n        // INF\n        frag.duration = parseFloat(duration);\n        // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n        const title = (' ' + result[2]).slice(1);\n        frag.title = title || null;\n        frag.tagList.push(title ? ['INF', duration, title] : ['INF', duration]);\n      } else if (result[3]) {\n        // url\n        if (isFiniteNumber(frag.duration)) {\n          frag.playlistOffset = totalduration;\n          frag.start = totalduration;\n          if (levelkeys) {\n            setFragLevelKeys(frag, levelkeys, level);\n          }\n          frag.sn = currentSN;\n          frag.level = id;\n          frag.cc = discontinuityCounter;\n          fragments.push(frag);\n          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n          const uri = (' ' + result[3]).slice(1);\n          frag.relurl = substituteVariables(level, uri) ;\n          assignProgramDateTime(frag, prevFrag, programDateTimes);\n          prevFrag = frag;\n          totalduration += frag.duration;\n          currentSN++;\n          currentPart = 0;\n          createNextFrag = true;\n        }\n      } else {\n        result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);\n        if (!result) {\n          logger.warn('No matches on slow regex match for level playlist!');\n          continue;\n        }\n        for (i = 1; i < result.length; i++) {\n          if (result[i] !== undefined) {\n            break;\n          }\n        }\n\n        // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n        const tag = (' ' + result[i]).slice(1);\n        const value1 = (' ' + result[i + 1]).slice(1);\n        const value2 = result[i + 2] ? (' ' + result[i + 2]).slice(1) : null;\n        switch (tag) {\n          case 'BYTERANGE':\n            if (prevFrag) {\n              frag.setByteRange(value1, prevFrag);\n            } else {\n              frag.setByteRange(value1);\n            }\n            break;\n          case 'PROGRAM-DATE-TIME':\n            // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n            frag.rawProgramDateTime = value1;\n            frag.tagList.push(['PROGRAM-DATE-TIME', value1]);\n            if (firstPdtIndex === -1) {\n              firstPdtIndex = fragments.length;\n            }\n            break;\n          case 'PLAYLIST-TYPE':\n            if (level.type) {\n              assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);\n            }\n            level.type = value1.toUpperCase();\n            break;\n          case 'MEDIA-SEQUENCE':\n            if (level.startSN !== 0) {\n              assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);\n            } else if (fragments.length > 0) {\n              assignMustAppearBeforeSegmentsError(level, tag, result);\n            }\n            currentSN = level.startSN = parseInt(value1);\n            break;\n          case 'SKIP':\n            {\n              if (level.skippedSegments) {\n                assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);\n              }\n              const skipAttrs = new AttrList(value1, level);\n              const skippedSegments = skipAttrs.decimalInteger('SKIPPED-SEGMENTS');\n              if (isFiniteNumber(skippedSegments)) {\n                level.skippedSegments += skippedSegments;\n                // This will result in fragments[] containing undefined values, which we will fill in with `mergeDetails`\n                for (let _i = skippedSegments; _i--;) {\n                  fragments.push(null);\n                }\n                currentSN += skippedSegments;\n              }\n              const recentlyRemovedDateranges = skipAttrs.enumeratedString('RECENTLY-REMOVED-DATERANGES');\n              if (recentlyRemovedDateranges) {\n                level.recentlyRemovedDateranges = (level.recentlyRemovedDateranges || []).concat(recentlyRemovedDateranges.split('\\t'));\n              }\n              break;\n            }\n          case 'TARGETDURATION':\n            if (level.targetduration !== 0) {\n              assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);\n            }\n            level.targetduration = Math.max(parseInt(value1), 1);\n            break;\n          case 'VERSION':\n            if (level.version !== null) {\n              assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);\n            }\n            level.version = parseInt(value1);\n            break;\n          case 'INDEPENDENT-SEGMENTS':\n            break;\n          case 'ENDLIST':\n            if (!level.live) {\n              assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);\n            }\n            level.live = false;\n            break;\n          case '#':\n            if (value1 || value2) {\n              frag.tagList.push(value2 ? [value1, value2] : [value1]);\n            }\n            break;\n          case 'DISCONTINUITY':\n            discontinuityCounter++;\n            frag.tagList.push(['DIS']);\n            break;\n          case 'GAP':\n            frag.gap = true;\n            frag.tagList.push([tag]);\n            break;\n          case 'BITRATE':\n            frag.tagList.push([tag, value1]);\n            currentBitrate = parseInt(value1) * 1000;\n            if (isFiniteNumber(currentBitrate)) {\n              frag.bitrate = currentBitrate;\n            } else {\n              currentBitrate = 0;\n            }\n            break;\n          case 'DATERANGE':\n            {\n              const dateRangeAttr = new AttrList(value1, level);\n              const dateRange = new DateRange(dateRangeAttr, level.dateRanges[dateRangeAttr.ID], level.dateRangeTagCount);\n              level.dateRangeTagCount++;\n              if (dateRange.isValid || level.skippedSegments) {\n                level.dateRanges[dateRange.id] = dateRange;\n              } else {\n                logger.warn(`Ignoring invalid DATERANGE tag: \"${value1}\"`);\n              }\n              // Add to fragment tag list for backwards compatibility (< v1.2.0)\n              frag.tagList.push(['EXT-X-DATERANGE', value1]);\n              break;\n            }\n          case 'DEFINE':\n            {\n              {\n                const variableAttributes = new AttrList(value1, level);\n                if ('IMPORT' in variableAttributes) {\n                  importVariableDefinition(level, variableAttributes, multivariantVariableList);\n                } else {\n                  addVariableDefinition(level, variableAttributes, baseurl);\n                }\n              }\n              break;\n            }\n          case 'DISCONTINUITY-SEQUENCE':\n            if (level.startCC !== 0) {\n              assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);\n            } else if (fragments.length > 0) {\n              assignMustAppearBeforeSegmentsError(level, tag, result);\n            }\n            level.startCC = discontinuityCounter = parseInt(value1);\n            break;\n          case 'KEY':\n            {\n              const levelKey = parseKey(value1, baseurl, level);\n              if (levelKey.isSupported()) {\n                if (levelKey.method === 'NONE') {\n                  levelkeys = undefined;\n                  break;\n                }\n                if (!levelkeys) {\n                  levelkeys = {};\n                }\n                const currentKey = levelkeys[levelKey.keyFormat];\n                // Ignore duplicate playlist KEY tags\n                if (!(currentKey != null && currentKey.matches(levelKey))) {\n                  if (currentKey) {\n                    levelkeys = _extends({}, levelkeys);\n                  }\n                  levelkeys[levelKey.keyFormat] = levelKey;\n                }\n              } else {\n                logger.warn(`[Keys] Ignoring invalid EXT-X-KEY tag: \"${value1}\"`);\n              }\n              break;\n            }\n          case 'START':\n            level.startTimeOffset = parseStartTimeOffset(value1);\n            break;\n          case 'MAP':\n            {\n              const mapAttrs = new AttrList(value1, level);\n              if (frag.duration) {\n                // Initial segment tag is after segment duration tag.\n                //   #EXTINF: 6.0\n                //   #EXT-X-MAP:URI=\"init.mp4\n                const init = new Fragment(type, base);\n                setInitSegment(init, mapAttrs, id, levelkeys);\n                currentInitSegment = init;\n                frag.initSegment = currentInitSegment;\n                if (currentInitSegment.rawProgramDateTime && !frag.rawProgramDateTime) {\n                  frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;\n                }\n              } else {\n                // Initial segment tag is before segment duration tag\n                // Handle case where EXT-X-MAP is declared after EXT-X-BYTERANGE\n                const end = frag.byteRangeEndOffset;\n                if (end) {\n                  const start = frag.byteRangeStartOffset;\n                  nextByteRange = `${end - start}@${start}`;\n                } else {\n                  nextByteRange = null;\n                }\n                setInitSegment(frag, mapAttrs, id, levelkeys);\n                currentInitSegment = frag;\n                createNextFrag = true;\n              }\n              currentInitSegment.cc = discontinuityCounter;\n              break;\n            }\n          case 'SERVER-CONTROL':\n            {\n              if (serverControlAttrs) {\n                assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);\n              }\n              serverControlAttrs = new AttrList(value1);\n              level.canBlockReload = serverControlAttrs.bool('CAN-BLOCK-RELOAD');\n              level.canSkipUntil = serverControlAttrs.optionalFloat('CAN-SKIP-UNTIL', 0);\n              level.canSkipDateRanges = level.canSkipUntil > 0 && serverControlAttrs.bool('CAN-SKIP-DATERANGES');\n              level.partHoldBack = serverControlAttrs.optionalFloat('PART-HOLD-BACK', 0);\n              level.holdBack = serverControlAttrs.optionalFloat('HOLD-BACK', 0);\n              break;\n            }\n          case 'PART-INF':\n            {\n              if (level.partTarget) {\n                assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);\n              }\n              const partInfAttrs = new AttrList(value1);\n              level.partTarget = partInfAttrs.decimalFloatingPoint('PART-TARGET');\n              break;\n            }\n          case 'PART':\n            {\n              let partList = level.partList;\n              if (!partList) {\n                partList = level.partList = [];\n              }\n              const previousFragmentPart = currentPart > 0 ? partList[partList.length - 1] : undefined;\n              const index = currentPart++;\n              const partAttrs = new AttrList(value1, level);\n              const part = new Part(partAttrs, frag, base, index, previousFragmentPart);\n              partList.push(part);\n              frag.duration += part.duration;\n              break;\n            }\n          case 'PRELOAD-HINT':\n            {\n              const preloadHintAttrs = new AttrList(value1, level);\n              level.preloadHint = preloadHintAttrs;\n              break;\n            }\n          case 'RENDITION-REPORT':\n            {\n              const renditionReportAttrs = new AttrList(value1, level);\n              level.renditionReports = level.renditionReports || [];\n              level.renditionReports.push(renditionReportAttrs);\n              break;\n            }\n          default:\n            logger.warn(`line parsed but not handled: ${result}`);\n            break;\n        }\n      }\n    }\n    if (prevFrag && !prevFrag.relurl) {\n      fragments.pop();\n      totalduration -= prevFrag.duration;\n      if (level.partList) {\n        level.fragmentHint = prevFrag;\n      }\n    } else if (level.partList) {\n      assignProgramDateTime(frag, prevFrag, programDateTimes);\n      frag.cc = discontinuityCounter;\n      level.fragmentHint = frag;\n      if (levelkeys) {\n        setFragLevelKeys(frag, levelkeys, level);\n      }\n    }\n    if (!level.targetduration) {\n      level.playlistParsingError = new Error(`#EXT-X-TARGETDURATION is required`);\n    }\n    const fragmentLength = fragments.length;\n    const firstFragment = fragments[0];\n    const lastFragment = fragments[fragmentLength - 1];\n    totalduration += level.skippedSegments * level.targetduration;\n    if (totalduration > 0 && fragmentLength && lastFragment) {\n      level.averagetargetduration = totalduration / fragmentLength;\n      const lastSn = lastFragment.sn;\n      level.endSN = lastSn !== 'initSegment' ? lastSn : 0;\n      if (!level.live) {\n        lastFragment.endList = true;\n      }\n      if (firstFragment && level.startCC === undefined) {\n        level.startCC = firstFragment.cc;\n      }\n      /**\n       * Backfill any missing PDT values\n       * \"If the first EXT-X-PROGRAM-DATE-TIME tag in a Playlist appears after\n       * one or more Media Segment URIs, the client SHOULD extrapolate\n       * backward from that tag (using EXTINF durations and/or media\n       * timestamps) to associate dates with those segments.\"\n       * We have already extrapolated forward, but all fragments up to the first instance of PDT do not have their PDTs\n       * computed.\n       */\n      if (firstPdtIndex > 0) {\n        backfillProgramDateTimes(fragments, firstPdtIndex);\n        if (firstFragment) {\n          programDateTimes.unshift(firstFragment);\n        }\n      }\n    } else {\n      level.endSN = 0;\n      level.startCC = 0;\n    }\n    if (level.fragmentHint) {\n      totalduration += level.fragmentHint.duration;\n    }\n    level.totalduration = totalduration;\n    if (programDateTimes.length && level.dateRangeTagCount && firstFragment) {\n      mapDateRanges(programDateTimes, level);\n    }\n    level.endCC = discontinuityCounter;\n    return level;\n  }\n}\nfunction mapDateRanges(programDateTimes, details) {\n  // Make sure DateRanges are mapped to a ProgramDateTime tag that applies a date to a segment that overlaps with its start date\n  const programDateTimeCount = programDateTimes.length;\n  if (!programDateTimeCount) {\n    return;\n  }\n  const lastProgramDateTime = programDateTimes[programDateTimeCount - 1];\n  const playlistEnd = details.live ? Infinity : details.totalduration;\n  const dateRangeIds = Object.keys(details.dateRanges);\n  for (let i = dateRangeIds.length; i--;) {\n    const dateRange = details.dateRanges[dateRangeIds[i]];\n    const startDateTime = dateRange.startDate.getTime();\n    dateRange.tagAnchor = lastProgramDateTime.ref;\n    for (let j = programDateTimeCount; j--;) {\n      const fragIndex = findFragmentWithStartDate(details, startDateTime, programDateTimes, j, playlistEnd);\n      if (fragIndex !== -1) {\n        dateRange.tagAnchor = details.fragments[fragIndex].ref;\n        break;\n      }\n    }\n  }\n}\nfunction findFragmentWithStartDate(details, startDateTime, programDateTimes, index, endTime) {\n  const pdtFragment = programDateTimes[index];\n  if (pdtFragment) {\n    // find matching range between PDT tags\n    const pdtStart = pdtFragment.programDateTime;\n    if (startDateTime >= pdtStart || index === 0) {\n      var _programDateTimes;\n      const durationBetweenPdt = (((_programDateTimes = programDateTimes[index + 1]) == null ? void 0 : _programDateTimes.start) || endTime) - pdtFragment.start;\n      if (startDateTime <= pdtStart + durationBetweenPdt * 1000) {\n        // map to fragment with date-time range\n        const startIndex = programDateTimes[index].sn - details.startSN;\n        const fragments = details.fragments;\n        if (fragments.length > programDateTimes.length) {\n          const endSegment = programDateTimes[index + 1] || fragments[fragments.length - 1];\n          const endIndex = endSegment.sn - details.startSN;\n          for (let i = endIndex; i > startIndex; i--) {\n            const fragStartDateTime = fragments[i].programDateTime;\n            if (startDateTime >= fragStartDateTime && startDateTime < fragStartDateTime + fragments[i].duration * 1000) {\n              return i;\n            }\n          }\n        }\n        return startIndex;\n      }\n    }\n  }\n  return -1;\n}\nfunction parseKey(keyTagAttributes, baseurl, parsed) {\n  var _keyAttrs$METHOD, _keyAttrs$KEYFORMAT;\n  // https://tools.ietf.org/html/rfc8216#section-4.3.2.4\n  const keyAttrs = new AttrList(keyTagAttributes, parsed);\n  const decryptmethod = (_keyAttrs$METHOD = keyAttrs.METHOD) != null ? _keyAttrs$METHOD : '';\n  const decrypturi = keyAttrs.URI;\n  const decryptiv = keyAttrs.hexadecimalInteger('IV');\n  const decryptkeyformatversions = keyAttrs.KEYFORMATVERSIONS;\n  // From RFC: This attribute is OPTIONAL; its absence indicates an implicit value of \"identity\".\n  const decryptkeyformat = (_keyAttrs$KEYFORMAT = keyAttrs.KEYFORMAT) != null ? _keyAttrs$KEYFORMAT : 'identity';\n  if (decrypturi && keyAttrs.IV && !decryptiv) {\n    logger.error(`Invalid IV: ${keyAttrs.IV}`);\n  }\n  // If decrypturi is a URI with a scheme, then baseurl will be ignored\n  // No uri is allowed when METHOD is NONE\n  const resolvedUri = decrypturi ? M3U8Parser.resolve(decrypturi, baseurl) : '';\n  const keyFormatVersions = (decryptkeyformatversions ? decryptkeyformatversions : '1').split('/').map(Number).filter(Number.isFinite);\n  return new LevelKey(decryptmethod, resolvedUri, decryptkeyformat, keyFormatVersions, decryptiv, keyAttrs.KEYID);\n}\nfunction parseStartTimeOffset(startAttributes) {\n  const startAttrs = new AttrList(startAttributes);\n  const startTimeOffset = startAttrs.decimalFloatingPoint('TIME-OFFSET');\n  if (isFiniteNumber(startTimeOffset)) {\n    return startTimeOffset;\n  }\n  return null;\n}\nfunction setCodecs(codecsAttributeValue, level) {\n  let codecs = (codecsAttributeValue || '').split(/[ ,]+/).filter(c => c);\n  ['video', 'audio', 'text'].forEach(type => {\n    const filtered = codecs.filter(codec => isCodecType(codec, type));\n    if (filtered.length) {\n      // Comma separated list of all codecs for type\n      level[`${type}Codec`] = filtered.map(c => c.split('/')[0]).join(',');\n      // Remove known codecs so that only unknownCodecs are left after iterating through each type\n      codecs = codecs.filter(codec => filtered.indexOf(codec) === -1);\n    }\n  });\n  level.unknownCodecs = codecs;\n}\nfunction assignCodec(media, groupItem, codecProperty) {\n  const codecValue = groupItem[codecProperty];\n  if (codecValue) {\n    media[codecProperty] = codecValue;\n  }\n}\nfunction backfillProgramDateTimes(fragments, firstPdtIndex) {\n  let fragPrev = fragments[firstPdtIndex];\n  for (let i = firstPdtIndex; i--;) {\n    const frag = fragments[i];\n    // Exit on delta-playlist skipped segments\n    if (!frag) {\n      return;\n    }\n    frag.programDateTime = fragPrev.programDateTime - frag.duration * 1000;\n    fragPrev = frag;\n  }\n}\nfunction assignProgramDateTime(frag, prevFrag, programDateTimes) {\n  if (frag.rawProgramDateTime) {\n    programDateTimes.push(frag);\n  } else if (prevFrag != null && prevFrag.programDateTime) {\n    frag.programDateTime = prevFrag.endProgramDateTime;\n  }\n}\nfunction setInitSegment(frag, mapAttrs, id, levelkeys) {\n  frag.relurl = mapAttrs.URI;\n  if (mapAttrs.BYTERANGE) {\n    frag.setByteRange(mapAttrs.BYTERANGE);\n  }\n  frag.level = id;\n  frag.sn = 'initSegment';\n  if (levelkeys) {\n    frag.levelkeys = levelkeys;\n  }\n  frag.initSegment = null;\n}\nfunction setFragLevelKeys(frag, levelkeys, level) {\n  frag.levelkeys = levelkeys;\n  const {\n    encryptedFragments\n  } = level;\n  if ((!encryptedFragments.length || encryptedFragments[encryptedFragments.length - 1].levelkeys !== levelkeys) && Object.keys(levelkeys).some(format => levelkeys[format].isCommonEncryption)) {\n    encryptedFragments.push(frag);\n  }\n}\nfunction assignMultipleMediaPlaylistTagOccuranceError(level, tag, result) {\n  level.playlistParsingError = new Error(`#EXT-X-${tag} must not appear more than once (${result[0]})`);\n}\nfunction assignMustAppearBeforeSegmentsError(level, tag, result) {\n  level.playlistParsingError = new Error(`#EXT-X-${tag} must appear before the first Media Segment (${result[0]})`);\n}\n\nfunction updateFromToPTS(fragFrom, fragTo) {\n  const fragToPTS = fragTo.startPTS;\n  // if we know startPTS[toIdx]\n  if (isFiniteNumber(fragToPTS)) {\n    // update fragment duration.\n    // it helps to fix drifts between playlist reported duration and fragment real duration\n    let duration = 0;\n    let frag;\n    if (fragTo.sn > fragFrom.sn) {\n      duration = fragToPTS - fragFrom.start;\n      frag = fragFrom;\n    } else {\n      duration = fragFrom.start - fragToPTS;\n      frag = fragTo;\n    }\n    if (frag.duration !== duration) {\n      frag.setDuration(duration);\n    }\n    // we dont know startPTS[toIdx]\n  } else if (fragTo.sn > fragFrom.sn) {\n    const contiguous = fragFrom.cc === fragTo.cc;\n    // TODO: With part-loading end/durations we need to confirm the whole fragment is loaded before using (or setting) minEndPTS\n    if (contiguous && fragFrom.minEndPTS) {\n      fragTo.setStart(fragFrom.start + (fragFrom.minEndPTS - fragFrom.start));\n    } else {\n      fragTo.setStart(fragFrom.start + fragFrom.duration);\n    }\n  } else {\n    fragTo.setStart(Math.max(fragFrom.start - fragTo.duration, 0));\n  }\n}\nfunction updateFragPTSDTS(details, frag, startPTS, endPTS, startDTS, endDTS) {\n  const parsedMediaDuration = endPTS - startPTS;\n  if (parsedMediaDuration <= 0) {\n    logger.warn('Fragment should have a positive duration', frag);\n    endPTS = startPTS + frag.duration;\n    endDTS = startDTS + frag.duration;\n  }\n  let maxStartPTS = startPTS;\n  let minEndPTS = endPTS;\n  const fragStartPts = frag.startPTS;\n  const fragEndPts = frag.endPTS;\n  if (isFiniteNumber(fragStartPts)) {\n    // delta PTS between audio and video\n    const deltaPTS = Math.abs(fragStartPts - startPTS);\n    if (!isFiniteNumber(frag.deltaPTS)) {\n      frag.deltaPTS = deltaPTS;\n    } else {\n      frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);\n    }\n    maxStartPTS = Math.max(startPTS, fragStartPts);\n    startPTS = Math.min(startPTS, fragStartPts);\n    startDTS = Math.min(startDTS, frag.startDTS);\n    minEndPTS = Math.min(endPTS, fragEndPts);\n    endPTS = Math.max(endPTS, fragEndPts);\n    endDTS = Math.max(endDTS, frag.endDTS);\n  }\n  const drift = startPTS - frag.start;\n  if (frag.start !== 0) {\n    frag.setStart(startPTS);\n  }\n  frag.setDuration(endPTS - frag.start);\n  frag.startPTS = startPTS;\n  frag.maxStartPTS = maxStartPTS;\n  frag.startDTS = startDTS;\n  frag.endPTS = endPTS;\n  frag.minEndPTS = minEndPTS;\n  frag.endDTS = endDTS;\n  const sn = frag.sn;\n  // exit if sn out of range\n  if (!details || sn < details.startSN || sn > details.endSN) {\n    return 0;\n  }\n  let i;\n  const fragIdx = sn - details.startSN;\n  const fragments = details.fragments;\n  // update frag reference in fragments array\n  // rationale is that fragments array might not contain this frag object.\n  // this will happen if playlist has been refreshed between frag loading and call to updateFragPTSDTS()\n  // if we don't update frag, we won't be able to propagate PTS info on the playlist\n  // resulting in invalid sliding computation\n  fragments[fragIdx] = frag;\n  // adjust fragment PTS/duration from seqnum-1 to frag 0\n  for (i = fragIdx; i > 0; i--) {\n    updateFromToPTS(fragments[i], fragments[i - 1]);\n  }\n\n  // adjust fragment PTS/duration from seqnum to last frag\n  for (i = fragIdx; i < fragments.length - 1; i++) {\n    updateFromToPTS(fragments[i], fragments[i + 1]);\n  }\n  if (details.fragmentHint) {\n    updateFromToPTS(fragments[fragments.length - 1], details.fragmentHint);\n  }\n  details.PTSKnown = details.alignedSliding = true;\n  return drift;\n}\nfunction mergeDetails(oldDetails, newDetails) {\n  if (oldDetails === newDetails) {\n    return;\n  }\n  // Track the last initSegment processed. Initialize it to the last one on the timeline.\n  let currentInitSegment = null;\n  const oldFragments = oldDetails.fragments;\n  for (let i = oldFragments.length - 1; i >= 0; i--) {\n    const oldInit = oldFragments[i].initSegment;\n    if (oldInit) {\n      currentInitSegment = oldInit;\n      break;\n    }\n  }\n  if (oldDetails.fragmentHint) {\n    // prevent PTS and duration from being adjusted on the next hint\n    delete oldDetails.fragmentHint.endPTS;\n  }\n  // check if old/new playlists have fragments in common\n  // loop through overlapping SN and update startPTS, cc, and duration if any found\n  let PTSFrag;\n  mapFragmentIntersection(oldDetails, newDetails, (oldFrag, newFrag, newFragIndex, newFragments) => {\n    if ((!newDetails.startCC || newDetails.skippedSegments) && newFrag.cc !== oldFrag.cc) {\n      const ccOffset = oldFrag.cc - newFrag.cc;\n      for (let i = newFragIndex; i < newFragments.length; i++) {\n        newFragments[i].cc += ccOffset;\n      }\n      newDetails.endCC = newFragments[newFragments.length - 1].cc;\n    }\n    if (isFiniteNumber(oldFrag.startPTS) && isFiniteNumber(oldFrag.endPTS)) {\n      newFrag.setStart(newFrag.startPTS = oldFrag.startPTS);\n      newFrag.startDTS = oldFrag.startDTS;\n      newFrag.maxStartPTS = oldFrag.maxStartPTS;\n      newFrag.endPTS = oldFrag.endPTS;\n      newFrag.endDTS = oldFrag.endDTS;\n      newFrag.minEndPTS = oldFrag.minEndPTS;\n      newFrag.setDuration(oldFrag.endPTS - oldFrag.startPTS);\n      if (newFrag.duration) {\n        PTSFrag = newFrag;\n      }\n\n      // PTS is known when any segment has startPTS and endPTS\n      newDetails.PTSKnown = newDetails.alignedSliding = true;\n    }\n    if (oldFrag.hasStreams) {\n      newFrag.elementaryStreams = oldFrag.elementaryStreams;\n    }\n    newFrag.loader = oldFrag.loader;\n    if (oldFrag.hasStats) {\n      newFrag.stats = oldFrag.stats;\n    }\n    if (oldFrag.initSegment) {\n      newFrag.initSegment = oldFrag.initSegment;\n      currentInitSegment = oldFrag.initSegment;\n    }\n  });\n  const newFragments = newDetails.fragments;\n  const fragmentsToCheck = newDetails.fragmentHint ? newFragments.concat(newDetails.fragmentHint) : newFragments;\n  if (currentInitSegment) {\n    fragmentsToCheck.forEach(frag => {\n      var _currentInitSegment;\n      if (frag && (!frag.initSegment || frag.initSegment.relurl === ((_currentInitSegment = currentInitSegment) == null ? void 0 : _currentInitSegment.relurl))) {\n        frag.initSegment = currentInitSegment;\n      }\n    });\n  }\n  if (newDetails.skippedSegments) {\n    newDetails.deltaUpdateFailed = newFragments.some(frag => !frag);\n    if (newDetails.deltaUpdateFailed) {\n      logger.warn('[level-helper] Previous playlist missing segments skipped in delta playlist');\n      for (let i = newDetails.skippedSegments; i--;) {\n        newFragments.shift();\n      }\n      newDetails.startSN = newFragments[0].sn;\n    } else {\n      if (newDetails.canSkipDateRanges) {\n        newDetails.dateRanges = mergeDateRanges(oldDetails.dateRanges, newDetails);\n      }\n      const programDateTimes = oldDetails.fragments.filter(frag => frag.rawProgramDateTime);\n      if (oldDetails.hasProgramDateTime && !newDetails.hasProgramDateTime) {\n        for (let i = 1; i < fragmentsToCheck.length; i++) {\n          if (fragmentsToCheck[i].programDateTime === null) {\n            assignProgramDateTime(fragmentsToCheck[i], fragmentsToCheck[i - 1], programDateTimes);\n          }\n        }\n      }\n      mapDateRanges(programDateTimes, newDetails);\n    }\n    newDetails.endCC = newFragments[newFragments.length - 1].cc;\n  }\n  if (!newDetails.startCC) {\n    var _fragPriorToNewStart$;\n    const fragPriorToNewStart = getFragmentWithSN(oldDetails, newDetails.startSN - 1);\n    newDetails.startCC = (_fragPriorToNewStart$ = fragPriorToNewStart == null ? void 0 : fragPriorToNewStart.cc) != null ? _fragPriorToNewStart$ : newFragments[0].cc;\n  }\n\n  // Merge parts\n  mapPartIntersection(oldDetails.partList, newDetails.partList, (oldPart, newPart) => {\n    newPart.elementaryStreams = oldPart.elementaryStreams;\n    newPart.stats = oldPart.stats;\n  });\n\n  // if at least one fragment contains PTS info, recompute PTS information for all fragments\n  if (PTSFrag) {\n    updateFragPTSDTS(newDetails, PTSFrag, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);\n  } else {\n    // ensure that delta is within oldFragments range\n    // also adjust sliding in case delta is 0 (we could have old=[50-60] and new=old=[50-61])\n    // in that case we also need to adjust start offset of all fragments\n    adjustSliding(oldDetails, newDetails);\n  }\n  if (newFragments.length) {\n    newDetails.totalduration = newDetails.edge - newFragments[0].start;\n  }\n  newDetails.driftStartTime = oldDetails.driftStartTime;\n  newDetails.driftStart = oldDetails.driftStart;\n  const advancedDateTime = newDetails.advancedDateTime;\n  if (newDetails.advanced && advancedDateTime) {\n    const edge = newDetails.edge;\n    if (!newDetails.driftStart) {\n      newDetails.driftStartTime = advancedDateTime;\n      newDetails.driftStart = edge;\n    }\n    newDetails.driftEndTime = advancedDateTime;\n    newDetails.driftEnd = edge;\n  } else {\n    newDetails.driftEndTime = oldDetails.driftEndTime;\n    newDetails.driftEnd = oldDetails.driftEnd;\n    newDetails.advancedDateTime = oldDetails.advancedDateTime;\n  }\n  if (newDetails.requestScheduled === -1) {\n    newDetails.requestScheduled = oldDetails.requestScheduled;\n  }\n}\nfunction mergeDateRanges(oldDateRanges, newDetails) {\n  const {\n    dateRanges: deltaDateRanges,\n    recentlyRemovedDateranges\n  } = newDetails;\n  const dateRanges = _extends({}, oldDateRanges);\n  if (recentlyRemovedDateranges) {\n    recentlyRemovedDateranges.forEach(id => {\n      delete dateRanges[id];\n    });\n  }\n  const mergeIds = Object.keys(dateRanges);\n  const mergeCount = mergeIds.length;\n  if (mergeCount) {\n    Object.keys(deltaDateRanges).forEach(id => {\n      const mergedDateRange = dateRanges[id];\n      const dateRange = new DateRange(deltaDateRanges[id].attr, mergedDateRange);\n      if (dateRange.isValid) {\n        dateRanges[id] = dateRange;\n        if (!mergedDateRange) {\n          dateRange.tagOrder += mergeCount;\n        }\n      } else {\n        logger.warn(`Ignoring invalid Playlist Delta Update DATERANGE tag: \"${stringify(deltaDateRanges[id].attr)}\"`);\n      }\n    });\n  }\n  return dateRanges;\n}\nfunction mapPartIntersection(oldParts, newParts, intersectionFn) {\n  if (oldParts && newParts) {\n    let delta = 0;\n    for (let i = 0, len = oldParts.length; i <= len; i++) {\n      const oldPart = oldParts[i];\n      const newPart = newParts[i + delta];\n      if (oldPart && newPart && oldPart.index === newPart.index && oldPart.fragment.sn === newPart.fragment.sn) {\n        intersectionFn(oldPart, newPart);\n      } else {\n        delta--;\n      }\n    }\n  }\n}\nfunction mapFragmentIntersection(oldDetails, newDetails, intersectionFn) {\n  const skippedSegments = newDetails.skippedSegments;\n  const start = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN;\n  const end = (oldDetails.fragmentHint ? 1 : 0) + (skippedSegments ? newDetails.endSN : Math.min(oldDetails.endSN, newDetails.endSN)) - newDetails.startSN;\n  const delta = newDetails.startSN - oldDetails.startSN;\n  const newFrags = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;\n  const oldFrags = oldDetails.fragmentHint ? oldDetails.fragments.concat(oldDetails.fragmentHint) : oldDetails.fragments;\n  for (let i = start; i <= end; i++) {\n    const oldFrag = oldFrags[delta + i];\n    let newFrag = newFrags[i];\n    if (skippedSegments && !newFrag && oldFrag) {\n      // Fill in skipped segments in delta playlist\n      newFrag = newDetails.fragments[i] = oldFrag;\n    }\n    if (oldFrag && newFrag) {\n      intersectionFn(oldFrag, newFrag, i, newFrags);\n      if (oldFrag.url && oldFrag.url !== newFrag.url) {\n        newDetails.playlistParsingError = getSequenceError(`media sequence mismatch ${newFrag.sn}:`, oldDetails, newDetails, oldFrag, newFrag);\n        return;\n      } else if (oldFrag.cc !== newFrag.cc) {\n        newDetails.playlistParsingError = getSequenceError(`discontinuity sequence mismatch (${oldFrag.cc}!=${newFrag.cc})`, oldDetails, newDetails, oldFrag, newFrag);\n        return;\n      }\n    }\n  }\n}\nfunction getSequenceError(message, oldDetails, newDetails, oldFrag, newFrag) {\n  return new Error(`${message} ${newFrag.url}\nPlaylist starting @${oldDetails.startSN}\n${oldDetails.m3u8}\n\nPlaylist starting @${newDetails.startSN}\n${newDetails.m3u8}`);\n}\nfunction adjustSliding(oldDetails, newDetails, matchingStableVariantOrRendition = true) {\n  const delta = newDetails.startSN + newDetails.skippedSegments - oldDetails.startSN;\n  const oldFragments = oldDetails.fragments;\n  const advancedOrStable = delta >= 0;\n  let sliding = 0;\n  if (advancedOrStable && delta < oldFragments.length) {\n    sliding = oldFragments[delta].start;\n  } else if (advancedOrStable && newDetails.startSN === oldDetails.endSN + 1) {\n    sliding = oldDetails.fragmentEnd;\n  } else if (advancedOrStable && matchingStableVariantOrRendition) {\n    // align with expected position (updated playlist start sequence is past end sequence of last update)\n    sliding = oldDetails.fragmentStart + delta * newDetails.levelTargetDuration;\n  } else if (!newDetails.skippedSegments && newDetails.fragmentStart === 0) {\n    // align new start with old (playlist switch has a sequence with no overlap and should not be used for alignment)\n    sliding = oldDetails.fragmentStart;\n  } else {\n    // new details already has a sliding offset or has skipped segments\n    return;\n  }\n  addSliding(newDetails, sliding);\n}\nfunction addSliding(details, sliding) {\n  if (sliding) {\n    const fragments = details.fragments;\n    for (let i = details.skippedSegments; i < fragments.length; i++) {\n      fragments[i].addStart(sliding);\n    }\n    if (details.fragmentHint) {\n      details.fragmentHint.addStart(sliding);\n    }\n  }\n}\nfunction computeReloadInterval(newDetails, distanceToLiveEdgeMs = Infinity) {\n  let reloadInterval = 1000 * newDetails.targetduration;\n  if (newDetails.updated) {\n    // Use last segment duration when shorter than target duration and near live edge\n    const fragments = newDetails.fragments;\n    const liveEdgeMaxTargetDurations = 4;\n    if (fragments.length && reloadInterval * liveEdgeMaxTargetDurations > distanceToLiveEdgeMs) {\n      const lastSegmentDuration = fragments[fragments.length - 1].duration * 1000;\n      if (lastSegmentDuration < reloadInterval) {\n        reloadInterval = lastSegmentDuration;\n      }\n    }\n  } else {\n    // estimate = 'miss half average';\n    // follow HLS Spec, If the client reloads a Playlist file and finds that it has not\n    // changed then it MUST wait for a period of one-half the target\n    // duration before retrying.\n    reloadInterval /= 2;\n  }\n  return Math.round(reloadInterval);\n}\nfunction getFragmentWithSN(details, sn, fragCurrent) {\n  if (!details) {\n    return null;\n  }\n  let fragment = details.fragments[sn - details.startSN];\n  if (fragment) {\n    return fragment;\n  }\n  fragment = details.fragmentHint;\n  if (fragment && fragment.sn === sn) {\n    return fragment;\n  }\n  if (sn < details.startSN && fragCurrent && fragCurrent.sn === sn) {\n    return fragCurrent;\n  }\n  return null;\n}\nfunction getPartWith(details, sn, partIndex) {\n  if (!details) {\n    return null;\n  }\n  return findPart(details.partList, sn, partIndex);\n}\nfunction findPart(partList, sn, partIndex) {\n  if (partList) {\n    for (let i = partList.length; i--;) {\n      const part = partList[i];\n      if (part.index === partIndex && part.fragment.sn === sn) {\n        return part;\n      }\n    }\n  }\n  return null;\n}\nfunction reassignFragmentLevelIndexes(levels) {\n  levels.forEach((level, index) => {\n    var _level$details;\n    (_level$details = level.details) == null ? void 0 : _level$details.fragments.forEach(fragment => {\n      fragment.level = index;\n      if (fragment.initSegment) {\n        fragment.initSegment.level = index;\n      }\n    });\n  });\n}\n\nfunction findFirstFragWithCC(fragments, cc) {\n  for (let i = 0, len = fragments.length; i < len; i++) {\n    var _fragments$i;\n    if (((_fragments$i = fragments[i]) == null ? void 0 : _fragments$i.cc) === cc) {\n      return fragments[i];\n    }\n  }\n  return null;\n}\nfunction shouldAlignOnDiscontinuities(refDetails, details) {\n  if (refDetails) {\n    if (details.startCC < refDetails.endCC && details.endCC > refDetails.startCC) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction adjustFragmentStart(frag, sliding) {\n  if (frag) {\n    const start = frag.start + sliding;\n    frag.start = frag.startPTS = start;\n    frag.endPTS = start + frag.duration;\n  }\n}\nfunction adjustSlidingStart(sliding, details) {\n  // Update segments\n  const fragments = details.fragments;\n  for (let i = 0, len = fragments.length; i < len; i++) {\n    adjustFragmentStart(fragments[i], sliding);\n  }\n  // Update LL-HLS parts at the end of the playlist\n  if (details.fragmentHint) {\n    adjustFragmentStart(details.fragmentHint, sliding);\n  }\n  details.alignedSliding = true;\n}\n\n/**\n * Using the parameters of the last level, this function computes PTS' of the new fragments so that they form a\n * contiguous stream with the last fragments.\n * The PTS of a fragment lets Hls.js know where it fits into a stream - by knowing every PTS, we know which fragment to\n * download at any given time. PTS is normally computed when the fragment is demuxed, so taking this step saves us time\n * and an extra download.\n * @param lastLevel\n * @param details\n */\nfunction alignStream(switchDetails, details) {\n  if (!switchDetails) {\n    return;\n  }\n  alignDiscontinuities(details, switchDetails);\n  if (!details.alignedSliding && switchDetails) {\n    // If the PTS wasn't figured out via discontinuity sequence that means there was no CC increase within the level.\n    // Aligning via Program Date Time should therefore be reliable, since PDT should be the same within the same\n    // discontinuity sequence.\n    alignMediaPlaylistByPDT(details, switchDetails);\n  }\n  if (!details.alignedSliding && switchDetails && !details.skippedSegments) {\n    // Try to align on sn so that we pick a better start fragment.\n    // Do not perform this on playlists with delta updates as this is only to align levels on switch\n    // and adjustSliding only adjusts fragments after skippedSegments.\n    adjustSliding(switchDetails, details, false);\n  }\n}\n\n/**\n * Ajust the start of fragments in `details` by the difference in time between fragments of the latest\n * shared discontinuity sequence change.\n * @param lastLevel - The details of the last loaded level\n * @param details - The details of the new level\n */\nfunction alignDiscontinuities(details, refDetails) {\n  if (!shouldAlignOnDiscontinuities(refDetails, details)) {\n    return;\n  }\n  const targetCC = Math.min(refDetails.endCC, details.endCC);\n  const refFrag = findFirstFragWithCC(refDetails.fragments, targetCC);\n  const frag = findFirstFragWithCC(details.fragments, targetCC);\n  if (!refFrag || !frag) {\n    return;\n  }\n  logger.log(`Aligning playlist at start of dicontinuity sequence ${targetCC}`);\n  const delta = refFrag.start - frag.start;\n  adjustSlidingStart(delta, details);\n}\n\n/**\n * Ensures appropriate time-alignment between renditions based on PDT.\n * This function assumes the timelines represented in `refDetails` are accurate, including the PDTs\n * for the last discontinuity sequence number shared by both playlists when present,\n * and uses the \"wallclock\"/PDT timeline as a cross-reference to `details`, adjusting the presentation\n * times/timelines of `details` accordingly.\n * Given the asynchronous nature of fetches and initial loads of live `main` and audio/subtitle tracks,\n * the primary purpose of this function is to ensure the \"local timelines\" of audio/subtitle tracks\n * are aligned to the main/video timeline, using PDT as the cross-reference/\"anchor\" that should\n * be consistent across playlists, per the HLS spec.\n * @param details - The details of the rendition you'd like to time-align (e.g. an audio rendition).\n * @param refDetails - The details of the reference rendition with start and PDT times for alignment.\n */\nfunction alignMediaPlaylistByPDT(details, refDetails) {\n  if (!details.hasProgramDateTime || !refDetails.hasProgramDateTime) {\n    return;\n  }\n  const fragments = details.fragments;\n  const refFragments = refDetails.fragments;\n  if (!fragments.length || !refFragments.length) {\n    return;\n  }\n\n  // Calculate a delta to apply to all fragments according to the delta in PDT times and start times\n  // of a fragment in the reference details, and a fragment in the target details of the same discontinuity.\n  // If a fragment of the same discontinuity was not found use the middle fragment of both.\n  let refFrag;\n  let frag;\n  const targetCC = Math.min(refDetails.endCC, details.endCC);\n  if (refDetails.startCC < targetCC && details.startCC < targetCC) {\n    refFrag = findFirstFragWithCC(refFragments, targetCC);\n    frag = findFirstFragWithCC(fragments, targetCC);\n  }\n  if (!refFrag || !frag) {\n    refFrag = refFragments[Math.floor(refFragments.length / 2)];\n    frag = findFirstFragWithCC(fragments, refFrag.cc) || fragments[Math.floor(fragments.length / 2)];\n  }\n  const refPDT = refFrag.programDateTime;\n  const targetPDT = frag.programDateTime;\n  if (!refPDT || !targetPDT) {\n    return;\n  }\n  const delta = (targetPDT - refPDT) / 1000 - (frag.start - refFrag.start);\n  adjustSlidingStart(delta, details);\n}\n\n/**\n *  TimeRanges to string helper\n */\n\nconst TimeRanges = {\n  toString: function (r) {\n    let log = '';\n    const len = r.length;\n    for (let i = 0; i < len; i++) {\n      log += `[${r.start(i).toFixed(3)}-${r.end(i).toFixed(3)}]`;\n    }\n    return log;\n  }\n};\n\nconst State = {\n  STOPPED: 'STOPPED',\n  IDLE: 'IDLE',\n  KEY_LOADING: 'KEY_LOADING',\n  FRAG_LOADING: 'FRAG_LOADING',\n  FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',\n  WAITING_TRACK: 'WAITING_TRACK',\n  PARSING: 'PARSING',\n  PARSED: 'PARSED',\n  ENDED: 'ENDED',\n  ERROR: 'ERROR',\n  WAITING_INIT_PTS: 'WAITING_INIT_PTS',\n  WAITING_LEVEL: 'WAITING_LEVEL'\n};\nclass BaseStreamController extends TaskLoop {\n  constructor(hls, fragmentTracker, keyLoader, logPrefix, playlistType) {\n    super(logPrefix, hls.logger);\n    this.hls = void 0;\n    this.fragPrevious = null;\n    this.fragCurrent = null;\n    this.fragmentTracker = void 0;\n    this.transmuxer = null;\n    this._state = State.STOPPED;\n    this.playlistType = void 0;\n    this.media = null;\n    this.mediaBuffer = null;\n    this.config = void 0;\n    this.bitrateTest = false;\n    this.lastCurrentTime = 0;\n    this.nextLoadPosition = 0;\n    this.startPosition = 0;\n    this.startTimeOffset = null;\n    this.retryDate = 0;\n    this.levels = null;\n    this.fragmentLoader = void 0;\n    this.keyLoader = void 0;\n    this.levelLastLoaded = null;\n    this.startFragRequested = false;\n    this.decrypter = void 0;\n    this.initPTS = [];\n    this.buffering = true;\n    this.loadingParts = false;\n    this.loopSn = void 0;\n    this.onMediaSeeking = () => {\n      const {\n        config,\n        fragCurrent,\n        media,\n        mediaBuffer,\n        state\n      } = this;\n      const currentTime = media ? media.currentTime : 0;\n      const bufferInfo = BufferHelper.bufferInfo(mediaBuffer ? mediaBuffer : media, currentTime, config.maxBufferHole);\n      const noFowardBuffer = !bufferInfo.len;\n      this.log(`Media seeking to ${isFiniteNumber(currentTime) ? currentTime.toFixed(3) : currentTime}, state: ${state}, ${noFowardBuffer ? 'out of' : 'in'} buffer`);\n      if (this.state === State.ENDED) {\n        this.resetLoadingState();\n      } else if (fragCurrent) {\n        // Seeking while frag load is in progress\n        const tolerance = config.maxFragLookUpTolerance;\n        const fragStartOffset = fragCurrent.start - tolerance;\n        const fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;\n        // if seeking out of buffered range or into new one\n        if (noFowardBuffer || fragEndOffset < bufferInfo.start || fragStartOffset > bufferInfo.end) {\n          const pastFragment = currentTime > fragEndOffset;\n          // if the seek position is outside the current fragment range\n          if (currentTime < fragStartOffset || pastFragment) {\n            if (pastFragment && fragCurrent.loader) {\n              this.log(`Cancelling fragment load for seek (sn: ${fragCurrent.sn})`);\n              fragCurrent.abortRequests();\n              this.resetLoadingState();\n            }\n            this.fragPrevious = null;\n          }\n        }\n      }\n      if (media) {\n        // Remove gap fragments\n        this.fragmentTracker.removeFragmentsInRange(currentTime, Infinity, this.playlistType, true);\n\n        // Don't set lastCurrentTime with backward seeks (allows for frag selection with strict tolerances)\n        const lastCurrentTime = this.lastCurrentTime;\n        if (currentTime > lastCurrentTime) {\n          this.lastCurrentTime = currentTime;\n        }\n        if (!this.loadingParts) {\n          const bufferEnd = Math.max(bufferInfo.end, currentTime);\n          const shouldLoadParts = this.shouldLoadParts(this.getLevelDetails(), bufferEnd);\n          if (shouldLoadParts) {\n            this.log(`LL-Part loading ON after seeking to ${currentTime.toFixed(2)} with buffer @${bufferEnd.toFixed(2)}`);\n            this.loadingParts = shouldLoadParts;\n          }\n        }\n      }\n\n      // in case seeking occurs although no media buffered, adjust startPosition and nextLoadPosition to seek target\n      if (!this.hls.hasEnoughToStart) {\n        this.log(`Setting ${noFowardBuffer ? 'startPosition' : 'nextLoadPosition'} to ${currentTime} for seek without enough to start`);\n        this.nextLoadPosition = currentTime;\n        if (noFowardBuffer) {\n          this.startPosition = currentTime;\n        }\n      }\n\n      // Async tick to speed up processing\n      this.tickImmediate();\n    };\n    this.onMediaEnded = () => {\n      // reset startPosition and lastCurrentTime to restart playback @ stream beginning\n      this.log(`setting startPosition to 0 because media ended`);\n      this.startPosition = this.lastCurrentTime = 0;\n    };\n    this.playlistType = playlistType;\n    this.hls = hls;\n    this.fragmentLoader = new FragmentLoader(hls.config);\n    this.keyLoader = keyLoader;\n    this.fragmentTracker = fragmentTracker;\n    this.config = hls.config;\n    this.decrypter = new Decrypter(hls.config);\n  }\n  registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.on(Events.ERROR, this.onError, this);\n  }\n  unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.off(Events.ERROR, this.onError, this);\n  }\n  doTick() {\n    this.onTickEnd();\n  }\n  onTickEnd() {}\n  startLoad(startPosition) {}\n  stopLoad() {\n    if (this.state === State.STOPPED) {\n      return;\n    }\n    this.fragmentLoader.abort();\n    this.keyLoader.abort(this.playlistType);\n    const frag = this.fragCurrent;\n    if (frag != null && frag.loader) {\n      frag.abortRequests();\n      this.fragmentTracker.removeFragment(frag);\n    }\n    this.resetTransmuxer();\n    this.fragCurrent = null;\n    this.fragPrevious = null;\n    this.clearInterval();\n    this.clearNextTick();\n    this.state = State.STOPPED;\n  }\n  get startPositionValue() {\n    const {\n      nextLoadPosition,\n      startPosition\n    } = this;\n    if (startPosition === -1 && nextLoadPosition) {\n      return nextLoadPosition;\n    }\n    return startPosition;\n  }\n  get bufferingEnabled() {\n    return this.buffering;\n  }\n  pauseBuffering() {\n    this.buffering = false;\n  }\n  resumeBuffering() {\n    this.buffering = true;\n  }\n  get inFlightFrag() {\n    return {\n      frag: this.fragCurrent,\n      state: this.state\n    };\n  }\n  _streamEnded(bufferInfo, levelDetails) {\n    // Stream is never \"ended\" when playlist is live or media is detached\n    if (levelDetails.live || !this.media) {\n      return false;\n    }\n    // Stream is not \"ended\" when nothing is buffered past the start\n    const bufferEnd = bufferInfo.end || 0;\n    const timelineStart = this.config.timelineOffset || 0;\n    if (bufferEnd <= timelineStart) {\n      return false;\n    }\n    // Stream is not \"ended\" when there is a second buffered range starting before the end of the playlist\n    const bufferedRanges = bufferInfo.buffered;\n    if (this.config.maxBufferHole && bufferedRanges && bufferedRanges.length > 1) {\n      // make sure bufferInfo accounts for any gaps\n      bufferInfo = BufferHelper.bufferedInfo(bufferedRanges, bufferInfo.start, 0);\n    }\n    const nextStart = bufferInfo.nextStart;\n    const hasSecondBufferedRange = nextStart && nextStart > timelineStart && nextStart < levelDetails.edge;\n    if (hasSecondBufferedRange) {\n      return false;\n    }\n    // Playhead is in unbuffered region. Marking EoS now could result in Safari failing to dispatch \"ended\" event following seek on start.\n    if (this.media.currentTime < bufferInfo.start) {\n      return false;\n    }\n    const partList = levelDetails.partList;\n    // Since the last part isn't guaranteed to correspond to the last playlist segment for Low-Latency HLS,\n    // check instead if the last part is buffered.\n    if (partList != null && partList.length) {\n      const lastPart = partList[partList.length - 1];\n\n      // Checking the midpoint of the part for potential margin of error and related issues.\n      // NOTE: Technically I believe parts could yield content that is < the computed duration (including potential a duration of 0)\n      // and still be spec-compliant, so there may still be edge cases here. Likewise, there could be issues in end of stream\n      // part mismatches for independent audio and video playlists/segments.\n      const lastPartBuffered = BufferHelper.isBuffered(this.media, lastPart.start + lastPart.duration / 2);\n      return lastPartBuffered;\n    }\n    const playlistType = levelDetails.fragments[levelDetails.fragments.length - 1].type;\n    return this.fragmentTracker.isEndListAppended(playlistType);\n  }\n  getLevelDetails() {\n    if (this.levels && this.levelLastLoaded !== null) {\n      var _this$levelLastLoaded;\n      return (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details;\n    }\n  }\n  get timelineOffset() {\n    const configuredTimelineOffset = this.config.timelineOffset;\n    if (configuredTimelineOffset) {\n      var _this$getLevelDetails;\n      return ((_this$getLevelDetails = this.getLevelDetails()) == null ? void 0 : _this$getLevelDetails.appliedTimelineOffset) || configuredTimelineOffset;\n    }\n    return 0;\n  }\n  onMediaAttached(event, data) {\n    const media = this.media = this.mediaBuffer = data.media;\n    media.removeEventListener('seeking', this.onMediaSeeking);\n    media.removeEventListener('ended', this.onMediaEnded);\n    media.addEventListener('seeking', this.onMediaSeeking);\n    media.addEventListener('ended', this.onMediaEnded);\n    const config = this.config;\n    if (this.levels && config.autoStartLoad && this.state === State.STOPPED) {\n      this.startLoad(config.startPosition);\n    }\n  }\n  onMediaDetaching(event, data) {\n    const transferringMedia = !!data.transferMedia;\n    const media = this.media;\n    if (media === null) {\n      return;\n    }\n    if (media.ended) {\n      this.log('MSE detaching and video ended, reset startPosition');\n      this.startPosition = this.lastCurrentTime = 0;\n    }\n\n    // remove video listeners\n    media.removeEventListener('seeking', this.onMediaSeeking);\n    media.removeEventListener('ended', this.onMediaEnded);\n    if (this.keyLoader && !transferringMedia) {\n      this.keyLoader.detach();\n    }\n    this.media = this.mediaBuffer = null;\n    this.loopSn = undefined;\n    if (transferringMedia) {\n      this.resetLoadingState();\n      this.resetTransmuxer();\n      return;\n    }\n    this.loadingParts = false;\n    this.fragmentTracker.removeAllFragments();\n    this.stopLoad();\n  }\n  onManifestLoading() {\n    this.initPTS = [];\n    this.levels = this.levelLastLoaded = this.fragCurrent = null;\n    this.lastCurrentTime = this.startPosition = 0;\n    this.startFragRequested = false;\n  }\n  onError(event, data) {}\n  onManifestLoaded(event, data) {\n    this.startTimeOffset = data.startTimeOffset;\n  }\n  onHandlerDestroying() {\n    this.stopLoad();\n    if (this.transmuxer) {\n      this.transmuxer.destroy();\n      this.transmuxer = null;\n    }\n    super.onHandlerDestroying();\n    // @ts-ignore\n    this.hls = this.onMediaSeeking = this.onMediaEnded = null;\n  }\n  onHandlerDestroyed() {\n    this.state = State.STOPPED;\n    if (this.fragmentLoader) {\n      this.fragmentLoader.destroy();\n    }\n    if (this.keyLoader) {\n      this.keyLoader.destroy();\n    }\n    if (this.decrypter) {\n      this.decrypter.destroy();\n    }\n    this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null;\n    super.onHandlerDestroyed();\n  }\n  loadFragment(frag, level, targetBufferTime) {\n    this.startFragRequested = true;\n    this._loadFragForPlayback(frag, level, targetBufferTime);\n  }\n  _loadFragForPlayback(fragment, level, targetBufferTime) {\n    const progressCallback = data => {\n      const frag = data.frag;\n      if (this.fragContextChanged(frag)) {\n        this.warn(`${frag.type} sn: ${frag.sn}${data.part ? ' part: ' + data.part.index : ''} of ${this.fragInfo(frag, false, data.part)}) was dropped during download.`);\n        this.fragmentTracker.removeFragment(frag);\n        return;\n      }\n      frag.stats.chunkCount++;\n      this._handleFragmentLoadProgress(data);\n    };\n    this._doFragLoad(fragment, level, targetBufferTime, progressCallback).then(data => {\n      if (!data) {\n        // if we're here we probably needed to backtrack or are waiting for more parts\n        return;\n      }\n      const state = this.state;\n      const frag = data.frag;\n      if (this.fragContextChanged(frag)) {\n        if (state === State.FRAG_LOADING || !this.fragCurrent && state === State.PARSING) {\n          this.fragmentTracker.removeFragment(frag);\n          this.state = State.IDLE;\n        }\n        return;\n      }\n      if ('payload' in data) {\n        this.log(`Loaded ${frag.type} sn: ${frag.sn} of ${this.playlistLabel()} ${frag.level}`);\n        this.hls.trigger(Events.FRAG_LOADED, data);\n      }\n\n      // Pass through the whole payload; controllers not implementing progressive loading receive data from this callback\n      this._handleFragmentLoadComplete(data);\n    }).catch(reason => {\n      if (this.state === State.STOPPED || this.state === State.ERROR) {\n        return;\n      }\n      this.warn(`Frag error: ${(reason == null ? void 0 : reason.message) || reason}`);\n      this.resetFragmentLoading(fragment);\n    });\n  }\n  clearTrackerIfNeeded(frag) {\n    var _this$mediaBuffer;\n    const {\n      fragmentTracker\n    } = this;\n    const fragState = fragmentTracker.getState(frag);\n    if (fragState === FragmentState.APPENDING) {\n      // Lower the max buffer length and try again\n      const playlistType = frag.type;\n      const bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);\n      const minForwardBufferLength = Math.max(frag.duration, bufferedInfo ? bufferedInfo.len : this.config.maxBufferLength);\n      // If backtracking, always remove from the tracker without reducing max buffer length\n      const backtrackFragment = this.backtrackFragment;\n      const backtracked = backtrackFragment ? frag.sn - backtrackFragment.sn : 0;\n      if (backtracked === 1 || this.reduceMaxBufferLength(minForwardBufferLength, frag.duration)) {\n        fragmentTracker.removeFragment(frag);\n      }\n    } else if (((_this$mediaBuffer = this.mediaBuffer) == null ? void 0 : _this$mediaBuffer.buffered.length) === 0) {\n      // Stop gap for bad tracker / buffer flush behavior\n      fragmentTracker.removeAllFragments();\n    } else if (fragmentTracker.hasParts(frag.type)) {\n      // In low latency mode, remove fragments for which only some parts were buffered\n      fragmentTracker.detectPartialFragments({\n        frag,\n        part: null,\n        stats: frag.stats,\n        id: frag.type\n      });\n      if (fragmentTracker.getState(frag) === FragmentState.PARTIAL) {\n        fragmentTracker.removeFragment(frag);\n      }\n    }\n  }\n  checkLiveUpdate(details) {\n    if (details.updated && !details.live) {\n      // Live stream ended, update fragment tracker\n      const lastFragment = details.fragments[details.fragments.length - 1];\n      this.fragmentTracker.detectPartialFragments({\n        frag: lastFragment,\n        part: null,\n        stats: lastFragment.stats,\n        id: lastFragment.type\n      });\n    }\n    if (!details.fragments[0]) {\n      details.deltaUpdateFailed = true;\n    }\n  }\n  waitForLive(levelInfo) {\n    const details = levelInfo.details;\n    return (details == null ? void 0 : details.live) && details.type !== 'EVENT' && (this.levelLastLoaded !== levelInfo || details.expired);\n  }\n  flushMainBuffer(startOffset, endOffset, type = null) {\n    if (!(startOffset - endOffset)) {\n      return;\n    }\n    // When alternate audio is playing, the audio-stream-controller is responsible for the audio buffer. Otherwise,\n    // passing a null type flushes both buffers\n    const flushScope = {\n      startOffset,\n      endOffset,\n      type\n    };\n    this.hls.trigger(Events.BUFFER_FLUSHING, flushScope);\n  }\n  _loadInitSegment(fragment, level) {\n    this._doFragLoad(fragment, level).then(data => {\n      const frag = data == null ? void 0 : data.frag;\n      if (!frag || this.fragContextChanged(frag) || !this.levels) {\n        throw new Error('init load aborted');\n      }\n      return data;\n    }).then(data => {\n      const {\n        hls\n      } = this;\n      const {\n        frag,\n        payload\n      } = data;\n      const decryptData = frag.decryptdata;\n\n      // check to see if the payload needs to be decrypted\n      if (payload && payload.byteLength > 0 && decryptData != null && decryptData.key && decryptData.iv && isFullSegmentEncryption(decryptData.method)) {\n        const startTime = self.performance.now();\n        // decrypt init segment data\n        return this.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer, getAesModeFromFullSegmentMethod(decryptData.method)).catch(err => {\n          hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.FRAG_DECRYPT_ERROR,\n            fatal: false,\n            error: err,\n            reason: err.message,\n            frag\n          });\n          throw err;\n        }).then(decryptedData => {\n          const endTime = self.performance.now();\n          hls.trigger(Events.FRAG_DECRYPTED, {\n            frag,\n            payload: decryptedData,\n            stats: {\n              tstart: startTime,\n              tdecrypt: endTime\n            }\n          });\n          data.payload = decryptedData;\n          return this.completeInitSegmentLoad(data);\n        });\n      }\n      return this.completeInitSegmentLoad(data);\n    }).catch(reason => {\n      if (this.state === State.STOPPED || this.state === State.ERROR) {\n        return;\n      }\n      this.warn(reason);\n      this.resetFragmentLoading(fragment);\n    });\n  }\n  completeInitSegmentLoad(data) {\n    const {\n      levels\n    } = this;\n    if (!levels) {\n      throw new Error('init load aborted, missing levels');\n    }\n    const stats = data.frag.stats;\n    if (this.state !== State.STOPPED) {\n      this.state = State.IDLE;\n    }\n    data.frag.data = new Uint8Array(data.payload);\n    stats.parsing.start = stats.buffering.start = self.performance.now();\n    stats.parsing.end = stats.buffering.end = self.performance.now();\n    this.tick();\n  }\n  fragContextChanged(frag) {\n    const {\n      fragCurrent\n    } = this;\n    return !frag || !fragCurrent || frag.sn !== fragCurrent.sn || frag.level !== fragCurrent.level;\n  }\n  fragBufferedComplete(frag, part) {\n    const media = this.mediaBuffer ? this.mediaBuffer : this.media;\n    this.log(`Buffered ${frag.type} sn: ${frag.sn}${part ? ' part: ' + part.index : ''} of ${this.fragInfo(frag, false, part)} > buffer:${media ? TimeRanges.toString(BufferHelper.getBuffered(media)) : '(detached)'})`);\n    if (isMediaFragment(frag)) {\n      var _this$levels;\n      if (frag.type !== PlaylistLevelType.SUBTITLE) {\n        const el = frag.elementaryStreams;\n        if (!Object.keys(el).some(type => !!el[type])) {\n          // empty segment\n          this.state = State.IDLE;\n          return;\n        }\n      }\n      const level = (_this$levels = this.levels) == null ? void 0 : _this$levels[frag.level];\n      if (level != null && level.fragmentError) {\n        this.log(`Resetting level fragment error count of ${level.fragmentError} on frag buffered`);\n        level.fragmentError = 0;\n      }\n    }\n    this.state = State.IDLE;\n  }\n  _handleFragmentLoadComplete(fragLoadedEndData) {\n    const {\n      transmuxer\n    } = this;\n    if (!transmuxer) {\n      return;\n    }\n    const {\n      frag,\n      part,\n      partsLoaded\n    } = fragLoadedEndData;\n    // If we did not load parts, or loaded all parts, we have complete (not partial) fragment data\n    const complete = !partsLoaded || partsLoaded.length === 0 || partsLoaded.some(fragLoaded => !fragLoaded);\n    const chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount + 1, 0, part ? part.index : -1, !complete);\n    transmuxer.flush(chunkMeta);\n  }\n  _handleFragmentLoadProgress(frag) {}\n  _doFragLoad(frag, level, targetBufferTime = null, progressCallback) {\n    var _frag$decryptdata;\n    this.fragCurrent = frag;\n    const details = level == null ? void 0 : level.details;\n    if (!this.levels || !details) {\n      throw new Error(`frag load aborted, missing level${details ? '' : ' detail'}s`);\n    }\n    let keyLoadingPromise = null;\n    if (frag.encrypted && !((_frag$decryptdata = frag.decryptdata) != null && _frag$decryptdata.key)) {\n      this.log(`Loading key for ${frag.sn} of [${details.startSN}-${details.endSN}], ${this.playlistLabel()} ${frag.level}`);\n      this.state = State.KEY_LOADING;\n      this.fragCurrent = frag;\n      keyLoadingPromise = this.keyLoader.load(frag).then(keyLoadedData => {\n        if (!this.fragContextChanged(keyLoadedData.frag)) {\n          this.hls.trigger(Events.KEY_LOADED, keyLoadedData);\n          if (this.state === State.KEY_LOADING) {\n            this.state = State.IDLE;\n          }\n          return keyLoadedData;\n        }\n      });\n      this.hls.trigger(Events.KEY_LOADING, {\n        frag\n      });\n      if (this.fragCurrent === null) {\n        keyLoadingPromise = Promise.reject(new Error(`frag load aborted, context changed in KEY_LOADING`));\n      }\n    } else if (!frag.encrypted) {\n      keyLoadingPromise = this.keyLoader.loadClear(frag, details.encryptedFragments, this.startFragRequested);\n      if (keyLoadingPromise) {\n        this.log(`[eme] blocking frag load until media-keys acquired`);\n      }\n    }\n    const fragPrevious = this.fragPrevious;\n    if (isMediaFragment(frag) && (!fragPrevious || frag.sn !== fragPrevious.sn)) {\n      const shouldLoadParts = this.shouldLoadParts(level.details, frag.end);\n      if (shouldLoadParts !== this.loadingParts) {\n        this.log(`LL-Part loading ${shouldLoadParts ? 'ON' : 'OFF'} loading sn ${fragPrevious == null ? void 0 : fragPrevious.sn}->${frag.sn}`);\n        this.loadingParts = shouldLoadParts;\n      }\n    }\n    targetBufferTime = Math.max(frag.start, targetBufferTime || 0);\n    if (this.loadingParts && isMediaFragment(frag)) {\n      const partList = details.partList;\n      if (partList && progressCallback) {\n        if (targetBufferTime > frag.end && details.fragmentHint) {\n          frag = details.fragmentHint;\n        }\n        const partIndex = this.getNextPart(partList, frag, targetBufferTime);\n        if (partIndex > -1) {\n          const part = partList[partIndex];\n          frag = this.fragCurrent = part.fragment;\n          this.log(`Loading ${frag.type} sn: ${frag.sn} part: ${part.index} (${partIndex}/${partList.length - 1}) of ${this.fragInfo(frag, false, part)}) cc: ${frag.cc} [${details.startSN}-${details.endSN}], target: ${parseFloat(targetBufferTime.toFixed(3))}`);\n          this.nextLoadPosition = part.start + part.duration;\n          this.state = State.FRAG_LOADING;\n          let _result;\n          if (keyLoadingPromise) {\n            _result = keyLoadingPromise.then(keyLoadedData => {\n              if (!keyLoadedData || this.fragContextChanged(keyLoadedData.frag)) {\n                return null;\n              }\n              return this.doFragPartsLoad(frag, part, level, progressCallback);\n            }).catch(error => this.handleFragLoadError(error));\n          } else {\n            _result = this.doFragPartsLoad(frag, part, level, progressCallback).catch(error => this.handleFragLoadError(error));\n          }\n          this.hls.trigger(Events.FRAG_LOADING, {\n            frag,\n            part,\n            targetBufferTime\n          });\n          if (this.fragCurrent === null) {\n            return Promise.reject(new Error(`frag load aborted, context changed in FRAG_LOADING parts`));\n          }\n          return _result;\n        } else if (!frag.url || this.loadedEndOfParts(partList, targetBufferTime)) {\n          // Fragment hint has no parts\n          return Promise.resolve(null);\n        }\n      }\n    }\n    if (isMediaFragment(frag) && this.loadingParts) {\n      this.log(`LL-Part loading OFF after next part miss @${targetBufferTime.toFixed(2)}`);\n      this.loadingParts = false;\n    } else if (!frag.url) {\n      // Selected fragment hint for part but not loading parts\n      return Promise.resolve(null);\n    }\n    this.log(`Loading ${frag.type} sn: ${frag.sn} of ${this.fragInfo(frag, false)}) cc: ${frag.cc} ${details ? '[' + details.startSN + '-' + details.endSN + ']' : ''}, target: ${parseFloat(targetBufferTime.toFixed(3))}`);\n    // Don't update nextLoadPosition for fragments which are not buffered\n    if (isFiniteNumber(frag.sn) && !this.bitrateTest) {\n      this.nextLoadPosition = frag.start + frag.duration;\n    }\n    this.state = State.FRAG_LOADING;\n\n    // Load key before streaming fragment data\n    const dataOnProgress = this.config.progressive;\n    let result;\n    if (dataOnProgress && keyLoadingPromise) {\n      result = keyLoadingPromise.then(keyLoadedData => {\n        if (!keyLoadedData || this.fragContextChanged(keyLoadedData == null ? void 0 : keyLoadedData.frag)) {\n          return null;\n        }\n        return this.fragmentLoader.load(frag, progressCallback);\n      }).catch(error => this.handleFragLoadError(error));\n    } else {\n      // load unencrypted fragment data with progress event,\n      // or handle fragment result after key and fragment are finished loading\n      result = Promise.all([this.fragmentLoader.load(frag, dataOnProgress ? progressCallback : undefined), keyLoadingPromise]).then(([fragLoadedData]) => {\n        if (!dataOnProgress && fragLoadedData && progressCallback) {\n          progressCallback(fragLoadedData);\n        }\n        return fragLoadedData;\n      }).catch(error => this.handleFragLoadError(error));\n    }\n    this.hls.trigger(Events.FRAG_LOADING, {\n      frag,\n      targetBufferTime\n    });\n    if (this.fragCurrent === null) {\n      return Promise.reject(new Error(`frag load aborted, context changed in FRAG_LOADING`));\n    }\n    return result;\n  }\n  doFragPartsLoad(frag, fromPart, level, progressCallback) {\n    return new Promise((resolve, reject) => {\n      var _level$details;\n      const partsLoaded = [];\n      const initialPartList = (_level$details = level.details) == null ? void 0 : _level$details.partList;\n      const loadPart = part => {\n        this.fragmentLoader.loadPart(frag, part, progressCallback).then(partLoadedData => {\n          partsLoaded[part.index] = partLoadedData;\n          const loadedPart = partLoadedData.part;\n          this.hls.trigger(Events.FRAG_LOADED, partLoadedData);\n          const nextPart = getPartWith(level.details, frag.sn, part.index + 1) || findPart(initialPartList, frag.sn, part.index + 1);\n          if (nextPart) {\n            loadPart(nextPart);\n          } else {\n            return resolve({\n              frag,\n              part: loadedPart,\n              partsLoaded\n            });\n          }\n        }).catch(reject);\n      };\n      loadPart(fromPart);\n    });\n  }\n  handleFragLoadError(error) {\n    if ('data' in error) {\n      const data = error.data;\n      if (error.data && data.details === ErrorDetails.INTERNAL_ABORTED) {\n        this.handleFragLoadAborted(data.frag, data.part);\n      } else {\n        this.hls.trigger(Events.ERROR, data);\n      }\n    } else {\n      this.hls.trigger(Events.ERROR, {\n        type: ErrorTypes.OTHER_ERROR,\n        details: ErrorDetails.INTERNAL_EXCEPTION,\n        err: error,\n        error,\n        fatal: true\n      });\n    }\n    return null;\n  }\n  _handleTransmuxerFlush(chunkMeta) {\n    const context = this.getCurrentContext(chunkMeta);\n    if (!context || this.state !== State.PARSING) {\n      if (!this.fragCurrent && this.state !== State.STOPPED && this.state !== State.ERROR) {\n        this.state = State.IDLE;\n      }\n      return;\n    }\n    const {\n      frag,\n      part,\n      level\n    } = context;\n    const now = self.performance.now();\n    frag.stats.parsing.end = now;\n    if (part) {\n      part.stats.parsing.end = now;\n    }\n    // See if part loading should be disabled/enabled based on buffer and playback position.\n    const levelDetails = this.getLevelDetails();\n    const loadingPartsAtEdge = levelDetails && frag.sn > levelDetails.endSN;\n    const shouldLoadParts = loadingPartsAtEdge || this.shouldLoadParts(levelDetails, frag.end);\n    if (shouldLoadParts !== this.loadingParts) {\n      this.log(`LL-Part loading ${shouldLoadParts ? 'ON' : 'OFF'} after parsing segment ending @${frag.end.toFixed(2)}`);\n      this.loadingParts = shouldLoadParts;\n    }\n    this.updateLevelTiming(frag, part, level, chunkMeta.partial);\n  }\n  shouldLoadParts(details, bufferEnd) {\n    if (this.config.lowLatencyMode) {\n      if (!details) {\n        return this.loadingParts;\n      }\n      if (details != null && details.partList) {\n        var _details$fragmentHint;\n        // Buffer must be ahead of first part + duration of parts after last segment\n        // and playback must be at or past segment adjacent to part list\n        const firstPart = details.partList[0];\n        const safePartStart = firstPart.end + (((_details$fragmentHint = details.fragmentHint) == null ? void 0 : _details$fragmentHint.duration) || 0);\n        if (bufferEnd >= safePartStart) {\n          var _this$media;\n          const playhead = this.hls.hasEnoughToStart ? ((_this$media = this.media) == null ? void 0 : _this$media.currentTime) || this.lastCurrentTime : this.getLoadPosition();\n          if (playhead > firstPart.start - firstPart.fragment.duration) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  getCurrentContext(chunkMeta) {\n    const {\n      levels,\n      fragCurrent\n    } = this;\n    const {\n      level: levelIndex,\n      sn,\n      part: partIndex\n    } = chunkMeta;\n    if (!(levels != null && levels[levelIndex])) {\n      this.warn(`Levels object was unset while buffering fragment ${sn} of ${this.playlistLabel()} ${levelIndex}. The current chunk will not be buffered.`);\n      return null;\n    }\n    const level = levels[levelIndex];\n    const levelDetails = level.details;\n    const part = partIndex > -1 ? getPartWith(levelDetails, sn, partIndex) : null;\n    const frag = part ? part.fragment : getFragmentWithSN(levelDetails, sn, fragCurrent);\n    if (!frag) {\n      return null;\n    }\n    if (fragCurrent && fragCurrent !== frag) {\n      frag.stats = fragCurrent.stats;\n    }\n    return {\n      frag,\n      part,\n      level\n    };\n  }\n  bufferFragmentData(data, frag, part, chunkMeta, noBacktracking) {\n    var _buffer;\n    if (!data || this.state !== State.PARSING) {\n      return;\n    }\n    const {\n      data1,\n      data2\n    } = data;\n    let buffer = data1;\n    if (data1 && data2) {\n      // Combine the moof + mdat so that we buffer with a single append\n      buffer = appendUint8Array(data1, data2);\n    }\n    if (!((_buffer = buffer) != null && _buffer.length)) {\n      return;\n    }\n    const offsetTimestamp = this.initPTS[frag.cc];\n    const offset = offsetTimestamp ? -offsetTimestamp.baseTime / offsetTimestamp.timescale : undefined;\n    const segment = {\n      type: data.type,\n      frag,\n      part,\n      chunkMeta,\n      offset,\n      parent: frag.type,\n      data: buffer\n    };\n    this.hls.trigger(Events.BUFFER_APPENDING, segment);\n    if (data.dropped && data.independent && !part) {\n      if (noBacktracking) {\n        return;\n      }\n      // Clear buffer so that we reload previous segments sequentially if required\n      this.flushBufferGap(frag);\n    }\n  }\n  flushBufferGap(frag) {\n    const media = this.media;\n    if (!media) {\n      return;\n    }\n    // If currentTime is not buffered, clear the back buffer so that we can backtrack as much as needed\n    if (!BufferHelper.isBuffered(media, media.currentTime)) {\n      this.flushMainBuffer(0, frag.start);\n      return;\n    }\n    // Remove back-buffer without interrupting playback to allow back tracking\n    const currentTime = media.currentTime;\n    const bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);\n    const fragDuration = frag.duration;\n    const segmentFraction = Math.min(this.config.maxFragLookUpTolerance * 2, fragDuration * 0.25);\n    const start = Math.max(Math.min(frag.start - segmentFraction, bufferInfo.end - segmentFraction), currentTime + segmentFraction);\n    if (frag.start - start > segmentFraction) {\n      this.flushMainBuffer(start, frag.start);\n    }\n  }\n  getFwdBufferInfo(bufferable, type) {\n    var _this$media2;\n    const pos = this.getLoadPosition();\n    if (!isFiniteNumber(pos)) {\n      return null;\n    }\n    const backwardSeek = this.lastCurrentTime > pos;\n    const maxBufferHole = backwardSeek || (_this$media2 = this.media) != null && _this$media2.paused ? 0 : this.config.maxBufferHole;\n    return this.getFwdBufferInfoAtPos(bufferable, pos, type, maxBufferHole);\n  }\n  getFwdBufferInfoAtPos(bufferable, pos, type, maxBufferHole) {\n    const bufferInfo = BufferHelper.bufferInfo(bufferable, pos, maxBufferHole);\n    // Workaround flaw in getting forward buffer when maxBufferHole is smaller than gap at current pos\n    if (bufferInfo.len === 0 && bufferInfo.nextStart !== undefined) {\n      const bufferedFragAtPos = this.fragmentTracker.getBufferedFrag(pos, type);\n      if (bufferedFragAtPos && (bufferInfo.nextStart <= bufferedFragAtPos.end || bufferedFragAtPos.gap)) {\n        const gapDuration = Math.max(Math.min(bufferInfo.nextStart, bufferedFragAtPos.end) - pos, maxBufferHole);\n        return BufferHelper.bufferInfo(bufferable, pos, gapDuration);\n      }\n    }\n    return bufferInfo;\n  }\n  getMaxBufferLength(levelBitrate) {\n    const {\n      config\n    } = this;\n    let maxBufLen;\n    if (levelBitrate) {\n      maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);\n    } else {\n      maxBufLen = config.maxBufferLength;\n    }\n    return Math.min(maxBufLen, config.maxMaxBufferLength);\n  }\n  reduceMaxBufferLength(threshold, fragDuration) {\n    const config = this.config;\n    const minLength = Math.max(Math.min(threshold - fragDuration, config.maxBufferLength), fragDuration);\n    const reducedLength = Math.max(threshold - fragDuration * 3, config.maxMaxBufferLength / 2, minLength);\n    if (reducedLength >= minLength) {\n      // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...\n      config.maxMaxBufferLength = reducedLength;\n      this.warn(`Reduce max buffer length to ${reducedLength}s`);\n      return true;\n    }\n    return false;\n  }\n  getAppendedFrag(position, playlistType = PlaylistLevelType.MAIN) {\n    var _this$fragmentTracker;\n    const fragOrPart = (_this$fragmentTracker = this.fragmentTracker) == null ? void 0 : _this$fragmentTracker.getAppendedFrag(position, playlistType);\n    if (fragOrPart && 'fragment' in fragOrPart) {\n      return fragOrPart.fragment;\n    }\n    return fragOrPart;\n  }\n  getNextFragment(pos, levelDetails) {\n    const fragments = levelDetails.fragments;\n    const fragLen = fragments.length;\n    if (!fragLen) {\n      return null;\n    }\n\n    // find fragment index, contiguous with end of buffer position\n    const {\n      config\n    } = this;\n    const start = fragments[0].start;\n    const canLoadParts = config.lowLatencyMode && !!levelDetails.partList;\n    let frag = null;\n    if (levelDetails.live) {\n      const initialLiveManifestSize = config.initialLiveManifestSize;\n      if (fragLen < initialLiveManifestSize) {\n        this.warn(`Not enough fragments to start playback (have: ${fragLen}, need: ${initialLiveManifestSize})`);\n        return null;\n      }\n      // The real fragment start times for a live stream are only known after the PTS range for that level is known.\n      // In order to discover the range, we load the best matching fragment for that level and demux it.\n      // Do not load using live logic if the starting frag is requested - we want to use getFragmentAtPosition() so that\n      // we get the fragment matching that start time\n      if (!levelDetails.PTSKnown && !this.startFragRequested && this.startPosition === -1 || pos < start) {\n        var _frag;\n        if (canLoadParts && !this.loadingParts) {\n          this.log(`LL-Part loading ON for initial live fragment`);\n          this.loadingParts = true;\n        }\n        frag = this.getInitialLiveFragment(levelDetails);\n        const mainStart = this.hls.startPosition;\n        const liveSyncPosition = this.hls.liveSyncPosition;\n        const startPosition = frag ? (mainStart !== -1 && mainStart >= start ? mainStart : liveSyncPosition) || frag.start : pos;\n        this.log(`Setting startPosition to ${startPosition} to match start frag at live edge. mainStart: ${mainStart} liveSyncPosition: ${liveSyncPosition} frag.start: ${(_frag = frag) == null ? void 0 : _frag.start}`);\n        this.startPosition = this.nextLoadPosition = startPosition;\n      }\n    } else if (pos <= start) {\n      // VoD playlist: if loadPosition before start of playlist, load first fragment\n      frag = fragments[0];\n    }\n\n    // If we haven't run into any special cases already, just load the fragment most closely matching the requested position\n    if (!frag) {\n      const end = this.loadingParts ? levelDetails.partEnd : levelDetails.fragmentEnd;\n      frag = this.getFragmentAtPosition(pos, end, levelDetails);\n    }\n    let programFrag = this.filterReplacedPrimary(frag, levelDetails);\n    if (!programFrag && frag) {\n      const curSNIdx = frag.sn - levelDetails.startSN;\n      programFrag = this.filterReplacedPrimary(fragments[curSNIdx + 1] || null, levelDetails);\n    }\n    return this.mapToInitFragWhenRequired(programFrag);\n  }\n  isLoopLoading(frag, targetBufferTime) {\n    const trackerState = this.fragmentTracker.getState(frag);\n    return (trackerState === FragmentState.OK || trackerState === FragmentState.PARTIAL && !!frag.gap) && this.nextLoadPosition > targetBufferTime;\n  }\n  getNextFragmentLoopLoading(frag, levelDetails, bufferInfo, playlistType, maxBufLen) {\n    let nextFragment = null;\n    if (frag.gap) {\n      nextFragment = this.getNextFragment(this.nextLoadPosition, levelDetails);\n      if (nextFragment && !nextFragment.gap && bufferInfo.nextStart) {\n        // Media buffered after GAP tags should not make the next buffer timerange exceed forward buffer length\n        const nextbufferInfo = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, bufferInfo.nextStart, playlistType, 0);\n        if (nextbufferInfo !== null && bufferInfo.len + nextbufferInfo.len >= maxBufLen) {\n          // Returning here might result in not finding an audio and video candiate to skip to\n          const sn = nextFragment.sn;\n          if (this.loopSn !== sn) {\n            this.log(`buffer full after gaps in \"${playlistType}\" playlist starting at sn: ${sn}`);\n            this.loopSn = sn;\n          }\n          return null;\n        }\n      }\n    }\n    this.loopSn = undefined;\n    return nextFragment;\n  }\n  get primaryPrefetch() {\n    if (interstitialsEnabled(this.hls.config)) {\n      var _this$hls$interstitia, _this$hls$interstitia2;\n      const playingInterstitial = (_this$hls$interstitia = this.hls.interstitialsManager) == null ? void 0 : (_this$hls$interstitia2 = _this$hls$interstitia.playingItem) == null ? void 0 : _this$hls$interstitia2.event;\n      if (playingInterstitial) {\n        return true;\n      }\n    }\n    return false;\n  }\n  filterReplacedPrimary(frag, details) {\n    if (!frag) {\n      return frag;\n    }\n    if (interstitialsEnabled(this.hls.config) && frag.type !== PlaylistLevelType.SUBTITLE) {\n      // Do not load fragments outside the buffering schedule segment\n      const interstitials = this.hls.interstitialsManager;\n      const bufferingItem = interstitials == null ? void 0 : interstitials.bufferingItem;\n      if (bufferingItem) {\n        const bufferingInterstitial = bufferingItem.event;\n        if (bufferingInterstitial) {\n          // Do not stream fragments while buffering Interstitial Events (except for overlap at the start)\n          if (bufferingInterstitial.appendInPlace || Math.abs(frag.start - bufferingItem.start) > 1 || bufferingItem.start === 0) {\n            return null;\n          }\n        } else {\n          // Limit fragment loading to media in schedule item\n          if (frag.end <= bufferingItem.start && (details == null ? void 0 : details.live) === false) {\n            // fragment ends by schedule item start\n            // this.fragmentTracker.fragBuffered(frag, true);\n            return null;\n          }\n          if (frag.start > bufferingItem.end && bufferingItem.nextEvent) {\n            // fragment is past schedule item end\n            // allow some overflow when not appending in place to prevent stalls\n            if (bufferingItem.nextEvent.appendInPlace || frag.start - bufferingItem.end > 1) {\n              return null;\n            }\n          }\n        }\n      }\n      // Skip loading of fragments that overlap completely with appendInPlace interstitials\n      const playerQueue = interstitials == null ? void 0 : interstitials.playerQueue;\n      if (playerQueue) {\n        for (let i = playerQueue.length; i--;) {\n          const interstitial = playerQueue[i].interstitial;\n          if (interstitial.appendInPlace && frag.start >= interstitial.startTime && frag.end <= interstitial.resumeTime) {\n            return null;\n          }\n        }\n      }\n    }\n    return frag;\n  }\n  mapToInitFragWhenRequired(frag) {\n    // If an initSegment is present, it must be buffered first\n    if (frag != null && frag.initSegment && !(frag != null && frag.initSegment.data) && !this.bitrateTest) {\n      return frag.initSegment;\n    }\n    return frag;\n  }\n  getNextPart(partList, frag, targetBufferTime) {\n    let nextPart = -1;\n    let contiguous = false;\n    let independentAttrOmitted = true;\n    for (let i = 0, len = partList.length; i < len; i++) {\n      const part = partList[i];\n      independentAttrOmitted = independentAttrOmitted && !part.independent;\n      if (nextPart > -1 && targetBufferTime < part.start) {\n        break;\n      }\n      const loaded = part.loaded;\n      if (loaded) {\n        nextPart = -1;\n      } else if ((contiguous || part.independent || independentAttrOmitted) && part.fragment === frag) {\n        nextPart = i;\n      }\n      contiguous = loaded;\n    }\n    return nextPart;\n  }\n  loadedEndOfParts(partList, targetBufferTime) {\n    const lastPart = partList[partList.length - 1];\n    return lastPart && targetBufferTime > lastPart.start && lastPart.loaded;\n  }\n\n  /*\n   This method is used find the best matching first fragment for a live playlist. This fragment is used to calculate the\n   \"sliding\" of the playlist, which is its offset from the start of playback. After sliding we can compute the real\n   start and end times for each fragment in the playlist (after which this method will not need to be called).\n  */\n  getInitialLiveFragment(levelDetails) {\n    const fragments = levelDetails.fragments;\n    const fragPrevious = this.fragPrevious;\n    let frag = null;\n    if (fragPrevious) {\n      if (levelDetails.hasProgramDateTime) {\n        // Prefer using PDT, because it can be accurate enough to choose the correct fragment without knowing the level sliding\n        this.log(`Live playlist, switching playlist, load frag with same PDT: ${fragPrevious.programDateTime}`);\n        frag = findFragmentByPDT(fragments, fragPrevious.endProgramDateTime, this.config.maxFragLookUpTolerance);\n      }\n      if (!frag) {\n        // SN does not need to be accurate between renditions, but depending on the packaging it may be so.\n        const targetSN = fragPrevious.sn + 1;\n        if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {\n          const fragNext = fragments[targetSN - levelDetails.startSN];\n          // Ensure that we're staying within the continuity range, since PTS resets upon a new range\n          if (fragPrevious.cc === fragNext.cc) {\n            frag = fragNext;\n            this.log(`Live playlist, switching playlist, load frag with next SN: ${frag.sn}`);\n          }\n        }\n        // It's important to stay within the continuity range if available; otherwise the fragments in the playlist\n        // will have the wrong start times\n        if (!frag) {\n          frag = findNearestWithCC(levelDetails, fragPrevious.cc, fragPrevious.end);\n          if (frag) {\n            this.log(`Live playlist, switching playlist, load frag with same CC: ${frag.sn}`);\n          }\n        }\n      }\n    } else {\n      // Find a new start fragment when fragPrevious is null\n      const liveStart = this.hls.liveSyncPosition;\n      if (liveStart !== null) {\n        frag = this.getFragmentAtPosition(liveStart, this.bitrateTest ? levelDetails.fragmentEnd : levelDetails.edge, levelDetails);\n      }\n    }\n    return frag;\n  }\n\n  /*\n  This method finds the best matching fragment given the provided position.\n   */\n  getFragmentAtPosition(bufferEnd, end, levelDetails) {\n    const {\n      config\n    } = this;\n    let {\n      fragPrevious\n    } = this;\n    let {\n      fragments,\n      endSN\n    } = levelDetails;\n    const {\n      fragmentHint\n    } = levelDetails;\n    const {\n      maxFragLookUpTolerance\n    } = config;\n    const partList = levelDetails.partList;\n    const loadingParts = !!(this.loadingParts && partList != null && partList.length && fragmentHint);\n    if (loadingParts && fragmentHint && !this.bitrateTest && partList[partList.length - 1].fragment.sn === fragmentHint.sn) {\n      // Include incomplete fragment with parts at end\n      fragments = fragments.concat(fragmentHint);\n      endSN = fragmentHint.sn;\n    }\n    let frag;\n    if (bufferEnd < end) {\n      var _this$media3;\n      const backwardSeek = bufferEnd < this.lastCurrentTime;\n      const lookupTolerance = backwardSeek || bufferEnd > end - maxFragLookUpTolerance || (_this$media3 = this.media) != null && _this$media3.paused || !this.startFragRequested ? 0 : maxFragLookUpTolerance;\n      // Remove the tolerance if it would put the bufferEnd past the actual end of stream\n      // Uses buffer and sequence number to calculate switch segment (required if using EXT-X-DISCONTINUITY-SEQUENCE)\n      frag = findFragmentByPTS(fragPrevious, fragments, bufferEnd, lookupTolerance);\n    } else {\n      // reach end of playlist\n      frag = fragments[fragments.length - 1];\n    }\n    if (frag) {\n      const curSNIdx = frag.sn - levelDetails.startSN;\n      // Move fragPrevious forward to support forcing the next fragment to load\n      // when the buffer catches up to a previously buffered range.\n      const fragState = this.fragmentTracker.getState(frag);\n      if (fragState === FragmentState.OK || fragState === FragmentState.PARTIAL && frag.gap) {\n        fragPrevious = frag;\n      }\n      if (fragPrevious && frag.sn === fragPrevious.sn && (!loadingParts || partList[0].fragment.sn > frag.sn || !levelDetails.live && !loadingParts)) {\n        // Force the next fragment to load if the previous one was already selected. This can occasionally happen with\n        // non-uniform fragment durations\n        const sameLevel = fragPrevious && frag.level === fragPrevious.level;\n        if (sameLevel) {\n          const nextFrag = fragments[curSNIdx + 1];\n          if (frag.sn < endSN && this.fragmentTracker.getState(nextFrag) !== FragmentState.OK) {\n            frag = nextFrag;\n          } else {\n            frag = null;\n          }\n        }\n      }\n    }\n    return frag;\n  }\n  alignPlaylists(details, previousDetails, switchDetails) {\n    // TODO: If not for `shouldAlignOnDiscontinuities` requiring fragPrevious.cc,\n    //  this could all go in level-helper mergeDetails()\n    const length = details.fragments.length;\n    if (!length) {\n      this.warn(`No fragments in live playlist`);\n      return 0;\n    }\n    const slidingStart = details.fragmentStart;\n    const firstLevelLoad = !previousDetails;\n    const aligned = details.alignedSliding && isFiniteNumber(slidingStart);\n    if (firstLevelLoad || !aligned && !slidingStart) {\n      alignStream(switchDetails, details);\n      const alignedSlidingStart = details.fragmentStart;\n      this.log(`Live playlist sliding: ${alignedSlidingStart.toFixed(2)} start-sn: ${previousDetails ? previousDetails.startSN : 'na'}->${details.startSN} fragments: ${length}`);\n      return alignedSlidingStart;\n    }\n    return slidingStart;\n  }\n  waitForCdnTuneIn(details) {\n    // Wait for Low-Latency CDN Tune-in to get an updated playlist\n    const advancePartLimit = 3;\n    return details.live && details.canBlockReload && details.partTarget && details.tuneInGoal > Math.max(details.partHoldBack, details.partTarget * advancePartLimit);\n  }\n  setStartPosition(details, sliding) {\n    // compute start position if set to -1. use it straight away if value is defined\n    let startPosition = this.startPosition;\n    if (startPosition < sliding) {\n      startPosition = -1;\n    }\n    const timelineOffset = this.timelineOffset;\n    if (startPosition === -1) {\n      // Use Playlist EXT-X-START:TIME-OFFSET when set\n      // Prioritize Multivariant Playlist offset so that main, audio, and subtitle stream-controller start times match\n      const offsetInMultivariantPlaylist = this.startTimeOffset !== null;\n      const startTimeOffset = offsetInMultivariantPlaylist ? this.startTimeOffset : details.startTimeOffset;\n      if (startTimeOffset !== null && isFiniteNumber(startTimeOffset)) {\n        startPosition = sliding + startTimeOffset;\n        if (startTimeOffset < 0) {\n          startPosition += details.edge;\n        }\n        startPosition = Math.min(Math.max(sliding, startPosition), sliding + details.totalduration);\n        this.log(`Setting startPosition to ${startPosition} for start time offset ${startTimeOffset} found in ${offsetInMultivariantPlaylist ? 'multivariant' : 'media'} playlist`);\n        this.startPosition = startPosition;\n      } else if (details.live) {\n        // Leave this.startPosition at -1, so that we can use `getInitialLiveFragment` logic when startPosition has\n        // not been specified via the config or an as an argument to startLoad (#3736).\n        startPosition = this.hls.liveSyncPosition || sliding;\n        this.log(`Setting startPosition to -1 to start at live edge ${startPosition}`);\n        this.startPosition = -1;\n      } else {\n        this.log(`setting startPosition to 0 by default`);\n        this.startPosition = startPosition = 0;\n      }\n      this.lastCurrentTime = startPosition + timelineOffset;\n    }\n    this.nextLoadPosition = startPosition + timelineOffset;\n  }\n  getLoadPosition() {\n    var _this$hls;\n    const {\n      media\n    } = this;\n    // if we have not yet loaded any fragment, start loading from start position\n    let pos = 0;\n    if ((_this$hls = this.hls) != null && _this$hls.hasEnoughToStart && media) {\n      pos = media.currentTime;\n    } else if (this.nextLoadPosition >= 0) {\n      pos = this.nextLoadPosition;\n    }\n    return pos;\n  }\n  handleFragLoadAborted(frag, part) {\n    if (this.transmuxer && frag.type === this.playlistType && isMediaFragment(frag) && frag.stats.aborted) {\n      this.log(`Fragment ${frag.sn}${part ? ' part ' + part.index : ''} of ${this.playlistLabel()} ${frag.level} was aborted`);\n      this.resetFragmentLoading(frag);\n    }\n  }\n  resetFragmentLoading(frag) {\n    if (!this.fragCurrent || !this.fragContextChanged(frag) && this.state !== State.FRAG_LOADING_WAITING_RETRY) {\n      this.state = State.IDLE;\n    }\n  }\n  onFragmentOrKeyLoadError(filterType, data) {\n    if (data.chunkMeta && !data.frag) {\n      const context = this.getCurrentContext(data.chunkMeta);\n      if (context) {\n        data.frag = context.frag;\n      }\n    }\n    const frag = data.frag;\n    // Handle frag error related to caller's filterType\n    if (!frag || frag.type !== filterType || !this.levels) {\n      return;\n    }\n    if (this.fragContextChanged(frag)) {\n      var _this$fragCurrent;\n      this.warn(`Frag load error must match current frag to retry ${frag.url} > ${(_this$fragCurrent = this.fragCurrent) == null ? void 0 : _this$fragCurrent.url}`);\n      return;\n    }\n    const gapTagEncountered = data.details === ErrorDetails.FRAG_GAP;\n    if (gapTagEncountered) {\n      this.fragmentTracker.fragBuffered(frag, true);\n    }\n    // keep retrying until the limit will be reached\n    const errorAction = data.errorAction;\n    const {\n      action,\n      flags,\n      retryCount = 0,\n      retryConfig\n    } = errorAction || {};\n    const couldRetry = !!errorAction && !!retryConfig;\n    const retry = couldRetry && action === NetworkErrorAction.RetryRequest;\n    const noAlternate = couldRetry && !errorAction.resolved && flags === ErrorActionFlags.MoveAllAlternatesMatchingHost;\n    if (!retry && noAlternate && isMediaFragment(frag) && !frag.endList) {\n      this.resetFragmentErrors(filterType);\n      this.treatAsGap(frag);\n      errorAction.resolved = true;\n    } else if ((retry || noAlternate) && retryCount < retryConfig.maxNumRetry) {\n      this.resetStartWhenNotLoaded(this.levelLastLoaded);\n      const delay = getRetryDelay(retryConfig, retryCount);\n      this.warn(`Fragment ${frag.sn} of ${filterType} ${frag.level} errored with ${data.details}, retrying loading ${retryCount + 1}/${retryConfig.maxNumRetry} in ${delay}ms`);\n      errorAction.resolved = true;\n      this.retryDate = self.performance.now() + delay;\n      this.state = State.FRAG_LOADING_WAITING_RETRY;\n    } else if (retryConfig && errorAction) {\n      this.resetFragmentErrors(filterType);\n      if (retryCount < retryConfig.maxNumRetry) {\n        // Network retry is skipped when level switch is preferred\n        if (!gapTagEncountered && action !== NetworkErrorAction.RemoveAlternatePermanently) {\n          errorAction.resolved = true;\n        }\n      } else {\n        this.warn(`${data.details} reached or exceeded max retry (${retryCount})`);\n        return;\n      }\n    } else if (action === NetworkErrorAction.SendAlternateToPenaltyBox) {\n      this.state = State.WAITING_LEVEL;\n    } else {\n      this.state = State.ERROR;\n    }\n    // Perform next async tick sooner to speed up error action resolution\n    this.tickImmediate();\n  }\n  reduceLengthAndFlushBuffer(data) {\n    // if in appending state\n    if (this.state === State.PARSING || this.state === State.PARSED) {\n      const frag = data.frag;\n      const playlistType = data.parent;\n      const bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);\n      // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end\n      // reduce max buf len if current position is buffered\n      const buffered = bufferedInfo && bufferedInfo.len > 0.5;\n      if (buffered) {\n        this.reduceMaxBufferLength(bufferedInfo.len, (frag == null ? void 0 : frag.duration) || 10);\n      }\n      const flushBuffer = !buffered;\n      if (flushBuffer) {\n        // current position is not buffered, but browser is still complaining about buffer full error\n        // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708\n        // in that case flush the whole audio buffer to recover\n        this.warn(`Buffer full error while media.currentTime is not buffered, flush ${playlistType} buffer`);\n      }\n      if (frag) {\n        this.fragmentTracker.removeFragment(frag);\n        this.nextLoadPosition = frag.start;\n      }\n      this.resetLoadingState();\n      return flushBuffer;\n    }\n    return false;\n  }\n  resetFragmentErrors(filterType) {\n    if (filterType === PlaylistLevelType.AUDIO) {\n      // Reset current fragment since audio track audio is essential and may not have a fail-over track\n      this.fragCurrent = null;\n    }\n    // Fragment errors that result in a level switch or redundant fail-over\n    // should reset the stream controller state to idle\n    if (!this.hls.hasEnoughToStart) {\n      this.startFragRequested = false;\n    }\n    if (this.state !== State.STOPPED) {\n      this.state = State.IDLE;\n    }\n  }\n  afterBufferFlushed(media, bufferType, playlistType) {\n    if (!media) {\n      return;\n    }\n    // After successful buffer flushing, filter flushed fragments from bufferedFrags use mediaBuffered instead of media\n    // (so that we will check against video.buffered ranges in case of alt audio track)\n    const bufferedTimeRanges = BufferHelper.getBuffered(media);\n    this.fragmentTracker.detectEvictedFragments(bufferType, bufferedTimeRanges, playlistType);\n    if (this.state === State.ENDED) {\n      this.resetLoadingState();\n    }\n  }\n  resetLoadingState() {\n    this.log('Reset loading state');\n    this.fragCurrent = null;\n    this.fragPrevious = null;\n    if (this.state !== State.STOPPED) {\n      this.state = State.IDLE;\n    }\n  }\n  resetStartWhenNotLoaded(level) {\n    // if loadedmetadata is not set, it means that first frag request failed\n    // in that case, reset startFragRequested flag\n    if (!this.hls.hasEnoughToStart) {\n      this.startFragRequested = false;\n      const details = level ? level.details : null;\n      if (details != null && details.live) {\n        // Update the start position and return to IDLE to recover live start\n        this.log(`resetting startPosition for live start`);\n        this.startPosition = -1;\n        this.setStartPosition(details, details.fragmentStart);\n        this.resetLoadingState();\n      } else {\n        this.nextLoadPosition = this.startPosition;\n      }\n    }\n  }\n  resetWhenMissingContext(chunkMeta) {\n    this.warn(`The loading context changed while buffering fragment ${chunkMeta.sn} of ${this.playlistLabel()} ${chunkMeta.level}. This chunk will not be buffered.`);\n    this.removeUnbufferedFrags();\n    this.resetStartWhenNotLoaded(this.levelLastLoaded);\n    this.resetLoadingState();\n  }\n  removeUnbufferedFrags(start = 0) {\n    this.fragmentTracker.removeFragmentsInRange(start, Infinity, this.playlistType, false, true);\n  }\n  updateLevelTiming(frag, part, level, partial) {\n    const details = level.details;\n    if (!details) {\n      this.warn('level.details undefined');\n      return;\n    }\n    const parsed = Object.keys(frag.elementaryStreams).reduce((result, type) => {\n      const info = frag.elementaryStreams[type];\n      if (info) {\n        const parsedDuration = info.endPTS - info.startPTS;\n        if (parsedDuration <= 0) {\n          // Destroy the transmuxer after it's next time offset failed to advance because duration was <= 0.\n          // The new transmuxer will be configured with a time offset matching the next fragment start,\n          // preventing the timeline from shifting.\n          this.warn(`Could not parse fragment ${frag.sn} ${type} duration reliably (${parsedDuration})`);\n          return result || false;\n        }\n        const drift = partial ? 0 : updateFragPTSDTS(details, frag, info.startPTS, info.endPTS, info.startDTS, info.endDTS);\n        this.hls.trigger(Events.LEVEL_PTS_UPDATED, {\n          details,\n          level,\n          drift,\n          type,\n          frag,\n          start: info.startPTS,\n          end: info.endPTS\n        });\n        return true;\n      }\n      return result;\n    }, false);\n    if (!parsed) {\n      var _this$transmuxer;\n      if (level.fragmentError === 0) {\n        // Mark and track the odd empty segment as a gap to avoid reloading\n        this.treatAsGap(frag, level);\n      }\n      if (((_this$transmuxer = this.transmuxer) == null ? void 0 : _this$transmuxer.error) === null) {\n        const error = new Error(`Found no media in fragment ${frag.sn} of ${this.playlistLabel()} ${frag.level} resetting transmuxer to fallback to playlist timing`);\n        this.warn(error.message);\n        this.hls.trigger(Events.ERROR, {\n          type: ErrorTypes.MEDIA_ERROR,\n          details: ErrorDetails.FRAG_PARSING_ERROR,\n          fatal: false,\n          error,\n          frag,\n          reason: `Found no media in msn ${frag.sn} of ${this.playlistLabel()} \"${level.url}\"`\n        });\n        if (!this.hls) {\n          return;\n        }\n        this.resetTransmuxer();\n      }\n      // For this error fallthrough. Marking parsed will allow advancing to next fragment.\n    }\n    this.state = State.PARSED;\n    this.log(`Parsed ${frag.type} sn: ${frag.sn}${part ? ' part: ' + part.index : ''} of ${this.fragInfo(frag, false, part)})`);\n    this.hls.trigger(Events.FRAG_PARSED, {\n      frag,\n      part\n    });\n  }\n  playlistLabel() {\n    return this.playlistType === PlaylistLevelType.MAIN ? 'level' : 'track';\n  }\n  fragInfo(frag, pts = true, part) {\n    var _ref, _ref2;\n    return `${this.playlistLabel()} ${frag.level} (${part ? 'part' : 'frag'}:[${((_ref = pts && !part ? frag.startPTS : (part || frag).start) != null ? _ref : NaN).toFixed(3)}-${((_ref2 = pts && !part ? frag.endPTS : (part || frag).end) != null ? _ref2 : NaN).toFixed(3)}]${part && frag.type === 'main' ? 'INDEPENDENT=' + (part.independent ? 'YES' : 'NO') : ''}`;\n  }\n  treatAsGap(frag, level) {\n    if (level) {\n      level.fragmentError++;\n    }\n    frag.gap = true;\n    this.fragmentTracker.removeFragment(frag);\n    this.fragmentTracker.fragBuffered(frag, true);\n  }\n  resetTransmuxer() {\n    var _this$transmuxer2;\n    (_this$transmuxer2 = this.transmuxer) == null ? void 0 : _this$transmuxer2.reset();\n  }\n  recoverWorkerError(data) {\n    if (data.event === 'demuxerWorker') {\n      this.fragmentTracker.removeAllFragments();\n      if (this.transmuxer) {\n        this.transmuxer.destroy();\n        this.transmuxer = null;\n      }\n      this.resetStartWhenNotLoaded(this.levelLastLoaded);\n      this.resetLoadingState();\n    }\n  }\n  set state(nextState) {\n    const previousState = this._state;\n    if (previousState !== nextState) {\n      this._state = nextState;\n      this.log(`${previousState}->${nextState}`);\n    }\n  }\n  get state() {\n    return this._state;\n  }\n}\nfunction interstitialsEnabled(config) {\n  return !!config.interstitialsController && config.enableInterstitialPlayback !== false;\n}\n\nclass ChunkCache {\n  constructor() {\n    this.chunks = [];\n    this.dataLength = 0;\n  }\n  push(chunk) {\n    this.chunks.push(chunk);\n    this.dataLength += chunk.length;\n  }\n  flush() {\n    const {\n      chunks,\n      dataLength\n    } = this;\n    let result;\n    if (!chunks.length) {\n      return new Uint8Array(0);\n    } else if (chunks.length === 1) {\n      result = chunks[0];\n    } else {\n      result = concatUint8Arrays(chunks, dataLength);\n    }\n    this.reset();\n    return result;\n  }\n  reset() {\n    this.chunks.length = 0;\n    this.dataLength = 0;\n  }\n}\nfunction concatUint8Arrays(chunks, dataLength) {\n  const result = new Uint8Array(dataLength);\n  let offset = 0;\n  for (let i = 0; i < chunks.length; i++) {\n    const chunk = chunks[i];\n    result.set(chunk, offset);\n    offset += chunk.length;\n  }\n  return result;\n}\n\nvar eventemitter3 = {exports: {}};\n\nvar hasRequiredEventemitter3;\n\nfunction requireEventemitter3 () {\n\tif (hasRequiredEventemitter3) return eventemitter3.exports;\n\thasRequiredEventemitter3 = 1;\n\t(function (module) {\n\n\t\tvar has = Object.prototype.hasOwnProperty\n\t\t  , prefix = '~';\n\n\t\t/**\n\t\t * Constructor to create a storage for our `EE` objects.\n\t\t * An `Events` instance is a plain object whose properties are event names.\n\t\t *\n\t\t * @constructor\n\t\t * @private\n\t\t */\n\t\tfunction Events() {}\n\n\t\t//\n\t\t// We try to not inherit from `Object.prototype`. In some engines creating an\n\t\t// instance in this way is faster than calling `Object.create(null)` directly.\n\t\t// If `Object.create(null)` is not supported we prefix the event names with a\n\t\t// character to make sure that the built-in object properties are not\n\t\t// overridden or used as an attack vector.\n\t\t//\n\t\tif (Object.create) {\n\t\t  Events.prototype = Object.create(null);\n\n\t\t  //\n\t\t  // This hack is needed because the `__proto__` property is still inherited in\n\t\t  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n\t\t  //\n\t\t  if (!new Events().__proto__) prefix = false;\n\t\t}\n\n\t\t/**\n\t\t * Representation of a single event listener.\n\t\t *\n\t\t * @param {Function} fn The listener function.\n\t\t * @param {*} context The context to invoke the listener with.\n\t\t * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n\t\t * @constructor\n\t\t * @private\n\t\t */\n\t\tfunction EE(fn, context, once) {\n\t\t  this.fn = fn;\n\t\t  this.context = context;\n\t\t  this.once = once || false;\n\t\t}\n\n\t\t/**\n\t\t * Add a listener for a given event.\n\t\t *\n\t\t * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n\t\t * @param {(String|Symbol)} event The event name.\n\t\t * @param {Function} fn The listener function.\n\t\t * @param {*} context The context to invoke the listener with.\n\t\t * @param {Boolean} once Specify if the listener is a one-time listener.\n\t\t * @returns {EventEmitter}\n\t\t * @private\n\t\t */\n\t\tfunction addListener(emitter, event, fn, context, once) {\n\t\t  if (typeof fn !== 'function') {\n\t\t    throw new TypeError('The listener must be a function');\n\t\t  }\n\n\t\t  var listener = new EE(fn, context || emitter, once)\n\t\t    , evt = prefix ? prefix + event : event;\n\n\t\t  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n\t\t  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n\t\t  else emitter._events[evt] = [emitter._events[evt], listener];\n\n\t\t  return emitter;\n\t\t}\n\n\t\t/**\n\t\t * Clear event by name.\n\t\t *\n\t\t * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n\t\t * @param {(String|Symbol)} evt The Event name.\n\t\t * @private\n\t\t */\n\t\tfunction clearEvent(emitter, evt) {\n\t\t  if (--emitter._eventsCount === 0) emitter._events = new Events();\n\t\t  else delete emitter._events[evt];\n\t\t}\n\n\t\t/**\n\t\t * Minimal `EventEmitter` interface that is molded against the Node.js\n\t\t * `EventEmitter` interface.\n\t\t *\n\t\t * @constructor\n\t\t * @public\n\t\t */\n\t\tfunction EventEmitter() {\n\t\t  this._events = new Events();\n\t\t  this._eventsCount = 0;\n\t\t}\n\n\t\t/**\n\t\t * Return an array listing the events for which the emitter has registered\n\t\t * listeners.\n\t\t *\n\t\t * @returns {Array}\n\t\t * @public\n\t\t */\n\t\tEventEmitter.prototype.eventNames = function eventNames() {\n\t\t  var names = []\n\t\t    , events\n\t\t    , name;\n\n\t\t  if (this._eventsCount === 0) return names;\n\n\t\t  for (name in (events = this._events)) {\n\t\t    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n\t\t  }\n\n\t\t  if (Object.getOwnPropertySymbols) {\n\t\t    return names.concat(Object.getOwnPropertySymbols(events));\n\t\t  }\n\n\t\t  return names;\n\t\t};\n\n\t\t/**\n\t\t * Return the listeners registered for a given event.\n\t\t *\n\t\t * @param {(String|Symbol)} event The event name.\n\t\t * @returns {Array} The registered listeners.\n\t\t * @public\n\t\t */\n\t\tEventEmitter.prototype.listeners = function listeners(event) {\n\t\t  var evt = prefix ? prefix + event : event\n\t\t    , handlers = this._events[evt];\n\n\t\t  if (!handlers) return [];\n\t\t  if (handlers.fn) return [handlers.fn];\n\n\t\t  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n\t\t    ee[i] = handlers[i].fn;\n\t\t  }\n\n\t\t  return ee;\n\t\t};\n\n\t\t/**\n\t\t * Return the number of listeners listening to a given event.\n\t\t *\n\t\t * @param {(String|Symbol)} event The event name.\n\t\t * @returns {Number} The number of listeners.\n\t\t * @public\n\t\t */\n\t\tEventEmitter.prototype.listenerCount = function listenerCount(event) {\n\t\t  var evt = prefix ? prefix + event : event\n\t\t    , listeners = this._events[evt];\n\n\t\t  if (!listeners) return 0;\n\t\t  if (listeners.fn) return 1;\n\t\t  return listeners.length;\n\t\t};\n\n\t\t/**\n\t\t * Calls each of the listeners registered for a given event.\n\t\t *\n\t\t * @param {(String|Symbol)} event The event name.\n\t\t * @returns {Boolean} `true` if the event had listeners, else `false`.\n\t\t * @public\n\t\t */\n\t\tEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n\t\t  var evt = prefix ? prefix + event : event;\n\n\t\t  if (!this._events[evt]) return false;\n\n\t\t  var listeners = this._events[evt]\n\t\t    , len = arguments.length\n\t\t    , args\n\t\t    , i;\n\n\t\t  if (listeners.fn) {\n\t\t    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n\t\t    switch (len) {\n\t\t      case 1: return listeners.fn.call(listeners.context), true;\n\t\t      case 2: return listeners.fn.call(listeners.context, a1), true;\n\t\t      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n\t\t      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n\t\t      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n\t\t      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n\t\t    }\n\n\t\t    for (i = 1, args = new Array(len -1); i < len; i++) {\n\t\t      args[i - 1] = arguments[i];\n\t\t    }\n\n\t\t    listeners.fn.apply(listeners.context, args);\n\t\t  } else {\n\t\t    var length = listeners.length\n\t\t      , j;\n\n\t\t    for (i = 0; i < length; i++) {\n\t\t      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n\t\t      switch (len) {\n\t\t        case 1: listeners[i].fn.call(listeners[i].context); break;\n\t\t        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n\t\t        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n\t\t        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n\t\t        default:\n\t\t          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n\t\t            args[j - 1] = arguments[j];\n\t\t          }\n\n\t\t          listeners[i].fn.apply(listeners[i].context, args);\n\t\t      }\n\t\t    }\n\t\t  }\n\n\t\t  return true;\n\t\t};\n\n\t\t/**\n\t\t * Add a listener for a given event.\n\t\t *\n\t\t * @param {(String|Symbol)} event The event name.\n\t\t * @param {Function} fn The listener function.\n\t\t * @param {*} [context=this] The context to invoke the listener with.\n\t\t * @returns {EventEmitter} `this`.\n\t\t * @public\n\t\t */\n\t\tEventEmitter.prototype.on = function on(event, fn, context) {\n\t\t  return addListener(this, event, fn, context, false);\n\t\t};\n\n\t\t/**\n\t\t * Add a one-time listener for a given event.\n\t\t *\n\t\t * @param {(String|Symbol)} event The event name.\n\t\t * @param {Function} fn The listener function.\n\t\t * @param {*} [context=this] The context to invoke the listener with.\n\t\t * @returns {EventEmitter} `this`.\n\t\t * @public\n\t\t */\n\t\tEventEmitter.prototype.once = function once(event, fn, context) {\n\t\t  return addListener(this, event, fn, context, true);\n\t\t};\n\n\t\t/**\n\t\t * Remove the listeners of a given event.\n\t\t *\n\t\t * @param {(String|Symbol)} event The event name.\n\t\t * @param {Function} fn Only remove the listeners that match this function.\n\t\t * @param {*} context Only remove the listeners that have this context.\n\t\t * @param {Boolean} once Only remove one-time listeners.\n\t\t * @returns {EventEmitter} `this`.\n\t\t * @public\n\t\t */\n\t\tEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n\t\t  var evt = prefix ? prefix + event : event;\n\n\t\t  if (!this._events[evt]) return this;\n\t\t  if (!fn) {\n\t\t    clearEvent(this, evt);\n\t\t    return this;\n\t\t  }\n\n\t\t  var listeners = this._events[evt];\n\n\t\t  if (listeners.fn) {\n\t\t    if (\n\t\t      listeners.fn === fn &&\n\t\t      (!once || listeners.once) &&\n\t\t      (!context || listeners.context === context)\n\t\t    ) {\n\t\t      clearEvent(this, evt);\n\t\t    }\n\t\t  } else {\n\t\t    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n\t\t      if (\n\t\t        listeners[i].fn !== fn ||\n\t\t        (once && !listeners[i].once) ||\n\t\t        (context && listeners[i].context !== context)\n\t\t      ) {\n\t\t        events.push(listeners[i]);\n\t\t      }\n\t\t    }\n\n\t\t    //\n\t\t    // Reset the array, or remove it completely if we have no more listeners.\n\t\t    //\n\t\t    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n\t\t    else clearEvent(this, evt);\n\t\t  }\n\n\t\t  return this;\n\t\t};\n\n\t\t/**\n\t\t * Remove all listeners, or those of the specified event.\n\t\t *\n\t\t * @param {(String|Symbol)} [event] The event name.\n\t\t * @returns {EventEmitter} `this`.\n\t\t * @public\n\t\t */\n\t\tEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n\t\t  var evt;\n\n\t\t  if (event) {\n\t\t    evt = prefix ? prefix + event : event;\n\t\t    if (this._events[evt]) clearEvent(this, evt);\n\t\t  } else {\n\t\t    this._events = new Events();\n\t\t    this._eventsCount = 0;\n\t\t  }\n\n\t\t  return this;\n\t\t};\n\n\t\t//\n\t\t// Alias methods names because people roll like that.\n\t\t//\n\t\tEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\t\tEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n\t\t//\n\t\t// Expose the prefix.\n\t\t//\n\t\tEventEmitter.prefixed = prefix;\n\n\t\t//\n\t\t// Allow `EventEmitter` to be imported as module namespace.\n\t\t//\n\t\tEventEmitter.EventEmitter = EventEmitter;\n\n\t\t//\n\t\t// Expose the module.\n\t\t//\n\t\t{\n\t\t  module.exports = EventEmitter;\n\t\t} \n\t} (eventemitter3));\n\treturn eventemitter3.exports;\n}\n\nvar eventemitter3Exports = requireEventemitter3();\nvar EventEmitter = /*@__PURE__*/getDefaultExportFromCjs(eventemitter3Exports);\n\nconst version = \"1.6.7\";\n\n// ensure the worker ends up in the bundle\n// If the worker should not be included this gets aliased to empty.js\nconst workerStore = {};\nfunction hasUMDWorker() {\n  return typeof __HLS_WORKER_BUNDLE__ === 'function';\n}\nfunction injectWorker() {\n  const workerContext = workerStore[version];\n  if (workerContext) {\n    workerContext.clientCount++;\n    return workerContext;\n  }\n  const blob = new self.Blob([`var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(${__HLS_WORKER_BUNDLE__.toString()})(true);`], {\n    type: 'text/javascript'\n  });\n  const objectURL = self.URL.createObjectURL(blob);\n  const worker = new self.Worker(objectURL);\n  const result = {\n    worker,\n    objectURL,\n    clientCount: 1\n  };\n  workerStore[version] = result;\n  return result;\n}\nfunction loadWorker(path) {\n  const workerContext = workerStore[path];\n  if (workerContext) {\n    workerContext.clientCount++;\n    return workerContext;\n  }\n  const scriptURL = new self.URL(path, self.location.href).href;\n  const worker = new self.Worker(scriptURL);\n  const result = {\n    worker,\n    scriptURL,\n    clientCount: 1\n  };\n  workerStore[path] = result;\n  return result;\n}\nfunction removeWorkerFromStore(path) {\n  const workerContext = workerStore[path || version];\n  if (workerContext) {\n    const clientCount = workerContext.clientCount--;\n    if (clientCount === 1) {\n      const {\n        worker,\n        objectURL\n      } = workerContext;\n      delete workerStore[path || version];\n      if (objectURL) {\n        // revoke the Object URL that was used to create transmuxer worker, so as not to leak it\n        self.URL.revokeObjectURL(objectURL);\n      }\n      worker.terminate();\n    }\n  }\n}\n\n/**\n * Returns true if an ID3 footer can be found at offset in data\n *\n * @param data - The data to search in\n * @param offset - The offset at which to start searching\n *\n * @returns `true` if an ID3 footer is found\n *\n * @internal\n *\n * @group ID3\n */\nfunction isId3Footer(data, offset) {\n  /*\n   * The footer is a copy of the header, but with a different identifier\n   */\n  if (offset + 10 <= data.length) {\n    // look for '3DI' identifier\n    if (data[offset] === 0x33 && data[offset + 1] === 0x44 && data[offset + 2] === 0x49) {\n      // check version is within range\n      if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {\n        // check size is within range\n        if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Returns true if an ID3 header can be found at offset in data\n *\n * @param data - The data to search in\n * @param offset - The offset at which to start searching\n *\n * @returns `true` if an ID3 header is found\n *\n * @internal\n *\n * @group ID3\n */\nfunction isId3Header(data, offset) {\n  /*\n   * http://id3.org/id3v2.3.0\n   * [0]     = 'I'\n   * [1]     = 'D'\n   * [2]     = '3'\n   * [3,4]   = {Version}\n   * [5]     = {Flags}\n   * [6-9]   = {ID3 Size}\n   *\n   * An ID3v2 tag can be detected with the following pattern:\n   *  $49 44 33 yy yy xx zz zz zz zz\n   * Where yy is less than $FF, xx is the 'flags' byte and zz is less than $80\n   */\n  if (offset + 10 <= data.length) {\n    // look for 'ID3' identifier\n    if (data[offset] === 0x49 && data[offset + 1] === 0x44 && data[offset + 2] === 0x33) {\n      // check version is within range\n      if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {\n        // check size is within range\n        if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Read ID3 size\n *\n * @param data - The data to read from\n * @param offset - The offset at which to start reading\n *\n * @returns The size\n *\n * @internal\n *\n * @group ID3\n */\nfunction readId3Size(data, offset) {\n  let size = 0;\n  size = (data[offset] & 0x7f) << 21;\n  size |= (data[offset + 1] & 0x7f) << 14;\n  size |= (data[offset + 2] & 0x7f) << 7;\n  size |= data[offset + 3] & 0x7f;\n  return size;\n}\n\n/**\n * Returns any adjacent ID3 tags found in data starting at offset, as one block of data\n *\n * @param data - The data to search in\n * @param offset - The offset at which to start searching\n *\n * @returns The block of data containing any ID3 tags found\n * or `undefined` if no header is found at the starting offset\n *\n * @internal\n *\n * @group ID3\n */\nfunction getId3Data(data, offset) {\n  const front = offset;\n  let length = 0;\n  while (isId3Header(data, offset)) {\n    // ID3 header is 10 bytes\n    length += 10;\n    const size = readId3Size(data, offset + 6);\n    length += size;\n    if (isId3Footer(data, offset + 10)) {\n      // ID3 footer is 10 bytes\n      length += 10;\n    }\n    offset += length;\n  }\n  if (length > 0) {\n    return data.subarray(front, front + length);\n  }\n  return undefined;\n}\n\nfunction getAudioConfig(observer, data, offset, manifestCodec) {\n  const adtsSamplingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n  const byte2 = data[offset + 2];\n  const adtsSamplingIndex = byte2 >> 2 & 0xf;\n  if (adtsSamplingIndex > 12) {\n    const error = new Error(`invalid ADTS sampling index:${adtsSamplingIndex}`);\n    observer.emit(Events.ERROR, Events.ERROR, {\n      type: ErrorTypes.MEDIA_ERROR,\n      details: ErrorDetails.FRAG_PARSING_ERROR,\n      fatal: true,\n      error,\n      reason: error.message\n    });\n    return;\n  }\n  // MPEG-4 Audio Object Type (profile_ObjectType+1)\n  const adtsObjectType = (byte2 >> 6 & 0x3) + 1;\n  const channelCount = data[offset + 3] >> 6 & 0x3 | (byte2 & 1) << 2;\n  const codec = 'mp4a.40.' + adtsObjectType;\n  /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config\n      ISO/IEC 14496-3 - Table 1.13  Syntax of AudioSpecificConfig()\n    Audio Profile / Audio Object Type\n    0: Null\n    1: AAC Main\n    2: AAC LC (Low Complexity)\n    3: AAC SSR (Scalable Sample Rate)\n    4: AAC LTP (Long Term Prediction)\n    5: SBR (Spectral Band Replication)\n    6: AAC Scalable\n   sampling freq\n    0: 96000 Hz\n    1: 88200 Hz\n    2: 64000 Hz\n    3: 48000 Hz\n    4: 44100 Hz\n    5: 32000 Hz\n    6: 24000 Hz\n    7: 22050 Hz\n    8: 16000 Hz\n    9: 12000 Hz\n    10: 11025 Hz\n    11: 8000 Hz\n    12: 7350 Hz\n    13: Reserved\n    14: Reserved\n    15: frequency is written explictly\n    Channel Configurations\n    These are the channel configurations:\n    0: Defined in AOT Specifc Config\n    1: 1 channel: front-center\n    2: 2 channels: front-left, front-right\n  */\n  // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1\n  const samplerate = adtsSamplingRates[adtsSamplingIndex];\n  let aacSampleIndex = adtsSamplingIndex;\n  if (adtsObjectType === 5 || adtsObjectType === 29) {\n    // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\n    // there is a factor 2 between frame sample rate and output sample rate\n    // multiply frequency by 2 (see table above, equivalent to substract 3)\n    aacSampleIndex -= 3;\n  }\n  const config = [adtsObjectType << 3 | (aacSampleIndex & 0x0e) >> 1, (aacSampleIndex & 0x01) << 7 | channelCount << 3];\n  logger.log(`manifest codec:${manifestCodec}, parsed codec:${codec}, channels:${channelCount}, rate:${samplerate} (ADTS object type:${adtsObjectType} sampling index:${adtsSamplingIndex})`);\n  return {\n    config,\n    samplerate,\n    channelCount,\n    codec,\n    parsedCodec: codec,\n    manifestCodec\n  };\n}\nfunction isHeaderPattern$1(data, offset) {\n  return data[offset] === 0xff && (data[offset + 1] & 0xf6) === 0xf0;\n}\nfunction getHeaderLength(data, offset) {\n  return data[offset + 1] & 0x01 ? 7 : 9;\n}\nfunction getFullFrameLength(data, offset) {\n  return (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xe0) >>> 5;\n}\nfunction canGetFrameLength(data, offset) {\n  return offset + 5 < data.length;\n}\nfunction isHeader$1(data, offset) {\n  // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1\n  // Layer bits (position 14 and 15) in header should be always 0 for ADTS\n  // More info https://wiki.multimedia.cx/index.php?title=ADTS\n  return offset + 1 < data.length && isHeaderPattern$1(data, offset);\n}\nfunction canParse$1(data, offset) {\n  return canGetFrameLength(data, offset) && isHeaderPattern$1(data, offset) && getFullFrameLength(data, offset) <= data.length - offset;\n}\nfunction probe$1(data, offset) {\n  // same as isHeader but we also check that ADTS frame follows last ADTS frame\n  // or end of data is reached\n  if (isHeader$1(data, offset)) {\n    // ADTS header Length\n    const headerLength = getHeaderLength(data, offset);\n    if (offset + headerLength >= data.length) {\n      return false;\n    }\n    // ADTS frame Length\n    const frameLength = getFullFrameLength(data, offset);\n    if (frameLength <= headerLength) {\n      return false;\n    }\n    const newOffset = offset + frameLength;\n    return newOffset === data.length || isHeader$1(data, newOffset);\n  }\n  return false;\n}\nfunction initTrackConfig(track, observer, data, offset, audioCodec) {\n  if (!track.samplerate) {\n    const config = getAudioConfig(observer, data, offset, audioCodec);\n    if (!config) {\n      return;\n    }\n    _extends(track, config);\n  }\n}\nfunction getFrameDuration(samplerate) {\n  return 1024 * 90000 / samplerate;\n}\nfunction parseFrameHeader(data, offset) {\n  // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header\n  const headerLength = getHeaderLength(data, offset);\n  if (offset + headerLength <= data.length) {\n    // retrieve frame size\n    const frameLength = getFullFrameLength(data, offset) - headerLength;\n    if (frameLength > 0) {\n      // logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}`);\n      return {\n        headerLength,\n        frameLength\n      };\n    }\n  }\n}\nfunction appendFrame$2(track, data, offset, pts, frameIndex) {\n  const frameDuration = getFrameDuration(track.samplerate);\n  const stamp = pts + frameIndex * frameDuration;\n  const header = parseFrameHeader(data, offset);\n  let unit;\n  if (header) {\n    const {\n      frameLength,\n      headerLength\n    } = header;\n    const _length = headerLength + frameLength;\n    const missing = Math.max(0, offset + _length - data.length);\n    // logger.log(`AAC frame ${frameIndex}, pts:${stamp} length@offset/total: ${frameLength}@${offset+headerLength}/${data.byteLength} missing: ${missing}`);\n    if (missing) {\n      unit = new Uint8Array(_length - headerLength);\n      unit.set(data.subarray(offset + headerLength, data.length), 0);\n    } else {\n      unit = data.subarray(offset + headerLength, offset + _length);\n    }\n    const _sample = {\n      unit,\n      pts: stamp\n    };\n    if (!missing) {\n      track.samples.push(_sample);\n    }\n    return {\n      sample: _sample,\n      length: _length,\n      missing\n    };\n  }\n  // overflow incomplete header\n  const length = data.length - offset;\n  unit = new Uint8Array(length);\n  unit.set(data.subarray(offset, data.length), 0);\n  const sample = {\n    unit,\n    pts: stamp\n  };\n  return {\n    sample,\n    length,\n    missing: -1\n  };\n}\n\n/**\n * Checks if the given data contains an ID3 tag.\n *\n * @param data - The data to check\n * @param offset - The offset at which to start checking\n *\n * @returns `true` if an ID3 tag is found\n *\n * @group ID3\n *\n * @beta\n */\nfunction canParseId3(data, offset) {\n  return isId3Header(data, offset) && readId3Size(data, offset + 6) + 10 <= data.length - offset;\n}\n\nfunction toArrayBuffer(view) {\n  if (view instanceof ArrayBuffer) {\n    return view;\n  } else {\n    if (view.byteOffset == 0 && view.byteLength == view.buffer.byteLength) {\n      // This is a TypedArray over the whole buffer.\n      return view.buffer;\n    }\n    // This is a 'view' on the buffer.  Create a new buffer that only contains\n    // the data.  Note that since this isn't an ArrayBuffer, the 'new' call\n    // will allocate a new buffer to hold the copy.\n    return new Uint8Array(view).buffer;\n  }\n}\n\nfunction toUint8(data, offset = 0, length = Infinity) {\n  return view(data, offset, length, Uint8Array);\n}\nfunction view(data, offset, length, Type) {\n  const buffer = unsafeGetArrayBuffer(data);\n  let bytesPerElement = 1;\n  if ('BYTES_PER_ELEMENT' in Type) {\n    bytesPerElement = Type.BYTES_PER_ELEMENT;\n  }\n  // Absolute end of the |data| view within |buffer|.\n  const dataOffset = isArrayBufferView(data) ? data.byteOffset : 0;\n  const dataEnd = (dataOffset + data.byteLength) / bytesPerElement;\n  // Absolute start of the result within |buffer|.\n  const rawStart = (dataOffset + offset) / bytesPerElement;\n  const start = Math.floor(Math.max(0, Math.min(rawStart, dataEnd)));\n  // Absolute end of the result within |buffer|.\n  const end = Math.floor(Math.min(start + Math.max(length, 0), dataEnd));\n  return new Type(buffer, start, end - start);\n}\nfunction unsafeGetArrayBuffer(view) {\n  if (view instanceof ArrayBuffer) {\n    return view;\n  } else {\n    return view.buffer;\n  }\n}\nfunction isArrayBufferView(obj) {\n  return obj && obj.buffer instanceof ArrayBuffer && obj.byteLength !== undefined && obj.byteOffset !== undefined;\n}\n\nfunction decodeId3ImageFrame(frame) {\n  const metadataFrame = {\n    key: frame.type,\n    description: '',\n    data: '',\n    mimeType: null,\n    pictureType: null\n  };\n  const utf8Encoding = 0x03;\n  if (frame.size < 2) {\n    return undefined;\n  }\n  if (frame.data[0] !== utf8Encoding) {\n    console.log('Ignore frame with unrecognized character ' + 'encoding');\n    return undefined;\n  }\n  const mimeTypeEndIndex = frame.data.subarray(1).indexOf(0);\n  if (mimeTypeEndIndex === -1) {\n    return undefined;\n  }\n  const mimeType = utf8ArrayToStr(toUint8(frame.data, 1, mimeTypeEndIndex));\n  const pictureType = frame.data[2 + mimeTypeEndIndex];\n  const descriptionEndIndex = frame.data.subarray(3 + mimeTypeEndIndex).indexOf(0);\n  if (descriptionEndIndex === -1) {\n    return undefined;\n  }\n  const description = utf8ArrayToStr(toUint8(frame.data, 3 + mimeTypeEndIndex, descriptionEndIndex));\n  let data;\n  if (mimeType === '-->') {\n    data = utf8ArrayToStr(toUint8(frame.data, 4 + mimeTypeEndIndex + descriptionEndIndex));\n  } else {\n    data = toArrayBuffer(frame.data.subarray(4 + mimeTypeEndIndex + descriptionEndIndex));\n  }\n  metadataFrame.mimeType = mimeType;\n  metadataFrame.pictureType = pictureType;\n  metadataFrame.description = description;\n  metadataFrame.data = data;\n  return metadataFrame;\n}\n\n/**\n * Decode an ID3 PRIV frame.\n *\n * @param frame - the ID3 PRIV frame\n *\n * @returns The decoded ID3 PRIV frame\n *\n * @internal\n *\n * @group ID3\n */\nfunction decodeId3PrivFrame(frame) {\n  /*\n  Format: <text string>\\0<binary data>\n  */\n  if (frame.size < 2) {\n    return undefined;\n  }\n  const owner = utf8ArrayToStr(frame.data, true);\n  const privateData = new Uint8Array(frame.data.subarray(owner.length + 1));\n  return {\n    key: frame.type,\n    info: owner,\n    data: privateData.buffer\n  };\n}\n\n/**\n * Decodes an ID3 text frame\n *\n * @param frame - the ID3 text frame\n *\n * @returns The decoded ID3 text frame\n *\n * @internal\n *\n * @group ID3\n */\nfunction decodeId3TextFrame(frame) {\n  if (frame.size < 2) {\n    return undefined;\n  }\n  if (frame.type === 'TXXX') {\n    /*\n    Format:\n    [0]   = {Text Encoding}\n    [1-?] = {Description}\\0{Value}\n    */\n    let index = 1;\n    const description = utf8ArrayToStr(frame.data.subarray(index), true);\n    index += description.length + 1;\n    const value = utf8ArrayToStr(frame.data.subarray(index));\n    return {\n      key: frame.type,\n      info: description,\n      data: value\n    };\n  }\n  /*\n  Format:\n  [0]   = {Text Encoding}\n  [1-?] = {Value}\n  */\n  const text = utf8ArrayToStr(frame.data.subarray(1));\n  return {\n    key: frame.type,\n    info: '',\n    data: text\n  };\n}\n\n/**\n * Decode a URL frame\n *\n * @param frame - the ID3 URL frame\n *\n * @returns The decoded ID3 URL frame\n *\n * @internal\n *\n * @group ID3\n */\nfunction decodeId3UrlFrame(frame) {\n  if (frame.type === 'WXXX') {\n    /*\n    Format:\n    [0]   = {Text Encoding}\n    [1-?] = {Description}\\0{URL}\n    */\n    if (frame.size < 2) {\n      return undefined;\n    }\n    let index = 1;\n    const description = utf8ArrayToStr(frame.data.subarray(index), true);\n    index += description.length + 1;\n    const value = utf8ArrayToStr(frame.data.subarray(index));\n    return {\n      key: frame.type,\n      info: description,\n      data: value\n    };\n  }\n  /*\n  Format:\n  [0-?] = {URL}\n  */\n  const url = utf8ArrayToStr(frame.data);\n  return {\n    key: frame.type,\n    info: '',\n    data: url\n  };\n}\n\n/**\n * Decode an ID3 frame.\n *\n * @param frame - the ID3 frame\n *\n * @returns The decoded ID3 frame\n *\n * @internal\n *\n * @group ID3\n */\nfunction decodeId3Frame(frame) {\n  if (frame.type === 'PRIV') {\n    return decodeId3PrivFrame(frame);\n  } else if (frame.type[0] === 'W') {\n    return decodeId3UrlFrame(frame);\n  } else if (frame.type === 'APIC') {\n    return decodeId3ImageFrame(frame);\n  }\n  return decodeId3TextFrame(frame);\n}\n\n/**\n * Returns the data of an ID3 frame.\n *\n * @param data - The data to read from\n *\n * @returns The data of the ID3 frame\n *\n * @internal\n *\n * @group ID3\n */\nfunction getId3FrameData(data) {\n  /*\n  Frame ID       $xx xx xx xx (four characters)\n  Size           $xx xx xx xx\n  Flags          $xx xx\n  */\n  const type = String.fromCharCode(data[0], data[1], data[2], data[3]);\n  const size = readId3Size(data, 4);\n  // skip frame id, size, and flags\n  const offset = 10;\n  return {\n    type,\n    size,\n    data: data.subarray(offset, offset + size)\n  };\n}\n\nconst HEADER_FOOTER_SIZE = 10;\nconst FRAME_SIZE = 10;\n/**\n * Returns an array of ID3 frames found in all the ID3 tags in the id3Data\n *\n * @param id3Data - The ID3 data containing one or more ID3 tags\n *\n * @returns Array of ID3 frame objects\n *\n * @group ID3\n *\n * @beta\n */\nfunction getId3Frames(id3Data) {\n  let offset = 0;\n  const frames = [];\n  while (isId3Header(id3Data, offset)) {\n    const size = readId3Size(id3Data, offset + 6);\n    if (id3Data[offset + 5] >> 6 & 1) {\n      // skip extended header\n      offset += HEADER_FOOTER_SIZE;\n    }\n    // skip past ID3 header\n    offset += HEADER_FOOTER_SIZE;\n    const end = offset + size;\n    // loop through frames in the ID3 tag\n    while (offset + FRAME_SIZE < end) {\n      const frameData = getId3FrameData(id3Data.subarray(offset));\n      const frame = decodeId3Frame(frameData);\n      if (frame) {\n        frames.push(frame);\n      }\n      // skip frame header and frame data\n      offset += frameData.size + HEADER_FOOTER_SIZE;\n    }\n    if (isId3Footer(id3Data, offset)) {\n      offset += HEADER_FOOTER_SIZE;\n    }\n  }\n  return frames;\n}\n\n/**\n * Returns true if the ID3 frame is an Elementary Stream timestamp frame\n *\n * @param frame - the ID3 frame\n *\n * @returns `true` if the ID3 frame is an Elementary Stream timestamp frame\n *\n * @internal\n *\n * @group ID3\n */\nfunction isId3TimestampFrame(frame) {\n  return frame && frame.key === 'PRIV' && frame.info === 'com.apple.streaming.transportStreamTimestamp';\n}\n\n/**\n * Read a 33 bit timestamp from an ID3 frame.\n *\n * @param timeStampFrame - the ID3 frame\n *\n * @returns The timestamp\n *\n * @internal\n *\n * @group ID3\n */\nfunction readId3Timestamp(timeStampFrame) {\n  if (timeStampFrame.data.byteLength === 8) {\n    const data = new Uint8Array(timeStampFrame.data);\n    // timestamp is 33 bit expressed as a big-endian eight-octet number,\n    // with the upper 31 bits set to zero.\n    const pts33Bit = data[3] & 0x1;\n    let timestamp = (data[4] << 23) + (data[5] << 15) + (data[6] << 7) + data[7];\n    timestamp /= 45;\n    if (pts33Bit) {\n      timestamp += 47721858.84;\n    } // 2^32 / 90\n    return Math.round(timestamp);\n  }\n  return undefined;\n}\n\n/**\n * Searches for the Elementary Stream timestamp found in the ID3 data chunk\n *\n * @param data - Block of data containing one or more ID3 tags\n *\n * @returns The timestamp\n *\n * @group ID3\n *\n * @beta\n */\nfunction getId3Timestamp(data) {\n  const frames = getId3Frames(data);\n  for (let i = 0; i < frames.length; i++) {\n    const frame = frames[i];\n    if (isId3TimestampFrame(frame)) {\n      return readId3Timestamp(frame);\n    }\n  }\n  return undefined;\n}\n\nlet MetadataSchema = /*#__PURE__*/function (MetadataSchema) {\n  MetadataSchema[\"audioId3\"] = \"org.id3\";\n  MetadataSchema[\"dateRange\"] = \"com.apple.quicktime.HLS\";\n  MetadataSchema[\"emsg\"] = \"https://aomedia.org/emsg/ID3\";\n  MetadataSchema[\"misbklv\"] = \"urn:misb:KLV:bin:1910.1\";\n  return MetadataSchema;\n}({});\n\nfunction dummyTrack(type = '', inputTimeScale = 90000) {\n  return {\n    type,\n    id: -1,\n    pid: -1,\n    inputTimeScale,\n    sequenceNumber: -1,\n    samples: [],\n    dropped: 0\n  };\n}\n\nclass BaseAudioDemuxer {\n  constructor() {\n    this._audioTrack = void 0;\n    this._id3Track = void 0;\n    this.frameIndex = 0;\n    this.cachedData = null;\n    this.basePTS = null;\n    this.initPTS = null;\n    this.lastPTS = null;\n  }\n  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    this._id3Track = {\n      type: 'id3',\n      id: 3,\n      pid: -1,\n      inputTimeScale: 90000,\n      sequenceNumber: 0,\n      samples: [],\n      dropped: 0\n    };\n  }\n  resetTimeStamp(deaultTimestamp) {\n    this.initPTS = deaultTimestamp;\n    this.resetContiguity();\n  }\n  resetContiguity() {\n    this.basePTS = null;\n    this.lastPTS = null;\n    this.frameIndex = 0;\n  }\n  canParse(data, offset) {\n    return false;\n  }\n  appendFrame(track, data, offset) {}\n\n  // feed incoming data to the front of the parsing pipeline\n  demux(data, timeOffset) {\n    if (this.cachedData) {\n      data = appendUint8Array(this.cachedData, data);\n      this.cachedData = null;\n    }\n    let id3Data = getId3Data(data, 0);\n    let offset = id3Data ? id3Data.length : 0;\n    let lastDataIndex;\n    const track = this._audioTrack;\n    const id3Track = this._id3Track;\n    const timestamp = id3Data ? getId3Timestamp(id3Data) : undefined;\n    const length = data.length;\n    if (this.basePTS === null || this.frameIndex === 0 && isFiniteNumber(timestamp)) {\n      this.basePTS = initPTSFn(timestamp, timeOffset, this.initPTS);\n      this.lastPTS = this.basePTS;\n    }\n    if (this.lastPTS === null) {\n      this.lastPTS = this.basePTS;\n    }\n\n    // more expressive than alternative: id3Data?.length\n    if (id3Data && id3Data.length > 0) {\n      id3Track.samples.push({\n        pts: this.lastPTS,\n        dts: this.lastPTS,\n        data: id3Data,\n        type: MetadataSchema.audioId3,\n        duration: Number.POSITIVE_INFINITY\n      });\n    }\n    while (offset < length) {\n      if (this.canParse(data, offset)) {\n        const frame = this.appendFrame(track, data, offset);\n        if (frame) {\n          this.frameIndex++;\n          this.lastPTS = frame.sample.pts;\n          offset += frame.length;\n          lastDataIndex = offset;\n        } else {\n          offset = length;\n        }\n      } else if (canParseId3(data, offset)) {\n        // after a canParse, a call to getId3Data *should* always returns some data\n        id3Data = getId3Data(data, offset);\n        id3Track.samples.push({\n          pts: this.lastPTS,\n          dts: this.lastPTS,\n          data: id3Data,\n          type: MetadataSchema.audioId3,\n          duration: Number.POSITIVE_INFINITY\n        });\n        offset += id3Data.length;\n        lastDataIndex = offset;\n      } else {\n        offset++;\n      }\n      if (offset === length && lastDataIndex !== length) {\n        const partialData = data.slice(lastDataIndex);\n        if (this.cachedData) {\n          this.cachedData = appendUint8Array(this.cachedData, partialData);\n        } else {\n          this.cachedData = partialData;\n        }\n      }\n    }\n    return {\n      audioTrack: track,\n      videoTrack: dummyTrack(),\n      id3Track,\n      textTrack: dummyTrack()\n    };\n  }\n  demuxSampleAes(data, keyData, timeOffset) {\n    return Promise.reject(new Error(`[${this}] This demuxer does not support Sample-AES decryption`));\n  }\n  flush(timeOffset) {\n    // Parse cache in case of remaining frames.\n    const cachedData = this.cachedData;\n    if (cachedData) {\n      this.cachedData = null;\n      this.demux(cachedData, 0);\n    }\n    return {\n      audioTrack: this._audioTrack,\n      videoTrack: dummyTrack(),\n      id3Track: this._id3Track,\n      textTrack: dummyTrack()\n    };\n  }\n  destroy() {\n    this.cachedData = null;\n    // @ts-ignore\n    this._audioTrack = this._id3Track = undefined;\n  }\n}\n\n/**\n * Initialize PTS\n * <p>\n *    use timestamp unless it is undefined, NaN or Infinity\n * </p>\n */\nconst initPTSFn = (timestamp, timeOffset, initPTS) => {\n  if (isFiniteNumber(timestamp)) {\n    return timestamp * 90;\n  }\n  const init90kHz = initPTS ? initPTS.baseTime * 90000 / initPTS.timescale : 0;\n  return timeOffset * 90000 + init90kHz;\n};\n\n/**\n *  MPEG parser helper\n */\n\nlet chromeVersion$1 = null;\nconst BitratesMap = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160];\nconst SamplingRateMap = [44100, 48000, 32000, 22050, 24000, 16000, 11025, 12000, 8000];\nconst SamplesCoefficients = [\n// MPEG 2.5\n[0,\n// Reserved\n72,\n// Layer3\n144,\n// Layer2\n12 // Layer1\n],\n// Reserved\n[0,\n// Reserved\n0,\n// Layer3\n0,\n// Layer2\n0 // Layer1\n],\n// MPEG 2\n[0,\n// Reserved\n72,\n// Layer3\n144,\n// Layer2\n12 // Layer1\n],\n// MPEG 1\n[0,\n// Reserved\n144,\n// Layer3\n144,\n// Layer2\n12 // Layer1\n]];\nconst BytesInSlot = [0,\n// Reserved\n1,\n// Layer3\n1,\n// Layer2\n4 // Layer1\n];\nfunction appendFrame$1(track, data, offset, pts, frameIndex) {\n  // Using http://www.datavoyage.com/mpgscript/mpeghdr.htm as a reference\n  if (offset + 24 > data.length) {\n    return;\n  }\n  const header = parseHeader(data, offset);\n  if (header && offset + header.frameLength <= data.length) {\n    const frameDuration = header.samplesPerFrame * 90000 / header.sampleRate;\n    const stamp = pts + frameIndex * frameDuration;\n    const sample = {\n      unit: data.subarray(offset, offset + header.frameLength),\n      pts: stamp,\n      dts: stamp\n    };\n    track.config = [];\n    track.channelCount = header.channelCount;\n    track.samplerate = header.sampleRate;\n    track.samples.push(sample);\n    return {\n      sample,\n      length: header.frameLength,\n      missing: 0\n    };\n  }\n}\nfunction parseHeader(data, offset) {\n  const mpegVersion = data[offset + 1] >> 3 & 3;\n  const mpegLayer = data[offset + 1] >> 1 & 3;\n  const bitRateIndex = data[offset + 2] >> 4 & 15;\n  const sampleRateIndex = data[offset + 2] >> 2 & 3;\n  if (mpegVersion !== 1 && bitRateIndex !== 0 && bitRateIndex !== 15 && sampleRateIndex !== 3) {\n    const paddingBit = data[offset + 2] >> 1 & 1;\n    const channelMode = data[offset + 3] >> 6;\n    const columnInBitrates = mpegVersion === 3 ? 3 - mpegLayer : mpegLayer === 3 ? 3 : 4;\n    const bitRate = BitratesMap[columnInBitrates * 14 + bitRateIndex - 1] * 1000;\n    const columnInSampleRates = mpegVersion === 3 ? 0 : mpegVersion === 2 ? 1 : 2;\n    const sampleRate = SamplingRateMap[columnInSampleRates * 3 + sampleRateIndex];\n    const channelCount = channelMode === 3 ? 1 : 2; // If bits of channel mode are `11` then it is a single channel (Mono)\n    const sampleCoefficient = SamplesCoefficients[mpegVersion][mpegLayer];\n    const bytesInSlot = BytesInSlot[mpegLayer];\n    const samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;\n    const frameLength = Math.floor(sampleCoefficient * bitRate / sampleRate + paddingBit) * bytesInSlot;\n    if (chromeVersion$1 === null) {\n      const userAgent = navigator.userAgent || '';\n      const result = userAgent.match(/Chrome\\/(\\d+)/i);\n      chromeVersion$1 = result ? parseInt(result[1]) : 0;\n    }\n    const needChromeFix = !!chromeVersion$1 && chromeVersion$1 <= 87;\n    if (needChromeFix && mpegLayer === 2 && bitRate >= 224000 && channelMode === 0) {\n      // Work around bug in Chromium by setting channelMode to dual-channel (01) instead of stereo (00)\n      data[offset + 3] = data[offset + 3] | 0x80;\n    }\n    return {\n      sampleRate,\n      channelCount,\n      frameLength,\n      samplesPerFrame\n    };\n  }\n}\nfunction isHeaderPattern(data, offset) {\n  return data[offset] === 0xff && (data[offset + 1] & 0xe0) === 0xe0 && (data[offset + 1] & 0x06) !== 0x00;\n}\nfunction isHeader(data, offset) {\n  // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1\n  // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)\n  // More info http://www.mp3-tech.org/programmer/frame_header.html\n  return offset + 1 < data.length && isHeaderPattern(data, offset);\n}\nfunction canParse(data, offset) {\n  const headerSize = 4;\n  return isHeaderPattern(data, offset) && headerSize <= data.length - offset;\n}\nfunction probe(data, offset) {\n  // same as isHeader but we also check that MPEG frame follows last MPEG frame\n  // or end of data is reached\n  if (offset + 1 < data.length && isHeaderPattern(data, offset)) {\n    // MPEG header Length\n    const headerLength = 4;\n    // MPEG frame Length\n    const header = parseHeader(data, offset);\n    let frameLength = headerLength;\n    if (header != null && header.frameLength) {\n      frameLength = header.frameLength;\n    }\n    const newOffset = offset + frameLength;\n    return newOffset === data.length || isHeader(data, newOffset);\n  }\n  return false;\n}\n\n/**\n * AAC demuxer\n */\nclass AACDemuxer extends BaseAudioDemuxer {\n  constructor(observer, config) {\n    super();\n    this.observer = void 0;\n    this.config = void 0;\n    this.observer = observer;\n    this.config = config;\n  }\n  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);\n    this._audioTrack = {\n      container: 'audio/adts',\n      type: 'audio',\n      id: 2,\n      pid: -1,\n      sequenceNumber: 0,\n      segmentCodec: 'aac',\n      samples: [],\n      manifestCodec: audioCodec,\n      duration: trackDuration,\n      inputTimeScale: 90000,\n      dropped: 0\n    };\n  }\n\n  // Source for probe info - https://wiki.multimedia.cx/index.php?title=ADTS\n  static probe(data, logger) {\n    if (!data) {\n      return false;\n    }\n\n    // Check for the ADTS sync word\n    // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1\n    // Layer bits (position 14 and 15) in header should be always 0 for ADTS\n    // More info https://wiki.multimedia.cx/index.php?title=ADTS\n    const id3Data = getId3Data(data, 0);\n    let offset = (id3Data == null ? void 0 : id3Data.length) || 0;\n    if (probe(data, offset)) {\n      return false;\n    }\n    for (let length = data.length; offset < length; offset++) {\n      if (probe$1(data, offset)) {\n        logger.log('ADTS sync word found !');\n        return true;\n      }\n    }\n    return false;\n  }\n  canParse(data, offset) {\n    return canParse$1(data, offset);\n  }\n  appendFrame(track, data, offset) {\n    initTrackConfig(track, this.observer, data, offset, track.manifestCodec);\n    const frame = appendFrame$2(track, data, offset, this.basePTS, this.frameIndex);\n    if (frame && frame.missing === 0) {\n      return frame;\n    }\n  }\n}\n\nconst getAudioBSID = (data, offset) => {\n  // check the bsid to confirm ac-3 | ec-3\n  let bsid = 0;\n  let numBits = 5;\n  offset += numBits;\n  const temp = new Uint32Array(1); // unsigned 32 bit for temporary storage\n  const mask = new Uint32Array(1); // unsigned 32 bit mask value\n  const byte = new Uint8Array(1); // unsigned 8 bit for temporary storage\n  while (numBits > 0) {\n    byte[0] = data[offset];\n    // read remaining bits, upto 8 bits at a time\n    const bits = Math.min(numBits, 8);\n    const shift = 8 - bits;\n    mask[0] = 0xff000000 >>> 24 + shift << shift;\n    temp[0] = (byte[0] & mask[0]) >> shift;\n    bsid = !bsid ? temp[0] : bsid << bits | temp[0];\n    offset += 1;\n    numBits -= bits;\n  }\n  return bsid;\n};\n\nclass AC3Demuxer extends BaseAudioDemuxer {\n  constructor(observer) {\n    super();\n    this.observer = void 0;\n    this.observer = observer;\n  }\n  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);\n    this._audioTrack = {\n      container: 'audio/ac-3',\n      type: 'audio',\n      id: 2,\n      pid: -1,\n      sequenceNumber: 0,\n      segmentCodec: 'ac3',\n      samples: [],\n      manifestCodec: audioCodec,\n      duration: trackDuration,\n      inputTimeScale: 90000,\n      dropped: 0\n    };\n  }\n  canParse(data, offset) {\n    return offset + 64 < data.length;\n  }\n  appendFrame(track, data, offset) {\n    const frameLength = appendFrame(track, data, offset, this.basePTS, this.frameIndex);\n    if (frameLength !== -1) {\n      const sample = track.samples[track.samples.length - 1];\n      return {\n        sample,\n        length: frameLength,\n        missing: 0\n      };\n    }\n  }\n  static probe(data) {\n    if (!data) {\n      return false;\n    }\n    const id3Data = getId3Data(data, 0);\n    if (!id3Data) {\n      return false;\n    }\n\n    // look for the ac-3 sync bytes\n    const offset = id3Data.length;\n    if (data[offset] === 0x0b && data[offset + 1] === 0x77 && getId3Timestamp(id3Data) !== undefined &&\n    // check the bsid to confirm ac-3\n    getAudioBSID(data, offset) < 16) {\n      return true;\n    }\n    return false;\n  }\n}\nfunction appendFrame(track, data, start, pts, frameIndex) {\n  if (start + 8 > data.length) {\n    return -1; // not enough bytes left\n  }\n  if (data[start] !== 0x0b || data[start + 1] !== 0x77) {\n    return -1; // invalid magic\n  }\n\n  // get sample rate\n  const samplingRateCode = data[start + 4] >> 6;\n  if (samplingRateCode >= 3) {\n    return -1; // invalid sampling rate\n  }\n  const samplingRateMap = [48000, 44100, 32000];\n  const sampleRate = samplingRateMap[samplingRateCode];\n\n  // get frame size\n  const frameSizeCode = data[start + 4] & 0x3f;\n  const frameSizeMap = [64, 69, 96, 64, 70, 96, 80, 87, 120, 80, 88, 120, 96, 104, 144, 96, 105, 144, 112, 121, 168, 112, 122, 168, 128, 139, 192, 128, 140, 192, 160, 174, 240, 160, 175, 240, 192, 208, 288, 192, 209, 288, 224, 243, 336, 224, 244, 336, 256, 278, 384, 256, 279, 384, 320, 348, 480, 320, 349, 480, 384, 417, 576, 384, 418, 576, 448, 487, 672, 448, 488, 672, 512, 557, 768, 512, 558, 768, 640, 696, 960, 640, 697, 960, 768, 835, 1152, 768, 836, 1152, 896, 975, 1344, 896, 976, 1344, 1024, 1114, 1536, 1024, 1115, 1536, 1152, 1253, 1728, 1152, 1254, 1728, 1280, 1393, 1920, 1280, 1394, 1920];\n  const frameLength = frameSizeMap[frameSizeCode * 3 + samplingRateCode] * 2;\n  if (start + frameLength > data.length) {\n    return -1;\n  }\n\n  // get channel count\n  const channelMode = data[start + 6] >> 5;\n  let skipCount = 0;\n  if (channelMode === 2) {\n    skipCount += 2;\n  } else {\n    if (channelMode & 1 && channelMode !== 1) {\n      skipCount += 2;\n    }\n    if (channelMode & 4) {\n      skipCount += 2;\n    }\n  }\n  const lfeon = (data[start + 6] << 8 | data[start + 7]) >> 12 - skipCount & 1;\n  const channelsMap = [2, 1, 2, 3, 3, 4, 4, 5];\n  const channelCount = channelsMap[channelMode] + lfeon;\n\n  // build dac3 box\n  const bsid = data[start + 5] >> 3;\n  const bsmod = data[start + 5] & 7;\n  const config = new Uint8Array([samplingRateCode << 6 | bsid << 1 | bsmod >> 2, (bsmod & 3) << 6 | channelMode << 3 | lfeon << 2 | frameSizeCode >> 4, frameSizeCode << 4 & 0xe0]);\n  const frameDuration = 1536 / sampleRate * 90000;\n  const stamp = pts + frameIndex * frameDuration;\n  const unit = data.subarray(start, start + frameLength);\n  track.config = config;\n  track.channelCount = channelCount;\n  track.samplerate = sampleRate;\n  track.samples.push({\n    unit,\n    pts: stamp\n  });\n  return frameLength;\n}\n\n/**\n * MP3 demuxer\n */\nclass MP3Demuxer extends BaseAudioDemuxer {\n  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);\n    this._audioTrack = {\n      container: 'audio/mpeg',\n      type: 'audio',\n      id: 2,\n      pid: -1,\n      sequenceNumber: 0,\n      segmentCodec: 'mp3',\n      samples: [],\n      manifestCodec: audioCodec,\n      duration: trackDuration,\n      inputTimeScale: 90000,\n      dropped: 0\n    };\n  }\n  static probe(data) {\n    if (!data) {\n      return false;\n    }\n\n    // check if data contains ID3 timestamp and MPEG sync word\n    // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1\n    // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)\n    // More info http://www.mp3-tech.org/programmer/frame_header.html\n    const id3Data = getId3Data(data, 0);\n    let offset = (id3Data == null ? void 0 : id3Data.length) || 0;\n\n    // Check for ac-3|ec-3 sync bytes and return false if present\n    if (id3Data && data[offset] === 0x0b && data[offset + 1] === 0x77 && getId3Timestamp(id3Data) !== undefined &&\n    // check the bsid to confirm ac-3 or ec-3 (not mp3)\n    getAudioBSID(data, offset) <= 16) {\n      return false;\n    }\n    for (let length = data.length; offset < length; offset++) {\n      if (probe(data, offset)) {\n        logger.log('MPEG Audio sync word found !');\n        return true;\n      }\n    }\n    return false;\n  }\n  canParse(data, offset) {\n    return canParse(data, offset);\n  }\n  appendFrame(track, data, offset) {\n    if (this.basePTS === null) {\n      return;\n    }\n    return appendFrame$1(track, data, offset, this.basePTS, this.frameIndex);\n  }\n}\n\nconst emsgSchemePattern = /\\/emsg[-/]ID3/i;\nclass MP4Demuxer {\n  constructor(observer, config) {\n    this.remainderData = null;\n    this.timeOffset = 0;\n    this.config = void 0;\n    this.videoTrack = void 0;\n    this.audioTrack = void 0;\n    this.id3Track = void 0;\n    this.txtTrack = void 0;\n    this.config = config;\n  }\n  resetTimeStamp() {}\n  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    const videoTrack = this.videoTrack = dummyTrack('video', 1);\n    const audioTrack = this.audioTrack = dummyTrack('audio', 1);\n    const captionTrack = this.txtTrack = dummyTrack('text', 1);\n    this.id3Track = dummyTrack('id3', 1);\n    this.timeOffset = 0;\n    if (!(initSegment != null && initSegment.byteLength)) {\n      return;\n    }\n    const initData = parseInitSegment(initSegment);\n    if (initData.video) {\n      const {\n        id,\n        timescale,\n        codec,\n        supplemental\n      } = initData.video;\n      videoTrack.id = id;\n      videoTrack.timescale = captionTrack.timescale = timescale;\n      videoTrack.codec = codec;\n      videoTrack.supplemental = supplemental;\n    }\n    if (initData.audio) {\n      const {\n        id,\n        timescale,\n        codec\n      } = initData.audio;\n      audioTrack.id = id;\n      audioTrack.timescale = timescale;\n      audioTrack.codec = codec;\n    }\n    captionTrack.id = RemuxerTrackIdConfig.text;\n    videoTrack.sampleDuration = 0;\n    videoTrack.duration = audioTrack.duration = trackDuration;\n  }\n  resetContiguity() {\n    this.remainderData = null;\n  }\n  static probe(data) {\n    return hasMoofData(data);\n  }\n  demux(data, timeOffset) {\n    this.timeOffset = timeOffset;\n    // Load all data into the avc track. The CMAF remuxer will look for the data in the samples object; the rest of the fields do not matter\n    let videoSamples = data;\n    const videoTrack = this.videoTrack;\n    const textTrack = this.txtTrack;\n    if (this.config.progressive) {\n      // Split the bytestream into two ranges: one encompassing all data up until the start of the last moof, and everything else.\n      // This is done to guarantee that we're sending valid data to MSE - when demuxing progressively, we have no guarantee\n      // that the fetch loader gives us flush moof+mdat pairs. If we push jagged data to MSE, it will throw an exception.\n      if (this.remainderData) {\n        videoSamples = appendUint8Array(this.remainderData, data);\n      }\n      const segmentedData = segmentValidRange(videoSamples);\n      this.remainderData = segmentedData.remainder;\n      videoTrack.samples = segmentedData.valid || new Uint8Array();\n    } else {\n      videoTrack.samples = videoSamples;\n    }\n    const id3Track = this.extractID3Track(videoTrack, timeOffset);\n    textTrack.samples = parseSamples(timeOffset, videoTrack);\n    return {\n      videoTrack,\n      audioTrack: this.audioTrack,\n      id3Track,\n      textTrack: this.txtTrack\n    };\n  }\n  flush() {\n    const timeOffset = this.timeOffset;\n    const videoTrack = this.videoTrack;\n    const textTrack = this.txtTrack;\n    videoTrack.samples = this.remainderData || new Uint8Array();\n    this.remainderData = null;\n    const id3Track = this.extractID3Track(videoTrack, this.timeOffset);\n    textTrack.samples = parseSamples(timeOffset, videoTrack);\n    return {\n      videoTrack,\n      audioTrack: dummyTrack(),\n      id3Track,\n      textTrack: dummyTrack()\n    };\n  }\n  extractID3Track(videoTrack, timeOffset) {\n    const id3Track = this.id3Track;\n    if (videoTrack.samples.length) {\n      const emsgs = findBox(videoTrack.samples, ['emsg']);\n      if (emsgs) {\n        emsgs.forEach(data => {\n          const emsgInfo = parseEmsg(data);\n          if (emsgSchemePattern.test(emsgInfo.schemeIdUri)) {\n            const pts = getEmsgStartTime(emsgInfo, timeOffset);\n            let duration = emsgInfo.eventDuration === 0xffffffff ? Number.POSITIVE_INFINITY : emsgInfo.eventDuration / emsgInfo.timeScale;\n            // Safari takes anything <= 0.001 seconds and maps it to Infinity\n            if (duration <= 0.001) {\n              duration = Number.POSITIVE_INFINITY;\n            }\n            const payload = emsgInfo.payload;\n            id3Track.samples.push({\n              data: payload,\n              len: payload.byteLength,\n              dts: pts,\n              pts: pts,\n              type: MetadataSchema.emsg,\n              duration: duration\n            });\n          } else if (this.config.enableEmsgKLVMetadata && emsgInfo.schemeIdUri.startsWith('urn:misb:KLV:bin:1910.1')) {\n            const pts = getEmsgStartTime(emsgInfo, timeOffset);\n            id3Track.samples.push({\n              data: emsgInfo.payload,\n              len: emsgInfo.payload.byteLength,\n              dts: pts,\n              pts: pts,\n              type: MetadataSchema.misbklv,\n              duration: Number.POSITIVE_INFINITY\n            });\n          }\n        });\n      }\n    }\n    return id3Track;\n  }\n  demuxSampleAes(data, keyData, timeOffset) {\n    return Promise.reject(new Error('The MP4 demuxer does not support SAMPLE-AES decryption'));\n  }\n  destroy() {\n    // @ts-ignore\n    this.config = null;\n    this.remainderData = null;\n    this.videoTrack = this.audioTrack = this.id3Track = this.txtTrack = undefined;\n  }\n}\nfunction getEmsgStartTime(emsgInfo, timeOffset) {\n  return isFiniteNumber(emsgInfo.presentationTime) ? emsgInfo.presentationTime / emsgInfo.timeScale : timeOffset + emsgInfo.presentationTimeDelta / emsgInfo.timeScale;\n}\n\n/**\n * SAMPLE-AES decrypter\n */\n\nclass SampleAesDecrypter {\n  constructor(observer, config, keyData) {\n    this.keyData = void 0;\n    this.decrypter = void 0;\n    this.keyData = keyData;\n    this.decrypter = new Decrypter(config, {\n      removePKCS7Padding: false\n    });\n  }\n  decryptBuffer(encryptedData) {\n    return this.decrypter.decrypt(encryptedData, this.keyData.key.buffer, this.keyData.iv.buffer, DecrypterAesMode.cbc);\n  }\n\n  // AAC - encrypt all full 16 bytes blocks starting from offset 16\n  decryptAacSample(samples, sampleIndex, callback) {\n    const curUnit = samples[sampleIndex].unit;\n    if (curUnit.length <= 16) {\n      // No encrypted portion in this sample (first 16 bytes is not\n      // encrypted, see https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/HLS_Sample_Encryption/Encryption/Encryption.html),\n      return;\n    }\n    const encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);\n    const encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);\n    this.decryptBuffer(encryptedBuffer).then(decryptedBuffer => {\n      const decryptedData = new Uint8Array(decryptedBuffer);\n      curUnit.set(decryptedData, 16);\n      if (!this.decrypter.isSync()) {\n        this.decryptAacSamples(samples, sampleIndex + 1, callback);\n      }\n    });\n  }\n  decryptAacSamples(samples, sampleIndex, callback) {\n    for (;; sampleIndex++) {\n      if (sampleIndex >= samples.length) {\n        callback();\n        return;\n      }\n      if (samples[sampleIndex].unit.length < 32) {\n        continue;\n      }\n      this.decryptAacSample(samples, sampleIndex, callback);\n      if (!this.decrypter.isSync()) {\n        return;\n      }\n    }\n  }\n\n  // AVC - encrypt one 16 bytes block out of ten, starting from offset 32\n  getAvcEncryptedData(decodedData) {\n    const encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;\n    const encryptedData = new Int8Array(encryptedDataLen);\n    let outputPos = 0;\n    for (let inputPos = 32; inputPos < decodedData.length - 16; inputPos += 160, outputPos += 16) {\n      encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);\n    }\n    return encryptedData;\n  }\n  getAvcDecryptedUnit(decodedData, decryptedData) {\n    const uint8DecryptedData = new Uint8Array(decryptedData);\n    let inputPos = 0;\n    for (let outputPos = 32; outputPos < decodedData.length - 16; outputPos += 160, inputPos += 16) {\n      decodedData.set(uint8DecryptedData.subarray(inputPos, inputPos + 16), outputPos);\n    }\n    return decodedData;\n  }\n  decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit) {\n    const decodedData = discardEPB(curUnit.data);\n    const encryptedData = this.getAvcEncryptedData(decodedData);\n    this.decryptBuffer(encryptedData.buffer).then(decryptedBuffer => {\n      curUnit.data = this.getAvcDecryptedUnit(decodedData, decryptedBuffer);\n      if (!this.decrypter.isSync()) {\n        this.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);\n      }\n    });\n  }\n  decryptAvcSamples(samples, sampleIndex, unitIndex, callback) {\n    if (samples instanceof Uint8Array) {\n      throw new Error('Cannot decrypt samples of type Uint8Array');\n    }\n    for (;; sampleIndex++, unitIndex = 0) {\n      if (sampleIndex >= samples.length) {\n        callback();\n        return;\n      }\n      const curUnits = samples[sampleIndex].units;\n      for (;; unitIndex++) {\n        if (unitIndex >= curUnits.length) {\n          break;\n        }\n        const curUnit = curUnits[unitIndex];\n        if (curUnit.data.length <= 48 || curUnit.type !== 1 && curUnit.type !== 5) {\n          continue;\n        }\n        this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit);\n        if (!this.decrypter.isSync()) {\n          return;\n        }\n      }\n    }\n  }\n}\n\nclass BaseVideoParser {\n  constructor() {\n    this.VideoSample = null;\n  }\n  createVideoSample(key, pts, dts) {\n    return {\n      key,\n      frame: false,\n      pts,\n      dts,\n      units: [],\n      length: 0\n    };\n  }\n  getLastNalUnit(samples) {\n    var _VideoSample;\n    let VideoSample = this.VideoSample;\n    let lastUnit;\n    // try to fallback to previous sample if current one is empty\n    if (!VideoSample || VideoSample.units.length === 0) {\n      VideoSample = samples[samples.length - 1];\n    }\n    if ((_VideoSample = VideoSample) != null && _VideoSample.units) {\n      const units = VideoSample.units;\n      lastUnit = units[units.length - 1];\n    }\n    return lastUnit;\n  }\n  pushAccessUnit(VideoSample, videoTrack) {\n    if (VideoSample.units.length && VideoSample.frame) {\n      // if sample does not have PTS/DTS, patch with last sample PTS/DTS\n      if (VideoSample.pts === undefined) {\n        const samples = videoTrack.samples;\n        const nbSamples = samples.length;\n        if (nbSamples) {\n          const lastSample = samples[nbSamples - 1];\n          VideoSample.pts = lastSample.pts;\n          VideoSample.dts = lastSample.dts;\n        } else {\n          // dropping samples, no timestamp found\n          videoTrack.dropped++;\n          return;\n        }\n      }\n      videoTrack.samples.push(VideoSample);\n    }\n  }\n  parseNALu(track, array, endOfSegment) {\n    const len = array.byteLength;\n    let state = track.naluState || 0;\n    const lastState = state;\n    const units = [];\n    let i = 0;\n    let value;\n    let overflow;\n    let unitType;\n    let lastUnitStart = -1;\n    let lastUnitType = 0;\n    // logger.log('PES:' + Hex.hexDump(array));\n\n    if (state === -1) {\n      // special use case where we found 3 or 4-byte start codes exactly at the end of previous PES packet\n      lastUnitStart = 0;\n      // NALu type is value read from offset 0\n      lastUnitType = this.getNALuType(array, 0);\n      state = 0;\n      i = 1;\n    }\n    while (i < len) {\n      value = array[i++];\n      // optimization. state 0 and 1 are the predominant case. let's handle them outside of the switch/case\n      if (!state) {\n        state = value ? 0 : 1;\n        continue;\n      }\n      if (state === 1) {\n        state = value ? 0 : 2;\n        continue;\n      }\n      // here we have state either equal to 2 or 3\n      if (!value) {\n        state = 3;\n      } else if (value === 1) {\n        overflow = i - state - 1;\n        if (lastUnitStart >= 0) {\n          const unit = {\n            data: array.subarray(lastUnitStart, overflow),\n            type: lastUnitType\n          };\n          // logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);\n          units.push(unit);\n        } else {\n          // lastUnitStart is undefined => this is the first start code found in this PES packet\n          // first check if start code delimiter is overlapping between 2 PES packets,\n          // ie it started in last packet (lastState not zero)\n          // and ended at the beginning of this PES packet (i <= 4 - lastState)\n          const lastUnit = this.getLastNalUnit(track.samples);\n          if (lastUnit) {\n            if (lastState && i <= 4 - lastState) {\n              // start delimiter overlapping between PES packets\n              // strip start delimiter bytes from the end of last NAL unit\n              // check if lastUnit had a state different from zero\n              if (lastUnit.state) {\n                // strip last bytes\n                lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);\n              }\n            }\n            // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.\n\n            if (overflow > 0) {\n              // logger.log('first NALU found with overflow:' + overflow);\n              lastUnit.data = appendUint8Array(lastUnit.data, array.subarray(0, overflow));\n              lastUnit.state = 0;\n            }\n          }\n        }\n        // check if we can read unit type\n        if (i < len) {\n          unitType = this.getNALuType(array, i);\n          // logger.log('find NALU @ offset:' + i + ',type:' + unitType);\n          lastUnitStart = i;\n          lastUnitType = unitType;\n          state = 0;\n        } else {\n          // not enough byte to read unit type. let's read it on next PES parsing\n          state = -1;\n        }\n      } else {\n        state = 0;\n      }\n    }\n    if (lastUnitStart >= 0 && state >= 0) {\n      const unit = {\n        data: array.subarray(lastUnitStart, len),\n        type: lastUnitType,\n        state: state\n      };\n      units.push(unit);\n      // logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);\n    }\n    // no NALu found\n    if (units.length === 0) {\n      // append pes.data to previous NAL unit\n      const lastUnit = this.getLastNalUnit(track.samples);\n      if (lastUnit) {\n        lastUnit.data = appendUint8Array(lastUnit.data, array);\n      }\n    }\n    track.naluState = state;\n    return units;\n  }\n}\n\n/**\n * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.\n */\n\nclass ExpGolomb {\n  constructor(data) {\n    this.data = void 0;\n    this.bytesAvailable = void 0;\n    this.word = void 0;\n    this.bitsAvailable = void 0;\n    this.data = data;\n    // the number of bytes left to examine in this.data\n    this.bytesAvailable = data.byteLength;\n    // the current word being examined\n    this.word = 0; // :uint\n    // the number of bits left to examine in the current word\n    this.bitsAvailable = 0; // :uint\n  }\n\n  // ():void\n  loadWord() {\n    const data = this.data;\n    const bytesAvailable = this.bytesAvailable;\n    const position = data.byteLength - bytesAvailable;\n    const workingBytes = new Uint8Array(4);\n    const availableBytes = Math.min(4, bytesAvailable);\n    if (availableBytes === 0) {\n      throw new Error('no bytes available');\n    }\n    workingBytes.set(data.subarray(position, position + availableBytes));\n    this.word = new DataView(workingBytes.buffer).getUint32(0);\n    // track the amount of this.data that has been processed\n    this.bitsAvailable = availableBytes * 8;\n    this.bytesAvailable -= availableBytes;\n  }\n\n  // (count:int):void\n  skipBits(count) {\n    let skipBytes; // :int\n    count = Math.min(count, this.bytesAvailable * 8 + this.bitsAvailable);\n    if (this.bitsAvailable > count) {\n      this.word <<= count;\n      this.bitsAvailable -= count;\n    } else {\n      count -= this.bitsAvailable;\n      skipBytes = count >> 3;\n      count -= skipBytes << 3;\n      this.bytesAvailable -= skipBytes;\n      this.loadWord();\n      this.word <<= count;\n      this.bitsAvailable -= count;\n    }\n  }\n\n  // (size:int):uint\n  readBits(size) {\n    let bits = Math.min(this.bitsAvailable, size); // :uint\n    const valu = this.word >>> 32 - bits; // :uint\n    if (size > 32) {\n      logger.error('Cannot read more than 32 bits at a time');\n    }\n    this.bitsAvailable -= bits;\n    if (this.bitsAvailable > 0) {\n      this.word <<= bits;\n    } else if (this.bytesAvailable > 0) {\n      this.loadWord();\n    } else {\n      throw new Error('no bits available');\n    }\n    bits = size - bits;\n    if (bits > 0 && this.bitsAvailable) {\n      return valu << bits | this.readBits(bits);\n    } else {\n      return valu;\n    }\n  }\n\n  // ():uint\n  skipLZ() {\n    let leadingZeroCount; // :uint\n    for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {\n      if ((this.word & 0x80000000 >>> leadingZeroCount) !== 0) {\n        // the first bit of working word is 1\n        this.word <<= leadingZeroCount;\n        this.bitsAvailable -= leadingZeroCount;\n        return leadingZeroCount;\n      }\n    }\n    // we exhausted word and still have not found a 1\n    this.loadWord();\n    return leadingZeroCount + this.skipLZ();\n  }\n\n  // ():void\n  skipUEG() {\n    this.skipBits(1 + this.skipLZ());\n  }\n\n  // ():void\n  skipEG() {\n    this.skipBits(1 + this.skipLZ());\n  }\n\n  // ():uint\n  readUEG() {\n    const clz = this.skipLZ(); // :uint\n    return this.readBits(clz + 1) - 1;\n  }\n\n  // ():int\n  readEG() {\n    const valu = this.readUEG(); // :int\n    if (0x01 & valu) {\n      // the number is odd if the low order bit is set\n      return 1 + valu >>> 1; // add 1 to make it even, and divide by 2\n    } else {\n      return -1 * (valu >>> 1); // divide by two then make it negative\n    }\n  }\n\n  // Some convenience functions\n  // :Boolean\n  readBoolean() {\n    return this.readBits(1) === 1;\n  }\n\n  // ():int\n  readUByte() {\n    return this.readBits(8);\n  }\n\n  // ():int\n  readUShort() {\n    return this.readBits(16);\n  }\n\n  // ():int\n  readUInt() {\n    return this.readBits(32);\n  }\n}\n\nclass AvcVideoParser extends BaseVideoParser {\n  parsePES(track, textTrack, pes, endOfSegment) {\n    const units = this.parseNALu(track, pes.data, endOfSegment);\n    let VideoSample = this.VideoSample;\n    let push;\n    let spsfound = false;\n    // free pes.data to save up some memory\n    pes.data = null;\n\n    // if new NAL units found and last sample still there, let's push ...\n    // this helps parsing streams with missing AUD (only do this if AUD never found)\n    if (VideoSample && units.length && !track.audFound) {\n      this.pushAccessUnit(VideoSample, track);\n      VideoSample = this.VideoSample = this.createVideoSample(false, pes.pts, pes.dts);\n    }\n    units.forEach(unit => {\n      var _VideoSample2, _VideoSample3;\n      switch (unit.type) {\n        // NDR\n        case 1:\n          {\n            let iskey = false;\n            push = true;\n            const data = unit.data;\n            // only check slice type to detect KF in case SPS found in same packet (any keyframe is preceded by SPS ...)\n            if (spsfound && data.length > 4) {\n              // retrieve slice type by parsing beginning of NAL unit (follow H264 spec, slice_header definition) to detect keyframe embedded in NDR\n              const sliceType = this.readSliceType(data);\n              // 2 : I slice, 4 : SI slice, 7 : I slice, 9: SI slice\n              // SI slice : A slice that is coded using intra prediction only and using quantisation of the prediction samples.\n              // An SI slice can be coded such that its decoded samples can be constructed identically to an SP slice.\n              // I slice: A slice that is not an SI slice that is decoded using intra prediction only.\n              // if (sliceType === 2 || sliceType === 7) {\n              if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {\n                iskey = true;\n              }\n            }\n            if (iskey) {\n              var _VideoSample;\n              // if we have non-keyframe data already, that cannot belong to the same frame as a keyframe, so force a push\n              if ((_VideoSample = VideoSample) != null && _VideoSample.frame && !VideoSample.key) {\n                this.pushAccessUnit(VideoSample, track);\n                VideoSample = this.VideoSample = null;\n              }\n            }\n            if (!VideoSample) {\n              VideoSample = this.VideoSample = this.createVideoSample(true, pes.pts, pes.dts);\n            }\n            VideoSample.frame = true;\n            VideoSample.key = iskey;\n            break;\n            // IDR\n          }\n        case 5:\n          push = true;\n          // handle PES not starting with AUD\n          // if we have frame data already, that cannot belong to the same frame, so force a push\n          if ((_VideoSample2 = VideoSample) != null && _VideoSample2.frame && !VideoSample.key) {\n            this.pushAccessUnit(VideoSample, track);\n            VideoSample = this.VideoSample = null;\n          }\n          if (!VideoSample) {\n            VideoSample = this.VideoSample = this.createVideoSample(true, pes.pts, pes.dts);\n          }\n          VideoSample.key = true;\n          VideoSample.frame = true;\n          break;\n        // SEI\n        case 6:\n          {\n            push = true;\n            parseSEIMessageFromNALu(unit.data, 1, pes.pts, textTrack.samples);\n            break;\n            // SPS\n          }\n        case 7:\n          {\n            var _track$pixelRatio, _track$pixelRatio2;\n            push = true;\n            spsfound = true;\n            const sps = unit.data;\n            const config = this.readSPS(sps);\n            if (!track.sps || track.width !== config.width || track.height !== config.height || ((_track$pixelRatio = track.pixelRatio) == null ? void 0 : _track$pixelRatio[0]) !== config.pixelRatio[0] || ((_track$pixelRatio2 = track.pixelRatio) == null ? void 0 : _track$pixelRatio2[1]) !== config.pixelRatio[1]) {\n              track.width = config.width;\n              track.height = config.height;\n              track.pixelRatio = config.pixelRatio;\n              track.sps = [sps];\n              const codecarray = sps.subarray(1, 4);\n              let codecstring = 'avc1.';\n              for (let i = 0; i < 3; i++) {\n                let h = codecarray[i].toString(16);\n                if (h.length < 2) {\n                  h = '0' + h;\n                }\n                codecstring += h;\n              }\n              track.codec = codecstring;\n            }\n            break;\n          }\n        // PPS\n        case 8:\n          push = true;\n          track.pps = [unit.data];\n          break;\n        // AUD\n        case 9:\n          push = true;\n          track.audFound = true;\n          if ((_VideoSample3 = VideoSample) != null && _VideoSample3.frame) {\n            this.pushAccessUnit(VideoSample, track);\n            VideoSample = null;\n          }\n          if (!VideoSample) {\n            VideoSample = this.VideoSample = this.createVideoSample(false, pes.pts, pes.dts);\n          }\n          break;\n        // Filler Data\n        case 12:\n          push = true;\n          break;\n        default:\n          push = false;\n          break;\n      }\n      if (VideoSample && push) {\n        const units = VideoSample.units;\n        units.push(unit);\n      }\n    });\n    // if last PES packet, push samples\n    if (endOfSegment && VideoSample) {\n      this.pushAccessUnit(VideoSample, track);\n      this.VideoSample = null;\n    }\n  }\n  getNALuType(data, offset) {\n    return data[offset] & 0x1f;\n  }\n  readSliceType(data) {\n    const eg = new ExpGolomb(data);\n    // skip NALu type\n    eg.readUByte();\n    // discard first_mb_in_slice\n    eg.readUEG();\n    // return slice_type\n    return eg.readUEG();\n  }\n\n  /**\n   * The scaling list is optionally transmitted as part of a sequence parameter\n   * set and is not relevant to transmuxing.\n   * @param count the number of entries in this scaling list\n   * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1\n   */\n  skipScalingList(count, reader) {\n    let lastScale = 8;\n    let nextScale = 8;\n    let deltaScale;\n    for (let j = 0; j < count; j++) {\n      if (nextScale !== 0) {\n        deltaScale = reader.readEG();\n        nextScale = (lastScale + deltaScale + 256) % 256;\n      }\n      lastScale = nextScale === 0 ? lastScale : nextScale;\n    }\n  }\n\n  /**\n   * Read a sequence parameter set and return some interesting video\n   * properties. A sequence parameter set is the H264 metadata that\n   * describes the properties of upcoming video frames.\n   * @returns an object with configuration parsed from the\n   * sequence parameter set, including the dimensions of the\n   * associated video frames.\n   */\n  readSPS(sps) {\n    const eg = new ExpGolomb(sps);\n    let frameCropLeftOffset = 0;\n    let frameCropRightOffset = 0;\n    let frameCropTopOffset = 0;\n    let frameCropBottomOffset = 0;\n    let numRefFramesInPicOrderCntCycle;\n    let scalingListCount;\n    let i;\n    const readUByte = eg.readUByte.bind(eg);\n    const readBits = eg.readBits.bind(eg);\n    const readUEG = eg.readUEG.bind(eg);\n    const readBoolean = eg.readBoolean.bind(eg);\n    const skipBits = eg.skipBits.bind(eg);\n    const skipEG = eg.skipEG.bind(eg);\n    const skipUEG = eg.skipUEG.bind(eg);\n    const skipScalingList = this.skipScalingList.bind(this);\n    readUByte();\n    const profileIdc = readUByte(); // profile_idc\n    readBits(5); // profileCompat constraint_set[0-4]_flag, u(5)\n    skipBits(3); // reserved_zero_3bits u(3),\n    readUByte(); // level_idc u(8)\n    skipUEG(); // seq_parameter_set_id\n    // some profiles have more optional data we don't need\n    if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {\n      const chromaFormatIdc = readUEG();\n      if (chromaFormatIdc === 3) {\n        skipBits(1);\n      } // separate_colour_plane_flag\n\n      skipUEG(); // bit_depth_luma_minus8\n      skipUEG(); // bit_depth_chroma_minus8\n      skipBits(1); // qpprime_y_zero_transform_bypass_flag\n      if (readBoolean()) {\n        // seq_scaling_matrix_present_flag\n        scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;\n        for (i = 0; i < scalingListCount; i++) {\n          if (readBoolean()) {\n            // seq_scaling_list_present_flag[ i ]\n            if (i < 6) {\n              skipScalingList(16, eg);\n            } else {\n              skipScalingList(64, eg);\n            }\n          }\n        }\n      }\n    }\n    skipUEG(); // log2_max_frame_num_minus4\n    const picOrderCntType = readUEG();\n    if (picOrderCntType === 0) {\n      readUEG(); // log2_max_pic_order_cnt_lsb_minus4\n    } else if (picOrderCntType === 1) {\n      skipBits(1); // delta_pic_order_always_zero_flag\n      skipEG(); // offset_for_non_ref_pic\n      skipEG(); // offset_for_top_to_bottom_field\n      numRefFramesInPicOrderCntCycle = readUEG();\n      for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\n        skipEG();\n      } // offset_for_ref_frame[ i ]\n    }\n    skipUEG(); // max_num_ref_frames\n    skipBits(1); // gaps_in_frame_num_value_allowed_flag\n    const picWidthInMbsMinus1 = readUEG();\n    const picHeightInMapUnitsMinus1 = readUEG();\n    const frameMbsOnlyFlag = readBits(1);\n    if (frameMbsOnlyFlag === 0) {\n      skipBits(1);\n    } // mb_adaptive_frame_field_flag\n\n    skipBits(1); // direct_8x8_inference_flag\n    if (readBoolean()) {\n      // frame_cropping_flag\n      frameCropLeftOffset = readUEG();\n      frameCropRightOffset = readUEG();\n      frameCropTopOffset = readUEG();\n      frameCropBottomOffset = readUEG();\n    }\n    let pixelRatio = [1, 1];\n    if (readBoolean()) {\n      // vui_parameters_present_flag\n      if (readBoolean()) {\n        // aspect_ratio_info_present_flag\n        const aspectRatioIdc = readUByte();\n        switch (aspectRatioIdc) {\n          case 1:\n            pixelRatio = [1, 1];\n            break;\n          case 2:\n            pixelRatio = [12, 11];\n            break;\n          case 3:\n            pixelRatio = [10, 11];\n            break;\n          case 4:\n            pixelRatio = [16, 11];\n            break;\n          case 5:\n            pixelRatio = [40, 33];\n            break;\n          case 6:\n            pixelRatio = [24, 11];\n            break;\n          case 7:\n            pixelRatio = [20, 11];\n            break;\n          case 8:\n            pixelRatio = [32, 11];\n            break;\n          case 9:\n            pixelRatio = [80, 33];\n            break;\n          case 10:\n            pixelRatio = [18, 11];\n            break;\n          case 11:\n            pixelRatio = [15, 11];\n            break;\n          case 12:\n            pixelRatio = [64, 33];\n            break;\n          case 13:\n            pixelRatio = [160, 99];\n            break;\n          case 14:\n            pixelRatio = [4, 3];\n            break;\n          case 15:\n            pixelRatio = [3, 2];\n            break;\n          case 16:\n            pixelRatio = [2, 1];\n            break;\n          case 255:\n            {\n              pixelRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];\n              break;\n            }\n        }\n      }\n    }\n    return {\n      width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2),\n      height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),\n      pixelRatio: pixelRatio\n    };\n  }\n}\n\nclass HevcVideoParser extends BaseVideoParser {\n  constructor(...args) {\n    super(...args);\n    this.initVPS = null;\n  }\n  parsePES(track, textTrack, pes, endOfSegment) {\n    const units = this.parseNALu(track, pes.data, endOfSegment);\n    let VideoSample = this.VideoSample;\n    let push;\n    let spsfound = false;\n    // free pes.data to save up some memory\n    pes.data = null;\n\n    // if new NAL units found and last sample still there, let's push ...\n    // this helps parsing streams with missing AUD (only do this if AUD never found)\n    if (VideoSample && units.length && !track.audFound) {\n      this.pushAccessUnit(VideoSample, track);\n      VideoSample = this.VideoSample = this.createVideoSample(false, pes.pts, pes.dts);\n    }\n    units.forEach(unit => {\n      var _VideoSample2, _VideoSample3;\n      switch (unit.type) {\n        // NON-IDR, NON RANDOM ACCESS SLICE\n        case 0:\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n          if (!VideoSample) {\n            VideoSample = this.VideoSample = this.createVideoSample(false, pes.pts, pes.dts);\n          }\n          VideoSample.frame = true;\n          push = true;\n          break;\n\n        // CRA, BLA (random access picture)\n        case 16:\n        case 17:\n        case 18:\n        case 21:\n          push = true;\n          if (spsfound) {\n            var _VideoSample;\n            // handle PES not starting with AUD\n            // if we have frame data already, that cannot belong to the same frame, so force a push\n            if ((_VideoSample = VideoSample) != null && _VideoSample.frame && !VideoSample.key) {\n              this.pushAccessUnit(VideoSample, track);\n              VideoSample = this.VideoSample = null;\n            }\n          }\n          if (!VideoSample) {\n            VideoSample = this.VideoSample = this.createVideoSample(true, pes.pts, pes.dts);\n          }\n          VideoSample.key = true;\n          VideoSample.frame = true;\n          break;\n\n        // IDR\n        case 19:\n        case 20:\n          push = true;\n          // handle PES not starting with AUD\n          // if we have frame data already, that cannot belong to the same frame, so force a push\n          if ((_VideoSample2 = VideoSample) != null && _VideoSample2.frame && !VideoSample.key) {\n            this.pushAccessUnit(VideoSample, track);\n            VideoSample = this.VideoSample = null;\n          }\n          if (!VideoSample) {\n            VideoSample = this.VideoSample = this.createVideoSample(true, pes.pts, pes.dts);\n          }\n          VideoSample.key = true;\n          VideoSample.frame = true;\n          break;\n\n        // SEI\n        case 39:\n          push = true;\n          parseSEIMessageFromNALu(unit.data, 2,\n          // NALu header size\n          pes.pts, textTrack.samples);\n          break;\n\n        // VPS\n        case 32:\n          push = true;\n          if (!track.vps) {\n            if (typeof track.params !== 'object') {\n              track.params = {};\n            }\n            track.params = _extends(track.params, this.readVPS(unit.data));\n            this.initVPS = unit.data;\n          }\n          track.vps = [unit.data];\n          break;\n\n        // SPS\n        case 33:\n          push = true;\n          spsfound = true;\n          if (track.vps !== undefined && track.vps[0] !== this.initVPS && track.sps !== undefined && !this.matchSPS(track.sps[0], unit.data)) {\n            this.initVPS = track.vps[0];\n            track.sps = track.pps = undefined;\n          }\n          if (!track.sps) {\n            const config = this.readSPS(unit.data);\n            track.width = config.width;\n            track.height = config.height;\n            track.pixelRatio = config.pixelRatio;\n            track.codec = config.codecString;\n            track.sps = [];\n            if (typeof track.params !== 'object') {\n              track.params = {};\n            }\n            for (const prop in config.params) {\n              track.params[prop] = config.params[prop];\n            }\n          }\n          this.pushParameterSet(track.sps, unit.data, track.vps);\n          if (!VideoSample) {\n            VideoSample = this.VideoSample = this.createVideoSample(true, pes.pts, pes.dts);\n          }\n          VideoSample.key = true;\n          break;\n\n        // PPS\n        case 34:\n          push = true;\n          if (typeof track.params === 'object') {\n            if (!track.pps) {\n              track.pps = [];\n              const config = this.readPPS(unit.data);\n              for (const prop in config) {\n                track.params[prop] = config[prop];\n              }\n            }\n            this.pushParameterSet(track.pps, unit.data, track.vps);\n          }\n          break;\n\n        // ACCESS UNIT DELIMITER\n        case 35:\n          push = true;\n          track.audFound = true;\n          if ((_VideoSample3 = VideoSample) != null && _VideoSample3.frame) {\n            this.pushAccessUnit(VideoSample, track);\n            VideoSample = null;\n          }\n          if (!VideoSample) {\n            VideoSample = this.VideoSample = this.createVideoSample(false, pes.pts, pes.dts);\n          }\n          break;\n        default:\n          push = false;\n          break;\n      }\n      if (VideoSample && push) {\n        const units = VideoSample.units;\n        units.push(unit);\n      }\n    });\n    // if last PES packet, push samples\n    if (endOfSegment && VideoSample) {\n      this.pushAccessUnit(VideoSample, track);\n      this.VideoSample = null;\n    }\n  }\n  pushParameterSet(parameterSets, data, vps) {\n    if (vps && vps[0] === this.initVPS || !vps && !parameterSets.length) {\n      parameterSets.push(data);\n    }\n  }\n  getNALuType(data, offset) {\n    return (data[offset] & 0x7e) >>> 1;\n  }\n  ebsp2rbsp(arr) {\n    const dst = new Uint8Array(arr.byteLength);\n    let dstIdx = 0;\n    for (let i = 0; i < arr.byteLength; i++) {\n      if (i >= 2) {\n        // Unescape: Skip 0x03 after 00 00\n        if (arr[i] === 0x03 && arr[i - 1] === 0x00 && arr[i - 2] === 0x00) {\n          continue;\n        }\n      }\n      dst[dstIdx] = arr[i];\n      dstIdx++;\n    }\n    return new Uint8Array(dst.buffer, 0, dstIdx);\n  }\n  pushAccessUnit(VideoSample, videoTrack) {\n    super.pushAccessUnit(VideoSample, videoTrack);\n    if (this.initVPS) {\n      this.initVPS = null; // null initVPS to prevent possible track's sps/pps growth until next VPS\n    }\n  }\n  readVPS(vps) {\n    const eg = new ExpGolomb(vps);\n    // remove header\n    eg.readUByte();\n    eg.readUByte();\n    eg.readBits(4); // video_parameter_set_id\n    eg.skipBits(2);\n    eg.readBits(6); // max_layers_minus1\n    const max_sub_layers_minus1 = eg.readBits(3);\n    const temporal_id_nesting_flag = eg.readBoolean();\n    // ...vui fps can be here, but empty fps value is not critical for metadata\n\n    return {\n      numTemporalLayers: max_sub_layers_minus1 + 1,\n      temporalIdNested: temporal_id_nesting_flag\n    };\n  }\n  readSPS(sps) {\n    const eg = new ExpGolomb(this.ebsp2rbsp(sps));\n    eg.readUByte();\n    eg.readUByte();\n    eg.readBits(4); //video_parameter_set_id\n    const max_sub_layers_minus1 = eg.readBits(3);\n    eg.readBoolean(); // temporal_id_nesting_flag\n\n    // profile_tier_level\n    const general_profile_space = eg.readBits(2);\n    const general_tier_flag = eg.readBoolean();\n    const general_profile_idc = eg.readBits(5);\n    const general_profile_compatibility_flags_1 = eg.readUByte();\n    const general_profile_compatibility_flags_2 = eg.readUByte();\n    const general_profile_compatibility_flags_3 = eg.readUByte();\n    const general_profile_compatibility_flags_4 = eg.readUByte();\n    const general_constraint_indicator_flags_1 = eg.readUByte();\n    const general_constraint_indicator_flags_2 = eg.readUByte();\n    const general_constraint_indicator_flags_3 = eg.readUByte();\n    const general_constraint_indicator_flags_4 = eg.readUByte();\n    const general_constraint_indicator_flags_5 = eg.readUByte();\n    const general_constraint_indicator_flags_6 = eg.readUByte();\n    const general_level_idc = eg.readUByte();\n    const sub_layer_profile_present_flags = [];\n    const sub_layer_level_present_flags = [];\n    for (let i = 0; i < max_sub_layers_minus1; i++) {\n      sub_layer_profile_present_flags.push(eg.readBoolean());\n      sub_layer_level_present_flags.push(eg.readBoolean());\n    }\n    if (max_sub_layers_minus1 > 0) {\n      for (let i = max_sub_layers_minus1; i < 8; i++) {\n        eg.readBits(2);\n      }\n    }\n    for (let i = 0; i < max_sub_layers_minus1; i++) {\n      if (sub_layer_profile_present_flags[i]) {\n        eg.readUByte(); // sub_layer_profile_space, sub_layer_tier_flag, sub_layer_profile_idc\n        eg.readUByte();\n        eg.readUByte();\n        eg.readUByte();\n        eg.readUByte(); // sub_layer_profile_compatibility_flag\n        eg.readUByte();\n        eg.readUByte();\n        eg.readUByte();\n        eg.readUByte();\n        eg.readUByte();\n        eg.readUByte();\n      }\n      if (sub_layer_level_present_flags[i]) {\n        eg.readUByte();\n      }\n    }\n    eg.readUEG(); // seq_parameter_set_id\n    const chroma_format_idc = eg.readUEG();\n    if (chroma_format_idc == 3) {\n      eg.skipBits(1); //separate_colour_plane_flag\n    }\n    const pic_width_in_luma_samples = eg.readUEG();\n    const pic_height_in_luma_samples = eg.readUEG();\n    const conformance_window_flag = eg.readBoolean();\n    let pic_left_offset = 0,\n      pic_right_offset = 0,\n      pic_top_offset = 0,\n      pic_bottom_offset = 0;\n    if (conformance_window_flag) {\n      pic_left_offset += eg.readUEG();\n      pic_right_offset += eg.readUEG();\n      pic_top_offset += eg.readUEG();\n      pic_bottom_offset += eg.readUEG();\n    }\n    const bit_depth_luma_minus8 = eg.readUEG();\n    const bit_depth_chroma_minus8 = eg.readUEG();\n    const log2_max_pic_order_cnt_lsb_minus4 = eg.readUEG();\n    const sub_layer_ordering_info_present_flag = eg.readBoolean();\n    for (let i = sub_layer_ordering_info_present_flag ? 0 : max_sub_layers_minus1; i <= max_sub_layers_minus1; i++) {\n      eg.skipUEG(); // max_dec_pic_buffering_minus1[i]\n      eg.skipUEG(); // max_num_reorder_pics[i]\n      eg.skipUEG(); // max_latency_increase_plus1[i]\n    }\n    eg.skipUEG(); // log2_min_luma_coding_block_size_minus3\n    eg.skipUEG(); // log2_diff_max_min_luma_coding_block_size\n    eg.skipUEG(); // log2_min_transform_block_size_minus2\n    eg.skipUEG(); // log2_diff_max_min_transform_block_size\n    eg.skipUEG(); // max_transform_hierarchy_depth_inter\n    eg.skipUEG(); // max_transform_hierarchy_depth_intra\n    const scaling_list_enabled_flag = eg.readBoolean();\n    if (scaling_list_enabled_flag) {\n      const sps_scaling_list_data_present_flag = eg.readBoolean();\n      if (sps_scaling_list_data_present_flag) {\n        for (let sizeId = 0; sizeId < 4; sizeId++) {\n          for (let matrixId = 0; matrixId < (sizeId === 3 ? 2 : 6); matrixId++) {\n            const scaling_list_pred_mode_flag = eg.readBoolean();\n            if (!scaling_list_pred_mode_flag) {\n              eg.readUEG(); // scaling_list_pred_matrix_id_delta\n            } else {\n              const coefNum = Math.min(64, 1 << 4 + (sizeId << 1));\n              if (sizeId > 1) {\n                eg.readEG();\n              }\n              for (let i = 0; i < coefNum; i++) {\n                eg.readEG();\n              }\n            }\n          }\n        }\n      }\n    }\n    eg.readBoolean(); // amp_enabled_flag\n    eg.readBoolean(); // sample_adaptive_offset_enabled_flag\n    const pcm_enabled_flag = eg.readBoolean();\n    if (pcm_enabled_flag) {\n      eg.readUByte();\n      eg.skipUEG();\n      eg.skipUEG();\n      eg.readBoolean();\n    }\n    const num_short_term_ref_pic_sets = eg.readUEG();\n    let num_delta_pocs = 0;\n    for (let i = 0; i < num_short_term_ref_pic_sets; i++) {\n      let inter_ref_pic_set_prediction_flag = false;\n      if (i !== 0) {\n        inter_ref_pic_set_prediction_flag = eg.readBoolean();\n      }\n      if (inter_ref_pic_set_prediction_flag) {\n        if (i === num_short_term_ref_pic_sets) {\n          eg.readUEG();\n        }\n        eg.readBoolean();\n        eg.readUEG();\n        let next_num_delta_pocs = 0;\n        for (let j = 0; j <= num_delta_pocs; j++) {\n          const used_by_curr_pic_flag = eg.readBoolean();\n          let use_delta_flag = false;\n          if (!used_by_curr_pic_flag) {\n            use_delta_flag = eg.readBoolean();\n          }\n          if (used_by_curr_pic_flag || use_delta_flag) {\n            next_num_delta_pocs++;\n          }\n        }\n        num_delta_pocs = next_num_delta_pocs;\n      } else {\n        const num_negative_pics = eg.readUEG();\n        const num_positive_pics = eg.readUEG();\n        num_delta_pocs = num_negative_pics + num_positive_pics;\n        for (let j = 0; j < num_negative_pics; j++) {\n          eg.readUEG();\n          eg.readBoolean();\n        }\n        for (let j = 0; j < num_positive_pics; j++) {\n          eg.readUEG();\n          eg.readBoolean();\n        }\n      }\n    }\n    const long_term_ref_pics_present_flag = eg.readBoolean();\n    if (long_term_ref_pics_present_flag) {\n      const num_long_term_ref_pics_sps = eg.readUEG();\n      for (let i = 0; i < num_long_term_ref_pics_sps; i++) {\n        for (let j = 0; j < log2_max_pic_order_cnt_lsb_minus4 + 4; j++) {\n          eg.readBits(1);\n        }\n        eg.readBits(1);\n      }\n    }\n    let min_spatial_segmentation_idc = 0;\n    let sar_width = 1,\n      sar_height = 1;\n    let fps_fixed = true,\n      fps_den = 1,\n      fps_num = 0;\n    eg.readBoolean(); // sps_temporal_mvp_enabled_flag\n    eg.readBoolean(); // strong_intra_smoothing_enabled_flag\n    let default_display_window_flag = false;\n    const vui_parameters_present_flag = eg.readBoolean();\n    if (vui_parameters_present_flag) {\n      const aspect_ratio_info_present_flag = eg.readBoolean();\n      if (aspect_ratio_info_present_flag) {\n        const aspect_ratio_idc = eg.readUByte();\n        const sar_width_table = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2];\n        const sar_height_table = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1];\n        if (aspect_ratio_idc > 0 && aspect_ratio_idc < 16) {\n          sar_width = sar_width_table[aspect_ratio_idc - 1];\n          sar_height = sar_height_table[aspect_ratio_idc - 1];\n        } else if (aspect_ratio_idc === 255) {\n          sar_width = eg.readBits(16);\n          sar_height = eg.readBits(16);\n        }\n      }\n      const overscan_info_present_flag = eg.readBoolean();\n      if (overscan_info_present_flag) {\n        eg.readBoolean();\n      }\n      const video_signal_type_present_flag = eg.readBoolean();\n      if (video_signal_type_present_flag) {\n        eg.readBits(3);\n        eg.readBoolean();\n        const colour_description_present_flag = eg.readBoolean();\n        if (colour_description_present_flag) {\n          eg.readUByte();\n          eg.readUByte();\n          eg.readUByte();\n        }\n      }\n      const chroma_loc_info_present_flag = eg.readBoolean();\n      if (chroma_loc_info_present_flag) {\n        eg.readUEG();\n        eg.readUEG();\n      }\n      eg.readBoolean(); // neutral_chroma_indication_flag\n      eg.readBoolean(); // field_seq_flag\n      eg.readBoolean(); // frame_field_info_present_flag\n      default_display_window_flag = eg.readBoolean();\n      if (default_display_window_flag) {\n        pic_left_offset += eg.readUEG();\n        pic_right_offset += eg.readUEG();\n        pic_top_offset += eg.readUEG();\n        pic_bottom_offset += eg.readUEG();\n      }\n      const vui_timing_info_present_flag = eg.readBoolean();\n      if (vui_timing_info_present_flag) {\n        fps_den = eg.readBits(32);\n        fps_num = eg.readBits(32);\n        const vui_poc_proportional_to_timing_flag = eg.readBoolean();\n        if (vui_poc_proportional_to_timing_flag) {\n          eg.readUEG();\n        }\n        const vui_hrd_parameters_present_flag = eg.readBoolean();\n        if (vui_hrd_parameters_present_flag) {\n          //const commonInfPresentFlag = true;\n          //if (commonInfPresentFlag) {\n          const nal_hrd_parameters_present_flag = eg.readBoolean();\n          const vcl_hrd_parameters_present_flag = eg.readBoolean();\n          let sub_pic_hrd_params_present_flag = false;\n          if (nal_hrd_parameters_present_flag || vcl_hrd_parameters_present_flag) {\n            sub_pic_hrd_params_present_flag = eg.readBoolean();\n            if (sub_pic_hrd_params_present_flag) {\n              eg.readUByte();\n              eg.readBits(5);\n              eg.readBoolean();\n              eg.readBits(5);\n            }\n            eg.readBits(4); // bit_rate_scale\n            eg.readBits(4); // cpb_size_scale\n            if (sub_pic_hrd_params_present_flag) {\n              eg.readBits(4);\n            }\n            eg.readBits(5);\n            eg.readBits(5);\n            eg.readBits(5);\n          }\n          //}\n          for (let i = 0; i <= max_sub_layers_minus1; i++) {\n            fps_fixed = eg.readBoolean(); // fixed_pic_rate_general_flag\n            const fixed_pic_rate_within_cvs_flag = fps_fixed || eg.readBoolean();\n            let low_delay_hrd_flag = false;\n            if (fixed_pic_rate_within_cvs_flag) {\n              eg.readEG();\n            } else {\n              low_delay_hrd_flag = eg.readBoolean();\n            }\n            const cpb_cnt = low_delay_hrd_flag ? 1 : eg.readUEG() + 1;\n            if (nal_hrd_parameters_present_flag) {\n              for (let j = 0; j < cpb_cnt; j++) {\n                eg.readUEG();\n                eg.readUEG();\n                if (sub_pic_hrd_params_present_flag) {\n                  eg.readUEG();\n                  eg.readUEG();\n                }\n                eg.skipBits(1);\n              }\n            }\n            if (vcl_hrd_parameters_present_flag) {\n              for (let j = 0; j < cpb_cnt; j++) {\n                eg.readUEG();\n                eg.readUEG();\n                if (sub_pic_hrd_params_present_flag) {\n                  eg.readUEG();\n                  eg.readUEG();\n                }\n                eg.skipBits(1);\n              }\n            }\n          }\n        }\n      }\n      const bitstream_restriction_flag = eg.readBoolean();\n      if (bitstream_restriction_flag) {\n        eg.readBoolean(); // tiles_fixed_structure_flag\n        eg.readBoolean(); // motion_vectors_over_pic_boundaries_flag\n        eg.readBoolean(); // restricted_ref_pic_lists_flag\n        min_spatial_segmentation_idc = eg.readUEG();\n      }\n    }\n    let width = pic_width_in_luma_samples,\n      height = pic_height_in_luma_samples;\n    if (conformance_window_flag || default_display_window_flag) {\n      let chroma_scale_w = 1,\n        chroma_scale_h = 1;\n      if (chroma_format_idc === 1) {\n        // YUV 420\n        chroma_scale_w = chroma_scale_h = 2;\n      } else if (chroma_format_idc == 2) {\n        // YUV 422\n        chroma_scale_w = 2;\n      }\n      width = pic_width_in_luma_samples - chroma_scale_w * pic_right_offset - chroma_scale_w * pic_left_offset;\n      height = pic_height_in_luma_samples - chroma_scale_h * pic_bottom_offset - chroma_scale_h * pic_top_offset;\n    }\n    const profile_space_string = general_profile_space ? ['A', 'B', 'C'][general_profile_space] : '';\n    const profile_compatibility_buf = general_profile_compatibility_flags_1 << 24 | general_profile_compatibility_flags_2 << 16 | general_profile_compatibility_flags_3 << 8 | general_profile_compatibility_flags_4;\n    let profile_compatibility_rev = 0;\n    for (let i = 0; i < 32; i++) {\n      profile_compatibility_rev = (profile_compatibility_rev | (profile_compatibility_buf >> i & 1) << 31 - i) >>> 0; // reverse bit position (and cast as UInt32)\n    }\n    let profile_compatibility_flags_string = profile_compatibility_rev.toString(16);\n    if (general_profile_idc === 1 && profile_compatibility_flags_string === '2') {\n      profile_compatibility_flags_string = '6';\n    }\n    const tier_flag_string = general_tier_flag ? 'H' : 'L';\n    return {\n      codecString: `hvc1.${profile_space_string}${general_profile_idc}.${profile_compatibility_flags_string}.${tier_flag_string}${general_level_idc}.B0`,\n      params: {\n        general_tier_flag,\n        general_profile_idc,\n        general_profile_space,\n        general_profile_compatibility_flags: [general_profile_compatibility_flags_1, general_profile_compatibility_flags_2, general_profile_compatibility_flags_3, general_profile_compatibility_flags_4],\n        general_constraint_indicator_flags: [general_constraint_indicator_flags_1, general_constraint_indicator_flags_2, general_constraint_indicator_flags_3, general_constraint_indicator_flags_4, general_constraint_indicator_flags_5, general_constraint_indicator_flags_6],\n        general_level_idc,\n        bit_depth: bit_depth_luma_minus8 + 8,\n        bit_depth_luma_minus8,\n        bit_depth_chroma_minus8,\n        min_spatial_segmentation_idc,\n        chroma_format_idc: chroma_format_idc,\n        frame_rate: {\n          fixed: fps_fixed,\n          fps: fps_num / fps_den\n        }\n      },\n      width,\n      height,\n      pixelRatio: [sar_width, sar_height]\n    };\n  }\n  readPPS(pps) {\n    const eg = new ExpGolomb(this.ebsp2rbsp(pps));\n    eg.readUByte();\n    eg.readUByte();\n    eg.skipUEG(); // pic_parameter_set_id\n    eg.skipUEG(); // seq_parameter_set_id\n    eg.skipBits(2); // dependent_slice_segments_enabled_flag, output_flag_present_flag\n    eg.skipBits(3); // num_extra_slice_header_bits\n    eg.skipBits(2); // sign_data_hiding_enabled_flag, cabac_init_present_flag\n    eg.skipUEG();\n    eg.skipUEG();\n    eg.skipEG(); // init_qp_minus26\n    eg.skipBits(2); // constrained_intra_pred_flag, transform_skip_enabled_flag\n    const cu_qp_delta_enabled_flag = eg.readBoolean();\n    if (cu_qp_delta_enabled_flag) {\n      eg.skipUEG();\n    }\n    eg.skipEG(); // cb_qp_offset\n    eg.skipEG(); // cr_qp_offset\n    eg.skipBits(4); // pps_slice_chroma_qp_offsets_present_flag, weighted_pred_flag, weighted_bipred_flag, transquant_bypass_enabled_flag\n    const tiles_enabled_flag = eg.readBoolean();\n    const entropy_coding_sync_enabled_flag = eg.readBoolean();\n    let parallelismType = 1; // slice-based parallel decoding\n    if (entropy_coding_sync_enabled_flag && tiles_enabled_flag) {\n      parallelismType = 0; // mixed-type parallel decoding\n    } else if (entropy_coding_sync_enabled_flag) {\n      parallelismType = 3; // wavefront-based parallel decoding\n    } else if (tiles_enabled_flag) {\n      parallelismType = 2; // tile-based parallel decoding\n    }\n    return {\n      parallelismType\n    };\n  }\n  matchSPS(sps1, sps2) {\n    // compare without headers and VPS related params\n    return String.fromCharCode.apply(null, sps1).substr(3) === String.fromCharCode.apply(null, sps2).substr(3);\n  }\n}\n\nconst PACKET_LENGTH = 188;\nclass TSDemuxer {\n  constructor(observer, config, typeSupported, logger) {\n    this.logger = void 0;\n    this.observer = void 0;\n    this.config = void 0;\n    this.typeSupported = void 0;\n    this.sampleAes = null;\n    this.pmtParsed = false;\n    this.audioCodec = void 0;\n    this.videoCodec = void 0;\n    this._pmtId = -1;\n    this._videoTrack = void 0;\n    this._audioTrack = void 0;\n    this._id3Track = void 0;\n    this._txtTrack = void 0;\n    this.aacOverFlow = null;\n    this.remainderData = null;\n    this.videoParser = void 0;\n    this.observer = observer;\n    this.config = config;\n    this.typeSupported = typeSupported;\n    this.logger = logger;\n    this.videoParser = null;\n  }\n  static probe(data, logger) {\n    const syncOffset = TSDemuxer.syncOffset(data);\n    if (syncOffset > 0) {\n      logger.warn(`MPEG2-TS detected but first sync word found @ offset ${syncOffset}`);\n    }\n    return syncOffset !== -1;\n  }\n  static syncOffset(data) {\n    const length = data.length;\n    let scanwindow = Math.min(PACKET_LENGTH * 5, length - PACKET_LENGTH) + 1;\n    let i = 0;\n    while (i < scanwindow) {\n      // a TS init segment should contain at least 2 TS packets: PAT and PMT, each starting with 0x47\n      let foundPat = false;\n      let packetStart = -1;\n      let tsPackets = 0;\n      for (let j = i; j < length; j += PACKET_LENGTH) {\n        if (data[j] === 0x47 && (length - j === PACKET_LENGTH || data[j + PACKET_LENGTH] === 0x47)) {\n          tsPackets++;\n          if (packetStart === -1) {\n            packetStart = j;\n            // First sync word found at offset, increase scan length (#5251)\n            if (packetStart !== 0) {\n              scanwindow = Math.min(packetStart + PACKET_LENGTH * 99, data.length - PACKET_LENGTH) + 1;\n            }\n          }\n          if (!foundPat) {\n            foundPat = parsePID(data, j) === 0;\n          }\n          // Sync word found at 0 with 3 packets, or found at offset least 2 packets up to scanwindow (#5501)\n          if (foundPat && tsPackets > 1 && (packetStart === 0 && tsPackets > 2 || j + PACKET_LENGTH > scanwindow)) {\n            return packetStart;\n          }\n        } else if (tsPackets) {\n          // Exit if sync word found, but does not contain contiguous packets\n          return -1;\n        } else {\n          break;\n        }\n      }\n      i++;\n    }\n    return -1;\n  }\n\n  /**\n   * Creates a track model internal to demuxer used to drive remuxing input\n   */\n  static createTrack(type, duration) {\n    return {\n      container: type === 'video' || type === 'audio' ? 'video/mp2t' : undefined,\n      type,\n      id: RemuxerTrackIdConfig[type],\n      pid: -1,\n      inputTimeScale: 90000,\n      sequenceNumber: 0,\n      samples: [],\n      dropped: 0,\n      duration: type === 'audio' ? duration : undefined\n    };\n  }\n\n  /**\n   * Initializes a new init segment on the demuxer/remuxer interface. Needed for discontinuities/track-switches (or at stream start)\n   * Resets all internal track instances of the demuxer.\n   */\n  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    this.pmtParsed = false;\n    this._pmtId = -1;\n    this._videoTrack = TSDemuxer.createTrack('video');\n    this._videoTrack.duration = trackDuration;\n    this._audioTrack = TSDemuxer.createTrack('audio', trackDuration);\n    this._id3Track = TSDemuxer.createTrack('id3');\n    this._txtTrack = TSDemuxer.createTrack('text');\n    this._audioTrack.segmentCodec = 'aac';\n\n    // flush any partial content\n    this.aacOverFlow = null;\n    this.remainderData = null;\n    this.audioCodec = audioCodec;\n    this.videoCodec = videoCodec;\n  }\n  resetTimeStamp() {}\n  resetContiguity() {\n    const {\n      _audioTrack,\n      _videoTrack,\n      _id3Track\n    } = this;\n    if (_audioTrack) {\n      _audioTrack.pesData = null;\n    }\n    if (_videoTrack) {\n      _videoTrack.pesData = null;\n    }\n    if (_id3Track) {\n      _id3Track.pesData = null;\n    }\n    this.aacOverFlow = null;\n    this.remainderData = null;\n  }\n  demux(data, timeOffset, isSampleAes = false, flush = false) {\n    if (!isSampleAes) {\n      this.sampleAes = null;\n    }\n    let pes;\n    const videoTrack = this._videoTrack;\n    const audioTrack = this._audioTrack;\n    const id3Track = this._id3Track;\n    const textTrack = this._txtTrack;\n    let videoPid = videoTrack.pid;\n    let videoData = videoTrack.pesData;\n    let audioPid = audioTrack.pid;\n    let id3Pid = id3Track.pid;\n    let audioData = audioTrack.pesData;\n    let id3Data = id3Track.pesData;\n    let unknownPID = null;\n    let pmtParsed = this.pmtParsed;\n    let pmtId = this._pmtId;\n    let len = data.length;\n    if (this.remainderData) {\n      data = appendUint8Array(this.remainderData, data);\n      len = data.length;\n      this.remainderData = null;\n    }\n    if (len < PACKET_LENGTH && !flush) {\n      this.remainderData = data;\n      return {\n        audioTrack,\n        videoTrack,\n        id3Track,\n        textTrack\n      };\n    }\n    const syncOffset = Math.max(0, TSDemuxer.syncOffset(data));\n    len -= (len - syncOffset) % PACKET_LENGTH;\n    if (len < data.byteLength && !flush) {\n      this.remainderData = new Uint8Array(data.buffer, len, data.buffer.byteLength - len);\n    }\n\n    // loop through TS packets\n    let tsPacketErrors = 0;\n    for (let start = syncOffset; start < len; start += PACKET_LENGTH) {\n      if (data[start] === 0x47) {\n        const stt = !!(data[start + 1] & 0x40);\n        const pid = parsePID(data, start);\n        const atf = (data[start + 3] & 0x30) >> 4;\n\n        // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.\n        let offset;\n        if (atf > 1) {\n          offset = start + 5 + data[start + 4];\n          // continue if there is only adaptation field\n          if (offset === start + PACKET_LENGTH) {\n            continue;\n          }\n        } else {\n          offset = start + 4;\n        }\n        switch (pid) {\n          case videoPid:\n            if (stt) {\n              if (videoData && (pes = parsePES(videoData, this.logger))) {\n                if (this.videoParser === null) {\n                  switch (videoTrack.segmentCodec) {\n                    case 'avc':\n                      this.videoParser = new AvcVideoParser();\n                      break;\n                    case 'hevc':\n                      {\n                        this.videoParser = new HevcVideoParser();\n                      }\n                      break;\n                  }\n                }\n                if (this.videoParser !== null) {\n                  this.videoParser.parsePES(videoTrack, textTrack, pes, false);\n                }\n              }\n              videoData = {\n                data: [],\n                size: 0\n              };\n            }\n            if (videoData) {\n              videoData.data.push(data.subarray(offset, start + PACKET_LENGTH));\n              videoData.size += start + PACKET_LENGTH - offset;\n            }\n            break;\n          case audioPid:\n            if (stt) {\n              if (audioData && (pes = parsePES(audioData, this.logger))) {\n                switch (audioTrack.segmentCodec) {\n                  case 'aac':\n                    this.parseAACPES(audioTrack, pes);\n                    break;\n                  case 'mp3':\n                    this.parseMPEGPES(audioTrack, pes);\n                    break;\n                  case 'ac3':\n                    {\n                      this.parseAC3PES(audioTrack, pes);\n                    }\n                    break;\n                }\n              }\n              audioData = {\n                data: [],\n                size: 0\n              };\n            }\n            if (audioData) {\n              audioData.data.push(data.subarray(offset, start + PACKET_LENGTH));\n              audioData.size += start + PACKET_LENGTH - offset;\n            }\n            break;\n          case id3Pid:\n            if (stt) {\n              if (id3Data && (pes = parsePES(id3Data, this.logger))) {\n                this.parseID3PES(id3Track, pes);\n              }\n              id3Data = {\n                data: [],\n                size: 0\n              };\n            }\n            if (id3Data) {\n              id3Data.data.push(data.subarray(offset, start + PACKET_LENGTH));\n              id3Data.size += start + PACKET_LENGTH - offset;\n            }\n            break;\n          case 0:\n            if (stt) {\n              offset += data[offset] + 1;\n            }\n            pmtId = this._pmtId = parsePAT(data, offset);\n            // this.logger.log('PMT PID:'  + this._pmtId);\n            break;\n          case pmtId:\n            {\n              if (stt) {\n                offset += data[offset] + 1;\n              }\n              const parsedPIDs = parsePMT(data, offset, this.typeSupported, isSampleAes, this.observer, this.logger);\n\n              // only update track id if track PID found while parsing PMT\n              // this is to avoid resetting the PID to -1 in case\n              // track PID transiently disappears from the stream\n              // this could happen in case of transient missing audio samples for example\n              // NOTE this is only the PID of the track as found in TS,\n              // but we are not using this for MP4 track IDs.\n              videoPid = parsedPIDs.videoPid;\n              if (videoPid > 0) {\n                videoTrack.pid = videoPid;\n                videoTrack.segmentCodec = parsedPIDs.segmentVideoCodec;\n              }\n              audioPid = parsedPIDs.audioPid;\n              if (audioPid > 0) {\n                audioTrack.pid = audioPid;\n                audioTrack.segmentCodec = parsedPIDs.segmentAudioCodec;\n              }\n              id3Pid = parsedPIDs.id3Pid;\n              if (id3Pid > 0) {\n                id3Track.pid = id3Pid;\n              }\n              if (unknownPID !== null && !pmtParsed) {\n                this.logger.warn(`MPEG-TS PMT found at ${start} after unknown PID '${unknownPID}'. Backtracking to sync byte @${syncOffset} to parse all TS packets.`);\n                unknownPID = null;\n                // we set it to -188, the += 188 in the for loop will reset start to 0\n                start = syncOffset - 188;\n              }\n              pmtParsed = this.pmtParsed = true;\n              break;\n            }\n          case 0x11:\n          case 0x1fff:\n            break;\n          default:\n            unknownPID = pid;\n            break;\n        }\n      } else {\n        tsPacketErrors++;\n      }\n    }\n    if (tsPacketErrors > 0) {\n      emitParsingError(this.observer, new Error(`Found ${tsPacketErrors} TS packet/s that do not start with 0x47`), undefined, this.logger);\n    }\n    videoTrack.pesData = videoData;\n    audioTrack.pesData = audioData;\n    id3Track.pesData = id3Data;\n    const demuxResult = {\n      audioTrack,\n      videoTrack,\n      id3Track,\n      textTrack\n    };\n    if (flush) {\n      this.extractRemainingSamples(demuxResult);\n    }\n    return demuxResult;\n  }\n  flush() {\n    const {\n      remainderData\n    } = this;\n    this.remainderData = null;\n    let result;\n    if (remainderData) {\n      result = this.demux(remainderData, -1, false, true);\n    } else {\n      result = {\n        videoTrack: this._videoTrack,\n        audioTrack: this._audioTrack,\n        id3Track: this._id3Track,\n        textTrack: this._txtTrack\n      };\n    }\n    this.extractRemainingSamples(result);\n    if (this.sampleAes) {\n      return this.decrypt(result, this.sampleAes);\n    }\n    return result;\n  }\n  extractRemainingSamples(demuxResult) {\n    const {\n      audioTrack,\n      videoTrack,\n      id3Track,\n      textTrack\n    } = demuxResult;\n    const videoData = videoTrack.pesData;\n    const audioData = audioTrack.pesData;\n    const id3Data = id3Track.pesData;\n    // try to parse last PES packets\n    let pes;\n    if (videoData && (pes = parsePES(videoData, this.logger))) {\n      if (this.videoParser === null) {\n        switch (videoTrack.segmentCodec) {\n          case 'avc':\n            this.videoParser = new AvcVideoParser();\n            break;\n          case 'hevc':\n            {\n              this.videoParser = new HevcVideoParser();\n            }\n            break;\n        }\n      }\n      if (this.videoParser !== null) {\n        this.videoParser.parsePES(videoTrack, textTrack, pes, true);\n        videoTrack.pesData = null;\n      }\n    } else {\n      // either avcData null or PES truncated, keep it for next frag parsing\n      videoTrack.pesData = videoData;\n    }\n    if (audioData && (pes = parsePES(audioData, this.logger))) {\n      switch (audioTrack.segmentCodec) {\n        case 'aac':\n          this.parseAACPES(audioTrack, pes);\n          break;\n        case 'mp3':\n          this.parseMPEGPES(audioTrack, pes);\n          break;\n        case 'ac3':\n          {\n            this.parseAC3PES(audioTrack, pes);\n          }\n          break;\n      }\n      audioTrack.pesData = null;\n    } else {\n      if (audioData != null && audioData.size) {\n        this.logger.log('last AAC PES packet truncated,might overlap between fragments');\n      }\n\n      // either audioData null or PES truncated, keep it for next frag parsing\n      audioTrack.pesData = audioData;\n    }\n    if (id3Data && (pes = parsePES(id3Data, this.logger))) {\n      this.parseID3PES(id3Track, pes);\n      id3Track.pesData = null;\n    } else {\n      // either id3Data null or PES truncated, keep it for next frag parsing\n      id3Track.pesData = id3Data;\n    }\n  }\n  demuxSampleAes(data, keyData, timeOffset) {\n    const demuxResult = this.demux(data, timeOffset, true, !this.config.progressive);\n    const sampleAes = this.sampleAes = new SampleAesDecrypter(this.observer, this.config, keyData);\n    return this.decrypt(demuxResult, sampleAes);\n  }\n  decrypt(demuxResult, sampleAes) {\n    return new Promise(resolve => {\n      const {\n        audioTrack,\n        videoTrack\n      } = demuxResult;\n      if (audioTrack.samples && audioTrack.segmentCodec === 'aac') {\n        sampleAes.decryptAacSamples(audioTrack.samples, 0, () => {\n          if (videoTrack.samples) {\n            sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, () => {\n              resolve(demuxResult);\n            });\n          } else {\n            resolve(demuxResult);\n          }\n        });\n      } else if (videoTrack.samples) {\n        sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, () => {\n          resolve(demuxResult);\n        });\n      }\n    });\n  }\n  destroy() {\n    if (this.observer) {\n      this.observer.removeAllListeners();\n    }\n    // @ts-ignore\n    this.config = this.logger = this.observer = null;\n    this.aacOverFlow = this.videoParser = this.remainderData = this.sampleAes = null;\n    this._videoTrack = this._audioTrack = this._id3Track = this._txtTrack = undefined;\n  }\n  parseAACPES(track, pes) {\n    let startOffset = 0;\n    const aacOverFlow = this.aacOverFlow;\n    let data = pes.data;\n    if (aacOverFlow) {\n      this.aacOverFlow = null;\n      const frameMissingBytes = aacOverFlow.missing;\n      const sampleLength = aacOverFlow.sample.unit.byteLength;\n      // logger.log(`AAC: append overflowing ${sampleLength} bytes to beginning of new PES`);\n      if (frameMissingBytes === -1) {\n        data = appendUint8Array(aacOverFlow.sample.unit, data);\n      } else {\n        const frameOverflowBytes = sampleLength - frameMissingBytes;\n        aacOverFlow.sample.unit.set(data.subarray(0, frameMissingBytes), frameOverflowBytes);\n        track.samples.push(aacOverFlow.sample);\n        startOffset = aacOverFlow.missing;\n      }\n    }\n    // look for ADTS header (0xFFFx)\n    let offset;\n    let len;\n    for (offset = startOffset, len = data.length; offset < len - 1; offset++) {\n      if (isHeader$1(data, offset)) {\n        break;\n      }\n    }\n    // if ADTS header does not start straight from the beginning of the PES payload, raise an error\n    if (offset !== startOffset) {\n      let reason;\n      const recoverable = offset < len - 1;\n      if (recoverable) {\n        reason = `AAC PES did not start with ADTS header,offset:${offset}`;\n      } else {\n        reason = 'No ADTS header found in AAC PES';\n      }\n      emitParsingError(this.observer, new Error(reason), recoverable, this.logger);\n      if (!recoverable) {\n        return;\n      }\n    }\n    initTrackConfig(track, this.observer, data, offset, this.audioCodec);\n    let pts;\n    if (pes.pts !== undefined) {\n      pts = pes.pts;\n    } else if (aacOverFlow) {\n      // if last AAC frame is overflowing, we should ensure timestamps are contiguous:\n      // first sample PTS should be equal to last sample PTS + frameDuration\n      const frameDuration = getFrameDuration(track.samplerate);\n      pts = aacOverFlow.sample.pts + frameDuration;\n    } else {\n      this.logger.warn('[tsdemuxer]: AAC PES unknown PTS');\n      return;\n    }\n\n    // scan for aac samples\n    let frameIndex = 0;\n    let frame;\n    while (offset < len) {\n      frame = appendFrame$2(track, data, offset, pts, frameIndex);\n      offset += frame.length;\n      if (!frame.missing) {\n        frameIndex++;\n        for (; offset < len - 1; offset++) {\n          if (isHeader$1(data, offset)) {\n            break;\n          }\n        }\n      } else {\n        this.aacOverFlow = frame;\n        break;\n      }\n    }\n  }\n  parseMPEGPES(track, pes) {\n    const data = pes.data;\n    const length = data.length;\n    let frameIndex = 0;\n    let offset = 0;\n    const pts = pes.pts;\n    if (pts === undefined) {\n      this.logger.warn('[tsdemuxer]: MPEG PES unknown PTS');\n      return;\n    }\n    while (offset < length) {\n      if (isHeader(data, offset)) {\n        const frame = appendFrame$1(track, data, offset, pts, frameIndex);\n        if (frame) {\n          offset += frame.length;\n          frameIndex++;\n        } else {\n          // logger.log('Unable to parse Mpeg audio frame');\n          break;\n        }\n      } else {\n        // nothing found, keep looking\n        offset++;\n      }\n    }\n  }\n  parseAC3PES(track, pes) {\n    {\n      const data = pes.data;\n      const pts = pes.pts;\n      if (pts === undefined) {\n        this.logger.warn('[tsdemuxer]: AC3 PES unknown PTS');\n        return;\n      }\n      const length = data.length;\n      let frameIndex = 0;\n      let offset = 0;\n      let parsed;\n      while (offset < length && (parsed = appendFrame(track, data, offset, pts, frameIndex++)) > 0) {\n        offset += parsed;\n      }\n    }\n  }\n  parseID3PES(id3Track, pes) {\n    if (pes.pts === undefined) {\n      this.logger.warn('[tsdemuxer]: ID3 PES unknown PTS');\n      return;\n    }\n    const id3Sample = _extends({}, pes, {\n      type: this._videoTrack ? MetadataSchema.emsg : MetadataSchema.audioId3,\n      duration: Number.POSITIVE_INFINITY\n    });\n    id3Track.samples.push(id3Sample);\n  }\n}\nfunction parsePID(data, offset) {\n  // pid is a 13-bit field starting at the last bit of TS[1]\n  return ((data[offset + 1] & 0x1f) << 8) + data[offset + 2];\n}\nfunction parsePAT(data, offset) {\n  // skip the PSI header and parse the first PMT entry\n  return (data[offset + 10] & 0x1f) << 8 | data[offset + 11];\n}\nfunction parsePMT(data, offset, typeSupported, isSampleAes, observer, logger) {\n  const result = {\n    audioPid: -1,\n    videoPid: -1,\n    id3Pid: -1,\n    segmentVideoCodec: 'avc',\n    segmentAudioCodec: 'aac'\n  };\n  const sectionLength = (data[offset + 1] & 0x0f) << 8 | data[offset + 2];\n  const tableEnd = offset + 3 + sectionLength - 4;\n  // to determine where the table is, we have to figure out how\n  // long the program info descriptors are\n  const programInfoLength = (data[offset + 10] & 0x0f) << 8 | data[offset + 11];\n  // advance the offset to the first entry in the mapping table\n  offset += 12 + programInfoLength;\n  while (offset < tableEnd) {\n    const pid = parsePID(data, offset);\n    const esInfoLength = (data[offset + 3] & 0x0f) << 8 | data[offset + 4];\n    switch (data[offset]) {\n      case 0xcf:\n        // SAMPLE-AES AAC\n        if (!isSampleAes) {\n          logEncryptedSamplesFoundInUnencryptedStream('ADTS AAC', logger);\n          break;\n        }\n      /* falls through */\n      case 0x0f:\n        // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)\n        // logger.log('AAC PID:'  + pid);\n        if (result.audioPid === -1) {\n          result.audioPid = pid;\n        }\n        break;\n\n      // Packetized metadata (ID3)\n      case 0x15:\n        // logger.log('ID3 PID:'  + pid);\n        if (result.id3Pid === -1) {\n          result.id3Pid = pid;\n        }\n        break;\n      case 0xdb:\n        // SAMPLE-AES AVC\n        if (!isSampleAes) {\n          logEncryptedSamplesFoundInUnencryptedStream('H.264', logger);\n          break;\n        }\n      /* falls through */\n      case 0x1b:\n        // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)\n        // logger.log('AVC PID:'  + pid);\n        if (result.videoPid === -1) {\n          result.videoPid = pid;\n        }\n        break;\n\n      // ISO/IEC 11172-3 (MPEG-1 audio)\n      // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)\n      case 0x03:\n      case 0x04:\n        // logger.log('MPEG PID:'  + pid);\n        if (!typeSupported.mpeg && !typeSupported.mp3) {\n          logger.log('MPEG audio found, not supported in this browser');\n        } else if (result.audioPid === -1) {\n          result.audioPid = pid;\n          result.segmentAudioCodec = 'mp3';\n        }\n        break;\n      case 0xc1:\n        // SAMPLE-AES AC3\n        if (!isSampleAes) {\n          logEncryptedSamplesFoundInUnencryptedStream('AC-3', logger);\n          break;\n        }\n      /* falls through */\n      case 0x81:\n        {\n          if (!typeSupported.ac3) {\n            logger.log('AC-3 audio found, not supported in this browser');\n          } else if (result.audioPid === -1) {\n            result.audioPid = pid;\n            result.segmentAudioCodec = 'ac3';\n          }\n        }\n        break;\n      case 0x06:\n        // stream_type 6 can mean a lot of different things in case of DVB.\n        // We need to look at the descriptors. Right now, we're only interested\n        // in AC-3 audio, so we do the descriptor parsing only when we don't have\n        // an audio PID yet.\n        if (result.audioPid === -1 && esInfoLength > 0) {\n          let parsePos = offset + 5;\n          let remaining = esInfoLength;\n          while (remaining > 2) {\n            const descriptorId = data[parsePos];\n            switch (descriptorId) {\n              case 0x6a:\n                // DVB Descriptor for AC-3\n                {\n                  if (typeSupported.ac3 !== true) {\n                    logger.log('AC-3 audio found, not supported in this browser for now');\n                  } else {\n                    result.audioPid = pid;\n                    result.segmentAudioCodec = 'ac3';\n                  }\n                }\n                break;\n            }\n            const descriptorLen = data[parsePos + 1] + 2;\n            parsePos += descriptorLen;\n            remaining -= descriptorLen;\n          }\n        }\n        break;\n      case 0xc2: // SAMPLE-AES EC3\n      /* falls through */\n      case 0x87:\n        emitParsingError(observer, new Error('Unsupported EC-3 in M2TS found'), undefined, logger);\n        return result;\n      case 0x24:\n        // ITU-T Rec. H.265 and ISO/IEC 23008-2 (HEVC)\n        {\n          if (result.videoPid === -1) {\n            result.videoPid = pid;\n            result.segmentVideoCodec = 'hevc';\n            logger.log('HEVC in M2TS found');\n          }\n        }\n        break;\n    }\n    // move to the next table entry\n    // skip past the elementary stream descriptors, if present\n    offset += esInfoLength + 5;\n  }\n  return result;\n}\nfunction emitParsingError(observer, error, levelRetry, logger) {\n  logger.warn(`parsing error: ${error.message}`);\n  observer.emit(Events.ERROR, Events.ERROR, {\n    type: ErrorTypes.MEDIA_ERROR,\n    details: ErrorDetails.FRAG_PARSING_ERROR,\n    fatal: false,\n    levelRetry,\n    error,\n    reason: error.message\n  });\n}\nfunction logEncryptedSamplesFoundInUnencryptedStream(type, logger) {\n  logger.log(`${type} with AES-128-CBC encryption found in unencrypted stream`);\n}\nfunction parsePES(stream, logger) {\n  let i = 0;\n  let frag;\n  let pesLen;\n  let pesHdrLen;\n  let pesPts;\n  let pesDts;\n  const data = stream.data;\n  // safety check\n  if (!stream || stream.size === 0) {\n    return null;\n  }\n\n  // we might need up to 19 bytes to read PES header\n  // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes\n  // usually only one merge is needed (and this is rare ...)\n  while (data[0].length < 19 && data.length > 1) {\n    data[0] = appendUint8Array(data[0], data[1]);\n    data.splice(1, 1);\n  }\n  // retrieve PTS/DTS from first fragment\n  frag = data[0];\n  const pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];\n  if (pesPrefix === 1) {\n    pesLen = (frag[4] << 8) + frag[5];\n    // if PES parsed length is not zero and greater than total received length, stop parsing. PES might be truncated\n    // minus 6 : PES header size\n    if (pesLen && pesLen > stream.size - 6) {\n      return null;\n    }\n    const pesFlags = frag[7];\n    if (pesFlags & 0xc0) {\n      /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n          as PTS / DTS is 33 bit we cannot use bitwise operator in JS,\n          as Bitwise operators treat their operands as a sequence of 32 bits */\n      pesPts = (frag[9] & 0x0e) * 536870912 +\n      // 1 << 29\n      (frag[10] & 0xff) * 4194304 +\n      // 1 << 22\n      (frag[11] & 0xfe) * 16384 +\n      // 1 << 14\n      (frag[12] & 0xff) * 128 +\n      // 1 << 7\n      (frag[13] & 0xfe) / 2;\n      if (pesFlags & 0x40) {\n        pesDts = (frag[14] & 0x0e) * 536870912 +\n        // 1 << 29\n        (frag[15] & 0xff) * 4194304 +\n        // 1 << 22\n        (frag[16] & 0xfe) * 16384 +\n        // 1 << 14\n        (frag[17] & 0xff) * 128 +\n        // 1 << 7\n        (frag[18] & 0xfe) / 2;\n        if (pesPts - pesDts > 60 * 90000) {\n          logger.warn(`${Math.round((pesPts - pesDts) / 90000)}s delta between PTS and DTS, align them`);\n          pesPts = pesDts;\n        }\n      } else {\n        pesDts = pesPts;\n      }\n    }\n    pesHdrLen = frag[8];\n    // 9 bytes : 6 bytes for PES header + 3 bytes for PES extension\n    let payloadStartOffset = pesHdrLen + 9;\n    if (stream.size <= payloadStartOffset) {\n      return null;\n    }\n    stream.size -= payloadStartOffset;\n    // reassemble PES packet\n    const pesData = new Uint8Array(stream.size);\n    for (let j = 0, dataLen = data.length; j < dataLen; j++) {\n      frag = data[j];\n      let len = frag.byteLength;\n      if (payloadStartOffset) {\n        if (payloadStartOffset > len) {\n          // trim full frag if PES header bigger than frag\n          payloadStartOffset -= len;\n          continue;\n        } else {\n          // trim partial frag if PES header smaller than frag\n          frag = frag.subarray(payloadStartOffset);\n          len -= payloadStartOffset;\n          payloadStartOffset = 0;\n        }\n      }\n      pesData.set(frag, i);\n      i += len;\n    }\n    if (pesLen) {\n      // payload size : remove PES header + PES extension\n      pesLen -= pesHdrLen + 3;\n    }\n    return {\n      data: pesData,\n      pts: pesPts,\n      dts: pesDts,\n      len: pesLen\n    };\n  }\n  return null;\n}\n\n/**\n *  AAC helper\n */\n\nclass AAC {\n  static getSilentFrame(codec, channelCount) {\n    switch (codec) {\n      case 'mp4a.40.2':\n        if (channelCount === 1) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);\n        } else if (channelCount === 2) {\n          return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);\n        } else if (channelCount === 3) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);\n        } else if (channelCount === 4) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);\n        } else if (channelCount === 5) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);\n        } else if (channelCount === 6) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);\n        }\n        break;\n      // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)\n      default:\n        if (channelCount === 1) {\n          // ffmpeg -y -f lavfi -i \"aevalsrc=0:d=0.05\" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n          return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n        } else if (channelCount === 2) {\n          // ffmpeg -y -f lavfi -i \"aevalsrc=0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n          return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n        } else if (channelCount === 3) {\n          // ffmpeg -y -f lavfi -i \"aevalsrc=0|0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n          return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n        }\n        break;\n    }\n    return undefined;\n  }\n}\n\n/**\n * Generate MP4 Box\n */\n\nconst UINT32_MAX = Math.pow(2, 32) - 1;\nclass MP4 {\n  static init() {\n    MP4.types = {\n      avc1: [],\n      // codingname\n      avcC: [],\n      hvc1: [],\n      hvcC: [],\n      btrt: [],\n      dinf: [],\n      dref: [],\n      esds: [],\n      ftyp: [],\n      hdlr: [],\n      mdat: [],\n      mdhd: [],\n      mdia: [],\n      mfhd: [],\n      minf: [],\n      moof: [],\n      moov: [],\n      mp4a: [],\n      '.mp3': [],\n      dac3: [],\n      'ac-3': [],\n      mvex: [],\n      mvhd: [],\n      pasp: [],\n      sdtp: [],\n      stbl: [],\n      stco: [],\n      stsc: [],\n      stsd: [],\n      stsz: [],\n      stts: [],\n      tfdt: [],\n      tfhd: [],\n      traf: [],\n      trak: [],\n      trun: [],\n      trex: [],\n      tkhd: [],\n      vmhd: [],\n      smhd: []\n    };\n    let i;\n    for (i in MP4.types) {\n      if (MP4.types.hasOwnProperty(i)) {\n        MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];\n      }\n    }\n    const videoHdlr = new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00,\n    // pre_defined\n    0x76, 0x69, 0x64, 0x65,\n    // handler_type: 'vide'\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\n    ]);\n    const audioHdlr = new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00,\n    // pre_defined\n    0x73, 0x6f, 0x75, 0x6e,\n    // handler_type: 'soun'\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\n    ]);\n    MP4.HDLR_TYPES = {\n      video: videoHdlr,\n      audio: audioHdlr\n    };\n    const dref = new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x01,\n    // entry_count\n    0x00, 0x00, 0x00, 0x0c,\n    // entry_size\n    0x75, 0x72, 0x6c, 0x20,\n    // 'url' type\n    0x00,\n    // version 0\n    0x00, 0x00, 0x01 // entry_flags\n    ]);\n    const stco = new Uint8Array([0x00,\n    // version\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00 // entry_count\n    ]);\n    MP4.STTS = MP4.STSC = MP4.STCO = stco;\n    MP4.STSZ = new Uint8Array([0x00,\n    // version\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00,\n    // sample_size\n    0x00, 0x00, 0x00, 0x00 // sample_count\n    ]);\n    MP4.VMHD = new Uint8Array([0x00,\n    // version\n    0x00, 0x00, 0x01,\n    // flags\n    0x00, 0x00,\n    // graphicsmode\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor\n    ]);\n    MP4.SMHD = new Uint8Array([0x00,\n    // version\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00,\n    // balance\n    0x00, 0x00 // reserved\n    ]);\n    MP4.STSD = new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x01]); // entry_count\n\n    const majorBrand = new Uint8Array([105, 115, 111, 109]); // isom\n    const avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1\n    const minorVersion = new Uint8Array([0, 0, 0, 1]);\n    MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);\n    MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));\n  }\n  static box(type, ...payload) {\n    let size = 8;\n    let i = payload.length;\n    const len = i;\n    // calculate the total size we need to allocate\n    while (i--) {\n      size += payload[i].byteLength;\n    }\n    const result = new Uint8Array(size);\n    result[0] = size >> 24 & 0xff;\n    result[1] = size >> 16 & 0xff;\n    result[2] = size >> 8 & 0xff;\n    result[3] = size & 0xff;\n    result.set(type, 4);\n    // copy the payload into the result\n    for (i = 0, size = 8; i < len; i++) {\n      // copy payload[i] array @ offset size\n      result.set(payload[i], size);\n      size += payload[i].byteLength;\n    }\n    return result;\n  }\n  static hdlr(type) {\n    return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);\n  }\n  static mdat(data) {\n    return MP4.box(MP4.types.mdat, data);\n  }\n  static mdhd(timescale, duration) {\n    duration *= timescale;\n    const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n    const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n    return MP4.box(MP4.types.mdhd, new Uint8Array([0x01,\n    // version 1\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,\n    // creation_time\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,\n    // modification_time\n    timescale >> 24 & 0xff, timescale >> 16 & 0xff, timescale >> 8 & 0xff, timescale & 0xff,\n    // timescale\n    upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x55, 0xc4,\n    // 'und' language (undetermined)\n    0x00, 0x00]));\n  }\n  static mdia(track) {\n    return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale || 0, track.duration || 0), MP4.hdlr(track.type), MP4.minf(track));\n  }\n  static mfhd(sequenceNumber) {\n    return MP4.box(MP4.types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00,\n    // flags\n    sequenceNumber >> 24, sequenceNumber >> 16 & 0xff, sequenceNumber >> 8 & 0xff, sequenceNumber & 0xff // sequence_number\n    ]));\n  }\n  static minf(track) {\n    if (track.type === 'audio') {\n      return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));\n    } else {\n      return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));\n    }\n  }\n  static moof(sn, baseMediaDecodeTime, track) {\n    return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));\n  }\n  static moov(tracks) {\n    let i = tracks.length;\n    const boxes = [];\n    while (i--) {\n      boxes[i] = MP4.trak(tracks[i]);\n    }\n    return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].timescale || 0, tracks[0].duration || 0)].concat(boxes).concat(MP4.mvex(tracks)));\n  }\n  static mvex(tracks) {\n    let i = tracks.length;\n    const boxes = [];\n    while (i--) {\n      boxes[i] = MP4.trex(tracks[i]);\n    }\n    return MP4.box.apply(null, [MP4.types.mvex, ...boxes]);\n  }\n  static mvhd(timescale, duration) {\n    duration *= timescale;\n    const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n    const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n    const bytes = new Uint8Array([0x01,\n    // version 1\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,\n    // creation_time\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,\n    // modification_time\n    timescale >> 24 & 0xff, timescale >> 16 & 0xff, timescale >> 8 & 0xff, timescale & 0xff,\n    // timescale\n    upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x00, 0x01, 0x00, 0x00,\n    // 1.0 rate\n    0x01, 0x00,\n    // 1.0 volume\n    0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,\n    // transformation: unity matrix\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // pre_defined\n    0xff, 0xff, 0xff, 0xff // next_track_ID\n    ]);\n    return MP4.box(MP4.types.mvhd, bytes);\n  }\n  static sdtp(track) {\n    const samples = track.samples || [];\n    const bytes = new Uint8Array(4 + samples.length);\n    let i;\n    let flags;\n    // leave the full box header (4 bytes) all zero\n    // write the sample table\n    for (i = 0; i < samples.length; i++) {\n      flags = samples[i].flags;\n      bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;\n    }\n    return MP4.box(MP4.types.sdtp, bytes);\n  }\n  static stbl(track) {\n    return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));\n  }\n  static avc1(track) {\n    let sps = [];\n    let pps = [];\n    let i;\n    let data;\n    let len;\n    // assemble the SPSs\n\n    for (i = 0; i < track.sps.length; i++) {\n      data = track.sps[i];\n      len = data.byteLength;\n      sps.push(len >>> 8 & 0xff);\n      sps.push(len & 0xff);\n\n      // SPS\n      sps = sps.concat(Array.prototype.slice.call(data));\n    }\n\n    // assemble the PPSs\n    for (i = 0; i < track.pps.length; i++) {\n      data = track.pps[i];\n      len = data.byteLength;\n      pps.push(len >>> 8 & 0xff);\n      pps.push(len & 0xff);\n      pps = pps.concat(Array.prototype.slice.call(data));\n    }\n    const avcc = MP4.box(MP4.types.avcC, new Uint8Array([0x01,\n    // version\n    sps[3],\n    // profile\n    sps[4],\n    // profile compat\n    sps[5],\n    // level\n    0xfc | 3,\n    // lengthSizeMinusOne, hard-coded to 4 bytes\n    0xe0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets\n    ].concat(sps).concat([track.pps.length // numOfPictureParameterSets\n    ]).concat(pps))); // \"PPS\"\n    const width = track.width;\n    const height = track.height;\n    const hSpacing = track.pixelRatio[0];\n    const vSpacing = track.pixelRatio[1];\n    return MP4.box(MP4.types.avc1, new Uint8Array([0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x01,\n    // data_reference_index\n    0x00, 0x00,\n    // pre_defined\n    0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // pre_defined\n    width >> 8 & 0xff, width & 0xff,\n    // width\n    height >> 8 & 0xff, height & 0xff,\n    // height\n    0x00, 0x48, 0x00, 0x00,\n    // horizresolution\n    0x00, 0x48, 0x00, 0x00,\n    // vertresolution\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x01,\n    // frame_count\n    0x12, 0x64, 0x61, 0x69, 0x6c,\n    // dailymotion/hls.js\n    0x79, 0x6d, 0x6f, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x68, 0x6c, 0x73, 0x2e, 0x6a, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // compressorname\n    0x00, 0x18,\n    // depth = 24\n    0x11, 0x11]),\n    // pre_defined = -1\n    avcc, MP4.box(MP4.types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80,\n    // bufferSizeDB\n    0x00, 0x2d, 0xc6, 0xc0,\n    // maxBitrate\n    0x00, 0x2d, 0xc6, 0xc0])),\n    // avgBitrate\n    MP4.box(MP4.types.pasp, new Uint8Array([hSpacing >> 24,\n    // hSpacing\n    hSpacing >> 16 & 0xff, hSpacing >> 8 & 0xff, hSpacing & 0xff, vSpacing >> 24,\n    // vSpacing\n    vSpacing >> 16 & 0xff, vSpacing >> 8 & 0xff, vSpacing & 0xff])));\n  }\n  static esds(track) {\n    const config = track.config;\n    return new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n\n    0x03,\n    // descriptor_type\n    0x19,\n    // length\n\n    0x00, 0x01,\n    // es_id\n\n    0x00,\n    // stream_priority\n\n    0x04,\n    // descriptor_type\n    0x11,\n    // length\n    0x40,\n    // codec : mpeg4_audio\n    0x15,\n    // stream_type\n    0x00, 0x00, 0x00,\n    // buffer_size\n    0x00, 0x00, 0x00, 0x00,\n    // maxBitrate\n    0x00, 0x00, 0x00, 0x00,\n    // avgBitrate\n\n    0x05,\n    // descriptor_type\n    0x02,\n    // length\n    ...config, 0x06, 0x01, 0x02 // GASpecificConfig)); // length + audio config descriptor\n    ]);\n  }\n  static audioStsd(track) {\n    const samplerate = track.samplerate || 0;\n    return new Uint8Array([0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x01,\n    // data_reference_index\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, track.channelCount || 0,\n    // channelcount\n    0x00, 0x10,\n    // sampleSize:16bits\n    0x00, 0x00, 0x00, 0x00,\n    // reserved2\n    samplerate >> 8 & 0xff, samplerate & 0xff,\n    //\n    0x00, 0x00]);\n  }\n  static mp4a(track) {\n    return MP4.box(MP4.types.mp4a, MP4.audioStsd(track), MP4.box(MP4.types.esds, MP4.esds(track)));\n  }\n  static mp3(track) {\n    return MP4.box(MP4.types['.mp3'], MP4.audioStsd(track));\n  }\n  static ac3(track) {\n    return MP4.box(MP4.types['ac-3'], MP4.audioStsd(track), MP4.box(MP4.types.dac3, track.config));\n  }\n  static stsd(track) {\n    const {\n      segmentCodec\n    } = track;\n    if (track.type === 'audio') {\n      if (segmentCodec === 'aac') {\n        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));\n      }\n      if (segmentCodec === 'ac3' && track.config) {\n        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.ac3(track));\n      }\n      if (segmentCodec === 'mp3' && track.codec === 'mp3') {\n        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));\n      }\n    } else {\n      if (track.pps && track.sps) {\n        if (segmentCodec === 'avc') {\n          return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));\n        }\n        if (segmentCodec === 'hevc' && track.vps) {\n          return MP4.box(MP4.types.stsd, MP4.STSD, MP4.hvc1(track));\n        }\n      } else {\n        throw new Error(`video track missing pps or sps`);\n      }\n    }\n    throw new Error(`unsupported ${track.type} segment codec (${segmentCodec}/${track.codec})`);\n  }\n  static tkhd(track) {\n    const id = track.id;\n    const duration = (track.duration || 0) * (track.timescale || 0);\n    const width = track.width || 0;\n    const height = track.height || 0;\n    const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n    const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n    return MP4.box(MP4.types.tkhd, new Uint8Array([0x01,\n    // version 1\n    0x00, 0x00, 0x07,\n    // flags\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,\n    // creation_time\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,\n    // modification_time\n    id >> 24 & 0xff, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff,\n    // track_ID\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00,\n    // layer\n    0x00, 0x00,\n    // alternate_group\n    0x00, 0x00,\n    // non-audio track volume\n    0x00, 0x00,\n    // reserved\n    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,\n    // transformation: unity matrix\n    width >> 8 & 0xff, width & 0xff, 0x00, 0x00,\n    // width\n    height >> 8 & 0xff, height & 0xff, 0x00, 0x00 // height\n    ]));\n  }\n  static traf(track, baseMediaDecodeTime) {\n    const sampleDependencyTable = MP4.sdtp(track);\n    const id = track.id;\n    const upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));\n    const lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));\n    return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    id >> 24, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff // track_ID\n    ])), MP4.box(MP4.types.tfdt, new Uint8Array([0x01,\n    // version 1\n    0x00, 0x00, 0x00,\n    // flags\n    upperWordBaseMediaDecodeTime >> 24, upperWordBaseMediaDecodeTime >> 16 & 0xff, upperWordBaseMediaDecodeTime >> 8 & 0xff, upperWordBaseMediaDecodeTime & 0xff, lowerWordBaseMediaDecodeTime >> 24, lowerWordBaseMediaDecodeTime >> 16 & 0xff, lowerWordBaseMediaDecodeTime >> 8 & 0xff, lowerWordBaseMediaDecodeTime & 0xff])), MP4.trun(track, sampleDependencyTable.length + 16 +\n    // tfhd\n    20 +\n    // tfdt\n    8 +\n    // traf header\n    16 +\n    // mfhd\n    8 +\n    // moof header\n    8),\n    // mdat header\n    sampleDependencyTable);\n  }\n\n  /**\n   * Generate a track box.\n   * @param track a track definition\n   */\n  static trak(track) {\n    track.duration = track.duration || 0xffffffff;\n    return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));\n  }\n  static trex(track) {\n    const id = track.id;\n    return MP4.box(MP4.types.trex, new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    id >> 24, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff,\n    // track_ID\n    0x00, 0x00, 0x00, 0x01,\n    // default_sample_description_index\n    0x00, 0x00, 0x00, 0x00,\n    // default_sample_duration\n    0x00, 0x00, 0x00, 0x00,\n    // default_sample_size\n    0x00, 0x01, 0x00, 0x01 // default_sample_flags\n    ]));\n  }\n  static trun(track, offset) {\n    const samples = track.samples || [];\n    const len = samples.length;\n    const arraylen = 12 + 16 * len;\n    const array = new Uint8Array(arraylen);\n    let i;\n    let sample;\n    let duration;\n    let size;\n    let flags;\n    let cts;\n    offset += 8 + arraylen;\n    array.set([track.type === 'video' ? 0x01 : 0x00,\n    // version 1 for video with signed-int sample_composition_time_offset\n    0x00, 0x0f, 0x01,\n    // flags\n    len >>> 24 & 0xff, len >>> 16 & 0xff, len >>> 8 & 0xff, len & 0xff,\n    // sample_count\n    offset >>> 24 & 0xff, offset >>> 16 & 0xff, offset >>> 8 & 0xff, offset & 0xff // data_offset\n    ], 0);\n    for (i = 0; i < len; i++) {\n      sample = samples[i];\n      duration = sample.duration;\n      size = sample.size;\n      flags = sample.flags;\n      cts = sample.cts;\n      array.set([duration >>> 24 & 0xff, duration >>> 16 & 0xff, duration >>> 8 & 0xff, duration & 0xff,\n      // sample_duration\n      size >>> 24 & 0xff, size >>> 16 & 0xff, size >>> 8 & 0xff, size & 0xff,\n      // sample_size\n      flags.isLeading << 2 | flags.dependsOn, flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync, flags.degradPrio & 0xf0 << 8, flags.degradPrio & 0x0f,\n      // sample_flags\n      cts >>> 24 & 0xff, cts >>> 16 & 0xff, cts >>> 8 & 0xff, cts & 0xff // sample_composition_time_offset\n      ], 12 + 16 * i);\n    }\n    return MP4.box(MP4.types.trun, array);\n  }\n  static initSegment(tracks) {\n    if (!MP4.types) {\n      MP4.init();\n    }\n    const movie = MP4.moov(tracks);\n    const result = appendUint8Array(MP4.FTYP, movie);\n    return result;\n  }\n  static hvc1(track) {\n    const ps = track.params;\n    const units = [track.vps, track.sps, track.pps];\n    const NALuLengthSize = 4;\n    const config = new Uint8Array([0x01, ps.general_profile_space << 6 | (ps.general_tier_flag ? 32 : 0) | ps.general_profile_idc, ps.general_profile_compatibility_flags[0], ps.general_profile_compatibility_flags[1], ps.general_profile_compatibility_flags[2], ps.general_profile_compatibility_flags[3], ps.general_constraint_indicator_flags[0], ps.general_constraint_indicator_flags[1], ps.general_constraint_indicator_flags[2], ps.general_constraint_indicator_flags[3], ps.general_constraint_indicator_flags[4], ps.general_constraint_indicator_flags[5], ps.general_level_idc, 240 | ps.min_spatial_segmentation_idc >> 8, 255 & ps.min_spatial_segmentation_idc, 252 | ps.parallelismType, 252 | ps.chroma_format_idc, 248 | ps.bit_depth_luma_minus8, 248 | ps.bit_depth_chroma_minus8, 0x00, parseInt(ps.frame_rate.fps), NALuLengthSize - 1 | ps.temporal_id_nested << 2 | ps.num_temporal_layers << 3 | (ps.frame_rate.fixed ? 64 : 0), units.length]);\n\n    // compute hvcC size in bytes\n    let length = config.length;\n    for (let i = 0; i < units.length; i += 1) {\n      length += 3;\n      for (let j = 0; j < units[i].length; j += 1) {\n        length += 2 + units[i][j].length;\n      }\n    }\n    const hvcC = new Uint8Array(length);\n    hvcC.set(config, 0);\n    length = config.length;\n    // append parameter set units: one vps, one or more sps and pps\n    const iMax = units.length - 1;\n    for (let i = 0; i < units.length; i += 1) {\n      hvcC.set(new Uint8Array([32 + i | (i === iMax ? 128 : 0), 0x00, units[i].length]), length);\n      length += 3;\n      for (let j = 0; j < units[i].length; j += 1) {\n        hvcC.set(new Uint8Array([units[i][j].length >> 8, units[i][j].length & 255]), length);\n        length += 2;\n        hvcC.set(units[i][j], length);\n        length += units[i][j].length;\n      }\n    }\n    const hvcc = MP4.box(MP4.types.hvcC, hvcC);\n    const width = track.width;\n    const height = track.height;\n    const hSpacing = track.pixelRatio[0];\n    const vSpacing = track.pixelRatio[1];\n    return MP4.box(MP4.types.hvc1, new Uint8Array([0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x01,\n    // data_reference_index\n    0x00, 0x00,\n    // pre_defined\n    0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // pre_defined\n    width >> 8 & 0xff, width & 0xff,\n    // width\n    height >> 8 & 0xff, height & 0xff,\n    // height\n    0x00, 0x48, 0x00, 0x00,\n    // horizresolution\n    0x00, 0x48, 0x00, 0x00,\n    // vertresolution\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x01,\n    // frame_count\n    0x12, 0x64, 0x61, 0x69, 0x6c,\n    // dailymotion/hls.js\n    0x79, 0x6d, 0x6f, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x68, 0x6c, 0x73, 0x2e, 0x6a, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // compressorname\n    0x00, 0x18,\n    // depth = 24\n    0x11, 0x11]),\n    // pre_defined = -1\n    hvcc, MP4.box(MP4.types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80,\n    // bufferSizeDB\n    0x00, 0x2d, 0xc6, 0xc0,\n    // maxBitrate\n    0x00, 0x2d, 0xc6, 0xc0])),\n    // avgBitrate\n    MP4.box(MP4.types.pasp, new Uint8Array([hSpacing >> 24,\n    // hSpacing\n    hSpacing >> 16 & 0xff, hSpacing >> 8 & 0xff, hSpacing & 0xff, vSpacing >> 24,\n    // vSpacing\n    vSpacing >> 16 & 0xff, vSpacing >> 8 & 0xff, vSpacing & 0xff])));\n  }\n}\nMP4.types = void 0;\nMP4.HDLR_TYPES = void 0;\nMP4.STTS = void 0;\nMP4.STSC = void 0;\nMP4.STCO = void 0;\nMP4.STSZ = void 0;\nMP4.VMHD = void 0;\nMP4.SMHD = void 0;\nMP4.STSD = void 0;\nMP4.FTYP = void 0;\nMP4.DINF = void 0;\n\nconst MPEG_TS_CLOCK_FREQ_HZ = 90000;\nfunction toTimescaleFromBase(baseTime, destScale, srcBase = 1, round = false) {\n  const result = baseTime * destScale * srcBase; // equivalent to `(value * scale) / (1 / base)`\n  return round ? Math.round(result) : result;\n}\nfunction toTimescaleFromScale(baseTime, destScale, srcScale = 1, round = false) {\n  return toTimescaleFromBase(baseTime, destScale, 1 / srcScale, round);\n}\nfunction toMsFromMpegTsClock(baseTime, round = false) {\n  return toTimescaleFromBase(baseTime, 1000, 1 / MPEG_TS_CLOCK_FREQ_HZ, round);\n}\nfunction toMpegTsClockFromTimescale(baseTime, srcScale = 1) {\n  return toTimescaleFromBase(baseTime, MPEG_TS_CLOCK_FREQ_HZ, 1 / srcScale);\n}\n\nconst MAX_SILENT_FRAME_DURATION = 10 * 1000; // 10 seconds\nconst AAC_SAMPLES_PER_FRAME = 1024;\nconst MPEG_AUDIO_SAMPLE_PER_FRAME = 1152;\nconst AC3_SAMPLES_PER_FRAME = 1536;\nlet chromeVersion = null;\nlet safariWebkitVersion = null;\nfunction createMp4Sample(isKeyframe, duration, size, cts) {\n  return {\n    duration,\n    size,\n    cts,\n    flags: {\n      isLeading: 0,\n      isDependedOn: 0,\n      hasRedundancy: 0,\n      degradPrio: 0,\n      dependsOn: isKeyframe ? 2 : 1,\n      isNonSync: isKeyframe ? 0 : 1\n    }\n  };\n}\nclass MP4Remuxer extends Logger {\n  constructor(observer, config, typeSupported, logger) {\n    super('mp4-remuxer', logger);\n    this.observer = void 0;\n    this.config = void 0;\n    this.typeSupported = void 0;\n    this.ISGenerated = false;\n    this._initPTS = null;\n    this._initDTS = null;\n    this.nextVideoTs = null;\n    this.nextAudioTs = null;\n    this.videoSampleDuration = null;\n    this.isAudioContiguous = false;\n    this.isVideoContiguous = false;\n    this.videoTrackConfig = void 0;\n    this.observer = observer;\n    this.config = config;\n    this.typeSupported = typeSupported;\n    this.ISGenerated = false;\n    if (chromeVersion === null) {\n      const userAgent = navigator.userAgent || '';\n      const result = userAgent.match(/Chrome\\/(\\d+)/i);\n      chromeVersion = result ? parseInt(result[1]) : 0;\n    }\n    if (safariWebkitVersion === null) {\n      const result = navigator.userAgent.match(/Safari\\/(\\d+)/i);\n      safariWebkitVersion = result ? parseInt(result[1]) : 0;\n    }\n  }\n  destroy() {\n    // @ts-ignore\n    this.config = this.videoTrackConfig = this._initPTS = this._initDTS = null;\n  }\n  resetTimeStamp(defaultTimeStamp) {\n    this.log('initPTS & initDTS reset');\n    this._initPTS = this._initDTS = defaultTimeStamp;\n  }\n  resetNextTimestamp() {\n    this.log('reset next timestamp');\n    this.isVideoContiguous = false;\n    this.isAudioContiguous = false;\n  }\n  resetInitSegment() {\n    this.log('ISGenerated flag reset');\n    this.ISGenerated = false;\n    this.videoTrackConfig = undefined;\n  }\n  getVideoStartPts(videoSamples) {\n    // Get the minimum PTS value relative to the first sample's PTS, normalized for 33-bit wrapping\n    let rolloverDetected = false;\n    const firstPts = videoSamples[0].pts;\n    const startPTS = videoSamples.reduce((minPTS, sample) => {\n      let pts = sample.pts;\n      let delta = pts - minPTS;\n      if (delta < -4294967296) {\n        // 2^32, see PTSNormalize for reasoning, but we're hitting a rollover here, and we don't want that to impact the timeOffset calculation\n        rolloverDetected = true;\n        pts = normalizePts(pts, firstPts);\n        delta = pts - minPTS;\n      }\n      if (delta > 0) {\n        return minPTS;\n      }\n      return pts;\n    }, firstPts);\n    if (rolloverDetected) {\n      this.debug('PTS rollover detected');\n    }\n    return startPTS;\n  }\n  remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, flush, playlistType) {\n    let video;\n    let audio;\n    let initSegment;\n    let text;\n    let id3;\n    let independent;\n    let audioTimeOffset = timeOffset;\n    let videoTimeOffset = timeOffset;\n\n    // If we're remuxing audio and video progressively, wait until we've received enough samples for each track before proceeding.\n    // This is done to synchronize the audio and video streams. We know if the current segment will have samples if the \"pid\"\n    // parameter is greater than -1. The pid is set when the PMT is parsed, which contains the tracks list.\n    // However, if the initSegment has already been generated, or we've reached the end of a segment (flush),\n    // then we can remux one track without waiting for the other.\n    const hasAudio = audioTrack.pid > -1;\n    const hasVideo = videoTrack.pid > -1;\n    const length = videoTrack.samples.length;\n    const enoughAudioSamples = audioTrack.samples.length > 0;\n    const enoughVideoSamples = flush && length > 0 || length > 1;\n    const canRemuxAvc = (!hasAudio || enoughAudioSamples) && (!hasVideo || enoughVideoSamples) || this.ISGenerated || flush;\n    if (canRemuxAvc) {\n      if (this.ISGenerated) {\n        var _videoTrack$pixelRati, _config$pixelRatio, _videoTrack$pixelRati2, _config$pixelRatio2;\n        const config = this.videoTrackConfig;\n        if (config && (videoTrack.width !== config.width || videoTrack.height !== config.height || ((_videoTrack$pixelRati = videoTrack.pixelRatio) == null ? void 0 : _videoTrack$pixelRati[0]) !== ((_config$pixelRatio = config.pixelRatio) == null ? void 0 : _config$pixelRatio[0]) || ((_videoTrack$pixelRati2 = videoTrack.pixelRatio) == null ? void 0 : _videoTrack$pixelRati2[1]) !== ((_config$pixelRatio2 = config.pixelRatio) == null ? void 0 : _config$pixelRatio2[1])) || !config && enoughVideoSamples || this.nextAudioTs === null && enoughAudioSamples) {\n          this.resetInitSegment();\n        }\n      }\n      if (!this.ISGenerated) {\n        initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);\n      }\n      const isVideoContiguous = this.isVideoContiguous;\n      let firstKeyFrameIndex = -1;\n      let firstKeyFramePTS;\n      if (enoughVideoSamples) {\n        firstKeyFrameIndex = findKeyframeIndex(videoTrack.samples);\n        if (!isVideoContiguous && this.config.forceKeyFrameOnDiscontinuity) {\n          independent = true;\n          if (firstKeyFrameIndex > 0) {\n            this.warn(`Dropped ${firstKeyFrameIndex} out of ${length} video samples due to a missing keyframe`);\n            const startPTS = this.getVideoStartPts(videoTrack.samples);\n            videoTrack.samples = videoTrack.samples.slice(firstKeyFrameIndex);\n            videoTrack.dropped += firstKeyFrameIndex;\n            videoTimeOffset += (videoTrack.samples[0].pts - startPTS) / videoTrack.inputTimeScale;\n            firstKeyFramePTS = videoTimeOffset;\n          } else if (firstKeyFrameIndex === -1) {\n            this.warn(`No keyframe found out of ${length} video samples`);\n            independent = false;\n          }\n        }\n      }\n      if (this.ISGenerated) {\n        if (enoughAudioSamples && enoughVideoSamples) {\n          // timeOffset is expected to be the offset of the first timestamp of this fragment (first DTS)\n          // if first audio DTS is not aligned with first video DTS then we need to take that into account\n          // when providing timeOffset to remuxAudio / remuxVideo. if we don't do that, there might be a permanent / small\n          // drift between audio and video streams\n          const startPTS = this.getVideoStartPts(videoTrack.samples);\n          const tsDelta = normalizePts(audioTrack.samples[0].pts, startPTS) - startPTS;\n          const audiovideoTimestampDelta = tsDelta / videoTrack.inputTimeScale;\n          audioTimeOffset += Math.max(0, audiovideoTimestampDelta);\n          videoTimeOffset += Math.max(0, -audiovideoTimestampDelta);\n        }\n\n        // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is calculated in remuxAudio.\n        if (enoughAudioSamples) {\n          // if initSegment was generated without audio samples, regenerate it again\n          if (!audioTrack.samplerate) {\n            this.warn('regenerate InitSegment as audio detected');\n            initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);\n          }\n          audio = this.remuxAudio(audioTrack, audioTimeOffset, this.isAudioContiguous, accurateTimeOffset, hasVideo || enoughVideoSamples || playlistType === PlaylistLevelType.AUDIO ? videoTimeOffset : undefined);\n          if (enoughVideoSamples) {\n            const audioTrackLength = audio ? audio.endPTS - audio.startPTS : 0;\n            // if initSegment was generated without video samples, regenerate it again\n            if (!videoTrack.inputTimeScale) {\n              this.warn('regenerate InitSegment as video detected');\n              initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);\n            }\n            video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, audioTrackLength);\n          }\n        } else if (enoughVideoSamples) {\n          video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, 0);\n        }\n        if (video) {\n          video.firstKeyFrame = firstKeyFrameIndex;\n          video.independent = firstKeyFrameIndex !== -1;\n          video.firstKeyFramePTS = firstKeyFramePTS;\n        }\n      }\n    }\n\n    // Allow ID3 and text to remux, even if more audio/video samples are required\n    if (this.ISGenerated && this._initPTS && this._initDTS) {\n      if (id3Track.samples.length) {\n        id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, this._initPTS, this._initDTS);\n      }\n      if (textTrack.samples.length) {\n        text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, this._initPTS);\n      }\n    }\n    return {\n      audio,\n      video,\n      initSegment,\n      independent,\n      text,\n      id3\n    };\n  }\n  generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset) {\n    const audioSamples = audioTrack.samples;\n    const videoSamples = videoTrack.samples;\n    const typeSupported = this.typeSupported;\n    const tracks = {};\n    const _initPTS = this._initPTS;\n    let computePTSDTS = !_initPTS || accurateTimeOffset;\n    let container = 'audio/mp4';\n    let initPTS;\n    let initDTS;\n    let timescale;\n    let trackId;\n    if (computePTSDTS) {\n      initPTS = initDTS = Infinity;\n    }\n    if (audioTrack.config && audioSamples.length) {\n      // let's use audio sampling rate as MP4 time scale.\n      // rationale is that there is a integer nb of audio frames per audio sample (1024 for AAC)\n      // using audio sampling rate here helps having an integer MP4 frame duration\n      // this avoids potential rounding issue and AV sync issue\n      audioTrack.timescale = audioTrack.samplerate;\n      switch (audioTrack.segmentCodec) {\n        case 'mp3':\n          if (typeSupported.mpeg) {\n            // Chrome and Safari\n            container = 'audio/mpeg';\n            audioTrack.codec = '';\n          } else if (typeSupported.mp3) {\n            // Firefox\n            audioTrack.codec = 'mp3';\n          }\n          break;\n        case 'ac3':\n          audioTrack.codec = 'ac-3';\n          break;\n      }\n      tracks.audio = {\n        id: 'audio',\n        container: container,\n        codec: audioTrack.codec,\n        initSegment: audioTrack.segmentCodec === 'mp3' && typeSupported.mpeg ? new Uint8Array(0) : MP4.initSegment([audioTrack]),\n        metadata: {\n          channelCount: audioTrack.channelCount\n        }\n      };\n      if (computePTSDTS) {\n        trackId = audioTrack.id;\n        timescale = audioTrack.inputTimeScale;\n        if (!_initPTS || timescale !== _initPTS.timescale) {\n          // remember first PTS of this demuxing context. for audio, PTS = DTS\n          initPTS = initDTS = audioSamples[0].pts - Math.round(timescale * timeOffset);\n        } else {\n          computePTSDTS = false;\n        }\n      }\n    }\n    if (videoTrack.sps && videoTrack.pps && videoSamples.length) {\n      // let's use input time scale as MP4 video timescale\n      // we use input time scale straight away to avoid rounding issues on frame duration / cts computation\n      videoTrack.timescale = videoTrack.inputTimeScale;\n      tracks.video = {\n        id: 'main',\n        container: 'video/mp4',\n        codec: videoTrack.codec,\n        initSegment: MP4.initSegment([videoTrack]),\n        metadata: {\n          width: videoTrack.width,\n          height: videoTrack.height\n        }\n      };\n      if (computePTSDTS) {\n        trackId = videoTrack.id;\n        timescale = videoTrack.inputTimeScale;\n        if (!_initPTS || timescale !== _initPTS.timescale) {\n          const startPTS = this.getVideoStartPts(videoSamples);\n          const startOffset = Math.round(timescale * timeOffset);\n          initDTS = Math.min(initDTS, normalizePts(videoSamples[0].dts, startPTS) - startOffset);\n          initPTS = Math.min(initPTS, startPTS - startOffset);\n        } else {\n          computePTSDTS = false;\n        }\n      }\n      this.videoTrackConfig = {\n        width: videoTrack.width,\n        height: videoTrack.height,\n        pixelRatio: videoTrack.pixelRatio\n      };\n    }\n    if (Object.keys(tracks).length) {\n      this.ISGenerated = true;\n      if (computePTSDTS) {\n        this._initPTS = {\n          baseTime: initPTS,\n          timescale: timescale\n        };\n        this._initDTS = {\n          baseTime: initDTS,\n          timescale: timescale\n        };\n      } else {\n        initPTS = timescale = undefined;\n      }\n      return {\n        tracks,\n        initPTS,\n        timescale,\n        trackId\n      };\n    }\n  }\n  remuxVideo(track, timeOffset, contiguous, audioTrackLength) {\n    const timeScale = track.inputTimeScale;\n    const inputSamples = track.samples;\n    const outputSamples = [];\n    const nbSamples = inputSamples.length;\n    const initPTS = this._initPTS;\n    const initTime = initPTS.baseTime * timeScale / initPTS.timescale;\n    let nextVideoTs = this.nextVideoTs;\n    let offset = 8;\n    let mp4SampleDuration = this.videoSampleDuration;\n    let firstDTS;\n    let lastDTS;\n    let minPTS = Number.POSITIVE_INFINITY;\n    let maxPTS = Number.NEGATIVE_INFINITY;\n    let sortSamples = false;\n\n    // if parsed fragment is contiguous with last one, let's use last DTS value as reference\n    if (!contiguous || nextVideoTs === null) {\n      const pts = initTime + timeOffset * timeScale;\n      const cts = inputSamples[0].pts - normalizePts(inputSamples[0].dts, inputSamples[0].pts);\n      if (chromeVersion && nextVideoTs !== null && Math.abs(pts - cts - (nextVideoTs + initTime)) < 15000) {\n        // treat as contigous to adjust samples that would otherwise produce video buffer gaps in Chrome\n        contiguous = true;\n      } else {\n        // if not contiguous, let's use target timeOffset\n        nextVideoTs = pts - cts - initTime;\n      }\n    }\n\n    // PTS is coded on 33bits, and can loop from -2^32 to 2^32\n    // PTSNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value\n    const nextVideoPts = nextVideoTs + initTime;\n    for (let i = 0; i < nbSamples; i++) {\n      const sample = inputSamples[i];\n      sample.pts = normalizePts(sample.pts, nextVideoPts);\n      sample.dts = normalizePts(sample.dts, nextVideoPts);\n      if (sample.dts < inputSamples[i > 0 ? i - 1 : i].dts) {\n        sortSamples = true;\n      }\n    }\n\n    // sort video samples by DTS then PTS then demux id order\n    if (sortSamples) {\n      inputSamples.sort(function (a, b) {\n        const deltadts = a.dts - b.dts;\n        const deltapts = a.pts - b.pts;\n        return deltadts || deltapts;\n      });\n    }\n\n    // Get first/last DTS\n    firstDTS = inputSamples[0].dts;\n    lastDTS = inputSamples[inputSamples.length - 1].dts;\n\n    // Sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS\n    // set this constant duration as being the avg delta between consecutive DTS.\n    const inputDuration = lastDTS - firstDTS;\n    const averageSampleDuration = inputDuration ? Math.round(inputDuration / (nbSamples - 1)) : mp4SampleDuration || track.inputTimeScale / 30;\n\n    // if fragment are contiguous, detect hole/overlapping between fragments\n    if (contiguous) {\n      // check timestamp continuity across consecutive fragments (this is to remove inter-fragment gap/hole)\n      const delta = firstDTS - nextVideoPts;\n      const foundHole = delta > averageSampleDuration;\n      const foundOverlap = delta < -1;\n      if (foundHole || foundOverlap) {\n        if (foundHole) {\n          this.warn(`${(track.segmentCodec || '').toUpperCase()}: ${toMsFromMpegTsClock(delta, true)} ms (${delta}dts) hole between fragments detected at ${timeOffset.toFixed(3)}`);\n        } else {\n          this.warn(`${(track.segmentCodec || '').toUpperCase()}: ${toMsFromMpegTsClock(-delta, true)} ms (${delta}dts) overlapping between fragments detected at ${timeOffset.toFixed(3)}`);\n        }\n        if (!foundOverlap || nextVideoPts >= inputSamples[0].pts || chromeVersion) {\n          firstDTS = nextVideoPts;\n          const firstPTS = inputSamples[0].pts - delta;\n          if (foundHole) {\n            inputSamples[0].dts = firstDTS;\n            inputSamples[0].pts = firstPTS;\n          } else {\n            let isPTSOrderRetained = true;\n            for (let i = 0; i < inputSamples.length; i++) {\n              if (inputSamples[i].dts > firstPTS && isPTSOrderRetained) {\n                break;\n              }\n              const prevPTS = inputSamples[i].pts;\n              inputSamples[i].dts -= delta;\n              inputSamples[i].pts -= delta;\n\n              // check to see if this sample's PTS order has changed\n              // relative to the next one\n              if (i < inputSamples.length - 1) {\n                const nextSamplePTS = inputSamples[i + 1].pts;\n                const currentSamplePTS = inputSamples[i].pts;\n                const currentOrder = nextSamplePTS <= currentSamplePTS;\n                const prevOrder = nextSamplePTS <= prevPTS;\n                isPTSOrderRetained = currentOrder == prevOrder;\n              }\n            }\n          }\n          this.log(`Video: Initial PTS/DTS adjusted: ${toMsFromMpegTsClock(firstPTS, true)}/${toMsFromMpegTsClock(firstDTS, true)}, delta: ${toMsFromMpegTsClock(delta, true)} ms`);\n        }\n      }\n    }\n    firstDTS = Math.max(0, firstDTS);\n    let nbNalu = 0;\n    let naluLen = 0;\n    let dtsStep = firstDTS;\n    for (let i = 0; i < nbSamples; i++) {\n      // compute total/avc sample length and nb of NAL units\n      const sample = inputSamples[i];\n      const units = sample.units;\n      const nbUnits = units.length;\n      let sampleLen = 0;\n      for (let j = 0; j < nbUnits; j++) {\n        sampleLen += units[j].data.length;\n      }\n      naluLen += sampleLen;\n      nbNalu += nbUnits;\n      sample.length = sampleLen;\n\n      // ensure sample monotonic DTS\n      if (sample.dts < dtsStep) {\n        sample.dts = dtsStep;\n        dtsStep += averageSampleDuration / 4 | 0 || 1;\n      } else {\n        dtsStep = sample.dts;\n      }\n      minPTS = Math.min(sample.pts, minPTS);\n      maxPTS = Math.max(sample.pts, maxPTS);\n    }\n    lastDTS = inputSamples[nbSamples - 1].dts;\n\n    /* concatenate the video data and construct the mdat in place\n      (need 8 more bytes to fill length and mpdat type) */\n    const mdatSize = naluLen + 4 * nbNalu + 8;\n    let mdat;\n    try {\n      mdat = new Uint8Array(mdatSize);\n    } catch (err) {\n      this.observer.emit(Events.ERROR, Events.ERROR, {\n        type: ErrorTypes.MUX_ERROR,\n        details: ErrorDetails.REMUX_ALLOC_ERROR,\n        fatal: false,\n        error: err,\n        bytes: mdatSize,\n        reason: `fail allocating video mdat ${mdatSize}`\n      });\n      return;\n    }\n    const view = new DataView(mdat.buffer);\n    view.setUint32(0, mdatSize);\n    mdat.set(MP4.types.mdat, 4);\n    let stretchedLastFrame = false;\n    let minDtsDelta = Number.POSITIVE_INFINITY;\n    let minPtsDelta = Number.POSITIVE_INFINITY;\n    let maxDtsDelta = Number.NEGATIVE_INFINITY;\n    let maxPtsDelta = Number.NEGATIVE_INFINITY;\n    for (let i = 0; i < nbSamples; i++) {\n      const VideoSample = inputSamples[i];\n      const VideoSampleUnits = VideoSample.units;\n      let mp4SampleLength = 0;\n      // convert NALU bitstream to MP4 format (prepend NALU with size field)\n      for (let j = 0, nbUnits = VideoSampleUnits.length; j < nbUnits; j++) {\n        const unit = VideoSampleUnits[j];\n        const unitData = unit.data;\n        const unitDataLen = unit.data.byteLength;\n        view.setUint32(offset, unitDataLen);\n        offset += 4;\n        mdat.set(unitData, offset);\n        offset += unitDataLen;\n        mp4SampleLength += 4 + unitDataLen;\n      }\n\n      // expected sample duration is the Decoding Timestamp diff of consecutive samples\n      let ptsDelta;\n      if (i < nbSamples - 1) {\n        mp4SampleDuration = inputSamples[i + 1].dts - VideoSample.dts;\n        ptsDelta = inputSamples[i + 1].pts - VideoSample.pts;\n      } else {\n        const config = this.config;\n        const lastFrameDuration = i > 0 ? VideoSample.dts - inputSamples[i - 1].dts : averageSampleDuration;\n        ptsDelta = i > 0 ? VideoSample.pts - inputSamples[i - 1].pts : averageSampleDuration;\n        if (config.stretchShortVideoTrack && this.nextAudioTs !== null) {\n          // In some cases, a segment's audio track duration may exceed the video track duration.\n          // Since we've already remuxed audio, and we know how long the audio track is, we look to\n          // see if the delta to the next segment is longer than maxBufferHole.\n          // If so, playback would potentially get stuck, so we artificially inflate\n          // the duration of the last frame to minimize any potential gap between segments.\n          const gapTolerance = Math.floor(config.maxBufferHole * timeScale);\n          const deltaToFrameEnd = (audioTrackLength ? minPTS + audioTrackLength * timeScale : this.nextAudioTs + initTime) - VideoSample.pts;\n          if (deltaToFrameEnd > gapTolerance) {\n            // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video\n            // frame overlap. maxBufferHole should be >> lastFrameDuration anyway.\n            mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;\n            if (mp4SampleDuration < 0) {\n              mp4SampleDuration = lastFrameDuration;\n            } else {\n              stretchedLastFrame = true;\n            }\n            this.log(`It is approximately ${deltaToFrameEnd / 90} ms to the next segment; using duration ${mp4SampleDuration / 90} ms for the last video frame.`);\n          } else {\n            mp4SampleDuration = lastFrameDuration;\n          }\n        } else {\n          mp4SampleDuration = lastFrameDuration;\n        }\n      }\n      const compositionTimeOffset = Math.round(VideoSample.pts - VideoSample.dts);\n      minDtsDelta = Math.min(minDtsDelta, mp4SampleDuration);\n      maxDtsDelta = Math.max(maxDtsDelta, mp4SampleDuration);\n      minPtsDelta = Math.min(minPtsDelta, ptsDelta);\n      maxPtsDelta = Math.max(maxPtsDelta, ptsDelta);\n      outputSamples.push(createMp4Sample(VideoSample.key, mp4SampleDuration, mp4SampleLength, compositionTimeOffset));\n    }\n    if (outputSamples.length) {\n      if (chromeVersion) {\n        if (chromeVersion < 70) {\n          // Chrome workaround, mark first sample as being a Random Access Point (keyframe) to avoid sourcebuffer append issue\n          // https://code.google.com/p/chromium/issues/detail?id=229412\n          const flags = outputSamples[0].flags;\n          flags.dependsOn = 2;\n          flags.isNonSync = 0;\n        }\n      } else if (safariWebkitVersion) {\n        // Fix for \"CNN special report, with CC\" in test-streams (Safari browser only)\n        // Ignore DTS when frame durations are irregular. Safari MSE does not handle this leading to gaps.\n        if (maxPtsDelta - minPtsDelta < maxDtsDelta - minDtsDelta && averageSampleDuration / maxDtsDelta < 0.025 && outputSamples[0].cts === 0) {\n          this.warn('Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.');\n          let dts = firstDTS;\n          for (let i = 0, len = outputSamples.length; i < len; i++) {\n            const nextDts = dts + outputSamples[i].duration;\n            const pts = dts + outputSamples[i].cts;\n            if (i < len - 1) {\n              const nextPts = nextDts + outputSamples[i + 1].cts;\n              outputSamples[i].duration = nextPts - pts;\n            } else {\n              outputSamples[i].duration = i ? outputSamples[i - 1].duration : averageSampleDuration;\n            }\n            outputSamples[i].cts = 0;\n            dts = nextDts;\n          }\n        }\n      }\n    }\n    // next AVC/HEVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)\n    mp4SampleDuration = stretchedLastFrame || !mp4SampleDuration ? averageSampleDuration : mp4SampleDuration;\n    const endDTS = lastDTS + mp4SampleDuration;\n    this.nextVideoTs = nextVideoTs = endDTS - initTime;\n    this.videoSampleDuration = mp4SampleDuration;\n    this.isVideoContiguous = true;\n    const moof = MP4.moof(track.sequenceNumber++, firstDTS, _extends(track, {\n      samples: outputSamples\n    }));\n    const type = 'video';\n    const data = {\n      data1: moof,\n      data2: mdat,\n      startPTS: (minPTS - initTime) / timeScale,\n      endPTS: (maxPTS + mp4SampleDuration - initTime) / timeScale,\n      startDTS: (firstDTS - initTime) / timeScale,\n      endDTS: nextVideoTs / timeScale,\n      type,\n      hasAudio: false,\n      hasVideo: true,\n      nb: outputSamples.length,\n      dropped: track.dropped\n    };\n    track.samples = [];\n    track.dropped = 0;\n    return data;\n  }\n  getSamplesPerFrame(track) {\n    switch (track.segmentCodec) {\n      case 'mp3':\n        return MPEG_AUDIO_SAMPLE_PER_FRAME;\n      case 'ac3':\n        return AC3_SAMPLES_PER_FRAME;\n      default:\n        return AAC_SAMPLES_PER_FRAME;\n    }\n  }\n  remuxAudio(track, timeOffset, contiguous, accurateTimeOffset, videoTimeOffset) {\n    const inputTimeScale = track.inputTimeScale;\n    const mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;\n    const scaleFactor = inputTimeScale / mp4timeScale;\n    const mp4SampleDuration = this.getSamplesPerFrame(track);\n    const inputSampleDuration = mp4SampleDuration * scaleFactor;\n    const initPTS = this._initPTS;\n    const rawMPEG = track.segmentCodec === 'mp3' && this.typeSupported.mpeg;\n    const outputSamples = [];\n    const alignedWithVideo = videoTimeOffset !== undefined;\n    let inputSamples = track.samples;\n    let offset = rawMPEG ? 0 : 8;\n    let nextAudioTs = this.nextAudioTs || -1;\n\n    // window.audioSamples ? window.audioSamples.push(inputSamples.map(s => s.pts)) : (window.audioSamples = [inputSamples.map(s => s.pts)]);\n\n    // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),\n    // for sake of clarity:\n    // consecutive fragments are frags with\n    //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR\n    //  - less than 20 audio frames distance\n    // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)\n    // this helps ensuring audio continuity\n    // and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame\n    const initTime = initPTS.baseTime * inputTimeScale / initPTS.timescale;\n    const timeOffsetMpegTS = initTime + timeOffset * inputTimeScale;\n    this.isAudioContiguous = contiguous = contiguous || inputSamples.length && nextAudioTs > 0 && (accurateTimeOffset && Math.abs(timeOffsetMpegTS - (nextAudioTs + initTime)) < 9000 || Math.abs(normalizePts(inputSamples[0].pts, timeOffsetMpegTS) - (nextAudioTs + initTime)) < 20 * inputSampleDuration);\n\n    // compute normalized PTS\n    inputSamples.forEach(function (sample) {\n      sample.pts = normalizePts(sample.pts, timeOffsetMpegTS);\n    });\n    if (!contiguous || nextAudioTs < 0) {\n      // filter out sample with negative PTS that are not playable anyway\n      // if we don't remove these negative samples, they will shift all audio samples forward.\n      // leading to audio overlap between current / next fragment\n      inputSamples = inputSamples.filter(sample => sample.pts >= 0);\n\n      // in case all samples have negative PTS, and have been filtered out, return now\n      if (!inputSamples.length) {\n        return;\n      }\n      if (videoTimeOffset === 0) {\n        // Set the start to match video so that start gaps larger than inputSampleDuration are filled with silence\n        nextAudioTs = 0;\n      } else if (accurateTimeOffset && !alignedWithVideo) {\n        // When not seeking, not live, and LevelDetails.PTSKnown, use fragment start as predicted next audio PTS\n        nextAudioTs = Math.max(0, timeOffsetMpegTS - initTime);\n      } else {\n        // if frags are not contiguous and if we cant trust time offset, let's use first sample PTS as next audio PTS\n        nextAudioTs = inputSamples[0].pts - initTime;\n      }\n    }\n\n    // If the audio track is missing samples, the frames seem to get \"left-shifted\" within the\n    // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.\n    // In an effort to prevent this from happening, we inject frames here where there are gaps.\n    // When possible, we inject a silent frame; when that's not possible, we duplicate the last\n    // frame.\n\n    if (track.segmentCodec === 'aac') {\n      const maxAudioFramesDrift = this.config.maxAudioFramesDrift;\n      for (let i = 0, nextPts = nextAudioTs + initTime; i < inputSamples.length; i++) {\n        // First, let's see how far off this frame is from where we expect it to be\n        const sample = inputSamples[i];\n        const pts = sample.pts;\n        const delta = pts - nextPts;\n        const duration = Math.abs(1000 * delta / inputTimeScale);\n\n        // When remuxing with video, if we're overlapping by more than a duration, drop this sample to stay in sync\n        if (delta <= -maxAudioFramesDrift * inputSampleDuration && alignedWithVideo) {\n          if (i === 0) {\n            this.warn(`Audio frame @ ${(pts / inputTimeScale).toFixed(3)}s overlaps marker by ${Math.round(1000 * delta / inputTimeScale)} ms.`);\n            this.nextAudioTs = nextAudioTs = pts - initTime;\n            nextPts = pts;\n          }\n        } // eslint-disable-line brace-style\n\n        // Insert missing frames if:\n        // 1: We're more than maxAudioFramesDrift frame away\n        // 2: Not more than MAX_SILENT_FRAME_DURATION away\n        // 3: currentTime (aka nextPtsNorm) is not 0\n        // 4: remuxing with video (videoTimeOffset !== undefined)\n        else if (delta >= maxAudioFramesDrift * inputSampleDuration && duration < MAX_SILENT_FRAME_DURATION && alignedWithVideo) {\n          let missing = Math.round(delta / inputSampleDuration);\n          // Adjust nextPts so that silent samples are aligned with media pts. This will prevent media samples from\n          // later being shifted if nextPts is based on timeOffset and delta is not a multiple of inputSampleDuration.\n          nextPts = pts - missing * inputSampleDuration;\n          while (nextPts < 0 && missing && inputSampleDuration) {\n            missing--;\n            nextPts += inputSampleDuration;\n          }\n          if (i === 0) {\n            this.nextAudioTs = nextAudioTs = nextPts - initTime;\n          }\n          this.warn(`Injecting ${missing} audio frames @ ${((nextPts - initTime) / inputTimeScale).toFixed(3)}s due to ${Math.round(1000 * delta / inputTimeScale)} ms gap.`);\n          for (let j = 0; j < missing; j++) {\n            let fillFrame = AAC.getSilentFrame(track.parsedCodec || track.manifestCodec || track.codec, track.channelCount);\n            if (!fillFrame) {\n              this.log('Unable to get silent frame for given audio codec; duplicating last frame instead.');\n              fillFrame = sample.unit.subarray();\n            }\n            inputSamples.splice(i, 0, {\n              unit: fillFrame,\n              pts: nextPts\n            });\n            nextPts += inputSampleDuration;\n            i++;\n          }\n        }\n        sample.pts = nextPts;\n        nextPts += inputSampleDuration;\n      }\n    }\n    let firstPTS = null;\n    let lastPTS = null;\n    let mdat;\n    let mdatSize = 0;\n    let sampleLength = inputSamples.length;\n    while (sampleLength--) {\n      mdatSize += inputSamples[sampleLength].unit.byteLength;\n    }\n    for (let j = 0, _nbSamples = inputSamples.length; j < _nbSamples; j++) {\n      const audioSample = inputSamples[j];\n      const unit = audioSample.unit;\n      let pts = audioSample.pts;\n      if (lastPTS !== null) {\n        // If we have more than one sample, set the duration of the sample to the \"real\" duration; the PTS diff with\n        // the previous sample\n        const prevSample = outputSamples[j - 1];\n        prevSample.duration = Math.round((pts - lastPTS) / scaleFactor);\n      } else {\n        if (contiguous && track.segmentCodec === 'aac') {\n          // set PTS/DTS to expected PTS/DTS\n          pts = nextAudioTs + initTime;\n        }\n        // remember first PTS of our audioSamples\n        firstPTS = pts;\n        if (mdatSize > 0) {\n          /* concatenate the audio data and construct the mdat in place\n            (need 8 more bytes to fill length and mdat type) */\n          mdatSize += offset;\n          try {\n            mdat = new Uint8Array(mdatSize);\n          } catch (err) {\n            this.observer.emit(Events.ERROR, Events.ERROR, {\n              type: ErrorTypes.MUX_ERROR,\n              details: ErrorDetails.REMUX_ALLOC_ERROR,\n              fatal: false,\n              error: err,\n              bytes: mdatSize,\n              reason: `fail allocating audio mdat ${mdatSize}`\n            });\n            return;\n          }\n          if (!rawMPEG) {\n            const view = new DataView(mdat.buffer);\n            view.setUint32(0, mdatSize);\n            mdat.set(MP4.types.mdat, 4);\n          }\n        } else {\n          // no audio samples\n          return;\n        }\n      }\n      mdat.set(unit, offset);\n      const unitLen = unit.byteLength;\n      offset += unitLen;\n      // Default the sample's duration to the computed mp4SampleDuration, which will either be 1024 for AAC or 1152 for MPEG\n      // In the case that we have 1 sample, this will be the duration. If we have more than one sample, the duration\n      // becomes the PTS diff with the previous sample\n      outputSamples.push(createMp4Sample(true, mp4SampleDuration, unitLen, 0));\n      lastPTS = pts;\n    }\n\n    // We could end up with no audio samples if all input samples were overlapping with the previously remuxed ones\n    const nbSamples = outputSamples.length;\n    if (!nbSamples) {\n      return;\n    }\n\n    // The next audio sample PTS should be equal to last sample PTS + duration\n    const lastSample = outputSamples[outputSamples.length - 1];\n    nextAudioTs = lastPTS - initTime;\n    this.nextAudioTs = nextAudioTs + scaleFactor * lastSample.duration;\n\n    // Set the track samples from inputSamples to outputSamples before remuxing\n    const moof = rawMPEG ? new Uint8Array(0) : MP4.moof(track.sequenceNumber++, firstPTS / scaleFactor, _extends({}, track, {\n      samples: outputSamples\n    }));\n\n    // Clear the track samples. This also clears the samples array in the demuxer, since the reference is shared\n    track.samples = [];\n    const start = (firstPTS - initTime) / inputTimeScale;\n    const end = nextAudioTs / inputTimeScale;\n    const type = 'audio';\n    const audioData = {\n      data1: moof,\n      data2: mdat,\n      startPTS: start,\n      endPTS: end,\n      startDTS: start,\n      endDTS: end,\n      type,\n      hasAudio: true,\n      hasVideo: false,\n      nb: nbSamples\n    };\n    this.isAudioContiguous = true;\n    return audioData;\n  }\n}\nfunction normalizePts(value, reference) {\n  let offset;\n  if (reference === null) {\n    return value;\n  }\n  if (reference < value) {\n    // - 2^33\n    offset = -8589934592;\n  } else {\n    // + 2^33\n    offset = 8589934592;\n  }\n  /* PTS is 33bit (from 0 to 2^33 -1)\n    if diff between value and reference is bigger than half of the amplitude (2^32) then it means that\n    PTS looping occured. fill the gap */\n  while (Math.abs(value - reference) > 4294967296) {\n    value += offset;\n  }\n  return value;\n}\nfunction findKeyframeIndex(samples) {\n  for (let i = 0; i < samples.length; i++) {\n    if (samples[i].key) {\n      return i;\n    }\n  }\n  return -1;\n}\nfunction flushTextTrackMetadataCueSamples(track, timeOffset, initPTS, initDTS) {\n  const length = track.samples.length;\n  if (!length) {\n    return;\n  }\n  const inputTimeScale = track.inputTimeScale;\n  for (let index = 0; index < length; index++) {\n    const sample = track.samples[index];\n    // setting id3 pts, dts to relative time\n    // using this._initPTS and this._initDTS to calculate relative time\n    sample.pts = normalizePts(sample.pts - initPTS.baseTime * inputTimeScale / initPTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;\n    sample.dts = normalizePts(sample.dts - initDTS.baseTime * inputTimeScale / initDTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;\n  }\n  const samples = track.samples;\n  track.samples = [];\n  return {\n    samples\n  };\n}\nfunction flushTextTrackUserdataCueSamples(track, timeOffset, initPTS) {\n  const length = track.samples.length;\n  if (!length) {\n    return;\n  }\n  const inputTimeScale = track.inputTimeScale;\n  for (let index = 0; index < length; index++) {\n    const sample = track.samples[index];\n    // setting text pts, dts to relative time\n    // using this._initPTS and this._initDTS to calculate relative time\n    sample.pts = normalizePts(sample.pts - initPTS.baseTime * inputTimeScale / initPTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;\n  }\n  track.samples.sort((a, b) => a.pts - b.pts);\n  const samples = track.samples;\n  track.samples = [];\n  return {\n    samples\n  };\n}\n\nclass PassThroughRemuxer extends Logger {\n  constructor(observer, config, typeSupported, logger) {\n    super('passthrough-remuxer', logger);\n    this.emitInitSegment = false;\n    this.audioCodec = void 0;\n    this.videoCodec = void 0;\n    this.initData = void 0;\n    this.initPTS = null;\n    this.initTracks = void 0;\n    this.lastEndTime = null;\n    this.isVideoContiguous = false;\n  }\n  destroy() {}\n  resetTimeStamp(defaultInitPTS) {\n    this.lastEndTime = null;\n    const initPTS = this.initPTS;\n    if (initPTS && defaultInitPTS) {\n      if (initPTS.baseTime === defaultInitPTS.baseTime && initPTS.timescale === defaultInitPTS.timescale) {\n        return;\n      }\n    }\n    this.initPTS = defaultInitPTS;\n  }\n  resetNextTimestamp() {\n    this.isVideoContiguous = false;\n    this.lastEndTime = null;\n  }\n  resetInitSegment(initSegment, audioCodec, videoCodec, decryptdata) {\n    this.audioCodec = audioCodec;\n    this.videoCodec = videoCodec;\n    this.generateInitSegment(patchEncyptionData(initSegment, decryptdata));\n    this.emitInitSegment = true;\n  }\n  generateInitSegment(initSegment) {\n    let {\n      audioCodec,\n      videoCodec\n    } = this;\n    if (!(initSegment != null && initSegment.byteLength)) {\n      this.initTracks = undefined;\n      this.initData = undefined;\n      return;\n    }\n    const initData = this.initData = parseInitSegment(initSegment);\n\n    // Get codec from initSegment\n    if (initData.audio) {\n      audioCodec = getParsedTrackCodec(initData.audio, ElementaryStreamTypes.AUDIO, this);\n    }\n    if (initData.video) {\n      videoCodec = getParsedTrackCodec(initData.video, ElementaryStreamTypes.VIDEO, this);\n    }\n    const tracks = {};\n    if (initData.audio && initData.video) {\n      tracks.audiovideo = {\n        container: 'video/mp4',\n        codec: audioCodec + ',' + videoCodec,\n        supplemental: initData.video.supplemental,\n        initSegment,\n        id: 'main'\n      };\n    } else if (initData.audio) {\n      tracks.audio = {\n        container: 'audio/mp4',\n        codec: audioCodec,\n        initSegment,\n        id: 'audio'\n      };\n    } else if (initData.video) {\n      tracks.video = {\n        container: 'video/mp4',\n        codec: videoCodec,\n        supplemental: initData.video.supplemental,\n        initSegment,\n        id: 'main'\n      };\n    } else {\n      this.warn('initSegment does not contain moov or trak boxes.');\n    }\n    this.initTracks = tracks;\n  }\n  remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset) {\n    var _initData, _initData2;\n    let {\n      initPTS,\n      lastEndTime\n    } = this;\n    const result = {\n      audio: undefined,\n      video: undefined,\n      text: textTrack,\n      id3: id3Track,\n      initSegment: undefined\n    };\n\n    // If we haven't yet set a lastEndDTS, or it was reset, set it to the provided timeOffset. We want to use the\n    // lastEndDTS over timeOffset whenever possible; during progressive playback, the media source will not update\n    // the media duration (which is what timeOffset is provided as) before we need to process the next chunk.\n    if (!isFiniteNumber(lastEndTime)) {\n      lastEndTime = this.lastEndTime = timeOffset || 0;\n    }\n\n    // The binary segment data is added to the videoTrack in the mp4demuxer. We don't check to see if the data is only\n    // audio or video (or both); adding it to video was an arbitrary choice.\n    const data = videoTrack.samples;\n    if (!(data != null && data.length)) {\n      return result;\n    }\n    const initSegment = {\n      initPTS: undefined,\n      timescale: undefined,\n      trackId: undefined\n    };\n    let initData = this.initData;\n    if (!((_initData = initData) != null && _initData.length)) {\n      this.generateInitSegment(data);\n      initData = this.initData;\n    }\n    if (!((_initData2 = initData) != null && _initData2.length)) {\n      // We can't remux if the initSegment could not be generated\n      this.warn('Failed to generate initSegment.');\n      return result;\n    }\n    if (this.emitInitSegment) {\n      initSegment.tracks = this.initTracks;\n      this.emitInitSegment = false;\n    }\n    const trackSampleData = getSampleData(data, initData, this);\n    const audioSampleTimestamps = initData.audio ? trackSampleData[initData.audio.id] : null;\n    const videoSampleTimestamps = initData.video ? trackSampleData[initData.video.id] : null;\n    const videoStartTime = toStartEndOrDefault(videoSampleTimestamps, Infinity);\n    const audioStartTime = toStartEndOrDefault(audioSampleTimestamps, Infinity);\n    const videoEndTime = toStartEndOrDefault(videoSampleTimestamps, 0, true);\n    const audioEndTime = toStartEndOrDefault(audioSampleTimestamps, 0, true);\n    let baseOffsetSamples;\n    let decodeTime = timeOffset;\n    let duration = 0;\n    if (audioSampleTimestamps && (!videoSampleTimestamps || !initPTS && audioStartTime < videoStartTime || initPTS && initPTS.trackId === initData.audio.id)) {\n      initSegment.trackId = initData.audio.id;\n      baseOffsetSamples = audioSampleTimestamps;\n      duration = audioEndTime - audioStartTime;\n    } else if (videoSampleTimestamps) {\n      initSegment.trackId = initData.video.id;\n      baseOffsetSamples = videoSampleTimestamps;\n      duration = videoEndTime - videoStartTime;\n    }\n    if (baseOffsetSamples) {\n      const timescale = baseOffsetSamples.timescale;\n      decodeTime = baseOffsetSamples.start / timescale;\n      initSegment.initPTS = baseOffsetSamples.start - timeOffset * timescale;\n      initSegment.timescale = timescale;\n      if (!initPTS) {\n        this.initPTS = initPTS = {\n          baseTime: initSegment.initPTS,\n          timescale,\n          trackId: initSegment.trackId\n        };\n      }\n    }\n    if ((accurateTimeOffset || !initPTS) && (isInvalidInitPts(initPTS, decodeTime, timeOffset, duration) || initSegment.timescale !== initPTS.timescale)) {\n      initSegment.initPTS = decodeTime - timeOffset;\n      initSegment.timescale = 1;\n      if (initPTS && initPTS.timescale === 1) {\n        this.warn(`Adjusting initPTS @${timeOffset} from ${initPTS.baseTime / initPTS.timescale} to ${initSegment.initPTS}`);\n      }\n      this.initPTS = initPTS = {\n        baseTime: initSegment.initPTS,\n        timescale: 1\n      };\n    }\n    const startTime = audioTrack ? decodeTime - initPTS.baseTime / initPTS.timescale : lastEndTime;\n    const endTime = startTime + duration;\n    if (duration > 0) {\n      this.lastEndTime = endTime;\n    } else {\n      this.warn('Duration parsed from mp4 should be greater than zero');\n      this.resetNextTimestamp();\n    }\n    const hasAudio = !!initData.audio;\n    const hasVideo = !!initData.video;\n    let type = '';\n    if (hasAudio) {\n      type += 'audio';\n    }\n    if (hasVideo) {\n      type += 'video';\n    }\n    const track = {\n      data1: data,\n      startPTS: startTime,\n      startDTS: startTime,\n      endPTS: endTime,\n      endDTS: endTime,\n      type,\n      hasAudio,\n      hasVideo,\n      nb: 1,\n      dropped: 0\n    };\n    result.audio = hasAudio && !hasVideo ? track : undefined;\n    result.video = hasVideo ? track : undefined;\n    const videoSampleCount = videoSampleTimestamps == null ? void 0 : videoSampleTimestamps.sampleCount;\n    if (videoSampleCount) {\n      const firstKeyFrame = videoSampleTimestamps.keyFrameIndex;\n      const independent = firstKeyFrame !== -1;\n      track.nb = videoSampleCount;\n      track.dropped = firstKeyFrame === 0 || this.isVideoContiguous ? 0 : independent ? firstKeyFrame : videoSampleCount;\n      track.independent = independent;\n      track.firstKeyFrame = firstKeyFrame;\n      if (independent && videoSampleTimestamps.keyFrameStart) {\n        track.firstKeyFramePTS = (videoSampleTimestamps.keyFrameStart - initPTS.baseTime) / initPTS.timescale;\n      }\n      if (!this.isVideoContiguous) {\n        result.independent = independent;\n      }\n      this.isVideoContiguous || (this.isVideoContiguous = independent);\n      if (track.dropped) {\n        this.warn(`fmp4 does not start with IDR: firstIDR ${firstKeyFrame}/${videoSampleCount} dropped: ${track.dropped} start: ${track.firstKeyFramePTS || 'NA'}`);\n      }\n    }\n    result.initSegment = initSegment;\n    result.id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, initPTS, initPTS);\n    if (textTrack.samples.length) {\n      result.text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, initPTS);\n    }\n    return result;\n  }\n}\nfunction toStartEndOrDefault(trackTimes, defaultValue, end = false) {\n  return (trackTimes == null ? void 0 : trackTimes.start) !== undefined ? (trackTimes.start + (end ? trackTimes.duration : 0)) / trackTimes.timescale : defaultValue;\n}\nfunction isInvalidInitPts(initPTS, startDTS, timeOffset, duration) {\n  if (initPTS === null) {\n    return true;\n  }\n  // InitPTS is invalid when distance from program would be more than segment duration or a minimum of one second\n  const minDuration = Math.max(duration, 1);\n  const startTime = startDTS - initPTS.baseTime / initPTS.timescale;\n  return Math.abs(startTime - timeOffset) > minDuration;\n}\nfunction getParsedTrackCodec(track, type, logger) {\n  const parsedCodec = track == null ? void 0 : track.codec;\n  if (parsedCodec && parsedCodec.length > 4) {\n    return parsedCodec;\n  }\n  if (type === ElementaryStreamTypes.AUDIO) {\n    if (parsedCodec === 'ec-3' || parsedCodec === 'ac-3' || parsedCodec === 'alac') {\n      return parsedCodec;\n    }\n    if (parsedCodec === 'fLaC' || parsedCodec === 'Opus') {\n      // Opting not to get `preferManagedMediaSource` from player config for isSupported() check for simplicity\n      const preferManagedMediaSource = false;\n      return getCodecCompatibleName(parsedCodec, preferManagedMediaSource);\n    }\n    logger.warn(`Unhandled audio codec \"${parsedCodec}\" in mp4 MAP`);\n    return parsedCodec || 'mp4a';\n  }\n  // Provide defaults based on codec type\n  // This allows for some playback of some fmp4 playlists without CODECS defined in manifest\n  logger.warn(`Unhandled video codec \"${parsedCodec}\" in mp4 MAP`);\n  return parsedCodec || 'avc1';\n}\n\nlet now;\n// performance.now() not available on WebWorker, at least on Safari Desktop\ntry {\n  now = self.performance.now.bind(self.performance);\n} catch (err) {\n  now = Date.now;\n}\nconst muxConfig = [{\n  demux: MP4Demuxer,\n  remux: PassThroughRemuxer\n}, {\n  demux: TSDemuxer,\n  remux: MP4Remuxer\n}, {\n  demux: AACDemuxer,\n  remux: MP4Remuxer\n}, {\n  demux: MP3Demuxer,\n  remux: MP4Remuxer\n}];\n{\n  muxConfig.splice(2, 0, {\n    demux: AC3Demuxer,\n    remux: MP4Remuxer\n  });\n}\nclass Transmuxer {\n  constructor(observer, typeSupported, config, vendor, id, logger) {\n    this.asyncResult = false;\n    this.logger = void 0;\n    this.observer = void 0;\n    this.typeSupported = void 0;\n    this.config = void 0;\n    this.id = void 0;\n    this.demuxer = void 0;\n    this.remuxer = void 0;\n    this.decrypter = void 0;\n    this.probe = void 0;\n    this.decryptionPromise = null;\n    this.transmuxConfig = void 0;\n    this.currentTransmuxState = void 0;\n    this.observer = observer;\n    this.typeSupported = typeSupported;\n    this.config = config;\n    this.id = id;\n    this.logger = logger;\n  }\n  configure(transmuxConfig) {\n    this.transmuxConfig = transmuxConfig;\n    if (this.decrypter) {\n      this.decrypter.reset();\n    }\n  }\n  push(data, decryptdata, chunkMeta, state) {\n    const stats = chunkMeta.transmuxing;\n    stats.executeStart = now();\n    let uintData = new Uint8Array(data);\n    const {\n      currentTransmuxState,\n      transmuxConfig\n    } = this;\n    if (state) {\n      this.currentTransmuxState = state;\n    }\n    const {\n      contiguous,\n      discontinuity,\n      trackSwitch,\n      accurateTimeOffset,\n      timeOffset,\n      initSegmentChange\n    } = state || currentTransmuxState;\n    const {\n      audioCodec,\n      videoCodec,\n      defaultInitPts,\n      duration,\n      initSegmentData\n    } = transmuxConfig;\n    const keyData = getEncryptionType(uintData, decryptdata);\n    if (keyData && isFullSegmentEncryption(keyData.method)) {\n      const decrypter = this.getDecrypter();\n      const aesMode = getAesModeFromFullSegmentMethod(keyData.method);\n\n      // Software decryption is synchronous; webCrypto is not\n      if (decrypter.isSync()) {\n        // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached\n        // data is handled in the flush() call\n        let decryptedData = decrypter.softwareDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer, aesMode);\n        // For Low-Latency HLS Parts, decrypt in place, since part parsing is expected on push progress\n        const loadingParts = chunkMeta.part > -1;\n        if (loadingParts) {\n          const _data = decrypter.flush();\n          decryptedData = _data ? _data.buffer : _data;\n        }\n        if (!decryptedData) {\n          stats.executeEnd = now();\n          return emptyResult(chunkMeta);\n        }\n        uintData = new Uint8Array(decryptedData);\n      } else {\n        this.asyncResult = true;\n        this.decryptionPromise = decrypter.webCryptoDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer, aesMode).then(decryptedData => {\n          // Calling push here is important; if flush() is called while this is still resolving, this ensures that\n          // the decrypted data has been transmuxed\n          const result = this.push(decryptedData, null, chunkMeta);\n          this.decryptionPromise = null;\n          return result;\n        });\n        return this.decryptionPromise;\n      }\n    }\n    const resetMuxers = this.needsProbing(discontinuity, trackSwitch);\n    if (resetMuxers) {\n      const error = this.configureTransmuxer(uintData);\n      if (error) {\n        this.logger.warn(`[transmuxer] ${error.message}`);\n        this.observer.emit(Events.ERROR, Events.ERROR, {\n          type: ErrorTypes.MEDIA_ERROR,\n          details: ErrorDetails.FRAG_PARSING_ERROR,\n          fatal: false,\n          error,\n          reason: error.message\n        });\n        stats.executeEnd = now();\n        return emptyResult(chunkMeta);\n      }\n    }\n    if (discontinuity || trackSwitch || initSegmentChange || resetMuxers) {\n      this.resetInitSegment(initSegmentData, audioCodec, videoCodec, duration, decryptdata);\n    }\n    if (discontinuity || initSegmentChange || resetMuxers) {\n      this.resetInitialTimestamp(defaultInitPts);\n    }\n    if (!contiguous) {\n      this.resetContiguity();\n    }\n    const result = this.transmux(uintData, keyData, timeOffset, accurateTimeOffset, chunkMeta);\n    this.asyncResult = isPromise(result);\n    const currentState = this.currentTransmuxState;\n    currentState.contiguous = true;\n    currentState.discontinuity = false;\n    currentState.trackSwitch = false;\n    stats.executeEnd = now();\n    return result;\n  }\n\n  // Due to data caching, flush calls can produce more than one TransmuxerResult (hence the Array type)\n  flush(chunkMeta) {\n    const stats = chunkMeta.transmuxing;\n    stats.executeStart = now();\n    const {\n      decrypter,\n      currentTransmuxState,\n      decryptionPromise\n    } = this;\n    if (decryptionPromise) {\n      this.asyncResult = true;\n      // Upon resolution, the decryption promise calls push() and returns its TransmuxerResult up the stack. Therefore\n      // only flushing is required for async decryption\n      return decryptionPromise.then(() => {\n        return this.flush(chunkMeta);\n      });\n    }\n    const transmuxResults = [];\n    const {\n      timeOffset\n    } = currentTransmuxState;\n    if (decrypter) {\n      // The decrypter may have data cached, which needs to be demuxed. In this case we'll have two TransmuxResults\n      // This happens in the case that we receive only 1 push call for a segment (either for non-progressive downloads,\n      // or for progressive downloads with small segments)\n      const decryptedData = decrypter.flush();\n      if (decryptedData) {\n        // Push always returns a TransmuxerResult if decryptdata is null\n        transmuxResults.push(this.push(decryptedData.buffer, null, chunkMeta));\n      }\n    }\n    const {\n      demuxer,\n      remuxer\n    } = this;\n    if (!demuxer || !remuxer) {\n      // If probing failed, then Hls.js has been given content its not able to handle\n      stats.executeEnd = now();\n      const emptyResults = [emptyResult(chunkMeta)];\n      if (this.asyncResult) {\n        return Promise.resolve(emptyResults);\n      }\n      return emptyResults;\n    }\n    const demuxResultOrPromise = demuxer.flush(timeOffset);\n    if (isPromise(demuxResultOrPromise)) {\n      this.asyncResult = true;\n      // Decrypt final SAMPLE-AES samples\n      return demuxResultOrPromise.then(demuxResult => {\n        this.flushRemux(transmuxResults, demuxResult, chunkMeta);\n        return transmuxResults;\n      });\n    }\n    this.flushRemux(transmuxResults, demuxResultOrPromise, chunkMeta);\n    if (this.asyncResult) {\n      return Promise.resolve(transmuxResults);\n    }\n    return transmuxResults;\n  }\n  flushRemux(transmuxResults, demuxResult, chunkMeta) {\n    const {\n      audioTrack,\n      videoTrack,\n      id3Track,\n      textTrack\n    } = demuxResult;\n    const {\n      accurateTimeOffset,\n      timeOffset\n    } = this.currentTransmuxState;\n    this.logger.log(`[transmuxer.ts]: Flushed ${this.id} sn: ${chunkMeta.sn}${chunkMeta.part > -1 ? ' part: ' + chunkMeta.part : ''} of ${this.id === PlaylistLevelType.MAIN ? 'level' : 'track'} ${chunkMeta.level}`);\n    const remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, true, this.id);\n    transmuxResults.push({\n      remuxResult,\n      chunkMeta\n    });\n    chunkMeta.transmuxing.executeEnd = now();\n  }\n  resetInitialTimestamp(defaultInitPts) {\n    const {\n      demuxer,\n      remuxer\n    } = this;\n    if (!demuxer || !remuxer) {\n      return;\n    }\n    demuxer.resetTimeStamp(defaultInitPts);\n    remuxer.resetTimeStamp(defaultInitPts);\n  }\n  resetContiguity() {\n    const {\n      demuxer,\n      remuxer\n    } = this;\n    if (!demuxer || !remuxer) {\n      return;\n    }\n    demuxer.resetContiguity();\n    remuxer.resetNextTimestamp();\n  }\n  resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration, decryptdata) {\n    const {\n      demuxer,\n      remuxer\n    } = this;\n    if (!demuxer || !remuxer) {\n      return;\n    }\n    demuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration);\n    remuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, decryptdata);\n  }\n  destroy() {\n    if (this.demuxer) {\n      this.demuxer.destroy();\n      this.demuxer = undefined;\n    }\n    if (this.remuxer) {\n      this.remuxer.destroy();\n      this.remuxer = undefined;\n    }\n  }\n  transmux(data, keyData, timeOffset, accurateTimeOffset, chunkMeta) {\n    let result;\n    if (keyData && keyData.method === 'SAMPLE-AES') {\n      result = this.transmuxSampleAes(data, keyData, timeOffset, accurateTimeOffset, chunkMeta);\n    } else {\n      result = this.transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta);\n    }\n    return result;\n  }\n  transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta) {\n    const {\n      audioTrack,\n      videoTrack,\n      id3Track,\n      textTrack\n    } = this.demuxer.demux(data, timeOffset, false, !this.config.progressive);\n    const remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, false, this.id);\n    return {\n      remuxResult,\n      chunkMeta\n    };\n  }\n  transmuxSampleAes(data, decryptData, timeOffset, accurateTimeOffset, chunkMeta) {\n    return this.demuxer.demuxSampleAes(data, decryptData, timeOffset).then(demuxResult => {\n      const remuxResult = this.remuxer.remux(demuxResult.audioTrack, demuxResult.videoTrack, demuxResult.id3Track, demuxResult.textTrack, timeOffset, accurateTimeOffset, false, this.id);\n      return {\n        remuxResult,\n        chunkMeta\n      };\n    });\n  }\n  configureTransmuxer(data) {\n    const {\n      config,\n      observer,\n      typeSupported\n    } = this;\n    // probe for content type\n    let mux;\n    for (let i = 0, len = muxConfig.length; i < len; i++) {\n      var _muxConfig$i$demux;\n      if ((_muxConfig$i$demux = muxConfig[i].demux) != null && _muxConfig$i$demux.probe(data, this.logger)) {\n        mux = muxConfig[i];\n        break;\n      }\n    }\n    if (!mux) {\n      return new Error('Failed to find demuxer by probing fragment data');\n    }\n    // so let's check that current remuxer and demuxer are still valid\n    const demuxer = this.demuxer;\n    const remuxer = this.remuxer;\n    const Remuxer = mux.remux;\n    const Demuxer = mux.demux;\n    if (!remuxer || !(remuxer instanceof Remuxer)) {\n      this.remuxer = new Remuxer(observer, config, typeSupported, this.logger);\n    }\n    if (!demuxer || !(demuxer instanceof Demuxer)) {\n      this.demuxer = new Demuxer(observer, config, typeSupported, this.logger);\n      this.probe = Demuxer.probe;\n    }\n  }\n  needsProbing(discontinuity, trackSwitch) {\n    // in case of continuity change, or track switch\n    // we might switch from content type (AAC container to TS container, or TS to fmp4 for example)\n    return !this.demuxer || !this.remuxer || discontinuity || trackSwitch;\n  }\n  getDecrypter() {\n    let decrypter = this.decrypter;\n    if (!decrypter) {\n      decrypter = this.decrypter = new Decrypter(this.config);\n    }\n    return decrypter;\n  }\n}\nfunction getEncryptionType(data, decryptData) {\n  let encryptionType = null;\n  if (data.byteLength > 0 && (decryptData == null ? void 0 : decryptData.key) != null && decryptData.iv !== null && decryptData.method != null) {\n    encryptionType = decryptData;\n  }\n  return encryptionType;\n}\nconst emptyResult = chunkMeta => ({\n  remuxResult: {},\n  chunkMeta\n});\nfunction isPromise(p) {\n  return 'then' in p && p.then instanceof Function;\n}\nclass TransmuxConfig {\n  constructor(audioCodec, videoCodec, initSegmentData, duration, defaultInitPts) {\n    this.audioCodec = void 0;\n    this.videoCodec = void 0;\n    this.initSegmentData = void 0;\n    this.duration = void 0;\n    this.defaultInitPts = void 0;\n    this.audioCodec = audioCodec;\n    this.videoCodec = videoCodec;\n    this.initSegmentData = initSegmentData;\n    this.duration = duration;\n    this.defaultInitPts = defaultInitPts || null;\n  }\n}\nclass TransmuxState {\n  constructor(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange) {\n    this.discontinuity = void 0;\n    this.contiguous = void 0;\n    this.accurateTimeOffset = void 0;\n    this.trackSwitch = void 0;\n    this.timeOffset = void 0;\n    this.initSegmentChange = void 0;\n    this.discontinuity = discontinuity;\n    this.contiguous = contiguous;\n    this.accurateTimeOffset = accurateTimeOffset;\n    this.trackSwitch = trackSwitch;\n    this.timeOffset = timeOffset;\n    this.initSegmentChange = initSegmentChange;\n  }\n}\n\nlet transmuxerInstanceCount = 0;\nclass TransmuxerInterface {\n  constructor(_hls, id, onTransmuxComplete, onFlush) {\n    this.error = null;\n    this.hls = void 0;\n    this.id = void 0;\n    this.instanceNo = transmuxerInstanceCount++;\n    this.observer = void 0;\n    this.frag = null;\n    this.part = null;\n    this.useWorker = void 0;\n    this.workerContext = null;\n    this.transmuxer = null;\n    this.onTransmuxComplete = void 0;\n    this.onFlush = void 0;\n    this.onWorkerMessage = event => {\n      const data = event.data;\n      const hls = this.hls;\n      if (!hls || !(data != null && data.event) || data.instanceNo !== this.instanceNo) {\n        return;\n      }\n      switch (data.event) {\n        case 'init':\n          {\n            var _this$workerContext;\n            const objectURL = (_this$workerContext = this.workerContext) == null ? void 0 : _this$workerContext.objectURL;\n            if (objectURL) {\n              // revoke the Object URL that was used to create transmuxer worker, so as not to leak it\n              self.URL.revokeObjectURL(objectURL);\n            }\n            break;\n          }\n        case 'transmuxComplete':\n          {\n            this.handleTransmuxComplete(data.data);\n            break;\n          }\n        case 'flush':\n          {\n            this.onFlush(data.data);\n            break;\n          }\n\n        // pass logs from the worker thread to the main logger\n        case 'workerLog':\n          {\n            if (hls.logger[data.data.logType]) {\n              hls.logger[data.data.logType](data.data.message);\n            }\n            break;\n          }\n        default:\n          {\n            data.data = data.data || {};\n            data.data.frag = this.frag;\n            data.data.part = this.part;\n            data.data.id = this.id;\n            hls.trigger(data.event, data.data);\n            break;\n          }\n      }\n    };\n    this.onWorkerError = event => {\n      if (!this.hls) {\n        return;\n      }\n      const error = new Error(`${event.message}  (${event.filename}:${event.lineno})`);\n      this.hls.config.enableWorker = false;\n      this.hls.logger.warn(`Error in \"${this.id}\" Web Worker, fallback to inline`);\n      this.hls.trigger(Events.ERROR, {\n        type: ErrorTypes.OTHER_ERROR,\n        details: ErrorDetails.INTERNAL_EXCEPTION,\n        fatal: false,\n        event: 'demuxerWorker',\n        error\n      });\n    };\n    const config = _hls.config;\n    this.hls = _hls;\n    this.id = id;\n    this.useWorker = !!config.enableWorker;\n    this.onTransmuxComplete = onTransmuxComplete;\n    this.onFlush = onFlush;\n    const forwardMessage = (ev, data) => {\n      data = data || {};\n      data.frag = this.frag || undefined;\n      if (ev === Events.ERROR) {\n        data = data;\n        data.parent = this.id;\n        data.part = this.part;\n        this.error = data.error;\n      }\n      this.hls.trigger(ev, data);\n    };\n\n    // forward events to main thread\n    this.observer = new EventEmitter();\n    this.observer.on(Events.FRAG_DECRYPTED, forwardMessage);\n    this.observer.on(Events.ERROR, forwardMessage);\n    const m2tsTypeSupported = getM2TSSupportedAudioTypes(config.preferManagedMediaSource);\n    if (this.useWorker && typeof Worker !== 'undefined') {\n      const logger = this.hls.logger;\n      const canCreateWorker = config.workerPath || hasUMDWorker();\n      if (canCreateWorker) {\n        try {\n          if (config.workerPath) {\n            logger.log(`loading Web Worker ${config.workerPath} for \"${id}\"`);\n            this.workerContext = loadWorker(config.workerPath);\n          } else {\n            logger.log(`injecting Web Worker for \"${id}\"`);\n            this.workerContext = injectWorker();\n          }\n          const {\n            worker\n          } = this.workerContext;\n          worker.addEventListener('message', this.onWorkerMessage);\n          worker.addEventListener('error', this.onWorkerError);\n          worker.postMessage({\n            instanceNo: this.instanceNo,\n            cmd: 'init',\n            typeSupported: m2tsTypeSupported,\n            id,\n            config: stringify(config)\n          });\n        } catch (err) {\n          logger.warn(`Error setting up \"${id}\" Web Worker, fallback to inline`, err);\n          this.terminateWorker();\n          this.error = null;\n          this.transmuxer = new Transmuxer(this.observer, m2tsTypeSupported, config, '', id, _hls.logger);\n        }\n        return;\n      }\n    }\n    this.transmuxer = new Transmuxer(this.observer, m2tsTypeSupported, config, '', id, _hls.logger);\n  }\n  reset() {\n    this.frag = null;\n    this.part = null;\n    if (this.workerContext) {\n      const instanceNo = this.instanceNo;\n      this.instanceNo = transmuxerInstanceCount++;\n      const config = this.hls.config;\n      const m2tsTypeSupported = getM2TSSupportedAudioTypes(config.preferManagedMediaSource);\n      this.workerContext.worker.postMessage({\n        instanceNo: this.instanceNo,\n        cmd: 'reset',\n        resetNo: instanceNo,\n        typeSupported: m2tsTypeSupported,\n        id: this.id,\n        config: stringify(config)\n      });\n    }\n  }\n  terminateWorker() {\n    if (this.workerContext) {\n      const {\n        worker\n      } = this.workerContext;\n      this.workerContext = null;\n      worker.removeEventListener('message', this.onWorkerMessage);\n      worker.removeEventListener('error', this.onWorkerError);\n      removeWorkerFromStore(this.hls.config.workerPath);\n    }\n  }\n  destroy() {\n    if (this.workerContext) {\n      this.terminateWorker();\n      // @ts-ignore\n      this.onWorkerMessage = this.onWorkerError = null;\n    } else {\n      const transmuxer = this.transmuxer;\n      if (transmuxer) {\n        transmuxer.destroy();\n        this.transmuxer = null;\n      }\n    }\n    const observer = this.observer;\n    if (observer) {\n      observer.removeAllListeners();\n    }\n    this.frag = null;\n    this.part = null;\n    // @ts-ignore\n    this.observer = null;\n    // @ts-ignore\n    this.hls = null;\n  }\n  push(data, initSegmentData, audioCodec, videoCodec, frag, part, duration, accurateTimeOffset, chunkMeta, defaultInitPTS) {\n    var _frag$initSegment, _lastFrag$initSegment;\n    chunkMeta.transmuxing.start = self.performance.now();\n    const {\n      instanceNo,\n      transmuxer\n    } = this;\n    const timeOffset = part ? part.start : frag.start;\n    // TODO: push \"clear-lead\" decrypt data for unencrypted fragments in streams with encrypted ones\n    const decryptdata = frag.decryptdata;\n    const lastFrag = this.frag;\n    const discontinuity = !(lastFrag && frag.cc === lastFrag.cc);\n    const trackSwitch = !(lastFrag && chunkMeta.level === lastFrag.level);\n    const snDiff = lastFrag ? chunkMeta.sn - lastFrag.sn : -1;\n    const partDiff = this.part ? chunkMeta.part - this.part.index : -1;\n    const progressive = snDiff === 0 && chunkMeta.id > 1 && chunkMeta.id === (lastFrag == null ? void 0 : lastFrag.stats.chunkCount);\n    const contiguous = !trackSwitch && (snDiff === 1 || snDiff === 0 && (partDiff === 1 || progressive && partDiff <= 0));\n    const now = self.performance.now();\n    if (trackSwitch || snDiff || frag.stats.parsing.start === 0) {\n      frag.stats.parsing.start = now;\n    }\n    if (part && (partDiff || !contiguous)) {\n      part.stats.parsing.start = now;\n    }\n    const initSegmentChange = !(lastFrag && ((_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.url) === ((_lastFrag$initSegment = lastFrag.initSegment) == null ? void 0 : _lastFrag$initSegment.url));\n    const state = new TransmuxState(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange);\n    if (!contiguous || discontinuity || initSegmentChange) {\n      this.hls.logger.log(`[transmuxer-interface]: Starting new transmux session for ${frag.type} sn: ${chunkMeta.sn}${chunkMeta.part > -1 ? ' part: ' + chunkMeta.part : ''} ${this.id === PlaylistLevelType.MAIN ? 'level' : 'track'}: ${chunkMeta.level} id: ${chunkMeta.id}\n        discontinuity: ${discontinuity}\n        trackSwitch: ${trackSwitch}\n        contiguous: ${contiguous}\n        accurateTimeOffset: ${accurateTimeOffset}\n        timeOffset: ${timeOffset}\n        initSegmentChange: ${initSegmentChange}`);\n      const config = new TransmuxConfig(audioCodec, videoCodec, initSegmentData, duration, defaultInitPTS);\n      this.configureTransmuxer(config);\n    }\n    this.frag = frag;\n    this.part = part;\n\n    // Frags with sn of 'initSegment' are not transmuxed\n    if (this.workerContext) {\n      // post fragment payload as transferable objects for ArrayBuffer (no copy)\n      this.workerContext.worker.postMessage({\n        instanceNo,\n        cmd: 'demux',\n        data,\n        decryptdata,\n        chunkMeta,\n        state\n      }, data instanceof ArrayBuffer ? [data] : []);\n    } else if (transmuxer) {\n      const transmuxResult = transmuxer.push(data, decryptdata, chunkMeta, state);\n      if (isPromise(transmuxResult)) {\n        transmuxResult.then(data => {\n          this.handleTransmuxComplete(data);\n        }).catch(error => {\n          this.transmuxerError(error, chunkMeta, 'transmuxer-interface push error');\n        });\n      } else {\n        this.handleTransmuxComplete(transmuxResult);\n      }\n    }\n  }\n  flush(chunkMeta) {\n    chunkMeta.transmuxing.start = self.performance.now();\n    const {\n      instanceNo,\n      transmuxer\n    } = this;\n    if (this.workerContext) {\n      this.workerContext.worker.postMessage({\n        instanceNo,\n        cmd: 'flush',\n        chunkMeta\n      });\n    } else if (transmuxer) {\n      const transmuxResult = transmuxer.flush(chunkMeta);\n      if (isPromise(transmuxResult)) {\n        transmuxResult.then(data => {\n          this.handleFlushResult(data, chunkMeta);\n        }).catch(error => {\n          this.transmuxerError(error, chunkMeta, 'transmuxer-interface flush error');\n        });\n      } else {\n        this.handleFlushResult(transmuxResult, chunkMeta);\n      }\n    }\n  }\n  transmuxerError(error, chunkMeta, reason) {\n    if (!this.hls) {\n      return;\n    }\n    this.error = error;\n    this.hls.trigger(Events.ERROR, {\n      type: ErrorTypes.MEDIA_ERROR,\n      details: ErrorDetails.FRAG_PARSING_ERROR,\n      chunkMeta,\n      frag: this.frag || undefined,\n      part: this.part || undefined,\n      fatal: false,\n      error,\n      err: error,\n      reason\n    });\n  }\n  handleFlushResult(results, chunkMeta) {\n    results.forEach(result => {\n      this.handleTransmuxComplete(result);\n    });\n    this.onFlush(chunkMeta);\n  }\n  configureTransmuxer(config) {\n    const {\n      instanceNo,\n      transmuxer\n    } = this;\n    if (this.workerContext) {\n      this.workerContext.worker.postMessage({\n        instanceNo,\n        cmd: 'configure',\n        config\n      });\n    } else if (transmuxer) {\n      transmuxer.configure(config);\n    }\n  }\n  handleTransmuxComplete(result) {\n    result.chunkMeta.transmuxing.end = self.performance.now();\n    this.onTransmuxComplete(result);\n  }\n}\n\nconst TICK_INTERVAL$3 = 100; // how often to tick in ms\n\nclass AudioStreamController extends BaseStreamController {\n  constructor(hls, fragmentTracker, keyLoader) {\n    super(hls, fragmentTracker, keyLoader, 'audio-stream-controller', PlaylistLevelType.AUDIO);\n    this.mainAnchor = null;\n    this.mainFragLoading = null;\n    this.audioOnly = false;\n    this.bufferedTrack = null;\n    this.switchingTrack = null;\n    this.trackId = -1;\n    this.waitingData = null;\n    this.mainDetails = null;\n    this.flushing = false;\n    this.bufferFlushed = false;\n    this.cachedTrackLoadedData = null;\n    this.registerListeners();\n  }\n  onHandlerDestroying() {\n    this.unregisterListeners();\n    super.onHandlerDestroying();\n    this.resetItem();\n  }\n  resetItem() {\n    this.mainDetails = this.mainAnchor = this.mainFragLoading = this.bufferedTrack = this.switchingTrack = this.waitingData = this.cachedTrackLoadedData = null;\n  }\n  registerListeners() {\n    super.registerListeners();\n    const {\n      hls\n    } = this;\n    hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);\n    hls.on(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n    hls.on(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n    hls.on(Events.BUFFER_RESET, this.onBufferReset, this);\n    hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);\n    hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.on(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n    hls.on(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);\n    hls.on(Events.FRAG_LOADING, this.onFragLoading, this);\n    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n  }\n  unregisterListeners() {\n    const {\n      hls\n    } = this;\n    if (!hls) {\n      return;\n    }\n    super.unregisterListeners();\n    hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);\n    hls.off(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n    hls.off(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n    hls.off(Events.BUFFER_RESET, this.onBufferReset, this);\n    hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);\n    hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.off(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n    hls.off(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);\n    hls.off(Events.FRAG_LOADING, this.onFragLoading, this);\n    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n  }\n\n  // INIT_PTS_FOUND is triggered when the video track parsed in the stream-controller has a new PTS value\n  onInitPtsFound(event, {\n    frag,\n    id,\n    initPTS,\n    timescale\n  }) {\n    // Always update the new INIT PTS\n    // Can change due level switch\n    if (id === PlaylistLevelType.MAIN) {\n      const cc = frag.cc;\n      const inFlightFrag = this.fragCurrent;\n      this.initPTS[cc] = {\n        baseTime: initPTS,\n        timescale\n      };\n      this.log(`InitPTS for cc: ${cc} found from main: ${initPTS}/${timescale}`);\n      this.mainAnchor = frag;\n      // If we are waiting, tick immediately to unblock audio fragment transmuxing\n      if (this.state === State.WAITING_INIT_PTS) {\n        const waitingData = this.waitingData;\n        if (!waitingData && !this.loadingParts || waitingData && waitingData.frag.cc !== cc) {\n          this.syncWithAnchor(frag, waitingData == null ? void 0 : waitingData.frag);\n        }\n      } else if (!this.hls.hasEnoughToStart && inFlightFrag && inFlightFrag.cc !== cc) {\n        inFlightFrag.abortRequests();\n        this.syncWithAnchor(frag, inFlightFrag);\n      } else if (this.state === State.IDLE) {\n        this.tick();\n      }\n    }\n  }\n  getLoadPosition() {\n    if (!this.startFragRequested && this.nextLoadPosition >= 0) {\n      return this.nextLoadPosition;\n    }\n    return super.getLoadPosition();\n  }\n  syncWithAnchor(mainAnchor, waitingToAppend) {\n    var _this$mainFragLoading;\n    // Drop waiting fragment if videoTrackCC has changed since waitingFragment was set and initPTS was not found\n    const mainFragLoading = ((_this$mainFragLoading = this.mainFragLoading) == null ? void 0 : _this$mainFragLoading.frag) || null;\n    if (waitingToAppend) {\n      if ((mainFragLoading == null ? void 0 : mainFragLoading.cc) === waitingToAppend.cc) {\n        // Wait for loading frag to complete and INIT_PTS_FOUND\n        return;\n      }\n    }\n    const targetDiscontinuity = (mainFragLoading || mainAnchor).cc;\n    const trackDetails = this.getLevelDetails();\n    const pos = this.getLoadPosition();\n    const syncFrag = findNearestWithCC(trackDetails, targetDiscontinuity, pos);\n    // Only stop waiting for audioFrag.cc if an audio segment of the same discontinuity domain (cc) is found\n    if (syncFrag) {\n      this.log(`Syncing with main frag at ${syncFrag.start} cc ${syncFrag.cc}`);\n      this.startFragRequested = false;\n      this.nextLoadPosition = syncFrag.start;\n      this.resetLoadingState();\n      if (this.state === State.IDLE) {\n        this.doTickIdle();\n      }\n    }\n  }\n  startLoad(startPosition, skipSeekToStartPosition) {\n    if (!this.levels) {\n      this.startPosition = startPosition;\n      this.state = State.STOPPED;\n      return;\n    }\n    const lastCurrentTime = this.lastCurrentTime;\n    this.stopLoad();\n    this.setInterval(TICK_INTERVAL$3);\n    if (lastCurrentTime > 0 && startPosition === -1) {\n      this.log(`Override startPosition with lastCurrentTime @${lastCurrentTime.toFixed(3)}`);\n      startPosition = lastCurrentTime;\n      this.state = State.IDLE;\n    } else {\n      this.state = State.WAITING_TRACK;\n    }\n    this.nextLoadPosition = this.lastCurrentTime = startPosition + this.timelineOffset;\n    this.startPosition = skipSeekToStartPosition ? -1 : startPosition;\n    this.tick();\n  }\n  doTick() {\n    switch (this.state) {\n      case State.IDLE:\n        this.doTickIdle();\n        break;\n      case State.WAITING_TRACK:\n        {\n          const {\n            levels,\n            trackId\n          } = this;\n          const currenTrack = levels == null ? void 0 : levels[trackId];\n          const details = currenTrack == null ? void 0 : currenTrack.details;\n          if (details && !this.waitForLive(currenTrack)) {\n            if (this.waitForCdnTuneIn(details)) {\n              break;\n            }\n            this.state = State.WAITING_INIT_PTS;\n          }\n          break;\n        }\n      case State.FRAG_LOADING_WAITING_RETRY:\n        {\n          var _this$media;\n          const now = performance.now();\n          const retryDate = this.retryDate;\n          // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading\n          if (!retryDate || now >= retryDate || (_this$media = this.media) != null && _this$media.seeking) {\n            const {\n              levels,\n              trackId\n            } = this;\n            this.log('RetryDate reached, switch back to IDLE state');\n            this.resetStartWhenNotLoaded((levels == null ? void 0 : levels[trackId]) || null);\n            this.state = State.IDLE;\n          }\n          break;\n        }\n      case State.WAITING_INIT_PTS:\n        {\n          // Ensure we don't get stuck in the WAITING_INIT_PTS state if the waiting frag CC doesn't match any initPTS\n          const waitingData = this.waitingData;\n          if (waitingData) {\n            const {\n              frag,\n              part,\n              cache,\n              complete\n            } = waitingData;\n            const mainAnchor = this.mainAnchor;\n            if (this.initPTS[frag.cc] !== undefined) {\n              this.waitingData = null;\n              this.state = State.FRAG_LOADING;\n              const payload = cache.flush().buffer;\n              const data = {\n                frag,\n                part,\n                payload,\n                networkDetails: null\n              };\n              this._handleFragmentLoadProgress(data);\n              if (complete) {\n                super._handleFragmentLoadComplete(data);\n              }\n            } else if (mainAnchor && mainAnchor.cc !== waitingData.frag.cc) {\n              this.syncWithAnchor(mainAnchor, waitingData.frag);\n            }\n          } else {\n            this.state = State.IDLE;\n          }\n        }\n    }\n    this.onTickEnd();\n  }\n  resetLoadingState() {\n    const waitingData = this.waitingData;\n    if (waitingData) {\n      this.fragmentTracker.removeFragment(waitingData.frag);\n      this.waitingData = null;\n    }\n    super.resetLoadingState();\n  }\n  onTickEnd() {\n    const {\n      media\n    } = this;\n    if (!(media != null && media.readyState)) {\n      // Exit early if we don't have media or if the media hasn't buffered anything yet (readyState 0)\n      return;\n    }\n    this.lastCurrentTime = media.currentTime;\n  }\n  doTickIdle() {\n    var _this$mainFragLoading2;\n    const {\n      hls,\n      levels,\n      media,\n      trackId\n    } = this;\n    const config = hls.config;\n\n    // 1. if buffering is suspended\n    // 2. if video not attached AND\n    //    start fragment already requested OR start frag prefetch not enabled\n    // 3. if tracks or track not loaded and selected\n    // then exit loop\n    // => if media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop\n    if (!this.buffering || !media && !this.primaryPrefetch && (this.startFragRequested || !config.startFragPrefetch) || !(levels != null && levels[trackId])) {\n      return;\n    }\n    const levelInfo = levels[trackId];\n    const trackDetails = levelInfo.details;\n    if (!trackDetails || this.waitForLive(levelInfo) || this.waitForCdnTuneIn(trackDetails)) {\n      this.state = State.WAITING_TRACK;\n      this.startFragRequested = false;\n      return;\n    }\n    const bufferable = this.mediaBuffer ? this.mediaBuffer : this.media;\n    if (this.bufferFlushed && bufferable) {\n      this.bufferFlushed = false;\n      this.afterBufferFlushed(bufferable, ElementaryStreamTypes.AUDIO, PlaylistLevelType.AUDIO);\n    }\n    const bufferInfo = this.getFwdBufferInfo(bufferable, PlaylistLevelType.AUDIO);\n    if (bufferInfo === null) {\n      return;\n    }\n    if (!this.switchingTrack && this._streamEnded(bufferInfo, trackDetails)) {\n      hls.trigger(Events.BUFFER_EOS, {\n        type: 'audio'\n      });\n      this.state = State.ENDED;\n      return;\n    }\n    const bufferLen = bufferInfo.len;\n    const maxBufLen = hls.maxBufferLength;\n    const fragments = trackDetails.fragments;\n    const start = fragments[0].start;\n    const loadPosition = this.getLoadPosition();\n    const targetBufferTime = this.flushing ? loadPosition : bufferInfo.end;\n    if (this.switchingTrack && media) {\n      const pos = loadPosition;\n      // if currentTime (pos) is less than alt audio playlist start time, it means that alt audio is ahead of currentTime\n      if (trackDetails.PTSKnown && pos < start) {\n        // if everything is buffered from pos to start or if audio buffer upfront, let's seek to start\n        if (bufferInfo.end > start || bufferInfo.nextStart) {\n          this.log('Alt audio track ahead of main track, seek to start of alt audio track');\n          media.currentTime = start + 0.05;\n        }\n      }\n    }\n\n    // if buffer length is less than maxBufLen, or near the end, find a fragment to load\n    if (bufferLen >= maxBufLen && !this.switchingTrack && targetBufferTime < fragments[fragments.length - 1].start) {\n      return;\n    }\n    let frag = this.getNextFragment(targetBufferTime, trackDetails);\n    // Avoid loop loading by using nextLoadPosition set for backtracking and skipping consecutive GAP tags\n    if (frag && this.isLoopLoading(frag, targetBufferTime)) {\n      frag = this.getNextFragmentLoopLoading(frag, trackDetails, bufferInfo, PlaylistLevelType.MAIN, maxBufLen);\n    }\n    if (!frag) {\n      this.bufferFlushed = true;\n      return;\n    }\n\n    // Request audio segments up to one fragment ahead of main stream-controller\n    let mainFragLoading = ((_this$mainFragLoading2 = this.mainFragLoading) == null ? void 0 : _this$mainFragLoading2.frag) || null;\n    if (!this.audioOnly && this.startFragRequested && mainFragLoading && isMediaFragment(frag) && !frag.endList && (!trackDetails.live || !this.loadingParts && targetBufferTime < this.hls.liveSyncPosition)) {\n      if (this.fragmentTracker.getState(mainFragLoading) === FragmentState.OK) {\n        this.mainFragLoading = mainFragLoading = null;\n      }\n      if (mainFragLoading && isMediaFragment(mainFragLoading)) {\n        if (frag.start > mainFragLoading.end) {\n          // Get buffered frag at target position from tracker (loaded out of sequence)\n          const mainFragAtPos = this.fragmentTracker.getFragAtPos(targetBufferTime, PlaylistLevelType.MAIN);\n          if (mainFragAtPos && mainFragAtPos.end > mainFragLoading.end) {\n            mainFragLoading = mainFragAtPos;\n            this.mainFragLoading = {\n              frag: mainFragAtPos,\n              targetBufferTime: null\n            };\n          }\n        }\n        const atBufferSyncLimit = frag.start > mainFragLoading.end;\n        if (atBufferSyncLimit) {\n          return;\n        }\n      }\n    }\n    this.loadFragment(frag, levelInfo, targetBufferTime);\n  }\n  onMediaDetaching(event, data) {\n    this.bufferFlushed = this.flushing = false;\n    super.onMediaDetaching(event, data);\n  }\n  onAudioTracksUpdated(event, {\n    audioTracks\n  }) {\n    // Reset tranxmuxer is essential for large context switches (Content Steering)\n    this.resetTransmuxer();\n    this.levels = audioTracks.map(mediaPlaylist => new Level(mediaPlaylist));\n  }\n  onAudioTrackSwitching(event, data) {\n    // if any URL found on new audio track, it is an alternate audio track\n    const altAudio = !!data.url;\n    this.trackId = data.id;\n    const {\n      fragCurrent\n    } = this;\n    if (fragCurrent) {\n      fragCurrent.abortRequests();\n      this.removeUnbufferedFrags(fragCurrent.start);\n    }\n    this.resetLoadingState();\n\n    // should we switch tracks ?\n    if (altAudio) {\n      this.switchingTrack = data;\n      // main audio track are handled by stream-controller, just do something if switching to alt audio track\n      this.flushAudioIfNeeded(data);\n      if (this.state !== State.STOPPED) {\n        // switching to audio track, start timer if not already started\n        this.setInterval(TICK_INTERVAL$3);\n        this.state = State.IDLE;\n        this.tick();\n      }\n    } else {\n      // destroy useless transmuxer when switching audio to main\n      this.resetTransmuxer();\n      this.switchingTrack = null;\n      this.bufferedTrack = data;\n      this.clearInterval();\n    }\n  }\n  onManifestLoading() {\n    super.onManifestLoading();\n    this.bufferFlushed = this.flushing = this.audioOnly = false;\n    this.resetItem();\n    this.trackId = -1;\n  }\n  onLevelLoaded(event, data) {\n    this.mainDetails = data.details;\n    const cachedTrackLoadedData = this.cachedTrackLoadedData;\n    if (cachedTrackLoadedData) {\n      this.cachedTrackLoadedData = null;\n      this.onAudioTrackLoaded(Events.AUDIO_TRACK_LOADED, cachedTrackLoadedData);\n    }\n  }\n  onAudioTrackLoaded(event, data) {\n    var _trackLevel$details;\n    const {\n      levels\n    } = this;\n    const {\n      details: newDetails,\n      id: trackId,\n      groupId,\n      track\n    } = data;\n    if (!levels) {\n      this.warn(`Audio tracks reset while loading track ${trackId} \"${track.name}\" of \"${groupId}\"`);\n      return;\n    }\n    const mainDetails = this.mainDetails;\n    if (!mainDetails || newDetails.endCC > mainDetails.endCC || mainDetails.expired) {\n      this.cachedTrackLoadedData = data;\n      if (this.state !== State.STOPPED) {\n        this.state = State.WAITING_TRACK;\n      }\n      return;\n    }\n    this.cachedTrackLoadedData = null;\n    this.log(`Audio track ${trackId} \"${track.name}\" of \"${groupId}\" loaded [${newDetails.startSN},${newDetails.endSN}]${newDetails.lastPartSn ? `[part-${newDetails.lastPartSn}-${newDetails.lastPartIndex}]` : ''},duration:${newDetails.totalduration}`);\n    const trackLevel = levels[trackId];\n    let sliding = 0;\n    if (newDetails.live || (_trackLevel$details = trackLevel.details) != null && _trackLevel$details.live) {\n      this.checkLiveUpdate(newDetails);\n      if (newDetails.deltaUpdateFailed) {\n        return;\n      }\n      if (trackLevel.details) {\n        var _this$levelLastLoaded;\n        sliding = this.alignPlaylists(newDetails, trackLevel.details, (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details);\n      }\n      if (!newDetails.alignedSliding) {\n        // Align audio rendition with the \"main\" playlist on discontinuity change\n        // or program-date-time (PDT)\n        alignDiscontinuities(newDetails, mainDetails);\n        if (!newDetails.alignedSliding) {\n          alignMediaPlaylistByPDT(newDetails, mainDetails);\n        }\n        sliding = newDetails.fragmentStart;\n      }\n    }\n    trackLevel.details = newDetails;\n    this.levelLastLoaded = trackLevel;\n\n    // compute start position if we are aligned with the main playlist\n    if (!this.startFragRequested) {\n      this.setStartPosition(mainDetails, sliding);\n    }\n    this.hls.trigger(Events.AUDIO_TRACK_UPDATED, {\n      details: newDetails,\n      id: trackId,\n      groupId: data.groupId\n    });\n\n    // only switch back to IDLE state if we were waiting for track to start downloading a new fragment\n    if (this.state === State.WAITING_TRACK && !this.waitForCdnTuneIn(newDetails)) {\n      this.state = State.IDLE;\n    }\n\n    // trigger handler right now\n    this.tick();\n  }\n  _handleFragmentLoadProgress(data) {\n    var _frag$initSegment;\n    const frag = data.frag;\n    const {\n      part,\n      payload\n    } = data;\n    const {\n      config,\n      trackId,\n      levels\n    } = this;\n    if (!levels) {\n      this.warn(`Audio tracks were reset while fragment load was in progress. Fragment ${frag.sn} of level ${frag.level} will not be buffered`);\n      return;\n    }\n    const track = levels[trackId];\n    if (!track) {\n      this.warn('Audio track is undefined on fragment load progress');\n      return;\n    }\n    const details = track.details;\n    if (!details) {\n      this.warn('Audio track details undefined on fragment load progress');\n      this.removeUnbufferedFrags(frag.start);\n      return;\n    }\n    const audioCodec = config.defaultAudioCodec || track.audioCodec || 'mp4a.40.2';\n    let transmuxer = this.transmuxer;\n    if (!transmuxer) {\n      transmuxer = this.transmuxer = new TransmuxerInterface(this.hls, PlaylistLevelType.AUDIO, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));\n    }\n\n    // Check if we have video initPTS\n    // If not we need to wait for it\n    const initPTS = this.initPTS[frag.cc];\n    const initSegmentData = (_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.data;\n    if (initPTS !== undefined) {\n      // this.log(`Transmuxing ${sn} of [${details.startSN} ,${details.endSN}],track ${trackId}`);\n      // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)\n      const accurateTimeOffset = false; // details.PTSKnown || !details.live;\n      const partIndex = part ? part.index : -1;\n      const partial = partIndex !== -1;\n      const chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);\n      transmuxer.push(payload, initSegmentData, audioCodec, '', frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);\n    } else {\n      this.log(`Unknown video PTS for cc ${frag.cc}, waiting for video PTS before demuxing audio frag ${frag.sn} of [${details.startSN} ,${details.endSN}],track ${trackId}`);\n      const {\n        cache\n      } = this.waitingData = this.waitingData || {\n        frag,\n        part,\n        cache: new ChunkCache(),\n        complete: false\n      };\n      cache.push(new Uint8Array(payload));\n      if (this.state !== State.STOPPED) {\n        this.state = State.WAITING_INIT_PTS;\n      }\n    }\n  }\n  _handleFragmentLoadComplete(fragLoadedData) {\n    if (this.waitingData) {\n      this.waitingData.complete = true;\n      return;\n    }\n    super._handleFragmentLoadComplete(fragLoadedData);\n  }\n  onBufferReset(/* event: Events.BUFFER_RESET */\n  ) {\n    // reset reference to sourcebuffers\n    this.mediaBuffer = null;\n  }\n  onBufferCreated(event, data) {\n    this.bufferFlushed = this.flushing = false;\n    const audioTrack = data.tracks.audio;\n    if (audioTrack) {\n      this.mediaBuffer = audioTrack.buffer || null;\n    }\n  }\n  onFragLoading(event, data) {\n    if (!this.audioOnly && data.frag.type === PlaylistLevelType.MAIN && isMediaFragment(data.frag)) {\n      this.mainFragLoading = data;\n      if (this.state === State.IDLE) {\n        this.tick();\n      }\n    }\n  }\n  onFragBuffered(event, data) {\n    const {\n      frag,\n      part\n    } = data;\n    if (frag.type !== PlaylistLevelType.AUDIO) {\n      if (!this.audioOnly && frag.type === PlaylistLevelType.MAIN && !frag.elementaryStreams.video && !frag.elementaryStreams.audiovideo) {\n        this.audioOnly = true;\n        this.mainFragLoading = null;\n      }\n      return;\n    }\n    if (this.fragContextChanged(frag)) {\n      // If a level switch was requested while a fragment was buffering, it will emit the FRAG_BUFFERED event upon completion\n      // Avoid setting state back to IDLE or concluding the audio switch; otherwise, the switched-to track will not buffer\n      this.warn(`Fragment ${frag.sn}${part ? ' p: ' + part.index : ''} of level ${frag.level} finished buffering, but was aborted. state: ${this.state}, audioSwitch: ${this.switchingTrack ? this.switchingTrack.name : 'false'}`);\n      return;\n    }\n    if (isMediaFragment(frag)) {\n      this.fragPrevious = frag;\n      const track = this.switchingTrack;\n      if (track) {\n        this.bufferedTrack = track;\n        this.switchingTrack = null;\n        this.hls.trigger(Events.AUDIO_TRACK_SWITCHED, _objectSpread2({}, track));\n      }\n    }\n    this.fragBufferedComplete(frag, part);\n    if (this.media) {\n      this.tick();\n    }\n  }\n  onError(event, data) {\n    var _data$context;\n    if (data.fatal) {\n      this.state = State.ERROR;\n      return;\n    }\n    switch (data.details) {\n      case ErrorDetails.FRAG_GAP:\n      case ErrorDetails.FRAG_PARSING_ERROR:\n      case ErrorDetails.FRAG_DECRYPT_ERROR:\n      case ErrorDetails.FRAG_LOAD_ERROR:\n      case ErrorDetails.FRAG_LOAD_TIMEOUT:\n      case ErrorDetails.KEY_LOAD_ERROR:\n      case ErrorDetails.KEY_LOAD_TIMEOUT:\n        this.onFragmentOrKeyLoadError(PlaylistLevelType.AUDIO, data);\n        break;\n      case ErrorDetails.AUDIO_TRACK_LOAD_ERROR:\n      case ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:\n      case ErrorDetails.LEVEL_PARSING_ERROR:\n        // in case of non fatal error while loading track, if not retrying to load track, switch back to IDLE\n        if (!data.levelRetry && this.state === State.WAITING_TRACK && ((_data$context = data.context) == null ? void 0 : _data$context.type) === PlaylistContextType.AUDIO_TRACK) {\n          this.state = State.IDLE;\n        }\n        break;\n      case ErrorDetails.BUFFER_ADD_CODEC_ERROR:\n      case ErrorDetails.BUFFER_APPEND_ERROR:\n        if (data.parent !== 'audio') {\n          return;\n        }\n        if (!this.reduceLengthAndFlushBuffer(data)) {\n          this.resetLoadingState();\n        }\n        break;\n      case ErrorDetails.BUFFER_FULL_ERROR:\n        if (data.parent !== 'audio') {\n          return;\n        }\n        if (this.reduceLengthAndFlushBuffer(data)) {\n          this.bufferedTrack = null;\n          super.flushMainBuffer(0, Number.POSITIVE_INFINITY, 'audio');\n        }\n        break;\n      case ErrorDetails.INTERNAL_EXCEPTION:\n        this.recoverWorkerError(data);\n        break;\n    }\n  }\n  onBufferFlushing(event, {\n    type\n  }) {\n    if (type !== ElementaryStreamTypes.VIDEO) {\n      this.flushing = true;\n    }\n  }\n  onBufferFlushed(event, {\n    type\n  }) {\n    if (type !== ElementaryStreamTypes.VIDEO) {\n      this.flushing = false;\n      this.bufferFlushed = true;\n      if (this.state === State.ENDED) {\n        this.state = State.IDLE;\n      }\n      const mediaBuffer = this.mediaBuffer || this.media;\n      if (mediaBuffer) {\n        this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.AUDIO);\n        this.tick();\n      }\n    }\n  }\n  _handleTransmuxComplete(transmuxResult) {\n    var _id3$samples;\n    const id = 'audio';\n    const {\n      hls\n    } = this;\n    const {\n      remuxResult,\n      chunkMeta\n    } = transmuxResult;\n    const context = this.getCurrentContext(chunkMeta);\n    if (!context) {\n      this.resetWhenMissingContext(chunkMeta);\n      return;\n    }\n    const {\n      frag,\n      part,\n      level\n    } = context;\n    const {\n      details\n    } = level;\n    const {\n      audio,\n      text,\n      id3,\n      initSegment\n    } = remuxResult;\n\n    // Check if the current fragment has been aborted. We check this by first seeing if we're still playing the current level.\n    // If we are, subsequently check if the currently loading fragment (fragCurrent) has changed.\n    if (this.fragContextChanged(frag) || !details) {\n      this.fragmentTracker.removeFragment(frag);\n      return;\n    }\n    this.state = State.PARSING;\n    if (this.switchingTrack && audio) {\n      this.completeAudioSwitch(this.switchingTrack);\n    }\n    if (initSegment != null && initSegment.tracks) {\n      const mapFragment = frag.initSegment || frag;\n      this._bufferInitSegment(level, initSegment.tracks, mapFragment, chunkMeta);\n      hls.trigger(Events.FRAG_PARSING_INIT_SEGMENT, {\n        frag: mapFragment,\n        id,\n        tracks: initSegment.tracks\n      });\n      // Only flush audio from old audio tracks when PTS is known on new audio track\n    }\n    if (audio) {\n      const {\n        startPTS,\n        endPTS,\n        startDTS,\n        endDTS\n      } = audio;\n      if (part) {\n        part.elementaryStreams[ElementaryStreamTypes.AUDIO] = {\n          startPTS,\n          endPTS,\n          startDTS,\n          endDTS\n        };\n      }\n      frag.setElementaryStreamInfo(ElementaryStreamTypes.AUDIO, startPTS, endPTS, startDTS, endDTS);\n      this.bufferFragmentData(audio, frag, part, chunkMeta);\n    }\n    if (id3 != null && (_id3$samples = id3.samples) != null && _id3$samples.length) {\n      const emittedID3 = _extends({\n        id,\n        frag,\n        details\n      }, id3);\n      hls.trigger(Events.FRAG_PARSING_METADATA, emittedID3);\n    }\n    if (text) {\n      const emittedText = _extends({\n        id,\n        frag,\n        details\n      }, text);\n      hls.trigger(Events.FRAG_PARSING_USERDATA, emittedText);\n    }\n  }\n  _bufferInitSegment(currentLevel, tracks, frag, chunkMeta) {\n    if (this.state !== State.PARSING) {\n      return;\n    }\n    // delete any video track found on audio transmuxer\n    if (tracks.video) {\n      delete tracks.video;\n    }\n    if (tracks.audiovideo) {\n      delete tracks.audiovideo;\n    }\n\n    // include levelCodec in audio and video tracks\n    if (!tracks.audio) {\n      return;\n    }\n    const track = tracks.audio;\n    track.id = PlaylistLevelType.AUDIO;\n    const variantAudioCodecs = currentLevel.audioCodec;\n    this.log(`Init audio buffer, container:${track.container}, codecs[level/parsed]=[${variantAudioCodecs}/${track.codec}]`);\n    // SourceBuffer will use track.levelCodec if defined\n    if (variantAudioCodecs && variantAudioCodecs.split(',').length === 1) {\n      track.levelCodec = variantAudioCodecs;\n    }\n    this.hls.trigger(Events.BUFFER_CODECS, tracks);\n    const initSegment = track.initSegment;\n    if (initSegment != null && initSegment.byteLength) {\n      const segment = {\n        type: 'audio',\n        frag,\n        part: null,\n        chunkMeta,\n        parent: frag.type,\n        data: initSegment\n      };\n      this.hls.trigger(Events.BUFFER_APPENDING, segment);\n    }\n    // trigger handler right now\n    this.tickImmediate();\n  }\n  loadFragment(frag, track, targetBufferTime) {\n    // only load if fragment is not loaded or if in audio switch\n    const fragState = this.fragmentTracker.getState(frag);\n\n    // we force a frag loading in audio switch as fragment tracker might not have evicted previous frags in case of quick audio switch\n    if (this.switchingTrack || fragState === FragmentState.NOT_LOADED || fragState === FragmentState.PARTIAL) {\n      var _track$details;\n      if (!isMediaFragment(frag)) {\n        this._loadInitSegment(frag, track);\n      } else if ((_track$details = track.details) != null && _track$details.live && !this.initPTS[frag.cc]) {\n        this.log(`Waiting for video PTS in continuity counter ${frag.cc} of live stream before loading audio fragment ${frag.sn} of level ${this.trackId}`);\n        this.state = State.WAITING_INIT_PTS;\n        const mainDetails = this.mainDetails;\n        if (mainDetails && mainDetails.fragmentStart !== track.details.fragmentStart) {\n          alignMediaPlaylistByPDT(track.details, mainDetails);\n        }\n      } else {\n        super.loadFragment(frag, track, targetBufferTime);\n      }\n    } else {\n      this.clearTrackerIfNeeded(frag);\n    }\n  }\n  flushAudioIfNeeded(switchingTrack) {\n    if (this.media && this.bufferedTrack) {\n      const {\n        name,\n        lang,\n        assocLang,\n        characteristics,\n        audioCodec,\n        channels\n      } = this.bufferedTrack;\n      if (!matchesOption({\n        name,\n        lang,\n        assocLang,\n        characteristics,\n        audioCodec,\n        channels\n      }, switchingTrack, audioMatchPredicate)) {\n        if (useAlternateAudio(switchingTrack.url, this.hls)) {\n          this.log('Switching audio track : flushing all audio');\n          super.flushMainBuffer(0, Number.POSITIVE_INFINITY, 'audio');\n          this.bufferedTrack = null;\n        } else {\n          // Main is being buffered. Set bufferedTrack so that it is flushed when switching back to alt-audio\n          this.bufferedTrack = switchingTrack;\n        }\n      }\n    }\n  }\n  completeAudioSwitch(switchingTrack) {\n    const {\n      hls\n    } = this;\n    this.flushAudioIfNeeded(switchingTrack);\n    this.bufferedTrack = switchingTrack;\n    this.switchingTrack = null;\n    hls.trigger(Events.AUDIO_TRACK_SWITCHED, _objectSpread2({}, switchingTrack));\n  }\n}\n\nclass BasePlaylistController extends Logger {\n  constructor(hls, logPrefix) {\n    super(logPrefix, hls.logger);\n    this.hls = void 0;\n    this.canLoad = false;\n    this.timer = -1;\n    this.hls = hls;\n  }\n  destroy() {\n    this.clearTimer();\n    // @ts-ignore\n    this.hls = this.log = this.warn = null;\n  }\n  clearTimer() {\n    if (this.timer !== -1) {\n      self.clearTimeout(this.timer);\n      this.timer = -1;\n    }\n  }\n  startLoad() {\n    this.canLoad = true;\n    this.loadPlaylist();\n  }\n  stopLoad() {\n    this.canLoad = false;\n    this.clearTimer();\n  }\n  switchParams(playlistUri, previous, current) {\n    const renditionReports = previous == null ? void 0 : previous.renditionReports;\n    if (renditionReports) {\n      let foundIndex = -1;\n      for (let i = 0; i < renditionReports.length; i++) {\n        const attr = renditionReports[i];\n        let uri;\n        try {\n          uri = new self.URL(attr.URI, previous.url).href;\n        } catch (error) {\n          this.warn(`Could not construct new URL for Rendition Report: ${error}`);\n          uri = attr.URI || '';\n        }\n        // Use exact match. Otherwise, the last partial match, if any, will be used\n        // (Playlist URI includes a query string that the Rendition Report does not)\n        if (uri === playlistUri) {\n          foundIndex = i;\n          break;\n        } else if (uri === playlistUri.substring(0, uri.length)) {\n          foundIndex = i;\n        }\n      }\n      if (foundIndex !== -1) {\n        const attr = renditionReports[foundIndex];\n        const msn = parseInt(attr['LAST-MSN']) || (previous == null ? void 0 : previous.lastPartSn);\n        let part = parseInt(attr['LAST-PART']) || (previous == null ? void 0 : previous.lastPartIndex);\n        if (this.hls.config.lowLatencyMode) {\n          const currentGoal = Math.min(previous.age - previous.partTarget, previous.targetduration);\n          if (part >= 0 && currentGoal > previous.partTarget) {\n            part += 1;\n          }\n        }\n        const skip = current && getSkipValue(current);\n        return new HlsUrlParameters(msn, part >= 0 ? part : undefined, skip);\n      }\n    }\n  }\n  loadPlaylist(hlsUrlParameters) {\n    // Loading is handled by the subclasses\n    this.clearTimer();\n  }\n  loadingPlaylist(playlist, hlsUrlParameters) {\n    // Loading is handled by the subclasses\n    this.clearTimer();\n  }\n  shouldLoadPlaylist(playlist) {\n    return this.canLoad && !!playlist && !!playlist.url && (!playlist.details || playlist.details.live);\n  }\n  getUrlWithDirectives(uri, hlsUrlParameters) {\n    if (hlsUrlParameters) {\n      try {\n        return hlsUrlParameters.addDirectives(uri);\n      } catch (error) {\n        this.warn(`Could not construct new URL with HLS Delivery Directives: ${error}`);\n      }\n    }\n    return uri;\n  }\n  playlistLoaded(index, data, previousDetails) {\n    const {\n      details,\n      stats\n    } = data;\n\n    // Set last updated date-time\n    const now = self.performance.now();\n    const elapsed = stats.loading.first ? Math.max(0, now - stats.loading.first) : 0;\n    details.advancedDateTime = Date.now() - elapsed;\n\n    // shift fragment starts with timelineOffset\n    const timelineOffset = this.hls.config.timelineOffset;\n    if (timelineOffset !== details.appliedTimelineOffset) {\n      const offset = Math.max(timelineOffset || 0, 0);\n      details.appliedTimelineOffset = offset;\n      details.fragments.forEach(frag => {\n        frag.start = frag.playlistOffset + offset;\n      });\n    }\n\n    // if current playlist is a live playlist, arm a timer to reload it\n    if (details.live || previousDetails != null && previousDetails.live) {\n      const levelOrTrack = 'levelInfo' in data ? data.levelInfo : data.track;\n      details.reloaded(previousDetails);\n      // Merge live playlists to adjust fragment starts and fill in delta playlist skipped segments\n      if (previousDetails && details.fragments.length > 0) {\n        mergeDetails(previousDetails, details);\n        const error = details.playlistParsingError;\n        if (error) {\n          this.warn(error);\n          const hls = this.hls;\n          if (!hls.config.ignorePlaylistParsingErrors) {\n            var _details$fragments$;\n            const {\n              networkDetails\n            } = data;\n            hls.trigger(Events.ERROR, {\n              type: ErrorTypes.NETWORK_ERROR,\n              details: ErrorDetails.LEVEL_PARSING_ERROR,\n              fatal: false,\n              url: details.url,\n              error,\n              reason: error.message,\n              level: data.level || undefined,\n              parent: (_details$fragments$ = details.fragments[0]) == null ? void 0 : _details$fragments$.type,\n              networkDetails,\n              stats\n            });\n            return;\n          }\n          details.playlistParsingError = null;\n        }\n      }\n      if (details.requestScheduled === -1) {\n        details.requestScheduled = stats.loading.start;\n      }\n      const bufferInfo = this.hls.mainForwardBufferInfo;\n      const position = bufferInfo ? bufferInfo.end - bufferInfo.len : 0;\n      const distanceToLiveEdgeMs = (details.edge - position) * 1000;\n      const reloadInterval = computeReloadInterval(details, distanceToLiveEdgeMs);\n      if (details.requestScheduled + reloadInterval < now) {\n        details.requestScheduled = now;\n      } else {\n        details.requestScheduled += reloadInterval;\n      }\n      this.log(`live playlist ${index} ${details.advanced ? 'REFRESHED ' + details.lastPartSn + '-' + details.lastPartIndex : details.updated ? 'UPDATED' : 'MISSED'}`);\n      if (!this.canLoad || !details.live) {\n        return;\n      }\n      let deliveryDirectives;\n      let msn = undefined;\n      let part = undefined;\n      if (details.canBlockReload && details.endSN && details.advanced) {\n        // Load level with LL-HLS delivery directives\n        const lowLatencyMode = this.hls.config.lowLatencyMode;\n        const lastPartSn = details.lastPartSn;\n        const endSn = details.endSN;\n        const lastPartIndex = details.lastPartIndex;\n        const hasParts = lastPartIndex !== -1;\n        const atLastPartOfSegment = lastPartSn === endSn;\n        if (hasParts) {\n          // When low latency mode is disabled, request the last part of the next segment\n          if (atLastPartOfSegment) {\n            msn = endSn + 1;\n            part = lowLatencyMode ? 0 : lastPartIndex;\n          } else {\n            msn = lastPartSn;\n            part = lowLatencyMode ? lastPartIndex + 1 : details.maxPartIndex;\n          }\n        } else {\n          msn = endSn + 1;\n        }\n        // Low-Latency CDN Tune-in: \"age\" header and time since load indicates we're behind by more than one part\n        // Update directives to obtain the Playlist that has the estimated additional duration of media\n        const lastAdvanced = details.age;\n        const cdnAge = lastAdvanced + details.ageHeader;\n        let currentGoal = Math.min(cdnAge - details.partTarget, details.targetduration * 1.5);\n        if (currentGoal > 0) {\n          if (cdnAge > details.targetduration * 3) {\n            // Omit segment and part directives when the last response was more than 3 target durations ago,\n            this.log(`Playlist last advanced ${lastAdvanced.toFixed(2)}s ago. Omitting segment and part directives.`);\n            msn = undefined;\n            part = undefined;\n          } else if (previousDetails != null && previousDetails.tuneInGoal && cdnAge - details.partTarget > previousDetails.tuneInGoal) {\n            // If we attempted to get the next or latest playlist update, but currentGoal increased,\n            // then we either can't catchup, or the \"age\" header cannot be trusted.\n            this.warn(`CDN Tune-in goal increased from: ${previousDetails.tuneInGoal} to: ${currentGoal} with playlist age: ${details.age}`);\n            currentGoal = 0;\n          } else {\n            const segments = Math.floor(currentGoal / details.targetduration);\n            msn += segments;\n            if (part !== undefined) {\n              const parts = Math.round(currentGoal % details.targetduration / details.partTarget);\n              part += parts;\n            }\n            this.log(`CDN Tune-in age: ${details.ageHeader}s last advanced ${lastAdvanced.toFixed(2)}s goal: ${currentGoal} skip sn ${segments} to part ${part}`);\n          }\n          details.tuneInGoal = currentGoal;\n        }\n        deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);\n        if (lowLatencyMode || !atLastPartOfSegment) {\n          details.requestScheduled = now;\n          this.loadingPlaylist(levelOrTrack, deliveryDirectives);\n          return;\n        }\n      } else if (details.canBlockReload || details.canSkipUntil) {\n        deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);\n      }\n      if (deliveryDirectives && msn !== undefined && details.canBlockReload) {\n        details.requestScheduled = stats.loading.first + Math.max(reloadInterval - elapsed * 2, reloadInterval / 2);\n      }\n      this.scheduleLoading(levelOrTrack, deliveryDirectives, details);\n    } else {\n      this.clearTimer();\n    }\n  }\n  scheduleLoading(levelOrTrack, deliveryDirectives, updatedDetails) {\n    const details = updatedDetails || levelOrTrack.details;\n    if (!details) {\n      this.loadingPlaylist(levelOrTrack, deliveryDirectives);\n      return;\n    }\n    const now = self.performance.now();\n    const requestScheduled = details.requestScheduled;\n    if (now >= requestScheduled) {\n      this.loadingPlaylist(levelOrTrack, deliveryDirectives);\n      return;\n    }\n    const estimatedTimeUntilUpdate = requestScheduled - now;\n    this.log(`reload live playlist ${levelOrTrack.name || levelOrTrack.bitrate + 'bps'} in ${Math.round(estimatedTimeUntilUpdate)} ms`);\n    this.clearTimer();\n    this.timer = self.setTimeout(() => this.loadingPlaylist(levelOrTrack, deliveryDirectives), estimatedTimeUntilUpdate);\n  }\n  getDeliveryDirectives(details, previousDeliveryDirectives, msn, part) {\n    let skip = getSkipValue(details);\n    if (previousDeliveryDirectives != null && previousDeliveryDirectives.skip && details.deltaUpdateFailed) {\n      msn = previousDeliveryDirectives.msn;\n      part = previousDeliveryDirectives.part;\n      skip = HlsSkip.No;\n    }\n    return new HlsUrlParameters(msn, part, skip);\n  }\n  checkRetry(errorEvent) {\n    const errorDetails = errorEvent.details;\n    const isTimeout = isTimeoutError(errorEvent);\n    const errorAction = errorEvent.errorAction;\n    const {\n      action,\n      retryCount = 0,\n      retryConfig\n    } = errorAction || {};\n    const retry = !!errorAction && !!retryConfig && (action === NetworkErrorAction.RetryRequest || !errorAction.resolved && action === NetworkErrorAction.SendAlternateToPenaltyBox);\n    if (retry) {\n      var _errorEvent$context;\n      if (retryCount >= retryConfig.maxNumRetry) {\n        return false;\n      }\n      if (isTimeout && (_errorEvent$context = errorEvent.context) != null && _errorEvent$context.deliveryDirectives) {\n        // The LL-HLS request already timed out so retry immediately\n        this.warn(`Retrying playlist loading ${retryCount + 1}/${retryConfig.maxNumRetry} after \"${errorDetails}\" without delivery-directives`);\n        this.loadPlaylist();\n      } else {\n        const delay = getRetryDelay(retryConfig, retryCount);\n        // Schedule level/track reload\n        this.clearTimer();\n        this.timer = self.setTimeout(() => this.loadPlaylist(), delay);\n        this.warn(`Retrying playlist loading ${retryCount + 1}/${retryConfig.maxNumRetry} after \"${errorDetails}\" in ${delay}ms`);\n      }\n      // `levelRetry = true` used to inform other controllers that a retry is happening\n      errorEvent.levelRetry = true;\n      errorAction.resolved = true;\n    }\n    return retry;\n  }\n}\n\nfunction subtitleOptionsIdentical(trackList1, trackList2) {\n  if (trackList1.length !== trackList2.length) {\n    return false;\n  }\n  for (let i = 0; i < trackList1.length; i++) {\n    if (!mediaAttributesIdentical(trackList1[i].attrs, trackList2[i].attrs)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction mediaAttributesIdentical(attrs1, attrs2, customAttributes) {\n  // Media options with the same rendition ID must be bit identical\n  const stableRenditionId = attrs1['STABLE-RENDITION-ID'];\n  if (stableRenditionId && !customAttributes) {\n    return stableRenditionId === attrs2['STABLE-RENDITION-ID'];\n  }\n  // When rendition ID is not present, compare attributes\n  return !(customAttributes || ['LANGUAGE', 'NAME', 'CHARACTERISTICS', 'AUTOSELECT', 'DEFAULT', 'FORCED', 'ASSOC-LANGUAGE']).some(subtitleAttribute => attrs1[subtitleAttribute] !== attrs2[subtitleAttribute]);\n}\nfunction subtitleTrackMatchesTextTrack(subtitleTrack, textTrack) {\n  return textTrack.label.toLowerCase() === subtitleTrack.name.toLowerCase() && (!textTrack.language || textTrack.language.toLowerCase() === (subtitleTrack.lang || '').toLowerCase());\n}\n\nclass AudioTrackController extends BasePlaylistController {\n  constructor(hls) {\n    super(hls, 'audio-track-controller');\n    this.tracks = [];\n    this.groupIds = null;\n    this.tracksInGroup = [];\n    this.trackId = -1;\n    this.currentTrack = null;\n    this.selectDefaultTrack = true;\n    this.registerListeners();\n  }\n  registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.on(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n    hls.on(Events.ERROR, this.onError, this);\n  }\n  unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.off(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n    hls.off(Events.ERROR, this.onError, this);\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.tracks.length = 0;\n    this.tracksInGroup.length = 0;\n    this.currentTrack = null;\n    super.destroy();\n  }\n  onManifestLoading() {\n    this.tracks = [];\n    this.tracksInGroup = [];\n    this.groupIds = null;\n    this.currentTrack = null;\n    this.trackId = -1;\n    this.selectDefaultTrack = true;\n  }\n  onManifestParsed(event, data) {\n    this.tracks = data.audioTracks || [];\n  }\n  onAudioTrackLoaded(event, data) {\n    const {\n      id,\n      groupId,\n      details\n    } = data;\n    const trackInActiveGroup = this.tracksInGroup[id];\n    if (!trackInActiveGroup || trackInActiveGroup.groupId !== groupId) {\n      this.warn(`Audio track with id:${id} and group:${groupId} not found in active group ${trackInActiveGroup == null ? void 0 : trackInActiveGroup.groupId}`);\n      return;\n    }\n    const curDetails = trackInActiveGroup.details;\n    trackInActiveGroup.details = data.details;\n    this.log(`Audio track ${id} \"${trackInActiveGroup.name}\" lang:${trackInActiveGroup.lang} group:${groupId} loaded [${details.startSN}-${details.endSN}]`);\n    if (id === this.trackId) {\n      this.playlistLoaded(id, data, curDetails);\n    }\n  }\n  onLevelLoading(event, data) {\n    this.switchLevel(data.level);\n  }\n  onLevelSwitching(event, data) {\n    this.switchLevel(data.level);\n  }\n  switchLevel(levelIndex) {\n    const levelInfo = this.hls.levels[levelIndex];\n    if (!levelInfo) {\n      return;\n    }\n    const audioGroups = levelInfo.audioGroups || null;\n    const currentGroups = this.groupIds;\n    let currentTrack = this.currentTrack;\n    if (!audioGroups || (currentGroups == null ? void 0 : currentGroups.length) !== (audioGroups == null ? void 0 : audioGroups.length) || audioGroups != null && audioGroups.some(groupId => (currentGroups == null ? void 0 : currentGroups.indexOf(groupId)) === -1)) {\n      this.groupIds = audioGroups;\n      this.trackId = -1;\n      this.currentTrack = null;\n      const audioTracks = this.tracks.filter(track => !audioGroups || audioGroups.indexOf(track.groupId) !== -1);\n      if (audioTracks.length) {\n        // Disable selectDefaultTrack if there are no default tracks\n        if (this.selectDefaultTrack && !audioTracks.some(track => track.default)) {\n          this.selectDefaultTrack = false;\n        }\n        // track.id should match hls.audioTracks index\n        audioTracks.forEach((track, i) => {\n          track.id = i;\n        });\n      } else if (!currentTrack && !this.tracksInGroup.length) {\n        // Do not dispatch AUDIO_TRACKS_UPDATED when there were and are no tracks\n        return;\n      }\n      this.tracksInGroup = audioTracks;\n\n      // Find preferred track\n      const audioPreference = this.hls.config.audioPreference;\n      if (!currentTrack && audioPreference) {\n        const groupIndex = findMatchingOption(audioPreference, audioTracks, audioMatchPredicate);\n        if (groupIndex > -1) {\n          currentTrack = audioTracks[groupIndex];\n        } else {\n          const allIndex = findMatchingOption(audioPreference, this.tracks);\n          currentTrack = this.tracks[allIndex];\n        }\n      }\n\n      // Select initial track\n      let trackId = this.findTrackId(currentTrack);\n      if (trackId === -1 && currentTrack) {\n        trackId = this.findTrackId(null);\n      }\n\n      // Dispatch events and load track if needed\n      const audioTracksUpdated = {\n        audioTracks\n      };\n      this.log(`Updating audio tracks, ${audioTracks.length} track(s) found in group(s): ${audioGroups == null ? void 0 : audioGroups.join(',')}`);\n      this.hls.trigger(Events.AUDIO_TRACKS_UPDATED, audioTracksUpdated);\n      const selectedTrackId = this.trackId;\n      if (trackId !== -1 && selectedTrackId === -1) {\n        this.setAudioTrack(trackId);\n      } else if (audioTracks.length && selectedTrackId === -1) {\n        var _this$groupIds;\n        const error = new Error(`No audio track selected for current audio group-ID(s): ${(_this$groupIds = this.groupIds) == null ? void 0 : _this$groupIds.join(',')} track count: ${audioTracks.length}`);\n        this.warn(error.message);\n        this.hls.trigger(Events.ERROR, {\n          type: ErrorTypes.MEDIA_ERROR,\n          details: ErrorDetails.AUDIO_TRACK_LOAD_ERROR,\n          fatal: true,\n          error\n        });\n      }\n    }\n  }\n  onError(event, data) {\n    if (data.fatal || !data.context) {\n      return;\n    }\n    if (data.context.type === PlaylistContextType.AUDIO_TRACK && data.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(data.context.groupId) !== -1)) {\n      this.checkRetry(data);\n    }\n  }\n  get allAudioTracks() {\n    return this.tracks;\n  }\n  get audioTracks() {\n    return this.tracksInGroup;\n  }\n  get audioTrack() {\n    return this.trackId;\n  }\n  set audioTrack(newId) {\n    // If audio track is selected from API then don't choose from the manifest default track\n    this.selectDefaultTrack = false;\n    this.setAudioTrack(newId);\n  }\n  setAudioOption(audioOption) {\n    const hls = this.hls;\n    hls.config.audioPreference = audioOption;\n    if (audioOption) {\n      const allAudioTracks = this.allAudioTracks;\n      this.selectDefaultTrack = false;\n      if (allAudioTracks.length) {\n        // First see if current option matches (no switch op)\n        const currentTrack = this.currentTrack;\n        if (currentTrack && matchesOption(audioOption, currentTrack, audioMatchPredicate)) {\n          return currentTrack;\n        }\n        // Find option in available tracks (tracksInGroup)\n        const groupIndex = findMatchingOption(audioOption, this.tracksInGroup, audioMatchPredicate);\n        if (groupIndex > -1) {\n          const track = this.tracksInGroup[groupIndex];\n          this.setAudioTrack(groupIndex);\n          return track;\n        } else if (currentTrack) {\n          // Find option in nearest level audio group\n          let searchIndex = hls.loadLevel;\n          if (searchIndex === -1) {\n            searchIndex = hls.firstAutoLevel;\n          }\n          const switchIndex = findClosestLevelWithAudioGroup(audioOption, hls.levels, allAudioTracks, searchIndex, audioMatchPredicate);\n          if (switchIndex === -1) {\n            // could not find matching variant\n            return null;\n          }\n          // and switch level to acheive the audio group switch\n          hls.nextLoadLevel = switchIndex;\n        }\n        if (audioOption.channels || audioOption.audioCodec) {\n          // Could not find a match with codec / channels predicate\n          // Find a match without channels or codec\n          const withoutCodecAndChannelsMatch = findMatchingOption(audioOption, allAudioTracks);\n          if (withoutCodecAndChannelsMatch > -1) {\n            return allAudioTracks[withoutCodecAndChannelsMatch];\n          }\n        }\n      }\n    }\n    return null;\n  }\n  setAudioTrack(newId) {\n    const tracks = this.tracksInGroup;\n\n    // check if level idx is valid\n    if (newId < 0 || newId >= tracks.length) {\n      this.warn(`Invalid audio track id: ${newId}`);\n      return;\n    }\n    this.selectDefaultTrack = false;\n    const lastTrack = this.currentTrack;\n    const track = tracks[newId];\n    const trackLoaded = track.details && !track.details.live;\n    if (newId === this.trackId && track === lastTrack && trackLoaded) {\n      return;\n    }\n    this.log(`Switching to audio-track ${newId} \"${track.name}\" lang:${track.lang} group:${track.groupId} channels:${track.channels}`);\n    this.trackId = newId;\n    this.currentTrack = track;\n    this.hls.trigger(Events.AUDIO_TRACK_SWITCHING, _objectSpread2({}, track));\n    // Do not reload track unless live\n    if (trackLoaded) {\n      return;\n    }\n    const hlsUrlParameters = this.switchParams(track.url, lastTrack == null ? void 0 : lastTrack.details, track.details);\n    this.loadPlaylist(hlsUrlParameters);\n  }\n  findTrackId(currentTrack) {\n    const audioTracks = this.tracksInGroup;\n    for (let i = 0; i < audioTracks.length; i++) {\n      const track = audioTracks[i];\n      if (this.selectDefaultTrack && !track.default) {\n        continue;\n      }\n      if (!currentTrack || matchesOption(currentTrack, track, audioMatchPredicate)) {\n        return i;\n      }\n    }\n    if (currentTrack) {\n      const {\n        name,\n        lang,\n        assocLang,\n        characteristics,\n        audioCodec,\n        channels\n      } = currentTrack;\n      for (let i = 0; i < audioTracks.length; i++) {\n        const track = audioTracks[i];\n        if (matchesOption({\n          name,\n          lang,\n          assocLang,\n          characteristics,\n          audioCodec,\n          channels\n        }, track, audioMatchPredicate)) {\n          return i;\n        }\n      }\n      for (let i = 0; i < audioTracks.length; i++) {\n        const track = audioTracks[i];\n        if (mediaAttributesIdentical(currentTrack.attrs, track.attrs, ['LANGUAGE', 'ASSOC-LANGUAGE', 'CHARACTERISTICS'])) {\n          return i;\n        }\n      }\n      for (let i = 0; i < audioTracks.length; i++) {\n        const track = audioTracks[i];\n        if (mediaAttributesIdentical(currentTrack.attrs, track.attrs, ['LANGUAGE'])) {\n          return i;\n        }\n      }\n    }\n    return -1;\n  }\n  loadPlaylist(hlsUrlParameters) {\n    super.loadPlaylist();\n    const audioTrack = this.currentTrack;\n    if (!this.shouldLoadPlaylist(audioTrack)) {\n      return;\n    }\n    // Do not load audio rendition with URI matching main variant URI\n    if (useAlternateAudio(audioTrack.url, this.hls)) {\n      this.scheduleLoading(audioTrack, hlsUrlParameters);\n    }\n  }\n  loadingPlaylist(audioTrack, hlsUrlParameters) {\n    super.loadingPlaylist(audioTrack, hlsUrlParameters);\n    const id = audioTrack.id;\n    const groupId = audioTrack.groupId;\n    const url = this.getUrlWithDirectives(audioTrack.url, hlsUrlParameters);\n    const details = audioTrack.details;\n    const age = details == null ? void 0 : details.age;\n    this.log(`Loading audio-track ${id} \"${audioTrack.name}\" lang:${audioTrack.lang} group:${groupId}${(hlsUrlParameters == null ? void 0 : hlsUrlParameters.msn) !== undefined ? ' at sn ' + hlsUrlParameters.msn + ' part ' + hlsUrlParameters.part : ''}${age && details.live ? ' age ' + age.toFixed(1) + (details.type ? ' ' + details.type || 0 : '') : ''} ${url}`);\n    this.hls.trigger(Events.AUDIO_TRACK_LOADING, {\n      url,\n      id,\n      groupId,\n      deliveryDirectives: hlsUrlParameters || null,\n      track: audioTrack\n    });\n  }\n}\n\nclass BufferOperationQueue {\n  constructor(sourceBufferReference) {\n    this.tracks = void 0;\n    this.queues = {\n      video: [],\n      audio: [],\n      audiovideo: []\n    };\n    this.tracks = sourceBufferReference;\n  }\n  destroy() {\n    this.tracks = this.queues = null;\n  }\n  append(operation, type, pending) {\n    if (this.queues === null || this.tracks === null) {\n      return;\n    }\n    const queue = this.queues[type];\n    queue.push(operation);\n    if (queue.length === 1 && !pending) {\n      this.executeNext(type);\n    }\n  }\n  appendBlocker(type) {\n    return new Promise(resolve => {\n      const operation = {\n        label: 'async-blocker',\n        execute: resolve,\n        onStart: () => {},\n        onComplete: () => {},\n        onError: () => {}\n      };\n      this.append(operation, type);\n    });\n  }\n  prependBlocker(type) {\n    return new Promise(resolve => {\n      if (this.queues) {\n        const operation = {\n          label: 'async-blocker-prepend',\n          execute: resolve,\n          onStart: () => {},\n          onComplete: () => {},\n          onError: () => {}\n        };\n        this.queues[type].unshift(operation);\n      }\n    });\n  }\n  removeBlockers() {\n    if (this.queues === null) {\n      return;\n    }\n    [this.queues.video, this.queues.audio, this.queues.audiovideo].forEach(queue => {\n      var _queue$;\n      const label = (_queue$ = queue[0]) == null ? void 0 : _queue$.label;\n      if (label === 'async-blocker' || label === 'async-blocker-prepend') {\n        queue[0].execute();\n        queue.splice(0, 1);\n      }\n    });\n  }\n  unblockAudio(op) {\n    if (this.queues === null) {\n      return;\n    }\n    const queue = this.queues.audio;\n    if (queue[0] === op) {\n      this.shiftAndExecuteNext('audio');\n    }\n  }\n  executeNext(type) {\n    if (this.queues === null || this.tracks === null) {\n      return;\n    }\n    const queue = this.queues[type];\n    if (queue.length) {\n      const operation = queue[0];\n      try {\n        // Operations are expected to result in an 'updateend' event being fired. If not, the queue will lock. Operations\n        // which do not end with this event must call _onSBUpdateEnd manually\n        operation.execute();\n      } catch (error) {\n        var _this$tracks$type;\n        operation.onError(error);\n        if (this.queues === null || this.tracks === null) {\n          return;\n        }\n\n        // Only shift the current operation off, otherwise the updateend handler will do this for us\n        const sb = (_this$tracks$type = this.tracks[type]) == null ? void 0 : _this$tracks$type.buffer;\n        if (!(sb != null && sb.updating)) {\n          this.shiftAndExecuteNext(type);\n        }\n      }\n    }\n  }\n  shiftAndExecuteNext(type) {\n    if (this.queues === null) {\n      return;\n    }\n    this.queues[type].shift();\n    this.executeNext(type);\n  }\n  current(type) {\n    var _this$queues;\n    return ((_this$queues = this.queues) == null ? void 0 : _this$queues[type][0]) || null;\n  }\n  toString() {\n    const {\n      queues,\n      tracks\n    } = this;\n    if (queues === null || tracks === null) {\n      return `<destroyed>`;\n    }\n    return `\n${this.list('video')}\n${this.list('audio')}\n${this.list('audiovideo')}}`;\n  }\n  list(type) {\n    var _this$queues2, _this$tracks;\n    return (_this$queues2 = this.queues) != null && _this$queues2[type] || (_this$tracks = this.tracks) != null && _this$tracks[type] ? `${type}: (${this.listSbInfo(type)}) ${this.listOps(type)}` : '';\n  }\n  listSbInfo(type) {\n    var _this$tracks2;\n    const track = (_this$tracks2 = this.tracks) == null ? void 0 : _this$tracks2[type];\n    const sb = track == null ? void 0 : track.buffer;\n    if (!sb) {\n      return 'none';\n    }\n    return `SourceBuffer${sb.updating ? ' updating' : ''}${track.ended ? ' ended' : ''}${track.ending ? ' ending' : ''}`;\n  }\n  listOps(type) {\n    var _this$queues3;\n    return ((_this$queues3 = this.queues) == null ? void 0 : _this$queues3[type].map(op => op.label).join(', ')) || '';\n  }\n}\n\nconst VIDEO_CODEC_PROFILE_REPLACE = /(avc[1234]|hvc1|hev1|dvh[1e]|vp09|av01)(?:\\.[^.,]+)+/;\nconst TRACK_REMOVED_ERROR_NAME = 'HlsJsTrackRemovedError';\nclass HlsJsTrackRemovedError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = TRACK_REMOVED_ERROR_NAME;\n  }\n}\nclass BufferController extends Logger {\n  constructor(hls, fragmentTracker) {\n    super('buffer-controller', hls.logger);\n    this.hls = void 0;\n    this.fragmentTracker = void 0;\n    // The level details used to determine duration, target-duration and live\n    this.details = null;\n    // cache the self generated object url to detect hijack of video tag\n    this._objectUrl = null;\n    // A queue of buffer operations which require the SourceBuffer to not be updating upon execution\n    this.operationQueue = null;\n    // The total number track codecs expected before any sourceBuffers are created (2: audio and video or 1: audiovideo | audio | video)\n    this.bufferCodecEventsTotal = 0;\n    // A reference to the attached media element\n    this.media = null;\n    // A reference to the active media source\n    this.mediaSource = null;\n    // Last MP3 audio chunk appended\n    this.lastMpegAudioChunk = null;\n    // Audio fragment blocked from appending until corresponding video appends or context changes\n    this.blockedAudioAppend = null;\n    // Keep track of video append position for unblocking audio\n    this.lastVideoAppendEnd = 0;\n    // Whether or not to use ManagedMediaSource API and append source element to media element.\n    this.appendSource = void 0;\n    // Transferred MediaSource information used to detmerine if duration end endstream may be appended\n    this.transferData = void 0;\n    // Directives used to override default MediaSource handling\n    this.overrides = void 0;\n    // Error counters\n    this.appendErrors = {\n      audio: 0,\n      video: 0,\n      audiovideo: 0\n    };\n    // Record of required or created buffers by type. SourceBuffer is stored in Track.buffer once created.\n    this.tracks = {};\n    // Array of SourceBuffer type and SourceBuffer (or null). One entry per TrackSet in this.tracks.\n    this.sourceBuffers = [[null, null], [null, null]];\n    this._onEndStreaming = event => {\n      var _this$mediaSource;\n      if (!this.hls) {\n        return;\n      }\n      if (((_this$mediaSource = this.mediaSource) == null ? void 0 : _this$mediaSource.readyState) !== 'open') {\n        return;\n      }\n      this.hls.pauseBuffering();\n    };\n    this._onStartStreaming = event => {\n      if (!this.hls) {\n        return;\n      }\n      this.hls.resumeBuffering();\n    };\n    // Keep as arrow functions so that we can directly reference these functions directly as event listeners\n    this._onMediaSourceOpen = e => {\n      const {\n        media,\n        mediaSource\n      } = this;\n      if (e) {\n        this.log('Media source opened');\n      }\n      if (!media || !mediaSource) {\n        return;\n      }\n      // once received, don't listen anymore to sourceopen event\n      mediaSource.removeEventListener('sourceopen', this._onMediaSourceOpen);\n      media.removeEventListener('emptied', this._onMediaEmptied);\n      this.updateDuration();\n      this.hls.trigger(Events.MEDIA_ATTACHED, {\n        media,\n        mediaSource: mediaSource\n      });\n      if (this.mediaSource !== null) {\n        this.checkPendingTracks();\n      }\n    };\n    this._onMediaSourceClose = () => {\n      this.log('Media source closed');\n    };\n    this._onMediaSourceEnded = () => {\n      this.log('Media source ended');\n    };\n    this._onMediaEmptied = () => {\n      const {\n        mediaSrc,\n        _objectUrl\n      } = this;\n      if (mediaSrc !== _objectUrl) {\n        this.error(`Media element src was set while attaching MediaSource (${_objectUrl} > ${mediaSrc})`);\n      }\n    };\n    this.hls = hls;\n    this.fragmentTracker = fragmentTracker;\n    this.appendSource = isManagedMediaSource(getMediaSource(hls.config.preferManagedMediaSource));\n    this.initTracks();\n    this.registerListeners();\n  }\n  hasSourceTypes() {\n    return Object.keys(this.tracks).length > 0;\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.details = null;\n    this.lastMpegAudioChunk = this.blockedAudioAppend = null;\n    this.transferData = this.overrides = undefined;\n    if (this.operationQueue) {\n      this.operationQueue.destroy();\n      this.operationQueue = null;\n    }\n    // @ts-ignore\n    this.hls = this.fragmentTracker = null;\n    // @ts-ignore\n    this._onMediaSourceOpen = this._onMediaSourceClose = null;\n    // @ts-ignore\n    this._onMediaSourceEnded = null;\n    // @ts-ignore\n    this._onStartStreaming = this._onEndStreaming = null;\n  }\n  registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(Events.BUFFER_RESET, this.onBufferReset, this);\n    hls.on(Events.BUFFER_APPENDING, this.onBufferAppending, this);\n    hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n    hls.on(Events.BUFFER_EOS, this.onBufferEos, this);\n    hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    hls.on(Events.FRAG_PARSED, this.onFragParsed, this);\n    hls.on(Events.FRAG_CHANGED, this.onFragChanged, this);\n    hls.on(Events.ERROR, this.onError, this);\n  }\n  unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(Events.BUFFER_RESET, this.onBufferReset, this);\n    hls.off(Events.BUFFER_APPENDING, this.onBufferAppending, this);\n    hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n    hls.off(Events.BUFFER_EOS, this.onBufferEos, this);\n    hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    hls.off(Events.FRAG_PARSED, this.onFragParsed, this);\n    hls.off(Events.FRAG_CHANGED, this.onFragChanged, this);\n    hls.off(Events.ERROR, this.onError, this);\n  }\n  transferMedia() {\n    const {\n      media,\n      mediaSource\n    } = this;\n    if (!media) {\n      return null;\n    }\n    const tracks = {};\n    if (this.operationQueue) {\n      const updating = this.isUpdating();\n      if (!updating) {\n        this.operationQueue.removeBlockers();\n      }\n      const queued = this.isQueued();\n      if (updating || queued) {\n        this.warn(`Transfering MediaSource with${queued ? ' operations in queue' : ''}${updating ? ' updating SourceBuffer(s)' : ''} ${this.operationQueue}`);\n      }\n      this.operationQueue.destroy();\n    }\n    const transferData = this.transferData;\n    if (!this.sourceBufferCount && transferData && transferData.mediaSource === mediaSource) {\n      _extends(tracks, transferData.tracks);\n    } else {\n      this.sourceBuffers.forEach(tuple => {\n        const [type] = tuple;\n        if (type) {\n          tracks[type] = _extends({}, this.tracks[type]);\n          this.removeBuffer(type);\n        }\n        tuple[0] = tuple[1] = null;\n      });\n    }\n    return {\n      media,\n      mediaSource,\n      tracks\n    };\n  }\n  initTracks() {\n    const tracks = {};\n    this.sourceBuffers = [[null, null], [null, null]];\n    this.tracks = tracks;\n    this.resetQueue();\n    this.resetAppendErrors();\n    this.lastMpegAudioChunk = this.blockedAudioAppend = null;\n    this.lastVideoAppendEnd = 0;\n  }\n  onManifestLoading() {\n    this.bufferCodecEventsTotal = 0;\n    this.details = null;\n  }\n  onManifestParsed(event, data) {\n    var _this$transferData;\n    // in case of alt audio 2 BUFFER_CODECS events will be triggered, one per stream controller\n    // sourcebuffers will be created all at once when the expected nb of tracks will be reached\n    // in case alt audio is not used, only one BUFFER_CODEC event will be fired from main stream controller\n    // it will contain the expected nb of source buffers, no need to compute it\n    let codecEvents = 2;\n    if (data.audio && !data.video || !data.altAudio) {\n      codecEvents = 1;\n    }\n    this.bufferCodecEventsTotal = codecEvents;\n    this.log(`${codecEvents} bufferCodec event(s) expected.`);\n    if ((_this$transferData = this.transferData) != null && _this$transferData.mediaSource && this.sourceBufferCount && codecEvents) {\n      this.bufferCreated();\n    }\n  }\n  onMediaAttaching(event, data) {\n    const media = this.media = data.media;\n    const MediaSource = getMediaSource(this.appendSource);\n    this.transferData = this.overrides = undefined;\n    if (media && MediaSource) {\n      const transferringMedia = !!data.mediaSource;\n      if (transferringMedia || data.overrides) {\n        this.transferData = data;\n        this.overrides = data.overrides;\n      }\n      const ms = this.mediaSource = data.mediaSource || new MediaSource();\n      this.assignMediaSource(ms);\n      if (transferringMedia) {\n        this._objectUrl = media.src;\n        this.attachTransferred();\n      } else {\n        // cache the locally generated object url\n        const objectUrl = this._objectUrl = self.URL.createObjectURL(ms);\n        // link video and media Source\n        if (this.appendSource) {\n          try {\n            media.removeAttribute('src');\n            // ManagedMediaSource will not open without disableRemotePlayback set to false or source alternatives\n            const MMS = self.ManagedMediaSource;\n            media.disableRemotePlayback = media.disableRemotePlayback || MMS && ms instanceof MMS;\n            removeSourceChildren(media);\n            addSource(media, objectUrl);\n            media.load();\n          } catch (error) {\n            media.src = objectUrl;\n          }\n        } else {\n          media.src = objectUrl;\n        }\n      }\n      media.addEventListener('emptied', this._onMediaEmptied);\n    }\n  }\n  assignMediaSource(ms) {\n    var _this$transferData2, _ms$constructor;\n    this.log(`${((_this$transferData2 = this.transferData) == null ? void 0 : _this$transferData2.mediaSource) === ms ? 'transferred' : 'created'} media source: ${(_ms$constructor = ms.constructor) == null ? void 0 : _ms$constructor.name}`);\n    // MediaSource listeners are arrow functions with a lexical scope, and do not need to be bound\n    ms.addEventListener('sourceopen', this._onMediaSourceOpen);\n    ms.addEventListener('sourceended', this._onMediaSourceEnded);\n    ms.addEventListener('sourceclose', this._onMediaSourceClose);\n    if (this.appendSource) {\n      ms.addEventListener('startstreaming', this._onStartStreaming);\n      ms.addEventListener('endstreaming', this._onEndStreaming);\n    }\n  }\n  attachTransferred() {\n    const media = this.media;\n    const data = this.transferData;\n    if (!data || !media) {\n      return;\n    }\n    const requiredTracks = this.tracks;\n    const transferredTracks = data.tracks;\n    const trackNames = transferredTracks ? Object.keys(transferredTracks) : null;\n    const trackCount = trackNames ? trackNames.length : 0;\n    const mediaSourceOpenCallback = () => {\n      if (this.media && this.mediaSourceOpenOrEnded) {\n        this._onMediaSourceOpen();\n      }\n    };\n    if (transferredTracks && trackNames && trackCount) {\n      if (!this.tracksReady) {\n        // Wait for CODECS event(s)\n        this.hls.config.startFragPrefetch = true;\n        this.log(`attachTransferred: waiting for SourceBuffer track info`);\n        return;\n      }\n      this.log(`attachTransferred: (bufferCodecEventsTotal ${this.bufferCodecEventsTotal})\nrequired tracks: ${stringify(requiredTracks, (key, value) => key === 'initSegment' ? undefined : value)};\ntransfer tracks: ${stringify(transferredTracks, (key, value) => key === 'initSegment' ? undefined : value)}}`);\n      if (!isCompatibleTrackChange(transferredTracks, requiredTracks)) {\n        // destroy attaching media source\n        data.mediaSource = null;\n        data.tracks = undefined;\n        const currentTime = media.currentTime;\n        const details = this.details;\n        const startTime = Math.max(currentTime, (details == null ? void 0 : details.fragments[0].start) || 0);\n        if (startTime - currentTime > 1) {\n          this.log(`attachTransferred: waiting for playback to reach new tracks start time ${currentTime} -> ${startTime}`);\n          return;\n        }\n        this.warn(`attachTransferred: resetting MediaSource for incompatible tracks (\"${Object.keys(transferredTracks)}\"->\"${Object.keys(requiredTracks)}\") start time: ${startTime} currentTime: ${currentTime}`);\n        this.onMediaDetaching(Events.MEDIA_DETACHING, {});\n        this.onMediaAttaching(Events.MEDIA_ATTACHING, data);\n        media.currentTime = startTime;\n        return;\n      }\n      this.transferData = undefined;\n      trackNames.forEach(trackName => {\n        const type = trackName;\n        const track = transferredTracks[type];\n        if (track) {\n          const sb = track.buffer;\n          if (sb) {\n            // Purge fragment tracker of ejected segments for existing buffer\n            const fragmentTracker = this.fragmentTracker;\n            const playlistType = track.id;\n            if (fragmentTracker.hasFragments(playlistType) || fragmentTracker.hasParts(playlistType)) {\n              const bufferedTimeRanges = BufferHelper.getBuffered(sb);\n              fragmentTracker.detectEvictedFragments(type, bufferedTimeRanges, playlistType, null, true);\n            }\n            // Transfer SourceBuffer\n            const sbIndex = sourceBufferNameToIndex(type);\n            const sbTuple = [type, sb];\n            this.sourceBuffers[sbIndex] = sbTuple;\n            if (sb.updating && this.operationQueue) {\n              this.operationQueue.prependBlocker(type);\n            }\n            this.trackSourceBuffer(type, track);\n          }\n        }\n      });\n      mediaSourceOpenCallback();\n      this.bufferCreated();\n    } else {\n      this.log(`attachTransferred: MediaSource w/o SourceBuffers`);\n      mediaSourceOpenCallback();\n    }\n  }\n  get mediaSourceOpenOrEnded() {\n    var _this$mediaSource2;\n    const readyState = (_this$mediaSource2 = this.mediaSource) == null ? void 0 : _this$mediaSource2.readyState;\n    return readyState === 'open' || readyState === 'ended';\n  }\n  onMediaDetaching(event, data) {\n    const transferringMedia = !!data.transferMedia;\n    this.transferData = this.overrides = undefined;\n    const {\n      media,\n      mediaSource,\n      _objectUrl\n    } = this;\n    if (mediaSource) {\n      this.log(`media source ${transferringMedia ? 'transferring' : 'detaching'}`);\n      if (transferringMedia) {\n        // Detach SourceBuffers without removing from MediaSource\n        // and leave `tracks` (required SourceBuffers configuration)\n        this.sourceBuffers.forEach(([type]) => {\n          if (type) {\n            this.removeBuffer(type);\n          }\n        });\n        this.resetQueue();\n      } else {\n        if (this.mediaSourceOpenOrEnded) {\n          const open = mediaSource.readyState === 'open';\n          try {\n            const sourceBuffers = mediaSource.sourceBuffers;\n            for (let i = sourceBuffers.length; i--;) {\n              if (open) {\n                sourceBuffers[i].abort();\n              }\n              mediaSource.removeSourceBuffer(sourceBuffers[i]);\n            }\n            if (open) {\n              // endOfStream could trigger exception if any sourcebuffer is in updating state\n              // we don't really care about checking sourcebuffer state here,\n              // as we are anyway detaching the MediaSource\n              // let's just avoid this exception to propagate\n              mediaSource.endOfStream();\n            }\n          } catch (err) {\n            this.warn(`onMediaDetaching: ${err.message} while calling endOfStream`);\n          }\n        }\n        // Clean up the SourceBuffers by invoking onBufferReset\n        if (this.sourceBufferCount) {\n          this.onBufferReset();\n        }\n      }\n      mediaSource.removeEventListener('sourceopen', this._onMediaSourceOpen);\n      mediaSource.removeEventListener('sourceended', this._onMediaSourceEnded);\n      mediaSource.removeEventListener('sourceclose', this._onMediaSourceClose);\n      if (this.appendSource) {\n        mediaSource.removeEventListener('startstreaming', this._onStartStreaming);\n        mediaSource.removeEventListener('endstreaming', this._onEndStreaming);\n      }\n      this.mediaSource = null;\n      this._objectUrl = null;\n    }\n\n    // Detach properly the MediaSource from the HTMLMediaElement as\n    // suggested in https://github.com/w3c/media-source/issues/53.\n    if (media) {\n      media.removeEventListener('emptied', this._onMediaEmptied);\n      if (!transferringMedia) {\n        if (_objectUrl) {\n          self.URL.revokeObjectURL(_objectUrl);\n        }\n\n        // clean up video tag src only if it's our own url. some external libraries might\n        // hijack the video tag and change its 'src' without destroying the Hls instance first\n        if (this.mediaSrc === _objectUrl) {\n          media.removeAttribute('src');\n          if (this.appendSource) {\n            removeSourceChildren(media);\n          }\n          media.load();\n        } else {\n          this.warn('media|source.src was changed by a third party - skip cleanup');\n        }\n      }\n      this.media = null;\n    }\n    this.hls.trigger(Events.MEDIA_DETACHED, data);\n  }\n  onBufferReset() {\n    this.sourceBuffers.forEach(([type]) => {\n      if (type) {\n        this.resetBuffer(type);\n      }\n    });\n    this.initTracks();\n  }\n  resetBuffer(type) {\n    var _this$tracks$type;\n    const sb = (_this$tracks$type = this.tracks[type]) == null ? void 0 : _this$tracks$type.buffer;\n    this.removeBuffer(type);\n    if (sb) {\n      try {\n        var _this$mediaSource3;\n        if ((_this$mediaSource3 = this.mediaSource) != null && _this$mediaSource3.sourceBuffers.length) {\n          this.mediaSource.removeSourceBuffer(sb);\n        }\n      } catch (err) {\n        this.warn(`onBufferReset ${type}`, err);\n      }\n    }\n    delete this.tracks[type];\n  }\n  removeBuffer(type) {\n    this.removeBufferListeners(type);\n    this.sourceBuffers[sourceBufferNameToIndex(type)] = [null, null];\n    const track = this.tracks[type];\n    if (track) {\n      track.buffer = undefined;\n    }\n  }\n  resetQueue() {\n    if (this.operationQueue) {\n      this.operationQueue.destroy();\n    }\n    this.operationQueue = new BufferOperationQueue(this.tracks);\n  }\n  onBufferCodecs(event, data) {\n    const tracks = this.tracks;\n    const trackNames = Object.keys(data);\n    this.log(`BUFFER_CODECS: \"${trackNames}\" (current SB count ${this.sourceBufferCount})`);\n    const unmuxedToMuxed = 'audiovideo' in data && (tracks.audio || tracks.video) || tracks.audiovideo && ('audio' in data || 'video' in data);\n    const muxedToUnmuxed = !unmuxedToMuxed && this.sourceBufferCount && this.media && trackNames.some(sbName => !tracks[sbName]);\n    if (unmuxedToMuxed || muxedToUnmuxed) {\n      this.warn(`Unsupported transition between \"${Object.keys(tracks)}\" and \"${trackNames}\" SourceBuffers`);\n      // Do not add incompatible track ('audiovideo' <-> 'video'/'audio').\n      // Allow following onBufferAppending handle to trigger BUFFER_APPEND_ERROR.\n      // This will either be resolved by level switch or could be handled with recoverMediaError().\n      return;\n    }\n    trackNames.forEach(trackName => {\n      var _this$transferData3, _this$transferData3$t, _trackCodec;\n      const parsedTrack = data[trackName];\n      const {\n        id,\n        codec,\n        levelCodec,\n        container,\n        metadata,\n        supplemental\n      } = parsedTrack;\n      let track = tracks[trackName];\n      const transferredTrack = (_this$transferData3 = this.transferData) == null ? void 0 : (_this$transferData3$t = _this$transferData3.tracks) == null ? void 0 : _this$transferData3$t[trackName];\n      const sbTrack = transferredTrack != null && transferredTrack.buffer ? transferredTrack : track;\n      const sbCodec = (sbTrack == null ? void 0 : sbTrack.pendingCodec) || (sbTrack == null ? void 0 : sbTrack.codec);\n      const trackLevelCodec = sbTrack == null ? void 0 : sbTrack.levelCodec;\n      if (!track) {\n        track = tracks[trackName] = {\n          buffer: undefined,\n          listeners: [],\n          codec,\n          supplemental,\n          container,\n          levelCodec,\n          metadata,\n          id\n        };\n      }\n      // check if SourceBuffer codec needs to change\n      const currentCodecFull = pickMostCompleteCodecName(sbCodec, trackLevelCodec);\n      const currentCodec = currentCodecFull == null ? void 0 : currentCodecFull.replace(VIDEO_CODEC_PROFILE_REPLACE, '$1');\n      let trackCodec = pickMostCompleteCodecName(codec, levelCodec);\n      const nextCodec = (_trackCodec = trackCodec) == null ? void 0 : _trackCodec.replace(VIDEO_CODEC_PROFILE_REPLACE, '$1');\n      if (trackCodec && currentCodecFull && currentCodec !== nextCodec) {\n        if (trackName.slice(0, 5) === 'audio') {\n          trackCodec = getCodecCompatibleName(trackCodec, this.appendSource);\n        }\n        this.log(`switching codec ${sbCodec} to ${trackCodec}`);\n        if (trackCodec !== (track.pendingCodec || track.codec)) {\n          track.pendingCodec = trackCodec;\n        }\n        track.container = container;\n        this.appendChangeType(trackName, container, trackCodec);\n      }\n    });\n    if (this.tracksReady || this.sourceBufferCount) {\n      data.tracks = this.sourceBufferTracks;\n    }\n\n    // if sourcebuffers already created, do nothing ...\n    if (this.sourceBufferCount) {\n      return;\n    }\n    if (this.mediaSourceOpenOrEnded) {\n      this.checkPendingTracks();\n    }\n  }\n  get sourceBufferTracks() {\n    return Object.keys(this.tracks).reduce((baseTracks, type) => {\n      const track = this.tracks[type];\n      baseTracks[type] = {\n        id: track.id,\n        container: track.container,\n        codec: track.codec,\n        levelCodec: track.levelCodec\n      };\n      return baseTracks;\n    }, {});\n  }\n  appendChangeType(type, container, codec) {\n    const mimeType = `${container};codecs=${codec}`;\n    const operation = {\n      label: `change-type=${mimeType}`,\n      execute: () => {\n        const track = this.tracks[type];\n        if (track) {\n          const sb = track.buffer;\n          if (sb != null && sb.changeType) {\n            this.log(`changing ${type} sourceBuffer type to ${mimeType}`);\n            sb.changeType(mimeType);\n            track.codec = codec;\n            track.container = container;\n          }\n        }\n        this.shiftAndExecuteNext(type);\n      },\n      onStart: () => {},\n      onComplete: () => {},\n      onError: error => {\n        this.warn(`Failed to change ${type} SourceBuffer type`, error);\n      }\n    };\n    this.append(operation, type, this.isPending(this.tracks[type]));\n  }\n  blockAudio(partOrFrag) {\n    var _this$fragmentTracker;\n    const pStart = partOrFrag.start;\n    const pTime = pStart + partOrFrag.duration * 0.05;\n    const atGap = ((_this$fragmentTracker = this.fragmentTracker.getAppendedFrag(pStart, PlaylistLevelType.MAIN)) == null ? void 0 : _this$fragmentTracker.gap) === true;\n    if (atGap) {\n      return;\n    }\n    const op = {\n      label: 'block-audio',\n      execute: () => {\n        var _this$fragmentTracker2;\n        const videoTrack = this.tracks.video;\n        if (this.lastVideoAppendEnd > pTime || videoTrack != null && videoTrack.buffer && BufferHelper.isBuffered(videoTrack.buffer, pTime) || ((_this$fragmentTracker2 = this.fragmentTracker.getAppendedFrag(pTime, PlaylistLevelType.MAIN)) == null ? void 0 : _this$fragmentTracker2.gap) === true) {\n          this.blockedAudioAppend = null;\n          this.shiftAndExecuteNext('audio');\n        }\n      },\n      onStart: () => {},\n      onComplete: () => {},\n      onError: error => {\n        this.warn('Error executing block-audio operation', error);\n      }\n    };\n    this.blockedAudioAppend = {\n      op,\n      frag: partOrFrag\n    };\n    this.append(op, 'audio', true);\n  }\n  unblockAudio() {\n    const {\n      blockedAudioAppend,\n      operationQueue\n    } = this;\n    if (blockedAudioAppend && operationQueue) {\n      this.blockedAudioAppend = null;\n      operationQueue.unblockAudio(blockedAudioAppend.op);\n    }\n  }\n  onBufferAppending(event, eventData) {\n    const {\n      tracks\n    } = this;\n    const {\n      data,\n      type,\n      parent,\n      frag,\n      part,\n      chunkMeta,\n      offset\n    } = eventData;\n    const chunkStats = chunkMeta.buffering[type];\n    const {\n      sn,\n      cc\n    } = frag;\n    const bufferAppendingStart = self.performance.now();\n    chunkStats.start = bufferAppendingStart;\n    const fragBuffering = frag.stats.buffering;\n    const partBuffering = part ? part.stats.buffering : null;\n    if (fragBuffering.start === 0) {\n      fragBuffering.start = bufferAppendingStart;\n    }\n    if (partBuffering && partBuffering.start === 0) {\n      partBuffering.start = bufferAppendingStart;\n    }\n\n    // TODO: Only update timestampOffset when audio/mpeg fragment or part is not contiguous with previously appended\n    // Adjusting `SourceBuffer.timestampOffset` (desired point in the timeline where the next frames should be appended)\n    // in Chrome browser when we detect MPEG audio container and time delta between level PTS and `SourceBuffer.timestampOffset`\n    // is greater than 100ms (this is enough to handle seek for VOD or level change for LIVE videos).\n    // More info here: https://github.com/video-dev/hls.js/issues/332#issuecomment-257986486\n    const audioTrack = tracks.audio;\n    let checkTimestampOffset = false;\n    if (type === 'audio' && (audioTrack == null ? void 0 : audioTrack.container) === 'audio/mpeg') {\n      checkTimestampOffset = !this.lastMpegAudioChunk || chunkMeta.id === 1 || this.lastMpegAudioChunk.sn !== chunkMeta.sn;\n      this.lastMpegAudioChunk = chunkMeta;\n    }\n\n    // Block audio append until overlapping video append\n    const videoTrack = tracks.video;\n    const videoSb = videoTrack == null ? void 0 : videoTrack.buffer;\n    if (videoSb && sn !== 'initSegment') {\n      const partOrFrag = part || frag;\n      const blockedAudioAppend = this.blockedAudioAppend;\n      if (type === 'audio' && parent !== 'main' && !this.blockedAudioAppend) {\n        const pStart = partOrFrag.start;\n        const pTime = pStart + partOrFrag.duration * 0.05;\n        const vbuffered = videoSb.buffered;\n        const vappending = this.currentOp('video');\n        if (!vbuffered.length && !vappending) {\n          // wait for video before appending audio\n          this.blockAudio(partOrFrag);\n        } else if (!vappending && !BufferHelper.isBuffered(videoSb, pTime) && this.lastVideoAppendEnd < pTime) {\n          // audio is ahead of video\n          this.blockAudio(partOrFrag);\n        }\n      } else if (type === 'video') {\n        const videoAppendEnd = partOrFrag.end;\n        if (blockedAudioAppend) {\n          const audioStart = blockedAudioAppend.frag.start;\n          if (videoAppendEnd > audioStart || videoAppendEnd < this.lastVideoAppendEnd || BufferHelper.isBuffered(videoSb, audioStart)) {\n            this.unblockAudio();\n          }\n        }\n        this.lastVideoAppendEnd = videoAppendEnd;\n      }\n    }\n    const fragStart = (part || frag).start;\n    const operation = {\n      label: `append-${type}`,\n      execute: () => {\n        var _this$tracks$type2;\n        chunkStats.executeStart = self.performance.now();\n        const sb = (_this$tracks$type2 = this.tracks[type]) == null ? void 0 : _this$tracks$type2.buffer;\n        if (sb) {\n          if (checkTimestampOffset) {\n            this.updateTimestampOffset(sb, fragStart, 0.1, type, sn, cc);\n          } else if (offset !== undefined && isFiniteNumber(offset)) {\n            this.updateTimestampOffset(sb, offset, 0.000001, type, sn, cc);\n          }\n        }\n        this.appendExecutor(data, type);\n      },\n      onStart: () => {\n        // logger.debug(`[buffer-controller]: ${type} SourceBuffer updatestart`);\n      },\n      onComplete: () => {\n        // logger.debug(`[buffer-controller]: ${type} SourceBuffer updateend`);\n        const end = self.performance.now();\n        chunkStats.executeEnd = chunkStats.end = end;\n        if (fragBuffering.first === 0) {\n          fragBuffering.first = end;\n        }\n        if (partBuffering && partBuffering.first === 0) {\n          partBuffering.first = end;\n        }\n        const timeRanges = {};\n        this.sourceBuffers.forEach(([type, sb]) => {\n          if (type) {\n            timeRanges[type] = BufferHelper.getBuffered(sb);\n          }\n        });\n        this.appendErrors[type] = 0;\n        if (type === 'audio' || type === 'video') {\n          this.appendErrors.audiovideo = 0;\n        } else {\n          this.appendErrors.audio = 0;\n          this.appendErrors.video = 0;\n        }\n        this.hls.trigger(Events.BUFFER_APPENDED, {\n          type,\n          frag,\n          part,\n          chunkMeta,\n          parent: frag.type,\n          timeRanges\n        });\n      },\n      onError: error => {\n        var _this$media;\n        // in case any error occured while appending, put back segment in segments table\n        const event = {\n          type: ErrorTypes.MEDIA_ERROR,\n          parent: frag.type,\n          details: ErrorDetails.BUFFER_APPEND_ERROR,\n          sourceBufferName: type,\n          frag,\n          part,\n          chunkMeta,\n          error,\n          err: error,\n          fatal: false\n        };\n        const mediaError = (_this$media = this.media) == null ? void 0 : _this$media.error;\n        if (error.code === DOMException.QUOTA_EXCEEDED_ERR || error.name == 'QuotaExceededError' || `quota` in error) {\n          // QuotaExceededError: http://www.w3.org/TR/html5/infrastructure.html#quotaexceedederror\n          // let's stop appending any segments, and report BUFFER_FULL_ERROR error\n          event.details = ErrorDetails.BUFFER_FULL_ERROR;\n        } else if (error.code === DOMException.INVALID_STATE_ERR && this.mediaSourceOpenOrEnded && !mediaError) {\n          // Allow retry for \"Failed to execute 'appendBuffer' on 'SourceBuffer': This SourceBuffer is still processing\" errors\n          event.errorAction = createDoNothingErrorAction(true);\n        } else if (error.name === TRACK_REMOVED_ERROR_NAME && this.sourceBufferCount === 0) {\n          // Do nothing if sourceBuffers were removed (media is detached and append was not aborted)\n          event.errorAction = createDoNothingErrorAction(true);\n        } else {\n          const appendErrorCount = ++this.appendErrors[type];\n          /* with UHD content, we could get loop of quota exceeded error until\n            browser is able to evict some data from sourcebuffer. Retrying can help recover.\n          */\n          this.warn(`Failed ${appendErrorCount}/${this.hls.config.appendErrorMaxRetry} times to append segment in \"${type}\" sourceBuffer (${mediaError ? mediaError : 'no media error'})`);\n          if (appendErrorCount >= this.hls.config.appendErrorMaxRetry || !!mediaError) {\n            event.fatal = true;\n          }\n        }\n        this.hls.trigger(Events.ERROR, event);\n      }\n    };\n    this.append(operation, type, this.isPending(this.tracks[type]));\n  }\n  getFlushOp(type, start, end) {\n    this.log(`queuing \"${type}\" remove ${start}-${end}`);\n    return {\n      label: 'remove',\n      execute: () => {\n        this.removeExecutor(type, start, end);\n      },\n      onStart: () => {\n        // logger.debug(`[buffer-controller]: Started flushing ${data.startOffset} -> ${data.endOffset} for ${type} Source Buffer`);\n      },\n      onComplete: () => {\n        // logger.debug(`[buffer-controller]: Finished flushing ${data.startOffset} -> ${data.endOffset} for ${type} Source Buffer`);\n        this.hls.trigger(Events.BUFFER_FLUSHED, {\n          type\n        });\n      },\n      onError: error => {\n        this.warn(`Failed to remove ${start}-${end} from \"${type}\" SourceBuffer`, error);\n      }\n    };\n  }\n  onBufferFlushing(event, data) {\n    const {\n      type,\n      startOffset,\n      endOffset\n    } = data;\n    if (type) {\n      this.append(this.getFlushOp(type, startOffset, endOffset), type);\n    } else {\n      this.sourceBuffers.forEach(([type]) => {\n        if (type) {\n          this.append(this.getFlushOp(type, startOffset, endOffset), type);\n        }\n      });\n    }\n  }\n  onFragParsed(event, data) {\n    const {\n      frag,\n      part\n    } = data;\n    const buffersAppendedTo = [];\n    const elementaryStreams = part ? part.elementaryStreams : frag.elementaryStreams;\n    if (elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO]) {\n      buffersAppendedTo.push('audiovideo');\n    } else {\n      if (elementaryStreams[ElementaryStreamTypes.AUDIO]) {\n        buffersAppendedTo.push('audio');\n      }\n      if (elementaryStreams[ElementaryStreamTypes.VIDEO]) {\n        buffersAppendedTo.push('video');\n      }\n    }\n    const onUnblocked = () => {\n      const now = self.performance.now();\n      frag.stats.buffering.end = now;\n      if (part) {\n        part.stats.buffering.end = now;\n      }\n      const stats = part ? part.stats : frag.stats;\n      this.hls.trigger(Events.FRAG_BUFFERED, {\n        frag,\n        part,\n        stats,\n        id: frag.type\n      });\n    };\n    if (buffersAppendedTo.length === 0) {\n      this.warn(`Fragments must have at least one ElementaryStreamType set. type: ${frag.type} level: ${frag.level} sn: ${frag.sn}`);\n    }\n    this.blockBuffers(onUnblocked, buffersAppendedTo).catch(error => {\n      this.warn(`Fragment buffered callback ${error}`);\n      this.stepOperationQueue(this.sourceBufferTypes);\n    });\n  }\n  onFragChanged(event, data) {\n    this.trimBuffers();\n  }\n  get bufferedToEnd() {\n    return this.sourceBufferCount > 0 && !this.sourceBuffers.some(([type]) => {\n      var _this$tracks$type3, _this$tracks$type4;\n      return type && (!((_this$tracks$type3 = this.tracks[type]) != null && _this$tracks$type3.ended) || ((_this$tracks$type4 = this.tracks[type]) == null ? void 0 : _this$tracks$type4.ending));\n    });\n  }\n\n  // on BUFFER_EOS mark matching sourcebuffer(s) as \"ending\" and \"ended\" and queue endOfStream after remaining operations(s)\n  // an undefined data.type will mark all buffers as EOS.\n  onBufferEos(event, data) {\n    var _this$overrides;\n    this.sourceBuffers.forEach(([type]) => {\n      if (type) {\n        const track = this.tracks[type];\n        if (!data.type || data.type === type) {\n          track.ending = true;\n          if (!track.ended) {\n            track.ended = true;\n            this.log(`${type} buffer reached EOS`);\n          }\n        }\n      }\n    });\n    const allowEndOfStream = ((_this$overrides = this.overrides) == null ? void 0 : _this$overrides.endOfStream) !== false;\n    const allTracksEnding = this.sourceBufferCount > 0 && !this.sourceBuffers.some(([type]) => {\n      var _this$tracks$type5;\n      return type && !((_this$tracks$type5 = this.tracks[type]) != null && _this$tracks$type5.ended);\n    });\n    if (allTracksEnding) {\n      if (allowEndOfStream) {\n        this.log(`Queueing EOS`);\n        this.blockUntilOpen(() => {\n          this.tracksEnded();\n          const {\n            mediaSource\n          } = this;\n          if (!mediaSource || mediaSource.readyState !== 'open') {\n            if (mediaSource) {\n              this.log(`Could not call mediaSource.endOfStream(). mediaSource.readyState: ${mediaSource.readyState}`);\n            }\n            return;\n          }\n          this.log(`Calling mediaSource.endOfStream()`);\n          // Allow this to throw and be caught by the enqueueing function\n          mediaSource.endOfStream();\n          this.hls.trigger(Events.BUFFERED_TO_END, undefined);\n        });\n      } else {\n        this.tracksEnded();\n        this.hls.trigger(Events.BUFFERED_TO_END, undefined);\n      }\n    }\n  }\n  tracksEnded() {\n    this.sourceBuffers.forEach(([type]) => {\n      if (type !== null) {\n        const track = this.tracks[type];\n        if (track) {\n          track.ending = false;\n        }\n      }\n    });\n  }\n  onLevelUpdated(event, {\n    details\n  }) {\n    if (!details.fragments.length) {\n      return;\n    }\n    this.details = details;\n    this.updateDuration();\n  }\n  updateDuration() {\n    this.blockUntilOpen(() => {\n      const durationAndRange = this.getDurationAndRange();\n      if (!durationAndRange) {\n        return;\n      }\n      this.updateMediaSource(durationAndRange);\n    });\n  }\n  onError(event, data) {\n    if (data.details === ErrorDetails.BUFFER_APPEND_ERROR && data.frag) {\n      var _data$errorAction;\n      const nextAutoLevel = (_data$errorAction = data.errorAction) == null ? void 0 : _data$errorAction.nextAutoLevel;\n      if (isFiniteNumber(nextAutoLevel) && nextAutoLevel !== data.frag.level) {\n        this.resetAppendErrors();\n      }\n    }\n  }\n  resetAppendErrors() {\n    this.appendErrors = {\n      audio: 0,\n      video: 0,\n      audiovideo: 0\n    };\n  }\n  trimBuffers() {\n    const {\n      hls,\n      details,\n      media\n    } = this;\n    if (!media || details === null) {\n      return;\n    }\n    if (!this.sourceBufferCount) {\n      return;\n    }\n    const config = hls.config;\n    const currentTime = media.currentTime;\n    const targetDuration = details.levelTargetDuration;\n\n    // Support for deprecated liveBackBufferLength\n    const backBufferLength = details.live && config.liveBackBufferLength !== null ? config.liveBackBufferLength : config.backBufferLength;\n    if (isFiniteNumber(backBufferLength) && backBufferLength >= 0) {\n      const maxBackBufferLength = Math.max(backBufferLength, targetDuration);\n      const targetBackBufferPosition = Math.floor(currentTime / targetDuration) * targetDuration - maxBackBufferLength;\n      this.flushBackBuffer(currentTime, targetDuration, targetBackBufferPosition);\n    }\n    if (isFiniteNumber(config.frontBufferFlushThreshold) && config.frontBufferFlushThreshold > 0) {\n      const frontBufferLength = Math.max(config.maxBufferLength, config.frontBufferFlushThreshold);\n      const maxFrontBufferLength = Math.max(frontBufferLength, targetDuration);\n      const targetFrontBufferPosition = Math.floor(currentTime / targetDuration) * targetDuration + maxFrontBufferLength;\n      this.flushFrontBuffer(currentTime, targetDuration, targetFrontBufferPosition);\n    }\n  }\n  flushBackBuffer(currentTime, targetDuration, targetBackBufferPosition) {\n    this.sourceBuffers.forEach(([type, sb]) => {\n      if (sb) {\n        const buffered = BufferHelper.getBuffered(sb);\n        // when target buffer start exceeds actual buffer start\n        if (buffered.length > 0 && targetBackBufferPosition > buffered.start(0)) {\n          var _this$details;\n          this.hls.trigger(Events.BACK_BUFFER_REACHED, {\n            bufferEnd: targetBackBufferPosition\n          });\n\n          // Support for deprecated event:\n          const track = this.tracks[type];\n          if ((_this$details = this.details) != null && _this$details.live) {\n            this.hls.trigger(Events.LIVE_BACK_BUFFER_REACHED, {\n              bufferEnd: targetBackBufferPosition\n            });\n          } else if (track != null && track.ended) {\n            this.log(`Cannot flush ${type} back buffer while SourceBuffer is in ended state`);\n            return;\n          }\n          this.hls.trigger(Events.BUFFER_FLUSHING, {\n            startOffset: 0,\n            endOffset: targetBackBufferPosition,\n            type\n          });\n        }\n      }\n    });\n  }\n  flushFrontBuffer(currentTime, targetDuration, targetFrontBufferPosition) {\n    this.sourceBuffers.forEach(([type, sb]) => {\n      if (sb) {\n        const buffered = BufferHelper.getBuffered(sb);\n        const numBufferedRanges = buffered.length;\n        // The buffer is either empty or contiguous\n        if (numBufferedRanges < 2) {\n          return;\n        }\n        const bufferStart = buffered.start(numBufferedRanges - 1);\n        const bufferEnd = buffered.end(numBufferedRanges - 1);\n        // No flush if we can tolerate the current buffer length or the current buffer range we would flush is contiguous with current position\n        if (targetFrontBufferPosition > bufferStart || currentTime >= bufferStart && currentTime <= bufferEnd) {\n          return;\n        }\n        this.hls.trigger(Events.BUFFER_FLUSHING, {\n          startOffset: bufferStart,\n          endOffset: Infinity,\n          type\n        });\n      }\n    });\n  }\n\n  /**\n   * Update Media Source duration to current level duration or override to Infinity if configuration parameter\n   * 'liveDurationInfinity` is set to `true`\n   * More details: https://github.com/video-dev/hls.js/issues/355\n   */\n  getDurationAndRange() {\n    var _this$overrides2;\n    const {\n      details,\n      mediaSource\n    } = this;\n    if (!details || !this.media || (mediaSource == null ? void 0 : mediaSource.readyState) !== 'open') {\n      return null;\n    }\n    const playlistEnd = details.edge;\n    if (details.live && this.hls.config.liveDurationInfinity) {\n      const len = details.fragments.length;\n      if (len && details.live && !!mediaSource.setLiveSeekableRange) {\n        const start = Math.max(0, details.fragmentStart);\n        const end = Math.max(start, playlistEnd);\n        return {\n          duration: Infinity,\n          start,\n          end\n        };\n      }\n      return {\n        duration: Infinity\n      };\n    }\n    const overrideDuration = (_this$overrides2 = this.overrides) == null ? void 0 : _this$overrides2.duration;\n    if (overrideDuration) {\n      if (!isFiniteNumber(overrideDuration)) {\n        return null;\n      }\n      return {\n        duration: overrideDuration\n      };\n    }\n    const mediaDuration = this.media.duration;\n    const msDuration = isFiniteNumber(mediaSource.duration) ? mediaSource.duration : 0;\n    if (playlistEnd > msDuration && playlistEnd > mediaDuration || !isFiniteNumber(mediaDuration)) {\n      return {\n        duration: playlistEnd\n      };\n    }\n    return null;\n  }\n  updateMediaSource({\n    duration,\n    start,\n    end\n  }) {\n    const mediaSource = this.mediaSource;\n    if (!this.media || !mediaSource || mediaSource.readyState !== 'open') {\n      return;\n    }\n    if (mediaSource.duration !== duration) {\n      if (isFiniteNumber(duration)) {\n        this.log(`Updating MediaSource duration to ${duration.toFixed(3)}`);\n      }\n      mediaSource.duration = duration;\n    }\n    if (start !== undefined && end !== undefined) {\n      this.log(`MediaSource duration is set to ${mediaSource.duration}. Setting seekable range to ${start}-${end}.`);\n      mediaSource.setLiveSeekableRange(start, end);\n    }\n  }\n  get tracksReady() {\n    const pendingTrackCount = this.pendingTrackCount;\n    return pendingTrackCount > 0 && (pendingTrackCount >= this.bufferCodecEventsTotal || this.isPending(this.tracks.audiovideo));\n  }\n  checkPendingTracks() {\n    const {\n      bufferCodecEventsTotal,\n      pendingTrackCount,\n      tracks\n    } = this;\n    this.log(`checkPendingTracks (pending: ${pendingTrackCount} codec events expected: ${bufferCodecEventsTotal}) ${stringify(tracks)}`);\n    // Check if we've received all of the expected bufferCodec events. When none remain, create all the sourceBuffers at once.\n    // This is important because the MSE spec allows implementations to throw QuotaExceededErrors if creating new sourceBuffers after\n    // data has been appended to existing ones.\n    // 2 tracks is the max (one for audio, one for video). If we've reach this max go ahead and create the buffers.\n    if (this.tracksReady) {\n      var _this$transferData4;\n      const transferredTracks = (_this$transferData4 = this.transferData) == null ? void 0 : _this$transferData4.tracks;\n      if (transferredTracks && Object.keys(transferredTracks).length) {\n        this.attachTransferred();\n      } else {\n        // ok, let's create them now !\n        this.createSourceBuffers();\n      }\n    }\n  }\n  bufferCreated() {\n    if (this.sourceBufferCount) {\n      const tracks = {};\n      this.sourceBuffers.forEach(([type, buffer]) => {\n        if (type) {\n          const track = this.tracks[type];\n          tracks[type] = {\n            buffer,\n            container: track.container,\n            codec: track.codec,\n            supplemental: track.supplemental,\n            levelCodec: track.levelCodec,\n            id: track.id,\n            metadata: track.metadata\n          };\n        }\n      });\n      this.hls.trigger(Events.BUFFER_CREATED, {\n        tracks\n      });\n      this.log(`SourceBuffers created. Running queue: ${this.operationQueue}`);\n      this.sourceBuffers.forEach(([type]) => {\n        this.executeNext(type);\n      });\n    } else {\n      const error = new Error('could not create source buffer for media codec(s)');\n      this.hls.trigger(Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.BUFFER_INCOMPATIBLE_CODECS_ERROR,\n        fatal: true,\n        error,\n        reason: error.message\n      });\n    }\n  }\n  createSourceBuffers() {\n    const {\n      tracks,\n      sourceBuffers,\n      mediaSource\n    } = this;\n    if (!mediaSource) {\n      throw new Error('createSourceBuffers called when mediaSource was null');\n    }\n    for (const trackName in tracks) {\n      const type = trackName;\n      const track = tracks[type];\n      if (this.isPending(track)) {\n        const codec = this.getTrackCodec(track, type);\n        const mimeType = `${track.container};codecs=${codec}`;\n        track.codec = codec;\n        this.log(`creating sourceBuffer(${mimeType})${this.currentOp(type) ? ' Queued' : ''} ${stringify(track)}`);\n        try {\n          const sb = mediaSource.addSourceBuffer(mimeType);\n          const sbIndex = sourceBufferNameToIndex(type);\n          const sbTuple = [type, sb];\n          sourceBuffers[sbIndex] = sbTuple;\n          track.buffer = sb;\n        } catch (error) {\n          var _this$operationQueue;\n          this.error(`error while trying to add sourceBuffer: ${error.message}`);\n          // remove init segment from queue and delete track info\n          this.shiftAndExecuteNext(type);\n          (_this$operationQueue = this.operationQueue) == null ? void 0 : _this$operationQueue.removeBlockers();\n          delete this.tracks[type];\n          this.hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.BUFFER_ADD_CODEC_ERROR,\n            fatal: false,\n            error,\n            sourceBufferName: type,\n            mimeType: mimeType,\n            parent: track.id\n          });\n          return;\n        }\n        this.trackSourceBuffer(type, track);\n      }\n    }\n    this.bufferCreated();\n  }\n  getTrackCodec(track, trackName) {\n    // Use supplemental video codec when supported when adding SourceBuffer (#5558)\n    const supplementalCodec = track.supplemental;\n    let trackCodec = track.codec;\n    if (supplementalCodec && (trackName === 'video' || trackName === 'audiovideo') && areCodecsMediaSourceSupported(supplementalCodec, 'video')) {\n      trackCodec = replaceVideoCodec(trackCodec, supplementalCodec);\n    }\n    const codec = pickMostCompleteCodecName(trackCodec, track.levelCodec);\n    if (codec) {\n      if (trackName.slice(0, 5) === 'audio') {\n        return getCodecCompatibleName(codec, this.appendSource);\n      }\n      return codec;\n    }\n    return '';\n  }\n  trackSourceBuffer(type, track) {\n    const buffer = track.buffer;\n    if (!buffer) {\n      return;\n    }\n    const codec = this.getTrackCodec(track, type);\n    this.tracks[type] = {\n      buffer,\n      codec,\n      container: track.container,\n      levelCodec: track.levelCodec,\n      supplemental: track.supplemental,\n      metadata: track.metadata,\n      id: track.id,\n      listeners: []\n    };\n    this.removeBufferListeners(type);\n    this.addBufferListener(type, 'updatestart', this.onSBUpdateStart);\n    this.addBufferListener(type, 'updateend', this.onSBUpdateEnd);\n    this.addBufferListener(type, 'error', this.onSBUpdateError);\n    // ManagedSourceBuffer bufferedchange event\n    if (this.appendSource) {\n      this.addBufferListener(type, 'bufferedchange', (type, event) => {\n        // If media was ejected check for a change. Added ranges are redundant with changes on 'updateend' event.\n        const removedRanges = event.removedRanges;\n        if (removedRanges != null && removedRanges.length) {\n          this.hls.trigger(Events.BUFFER_FLUSHED, {\n            type: type\n          });\n        }\n      });\n    }\n  }\n  get mediaSrc() {\n    var _this$media2, _this$media2$querySel;\n    const media = ((_this$media2 = this.media) == null ? void 0 : (_this$media2$querySel = _this$media2.querySelector) == null ? void 0 : _this$media2$querySel.call(_this$media2, 'source')) || this.media;\n    return media == null ? void 0 : media.src;\n  }\n  onSBUpdateStart(type) {\n    const operation = this.currentOp(type);\n    if (!operation) {\n      return;\n    }\n    operation.onStart();\n  }\n  onSBUpdateEnd(type) {\n    var _this$mediaSource4;\n    if (((_this$mediaSource4 = this.mediaSource) == null ? void 0 : _this$mediaSource4.readyState) === 'closed') {\n      this.resetBuffer(type);\n      return;\n    }\n    const operation = this.currentOp(type);\n    if (!operation) {\n      return;\n    }\n    operation.onComplete();\n    this.shiftAndExecuteNext(type);\n  }\n  onSBUpdateError(type, event) {\n    var _this$mediaSource5;\n    const error = new Error(`${type} SourceBuffer error. MediaSource readyState: ${(_this$mediaSource5 = this.mediaSource) == null ? void 0 : _this$mediaSource5.readyState}`);\n    this.error(`${error}`, event);\n    // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error\n    // SourceBuffer errors are not necessarily fatal; if so, the HTMLMediaElement will fire an error event\n    this.hls.trigger(Events.ERROR, {\n      type: ErrorTypes.MEDIA_ERROR,\n      details: ErrorDetails.BUFFER_APPENDING_ERROR,\n      sourceBufferName: type,\n      error,\n      fatal: false\n    });\n    // updateend is always fired after error, so we'll allow that to shift the current operation off of the queue\n    const operation = this.currentOp(type);\n    if (operation) {\n      operation.onError(error);\n    }\n  }\n  updateTimestampOffset(sb, timestampOffset, tolerance, type, sn, cc) {\n    const delta = timestampOffset - sb.timestampOffset;\n    if (Math.abs(delta) >= tolerance) {\n      this.log(`Updating ${type} SourceBuffer timestampOffset to ${timestampOffset} (sn: ${sn} cc: ${cc})`);\n      sb.timestampOffset = timestampOffset;\n    }\n  }\n\n  // This method must result in an updateend event; if remove is not called, onSBUpdateEnd must be called manually\n  removeExecutor(type, startOffset, endOffset) {\n    const {\n      media,\n      mediaSource\n    } = this;\n    const track = this.tracks[type];\n    const sb = track == null ? void 0 : track.buffer;\n    if (!media || !mediaSource || !sb) {\n      this.warn(`Attempting to remove from the ${type} SourceBuffer, but it does not exist`);\n      this.shiftAndExecuteNext(type);\n      return;\n    }\n    const mediaDuration = isFiniteNumber(media.duration) ? media.duration : Infinity;\n    const msDuration = isFiniteNumber(mediaSource.duration) ? mediaSource.duration : Infinity;\n    const removeStart = Math.max(0, startOffset);\n    const removeEnd = Math.min(endOffset, mediaDuration, msDuration);\n    if (removeEnd > removeStart && (!track.ending || track.ended)) {\n      track.ended = false;\n      this.log(`Removing [${removeStart},${removeEnd}] from the ${type} SourceBuffer`);\n      sb.remove(removeStart, removeEnd);\n    } else {\n      // Cycle the queue\n      this.shiftAndExecuteNext(type);\n    }\n  }\n\n  // This method must result in an updateend event; if append is not called, onSBUpdateEnd must be called manually\n  appendExecutor(data, type) {\n    const track = this.tracks[type];\n    const sb = track == null ? void 0 : track.buffer;\n    if (!sb) {\n      throw new HlsJsTrackRemovedError(`Attempting to append to the ${type} SourceBuffer, but it does not exist`);\n    }\n    track.ending = false;\n    track.ended = false;\n    sb.appendBuffer(data);\n  }\n  blockUntilOpen(callback) {\n    if (this.isUpdating() || this.isQueued()) {\n      this.blockBuffers(callback).catch(error => {\n        this.warn(`SourceBuffer blocked callback ${error}`);\n        this.stepOperationQueue(this.sourceBufferTypes);\n      });\n    } else {\n      try {\n        callback();\n      } catch (error) {\n        this.warn(`Callback run without blocking ${this.operationQueue} ${error}`);\n      }\n    }\n  }\n  isUpdating() {\n    return this.sourceBuffers.some(([type, sb]) => type && sb.updating);\n  }\n  isQueued() {\n    return this.sourceBuffers.some(([type]) => type && !!this.currentOp(type));\n  }\n  isPending(track) {\n    return !!track && !track.buffer;\n  }\n\n  // Enqueues an operation to each SourceBuffer queue which, upon execution, resolves a promise. When all promises\n  // resolve, the onUnblocked function is executed. Functions calling this method do not need to unblock the queue\n  // upon completion, since we already do it here\n  blockBuffers(onUnblocked, bufferNames = this.sourceBufferTypes) {\n    if (!bufferNames.length) {\n      this.log('Blocking operation requested, but no SourceBuffers exist');\n      return Promise.resolve().then(onUnblocked);\n    }\n    const {\n      operationQueue\n    } = this;\n\n    // logger.debug(`[buffer-controller]: Blocking ${buffers} SourceBuffer`);\n    const blockingOperations = bufferNames.map(type => this.appendBlocker(type));\n    const audioBlocked = bufferNames.length > 1 && !!this.blockedAudioAppend;\n    if (audioBlocked) {\n      this.unblockAudio();\n    }\n    return Promise.all(blockingOperations).then(result => {\n      if (operationQueue !== this.operationQueue) {\n        return;\n      }\n      // logger.debug(`[buffer-controller]: Blocking operation resolved; unblocking ${buffers} SourceBuffer`);\n      onUnblocked();\n      this.stepOperationQueue(this.sourceBufferTypes);\n    });\n  }\n  stepOperationQueue(bufferNames) {\n    bufferNames.forEach(type => {\n      var _this$tracks$type6;\n      const sb = (_this$tracks$type6 = this.tracks[type]) == null ? void 0 : _this$tracks$type6.buffer;\n      // Only cycle the queue if the SB is not updating. There's a bug in Chrome which sets the SB updating flag to\n      // true when changing the MediaSource duration (https://bugs.chromium.org/p/chromium/issues/detail?id=959359&can=2&q=mediasource%20duration)\n      // While this is a workaround, it's probably useful to have around\n      if (!sb || sb.updating) {\n        return;\n      }\n      this.shiftAndExecuteNext(type);\n    });\n  }\n  append(operation, type, pending) {\n    if (this.operationQueue) {\n      this.operationQueue.append(operation, type, pending);\n    }\n  }\n  appendBlocker(type) {\n    if (this.operationQueue) {\n      return this.operationQueue.appendBlocker(type);\n    }\n  }\n  currentOp(type) {\n    if (this.operationQueue) {\n      return this.operationQueue.current(type);\n    }\n    return null;\n  }\n  executeNext(type) {\n    if (type && this.operationQueue) {\n      this.operationQueue.executeNext(type);\n    }\n  }\n  shiftAndExecuteNext(type) {\n    if (this.operationQueue) {\n      this.operationQueue.shiftAndExecuteNext(type);\n    }\n  }\n  get pendingTrackCount() {\n    return Object.keys(this.tracks).reduce((acc, type) => acc + (this.isPending(this.tracks[type]) ? 1 : 0), 0);\n  }\n  get sourceBufferCount() {\n    return this.sourceBuffers.reduce((acc, [type]) => acc + (type ? 1 : 0), 0);\n  }\n  get sourceBufferTypes() {\n    return this.sourceBuffers.map(([type]) => type).filter(type => !!type);\n  }\n  addBufferListener(type, event, fn) {\n    const track = this.tracks[type];\n    if (!track) {\n      return;\n    }\n    const buffer = track.buffer;\n    if (!buffer) {\n      return;\n    }\n    const listener = fn.bind(this, type);\n    track.listeners.push({\n      event,\n      listener\n    });\n    buffer.addEventListener(event, listener);\n  }\n  removeBufferListeners(type) {\n    const track = this.tracks[type];\n    if (!track) {\n      return;\n    }\n    const buffer = track.buffer;\n    if (!buffer) {\n      return;\n    }\n    track.listeners.forEach(l => {\n      buffer.removeEventListener(l.event, l.listener);\n    });\n    track.listeners.length = 0;\n  }\n}\nfunction removeSourceChildren(node) {\n  const sourceChildren = node.querySelectorAll('source');\n  [].slice.call(sourceChildren).forEach(source => {\n    node.removeChild(source);\n  });\n}\nfunction addSource(media, url) {\n  const source = self.document.createElement('source');\n  source.type = 'video/mp4';\n  source.src = url;\n  media.appendChild(source);\n}\nfunction sourceBufferNameToIndex(type) {\n  return type === 'audio' ? 1 : 0;\n}\n\nclass CapLevelController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.autoLevelCapping = void 0;\n    this.firstLevel = void 0;\n    this.media = void 0;\n    this.restrictedLevels = void 0;\n    this.timer = void 0;\n    this.clientRect = void 0;\n    this.streamController = void 0;\n    this.hls = hls;\n    this.autoLevelCapping = Number.POSITIVE_INFINITY;\n    this.firstLevel = -1;\n    this.media = null;\n    this.restrictedLevels = [];\n    this.timer = undefined;\n    this.clientRect = null;\n    this.registerListeners();\n  }\n  setStreamController(streamController) {\n    this.streamController = streamController;\n  }\n  destroy() {\n    if (this.hls) {\n      this.unregisterListener();\n    }\n    if (this.timer) {\n      this.stopCapping();\n    }\n    this.media = null;\n    this.clientRect = null;\n    // @ts-ignore\n    this.hls = this.streamController = null;\n  }\n  registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);\n    hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n  }\n  unregisterListener() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);\n    hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n  }\n  onFpsDropLevelCapping(event, data) {\n    // Don't add a restricted level more than once\n    const level = this.hls.levels[data.droppedLevel];\n    if (this.isLevelAllowed(level)) {\n      this.restrictedLevels.push({\n        bitrate: level.bitrate,\n        height: level.height,\n        width: level.width\n      });\n    }\n  }\n  onMediaAttaching(event, data) {\n    this.media = data.media instanceof HTMLVideoElement ? data.media : null;\n    this.clientRect = null;\n    if (this.timer && this.hls.levels.length) {\n      this.detectPlayerSize();\n    }\n  }\n  onManifestParsed(event, data) {\n    const hls = this.hls;\n    this.restrictedLevels = [];\n    this.firstLevel = data.firstLevel;\n    if (hls.config.capLevelToPlayerSize && data.video) {\n      // Start capping immediately if the manifest has signaled video codecs\n      this.startCapping();\n    }\n  }\n  onLevelsUpdated(event, data) {\n    if (this.timer && isFiniteNumber(this.autoLevelCapping)) {\n      this.detectPlayerSize();\n    }\n  }\n\n  // Only activate capping when playing a video stream; otherwise, multi-bitrate audio-only streams will be restricted\n  // to the first level\n  onBufferCodecs(event, data) {\n    const hls = this.hls;\n    if (hls.config.capLevelToPlayerSize && data.video) {\n      // If the manifest did not signal a video codec capping has been deferred until we're certain video is present\n      this.startCapping();\n    }\n  }\n  onMediaDetaching() {\n    this.stopCapping();\n    this.media = null;\n  }\n  detectPlayerSize() {\n    if (this.media) {\n      if (this.mediaHeight <= 0 || this.mediaWidth <= 0) {\n        this.clientRect = null;\n        return;\n      }\n      const levels = this.hls.levels;\n      if (levels.length) {\n        const hls = this.hls;\n        const maxLevel = this.getMaxLevel(levels.length - 1);\n        if (maxLevel !== this.autoLevelCapping) {\n          hls.logger.log(`Setting autoLevelCapping to ${maxLevel}: ${levels[maxLevel].height}p@${levels[maxLevel].bitrate} for media ${this.mediaWidth}x${this.mediaHeight}`);\n        }\n        hls.autoLevelCapping = maxLevel;\n        if (hls.autoLevelEnabled && hls.autoLevelCapping > this.autoLevelCapping && this.streamController) {\n          // if auto level capping has a higher value for the previous one, flush the buffer using nextLevelSwitch\n          // usually happen when the user go to the fullscreen mode.\n          this.streamController.nextLevelSwitch();\n        }\n        this.autoLevelCapping = hls.autoLevelCapping;\n      }\n    }\n  }\n\n  /*\n   * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)\n   */\n  getMaxLevel(capLevelIndex) {\n    const levels = this.hls.levels;\n    if (!levels.length) {\n      return -1;\n    }\n    const validLevels = levels.filter((level, index) => this.isLevelAllowed(level) && index <= capLevelIndex);\n    this.clientRect = null;\n    return CapLevelController.getMaxLevelByMediaSize(validLevels, this.mediaWidth, this.mediaHeight);\n  }\n  startCapping() {\n    if (this.timer) {\n      // Don't reset capping if started twice; this can happen if the manifest signals a video codec\n      return;\n    }\n    this.autoLevelCapping = Number.POSITIVE_INFINITY;\n    self.clearInterval(this.timer);\n    this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1000);\n    this.detectPlayerSize();\n  }\n  stopCapping() {\n    this.restrictedLevels = [];\n    this.firstLevel = -1;\n    this.autoLevelCapping = Number.POSITIVE_INFINITY;\n    if (this.timer) {\n      self.clearInterval(this.timer);\n      this.timer = undefined;\n    }\n  }\n  getDimensions() {\n    if (this.clientRect) {\n      return this.clientRect;\n    }\n    const media = this.media;\n    const boundsRect = {\n      width: 0,\n      height: 0\n    };\n    if (media) {\n      const clientRect = media.getBoundingClientRect();\n      boundsRect.width = clientRect.width;\n      boundsRect.height = clientRect.height;\n      if (!boundsRect.width && !boundsRect.height) {\n        // When the media element has no width or height (equivalent to not being in the DOM),\n        // then use its width and height attributes (media.width, media.height)\n        boundsRect.width = clientRect.right - clientRect.left || media.width || 0;\n        boundsRect.height = clientRect.bottom - clientRect.top || media.height || 0;\n      }\n    }\n    this.clientRect = boundsRect;\n    return boundsRect;\n  }\n  get mediaWidth() {\n    return this.getDimensions().width * this.contentScaleFactor;\n  }\n  get mediaHeight() {\n    return this.getDimensions().height * this.contentScaleFactor;\n  }\n  get contentScaleFactor() {\n    let pixelRatio = 1;\n    if (!this.hls.config.ignoreDevicePixelRatio) {\n      try {\n        pixelRatio = self.devicePixelRatio;\n      } catch (e) {\n        /* no-op */\n      }\n    }\n    return Math.min(pixelRatio, this.hls.config.maxDevicePixelRatio);\n  }\n  isLevelAllowed(level) {\n    const restrictedLevels = this.restrictedLevels;\n    return !restrictedLevels.some(restrictedLevel => {\n      return level.bitrate === restrictedLevel.bitrate && level.width === restrictedLevel.width && level.height === restrictedLevel.height;\n    });\n  }\n  static getMaxLevelByMediaSize(levels, width, height) {\n    if (!(levels != null && levels.length)) {\n      return -1;\n    }\n\n    // Levels can have the same dimensions but differing bandwidths - since levels are ordered, we can look to the next\n    // to determine whether we've chosen the greatest bandwidth for the media's dimensions\n    const atGreatestBandwidth = (curLevel, nextLevel) => {\n      if (!nextLevel) {\n        return true;\n      }\n      return curLevel.width !== nextLevel.width || curLevel.height !== nextLevel.height;\n    };\n\n    // If we run through the loop without breaking, the media's dimensions are greater than every level, so default to\n    // the max level\n    let maxLevelIndex = levels.length - 1;\n    // Prevent changes in aspect-ratio from causing capping to toggle back and forth\n    const squareSize = Math.max(width, height);\n    for (let i = 0; i < levels.length; i += 1) {\n      const level = levels[i];\n      if ((level.width >= squareSize || level.height >= squareSize) && atGreatestBandwidth(level, levels[i + 1])) {\n        maxLevelIndex = i;\n        break;\n      }\n    }\n    return maxLevelIndex;\n  }\n}\n\n/**\n * Common Media Object Type\n *\n * @internal\n */\nconst CmObjectType = {\n  /**\n   * text file, such as a manifest or playlist\n   */\n  MANIFEST: 'm',\n  /**\n   * audio only\n   */\n  AUDIO: 'a',\n  /**\n   * video only\n   */\n  VIDEO: 'v',\n  /**\n   * muxed audio and video\n   */\n  MUXED: 'av',\n  /**\n   * init segment\n   */\n  INIT: 'i',\n  /**\n   * caption or subtitle\n   */\n  CAPTION: 'c',\n  /**\n   * ISOBMFF timed text track\n   */\n  TIMED_TEXT: 'tt',\n  /**\n   * cryptographic key, license or certificate.\n   */\n  KEY: 'k',\n  /**\n   * other\n   */\n  OTHER: 'o'\n};\n\n/**\n * Common Media Client Data Object Type\n *\n * @group CMCD\n *\n * @beta\n *\n * @enum\n */\nconst CmcdObjectType = CmObjectType;\n\n/**\n * Common Media Streaming Format\n *\n * @internal\n */\nconst CmStreamingFormat = {\n  /**\n   * HTTP Live Streaming (HLS)\n   */\n  HLS: 'h'};\n\n/**\n * Common Media Client Data Streaming Format\n *\n * @group CMCD\n *\n * @enum\n *\n * @beta\n */\nconst CmcdStreamingFormat = CmStreamingFormat;\n\n/**\n * CMCD object header name.\n *\n * @group CMCD\n *\n * @beta\n */\nconst CMCD_OBJECT = 'CMCD-Object';\n\n/**\n * CMCD request header name.\n *\n * @group CMCD\n *\n * @beta\n */\nconst CMCD_REQUEST = 'CMCD-Request';\n\n/**\n * CMCD session header name.\n *\n * @group CMCD\n *\n * @beta\n */\nconst CMCD_SESSION = 'CMCD-Session';\n\n/**\n * CMCD status header name.\n *\n * @group CMCD\n *\n * @beta\n */\nconst CMCD_STATUS = 'CMCD-Status';\n\n/**\n * CMCD header fields.\n *\n * @group CMCD\n *\n * @enum\n *\n * @beta\n */\nconst CmcdHeaderField = {\n  /**\n   * keys whose values vary with the object being requested.\n   */\n  OBJECT: CMCD_OBJECT,\n  /**\n   * keys whose values vary with each request.\n   */\n  REQUEST: CMCD_REQUEST,\n  /**\n   * keys whose values are expected to be invariant over the life of the session.\n   */\n  SESSION: CMCD_SESSION,\n  /**\n   * keys whose values do not vary with every request or object.\n   */\n  STATUS: CMCD_STATUS\n};\n\n/**\n * The map of CMCD header fields to official CMCD keys.\n *\n * @internal\n *\n * @group CMCD\n */\nconst CmcdHeaderMap = {\n  [CmcdHeaderField.OBJECT]: ['br', 'ab', 'd', 'ot', 'tb', 'tpb', 'lb', 'tab', 'lab', 'url'],\n  [CmcdHeaderField.REQUEST]: ['pb', 'bl', 'tbl', 'dl', 'ltc', 'mtp', 'nor', 'nrr', 'rc', 'sn', 'sta', 'su', 'ttfb', 'ttfbb', 'ttlb', 'cmsdd', 'cmsds', 'smrt', 'df', 'cs'],\n  [CmcdHeaderField.SESSION]: ['cid', 'pr', 'sf', 'sid', 'st', 'v', 'msd'],\n  [CmcdHeaderField.STATUS]: ['bs', 'bsd', 'cdn', 'rtp', 'bg', 'pt', 'ec', 'e']\n};\n\n/**\n * Structured Field Item\n *\n * @group Structured Field\n *\n * @beta\n */\nclass SfItem {\n  constructor(value, params) {\n    if (Array.isArray(value)) {\n      value = value.map(v => v instanceof SfItem ? v : new SfItem(v));\n    }\n    this.value = value;\n    this.params = params;\n  }\n}\n\nconst DICT = 'Dict';\n\nfunction format(value) {\n  if (Array.isArray(value)) {\n    return JSON.stringify(value);\n  }\n  if (value instanceof Map) {\n    return 'Map{}';\n  }\n  if (value instanceof Set) {\n    return 'Set{}';\n  }\n  if (typeof value === 'object') {\n    return JSON.stringify(value);\n  }\n  return String(value);\n}\nfunction throwError(action, src, type, cause) {\n  return new Error(`failed to ${action} \"${format(src)}\" as ${type}`, {\n    cause\n  });\n}\n\nfunction serializeError(src, type, cause) {\n  return throwError('serialize', src, type, cause);\n}\n\n/**\n * A class to represent structured field tokens when `Symbol` is not available.\n *\n * @group Structured Field\n *\n * @beta\n */\nclass SfToken {\n  constructor(description) {\n    this.description = description;\n  }\n}\n\nconst BARE_ITEM = 'Bare Item';\n\nconst BOOLEAN = 'Boolean';\n\n// 4.1.9.  Serializing a Boolean\n//\n// Given a Boolean as input_boolean, return an ASCII string suitable for\n// use in a HTTP field value.\n//\n// 1.  If input_boolean is not a boolean, fail serialization.\n//\n// 2.  Let output be an empty string.\n//\n// 3.  Append \"?\" to output.\n//\n// 4.  If input_boolean is true, append \"1\" to output.\n//\n// 5.  If input_boolean is false, append \"0\" to output.\n//\n// 6.  Return output.\nfunction serializeBoolean(value) {\n  if (typeof value !== 'boolean') {\n    throw serializeError(value, BOOLEAN);\n  }\n  return value ? '?1' : '?0';\n}\n\n/**\n * Encodes binary data to base64\n *\n * @param binary - The binary data to encode\n * @returns The base64 encoded string\n *\n * @group Utils\n *\n * @beta\n */\nfunction encodeBase64(binary) {\n  return btoa(String.fromCharCode(...binary));\n}\n\nconst BYTES = 'Byte Sequence';\n\n// 4.1.8.  Serializing a Byte Sequence\n//\n// Given a Byte Sequence as input_bytes, return an ASCII string suitable\n// for use in a HTTP field value.\n//\n// 1.  If input_bytes is not a sequence of bytes, fail serialization.\n//\n// 2.  Let output be an empty string.\n//\n// 3.  Append \":\" to output.\n//\n// 4.  Append the result of base64-encoding input_bytes as per\n//     [RFC4648], Section 4, taking account of the requirements below.\n//\n// 5.  Append \":\" to output.\n//\n// 6.  Return output.\n//\n// The encoded data is required to be padded with \"=\", as per [RFC4648],\n// Section 3.2.\n//\n// Likewise, encoded data SHOULD have pad bits set to zero, as per\n// [RFC4648], Section 3.5, unless it is not possible to do so due to\n// implementation constraints.\nfunction serializeByteSequence(value) {\n  if (ArrayBuffer.isView(value) === false) {\n    throw serializeError(value, BYTES);\n  }\n  return `:${encodeBase64(value)}:`;\n}\n\nconst INTEGER = 'Integer';\n\nfunction isInvalidInt(value) {\n  return value < -999999999999999 || 999999999999999 < value;\n}\n\n// 4.1.4.  Serializing an Integer\n//\n// Given an Integer as input_integer, return an ASCII string suitable\n// for use in a HTTP field value.\n//\n// 1.  If input_integer is not an integer in the range of\n//     -999,999,999,999,999 to 999,999,999,999,999 inclusive, fail\n//     serialization.\n//\n// 2.  Let output be an empty string.\n//\n// 3.  If input_integer is less than (but not equal to) 0, append \"-\" to\n//     output.\n//\n// 4.  Append input_integer's numeric value represented in base 10 using\n//     only decimal digits to output.\n//\n// 5.  Return output.\nfunction serializeInteger(value) {\n  if (isInvalidInt(value)) {\n    throw serializeError(value, INTEGER);\n  }\n  return value.toString();\n}\n\n// 4.1.10.  Serializing a Date\n//\n// Given a Date as input_integer, return an ASCII string suitable for\n// use in an HTTP field value.\n// 1.  Let output be \"@\".\n// 2.  Append to output the result of running Serializing an Integer\n//     with input_date (Section 4.1.4).\n// 3.  Return output.\nfunction serializeDate(value) {\n  return `@${serializeInteger(value.getTime() / 1000)}`;\n}\n\n/**\n * This implements the rounding procedure described in step 2 of the \"Serializing a Decimal\" specification.\n * This rounding style is known as \"even rounding\", \"banker's rounding\", or \"commercial rounding\".\n *\n * @param value - The value to round\n * @param precision - The number of decimal places to round to\n * @returns The rounded value\n *\n * @group Utils\n *\n * @beta\n */\nfunction roundToEven(value, precision) {\n  if (value < 0) {\n    return -roundToEven(-value, precision);\n  }\n  const decimalShift = Math.pow(10, precision);\n  const isEquidistant = Math.abs(value * decimalShift % 1 - 0.5) < Number.EPSILON;\n  if (isEquidistant) {\n    // If the tail of the decimal place is 'equidistant' we round to the nearest even value\n    const flooredValue = Math.floor(value * decimalShift);\n    return (flooredValue % 2 === 0 ? flooredValue : flooredValue + 1) / decimalShift;\n  } else {\n    // Otherwise, proceed as normal\n    return Math.round(value * decimalShift) / decimalShift;\n  }\n}\n\nconst DECIMAL = 'Decimal';\n\n// 4.1.5.  Serializing a Decimal\n//\n// Given a decimal number as input_decimal, return an ASCII string\n// suitable for use in a HTTP field value.\n//\n// 1.   If input_decimal is not a decimal number, fail serialization.\n//\n// 2.   If input_decimal has more than three significant digits to the\n//      right of the decimal point, round it to three decimal places,\n//      rounding the final digit to the nearest value, or to the even\n//      value if it is equidistant.\n//\n// 3.   If input_decimal has more than 12 significant digits to the left\n//      of the decimal point after rounding, fail serialization.\n//\n// 4.   Let output be an empty string.\n//\n// 5.   If input_decimal is less than (but not equal to) 0, append \"-\"\n//      to output.\n//\n// 6.   Append input_decimal's integer component represented in base 10\n//      (using only decimal digits) to output; if it is zero, append\n//      \"0\".\n//\n// 7.   Append \".\" to output.\n//\n// 8.   If input_decimal's fractional component is zero, append \"0\" to\n//      output.\n//\n// 9.   Otherwise, append the significant digits of input_decimal's\n//      fractional component represented in base 10 (using only decimal\n//      digits) to output.\n//\n// 10.  Return output.\nfunction serializeDecimal(value) {\n  const roundedValue = roundToEven(value, 3); // round to 3 decimal places\n  if (Math.floor(Math.abs(roundedValue)).toString().length > 12) {\n    throw serializeError(value, DECIMAL);\n  }\n  const stringValue = roundedValue.toString();\n  return stringValue.includes('.') ? stringValue : `${stringValue}.0`;\n}\n\nconst STRING = 'String';\n\nconst STRING_REGEX = /[\\x00-\\x1f\\x7f]+/;\n\n// 4.1.6.  Serializing a String\n//\n// Given a String as input_string, return an ASCII string suitable for\n// use in a HTTP field value.\n//\n// 1.  Convert input_string into a sequence of ASCII characters; if\n//     conversion fails, fail serialization.\n//\n// 2.  If input_string contains characters in the range %x00-1f or %x7f\n//     (i.e., not in VCHAR or SP), fail serialization.\n//\n// 3.  Let output be the string DQUOTE.\n//\n// 4.  For each character char in input_string:\n//\n//     1.  If char is \"\\\" or DQUOTE:\n//\n//         1.  Append \"\\\" to output.\n//\n//     2.  Append char to output.\n//\n// 5.  Append DQUOTE to output.\n//\n// 6.  Return output.\nfunction serializeString(value) {\n  if (STRING_REGEX.test(value)) {\n    throw serializeError(value, STRING);\n  }\n  return `\"${value.replace(/\\\\/g, `\\\\\\\\`).replace(/\"/g, `\\\\\"`)}\"`;\n}\n\n/**\n * Converts a symbol to a string.\n *\n * @param symbol - The symbol to convert.\n *\n * @returns The string representation of the symbol.\n *\n * @internal\n */\nfunction symbolToStr(symbol) {\n  return symbol.description || symbol.toString().slice(7, -1);\n}\n\nconst TOKEN = 'Token';\n\nfunction serializeToken(token) {\n  const value = symbolToStr(token);\n  if (/^([a-zA-Z*])([!#$%&'*+\\-.^_`|~\\w:/]*)$/.test(value) === false) {\n    throw serializeError(value, TOKEN);\n  }\n  return value;\n}\n\n// 4.1.3.1.  Serializing a Bare Item\n//\n// Given an Item as input_item, return an ASCII string suitable for use\n// in a HTTP field value.\n//\n// 1.  If input_item is an Integer, return the result of running\n//     Serializing an Integer (Section 4.1.4) with input_item.\n//\n// 2.  If input_item is a Decimal, return the result of running\n//     Serializing a Decimal (Section 4.1.5) with input_item.\n//\n// 3.  If input_item is a String, return the result of running\n//     Serializing a String (Section 4.1.6) with input_item.\n//\n// 4.  If input_item is a Token, return the result of running\n//     Serializing a Token (Section 4.1.7) with input_item.\n//\n// 5.  If input_item is a Boolean, return the result of running\n//     Serializing a Boolean (Section 4.1.9) with input_item.\n//\n// 6.  If input_item is a Byte Sequence, return the result of running\n//     Serializing a Byte Sequence (Section 4.1.8) with input_item.\n//\n// 7.  If input_item is a Date, return the result of running Serializing\n//     a Date (Section 4.1.10) with input_item.\n//\n// 8.  Otherwise, fail serialization.\nfunction serializeBareItem(value) {\n  switch (typeof value) {\n    case 'number':\n      if (!isFiniteNumber(value)) {\n        throw serializeError(value, BARE_ITEM);\n      }\n      if (Number.isInteger(value)) {\n        return serializeInteger(value);\n      }\n      return serializeDecimal(value);\n    case 'string':\n      return serializeString(value);\n    case 'symbol':\n      return serializeToken(value);\n    case 'boolean':\n      return serializeBoolean(value);\n    case 'object':\n      if (value instanceof Date) {\n        return serializeDate(value);\n      }\n      if (value instanceof Uint8Array) {\n        return serializeByteSequence(value);\n      }\n      if (value instanceof SfToken) {\n        return serializeToken(value);\n      }\n    default:\n      // fail\n      throw serializeError(value, BARE_ITEM);\n  }\n}\n\nconst KEY = 'Key';\n\n// 4.1.1.3.  Serializing a Key\n//\n// Given a key as input_key, return an ASCII string suitable for use in\n// a HTTP field value.\n//\n// 1.  Convert input_key into a sequence of ASCII characters; if\n//     conversion fails, fail serialization.\n//\n// 2.  If input_key contains characters not in lcalpha, DIGIT, \"_\", \"-\",\n//     \".\", or \"*\" fail serialization.\n//\n// 3.  If the first character of input_key is not lcalpha or \"*\", fail\n//     serialization.\n//\n// 4.  Let output be an empty string.\n//\n// 5.  Append input_key to output.\n//\n// 6.  Return output.\nfunction serializeKey(value) {\n  if (/^[a-z*][a-z0-9\\-_.*]*$/.test(value) === false) {\n    throw serializeError(value, KEY);\n  }\n  return value;\n}\n\n// 4.1.1.2.  Serializing Parameters\n//\n// Given an ordered Dictionary as input_parameters (each member having a\n// param_name and a param_value), return an ASCII string suitable for\n// use in a HTTP field value.\n//\n// 1.  Let output be an empty string.\n//\n// 2.  For each param_name with a value of param_value in\n//     input_parameters:\n//\n//     1.  Append \";\" to output.\n//\n//     2.  Append the result of running Serializing a Key\n//         (Section 4.1.1.3) with param_name to output.\n//\n//     3.  If param_value is not Boolean true:\n//\n//         1.  Append \"=\" to output.\n//\n//         2.  Append the result of running Serializing a bare Item\n//             (Section 4.1.3.1) with param_value to output.\n//\n// 3.  Return output.\nfunction serializeParams(params) {\n  if (params == null) {\n    return '';\n  }\n  return Object.entries(params).map(([key, value]) => {\n    if (value === true) {\n      return `;${serializeKey(key)}`; // omit true\n    }\n    return `;${serializeKey(key)}=${serializeBareItem(value)}`;\n  }).join('');\n}\n\n// 4.1.3.  Serializing an Item\n//\n// Given an Item as bare_item and Parameters as item_parameters, return\n// an ASCII string suitable for use in a HTTP field value.\n//\n// 1.  Let output be an empty string.\n//\n// 2.  Append the result of running Serializing a Bare Item\n//     Section 4.1.3.1 with bare_item to output.\n//\n// 3.  Append the result of running Serializing Parameters\n//     Section 4.1.1.2 with item_parameters to output.\n//\n// 4.  Return output.\nfunction serializeItem(value) {\n  if (value instanceof SfItem) {\n    return `${serializeBareItem(value.value)}${serializeParams(value.params)}`;\n  } else {\n    return serializeBareItem(value);\n  }\n}\n\n// 4.1.1.1.  Serializing an Inner List\n//\n// Given an array of (member_value, parameters) tuples as inner_list,\n// and parameters as list_parameters, return an ASCII string suitable\n// for use in a HTTP field value.\n//\n// 1.  Let output be the string \"(\".\n//\n// 2.  For each (member_value, parameters) of inner_list:\n//\n//     1.  Append the result of running Serializing an Item\n//         (Section 4.1.3) with (member_value, parameters) to output.\n//\n//     2.  If more values remain in inner_list, append a single SP to\n//         output.\n//\n// 3.  Append \")\" to output.\n//\n// 4.  Append the result of running Serializing Parameters\n//     (Section 4.1.1.2) with list_parameters to output.\n//\n// 5.  Return output.\nfunction serializeInnerList(value) {\n  return `(${value.value.map(serializeItem).join(' ')})${serializeParams(value.params)}`;\n}\n\n// 4.1.2.  Serializing a Dictionary\n//\n// Given an ordered Dictionary as input_dictionary (each member having a\n// member_name and a tuple value of (member_value, parameters)), return\n// an ASCII string suitable for use in a HTTP field value.\n//\n// 1.  Let output be an empty string.\n//\n// 2.  For each member_name with a value of (member_value, parameters)\n//     in input_dictionary:\n//\n//     1.  Append the result of running Serializing a Key\n//         (Section 4.1.1.3) with member's member_name to output.\n//\n//     2.  If member_value is Boolean true:\n//\n//         1.  Append the result of running Serializing Parameters\n//             (Section 4.1.1.2) with parameters to output.\n//\n//     3.  Otherwise:\n//\n//         1.  Append \"=\" to output.\n//\n//         2.  If member_value is an array, append the result of running\n//             Serializing an Inner List (Section 4.1.1.1) with\n//             (member_value, parameters) to output.\n//\n//         3.  Otherwise, append the result of running Serializing an\n//             Item (Section 4.1.3) with (member_value, parameters) to\n//             output.\n//\n//     4.  If more members remain in input_dictionary:\n//\n//         1.  Append \",\" to output.\n//\n//         2.  Append a single SP to output.\n//\n// 3.  Return output.\nfunction serializeDict(dict, options = {\n  whitespace: true\n}) {\n  if (typeof dict !== 'object') {\n    throw serializeError(dict, DICT);\n  }\n  const entries = dict instanceof Map ? dict.entries() : Object.entries(dict);\n  const optionalWhiteSpace = (options === null || options === void 0 ? void 0 : options.whitespace) ? ' ' : '';\n  return Array.from(entries).map(([key, item]) => {\n    if (item instanceof SfItem === false) {\n      item = new SfItem(item);\n    }\n    let output = serializeKey(key);\n    if (item.value === true) {\n      output += serializeParams(item.params);\n    } else {\n      output += '=';\n      if (Array.isArray(item.value)) {\n        output += serializeInnerList(item);\n      } else {\n        output += serializeItem(item);\n      }\n    }\n    return output;\n  }).join(`,${optionalWhiteSpace}`);\n}\n\n/**\n * Encode an object into a structured field dictionary\n *\n * @param value - The structured field dictionary to encode\n * @param options - Encoding options\n *\n * @returns The structured field string\n *\n * @group Structured Field\n *\n * @beta\n */\nfunction encodeSfDict(value, options) {\n  return serializeDict(value, options);\n}\n\n/**\n * Checks if the given key is a token field.\n *\n * @param key - The key to check.\n *\n * @returns `true` if the key is a token field.\n *\n * @internal\n */\nfunction isTokenField(key) {\n  return ['ot', 'sf', 'st', 'e', 'sta'].includes(key);\n}\n\n/**\n * Checks if the given value is valid\n *\n * @param value - The value to check.\n *\n * @returns `true` if the key is a value is valid.\n *\n * @internal\n */\nfunction isValid(value) {\n  if (typeof value === 'number') {\n    return isFiniteNumber(value);\n  }\n  return value != null && value !== '' && value !== false;\n}\n\n/**\n * Constructs a relative path from a URL.\n *\n * @param url - The destination URL\n * @param base - The base URL\n * @returns The relative path\n *\n * @group Utils\n *\n * @beta\n */\nfunction urlToRelativePath(url, base) {\n  const to = new URL(url);\n  const from = new URL(base);\n  if (to.origin !== from.origin) {\n    return url;\n  }\n  const toPath = to.pathname.split('/').slice(1);\n  const fromPath = from.pathname.split('/').slice(1, -1);\n  // remove common parents\n  while (toPath[0] === fromPath[0]) {\n    toPath.shift();\n    fromPath.shift();\n  }\n  // add back paths\n  while (fromPath.length) {\n    fromPath.shift();\n    toPath.unshift('..');\n  }\n  return toPath.join('/');\n}\n\nconst toRounded = value => Math.round(value);\nconst toUrlSafe = (value, options) => {\n  if (options === null || options === void 0 ? void 0 : options.baseUrl) {\n    value = urlToRelativePath(value, options.baseUrl);\n  }\n  return encodeURIComponent(value);\n};\nconst toHundred = value => toRounded(value / 100) * 100;\n/**\n * The default formatters for CMCD values.\n *\n * @group CMCD\n *\n * @beta\n */\nconst CmcdFormatters = {\n  /**\n   * Bitrate (kbps) rounded integer\n   */\n  br: toRounded,\n  /**\n   * Duration (milliseconds) rounded integer\n   */\n  d: toRounded,\n  /**\n   * Buffer Length (milliseconds) rounded nearest 100ms\n   */\n  bl: toHundred,\n  /**\n   * Deadline (milliseconds) rounded nearest 100ms\n   */\n  dl: toHundred,\n  /**\n   * Measured Throughput (kbps) rounded nearest 100kbps\n   */\n  mtp: toHundred,\n  /**\n   * Next Object Request URL encoded\n   */\n  nor: toUrlSafe,\n  /**\n   * Requested maximum throughput (kbps) rounded nearest 100kbps\n   */\n  rtp: toHundred,\n  /**\n   * Top Bitrate (kbps) rounded integer\n   */\n  tb: toRounded\n};\n\n/**\n * Internal CMCD processing function.\n *\n * @param obj - The CMCD object to process.\n * @param map - The mapping function to use.\n * @param options - Options for encoding.\n *\n * @internal\n *\n * @group CMCD\n */\nfunction processCmcd(obj, options) {\n  const results = {};\n  if (obj == null || typeof obj !== 'object') {\n    return results;\n  }\n  const keys = Object.keys(obj).sort();\n  const formatters = _extends({}, CmcdFormatters, options === null || options === void 0 ? void 0 : options.formatters);\n  const filter = options === null || options === void 0 ? void 0 : options.filter;\n  keys.forEach(key => {\n    if ((filter === null || filter === void 0 ? void 0 : filter(key)) === false) {\n      return;\n    }\n    let value = obj[key];\n    const formatter = formatters[key];\n    if (formatter) {\n      value = formatter(value, options);\n    }\n    // Version should only be reported if not equal to 1.\n    if (key === 'v' && value === 1) {\n      return;\n    }\n    // Playback rate should only be sent if not equal to 1.\n    if (key == 'pr' && value === 1) {\n      return;\n    }\n    // ignore invalid values\n    if (!isValid(value)) {\n      return;\n    }\n    if (isTokenField(key) && typeof value === 'string') {\n      value = new SfToken(value);\n    }\n    results[key] = value;\n  });\n  return results;\n}\n\n/**\n * Encode a CMCD object to a string.\n *\n * @param cmcd - The CMCD object to encode.\n * @param options - Options for encoding.\n *\n * @returns The encoded CMCD string.\n *\n * @group CMCD\n *\n * @beta\n */\nfunction encodeCmcd(cmcd, options = {}) {\n  if (!cmcd) {\n    return '';\n  }\n  return encodeSfDict(processCmcd(cmcd, options), _extends({\n    whitespace: false\n  }, options));\n}\n\n/**\n * Convert a CMCD data object to request headers\n *\n * @param cmcd - The CMCD data object to convert.\n * @param options - Options for encoding the CMCD object.\n *\n * @returns The CMCD header shards.\n *\n * @group CMCD\n *\n * @beta\n */\nfunction toCmcdHeaders(cmcd, options = {}) {\n  const result = {};\n  if (!cmcd) {\n    return result;\n  }\n  const entries = Object.entries(cmcd);\n  const headerMap = Object.entries(CmcdHeaderMap).concat(Object.entries((options === null || options === void 0 ? void 0 : options.customHeaderMap) || {}));\n  const shards = entries.reduce((acc, entry) => {\n    var _a, _b;\n    const [key, value] = entry;\n    const field = ((_a = headerMap.find(entry => entry[1].includes(key))) === null || _a === void 0 ? void 0 : _a[0]) || CmcdHeaderField.REQUEST;\n    (_b = acc[field]) !== null && _b !== void 0 ? _b : acc[field] = {};\n    acc[field][key] = value;\n    return acc;\n  }, {});\n  return Object.entries(shards).reduce((acc, [field, value]) => {\n    acc[field] = encodeCmcd(value, options);\n    return acc;\n  }, result);\n}\n\n/**\n * Append CMCD query args to a header object.\n *\n * @param headers - The headers to append to.\n * @param cmcd - The CMCD object to append.\n * @param options - Encode options.\n *\n * @returns The headers with the CMCD header shards appended.\n *\n * @group CMCD\n *\n * @beta\n */\nfunction appendCmcdHeaders(headers, cmcd, options) {\n  return _extends(headers, toCmcdHeaders(cmcd, options));\n}\n\n/**\n * CMCD parameter name.\n *\n * @group CMCD\n *\n * @beta\n */\nconst CMCD_PARAM = 'CMCD';\n\n/**\n * Convert a CMCD data object to a query arg.\n *\n * @param cmcd - The CMCD object to convert.\n * @param options - Options for encoding the CMCD object.\n *\n * @returns The CMCD query arg.\n *\n * @group CMCD\n *\n * @beta\n */\nfunction toCmcdQuery(cmcd, options = {}) {\n  if (!cmcd) {\n    return '';\n  }\n  const params = encodeCmcd(cmcd, options);\n  return `${CMCD_PARAM}=${encodeURIComponent(params)}`;\n}\n\nconst REGEX = /CMCD=[^&#]+/;\n/**\n * Append CMCD query args to a URL.\n *\n * @param url - The URL to append to.\n * @param cmcd - The CMCD object to append.\n * @param options - Options for encoding the CMCD object.\n *\n * @returns The URL with the CMCD query args appended.\n *\n * @group CMCD\n *\n * @beta\n */\nfunction appendCmcdQuery(url, cmcd, options) {\n  // TODO: Replace with URLSearchParams once we drop Safari < 10.1 & Chrome < 49 support.\n  // https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams\n  const query = toCmcdQuery(cmcd, options);\n  if (!query) {\n    return url;\n  }\n  if (REGEX.test(url)) {\n    return url.replace(REGEX, query);\n  }\n  const separator = url.includes('?') ? '&' : '?';\n  return `${url}${separator}${query}`;\n}\n\n/**\n * Controller to deal with Common Media Client Data (CMCD)\n * @see https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5004-final.pdf\n */\nclass CMCDController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.config = void 0;\n    this.media = void 0;\n    this.sid = void 0;\n    this.cid = void 0;\n    this.useHeaders = false;\n    this.includeKeys = void 0;\n    this.initialized = false;\n    this.starved = false;\n    this.buffering = true;\n    this.audioBuffer = void 0;\n    this.videoBuffer = void 0;\n    this.onWaiting = () => {\n      if (this.initialized) {\n        this.starved = true;\n      }\n      this.buffering = true;\n    };\n    this.onPlaying = () => {\n      if (!this.initialized) {\n        this.initialized = true;\n      }\n      this.buffering = false;\n    };\n    /**\n     * Apply CMCD data to a manifest request.\n     */\n    this.applyPlaylistData = context => {\n      try {\n        this.apply(context, {\n          ot: CmcdObjectType.MANIFEST,\n          su: !this.initialized\n        });\n      } catch (error) {\n        this.hls.logger.warn('Could not generate manifest CMCD data.', error);\n      }\n    };\n    /**\n     * Apply CMCD data to a segment request\n     */\n    this.applyFragmentData = context => {\n      try {\n        const {\n          frag,\n          part\n        } = context;\n        const level = this.hls.levels[frag.level];\n        const ot = this.getObjectType(frag);\n        const data = {\n          d: (part || frag).duration * 1000,\n          ot\n        };\n        if (ot === CmcdObjectType.VIDEO || ot === CmcdObjectType.AUDIO || ot == CmcdObjectType.MUXED) {\n          data.br = level.bitrate / 1000;\n          data.tb = this.getTopBandwidth(ot) / 1000;\n          data.bl = this.getBufferLength(ot);\n        }\n        const next = part ? this.getNextPart(part) : this.getNextFrag(frag);\n        if (next != null && next.url && next.url !== frag.url) {\n          data.nor = next.url;\n        }\n        this.apply(context, data);\n      } catch (error) {\n        this.hls.logger.warn('Could not generate segment CMCD data.', error);\n      }\n    };\n    this.hls = hls;\n    const config = this.config = hls.config;\n    const {\n      cmcd\n    } = config;\n    if (cmcd != null) {\n      config.pLoader = this.createPlaylistLoader();\n      config.fLoader = this.createFragmentLoader();\n      this.sid = cmcd.sessionId || hls.sessionId;\n      this.cid = cmcd.contentId;\n      this.useHeaders = cmcd.useHeaders === true;\n      this.includeKeys = cmcd.includeKeys;\n      this.registerListeners();\n    }\n  }\n  registerListeners() {\n    const hls = this.hls;\n    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(Events.MEDIA_DETACHED, this.onMediaDetached, this);\n    hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);\n  }\n  unregisterListeners() {\n    const hls = this.hls;\n    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(Events.MEDIA_DETACHED, this.onMediaDetached, this);\n    hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.onMediaDetached();\n\n    // @ts-ignore\n    this.hls = this.config = this.audioBuffer = this.videoBuffer = null;\n    // @ts-ignore\n    this.onWaiting = this.onPlaying = this.media = null;\n  }\n  onMediaAttached(event, data) {\n    this.media = data.media;\n    this.media.addEventListener('waiting', this.onWaiting);\n    this.media.addEventListener('playing', this.onPlaying);\n  }\n  onMediaDetached() {\n    if (!this.media) {\n      return;\n    }\n    this.media.removeEventListener('waiting', this.onWaiting);\n    this.media.removeEventListener('playing', this.onPlaying);\n\n    // @ts-ignore\n    this.media = null;\n  }\n  onBufferCreated(event, data) {\n    var _data$tracks$audio, _data$tracks$video;\n    this.audioBuffer = (_data$tracks$audio = data.tracks.audio) == null ? void 0 : _data$tracks$audio.buffer;\n    this.videoBuffer = (_data$tracks$video = data.tracks.video) == null ? void 0 : _data$tracks$video.buffer;\n  }\n  /**\n   * Create baseline CMCD data\n   */\n  createData() {\n    var _this$media;\n    return {\n      v: 1,\n      sf: CmcdStreamingFormat.HLS,\n      sid: this.sid,\n      cid: this.cid,\n      pr: (_this$media = this.media) == null ? void 0 : _this$media.playbackRate,\n      mtp: this.hls.bandwidthEstimate / 1000\n    };\n  }\n\n  /**\n   * Apply CMCD data to a request.\n   */\n  apply(context, data = {}) {\n    // apply baseline data\n    _extends(data, this.createData());\n    const isVideo = data.ot === CmcdObjectType.INIT || data.ot === CmcdObjectType.VIDEO || data.ot === CmcdObjectType.MUXED;\n    if (this.starved && isVideo) {\n      data.bs = true;\n      data.su = true;\n      this.starved = false;\n    }\n    if (data.su == null) {\n      data.su = this.buffering;\n    }\n\n    // TODO: Implement rtp, nrr, dl\n\n    const {\n      includeKeys\n    } = this;\n    if (includeKeys) {\n      data = Object.keys(data).reduce((acc, key) => {\n        includeKeys.includes(key) && (acc[key] = data[key]);\n        return acc;\n      }, {});\n    }\n    const options = {\n      baseUrl: context.url\n    };\n    if (this.useHeaders) {\n      if (!context.headers) {\n        context.headers = {};\n      }\n      appendCmcdHeaders(context.headers, data, options);\n    } else {\n      context.url = appendCmcdQuery(context.url, data, options);\n    }\n  }\n  getNextFrag(fragment) {\n    var _this$hls$levels$frag;\n    const levelDetails = (_this$hls$levels$frag = this.hls.levels[fragment.level]) == null ? void 0 : _this$hls$levels$frag.details;\n    if (levelDetails) {\n      const index = fragment.sn - levelDetails.startSN;\n      return levelDetails.fragments[index + 1];\n    }\n    return undefined;\n  }\n  getNextPart(part) {\n    var _this$hls$levels$frag2, _this$hls$levels$frag3;\n    const {\n      index,\n      fragment\n    } = part;\n    const partList = (_this$hls$levels$frag2 = this.hls.levels[fragment.level]) == null ? void 0 : (_this$hls$levels$frag3 = _this$hls$levels$frag2.details) == null ? void 0 : _this$hls$levels$frag3.partList;\n    if (partList) {\n      const {\n        sn\n      } = fragment;\n      for (let i = partList.length - 1; i >= 0; i--) {\n        const p = partList[i];\n        if (p.index === index && p.fragment.sn === sn) {\n          return partList[i + 1];\n        }\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * The CMCD object type.\n   */\n  getObjectType(fragment) {\n    const {\n      type\n    } = fragment;\n    if (type === 'subtitle') {\n      return CmcdObjectType.TIMED_TEXT;\n    }\n    if (fragment.sn === 'initSegment') {\n      return CmcdObjectType.INIT;\n    }\n    if (type === 'audio') {\n      return CmcdObjectType.AUDIO;\n    }\n    if (type === 'main') {\n      if (!this.hls.audioTracks.length) {\n        return CmcdObjectType.MUXED;\n      }\n      return CmcdObjectType.VIDEO;\n    }\n    return undefined;\n  }\n\n  /**\n   * Get the highest bitrate.\n   */\n  getTopBandwidth(type) {\n    let bitrate = 0;\n    let levels;\n    const hls = this.hls;\n    if (type === CmcdObjectType.AUDIO) {\n      levels = hls.audioTracks;\n    } else {\n      const max = hls.maxAutoLevel;\n      const len = max > -1 ? max + 1 : hls.levels.length;\n      levels = hls.levels.slice(0, len);\n    }\n    levels.forEach(level => {\n      if (level.bitrate > bitrate) {\n        bitrate = level.bitrate;\n      }\n    });\n    return bitrate > 0 ? bitrate : NaN;\n  }\n\n  /**\n   * Get the buffer length for a media type in milliseconds\n   */\n  getBufferLength(type) {\n    const media = this.media;\n    const buffer = type === CmcdObjectType.AUDIO ? this.audioBuffer : this.videoBuffer;\n    if (!buffer || !media) {\n      return NaN;\n    }\n    const info = BufferHelper.bufferInfo(buffer, media.currentTime, this.config.maxBufferHole);\n    return info.len * 1000;\n  }\n\n  /**\n   * Create a playlist loader\n   */\n  createPlaylistLoader() {\n    const {\n      pLoader\n    } = this.config;\n    const apply = this.applyPlaylistData;\n    const Ctor = pLoader || this.config.loader;\n    return class CmcdPlaylistLoader {\n      constructor(config) {\n        this.loader = void 0;\n        this.loader = new Ctor(config);\n      }\n      get stats() {\n        return this.loader.stats;\n      }\n      get context() {\n        return this.loader.context;\n      }\n      destroy() {\n        this.loader.destroy();\n      }\n      abort() {\n        this.loader.abort();\n      }\n      load(context, config, callbacks) {\n        apply(context);\n        this.loader.load(context, config, callbacks);\n      }\n    };\n  }\n\n  /**\n   * Create a playlist loader\n   */\n  createFragmentLoader() {\n    const {\n      fLoader\n    } = this.config;\n    const apply = this.applyFragmentData;\n    const Ctor = fLoader || this.config.loader;\n    return class CmcdFragmentLoader {\n      constructor(config) {\n        this.loader = void 0;\n        this.loader = new Ctor(config);\n      }\n      get stats() {\n        return this.loader.stats;\n      }\n      get context() {\n        return this.loader.context;\n      }\n      destroy() {\n        this.loader.destroy();\n      }\n      abort() {\n        this.loader.abort();\n      }\n      load(context, config, callbacks) {\n        apply(context);\n        this.loader.load(context, config, callbacks);\n      }\n    };\n  }\n}\n\nconst PATHWAY_PENALTY_DURATION_MS = 300000;\nclass ContentSteeringController extends Logger {\n  constructor(hls) {\n    super('content-steering', hls.logger);\n    this.hls = void 0;\n    this.loader = null;\n    this.uri = null;\n    this.pathwayId = '.';\n    this._pathwayPriority = null;\n    this.timeToLoad = 300;\n    this.reloadTimer = -1;\n    this.updated = 0;\n    this.started = false;\n    this.enabled = true;\n    this.levels = null;\n    this.audioTracks = null;\n    this.subtitleTracks = null;\n    this.penalizedPathways = {};\n    this.hls = hls;\n    this.registerListeners();\n  }\n  registerListeners() {\n    const hls = this.hls;\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(Events.ERROR, this.onError, this);\n  }\n  unregisterListeners() {\n    const hls = this.hls;\n    if (!hls) {\n      return;\n    }\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(Events.ERROR, this.onError, this);\n  }\n  pathways() {\n    return (this.levels || []).reduce((pathways, level) => {\n      if (pathways.indexOf(level.pathwayId) === -1) {\n        pathways.push(level.pathwayId);\n      }\n      return pathways;\n    }, []);\n  }\n  get pathwayPriority() {\n    return this._pathwayPriority;\n  }\n  set pathwayPriority(pathwayPriority) {\n    this.updatePathwayPriority(pathwayPriority);\n  }\n  startLoad() {\n    this.started = true;\n    this.clearTimeout();\n    if (this.enabled && this.uri) {\n      if (this.updated) {\n        const ttl = this.timeToLoad * 1000 - (performance.now() - this.updated);\n        if (ttl > 0) {\n          this.scheduleRefresh(this.uri, ttl);\n          return;\n        }\n      }\n      this.loadSteeringManifest(this.uri);\n    }\n  }\n  stopLoad() {\n    this.started = false;\n    if (this.loader) {\n      this.loader.destroy();\n      this.loader = null;\n    }\n    this.clearTimeout();\n  }\n  clearTimeout() {\n    if (this.reloadTimer !== -1) {\n      self.clearTimeout(this.reloadTimer);\n      this.reloadTimer = -1;\n    }\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.stopLoad();\n    // @ts-ignore\n    this.hls = null;\n    this.levels = this.audioTracks = this.subtitleTracks = null;\n  }\n  removeLevel(levelToRemove) {\n    const levels = this.levels;\n    if (levels) {\n      this.levels = levels.filter(level => level !== levelToRemove);\n    }\n  }\n  onManifestLoading() {\n    this.stopLoad();\n    this.enabled = true;\n    this.timeToLoad = 300;\n    this.updated = 0;\n    this.uri = null;\n    this.pathwayId = '.';\n    this.levels = this.audioTracks = this.subtitleTracks = null;\n  }\n  onManifestLoaded(event, data) {\n    const {\n      contentSteering\n    } = data;\n    if (contentSteering === null) {\n      return;\n    }\n    this.pathwayId = contentSteering.pathwayId;\n    this.uri = contentSteering.uri;\n    if (this.started) {\n      this.startLoad();\n    }\n  }\n  onManifestParsed(event, data) {\n    this.audioTracks = data.audioTracks;\n    this.subtitleTracks = data.subtitleTracks;\n  }\n  onError(event, data) {\n    const {\n      errorAction\n    } = data;\n    if ((errorAction == null ? void 0 : errorAction.action) === NetworkErrorAction.SendAlternateToPenaltyBox && errorAction.flags === ErrorActionFlags.MoveAllAlternatesMatchingHost) {\n      const levels = this.levels;\n      let pathwayPriority = this._pathwayPriority;\n      let errorPathway = this.pathwayId;\n      if (data.context) {\n        const {\n          groupId,\n          pathwayId,\n          type\n        } = data.context;\n        if (groupId && levels) {\n          errorPathway = this.getPathwayForGroupId(groupId, type, errorPathway);\n        } else if (pathwayId) {\n          errorPathway = pathwayId;\n        }\n      }\n      if (!(errorPathway in this.penalizedPathways)) {\n        this.penalizedPathways[errorPathway] = performance.now();\n      }\n      if (!pathwayPriority && levels) {\n        // If PATHWAY-PRIORITY was not provided, list pathways for error handling\n        pathwayPriority = this.pathways();\n      }\n      if (pathwayPriority && pathwayPriority.length > 1) {\n        this.updatePathwayPriority(pathwayPriority);\n        errorAction.resolved = this.pathwayId !== errorPathway;\n      }\n      if (data.details === ErrorDetails.BUFFER_APPEND_ERROR && !data.fatal) {\n        // Error will become fatal in buffer-controller when reaching `appendErrorMaxRetry`\n        // Stream-controllers are expected to reduce buffer length even if this is not deemed a QuotaExceededError\n        errorAction.resolved = true;\n      } else if (!errorAction.resolved) {\n        this.warn(`Could not resolve ${data.details} (\"${data.error.message}\") with content-steering for Pathway: ${errorPathway} levels: ${levels ? levels.length : levels} priorities: ${stringify(pathwayPriority)} penalized: ${stringify(this.penalizedPathways)}`);\n      }\n    }\n  }\n  filterParsedLevels(levels) {\n    // Filter levels to only include those that are in the initial pathway\n    this.levels = levels;\n    let pathwayLevels = this.getLevelsForPathway(this.pathwayId);\n    if (pathwayLevels.length === 0) {\n      const pathwayId = levels[0].pathwayId;\n      this.log(`No levels found in Pathway ${this.pathwayId}. Setting initial Pathway to \"${pathwayId}\"`);\n      pathwayLevels = this.getLevelsForPathway(pathwayId);\n      this.pathwayId = pathwayId;\n    }\n    if (pathwayLevels.length !== levels.length) {\n      this.log(`Found ${pathwayLevels.length}/${levels.length} levels in Pathway \"${this.pathwayId}\"`);\n    }\n    return pathwayLevels;\n  }\n  getLevelsForPathway(pathwayId) {\n    if (this.levels === null) {\n      return [];\n    }\n    return this.levels.filter(level => pathwayId === level.pathwayId);\n  }\n  updatePathwayPriority(pathwayPriority) {\n    this._pathwayPriority = pathwayPriority;\n    let levels;\n\n    // Evaluate if we should remove the pathway from the penalized list\n    const penalizedPathways = this.penalizedPathways;\n    const now = performance.now();\n    Object.keys(penalizedPathways).forEach(pathwayId => {\n      if (now - penalizedPathways[pathwayId] > PATHWAY_PENALTY_DURATION_MS) {\n        delete penalizedPathways[pathwayId];\n      }\n    });\n    for (let i = 0; i < pathwayPriority.length; i++) {\n      const pathwayId = pathwayPriority[i];\n      if (pathwayId in penalizedPathways) {\n        continue;\n      }\n      if (pathwayId === this.pathwayId) {\n        return;\n      }\n      const selectedIndex = this.hls.nextLoadLevel;\n      const selectedLevel = this.hls.levels[selectedIndex];\n      levels = this.getLevelsForPathway(pathwayId);\n      if (levels.length > 0) {\n        this.log(`Setting Pathway to \"${pathwayId}\"`);\n        this.pathwayId = pathwayId;\n        reassignFragmentLevelIndexes(levels);\n        this.hls.trigger(Events.LEVELS_UPDATED, {\n          levels\n        });\n        // Set LevelController's level to trigger LEVEL_SWITCHING which loads playlist if needed\n        const levelAfterChange = this.hls.levels[selectedIndex];\n        if (selectedLevel && levelAfterChange && this.levels) {\n          if (levelAfterChange.attrs['STABLE-VARIANT-ID'] !== selectedLevel.attrs['STABLE-VARIANT-ID'] && levelAfterChange.bitrate !== selectedLevel.bitrate) {\n            this.log(`Unstable Pathways change from bitrate ${selectedLevel.bitrate} to ${levelAfterChange.bitrate}`);\n          }\n          this.hls.nextLoadLevel = selectedIndex;\n        }\n        break;\n      }\n    }\n  }\n  getPathwayForGroupId(groupId, type, defaultPathway) {\n    const levels = this.getLevelsForPathway(defaultPathway).concat(this.levels || []);\n    for (let i = 0; i < levels.length; i++) {\n      if (type === PlaylistContextType.AUDIO_TRACK && levels[i].hasAudioGroup(groupId) || type === PlaylistContextType.SUBTITLE_TRACK && levels[i].hasSubtitleGroup(groupId)) {\n        return levels[i].pathwayId;\n      }\n    }\n    return defaultPathway;\n  }\n  clonePathways(pathwayClones) {\n    const levels = this.levels;\n    if (!levels) {\n      return;\n    }\n    const audioGroupCloneMap = {};\n    const subtitleGroupCloneMap = {};\n    pathwayClones.forEach(pathwayClone => {\n      const {\n        ID: cloneId,\n        'BASE-ID': baseId,\n        'URI-REPLACEMENT': uriReplacement\n      } = pathwayClone;\n      if (levels.some(level => level.pathwayId === cloneId)) {\n        return;\n      }\n      const clonedVariants = this.getLevelsForPathway(baseId).map(baseLevel => {\n        const attributes = new AttrList(baseLevel.attrs);\n        attributes['PATHWAY-ID'] = cloneId;\n        const clonedAudioGroupId = attributes.AUDIO && `${attributes.AUDIO}_clone_${cloneId}`;\n        const clonedSubtitleGroupId = attributes.SUBTITLES && `${attributes.SUBTITLES}_clone_${cloneId}`;\n        if (clonedAudioGroupId) {\n          audioGroupCloneMap[attributes.AUDIO] = clonedAudioGroupId;\n          attributes.AUDIO = clonedAudioGroupId;\n        }\n        if (clonedSubtitleGroupId) {\n          subtitleGroupCloneMap[attributes.SUBTITLES] = clonedSubtitleGroupId;\n          attributes.SUBTITLES = clonedSubtitleGroupId;\n        }\n        const url = performUriReplacement(baseLevel.uri, attributes['STABLE-VARIANT-ID'], 'PER-VARIANT-URIS', uriReplacement);\n        const clonedLevel = new Level({\n          attrs: attributes,\n          audioCodec: baseLevel.audioCodec,\n          bitrate: baseLevel.bitrate,\n          height: baseLevel.height,\n          name: baseLevel.name,\n          url,\n          videoCodec: baseLevel.videoCodec,\n          width: baseLevel.width\n        });\n        if (baseLevel.audioGroups) {\n          for (let i = 1; i < baseLevel.audioGroups.length; i++) {\n            clonedLevel.addGroupId('audio', `${baseLevel.audioGroups[i]}_clone_${cloneId}`);\n          }\n        }\n        if (baseLevel.subtitleGroups) {\n          for (let i = 1; i < baseLevel.subtitleGroups.length; i++) {\n            clonedLevel.addGroupId('text', `${baseLevel.subtitleGroups[i]}_clone_${cloneId}`);\n          }\n        }\n        return clonedLevel;\n      });\n      levels.push(...clonedVariants);\n      cloneRenditionGroups(this.audioTracks, audioGroupCloneMap, uriReplacement, cloneId);\n      cloneRenditionGroups(this.subtitleTracks, subtitleGroupCloneMap, uriReplacement, cloneId);\n    });\n  }\n  loadSteeringManifest(uri) {\n    const config = this.hls.config;\n    const Loader = config.loader;\n    if (this.loader) {\n      this.loader.destroy();\n    }\n    this.loader = new Loader(config);\n    let url;\n    try {\n      url = new self.URL(uri);\n    } catch (error) {\n      this.enabled = false;\n      this.log(`Failed to parse Steering Manifest URI: ${uri}`);\n      return;\n    }\n    if (url.protocol !== 'data:') {\n      const throughput = (this.hls.bandwidthEstimate || config.abrEwmaDefaultEstimate) | 0;\n      url.searchParams.set('_HLS_pathway', this.pathwayId);\n      url.searchParams.set('_HLS_throughput', '' + throughput);\n    }\n    const context = {\n      responseType: 'json',\n      url: url.href\n    };\n    const loadPolicy = config.steeringManifestLoadPolicy.default;\n    const legacyRetryCompatibility = loadPolicy.errorRetry || loadPolicy.timeoutRetry || {};\n    const loaderConfig = {\n      loadPolicy,\n      timeout: loadPolicy.maxLoadTimeMs,\n      maxRetry: legacyRetryCompatibility.maxNumRetry || 0,\n      retryDelay: legacyRetryCompatibility.retryDelayMs || 0,\n      maxRetryDelay: legacyRetryCompatibility.maxRetryDelayMs || 0\n    };\n    const callbacks = {\n      onSuccess: (response, stats, context, networkDetails) => {\n        this.log(`Loaded steering manifest: \"${url}\"`);\n        const steeringData = response.data;\n        if ((steeringData == null ? void 0 : steeringData.VERSION) !== 1) {\n          this.log(`Steering VERSION ${steeringData.VERSION} not supported!`);\n          return;\n        }\n        this.updated = performance.now();\n        this.timeToLoad = steeringData.TTL;\n        const {\n          'RELOAD-URI': reloadUri,\n          'PATHWAY-CLONES': pathwayClones,\n          'PATHWAY-PRIORITY': pathwayPriority\n        } = steeringData;\n        if (reloadUri) {\n          try {\n            this.uri = new self.URL(reloadUri, url).href;\n          } catch (error) {\n            this.enabled = false;\n            this.log(`Failed to parse Steering Manifest RELOAD-URI: ${reloadUri}`);\n            return;\n          }\n        }\n        this.scheduleRefresh(this.uri || context.url);\n        if (pathwayClones) {\n          this.clonePathways(pathwayClones);\n        }\n        const loadedSteeringData = {\n          steeringManifest: steeringData,\n          url: url.toString()\n        };\n        this.hls.trigger(Events.STEERING_MANIFEST_LOADED, loadedSteeringData);\n        if (pathwayPriority) {\n          this.updatePathwayPriority(pathwayPriority);\n        }\n      },\n      onError: (error, context, networkDetails, stats) => {\n        this.log(`Error loading steering manifest: ${error.code} ${error.text} (${context.url})`);\n        this.stopLoad();\n        if (error.code === 410) {\n          this.enabled = false;\n          this.log(`Steering manifest ${context.url} no longer available`);\n          return;\n        }\n        let ttl = this.timeToLoad * 1000;\n        if (error.code === 429) {\n          const loader = this.loader;\n          if (typeof (loader == null ? void 0 : loader.getResponseHeader) === 'function') {\n            const retryAfter = loader.getResponseHeader('Retry-After');\n            if (retryAfter) {\n              ttl = parseFloat(retryAfter) * 1000;\n            }\n          }\n          this.log(`Steering manifest ${context.url} rate limited`);\n          return;\n        }\n        this.scheduleRefresh(this.uri || context.url, ttl);\n      },\n      onTimeout: (stats, context, networkDetails) => {\n        this.log(`Timeout loading steering manifest (${context.url})`);\n        this.scheduleRefresh(this.uri || context.url);\n      }\n    };\n    this.log(`Requesting steering manifest: ${url}`);\n    this.loader.load(context, loaderConfig, callbacks);\n  }\n  scheduleRefresh(uri, ttlMs = this.timeToLoad * 1000) {\n    this.clearTimeout();\n    this.reloadTimer = self.setTimeout(() => {\n      var _this$hls;\n      const media = (_this$hls = this.hls) == null ? void 0 : _this$hls.media;\n      if (media && !media.ended) {\n        this.loadSteeringManifest(uri);\n        return;\n      }\n      this.scheduleRefresh(uri, this.timeToLoad * 1000);\n    }, ttlMs);\n  }\n}\nfunction cloneRenditionGroups(tracks, groupCloneMap, uriReplacement, cloneId) {\n  if (!tracks) {\n    return;\n  }\n  Object.keys(groupCloneMap).forEach(audioGroupId => {\n    const clonedTracks = tracks.filter(track => track.groupId === audioGroupId).map(track => {\n      const clonedTrack = _extends({}, track);\n      clonedTrack.details = undefined;\n      clonedTrack.attrs = new AttrList(clonedTrack.attrs);\n      clonedTrack.url = clonedTrack.attrs.URI = performUriReplacement(track.url, track.attrs['STABLE-RENDITION-ID'], 'PER-RENDITION-URIS', uriReplacement);\n      clonedTrack.groupId = clonedTrack.attrs['GROUP-ID'] = groupCloneMap[audioGroupId];\n      clonedTrack.attrs['PATHWAY-ID'] = cloneId;\n      return clonedTrack;\n    });\n    tracks.push(...clonedTracks);\n  });\n}\nfunction performUriReplacement(uri, stableId, perOptionKey, uriReplacement) {\n  const {\n    HOST: host,\n    PARAMS: params,\n    [perOptionKey]: perOptionUris\n  } = uriReplacement;\n  let perVariantUri;\n  if (stableId) {\n    perVariantUri = perOptionUris == null ? void 0 : perOptionUris[stableId];\n    if (perVariantUri) {\n      uri = perVariantUri;\n    }\n  }\n  const url = new self.URL(uri);\n  if (host && !perVariantUri) {\n    url.host = host;\n  }\n  if (params) {\n    Object.keys(params).sort().forEach(key => {\n      if (key) {\n        url.searchParams.set(key, params[key]);\n      }\n    });\n  }\n  return url.href;\n}\n\nfunction addEventListener(el, type, listener) {\n  removeEventListener(el, type, listener);\n  el.addEventListener(type, listener);\n}\nfunction removeEventListener(el, type, listener) {\n  el.removeEventListener(type, listener);\n}\n\n/**\n * Controller to deal with encrypted media extensions (EME)\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API\n *\n * @class\n * @constructor\n */\nclass EMEController extends Logger {\n  constructor(hls) {\n    super('eme', hls.logger);\n    this.hls = void 0;\n    this.config = void 0;\n    this.media = null;\n    this.keyFormatPromise = null;\n    this.keySystemAccessPromises = {};\n    this._requestLicenseFailureCount = 0;\n    this.mediaKeySessions = [];\n    this.keyIdToKeySessionPromise = {};\n    this.mediaKeys = null;\n    this.setMediaKeysQueue = EMEController.CDMCleanupPromise ? [EMEController.CDMCleanupPromise] : [];\n    this.onWaitingForKey = event => {\n      this.log(`\"${event.type}\" event`);\n    };\n    this.hls = hls;\n    this.config = hls.config;\n    this.registerListeners();\n  }\n  destroy() {\n    this.onDestroying();\n    this.onMediaDetached();\n    // Remove any references that could be held in config options or callbacks\n    const config = this.config;\n    config.requestMediaKeySystemAccessFunc = null;\n    config.licenseXhrSetup = config.licenseResponseCallback = undefined;\n    config.drmSystems = config.drmSystemOptions = {};\n    // @ts-ignore\n    this.hls = this.config = this.keyIdToKeySessionPromise = null;\n    // @ts-ignore\n    this.onWaitingForKey = null;\n  }\n  registerListeners() {\n    this.hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    this.hls.on(Events.MEDIA_DETACHED, this.onMediaDetached, this);\n    this.hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    this.hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    this.hls.on(Events.DESTROYING, this.onDestroying, this);\n  }\n  unregisterListeners() {\n    this.hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    this.hls.off(Events.MEDIA_DETACHED, this.onMediaDetached, this);\n    this.hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    this.hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    this.hls.off(Events.DESTROYING, this.onDestroying, this);\n  }\n  getLicenseServerUrl(keySystem) {\n    const {\n      drmSystems,\n      widevineLicenseUrl\n    } = this.config;\n    const keySystemConfiguration = drmSystems[keySystem];\n    if (keySystemConfiguration) {\n      return keySystemConfiguration.licenseUrl;\n    }\n\n    // For backward compatibility\n    if (keySystem === KeySystems.WIDEVINE && widevineLicenseUrl) {\n      return widevineLicenseUrl;\n    }\n  }\n  getLicenseServerUrlOrThrow(keySystem) {\n    const url = this.getLicenseServerUrl(keySystem);\n    if (url === undefined) {\n      throw new Error(`no license server URL configured for key-system \"${keySystem}\"`);\n    }\n    return url;\n  }\n  getServerCertificateUrl(keySystem) {\n    const {\n      drmSystems\n    } = this.config;\n    const keySystemConfiguration = drmSystems[keySystem];\n    if (keySystemConfiguration) {\n      return keySystemConfiguration.serverCertificateUrl;\n    } else {\n      this.log(`No Server Certificate in config.drmSystems[\"${keySystem}\"]`);\n    }\n  }\n  attemptKeySystemAccess(keySystemsToAttempt) {\n    const levels = this.hls.levels;\n    const uniqueCodec = (value, i, a) => !!value && a.indexOf(value) === i;\n    const audioCodecs = levels.map(level => level.audioCodec).filter(uniqueCodec);\n    const videoCodecs = levels.map(level => level.videoCodec).filter(uniqueCodec);\n    if (audioCodecs.length + videoCodecs.length === 0) {\n      videoCodecs.push('avc1.42e01e');\n    }\n    return new Promise((resolve, reject) => {\n      const attempt = keySystems => {\n        const keySystem = keySystems.shift();\n        this.getMediaKeysPromise(keySystem, audioCodecs, videoCodecs).then(mediaKeys => resolve({\n          keySystem,\n          mediaKeys\n        })).catch(error => {\n          if (keySystems.length) {\n            attempt(keySystems);\n          } else if (error instanceof EMEKeyError) {\n            reject(error);\n          } else {\n            reject(new EMEKeyError({\n              type: ErrorTypes.KEY_SYSTEM_ERROR,\n              details: ErrorDetails.KEY_SYSTEM_NO_ACCESS,\n              error,\n              fatal: true\n            }, error.message));\n          }\n        });\n      };\n      attempt(keySystemsToAttempt);\n    });\n  }\n  requestMediaKeySystemAccess(keySystem, supportedConfigurations) {\n    const {\n      requestMediaKeySystemAccessFunc\n    } = this.config;\n    if (!(typeof requestMediaKeySystemAccessFunc === 'function')) {\n      let errMessage = `Configured requestMediaKeySystemAccess is not a function ${requestMediaKeySystemAccessFunc}`;\n      if (requestMediaKeySystemAccess === null && self.location.protocol === 'http:') {\n        errMessage = `navigator.requestMediaKeySystemAccess is not available over insecure protocol ${location.protocol}`;\n      }\n      return Promise.reject(new Error(errMessage));\n    }\n    return requestMediaKeySystemAccessFunc(keySystem, supportedConfigurations);\n  }\n  getMediaKeysPromise(keySystem, audioCodecs, videoCodecs) {\n    // This can throw, but is caught in event handler callpath\n    const mediaKeySystemConfigs = getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, this.config.drmSystemOptions);\n    const keySystemAccessPromises = this.keySystemAccessPromises[keySystem];\n    let keySystemAccess = keySystemAccessPromises == null ? void 0 : keySystemAccessPromises.keySystemAccess;\n    if (!keySystemAccess) {\n      this.log(`Requesting encrypted media \"${keySystem}\" key-system access with config: ${stringify(mediaKeySystemConfigs)}`);\n      keySystemAccess = this.requestMediaKeySystemAccess(keySystem, mediaKeySystemConfigs);\n      const _keySystemAccessPromises = this.keySystemAccessPromises[keySystem] = {\n        keySystemAccess\n      };\n      keySystemAccess.catch(error => {\n        this.log(`Failed to obtain access to key-system \"${keySystem}\": ${error}`);\n      });\n      return keySystemAccess.then(mediaKeySystemAccess => {\n        this.log(`Access for key-system \"${mediaKeySystemAccess.keySystem}\" obtained`);\n        const certificateRequest = this.fetchServerCertificate(keySystem);\n        this.log(`Create media-keys for \"${keySystem}\"`);\n        _keySystemAccessPromises.mediaKeys = mediaKeySystemAccess.createMediaKeys().then(mediaKeys => {\n          this.log(`Media-keys created for \"${keySystem}\"`);\n          _keySystemAccessPromises.hasMediaKeys = true;\n          return certificateRequest.then(certificate => {\n            if (certificate) {\n              return this.setMediaKeysServerCertificate(mediaKeys, keySystem, certificate);\n            }\n            return mediaKeys;\n          });\n        });\n        _keySystemAccessPromises.mediaKeys.catch(error => {\n          this.error(`Failed to create media-keys for \"${keySystem}\"}: ${error}`);\n        });\n        return _keySystemAccessPromises.mediaKeys;\n      });\n    }\n    return keySystemAccess.then(() => keySystemAccessPromises.mediaKeys);\n  }\n  createMediaKeySessionContext({\n    decryptdata,\n    keySystem,\n    mediaKeys\n  }) {\n    this.log(`Creating key-system session \"${keySystem}\" keyId: ${Hex.hexDump(decryptdata.keyId || [])}`);\n    const mediaKeysSession = mediaKeys.createSession();\n    const mediaKeySessionContext = {\n      decryptdata,\n      keySystem,\n      mediaKeys,\n      mediaKeysSession,\n      keyStatus: 'status-pending'\n    };\n    this.mediaKeySessions.push(mediaKeySessionContext);\n    return mediaKeySessionContext;\n  }\n  renewKeySession(mediaKeySessionContext) {\n    const decryptdata = mediaKeySessionContext.decryptdata;\n    if (decryptdata.pssh) {\n      const keySessionContext = this.createMediaKeySessionContext(mediaKeySessionContext);\n      const keyId = this.getKeyIdString(decryptdata);\n      const scheme = 'cenc';\n      this.keyIdToKeySessionPromise[keyId] = this.generateRequestWithPreferredKeySession(keySessionContext, scheme, decryptdata.pssh.buffer, 'expired');\n    } else {\n      this.warn(`Could not renew expired session. Missing pssh initData.`);\n    }\n    this.removeSession(mediaKeySessionContext);\n  }\n  getKeyIdString(decryptdata) {\n    if (!decryptdata) {\n      throw new Error('Could not read keyId of undefined decryptdata');\n    }\n    if (decryptdata.keyId === null) {\n      throw new Error('keyId is null');\n    }\n    return Hex.hexDump(decryptdata.keyId);\n  }\n  updateKeySession(mediaKeySessionContext, data) {\n    var _mediaKeySessionConte;\n    const keySession = mediaKeySessionContext.mediaKeysSession;\n    this.log(`Updating key-session \"${keySession.sessionId}\" for keyID ${Hex.hexDump(((_mediaKeySessionConte = mediaKeySessionContext.decryptdata) == null ? void 0 : _mediaKeySessionConte.keyId) || [])}\n      } (data length: ${data ? data.byteLength : data})`);\n    return keySession.update(data);\n  }\n  getSelectedKeySystemFormats() {\n    return Object.keys(this.keySystemAccessPromises).map(keySystem => ({\n      keySystem,\n      hasMediaKeys: this.keySystemAccessPromises[keySystem].hasMediaKeys\n    })).filter(({\n      hasMediaKeys\n    }) => !!hasMediaKeys).map(({\n      keySystem\n    }) => keySystemDomainToKeySystemFormat(keySystem)).filter(keySystem => !!keySystem);\n  }\n  getKeySystemAccess(keySystemsToAttempt) {\n    return this.getKeySystemSelectionPromise(keySystemsToAttempt).then(({\n      keySystem,\n      mediaKeys\n    }) => {\n      return this.attemptSetMediaKeys(keySystem, mediaKeys);\n    });\n  }\n  selectKeySystem(keySystemsToAttempt) {\n    return new Promise((resolve, reject) => {\n      return this.getKeySystemSelectionPromise(keySystemsToAttempt).then(({\n        keySystem\n      }) => {\n        const keySystemFormat = keySystemDomainToKeySystemFormat(keySystem);\n        if (keySystemFormat) {\n          resolve(keySystemFormat);\n        } else {\n          reject(new Error(`Unable to find format for key-system \"${keySystem}\"`));\n        }\n      }).catch(reject);\n    });\n  }\n  selectKeySystemFormat(frag) {\n    const keyFormats = Object.keys(frag.levelkeys || {});\n    if (!this.keyFormatPromise) {\n      this.log(`Selecting key-system from fragment (sn: ${frag.sn} ${frag.type}: ${frag.level}) key formats ${keyFormats.join(', ')}`);\n      this.keyFormatPromise = this.getKeyFormatPromise(keyFormats);\n    }\n    return this.keyFormatPromise;\n  }\n  getKeyFormatPromise(keyFormats) {\n    const keySystemsInConfig = getKeySystemsForConfig(this.config);\n    const keySystemsToAttempt = keyFormats.map(keySystemFormatToKeySystemDomain).filter(value => !!value && keySystemsInConfig.indexOf(value) !== -1);\n    return this.selectKeySystem(keySystemsToAttempt);\n  }\n  loadKey(data) {\n    const decryptdata = data.keyInfo.decryptdata;\n    const keyId = this.getKeyIdString(decryptdata);\n    const keyDetails = `(keyId: ${keyId} format: \"${decryptdata.keyFormat}\" method: ${decryptdata.method} uri: ${decryptdata.uri})`;\n    this.log(`Starting session for key ${keyDetails}`);\n    let keyContextPromise = this.keyIdToKeySessionPromise[keyId];\n    if (!keyContextPromise) {\n      keyContextPromise = this.getKeySystemForKeyPromise(decryptdata).then(({\n        keySystem,\n        mediaKeys\n      }) => {\n        this.throwIfDestroyed();\n        this.log(`Handle encrypted media sn: ${data.frag.sn} ${data.frag.type}: ${data.frag.level} using key ${keyDetails}`);\n        return this.attemptSetMediaKeys(keySystem, mediaKeys).then(() => {\n          this.throwIfDestroyed();\n          return this.createMediaKeySessionContext({\n            keySystem,\n            mediaKeys,\n            decryptdata\n          });\n        });\n      });\n      const keySessionContextPromise = this.keyIdToKeySessionPromise[keyId] = keyContextPromise.then(keySessionContext => {\n        const scheme = 'cenc';\n        const initData = decryptdata.pssh ? decryptdata.pssh.buffer : null;\n        return this.generateRequestWithPreferredKeySession(keySessionContext, scheme, initData, 'playlist-key');\n      });\n      keySessionContextPromise.catch(error => this.handleError(error));\n    }\n    return keyContextPromise;\n  }\n  throwIfDestroyed(message = 'Invalid state') {\n    if (!this.hls) {\n      throw new Error('invalid state');\n    }\n  }\n  handleError(error) {\n    if (!this.hls) {\n      return;\n    }\n    this.error(error.message);\n    if (error instanceof EMEKeyError) {\n      this.hls.trigger(Events.ERROR, error.data);\n    } else {\n      this.hls.trigger(Events.ERROR, {\n        type: ErrorTypes.KEY_SYSTEM_ERROR,\n        details: ErrorDetails.KEY_SYSTEM_NO_KEYS,\n        error,\n        fatal: true\n      });\n    }\n  }\n  getKeySystemForKeyPromise(decryptdata) {\n    const keyId = this.getKeyIdString(decryptdata);\n    const mediaKeySessionContext = this.keyIdToKeySessionPromise[keyId];\n    if (!mediaKeySessionContext) {\n      const keySystem = keySystemFormatToKeySystemDomain(decryptdata.keyFormat);\n      const keySystemsToAttempt = keySystem ? [keySystem] : getKeySystemsForConfig(this.config);\n      return this.attemptKeySystemAccess(keySystemsToAttempt);\n    }\n    return mediaKeySessionContext;\n  }\n  getKeySystemSelectionPromise(keySystemsToAttempt) {\n    if (!keySystemsToAttempt.length) {\n      keySystemsToAttempt = getKeySystemsForConfig(this.config);\n    }\n    if (keySystemsToAttempt.length === 0) {\n      throw new EMEKeyError({\n        type: ErrorTypes.KEY_SYSTEM_ERROR,\n        details: ErrorDetails.KEY_SYSTEM_NO_CONFIGURED_LICENSE,\n        fatal: true\n      }, `Missing key-system license configuration options ${stringify({\n        drmSystems: this.config.drmSystems\n      })}`);\n    }\n    return this.attemptKeySystemAccess(keySystemsToAttempt);\n  }\n  attemptSetMediaKeys(keySystem, mediaKeys) {\n    if (this.mediaKeys === mediaKeys) {\n      return Promise.resolve();\n    }\n    const queue = this.setMediaKeysQueue.slice();\n    this.log(`Setting media-keys for \"${keySystem}\"`);\n    // Only one setMediaKeys() can run at one time, and multiple setMediaKeys() operations\n    // can be queued for execution for multiple key sessions.\n    const setMediaKeysPromise = Promise.all(queue).then(() => {\n      if (!this.media) {\n        this.mediaKeys = null;\n        throw new Error('Attempted to set mediaKeys without media element attached');\n      }\n      return this.media.setMediaKeys(mediaKeys);\n    });\n    this.mediaKeys = mediaKeys;\n    this.setMediaKeysQueue.push(setMediaKeysPromise);\n    return setMediaKeysPromise.then(() => {\n      this.log(`Media-keys set for \"${keySystem}\"`);\n      queue.push(setMediaKeysPromise);\n      this.setMediaKeysQueue = this.setMediaKeysQueue.filter(p => queue.indexOf(p) === -1);\n    });\n  }\n  generateRequestWithPreferredKeySession(context, initDataType, initData, reason) {\n    var _this$config$drmSyste, _this$config$drmSyste2;\n    const generateRequestFilter = (_this$config$drmSyste = this.config.drmSystems) == null ? void 0 : (_this$config$drmSyste2 = _this$config$drmSyste[context.keySystem]) == null ? void 0 : _this$config$drmSyste2.generateRequest;\n    if (generateRequestFilter) {\n      try {\n        const mappedInitData = generateRequestFilter.call(this.hls, initDataType, initData, context);\n        if (!mappedInitData) {\n          throw new Error('Invalid response from configured generateRequest filter');\n        }\n        initDataType = mappedInitData.initDataType;\n        initData = mappedInitData.initData ? mappedInitData.initData : null;\n        context.decryptdata.pssh = initData ? new Uint8Array(initData) : null;\n      } catch (error) {\n        var _this$hls;\n        this.warn(error.message);\n        if ((_this$hls = this.hls) != null && _this$hls.config.debug) {\n          throw error;\n        }\n      }\n    }\n    if (initData === null) {\n      this.log(`Skipping key-session request for \"${reason}\" (no initData)`);\n      return Promise.resolve(context);\n    }\n    const keyId = this.getKeyIdString(context.decryptdata);\n    this.log(`Generating key-session request for \"${reason}\": ${keyId} (init data type: ${initDataType} length: ${initData ? initData.byteLength : null})`);\n    const licenseStatus = new EventEmitter();\n    const onmessage = context._onmessage = event => {\n      const keySession = context.mediaKeysSession;\n      if (!keySession) {\n        licenseStatus.emit('error', new Error('invalid state'));\n        return;\n      }\n      const {\n        messageType,\n        message\n      } = event;\n      this.log(`\"${messageType}\" message event for session \"${keySession.sessionId}\" message size: ${message.byteLength}`);\n      if (messageType === 'license-request' || messageType === 'license-renewal') {\n        this.renewLicense(context, message).catch(error => {\n          if (licenseStatus.eventNames().length) {\n            licenseStatus.emit('error', error);\n          } else {\n            this.handleError(error);\n          }\n        });\n      } else if (messageType === 'license-release') {\n        if (context.keySystem === KeySystems.FAIRPLAY) {\n          this.updateKeySession(context, strToUtf8array('acknowledged'));\n          this.removeSession(context);\n        }\n      } else {\n        this.warn(`unhandled media key message type \"${messageType}\"`);\n      }\n    };\n    const onkeystatuseschange = context._onkeystatuseschange = event => {\n      const keySession = context.mediaKeysSession;\n      if (!keySession) {\n        licenseStatus.emit('error', new Error('invalid state'));\n        return;\n      }\n      this.onKeyStatusChange(context);\n      const keyStatus = context.keyStatus;\n      licenseStatus.emit('keyStatus', keyStatus);\n      if (keyStatus === 'expired') {\n        this.warn(`${context.keySystem} expired for key ${keyId}`);\n        this.renewKeySession(context);\n      }\n    };\n    addEventListener(context.mediaKeysSession, 'message', onmessage);\n    addEventListener(context.mediaKeysSession, 'keystatuseschange', onkeystatuseschange);\n    const keyUsablePromise = new Promise((resolve, reject) => {\n      licenseStatus.on('error', reject);\n      licenseStatus.on('keyStatus', keyStatus => {\n        if (keyStatus.startsWith('usable')) {\n          resolve();\n        } else if (keyStatus === 'output-restricted') {\n          reject(new EMEKeyError({\n            type: ErrorTypes.KEY_SYSTEM_ERROR,\n            details: ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED,\n            fatal: false\n          }, 'HDCP level output restricted'));\n        } else if (keyStatus === 'internal-error') {\n          reject(new EMEKeyError({\n            type: ErrorTypes.KEY_SYSTEM_ERROR,\n            details: ErrorDetails.KEY_SYSTEM_STATUS_INTERNAL_ERROR,\n            fatal: true\n          }, `key status changed to \"${keyStatus}\"`));\n        } else if (keyStatus === 'expired') {\n          reject(new Error('key expired while generating request'));\n        } else {\n          this.warn(`unhandled key status change \"${keyStatus}\"`);\n        }\n      });\n    });\n    return context.mediaKeysSession.generateRequest(initDataType, initData).then(() => {\n      var _context$mediaKeysSes;\n      this.log(`Request generated for key-session \"${(_context$mediaKeysSes = context.mediaKeysSession) == null ? void 0 : _context$mediaKeysSes.sessionId}\" keyId: ${keyId}`);\n    }).catch(error => {\n      throw new EMEKeyError({\n        type: ErrorTypes.KEY_SYSTEM_ERROR,\n        details: ErrorDetails.KEY_SYSTEM_NO_SESSION,\n        error,\n        fatal: false\n      }, `Error generating key-session request: ${error}`);\n    }).then(() => keyUsablePromise).catch(error => {\n      licenseStatus.removeAllListeners();\n      this.removeSession(context);\n      throw error;\n    }).then(() => {\n      licenseStatus.removeAllListeners();\n      return context;\n    });\n  }\n  onKeyStatusChange(mediaKeySessionContext) {\n    mediaKeySessionContext.mediaKeysSession.keyStatuses.forEach((status, keyId) => {\n      // keyStatuses.forEach is not standard API so the callback value looks weird on xboxone\n      // xboxone callback(keyId, status) so we need to exchange them\n      if (typeof keyId === 'string' && typeof status === 'object') {\n        const temp = keyId;\n        keyId = status;\n        status = temp;\n      }\n      this.log(`key status change \"${status}\" for keyStatuses keyId: ${Hex.hexDump('buffer' in keyId ? new Uint8Array(keyId.buffer, keyId.byteOffset, keyId.byteLength) : new Uint8Array(keyId))} session keyId: ${Hex.hexDump(new Uint8Array(mediaKeySessionContext.decryptdata.keyId || []))} uri: ${mediaKeySessionContext.decryptdata.uri}`);\n      mediaKeySessionContext.keyStatus = status;\n    });\n  }\n  fetchServerCertificate(keySystem) {\n    const config = this.config;\n    const Loader = config.loader;\n    const certLoader = new Loader(config);\n    const url = this.getServerCertificateUrl(keySystem);\n    if (!url) {\n      return Promise.resolve();\n    }\n    this.log(`Fetching server certificate for \"${keySystem}\"`);\n    return new Promise((resolve, reject) => {\n      const loaderContext = {\n        responseType: 'arraybuffer',\n        url\n      };\n      const loadPolicy = config.certLoadPolicy.default;\n      const loaderConfig = {\n        loadPolicy,\n        timeout: loadPolicy.maxLoadTimeMs,\n        maxRetry: 0,\n        retryDelay: 0,\n        maxRetryDelay: 0\n      };\n      const loaderCallbacks = {\n        onSuccess: (response, stats, context, networkDetails) => {\n          resolve(response.data);\n        },\n        onError: (response, contex, networkDetails, stats) => {\n          reject(new EMEKeyError({\n            type: ErrorTypes.KEY_SYSTEM_ERROR,\n            details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,\n            fatal: true,\n            networkDetails,\n            response: _objectSpread2({\n              url: loaderContext.url,\n              data: undefined\n            }, response)\n          }, `\"${keySystem}\" certificate request failed (${url}). Status: ${response.code} (${response.text})`));\n        },\n        onTimeout: (stats, context, networkDetails) => {\n          reject(new EMEKeyError({\n            type: ErrorTypes.KEY_SYSTEM_ERROR,\n            details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,\n            fatal: true,\n            networkDetails,\n            response: {\n              url: loaderContext.url,\n              data: undefined\n            }\n          }, `\"${keySystem}\" certificate request timed out (${url})`));\n        },\n        onAbort: (stats, context, networkDetails) => {\n          reject(new Error('aborted'));\n        }\n      };\n      certLoader.load(loaderContext, loaderConfig, loaderCallbacks);\n    });\n  }\n  setMediaKeysServerCertificate(mediaKeys, keySystem, cert) {\n    return new Promise((resolve, reject) => {\n      mediaKeys.setServerCertificate(cert).then(success => {\n        this.log(`setServerCertificate ${success ? 'success' : 'not supported by CDM'} (${cert == null ? void 0 : cert.byteLength}) on \"${keySystem}\"`);\n        resolve(mediaKeys);\n      }).catch(error => {\n        reject(new EMEKeyError({\n          type: ErrorTypes.KEY_SYSTEM_ERROR,\n          details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED,\n          error,\n          fatal: true\n        }, error.message));\n      });\n    });\n  }\n  renewLicense(context, keyMessage) {\n    return this.requestLicense(context, new Uint8Array(keyMessage)).then(data => {\n      return this.updateKeySession(context, new Uint8Array(data)).catch(error => {\n        throw new EMEKeyError({\n          type: ErrorTypes.KEY_SYSTEM_ERROR,\n          details: ErrorDetails.KEY_SYSTEM_SESSION_UPDATE_FAILED,\n          error,\n          fatal: true\n        }, error.message);\n      });\n    });\n  }\n  unpackPlayReadyKeyMessage(xhr, licenseChallenge) {\n    // On Edge, the raw license message is UTF-16-encoded XML.  We need\n    // to unpack the Challenge element (base64-encoded string containing the\n    // actual license request) and any HttpHeader elements (sent as request\n    // headers).\n    // For PlayReady CDMs, we need to dig the Challenge out of the XML.\n    const xmlString = String.fromCharCode.apply(null, new Uint16Array(licenseChallenge.buffer));\n    if (!xmlString.includes('PlayReadyKeyMessage')) {\n      // This does not appear to be a wrapped message as on Edge.  Some\n      // clients do not need this unwrapping, so we will assume this is one of\n      // them.  Note that \"xml\" at this point probably looks like random\n      // garbage, since we interpreted UTF-8 as UTF-16.\n      xhr.setRequestHeader('Content-Type', 'text/xml; charset=utf-8');\n      return licenseChallenge;\n    }\n    const keyMessageXml = new DOMParser().parseFromString(xmlString, 'application/xml');\n    // Set request headers.\n    const headers = keyMessageXml.querySelectorAll('HttpHeader');\n    if (headers.length > 0) {\n      let header;\n      for (let i = 0, len = headers.length; i < len; i++) {\n        var _header$querySelector, _header$querySelector2;\n        header = headers[i];\n        const name = (_header$querySelector = header.querySelector('name')) == null ? void 0 : _header$querySelector.textContent;\n        const value = (_header$querySelector2 = header.querySelector('value')) == null ? void 0 : _header$querySelector2.textContent;\n        if (name && value) {\n          xhr.setRequestHeader(name, value);\n        }\n      }\n    }\n    const challengeElement = keyMessageXml.querySelector('Challenge');\n    const challengeText = challengeElement == null ? void 0 : challengeElement.textContent;\n    if (!challengeText) {\n      throw new Error(`Cannot find <Challenge> in key message`);\n    }\n    return strToUtf8array(atob(challengeText));\n  }\n  setupLicenseXHR(xhr, url, keysListItem, licenseChallenge) {\n    const licenseXhrSetup = this.config.licenseXhrSetup;\n    if (!licenseXhrSetup) {\n      xhr.open('POST', url, true);\n      return Promise.resolve({\n        xhr,\n        licenseChallenge\n      });\n    }\n    return Promise.resolve().then(() => {\n      if (!keysListItem.decryptdata) {\n        throw new Error('Key removed');\n      }\n      return licenseXhrSetup.call(this.hls, xhr, url, keysListItem, licenseChallenge);\n    }).catch(error => {\n      if (!keysListItem.decryptdata) {\n        // Key session removed. Cancel license request.\n        throw error;\n      }\n      // let's try to open before running setup\n      xhr.open('POST', url, true);\n      return licenseXhrSetup.call(this.hls, xhr, url, keysListItem, licenseChallenge);\n    }).then(licenseXhrSetupResult => {\n      // if licenseXhrSetup did not yet call open, let's do it now\n      if (!xhr.readyState) {\n        xhr.open('POST', url, true);\n      }\n      const finalLicenseChallenge = licenseXhrSetupResult ? licenseXhrSetupResult : licenseChallenge;\n      return {\n        xhr,\n        licenseChallenge: finalLicenseChallenge\n      };\n    });\n  }\n  requestLicense(keySessionContext, licenseChallenge) {\n    const keyLoadPolicy = this.config.keyLoadPolicy.default;\n    return new Promise((resolve, reject) => {\n      const url = this.getLicenseServerUrlOrThrow(keySessionContext.keySystem);\n      this.log(`Sending license request to URL: ${url}`);\n      const xhr = new XMLHttpRequest();\n      xhr.responseType = 'arraybuffer';\n      xhr.onreadystatechange = () => {\n        if (!this.hls || !keySessionContext.mediaKeysSession) {\n          return reject(new Error('invalid state'));\n        }\n        if (xhr.readyState === 4) {\n          if (xhr.status === 200) {\n            this._requestLicenseFailureCount = 0;\n            let data = xhr.response;\n            this.log(`License received ${data instanceof ArrayBuffer ? data.byteLength : data}`);\n            const licenseResponseCallback = this.config.licenseResponseCallback;\n            if (licenseResponseCallback) {\n              try {\n                data = licenseResponseCallback.call(this.hls, xhr, url, keySessionContext);\n              } catch (error) {\n                this.error(error);\n              }\n            }\n            resolve(data);\n          } else {\n            const retryConfig = keyLoadPolicy.errorRetry;\n            const maxNumRetry = retryConfig ? retryConfig.maxNumRetry : 0;\n            this._requestLicenseFailureCount++;\n            if (this._requestLicenseFailureCount > maxNumRetry || xhr.status >= 400 && xhr.status < 500) {\n              reject(new EMEKeyError({\n                type: ErrorTypes.KEY_SYSTEM_ERROR,\n                details: ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,\n                fatal: true,\n                networkDetails: xhr,\n                response: {\n                  url,\n                  data: undefined,\n                  code: xhr.status,\n                  text: xhr.statusText\n                }\n              }, `License Request XHR failed (${url}). Status: ${xhr.status} (${xhr.statusText})`));\n            } else {\n              const attemptsLeft = maxNumRetry - this._requestLicenseFailureCount + 1;\n              this.warn(`Retrying license request, ${attemptsLeft} attempts left`);\n              this.requestLicense(keySessionContext, licenseChallenge).then(resolve, reject);\n            }\n          }\n        }\n      };\n      if (keySessionContext.licenseXhr && keySessionContext.licenseXhr.readyState !== XMLHttpRequest.DONE) {\n        keySessionContext.licenseXhr.abort();\n      }\n      keySessionContext.licenseXhr = xhr;\n      this.setupLicenseXHR(xhr, url, keySessionContext, licenseChallenge).then(({\n        xhr,\n        licenseChallenge\n      }) => {\n        if (keySessionContext.keySystem == KeySystems.PLAYREADY) {\n          licenseChallenge = this.unpackPlayReadyKeyMessage(xhr, licenseChallenge);\n        }\n        xhr.send(licenseChallenge);\n      });\n    });\n  }\n  onDestroying() {\n    this.unregisterListeners();\n    this._clear();\n  }\n  onMediaAttached(event, data) {\n    if (!this.config.emeEnabled) {\n      return;\n    }\n    const media = data.media;\n\n    // keep reference of media\n    this.media = media;\n    addEventListener(media, 'waitingforkey', this.onWaitingForKey);\n  }\n  onMediaDetached() {\n    const media = this.media;\n    if (media) {\n      removeEventListener(media, 'waitingforkey', this.onWaitingForKey);\n      this.media = null;\n      this.mediaKeys = null;\n    }\n  }\n  _clear() {\n    var _media$setMediaKeys;\n    this._requestLicenseFailureCount = 0;\n    this.keyIdToKeySessionPromise = {};\n    if (!this.mediaKeys && !this.mediaKeySessions.length) {\n      return;\n    }\n    const media = this.media;\n    const mediaKeysList = this.mediaKeySessions.slice();\n    this.mediaKeySessions = [];\n    this.mediaKeys = null;\n    LevelKey.clearKeyUriToKeyIdMap();\n\n    // Close all sessions and remove media keys from the video element.\n    const keySessionCount = mediaKeysList.length;\n    EMEController.CDMCleanupPromise = Promise.all(mediaKeysList.map(mediaKeySessionContext => this.removeSession(mediaKeySessionContext)).concat(media == null ? void 0 : (_media$setMediaKeys = media.setMediaKeys(null)) == null ? void 0 : _media$setMediaKeys.catch(error => {\n      var _this$hls2;\n      this.log(`Could not clear media keys: ${error}`);\n      (_this$hls2 = this.hls) == null ? void 0 : _this$hls2.trigger(Events.ERROR, {\n        type: ErrorTypes.OTHER_ERROR,\n        details: ErrorDetails.KEY_SYSTEM_DESTROY_MEDIA_KEYS_ERROR,\n        fatal: false,\n        error: new Error(`Could not clear media keys: ${error}`)\n      });\n    }))).catch(error => {\n      var _this$hls3;\n      this.log(`Could not close sessions and clear media keys: ${error}`);\n      (_this$hls3 = this.hls) == null ? void 0 : _this$hls3.trigger(Events.ERROR, {\n        type: ErrorTypes.OTHER_ERROR,\n        details: ErrorDetails.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR,\n        fatal: false,\n        error: new Error(`Could not close sessions and clear media keys: ${error}`)\n      });\n    }).then(() => {\n      if (keySessionCount) {\n        this.log('finished closing key sessions and clearing media keys');\n      }\n    });\n  }\n  onManifestLoading() {\n    this.keyFormatPromise = null;\n  }\n  onManifestLoaded(event, {\n    sessionKeys\n  }) {\n    if (!sessionKeys || !this.config.emeEnabled) {\n      return;\n    }\n    if (!this.keyFormatPromise) {\n      const keyFormats = sessionKeys.reduce((formats, sessionKey) => {\n        if (formats.indexOf(sessionKey.keyFormat) === -1) {\n          formats.push(sessionKey.keyFormat);\n        }\n        return formats;\n      }, []);\n      this.log(`Selecting key-system from session-keys ${keyFormats.join(', ')}`);\n      this.keyFormatPromise = this.getKeyFormatPromise(keyFormats);\n    }\n  }\n  removeSession(mediaKeySessionContext) {\n    const {\n      mediaKeysSession,\n      licenseXhr\n    } = mediaKeySessionContext;\n    if (mediaKeysSession) {\n      this.log(`Remove licenses and keys and close session ${mediaKeysSession.sessionId}`);\n      if (mediaKeySessionContext._onmessage) {\n        mediaKeysSession.removeEventListener('message', mediaKeySessionContext._onmessage);\n        mediaKeySessionContext._onmessage = undefined;\n      }\n      if (mediaKeySessionContext._onkeystatuseschange) {\n        mediaKeysSession.removeEventListener('keystatuseschange', mediaKeySessionContext._onkeystatuseschange);\n        mediaKeySessionContext._onkeystatuseschange = undefined;\n      }\n      if (licenseXhr && licenseXhr.readyState !== XMLHttpRequest.DONE) {\n        licenseXhr.abort();\n      }\n      mediaKeySessionContext.mediaKeysSession = mediaKeySessionContext.decryptdata = mediaKeySessionContext.licenseXhr = undefined;\n      const index = this.mediaKeySessions.indexOf(mediaKeySessionContext);\n      if (index > -1) {\n        this.mediaKeySessions.splice(index, 1);\n      }\n      const {\n        drmSystemOptions\n      } = this.config;\n      const removePromise = isPersistentSessionType(drmSystemOptions) ? new Promise((resolve, reject) => {\n        self.setTimeout(() => reject(new Error(`MediaKeySession.remove() timeout`)), 8000);\n        mediaKeysSession.remove().then(resolve);\n      }) : Promise.resolve();\n      return removePromise.catch(error => {\n        var _this$hls4;\n        this.log(`Could not remove session: ${error}`);\n        (_this$hls4 = this.hls) == null ? void 0 : _this$hls4.trigger(Events.ERROR, {\n          type: ErrorTypes.OTHER_ERROR,\n          details: ErrorDetails.KEY_SYSTEM_DESTROY_REMOVE_SESSION_ERROR,\n          fatal: false,\n          error: new Error(`Could not remove session: ${error}`)\n        });\n      }).then(() => {\n        return mediaKeysSession.close();\n      }).catch(error => {\n        var _this$hls5;\n        this.log(`Could not close session: ${error}`);\n        (_this$hls5 = this.hls) == null ? void 0 : _this$hls5.trigger(Events.ERROR, {\n          type: ErrorTypes.OTHER_ERROR,\n          details: ErrorDetails.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR,\n          fatal: false,\n          error: new Error(`Could not close session: ${error}`)\n        });\n      });\n    }\n  }\n}\nEMEController.CDMCleanupPromise = void 0;\nclass EMEKeyError extends Error {\n  constructor(data, message) {\n    super(message);\n    this.data = void 0;\n    data.error || (data.error = new Error(message));\n    this.data = data;\n    data.err = data.error;\n  }\n}\n\nclass FPSController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.isVideoPlaybackQualityAvailable = false;\n    this.timer = void 0;\n    this.media = null;\n    this.lastTime = void 0;\n    this.lastDroppedFrames = 0;\n    this.lastDecodedFrames = 0;\n    // stream controller must be provided as a dependency!\n    this.streamController = void 0;\n    this.hls = hls;\n    this.registerListeners();\n  }\n  setStreamController(streamController) {\n    this.streamController = streamController;\n  }\n  registerListeners() {\n    this.hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    this.hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n  }\n  unregisterListeners() {\n    this.hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    this.hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n  }\n  destroy() {\n    if (this.timer) {\n      clearInterval(this.timer);\n    }\n    this.unregisterListeners();\n    this.isVideoPlaybackQualityAvailable = false;\n    this.media = null;\n  }\n  onMediaAttaching(event, data) {\n    const config = this.hls.config;\n    if (config.capLevelOnFPSDrop) {\n      const media = data.media instanceof self.HTMLVideoElement ? data.media : null;\n      this.media = media;\n      if (media && typeof media.getVideoPlaybackQuality === 'function') {\n        this.isVideoPlaybackQualityAvailable = true;\n      }\n      self.clearInterval(this.timer);\n      this.timer = self.setInterval(this.checkFPSInterval.bind(this), config.fpsDroppedMonitoringPeriod);\n    }\n  }\n  onMediaDetaching() {\n    this.media = null;\n  }\n  checkFPS(video, decodedFrames, droppedFrames) {\n    const currentTime = performance.now();\n    if (decodedFrames) {\n      if (this.lastTime) {\n        const currentPeriod = currentTime - this.lastTime;\n        const currentDropped = droppedFrames - this.lastDroppedFrames;\n        const currentDecoded = decodedFrames - this.lastDecodedFrames;\n        const droppedFPS = 1000 * currentDropped / currentPeriod;\n        const hls = this.hls;\n        hls.trigger(Events.FPS_DROP, {\n          currentDropped: currentDropped,\n          currentDecoded: currentDecoded,\n          totalDroppedFrames: droppedFrames\n        });\n        if (droppedFPS > 0) {\n          // hls.logger.log('checkFPS : droppedFPS/decodedFPS:' + droppedFPS/(1000 * currentDecoded / currentPeriod));\n          if (currentDropped > hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {\n            let currentLevel = hls.currentLevel;\n            hls.logger.warn('drop FPS ratio greater than max allowed value for currentLevel: ' + currentLevel);\n            if (currentLevel > 0 && (hls.autoLevelCapping === -1 || hls.autoLevelCapping >= currentLevel)) {\n              currentLevel = currentLevel - 1;\n              hls.trigger(Events.FPS_DROP_LEVEL_CAPPING, {\n                level: currentLevel,\n                droppedLevel: hls.currentLevel\n              });\n              hls.autoLevelCapping = currentLevel;\n              this.streamController.nextLevelSwitch();\n            }\n          }\n        }\n      }\n      this.lastTime = currentTime;\n      this.lastDroppedFrames = droppedFrames;\n      this.lastDecodedFrames = decodedFrames;\n    }\n  }\n  checkFPSInterval() {\n    const video = this.media;\n    if (video) {\n      if (this.isVideoPlaybackQualityAvailable) {\n        const videoPlaybackQuality = video.getVideoPlaybackQuality();\n        this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);\n      } else {\n        // HTMLVideoElement doesn't include the webkit types\n        this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);\n      }\n    }\n  }\n}\n\nfunction sendAddTrackEvent(track, videoEl) {\n  let event;\n  try {\n    event = new Event('addtrack');\n  } catch (err) {\n    // for IE11\n    event = document.createEvent('Event');\n    event.initEvent('addtrack', false, false);\n  }\n  event.track = track;\n  videoEl.dispatchEvent(event);\n}\nfunction addCueToTrack(track, cue) {\n  // Sometimes there are cue overlaps on segmented vtts so the same\n  // cue can appear more than once in different vtt files.\n  // This avoid showing duplicated cues with same timecode and text.\n  const mode = track.mode;\n  if (mode === 'disabled') {\n    track.mode = 'hidden';\n  }\n  if (track.cues && !track.cues.getCueById(cue.id)) {\n    try {\n      track.addCue(cue);\n      if (!track.cues.getCueById(cue.id)) {\n        throw new Error(`addCue is failed for: ${cue}`);\n      }\n    } catch (err) {\n      logger.debug(`[texttrack-utils]: ${err}`);\n      try {\n        const textTrackCue = new self.TextTrackCue(cue.startTime, cue.endTime, cue.text);\n        textTrackCue.id = cue.id;\n        track.addCue(textTrackCue);\n      } catch (err2) {\n        logger.debug(`[texttrack-utils]: Legacy TextTrackCue fallback failed: ${err2}`);\n      }\n    }\n  }\n  if (mode === 'disabled') {\n    track.mode = mode;\n  }\n}\nfunction clearCurrentCues(track, enterHandler) {\n  // When track.mode is disabled, track.cues will be null.\n  // To guarantee the removal of cues, we need to temporarily\n  // change the mode to hidden\n  const mode = track.mode;\n  if (mode === 'disabled') {\n    track.mode = 'hidden';\n  }\n  if (track.cues) {\n    for (let i = track.cues.length; i--;) {\n      if (enterHandler) {\n        track.cues[i].removeEventListener('enter', enterHandler);\n      }\n      track.removeCue(track.cues[i]);\n    }\n  }\n  if (mode === 'disabled') {\n    track.mode = mode;\n  }\n}\nfunction removeCuesInRange(track, start, end, predicate) {\n  const mode = track.mode;\n  if (mode === 'disabled') {\n    track.mode = 'hidden';\n  }\n  if (track.cues && track.cues.length > 0) {\n    const cues = getCuesInRange(track.cues, start, end);\n    for (let i = 0; i < cues.length; i++) {\n      if (!predicate || predicate(cues[i])) {\n        track.removeCue(cues[i]);\n      }\n    }\n  }\n  if (mode === 'disabled') {\n    track.mode = mode;\n  }\n}\n\n// Find first cue starting at or after given time.\n// Modified version of binary search O(log(n)).\nfunction getFirstCueIndexFromTime(cues, time) {\n  // If first cue starts at or after time, start there\n  if (time <= cues[0].startTime) {\n    return 0;\n  }\n  // If the last cue ends before time there is no overlap\n  const len = cues.length - 1;\n  if (time > cues[len].endTime) {\n    return -1;\n  }\n  let left = 0;\n  let right = len;\n  let mid;\n  while (left <= right) {\n    mid = Math.floor((right + left) / 2);\n    if (time < cues[mid].startTime) {\n      right = mid - 1;\n    } else if (time > cues[mid].startTime && left < len) {\n      left = mid + 1;\n    } else {\n      // If it's not lower or higher, it must be equal.\n      return mid;\n    }\n  }\n  // At this point, left and right have swapped.\n  // No direct match was found, left or right element must be the closest. Check which one has the smallest diff.\n  return cues[left].startTime - time < time - cues[right].startTime ? left : right;\n}\nfunction getCuesInRange(cues, start, end) {\n  const cuesFound = [];\n  const firstCueInRange = getFirstCueIndexFromTime(cues, start);\n  if (firstCueInRange > -1) {\n    for (let i = firstCueInRange, len = cues.length; i < len; i++) {\n      const cue = cues[i];\n      if (cue.startTime >= start && cue.endTime <= end) {\n        cuesFound.push(cue);\n      } else if (cue.startTime > end) {\n        return cuesFound;\n      }\n    }\n  }\n  return cuesFound;\n}\nfunction filterSubtitleTracks(textTrackList) {\n  const tracks = [];\n  for (let i = 0; i < textTrackList.length; i++) {\n    const track = textTrackList[i];\n    // Edge adds a track without a label; we don't want to use it\n    if ((track.kind === 'subtitles' || track.kind === 'captions') && track.label) {\n      tracks.push(textTrackList[i]);\n    }\n  }\n  return tracks;\n}\n\nclass SubtitleTrackController extends BasePlaylistController {\n  constructor(hls) {\n    super(hls, 'subtitle-track-controller');\n    this.media = null;\n    this.tracks = [];\n    this.groupIds = null;\n    this.tracksInGroup = [];\n    this.trackId = -1;\n    this.currentTrack = null;\n    this.selectDefaultTrack = true;\n    this.queuedDefaultTrack = -1;\n    this.useTextTrackPolling = false;\n    this.subtitlePollingInterval = -1;\n    this._subtitleDisplay = true;\n    this.asyncPollTrackChange = () => this.pollTrackChange(0);\n    this.onTextTracksChanged = () => {\n      if (!this.useTextTrackPolling) {\n        self.clearInterval(this.subtitlePollingInterval);\n      }\n      // Media is undefined when switching streams via loadSource()\n      if (!this.media || !this.hls.config.renderTextTracksNatively) {\n        return;\n      }\n      let textTrack = null;\n      const tracks = filterSubtitleTracks(this.media.textTracks);\n      for (let i = 0; i < tracks.length; i++) {\n        if (tracks[i].mode === 'hidden') {\n          // Do not break in case there is a following track with showing.\n          textTrack = tracks[i];\n        } else if (tracks[i].mode === 'showing') {\n          textTrack = tracks[i];\n          break;\n        }\n      }\n\n      // Find internal track index for TextTrack\n      const trackId = this.findTrackForTextTrack(textTrack);\n      if (this.subtitleTrack !== trackId) {\n        this.setSubtitleTrack(trackId);\n      }\n    };\n    this.registerListeners();\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.tracks.length = 0;\n    this.tracksInGroup.length = 0;\n    this.currentTrack = null;\n    // @ts-ignore\n    this.onTextTracksChanged = this.asyncPollTrackChange = null;\n    super.destroy();\n  }\n  get subtitleDisplay() {\n    return this._subtitleDisplay;\n  }\n  set subtitleDisplay(value) {\n    this._subtitleDisplay = value;\n    if (this.trackId > -1) {\n      this.toggleTrackModes();\n    }\n  }\n  registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.on(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n    hls.on(Events.ERROR, this.onError, this);\n  }\n  unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.off(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n    hls.off(Events.ERROR, this.onError, this);\n  }\n\n  // Listen for subtitle track change, then extract the current track ID.\n  onMediaAttached(event, data) {\n    this.media = data.media;\n    if (!this.media) {\n      return;\n    }\n    if (this.queuedDefaultTrack > -1) {\n      this.subtitleTrack = this.queuedDefaultTrack;\n      this.queuedDefaultTrack = -1;\n    }\n    this.useTextTrackPolling = !(this.media.textTracks && 'onchange' in this.media.textTracks);\n    if (this.useTextTrackPolling) {\n      this.pollTrackChange(500);\n    } else {\n      this.media.textTracks.addEventListener('change', this.asyncPollTrackChange);\n    }\n  }\n  pollTrackChange(timeout) {\n    self.clearInterval(this.subtitlePollingInterval);\n    this.subtitlePollingInterval = self.setInterval(this.onTextTracksChanged, timeout);\n  }\n  onMediaDetaching(event, data) {\n    const media = this.media;\n    if (!media) {\n      return;\n    }\n    const transferringMedia = !!data.transferMedia;\n    self.clearInterval(this.subtitlePollingInterval);\n    if (!this.useTextTrackPolling) {\n      media.textTracks.removeEventListener('change', this.asyncPollTrackChange);\n    }\n    if (this.trackId > -1) {\n      this.queuedDefaultTrack = this.trackId;\n    }\n\n    // Disable all subtitle tracks before detachment so when reattached only tracks in that content are enabled.\n    this.subtitleTrack = -1;\n    this.media = null;\n    if (transferringMedia) {\n      return;\n    }\n    const textTracks = filterSubtitleTracks(media.textTracks);\n    // Clear loaded cues on media detachment from tracks\n    textTracks.forEach(track => {\n      clearCurrentCues(track);\n    });\n  }\n  onManifestLoading() {\n    this.tracks = [];\n    this.groupIds = null;\n    this.tracksInGroup = [];\n    this.trackId = -1;\n    this.currentTrack = null;\n    this.selectDefaultTrack = true;\n  }\n\n  // Fired whenever a new manifest is loaded.\n  onManifestParsed(event, data) {\n    this.tracks = data.subtitleTracks;\n  }\n  onSubtitleTrackLoaded(event, data) {\n    const {\n      id,\n      groupId,\n      details\n    } = data;\n    const trackInActiveGroup = this.tracksInGroup[id];\n    if (!trackInActiveGroup || trackInActiveGroup.groupId !== groupId) {\n      this.warn(`Subtitle track with id:${id} and group:${groupId} not found in active group ${trackInActiveGroup == null ? void 0 : trackInActiveGroup.groupId}`);\n      return;\n    }\n    const curDetails = trackInActiveGroup.details;\n    trackInActiveGroup.details = data.details;\n    this.log(`Subtitle track ${id} \"${trackInActiveGroup.name}\" lang:${trackInActiveGroup.lang} group:${groupId} loaded [${details.startSN}-${details.endSN}]`);\n    if (id === this.trackId) {\n      this.playlistLoaded(id, data, curDetails);\n    }\n  }\n  onLevelLoading(event, data) {\n    this.switchLevel(data.level);\n  }\n  onLevelSwitching(event, data) {\n    this.switchLevel(data.level);\n  }\n  switchLevel(levelIndex) {\n    const levelInfo = this.hls.levels[levelIndex];\n    if (!levelInfo) {\n      return;\n    }\n    const subtitleGroups = levelInfo.subtitleGroups || null;\n    const currentGroups = this.groupIds;\n    let currentTrack = this.currentTrack;\n    if (!subtitleGroups || (currentGroups == null ? void 0 : currentGroups.length) !== (subtitleGroups == null ? void 0 : subtitleGroups.length) || subtitleGroups != null && subtitleGroups.some(groupId => (currentGroups == null ? void 0 : currentGroups.indexOf(groupId)) === -1)) {\n      this.groupIds = subtitleGroups;\n      this.trackId = -1;\n      this.currentTrack = null;\n      const subtitleTracks = this.tracks.filter(track => !subtitleGroups || subtitleGroups.indexOf(track.groupId) !== -1);\n      if (subtitleTracks.length) {\n        // Disable selectDefaultTrack if there are no default tracks\n        if (this.selectDefaultTrack && !subtitleTracks.some(track => track.default)) {\n          this.selectDefaultTrack = false;\n        }\n        // track.id should match hls.audioTracks index\n        subtitleTracks.forEach((track, i) => {\n          track.id = i;\n        });\n      } else if (!currentTrack && !this.tracksInGroup.length) {\n        // Do not dispatch SUBTITLE_TRACKS_UPDATED when there were and are no tracks\n        return;\n      }\n      this.tracksInGroup = subtitleTracks;\n\n      // Find preferred track\n      const subtitlePreference = this.hls.config.subtitlePreference;\n      if (!currentTrack && subtitlePreference) {\n        this.selectDefaultTrack = false;\n        const groupIndex = findMatchingOption(subtitlePreference, subtitleTracks);\n        if (groupIndex > -1) {\n          currentTrack = subtitleTracks[groupIndex];\n        } else {\n          const allIndex = findMatchingOption(subtitlePreference, this.tracks);\n          currentTrack = this.tracks[allIndex];\n        }\n      }\n\n      // Select initial track\n      let trackId = this.findTrackId(currentTrack);\n      if (trackId === -1 && currentTrack) {\n        trackId = this.findTrackId(null);\n      }\n\n      // Dispatch events and load track if needed\n      const subtitleTracksUpdated = {\n        subtitleTracks\n      };\n      this.log(`Updating subtitle tracks, ${subtitleTracks.length} track(s) found in \"${subtitleGroups == null ? void 0 : subtitleGroups.join(',')}\" group-id`);\n      this.hls.trigger(Events.SUBTITLE_TRACKS_UPDATED, subtitleTracksUpdated);\n      if (trackId !== -1 && this.trackId === -1) {\n        this.setSubtitleTrack(trackId);\n      }\n    }\n  }\n  findTrackId(currentTrack) {\n    const tracks = this.tracksInGroup;\n    const selectDefault = this.selectDefaultTrack;\n    for (let i = 0; i < tracks.length; i++) {\n      const track = tracks[i];\n      if (selectDefault && !track.default || !selectDefault && !currentTrack) {\n        continue;\n      }\n      if (!currentTrack || matchesOption(track, currentTrack)) {\n        return i;\n      }\n    }\n    if (currentTrack) {\n      for (let i = 0; i < tracks.length; i++) {\n        const track = tracks[i];\n        if (mediaAttributesIdentical(currentTrack.attrs, track.attrs, ['LANGUAGE', 'ASSOC-LANGUAGE', 'CHARACTERISTICS'])) {\n          return i;\n        }\n      }\n      for (let i = 0; i < tracks.length; i++) {\n        const track = tracks[i];\n        if (mediaAttributesIdentical(currentTrack.attrs, track.attrs, ['LANGUAGE'])) {\n          return i;\n        }\n      }\n    }\n    return -1;\n  }\n  findTrackForTextTrack(textTrack) {\n    if (textTrack) {\n      const tracks = this.tracksInGroup;\n      for (let i = 0; i < tracks.length; i++) {\n        const track = tracks[i];\n        if (subtitleTrackMatchesTextTrack(track, textTrack)) {\n          return i;\n        }\n      }\n    }\n    return -1;\n  }\n  onError(event, data) {\n    if (data.fatal || !data.context) {\n      return;\n    }\n    if (data.context.type === PlaylistContextType.SUBTITLE_TRACK && data.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(data.context.groupId) !== -1)) {\n      this.checkRetry(data);\n    }\n  }\n  get allSubtitleTracks() {\n    return this.tracks;\n  }\n\n  /** get alternate subtitle tracks list from playlist **/\n  get subtitleTracks() {\n    return this.tracksInGroup;\n  }\n\n  /** get/set index of the selected subtitle track (based on index in subtitle track lists) **/\n  get subtitleTrack() {\n    return this.trackId;\n  }\n  set subtitleTrack(newId) {\n    this.selectDefaultTrack = false;\n    this.setSubtitleTrack(newId);\n  }\n  setSubtitleOption(subtitleOption) {\n    this.hls.config.subtitlePreference = subtitleOption;\n    if (subtitleOption) {\n      if (subtitleOption.id === -1) {\n        this.setSubtitleTrack(-1);\n        return null;\n      }\n      const allSubtitleTracks = this.allSubtitleTracks;\n      this.selectDefaultTrack = false;\n      if (allSubtitleTracks.length) {\n        // First see if current option matches (no switch op)\n        const currentTrack = this.currentTrack;\n        if (currentTrack && matchesOption(subtitleOption, currentTrack)) {\n          return currentTrack;\n        }\n        // Find option in current group\n        const groupIndex = findMatchingOption(subtitleOption, this.tracksInGroup);\n        if (groupIndex > -1) {\n          const track = this.tracksInGroup[groupIndex];\n          this.setSubtitleTrack(groupIndex);\n          return track;\n        } else if (currentTrack) {\n          // If this is not the initial selection return null\n          // option should have matched one in active group\n          return null;\n        } else {\n          // Find the option in all tracks for initial selection\n          const allIndex = findMatchingOption(subtitleOption, allSubtitleTracks);\n          if (allIndex > -1) {\n            return allSubtitleTracks[allIndex];\n          }\n        }\n      }\n    }\n    return null;\n  }\n  loadPlaylist(hlsUrlParameters) {\n    super.loadPlaylist();\n    if (this.shouldLoadPlaylist(this.currentTrack)) {\n      this.scheduleLoading(this.currentTrack, hlsUrlParameters);\n    }\n  }\n  loadingPlaylist(currentTrack, hlsUrlParameters) {\n    super.loadingPlaylist(currentTrack, hlsUrlParameters);\n    const id = currentTrack.id;\n    const groupId = currentTrack.groupId;\n    const url = this.getUrlWithDirectives(currentTrack.url, hlsUrlParameters);\n    const details = currentTrack.details;\n    const age = details == null ? void 0 : details.age;\n    this.log(`Loading subtitle ${id} \"${currentTrack.name}\" lang:${currentTrack.lang} group:${groupId}${(hlsUrlParameters == null ? void 0 : hlsUrlParameters.msn) !== undefined ? ' at sn ' + hlsUrlParameters.msn + ' part ' + hlsUrlParameters.part : ''}${age && details.live ? ' age ' + age.toFixed(1) + (details.type ? ' ' + details.type || 0 : '') : ''} ${url}`);\n    this.hls.trigger(Events.SUBTITLE_TRACK_LOADING, {\n      url,\n      id,\n      groupId,\n      deliveryDirectives: hlsUrlParameters || null,\n      track: currentTrack\n    });\n  }\n\n  /**\n   * Disables the old subtitleTrack and sets current mode on the next subtitleTrack.\n   * This operates on the DOM textTracks.\n   * A value of -1 will disable all subtitle tracks.\n   */\n  toggleTrackModes() {\n    const {\n      media\n    } = this;\n    if (!media) {\n      return;\n    }\n    const textTracks = filterSubtitleTracks(media.textTracks);\n    const currentTrack = this.currentTrack;\n    let nextTrack;\n    if (currentTrack) {\n      nextTrack = textTracks.filter(textTrack => subtitleTrackMatchesTextTrack(currentTrack, textTrack))[0];\n      if (!nextTrack) {\n        this.warn(`Unable to find subtitle TextTrack with name \"${currentTrack.name}\" and language \"${currentTrack.lang}\"`);\n      }\n    }\n    [].slice.call(textTracks).forEach(track => {\n      if (track.mode !== 'disabled' && track !== nextTrack) {\n        track.mode = 'disabled';\n      }\n    });\n    if (nextTrack) {\n      const mode = this.subtitleDisplay ? 'showing' : 'hidden';\n      if (nextTrack.mode !== mode) {\n        nextTrack.mode = mode;\n      }\n    }\n  }\n\n  /**\n   * This method is responsible for validating the subtitle index and periodically reloading if live.\n   * Dispatches the SUBTITLE_TRACK_SWITCH event, which instructs the subtitle-stream-controller to load the selected track.\n   */\n  setSubtitleTrack(newId) {\n    const tracks = this.tracksInGroup;\n\n    // setting this.subtitleTrack will trigger internal logic\n    // if media has not been attached yet, it will fail\n    // we keep a reference to the default track id\n    // and we'll set subtitleTrack when onMediaAttached is triggered\n    if (!this.media) {\n      this.queuedDefaultTrack = newId;\n      return;\n    }\n\n    // exit if track id as already set or invalid\n    if (newId < -1 || newId >= tracks.length || !isFiniteNumber(newId)) {\n      this.warn(`Invalid subtitle track id: ${newId}`);\n      return;\n    }\n    this.selectDefaultTrack = false;\n    const lastTrack = this.currentTrack;\n    const track = tracks[newId] || null;\n    this.trackId = newId;\n    this.currentTrack = track;\n    this.toggleTrackModes();\n    if (!track) {\n      // switch to -1\n      this.hls.trigger(Events.SUBTITLE_TRACK_SWITCH, {\n        id: newId\n      });\n      return;\n    }\n    const trackLoaded = !!track.details && !track.details.live;\n    if (newId === this.trackId && track === lastTrack && trackLoaded) {\n      return;\n    }\n    this.log(`Switching to subtitle-track ${newId}` + (track ? ` \"${track.name}\" lang:${track.lang} group:${track.groupId}` : ''));\n    const {\n      id,\n      groupId = '',\n      name,\n      type,\n      url\n    } = track;\n    this.hls.trigger(Events.SUBTITLE_TRACK_SWITCH, {\n      id,\n      groupId,\n      name,\n      type,\n      url\n    });\n    const hlsUrlParameters = this.switchParams(track.url, lastTrack == null ? void 0 : lastTrack.details, track.details);\n    this.loadPlaylist(hlsUrlParameters);\n  }\n}\n\n/**\n * Generate a random v4 UUID\n *\n * @returns A random v4 UUID\n *\n * @group Utils\n *\n * @beta\n */\nfunction uuid() {\n  try {\n    return crypto.randomUUID();\n  } catch (error) {\n    try {\n      const url = URL.createObjectURL(new Blob());\n      const uuid = url.toString();\n      URL.revokeObjectURL(url);\n      return uuid.slice(uuid.lastIndexOf('/') + 1);\n    } catch (error) {\n      let dt = new Date().getTime();\n      const uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n        const r = (dt + Math.random() * 16) % 16 | 0;\n        dt = Math.floor(dt / 16);\n        return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n      });\n      return uuid;\n    }\n  }\n}\n\n// From https://github.com/darkskyapp/string-hash\nfunction hash(text) {\n  let hash = 5381;\n  let i = text.length;\n  while (i) {\n    hash = hash * 33 ^ text.charCodeAt(--i);\n  }\n  return (hash >>> 0).toString();\n}\n\nconst ALIGNED_END_THRESHOLD_SECONDS = 0.025;\nlet TimelineOccupancy = /*#__PURE__*/function (TimelineOccupancy) {\n  TimelineOccupancy[TimelineOccupancy[\"Point\"] = 0] = \"Point\";\n  TimelineOccupancy[TimelineOccupancy[\"Range\"] = 1] = \"Range\";\n  return TimelineOccupancy;\n}({});\nfunction generateAssetIdentifier(interstitial, uri, assetListIndex) {\n  return `${interstitial.identifier}-${assetListIndex + 1}-${hash(uri)}`;\n}\nclass InterstitialEvent {\n  constructor(dateRange, base) {\n    this.base = void 0;\n    this._duration = null;\n    this._timelineStart = null;\n    this.appendInPlaceDisabled = void 0;\n    this.appendInPlaceStarted = void 0;\n    this.dateRange = void 0;\n    this.hasPlayed = false;\n    this.cumulativeDuration = 0;\n    this.resumeOffset = NaN;\n    this.playoutLimit = NaN;\n    this.restrictions = {\n      skip: false,\n      jump: false\n    };\n    this.snapOptions = {\n      out: false,\n      in: false\n    };\n    this.assetList = [];\n    this.assetListLoader = void 0;\n    this.assetListResponse = null;\n    this.resumeAnchor = void 0;\n    this.error = void 0;\n    this.resetOnResume = void 0;\n    this.base = base;\n    this.dateRange = dateRange;\n    this.setDateRange(dateRange);\n  }\n  setDateRange(dateRange) {\n    this.dateRange = dateRange;\n    this.resumeOffset = dateRange.attr.optionalFloat('X-RESUME-OFFSET', this.resumeOffset);\n    this.playoutLimit = dateRange.attr.optionalFloat('X-PLAYOUT-LIMIT', this.playoutLimit);\n    this.restrictions = dateRange.attr.enumeratedStringList('X-RESTRICT', this.restrictions);\n    this.snapOptions = dateRange.attr.enumeratedStringList('X-SNAP', this.snapOptions);\n  }\n  reset() {\n    var _this$assetListLoader;\n    this.appendInPlaceStarted = false;\n    (_this$assetListLoader = this.assetListLoader) == null ? void 0 : _this$assetListLoader.destroy();\n    this.assetListLoader = undefined;\n    if (!this.supplementsPrimary) {\n      this.assetListResponse = null;\n      this.assetList = [];\n      this._duration = null;\n    }\n    // `error?` is reset when seeking back over interstitial `startOffset`\n    //  using `schedule.resetErrorsInRange(start, end)`.\n  }\n  isAssetPastPlayoutLimit(assetIndex) {\n    var _this$assetList$asset;\n    if (assetIndex > 0 && assetIndex >= this.assetList.length) {\n      return true;\n    }\n    const playoutLimit = this.playoutLimit;\n    if (assetIndex <= 0 || isNaN(playoutLimit)) {\n      return false;\n    }\n    if (playoutLimit === 0) {\n      return true;\n    }\n    const assetOffset = ((_this$assetList$asset = this.assetList[assetIndex]) == null ? void 0 : _this$assetList$asset.startOffset) || 0;\n    return assetOffset > playoutLimit;\n  }\n  findAssetIndex(asset) {\n    const index = this.assetList.indexOf(asset);\n    return index;\n  }\n  get identifier() {\n    return this.dateRange.id;\n  }\n  get startDate() {\n    return this.dateRange.startDate;\n  }\n  get startTime() {\n    // Primary media timeline start time\n    const startTime = this.dateRange.startTime;\n    if (this.snapOptions.out) {\n      const frag = this.dateRange.tagAnchor;\n      if (frag) {\n        return getSnapToFragmentTime(startTime, frag);\n      }\n    }\n    return startTime;\n  }\n  get startOffset() {\n    return this.cue.pre ? 0 : this.startTime;\n  }\n  get startIsAligned() {\n    if (this.startTime === 0 || this.snapOptions.out) {\n      return true;\n    }\n    const frag = this.dateRange.tagAnchor;\n    if (frag) {\n      const startTime = this.dateRange.startTime;\n      const snappedStart = getSnapToFragmentTime(startTime, frag);\n      return startTime - snappedStart < 0.1;\n    }\n    return false;\n  }\n  get resumptionOffset() {\n    const resumeOffset = this.resumeOffset;\n    const offset = isFiniteNumber(resumeOffset) ? resumeOffset : this.duration;\n    return this.cumulativeDuration + offset;\n  }\n  get resumeTime() {\n    // Primary media timeline resumption time\n    const resumeTime = this.startOffset + this.resumptionOffset;\n    if (this.snapOptions.in) {\n      const frag = this.resumeAnchor;\n      if (frag) {\n        return getSnapToFragmentTime(resumeTime, frag);\n      }\n    }\n    return resumeTime;\n  }\n  get appendInPlace() {\n    if (this.appendInPlaceStarted) {\n      return true;\n    }\n    if (this.appendInPlaceDisabled) {\n      return false;\n    }\n    if (!this.cue.once && !this.cue.pre &&\n    // preroll starts at startPosition before startPosition is known (live)\n    this.startIsAligned && (isNaN(this.playoutLimit) && isNaN(this.resumeOffset) || this.resumeOffset && this.duration && Math.abs(this.resumeOffset - this.duration) < ALIGNED_END_THRESHOLD_SECONDS)) {\n      return true;\n    }\n    return false;\n  }\n  set appendInPlace(value) {\n    if (this.appendInPlaceStarted) {\n      this.resetOnResume = !value;\n      return;\n    }\n    this.appendInPlaceDisabled = !value;\n  }\n\n  // Extended timeline start time\n  get timelineStart() {\n    if (this._timelineStart !== null) {\n      return this._timelineStart;\n    }\n    return this.startTime;\n  }\n  set timelineStart(value) {\n    this._timelineStart = value;\n  }\n  get duration() {\n    const playoutLimit = this.playoutLimit;\n    let duration;\n    if (this._duration !== null) {\n      duration = this._duration;\n    } else if (this.dateRange.duration) {\n      duration = this.dateRange.duration;\n    } else {\n      duration = this.dateRange.plannedDuration || 0;\n    }\n    if (!isNaN(playoutLimit) && playoutLimit < duration) {\n      duration = playoutLimit;\n    }\n    return duration;\n  }\n  set duration(value) {\n    this._duration = value;\n  }\n  get cue() {\n    return this.dateRange.cue;\n  }\n  get timelineOccupancy() {\n    if (this.dateRange.attr['X-TIMELINE-OCCUPIES'] === 'RANGE') {\n      return TimelineOccupancy.Range;\n    }\n    return TimelineOccupancy.Point;\n  }\n  get supplementsPrimary() {\n    return this.dateRange.attr['X-TIMELINE-STYLE'] === 'PRIMARY';\n  }\n  get contentMayVary() {\n    return this.dateRange.attr['X-CONTENT-MAY-VARY'] !== 'NO';\n  }\n  get assetUrl() {\n    return this.dateRange.attr['X-ASSET-URI'];\n  }\n  get assetListUrl() {\n    return this.dateRange.attr['X-ASSET-LIST'];\n  }\n  get baseUrl() {\n    return this.base.url;\n  }\n  get assetListLoaded() {\n    return this.assetList.length > 0 || this.assetListResponse !== null;\n  }\n  toString() {\n    return eventToString(this);\n  }\n}\nfunction getSnapToFragmentTime(time, frag) {\n  return time - frag.start < frag.duration / 2 && !(Math.abs(time - (frag.start + frag.duration)) < ALIGNED_END_THRESHOLD_SECONDS) ? frag.start : frag.start + frag.duration;\n}\nfunction getInterstitialUrl(uri, sessionId, baseUrl) {\n  const url = new self.URL(uri, baseUrl);\n  if (url.protocol !== 'data:') {\n    url.searchParams.set('_HLS_primary_id', sessionId);\n  }\n  return url;\n}\nfunction getNextAssetIndex(interstitial, assetListIndex) {\n  while ((_interstitial$assetLi = interstitial.assetList[++assetListIndex]) != null && _interstitial$assetLi.error) {\n    var _interstitial$assetLi;\n  } /* no-op */\n  return assetListIndex;\n}\nfunction eventToString(interstitial) {\n  return `[\"${interstitial.identifier}\" ${interstitial.cue.pre ? '<pre>' : interstitial.cue.post ? '<post>' : ''}${interstitial.timelineStart.toFixed(2)}-${interstitial.resumeTime.toFixed(2)}]`;\n}\nfunction eventAssetToString(asset) {\n  const start = asset.timelineStart;\n  const duration = asset.duration || 0;\n  return `[\"${asset.identifier}\" ${start.toFixed(2)}-${(start + duration).toFixed(2)}]`;\n}\n\nclass HlsAssetPlayer {\n  constructor(HlsPlayerClass, userConfig, interstitial, assetItem) {\n    this.hls = void 0;\n    this.interstitial = void 0;\n    this.assetItem = void 0;\n    this.tracks = null;\n    this.hasDetails = false;\n    this.mediaAttached = null;\n    this._currentTime = void 0;\n    this._bufferedEosTime = void 0;\n    this.checkPlayout = () => {\n      if (this.reachedPlayout(this.currentTime)) {\n        this.hls.trigger(Events.PLAYOUT_LIMIT_REACHED, {});\n      }\n    };\n    const hls = this.hls = new HlsPlayerClass(userConfig);\n    this.interstitial = interstitial;\n    this.assetItem = assetItem;\n    let uri = assetItem.uri;\n    try {\n      uri = getInterstitialUrl(uri, userConfig.primarySessionId).href;\n    } catch (error) {\n      // Ignore error parsing ASSET_URI or adding _HLS_primary_id to it. The\n      // issue should surface as an INTERSTITIAL_ASSET_ERROR loading the asset.\n    }\n    hls.loadSource(uri);\n    const detailsLoaded = () => {\n      this.hasDetails = true;\n    };\n    hls.once(Events.LEVEL_LOADED, detailsLoaded);\n    hls.once(Events.AUDIO_TRACK_LOADED, detailsLoaded);\n    hls.once(Events.SUBTITLE_TRACK_LOADED, detailsLoaded);\n    hls.on(Events.MEDIA_ATTACHING, (name, {\n      media\n    }) => {\n      this.removeMediaListeners();\n      this.mediaAttached = media;\n      const event = this.interstitial;\n      if (event.playoutLimit) {\n        media.addEventListener('timeupdate', this.checkPlayout);\n        if (this.appendInPlace) {\n          hls.on(Events.BUFFER_APPENDED, () => {\n            const bufferedEnd = this.bufferedEnd;\n            if (this.reachedPlayout(bufferedEnd)) {\n              this._bufferedEosTime = bufferedEnd;\n              hls.trigger(Events.BUFFERED_TO_END, undefined);\n            }\n          });\n        }\n      }\n    });\n  }\n  get appendInPlace() {\n    var _this$interstitial;\n    return ((_this$interstitial = this.interstitial) == null ? void 0 : _this$interstitial.appendInPlace) || false;\n  }\n  bufferedInPlaceToEnd(media) {\n    var _this$hls;\n    if (!this.appendInPlace) {\n      return false;\n    }\n    if ((_this$hls = this.hls) != null && _this$hls.bufferedToEnd) {\n      return true;\n    }\n    if (!media || !this._bufferedEosTime) {\n      return false;\n    }\n    const start = this.timelineOffset;\n    const bufferInfo = BufferHelper.bufferInfo(media, start, 0);\n    const bufferedEnd = this.getAssetTime(bufferInfo.end);\n    return bufferedEnd >= this._bufferedEosTime - 0.02;\n  }\n  reachedPlayout(time) {\n    const interstitial = this.interstitial;\n    const playoutLimit = interstitial.playoutLimit;\n    return this.startOffset + time >= playoutLimit;\n  }\n  get destroyed() {\n    var _this$hls2;\n    return !((_this$hls2 = this.hls) != null && _this$hls2.userConfig);\n  }\n  get assetId() {\n    return this.assetItem.identifier;\n  }\n  get interstitialId() {\n    return this.assetItem.parentIdentifier;\n  }\n  get media() {\n    var _this$hls3;\n    return ((_this$hls3 = this.hls) == null ? void 0 : _this$hls3.media) || null;\n  }\n  get bufferedEnd() {\n    const media = this.media || this.mediaAttached;\n    if (!media) {\n      if (this._bufferedEosTime) {\n        return this._bufferedEosTime;\n      }\n      return this.currentTime;\n    }\n    const bufferInfo = BufferHelper.bufferInfo(media, media.currentTime, 0.001);\n    return this.getAssetTime(bufferInfo.end);\n  }\n  get currentTime() {\n    const media = this.media || this.mediaAttached;\n    if (!media) {\n      return this._currentTime || 0;\n    }\n    return this.getAssetTime(media.currentTime);\n  }\n  get duration() {\n    const duration = this.assetItem.duration;\n    if (!duration) {\n      return 0;\n    }\n    return duration;\n  }\n  get remaining() {\n    const duration = this.duration;\n    if (!duration) {\n      return 0;\n    }\n    return Math.max(0, duration - this.currentTime);\n  }\n  get startOffset() {\n    return this.assetItem.startOffset;\n  }\n  get timelineOffset() {\n    var _this$hls4;\n    return ((_this$hls4 = this.hls) == null ? void 0 : _this$hls4.config.timelineOffset) || 0;\n  }\n  set timelineOffset(value) {\n    const timelineOffset = this.timelineOffset;\n    if (value !== timelineOffset) {\n      const diff = value - timelineOffset;\n      if (Math.abs(diff) > 1 / 90000) {\n        if (this.hasDetails) {\n          throw new Error(`Cannot set timelineOffset after playlists are loaded`);\n        }\n        this.hls.config.timelineOffset = value;\n      }\n    }\n  }\n  getAssetTime(time) {\n    const timelineOffset = this.timelineOffset;\n    const duration = this.duration;\n    return Math.min(Math.max(0, time - timelineOffset), duration);\n  }\n  removeMediaListeners() {\n    const media = this.mediaAttached;\n    if (media) {\n      this._currentTime = media.currentTime;\n      this.bufferSnapShot();\n      media.removeEventListener('timeupdate', this.checkPlayout);\n    }\n  }\n  bufferSnapShot() {\n    if (this.mediaAttached) {\n      var _this$hls5;\n      if ((_this$hls5 = this.hls) != null && _this$hls5.bufferedToEnd) {\n        this._bufferedEosTime = this.bufferedEnd;\n      }\n    }\n  }\n  destroy() {\n    this.removeMediaListeners();\n    this.hls.destroy();\n    // @ts-ignore\n    this.hls = this.interstitial = null;\n    // @ts-ignore\n    this.tracks = this.mediaAttached = this.checkPlayout = null;\n  }\n  attachMedia(data) {\n    this.hls.attachMedia(data);\n  }\n  detachMedia() {\n    this.removeMediaListeners();\n    this.mediaAttached = null;\n    this.hls.detachMedia();\n  }\n  resumeBuffering() {\n    this.hls.resumeBuffering();\n  }\n  pauseBuffering() {\n    this.hls.pauseBuffering();\n  }\n  transferMedia() {\n    this.bufferSnapShot();\n    return this.hls.transferMedia();\n  }\n  resetDetails() {\n    const hls = this.hls;\n    if (this.hasDetails) {\n      hls.stopLoad();\n      const deleteDetails = obj => delete obj.details;\n      hls.levels.forEach(deleteDetails);\n      hls.allAudioTracks.forEach(deleteDetails);\n      hls.allSubtitleTracks.forEach(deleteDetails);\n      this.hasDetails = false;\n    }\n  }\n  on(event, listener, context) {\n    this.hls.on(event, listener);\n  }\n  once(event, listener, context) {\n    this.hls.once(event, listener);\n  }\n  off(event, listener, context) {\n    this.hls.off(event, listener);\n  }\n  toString() {\n    var _this$hls6;\n    return `HlsAssetPlayer: ${eventAssetToString(this.assetItem)} ${(_this$hls6 = this.hls) == null ? void 0 : _this$hls6.sessionId} ${this.appendInPlace ? 'append-in-place' : ''}`;\n  }\n}\n\nconst ABUTTING_THRESHOLD_SECONDS = 0.033;\nclass InterstitialsSchedule extends Logger {\n  constructor(onScheduleUpdate, logger) {\n    super('interstitials-sched', logger);\n    this.onScheduleUpdate = void 0;\n    this.eventMap = {};\n    this.events = null;\n    this.items = null;\n    this.durations = {\n      primary: 0,\n      playout: 0,\n      integrated: 0\n    };\n    this.onScheduleUpdate = onScheduleUpdate;\n  }\n  destroy() {\n    this.reset();\n    // @ts-ignore\n    this.onScheduleUpdate = null;\n  }\n  reset() {\n    this.eventMap = {};\n    this.setDurations(0, 0, 0);\n    if (this.events) {\n      this.events.forEach(interstitial => interstitial.reset());\n    }\n    this.events = this.items = null;\n  }\n  resetErrorsInRange(start, end) {\n    if (this.events) {\n      return this.events.reduce((count, interstitial) => {\n        if (start <= interstitial.startOffset && end > interstitial.startOffset) {\n          delete interstitial.error;\n          return count + 1;\n        }\n        return count;\n      }, 0);\n    }\n    return 0;\n  }\n  get duration() {\n    const items = this.items;\n    return items ? items[items.length - 1].end : 0;\n  }\n  get length() {\n    return this.items ? this.items.length : 0;\n  }\n  getEvent(identifier) {\n    return identifier ? this.eventMap[identifier] || null : null;\n  }\n  hasEvent(identifier) {\n    return identifier in this.eventMap;\n  }\n  findItemIndex(item, time) {\n    if (item.event) {\n      // Find Event Item\n      return this.findEventIndex(item.event.identifier);\n    }\n    // Find Primary Item\n    let index = -1;\n    if (item.nextEvent) {\n      index = this.findEventIndex(item.nextEvent.identifier) - 1;\n    } else if (item.previousEvent) {\n      index = this.findEventIndex(item.previousEvent.identifier) + 1;\n    }\n    const items = this.items;\n    if (items) {\n      if (!items[index]) {\n        if (time === undefined) {\n          time = item.start;\n        }\n        index = this.findItemIndexAtTime(time);\n      }\n      // Only return index of a Primary Item\n      while (index >= 0 && (_items$index = items[index]) != null && _items$index.event) {\n        var _items$index;\n        // If index found is an interstitial it is not a valid result as it should have been matched up top\n        // decrement until result is negative (not found) or a primary segment\n        index--;\n      }\n    }\n    return index;\n  }\n  findItemIndexAtTime(timelinePos, timelineType) {\n    const items = this.items;\n    if (items) {\n      for (let i = 0; i < items.length; i++) {\n        let timeRange = items[i];\n        if (timelineType && timelineType !== 'primary') {\n          timeRange = timeRange[timelineType];\n        }\n        if (timelinePos === timeRange.start || timelinePos > timeRange.start && timelinePos < timeRange.end) {\n          return i;\n        }\n      }\n    }\n    return -1;\n  }\n  findJumpRestrictedIndex(startIndex, endIndex) {\n    const items = this.items;\n    if (items) {\n      for (let i = startIndex; i <= endIndex; i++) {\n        if (!items[i]) {\n          break;\n        }\n        const event = items[i].event;\n        if (event != null && event.restrictions.jump && !event.appendInPlace) {\n          return i;\n        }\n      }\n    }\n    return -1;\n  }\n  findEventIndex(identifier) {\n    const items = this.items;\n    if (items) {\n      for (let i = items.length; i--;) {\n        var _items$i$event;\n        if (((_items$i$event = items[i].event) == null ? void 0 : _items$i$event.identifier) === identifier) {\n          return i;\n        }\n      }\n    }\n    return -1;\n  }\n  findAssetIndex(event, timelinePos) {\n    const assetList = event.assetList;\n    const length = assetList.length;\n    if (length > 1) {\n      for (let i = 0; i < length; i++) {\n        const asset = assetList[i];\n        if (!asset.error) {\n          const timelineStart = asset.timelineStart;\n          if (timelinePos === timelineStart || timelinePos > timelineStart && timelinePos < timelineStart + (asset.duration || 0)) {\n            return i;\n          }\n        }\n      }\n    }\n    return 0;\n  }\n  get assetIdAtEnd() {\n    var _this$items, _this$items2;\n    const interstitialAtEnd = (_this$items = this.items) == null ? void 0 : (_this$items2 = _this$items[this.length - 1]) == null ? void 0 : _this$items2.event;\n    if (interstitialAtEnd) {\n      const assetList = interstitialAtEnd.assetList;\n      const assetAtEnd = assetList[assetList.length - 1];\n      if (assetAtEnd) {\n        return assetAtEnd.identifier;\n      }\n    }\n    return null;\n  }\n  parseInterstitialDateRanges(mediaSelection, enableAppendInPlace) {\n    const details = mediaSelection.main.details;\n    const {\n      dateRanges\n    } = details;\n    const previousInterstitialEvents = this.events;\n    const interstitialEvents = this.parseDateRanges(dateRanges, {\n      url: details.url\n    }, enableAppendInPlace);\n    const ids = Object.keys(dateRanges);\n    const removedInterstitials = previousInterstitialEvents ? previousInterstitialEvents.filter(event => !ids.includes(event.identifier)) : [];\n    if (interstitialEvents.length) {\n      // pre-rolls, post-rolls, and events with the same start time are played in playlist tag order\n      // all other events are ordered by start time\n      interstitialEvents.sort((a, b) => {\n        const aPre = a.cue.pre;\n        const aPost = a.cue.post;\n        const bPre = b.cue.pre;\n        const bPost = b.cue.post;\n        if (aPre && !bPre) {\n          return -1;\n        }\n        if (bPre && !aPre) {\n          return 1;\n        }\n        if (aPost && !bPost) {\n          return 1;\n        }\n        if (bPost && !aPost) {\n          return -1;\n        }\n        if (!aPre && !bPre && !aPost && !bPost) {\n          const startA = a.startTime;\n          const startB = b.startTime;\n          if (startA !== startB) {\n            return startA - startB;\n          }\n        }\n        return a.dateRange.tagOrder - b.dateRange.tagOrder;\n      });\n    }\n    this.events = interstitialEvents;\n\n    // Clear removed DateRanges from buffered list (kills playback of active Interstitials)\n    removedInterstitials.forEach(interstitial => {\n      this.removeEvent(interstitial);\n    });\n    this.updateSchedule(mediaSelection, removedInterstitials);\n  }\n  updateSchedule(mediaSelection, removedInterstitials = []) {\n    const events = this.events || [];\n    if (events.length || removedInterstitials.length || this.length < 2) {\n      const currentItems = this.items;\n      const updatedItems = this.parseSchedule(events, mediaSelection);\n      const updated = removedInterstitials.length || (currentItems == null ? void 0 : currentItems.length) !== updatedItems.length || updatedItems.some((item, i) => {\n        return Math.abs(item.playout.start - currentItems[i].playout.start) > 0.005 || Math.abs(item.playout.end - currentItems[i].playout.end) > 0.005;\n      });\n      if (updated) {\n        this.items = updatedItems;\n        // call interstitials-controller onScheduleUpdated()\n        this.onScheduleUpdate(removedInterstitials, currentItems);\n      }\n    }\n  }\n  parseDateRanges(dateRanges, baseData, enableAppendInPlace) {\n    const interstitialEvents = [];\n    const ids = Object.keys(dateRanges);\n    for (let i = 0; i < ids.length; i++) {\n      const id = ids[i];\n      const dateRange = dateRanges[id];\n      if (dateRange.isInterstitial) {\n        let interstitial = this.eventMap[id];\n        if (interstitial) {\n          // Update InterstitialEvent already parsed and mapped\n          // This retains already loaded duration and loaded asset list info\n          interstitial.setDateRange(dateRange);\n        } else {\n          interstitial = new InterstitialEvent(dateRange, baseData);\n          this.eventMap[id] = interstitial;\n          if (enableAppendInPlace === false) {\n            interstitial.appendInPlace = enableAppendInPlace;\n          }\n        }\n        interstitialEvents.push(interstitial);\n      }\n    }\n    return interstitialEvents;\n  }\n  parseSchedule(interstitialEvents, mediaSelection) {\n    const schedule = [];\n    const details = mediaSelection.main.details;\n    const primaryDuration = details.live ? Infinity : details.edge;\n    let playoutDuration = 0;\n\n    // Filter events that have errored from the schedule (Primary fallback)\n    interstitialEvents = interstitialEvents.filter(event => !event.error && !(event.cue.once && event.hasPlayed));\n    if (interstitialEvents.length) {\n      // Update Schedule\n      this.resolveOffsets(interstitialEvents, mediaSelection);\n\n      // Populate Schedule with Interstitial Event and Primary Segment Items\n      let primaryPosition = 0;\n      let integratedTime = 0;\n      interstitialEvents.forEach((interstitial, i) => {\n        const preroll = interstitial.cue.pre;\n        const postroll = interstitial.cue.post;\n        const previousEvent = interstitialEvents[i - 1] || null;\n        const appendInPlace = interstitial.appendInPlace;\n        const eventStart = postroll ? primaryDuration : interstitial.startOffset;\n        const interstitialDuration = interstitial.duration;\n        const timelineDuration = interstitial.timelineOccupancy === TimelineOccupancy.Range ? interstitialDuration : 0;\n        const resumptionOffset = interstitial.resumptionOffset;\n        const inSameStartTimeSequence = (previousEvent == null ? void 0 : previousEvent.startTime) === eventStart;\n        const start = eventStart + interstitial.cumulativeDuration;\n        let end = appendInPlace ? start + interstitialDuration : eventStart + resumptionOffset;\n        if (preroll || !postroll && eventStart <= 0) {\n          // preroll or in-progress midroll\n          const integratedStart = integratedTime;\n          integratedTime += timelineDuration;\n          interstitial.timelineStart = start;\n          const playoutStart = playoutDuration;\n          playoutDuration += interstitialDuration;\n          schedule.push({\n            event: interstitial,\n            start,\n            end,\n            playout: {\n              start: playoutStart,\n              end: playoutDuration\n            },\n            integrated: {\n              start: integratedStart,\n              end: integratedTime\n            }\n          });\n        } else if (eventStart <= primaryDuration) {\n          if (!inSameStartTimeSequence) {\n            const segmentDuration = eventStart - primaryPosition;\n            // Do not schedule a primary segment if interstitials are abutting by less than ABUTTING_THRESHOLD_SECONDS\n            if (segmentDuration > ABUTTING_THRESHOLD_SECONDS) {\n              // primary segment\n              const timelineStart = primaryPosition;\n              const _integratedStart = integratedTime;\n              integratedTime += segmentDuration;\n              const _playoutStart = playoutDuration;\n              playoutDuration += segmentDuration;\n              const primarySegment = {\n                previousEvent: interstitialEvents[i - 1] || null,\n                nextEvent: interstitial,\n                start: timelineStart,\n                end: timelineStart + segmentDuration,\n                playout: {\n                  start: _playoutStart,\n                  end: playoutDuration\n                },\n                integrated: {\n                  start: _integratedStart,\n                  end: integratedTime\n                }\n              };\n              schedule.push(primarySegment);\n            } else if (segmentDuration > 0 && previousEvent) {\n              // Add previous event `resumeTime` (based on duration or resumeOffset) so that it ends aligned with this one\n              previousEvent.cumulativeDuration += segmentDuration;\n              schedule[schedule.length - 1].end = eventStart;\n            }\n          }\n          // midroll / postroll\n          if (postroll) {\n            end = start;\n          }\n          interstitial.timelineStart = start;\n          const integratedStart = integratedTime;\n          integratedTime += timelineDuration;\n          const playoutStart = playoutDuration;\n          playoutDuration += interstitialDuration;\n          schedule.push({\n            event: interstitial,\n            start,\n            end,\n            playout: {\n              start: playoutStart,\n              end: playoutDuration\n            },\n            integrated: {\n              start: integratedStart,\n              end: integratedTime\n            }\n          });\n        } else {\n          // Interstitial starts after end of primary VOD - not included in schedule\n          return;\n        }\n        const resumeTime = interstitial.resumeTime;\n        if (postroll || resumeTime > primaryDuration) {\n          primaryPosition = primaryDuration;\n        } else {\n          primaryPosition = resumeTime;\n        }\n      });\n      if (primaryPosition < primaryDuration) {\n        var _schedule;\n        // last primary segment\n        const timelineStart = primaryPosition;\n        const integratedStart = integratedTime;\n        const segmentDuration = primaryDuration - primaryPosition;\n        integratedTime += segmentDuration;\n        const playoutStart = playoutDuration;\n        playoutDuration += segmentDuration;\n        schedule.push({\n          previousEvent: ((_schedule = schedule[schedule.length - 1]) == null ? void 0 : _schedule.event) || null,\n          nextEvent: null,\n          start: primaryPosition,\n          end: timelineStart + segmentDuration,\n          playout: {\n            start: playoutStart,\n            end: playoutDuration\n          },\n          integrated: {\n            start: integratedStart,\n            end: integratedTime\n          }\n        });\n      }\n      this.setDurations(primaryDuration, playoutDuration, integratedTime);\n    } else {\n      // no interstials - schedule is one primary segment\n      const start = 0;\n      schedule.push({\n        previousEvent: null,\n        nextEvent: null,\n        start,\n        end: primaryDuration,\n        playout: {\n          start,\n          end: primaryDuration\n        },\n        integrated: {\n          start,\n          end: primaryDuration\n        }\n      });\n      this.setDurations(primaryDuration, primaryDuration, primaryDuration);\n    }\n    return schedule;\n  }\n  setDurations(primary, playout, integrated) {\n    this.durations = {\n      primary,\n      playout,\n      integrated\n    };\n  }\n  resolveOffsets(interstitialEvents, mediaSelection) {\n    const details = mediaSelection.main.details;\n    const primaryDuration = details.live ? Infinity : details.edge;\n\n    // First resolve cumulative resumption offsets for Interstitials that start at the same DateTime\n    let cumulativeDuration = 0;\n    let lastScheduledStart = -1;\n    interstitialEvents.forEach((interstitial, i) => {\n      const preroll = interstitial.cue.pre;\n      const postroll = interstitial.cue.post;\n      const eventStart = preroll ? 0 : postroll ? primaryDuration : interstitial.startTime;\n      this.updateAssetDurations(interstitial);\n\n      // X-RESUME-OFFSET values of interstitials scheduled at the same time are cumulative\n      const inSameStartTimeSequence = lastScheduledStart === eventStart;\n      if (inSameStartTimeSequence) {\n        interstitial.cumulativeDuration = cumulativeDuration;\n      } else {\n        cumulativeDuration = 0;\n        lastScheduledStart = eventStart;\n      }\n      if (!postroll && interstitial.snapOptions.in) {\n        // FIXME: Include audio playlist in snapping\n        interstitial.resumeAnchor = findFragmentByPTS(null, details.fragments, interstitial.startOffset + interstitial.resumptionOffset, 0, 0) || undefined;\n      }\n      // Check if primary fragments align with resumption offset and disable appendInPlace if they do not\n      if (interstitial.appendInPlace && !interstitial.appendInPlaceStarted) {\n        const alignedSegmentStart = this.primaryCanResumeInPlaceAt(interstitial, mediaSelection);\n        if (!alignedSegmentStart) {\n          interstitial.appendInPlace = false;\n        }\n      }\n      if (!interstitial.appendInPlace && i + 1 < interstitialEvents.length) {\n        // abutting Interstitials must use the same MediaSource strategy, this applies to all whether or not they are back to back:\n        const timeBetween = interstitialEvents[i + 1].startTime - interstitialEvents[i].resumeTime;\n        if (timeBetween < ABUTTING_THRESHOLD_SECONDS) {\n          interstitialEvents[i + 1].appendInPlace = false;\n          if (interstitialEvents[i + 1].appendInPlace) {\n            this.warn(`Could not change append strategy for abutting event ${interstitial}`);\n          }\n        }\n      }\n      // Update cumulativeDuration for next abutting interstitial with the same start date\n      const resumeOffset = isFiniteNumber(interstitial.resumeOffset) ? interstitial.resumeOffset : interstitial.duration;\n      cumulativeDuration += resumeOffset;\n    });\n  }\n  primaryCanResumeInPlaceAt(interstitial, mediaSelection) {\n    const resumeTime = interstitial.resumeTime;\n    const resumesInPlaceAt = interstitial.startTime + interstitial.resumptionOffset;\n    if (Math.abs(resumeTime - resumesInPlaceAt) > ALIGNED_END_THRESHOLD_SECONDS) {\n      this.log(`\"${interstitial.identifier}\" resumption ${resumeTime} not aligned with estimated timeline end ${resumesInPlaceAt}`);\n      return false;\n    }\n    if (!mediaSelection) {\n      this.log(`\"${interstitial.identifier}\" resumption ${resumeTime} can not be aligned with media (none selected)`);\n      return false;\n    }\n    const playlists = Object.keys(mediaSelection);\n    return !playlists.some(playlistType => {\n      const details = mediaSelection[playlistType].details;\n      const playlistEnd = details.edge;\n      if (resumeTime >= playlistEnd) {\n        // Live playback - resumption segments are not yet available\n        this.log(`\"${interstitial.identifier}\" resumption ${resumeTime} past ${playlistType} playlist end ${playlistEnd}`);\n        // Assume alignment is possible (or reset can take place)\n        return false;\n      }\n      const startFragment = findFragmentByPTS(null, details.fragments, resumeTime);\n      if (!startFragment) {\n        this.log(`\"${interstitial.identifier}\" resumption ${resumeTime} does not align with any fragments in ${playlistType} playlist (${details.fragStart}-${details.fragmentEnd})`);\n        return true;\n      }\n      const allowance = playlistType === 'audio' ? 0.175 : 0;\n      const alignedWithSegment = Math.abs(startFragment.start - resumeTime) < ALIGNED_END_THRESHOLD_SECONDS + allowance || Math.abs(startFragment.end - resumeTime) < ALIGNED_END_THRESHOLD_SECONDS + allowance;\n      if (!alignedWithSegment) {\n        this.log(`\"${interstitial.identifier}\" resumption ${resumeTime} not aligned with ${playlistType} fragment bounds (${startFragment.start}-${startFragment.end} sn: ${startFragment.sn} cc: ${startFragment.cc})`);\n        return true;\n      }\n      return false;\n    });\n  }\n  updateAssetDurations(interstitial) {\n    if (!interstitial.assetListLoaded) {\n      return;\n    }\n    const eventStart = interstitial.timelineStart;\n    let sumDuration = 0;\n    let hasUnknownDuration = false;\n    let hasErrors = false;\n    interstitial.assetList.forEach((asset, i) => {\n      const timelineStart = eventStart + sumDuration;\n      asset.startOffset = sumDuration;\n      asset.timelineStart = timelineStart;\n      hasUnknownDuration || (hasUnknownDuration = asset.duration === null);\n      hasErrors || (hasErrors = !!asset.error);\n      const duration = asset.error ? 0 : asset.duration || 0;\n      sumDuration += duration;\n    });\n    // Use the sum of known durations when it is greater than the stated duration\n    if (hasUnknownDuration && !hasErrors) {\n      interstitial.duration = Math.max(sumDuration, interstitial.duration);\n    } else {\n      interstitial.duration = sumDuration;\n    }\n  }\n  removeEvent(interstitial) {\n    interstitial.reset();\n    delete this.eventMap[interstitial.identifier];\n  }\n}\nfunction segmentToString(segment) {\n  return `[${segment.event ? '\"' + segment.event.identifier + '\"' : 'primary'}: ${segment.start.toFixed(2)}-${segment.end.toFixed(2)}]`;\n}\n\nclass AssetListLoader {\n  constructor(hls) {\n    this.hls = void 0;\n    this.hls = hls;\n  }\n  destroy() {\n    // @ts-ignore\n    this.hls = null;\n  }\n  loadAssetList(interstitial, hlsStartOffset) {\n    const assetListUrl = interstitial.assetListUrl;\n    let url;\n    try {\n      url = getInterstitialUrl(assetListUrl, this.hls.sessionId, interstitial.baseUrl);\n    } catch (error) {\n      const errorData = this.assignAssetListError(interstitial, ErrorDetails.ASSET_LIST_LOAD_ERROR, error, assetListUrl);\n      this.hls.trigger(Events.ERROR, errorData);\n      return;\n    }\n    if (hlsStartOffset && url.protocol !== 'data:') {\n      url.searchParams.set('_HLS_start_offset', '' + hlsStartOffset);\n    }\n    const config = this.hls.config;\n    const Loader = config.loader;\n    const loader = new Loader(config);\n    const context = {\n      responseType: 'json',\n      url: url.href\n    };\n    const loadPolicy = config.interstitialAssetListLoadPolicy.default;\n    const loaderConfig = {\n      loadPolicy,\n      timeout: loadPolicy.maxLoadTimeMs,\n      maxRetry: 0,\n      retryDelay: 0,\n      maxRetryDelay: 0\n    };\n    const callbacks = {\n      onSuccess: (response, stats, context, networkDetails) => {\n        const assetListResponse = response.data;\n        const assets = assetListResponse == null ? void 0 : assetListResponse.ASSETS;\n        if (!Array.isArray(assets)) {\n          const errorData = this.assignAssetListError(interstitial, ErrorDetails.ASSET_LIST_PARSING_ERROR, new Error(`Invalid interstitial asset list`), context.url, stats, networkDetails);\n          this.hls.trigger(Events.ERROR, errorData);\n          return;\n        }\n        interstitial.assetListResponse = assetListResponse;\n        this.hls.trigger(Events.ASSET_LIST_LOADED, {\n          event: interstitial,\n          assetListResponse,\n          networkDetails\n        });\n      },\n      onError: (error, context, networkDetails, stats) => {\n        const errorData = this.assignAssetListError(interstitial, ErrorDetails.ASSET_LIST_LOAD_ERROR, new Error(`Error loading X-ASSET-LIST: HTTP status ${error.code} ${error.text} (${context.url})`), context.url, stats, networkDetails);\n        this.hls.trigger(Events.ERROR, errorData);\n      },\n      onTimeout: (stats, context, networkDetails) => {\n        const errorData = this.assignAssetListError(interstitial, ErrorDetails.ASSET_LIST_LOAD_TIMEOUT, new Error(`Timeout loading X-ASSET-LIST (${context.url})`), context.url, stats, networkDetails);\n        this.hls.trigger(Events.ERROR, errorData);\n      }\n    };\n    loader.load(context, loaderConfig, callbacks);\n    this.hls.trigger(Events.ASSET_LIST_LOADING, {\n      event: interstitial\n    });\n    return loader;\n  }\n  assignAssetListError(interstitial, details, error, url, stats, networkDetails) {\n    interstitial.error = error;\n    return {\n      type: ErrorTypes.NETWORK_ERROR,\n      details,\n      fatal: false,\n      interstitial,\n      url,\n      error,\n      networkDetails,\n      stats\n    };\n  }\n}\n\nfunction playWithCatch(media) {\n  media == null ? void 0 : media.play().catch(() => {\n    /* no-op */\n  });\n}\nclass InterstitialsController extends Logger {\n  constructor(hls, HlsPlayerClass) {\n    super('interstitials', hls.logger);\n    this.HlsPlayerClass = void 0;\n    this.hls = void 0;\n    this.assetListLoader = void 0;\n    // Last updated LevelDetails\n    this.mediaSelection = null;\n    this.altSelection = null;\n    // Media and MediaSource/SourceBuffers\n    this.media = null;\n    this.detachedData = null;\n    this.requiredTracks = null;\n    // Public Interface for Interstitial playback state and control\n    this.manager = null;\n    // Interstitial Asset Players\n    this.playerQueue = [];\n    // Timeline position tracking\n    this.bufferedPos = -1;\n    this.timelinePos = -1;\n    // Schedule\n    this.schedule = void 0;\n    // Schedule playback and buffering state\n    this.playingItem = null;\n    this.bufferingItem = null;\n    this.waitingItem = null;\n    this.endedItem = null;\n    this.playingAsset = null;\n    this.endedAsset = null;\n    this.bufferingAsset = null;\n    this.shouldPlay = false;\n    this.onPlay = () => {\n      this.shouldPlay = true;\n    };\n    this.onPause = () => {\n      this.shouldPlay = false;\n    };\n    this.onSeeking = () => {\n      const currentTime = this.currentTime;\n      if (currentTime === undefined || this.playbackDisabled) {\n        return;\n      }\n      const diff = currentTime - this.timelinePos;\n      const roundingError = Math.abs(diff) < 1 / 705600000; // one flick\n      if (roundingError) {\n        return;\n      }\n      const backwardSeek = diff <= -0.01;\n      this.timelinePos = currentTime;\n      this.bufferedPos = currentTime;\n\n      // Check if seeking out of an item\n      const playingItem = this.playingItem;\n      if (!playingItem) {\n        this.checkBuffer();\n        return;\n      }\n      if (backwardSeek) {\n        const resetCount = this.schedule.resetErrorsInRange(currentTime, currentTime - diff);\n        if (resetCount) {\n          this.updateSchedule();\n        }\n      }\n      this.checkBuffer();\n      if (backwardSeek && currentTime < playingItem.start || currentTime >= playingItem.end) {\n        var _this$media;\n        const scheduleIndex = this.schedule.findItemIndexAtTime(this.timelinePos);\n        if (!this.isInterstitial(playingItem) && (_this$media = this.media) != null && _this$media.paused) {\n          this.shouldPlay = false;\n        }\n        if (!backwardSeek) {\n          // check if an Interstitial between the current item and target item has an X-RESTRICT JUMP restriction\n          const playingIndex = this.findItemIndex(playingItem);\n          if (scheduleIndex > playingIndex) {\n            const jumpIndex = this.schedule.findJumpRestrictedIndex(playingIndex + 1, scheduleIndex);\n            if (jumpIndex > playingIndex) {\n              this.setSchedulePosition(jumpIndex);\n              return;\n            }\n          }\n        }\n        this.setSchedulePosition(scheduleIndex);\n        return;\n      }\n      // Check if seeking out of an asset (assumes same item following above check)\n      const playingAsset = this.playingAsset;\n      if (!playingAsset) {\n        // restart Interstitial at end\n        if (this.playingLastItem && this.isInterstitial(playingItem)) {\n          const restartAsset = playingItem.event.assetList[0];\n          if (restartAsset) {\n            this.endedItem = this.playingItem;\n            this.playingItem = null;\n            this.setScheduleToAssetAtTime(currentTime, restartAsset);\n          }\n        }\n        return;\n      }\n      const start = playingAsset.timelineStart;\n      const duration = playingAsset.duration || 0;\n      if (backwardSeek && currentTime < start || currentTime >= start + duration) {\n        this.setScheduleToAssetAtTime(currentTime, playingAsset);\n      }\n    };\n    this.onTimeupdate = () => {\n      const currentTime = this.currentTime;\n      if (currentTime === undefined || this.playbackDisabled) {\n        return;\n      }\n\n      // Only allow timeupdate to advance primary position, seeking is used for jumping back\n      // this prevents primaryPos from being reset to 0 after re-attach\n      if (currentTime > this.timelinePos) {\n        this.timelinePos = currentTime;\n        if (currentTime > this.bufferedPos) {\n          this.checkBuffer();\n        }\n      } else {\n        return;\n      }\n\n      // Check if playback has entered the next item\n      const playingItem = this.playingItem;\n      if (!playingItem || this.playingLastItem) {\n        return;\n      }\n      if (currentTime >= playingItem.end) {\n        this.timelinePos = playingItem.end;\n        const playingIndex = this.findItemIndex(playingItem);\n        this.setSchedulePosition(playingIndex + 1);\n      }\n      // Check if playback has entered the next asset\n      const playingAsset = this.playingAsset;\n      if (!playingAsset) {\n        return;\n      }\n      const end = playingAsset.timelineStart + (playingAsset.duration || 0);\n      if (currentTime >= end) {\n        this.setScheduleToAssetAtTime(currentTime, playingAsset);\n      }\n    };\n    // Schedule update callback\n    this.onScheduleUpdate = (removedInterstitials, previousItems) => {\n      const schedule = this.schedule;\n      const playingItem = this.playingItem;\n      const interstitialEvents = schedule.events || [];\n      const scheduleItems = schedule.items || [];\n      const durations = schedule.durations;\n      const removedIds = removedInterstitials.map(interstitial => interstitial.identifier);\n      const interstitialsUpdated = !!(interstitialEvents.length || removedIds.length);\n      if (interstitialsUpdated || previousItems) {\n        this.log(`INTERSTITIALS_UPDATED (${interstitialEvents.length}): ${interstitialEvents}\nSchedule: ${scheduleItems.map(seg => segmentToString(seg))} pos: ${this.timelinePos}`);\n      }\n      if (removedIds.length) {\n        this.log(`Removed events ${removedIds}`);\n      }\n      this.playerQueue.forEach(player => {\n        if (player.interstitial.appendInPlace) {\n          const timelineStart = player.assetItem.timelineStart;\n          const diff = player.timelineOffset - timelineStart;\n          if (diff) {\n            try {\n              player.timelineOffset = timelineStart;\n            } catch (e) {\n              if (Math.abs(diff) > ALIGNED_END_THRESHOLD_SECONDS) {\n                this.warn(`${e} (\"${player.assetId}\" ${player.timelineOffset}->${timelineStart})`);\n              }\n            }\n          }\n        }\n      });\n\n      // Update schedule item references\n      // Do not replace Interstitial playingItem without a match - used for INTERSTITIAL_ASSET_ENDED and INTERSTITIAL_ENDED\n      let trimInPlaceForPlayout = null;\n      if (playingItem) {\n        const updatedPlayingItem = this.updateItem(playingItem, this.timelinePos);\n        if (this.itemsMatch(playingItem, updatedPlayingItem)) {\n          this.playingItem = updatedPlayingItem;\n          this.waitingItem = this.endedItem = null;\n          trimInPlaceForPlayout = () => this.trimInPlace(updatedPlayingItem, playingItem);\n        }\n      } else {\n        // Clear waitingItem if it has been removed from the schedule\n        this.waitingItem = this.updateItem(this.waitingItem);\n        this.endedItem = this.updateItem(this.endedItem);\n      }\n      // Do not replace Interstitial bufferingItem without a match - used for transfering media element or source\n      const bufferingItem = this.bufferingItem;\n      if (bufferingItem) {\n        const updatedBufferingItem = this.updateItem(bufferingItem, this.bufferedPos);\n        if (this.itemsMatch(bufferingItem, updatedBufferingItem)) {\n          this.bufferingItem = updatedBufferingItem;\n          trimInPlaceForPlayout || (trimInPlaceForPlayout = () => this.trimInPlace(updatedBufferingItem, bufferingItem));\n        } else if (bufferingItem.event) {\n          // Interstitial removed from schedule (Live -> VOD or other scenario where Start Date is outside the range of VOD Playlist)\n          this.bufferingItem = this.playingItem;\n          this.clearInterstitial(bufferingItem.event, null);\n        }\n      }\n      removedInterstitials.forEach(interstitial => {\n        interstitial.assetList.forEach(asset => {\n          this.clearAssetPlayer(asset.identifier, null);\n        });\n      });\n      if (interstitialsUpdated || previousItems) {\n        this.hls.trigger(Events.INTERSTITIALS_UPDATED, {\n          events: interstitialEvents.slice(0),\n          schedule: scheduleItems.slice(0),\n          durations,\n          removedIds\n        });\n        if (this.isInterstitial(playingItem) && removedIds.includes(playingItem.event.identifier)) {\n          this.warn(`Interstitial \"${playingItem.event.identifier}\" removed while playing`);\n          this.primaryFallback(playingItem.event);\n          return;\n        }\n        if (trimInPlaceForPlayout) {\n          trimInPlaceForPlayout();\n        }\n\n        // Check is buffered to new Interstitial event boundary\n        // (Live update publishes Interstitial with new segment)\n        this.checkBuffer();\n      }\n    };\n    this.hls = hls;\n    this.HlsPlayerClass = HlsPlayerClass;\n    this.assetListLoader = new AssetListLoader(hls);\n    this.schedule = new InterstitialsSchedule(this.onScheduleUpdate, hls.logger);\n    this.registerListeners();\n  }\n  registerListeners() {\n    const hls = this.hls;\n    hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    hls.on(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n    hls.on(Events.AUDIO_TRACK_UPDATED, this.onAudioTrackUpdated, this);\n    hls.on(Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);\n    hls.on(Events.SUBTITLE_TRACK_UPDATED, this.onSubtitleTrackUpdated, this);\n    hls.on(Events.EVENT_CUE_ENTER, this.onInterstitialCueEnter, this);\n    hls.on(Events.ASSET_LIST_LOADED, this.onAssetListLoaded, this);\n    hls.on(Events.BUFFER_APPENDED, this.onBufferAppended, this);\n    hls.on(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n    hls.on(Events.BUFFERED_TO_END, this.onBufferedToEnd, this);\n    hls.on(Events.MEDIA_ENDED, this.onMediaEnded, this);\n    hls.on(Events.ERROR, this.onError, this);\n    hls.on(Events.DESTROYING, this.onDestroying, this);\n  }\n  unregisterListeners() {\n    const hls = this.hls;\n    if (!hls) {\n      return;\n    }\n    hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    hls.off(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n    hls.off(Events.AUDIO_TRACK_UPDATED, this.onAudioTrackUpdated, this);\n    hls.off(Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);\n    hls.off(Events.SUBTITLE_TRACK_UPDATED, this.onSubtitleTrackUpdated, this);\n    hls.off(Events.EVENT_CUE_ENTER, this.onInterstitialCueEnter, this);\n    hls.off(Events.ASSET_LIST_LOADED, this.onAssetListLoaded, this);\n    hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n    hls.off(Events.BUFFER_APPENDED, this.onBufferAppended, this);\n    hls.off(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n    hls.off(Events.BUFFERED_TO_END, this.onBufferedToEnd, this);\n    hls.off(Events.MEDIA_ENDED, this.onMediaEnded, this);\n    hls.off(Events.ERROR, this.onError, this);\n    hls.off(Events.DESTROYING, this.onDestroying, this);\n  }\n  startLoad() {\n    // TODO: startLoad - check for waitingItem and retry by resetting schedule\n    this.resumeBuffering();\n  }\n  stopLoad() {\n    // TODO: stopLoad - stop all scheule.events[].assetListLoader?.abort() then delete the loaders\n    this.pauseBuffering();\n  }\n  resumeBuffering() {\n    var _this$getBufferingPla;\n    (_this$getBufferingPla = this.getBufferingPlayer()) == null ? void 0 : _this$getBufferingPla.resumeBuffering();\n  }\n  pauseBuffering() {\n    var _this$getBufferingPla2;\n    (_this$getBufferingPla2 = this.getBufferingPlayer()) == null ? void 0 : _this$getBufferingPla2.pauseBuffering();\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.stopLoad();\n    if (this.assetListLoader) {\n      this.assetListLoader.destroy();\n    }\n    this.emptyPlayerQueue();\n    this.clearScheduleState();\n    if (this.schedule) {\n      this.schedule.destroy();\n    }\n    this.media = this.detachedData = this.mediaSelection = this.requiredTracks = this.altSelection = this.manager = null;\n    // @ts-ignore\n    this.hls = this.HlsPlayerClass = this.schedule = this.log = null;\n    // @ts-ignore\n    this.assetListLoader = null;\n    // @ts-ignore\n    this.onPlay = this.onPause = this.onSeeking = this.onTimeupdate = null;\n    // @ts-ignore\n    this.onScheduleUpdate = null;\n  }\n  onDestroying() {\n    const media = this.primaryMedia || this.media;\n    if (media) {\n      this.removeMediaListeners(media);\n    }\n  }\n  removeMediaListeners(media) {\n    removeEventListener(media, 'play', this.onPlay);\n    removeEventListener(media, 'pause', this.onPause);\n    removeEventListener(media, 'seeking', this.onSeeking);\n    removeEventListener(media, 'timeupdate', this.onTimeupdate);\n  }\n  onMediaAttaching(event, data) {\n    const media = this.media = data.media;\n    addEventListener(media, 'seeking', this.onSeeking);\n    addEventListener(media, 'timeupdate', this.onTimeupdate);\n    addEventListener(media, 'play', this.onPlay);\n    addEventListener(media, 'pause', this.onPause);\n  }\n  onMediaAttached(event, data) {\n    const playingItem = this.effectivePlayingItem;\n    const detachedMedia = this.detachedData;\n    this.detachedData = null;\n    if (playingItem === null) {\n      this.checkStart();\n    } else if (!detachedMedia) {\n      // Resume schedule after detached externally\n      this.clearScheduleState();\n      const playingIndex = this.findItemIndex(playingItem);\n      this.setSchedulePosition(playingIndex);\n    }\n  }\n  clearScheduleState() {\n    this.playingItem = this.bufferingItem = this.waitingItem = this.endedItem = this.playingAsset = this.endedAsset = this.bufferingAsset = null;\n  }\n  onMediaDetaching(event, data) {\n    const transferringMedia = !!data.transferMedia;\n    const media = this.media;\n    this.media = null;\n    if (transferringMedia) {\n      return;\n    }\n    if (media) {\n      this.removeMediaListeners(media);\n    }\n    // If detachMedia is called while in an Interstitial, detach the asset player as well and reset the schedule position\n    if (this.detachedData) {\n      const player = this.getBufferingPlayer();\n      if (player) {\n        this.playingAsset = this.endedAsset = this.bufferingAsset = this.bufferingItem = this.waitingItem = this.detachedData = null;\n        player.detachMedia();\n      }\n      this.shouldPlay = false;\n    }\n  }\n  get interstitialsManager() {\n    if (!this.manager) {\n      if (!this.hls) {\n        return null;\n      }\n      const c = this;\n      const effectiveBufferingItem = () => c.bufferingItem || c.waitingItem;\n      const getAssetPlayer = asset => asset ? c.getAssetPlayer(asset.identifier) : asset;\n      const getMappedTime = (item, timelineType, asset, controllerField, assetPlayerField) => {\n        if (item) {\n          let time = item[timelineType].start;\n          const interstitial = item.event;\n          if (interstitial) {\n            if (timelineType === 'playout' || interstitial.timelineOccupancy !== TimelineOccupancy.Point) {\n              const assetPlayer = getAssetPlayer(asset);\n              if ((assetPlayer == null ? void 0 : assetPlayer.interstitial) === interstitial) {\n                time += assetPlayer.assetItem.startOffset + assetPlayer[assetPlayerField];\n              }\n            }\n          } else {\n            const value = controllerField === 'bufferedPos' ? getBufferedEnd() : c[controllerField];\n            time += value - item.start;\n          }\n          return time;\n        }\n        return 0;\n      };\n      const findMappedTime = (primaryTime, timelineType) => {\n        if (primaryTime !== 0 && timelineType !== 'primary' && c.schedule.length) {\n          var _c$schedule$items;\n          const index = c.schedule.findItemIndexAtTime(primaryTime);\n          const item = (_c$schedule$items = c.schedule.items) == null ? void 0 : _c$schedule$items[index];\n          if (item) {\n            const diff = item[timelineType].start - item.start;\n            return primaryTime + diff;\n          }\n        }\n        return primaryTime;\n      };\n      const getBufferedEnd = () => {\n        const value = c.bufferedPos;\n        if (value === Number.MAX_VALUE) {\n          return getMappedDuration('primary');\n        }\n        return Math.max(value, 0);\n      };\n      const getMappedDuration = timelineType => {\n        var _c$primaryDetails;\n        if ((_c$primaryDetails = c.primaryDetails) != null && _c$primaryDetails.live) {\n          // return end of last event item or playlist\n          return c.primaryDetails.edge;\n        }\n        return c.schedule.durations[timelineType];\n      };\n      const seekTo = (time, timelineType) => {\n        var _item$event, _c$schedule$items2;\n        const item = c.effectivePlayingItem;\n        if (item != null && (_item$event = item.event) != null && _item$event.restrictions.skip) {\n          return;\n        }\n        c.log(`seek to ${time} \"${timelineType}\"`);\n        const playingItem = c.effectivePlayingItem;\n        const targetIndex = c.schedule.findItemIndexAtTime(time, timelineType);\n        const targetItem = (_c$schedule$items2 = c.schedule.items) == null ? void 0 : _c$schedule$items2[targetIndex];\n        const bufferingPlayer = c.getBufferingPlayer();\n        const bufferingInterstitial = bufferingPlayer == null ? void 0 : bufferingPlayer.interstitial;\n        const appendInPlace = bufferingInterstitial == null ? void 0 : bufferingInterstitial.appendInPlace;\n        const seekInItem = playingItem && c.itemsMatch(playingItem, targetItem);\n        if (playingItem && (appendInPlace || seekInItem)) {\n          // seek in asset player or primary media (appendInPlace)\n          const assetPlayer = getAssetPlayer(c.playingAsset);\n          const media = (assetPlayer == null ? void 0 : assetPlayer.media) || c.primaryMedia;\n          if (media) {\n            const currentTime = timelineType === 'primary' ? media.currentTime : getMappedTime(playingItem, timelineType, c.playingAsset, 'timelinePos', 'currentTime');\n            const diff = time - currentTime;\n            const seekToTime = (appendInPlace ? currentTime : media.currentTime) + diff;\n            if (seekToTime >= 0 && (!assetPlayer || appendInPlace || seekToTime <= assetPlayer.duration)) {\n              media.currentTime = seekToTime;\n              return;\n            }\n          }\n        }\n        // seek out of item or asset\n        if (targetItem) {\n          let seekToTime = time;\n          if (timelineType !== 'primary') {\n            const primarySegmentStart = targetItem[timelineType].start;\n            const diff = time - primarySegmentStart;\n            seekToTime = targetItem.start + diff;\n          }\n          const targetIsPrimary = !c.isInterstitial(targetItem);\n          if ((!c.isInterstitial(playingItem) || playingItem.event.appendInPlace) && (targetIsPrimary || targetItem.event.appendInPlace)) {\n            const media = c.media || (appendInPlace ? bufferingPlayer == null ? void 0 : bufferingPlayer.media : null);\n            if (media) {\n              media.currentTime = seekToTime;\n            }\n          } else if (playingItem) {\n            // check if an Interstitial between the current item and target item has an X-RESTRICT JUMP restriction\n            const playingIndex = c.findItemIndex(playingItem);\n            if (targetIndex > playingIndex) {\n              const jumpIndex = c.schedule.findJumpRestrictedIndex(playingIndex + 1, targetIndex);\n              if (jumpIndex > playingIndex) {\n                c.setSchedulePosition(jumpIndex);\n                return;\n              }\n            }\n            let assetIndex = 0;\n            if (targetIsPrimary) {\n              c.timelinePos = seekToTime;\n              c.checkBuffer();\n            } else {\n              var _targetItem$event;\n              const assetList = targetItem == null ? void 0 : (_targetItem$event = targetItem.event) == null ? void 0 : _targetItem$event.assetList;\n              if (assetList) {\n                const eventTime = time - (targetItem[timelineType] || targetItem).start;\n                for (let i = assetList.length; i--;) {\n                  const asset = assetList[i];\n                  if (asset.duration && eventTime >= asset.startOffset && eventTime < asset.startOffset + asset.duration) {\n                    assetIndex = i;\n                    break;\n                  }\n                }\n              }\n            }\n            c.setSchedulePosition(targetIndex, assetIndex);\n          }\n        }\n      };\n      const getActiveInterstitial = () => {\n        const playingItem = c.effectivePlayingItem;\n        if (c.isInterstitial(playingItem)) {\n          return playingItem;\n        }\n        const bufferingItem = effectiveBufferingItem();\n        if (c.isInterstitial(bufferingItem)) {\n          return bufferingItem;\n        }\n        return null;\n      };\n      const interstitialPlayer = {\n        get currentTime() {\n          const interstitialItem = getActiveInterstitial();\n          const playingItem = c.effectivePlayingItem;\n          if (playingItem && playingItem === interstitialItem) {\n            return getMappedTime(playingItem, 'playout', c.effectivePlayingAsset, 'timelinePos', 'currentTime') - playingItem.playout.start;\n          }\n          return 0;\n        },\n        set currentTime(time) {\n          const interstitialItem = getActiveInterstitial();\n          const playingItem = c.effectivePlayingItem;\n          if (playingItem && playingItem === interstitialItem) {\n            seekTo(time + playingItem.playout.start, 'playout');\n          }\n        },\n        get duration() {\n          const interstitialItem = getActiveInterstitial();\n          if (interstitialItem) {\n            return interstitialItem.playout.end - interstitialItem.playout.start;\n          }\n          return 0;\n        },\n        get assetPlayers() {\n          var _getActiveInterstitia;\n          const assetList = (_getActiveInterstitia = getActiveInterstitial()) == null ? void 0 : _getActiveInterstitia.event.assetList;\n          if (assetList) {\n            return assetList.map(asset => c.getAssetPlayer(asset.identifier));\n          }\n          return [];\n        },\n        get playingIndex() {\n          var _getActiveInterstitia2;\n          const interstitial = (_getActiveInterstitia2 = getActiveInterstitial()) == null ? void 0 : _getActiveInterstitia2.event;\n          if (interstitial && c.effectivePlayingAsset) {\n            return interstitial.findAssetIndex(c.effectivePlayingAsset);\n          }\n          return -1;\n        },\n        get scheduleItem() {\n          return getActiveInterstitial();\n        }\n      };\n      this.manager = {\n        get events() {\n          var _c$schedule, _c$schedule$events;\n          return ((_c$schedule = c.schedule) == null ? void 0 : (_c$schedule$events = _c$schedule.events) == null ? void 0 : _c$schedule$events.slice(0)) || [];\n        },\n        get schedule() {\n          var _c$schedule2, _c$schedule2$items;\n          return ((_c$schedule2 = c.schedule) == null ? void 0 : (_c$schedule2$items = _c$schedule2.items) == null ? void 0 : _c$schedule2$items.slice(0)) || [];\n        },\n        get interstitialPlayer() {\n          if (getActiveInterstitial()) {\n            return interstitialPlayer;\n          }\n          return null;\n        },\n        get playerQueue() {\n          return c.playerQueue.slice(0);\n        },\n        get bufferingAsset() {\n          return c.bufferingAsset;\n        },\n        get bufferingItem() {\n          return effectiveBufferingItem();\n        },\n        get bufferingIndex() {\n          const item = effectiveBufferingItem();\n          return c.findItemIndex(item);\n        },\n        get playingAsset() {\n          return c.effectivePlayingAsset;\n        },\n        get playingItem() {\n          return c.effectivePlayingItem;\n        },\n        get playingIndex() {\n          const item = c.effectivePlayingItem;\n          return c.findItemIndex(item);\n        },\n        primary: {\n          get bufferedEnd() {\n            return getBufferedEnd();\n          },\n          get currentTime() {\n            const timelinePos = c.timelinePos;\n            return timelinePos > 0 ? timelinePos : 0;\n          },\n          set currentTime(time) {\n            seekTo(time, 'primary');\n          },\n          get duration() {\n            return getMappedDuration('primary');\n          },\n          get seekableStart() {\n            var _c$primaryDetails2;\n            return ((_c$primaryDetails2 = c.primaryDetails) == null ? void 0 : _c$primaryDetails2.fragmentStart) || 0;\n          }\n        },\n        integrated: {\n          get bufferedEnd() {\n            return getMappedTime(effectiveBufferingItem(), 'integrated', c.bufferingAsset, 'bufferedPos', 'bufferedEnd');\n          },\n          get currentTime() {\n            return getMappedTime(c.effectivePlayingItem, 'integrated', c.effectivePlayingAsset, 'timelinePos', 'currentTime');\n          },\n          set currentTime(time) {\n            seekTo(time, 'integrated');\n          },\n          get duration() {\n            return getMappedDuration('integrated');\n          },\n          get seekableStart() {\n            var _c$primaryDetails3;\n            return findMappedTime(((_c$primaryDetails3 = c.primaryDetails) == null ? void 0 : _c$primaryDetails3.fragmentStart) || 0, 'integrated');\n          }\n        },\n        skip: () => {\n          const item = c.effectivePlayingItem;\n          const event = item == null ? void 0 : item.event;\n          if (event && !event.restrictions.skip) {\n            const index = c.findItemIndex(item);\n            if (event.appendInPlace) {\n              const time = item.playout.start + item.event.duration;\n              seekTo(time + 0.001, 'playout');\n            } else {\n              c.advanceAfterAssetEnded(event, index, Infinity);\n            }\n          }\n        }\n      };\n    }\n    return this.manager;\n  }\n\n  // Schedule getters\n  get effectivePlayingItem() {\n    return this.waitingItem || this.playingItem || this.endedItem;\n  }\n  get effectivePlayingAsset() {\n    return this.playingAsset || this.endedAsset;\n  }\n  get playingLastItem() {\n    var _this$schedule;\n    const playingItem = this.playingItem;\n    const items = (_this$schedule = this.schedule) == null ? void 0 : _this$schedule.items;\n    if (!this.playbackStarted || !playingItem || !items) {\n      return false;\n    }\n    return this.findItemIndex(playingItem) === items.length - 1;\n  }\n  get playbackStarted() {\n    return this.effectivePlayingItem !== null;\n  }\n\n  // Media getters and event callbacks\n  get currentTime() {\n    var _this$bufferingItem, _this$bufferingItem$e, _media;\n    if (this.mediaSelection === null) {\n      // Do not advance before schedule is known\n      return undefined;\n    }\n    // Ignore currentTime when detached for Interstitial playback with source reset\n    const queuedForPlayback = this.waitingItem || this.playingItem;\n    if (this.isInterstitial(queuedForPlayback) && !queuedForPlayback.event.appendInPlace) {\n      return undefined;\n    }\n    let media = this.media;\n    if (!media && (_this$bufferingItem = this.bufferingItem) != null && (_this$bufferingItem$e = _this$bufferingItem.event) != null && _this$bufferingItem$e.appendInPlace) {\n      // Observe detached media currentTime when appending in place\n      media = this.primaryMedia;\n    }\n    const currentTime = (_media = media) == null ? void 0 : _media.currentTime;\n    if (currentTime === undefined || !isFiniteNumber(currentTime)) {\n      return undefined;\n    }\n    return currentTime;\n  }\n  get primaryMedia() {\n    var _this$detachedData;\n    return this.media || ((_this$detachedData = this.detachedData) == null ? void 0 : _this$detachedData.media) || null;\n  }\n  isInterstitial(item) {\n    return !!(item != null && item.event);\n  }\n  retreiveMediaSource(assetId, toSegment) {\n    const player = this.getAssetPlayer(assetId);\n    if (player) {\n      this.transferMediaFromPlayer(player, toSegment);\n    }\n  }\n  transferMediaFromPlayer(player, toSegment) {\n    const appendInPlace = player.interstitial.appendInPlace;\n    const playerMedia = player.media;\n    if (appendInPlace && playerMedia === this.primaryMedia) {\n      this.bufferingAsset = null;\n      if (!toSegment || this.isInterstitial(toSegment) && !toSegment.event.appendInPlace) {\n        // MediaSource cannot be transfered back to an Interstitial that requires a source reset\n        // no-op when toSegment is undefined\n        if (toSegment && playerMedia) {\n          this.detachedData = {\n            media: playerMedia\n          };\n          return;\n        }\n      }\n      const attachMediaSourceData = player.transferMedia();\n      this.log(`transfer MediaSource from ${player} ${stringify(attachMediaSourceData)}`);\n      this.detachedData = attachMediaSourceData;\n    } else if (toSegment && playerMedia) {\n      this.shouldPlay || (this.shouldPlay = !playerMedia.paused);\n    }\n  }\n  transferMediaTo(player, media) {\n    var _this$detachedData2, _attachMediaSourceDat;\n    if (player.media === media) {\n      return;\n    }\n    let attachMediaSourceData = null;\n    const primaryPlayer = this.hls;\n    const isAssetPlayer = player !== primaryPlayer;\n    const appendInPlace = isAssetPlayer && player.interstitial.appendInPlace;\n    const detachedMediaSource = (_this$detachedData2 = this.detachedData) == null ? void 0 : _this$detachedData2.mediaSource;\n    let logFromSource;\n    if (primaryPlayer.media) {\n      if (appendInPlace) {\n        attachMediaSourceData = primaryPlayer.transferMedia();\n        this.detachedData = attachMediaSourceData;\n      }\n      logFromSource = `Primary`;\n    } else if (detachedMediaSource) {\n      const bufferingPlayer = this.getBufferingPlayer();\n      if (bufferingPlayer) {\n        attachMediaSourceData = bufferingPlayer.transferMedia();\n        logFromSource = `${bufferingPlayer}`;\n      } else {\n        logFromSource = `detached MediaSource`;\n      }\n    } else {\n      logFromSource = `detached media`;\n    }\n    if (!attachMediaSourceData) {\n      if (detachedMediaSource) {\n        attachMediaSourceData = this.detachedData;\n        this.log(`using detachedData: MediaSource ${stringify(attachMediaSourceData)}`);\n      } else if (!this.detachedData || primaryPlayer.media === media) {\n        // Keep interstitial media transition consistent\n        const playerQueue = this.playerQueue;\n        if (playerQueue.length > 1) {\n          playerQueue.forEach(queuedPlayer => {\n            if (isAssetPlayer && queuedPlayer.interstitial.appendInPlace !== appendInPlace) {\n              const interstitial = queuedPlayer.interstitial;\n              this.clearInterstitial(queuedPlayer.interstitial, null);\n              interstitial.appendInPlace = false;\n              if (interstitial.appendInPlace) {\n                this.warn(`Could not change append strategy for queued assets ${interstitial}`);\n              }\n            }\n          });\n        }\n        this.hls.detachMedia();\n        this.detachedData = {\n          media\n        };\n      }\n    }\n    const transferring = attachMediaSourceData && 'mediaSource' in attachMediaSourceData && ((_attachMediaSourceDat = attachMediaSourceData.mediaSource) == null ? void 0 : _attachMediaSourceDat.readyState) !== 'closed';\n    const dataToAttach = transferring && attachMediaSourceData ? attachMediaSourceData : media;\n    this.log(`${transferring ? 'transfering MediaSource' : 'attaching media'} to ${isAssetPlayer ? player : 'Primary'} from ${logFromSource}`);\n    if (dataToAttach === attachMediaSourceData) {\n      const isAssetAtEndOfSchedule = isAssetPlayer && player.assetId === this.schedule.assetIdAtEnd;\n      // Prevent asset players from marking EoS on transferred MediaSource\n      dataToAttach.overrides = {\n        duration: this.schedule.duration,\n        endOfStream: !isAssetPlayer || isAssetAtEndOfSchedule,\n        cueRemoval: !isAssetPlayer\n      };\n    }\n    player.attachMedia(dataToAttach);\n  }\n  onInterstitialCueEnter() {\n    this.onTimeupdate();\n  }\n  // Scheduling methods\n  checkStart() {\n    const schedule = this.schedule;\n    const interstitialEvents = schedule.events;\n    if (!interstitialEvents || this.playbackDisabled || !this.media) {\n      return;\n    }\n    // Check buffered to pre-roll\n    if (this.bufferedPos === -1) {\n      this.bufferedPos = 0;\n    }\n    // Start stepping through schedule when playback begins for the first time and we have a pre-roll\n    const timelinePos = this.timelinePos;\n    const effectivePlayingItem = this.effectivePlayingItem;\n    if (timelinePos === -1) {\n      const startPosition = this.hls.startPosition;\n      this.timelinePos = startPosition;\n      if (interstitialEvents.length && interstitialEvents[0].cue.pre) {\n        const index = schedule.findEventIndex(interstitialEvents[0].identifier);\n        this.setSchedulePosition(index);\n      } else if (startPosition >= 0 || !this.primaryLive) {\n        const start = this.timelinePos = startPosition > 0 ? startPosition : 0;\n        const index = schedule.findItemIndexAtTime(start);\n        this.setSchedulePosition(index);\n      }\n    } else if (effectivePlayingItem && !this.playingItem) {\n      const index = schedule.findItemIndex(effectivePlayingItem);\n      this.setSchedulePosition(index);\n    }\n  }\n  advanceAfterAssetEnded(interstitial, index, assetListIndex) {\n    const nextAssetIndex = getNextAssetIndex(interstitial, assetListIndex);\n    if (!interstitial.isAssetPastPlayoutLimit(nextAssetIndex)) {\n      // Advance to next asset list item\n      this.setSchedulePosition(index, nextAssetIndex);\n    } else {\n      // Advance to next schedule segment\n      // check if we've reached the end of the program\n      const scheduleItems = this.schedule.items;\n      if (scheduleItems) {\n        const nextIndex = index + 1;\n        const scheduleLength = scheduleItems.length;\n        if (nextIndex >= scheduleLength) {\n          this.setSchedulePosition(-1);\n          return;\n        }\n        const resumptionTime = interstitial.resumeTime;\n        if (this.timelinePos < resumptionTime) {\n          this.timelinePos = resumptionTime;\n          this.checkBuffer();\n        }\n        this.setSchedulePosition(nextIndex);\n      }\n    }\n  }\n  setScheduleToAssetAtTime(time, playingAsset) {\n    const schedule = this.schedule;\n    const parentIdentifier = playingAsset.parentIdentifier;\n    const interstitial = schedule.getEvent(parentIdentifier);\n    if (interstitial) {\n      const itemIndex = schedule.findEventIndex(parentIdentifier);\n      const assetListIndex = schedule.findAssetIndex(interstitial, time);\n      this.advanceAfterAssetEnded(interstitial, itemIndex, assetListIndex - 1);\n    }\n  }\n  setSchedulePosition(index, assetListIndex) {\n    const scheduleItems = this.schedule.items;\n    if (!scheduleItems || this.playbackDisabled) {\n      return;\n    }\n    this.log(`setSchedulePosition ${index}, ${assetListIndex}`);\n    const scheduledItem = index >= 0 ? scheduleItems[index] : null;\n    // Cleanup current item / asset\n    const currentItem = this.playingItem;\n    const playingLastItem = this.playingLastItem;\n    if (this.isInterstitial(currentItem)) {\n      var _interstitial$assetLi;\n      const interstitial = currentItem.event;\n      const playingAsset = this.playingAsset;\n      const assetId = playingAsset == null ? void 0 : playingAsset.identifier;\n      const player = assetId ? this.getAssetPlayer(assetId) : null;\n      if (player && assetId && (!this.eventItemsMatch(currentItem, scheduledItem) || assetListIndex !== undefined && assetId !== ((_interstitial$assetLi = interstitial.assetList) == null ? void 0 : _interstitial$assetLi[assetListIndex].identifier))) {\n        var _this$detachedData3;\n        const playingAssetListIndex = interstitial.findAssetIndex(playingAsset);\n        this.log(`INTERSTITIAL_ASSET_ENDED ${playingAssetListIndex + 1}/${interstitial.assetList.length} ${eventAssetToString(playingAsset)}`);\n        this.endedAsset = playingAsset;\n        this.playingAsset = null;\n        this.hls.trigger(Events.INTERSTITIAL_ASSET_ENDED, {\n          asset: playingAsset,\n          assetListIndex: playingAssetListIndex,\n          event: interstitial,\n          schedule: scheduleItems.slice(0),\n          scheduleIndex: index,\n          player\n        });\n        if (currentItem !== this.playingItem) {\n          // Schedule change occured on INTERSTITIAL_ASSET_ENDED\n          if (this.itemsMatch(currentItem, this.playingItem) && !this.playingAsset) {\n            this.advanceAfterAssetEnded(interstitial, this.findItemIndex(this.playingItem), playingAssetListIndex);\n          }\n          // Navigation occured on INTERSTITIAL_ASSET_ENDED\n          return;\n        }\n        this.retreiveMediaSource(assetId, scheduledItem);\n        if (player.media && !((_this$detachedData3 = this.detachedData) != null && _this$detachedData3.mediaSource)) {\n          player.detachMedia();\n        }\n      }\n      if (!this.eventItemsMatch(currentItem, scheduledItem)) {\n        this.endedItem = currentItem;\n        this.playingItem = null;\n        this.log(`INTERSTITIAL_ENDED ${interstitial} ${segmentToString(currentItem)}`);\n        interstitial.hasPlayed = true;\n        this.hls.trigger(Events.INTERSTITIAL_ENDED, {\n          event: interstitial,\n          schedule: scheduleItems.slice(0),\n          scheduleIndex: index\n        });\n        // Exiting an Interstitial\n        if (interstitial.cue.once) {\n          // Remove interstitial with CUE attribute value of ONCE after it has played\n          this.updateSchedule();\n          const items = this.schedule.items;\n          if (scheduledItem && items) {\n            const updatedIndex = this.findItemIndex(scheduledItem);\n            this.advanceSchedule(updatedIndex, items, assetListIndex, currentItem, playingLastItem);\n          }\n          return;\n        }\n      }\n    }\n    this.advanceSchedule(index, scheduleItems, assetListIndex, currentItem, playingLastItem);\n  }\n  advanceSchedule(index, scheduleItems, assetListIndex, currentItem, playedLastItem) {\n    const scheduledItem = index >= 0 ? scheduleItems[index] : null;\n    const media = this.primaryMedia;\n    // Cleanup out of range Interstitials\n    const playerQueue = this.playerQueue;\n    if (playerQueue.length) {\n      playerQueue.forEach(player => {\n        const interstitial = player.interstitial;\n        const queuedIndex = this.schedule.findEventIndex(interstitial.identifier);\n        if (queuedIndex < index || queuedIndex > index + 1) {\n          this.clearInterstitial(interstitial, scheduledItem);\n        }\n      });\n    }\n    // Setup scheduled item\n    if (this.isInterstitial(scheduledItem)) {\n      this.timelinePos = Math.min(Math.max(this.timelinePos, scheduledItem.start), scheduledItem.end);\n      // Handle Interstitial\n      const interstitial = scheduledItem.event;\n      // find asset index\n      if (assetListIndex === undefined) {\n        assetListIndex = this.schedule.findAssetIndex(interstitial, this.timelinePos);\n        const assetIndexCandidate = getNextAssetIndex(interstitial, assetListIndex - 1);\n        if (interstitial.isAssetPastPlayoutLimit(assetIndexCandidate)) {\n          this.advanceAfterAssetEnded(interstitial, index, assetListIndex);\n          return;\n        }\n        assetListIndex = assetIndexCandidate;\n      }\n      // Ensure Interstitial is enqueued\n      const waitingItem = this.waitingItem;\n      if (!this.assetsBuffered(scheduledItem, media)) {\n        this.setBufferingItem(scheduledItem);\n      }\n      let player = this.preloadAssets(interstitial, assetListIndex);\n      if (!this.eventItemsMatch(scheduledItem, waitingItem || currentItem)) {\n        this.waitingItem = scheduledItem;\n        this.log(`INTERSTITIAL_STARTED ${segmentToString(scheduledItem)} ${interstitial.appendInPlace ? 'append in place' : ''}`);\n        this.hls.trigger(Events.INTERSTITIAL_STARTED, {\n          event: interstitial,\n          schedule: scheduleItems.slice(0),\n          scheduleIndex: index\n        });\n      }\n      if (!interstitial.assetListLoaded) {\n        // Waiting at end of primary content segment\n        // Expect setSchedulePosition to be called again once ASSET-LIST is loaded\n        this.log(`Waiting for ASSET-LIST to complete loading ${interstitial}`);\n        return;\n      }\n      if (interstitial.assetListLoader) {\n        interstitial.assetListLoader.destroy();\n        interstitial.assetListLoader = undefined;\n      }\n      if (!media) {\n        this.log(`Waiting for attachMedia to start Interstitial ${interstitial}`);\n        return;\n      }\n      // Update schedule and asset list position now that it can start\n      this.waitingItem = this.endedItem = null;\n      this.playingItem = scheduledItem;\n\n      // If asset-list is empty or missing asset index, advance to next item\n      const assetItem = interstitial.assetList[assetListIndex];\n      if (!assetItem) {\n        const nextItem = scheduleItems[index + 1];\n        const _media2 = this.media;\n        if (nextItem && _media2 && !this.isInterstitial(nextItem) && _media2.currentTime < nextItem.start) {\n          _media2.currentTime = this.timelinePos = nextItem.start;\n        }\n        this.advanceAfterAssetEnded(interstitial, index, assetListIndex || 0);\n        return;\n      }\n\n      // Start Interstitial Playback\n      if (!player) {\n        player = this.getAssetPlayer(assetItem.identifier);\n      }\n      if (player === null || player.destroyed) {\n        const assetListLength = interstitial.assetList.length;\n        this.warn(`asset ${assetListIndex + 1}/${assetListLength} player destroyed ${interstitial}`);\n        player = this.createAssetPlayer(interstitial, assetItem, assetListIndex);\n      }\n      if (!this.eventItemsMatch(scheduledItem, this.bufferingItem)) {\n        if (interstitial.appendInPlace && this.isAssetBuffered(assetItem)) {\n          return;\n        }\n      }\n      this.startAssetPlayer(player, assetListIndex, scheduleItems, index, media);\n      if (this.shouldPlay) {\n        playWithCatch(player.media);\n      }\n    } else if (scheduledItem !== null) {\n      this.resumePrimary(scheduledItem, index, currentItem);\n      if (this.shouldPlay) {\n        playWithCatch(this.hls.media);\n      }\n    } else if (playedLastItem && this.isInterstitial(currentItem)) {\n      // Maintain playingItem state at end of schedule (setSchedulePosition(-1) called to end program)\n      // this allows onSeeking handler to update schedule position\n      this.endedItem = null;\n      this.playingItem = currentItem;\n      if (!currentItem.event.appendInPlace) {\n        // Media must be re-attached to resume primary schedule if not sharing source\n        this.attachPrimary(this.schedule.durations.primary, null);\n      }\n    }\n  }\n  get playbackDisabled() {\n    return this.hls.config.enableInterstitialPlayback === false;\n  }\n  get primaryDetails() {\n    var _this$mediaSelection, _this$mediaSelection$;\n    return (_this$mediaSelection = this.mediaSelection) == null ? void 0 : (_this$mediaSelection$ = _this$mediaSelection.main) == null ? void 0 : _this$mediaSelection$.details;\n  }\n  get primaryLive() {\n    var _this$primaryDetails;\n    return !!((_this$primaryDetails = this.primaryDetails) != null && _this$primaryDetails.live);\n  }\n  resumePrimary(scheduledItem, index, fromItem) {\n    var _this$detachedData4;\n    this.playingItem = scheduledItem;\n    this.playingAsset = this.endedAsset = null;\n    this.waitingItem = this.endedItem = null;\n    this.bufferedToItem(scheduledItem);\n    this.log(`resuming ${segmentToString(scheduledItem)}`);\n    if (!((_this$detachedData4 = this.detachedData) != null && _this$detachedData4.mediaSource)) {\n      let timelinePos = this.timelinePos;\n      if (timelinePos < scheduledItem.start || timelinePos >= scheduledItem.end) {\n        timelinePos = this.getPrimaryResumption(scheduledItem, index);\n        this.timelinePos = timelinePos;\n      }\n      this.attachPrimary(timelinePos, scheduledItem);\n    }\n    if (!fromItem) {\n      return;\n    }\n    const scheduleItems = this.schedule.items;\n    if (!scheduleItems) {\n      return;\n    }\n    this.log(`INTERSTITIALS_PRIMARY_RESUMED ${segmentToString(scheduledItem)}`);\n    this.hls.trigger(Events.INTERSTITIALS_PRIMARY_RESUMED, {\n      schedule: scheduleItems.slice(0),\n      scheduleIndex: index\n    });\n    this.checkBuffer();\n  }\n  getPrimaryResumption(scheduledItem, index) {\n    const itemStart = scheduledItem.start;\n    if (this.primaryLive) {\n      const details = this.primaryDetails;\n      if (index === 0) {\n        return this.hls.startPosition;\n      } else if (details && (itemStart < details.fragmentStart || itemStart > details.edge)) {\n        return this.hls.liveSyncPosition || -1;\n      }\n    }\n    return itemStart;\n  }\n  isAssetBuffered(asset) {\n    const player = this.getAssetPlayer(asset.identifier);\n    if (player != null && player.hls) {\n      return player.hls.bufferedToEnd;\n    }\n    const bufferInfo = BufferHelper.bufferInfo(this.primaryMedia, this.timelinePos, 0);\n    return bufferInfo.end + 1 >= asset.timelineStart + (asset.duration || 0);\n  }\n  attachPrimary(timelinePos, item, skipSeekToStartPosition) {\n    if (item) {\n      this.setBufferingItem(item);\n    } else {\n      this.bufferingItem = this.playingItem;\n    }\n    this.bufferingAsset = null;\n    const media = this.primaryMedia;\n    if (!media) {\n      return;\n    }\n    const hls = this.hls;\n    if (hls.media) {\n      this.checkBuffer();\n    } else {\n      this.transferMediaTo(hls, media);\n      if (skipSeekToStartPosition) {\n        this.startLoadingPrimaryAt(timelinePos, skipSeekToStartPosition);\n      }\n    }\n    if (!skipSeekToStartPosition) {\n      // Set primary position to resume time\n      this.timelinePos = timelinePos;\n      this.startLoadingPrimaryAt(timelinePos, skipSeekToStartPosition);\n    }\n  }\n  startLoadingPrimaryAt(timelinePos, skipSeekToStartPosition) {\n    var _hls$mainForwardBuffe;\n    const hls = this.hls;\n    if (!hls.loadingEnabled || !hls.media || Math.abs((((_hls$mainForwardBuffe = hls.mainForwardBufferInfo) == null ? void 0 : _hls$mainForwardBuffe.start) || hls.media.currentTime) - timelinePos) > 0.5) {\n      hls.startLoad(timelinePos, skipSeekToStartPosition);\n    } else if (!hls.bufferingEnabled) {\n      hls.resumeBuffering();\n    }\n  }\n\n  // HLS.js event callbacks\n  onManifestLoading() {\n    this.stopLoad();\n    this.schedule.reset();\n    this.emptyPlayerQueue();\n    this.clearScheduleState();\n    this.shouldPlay = false;\n    this.bufferedPos = this.timelinePos = -1;\n    this.mediaSelection = this.altSelection = this.manager = this.requiredTracks = null;\n    // BUFFER_CODECS listener added here for buffer-controller to handle it first where it adds tracks\n    this.hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n    this.hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n  }\n  onLevelUpdated(event, data) {\n    if (data.level === -1) {\n      // level was removed\n      return;\n    }\n    const main = this.hls.levels[data.level];\n    const currentSelection = _objectSpread2(_objectSpread2({}, this.mediaSelection || this.altSelection), {}, {\n      main\n    });\n    this.mediaSelection = currentSelection;\n    this.schedule.parseInterstitialDateRanges(currentSelection, this.hls.config.interstitialAppendInPlace);\n    if (!this.effectivePlayingItem && this.schedule.items) {\n      this.checkStart();\n    }\n  }\n  onAudioTrackUpdated(event, data) {\n    const audio = this.hls.audioTracks[data.id];\n    const previousSelection = this.mediaSelection;\n    if (!previousSelection) {\n      this.altSelection = _objectSpread2(_objectSpread2({}, this.altSelection), {}, {\n        audio\n      });\n      return;\n    }\n    const currentSelection = _objectSpread2(_objectSpread2({}, previousSelection), {}, {\n      audio\n    });\n    this.mediaSelection = currentSelection;\n  }\n  onSubtitleTrackUpdated(event, data) {\n    const subtitles = this.hls.subtitleTracks[data.id];\n    const previousSelection = this.mediaSelection;\n    if (!previousSelection) {\n      this.altSelection = _objectSpread2(_objectSpread2({}, this.altSelection), {}, {\n        subtitles\n      });\n      return;\n    }\n    const currentSelection = _objectSpread2(_objectSpread2({}, previousSelection), {}, {\n      subtitles\n    });\n    this.mediaSelection = currentSelection;\n  }\n  onAudioTrackSwitching(event, data) {\n    const audioOption = getBasicSelectionOption(data);\n    this.playerQueue.forEach(player => player.hls.setAudioOption(data) || player.hls.setAudioOption(audioOption));\n  }\n  onSubtitleTrackSwitch(event, data) {\n    const subtitleOption = getBasicSelectionOption(data);\n    this.playerQueue.forEach(player => player.hls.setSubtitleOption(data) || data.id !== -1 && player.hls.setSubtitleOption(subtitleOption));\n  }\n  onBufferCodecs(event, data) {\n    const requiredTracks = data.tracks;\n    if (requiredTracks) {\n      this.requiredTracks = requiredTracks;\n    }\n  }\n  onBufferAppended(event, data) {\n    this.checkBuffer();\n  }\n  onBufferFlushed(event, data) {\n    const playingItem = this.playingItem;\n    if (playingItem && !this.itemsMatch(playingItem, this.bufferingItem) && !this.isInterstitial(playingItem)) {\n      const timelinePos = this.timelinePos;\n      this.bufferedPos = timelinePos;\n      this.checkBuffer();\n    }\n  }\n  onBufferedToEnd(event) {\n    // Buffered to post-roll\n    const interstitialEvents = this.schedule.events;\n    if (this.bufferedPos < Number.MAX_VALUE && interstitialEvents) {\n      for (let i = 0; i < interstitialEvents.length; i++) {\n        const interstitial = interstitialEvents[i];\n        if (interstitial.cue.post) {\n          var _this$schedule$items;\n          const scheduleIndex = this.schedule.findEventIndex(interstitial.identifier);\n          const item = (_this$schedule$items = this.schedule.items) == null ? void 0 : _this$schedule$items[scheduleIndex];\n          if (this.isInterstitial(item) && this.eventItemsMatch(item, this.bufferingItem)) {\n            this.bufferedToItem(item, 0);\n          }\n          break;\n        }\n      }\n      this.bufferedPos = Number.MAX_VALUE;\n    }\n  }\n  onMediaEnded(event) {\n    const playingItem = this.playingItem;\n    if (!this.playingLastItem && playingItem) {\n      const playingIndex = this.findItemIndex(playingItem);\n      this.setSchedulePosition(playingIndex + 1);\n    } else {\n      this.shouldPlay = false;\n    }\n  }\n  updateItem(previousItem, time) {\n    // find item in this.schedule.items;\n    const items = this.schedule.items;\n    if (previousItem && items) {\n      const index = this.findItemIndex(previousItem, time);\n      return items[index] || null;\n    }\n    return null;\n  }\n  trimInPlace(updatedItem, itemBeforeUpdate) {\n    if (this.isInterstitial(updatedItem) && updatedItem.event.appendInPlace && itemBeforeUpdate.end - updatedItem.end > 0.25) {\n      updatedItem.event.assetList.forEach((asset, index) => {\n        if (updatedItem.event.isAssetPastPlayoutLimit(index)) {\n          this.clearAssetPlayer(asset.identifier, null);\n        }\n      });\n      const flushStart = updatedItem.end + 0.25;\n      const bufferInfo = BufferHelper.bufferInfo(this.primaryMedia, flushStart, 0);\n      if (bufferInfo.end > flushStart || (bufferInfo.nextStart || 0) > flushStart) {\n        this.attachPrimary(flushStart, null);\n        this.flushFrontBuffer(flushStart);\n      }\n    }\n  }\n  itemsMatch(a, b) {\n    return !!b && (a === b || a.event && b.event && this.eventItemsMatch(a, b) || !a.event && !b.event && this.findItemIndex(a) === this.findItemIndex(b));\n  }\n  eventItemsMatch(a, b) {\n    var _b$event;\n    return !!b && (a === b || a.event.identifier === ((_b$event = b.event) == null ? void 0 : _b$event.identifier));\n  }\n  findItemIndex(item, time) {\n    return item ? this.schedule.findItemIndex(item, time) : -1;\n  }\n  updateSchedule() {\n    const mediaSelection = this.mediaSelection;\n    if (!mediaSelection) {\n      return;\n    }\n    this.schedule.updateSchedule(mediaSelection, []);\n  }\n\n  // Schedule buffer control\n  checkBuffer(starved) {\n    const items = this.schedule.items;\n    if (!items) {\n      return;\n    }\n    // Find when combined forward buffer change reaches next schedule segment\n    const bufferInfo = BufferHelper.bufferInfo(this.primaryMedia, this.timelinePos, 0);\n    if (starved) {\n      this.bufferedPos = this.timelinePos;\n    }\n    starved || (starved = bufferInfo.len < 1);\n    this.updateBufferedPos(bufferInfo.end, items, starved);\n  }\n  updateBufferedPos(bufferEnd, items, bufferIsEmpty) {\n    const schedule = this.schedule;\n    const bufferingItem = this.bufferingItem;\n    if (this.bufferedPos > bufferEnd) {\n      return;\n    }\n    if (items.length === 1 && this.itemsMatch(items[0], bufferingItem)) {\n      this.bufferedPos = bufferEnd;\n      return;\n    }\n    const playingItem = this.playingItem;\n    const playingIndex = this.findItemIndex(playingItem);\n    let bufferEndIndex = schedule.findItemIndexAtTime(bufferEnd);\n    if (this.bufferedPos < bufferEnd) {\n      var _nextItemToBuffer$eve, _bufferingItem$event;\n      const bufferingIndex = this.findItemIndex(bufferingItem);\n      const nextToBufferIndex = Math.min(bufferingIndex + 1, items.length - 1);\n      const nextItemToBuffer = items[nextToBufferIndex];\n      if (bufferEndIndex === -1 && bufferingItem && bufferEnd >= bufferingItem.end || (_nextItemToBuffer$eve = nextItemToBuffer.event) != null && _nextItemToBuffer$eve.appendInPlace && bufferEnd + 0.01 >= nextItemToBuffer.start) {\n        bufferEndIndex = nextToBufferIndex;\n      }\n      if (nextToBufferIndex - playingIndex > 1 && (bufferingItem == null ? void 0 : (_bufferingItem$event = bufferingItem.event) == null ? void 0 : _bufferingItem$event.appendInPlace) === false) {\n        // do not advance buffering item past Interstitial that requires source reset\n        return;\n      }\n      this.bufferedPos = bufferEnd;\n      if (bufferEndIndex > bufferingIndex && bufferEndIndex > playingIndex) {\n        this.bufferedToItem(nextItemToBuffer);\n      } else {\n        // allow more time than distance from edge for assets to load\n        const details = this.primaryDetails;\n        if (this.primaryLive && details && bufferEnd > details.edge - details.targetduration && nextItemToBuffer.start < details.edge + this.hls.config.interstitialLiveLookAhead && this.isInterstitial(nextItemToBuffer)) {\n          this.preloadAssets(nextItemToBuffer.event, 0);\n        }\n      }\n    } else if (bufferIsEmpty && playingItem && !this.itemsMatch(playingItem, bufferingItem)) {\n      if (bufferEndIndex === playingIndex) {\n        this.bufferedToItem(playingItem);\n      } else if (bufferEndIndex === playingIndex + 1) {\n        this.bufferedToItem(items[bufferEndIndex]);\n      }\n    }\n  }\n  assetsBuffered(item, media) {\n    const assetList = item.event.assetList;\n    if (assetList.length === 0) {\n      return false;\n    }\n    return !item.event.assetList.some(asset => {\n      const player = this.getAssetPlayer(asset.identifier);\n      return !(player != null && player.bufferedInPlaceToEnd(media));\n    });\n  }\n  setBufferingItem(item) {\n    const bufferingLast = this.bufferingItem;\n    const schedule = this.schedule;\n    if (!this.itemsMatch(item, bufferingLast)) {\n      const {\n        items,\n        events\n      } = schedule;\n      if (!items || !events) {\n        return bufferingLast;\n      }\n      const isInterstitial = this.isInterstitial(item);\n      const bufferingPlayer = this.getBufferingPlayer();\n      this.bufferingItem = item;\n      this.bufferedPos = Math.max(item.start, Math.min(item.end, this.timelinePos));\n      const timeRemaining = bufferingPlayer ? bufferingPlayer.remaining : bufferingLast ? bufferingLast.end - this.timelinePos : 0;\n      this.log(`INTERSTITIALS_BUFFERED_TO_BOUNDARY ${segmentToString(item)}` + (bufferingLast ? ` (${timeRemaining.toFixed(2)} remaining)` : ''));\n      if (!this.playbackDisabled) {\n        if (isInterstitial) {\n          // primary fragment loading will exit early in base-stream-controller while `bufferingItem` is set to an Interstitial block\n          item.event.assetList.forEach(asset => {\n            const player = this.getAssetPlayer(asset.identifier);\n            if (player) {\n              player.resumeBuffering();\n            }\n          });\n        } else {\n          this.hls.resumeBuffering();\n          this.playerQueue.forEach(player => player.pauseBuffering());\n        }\n      }\n      this.hls.trigger(Events.INTERSTITIALS_BUFFERED_TO_BOUNDARY, {\n        events: events.slice(0),\n        schedule: items.slice(0),\n        bufferingIndex: this.findItemIndex(item),\n        playingIndex: this.findItemIndex(this.playingItem)\n      });\n    } else if (this.bufferingItem !== item) {\n      this.bufferingItem = item;\n    }\n    return bufferingLast;\n  }\n  bufferedToItem(item, assetListIndex = 0) {\n    const bufferingLast = this.setBufferingItem(item);\n    if (this.playbackDisabled) {\n      return;\n    }\n    if (this.isInterstitial(item)) {\n      // Ensure asset list is loaded\n      this.bufferedToEvent(item, assetListIndex);\n    } else if (bufferingLast !== null) {\n      // If primary player is detached, it is also stopped, restart loading at primary position\n      this.bufferingAsset = null;\n      const detachedData = this.detachedData;\n      if (detachedData) {\n        if (detachedData.mediaSource) {\n          const skipSeekToStartPosition = true;\n          this.attachPrimary(item.start, item, skipSeekToStartPosition);\n        } else {\n          this.preloadPrimary(item);\n        }\n      } else {\n        // If not detached seek to resumption point\n        this.preloadPrimary(item);\n      }\n    }\n  }\n  preloadPrimary(item) {\n    const index = this.findItemIndex(item);\n    const timelinePos = this.getPrimaryResumption(item, index);\n    this.startLoadingPrimaryAt(timelinePos);\n  }\n  bufferedToEvent(item, assetListIndex) {\n    const interstitial = item.event;\n    const neverLoaded = interstitial.assetList.length === 0 && !interstitial.assetListLoader;\n    const playOnce = interstitial.cue.once;\n    if (neverLoaded || !playOnce) {\n      // Buffered to Interstitial boundary\n      const player = this.preloadAssets(interstitial, assetListIndex);\n      if (player != null && player.interstitial.appendInPlace) {\n        // If we have a player and asset list info, start buffering\n        const assetItem = interstitial.assetList[assetListIndex];\n        const media = this.primaryMedia;\n        if (assetItem && media) {\n          this.bufferAssetPlayer(player, media);\n        }\n      }\n    }\n  }\n  preloadAssets(interstitial, assetListIndex) {\n    const uri = interstitial.assetUrl;\n    const assetListLength = interstitial.assetList.length;\n    const neverLoaded = assetListLength === 0 && !interstitial.assetListLoader;\n    const playOnce = interstitial.cue.once;\n    if (neverLoaded) {\n      const timelineStart = interstitial.timelineStart;\n      if (interstitial.appendInPlace) {\n        var _playingItem$nextEven;\n        const playingItem = this.playingItem;\n        if (!this.isInterstitial(playingItem) && (playingItem == null ? void 0 : (_playingItem$nextEven = playingItem.nextEvent) == null ? void 0 : _playingItem$nextEven.identifier) === interstitial.identifier) {\n          this.flushFrontBuffer(timelineStart + 0.25);\n        }\n      }\n      let hlsStartOffset;\n      let liveStartPosition = 0;\n      if (!this.playingItem && this.primaryLive) {\n        liveStartPosition = this.hls.startPosition;\n        if (liveStartPosition === -1) {\n          liveStartPosition = this.hls.liveSyncPosition || 0;\n        }\n      }\n      if (liveStartPosition && !(interstitial.cue.pre || interstitial.cue.post)) {\n        const startOffset = liveStartPosition - timelineStart;\n        if (startOffset > 0) {\n          hlsStartOffset = Math.round(startOffset * 1000) / 1000;\n        }\n      }\n      this.log(`Load interstitial asset ${assetListIndex + 1}/${uri ? 1 : assetListLength} ${interstitial}${hlsStartOffset ? ` live-start: ${liveStartPosition} start-offset: ${hlsStartOffset}` : ''}`);\n      if (uri) {\n        return this.createAsset(interstitial, 0, 0, timelineStart, interstitial.duration, uri);\n      }\n      const assetListLoader = this.assetListLoader.loadAssetList(interstitial, hlsStartOffset);\n      if (assetListLoader) {\n        interstitial.assetListLoader = assetListLoader;\n      }\n    } else if (!playOnce && assetListLength) {\n      // Re-buffered to Interstitial boundary, re-create asset player(s)\n      for (let i = assetListIndex; i < assetListLength; i++) {\n        const asset = interstitial.assetList[i];\n        const playerIndex = this.getAssetPlayerQueueIndex(asset.identifier);\n        if ((playerIndex === -1 || this.playerQueue[playerIndex].destroyed) && !asset.error) {\n          this.createAssetPlayer(interstitial, asset, i);\n        }\n      }\n      return this.getAssetPlayer(interstitial.assetList[assetListIndex].identifier);\n    }\n    return null;\n  }\n  flushFrontBuffer(startOffset) {\n    // Force queued flushing of all buffers\n    const requiredTracks = this.requiredTracks;\n    if (!requiredTracks) {\n      return;\n    }\n    this.log(`Removing front buffer starting at ${startOffset}`);\n    const sourceBufferNames = Object.keys(requiredTracks);\n    sourceBufferNames.forEach(type => {\n      this.hls.trigger(Events.BUFFER_FLUSHING, {\n        startOffset,\n        endOffset: Infinity,\n        type\n      });\n    });\n  }\n\n  // Interstitial Asset Player control\n  getAssetPlayerQueueIndex(assetId) {\n    const playerQueue = this.playerQueue;\n    for (let i = 0; i < playerQueue.length; i++) {\n      if (assetId === playerQueue[i].assetId) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  getAssetPlayer(assetId) {\n    const index = this.getAssetPlayerQueueIndex(assetId);\n    return this.playerQueue[index] || null;\n  }\n  getBufferingPlayer() {\n    const {\n      playerQueue,\n      primaryMedia\n    } = this;\n    if (primaryMedia) {\n      for (let i = 0; i < playerQueue.length; i++) {\n        if (playerQueue[i].media === primaryMedia) {\n          return playerQueue[i];\n        }\n      }\n    }\n    return null;\n  }\n  createAsset(interstitial, assetListIndex, startOffset, timelineStart, duration, uri) {\n    const assetItem = {\n      parentIdentifier: interstitial.identifier,\n      identifier: generateAssetIdentifier(interstitial, uri, assetListIndex),\n      duration,\n      startOffset,\n      timelineStart,\n      uri\n    };\n    return this.createAssetPlayer(interstitial, assetItem, assetListIndex);\n  }\n  createAssetPlayer(interstitial, assetItem, assetListIndex) {\n    const primary = this.hls;\n    const userConfig = primary.userConfig;\n    let videoPreference = userConfig.videoPreference;\n    const currentLevel = primary.loadLevelObj || primary.levels[primary.currentLevel];\n    if (videoPreference || currentLevel) {\n      videoPreference = _extends({}, videoPreference);\n      if (currentLevel.videoCodec) {\n        videoPreference.videoCodec = currentLevel.videoCodec;\n      }\n      if (currentLevel.videoRange) {\n        videoPreference.allowedVideoRanges = [currentLevel.videoRange];\n      }\n    }\n    const selectedAudio = primary.audioTracks[primary.audioTrack];\n    const selectedSubtitle = primary.subtitleTracks[primary.subtitleTrack];\n    let startPosition = 0;\n    if (this.primaryLive || interstitial.appendInPlace) {\n      const timePastStart = this.timelinePos - assetItem.timelineStart;\n      if (timePastStart > 1) {\n        const duration = assetItem.duration;\n        if (duration && timePastStart < duration) {\n          startPosition = timePastStart;\n        }\n      }\n    }\n    const assetId = assetItem.identifier;\n    const playerConfig = _objectSpread2(_objectSpread2({}, userConfig), {}, {\n      autoStartLoad: true,\n      startFragPrefetch: true,\n      primarySessionId: primary.sessionId,\n      assetPlayerId: assetId,\n      abrEwmaDefaultEstimate: primary.bandwidthEstimate,\n      interstitialsController: undefined,\n      startPosition,\n      liveDurationInfinity: false,\n      testBandwidth: false,\n      videoPreference,\n      audioPreference: selectedAudio || userConfig.audioPreference,\n      subtitlePreference: selectedSubtitle || userConfig.subtitlePreference\n    });\n    if (interstitial.appendInPlace) {\n      interstitial.appendInPlaceStarted = true;\n      if (assetItem.timelineStart) {\n        playerConfig.timelineOffset = assetItem.timelineStart;\n      }\n    }\n    const cmcd = playerConfig.cmcd;\n    if (cmcd != null && cmcd.sessionId && cmcd.contentId) {\n      playerConfig.cmcd = _extends({}, cmcd, {\n        contentId: hash(assetItem.uri)\n      });\n    }\n    if (this.getAssetPlayer(assetId)) {\n      this.warn(`Duplicate date range identifier ${interstitial} and asset ${assetId}`);\n    }\n    const player = new HlsAssetPlayer(this.HlsPlayerClass, playerConfig, interstitial, assetItem);\n    this.playerQueue.push(player);\n    interstitial.assetList[assetListIndex] = assetItem;\n    // Listen for LevelDetails and PTS change to update duration\n    const updateAssetPlayerDetails = details => {\n      if (details.live) {\n        const error = new Error(`Interstitials MUST be VOD assets ${interstitial}`);\n        const errorData = {\n          fatal: true,\n          type: ErrorTypes.OTHER_ERROR,\n          details: ErrorDetails.INTERSTITIAL_ASSET_ITEM_ERROR,\n          error\n        };\n        this.handleAssetItemError(errorData, interstitial, this.schedule.findEventIndex(interstitial.identifier), assetListIndex, error.message);\n        return;\n      }\n      // Get time at end of last fragment\n      const duration = details.edge - details.fragmentStart;\n      const currentAssetDuration = assetItem.duration;\n      if (currentAssetDuration === null || duration > currentAssetDuration) {\n        this.log(`Interstitial asset \"${assetId}\" duration change ${currentAssetDuration} > ${duration}`);\n        assetItem.duration = duration;\n        // Update schedule with new event and asset duration\n        this.updateSchedule();\n      }\n    };\n    player.on(Events.LEVEL_UPDATED, (event, {\n      details\n    }) => updateAssetPlayerDetails(details));\n    player.on(Events.LEVEL_PTS_UPDATED, (event, {\n      details\n    }) => updateAssetPlayerDetails(details));\n    const onBufferCodecs = (event, data) => {\n      const inQueuPlayer = this.getAssetPlayer(assetId);\n      if (inQueuPlayer && data.tracks) {\n        inQueuPlayer.off(Events.BUFFER_CODECS, onBufferCodecs);\n        inQueuPlayer.tracks = data.tracks;\n        const media = this.primaryMedia;\n        if (this.bufferingAsset === inQueuPlayer.assetItem && media && !inQueuPlayer.media) {\n          this.bufferAssetPlayer(inQueuPlayer, media);\n        }\n      }\n    };\n    player.on(Events.BUFFER_CODECS, onBufferCodecs);\n    const bufferedToEnd = () => {\n      var _this$schedule$items2;\n      const inQueuPlayer = this.getAssetPlayer(assetId);\n      this.log(`buffered to end of asset ${inQueuPlayer}`);\n      if (!inQueuPlayer) {\n        return;\n      }\n      // Preload at end of asset\n      const scheduleIndex = this.schedule.findEventIndex(interstitial.identifier);\n      const item = (_this$schedule$items2 = this.schedule.items) == null ? void 0 : _this$schedule$items2[scheduleIndex];\n      if (this.isInterstitial(item)) {\n        const assetListIndex = interstitial.findAssetIndex(assetItem);\n        const nextAssetIndex = getNextAssetIndex(interstitial, assetListIndex);\n        if (!interstitial.isAssetPastPlayoutLimit(nextAssetIndex)) {\n          this.bufferedToItem(item, nextAssetIndex);\n        } else {\n          var _this$schedule$items3;\n          const nextItem = (_this$schedule$items3 = this.schedule.items) == null ? void 0 : _this$schedule$items3[scheduleIndex + 1];\n          if (nextItem) {\n            this.bufferedToItem(nextItem);\n          }\n        }\n      }\n    };\n    player.on(Events.BUFFERED_TO_END, bufferedToEnd);\n    const endedWithAssetIndex = assetIndex => {\n      return () => {\n        const inQueuPlayer = this.getAssetPlayer(assetId);\n        if (!inQueuPlayer) {\n          return;\n        }\n        this.shouldPlay = true;\n        const scheduleIndex = this.schedule.findEventIndex(interstitial.identifier);\n        this.advanceAfterAssetEnded(interstitial, scheduleIndex, assetIndex);\n      };\n    };\n    player.once(Events.MEDIA_ENDED, endedWithAssetIndex(assetListIndex));\n    player.once(Events.PLAYOUT_LIMIT_REACHED, endedWithAssetIndex(Infinity));\n    player.on(Events.ERROR, (event, data) => {\n      const inQueuPlayer = this.getAssetPlayer(assetId);\n      if (data.details === ErrorDetails.BUFFER_STALLED_ERROR) {\n        if (inQueuPlayer != null && inQueuPlayer.media) {\n          const assetCurrentTime = inQueuPlayer.currentTime;\n          const distanceFromEnd = inQueuPlayer.duration - assetCurrentTime;\n          if (assetCurrentTime && interstitial.appendInPlace && distanceFromEnd / inQueuPlayer.media.playbackRate < 0.5) {\n            this.log(`Advancing buffer past end of asset ${assetId} ${interstitial} at ${inQueuPlayer.media.currentTime}`);\n            bufferedToEnd();\n          } else {\n            this.warn(`Stalled at ${assetCurrentTime} of ${assetCurrentTime + distanceFromEnd} in asset ${assetId} ${interstitial}`);\n            this.onTimeupdate();\n            this.checkBuffer(true);\n          }\n        }\n        return;\n      }\n      this.handleAssetItemError(data, interstitial, this.schedule.findEventIndex(interstitial.identifier), assetListIndex, `Asset player error ${data.error} ${interstitial}`);\n    });\n    player.on(Events.DESTROYING, () => {\n      const inQueuPlayer = this.getAssetPlayer(assetId);\n      if (!inQueuPlayer) {\n        return;\n      }\n      const error = new Error(`Asset player destroyed unexpectedly ${assetId}`);\n      const errorData = {\n        fatal: true,\n        type: ErrorTypes.OTHER_ERROR,\n        details: ErrorDetails.INTERSTITIAL_ASSET_ITEM_ERROR,\n        error\n      };\n      this.handleAssetItemError(errorData, interstitial, this.schedule.findEventIndex(interstitial.identifier), assetListIndex, error.message);\n    });\n    this.log(`INTERSTITIAL_ASSET_PLAYER_CREATED ${eventAssetToString(assetItem)}`);\n    this.hls.trigger(Events.INTERSTITIAL_ASSET_PLAYER_CREATED, {\n      asset: assetItem,\n      assetListIndex,\n      event: interstitial,\n      player\n    });\n    return player;\n  }\n  clearInterstitial(interstitial, toSegment) {\n    interstitial.assetList.forEach(asset => {\n      this.clearAssetPlayer(asset.identifier, toSegment);\n    });\n    // Remove asset list and resolved duration\n    interstitial.reset();\n  }\n  resetAssetPlayer(assetId) {\n    // Reset asset player so that it's timeline can be adjusted without reloading the MVP\n    const playerIndex = this.getAssetPlayerQueueIndex(assetId);\n    if (playerIndex !== -1) {\n      this.log(`reset asset player \"${assetId}\" after error`);\n      const player = this.playerQueue[playerIndex];\n      this.transferMediaFromPlayer(player, null);\n      player.resetDetails();\n    }\n  }\n  clearAssetPlayer(assetId, toSegment) {\n    const playerIndex = this.getAssetPlayerQueueIndex(assetId);\n    if (playerIndex !== -1) {\n      this.log(`clear asset player \"${assetId}\" toSegment: ${toSegment ? segmentToString(toSegment) : toSegment}`);\n      const player = this.playerQueue[playerIndex];\n      this.transferMediaFromPlayer(player, toSegment);\n      this.playerQueue.splice(playerIndex, 1);\n      player.destroy();\n    }\n  }\n  emptyPlayerQueue() {\n    let player;\n    while (player = this.playerQueue.pop()) {\n      player.destroy();\n    }\n    this.playerQueue = [];\n  }\n  startAssetPlayer(player, assetListIndex, scheduleItems, scheduleIndex, media) {\n    const {\n      interstitial,\n      assetItem,\n      assetId\n    } = player;\n    const assetListLength = interstitial.assetList.length;\n    const playingAsset = this.playingAsset;\n    this.endedAsset = null;\n    this.playingAsset = assetItem;\n    if (!playingAsset || playingAsset.identifier !== assetId) {\n      if (playingAsset) {\n        // Exiting another Interstitial asset\n        this.clearAssetPlayer(playingAsset.identifier, scheduleItems[scheduleIndex]);\n        delete playingAsset.error;\n      }\n      this.log(`INTERSTITIAL_ASSET_STARTED ${assetListIndex + 1}/${assetListLength} ${eventAssetToString(assetItem)}`);\n      this.hls.trigger(Events.INTERSTITIAL_ASSET_STARTED, {\n        asset: assetItem,\n        assetListIndex,\n        event: interstitial,\n        schedule: scheduleItems.slice(0),\n        scheduleIndex,\n        player\n      });\n    }\n\n    // detach media and attach to interstitial player if it does not have another element attached\n    this.bufferAssetPlayer(player, media);\n  }\n  bufferAssetPlayer(player, media) {\n    var _this$schedule$items4, _this$detachedData5;\n    const {\n      interstitial,\n      assetItem\n    } = player;\n    const scheduleIndex = this.schedule.findEventIndex(interstitial.identifier);\n    const item = (_this$schedule$items4 = this.schedule.items) == null ? void 0 : _this$schedule$items4[scheduleIndex];\n    if (!item) {\n      return;\n    }\n    this.setBufferingItem(item);\n    this.bufferingAsset = assetItem;\n    const bufferingPlayer = this.getBufferingPlayer();\n    if (bufferingPlayer === player) {\n      return;\n    }\n    const appendInPlaceNext = interstitial.appendInPlace;\n    if (appendInPlaceNext && (bufferingPlayer == null ? void 0 : bufferingPlayer.interstitial.appendInPlace) === false) {\n      // Media is detached and not available to append in place\n      return;\n    }\n    const activeTracks = (bufferingPlayer == null ? void 0 : bufferingPlayer.tracks) || ((_this$detachedData5 = this.detachedData) == null ? void 0 : _this$detachedData5.tracks) || this.requiredTracks;\n    if (appendInPlaceNext && assetItem !== this.playingAsset) {\n      // Do not buffer another item if tracks are unknown or incompatible\n      if (!player.tracks) {\n        return;\n      }\n      if (activeTracks && !isCompatibleTrackChange(activeTracks, player.tracks)) {\n        const error = new Error(`Asset ${eventAssetToString(assetItem)} SourceBuffer tracks ('${Object.keys(player.tracks)}') are not compatible with primary content tracks ('${Object.keys(activeTracks)}')`);\n        const errorData = {\n          fatal: true,\n          type: ErrorTypes.OTHER_ERROR,\n          details: ErrorDetails.INTERSTITIAL_ASSET_ITEM_ERROR,\n          error\n        };\n        const assetListIndex = interstitial.findAssetIndex(assetItem);\n        this.handleAssetItemError(errorData, interstitial, scheduleIndex, assetListIndex, error.message);\n        return;\n      }\n    }\n    this.transferMediaTo(player, media);\n  }\n  handleAssetItemError(data, interstitial, scheduleIndex, assetListIndex, errorMessage) {\n    if (data.details === ErrorDetails.BUFFER_STALLED_ERROR) {\n      return;\n    }\n    const assetItem = interstitial.assetList[assetListIndex];\n    this.warn(`INTERSTITIAL_ASSET_ERROR ${assetItem ? eventAssetToString(assetItem) : assetItem} ${data.error}`);\n    const assetId = assetItem == null ? void 0 : assetItem.identifier;\n    const playerIndex = this.getAssetPlayerQueueIndex(assetId);\n    const player = this.playerQueue[playerIndex] || null;\n    const items = this.schedule.items;\n    const interstitialAssetError = _extends({}, data, {\n      fatal: false,\n      errorAction: createDoNothingErrorAction(true),\n      asset: assetItem,\n      assetListIndex,\n      event: interstitial,\n      schedule: items,\n      scheduleIndex,\n      player\n    });\n    this.hls.trigger(Events.INTERSTITIAL_ASSET_ERROR, interstitialAssetError);\n    if (!data.fatal) {\n      return;\n    }\n    const playingAsset = this.playingAsset;\n    const error = new Error(errorMessage);\n    if (assetItem) {\n      this.clearAssetPlayer(assetId, null);\n      assetItem.error = error;\n    }\n\n    // If all assets in interstitial fail, mark the interstitial with an error\n    if (!interstitial.assetList.some(asset => !asset.error)) {\n      interstitial.error = error;\n    } else {\n      // Reset level details and reload/parse media playlists to align with updated schedule\n      for (let i = assetListIndex; i < interstitial.assetList.length; i++) {\n        this.resetAssetPlayer(interstitial.assetList[i].identifier);\n      }\n      this.updateSchedule();\n    }\n    if (interstitial.error) {\n      this.primaryFallback(interstitial);\n    } else if (playingAsset && playingAsset.identifier === assetId) {\n      this.advanceAfterAssetEnded(interstitial, scheduleIndex, assetListIndex);\n    }\n  }\n  primaryFallback(interstitial) {\n    // Fallback to Primary by on current or future events by updating schedule to skip errored interstitials/assets\n    const flushStart = interstitial.timelineStart;\n    const playingItem = this.effectivePlayingItem;\n    // Update schedule now that interstitial/assets are flagged with `error` for fallback\n    this.updateSchedule();\n    if (playingItem) {\n      this.log(`Fallback to primary from event \"${interstitial.identifier}\" start: ${flushStart} pos: ${this.timelinePos} playing: ${playingItem ? segmentToString(playingItem) : '<none>'} error: ${interstitial.error}`);\n      let timelinePos = this.timelinePos;\n      if (timelinePos === -1) {\n        timelinePos = this.hls.startPosition;\n      }\n      const newPlayingItem = this.updateItem(playingItem, timelinePos);\n      if (this.itemsMatch(playingItem, newPlayingItem)) {\n        this.clearInterstitial(interstitial, null);\n      }\n      if (interstitial.appendInPlace) {\n        this.attachPrimary(flushStart, null);\n        this.flushFrontBuffer(flushStart);\n      }\n      const scheduleIndex = this.schedule.findItemIndexAtTime(timelinePos);\n      this.setSchedulePosition(scheduleIndex);\n    } else {\n      this.checkStart();\n    }\n  }\n\n  // Asset List loading\n  onAssetListLoaded(event, data) {\n    var _this$bufferingItem2;\n    const interstitial = data.event;\n    const interstitialId = interstitial.identifier;\n    const assets = data.assetListResponse.ASSETS;\n    if (!this.schedule.hasEvent(interstitialId)) {\n      // Interstitial with id was removed\n      return;\n    }\n    const eventStart = interstitial.timelineStart;\n    const previousDuration = interstitial.duration;\n    let sumDuration = 0;\n    assets.forEach((asset, assetListIndex) => {\n      const duration = parseFloat(asset.DURATION);\n      this.createAsset(interstitial, assetListIndex, sumDuration, eventStart + sumDuration, duration, asset.URI);\n      sumDuration += duration;\n    });\n    interstitial.duration = sumDuration;\n    this.log(`Loaded asset-list with duration: ${sumDuration} (was: ${previousDuration}) ${interstitial}`);\n    const waitingItem = this.waitingItem;\n    const waitingForItem = (waitingItem == null ? void 0 : waitingItem.event.identifier) === interstitialId;\n\n    // Update schedule now that asset.DURATION(s) are parsed\n    this.updateSchedule();\n    const bufferingEvent = (_this$bufferingItem2 = this.bufferingItem) == null ? void 0 : _this$bufferingItem2.event;\n\n    // If buffer reached Interstitial, start buffering first asset\n    if (waitingForItem) {\n      var _this$schedule$items5;\n      // Advance schedule when waiting for asset list data to play\n      const scheduleIndex = this.schedule.findEventIndex(interstitialId);\n      const item = (_this$schedule$items5 = this.schedule.items) == null ? void 0 : _this$schedule$items5[scheduleIndex];\n      if (item) {\n        if (!this.playingItem && this.timelinePos > item.end) {\n          // Abandon if new duration is reduced enough to land playback in primary start\n          const index = this.schedule.findItemIndexAtTime(this.timelinePos);\n          if (index !== scheduleIndex) {\n            interstitial.error = new Error(`Interstitial no longer within playback range ${this.timelinePos} ${interstitial}`);\n            this.primaryFallback(interstitial);\n            return;\n          }\n        }\n        this.setBufferingItem(item);\n      }\n      this.setSchedulePosition(scheduleIndex);\n    } else if ((bufferingEvent == null ? void 0 : bufferingEvent.identifier) === interstitialId && bufferingEvent.appendInPlace) {\n      // If buffering (but not playback) has reached this item transfer media-source\n      const assetItem = interstitial.assetList[0];\n      const player = this.getAssetPlayer(assetItem.identifier);\n      const media = this.primaryMedia;\n      if (assetItem && player && media) {\n        this.bufferAssetPlayer(player, media);\n      }\n    }\n  }\n  onError(event, data) {\n    switch (data.details) {\n      case ErrorDetails.ASSET_LIST_PARSING_ERROR:\n      case ErrorDetails.ASSET_LIST_LOAD_ERROR:\n      case ErrorDetails.ASSET_LIST_LOAD_TIMEOUT:\n        {\n          const interstitial = data.interstitial;\n          if (interstitial) {\n            this.primaryFallback(interstitial);\n          }\n          break;\n        }\n      case ErrorDetails.BUFFER_STALLED_ERROR:\n        {\n          this.onTimeupdate();\n          this.checkBuffer(true);\n          break;\n        }\n    }\n  }\n}\n\nconst TICK_INTERVAL$2 = 500; // how often to tick in ms\n\nclass SubtitleStreamController extends BaseStreamController {\n  constructor(hls, fragmentTracker, keyLoader) {\n    super(hls, fragmentTracker, keyLoader, 'subtitle-stream-controller', PlaylistLevelType.SUBTITLE);\n    this.currentTrackId = -1;\n    this.tracksBuffered = [];\n    this.mainDetails = null;\n    this.registerListeners();\n  }\n  onHandlerDestroying() {\n    this.unregisterListeners();\n    super.onHandlerDestroying();\n    this.mainDetails = null;\n  }\n  registerListeners() {\n    super.registerListeners();\n    const {\n      hls\n    } = this;\n    hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n    hls.on(Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);\n    hls.on(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n    hls.on(Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);\n    hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n  }\n  unregisterListeners() {\n    super.unregisterListeners();\n    const {\n      hls\n    } = this;\n    hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n    hls.off(Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);\n    hls.off(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n    hls.off(Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);\n    hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n  }\n  startLoad(startPosition, skipSeekToStartPosition) {\n    this.stopLoad();\n    this.state = State.IDLE;\n    this.setInterval(TICK_INTERVAL$2);\n    this.nextLoadPosition = this.lastCurrentTime = startPosition + this.timelineOffset;\n    this.startPosition = skipSeekToStartPosition ? -1 : startPosition;\n    this.tick();\n  }\n  onManifestLoading() {\n    super.onManifestLoading();\n    this.mainDetails = null;\n  }\n  onMediaDetaching(event, data) {\n    this.tracksBuffered = [];\n    super.onMediaDetaching(event, data);\n  }\n  onLevelLoaded(event, data) {\n    this.mainDetails = data.details;\n  }\n  onSubtitleFragProcessed(event, data) {\n    const {\n      frag,\n      success\n    } = data;\n    if (!this.fragContextChanged(frag)) {\n      if (isMediaFragment(frag)) {\n        this.fragPrevious = frag;\n      }\n      this.state = State.IDLE;\n    }\n    if (!success) {\n      return;\n    }\n    const buffered = this.tracksBuffered[this.currentTrackId];\n    if (!buffered) {\n      return;\n    }\n\n    // Create/update a buffered array matching the interface used by BufferHelper.bufferedInfo\n    // so we can re-use the logic used to detect how much has been buffered\n    let timeRange;\n    const fragStart = frag.start;\n    for (let i = 0; i < buffered.length; i++) {\n      if (fragStart >= buffered[i].start && fragStart <= buffered[i].end) {\n        timeRange = buffered[i];\n        break;\n      }\n    }\n    const fragEnd = frag.start + frag.duration;\n    if (timeRange) {\n      timeRange.end = fragEnd;\n    } else {\n      timeRange = {\n        start: fragStart,\n        end: fragEnd\n      };\n      buffered.push(timeRange);\n    }\n    this.fragmentTracker.fragBuffered(frag);\n    this.fragBufferedComplete(frag, null);\n    if (this.media) {\n      this.tick();\n    }\n  }\n  onBufferFlushing(event, data) {\n    const {\n      startOffset,\n      endOffset\n    } = data;\n    if (startOffset === 0 && endOffset !== Number.POSITIVE_INFINITY) {\n      const endOffsetSubtitles = endOffset - 1;\n      if (endOffsetSubtitles <= 0) {\n        return;\n      }\n      data.endOffsetSubtitles = Math.max(0, endOffsetSubtitles);\n      this.tracksBuffered.forEach(buffered => {\n        for (let i = 0; i < buffered.length;) {\n          if (buffered[i].end <= endOffsetSubtitles) {\n            buffered.shift();\n            continue;\n          } else if (buffered[i].start < endOffsetSubtitles) {\n            buffered[i].start = endOffsetSubtitles;\n          } else {\n            break;\n          }\n          i++;\n        }\n      });\n      this.fragmentTracker.removeFragmentsInRange(startOffset, endOffsetSubtitles, PlaylistLevelType.SUBTITLE);\n    }\n  }\n\n  // If something goes wrong, proceed to next frag, if we were processing one.\n  onError(event, data) {\n    const frag = data.frag;\n    if ((frag == null ? void 0 : frag.type) === PlaylistLevelType.SUBTITLE) {\n      if (data.details === ErrorDetails.FRAG_GAP) {\n        this.fragmentTracker.fragBuffered(frag, true);\n      }\n      if (this.fragCurrent) {\n        this.fragCurrent.abortRequests();\n      }\n      if (this.state !== State.STOPPED) {\n        this.state = State.IDLE;\n      }\n    }\n  }\n\n  // Got all new subtitle levels.\n  onSubtitleTracksUpdated(event, {\n    subtitleTracks\n  }) {\n    if (this.levels && subtitleOptionsIdentical(this.levels, subtitleTracks)) {\n      this.levels = subtitleTracks.map(mediaPlaylist => new Level(mediaPlaylist));\n      return;\n    }\n    this.tracksBuffered = [];\n    this.levels = subtitleTracks.map(mediaPlaylist => {\n      const level = new Level(mediaPlaylist);\n      this.tracksBuffered[level.id] = [];\n      return level;\n    });\n    this.fragmentTracker.removeFragmentsInRange(0, Number.POSITIVE_INFINITY, PlaylistLevelType.SUBTITLE);\n    this.fragPrevious = null;\n    this.mediaBuffer = null;\n  }\n  onSubtitleTrackSwitch(event, data) {\n    var _this$levels;\n    this.currentTrackId = data.id;\n    if (!((_this$levels = this.levels) != null && _this$levels.length) || this.currentTrackId === -1) {\n      this.clearInterval();\n      return;\n    }\n\n    // Check if track has the necessary details to load fragments\n    const currentTrack = this.levels[this.currentTrackId];\n    if (currentTrack != null && currentTrack.details) {\n      this.mediaBuffer = this.mediaBufferTimeRanges;\n    } else {\n      this.mediaBuffer = null;\n    }\n    if (currentTrack && this.state !== State.STOPPED) {\n      this.setInterval(TICK_INTERVAL$2);\n    }\n  }\n\n  // Got a new set of subtitle fragments.\n  onSubtitleTrackLoaded(event, data) {\n    var _track$details;\n    const {\n      currentTrackId,\n      levels\n    } = this;\n    const {\n      details: newDetails,\n      id: trackId\n    } = data;\n    if (!levels) {\n      this.warn(`Subtitle tracks were reset while loading level ${trackId}`);\n      return;\n    }\n    const track = levels[trackId];\n    if (trackId >= levels.length || !track) {\n      return;\n    }\n    this.log(`Subtitle track ${trackId} loaded [${newDetails.startSN},${newDetails.endSN}]${newDetails.lastPartSn ? `[part-${newDetails.lastPartSn}-${newDetails.lastPartIndex}]` : ''},duration:${newDetails.totalduration}`);\n    this.mediaBuffer = this.mediaBufferTimeRanges;\n    let sliding = 0;\n    if (newDetails.live || (_track$details = track.details) != null && _track$details.live) {\n      if (newDetails.deltaUpdateFailed) {\n        return;\n      }\n      const mainDetails = this.mainDetails;\n      if (!mainDetails) {\n        this.startFragRequested = false;\n        return;\n      }\n      const mainSlidingStartFragment = mainDetails.fragments[0];\n      if (!track.details) {\n        if (newDetails.hasProgramDateTime && mainDetails.hasProgramDateTime) {\n          alignMediaPlaylistByPDT(newDetails, mainDetails);\n          sliding = newDetails.fragmentStart;\n        } else if (mainSlidingStartFragment) {\n          // line up live playlist with main so that fragments in range are loaded\n          sliding = mainSlidingStartFragment.start;\n          addSliding(newDetails, sliding);\n        }\n      } else {\n        var _this$levelLastLoaded;\n        sliding = this.alignPlaylists(newDetails, track.details, (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details);\n        if (sliding === 0 && mainSlidingStartFragment) {\n          // realign with main when there is no overlap with last refresh\n          sliding = mainSlidingStartFragment.start;\n          addSliding(newDetails, sliding);\n        }\n      }\n      // compute start position if we are aligned with the main playlist\n      if (mainDetails && !this.startFragRequested) {\n        this.setStartPosition(mainDetails, sliding);\n      }\n    }\n    track.details = newDetails;\n    this.levelLastLoaded = track;\n    if (trackId !== currentTrackId) {\n      return;\n    }\n    this.hls.trigger(Events.SUBTITLE_TRACK_UPDATED, {\n      details: newDetails,\n      id: trackId,\n      groupId: data.groupId\n    });\n\n    // trigger handler right now\n    this.tick();\n\n    // If playlist is misaligned because of bad PDT or drift, delete details to resync with main on reload\n    if (newDetails.live && !this.fragCurrent && this.media && this.state === State.IDLE) {\n      const foundFrag = findFragmentByPTS(null, newDetails.fragments, this.media.currentTime, 0);\n      if (!foundFrag) {\n        this.warn('Subtitle playlist not aligned with playback');\n        track.details = undefined;\n      }\n    }\n  }\n  _handleFragmentLoadComplete(fragLoadedData) {\n    const {\n      frag,\n      payload\n    } = fragLoadedData;\n    const decryptData = frag.decryptdata;\n    const hls = this.hls;\n    if (this.fragContextChanged(frag)) {\n      return;\n    }\n    // check to see if the payload needs to be decrypted\n    if (payload && payload.byteLength > 0 && decryptData != null && decryptData.key && decryptData.iv && isFullSegmentEncryption(decryptData.method)) {\n      const startTime = performance.now();\n      // decrypt the subtitles\n      this.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer, getAesModeFromFullSegmentMethod(decryptData.method)).catch(err => {\n        hls.trigger(Events.ERROR, {\n          type: ErrorTypes.MEDIA_ERROR,\n          details: ErrorDetails.FRAG_DECRYPT_ERROR,\n          fatal: false,\n          error: err,\n          reason: err.message,\n          frag\n        });\n        throw err;\n      }).then(decryptedData => {\n        const endTime = performance.now();\n        hls.trigger(Events.FRAG_DECRYPTED, {\n          frag,\n          payload: decryptedData,\n          stats: {\n            tstart: startTime,\n            tdecrypt: endTime\n          }\n        });\n      }).catch(err => {\n        this.warn(`${err.name}: ${err.message}`);\n        this.state = State.IDLE;\n      });\n    }\n  }\n  doTick() {\n    if (!this.media) {\n      this.state = State.IDLE;\n      return;\n    }\n    if (this.state === State.IDLE) {\n      const {\n        currentTrackId,\n        levels\n      } = this;\n      const track = levels == null ? void 0 : levels[currentTrackId];\n      if (!track || !levels.length || !track.details) {\n        return;\n      }\n      if (this.waitForLive(track)) {\n        return;\n      }\n      const {\n        config\n      } = this;\n      const currentTime = this.getLoadPosition();\n      const bufferedInfo = BufferHelper.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], currentTime, config.maxBufferHole);\n      const {\n        end: targetBufferTime,\n        len: bufferLen\n      } = bufferedInfo;\n      const trackDetails = track.details;\n      const maxBufLen = this.hls.maxBufferLength + trackDetails.levelTargetDuration;\n      if (bufferLen > maxBufLen) {\n        return;\n      }\n      const fragments = trackDetails.fragments;\n      const fragLen = fragments.length;\n      const end = trackDetails.edge;\n      let foundFrag = null;\n      const fragPrevious = this.fragPrevious;\n      if (targetBufferTime < end) {\n        const tolerance = config.maxFragLookUpTolerance;\n        const lookupTolerance = targetBufferTime > end - tolerance ? 0 : tolerance;\n        foundFrag = findFragmentByPTS(fragPrevious, fragments, Math.max(fragments[0].start, targetBufferTime), lookupTolerance);\n        if (!foundFrag && fragPrevious && fragPrevious.start < fragments[0].start) {\n          foundFrag = fragments[0];\n        }\n      } else {\n        foundFrag = fragments[fragLen - 1];\n      }\n      foundFrag = this.filterReplacedPrimary(foundFrag, track.details);\n      if (!foundFrag) {\n        return;\n      }\n      // Load earlier fragment in same discontinuity to make up for misaligned playlists and cues that extend beyond end of segment\n      const curSNIdx = foundFrag.sn - trackDetails.startSN;\n      const prevFrag = fragments[curSNIdx - 1];\n      if (prevFrag && prevFrag.cc === foundFrag.cc && this.fragmentTracker.getState(prevFrag) === FragmentState.NOT_LOADED) {\n        foundFrag = prevFrag;\n      }\n      if (this.fragmentTracker.getState(foundFrag) === FragmentState.NOT_LOADED) {\n        // only load if fragment is not loaded\n        const fragToLoad = this.mapToInitFragWhenRequired(foundFrag);\n        if (fragToLoad) {\n          this.loadFragment(fragToLoad, track, targetBufferTime);\n        }\n      }\n    }\n  }\n  loadFragment(frag, level, targetBufferTime) {\n    if (!isMediaFragment(frag)) {\n      this._loadInitSegment(frag, level);\n    } else {\n      super.loadFragment(frag, level, targetBufferTime);\n    }\n  }\n  get mediaBufferTimeRanges() {\n    return new BufferableInstance(this.tracksBuffered[this.currentTrackId] || []);\n  }\n}\nclass BufferableInstance {\n  constructor(timeranges) {\n    this.buffered = void 0;\n    const getRange = (name, index, length) => {\n      index = index >>> 0;\n      if (index > length - 1) {\n        throw new DOMException(`Failed to execute '${name}' on 'TimeRanges': The index provided (${index}) is greater than the maximum bound (${length})`);\n      }\n      return timeranges[index][name];\n    };\n    this.buffered = {\n      get length() {\n        return timeranges.length;\n      },\n      end(index) {\n        return getRange('end', index, timeranges.length);\n      },\n      start(index) {\n        return getRange('start', index, timeranges.length);\n      }\n    };\n  }\n}\n\n/**\n *\n * This code was ported from the dash.js project at:\n *   https://github.com/Dash-Industry-Forum/dash.js/blob/development/externals/cea608-parser.js\n *   https://github.com/Dash-Industry-Forum/dash.js/commit/8269b26a761e0853bb21d78780ed945144ecdd4d#diff-71bc295a2d6b6b7093a1d3290d53a4b2\n *\n * The original copyright appears below:\n *\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2015-2016, DASH Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  1. Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  2. Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n/**\n *  Exceptions from regular ASCII. CodePoints are mapped to UTF-16 codes\n */\n\nconst specialCea608CharsCodes = {\n  0x2a: 0xe1,\n  // lowercase a, acute accent\n  0x5c: 0xe9,\n  // lowercase e, acute accent\n  0x5e: 0xed,\n  // lowercase i, acute accent\n  0x5f: 0xf3,\n  // lowercase o, acute accent\n  0x60: 0xfa,\n  // lowercase u, acute accent\n  0x7b: 0xe7,\n  // lowercase c with cedilla\n  0x7c: 0xf7,\n  // division symbol\n  0x7d: 0xd1,\n  // uppercase N tilde\n  0x7e: 0xf1,\n  // lowercase n tilde\n  0x7f: 0x2588,\n  // Full block\n  // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n  // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F\n  // THIS MEANS THAT \\x50 MUST BE ADDED TO THE VALUES\n  0x80: 0xae,\n  // Registered symbol (R)\n  0x81: 0xb0,\n  // degree sign\n  0x82: 0xbd,\n  // 1/2 symbol\n  0x83: 0xbf,\n  // Inverted (open) question mark\n  0x84: 0x2122,\n  // Trademark symbol (TM)\n  0x85: 0xa2,\n  // Cents symbol\n  0x86: 0xa3,\n  // Pounds sterling\n  0x87: 0x266a,\n  // Music 8'th note\n  0x88: 0xe0,\n  // lowercase a, grave accent\n  0x89: 0x20,\n  // transparent space (regular)\n  0x8a: 0xe8,\n  // lowercase e, grave accent\n  0x8b: 0xe2,\n  // lowercase a, circumflex accent\n  0x8c: 0xea,\n  // lowercase e, circumflex accent\n  0x8d: 0xee,\n  // lowercase i, circumflex accent\n  0x8e: 0xf4,\n  // lowercase o, circumflex accent\n  0x8f: 0xfb,\n  // lowercase u, circumflex accent\n  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n  // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F\n  0x90: 0xc1,\n  // capital letter A with acute\n  0x91: 0xc9,\n  // capital letter E with acute\n  0x92: 0xd3,\n  // capital letter O with acute\n  0x93: 0xda,\n  // capital letter U with acute\n  0x94: 0xdc,\n  // capital letter U with diaresis\n  0x95: 0xfc,\n  // lowercase letter U with diaeresis\n  0x96: 0x2018,\n  // opening single quote\n  0x97: 0xa1,\n  // inverted exclamation mark\n  0x98: 0x2a,\n  // asterisk\n  0x99: 0x2019,\n  // closing single quote\n  0x9a: 0x2501,\n  // box drawings heavy horizontal\n  0x9b: 0xa9,\n  // copyright sign\n  0x9c: 0x2120,\n  // Service mark\n  0x9d: 0x2022,\n  // (round) bullet\n  0x9e: 0x201c,\n  // Left double quotation mark\n  0x9f: 0x201d,\n  // Right double quotation mark\n  0xa0: 0xc0,\n  // uppercase A, grave accent\n  0xa1: 0xc2,\n  // uppercase A, circumflex\n  0xa2: 0xc7,\n  // uppercase C with cedilla\n  0xa3: 0xc8,\n  // uppercase E, grave accent\n  0xa4: 0xca,\n  // uppercase E, circumflex\n  0xa5: 0xcb,\n  // capital letter E with diaresis\n  0xa6: 0xeb,\n  // lowercase letter e with diaresis\n  0xa7: 0xce,\n  // uppercase I, circumflex\n  0xa8: 0xcf,\n  // uppercase I, with diaresis\n  0xa9: 0xef,\n  // lowercase i, with diaresis\n  0xaa: 0xd4,\n  // uppercase O, circumflex\n  0xab: 0xd9,\n  // uppercase U, grave accent\n  0xac: 0xf9,\n  // lowercase u, grave accent\n  0xad: 0xdb,\n  // uppercase U, circumflex\n  0xae: 0xab,\n  // left-pointing double angle quotation mark\n  0xaf: 0xbb,\n  // right-pointing double angle quotation mark\n  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n  // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F\n  0xb0: 0xc3,\n  // Uppercase A, tilde\n  0xb1: 0xe3,\n  // Lowercase a, tilde\n  0xb2: 0xcd,\n  // Uppercase I, acute accent\n  0xb3: 0xcc,\n  // Uppercase I, grave accent\n  0xb4: 0xec,\n  // Lowercase i, grave accent\n  0xb5: 0xd2,\n  // Uppercase O, grave accent\n  0xb6: 0xf2,\n  // Lowercase o, grave accent\n  0xb7: 0xd5,\n  // Uppercase O, tilde\n  0xb8: 0xf5,\n  // Lowercase o, tilde\n  0xb9: 0x7b,\n  // Open curly brace\n  0xba: 0x7d,\n  // Closing curly brace\n  0xbb: 0x5c,\n  // Backslash\n  0xbc: 0x5e,\n  // Caret\n  0xbd: 0x5f,\n  // Underscore\n  0xbe: 0x7c,\n  // Pipe (vertical line)\n  0xbf: 0x223c,\n  // Tilde operator\n  0xc0: 0xc4,\n  // Uppercase A, umlaut\n  0xc1: 0xe4,\n  // Lowercase A, umlaut\n  0xc2: 0xd6,\n  // Uppercase O, umlaut\n  0xc3: 0xf6,\n  // Lowercase o, umlaut\n  0xc4: 0xdf,\n  // Esszett (sharp S)\n  0xc5: 0xa5,\n  // Yen symbol\n  0xc6: 0xa4,\n  // Generic currency sign\n  0xc7: 0x2503,\n  // Box drawings heavy vertical\n  0xc8: 0xc5,\n  // Uppercase A, ring\n  0xc9: 0xe5,\n  // Lowercase A, ring\n  0xca: 0xd8,\n  // Uppercase O, stroke\n  0xcb: 0xf8,\n  // Lowercase o, strok\n  0xcc: 0x250f,\n  // Box drawings heavy down and right\n  0xcd: 0x2513,\n  // Box drawings heavy down and left\n  0xce: 0x2517,\n  // Box drawings heavy up and right\n  0xcf: 0x251b // Box drawings heavy up and left\n};\n\n/**\n * Utils\n */\nconst getCharForByte = byte => String.fromCharCode(specialCea608CharsCodes[byte] || byte);\nconst NR_ROWS = 15;\nconst NR_COLS = 100;\n// Tables to look up row from PAC data\nconst rowsLowCh1 = {\n  0x11: 1,\n  0x12: 3,\n  0x15: 5,\n  0x16: 7,\n  0x17: 9,\n  0x10: 11,\n  0x13: 12,\n  0x14: 14\n};\nconst rowsHighCh1 = {\n  0x11: 2,\n  0x12: 4,\n  0x15: 6,\n  0x16: 8,\n  0x17: 10,\n  0x13: 13,\n  0x14: 15\n};\nconst rowsLowCh2 = {\n  0x19: 1,\n  0x1a: 3,\n  0x1d: 5,\n  0x1e: 7,\n  0x1f: 9,\n  0x18: 11,\n  0x1b: 12,\n  0x1c: 14\n};\nconst rowsHighCh2 = {\n  0x19: 2,\n  0x1a: 4,\n  0x1d: 6,\n  0x1e: 8,\n  0x1f: 10,\n  0x1b: 13,\n  0x1c: 15\n};\nconst backgroundColors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'black', 'transparent'];\nclass CaptionsLogger {\n  constructor() {\n    this.time = null;\n    this.verboseLevel = 0;\n  }\n  log(severity, msg) {\n    if (this.verboseLevel >= severity) {\n      const m = typeof msg === 'function' ? msg() : msg;\n      logger.log(`${this.time} [${severity}] ${m}`);\n    }\n  }\n}\nconst numArrayToHexArray = function numArrayToHexArray(numArray) {\n  const hexArray = [];\n  for (let j = 0; j < numArray.length; j++) {\n    hexArray.push(numArray[j].toString(16));\n  }\n  return hexArray;\n};\nclass PenState {\n  constructor() {\n    this.foreground = 'white';\n    this.underline = false;\n    this.italics = false;\n    this.background = 'black';\n    this.flash = false;\n  }\n  reset() {\n    this.foreground = 'white';\n    this.underline = false;\n    this.italics = false;\n    this.background = 'black';\n    this.flash = false;\n  }\n  setStyles(styles) {\n    const attribs = ['foreground', 'underline', 'italics', 'background', 'flash'];\n    for (let i = 0; i < attribs.length; i++) {\n      const style = attribs[i];\n      if (styles.hasOwnProperty(style)) {\n        this[style] = styles[style];\n      }\n    }\n  }\n  isDefault() {\n    return this.foreground === 'white' && !this.underline && !this.italics && this.background === 'black' && !this.flash;\n  }\n  equals(other) {\n    return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;\n  }\n  copy(newPenState) {\n    this.foreground = newPenState.foreground;\n    this.underline = newPenState.underline;\n    this.italics = newPenState.italics;\n    this.background = newPenState.background;\n    this.flash = newPenState.flash;\n  }\n  toString() {\n    return 'color=' + this.foreground + ', underline=' + this.underline + ', italics=' + this.italics + ', background=' + this.background + ', flash=' + this.flash;\n  }\n}\n\n/**\n * Unicode character with styling and background.\n * @constructor\n */\nclass StyledUnicodeChar {\n  constructor() {\n    this.uchar = ' ';\n    this.penState = new PenState();\n  }\n  reset() {\n    this.uchar = ' ';\n    this.penState.reset();\n  }\n  setChar(uchar, newPenState) {\n    this.uchar = uchar;\n    this.penState.copy(newPenState);\n  }\n  setPenState(newPenState) {\n    this.penState.copy(newPenState);\n  }\n  equals(other) {\n    return this.uchar === other.uchar && this.penState.equals(other.penState);\n  }\n  copy(newChar) {\n    this.uchar = newChar.uchar;\n    this.penState.copy(newChar.penState);\n  }\n  isEmpty() {\n    return this.uchar === ' ' && this.penState.isDefault();\n  }\n}\n\n/**\n * CEA-608 row consisting of NR_COLS instances of StyledUnicodeChar.\n * @constructor\n */\nclass Row {\n  constructor(logger) {\n    this.chars = [];\n    this.pos = 0;\n    this.currPenState = new PenState();\n    this.cueStartTime = null;\n    this.logger = void 0;\n    for (let i = 0; i < NR_COLS; i++) {\n      this.chars.push(new StyledUnicodeChar());\n    }\n    this.logger = logger;\n  }\n  equals(other) {\n    for (let i = 0; i < NR_COLS; i++) {\n      if (!this.chars[i].equals(other.chars[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  copy(other) {\n    for (let i = 0; i < NR_COLS; i++) {\n      this.chars[i].copy(other.chars[i]);\n    }\n  }\n  isEmpty() {\n    let empty = true;\n    for (let i = 0; i < NR_COLS; i++) {\n      if (!this.chars[i].isEmpty()) {\n        empty = false;\n        break;\n      }\n    }\n    return empty;\n  }\n\n  /**\n   *  Set the cursor to a valid column.\n   */\n  setCursor(absPos) {\n    if (this.pos !== absPos) {\n      this.pos = absPos;\n    }\n    if (this.pos < 0) {\n      this.logger.log(3, 'Negative cursor position ' + this.pos);\n      this.pos = 0;\n    } else if (this.pos > NR_COLS) {\n      this.logger.log(3, 'Too large cursor position ' + this.pos);\n      this.pos = NR_COLS;\n    }\n  }\n\n  /**\n   * Move the cursor relative to current position.\n   */\n  moveCursor(relPos) {\n    const newPos = this.pos + relPos;\n    if (relPos > 1) {\n      for (let i = this.pos + 1; i < newPos + 1; i++) {\n        this.chars[i].setPenState(this.currPenState);\n      }\n    }\n    this.setCursor(newPos);\n  }\n\n  /**\n   * Backspace, move one step back and clear character.\n   */\n  backSpace() {\n    this.moveCursor(-1);\n    this.chars[this.pos].setChar(' ', this.currPenState);\n  }\n  insertChar(byte) {\n    if (byte >= 0x90) {\n      // Extended char\n      this.backSpace();\n    }\n    const char = getCharForByte(byte);\n    if (this.pos >= NR_COLS) {\n      this.logger.log(0, () => 'Cannot insert ' + byte.toString(16) + ' (' + char + ') at position ' + this.pos + '. Skipping it!');\n      return;\n    }\n    this.chars[this.pos].setChar(char, this.currPenState);\n    this.moveCursor(1);\n  }\n  clearFromPos(startPos) {\n    let i;\n    for (i = startPos; i < NR_COLS; i++) {\n      this.chars[i].reset();\n    }\n  }\n  clear() {\n    this.clearFromPos(0);\n    this.pos = 0;\n    this.currPenState.reset();\n  }\n  clearToEndOfRow() {\n    this.clearFromPos(this.pos);\n  }\n  getTextString() {\n    const chars = [];\n    let empty = true;\n    for (let i = 0; i < NR_COLS; i++) {\n      const char = this.chars[i].uchar;\n      if (char !== ' ') {\n        empty = false;\n      }\n      chars.push(char);\n    }\n    if (empty) {\n      return '';\n    } else {\n      return chars.join('');\n    }\n  }\n  setPenStyles(styles) {\n    this.currPenState.setStyles(styles);\n    const currChar = this.chars[this.pos];\n    currChar.setPenState(this.currPenState);\n  }\n}\n\n/**\n * Keep a CEA-608 screen of 32x15 styled characters\n * @constructor\n */\nclass CaptionScreen {\n  constructor(logger) {\n    this.rows = [];\n    this.currRow = NR_ROWS - 1;\n    this.nrRollUpRows = null;\n    this.lastOutputScreen = null;\n    this.logger = void 0;\n    for (let i = 0; i < NR_ROWS; i++) {\n      this.rows.push(new Row(logger));\n    }\n    this.logger = logger;\n  }\n  reset() {\n    for (let i = 0; i < NR_ROWS; i++) {\n      this.rows[i].clear();\n    }\n    this.currRow = NR_ROWS - 1;\n  }\n  equals(other) {\n    let equal = true;\n    for (let i = 0; i < NR_ROWS; i++) {\n      if (!this.rows[i].equals(other.rows[i])) {\n        equal = false;\n        break;\n      }\n    }\n    return equal;\n  }\n  copy(other) {\n    for (let i = 0; i < NR_ROWS; i++) {\n      this.rows[i].copy(other.rows[i]);\n    }\n  }\n  isEmpty() {\n    let empty = true;\n    for (let i = 0; i < NR_ROWS; i++) {\n      if (!this.rows[i].isEmpty()) {\n        empty = false;\n        break;\n      }\n    }\n    return empty;\n  }\n  backSpace() {\n    const row = this.rows[this.currRow];\n    row.backSpace();\n  }\n  clearToEndOfRow() {\n    const row = this.rows[this.currRow];\n    row.clearToEndOfRow();\n  }\n\n  /**\n   * Insert a character (without styling) in the current row.\n   */\n  insertChar(char) {\n    const row = this.rows[this.currRow];\n    row.insertChar(char);\n  }\n  setPen(styles) {\n    const row = this.rows[this.currRow];\n    row.setPenStyles(styles);\n  }\n  moveCursor(relPos) {\n    const row = this.rows[this.currRow];\n    row.moveCursor(relPos);\n  }\n  setCursor(absPos) {\n    this.logger.log(2, 'setCursor: ' + absPos);\n    const row = this.rows[this.currRow];\n    row.setCursor(absPos);\n  }\n  setPAC(pacData) {\n    this.logger.log(2, () => 'pacData = ' + stringify(pacData));\n    let newRow = pacData.row - 1;\n    if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {\n      newRow = this.nrRollUpRows - 1;\n    }\n\n    // Make sure this only affects Roll-up Captions by checking this.nrRollUpRows\n    if (this.nrRollUpRows && this.currRow !== newRow) {\n      // clear all rows first\n      for (let i = 0; i < NR_ROWS; i++) {\n        this.rows[i].clear();\n      }\n\n      // Copy this.nrRollUpRows rows from lastOutputScreen and place it in the newRow location\n      // topRowIndex - the start of rows to copy (inclusive index)\n      const topRowIndex = this.currRow + 1 - this.nrRollUpRows;\n      // We only copy if the last position was already shown.\n      // We use the cueStartTime value to check this.\n      const lastOutputScreen = this.lastOutputScreen;\n      if (lastOutputScreen) {\n        const prevLineTime = lastOutputScreen.rows[topRowIndex].cueStartTime;\n        const time = this.logger.time;\n        if (prevLineTime !== null && time !== null && prevLineTime < time) {\n          for (let i = 0; i < this.nrRollUpRows; i++) {\n            this.rows[newRow - this.nrRollUpRows + i + 1].copy(lastOutputScreen.rows[topRowIndex + i]);\n          }\n        }\n      }\n    }\n    this.currRow = newRow;\n    const row = this.rows[this.currRow];\n    if (pacData.indent !== null) {\n      const indent = pacData.indent;\n      const prevPos = Math.max(indent - 1, 0);\n      row.setCursor(pacData.indent);\n      pacData.color = row.chars[prevPos].penState.foreground;\n    }\n    const styles = {\n      foreground: pacData.color,\n      underline: pacData.underline,\n      italics: pacData.italics,\n      background: 'black',\n      flash: false\n    };\n    this.setPen(styles);\n  }\n\n  /**\n   * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).\n   */\n  setBkgData(bkgData) {\n    this.logger.log(2, () => 'bkgData = ' + stringify(bkgData));\n    this.backSpace();\n    this.setPen(bkgData);\n    this.insertChar(0x20); // Space\n  }\n  setRollUpRows(nrRows) {\n    this.nrRollUpRows = nrRows;\n  }\n  rollUp() {\n    if (this.nrRollUpRows === null) {\n      this.logger.log(3, 'roll_up but nrRollUpRows not set yet');\n      return; // Not properly setup\n    }\n    this.logger.log(1, () => this.getDisplayText());\n    const topRowIndex = this.currRow + 1 - this.nrRollUpRows;\n    const topRow = this.rows.splice(topRowIndex, 1)[0];\n    topRow.clear();\n    this.rows.splice(this.currRow, 0, topRow);\n    this.logger.log(2, 'Rolling up');\n    // this.logger.log(VerboseLevel.TEXT, this.get_display_text())\n  }\n\n  /**\n   * Get all non-empty rows with as unicode text.\n   */\n  getDisplayText(asOneRow) {\n    asOneRow = asOneRow || false;\n    const displayText = [];\n    let text = '';\n    let rowNr = -1;\n    for (let i = 0; i < NR_ROWS; i++) {\n      const rowText = this.rows[i].getTextString();\n      if (rowText) {\n        rowNr = i + 1;\n        if (asOneRow) {\n          displayText.push('Row ' + rowNr + \": '\" + rowText + \"'\");\n        } else {\n          displayText.push(rowText.trim());\n        }\n      }\n    }\n    if (displayText.length > 0) {\n      if (asOneRow) {\n        text = '[' + displayText.join(' | ') + ']';\n      } else {\n        text = displayText.join('\\n');\n      }\n    }\n    return text;\n  }\n  getTextAndFormat() {\n    return this.rows;\n  }\n}\n\n// var modes = ['MODE_ROLL-UP', 'MODE_POP-ON', 'MODE_PAINT-ON', 'MODE_TEXT'];\n\nclass Cea608Channel {\n  constructor(channelNumber, outputFilter, logger) {\n    this.chNr = void 0;\n    this.outputFilter = void 0;\n    this.mode = void 0;\n    this.verbose = void 0;\n    this.displayedMemory = void 0;\n    this.nonDisplayedMemory = void 0;\n    this.lastOutputScreen = void 0;\n    this.currRollUpRow = void 0;\n    this.writeScreen = void 0;\n    this.cueStartTime = void 0;\n    this.logger = void 0;\n    this.chNr = channelNumber;\n    this.outputFilter = outputFilter;\n    this.mode = null;\n    this.verbose = 0;\n    this.displayedMemory = new CaptionScreen(logger);\n    this.nonDisplayedMemory = new CaptionScreen(logger);\n    this.lastOutputScreen = new CaptionScreen(logger);\n    this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];\n    this.writeScreen = this.displayedMemory;\n    this.mode = null;\n    this.cueStartTime = null; // Keeps track of where a cue started.\n    this.logger = logger;\n  }\n  reset() {\n    this.mode = null;\n    this.displayedMemory.reset();\n    this.nonDisplayedMemory.reset();\n    this.lastOutputScreen.reset();\n    this.outputFilter.reset();\n    this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];\n    this.writeScreen = this.displayedMemory;\n    this.mode = null;\n    this.cueStartTime = null;\n  }\n  getHandler() {\n    return this.outputFilter;\n  }\n  setHandler(newHandler) {\n    this.outputFilter = newHandler;\n  }\n  setPAC(pacData) {\n    this.writeScreen.setPAC(pacData);\n  }\n  setBkgData(bkgData) {\n    this.writeScreen.setBkgData(bkgData);\n  }\n  setMode(newMode) {\n    if (newMode === this.mode) {\n      return;\n    }\n    this.mode = newMode;\n    this.logger.log(2, () => 'MODE=' + newMode);\n    if (this.mode === 'MODE_POP-ON') {\n      this.writeScreen = this.nonDisplayedMemory;\n    } else {\n      this.writeScreen = this.displayedMemory;\n      this.writeScreen.reset();\n    }\n    if (this.mode !== 'MODE_ROLL-UP') {\n      this.displayedMemory.nrRollUpRows = null;\n      this.nonDisplayedMemory.nrRollUpRows = null;\n    }\n    this.mode = newMode;\n  }\n  insertChars(chars) {\n    for (let i = 0; i < chars.length; i++) {\n      this.writeScreen.insertChar(chars[i]);\n    }\n    const screen = this.writeScreen === this.displayedMemory ? 'DISP' : 'NON_DISP';\n    this.logger.log(2, () => screen + ': ' + this.writeScreen.getDisplayText(true));\n    if (this.mode === 'MODE_PAINT-ON' || this.mode === 'MODE_ROLL-UP') {\n      this.logger.log(1, () => 'DISPLAYED: ' + this.displayedMemory.getDisplayText(true));\n      this.outputDataUpdate();\n    }\n  }\n  ccRCL() {\n    // Resume Caption Loading (switch mode to Pop On)\n    this.logger.log(2, 'RCL - Resume Caption Loading');\n    this.setMode('MODE_POP-ON');\n  }\n  ccBS() {\n    // BackSpace\n    this.logger.log(2, 'BS - BackSpace');\n    if (this.mode === 'MODE_TEXT') {\n      return;\n    }\n    this.writeScreen.backSpace();\n    if (this.writeScreen === this.displayedMemory) {\n      this.outputDataUpdate();\n    }\n  }\n  ccAOF() {\n    // Reserved (formerly Alarm Off)\n  }\n  ccAON() {\n    // Reserved (formerly Alarm On)\n  }\n  ccDER() {\n    // Delete to End of Row\n    this.logger.log(2, 'DER- Delete to End of Row');\n    this.writeScreen.clearToEndOfRow();\n    this.outputDataUpdate();\n  }\n  ccRU(nrRows) {\n    // Roll-Up Captions-2,3,or 4 Rows\n    this.logger.log(2, 'RU(' + nrRows + ') - Roll Up');\n    this.writeScreen = this.displayedMemory;\n    this.setMode('MODE_ROLL-UP');\n    this.writeScreen.setRollUpRows(nrRows);\n  }\n  ccFON() {\n    // Flash On\n    this.logger.log(2, 'FON - Flash On');\n    this.writeScreen.setPen({\n      flash: true\n    });\n  }\n  ccRDC() {\n    // Resume Direct Captioning (switch mode to PaintOn)\n    this.logger.log(2, 'RDC - Resume Direct Captioning');\n    this.setMode('MODE_PAINT-ON');\n  }\n  ccTR() {\n    // Text Restart in text mode (not supported, however)\n    this.logger.log(2, 'TR');\n    this.setMode('MODE_TEXT');\n  }\n  ccRTD() {\n    // Resume Text Display in Text mode (not supported, however)\n    this.logger.log(2, 'RTD');\n    this.setMode('MODE_TEXT');\n  }\n  ccEDM() {\n    // Erase Displayed Memory\n    this.logger.log(2, 'EDM - Erase Displayed Memory');\n    this.displayedMemory.reset();\n    this.outputDataUpdate(true);\n  }\n  ccCR() {\n    // Carriage Return\n    this.logger.log(2, 'CR - Carriage Return');\n    this.writeScreen.rollUp();\n    this.outputDataUpdate(true);\n  }\n  ccENM() {\n    // Erase Non-Displayed Memory\n    this.logger.log(2, 'ENM - Erase Non-displayed Memory');\n    this.nonDisplayedMemory.reset();\n  }\n  ccEOC() {\n    // End of Caption (Flip Memories)\n    this.logger.log(2, 'EOC - End Of Caption');\n    if (this.mode === 'MODE_POP-ON') {\n      const tmp = this.displayedMemory;\n      this.displayedMemory = this.nonDisplayedMemory;\n      this.nonDisplayedMemory = tmp;\n      this.writeScreen = this.nonDisplayedMemory;\n      this.logger.log(1, () => 'DISP: ' + this.displayedMemory.getDisplayText());\n    }\n    this.outputDataUpdate(true);\n  }\n  ccTO(nrCols) {\n    // Tab Offset 1,2, or 3 columns\n    this.logger.log(2, 'TO(' + nrCols + ') - Tab Offset');\n    this.writeScreen.moveCursor(nrCols);\n  }\n  ccMIDROW(secondByte) {\n    // Parse MIDROW command\n    const styles = {\n      flash: false\n    };\n    styles.underline = secondByte % 2 === 1;\n    styles.italics = secondByte >= 0x2e;\n    if (!styles.italics) {\n      const colorIndex = Math.floor(secondByte / 2) - 0x10;\n      const colors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta'];\n      styles.foreground = colors[colorIndex];\n    } else {\n      styles.foreground = 'white';\n    }\n    this.logger.log(2, 'MIDROW: ' + stringify(styles));\n    this.writeScreen.setPen(styles);\n  }\n  outputDataUpdate(dispatch = false) {\n    const time = this.logger.time;\n    if (time === null) {\n      return;\n    }\n    if (this.outputFilter) {\n      if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {\n        // Start of a new cue\n        this.cueStartTime = time;\n      } else {\n        if (!this.displayedMemory.equals(this.lastOutputScreen)) {\n          this.outputFilter.newCue(this.cueStartTime, time, this.lastOutputScreen);\n          if (dispatch && this.outputFilter.dispatchCue) {\n            this.outputFilter.dispatchCue();\n          }\n          this.cueStartTime = this.displayedMemory.isEmpty() ? null : time;\n        }\n      }\n      this.lastOutputScreen.copy(this.displayedMemory);\n    }\n  }\n  cueSplitAtTime(t) {\n    if (this.outputFilter) {\n      if (!this.displayedMemory.isEmpty()) {\n        if (this.outputFilter.newCue) {\n          this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);\n        }\n        this.cueStartTime = t;\n      }\n    }\n  }\n}\n\n// Will be 1 or 2 when parsing captions\n\nclass Cea608Parser {\n  constructor(field, out1, out2) {\n    this.channels = void 0;\n    this.currentChannel = 0;\n    this.cmdHistory = createCmdHistory();\n    this.logger = void 0;\n    const logger = this.logger = new CaptionsLogger();\n    this.channels = [null, new Cea608Channel(field, out1, logger), new Cea608Channel(field + 1, out2, logger)];\n  }\n  getHandler(channel) {\n    return this.channels[channel].getHandler();\n  }\n  setHandler(channel, newHandler) {\n    this.channels[channel].setHandler(newHandler);\n  }\n\n  /**\n   * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.\n   */\n  addData(time, byteList) {\n    this.logger.time = time;\n    for (let i = 0; i < byteList.length; i += 2) {\n      const a = byteList[i] & 0x7f;\n      const b = byteList[i + 1] & 0x7f;\n      let cmdFound = false;\n      let charsFound = null;\n      if (a === 0 && b === 0) {\n        continue;\n      } else {\n        this.logger.log(3, () => '[' + numArrayToHexArray([byteList[i], byteList[i + 1]]) + '] -> (' + numArrayToHexArray([a, b]) + ')');\n      }\n      const cmdHistory = this.cmdHistory;\n      const isControlCode = a >= 0x10 && a <= 0x1f;\n      if (isControlCode) {\n        // Skip redundant control codes\n        if (hasCmdRepeated(a, b, cmdHistory)) {\n          setLastCmd(null, null, cmdHistory);\n          this.logger.log(3, () => 'Repeated command (' + numArrayToHexArray([a, b]) + ') is dropped');\n          continue;\n        }\n        setLastCmd(a, b, this.cmdHistory);\n        cmdFound = this.parseCmd(a, b);\n        if (!cmdFound) {\n          cmdFound = this.parseMidrow(a, b);\n        }\n        if (!cmdFound) {\n          cmdFound = this.parsePAC(a, b);\n        }\n        if (!cmdFound) {\n          cmdFound = this.parseBackgroundAttributes(a, b);\n        }\n      } else {\n        setLastCmd(null, null, cmdHistory);\n      }\n      if (!cmdFound) {\n        charsFound = this.parseChars(a, b);\n        if (charsFound) {\n          const currChNr = this.currentChannel;\n          if (currChNr && currChNr > 0) {\n            const channel = this.channels[currChNr];\n            channel.insertChars(charsFound);\n          } else {\n            this.logger.log(2, 'No channel found yet. TEXT-MODE?');\n          }\n        }\n      }\n      if (!cmdFound && !charsFound) {\n        this.logger.log(2, () => \"Couldn't parse cleaned data \" + numArrayToHexArray([a, b]) + ' orig: ' + numArrayToHexArray([byteList[i], byteList[i + 1]]));\n      }\n    }\n  }\n\n  /**\n   * Parse Command.\n   * @returns True if a command was found\n   */\n  parseCmd(a, b) {\n    const cond1 = (a === 0x14 || a === 0x1c || a === 0x15 || a === 0x1d) && b >= 0x20 && b <= 0x2f;\n    const cond2 = (a === 0x17 || a === 0x1f) && b >= 0x21 && b <= 0x23;\n    if (!(cond1 || cond2)) {\n      return false;\n    }\n    const chNr = a === 0x14 || a === 0x15 || a === 0x17 ? 1 : 2;\n    const channel = this.channels[chNr];\n    if (a === 0x14 || a === 0x15 || a === 0x1c || a === 0x1d) {\n      if (b === 0x20) {\n        channel.ccRCL();\n      } else if (b === 0x21) {\n        channel.ccBS();\n      } else if (b === 0x22) {\n        channel.ccAOF();\n      } else if (b === 0x23) {\n        channel.ccAON();\n      } else if (b === 0x24) {\n        channel.ccDER();\n      } else if (b === 0x25) {\n        channel.ccRU(2);\n      } else if (b === 0x26) {\n        channel.ccRU(3);\n      } else if (b === 0x27) {\n        channel.ccRU(4);\n      } else if (b === 0x28) {\n        channel.ccFON();\n      } else if (b === 0x29) {\n        channel.ccRDC();\n      } else if (b === 0x2a) {\n        channel.ccTR();\n      } else if (b === 0x2b) {\n        channel.ccRTD();\n      } else if (b === 0x2c) {\n        channel.ccEDM();\n      } else if (b === 0x2d) {\n        channel.ccCR();\n      } else if (b === 0x2e) {\n        channel.ccENM();\n      } else if (b === 0x2f) {\n        channel.ccEOC();\n      }\n    } else {\n      // a == 0x17 || a == 0x1F\n      channel.ccTO(b - 0x20);\n    }\n    this.currentChannel = chNr;\n    return true;\n  }\n\n  /**\n   * Parse midrow styling command\n   */\n  parseMidrow(a, b) {\n    let chNr = 0;\n    if ((a === 0x11 || a === 0x19) && b >= 0x20 && b <= 0x2f) {\n      if (a === 0x11) {\n        chNr = 1;\n      } else {\n        chNr = 2;\n      }\n      if (chNr !== this.currentChannel) {\n        this.logger.log(0, 'Mismatch channel in midrow parsing');\n        return false;\n      }\n      const channel = this.channels[chNr];\n      if (!channel) {\n        return false;\n      }\n      channel.ccMIDROW(b);\n      this.logger.log(3, () => 'MIDROW (' + numArrayToHexArray([a, b]) + ')');\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Parse Preable Access Codes (Table 53).\n   * @returns {Boolean} Tells if PAC found\n   */\n  parsePAC(a, b) {\n    let row;\n    const case1 = (a >= 0x11 && a <= 0x17 || a >= 0x19 && a <= 0x1f) && b >= 0x40 && b <= 0x7f;\n    const case2 = (a === 0x10 || a === 0x18) && b >= 0x40 && b <= 0x5f;\n    if (!(case1 || case2)) {\n      return false;\n    }\n    const chNr = a <= 0x17 ? 1 : 2;\n    if (b >= 0x40 && b <= 0x5f) {\n      row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];\n    } else {\n      // 0x60 <= b <= 0x7F\n      row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];\n    }\n    const channel = this.channels[chNr];\n    if (!channel) {\n      return false;\n    }\n    channel.setPAC(this.interpretPAC(row, b));\n    this.currentChannel = chNr;\n    return true;\n  }\n\n  /**\n   * Interpret the second byte of the pac, and return the information.\n   * @returns pacData with style parameters\n   */\n  interpretPAC(row, byte) {\n    let pacIndex;\n    const pacData = {\n      color: null,\n      italics: false,\n      indent: null,\n      underline: false,\n      row: row\n    };\n    if (byte > 0x5f) {\n      pacIndex = byte - 0x60;\n    } else {\n      pacIndex = byte - 0x40;\n    }\n    pacData.underline = (pacIndex & 1) === 1;\n    if (pacIndex <= 0xd) {\n      pacData.color = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'white'][Math.floor(pacIndex / 2)];\n    } else if (pacIndex <= 0xf) {\n      pacData.italics = true;\n      pacData.color = 'white';\n    } else {\n      pacData.indent = Math.floor((pacIndex - 0x10) / 2) * 4;\n    }\n    return pacData; // Note that row has zero offset. The spec uses 1.\n  }\n\n  /**\n   * Parse characters.\n   * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.\n   */\n  parseChars(a, b) {\n    let channelNr;\n    let charCodes = null;\n    let charCode1 = null;\n    if (a >= 0x19) {\n      channelNr = 2;\n      charCode1 = a - 8;\n    } else {\n      channelNr = 1;\n      charCode1 = a;\n    }\n    if (charCode1 >= 0x11 && charCode1 <= 0x13) {\n      // Special character\n      let oneCode;\n      if (charCode1 === 0x11) {\n        oneCode = b + 0x50;\n      } else if (charCode1 === 0x12) {\n        oneCode = b + 0x70;\n      } else {\n        oneCode = b + 0x90;\n      }\n      this.logger.log(2, () => \"Special char '\" + getCharForByte(oneCode) + \"' in channel \" + channelNr);\n      charCodes = [oneCode];\n    } else if (a >= 0x20 && a <= 0x7f) {\n      charCodes = b === 0 ? [a] : [a, b];\n    }\n    if (charCodes) {\n      this.logger.log(3, () => 'Char codes =  ' + numArrayToHexArray(charCodes).join(','));\n    }\n    return charCodes;\n  }\n\n  /**\n   * Parse extended background attributes as well as new foreground color black.\n   * @returns True if background attributes are found\n   */\n  parseBackgroundAttributes(a, b) {\n    const case1 = (a === 0x10 || a === 0x18) && b >= 0x20 && b <= 0x2f;\n    const case2 = (a === 0x17 || a === 0x1f) && b >= 0x2d && b <= 0x2f;\n    if (!(case1 || case2)) {\n      return false;\n    }\n    let index;\n    const bkgData = {};\n    if (a === 0x10 || a === 0x18) {\n      index = Math.floor((b - 0x20) / 2);\n      bkgData.background = backgroundColors[index];\n      if (b % 2 === 1) {\n        bkgData.background = bkgData.background + '_semi';\n      }\n    } else if (b === 0x2d) {\n      bkgData.background = 'transparent';\n    } else {\n      bkgData.foreground = 'black';\n      if (b === 0x2f) {\n        bkgData.underline = true;\n      }\n    }\n    const chNr = a <= 0x17 ? 1 : 2;\n    const channel = this.channels[chNr];\n    channel.setBkgData(bkgData);\n    return true;\n  }\n\n  /**\n   * Reset state of parser and its channels.\n   */\n  reset() {\n    for (let i = 0; i < Object.keys(this.channels).length; i++) {\n      const channel = this.channels[i];\n      if (channel) {\n        channel.reset();\n      }\n    }\n    setLastCmd(null, null, this.cmdHistory);\n  }\n\n  /**\n   * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.\n   */\n  cueSplitAtTime(t) {\n    for (let i = 0; i < this.channels.length; i++) {\n      const channel = this.channels[i];\n      if (channel) {\n        channel.cueSplitAtTime(t);\n      }\n    }\n  }\n}\nfunction setLastCmd(a, b, cmdHistory) {\n  cmdHistory.a = a;\n  cmdHistory.b = b;\n}\nfunction hasCmdRepeated(a, b, cmdHistory) {\n  return cmdHistory.a === a && cmdHistory.b === b;\n}\nfunction createCmdHistory() {\n  return {\n    a: null,\n    b: null\n  };\n}\n\n/**\n * Copyright 2013 vtt.js Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar VTTCue = (function () {\n  if (optionalSelf != null && optionalSelf.VTTCue) {\n    return self.VTTCue;\n  }\n  const AllowedDirections = ['', 'lr', 'rl'];\n  const AllowedAlignments = ['start', 'middle', 'end', 'left', 'right'];\n  function isAllowedValue(allowed, value) {\n    if (typeof value !== 'string') {\n      return false;\n    }\n    // necessary for assuring the generic conforms to the Array interface\n    if (!Array.isArray(allowed)) {\n      return false;\n    }\n    // reset the type so that the next narrowing works well\n    const lcValue = value.toLowerCase();\n    // use the allow list to narrow the type to a specific subset of strings\n    if (~allowed.indexOf(lcValue)) {\n      return lcValue;\n    }\n    return false;\n  }\n  function findDirectionSetting(value) {\n    return isAllowedValue(AllowedDirections, value);\n  }\n  function findAlignSetting(value) {\n    return isAllowedValue(AllowedAlignments, value);\n  }\n  function extend(obj, ...rest) {\n    let i = 1;\n    for (; i < arguments.length; i++) {\n      const cobj = arguments[i];\n      for (const p in cobj) {\n        obj[p] = cobj[p];\n      }\n    }\n    return obj;\n  }\n  function VTTCue(startTime, endTime, text) {\n    const cue = this;\n    const baseObj = {\n      enumerable: true\n    };\n    /**\n     * Shim implementation specific properties. These properties are not in\n     * the spec.\n     */\n\n    // Lets us know when the VTTCue's data has changed in such a way that we need\n    // to recompute its display state. This lets us compute its display state\n    // lazily.\n    cue.hasBeenReset = false;\n\n    /**\n     * VTTCue and TextTrackCue properties\n     * http://dev.w3.org/html5/webvtt/#vttcue-interface\n     */\n\n    let _id = '';\n    let _pauseOnExit = false;\n    let _startTime = startTime;\n    let _endTime = endTime;\n    let _text = text;\n    let _region = null;\n    let _vertical = '';\n    let _snapToLines = true;\n    let _line = 'auto';\n    let _lineAlign = 'start';\n    let _position = 50;\n    let _positionAlign = 'middle';\n    let _size = 50;\n    let _align = 'middle';\n    Object.defineProperty(cue, 'id', extend({}, baseObj, {\n      get: function () {\n        return _id;\n      },\n      set: function (value) {\n        _id = '' + value;\n      }\n    }));\n    Object.defineProperty(cue, 'pauseOnExit', extend({}, baseObj, {\n      get: function () {\n        return _pauseOnExit;\n      },\n      set: function (value) {\n        _pauseOnExit = !!value;\n      }\n    }));\n    Object.defineProperty(cue, 'startTime', extend({}, baseObj, {\n      get: function () {\n        return _startTime;\n      },\n      set: function (value) {\n        if (typeof value !== 'number') {\n          throw new TypeError('Start time must be set to a number.');\n        }\n        _startTime = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'endTime', extend({}, baseObj, {\n      get: function () {\n        return _endTime;\n      },\n      set: function (value) {\n        if (typeof value !== 'number') {\n          throw new TypeError('End time must be set to a number.');\n        }\n        _endTime = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'text', extend({}, baseObj, {\n      get: function () {\n        return _text;\n      },\n      set: function (value) {\n        _text = '' + value;\n        this.hasBeenReset = true;\n      }\n    }));\n\n    // todo: implement VTTRegion polyfill?\n    Object.defineProperty(cue, 'region', extend({}, baseObj, {\n      get: function () {\n        return _region;\n      },\n      set: function (value) {\n        _region = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'vertical', extend({}, baseObj, {\n      get: function () {\n        return _vertical;\n      },\n      set: function (value) {\n        const setting = findDirectionSetting(value);\n        // Have to check for false because the setting an be an empty string.\n        if (setting === false) {\n          throw new SyntaxError('An invalid or illegal string was specified.');\n        }\n        _vertical = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'snapToLines', extend({}, baseObj, {\n      get: function () {\n        return _snapToLines;\n      },\n      set: function (value) {\n        _snapToLines = !!value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'line', extend({}, baseObj, {\n      get: function () {\n        return _line;\n      },\n      set: function (value) {\n        if (typeof value !== 'number' && value !== 'auto') {\n          throw new SyntaxError('An invalid number or illegal string was specified.');\n        }\n        _line = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'lineAlign', extend({}, baseObj, {\n      get: function () {\n        return _lineAlign;\n      },\n      set: function (value) {\n        const setting = findAlignSetting(value);\n        if (!setting) {\n          throw new SyntaxError('An invalid or illegal string was specified.');\n        }\n        _lineAlign = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'position', extend({}, baseObj, {\n      get: function () {\n        return _position;\n      },\n      set: function (value) {\n        if (value < 0 || value > 100) {\n          throw new Error('Position must be between 0 and 100.');\n        }\n        _position = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'positionAlign', extend({}, baseObj, {\n      get: function () {\n        return _positionAlign;\n      },\n      set: function (value) {\n        const setting = findAlignSetting(value);\n        if (!setting) {\n          throw new SyntaxError('An invalid or illegal string was specified.');\n        }\n        _positionAlign = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'size', extend({}, baseObj, {\n      get: function () {\n        return _size;\n      },\n      set: function (value) {\n        if (value < 0 || value > 100) {\n          throw new Error('Size must be between 0 and 100.');\n        }\n        _size = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'align', extend({}, baseObj, {\n      get: function () {\n        return _align;\n      },\n      set: function (value) {\n        const setting = findAlignSetting(value);\n        if (!setting) {\n          throw new SyntaxError('An invalid or illegal string was specified.');\n        }\n        _align = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n\n    /**\n     * Other <track> spec defined properties\n     */\n\n    // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state\n    cue.displayState = undefined;\n  }\n\n  /**\n   * VTTCue methods\n   */\n\n  VTTCue.prototype.getCueAsHTML = function () {\n    // Assume WebVTT.convertCueToDOMTree is on the global.\n    const WebVTT = self.WebVTT;\n    return WebVTT.convertCueToDOMTree(self, this.text);\n  };\n  // this is a polyfill hack\n  return VTTCue;\n})();\n\n/*\n * Source: https://github.com/mozilla/vtt.js/blob/master/dist/vtt.js\n */\n\nclass StringDecoder {\n  decode(data, options) {\n    if (!data) {\n      return '';\n    }\n    if (typeof data !== 'string') {\n      throw new Error('Error - expected string data.');\n    }\n    return decodeURIComponent(encodeURIComponent(data));\n  }\n}\n\n// Try to parse input as a time stamp.\nfunction parseTimeStamp(input) {\n  function computeSeconds(h, m, s, f) {\n    return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + parseFloat(f || 0);\n  }\n  const m = input.match(/^(?:(\\d+):)?(\\d{2}):(\\d{2})(\\.\\d+)?/);\n  if (!m) {\n    return null;\n  }\n  if (parseFloat(m[2]) > 59) {\n    // Timestamp takes the form of [hours]:[minutes].[milliseconds]\n    // First position is hours as it's over 59.\n    return computeSeconds(m[2], m[3], 0, m[4]);\n  }\n  // Timestamp takes the form of [hours (optional)]:[minutes]:[seconds].[milliseconds]\n  return computeSeconds(m[1], m[2], m[3], m[4]);\n}\n\n// A settings object holds key/value pairs and will ignore anything but the first\n// assignment to a specific key.\nclass Settings {\n  constructor() {\n    this.values = Object.create(null);\n  }\n  // Only accept the first assignment to any key.\n  set(k, v) {\n    if (!this.get(k) && v !== '') {\n      this.values[k] = v;\n    }\n  }\n  // Return the value for a key, or a default value.\n  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with\n  // a number of possible default values as properties where 'defaultKey' is\n  // the key of the property that will be chosen; otherwise it's assumed to be\n  // a single value.\n  get(k, dflt, defaultKey) {\n    if (defaultKey) {\n      return this.has(k) ? this.values[k] : dflt[defaultKey];\n    }\n    return this.has(k) ? this.values[k] : dflt;\n  }\n  // Check whether we have a value for a key.\n  has(k) {\n    return k in this.values;\n  }\n  // Accept a setting if its one of the given alternatives.\n  alt(k, v, a) {\n    for (let n = 0; n < a.length; ++n) {\n      if (v === a[n]) {\n        this.set(k, v);\n        break;\n      }\n    }\n  }\n  // Accept a setting if its a valid (signed) integer.\n  integer(k, v) {\n    if (/^-?\\d+$/.test(v)) {\n      // integer\n      this.set(k, parseInt(v, 10));\n    }\n  }\n  // Accept a setting if its a valid percentage.\n  percent(k, v) {\n    if (/^([\\d]{1,3})(\\.[\\d]*)?%$/.test(v)) {\n      const percent = parseFloat(v);\n      if (percent >= 0 && percent <= 100) {\n        this.set(k, percent);\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\n// Helper function to parse input into groups separated by 'groupDelim', and\n// interpret each group as a key/value pair separated by 'keyValueDelim'.\nfunction parseOptions(input, callback, keyValueDelim, groupDelim) {\n  const groups = groupDelim ? input.split(groupDelim) : [input];\n  for (const i in groups) {\n    if (typeof groups[i] !== 'string') {\n      continue;\n    }\n    const kv = groups[i].split(keyValueDelim);\n    if (kv.length !== 2) {\n      continue;\n    }\n    const k = kv[0];\n    const v = kv[1];\n    callback(k, v);\n  }\n}\nconst defaults = new VTTCue(0, 0, '');\n// 'middle' was changed to 'center' in the spec: https://github.com/w3c/webvtt/pull/244\n//  Safari doesn't yet support this change, but FF and Chrome do.\nconst center = defaults.align === 'middle' ? 'middle' : 'center';\nfunction parseCue(input, cue, regionList) {\n  // Remember the original input if we need to throw an error.\n  const oInput = input;\n  // 4.1 WebVTT timestamp\n  function consumeTimeStamp() {\n    const ts = parseTimeStamp(input);\n    if (ts === null) {\n      throw new Error('Malformed timestamp: ' + oInput);\n    }\n\n    // Remove time stamp from input.\n    input = input.replace(/^[^\\sa-zA-Z-]+/, '');\n    return ts;\n  }\n\n  // 4.4.2 WebVTT cue settings\n  function consumeCueSettings(input, cue) {\n    const settings = new Settings();\n    parseOptions(input, function (k, v) {\n      let vals;\n      switch (k) {\n        case 'region':\n          // Find the last region we parsed with the same region id.\n          for (let i = regionList.length - 1; i >= 0; i--) {\n            if (regionList[i].id === v) {\n              settings.set(k, regionList[i].region);\n              break;\n            }\n          }\n          break;\n        case 'vertical':\n          settings.alt(k, v, ['rl', 'lr']);\n          break;\n        case 'line':\n          vals = v.split(',');\n          settings.integer(k, vals[0]);\n          if (settings.percent(k, vals[0])) {\n            settings.set('snapToLines', false);\n          }\n          settings.alt(k, vals[0], ['auto']);\n          if (vals.length === 2) {\n            settings.alt('lineAlign', vals[1], ['start', center, 'end']);\n          }\n          break;\n        case 'position':\n          vals = v.split(',');\n          settings.percent(k, vals[0]);\n          if (vals.length === 2) {\n            settings.alt('positionAlign', vals[1], ['start', center, 'end', 'line-left', 'line-right', 'auto']);\n          }\n          break;\n        case 'size':\n          settings.percent(k, v);\n          break;\n        case 'align':\n          settings.alt(k, v, ['start', center, 'end', 'left', 'right']);\n          break;\n      }\n    }, /:/, /\\s/);\n\n    // Apply default values for any missing fields.\n    cue.region = settings.get('region', null);\n    cue.vertical = settings.get('vertical', '');\n    let line = settings.get('line', 'auto');\n    if (line === 'auto' && defaults.line === -1) {\n      // set numeric line number for Safari\n      line = -1;\n    }\n    cue.line = line;\n    cue.lineAlign = settings.get('lineAlign', 'start');\n    cue.snapToLines = settings.get('snapToLines', true);\n    cue.size = settings.get('size', 100);\n    cue.align = settings.get('align', center);\n    let position = settings.get('position', 'auto');\n    if (position === 'auto' && defaults.position === 50) {\n      // set numeric position for Safari\n      position = cue.align === 'start' || cue.align === 'left' ? 0 : cue.align === 'end' || cue.align === 'right' ? 100 : 50;\n    }\n    cue.position = position;\n  }\n  function skipWhitespace() {\n    input = input.replace(/^\\s+/, '');\n  }\n\n  // 4.1 WebVTT cue timings.\n  skipWhitespace();\n  cue.startTime = consumeTimeStamp(); // (1) collect cue start time\n  skipWhitespace();\n  if (input.slice(0, 3) !== '-->') {\n    // (3) next characters must match '-->'\n    throw new Error(\"Malformed time stamp (time stamps must be separated by '-->'): \" + oInput);\n  }\n  input = input.slice(3);\n  skipWhitespace();\n  cue.endTime = consumeTimeStamp(); // (5) collect cue end time\n\n  // 4.1 WebVTT cue settings list.\n  skipWhitespace();\n  consumeCueSettings(input, cue);\n}\nfunction fixLineBreaks(input) {\n  return input.replace(/<br(?: \\/)?>/gi, '\\n');\n}\nclass VTTParser {\n  constructor() {\n    this.state = 'INITIAL';\n    this.buffer = '';\n    this.decoder = new StringDecoder();\n    this.regionList = [];\n    this.cue = null;\n    this.oncue = void 0;\n    this.onparsingerror = void 0;\n    this.onflush = void 0;\n  }\n  parse(data) {\n    const _this = this;\n\n    // If there is no data then we won't decode it, but will just try to parse\n    // whatever is in buffer already. This may occur in circumstances, for\n    // example when flush() is called.\n    if (data) {\n      // Try to decode the data that we received.\n      _this.buffer += _this.decoder.decode(data, {\n        stream: true\n      });\n    }\n    function collectNextLine() {\n      let buffer = _this.buffer;\n      let pos = 0;\n      buffer = fixLineBreaks(buffer);\n      while (pos < buffer.length && buffer[pos] !== '\\r' && buffer[pos] !== '\\n') {\n        ++pos;\n      }\n      const line = buffer.slice(0, pos);\n      // Advance the buffer early in case we fail below.\n      if (buffer[pos] === '\\r') {\n        ++pos;\n      }\n      if (buffer[pos] === '\\n') {\n        ++pos;\n      }\n      _this.buffer = buffer.slice(pos);\n      return line;\n    }\n\n    // 3.2 WebVTT metadata header syntax\n    function parseHeader(input) {\n      parseOptions(input, function (k, v) {\n        // switch (k) {\n        // case 'region':\n        // 3.3 WebVTT region metadata header syntax\n        // console.log('parse region', v);\n        // parseRegion(v);\n        // break;\n        // }\n      }, /:/);\n    }\n\n    // 5.1 WebVTT file parsing.\n    try {\n      let line = '';\n      if (_this.state === 'INITIAL') {\n        // We can't start parsing until we have the first line.\n        if (!/\\r\\n|\\n/.test(_this.buffer)) {\n          return this;\n        }\n        line = collectNextLine();\n        // strip of UTF-8 BOM if any\n        // https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8\n        const m = line.match(/^()?WEBVTT([ \\t].*)?$/);\n        if (!(m != null && m[0])) {\n          throw new Error('Malformed WebVTT signature.');\n        }\n        _this.state = 'HEADER';\n      }\n      let alreadyCollectedLine = false;\n      while (_this.buffer) {\n        // We can't parse a line until we have the full line.\n        if (!/\\r\\n|\\n/.test(_this.buffer)) {\n          return this;\n        }\n        if (!alreadyCollectedLine) {\n          line = collectNextLine();\n        } else {\n          alreadyCollectedLine = false;\n        }\n        switch (_this.state) {\n          case 'HEADER':\n            // 13-18 - Allow a header (metadata) under the WEBVTT line.\n            if (/:/.test(line)) {\n              parseHeader(line);\n            } else if (!line) {\n              // An empty line terminates the header and starts the body (cues).\n              _this.state = 'ID';\n            }\n            continue;\n          case 'NOTE':\n            // Ignore NOTE blocks.\n            if (!line) {\n              _this.state = 'ID';\n            }\n            continue;\n          case 'ID':\n            // Check for the start of NOTE blocks.\n            if (/^NOTE($|[ \\t])/.test(line)) {\n              _this.state = 'NOTE';\n              break;\n            }\n            // 19-29 - Allow any number of line terminators, then initialize new cue values.\n            if (!line) {\n              continue;\n            }\n            _this.cue = new VTTCue(0, 0, '');\n            _this.state = 'CUE';\n            // 30-39 - Check if self line contains an optional identifier or timing data.\n            if (line.indexOf('-->') === -1) {\n              _this.cue.id = line;\n              continue;\n            }\n          // Process line as start of a cue.\n          /* falls through */\n          case 'CUE':\n            // 40 - Collect cue timings and settings.\n            if (!_this.cue) {\n              _this.state = 'BADCUE';\n              continue;\n            }\n            try {\n              parseCue(line, _this.cue, _this.regionList);\n            } catch (e) {\n              // In case of an error ignore rest of the cue.\n              _this.cue = null;\n              _this.state = 'BADCUE';\n              continue;\n            }\n            _this.state = 'CUETEXT';\n            continue;\n          case 'CUETEXT':\n            {\n              const hasSubstring = line.indexOf('-->') !== -1;\n              // 34 - If we have an empty line then report the cue.\n              // 35 - If we have the special substring '-->' then report the cue,\n              // but do not collect the line as we need to process the current\n              // one as a new cue.\n              if (!line || hasSubstring && (alreadyCollectedLine = true)) {\n                // We are done parsing self cue.\n                if (_this.oncue && _this.cue) {\n                  _this.oncue(_this.cue);\n                }\n                _this.cue = null;\n                _this.state = 'ID';\n                continue;\n              }\n              if (_this.cue === null) {\n                continue;\n              }\n              if (_this.cue.text) {\n                _this.cue.text += '\\n';\n              }\n              _this.cue.text += line;\n            }\n            continue;\n          case 'BADCUE':\n            // 54-62 - Collect and discard the remaining cue.\n            if (!line) {\n              _this.state = 'ID';\n            }\n        }\n      }\n    } catch (e) {\n      // If we are currently parsing a cue, report what we have.\n      if (_this.state === 'CUETEXT' && _this.cue && _this.oncue) {\n        _this.oncue(_this.cue);\n      }\n      _this.cue = null;\n      // Enter BADWEBVTT state if header was not parsed correctly otherwise\n      // another exception occurred so enter BADCUE state.\n      _this.state = _this.state === 'INITIAL' ? 'BADWEBVTT' : 'BADCUE';\n    }\n    return this;\n  }\n  flush() {\n    const _this = this;\n    try {\n      // Finish decoding the stream.\n      // _this.buffer += _this.decoder.decode();\n      // Synthesize the end of the current cue or region.\n      if (_this.cue || _this.state === 'HEADER') {\n        _this.buffer += '\\n\\n';\n        _this.parse();\n      }\n      // If we've flushed, parsed, and we're still on the INITIAL state then\n      // that means we don't have enough of the stream to parse the first\n      // line.\n      if (_this.state === 'INITIAL' || _this.state === 'BADWEBVTT') {\n        throw new Error('Malformed WebVTT signature.');\n      }\n    } catch (e) {\n      if (_this.onparsingerror) {\n        _this.onparsingerror(e);\n      }\n    }\n    if (_this.onflush) {\n      _this.onflush();\n    }\n    return this;\n  }\n}\n\nconst LINEBREAKS = /\\r\\n|\\n\\r|\\n|\\r/g;\n\n// String.prototype.startsWith is not supported in IE11\nconst startsWith = function startsWith(inputString, searchString, position = 0) {\n  return inputString.slice(position, position + searchString.length) === searchString;\n};\nconst cueString2millis = function cueString2millis(timeString) {\n  let ts = parseInt(timeString.slice(-3));\n  const secs = parseInt(timeString.slice(-6, -4));\n  const mins = parseInt(timeString.slice(-9, -7));\n  const hours = timeString.length > 9 ? parseInt(timeString.substring(0, timeString.indexOf(':'))) : 0;\n  if (!isFiniteNumber(ts) || !isFiniteNumber(secs) || !isFiniteNumber(mins) || !isFiniteNumber(hours)) {\n    throw Error(`Malformed X-TIMESTAMP-MAP: Local:${timeString}`);\n  }\n  ts += 1000 * secs;\n  ts += 60 * 1000 * mins;\n  ts += 60 * 60 * 1000 * hours;\n  return ts;\n};\n\n// Create a unique hash id for a cue based on start/end times and text.\n// This helps timeline-controller to avoid showing repeated captions.\nfunction generateCueId(startTime, endTime, text) {\n  return hash(startTime.toString()) + hash(endTime.toString()) + hash(text);\n}\nconst calculateOffset = function calculateOffset(vttCCs, cc, presentationTime) {\n  let currCC = vttCCs[cc];\n  let prevCC = vttCCs[currCC.prevCC];\n\n  // This is the first discontinuity or cues have been processed since the last discontinuity\n  // Offset = current discontinuity time\n  if (!prevCC || !prevCC.new && currCC.new) {\n    vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start;\n    currCC.new = false;\n    return;\n  }\n\n  // There have been discontinuities since cues were last parsed.\n  // Offset = time elapsed\n  while ((_prevCC = prevCC) != null && _prevCC.new) {\n    var _prevCC;\n    vttCCs.ccOffset += currCC.start - prevCC.start;\n    currCC.new = false;\n    currCC = prevCC;\n    prevCC = vttCCs[currCC.prevCC];\n  }\n  vttCCs.presentationOffset = presentationTime;\n};\nfunction parseWebVTT(vttByteArray, initPTS, vttCCs, cc, timeOffset, callBack, errorCallBack) {\n  const parser = new VTTParser();\n  // Convert byteArray into string, replacing any somewhat exotic linefeeds with \"\\n\", then split on that character.\n  // Uint8Array.prototype.reduce is not implemented in IE11\n  const vttLines = utf8ArrayToStr(new Uint8Array(vttByteArray)).trim().replace(LINEBREAKS, '\\n').split('\\n');\n  const cues = [];\n  const init90kHz = initPTS ? toMpegTsClockFromTimescale(initPTS.baseTime, initPTS.timescale) : 0;\n  let cueTime = '00:00.000';\n  let timestampMapMPEGTS = 0;\n  let timestampMapLOCAL = 0;\n  let parsingError;\n  let inHeader = true;\n  parser.oncue = function (cue) {\n    // Adjust cue timing; clamp cues to start no earlier than - and drop cues that don't end after - 0 on timeline.\n    const currCC = vttCCs[cc];\n    let cueOffset = vttCCs.ccOffset;\n\n    // Calculate subtitle PTS offset\n    const webVttMpegTsMapOffset = (timestampMapMPEGTS - init90kHz) / 90000;\n\n    // Update offsets for new discontinuities\n    if (currCC != null && currCC.new) {\n      if (timestampMapLOCAL !== undefined) {\n        // When local time is provided, offset = discontinuity start time - local time\n        cueOffset = vttCCs.ccOffset = currCC.start;\n      } else {\n        calculateOffset(vttCCs, cc, webVttMpegTsMapOffset);\n      }\n    }\n    if (webVttMpegTsMapOffset) {\n      if (!initPTS) {\n        parsingError = new Error('Missing initPTS for VTT MPEGTS');\n        return;\n      }\n      // If we have MPEGTS, offset = presentation time + discontinuity offset\n      cueOffset = webVttMpegTsMapOffset - vttCCs.presentationOffset;\n    }\n    const duration = cue.endTime - cue.startTime;\n    const startTime = normalizePts((cue.startTime + cueOffset - timestampMapLOCAL) * 90000, timeOffset * 90000) / 90000;\n    cue.startTime = Math.max(startTime, 0);\n    cue.endTime = Math.max(startTime + duration, 0);\n\n    //trim trailing webvtt block whitespaces\n    const text = cue.text.trim();\n\n    // Fix encoding of special characters\n    cue.text = decodeURIComponent(encodeURIComponent(text));\n\n    // If the cue was not assigned an id from the VTT file (line above the content), create one.\n    if (!cue.id) {\n      cue.id = generateCueId(cue.startTime, cue.endTime, text);\n    }\n    if (cue.endTime > 0) {\n      cues.push(cue);\n    }\n  };\n  parser.onparsingerror = function (error) {\n    parsingError = error;\n  };\n  parser.onflush = function () {\n    if (parsingError) {\n      errorCallBack(parsingError);\n      return;\n    }\n    callBack(cues);\n  };\n\n  // Go through contents line by line.\n  vttLines.forEach(line => {\n    if (inHeader) {\n      // Look for X-TIMESTAMP-MAP in header.\n      if (startsWith(line, 'X-TIMESTAMP-MAP=')) {\n        // Once found, no more are allowed anyway, so stop searching.\n        inHeader = false;\n        // Extract LOCAL and MPEGTS.\n        line.slice(16).split(',').forEach(timestamp => {\n          if (startsWith(timestamp, 'LOCAL:')) {\n            cueTime = timestamp.slice(6);\n          } else if (startsWith(timestamp, 'MPEGTS:')) {\n            timestampMapMPEGTS = parseInt(timestamp.slice(7));\n          }\n        });\n        try {\n          // Convert cue time to seconds\n          timestampMapLOCAL = cueString2millis(cueTime) / 1000;\n        } catch (error) {\n          parsingError = error;\n        }\n        // Return without parsing X-TIMESTAMP-MAP line.\n        return;\n      } else if (line === '') {\n        inHeader = false;\n      }\n    }\n    // Parse line by default.\n    parser.parse(line + '\\n');\n  });\n  parser.flush();\n}\n\nconst IMSC1_CODEC = 'stpp.ttml.im1t';\n\n// Time format: h:m:s:frames(.subframes)\nconst HMSF_REGEX = /^(\\d{2,}):(\\d{2}):(\\d{2}):(\\d{2})\\.?(\\d+)?$/;\n\n// Time format: hours, minutes, seconds, milliseconds, frames, ticks\nconst TIME_UNIT_REGEX = /^(\\d*(?:\\.\\d*)?)(h|m|s|ms|f|t)$/;\nconst textAlignToLineAlign = {\n  left: 'start',\n  center: 'center',\n  right: 'end',\n  start: 'start',\n  end: 'end'\n};\nfunction parseIMSC1(payload, initPTS, callBack, errorCallBack) {\n  const results = findBox(new Uint8Array(payload), ['mdat']);\n  if (results.length === 0) {\n    errorCallBack(new Error('Could not parse IMSC1 mdat'));\n    return;\n  }\n  const ttmlList = results.map(mdat => utf8ArrayToStr(mdat));\n  const syncTime = toTimescaleFromScale(initPTS.baseTime, 1, initPTS.timescale);\n  try {\n    ttmlList.forEach(ttml => callBack(parseTTML(ttml, syncTime)));\n  } catch (error) {\n    errorCallBack(error);\n  }\n}\nfunction parseTTML(ttml, syncTime) {\n  const parser = new DOMParser();\n  const xmlDoc = parser.parseFromString(ttml, 'text/xml');\n  const tt = xmlDoc.getElementsByTagName('tt')[0];\n  if (!tt) {\n    throw new Error('Invalid ttml');\n  }\n  const defaultRateInfo = {\n    frameRate: 30,\n    subFrameRate: 1,\n    frameRateMultiplier: 0,\n    tickRate: 0\n  };\n  const rateInfo = Object.keys(defaultRateInfo).reduce((result, key) => {\n    result[key] = tt.getAttribute(`ttp:${key}`) || defaultRateInfo[key];\n    return result;\n  }, {});\n  const trim = tt.getAttribute('xml:space') !== 'preserve';\n  const styleElements = collectionToDictionary(getElementCollection(tt, 'styling', 'style'));\n  const regionElements = collectionToDictionary(getElementCollection(tt, 'layout', 'region'));\n  const cueElements = getElementCollection(tt, 'body', '[begin]');\n  return [].map.call(cueElements, cueElement => {\n    const cueText = getTextContent(cueElement, trim);\n    if (!cueText || !cueElement.hasAttribute('begin')) {\n      return null;\n    }\n    const startTime = parseTtmlTime(cueElement.getAttribute('begin'), rateInfo);\n    const duration = parseTtmlTime(cueElement.getAttribute('dur'), rateInfo);\n    let endTime = parseTtmlTime(cueElement.getAttribute('end'), rateInfo);\n    if (startTime === null) {\n      throw timestampParsingError(cueElement);\n    }\n    if (endTime === null) {\n      if (duration === null) {\n        throw timestampParsingError(cueElement);\n      }\n      endTime = startTime + duration;\n    }\n    const cue = new VTTCue(startTime - syncTime, endTime - syncTime, cueText);\n    cue.id = generateCueId(cue.startTime, cue.endTime, cue.text);\n    const region = regionElements[cueElement.getAttribute('region')];\n    const style = styleElements[cueElement.getAttribute('style')];\n\n    // Apply styles to cue\n    const styles = getTtmlStyles(region, style, styleElements);\n    const {\n      textAlign\n    } = styles;\n    if (textAlign) {\n      // cue.positionAlign not settable in FF~2016\n      const lineAlign = textAlignToLineAlign[textAlign];\n      if (lineAlign) {\n        cue.lineAlign = lineAlign;\n      }\n      cue.align = textAlign;\n    }\n    _extends(cue, styles);\n    return cue;\n  }).filter(cue => cue !== null);\n}\nfunction getElementCollection(fromElement, parentName, childName) {\n  const parent = fromElement.getElementsByTagName(parentName)[0];\n  if (parent) {\n    return [].slice.call(parent.querySelectorAll(childName));\n  }\n  return [];\n}\nfunction collectionToDictionary(elementsWithId) {\n  return elementsWithId.reduce((dict, element) => {\n    const id = element.getAttribute('xml:id');\n    if (id) {\n      dict[id] = element;\n    }\n    return dict;\n  }, {});\n}\nfunction getTextContent(element, trim) {\n  return [].slice.call(element.childNodes).reduce((str, node, i) => {\n    var _node$childNodes;\n    if (node.nodeName === 'br' && i) {\n      return str + '\\n';\n    }\n    if ((_node$childNodes = node.childNodes) != null && _node$childNodes.length) {\n      return getTextContent(node, trim);\n    } else if (trim) {\n      return str + node.textContent.trim().replace(/\\s+/g, ' ');\n    }\n    return str + node.textContent;\n  }, '');\n}\nfunction getTtmlStyles(region, style, styleElements) {\n  const ttsNs = 'http://www.w3.org/ns/ttml#styling';\n  let regionStyle = null;\n  const styleAttributes = ['displayAlign', 'textAlign', 'color', 'backgroundColor', 'fontSize', 'fontFamily'\n  // 'fontWeight',\n  // 'lineHeight',\n  // 'wrapOption',\n  // 'fontStyle',\n  // 'direction',\n  // 'writingMode'\n  ];\n  const regionStyleName = region != null && region.hasAttribute('style') ? region.getAttribute('style') : null;\n  if (regionStyleName && styleElements.hasOwnProperty(regionStyleName)) {\n    regionStyle = styleElements[regionStyleName];\n  }\n  return styleAttributes.reduce((styles, name) => {\n    const value = getAttributeNS(style, ttsNs, name) || getAttributeNS(region, ttsNs, name) || getAttributeNS(regionStyle, ttsNs, name);\n    if (value) {\n      styles[name] = value;\n    }\n    return styles;\n  }, {});\n}\nfunction getAttributeNS(element, ns, name) {\n  if (!element) {\n    return null;\n  }\n  return element.hasAttributeNS(ns, name) ? element.getAttributeNS(ns, name) : null;\n}\nfunction timestampParsingError(node) {\n  return new Error(`Could not parse ttml timestamp ${node}`);\n}\nfunction parseTtmlTime(timeAttributeValue, rateInfo) {\n  if (!timeAttributeValue) {\n    return null;\n  }\n  let seconds = parseTimeStamp(timeAttributeValue);\n  if (seconds === null) {\n    if (HMSF_REGEX.test(timeAttributeValue)) {\n      seconds = parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo);\n    } else if (TIME_UNIT_REGEX.test(timeAttributeValue)) {\n      seconds = parseTimeUnits(timeAttributeValue, rateInfo);\n    }\n  }\n  return seconds;\n}\nfunction parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo) {\n  const m = HMSF_REGEX.exec(timeAttributeValue);\n  const frames = (m[4] | 0) + (m[5] | 0) / rateInfo.subFrameRate;\n  return (m[1] | 0) * 3600 + (m[2] | 0) * 60 + (m[3] | 0) + frames / rateInfo.frameRate;\n}\nfunction parseTimeUnits(timeAttributeValue, rateInfo) {\n  const m = TIME_UNIT_REGEX.exec(timeAttributeValue);\n  const value = Number(m[1]);\n  const unit = m[2];\n  switch (unit) {\n    case 'h':\n      return value * 3600;\n    case 'm':\n      return value * 60;\n    case 'ms':\n      return value * 1000;\n    case 'f':\n      return value / rateInfo.frameRate;\n    case 't':\n      return value / rateInfo.tickRate;\n  }\n  return value;\n}\n\nclass OutputFilter {\n  constructor(timelineController, trackName) {\n    this.timelineController = void 0;\n    this.cueRanges = [];\n    this.trackName = void 0;\n    this.startTime = null;\n    this.endTime = null;\n    this.screen = null;\n    this.timelineController = timelineController;\n    this.trackName = trackName;\n  }\n  dispatchCue() {\n    if (this.startTime === null) {\n      return;\n    }\n    this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges);\n    this.startTime = null;\n  }\n  newCue(startTime, endTime, screen) {\n    if (this.startTime === null || this.startTime > startTime) {\n      this.startTime = startTime;\n    }\n    this.endTime = endTime;\n    this.screen = screen;\n    this.timelineController.createCaptionsTrack(this.trackName);\n  }\n  reset() {\n    this.cueRanges = [];\n    this.startTime = null;\n  }\n}\n\nclass TimelineController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.media = null;\n    this.config = void 0;\n    this.enabled = true;\n    this.Cues = void 0;\n    this.textTracks = [];\n    this.tracks = [];\n    this.initPTS = [];\n    this.unparsedVttFrags = [];\n    this.captionsTracks = {};\n    this.nonNativeCaptionsTracks = {};\n    this.cea608Parser1 = void 0;\n    this.cea608Parser2 = void 0;\n    this.lastCc = -1;\n    // Last video (CEA-608) fragment CC\n    this.lastSn = -1;\n    // Last video (CEA-608) fragment MSN\n    this.lastPartIndex = -1;\n    // Last video (CEA-608) fragment Part Index\n    this.prevCC = -1;\n    // Last subtitle fragment CC\n    this.vttCCs = newVTTCCs();\n    this.captionsProperties = void 0;\n    this.hls = hls;\n    this.config = hls.config;\n    this.Cues = hls.config.cueHandler;\n    this.captionsProperties = {\n      textTrack1: {\n        label: this.config.captionsTextTrack1Label,\n        languageCode: this.config.captionsTextTrack1LanguageCode\n      },\n      textTrack2: {\n        label: this.config.captionsTextTrack2Label,\n        languageCode: this.config.captionsTextTrack2LanguageCode\n      },\n      textTrack3: {\n        label: this.config.captionsTextTrack3Label,\n        languageCode: this.config.captionsTextTrack3LanguageCode\n      },\n      textTrack4: {\n        label: this.config.captionsTextTrack4Label,\n        languageCode: this.config.captionsTextTrack4LanguageCode\n      }\n    };\n    hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.on(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n    hls.on(Events.FRAG_LOADING, this.onFragLoading, this);\n    hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);\n    hls.on(Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);\n    hls.on(Events.FRAG_DECRYPTED, this.onFragDecrypted, this);\n    hls.on(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);\n    hls.on(Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);\n    hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n  }\n  destroy() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.off(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n    hls.off(Events.FRAG_LOADING, this.onFragLoading, this);\n    hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);\n    hls.off(Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);\n    hls.off(Events.FRAG_DECRYPTED, this.onFragDecrypted, this);\n    hls.off(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);\n    hls.off(Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);\n    hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    // @ts-ignore\n    this.hls = this.config = this.media = null;\n    this.cea608Parser1 = this.cea608Parser2 = undefined;\n  }\n  initCea608Parsers() {\n    const channel1 = new OutputFilter(this, 'textTrack1');\n    const channel2 = new OutputFilter(this, 'textTrack2');\n    const channel3 = new OutputFilter(this, 'textTrack3');\n    const channel4 = new OutputFilter(this, 'textTrack4');\n    this.cea608Parser1 = new Cea608Parser(1, channel1, channel2);\n    this.cea608Parser2 = new Cea608Parser(3, channel3, channel4);\n  }\n  addCues(trackName, startTime, endTime, screen, cueRanges) {\n    // skip cues which overlap more than 50% with previously parsed time ranges\n    let merged = false;\n    for (let i = cueRanges.length; i--;) {\n      const cueRange = cueRanges[i];\n      const overlap = intersection(cueRange[0], cueRange[1], startTime, endTime);\n      if (overlap >= 0) {\n        cueRange[0] = Math.min(cueRange[0], startTime);\n        cueRange[1] = Math.max(cueRange[1], endTime);\n        merged = true;\n        if (overlap / (endTime - startTime) > 0.5) {\n          return;\n        }\n      }\n    }\n    if (!merged) {\n      cueRanges.push([startTime, endTime]);\n    }\n    if (this.config.renderTextTracksNatively) {\n      const track = this.captionsTracks[trackName];\n      this.Cues.newCue(track, startTime, endTime, screen);\n    } else {\n      const cues = this.Cues.newCue(null, startTime, endTime, screen);\n      this.hls.trigger(Events.CUES_PARSED, {\n        type: 'captions',\n        cues,\n        track: trackName\n      });\n    }\n  }\n\n  // Triggered when an initial PTS is found; used for synchronisation of WebVTT.\n  onInitPtsFound(event, {\n    frag,\n    id,\n    initPTS,\n    timescale\n  }) {\n    const {\n      unparsedVttFrags\n    } = this;\n    if (id === PlaylistLevelType.MAIN) {\n      this.initPTS[frag.cc] = {\n        baseTime: initPTS,\n        timescale\n      };\n    }\n\n    // Due to asynchronous processing, initial PTS may arrive later than the first VTT fragments are loaded.\n    // Parse any unparsed fragments upon receiving the initial PTS.\n    if (unparsedVttFrags.length) {\n      this.unparsedVttFrags = [];\n      unparsedVttFrags.forEach(data => {\n        if (this.initPTS[data.frag.cc]) {\n          this.onFragLoaded(Events.FRAG_LOADED, data);\n        } else {\n          this.hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n            success: false,\n            frag: data.frag,\n            error: new Error('Subtitle discontinuity domain does not match main')\n          });\n        }\n      });\n    }\n  }\n  getExistingTrack(label, language) {\n    const {\n      media\n    } = this;\n    if (media) {\n      for (let i = 0; i < media.textTracks.length; i++) {\n        const textTrack = media.textTracks[i];\n        if (canReuseVttTextTrack(textTrack, {\n          name: label,\n          lang: language,\n          characteristics: 'transcribes-spoken-dialog,describes-music-and-sound'})) {\n          return textTrack;\n        }\n      }\n    }\n    return null;\n  }\n  createCaptionsTrack(trackName) {\n    if (this.config.renderTextTracksNatively) {\n      this.createNativeTrack(trackName);\n    } else {\n      this.createNonNativeTrack(trackName);\n    }\n  }\n  createNativeTrack(trackName) {\n    if (this.captionsTracks[trackName]) {\n      return;\n    }\n    const {\n      captionsProperties,\n      captionsTracks,\n      media\n    } = this;\n    const {\n      label,\n      languageCode\n    } = captionsProperties[trackName];\n    // Enable reuse of existing text track.\n    const existingTrack = this.getExistingTrack(label, languageCode);\n    if (!existingTrack) {\n      const textTrack = this.createTextTrack('captions', label, languageCode);\n      if (textTrack) {\n        // Set a special property on the track so we know it's managed by Hls.js\n        textTrack[trackName] = true;\n        captionsTracks[trackName] = textTrack;\n      }\n    } else {\n      captionsTracks[trackName] = existingTrack;\n      clearCurrentCues(captionsTracks[trackName]);\n      sendAddTrackEvent(captionsTracks[trackName], media);\n    }\n  }\n  createNonNativeTrack(trackName) {\n    if (this.nonNativeCaptionsTracks[trackName]) {\n      return;\n    }\n    // Create a list of a single track for the provider to consume\n    const trackProperties = this.captionsProperties[trackName];\n    if (!trackProperties) {\n      return;\n    }\n    const label = trackProperties.label;\n    const track = {\n      _id: trackName,\n      label,\n      kind: 'captions',\n      default: trackProperties.media ? !!trackProperties.media.default : false,\n      closedCaptions: trackProperties.media\n    };\n    this.nonNativeCaptionsTracks[trackName] = track;\n    this.hls.trigger(Events.NON_NATIVE_TEXT_TRACKS_FOUND, {\n      tracks: [track]\n    });\n  }\n  createTextTrack(kind, label, lang) {\n    const media = this.media;\n    if (!media) {\n      return;\n    }\n    return media.addTextTrack(kind, label, lang);\n  }\n  onMediaAttaching(event, data) {\n    this.media = data.media;\n    if (!data.mediaSource) {\n      this._cleanTracks();\n    }\n  }\n  onMediaDetaching(event, data) {\n    const transferringMedia = !!data.transferMedia;\n    this.media = null;\n    if (transferringMedia) {\n      return;\n    }\n    const {\n      captionsTracks\n    } = this;\n    Object.keys(captionsTracks).forEach(trackName => {\n      clearCurrentCues(captionsTracks[trackName]);\n      delete captionsTracks[trackName];\n    });\n    this.nonNativeCaptionsTracks = {};\n  }\n  onManifestLoading() {\n    // Detect discontinuity in video fragment (CEA-608) parsing\n    this.lastCc = -1;\n    this.lastSn = -1;\n    this.lastPartIndex = -1;\n    // Detect discontinuity in subtitle manifests\n    this.prevCC = -1;\n    this.vttCCs = newVTTCCs();\n    // Reset tracks\n    this._cleanTracks();\n    this.tracks = [];\n    this.captionsTracks = {};\n    this.nonNativeCaptionsTracks = {};\n    this.textTracks = [];\n    this.unparsedVttFrags = [];\n    this.initPTS = [];\n    if (this.cea608Parser1 && this.cea608Parser2) {\n      this.cea608Parser1.reset();\n      this.cea608Parser2.reset();\n    }\n  }\n  _cleanTracks() {\n    // clear outdated subtitles\n    const {\n      media\n    } = this;\n    if (!media) {\n      return;\n    }\n    const textTracks = media.textTracks;\n    if (textTracks) {\n      for (let i = 0; i < textTracks.length; i++) {\n        clearCurrentCues(textTracks[i]);\n      }\n    }\n  }\n  onSubtitleTracksUpdated(event, data) {\n    const tracks = data.subtitleTracks || [];\n    const hasIMSC1 = tracks.some(track => track.textCodec === IMSC1_CODEC);\n    if (this.config.enableWebVTT || hasIMSC1 && this.config.enableIMSC1) {\n      const listIsIdentical = subtitleOptionsIdentical(this.tracks, tracks);\n      if (listIsIdentical) {\n        this.tracks = tracks;\n        return;\n      }\n      this.textTracks = [];\n      this.tracks = tracks;\n      if (this.config.renderTextTracksNatively) {\n        const media = this.media;\n        const inUseTracks = media ? filterSubtitleTracks(media.textTracks) : null;\n        this.tracks.forEach((track, index) => {\n          // Reuse tracks with the same label and lang, but do not reuse 608/708 tracks\n          let textTrack;\n          if (inUseTracks) {\n            let inUseTrack = null;\n            for (let i = 0; i < inUseTracks.length; i++) {\n              if (inUseTracks[i] && canReuseVttTextTrack(inUseTracks[i], track)) {\n                inUseTrack = inUseTracks[i];\n                inUseTracks[i] = null;\n                break;\n              }\n            }\n            if (inUseTrack) {\n              textTrack = inUseTrack;\n            }\n          }\n          if (textTrack) {\n            clearCurrentCues(textTrack);\n          } else {\n            const textTrackKind = captionsOrSubtitlesFromCharacteristics(track);\n            textTrack = this.createTextTrack(textTrackKind, track.name, track.lang);\n            if (textTrack) {\n              textTrack.mode = 'disabled';\n            }\n          }\n          if (textTrack) {\n            this.textTracks.push(textTrack);\n          }\n        });\n        // Warn when video element has captions or subtitle TextTracks carried over from another source\n        if (inUseTracks != null && inUseTracks.length) {\n          const unusedTextTracks = inUseTracks.filter(t => t !== null).map(t => t.label);\n          if (unusedTextTracks.length) {\n            this.hls.logger.warn(`Media element contains unused subtitle tracks: ${unusedTextTracks.join(', ')}. Replace media element for each source to clear TextTracks and captions menu.`);\n          }\n        }\n      } else if (this.tracks.length) {\n        // Create a list of tracks for the provider to consume\n        const tracksList = this.tracks.map(track => {\n          return {\n            label: track.name,\n            kind: track.type.toLowerCase(),\n            default: track.default,\n            subtitleTrack: track\n          };\n        });\n        this.hls.trigger(Events.NON_NATIVE_TEXT_TRACKS_FOUND, {\n          tracks: tracksList\n        });\n      }\n    }\n  }\n  onManifestLoaded(event, data) {\n    if (this.config.enableCEA708Captions && data.captions) {\n      data.captions.forEach(captionsTrack => {\n        const instreamIdMatch = /(?:CC|SERVICE)([1-4])/.exec(captionsTrack.instreamId);\n        if (!instreamIdMatch) {\n          return;\n        }\n        const trackName = `textTrack${instreamIdMatch[1]}`;\n        const trackProperties = this.captionsProperties[trackName];\n        if (!trackProperties) {\n          return;\n        }\n        trackProperties.label = captionsTrack.name;\n        if (captionsTrack.lang) {\n          // optional attribute\n          trackProperties.languageCode = captionsTrack.lang;\n        }\n        trackProperties.media = captionsTrack;\n      });\n    }\n  }\n  closedCaptionsForLevel(frag) {\n    const level = this.hls.levels[frag.level];\n    return level == null ? void 0 : level.attrs['CLOSED-CAPTIONS'];\n  }\n  onFragLoading(event, data) {\n    // if this frag isn't contiguous, clear the parser so cues with bad start/end times aren't added to the textTrack\n    if (this.enabled && data.frag.type === PlaylistLevelType.MAIN) {\n      var _data$part$index, _data$part;\n      const {\n        cea608Parser1,\n        cea608Parser2,\n        lastSn\n      } = this;\n      const {\n        cc,\n        sn\n      } = data.frag;\n      const partIndex = (_data$part$index = (_data$part = data.part) == null ? void 0 : _data$part.index) != null ? _data$part$index : -1;\n      if (cea608Parser1 && cea608Parser2) {\n        if (sn !== lastSn + 1 || sn === lastSn && partIndex !== this.lastPartIndex + 1 || cc !== this.lastCc) {\n          cea608Parser1.reset();\n          cea608Parser2.reset();\n        }\n      }\n      this.lastCc = cc;\n      this.lastSn = sn;\n      this.lastPartIndex = partIndex;\n    }\n  }\n  onFragLoaded(event, data) {\n    const {\n      frag,\n      payload\n    } = data;\n    if (frag.type === PlaylistLevelType.SUBTITLE) {\n      // If fragment is subtitle type, parse as WebVTT.\n      if (payload.byteLength) {\n        const decryptData = frag.decryptdata;\n        // fragment after decryption has a stats object\n        const decrypted = 'stats' in data;\n        // If the subtitles are not encrypted, parse VTTs now. Otherwise, we need to wait.\n        if (decryptData == null || !decryptData.encrypted || decrypted) {\n          const trackPlaylistMedia = this.tracks[frag.level];\n          const vttCCs = this.vttCCs;\n          if (!vttCCs[frag.cc]) {\n            vttCCs[frag.cc] = {\n              start: frag.start,\n              prevCC: this.prevCC,\n              new: true\n            };\n            this.prevCC = frag.cc;\n          }\n          if (trackPlaylistMedia && trackPlaylistMedia.textCodec === IMSC1_CODEC) {\n            this._parseIMSC1(frag, payload);\n          } else {\n            this._parseVTTs(data);\n          }\n        }\n      } else {\n        // In case there is no payload, finish unsuccessfully.\n        this.hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n          success: false,\n          frag,\n          error: new Error('Empty subtitle payload')\n        });\n      }\n    }\n  }\n  _parseIMSC1(frag, payload) {\n    const hls = this.hls;\n    parseIMSC1(payload, this.initPTS[frag.cc], cues => {\n      this._appendCues(cues, frag.level);\n      hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n        success: true,\n        frag: frag\n      });\n    }, error => {\n      hls.logger.log(`Failed to parse IMSC1: ${error}`);\n      hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n        success: false,\n        frag: frag,\n        error\n      });\n    });\n  }\n  _parseVTTs(data) {\n    var _frag$initSegment;\n    const {\n      frag,\n      payload\n    } = data;\n    // We need an initial synchronisation PTS. Store fragments as long as none has arrived\n    const {\n      initPTS,\n      unparsedVttFrags\n    } = this;\n    const maxAvCC = initPTS.length - 1;\n    if (!initPTS[frag.cc] && maxAvCC === -1) {\n      unparsedVttFrags.push(data);\n      return;\n    }\n    const hls = this.hls;\n    // Parse the WebVTT file contents.\n    const payloadWebVTT = (_frag$initSegment = frag.initSegment) != null && _frag$initSegment.data ? appendUint8Array(frag.initSegment.data, new Uint8Array(payload)).buffer : payload;\n    parseWebVTT(payloadWebVTT, this.initPTS[frag.cc], this.vttCCs, frag.cc, frag.start, cues => {\n      this._appendCues(cues, frag.level);\n      hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n        success: true,\n        frag: frag\n      });\n    }, error => {\n      const missingInitPTS = error.message === 'Missing initPTS for VTT MPEGTS';\n      if (missingInitPTS) {\n        unparsedVttFrags.push(data);\n      } else {\n        this._fallbackToIMSC1(frag, payload);\n      }\n      // Something went wrong while parsing. Trigger event with success false.\n      hls.logger.log(`Failed to parse VTT cue: ${error}`);\n      if (missingInitPTS && maxAvCC > frag.cc) {\n        return;\n      }\n      hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n        success: false,\n        frag: frag,\n        error\n      });\n    });\n  }\n  _fallbackToIMSC1(frag, payload) {\n    // If textCodec is unknown, try parsing as IMSC1. Set textCodec based on the result\n    const trackPlaylistMedia = this.tracks[frag.level];\n    if (!trackPlaylistMedia.textCodec) {\n      parseIMSC1(payload, this.initPTS[frag.cc], () => {\n        trackPlaylistMedia.textCodec = IMSC1_CODEC;\n        this._parseIMSC1(frag, payload);\n      }, () => {\n        trackPlaylistMedia.textCodec = 'wvtt';\n      });\n    }\n  }\n  _appendCues(cues, fragLevel) {\n    const hls = this.hls;\n    if (this.config.renderTextTracksNatively) {\n      const textTrack = this.textTracks[fragLevel];\n      // WebVTTParser.parse is an async method and if the currently selected text track mode is set to \"disabled\"\n      // before parsing is done then don't try to access currentTrack.cues.getCueById as cues will be null\n      // and trying to access getCueById method of cues will throw an exception\n      // Because we check if the mode is disabled, we can force check `cues` below. They can't be null.\n      if (!textTrack || textTrack.mode === 'disabled') {\n        return;\n      }\n      cues.forEach(cue => addCueToTrack(textTrack, cue));\n    } else {\n      const currentTrack = this.tracks[fragLevel];\n      if (!currentTrack) {\n        return;\n      }\n      const track = currentTrack.default ? 'default' : 'subtitles' + fragLevel;\n      hls.trigger(Events.CUES_PARSED, {\n        type: 'subtitles',\n        cues,\n        track\n      });\n    }\n  }\n  onFragDecrypted(event, data) {\n    const {\n      frag\n    } = data;\n    if (frag.type === PlaylistLevelType.SUBTITLE) {\n      this.onFragLoaded(Events.FRAG_LOADED, data);\n    }\n  }\n  onSubtitleTracksCleared() {\n    this.tracks = [];\n    this.captionsTracks = {};\n  }\n  onFragParsingUserdata(event, data) {\n    if (!this.enabled || !this.config.enableCEA708Captions) {\n      return;\n    }\n    const {\n      frag,\n      samples\n    } = data;\n    if (frag.type === PlaylistLevelType.MAIN && this.closedCaptionsForLevel(frag) === 'NONE') {\n      return;\n    }\n    // If the event contains captions (found in the bytes property), push all bytes into the parser immediately\n    // It will create the proper timestamps based on the PTS value\n    for (let i = 0; i < samples.length; i++) {\n      const ccBytes = samples[i].bytes;\n      if (ccBytes) {\n        if (!this.cea608Parser1) {\n          this.initCea608Parsers();\n        }\n        const ccdatas = this.extractCea608Data(ccBytes);\n        this.cea608Parser1.addData(samples[i].pts, ccdatas[0]);\n        this.cea608Parser2.addData(samples[i].pts, ccdatas[1]);\n      }\n    }\n  }\n  onBufferFlushing(event, {\n    startOffset,\n    endOffset,\n    endOffsetSubtitles,\n    type\n  }) {\n    const {\n      media\n    } = this;\n    if (!media || media.currentTime < endOffset) {\n      return;\n    }\n    // Clear 608 caption cues from the captions TextTracks when the video back buffer is flushed\n    // Forward cues are never removed because we can loose streamed 608 content from recent fragments\n    if (!type || type === 'video') {\n      const {\n        captionsTracks\n      } = this;\n      Object.keys(captionsTracks).forEach(trackName => removeCuesInRange(captionsTracks[trackName], startOffset, endOffset));\n    }\n    if (this.config.renderTextTracksNatively) {\n      // Clear VTT/IMSC1 subtitle cues from the subtitle TextTracks when the back buffer is flushed\n      if (startOffset === 0 && endOffsetSubtitles !== undefined) {\n        const {\n          textTracks\n        } = this;\n        Object.keys(textTracks).forEach(trackName => removeCuesInRange(textTracks[trackName], startOffset, endOffsetSubtitles));\n      }\n    }\n  }\n  extractCea608Data(byteArray) {\n    const actualCCBytes = [[], []];\n    const count = byteArray[0] & 0x1f;\n    let position = 2;\n    for (let j = 0; j < count; j++) {\n      const tmpByte = byteArray[position++];\n      const ccbyte1 = 0x7f & byteArray[position++];\n      const ccbyte2 = 0x7f & byteArray[position++];\n      if (ccbyte1 === 0 && ccbyte2 === 0) {\n        continue;\n      }\n      const ccValid = (0x04 & tmpByte) !== 0; // Support all four channels\n      if (ccValid) {\n        const ccType = 0x03 & tmpByte;\n        if (0x00 /* CEA608 field1*/ === ccType || 0x01 /* CEA608 field2*/ === ccType) {\n          // Exclude CEA708 CC data.\n          actualCCBytes[ccType].push(ccbyte1);\n          actualCCBytes[ccType].push(ccbyte2);\n        }\n      }\n    }\n    return actualCCBytes;\n  }\n}\nfunction captionsOrSubtitlesFromCharacteristics(track) {\n  if (track.characteristics) {\n    if (/transcribes-spoken-dialog/gi.test(track.characteristics) && /describes-music-and-sound/gi.test(track.characteristics)) {\n      return 'captions';\n    }\n  }\n  return 'subtitles';\n}\nfunction canReuseVttTextTrack(inUseTrack, manifestTrack) {\n  return !!inUseTrack && inUseTrack.kind === captionsOrSubtitlesFromCharacteristics(manifestTrack) && subtitleTrackMatchesTextTrack(manifestTrack, inUseTrack);\n}\nfunction intersection(x1, x2, y1, y2) {\n  return Math.min(x2, y2) - Math.max(x1, y1);\n}\nfunction newVTTCCs() {\n  return {\n    ccOffset: 0,\n    presentationOffset: 0,\n    0: {\n      start: 0,\n      prevCC: -1,\n      new: true\n    }\n  };\n}\n\nconst WHITESPACE_CHAR = /\\s/;\nconst Cues = {\n  newCue(track, startTime, endTime, captionScreen) {\n    const result = [];\n    let row;\n    // the type data states this is VTTCue, but it can potentially be a TextTrackCue on old browsers\n    let cue;\n    let indenting;\n    let indent;\n    let text;\n    const Cue = self.VTTCue || self.TextTrackCue;\n    for (let r = 0; r < captionScreen.rows.length; r++) {\n      row = captionScreen.rows[r];\n      indenting = true;\n      indent = 0;\n      text = '';\n      if (!row.isEmpty()) {\n        var _track$cues;\n        for (let c = 0; c < row.chars.length; c++) {\n          if (WHITESPACE_CHAR.test(row.chars[c].uchar) && indenting) {\n            indent++;\n          } else {\n            text += row.chars[c].uchar;\n            indenting = false;\n          }\n        }\n        // To be used for cleaning-up orphaned roll-up captions\n        row.cueStartTime = startTime;\n\n        // Give a slight bump to the endTime if it's equal to startTime to avoid a SyntaxError in IE\n        if (startTime === endTime) {\n          endTime += 0.0001;\n        }\n        if (indent >= 16) {\n          indent--;\n        } else {\n          indent++;\n        }\n        const cueText = fixLineBreaks(text.trim());\n        const id = generateCueId(startTime, endTime, cueText);\n\n        // If this cue already exists in the track do not push it\n        if (!(track != null && (_track$cues = track.cues) != null && _track$cues.getCueById(id))) {\n          cue = new Cue(startTime, endTime, cueText);\n          cue.id = id;\n          cue.line = r + 1;\n          cue.align = 'left';\n          // Clamp the position between 10 and 80 percent (CEA-608 PAC indent code)\n          // https://dvcs.w3.org/hg/text-tracks/raw-file/default/608toVTT/608toVTT.html#positioning-in-cea-608\n          // Firefox throws an exception and captions break with out of bounds 0-100 values\n          cue.position = 10 + Math.min(80, Math.floor(indent * 8 / 32) * 10);\n          result.push(cue);\n        }\n      }\n    }\n    if (track && result.length) {\n      // Sort bottom cues in reverse order so that they render in line order when overlapping in Chrome\n      result.sort((cueA, cueB) => {\n        if (cueA.line === 'auto' || cueB.line === 'auto') {\n          return 0;\n        }\n        if (cueA.line > 8 && cueB.line > 8) {\n          return cueB.line - cueA.line;\n        }\n        return cueA.line - cueB.line;\n      });\n      result.forEach(cue => addCueToTrack(track, cue));\n    }\n    return result;\n  }\n};\n\nfunction fetchSupported() {\n  if (\n  // @ts-ignore\n  self.fetch && self.AbortController && self.ReadableStream && self.Request) {\n    try {\n      new self.ReadableStream({}); // eslint-disable-line no-new\n      return true;\n    } catch (e) {\n      /* noop */\n    }\n  }\n  return false;\n}\nconst BYTERANGE = /(\\d+)-(\\d+)\\/(\\d+)/;\nclass FetchLoader {\n  constructor(config) {\n    this.fetchSetup = void 0;\n    this.requestTimeout = void 0;\n    this.request = null;\n    this.response = null;\n    this.controller = void 0;\n    this.context = null;\n    this.config = null;\n    this.callbacks = null;\n    this.stats = void 0;\n    this.loader = null;\n    this.fetchSetup = config.fetchSetup || getRequest;\n    this.controller = new self.AbortController();\n    this.stats = new LoadStats();\n  }\n  destroy() {\n    this.loader = this.callbacks = this.context = this.config = this.request = null;\n    this.abortInternal();\n    this.response = null;\n    // @ts-ignore\n    this.fetchSetup = this.controller = this.stats = null;\n  }\n  abortInternal() {\n    if (this.controller && !this.stats.loading.end) {\n      this.stats.aborted = true;\n      this.controller.abort();\n    }\n  }\n  abort() {\n    var _this$callbacks;\n    this.abortInternal();\n    if ((_this$callbacks = this.callbacks) != null && _this$callbacks.onAbort) {\n      this.callbacks.onAbort(this.stats, this.context, this.response);\n    }\n  }\n  load(context, config, callbacks) {\n    const stats = this.stats;\n    if (stats.loading.start) {\n      throw new Error('Loader can only be used once.');\n    }\n    stats.loading.start = self.performance.now();\n    const initParams = getRequestParameters(context, this.controller.signal);\n    const isArrayBuffer = context.responseType === 'arraybuffer';\n    const LENGTH = isArrayBuffer ? 'byteLength' : 'length';\n    const {\n      maxTimeToFirstByteMs,\n      maxLoadTimeMs\n    } = config.loadPolicy;\n    this.context = context;\n    this.config = config;\n    this.callbacks = callbacks;\n    this.request = this.fetchSetup(context, initParams);\n    self.clearTimeout(this.requestTimeout);\n    config.timeout = maxTimeToFirstByteMs && isFiniteNumber(maxTimeToFirstByteMs) ? maxTimeToFirstByteMs : maxLoadTimeMs;\n    this.requestTimeout = self.setTimeout(() => {\n      if (this.callbacks) {\n        this.abortInternal();\n        this.callbacks.onTimeout(stats, context, this.response);\n      }\n    }, config.timeout);\n    const fetchPromise = isPromise(this.request) ? this.request.then(self.fetch) : self.fetch(this.request);\n    fetchPromise.then(response => {\n      var _this$callbacks2;\n      this.response = this.loader = response;\n      const first = Math.max(self.performance.now(), stats.loading.start);\n      self.clearTimeout(this.requestTimeout);\n      config.timeout = maxLoadTimeMs;\n      this.requestTimeout = self.setTimeout(() => {\n        if (this.callbacks) {\n          this.abortInternal();\n          this.callbacks.onTimeout(stats, context, this.response);\n        }\n      }, maxLoadTimeMs - (first - stats.loading.start));\n      if (!response.ok) {\n        const {\n          status,\n          statusText\n        } = response;\n        throw new FetchError(statusText || 'fetch, bad network response', status, response);\n      }\n      stats.loading.first = first;\n      stats.total = getContentLength(response.headers) || stats.total;\n      const onProgress = (_this$callbacks2 = this.callbacks) == null ? void 0 : _this$callbacks2.onProgress;\n      if (onProgress && isFiniteNumber(config.highWaterMark)) {\n        return this.loadProgressively(response, stats, context, config.highWaterMark, onProgress);\n      }\n      if (isArrayBuffer) {\n        return response.arrayBuffer();\n      }\n      if (context.responseType === 'json') {\n        return response.json();\n      }\n      return response.text();\n    }).then(responseData => {\n      var _this$callbacks3, _this$callbacks4;\n      const response = this.response;\n      if (!response) {\n        throw new Error('loader destroyed');\n      }\n      self.clearTimeout(this.requestTimeout);\n      stats.loading.end = Math.max(self.performance.now(), stats.loading.first);\n      const total = responseData[LENGTH];\n      if (total) {\n        stats.loaded = stats.total = total;\n      }\n      const loaderResponse = {\n        url: response.url,\n        data: responseData,\n        code: response.status\n      };\n      const onProgress = (_this$callbacks3 = this.callbacks) == null ? void 0 : _this$callbacks3.onProgress;\n      if (onProgress && !isFiniteNumber(config.highWaterMark)) {\n        onProgress(stats, context, responseData, response);\n      }\n      (_this$callbacks4 = this.callbacks) == null ? void 0 : _this$callbacks4.onSuccess(loaderResponse, stats, context, response);\n    }).catch(error => {\n      var _this$callbacks5;\n      self.clearTimeout(this.requestTimeout);\n      if (stats.aborted) {\n        return;\n      }\n      // CORS errors result in an undefined code. Set it to 0 here to align with XHR's behavior\n      // when destroying, 'error' itself can be undefined\n      const code = !error ? 0 : error.code || 0;\n      const text = !error ? null : error.message;\n      (_this$callbacks5 = this.callbacks) == null ? void 0 : _this$callbacks5.onError({\n        code,\n        text\n      }, context, error ? error.details : null, stats);\n    });\n  }\n  getCacheAge() {\n    let result = null;\n    if (this.response) {\n      const ageHeader = this.response.headers.get('age');\n      result = ageHeader ? parseFloat(ageHeader) : null;\n    }\n    return result;\n  }\n  getResponseHeader(name) {\n    return this.response ? this.response.headers.get(name) : null;\n  }\n  loadProgressively(response, stats, context, highWaterMark = 0, onProgress) {\n    const chunkCache = new ChunkCache();\n    const reader = response.body.getReader();\n    const pump = () => {\n      return reader.read().then(data => {\n        if (data.done) {\n          if (chunkCache.dataLength) {\n            onProgress(stats, context, chunkCache.flush().buffer, response);\n          }\n          return Promise.resolve(new ArrayBuffer(0));\n        }\n        const chunk = data.value;\n        const len = chunk.length;\n        stats.loaded += len;\n        if (len < highWaterMark || chunkCache.dataLength) {\n          // The current chunk is too small to to be emitted or the cache already has data\n          // Push it to the cache\n          chunkCache.push(chunk);\n          if (chunkCache.dataLength >= highWaterMark) {\n            // flush in order to join the typed arrays\n            onProgress(stats, context, chunkCache.flush().buffer, response);\n          }\n        } else {\n          // If there's nothing cached already, and the chache is large enough\n          // just emit the progress event\n          onProgress(stats, context, chunk.buffer, response);\n        }\n        return pump();\n      }).catch(() => {\n        /* aborted */\n        return Promise.reject();\n      });\n    };\n    return pump();\n  }\n}\nfunction getRequestParameters(context, signal) {\n  const initParams = {\n    method: 'GET',\n    mode: 'cors',\n    credentials: 'same-origin',\n    signal,\n    headers: new self.Headers(_extends({}, context.headers))\n  };\n  if (context.rangeEnd) {\n    initParams.headers.set('Range', 'bytes=' + context.rangeStart + '-' + String(context.rangeEnd - 1));\n  }\n  return initParams;\n}\nfunction getByteRangeLength(byteRangeHeader) {\n  const result = BYTERANGE.exec(byteRangeHeader);\n  if (result) {\n    return parseInt(result[2]) - parseInt(result[1]) + 1;\n  }\n}\nfunction getContentLength(headers) {\n  const contentRange = headers.get('Content-Range');\n  if (contentRange) {\n    const byteRangeLength = getByteRangeLength(contentRange);\n    if (isFiniteNumber(byteRangeLength)) {\n      return byteRangeLength;\n    }\n  }\n  const contentLength = headers.get('Content-Length');\n  if (contentLength) {\n    return parseInt(contentLength);\n  }\n}\nfunction getRequest(context, initParams) {\n  return new self.Request(context.url, initParams);\n}\nclass FetchError extends Error {\n  constructor(message, code, details) {\n    super(message);\n    this.code = void 0;\n    this.details = void 0;\n    this.code = code;\n    this.details = details;\n  }\n}\n\nconst AGE_HEADER_LINE_REGEX = /^age:\\s*[\\d.]+\\s*$/im;\nclass XhrLoader {\n  constructor(config) {\n    this.xhrSetup = void 0;\n    this.requestTimeout = void 0;\n    this.retryTimeout = void 0;\n    this.retryDelay = void 0;\n    this.config = null;\n    this.callbacks = null;\n    this.context = null;\n    this.loader = null;\n    this.stats = void 0;\n    this.xhrSetup = config ? config.xhrSetup || null : null;\n    this.stats = new LoadStats();\n    this.retryDelay = 0;\n  }\n  destroy() {\n    this.callbacks = null;\n    this.abortInternal();\n    this.loader = null;\n    this.config = null;\n    this.context = null;\n    this.xhrSetup = null;\n  }\n  abortInternal() {\n    const loader = this.loader;\n    self.clearTimeout(this.requestTimeout);\n    self.clearTimeout(this.retryTimeout);\n    if (loader) {\n      loader.onreadystatechange = null;\n      loader.onprogress = null;\n      if (loader.readyState !== 4) {\n        this.stats.aborted = true;\n        loader.abort();\n      }\n    }\n  }\n  abort() {\n    var _this$callbacks;\n    this.abortInternal();\n    if ((_this$callbacks = this.callbacks) != null && _this$callbacks.onAbort) {\n      this.callbacks.onAbort(this.stats, this.context, this.loader);\n    }\n  }\n  load(context, config, callbacks) {\n    if (this.stats.loading.start) {\n      throw new Error('Loader can only be used once.');\n    }\n    this.stats.loading.start = self.performance.now();\n    this.context = context;\n    this.config = config;\n    this.callbacks = callbacks;\n    this.loadInternal();\n  }\n  loadInternal() {\n    const {\n      config,\n      context\n    } = this;\n    if (!config || !context) {\n      return;\n    }\n    const xhr = this.loader = new self.XMLHttpRequest();\n    const stats = this.stats;\n    stats.loading.first = 0;\n    stats.loaded = 0;\n    stats.aborted = false;\n    const xhrSetup = this.xhrSetup;\n    if (xhrSetup) {\n      Promise.resolve().then(() => {\n        if (this.loader !== xhr || this.stats.aborted) return;\n        return xhrSetup(xhr, context.url);\n      }).catch(error => {\n        if (this.loader !== xhr || this.stats.aborted) return;\n        xhr.open('GET', context.url, true);\n        return xhrSetup(xhr, context.url);\n      }).then(() => {\n        if (this.loader !== xhr || this.stats.aborted) return;\n        this.openAndSendXhr(xhr, context, config);\n      }).catch(error => {\n        var _this$callbacks2;\n        // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS\n        (_this$callbacks2 = this.callbacks) == null ? void 0 : _this$callbacks2.onError({\n          code: xhr.status,\n          text: error.message\n        }, context, xhr, stats);\n        return;\n      });\n    } else {\n      this.openAndSendXhr(xhr, context, config);\n    }\n  }\n  openAndSendXhr(xhr, context, config) {\n    if (!xhr.readyState) {\n      xhr.open('GET', context.url, true);\n    }\n    const headers = context.headers;\n    const {\n      maxTimeToFirstByteMs,\n      maxLoadTimeMs\n    } = config.loadPolicy;\n    if (headers) {\n      for (const header in headers) {\n        xhr.setRequestHeader(header, headers[header]);\n      }\n    }\n    if (context.rangeEnd) {\n      xhr.setRequestHeader('Range', 'bytes=' + context.rangeStart + '-' + (context.rangeEnd - 1));\n    }\n    xhr.onreadystatechange = this.readystatechange.bind(this);\n    xhr.onprogress = this.loadprogress.bind(this);\n    xhr.responseType = context.responseType;\n    // setup timeout before we perform request\n    self.clearTimeout(this.requestTimeout);\n    config.timeout = maxTimeToFirstByteMs && isFiniteNumber(maxTimeToFirstByteMs) ? maxTimeToFirstByteMs : maxLoadTimeMs;\n    this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.timeout);\n    xhr.send();\n  }\n  readystatechange() {\n    const {\n      context,\n      loader: xhr,\n      stats\n    } = this;\n    if (!context || !xhr) {\n      return;\n    }\n    const readyState = xhr.readyState;\n    const config = this.config;\n\n    // don't proceed if xhr has been aborted\n    if (stats.aborted) {\n      return;\n    }\n\n    // >= HEADERS_RECEIVED\n    if (readyState >= 2) {\n      if (stats.loading.first === 0) {\n        stats.loading.first = Math.max(self.performance.now(), stats.loading.start);\n        // readyState >= 2 AND readyState !==4 (readyState = HEADERS_RECEIVED || LOADING) rearm timeout as xhr not finished yet\n        if (config.timeout !== config.loadPolicy.maxLoadTimeMs) {\n          self.clearTimeout(this.requestTimeout);\n          config.timeout = config.loadPolicy.maxLoadTimeMs;\n          this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.loadPolicy.maxLoadTimeMs - (stats.loading.first - stats.loading.start));\n        }\n      }\n      if (readyState === 4) {\n        self.clearTimeout(this.requestTimeout);\n        xhr.onreadystatechange = null;\n        xhr.onprogress = null;\n        const status = xhr.status;\n        // http status between 200 to 299 are all successful\n        const useResponseText = xhr.responseType === 'text' ? xhr.responseText : null;\n        if (status >= 200 && status < 300) {\n          const data = useResponseText != null ? useResponseText : xhr.response;\n          if (data != null) {\n            var _this$callbacks3, _this$callbacks4;\n            stats.loading.end = Math.max(self.performance.now(), stats.loading.first);\n            const len = xhr.responseType === 'arraybuffer' ? data.byteLength : data.length;\n            stats.loaded = stats.total = len;\n            stats.bwEstimate = stats.total * 8000 / (stats.loading.end - stats.loading.first);\n            const onProgress = (_this$callbacks3 = this.callbacks) == null ? void 0 : _this$callbacks3.onProgress;\n            if (onProgress) {\n              onProgress(stats, context, data, xhr);\n            }\n            const _response = {\n              url: xhr.responseURL,\n              data: data,\n              code: status\n            };\n            (_this$callbacks4 = this.callbacks) == null ? void 0 : _this$callbacks4.onSuccess(_response, stats, context, xhr);\n            return;\n          }\n        }\n\n        // Handle bad status or nullish response\n        const retryConfig = config.loadPolicy.errorRetry;\n        const retryCount = stats.retry;\n        // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error\n        const response = {\n          url: context.url,\n          data: undefined,\n          code: status\n        };\n        if (shouldRetry(retryConfig, retryCount, false, response)) {\n          this.retry(retryConfig);\n        } else {\n          var _this$callbacks5;\n          logger.error(`${status} while loading ${context.url}`);\n          (_this$callbacks5 = this.callbacks) == null ? void 0 : _this$callbacks5.onError({\n            code: status,\n            text: xhr.statusText\n          }, context, xhr, stats);\n        }\n      }\n    }\n  }\n  loadtimeout() {\n    if (!this.config) return;\n    const retryConfig = this.config.loadPolicy.timeoutRetry;\n    const retryCount = this.stats.retry;\n    if (shouldRetry(retryConfig, retryCount, true)) {\n      this.retry(retryConfig);\n    } else {\n      var _this$context;\n      logger.warn(`timeout while loading ${(_this$context = this.context) == null ? void 0 : _this$context.url}`);\n      const callbacks = this.callbacks;\n      if (callbacks) {\n        this.abortInternal();\n        callbacks.onTimeout(this.stats, this.context, this.loader);\n      }\n    }\n  }\n  retry(retryConfig) {\n    const {\n      context,\n      stats\n    } = this;\n    this.retryDelay = getRetryDelay(retryConfig, stats.retry);\n    stats.retry++;\n    logger.warn(`${status ? 'HTTP Status ' + status : 'Timeout'} while loading ${context == null ? void 0 : context.url}, retrying ${stats.retry}/${retryConfig.maxNumRetry} in ${this.retryDelay}ms`);\n    // abort and reset internal state\n    this.abortInternal();\n    this.loader = null;\n    // schedule retry\n    self.clearTimeout(this.retryTimeout);\n    this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay);\n  }\n  loadprogress(event) {\n    const stats = this.stats;\n    stats.loaded = event.loaded;\n    if (event.lengthComputable) {\n      stats.total = event.total;\n    }\n  }\n  getCacheAge() {\n    let result = null;\n    if (this.loader && AGE_HEADER_LINE_REGEX.test(this.loader.getAllResponseHeaders())) {\n      const ageHeader = this.loader.getResponseHeader('age');\n      result = ageHeader ? parseFloat(ageHeader) : null;\n    }\n    return result;\n  }\n  getResponseHeader(name) {\n    if (this.loader && new RegExp(`^${name}:\\\\s*[\\\\d.]+\\\\s*$`, 'im').test(this.loader.getAllResponseHeaders())) {\n      return this.loader.getResponseHeader(name);\n    }\n    return null;\n  }\n}\n\n/**\n * @deprecated use fragLoadPolicy.default\n */\n\n/**\n * @deprecated use manifestLoadPolicy.default and playlistLoadPolicy.default\n */\n\nconst defaultLoadPolicy = {\n  maxTimeToFirstByteMs: 8000,\n  maxLoadTimeMs: 20000,\n  timeoutRetry: null,\n  errorRetry: null\n};\n\n/**\n * @ignore\n * If possible, keep hlsDefaultConfig shallow\n * It is cloned whenever a new Hls instance is created, by keeping the config\n * shallow the properties are cloned, and we don't end up manipulating the default\n */\nconst hlsDefaultConfig = _objectSpread2(_objectSpread2({\n  autoStartLoad: true,\n  // used by stream-controller\n  startPosition: -1,\n  // used by stream-controller\n  defaultAudioCodec: undefined,\n  // used by stream-controller\n  debug: false,\n  // used by logger\n  capLevelOnFPSDrop: false,\n  // used by fps-controller\n  capLevelToPlayerSize: false,\n  // used by cap-level-controller\n  ignoreDevicePixelRatio: false,\n  // used by cap-level-controller\n  maxDevicePixelRatio: Number.POSITIVE_INFINITY,\n  // used by cap-level-controller\n  preferManagedMediaSource: true,\n  initialLiveManifestSize: 1,\n  // used by stream-controller\n  maxBufferLength: 30,\n  // used by stream-controller\n  backBufferLength: Infinity,\n  // used by buffer-controller\n  frontBufferFlushThreshold: Infinity,\n  startOnSegmentBoundary: false,\n  // used by stream-controller\n  maxBufferSize: 60 * 1000 * 1000,\n  // used by stream-controller\n  maxFragLookUpTolerance: 0.25,\n  // used by stream-controller\n  maxBufferHole: 0.1,\n  // used by stream-controller and gap-controller\n  detectStallWithCurrentTimeMs: 1250,\n  // used by gap-controller\n  highBufferWatchdogPeriod: 2,\n  // used by gap-controller\n  nudgeOffset: 0.1,\n  // used by gap-controller\n  nudgeMaxRetry: 3,\n  // used by gap-controller\n  nudgeOnVideoHole: true,\n  // used by gap-controller\n  liveSyncMode: 'edge',\n  // used by stream-controller\n  liveSyncDurationCount: 3,\n  // used by latency-controller\n  liveSyncOnStallIncrease: 1,\n  // used by latency-controller\n  liveMaxLatencyDurationCount: Infinity,\n  // used by latency-controller\n  liveSyncDuration: undefined,\n  // used by latency-controller\n  liveMaxLatencyDuration: undefined,\n  // used by latency-controller\n  maxLiveSyncPlaybackRate: 1,\n  // used by latency-controller\n  liveDurationInfinity: false,\n  // used by buffer-controller\n  /**\n   * @deprecated use backBufferLength\n   */\n  liveBackBufferLength: null,\n  // used by buffer-controller\n  maxMaxBufferLength: 600,\n  // used by stream-controller\n  enableWorker: true,\n  // used by transmuxer\n  workerPath: null,\n  // used by transmuxer\n  enableSoftwareAES: true,\n  // used by decrypter\n  startLevel: undefined,\n  // used by level-controller\n  startFragPrefetch: false,\n  // used by stream-controller\n  fpsDroppedMonitoringPeriod: 5000,\n  // used by fps-controller\n  fpsDroppedMonitoringThreshold: 0.2,\n  // used by fps-controller\n  appendErrorMaxRetry: 3,\n  // used by buffer-controller\n  ignorePlaylistParsingErrors: false,\n  loader: XhrLoader,\n  // loader: FetchLoader,\n  fLoader: undefined,\n  // used by fragment-loader\n  pLoader: undefined,\n  // used by playlist-loader\n  xhrSetup: undefined,\n  // used by xhr-loader\n  licenseXhrSetup: undefined,\n  // used by eme-controller\n  licenseResponseCallback: undefined,\n  // used by eme-controller\n  abrController: AbrController,\n  bufferController: BufferController,\n  capLevelController: CapLevelController,\n  errorController: ErrorController,\n  fpsController: FPSController,\n  stretchShortVideoTrack: false,\n  // used by mp4-remuxer\n  maxAudioFramesDrift: 1,\n  // used by mp4-remuxer\n  forceKeyFrameOnDiscontinuity: true,\n  // used by ts-demuxer\n  abrEwmaFastLive: 3,\n  // used by abr-controller\n  abrEwmaSlowLive: 9,\n  // used by abr-controller\n  abrEwmaFastVoD: 3,\n  // used by abr-controller\n  abrEwmaSlowVoD: 9,\n  // used by abr-controller\n  abrEwmaDefaultEstimate: 5e5,\n  // 500 kbps  // used by abr-controller\n  abrEwmaDefaultEstimateMax: 5e6,\n  // 5 mbps\n  abrBandWidthFactor: 0.95,\n  // used by abr-controller\n  abrBandWidthUpFactor: 0.7,\n  // used by abr-controller\n  abrMaxWithRealBitrate: false,\n  // used by abr-controller\n  maxStarvationDelay: 4,\n  // used by abr-controller\n  maxLoadingDelay: 4,\n  // used by abr-controller\n  minAutoBitrate: 0,\n  // used by hls\n  emeEnabled: false,\n  // used by eme-controller\n  widevineLicenseUrl: undefined,\n  // used by eme-controller\n  drmSystems: {},\n  // used by eme-controller\n  drmSystemOptions: {},\n  // used by eme-controller\n  requestMediaKeySystemAccessFunc: requestMediaKeySystemAccess ,\n  // used by eme-controller\n  requireKeySystemAccessOnStart: false,\n  // used by eme-controller\n  testBandwidth: true,\n  progressive: false,\n  lowLatencyMode: true,\n  cmcd: undefined,\n  enableDateRangeMetadataCues: true,\n  enableEmsgMetadataCues: true,\n  enableEmsgKLVMetadata: false,\n  enableID3MetadataCues: true,\n  enableInterstitialPlayback: true,\n  interstitialAppendInPlace: true,\n  interstitialLiveLookAhead: 10,\n  useMediaCapabilities: true,\n  preserveManualLevelOnError: false,\n  certLoadPolicy: {\n    default: defaultLoadPolicy\n  },\n  keyLoadPolicy: {\n    default: {\n      maxTimeToFirstByteMs: 8000,\n      maxLoadTimeMs: 20000,\n      timeoutRetry: {\n        maxNumRetry: 1,\n        retryDelayMs: 1000,\n        maxRetryDelayMs: 20000,\n        backoff: 'linear'\n      },\n      errorRetry: {\n        maxNumRetry: 8,\n        retryDelayMs: 1000,\n        maxRetryDelayMs: 20000,\n        backoff: 'linear'\n      }\n    }\n  },\n  manifestLoadPolicy: {\n    default: {\n      maxTimeToFirstByteMs: Infinity,\n      maxLoadTimeMs: 20000,\n      timeoutRetry: {\n        maxNumRetry: 2,\n        retryDelayMs: 0,\n        maxRetryDelayMs: 0\n      },\n      errorRetry: {\n        maxNumRetry: 1,\n        retryDelayMs: 1000,\n        maxRetryDelayMs: 8000\n      }\n    }\n  },\n  playlistLoadPolicy: {\n    default: {\n      maxTimeToFirstByteMs: 10000,\n      maxLoadTimeMs: 20000,\n      timeoutRetry: {\n        maxNumRetry: 2,\n        retryDelayMs: 0,\n        maxRetryDelayMs: 0\n      },\n      errorRetry: {\n        maxNumRetry: 2,\n        retryDelayMs: 1000,\n        maxRetryDelayMs: 8000\n      }\n    }\n  },\n  fragLoadPolicy: {\n    default: {\n      maxTimeToFirstByteMs: 10000,\n      maxLoadTimeMs: 120000,\n      timeoutRetry: {\n        maxNumRetry: 4,\n        retryDelayMs: 0,\n        maxRetryDelayMs: 0\n      },\n      errorRetry: {\n        maxNumRetry: 6,\n        retryDelayMs: 1000,\n        maxRetryDelayMs: 8000\n      }\n    }\n  },\n  steeringManifestLoadPolicy: {\n    default: {\n      maxTimeToFirstByteMs: 10000,\n      maxLoadTimeMs: 20000,\n      timeoutRetry: {\n        maxNumRetry: 2,\n        retryDelayMs: 0,\n        maxRetryDelayMs: 0\n      },\n      errorRetry: {\n        maxNumRetry: 1,\n        retryDelayMs: 1000,\n        maxRetryDelayMs: 8000\n      }\n    } \n  },\n  interstitialAssetListLoadPolicy: {\n    default: {\n      maxTimeToFirstByteMs: 10000,\n      maxLoadTimeMs: 30000,\n      timeoutRetry: {\n        maxNumRetry: 0,\n        retryDelayMs: 0,\n        maxRetryDelayMs: 0\n      },\n      errorRetry: {\n        maxNumRetry: 0,\n        retryDelayMs: 1000,\n        maxRetryDelayMs: 8000\n      }\n    } \n  },\n  // These default settings are deprecated in favor of the above policies\n  // and are maintained for backwards compatibility\n  manifestLoadingTimeOut: 10000,\n  manifestLoadingMaxRetry: 1,\n  manifestLoadingRetryDelay: 1000,\n  manifestLoadingMaxRetryTimeout: 64000,\n  levelLoadingTimeOut: 10000,\n  levelLoadingMaxRetry: 4,\n  levelLoadingRetryDelay: 1000,\n  levelLoadingMaxRetryTimeout: 64000,\n  fragLoadingTimeOut: 20000,\n  fragLoadingMaxRetry: 6,\n  fragLoadingRetryDelay: 1000,\n  fragLoadingMaxRetryTimeout: 64000\n}, timelineConfig()), {}, {\n  subtitleStreamController: SubtitleStreamController ,\n  subtitleTrackController: SubtitleTrackController ,\n  timelineController: TimelineController ,\n  audioStreamController: AudioStreamController ,\n  audioTrackController: AudioTrackController ,\n  emeController: EMEController ,\n  cmcdController: CMCDController ,\n  contentSteeringController: ContentSteeringController ,\n  interstitialsController: InterstitialsController \n});\nfunction timelineConfig() {\n  return {\n    cueHandler: Cues,\n    // used by timeline-controller\n    enableWebVTT: true,\n    // used by timeline-controller\n    enableIMSC1: true,\n    // used by timeline-controller\n    enableCEA708Captions: true,\n    // used by timeline-controller\n    captionsTextTrack1Label: 'English',\n    // used by timeline-controller\n    captionsTextTrack1LanguageCode: 'en',\n    // used by timeline-controller\n    captionsTextTrack2Label: 'Spanish',\n    // used by timeline-controller\n    captionsTextTrack2LanguageCode: 'es',\n    // used by timeline-controller\n    captionsTextTrack3Label: 'Unknown CC',\n    // used by timeline-controller\n    captionsTextTrack3LanguageCode: '',\n    // used by timeline-controller\n    captionsTextTrack4Label: 'Unknown CC',\n    // used by timeline-controller\n    captionsTextTrack4LanguageCode: '',\n    // used by timeline-controller\n    renderTextTracksNatively: true\n  };\n}\n\n/**\n * @ignore\n */\nfunction mergeConfig(defaultConfig, userConfig, logger) {\n  if ((userConfig.liveSyncDurationCount || userConfig.liveMaxLatencyDurationCount) && (userConfig.liveSyncDuration || userConfig.liveMaxLatencyDuration)) {\n    throw new Error(\"Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration\");\n  }\n  if (userConfig.liveMaxLatencyDurationCount !== undefined && (userConfig.liveSyncDurationCount === undefined || userConfig.liveMaxLatencyDurationCount <= userConfig.liveSyncDurationCount)) {\n    throw new Error('Illegal hls.js config: \"liveMaxLatencyDurationCount\" must be greater than \"liveSyncDurationCount\"');\n  }\n  if (userConfig.liveMaxLatencyDuration !== undefined && (userConfig.liveSyncDuration === undefined || userConfig.liveMaxLatencyDuration <= userConfig.liveSyncDuration)) {\n    throw new Error('Illegal hls.js config: \"liveMaxLatencyDuration\" must be greater than \"liveSyncDuration\"');\n  }\n  const defaultsCopy = deepCpy(defaultConfig);\n\n  // Backwards compatibility with deprecated config values\n  const deprecatedSettingTypes = ['manifest', 'level', 'frag'];\n  const deprecatedSettings = ['TimeOut', 'MaxRetry', 'RetryDelay', 'MaxRetryTimeout'];\n  deprecatedSettingTypes.forEach(type => {\n    const policyName = `${type === 'level' ? 'playlist' : type}LoadPolicy`;\n    const policyNotSet = userConfig[policyName] === undefined;\n    const report = [];\n    deprecatedSettings.forEach(setting => {\n      const deprecatedSetting = `${type}Loading${setting}`;\n      const value = userConfig[deprecatedSetting];\n      if (value !== undefined && policyNotSet) {\n        report.push(deprecatedSetting);\n        const settings = defaultsCopy[policyName].default;\n        userConfig[policyName] = {\n          default: settings\n        };\n        switch (setting) {\n          case 'TimeOut':\n            settings.maxLoadTimeMs = value;\n            settings.maxTimeToFirstByteMs = value;\n            break;\n          case 'MaxRetry':\n            settings.errorRetry.maxNumRetry = value;\n            settings.timeoutRetry.maxNumRetry = value;\n            break;\n          case 'RetryDelay':\n            settings.errorRetry.retryDelayMs = value;\n            settings.timeoutRetry.retryDelayMs = value;\n            break;\n          case 'MaxRetryTimeout':\n            settings.errorRetry.maxRetryDelayMs = value;\n            settings.timeoutRetry.maxRetryDelayMs = value;\n            break;\n        }\n      }\n    });\n    if (report.length) {\n      logger.warn(`hls.js config: \"${report.join('\", \"')}\" setting(s) are deprecated, use \"${policyName}\": ${stringify(userConfig[policyName])}`);\n    }\n  });\n  return _objectSpread2(_objectSpread2({}, defaultsCopy), userConfig);\n}\nfunction deepCpy(obj) {\n  if (obj && typeof obj === 'object') {\n    if (Array.isArray(obj)) {\n      return obj.map(deepCpy);\n    }\n    return Object.keys(obj).reduce((result, key) => {\n      result[key] = deepCpy(obj[key]);\n      return result;\n    }, {});\n  }\n  return obj;\n}\n\n/**\n * @ignore\n */\nfunction enableStreamingMode(config, logger) {\n  const currentLoader = config.loader;\n  if (currentLoader !== FetchLoader && currentLoader !== XhrLoader) {\n    // If a developer has configured their own loader, respect that choice\n    logger.log('[config]: Custom loader detected, cannot enable progressive streaming');\n    config.progressive = false;\n  } else {\n    const canStreamProgressively = fetchSupported();\n    if (canStreamProgressively) {\n      config.loader = FetchLoader;\n      config.progressive = true;\n      config.enableSoftwareAES = true;\n      logger.log('[config]: Progressive streaming enabled, using FetchLoader');\n    }\n  }\n}\n\nconst MAX_START_GAP_JUMP = 2.0;\nconst SKIP_BUFFER_HOLE_STEP_SECONDS = 0.1;\nconst SKIP_BUFFER_RANGE_START = 0.05;\nconst TICK_INTERVAL$1 = 100;\nclass GapController extends TaskLoop {\n  constructor(hls, fragmentTracker) {\n    super('gap-controller', hls.logger);\n    this.hls = null;\n    this.fragmentTracker = null;\n    this.media = null;\n    this.mediaSource = void 0;\n    this.nudgeRetry = 0;\n    this.stallReported = false;\n    this.stalled = null;\n    this.moved = false;\n    this.seeking = false;\n    this.buffered = {};\n    this.lastCurrentTime = 0;\n    this.ended = 0;\n    this.waiting = 0;\n    this.onMediaPlaying = () => {\n      this.ended = 0;\n      this.waiting = 0;\n    };\n    this.onMediaWaiting = () => {\n      var _this$media;\n      if ((_this$media = this.media) != null && _this$media.seeking) {\n        return;\n      }\n      this.waiting = self.performance.now();\n      this.tick();\n    };\n    this.onMediaEnded = () => {\n      if (this.hls) {\n        var _this$media2;\n        // ended is set when triggering MEDIA_ENDED so that we do not trigger it again on stall or on tick with media.ended\n        this.ended = ((_this$media2 = this.media) == null ? void 0 : _this$media2.currentTime) || 1;\n        this.hls.trigger(Events.MEDIA_ENDED, {\n          stalled: false\n        });\n      }\n    };\n    this.hls = hls;\n    this.fragmentTracker = fragmentTracker;\n    this.registerListeners();\n  }\n  registerListeners() {\n    const {\n      hls\n    } = this;\n    if (hls) {\n      hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n      hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n      hls.on(Events.BUFFER_APPENDED, this.onBufferAppended, this);\n    }\n  }\n  unregisterListeners() {\n    const {\n      hls\n    } = this;\n    if (hls) {\n      hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n      hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n      hls.off(Events.BUFFER_APPENDED, this.onBufferAppended, this);\n    }\n  }\n  destroy() {\n    super.destroy();\n    this.unregisterListeners();\n    this.media = this.hls = this.fragmentTracker = null;\n    this.mediaSource = undefined;\n  }\n  onMediaAttached(event, data) {\n    this.setInterval(TICK_INTERVAL$1);\n    this.mediaSource = data.mediaSource;\n    const media = this.media = data.media;\n    addEventListener(media, 'playing', this.onMediaPlaying);\n    addEventListener(media, 'waiting', this.onMediaWaiting);\n    addEventListener(media, 'ended', this.onMediaEnded);\n  }\n  onMediaDetaching(event, data) {\n    this.clearInterval();\n    const {\n      media\n    } = this;\n    if (media) {\n      removeEventListener(media, 'playing', this.onMediaPlaying);\n      removeEventListener(media, 'waiting', this.onMediaWaiting);\n      removeEventListener(media, 'ended', this.onMediaEnded);\n      this.media = null;\n    }\n    this.mediaSource = undefined;\n  }\n  onBufferAppended(event, data) {\n    this.buffered = data.timeRanges;\n  }\n  get hasBuffered() {\n    return Object.keys(this.buffered).length > 0;\n  }\n  tick() {\n    var _this$media3;\n    if (!((_this$media3 = this.media) != null && _this$media3.readyState) || !this.hasBuffered) {\n      return;\n    }\n    const currentTime = this.media.currentTime;\n    this.poll(currentTime, this.lastCurrentTime);\n    this.lastCurrentTime = currentTime;\n  }\n\n  /**\n   * Checks if the playhead is stuck within a gap, and if so, attempts to free it.\n   * A gap is an unbuffered range between two buffered ranges (or the start and the first buffered range).\n   *\n   * @param lastCurrentTime - Previously read playhead position\n   */\n  poll(currentTime, lastCurrentTime) {\n    var _this$hls, _this$hls2;\n    const config = (_this$hls = this.hls) == null ? void 0 : _this$hls.config;\n    if (!config) {\n      return;\n    }\n    const media = this.media;\n    if (!media) {\n      return;\n    }\n    const {\n      seeking\n    } = media;\n    const seeked = this.seeking && !seeking;\n    const beginSeek = !this.seeking && seeking;\n    const pausedEndedOrHalted = media.paused && !seeking || media.ended || media.playbackRate === 0;\n    this.seeking = seeking;\n\n    // The playhead is moving, no-op\n    if (currentTime !== lastCurrentTime) {\n      if (lastCurrentTime) {\n        this.ended = 0;\n      }\n      this.moved = true;\n      if (!seeking) {\n        this.nudgeRetry = 0;\n        // When crossing between buffered video time ranges, but not audio, flush pipeline with seek (Chrome)\n        if (config.nudgeOnVideoHole && !pausedEndedOrHalted && currentTime > lastCurrentTime) {\n          this.nudgeOnVideoHole(currentTime, lastCurrentTime);\n        }\n      }\n      if (this.waiting === 0) {\n        this.stallResolved(currentTime);\n      }\n      return;\n    }\n\n    // Clear stalled state when beginning or finishing seeking so that we don't report stalls coming out of a seek\n    if (beginSeek || seeked) {\n      if (seeked) {\n        this.stallResolved(currentTime);\n      }\n      return;\n    }\n\n    // The playhead should not be moving\n    if (pausedEndedOrHalted) {\n      this.nudgeRetry = 0;\n      this.stallResolved(currentTime);\n      // Fire MEDIA_ENDED to workaround event not being dispatched by browser\n      if (!this.ended && media.ended && this.hls) {\n        this.ended = currentTime || 1;\n        this.hls.trigger(Events.MEDIA_ENDED, {\n          stalled: false\n        });\n      }\n      return;\n    }\n    if (!BufferHelper.getBuffered(media).length) {\n      this.nudgeRetry = 0;\n      return;\n    }\n\n    // Resolve stalls at buffer holes using the main buffer, whose ranges are the intersections of the A/V sourcebuffers\n    const bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);\n    const nextStart = bufferInfo.nextStart || 0;\n    const fragmentTracker = this.fragmentTracker;\n    if (seeking && fragmentTracker && this.hls) {\n      // Is there a fragment loading/parsing/appending before currentTime?\n      const inFlightDependency = getInFlightDependency(this.hls.inFlightFragments, currentTime);\n\n      // Waiting for seeking in a buffered range to complete\n      const hasEnoughBuffer = bufferInfo.len > MAX_START_GAP_JUMP;\n      // Next buffered range is too far ahead to jump to while still seeking\n      const noBufferHole = !nextStart || inFlightDependency || nextStart - currentTime > MAX_START_GAP_JUMP && !fragmentTracker.getPartialFragment(currentTime);\n      if (hasEnoughBuffer || noBufferHole) {\n        return;\n      }\n      // Reset moved state when seeking to a point in or before a gap/hole\n      this.moved = false;\n    }\n\n    // Skip start gaps if we haven't played, but the last poll detected the start of a stall\n    // The addition poll gives the browser a chance to jump the gap for us\n    const levelDetails = (_this$hls2 = this.hls) == null ? void 0 : _this$hls2.latestLevelDetails;\n    if (!this.moved && this.stalled !== null && fragmentTracker) {\n      // There is no playable buffer (seeked, waiting for buffer)\n      const isBuffered = bufferInfo.len > 0;\n      if (!isBuffered && !nextStart) {\n        return;\n      }\n      // Jump start gaps within jump threshold\n      const startJump = Math.max(nextStart, bufferInfo.start || 0) - currentTime;\n\n      // When joining a live stream with audio tracks, account for live playlist window sliding by allowing\n      // a larger jump over start gaps caused by the audio-stream-controller buffering a start fragment\n      // that begins over 1 target duration after the video start position.\n      const isLive = !!(levelDetails != null && levelDetails.live);\n      const maxStartGapJump = isLive ? levelDetails.targetduration * 2 : MAX_START_GAP_JUMP;\n      const partialOrGap = fragmentTracker.getPartialFragment(currentTime);\n      if (startJump > 0 && (startJump <= maxStartGapJump || partialOrGap)) {\n        if (!media.paused) {\n          this._trySkipBufferHole(partialOrGap);\n        }\n        return;\n      }\n    }\n\n    // Start tracking stall time\n    const detectStallWithCurrentTimeMs = config.detectStallWithCurrentTimeMs;\n    const tnow = self.performance.now();\n    const tWaiting = this.waiting;\n    let stalled = this.stalled;\n    if (stalled === null) {\n      // Use time of recent \"waiting\" event\n      if (tWaiting > 0 && tnow - tWaiting < detectStallWithCurrentTimeMs) {\n        stalled = this.stalled = tWaiting;\n      } else {\n        this.stalled = tnow;\n        return;\n      }\n    }\n    const stalledDuration = tnow - stalled;\n    if (!seeking && (stalledDuration >= detectStallWithCurrentTimeMs || tWaiting) && this.hls) {\n      var _this$mediaSource;\n      // Dispatch MEDIA_ENDED when media.ended/ended event is not signalled at end of stream\n      if (((_this$mediaSource = this.mediaSource) == null ? void 0 : _this$mediaSource.readyState) === 'ended' && !(levelDetails != null && levelDetails.live) && Math.abs(currentTime - ((levelDetails == null ? void 0 : levelDetails.edge) || 0)) < 1) {\n        if (this.ended) {\n          return;\n        }\n        this.ended = currentTime || 1;\n        this.hls.trigger(Events.MEDIA_ENDED, {\n          stalled: true\n        });\n        return;\n      }\n      // Report stalling after trying to fix\n      this._reportStall(bufferInfo);\n      if (!this.media || !this.hls) {\n        return;\n      }\n    }\n    const bufferedWithHoles = BufferHelper.bufferInfo(media, currentTime, config.maxBufferHole);\n    this._tryFixBufferStall(bufferedWithHoles, stalledDuration, currentTime);\n  }\n  stallResolved(currentTime) {\n    const stalled = this.stalled;\n    if (stalled && this.hls) {\n      this.stalled = null;\n      // The playhead is now moving, but was previously stalled\n      if (this.stallReported) {\n        const stalledDuration = self.performance.now() - stalled;\n        this.log(`playback not stuck anymore @${currentTime}, after ${Math.round(stalledDuration)}ms`);\n        this.stallReported = false;\n        this.waiting = 0;\n        this.hls.trigger(Events.STALL_RESOLVED, {});\n      }\n    }\n  }\n  nudgeOnVideoHole(currentTime, lastCurrentTime) {\n    var _this$buffered$audio;\n    // Chrome will play one second past a hole in video buffered time ranges without rendering any video from the subsequent range and then stall as long as audio is buffered:\n    // https://github.com/video-dev/hls.js/issues/5631\n    // https://issues.chromium.org/issues/40280613#comment10\n    // Detect the potential for this situation and proactively seek to flush the video pipeline once the playhead passes the start of the video hole.\n    // When there are audio and video buffers and currentTime is past the end of the first video buffered range...\n    const videoSourceBuffered = this.buffered.video;\n    if (this.hls && this.media && this.fragmentTracker && (_this$buffered$audio = this.buffered.audio) != null && _this$buffered$audio.length && videoSourceBuffered && videoSourceBuffered.length > 1 && currentTime > videoSourceBuffered.end(0)) {\n      // and audio is buffered at the playhead\n      const audioBufferInfo = BufferHelper.bufferedInfo(BufferHelper.timeRangesToArray(this.buffered.audio), currentTime, 0);\n      if (audioBufferInfo.len > 1 && lastCurrentTime >= audioBufferInfo.start) {\n        const videoTimes = BufferHelper.timeRangesToArray(videoSourceBuffered);\n        const lastBufferedIndex = BufferHelper.bufferedInfo(videoTimes, lastCurrentTime, 0).bufferedIndex;\n        // nudge when crossing into another video buffered range (hole).\n        if (lastBufferedIndex > -1 && lastBufferedIndex < videoTimes.length - 1) {\n          const bufferedIndex = BufferHelper.bufferedInfo(videoTimes, currentTime, 0).bufferedIndex;\n          const holeStart = videoTimes[lastBufferedIndex].end;\n          const holeEnd = videoTimes[lastBufferedIndex + 1].start;\n          if ((bufferedIndex === -1 || bufferedIndex > lastBufferedIndex) && holeEnd - holeStart < 1 &&\n          // `maxBufferHole` may be too small and setting it to 0 should not disable this feature\n          currentTime - holeStart < 2) {\n            const error = new Error(`nudging playhead to flush pipeline after video hole. currentTime: ${currentTime} hole: ${holeStart} -> ${holeEnd} buffered index: ${bufferedIndex}`);\n            this.warn(error.message);\n            // Magic number to flush the pipeline without interuption to audio playback:\n            this.media.currentTime += 0.000001;\n            const frag = this.fragmentTracker.getPartialFragment(currentTime) || undefined;\n            const bufferInfo = BufferHelper.bufferInfo(this.media, currentTime, 0);\n            this.hls.trigger(Events.ERROR, {\n              type: ErrorTypes.MEDIA_ERROR,\n              details: ErrorDetails.BUFFER_SEEK_OVER_HOLE,\n              fatal: false,\n              error,\n              reason: error.message,\n              frag,\n              buffer: bufferInfo.len,\n              bufferInfo\n            });\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Detects and attempts to fix known buffer stalling issues.\n   * @param bufferInfo - The properties of the current buffer.\n   * @param stalledDurationMs - The amount of time Hls.js has been stalling for.\n   * @private\n   */\n  _tryFixBufferStall(bufferInfo, stalledDurationMs, currentTime) {\n    var _this$hls3, _this$hls4;\n    const {\n      fragmentTracker,\n      media\n    } = this;\n    const config = (_this$hls3 = this.hls) == null ? void 0 : _this$hls3.config;\n    if (!media || !fragmentTracker || !config) {\n      return;\n    }\n    const levelDetails = (_this$hls4 = this.hls) == null ? void 0 : _this$hls4.latestLevelDetails;\n    const partial = fragmentTracker.getPartialFragment(currentTime);\n    if (partial || levelDetails != null && levelDetails.live && currentTime < levelDetails.fragmentStart) {\n      // Try to skip over the buffer hole caused by a partial fragment\n      // This method isn't limited by the size of the gap between buffered ranges\n      const targetTime = this._trySkipBufferHole(partial);\n      // we return here in this case, meaning\n      // the branch below only executes when we haven't seeked to a new position\n      if (targetTime || !this.media) {\n        return;\n      }\n    }\n\n    // if we haven't had to skip over a buffer hole of a partial fragment\n    // we may just have to \"nudge\" the playlist as the browser decoding/rendering engine\n    // needs to cross some sort of threshold covering all source-buffers content\n    // to start playing properly.\n    const bufferedRanges = bufferInfo.buffered;\n    const adjacentTraversal = this.adjacentTraversal(bufferInfo, currentTime);\n    if ((bufferedRanges && bufferedRanges.length > 1 && bufferInfo.len > config.maxBufferHole || bufferInfo.nextStart && (bufferInfo.nextStart - currentTime < config.maxBufferHole || adjacentTraversal)) && (stalledDurationMs > config.highBufferWatchdogPeriod * 1000 || this.waiting)) {\n      this.warn('Trying to nudge playhead over buffer-hole');\n      // Try to nudge currentTime over a buffer hole if we've been stalling for the configured amount of seconds\n      // We only try to jump the hole if it's under the configured size\n      this._tryNudgeBuffer(bufferInfo);\n    }\n  }\n  adjacentTraversal(bufferInfo, currentTime) {\n    const fragmentTracker = this.fragmentTracker;\n    const nextStart = bufferInfo.nextStart;\n    if (fragmentTracker && nextStart) {\n      const current = fragmentTracker.getFragAtPos(currentTime, PlaylistLevelType.MAIN);\n      const next = fragmentTracker.getFragAtPos(nextStart, PlaylistLevelType.MAIN);\n      if (current && next) {\n        return next.sn - current.sn < 2;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Triggers a BUFFER_STALLED_ERROR event, but only once per stall period.\n   * @param bufferLen - The playhead distance from the end of the current buffer segment.\n   * @private\n   */\n  _reportStall(bufferInfo) {\n    const {\n      hls,\n      media,\n      stallReported,\n      stalled\n    } = this;\n    if (!stallReported && stalled !== null && media && hls) {\n      // Report stalled error once\n      this.stallReported = true;\n      const error = new Error(`Playback stalling at @${media.currentTime} due to low buffer (${stringify(bufferInfo)})`);\n      this.warn(error.message);\n      hls.trigger(Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.BUFFER_STALLED_ERROR,\n        fatal: false,\n        error,\n        buffer: bufferInfo.len,\n        bufferInfo,\n        stalled: {\n          start: stalled\n        }\n      });\n    }\n  }\n\n  /**\n   * Attempts to fix buffer stalls by jumping over known gaps caused by partial fragments\n   * @param partial - The partial fragment found at the current time (where playback is stalling).\n   * @private\n   */\n  _trySkipBufferHole(partial) {\n    var _this$hls5;\n    const {\n      fragmentTracker,\n      media\n    } = this;\n    const config = (_this$hls5 = this.hls) == null ? void 0 : _this$hls5.config;\n    if (!media || !fragmentTracker || !config) {\n      return 0;\n    }\n\n    // Check if currentTime is between unbuffered regions of partial fragments\n    const currentTime = media.currentTime;\n    const bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);\n    const startTime = currentTime < bufferInfo.start ? bufferInfo.start : bufferInfo.nextStart;\n    if (startTime && this.hls) {\n      const bufferStarved = bufferInfo.len <= config.maxBufferHole;\n      const waiting = bufferInfo.len > 0 && bufferInfo.len < 1 && media.readyState < 3;\n      const gapLength = startTime - currentTime;\n      if (gapLength > 0 && (bufferStarved || waiting)) {\n        // Only allow large gaps to be skipped if it is a start gap, or all fragments in skip range are partial\n        if (gapLength > config.maxBufferHole) {\n          let startGap = false;\n          if (currentTime === 0) {\n            const startFrag = fragmentTracker.getAppendedFrag(0, PlaylistLevelType.MAIN);\n            if (startFrag && startTime < startFrag.end) {\n              startGap = true;\n            }\n          }\n          if (!startGap) {\n            const startProvisioned = partial || fragmentTracker.getAppendedFrag(currentTime, PlaylistLevelType.MAIN);\n            if (startProvisioned) {\n              var _this$hls$loadLevelOb;\n              // Do not seek when selected variant playlist is unloaded\n              if (!((_this$hls$loadLevelOb = this.hls.loadLevelObj) != null && _this$hls$loadLevelOb.details)) {\n                return 0;\n              }\n              // Do not seek when required fragments are inflight or appending\n              const inFlightDependency = getInFlightDependency(this.hls.inFlightFragments, startTime);\n              if (inFlightDependency) {\n                return 0;\n              }\n              // Do not seek if we can't walk tracked fragments to end of gap\n              let moreToLoad = false;\n              let pos = startProvisioned.end;\n              while (pos < startTime) {\n                const provisioned = fragmentTracker.getAppendedFrag(pos, PlaylistLevelType.MAIN) || fragmentTracker.getPartialFragment(pos);\n                if (provisioned) {\n                  pos += provisioned.duration;\n                } else {\n                  moreToLoad = true;\n                  break;\n                }\n              }\n              if (moreToLoad) {\n                return 0;\n              }\n            }\n          }\n        }\n        const targetTime = Math.max(startTime + SKIP_BUFFER_RANGE_START, currentTime + SKIP_BUFFER_HOLE_STEP_SECONDS);\n        this.warn(`skipping hole, adjusting currentTime from ${currentTime} to ${targetTime}`);\n        this.moved = true;\n        media.currentTime = targetTime;\n        if (!(partial != null && partial.gap)) {\n          const error = new Error(`fragment loaded with buffer holes, seeking from ${currentTime} to ${targetTime}`);\n          this.hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.BUFFER_SEEK_OVER_HOLE,\n            fatal: false,\n            error,\n            reason: error.message,\n            frag: partial || undefined,\n            buffer: bufferInfo.len,\n            bufferInfo\n          });\n        }\n        return targetTime;\n      }\n    }\n    return 0;\n  }\n\n  /**\n   * Attempts to fix buffer stalls by advancing the mediaElement's current time by a small amount.\n   * @private\n   */\n  _tryNudgeBuffer(bufferInfo) {\n    const {\n      hls,\n      media,\n      nudgeRetry\n    } = this;\n    const config = hls == null ? void 0 : hls.config;\n    if (!media || !config) {\n      return 0;\n    }\n    const currentTime = media.currentTime;\n    this.nudgeRetry++;\n    if (nudgeRetry < config.nudgeMaxRetry) {\n      const targetTime = currentTime + (nudgeRetry + 1) * config.nudgeOffset;\n      // playback stalled in buffered area ... let's nudge currentTime to try to overcome this\n      const error = new Error(`Nudging 'currentTime' from ${currentTime} to ${targetTime}`);\n      this.warn(error.message);\n      media.currentTime = targetTime;\n      hls.trigger(Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.BUFFER_NUDGE_ON_STALL,\n        error,\n        fatal: false,\n        buffer: bufferInfo.len,\n        bufferInfo\n      });\n    } else {\n      const error = new Error(`Playhead still not moving while enough data buffered @${currentTime} after ${config.nudgeMaxRetry} nudges`);\n      this.error(error.message);\n      hls.trigger(Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.BUFFER_STALLED_ERROR,\n        error,\n        fatal: true,\n        buffer: bufferInfo.len,\n        bufferInfo\n      });\n    }\n  }\n}\nfunction getInFlightDependency(inFlightFragments, currentTime) {\n  const main = inFlight(inFlightFragments.main);\n  if (main && main.start <= currentTime) {\n    return main;\n  }\n  const audio = inFlight(inFlightFragments.audio);\n  if (audio && audio.start <= currentTime) {\n    return audio;\n  }\n  return null;\n}\nfunction inFlight(inFlightData) {\n  if (!inFlightData) {\n    return null;\n  }\n  switch (inFlightData.state) {\n    case State.IDLE:\n    case State.STOPPED:\n    case State.ENDED:\n    case State.ERROR:\n      return null;\n  }\n  return inFlightData.frag;\n}\n\nconst MIN_CUE_DURATION = 0.25;\nfunction getCueClass() {\n  if (typeof self === 'undefined') return undefined;\n  return self.VTTCue || self.TextTrackCue;\n}\nfunction createCueWithDataFields(Cue, startTime, endTime, data, type) {\n  let cue = new Cue(startTime, endTime, '');\n  try {\n    cue.value = data;\n    if (type) {\n      cue.type = type;\n    }\n  } catch (e) {\n    cue = new Cue(startTime, endTime, stringify(type ? _objectSpread2({\n      type\n    }, data) : data));\n  }\n  return cue;\n}\n\n// VTTCue latest draft allows an infinite duration, fallback\n// to MAX_VALUE if necessary\nconst MAX_CUE_ENDTIME = (() => {\n  const Cue = getCueClass();\n  try {\n    Cue && new Cue(0, Number.POSITIVE_INFINITY, '');\n  } catch (e) {\n    return Number.MAX_VALUE;\n  }\n  return Number.POSITIVE_INFINITY;\n})();\nclass ID3TrackController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.id3Track = null;\n    this.media = null;\n    this.dateRangeCuesAppended = {};\n    this.removeCues = true;\n    this.onEventCueEnter = () => {\n      if (!this.hls) {\n        return;\n      }\n      this.hls.trigger(Events.EVENT_CUE_ENTER, {});\n    };\n    this.hls = hls;\n    this._registerListeners();\n  }\n  destroy() {\n    this._unregisterListeners();\n    this.id3Track = null;\n    this.media = null;\n    this.dateRangeCuesAppended = {};\n    // @ts-ignore\n    this.hls = this.onEventCueEnter = null;\n  }\n  _registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);\n    hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    hls.on(Events.LEVEL_PTS_UPDATED, this.onLevelPtsUpdated, this);\n  }\n  _unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);\n    hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    hls.off(Events.LEVEL_PTS_UPDATED, this.onLevelPtsUpdated, this);\n  }\n  // Add ID3 metatadata text track.\n  onMediaAttaching(event, data) {\n    var _data$overrides;\n    this.media = data.media;\n    if (((_data$overrides = data.overrides) == null ? void 0 : _data$overrides.cueRemoval) === false) {\n      this.removeCues = false;\n    }\n  }\n  onMediaAttached() {\n    const details = this.hls.latestLevelDetails;\n    if (details) {\n      this.updateDateRangeCues(details);\n    }\n  }\n  onMediaDetaching(event, data) {\n    this.media = null;\n    const transferringMedia = !!data.transferMedia;\n    if (transferringMedia) {\n      return;\n    }\n    if (this.id3Track) {\n      if (this.removeCues) {\n        clearCurrentCues(this.id3Track, this.onEventCueEnter);\n      }\n      this.id3Track = null;\n    }\n    this.dateRangeCuesAppended = {};\n  }\n  onManifestLoading() {\n    this.dateRangeCuesAppended = {};\n  }\n  createTrack(media) {\n    const track = this.getID3Track(media.textTracks);\n    track.mode = 'hidden';\n    return track;\n  }\n  getID3Track(textTracks) {\n    if (!this.media) {\n      return;\n    }\n    for (let i = 0; i < textTracks.length; i++) {\n      const textTrack = textTracks[i];\n      if (textTrack.kind === 'metadata' && textTrack.label === 'id3') {\n        // send 'addtrack' when reusing the textTrack for metadata,\n        // same as what we do for captions\n        sendAddTrackEvent(textTrack, this.media);\n        return textTrack;\n      }\n    }\n    return this.media.addTextTrack('metadata', 'id3');\n  }\n  onFragParsingMetadata(event, data) {\n    if (!this.media) {\n      return;\n    }\n    const {\n      hls: {\n        config: {\n          enableEmsgMetadataCues,\n          enableID3MetadataCues\n        }\n      }\n    } = this;\n    if (!enableEmsgMetadataCues && !enableID3MetadataCues) {\n      return;\n    }\n    const {\n      samples\n    } = data;\n\n    // create track dynamically\n    if (!this.id3Track) {\n      this.id3Track = this.createTrack(this.media);\n    }\n    const Cue = getCueClass();\n    if (!Cue) {\n      return;\n    }\n    for (let i = 0; i < samples.length; i++) {\n      const type = samples[i].type;\n      if (type === MetadataSchema.emsg && !enableEmsgMetadataCues || !enableID3MetadataCues) {\n        continue;\n      }\n      const frames = getId3Frames(samples[i].data);\n      if (frames) {\n        const startTime = samples[i].pts;\n        let endTime = startTime + samples[i].duration;\n        if (endTime > MAX_CUE_ENDTIME) {\n          endTime = MAX_CUE_ENDTIME;\n        }\n        const timeDiff = endTime - startTime;\n        if (timeDiff <= 0) {\n          endTime = startTime + MIN_CUE_DURATION;\n        }\n        for (let j = 0; j < frames.length; j++) {\n          const frame = frames[j];\n          // Safari doesn't put the timestamp frame in the TextTrack\n          if (!isId3TimestampFrame(frame)) {\n            // add a bounds to any unbounded cues\n            this.updateId3CueEnds(startTime, type);\n            const cue = createCueWithDataFields(Cue, startTime, endTime, frame, type);\n            if (cue) {\n              this.id3Track.addCue(cue);\n            }\n          }\n        }\n      }\n    }\n  }\n  updateId3CueEnds(startTime, type) {\n    var _this$id3Track;\n    const cues = (_this$id3Track = this.id3Track) == null ? void 0 : _this$id3Track.cues;\n    if (cues) {\n      for (let i = cues.length; i--;) {\n        const cue = cues[i];\n        if (cue.type === type && cue.startTime < startTime && cue.endTime === MAX_CUE_ENDTIME) {\n          cue.endTime = startTime;\n        }\n      }\n    }\n  }\n  onBufferFlushing(event, {\n    startOffset,\n    endOffset,\n    type\n  }) {\n    const {\n      id3Track,\n      hls\n    } = this;\n    if (!hls) {\n      return;\n    }\n    const {\n      config: {\n        enableEmsgMetadataCues,\n        enableID3MetadataCues\n      }\n    } = hls;\n    if (id3Track && (enableEmsgMetadataCues || enableID3MetadataCues)) {\n      let predicate;\n      if (type === 'audio') {\n        predicate = cue => cue.type === MetadataSchema.audioId3 && enableID3MetadataCues;\n      } else if (type === 'video') {\n        predicate = cue => cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;\n      } else {\n        predicate = cue => cue.type === MetadataSchema.audioId3 && enableID3MetadataCues || cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;\n      }\n      removeCuesInRange(id3Track, startOffset, endOffset, predicate);\n    }\n  }\n  onLevelUpdated(event, {\n    details\n  }) {\n    this.updateDateRangeCues(details, true);\n  }\n  onLevelPtsUpdated(event, data) {\n    if (Math.abs(data.drift) > 0.01) {\n      this.updateDateRangeCues(data.details);\n    }\n  }\n  updateDateRangeCues(details, removeOldCues) {\n    if (!this.media || !details.hasProgramDateTime || !this.hls.config.enableDateRangeMetadataCues) {\n      return;\n    }\n    const {\n      id3Track\n    } = this;\n    const {\n      dateRanges\n    } = details;\n    const ids = Object.keys(dateRanges);\n    let dateRangeCuesAppended = this.dateRangeCuesAppended;\n    // Remove cues from track not found in details.dateRanges\n    if (id3Track && removeOldCues) {\n      var _id3Track$cues;\n      if ((_id3Track$cues = id3Track.cues) != null && _id3Track$cues.length) {\n        const idsToRemove = Object.keys(dateRangeCuesAppended).filter(id => !ids.includes(id));\n        for (let i = idsToRemove.length; i--;) {\n          const id = idsToRemove[i];\n          const cues = dateRangeCuesAppended[id].cues;\n          delete dateRangeCuesAppended[id];\n          Object.keys(cues).forEach(key => {\n            try {\n              const cue = cues[key];\n              cue.removeEventListener('enter', this.onEventCueEnter);\n              id3Track.removeCue(cue);\n            } catch (e) {\n              /* no-op */\n            }\n          });\n        }\n      } else {\n        dateRangeCuesAppended = this.dateRangeCuesAppended = {};\n      }\n    }\n    // Exit if the playlist does not have Date Ranges or does not have Program Date Time\n    const lastFragment = details.fragments[details.fragments.length - 1];\n    if (ids.length === 0 || !isFiniteNumber(lastFragment == null ? void 0 : lastFragment.programDateTime)) {\n      return;\n    }\n    if (!this.id3Track) {\n      this.id3Track = this.createTrack(this.media);\n    }\n    const Cue = getCueClass();\n    for (let i = 0; i < ids.length; i++) {\n      const id = ids[i];\n      const dateRange = dateRanges[id];\n      const startTime = dateRange.startTime;\n\n      // Process DateRanges to determine end-time (known DURATION, END-DATE, or END-ON-NEXT)\n      const appendedDateRangeCues = dateRangeCuesAppended[id];\n      const cues = (appendedDateRangeCues == null ? void 0 : appendedDateRangeCues.cues) || {};\n      let durationKnown = (appendedDateRangeCues == null ? void 0 : appendedDateRangeCues.durationKnown) || false;\n      let endTime = MAX_CUE_ENDTIME;\n      const {\n        duration,\n        endDate\n      } = dateRange;\n      if (endDate && duration !== null) {\n        endTime = startTime + duration;\n        durationKnown = true;\n      } else if (dateRange.endOnNext && !durationKnown) {\n        const nextDateRangeWithSameClass = ids.reduce((candidateDateRange, id) => {\n          if (id !== dateRange.id) {\n            const otherDateRange = dateRanges[id];\n            if (otherDateRange.class === dateRange.class && otherDateRange.startDate > dateRange.startDate && (!candidateDateRange || dateRange.startDate < candidateDateRange.startDate)) {\n              return otherDateRange;\n            }\n          }\n          return candidateDateRange;\n        }, null);\n        if (nextDateRangeWithSameClass) {\n          endTime = nextDateRangeWithSameClass.startTime;\n          durationKnown = true;\n        }\n      }\n\n      // Create TextTrack Cues for each MetadataGroup Item (select DateRange attribute)\n      // This is to emulate Safari HLS playback handling of DateRange tags\n      const attributes = Object.keys(dateRange.attr);\n      for (let j = 0; j < attributes.length; j++) {\n        const key = attributes[j];\n        if (!isDateRangeCueAttribute(key)) {\n          continue;\n        }\n        const cue = cues[key];\n        if (cue) {\n          if (durationKnown && !appendedDateRangeCues.durationKnown) {\n            cue.endTime = endTime;\n          } else if (Math.abs(cue.startTime - startTime) > 0.01) {\n            cue.startTime = startTime;\n            cue.endTime = endTime;\n          }\n        } else if (Cue) {\n          let data = dateRange.attr[key];\n          if (isSCTE35Attribute(key)) {\n            data = hexToArrayBuffer(data);\n          }\n          const payload = {\n            key,\n            data\n          };\n          const _cue = createCueWithDataFields(Cue, startTime, endTime, payload, MetadataSchema.dateRange);\n          if (_cue) {\n            _cue.id = id;\n            this.id3Track.addCue(_cue);\n            cues[key] = _cue;\n            if (this.hls.config.interstitialsController) {\n              if (key === 'X-ASSET-LIST' || key === 'X-ASSET-URL') {\n                _cue.addEventListener('enter', this.onEventCueEnter);\n              }\n            }\n          }\n        }\n      }\n\n      // Keep track of processed DateRanges by ID for updating cues with new DateRange tag attributes\n      dateRangeCuesAppended[id] = {\n        cues,\n        dateRange,\n        durationKnown\n      };\n    }\n  }\n}\n\nclass LatencyController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.config = void 0;\n    this.media = null;\n    this.currentTime = 0;\n    this.stallCount = 0;\n    this._latency = null;\n    this._targetLatencyUpdated = false;\n    this.onTimeupdate = () => {\n      const {\n        media\n      } = this;\n      const levelDetails = this.levelDetails;\n      if (!media || !levelDetails) {\n        return;\n      }\n      this.currentTime = media.currentTime;\n      const latency = this.computeLatency();\n      if (latency === null) {\n        return;\n      }\n      this._latency = latency;\n\n      // Adapt playbackRate to meet target latency in low-latency mode\n      const {\n        lowLatencyMode,\n        maxLiveSyncPlaybackRate\n      } = this.config;\n      if (!lowLatencyMode || maxLiveSyncPlaybackRate === 1 || !levelDetails.live) {\n        return;\n      }\n      const targetLatency = this.targetLatency;\n      if (targetLatency === null) {\n        return;\n      }\n      const distanceFromTarget = latency - targetLatency;\n      // Only adjust playbackRate when within one target duration of targetLatency\n      // and more than one second from under-buffering.\n      // Playback further than one target duration from target can be considered DVR playback.\n      const liveMinLatencyDuration = Math.min(this.maxLatency, targetLatency + levelDetails.targetduration);\n      const inLiveRange = distanceFromTarget < liveMinLatencyDuration;\n      if (inLiveRange && distanceFromTarget > 0.05 && this.forwardBufferLength > 1) {\n        const max = Math.min(2, Math.max(1.0, maxLiveSyncPlaybackRate));\n        const rate = Math.round(2 / (1 + Math.exp(-0.75 * distanceFromTarget - this.edgeStalled)) * 20) / 20;\n        const playbackRate = Math.min(max, Math.max(1, rate));\n        this.changeMediaPlaybackRate(media, playbackRate);\n      } else if (media.playbackRate !== 1 && media.playbackRate !== 0) {\n        this.changeMediaPlaybackRate(media, 1);\n      }\n    };\n    this.hls = hls;\n    this.config = hls.config;\n    this.registerListeners();\n  }\n  get levelDetails() {\n    var _this$hls;\n    return ((_this$hls = this.hls) == null ? void 0 : _this$hls.latestLevelDetails) || null;\n  }\n  get latency() {\n    return this._latency || 0;\n  }\n  get maxLatency() {\n    const {\n      config\n    } = this;\n    if (config.liveMaxLatencyDuration !== undefined) {\n      return config.liveMaxLatencyDuration;\n    }\n    const levelDetails = this.levelDetails;\n    return levelDetails ? config.liveMaxLatencyDurationCount * levelDetails.targetduration : 0;\n  }\n  get targetLatency() {\n    const levelDetails = this.levelDetails;\n    if (levelDetails === null || this.hls === null) {\n      return null;\n    }\n    const {\n      holdBack,\n      partHoldBack,\n      targetduration\n    } = levelDetails;\n    const {\n      liveSyncDuration,\n      liveSyncDurationCount,\n      lowLatencyMode\n    } = this.config;\n    const userConfig = this.hls.userConfig;\n    let targetLatency = lowLatencyMode ? partHoldBack || holdBack : holdBack;\n    if (this._targetLatencyUpdated || userConfig.liveSyncDuration || userConfig.liveSyncDurationCount || targetLatency === 0) {\n      targetLatency = liveSyncDuration !== undefined ? liveSyncDuration : liveSyncDurationCount * targetduration;\n    }\n    const maxLiveSyncOnStallIncrease = targetduration;\n    return targetLatency + Math.min(this.stallCount * this.config.liveSyncOnStallIncrease, maxLiveSyncOnStallIncrease);\n  }\n  set targetLatency(latency) {\n    this.stallCount = 0;\n    this.config.liveSyncDuration = latency;\n    this._targetLatencyUpdated = true;\n  }\n  get liveSyncPosition() {\n    const liveEdge = this.estimateLiveEdge();\n    const targetLatency = this.targetLatency;\n    if (liveEdge === null || targetLatency === null) {\n      return null;\n    }\n    const levelDetails = this.levelDetails;\n    if (levelDetails === null) {\n      return null;\n    }\n    const edge = levelDetails.edge;\n    const syncPosition = liveEdge - targetLatency - this.edgeStalled;\n    const min = edge - levelDetails.totalduration;\n    const max = edge - (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration);\n    return Math.min(Math.max(min, syncPosition), max);\n  }\n  get drift() {\n    const levelDetails = this.levelDetails;\n    if (levelDetails === null) {\n      return 1;\n    }\n    return levelDetails.drift;\n  }\n  get edgeStalled() {\n    const levelDetails = this.levelDetails;\n    if (levelDetails === null) {\n      return 0;\n    }\n    const maxLevelUpdateAge = (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration) * 3;\n    return Math.max(levelDetails.age - maxLevelUpdateAge, 0);\n  }\n  get forwardBufferLength() {\n    const {\n      media\n    } = this;\n    const levelDetails = this.levelDetails;\n    if (!media || !levelDetails) {\n      return 0;\n    }\n    const bufferedRanges = media.buffered.length;\n    return (bufferedRanges ? media.buffered.end(bufferedRanges - 1) : levelDetails.edge) - this.currentTime;\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.onMediaDetaching();\n    this.hls = null;\n  }\n  registerListeners() {\n    const {\n      hls\n    } = this;\n    if (!hls) {\n      return;\n    }\n    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    hls.on(Events.ERROR, this.onError, this);\n  }\n  unregisterListeners() {\n    const {\n      hls\n    } = this;\n    if (!hls) {\n      return;\n    }\n    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    hls.off(Events.ERROR, this.onError, this);\n  }\n  onMediaAttached(event, data) {\n    this.media = data.media;\n    this.media.addEventListener('timeupdate', this.onTimeupdate);\n  }\n  onMediaDetaching() {\n    if (this.media) {\n      this.media.removeEventListener('timeupdate', this.onTimeupdate);\n      this.media = null;\n    }\n  }\n  onManifestLoading() {\n    this._latency = null;\n    this.stallCount = 0;\n  }\n  onLevelUpdated(event, {\n    details\n  }) {\n    if (details.advanced) {\n      this.onTimeupdate();\n    }\n    if (!details.live && this.media) {\n      this.media.removeEventListener('timeupdate', this.onTimeupdate);\n    }\n  }\n  onError(event, data) {\n    var _this$levelDetails;\n    if (data.details !== ErrorDetails.BUFFER_STALLED_ERROR) {\n      return;\n    }\n    this.stallCount++;\n    if (this.hls && (_this$levelDetails = this.levelDetails) != null && _this$levelDetails.live) {\n      this.hls.logger.warn('[latency-controller]: Stall detected, adjusting target latency');\n    }\n  }\n  changeMediaPlaybackRate(media, playbackRate) {\n    var _this$hls2, _this$targetLatency;\n    if (media.playbackRate === playbackRate) {\n      return;\n    }\n    (_this$hls2 = this.hls) == null ? void 0 : _this$hls2.logger.debug(`[latency-controller]: latency=${this.latency.toFixed(3)}, targetLatency=${(_this$targetLatency = this.targetLatency) == null ? void 0 : _this$targetLatency.toFixed(3)}, forwardBufferLength=${this.forwardBufferLength.toFixed(3)}: adjusting playback rate from ${media.playbackRate} to ${playbackRate}`);\n    media.playbackRate = playbackRate;\n  }\n  estimateLiveEdge() {\n    const levelDetails = this.levelDetails;\n    if (levelDetails === null) {\n      return null;\n    }\n    return levelDetails.edge + levelDetails.age;\n  }\n  computeLatency() {\n    const liveEdge = this.estimateLiveEdge();\n    if (liveEdge === null) {\n      return null;\n    }\n    return liveEdge - this.currentTime;\n  }\n}\n\nclass LevelController extends BasePlaylistController {\n  constructor(hls, contentSteeringController) {\n    super(hls, 'level-controller');\n    this._levels = [];\n    this._firstLevel = -1;\n    this._maxAutoLevel = -1;\n    this._startLevel = void 0;\n    this.currentLevel = null;\n    this.currentLevelIndex = -1;\n    this.manualLevelIndex = -1;\n    this.steering = void 0;\n    this.onParsedComplete = void 0;\n    this.steering = contentSteeringController;\n    this._registerListeners();\n  }\n  _registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.on(Events.ERROR, this.onError, this);\n  }\n  _unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.off(Events.ERROR, this.onError, this);\n  }\n  destroy() {\n    this._unregisterListeners();\n    this.steering = null;\n    this.resetLevels();\n    super.destroy();\n  }\n  stopLoad() {\n    const levels = this._levels;\n\n    // clean up live level details to force reload them, and reset load errors\n    levels.forEach(level => {\n      level.loadError = 0;\n      level.fragmentError = 0;\n    });\n    super.stopLoad();\n  }\n  resetLevels() {\n    this._startLevel = undefined;\n    this.manualLevelIndex = -1;\n    this.currentLevelIndex = -1;\n    this.currentLevel = null;\n    this._levels = [];\n    this._maxAutoLevel = -1;\n  }\n  onManifestLoading(event, data) {\n    this.resetLevels();\n  }\n  onManifestLoaded(event, data) {\n    const preferManagedMediaSource = this.hls.config.preferManagedMediaSource;\n    const levels = [];\n    const redundantSet = {};\n    const generatePathwaySet = {};\n    let resolutionFound = false;\n    let videoCodecFound = false;\n    let audioCodecFound = false;\n    data.levels.forEach(levelParsed => {\n      const attributes = levelParsed.attrs;\n      let {\n        audioCodec,\n        videoCodec\n      } = levelParsed;\n      if (audioCodec) {\n        // Returns empty and set to undefined for 'mp4a.40.34' with fallback to 'audio/mpeg' SourceBuffer\n        levelParsed.audioCodec = audioCodec = getCodecCompatibleName(audioCodec, preferManagedMediaSource) || undefined;\n      }\n      if (videoCodec) {\n        videoCodec = levelParsed.videoCodec = convertAVC1ToAVCOTI(videoCodec);\n      }\n\n      // only keep levels with supported audio/video codecs\n      const {\n        width,\n        height,\n        unknownCodecs\n      } = levelParsed;\n      let unknownUnsupportedCodecCount = unknownCodecs ? unknownCodecs.length : 0;\n      if (unknownCodecs) {\n        // Treat unknown codec as audio or video codec based on passing `isTypeSupported` check\n        // (allows for playback of any supported codec even if not indexed in utils/codecs)\n        for (let i = unknownUnsupportedCodecCount; i--;) {\n          const unknownCodec = unknownCodecs[i];\n          if (this.isAudioSupported(unknownCodec)) {\n            levelParsed.audioCodec = audioCodec = audioCodec ? `${audioCodec},${unknownCodec}` : unknownCodec;\n            unknownUnsupportedCodecCount--;\n            sampleEntryCodesISO.audio[audioCodec.substring(0, 4)] = 2;\n          } else if (this.isVideoSupported(unknownCodec)) {\n            levelParsed.videoCodec = videoCodec = videoCodec ? `${videoCodec},${unknownCodec}` : unknownCodec;\n            unknownUnsupportedCodecCount--;\n            sampleEntryCodesISO.video[videoCodec.substring(0, 4)] = 2;\n          }\n        }\n      }\n      resolutionFound || (resolutionFound = !!(width && height));\n      videoCodecFound || (videoCodecFound = !!videoCodec);\n      audioCodecFound || (audioCodecFound = !!audioCodec);\n      if (unknownUnsupportedCodecCount || audioCodec && !this.isAudioSupported(audioCodec) || videoCodec && !this.isVideoSupported(videoCodec)) {\n        this.log(`Some or all CODECS not supported \"${attributes.CODECS}\"`);\n        return;\n      }\n      const {\n        CODECS,\n        'FRAME-RATE': FRAMERATE,\n        'HDCP-LEVEL': HDCP,\n        'PATHWAY-ID': PATHWAY,\n        RESOLUTION,\n        'VIDEO-RANGE': VIDEO_RANGE\n      } = attributes;\n      const contentSteeringPrefix = `${PATHWAY || '.'}-`;\n      const levelKey = `${contentSteeringPrefix}${levelParsed.bitrate}-${RESOLUTION}-${FRAMERATE}-${CODECS}-${VIDEO_RANGE}-${HDCP}`;\n      if (!redundantSet[levelKey]) {\n        const level = this.createLevel(levelParsed);\n        redundantSet[levelKey] = level;\n        generatePathwaySet[levelKey] = 1;\n        levels.push(level);\n      } else if (redundantSet[levelKey].uri !== levelParsed.url && !levelParsed.attrs['PATHWAY-ID']) {\n        // Assign Pathway IDs to Redundant Streams (default Pathways is \".\". Redundant Streams \"..\", \"...\", and so on.)\n        // Content Steering controller to handles Pathway fallback on error\n        const pathwayCount = generatePathwaySet[levelKey] += 1;\n        levelParsed.attrs['PATHWAY-ID'] = new Array(pathwayCount + 1).join('.');\n        const level = this.createLevel(levelParsed);\n        redundantSet[levelKey] = level;\n        levels.push(level);\n      } else {\n        redundantSet[levelKey].addGroupId('audio', attributes.AUDIO);\n        redundantSet[levelKey].addGroupId('text', attributes.SUBTITLES);\n      }\n    });\n    this.filterAndSortMediaOptions(levels, data, resolutionFound, videoCodecFound, audioCodecFound);\n  }\n  createLevel(levelParsed) {\n    const level = new Level(levelParsed);\n    const supplemental = levelParsed.supplemental;\n    if (supplemental != null && supplemental.videoCodec && !this.isVideoSupported(supplemental.videoCodec)) {\n      const error = new Error(`SUPPLEMENTAL-CODECS not supported \"${supplemental.videoCodec}\"`);\n      this.log(error.message);\n      level.supportedResult = getUnsupportedResult(error, []);\n    }\n    return level;\n  }\n  isAudioSupported(codec) {\n    return areCodecsMediaSourceSupported(codec, 'audio', this.hls.config.preferManagedMediaSource);\n  }\n  isVideoSupported(codec) {\n    return areCodecsMediaSourceSupported(codec, 'video', this.hls.config.preferManagedMediaSource);\n  }\n  filterAndSortMediaOptions(filteredLevels, data, resolutionFound, videoCodecFound, audioCodecFound) {\n    let audioTracks = [];\n    let subtitleTracks = [];\n    let levels = filteredLevels;\n\n    // remove audio-only and invalid video-range levels if we also have levels with video codecs or RESOLUTION signalled\n    if ((resolutionFound || videoCodecFound) && audioCodecFound) {\n      levels = levels.filter(({\n        videoCodec,\n        videoRange,\n        width,\n        height\n      }) => (!!videoCodec || !!(width && height)) && isVideoRange(videoRange));\n    }\n    if (levels.length === 0) {\n      // Dispatch error after MANIFEST_LOADED is done propagating\n      Promise.resolve().then(() => {\n        if (this.hls) {\n          let message = 'no level with compatible codecs found in manifest';\n          let reason = message;\n          if (data.levels.length) {\n            reason = `one or more CODECS in variant not supported: ${stringify(data.levels.map(level => level.attrs.CODECS).filter((value, index, array) => array.indexOf(value) === index))}`;\n            this.warn(reason);\n            message += ` (${reason})`;\n          }\n          const error = new Error(message);\n          this.hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR,\n            fatal: true,\n            url: data.url,\n            error,\n            reason\n          });\n        }\n      });\n      return;\n    }\n    if (data.audioTracks) {\n      audioTracks = data.audioTracks.filter(track => !track.audioCodec || this.isAudioSupported(track.audioCodec));\n      // Assign ids after filtering as array indices by group-id\n      assignTrackIdsByGroup(audioTracks);\n    }\n    if (data.subtitles) {\n      subtitleTracks = data.subtitles;\n      assignTrackIdsByGroup(subtitleTracks);\n    }\n    // start bitrate is the first bitrate of the manifest\n    const unsortedLevels = levels.slice(0);\n    // sort levels from lowest to highest\n    levels.sort((a, b) => {\n      if (a.attrs['HDCP-LEVEL'] !== b.attrs['HDCP-LEVEL']) {\n        return (a.attrs['HDCP-LEVEL'] || '') > (b.attrs['HDCP-LEVEL'] || '') ? 1 : -1;\n      }\n      // sort on height before bitrate for cap-level-controller\n      if (resolutionFound && a.height !== b.height) {\n        return a.height - b.height;\n      }\n      if (a.frameRate !== b.frameRate) {\n        return a.frameRate - b.frameRate;\n      }\n      if (a.videoRange !== b.videoRange) {\n        return VideoRangeValues.indexOf(a.videoRange) - VideoRangeValues.indexOf(b.videoRange);\n      }\n      if (a.videoCodec !== b.videoCodec) {\n        const valueA = videoCodecPreferenceValue(a.videoCodec);\n        const valueB = videoCodecPreferenceValue(b.videoCodec);\n        if (valueA !== valueB) {\n          return valueB - valueA;\n        }\n      }\n      if (a.uri === b.uri && a.codecSet !== b.codecSet) {\n        const valueA = codecsSetSelectionPreferenceValue(a.codecSet);\n        const valueB = codecsSetSelectionPreferenceValue(b.codecSet);\n        if (valueA !== valueB) {\n          return valueB - valueA;\n        }\n      }\n      if (a.averageBitrate !== b.averageBitrate) {\n        return a.averageBitrate - b.averageBitrate;\n      }\n      return 0;\n    });\n    let firstLevelInPlaylist = unsortedLevels[0];\n    if (this.steering) {\n      levels = this.steering.filterParsedLevels(levels);\n      if (levels.length !== unsortedLevels.length) {\n        for (let i = 0; i < unsortedLevels.length; i++) {\n          if (unsortedLevels[i].pathwayId === levels[0].pathwayId) {\n            firstLevelInPlaylist = unsortedLevels[i];\n            break;\n          }\n        }\n      }\n    }\n    this._levels = levels;\n\n    // find index of first level in sorted levels\n    for (let i = 0; i < levels.length; i++) {\n      if (levels[i] === firstLevelInPlaylist) {\n        var _this$hls$userConfig;\n        this._firstLevel = i;\n        const firstLevelBitrate = firstLevelInPlaylist.bitrate;\n        const bandwidthEstimate = this.hls.bandwidthEstimate;\n        this.log(`manifest loaded, ${levels.length} level(s) found, first bitrate: ${firstLevelBitrate}`);\n        // Update default bwe to first variant bitrate as long it has not been configured or set\n        if (((_this$hls$userConfig = this.hls.userConfig) == null ? void 0 : _this$hls$userConfig.abrEwmaDefaultEstimate) === undefined) {\n          const startingBwEstimate = Math.min(firstLevelBitrate, this.hls.config.abrEwmaDefaultEstimateMax);\n          if (startingBwEstimate > bandwidthEstimate && bandwidthEstimate === this.hls.abrEwmaDefaultEstimate) {\n            this.hls.bandwidthEstimate = startingBwEstimate;\n          }\n        }\n        break;\n      }\n    }\n\n    // Audio is only alternate if manifest include a URI along with the audio group tag,\n    // and this is not an audio-only stream where levels contain audio-only\n    const audioOnly = audioCodecFound && !videoCodecFound;\n    const config = this.hls.config;\n    const altAudioEnabled = !!(config.audioStreamController && config.audioTrackController);\n    const edata = {\n      levels,\n      audioTracks,\n      subtitleTracks,\n      sessionData: data.sessionData,\n      sessionKeys: data.sessionKeys,\n      firstLevel: this._firstLevel,\n      stats: data.stats,\n      audio: audioCodecFound,\n      video: videoCodecFound,\n      altAudio: altAudioEnabled && !audioOnly && audioTracks.some(t => !!t.url)\n    };\n    this.hls.trigger(Events.MANIFEST_PARSED, edata);\n  }\n  get levels() {\n    if (this._levels.length === 0) {\n      return null;\n    }\n    return this._levels;\n  }\n  get loadLevelObj() {\n    return this.currentLevel;\n  }\n  get level() {\n    return this.currentLevelIndex;\n  }\n  set level(newLevel) {\n    const levels = this._levels;\n    if (levels.length === 0) {\n      return;\n    }\n    // check if level idx is valid\n    if (newLevel < 0 || newLevel >= levels.length) {\n      // invalid level id given, trigger error\n      const error = new Error('invalid level idx');\n      const fatal = newLevel < 0;\n      this.hls.trigger(Events.ERROR, {\n        type: ErrorTypes.OTHER_ERROR,\n        details: ErrorDetails.LEVEL_SWITCH_ERROR,\n        level: newLevel,\n        fatal,\n        error,\n        reason: error.message\n      });\n      if (fatal) {\n        return;\n      }\n      newLevel = Math.min(newLevel, levels.length - 1);\n    }\n    const lastLevelIndex = this.currentLevelIndex;\n    const lastLevel = this.currentLevel;\n    const lastPathwayId = lastLevel ? lastLevel.attrs['PATHWAY-ID'] : undefined;\n    const level = levels[newLevel];\n    const pathwayId = level.attrs['PATHWAY-ID'];\n    this.currentLevelIndex = newLevel;\n    this.currentLevel = level;\n    if (lastLevelIndex === newLevel && lastLevel && lastPathwayId === pathwayId) {\n      return;\n    }\n    this.log(`Switching to level ${newLevel} (${level.height ? level.height + 'p ' : ''}${level.videoRange ? level.videoRange + ' ' : ''}${level.codecSet ? level.codecSet + ' ' : ''}@${level.bitrate})${pathwayId ? ' with Pathway ' + pathwayId : ''} from level ${lastLevelIndex}${lastPathwayId ? ' with Pathway ' + lastPathwayId : ''}`);\n    const levelSwitchingData = {\n      level: newLevel,\n      attrs: level.attrs,\n      details: level.details,\n      bitrate: level.bitrate,\n      averageBitrate: level.averageBitrate,\n      maxBitrate: level.maxBitrate,\n      realBitrate: level.realBitrate,\n      width: level.width,\n      height: level.height,\n      codecSet: level.codecSet,\n      audioCodec: level.audioCodec,\n      videoCodec: level.videoCodec,\n      audioGroups: level.audioGroups,\n      subtitleGroups: level.subtitleGroups,\n      loaded: level.loaded,\n      loadError: level.loadError,\n      fragmentError: level.fragmentError,\n      name: level.name,\n      id: level.id,\n      uri: level.uri,\n      url: level.url,\n      urlId: 0,\n      audioGroupIds: level.audioGroupIds,\n      textGroupIds: level.textGroupIds\n    };\n    this.hls.trigger(Events.LEVEL_SWITCHING, levelSwitchingData);\n    // check if we need to load playlist for this level\n    const levelDetails = level.details;\n    if (!levelDetails || levelDetails.live) {\n      // level not retrieved yet, or live playlist we need to (re)load it\n      const hlsUrlParameters = this.switchParams(level.uri, lastLevel == null ? void 0 : lastLevel.details, levelDetails);\n      this.loadPlaylist(hlsUrlParameters);\n    }\n  }\n  get manualLevel() {\n    return this.manualLevelIndex;\n  }\n  set manualLevel(newLevel) {\n    this.manualLevelIndex = newLevel;\n    if (this._startLevel === undefined) {\n      this._startLevel = newLevel;\n    }\n    if (newLevel !== -1) {\n      this.level = newLevel;\n    }\n  }\n  get firstLevel() {\n    return this._firstLevel;\n  }\n  set firstLevel(newLevel) {\n    this._firstLevel = newLevel;\n  }\n  get startLevel() {\n    // Setting hls.startLevel (this._startLevel) overrides config.startLevel\n    if (this._startLevel === undefined) {\n      const configStartLevel = this.hls.config.startLevel;\n      if (configStartLevel !== undefined) {\n        return configStartLevel;\n      }\n      return this.hls.firstAutoLevel;\n    }\n    return this._startLevel;\n  }\n  set startLevel(newLevel) {\n    this._startLevel = newLevel;\n  }\n  get pathways() {\n    if (this.steering) {\n      return this.steering.pathways();\n    }\n    return [];\n  }\n  get pathwayPriority() {\n    if (this.steering) {\n      return this.steering.pathwayPriority;\n    }\n    return null;\n  }\n  set pathwayPriority(pathwayPriority) {\n    if (this.steering) {\n      const pathwaysList = this.steering.pathways();\n      const filteredPathwayPriority = pathwayPriority.filter(pathwayId => {\n        return pathwaysList.indexOf(pathwayId) !== -1;\n      });\n      if (pathwayPriority.length < 1) {\n        this.warn(`pathwayPriority ${pathwayPriority} should contain at least one pathway from list: ${pathwaysList}`);\n        return;\n      }\n      this.steering.pathwayPriority = filteredPathwayPriority;\n    }\n  }\n  onError(event, data) {\n    if (data.fatal || !data.context) {\n      return;\n    }\n    if (data.context.type === PlaylistContextType.LEVEL && data.context.level === this.level) {\n      this.checkRetry(data);\n    }\n  }\n\n  // reset errors on the successful load of a fragment\n  onFragBuffered(event, {\n    frag\n  }) {\n    if (frag !== undefined && frag.type === PlaylistLevelType.MAIN) {\n      const el = frag.elementaryStreams;\n      if (!Object.keys(el).some(type => !!el[type])) {\n        return;\n      }\n      const level = this._levels[frag.level];\n      if (level != null && level.loadError) {\n        this.log(`Resetting level error count of ${level.loadError} on frag buffered`);\n        level.loadError = 0;\n      }\n    }\n  }\n  onLevelLoaded(event, data) {\n    var _data$deliveryDirecti2;\n    const {\n      level,\n      details\n    } = data;\n    const curLevel = data.levelInfo;\n    if (!curLevel) {\n      var _data$deliveryDirecti;\n      this.warn(`Invalid level index ${level}`);\n      if ((_data$deliveryDirecti = data.deliveryDirectives) != null && _data$deliveryDirecti.skip) {\n        details.deltaUpdateFailed = true;\n      }\n      return;\n    }\n\n    // only process level loaded events matching with expected level or prior to switch when media playlist is loaded directly\n    if (curLevel === this.currentLevel || data.withoutMultiVariant) {\n      // reset level load error counter on successful level loaded only if there is no issues with fragments\n      if (curLevel.fragmentError === 0) {\n        curLevel.loadError = 0;\n      }\n      // Ignore matching details populated by loading a Media Playlist directly\n      let previousDetails = curLevel.details;\n      if (previousDetails === data.details && previousDetails.advanced) {\n        previousDetails = undefined;\n      }\n      this.playlistLoaded(level, data, previousDetails);\n    } else if ((_data$deliveryDirecti2 = data.deliveryDirectives) != null && _data$deliveryDirecti2.skip) {\n      // received a delta playlist update that cannot be merged\n      details.deltaUpdateFailed = true;\n    }\n  }\n  loadPlaylist(hlsUrlParameters) {\n    super.loadPlaylist();\n    if (this.shouldLoadPlaylist(this.currentLevel)) {\n      this.scheduleLoading(this.currentLevel, hlsUrlParameters);\n    }\n  }\n  loadingPlaylist(currentLevel, hlsUrlParameters) {\n    super.loadingPlaylist(currentLevel, hlsUrlParameters);\n    const url = this.getUrlWithDirectives(currentLevel.uri, hlsUrlParameters);\n    const currentLevelIndex = this.currentLevelIndex;\n    const pathwayId = currentLevel.attrs['PATHWAY-ID'];\n    const details = currentLevel.details;\n    const age = details == null ? void 0 : details.age;\n    this.log(`Loading level index ${currentLevelIndex}${(hlsUrlParameters == null ? void 0 : hlsUrlParameters.msn) !== undefined ? ' at sn ' + hlsUrlParameters.msn + ' part ' + hlsUrlParameters.part : ''}${pathwayId ? ' Pathway ' + pathwayId : ''}${age && details.live ? ' age ' + age.toFixed(1) + (details.type ? ' ' + details.type || 0 : '') : ''} ${url}`);\n    this.hls.trigger(Events.LEVEL_LOADING, {\n      url,\n      level: currentLevelIndex,\n      levelInfo: currentLevel,\n      pathwayId: currentLevel.attrs['PATHWAY-ID'],\n      id: 0,\n      // Deprecated Level urlId\n      deliveryDirectives: hlsUrlParameters || null\n    });\n  }\n  get nextLoadLevel() {\n    if (this.manualLevelIndex !== -1) {\n      return this.manualLevelIndex;\n    } else {\n      return this.hls.nextAutoLevel;\n    }\n  }\n  set nextLoadLevel(nextLevel) {\n    this.level = nextLevel;\n    if (this.manualLevelIndex === -1) {\n      this.hls.nextAutoLevel = nextLevel;\n    }\n  }\n  removeLevel(levelIndex) {\n    var _this$currentLevel;\n    if (this._levels.length === 1) {\n      return;\n    }\n    const levels = this._levels.filter((level, index) => {\n      if (index !== levelIndex) {\n        return true;\n      }\n      if (this.steering) {\n        this.steering.removeLevel(level);\n      }\n      if (level === this.currentLevel) {\n        this.currentLevel = null;\n        this.currentLevelIndex = -1;\n        if (level.details) {\n          level.details.fragments.forEach(f => f.level = -1);\n        }\n      }\n      return false;\n    });\n    reassignFragmentLevelIndexes(levels);\n    this._levels = levels;\n    if (this.currentLevelIndex > -1 && (_this$currentLevel = this.currentLevel) != null && _this$currentLevel.details) {\n      this.currentLevelIndex = this.currentLevel.details.fragments[0].level;\n    }\n    if (this.manualLevelIndex > -1) {\n      this.manualLevelIndex = this.currentLevelIndex;\n    }\n    const maxLevel = levels.length - 1;\n    this._firstLevel = Math.min(this._firstLevel, maxLevel);\n    if (this._startLevel) {\n      this._startLevel = Math.min(this._startLevel, maxLevel);\n    }\n    this.hls.trigger(Events.LEVELS_UPDATED, {\n      levels\n    });\n  }\n  onLevelsUpdated(event, {\n    levels\n  }) {\n    this._levels = levels;\n  }\n  checkMaxAutoUpdated() {\n    const {\n      autoLevelCapping,\n      maxAutoLevel,\n      maxHdcpLevel\n    } = this.hls;\n    if (this._maxAutoLevel !== maxAutoLevel) {\n      this._maxAutoLevel = maxAutoLevel;\n      this.hls.trigger(Events.MAX_AUTO_LEVEL_UPDATED, {\n        autoLevelCapping,\n        levels: this.levels,\n        maxAutoLevel,\n        minAutoLevel: this.hls.minAutoLevel,\n        maxHdcpLevel\n      });\n    }\n  }\n}\nfunction assignTrackIdsByGroup(tracks) {\n  const groups = {};\n  tracks.forEach(track => {\n    const groupId = track.groupId || '';\n    track.id = groups[groupId] = groups[groupId] || 0;\n    groups[groupId]++;\n  });\n}\n\nfunction getSourceBuffer() {\n  return self.SourceBuffer || self.WebKitSourceBuffer;\n}\nfunction isMSESupported() {\n  const mediaSource = getMediaSource();\n  if (!mediaSource) {\n    return false;\n  }\n\n  // if SourceBuffer is exposed ensure its API is valid\n  // Older browsers do not expose SourceBuffer globally so checking SourceBuffer.prototype is impossible\n  const sourceBuffer = getSourceBuffer();\n  return !sourceBuffer || sourceBuffer.prototype && typeof sourceBuffer.prototype.appendBuffer === 'function' && typeof sourceBuffer.prototype.remove === 'function';\n}\nfunction isSupported() {\n  if (!isMSESupported()) {\n    return false;\n  }\n  const mediaSource = getMediaSource();\n  return typeof (mediaSource == null ? void 0 : mediaSource.isTypeSupported) === 'function' && (['avc1.42E01E,mp4a.40.2', 'av01.0.01M.08', 'vp09.00.50.08'].some(codecsForVideoContainer => mediaSource.isTypeSupported(mimeTypeForCodec(codecsForVideoContainer, 'video'))) || ['mp4a.40.2', 'fLaC'].some(codecForAudioContainer => mediaSource.isTypeSupported(mimeTypeForCodec(codecForAudioContainer, 'audio'))));\n}\nfunction changeTypeSupported() {\n  var _sourceBuffer$prototy;\n  const sourceBuffer = getSourceBuffer();\n  return typeof (sourceBuffer == null ? void 0 : (_sourceBuffer$prototy = sourceBuffer.prototype) == null ? void 0 : _sourceBuffer$prototy.changeType) === 'function';\n}\n\nconst TICK_INTERVAL = 100; // how often to tick in ms\n\nclass StreamController extends BaseStreamController {\n  constructor(hls, fragmentTracker, keyLoader) {\n    super(hls, fragmentTracker, keyLoader, 'stream-controller', PlaylistLevelType.MAIN);\n    this.audioCodecSwap = false;\n    this.level = -1;\n    this._forceStartLoad = false;\n    this._hasEnoughToStart = false;\n    this.altAudio = 0;\n    this.audioOnly = false;\n    this.fragPlaying = null;\n    this.fragLastKbps = 0;\n    this.couldBacktrack = false;\n    this.backtrackFragment = null;\n    this.audioCodecSwitch = false;\n    this.videoBuffer = null;\n    this.onMediaPlaying = () => {\n      // tick to speed up FRAG_CHANGED triggering\n      this.tick();\n    };\n    this.onMediaSeeked = () => {\n      const media = this.media;\n      const currentTime = media ? media.currentTime : null;\n      if (currentTime === null || !isFiniteNumber(currentTime)) {\n        return;\n      }\n      this.log(`Media seeked to ${currentTime.toFixed(3)}`);\n\n      // If seeked was issued before buffer was appended do not tick immediately\n      if (!this.getBufferedFrag(currentTime)) {\n        return;\n      }\n      const bufferInfo = this.getFwdBufferInfoAtPos(media, currentTime, PlaylistLevelType.MAIN, 0);\n      if (bufferInfo === null || bufferInfo.len === 0) {\n        this.warn(`Main forward buffer length at ${currentTime} on \"seeked\" event ${bufferInfo ? bufferInfo.len : 'empty'})`);\n        return;\n      }\n\n      // tick to speed up FRAG_CHANGED triggering\n      this.tick();\n    };\n    this.registerListeners();\n  }\n  registerListeners() {\n    super.registerListeners();\n    const {\n      hls\n    } = this;\n    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);\n    hls.on(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n    hls.on(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n    hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);\n    hls.on(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n    hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n  }\n  unregisterListeners() {\n    super.unregisterListeners();\n    const {\n      hls\n    } = this;\n    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);\n    hls.off(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n    hls.off(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n    hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);\n    hls.off(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n    hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n  }\n  onHandlerDestroying() {\n    // @ts-ignore\n    this.onMediaPlaying = this.onMediaSeeked = null;\n    this.unregisterListeners();\n    super.onHandlerDestroying();\n  }\n  startLoad(startPosition, skipSeekToStartPosition) {\n    if (this.levels) {\n      const {\n        lastCurrentTime,\n        hls\n      } = this;\n      this.stopLoad();\n      this.setInterval(TICK_INTERVAL);\n      this.level = -1;\n      if (!this.startFragRequested) {\n        // determine load level\n        let startLevel = hls.startLevel;\n        if (startLevel === -1) {\n          if (hls.config.testBandwidth && this.levels.length > 1) {\n            // -1 : guess start Level by doing a bitrate test by loading first fragment of lowest quality level\n            startLevel = 0;\n            this.bitrateTest = true;\n          } else {\n            startLevel = hls.firstAutoLevel;\n          }\n        }\n        // set new level to playlist loader : this will trigger start level load\n        // hls.nextLoadLevel remains until it is set to a new value or until a new frag is successfully loaded\n        hls.nextLoadLevel = startLevel;\n        this.level = hls.loadLevel;\n        this._hasEnoughToStart = !!skipSeekToStartPosition;\n      }\n      // if startPosition undefined but lastCurrentTime set, set startPosition to last currentTime\n      if (lastCurrentTime > 0 && startPosition === -1 && !skipSeekToStartPosition) {\n        this.log(`Override startPosition with lastCurrentTime @${lastCurrentTime.toFixed(3)}`);\n        startPosition = lastCurrentTime;\n      }\n      this.state = State.IDLE;\n      this.nextLoadPosition = this.lastCurrentTime = startPosition + this.timelineOffset;\n      this.startPosition = skipSeekToStartPosition ? -1 : startPosition;\n      this.tick();\n    } else {\n      this._forceStartLoad = true;\n      this.state = State.STOPPED;\n    }\n  }\n  stopLoad() {\n    this._forceStartLoad = false;\n    super.stopLoad();\n  }\n  doTick() {\n    switch (this.state) {\n      case State.WAITING_LEVEL:\n        {\n          const {\n            levels,\n            level\n          } = this;\n          const currentLevel = levels == null ? void 0 : levels[level];\n          const details = currentLevel == null ? void 0 : currentLevel.details;\n          if (details && (!details.live || this.levelLastLoaded === currentLevel && !this.waitForLive(currentLevel))) {\n            if (this.waitForCdnTuneIn(details)) {\n              break;\n            }\n            this.state = State.IDLE;\n            break;\n          } else if (this.hls.nextLoadLevel !== this.level) {\n            this.state = State.IDLE;\n            break;\n          }\n          break;\n        }\n      case State.FRAG_LOADING_WAITING_RETRY:\n        {\n          var _this$media;\n          const now = self.performance.now();\n          const retryDate = this.retryDate;\n          // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading\n          if (!retryDate || now >= retryDate || (_this$media = this.media) != null && _this$media.seeking) {\n            const {\n              levels,\n              level\n            } = this;\n            const currentLevel = levels == null ? void 0 : levels[level];\n            this.resetStartWhenNotLoaded(currentLevel || null);\n            this.state = State.IDLE;\n          }\n        }\n        break;\n    }\n    if (this.state === State.IDLE) {\n      this.doTickIdle();\n    }\n    this.onTickEnd();\n  }\n  onTickEnd() {\n    var _this$media2;\n    super.onTickEnd();\n    if ((_this$media2 = this.media) != null && _this$media2.readyState && this.media.seeking === false) {\n      this.lastCurrentTime = this.media.currentTime;\n    }\n    this.checkFragmentChanged();\n  }\n  doTickIdle() {\n    const {\n      hls,\n      levelLastLoaded,\n      levels,\n      media\n    } = this;\n\n    // if start level not parsed yet OR\n    // if video not attached AND start fragment already requested OR start frag prefetch not enabled\n    // exit loop, as we either need more info (level not parsed) or we need media to be attached to load new fragment\n    if (levelLastLoaded === null || !media && !this.primaryPrefetch && (this.startFragRequested || !hls.config.startFragPrefetch)) {\n      return;\n    }\n\n    // If the \"main\" level is audio-only but we are loading an alternate track in the same group, do not load anything\n    if (this.altAudio && this.audioOnly) {\n      return;\n    }\n    const level = this.buffering ? hls.nextLoadLevel : hls.loadLevel;\n    if (!(levels != null && levels[level])) {\n      return;\n    }\n    const levelInfo = levels[level];\n\n    // if buffer length is less than maxBufLen try to load a new fragment\n\n    const bufferInfo = this.getMainFwdBufferInfo();\n    if (bufferInfo === null) {\n      return;\n    }\n    const lastDetails = this.getLevelDetails();\n    if (lastDetails && this._streamEnded(bufferInfo, lastDetails)) {\n      const data = {};\n      if (this.altAudio === 2) {\n        data.type = 'video';\n      }\n      this.hls.trigger(Events.BUFFER_EOS, data);\n      this.state = State.ENDED;\n      return;\n    }\n    if (!this.buffering) {\n      return;\n    }\n\n    // set next load level : this will trigger a playlist load if needed\n    if (hls.loadLevel !== level && hls.manualLevel === -1) {\n      this.log(`Adapting to level ${level} from level ${this.level}`);\n    }\n    this.level = hls.nextLoadLevel = level;\n    const levelDetails = levelInfo.details;\n    // if level info not retrieved yet, switch state and wait for level retrieval\n    // if live playlist, ensure that new playlist has been refreshed to avoid loading/try to load\n    // a useless and outdated fragment (that might even introduce load error if it is already out of the live playlist)\n    if (!levelDetails || this.state === State.WAITING_LEVEL || this.waitForLive(levelInfo)) {\n      this.level = level;\n      this.state = State.WAITING_LEVEL;\n      this.startFragRequested = false;\n      return;\n    }\n    const bufferLen = bufferInfo.len;\n\n    // compute max Buffer Length that we could get from this load level, based on level bitrate. don't buffer more than 60 MB and more than 30s\n    const maxBufLen = this.getMaxBufferLength(levelInfo.maxBitrate);\n\n    // Stay idle if we are still with buffer margins\n    if (bufferLen >= maxBufLen) {\n      return;\n    }\n    if (this.backtrackFragment && this.backtrackFragment.start > bufferInfo.end) {\n      this.backtrackFragment = null;\n    }\n    const targetBufferTime = this.backtrackFragment ? this.backtrackFragment.start : bufferInfo.end;\n    let frag = this.getNextFragment(targetBufferTime, levelDetails);\n    // Avoid backtracking by loading an earlier segment in streams with segments that do not start with a key frame (flagged by `couldBacktrack`)\n    if (this.couldBacktrack && !this.fragPrevious && frag && isMediaFragment(frag) && this.fragmentTracker.getState(frag) !== FragmentState.OK) {\n      var _this$backtrackFragme;\n      const backtrackSn = ((_this$backtrackFragme = this.backtrackFragment) != null ? _this$backtrackFragme : frag).sn;\n      const fragIdx = backtrackSn - levelDetails.startSN;\n      const backtrackFrag = levelDetails.fragments[fragIdx - 1];\n      if (backtrackFrag && frag.cc === backtrackFrag.cc) {\n        frag = backtrackFrag;\n        this.fragmentTracker.removeFragment(backtrackFrag);\n      }\n    } else if (this.backtrackFragment && bufferInfo.len) {\n      this.backtrackFragment = null;\n    }\n    // Avoid loop loading by using nextLoadPosition set for backtracking and skipping consecutive GAP tags\n    if (frag && this.isLoopLoading(frag, targetBufferTime)) {\n      const gapStart = frag.gap;\n      if (!gapStart) {\n        // Cleanup the fragment tracker before trying to find the next unbuffered fragment\n        const type = this.audioOnly && !this.altAudio ? ElementaryStreamTypes.AUDIO : ElementaryStreamTypes.VIDEO;\n        const mediaBuffer = (type === ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;\n        if (mediaBuffer) {\n          this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.MAIN);\n        }\n      }\n      frag = this.getNextFragmentLoopLoading(frag, levelDetails, bufferInfo, PlaylistLevelType.MAIN, maxBufLen);\n    }\n    if (!frag) {\n      return;\n    }\n    if (frag.initSegment && !frag.initSegment.data && !this.bitrateTest) {\n      frag = frag.initSegment;\n    }\n    this.loadFragment(frag, levelInfo, targetBufferTime);\n  }\n  loadFragment(frag, level, targetBufferTime) {\n    // Check if fragment is not loaded\n    const fragState = this.fragmentTracker.getState(frag);\n    if (fragState === FragmentState.NOT_LOADED || fragState === FragmentState.PARTIAL) {\n      if (!isMediaFragment(frag)) {\n        this._loadInitSegment(frag, level);\n      } else if (this.bitrateTest) {\n        this.log(`Fragment ${frag.sn} of level ${frag.level} is being downloaded to test bitrate and will not be buffered`);\n        this._loadBitrateTestFrag(frag, level);\n      } else {\n        super.loadFragment(frag, level, targetBufferTime);\n      }\n    } else {\n      this.clearTrackerIfNeeded(frag);\n    }\n  }\n  getBufferedFrag(position) {\n    return this.fragmentTracker.getBufferedFrag(position, PlaylistLevelType.MAIN);\n  }\n  followingBufferedFrag(frag) {\n    if (frag) {\n      // try to get range of next fragment (500ms after this range)\n      return this.getBufferedFrag(frag.end + 0.5);\n    }\n    return null;\n  }\n\n  /*\n    on immediate level switch :\n     - pause playback if playing\n     - cancel any pending load request\n     - and trigger a buffer flush\n  */\n  immediateLevelSwitch() {\n    this.abortCurrentFrag();\n    this.flushMainBuffer(0, Number.POSITIVE_INFINITY);\n  }\n\n  /**\n   * try to switch ASAP without breaking video playback:\n   * in order to ensure smooth but quick level switching,\n   * we need to find the next flushable buffer range\n   * we should take into account new segment fetch time\n   */\n  nextLevelSwitch() {\n    const {\n      levels,\n      media\n    } = this;\n    // ensure that media is defined and that metadata are available (to retrieve currentTime)\n    if (media != null && media.readyState) {\n      let fetchdelay;\n      const fragPlayingCurrent = this.getAppendedFrag(media.currentTime);\n      if (fragPlayingCurrent && fragPlayingCurrent.start > 1) {\n        // flush buffer preceding current fragment (flush until current fragment start offset)\n        // minus 1s to avoid video freezing, that could happen if we flush keyframe of current video ...\n        this.flushMainBuffer(0, fragPlayingCurrent.start - 1);\n      }\n      const levelDetails = this.getLevelDetails();\n      if (levelDetails != null && levelDetails.live) {\n        const bufferInfo = this.getMainFwdBufferInfo();\n        // Do not flush in live stream with low buffer\n        if (!bufferInfo || bufferInfo.len < levelDetails.targetduration * 2) {\n          return;\n        }\n      }\n      if (!media.paused && levels) {\n        // add a safety delay of 1s\n        const nextLevelId = this.hls.nextLoadLevel;\n        const nextLevel = levels[nextLevelId];\n        const fragLastKbps = this.fragLastKbps;\n        if (fragLastKbps && this.fragCurrent) {\n          fetchdelay = this.fragCurrent.duration * nextLevel.maxBitrate / (1000 * fragLastKbps) + 1;\n        } else {\n          fetchdelay = 0;\n        }\n      } else {\n        fetchdelay = 0;\n      }\n      // this.log('fetchdelay:'+fetchdelay);\n      // find buffer range that will be reached once new fragment will be fetched\n      const bufferedFrag = this.getBufferedFrag(media.currentTime + fetchdelay);\n      if (bufferedFrag) {\n        // we can flush buffer range following this one without stalling playback\n        const nextBufferedFrag = this.followingBufferedFrag(bufferedFrag);\n        if (nextBufferedFrag) {\n          // if we are here, we can also cancel any loading/demuxing in progress, as they are useless\n          this.abortCurrentFrag();\n          // start flush position is in next buffered frag. Leave some padding for non-independent segments and smoother playback.\n          const maxStart = nextBufferedFrag.maxStartPTS ? nextBufferedFrag.maxStartPTS : nextBufferedFrag.start;\n          const fragDuration = nextBufferedFrag.duration;\n          const startPts = Math.max(bufferedFrag.end, maxStart + Math.min(Math.max(fragDuration - this.config.maxFragLookUpTolerance, fragDuration * (this.couldBacktrack ? 0.5 : 0.125)), fragDuration * (this.couldBacktrack ? 0.75 : 0.25)));\n          this.flushMainBuffer(startPts, Number.POSITIVE_INFINITY);\n        }\n      }\n    }\n  }\n  abortCurrentFrag() {\n    const fragCurrent = this.fragCurrent;\n    this.fragCurrent = null;\n    this.backtrackFragment = null;\n    if (fragCurrent) {\n      fragCurrent.abortRequests();\n      this.fragmentTracker.removeFragment(fragCurrent);\n    }\n    switch (this.state) {\n      case State.KEY_LOADING:\n      case State.FRAG_LOADING:\n      case State.FRAG_LOADING_WAITING_RETRY:\n      case State.PARSING:\n      case State.PARSED:\n        this.state = State.IDLE;\n        break;\n    }\n    this.nextLoadPosition = this.getLoadPosition();\n  }\n  flushMainBuffer(startOffset, endOffset) {\n    super.flushMainBuffer(startOffset, endOffset, this.altAudio === 2 ? 'video' : null);\n  }\n  onMediaAttached(event, data) {\n    super.onMediaAttached(event, data);\n    const media = data.media;\n    addEventListener(media, 'playing', this.onMediaPlaying);\n    addEventListener(media, 'seeked', this.onMediaSeeked);\n  }\n  onMediaDetaching(event, data) {\n    const {\n      media\n    } = this;\n    if (media) {\n      removeEventListener(media, 'playing', this.onMediaPlaying);\n      removeEventListener(media, 'seeked', this.onMediaSeeked);\n    }\n    this.videoBuffer = null;\n    this.fragPlaying = null;\n    super.onMediaDetaching(event, data);\n    const transferringMedia = !!data.transferMedia;\n    if (transferringMedia) {\n      return;\n    }\n    this._hasEnoughToStart = false;\n  }\n  onManifestLoading() {\n    super.onManifestLoading();\n    // reset buffer on manifest loading\n    this.log('Trigger BUFFER_RESET');\n    this.hls.trigger(Events.BUFFER_RESET, undefined);\n    this.couldBacktrack = false;\n    this.fragLastKbps = 0;\n    this.fragPlaying = this.backtrackFragment = null;\n    this.altAudio = 0;\n    this.audioOnly = false;\n  }\n  onManifestParsed(event, data) {\n    // detect if we have different kind of audio codecs used amongst playlists\n    let aac = false;\n    let heaac = false;\n    data.levels.forEach(level => {\n      const codec = level.audioCodec;\n      if (codec) {\n        aac = aac || codec.indexOf('mp4a.40.2') !== -1;\n        heaac = heaac || codec.indexOf('mp4a.40.5') !== -1;\n      }\n    });\n    this.audioCodecSwitch = aac && heaac && !changeTypeSupported();\n    if (this.audioCodecSwitch) {\n      this.log('Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC');\n    }\n    this.levels = data.levels;\n    this.startFragRequested = false;\n  }\n  onLevelLoading(event, data) {\n    const {\n      levels\n    } = this;\n    if (!levels || this.state !== State.IDLE) {\n      return;\n    }\n    const level = data.levelInfo;\n    if (!level.details || level.details.live && (this.levelLastLoaded !== level || level.details.expired) || this.waitForCdnTuneIn(level.details)) {\n      this.state = State.WAITING_LEVEL;\n    }\n  }\n  onLevelLoaded(event, data) {\n    var _curLevel$details;\n    const {\n      levels,\n      startFragRequested\n    } = this;\n    const newLevelId = data.level;\n    const newDetails = data.details;\n    const duration = newDetails.totalduration;\n    if (!levels) {\n      this.warn(`Levels were reset while loading level ${newLevelId}`);\n      return;\n    }\n    this.log(`Level ${newLevelId} loaded [${newDetails.startSN},${newDetails.endSN}]${newDetails.lastPartSn ? `[part-${newDetails.lastPartSn}-${newDetails.lastPartIndex}]` : ''}, cc [${newDetails.startCC}, ${newDetails.endCC}] duration:${duration}`);\n    const curLevel = data.levelInfo;\n    const fragCurrent = this.fragCurrent;\n    if (fragCurrent && (this.state === State.FRAG_LOADING || this.state === State.FRAG_LOADING_WAITING_RETRY)) {\n      if (fragCurrent.level !== data.level && fragCurrent.loader) {\n        this.abortCurrentFrag();\n      }\n    }\n    let sliding = 0;\n    if (newDetails.live || (_curLevel$details = curLevel.details) != null && _curLevel$details.live) {\n      var _this$levelLastLoaded;\n      this.checkLiveUpdate(newDetails);\n      if (newDetails.deltaUpdateFailed) {\n        return;\n      }\n      sliding = this.alignPlaylists(newDetails, curLevel.details, (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details);\n    }\n    // override level info\n    curLevel.details = newDetails;\n    this.levelLastLoaded = curLevel;\n    if (!startFragRequested) {\n      this.setStartPosition(newDetails, sliding);\n    }\n    this.hls.trigger(Events.LEVEL_UPDATED, {\n      details: newDetails,\n      level: newLevelId\n    });\n\n    // only switch back to IDLE state if we were waiting for level to start downloading a new fragment\n    if (this.state === State.WAITING_LEVEL) {\n      if (this.waitForCdnTuneIn(newDetails)) {\n        // Wait for Low-Latency CDN Tune-in\n        return;\n      }\n      this.state = State.IDLE;\n    }\n    if (startFragRequested && newDetails.live) {\n      this.synchronizeToLiveEdge(newDetails);\n    }\n\n    // trigger handler right now\n    this.tick();\n  }\n  synchronizeToLiveEdge(levelDetails) {\n    const {\n      config,\n      media\n    } = this;\n    if (!media) {\n      return;\n    }\n    const liveSyncPosition = this.hls.liveSyncPosition;\n    const currentTime = this.getLoadPosition();\n    const start = levelDetails.fragmentStart;\n    const end = levelDetails.edge;\n    const withinSlidingWindow = currentTime >= start - config.maxFragLookUpTolerance && currentTime <= end;\n    // Continue if we can seek forward to sync position or if current time is outside of sliding window\n    if (liveSyncPosition !== null && media.duration > liveSyncPosition && (currentTime < liveSyncPosition || !withinSlidingWindow)) {\n      // Continue if buffer is starving or if current time is behind max latency\n      const maxLatency = config.liveMaxLatencyDuration !== undefined ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;\n      if (!withinSlidingWindow && media.readyState < 4 || currentTime < end - maxLatency) {\n        if (!this._hasEnoughToStart) {\n          this.nextLoadPosition = liveSyncPosition;\n        }\n        // Only seek if ready and there is not a significant forward buffer available for playback\n        if (media.readyState) {\n          this.warn(`Playback: ${currentTime.toFixed(3)} is located too far from the end of live sliding playlist: ${end}, reset currentTime to : ${liveSyncPosition.toFixed(3)}`);\n          if (this.config.liveSyncMode === 'buffered') {\n            var _bufferInfo$buffered;\n            const bufferInfo = BufferHelper.bufferInfo(media, liveSyncPosition, 0);\n            if (!(bufferInfo != null && (_bufferInfo$buffered = bufferInfo.buffered) != null && _bufferInfo$buffered.length)) {\n              media.currentTime = liveSyncPosition;\n              return;\n            }\n            const isLiveSyncInBuffer = bufferInfo.start <= currentTime;\n            if (isLiveSyncInBuffer) {\n              media.currentTime = liveSyncPosition;\n              return;\n            }\n            const {\n              nextStart\n            } = BufferHelper.bufferedInfo(bufferInfo.buffered, currentTime, 0);\n            if (nextStart) {\n              media.currentTime = nextStart;\n            }\n          } else {\n            media.currentTime = liveSyncPosition;\n          }\n        }\n      }\n    }\n  }\n  _handleFragmentLoadProgress(data) {\n    var _frag$initSegment;\n    const frag = data.frag;\n    const {\n      part,\n      payload\n    } = data;\n    const {\n      levels\n    } = this;\n    if (!levels) {\n      this.warn(`Levels were reset while fragment load was in progress. Fragment ${frag.sn} of level ${frag.level} will not be buffered`);\n      return;\n    }\n    const currentLevel = levels[frag.level];\n    if (!currentLevel) {\n      this.warn(`Level ${frag.level} not found on progress`);\n      return;\n    }\n    const details = currentLevel.details;\n    if (!details) {\n      this.warn(`Dropping fragment ${frag.sn} of level ${frag.level} after level details were reset`);\n      this.fragmentTracker.removeFragment(frag);\n      return;\n    }\n    const videoCodec = currentLevel.videoCodec;\n\n    // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)\n    const accurateTimeOffset = details.PTSKnown || !details.live;\n    const initSegmentData = (_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.data;\n    const audioCodec = this._getAudioCodec(currentLevel);\n\n    // transmux the MPEG-TS data to ISO-BMFF segments\n    // this.log(`Transmuxing ${frag.sn} of [${details.startSN} ,${details.endSN}],level ${frag.level}, cc ${frag.cc}`);\n    const transmuxer = this.transmuxer = this.transmuxer || new TransmuxerInterface(this.hls, PlaylistLevelType.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));\n    const partIndex = part ? part.index : -1;\n    const partial = partIndex !== -1;\n    const chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);\n    const initPTS = this.initPTS[frag.cc];\n    transmuxer.push(payload, initSegmentData, audioCodec, videoCodec, frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);\n  }\n  onAudioTrackSwitching(event, data) {\n    const hls = this.hls;\n    // if any URL found on new audio track, it is an alternate audio track\n    const fromAltAudio = this.altAudio === 2;\n    const altAudio = useAlternateAudio(data.url, hls);\n    // if we switch on main audio, ensure that main fragment scheduling is synced with media.buffered\n    // don't do anything if we switch to alt audio: audio stream controller is handling it.\n    // we will just have to change buffer scheduling on audioTrackSwitched\n    if (!altAudio) {\n      if (this.mediaBuffer !== this.media) {\n        this.log('Switching on main audio, use media.buffered to schedule main fragment loading');\n        this.mediaBuffer = this.media;\n        const fragCurrent = this.fragCurrent;\n        // we need to refill audio buffer from main: cancel any frag loading to speed up audio switch\n        if (fragCurrent) {\n          this.log('Switching to main audio track, cancel main fragment load');\n          fragCurrent.abortRequests();\n          this.fragmentTracker.removeFragment(fragCurrent);\n        }\n        // destroy transmuxer to force init segment generation (following audio switch)\n        this.resetTransmuxer();\n        // switch to IDLE state to load new fragment\n        this.resetLoadingState();\n      } else if (this.audioOnly) {\n        // Reset audio transmuxer so when switching back to main audio we're not still appending where we left off\n        this.resetTransmuxer();\n      }\n      // If switching from alt to main audio, flush all audio and trigger track switched\n      if (fromAltAudio) {\n        this.fragmentTracker.removeAllFragments();\n        hls.once(Events.BUFFER_FLUSHED, () => {\n          var _this$hls;\n          (_this$hls = this.hls) == null ? void 0 : _this$hls.trigger(Events.AUDIO_TRACK_SWITCHED, data);\n        });\n        hls.trigger(Events.BUFFER_FLUSHING, {\n          startOffset: 0,\n          endOffset: Number.POSITIVE_INFINITY,\n          type: null\n        });\n        return;\n      }\n      hls.trigger(Events.AUDIO_TRACK_SWITCHED, data);\n    } else {\n      this.altAudio = 1;\n    }\n  }\n  onAudioTrackSwitched(event, data) {\n    const altAudio = useAlternateAudio(data.url, this.hls);\n    if (altAudio) {\n      const videoBuffer = this.videoBuffer;\n      // if we switched on alternate audio, ensure that main fragment scheduling is synced with video sourcebuffer buffered\n      if (videoBuffer && this.mediaBuffer !== videoBuffer) {\n        this.log('Switching on alternate audio, use video.buffered to schedule main fragment loading');\n        this.mediaBuffer = videoBuffer;\n      }\n    }\n    this.altAudio = altAudio ? 2 : 0;\n    this.tick();\n  }\n  onBufferCreated(event, data) {\n    const tracks = data.tracks;\n    let mediaTrack;\n    let name;\n    let alternate = false;\n    for (const type in tracks) {\n      const track = tracks[type];\n      if (track.id === 'main') {\n        name = type;\n        mediaTrack = track;\n        // keep video source buffer reference\n        if (type === 'video') {\n          const videoTrack = tracks[type];\n          if (videoTrack) {\n            this.videoBuffer = videoTrack.buffer;\n          }\n        }\n      } else {\n        alternate = true;\n      }\n    }\n    if (alternate && mediaTrack) {\n      this.log(`Alternate track found, use ${name}.buffered to schedule main fragment loading`);\n      this.mediaBuffer = mediaTrack.buffer;\n    } else {\n      this.mediaBuffer = this.media;\n    }\n  }\n  onFragBuffered(event, data) {\n    const {\n      frag,\n      part\n    } = data;\n    const bufferedMainFragment = frag.type === PlaylistLevelType.MAIN;\n    if (bufferedMainFragment) {\n      if (this.fragContextChanged(frag)) {\n        // If a level switch was requested while a fragment was buffering, it will emit the FRAG_BUFFERED event upon completion\n        // Avoid setting state back to IDLE, since that will interfere with a level switch\n        this.warn(`Fragment ${frag.sn}${part ? ' p: ' + part.index : ''} of level ${frag.level} finished buffering, but was aborted. state: ${this.state}`);\n        if (this.state === State.PARSED) {\n          this.state = State.IDLE;\n        }\n        return;\n      }\n      const stats = part ? part.stats : frag.stats;\n      this.fragLastKbps = Math.round(8 * stats.total / (stats.buffering.end - stats.loading.first));\n      if (isMediaFragment(frag)) {\n        this.fragPrevious = frag;\n      }\n      this.fragBufferedComplete(frag, part);\n    }\n    const media = this.media;\n    if (!media) {\n      return;\n    }\n    if (!this._hasEnoughToStart && BufferHelper.getBuffered(media).length) {\n      this._hasEnoughToStart = true;\n      this.seekToStartPos();\n    }\n    if (bufferedMainFragment) {\n      this.tick();\n    }\n  }\n  get hasEnoughToStart() {\n    return this._hasEnoughToStart;\n  }\n  onError(event, data) {\n    var _data$context;\n    if (data.fatal) {\n      this.state = State.ERROR;\n      return;\n    }\n    switch (data.details) {\n      case ErrorDetails.FRAG_GAP:\n      case ErrorDetails.FRAG_PARSING_ERROR:\n      case ErrorDetails.FRAG_DECRYPT_ERROR:\n      case ErrorDetails.FRAG_LOAD_ERROR:\n      case ErrorDetails.FRAG_LOAD_TIMEOUT:\n      case ErrorDetails.KEY_LOAD_ERROR:\n      case ErrorDetails.KEY_LOAD_TIMEOUT:\n        this.onFragmentOrKeyLoadError(PlaylistLevelType.MAIN, data);\n        break;\n      case ErrorDetails.LEVEL_LOAD_ERROR:\n      case ErrorDetails.LEVEL_LOAD_TIMEOUT:\n      case ErrorDetails.LEVEL_PARSING_ERROR:\n        // in case of non fatal error while loading level, if level controller is not retrying to load level, switch back to IDLE\n        if (!data.levelRetry && this.state === State.WAITING_LEVEL && ((_data$context = data.context) == null ? void 0 : _data$context.type) === PlaylistContextType.LEVEL) {\n          this.state = State.IDLE;\n        }\n        break;\n      case ErrorDetails.BUFFER_ADD_CODEC_ERROR:\n      case ErrorDetails.BUFFER_APPEND_ERROR:\n        if (data.parent !== 'main') {\n          return;\n        }\n        if (this.reduceLengthAndFlushBuffer(data)) {\n          this.resetLoadingState();\n        }\n        break;\n      case ErrorDetails.BUFFER_FULL_ERROR:\n        if (data.parent !== 'main') {\n          return;\n        }\n        if (this.reduceLengthAndFlushBuffer(data)) {\n          this.flushMainBuffer(0, Number.POSITIVE_INFINITY);\n        }\n        break;\n      case ErrorDetails.INTERNAL_EXCEPTION:\n        this.recoverWorkerError(data);\n        break;\n    }\n  }\n  onFragLoadEmergencyAborted() {\n    this.state = State.IDLE;\n    // if loadedmetadata is not set, it means that we are emergency switch down on first frag\n    // in that case, reset startFragRequested flag\n    if (!this._hasEnoughToStart) {\n      this.startFragRequested = false;\n      this.nextLoadPosition = this.lastCurrentTime;\n    }\n    this.tickImmediate();\n  }\n  onBufferFlushed(event, {\n    type\n  }) {\n    if (type !== ElementaryStreamTypes.AUDIO || !this.altAudio) {\n      const mediaBuffer = (type === ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;\n      if (mediaBuffer) {\n        this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.MAIN);\n        this.tick();\n      }\n    }\n  }\n  onLevelsUpdated(event, data) {\n    if (this.level > -1 && this.fragCurrent) {\n      this.level = this.fragCurrent.level;\n      if (this.level === -1) {\n        this.resetWhenMissingContext(this.fragCurrent);\n      }\n    }\n    this.levels = data.levels;\n  }\n  swapAudioCodec() {\n    this.audioCodecSwap = !this.audioCodecSwap;\n  }\n\n  /**\n   * Seeks to the set startPosition if not equal to the mediaElement's current time.\n   */\n  seekToStartPos() {\n    const {\n      media\n    } = this;\n    if (!media) {\n      return;\n    }\n    const currentTime = media.currentTime;\n    let startPosition = this.startPosition;\n    // only adjust currentTime if different from startPosition or if startPosition not buffered\n    // at that stage, there should be only one buffered range, as we reach that code after first fragment has been buffered\n    if (startPosition >= 0 && currentTime < startPosition) {\n      if (media.seeking) {\n        this.log(`could not seek to ${startPosition}, already seeking at ${currentTime}`);\n        return;\n      }\n\n      // Offset start position by timeline offset\n      const timelineOffset = this.timelineOffset;\n      if (timelineOffset && startPosition) {\n        startPosition += timelineOffset;\n      }\n      const details = this.getLevelDetails();\n      const buffered = BufferHelper.getBuffered(media);\n      const bufferStart = buffered.length ? buffered.start(0) : 0;\n      const delta = bufferStart - startPosition;\n      const skipTolerance = Math.max(this.config.maxBufferHole, this.config.maxFragLookUpTolerance);\n      if (this.config.startOnSegmentBoundary || delta > 0 && (delta < skipTolerance || this.loadingParts && delta < 2 * ((details == null ? void 0 : details.partTarget) || 0))) {\n        this.log(`adjusting start position by ${delta} to match buffer start`);\n        startPosition += delta;\n        this.startPosition = startPosition;\n      }\n      if (currentTime < startPosition) {\n        this.log(`seek to target start position ${startPosition} from current time ${currentTime} buffer start ${bufferStart}`);\n        media.currentTime = startPosition;\n      }\n    }\n  }\n  _getAudioCodec(currentLevel) {\n    let audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;\n    if (this.audioCodecSwap && audioCodec) {\n      this.log('Swapping audio codec');\n      if (audioCodec.indexOf('mp4a.40.5') !== -1) {\n        audioCodec = 'mp4a.40.2';\n      } else {\n        audioCodec = 'mp4a.40.5';\n      }\n    }\n    return audioCodec;\n  }\n  _loadBitrateTestFrag(fragment, level) {\n    fragment.bitrateTest = true;\n    this._doFragLoad(fragment, level).then(data => {\n      const {\n        hls\n      } = this;\n      const frag = data == null ? void 0 : data.frag;\n      if (!frag || this.fragContextChanged(frag)) {\n        return;\n      }\n      level.fragmentError = 0;\n      this.state = State.IDLE;\n      this.startFragRequested = false;\n      this.bitrateTest = false;\n      const stats = frag.stats;\n      // Bitrate tests fragments are neither parsed nor buffered\n      stats.parsing.start = stats.parsing.end = stats.buffering.start = stats.buffering.end = self.performance.now();\n      hls.trigger(Events.FRAG_LOADED, data);\n      frag.bitrateTest = false;\n    });\n  }\n  _handleTransmuxComplete(transmuxResult) {\n    var _id3$samples;\n    const id = this.playlistType;\n    const {\n      hls\n    } = this;\n    const {\n      remuxResult,\n      chunkMeta\n    } = transmuxResult;\n    const context = this.getCurrentContext(chunkMeta);\n    if (!context) {\n      this.resetWhenMissingContext(chunkMeta);\n      return;\n    }\n    const {\n      frag,\n      part,\n      level\n    } = context;\n    const {\n      video,\n      text,\n      id3,\n      initSegment\n    } = remuxResult;\n    const {\n      details\n    } = level;\n    // The audio-stream-controller handles audio buffering if Hls.js is playing an alternate audio track\n    const audio = this.altAudio ? undefined : remuxResult.audio;\n\n    // Check if the current fragment has been aborted. We check this by first seeing if we're still playing the current level.\n    // If we are, subsequently check if the currently loading fragment (fragCurrent) has changed.\n    if (this.fragContextChanged(frag)) {\n      this.fragmentTracker.removeFragment(frag);\n      return;\n    }\n    this.state = State.PARSING;\n    if (initSegment) {\n      if (initSegment != null && initSegment.tracks) {\n        const mapFragment = frag.initSegment || frag;\n        this._bufferInitSegment(level, initSegment.tracks, mapFragment, chunkMeta);\n        hls.trigger(Events.FRAG_PARSING_INIT_SEGMENT, {\n          frag: mapFragment,\n          id,\n          tracks: initSegment.tracks\n        });\n      }\n\n      // This would be nice if Number.isFinite acted as a typeguard, but it doesn't. See: https://github.com/Microsoft/TypeScript/issues/10038\n      const baseTime = initSegment.initPTS;\n      const timescale = initSegment.timescale;\n      const initPTS = this.initPTS[frag.cc];\n      if (isFiniteNumber(baseTime) && (!initPTS || initPTS.baseTime !== baseTime || initPTS.timescale !== timescale)) {\n        this.initPTS[frag.cc] = {\n          baseTime,\n          timescale\n        };\n        hls.trigger(Events.INIT_PTS_FOUND, {\n          frag,\n          id,\n          initPTS: baseTime,\n          timescale\n        });\n      }\n    }\n\n    // Avoid buffering if backtracking this fragment\n    if (video && details) {\n      if (audio && video.type === 'audiovideo') {\n        this.logMuxedErr(frag);\n      }\n      const prevFrag = details.fragments[frag.sn - 1 - details.startSN];\n      const isFirstFragment = frag.sn === details.startSN;\n      const isFirstInDiscontinuity = !prevFrag || frag.cc > prevFrag.cc;\n      if (remuxResult.independent !== false) {\n        const {\n          startPTS,\n          endPTS,\n          startDTS,\n          endDTS\n        } = video;\n        if (part) {\n          part.elementaryStreams[video.type] = {\n            startPTS,\n            endPTS,\n            startDTS,\n            endDTS\n          };\n        } else {\n          if (video.firstKeyFrame && video.independent && chunkMeta.id === 1 && !isFirstInDiscontinuity) {\n            this.couldBacktrack = true;\n          }\n          if (video.dropped && video.independent) {\n            // Backtrack if dropped frames create a gap after currentTime\n\n            const bufferInfo = this.getMainFwdBufferInfo();\n            const targetBufferTime = (bufferInfo ? bufferInfo.end : this.getLoadPosition()) + this.config.maxBufferHole;\n            const startTime = video.firstKeyFramePTS ? video.firstKeyFramePTS : startPTS;\n            if (!isFirstFragment && targetBufferTime < startTime - this.config.maxBufferHole && !isFirstInDiscontinuity) {\n              this.backtrack(frag);\n              return;\n            } else if (isFirstInDiscontinuity) {\n              // Mark segment with a gap to avoid loop loading\n              frag.gap = true;\n            }\n            // Set video stream start to fragment start so that truncated samples do not distort the timeline, and mark it partial\n            frag.setElementaryStreamInfo(video.type, frag.start, endPTS, frag.start, endDTS, true);\n          } else if (isFirstFragment && startPTS - (details.appliedTimelineOffset || 0) > MAX_START_GAP_JUMP) {\n            // Mark segment with a gap to skip large start gap\n            frag.gap = true;\n          }\n        }\n        frag.setElementaryStreamInfo(video.type, startPTS, endPTS, startDTS, endDTS);\n        if (this.backtrackFragment) {\n          this.backtrackFragment = frag;\n        }\n        this.bufferFragmentData(video, frag, part, chunkMeta, isFirstFragment || isFirstInDiscontinuity);\n      } else if (isFirstFragment || isFirstInDiscontinuity) {\n        // Mark segment with a gap to avoid loop loading\n        frag.gap = true;\n      } else {\n        this.backtrack(frag);\n        return;\n      }\n    }\n    if (audio) {\n      const {\n        startPTS,\n        endPTS,\n        startDTS,\n        endDTS\n      } = audio;\n      if (part) {\n        part.elementaryStreams[ElementaryStreamTypes.AUDIO] = {\n          startPTS,\n          endPTS,\n          startDTS,\n          endDTS\n        };\n      }\n      frag.setElementaryStreamInfo(ElementaryStreamTypes.AUDIO, startPTS, endPTS, startDTS, endDTS);\n      this.bufferFragmentData(audio, frag, part, chunkMeta);\n    }\n    if (details && id3 != null && (_id3$samples = id3.samples) != null && _id3$samples.length) {\n      const emittedID3 = {\n        id,\n        frag,\n        details,\n        samples: id3.samples\n      };\n      hls.trigger(Events.FRAG_PARSING_METADATA, emittedID3);\n    }\n    if (details && text) {\n      const emittedText = {\n        id,\n        frag,\n        details,\n        samples: text.samples\n      };\n      hls.trigger(Events.FRAG_PARSING_USERDATA, emittedText);\n    }\n  }\n  logMuxedErr(frag) {\n    this.warn(`${isMediaFragment(frag) ? 'Media' : 'Init'} segment with muxed audiovideo where only video expected: ${frag.url}`);\n  }\n  _bufferInitSegment(currentLevel, tracks, frag, chunkMeta) {\n    if (this.state !== State.PARSING) {\n      return;\n    }\n    this.audioOnly = !!tracks.audio && !tracks.video;\n\n    // if audio track is expected to come from audio stream controller, discard any coming from main\n    if (this.altAudio && !this.audioOnly) {\n      delete tracks.audio;\n      if (tracks.audiovideo) {\n        this.logMuxedErr(frag);\n      }\n    }\n    // include levelCodec in audio and video tracks\n    const {\n      audio,\n      video,\n      audiovideo\n    } = tracks;\n    if (audio) {\n      const levelCodec = currentLevel.audioCodec;\n      let audioCodec = pickMostCompleteCodecName(audio.codec, levelCodec);\n      // Add level and profile to make up for remuxer not being able to parse full codec\n      // (logger warning \"Unhandled audio codec...\")\n      if (audioCodec === 'mp4a') {\n        audioCodec = 'mp4a.40.5';\n      }\n      // Handle `audioCodecSwitch`\n      const ua = navigator.userAgent.toLowerCase();\n      if (this.audioCodecSwitch) {\n        if (audioCodec) {\n          if (audioCodec.indexOf('mp4a.40.5') !== -1) {\n            audioCodec = 'mp4a.40.2';\n          } else {\n            audioCodec = 'mp4a.40.5';\n          }\n        }\n        // In the case that AAC and HE-AAC audio codecs are signalled in manifest,\n        // force HE-AAC, as it seems that most browsers prefers it.\n        // don't force HE-AAC if mono stream, or in Firefox\n        const audioMetadata = audio.metadata;\n        if (audioMetadata && 'channelCount' in audioMetadata && (audioMetadata.channelCount || 1) !== 1 && ua.indexOf('firefox') === -1) {\n          audioCodec = 'mp4a.40.5';\n        }\n      }\n      // HE-AAC is broken on Android, always signal audio codec as AAC even if variant manifest states otherwise\n      if (audioCodec && audioCodec.indexOf('mp4a.40.5') !== -1 && ua.indexOf('android') !== -1 && audio.container !== 'audio/mpeg') {\n        // Exclude mpeg audio\n        audioCodec = 'mp4a.40.2';\n        this.log(`Android: force audio codec to ${audioCodec}`);\n      }\n      if (levelCodec && levelCodec !== audioCodec) {\n        this.log(`Swapping manifest audio codec \"${levelCodec}\" for \"${audioCodec}\"`);\n      }\n      audio.levelCodec = audioCodec;\n      audio.id = PlaylistLevelType.MAIN;\n      this.log(`Init audio buffer, container:${audio.container}, codecs[selected/level/parsed]=[${audioCodec || ''}/${levelCodec || ''}/${audio.codec}]`);\n      delete tracks.audiovideo;\n    }\n    if (video) {\n      video.levelCodec = currentLevel.videoCodec;\n      video.id = PlaylistLevelType.MAIN;\n      const parsedVideoCodec = video.codec;\n      if ((parsedVideoCodec == null ? void 0 : parsedVideoCodec.length) === 4) {\n        // Make up for passthrough-remuxer not being able to parse full codec\n        // (logger warning \"Unhandled video codec...\")\n        switch (parsedVideoCodec) {\n          case 'hvc1':\n          case 'hev1':\n            video.codec = 'hvc1.1.6.L120.90';\n            break;\n          case 'av01':\n            video.codec = 'av01.0.04M.08';\n            break;\n          case 'avc1':\n            video.codec = 'avc1.42e01e';\n            break;\n        }\n      }\n      this.log(`Init video buffer, container:${video.container}, codecs[level/parsed]=[${currentLevel.videoCodec || ''}/${parsedVideoCodec}]${video.codec !== parsedVideoCodec ? ' parsed-corrected=' + video.codec : ''}${video.supplemental ? ' supplemental=' + video.supplemental : ''}`);\n      delete tracks.audiovideo;\n    }\n    if (audiovideo) {\n      this.log(`Init audiovideo buffer, container:${audiovideo.container}, codecs[level/parsed]=[${currentLevel.codecs}/${audiovideo.codec}]`);\n      delete tracks.video;\n      delete tracks.audio;\n    }\n    const trackTypes = Object.keys(tracks);\n    if (trackTypes.length) {\n      this.hls.trigger(Events.BUFFER_CODECS, tracks);\n      if (!this.hls) {\n        // Exit after fatal tracks error\n        return;\n      }\n      // loop through tracks that are going to be provided to bufferController\n      trackTypes.forEach(trackName => {\n        const track = tracks[trackName];\n        const initSegment = track.initSegment;\n        if (initSegment != null && initSegment.byteLength) {\n          this.hls.trigger(Events.BUFFER_APPENDING, {\n            type: trackName,\n            data: initSegment,\n            frag,\n            part: null,\n            chunkMeta,\n            parent: frag.type\n          });\n        }\n      });\n    }\n    // trigger handler right now\n    this.tickImmediate();\n  }\n  getMainFwdBufferInfo() {\n    // Observe video SourceBuffer (this.mediaBuffer) only when alt-audio is used, otherwise observe combined media buffer\n    const bufferOutput = this.mediaBuffer && this.altAudio === 2 ? this.mediaBuffer : this.media;\n    return this.getFwdBufferInfo(bufferOutput, PlaylistLevelType.MAIN);\n  }\n  get maxBufferLength() {\n    const {\n      levels,\n      level\n    } = this;\n    const levelInfo = levels == null ? void 0 : levels[level];\n    if (!levelInfo) {\n      return this.config.maxBufferLength;\n    }\n    return this.getMaxBufferLength(levelInfo.maxBitrate);\n  }\n  backtrack(frag) {\n    this.couldBacktrack = true;\n    // Causes findFragments to backtrack through fragments to find the keyframe\n    this.backtrackFragment = frag;\n    this.resetTransmuxer();\n    this.flushBufferGap(frag);\n    this.fragmentTracker.removeFragment(frag);\n    this.fragPrevious = null;\n    this.nextLoadPosition = frag.start;\n    this.state = State.IDLE;\n  }\n  checkFragmentChanged() {\n    const video = this.media;\n    let fragPlayingCurrent = null;\n    if (video && video.readyState > 1 && video.seeking === false) {\n      const currentTime = video.currentTime;\n      /* if video element is in seeked state, currentTime can only increase.\n        (assuming that playback rate is positive ...)\n        As sometimes currentTime jumps back to zero after a\n        media decode error, check this, to avoid seeking back to\n        wrong position after a media decode error\n      */\n\n      if (BufferHelper.isBuffered(video, currentTime)) {\n        fragPlayingCurrent = this.getAppendedFrag(currentTime);\n      } else if (BufferHelper.isBuffered(video, currentTime + 0.1)) {\n        /* ensure that FRAG_CHANGED event is triggered at startup,\n          when first video frame is displayed and playback is paused.\n          add a tolerance of 100ms, in case current position is not buffered,\n          check if current pos+100ms is buffered and use that buffer range\n          for FRAG_CHANGED event reporting */\n        fragPlayingCurrent = this.getAppendedFrag(currentTime + 0.1);\n      }\n      if (fragPlayingCurrent) {\n        this.backtrackFragment = null;\n        const fragPlaying = this.fragPlaying;\n        const fragCurrentLevel = fragPlayingCurrent.level;\n        if (!fragPlaying || fragPlayingCurrent.sn !== fragPlaying.sn || fragPlaying.level !== fragCurrentLevel) {\n          this.fragPlaying = fragPlayingCurrent;\n          this.hls.trigger(Events.FRAG_CHANGED, {\n            frag: fragPlayingCurrent\n          });\n          if (!fragPlaying || fragPlaying.level !== fragCurrentLevel) {\n            this.hls.trigger(Events.LEVEL_SWITCHED, {\n              level: fragCurrentLevel\n            });\n          }\n        }\n      }\n    }\n  }\n  get nextLevel() {\n    const frag = this.nextBufferedFrag;\n    if (frag) {\n      return frag.level;\n    }\n    return -1;\n  }\n  get currentFrag() {\n    var _this$media3;\n    if (this.fragPlaying) {\n      return this.fragPlaying;\n    }\n    const currentTime = ((_this$media3 = this.media) == null ? void 0 : _this$media3.currentTime) || this.lastCurrentTime;\n    if (isFiniteNumber(currentTime)) {\n      return this.getAppendedFrag(currentTime);\n    }\n    return null;\n  }\n  get currentProgramDateTime() {\n    var _this$media4;\n    const currentTime = ((_this$media4 = this.media) == null ? void 0 : _this$media4.currentTime) || this.lastCurrentTime;\n    if (isFiniteNumber(currentTime)) {\n      const details = this.getLevelDetails();\n      const frag = this.currentFrag || (details ? findFragmentByPTS(null, details.fragments, currentTime) : null);\n      if (frag) {\n        const programDateTime = frag.programDateTime;\n        if (programDateTime !== null) {\n          const epocMs = programDateTime + (currentTime - frag.start) * 1000;\n          return new Date(epocMs);\n        }\n      }\n    }\n    return null;\n  }\n  get currentLevel() {\n    const frag = this.currentFrag;\n    if (frag) {\n      return frag.level;\n    }\n    return -1;\n  }\n  get nextBufferedFrag() {\n    const frag = this.currentFrag;\n    if (frag) {\n      return this.followingBufferedFrag(frag);\n    }\n    return null;\n  }\n  get forceStartLoad() {\n    return this._forceStartLoad;\n  }\n}\n\nclass KeyLoader {\n  constructor(config) {\n    this.config = void 0;\n    this.keyUriToKeyInfo = {};\n    this.emeController = null;\n    this.config = config;\n  }\n  abort(type) {\n    for (const uri in this.keyUriToKeyInfo) {\n      const loader = this.keyUriToKeyInfo[uri].loader;\n      if (loader) {\n        var _loader$context;\n        if (type && type !== ((_loader$context = loader.context) == null ? void 0 : _loader$context.frag.type)) {\n          return;\n        }\n        loader.abort();\n      }\n    }\n  }\n  detach() {\n    for (const uri in this.keyUriToKeyInfo) {\n      const keyInfo = this.keyUriToKeyInfo[uri];\n      // Remove cached EME keys on detach\n      if (keyInfo.mediaKeySessionContext || keyInfo.decryptdata.isCommonEncryption) {\n        delete this.keyUriToKeyInfo[uri];\n      }\n    }\n  }\n  destroy() {\n    this.detach();\n    for (const uri in this.keyUriToKeyInfo) {\n      const loader = this.keyUriToKeyInfo[uri].loader;\n      if (loader) {\n        loader.destroy();\n      }\n    }\n    this.keyUriToKeyInfo = {};\n  }\n  createKeyLoadError(frag, details = ErrorDetails.KEY_LOAD_ERROR, error, networkDetails, response) {\n    return new LoadError({\n      type: ErrorTypes.NETWORK_ERROR,\n      details,\n      fatal: false,\n      frag,\n      response,\n      error,\n      networkDetails\n    });\n  }\n  loadClear(loadingFrag, encryptedFragments, startFragRequested) {\n    if (this.emeController && this.config.emeEnabled && !this.emeController.getSelectedKeySystemFormats().length) {\n      // Access key-system with nearest key on start (loading frag is unencrypted)\n      if (encryptedFragments.length) {\n        for (let i = 0, l = encryptedFragments.length; i < l; i++) {\n          const frag = encryptedFragments[i];\n          // Loading at or before segment with EXT-X-KEY, or first frag loading and last EXT-X-KEY\n          if (loadingFrag.cc <= frag.cc && (!isMediaFragment(loadingFrag) || !isMediaFragment(frag) || loadingFrag.sn < frag.sn) || !startFragRequested && i == l - 1) {\n            return this.emeController.selectKeySystemFormat(frag).then(keySystemFormat => {\n              if (!this.emeController) {\n                return;\n              }\n              frag.setKeyFormat(keySystemFormat);\n              const keySystem = keySystemFormatToKeySystemDomain(keySystemFormat);\n              if (keySystem) {\n                return this.emeController.getKeySystemAccess([keySystem]);\n              }\n            });\n          }\n        }\n      }\n      if (this.config.requireKeySystemAccessOnStart) {\n        const keySystemsInConfig = getKeySystemsForConfig(this.config);\n        if (keySystemsInConfig.length) {\n          return this.emeController.getKeySystemAccess(keySystemsInConfig);\n        }\n      }\n    }\n    return null;\n  }\n  load(frag) {\n    if (!frag.decryptdata && frag.encrypted && this.emeController && this.config.emeEnabled) {\n      // Multiple keys, but none selected, resolve in eme-controller\n      return this.emeController.selectKeySystemFormat(frag).then(keySystemFormat => {\n        return this.loadInternal(frag, keySystemFormat);\n      });\n    }\n    return this.loadInternal(frag);\n  }\n  loadInternal(frag, keySystemFormat) {\n    var _keyInfo, _keyInfo2;\n    if (keySystemFormat) {\n      frag.setKeyFormat(keySystemFormat);\n    }\n    const decryptdata = frag.decryptdata;\n    if (!decryptdata) {\n      const error = new Error(keySystemFormat ? `Expected frag.decryptdata to be defined after setting format ${keySystemFormat}` : 'Missing decryption data on fragment in onKeyLoading');\n      return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, error));\n    }\n    const uri = decryptdata.uri;\n    if (!uri) {\n      return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(`Invalid key URI: \"${uri}\"`)));\n    }\n    let keyInfo = this.keyUriToKeyInfo[uri];\n    if ((_keyInfo = keyInfo) != null && _keyInfo.decryptdata.key) {\n      decryptdata.key = keyInfo.decryptdata.key;\n      return Promise.resolve({\n        frag,\n        keyInfo\n      });\n    }\n    // Return key load promise as long as it does not have a mediakey session with an unusable key status\n    if ((_keyInfo2 = keyInfo) != null && _keyInfo2.keyLoadPromise) {\n      var _keyInfo$mediaKeySess;\n      switch ((_keyInfo$mediaKeySess = keyInfo.mediaKeySessionContext) == null ? void 0 : _keyInfo$mediaKeySess.keyStatus) {\n        case undefined:\n        case 'status-pending':\n        case 'usable':\n        case 'usable-in-future':\n          return keyInfo.keyLoadPromise.then(keyLoadedData => {\n            // Return the correct fragment with updated decryptdata key and loaded keyInfo\n            decryptdata.key = keyLoadedData.keyInfo.decryptdata.key;\n            return {\n              frag,\n              keyInfo\n            };\n          });\n      }\n      // If we have a key session and status and it is not pending or usable, continue\n      // This will go back to the eme-controller for expired keys to get a new keyLoadPromise\n    }\n\n    // Load the key or return the loading promise\n    keyInfo = this.keyUriToKeyInfo[uri] = {\n      decryptdata,\n      keyLoadPromise: null,\n      loader: null,\n      mediaKeySessionContext: null\n    };\n    switch (decryptdata.method) {\n      case 'ISO-23001-7':\n      case 'SAMPLE-AES':\n      case 'SAMPLE-AES-CENC':\n      case 'SAMPLE-AES-CTR':\n        if (decryptdata.keyFormat === 'identity') {\n          // loadKeyHTTP handles http(s) and data URLs\n          return this.loadKeyHTTP(keyInfo, frag);\n        }\n        return this.loadKeyEME(keyInfo, frag);\n      case 'AES-128':\n      case 'AES-256':\n      case 'AES-256-CTR':\n        return this.loadKeyHTTP(keyInfo, frag);\n      default:\n        return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(`Key supplied with unsupported METHOD: \"${decryptdata.method}\"`)));\n    }\n  }\n  loadKeyEME(keyInfo, frag) {\n    const keyLoadedData = {\n      frag,\n      keyInfo\n    };\n    if (this.emeController && this.config.emeEnabled) {\n      const keySessionContextPromise = this.emeController.loadKey(keyLoadedData);\n      if (keySessionContextPromise) {\n        return (keyInfo.keyLoadPromise = keySessionContextPromise.then(keySessionContext => {\n          keyInfo.mediaKeySessionContext = keySessionContext;\n          return keyLoadedData;\n        })).catch(error => {\n          // Remove promise for license renewal or retry\n          keyInfo.keyLoadPromise = null;\n          throw error;\n        });\n      }\n    }\n    return Promise.resolve(keyLoadedData);\n  }\n  loadKeyHTTP(keyInfo, frag) {\n    const config = this.config;\n    const Loader = config.loader;\n    const keyLoader = new Loader(config);\n    frag.keyLoader = keyInfo.loader = keyLoader;\n    return keyInfo.keyLoadPromise = new Promise((resolve, reject) => {\n      const loaderContext = {\n        keyInfo,\n        frag,\n        responseType: 'arraybuffer',\n        url: keyInfo.decryptdata.uri\n      };\n\n      // maxRetry is 0 so that instead of retrying the same key on the same variant multiple times,\n      // key-loader will trigger an error and rely on stream-controller to handle retry logic.\n      // this will also align retry logic with fragment-loader\n      const loadPolicy = config.keyLoadPolicy.default;\n      const loaderConfig = {\n        loadPolicy,\n        timeout: loadPolicy.maxLoadTimeMs,\n        maxRetry: 0,\n        retryDelay: 0,\n        maxRetryDelay: 0\n      };\n      const loaderCallbacks = {\n        onSuccess: (response, stats, context, networkDetails) => {\n          const {\n            frag,\n            keyInfo,\n            url: uri\n          } = context;\n          if (!frag.decryptdata || keyInfo !== this.keyUriToKeyInfo[uri]) {\n            return reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error('after key load, decryptdata unset or changed'), networkDetails));\n          }\n          keyInfo.decryptdata.key = frag.decryptdata.key = new Uint8Array(response.data);\n\n          // detach fragment key loader on load success\n          frag.keyLoader = null;\n          keyInfo.loader = null;\n          resolve({\n            frag,\n            keyInfo\n          });\n        },\n        onError: (response, context, networkDetails, stats) => {\n          this.resetLoader(context);\n          reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(`HTTP Error ${response.code} loading key ${response.text}`), networkDetails, _objectSpread2({\n            url: loaderContext.url,\n            data: undefined\n          }, response)));\n        },\n        onTimeout: (stats, context, networkDetails) => {\n          this.resetLoader(context);\n          reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_TIMEOUT, new Error('key loading timed out'), networkDetails));\n        },\n        onAbort: (stats, context, networkDetails) => {\n          this.resetLoader(context);\n          reject(this.createKeyLoadError(frag, ErrorDetails.INTERNAL_ABORTED, new Error('key loading aborted'), networkDetails));\n        }\n      };\n      keyLoader.load(loaderContext, loaderConfig, loaderCallbacks);\n    });\n  }\n  resetLoader(context) {\n    const {\n      frag,\n      keyInfo,\n      url: uri\n    } = context;\n    const loader = keyInfo.loader;\n    if (frag.keyLoader === loader) {\n      frag.keyLoader = null;\n      keyInfo.loader = null;\n    }\n    delete this.keyUriToKeyInfo[uri];\n    if (loader) {\n      loader.destroy();\n    }\n  }\n}\n\nfunction mapContextToLevelType(context) {\n  const {\n    type\n  } = context;\n  switch (type) {\n    case PlaylistContextType.AUDIO_TRACK:\n      return PlaylistLevelType.AUDIO;\n    case PlaylistContextType.SUBTITLE_TRACK:\n      return PlaylistLevelType.SUBTITLE;\n    default:\n      return PlaylistLevelType.MAIN;\n  }\n}\nfunction getResponseUrl(response, context) {\n  let url = response.url;\n  // responseURL not supported on some browsers (it is used to detect URL redirection)\n  // data-uri mode also not supported (but no need to detect redirection)\n  if (url === undefined || url.indexOf('data:') === 0) {\n    // fallback to initial URL\n    url = context.url;\n  }\n  return url;\n}\nclass PlaylistLoader {\n  constructor(hls) {\n    this.hls = void 0;\n    this.loaders = Object.create(null);\n    this.variableList = null;\n    this.onManifestLoaded = this.checkAutostartLoad;\n    this.hls = hls;\n    this.registerListeners();\n  }\n  startLoad(startPosition) {}\n  stopLoad() {\n    this.destroyInternalLoaders();\n  }\n  registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.on(Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);\n    hls.on(Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);\n    hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n  }\n  unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.off(Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);\n    hls.off(Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);\n    hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n  }\n\n  /**\n   * Returns defaults or configured loader-type overloads (pLoader and loader config params)\n   */\n  createInternalLoader(context) {\n    const config = this.hls.config;\n    const PLoader = config.pLoader;\n    const Loader = config.loader;\n    const InternalLoader = PLoader || Loader;\n    const loader = new InternalLoader(config);\n    this.loaders[context.type] = loader;\n    return loader;\n  }\n  getInternalLoader(context) {\n    return this.loaders[context.type];\n  }\n  resetInternalLoader(contextType) {\n    if (this.loaders[contextType]) {\n      delete this.loaders[contextType];\n    }\n  }\n\n  /**\n   * Call `destroy` on all internal loader instances mapped (one per context type)\n   */\n  destroyInternalLoaders() {\n    for (const contextType in this.loaders) {\n      const loader = this.loaders[contextType];\n      if (loader) {\n        loader.destroy();\n      }\n      this.resetInternalLoader(contextType);\n    }\n  }\n  destroy() {\n    this.variableList = null;\n    this.unregisterListeners();\n    this.destroyInternalLoaders();\n  }\n  onManifestLoading(event, data) {\n    const {\n      url\n    } = data;\n    this.variableList = null;\n    this.load({\n      id: null,\n      level: 0,\n      responseType: 'text',\n      type: PlaylistContextType.MANIFEST,\n      url,\n      deliveryDirectives: null,\n      levelOrTrack: null\n    });\n  }\n  onLevelLoading(event, data) {\n    const {\n      id,\n      level,\n      pathwayId,\n      url,\n      deliveryDirectives,\n      levelInfo\n    } = data;\n    this.load({\n      id,\n      level,\n      pathwayId,\n      responseType: 'text',\n      type: PlaylistContextType.LEVEL,\n      url,\n      deliveryDirectives,\n      levelOrTrack: levelInfo\n    });\n  }\n  onAudioTrackLoading(event, data) {\n    const {\n      id,\n      groupId,\n      url,\n      deliveryDirectives,\n      track\n    } = data;\n    this.load({\n      id,\n      groupId,\n      level: null,\n      responseType: 'text',\n      type: PlaylistContextType.AUDIO_TRACK,\n      url,\n      deliveryDirectives,\n      levelOrTrack: track\n    });\n  }\n  onSubtitleTrackLoading(event, data) {\n    const {\n      id,\n      groupId,\n      url,\n      deliveryDirectives,\n      track\n    } = data;\n    this.load({\n      id,\n      groupId,\n      level: null,\n      responseType: 'text',\n      type: PlaylistContextType.SUBTITLE_TRACK,\n      url,\n      deliveryDirectives,\n      levelOrTrack: track\n    });\n  }\n  onLevelsUpdated(event, data) {\n    // abort and delete loader of removed levels\n    const loader = this.loaders[PlaylistContextType.LEVEL];\n    if (loader) {\n      const context = loader.context;\n      if (context && !data.levels.some(lvl => lvl === context.levelOrTrack)) {\n        loader.abort();\n        delete this.loaders[PlaylistContextType.LEVEL];\n      }\n    }\n  }\n  load(context) {\n    var _context$deliveryDire;\n    const config = this.hls.config;\n\n    // logger.debug(`[playlist-loader]: Loading playlist of type ${context.type}, level: ${context.level}, id: ${context.id}`);\n\n    // Check if a loader for this context already exists\n    let loader = this.getInternalLoader(context);\n    if (loader) {\n      const logger = this.hls.logger;\n      const loaderContext = loader.context;\n      if (loaderContext && loaderContext.levelOrTrack === context.levelOrTrack && (loaderContext.url === context.url || loaderContext.deliveryDirectives && !context.deliveryDirectives)) {\n        // same URL can't overlap, or wait for blocking request\n        if (loaderContext.url === context.url) {\n          logger.log(`[playlist-loader]: ignore ${context.url} ongoing request`);\n        } else {\n          logger.log(`[playlist-loader]: ignore ${context.url} in favor of ${loaderContext.url}`);\n        }\n        return;\n      }\n      logger.log(`[playlist-loader]: aborting previous loader for type: ${context.type}`);\n      loader.abort();\n    }\n\n    // apply different configs for retries depending on\n    // context (manifest, level, audio/subs playlist)\n    let loadPolicy;\n    if (context.type === PlaylistContextType.MANIFEST) {\n      loadPolicy = config.manifestLoadPolicy.default;\n    } else {\n      loadPolicy = _extends({}, config.playlistLoadPolicy.default, {\n        timeoutRetry: null,\n        errorRetry: null\n      });\n    }\n    loader = this.createInternalLoader(context);\n\n    // Override level/track timeout for LL-HLS requests\n    // (the default of 10000ms is counter productive to blocking playlist reload requests)\n    if (isFiniteNumber((_context$deliveryDire = context.deliveryDirectives) == null ? void 0 : _context$deliveryDire.part)) {\n      let levelDetails;\n      if (context.type === PlaylistContextType.LEVEL && context.level !== null) {\n        levelDetails = this.hls.levels[context.level].details;\n      } else if (context.type === PlaylistContextType.AUDIO_TRACK && context.id !== null) {\n        levelDetails = this.hls.audioTracks[context.id].details;\n      } else if (context.type === PlaylistContextType.SUBTITLE_TRACK && context.id !== null) {\n        levelDetails = this.hls.subtitleTracks[context.id].details;\n      }\n      if (levelDetails) {\n        const partTarget = levelDetails.partTarget;\n        const targetDuration = levelDetails.targetduration;\n        if (partTarget && targetDuration) {\n          const maxLowLatencyPlaylistRefresh = Math.max(partTarget * 3, targetDuration * 0.8) * 1000;\n          loadPolicy = _extends({}, loadPolicy, {\n            maxTimeToFirstByteMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs),\n            maxLoadTimeMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs)\n          });\n        }\n      }\n    }\n    const legacyRetryCompatibility = loadPolicy.errorRetry || loadPolicy.timeoutRetry || {};\n    const loaderConfig = {\n      loadPolicy,\n      timeout: loadPolicy.maxLoadTimeMs,\n      maxRetry: legacyRetryCompatibility.maxNumRetry || 0,\n      retryDelay: legacyRetryCompatibility.retryDelayMs || 0,\n      maxRetryDelay: legacyRetryCompatibility.maxRetryDelayMs || 0\n    };\n    const loaderCallbacks = {\n      onSuccess: (response, stats, context, networkDetails) => {\n        const loader = this.getInternalLoader(context);\n        this.resetInternalLoader(context.type);\n        const string = response.data;\n\n        // Validate if it is an M3U8 at all\n        if (string.indexOf('#EXTM3U') !== 0) {\n          this.handleManifestParsingError(response, context, new Error('no EXTM3U delimiter'), networkDetails || null, stats);\n          return;\n        }\n        stats.parsing.start = performance.now();\n        if (M3U8Parser.isMediaPlaylist(string) || context.type !== PlaylistContextType.MANIFEST) {\n          this.handleTrackOrLevelPlaylist(response, stats, context, networkDetails || null, loader);\n        } else {\n          this.handleMasterPlaylist(response, stats, context, networkDetails);\n        }\n      },\n      onError: (response, context, networkDetails, stats) => {\n        this.handleNetworkError(context, networkDetails, false, response, stats);\n      },\n      onTimeout: (stats, context, networkDetails) => {\n        this.handleNetworkError(context, networkDetails, true, undefined, stats);\n      }\n    };\n\n    // logger.debug(`[playlist-loader]: Calling internal loader delegate for URL: ${context.url}`);\n\n    loader.load(context, loaderConfig, loaderCallbacks);\n  }\n  checkAutostartLoad() {\n    if (!this.hls) {\n      return;\n    }\n    const {\n      config: {\n        autoStartLoad,\n        startPosition\n      },\n      forceStartLoad\n    } = this.hls;\n    if (autoStartLoad || forceStartLoad) {\n      this.hls.logger.log(`${autoStartLoad ? 'auto' : 'force'} startLoad with configured startPosition ${startPosition}`);\n      this.hls.startLoad(startPosition);\n    }\n  }\n  handleMasterPlaylist(response, stats, context, networkDetails) {\n    const hls = this.hls;\n    const string = response.data;\n    const url = getResponseUrl(response, context);\n    const parsedResult = M3U8Parser.parseMasterPlaylist(string, url);\n    if (parsedResult.playlistParsingError) {\n      this.handleManifestParsingError(response, context, parsedResult.playlistParsingError, networkDetails, stats);\n      return;\n    }\n    const {\n      contentSteering,\n      levels,\n      sessionData,\n      sessionKeys,\n      startTimeOffset,\n      variableList\n    } = parsedResult;\n    this.variableList = variableList;\n    const {\n      AUDIO: audioTracks = [],\n      SUBTITLES: subtitles,\n      'CLOSED-CAPTIONS': captions\n    } = M3U8Parser.parseMasterPlaylistMedia(string, url, parsedResult);\n    if (audioTracks.length) {\n      // check if we have found an audio track embedded in main playlist (audio track without URI attribute)\n      const embeddedAudioFound = audioTracks.some(audioTrack => !audioTrack.url);\n\n      // if no embedded audio track defined, but audio codec signaled in quality level,\n      // we need to signal this main audio track this could happen with playlists with\n      // alt audio rendition in which quality levels (main)\n      // contains both audio+video. but with mixed audio track not signaled\n      if (!embeddedAudioFound && levels[0].audioCodec && !levels[0].attrs.AUDIO) {\n        this.hls.logger.log('[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one');\n        audioTracks.unshift({\n          type: 'main',\n          name: 'main',\n          groupId: 'main',\n          default: false,\n          autoselect: false,\n          forced: false,\n          id: -1,\n          attrs: new AttrList({}),\n          bitrate: 0,\n          url: ''\n        });\n      }\n    }\n    hls.trigger(Events.MANIFEST_LOADED, {\n      levels,\n      audioTracks,\n      subtitles,\n      captions,\n      contentSteering,\n      url,\n      stats,\n      networkDetails,\n      sessionData,\n      sessionKeys,\n      startTimeOffset,\n      variableList\n    });\n  }\n  handleTrackOrLevelPlaylist(response, stats, context, networkDetails, loader) {\n    const hls = this.hls;\n    const {\n      id,\n      level,\n      type\n    } = context;\n    const url = getResponseUrl(response, context);\n    const levelId = isFiniteNumber(level) ? level : isFiniteNumber(id) ? id : 0;\n    const levelType = mapContextToLevelType(context);\n    const levelDetails = M3U8Parser.parseLevelPlaylist(response.data, url, levelId, levelType, 0, this.variableList);\n\n    // We have done our first request (Manifest-type) and receive\n    // not a master playlist but a chunk-list (track/level)\n    // We fire the manifest-loaded event anyway with the parsed level-details\n    // by creating a single-level structure for it.\n    if (type === PlaylistContextType.MANIFEST) {\n      const singleLevel = {\n        attrs: new AttrList({}),\n        bitrate: 0,\n        details: levelDetails,\n        name: '',\n        url\n      };\n      levelDetails.requestScheduled = stats.loading.start + computeReloadInterval(levelDetails, 0);\n      hls.trigger(Events.MANIFEST_LOADED, {\n        levels: [singleLevel],\n        audioTracks: [],\n        url,\n        stats,\n        networkDetails,\n        sessionData: null,\n        sessionKeys: null,\n        contentSteering: null,\n        startTimeOffset: null,\n        variableList: null\n      });\n    }\n\n    // save parsing time\n    stats.parsing.end = performance.now();\n\n    // extend the context with the new levelDetails property\n    context.levelDetails = levelDetails;\n    this.handlePlaylistLoaded(levelDetails, response, stats, context, networkDetails, loader);\n  }\n  handleManifestParsingError(response, context, error, networkDetails, stats) {\n    this.hls.trigger(Events.ERROR, {\n      type: ErrorTypes.NETWORK_ERROR,\n      details: ErrorDetails.MANIFEST_PARSING_ERROR,\n      fatal: context.type === PlaylistContextType.MANIFEST,\n      url: response.url,\n      err: error,\n      error,\n      reason: error.message,\n      response,\n      context,\n      networkDetails,\n      stats\n    });\n  }\n  handleNetworkError(context, networkDetails, timeout = false, response, stats) {\n    let message = `A network ${timeout ? 'timeout' : 'error' + (response ? ' (status ' + response.code + ')' : '')} occurred while loading ${context.type}`;\n    if (context.type === PlaylistContextType.LEVEL) {\n      message += `: ${context.level} id: ${context.id}`;\n    } else if (context.type === PlaylistContextType.AUDIO_TRACK || context.type === PlaylistContextType.SUBTITLE_TRACK) {\n      message += ` id: ${context.id} group-id: \"${context.groupId}\"`;\n    }\n    const error = new Error(message);\n    this.hls.logger.warn(`[playlist-loader]: ${message}`);\n    let details = ErrorDetails.UNKNOWN;\n    let fatal = false;\n    const loader = this.getInternalLoader(context);\n    switch (context.type) {\n      case PlaylistContextType.MANIFEST:\n        details = timeout ? ErrorDetails.MANIFEST_LOAD_TIMEOUT : ErrorDetails.MANIFEST_LOAD_ERROR;\n        fatal = true;\n        break;\n      case PlaylistContextType.LEVEL:\n        details = timeout ? ErrorDetails.LEVEL_LOAD_TIMEOUT : ErrorDetails.LEVEL_LOAD_ERROR;\n        fatal = false;\n        break;\n      case PlaylistContextType.AUDIO_TRACK:\n        details = timeout ? ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT : ErrorDetails.AUDIO_TRACK_LOAD_ERROR;\n        fatal = false;\n        break;\n      case PlaylistContextType.SUBTITLE_TRACK:\n        details = timeout ? ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT : ErrorDetails.SUBTITLE_LOAD_ERROR;\n        fatal = false;\n        break;\n    }\n    if (loader) {\n      this.resetInternalLoader(context.type);\n    }\n    const errorData = {\n      type: ErrorTypes.NETWORK_ERROR,\n      details,\n      fatal,\n      url: context.url,\n      loader,\n      context,\n      error,\n      networkDetails,\n      stats\n    };\n    if (response) {\n      const url = (networkDetails == null ? void 0 : networkDetails.url) || context.url;\n      errorData.response = _objectSpread2({\n        url,\n        data: undefined\n      }, response);\n    }\n    this.hls.trigger(Events.ERROR, errorData);\n  }\n  handlePlaylistLoaded(levelDetails, response, stats, context, networkDetails, loader) {\n    const hls = this.hls;\n    const {\n      type,\n      level,\n      id,\n      groupId,\n      deliveryDirectives\n    } = context;\n    const url = getResponseUrl(response, context);\n    const parent = mapContextToLevelType(context);\n    const levelIndex = typeof context.level === 'number' && parent === PlaylistLevelType.MAIN ? level : undefined;\n    if (!levelDetails.fragments.length) {\n      const _error = levelDetails.playlistParsingError = new Error('No Segments found in Playlist');\n      hls.trigger(Events.ERROR, {\n        type: ErrorTypes.NETWORK_ERROR,\n        details: ErrorDetails.LEVEL_EMPTY_ERROR,\n        fatal: false,\n        url,\n        error: _error,\n        reason: _error.message,\n        response,\n        context,\n        level: levelIndex,\n        parent,\n        networkDetails,\n        stats\n      });\n      return;\n    }\n    if (!levelDetails.targetduration) {\n      levelDetails.playlistParsingError = new Error('Missing Target Duration');\n    }\n    const error = levelDetails.playlistParsingError;\n    if (error) {\n      this.hls.logger.warn(error);\n      if (!hls.config.ignorePlaylistParsingErrors) {\n        hls.trigger(Events.ERROR, {\n          type: ErrorTypes.NETWORK_ERROR,\n          details: ErrorDetails.LEVEL_PARSING_ERROR,\n          fatal: false,\n          url,\n          error,\n          reason: error.message,\n          response,\n          context,\n          level: levelIndex,\n          parent,\n          networkDetails,\n          stats\n        });\n        return;\n      }\n      levelDetails.playlistParsingError = null;\n    }\n    if (levelDetails.live && loader) {\n      if (loader.getCacheAge) {\n        levelDetails.ageHeader = loader.getCacheAge() || 0;\n      }\n      if (!loader.getCacheAge || isNaN(levelDetails.ageHeader)) {\n        levelDetails.ageHeader = 0;\n      }\n    }\n    switch (type) {\n      case PlaylistContextType.MANIFEST:\n      case PlaylistContextType.LEVEL:\n        hls.trigger(Events.LEVEL_LOADED, {\n          details: levelDetails,\n          levelInfo: context.levelOrTrack || hls.levels[0],\n          level: levelIndex || 0,\n          id: id || 0,\n          stats,\n          networkDetails,\n          deliveryDirectives,\n          withoutMultiVariant: type === PlaylistContextType.MANIFEST\n        });\n        break;\n      case PlaylistContextType.AUDIO_TRACK:\n        hls.trigger(Events.AUDIO_TRACK_LOADED, {\n          details: levelDetails,\n          track: context.levelOrTrack,\n          id: id || 0,\n          groupId: groupId || '',\n          stats,\n          networkDetails,\n          deliveryDirectives\n        });\n        break;\n      case PlaylistContextType.SUBTITLE_TRACK:\n        hls.trigger(Events.SUBTITLE_TRACK_LOADED, {\n          details: levelDetails,\n          track: context.levelOrTrack,\n          id: id || 0,\n          groupId: groupId || '',\n          stats,\n          networkDetails,\n          deliveryDirectives\n        });\n        break;\n    }\n  }\n}\n\n/**\n * The `Hls` class is the core of the HLS.js library used to instantiate player instances.\n * @public\n */\nclass Hls {\n  /**\n   * Get the video-dev/hls.js package version.\n   */\n  static get version() {\n    return version;\n  }\n\n  /**\n   * Check if the required MediaSource Extensions are available.\n   */\n  static isMSESupported() {\n    return isMSESupported();\n  }\n\n  /**\n   * Check if MediaSource Extensions are available and isTypeSupported checks pass for any baseline codecs.\n   */\n  static isSupported() {\n    return isSupported();\n  }\n\n  /**\n   * Get the MediaSource global used for MSE playback (ManagedMediaSource, MediaSource, or WebKitMediaSource).\n   */\n  static getMediaSource() {\n    return getMediaSource();\n  }\n  static get Events() {\n    return Events;\n  }\n  static get MetadataSchema() {\n    return MetadataSchema;\n  }\n  static get ErrorTypes() {\n    return ErrorTypes;\n  }\n  static get ErrorDetails() {\n    return ErrorDetails;\n  }\n\n  /**\n   * Get the default configuration applied to new instances.\n   */\n  static get DefaultConfig() {\n    if (!Hls.defaultConfig) {\n      return hlsDefaultConfig;\n    }\n    return Hls.defaultConfig;\n  }\n\n  /**\n   * Replace the default configuration applied to new instances.\n   */\n  static set DefaultConfig(defaultConfig) {\n    Hls.defaultConfig = defaultConfig;\n  }\n\n  /**\n   * Creates an instance of an HLS client that can attach to exactly one `HTMLMediaElement`.\n   * @param userConfig - Configuration options applied over `Hls.DefaultConfig`\n   */\n  constructor(userConfig = {}) {\n    /**\n     * The runtime configuration used by the player. At instantiation this is combination of `hls.userConfig` merged over `Hls.DefaultConfig`.\n     */\n    this.config = void 0;\n    /**\n     * The configuration object provided on player instantiation.\n     */\n    this.userConfig = void 0;\n    /**\n     * The logger functions used by this player instance, configured on player instantiation.\n     */\n    this.logger = void 0;\n    this.coreComponents = void 0;\n    this.networkControllers = void 0;\n    this._emitter = new EventEmitter();\n    this._autoLevelCapping = -1;\n    this._maxHdcpLevel = null;\n    this.abrController = void 0;\n    this.bufferController = void 0;\n    this.capLevelController = void 0;\n    this.latencyController = void 0;\n    this.levelController = void 0;\n    this.streamController = void 0;\n    this.audioStreamController = void 0;\n    this.subtititleStreamController = void 0;\n    this.audioTrackController = void 0;\n    this.subtitleTrackController = void 0;\n    this.interstitialsController = void 0;\n    this.gapController = void 0;\n    this.emeController = void 0;\n    this.cmcdController = void 0;\n    this._media = null;\n    this._url = null;\n    this._sessionId = void 0;\n    this.triggeringException = void 0;\n    this.started = false;\n    const logger = this.logger = enableLogs(userConfig.debug || false, 'Hls instance', userConfig.assetPlayerId);\n    const config = this.config = mergeConfig(Hls.DefaultConfig, userConfig, logger);\n    this.userConfig = userConfig;\n    if (config.progressive) {\n      enableStreamingMode(config, logger);\n    }\n\n    // core controllers and network loaders\n    const {\n      abrController: _AbrController,\n      bufferController: _BufferController,\n      capLevelController: _CapLevelController,\n      errorController: _ErrorController,\n      fpsController: _FpsController\n    } = config;\n    const errorController = new _ErrorController(this);\n    const abrController = this.abrController = new _AbrController(this);\n    // FragmentTracker must be defined before StreamController because the order of event handling is important\n    const fragmentTracker = new FragmentTracker(this);\n    const _InterstitialsController = config.interstitialsController;\n    const interstitialsController = _InterstitialsController ? this.interstitialsController = new _InterstitialsController(this, Hls) : null;\n    const bufferController = this.bufferController = new _BufferController(this, fragmentTracker);\n    const capLevelController = this.capLevelController = new _CapLevelController(this);\n    const fpsController = new _FpsController(this);\n    const playListLoader = new PlaylistLoader(this);\n    const _ContentSteeringController = config.contentSteeringController;\n    // Instantiate ConentSteeringController before LevelController to receive Multivariant Playlist events first\n    const contentSteering = _ContentSteeringController ? new _ContentSteeringController(this) : null;\n    const levelController = this.levelController = new LevelController(this, contentSteering);\n    const id3TrackController = new ID3TrackController(this);\n    const keyLoader = new KeyLoader(this.config);\n    const streamController = this.streamController = new StreamController(this, fragmentTracker, keyLoader);\n    const gapController = this.gapController = new GapController(this, fragmentTracker);\n\n    // Cap level controller uses streamController to flush the buffer\n    capLevelController.setStreamController(streamController);\n    // fpsController uses streamController to switch when frames are being dropped\n    fpsController.setStreamController(streamController);\n    const networkControllers = [playListLoader, levelController, streamController];\n    if (interstitialsController) {\n      networkControllers.splice(1, 0, interstitialsController);\n    }\n    if (contentSteering) {\n      networkControllers.splice(1, 0, contentSteering);\n    }\n    this.networkControllers = networkControllers;\n    const coreComponents = [abrController, bufferController, gapController, capLevelController, fpsController, id3TrackController, fragmentTracker];\n    this.audioTrackController = this.createController(config.audioTrackController, networkControllers);\n    const AudioStreamControllerClass = config.audioStreamController;\n    if (AudioStreamControllerClass) {\n      networkControllers.push(this.audioStreamController = new AudioStreamControllerClass(this, fragmentTracker, keyLoader));\n    }\n    // Instantiate subtitleTrackController before SubtitleStreamController to receive level events first\n    this.subtitleTrackController = this.createController(config.subtitleTrackController, networkControllers);\n    const SubtitleStreamControllerClass = config.subtitleStreamController;\n    if (SubtitleStreamControllerClass) {\n      networkControllers.push(this.subtititleStreamController = new SubtitleStreamControllerClass(this, fragmentTracker, keyLoader));\n    }\n    this.createController(config.timelineController, coreComponents);\n    keyLoader.emeController = this.emeController = this.createController(config.emeController, coreComponents);\n    this.cmcdController = this.createController(config.cmcdController, coreComponents);\n    this.latencyController = this.createController(LatencyController, coreComponents);\n    this.coreComponents = coreComponents;\n\n    // Error controller handles errors before and after all other controllers\n    // This listener will be invoked after all other controllers error listeners\n    networkControllers.push(errorController);\n    const onErrorOut = errorController.onErrorOut;\n    if (typeof onErrorOut === 'function') {\n      this.on(Events.ERROR, onErrorOut, errorController);\n    }\n    // Autostart load handler\n    this.on(Events.MANIFEST_LOADED, playListLoader.onManifestLoaded, playListLoader);\n  }\n  createController(ControllerClass, components) {\n    if (ControllerClass) {\n      const controllerInstance = new ControllerClass(this);\n      if (components) {\n        components.push(controllerInstance);\n      }\n      return controllerInstance;\n    }\n    return null;\n  }\n\n  // Delegate the EventEmitter through the public API of Hls.js\n  on(event, listener, context = this) {\n    this._emitter.on(event, listener, context);\n  }\n  once(event, listener, context = this) {\n    this._emitter.once(event, listener, context);\n  }\n  removeAllListeners(event) {\n    this._emitter.removeAllListeners(event);\n  }\n  off(event, listener, context = this, once) {\n    this._emitter.off(event, listener, context, once);\n  }\n  listeners(event) {\n    return this._emitter.listeners(event);\n  }\n  emit(event, name, eventObject) {\n    return this._emitter.emit(event, name, eventObject);\n  }\n  trigger(event, eventObject) {\n    if (this.config.debug) {\n      return this.emit(event, event, eventObject);\n    } else {\n      try {\n        return this.emit(event, event, eventObject);\n      } catch (error) {\n        this.logger.error('An internal error happened while handling event ' + event + '. Error message: \"' + error.message + '\". Here is a stacktrace:', error);\n        // Prevent recursion in error event handlers that throw #5497\n        if (!this.triggeringException) {\n          this.triggeringException = true;\n          const fatal = event === Events.ERROR;\n          this.trigger(Events.ERROR, {\n            type: ErrorTypes.OTHER_ERROR,\n            details: ErrorDetails.INTERNAL_EXCEPTION,\n            fatal,\n            event,\n            error\n          });\n          this.triggeringException = false;\n        }\n      }\n    }\n    return false;\n  }\n  listenerCount(event) {\n    return this._emitter.listenerCount(event);\n  }\n\n  /**\n   * Dispose of the instance\n   */\n  destroy() {\n    this.logger.log('destroy');\n    this.trigger(Events.DESTROYING, undefined);\n    this.detachMedia();\n    this.removeAllListeners();\n    this._autoLevelCapping = -1;\n    this._url = null;\n    this.networkControllers.forEach(component => component.destroy());\n    this.networkControllers.length = 0;\n    this.coreComponents.forEach(component => component.destroy());\n    this.coreComponents.length = 0;\n    // Remove any references that could be held in config options or callbacks\n    const config = this.config;\n    config.xhrSetup = config.fetchSetup = undefined;\n    // @ts-ignore\n    this.userConfig = null;\n  }\n\n  /**\n   * Attaches Hls.js to a media element\n   */\n  attachMedia(data) {\n    if (!data || 'media' in data && !data.media) {\n      const error = new Error(`attachMedia failed: invalid argument (${data})`);\n      this.trigger(Events.ERROR, {\n        type: ErrorTypes.OTHER_ERROR,\n        details: ErrorDetails.ATTACH_MEDIA_ERROR,\n        fatal: true,\n        error\n      });\n      return;\n    }\n    this.logger.log(`attachMedia`);\n    if (this._media) {\n      this.logger.warn(`media must be detached before attaching`);\n      this.detachMedia();\n    }\n    const attachMediaSource = 'media' in data;\n    const media = attachMediaSource ? data.media : data;\n    const attachingData = attachMediaSource ? data : {\n      media\n    };\n    this._media = media;\n    this.trigger(Events.MEDIA_ATTACHING, attachingData);\n  }\n\n  /**\n   * Detach Hls.js from the media\n   */\n  detachMedia() {\n    this.logger.log('detachMedia');\n    this.trigger(Events.MEDIA_DETACHING, {});\n    this._media = null;\n  }\n\n  /**\n   * Detach HTMLMediaElement, MediaSource, and SourceBuffers without reset, for attaching to another instance\n   */\n  transferMedia() {\n    this._media = null;\n    const transferMedia = this.bufferController.transferMedia();\n    this.trigger(Events.MEDIA_DETACHING, {\n      transferMedia\n    });\n    return transferMedia;\n  }\n\n  /**\n   * Set the source URL. Can be relative or absolute.\n   */\n  loadSource(url) {\n    this.stopLoad();\n    const media = this.media;\n    const loadedSource = this._url;\n    const loadingSource = this._url = urlToolkitExports.buildAbsoluteURL(self.location.href, url, {\n      alwaysNormalize: true\n    });\n    this._autoLevelCapping = -1;\n    this._maxHdcpLevel = null;\n    this.logger.log(`loadSource:${loadingSource}`);\n    if (media && loadedSource && (loadedSource !== loadingSource || this.bufferController.hasSourceTypes())) {\n      // Remove and re-create MediaSource\n      this.detachMedia();\n      this.attachMedia(media);\n    }\n    // when attaching to a source URL, trigger a playlist load\n    this.trigger(Events.MANIFEST_LOADING, {\n      url: url\n    });\n  }\n\n  /**\n   * Gets the currently loaded URL\n   */\n  get url() {\n    return this._url;\n  }\n\n  /**\n   * Whether or not enough has been buffered to seek to start position or use `media.currentTime` to determine next load position\n   */\n  get hasEnoughToStart() {\n    return this.streamController.hasEnoughToStart;\n  }\n\n  /**\n   * Get the startPosition set on startLoad(position) or on autostart with config.startPosition\n   */\n  get startPosition() {\n    return this.streamController.startPositionValue;\n  }\n\n  /**\n   * Start loading data from the stream source.\n   * Depending on default config, client starts loading automatically when a source is set.\n   *\n   * @param startPosition - Set the start position to stream from.\n   * Defaults to -1 (None: starts from earliest point)\n   */\n  startLoad(startPosition = -1, skipSeekToStartPosition) {\n    this.logger.log(`startLoad(${startPosition + (skipSeekToStartPosition ? ', <skip seek to start>' : '')})`);\n    this.started = true;\n    this.resumeBuffering();\n    for (let i = 0; i < this.networkControllers.length; i++) {\n      this.networkControllers[i].startLoad(startPosition, skipSeekToStartPosition);\n      if (!this.started || !this.networkControllers) {\n        break;\n      }\n    }\n  }\n\n  /**\n   * Stop loading of any stream data.\n   */\n  stopLoad() {\n    this.logger.log('stopLoad');\n    this.started = false;\n    for (let i = 0; i < this.networkControllers.length; i++) {\n      this.networkControllers[i].stopLoad();\n      if (this.started || !this.networkControllers) {\n        break;\n      }\n    }\n  }\n\n  /**\n   * Returns whether loading, toggled with `startLoad()` and `stopLoad()`, is active or not`.\n   */\n  get loadingEnabled() {\n    return this.started;\n  }\n\n  /**\n   * Returns state of fragment loading toggled by calling `pauseBuffering()` and `resumeBuffering()`.\n   */\n  get bufferingEnabled() {\n    return this.streamController.bufferingEnabled;\n  }\n\n  /**\n   * Resumes stream controller segment loading after `pauseBuffering` has been called.\n   */\n  resumeBuffering() {\n    if (!this.bufferingEnabled) {\n      this.logger.log(`resume buffering`);\n      this.networkControllers.forEach(controller => {\n        if (controller.resumeBuffering) {\n          controller.resumeBuffering();\n        }\n      });\n    }\n  }\n\n  /**\n   * Prevents stream controller from loading new segments until `resumeBuffering` is called.\n   * This allows for media buffering to be paused without interupting playlist loading.\n   */\n  pauseBuffering() {\n    if (this.bufferingEnabled) {\n      this.logger.log(`pause buffering`);\n      this.networkControllers.forEach(controller => {\n        if (controller.pauseBuffering) {\n          controller.pauseBuffering();\n        }\n      });\n    }\n  }\n  get inFlightFragments() {\n    const inFlightData = {\n      [PlaylistLevelType.MAIN]: this.streamController.inFlightFrag\n    };\n    if (this.audioStreamController) {\n      inFlightData[PlaylistLevelType.AUDIO] = this.audioStreamController.inFlightFrag;\n    }\n    if (this.subtititleStreamController) {\n      inFlightData[PlaylistLevelType.SUBTITLE] = this.subtititleStreamController.inFlightFrag;\n    }\n    return inFlightData;\n  }\n\n  /**\n   * Swap through possible audio codecs in the stream (for example to switch from stereo to 5.1)\n   */\n  swapAudioCodec() {\n    this.logger.log('swapAudioCodec');\n    this.streamController.swapAudioCodec();\n  }\n\n  /**\n   * When the media-element fails, this allows to detach and then re-attach it\n   * as one call (convenience method).\n   *\n   * Automatic recovery of media-errors by this process is configurable.\n   */\n  recoverMediaError() {\n    this.logger.log('recoverMediaError');\n    const media = this._media;\n    const time = media == null ? void 0 : media.currentTime;\n    this.detachMedia();\n    if (media) {\n      this.attachMedia(media);\n      if (time) {\n        this.startLoad(time);\n      }\n    }\n  }\n  removeLevel(levelIndex) {\n    this.levelController.removeLevel(levelIndex);\n  }\n\n  /**\n   * @returns a UUID for this player instance\n   */\n  get sessionId() {\n    let _sessionId = this._sessionId;\n    if (!_sessionId) {\n      _sessionId = this._sessionId = uuid();\n    }\n    return _sessionId;\n  }\n\n  /**\n   * @returns an array of levels (variants) sorted by HDCP-LEVEL, RESOLUTION (height), FRAME-RATE, CODECS, VIDEO-RANGE, and BANDWIDTH\n   */\n  get levels() {\n    const levels = this.levelController.levels;\n    return levels ? levels : [];\n  }\n\n  /**\n   * @returns LevelDetails of last loaded level (variant) or `null` prior to loading a media playlist.\n   */\n  get latestLevelDetails() {\n    return this.streamController.getLevelDetails() || null;\n  }\n\n  /**\n   * @returns Level object of selected level (variant) or `null` prior to selecting a level or once the level is removed.\n   */\n  get loadLevelObj() {\n    return this.levelController.loadLevelObj;\n  }\n\n  /**\n   * Index of quality level (variant) currently played\n   */\n  get currentLevel() {\n    return this.streamController.currentLevel;\n  }\n\n  /**\n   * Set quality level index immediately. This will flush the current buffer to replace the quality asap. That means playback will interrupt at least shortly to re-buffer and re-sync eventually. Set to -1 for automatic level selection.\n   */\n  set currentLevel(newLevel) {\n    this.logger.log(`set currentLevel:${newLevel}`);\n    this.levelController.manualLevel = newLevel;\n    this.streamController.immediateLevelSwitch();\n  }\n\n  /**\n   * Index of next quality level loaded as scheduled by stream controller.\n   */\n  get nextLevel() {\n    return this.streamController.nextLevel;\n  }\n\n  /**\n   * Set quality level index for next loaded data.\n   * This will switch the video quality asap, without interrupting playback.\n   * May abort current loading of data, and flush parts of buffer (outside currently played fragment region).\n   * @param newLevel - Pass -1 for automatic level selection\n   */\n  set nextLevel(newLevel) {\n    this.logger.log(`set nextLevel:${newLevel}`);\n    this.levelController.manualLevel = newLevel;\n    this.streamController.nextLevelSwitch();\n  }\n\n  /**\n   * Return the quality level of the currently or last (of none is loaded currently) segment\n   */\n  get loadLevel() {\n    return this.levelController.level;\n  }\n\n  /**\n   * Set quality level index for next loaded data in a conservative way.\n   * This will switch the quality without flushing, but interrupt current loading.\n   * Thus the moment when the quality switch will appear in effect will only be after the already existing buffer.\n   * @param newLevel - Pass -1 for automatic level selection\n   */\n  set loadLevel(newLevel) {\n    this.logger.log(`set loadLevel:${newLevel}`);\n    this.levelController.manualLevel = newLevel;\n  }\n\n  /**\n   * get next quality level loaded\n   */\n  get nextLoadLevel() {\n    return this.levelController.nextLoadLevel;\n  }\n\n  /**\n   * Set quality level of next loaded segment in a fully \"non-destructive\" way.\n   * Same as `loadLevel` but will wait for next switch (until current loading is done).\n   */\n  set nextLoadLevel(level) {\n    this.levelController.nextLoadLevel = level;\n  }\n\n  /**\n   * Return \"first level\": like a default level, if not set,\n   * falls back to index of first level referenced in manifest\n   */\n  get firstLevel() {\n    return Math.max(this.levelController.firstLevel, this.minAutoLevel);\n  }\n\n  /**\n   * Sets \"first-level\", see getter.\n   */\n  set firstLevel(newLevel) {\n    this.logger.log(`set firstLevel:${newLevel}`);\n    this.levelController.firstLevel = newLevel;\n  }\n\n  /**\n   * Return the desired start level for the first fragment that will be loaded.\n   * The default value of -1 indicates automatic start level selection.\n   * Setting hls.nextAutoLevel without setting a startLevel will result in\n   * the nextAutoLevel value being used for one fragment load.\n   */\n  get startLevel() {\n    const startLevel = this.levelController.startLevel;\n    if (startLevel === -1 && this.abrController.forcedAutoLevel > -1) {\n      return this.abrController.forcedAutoLevel;\n    }\n    return startLevel;\n  }\n\n  /**\n   * set  start level (level of first fragment that will be played back)\n   * if not overrided by user, first level appearing in manifest will be used as start level\n   * if -1 : automatic start level selection, playback will start from level matching download bandwidth\n   * (determined from download of first segment)\n   */\n  set startLevel(newLevel) {\n    this.logger.log(`set startLevel:${newLevel}`);\n    // if not in automatic start level detection, ensure startLevel is greater than minAutoLevel\n    if (newLevel !== -1) {\n      newLevel = Math.max(newLevel, this.minAutoLevel);\n    }\n    this.levelController.startLevel = newLevel;\n  }\n\n  /**\n   * Whether level capping is enabled.\n   * Default value is set via `config.capLevelToPlayerSize`.\n   */\n  get capLevelToPlayerSize() {\n    return this.config.capLevelToPlayerSize;\n  }\n\n  /**\n   * Enables or disables level capping. If disabled after previously enabled, `nextLevelSwitch` will be immediately called.\n   */\n  set capLevelToPlayerSize(shouldStartCapping) {\n    const newCapLevelToPlayerSize = !!shouldStartCapping;\n    if (newCapLevelToPlayerSize !== this.config.capLevelToPlayerSize) {\n      if (newCapLevelToPlayerSize) {\n        this.capLevelController.startCapping(); // If capping occurs, nextLevelSwitch will happen based on size.\n      } else {\n        this.capLevelController.stopCapping();\n        this.autoLevelCapping = -1;\n        this.streamController.nextLevelSwitch(); // Now we're uncapped, get the next level asap.\n      }\n      this.config.capLevelToPlayerSize = newCapLevelToPlayerSize;\n    }\n  }\n\n  /**\n   * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)\n   */\n  get autoLevelCapping() {\n    return this._autoLevelCapping;\n  }\n\n  /**\n   * Returns the current bandwidth estimate in bits per second, when available. Otherwise, `NaN` is returned.\n   */\n  get bandwidthEstimate() {\n    const {\n      bwEstimator\n    } = this.abrController;\n    if (!bwEstimator) {\n      return NaN;\n    }\n    return bwEstimator.getEstimate();\n  }\n  set bandwidthEstimate(abrEwmaDefaultEstimate) {\n    this.abrController.resetEstimator(abrEwmaDefaultEstimate);\n  }\n  get abrEwmaDefaultEstimate() {\n    const {\n      bwEstimator\n    } = this.abrController;\n    if (!bwEstimator) {\n      return NaN;\n    }\n    return bwEstimator.defaultEstimate;\n  }\n\n  /**\n   * get time to first byte estimate\n   * @type {number}\n   */\n  get ttfbEstimate() {\n    const {\n      bwEstimator\n    } = this.abrController;\n    if (!bwEstimator) {\n      return NaN;\n    }\n    return bwEstimator.getEstimateTTFB();\n  }\n\n  /**\n   * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)\n   */\n  set autoLevelCapping(newLevel) {\n    if (this._autoLevelCapping !== newLevel) {\n      this.logger.log(`set autoLevelCapping:${newLevel}`);\n      this._autoLevelCapping = newLevel;\n      this.levelController.checkMaxAutoUpdated();\n    }\n  }\n  get maxHdcpLevel() {\n    return this._maxHdcpLevel;\n  }\n  set maxHdcpLevel(value) {\n    if (isHdcpLevel(value) && this._maxHdcpLevel !== value) {\n      this._maxHdcpLevel = value;\n      this.levelController.checkMaxAutoUpdated();\n    }\n  }\n\n  /**\n   * True when automatic level selection enabled\n   */\n  get autoLevelEnabled() {\n    return this.levelController.manualLevel === -1;\n  }\n\n  /**\n   * Level set manually (if any)\n   */\n  get manualLevel() {\n    return this.levelController.manualLevel;\n  }\n\n  /**\n   * min level selectable in auto mode according to config.minAutoBitrate\n   */\n  get minAutoLevel() {\n    const {\n      levels,\n      config: {\n        minAutoBitrate\n      }\n    } = this;\n    if (!levels) return 0;\n    const len = levels.length;\n    for (let i = 0; i < len; i++) {\n      if (levels[i].maxBitrate >= minAutoBitrate) {\n        return i;\n      }\n    }\n    return 0;\n  }\n\n  /**\n   * max level selectable in auto mode according to autoLevelCapping\n   */\n  get maxAutoLevel() {\n    const {\n      levels,\n      autoLevelCapping,\n      maxHdcpLevel\n    } = this;\n    let maxAutoLevel;\n    if (autoLevelCapping === -1 && levels != null && levels.length) {\n      maxAutoLevel = levels.length - 1;\n    } else {\n      maxAutoLevel = autoLevelCapping;\n    }\n    if (maxHdcpLevel) {\n      for (let i = maxAutoLevel; i--;) {\n        const hdcpLevel = levels[i].attrs['HDCP-LEVEL'];\n        if (hdcpLevel && hdcpLevel <= maxHdcpLevel) {\n          return i;\n        }\n      }\n    }\n    return maxAutoLevel;\n  }\n  get firstAutoLevel() {\n    return this.abrController.firstAutoLevel;\n  }\n\n  /**\n   * next automatically selected quality level\n   */\n  get nextAutoLevel() {\n    return this.abrController.nextAutoLevel;\n  }\n\n  /**\n   * this setter is used to force next auto level.\n   * this is useful to force a switch down in auto mode:\n   * in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)\n   * forced value is valid for one fragment. upon successful frag loading at forced level,\n   * this value will be resetted to -1 by ABR controller.\n   */\n  set nextAutoLevel(nextLevel) {\n    this.abrController.nextAutoLevel = nextLevel;\n  }\n\n  /**\n   * get the datetime value relative to media.currentTime for the active level Program Date Time if present\n   */\n  get playingDate() {\n    return this.streamController.currentProgramDateTime;\n  }\n  get mainForwardBufferInfo() {\n    return this.streamController.getMainFwdBufferInfo();\n  }\n  get maxBufferLength() {\n    return this.streamController.maxBufferLength;\n  }\n\n  /**\n   * Find and select the best matching audio track, making a level switch when a Group change is necessary.\n   * Updates `hls.config.audioPreference`. Returns the selected track, or null when no matching track is found.\n   */\n  setAudioOption(audioOption) {\n    var _this$audioTrackContr;\n    return ((_this$audioTrackContr = this.audioTrackController) == null ? void 0 : _this$audioTrackContr.setAudioOption(audioOption)) || null;\n  }\n  /**\n   * Find and select the best matching subtitle track, making a level switch when a Group change is necessary.\n   * Updates `hls.config.subtitlePreference`. Returns the selected track, or null when no matching track is found.\n   */\n  setSubtitleOption(subtitleOption) {\n    var _this$subtitleTrackCo;\n    return ((_this$subtitleTrackCo = this.subtitleTrackController) == null ? void 0 : _this$subtitleTrackCo.setSubtitleOption(subtitleOption)) || null;\n  }\n\n  /**\n   * Get the complete list of audio tracks across all media groups\n   */\n  get allAudioTracks() {\n    const audioTrackController = this.audioTrackController;\n    return audioTrackController ? audioTrackController.allAudioTracks : [];\n  }\n\n  /**\n   * Get the list of selectable audio tracks\n   */\n  get audioTracks() {\n    const audioTrackController = this.audioTrackController;\n    return audioTrackController ? audioTrackController.audioTracks : [];\n  }\n\n  /**\n   * index of the selected audio track (index in audio track lists)\n   */\n  get audioTrack() {\n    const audioTrackController = this.audioTrackController;\n    return audioTrackController ? audioTrackController.audioTrack : -1;\n  }\n\n  /**\n   * selects an audio track, based on its index in audio track lists\n   */\n  set audioTrack(audioTrackId) {\n    const audioTrackController = this.audioTrackController;\n    if (audioTrackController) {\n      audioTrackController.audioTrack = audioTrackId;\n    }\n  }\n\n  /**\n   * get the complete list of subtitle tracks across all media groups\n   */\n  get allSubtitleTracks() {\n    const subtitleTrackController = this.subtitleTrackController;\n    return subtitleTrackController ? subtitleTrackController.allSubtitleTracks : [];\n  }\n\n  /**\n   * get alternate subtitle tracks list from playlist\n   */\n  get subtitleTracks() {\n    const subtitleTrackController = this.subtitleTrackController;\n    return subtitleTrackController ? subtitleTrackController.subtitleTracks : [];\n  }\n\n  /**\n   * index of the selected subtitle track (index in subtitle track lists)\n   */\n  get subtitleTrack() {\n    const subtitleTrackController = this.subtitleTrackController;\n    return subtitleTrackController ? subtitleTrackController.subtitleTrack : -1;\n  }\n  get media() {\n    return this._media;\n  }\n\n  /**\n   * select an subtitle track, based on its index in subtitle track lists\n   */\n  set subtitleTrack(subtitleTrackId) {\n    const subtitleTrackController = this.subtitleTrackController;\n    if (subtitleTrackController) {\n      subtitleTrackController.subtitleTrack = subtitleTrackId;\n    }\n  }\n\n  /**\n   * Whether subtitle display is enabled or not\n   */\n  get subtitleDisplay() {\n    const subtitleTrackController = this.subtitleTrackController;\n    return subtitleTrackController ? subtitleTrackController.subtitleDisplay : false;\n  }\n\n  /**\n   * Enable/disable subtitle display rendering\n   */\n  set subtitleDisplay(value) {\n    const subtitleTrackController = this.subtitleTrackController;\n    if (subtitleTrackController) {\n      subtitleTrackController.subtitleDisplay = value;\n    }\n  }\n\n  /**\n   * get mode for Low-Latency HLS loading\n   */\n  get lowLatencyMode() {\n    return this.config.lowLatencyMode;\n  }\n\n  /**\n   * Enable/disable Low-Latency HLS part playlist and segment loading, and start live streams at playlist PART-HOLD-BACK rather than HOLD-BACK.\n   */\n  set lowLatencyMode(mode) {\n    this.config.lowLatencyMode = mode;\n  }\n\n  /**\n   * Position (in seconds) of live sync point (ie edge of live position minus safety delay defined by ```hls.config.liveSyncDuration```)\n   * @returns null prior to loading live Playlist\n   */\n  get liveSyncPosition() {\n    return this.latencyController.liveSyncPosition;\n  }\n\n  /**\n   * Estimated position (in seconds) of live edge (ie edge of live playlist plus time sync playlist advanced)\n   * @returns 0 before first playlist is loaded\n   */\n  get latency() {\n    return this.latencyController.latency;\n  }\n\n  /**\n   * maximum distance from the edge before the player seeks forward to ```hls.liveSyncPosition```\n   * configured using ```liveMaxLatencyDurationCount``` (multiple of target duration) or ```liveMaxLatencyDuration```\n   * @returns 0 before first playlist is loaded\n   */\n  get maxLatency() {\n    return this.latencyController.maxLatency;\n  }\n\n  /**\n   * target distance from the edge as calculated by the latency controller\n   */\n  get targetLatency() {\n    return this.latencyController.targetLatency;\n  }\n  set targetLatency(latency) {\n    this.latencyController.targetLatency = latency;\n  }\n\n  /**\n   * the rate at which the edge of the current live playlist is advancing or 1 if there is none\n   */\n  get drift() {\n    return this.latencyController.drift;\n  }\n\n  /**\n   * set to true when startLoad is called before MANIFEST_PARSED event\n   */\n  get forceStartLoad() {\n    return this.streamController.forceStartLoad;\n  }\n\n  /**\n   * ContentSteering pathways getter\n   */\n  get pathways() {\n    return this.levelController.pathways;\n  }\n\n  /**\n   * ContentSteering pathwayPriority getter/setter\n   */\n  get pathwayPriority() {\n    return this.levelController.pathwayPriority;\n  }\n  set pathwayPriority(pathwayPriority) {\n    this.levelController.pathwayPriority = pathwayPriority;\n  }\n\n  /**\n   * returns true when all SourceBuffers are buffered to the end\n   */\n  get bufferedToEnd() {\n    var _this$bufferControlle;\n    return !!((_this$bufferControlle = this.bufferController) != null && _this$bufferControlle.bufferedToEnd);\n  }\n\n  /**\n   * returns Interstitials Program Manager\n   */\n  get interstitialsManager() {\n    var _this$interstitialsCo;\n    return ((_this$interstitialsCo = this.interstitialsController) == null ? void 0 : _this$interstitialsCo.interstitialsManager) || null;\n  }\n\n  /**\n   * returns mediaCapabilities.decodingInfo for a variant/rendition\n   */\n  getMediaDecodingInfo(level, audioTracks = this.allAudioTracks) {\n    const audioTracksByGroup = getAudioTracksByGroup(audioTracks);\n    return getMediaDecodingInfoPromise(level, audioTracksByGroup, navigator.mediaCapabilities);\n  }\n}\nHls.defaultConfig = void 0;\n\n\n//# sourceMappingURL=hls.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGxzLmpzL2Rpc3QvaGxzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCwrQkFBK0I7QUFDbkY7QUFDQSxzREFBc0QsK0JBQStCO0FBQ3JGO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0EsaURBQWlELCtCQUErQjtBQUNoRjtBQUNBLG1EQUFtRCwrQkFBK0I7QUFDbEY7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQSx3REFBd0QsK0JBQStCO0FBQ3ZGO0FBQ0EsMERBQTBELCtCQUErQjtBQUN6RjtBQUNBLDBEQUEwRCwrQkFBK0I7QUFDekY7QUFDQSw0REFBNEQsK0JBQStCO0FBQzNGO0FBQ0Esa0RBQWtELHFDQUFxQztBQUN2RjtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBLCtEQUErRDtBQUMvRDtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBLHFEQUFxRCxxQ0FBcUM7QUFDMUY7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQSw4RkFBOEY7QUFDOUY7QUFDQSxrSkFBa0o7QUFDbEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsNkJBQTZCO0FBQ2hHO0FBQ0EscUVBQXFFLDZCQUE2QjtBQUNsRztBQUNBLHNFQUFzRSxzREFBc0Q7QUFDNUg7QUFDQSxzRUFBc0Usc0RBQXNEO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RixXQUFXO0FBQ25HO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0Esa0hBQWtIO0FBQ2xIO0FBQ0EsOEZBQThGO0FBQzlGO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0EsMEhBQTBIO0FBQzFIO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBLDREQUE0RDtBQUM1RDtBQUNBLDRIQUE0SDtBQUM1SDtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBLG9GQUFvRjtBQUNwRjtBQUNBLHlFQUF5RSxZQUFZLGdEQUFnRDtBQUNySTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBLDREQUE0RCwwQkFBMEI7QUFDdEY7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQSw2REFBNkQsOEVBQThFO0FBQzNJO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0EsOEZBQThGO0FBQzlGO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBLGlCQUFpQiwwQ0FBMEM7QUFDM0Q7QUFDQSx1R0FBdUc7QUFDdkc7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUc7O0FBRUo7QUFDQSwrREFBK0QsOEJBQThCO0FBQzdGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE1BQU07QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQywwQkFBMEIsR0FBRyxLQUFLO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUSxzQkFBc0IsUUFBUTtBQUNyRixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxFQUFFO0FBQ3ZFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7O0FBRWxCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdGQUF3RixpQkFBaUI7QUFDekc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLEdBQUc7QUFDSCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0VBQWtFLG9DQUFvQztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEVBQTBFLG1DQUFtQztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsSUFBSTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFELDhGQUE4RjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxvQkFBb0Isb0JBQW9CLHdCQUF3QixLQUFLLG1CQUFtQjtBQUNoSjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0JBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsNkNBQTZDLGFBQWEscUJBQXFCLFVBQVU7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdCQUFnQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSyxLQUFLLFNBQVMsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0EsR0FBRztBQUNILGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLElBQUk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtDQUFrQyxFQUFFLHNEQUFzRDtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUJBQWlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsSUFBSTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFKQUFxSixHQUFHO0FBQ3hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxjQUFjLE1BQU0sSUFBSSxhQUFhLEdBQUcsWUFBWSxHQUFHLDJCQUEyQixFQUFFLCtCQUErQixHQUFHLCtCQUErQjtBQUNySjtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQixFQUFFLE1BQU0sSUFBSSxlQUFlO0FBQzFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtDQUFrQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDBDQUEwQztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxTQUFTLGlGQUFpRjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGlDQUFpQyxJQUFJO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSwwQkFBMEIsd0JBQXdCLFVBQVU7QUFDL0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUscUJBQXFCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLG9CQUFvQix5Q0FBeUMsb0NBQW9DO0FBQzFLO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UseUJBQXlCLGVBQWUsVUFBVTtBQUN4SDtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsNEJBQTRCLGVBQWUsYUFBYTtBQUM3SDtBQUNBO0FBQ0E7QUFDQSxvRkFBb0Ysd0JBQXdCO0FBQzVHO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxxQkFBcUI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLHdCQUF3QixvQkFBb0IsY0FBYztBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRLG9CQUFvQixPQUFPO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsOEJBQThCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRLEVBQUUsbUNBQW1DLFdBQVcscUJBQXFCO0FBQ3pHLDJCQUEyQjtBQUMzQiw2QkFBNkIsa0NBQWtDO0FBQy9ELGtEQUFrRCw0QkFBNEI7QUFDOUUsc0RBQXNELHFDQUFxQztBQUMzRix1QkFBdUIsVUFBVTtBQUNqQyw2QkFBNkIseURBQXlEO0FBQ3RGLHlCQUF5QiwwQkFBMEI7QUFDbkQsMkJBQTJCLGVBQWUsSUFBSSwwQkFBMEI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsMkJBQTJCLDBCQUEwQjtBQUNyRCw2QkFBNkIsa0NBQWtDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHVCQUF1QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixZQUFZLGFBQWEsUUFBUTtBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxQkFBcUIsR0FBRyxxQ0FBcUM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsb0NBQW9DLDhDQUE4Qyx1Q0FBdUM7QUFDaEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUVBQW1FLDBCQUEwQixVQUFVO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHFCQUFxQjtBQUN6RCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1CQUFtQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsbUJBQW1CLGNBQWMsT0FBTyxFQUFFLHdCQUF3QjtBQUNwSSxjQUFjO0FBQ2QsdUZBQXVGLE9BQU8sRUFBRSx3QkFBd0I7QUFDeEg7QUFDQSx1REFBdUQsTUFBTTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLG1FQUFtRSxPQUFPLGdDQUFnQyx3QkFBd0I7QUFDbEk7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHlCQUF5QixLQUFLLGNBQWMsbUNBQW1DLGdDQUFnQyxJQUFJLHNDQUFzQyx1QkFBdUIsZ0JBQWdCLElBQUksa0JBQWtCO0FBQ2pRO0FBQ0Esd0NBQXdDLG1CQUFtQixJQUFJLEdBQUcsYUFBYSx1QkFBdUIsWUFBWSxrQ0FBa0MsT0FBTyw0QkFBNEIsY0FBYyx3QkFBd0IsbUJBQW1CLDZCQUE2QixnQkFBZ0IsMEJBQTBCLGlCQUFpQixnQkFBZ0IsV0FBVyxvQkFBb0IsYUFBYSxzQkFBc0IsZ0JBQWdCLFVBQVU7QUFDcGI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsTUFBTSxHQUFHLGFBQWEsR0FBRyxnQkFBZ0IsR0FBRyxxQ0FBcUMsR0FBRyxVQUFVO0FBQzNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZ0NBQWdDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isa0NBQWtDLElBQUk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsZ0RBQWdELHNCQUFzQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxZQUFZLFFBQVEsYUFBYTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxJQUFJO0FBQ3hDLDJCQUEyQixzQkFBc0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLElBQUk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSw4QkFBOEIsSUFBSTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixJQUFJO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYyxHQUFHLGVBQWUsR0FBRyxZQUFZO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGFBQWE7QUFDckU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixhQUFhO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxRQUFRO0FBQy9EO0FBQ0E7O0FBRUEsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDBFQUEwRSxTQUFTLElBQUksWUFBWTtBQUNuRztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsSUFBSTtBQUNuQztBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsMEJBQTBCO0FBQy9FO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiwyQ0FBMkMsZUFBZSxFQUFFLGNBQWM7QUFDMUU7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHFCQUFxQjtBQUNuRTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsMkNBQTJDLGVBQWUsRUFBRSxjQUFjO0FBQzFFO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxxQkFBcUI7QUFDbkU7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQ0FBZ0M7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLElBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxvQkFBb0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrSUFBK0ksYUFBYTtBQUM1SjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsNEJBQTRCLEtBQUssZ0RBQWdELFVBQVU7QUFDM0Y7QUFDQSxNQUFNO0FBQ04sMEdBQTBHLGNBQWM7QUFDeEg7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtSUFBbUksS0FBSztBQUN4SSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixrSkFBa0osT0FBTztBQUN6SjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0QkFBNEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE1BQU0sY0FBYyxNQUFNO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELElBQUksc0NBQXNDLGlCQUFpQjtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsNkVBQTZFLFFBQVEsS0FBSyxVQUFVO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EseUVBQXlFLDJCQUEyQjtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLElBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsT0FBTztBQUM1RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrQkFBa0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsVUFBVTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixTQUFTLE1BQU07QUFDOUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLCtCQUErQixTQUFTLE1BQU07QUFDOUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsWUFBWTs7QUFFdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOERBQThEOztBQUU5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQiwrRUFBK0UsV0FBVztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsS0FBSztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsZ0VBQWdFLE9BQU87QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQix1RUFBdUUsT0FBTztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsWUFBWSxHQUFHLE1BQU07QUFDMUQsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsT0FBTztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxJQUFJO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0JBQWdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBLGdDQUFnQyxZQUFZO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsSUFBSTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxLQUFLLGtDQUFrQyxVQUFVO0FBQ3BHO0FBQ0E7QUFDQSxtREFBbUQsS0FBSyw4Q0FBOEMsVUFBVTtBQUNoSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHlCQUF5QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsSUFBSTtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw2QkFBNkI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiw4RUFBOEUsb0NBQW9DO0FBQ2xIO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxVQUFVO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixVQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRixXQUFXO0FBQ2pHO0FBQ0EsUUFBUTtBQUNSLCtGQUErRixXQUFXLElBQUksV0FBVztBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUyxFQUFFO0FBQ2pDLHFCQUFxQjtBQUNyQixFQUFFOztBQUVGLHFCQUFxQjtBQUNyQixFQUFFLGdCQUFnQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNCQUFzQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsSUFBSTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLFNBQVM7QUFDN0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCLGlCQUFpQixzQkFBc0IsR0FBRyxvQkFBb0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsbUVBQW1FLFdBQVcsTUFBTSxJQUFJLGtDQUFrQztBQUM3SjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGVBQWU7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELHdCQUF3QixlQUFlLHFCQUFxQjtBQUN4SDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLHVEQUF1RCxLQUFLLGFBQWE7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixXQUFXLE1BQU0sUUFBUSxFQUFFLDhDQUE4QyxLQUFLLHNDQUFzQztBQUN6STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsV0FBVyxNQUFNLFNBQVMsS0FBSyxzQkFBc0IsRUFBRSxXQUFXO0FBQzdGO0FBQ0E7O0FBRUEseUNBQXlDO0FBQ3pDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxREFBcUQ7QUFDcEY7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixXQUFXLE1BQU0sUUFBUSxFQUFFLG9DQUFvQyxLQUFLLGtDQUFrQyxXQUFXLDRFQUE0RTtBQUN0TjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQscUJBQXFCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCx5QkFBeUI7QUFDbEY7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVMsTUFBTSxnQkFBZ0IsR0FBRyxjQUFjLEtBQUssc0JBQXNCLEVBQUUsV0FBVztBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsZ0NBQWdDLGFBQWEsZ0RBQWdELElBQUksUUFBUTtBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFdBQVcsTUFBTSxTQUFTLFFBQVEsWUFBWSxHQUFHLFVBQVUsR0FBRyxvQkFBb0IsT0FBTyxpQ0FBaUMsUUFBUSxTQUFTLEdBQUcsZ0JBQWdCLEdBQUcsY0FBYyxhQUFhLHdDQUF3QztBQUNsUTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsNEJBQTRCO0FBQ3hGO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixXQUFXLE1BQU0sU0FBUyxLQUFLLDJCQUEyQixRQUFRLFNBQVMsRUFBRSxpRUFBaUUsWUFBWSx3Q0FBd0M7QUFDMU47QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZ0NBQWdDLGdDQUFnQyxvQkFBb0I7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esb0VBQW9FLElBQUksS0FBSyxzQkFBc0IsRUFBRSxXQUFXO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsY0FBYztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxRQUFRLFVBQVUsd0JBQXdCO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGVBQWUsK0NBQStDLFdBQVcsb0JBQW9CLGtCQUFrQixjQUFjLDhDQUE4QztBQUN4TjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsYUFBYSw2QkFBNkIsR0FBRztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsSUFBSTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsNkJBQTZCO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLFFBQVE7QUFDM0Y7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixRQUFRO0FBQzNGO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxnQ0FBZ0MsWUFBWSxpREFBaUQsSUFBSSxpQkFBaUIsYUFBYSxPQUFPO0FBQy9LO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxlQUFlLHdCQUF3QixpQkFBaUIsV0FBVyx5REFBeUQ7QUFDeks7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGNBQWM7QUFDcEY7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsUUFBUSxFQUFFLG1DQUFtQyxLQUFLLHNCQUFzQixFQUFFLFlBQVk7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsVUFBVSxJQUFJLGdGQUFnRjtBQUNsSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsNEJBQTRCLFNBQVMsS0FBSyxZQUFZLEVBQUUsWUFBWSxlQUFlLGFBQWEscUJBQXFCLGVBQWUsR0FBRyx5QkFBeUIsS0FBSyxNQUFNO0FBQzNLO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IscUJBQXFCLGNBQWMsaUNBQWlDLFdBQVc7QUFDL0U7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRixjQUFjO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxjQUFjLEtBQUssc0JBQXNCLEVBQUUsZ0JBQWdCO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxTQUFTLEVBQUUsTUFBTSxxQkFBcUIsZUFBZTtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxTQUFTLEtBQUssc0JBQXNCLEVBQUUsWUFBWTtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTLEtBQUssc0JBQXNCLEdBQUcsVUFBVTtBQUM1RixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixXQUFXLE1BQU0sUUFBUSxFQUFFLG9DQUFvQyxLQUFLLGlDQUFpQztBQUM1SDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzQkFBc0IsRUFBRSxZQUFZLEdBQUcsdUJBQXVCLElBQUksK0ZBQStGLEdBQUcsNkZBQTZGLEdBQUcsdUZBQXVGO0FBQ3pXO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWMsSUFBSSxVQUFVO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7O0FBRXJCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixhQUFhLEdBQUc7QUFDaEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCLGFBQWEsaUJBQWlCO0FBQzlCLGFBQWEsVUFBVTtBQUN2QixhQUFhLEdBQUc7QUFDaEIsYUFBYSxTQUFTO0FBQ3RCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0IsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDREQUE0RCxPQUFPO0FBQ25FO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQSxrQkFBa0IsWUFBWTtBQUM5Qjs7QUFFQTtBQUNBLDhEQUE4RDtBQUM5RCxrRUFBa0U7QUFDbEUsc0VBQXNFO0FBQ3RFLDBFQUEwRTtBQUMxRTtBQUNBLDZEQUE2RCxTQUFTO0FBQ3RFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QixhQUFhLFVBQVU7QUFDdkIsYUFBYSxHQUFHO0FBQ2hCLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCLGFBQWEsVUFBVTtBQUN2QixhQUFhLEdBQUc7QUFDaEIsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUIsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsR0FBRztBQUNoQixhQUFhLFNBQVM7QUFDdEIsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw4REFBOEQsWUFBWTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxZQUFZLGlCQUFpQixtQkFBbUIsS0FBSyxnQkFBZ0IsR0FBRyxpQ0FBaUMsUUFBUTtBQUMvSjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGtCQUFrQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsY0FBYyxpQkFBaUIsTUFBTSxhQUFhLGFBQWEsU0FBUyxZQUFZLG9CQUFvQixnQkFBZ0IsaUJBQWlCLGtCQUFrQjtBQUMxTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELG9CQUFvQixHQUFHLFlBQVksR0FBRyxnQkFBZ0I7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLCtCQUErQixXQUFXLFFBQVEsT0FBTyx1QkFBdUIsWUFBWSxHQUFHLG9CQUFvQixHQUFHLGlCQUFpQixXQUFXLFFBQVE7QUFDMUo7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsYUFBYSxZQUFZLEdBQUc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGFBQWEsWUFBWSxHQUFHO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLEtBQUs7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUJBQWlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLG1DQUFtQztBQUNuQyxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxpQkFBaUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0NBQW9DO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHFDQUFxQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLCtCQUErQix1Q0FBdUM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLE1BQU07QUFDTixnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLE9BQU87QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsTUFBTTtBQUNOLG1CQUFtQjtBQUNuQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCO0FBQ0Esa0JBQWtCLG9DQUFvQztBQUN0RDtBQUNBLFFBQVE7QUFDUjtBQUNBLGVBQWU7QUFDZixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU4saUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsNEJBQTRCO0FBQy9HLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCO0FBQ0Esa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsWUFBWTtBQUN6QyxpQ0FBaUMsbUNBQW1DO0FBQ3BFO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGFBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQ0FBaUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0NBQWdDO0FBQ3RELHdCQUF3QiwyQ0FBMkM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNEJBQTRCO0FBQ3RELDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixhQUFhO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGFBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUIsc0hBQXNIO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFCQUFxQixFQUFFLG9CQUFvQixHQUFHLG1DQUFtQyxHQUFHLGlCQUFpQixFQUFFLGtCQUFrQjtBQUNwSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLDJCQUEyQjtBQUMzQixNQUFNO0FBQ04sMkJBQTJCO0FBQzNCLE1BQU07QUFDTiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsV0FBVztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsYUFBYTtBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsT0FBTyxxQkFBcUIsV0FBVyxnQ0FBZ0MsWUFBWTtBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGdCQUFnQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxjQUFjO0FBQzdEO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGtCQUFrQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsT0FBTztBQUN6RSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGNBQWM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixzQ0FBc0M7QUFDL0Q7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsYUFBYTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5Qiw2REFBNkQ7QUFDN0QseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFNBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFlBQVksaUJBQWlCLGFBQWEsR0FBRyxZQUFZO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsb0JBQW9CLFNBQVMsUUFBUTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLGtEQUFrRCxRQUFRO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseUNBQXlDLElBQUksa0NBQWtDLE1BQU0sTUFBTSwwQ0FBMEMsc0JBQXNCO0FBQ2xMLFVBQVU7QUFDVix1QkFBdUIseUNBQXlDLElBQUksbUNBQW1DLE1BQU0sTUFBTSxpREFBaUQsc0JBQXNCO0FBQzFMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxvQ0FBb0MsR0FBRyxvQ0FBb0MsV0FBVyxrQ0FBa0M7QUFDL0s7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxTQUFTO0FBQ3ZELE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGFBQWE7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsNENBQTRDLHNCQUFzQix3QkFBd0IsaUJBQWlCLHdCQUF3QjtBQUNuSSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFNBQVM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBLHdEQUF3RCx5QkFBeUI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsa0NBQWtDLHVCQUF1QiwyQ0FBMkM7QUFDM0k7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFNBQVMsaUJBQWlCLG1EQUFtRCxXQUFXLDJDQUEyQztBQUNwSywwQkFBMEIsYUFBYTtBQUN2QztBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsZ0JBQWdCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFNBQVM7QUFDN0QsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtSEFBbUg7QUFDbkg7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxZQUFZLE9BQU8sc0NBQXNDLEtBQUssb0JBQW9CO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxjQUFjLEdBQUcsa0JBQWtCLFdBQVcsZUFBZSxTQUFTLCtCQUErQjtBQUNqSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsWUFBWTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxZQUFZO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsY0FBYztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGdEQUFnRCxTQUFTLE1BQU0sYUFBYSxFQUFFLHVEQUF1RCxLQUFLLHdEQUF3RCxFQUFFLGdCQUFnQjtBQUNwTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0IsR0FBRyxlQUFlLEdBQUcsYUFBYTtBQUNuRjtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxtQkFBbUIsT0FBTyxHQUFHO0FBQzFFO0FBQ0EsWUFBWTtBQUNaLG9EQUFvRCxHQUFHO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWLDJDQUEyQyxHQUFHO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsV0FBVyxNQUFNLGFBQWEsRUFBRSx1REFBdUQsRUFBRSx1REFBdUQsSUFBSSxpQkFBaUIsTUFBTTtBQUNsUSx5QkFBeUI7QUFDekIsdUJBQXVCO0FBQ3ZCLHNCQUFzQjtBQUN0Qiw4QkFBOEI7QUFDOUIsc0JBQXNCO0FBQ3RCLDZCQUE2QixrQkFBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxJQUFJLG1CQUFtQixRQUFRLEdBQUcsVUFBVTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsZ0JBQWdCLEtBQUssWUFBWTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsMkJBQTJCO0FBQzFGO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDBEQUEwRCxTQUFTLEdBQUcsV0FBVyxRQUFRLFFBQVE7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTLEdBQUcsV0FBVyxRQUFRLFFBQVEsWUFBWSxtQkFBbUIsR0FBRyxpQkFBaUIsR0FBRyxpQ0FBaUMsc0JBQXNCLEdBQUcseUJBQXlCLFFBQVEsWUFBWSx5QkFBeUI7QUFDelA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSx5RkFBeUYsU0FBUyxXQUFXLFlBQVk7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsSUFBSSxNQUFNLGlCQUFpQixHQUFHLGNBQWMsVUFBVSxRQUFRO0FBQy9GO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDJDQUEyQyxRQUFRLHFEQUFxRCxTQUFTLE1BQU0saUJBQWlCLEdBQUcsY0FBYyxVQUFVLFFBQVE7QUFDM0s7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFLDRCQUE0QixRQUFRLEVBQUUsaUNBQWlDLFdBQVcsWUFBWSw4Q0FBOEMsV0FBVyxpQkFBaUIseURBQXlEO0FBQ2pPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxnQkFBZ0IsMEJBQTBCLG1CQUFtQixHQUFHLFlBQVk7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGdFQUFnRSxTQUFTLCtDQUErQyxTQUFTLFdBQVcsYUFBYTtBQUN6SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw2QkFBNkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YseUVBQXlFLE1BQU07QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLCtFQUErRSxNQUFNO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLGdDQUFnQyxPQUFPLEVBQUUsNEhBQTRIO0FBQ3JLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyx3QkFBd0I7QUFDdkU7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsMERBQTBELDRCQUE0QixNQUFNLGFBQWEscUJBQXFCLFlBQVk7QUFDMUk7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGtCQUFrQixrQkFBa0Isd0JBQXdCLFVBQVUsYUFBYSxVQUFVLFVBQVUsVUFBVSxLQUFLO0FBQy9KO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsbURBQW1ELEtBQUssc0NBQXNDO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxlQUFlLEdBQUcseUJBQXlCLFNBQVMsYUFBYTtBQUNoSDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxlQUFlLEdBQUcseUJBQXlCLFNBQVMsYUFBYSxPQUFPLE1BQU07QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSx1Q0FBdUMsSUFBSSxZQUFZLFNBQVMsNEJBQTRCLGlFQUFpRTtBQUM3SjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixJQUFJLEdBQUcsd0JBQXdCLFNBQVMseUJBQXlCLFFBQVEsU0FBUyxVQUFVLGdCQUFnQixHQUFHLGNBQWM7QUFDeko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLG9CQUFvQiw4QkFBOEIscURBQXFEO0FBQ2hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsMEZBQTBGLDhFQUE4RSxlQUFlLG1CQUFtQjtBQUMxTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkMsTUFBTTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsT0FBTyxHQUFHLFdBQVcsU0FBUyxZQUFZLFFBQVEsZUFBZSxXQUFXLGVBQWU7QUFDcEk7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsSUFBSSxHQUFHLGdCQUFnQixTQUFTLGlCQUFpQixRQUFRLFFBQVEsRUFBRSxvSkFBb0osRUFBRSx1RkFBdUYsQ0FBRSxhQUFhLEVBQUUsSUFBSTtBQUN6VztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixFQUFFO0FBQ0YsRUFBRSx5QkFBeUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsMklBQTJJLEtBQUssS0FBSyxzQkFBc0IsSUFBSSxtQkFBbUI7QUFDbE07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwrQkFBK0IsRUFBRSw0QkFBNEIsRUFBRSw4QkFBOEI7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLDZFQUE2RSxZQUFZLElBQUksU0FBUztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQscUNBQXFDLEVBQUUsNkNBQTZDLEVBQUUsb0JBQW9CO0FBQzNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtSUFBbUksZ0JBQWdCLDJFQUEyRTtBQUM5TztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCw0QkFBNEI7QUFDekYsbUJBQW1CO0FBQ25CLG1CQUFtQix5RkFBeUY7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RixhQUFhLEtBQUssVUFBVTtBQUN6SDtBQUNBO0FBQ0Esd0ZBQXdGLCtCQUErQixNQUFNLDRCQUE0QixpQkFBaUIsV0FBVyxlQUFlLFlBQVk7QUFDaE4sd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSwrQkFBK0IsaURBQWlEO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLElBQUk7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsbUNBQW1DLEtBQUs7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFdBQVcsc0JBQXNCLHVCQUF1QjtBQUN4RjtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsb0JBQW9CLFNBQVMsV0FBVztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxTQUFTLEtBQUssV0FBVztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQSx3QkFBd0IsV0FBVyxTQUFTLE1BQU07QUFDbEQ7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE1BQU0sdUJBQXVCLFNBQVM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHVCQUF1QjtBQUN2QiwwQkFBMEI7QUFDMUI7QUFDQSxzQ0FBc0MsTUFBTTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsdUJBQXVCO0FBQ3ZCLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixLQUFLO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsZ0RBQWdELE1BQU07QUFDdEQsT0FBTztBQUNQO0FBQ0EsZ0RBQWdELE1BQU07QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpQkFBaUIsR0FBRyxxQ0FBcUMsOEJBQThCLEtBQUssa0JBQWtCLDJDQUEyQztBQUN2TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixLQUFLLFdBQVcsTUFBTSxHQUFHLElBQUk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxpRUFBaUUsa0JBQWtCLEtBQUssZ0JBQWdCLE1BQU0sTUFBTTtBQUNwSCxPQUFPO0FBQ1A7QUFDQSxrRUFBa0Usa0JBQWtCLEtBQUssZ0JBQWdCLE1BQU0sTUFBTTtBQUNySDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLHNDQUFzQyxNQUFNLEdBQUcsS0FBSyxRQUFRLEtBQUs7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esb0ZBQW9GLFdBQVcsU0FBUyxZQUFZLE1BQU0sUUFBUTtBQUNsSTtBQUNBO0FBQ0EsOENBQThDLE1BQU07QUFDcEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE1BQU07QUFDOUI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSw0RkFBNEYsdUJBQXVCO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaLHFDQUFxQyxNQUFNO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsb0JBQW9CO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHFCQUFxQiw4QkFBOEIsTUFBTSxHQUFHLElBQUk7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDZDQUE2QyxtQkFBbUIseUJBQXlCLHVCQUF1QixJQUFJLGtCQUFrQjtBQUN0STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asd0RBQXdELG9CQUFvQjtBQUM1RTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlCQUFpQixTQUFTLE1BQU07QUFDNUQ7QUFDQSwwQ0FBMEMsU0FBUyxHQUFHLHVDQUF1QyxFQUFFLGlCQUFpQjtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxnRUFBZ0UsY0FBYztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTSw4Q0FBOEMseUZBQXlGO0FBQzVLLGtCQUFrQixNQUFNO0FBQ3hCO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsTUFBTSxrQ0FBa0MsaUJBQWlCLE9BQU8sSUFBSSxNQUFNLEdBQUc7QUFDeEc7QUFDQTtBQUNBOztBQUVBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsTUFBTTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsWUFBWSxHQUFHLFVBQVUsYUFBYSxNQUFNO0FBQ3hFO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxNQUFNO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsTUFBTTtBQUN6RDtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUixtREFBbUQscUJBQXFCLEVBQUUsTUFBTTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOLHFEQUFxRCxTQUFTO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxhQUFhLFNBQVM7QUFDL0Y7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsU0FBUyxJQUFJLHdCQUF3QixJQUFJLDBCQUEwQixZQUFZLGdCQUFnQixHQUFHLGlCQUFpQjtBQUMzSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUSxHQUFHLFlBQVksT0FBTyxLQUFLO0FBQ25FO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEseUNBQXlDO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxZQUFZO0FBQ2xFOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtEQUFrRDtBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRSxrQkFBa0IsR0FBRztBQUN0QztBQUNBLGFBQWEsRUFBRSxrQkFBa0IsR0FBRyx5QkFBeUI7QUFDN0QsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywrQkFBK0IsRUFBRSw4QkFBOEI7QUFDN0UsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx5Q0FBeUMsR0FBRyw4QkFBOEI7QUFDdkY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsV0FBVyxtQkFBbUI7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5SkFBeUo7QUFDeko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVcsR0FBRywyQkFBMkI7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLElBQUksRUFBRSxVQUFVLEVBQUUsTUFBTTtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLElBQUk7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUix3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsdUNBQXVDLGNBQWMsSUFBSSxtQkFBbUIsd0NBQXdDLGNBQWMsVUFBVSxpQ0FBaUMsY0FBYyw0QkFBNEIsYUFBYSxrQ0FBa0M7QUFDdFE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGVBQWUsZ0NBQWdDLFVBQVU7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCLEdBQUcsZUFBZSxxQkFBcUIsZUFBZTtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFVBQVU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsdUJBQXVCLEtBQUsseUJBQXlCO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxpQkFBaUIsU0FBUyxRQUFRO0FBQzVGLGlFQUFpRSxxQkFBcUIsU0FBUyxRQUFRO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDBCQUEwQixrQ0FBa0M7QUFDNUQsK0NBQStDLHlCQUF5QixTQUFTLFFBQVE7QUFDekY7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFDQUFxQztBQUMvRCw4Q0FBOEMsNEJBQTRCLFNBQVMsUUFBUTtBQUMzRjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSx5REFBeUQsSUFBSTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxJQUFJO0FBQ25EO0FBQ0E7QUFDQSx1Q0FBdUMsc0JBQXNCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0Esc0VBQXNFLFVBQVU7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EscURBQXFELFlBQVksRUFBRSxZQUFZLEdBQUcsWUFBWTtBQUM5RjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsYUFBYTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGFBQWE7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsdURBQXVELFlBQVk7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsOENBQThDLElBQUk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFdBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsVUFBVTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDhEQUE4RCxVQUFVO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsbUZBQW1GLGdDQUFnQztBQUNuSDtBQUNBLHNHQUFzRyxrQkFBa0I7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxVQUFVLG1DQUFtQyxpQ0FBaUM7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxVQUFVLEtBQUssTUFBTTtBQUNoRixPQUFPO0FBQ1A7QUFDQSwyQ0FBMkMsK0JBQStCO0FBQzFFO0FBQ0EsMkNBQTJDLFVBQVU7QUFDckQ7QUFDQSw4Q0FBOEMsVUFBVTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EseURBQXlELFVBQVUsRUFBRSxJQUFJLE1BQU07QUFDL0UsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDZDQUE2QyxVQUFVLFdBQVcscUNBQXFDO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxQkFBcUIsY0FBYztBQUN6RSxRQUFRLGdCQUFnQiw4QkFBOEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysb0VBQW9FLFVBQVU7QUFDOUU7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQSwwREFBMEQsU0FBUyxFQUFFLFVBQVUsSUFBSSxXQUFXLGdCQUFnQixzQkFBc0I7QUFDcEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU8sV0FBVyxzQkFBc0IsWUFBWSxvQkFBb0IsT0FBTyxnQkFBZ0I7QUFDakkseUNBQXlDLFdBQVc7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLCtDQUErQyxjQUFjLEVBQUUsZUFBZSxJQUFJLGlCQUFpQixZQUFZLFdBQVc7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLHNEQUFzRDtBQUM3RDtBQUNBLE9BQU8sRUFBRTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsVUFBVTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxVQUFVO0FBQ2hEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxPQUFPO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxPQUFPLEtBQUssT0FBTyxtQkFBbUIsY0FBYyxVQUFVLHNDQUFzQztBQUN4SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixtQkFBbUIsWUFBWSwrQkFBK0IscUJBQXFCLGtCQUFrQixtQkFBbUI7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsdURBQXVELFlBQVk7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQixrQkFBa0IsTUFBTTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDRCQUE0QixVQUFVO0FBQ2pELFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVixvREFBb0QsVUFBVTtBQUM5RDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFEQUFxRCxzR0FBc0csV0FBVyxNQUFNO0FBQzVLLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTywyQ0FBMkMsTUFBTTtBQUN4RCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTywyQkFBMkIsMkhBQTJILGlCQUFpQiw2RUFBNkUsT0FBTyx1Q0FBdUM7QUFDOVU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFVBQVU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVcsTUFBTSxVQUFVLGdDQUFnQyxJQUFJLGFBQWEsZUFBZSxHQUFHLGNBQWM7QUFDNUcsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNLFVBQVUsbUNBQW1DLElBQUk7QUFDbEUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsOENBQThDLEdBQUcsd0NBQXdDLFFBQVEsVUFBVTtBQUNwSjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxJQUFJO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHFEQUFxRDtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlDQUFpQyxJQUFJLGFBQWEsWUFBWSxHQUFHLGVBQWU7QUFDL0YsY0FBYztBQUNkO0FBQ0EscURBQXFELGNBQWM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsTUFBTTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxNQUFNO0FBQzlELE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxpRUFBaUUsTUFBTTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxNQUFNO0FBQ2pGLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AseURBQXlELHNCQUFzQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDZEQUE2RCwyQkFBMkI7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsOENBQThDLE1BQU07QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsTUFBTTtBQUM5RCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsNkNBQTZDLE1BQU07QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsTUFBTTtBQUM3RCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELElBQUk7QUFDckQ7QUFDQSxNQUFNO0FBQ04seUNBQXlDLElBQUk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsZ0ZBQWdGLEtBQUs7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMEJBQTBCO0FBQzVDO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDBDQUEwQyxJQUFJLFlBQVksU0FBUyw0QkFBNEIsaUVBQWlFO0FBQ2hLO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLElBQUksR0FBRyx3QkFBd0IsU0FBUyx5QkFBeUIsUUFBUSxTQUFTLFVBQVUsZ0JBQWdCLEdBQUcsY0FBYztBQUM1SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx1QkFBdUIscUJBQXFCLDJEQUEyRDtBQUNuSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxJQUFJLEdBQUcsa0JBQWtCLFNBQVMsbUJBQW1CLFFBQVEsUUFBUSxFQUFFLG9KQUFvSixFQUFFLHVGQUF1RixDQUFFLGFBQWEsRUFBRSxJQUFJO0FBQzFXO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxrQkFBa0Isa0JBQWtCLGtCQUFrQjtBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhDQUE4QyxNQUFNO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsTUFBTSxrQkFBa0IsV0FBVyxTQUFTLFlBQVksUUFBUSxjQUFjO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsR0FBRztBQUNKO0FBQ0EsWUFBWSx3QkFBd0IsR0FBRyxtQkFBbUIsR0FBRyxVQUFVO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsY0FBYyx3QkFBd0IsSUFBSSx1RUFBdUUsRUFBRSxzQ0FBc0MsR0FBRyxtQ0FBbUM7QUFDL0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQixJQUFJLGlCQUFpQixHQUFHLDhCQUE4QjtBQUNyRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0NBQW9DLEVBQUUsaUVBQWlFLEVBQUUsNENBQTRDO0FBQ25MO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZUFBZTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLElBQUk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxhQUFhO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QixlQUFlLFlBQVksMENBQTBDLGlCQUFpQjtBQUNqSTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCLGVBQWUsWUFBWTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdCQUF3QixlQUFlLFlBQVksT0FBTyxjQUFjLGVBQWUsWUFBWTtBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdCQUF3QixlQUFlLFlBQVksdUNBQXVDLGNBQWMsWUFBWSxrQkFBa0IsR0FBRyxvQkFBb0I7QUFDbEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3QkFBd0IsZUFBZSxZQUFZLG1CQUFtQixjQUFjLG1CQUFtQixvQkFBb0IsR0FBRyxtQkFBbUIsTUFBTSxrQkFBa0IsTUFBTSxpQkFBaUI7QUFDck47QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUVBQWlFLElBQUkseUJBQXlCLEdBQUcsdUJBQXVCO0FBQ3JJOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLDJKQUEySixZQUFZLEVBQUUsWUFBWSxHQUFHLFlBQVk7QUFDcE07QUFDQSxPQUFPO0FBQ1A7QUFDQSxtSkFBbUosWUFBWTtBQUMvSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDBCQUEwQixLQUFLO0FBQzFFLFlBQVksZ0RBQWdELE9BQU8saUJBQWlCO0FBQ3BGO0FBQ0E7QUFDQSxtQ0FBbUMsV0FBVztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsNkJBQTZCLEdBQUcsSUFBSSxlQUFlLElBQUksc0JBQXNCLElBQUksY0FBYztBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxxQ0FBcUMsNkJBQTZCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE1BQU0sR0FBRyxhQUFhO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsSUFBSTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRLEVBQUUsaUNBQWlDO0FBQ3ZGO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQyxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGlDQUFpQztBQUNyRixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLGFBQWE7QUFDN0Y7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOERBQThELEtBQUssb0NBQW9DLE9BQU8sY0FBYztBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsTUFBTSxJQUFJLGVBQWU7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsMEJBQTBCLEdBQUcsK0JBQStCLEVBQUUsaUNBQWlDO0FBQzVJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxjQUFjLEVBQUUsNkJBQTZCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxnQ0FBZ0MsRUFBRSxvREFBb0Q7QUFDL0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsYUFBYTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxhQUFhO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbUJBQW1CLEdBQUcsaUJBQWlCLG1CQUFtQixhQUFhO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLCtCQUErQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsK0JBQStCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCwrQ0FBK0M7QUFDNUc7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsd0JBQXdCO0FBQ2xGO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSw2REFBNkQsd0JBQXdCO0FBQ3JGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCx3QkFBd0I7QUFDbEY7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLDZEQUE2RCx3QkFBd0I7QUFDckY7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsK0JBQStCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxzQkFBc0IsMEJBQTBCLDBCQUEwQjtBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG1CQUFtQixHQUFHLDJCQUEyQixFQUFFLGFBQWEsRUFBRSxpQ0FBaUMsbUJBQW1CLGdCQUFnQixlQUFlLE9BQU87QUFDdE07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxtQ0FBbUMscUJBQXFCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFlBQVk7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGlCQUFpQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsbURBQW1ELGNBQWMsWUFBWSxRQUFRO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGFBQWE7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUSxvQkFBb0Isc0JBQXNCLElBQUksU0FBUztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxTQUFTLEVBQUUsY0FBYyxLQUFLLCtCQUErQjtBQUN4SDtBQUNBLFlBQVk7QUFDWixvQ0FBb0Msa0JBQWtCLEtBQUssb0NBQW9DLFdBQVcsU0FBUyxFQUFFLGFBQWE7QUFDbEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUpBQWlKLFlBQVksRUFBRSxhQUFhO0FBQzVLLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLFFBQVE7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsa0RBQWtELDhCQUE4QjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVEsZUFBZSxtREFBbUQ7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLG1CQUFtQixHQUFHLGlCQUFpQixFQUFFLDhCQUE4QjtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsK0JBQStCLHdCQUF3QiwyQkFBMkIsc0RBQXNELDBCQUEwQjtBQUMzTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsdURBQXVELEVBQUUsV0FBVztBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLG1DQUFtQyxtQ0FBbUM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHdCQUF3QixXQUFXLFlBQVksT0FBTyxrQkFBa0IsV0FBVyx1REFBdUQsU0FBUyxtQkFBbUI7QUFDeE47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGlEQUFpRCxhQUFhLFFBQVEsaUJBQWlCLElBQUksYUFBYTtBQUN4RztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLGtCQUFrQixFQUFFLGFBQWE7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esa0VBQWtFLFFBQVE7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFNBQVMsVUFBVSxtQkFBbUIsR0FBRyxpQkFBaUIsR0FBRyxpQ0FBaUMsc0JBQXNCLEdBQUcseUJBQXlCLFFBQVEsWUFBWSx5QkFBeUI7QUFDNU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxxQkFBcUIsU0FBUyxJQUFJLFlBQVk7QUFDOUM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxLQUFLLHlDQUF5QyxNQUFNLHVDQUF1QyxPQUFPO0FBQ3ZKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVyxHQUFHLFNBQVMsSUFBSSxFQUFFO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUNBQXVDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEVBQUUsTUFBTSxFQUFFO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLElBQUk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFdBQVc7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0EseUJBQXlCLEdBQUcsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUU7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsSUFBSTtBQUM3QztBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELEtBQUs7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLElBQUk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHNCQUFzQiw2QkFBNkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUY7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsd0JBQXdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsNEJBQTRCO0FBQy9HO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLG1CQUFtQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCwrQ0FBK0MsTUFBTTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE1BQU07QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwrQkFBK0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxHQUFHO0FBQ25DO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDBCQUEwQixRQUFRLGdCQUFnQixZQUFZO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDJDQUEyQyxvRUFBb0U7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsbUJBQW1CLDhDQUE4QyxnQkFBZ0IsdUNBQXVDLGFBQWEsWUFBWSxHQUFHLHlCQUF5QixLQUFLLGdCQUFnQjtBQUNsTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLEtBQUs7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHVCQUF1QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFDQUFxQztBQUMvRDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsS0FBSyxTQUFTLFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFDQUFxQyxvQkFBb0Isb0NBQW9DLFdBQVcsS0FBSyxrQ0FBa0M7QUFDL0k7QUFDQSxHQUFHO0FBQ0gseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWSxVQUFVLDRCQUE0QjtBQUNsRztBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUdBQXlHLGFBQWEsUUFBUSxXQUFXLEtBQUssU0FBUyxrQkFBa0IsY0FBYztBQUN2TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxtQkFBbUIscUJBQXFCLHNCQUFzQjtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGFBQWEsS0FBSyxXQUFXO0FBQzVGO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRixhQUFhLEtBQUssV0FBVztBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsYUFBYSxLQUFLLFdBQVc7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTix1RkFBdUYsYUFBYSxRQUFRLHNCQUFzQjtBQUNsSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxJQUFJO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHLHdCQUF3QixrQkFBa0IsNkZBQTZGLHdCQUF3QixvQ0FBb0MsaUNBQWlDLG9CQUFvQixLQUFLLGFBQWE7QUFDbFg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxJQUFJO0FBQ3ZEO0FBQ0E7QUFDQSxrRUFBa0UsV0FBVyxHQUFHLGFBQWE7QUFDN0Y7QUFDQTtBQUNBLFlBQVk7QUFDWixrRUFBa0UsV0FBVyxHQUFHLGFBQWE7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGtCQUFrQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsdUNBQXVDLGVBQWU7QUFDdEQsMEJBQTBCLHNCQUFzQixFQUFFLG9CQUFvQixHQUFHLFdBQVcsR0FBRyxVQUFVLEdBQUcsT0FBTyxHQUFHLFlBQVksR0FBRyxLQUFLO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSx3QkFBd0I7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsd0hBQXdIO0FBQzdMO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJCQUEyQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGVBQWUsaUNBQWlDLGtCQUFrQjtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFVBQVUsR0FBRyx3Q0FBd0MsRUFBRSwrQ0FBK0MsRUFBRSwyQ0FBMkMsR0FBRyxjQUFjLEdBQUcsK0NBQStDLGFBQWEsZUFBZSxFQUFFLHNEQUFzRDtBQUM3VTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxxQ0FBcUMsaUJBQWlCLGlEQUFpRCxhQUFhO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxpQkFBaUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxNQUFNO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msa0JBQWtCLEVBQUUsb0pBQW9KLEVBQUUseUNBQXlDLEVBQUUsdUZBQXVGLENBQUUsYUFBYSxFQUFFLElBQUk7QUFDclc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsdUJBQXVCOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsYUFBYSxvQkFBb0Isc0NBQXNDO0FBQzFIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLDJCQUEyQjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU8sYUFBYSxXQUFXO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiw2QkFBNkIsU0FBUyxXQUFXLFlBQVk7QUFDN0Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxXQUFXO0FBQ3BFO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWSxVQUFVLG1CQUFtQixHQUFHLGlCQUFpQixHQUFHLGlDQUFpQyxzQkFBc0IsR0FBRyx5QkFBeUIsUUFBUSxRQUFRLG1CQUFtQixJQUFJLGlCQUFpQixhQUFhLFNBQVM7QUFDdlA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHdCQUF3Qiw0REFBNEQsSUFBSSwyQkFBMkIsNEJBQTRCO0FBQ2hMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsbUZBQW1GLFNBQVMsV0FBVyxZQUFZO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFlBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsU0FBUyxXQUFXLFlBQVk7QUFDckU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsU0FBUyxNQUFNLGlCQUFpQixHQUFHLGNBQWMsVUFBVSxXQUFXLE9BQU8sUUFBUTtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsS0FBSztBQUNsRDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFFBQVEsRUFBRSxpQ0FBaUMsV0FBVyxZQUFZLDhDQUE4QyxXQUFXO0FBQ3pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxjQUFjLHVCQUF1QixZQUFZO0FBQ3ZGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGVBQWUsb0JBQW9CLGFBQWEsZUFBZSxZQUFZO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDBDQUEwQywyREFBMkQsU0FBUztBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFdBQVc7QUFDN0Q7QUFDQTtBQUNBLG1EQUFtRCxXQUFXLFNBQVMsV0FBVztBQUNsRjtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZ0JBQWdCLG1DQUFtQyxpQkFBaUIsR0FBRyxpQkFBaUIsR0FBRyxZQUFZO0FBQ3RKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGdCQUFnQiwwQkFBMEIsOEJBQThCLEdBQUcsaUJBQWlCLEdBQUcsMkVBQTJFLEVBQUUsZ0VBQWdFO0FBQzNSO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxxQkFBcUIsMEJBQTBCLG9CQUFvQixHQUFHLGlCQUFpQjtBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0hBQWdILGdCQUFnQjtBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNIQUFzSCxJQUFJO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNklBQTZJLG1CQUFtQjtBQUNoSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxvR0FBb0csZUFBZSxjQUFjLGNBQWM7QUFDL0k7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUVBQW1FLGFBQWEsV0FBVyxjQUFjLFFBQVEsV0FBVzs7QUFFNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxhQUFhO0FBQy9ELFVBQVU7QUFDVixrREFBa0QsYUFBYSxjQUFjLGtCQUFrQjtBQUMvRjtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsYUFBYTtBQUN2RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvRkFBb0YsWUFBWTs7QUFFaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQSw2QkFBNkIsa0NBQWtDLDBDQUEwQyxjQUFjO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQkFBK0IscUZBQXFGLHlCQUF5QixhQUFhO0FBQzFKO0FBQ0Esc0JBQXNCLGVBQWUsTUFBTSxXQUFXO0FBQ3RELE1BQU07QUFDTix5QkFBeUIsWUFBWSxhQUFhLGdCQUFnQjtBQUNsRTtBQUNBO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxLQUFLO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxrQ0FBa0MsY0FBYztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMEVBQTBFO0FBQzNHO0FBQ0E7QUFDQSxvQkFBb0Isb0NBQW9DO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0NBQW9DO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsU0FBUztBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFNBQVM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hELFFBQVE7QUFDUjtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFNBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsSUFBSTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVtdUI7QUFDbnVCIiwic291cmNlcyI6WyIvVXNlcnMvRXRoYW5MZWUvRGVza3RvcC9BZHZYL0FJLVdhdGNoLUJ1ZGR5L2Zyb250ZW5kL25vZGVfbW9kdWxlcy9obHMuanMvZGlzdC9obHMubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGh0dHBzOi8vY2FuaXVzZS5jb20vbWRuLWphdmFzY3JpcHRfYnVpbHRpbnNfbnVtYmVyX2lzZmluaXRlXG5jb25zdCBpc0Zpbml0ZU51bWJlciA9IE51bWJlci5pc0Zpbml0ZSB8fCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsdWUpO1xufTtcblxuLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS9tZG4tamF2YXNjcmlwdF9idWlsdGluc19udW1iZXJfaXNzYWZlaW50ZWdlclxuY29uc3QgaXNTYWZlSW50ZWdlciA9IE51bWJlci5pc1NhZmVJbnRlZ2VyIHx8IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBNYXRoLmFicyh2YWx1ZSkgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn07XG5jb25zdCBNQVhfU0FGRV9JTlRFR0VSID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgOTAwNzE5OTI1NDc0MDk5MTtcblxubGV0IEVycm9yVHlwZXMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKEVycm9yVHlwZXMpIHtcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBuZXR3b3JrIGVycm9yIChsb2FkaW5nIGVycm9yIC8gdGltZW91dCAuLi4pXG4gIEVycm9yVHlwZXNbXCJORVRXT1JLX0VSUk9SXCJdID0gXCJuZXR3b3JrRXJyb3JcIjtcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtZWRpYSBFcnJvciAodmlkZW8vcGFyc2luZy9tZWRpYXNvdXJjZSBlcnJvcilcbiAgRXJyb3JUeXBlc1tcIk1FRElBX0VSUk9SXCJdID0gXCJtZWRpYUVycm9yXCI7XG4gIC8vIEVNRSAoZW5jcnlwdGVkIG1lZGlhIGV4dGVuc2lvbnMpIGVycm9yc1xuICBFcnJvclR5cGVzW1wiS0VZX1NZU1RFTV9FUlJPUlwiXSA9IFwia2V5U3lzdGVtRXJyb3JcIjtcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtdXggRXJyb3IgKGRlbXV4aW5nL3JlbXV4aW5nKVxuICBFcnJvclR5cGVzW1wiTVVYX0VSUk9SXCJdID0gXCJtdXhFcnJvclwiO1xuICAvLyBJZGVudGlmaWVyIGZvciBhbGwgb3RoZXIgZXJyb3JzXG4gIEVycm9yVHlwZXNbXCJPVEhFUl9FUlJPUlwiXSA9IFwib3RoZXJFcnJvclwiO1xuICByZXR1cm4gRXJyb3JUeXBlcztcbn0oe30pO1xubGV0IEVycm9yRGV0YWlscyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoRXJyb3JEZXRhaWxzKSB7XG4gIEVycm9yRGV0YWlsc1tcIktFWV9TWVNURU1fTk9fS0VZU1wiXSA9IFwia2V5U3lzdGVtTm9LZXlzXCI7XG4gIEVycm9yRGV0YWlsc1tcIktFWV9TWVNURU1fTk9fQUNDRVNTXCJdID0gXCJrZXlTeXN0ZW1Ob0FjY2Vzc1wiO1xuICBFcnJvckRldGFpbHNbXCJLRVlfU1lTVEVNX05PX1NFU1NJT05cIl0gPSBcImtleVN5c3RlbU5vU2Vzc2lvblwiO1xuICBFcnJvckRldGFpbHNbXCJLRVlfU1lTVEVNX05PX0NPTkZJR1VSRURfTElDRU5TRVwiXSA9IFwia2V5U3lzdGVtTm9Db25maWd1cmVkTGljZW5zZVwiO1xuICBFcnJvckRldGFpbHNbXCJLRVlfU1lTVEVNX0xJQ0VOU0VfUkVRVUVTVF9GQUlMRURcIl0gPSBcImtleVN5c3RlbUxpY2Vuc2VSZXF1ZXN0RmFpbGVkXCI7XG4gIEVycm9yRGV0YWlsc1tcIktFWV9TWVNURU1fU0VSVkVSX0NFUlRJRklDQVRFX1JFUVVFU1RfRkFJTEVEXCJdID0gXCJrZXlTeXN0ZW1TZXJ2ZXJDZXJ0aWZpY2F0ZVJlcXVlc3RGYWlsZWRcIjtcbiAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9TRVJWRVJfQ0VSVElGSUNBVEVfVVBEQVRFX0ZBSUxFRFwiXSA9IFwia2V5U3lzdGVtU2VydmVyQ2VydGlmaWNhdGVVcGRhdGVGYWlsZWRcIjtcbiAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9TRVNTSU9OX1VQREFURV9GQUlMRURcIl0gPSBcImtleVN5c3RlbVNlc3Npb25VcGRhdGVGYWlsZWRcIjtcbiAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9TVEFUVVNfT1VUUFVUX1JFU1RSSUNURURcIl0gPSBcImtleVN5c3RlbVN0YXR1c091dHB1dFJlc3RyaWN0ZWRcIjtcbiAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9TVEFUVVNfSU5URVJOQUxfRVJST1JcIl0gPSBcImtleVN5c3RlbVN0YXR1c0ludGVybmFsRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9ERVNUUk9ZX01FRElBX0tFWVNfRVJST1JcIl0gPSBcImtleVN5c3RlbURlc3Ryb3lNZWRpYUtleXNFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJLRVlfU1lTVEVNX0RFU1RST1lfQ0xPU0VfU0VTU0lPTl9FUlJPUlwiXSA9IFwia2V5U3lzdGVtRGVzdHJveUNsb3NlU2Vzc2lvbkVycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIktFWV9TWVNURU1fREVTVFJPWV9SRU1PVkVfU0VTU0lPTl9FUlJPUlwiXSA9IFwia2V5U3lzdGVtRGVzdHJveVJlbW92ZVNlc3Npb25FcnJvclwiO1xuICAvLyBJZGVudGlmaWVyIGZvciBhIG1hbmlmZXN0IGxvYWQgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIEVycm9yRGV0YWlsc1tcIk1BTklGRVNUX0xPQURfRVJST1JcIl0gPSBcIm1hbmlmZXN0TG9hZEVycm9yXCI7XG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbWFuaWZlc3QgbG9hZCB0aW1lb3V0IC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBFcnJvckRldGFpbHNbXCJNQU5JRkVTVF9MT0FEX1RJTUVPVVRcIl0gPSBcIm1hbmlmZXN0TG9hZFRpbWVPdXRcIjtcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtYW5pZmVzdCBwYXJzaW5nIGVycm9yIC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZWFzb24gOiBlcnJvciByZWFzb259XG4gIEVycm9yRGV0YWlsc1tcIk1BTklGRVNUX1BBUlNJTkdfRVJST1JcIl0gPSBcIm1hbmlmZXN0UGFyc2luZ0Vycm9yXCI7XG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbWFuaWZlc3Qgd2l0aCBvbmx5IGluY29tcGF0aWJsZSBjb2RlY3MgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlYXNvbiA6IGVycm9yIHJlYXNvbn1cbiAgRXJyb3JEZXRhaWxzW1wiTUFOSUZFU1RfSU5DT01QQVRJQkxFX0NPREVDU19FUlJPUlwiXSA9IFwibWFuaWZlc3RJbmNvbXBhdGlibGVDb2RlY3NFcnJvclwiO1xuICAvLyBJZGVudGlmaWVyIGZvciBhIGxldmVsIHdoaWNoIGNvbnRhaW5zIG5vIGZyYWdtZW50cyAtIGRhdGE6IHsgdXJsOiBmYXVsdHkgVVJMLCByZWFzb246IFwibm8gZnJhZ21lbnRzIGZvdW5kIGluIGxldmVsXCIsIGxldmVsOiBpbmRleCBvZiB0aGUgYmFkIGxldmVsIH1cbiAgRXJyb3JEZXRhaWxzW1wiTEVWRUxfRU1QVFlfRVJST1JcIl0gPSBcImxldmVsRW1wdHlFcnJvclwiO1xuICAvLyBJZGVudGlmaWVyIGZvciBhIGxldmVsIGxvYWQgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIEVycm9yRGV0YWlsc1tcIkxFVkVMX0xPQURfRVJST1JcIl0gPSBcImxldmVsTG9hZEVycm9yXCI7XG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbGV2ZWwgbG9hZCB0aW1lb3V0IC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBFcnJvckRldGFpbHNbXCJMRVZFTF9MT0FEX1RJTUVPVVRcIl0gPSBcImxldmVsTG9hZFRpbWVPdXRcIjtcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBsZXZlbCBwYXJzZSBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgZXJyb3I6IEVycm9yLCByZWFzb246IGVycm9yIG1lc3NhZ2UgfVxuICBFcnJvckRldGFpbHNbXCJMRVZFTF9QQVJTSU5HX0VSUk9SXCJdID0gXCJsZXZlbFBhcnNpbmdFcnJvclwiO1xuICAvLyBJZGVudGlmaWVyIGZvciBhIGxldmVsIHN3aXRjaCBlcnJvciAtIGRhdGE6IHsgbGV2ZWwgOiBmYXVsdHkgbGV2ZWwgSWQsIGV2ZW50IDogZXJyb3IgZGVzY3JpcHRpb259XG4gIEVycm9yRGV0YWlsc1tcIkxFVkVMX1NXSVRDSF9FUlJPUlwiXSA9IFwibGV2ZWxTd2l0Y2hFcnJvclwiO1xuICAvLyBJZGVudGlmaWVyIGZvciBhbiBhdWRpbyB0cmFjayBsb2FkIGVycm9yIC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBFcnJvckRldGFpbHNbXCJBVURJT19UUkFDS19MT0FEX0VSUk9SXCJdID0gXCJhdWRpb1RyYWNrTG9hZEVycm9yXCI7XG4gIC8vIElkZW50aWZpZXIgZm9yIGFuIGF1ZGlvIHRyYWNrIGxvYWQgdGltZW91dCAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgRXJyb3JEZXRhaWxzW1wiQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUXCJdID0gXCJhdWRpb1RyYWNrTG9hZFRpbWVPdXRcIjtcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBzdWJ0aXRsZSB0cmFjayBsb2FkIGVycm9yIC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBFcnJvckRldGFpbHNbXCJTVUJUSVRMRV9MT0FEX0VSUk9SXCJdID0gXCJzdWJ0aXRsZVRyYWNrTG9hZEVycm9yXCI7XG4gIC8vIElkZW50aWZpZXIgZm9yIGEgc3VidGl0bGUgdHJhY2sgbG9hZCB0aW1lb3V0IC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBFcnJvckRldGFpbHNbXCJTVUJUSVRMRV9UUkFDS19MT0FEX1RJTUVPVVRcIl0gPSBcInN1YnRpdGxlVHJhY2tMb2FkVGltZU91dFwiO1xuICAvLyBJZGVudGlmaWVyIGZvciBmcmFnbWVudCBsb2FkIGVycm9yIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBFcnJvckRldGFpbHNbXCJGUkFHX0xPQURfRVJST1JcIl0gPSBcImZyYWdMb2FkRXJyb3JcIjtcbiAgLy8gSWRlbnRpZmllciBmb3IgZnJhZ21lbnQgbG9hZCB0aW1lb3V0IGVycm9yIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0fVxuICBFcnJvckRldGFpbHNbXCJGUkFHX0xPQURfVElNRU9VVFwiXSA9IFwiZnJhZ0xvYWRUaW1lT3V0XCI7XG4gIC8vIElkZW50aWZpZXIgZm9yIGEgZnJhZ21lbnQgZGVjcnlwdGlvbiBlcnJvciBldmVudCAtIGRhdGE6IHtpZCA6IGRlbXV4ZXIgSWQsZnJhZzogZnJhZ21lbnQgb2JqZWN0LCByZWFzb24gOiBwYXJzaW5nIGVycm9yIGRlc2NyaXB0aW9uIH1cbiAgRXJyb3JEZXRhaWxzW1wiRlJBR19ERUNSWVBUX0VSUk9SXCJdID0gXCJmcmFnRGVjcnlwdEVycm9yXCI7XG4gIC8vIElkZW50aWZpZXIgZm9yIGEgZnJhZ21lbnQgcGFyc2luZyBlcnJvciBldmVudCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIElkLCByZWFzb24gOiBwYXJzaW5nIGVycm9yIGRlc2NyaXB0aW9uIH1cbiAgLy8gd2lsbCBiZSByZW5hbWVkIERFTVVYX1BBUlNJTkdfRVJST1IgYW5kIHN3aXRjaGVkIHRvIE1VWF9FUlJPUiBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlXG4gIEVycm9yRGV0YWlsc1tcIkZSQUdfUEFSU0lOR19FUlJPUlwiXSA9IFwiZnJhZ1BhcnNpbmdFcnJvclwiO1xuICAvLyBJZGVudGlmaWVyIGZvciBhIGZyYWdtZW50IG9yIHBhcnQgbG9hZCBza2lwcGVkIGJlY2F1c2Ugb2YgYSBHQVAgdGFnIG9yIGF0dHJpYnV0ZVxuICBFcnJvckRldGFpbHNbXCJGUkFHX0dBUFwiXSA9IFwiZnJhZ0dhcFwiO1xuICAvLyBJZGVudGlmaWVyIGZvciBhIHJlbXV4IGFsbG9jIGVycm9yIGV2ZW50IC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgSWQsIGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIGJ5dGVzIDogbmIgb2YgYnl0ZXMgb24gd2hpY2ggYWxsb2NhdGlvbiBmYWlsZWQgLCByZWFzb24gOiBlcnJvciB0ZXh0IH1cbiAgRXJyb3JEZXRhaWxzW1wiUkVNVVhfQUxMT0NfRVJST1JcIl0gPSBcInJlbXV4QWxsb2NFcnJvclwiO1xuICAvLyBJZGVudGlmaWVyIGZvciBkZWNyeXB0IGtleSBsb2FkIGVycm9yIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBFcnJvckRldGFpbHNbXCJLRVlfTE9BRF9FUlJPUlwiXSA9IFwia2V5TG9hZEVycm9yXCI7XG4gIC8vIElkZW50aWZpZXIgZm9yIGRlY3J5cHQga2V5IGxvYWQgdGltZW91dCBlcnJvciAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdH1cbiAgRXJyb3JEZXRhaWxzW1wiS0VZX0xPQURfVElNRU9VVFwiXSA9IFwia2V5TG9hZFRpbWVPdXRcIjtcbiAgLy8gVHJpZ2dlcmVkIHdoZW4gYW4gZXhjZXB0aW9uIG9jY3VycyB3aGlsZSBhZGRpbmcgYSBzb3VyY2VCdWZmZXIgdG8gTWVkaWFTb3VyY2UgLSBkYXRhIDogeyBlcnJvciA6IGV4Y2VwdGlvbiAsIG1pbWVUeXBlIDogbWltZVR5cGUgfVxuICBFcnJvckRldGFpbHNbXCJCVUZGRVJfQUREX0NPREVDX0VSUk9SXCJdID0gXCJidWZmZXJBZGRDb2RlY0Vycm9yXCI7XG4gIC8vIFRyaWdnZXJlZCB3aGVuIHNvdXJjZSBidWZmZXIocykgY291bGQgbm90IGJlIGNyZWF0ZWQgdXNpbmcgbGV2ZWwgKG1hbmlmZXN0IENPREVDUyBhdHRyaWJ1dGUpLCBwYXJzZWQgbWVkaWEsIG9yIGJlc3QgZ3Vlc3MgY29kZWMocykgLSBkYXRhOiB7IHJlYXNvbiA6IGVycm9yIHJlYXNvbiB9XG4gIEVycm9yRGV0YWlsc1tcIkJVRkZFUl9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SXCJdID0gXCJidWZmZXJJbmNvbXBhdGlibGVDb2RlY3NFcnJvclwiO1xuICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBhcHBlbmQgZXJyb3IgLSBkYXRhOiBhcHBlbmQgZXJyb3IgZGVzY3JpcHRpb25cbiAgRXJyb3JEZXRhaWxzW1wiQlVGRkVSX0FQUEVORF9FUlJPUlwiXSA9IFwiYnVmZmVyQXBwZW5kRXJyb3JcIjtcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBidWZmZXIgYXBwZW5kaW5nIGVycm9yIGV2ZW50IC0gZGF0YTogYXBwZW5kaW5nIGVycm9yIGRlc2NyaXB0aW9uXG4gIEVycm9yRGV0YWlsc1tcIkJVRkZFUl9BUFBFTkRJTkdfRVJST1JcIl0gPSBcImJ1ZmZlckFwcGVuZGluZ0Vycm9yXCI7XG4gIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIHN0YWxsZWQgZXJyb3IgZXZlbnRcbiAgRXJyb3JEZXRhaWxzW1wiQlVGRkVSX1NUQUxMRURfRVJST1JcIl0gPSBcImJ1ZmZlclN0YWxsZWRFcnJvclwiO1xuICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBmdWxsIGV2ZW50XG4gIEVycm9yRGV0YWlsc1tcIkJVRkZFUl9GVUxMX0VSUk9SXCJdID0gXCJidWZmZXJGdWxsRXJyb3JcIjtcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBidWZmZXIgc2VlayBvdmVyIGhvbGUgZXZlbnRcbiAgRXJyb3JEZXRhaWxzW1wiQlVGRkVSX1NFRUtfT1ZFUl9IT0xFXCJdID0gXCJidWZmZXJTZWVrT3ZlckhvbGVcIjtcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBidWZmZXIgbnVkZ2Ugb24gc3RhbGwgKHBsYXliYWNrIGlzIHN0dWNrIGFsdGhvdWdoIGN1cnJlbnRUaW1lIGlzIGluIGEgYnVmZmVyZWQgYXJlYSlcbiAgRXJyb3JEZXRhaWxzW1wiQlVGRkVSX05VREdFX09OX1NUQUxMXCJdID0gXCJidWZmZXJOdWRnZU9uU3RhbGxcIjtcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBJbnRlcnN0aXRpYWwgQXNzZXQgTGlzdCBsb2FkIGVycm9yIC0gZGF0YTogeyB1cmw6IGZhdWx0eSBVUkwsIHJlc3BvbnNlOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfSB9XG4gIEVycm9yRGV0YWlsc1tcIkFTU0VUX0xJU1RfTE9BRF9FUlJPUlwiXSA9IFwiYXNzZXRMaXN0TG9hZEVycm9yXCI7XG4gIC8vIElkZW50aWZpZXIgZm9yIGEgSW50ZXJzdGl0aWFsIEFzc2V0IExpc3QgbG9hZCB0aW1lb3V0IC0gZGF0YTogeyB1cmw6IGZhdWx0eSBVUkwsIHJlc3BvbnNlOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfSB9XG4gIEVycm9yRGV0YWlsc1tcIkFTU0VUX0xJU1RfTE9BRF9USU1FT1VUXCJdID0gXCJhc3NldExpc3RMb2FkVGltZW91dFwiO1xuICAvLyBJZGVudGlmaWVyIGZvciBhIEludGVyc3RpdGlhbCBBc3NldCBMaXN0IHBhcnNpbmcgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlYXNvbiA6IGVycm9yIHJlYXNvbiwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgRXJyb3JEZXRhaWxzW1wiQVNTRVRfTElTVF9QQVJTSU5HX0VSUk9SXCJdID0gXCJhc3NldExpc3RQYXJzaW5nRXJyb3JcIjtcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBJbnRlcnN0aXRpYWwgQXNzZXQgTGlzdCBwYXJzaW5nIGVycm9yIC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZWFzb24gOiBlcnJvciByZWFzb24sIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIEVycm9yRGV0YWlsc1tcIklOVEVSU1RJVElBTF9BU1NFVF9JVEVNX0VSUk9SXCJdID0gXCJpbnRlcnN0aXRpYWxBc3NldEl0ZW1FcnJvclwiO1xuICAvLyBJZGVudGlmaWVyIGZvciBhbiBpbnRlcm5hbCBleGNlcHRpb24gaGFwcGVuaW5nIGluc2lkZSBobHMuanMgd2hpbGUgaGFuZGxpbmcgYW4gZXZlbnRcbiAgRXJyb3JEZXRhaWxzW1wiSU5URVJOQUxfRVhDRVBUSU9OXCJdID0gXCJpbnRlcm5hbEV4Y2VwdGlvblwiO1xuICAvLyBJZGVudGlmaWVyIGZvciBhbiBpbnRlcm5hbCBjYWxsIHRvIGFib3J0IGEgbG9hZGVyXG4gIEVycm9yRGV0YWlsc1tcIklOVEVSTkFMX0FCT1JURURcIl0gPSBcImFib3J0ZWRcIjtcbiAgLy8gVHJpZ2dlcmVkIHdoZW4gYXR0YWNoTWVkaWEgZmFpbHNcbiAgRXJyb3JEZXRhaWxzW1wiQVRUQUNIX01FRElBX0VSUk9SXCJdID0gXCJhdHRhY2hNZWRpYUVycm9yXCI7XG4gIC8vIFVuY2F0ZWdvcml6ZWQgZXJyb3JcbiAgRXJyb3JEZXRhaWxzW1wiVU5LTk9XTlwiXSA9IFwidW5rbm93blwiO1xuICByZXR1cm4gRXJyb3JEZXRhaWxzO1xufSh7fSk7XG5cbmxldCBFdmVudHMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKEV2ZW50cykge1xuICAvLyBGaXJlZCBiZWZvcmUgTWVkaWFTb3VyY2UgaXMgYXR0YWNoaW5nIHRvIG1lZGlhIGVsZW1lbnRcbiAgRXZlbnRzW1wiTUVESUFfQVRUQUNISU5HXCJdID0gXCJobHNNZWRpYUF0dGFjaGluZ1wiO1xuICAvLyBGaXJlZCB3aGVuIE1lZGlhU291cmNlIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBhdHRhY2hlZCB0byBtZWRpYSBlbGVtZW50XG4gIEV2ZW50c1tcIk1FRElBX0FUVEFDSEVEXCJdID0gXCJobHNNZWRpYUF0dGFjaGVkXCI7XG4gIC8vIEZpcmVkIGJlZm9yZSBkZXRhY2hpbmcgTWVkaWFTb3VyY2UgZnJvbSBtZWRpYSBlbGVtZW50XG4gIEV2ZW50c1tcIk1FRElBX0RFVEFDSElOR1wiXSA9IFwiaGxzTWVkaWFEZXRhY2hpbmdcIjtcbiAgLy8gRmlyZWQgd2hlbiBNZWRpYVNvdXJjZSBoYXMgYmVlbiBkZXRhY2hlZCBmcm9tIG1lZGlhIGVsZW1lbnRcbiAgRXZlbnRzW1wiTUVESUFfREVUQUNIRURcIl0gPSBcImhsc01lZGlhRGV0YWNoZWRcIjtcbiAgLy8gRmlyZWQgd2hlbiBIVE1MTWVkaWFFbGVtZW50IGRpc3BhdGNoZXMgXCJlbmRlZFwiIGV2ZW50LCBvciBzdGFsbHMgYXQgZW5kIG9mIFZPRCBwcm9ncmFtXG4gIEV2ZW50c1tcIk1FRElBX0VOREVEXCJdID0gXCJobHNNZWRpYUVuZGVkXCI7XG4gIC8vIEZpcmVkIGFmdGVyIHBsYXliYWNrIHN0YWxsIGlzIHJlc29sdmVkIHdpdGggcGxheWluZywgc2Vla2VkLCBvciBlbmRlZCBldmVudCBmb2xsb3dpbmcgQlVGRkVSX1NUQUxMRURfRVJST1JcbiAgRXZlbnRzW1wiU1RBTExfUkVTT0xWRURcIl0gPSBcImhsc1N0YWxsUmVzb2x2ZWRcIjtcbiAgLy8gRmlyZWQgd2hlbiB0aGUgYnVmZmVyIGlzIGdvaW5nIHRvIGJlIHJlc2V0XG4gIEV2ZW50c1tcIkJVRkZFUl9SRVNFVFwiXSA9IFwiaGxzQnVmZmVyUmVzZXRcIjtcbiAgLy8gRmlyZWQgd2hlbiB3ZSBrbm93IGFib3V0IHRoZSBjb2RlY3MgdGhhdCB3ZSBuZWVkIGJ1ZmZlcnMgZm9yIHRvIHB1c2ggaW50byAtIGRhdGE6IHt0cmFja3MgOiB7IGNvbnRhaW5lciwgY29kZWMsIGxldmVsQ29kZWMsIGluaXRTZWdtZW50LCBtZXRhZGF0YSB9fVxuICBFdmVudHNbXCJCVUZGRVJfQ09ERUNTXCJdID0gXCJobHNCdWZmZXJDb2RlY3NcIjtcbiAgLy8gZmlyZWQgd2hlbiBzb3VyY2VidWZmZXJzIGhhdmUgYmVlbiBjcmVhdGVkIC0gZGF0YTogeyB0cmFja3MgOiB0cmFja3MgfVxuICBFdmVudHNbXCJCVUZGRVJfQ1JFQVRFRFwiXSA9IFwiaGxzQnVmZmVyQ3JlYXRlZFwiO1xuICAvLyBmaXJlZCB3aGVuIHdlIGFwcGVuZCBhIHNlZ21lbnQgdG8gdGhlIGJ1ZmZlciAtIGRhdGE6IHsgc2VnbWVudDogc2VnbWVudCBvYmplY3QgfVxuICBFdmVudHNbXCJCVUZGRVJfQVBQRU5ESU5HXCJdID0gXCJobHNCdWZmZXJBcHBlbmRpbmdcIjtcbiAgLy8gZmlyZWQgd2hlbiB3ZSBhcmUgZG9uZSB3aXRoIGFwcGVuZGluZyBhIG1lZGlhIHNlZ21lbnQgdG8gdGhlIGJ1ZmZlciAtIGRhdGEgOiB7IHBhcmVudCA6IHNlZ21lbnQgcGFyZW50IHRoYXQgdHJpZ2dlcmVkIEJVRkZFUl9BUFBFTkRJTkcsIHBlbmRpbmcgOiBuYiBvZiBzZWdtZW50cyB3YWl0aW5nIGZvciBhcHBlbmRpbmcgZm9yIHRoaXMgc2VnbWVudCBwYXJlbnR9XG4gIEV2ZW50c1tcIkJVRkZFUl9BUFBFTkRFRFwiXSA9IFwiaGxzQnVmZmVyQXBwZW5kZWRcIjtcbiAgLy8gZmlyZWQgd2hlbiB0aGUgc3RyZWFtIGlzIGZpbmlzaGVkIGFuZCB3ZSB3YW50IHRvIG5vdGlmeSB0aGUgbWVkaWEgYnVmZmVyIHRoYXQgdGhlcmUgd2lsbCBiZSBubyBtb3JlIGRhdGEgLSBkYXRhOiB7IH1cbiAgRXZlbnRzW1wiQlVGRkVSX0VPU1wiXSA9IFwiaGxzQnVmZmVyRW9zXCI7XG4gIC8vIGZpcmVkIHdoZW4gYWxsIGJ1ZmZlcnMgYXJlIGZ1bGwgdG8gdGhlIGVuZCBvZiB0aGUgcHJvZ3JhbSwgYWZ0ZXIgY2FsbGluZyBNZWRpYVNvdXJjZS5lbmRPZlN0cmVhbSgpICh1bmxlc3MgcmVzdHJpY3RlZClcbiAgRXZlbnRzW1wiQlVGRkVSRURfVE9fRU5EXCJdID0gXCJobHNCdWZmZXJlZFRvRW5kXCI7XG4gIC8vIGZpcmVkIHdoZW4gdGhlIG1lZGlhIGJ1ZmZlciBzaG91bGQgYmUgZmx1c2hlZCAtIGRhdGEgeyBzdGFydE9mZnNldCwgZW5kT2Zmc2V0IH1cbiAgRXZlbnRzW1wiQlVGRkVSX0ZMVVNISU5HXCJdID0gXCJobHNCdWZmZXJGbHVzaGluZ1wiO1xuICAvLyBmaXJlZCB3aGVuIHRoZSBtZWRpYSBidWZmZXIgaGFzIGJlZW4gZmx1c2hlZCAtIGRhdGE6IHsgfVxuICBFdmVudHNbXCJCVUZGRVJfRkxVU0hFRFwiXSA9IFwiaGxzQnVmZmVyRmx1c2hlZFwiO1xuICAvLyBmaXJlZCB0byBzaWduYWwgdGhhdCBhIG1hbmlmZXN0IGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyB1cmwgOiBtYW5pZmVzdFVSTH1cbiAgRXZlbnRzW1wiTUFOSUZFU1RfTE9BRElOR1wiXSA9IFwiaGxzTWFuaWZlc3RMb2FkaW5nXCI7XG4gIC8vIGZpcmVkIGFmdGVyIG1hbmlmZXN0IGhhcyBiZWVuIGxvYWRlZCAtIGRhdGE6IHsgbGV2ZWxzIDogW2F2YWlsYWJsZSBxdWFsaXR5IGxldmVsc10sIGF1ZGlvVHJhY2tzIDogWyBhdmFpbGFibGUgYXVkaW8gdHJhY2tzIF0sIHVybCA6IG1hbmlmZXN0VVJMLCBzdGF0cyA6IExvYWRlclN0YXRzIH1cbiAgRXZlbnRzW1wiTUFOSUZFU1RfTE9BREVEXCJdID0gXCJobHNNYW5pZmVzdExvYWRlZFwiO1xuICAvLyBmaXJlZCBhZnRlciBtYW5pZmVzdCBoYXMgYmVlbiBwYXJzZWQgLSBkYXRhOiB7IGxldmVscyA6IFthdmFpbGFibGUgcXVhbGl0eSBsZXZlbHNdLCBmaXJzdExldmVsIDogaW5kZXggb2YgZmlyc3QgcXVhbGl0eSBsZXZlbCBhcHBlYXJpbmcgaW4gTWFuaWZlc3R9XG4gIEV2ZW50c1tcIk1BTklGRVNUX1BBUlNFRFwiXSA9IFwiaGxzTWFuaWZlc3RQYXJzZWRcIjtcbiAgLy8gZmlyZWQgd2hlbiBhIGxldmVsIHN3aXRjaCBpcyByZXF1ZXN0ZWQgLSBkYXRhOiB7IGxldmVsIDogaWQgb2YgbmV3IGxldmVsIH1cbiAgRXZlbnRzW1wiTEVWRUxfU1dJVENISU5HXCJdID0gXCJobHNMZXZlbFN3aXRjaGluZ1wiO1xuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwgc3dpdGNoIGlzIGVmZmVjdGl2ZSAtIGRhdGE6IHsgbGV2ZWwgOiBpZCBvZiBuZXcgbGV2ZWwgfVxuICBFdmVudHNbXCJMRVZFTF9TV0lUQ0hFRFwiXSA9IFwiaGxzTGV2ZWxTd2l0Y2hlZFwiO1xuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwgcGxheWxpc3QgbG9hZGluZyBzdGFydHMgLSBkYXRhOiB7IHVybCA6IGxldmVsIFVSTCwgbGV2ZWwgOiBpZCBvZiBsZXZlbCBiZWluZyBsb2FkZWR9XG4gIEV2ZW50c1tcIkxFVkVMX0xPQURJTkdcIl0gPSBcImhsc0xldmVsTG9hZGluZ1wiO1xuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwgcGxheWxpc3QgbG9hZGluZyBmaW5pc2hlcyAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGxldmVsIDogaWQgb2YgbG9hZGVkIGxldmVsLCBzdGF0cyA6IExvYWRlclN0YXRzIH1cbiAgRXZlbnRzW1wiTEVWRUxfTE9BREVEXCJdID0gXCJobHNMZXZlbExvYWRlZFwiO1xuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwncyBkZXRhaWxzIGhhdmUgYmVlbiB1cGRhdGVkIGJhc2VkIG9uIHByZXZpb3VzIGRldGFpbHMsIGFmdGVyIGl0IGhhcyBiZWVuIGxvYWRlZCAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGxldmVsIDogaWQgb2YgdXBkYXRlZCBsZXZlbCB9XG4gIEV2ZW50c1tcIkxFVkVMX1VQREFURURcIl0gPSBcImhsc0xldmVsVXBkYXRlZFwiO1xuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwncyBQVFMgaW5mb3JtYXRpb24gaGFzIGJlZW4gdXBkYXRlZCBhZnRlciBwYXJzaW5nIGEgZnJhZ21lbnQgLSBkYXRhOiB7IGRldGFpbHMgOiBsZXZlbERldGFpbHMgb2JqZWN0LCBsZXZlbCA6IGlkIG9mIHVwZGF0ZWQgbGV2ZWwsIGRyaWZ0OiBQVFMgZHJpZnQgb2JzZXJ2ZWQgd2hlbiBwYXJzaW5nIGxhc3QgZnJhZ21lbnQgfVxuICBFdmVudHNbXCJMRVZFTF9QVFNfVVBEQVRFRFwiXSA9IFwiaGxzTGV2ZWxQdHNVcGRhdGVkXCI7XG4gIC8vIGZpcmVkIHRvIG5vdGlmeSB0aGF0IGxldmVscyBoYXZlIGNoYW5nZWQgYWZ0ZXIgcmVtb3ZpbmcgYSBsZXZlbCAtIGRhdGE6IHsgbGV2ZWxzIDogW2F2YWlsYWJsZSBxdWFsaXR5IGxldmVsc10gfVxuICBFdmVudHNbXCJMRVZFTFNfVVBEQVRFRFwiXSA9IFwiaGxzTGV2ZWxzVXBkYXRlZFwiO1xuICAvLyBmaXJlZCB0byBub3RpZnkgdGhhdCBhdWRpbyB0cmFjayBsaXN0cyBoYXMgYmVlbiB1cGRhdGVkIC0gZGF0YTogeyBhdWRpb1RyYWNrcyA6IGF1ZGlvVHJhY2tzIH1cbiAgRXZlbnRzW1wiQVVESU9fVFJBQ0tTX1VQREFURURcIl0gPSBcImhsc0F1ZGlvVHJhY2tzVXBkYXRlZFwiO1xuICAvLyBmaXJlZCB3aGVuIGFuIGF1ZGlvIHRyYWNrIHN3aXRjaGluZyBpcyByZXF1ZXN0ZWQgLSBkYXRhOiB7IGlkIDogYXVkaW8gdHJhY2sgaWQgfVxuICBFdmVudHNbXCJBVURJT19UUkFDS19TV0lUQ0hJTkdcIl0gPSBcImhsc0F1ZGlvVHJhY2tTd2l0Y2hpbmdcIjtcbiAgLy8gZmlyZWQgd2hlbiBhbiBhdWRpbyB0cmFjayBzd2l0Y2ggYWN0dWFsbHkgb2NjdXJzIC0gZGF0YTogeyBpZCA6IGF1ZGlvIHRyYWNrIGlkIH1cbiAgRXZlbnRzW1wiQVVESU9fVFJBQ0tfU1dJVENIRURcIl0gPSBcImhsc0F1ZGlvVHJhY2tTd2l0Y2hlZFwiO1xuICAvLyBmaXJlZCB3aGVuIGFuIGF1ZGlvIHRyYWNrIGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyB1cmwgOiBhdWRpbyB0cmFjayBVUkwsIGlkIDogYXVkaW8gdHJhY2sgaWQgfVxuICBFdmVudHNbXCJBVURJT19UUkFDS19MT0FESU5HXCJdID0gXCJobHNBdWRpb1RyYWNrTG9hZGluZ1wiO1xuICAvLyBmaXJlZCB3aGVuIGFuIGF1ZGlvIHRyYWNrIGxvYWRpbmcgZmluaXNoZXMgLSBkYXRhOiB7IGRldGFpbHMgOiBsZXZlbERldGFpbHMgb2JqZWN0LCBpZCA6IGF1ZGlvIHRyYWNrIGlkLCBzdGF0cyA6IExvYWRlclN0YXRzIH1cbiAgRXZlbnRzW1wiQVVESU9fVFJBQ0tfTE9BREVEXCJdID0gXCJobHNBdWRpb1RyYWNrTG9hZGVkXCI7XG4gIC8vIGZpcmVkIHdoZW4gYW4gYXVkaW8gdHJhY2tzJ3MgZGV0YWlscyBoYXZlIGJlZW4gdXBkYXRlZCBiYXNlZCBvbiBwcmV2aW91cyBkZXRhaWxzLCBhZnRlciBpdCBoYXMgYmVlbiBsb2FkZWQgLSBkYXRhOiB7IGRldGFpbHMgOiBsZXZlbERldGFpbHMgb2JqZWN0LCBpZCA6IHRyYWNrIGlkIH1cbiAgRXZlbnRzW1wiQVVESU9fVFJBQ0tfVVBEQVRFRFwiXSA9IFwiaGxzQXVkaW9UcmFja1VwZGF0ZWRcIjtcbiAgLy8gZmlyZWQgdG8gbm90aWZ5IHRoYXQgc3VidGl0bGUgdHJhY2sgbGlzdHMgaGFzIGJlZW4gdXBkYXRlZCAtIGRhdGE6IHsgc3VidGl0bGVUcmFja3MgOiBzdWJ0aXRsZVRyYWNrcyB9XG4gIEV2ZW50c1tcIlNVQlRJVExFX1RSQUNLU19VUERBVEVEXCJdID0gXCJobHNTdWJ0aXRsZVRyYWNrc1VwZGF0ZWRcIjtcbiAgLy8gZmlyZWQgdG8gbm90aWZ5IHRoYXQgc3VidGl0bGUgdHJhY2tzIHdlcmUgY2xlYXJlZCBhcyBhIHJlc3VsdCBvZiBzdG9wcGluZyB0aGUgbWVkaWFcbiAgRXZlbnRzW1wiU1VCVElUTEVfVFJBQ0tTX0NMRUFSRURcIl0gPSBcImhsc1N1YnRpdGxlVHJhY2tzQ2xlYXJlZFwiO1xuICAvLyBmaXJlZCB3aGVuIGFuIHN1YnRpdGxlIHRyYWNrIHN3aXRjaCBvY2N1cnMgLSBkYXRhOiB7IGlkIDogc3VidGl0bGUgdHJhY2sgaWQgfVxuICBFdmVudHNbXCJTVUJUSVRMRV9UUkFDS19TV0lUQ0hcIl0gPSBcImhsc1N1YnRpdGxlVHJhY2tTd2l0Y2hcIjtcbiAgLy8gZmlyZWQgd2hlbiBhIHN1YnRpdGxlIHRyYWNrIGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyB1cmwgOiBzdWJ0aXRsZSB0cmFjayBVUkwsIGlkIDogc3VidGl0bGUgdHJhY2sgaWQgfVxuICBFdmVudHNbXCJTVUJUSVRMRV9UUkFDS19MT0FESU5HXCJdID0gXCJobHNTdWJ0aXRsZVRyYWNrTG9hZGluZ1wiO1xuICAvLyBmaXJlZCB3aGVuIGEgc3VidGl0bGUgdHJhY2sgbG9hZGluZyBmaW5pc2hlcyAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGlkIDogc3VidGl0bGUgdHJhY2sgaWQsIHN0YXRzIDogTG9hZGVyU3RhdHMgfVxuICBFdmVudHNbXCJTVUJUSVRMRV9UUkFDS19MT0FERURcIl0gPSBcImhsc1N1YnRpdGxlVHJhY2tMb2FkZWRcIjtcbiAgLy8gZmlyZWQgd2hlbiBhIHN1YnRpdGxlICByYWNrcydzIGRldGFpbHMgaGF2ZSBiZWVuIHVwZGF0ZWQgYmFzZWQgb24gcHJldmlvdXMgZGV0YWlscywgYWZ0ZXIgaXQgaGFzIGJlZW4gbG9hZGVkIC0gZGF0YTogeyBkZXRhaWxzIDogbGV2ZWxEZXRhaWxzIG9iamVjdCwgaWQgOiB0cmFjayBpZCB9XG4gIEV2ZW50c1tcIlNVQlRJVExFX1RSQUNLX1VQREFURURcIl0gPSBcImhsc1N1YnRpdGxlVHJhY2tVcGRhdGVkXCI7XG4gIC8vIGZpcmVkIHdoZW4gYSBzdWJ0aXRsZSBmcmFnbWVudCBoYXMgYmVlbiBwcm9jZXNzZWQgLSBkYXRhOiB7IHN1Y2Nlc3MgOiBib29sZWFuLCBmcmFnIDogdGhlIHByb2Nlc3NlZCBmcmFnIH1cbiAgRXZlbnRzW1wiU1VCVElUTEVfRlJBR19QUk9DRVNTRURcIl0gPSBcImhsc1N1YnRpdGxlRnJhZ1Byb2Nlc3NlZFwiO1xuICAvLyBmaXJlZCB3aGVuIGEgc2V0IG9mIFZUVEN1ZXMgdG8gYmUgbWFuYWdlZCBleHRlcm5hbGx5IGhhcyBiZWVuIHBhcnNlZCAtIGRhdGE6IHsgdHlwZTogc3RyaW5nLCB0cmFjazogc3RyaW5nLCBjdWVzOiBbIFZUVEN1ZSBdIH1cbiAgRXZlbnRzW1wiQ1VFU19QQVJTRURcIl0gPSBcImhsc0N1ZXNQYXJzZWRcIjtcbiAgLy8gZmlyZWQgd2hlbiBhIHRleHQgdHJhY2sgdG8gYmUgbWFuYWdlZCBleHRlcm5hbGx5IGlzIGZvdW5kIC0gZGF0YTogeyB0cmFja3M6IFsgeyBsYWJlbDogc3RyaW5nLCBraW5kOiBzdHJpbmcsIGRlZmF1bHQ6IGJvb2xlYW4gfSBdIH1cbiAgRXZlbnRzW1wiTk9OX05BVElWRV9URVhUX1RSQUNLU19GT1VORFwiXSA9IFwiaGxzTm9uTmF0aXZlVGV4dFRyYWNrc0ZvdW5kXCI7XG4gIC8vIGZpcmVkIHdoZW4gdGhlIGZpcnN0IHRpbWVzdGFtcCBpcyBmb3VuZCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBpbml0UFRTOiBpbml0UFRTLCB0aW1lc2NhbGU6IHRpbWVzY2FsZSwgZnJhZyA6IGZyYWdtZW50IG9iamVjdCB9XG4gIEV2ZW50c1tcIklOSVRfUFRTX0ZPVU5EXCJdID0gXCJobHNJbml0UHRzRm91bmRcIjtcbiAgLy8gZmlyZWQgd2hlbiBhIGZyYWdtZW50IGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0IH1cbiAgRXZlbnRzW1wiRlJBR19MT0FESU5HXCJdID0gXCJobHNGcmFnTG9hZGluZ1wiO1xuICAvLyBmaXJlZCB3aGVuIGEgZnJhZ21lbnQgbG9hZGluZyBpcyBwcm9ncmVzc2luZyAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgeyB0cmVxdWVzdCwgdGZpcnN0LCBsb2FkZWQgfSB9XG4gIC8vIEZSQUdfTE9BRF9QUk9HUkVTUyA9ICdobHNGcmFnTG9hZFByb2dyZXNzJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgZnJhZ21lbnQgbG9hZCBhYm9ydGluZyBmb3IgZW1lcmdlbmN5IHN3aXRjaCBkb3duIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0IH1cbiAgRXZlbnRzW1wiRlJBR19MT0FEX0VNRVJHRU5DWV9BQk9SVEVEXCJdID0gXCJobHNGcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWRcIjtcbiAgLy8gZmlyZWQgd2hlbiBhIGZyYWdtZW50IGxvYWRpbmcgaXMgY29tcGxldGVkIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCBwYXlsb2FkIDogZnJhZ21lbnQgcGF5bG9hZCwgc3RhdHMgOiBMb2FkZXJTdGF0cyB9XG4gIEV2ZW50c1tcIkZSQUdfTE9BREVEXCJdID0gXCJobHNGcmFnTG9hZGVkXCI7XG4gIC8vIGZpcmVkIHdoZW4gYSBmcmFnbWVudCBoYXMgZmluaXNoZWQgZGVjcnlwdGluZyAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnOiBmcmFnbWVudCBvYmplY3QsIHBheWxvYWQgOiBmcmFnbWVudCBwYXlsb2FkLCBzdGF0cyA6IHsgdHN0YXJ0LCB0ZGVjcnlwdCB9IH1cbiAgRXZlbnRzW1wiRlJBR19ERUNSWVBURURcIl0gPSBcImhsc0ZyYWdEZWNyeXB0ZWRcIjtcbiAgLy8gZmlyZWQgd2hlbiBJbml0IFNlZ21lbnQgaGFzIGJlZW4gZXh0cmFjdGVkIGZyb20gZnJhZ21lbnQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZzogZnJhZ21lbnQgb2JqZWN0LCBtb292IDogbW9vdiBNUDQgYm94LCBjb2RlY3MgOiBjb2RlY3MgZm91bmQgd2hpbGUgcGFyc2luZyBmcmFnbWVudCB9XG4gIEV2ZW50c1tcIkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlRcIl0gPSBcImhsc0ZyYWdQYXJzaW5nSW5pdFNlZ21lbnRcIjtcbiAgLy8gZmlyZWQgd2hlbiBwYXJzaW5nIHNlaSB0ZXh0IGlzIGNvbXBsZXRlZCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnOiBmcmFnbWVudCBvYmplY3QsIHNhbXBsZXMgOiBbIHNlaSBzYW1wbGVzIHBlcyBdIH1cbiAgRXZlbnRzW1wiRlJBR19QQVJTSU5HX1VTRVJEQVRBXCJdID0gXCJobHNGcmFnUGFyc2luZ1VzZXJkYXRhXCI7XG4gIC8vIGZpcmVkIHdoZW4gcGFyc2luZyBpZDMgaXMgY29tcGxldGVkIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWc6IGZyYWdtZW50IG9iamVjdCwgc2FtcGxlcyA6IFsgaWQzIHNhbXBsZXMgcGVzIF0gfVxuICBFdmVudHNbXCJGUkFHX1BBUlNJTkdfTUVUQURBVEFcIl0gPSBcImhsc0ZyYWdQYXJzaW5nTWV0YWRhdGFcIjtcbiAgLy8gZmlyZWQgd2hlbiBkYXRhIGhhdmUgYmVlbiBleHRyYWN0ZWQgZnJvbSBmcmFnbWVudCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnOiBmcmFnbWVudCBvYmplY3QsIGRhdGExIDogbW9vZiBNUDQgYm94IG9yIFRTIGZyYWdtZW50cywgZGF0YTIgOiBtZGF0IE1QNCBib3ggb3IgbnVsbH1cbiAgLy8gRlJBR19QQVJTSU5HX0RBVEEgPSAnaGxzRnJhZ1BhcnNpbmdEYXRhJyxcbiAgLy8gZmlyZWQgd2hlbiBmcmFnbWVudCBwYXJzaW5nIGlzIGNvbXBsZXRlZCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnOiBmcmFnbWVudCBvYmplY3QgfVxuICBFdmVudHNbXCJGUkFHX1BBUlNFRFwiXSA9IFwiaGxzRnJhZ1BhcnNlZFwiO1xuICAvLyBmaXJlZCB3aGVuIGZyYWdtZW50IHJlbXV4ZWQgTVA0IGJveGVzIGhhdmUgYWxsIGJlZW4gYXBwZW5kZWQgaW50byBTb3VyY2VCdWZmZXIgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgc3RhdHMgOiBMb2FkZXJTdGF0cyB9XG4gIEV2ZW50c1tcIkZSQUdfQlVGRkVSRURcIl0gPSBcImhsc0ZyYWdCdWZmZXJlZFwiO1xuICAvLyBmaXJlZCB3aGVuIGZyYWdtZW50IG1hdGNoaW5nIHdpdGggY3VycmVudCBtZWRpYSBwb3NpdGlvbiBpcyBjaGFuZ2luZyAtIGRhdGEgOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZyA6IGZyYWdtZW50IG9iamVjdCB9XG4gIEV2ZW50c1tcIkZSQUdfQ0hBTkdFRFwiXSA9IFwiaGxzRnJhZ0NoYW5nZWRcIjtcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBGUFMgZHJvcCBldmVudCAtIGRhdGE6IHsgY3VycmVudERyb3BwZWQsIGN1cnJlbnREZWNvZGVkLCB0b3RhbERyb3BwZWRGcmFtZXMgfVxuICBFdmVudHNbXCJGUFNfRFJPUFwiXSA9IFwiaGxzRnBzRHJvcFwiO1xuICAvLyB0cmlnZ2VyZWQgd2hlbiBGUFMgZHJvcCB0cmlnZ2VycyBhdXRvIGxldmVsIGNhcHBpbmcgLSBkYXRhOiB7IGxldmVsLCBkcm9wcGVkTGV2ZWwgfVxuICBFdmVudHNbXCJGUFNfRFJPUF9MRVZFTF9DQVBQSU5HXCJdID0gXCJobHNGcHNEcm9wTGV2ZWxDYXBwaW5nXCI7XG4gIC8vIHRyaWdnZXJlZCB3aGVuIG1heEF1dG9MZXZlbCBjaGFuZ2VzIC0gZGF0YSB7IGF1dG9MZXZlbENhcHBpbmcsIGxldmVscywgbWF4QXV0b0xldmVsLCBtaW5BdXRvTGV2ZWwsIG1heEhkY3BMZXZlbCB9XG4gIEV2ZW50c1tcIk1BWF9BVVRPX0xFVkVMX1VQREFURURcIl0gPSBcImhsc01heEF1dG9MZXZlbFVwZGF0ZWRcIjtcbiAgLy8gSWRlbnRpZmllciBmb3IgYW4gZXJyb3IgZXZlbnQgLSBkYXRhOiB7IHR5cGUgOiBlcnJvciB0eXBlLCBkZXRhaWxzIDogZXJyb3IgZGV0YWlscywgZmF0YWwgOiBpZiB0cnVlLCBobHMuanMgY2Fubm90L3dpbGwgbm90IHRyeSB0byByZWNvdmVyLCBpZiBmYWxzZSwgaGxzLmpzIHdpbGwgdHJ5IHRvIHJlY292ZXIsb3RoZXIgZXJyb3Igc3BlY2lmaWMgZGF0YSB9XG4gIEV2ZW50c1tcIkVSUk9SXCJdID0gXCJobHNFcnJvclwiO1xuICAvLyBmaXJlZCB3aGVuIGhscy5qcyBpbnN0YW5jZSBzdGFydHMgZGVzdHJveWluZy4gRGlmZmVyZW50IGZyb20gTUVESUFfREVUQUNIRUQgYXMgb25lIGNvdWxkIHdhbnQgdG8gZGV0YWNoIGFuZCByZWF0dGFjaCBhIG1lZGlhIHRvIHRoZSBpbnN0YW5jZSBvZiBobHMuanMgdG8gaGFuZGxlIG1pZC1yb2xscyBmb3IgZXhhbXBsZSAtIGRhdGE6IHsgfVxuICBFdmVudHNbXCJERVNUUk9ZSU5HXCJdID0gXCJobHNEZXN0cm95aW5nXCI7XG4gIC8vIGZpcmVkIHdoZW4gYSBkZWNyeXB0IGtleSBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCB9XG4gIEV2ZW50c1tcIktFWV9MT0FESU5HXCJdID0gXCJobHNLZXlMb2FkaW5nXCI7XG4gIC8vIGZpcmVkIHdoZW4gYSBkZWNyeXB0IGtleSBsb2FkaW5nIGlzIGNvbXBsZXRlZCAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwga2V5SW5mbyA6IEtleUxvYWRlckluZm8gfVxuICBFdmVudHNbXCJLRVlfTE9BREVEXCJdID0gXCJobHNLZXlMb2FkZWRcIjtcbiAgLy8gZGVwcmVjYXRlZDsgcGxlYXNlIHVzZSBCQUNLX0JVRkZFUl9SRUFDSEVEIC0gZGF0YSA6IHsgYnVmZmVyRW5kOiBudW1iZXIgfVxuICBFdmVudHNbXCJMSVZFX0JBQ0tfQlVGRkVSX1JFQUNIRURcIl0gPSBcImhsc0xpdmVCYWNrQnVmZmVyUmVhY2hlZFwiO1xuICAvLyBmaXJlZCB3aGVuIHRoZSBiYWNrIGJ1ZmZlciBpcyByZWFjaGVkIGFzIGRlZmluZWQgYnkgdGhlIGJhY2tCdWZmZXJMZW5ndGggY29uZmlnIG9wdGlvbiAtIGRhdGEgOiB7IGJ1ZmZlckVuZDogbnVtYmVyIH1cbiAgRXZlbnRzW1wiQkFDS19CVUZGRVJfUkVBQ0hFRFwiXSA9IFwiaGxzQmFja0J1ZmZlclJlYWNoZWRcIjtcbiAgLy8gZmlyZWQgYWZ0ZXIgc3RlZXJpbmcgbWFuaWZlc3QgaGFzIGJlZW4gbG9hZGVkIC0gZGF0YTogeyBzdGVlcmluZ01hbmlmZXN0OiBTdGVlcmluZ01hbmlmZXN0IG9iamVjdCwgdXJsOiBzdGVlcmluZyBtYW5pZmVzdCBVUkwgfVxuICBFdmVudHNbXCJTVEVFUklOR19NQU5JRkVTVF9MT0FERURcIl0gPSBcImhsc1N0ZWVyaW5nTWFuaWZlc3RMb2FkZWRcIjtcbiAgLy8gZmlyZWQgd2hlbiBhc3NldCBsaXN0IGhhcyBiZWd1biBsb2FkaW5nXG4gIEV2ZW50c1tcIkFTU0VUX0xJU1RfTE9BRElOR1wiXSA9IFwiaGxzQXNzZXRMaXN0TG9hZGluZ1wiO1xuICAvLyBmaXJlZCB3aGVuIGEgdmFsaWQgYXNzZXQgbGlzdCBpcyBsb2FkZWRcbiAgRXZlbnRzW1wiQVNTRVRfTElTVF9MT0FERURcIl0gPSBcImhsc0Fzc2V0TGlzdExvYWRlZFwiO1xuICAvLyBmaXJlZCB3aGVuIHRoZSBsaXN0IG9mIEludGVyc3RpdGlhbCBFdmVudHMgYW5kIEludGVyc3RpdGlhbCBTY2hlZHVsZSBpcyB1cGRhdGVkXG4gIEV2ZW50c1tcIklOVEVSU1RJVElBTFNfVVBEQVRFRFwiXSA9IFwiaGxzSW50ZXJzdGl0aWFsc1VwZGF0ZWRcIjtcbiAgLy8gZmlyZWQgd2hlbiB0aGUgYnVmZmVyIHJlYWNoZXMgYW4gSW50ZXJzdGl0aWFsIFNjaGVkdWxlIGJvdW5kYXJ5IChib3RoIFByaW1hcnkgc2VnbWVudHMgYW5kIEludGVyc3RpdGlhbCBBc3NldHMpXG4gIEV2ZW50c1tcIklOVEVSU1RJVElBTFNfQlVGRkVSRURfVE9fQk9VTkRBUllcIl0gPSBcImhsc0ludGVyc3RpdGlhbHNCdWZmZXJlZFRvQm91bmRhcnlcIjtcbiAgLy8gZmlyZWQgd2hlbiBhIHBsYXllciBpbnN0YW5jZSBmb3IgYW4gSW50ZXJzdGl0aWFsIEFzc2V0IGhhcyBiZWVuIGNyZWF0ZWRcbiAgRXZlbnRzW1wiSU5URVJTVElUSUFMX0FTU0VUX1BMQVlFUl9DUkVBVEVEXCJdID0gXCJobHNJbnRlcnN0aXRpYWxBc3NldFBsYXllckNyZWF0ZWRcIjtcbiAgLy8gSW50ZXJzdGl0aWFsIHBsYXliYWNrIHN0YXJ0ZWRcbiAgRXZlbnRzW1wiSU5URVJTVElUSUFMX1NUQVJURURcIl0gPSBcImhsc0ludGVyc3RpdGlhbFN0YXJ0ZWRcIjtcbiAgLy8gSW50ZXJzdGl0aWFsQXNzZXQgcGxheWJhY2sgc3RhcnRlZFxuICBFdmVudHNbXCJJTlRFUlNUSVRJQUxfQVNTRVRfU1RBUlRFRFwiXSA9IFwiaGxzSW50ZXJzdGl0aWFsQXNzZXRTdGFydGVkXCI7XG4gIC8vIEludGVyc3RpdGlhbEFzc2V0IHBsYXliYWNrIGVuZGVkXG4gIEV2ZW50c1tcIklOVEVSU1RJVElBTF9BU1NFVF9FTkRFRFwiXSA9IFwiaGxzSW50ZXJzdGl0aWFsQXNzZXRFbmRlZFwiO1xuICAvLyBJbnRlcnN0aXRpYWxBc3NldCBwbGF5YmFjayBlcnJvcmVkXG4gIEV2ZW50c1tcIklOVEVSU1RJVElBTF9BU1NFVF9FUlJPUlwiXSA9IFwiaGxzSW50ZXJzdGl0aWFsQXNzZXRFcnJvclwiO1xuICAvLyBJbnRlcnN0aXRpYWwgcGxheWJhY2sgZW5kZWRcbiAgRXZlbnRzW1wiSU5URVJTVElUSUFMX0VOREVEXCJdID0gXCJobHNJbnRlcnN0aXRpYWxFbmRlZFwiO1xuICAvLyBJbnRlcnN0aXRpYWwgc2NoZWR1bGUgcmVzdW1lZCBwcmltYXJ5IHBsYXliYWNrXG4gIEV2ZW50c1tcIklOVEVSU1RJVElBTFNfUFJJTUFSWV9SRVNVTUVEXCJdID0gXCJobHNJbnRlcnN0aXRpYWxzUHJpbWFyeVJlc3VtZWRcIjtcbiAgLy8gSW50ZXJzdGl0aWFsIHBsYXllcnMgZGlzcGF0Y2ggdGhpcyBldmVudCB3aGVuIHBsYXlvdXQgbGltaXQgaXMgcmVhY2hlZFxuICBFdmVudHNbXCJQTEFZT1VUX0xJTUlUX1JFQUNIRURcIl0gPSBcImhsc1BsYXlvdXRMaW1pdFJlYWNoZWRcIjtcbiAgLy8gRXZlbnQgRGF0ZVJhbmdlIGN1ZSBcImVudGVyXCIgZXZlbnQgZGlzcGF0Y2hlZFxuICBFdmVudHNbXCJFVkVOVF9DVUVfRU5URVJcIl0gPSBcImhsc0V2ZW50Q3VlRW50ZXJcIjtcbiAgcmV0dXJuIEV2ZW50cztcbn0oe30pO1xuXG4vKipcbiAqIERlZmluZXMgZWFjaCBFdmVudCB0eXBlIGFuZCBwYXlsb2FkIGJ5IEV2ZW50IG5hbWUuIFVzZWQgaW4ge0BsaW5rIGhscy5qcyNIbHNFdmVudEVtaXR0ZXJ9IHRvIHN0cm9uZ2x5IHR5cGUgdGhlIGV2ZW50IGxpc3RlbmVyIEFQSS5cbiAqL1xuXG52YXIgUGxheWxpc3RDb250ZXh0VHlwZSA9IHtcbiAgTUFOSUZFU1Q6IFwibWFuaWZlc3RcIixcbiAgTEVWRUw6IFwibGV2ZWxcIixcbiAgQVVESU9fVFJBQ0s6IFwiYXVkaW9UcmFja1wiLFxuICBTVUJUSVRMRV9UUkFDSzogXCJzdWJ0aXRsZVRyYWNrXCJcbn07XG52YXIgUGxheWxpc3RMZXZlbFR5cGUgPSB7XG4gIE1BSU46IFwibWFpblwiLFxuICBBVURJTzogXCJhdWRpb1wiLFxuICBTVUJUSVRMRTogXCJzdWJ0aXRsZVwiXG59O1xuXG4vKlxuICogY29tcHV0ZSBhbiBFeHBvbmVudGlhbCBXZWlnaHRlZCBtb3ZpbmcgYXZlcmFnZVxuICogLSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Nb3ZpbmdfYXZlcmFnZSNFeHBvbmVudGlhbF9tb3ZpbmdfYXZlcmFnZVxuICogIC0gaGVhdmlseSBpbnNwaXJlZCBmcm9tIHNoYWthLXBsYXllclxuICovXG5cbmNsYXNzIEVXTUEge1xuICAvLyAgQWJvdXQgaGFsZiBvZiB0aGUgZXN0aW1hdGVkIHZhbHVlIHdpbGwgYmUgZnJvbSB0aGUgbGFzdCB8aGFsZkxpZmV8IHNhbXBsZXMgYnkgd2VpZ2h0LlxuICBjb25zdHJ1Y3RvcihoYWxmTGlmZSwgZXN0aW1hdGUgPSAwLCB3ZWlnaHQgPSAwKSB7XG4gICAgdGhpcy5oYWxmTGlmZSA9IHZvaWQgMDtcbiAgICB0aGlzLmFscGhhXyA9IHZvaWQgMDtcbiAgICB0aGlzLmVzdGltYXRlXyA9IHZvaWQgMDtcbiAgICB0aGlzLnRvdGFsV2VpZ2h0XyA9IHZvaWQgMDtcbiAgICB0aGlzLmhhbGZMaWZlID0gaGFsZkxpZmU7XG4gICAgLy8gTGFyZ2VyIHZhbHVlcyBvZiBhbHBoYSBleHBpcmUgaGlzdG9yaWNhbCBkYXRhIG1vcmUgc2xvd2x5LlxuICAgIHRoaXMuYWxwaGFfID0gaGFsZkxpZmUgPyBNYXRoLmV4cChNYXRoLmxvZygwLjUpIC8gaGFsZkxpZmUpIDogMDtcbiAgICB0aGlzLmVzdGltYXRlXyA9IGVzdGltYXRlO1xuICAgIHRoaXMudG90YWxXZWlnaHRfID0gd2VpZ2h0O1xuICB9XG4gIHNhbXBsZSh3ZWlnaHQsIHZhbHVlKSB7XG4gICAgY29uc3QgYWRqQWxwaGEgPSBNYXRoLnBvdyh0aGlzLmFscGhhXywgd2VpZ2h0KTtcbiAgICB0aGlzLmVzdGltYXRlXyA9IHZhbHVlICogKDEgLSBhZGpBbHBoYSkgKyBhZGpBbHBoYSAqIHRoaXMuZXN0aW1hdGVfO1xuICAgIHRoaXMudG90YWxXZWlnaHRfICs9IHdlaWdodDtcbiAgfVxuICBnZXRUb3RhbFdlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy50b3RhbFdlaWdodF87XG4gIH1cbiAgZ2V0RXN0aW1hdGUoKSB7XG4gICAgaWYgKHRoaXMuYWxwaGFfKSB7XG4gICAgICBjb25zdCB6ZXJvRmFjdG9yID0gMSAtIE1hdGgucG93KHRoaXMuYWxwaGFfLCB0aGlzLnRvdGFsV2VpZ2h0Xyk7XG4gICAgICBpZiAoemVyb0ZhY3Rvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZV8gLyB6ZXJvRmFjdG9yO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZV87XG4gIH1cbn1cblxuLypcbiAqIEVXTUEgQmFuZHdpZHRoIEVzdGltYXRvclxuICogIC0gaGVhdmlseSBpbnNwaXJlZCBmcm9tIHNoYWthLXBsYXllclxuICogVHJhY2tzIGJhbmR3aWR0aCBzYW1wbGVzIGFuZCBlc3RpbWF0ZXMgYXZhaWxhYmxlIGJhbmR3aWR0aC5cbiAqIEJhc2VkIG9uIHRoZSBtaW5pbXVtIG9mIHR3byBleHBvbmVudGlhbGx5LXdlaWdodGVkIG1vdmluZyBhdmVyYWdlcyB3aXRoXG4gKiBkaWZmZXJlbnQgaGFsZi1saXZlcy5cbiAqL1xuXG5jbGFzcyBFd21hQmFuZFdpZHRoRXN0aW1hdG9yIHtcbiAgY29uc3RydWN0b3Ioc2xvdywgZmFzdCwgZGVmYXVsdEVzdGltYXRlLCBkZWZhdWx0VFRGQiA9IDEwMCkge1xuICAgIHRoaXMuZGVmYXVsdEVzdGltYXRlXyA9IHZvaWQgMDtcbiAgICB0aGlzLm1pbldlaWdodF8gPSB2b2lkIDA7XG4gICAgdGhpcy5taW5EZWxheU1zXyA9IHZvaWQgMDtcbiAgICB0aGlzLnNsb3dfID0gdm9pZCAwO1xuICAgIHRoaXMuZmFzdF8gPSB2b2lkIDA7XG4gICAgdGhpcy5kZWZhdWx0VFRGQl8gPSB2b2lkIDA7XG4gICAgdGhpcy50dGZiXyA9IHZvaWQgMDtcbiAgICB0aGlzLmRlZmF1bHRFc3RpbWF0ZV8gPSBkZWZhdWx0RXN0aW1hdGU7XG4gICAgdGhpcy5taW5XZWlnaHRfID0gMC4wMDE7XG4gICAgdGhpcy5taW5EZWxheU1zXyA9IDUwO1xuICAgIHRoaXMuc2xvd18gPSBuZXcgRVdNQShzbG93KTtcbiAgICB0aGlzLmZhc3RfID0gbmV3IEVXTUEoZmFzdCk7XG4gICAgdGhpcy5kZWZhdWx0VFRGQl8gPSBkZWZhdWx0VFRGQjtcbiAgICB0aGlzLnR0ZmJfID0gbmV3IEVXTUEoc2xvdyk7XG4gIH1cbiAgdXBkYXRlKHNsb3csIGZhc3QpIHtcbiAgICBjb25zdCB7XG4gICAgICBzbG93XyxcbiAgICAgIGZhc3RfLFxuICAgICAgdHRmYl9cbiAgICB9ID0gdGhpcztcbiAgICBpZiAoc2xvd18uaGFsZkxpZmUgIT09IHNsb3cpIHtcbiAgICAgIHRoaXMuc2xvd18gPSBuZXcgRVdNQShzbG93LCBzbG93Xy5nZXRFc3RpbWF0ZSgpLCBzbG93Xy5nZXRUb3RhbFdlaWdodCgpKTtcbiAgICB9XG4gICAgaWYgKGZhc3RfLmhhbGZMaWZlICE9PSBmYXN0KSB7XG4gICAgICB0aGlzLmZhc3RfID0gbmV3IEVXTUEoZmFzdCwgZmFzdF8uZ2V0RXN0aW1hdGUoKSwgZmFzdF8uZ2V0VG90YWxXZWlnaHQoKSk7XG4gICAgfVxuICAgIGlmICh0dGZiXy5oYWxmTGlmZSAhPT0gc2xvdykge1xuICAgICAgdGhpcy50dGZiXyA9IG5ldyBFV01BKHNsb3csIHR0ZmJfLmdldEVzdGltYXRlKCksIHR0ZmJfLmdldFRvdGFsV2VpZ2h0KCkpO1xuICAgIH1cbiAgfVxuICBzYW1wbGUoZHVyYXRpb25NcywgbnVtQnl0ZXMpIHtcbiAgICBkdXJhdGlvbk1zID0gTWF0aC5tYXgoZHVyYXRpb25NcywgdGhpcy5taW5EZWxheU1zXyk7XG4gICAgY29uc3QgbnVtQml0cyA9IDggKiBudW1CeXRlcztcbiAgICAvLyB3ZWlnaHQgaXMgZHVyYXRpb24gaW4gc2Vjb25kc1xuICAgIGNvbnN0IGR1cmF0aW9uUyA9IGR1cmF0aW9uTXMgLyAxMDAwO1xuICAgIC8vIHZhbHVlIGlzIGJhbmR3aWR0aCBpbiBiaXRzL3NcbiAgICBjb25zdCBiYW5kd2lkdGhJbkJwcyA9IG51bUJpdHMgLyBkdXJhdGlvblM7XG4gICAgdGhpcy5mYXN0Xy5zYW1wbGUoZHVyYXRpb25TLCBiYW5kd2lkdGhJbkJwcyk7XG4gICAgdGhpcy5zbG93Xy5zYW1wbGUoZHVyYXRpb25TLCBiYW5kd2lkdGhJbkJwcyk7XG4gIH1cbiAgc2FtcGxlVFRGQih0dGZiKSB7XG4gICAgLy8gd2VpZ2h0IGlzIGZyZXF1ZW5jeSBjdXJ2ZSBhcHBsaWVkIHRvIFRURkIgaW4gc2Vjb25kc1xuICAgIC8vIChsb25nZXIgdGltZXMgaGF2ZSBsZXNzIHdlaWdodCB3aXRoIGV4cGVjdGVkIGlucHV0IHVuZGVyIDEgc2Vjb25kKVxuICAgIGNvbnN0IHNlY29uZHMgPSB0dGZiIC8gMTAwMDtcbiAgICBjb25zdCB3ZWlnaHQgPSBNYXRoLnNxcnQoMikgKiBNYXRoLmV4cCgtTWF0aC5wb3coc2Vjb25kcywgMikgLyAyKTtcbiAgICB0aGlzLnR0ZmJfLnNhbXBsZSh3ZWlnaHQsIE1hdGgubWF4KHR0ZmIsIDUpKTtcbiAgfVxuICBjYW5Fc3RpbWF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5mYXN0Xy5nZXRUb3RhbFdlaWdodCgpID49IHRoaXMubWluV2VpZ2h0XztcbiAgfVxuICBnZXRFc3RpbWF0ZSgpIHtcbiAgICBpZiAodGhpcy5jYW5Fc3RpbWF0ZSgpKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnc2xvdyBlc3RpbWF0ZTonKyBNYXRoLnJvdW5kKHRoaXMuc2xvd18uZ2V0RXN0aW1hdGUoKSkpO1xuICAgICAgLy8gY29uc29sZS5sb2coJ2Zhc3QgZXN0aW1hdGU6JysgTWF0aC5yb3VuZCh0aGlzLmZhc3RfLmdldEVzdGltYXRlKCkpKTtcbiAgICAgIC8vIFRha2UgdGhlIG1pbmltdW0gb2YgdGhlc2UgdHdvIGVzdGltYXRlcy4gIFRoaXMgc2hvdWxkIGhhdmUgdGhlIGVmZmVjdCBvZlxuICAgICAgLy8gYWRhcHRpbmcgZG93biBxdWlja2x5LCBidXQgdXAgbW9yZSBzbG93bHkuXG4gICAgICByZXR1cm4gTWF0aC5taW4odGhpcy5mYXN0Xy5nZXRFc3RpbWF0ZSgpLCB0aGlzLnNsb3dfLmdldEVzdGltYXRlKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWZhdWx0RXN0aW1hdGVfO1xuICAgIH1cbiAgfVxuICBnZXRFc3RpbWF0ZVRURkIoKSB7XG4gICAgaWYgKHRoaXMudHRmYl8uZ2V0VG90YWxXZWlnaHQoKSA+PSB0aGlzLm1pbldlaWdodF8pIHtcbiAgICAgIHJldHVybiB0aGlzLnR0ZmJfLmdldEVzdGltYXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRUVEZCXztcbiAgICB9XG4gIH1cbiAgZ2V0IGRlZmF1bHRFc3RpbWF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZhdWx0RXN0aW1hdGVfO1xuICB9XG4gIGRlc3Ryb3koKSB7fVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSwgciwgdCkge1xuICByZXR1cm4gKHIgPSBfdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7XG4gICAgdmFsdWU6IHQsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSkgOiBlW3JdID0gdCwgZTtcbn1cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICByZXR1cm4gX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAobikge1xuICAgIGZvciAodmFyIGUgPSAxOyBlIDwgYXJndW1lbnRzLmxlbmd0aDsgZSsrKSB7XG4gICAgICB2YXIgdCA9IGFyZ3VtZW50c1tlXTtcbiAgICAgIGZvciAodmFyIHIgaW4gdCkgKHt9KS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsIHIpICYmIChuW3JdID0gdFtyXSk7XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9LCBfZXh0ZW5kcy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7XG4gIHZhciB0ID0gT2JqZWN0LmtleXMoZSk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuICAgIHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTtcbiAgICB9KSksIHQucHVzaC5hcHBseSh0LCBvKTtcbiAgfVxuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKGUpIHtcbiAgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHtcbiAgICB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307XG4gICAgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pO1xuICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHtcbiAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHQgfHwgIXQpIHJldHVybiB0O1xuICB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHZvaWQgMCAhPT0gZSkge1xuICAgIHZhciBpID0gZS5jYWxsKHQsIHIpO1xuICAgIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiBpKSByZXR1cm4gaTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTtcbn1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHtcbiAgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7XG4gIHJldHVybiBcInN5bWJvbFwiID09IHR5cGVvZiBpID8gaSA6IGkgKyBcIlwiO1xufVxuXG5jbGFzcyBMb2dnZXIge1xuICBjb25zdHJ1Y3RvcihsYWJlbCwgbG9nZ2VyKSB7XG4gICAgdGhpcy50cmFjZSA9IHZvaWQgMDtcbiAgICB0aGlzLmRlYnVnID0gdm9pZCAwO1xuICAgIHRoaXMubG9nID0gdm9pZCAwO1xuICAgIHRoaXMud2FybiA9IHZvaWQgMDtcbiAgICB0aGlzLmluZm8gPSB2b2lkIDA7XG4gICAgdGhpcy5lcnJvciA9IHZvaWQgMDtcbiAgICBjb25zdCBsYiA9IGBbJHtsYWJlbH1dOmA7XG4gICAgdGhpcy50cmFjZSA9IG5vb3A7XG4gICAgdGhpcy5kZWJ1ZyA9IGxvZ2dlci5kZWJ1Zy5iaW5kKG51bGwsIGxiKTtcbiAgICB0aGlzLmxvZyA9IGxvZ2dlci5sb2cuYmluZChudWxsLCBsYik7XG4gICAgdGhpcy53YXJuID0gbG9nZ2VyLndhcm4uYmluZChudWxsLCBsYik7XG4gICAgdGhpcy5pbmZvID0gbG9nZ2VyLmluZm8uYmluZChudWxsLCBsYik7XG4gICAgdGhpcy5lcnJvciA9IGxvZ2dlci5lcnJvci5iaW5kKG51bGwsIGxiKTtcbiAgfVxufVxuY29uc3Qgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcbmNvbnN0IGZha2VMb2dnZXIgPSB7XG4gIHRyYWNlOiBub29wLFxuICBkZWJ1Zzogbm9vcCxcbiAgbG9nOiBub29wLFxuICB3YXJuOiBub29wLFxuICBpbmZvOiBub29wLFxuICBlcnJvcjogbm9vcFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUxvZ2dlcigpIHtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBmYWtlTG9nZ2VyKTtcbn1cblxuLy8gbGV0IGxhc3RDYWxsVGltZTtcbi8vIGZ1bmN0aW9uIGZvcm1hdE1zZ1dpdGhUaW1lSW5mbyh0eXBlLCBtc2cpIHtcbi8vICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbi8vICAgY29uc3QgZGlmZiA9IGxhc3RDYWxsVGltZSA/ICcrJyArIChub3cgLSBsYXN0Q2FsbFRpbWUpIDogJzAnO1xuLy8gICBsYXN0Q2FsbFRpbWUgPSBub3c7XG4vLyAgIG1zZyA9IChuZXcgRGF0ZShub3cpKS50b0lTT1N0cmluZygpICsgJyB8IFsnICsgIHR5cGUgKyAnXSA+ICcgKyBtc2cgKyAnICggJyArIGRpZmYgKyAnIG1zICknO1xuLy8gICByZXR1cm4gbXNnO1xuLy8gfVxuXG5mdW5jdGlvbiBjb25zb2xlUHJpbnRGbih0eXBlLCBpZCkge1xuICBjb25zdCBmdW5jID0gc2VsZi5jb25zb2xlW3R5cGVdO1xuICByZXR1cm4gZnVuYyA/IGZ1bmMuYmluZChzZWxmLmNvbnNvbGUsIGAke2lkID8gJ1snICsgaWQgKyAnXSAnIDogJyd9WyR7dHlwZX1dID5gKSA6IG5vb3A7XG59XG5mdW5jdGlvbiBnZXRMb2dnZXJGbihrZXksIGRlYnVnQ29uZmlnLCBpZCkge1xuICByZXR1cm4gZGVidWdDb25maWdba2V5XSA/IGRlYnVnQ29uZmlnW2tleV0uYmluZChkZWJ1Z0NvbmZpZykgOiBjb25zb2xlUHJpbnRGbihrZXksIGlkKTtcbn1cbmNvbnN0IGV4cG9ydGVkTG9nZ2VyID0gY3JlYXRlTG9nZ2VyKCk7XG5mdW5jdGlvbiBlbmFibGVMb2dzKGRlYnVnQ29uZmlnLCBjb250ZXh0LCBpZCkge1xuICAvLyBjaGVjayB0aGF0IGNvbnNvbGUgaXMgYXZhaWxhYmxlXG4gIGNvbnN0IG5ld0xvZ2dlciA9IGNyZWF0ZUxvZ2dlcigpO1xuICBpZiAodHlwZW9mIGNvbnNvbGUgPT09ICdvYmplY3QnICYmIGRlYnVnQ29uZmlnID09PSB0cnVlIHx8IHR5cGVvZiBkZWJ1Z0NvbmZpZyA9PT0gJ29iamVjdCcpIHtcbiAgICBjb25zdCBrZXlzID0gW1xuICAgIC8vIFJlbW92ZSBvdXQgZnJvbSBsaXN0IGhlcmUgdG8gaGFyZC1kaXNhYmxlIGEgbG9nLWxldmVsXG4gICAgLy8gJ3RyYWNlJyxcbiAgICAnZGVidWcnLCAnbG9nJywgJ2luZm8nLCAnd2FybicsICdlcnJvciddO1xuICAgIGtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgbmV3TG9nZ2VyW2tleV0gPSBnZXRMb2dnZXJGbihrZXksIGRlYnVnQ29uZmlnLCBpZCk7XG4gICAgfSk7XG4gICAgLy8gU29tZSBicm93c2VycyBkb24ndCBhbGxvdyB0byB1c2UgYmluZCBvbiBjb25zb2xlIG9iamVjdCBhbnl3YXlcbiAgICAvLyBmYWxsYmFjayB0byBkZWZhdWx0IGlmIG5lZWRlZFxuICAgIHRyeSB7XG4gICAgICBuZXdMb2dnZXIubG9nKGBEZWJ1ZyBsb2dzIGVuYWJsZWQgZm9yIFwiJHtjb250ZXh0fVwiIGluIGhscy5qcyB2ZXJzaW9uICR7XCIxLjYuN1wifWApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8qIGxvZyBmbiB0aHJldyBhbiBleGNlcHRpb24uIEFsbCBsb2dnZXIgbWV0aG9kcyBhcmUgbm8tb3BzLiAqL1xuICAgICAgcmV0dXJuIGNyZWF0ZUxvZ2dlcigpO1xuICAgIH1cbiAgICAvLyBnbG9iYWwgZXhwb3J0ZWQgbG9nZ2VyIHVzZXMgdGhlIHNhbWUgZnVuY3Rpb25zIGFzIG5ldyBsb2dnZXIgd2l0aG91dCBgaWRgXG4gICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBleHBvcnRlZExvZ2dlcltrZXldID0gZ2V0TG9nZ2VyRm4oa2V5LCBkZWJ1Z0NvbmZpZyk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gUmVzZXQgZ2xvYmFsIGV4cG9ydGVkIGxvZ2dlclxuICAgIF9leHRlbmRzKGV4cG9ydGVkTG9nZ2VyLCBuZXdMb2dnZXIpO1xuICB9XG4gIHJldHVybiBuZXdMb2dnZXI7XG59XG5jb25zdCBsb2dnZXIgPSBleHBvcnRlZExvZ2dlcjtcblxuZnVuY3Rpb24gZ2V0TWVkaWFTb3VyY2UocHJlZmVyTWFuYWdlZE1lZGlhU291cmNlID0gdHJ1ZSkge1xuICBpZiAodHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gdW5kZWZpbmVkO1xuICBjb25zdCBtbXMgPSAocHJlZmVyTWFuYWdlZE1lZGlhU291cmNlIHx8ICFzZWxmLk1lZGlhU291cmNlKSAmJiBzZWxmLk1hbmFnZWRNZWRpYVNvdXJjZTtcbiAgcmV0dXJuIG1tcyB8fCBzZWxmLk1lZGlhU291cmNlIHx8IHNlbGYuV2ViS2l0TWVkaWFTb3VyY2U7XG59XG5mdW5jdGlvbiBpc01hbmFnZWRNZWRpYVNvdXJjZShzb3VyY2UpIHtcbiAgcmV0dXJuIHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzb3VyY2UgPT09IHNlbGYuTWFuYWdlZE1lZGlhU291cmNlO1xufVxuZnVuY3Rpb24gaXNDb21wYXRpYmxlVHJhY2tDaGFuZ2UoY3VycmVudFRyYWNrcywgcmVxdWlyZWRUcmFja3MpIHtcbiAgY29uc3QgdHJhY2tOYW1lcyA9IE9iamVjdC5rZXlzKGN1cnJlbnRUcmFja3MpO1xuICBjb25zdCByZXF1aXJlZFRyYWNrTmFtZXMgPSBPYmplY3Qua2V5cyhyZXF1aXJlZFRyYWNrcyk7XG4gIGNvbnN0IHRyYWNrQ291bnQgPSB0cmFja05hbWVzLmxlbmd0aDtcbiAgY29uc3QgcmVxdWlyZWRUcmFja0NvdW50ID0gcmVxdWlyZWRUcmFja05hbWVzLmxlbmd0aDtcbiAgcmV0dXJuICF0cmFja0NvdW50IHx8ICFyZXF1aXJlZFRyYWNrQ291bnQgfHwgdHJhY2tDb3VudCA9PT0gcmVxdWlyZWRUcmFja0NvdW50ICYmICF0cmFja05hbWVzLnNvbWUobmFtZSA9PiByZXF1aXJlZFRyYWNrTmFtZXMuaW5kZXhPZihuYW1lKSA9PT0gLTEpO1xufVxuXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg5MzY5ODQvdWludDhhcnJheS10by1zdHJpbmctaW4tamF2YXNjcmlwdC8yMjM3MzE5N1xuLy8gaHR0cDovL3d3dy5vbmljb3MuY29tL3N0YWZmL2l6L2FtdXNlL2phdmFzY3JpcHQvZXhwZXJ0L3V0Zi50eHRcbi8qIHV0Zi5qcyAtIFVURi04IDw9PiBVVEYtMTYgY29udmVydGlvblxuICpcbiAqIENvcHlyaWdodCAoQykgMTk5OSBNYXNhbmFvIEl6dW1vIDxpekBvbmljb3MuY28uanA+XG4gKiBWZXJzaW9uOiAxLjBcbiAqIExhc3RNb2RpZmllZDogRGVjIDI1IDE5OTlcbiAqIFRoaXMgbGlicmFyeSBpcyBmcmVlLiAgWW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdC5cbiAqL1xuLyoqXG4gKiBDb252ZXJ0cyBhIFVURi04IGFycmF5IHRvIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBhcnJheSAtIFRoZSBVVEYtOCBhcnJheSB0byBjb252ZXJ0XG4gKlxuICogQHJldHVybnMgVGhlIHN0cmluZ1xuICpcbiAqIEBncm91cCBVdGlsc1xuICpcbiAqIEBiZXRhXG4gKi9cbmZ1bmN0aW9uIHV0ZjhBcnJheVRvU3RyKGFycmF5LCBleGl0T25OdWxsID0gZmFsc2UpIHtcbiAgaWYgKHR5cGVvZiBUZXh0RGVjb2RlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcpO1xuICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGVyLmRlY29kZShhcnJheSk7XG4gICAgaWYgKGV4aXRPbk51bGwpIHtcbiAgICAgIC8vIGdyYWIgdXAgdG8gdGhlIGZpcnN0IG51bGxcbiAgICAgIGNvbnN0IGlkeCA9IGRlY29kZWQuaW5kZXhPZignXFwwJyk7XG4gICAgICByZXR1cm4gaWR4ICE9PSAtMSA/IGRlY29kZWQuc3Vic3RyaW5nKDAsIGlkeCkgOiBkZWNvZGVkO1xuICAgIH1cbiAgICAvLyByZW1vdmUgYW55IG51bGwgY2hhcmFjdGVyc1xuICAgIHJldHVybiBkZWNvZGVkLnJlcGxhY2UoL1xcMC9nLCAnJyk7XG4gIH1cbiAgY29uc3QgbGVuID0gYXJyYXkubGVuZ3RoO1xuICBsZXQgYztcbiAgbGV0IGNoYXIyO1xuICBsZXQgY2hhcjM7XG4gIGxldCBvdXQgPSAnJztcbiAgbGV0IGkgPSAwO1xuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIGMgPSBhcnJheVtpKytdO1xuICAgIGlmIChjID09PSAweDAwICYmIGV4aXRPbk51bGwpIHtcbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfSBlbHNlIGlmIChjID09PSAweDAwIHx8IGMgPT09IDB4MDMpIHtcbiAgICAgIC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgMyAoRU5EX09GX1RFWFQpIG9yIDAgKE5VTEwpIHRoZW4gc2tpcCBpdFxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHN3aXRjaCAoYyA+PiA0KSB7XG4gICAgICBjYXNlIDA6XG4gICAgICBjYXNlIDE6XG4gICAgICBjYXNlIDI6XG4gICAgICBjYXNlIDM6XG4gICAgICBjYXNlIDQ6XG4gICAgICBjYXNlIDU6XG4gICAgICBjYXNlIDY6XG4gICAgICBjYXNlIDc6XG4gICAgICAgIC8vIDB4eHh4eHh4XG4gICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI6XG4gICAgICBjYXNlIDEzOlxuICAgICAgICAvLyAxMTB4IHh4eHggICAxMHh4IHh4eHhcbiAgICAgICAgY2hhcjIgPSBhcnJheVtpKytdO1xuICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyAmIDB4MWYpIDw8IDYgfCBjaGFyMiAmIDB4M2YpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTQ6XG4gICAgICAgIC8vIDExMTAgeHh4eCAgMTB4eCB4eHh4ICAxMHh4IHh4eHhcbiAgICAgICAgY2hhcjIgPSBhcnJheVtpKytdO1xuICAgICAgICBjaGFyMyA9IGFycmF5W2krK107XG4gICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgMHgwZikgPDwgMTIgfCAoY2hhcjIgJiAweDNmKSA8PCA2IHwgKGNoYXIzICYgMHgzZikgPDwgMCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqICBoZXggZHVtcCBoZWxwZXIgY2xhc3NcbiAqL1xuXG5jb25zdCBIZXggPSB7XG4gIGhleER1bXA6IGZ1bmN0aW9uIChhcnJheSkge1xuICAgIGxldCBzdHIgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgaCA9IGFycmF5W2ldLnRvU3RyaW5nKDE2KTtcbiAgICAgIGlmIChoLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgaCA9ICcwJyArIGg7XG4gICAgICB9XG4gICAgICBzdHIgKz0gaDtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufTtcbmZ1bmN0aW9uIGhleFRvQXJyYXlCdWZmZXIoc3RyKSB7XG4gIHJldHVybiBVaW50OEFycmF5LmZyb20oc3RyLnJlcGxhY2UoL14weC8sICcnKS5yZXBsYWNlKC8oW1xcZGEtZkEtRl17Mn0pID8vZywgJzB4JDEgJykucmVwbGFjZSgvICskLywgJycpLnNwbGl0KCcgJykpLmJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMgKHgpIHtcblx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcbn1cblxudmFyIHVybFRvb2xraXQgPSB7ZXhwb3J0czoge319O1xuXG52YXIgaGFzUmVxdWlyZWRVcmxUb29sa2l0O1xuXG5mdW5jdGlvbiByZXF1aXJlVXJsVG9vbGtpdCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZFVybFRvb2xraXQpIHJldHVybiB1cmxUb29sa2l0LmV4cG9ydHM7XG5cdGhhc1JlcXVpcmVkVXJsVG9vbGtpdCA9IDE7XG5cdChmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFx0Ly8gc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMxODA4XG5cblx0XHQoZnVuY3Rpb24gKHJvb3QpIHtcblx0XHQgIHZhciBVUkxfUkVHRVggPVxuXHRcdCAgICAvXig/PSgoPzpbYS16QS1aMC05K1xcLS5dKzopPykpXFwxKD89KCg/OlxcL1xcL1teXFwvPyNdKik/KSlcXDIoPz0oKD86KD86W14/I1xcL10qXFwvKSpbXjs/I1xcL10qKT8pKVxcMygoPzo7W14/I10qKT8pKFxcP1teI10qKT8oI1teXSopPyQvO1xuXHRcdCAgdmFyIEZJUlNUX1NFR01FTlRfUkVHRVggPSAvXig/PShbXlxcLz8jXSopKVxcMShbXl0qKSQvO1xuXHRcdCAgdmFyIFNMQVNIX0RPVF9SRUdFWCA9IC8oPzpcXC98XilcXC4oPz1cXC8pL2c7XG5cdFx0ICB2YXIgU0xBU0hfRE9UX0RPVF9SRUdFWCA9IC8oPzpcXC98XilcXC5cXC5cXC8oPyFcXC5cXC5cXC8pW15cXC9dKig/PVxcLykvZztcblxuXHRcdCAgdmFyIFVSTFRvb2xraXQgPSB7XG5cdFx0ICAgIC8vIElmIG9wdHMuYWx3YXlzTm9ybWFsaXplIGlzIHRydWUgdGhlbiB0aGUgcGF0aCB3aWxsIGFsd2F5cyBiZSBub3JtYWxpemVkIGV2ZW4gd2hlbiBpdCBzdGFydHMgd2l0aCAvIG9yIC8vXG5cdFx0ICAgIC8vIEUuZ1xuXHRcdCAgICAvLyBXaXRoIG9wdHMuYWx3YXlzTm9ybWFsaXplID0gZmFsc2UgKGRlZmF1bHQsIHNwZWMgY29tcGxpYW50KVxuXHRcdCAgICAvLyBodHRwOi8vYS5jb20vYi9jZCArIC9lL2YvLi4vZyA9PiBodHRwOi8vYS5jb20vZS9mLy4uL2dcblx0XHQgICAgLy8gV2l0aCBvcHRzLmFsd2F5c05vcm1hbGl6ZSA9IHRydWUgKG5vdCBzcGVjIGNvbXBsaWFudClcblx0XHQgICAgLy8gaHR0cDovL2EuY29tL2IvY2QgKyAvZS9mLy4uL2cgPT4gaHR0cDovL2EuY29tL2UvZ1xuXHRcdCAgICBidWlsZEFic29sdXRlVVJMOiBmdW5jdGlvbiAoYmFzZVVSTCwgcmVsYXRpdmVVUkwsIG9wdHMpIHtcblx0XHQgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcblx0XHQgICAgICAvLyByZW1vdmUgYW55IHJlbWFpbmluZyBzcGFjZSBhbmQgQ1JMRlxuXHRcdCAgICAgIGJhc2VVUkwgPSBiYXNlVVJMLnRyaW0oKTtcblx0XHQgICAgICByZWxhdGl2ZVVSTCA9IHJlbGF0aXZlVVJMLnRyaW0oKTtcblx0XHQgICAgICBpZiAoIXJlbGF0aXZlVVJMKSB7XG5cdFx0ICAgICAgICAvLyAyYSkgSWYgdGhlIGVtYmVkZGVkIFVSTCBpcyBlbnRpcmVseSBlbXB0eSwgaXQgaW5oZXJpdHMgdGhlXG5cdFx0ICAgICAgICAvLyBlbnRpcmUgYmFzZSBVUkwgKGkuZS4sIGlzIHNldCBlcXVhbCB0byB0aGUgYmFzZSBVUkwpXG5cdFx0ICAgICAgICAvLyBhbmQgd2UgYXJlIGRvbmUuXG5cdFx0ICAgICAgICBpZiAoIW9wdHMuYWx3YXlzTm9ybWFsaXplKSB7XG5cdFx0ICAgICAgICAgIHJldHVybiBiYXNlVVJMO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgdmFyIGJhc2VQYXJ0c0Zvck5vcm1hbGlzZSA9IFVSTFRvb2xraXQucGFyc2VVUkwoYmFzZVVSTCk7XG5cdFx0ICAgICAgICBpZiAoIWJhc2VQYXJ0c0Zvck5vcm1hbGlzZSkge1xuXHRcdCAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIHRyeWluZyB0byBwYXJzZSBiYXNlIFVSTC4nKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGJhc2VQYXJ0c0Zvck5vcm1hbGlzZS5wYXRoID0gVVJMVG9vbGtpdC5ub3JtYWxpemVQYXRoKFxuXHRcdCAgICAgICAgICBiYXNlUGFydHNGb3JOb3JtYWxpc2UucGF0aFxuXHRcdCAgICAgICAgKTtcblx0XHQgICAgICAgIHJldHVybiBVUkxUb29sa2l0LmJ1aWxkVVJMRnJvbVBhcnRzKGJhc2VQYXJ0c0Zvck5vcm1hbGlzZSk7XG5cdFx0ICAgICAgfVxuXHRcdCAgICAgIHZhciByZWxhdGl2ZVBhcnRzID0gVVJMVG9vbGtpdC5wYXJzZVVSTChyZWxhdGl2ZVVSTCk7XG5cdFx0ICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzKSB7XG5cdFx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIHRyeWluZyB0byBwYXJzZSByZWxhdGl2ZSBVUkwuJyk7XG5cdFx0ICAgICAgfVxuXHRcdCAgICAgIGlmIChyZWxhdGl2ZVBhcnRzLnNjaGVtZSkge1xuXHRcdCAgICAgICAgLy8gMmIpIElmIHRoZSBlbWJlZGRlZCBVUkwgc3RhcnRzIHdpdGggYSBzY2hlbWUgbmFtZSwgaXQgaXNcblx0XHQgICAgICAgIC8vIGludGVycHJldGVkIGFzIGFuIGFic29sdXRlIFVSTCBhbmQgd2UgYXJlIGRvbmUuXG5cdFx0ICAgICAgICBpZiAoIW9wdHMuYWx3YXlzTm9ybWFsaXplKSB7XG5cdFx0ICAgICAgICAgIHJldHVybiByZWxhdGl2ZVVSTDtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJlbGF0aXZlUGFydHMucGF0aCA9IFVSTFRvb2xraXQubm9ybWFsaXplUGF0aChyZWxhdGl2ZVBhcnRzLnBhdGgpO1xuXHRcdCAgICAgICAgcmV0dXJuIFVSTFRvb2xraXQuYnVpbGRVUkxGcm9tUGFydHMocmVsYXRpdmVQYXJ0cyk7XG5cdFx0ICAgICAgfVxuXHRcdCAgICAgIHZhciBiYXNlUGFydHMgPSBVUkxUb29sa2l0LnBhcnNlVVJMKGJhc2VVUkwpO1xuXHRcdCAgICAgIGlmICghYmFzZVBhcnRzKSB7XG5cdFx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIHRyeWluZyB0byBwYXJzZSBiYXNlIFVSTC4nKTtcblx0XHQgICAgICB9XG5cdFx0ICAgICAgaWYgKCFiYXNlUGFydHMubmV0TG9jICYmIGJhc2VQYXJ0cy5wYXRoICYmIGJhc2VQYXJ0cy5wYXRoWzBdICE9PSAnLycpIHtcblx0XHQgICAgICAgIC8vIElmIG5ldExvYyBtaXNzaW5nIGFuZCBwYXRoIGRvZXNuJ3Qgc3RhcnQgd2l0aCAnLycsIGFzc3VtZSBldmVydGhpbmcgYmVmb3JlIHRoZSBmaXJzdCAnLycgaXMgdGhlIG5ldExvY1xuXHRcdCAgICAgICAgLy8gVGhpcyBjYXVzZXMgJ2V4YW1wbGUuY29tL2EnIHRvIGJlIGhhbmRsZWQgYXMgJy8vZXhhbXBsZS5jb20vYScgaW5zdGVhZCBvZiAnL2V4YW1wbGUuY29tL2EnXG5cdFx0ICAgICAgICB2YXIgcGF0aFBhcnRzID0gRklSU1RfU0VHTUVOVF9SRUdFWC5leGVjKGJhc2VQYXJ0cy5wYXRoKTtcblx0XHQgICAgICAgIGJhc2VQYXJ0cy5uZXRMb2MgPSBwYXRoUGFydHNbMV07XG5cdFx0ICAgICAgICBiYXNlUGFydHMucGF0aCA9IHBhdGhQYXJ0c1syXTtcblx0XHQgICAgICB9XG5cdFx0ICAgICAgaWYgKGJhc2VQYXJ0cy5uZXRMb2MgJiYgIWJhc2VQYXJ0cy5wYXRoKSB7XG5cdFx0ICAgICAgICBiYXNlUGFydHMucGF0aCA9ICcvJztcblx0XHQgICAgICB9XG5cdFx0ICAgICAgdmFyIGJ1aWx0UGFydHMgPSB7XG5cdFx0ICAgICAgICAvLyAyYykgT3RoZXJ3aXNlLCB0aGUgZW1iZWRkZWQgVVJMIGluaGVyaXRzIHRoZSBzY2hlbWUgb2Zcblx0XHQgICAgICAgIC8vIHRoZSBiYXNlIFVSTC5cblx0XHQgICAgICAgIHNjaGVtZTogYmFzZVBhcnRzLnNjaGVtZSxcblx0XHQgICAgICAgIG5ldExvYzogcmVsYXRpdmVQYXJ0cy5uZXRMb2MsXG5cdFx0ICAgICAgICBwYXRoOiBudWxsLFxuXHRcdCAgICAgICAgcGFyYW1zOiByZWxhdGl2ZVBhcnRzLnBhcmFtcyxcblx0XHQgICAgICAgIHF1ZXJ5OiByZWxhdGl2ZVBhcnRzLnF1ZXJ5LFxuXHRcdCAgICAgICAgZnJhZ21lbnQ6IHJlbGF0aXZlUGFydHMuZnJhZ21lbnQsXG5cdFx0ICAgICAgfTtcblx0XHQgICAgICBpZiAoIXJlbGF0aXZlUGFydHMubmV0TG9jKSB7XG5cdFx0ICAgICAgICAvLyAzKSBJZiB0aGUgZW1iZWRkZWQgVVJMJ3MgPG5ldF9sb2M+IGlzIG5vbi1lbXB0eSwgd2Ugc2tpcCB0b1xuXHRcdCAgICAgICAgLy8gU3RlcCA3LiAgT3RoZXJ3aXNlLCB0aGUgZW1iZWRkZWQgVVJMIGluaGVyaXRzIHRoZSA8bmV0X2xvYz5cblx0XHQgICAgICAgIC8vIChpZiBhbnkpIG9mIHRoZSBiYXNlIFVSTC5cblx0XHQgICAgICAgIGJ1aWx0UGFydHMubmV0TG9jID0gYmFzZVBhcnRzLm5ldExvYztcblx0XHQgICAgICAgIC8vIDQpIElmIHRoZSBlbWJlZGRlZCBVUkwgcGF0aCBpcyBwcmVjZWRlZCBieSBhIHNsYXNoIFwiL1wiLCB0aGVcblx0XHQgICAgICAgIC8vIHBhdGggaXMgbm90IHJlbGF0aXZlIGFuZCB3ZSBza2lwIHRvIFN0ZXAgNy5cblx0XHQgICAgICAgIGlmIChyZWxhdGl2ZVBhcnRzLnBhdGhbMF0gIT09ICcvJykge1xuXHRcdCAgICAgICAgICBpZiAoIXJlbGF0aXZlUGFydHMucGF0aCkge1xuXHRcdCAgICAgICAgICAgIC8vIDUpIElmIHRoZSBlbWJlZGRlZCBVUkwgcGF0aCBpcyBlbXB0eSAoYW5kIG5vdCBwcmVjZWRlZCBieSBhXG5cdFx0ICAgICAgICAgICAgLy8gc2xhc2gpLCB0aGVuIHRoZSBlbWJlZGRlZCBVUkwgaW5oZXJpdHMgdGhlIGJhc2UgVVJMIHBhdGhcblx0XHQgICAgICAgICAgICBidWlsdFBhcnRzLnBhdGggPSBiYXNlUGFydHMucGF0aDtcblx0XHQgICAgICAgICAgICAvLyA1YSkgaWYgdGhlIGVtYmVkZGVkIFVSTCdzIDxwYXJhbXM+IGlzIG5vbi1lbXB0eSwgd2Ugc2tpcCB0b1xuXHRcdCAgICAgICAgICAgIC8vIHN0ZXAgNzsgb3RoZXJ3aXNlLCBpdCBpbmhlcml0cyB0aGUgPHBhcmFtcz4gb2YgdGhlIGJhc2Vcblx0XHQgICAgICAgICAgICAvLyBVUkwgKGlmIGFueSkgYW5kXG5cdFx0ICAgICAgICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzLnBhcmFtcykge1xuXHRcdCAgICAgICAgICAgICAgYnVpbHRQYXJ0cy5wYXJhbXMgPSBiYXNlUGFydHMucGFyYW1zO1xuXHRcdCAgICAgICAgICAgICAgLy8gNWIpIGlmIHRoZSBlbWJlZGRlZCBVUkwncyA8cXVlcnk+IGlzIG5vbi1lbXB0eSwgd2Ugc2tpcCB0b1xuXHRcdCAgICAgICAgICAgICAgLy8gc3RlcCA3OyBvdGhlcndpc2UsIGl0IGluaGVyaXRzIHRoZSA8cXVlcnk+IG9mIHRoZSBiYXNlXG5cdFx0ICAgICAgICAgICAgICAvLyBVUkwgKGlmIGFueSkgYW5kIHdlIHNraXAgdG8gc3RlcCA3LlxuXHRcdCAgICAgICAgICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzLnF1ZXJ5KSB7XG5cdFx0ICAgICAgICAgICAgICAgIGJ1aWx0UGFydHMucXVlcnkgPSBiYXNlUGFydHMucXVlcnk7XG5cdFx0ICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICB9IGVsc2Uge1xuXHRcdCAgICAgICAgICAgIC8vIDYpIFRoZSBsYXN0IHNlZ21lbnQgb2YgdGhlIGJhc2UgVVJMJ3MgcGF0aCAoYW55dGhpbmdcblx0XHQgICAgICAgICAgICAvLyBmb2xsb3dpbmcgdGhlIHJpZ2h0bW9zdCBzbGFzaCBcIi9cIiwgb3IgdGhlIGVudGlyZSBwYXRoIGlmIG5vXG5cdFx0ICAgICAgICAgICAgLy8gc2xhc2ggaXMgcHJlc2VudCkgaXMgcmVtb3ZlZCBhbmQgdGhlIGVtYmVkZGVkIFVSTCdzIHBhdGggaXNcblx0XHQgICAgICAgICAgICAvLyBhcHBlbmRlZCBpbiBpdHMgcGxhY2UuXG5cdFx0ICAgICAgICAgICAgdmFyIGJhc2VVUkxQYXRoID0gYmFzZVBhcnRzLnBhdGg7XG5cdFx0ICAgICAgICAgICAgdmFyIG5ld1BhdGggPVxuXHRcdCAgICAgICAgICAgICAgYmFzZVVSTFBhdGguc3Vic3RyaW5nKDAsIGJhc2VVUkxQYXRoLmxhc3RJbmRleE9mKCcvJykgKyAxKSArXG5cdFx0ICAgICAgICAgICAgICByZWxhdGl2ZVBhcnRzLnBhdGg7XG5cdFx0ICAgICAgICAgICAgYnVpbHRQYXJ0cy5wYXRoID0gVVJMVG9vbGtpdC5ub3JtYWxpemVQYXRoKG5ld1BhdGgpO1xuXHRcdCAgICAgICAgICB9XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgfVxuXHRcdCAgICAgIGlmIChidWlsdFBhcnRzLnBhdGggPT09IG51bGwpIHtcblx0XHQgICAgICAgIGJ1aWx0UGFydHMucGF0aCA9IG9wdHMuYWx3YXlzTm9ybWFsaXplXG5cdFx0ICAgICAgICAgID8gVVJMVG9vbGtpdC5ub3JtYWxpemVQYXRoKHJlbGF0aXZlUGFydHMucGF0aClcblx0XHQgICAgICAgICAgOiByZWxhdGl2ZVBhcnRzLnBhdGg7XG5cdFx0ICAgICAgfVxuXHRcdCAgICAgIHJldHVybiBVUkxUb29sa2l0LmJ1aWxkVVJMRnJvbVBhcnRzKGJ1aWx0UGFydHMpO1xuXHRcdCAgICB9LFxuXHRcdCAgICBwYXJzZVVSTDogZnVuY3Rpb24gKHVybCkge1xuXHRcdCAgICAgIHZhciBwYXJ0cyA9IFVSTF9SRUdFWC5leGVjKHVybCk7XG5cdFx0ICAgICAgaWYgKCFwYXJ0cykge1xuXHRcdCAgICAgICAgcmV0dXJuIG51bGw7XG5cdFx0ICAgICAgfVxuXHRcdCAgICAgIHJldHVybiB7XG5cdFx0ICAgICAgICBzY2hlbWU6IHBhcnRzWzFdIHx8ICcnLFxuXHRcdCAgICAgICAgbmV0TG9jOiBwYXJ0c1syXSB8fCAnJyxcblx0XHQgICAgICAgIHBhdGg6IHBhcnRzWzNdIHx8ICcnLFxuXHRcdCAgICAgICAgcGFyYW1zOiBwYXJ0c1s0XSB8fCAnJyxcblx0XHQgICAgICAgIHF1ZXJ5OiBwYXJ0c1s1XSB8fCAnJyxcblx0XHQgICAgICAgIGZyYWdtZW50OiBwYXJ0c1s2XSB8fCAnJyxcblx0XHQgICAgICB9O1xuXHRcdCAgICB9LFxuXHRcdCAgICBub3JtYWxpemVQYXRoOiBmdW5jdGlvbiAocGF0aCkge1xuXHRcdCAgICAgIC8vIFRoZSBmb2xsb3dpbmcgb3BlcmF0aW9ucyBhcmVcblx0XHQgICAgICAvLyB0aGVuIGFwcGxpZWQsIGluIG9yZGVyLCB0byB0aGUgbmV3IHBhdGg6XG5cdFx0ICAgICAgLy8gNmEpIEFsbCBvY2N1cnJlbmNlcyBvZiBcIi4vXCIsIHdoZXJlIFwiLlwiIGlzIGEgY29tcGxldGUgcGF0aFxuXHRcdCAgICAgIC8vIHNlZ21lbnQsIGFyZSByZW1vdmVkLlxuXHRcdCAgICAgIC8vIDZiKSBJZiB0aGUgcGF0aCBlbmRzIHdpdGggXCIuXCIgYXMgYSBjb21wbGV0ZSBwYXRoIHNlZ21lbnQsXG5cdFx0ICAgICAgLy8gdGhhdCBcIi5cIiBpcyByZW1vdmVkLlxuXHRcdCAgICAgIHBhdGggPSBwYXRoLnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJykucmVwbGFjZShTTEFTSF9ET1RfUkVHRVgsICcnKTtcblx0XHQgICAgICAvLyA2YykgQWxsIG9jY3VycmVuY2VzIG9mIFwiPHNlZ21lbnQ+Ly4uL1wiLCB3aGVyZSA8c2VnbWVudD4gaXMgYVxuXHRcdCAgICAgIC8vIGNvbXBsZXRlIHBhdGggc2VnbWVudCBub3QgZXF1YWwgdG8gXCIuLlwiLCBhcmUgcmVtb3ZlZC5cblx0XHQgICAgICAvLyBSZW1vdmFsIG9mIHRoZXNlIHBhdGggc2VnbWVudHMgaXMgcGVyZm9ybWVkIGl0ZXJhdGl2ZWx5LFxuXHRcdCAgICAgIC8vIHJlbW92aW5nIHRoZSBsZWZ0bW9zdCBtYXRjaGluZyBwYXR0ZXJuIG9uIGVhY2ggaXRlcmF0aW9uLFxuXHRcdCAgICAgIC8vIHVudGlsIG5vIG1hdGNoaW5nIHBhdHRlcm4gcmVtYWlucy5cblx0XHQgICAgICAvLyA2ZCkgSWYgdGhlIHBhdGggZW5kcyB3aXRoIFwiPHNlZ21lbnQ+Ly4uXCIsIHdoZXJlIDxzZWdtZW50PiBpcyBhXG5cdFx0ICAgICAgLy8gY29tcGxldGUgcGF0aCBzZWdtZW50IG5vdCBlcXVhbCB0byBcIi4uXCIsIHRoYXRcblx0XHQgICAgICAvLyBcIjxzZWdtZW50Pi8uLlwiIGlzIHJlbW92ZWQuXG5cdFx0ICAgICAgd2hpbGUgKFxuXHRcdCAgICAgICAgcGF0aC5sZW5ndGggIT09IChwYXRoID0gcGF0aC5yZXBsYWNlKFNMQVNIX0RPVF9ET1RfUkVHRVgsICcnKSkubGVuZ3RoXG5cdFx0ICAgICAgKSB7fVxuXHRcdCAgICAgIHJldHVybiBwYXRoLnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJyk7XG5cdFx0ICAgIH0sXG5cdFx0ICAgIGJ1aWxkVVJMRnJvbVBhcnRzOiBmdW5jdGlvbiAocGFydHMpIHtcblx0XHQgICAgICByZXR1cm4gKFxuXHRcdCAgICAgICAgcGFydHMuc2NoZW1lICtcblx0XHQgICAgICAgIHBhcnRzLm5ldExvYyArXG5cdFx0ICAgICAgICBwYXJ0cy5wYXRoICtcblx0XHQgICAgICAgIHBhcnRzLnBhcmFtcyArXG5cdFx0ICAgICAgICBwYXJ0cy5xdWVyeSArXG5cdFx0ICAgICAgICBwYXJ0cy5mcmFnbWVudFxuXHRcdCAgICAgICk7XG5cdFx0ICAgIH0sXG5cdFx0ICB9O1xuXG5cdFx0ICBtb2R1bGUuZXhwb3J0cyA9IFVSTFRvb2xraXQ7XG5cdFx0fSkoKTsgXG5cdH0gKHVybFRvb2xraXQpKTtcblx0cmV0dXJuIHVybFRvb2xraXQuZXhwb3J0cztcbn1cblxudmFyIHVybFRvb2xraXRFeHBvcnRzID0gcmVxdWlyZVVybFRvb2xraXQoKTtcblxuY2xhc3MgTG9hZFN0YXRzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5hYm9ydGVkID0gZmFsc2U7XG4gICAgdGhpcy5sb2FkZWQgPSAwO1xuICAgIHRoaXMucmV0cnkgPSAwO1xuICAgIHRoaXMudG90YWwgPSAwO1xuICAgIHRoaXMuY2h1bmtDb3VudCA9IDA7XG4gICAgdGhpcy5id0VzdGltYXRlID0gMDtcbiAgICB0aGlzLmxvYWRpbmcgPSB7XG4gICAgICBzdGFydDogMCxcbiAgICAgIGZpcnN0OiAwLFxuICAgICAgZW5kOiAwXG4gICAgfTtcbiAgICB0aGlzLnBhcnNpbmcgPSB7XG4gICAgICBzdGFydDogMCxcbiAgICAgIGVuZDogMFxuICAgIH07XG4gICAgdGhpcy5idWZmZXJpbmcgPSB7XG4gICAgICBzdGFydDogMCxcbiAgICAgIGZpcnN0OiAwLFxuICAgICAgZW5kOiAwXG4gICAgfTtcbiAgfVxufVxuXG52YXIgRWxlbWVudGFyeVN0cmVhbVR5cGVzID0ge1xuICBBVURJTzogXCJhdWRpb1wiLFxuICBWSURFTzogXCJ2aWRlb1wiLFxuICBBVURJT1ZJREVPOiBcImF1ZGlvdmlkZW9cIlxufTtcbmNsYXNzIEJhc2VTZWdtZW50IHtcbiAgY29uc3RydWN0b3IoYmFzZSkge1xuICAgIHRoaXMuX2J5dGVSYW5nZSA9IG51bGw7XG4gICAgdGhpcy5fdXJsID0gbnVsbDtcbiAgICB0aGlzLl9zdGF0cyA9IG51bGw7XG4gICAgdGhpcy5fc3RyZWFtcyA9IG51bGw7XG4gICAgLy8gYmFzZXVybCBpcyB0aGUgVVJMIHRvIHRoZSBwbGF5bGlzdFxuICAgIHRoaXMuYmFzZSA9IHZvaWQgMDtcbiAgICAvLyByZWx1cmwgaXMgdGhlIHBvcnRpb24gb2YgdGhlIFVSTCB0aGF0IGNvbWVzIGZyb20gaW5zaWRlIHRoZSBwbGF5bGlzdC5cbiAgICB0aGlzLnJlbHVybCA9IHZvaWQgMDtcbiAgICBpZiAodHlwZW9mIGJhc2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBiYXNlID0ge1xuICAgICAgICB1cmw6IGJhc2VcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMuYmFzZSA9IGJhc2U7XG4gICAgbWFrZUVudW1lcmFibGUodGhpcywgJ3N0YXRzJyk7XG4gIH1cblxuICAvLyBzZXRCeXRlUmFuZ2UgY29udmVydHMgYSBFWFQtWC1CWVRFUkFOR0UgYXR0cmlidXRlIGludG8gYSB0d28gZWxlbWVudCBhcnJheVxuICBzZXRCeXRlUmFuZ2UodmFsdWUsIHByZXZpb3VzKSB7XG4gICAgY29uc3QgcGFyYW1zID0gdmFsdWUuc3BsaXQoJ0AnLCAyKTtcbiAgICBsZXQgc3RhcnQ7XG4gICAgaWYgKHBhcmFtcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHN0YXJ0ID0gKHByZXZpb3VzID09IG51bGwgPyB2b2lkIDAgOiBwcmV2aW91cy5ieXRlUmFuZ2VFbmRPZmZzZXQpIHx8IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0ID0gcGFyc2VJbnQocGFyYW1zWzFdKTtcbiAgICB9XG4gICAgdGhpcy5fYnl0ZVJhbmdlID0gW3N0YXJ0LCBwYXJzZUludChwYXJhbXNbMF0pICsgc3RhcnRdO1xuICB9XG4gIGdldCBiYXNldXJsKCkge1xuICAgIHJldHVybiB0aGlzLmJhc2UudXJsO1xuICB9XG4gIGdldCBieXRlUmFuZ2UoKSB7XG4gICAgaWYgKHRoaXMuX2J5dGVSYW5nZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYnl0ZVJhbmdlO1xuICB9XG4gIGdldCBieXRlUmFuZ2VTdGFydE9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5ieXRlUmFuZ2VbMF07XG4gIH1cbiAgZ2V0IGJ5dGVSYW5nZUVuZE9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5ieXRlUmFuZ2VbMV07XG4gIH1cbiAgZ2V0IGVsZW1lbnRhcnlTdHJlYW1zKCkge1xuICAgIGlmICh0aGlzLl9zdHJlYW1zID09PSBudWxsKSB7XG4gICAgICB0aGlzLl9zdHJlYW1zID0ge1xuICAgICAgICBbRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPXTogbnVsbCxcbiAgICAgICAgW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFT106IG51bGwsXG4gICAgICAgIFtFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU9WSURFT106IG51bGxcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zdHJlYW1zO1xuICB9XG4gIHNldCBlbGVtZW50YXJ5U3RyZWFtcyh2YWx1ZSkge1xuICAgIHRoaXMuX3N0cmVhbXMgPSB2YWx1ZTtcbiAgfVxuICBnZXQgaGFzU3RhdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRzICE9PSBudWxsO1xuICB9XG4gIGdldCBoYXNTdHJlYW1zKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJlYW1zICE9PSBudWxsO1xuICB9XG4gIGdldCBzdGF0cygpIHtcbiAgICBpZiAodGhpcy5fc3RhdHMgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3N0YXRzID0gbmV3IExvYWRTdGF0cygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc3RhdHM7XG4gIH1cbiAgc2V0IHN0YXRzKHZhbHVlKSB7XG4gICAgdGhpcy5fc3RhdHMgPSB2YWx1ZTtcbiAgfVxuICBnZXQgdXJsKCkge1xuICAgIGlmICghdGhpcy5fdXJsICYmIHRoaXMuYmFzZXVybCAmJiB0aGlzLnJlbHVybCkge1xuICAgICAgdGhpcy5fdXJsID0gdXJsVG9vbGtpdEV4cG9ydHMuYnVpbGRBYnNvbHV0ZVVSTCh0aGlzLmJhc2V1cmwsIHRoaXMucmVsdXJsLCB7XG4gICAgICAgIGFsd2F5c05vcm1hbGl6ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl91cmwgfHwgJyc7XG4gIH1cbiAgc2V0IHVybCh2YWx1ZSkge1xuICAgIHRoaXMuX3VybCA9IHZhbHVlO1xuICB9XG4gIGNsZWFyRWxlbWVudGFyeVN0cmVhbUluZm8oKSB7XG4gICAgY29uc3Qge1xuICAgICAgZWxlbWVudGFyeVN0cmVhbXNcbiAgICB9ID0gdGhpcztcbiAgICBlbGVtZW50YXJ5U3RyZWFtc1tFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU9dID0gbnVsbDtcbiAgICBlbGVtZW50YXJ5U3RyZWFtc1tFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU9dID0gbnVsbDtcbiAgICBlbGVtZW50YXJ5U3RyZWFtc1tFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU9WSURFT10gPSBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBpc01lZGlhRnJhZ21lbnQoZnJhZykge1xuICByZXR1cm4gZnJhZy5zbiAhPT0gJ2luaXRTZWdtZW50Jztcbn1cblxuLyoqXG4gKiBPYmplY3QgcmVwcmVzZW50aW5nIHBhcnNlZCBkYXRhIGZyb20gYW4gSExTIFNlZ21lbnQuIEZvdW5kIGluIHtAbGluayBobHMuanMjTGV2ZWxEZXRhaWxzLmZyYWdtZW50c30uXG4gKi9cbmNsYXNzIEZyYWdtZW50IGV4dGVuZHMgQmFzZVNlZ21lbnQge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBiYXNlKSB7XG4gICAgc3VwZXIoYmFzZSk7XG4gICAgdGhpcy5fZGVjcnlwdGRhdGEgPSBudWxsO1xuICAgIHRoaXMuX3Byb2dyYW1EYXRlVGltZSA9IG51bGw7XG4gICAgdGhpcy5fcmVmID0gbnVsbDtcbiAgICAvLyBBcHByb3hpbWF0ZSBiaXQgcmF0ZSBvZiB0aGUgZnJhZ21lbnQgZXhwcmVzc2VkIGluIGJpdHMgcGVyIHNlY29uZCAoYnBzKSBhcyBpbmRpY2F0ZWQgYnkgdGhlIGxhc3QgRVhULVgtQklUUkFURSAoa2JwcykgdGFnXG4gICAgdGhpcy5fYml0cmF0ZSA9IHZvaWQgMDtcbiAgICB0aGlzLnJhd1Byb2dyYW1EYXRlVGltZSA9IG51bGw7XG4gICAgdGhpcy50YWdMaXN0ID0gW107XG4gICAgLy8gRVhUSU5GIGhhcyB0byBiZSBwcmVzZW50IGZvciBhIG0zdTggdG8gYmUgY29uc2lkZXJlZCB2YWxpZFxuICAgIHRoaXMuZHVyYXRpb24gPSAwO1xuICAgIC8vIHNuIG5vdGF0ZXMgdGhlIHNlcXVlbmNlIG51bWJlciBmb3IgYSBzZWdtZW50LCBhbmQgaWYgc2V0IHRvIGEgc3RyaW5nIGNhbiBiZSAnaW5pdFNlZ21lbnQnXG4gICAgdGhpcy5zbiA9IDA7XG4gICAgLy8gbGV2ZWxrZXlzIGFyZSB0aGUgRVhULVgtS0VZIHRhZ3MgdGhhdCBhcHBseSB0byB0aGlzIHNlZ21lbnQgZm9yIGRlY3J5cHRpb25cbiAgICAvLyBjb3JlIGRpZmZlcmVuY2UgZnJvbSB0aGUgcHJpdmF0ZSBmaWVsZCBfZGVjcnlwdGRhdGEgaXMgdGhlIGxhY2sgb2YgdGhlIGluaXRpYWxpemVkIElWXG4gICAgLy8gX2RlY3J5cHRkYXRhIHdpbGwgc2V0IHRoZSBJViBmb3IgdGhpcyBzZWdtZW50IGJhc2VkIG9uIHRoZSBzZWdtZW50IG51bWJlciBpbiB0aGUgZnJhZ21lbnRcbiAgICB0aGlzLmxldmVsa2V5cyA9IHZvaWQgMDtcbiAgICAvLyBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGZyYWdtZW50IHR5cGVcbiAgICB0aGlzLnR5cGUgPSB2b2lkIDA7XG4gICAgLy8gQSByZWZlcmVuY2UgdG8gdGhlIGxvYWRlci4gU2V0IHdoaWxlIHRoZSBmcmFnbWVudCBpcyBsb2FkaW5nLCBhbmQgcmVtb3ZlZCBhZnRlcndhcmRzLiBVc2VkIHRvIGFib3J0IGZyYWdtZW50IGxvYWRpbmdcbiAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgLy8gQSByZWZlcmVuY2UgdG8gdGhlIGtleSBsb2FkZXIuIFNldCB3aGlsZSB0aGUga2V5IGlzIGxvYWRpbmcsIGFuZCByZW1vdmVkIGFmdGVyd2FyZHMuIFVzZWQgdG8gYWJvcnQga2V5IGxvYWRpbmdcbiAgICB0aGlzLmtleUxvYWRlciA9IG51bGw7XG4gICAgLy8gVGhlIGxldmVsL3RyYWNrIGluZGV4IHRvIHdoaWNoIHRoZSBmcmFnbWVudCBiZWxvbmdzXG4gICAgdGhpcy5sZXZlbCA9IC0xO1xuICAgIC8vIFRoZSBjb250aW51aXR5IGNvdW50ZXIgb2YgdGhlIGZyYWdtZW50XG4gICAgdGhpcy5jYyA9IDA7XG4gICAgLy8gVGhlIHN0YXJ0aW5nIFByZXNlbnRhdGlvbiBUaW1lIFN0YW1wIChQVFMpIG9mIHRoZSBmcmFnbWVudC4gU2V0IGFmdGVyIHRyYW5zbXV4IGNvbXBsZXRlLlxuICAgIHRoaXMuc3RhcnRQVFMgPSB2b2lkIDA7XG4gICAgLy8gVGhlIGVuZGluZyBQcmVzZW50YXRpb24gVGltZSBTdGFtcCAoUFRTKSBvZiB0aGUgZnJhZ21lbnQuIFNldCBhZnRlciB0cmFuc211eCBjb21wbGV0ZS5cbiAgICB0aGlzLmVuZFBUUyA9IHZvaWQgMDtcbiAgICAvLyBUaGUgc3RhcnRpbmcgRGVjb2RlIFRpbWUgU3RhbXAgKERUUykgb2YgdGhlIGZyYWdtZW50LiBTZXQgYWZ0ZXIgdHJhbnNtdXggY29tcGxldGUuXG4gICAgdGhpcy5zdGFydERUUyA9IHZvaWQgMDtcbiAgICAvLyBUaGUgZW5kaW5nIERlY29kZSBUaW1lIFN0YW1wIChEVFMpIG9mIHRoZSBmcmFnbWVudC4gU2V0IGFmdGVyIHRyYW5zbXV4IGNvbXBsZXRlLlxuICAgIHRoaXMuZW5kRFRTID0gdm9pZCAwO1xuICAgIC8vIFRoZSBzdGFydCB0aW1lIG9mIHRoZSBmcmFnbWVudCwgYXMgbGlzdGVkIGluIHRoZSBtYW5pZmVzdC4gVXBkYXRlZCBhZnRlciB0cmFuc211eCBjb21wbGV0ZS5cbiAgICB0aGlzLnN0YXJ0ID0gMDtcbiAgICAvLyBUaGUgb2Zmc2V0IHRpbWUgKHNlY29uZHMpIG9mIHRoZSBmcmFnbWVudCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgUGxheWxpc3RcbiAgICB0aGlzLnBsYXlsaXN0T2Zmc2V0ID0gMDtcbiAgICAvLyBTZXQgYnkgYHVwZGF0ZUZyYWdQVFNEVFNgIGluIGxldmVsLWhlbHBlclxuICAgIHRoaXMuZGVsdGFQVFMgPSB2b2lkIDA7XG4gICAgLy8gVGhlIG1heGltdW0gc3RhcnRpbmcgUHJlc2VudGF0aW9uIFRpbWUgU3RhbXAgKGF1ZGlvL3ZpZGVvIFBUUykgb2YgdGhlIGZyYWdtZW50LiBTZXQgYWZ0ZXIgdHJhbnNtdXggY29tcGxldGUuXG4gICAgdGhpcy5tYXhTdGFydFBUUyA9IHZvaWQgMDtcbiAgICAvLyBUaGUgbWluaW11bSBlbmRpbmcgUHJlc2VudGF0aW9uIFRpbWUgU3RhbXAgKGF1ZGlvL3ZpZGVvIFBUUykgb2YgdGhlIGZyYWdtZW50LiBTZXQgYWZ0ZXIgdHJhbnNtdXggY29tcGxldGUuXG4gICAgdGhpcy5taW5FbmRQVFMgPSB2b2lkIDA7XG4gICAgLy8gSW5pdCBTZWdtZW50IGJ5dGVzICh1bnNldCBmb3IgbWVkaWEgc2VnbWVudHMpXG4gICAgdGhpcy5kYXRhID0gdm9pZCAwO1xuICAgIC8vIEEgZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHNlZ21lbnQgd2FzIGRvd25sb2FkZWQgaW4gb3JkZXIgdG8gdGVzdCBiaXRyYXRlLCBhbmQgd2FzIG5vdCBidWZmZXJlZFxuICAgIHRoaXMuYml0cmF0ZVRlc3QgPSBmYWxzZTtcbiAgICAvLyAjRVhUSU5GICBzZWdtZW50IHRpdGxlXG4gICAgdGhpcy50aXRsZSA9IG51bGw7XG4gICAgLy8gVGhlIE1lZGlhIEluaXRpYWxpemF0aW9uIFNlY3Rpb24gZm9yIHRoaXMgc2VnbWVudFxuICAgIHRoaXMuaW5pdFNlZ21lbnQgPSBudWxsO1xuICAgIC8vIEZyYWdtZW50IGlzIHRoZSBsYXN0IGZyYWdtZW50IGluIHRoZSBtZWRpYSBwbGF5bGlzdFxuICAgIHRoaXMuZW5kTGlzdCA9IHZvaWQgMDtcbiAgICAvLyBGcmFnbWVudCBpcyBtYXJrZWQgYnkgYW4gRVhULVgtR0FQIHRhZyBpbmRpY2F0aW5nIHRoYXQgaXQgZG9lcyBub3QgY29udGFpbiBtZWRpYSBkYXRhIGFuZCBzaG91bGQgbm90IGJlIGxvYWRlZFxuICAgIHRoaXMuZ2FwID0gdm9pZCAwO1xuICAgIC8vIERlcHJlY2F0ZWRcbiAgICB0aGlzLnVybElkID0gMDtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICB9XG4gIGdldCBieXRlTGVuZ3RoKCkge1xuICAgIGlmICh0aGlzLmhhc1N0YXRzKSB7XG4gICAgICBjb25zdCB0b3RhbCA9IHRoaXMuc3RhdHMudG90YWw7XG4gICAgICBpZiAodG90YWwpIHtcbiAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5ieXRlUmFuZ2UpIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5ieXRlUmFuZ2VbMF07XG4gICAgICBjb25zdCBlbmQgPSB0aGlzLmJ5dGVSYW5nZVsxXTtcbiAgICAgIGlmIChpc0Zpbml0ZU51bWJlcihzdGFydCkgJiYgaXNGaW5pdGVOdW1iZXIoZW5kKSkge1xuICAgICAgICByZXR1cm4gZW5kIC0gc3RhcnQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdldCBiaXRyYXRlKCkge1xuICAgIGlmICh0aGlzLmJ5dGVMZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLmJ5dGVMZW5ndGggKiA4IC8gdGhpcy5kdXJhdGlvbjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2JpdHJhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9iaXRyYXRlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBzZXQgYml0cmF0ZSh2YWx1ZSkge1xuICAgIHRoaXMuX2JpdHJhdGUgPSB2YWx1ZTtcbiAgfVxuICBnZXQgZGVjcnlwdGRhdGEoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWxrZXlzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFsZXZlbGtleXMgJiYgIXRoaXMuX2RlY3J5cHRkYXRhKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9kZWNyeXB0ZGF0YSAmJiB0aGlzLmxldmVsa2V5cyAmJiAhdGhpcy5sZXZlbGtleXMuTk9ORSkge1xuICAgICAgY29uc3Qga2V5ID0gdGhpcy5sZXZlbGtleXMuaWRlbnRpdHk7XG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHRoaXMuX2RlY3J5cHRkYXRhID0ga2V5LmdldERlY3J5cHREYXRhKHRoaXMuc24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qga2V5Rm9ybWF0cyA9IE9iamVjdC5rZXlzKHRoaXMubGV2ZWxrZXlzKTtcbiAgICAgICAgaWYgKGtleUZvcm1hdHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2RlY3J5cHRkYXRhID0gdGhpcy5sZXZlbGtleXNba2V5Rm9ybWF0c1swXV0uZ2V0RGVjcnlwdERhdGEodGhpcy5zbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2RlY3J5cHRkYXRhO1xuICB9XG4gIGdldCBlbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhcnQgKyB0aGlzLmR1cmF0aW9uO1xuICB9XG4gIGdldCBlbmRQcm9ncmFtRGF0ZVRpbWUoKSB7XG4gICAgaWYgKHRoaXMucHJvZ3JhbURhdGVUaW1lID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZHVyYXRpb24gPSAhaXNGaW5pdGVOdW1iZXIodGhpcy5kdXJhdGlvbikgPyAwIDogdGhpcy5kdXJhdGlvbjtcbiAgICByZXR1cm4gdGhpcy5wcm9ncmFtRGF0ZVRpbWUgKyBkdXJhdGlvbiAqIDEwMDA7XG4gIH1cbiAgZ2V0IGVuY3J5cHRlZCgpIHtcbiAgICB2YXIgX3RoaXMkX2RlY3J5cHRkYXRhO1xuICAgIC8vIEF0IHRoZSBtM3U4LXBhcnNlciBsZXZlbCB3ZSBuZWVkIHRvIGFkZCBzdXBwb3J0IGZvciBtYW5pZmVzdCBzaWduYWxsZWQga2V5Zm9ybWF0c1xuICAgIC8vIHdoZW4gd2Ugd2FudCB0aGUgZnJhZ21lbnQgdG8gc3RhcnQgcmVwb3J0aW5nIHRoYXQgaXQgaXMgZW5jcnlwdGVkLlxuICAgIC8vIEN1cnJlbnRseSwga2V5Rm9ybWF0IHdpbGwgb25seSBiZSBzZXQgZm9yIGlkZW50aXR5IGtleXNcbiAgICBpZiAoKF90aGlzJF9kZWNyeXB0ZGF0YSA9IHRoaXMuX2RlY3J5cHRkYXRhKSAhPSBudWxsICYmIF90aGlzJF9kZWNyeXB0ZGF0YS5lbmNyeXB0ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sZXZlbGtleXMpIHtcbiAgICAgIGNvbnN0IGtleUZvcm1hdHMgPSBPYmplY3Qua2V5cyh0aGlzLmxldmVsa2V5cyk7XG4gICAgICBjb25zdCBsZW4gPSBrZXlGb3JtYXRzLmxlbmd0aDtcbiAgICAgIGlmIChsZW4gPiAxIHx8IGxlbiA9PT0gMSAmJiB0aGlzLmxldmVsa2V5c1trZXlGb3JtYXRzWzBdXS5lbmNyeXB0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBnZXQgcHJvZ3JhbURhdGVUaW1lKCkge1xuICAgIGlmICh0aGlzLl9wcm9ncmFtRGF0ZVRpbWUgPT09IG51bGwgJiYgdGhpcy5yYXdQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICAgIHRoaXMucHJvZ3JhbURhdGVUaW1lID0gRGF0ZS5wYXJzZSh0aGlzLnJhd1Byb2dyYW1EYXRlVGltZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wcm9ncmFtRGF0ZVRpbWU7XG4gIH1cbiAgc2V0IHByb2dyYW1EYXRlVGltZSh2YWx1ZSkge1xuICAgIGlmICghaXNGaW5pdGVOdW1iZXIodmFsdWUpKSB7XG4gICAgICB0aGlzLl9wcm9ncmFtRGF0ZVRpbWUgPSB0aGlzLnJhd1Byb2dyYW1EYXRlVGltZSA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3Byb2dyYW1EYXRlVGltZSA9IHZhbHVlO1xuICB9XG4gIGdldCByZWYoKSB7XG4gICAgaWYgKCFpc01lZGlhRnJhZ21lbnQodGhpcykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX3JlZikge1xuICAgICAgdGhpcy5fcmVmID0ge1xuICAgICAgICBiYXNlOiB0aGlzLmJhc2UsXG4gICAgICAgIHN0YXJ0OiB0aGlzLnN0YXJ0LFxuICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgc246IHRoaXMuc24sXG4gICAgICAgIHByb2dyYW1EYXRlVGltZTogdGhpcy5wcm9ncmFtRGF0ZVRpbWVcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWY7XG4gIH1cbiAgYWRkU3RhcnQodmFsdWUpIHtcbiAgICB0aGlzLnNldFN0YXJ0KHRoaXMuc3RhcnQgKyB2YWx1ZSk7XG4gIH1cbiAgc2V0U3RhcnQodmFsdWUpIHtcbiAgICB0aGlzLnN0YXJ0ID0gdmFsdWU7XG4gICAgaWYgKHRoaXMuX3JlZikge1xuICAgICAgdGhpcy5fcmVmLnN0YXJ0ID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHNldER1cmF0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5kdXJhdGlvbiA9IHZhbHVlO1xuICAgIGlmICh0aGlzLl9yZWYpIHtcbiAgICAgIHRoaXMuX3JlZi5kdXJhdGlvbiA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICBzZXRLZXlGb3JtYXQoa2V5Rm9ybWF0KSB7XG4gICAgaWYgKHRoaXMubGV2ZWxrZXlzKSB7XG4gICAgICBjb25zdCBrZXkgPSB0aGlzLmxldmVsa2V5c1trZXlGb3JtYXRdO1xuICAgICAgaWYgKGtleSAmJiAhdGhpcy5fZGVjcnlwdGRhdGEpIHtcbiAgICAgICAgdGhpcy5fZGVjcnlwdGRhdGEgPSBrZXkuZ2V0RGVjcnlwdERhdGEodGhpcy5zbik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFib3J0UmVxdWVzdHMoKSB7XG4gICAgdmFyIF90aGlzJGxvYWRlciwgX3RoaXMka2V5TG9hZGVyO1xuICAgIChfdGhpcyRsb2FkZXIgPSB0aGlzLmxvYWRlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGxvYWRlci5hYm9ydCgpO1xuICAgIChfdGhpcyRrZXlMb2FkZXIgPSB0aGlzLmtleUxvYWRlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGtleUxvYWRlci5hYm9ydCgpO1xuICB9XG4gIHNldEVsZW1lbnRhcnlTdHJlYW1JbmZvKHR5cGUsIHN0YXJ0UFRTLCBlbmRQVFMsIHN0YXJ0RFRTLCBlbmREVFMsIHBhcnRpYWwgPSBmYWxzZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW1lbnRhcnlTdHJlYW1zXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgaW5mbyA9IGVsZW1lbnRhcnlTdHJlYW1zW3R5cGVdO1xuICAgIGlmICghaW5mbykge1xuICAgICAgZWxlbWVudGFyeVN0cmVhbXNbdHlwZV0gPSB7XG4gICAgICAgIHN0YXJ0UFRTLFxuICAgICAgICBlbmRQVFMsXG4gICAgICAgIHN0YXJ0RFRTLFxuICAgICAgICBlbmREVFMsXG4gICAgICAgIHBhcnRpYWxcbiAgICAgIH07XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGluZm8uc3RhcnRQVFMgPSBNYXRoLm1pbihpbmZvLnN0YXJ0UFRTLCBzdGFydFBUUyk7XG4gICAgaW5mby5lbmRQVFMgPSBNYXRoLm1heChpbmZvLmVuZFBUUywgZW5kUFRTKTtcbiAgICBpbmZvLnN0YXJ0RFRTID0gTWF0aC5taW4oaW5mby5zdGFydERUUywgc3RhcnREVFMpO1xuICAgIGluZm8uZW5kRFRTID0gTWF0aC5tYXgoaW5mby5lbmREVFMsIGVuZERUUyk7XG4gIH1cbn1cblxuLyoqXG4gKiBPYmplY3QgcmVwcmVzZW50aW5nIHBhcnNlZCBkYXRhIGZyb20gYW4gSExTIFBhcnRpYWwgU2VnbWVudC4gRm91bmQgaW4ge0BsaW5rIGhscy5qcyNMZXZlbERldGFpbHMucGFydExpc3R9LlxuICovXG5jbGFzcyBQYXJ0IGV4dGVuZHMgQmFzZVNlZ21lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJ0QXR0cnMsIGZyYWcsIGJhc2UsIGluZGV4LCBwcmV2aW91cykge1xuICAgIHN1cGVyKGJhc2UpO1xuICAgIHRoaXMuZnJhZ09mZnNldCA9IDA7XG4gICAgdGhpcy5kdXJhdGlvbiA9IDA7XG4gICAgdGhpcy5nYXAgPSBmYWxzZTtcbiAgICB0aGlzLmluZGVwZW5kZW50ID0gZmFsc2U7XG4gICAgdGhpcy5yZWx1cmwgPSB2b2lkIDA7XG4gICAgdGhpcy5mcmFnbWVudCA9IHZvaWQgMDtcbiAgICB0aGlzLmluZGV4ID0gdm9pZCAwO1xuICAgIHRoaXMuZHVyYXRpb24gPSBwYXJ0QXR0cnMuZGVjaW1hbEZsb2F0aW5nUG9pbnQoJ0RVUkFUSU9OJyk7XG4gICAgdGhpcy5nYXAgPSBwYXJ0QXR0cnMuYm9vbCgnR0FQJyk7XG4gICAgdGhpcy5pbmRlcGVuZGVudCA9IHBhcnRBdHRycy5ib29sKCdJTkRFUEVOREVOVCcpO1xuICAgIHRoaXMucmVsdXJsID0gcGFydEF0dHJzLmVudW1lcmF0ZWRTdHJpbmcoJ1VSSScpO1xuICAgIHRoaXMuZnJhZ21lbnQgPSBmcmFnO1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICBjb25zdCBieXRlUmFuZ2UgPSBwYXJ0QXR0cnMuZW51bWVyYXRlZFN0cmluZygnQllURVJBTkdFJyk7XG4gICAgaWYgKGJ5dGVSYW5nZSkge1xuICAgICAgdGhpcy5zZXRCeXRlUmFuZ2UoYnl0ZVJhbmdlLCBwcmV2aW91cyk7XG4gICAgfVxuICAgIGlmIChwcmV2aW91cykge1xuICAgICAgdGhpcy5mcmFnT2Zmc2V0ID0gcHJldmlvdXMuZnJhZ09mZnNldCArIHByZXZpb3VzLmR1cmF0aW9uO1xuICAgIH1cbiAgfVxuICBnZXQgc3RhcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZnJhZ21lbnQuc3RhcnQgKyB0aGlzLmZyYWdPZmZzZXQ7XG4gIH1cbiAgZ2V0IGVuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFydCArIHRoaXMuZHVyYXRpb247XG4gIH1cbiAgZ2V0IGxvYWRlZCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBlbGVtZW50YXJ5U3RyZWFtc1xuICAgIH0gPSB0aGlzO1xuICAgIHJldHVybiAhIShlbGVtZW50YXJ5U3RyZWFtcy5hdWRpbyB8fCBlbGVtZW50YXJ5U3RyZWFtcy52aWRlbyB8fCBlbGVtZW50YXJ5U3RyZWFtcy5hdWRpb3ZpZGVvKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yRnJvbVByb3RvdHlwZUNoYWluKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgY29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gIGlmIChwcm90b3R5cGUpIHtcbiAgICBjb25zdCBwcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvdHlwZSwgcHJvcGVydHkpO1xuICAgIGlmIChwcm9wZXJ0eURlc2NyaXB0b3IpIHtcbiAgICAgIHJldHVybiBwcm9wZXJ0eURlc2NyaXB0b3I7XG4gICAgfVxuICAgIHJldHVybiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JGcm9tUHJvdG90eXBlQ2hhaW4ocHJvdG90eXBlLCBwcm9wZXJ0eSk7XG4gIH1cbn1cbmZ1bmN0aW9uIG1ha2VFbnVtZXJhYmxlKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgY29uc3QgZCA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvckZyb21Qcm90b3R5cGVDaGFpbihvYmplY3QsIHByb3BlcnR5KTtcbiAgaWYgKGQpIHtcbiAgICBkLmVudW1lcmFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBkKTtcbiAgfVxufVxuXG5jb25zdCBVSU5UMzJfTUFYJDEgPSBNYXRoLnBvdygyLCAzMikgLSAxO1xuY29uc3QgcHVzaCA9IFtdLnB1c2g7XG5cbi8vIFdlIGFyZSB1c2luZyBmaXhlZCB0cmFjayBJRHMgZm9yIGRyaXZpbmcgdGhlIE1QNCByZW11eGVyXG4vLyBpbnN0ZWFkIG9mIGZvbGxvd2luZyB0aGUgVFMgUElEcy5cbi8vIFRoZXJlIGlzIG5vIHJlYXNvbiBub3QgdG8gZG8gdGhpcyBhbmQgc29tZSBicm93c2Vycy9Tb3VyY2VCdWZmZXItZGVtdXhlcnNcbi8vIG1heSBub3QgbGlrZSBpZiB0aGVyZSBhcmUgVHJhY2tJRCBcInN3aXRjaGVzXCJcbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvMTMzMVxuLy8gSGVyZSB3ZSBhcmUgbWFwcGluZyBvdXIgaW50ZXJuYWwgdHJhY2sgdHlwZXMgdG8gY29uc3RhbnQgTVA0IHRyYWNrIElEc1xuLy8gV2l0aCBNU0UgY3VycmVudGx5IG9uZSBjYW4gb25seSBoYXZlIG9uZSB0cmFjayBvZiBlYWNoLCBhbmQgd2UgYXJlIG11eGluZ1xuLy8gd2hhdGV2ZXIgdmlkZW8vYXVkaW8gcmVuZGl0aW9uIGluIHRoZW0uXG5jb25zdCBSZW11eGVyVHJhY2tJZENvbmZpZyA9IHtcbiAgdmlkZW86IDEsXG4gIGF1ZGlvOiAyLFxuICBpZDM6IDMsXG4gIHRleHQ6IDRcbn07XG5mdW5jdGlvbiBiaW4yc3RyKGRhdGEpIHtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgZGF0YSk7XG59XG5mdW5jdGlvbiByZWFkVWludDE2KGJ1ZmZlciwgb2Zmc2V0KSB7XG4gIGNvbnN0IHZhbCA9IGJ1ZmZlcltvZmZzZXRdIDw8IDggfCBidWZmZXJbb2Zmc2V0ICsgMV07XG4gIHJldHVybiB2YWwgPCAwID8gNjU1MzYgKyB2YWwgOiB2YWw7XG59XG5mdW5jdGlvbiByZWFkVWludDMyKGJ1ZmZlciwgb2Zmc2V0KSB7XG4gIGNvbnN0IHZhbCA9IHJlYWRTaW50MzIoYnVmZmVyLCBvZmZzZXQpO1xuICByZXR1cm4gdmFsIDwgMCA/IDQyOTQ5NjcyOTYgKyB2YWwgOiB2YWw7XG59XG5mdW5jdGlvbiByZWFkVWludDY0KGJ1ZmZlciwgb2Zmc2V0KSB7XG4gIGxldCByZXN1bHQgPSByZWFkVWludDMyKGJ1ZmZlciwgb2Zmc2V0KTtcbiAgcmVzdWx0ICo9IE1hdGgucG93KDIsIDMyKTtcbiAgcmVzdWx0ICs9IHJlYWRVaW50MzIoYnVmZmVyLCBvZmZzZXQgKyA0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHJlYWRTaW50MzIoYnVmZmVyLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGJ1ZmZlcltvZmZzZXRdIDw8IDI0IHwgYnVmZmVyW29mZnNldCArIDFdIDw8IDE2IHwgYnVmZmVyW29mZnNldCArIDJdIDw8IDggfCBidWZmZXJbb2Zmc2V0ICsgM107XG59XG5cbi8vIEZpbmQgXCJtb29mXCIgYm94XG5mdW5jdGlvbiBoYXNNb29mRGF0YShkYXRhKSB7XG4gIGNvbnN0IGVuZCA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmQ7KSB7XG4gICAgY29uc3Qgc2l6ZSA9IHJlYWRVaW50MzIoZGF0YSwgaSk7XG4gICAgaWYgKHNpemUgPiA4ICYmIGRhdGFbaSArIDRdID09PSAweDZkICYmIGRhdGFbaSArIDVdID09PSAweDZmICYmIGRhdGFbaSArIDZdID09PSAweDZmICYmIGRhdGFbaSArIDddID09PSAweDY2KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaSA9IHNpemUgPiAxID8gaSArIHNpemUgOiBlbmQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBGaW5kIHRoZSBkYXRhIGZvciBhIGJveCBzcGVjaWZpZWQgYnkgaXRzIHBhdGhcbmZ1bmN0aW9uIGZpbmRCb3goZGF0YSwgcGF0aCkge1xuICBjb25zdCByZXN1bHRzID0gW107XG4gIGlmICghcGF0aC5sZW5ndGgpIHtcbiAgICAvLyBzaG9ydC1jaXJjdWl0IHRoZSBzZWFyY2ggZm9yIGVtcHR5IHBhdGhzXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbiAgY29uc3QgZW5kID0gZGF0YS5ieXRlTGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGVuZDspIHtcbiAgICBjb25zdCBzaXplID0gcmVhZFVpbnQzMihkYXRhLCBpKTtcbiAgICBjb25zdCB0eXBlID0gYmluMnN0cihkYXRhLnN1YmFycmF5KGkgKyA0LCBpICsgOCkpO1xuICAgIGNvbnN0IGVuZGJveCA9IHNpemUgPiAxID8gaSArIHNpemUgOiBlbmQ7XG4gICAgaWYgKHR5cGUgPT09IHBhdGhbMF0pIHtcbiAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyB0aGlzIGlzIHRoZSBlbmQgb2YgdGhlIHBhdGggYW5kIHdlJ3ZlIGZvdW5kIHRoZSBib3ggd2Ugd2VyZVxuICAgICAgICAvLyBsb29raW5nIGZvclxuICAgICAgICByZXN1bHRzLnB1c2goZGF0YS5zdWJhcnJheShpICsgOCwgZW5kYm94KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHRoZSBuZXh0IGJveCBhbG9uZyB0aGUgcGF0aFxuICAgICAgICBjb25zdCBzdWJyZXN1bHRzID0gZmluZEJveChkYXRhLnN1YmFycmF5KGkgKyA4LCBlbmRib3gpLCBwYXRoLnNsaWNlKDEpKTtcbiAgICAgICAgaWYgKHN1YnJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgICAgcHVzaC5hcHBseShyZXN1bHRzLCBzdWJyZXN1bHRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpID0gZW5kYm94O1xuICB9XG5cbiAgLy8gd2UndmUgZmluaXNoZWQgc2VhcmNoaW5nIGFsbCBvZiBkYXRhXG4gIHJldHVybiByZXN1bHRzO1xufVxuZnVuY3Rpb24gcGFyc2VTZWdtZW50SW5kZXgoc2lkeCkge1xuICBjb25zdCByZWZlcmVuY2VzID0gW107XG4gIGNvbnN0IHZlcnNpb24gPSBzaWR4WzBdO1xuXG4gIC8vIHNldCBpbml0aWFsIG9mZnNldCwgd2Ugc2tpcCB0aGUgcmVmZXJlbmNlIElEIChub3QgbmVlZGVkKVxuICBsZXQgaW5kZXggPSA4O1xuICBjb25zdCB0aW1lc2NhbGUgPSByZWFkVWludDMyKHNpZHgsIGluZGV4KTtcbiAgaW5kZXggKz0gNDtcbiAgbGV0IGVhcmxpZXN0UHJlc2VudGF0aW9uVGltZSA9IDA7XG4gIGxldCBmaXJzdE9mZnNldCA9IDA7XG4gIGlmICh2ZXJzaW9uID09PSAwKSB7XG4gICAgZWFybGllc3RQcmVzZW50YXRpb25UaW1lID0gcmVhZFVpbnQzMihzaWR4LCBpbmRleCk7XG4gICAgZmlyc3RPZmZzZXQgPSByZWFkVWludDMyKHNpZHgsIGluZGV4ICsgNCk7XG4gICAgaW5kZXggKz0gODtcbiAgfSBlbHNlIHtcbiAgICBlYXJsaWVzdFByZXNlbnRhdGlvblRpbWUgPSByZWFkVWludDY0KHNpZHgsIGluZGV4KTtcbiAgICBmaXJzdE9mZnNldCA9IHJlYWRVaW50NjQoc2lkeCwgaW5kZXggKyA4KTtcbiAgICBpbmRleCArPSAxNjtcbiAgfVxuXG4gIC8vIHNraXAgcmVzZXJ2ZWRcbiAgaW5kZXggKz0gMjtcbiAgbGV0IHN0YXJ0Qnl0ZSA9IHNpZHgubGVuZ3RoICsgZmlyc3RPZmZzZXQ7XG4gIGNvbnN0IHJlZmVyZW5jZXNDb3VudCA9IHJlYWRVaW50MTYoc2lkeCwgaW5kZXgpO1xuICBpbmRleCArPSAyO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJlZmVyZW5jZXNDb3VudDsgaSsrKSB7XG4gICAgbGV0IHJlZmVyZW5jZUluZGV4ID0gaW5kZXg7XG4gICAgY29uc3QgcmVmZXJlbmNlSW5mbyA9IHJlYWRVaW50MzIoc2lkeCwgcmVmZXJlbmNlSW5kZXgpO1xuICAgIHJlZmVyZW5jZUluZGV4ICs9IDQ7XG4gICAgY29uc3QgcmVmZXJlbmNlU2l6ZSA9IHJlZmVyZW5jZUluZm8gJiAweDdmZmZmZmZmO1xuICAgIGNvbnN0IHJlZmVyZW5jZVR5cGUgPSAocmVmZXJlbmNlSW5mbyAmIDB4ODAwMDAwMDApID4+PiAzMTtcbiAgICBpZiAocmVmZXJlbmNlVHlwZSA9PT0gMSkge1xuICAgICAgbG9nZ2VyLndhcm4oJ1NJRFggaGFzIGhpZXJhcmNoaWNhbCByZWZlcmVuY2VzIChub3Qgc3VwcG9ydGVkKScpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHN1YnNlZ21lbnREdXJhdGlvbiA9IHJlYWRVaW50MzIoc2lkeCwgcmVmZXJlbmNlSW5kZXgpO1xuICAgIHJlZmVyZW5jZUluZGV4ICs9IDQ7XG4gICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgIHJlZmVyZW5jZVNpemUsXG4gICAgICBzdWJzZWdtZW50RHVyYXRpb24sXG4gICAgICAvLyB1bnNjYWxlZFxuICAgICAgaW5mbzoge1xuICAgICAgICBkdXJhdGlvbjogc3Vic2VnbWVudER1cmF0aW9uIC8gdGltZXNjYWxlLFxuICAgICAgICBzdGFydDogc3RhcnRCeXRlLFxuICAgICAgICBlbmQ6IHN0YXJ0Qnl0ZSArIHJlZmVyZW5jZVNpemUgLSAxXG4gICAgICB9XG4gICAgfSk7XG4gICAgc3RhcnRCeXRlICs9IHJlZmVyZW5jZVNpemU7XG5cbiAgICAvLyBTa2lwcGluZyAxIGJpdCBmb3IgfHN0YXJ0c1dpdGhTYXB8LCAzIGJpdHMgZm9yIHxzYXBUeXBlfCwgYW5kIDI4IGJpdHNcbiAgICAvLyBmb3IgfHNhcERlbHRhfC5cbiAgICByZWZlcmVuY2VJbmRleCArPSA0O1xuXG4gICAgLy8gc2tpcCB0byBuZXh0IHJlZlxuICAgIGluZGV4ID0gcmVmZXJlbmNlSW5kZXg7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBlYXJsaWVzdFByZXNlbnRhdGlvblRpbWUsXG4gICAgdGltZXNjYWxlLFxuICAgIHZlcnNpb24sXG4gICAgcmVmZXJlbmNlc0NvdW50LFxuICAgIHJlZmVyZW5jZXNcbiAgfTtcbn1cblxuLyoqXG4gKiBQYXJzZXMgYW4gTVA0IGluaXRpYWxpemF0aW9uIHNlZ21lbnQgYW5kIGV4dHJhY3RzIHN0cmVhbSB0eXBlIGFuZFxuICogdGltZXNjYWxlIHZhbHVlcyBmb3IgYW55IGRlY2xhcmVkIHRyYWNrcy4gVGltZXNjYWxlIHZhbHVlcyBpbmRpY2F0ZSB0aGVcbiAqIG51bWJlciBvZiBjbG9jayB0aWNrcyBwZXIgc2Vjb25kIHRvIGFzc3VtZSBmb3IgdGltZS1iYXNlZCB2YWx1ZXNcbiAqIGVsc2V3aGVyZSBpbiB0aGUgTVA0LlxuICpcbiAqIFRvIGRldGVybWluZSB0aGUgc3RhcnQgdGltZSBvZiBhbiBNUDQsIHlvdSBuZWVkIHR3byBwaWVjZXMgb2ZcbiAqIGluZm9ybWF0aW9uOiB0aGUgdGltZXNjYWxlIHVuaXQgYW5kIHRoZSBlYXJsaWVzdCBiYXNlIG1lZGlhIGRlY29kZVxuICogdGltZS4gTXVsdGlwbGUgdGltZXNjYWxlcyBjYW4gYmUgc3BlY2lmaWVkIHdpdGhpbiBhbiBNUDQgYnV0IHRoZVxuICogYmFzZSBtZWRpYSBkZWNvZGUgdGltZSBpcyBhbHdheXMgZXhwcmVzc2VkIGluIHRoZSB0aW1lc2NhbGUgZnJvbVxuICogdGhlIG1lZGlhIGhlYWRlciBib3ggZm9yIHRoZSB0cmFjazpcbiAqIGBgYFxuICogbW9vdiA+IHRyYWsgPiBtZGlhID4gbWRoZC50aW1lc2NhbGVcbiAqIG1vb3YgPiB0cmFrID4gbWRpYSA+IGhkbHJcbiAqIGBgYFxuICogQHBhcmFtIGluaXRTZWdtZW50IHRoZSBieXRlcyBvZiB0aGUgaW5pdCBzZWdtZW50XG4gKiBAcmV0dXJucyBhIGhhc2ggb2YgdHJhY2sgdHlwZSB0byB0aW1lc2NhbGUgdmFsdWVzIG9yIG51bGwgaWZcbiAqIHRoZSBpbml0IHNlZ21lbnQgaXMgbWFsZm9ybWVkLlxuICovXG5cbmZ1bmN0aW9uIHBhcnNlSW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IHRyYWtzID0gZmluZEJveChpbml0U2VnbWVudCwgWydtb292JywgJ3RyYWsnXSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdHJha3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0cmFrID0gdHJha3NbaV07XG4gICAgY29uc3QgdGtoZCA9IGZpbmRCb3godHJhaywgWyd0a2hkJ10pWzBdO1xuICAgIGlmICh0a2hkKSB7XG4gICAgICBsZXQgdmVyc2lvbiA9IHRraGRbMF07XG4gICAgICBjb25zdCB0cmFja0lkID0gcmVhZFVpbnQzMih0a2hkLCB2ZXJzaW9uID09PSAwID8gMTIgOiAyMCk7XG4gICAgICBjb25zdCBtZGhkID0gZmluZEJveCh0cmFrLCBbJ21kaWEnLCAnbWRoZCddKVswXTtcbiAgICAgIGlmIChtZGhkKSB7XG4gICAgICAgIHZlcnNpb24gPSBtZGhkWzBdO1xuICAgICAgICBjb25zdCB0aW1lc2NhbGUgPSByZWFkVWludDMyKG1kaGQsIHZlcnNpb24gPT09IDAgPyAxMiA6IDIwKTtcbiAgICAgICAgY29uc3QgaGRsciA9IGZpbmRCb3godHJhaywgWydtZGlhJywgJ2hkbHInXSlbMF07XG4gICAgICAgIGlmIChoZGxyKSB7XG4gICAgICAgICAgY29uc3QgaGRsclR5cGUgPSBiaW4yc3RyKGhkbHIuc3ViYXJyYXkoOCwgMTIpKTtcbiAgICAgICAgICBjb25zdCB0eXBlID0ge1xuICAgICAgICAgICAgc291bjogRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPLFxuICAgICAgICAgICAgdmlkZTogRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPXG4gICAgICAgICAgfVtoZGxyVHlwZV07XG4gICAgICAgICAgLy8gUGFyc2UgY29kZWMgZGV0YWlsc1xuICAgICAgICAgIGNvbnN0IHN0c2RCb3ggPSBmaW5kQm94KHRyYWssIFsnbWRpYScsICdtaW5mJywgJ3N0YmwnLCAnc3RzZCddKVswXTtcbiAgICAgICAgICBjb25zdCBzdHNkID0gcGFyc2VTdHNkKHN0c2RCb3gpO1xuICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICAvLyBBZGQgJ2F1ZGlvJywgJ3ZpZGVvJywgYW5kICdhdWRpb3ZpZGVvJyB0cmFjayByZWNvcmRzIHRoYXQgd2lsbCBtYXAgdG8gU291cmNlQnVmZmVyc1xuICAgICAgICAgICAgcmVzdWx0W3RyYWNrSWRdID0ge1xuICAgICAgICAgICAgICB0aW1lc2NhbGUsXG4gICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgIHN0c2RcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXN1bHRbdHlwZV0gPSBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgICAgIHRpbWVzY2FsZSxcbiAgICAgICAgICAgICAgaWQ6IHRyYWNrSWRcbiAgICAgICAgICAgIH0sIHN0c2QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBBZGQgJ21ldGEnIGFuZCBvdGhlciB0cmFjayByZWNvcmRzXG4gICAgICAgICAgICByZXN1bHRbdHJhY2tJZF0gPSB7XG4gICAgICAgICAgICAgIHRpbWVzY2FsZSxcbiAgICAgICAgICAgICAgdHlwZTogaGRsclR5cGUsXG4gICAgICAgICAgICAgIHN0c2RcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IHRyZXggPSBmaW5kQm94KGluaXRTZWdtZW50LCBbJ21vb3YnLCAnbXZleCcsICd0cmV4J10pO1xuICB0cmV4LmZvckVhY2godHJleCA9PiB7XG4gICAgY29uc3QgdHJhY2tJZCA9IHJlYWRVaW50MzIodHJleCwgNCk7XG4gICAgY29uc3QgdHJhY2sgPSByZXN1bHRbdHJhY2tJZF07XG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICB0cmFjay5kZWZhdWx0ID0ge1xuICAgICAgICBkdXJhdGlvbjogcmVhZFVpbnQzMih0cmV4LCAxMiksXG4gICAgICAgIGZsYWdzOiByZWFkVWludDMyKHRyZXgsIDIwKVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGFyc2VTdHNkKHN0c2QpIHtcbiAgY29uc3Qgc2FtcGxlRW50cmllcyA9IHN0c2Quc3ViYXJyYXkoOCk7XG4gIGNvbnN0IHNhbXBsZUVudHJpZXNFbmQgPSBzYW1wbGVFbnRyaWVzLnN1YmFycmF5KDggKyA3OCk7XG4gIGNvbnN0IGZvdXJDQyA9IGJpbjJzdHIoc2FtcGxlRW50cmllcy5zdWJhcnJheSg0LCA4KSk7XG4gIGxldCBjb2RlYyA9IGZvdXJDQztcbiAgbGV0IHN1cHBsZW1lbnRhbDtcbiAgY29uc3QgZW5jcnlwdGVkID0gZm91ckNDID09PSAnZW5jYScgfHwgZm91ckNDID09PSAnZW5jdic7XG4gIGlmIChlbmNyeXB0ZWQpIHtcbiAgICBjb25zdCBlbmNCb3ggPSBmaW5kQm94KHNhbXBsZUVudHJpZXMsIFtmb3VyQ0NdKVswXTtcbiAgICBjb25zdCBlbmNCb3hDaGlsZHJlbiA9IGVuY0JveC5zdWJhcnJheShmb3VyQ0MgPT09ICdlbmNhJyA/IDI4IDogNzgpO1xuICAgIGNvbnN0IHNpbmZzID0gZmluZEJveChlbmNCb3hDaGlsZHJlbiwgWydzaW5mJ10pO1xuICAgIHNpbmZzLmZvckVhY2goc2luZiA9PiB7XG4gICAgICBjb25zdCBzY2htID0gZmluZEJveChzaW5mLCBbJ3NjaG0nXSlbMF07XG4gICAgICBpZiAoc2NobSkge1xuICAgICAgICBjb25zdCBzY2hlbWUgPSBiaW4yc3RyKHNjaG0uc3ViYXJyYXkoNCwgOCkpO1xuICAgICAgICBpZiAoc2NoZW1lID09PSAnY2JjcycgfHwgc2NoZW1lID09PSAnY2VuYycpIHtcbiAgICAgICAgICBjb25zdCBmcm1hID0gZmluZEJveChzaW5mLCBbJ2ZybWEnXSlbMF07XG4gICAgICAgICAgaWYgKGZybWEpIHtcbiAgICAgICAgICAgIC8vIGZvciBlbmNyeXB0ZWQgY29udGVudCBjb2RlYyBmb3VyQ0Mgd2lsbCBiZSBpbiBmcm1hXG4gICAgICAgICAgICBjb2RlYyA9IGJpbjJzdHIoZnJtYSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgY29kZWNGb3VyQ0MgPSBjb2RlYztcbiAgc3dpdGNoIChjb2RlYykge1xuICAgIGNhc2UgJ2F2YzEnOlxuICAgIGNhc2UgJ2F2YzInOlxuICAgIGNhc2UgJ2F2YzMnOlxuICAgIGNhc2UgJ2F2YzQnOlxuICAgICAge1xuICAgICAgICAvLyBleHRyYWN0IHByb2ZpbGUgKyBjb21wYXRpYmlsaXR5ICsgbGV2ZWwgb3V0IG9mIGF2Y0MgYm94XG4gICAgICAgIGNvbnN0IGF2Y0NCb3ggPSBmaW5kQm94KHNhbXBsZUVudHJpZXNFbmQsIFsnYXZjQyddKVswXTtcbiAgICAgICAgaWYgKGF2Y0NCb3ggJiYgYXZjQ0JveC5sZW5ndGggPiAzKSB7XG4gICAgICAgICAgY29kZWMgKz0gJy4nICsgdG9IZXgoYXZjQ0JveFsxXSkgKyB0b0hleChhdmNDQm94WzJdKSArIHRvSGV4KGF2Y0NCb3hbM10pO1xuICAgICAgICAgIHN1cHBsZW1lbnRhbCA9IHBhcnNlU3VwcGxlbWVudGFsRG9WaUNvZGVjKGNvZGVjRm91ckNDID09PSAnYXZjMScgPyAnZHZhMScgOiAnZHZhdicsIHNhbXBsZUVudHJpZXNFbmQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgJ21wNGEnOlxuICAgICAge1xuICAgICAgICBjb25zdCBjb2RlY0JveCA9IGZpbmRCb3goc2FtcGxlRW50cmllcywgW2ZvdXJDQ10pWzBdO1xuICAgICAgICBjb25zdCBlc2RzQm94ID0gZmluZEJveChjb2RlY0JveC5zdWJhcnJheSgyOCksIFsnZXNkcyddKVswXTtcbiAgICAgICAgaWYgKGVzZHNCb3ggJiYgZXNkc0JveC5sZW5ndGggPiA3KSB7XG4gICAgICAgICAgbGV0IGkgPSA0O1xuICAgICAgICAgIC8vIEVTIERlc2NyaXB0b3IgdGFnXG4gICAgICAgICAgaWYgKGVzZHNCb3hbaSsrXSAhPT0gMHgwMykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGkgPSBza2lwQkVSSW50ZWdlcihlc2RzQm94LCBpKTtcbiAgICAgICAgICBpICs9IDI7IC8vIHNraXAgZXNfaWQ7XG4gICAgICAgICAgY29uc3QgZmxhZ3MgPSBlc2RzQm94W2krK107XG4gICAgICAgICAgaWYgKGZsYWdzICYgMHg4MCkge1xuICAgICAgICAgICAgaSArPSAyOyAvLyBza2lwIGRlcGVuZGVuY3kgZXNfaWRcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZsYWdzICYgMHg0MCkge1xuICAgICAgICAgICAgaSArPSBlc2RzQm94W2krK107IC8vIHNraXAgVVJMXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIERlY29kZXIgY29uZmlnIGRlc2NyaXB0b3JcbiAgICAgICAgICBpZiAoZXNkc0JveFtpKytdICE9PSAweDA0KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaSA9IHNraXBCRVJJbnRlZ2VyKGVzZHNCb3gsIGkpO1xuICAgICAgICAgIGNvbnN0IG9iamVjdFR5cGUgPSBlc2RzQm94W2krK107XG4gICAgICAgICAgaWYgKG9iamVjdFR5cGUgPT09IDB4NDApIHtcbiAgICAgICAgICAgIGNvZGVjICs9ICcuJyArIHRvSGV4KG9iamVjdFR5cGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaSArPSAxMjtcbiAgICAgICAgICAvLyBEZWNvZGVyIHNwZWNpZmljIGluZm9cbiAgICAgICAgICBpZiAoZXNkc0JveFtpKytdICE9PSAweDA1KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaSA9IHNraXBCRVJJbnRlZ2VyKGVzZHNCb3gsIGkpO1xuICAgICAgICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IGVzZHNCb3hbaSsrXTtcbiAgICAgICAgICBsZXQgYXVkaW9PYmplY3RUeXBlID0gKGZpcnN0Qnl0ZSAmIDB4ZjgpID4+IDM7XG4gICAgICAgICAgaWYgKGF1ZGlvT2JqZWN0VHlwZSA9PT0gMzEpIHtcbiAgICAgICAgICAgIGF1ZGlvT2JqZWN0VHlwZSArPSAxICsgKChmaXJzdEJ5dGUgJiAweDcpIDw8IDMpICsgKChlc2RzQm94W2ldICYgMHhlMCkgPj4gNSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvZGVjICs9ICcuJyArIGF1ZGlvT2JqZWN0VHlwZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlICdodmMxJzpcbiAgICBjYXNlICdoZXYxJzpcbiAgICAgIHtcbiAgICAgICAgY29uc3QgaHZjQ0JveCA9IGZpbmRCb3goc2FtcGxlRW50cmllc0VuZCwgWydodmNDJ10pWzBdO1xuICAgICAgICBpZiAoaHZjQ0JveCAmJiBodmNDQm94Lmxlbmd0aCA+IDEyKSB7XG4gICAgICAgICAgY29uc3QgcHJvZmlsZUJ5dGUgPSBodmNDQm94WzFdO1xuICAgICAgICAgIGNvbnN0IHByb2ZpbGVTcGFjZSA9IFsnJywgJ0EnLCAnQicsICdDJ11bcHJvZmlsZUJ5dGUgPj4gNl07XG4gICAgICAgICAgY29uc3QgZ2VuZXJhbFByb2ZpbGVJZGMgPSBwcm9maWxlQnl0ZSAmIDB4MWY7XG4gICAgICAgICAgY29uc3QgcHJvZmlsZUNvbXBhdCA9IHJlYWRVaW50MzIoaHZjQ0JveCwgMik7XG4gICAgICAgICAgY29uc3QgdGllckZsYWcgPSAocHJvZmlsZUJ5dGUgJiAweDIwKSA+PiA1ID8gJ0gnIDogJ0wnO1xuICAgICAgICAgIGNvbnN0IGxldmVsSURDID0gaHZjQ0JveFsxMl07XG4gICAgICAgICAgY29uc3QgY29uc3RyYWludEluZGljYXRvciA9IGh2Y0NCb3guc3ViYXJyYXkoNiwgMTIpO1xuICAgICAgICAgIGNvZGVjICs9ICcuJyArIHByb2ZpbGVTcGFjZSArIGdlbmVyYWxQcm9maWxlSWRjO1xuICAgICAgICAgIGNvZGVjICs9ICcuJyArIHJldmVyc2UzMkJpdEludChwcm9maWxlQ29tcGF0KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICBjb2RlYyArPSAnLicgKyB0aWVyRmxhZyArIGxldmVsSURDO1xuICAgICAgICAgIGxldCBjb25zdHJhaW50U3RyaW5nID0gJyc7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IGNvbnN0cmFpbnRJbmRpY2F0b3IubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICBjb25zdCBieXRlID0gY29uc3RyYWludEluZGljYXRvcltpXTtcbiAgICAgICAgICAgIGlmIChieXRlIHx8IGNvbnN0cmFpbnRTdHJpbmcpIHtcbiAgICAgICAgICAgICAgY29uc3QgZW5jb2RlZEJ5dGUgPSBieXRlLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICBjb25zdHJhaW50U3RyaW5nID0gJy4nICsgZW5jb2RlZEJ5dGUgKyBjb25zdHJhaW50U3RyaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb2RlYyArPSBjb25zdHJhaW50U3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIHN1cHBsZW1lbnRhbCA9IHBhcnNlU3VwcGxlbWVudGFsRG9WaUNvZGVjKGNvZGVjRm91ckNDID09ICdoZXYxJyA/ICdkdmhlJyA6ICdkdmgxJywgc2FtcGxlRW50cmllc0VuZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgJ2R2aDEnOlxuICAgIGNhc2UgJ2R2aGUnOlxuICAgIGNhc2UgJ2R2YXYnOlxuICAgIGNhc2UgJ2R2YTEnOlxuICAgIGNhc2UgJ2RhdjEnOlxuICAgICAge1xuICAgICAgICBjb2RlYyA9IHBhcnNlU3VwcGxlbWVudGFsRG9WaUNvZGVjKGNvZGVjLCBzYW1wbGVFbnRyaWVzRW5kKSB8fCBjb2RlYztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSAndnAwOSc6XG4gICAgICB7XG4gICAgICAgIGNvbnN0IHZwY0NCb3ggPSBmaW5kQm94KHNhbXBsZUVudHJpZXNFbmQsIFsndnBjQyddKVswXTtcbiAgICAgICAgaWYgKHZwY0NCb3ggJiYgdnBjQ0JveC5sZW5ndGggPiA2KSB7XG4gICAgICAgICAgY29uc3QgcHJvZmlsZSA9IHZwY0NCb3hbNF07XG4gICAgICAgICAgY29uc3QgbGV2ZWwgPSB2cGNDQm94WzVdO1xuICAgICAgICAgIGNvbnN0IGJpdERlcHRoID0gdnBjQ0JveFs2XSA+PiA0ICYgMHgwZjtcbiAgICAgICAgICBjb2RlYyArPSAnLicgKyBhZGRMZWFkaW5nWmVybyhwcm9maWxlKSArICcuJyArIGFkZExlYWRpbmdaZXJvKGxldmVsKSArICcuJyArIGFkZExlYWRpbmdaZXJvKGJpdERlcHRoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlICdhdjAxJzpcbiAgICAgIHtcbiAgICAgICAgY29uc3QgYXYxQ0JveCA9IGZpbmRCb3goc2FtcGxlRW50cmllc0VuZCwgWydhdjFDJ10pWzBdO1xuICAgICAgICBpZiAoYXYxQ0JveCAmJiBhdjFDQm94Lmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICBjb25zdCBwcm9maWxlID0gYXYxQ0JveFsxXSA+Pj4gNTtcbiAgICAgICAgICBjb25zdCBsZXZlbCA9IGF2MUNCb3hbMV0gJiAweDFmO1xuICAgICAgICAgIGNvbnN0IHRpZXJGbGFnID0gYXYxQ0JveFsyXSA+Pj4gNyA/ICdIJyA6ICdNJztcbiAgICAgICAgICBjb25zdCBoaWdoQml0RGVwdGggPSAoYXYxQ0JveFsyXSAmIDB4NDApID4+IDY7XG4gICAgICAgICAgY29uc3QgdHdlbHZlQml0ID0gKGF2MUNCb3hbMl0gJiAweDIwKSA+PiA1O1xuICAgICAgICAgIGNvbnN0IGJpdERlcHRoID0gcHJvZmlsZSA9PT0gMiAmJiBoaWdoQml0RGVwdGggPyB0d2VsdmVCaXQgPyAxMiA6IDEwIDogaGlnaEJpdERlcHRoID8gMTAgOiA4O1xuICAgICAgICAgIGNvbnN0IG1vbm9jaHJvbWUgPSAoYXYxQ0JveFsyXSAmIDB4MTApID4+IDQ7XG4gICAgICAgICAgY29uc3QgY2hyb21hU3Vic2FtcGxpbmdYID0gKGF2MUNCb3hbMl0gJiAweDA4KSA+PiAzO1xuICAgICAgICAgIGNvbnN0IGNocm9tYVN1YnNhbXBsaW5nWSA9IChhdjFDQm94WzJdICYgMHgwNCkgPj4gMjtcbiAgICAgICAgICBjb25zdCBjaHJvbWFTYW1wbGVQb3NpdGlvbiA9IGF2MUNCb3hbMl0gJiAweDAzO1xuICAgICAgICAgIC8vIFRPRE86IHBhcnNlIGNvbG9yX2Rlc2NyaXB0aW9uX3ByZXNlbnRfZmxhZ1xuICAgICAgICAgIC8vIGRlZmF1bHQgaXQgdG8gQlQuNzA5L2xpbWl0ZWQgcmFuZ2UgZm9yIG5vd1xuICAgICAgICAgIC8vIG1vcmUgaW5mbyBodHRwczovL2FvbWVkaWFjb2RlYy5naXRodWIuaW8vYXYxLWlzb2JtZmYvI2F2MWNvZGVjY29uZmlndXJhdGlvbmJveC1zeW50YXhcbiAgICAgICAgICBjb25zdCBjb2xvclByaW1hcmllcyA9IDE7XG4gICAgICAgICAgY29uc3QgdHJhbnNmZXJDaGFyYWN0ZXJpc3RpY3MgPSAxO1xuICAgICAgICAgIGNvbnN0IG1hdHJpeENvZWZmaWNpZW50cyA9IDE7XG4gICAgICAgICAgY29uc3QgdmlkZW9GdWxsUmFuZ2VGbGFnID0gMDtcbiAgICAgICAgICBjb2RlYyArPSAnLicgKyBwcm9maWxlICsgJy4nICsgYWRkTGVhZGluZ1plcm8obGV2ZWwpICsgdGllckZsYWcgKyAnLicgKyBhZGRMZWFkaW5nWmVybyhiaXREZXB0aCkgKyAnLicgKyBtb25vY2hyb21lICsgJy4nICsgY2hyb21hU3Vic2FtcGxpbmdYICsgY2hyb21hU3Vic2FtcGxpbmdZICsgY2hyb21hU2FtcGxlUG9zaXRpb24gKyAnLicgKyBhZGRMZWFkaW5nWmVybyhjb2xvclByaW1hcmllcykgKyAnLicgKyBhZGRMZWFkaW5nWmVybyh0cmFuc2ZlckNoYXJhY3RlcmlzdGljcykgKyAnLicgKyBhZGRMZWFkaW5nWmVybyhtYXRyaXhDb2VmZmljaWVudHMpICsgJy4nICsgdmlkZW9GdWxsUmFuZ2VGbGFnO1xuICAgICAgICAgIHN1cHBsZW1lbnRhbCA9IHBhcnNlU3VwcGxlbWVudGFsRG9WaUNvZGVjKCdkYXYxJywgc2FtcGxlRW50cmllc0VuZCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjb2RlYyxcbiAgICBlbmNyeXB0ZWQsXG4gICAgc3VwcGxlbWVudGFsXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZVN1cHBsZW1lbnRhbERvVmlDb2RlYyhmb3VyQ0MsIHNhbXBsZUVudHJpZXNFbmQpIHtcbiAgY29uc3QgZHZ2Q1Jlc3VsdCA9IGZpbmRCb3goc2FtcGxlRW50cmllc0VuZCwgWydkdnZDJ10pOyAvLyB1c2VkIGJ5IERvVmkgUHJvZmlsZSA4IHRvIDEwXG4gIGNvbnN0IGR2WENCb3ggPSBkdnZDUmVzdWx0Lmxlbmd0aCA/IGR2dkNSZXN1bHRbMF0gOiBmaW5kQm94KHNhbXBsZUVudHJpZXNFbmQsIFsnZHZjQyddKVswXTsgLy8gdXNlZCBieSBEb1ZpIFByb2ZpbGVzIHVwIHRvIDcgYW5kIDIwXG4gIGlmIChkdlhDQm94KSB7XG4gICAgY29uc3QgZG9WaVByb2ZpbGUgPSBkdlhDQm94WzJdID4+IDEgJiAweDdmO1xuICAgIGNvbnN0IGRvVmlMZXZlbCA9IGR2WENCb3hbMl0gPDwgNSAmIDB4MjAgfCBkdlhDQm94WzNdID4+IDMgJiAweDFmO1xuICAgIHJldHVybiBmb3VyQ0MgKyAnLicgKyBhZGRMZWFkaW5nWmVybyhkb1ZpUHJvZmlsZSkgKyAnLicgKyBhZGRMZWFkaW5nWmVybyhkb1ZpTGV2ZWwpO1xuICB9XG59XG5mdW5jdGlvbiByZXZlcnNlMzJCaXRJbnQodmFsKSB7XG4gIGxldCByZXN1bHQgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICByZXN1bHQgfD0gKHZhbCA+PiBpICYgMSkgPDwgMzIgLSAxIC0gaTtcbiAgfVxuICByZXR1cm4gcmVzdWx0ID4+PiAwO1xufVxuZnVuY3Rpb24gc2tpcEJFUkludGVnZXIoYnl0ZXMsIGkpIHtcbiAgY29uc3QgbGltaXQgPSBpICsgNTtcbiAgd2hpbGUgKGJ5dGVzW2krK10gJiAweDgwICYmIGkgPCBsaW1pdCkge1xuICAgIC8qIGRvIG5vdGhpbmcgKi9cbiAgfVxuICByZXR1cm4gaTtcbn1cbmZ1bmN0aW9uIHRvSGV4KHgpIHtcbiAgcmV0dXJuICgnMCcgKyB4LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpKS5zbGljZSgtMik7XG59XG5mdW5jdGlvbiBhZGRMZWFkaW5nWmVybyhudW0pIHtcbiAgcmV0dXJuIChudW0gPCAxMCA/ICcwJyA6ICcnKSArIG51bTtcbn1cbmZ1bmN0aW9uIHBhdGNoRW5jeXB0aW9uRGF0YShpbml0U2VnbWVudCwgZGVjcnlwdGRhdGEpIHtcbiAgaWYgKCFpbml0U2VnbWVudCB8fCAhZGVjcnlwdGRhdGEpIHtcbiAgICByZXR1cm4gaW5pdFNlZ21lbnQ7XG4gIH1cbiAgY29uc3Qga2V5SWQgPSBkZWNyeXB0ZGF0YS5rZXlJZDtcbiAgaWYgKGtleUlkICYmIGRlY3J5cHRkYXRhLmlzQ29tbW9uRW5jcnlwdGlvbikge1xuICAgIGNvbnN0IHRyYWtzID0gZmluZEJveChpbml0U2VnbWVudCwgWydtb292JywgJ3RyYWsnXSk7XG4gICAgdHJha3MuZm9yRWFjaCh0cmFrID0+IHtcbiAgICAgIGNvbnN0IHN0c2QgPSBmaW5kQm94KHRyYWssIFsnbWRpYScsICdtaW5mJywgJ3N0YmwnLCAnc3RzZCddKVswXTtcblxuICAgICAgLy8gc2tpcCB0aGUgc2FtcGxlIGVudHJ5IGNvdW50XG4gICAgICBjb25zdCBzYW1wbGVFbnRyaWVzID0gc3RzZC5zdWJhcnJheSg4KTtcbiAgICAgIGxldCBlbmNCb3hlcyA9IGZpbmRCb3goc2FtcGxlRW50cmllcywgWydlbmNhJ10pO1xuICAgICAgY29uc3QgaXNBdWRpbyA9IGVuY0JveGVzLmxlbmd0aCA+IDA7XG4gICAgICBpZiAoIWlzQXVkaW8pIHtcbiAgICAgICAgZW5jQm94ZXMgPSBmaW5kQm94KHNhbXBsZUVudHJpZXMsIFsnZW5jdiddKTtcbiAgICAgIH1cbiAgICAgIGVuY0JveGVzLmZvckVhY2goZW5jID0+IHtcbiAgICAgICAgY29uc3QgZW5jQm94Q2hpbGRyZW4gPSBpc0F1ZGlvID8gZW5jLnN1YmFycmF5KDI4KSA6IGVuYy5zdWJhcnJheSg3OCk7XG4gICAgICAgIGNvbnN0IHNpbmZCb3hlcyA9IGZpbmRCb3goZW5jQm94Q2hpbGRyZW4sIFsnc2luZiddKTtcbiAgICAgICAgc2luZkJveGVzLmZvckVhY2goc2luZiA9PiB7XG4gICAgICAgICAgY29uc3QgdGVuYyA9IHBhcnNlU2luZihzaW5mKTtcbiAgICAgICAgICBpZiAodGVuYykge1xuICAgICAgICAgICAgLy8gTG9vayBmb3IgZGVmYXVsdCBrZXkgaWQgKGtleUlEIG9mZnNldCBpcyBhbHdheXMgOCB3aXRoaW4gdGhlIHRlbmMgYm94KTpcbiAgICAgICAgICAgIGNvbnN0IHRlbmNLZXlJZCA9IHRlbmMuc3ViYXJyYXkoOCwgMjQpO1xuICAgICAgICAgICAgaWYgKCF0ZW5jS2V5SWQuc29tZShiID0+IGIgIT09IDApKSB7XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coYFtlbWVdIFBhdGNoaW5nIGtleUlkIGluICdlbmMke2lzQXVkaW8gPyAnYScgOiAndid9PnNpbmY+PnRlbmMnIGJveDogJHtIZXguaGV4RHVtcCh0ZW5jS2V5SWQpfSAtPiAke0hleC5oZXhEdW1wKGtleUlkKX1gKTtcbiAgICAgICAgICAgICAgdGVuYy5zZXQoa2V5SWQsIDgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gaW5pdFNlZ21lbnQ7XG59XG5mdW5jdGlvbiBwYXJzZVNpbmYoc2luZikge1xuICBjb25zdCBzY2htID0gZmluZEJveChzaW5mLCBbJ3NjaG0nXSlbMF07XG4gIGlmIChzY2htKSB7XG4gICAgY29uc3Qgc2NoZW1lID0gYmluMnN0cihzY2htLnN1YmFycmF5KDQsIDgpKTtcbiAgICBpZiAoc2NoZW1lID09PSAnY2JjcycgfHwgc2NoZW1lID09PSAnY2VuYycpIHtcbiAgICAgIHJldHVybiBmaW5kQm94KHNpbmYsIFsnc2NoaScsICd0ZW5jJ10pWzBdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLypcbiAgRm9yIFJlZmVyZW5jZTpcbiAgYWxpZ25lZCg4KSBjbGFzcyBUcmFja0ZyYWdtZW50SGVhZGVyQm94XG4gICAgICAgICAgIGV4dGVuZHMgRnVsbEJveCjigJh0Zmhk4oCZLCAwLCB0Zl9mbGFncyl7XG4gICAgIHVuc2lnbmVkIGludCgzMikgIHRyYWNrX0lEO1xuICAgICAvLyBhbGwgdGhlIGZvbGxvd2luZyBhcmUgb3B0aW9uYWwgZmllbGRzXG4gICAgIHVuc2lnbmVkIGludCg2NCkgIGJhc2VfZGF0YV9vZmZzZXQ7XG4gICAgIHVuc2lnbmVkIGludCgzMikgIHNhbXBsZV9kZXNjcmlwdGlvbl9pbmRleDtcbiAgICAgdW5zaWduZWQgaW50KDMyKSAgZGVmYXVsdF9zYW1wbGVfZHVyYXRpb247XG4gICAgIHVuc2lnbmVkIGludCgzMikgIGRlZmF1bHRfc2FtcGxlX3NpemU7XG4gICAgIHVuc2lnbmVkIGludCgzMikgIGRlZmF1bHRfc2FtcGxlX2ZsYWdzXG4gIH1cbiAqL1xuXG5mdW5jdGlvbiBnZXRTYW1wbGVEYXRhKGRhdGEsIGluaXREYXRhLCBsb2dnZXIpIHtcbiAgY29uc3QgdHJhY2tzID0ge307XG4gIGNvbnN0IHRyYWZzID0gZmluZEJveChkYXRhLCBbJ21vb2YnLCAndHJhZiddKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFmcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRyYWYgPSB0cmFmc1tpXTtcbiAgICAvLyBUaGVyZSBpcyBvbmx5IG9uZSB0ZmhkICYgdHJ1biBwZXIgdHJhZlxuICAgIC8vIFRoaXMgaXMgdHJ1ZSBmb3IgQ01BRiBzdHlsZSBjb250ZW50LCBhbmQgd2Ugc2hvdWxkIHBlcmhhcHMgY2hlY2sgdGhlIGZ0eXBcbiAgICAvLyBhbmQgb25seSBsb29rIGZvciBhIHNpbmdsZSB0cnVuIHRoZW4sIGJ1dCBmb3IgSVNPQk1GRiB3ZSBzaG91bGQgY2hlY2tcbiAgICAvLyBmb3IgbXVsdGlwbGUgdHJhY2sgcnVucy5cbiAgICBjb25zdCB0ZmhkID0gZmluZEJveCh0cmFmLCBbJ3RmaGQnXSlbMF07XG4gICAgLy8gZ2V0IHRoZSB0cmFjayBpZCBmcm9tIHRoZSB0ZmhkXG4gICAgY29uc3QgaWQgPSByZWFkVWludDMyKHRmaGQsIDQpO1xuICAgIGNvbnN0IHRyYWNrID0gaW5pdERhdGFbaWRdO1xuICAgIGlmICghdHJhY2spIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB0cmFja1RpbWVzID0gdHJhY2tzW2lkXSB8fCAodHJhY2tzW2lkXSA9IHtcbiAgICAgIHN0YXJ0OiBOYU4sXG4gICAgICBkdXJhdGlvbjogMCxcbiAgICAgIHNhbXBsZUNvdW50OiAwLFxuICAgICAgdGltZXNjYWxlOiB0cmFjay50aW1lc2NhbGUsXG4gICAgICB0eXBlOiB0cmFjay50eXBlXG4gICAgfSk7XG4gICAgLy8gZ2V0IHN0YXJ0IERUU1xuICAgIGNvbnN0IHRmZHQgPSBmaW5kQm94KHRyYWYsIFsndGZkdCddKVswXTtcbiAgICBpZiAodGZkdCkge1xuICAgICAgY29uc3QgdmVyc2lvbiA9IHRmZHRbMF07XG4gICAgICBsZXQgYmFzZVRpbWUgPSByZWFkVWludDMyKHRmZHQsIDQpO1xuICAgICAgaWYgKHZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgLy8gSWYgdmFsdWUgaXMgdG9vIGxhcmdlLCBhc3N1bWUgc2lnbmVkIDY0LWJpdC4gTmVnYXRpdmUgdHJhY2sgZnJhZ21lbnQgZGVjb2RlIHRpbWVzIGFyZSBpbnZhbGlkLCBidXQgdGhleSBleGlzdCBpbiB0aGUgd2lsZC5cbiAgICAgICAgLy8gVGhpcyBwcmV2ZW50cyBsYXJnZSB2YWx1ZXMgZnJvbSBiZWluZyB1c2VkIGZvciBpbml0UFRTLCB3aGljaCBjYW4gY2F1c2UgcGxheWxpc3Qgc3luYyBpc3N1ZXMuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy81MzAzXG4gICAgICAgIGlmIChiYXNlVGltZSA9PT0gVUlOVDMyX01BWCQxKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYFttcDQtZGVtdXhlcl06IElnbm9yaW5nIGFzc3VtZWQgaW52YWxpZCBzaWduZWQgNjQtYml0IHRyYWNrIGZyYWdtZW50IGRlY29kZSB0aW1lYCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmFzZVRpbWUgKj0gVUlOVDMyX01BWCQxICsgMTtcbiAgICAgICAgICBiYXNlVGltZSArPSByZWFkVWludDMyKHRmZHQsIDgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNGaW5pdGVOdW1iZXIoYmFzZVRpbWUpICYmICghaXNGaW5pdGVOdW1iZXIodHJhY2tUaW1lcy5zdGFydCkgfHwgYmFzZVRpbWUgPCB0cmFja1RpbWVzLnN0YXJ0KSkge1xuICAgICAgICB0cmFja1RpbWVzLnN0YXJ0ID0gYmFzZVRpbWU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRyYWNrRGVmYXVsdCA9IHRyYWNrLmRlZmF1bHQ7XG4gICAgY29uc3QgdGZoZEZsYWdzID0gcmVhZFVpbnQzMih0ZmhkLCAwKSB8ICh0cmFja0RlZmF1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHRyYWNrRGVmYXVsdC5mbGFncyk7XG4gICAgbGV0IGRlZmF1bHRTYW1wbGVEdXJhdGlvbiA9ICh0cmFja0RlZmF1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHRyYWNrRGVmYXVsdC5kdXJhdGlvbikgfHwgMDtcbiAgICBpZiAodGZoZEZsYWdzICYgMHgwMDAwMDgpIHtcbiAgICAgIC8vIDB4MDAwMDA4IGluZGljYXRlcyB0aGUgcHJlc2VuY2Ugb2YgdGhlIGRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uIGZpZWxkXG4gICAgICBpZiAodGZoZEZsYWdzICYgMHgwMDAwMDIpIHtcbiAgICAgICAgLy8gMHgwMDAwMDIgaW5kaWNhdGVzIHRoZSBwcmVzZW5jZSBvZiB0aGUgc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4IGZpZWxkLCB3aGljaCBwcmVjZWRlcyBkZWZhdWx0X3NhbXBsZV9kdXJhdGlvblxuICAgICAgICAvLyBJZiBwcmVzZW50LCB0aGUgZGVmYXVsdF9zYW1wbGVfZHVyYXRpb24gZXhpc3RzIGF0IGJ5dGUgb2Zmc2V0IDEyXG4gICAgICAgIGRlZmF1bHRTYW1wbGVEdXJhdGlvbiA9IHJlYWRVaW50MzIodGZoZCwgMTIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgZHVyYXRpb24gaXMgYXQgYnl0ZSBvZmZzZXQgOFxuICAgICAgICBkZWZhdWx0U2FtcGxlRHVyYXRpb24gPSByZWFkVWludDMyKHRmaGQsIDgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0cnVucyA9IGZpbmRCb3godHJhZiwgWyd0cnVuJ10pO1xuICAgIGxldCBzYW1wbGVEVFMgPSB0cmFja1RpbWVzLnN0YXJ0IHx8IDA7XG4gICAgbGV0IHJhd0R1cmF0aW9uID0gMDtcbiAgICBsZXQgc2FtcGxlRHVyYXRpb24gPSBkZWZhdWx0U2FtcGxlRHVyYXRpb247XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB0cnVucy5sZW5ndGg7IGorKykge1xuICAgICAgY29uc3QgdHJ1biA9IHRydW5zW2pdO1xuICAgICAgY29uc3Qgc2FtcGxlQ291bnQgPSByZWFkVWludDMyKHRydW4sIDQpO1xuICAgICAgY29uc3Qgc2FtcGxlSW5kZXggPSB0cmFja1RpbWVzLnNhbXBsZUNvdW50O1xuICAgICAgdHJhY2tUaW1lcy5zYW1wbGVDb3VudCArPSBzYW1wbGVDb3VudDtcbiAgICAgIC8vIEdldCBkdXJhdGlvbiBmcm9tIHNhbXBsZXNcbiAgICAgIGNvbnN0IGRhdGFPZmZzZXRQcmVzZW50ID0gdHJ1blszXSAmIDB4MDE7XG4gICAgICBjb25zdCBmaXJzdFNhbXBsZUZsYWdzUHJlc2VudCA9IHRydW5bM10gJiAweDA0O1xuICAgICAgY29uc3Qgc2FtcGxlRHVyYXRpb25QcmVzZW50ID0gdHJ1blsyXSAmIDB4MDE7XG4gICAgICBjb25zdCBzYW1wbGVTaXplUHJlc2VudCA9IHRydW5bMl0gJiAweDAyO1xuICAgICAgY29uc3Qgc2FtcGxlRmxhZ3NQcmVzZW50ID0gdHJ1blsyXSAmIDB4MDQ7XG4gICAgICBjb25zdCBzYW1wbGVDb21wb3NpdGlvblRpbWVPZmZzZXRQcmVzZW50ID0gdHJ1blsyXSAmIDB4MDg7XG4gICAgICBsZXQgb2Zmc2V0ID0gODtcbiAgICAgIGxldCByZW1haW5pbmcgPSBzYW1wbGVDb3VudDtcbiAgICAgIGlmIChkYXRhT2Zmc2V0UHJlc2VudCkge1xuICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgIH1cbiAgICAgIGlmIChmaXJzdFNhbXBsZUZsYWdzUHJlc2VudCAmJiBzYW1wbGVDb3VudCkge1xuICAgICAgICBjb25zdCBpc05vblN5bmNTYW1wbGUgPSB0cnVuW29mZnNldCArIDFdICYgMHgwMTtcbiAgICAgICAgaWYgKCFpc05vblN5bmNTYW1wbGUgJiYgdHJhY2tUaW1lcy5rZXlGcmFtZUluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0cmFja1RpbWVzLmtleUZyYW1lSW5kZXggPSBzYW1wbGVJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgaWYgKHNhbXBsZUR1cmF0aW9uUHJlc2VudCkge1xuICAgICAgICAgIHNhbXBsZUR1cmF0aW9uID0gcmVhZFVpbnQzMih0cnVuLCBvZmZzZXQpO1xuICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNhbXBsZUR1cmF0aW9uID0gZGVmYXVsdFNhbXBsZUR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzYW1wbGVTaXplUHJlc2VudCkge1xuICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzYW1wbGVDb21wb3NpdGlvblRpbWVPZmZzZXRQcmVzZW50KSB7XG4gICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgc2FtcGxlRFRTICs9IHNhbXBsZUR1cmF0aW9uO1xuICAgICAgICByYXdEdXJhdGlvbiArPSBzYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgcmVtYWluaW5nLS07XG4gICAgICB9XG4gICAgICB3aGlsZSAocmVtYWluaW5nLS0pIHtcbiAgICAgICAgaWYgKHNhbXBsZUR1cmF0aW9uUHJlc2VudCkge1xuICAgICAgICAgIHNhbXBsZUR1cmF0aW9uID0gcmVhZFVpbnQzMih0cnVuLCBvZmZzZXQpO1xuICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNhbXBsZUR1cmF0aW9uID0gZGVmYXVsdFNhbXBsZUR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzYW1wbGVTaXplUHJlc2VudCkge1xuICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzYW1wbGVGbGFnc1ByZXNlbnQpIHtcbiAgICAgICAgICBjb25zdCBpc05vblN5bmNTYW1wbGUgPSB0cnVuW29mZnNldCArIDFdICYgMHgwMTtcbiAgICAgICAgICBpZiAoIWlzTm9uU3luY1NhbXBsZSkge1xuICAgICAgICAgICAgaWYgKHRyYWNrVGltZXMua2V5RnJhbWVJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHRyYWNrVGltZXMua2V5RnJhbWVJbmRleCA9IHRyYWNrVGltZXMuc2FtcGxlQ291bnQgLSAocmVtYWluaW5nICsgMSk7XG4gICAgICAgICAgICAgIHRyYWNrVGltZXMua2V5RnJhbWVTdGFydCA9IHNhbXBsZURUUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNhbXBsZUNvbXBvc2l0aW9uVGltZU9mZnNldFByZXNlbnQpIHtcbiAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgfVxuICAgICAgICBzYW1wbGVEVFMgKz0gc2FtcGxlRHVyYXRpb247XG4gICAgICAgIHJhd0R1cmF0aW9uICs9IHNhbXBsZUR1cmF0aW9uO1xuICAgICAgfVxuICAgICAgaWYgKCFyYXdEdXJhdGlvbiAmJiBkZWZhdWx0U2FtcGxlRHVyYXRpb24pIHtcbiAgICAgICAgcmF3RHVyYXRpb24gKz0gZGVmYXVsdFNhbXBsZUR1cmF0aW9uICogc2FtcGxlQ291bnQ7XG4gICAgICB9XG4gICAgfVxuICAgIHRyYWNrVGltZXMuZHVyYXRpb24gKz0gcmF3RHVyYXRpb247XG4gIH1cbiAgaWYgKCFPYmplY3Qua2V5cyh0cmFja3MpLnNvbWUodHJhY2tJZCA9PiB0cmFja3NbdHJhY2tJZF0uZHVyYXRpb24pKSB7XG4gICAgLy8gSWYgZHVyYXRpb24gc2FtcGxlcyBhcmUgbm90IGF2YWlsYWJsZSBpbiB0aGUgdHJhZiB1c2Ugc2lkeCBzdWJzZWdtZW50X2R1cmF0aW9uXG4gICAgbGV0IHNpZHhNaW5TdGFydCA9IEluZmluaXR5O1xuICAgIGxldCBzaWR4TWF4RW5kID0gMDtcbiAgICBjb25zdCBzaWR4cyA9IGZpbmRCb3goZGF0YSwgWydzaWR4J10pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lkeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHNpZHggPSBwYXJzZVNlZ21lbnRJbmRleChzaWR4c1tpXSk7XG4gICAgICBpZiAoc2lkeCAhPSBudWxsICYmIHNpZHgucmVmZXJlbmNlcykge1xuICAgICAgICBzaWR4TWluU3RhcnQgPSBNYXRoLm1pbihzaWR4TWluU3RhcnQsIHNpZHguZWFybGllc3RQcmVzZW50YXRpb25UaW1lIC8gc2lkeC50aW1lc2NhbGUpO1xuICAgICAgICBjb25zdCBzdWJTZWdtZW50RHVyYXRpb24gPSBzaWR4LnJlZmVyZW5jZXMucmVkdWNlKChkdXIsIHJlZikgPT4gZHVyICsgcmVmLmluZm8uZHVyYXRpb24gfHwgMCwgMCk7XG4gICAgICAgIHNpZHhNYXhFbmQgPSBNYXRoLm1heChzaWR4TWF4RW5kLCBzdWJTZWdtZW50RHVyYXRpb24gKyBzaWR4LmVhcmxpZXN0UHJlc2VudGF0aW9uVGltZSAvIHNpZHgudGltZXNjYWxlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNpZHhNYXhFbmQgJiYgaXNGaW5pdGVOdW1iZXIoc2lkeE1heEVuZCkpIHtcbiAgICAgIE9iamVjdC5rZXlzKHRyYWNrcykuZm9yRWFjaCh0cmFja0lkID0+IHtcbiAgICAgICAgaWYgKCF0cmFja3NbdHJhY2tJZF0uZHVyYXRpb24pIHtcbiAgICAgICAgICB0cmFja3NbdHJhY2tJZF0uZHVyYXRpb24gPSBzaWR4TWF4RW5kICogdHJhY2tzW3RyYWNrSWRdLnRpbWVzY2FsZSAtIHRyYWNrc1t0cmFja0lkXS5zdGFydDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cmFja3M7XG59XG5cbi8vIFRPRE86IENoZWNrIGlmIHRoZSBsYXN0IG1vb2YrbWRhdCBwYWlyIGlzIHBhcnQgb2YgdGhlIHZhbGlkIHJhbmdlXG5mdW5jdGlvbiBzZWdtZW50VmFsaWRSYW5nZShkYXRhKSB7XG4gIGNvbnN0IHNlZ21lbnRlZFJhbmdlID0ge1xuICAgIHZhbGlkOiBudWxsLFxuICAgIHJlbWFpbmRlcjogbnVsbFxuICB9O1xuICBjb25zdCBtb29mcyA9IGZpbmRCb3goZGF0YSwgWydtb29mJ10pO1xuICBpZiAobW9vZnMubGVuZ3RoIDwgMikge1xuICAgIHNlZ21lbnRlZFJhbmdlLnJlbWFpbmRlciA9IGRhdGE7XG4gICAgcmV0dXJuIHNlZ21lbnRlZFJhbmdlO1xuICB9XG4gIGNvbnN0IGxhc3QgPSBtb29mc1ttb29mcy5sZW5ndGggLSAxXTtcbiAgLy8gT2Zmc2V0IGJ5IDggYnl0ZXM7IGZpbmRCb3ggb2Zmc2V0cyB0aGUgc3RhcnQgYnkgYXMgbXVjaFxuICBzZWdtZW50ZWRSYW5nZS52YWxpZCA9IGRhdGEuc2xpY2UoMCwgbGFzdC5ieXRlT2Zmc2V0IC0gOCk7XG4gIHNlZ21lbnRlZFJhbmdlLnJlbWFpbmRlciA9IGRhdGEuc2xpY2UobGFzdC5ieXRlT2Zmc2V0IC0gOCk7XG4gIHJldHVybiBzZWdtZW50ZWRSYW5nZTtcbn1cbmZ1bmN0aW9uIGFwcGVuZFVpbnQ4QXJyYXkoZGF0YTEsIGRhdGEyKSB7XG4gIGNvbnN0IHRlbXAgPSBuZXcgVWludDhBcnJheShkYXRhMS5sZW5ndGggKyBkYXRhMi5sZW5ndGgpO1xuICB0ZW1wLnNldChkYXRhMSk7XG4gIHRlbXAuc2V0KGRhdGEyLCBkYXRhMS5sZW5ndGgpO1xuICByZXR1cm4gdGVtcDtcbn1cbmZ1bmN0aW9uIHBhcnNlU2FtcGxlcyh0aW1lT2Zmc2V0LCB0cmFjaykge1xuICBjb25zdCBzZWlTYW1wbGVzID0gW107XG4gIGNvbnN0IHZpZGVvRGF0YSA9IHRyYWNrLnNhbXBsZXM7XG4gIGNvbnN0IHRpbWVzY2FsZSA9IHRyYWNrLnRpbWVzY2FsZTtcbiAgY29uc3QgdHJhY2tJZCA9IHRyYWNrLmlkO1xuICBsZXQgaXNIRVZDRmxhdm9yID0gZmFsc2U7XG4gIGNvbnN0IG1vb2ZzID0gZmluZEJveCh2aWRlb0RhdGEsIFsnbW9vZiddKTtcbiAgbW9vZnMubWFwKG1vb2YgPT4ge1xuICAgIGNvbnN0IG1vb2ZPZmZzZXQgPSBtb29mLmJ5dGVPZmZzZXQgLSA4O1xuICAgIGNvbnN0IHRyYWZzID0gZmluZEJveChtb29mLCBbJ3RyYWYnXSk7XG4gICAgdHJhZnMubWFwKHRyYWYgPT4ge1xuICAgICAgLy8gZ2V0IHRoZSBiYXNlIG1lZGlhIGRlY29kZSB0aW1lIGZyb20gdGhlIHRmZHRcbiAgICAgIGNvbnN0IGJhc2VUaW1lID0gZmluZEJveCh0cmFmLCBbJ3RmZHQnXSkubWFwKHRmZHQgPT4ge1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gdGZkdFswXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHJlYWRVaW50MzIodGZkdCwgNCk7XG4gICAgICAgIGlmICh2ZXJzaW9uID09PSAxKSB7XG4gICAgICAgICAgcmVzdWx0ICo9IE1hdGgucG93KDIsIDMyKTtcbiAgICAgICAgICByZXN1bHQgKz0gcmVhZFVpbnQzMih0ZmR0LCA4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0IC8gdGltZXNjYWxlO1xuICAgICAgfSlbMF07XG4gICAgICBpZiAoYmFzZVRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aW1lT2Zmc2V0ID0gYmFzZVRpbWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmluZEJveCh0cmFmLCBbJ3RmaGQnXSkubWFwKHRmaGQgPT4ge1xuICAgICAgICBjb25zdCBpZCA9IHJlYWRVaW50MzIodGZoZCwgNCk7XG4gICAgICAgIGNvbnN0IHRmaGRGbGFncyA9IHJlYWRVaW50MzIodGZoZCwgMCkgJiAweGZmZmZmZjtcbiAgICAgICAgY29uc3QgYmFzZURhdGFPZmZzZXRQcmVzZW50ID0gKHRmaGRGbGFncyAmIDB4MDAwMDAxKSAhPT0gMDtcbiAgICAgICAgY29uc3Qgc2FtcGxlRGVzY3JpcHRpb25JbmRleFByZXNlbnQgPSAodGZoZEZsYWdzICYgMHgwMDAwMDIpICE9PSAwO1xuICAgICAgICBjb25zdCBkZWZhdWx0U2FtcGxlRHVyYXRpb25QcmVzZW50ID0gKHRmaGRGbGFncyAmIDB4MDAwMDA4KSAhPT0gMDtcbiAgICAgICAgbGV0IGRlZmF1bHRTYW1wbGVEdXJhdGlvbiA9IDA7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRTYW1wbGVTaXplUHJlc2VudCA9ICh0ZmhkRmxhZ3MgJiAweDAwMDAxMCkgIT09IDA7XG4gICAgICAgIGxldCBkZWZhdWx0U2FtcGxlU2l6ZSA9IDA7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRTYW1wbGVGbGFnc1ByZXNlbnQgPSAodGZoZEZsYWdzICYgMHgwMDAwMjApICE9PSAwO1xuICAgICAgICBsZXQgdGZoZE9mZnNldCA9IDg7XG4gICAgICAgIGlmIChpZCA9PT0gdHJhY2tJZCkge1xuICAgICAgICAgIGlmIChiYXNlRGF0YU9mZnNldFByZXNlbnQpIHtcbiAgICAgICAgICAgIHRmaGRPZmZzZXQgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNhbXBsZURlc2NyaXB0aW9uSW5kZXhQcmVzZW50KSB7XG4gICAgICAgICAgICB0ZmhkT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZWZhdWx0U2FtcGxlRHVyYXRpb25QcmVzZW50KSB7XG4gICAgICAgICAgICBkZWZhdWx0U2FtcGxlRHVyYXRpb24gPSByZWFkVWludDMyKHRmaGQsIHRmaGRPZmZzZXQpO1xuICAgICAgICAgICAgdGZoZE9mZnNldCArPSA0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGVmYXVsdFNhbXBsZVNpemVQcmVzZW50KSB7XG4gICAgICAgICAgICBkZWZhdWx0U2FtcGxlU2l6ZSA9IHJlYWRVaW50MzIodGZoZCwgdGZoZE9mZnNldCk7XG4gICAgICAgICAgICB0ZmhkT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZWZhdWx0U2FtcGxlRmxhZ3NQcmVzZW50KSB7XG4gICAgICAgICAgICB0ZmhkT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0cmFjay50eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgICBpc0hFVkNGbGF2b3IgPSBpc0hFVkModHJhY2suY29kZWMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmaW5kQm94KHRyYWYsIFsndHJ1biddKS5tYXAodHJ1biA9PiB7XG4gICAgICAgICAgICBjb25zdCB2ZXJzaW9uID0gdHJ1blswXTtcbiAgICAgICAgICAgIGNvbnN0IGZsYWdzID0gcmVhZFVpbnQzMih0cnVuLCAwKSAmIDB4ZmZmZmZmO1xuICAgICAgICAgICAgY29uc3QgZGF0YU9mZnNldFByZXNlbnQgPSAoZmxhZ3MgJiAweDAwMDAwMSkgIT09IDA7XG4gICAgICAgICAgICBsZXQgZGF0YU9mZnNldCA9IDA7XG4gICAgICAgICAgICBjb25zdCBmaXJzdFNhbXBsZUZsYWdzUHJlc2VudCA9IChmbGFncyAmIDB4MDAwMDA0KSAhPT0gMDtcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZUR1cmF0aW9uUHJlc2VudCA9IChmbGFncyAmIDB4MDAwMTAwKSAhPT0gMDtcbiAgICAgICAgICAgIGxldCBzYW1wbGVEdXJhdGlvbiA9IDA7XG4gICAgICAgICAgICBjb25zdCBzYW1wbGVTaXplUHJlc2VudCA9IChmbGFncyAmIDB4MDAwMjAwKSAhPT0gMDtcbiAgICAgICAgICAgIGxldCBzYW1wbGVTaXplID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZUZsYWdzUHJlc2VudCA9IChmbGFncyAmIDB4MDAwNDAwKSAhPT0gMDtcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZUNvbXBvc2l0aW9uT2Zmc2V0c1ByZXNlbnQgPSAoZmxhZ3MgJiAweDAwMDgwMCkgIT09IDA7XG4gICAgICAgICAgICBsZXQgY29tcG9zaXRpb25PZmZzZXQgPSAwO1xuICAgICAgICAgICAgY29uc3Qgc2FtcGxlQ291bnQgPSByZWFkVWludDMyKHRydW4sIDQpO1xuICAgICAgICAgICAgbGV0IHRydW5PZmZzZXQgPSA4OyAvLyBwYXN0IHZlcnNpb24sIGZsYWdzLCBhbmQgc2FtcGxlIGNvdW50XG5cbiAgICAgICAgICAgIGlmIChkYXRhT2Zmc2V0UHJlc2VudCkge1xuICAgICAgICAgICAgICBkYXRhT2Zmc2V0ID0gcmVhZFVpbnQzMih0cnVuLCB0cnVuT2Zmc2V0KTtcbiAgICAgICAgICAgICAgdHJ1bk9mZnNldCArPSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpcnN0U2FtcGxlRmxhZ3NQcmVzZW50KSB7XG4gICAgICAgICAgICAgIHRydW5PZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzYW1wbGVPZmZzZXQgPSBkYXRhT2Zmc2V0ICsgbW9vZk9mZnNldDtcbiAgICAgICAgICAgIGZvciAobGV0IGl4ID0gMDsgaXggPCBzYW1wbGVDb3VudDsgaXgrKykge1xuICAgICAgICAgICAgICBpZiAoc2FtcGxlRHVyYXRpb25QcmVzZW50KSB7XG4gICAgICAgICAgICAgICAgc2FtcGxlRHVyYXRpb24gPSByZWFkVWludDMyKHRydW4sIHRydW5PZmZzZXQpO1xuICAgICAgICAgICAgICAgIHRydW5PZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzYW1wbGVEdXJhdGlvbiA9IGRlZmF1bHRTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoc2FtcGxlU2l6ZVByZXNlbnQpIHtcbiAgICAgICAgICAgICAgICBzYW1wbGVTaXplID0gcmVhZFVpbnQzMih0cnVuLCB0cnVuT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB0cnVuT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2FtcGxlU2l6ZSA9IGRlZmF1bHRTYW1wbGVTaXplO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzYW1wbGVGbGFnc1ByZXNlbnQpIHtcbiAgICAgICAgICAgICAgICB0cnVuT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHNhbXBsZUNvbXBvc2l0aW9uT2Zmc2V0c1ByZXNlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyc2lvbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgY29tcG9zaXRpb25PZmZzZXQgPSByZWFkVWludDMyKHRydW4sIHRydW5PZmZzZXQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjb21wb3NpdGlvbk9mZnNldCA9IHJlYWRTaW50MzIodHJ1biwgdHJ1bk9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRydW5PZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodHJhY2sudHlwZSA9PT0gRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5hbHVUb3RhbFNpemUgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChuYWx1VG90YWxTaXplIDwgc2FtcGxlU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbmFsdVNpemUgPSByZWFkVWludDMyKHZpZGVvRGF0YSwgc2FtcGxlT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgIHNhbXBsZU9mZnNldCArPSA0O1xuICAgICAgICAgICAgICAgICAgaWYgKGlzU0VJTWVzc2FnZShpc0hFVkNGbGF2b3IsIHZpZGVvRGF0YVtzYW1wbGVPZmZzZXRdKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gdmlkZW9EYXRhLnN1YmFycmF5KHNhbXBsZU9mZnNldCwgc2FtcGxlT2Zmc2V0ICsgbmFsdVNpemUpO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZVNFSU1lc3NhZ2VGcm9tTkFMdShkYXRhLCBpc0hFVkNGbGF2b3IgPyAyIDogMSwgdGltZU9mZnNldCArIGNvbXBvc2l0aW9uT2Zmc2V0IC8gdGltZXNjYWxlLCBzZWlTYW1wbGVzKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHNhbXBsZU9mZnNldCArPSBuYWx1U2l6ZTtcbiAgICAgICAgICAgICAgICAgIG5hbHVUb3RhbFNpemUgKz0gbmFsdVNpemUgKyA0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aW1lT2Zmc2V0ICs9IHNhbXBsZUR1cmF0aW9uIC8gdGltZXNjYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBzZWlTYW1wbGVzO1xufVxuZnVuY3Rpb24gaXNIRVZDKGNvZGVjKSB7XG4gIGlmICghY29kZWMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgYmFzZUNvZGVjID0gY29kZWMuc3Vic3RyaW5nKDAsIDQpO1xuICByZXR1cm4gYmFzZUNvZGVjID09PSAnaHZjMScgfHwgYmFzZUNvZGVjID09PSAnaGV2MScgfHxcbiAgLy8gRG9sYnkgVmlzaW9uXG4gIGJhc2VDb2RlYyA9PT0gJ2R2aDEnIHx8IGJhc2VDb2RlYyA9PT0gJ2R2aGUnO1xufVxuZnVuY3Rpb24gaXNTRUlNZXNzYWdlKGlzSEVWQ0ZsYXZvciwgbmFsdUhlYWRlcikge1xuICBpZiAoaXNIRVZDRmxhdm9yKSB7XG4gICAgY29uc3QgbmFsdVR5cGUgPSBuYWx1SGVhZGVyID4+IDEgJiAweDNmO1xuICAgIHJldHVybiBuYWx1VHlwZSA9PT0gMzkgfHwgbmFsdVR5cGUgPT09IDQwO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG5hbHVUeXBlID0gbmFsdUhlYWRlciAmIDB4MWY7XG4gICAgcmV0dXJuIG5hbHVUeXBlID09PSA2O1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZVNFSU1lc3NhZ2VGcm9tTkFMdSh1bmVzY2FwZWREYXRhLCBoZWFkZXJTaXplLCBwdHMsIHNhbXBsZXMpIHtcbiAgY29uc3QgZGF0YSA9IGRpc2NhcmRFUEIodW5lc2NhcGVkRGF0YSk7XG4gIGxldCBzZWlQdHIgPSAwO1xuICAvLyBza2lwIG5hbCBoZWFkZXJcbiAgc2VpUHRyICs9IGhlYWRlclNpemU7XG4gIGxldCBwYXlsb2FkVHlwZSA9IDA7XG4gIGxldCBwYXlsb2FkU2l6ZSA9IDA7XG4gIGxldCBiID0gMDtcbiAgd2hpbGUgKHNlaVB0ciA8IGRhdGEubGVuZ3RoKSB7XG4gICAgcGF5bG9hZFR5cGUgPSAwO1xuICAgIGRvIHtcbiAgICAgIGlmIChzZWlQdHIgPj0gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBiID0gZGF0YVtzZWlQdHIrK107XG4gICAgICBwYXlsb2FkVHlwZSArPSBiO1xuICAgIH0gd2hpbGUgKGIgPT09IDB4ZmYpO1xuXG4gICAgLy8gUGFyc2UgcGF5bG9hZCBzaXplLlxuICAgIHBheWxvYWRTaXplID0gMDtcbiAgICBkbyB7XG4gICAgICBpZiAoc2VpUHRyID49IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYiA9IGRhdGFbc2VpUHRyKytdO1xuICAgICAgcGF5bG9hZFNpemUgKz0gYjtcbiAgICB9IHdoaWxlIChiID09PSAweGZmKTtcbiAgICBjb25zdCBsZWZ0T3ZlciA9IGRhdGEubGVuZ3RoIC0gc2VpUHRyO1xuICAgIC8vIENyZWF0ZSBhIHZhcmlhYmxlIHRvIHByb2Nlc3MgdGhlIHBheWxvYWRcbiAgICBsZXQgcGF5UHRyID0gc2VpUHRyO1xuXG4gICAgLy8gSW5jcmVtZW50IHRoZSBzZWlQdHIgdG8gdGhlIGVuZCBvZiB0aGUgcGF5bG9hZFxuICAgIGlmIChwYXlsb2FkU2l6ZSA8IGxlZnRPdmVyKSB7XG4gICAgICBzZWlQdHIgKz0gcGF5bG9hZFNpemU7XG4gICAgfSBlbHNlIGlmIChwYXlsb2FkU2l6ZSA+IGxlZnRPdmVyKSB7XG4gICAgICAvLyBTb21lIHR5cGUgb2YgY29ycnVwdGlvbiBoYXMgaGFwcGVuZWQ/XG4gICAgICBsb2dnZXIuZXJyb3IoYE1hbGZvcm1lZCBTRUkgcGF5bG9hZC4gJHtwYXlsb2FkU2l6ZX0gaXMgdG9vIHNtYWxsLCBvbmx5ICR7bGVmdE92ZXJ9IGJ5dGVzIGxlZnQgdG8gcGFyc2UuYCk7XG4gICAgICAvLyBXZSBtaWdodCBiZSBhYmxlIHRvIHBhcnNlIHNvbWUgZGF0YSwgYnV0IGxldCdzIGJlIHNhZmUgYW5kIGlnbm9yZSBpdC5cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAocGF5bG9hZFR5cGUgPT09IDQpIHtcbiAgICAgIGNvbnN0IGNvdW50cnlDb2RlID0gZGF0YVtwYXlQdHIrK107XG4gICAgICBpZiAoY291bnRyeUNvZGUgPT09IDE4MSkge1xuICAgICAgICBjb25zdCBwcm92aWRlckNvZGUgPSByZWFkVWludDE2KGRhdGEsIHBheVB0cik7XG4gICAgICAgIHBheVB0ciArPSAyO1xuICAgICAgICBpZiAocHJvdmlkZXJDb2RlID09PSA0OSkge1xuICAgICAgICAgIGNvbnN0IHVzZXJTdHJ1Y3R1cmUgPSByZWFkVWludDMyKGRhdGEsIHBheVB0cik7XG4gICAgICAgICAgcGF5UHRyICs9IDQ7XG4gICAgICAgICAgaWYgKHVzZXJTdHJ1Y3R1cmUgPT09IDB4NDc0MTM5MzQpIHtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJEYXRhVHlwZSA9IGRhdGFbcGF5UHRyKytdO1xuXG4gICAgICAgICAgICAvLyBSYXcgQ0VBLTYwOCBieXRlcyB3cmFwcGVkIGluIENFQS03MDggcGFja2V0XG4gICAgICAgICAgICBpZiAodXNlckRhdGFUeXBlID09PSAzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IGRhdGFbcGF5UHRyKytdO1xuICAgICAgICAgICAgICBjb25zdCB0b3RhbENDcyA9IDB4MWYgJiBmaXJzdEJ5dGU7XG4gICAgICAgICAgICAgIGNvbnN0IGVuYWJsZWQgPSAweDQwICYgZmlyc3RCeXRlO1xuICAgICAgICAgICAgICBjb25zdCB0b3RhbEJ5dGVzID0gZW5hYmxlZCA/IDIgKyB0b3RhbENDcyAqIDMgOiAwO1xuICAgICAgICAgICAgICBjb25zdCBieXRlQXJyYXkgPSBuZXcgVWludDhBcnJheSh0b3RhbEJ5dGVzKTtcbiAgICAgICAgICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBieXRlQXJyYXlbMF0gPSBmaXJzdEJ5dGU7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0b3RhbEJ5dGVzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGJ5dGVBcnJheVtpXSA9IGRhdGFbcGF5UHRyKytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzYW1wbGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IHVzZXJEYXRhVHlwZSxcbiAgICAgICAgICAgICAgICBwYXlsb2FkVHlwZSxcbiAgICAgICAgICAgICAgICBwdHMsXG4gICAgICAgICAgICAgICAgYnl0ZXM6IGJ5dGVBcnJheVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBheWxvYWRUeXBlID09PSA1KSB7XG4gICAgICBpZiAocGF5bG9hZFNpemUgPiAxNikge1xuICAgICAgICBjb25zdCB1dWlkU3RyQXJyYXkgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgX2IgPSBkYXRhW3BheVB0cisrXS50b1N0cmluZygxNik7XG4gICAgICAgICAgdXVpZFN0ckFycmF5LnB1c2goX2IubGVuZ3RoID09IDEgPyAnMCcgKyBfYiA6IF9iKTtcbiAgICAgICAgICBpZiAoaSA9PT0gMyB8fCBpID09PSA1IHx8IGkgPT09IDcgfHwgaSA9PT0gOSkge1xuICAgICAgICAgICAgdXVpZFN0ckFycmF5LnB1c2goJy0nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuZ3RoID0gcGF5bG9hZFNpemUgLSAxNjtcbiAgICAgICAgY29uc3QgdXNlckRhdGFCeXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB1c2VyRGF0YUJ5dGVzW2ldID0gZGF0YVtwYXlQdHIrK107XG4gICAgICAgIH1cbiAgICAgICAgc2FtcGxlcy5wdXNoKHtcbiAgICAgICAgICBwYXlsb2FkVHlwZSxcbiAgICAgICAgICBwdHMsXG4gICAgICAgICAgdXVpZDogdXVpZFN0ckFycmF5LmpvaW4oJycpLFxuICAgICAgICAgIHVzZXJEYXRhOiB1dGY4QXJyYXlUb1N0cih1c2VyRGF0YUJ5dGVzKSxcbiAgICAgICAgICB1c2VyRGF0YUJ5dGVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIHJlbW92ZSBFbXVsYXRpb24gUHJldmVudGlvbiBieXRlcyBmcm9tIGEgUkJTUFxuICovXG5mdW5jdGlvbiBkaXNjYXJkRVBCKGRhdGEpIHtcbiAgY29uc3QgbGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoO1xuICBjb25zdCBFUEJQb3NpdGlvbnMgPSBbXTtcbiAgbGV0IGkgPSAxO1xuXG4gIC8vIEZpbmQgYWxsIGBFbXVsYXRpb24gUHJldmVudGlvbiBCeXRlc2BcbiAgd2hpbGUgKGkgPCBsZW5ndGggLSAyKSB7XG4gICAgaWYgKGRhdGFbaV0gPT09IDAgJiYgZGF0YVtpICsgMV0gPT09IDAgJiYgZGF0YVtpICsgMl0gPT09IDB4MDMpIHtcbiAgICAgIEVQQlBvc2l0aW9ucy5wdXNoKGkgKyAyKTtcbiAgICAgIGkgKz0gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgaSsrO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIG5vIEVtdWxhdGlvbiBQcmV2ZW50aW9uIEJ5dGVzIHdlcmUgZm91bmQganVzdCByZXR1cm4gdGhlIG9yaWdpbmFsXG4gIC8vIGFycmF5XG4gIGlmIChFUEJQb3NpdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICAvLyBDcmVhdGUgYSBuZXcgYXJyYXkgdG8gaG9sZCB0aGUgTkFMIHVuaXQgZGF0YVxuICBjb25zdCBuZXdMZW5ndGggPSBsZW5ndGggLSBFUEJQb3NpdGlvbnMubGVuZ3RoO1xuICBjb25zdCBuZXdEYXRhID0gbmV3IFVpbnQ4QXJyYXkobmV3TGVuZ3RoKTtcbiAgbGV0IHNvdXJjZUluZGV4ID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IG5ld0xlbmd0aDsgc291cmNlSW5kZXgrKywgaSsrKSB7XG4gICAgaWYgKHNvdXJjZUluZGV4ID09PSBFUEJQb3NpdGlvbnNbMF0pIHtcbiAgICAgIC8vIFNraXAgdGhpcyBieXRlXG4gICAgICBzb3VyY2VJbmRleCsrO1xuICAgICAgLy8gUmVtb3ZlIHRoaXMgcG9zaXRpb24gaW5kZXhcbiAgICAgIEVQQlBvc2l0aW9ucy5zaGlmdCgpO1xuICAgIH1cbiAgICBuZXdEYXRhW2ldID0gZGF0YVtzb3VyY2VJbmRleF07XG4gIH1cbiAgcmV0dXJuIG5ld0RhdGE7XG59XG5mdW5jdGlvbiBwYXJzZUVtc2coZGF0YSkge1xuICBjb25zdCB2ZXJzaW9uID0gZGF0YVswXTtcbiAgbGV0IHNjaGVtZUlkVXJpID0gJyc7XG4gIGxldCB2YWx1ZSA9ICcnO1xuICBsZXQgdGltZVNjYWxlID0gMDtcbiAgbGV0IHByZXNlbnRhdGlvblRpbWVEZWx0YSA9IDA7XG4gIGxldCBwcmVzZW50YXRpb25UaW1lID0gMDtcbiAgbGV0IGV2ZW50RHVyYXRpb24gPSAwO1xuICBsZXQgaWQgPSAwO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICB3aGlsZSAoYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpICE9PSAnXFwwJykge1xuICAgICAgc2NoZW1lSWRVcmkgKz0gYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpO1xuICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgfVxuICAgIHNjaGVtZUlkVXJpICs9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKTtcbiAgICBvZmZzZXQgKz0gMTtcbiAgICB3aGlsZSAoYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpICE9PSAnXFwwJykge1xuICAgICAgdmFsdWUgKz0gYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpO1xuICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgfVxuICAgIHZhbHVlICs9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKTtcbiAgICBvZmZzZXQgKz0gMTtcbiAgICB0aW1lU2NhbGUgPSByZWFkVWludDMyKGRhdGEsIDEyKTtcbiAgICBwcmVzZW50YXRpb25UaW1lRGVsdGEgPSByZWFkVWludDMyKGRhdGEsIDE2KTtcbiAgICBldmVudER1cmF0aW9uID0gcmVhZFVpbnQzMihkYXRhLCAyMCk7XG4gICAgaWQgPSByZWFkVWludDMyKGRhdGEsIDI0KTtcbiAgICBvZmZzZXQgPSAyODtcbiAgfSBlbHNlIGlmICh2ZXJzaW9uID09PSAxKSB7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gICAgdGltZVNjYWxlID0gcmVhZFVpbnQzMihkYXRhLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSA0O1xuICAgIGNvbnN0IGxlZnRQcmVzZW50YXRpb25UaW1lID0gcmVhZFVpbnQzMihkYXRhLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSA0O1xuICAgIGNvbnN0IHJpZ2h0UHJlc2VudGF0aW9uVGltZSA9IHJlYWRVaW50MzIoZGF0YSwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICBwcmVzZW50YXRpb25UaW1lID0gMiAqKiAzMiAqIGxlZnRQcmVzZW50YXRpb25UaW1lICsgcmlnaHRQcmVzZW50YXRpb25UaW1lO1xuICAgIGlmICghaXNTYWZlSW50ZWdlcihwcmVzZW50YXRpb25UaW1lKSkge1xuICAgICAgcHJlc2VudGF0aW9uVGltZSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgbG9nZ2VyLndhcm4oJ1ByZXNlbnRhdGlvbiB0aW1lIGV4Y2VlZHMgc2FmZSBpbnRlZ2VyIGxpbWl0IGFuZCB3cmFwcGVkIHRvIG1heCBzYWZlIGludGVnZXIgaW4gcGFyc2luZyBlbXNnIGJveCcpO1xuICAgIH1cbiAgICBldmVudER1cmF0aW9uID0gcmVhZFVpbnQzMihkYXRhLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSA0O1xuICAgIGlkID0gcmVhZFVpbnQzMihkYXRhLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSA0O1xuICAgIHdoaWxlIChiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSkgIT09ICdcXDAnKSB7XG4gICAgICBzY2hlbWVJZFVyaSArPSBiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSk7XG4gICAgICBvZmZzZXQgKz0gMTtcbiAgICB9XG4gICAgc2NoZW1lSWRVcmkgKz0gYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpO1xuICAgIG9mZnNldCArPSAxO1xuICAgIHdoaWxlIChiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSkgIT09ICdcXDAnKSB7XG4gICAgICB2YWx1ZSArPSBiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSk7XG4gICAgICBvZmZzZXQgKz0gMTtcbiAgICB9XG4gICAgdmFsdWUgKz0gYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpO1xuICAgIG9mZnNldCArPSAxO1xuICB9XG4gIGNvbnN0IHBheWxvYWQgPSBkYXRhLnN1YmFycmF5KG9mZnNldCwgZGF0YS5ieXRlTGVuZ3RoKTtcbiAgcmV0dXJuIHtcbiAgICBzY2hlbWVJZFVyaSxcbiAgICB2YWx1ZSxcbiAgICB0aW1lU2NhbGUsXG4gICAgcHJlc2VudGF0aW9uVGltZSxcbiAgICBwcmVzZW50YXRpb25UaW1lRGVsdGEsXG4gICAgZXZlbnREdXJhdGlvbixcbiAgICBpZCxcbiAgICBwYXlsb2FkXG4gIH07XG59XG5mdW5jdGlvbiBtcDRCb3godHlwZSwgLi4ucGF5bG9hZCkge1xuICBjb25zdCBsZW4gPSBwYXlsb2FkLmxlbmd0aDtcbiAgbGV0IHNpemUgPSA4O1xuICBsZXQgaSA9IGxlbjtcbiAgd2hpbGUgKGktLSkge1xuICAgIHNpemUgKz0gcGF5bG9hZFtpXS5ieXRlTGVuZ3RoO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICByZXN1bHRbMF0gPSBzaXplID4+IDI0ICYgMHhmZjtcbiAgcmVzdWx0WzFdID0gc2l6ZSA+PiAxNiAmIDB4ZmY7XG4gIHJlc3VsdFsyXSA9IHNpemUgPj4gOCAmIDB4ZmY7XG4gIHJlc3VsdFszXSA9IHNpemUgJiAweGZmO1xuICByZXN1bHQuc2V0KHR5cGUsIDQpO1xuICBmb3IgKGkgPSAwLCBzaXplID0gODsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzdWx0LnNldChwYXlsb2FkW2ldLCBzaXplKTtcbiAgICBzaXplICs9IHBheWxvYWRbaV0uYnl0ZUxlbmd0aDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbXA0cHNzaChzeXN0ZW1JZCwga2V5aWRzLCBkYXRhKSB7XG4gIGlmIChzeXN0ZW1JZC5ieXRlTGVuZ3RoICE9PSAxNikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHN5c3RlbSBpZCcpO1xuICB9XG4gIGxldCB2ZXJzaW9uO1xuICBsZXQga2lkcztcbiAge1xuICAgIHZlcnNpb24gPSAwO1xuICAgIGtpZHMgPSBuZXcgVWludDhBcnJheSgpO1xuICB9XG4gIGxldCBraWRDb3VudDtcbiAgaWYgKHZlcnNpb24gPiAwKSB7XG4gICAga2lkQ291bnQgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICBpZiAoa2V5aWRzLmxlbmd0aCA+IDApIHtcbiAgICAgIG5ldyBEYXRhVmlldyhraWRDb3VudC5idWZmZXIpLnNldFVpbnQzMigwLCBrZXlpZHMubGVuZ3RoLCBmYWxzZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGtpZENvdW50ID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgfVxuICBjb25zdCBkYXRhU2l6ZSA9IG5ldyBVaW50OEFycmF5KDQpO1xuICBpZiAoZGF0YSAmJiBkYXRhLmJ5dGVMZW5ndGggPiAwKSB7XG4gICAgbmV3IERhdGFWaWV3KGRhdGFTaXplLmJ1ZmZlcikuc2V0VWludDMyKDAsIGRhdGEuYnl0ZUxlbmd0aCwgZmFsc2UpO1xuICB9XG4gIHJldHVybiBtcDRCb3goWzExMiwgMTE1LCAxMTUsIDEwNF0sIG5ldyBVaW50OEFycmF5KFt2ZXJzaW9uLCAweDAwLCAweDAwLCAweDAwIC8vIEZsYWdzXG4gIF0pLCBzeXN0ZW1JZCxcbiAgLy8gMTYgYnl0ZXNcbiAga2lkQ291bnQsIGtpZHMsIGRhdGFTaXplLCBkYXRhIHx8IG5ldyBVaW50OEFycmF5KCkpO1xufVxuXG5jb25zdCB1c2VyQWdlbnRIZXZjU3VwcG9ydElzSW5hY2N1cmF0ZSA9ICgpID0+IHtcbiAgcmV0dXJuIC9cXChXaW5kb3dzLitGaXJlZm94XFwvL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbn07XG5cbi8vIGZyb20gaHR0cDovL21wNHJhLm9yZy9jb2RlY3MuaHRtbFxuLy8gdmFsdWVzIGluZGljYXRlIGNvZGVjIHNlbGVjdGlvbiBwcmVmZXJlbmNlIChsb3dlciBpcyBoaWdoZXIgcHJpb3JpdHkpXG5jb25zdCBzYW1wbGVFbnRyeUNvZGVzSVNPID0ge1xuICBhdWRpbzoge1xuICAgIGEzZHM6IDEsXG4gICAgJ2FjLTMnOiAwLjk1LFxuICAgICdhYy00JzogMSxcbiAgICBhbGFjOiAwLjksXG4gICAgYWxhdzogMSxcbiAgICBkcmExOiAxLFxuICAgICdkdHMrJzogMSxcbiAgICAnZHRzLSc6IDEsXG4gICAgZHRzYzogMSxcbiAgICBkdHNlOiAxLFxuICAgIGR0c2g6IDEsXG4gICAgJ2VjLTMnOiAwLjksXG4gICAgZW5jYTogMSxcbiAgICBmTGFDOiAwLjksXG4gICAgLy8gTVA0LVJBIGxpc3RlZCBjb2RlYyBlbnRyeSBmb3IgRkxBQ1xuICAgIGZsYWM6IDAuOSxcbiAgICAvLyBsZWdhY3kgYnJvd3NlciBjb2RlYyBuYW1lIGZvciBGTEFDXG4gICAgRkxBQzogMC45LFxuICAgIC8vIHNvbWUgbWFuaWZlc3RzIG1heSBsaXN0IFwiRkxBQ1wiIHdpdGggQXBwbGUncyB0b29sc1xuICAgIGc3MTk6IDEsXG4gICAgZzcyNjogMSxcbiAgICBtNGFlOiAxLFxuICAgIG1oYTE6IDEsXG4gICAgbWhhMjogMSxcbiAgICBtaG0xOiAxLFxuICAgIG1obTI6IDEsXG4gICAgbWxwYTogMSxcbiAgICBtcDRhOiAxLFxuICAgICdyYXcgJzogMSxcbiAgICBPcHVzOiAxLFxuICAgIG9wdXM6IDEsXG4gICAgLy8gYnJvd3NlcnMgZXhwZWN0IHRoaXMgdG8gYmUgbG93ZXJjYXNlIGRlc3BpdGUgTVA0UkEgc2F5cyAnT3B1cydcbiAgICBzYW1yOiAxLFxuICAgIHNhd2I6IDEsXG4gICAgc2F3cDogMSxcbiAgICBzZXZjOiAxLFxuICAgIHNxY3A6IDEsXG4gICAgc3NtdjogMSxcbiAgICB0d29zOiAxLFxuICAgIHVsYXc6IDFcbiAgfSxcbiAgdmlkZW86IHtcbiAgICBhdmMxOiAxLFxuICAgIGF2YzI6IDEsXG4gICAgYXZjMzogMSxcbiAgICBhdmM0OiAxLFxuICAgIGF2Y3A6IDEsXG4gICAgYXYwMTogMC44LFxuICAgIGRhdjE6IDAuOCxcbiAgICBkcmFjOiAxLFxuICAgIGR2YTE6IDEsXG4gICAgZHZhdjogMSxcbiAgICBkdmgxOiAwLjcsXG4gICAgZHZoZTogMC43LFxuICAgIGVuY3Y6IDEsXG4gICAgaGV2MTogMC43NSxcbiAgICBodmMxOiAwLjc1LFxuICAgIG1qcDI6IDEsXG4gICAgbXA0djogMSxcbiAgICBtdmMxOiAxLFxuICAgIG12YzI6IDEsXG4gICAgbXZjMzogMSxcbiAgICBtdmM0OiAxLFxuICAgIHJlc3Y6IDEsXG4gICAgcnY2MDogMSxcbiAgICBzMjYzOiAxLFxuICAgIHN2YzE6IDEsXG4gICAgc3ZjMjogMSxcbiAgICAndmMtMSc6IDEsXG4gICAgdnAwODogMSxcbiAgICB2cDA5OiAwLjlcbiAgfSxcbiAgdGV4dDoge1xuICAgIHN0cHA6IDEsXG4gICAgd3Z0dDogMVxuICB9XG59O1xuZnVuY3Rpb24gaXNDb2RlY1R5cGUoY29kZWMsIHR5cGUpIHtcbiAgY29uc3QgdHlwZUNvZGVzID0gc2FtcGxlRW50cnlDb2Rlc0lTT1t0eXBlXTtcbiAgcmV0dXJuICEhdHlwZUNvZGVzICYmICEhdHlwZUNvZGVzW2NvZGVjLnNsaWNlKDAsIDQpXTtcbn1cbmZ1bmN0aW9uIGFyZUNvZGVjc01lZGlhU291cmNlU3VwcG9ydGVkKGNvZGVjcywgdHlwZSwgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlID0gdHJ1ZSkge1xuICByZXR1cm4gIWNvZGVjcy5zcGxpdCgnLCcpLnNvbWUoY29kZWMgPT4gIWlzQ29kZWNNZWRpYVNvdXJjZVN1cHBvcnRlZChjb2RlYywgdHlwZSwgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlKSk7XG59XG5mdW5jdGlvbiBpc0NvZGVjTWVkaWFTb3VyY2VTdXBwb3J0ZWQoY29kZWMsIHR5cGUsIHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSA9IHRydWUpIHtcbiAgdmFyIF9NZWRpYVNvdXJjZSRpc1R5cGVTdTtcbiAgY29uc3QgTWVkaWFTb3VyY2UgPSBnZXRNZWRpYVNvdXJjZShwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UpO1xuICByZXR1cm4gKF9NZWRpYVNvdXJjZSRpc1R5cGVTdSA9IE1lZGlhU291cmNlID09IG51bGwgPyB2b2lkIDAgOiBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQobWltZVR5cGVGb3JDb2RlYyhjb2RlYywgdHlwZSkpKSAhPSBudWxsID8gX01lZGlhU291cmNlJGlzVHlwZVN1IDogZmFsc2U7XG59XG5mdW5jdGlvbiBtaW1lVHlwZUZvckNvZGVjKGNvZGVjLCB0eXBlKSB7XG4gIHJldHVybiBgJHt0eXBlfS9tcDQ7Y29kZWNzPSR7Y29kZWN9YDtcbn1cbmZ1bmN0aW9uIHZpZGVvQ29kZWNQcmVmZXJlbmNlVmFsdWUodmlkZW9Db2RlYykge1xuICBpZiAodmlkZW9Db2RlYykge1xuICAgIGNvbnN0IGZvdXJDQyA9IHZpZGVvQ29kZWMuc3Vic3RyaW5nKDAsIDQpO1xuICAgIHJldHVybiBzYW1wbGVFbnRyeUNvZGVzSVNPLnZpZGVvW2ZvdXJDQ107XG4gIH1cbiAgcmV0dXJuIDI7XG59XG5mdW5jdGlvbiBjb2RlY3NTZXRTZWxlY3Rpb25QcmVmZXJlbmNlVmFsdWUoY29kZWNTZXQpIHtcbiAgY29uc3QgbGltaXRlZEhldmNTdXBwb3J0ID0gdXNlckFnZW50SGV2Y1N1cHBvcnRJc0luYWNjdXJhdGUoKTtcbiAgcmV0dXJuIGNvZGVjU2V0LnNwbGl0KCcsJykucmVkdWNlKChudW0sIGZvdXJDQykgPT4ge1xuICAgIGNvbnN0IGxvd2VyUHJpb3JpdHkgPSBsaW1pdGVkSGV2Y1N1cHBvcnQgJiYgaXNIRVZDKGZvdXJDQyk7XG4gICAgY29uc3QgcHJlZmVyZW5jZVZhbHVlID0gbG93ZXJQcmlvcml0eSA/IDkgOiBzYW1wbGVFbnRyeUNvZGVzSVNPLnZpZGVvW2ZvdXJDQ107XG4gICAgaWYgKHByZWZlcmVuY2VWYWx1ZSkge1xuICAgICAgcmV0dXJuIChwcmVmZXJlbmNlVmFsdWUgKiAyICsgbnVtKSAvIChudW0gPyAzIDogMik7XG4gICAgfVxuICAgIHJldHVybiAoc2FtcGxlRW50cnlDb2Rlc0lTTy5hdWRpb1tmb3VyQ0NdICsgbnVtKSAvIChudW0gPyAyIDogMSk7XG4gIH0sIDApO1xufVxuY29uc3QgQ09ERUNfQ09NUEFUSUJMRV9OQU1FUyA9IHt9O1xuZnVuY3Rpb24gZ2V0Q29kZWNDb21wYXRpYmxlTmFtZUxvd2VyKGxvd2VyQ2FzZUNvZGVjLCBwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UgPSB0cnVlKSB7XG4gIGlmIChDT0RFQ19DT01QQVRJQkxFX05BTUVTW2xvd2VyQ2FzZUNvZGVjXSkge1xuICAgIHJldHVybiBDT0RFQ19DT01QQVRJQkxFX05BTUVTW2xvd2VyQ2FzZUNvZGVjXTtcbiAgfVxuICBjb25zdCBjb2RlY3NUb0NoZWNrID0ge1xuICAgIC8vIElkZWFseSBmTGFDIGFuZCBPcHVzIHdvdWxkIGJlIGZpcnN0IChzcGVjLWNvbXBsaWFudCkgYnV0XG4gICAgLy8gc29tZSBicm93c2VycyB3aWxsIHJlcG9ydCB0aGF0IGZMYUMgaXMgc3VwcG9ydGVkIHRoZW4gZmFpbC5cbiAgICAvLyBzZWU6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTE0MjI3MjhcbiAgICBmbGFjOiBbJ2ZsYWMnLCAnZkxhQycsICdGTEFDJ10sXG4gICAgb3B1czogWydvcHVzJywgJ09wdXMnXSxcbiAgICAvLyBSZXBsYWNlIGF1ZGlvIGNvZGVjIGluZm8gaWYgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IG1wNGEuNDAuMzQsXG4gICAgLy8gYW5kIGRlbXV4ZXIgY2FuIGZhbGxiYWNrIHRvICdhdWRpby9tcGVnJyBvciAnYXVkaW8vbXA0O2NvZGVjcz1cIm1wM1wiJ1xuICAgICdtcDRhLjQwLjM0JzogWydtcDMnXVxuICB9W2xvd2VyQ2FzZUNvZGVjXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2RlY3NUb0NoZWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9nZXRNZWRpYVNvdXJjZTtcbiAgICBpZiAoaXNDb2RlY01lZGlhU291cmNlU3VwcG9ydGVkKGNvZGVjc1RvQ2hlY2tbaV0sICdhdWRpbycsIHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSkpIHtcbiAgICAgIENPREVDX0NPTVBBVElCTEVfTkFNRVNbbG93ZXJDYXNlQ29kZWNdID0gY29kZWNzVG9DaGVja1tpXTtcbiAgICAgIHJldHVybiBjb2RlY3NUb0NoZWNrW2ldO1xuICAgIH0gZWxzZSBpZiAoY29kZWNzVG9DaGVja1tpXSA9PT0gJ21wMycgJiYgKF9nZXRNZWRpYVNvdXJjZSA9IGdldE1lZGlhU291cmNlKHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSkpICE9IG51bGwgJiYgX2dldE1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCgnYXVkaW8vbXBlZycpKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9XG4gIHJldHVybiBsb3dlckNhc2VDb2RlYztcbn1cbmNvbnN0IEFVRElPX0NPREVDX1JFR0VYUCA9IC9mbGFjfG9wdXN8bXA0YVxcLjQwXFwuMzQvaTtcbmZ1bmN0aW9uIGdldENvZGVjQ29tcGF0aWJsZU5hbWUoY29kZWMsIHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSA9IHRydWUpIHtcbiAgcmV0dXJuIGNvZGVjLnJlcGxhY2UoQVVESU9fQ09ERUNfUkVHRVhQLCBtID0+IGdldENvZGVjQ29tcGF0aWJsZU5hbWVMb3dlcihtLnRvTG93ZXJDYXNlKCksIHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSkpO1xufVxuZnVuY3Rpb24gcmVwbGFjZVZpZGVvQ29kZWMob3JpZ2luYWxDb2RlY3MsIG5ld1ZpZGVvQ29kZWMpIHtcbiAgY29uc3QgY29kZWNzID0gW107XG4gIGlmIChvcmlnaW5hbENvZGVjcykge1xuICAgIGNvbnN0IGFsbENvZGVjcyA9IG9yaWdpbmFsQ29kZWNzLnNwbGl0KCcsJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbGxDb2RlY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghaXNDb2RlY1R5cGUoYWxsQ29kZWNzW2ldLCAndmlkZW8nKSkge1xuICAgICAgICBjb2RlY3MucHVzaChhbGxDb2RlY3NbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAobmV3VmlkZW9Db2RlYykge1xuICAgIGNvZGVjcy5wdXNoKG5ld1ZpZGVvQ29kZWMpO1xuICB9XG4gIHJldHVybiBjb2RlY3Muam9pbignLCcpO1xufVxuZnVuY3Rpb24gcGlja01vc3RDb21wbGV0ZUNvZGVjTmFtZShwYXJzZWRDb2RlYywgbGV2ZWxDb2RlYykge1xuICAvLyBQYXJzaW5nIG9mIG1wNGEgY29kZWNzIHN0cmluZ3MgaW4gbXA0LXRvb2xzIGZyb20gbWVkaWEgaXMgaW5jb21wbGV0ZSBhcyBvZiBkOGM2YzdhXG4gIC8vIHNvIHVzZSBsZXZlbCBjb2RlYyBpcyBwYXJzZWQgY29kZWMgaXMgdW5hdmFpbGFibGUgb3IgaW5jb21wbGV0ZVxuICBpZiAocGFyc2VkQ29kZWMgJiYgKHBhcnNlZENvZGVjLmxlbmd0aCA+IDQgfHwgWydhYy0zJywgJ2VjLTMnLCAnYWxhYycsICdmTGFDJywgJ09wdXMnXS5pbmRleE9mKHBhcnNlZENvZGVjKSAhPT0gLTEpKSB7XG4gICAgaWYgKGlzQ29kZWNTdXBwb3J0ZWRBc1R5cGUocGFyc2VkQ29kZWMsICdhdWRpbycpIHx8IGlzQ29kZWNTdXBwb3J0ZWRBc1R5cGUocGFyc2VkQ29kZWMsICd2aWRlbycpKSB7XG4gICAgICByZXR1cm4gcGFyc2VkQ29kZWM7XG4gICAgfVxuICB9XG4gIGlmIChsZXZlbENvZGVjKSB7XG4gICAgY29uc3QgbGV2ZWxDb2RlY3MgPSBsZXZlbENvZGVjLnNwbGl0KCcsJyk7XG4gICAgaWYgKGxldmVsQ29kZWNzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGlmIChwYXJzZWRDb2RlYykge1xuICAgICAgICBmb3IgKGxldCBpID0gbGV2ZWxDb2RlY3MubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgaWYgKGxldmVsQ29kZWNzW2ldLnN1YnN0cmluZygwLCA0KSA9PT0gcGFyc2VkQ29kZWMuc3Vic3RyaW5nKDAsIDQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbGV2ZWxDb2RlY3NbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbGV2ZWxDb2RlY3NbMF07XG4gICAgfVxuICB9XG4gIHJldHVybiBsZXZlbENvZGVjIHx8IHBhcnNlZENvZGVjO1xufVxuZnVuY3Rpb24gaXNDb2RlY1N1cHBvcnRlZEFzVHlwZShjb2RlYywgdHlwZSkge1xuICByZXR1cm4gaXNDb2RlY1R5cGUoY29kZWMsIHR5cGUpICYmIGlzQ29kZWNNZWRpYVNvdXJjZVN1cHBvcnRlZChjb2RlYywgdHlwZSk7XG59XG5mdW5jdGlvbiBjb252ZXJ0QVZDMVRvQVZDT1RJKHZpZGVvQ29kZWNzKSB7XG4gIC8vIENvbnZlcnQgYXZjMSBjb2RlYyBzdHJpbmcgZnJvbSBSRkMtNDI4MSB0byBSRkMtNjM4MSBmb3IgTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkXG4gIC8vIEV4YW1wbGVzOiBhdmMxLjY2LjMwIHRvIGF2YzEuNDIwMDFlIGFuZCBhdmMxLjc3LjMwLGF2YzEuNjYuMzAgdG8gYXZjMS40ZDAwMWUsYXZjMS40MjAwMWUuXG4gIGNvbnN0IGNvZGVjcyA9IHZpZGVvQ29kZWNzLnNwbGl0KCcsJyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29kZWNzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYXZjZGF0YSA9IGNvZGVjc1tpXS5zcGxpdCgnLicpO1xuICAgIC8vIG9ubHkgY29udmVydCBjb2RlYyBzdHJpbmdzIHN0YXJ0aW5nIHdpdGggYXZjMSAoRXhhbXBsZXM6IGF2YzEuNjQwMDFmLGR2aDEuMDUuMDcpXG4gICAgaWYgKGF2Y2RhdGEubGVuZ3RoID4gMiAmJiBhdmNkYXRhWzBdID09PSAnYXZjMScpIHtcbiAgICAgIGNvZGVjc1tpXSA9IGBhdmMxLiR7cGFyc2VJbnQoYXZjZGF0YVsxXSkudG9TdHJpbmcoMTYpfSR7KCcwMDAnICsgcGFyc2VJbnQoYXZjZGF0YVsyXSkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCl9YDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvZGVjcy5qb2luKCcsJyk7XG59XG5mdW5jdGlvbiBmaWxsSW5NaXNzaW5nQVYwMVBhcmFtcyh2aWRlb0NvZGVjKSB7XG4gIC8vIFVzZWQgdG8gZmlsbCBpbiBpbmNvbXBsZXRlIEFWMSBwbGF5bGlzdCBDT0RFQ1Mgc3RyaW5ncyBmb3IgbWVkaWFDYXBhYmlsaXRpZXMuZGVjb2RpbmdJbmZvIHF1ZXJpZXNcbiAgaWYgKHZpZGVvQ29kZWMuc3RhcnRzV2l0aCgnYXYwMS4nKSkge1xuICAgIGNvbnN0IGF2MXBhcmFtcyA9IHZpZGVvQ29kZWMuc3BsaXQoJy4nKTtcbiAgICBjb25zdCBwbGFjZWhvbGRlcnMgPSBbJzAnLCAnMTExJywgJzAxJywgJzAxJywgJzAxJywgJzAnXTtcbiAgICBmb3IgKGxldCBpID0gYXYxcGFyYW1zLmxlbmd0aDsgaSA+IDQgJiYgaSA8IDEwOyBpKyspIHtcbiAgICAgIGF2MXBhcmFtc1tpXSA9IHBsYWNlaG9sZGVyc1tpIC0gNF07XG4gICAgfVxuICAgIHJldHVybiBhdjFwYXJhbXMuam9pbignLicpO1xuICB9XG4gIHJldHVybiB2aWRlb0NvZGVjO1xufVxuZnVuY3Rpb24gZ2V0TTJUU1N1cHBvcnRlZEF1ZGlvVHlwZXMocHJlZmVyTWFuYWdlZE1lZGlhU291cmNlKSB7XG4gIGNvbnN0IE1lZGlhU291cmNlID0gZ2V0TWVkaWFTb3VyY2UocHJlZmVyTWFuYWdlZE1lZGlhU291cmNlKSB8fCB7XG4gICAgaXNUeXBlU3VwcG9ydGVkOiAoKSA9PiBmYWxzZVxuICB9O1xuICByZXR1cm4ge1xuICAgIG1wZWc6IE1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCgnYXVkaW8vbXBlZycpLFxuICAgIG1wMzogTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCdhdWRpby9tcDQ7IGNvZGVjcz1cIm1wM1wiJyksXG4gICAgYWMzOiBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoJ2F1ZGlvL21wNDsgY29kZWNzPVwiYWMtM1wiJykgXG4gIH07XG59XG5mdW5jdGlvbiBnZXRDb2RlY3NGb3JNaW1lVHlwZShtaW1lVHlwZSkge1xuICByZXR1cm4gbWltZVR5cGUucmVwbGFjZSgvXi4rY29kZWNzPVtcIiddPyhbXlwiJ10rKS4qJC8sICckMScpO1xufVxuXG5jb25zdCBTVVBQT1JURURfSU5GT19ERUZBVUxUID0ge1xuICBzdXBwb3J0ZWQ6IHRydWUsXG4gIGNvbmZpZ3VyYXRpb25zOiBbXSxcbiAgZGVjb2RpbmdJbmZvUmVzdWx0czogW3tcbiAgICBzdXBwb3J0ZWQ6IHRydWUsXG4gICAgcG93ZXJFZmZpY2llbnQ6IHRydWUsXG4gICAgc21vb3RoOiB0cnVlXG4gIH1dXG59O1xuZnVuY3Rpb24gZ2V0VW5zdXBwb3J0ZWRSZXN1bHQoZXJyb3IsIGNvbmZpZ3VyYXRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgc3VwcG9ydGVkOiBmYWxzZSxcbiAgICBjb25maWd1cmF0aW9ucyxcbiAgICBkZWNvZGluZ0luZm9SZXN1bHRzOiBbe1xuICAgICAgc3VwcG9ydGVkOiBmYWxzZSxcbiAgICAgIHNtb290aDogZmFsc2UsXG4gICAgICBwb3dlckVmZmljaWVudDogZmFsc2VcbiAgICB9XSxcbiAgICBlcnJvclxuICB9O1xufVxuZnVuY3Rpb24gcmVxdWlyZXNNZWRpYUNhcGFiaWxpdGllc0RlY29kaW5nSW5mbyhsZXZlbCwgYXVkaW9UcmFja3NCeUdyb3VwLCBjdXJyZW50VmlkZW9SYW5nZSwgY3VycmVudEZyYW1lUmF0ZSwgY3VycmVudEJ3LCBhdWRpb1ByZWZlcmVuY2UpIHtcbiAgLy8gT25seSB0ZXN0IHN1cHBvcnQgd2hlbiBjb25maWd1cmF0aW9uIGlzIGV4Y2VlZHMgbWluaW11bSBvcHRpb25zXG4gIGNvbnN0IHZpZGVvQ29kZWNzID0gbGV2ZWwudmlkZW9Db2RlYztcbiAgY29uc3QgYXVkaW9Hcm91cHMgPSBsZXZlbC5hdWRpb0NvZGVjID8gbGV2ZWwuYXVkaW9Hcm91cHMgOiBudWxsO1xuICBjb25zdCBhdWRpb0NvZGVjUHJlZmVyZW5jZSA9IGF1ZGlvUHJlZmVyZW5jZSA9PSBudWxsID8gdm9pZCAwIDogYXVkaW9QcmVmZXJlbmNlLmF1ZGlvQ29kZWM7XG4gIGNvbnN0IGNoYW5uZWxzUHJlZmVyZW5jZSA9IGF1ZGlvUHJlZmVyZW5jZSA9PSBudWxsID8gdm9pZCAwIDogYXVkaW9QcmVmZXJlbmNlLmNoYW5uZWxzO1xuICBjb25zdCBtYXhDaGFubmVscyA9IGNoYW5uZWxzUHJlZmVyZW5jZSA/IHBhcnNlSW50KGNoYW5uZWxzUHJlZmVyZW5jZSkgOiBhdWRpb0NvZGVjUHJlZmVyZW5jZSA/IEluZmluaXR5IDogMjtcbiAgbGV0IGF1ZGlvQ2hhbm5lbHMgPSBudWxsO1xuICBpZiAoYXVkaW9Hcm91cHMgIT0gbnVsbCAmJiBhdWRpb0dyb3Vwcy5sZW5ndGgpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKGF1ZGlvR3JvdXBzLmxlbmd0aCA9PT0gMSAmJiBhdWRpb0dyb3Vwc1swXSkge1xuICAgICAgICBhdWRpb0NoYW5uZWxzID0gYXVkaW9UcmFja3NCeUdyb3VwLmdyb3Vwc1thdWRpb0dyb3Vwc1swXV0uY2hhbm5lbHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdWRpb0NoYW5uZWxzID0gYXVkaW9Hcm91cHMucmVkdWNlKChhY2MsIGdyb3VwSWQpID0+IHtcbiAgICAgICAgICBpZiAoZ3JvdXBJZCkge1xuICAgICAgICAgICAgY29uc3QgYXVkaW9UcmFja0dyb3VwID0gYXVkaW9UcmFja3NCeUdyb3VwLmdyb3Vwc1tncm91cElkXTtcbiAgICAgICAgICAgIGlmICghYXVkaW9UcmFja0dyb3VwKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXVkaW8gdHJhY2sgZ3JvdXAgJHtncm91cElkfSBub3QgZm91bmRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN1bSBhbGwgY2hhbm5lbCBrZXkgdmFsdWVzXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdWRpb1RyYWNrR3JvdXAuY2hhbm5lbHMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgYWNjW2tleV0gPSAoYWNjW2tleV0gfHwgMCkgKyBhdWRpb1RyYWNrR3JvdXAuY2hhbm5lbHNba2V5XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCB7XG4gICAgICAgICAgMjogMFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB2aWRlb0NvZGVjcyAhPT0gdW5kZWZpbmVkICYmIChcbiAgLy8gRm9yY2UgbWVkaWEgY2FwYWJpbGl0aWVzIGNoZWNrIGZvciBIRVZDIHRvIGF2b2lkIGZhaWx1cmUgb24gV2luZG93c1xuICB2aWRlb0NvZGVjcy5zcGxpdCgnLCcpLnNvbWUodmlkZW9Db2RlYyA9PiBpc0hFVkModmlkZW9Db2RlYykpIHx8IGxldmVsLndpZHRoID4gMTkyMCAmJiBsZXZlbC5oZWlnaHQgPiAxMDg4IHx8IGxldmVsLmhlaWdodCA+IDE5MjAgJiYgbGV2ZWwud2lkdGggPiAxMDg4IHx8IGxldmVsLmZyYW1lUmF0ZSA+IE1hdGgubWF4KGN1cnJlbnRGcmFtZVJhdGUsIDMwKSB8fCBsZXZlbC52aWRlb1JhbmdlICE9PSAnU0RSJyAmJiBsZXZlbC52aWRlb1JhbmdlICE9PSBjdXJyZW50VmlkZW9SYW5nZSB8fCBsZXZlbC5iaXRyYXRlID4gTWF0aC5tYXgoY3VycmVudEJ3LCA4ZTYpKSB8fCAhIWF1ZGlvQ2hhbm5lbHMgJiYgaXNGaW5pdGVOdW1iZXIobWF4Q2hhbm5lbHMpICYmIE9iamVjdC5rZXlzKGF1ZGlvQ2hhbm5lbHMpLnNvbWUoY2hhbm5lbHMgPT4gcGFyc2VJbnQoY2hhbm5lbHMpID4gbWF4Q2hhbm5lbHMpO1xufVxuZnVuY3Rpb24gZ2V0TWVkaWFEZWNvZGluZ0luZm9Qcm9taXNlKGxldmVsLCBhdWRpb1RyYWNrc0J5R3JvdXAsIG1lZGlhQ2FwYWJpbGl0aWVzLCBjYWNoZSA9IHt9KSB7XG4gIGNvbnN0IHZpZGVvQ29kZWNzID0gbGV2ZWwudmlkZW9Db2RlYztcbiAgaWYgKCF2aWRlb0NvZGVjcyAmJiAhbGV2ZWwuYXVkaW9Db2RlYyB8fCAhbWVkaWFDYXBhYmlsaXRpZXMpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFNVUFBPUlRFRF9JTkZPX0RFRkFVTFQpO1xuICB9XG4gIGNvbnN0IGNvbmZpZ3VyYXRpb25zID0gW107XG4gIGNvbnN0IHZpZGVvRGVjb2RlTGlzdCA9IG1ha2VWaWRlb0NvbmZpZ3VyYXRpb25zKGxldmVsKTtcbiAgY29uc3QgdmlkZW9Db3VudCA9IHZpZGVvRGVjb2RlTGlzdC5sZW5ndGg7XG4gIGNvbnN0IGF1ZGlvRGVjb2RlTGlzdCA9IG1ha2VBdWRpb0NvbmZpZ3VyYXRpb25zKGxldmVsLCBhdWRpb1RyYWNrc0J5R3JvdXAsIHZpZGVvQ291bnQgPiAwKTtcbiAgY29uc3QgYXVkaW9Db3VudCA9IGF1ZGlvRGVjb2RlTGlzdC5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSB2aWRlb0NvdW50IHx8IDEgKiBhdWRpb0NvdW50IHx8IDE7IGktLTspIHtcbiAgICBjb25zdCBjb25maWd1cmF0aW9uID0ge1xuICAgICAgdHlwZTogJ21lZGlhLXNvdXJjZSdcbiAgICB9O1xuICAgIGlmICh2aWRlb0NvdW50KSB7XG4gICAgICBjb25maWd1cmF0aW9uLnZpZGVvID0gdmlkZW9EZWNvZGVMaXN0W2kgJSB2aWRlb0NvdW50XTtcbiAgICB9XG4gICAgaWYgKGF1ZGlvQ291bnQpIHtcbiAgICAgIGNvbmZpZ3VyYXRpb24uYXVkaW8gPSBhdWRpb0RlY29kZUxpc3RbaSAlIGF1ZGlvQ291bnRdO1xuICAgICAgY29uc3QgYXVkaW9CaXRyYXRlID0gY29uZmlndXJhdGlvbi5hdWRpby5iaXRyYXRlO1xuICAgICAgaWYgKGNvbmZpZ3VyYXRpb24udmlkZW8gJiYgYXVkaW9CaXRyYXRlKSB7XG4gICAgICAgIGNvbmZpZ3VyYXRpb24udmlkZW8uYml0cmF0ZSAtPSBhdWRpb0JpdHJhdGU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbmZpZ3VyYXRpb25zLnB1c2goY29uZmlndXJhdGlvbik7XG4gIH1cbiAgaWYgKHZpZGVvQ29kZWNzKSB7XG4gICAgLy8gT3ZlcnJpZGUgV2luZG93cyBGaXJlZm94IEhFVkMgTWVkaWFDYXBhYmlsaXRpZXMgcmVzdWx0IChodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvNzA0NilcbiAgICBjb25zdCB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gICAgaWYgKHZpZGVvQ29kZWNzLnNwbGl0KCcsJykuc29tZSh2aWRlb0NvZGVjID0+IGlzSEVWQyh2aWRlb0NvZGVjKSkgJiYgdXNlckFnZW50SGV2Y1N1cHBvcnRJc0luYWNjdXJhdGUoKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShnZXRVbnN1cHBvcnRlZFJlc3VsdChuZXcgRXJyb3IoYE92ZXJyaWRpbmcgV2luZG93cyBGaXJlZm94IEhFVkMgTWVkaWFDYXBhYmlsaXRpZXMgcmVzdWx0IGJhc2VkIG9uIHVzZXItYWdlbnQgc3RyaW5nOiAoJHt1YX0pYCksIGNvbmZpZ3VyYXRpb25zKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBQcm9taXNlLmFsbChjb25maWd1cmF0aW9ucy5tYXAoY29uZmlndXJhdGlvbiA9PiB7XG4gICAgLy8gQ2FjaGUgTWVkaWFDYXBhYmlsaXRpZXMgcHJvbWlzZXNcbiAgICBjb25zdCBkZWNvZGluZ0luZm9LZXkgPSBnZXRNZWRpYURlY29kaW5nSW5mb0tleShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4gY2FjaGVbZGVjb2RpbmdJbmZvS2V5XSB8fCAoY2FjaGVbZGVjb2RpbmdJbmZvS2V5XSA9IG1lZGlhQ2FwYWJpbGl0aWVzLmRlY29kaW5nSW5mbyhjb25maWd1cmF0aW9uKSk7XG4gIH0pKS50aGVuKGRlY29kaW5nSW5mb1Jlc3VsdHMgPT4gKHtcbiAgICBzdXBwb3J0ZWQ6ICFkZWNvZGluZ0luZm9SZXN1bHRzLnNvbWUoaW5mbyA9PiAhaW5mby5zdXBwb3J0ZWQpLFxuICAgIGNvbmZpZ3VyYXRpb25zLFxuICAgIGRlY29kaW5nSW5mb1Jlc3VsdHNcbiAgfSkpLmNhdGNoKGVycm9yID0+ICh7XG4gICAgc3VwcG9ydGVkOiBmYWxzZSxcbiAgICBjb25maWd1cmF0aW9ucyxcbiAgICBkZWNvZGluZ0luZm9SZXN1bHRzOiBbXSxcbiAgICBlcnJvclxuICB9KSk7XG59XG5mdW5jdGlvbiBtYWtlVmlkZW9Db25maWd1cmF0aW9ucyhsZXZlbCkge1xuICB2YXIgX2xldmVsJHZpZGVvQ29kZWM7XG4gIGNvbnN0IHZpZGVvQ29kZWNzID0gKF9sZXZlbCR2aWRlb0NvZGVjID0gbGV2ZWwudmlkZW9Db2RlYykgPT0gbnVsbCA/IHZvaWQgMCA6IF9sZXZlbCR2aWRlb0NvZGVjLnNwbGl0KCcsJyk7XG4gIGNvbnN0IGJpdHJhdGUgPSBnZXRWYXJpYW50RGVjb2RpbmdCaXRyYXRlKGxldmVsKTtcbiAgY29uc3Qgd2lkdGggPSBsZXZlbC53aWR0aCB8fCA2NDA7XG4gIGNvbnN0IGhlaWdodCA9IGxldmVsLmhlaWdodCB8fCA0ODA7XG4gIC8vIEFzc3VtZSBhIGZyYW1lcmF0ZSBvZiAzMGZwcyBzaW5jZSBNZWRpYUNhcGFiaWxpdGllcyB3aWxsIG5vdCBhY2NlcHQgTGV2ZWwgZGVmYXVsdCBvZiAwLlxuICBjb25zdCBmcmFtZXJhdGUgPSBsZXZlbC5mcmFtZVJhdGUgfHwgMzA7XG4gIGNvbnN0IHZpZGVvUmFuZ2UgPSBsZXZlbC52aWRlb1JhbmdlLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiB2aWRlb0NvZGVjcyA/IHZpZGVvQ29kZWNzLm1hcCh2aWRlb0NvZGVjID0+IHtcbiAgICBjb25zdCB2aWRlb0NvbmZpZ3VyYXRpb24gPSB7XG4gICAgICBjb250ZW50VHlwZTogbWltZVR5cGVGb3JDb2RlYyhmaWxsSW5NaXNzaW5nQVYwMVBhcmFtcyh2aWRlb0NvZGVjKSwgJ3ZpZGVvJyksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGJpdHJhdGUsXG4gICAgICBmcmFtZXJhdGVcbiAgICB9O1xuICAgIGlmICh2aWRlb1JhbmdlICE9PSAnc2RyJykge1xuICAgICAgdmlkZW9Db25maWd1cmF0aW9uLnRyYW5zZmVyRnVuY3Rpb24gPSB2aWRlb1JhbmdlO1xuICAgIH1cbiAgICByZXR1cm4gdmlkZW9Db25maWd1cmF0aW9uO1xuICB9KSA6IFtdO1xufVxuZnVuY3Rpb24gbWFrZUF1ZGlvQ29uZmlndXJhdGlvbnMobGV2ZWwsIGF1ZGlvVHJhY2tzQnlHcm91cCwgaGFzVmlkZW8pIHtcbiAgdmFyIF9sZXZlbCRhdWRpb0NvZGVjO1xuICBjb25zdCBhdWRpb0NvZGVjcyA9IChfbGV2ZWwkYXVkaW9Db2RlYyA9IGxldmVsLmF1ZGlvQ29kZWMpID09IG51bGwgPyB2b2lkIDAgOiBfbGV2ZWwkYXVkaW9Db2RlYy5zcGxpdCgnLCcpO1xuICBjb25zdCBjb21iaW5lZEJpdHJhdGUgPSBnZXRWYXJpYW50RGVjb2RpbmdCaXRyYXRlKGxldmVsKTtcbiAgaWYgKGF1ZGlvQ29kZWNzICYmIGxldmVsLmF1ZGlvR3JvdXBzKSB7XG4gICAgcmV0dXJuIGxldmVsLmF1ZGlvR3JvdXBzLnJlZHVjZSgoY29uZmlndXJhdGlvbnMsIGF1ZGlvR3JvdXBJZCkgPT4ge1xuICAgICAgdmFyIF9hdWRpb1RyYWNrc0J5R3JvdXAkZztcbiAgICAgIGNvbnN0IHRyYWNrcyA9IGF1ZGlvR3JvdXBJZCA/IChfYXVkaW9UcmFja3NCeUdyb3VwJGcgPSBhdWRpb1RyYWNrc0J5R3JvdXAuZ3JvdXBzW2F1ZGlvR3JvdXBJZF0pID09IG51bGwgPyB2b2lkIDAgOiBfYXVkaW9UcmFja3NCeUdyb3VwJGcudHJhY2tzIDogbnVsbDtcbiAgICAgIGlmICh0cmFja3MpIHtcbiAgICAgICAgcmV0dXJuIHRyYWNrcy5yZWR1Y2UoKGNvbmZpZ3MsIGF1ZGlvVHJhY2spID0+IHtcbiAgICAgICAgICBpZiAoYXVkaW9UcmFjay5ncm91cElkID09PSBhdWRpb0dyb3VwSWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5uZWxzTnVtYmVyID0gcGFyc2VGbG9hdChhdWRpb1RyYWNrLmNoYW5uZWxzIHx8ICcnKTtcbiAgICAgICAgICAgIGF1ZGlvQ29kZWNzLmZvckVhY2goYXVkaW9Db2RlYyA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGF1ZGlvQ29uZmlndXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogbWltZVR5cGVGb3JDb2RlYyhhdWRpb0NvZGVjLCAnYXVkaW8nKSxcbiAgICAgICAgICAgICAgICBiaXRyYXRlOiBoYXNWaWRlbyA/IGVzdGltYXRlZEF1ZGlvQml0cmF0ZShhdWRpb0NvZGVjLCBjb21iaW5lZEJpdHJhdGUpIDogY29tYmluZWRCaXRyYXRlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGlmIChjaGFubmVsc051bWJlcikge1xuICAgICAgICAgICAgICAgIGF1ZGlvQ29uZmlndXJhdGlvbi5jaGFubmVscyA9ICcnICsgY2hhbm5lbHNOdW1iZXI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uZmlncy5wdXNoKGF1ZGlvQ29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNvbmZpZ3M7XG4gICAgICAgIH0sIGNvbmZpZ3VyYXRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb25maWd1cmF0aW9ucztcbiAgICB9LCBbXSk7XG4gIH1cbiAgcmV0dXJuIFtdO1xufVxuZnVuY3Rpb24gZXN0aW1hdGVkQXVkaW9CaXRyYXRlKGF1ZGlvQ29kZWMsIGxldmVsQml0cmF0ZSkge1xuICBpZiAobGV2ZWxCaXRyYXRlIDw9IDEpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBsZXQgYXVkaW9CaXRyYXRlID0gMTI4MDAwO1xuICBpZiAoYXVkaW9Db2RlYyA9PT0gJ2VjLTMnKSB7XG4gICAgYXVkaW9CaXRyYXRlID0gNzY4MDAwO1xuICB9IGVsc2UgaWYgKGF1ZGlvQ29kZWMgPT09ICdhYy0zJykge1xuICAgIGF1ZGlvQml0cmF0ZSA9IDY0MDAwMDtcbiAgfVxuICByZXR1cm4gTWF0aC5taW4obGV2ZWxCaXRyYXRlIC8gMiwgYXVkaW9CaXRyYXRlKTsgLy8gRG9uJ3QgZXhjZWVkIHNvbWUgJSBvZiBsZXZlbCBiaXRyYXRlXG59XG5mdW5jdGlvbiBnZXRWYXJpYW50RGVjb2RpbmdCaXRyYXRlKGxldmVsKSB7XG4gIHJldHVybiBNYXRoLmNlaWwoTWF0aC5tYXgobGV2ZWwuYml0cmF0ZSAqIDAuOSwgbGV2ZWwuYXZlcmFnZUJpdHJhdGUpIC8gMTAwMCkgKiAxMDAwIHx8IDE7XG59XG5mdW5jdGlvbiBnZXRNZWRpYURlY29kaW5nSW5mb0tleShjb25maWcpIHtcbiAgbGV0IGtleSA9ICcnO1xuICBjb25zdCB7XG4gICAgYXVkaW8sXG4gICAgdmlkZW9cbiAgfSA9IGNvbmZpZztcbiAgaWYgKHZpZGVvKSB7XG4gICAgY29uc3QgY29kZWMgPSBnZXRDb2RlY3NGb3JNaW1lVHlwZSh2aWRlby5jb250ZW50VHlwZSk7XG4gICAga2V5ICs9IGAke2NvZGVjfV9yJHt2aWRlby5oZWlnaHR9eCR7dmlkZW8ud2lkdGh9ZiR7TWF0aC5jZWlsKHZpZGVvLmZyYW1lcmF0ZSl9JHt2aWRlby50cmFuc2ZlckZ1bmN0aW9uIHx8ICdzZCd9XyR7TWF0aC5jZWlsKHZpZGVvLmJpdHJhdGUgLyAxZTUpfWA7XG4gIH1cbiAgaWYgKGF1ZGlvKSB7XG4gICAgY29uc3QgY29kZWMgPSBnZXRDb2RlY3NGb3JNaW1lVHlwZShhdWRpby5jb250ZW50VHlwZSk7XG4gICAga2V5ICs9IGAke3ZpZGVvID8gJ18nIDogJyd9JHtjb2RlY31fYyR7YXVkaW8uY2hhbm5lbHN9YDtcbiAgfVxuICByZXR1cm4ga2V5O1xufVxuXG5jb25zdCBIZGNwTGV2ZWxzID0gWydOT05FJywgJ1RZUEUtMCcsICdUWVBFLTEnLCBudWxsXTtcbmZ1bmN0aW9uIGlzSGRjcExldmVsKHZhbHVlKSB7XG4gIHJldHVybiBIZGNwTGV2ZWxzLmluZGV4T2YodmFsdWUpID4gLTE7XG59XG5jb25zdCBWaWRlb1JhbmdlVmFsdWVzID0gWydTRFInLCAnUFEnLCAnSExHJ107XG5mdW5jdGlvbiBpc1ZpZGVvUmFuZ2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgVmlkZW9SYW5nZVZhbHVlcy5pbmRleE9mKHZhbHVlKSA+IC0xO1xufVxudmFyIEhsc1NraXAgPSB7XG4gIE5vOiBcIlwiLFxuICBZZXM6IFwiWUVTXCIsXG4gIHYyOiBcInYyXCJcbn07XG5mdW5jdGlvbiBnZXRTa2lwVmFsdWUoZGV0YWlscykge1xuICBjb25zdCB7XG4gICAgY2FuU2tpcFVudGlsLFxuICAgIGNhblNraXBEYXRlUmFuZ2VzLFxuICAgIGFnZVxuICB9ID0gZGV0YWlscztcbiAgLy8gQSBDbGllbnQgU0hPVUxEIE5PVCByZXF1ZXN0IGEgUGxheWxpc3QgRGVsdGEgVXBkYXRlIHVubGVzcyBpdCBhbHJlYWR5XG4gIC8vIGhhcyBhIHZlcnNpb24gb2YgdGhlIFBsYXlsaXN0IHRoYXQgaXMgbm8gb2xkZXIgdGhhbiBvbmUtaGFsZiBvZiB0aGUgU2tpcCBCb3VuZGFyeS5cbiAgLy8gQHNlZTogaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1wYW50b3MtaGxzLXJmYzgyMTZiaXMjc2VjdGlvbi02LjMuN1xuICBjb25zdCBwbGF5bGlzdFJlY2VudEVub3VnaCA9IGFnZSA8IGNhblNraXBVbnRpbCAvIDI7XG4gIGlmIChjYW5Ta2lwVW50aWwgJiYgcGxheWxpc3RSZWNlbnRFbm91Z2gpIHtcbiAgICBpZiAoY2FuU2tpcERhdGVSYW5nZXMpIHtcbiAgICAgIHJldHVybiBIbHNTa2lwLnYyO1xuICAgIH1cbiAgICByZXR1cm4gSGxzU2tpcC5ZZXM7XG4gIH1cbiAgcmV0dXJuIEhsc1NraXAuTm87XG59XG5jbGFzcyBIbHNVcmxQYXJhbWV0ZXJzIHtcbiAgY29uc3RydWN0b3IobXNuLCBwYXJ0LCBza2lwKSB7XG4gICAgdGhpcy5tc24gPSB2b2lkIDA7XG4gICAgdGhpcy5wYXJ0ID0gdm9pZCAwO1xuICAgIHRoaXMuc2tpcCA9IHZvaWQgMDtcbiAgICB0aGlzLm1zbiA9IG1zbjtcbiAgICB0aGlzLnBhcnQgPSBwYXJ0O1xuICAgIHRoaXMuc2tpcCA9IHNraXA7XG4gIH1cbiAgYWRkRGlyZWN0aXZlcyh1cmkpIHtcbiAgICBjb25zdCB1cmwgPSBuZXcgc2VsZi5VUkwodXJpKTtcbiAgICBpZiAodGhpcy5tc24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ19ITFNfbXNuJywgdGhpcy5tc24udG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnBhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ19ITFNfcGFydCcsIHRoaXMucGFydC50b1N0cmluZygpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc2tpcCkge1xuICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ19ITFNfc2tpcCcsIHRoaXMuc2tpcCk7XG4gICAgfVxuICAgIHJldHVybiB1cmwuaHJlZjtcbiAgfVxufVxuY2xhc3MgTGV2ZWwge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgdGhpcy5fYXR0cnMgPSB2b2lkIDA7XG4gICAgdGhpcy5hdWRpb0NvZGVjID0gdm9pZCAwO1xuICAgIHRoaXMuYml0cmF0ZSA9IHZvaWQgMDtcbiAgICB0aGlzLmNvZGVjU2V0ID0gdm9pZCAwO1xuICAgIHRoaXMudXJsID0gdm9pZCAwO1xuICAgIHRoaXMuZnJhbWVSYXRlID0gdm9pZCAwO1xuICAgIHRoaXMuaGVpZ2h0ID0gdm9pZCAwO1xuICAgIHRoaXMuaWQgPSB2b2lkIDA7XG4gICAgdGhpcy5uYW1lID0gdm9pZCAwO1xuICAgIHRoaXMuc3VwcGxlbWVudGFsID0gdm9pZCAwO1xuICAgIHRoaXMudmlkZW9Db2RlYyA9IHZvaWQgMDtcbiAgICB0aGlzLndpZHRoID0gdm9pZCAwO1xuICAgIHRoaXMuZGV0YWlscyA9IHZvaWQgMDtcbiAgICB0aGlzLmZyYWdtZW50RXJyb3IgPSAwO1xuICAgIHRoaXMubG9hZEVycm9yID0gMDtcbiAgICB0aGlzLmxvYWRlZCA9IHZvaWQgMDtcbiAgICB0aGlzLnJlYWxCaXRyYXRlID0gMDtcbiAgICB0aGlzLnN1cHBvcnRlZFByb21pc2UgPSB2b2lkIDA7XG4gICAgdGhpcy5zdXBwb3J0ZWRSZXN1bHQgPSB2b2lkIDA7XG4gICAgdGhpcy5fYXZnQml0cmF0ZSA9IDA7XG4gICAgdGhpcy5fYXVkaW9Hcm91cHMgPSB2b2lkIDA7XG4gICAgdGhpcy5fc3VidGl0bGVHcm91cHMgPSB2b2lkIDA7XG4gICAgLy8gRGVwcmVjYXRlZCAocmV0YWluZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5KVxuICAgIHRoaXMuX3VybElkID0gMDtcbiAgICB0aGlzLnVybCA9IFtkYXRhLnVybF07XG4gICAgdGhpcy5fYXR0cnMgPSBbZGF0YS5hdHRyc107XG4gICAgdGhpcy5iaXRyYXRlID0gZGF0YS5iaXRyYXRlO1xuICAgIGlmIChkYXRhLmRldGFpbHMpIHtcbiAgICAgIHRoaXMuZGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICB9XG4gICAgdGhpcy5pZCA9IGRhdGEuaWQgfHwgMDtcbiAgICB0aGlzLm5hbWUgPSBkYXRhLm5hbWU7XG4gICAgdGhpcy53aWR0aCA9IGRhdGEud2lkdGggfHwgMDtcbiAgICB0aGlzLmhlaWdodCA9IGRhdGEuaGVpZ2h0IHx8IDA7XG4gICAgdGhpcy5mcmFtZVJhdGUgPSBkYXRhLmF0dHJzLm9wdGlvbmFsRmxvYXQoJ0ZSQU1FLVJBVEUnLCAwKTtcbiAgICB0aGlzLl9hdmdCaXRyYXRlID0gZGF0YS5hdHRycy5kZWNpbWFsSW50ZWdlcignQVZFUkFHRS1CQU5EV0lEVEgnKTtcbiAgICB0aGlzLmF1ZGlvQ29kZWMgPSBkYXRhLmF1ZGlvQ29kZWM7XG4gICAgdGhpcy52aWRlb0NvZGVjID0gZGF0YS52aWRlb0NvZGVjO1xuICAgIHRoaXMuY29kZWNTZXQgPSBbZGF0YS52aWRlb0NvZGVjLCBkYXRhLmF1ZGlvQ29kZWNdLmZpbHRlcihjID0+ICEhYykubWFwKHMgPT4gcy5zdWJzdHJpbmcoMCwgNCkpLmpvaW4oJywnKTtcbiAgICBpZiAoJ3N1cHBsZW1lbnRhbCcgaW4gZGF0YSkge1xuICAgICAgdmFyIF9kYXRhJHN1cHBsZW1lbnRhbDtcbiAgICAgIHRoaXMuc3VwcGxlbWVudGFsID0gZGF0YS5zdXBwbGVtZW50YWw7XG4gICAgICBjb25zdCBzdXBwbGVtZW50YWxWaWRlbyA9IChfZGF0YSRzdXBwbGVtZW50YWwgPSBkYXRhLnN1cHBsZW1lbnRhbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhJHN1cHBsZW1lbnRhbC52aWRlb0NvZGVjO1xuICAgICAgaWYgKHN1cHBsZW1lbnRhbFZpZGVvICYmIHN1cHBsZW1lbnRhbFZpZGVvICE9PSBkYXRhLnZpZGVvQ29kZWMpIHtcbiAgICAgICAgdGhpcy5jb2RlY1NldCArPSBgLCR7c3VwcGxlbWVudGFsVmlkZW8uc3Vic3RyaW5nKDAsIDQpfWA7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYWRkR3JvdXBJZCgnYXVkaW8nLCBkYXRhLmF0dHJzLkFVRElPKTtcbiAgICB0aGlzLmFkZEdyb3VwSWQoJ3RleHQnLCBkYXRhLmF0dHJzLlNVQlRJVExFUyk7XG4gIH1cbiAgZ2V0IG1heEJpdHJhdGUoKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KHRoaXMucmVhbEJpdHJhdGUsIHRoaXMuYml0cmF0ZSk7XG4gIH1cbiAgZ2V0IGF2ZXJhZ2VCaXRyYXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9hdmdCaXRyYXRlIHx8IHRoaXMucmVhbEJpdHJhdGUgfHwgdGhpcy5iaXRyYXRlO1xuICB9XG4gIGdldCBhdHRycygpIHtcbiAgICByZXR1cm4gdGhpcy5fYXR0cnNbMF07XG4gIH1cbiAgZ2V0IGNvZGVjcygpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRycy5DT0RFQ1MgfHwgJyc7XG4gIH1cbiAgZ2V0IHBhdGh3YXlJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyc1snUEFUSFdBWS1JRCddIHx8ICcuJztcbiAgfVxuICBnZXQgdmlkZW9SYW5nZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyc1snVklERU8tUkFOR0UnXSB8fCAnU0RSJztcbiAgfVxuICBnZXQgc2NvcmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cnMub3B0aW9uYWxGbG9hdCgnU0NPUkUnLCAwKTtcbiAgfVxuICBnZXQgdXJpKCkge1xuICAgIHJldHVybiB0aGlzLnVybFswXSB8fCAnJztcbiAgfVxuICBoYXNBdWRpb0dyb3VwKGdyb3VwSWQpIHtcbiAgICByZXR1cm4gaGFzR3JvdXAodGhpcy5fYXVkaW9Hcm91cHMsIGdyb3VwSWQpO1xuICB9XG4gIGhhc1N1YnRpdGxlR3JvdXAoZ3JvdXBJZCkge1xuICAgIHJldHVybiBoYXNHcm91cCh0aGlzLl9zdWJ0aXRsZUdyb3VwcywgZ3JvdXBJZCk7XG4gIH1cbiAgZ2V0IGF1ZGlvR3JvdXBzKCkge1xuICAgIHJldHVybiB0aGlzLl9hdWRpb0dyb3VwcztcbiAgfVxuICBnZXQgc3VidGl0bGVHcm91cHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N1YnRpdGxlR3JvdXBzO1xuICB9XG4gIGFkZEdyb3VwSWQodHlwZSwgZ3JvdXBJZCkge1xuICAgIGlmICghZ3JvdXBJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgbGV0IGF1ZGlvR3JvdXBzID0gdGhpcy5fYXVkaW9Hcm91cHM7XG4gICAgICBpZiAoIWF1ZGlvR3JvdXBzKSB7XG4gICAgICAgIGF1ZGlvR3JvdXBzID0gdGhpcy5fYXVkaW9Hcm91cHMgPSBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChhdWRpb0dyb3Vwcy5pbmRleE9mKGdyb3VwSWQpID09PSAtMSkge1xuICAgICAgICBhdWRpb0dyb3Vwcy5wdXNoKGdyb3VwSWQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICBsZXQgc3VidGl0bGVHcm91cHMgPSB0aGlzLl9zdWJ0aXRsZUdyb3VwcztcbiAgICAgIGlmICghc3VidGl0bGVHcm91cHMpIHtcbiAgICAgICAgc3VidGl0bGVHcm91cHMgPSB0aGlzLl9zdWJ0aXRsZUdyb3VwcyA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKHN1YnRpdGxlR3JvdXBzLmluZGV4T2YoZ3JvdXBJZCkgPT09IC0xKSB7XG4gICAgICAgIHN1YnRpdGxlR3JvdXBzLnB1c2goZ3JvdXBJZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gRGVwcmVjYXRlZCBtZXRob2RzIChyZXRhaW5lZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkpXG4gIGdldCB1cmxJZCgpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBzZXQgdXJsSWQodmFsdWUpIHt9XG4gIGdldCBhdWRpb0dyb3VwSWRzKCkge1xuICAgIHJldHVybiB0aGlzLmF1ZGlvR3JvdXBzID8gW3RoaXMuYXVkaW9Hcm91cElkXSA6IHVuZGVmaW5lZDtcbiAgfVxuICBnZXQgdGV4dEdyb3VwSWRzKCkge1xuICAgIHJldHVybiB0aGlzLnN1YnRpdGxlR3JvdXBzID8gW3RoaXMudGV4dEdyb3VwSWRdIDogdW5kZWZpbmVkO1xuICB9XG4gIGdldCBhdWRpb0dyb3VwSWQoKSB7XG4gICAgdmFyIF90aGlzJGF1ZGlvR3JvdXBzO1xuICAgIHJldHVybiAoX3RoaXMkYXVkaW9Hcm91cHMgPSB0aGlzLmF1ZGlvR3JvdXBzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkYXVkaW9Hcm91cHNbMF07XG4gIH1cbiAgZ2V0IHRleHRHcm91cElkKCkge1xuICAgIHZhciBfdGhpcyRzdWJ0aXRsZUdyb3VwcztcbiAgICByZXR1cm4gKF90aGlzJHN1YnRpdGxlR3JvdXBzID0gdGhpcy5zdWJ0aXRsZUdyb3VwcykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHN1YnRpdGxlR3JvdXBzWzBdO1xuICB9XG4gIGFkZEZhbGxiYWNrKCkge31cbn1cbmZ1bmN0aW9uIGhhc0dyb3VwKGdyb3VwcywgZ3JvdXBJZCkge1xuICBpZiAoIWdyb3VwSWQgfHwgIWdyb3Vwcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gZ3JvdXBzLmluZGV4T2YoZ3JvdXBJZCkgIT09IC0xO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIFdoZXRoZXIgd2UgY2FuIGRldGVjdCBhbmQgdmFsaWRhdGUgSERSIGNhcGFiaWxpdHkgd2l0aGluIHRoZSB3aW5kb3cgY29udGV4dFxuICovXG5mdW5jdGlvbiBpc0hkclN1cHBvcnRlZCgpIHtcbiAgaWYgKHR5cGVvZiBtYXRjaE1lZGlhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgbWVkaWFRdWVyeUxpc3QgPSBtYXRjaE1lZGlhKCcoZHluYW1pYy1yYW5nZTogaGlnaCknKTtcbiAgICBjb25zdCBiYWRRdWVyeSA9IG1hdGNoTWVkaWEoJ2JhZCBxdWVyeScpO1xuICAgIGlmIChtZWRpYVF1ZXJ5TGlzdC5tZWRpYSAhPT0gYmFkUXVlcnkubWVkaWEpIHtcbiAgICAgIHJldHVybiBtZWRpYVF1ZXJ5TGlzdC5tYXRjaGVzID09PSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogU2FuaXRpemVzIGlucHV0cyB0byByZXR1cm4gdGhlIGFjdGl2ZSB2aWRlbyBzZWxlY3Rpb24gb3B0aW9ucyBmb3IgSERSL1NEUi5cbiAqIFdoZW4gYm90aCBpbnB1dHMgYXJlIG51bGw6XG4gKlxuICogICAgYHsgcHJlZmVySERSOiBmYWxzZSwgYWxsb3dlZFZpZGVvUmFuZ2VzOiBbXSB9YFxuICpcbiAqIFdoZW4gYGN1cnJlbnRWaWRlb1JhbmdlYCBub24tbnVsbCwgbWFpbnRhaW4gdGhlIGFjdGl2ZSByYW5nZTpcbiAqXG4gKiAgICBgeyBwcmVmZXJIRFI6IGN1cnJlbnRWaWRlb1JhbmdlICE9PSAnU0RSJywgYWxsb3dlZFZpZGVvUmFuZ2VzOiBbY3VycmVudFZpZGVvUmFuZ2VdIH1gXG4gKlxuICogV2hlbiBWaWRlb1NlbGVjdGlvbk9wdGlvbiBub24tbnVsbDpcbiAqXG4gKiAgLSBBbGxvdyBhbGwgdmlkZW8gcmFuZ2VzIGlmIGBhbGxvd2VkVmlkZW9SYW5nZXNgIHVuc3BlY2lmaWVkLlxuICogIC0gSWYgYHByZWZlckhEUmAgaXMgbm9uLW51bGwgdXNlIHRoZSB2YWx1ZSB0byBmaWx0ZXIgYGFsbG93ZWRWaWRlb1Jhbmdlc2AuXG4gKiAgLSBFbHNlIGNoZWNrIHdpbmRvdyBmb3IgSERSIHN1cHBvcnQgYW5kIHNldCBgcHJlZmVySERSYCB0byB0aGUgcmVzdWx0LlxuICpcbiAqIEBwYXJhbSBjdXJyZW50VmlkZW9SYW5nZVxuICogQHBhcmFtIHZpZGVvUHJlZmVyZW5jZVxuICovXG5mdW5jdGlvbiBnZXRWaWRlb1NlbGVjdGlvbk9wdGlvbnMoY3VycmVudFZpZGVvUmFuZ2UsIHZpZGVvUHJlZmVyZW5jZSkge1xuICBsZXQgcHJlZmVySERSID0gZmFsc2U7XG4gIGxldCBhbGxvd2VkVmlkZW9SYW5nZXMgPSBbXTtcbiAgaWYgKGN1cnJlbnRWaWRlb1JhbmdlKSB7XG4gICAgcHJlZmVySERSID0gY3VycmVudFZpZGVvUmFuZ2UgIT09ICdTRFInO1xuICAgIGFsbG93ZWRWaWRlb1JhbmdlcyA9IFtjdXJyZW50VmlkZW9SYW5nZV07XG4gIH1cbiAgaWYgKHZpZGVvUHJlZmVyZW5jZSkge1xuICAgIGFsbG93ZWRWaWRlb1JhbmdlcyA9IHZpZGVvUHJlZmVyZW5jZS5hbGxvd2VkVmlkZW9SYW5nZXMgfHwgVmlkZW9SYW5nZVZhbHVlcy5zbGljZSgwKTtcbiAgICBjb25zdCBhbGxvd0F1dG9QcmVmZXJIRFIgPSBhbGxvd2VkVmlkZW9SYW5nZXMuam9pbignJykgIT09ICdTRFInICYmICF2aWRlb1ByZWZlcmVuY2UudmlkZW9Db2RlYztcbiAgICBwcmVmZXJIRFIgPSB2aWRlb1ByZWZlcmVuY2UucHJlZmVySERSICE9PSB1bmRlZmluZWQgPyB2aWRlb1ByZWZlcmVuY2UucHJlZmVySERSIDogYWxsb3dBdXRvUHJlZmVySERSICYmIGlzSGRyU3VwcG9ydGVkKCk7XG4gICAgaWYgKCFwcmVmZXJIRFIpIHtcbiAgICAgIGFsbG93ZWRWaWRlb1JhbmdlcyA9IFsnU0RSJ107XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgcHJlZmVySERSLFxuICAgIGFsbG93ZWRWaWRlb1Jhbmdlc1xuICB9O1xufVxuXG5jb25zdCBvbWl0Q2lyY3VsYXJSZWZzUmVwbGFjZXIgPSByZXBsYWNlciA9PiB7XG4gIGNvbnN0IGtub3duID0gbmV3IFdlYWtTZXQoKTtcbiAgcmV0dXJuIChfLCB2YWx1ZSkgPT4ge1xuICAgIGlmIChyZXBsYWNlcikge1xuICAgICAgdmFsdWUgPSByZXBsYWNlcihfLCB2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICBpZiAoa25vd24uaGFzKHZhbHVlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBrbm93bi5hZGQodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59O1xuY29uc3Qgc3RyaW5naWZ5ID0gKG9iamVjdCwgcmVwbGFjZXIpID0+IEpTT04uc3RyaW5naWZ5KG9iamVjdCwgb21pdENpcmN1bGFyUmVmc1JlcGxhY2VyKHJlcGxhY2VyKSk7XG5cbmZ1bmN0aW9uIGdldFN0YXJ0Q29kZWNUaWVyKGNvZGVjVGllcnMsIGN1cnJlbnRWaWRlb1JhbmdlLCBjdXJyZW50QncsIGF1ZGlvUHJlZmVyZW5jZSwgdmlkZW9QcmVmZXJlbmNlKSB7XG4gIGNvbnN0IGNvZGVjU2V0cyA9IE9iamVjdC5rZXlzKGNvZGVjVGllcnMpO1xuICBjb25zdCBjaGFubmVsc1ByZWZlcmVuY2UgPSBhdWRpb1ByZWZlcmVuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGF1ZGlvUHJlZmVyZW5jZS5jaGFubmVscztcbiAgY29uc3QgYXVkaW9Db2RlY1ByZWZlcmVuY2UgPSBhdWRpb1ByZWZlcmVuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGF1ZGlvUHJlZmVyZW5jZS5hdWRpb0NvZGVjO1xuICBjb25zdCB2aWRlb0NvZGVjUHJlZmVyZW5jZSA9IHZpZGVvUHJlZmVyZW5jZSA9PSBudWxsID8gdm9pZCAwIDogdmlkZW9QcmVmZXJlbmNlLnZpZGVvQ29kZWM7XG4gIGNvbnN0IHByZWZlclN0ZXJlbyA9IGNoYW5uZWxzUHJlZmVyZW5jZSAmJiBwYXJzZUludChjaGFubmVsc1ByZWZlcmVuY2UpID09PSAyO1xuICAvLyBVc2UgZmlyc3QgbGV2ZWwgc2V0IHRvIGRldGVybWluZSBzdGVyZW8sIGFuZCBtaW5pbXVtIHJlc29sdXRpb24gYW5kIGZyYW1lcmF0ZVxuICBsZXQgaGFzU3RlcmVvID0gZmFsc2U7XG4gIGxldCBoYXNDdXJyZW50VmlkZW9SYW5nZSA9IGZhbHNlO1xuICBsZXQgbWluSGVpZ2h0ID0gSW5maW5pdHk7XG4gIGxldCBtaW5GcmFtZXJhdGUgPSBJbmZpbml0eTtcbiAgbGV0IG1pbkJpdHJhdGUgPSBJbmZpbml0eTtcbiAgbGV0IG1pbkluZGV4ID0gSW5maW5pdHk7XG4gIGxldCBzZWxlY3RlZFNjb3JlID0gMDtcbiAgbGV0IHZpZGVvUmFuZ2VzID0gW107XG4gIGNvbnN0IHtcbiAgICBwcmVmZXJIRFIsXG4gICAgYWxsb3dlZFZpZGVvUmFuZ2VzXG4gIH0gPSBnZXRWaWRlb1NlbGVjdGlvbk9wdGlvbnMoY3VycmVudFZpZGVvUmFuZ2UsIHZpZGVvUHJlZmVyZW5jZSk7XG4gIGZvciAobGV0IGkgPSBjb2RlY1NldHMubGVuZ3RoOyBpLS07KSB7XG4gICAgY29uc3QgdGllciA9IGNvZGVjVGllcnNbY29kZWNTZXRzW2ldXTtcbiAgICBoYXNTdGVyZW8gfHwgKGhhc1N0ZXJlbyA9IHRpZXIuY2hhbm5lbHNbMl0gPiAwKTtcbiAgICBtaW5IZWlnaHQgPSBNYXRoLm1pbihtaW5IZWlnaHQsIHRpZXIubWluSGVpZ2h0KTtcbiAgICBtaW5GcmFtZXJhdGUgPSBNYXRoLm1pbihtaW5GcmFtZXJhdGUsIHRpZXIubWluRnJhbWVyYXRlKTtcbiAgICBtaW5CaXRyYXRlID0gTWF0aC5taW4obWluQml0cmF0ZSwgdGllci5taW5CaXRyYXRlKTtcbiAgICBjb25zdCBtYXRjaGluZ1ZpZGVvUmFuZ2VzID0gYWxsb3dlZFZpZGVvUmFuZ2VzLmZpbHRlcihyYW5nZSA9PiB0aWVyLnZpZGVvUmFuZ2VzW3JhbmdlXSA+IDApO1xuICAgIGlmIChtYXRjaGluZ1ZpZGVvUmFuZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIGhhc0N1cnJlbnRWaWRlb1JhbmdlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgbWluSGVpZ2h0ID0gaXNGaW5pdGVOdW1iZXIobWluSGVpZ2h0KSA/IG1pbkhlaWdodCA6IDA7XG4gIG1pbkZyYW1lcmF0ZSA9IGlzRmluaXRlTnVtYmVyKG1pbkZyYW1lcmF0ZSkgPyBtaW5GcmFtZXJhdGUgOiAwO1xuICBjb25zdCBtYXhIZWlnaHQgPSBNYXRoLm1heCgxMDgwLCBtaW5IZWlnaHQpO1xuICBjb25zdCBtYXhGcmFtZXJhdGUgPSBNYXRoLm1heCgzMCwgbWluRnJhbWVyYXRlKTtcbiAgbWluQml0cmF0ZSA9IGlzRmluaXRlTnVtYmVyKG1pbkJpdHJhdGUpID8gbWluQml0cmF0ZSA6IGN1cnJlbnRCdztcbiAgY3VycmVudEJ3ID0gTWF0aC5tYXgobWluQml0cmF0ZSwgY3VycmVudEJ3KTtcbiAgLy8gSWYgdGhlcmUgYXJlIG5vIHZhcmlhbnRzIHdpdGggbWF0Y2hpbmcgcHJlZmVyZW5jZSwgc2V0IGN1cnJlbnRWaWRlb1JhbmdlIHRvIHVuZGVmaW5lZFxuICBpZiAoIWhhc0N1cnJlbnRWaWRlb1JhbmdlKSB7XG4gICAgY3VycmVudFZpZGVvUmFuZ2UgPSB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3QgaGFzTXVsdGlwbGVTZXRzID0gY29kZWNTZXRzLmxlbmd0aCA+IDE7XG4gIGNvbnN0IGNvZGVjU2V0ID0gY29kZWNTZXRzLnJlZHVjZSgoc2VsZWN0ZWQsIGNhbmRpZGF0ZSkgPT4ge1xuICAgIC8vIFJlbW92ZSBjYW5kaWF0ZXMgd2hpY2ggZG8gbm90IG1lZXQgYml0cmF0ZSwgZGVmYXVsdCBhdWRpbywgc3RlcmVvIG9yIGNoYW5uZWxzIHByZWZlcmVuY2UsIDEwODBwIG9yIGxvd2VyLCAzMGZwcyBvciBsb3dlciwgb3IgU0RSL0hEUiBzZWxlY3Rpb24gaWYgcHJlc2VudFxuICAgIGNvbnN0IGNhbmRpZGF0ZVRpZXIgPSBjb2RlY1RpZXJzW2NhbmRpZGF0ZV07XG4gICAgaWYgKGNhbmRpZGF0ZSA9PT0gc2VsZWN0ZWQpIHtcbiAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICB9XG4gICAgdmlkZW9SYW5nZXMgPSBoYXNDdXJyZW50VmlkZW9SYW5nZSA/IGFsbG93ZWRWaWRlb1Jhbmdlcy5maWx0ZXIocmFuZ2UgPT4gY2FuZGlkYXRlVGllci52aWRlb1Jhbmdlc1tyYW5nZV0gPiAwKSA6IFtdO1xuICAgIGlmIChoYXNNdWx0aXBsZVNldHMpIHtcbiAgICAgIGlmIChjYW5kaWRhdGVUaWVyLm1pbkJpdHJhdGUgPiBjdXJyZW50QncpIHtcbiAgICAgICAgbG9nU3RhcnRDb2RlY0NhbmRpZGF0ZUlnbm9yZWQoY2FuZGlkYXRlLCBgbWluIGJpdHJhdGUgb2YgJHtjYW5kaWRhdGVUaWVyLm1pbkJpdHJhdGV9ID4gY3VycmVudCBlc3RpbWF0ZSBvZiAke2N1cnJlbnRCd31gKTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgICAgfVxuICAgICAgaWYgKCFjYW5kaWRhdGVUaWVyLmhhc0RlZmF1bHRBdWRpbykge1xuICAgICAgICBsb2dTdGFydENvZGVjQ2FuZGlkYXRlSWdub3JlZChjYW5kaWRhdGUsIGBubyByZW5kaXRpb25zIHdpdGggZGVmYXVsdCBvciBhdXRvLXNlbGVjdCBzb3VuZCBmb3VuZGApO1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgICBpZiAoYXVkaW9Db2RlY1ByZWZlcmVuY2UgJiYgY2FuZGlkYXRlLmluZGV4T2YoYXVkaW9Db2RlY1ByZWZlcmVuY2Uuc3Vic3RyaW5nKDAsIDQpKSAlIDUgIT09IDApIHtcbiAgICAgICAgbG9nU3RhcnRDb2RlY0NhbmRpZGF0ZUlnbm9yZWQoY2FuZGlkYXRlLCBgYXVkaW8gY29kZWMgcHJlZmVyZW5jZSBcIiR7YXVkaW9Db2RlY1ByZWZlcmVuY2V9XCIgbm90IGZvdW5kYCk7XG4gICAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFubmVsc1ByZWZlcmVuY2UgJiYgIXByZWZlclN0ZXJlbykge1xuICAgICAgICBpZiAoIWNhbmRpZGF0ZVRpZXIuY2hhbm5lbHNbY2hhbm5lbHNQcmVmZXJlbmNlXSkge1xuICAgICAgICAgIGxvZ1N0YXJ0Q29kZWNDYW5kaWRhdGVJZ25vcmVkKGNhbmRpZGF0ZSwgYG5vIHJlbmRpdGlvbnMgd2l0aCAke2NoYW5uZWxzUHJlZmVyZW5jZX0gY2hhbm5lbCBzb3VuZCBmb3VuZCAoY2hhbm5lbHMgb3B0aW9uczogJHtPYmplY3Qua2V5cyhjYW5kaWRhdGVUaWVyLmNoYW5uZWxzKX0pYCk7XG4gICAgICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCghYXVkaW9Db2RlY1ByZWZlcmVuY2UgfHwgcHJlZmVyU3RlcmVvKSAmJiBoYXNTdGVyZW8gJiYgY2FuZGlkYXRlVGllci5jaGFubmVsc1snMiddID09PSAwKSB7XG4gICAgICAgIGxvZ1N0YXJ0Q29kZWNDYW5kaWRhdGVJZ25vcmVkKGNhbmRpZGF0ZSwgYG5vIHJlbmRpdGlvbnMgd2l0aCBzdGVyZW8gc291bmQgZm91bmRgKTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgICAgfVxuICAgICAgaWYgKGNhbmRpZGF0ZVRpZXIubWluSGVpZ2h0ID4gbWF4SGVpZ2h0KSB7XG4gICAgICAgIGxvZ1N0YXJ0Q29kZWNDYW5kaWRhdGVJZ25vcmVkKGNhbmRpZGF0ZSwgYG1pbiByZXNvbHV0aW9uIG9mICR7Y2FuZGlkYXRlVGllci5taW5IZWlnaHR9ID4gbWF4aW11bSBvZiAke21heEhlaWdodH1gKTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgICAgfVxuICAgICAgaWYgKGNhbmRpZGF0ZVRpZXIubWluRnJhbWVyYXRlID4gbWF4RnJhbWVyYXRlKSB7XG4gICAgICAgIGxvZ1N0YXJ0Q29kZWNDYW5kaWRhdGVJZ25vcmVkKGNhbmRpZGF0ZSwgYG1pbiBmcmFtZXJhdGUgb2YgJHtjYW5kaWRhdGVUaWVyLm1pbkZyYW1lcmF0ZX0gPiBtYXhpbXVtIG9mICR7bWF4RnJhbWVyYXRlfWApO1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgICBpZiAoIXZpZGVvUmFuZ2VzLnNvbWUocmFuZ2UgPT4gY2FuZGlkYXRlVGllci52aWRlb1Jhbmdlc1tyYW5nZV0gPiAwKSkge1xuICAgICAgICBsb2dTdGFydENvZGVjQ2FuZGlkYXRlSWdub3JlZChjYW5kaWRhdGUsIGBubyB2YXJpYW50cyB3aXRoIFZJREVPLVJBTkdFIG9mICR7c3RyaW5naWZ5KHZpZGVvUmFuZ2VzKX0gZm91bmRgKTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgICAgfVxuICAgICAgaWYgKHZpZGVvQ29kZWNQcmVmZXJlbmNlICYmIGNhbmRpZGF0ZS5pbmRleE9mKHZpZGVvQ29kZWNQcmVmZXJlbmNlLnN1YnN0cmluZygwLCA0KSkgJSA1ICE9PSAwKSB7XG4gICAgICAgIGxvZ1N0YXJ0Q29kZWNDYW5kaWRhdGVJZ25vcmVkKGNhbmRpZGF0ZSwgYHZpZGVvIGNvZGVjIHByZWZlcmVuY2UgXCIke3ZpZGVvQ29kZWNQcmVmZXJlbmNlfVwiIG5vdCBmb3VuZGApO1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgICBpZiAoY2FuZGlkYXRlVGllci5tYXhTY29yZSA8IHNlbGVjdGVkU2NvcmUpIHtcbiAgICAgICAgbG9nU3RhcnRDb2RlY0NhbmRpZGF0ZUlnbm9yZWQoY2FuZGlkYXRlLCBgbWF4IHNjb3JlIG9mICR7Y2FuZGlkYXRlVGllci5tYXhTY29yZX0gPCBzZWxlY3RlZCBtYXggb2YgJHtzZWxlY3RlZFNjb3JlfWApO1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFJlbW92ZSBjYW5kaWF0ZXMgd2l0aCBsZXNzIHByZWZlcnJlZCBjb2RlY3Mgb3IgbW9yZSBlcnJvcnNcbiAgICBpZiAoc2VsZWN0ZWQgJiYgKGNvZGVjc1NldFNlbGVjdGlvblByZWZlcmVuY2VWYWx1ZShjYW5kaWRhdGUpID49IGNvZGVjc1NldFNlbGVjdGlvblByZWZlcmVuY2VWYWx1ZShzZWxlY3RlZCkgfHwgY2FuZGlkYXRlVGllci5mcmFnbWVudEVycm9yID4gY29kZWNUaWVyc1tzZWxlY3RlZF0uZnJhZ21lbnRFcnJvcikpIHtcbiAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICB9XG4gICAgbWluSW5kZXggPSBjYW5kaWRhdGVUaWVyLm1pbkluZGV4O1xuICAgIHNlbGVjdGVkU2NvcmUgPSBjYW5kaWRhdGVUaWVyLm1heFNjb3JlO1xuICAgIHJldHVybiBjYW5kaWRhdGU7XG4gIH0sIHVuZGVmaW5lZCk7XG4gIHJldHVybiB7XG4gICAgY29kZWNTZXQsXG4gICAgdmlkZW9SYW5nZXMsXG4gICAgcHJlZmVySERSLFxuICAgIG1pbkZyYW1lcmF0ZSxcbiAgICBtaW5CaXRyYXRlLFxuICAgIG1pbkluZGV4XG4gIH07XG59XG5mdW5jdGlvbiBsb2dTdGFydENvZGVjQ2FuZGlkYXRlSWdub3JlZChjb2RlU2V0LCByZWFzb24pIHtcbiAgbG9nZ2VyLmxvZyhgW2Ficl0gc3RhcnQgY2FuZGlkYXRlcyB3aXRoIFwiJHtjb2RlU2V0fVwiIGlnbm9yZWQgYmVjYXVzZSAke3JlYXNvbn1gKTtcbn1cbmZ1bmN0aW9uIGdldEF1ZGlvVHJhY2tzQnlHcm91cChhbGxBdWRpb1RyYWNrcykge1xuICByZXR1cm4gYWxsQXVkaW9UcmFja3MucmVkdWNlKChhdWRpb1RyYWNrc0J5R3JvdXAsIHRyYWNrKSA9PiB7XG4gICAgbGV0IHRyYWNrR3JvdXAgPSBhdWRpb1RyYWNrc0J5R3JvdXAuZ3JvdXBzW3RyYWNrLmdyb3VwSWRdO1xuICAgIGlmICghdHJhY2tHcm91cCkge1xuICAgICAgdHJhY2tHcm91cCA9IGF1ZGlvVHJhY2tzQnlHcm91cC5ncm91cHNbdHJhY2suZ3JvdXBJZF0gPSB7XG4gICAgICAgIHRyYWNrczogW10sXG4gICAgICAgIGNoYW5uZWxzOiB7XG4gICAgICAgICAgMjogMFxuICAgICAgICB9LFxuICAgICAgICBoYXNEZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgaGFzQXV0b1NlbGVjdDogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIHRyYWNrR3JvdXAudHJhY2tzLnB1c2godHJhY2spO1xuICAgIGNvbnN0IGNoYW5uZWxzS2V5ID0gdHJhY2suY2hhbm5lbHMgfHwgJzInO1xuICAgIHRyYWNrR3JvdXAuY2hhbm5lbHNbY2hhbm5lbHNLZXldID0gKHRyYWNrR3JvdXAuY2hhbm5lbHNbY2hhbm5lbHNLZXldIHx8IDApICsgMTtcbiAgICB0cmFja0dyb3VwLmhhc0RlZmF1bHQgPSB0cmFja0dyb3VwLmhhc0RlZmF1bHQgfHwgdHJhY2suZGVmYXVsdDtcbiAgICB0cmFja0dyb3VwLmhhc0F1dG9TZWxlY3QgPSB0cmFja0dyb3VwLmhhc0F1dG9TZWxlY3QgfHwgdHJhY2suYXV0b3NlbGVjdDtcbiAgICBpZiAodHJhY2tHcm91cC5oYXNEZWZhdWx0KSB7XG4gICAgICBhdWRpb1RyYWNrc0J5R3JvdXAuaGFzRGVmYXVsdEF1ZGlvID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRyYWNrR3JvdXAuaGFzQXV0b1NlbGVjdCkge1xuICAgICAgYXVkaW9UcmFja3NCeUdyb3VwLmhhc0F1dG9TZWxlY3RBdWRpbyA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBhdWRpb1RyYWNrc0J5R3JvdXA7XG4gIH0sIHtcbiAgICBoYXNEZWZhdWx0QXVkaW86IGZhbHNlLFxuICAgIGhhc0F1dG9TZWxlY3RBdWRpbzogZmFsc2UsXG4gICAgZ3JvdXBzOiB7fVxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldENvZGVjVGllcnMobGV2ZWxzLCBhdWRpb1RyYWNrc0J5R3JvdXAsIG1pbkF1dG9MZXZlbCwgbWF4QXV0b0xldmVsKSB7XG4gIHJldHVybiBsZXZlbHMuc2xpY2UobWluQXV0b0xldmVsLCBtYXhBdXRvTGV2ZWwgKyAxKS5yZWR1Y2UoKHRpZXJzLCBsZXZlbCwgaW5kZXgpID0+IHtcbiAgICBpZiAoIWxldmVsLmNvZGVjU2V0KSB7XG4gICAgICByZXR1cm4gdGllcnM7XG4gICAgfVxuICAgIGNvbnN0IGF1ZGlvR3JvdXBzID0gbGV2ZWwuYXVkaW9Hcm91cHM7XG4gICAgbGV0IHRpZXIgPSB0aWVyc1tsZXZlbC5jb2RlY1NldF07XG4gICAgaWYgKCF0aWVyKSB7XG4gICAgICB0aWVyc1tsZXZlbC5jb2RlY1NldF0gPSB0aWVyID0ge1xuICAgICAgICBtaW5CaXRyYXRlOiBJbmZpbml0eSxcbiAgICAgICAgbWluSGVpZ2h0OiBJbmZpbml0eSxcbiAgICAgICAgbWluRnJhbWVyYXRlOiBJbmZpbml0eSxcbiAgICAgICAgbWluSW5kZXg6IGluZGV4LFxuICAgICAgICBtYXhTY29yZTogMCxcbiAgICAgICAgdmlkZW9SYW5nZXM6IHtcbiAgICAgICAgICBTRFI6IDBcbiAgICAgICAgfSxcbiAgICAgICAgY2hhbm5lbHM6IHtcbiAgICAgICAgICAnMic6IDBcbiAgICAgICAgfSxcbiAgICAgICAgaGFzRGVmYXVsdEF1ZGlvOiAhYXVkaW9Hcm91cHMsXG4gICAgICAgIGZyYWdtZW50RXJyb3I6IDBcbiAgICAgIH07XG4gICAgfVxuICAgIHRpZXIubWluQml0cmF0ZSA9IE1hdGgubWluKHRpZXIubWluQml0cmF0ZSwgbGV2ZWwuYml0cmF0ZSk7XG4gICAgY29uc3QgbGVzc2VyV2lkdGhPckhlaWdodCA9IE1hdGgubWluKGxldmVsLmhlaWdodCwgbGV2ZWwud2lkdGgpO1xuICAgIHRpZXIubWluSGVpZ2h0ID0gTWF0aC5taW4odGllci5taW5IZWlnaHQsIGxlc3NlcldpZHRoT3JIZWlnaHQpO1xuICAgIHRpZXIubWluRnJhbWVyYXRlID0gTWF0aC5taW4odGllci5taW5GcmFtZXJhdGUsIGxldmVsLmZyYW1lUmF0ZSk7XG4gICAgdGllci5taW5JbmRleCA9IE1hdGgubWluKHRpZXIubWluSW5kZXgsIGluZGV4KTtcbiAgICB0aWVyLm1heFNjb3JlID0gTWF0aC5tYXgodGllci5tYXhTY29yZSwgbGV2ZWwuc2NvcmUpO1xuICAgIHRpZXIuZnJhZ21lbnRFcnJvciArPSBsZXZlbC5mcmFnbWVudEVycm9yO1xuICAgIHRpZXIudmlkZW9SYW5nZXNbbGV2ZWwudmlkZW9SYW5nZV0gPSAodGllci52aWRlb1Jhbmdlc1tsZXZlbC52aWRlb1JhbmdlXSB8fCAwKSArIDE7XG4gICAgaWYgKGF1ZGlvR3JvdXBzKSB7XG4gICAgICBhdWRpb0dyb3Vwcy5mb3JFYWNoKGF1ZGlvR3JvdXBJZCA9PiB7XG4gICAgICAgIGlmICghYXVkaW9Hcm91cElkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF1ZGlvR3JvdXAgPSBhdWRpb1RyYWNrc0J5R3JvdXAuZ3JvdXBzW2F1ZGlvR3JvdXBJZF07XG4gICAgICAgIGlmICghYXVkaW9Hcm91cCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWZhdWx0IGF1ZGlvIGlzIGFueSBncm91cCB3aXRoIERFRkFVTFQ9WUVTLCBvciBpZiBtaXNzaW5nIHRoZW4gYW55IGdyb3VwIHdpdGggQVVUT1NFTEVDVD1ZRVMsIG9yIGFsbCB2YXJpYW50c1xuICAgICAgICB0aWVyLmhhc0RlZmF1bHRBdWRpbyA9IHRpZXIuaGFzRGVmYXVsdEF1ZGlvIHx8IGF1ZGlvVHJhY2tzQnlHcm91cC5oYXNEZWZhdWx0QXVkaW8gPyBhdWRpb0dyb3VwLmhhc0RlZmF1bHQgOiBhdWRpb0dyb3VwLmhhc0F1dG9TZWxlY3QgfHwgIWF1ZGlvVHJhY2tzQnlHcm91cC5oYXNEZWZhdWx0QXVkaW8gJiYgIWF1ZGlvVHJhY2tzQnlHcm91cC5oYXNBdXRvU2VsZWN0QXVkaW87XG4gICAgICAgIE9iamVjdC5rZXlzKGF1ZGlvR3JvdXAuY2hhbm5lbHMpLmZvckVhY2goY2hhbm5lbHMgPT4ge1xuICAgICAgICAgIHRpZXIuY2hhbm5lbHNbY2hhbm5lbHNdID0gKHRpZXIuY2hhbm5lbHNbY2hhbm5lbHNdIHx8IDApICsgYXVkaW9Hcm91cC5jaGFubmVsc1tjaGFubmVsc107XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aWVycztcbiAgfSwge30pO1xufVxuZnVuY3Rpb24gZ2V0QmFzaWNTZWxlY3Rpb25PcHRpb24ob3B0aW9uKSB7XG4gIGlmICghb3B0aW9uKSB7XG4gICAgcmV0dXJuIG9wdGlvbjtcbiAgfVxuICBjb25zdCB7XG4gICAgbGFuZyxcbiAgICBhc3NvY0xhbmcsXG4gICAgY2hhcmFjdGVyaXN0aWNzLFxuICAgIGNoYW5uZWxzLFxuICAgIGF1ZGlvQ29kZWNcbiAgfSA9IG9wdGlvbjtcbiAgcmV0dXJuIHtcbiAgICBsYW5nLFxuICAgIGFzc29jTGFuZyxcbiAgICBjaGFyYWN0ZXJpc3RpY3MsXG4gICAgY2hhbm5lbHMsXG4gICAgYXVkaW9Db2RlY1xuICB9O1xufVxuZnVuY3Rpb24gZmluZE1hdGNoaW5nT3B0aW9uKG9wdGlvbiwgdHJhY2tzLCBtYXRjaFByZWRpY2F0ZSkge1xuICBpZiAoJ2F0dHJzJyBpbiBvcHRpb24pIHtcbiAgICBjb25zdCBpbmRleCA9IHRyYWNrcy5pbmRleE9mKG9wdGlvbik7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRyYWNrID0gdHJhY2tzW2ldO1xuICAgIGlmIChtYXRjaGVzT3B0aW9uKG9wdGlvbiwgdHJhY2ssIG1hdGNoUHJlZGljYXRlKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIG1hdGNoZXNPcHRpb24ob3B0aW9uLCB0cmFjaywgbWF0Y2hQcmVkaWNhdGUpIHtcbiAgY29uc3Qge1xuICAgIGdyb3VwSWQsXG4gICAgbmFtZSxcbiAgICBsYW5nLFxuICAgIGFzc29jTGFuZyxcbiAgICBkZWZhdWx0OiBpc0RlZmF1bHRcbiAgfSA9IG9wdGlvbjtcbiAgY29uc3QgZm9yY2VkID0gb3B0aW9uLmZvcmNlZDtcbiAgcmV0dXJuIChncm91cElkID09PSB1bmRlZmluZWQgfHwgdHJhY2suZ3JvdXBJZCA9PT0gZ3JvdXBJZCkgJiYgKG5hbWUgPT09IHVuZGVmaW5lZCB8fCB0cmFjay5uYW1lID09PSBuYW1lKSAmJiAobGFuZyA9PT0gdW5kZWZpbmVkIHx8IGxhbmd1YWdlc01hdGNoKGxhbmcsIHRyYWNrLmxhbmcpKSAmJiAobGFuZyA9PT0gdW5kZWZpbmVkIHx8IHRyYWNrLmFzc29jTGFuZyA9PT0gYXNzb2NMYW5nKSAmJiAoaXNEZWZhdWx0ID09PSB1bmRlZmluZWQgfHwgdHJhY2suZGVmYXVsdCA9PT0gaXNEZWZhdWx0KSAmJiAoZm9yY2VkID09PSB1bmRlZmluZWQgfHwgdHJhY2suZm9yY2VkID09PSBmb3JjZWQpICYmICghKCdjaGFyYWN0ZXJpc3RpY3MnIGluIG9wdGlvbikgfHwgY2hhcmFjdGVyaXN0aWNzTWF0Y2gob3B0aW9uLmNoYXJhY3RlcmlzdGljcyB8fCAnJywgdHJhY2suY2hhcmFjdGVyaXN0aWNzKSkgJiYgKG1hdGNoUHJlZGljYXRlID09PSB1bmRlZmluZWQgfHwgbWF0Y2hQcmVkaWNhdGUob3B0aW9uLCB0cmFjaykpO1xufVxuZnVuY3Rpb24gbGFuZ3VhZ2VzTWF0Y2gobGFuZ3VhZ2VBLCBsYW5ndWFnZUIgPSAnLS0nKSB7XG4gIGlmIChsYW5ndWFnZUEubGVuZ3RoID09PSBsYW5ndWFnZUIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGxhbmd1YWdlQSA9PT0gbGFuZ3VhZ2VCO1xuICB9XG4gIHJldHVybiBsYW5ndWFnZUEuc3RhcnRzV2l0aChsYW5ndWFnZUIpIHx8IGxhbmd1YWdlQi5zdGFydHNXaXRoKGxhbmd1YWdlQSk7XG59XG5mdW5jdGlvbiBjaGFyYWN0ZXJpc3RpY3NNYXRjaChjaGFyYWN0ZXJpc3RpY3NBLCBjaGFyYWN0ZXJpc3RpY3NCID0gJycpIHtcbiAgY29uc3QgYXJyQSA9IGNoYXJhY3RlcmlzdGljc0Euc3BsaXQoJywnKTtcbiAgY29uc3QgYXJyQiA9IGNoYXJhY3RlcmlzdGljc0Iuc3BsaXQoJywnKTtcbiAgLy8gRXhwZWN0cyBlYWNoIGl0ZW0gdG8gYmUgdW5pcXVlOlxuICByZXR1cm4gYXJyQS5sZW5ndGggPT09IGFyckIubGVuZ3RoICYmICFhcnJBLnNvbWUoZWwgPT4gYXJyQi5pbmRleE9mKGVsKSA9PT0gLTEpO1xufVxuZnVuY3Rpb24gYXVkaW9NYXRjaFByZWRpY2F0ZShvcHRpb24sIHRyYWNrKSB7XG4gIGNvbnN0IHtcbiAgICBhdWRpb0NvZGVjLFxuICAgIGNoYW5uZWxzXG4gIH0gPSBvcHRpb247XG4gIHJldHVybiAoYXVkaW9Db2RlYyA9PT0gdW5kZWZpbmVkIHx8ICh0cmFjay5hdWRpb0NvZGVjIHx8ICcnKS5zdWJzdHJpbmcoMCwgNCkgPT09IGF1ZGlvQ29kZWMuc3Vic3RyaW5nKDAsIDQpKSAmJiAoY2hhbm5lbHMgPT09IHVuZGVmaW5lZCB8fCBjaGFubmVscyA9PT0gKHRyYWNrLmNoYW5uZWxzIHx8ICcyJykpO1xufVxuZnVuY3Rpb24gZmluZENsb3Nlc3RMZXZlbFdpdGhBdWRpb0dyb3VwKG9wdGlvbiwgbGV2ZWxzLCBhbGxBdWRpb1RyYWNrcywgc2VhcmNoSW5kZXgsIG1hdGNoUHJlZGljYXRlKSB7XG4gIGNvbnN0IGN1cnJlbnRMZXZlbCA9IGxldmVsc1tzZWFyY2hJbmRleF07XG4gIC8vIEFyZSB0aGVyZSB2YXJpYW50cyB3aXRoIHNhbWUgVVJJIGFzIGN1cnJlbnQgbGV2ZWw/XG4gIC8vIElmIHNvLCBmaW5kIGEgbWF0Y2ggdGhhdCBkb2VzIG5vdCByZXF1aXJlIGFueSBsZXZlbCBVUkkgY2hhbmdlXG4gIGNvbnN0IHZhcmlhbnRzID0gbGV2ZWxzLnJlZHVjZSgodmFyaWFudE1hcCwgbGV2ZWwsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgdXJpID0gbGV2ZWwudXJpO1xuICAgIGNvbnN0IHJlbmRpdGlvbnMgPSB2YXJpYW50TWFwW3VyaV0gfHwgKHZhcmlhbnRNYXBbdXJpXSA9IFtdKTtcbiAgICByZW5kaXRpb25zLnB1c2goaW5kZXgpO1xuICAgIHJldHVybiB2YXJpYW50TWFwO1xuICB9LCB7fSk7XG4gIGNvbnN0IHJlbmRpdGlvbnMgPSB2YXJpYW50c1tjdXJyZW50TGV2ZWwudXJpXTtcbiAgaWYgKHJlbmRpdGlvbnMubGVuZ3RoID4gMSkge1xuICAgIHNlYXJjaEluZGV4ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgcmVuZGl0aW9ucyk7XG4gIH1cbiAgLy8gRmluZCBiZXN0IG1hdGNoXG4gIGNvbnN0IGN1cnJlbnRWaWRlb1JhbmdlID0gY3VycmVudExldmVsLnZpZGVvUmFuZ2U7XG4gIGNvbnN0IGN1cnJlbnRGcmFtZVJhdGUgPSBjdXJyZW50TGV2ZWwuZnJhbWVSYXRlO1xuICBjb25zdCBjdXJyZW50VmlkZW9Db2RlYyA9IGN1cnJlbnRMZXZlbC5jb2RlY1NldC5zdWJzdHJpbmcoMCwgNCk7XG4gIGNvbnN0IG1hdGNoaW5nVmlkZW8gPSBzZWFyY2hEb3duQW5kVXBMaXN0KGxldmVscywgc2VhcmNoSW5kZXgsIGxldmVsID0+IHtcbiAgICBpZiAobGV2ZWwudmlkZW9SYW5nZSAhPT0gY3VycmVudFZpZGVvUmFuZ2UgfHwgbGV2ZWwuZnJhbWVSYXRlICE9PSBjdXJyZW50RnJhbWVSYXRlIHx8IGxldmVsLmNvZGVjU2V0LnN1YnN0cmluZygwLCA0KSAhPT0gY3VycmVudFZpZGVvQ29kZWMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYXVkaW9Hcm91cHMgPSBsZXZlbC5hdWRpb0dyb3VwcztcbiAgICBjb25zdCB0cmFja3MgPSBhbGxBdWRpb1RyYWNrcy5maWx0ZXIodHJhY2sgPT4gIWF1ZGlvR3JvdXBzIHx8IGF1ZGlvR3JvdXBzLmluZGV4T2YodHJhY2suZ3JvdXBJZCkgIT09IC0xKTtcbiAgICByZXR1cm4gZmluZE1hdGNoaW5nT3B0aW9uKG9wdGlvbiwgdHJhY2tzLCBtYXRjaFByZWRpY2F0ZSkgPiAtMTtcbiAgfSk7XG4gIGlmIChtYXRjaGluZ1ZpZGVvID4gLTEpIHtcbiAgICByZXR1cm4gbWF0Y2hpbmdWaWRlbztcbiAgfVxuICByZXR1cm4gc2VhcmNoRG93bkFuZFVwTGlzdChsZXZlbHMsIHNlYXJjaEluZGV4LCBsZXZlbCA9PiB7XG4gICAgY29uc3QgYXVkaW9Hcm91cHMgPSBsZXZlbC5hdWRpb0dyb3VwcztcbiAgICBjb25zdCB0cmFja3MgPSBhbGxBdWRpb1RyYWNrcy5maWx0ZXIodHJhY2sgPT4gIWF1ZGlvR3JvdXBzIHx8IGF1ZGlvR3JvdXBzLmluZGV4T2YodHJhY2suZ3JvdXBJZCkgIT09IC0xKTtcbiAgICByZXR1cm4gZmluZE1hdGNoaW5nT3B0aW9uKG9wdGlvbiwgdHJhY2tzLCBtYXRjaFByZWRpY2F0ZSkgPiAtMTtcbiAgfSk7XG59XG5mdW5jdGlvbiBzZWFyY2hEb3duQW5kVXBMaXN0KGFyciwgc2VhcmNoSW5kZXgsIHByZWRpY2F0ZSkge1xuICBmb3IgKGxldCBpID0gc2VhcmNoSW5kZXg7IGkgPiAtMTsgaS0tKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJbaV0pKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IHNlYXJjaEluZGV4ICsgMTsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyW2ldKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIHVzZUFsdGVybmF0ZUF1ZGlvKGF1ZGlvVHJhY2tVcmwsIGhscykge1xuICB2YXIgX2hscyRsb2FkTGV2ZWxPYmo7XG4gIHJldHVybiAhIWF1ZGlvVHJhY2tVcmwgJiYgYXVkaW9UcmFja1VybCAhPT0gKChfaGxzJGxvYWRMZXZlbE9iaiA9IGhscy5sb2FkTGV2ZWxPYmopID09IG51bGwgPyB2b2lkIDAgOiBfaGxzJGxvYWRMZXZlbE9iai51cmkpO1xufVxuXG5jbGFzcyBBYnJDb250cm9sbGVyIGV4dGVuZHMgTG9nZ2VyIHtcbiAgY29uc3RydWN0b3IoX2hscykge1xuICAgIHN1cGVyKCdhYnInLCBfaGxzLmxvZ2dlcik7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5sYXN0TGV2ZWxMb2FkU2VjID0gMDtcbiAgICB0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwgPSAtMTtcbiAgICB0aGlzLmZpcnN0U2VsZWN0aW9uID0gLTE7XG4gICAgdGhpcy5fbmV4dEF1dG9MZXZlbCA9IC0xO1xuICAgIHRoaXMubmV4dEF1dG9MZXZlbEtleSA9ICcnO1xuICAgIHRoaXMuYXVkaW9UcmFja3NCeUdyb3VwID0gbnVsbDtcbiAgICB0aGlzLmNvZGVjVGllcnMgPSBudWxsO1xuICAgIHRoaXMudGltZXIgPSAtMTtcbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLnBhcnRDdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLmJpdHJhdGVUZXN0RGVsYXkgPSAwO1xuICAgIHRoaXMucmVidWZmZXJOb3RpY2UgPSAtMTtcbiAgICB0aGlzLnN1cHBvcnRlZENhY2hlID0ge307XG4gICAgdGhpcy5id0VzdGltYXRvciA9IHZvaWQgMDtcbiAgICAvKlxuICAgICAgICBUaGlzIG1ldGhvZCBtb25pdG9ycyB0aGUgZG93bmxvYWQgcmF0ZSBvZiB0aGUgY3VycmVudCBmcmFnbWVudCwgYW5kIHdpbGwgZG93bnN3aXRjaCBpZiB0aGF0IGZyYWdtZW50IHdpbGwgbm90IGxvYWRcbiAgICAgICAgcXVpY2tseSBlbm91Z2ggdG8gcHJldmVudCB1bmRlcmJ1ZmZlcmluZ1xuICAgICAgKi9cbiAgICB0aGlzLl9hYmFuZG9uUnVsZXNDaGVjayA9IGxldmVsTG9hZGVkID0+IHtcbiAgICAgIHZhciBfcmVmO1xuICAgICAgY29uc3Qge1xuICAgICAgICBmcmFnQ3VycmVudDogZnJhZyxcbiAgICAgICAgcGFydEN1cnJlbnQ6IHBhcnQsXG4gICAgICAgIGhsc1xuICAgICAgfSA9IHRoaXM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGF1dG9MZXZlbEVuYWJsZWQsXG4gICAgICAgIG1lZGlhXG4gICAgICB9ID0gaGxzO1xuICAgICAgaWYgKCFmcmFnIHx8ICFtZWRpYSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHN0YXRzID0gcGFydCA/IHBhcnQuc3RhdHMgOiBmcmFnLnN0YXRzO1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBwYXJ0ID8gcGFydC5kdXJhdGlvbiA6IGZyYWcuZHVyYXRpb247XG4gICAgICBjb25zdCB0aW1lTG9hZGluZyA9IG5vdyAtIHN0YXRzLmxvYWRpbmcuc3RhcnQ7XG4gICAgICBjb25zdCBtaW5BdXRvTGV2ZWwgPSBobHMubWluQXV0b0xldmVsO1xuICAgICAgY29uc3QgbG9hZGluZ0ZyYWdGb3JMZXZlbCA9IGZyYWcubGV2ZWw7XG4gICAgICBjb25zdCBjdXJyZW50QXV0b0xldmVsID0gdGhpcy5fbmV4dEF1dG9MZXZlbDtcbiAgICAgIC8vIElmIGZyYWcgbG9hZGluZyBpcyBhYm9ydGVkLCBjb21wbGV0ZSwgb3IgZnJvbSBsb3dlc3QgbGV2ZWwsIHN0b3AgdGltZXIgYW5kIHJldHVyblxuICAgICAgaWYgKHN0YXRzLmFib3J0ZWQgfHwgc3RhdHMubG9hZGVkICYmIHN0YXRzLmxvYWRlZCA9PT0gc3RhdHMudG90YWwgfHwgbG9hZGluZ0ZyYWdGb3JMZXZlbCA8PSBtaW5BdXRvTGV2ZWwpIHtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICAgIC8vIHJlc2V0IGZvcmNlZCBhdXRvIGxldmVsIHZhbHVlIHNvIHRoYXQgbmV4dCBsZXZlbCB3aWxsIGJlIHNlbGVjdGVkXG4gICAgICAgIHRoaXMuX25leHRBdXRvTGV2ZWwgPSAtMTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGlzIGNoZWNrIG9ubHkgcnVucyBpZiB3ZSdyZSBpbiBBQlIgbW9kZVxuICAgICAgaWYgKCFhdXRvTGV2ZWxFbmFibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gTXVzdCBiZSBsb2FkaW5nL2xvYWRlZCBhIG5ldyBsZXZlbCBvciBiZSBpbiBhIHBsYXlpbmcgc3RhdGVcbiAgICAgIGNvbnN0IGZyYWdCbG9ja2luZ1N3aXRjaCA9IGN1cnJlbnRBdXRvTGV2ZWwgPiAtMSAmJiBjdXJyZW50QXV0b0xldmVsICE9PSBsb2FkaW5nRnJhZ0ZvckxldmVsO1xuICAgICAgY29uc3QgbGV2ZWxDaGFuZ2UgPSAhIWxldmVsTG9hZGVkIHx8IGZyYWdCbG9ja2luZ1N3aXRjaDtcbiAgICAgIGlmICghbGV2ZWxDaGFuZ2UgJiYgKG1lZGlhLnBhdXNlZCB8fCAhbWVkaWEucGxheWJhY2tSYXRlIHx8ICFtZWRpYS5yZWFkeVN0YXRlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBidWZmZXJJbmZvID0gaGxzLm1haW5Gb3J3YXJkQnVmZmVySW5mbztcbiAgICAgIGlmICghbGV2ZWxDaGFuZ2UgJiYgYnVmZmVySW5mbyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB0dGZiRXN0aW1hdGUgPSB0aGlzLmJ3RXN0aW1hdG9yLmdldEVzdGltYXRlVFRGQigpO1xuICAgICAgY29uc3QgcGxheWJhY2tSYXRlID0gTWF0aC5hYnMobWVkaWEucGxheWJhY2tSYXRlKTtcbiAgICAgIC8vIFRvIG1haW50YWluIHN0YWJsZSBhZGFwdGl2ZSBwbGF5YmFjaywgb25seSBiZWdpbiBtb25pdG9yaW5nIGZyYWcgbG9hZGluZyBhZnRlciBoYWxmIG9yIG1vcmUgb2YgaXRzIHBsYXliYWNrIGR1cmF0aW9uIGhhcyBwYXNzZWRcbiAgICAgIGlmICh0aW1lTG9hZGluZyA8PSBNYXRoLm1heCh0dGZiRXN0aW1hdGUsIDEwMDAgKiAoZHVyYXRpb24gLyAocGxheWJhY2tSYXRlICogMikpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSBpcyBhbiBlc3RpbWF0ZSBvZiB0aGUgYW1vdW50IHRpbWUgKGluIHNlY29uZHMpIGl0IHdpbGwgdGFrZSB0byBleGhhdXN0IHRoZSBidWZmZXJcbiAgICAgIGNvbnN0IGJ1ZmZlclN0YXJ2YXRpb25EZWxheSA9IGJ1ZmZlckluZm8gPyBidWZmZXJJbmZvLmxlbiAvIHBsYXliYWNrUmF0ZSA6IDA7XG4gICAgICBjb25zdCB0dGZiID0gc3RhdHMubG9hZGluZy5maXJzdCA/IHN0YXRzLmxvYWRpbmcuZmlyc3QgLSBzdGF0cy5sb2FkaW5nLnN0YXJ0IDogLTE7XG4gICAgICBjb25zdCBsb2FkZWRGaXJzdEJ5dGUgPSBzdGF0cy5sb2FkZWQgJiYgdHRmYiA+IC0xO1xuICAgICAgY29uc3QgYndFc3RpbWF0ZSA9IHRoaXMuZ2V0QndFc3RpbWF0ZSgpO1xuICAgICAgY29uc3QgbGV2ZWxzID0gaGxzLmxldmVscztcbiAgICAgIGNvbnN0IGxldmVsID0gbGV2ZWxzW2xvYWRpbmdGcmFnRm9yTGV2ZWxdO1xuICAgICAgY29uc3QgZXhwZWN0ZWRMZW4gPSBNYXRoLm1heChzdGF0cy5sb2FkZWQsIE1hdGgucm91bmQoZHVyYXRpb24gKiAoZnJhZy5iaXRyYXRlIHx8IGxldmVsLmF2ZXJhZ2VCaXRyYXRlKSAvIDgpKTtcbiAgICAgIGxldCB0aW1lU3RyZWFtaW5nID0gbG9hZGVkRmlyc3RCeXRlID8gdGltZUxvYWRpbmcgLSB0dGZiIDogdGltZUxvYWRpbmc7XG4gICAgICBpZiAodGltZVN0cmVhbWluZyA8IDEgJiYgbG9hZGVkRmlyc3RCeXRlKSB7XG4gICAgICAgIHRpbWVTdHJlYW1pbmcgPSBNYXRoLm1pbih0aW1lTG9hZGluZywgc3RhdHMubG9hZGVkICogOCAvIGJ3RXN0aW1hdGUpO1xuICAgICAgfVxuICAgICAgY29uc3QgbG9hZFJhdGUgPSBsb2FkZWRGaXJzdEJ5dGUgPyBzdGF0cy5sb2FkZWQgKiAxMDAwIC8gdGltZVN0cmVhbWluZyA6IDA7XG4gICAgICAvLyBmcmFnTG9hZERlbGF5IGlzIGFuIGVzdGltYXRlIG9mIHRoZSB0aW1lIChpbiBzZWNvbmRzKSBpdCB3aWxsIHRha2UgdG8gYnVmZmVyIHRoZSByZW1haW5kZXIgb2YgdGhlIGZyYWdtZW50XG4gICAgICBjb25zdCB0dGZiU2Vjb25kcyA9IHR0ZmJFc3RpbWF0ZSAvIDEwMDA7XG4gICAgICBjb25zdCBmcmFnTG9hZGVkRGVsYXkgPSBsb2FkUmF0ZSA/IChleHBlY3RlZExlbiAtIHN0YXRzLmxvYWRlZCkgLyBsb2FkUmF0ZSA6IGV4cGVjdGVkTGVuICogOCAvIGJ3RXN0aW1hdGUgKyB0dGZiU2Vjb25kcztcbiAgICAgIC8vIE9ubHkgZG93bnN3aXRjaCBpZiB0aGUgdGltZSB0byBmaW5pc2ggbG9hZGluZyB0aGUgY3VycmVudCBmcmFnbWVudCBpcyBncmVhdGVyIHRoYW4gdGhlIGFtb3VudCBvZiBidWZmZXIgbGVmdFxuICAgICAgaWYgKGZyYWdMb2FkZWREZWxheSA8PSBidWZmZXJTdGFydmF0aW9uRGVsYXkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgYndlID0gbG9hZFJhdGUgPyBsb2FkUmF0ZSAqIDggOiBid0VzdGltYXRlO1xuICAgICAgY29uc3QgbGl2ZSA9ICgoX3JlZiA9IChsZXZlbExvYWRlZCA9PSBudWxsID8gdm9pZCAwIDogbGV2ZWxMb2FkZWQuZGV0YWlscykgfHwgdGhpcy5obHMubGF0ZXN0TGV2ZWxEZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX3JlZi5saXZlKSA9PT0gdHJ1ZTtcbiAgICAgIGNvbnN0IGFickJhbmRXaWR0aFVwRmFjdG9yID0gdGhpcy5obHMuY29uZmlnLmFickJhbmRXaWR0aFVwRmFjdG9yO1xuICAgICAgbGV0IGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgIGxldCBuZXh0TG9hZExldmVsO1xuICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGxvd2VyIGxldmVsIGFuZCB0cnkgdG8gZmluZCB0aGUgbGFyZ2VzdCBvbmUgdGhhdCBhdm9pZHMgcmVidWZmZXJpbmdcbiAgICAgIGZvciAobmV4dExvYWRMZXZlbCA9IGxvYWRpbmdGcmFnRm9yTGV2ZWwgLSAxOyBuZXh0TG9hZExldmVsID4gbWluQXV0b0xldmVsOyBuZXh0TG9hZExldmVsLS0pIHtcbiAgICAgICAgLy8gY29tcHV0ZSB0aW1lIHRvIGxvYWQgbmV4dCBmcmFnbWVudCBhdCBsb3dlciBsZXZlbFxuICAgICAgICAvLyA4ID0gYml0cyBwZXIgYnl0ZSAoYnBzL0JwcylcbiAgICAgICAgY29uc3QgbGV2ZWxOZXh0Qml0cmF0ZSA9IGxldmVsc1tuZXh0TG9hZExldmVsXS5tYXhCaXRyYXRlO1xuICAgICAgICBjb25zdCByZXF1aXJlc0xldmVsTG9hZCA9ICFsZXZlbHNbbmV4dExvYWRMZXZlbF0uZGV0YWlscyB8fCBsaXZlO1xuICAgICAgICBmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkgPSB0aGlzLmdldFRpbWVUb0xvYWRGcmFnKHR0ZmJTZWNvbmRzLCBid2UsIGR1cmF0aW9uICogbGV2ZWxOZXh0Qml0cmF0ZSwgcmVxdWlyZXNMZXZlbExvYWQpO1xuICAgICAgICBpZiAoZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5IDwgTWF0aC5taW4oYnVmZmVyU3RhcnZhdGlvbkRlbGF5LCBkdXJhdGlvbiArIHR0ZmJTZWNvbmRzKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBPbmx5IGVtZXJnZW5jeSBzd2l0Y2ggZG93biBpZiBpdCB0YWtlcyBsZXNzIHRpbWUgdG8gbG9hZCBhIG5ldyBmcmFnbWVudCBhdCBsb3dlc3QgbGV2ZWwgaW5zdGVhZCBvZiBjb250aW51aW5nXG4gICAgICAvLyB0byBsb2FkIHRoZSBjdXJyZW50IG9uZVxuICAgICAgaWYgKGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA+PSBmcmFnTG9hZGVkRGVsYXkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBlc3RpbWF0ZWQgbG9hZCB0aW1lIG9mIG5ldyBzZWdtZW50IGlzIGNvbXBsZXRlbHkgdW5yZWFzb25hYmxlLCBpZ25vcmUgYW5kIGRvIG5vdCBlbWVyZ2VuY3kgc3dpdGNoIGRvd25cbiAgICAgIGlmIChmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkgPiBkdXJhdGlvbiAqIDEwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChsb2FkZWRGaXJzdEJ5dGUpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgaGFzIGJlZW4gbG9hZGluZyBwcm9ncmVzcywgc2FtcGxlIGJhbmR3aWR0aCB1c2luZyBsb2FkaW5nIHRpbWUgb2Zmc2V0IGJ5IG1pbmltdW0gVFRGQiB0aW1lXG4gICAgICAgIHRoaXMuYndFc3RpbWF0b3Iuc2FtcGxlKHRpbWVMb2FkaW5nIC0gTWF0aC5taW4odHRmYkVzdGltYXRlLCB0dGZiKSwgc3RhdHMubG9hZGVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGhhcyBiZWVuIG5vIGxvYWRpbmcgcHJvZ3Jlc3MsIHNhbXBsZSBUVEZCXG4gICAgICAgIHRoaXMuYndFc3RpbWF0b3Iuc2FtcGxlVFRGQih0aW1lTG9hZGluZyk7XG4gICAgICB9XG4gICAgICBjb25zdCBuZXh0TG9hZExldmVsQml0cmF0ZSA9IGxldmVsc1tuZXh0TG9hZExldmVsXS5tYXhCaXRyYXRlO1xuICAgICAgaWYgKHRoaXMuZ2V0QndFc3RpbWF0ZSgpICogYWJyQmFuZFdpZHRoVXBGYWN0b3IgPiBuZXh0TG9hZExldmVsQml0cmF0ZSkge1xuICAgICAgICB0aGlzLnJlc2V0RXN0aW1hdG9yKG5leHRMb2FkTGV2ZWxCaXRyYXRlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJlc3RTd2l0Y2hMZXZlbCA9IHRoaXMuZmluZEJlc3RMZXZlbChuZXh0TG9hZExldmVsQml0cmF0ZSwgbWluQXV0b0xldmVsLCBuZXh0TG9hZExldmVsLCAwLCBidWZmZXJTdGFydmF0aW9uRGVsYXksIDEsIDEpO1xuICAgICAgaWYgKGJlc3RTd2l0Y2hMZXZlbCA+IC0xKSB7XG4gICAgICAgIG5leHRMb2FkTGV2ZWwgPSBiZXN0U3dpdGNoTGV2ZWw7XG4gICAgICB9XG4gICAgICB0aGlzLndhcm4oYEZyYWdtZW50ICR7ZnJhZy5zbn0ke3BhcnQgPyAnIHBhcnQgJyArIHBhcnQuaW5kZXggOiAnJ30gb2YgbGV2ZWwgJHtsb2FkaW5nRnJhZ0ZvckxldmVsfSBpcyBsb2FkaW5nIHRvbyBzbG93bHk7XG4gICAgICBGcmFnbWVudCBkdXJhdGlvbjogJHtmcmFnLmR1cmF0aW9uLnRvRml4ZWQoMyl9XG4gICAgICBUaW1lIHRvIHVuZGVyYnVmZmVyOiAke2J1ZmZlclN0YXJ2YXRpb25EZWxheS50b0ZpeGVkKDMpfSBzXG4gICAgICBFc3RpbWF0ZWQgbG9hZCB0aW1lIGZvciBjdXJyZW50IGZyYWdtZW50OiAke2ZyYWdMb2FkZWREZWxheS50b0ZpeGVkKDMpfSBzXG4gICAgICBFc3RpbWF0ZWQgbG9hZCB0aW1lIGZvciBkb3duIHN3aXRjaCBmcmFnbWVudDogJHtmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkudG9GaXhlZCgzKX0gc1xuICAgICAgVFRGQiBlc3RpbWF0ZTogJHt0dGZiIHwgMH0gbXNcbiAgICAgIEN1cnJlbnQgQlcgZXN0aW1hdGU6ICR7aXNGaW5pdGVOdW1iZXIoYndFc3RpbWF0ZSkgPyBid0VzdGltYXRlIHwgMCA6ICdVbmtub3duJ30gYnBzXG4gICAgICBOZXcgQlcgZXN0aW1hdGU6ICR7dGhpcy5nZXRCd0VzdGltYXRlKCkgfCAwfSBicHNcbiAgICAgIFN3aXRjaGluZyB0byBsZXZlbCAke25leHRMb2FkTGV2ZWx9IEAgJHtuZXh0TG9hZExldmVsQml0cmF0ZSB8IDB9IGJwc2ApO1xuICAgICAgaGxzLm5leHRMb2FkTGV2ZWwgPSBobHMubmV4dEF1dG9MZXZlbCA9IG5leHRMb2FkTGV2ZWw7XG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgIGNvbnN0IGFib3J0QW5kU3dpdGNoID0gKCkgPT4ge1xuICAgICAgICAvLyBBcmUgbmV4dExvYWRMZXZlbCBkZXRhaWxzIGF2YWlsYWJsZSBvciBpcyBzdHJlYW0tY29udHJvbGxlciBzdGlsbCBpbiBcIldBSVRJTkdfTEVWRUxcIiBzdGF0ZT9cbiAgICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICAgIGlmICh0aGlzLmZyYWdDdXJyZW50ID09PSBmcmFnICYmIHRoaXMuaGxzLmxvYWRMZXZlbCA9PT0gbmV4dExvYWRMZXZlbCAmJiBuZXh0TG9hZExldmVsID4gMCkge1xuICAgICAgICAgIGNvbnN0IGJ1ZmZlclN0YXJ2YXRpb25EZWxheSA9IHRoaXMuZ2V0U3RhcnZhdGlvbkRlbGF5KCk7XG4gICAgICAgICAgdGhpcy53YXJuKGBBYm9ydGluZyBpbmZsaWdodCByZXF1ZXN0ICR7bmV4dExvYWRMZXZlbCA+IDAgPyAnYW5kIHN3aXRjaGluZyBkb3duJyA6ICcnfVxuICAgICAgRnJhZ21lbnQgZHVyYXRpb246ICR7ZnJhZy5kdXJhdGlvbi50b0ZpeGVkKDMpfSBzXG4gICAgICBUaW1lIHRvIHVuZGVyYnVmZmVyOiAke2J1ZmZlclN0YXJ2YXRpb25EZWxheS50b0ZpeGVkKDMpfSBzYCk7XG4gICAgICAgICAgZnJhZy5hYm9ydFJlcXVlc3RzKCk7XG4gICAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IHRoaXMucGFydEN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIGlmIChuZXh0TG9hZExldmVsID4gbWluQXV0b0xldmVsKSB7XG4gICAgICAgICAgICBsZXQgbG93ZXN0U3dpdGNoTGV2ZWwgPSB0aGlzLmZpbmRCZXN0TGV2ZWwodGhpcy5obHMubGV2ZWxzW21pbkF1dG9MZXZlbF0uYml0cmF0ZSwgbWluQXV0b0xldmVsLCBuZXh0TG9hZExldmVsLCAwLCBidWZmZXJTdGFydmF0aW9uRGVsYXksIDEsIDEpO1xuICAgICAgICAgICAgaWYgKGxvd2VzdFN3aXRjaExldmVsID09PSAtMSkge1xuICAgICAgICAgICAgICBsb3dlc3RTd2l0Y2hMZXZlbCA9IG1pbkF1dG9MZXZlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGxzLm5leHRMb2FkTGV2ZWwgPSB0aGlzLmhscy5uZXh0QXV0b0xldmVsID0gbG93ZXN0U3dpdGNoTGV2ZWw7XG4gICAgICAgICAgICB0aGlzLnJlc2V0RXN0aW1hdG9yKHRoaXMuaGxzLmxldmVsc1tsb3dlc3RTd2l0Y2hMZXZlbF0uYml0cmF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKGZyYWdCbG9ja2luZ1N3aXRjaCB8fCBmcmFnTG9hZGVkRGVsYXkgPiBmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkgKiAyKSB7XG4gICAgICAgIGFib3J0QW5kU3dpdGNoKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRpbWVyID0gc2VsZi5zZXRJbnRlcnZhbChhYm9ydEFuZFN3aXRjaCwgZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5ICogMTAwMCk7XG4gICAgICB9XG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuRlJBR19MT0FEX0VNRVJHRU5DWV9BQk9SVEVELCB7XG4gICAgICAgIGZyYWcsXG4gICAgICAgIHBhcnQsXG4gICAgICAgIHN0YXRzXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMuaGxzID0gX2hscztcbiAgICB0aGlzLmJ3RXN0aW1hdG9yID0gdGhpcy5pbml0RXN0aW1hdG9yKCk7XG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIHJlc2V0RXN0aW1hdG9yKGFickV3bWFEZWZhdWx0RXN0aW1hdGUpIHtcbiAgICBpZiAoYWJyRXdtYURlZmF1bHRFc3RpbWF0ZSkge1xuICAgICAgdGhpcy5sb2coYHNldHRpbmcgaW5pdGlhbCBid2UgdG8gJHthYnJFd21hRGVmYXVsdEVzdGltYXRlfWApO1xuICAgICAgdGhpcy5obHMuY29uZmlnLmFickV3bWFEZWZhdWx0RXN0aW1hdGUgPSBhYnJFd21hRGVmYXVsdEVzdGltYXRlO1xuICAgIH1cbiAgICB0aGlzLmZpcnN0U2VsZWN0aW9uID0gLTE7XG4gICAgdGhpcy5id0VzdGltYXRvciA9IHRoaXMuaW5pdEVzdGltYXRvcigpO1xuICB9XG4gIGluaXRFc3RpbWF0b3IoKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuICAgIHJldHVybiBuZXcgRXdtYUJhbmRXaWR0aEVzdGltYXRvcihjb25maWcuYWJyRXdtYVNsb3dWb0QsIGNvbmZpZy5hYnJFd21hRmFzdFZvRCwgY29uZmlnLmFickV3bWFEZWZhdWx0RXN0aW1hdGUpO1xuICB9XG4gIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX0xPQURJTkcsIHRoaXMub25GcmFnTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX0xPQURFRCwgdGhpcy5vbkZyYWdMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9TV0lUQ0hJTkcsIHRoaXMub25MZXZlbFN3aXRjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTFNfVVBEQVRFRCwgdGhpcy5vbkxldmVsc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFYX0FVVE9fTEVWRUxfVVBEQVRFRCwgdGhpcy5vbk1heEF1dG9MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH1cbiAgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWhscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0xPQURJTkcsIHRoaXMub25GcmFnTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19MT0FERUQsIHRoaXMub25GcmFnTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9TV0lUQ0hJTkcsIHRoaXMub25MZXZlbFN3aXRjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMU19VUERBVEVELCB0aGlzLm9uTGV2ZWxzVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFYX0FVVE9fTEVWRUxfVVBEQVRFRCwgdGhpcy5vbk1heEF1dG9MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuaGxzID0gdGhpcy5fYWJhbmRvblJ1bGVzQ2hlY2sgPSB0aGlzLnN1cHBvcnRlZENhY2hlID0gbnVsbDtcbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gdGhpcy5wYXJ0Q3VycmVudCA9IG51bGw7XG4gIH1cbiAgb25NYW5pZmVzdExvYWRpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwgPSAtMTtcbiAgICB0aGlzLmZpcnN0U2VsZWN0aW9uID0gLTE7XG4gICAgdGhpcy5sYXN0TGV2ZWxMb2FkU2VjID0gMDtcbiAgICB0aGlzLnN1cHBvcnRlZENhY2hlID0ge307XG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IHRoaXMucGFydEN1cnJlbnQgPSBudWxsO1xuICAgIHRoaXMub25MZXZlbHNVcGRhdGVkKCk7XG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gIH1cbiAgb25MZXZlbHNVcGRhdGVkKCkge1xuICAgIGlmICh0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwgPiAtMSAmJiB0aGlzLmZyYWdDdXJyZW50KSB7XG4gICAgICB0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwgPSB0aGlzLmZyYWdDdXJyZW50LmxldmVsO1xuICAgIH1cbiAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gLTE7XG4gICAgdGhpcy5vbk1heEF1dG9MZXZlbFVwZGF0ZWQoKTtcbiAgICB0aGlzLmNvZGVjVGllcnMgPSBudWxsO1xuICAgIHRoaXMuYXVkaW9UcmFja3NCeUdyb3VwID0gbnVsbDtcbiAgfVxuICBvbk1heEF1dG9MZXZlbFVwZGF0ZWQoKSB7XG4gICAgdGhpcy5maXJzdFNlbGVjdGlvbiA9IC0xO1xuICAgIHRoaXMubmV4dEF1dG9MZXZlbEtleSA9ICcnO1xuICB9XG4gIG9uRnJhZ0xvYWRpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCBmcmFnID0gZGF0YS5mcmFnO1xuICAgIGlmICh0aGlzLmlnbm9yZUZyYWdtZW50KGZyYWcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghZnJhZy5iaXRyYXRlVGVzdCkge1xuICAgICAgdmFyIF9kYXRhJHBhcnQ7XG4gICAgICB0aGlzLmZyYWdDdXJyZW50ID0gZnJhZztcbiAgICAgIHRoaXMucGFydEN1cnJlbnQgPSAoX2RhdGEkcGFydCA9IGRhdGEucGFydCkgIT0gbnVsbCA/IF9kYXRhJHBhcnQgOiBudWxsO1xuICAgIH1cbiAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICB0aGlzLnRpbWVyID0gc2VsZi5zZXRJbnRlcnZhbCh0aGlzLl9hYmFuZG9uUnVsZXNDaGVjaywgMTAwKTtcbiAgfVxuICBvbkxldmVsU3dpdGNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gIH1cbiAgb25FcnJvcihldmVudCwgZGF0YSkge1xuICAgIGlmIChkYXRhLmZhdGFsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaCAoZGF0YS5kZXRhaWxzKSB7XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfQUREX0NPREVDX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORF9FUlJPUjpcbiAgICAgICAgLy8gUmVzZXQgbGFzdCBsb2FkZWQgbGV2ZWwgc28gdGhhdCBhIG5ldyBzZWxlY3Rpb24gY2FuIGJlIG1hZGUgYWZ0ZXIgY2FsbGluZyByZWNvdmVyTWVkaWFFcnJvclxuICAgICAgICB0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwgPSAtMTtcbiAgICAgICAgdGhpcy5maXJzdFNlbGVjdGlvbiA9IC0xO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgZnJhZyA9IGRhdGEuZnJhZztcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBmcmFnQ3VycmVudCxcbiAgICAgICAgICAgIHBhcnRDdXJyZW50OiBwYXJ0XG4gICAgICAgICAgfSA9IHRoaXM7XG4gICAgICAgICAgaWYgKGZyYWcgJiYgZnJhZ0N1cnJlbnQgJiYgZnJhZy5zbiA9PT0gZnJhZ0N1cnJlbnQuc24gJiYgZnJhZy5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgY29uc3Qgc3RhdHMgPSBwYXJ0ID8gcGFydC5zdGF0cyA6IGZyYWcuc3RhdHM7XG4gICAgICAgICAgICBjb25zdCB0aW1lTG9hZGluZyA9IG5vdyAtIHN0YXRzLmxvYWRpbmcuc3RhcnQ7XG4gICAgICAgICAgICBjb25zdCB0dGZiID0gc3RhdHMubG9hZGluZy5maXJzdCA/IHN0YXRzLmxvYWRpbmcuZmlyc3QgLSBzdGF0cy5sb2FkaW5nLnN0YXJ0IDogLTE7XG4gICAgICAgICAgICBjb25zdCBsb2FkZWRGaXJzdEJ5dGUgPSBzdGF0cy5sb2FkZWQgJiYgdHRmYiA+IC0xO1xuICAgICAgICAgICAgaWYgKGxvYWRlZEZpcnN0Qnl0ZSkge1xuICAgICAgICAgICAgICBjb25zdCB0dGZiRXN0aW1hdGUgPSB0aGlzLmJ3RXN0aW1hdG9yLmdldEVzdGltYXRlVFRGQigpO1xuICAgICAgICAgICAgICB0aGlzLmJ3RXN0aW1hdG9yLnNhbXBsZSh0aW1lTG9hZGluZyAtIE1hdGgubWluKHR0ZmJFc3RpbWF0ZSwgdHRmYiksIHN0YXRzLmxvYWRlZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmJ3RXN0aW1hdG9yLnNhbXBsZVRURkIodGltZUxvYWRpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXRUaW1lVG9Mb2FkRnJhZyh0aW1lVG9GaXJzdEJ5dGVTZWMsIGJhbmR3aWR0aCwgZnJhZ1NpemVCaXRzLCBpc1N3aXRjaCkge1xuICAgIGNvbnN0IGZyYWdMb2FkU2VjID0gdGltZVRvRmlyc3RCeXRlU2VjICsgZnJhZ1NpemVCaXRzIC8gYmFuZHdpZHRoO1xuICAgIGNvbnN0IHBsYXlsaXN0TG9hZFNlYyA9IGlzU3dpdGNoID8gdGltZVRvRmlyc3RCeXRlU2VjICsgdGhpcy5sYXN0TGV2ZWxMb2FkU2VjIDogMDtcbiAgICByZXR1cm4gZnJhZ0xvYWRTZWMgKyBwbGF5bGlzdExvYWRTZWM7XG4gIH1cbiAgb25MZXZlbExvYWRlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcbiAgICBjb25zdCB7XG4gICAgICBsb2FkaW5nXG4gICAgfSA9IGRhdGEuc3RhdHM7XG4gICAgY29uc3QgdGltZUxvYWRpbmdNcyA9IGxvYWRpbmcuZW5kIC0gbG9hZGluZy5maXJzdDtcbiAgICBpZiAoaXNGaW5pdGVOdW1iZXIodGltZUxvYWRpbmdNcykpIHtcbiAgICAgIHRoaXMubGFzdExldmVsTG9hZFNlYyA9IHRpbWVMb2FkaW5nTXMgLyAxMDAwO1xuICAgIH1cbiAgICBpZiAoZGF0YS5kZXRhaWxzLmxpdmUpIHtcbiAgICAgIHRoaXMuYndFc3RpbWF0b3IudXBkYXRlKGNvbmZpZy5hYnJFd21hU2xvd0xpdmUsIGNvbmZpZy5hYnJFd21hRmFzdExpdmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJ3RXN0aW1hdG9yLnVwZGF0ZShjb25maWcuYWJyRXdtYVNsb3dWb0QsIGNvbmZpZy5hYnJFd21hRmFzdFZvRCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRpbWVyID4gLTEpIHtcbiAgICAgIHRoaXMuX2FiYW5kb25SdWxlc0NoZWNrKGRhdGEubGV2ZWxJbmZvKTtcbiAgICB9XG4gIH1cbiAgb25GcmFnTG9hZGVkKGV2ZW50LCB7XG4gICAgZnJhZyxcbiAgICBwYXJ0XG4gIH0pIHtcbiAgICBjb25zdCBzdGF0cyA9IHBhcnQgPyBwYXJ0LnN0YXRzIDogZnJhZy5zdGF0cztcbiAgICBpZiAoZnJhZy50eXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOKSB7XG4gICAgICB0aGlzLmJ3RXN0aW1hdG9yLnNhbXBsZVRURkIoc3RhdHMubG9hZGluZy5maXJzdCAtIHN0YXRzLmxvYWRpbmcuc3RhcnQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pZ25vcmVGcmFnbWVudChmcmFnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBzdG9wIG1vbml0b3JpbmcgYncgb25jZSBmcmFnIGxvYWRlZFxuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgIC8vIHJlc2V0IGZvcmNlZCBhdXRvIGxldmVsIHZhbHVlIHNvIHRoYXQgbmV4dCBsZXZlbCB3aWxsIGJlIHNlbGVjdGVkXG4gICAgaWYgKGZyYWcubGV2ZWwgPT09IHRoaXMuX25leHRBdXRvTGV2ZWwpIHtcbiAgICAgIHRoaXMuX25leHRBdXRvTGV2ZWwgPSAtMTtcbiAgICB9XG4gICAgdGhpcy5maXJzdFNlbGVjdGlvbiA9IC0xO1xuXG4gICAgLy8gY29tcHV0ZSBsZXZlbCBhdmVyYWdlIGJpdHJhdGVcbiAgICBpZiAodGhpcy5obHMuY29uZmlnLmFick1heFdpdGhSZWFsQml0cmF0ZSkge1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBwYXJ0ID8gcGFydC5kdXJhdGlvbiA6IGZyYWcuZHVyYXRpb247XG4gICAgICBjb25zdCBsZXZlbCA9IHRoaXMuaGxzLmxldmVsc1tmcmFnLmxldmVsXTtcbiAgICAgIGNvbnN0IGxvYWRlZEJ5dGVzID0gKGxldmVsLmxvYWRlZCA/IGxldmVsLmxvYWRlZC5ieXRlcyA6IDApICsgc3RhdHMubG9hZGVkO1xuICAgICAgY29uc3QgbG9hZGVkRHVyYXRpb24gPSAobGV2ZWwubG9hZGVkID8gbGV2ZWwubG9hZGVkLmR1cmF0aW9uIDogMCkgKyBkdXJhdGlvbjtcbiAgICAgIGxldmVsLmxvYWRlZCA9IHtcbiAgICAgICAgYnl0ZXM6IGxvYWRlZEJ5dGVzLFxuICAgICAgICBkdXJhdGlvbjogbG9hZGVkRHVyYXRpb25cbiAgICAgIH07XG4gICAgICBsZXZlbC5yZWFsQml0cmF0ZSA9IE1hdGgucm91bmQoOCAqIGxvYWRlZEJ5dGVzIC8gbG9hZGVkRHVyYXRpb24pO1xuICAgIH1cbiAgICBpZiAoZnJhZy5iaXRyYXRlVGVzdCkge1xuICAgICAgY29uc3QgZnJhZ0J1ZmZlcmVkRGF0YSA9IHtcbiAgICAgICAgc3RhdHMsXG4gICAgICAgIGZyYWcsXG4gICAgICAgIHBhcnQsXG4gICAgICAgIGlkOiBmcmFnLnR5cGVcbiAgICAgIH07XG4gICAgICB0aGlzLm9uRnJhZ0J1ZmZlcmVkKEV2ZW50cy5GUkFHX0JVRkZFUkVELCBmcmFnQnVmZmVyZWREYXRhKTtcbiAgICAgIGZyYWcuYml0cmF0ZVRlc3QgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc3RvcmUgbGV2ZWwgaWQgYWZ0ZXIgc3VjY2Vzc2Z1bCBmcmFnbWVudCBsb2FkIGZvciBwbGF5YmFja1xuICAgICAgdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsID0gZnJhZy5sZXZlbDtcbiAgICB9XG4gIH1cbiAgb25GcmFnQnVmZmVyZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnLFxuICAgICAgcGFydFxuICAgIH0gPSBkYXRhO1xuICAgIGNvbnN0IHN0YXRzID0gcGFydCAhPSBudWxsICYmIHBhcnQuc3RhdHMubG9hZGVkID8gcGFydC5zdGF0cyA6IGZyYWcuc3RhdHM7XG4gICAgaWYgKHN0YXRzLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaWdub3JlRnJhZ21lbnQoZnJhZykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gVXNlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gcGFyc2luZyBhbmQgcmVxdWVzdCBpbnN0ZWFkIG9mIGJ1ZmZlcmluZyBhbmQgcmVxdWVzdCB0byBjb21wdXRlIGZyYWdMb2FkaW5nUHJvY2Vzc2luZztcbiAgICAvLyByYXRpb25hbGUgaXMgdGhhdCBidWZmZXIgYXBwZW5kaW5nIG9ubHkgaGFwcGVucyBvbmNlIG1lZGlhIGlzIGF0dGFjaGVkLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBjb25maWcuc3RhcnRGcmFnUHJlZmV0Y2hcbiAgICAvLyBpcyB1c2VkLiBJZiB3ZSB1c2VkIGJ1ZmZlcmluZyBpbiB0aGF0IGNhc2UsIG91ciBCVyBlc3RpbWF0ZSBzYW1wbGUgd2lsbCBiZSB2ZXJ5IGxhcmdlLlxuICAgIGNvbnN0IHByb2Nlc3NpbmdNcyA9IHN0YXRzLnBhcnNpbmcuZW5kIC0gc3RhdHMubG9hZGluZy5zdGFydCAtIE1hdGgubWluKHN0YXRzLmxvYWRpbmcuZmlyc3QgLSBzdGF0cy5sb2FkaW5nLnN0YXJ0LCB0aGlzLmJ3RXN0aW1hdG9yLmdldEVzdGltYXRlVFRGQigpKTtcbiAgICB0aGlzLmJ3RXN0aW1hdG9yLnNhbXBsZShwcm9jZXNzaW5nTXMsIHN0YXRzLmxvYWRlZCk7XG4gICAgc3RhdHMuYndFc3RpbWF0ZSA9IHRoaXMuZ2V0QndFc3RpbWF0ZSgpO1xuICAgIGlmIChmcmFnLmJpdHJhdGVUZXN0KSB7XG4gICAgICB0aGlzLmJpdHJhdGVUZXN0RGVsYXkgPSBwcm9jZXNzaW5nTXMgLyAxMDAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJpdHJhdGVUZXN0RGVsYXkgPSAwO1xuICAgIH1cbiAgfVxuICBpZ25vcmVGcmFnbWVudChmcmFnKSB7XG4gICAgLy8gT25seSBjb3VudCBub24tYWx0LWF1ZGlvIGZyYWdzIHdoaWNoIHdlcmUgYWN0dWFsbHkgYnVmZmVyZWQgaW4gb3VyIEJXIGNhbGN1bGF0aW9uc1xuICAgIHJldHVybiBmcmFnLnR5cGUgIT09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4gfHwgZnJhZy5zbiA9PT0gJ2luaXRTZWdtZW50JztcbiAgfVxuICBjbGVhclRpbWVyKCkge1xuICAgIGlmICh0aGlzLnRpbWVyID4gLTEpIHtcbiAgICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgIHRoaXMudGltZXIgPSAtMTtcbiAgICB9XG4gIH1cbiAgZ2V0IGZpcnN0QXV0b0xldmVsKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1heEF1dG9MZXZlbCxcbiAgICAgIG1pbkF1dG9MZXZlbFxuICAgIH0gPSB0aGlzLmhscztcbiAgICBjb25zdCBid0VzdGltYXRlID0gdGhpcy5nZXRCd0VzdGltYXRlKCk7XG4gICAgY29uc3QgbWF4U3RhcnREZWxheSA9IHRoaXMuaGxzLmNvbmZpZy5tYXhTdGFydmF0aW9uRGVsYXk7XG4gICAgY29uc3QgYWJyQXV0b0xldmVsID0gdGhpcy5maW5kQmVzdExldmVsKGJ3RXN0aW1hdGUsIG1pbkF1dG9MZXZlbCwgbWF4QXV0b0xldmVsLCAwLCBtYXhTdGFydERlbGF5LCAxLCAxKTtcbiAgICBpZiAoYWJyQXV0b0xldmVsID4gLTEpIHtcbiAgICAgIHJldHVybiBhYnJBdXRvTGV2ZWw7XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0TGV2ZWwgPSB0aGlzLmhscy5maXJzdExldmVsO1xuICAgIGNvbnN0IGNsYW1wZWQgPSBNYXRoLm1pbihNYXRoLm1heChmaXJzdExldmVsLCBtaW5BdXRvTGV2ZWwpLCBtYXhBdXRvTGV2ZWwpO1xuICAgIHRoaXMud2FybihgQ291bGQgbm90IGZpbmQgYmVzdCBzdGFydGluZyBhdXRvIGxldmVsLiBEZWZhdWx0aW5nIHRvIGZpcnN0IGluIHBsYXlsaXN0ICR7Zmlyc3RMZXZlbH0gY2xhbXBlZCB0byAke2NsYW1wZWR9YCk7XG4gICAgcmV0dXJuIGNsYW1wZWQ7XG4gIH1cbiAgZ2V0IGZvcmNlZEF1dG9MZXZlbCgpIHtcbiAgICBpZiAodGhpcy5uZXh0QXV0b0xldmVsS2V5KSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9uZXh0QXV0b0xldmVsO1xuICB9XG5cbiAgLy8gcmV0dXJuIG5leHQgYXV0byBsZXZlbFxuICBnZXQgbmV4dEF1dG9MZXZlbCgpIHtcbiAgICBjb25zdCBmb3JjZWRBdXRvTGV2ZWwgPSB0aGlzLmZvcmNlZEF1dG9MZXZlbDtcbiAgICBjb25zdCBid0VzdGltYXRvciA9IHRoaXMuYndFc3RpbWF0b3I7XG4gICAgY29uc3QgdXNlRXN0aW1hdGUgPSBid0VzdGltYXRvci5jYW5Fc3RpbWF0ZSgpO1xuICAgIGNvbnN0IGxvYWRlZEZpcnN0RnJhZyA9IHRoaXMubGFzdExvYWRlZEZyYWdMZXZlbCA+IC0xO1xuICAgIC8vIGluIGNhc2UgbmV4dCBhdXRvIGxldmVsIGhhcyBiZWVuIGZvcmNlZCwgYW5kIGJ3IG5vdCBhdmFpbGFibGUgb3Igbm90IHJlbGlhYmxlLCByZXR1cm4gZm9yY2VkIHZhbHVlXG4gICAgaWYgKGZvcmNlZEF1dG9MZXZlbCAhPT0gLTEgJiYgKCF1c2VFc3RpbWF0ZSB8fCAhbG9hZGVkRmlyc3RGcmFnIHx8IHRoaXMubmV4dEF1dG9MZXZlbEtleSA9PT0gdGhpcy5nZXRBdXRvTGV2ZWxLZXkoKSkpIHtcbiAgICAgIHJldHVybiBmb3JjZWRBdXRvTGV2ZWw7XG4gICAgfVxuXG4gICAgLy8gY29tcHV0ZSBuZXh0IGxldmVsIHVzaW5nIEFCUiBsb2dpY1xuICAgIGNvbnN0IG5leHRBQlJBdXRvTGV2ZWwgPSB1c2VFc3RpbWF0ZSAmJiBsb2FkZWRGaXJzdEZyYWcgPyB0aGlzLmdldE5leHRBQlJBdXRvTGV2ZWwoKSA6IHRoaXMuZmlyc3RBdXRvTGV2ZWw7XG5cbiAgICAvLyB1c2UgZm9yY2VkIGF1dG8gbGV2ZWwgd2hpbGUgaXQgaGFzbid0IGVycm9yZWQgbW9yZSB0aGFuIEFCUiBzZWxlY3Rpb25cbiAgICBpZiAoZm9yY2VkQXV0b0xldmVsICE9PSAtMSkge1xuICAgICAgY29uc3QgbGV2ZWxzID0gdGhpcy5obHMubGV2ZWxzO1xuICAgICAgaWYgKGxldmVscy5sZW5ndGggPiBNYXRoLm1heChmb3JjZWRBdXRvTGV2ZWwsIG5leHRBQlJBdXRvTGV2ZWwpICYmIGxldmVsc1tmb3JjZWRBdXRvTGV2ZWxdLmxvYWRFcnJvciA8PSBsZXZlbHNbbmV4dEFCUkF1dG9MZXZlbF0ubG9hZEVycm9yKSB7XG4gICAgICAgIHJldHVybiBmb3JjZWRBdXRvTGV2ZWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2F2ZSByZXN1bHQgdW50aWwgc3RhdGUgaGFzIGNoYW5nZWRcbiAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gbmV4dEFCUkF1dG9MZXZlbDtcbiAgICB0aGlzLm5leHRBdXRvTGV2ZWxLZXkgPSB0aGlzLmdldEF1dG9MZXZlbEtleSgpO1xuICAgIHJldHVybiBuZXh0QUJSQXV0b0xldmVsO1xuICB9XG4gIGdldEF1dG9MZXZlbEtleSgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5nZXRCd0VzdGltYXRlKCl9XyR7dGhpcy5nZXRTdGFydmF0aW9uRGVsYXkoKS50b0ZpeGVkKDIpfWA7XG4gIH1cbiAgZ2V0TmV4dEFCUkF1dG9MZXZlbCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnQ3VycmVudCxcbiAgICAgIHBhcnRDdXJyZW50LFxuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGhscy5sZXZlbHMubGVuZ3RoIDw9IDEpIHtcbiAgICAgIHJldHVybiBobHMubG9hZExldmVsO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBtYXhBdXRvTGV2ZWwsXG4gICAgICBjb25maWcsXG4gICAgICBtaW5BdXRvTGV2ZWxcbiAgICB9ID0gaGxzO1xuICAgIGNvbnN0IGN1cnJlbnRGcmFnRHVyYXRpb24gPSBwYXJ0Q3VycmVudCA/IHBhcnRDdXJyZW50LmR1cmF0aW9uIDogZnJhZ0N1cnJlbnQgPyBmcmFnQ3VycmVudC5kdXJhdGlvbiA6IDA7XG4gICAgY29uc3QgYXZnYncgPSB0aGlzLmdldEJ3RXN0aW1hdGUoKTtcbiAgICAvLyBidWZmZXJTdGFydmF0aW9uRGVsYXkgaXMgdGhlIHdhbGwtY2xvY2sgdGltZSBsZWZ0IHVudGlsIHRoZSBwbGF5YmFjayBidWZmZXIgaXMgZXhoYXVzdGVkLlxuICAgIGNvbnN0IGJ1ZmZlclN0YXJ2YXRpb25EZWxheSA9IHRoaXMuZ2V0U3RhcnZhdGlvbkRlbGF5KCk7XG4gICAgbGV0IGJ3RmFjdG9yID0gY29uZmlnLmFickJhbmRXaWR0aEZhY3RvcjtcbiAgICBsZXQgYndVcEZhY3RvciA9IGNvbmZpZy5hYnJCYW5kV2lkdGhVcEZhY3RvcjtcblxuICAgIC8vIEZpcnN0LCBsb29rIHRvIHNlZSBpZiB3ZSBjYW4gZmluZCBhIGxldmVsIG1hdGNoaW5nIHdpdGggb3VyIGF2ZyBiYW5kd2lkdGggQU5EIHRoYXQgY291bGQgYWxzbyBndWFyYW50ZWUgbm8gcmVidWZmZXJpbmcgYXQgYWxsXG4gICAgaWYgKGJ1ZmZlclN0YXJ2YXRpb25EZWxheSkge1xuICAgICAgY29uc3QgX2Jlc3RMZXZlbCA9IHRoaXMuZmluZEJlc3RMZXZlbChhdmdidywgbWluQXV0b0xldmVsLCBtYXhBdXRvTGV2ZWwsIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSwgMCwgYndGYWN0b3IsIGJ3VXBGYWN0b3IpO1xuICAgICAgaWYgKF9iZXN0TGV2ZWwgPj0gMCkge1xuICAgICAgICB0aGlzLnJlYnVmZmVyTm90aWNlID0gLTE7XG4gICAgICAgIHJldHVybiBfYmVzdExldmVsO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBub3QgcG9zc2libGUgdG8gZ2V0IHJpZCBvZiByZWJ1ZmZlcmluZy4uLiB0cnkgdG8gZmluZCBsZXZlbCB0aGF0IHdpbGwgZ3VhcmFudGVlIGxlc3MgdGhhbiBtYXhTdGFydmF0aW9uRGVsYXkgb2YgcmVidWZmZXJpbmdcbiAgICBsZXQgbWF4U3RhcnZhdGlvbkRlbGF5ID0gY3VycmVudEZyYWdEdXJhdGlvbiA/IE1hdGgubWluKGN1cnJlbnRGcmFnRHVyYXRpb24sIGNvbmZpZy5tYXhTdGFydmF0aW9uRGVsYXkpIDogY29uZmlnLm1heFN0YXJ2YXRpb25EZWxheTtcbiAgICBpZiAoIWJ1ZmZlclN0YXJ2YXRpb25EZWxheSkge1xuICAgICAgLy8gaW4gY2FzZSBidWZmZXIgaXMgZW1wdHksIGxldCdzIGNoZWNrIGlmIHByZXZpb3VzIGZyYWdtZW50IHdhcyBsb2FkZWQgdG8gcGVyZm9ybSBhIGJpdHJhdGUgdGVzdFxuICAgICAgY29uc3QgYml0cmF0ZVRlc3REZWxheSA9IHRoaXMuYml0cmF0ZVRlc3REZWxheTtcbiAgICAgIGlmIChiaXRyYXRlVGVzdERlbGF5KSB7XG4gICAgICAgIC8vIGlmIGl0IGlzIHRoZSBjYXNlLCB0aGVuIHdlIG5lZWQgdG8gYWRqdXN0IG91ciBtYXggc3RhcnZhdGlvbiBkZWxheSB1c2luZyBtYXhMb2FkaW5nRGVsYXkgY29uZmlnIHZhbHVlXG4gICAgICAgIC8vIG1heCB2aWRlbyBsb2FkaW5nIGRlbGF5IHVzZWQgaW4gIGF1dG9tYXRpYyBzdGFydCBsZXZlbCBzZWxlY3Rpb24gOlxuICAgICAgICAvLyBpbiB0aGF0IG1vZGUgQUJSIGNvbnRyb2xsZXIgd2lsbCBlbnN1cmUgdGhhdCB2aWRlbyBsb2FkaW5nIHRpbWUgKGllIHRoZSB0aW1lIHRvIGZldGNoIHRoZSBmaXJzdCBmcmFnbWVudCBhdCBsb3dlc3QgcXVhbGl0eSBsZXZlbCArXG4gICAgICAgIC8vIHRoZSB0aW1lIHRvIGZldGNoIHRoZSBmcmFnbWVudCBhdCB0aGUgYXBwcm9wcmlhdGUgcXVhbGl0eSBsZXZlbCBpcyBsZXNzIHRoYW4gYGBgbWF4TG9hZGluZ0RlbGF5YGBgIClcbiAgICAgICAgLy8gY2FwIG1heExvYWRpbmdEZWxheSBhbmQgZW5zdXJlIGl0IGlzIG5vdCBiaWdnZXIgJ3RoYW4gYml0cmF0ZSB0ZXN0JyBmcmFnIGR1cmF0aW9uXG4gICAgICAgIGNvbnN0IG1heExvYWRpbmdEZWxheSA9IGN1cnJlbnRGcmFnRHVyYXRpb24gPyBNYXRoLm1pbihjdXJyZW50RnJhZ0R1cmF0aW9uLCBjb25maWcubWF4TG9hZGluZ0RlbGF5KSA6IGNvbmZpZy5tYXhMb2FkaW5nRGVsYXk7XG4gICAgICAgIG1heFN0YXJ2YXRpb25EZWxheSA9IG1heExvYWRpbmdEZWxheSAtIGJpdHJhdGVUZXN0RGVsYXk7XG4gICAgICAgIHRoaXMuaW5mbyhgYml0cmF0ZSB0ZXN0IHRvb2sgJHtNYXRoLnJvdW5kKDEwMDAgKiBiaXRyYXRlVGVzdERlbGF5KX1tcywgc2V0IGZpcnN0IGZyYWdtZW50IG1heCBmZXRjaER1cmF0aW9uIHRvICR7TWF0aC5yb3VuZCgxMDAwICogbWF4U3RhcnZhdGlvbkRlbGF5KX0gbXNgKTtcbiAgICAgICAgLy8gZG9uJ3QgdXNlIGNvbnNlcnZhdGl2ZSBmYWN0b3Igb24gYml0cmF0ZSB0ZXN0XG4gICAgICAgIGJ3RmFjdG9yID0gYndVcEZhY3RvciA9IDE7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGJlc3RMZXZlbCA9IHRoaXMuZmluZEJlc3RMZXZlbChhdmdidywgbWluQXV0b0xldmVsLCBtYXhBdXRvTGV2ZWwsIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSwgbWF4U3RhcnZhdGlvbkRlbGF5LCBid0ZhY3RvciwgYndVcEZhY3Rvcik7XG4gICAgaWYgKHRoaXMucmVidWZmZXJOb3RpY2UgIT09IGJlc3RMZXZlbCkge1xuICAgICAgdGhpcy5yZWJ1ZmZlck5vdGljZSA9IGJlc3RMZXZlbDtcbiAgICAgIHRoaXMuaW5mbyhgJHtidWZmZXJTdGFydmF0aW9uRGVsYXkgPyAncmVidWZmZXJpbmcgZXhwZWN0ZWQnIDogJ2J1ZmZlciBpcyBlbXB0eSd9LCBvcHRpbWFsIHF1YWxpdHkgbGV2ZWwgJHtiZXN0TGV2ZWx9YCk7XG4gICAgfVxuICAgIGlmIChiZXN0TGV2ZWwgPiAtMSkge1xuICAgICAgcmV0dXJuIGJlc3RMZXZlbDtcbiAgICB9XG4gICAgLy8gSWYgbm8gbWF0Y2hpbmcgbGV2ZWwgZm91bmQsIHNlZSBpZiBtaW4gYXV0byBsZXZlbCB3b3VsZCBiZSBhIGJldHRlciBvcHRpb25cbiAgICBjb25zdCBtaW5MZXZlbCA9IGhscy5sZXZlbHNbbWluQXV0b0xldmVsXTtcbiAgICBjb25zdCBhdXRvTGV2ZWwgPSBobHMubG9hZExldmVsT2JqO1xuICAgIGlmIChhdXRvTGV2ZWwgJiYgKG1pbkxldmVsID09IG51bGwgPyB2b2lkIDAgOiBtaW5MZXZlbC5iaXRyYXRlKSA8IGF1dG9MZXZlbC5iaXRyYXRlKSB7XG4gICAgICByZXR1cm4gbWluQXV0b0xldmVsO1xuICAgIH1cbiAgICAvLyBvciBpZiBiaXRyYXRlIGlzIG5vdCBsb3dlciwgY29udGludWUgdG8gdXNlIGxvYWRMZXZlbFxuICAgIHJldHVybiBobHMubG9hZExldmVsO1xuICB9XG4gIGdldFN0YXJ2YXRpb25EZWxheSgpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBjb25zdCBtZWRpYSA9IGhscy5tZWRpYTtcbiAgICBpZiAoIW1lZGlhKSB7XG4gICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuICAgIC8vIHBsYXliYWNrUmF0ZSBpcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhlIHBsYXliYWNrIHJhdGU7IGlmIG1lZGlhLnBsYXliYWNrUmF0ZSBpcyAwLCB3ZSB1c2UgMSB0byBsb2FkIGFzXG4gICAgLy8gaWYgd2UncmUgcGxheWluZyBiYWNrIGF0IHRoZSBub3JtYWwgcmF0ZS5cbiAgICBjb25zdCBwbGF5YmFja1JhdGUgPSBtZWRpYSAmJiBtZWRpYS5wbGF5YmFja1JhdGUgIT09IDAgPyBNYXRoLmFicyhtZWRpYS5wbGF5YmFja1JhdGUpIDogMS4wO1xuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBobHMubWFpbkZvcndhcmRCdWZmZXJJbmZvO1xuICAgIHJldHVybiAoYnVmZmVySW5mbyA/IGJ1ZmZlckluZm8ubGVuIDogMCkgLyBwbGF5YmFja1JhdGU7XG4gIH1cbiAgZ2V0QndFc3RpbWF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5id0VzdGltYXRvci5jYW5Fc3RpbWF0ZSgpID8gdGhpcy5id0VzdGltYXRvci5nZXRFc3RpbWF0ZSgpIDogdGhpcy5obHMuY29uZmlnLmFickV3bWFEZWZhdWx0RXN0aW1hdGU7XG4gIH1cbiAgZmluZEJlc3RMZXZlbChjdXJyZW50QncsIG1pbkF1dG9MZXZlbCwgbWF4QXV0b0xldmVsLCBidWZmZXJTdGFydmF0aW9uRGVsYXksIG1heFN0YXJ2YXRpb25EZWxheSwgYndGYWN0b3IsIGJ3VXBGYWN0b3IpIHtcbiAgICB2YXIgX3RoaXMkaGxzJGxhdGVzdExldmVsO1xuICAgIGNvbnN0IG1heEZldGNoRHVyYXRpb24gPSBidWZmZXJTdGFydmF0aW9uRGVsYXkgKyBtYXhTdGFydmF0aW9uRGVsYXk7XG4gICAgY29uc3QgbGFzdExvYWRlZEZyYWdMZXZlbCA9IHRoaXMubGFzdExvYWRlZEZyYWdMZXZlbDtcbiAgICBjb25zdCBzZWxlY3Rpb25CYXNlTGV2ZWwgPSBsYXN0TG9hZGVkRnJhZ0xldmVsID09PSAtMSA/IHRoaXMuaGxzLmZpcnN0TGV2ZWwgOiBsYXN0TG9hZGVkRnJhZ0xldmVsO1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWdDdXJyZW50LFxuICAgICAgcGFydEN1cnJlbnRcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBsZXZlbHMsXG4gICAgICBhbGxBdWRpb1RyYWNrcyxcbiAgICAgIGxvYWRMZXZlbCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSB0aGlzLmhscztcbiAgICBpZiAobGV2ZWxzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNvbnN0IGxldmVsID0gbGV2ZWxzW3NlbGVjdGlvbkJhc2VMZXZlbF07XG4gICAgY29uc3QgbGl2ZSA9ICEhKChfdGhpcyRobHMkbGF0ZXN0TGV2ZWwgPSB0aGlzLmhscy5sYXRlc3RMZXZlbERldGFpbHMpICE9IG51bGwgJiYgX3RoaXMkaGxzJGxhdGVzdExldmVsLmxpdmUpO1xuICAgIGNvbnN0IGZpcnN0U2VsZWN0aW9uID0gbG9hZExldmVsID09PSAtMSB8fCBsYXN0TG9hZGVkRnJhZ0xldmVsID09PSAtMTtcbiAgICBsZXQgY3VycmVudENvZGVjU2V0O1xuICAgIGxldCBjdXJyZW50VmlkZW9SYW5nZSA9ICdTRFInO1xuICAgIGxldCBjdXJyZW50RnJhbWVSYXRlID0gKGxldmVsID09IG51bGwgPyB2b2lkIDAgOiBsZXZlbC5mcmFtZVJhdGUpIHx8IDA7XG4gICAgY29uc3Qge1xuICAgICAgYXVkaW9QcmVmZXJlbmNlLFxuICAgICAgdmlkZW9QcmVmZXJlbmNlXG4gICAgfSA9IGNvbmZpZztcbiAgICBjb25zdCBhdWRpb1RyYWNrc0J5R3JvdXAgPSB0aGlzLmF1ZGlvVHJhY2tzQnlHcm91cCB8fCAodGhpcy5hdWRpb1RyYWNrc0J5R3JvdXAgPSBnZXRBdWRpb1RyYWNrc0J5R3JvdXAoYWxsQXVkaW9UcmFja3MpKTtcbiAgICBsZXQgbWluU3RhcnRJbmRleCA9IC0xO1xuICAgIGlmIChmaXJzdFNlbGVjdGlvbikge1xuICAgICAgaWYgKHRoaXMuZmlyc3RTZWxlY3Rpb24gIT09IC0xKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpcnN0U2VsZWN0aW9uO1xuICAgICAgfVxuICAgICAgY29uc3QgY29kZWNUaWVycyA9IHRoaXMuY29kZWNUaWVycyB8fCAodGhpcy5jb2RlY1RpZXJzID0gZ2V0Q29kZWNUaWVycyhsZXZlbHMsIGF1ZGlvVHJhY2tzQnlHcm91cCwgbWluQXV0b0xldmVsLCBtYXhBdXRvTGV2ZWwpKTtcbiAgICAgIGNvbnN0IHN0YXJ0VGllciA9IGdldFN0YXJ0Q29kZWNUaWVyKGNvZGVjVGllcnMsIGN1cnJlbnRWaWRlb1JhbmdlLCBjdXJyZW50QncsIGF1ZGlvUHJlZmVyZW5jZSwgdmlkZW9QcmVmZXJlbmNlKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29kZWNTZXQsXG4gICAgICAgIHZpZGVvUmFuZ2VzLFxuICAgICAgICBtaW5GcmFtZXJhdGUsXG4gICAgICAgIG1pbkJpdHJhdGUsXG4gICAgICAgIG1pbkluZGV4LFxuICAgICAgICBwcmVmZXJIRFJcbiAgICAgIH0gPSBzdGFydFRpZXI7XG4gICAgICBtaW5TdGFydEluZGV4ID0gbWluSW5kZXg7XG4gICAgICBjdXJyZW50Q29kZWNTZXQgPSBjb2RlY1NldDtcbiAgICAgIGN1cnJlbnRWaWRlb1JhbmdlID0gcHJlZmVySERSID8gdmlkZW9SYW5nZXNbdmlkZW9SYW5nZXMubGVuZ3RoIC0gMV0gOiB2aWRlb1Jhbmdlc1swXTtcbiAgICAgIGN1cnJlbnRGcmFtZVJhdGUgPSBtaW5GcmFtZXJhdGU7XG4gICAgICBjdXJyZW50QncgPSBNYXRoLm1heChjdXJyZW50QncsIG1pbkJpdHJhdGUpO1xuICAgICAgdGhpcy5sb2coYHBpY2tlZCBzdGFydCB0aWVyICR7c3RyaW5naWZ5KHN0YXJ0VGllcil9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRDb2RlY1NldCA9IGxldmVsID09IG51bGwgPyB2b2lkIDAgOiBsZXZlbC5jb2RlY1NldDtcbiAgICAgIGN1cnJlbnRWaWRlb1JhbmdlID0gbGV2ZWwgPT0gbnVsbCA/IHZvaWQgMCA6IGxldmVsLnZpZGVvUmFuZ2U7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRGcmFnRHVyYXRpb24gPSBwYXJ0Q3VycmVudCA/IHBhcnRDdXJyZW50LmR1cmF0aW9uIDogZnJhZ0N1cnJlbnQgPyBmcmFnQ3VycmVudC5kdXJhdGlvbiA6IDA7XG4gICAgY29uc3QgdHRmYkVzdGltYXRlU2VjID0gdGhpcy5id0VzdGltYXRvci5nZXRFc3RpbWF0ZVRURkIoKSAvIDEwMDA7XG4gICAgY29uc3QgbGV2ZWxzU2tpcHBlZCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSBtYXhBdXRvTGV2ZWw7IGkgPj0gbWluQXV0b0xldmVsOyBpLS0pIHtcbiAgICAgIHZhciBfbGV2ZWxJbmZvJHN1cHBvcnRlZFIsIF9sZXZlbEluZm8kc3VwcG9ydGVkUjI7XG4gICAgICBjb25zdCBsZXZlbEluZm8gPSBsZXZlbHNbaV07XG4gICAgICBjb25zdCB1cFN3aXRjaCA9IGkgPiBzZWxlY3Rpb25CYXNlTGV2ZWw7XG4gICAgICBpZiAoIWxldmVsSW5mbykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjb25maWcudXNlTWVkaWFDYXBhYmlsaXRpZXMgJiYgIWxldmVsSW5mby5zdXBwb3J0ZWRSZXN1bHQgJiYgIWxldmVsSW5mby5zdXBwb3J0ZWRQcm9taXNlKSB7XG4gICAgICAgIGNvbnN0IG1lZGlhQ2FwYWJpbGl0aWVzID0gbmF2aWdhdG9yLm1lZGlhQ2FwYWJpbGl0aWVzO1xuICAgICAgICBpZiAodHlwZW9mIChtZWRpYUNhcGFiaWxpdGllcyA9PSBudWxsID8gdm9pZCAwIDogbWVkaWFDYXBhYmlsaXRpZXMuZGVjb2RpbmdJbmZvKSA9PT0gJ2Z1bmN0aW9uJyAmJiByZXF1aXJlc01lZGlhQ2FwYWJpbGl0aWVzRGVjb2RpbmdJbmZvKGxldmVsSW5mbywgYXVkaW9UcmFja3NCeUdyb3VwLCBjdXJyZW50VmlkZW9SYW5nZSwgY3VycmVudEZyYW1lUmF0ZSwgY3VycmVudEJ3LCBhdWRpb1ByZWZlcmVuY2UpKSB7XG4gICAgICAgICAgbGV2ZWxJbmZvLnN1cHBvcnRlZFByb21pc2UgPSBnZXRNZWRpYURlY29kaW5nSW5mb1Byb21pc2UobGV2ZWxJbmZvLCBhdWRpb1RyYWNrc0J5R3JvdXAsIG1lZGlhQ2FwYWJpbGl0aWVzLCB0aGlzLnN1cHBvcnRlZENhY2hlKTtcbiAgICAgICAgICBsZXZlbEluZm8uc3VwcG9ydGVkUHJvbWlzZS50aGVuKGRlY29kaW5nSW5mbyA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGxzKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldmVsSW5mby5zdXBwb3J0ZWRSZXN1bHQgPSBkZWNvZGluZ0luZm87XG4gICAgICAgICAgICBjb25zdCBsZXZlbHMgPSB0aGlzLmhscy5sZXZlbHM7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGxldmVscy5pbmRleE9mKGxldmVsSW5mbyk7XG4gICAgICAgICAgICBpZiAoZGVjb2RpbmdJbmZvLmVycm9yKSB7XG4gICAgICAgICAgICAgIHRoaXMud2FybihgTWVkaWFDYXBhYmlsaXRpZXMgZGVjb2RpbmdJbmZvIGVycm9yOiBcIiR7ZGVjb2RpbmdJbmZvLmVycm9yfVwiIGZvciBsZXZlbCAke2luZGV4fSAke3N0cmluZ2lmeShkZWNvZGluZ0luZm8pfWApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghZGVjb2RpbmdJbmZvLnN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICB0aGlzLndhcm4oYFVuc3VwcG9ydGVkIE1lZGlhQ2FwYWJpbGl0aWVzIGRlY29kaW5nSW5mbyByZXN1bHQgZm9yIGxldmVsICR7aW5kZXh9ICR7c3RyaW5naWZ5KGRlY29kaW5nSW5mbyl9YCk7XG4gICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xICYmIGxldmVscy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2coYFJlbW92aW5nIHVuc3VwcG9ydGVkIGxldmVsICR7aW5kZXh9YCk7XG4gICAgICAgICAgICAgICAgdGhpcy5obHMucmVtb3ZlTGV2ZWwoaW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhscy5sb2FkTGV2ZWwgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmhscy5uZXh0TG9hZExldmVsID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVjb2RpbmdJbmZvLmRlY29kaW5nSW5mb1Jlc3VsdHMuc29tZShpbmZvID0+IGluZm8uc21vb3RoID09PSBmYWxzZSB8fCBpbmZvLnBvd2VyRWZmaWNpZW50ID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5sb2coYE1lZGlhQ2FwYWJpbGl0aWVzIGRlY29kaW5nSW5mbyBmb3IgbGV2ZWwgJHtpbmRleH0gbm90IHNtb290aCBvciBwb3dlckVmZmljaWVudDogJHtzdHJpbmdpZnkoZGVjb2RpbmdJbmZvKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXZlbEluZm8uc3VwcG9ydGVkUmVzdWx0ID0gU1VQUE9SVEVEX0lORk9fREVGQVVMVDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBza2lwIGNhbmRpZGF0ZXMgd2hpY2ggY2hhbmdlIGNvZGVjLWZhbWlseSBvciB2aWRlby1yYW5nZSxcbiAgICAgIC8vIGFuZCB3aGljaCBkZWNyZWFzZSBvciBpbmNyZWFzZSBmcmFtZS1yYXRlIGZvciB1cCBhbmQgZG93bi1zd2l0Y2ggcmVzcGVjdGZ1bGx5XG4gICAgICBpZiAoY3VycmVudENvZGVjU2V0ICYmIGxldmVsSW5mby5jb2RlY1NldCAhPT0gY3VycmVudENvZGVjU2V0IHx8IGN1cnJlbnRWaWRlb1JhbmdlICYmIGxldmVsSW5mby52aWRlb1JhbmdlICE9PSBjdXJyZW50VmlkZW9SYW5nZSB8fCB1cFN3aXRjaCAmJiBjdXJyZW50RnJhbWVSYXRlID4gbGV2ZWxJbmZvLmZyYW1lUmF0ZSB8fCAhdXBTd2l0Y2ggJiYgY3VycmVudEZyYW1lUmF0ZSA+IDAgJiYgY3VycmVudEZyYW1lUmF0ZSA8IGxldmVsSW5mby5mcmFtZVJhdGUgfHwgKF9sZXZlbEluZm8kc3VwcG9ydGVkUiA9IGxldmVsSW5mby5zdXBwb3J0ZWRSZXN1bHQpICE9IG51bGwgJiYgKF9sZXZlbEluZm8kc3VwcG9ydGVkUjIgPSBfbGV2ZWxJbmZvJHN1cHBvcnRlZFIuZGVjb2RpbmdJbmZvUmVzdWx0cykgIT0gbnVsbCAmJiBfbGV2ZWxJbmZvJHN1cHBvcnRlZFIyLnNvbWUoaW5mbyA9PiBpbmZvLnNtb290aCA9PT0gZmFsc2UpKSB7XG4gICAgICAgIGlmICghZmlyc3RTZWxlY3Rpb24gfHwgaSAhPT0gbWluU3RhcnRJbmRleCkge1xuICAgICAgICAgIGxldmVsc1NraXBwZWQucHVzaChpKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gbGV2ZWxJbmZvLmRldGFpbHM7XG4gICAgICBjb25zdCBhdmdEdXJhdGlvbiA9IChwYXJ0Q3VycmVudCA/IGxldmVsRGV0YWlscyA9PSBudWxsID8gdm9pZCAwIDogbGV2ZWxEZXRhaWxzLnBhcnRUYXJnZXQgOiBsZXZlbERldGFpbHMgPT0gbnVsbCA/IHZvaWQgMCA6IGxldmVsRGV0YWlscy5hdmVyYWdldGFyZ2V0ZHVyYXRpb24pIHx8IGN1cnJlbnRGcmFnRHVyYXRpb247XG4gICAgICBsZXQgYWRqdXN0ZWRidztcbiAgICAgIC8vIGZvbGxvdyBhbGdvcml0aG0gY2FwdHVyZWQgZnJvbSBzdGFnZWZyaWdodCA6XG4gICAgICAvLyBodHRwczovL2FuZHJvaWQuZ29vZ2xlc291cmNlLmNvbS9wbGF0Zm9ybS9mcmFtZXdvcmtzL2F2LysvbWFzdGVyL21lZGlhL2xpYnN0YWdlZnJpZ2h0L2h0dHBsaXZlL0xpdmVTZXNzaW9uLmNwcFxuICAgICAgLy8gUGljayB0aGUgaGlnaGVzdCBiYW5kd2lkdGggc3RyZWFtIGJlbG93IG9yIGVxdWFsIHRvIGVzdGltYXRlZCBiYW5kd2lkdGguXG4gICAgICAvLyBjb25zaWRlciBvbmx5IDgwJSBvZiB0aGUgYXZhaWxhYmxlIGJhbmR3aWR0aCwgYnV0IGlmIHdlIGFyZSBzd2l0Y2hpbmcgdXAsXG4gICAgICAvLyBiZSBldmVuIG1vcmUgY29uc2VydmF0aXZlICg3MCUpIHRvIGF2b2lkIG92ZXJlc3RpbWF0aW5nIGFuZCBpbW1lZGlhdGVseVxuICAgICAgLy8gc3dpdGNoaW5nIGJhY2suXG4gICAgICBpZiAoIXVwU3dpdGNoKSB7XG4gICAgICAgIGFkanVzdGVkYncgPSBid0ZhY3RvciAqIGN1cnJlbnRCdztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkanVzdGVkYncgPSBid1VwRmFjdG9yICogY3VycmVudEJ3O1xuICAgICAgfVxuXG4gICAgICAvLyBVc2UgYXZlcmFnZSBiaXRyYXRlIHdoZW4gc3RhcnZhdGlvbiBkZWxheSAoYnVmZmVyIGxlbmd0aCkgaXMgZ3Qgb3IgZXEgdHdvIHNlZ21lbnQgZHVyYXRpb25zIGFuZCByZWJ1ZmZlcmluZyBpcyBub3QgZXhwZWN0ZWQgKG1heFN0YXJ2YXRpb25EZWxheSA+IDApXG4gICAgICBjb25zdCBiaXRyYXRlID0gY3VycmVudEZyYWdEdXJhdGlvbiAmJiBidWZmZXJTdGFydmF0aW9uRGVsYXkgPj0gY3VycmVudEZyYWdEdXJhdGlvbiAqIDIgJiYgbWF4U3RhcnZhdGlvbkRlbGF5ID09PSAwID8gbGV2ZWxJbmZvLmF2ZXJhZ2VCaXRyYXRlIDogbGV2ZWxJbmZvLm1heEJpdHJhdGU7XG4gICAgICBjb25zdCBmZXRjaER1cmF0aW9uID0gdGhpcy5nZXRUaW1lVG9Mb2FkRnJhZyh0dGZiRXN0aW1hdGVTZWMsIGFkanVzdGVkYncsIGJpdHJhdGUgKiBhdmdEdXJhdGlvbiwgbGV2ZWxEZXRhaWxzID09PSB1bmRlZmluZWQpO1xuICAgICAgY29uc3QgY2FuU3dpdGNoV2l0aGluVG9sZXJhbmNlID1cbiAgICAgIC8vIGlmIGFkanVzdGVkIGJ3IGlzIGdyZWF0ZXIgdGhhbiBsZXZlbCBiaXRyYXRlIEFORFxuICAgICAgYWRqdXN0ZWRidyA+PSBiaXRyYXRlICYmIChcbiAgICAgIC8vIG5vIGxldmVsIGNoYW5nZSwgb3IgbmV3IGxldmVsIGhhcyBubyBlcnJvciBoaXN0b3J5XG4gICAgICBpID09PSBsYXN0TG9hZGVkRnJhZ0xldmVsIHx8IGxldmVsSW5mby5sb2FkRXJyb3IgPT09IDAgJiYgbGV2ZWxJbmZvLmZyYWdtZW50RXJyb3IgPT09IDApICYmIChcbiAgICAgIC8vIGZyYWdtZW50IGZldGNoRHVyYXRpb24gdW5rbm93biBPUiBsaXZlIHN0cmVhbSBPUiBmcmFnbWVudCBmZXRjaER1cmF0aW9uIGxlc3MgdGhhbiBtYXggYWxsb3dlZCBmZXRjaCBkdXJhdGlvbiwgdGhlbiB0aGlzIGxldmVsIG1hdGNoZXNcbiAgICAgIC8vIHdlIGRvbid0IGFjY291bnQgZm9yIG1heCBGZXRjaCBEdXJhdGlvbiBmb3IgbGl2ZSBzdHJlYW1zLCB0aGlzIGlzIHRvIGF2b2lkIHN3aXRjaGluZyBkb3duIHdoZW4gbmVhciB0aGUgZWRnZSBvZiBsaXZlIHNsaWRpbmcgd2luZG93IC4uLlxuICAgICAgLy8gc3BlY2lhbCBjYXNlIHRvIHN1cHBvcnQgc3RhcnRMZXZlbCA9IC0xIChiaXRyYXRlVGVzdCkgb24gbGl2ZSBzdHJlYW1zIDogaW4gdGhhdCBjYXNlIHdlIHNob3VsZCBub3QgZXhpdCBsb29wIHNvIHRoYXQgZmluZEJlc3RMZXZlbCB3aWxsIHJldHVybiAtMVxuICAgICAgZmV0Y2hEdXJhdGlvbiA8PSB0dGZiRXN0aW1hdGVTZWMgfHwgIWlzRmluaXRlTnVtYmVyKGZldGNoRHVyYXRpb24pIHx8IGxpdmUgJiYgIXRoaXMuYml0cmF0ZVRlc3REZWxheSB8fCBmZXRjaER1cmF0aW9uIDwgbWF4RmV0Y2hEdXJhdGlvbik7XG4gICAgICBpZiAoY2FuU3dpdGNoV2l0aGluVG9sZXJhbmNlKSB7XG4gICAgICAgIGNvbnN0IGZvcmNlZEF1dG9MZXZlbCA9IHRoaXMuZm9yY2VkQXV0b0xldmVsO1xuICAgICAgICBpZiAoaSAhPT0gbG9hZExldmVsICYmIChmb3JjZWRBdXRvTGV2ZWwgPT09IC0xIHx8IGZvcmNlZEF1dG9MZXZlbCAhPT0gbG9hZExldmVsKSkge1xuICAgICAgICAgIGlmIChsZXZlbHNTa2lwcGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy50cmFjZShgU2tpcHBlZCBsZXZlbChzKSAke2xldmVsc1NraXBwZWQuam9pbignLCcpfSBvZiAke21heEF1dG9MZXZlbH0gbWF4IHdpdGggQ09ERUNTIGFuZCBWSURFTy1SQU5HRTpcIiR7bGV2ZWxzW2xldmVsc1NraXBwZWRbMF1dLmNvZGVjc31cIiAke2xldmVsc1tsZXZlbHNTa2lwcGVkWzBdXS52aWRlb1JhbmdlfTsgbm90IGNvbXBhdGlibGUgd2l0aCBcIiR7Y3VycmVudENvZGVjU2V0fVwiICR7Y3VycmVudFZpZGVvUmFuZ2V9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuaW5mbyhgc3dpdGNoIGNhbmRpZGF0ZToke3NlbGVjdGlvbkJhc2VMZXZlbH0tPiR7aX0gYWRqdXN0ZWRidygke01hdGgucm91bmQoYWRqdXN0ZWRidyl9KS1iaXRyYXRlPSR7TWF0aC5yb3VuZChhZGp1c3RlZGJ3IC0gYml0cmF0ZSl9IHR0ZmI6JHt0dGZiRXN0aW1hdGVTZWMudG9GaXhlZCgxKX0gYXZnRHVyYXRpb246JHthdmdEdXJhdGlvbi50b0ZpeGVkKDEpfSBtYXhGZXRjaER1cmF0aW9uOiR7bWF4RmV0Y2hEdXJhdGlvbi50b0ZpeGVkKDEpfSBmZXRjaER1cmF0aW9uOiR7ZmV0Y2hEdXJhdGlvbi50b0ZpeGVkKDEpfSBmaXJzdFNlbGVjdGlvbjoke2ZpcnN0U2VsZWN0aW9ufSBjb2RlY1NldDoke2xldmVsSW5mby5jb2RlY1NldH0gdmlkZW9SYW5nZToke2xldmVsSW5mby52aWRlb1JhbmdlfSBobHMubG9hZExldmVsOiR7bG9hZExldmVsfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaXJzdFNlbGVjdGlvbikge1xuICAgICAgICAgIHRoaXMuZmlyc3RTZWxlY3Rpb24gPSBpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFzIHdlIGFyZSBsb29waW5nIGZyb20gaGlnaGVzdCB0byBsb3dlc3QsIHRoaXMgd2lsbCByZXR1cm4gdGhlIGJlc3QgYWNoaWV2YWJsZSBxdWFsaXR5IGxldmVsXG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBub3QgZW5vdWdoIHRpbWUgYnVkZ2V0IGV2ZW4gd2l0aCBxdWFsaXR5IGxldmVsIDAgLi4uIHJlYnVmZmVyaW5nIG1pZ2h0IGhhcHBlblxuICAgIHJldHVybiAtMTtcbiAgfVxuICBzZXQgbmV4dEF1dG9MZXZlbChuZXh0TGV2ZWwpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZGVyaXZlTmV4dEF1dG9MZXZlbChuZXh0TGV2ZWwpO1xuICAgIGlmICh0aGlzLl9uZXh0QXV0b0xldmVsICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5uZXh0QXV0b0xldmVsS2V5ID0gJyc7XG4gICAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIGRlcml2ZU5leHRBdXRvTGV2ZWwobmV4dExldmVsKSB7XG4gICAgY29uc3Qge1xuICAgICAgbWF4QXV0b0xldmVsLFxuICAgICAgbWluQXV0b0xldmVsXG4gICAgfSA9IHRoaXMuaGxzO1xuICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChuZXh0TGV2ZWwsIG1pbkF1dG9MZXZlbCksIG1heEF1dG9MZXZlbCk7XG4gIH1cbn1cblxuY29uc3QgQmluYXJ5U2VhcmNoID0ge1xuICAvKipcbiAgICogU2VhcmNoZXMgZm9yIGFuIGl0ZW0gaW4gYW4gYXJyYXkgd2hpY2ggbWF0Y2hlcyBhIGNlcnRhaW4gY29uZGl0aW9uLlxuICAgKiBUaGlzIHJlcXVpcmVzIHRoZSBjb25kaXRpb24gdG8gb25seSBtYXRjaCBvbmUgaXRlbSBpbiB0aGUgYXJyYXksXG4gICAqIGFuZCBmb3IgdGhlIGFycmF5IHRvIGJlIG9yZGVyZWQuXG4gICAqXG4gICAqIEBwYXJhbSBsaXN0IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAqIEBwYXJhbSBjb21wYXJpc29uRm5cbiAgICogICAgICBDYWxsZWQgYW5kIHByb3ZpZGVkIGEgY2FuZGlkYXRlIGl0ZW0gYXMgdGhlIGZpcnN0IGFyZ3VtZW50LlxuICAgKiAgICAgIFNob3VsZCByZXR1cm46XG4gICAqICAgICAgICAgID4gLTEgaWYgdGhlIGl0ZW0gc2hvdWxkIGJlIGxvY2F0ZWQgYXQgYSBsb3dlciBpbmRleCB0aGFuIHRoZSBwcm92aWRlZCBpdGVtLlxuICAgKiAgICAgICAgICA+IDEgaWYgdGhlIGl0ZW0gc2hvdWxkIGJlIGxvY2F0ZWQgYXQgYSBoaWdoZXIgaW5kZXggdGhhbiB0aGUgcHJvdmlkZWQgaXRlbS5cbiAgICogICAgICAgICAgPiAwIGlmIHRoZSBpdGVtIGlzIHRoZSBpdGVtIHlvdSdyZSBsb29raW5nIGZvci5cbiAgICpcbiAgICogQHJldHVybnMgdGhlIG9iamVjdCBpZiBmb3VuZCwgb3RoZXJ3aXNlIHJldHVybnMgbnVsbFxuICAgKi9cbiAgc2VhcmNoOiBmdW5jdGlvbiAobGlzdCwgY29tcGFyaXNvbkZuKSB7XG4gICAgbGV0IG1pbkluZGV4ID0gMDtcbiAgICBsZXQgbWF4SW5kZXggPSBsaXN0Lmxlbmd0aCAtIDE7XG4gICAgbGV0IGN1cnJlbnRJbmRleCA9IG51bGw7XG4gICAgbGV0IGN1cnJlbnRFbGVtZW50ID0gbnVsbDtcbiAgICB3aGlsZSAobWluSW5kZXggPD0gbWF4SW5kZXgpIHtcbiAgICAgIGN1cnJlbnRJbmRleCA9IChtaW5JbmRleCArIG1heEluZGV4KSAvIDIgfCAwO1xuICAgICAgY3VycmVudEVsZW1lbnQgPSBsaXN0W2N1cnJlbnRJbmRleF07XG4gICAgICBjb25zdCBjb21wYXJpc29uUmVzdWx0ID0gY29tcGFyaXNvbkZuKGN1cnJlbnRFbGVtZW50KTtcbiAgICAgIGlmIChjb21wYXJpc29uUmVzdWx0ID4gMCkge1xuICAgICAgICBtaW5JbmRleCA9IGN1cnJlbnRJbmRleCArIDE7XG4gICAgICB9IGVsc2UgaWYgKGNvbXBhcmlzb25SZXN1bHQgPCAwKSB7XG4gICAgICAgIG1heEluZGV4ID0gY3VycmVudEluZGV4IC0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50RWxlbWVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBmaXJzdCBmcmFnbWVudCB3aG9zZSBlbmRQZHQgdmFsdWUgZXhjZWVkcyB0aGUgZ2l2ZW4gUERULCBvciBudWxsLlxuICogQHBhcmFtIGZyYWdtZW50cyAtIFRoZSBhcnJheSBvZiBjYW5kaWRhdGUgZnJhZ21lbnRzXG4gKiBAcGFyYW0gUERUVmFsdWUgLSBUaGUgUERUIHZhbHVlIHdoaWNoIG11c3QgYmUgZXhjZWVkZWRcbiAqIEBwYXJhbSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIC0gVGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgYSBmcmFnbWVudCdzIHN0YXJ0L2VuZCBjYW4gYmUgd2l0aGluIGluIG9yZGVyIHRvIGJlIGNvbnNpZGVyZWQgY29udGlndW91c1xuICovXG5mdW5jdGlvbiBmaW5kRnJhZ21lbnRCeVBEVChmcmFnbWVudHMsIFBEVFZhbHVlLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlKSB7XG4gIGlmIChQRFRWYWx1ZSA9PT0gbnVsbCB8fCAhQXJyYXkuaXNBcnJheShmcmFnbWVudHMpIHx8ICFmcmFnbWVudHMubGVuZ3RoIHx8ICFpc0Zpbml0ZU51bWJlcihQRFRWYWx1ZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIGlmIGxlc3MgdGhhbiBzdGFydFxuICBjb25zdCBzdGFydFBEVCA9IGZyYWdtZW50c1swXS5wcm9ncmFtRGF0ZVRpbWU7XG4gIGlmIChQRFRWYWx1ZSA8IChzdGFydFBEVCB8fCAwKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGVuZFBEVCA9IGZyYWdtZW50c1tmcmFnbWVudHMubGVuZ3RoIC0gMV0uZW5kUHJvZ3JhbURhdGVUaW1lO1xuICBpZiAoUERUVmFsdWUgPj0gKGVuZFBEVCB8fCAwKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZvciAobGV0IHNlZyA9IDA7IHNlZyA8IGZyYWdtZW50cy5sZW5ndGg7ICsrc2VnKSB7XG4gICAgY29uc3QgZnJhZyA9IGZyYWdtZW50c1tzZWddO1xuICAgIGlmIChwZHRXaXRoaW5Ub2xlcmFuY2VUZXN0KFBEVFZhbHVlLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBmcmFnKSkge1xuICAgICAgcmV0dXJuIGZyYWc7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEZpbmRzIGEgZnJhZ21lbnQgYmFzZWQgb24gdGhlIFNOIG9mIHRoZSBwcmV2aW91cyBmcmFnbWVudDsgb3IgYmFzZWQgb24gdGhlIG5lZWRzIG9mIHRoZSBjdXJyZW50IGJ1ZmZlci5cbiAqIFRoaXMgbWV0aG9kIGNvbXBlbnNhdGVzIGZvciBzbWFsbCBidWZmZXIgZ2FwcyBieSBhcHBseWluZyBhIHRvbGVyYW5jZSB0byB0aGUgc3RhcnQgb2YgYW55IGNhbmRpZGF0ZSBmcmFnbWVudCwgdGh1c1xuICogYnJlYWtpbmcgYW55IHRyYXBzIHdoaWNoIHdvdWxkIGNhdXNlIHRoZSBzYW1lIGZyYWdtZW50IHRvIGJlIGNvbnRpbnVvdXNseSBzZWxlY3RlZCB3aXRoaW4gYSBzbWFsbCByYW5nZS5cbiAqIEBwYXJhbSBmcmFnUHJldmlvdXMgLSBUaGUgbGFzdCBmcmFnIHN1Y2Nlc3NmdWxseSBhcHBlbmRlZFxuICogQHBhcmFtIGZyYWdtZW50cyAtIFRoZSBhcnJheSBvZiBjYW5kaWRhdGUgZnJhZ21lbnRzXG4gKiBAcGFyYW0gYnVmZmVyRW5kIC0gVGhlIGVuZCBvZiB0aGUgY29udGlndW91cyBidWZmZXJlZCByYW5nZSB0aGUgcGxheWhlYWQgaXMgY3VycmVudGx5IHdpdGhpblxuICogQHBhcmFtIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgLSBUaGUgYW1vdW50IG9mIHRpbWUgdGhhdCBhIGZyYWdtZW50J3Mgc3RhcnQvZW5kIGNhbiBiZSB3aXRoaW4gaW4gb3JkZXIgdG8gYmUgY29uc2lkZXJlZCBjb250aWd1b3VzXG4gKiBAcmV0dXJucyBhIG1hdGNoaW5nIGZyYWdtZW50IG9yIG51bGxcbiAqL1xuZnVuY3Rpb24gZmluZEZyYWdtZW50QnlQVFMoZnJhZ1ByZXZpb3VzLCBmcmFnbWVudHMsIGJ1ZmZlckVuZCA9IDAsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPSAwLCBuZXh0RnJhZ0xvb2t1cFRvbGVyYW5jZSA9IDAuMDA1KSB7XG4gIGxldCBmcmFnTmV4dCA9IG51bGw7XG4gIGlmIChmcmFnUHJldmlvdXMpIHtcbiAgICBmcmFnTmV4dCA9IGZyYWdtZW50c1sxICsgZnJhZ1ByZXZpb3VzLnNuIC0gZnJhZ21lbnRzWzBdLnNuXSB8fCBudWxsO1xuICAgIC8vIGNoZWNrIGZvciBidWZmZXItZW5kIHJvdW5kaW5nIGVycm9yXG4gICAgY29uc3QgYnVmZmVyRWRnZUVycm9yID0gZnJhZ1ByZXZpb3VzLmVuZERUUyAtIGJ1ZmZlckVuZDtcbiAgICBpZiAoYnVmZmVyRWRnZUVycm9yID4gMCAmJiBidWZmZXJFZGdlRXJyb3IgPCAwLjAwMDAwMTUpIHtcbiAgICAgIGJ1ZmZlckVuZCArPSAwLjAwMDAwMTU7XG4gICAgfVxuICAgIGlmIChmcmFnTmV4dCAmJiBmcmFnUHJldmlvdXMubGV2ZWwgIT09IGZyYWdOZXh0LmxldmVsICYmIGZyYWdOZXh0LmVuZCA8PSBmcmFnUHJldmlvdXMuZW5kKSB7XG4gICAgICBmcmFnTmV4dCA9IGZyYWdtZW50c1syICsgZnJhZ1ByZXZpb3VzLnNuIC0gZnJhZ21lbnRzWzBdLnNuXSB8fCBudWxsO1xuICAgIH1cbiAgfSBlbHNlIGlmIChidWZmZXJFbmQgPT09IDAgJiYgZnJhZ21lbnRzWzBdLnN0YXJ0ID09PSAwKSB7XG4gICAgZnJhZ05leHQgPSBmcmFnbWVudHNbMF07XG4gIH1cbiAgLy8gUHJlZmVyIHRoZSBuZXh0IGZyYWdtZW50IGlmIGl0J3Mgd2l0aGluIHRvbGVyYW5jZVxuICBpZiAoZnJhZ05leHQgJiYgKCghZnJhZ1ByZXZpb3VzIHx8IGZyYWdQcmV2aW91cy5sZXZlbCA9PT0gZnJhZ05leHQubGV2ZWwpICYmIGZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdChidWZmZXJFbmQsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGZyYWdOZXh0KSA9PT0gMCB8fCBmcmFnbWVudFdpdGhpbkZhc3RTdGFydFN3aXRjaChmcmFnTmV4dCwgZnJhZ1ByZXZpb3VzLCBNYXRoLm1pbihuZXh0RnJhZ0xvb2t1cFRvbGVyYW5jZSwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSkpKSkge1xuICAgIHJldHVybiBmcmFnTmV4dDtcbiAgfVxuICAvLyBXZSBtaWdodCBiZSBzZWVraW5nIHBhc3QgdGhlIHRvbGVyYW5jZSBzbyBmaW5kIHRoZSBiZXN0IG1hdGNoXG4gIGNvbnN0IGZvdW5kRnJhZ21lbnQgPSBCaW5hcnlTZWFyY2guc2VhcmNoKGZyYWdtZW50cywgZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0LmJpbmQobnVsbCwgYnVmZmVyRW5kLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlKSk7XG4gIGlmIChmb3VuZEZyYWdtZW50ICYmIChmb3VuZEZyYWdtZW50ICE9PSBmcmFnUHJldmlvdXMgfHwgIWZyYWdOZXh0KSkge1xuICAgIHJldHVybiBmb3VuZEZyYWdtZW50O1xuICB9XG4gIC8vIElmIG5vIG1hdGNoIHdhcyBmb3VuZCByZXR1cm4gdGhlIG5leHQgZnJhZ21lbnQgYWZ0ZXIgZnJhZ1ByZXZpb3VzLCBvciBudWxsXG4gIHJldHVybiBmcmFnTmV4dDtcbn1cbmZ1bmN0aW9uIGZyYWdtZW50V2l0aGluRmFzdFN0YXJ0U3dpdGNoKGZyYWdOZXh0LCBmcmFnUHJldmlvdXMsIG5leHRGcmFnTG9va3VwVG9sZXJhbmNlKSB7XG4gIGlmIChmcmFnUHJldmlvdXMgJiYgZnJhZ1ByZXZpb3VzLnN0YXJ0ID09PSAwICYmIGZyYWdQcmV2aW91cy5sZXZlbCA8IGZyYWdOZXh0LmxldmVsICYmIChmcmFnUHJldmlvdXMuZW5kUFRTIHx8IDApID4gMCkge1xuICAgIGNvbnN0IGZpcnN0RHVyYXRpb24gPSBmcmFnUHJldmlvdXMudGFnTGlzdC5yZWR1Y2UoKGR1cmF0aW9uLCB0YWcpID0+IHtcbiAgICAgIGlmICh0YWdbMF0gPT09ICdJTkYnKSB7XG4gICAgICAgIGR1cmF0aW9uICs9IHBhcnNlRmxvYXQodGFnWzFdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkdXJhdGlvbjtcbiAgICB9LCBuZXh0RnJhZ0xvb2t1cFRvbGVyYW5jZSk7XG4gICAgcmV0dXJuIGZyYWdOZXh0LnN0YXJ0IDw9IGZpcnN0RHVyYXRpb247XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFRoZSB0ZXN0IGZ1bmN0aW9uIHVzZWQgYnkgdGhlIGZpbmRGcmFnbWVudEJ5U24ncyBCaW5hcnlTZWFyY2ggdG8gbG9vayBmb3IgdGhlIGJlc3QgbWF0Y2ggdG8gdGhlIGN1cnJlbnQgYnVmZmVyIGNvbmRpdGlvbnMuXG4gKiBAcGFyYW0gY2FuZGlkYXRlIC0gVGhlIGZyYWdtZW50IHRvIHRlc3RcbiAqIEBwYXJhbSBidWZmZXJFbmQgLSBUaGUgZW5kIG9mIHRoZSBjdXJyZW50IGJ1ZmZlcmVkIHJhbmdlIHRoZSBwbGF5aGVhZCBpcyBjdXJyZW50bHkgd2l0aGluXG4gKiBAcGFyYW0gbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSAtIFRoZSBhbW91bnQgb2YgdGltZSB0aGF0IGEgZnJhZ21lbnQncyBzdGFydCBjYW4gYmUgd2l0aGluIGluIG9yZGVyIHRvIGJlIGNvbnNpZGVyZWQgY29udGlndW91c1xuICogQHJldHVybnMgMCBpZiBpdCBtYXRjaGVzLCAxIGlmIHRvbyBsb3csIC0xIGlmIHRvbyBoaWdoXG4gKi9cbmZ1bmN0aW9uIGZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdChidWZmZXJFbmQgPSAwLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gMCwgY2FuZGlkYXRlKSB7XG4gIC8vIGVhZ2VybHkgYWNjZXB0IGFuIGFjY3VyYXRlIG1hdGNoIChubyB0b2xlcmFuY2UpXG4gIGlmIChjYW5kaWRhdGUuc3RhcnQgPD0gYnVmZmVyRW5kICYmIGNhbmRpZGF0ZS5zdGFydCArIGNhbmRpZGF0ZS5kdXJhdGlvbiA+IGJ1ZmZlckVuZCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIC8vIG9mZnNldCBzaG91bGQgYmUgd2l0aGluIGZyYWdtZW50IGJvdW5kYXJ5IC0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2VcbiAgLy8gdGhpcyBpcyB0byBjb3BlIHdpdGggc2l0dWF0aW9ucyBsaWtlXG4gIC8vIGJ1ZmZlckVuZCA9IDkuOTkxXG4gIC8vIGZyYWdbw5hdIDogWzAsMTBdXG4gIC8vIGZyYWdbMV0gOiBbMTAsMjBdXG4gIC8vIGJ1ZmZlckVuZCBpcyB3aXRoaW4gZnJhZ1swXSByYW5nZSAuLi4gYWx0aG91Z2ggd2hhdCB3ZSBhcmUgZXhwZWN0aW5nIGlzIHRvIHJldHVybiBmcmFnWzFdIGhlcmVcbiAgLy8gICAgICAgICAgICAgIGZyYWcgc3RhcnQgICAgICAgICAgICAgICBmcmFnIHN0YXJ0K2R1cmF0aW9uXG4gIC8vICAgICAgICAgICAgICAgICAgfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICAvLyAgICAgICAgICAgICAgPC0tLT4gICAgICAgICAgICAgICAgICAgICAgICAgPC0tLT5cbiAgLy8gIC4uLi0tLS0tLS0tPjwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT48LS0tLS0tLS0tLi4uLlxuICAvLyBwcmV2aW91cyBmcmFnICAgICAgICAgbWF0Y2hpbmcgZnJhZ21lbnQgICAgICAgICBuZXh0IGZyYWdcbiAgLy8gIHJldHVybiAtMSAgICAgICAgICAgICByZXR1cm4gMCAgICAgICAgICAgICAgICAgcmV0dXJuIDFcbiAgLy8gbG9nZ2VyLmxvZyhgbGV2ZWwvc24vc3RhcnQvZW5kL2J1ZkVuZDoke2xldmVsfS8ke2NhbmRpZGF0ZS5zbn0vJHtjYW5kaWRhdGUuc3RhcnR9LyR7KGNhbmRpZGF0ZS5zdGFydCtjYW5kaWRhdGUuZHVyYXRpb24pfS8ke2J1ZmZlckVuZH1gKTtcbiAgLy8gU2V0IHRoZSBsb29rdXAgdG9sZXJhbmNlIHRvIGJlIHNtYWxsIGVub3VnaCB0byBkZXRlY3QgdGhlIGN1cnJlbnQgc2VnbWVudCAtIGVuc3VyZXMgd2UgZG9uJ3Qgc2tpcCBvdmVyIHZlcnkgc21hbGwgc2VnbWVudHNcbiAgY29uc3QgY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID0gTWF0aC5taW4obWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgY2FuZGlkYXRlLmR1cmF0aW9uICsgKGNhbmRpZGF0ZS5kZWx0YVBUUyA/IGNhbmRpZGF0ZS5kZWx0YVBUUyA6IDApKTtcbiAgaWYgKGNhbmRpZGF0ZS5zdGFydCArIGNhbmRpZGF0ZS5kdXJhdGlvbiAtIGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA8PSBidWZmZXJFbmQpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIGlmIChjYW5kaWRhdGUuc3RhcnQgLSBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPiBidWZmZXJFbmQgJiYgY2FuZGlkYXRlLnN0YXJ0KSB7XG4gICAgLy8gaWYgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSB3aWxsIGhhdmUgbmVnYXRpdmUgdmFsdWUgdGhlbiBkb24ndCByZXR1cm4gLTEgZm9yIGZpcnN0IGVsZW1lbnRcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8qKlxuICogVGhlIHRlc3QgZnVuY3Rpb24gdXNlZCBieSB0aGUgZmluZEZyYWdtZW50QnlQZHQncyBCaW5hcnlTZWFyY2ggdG8gbG9vayBmb3IgdGhlIGJlc3QgbWF0Y2ggdG8gdGhlIGN1cnJlbnQgYnVmZmVyIGNvbmRpdGlvbnMuXG4gKiBUaGlzIGZ1bmN0aW9uIHRlc3RzIHRoZSBjYW5kaWRhdGUncyBwcm9ncmFtIGRhdGUgdGltZSB2YWx1ZXMsIGFzIHJlcHJlc2VudGVkIGluIFVuaXggdGltZVxuICogQHBhcmFtIGNhbmRpZGF0ZSAtIFRoZSBmcmFnbWVudCB0byB0ZXN0XG4gKiBAcGFyYW0gcGR0QnVmZmVyRW5kIC0gVGhlIFVuaXggdGltZSByZXByZXNlbnRpbmcgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBidWZmZXJlZCByYW5nZVxuICogQHBhcmFtIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgLSBUaGUgYW1vdW50IG9mIHRpbWUgdGhhdCBhIGZyYWdtZW50J3Mgc3RhcnQgY2FuIGJlIHdpdGhpbiBpbiBvcmRlciB0byBiZSBjb25zaWRlcmVkIGNvbnRpZ3VvdXNcbiAqIEByZXR1cm5zIHRydWUgaWYgY29udGlndW91cywgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmZ1bmN0aW9uIHBkdFdpdGhpblRvbGVyYW5jZVRlc3QocGR0QnVmZmVyRW5kLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBjYW5kaWRhdGUpIHtcbiAgY29uc3QgY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID0gTWF0aC5taW4obWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgY2FuZGlkYXRlLmR1cmF0aW9uICsgKGNhbmRpZGF0ZS5kZWx0YVBUUyA/IGNhbmRpZGF0ZS5kZWx0YVBUUyA6IDApKSAqIDEwMDA7XG5cbiAgLy8gZW5kUHJvZ3JhbURhdGVUaW1lIGNhbiBiZSBudWxsLCBkZWZhdWx0IHRvIHplcm9cbiAgY29uc3QgZW5kUHJvZ3JhbURhdGVUaW1lID0gY2FuZGlkYXRlLmVuZFByb2dyYW1EYXRlVGltZSB8fCAwO1xuICByZXR1cm4gZW5kUHJvZ3JhbURhdGVUaW1lIC0gY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID4gcGR0QnVmZmVyRW5kO1xufVxuZnVuY3Rpb24gZmluZE5lYXJlc3RXaXRoQ0MoZGV0YWlscywgY2MsIHBvcykge1xuICBpZiAoZGV0YWlscykge1xuICAgIGlmIChkZXRhaWxzLnN0YXJ0Q0MgPD0gY2MgJiYgZGV0YWlscy5lbmRDQyA+PSBjYykge1xuICAgICAgbGV0IGZyYWdtZW50cyA9IGRldGFpbHMuZnJhZ21lbnRzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBmcmFnbWVudEhpbnRcbiAgICAgIH0gPSBkZXRhaWxzO1xuICAgICAgaWYgKGZyYWdtZW50SGludCkge1xuICAgICAgICBmcmFnbWVudHMgPSBmcmFnbWVudHMuY29uY2F0KGZyYWdtZW50SGludCk7XG4gICAgICB9XG4gICAgICBsZXQgY2xvc2VzdDtcbiAgICAgIEJpbmFyeVNlYXJjaC5zZWFyY2goZnJhZ21lbnRzLCBjYW5kaWRhdGUgPT4ge1xuICAgICAgICBpZiAoY2FuZGlkYXRlLmNjIDwgY2MpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FuZGlkYXRlLmNjID4gY2MpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgY2xvc2VzdCA9IGNhbmRpZGF0ZTtcbiAgICAgICAgaWYgKGNhbmRpZGF0ZS5lbmQgPD0gcG9zKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbmRpZGF0ZS5zdGFydCA+IHBvcykge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNsb3Nlc3QgfHwgbnVsbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVGltZW91dEVycm9yKGVycm9yKSB7XG4gIHN3aXRjaCAoZXJyb3IuZGV0YWlscykge1xuICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxuICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQ6XG4gICAgY2FzZSBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9USU1FT1VUOlxuICAgIGNhc2UgRXJyb3JEZXRhaWxzLk1BTklGRVNUX0xPQURfVElNRU9VVDpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFJldHJ5Q29uZmlnKGxvYWRQb2xpY3ksIGVycm9yKSB7XG4gIGNvbnN0IGlzVGltZW91dCA9IGlzVGltZW91dEVycm9yKGVycm9yKTtcbiAgcmV0dXJuIGxvYWRQb2xpY3kuZGVmYXVsdFtgJHtpc1RpbWVvdXQgPyAndGltZW91dCcgOiAnZXJyb3InfVJldHJ5YF07XG59XG5mdW5jdGlvbiBnZXRSZXRyeURlbGF5KHJldHJ5Q29uZmlnLCByZXRyeUNvdW50KSB7XG4gIC8vIGV4cG9uZW50aWFsIGJhY2tvZmYgY2FwcGVkIHRvIG1heCByZXRyeSBkZWxheVxuICBjb25zdCBiYWNrb2ZmRmFjdG9yID0gcmV0cnlDb25maWcuYmFja29mZiA9PT0gJ2xpbmVhcicgPyAxIDogTWF0aC5wb3coMiwgcmV0cnlDb3VudCk7XG4gIHJldHVybiBNYXRoLm1pbihiYWNrb2ZmRmFjdG9yICogcmV0cnlDb25maWcucmV0cnlEZWxheU1zLCByZXRyeUNvbmZpZy5tYXhSZXRyeURlbGF5TXMpO1xufVxuZnVuY3Rpb24gZ2V0TG9hZGVyQ29uZmlnV2l0aG91dFJldGllcyhsb2RlckNvbmZpZykge1xuICByZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGxvZGVyQ29uZmlnKSwge1xuICAgIGVycm9yUmV0cnk6IG51bGwsXG4gICAgdGltZW91dFJldHJ5OiBudWxsXG4gIH0pO1xufVxuZnVuY3Rpb24gc2hvdWxkUmV0cnkocmV0cnlDb25maWcsIHJldHJ5Q291bnQsIGlzVGltZW91dCwgbG9hZGVyUmVzcG9uc2UpIHtcbiAgaWYgKCFyZXRyeUNvbmZpZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBodHRwU3RhdHVzID0gbG9hZGVyUmVzcG9uc2UgPT0gbnVsbCA/IHZvaWQgMCA6IGxvYWRlclJlc3BvbnNlLmNvZGU7XG4gIGNvbnN0IHJldHJ5ID0gcmV0cnlDb3VudCA8IHJldHJ5Q29uZmlnLm1heE51bVJldHJ5ICYmIChyZXRyeUZvckh0dHBTdGF0dXMoaHR0cFN0YXR1cykgfHwgISFpc1RpbWVvdXQpO1xuICByZXR1cm4gcmV0cnlDb25maWcuc2hvdWxkUmV0cnkgPyByZXRyeUNvbmZpZy5zaG91bGRSZXRyeShyZXRyeUNvbmZpZywgcmV0cnlDb3VudCwgaXNUaW1lb3V0LCBsb2FkZXJSZXNwb25zZSwgcmV0cnkpIDogcmV0cnk7XG59XG5mdW5jdGlvbiByZXRyeUZvckh0dHBTdGF0dXMoaHR0cFN0YXR1cykge1xuICAvLyBEbyBub3QgcmV0cnkgb24gc3RhdHVzIDR4eCwgc3RhdHVzIDAgKENPUlMgZXJyb3IpLCBvciB1bmRlZmluZWQgKGRlY3J5cHQvZ2FwL3BhcnNlIGVycm9yKVxuICByZXR1cm4gaHR0cFN0YXR1cyA9PT0gMCAmJiBuYXZpZ2F0b3Iub25MaW5lID09PSBmYWxzZSB8fCAhIWh0dHBTdGF0dXMgJiYgKGh0dHBTdGF0dXMgPCA0MDAgfHwgaHR0cFN0YXR1cyA+IDQ5OSk7XG59XG5cbnZhciBOZXR3b3JrRXJyb3JBY3Rpb24gPSB7XG4gIERvTm90aGluZzogMCxcbiAgU2VuZEVuZENhbGxiYWNrOiAxLFxuICBTZW5kQWx0ZXJuYXRlVG9QZW5hbHR5Qm94OiAyLFxuICBSZW1vdmVBbHRlcm5hdGVQZXJtYW5lbnRseTogMyxcbiAgSW5zZXJ0RGlzY29udGludWl0eTogNCxcbiAgUmV0cnlSZXF1ZXN0OiA1XG59O1xudmFyIEVycm9yQWN0aW9uRmxhZ3MgPSB7XG4gIE5vbmU6IDAsXG4gIE1vdmVBbGxBbHRlcm5hdGVzTWF0Y2hpbmdIb3N0OiAxLFxuICBNb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nSERDUDogMixcbiAgU3dpdGNoVG9TRFI6IDRcbn07XG5jbGFzcyBFcnJvckNvbnRyb2xsZXIgZXh0ZW5kcyBMb2dnZXIge1xuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICBzdXBlcignZXJyb3ItY29udHJvbGxlcicsIGhscy5sb2dnZXIpO1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMucGxheWxpc3RFcnJvciA9IDA7XG4gICAgdGhpcy5wZW5hbGl6ZWRSZW5kaXRpb25zID0ge307XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vbihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX1VQREFURUQsIHRoaXMub25MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICB9XG4gIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgaWYgKCFobHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaGxzLm9mZihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvck91dCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxfVVBEQVRFRCwgdGhpcy5vbkxldmVsVXBkYXRlZCwgdGhpcyk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSBudWxsO1xuICAgIHRoaXMucGVuYWxpemVkUmVuZGl0aW9ucyA9IHt9O1xuICB9XG4gIHN0YXJ0TG9hZChzdGFydFBvc2l0aW9uKSB7fVxuICBzdG9wTG9hZCgpIHtcbiAgICB0aGlzLnBsYXlsaXN0RXJyb3IgPSAwO1xuICB9XG4gIGdldFZhcmlhbnRMZXZlbEluZGV4KGZyYWcpIHtcbiAgICByZXR1cm4gKGZyYWcgPT0gbnVsbCA/IHZvaWQgMCA6IGZyYWcudHlwZSkgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4gPyBmcmFnLmxldmVsIDogdGhpcy5obHMubG9hZExldmVsO1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHRoaXMucGxheWxpc3RFcnJvciA9IDA7XG4gICAgdGhpcy5wZW5hbGl6ZWRSZW5kaXRpb25zID0ge307XG4gIH1cbiAgb25MZXZlbFVwZGF0ZWQoKSB7XG4gICAgdGhpcy5wbGF5bGlzdEVycm9yID0gMDtcbiAgfVxuICBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF9kYXRhJGZyYWc7XG4gICAgaWYgKGRhdGEuZmF0YWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgY29uc3QgY29udGV4dCA9IGRhdGEuY29udGV4dDtcbiAgICBzd2l0Y2ggKGRhdGEuZGV0YWlscykge1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQ6XG4gICAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSB0aGlzLmdldEZyYWdSZXRyeU9yU3dpdGNoQWN0aW9uKGRhdGEpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1I6XG4gICAgICAgIC8vIGlnbm9yZSBlbXB0eSBzZWdtZW50IGVycm9ycyBtYXJrZWQgYXMgZ2FwXG4gICAgICAgIGlmICgoX2RhdGEkZnJhZyA9IGRhdGEuZnJhZykgIT0gbnVsbCAmJiBfZGF0YSRmcmFnLmdhcCkge1xuICAgICAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSBjcmVhdGVEb05vdGhpbmdFcnJvckFjdGlvbigpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19HQVA6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0RFQ1JZUFRfRVJST1I6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBTd2l0Y2ggbGV2ZWwgaWYgcG9zc2libGUsIG90aGVyd2lzZSBhbGxvdyByZXRyeSBjb3VudCB0byByZWFjaCBtYXggZXJyb3IgcmV0cmllc1xuICAgICAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSB0aGlzLmdldEZyYWdSZXRyeU9yU3dpdGNoQWN0aW9uKGRhdGEpO1xuICAgICAgICAgIGRhdGEuZXJyb3JBY3Rpb24uYWN0aW9uID0gTmV0d29ya0Vycm9yQWN0aW9uLlNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3g7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9FTVBUWV9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX1BBUlNJTkdfRVJST1I6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2RhdGEkY29udGV4dCwgX2RhdGEkY29udGV4dCRsZXZlbERlO1xuICAgICAgICAgIC8vIE9ubHkgcmV0cnkgd2hlbiBlbXB0eSBhbmQgbGl2ZVxuICAgICAgICAgIGNvbnN0IGxldmVsSW5kZXggPSBkYXRhLnBhcmVudCA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTiA/IGRhdGEubGV2ZWwgOiBobHMubG9hZExldmVsO1xuICAgICAgICAgIGlmIChkYXRhLmRldGFpbHMgPT09IEVycm9yRGV0YWlscy5MRVZFTF9FTVBUWV9FUlJPUiAmJiAhISgoX2RhdGEkY29udGV4dCA9IGRhdGEuY29udGV4dCkgIT0gbnVsbCAmJiAoX2RhdGEkY29udGV4dCRsZXZlbERlID0gX2RhdGEkY29udGV4dC5sZXZlbERldGFpbHMpICE9IG51bGwgJiYgX2RhdGEkY29udGV4dCRsZXZlbERlLmxpdmUpKSB7XG4gICAgICAgICAgICBkYXRhLmVycm9yQWN0aW9uID0gdGhpcy5nZXRQbGF5bGlzdFJldHJ5T3JTd2l0Y2hBY3Rpb24oZGF0YSwgbGV2ZWxJbmRleCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEVzY2FsYXRlIHRvIGZhdGFsIGlmIG5vdCByZXRyeWluZyBvciBzd2l0Y2hpbmdcbiAgICAgICAgICAgIGRhdGEubGV2ZWxSZXRyeSA9IGZhbHNlO1xuICAgICAgICAgICAgZGF0YS5lcnJvckFjdGlvbiA9IHRoaXMuZ2V0TGV2ZWxTd2l0Y2hBY3Rpb24oZGF0YSwgbGV2ZWxJbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQ6XG4gICAgICAgIGlmICh0eXBlb2YgKGNvbnRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRleHQubGV2ZWwpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSB0aGlzLmdldFBsYXlsaXN0UmV0cnlPclN3aXRjaEFjdGlvbihkYXRhLCBjb250ZXh0LmxldmVsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuU1VCVElUTEVfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLlNVQlRJVExFX1RSQUNLX0xPQURfVElNRU9VVDpcbiAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICBjb25zdCBsZXZlbCA9IGhscy5sb2FkTGV2ZWxPYmo7XG4gICAgICAgICAgaWYgKGxldmVsICYmIChjb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0sgJiYgbGV2ZWwuaGFzQXVkaW9Hcm91cChjb250ZXh0Lmdyb3VwSWQpIHx8IGNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSyAmJiBsZXZlbC5oYXNTdWJ0aXRsZUdyb3VwKGNvbnRleHQuZ3JvdXBJZCkpKSB7XG4gICAgICAgICAgICAvLyBQZXJmb3JtIFBhdGh3YXkgc3dpdGNoIG9yIFJlZHVuZGFudCBmYWlsb3ZlciBpZiBwb3NzaWJsZSBmb3IgZmFzdGVzdCByZWNvdmVyeVxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGFsbG93IHBsYXlsaXN0IHJldHJ5IGNvdW50IHRvIHJlYWNoIG1heCBlcnJvciByZXRyaWVzXG4gICAgICAgICAgICBkYXRhLmVycm9yQWN0aW9uID0gdGhpcy5nZXRQbGF5bGlzdFJldHJ5T3JTd2l0Y2hBY3Rpb24oZGF0YSwgaGxzLmxvYWRMZXZlbCk7XG4gICAgICAgICAgICBkYXRhLmVycm9yQWN0aW9uLmFjdGlvbiA9IE5ldHdvcmtFcnJvckFjdGlvbi5TZW5kQWx0ZXJuYXRlVG9QZW5hbHR5Qm94O1xuICAgICAgICAgICAgZGF0YS5lcnJvckFjdGlvbi5mbGFncyA9IEVycm9yQWN0aW9uRmxhZ3MuTW92ZUFsbEFsdGVybmF0ZXNNYXRjaGluZ0hvc3Q7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fU1RBVFVTX09VVFBVVF9SRVNUUklDVEVEOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgbGV2ZWwgPSBobHMubG9hZExldmVsT2JqO1xuICAgICAgICAgIGNvbnN0IHJlc3RyaWN0ZWRIZGNwTGV2ZWwgPSBsZXZlbCA9PSBudWxsID8gdm9pZCAwIDogbGV2ZWwuYXR0cnNbJ0hEQ1AtTEVWRUwnXTtcbiAgICAgICAgICBpZiAocmVzdHJpY3RlZEhkY3BMZXZlbCkge1xuICAgICAgICAgICAgZGF0YS5lcnJvckFjdGlvbiA9IHtcbiAgICAgICAgICAgICAgYWN0aW9uOiBOZXR3b3JrRXJyb3JBY3Rpb24uU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveCxcbiAgICAgICAgICAgICAgZmxhZ3M6IEVycm9yQWN0aW9uRmxhZ3MuTW92ZUFsbEFsdGVybmF0ZXNNYXRjaGluZ0hEQ1AsXG4gICAgICAgICAgICAgIGhkY3BMZXZlbDogcmVzdHJpY3RlZEhkY3BMZXZlbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5rZXlTeXN0ZW1FcnJvcihkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0FERF9DT0RFQ19FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLlJFTVVYX0FMTE9DX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORF9FUlJPUjpcbiAgICAgICAgLy8gQnVmZmVyLWNvbnRyb2xsZXIgY2FuIHNldCBlcnJvckFjdGlvbiB3aGVuIGFwcGVuZCBlcnJvcnMgY2FuIGJlIGlnbm9yZWQgb3IgcmVzb2x2ZWQgbG9jYWxseVxuICAgICAgICBpZiAoIWRhdGEuZXJyb3JBY3Rpb24pIHtcbiAgICAgICAgICB2YXIgX2RhdGEkbGV2ZWw7XG4gICAgICAgICAgZGF0YS5lcnJvckFjdGlvbiA9IHRoaXMuZ2V0TGV2ZWxTd2l0Y2hBY3Rpb24oZGF0YSwgKF9kYXRhJGxldmVsID0gZGF0YS5sZXZlbCkgIT0gbnVsbCA/IF9kYXRhJGxldmVsIDogaGxzLmxvYWRMZXZlbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuSU5URVJOQUxfRVhDRVBUSU9OOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORElOR19FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9GVUxMX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuTEVWRUxfU1dJVENIX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX1NUQUxMRURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfU0VFS19PVkVSX0hPTEU6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfTlVER0VfT05fU1RBTEw6XG4gICAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSBjcmVhdGVEb05vdGhpbmdFcnJvckFjdGlvbigpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkYXRhLnR5cGUgPT09IEVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUikge1xuICAgICAgdGhpcy5rZXlTeXN0ZW1FcnJvcihkYXRhKTtcbiAgICB9XG4gIH1cbiAga2V5U3lzdGVtRXJyb3IoZGF0YSkge1xuICAgIGNvbnN0IGxldmVsSW5kZXggPSB0aGlzLmdldFZhcmlhbnRMZXZlbEluZGV4KGRhdGEuZnJhZyk7XG4gICAgLy8gRG8gbm90IHJldHJ5IGxldmVsLiBFc2NhbGF0ZSB0byBmYXRhbCBpZiBzd2l0Y2hpbmcgbGV2ZWxzIGZhaWxzLlxuICAgIGRhdGEubGV2ZWxSZXRyeSA9IGZhbHNlO1xuICAgIGRhdGEuZXJyb3JBY3Rpb24gPSB0aGlzLmdldExldmVsU3dpdGNoQWN0aW9uKGRhdGEsIGxldmVsSW5kZXgpO1xuICB9XG4gIGdldFBsYXlsaXN0UmV0cnlPclN3aXRjaEFjdGlvbihkYXRhLCBsZXZlbEluZGV4KSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgY29uc3QgcmV0cnlDb25maWcgPSBnZXRSZXRyeUNvbmZpZyhobHMuY29uZmlnLnBsYXlsaXN0TG9hZFBvbGljeSwgZGF0YSk7XG4gICAgY29uc3QgcmV0cnlDb3VudCA9IHRoaXMucGxheWxpc3RFcnJvcisrO1xuICAgIGNvbnN0IHJldHJ5ID0gc2hvdWxkUmV0cnkocmV0cnlDb25maWcsIHJldHJ5Q291bnQsIGlzVGltZW91dEVycm9yKGRhdGEpLCBkYXRhLnJlc3BvbnNlKTtcbiAgICBpZiAocmV0cnkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFjdGlvbjogTmV0d29ya0Vycm9yQWN0aW9uLlJldHJ5UmVxdWVzdCxcbiAgICAgICAgZmxhZ3M6IEVycm9yQWN0aW9uRmxhZ3MuTm9uZSxcbiAgICAgICAgcmV0cnlDb25maWcsXG4gICAgICAgIHJldHJ5Q291bnRcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGVycm9yQWN0aW9uID0gdGhpcy5nZXRMZXZlbFN3aXRjaEFjdGlvbihkYXRhLCBsZXZlbEluZGV4KTtcbiAgICBpZiAocmV0cnlDb25maWcpIHtcbiAgICAgIGVycm9yQWN0aW9uLnJldHJ5Q29uZmlnID0gcmV0cnlDb25maWc7XG4gICAgICBlcnJvckFjdGlvbi5yZXRyeUNvdW50ID0gcmV0cnlDb3VudDtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yQWN0aW9uO1xuICB9XG4gIGdldEZyYWdSZXRyeU9yU3dpdGNoQWN0aW9uKGRhdGEpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICAvLyBTaGFyZSBmcmFnbWVudCBlcnJvciBjb3VudCBhY2Nyb3NzIG1lZGlhIG9wdGlvbnMgKG1haW4sIGF1ZGlvLCBzdWJzKVxuICAgIC8vIFRoaXMgYWxsb3dzIGZvciBsZXZlbCBiYXNlZCByZW5kaXRpb24gc3dpdGNoaW5nIHdoZW4gbWVkaWEgb3B0aW9uIGFzc2V0cyBmYWlsXG4gICAgY29uc3QgdmFyaWFudExldmVsSW5kZXggPSB0aGlzLmdldFZhcmlhbnRMZXZlbEluZGV4KGRhdGEuZnJhZyk7XG4gICAgY29uc3QgbGV2ZWwgPSBobHMubGV2ZWxzW3ZhcmlhbnRMZXZlbEluZGV4XTtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnTG9hZFBvbGljeSxcbiAgICAgIGtleUxvYWRQb2xpY3lcbiAgICB9ID0gaGxzLmNvbmZpZztcbiAgICBjb25zdCByZXRyeUNvbmZpZyA9IGdldFJldHJ5Q29uZmlnKGRhdGEuZGV0YWlscy5zdGFydHNXaXRoKCdrZXknKSA/IGtleUxvYWRQb2xpY3kgOiBmcmFnTG9hZFBvbGljeSwgZGF0YSk7XG4gICAgY29uc3QgZnJhZ21lbnRFcnJvcnMgPSBobHMubGV2ZWxzLnJlZHVjZSgoYWNjLCBsZXZlbCkgPT4gYWNjICsgbGV2ZWwuZnJhZ21lbnRFcnJvciwgMCk7XG4gICAgLy8gU3dpdGNoIGxldmVscyB3aGVuIG91dCBvZiByZXRyaWVkIG9yIGxldmVsIGluZGV4IG91dCBvZiBib3VuZHNcbiAgICBpZiAobGV2ZWwpIHtcbiAgICAgIGlmIChkYXRhLmRldGFpbHMgIT09IEVycm9yRGV0YWlscy5GUkFHX0dBUCkge1xuICAgICAgICBsZXZlbC5mcmFnbWVudEVycm9yKys7XG4gICAgICB9XG4gICAgICBjb25zdCByZXRyeSA9IHNob3VsZFJldHJ5KHJldHJ5Q29uZmlnLCBmcmFnbWVudEVycm9ycywgaXNUaW1lb3V0RXJyb3IoZGF0YSksIGRhdGEucmVzcG9uc2UpO1xuICAgICAgaWYgKHJldHJ5KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYWN0aW9uOiBOZXR3b3JrRXJyb3JBY3Rpb24uUmV0cnlSZXF1ZXN0LFxuICAgICAgICAgIGZsYWdzOiBFcnJvckFjdGlvbkZsYWdzLk5vbmUsXG4gICAgICAgICAgcmV0cnlDb25maWcsXG4gICAgICAgICAgcmV0cnlDb3VudDogZnJhZ21lbnRFcnJvcnNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVhY2ggbWF4IHJldHJ5IGNvdW50LCBvciBNaXNzaW5nIGxldmVsIHJlZmVyZW5jZVxuICAgIC8vIFN3aXRjaCB0byB2YWxpZCBpbmRleFxuICAgIGNvbnN0IGVycm9yQWN0aW9uID0gdGhpcy5nZXRMZXZlbFN3aXRjaEFjdGlvbihkYXRhLCB2YXJpYW50TGV2ZWxJbmRleCk7XG4gICAgLy8gQWRkIHJldHJ5IGRldGFpbHMgdG8gYWxsb3cgc2tpcHBpbmcgb2YgRlJBR19QQVJTSU5HX0VSUk9SXG4gICAgaWYgKHJldHJ5Q29uZmlnKSB7XG4gICAgICBlcnJvckFjdGlvbi5yZXRyeUNvbmZpZyA9IHJldHJ5Q29uZmlnO1xuICAgICAgZXJyb3JBY3Rpb24ucmV0cnlDb3VudCA9IGZyYWdtZW50RXJyb3JzO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JBY3Rpb247XG4gIH1cbiAgZ2V0TGV2ZWxTd2l0Y2hBY3Rpb24oZGF0YSwgbGV2ZWxJbmRleCkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGlmIChsZXZlbEluZGV4ID09PSBudWxsIHx8IGxldmVsSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV2ZWxJbmRleCA9IGhscy5sb2FkTGV2ZWw7XG4gICAgfVxuICAgIGNvbnN0IGxldmVsID0gdGhpcy5obHMubGV2ZWxzW2xldmVsSW5kZXhdO1xuICAgIGlmIChsZXZlbCkge1xuICAgICAgdmFyIF9kYXRhJGZyYWcyLCBfZGF0YSRjb250ZXh0MjtcbiAgICAgIGNvbnN0IGVycm9yRGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICAgIGxldmVsLmxvYWRFcnJvcisrO1xuICAgICAgaWYgKGVycm9yRGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRfRVJST1IpIHtcbiAgICAgICAgbGV2ZWwuZnJhZ21lbnRFcnJvcisrO1xuICAgICAgfVxuICAgICAgLy8gU2VhcmNoIGZvciBuZXh0IGxldmVsIHRvIHJldHJ5XG4gICAgICBsZXQgbmV4dExldmVsID0gLTE7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxldmVscyxcbiAgICAgICAgbG9hZExldmVsLFxuICAgICAgICBtaW5BdXRvTGV2ZWwsXG4gICAgICAgIG1heEF1dG9MZXZlbFxuICAgICAgfSA9IGhscztcbiAgICAgIGlmICghaGxzLmF1dG9MZXZlbEVuYWJsZWQgJiYgIWhscy5jb25maWcucHJlc2VydmVNYW51YWxMZXZlbE9uRXJyb3IpIHtcbiAgICAgICAgaGxzLmxvYWRMZXZlbCA9IC0xO1xuICAgICAgfVxuICAgICAgY29uc3QgZnJhZ0Vycm9yVHlwZSA9IChfZGF0YSRmcmFnMiA9IGRhdGEuZnJhZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhJGZyYWcyLnR5cGU7XG4gICAgICAvLyBGaW5kIGFsdGVybmF0ZSBhdWRpbyBjb2RlYyBpZiBhdmFpbGFibGUgb24gYXVkaW8gY29kZWMgZXJyb3JcbiAgICAgIGNvbnN0IGlzQXVkaW9Db2RlY0Vycm9yID0gZnJhZ0Vycm9yVHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuQVVESU8gJiYgZXJyb3JEZXRhaWxzID09PSBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SIHx8IGRhdGEuc291cmNlQnVmZmVyTmFtZSA9PT0gJ2F1ZGlvJyAmJiAoZXJyb3JEZXRhaWxzID09PSBFcnJvckRldGFpbHMuQlVGRkVSX0FERF9DT0RFQ19FUlJPUiB8fCBlcnJvckRldGFpbHMgPT09IEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5EX0VSUk9SKTtcbiAgICAgIGNvbnN0IGZpbmRBdWRpb0NvZGVjQWx0ZXJuYXRlID0gaXNBdWRpb0NvZGVjRXJyb3IgJiYgbGV2ZWxzLnNvbWUoKHtcbiAgICAgICAgYXVkaW9Db2RlY1xuICAgICAgfSkgPT4gbGV2ZWwuYXVkaW9Db2RlYyAhPT0gYXVkaW9Db2RlYyk7XG4gICAgICAvLyBGaW5kIGFsdGVybmF0ZSB2aWRlbyBjb2RlYyBpZiBhdmFpbGFibGUgb24gdmlkZW8gY29kZWMgZXJyb3JcbiAgICAgIGNvbnN0IGlzVmlkZW9Db2RlY0Vycm9yID0gZGF0YS5zb3VyY2VCdWZmZXJOYW1lID09PSAndmlkZW8nICYmIChlcnJvckRldGFpbHMgPT09IEVycm9yRGV0YWlscy5CVUZGRVJfQUREX0NPREVDX0VSUk9SIHx8IGVycm9yRGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRfRVJST1IpO1xuICAgICAgY29uc3QgZmluZFZpZGVvQ29kZWNBbHRlcm5hdGUgPSBpc1ZpZGVvQ29kZWNFcnJvciAmJiBsZXZlbHMuc29tZSgoe1xuICAgICAgICBjb2RlY1NldCxcbiAgICAgICAgYXVkaW9Db2RlY1xuICAgICAgfSkgPT4gbGV2ZWwuY29kZWNTZXQgIT09IGNvZGVjU2V0ICYmIGxldmVsLmF1ZGlvQ29kZWMgPT09IGF1ZGlvQ29kZWMpO1xuICAgICAgY29uc3Qge1xuICAgICAgICB0eXBlOiBwbGF5bGlzdEVycm9yVHlwZSxcbiAgICAgICAgZ3JvdXBJZDogcGxheWxpc3RFcnJvckdyb3VwSWRcbiAgICAgIH0gPSAoX2RhdGEkY29udGV4dDIgPSBkYXRhLmNvbnRleHQpICE9IG51bGwgPyBfZGF0YSRjb250ZXh0MiA6IHt9O1xuICAgICAgZm9yIChsZXQgaSA9IGxldmVscy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gKGkgKyBsb2FkTGV2ZWwpICUgbGV2ZWxzLmxlbmd0aDtcbiAgICAgICAgaWYgKGNhbmRpZGF0ZSAhPT0gbG9hZExldmVsICYmIGNhbmRpZGF0ZSA+PSBtaW5BdXRvTGV2ZWwgJiYgY2FuZGlkYXRlIDw9IG1heEF1dG9MZXZlbCAmJiBsZXZlbHNbY2FuZGlkYXRlXS5sb2FkRXJyb3IgPT09IDApIHtcbiAgICAgICAgICB2YXIgX2xldmVsJGF1ZGlvR3JvdXBzLCBfbGV2ZWwkc3VidGl0bGVHcm91cHM7XG4gICAgICAgICAgY29uc3QgbGV2ZWxDYW5kaWRhdGUgPSBsZXZlbHNbY2FuZGlkYXRlXTtcbiAgICAgICAgICAvLyBTa2lwIGxldmVsIHN3aXRjaCBpZiBHQVAgdGFnIGlzIGZvdW5kIGluIG5leHQgbGV2ZWwgYXQgc2FtZSBwb3NpdGlvblxuICAgICAgICAgIGlmIChlcnJvckRldGFpbHMgPT09IEVycm9yRGV0YWlscy5GUkFHX0dBUCAmJiBmcmFnRXJyb3JUeXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOICYmIGRhdGEuZnJhZykge1xuICAgICAgICAgICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gbGV2ZWxzW2NhbmRpZGF0ZV0uZGV0YWlscztcbiAgICAgICAgICAgIGlmIChsZXZlbERldGFpbHMpIHtcbiAgICAgICAgICAgICAgY29uc3QgZnJhZ0NhbmRpZGF0ZSA9IGZpbmRGcmFnbWVudEJ5UFRTKGRhdGEuZnJhZywgbGV2ZWxEZXRhaWxzLmZyYWdtZW50cywgZGF0YS5mcmFnLnN0YXJ0KTtcbiAgICAgICAgICAgICAgaWYgKGZyYWdDYW5kaWRhdGUgIT0gbnVsbCAmJiBmcmFnQ2FuZGlkYXRlLmdhcCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChwbGF5bGlzdEVycm9yVHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSyAmJiBsZXZlbENhbmRpZGF0ZS5oYXNBdWRpb0dyb3VwKHBsYXlsaXN0RXJyb3JHcm91cElkKSB8fCBwbGF5bGlzdEVycm9yVHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSyAmJiBsZXZlbENhbmRpZGF0ZS5oYXNTdWJ0aXRsZUdyb3VwKHBsYXlsaXN0RXJyb3JHcm91cElkKSkge1xuICAgICAgICAgICAgLy8gRm9yIGF1ZGlvL3N1YnMgcGxheWxpc3QgZXJyb3JzIGZpbmQgYW5vdGhlciBncm91cCBJRCBvciBmYWxsdGhyb3VnaCB0byByZWR1bmRhbnQgZmFpbC1vdmVyXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZyYWdFcnJvclR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLkFVRElPICYmIChfbGV2ZWwkYXVkaW9Hcm91cHMgPSBsZXZlbC5hdWRpb0dyb3VwcykgIT0gbnVsbCAmJiBfbGV2ZWwkYXVkaW9Hcm91cHMuc29tZShncm91cElkID0+IGxldmVsQ2FuZGlkYXRlLmhhc0F1ZGlvR3JvdXAoZ3JvdXBJZCkpIHx8IGZyYWdFcnJvclR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLlNVQlRJVExFICYmIChfbGV2ZWwkc3VidGl0bGVHcm91cHMgPSBsZXZlbC5zdWJ0aXRsZUdyb3VwcykgIT0gbnVsbCAmJiBfbGV2ZWwkc3VidGl0bGVHcm91cHMuc29tZShncm91cElkID0+IGxldmVsQ2FuZGlkYXRlLmhhc1N1YnRpdGxlR3JvdXAoZ3JvdXBJZCkpIHx8IGZpbmRBdWRpb0NvZGVjQWx0ZXJuYXRlICYmIGxldmVsLmF1ZGlvQ29kZWMgPT09IGxldmVsQ2FuZGlkYXRlLmF1ZGlvQ29kZWMgfHwgIWZpbmRBdWRpb0NvZGVjQWx0ZXJuYXRlICYmIGxldmVsLmF1ZGlvQ29kZWMgIT09IGxldmVsQ2FuZGlkYXRlLmF1ZGlvQ29kZWMgfHwgZmluZFZpZGVvQ29kZWNBbHRlcm5hdGUgJiYgbGV2ZWwuY29kZWNTZXQgPT09IGxldmVsQ2FuZGlkYXRlLmNvZGVjU2V0KSB7XG4gICAgICAgICAgICAvLyBGb3IgdmlkZW8vYXVkaW8vc3VicyBmcmFnIGVycm9ycyBmaW5kIGFub3RoZXIgZ3JvdXAgSUQgb3IgZmFsbHRocm91Z2ggdG8gcmVkdW5kYW50IGZhaWwtb3ZlclxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHRMZXZlbCA9IGNhbmRpZGF0ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5leHRMZXZlbCA+IC0xICYmIGhscy5sb2FkTGV2ZWwgIT09IG5leHRMZXZlbCkge1xuICAgICAgICBkYXRhLmxldmVsUmV0cnkgPSB0cnVlO1xuICAgICAgICB0aGlzLnBsYXlsaXN0RXJyb3IgPSAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFjdGlvbjogTmV0d29ya0Vycm9yQWN0aW9uLlNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3gsXG4gICAgICAgICAgZmxhZ3M6IEVycm9yQWN0aW9uRmxhZ3MuTm9uZSxcbiAgICAgICAgICBuZXh0QXV0b0xldmVsOiBuZXh0TGV2ZWxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gTm8gbGV2ZWxzIHRvIHN3aXRjaCAvIE1hbnVhbCBsZXZlbCBzZWxlY3Rpb24gLyBMZXZlbCBub3QgZm91bmRcbiAgICAvLyBSZXNvbHZlIHdpdGggUGF0aHdheSBzd2l0Y2gsIFJlZHVuZGFudCBmYWlsLW92ZXIsIG9yIHN0YXkgb24gbG93ZXN0IExldmVsXG4gICAgcmV0dXJuIHtcbiAgICAgIGFjdGlvbjogTmV0d29ya0Vycm9yQWN0aW9uLlNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3gsXG4gICAgICBmbGFnczogRXJyb3JBY3Rpb25GbGFncy5Nb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nSG9zdFxuICAgIH07XG4gIH1cbiAgb25FcnJvck91dChldmVudCwgZGF0YSkge1xuICAgIHZhciBfZGF0YSRlcnJvckFjdGlvbjtcbiAgICBzd2l0Y2ggKChfZGF0YSRlcnJvckFjdGlvbiA9IGRhdGEuZXJyb3JBY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YSRlcnJvckFjdGlvbi5hY3Rpb24pIHtcbiAgICAgIGNhc2UgTmV0d29ya0Vycm9yQWN0aW9uLkRvTm90aGluZzpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE5ldHdvcmtFcnJvckFjdGlvbi5TZW5kQWx0ZXJuYXRlVG9QZW5hbHR5Qm94OlxuICAgICAgICB0aGlzLnNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3goZGF0YSk7XG4gICAgICAgIGlmICghZGF0YS5lcnJvckFjdGlvbi5yZXNvbHZlZCAmJiBkYXRhLmRldGFpbHMgIT09IEVycm9yRGV0YWlscy5GUkFHX0dBUCkge1xuICAgICAgICAgIGRhdGEuZmF0YWwgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKC9NZWRpYVNvdXJjZSByZWFkeVN0YXRlOiBlbmRlZC8udGVzdChkYXRhLmVycm9yLm1lc3NhZ2UpKSB7XG4gICAgICAgICAgdGhpcy53YXJuKGBNZWRpYVNvdXJjZSBlbmRlZCBhZnRlciBcIiR7ZGF0YS5zb3VyY2VCdWZmZXJOYW1lfVwiIHNvdXJjZUJ1ZmZlciBhcHBlbmQgZXJyb3IuIEF0dGVtcHRpbmcgdG8gcmVjb3ZlciBmcm9tIG1lZGlhIGVycm9yLmApO1xuICAgICAgICAgIHRoaXMuaGxzLnJlY292ZXJNZWRpYUVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE5ldHdvcmtFcnJvckFjdGlvbi5SZXRyeVJlcXVlc3Q6XG4gICAgICAgIC8vIGhhbmRsZWQgYnkgc3RyZWFtIGFuZCBwbGF5bGlzdC9sZXZlbCBjb250cm9sbGVyc1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGRhdGEuZmF0YWwpIHtcbiAgICAgIHRoaXMuaGxzLnN0b3BMb2FkKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIHNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3goZGF0YSkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGNvbnN0IGVycm9yQWN0aW9uID0gZGF0YS5lcnJvckFjdGlvbjtcbiAgICBpZiAoIWVycm9yQWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGZsYWdzLFxuICAgICAgaGRjcExldmVsLFxuICAgICAgbmV4dEF1dG9MZXZlbFxuICAgIH0gPSBlcnJvckFjdGlvbjtcbiAgICBzd2l0Y2ggKGZsYWdzKSB7XG4gICAgICBjYXNlIEVycm9yQWN0aW9uRmxhZ3MuTm9uZTpcbiAgICAgICAgdGhpcy5zd2l0Y2hMZXZlbChkYXRhLCBuZXh0QXV0b0xldmVsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVycm9yQWN0aW9uRmxhZ3MuTW92ZUFsbEFsdGVybmF0ZXNNYXRjaGluZ0hEQ1A6XG4gICAgICAgIGlmIChoZGNwTGV2ZWwpIHtcbiAgICAgICAgICBobHMubWF4SGRjcExldmVsID0gSGRjcExldmVsc1tIZGNwTGV2ZWxzLmluZGV4T2YoaGRjcExldmVsKSAtIDFdO1xuICAgICAgICAgIGVycm9yQWN0aW9uLnJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndhcm4oYFJlc3RyaWN0aW5nIHBsYXliYWNrIHRvIEhEQ1AtTEVWRUwgb2YgXCIke2hscy5tYXhIZGNwTGV2ZWx9XCIgb3IgbG93ZXJgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIElmIG5vdCByZXNvbHZlZCBieSBwcmV2aW91cyBhY3Rpb25zIHRyeSB0byBzd2l0Y2ggdG8gbmV4dCBsZXZlbFxuICAgIGlmICghZXJyb3JBY3Rpb24ucmVzb2x2ZWQpIHtcbiAgICAgIHRoaXMuc3dpdGNoTGV2ZWwoZGF0YSwgbmV4dEF1dG9MZXZlbCk7XG4gICAgfVxuICB9XG4gIHN3aXRjaExldmVsKGRhdGEsIGxldmVsSW5kZXgpIHtcbiAgICBpZiAobGV2ZWxJbmRleCAhPT0gdW5kZWZpbmVkICYmIGRhdGEuZXJyb3JBY3Rpb24pIHtcbiAgICAgIHRoaXMud2Fybihgc3dpdGNoaW5nIHRvIGxldmVsICR7bGV2ZWxJbmRleH0gYWZ0ZXIgJHtkYXRhLmRldGFpbHN9YCk7XG4gICAgICB0aGlzLmhscy5uZXh0QXV0b0xldmVsID0gbGV2ZWxJbmRleDtcbiAgICAgIGRhdGEuZXJyb3JBY3Rpb24ucmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgLy8gU3RyZWFtIGNvbnRyb2xsZXIgaXMgcmVzcG9uc2libGUgZm9yIHRoaXMgYnV0IHdvbid0IHN3aXRjaCBvbiBmYWxzZSBzdGFydFxuICAgICAgdGhpcy5obHMubmV4dExvYWRMZXZlbCA9IHRoaXMuaGxzLm5leHRBdXRvTGV2ZWw7XG4gICAgICBpZiAoZGF0YS5kZXRhaWxzID09PSBFcnJvckRldGFpbHMuQlVGRkVSX0FERF9DT0RFQ19FUlJPUiAmJiBkYXRhLm1pbWVUeXBlICYmIGRhdGEuc291cmNlQnVmZmVyTmFtZSAhPT0gJ2F1ZGlvdmlkZW8nKSB7XG4gICAgICAgIGNvbnN0IGNvZGVjID0gZ2V0Q29kZWNzRm9yTWltZVR5cGUoZGF0YS5taW1lVHlwZSk7XG4gICAgICAgIGNvbnN0IGxldmVscyA9IHRoaXMuaGxzLmxldmVscztcbiAgICAgICAgZm9yIChsZXQgaSA9IGxldmVscy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICBpZiAobGV2ZWxzW2ldW2Ake2RhdGEuc291cmNlQnVmZmVyTmFtZX1Db2RlY2BdID09PSBjb2RlYykge1xuICAgICAgICAgICAgdGhpcy5obHMucmVtb3ZlTGV2ZWwoaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVEb05vdGhpbmdFcnJvckFjdGlvbihyZXNvbHZlZCkge1xuICBjb25zdCBlcnJvckFjdGlvbiA9IHtcbiAgICBhY3Rpb246IE5ldHdvcmtFcnJvckFjdGlvbi5Eb05vdGhpbmcsXG4gICAgZmxhZ3M6IEVycm9yQWN0aW9uRmxhZ3MuTm9uZVxuICB9O1xuICBpZiAocmVzb2x2ZWQpIHtcbiAgICBlcnJvckFjdGlvbi5yZXNvbHZlZCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGVycm9yQWN0aW9uO1xufVxuXG52YXIgRnJhZ21lbnRTdGF0ZSA9IHtcbiAgTk9UX0xPQURFRDogXCJOT1RfTE9BREVEXCIsXG4gIEFQUEVORElORzogXCJBUFBFTkRJTkdcIixcbiAgUEFSVElBTDogXCJQQVJUSUFMXCIsXG4gIE9LOiBcIk9LXCJcbn07XG5jbGFzcyBGcmFnbWVudFRyYWNrZXIge1xuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICB0aGlzLmFjdGl2ZVBhcnRMaXN0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5lbmRMaXN0RnJhZ21lbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmZyYWdtZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy50aW1lUmFuZ2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmJ1ZmZlclBhZGRpbmcgPSAwLjI7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5oYXNHYXBzID0gZmFsc2U7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICBfcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9BUFBFTkRFRCwgdGhpcy5vbkJ1ZmZlckFwcGVuZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19MT0FERUQsIHRoaXMub25GcmFnTG9hZGVkLCB0aGlzKTtcbiAgfVxuICBfdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfQVBQRU5ERUQsIHRoaXMub25CdWZmZXJBcHBlbmRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19MT0FERUQsIHRoaXMub25GcmFnTG9hZGVkLCB0aGlzKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5mcmFnbWVudHMgPVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmFjdGl2ZVBhcnRMaXN0cyA9XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuZW5kTGlzdEZyYWdtZW50cyA9IHRoaXMudGltZVJhbmdlcyA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgRnJhZ21lbnQgb3IgUGFydCB3aXRoIGFuIGFwcGVuZGVkIHJhbmdlIHRoYXQgbWF0Y2hlcyB0aGUgcG9zaXRpb24gYW5kIGxldmVsVHlwZVxuICAgKiBPdGhlcndpc2UsIHJldHVybiBudWxsXG4gICAqL1xuICBnZXRBcHBlbmRlZEZyYWcocG9zaXRpb24sIGxldmVsVHlwZSkge1xuICAgIGNvbnN0IGFjdGl2ZVBhcnRzID0gdGhpcy5hY3RpdmVQYXJ0TGlzdHNbbGV2ZWxUeXBlXTtcbiAgICBpZiAoYWN0aXZlUGFydHMpIHtcbiAgICAgIGZvciAobGV0IGkgPSBhY3RpdmVQYXJ0cy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgY29uc3QgYWN0aXZlUGFydCA9IGFjdGl2ZVBhcnRzW2ldO1xuICAgICAgICBpZiAoIWFjdGl2ZVBhcnQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcHBlbmRlZFBUUyA9IGFjdGl2ZVBhcnQuZW5kO1xuICAgICAgICBpZiAoYWN0aXZlUGFydC5zdGFydCA8PSBwb3NpdGlvbiAmJiBhcHBlbmRlZFBUUyAhPT0gbnVsbCAmJiBwb3NpdGlvbiA8PSBhcHBlbmRlZFBUUykge1xuICAgICAgICAgIHJldHVybiBhY3RpdmVQYXJ0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcmVkRnJhZyhwb3NpdGlvbiwgbGV2ZWxUeXBlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBidWZmZXJlZCBGcmFnbWVudCB0aGF0IG1hdGNoZXMgdGhlIHBvc2l0aW9uIGFuZCBsZXZlbFR5cGUuXG4gICAqIEEgYnVmZmVyZWQgRnJhZ21lbnQgaXMgb25lIHdob3NlIGxvYWRpbmcsIHBhcnNpbmcgYW5kIGFwcGVuZGluZyBpcyBkb25lIChjb21wbGV0ZWQgb3IgXCJwYXJ0aWFsXCIgbWVhbmluZyBhYm9ydGVkKS5cbiAgICogSWYgbm90IGZvdW5kIGFueSBGcmFnbWVudCwgcmV0dXJuIG51bGxcbiAgICovXG4gIGdldEJ1ZmZlcmVkRnJhZyhwb3NpdGlvbiwgbGV2ZWxUeXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RnJhZ0F0UG9zKHBvc2l0aW9uLCBsZXZlbFR5cGUsIHRydWUpO1xuICB9XG4gIGdldEZyYWdBdFBvcyhwb3NpdGlvbiwgbGV2ZWxUeXBlLCBidWZmZXJlZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWdtZW50c1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudHMpO1xuICAgIGZvciAobGV0IGkgPSBrZXlzLmxlbmd0aDsgaS0tOykge1xuICAgICAgY29uc3QgZnJhZ21lbnRFbnRpdHkgPSBmcmFnbWVudHNba2V5c1tpXV07XG4gICAgICBpZiAoKGZyYWdtZW50RW50aXR5ID09IG51bGwgPyB2b2lkIDAgOiBmcmFnbWVudEVudGl0eS5ib2R5LnR5cGUpID09PSBsZXZlbFR5cGUgJiYgKCFidWZmZXJlZCB8fCBmcmFnbWVudEVudGl0eS5idWZmZXJlZCkpIHtcbiAgICAgICAgY29uc3QgZnJhZyA9IGZyYWdtZW50RW50aXR5LmJvZHk7XG4gICAgICAgIGlmIChmcmFnLnN0YXJ0IDw9IHBvc2l0aW9uICYmIHBvc2l0aW9uIDw9IGZyYWcuZW5kKSB7XG4gICAgICAgICAgcmV0dXJuIGZyYWc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUGFydGlhbCBmcmFnbWVudHMgZWZmZWN0ZWQgYnkgY29kZWQgZnJhbWUgZXZpY3Rpb24gd2lsbCBiZSByZW1vdmVkXG4gICAqIFRoZSBicm93c2VyIHdpbGwgdW5sb2FkIHBhcnRzIG9mIHRoZSBidWZmZXIgdG8gZnJlZSB1cCBtZW1vcnkgZm9yIG5ldyBidWZmZXIgZGF0YVxuICAgKiBGcmFnbWVudHMgd2lsbCBuZWVkIHRvIGJlIHJlbG9hZGVkIHdoZW4gdGhlIGJ1ZmZlciBpcyBmcmVlZCB1cCwgcmVtb3ZpbmcgcGFydGlhbCBmcmFnbWVudHMgd2lsbCBhbGxvdyB0aGVtIHRvIHJlbG9hZChzaW5jZSB0aGVyZSBtaWdodCBiZSBwYXJ0cyB0aGF0IGFyZSBzdGlsbCBwbGF5YWJsZSlcbiAgICovXG4gIGRldGVjdEV2aWN0ZWRGcmFnbWVudHMoZWxlbWVudGFyeVN0cmVhbSwgdGltZVJhbmdlLCBwbGF5bGlzdFR5cGUsIGFwcGVuZGVkUGFydCwgcmVtb3ZlQXBwZW5kaW5nKSB7XG4gICAgaWYgKHRoaXMudGltZVJhbmdlcykge1xuICAgICAgdGhpcy50aW1lUmFuZ2VzW2VsZW1lbnRhcnlTdHJlYW1dID0gdGltZVJhbmdlO1xuICAgIH1cbiAgICAvLyBDaGVjayBpZiBhbnkgZmxhZ2dlZCBmcmFnbWVudHMgaGF2ZSBiZWVuIHVubG9hZGVkXG4gICAgLy8gZXhjbHVkaW5nIGFueXRoaW5nIG5ld2VyIHRoYW4gYXBwZW5kZWRQYXJ0U25cbiAgICBjb25zdCBhcHBlbmRlZFBhcnRTbiA9IChhcHBlbmRlZFBhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IGFwcGVuZGVkUGFydC5mcmFnbWVudC5zbikgfHwgLTE7XG4gICAgT2JqZWN0LmtleXModGhpcy5mcmFnbWVudHMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGNvbnN0IGZyYWdtZW50RW50aXR5ID0gdGhpcy5mcmFnbWVudHNba2V5XTtcbiAgICAgIGlmICghZnJhZ21lbnRFbnRpdHkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGFwcGVuZGVkUGFydFNuID49IGZyYWdtZW50RW50aXR5LmJvZHkuc24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFmcmFnbWVudEVudGl0eS5idWZmZXJlZCAmJiAoIWZyYWdtZW50RW50aXR5LmxvYWRlZCB8fCByZW1vdmVBcHBlbmRpbmcpKSB7XG4gICAgICAgIGlmIChmcmFnbWVudEVudGl0eS5ib2R5LnR5cGUgPT09IHBsYXlsaXN0VHlwZSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlRnJhZ21lbnQoZnJhZ21lbnRFbnRpdHkuYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZXNEYXRhID0gZnJhZ21lbnRFbnRpdHkucmFuZ2VbZWxlbWVudGFyeVN0cmVhbV07XG4gICAgICBpZiAoIWVzRGF0YSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXNEYXRhLnRpbWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRnJhZ21lbnQoZnJhZ21lbnRFbnRpdHkuYm9keSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVzRGF0YS50aW1lLnNvbWUodGltZSA9PiB7XG4gICAgICAgIGNvbnN0IGlzTm90QnVmZmVyZWQgPSAhdGhpcy5pc1RpbWVCdWZmZXJlZCh0aW1lLnN0YXJ0UFRTLCB0aW1lLmVuZFBUUywgdGltZVJhbmdlKTtcbiAgICAgICAgaWYgKGlzTm90QnVmZmVyZWQpIHtcbiAgICAgICAgICAvLyBVbnJlZ2lzdGVyIHBhcnRpYWwgZnJhZ21lbnQgYXMgaXQgbmVlZHMgdG8gbG9hZCBhZ2FpbiB0byBiZSByZXVzZWRcbiAgICAgICAgICB0aGlzLnJlbW92ZUZyYWdtZW50KGZyYWdtZW50RW50aXR5LmJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc05vdEJ1ZmZlcmVkO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBmcmFnbWVudCBwYXNzZWQgaW4gaXMgbG9hZGVkIGluIHRoZSBidWZmZXIgcHJvcGVybHlcbiAgICogUGFydGlhbGx5IGxvYWRlZCBmcmFnbWVudHMgd2lsbCBiZSByZWdpc3RlcmVkIGFzIGEgcGFydGlhbCBmcmFnbWVudFxuICAgKi9cbiAgZGV0ZWN0UGFydGlhbEZyYWdtZW50cyhkYXRhKSB7XG4gICAgY29uc3QgdGltZVJhbmdlcyA9IHRoaXMudGltZVJhbmdlcztcbiAgICBpZiAoIXRpbWVSYW5nZXMgfHwgZGF0YS5mcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgY29uc3QgZnJhZ0tleSA9IGdldEZyYWdtZW50S2V5KGZyYWcpO1xuICAgIGNvbnN0IGZyYWdtZW50RW50aXR5ID0gdGhpcy5mcmFnbWVudHNbZnJhZ0tleV07XG4gICAgaWYgKCFmcmFnbWVudEVudGl0eSB8fCBmcmFnbWVudEVudGl0eS5idWZmZXJlZCAmJiBmcmFnLmdhcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpc0ZyYWdIaW50ID0gIWZyYWcucmVsdXJsO1xuICAgIE9iamVjdC5rZXlzKHRpbWVSYW5nZXMpLmZvckVhY2goZWxlbWVudGFyeVN0cmVhbSA9PiB7XG4gICAgICBjb25zdCBzdHJlYW1JbmZvID0gZnJhZy5lbGVtZW50YXJ5U3RyZWFtc1tlbGVtZW50YXJ5U3RyZWFtXTtcbiAgICAgIGlmICghc3RyZWFtSW5mbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB0aW1lUmFuZ2UgPSB0aW1lUmFuZ2VzW2VsZW1lbnRhcnlTdHJlYW1dO1xuICAgICAgY29uc3QgcGFydGlhbCA9IGlzRnJhZ0hpbnQgfHwgc3RyZWFtSW5mby5wYXJ0aWFsID09PSB0cnVlO1xuICAgICAgZnJhZ21lbnRFbnRpdHkucmFuZ2VbZWxlbWVudGFyeVN0cmVhbV0gPSB0aGlzLmdldEJ1ZmZlcmVkVGltZXMoZnJhZywgZGF0YS5wYXJ0LCBwYXJ0aWFsLCB0aW1lUmFuZ2UpO1xuICAgIH0pO1xuICAgIGZyYWdtZW50RW50aXR5LmxvYWRlZCA9IG51bGw7XG4gICAgaWYgKE9iamVjdC5rZXlzKGZyYWdtZW50RW50aXR5LnJhbmdlKS5sZW5ndGgpIHtcbiAgICAgIGZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkID0gdHJ1ZTtcbiAgICAgIGNvbnN0IGVuZExpc3QgPSBmcmFnbWVudEVudGl0eS5ib2R5LmVuZExpc3QgPSBmcmFnLmVuZExpc3QgfHwgZnJhZ21lbnRFbnRpdHkuYm9keS5lbmRMaXN0O1xuICAgICAgaWYgKGVuZExpc3QpIHtcbiAgICAgICAgdGhpcy5lbmRMaXN0RnJhZ21lbnRzW2ZyYWdtZW50RW50aXR5LmJvZHkudHlwZV0gPSBmcmFnbWVudEVudGl0eTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNQYXJ0aWFsKGZyYWdtZW50RW50aXR5KSkge1xuICAgICAgICAvLyBSZW1vdmUgb2xkZXIgZnJhZ21lbnQgcGFydHMgZnJvbSBsb29rdXAgYWZ0ZXIgZnJhZyBpcyB0cmFja2VkIGFzIGJ1ZmZlcmVkXG4gICAgICAgIHRoaXMucmVtb3ZlUGFydHMoZnJhZy5zbiAtIDEsIGZyYWcudHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlbW92ZSBmcmFnbWVudCBpZiBub3RoaW5nIHdhcyBhcHBlbmRlZFxuICAgICAgdGhpcy5yZW1vdmVGcmFnbWVudChmcmFnbWVudEVudGl0eS5ib2R5KTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlUGFydHMoc25Ub0tlZXAsIGxldmVsVHlwZSkge1xuICAgIGNvbnN0IGFjdGl2ZVBhcnRzID0gdGhpcy5hY3RpdmVQYXJ0TGlzdHNbbGV2ZWxUeXBlXTtcbiAgICBpZiAoIWFjdGl2ZVBhcnRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlUGFydExpc3RzW2xldmVsVHlwZV0gPSBmaWx0ZXJQYXJ0cyhhY3RpdmVQYXJ0cywgcGFydCA9PiBwYXJ0LmZyYWdtZW50LnNuID49IHNuVG9LZWVwKTtcbiAgfVxuICBmcmFnQnVmZmVyZWQoZnJhZywgZm9yY2UpIHtcbiAgICBjb25zdCBmcmFnS2V5ID0gZ2V0RnJhZ21lbnRLZXkoZnJhZyk7XG4gICAgbGV0IGZyYWdtZW50RW50aXR5ID0gdGhpcy5mcmFnbWVudHNbZnJhZ0tleV07XG4gICAgaWYgKCFmcmFnbWVudEVudGl0eSAmJiBmb3JjZSkge1xuICAgICAgZnJhZ21lbnRFbnRpdHkgPSB0aGlzLmZyYWdtZW50c1tmcmFnS2V5XSA9IHtcbiAgICAgICAgYm9keTogZnJhZyxcbiAgICAgICAgYXBwZW5kZWRQVFM6IG51bGwsXG4gICAgICAgIGxvYWRlZDogbnVsbCxcbiAgICAgICAgYnVmZmVyZWQ6IGZhbHNlLFxuICAgICAgICByYW5nZTogT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgICAgfTtcbiAgICAgIGlmIChmcmFnLmdhcCkge1xuICAgICAgICB0aGlzLmhhc0dhcHMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZnJhZ21lbnRFbnRpdHkpIHtcbiAgICAgIGZyYWdtZW50RW50aXR5LmxvYWRlZCA9IG51bGw7XG4gICAgICBmcmFnbWVudEVudGl0eS5idWZmZXJlZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIGdldEJ1ZmZlcmVkVGltZXMoZnJhZ21lbnQsIHBhcnQsIHBhcnRpYWwsIHRpbWVSYW5nZSkge1xuICAgIGNvbnN0IGJ1ZmZlcmVkID0ge1xuICAgICAgdGltZTogW10sXG4gICAgICBwYXJ0aWFsXG4gICAgfTtcbiAgICBjb25zdCBzdGFydFBUUyA9IGZyYWdtZW50LnN0YXJ0O1xuICAgIGNvbnN0IGVuZFBUUyA9IGZyYWdtZW50LmVuZDtcbiAgICBjb25zdCBtaW5FbmRQVFMgPSBmcmFnbWVudC5taW5FbmRQVFMgfHwgZW5kUFRTO1xuICAgIGNvbnN0IG1heFN0YXJ0UFRTID0gZnJhZ21lbnQubWF4U3RhcnRQVFMgfHwgc3RhcnRQVFM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aW1lUmFuZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHRpbWVSYW5nZS5zdGFydChpKSAtIHRoaXMuYnVmZmVyUGFkZGluZztcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSB0aW1lUmFuZ2UuZW5kKGkpICsgdGhpcy5idWZmZXJQYWRkaW5nO1xuICAgICAgaWYgKG1heFN0YXJ0UFRTID49IHN0YXJ0VGltZSAmJiBtaW5FbmRQVFMgPD0gZW5kVGltZSkge1xuICAgICAgICAvLyBGcmFnbWVudCBpcyBlbnRpcmVseSBjb250YWluZWQgaW4gYnVmZmVyXG4gICAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgdGhlIG90aGVyIHRpbWVSYW5nZSB0aW1lcyBzaW5jZSBpdCdzIGNvbXBsZXRlbHkgcGxheWFibGVcbiAgICAgICAgYnVmZmVyZWQudGltZS5wdXNoKHtcbiAgICAgICAgICBzdGFydFBUUzogTWF0aC5tYXgoc3RhcnRQVFMsIHRpbWVSYW5nZS5zdGFydChpKSksXG4gICAgICAgICAgZW5kUFRTOiBNYXRoLm1pbihlbmRQVFMsIHRpbWVSYW5nZS5lbmQoaSkpXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnRQVFMgPCBlbmRUaW1lICYmIGVuZFBUUyA+IHN0YXJ0VGltZSkge1xuICAgICAgICBjb25zdCBzdGFydCA9IE1hdGgubWF4KHN0YXJ0UFRTLCB0aW1lUmFuZ2Uuc3RhcnQoaSkpO1xuICAgICAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihlbmRQVFMsIHRpbWVSYW5nZS5lbmQoaSkpO1xuICAgICAgICBpZiAoZW5kID4gc3RhcnQpIHtcbiAgICAgICAgICBidWZmZXJlZC5wYXJ0aWFsID0gdHJ1ZTtcbiAgICAgICAgICAvLyBDaGVjayBmb3IgaW50ZXJzZWN0aW9uIHdpdGggYnVmZmVyXG4gICAgICAgICAgLy8gR2V0IHBsYXlhYmxlIHNlY3Rpb25zIG9mIHRoZSBmcmFnbWVudFxuICAgICAgICAgIGJ1ZmZlcmVkLnRpbWUucHVzaCh7XG4gICAgICAgICAgICBzdGFydFBUUzogc3RhcnQsXG4gICAgICAgICAgICBlbmRQVFM6IGVuZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVuZFBUUyA8PSBzdGFydFRpbWUpIHtcbiAgICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayB0aGUgcmVzdCBvZiB0aGUgdGltZVJhbmdlIGFzIGl0IGlzIGluIG9yZGVyXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyZWQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgcGFydGlhbCBmcmFnbWVudCBmb3IgYSBjZXJ0YWluIHRpbWVcbiAgICovXG4gIGdldFBhcnRpYWxGcmFnbWVudCh0aW1lKSB7XG4gICAgbGV0IGJlc3RGcmFnbWVudCA9IG51bGw7XG4gICAgbGV0IHRpbWVQYWRkaW5nO1xuICAgIGxldCBzdGFydFRpbWU7XG4gICAgbGV0IGVuZFRpbWU7XG4gICAgbGV0IGJlc3RPdmVybGFwID0gMDtcbiAgICBjb25zdCB7XG4gICAgICBidWZmZXJQYWRkaW5nLFxuICAgICAgZnJhZ21lbnRzXG4gICAgfSA9IHRoaXM7XG4gICAgT2JqZWN0LmtleXMoZnJhZ21lbnRzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBmcmFnbWVudEVudGl0eSA9IGZyYWdtZW50c1trZXldO1xuICAgICAgaWYgKCFmcmFnbWVudEVudGl0eSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNQYXJ0aWFsKGZyYWdtZW50RW50aXR5KSkge1xuICAgICAgICBzdGFydFRpbWUgPSBmcmFnbWVudEVudGl0eS5ib2R5LnN0YXJ0IC0gYnVmZmVyUGFkZGluZztcbiAgICAgICAgZW5kVGltZSA9IGZyYWdtZW50RW50aXR5LmJvZHkuZW5kICsgYnVmZmVyUGFkZGluZztcbiAgICAgICAgaWYgKHRpbWUgPj0gc3RhcnRUaW1lICYmIHRpbWUgPD0gZW5kVGltZSkge1xuICAgICAgICAgIC8vIFVzZSB0aGUgZnJhZ21lbnQgdGhhdCBoYXMgdGhlIG1vc3QgcGFkZGluZyBmcm9tIHN0YXJ0IGFuZCBlbmQgdGltZVxuICAgICAgICAgIHRpbWVQYWRkaW5nID0gTWF0aC5taW4odGltZSAtIHN0YXJ0VGltZSwgZW5kVGltZSAtIHRpbWUpO1xuICAgICAgICAgIGlmIChiZXN0T3ZlcmxhcCA8PSB0aW1lUGFkZGluZykge1xuICAgICAgICAgICAgYmVzdEZyYWdtZW50ID0gZnJhZ21lbnRFbnRpdHkuYm9keTtcbiAgICAgICAgICAgIGJlc3RPdmVybGFwID0gdGltZVBhZGRpbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGJlc3RGcmFnbWVudDtcbiAgfVxuICBpc0VuZExpc3RBcHBlbmRlZCh0eXBlKSB7XG4gICAgY29uc3QgbGFzdEZyYWdtZW50RW50aXR5ID0gdGhpcy5lbmRMaXN0RnJhZ21lbnRzW3R5cGVdO1xuICAgIHJldHVybiBsYXN0RnJhZ21lbnRFbnRpdHkgIT09IHVuZGVmaW5lZCAmJiAobGFzdEZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkIHx8IGlzUGFydGlhbChsYXN0RnJhZ21lbnRFbnRpdHkpKTtcbiAgfVxuICBnZXRTdGF0ZShmcmFnbWVudCkge1xuICAgIGNvbnN0IGZyYWdLZXkgPSBnZXRGcmFnbWVudEtleShmcmFnbWVudCk7XG4gICAgY29uc3QgZnJhZ21lbnRFbnRpdHkgPSB0aGlzLmZyYWdtZW50c1tmcmFnS2V5XTtcbiAgICBpZiAoZnJhZ21lbnRFbnRpdHkpIHtcbiAgICAgIGlmICghZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQpIHtcbiAgICAgICAgcmV0dXJuIEZyYWdtZW50U3RhdGUuQVBQRU5ESU5HO1xuICAgICAgfSBlbHNlIGlmIChpc1BhcnRpYWwoZnJhZ21lbnRFbnRpdHkpKSB7XG4gICAgICAgIHJldHVybiBGcmFnbWVudFN0YXRlLlBBUlRJQUw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gRnJhZ21lbnRTdGF0ZS5PSztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEZyYWdtZW50U3RhdGUuTk9UX0xPQURFRDtcbiAgfVxuICBpc1RpbWVCdWZmZXJlZChzdGFydFBUUywgZW5kUFRTLCB0aW1lUmFuZ2UpIHtcbiAgICBsZXQgc3RhcnRUaW1lO1xuICAgIGxldCBlbmRUaW1lO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGltZVJhbmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzdGFydFRpbWUgPSB0aW1lUmFuZ2Uuc3RhcnQoaSkgLSB0aGlzLmJ1ZmZlclBhZGRpbmc7XG4gICAgICBlbmRUaW1lID0gdGltZVJhbmdlLmVuZChpKSArIHRoaXMuYnVmZmVyUGFkZGluZztcbiAgICAgIGlmIChzdGFydFBUUyA+PSBzdGFydFRpbWUgJiYgZW5kUFRTIDw9IGVuZFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoZW5kUFRTIDw9IHN0YXJ0VGltZSkge1xuICAgICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIHRoZSByZXN0IG9mIHRoZSB0aW1lUmFuZ2UgYXMgaXQgaXMgaW4gb3JkZXJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgdGhpcy5yZW1vdmVBbGxGcmFnbWVudHMoKTtcbiAgfVxuICBvbkZyYWdMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAvLyBkb24ndCB0cmFjayBpbml0c2VnbWVudCAoZm9yIHdoaWNoIHNuIGlzIG5vdCBhIG51bWJlcilcbiAgICAvLyBkb24ndCB0cmFjayBmcmFncyB1c2VkIGZvciBiaXRyYXRlVGVzdCwgdGhleSdyZSBpcnJlbGV2YW50LlxuICAgIGlmIChkYXRhLmZyYWcuc24gPT09ICdpbml0U2VnbWVudCcgfHwgZGF0YS5mcmFnLmJpdHJhdGVUZXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgLy8gRnJhZ21lbnQgZW50aXR5IGBsb2FkZWRgIEZyYWdMb2FkZWREYXRhIGlzIG51bGwgd2hlbiBsb2FkaW5nIHBhcnRzXG4gICAgY29uc3QgbG9hZGVkID0gZGF0YS5wYXJ0ID8gbnVsbCA6IGRhdGE7XG4gICAgY29uc3QgZnJhZ0tleSA9IGdldEZyYWdtZW50S2V5KGZyYWcpO1xuICAgIHRoaXMuZnJhZ21lbnRzW2ZyYWdLZXldID0ge1xuICAgICAgYm9keTogZnJhZyxcbiAgICAgIGFwcGVuZGVkUFRTOiBudWxsLFxuICAgICAgbG9hZGVkLFxuICAgICAgYnVmZmVyZWQ6IGZhbHNlLFxuICAgICAgcmFuZ2U6IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICB9O1xuICB9XG4gIG9uQnVmZmVyQXBwZW5kZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnLFxuICAgICAgcGFydCxcbiAgICAgIHRpbWVSYW5nZXMsXG4gICAgICB0eXBlXG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKGZyYWcuc24gPT09ICdpbml0U2VnbWVudCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGxheWxpc3RUeXBlID0gZnJhZy50eXBlO1xuICAgIGlmIChwYXJ0KSB7XG4gICAgICBsZXQgYWN0aXZlUGFydHMgPSB0aGlzLmFjdGl2ZVBhcnRMaXN0c1twbGF5bGlzdFR5cGVdO1xuICAgICAgaWYgKCFhY3RpdmVQYXJ0cykge1xuICAgICAgICB0aGlzLmFjdGl2ZVBhcnRMaXN0c1twbGF5bGlzdFR5cGVdID0gYWN0aXZlUGFydHMgPSBbXTtcbiAgICAgIH1cbiAgICAgIGFjdGl2ZVBhcnRzLnB1c2gocGFydCk7XG4gICAgfVxuICAgIC8vIFN0b3JlIHRoZSBsYXRlc3QgdGltZVJhbmdlcyBsb2FkZWQgaW4gdGhlIGJ1ZmZlclxuICAgIHRoaXMudGltZVJhbmdlcyA9IHRpbWVSYW5nZXM7XG4gICAgY29uc3QgdGltZVJhbmdlID0gdGltZVJhbmdlc1t0eXBlXTtcbiAgICB0aGlzLmRldGVjdEV2aWN0ZWRGcmFnbWVudHModHlwZSwgdGltZVJhbmdlLCBwbGF5bGlzdFR5cGUsIHBhcnQpO1xuICB9XG4gIG9uRnJhZ0J1ZmZlcmVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5kZXRlY3RQYXJ0aWFsRnJhZ21lbnRzKGRhdGEpO1xuICB9XG4gIGhhc0ZyYWdtZW50KGZyYWdtZW50KSB7XG4gICAgY29uc3QgZnJhZ0tleSA9IGdldEZyYWdtZW50S2V5KGZyYWdtZW50KTtcbiAgICByZXR1cm4gISF0aGlzLmZyYWdtZW50c1tmcmFnS2V5XTtcbiAgfVxuICBoYXNGcmFnbWVudHModHlwZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWdtZW50c1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudHMpO1xuICAgIGlmICghdHlwZSkge1xuICAgICAgcmV0dXJuIGtleXMubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IGtleXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICBjb25zdCBmcmFnbWVudEVudGl0eSA9IGZyYWdtZW50c1trZXlzW2ldXTtcbiAgICAgIGlmICgoZnJhZ21lbnRFbnRpdHkgPT0gbnVsbCA/IHZvaWQgMCA6IGZyYWdtZW50RW50aXR5LmJvZHkudHlwZSkgPT09IHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBoYXNQYXJ0cyh0eXBlKSB7XG4gICAgdmFyIF90aGlzJGFjdGl2ZVBhcnRMaXN0cztcbiAgICByZXR1cm4gISEoKF90aGlzJGFjdGl2ZVBhcnRMaXN0cyA9IHRoaXMuYWN0aXZlUGFydExpc3RzW3R5cGVdKSAhPSBudWxsICYmIF90aGlzJGFjdGl2ZVBhcnRMaXN0cy5sZW5ndGgpO1xuICB9XG4gIHJlbW92ZUZyYWdtZW50c0luUmFuZ2Uoc3RhcnQsIGVuZCwgcGxheWxpc3RUeXBlLCB3aXRoR2FwT25seSwgdW5idWZmZXJlZE9ubHkpIHtcbiAgICBpZiAod2l0aEdhcE9ubHkgJiYgIXRoaXMuaGFzR2Fwcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyh0aGlzLmZyYWdtZW50cykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgY29uc3QgZnJhZ21lbnRFbnRpdHkgPSB0aGlzLmZyYWdtZW50c1trZXldO1xuICAgICAgaWYgKCFmcmFnbWVudEVudGl0eSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBmcmFnID0gZnJhZ21lbnRFbnRpdHkuYm9keTtcbiAgICAgIGlmIChmcmFnLnR5cGUgIT09IHBsYXlsaXN0VHlwZSB8fCB3aXRoR2FwT25seSAmJiAhZnJhZy5nYXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGZyYWcuc3RhcnQgPCBlbmQgJiYgZnJhZy5lbmQgPiBzdGFydCAmJiAoZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQgfHwgdW5idWZmZXJlZE9ubHkpKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmVtb3ZlRnJhZ21lbnQoZnJhZ21lbnQpIHtcbiAgICBjb25zdCBmcmFnS2V5ID0gZ2V0RnJhZ21lbnRLZXkoZnJhZ21lbnQpO1xuICAgIGZyYWdtZW50LmNsZWFyRWxlbWVudGFyeVN0cmVhbUluZm8oKTtcbiAgICBjb25zdCBhY3RpdmVQYXJ0cyA9IHRoaXMuYWN0aXZlUGFydExpc3RzW2ZyYWdtZW50LnR5cGVdO1xuICAgIGlmIChhY3RpdmVQYXJ0cykge1xuICAgICAgY29uc3Qgc25Ub1JlbW92ZSA9IGZyYWdtZW50LnNuO1xuICAgICAgdGhpcy5hY3RpdmVQYXJ0TGlzdHNbZnJhZ21lbnQudHlwZV0gPSBmaWx0ZXJQYXJ0cyhhY3RpdmVQYXJ0cywgcGFydCA9PiBwYXJ0LmZyYWdtZW50LnNuICE9PSBzblRvUmVtb3ZlKTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuZnJhZ21lbnRzW2ZyYWdLZXldO1xuICAgIGlmIChmcmFnbWVudC5lbmRMaXN0KSB7XG4gICAgICBkZWxldGUgdGhpcy5lbmRMaXN0RnJhZ21lbnRzW2ZyYWdtZW50LnR5cGVdO1xuICAgIH1cbiAgfVxuICByZW1vdmVBbGxGcmFnbWVudHMoKSB7XG4gICAgdmFyIF90aGlzJGhscywgX3RoaXMkaGxzJGxhdGVzdExldmVsO1xuICAgIHRoaXMuZnJhZ21lbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmVuZExpc3RGcmFnbWVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuYWN0aXZlUGFydExpc3RzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmhhc0dhcHMgPSBmYWxzZTtcbiAgICBjb25zdCBwYXJ0bGlzdCA9IChfdGhpcyRobHMgPSB0aGlzLmhscykgPT0gbnVsbCA/IHZvaWQgMCA6IChfdGhpcyRobHMkbGF0ZXN0TGV2ZWwgPSBfdGhpcyRobHMubGF0ZXN0TGV2ZWxEZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkaGxzJGxhdGVzdExldmVsLnBhcnRMaXN0O1xuICAgIGlmIChwYXJ0bGlzdCkge1xuICAgICAgcGFydGxpc3QuZm9yRWFjaChwYXJ0ID0+IHBhcnQuY2xlYXJFbGVtZW50YXJ5U3RyZWFtSW5mbygpKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGlzUGFydGlhbChmcmFnbWVudEVudGl0eSkge1xuICB2YXIgX2ZyYWdtZW50RW50aXR5JHJhbmdlLCBfZnJhZ21lbnRFbnRpdHkkcmFuZ2UyLCBfZnJhZ21lbnRFbnRpdHkkcmFuZ2UzO1xuICByZXR1cm4gZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQgJiYgKGZyYWdtZW50RW50aXR5LmJvZHkuZ2FwIHx8ICgoX2ZyYWdtZW50RW50aXR5JHJhbmdlID0gZnJhZ21lbnRFbnRpdHkucmFuZ2UudmlkZW8pID09IG51bGwgPyB2b2lkIDAgOiBfZnJhZ21lbnRFbnRpdHkkcmFuZ2UucGFydGlhbCkgfHwgKChfZnJhZ21lbnRFbnRpdHkkcmFuZ2UyID0gZnJhZ21lbnRFbnRpdHkucmFuZ2UuYXVkaW8pID09IG51bGwgPyB2b2lkIDAgOiBfZnJhZ21lbnRFbnRpdHkkcmFuZ2UyLnBhcnRpYWwpIHx8ICgoX2ZyYWdtZW50RW50aXR5JHJhbmdlMyA9IGZyYWdtZW50RW50aXR5LnJhbmdlLmF1ZGlvdmlkZW8pID09IG51bGwgPyB2b2lkIDAgOiBfZnJhZ21lbnRFbnRpdHkkcmFuZ2UzLnBhcnRpYWwpKTtcbn1cbmZ1bmN0aW9uIGdldEZyYWdtZW50S2V5KGZyYWdtZW50KSB7XG4gIHJldHVybiBgJHtmcmFnbWVudC50eXBlfV8ke2ZyYWdtZW50LmxldmVsfV8ke2ZyYWdtZW50LnNufWA7XG59XG5mdW5jdGlvbiBmaWx0ZXJQYXJ0cyhwYXJ0TGlzdCwgcHJlZGljYXRlKSB7XG4gIHJldHVybiBwYXJ0TGlzdC5maWx0ZXIocGFydCA9PiB7XG4gICAgY29uc3Qga2VlcCA9IHByZWRpY2F0ZShwYXJ0KTtcbiAgICBpZiAoIWtlZXApIHtcbiAgICAgIHBhcnQuY2xlYXJFbGVtZW50YXJ5U3RyZWFtSW5mbygpO1xuICAgIH1cbiAgICByZXR1cm4ga2VlcDtcbiAgfSk7XG59XG5cbnZhciBEZWNyeXB0ZXJBZXNNb2RlID0ge1xuICBjYmM6IDAsXG4gIGN0cjogMVxufTtcblxuY2xhc3MgQUVTQ3J5cHRvIHtcbiAgY29uc3RydWN0b3Ioc3VidGxlLCBpdiwgYWVzTW9kZSkge1xuICAgIHRoaXMuc3VidGxlID0gdm9pZCAwO1xuICAgIHRoaXMuYWVzSVYgPSB2b2lkIDA7XG4gICAgdGhpcy5hZXNNb2RlID0gdm9pZCAwO1xuICAgIHRoaXMuc3VidGxlID0gc3VidGxlO1xuICAgIHRoaXMuYWVzSVYgPSBpdjtcbiAgICB0aGlzLmFlc01vZGUgPSBhZXNNb2RlO1xuICB9XG4gIGRlY3J5cHQoZGF0YSwga2V5KSB7XG4gICAgc3dpdGNoICh0aGlzLmFlc01vZGUpIHtcbiAgICAgIGNhc2UgRGVjcnlwdGVyQWVzTW9kZS5jYmM6XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnRsZS5kZWNyeXB0KHtcbiAgICAgICAgICBuYW1lOiAnQUVTLUNCQycsXG4gICAgICAgICAgaXY6IHRoaXMuYWVzSVZcbiAgICAgICAgfSwga2V5LCBkYXRhKTtcbiAgICAgIGNhc2UgRGVjcnlwdGVyQWVzTW9kZS5jdHI6XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnRsZS5kZWNyeXB0KHtcbiAgICAgICAgICBuYW1lOiAnQUVTLUNUUicsXG4gICAgICAgICAgY291bnRlcjogdGhpcy5hZXNJVixcbiAgICAgICAgICBsZW5ndGg6IDY0XG4gICAgICAgIH0sXG4gICAgICAgIC8vNjQgOiBOSVNUIFNQODAwLTM4QSBzdGFuZGFyZCBzdWdnZXN0cyB0aGF0IHRoZSBjb3VudGVyIHNob3VsZCBvY2N1cHkgaGFsZiBvZiB0aGUgY291bnRlciBibG9ja1xuICAgICAgICBrZXksIGRhdGEpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbQUVTQ3J5cHRvXSBpbnZhbGlkIGFlcyBtb2RlICR7dGhpcy5hZXNNb2RlfWApO1xuICAgIH1cbiAgfVxufVxuXG4vLyBQS0NTN1xuZnVuY3Rpb24gcmVtb3ZlUGFkZGluZyhhcnJheSkge1xuICBjb25zdCBvdXRwdXRCeXRlcyA9IGFycmF5LmJ5dGVMZW5ndGg7XG4gIGNvbnN0IHBhZGRpbmdCeXRlcyA9IG91dHB1dEJ5dGVzICYmIG5ldyBEYXRhVmlldyhhcnJheS5idWZmZXIpLmdldFVpbnQ4KG91dHB1dEJ5dGVzIC0gMSk7XG4gIGlmIChwYWRkaW5nQnl0ZXMpIHtcbiAgICByZXR1cm4gYXJyYXkuc2xpY2UoMCwgb3V0cHV0Qnl0ZXMgLSBwYWRkaW5nQnl0ZXMpO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cbmNsYXNzIEFFU0RlY3J5cHRvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucmNvbiA9IFsweDAsIDB4MSwgMHgyLCAweDQsIDB4OCwgMHgxMCwgMHgyMCwgMHg0MCwgMHg4MCwgMHgxYiwgMHgzNl07XG4gICAgdGhpcy5zdWJNaXggPSBbbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NildO1xuICAgIHRoaXMuaW52U3ViTWl4ID0gW25ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpXTtcbiAgICB0aGlzLnNCb3ggPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICB0aGlzLmludlNCb3ggPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICB0aGlzLmtleSA9IG5ldyBVaW50MzJBcnJheSgwKTtcbiAgICB0aGlzLmtzUm93cyA9IDA7XG4gICAgdGhpcy5rZXlTaXplID0gMDtcbiAgICB0aGlzLmtleVNjaGVkdWxlID0gdm9pZCAwO1xuICAgIHRoaXMuaW52S2V5U2NoZWR1bGUgPSB2b2lkIDA7XG4gICAgdGhpcy5pbml0VGFibGUoKTtcbiAgfVxuXG4gIC8vIFVzaW5nIHZpZXcuZ2V0VWludDMyKCkgYWxzbyBzd2FwcyB0aGUgYnl0ZSBvcmRlci5cbiAgdWludDhBcnJheVRvVWludDMyQXJyYXlfKGFycmF5QnVmZmVyKSB7XG4gICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlcik7XG4gICAgY29uc3QgbmV3QXJyYXkgPSBuZXcgVWludDMyQXJyYXkoNCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgIG5ld0FycmF5W2ldID0gdmlldy5nZXRVaW50MzIoaSAqIDQpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3QXJyYXk7XG4gIH1cbiAgaW5pdFRhYmxlKCkge1xuICAgIGNvbnN0IHNCb3ggPSB0aGlzLnNCb3g7XG4gICAgY29uc3QgaW52U0JveCA9IHRoaXMuaW52U0JveDtcbiAgICBjb25zdCBzdWJNaXggPSB0aGlzLnN1Yk1peDtcbiAgICBjb25zdCBzdWJNaXgwID0gc3ViTWl4WzBdO1xuICAgIGNvbnN0IHN1Yk1peDEgPSBzdWJNaXhbMV07XG4gICAgY29uc3Qgc3ViTWl4MiA9IHN1Yk1peFsyXTtcbiAgICBjb25zdCBzdWJNaXgzID0gc3ViTWl4WzNdO1xuICAgIGNvbnN0IGludlN1Yk1peCA9IHRoaXMuaW52U3ViTWl4O1xuICAgIGNvbnN0IGludlN1Yk1peDAgPSBpbnZTdWJNaXhbMF07XG4gICAgY29uc3QgaW52U3ViTWl4MSA9IGludlN1Yk1peFsxXTtcbiAgICBjb25zdCBpbnZTdWJNaXgyID0gaW52U3ViTWl4WzJdO1xuICAgIGNvbnN0IGludlN1Yk1peDMgPSBpbnZTdWJNaXhbM107XG4gICAgY29uc3QgZCA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgIGxldCB4ID0gMDtcbiAgICBsZXQgeGkgPSAwO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgIGlmIChpIDwgMTI4KSB7XG4gICAgICAgIGRbaV0gPSBpIDw8IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkW2ldID0gaSA8PCAxIF4gMHgxMWI7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgbGV0IHN4ID0geGkgXiB4aSA8PCAxIF4geGkgPDwgMiBeIHhpIDw8IDMgXiB4aSA8PCA0O1xuICAgICAgc3ggPSBzeCA+Pj4gOCBeIHN4ICYgMHhmZiBeIDB4NjM7XG4gICAgICBzQm94W3hdID0gc3g7XG4gICAgICBpbnZTQm94W3N4XSA9IHg7XG5cbiAgICAgIC8vIENvbXB1dGUgbXVsdGlwbGljYXRpb25cbiAgICAgIGNvbnN0IHgyID0gZFt4XTtcbiAgICAgIGNvbnN0IHg0ID0gZFt4Ml07XG4gICAgICBjb25zdCB4OCA9IGRbeDRdO1xuXG4gICAgICAvLyBDb21wdXRlIHN1Yi9pbnZTdWIgYnl0ZXMsIG1peCBjb2x1bW5zIHRhYmxlc1xuICAgICAgbGV0IHQgPSBkW3N4XSAqIDB4MTAxIF4gc3ggKiAweDEwMTAxMDA7XG4gICAgICBzdWJNaXgwW3hdID0gdCA8PCAyNCB8IHQgPj4+IDg7XG4gICAgICBzdWJNaXgxW3hdID0gdCA8PCAxNiB8IHQgPj4+IDE2O1xuICAgICAgc3ViTWl4Mlt4XSA9IHQgPDwgOCB8IHQgPj4+IDI0O1xuICAgICAgc3ViTWl4M1t4XSA9IHQ7XG5cbiAgICAgIC8vIENvbXB1dGUgaW52IHN1YiBieXRlcywgaW52IG1peCBjb2x1bW5zIHRhYmxlc1xuICAgICAgdCA9IHg4ICogMHgxMDEwMTAxIF4geDQgKiAweDEwMDAxIF4geDIgKiAweDEwMSBeIHggKiAweDEwMTAxMDA7XG4gICAgICBpbnZTdWJNaXgwW3N4XSA9IHQgPDwgMjQgfCB0ID4+PiA4O1xuICAgICAgaW52U3ViTWl4MVtzeF0gPSB0IDw8IDE2IHwgdCA+Pj4gMTY7XG4gICAgICBpbnZTdWJNaXgyW3N4XSA9IHQgPDwgOCB8IHQgPj4+IDI0O1xuICAgICAgaW52U3ViTWl4M1tzeF0gPSB0O1xuXG4gICAgICAvLyBDb21wdXRlIG5leHQgY291bnRlclxuICAgICAgaWYgKCF4KSB7XG4gICAgICAgIHggPSB4aSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0geDIgXiBkW2RbZFt4OCBeIHgyXV1dO1xuICAgICAgICB4aSBePSBkW2RbeGldXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZXhwYW5kS2V5KGtleUJ1ZmZlcikge1xuICAgIC8vIGNvbnZlcnQga2V5QnVmZmVyIHRvIFVpbnQzMkFycmF5XG4gICAgY29uc3Qga2V5ID0gdGhpcy51aW50OEFycmF5VG9VaW50MzJBcnJheV8oa2V5QnVmZmVyKTtcbiAgICBsZXQgc2FtZUtleSA9IHRydWU7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgd2hpbGUgKG9mZnNldCA8IGtleS5sZW5ndGggJiYgc2FtZUtleSkge1xuICAgICAgc2FtZUtleSA9IGtleVtvZmZzZXRdID09PSB0aGlzLmtleVtvZmZzZXRdO1xuICAgICAgb2Zmc2V0Kys7XG4gICAgfVxuICAgIGlmIChzYW1lS2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIGNvbnN0IGtleVNpemUgPSB0aGlzLmtleVNpemUgPSBrZXkubGVuZ3RoO1xuICAgIGlmIChrZXlTaXplICE9PSA0ICYmIGtleVNpemUgIT09IDYgJiYga2V5U2l6ZSAhPT0gOCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFlcyBrZXkgc2l6ZT0nICsga2V5U2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGtzUm93cyA9IHRoaXMua3NSb3dzID0gKGtleVNpemUgKyA2ICsgMSkgKiA0O1xuICAgIGxldCBrc1JvdztcbiAgICBsZXQgaW52S3NSb3c7XG4gICAgY29uc3Qga2V5U2NoZWR1bGUgPSB0aGlzLmtleVNjaGVkdWxlID0gbmV3IFVpbnQzMkFycmF5KGtzUm93cyk7XG4gICAgY29uc3QgaW52S2V5U2NoZWR1bGUgPSB0aGlzLmludktleVNjaGVkdWxlID0gbmV3IFVpbnQzMkFycmF5KGtzUm93cyk7XG4gICAgY29uc3Qgc2JveCA9IHRoaXMuc0JveDtcbiAgICBjb25zdCByY29uID0gdGhpcy5yY29uO1xuICAgIGNvbnN0IGludlN1Yk1peCA9IHRoaXMuaW52U3ViTWl4O1xuICAgIGNvbnN0IGludlN1Yk1peDAgPSBpbnZTdWJNaXhbMF07XG4gICAgY29uc3QgaW52U3ViTWl4MSA9IGludlN1Yk1peFsxXTtcbiAgICBjb25zdCBpbnZTdWJNaXgyID0gaW52U3ViTWl4WzJdO1xuICAgIGNvbnN0IGludlN1Yk1peDMgPSBpbnZTdWJNaXhbM107XG4gICAgbGV0IHByZXY7XG4gICAgbGV0IHQ7XG4gICAgZm9yIChrc1JvdyA9IDA7IGtzUm93IDwga3NSb3dzOyBrc1JvdysrKSB7XG4gICAgICBpZiAoa3NSb3cgPCBrZXlTaXplKSB7XG4gICAgICAgIHByZXYgPSBrZXlTY2hlZHVsZVtrc1Jvd10gPSBrZXlba3NSb3ddO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHQgPSBwcmV2O1xuICAgICAgaWYgKGtzUm93ICUga2V5U2l6ZSA9PT0gMCkge1xuICAgICAgICAvLyBSb3Qgd29yZFxuICAgICAgICB0ID0gdCA8PCA4IHwgdCA+Pj4gMjQ7XG5cbiAgICAgICAgLy8gU3ViIHdvcmRcbiAgICAgICAgdCA9IHNib3hbdCA+Pj4gMjRdIDw8IDI0IHwgc2JveFt0ID4+PiAxNiAmIDB4ZmZdIDw8IDE2IHwgc2JveFt0ID4+PiA4ICYgMHhmZl0gPDwgOCB8IHNib3hbdCAmIDB4ZmZdO1xuXG4gICAgICAgIC8vIE1peCBSY29uXG4gICAgICAgIHQgXj0gcmNvbltrc1JvdyAvIGtleVNpemUgfCAwXSA8PCAyNDtcbiAgICAgIH0gZWxzZSBpZiAoa2V5U2l6ZSA+IDYgJiYga3NSb3cgJSBrZXlTaXplID09PSA0KSB7XG4gICAgICAgIC8vIFN1YiB3b3JkXG4gICAgICAgIHQgPSBzYm94W3QgPj4+IDI0XSA8PCAyNCB8IHNib3hbdCA+Pj4gMTYgJiAweGZmXSA8PCAxNiB8IHNib3hbdCA+Pj4gOCAmIDB4ZmZdIDw8IDggfCBzYm94W3QgJiAweGZmXTtcbiAgICAgIH1cbiAgICAgIGtleVNjaGVkdWxlW2tzUm93XSA9IHByZXYgPSAoa2V5U2NoZWR1bGVba3NSb3cgLSBrZXlTaXplXSBeIHQpID4+PiAwO1xuICAgIH1cbiAgICBmb3IgKGludktzUm93ID0gMDsgaW52S3NSb3cgPCBrc1Jvd3M7IGludktzUm93KyspIHtcbiAgICAgIGtzUm93ID0ga3NSb3dzIC0gaW52S3NSb3c7XG4gICAgICBpZiAoaW52S3NSb3cgJiAzKSB7XG4gICAgICAgIHQgPSBrZXlTY2hlZHVsZVtrc1Jvd107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ID0ga2V5U2NoZWR1bGVba3NSb3cgLSA0XTtcbiAgICAgIH1cbiAgICAgIGlmIChpbnZLc1JvdyA8IDQgfHwga3NSb3cgPD0gNCkge1xuICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSB0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gaW52U3ViTWl4MFtzYm94W3QgPj4+IDI0XV0gXiBpbnZTdWJNaXgxW3Nib3hbdCA+Pj4gMTYgJiAweGZmXV0gXiBpbnZTdWJNaXgyW3Nib3hbdCA+Pj4gOCAmIDB4ZmZdXSBeIGludlN1Yk1peDNbc2JveFt0ICYgMHhmZl1dO1xuICAgICAgfVxuICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID4+PiAwO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFkZGluZyB0aGlzIGFzIGEgbWV0aG9kIGdyZWF0bHkgaW1wcm92ZXMgcGVyZm9ybWFuY2UuXG4gIG5ldHdvcmtUb0hvc3RPcmRlclN3YXAod29yZCkge1xuICAgIHJldHVybiB3b3JkIDw8IDI0IHwgKHdvcmQgJiAweGZmMDApIDw8IDggfCAod29yZCAmIDB4ZmYwMDAwKSA+PiA4IHwgd29yZCA+Pj4gMjQ7XG4gIH1cbiAgZGVjcnlwdChpbnB1dEFycmF5QnVmZmVyLCBvZmZzZXQsIGFlc0lWKSB7XG4gICAgY29uc3QgblJvdW5kcyA9IHRoaXMua2V5U2l6ZSArIDY7XG4gICAgY29uc3QgaW52S2V5U2NoZWR1bGUgPSB0aGlzLmludktleVNjaGVkdWxlO1xuICAgIGNvbnN0IGludlNCT1ggPSB0aGlzLmludlNCb3g7XG4gICAgY29uc3QgaW52U3ViTWl4ID0gdGhpcy5pbnZTdWJNaXg7XG4gICAgY29uc3QgaW52U3ViTWl4MCA9IGludlN1Yk1peFswXTtcbiAgICBjb25zdCBpbnZTdWJNaXgxID0gaW52U3ViTWl4WzFdO1xuICAgIGNvbnN0IGludlN1Yk1peDIgPSBpbnZTdWJNaXhbMl07XG4gICAgY29uc3QgaW52U3ViTWl4MyA9IGludlN1Yk1peFszXTtcbiAgICBjb25zdCBpbml0VmVjdG9yID0gdGhpcy51aW50OEFycmF5VG9VaW50MzJBcnJheV8oYWVzSVYpO1xuICAgIGxldCBpbml0VmVjdG9yMCA9IGluaXRWZWN0b3JbMF07XG4gICAgbGV0IGluaXRWZWN0b3IxID0gaW5pdFZlY3RvclsxXTtcbiAgICBsZXQgaW5pdFZlY3RvcjIgPSBpbml0VmVjdG9yWzJdO1xuICAgIGxldCBpbml0VmVjdG9yMyA9IGluaXRWZWN0b3JbM107XG4gICAgY29uc3QgaW5wdXRJbnQzMiA9IG5ldyBJbnQzMkFycmF5KGlucHV0QXJyYXlCdWZmZXIpO1xuICAgIGNvbnN0IG91dHB1dEludDMyID0gbmV3IEludDMyQXJyYXkoaW5wdXRJbnQzMi5sZW5ndGgpO1xuICAgIGxldCB0MCwgdDEsIHQyLCB0MztcbiAgICBsZXQgczAsIHMxLCBzMiwgczM7XG4gICAgbGV0IGlucHV0V29yZHMwLCBpbnB1dFdvcmRzMSwgaW5wdXRXb3JkczIsIGlucHV0V29yZHMzO1xuICAgIGxldCBrc1JvdywgaTtcbiAgICBjb25zdCBzd2FwV29yZCA9IHRoaXMubmV0d29ya1RvSG9zdE9yZGVyU3dhcDtcbiAgICB3aGlsZSAob2Zmc2V0IDwgaW5wdXRJbnQzMi5sZW5ndGgpIHtcbiAgICAgIGlucHV0V29yZHMwID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXRdKTtcbiAgICAgIGlucHV0V29yZHMxID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXQgKyAxXSk7XG4gICAgICBpbnB1dFdvcmRzMiA9IHN3YXBXb3JkKGlucHV0SW50MzJbb2Zmc2V0ICsgMl0pO1xuICAgICAgaW5wdXRXb3JkczMgPSBzd2FwV29yZChpbnB1dEludDMyW29mZnNldCArIDNdKTtcbiAgICAgIHMwID0gaW5wdXRXb3JkczAgXiBpbnZLZXlTY2hlZHVsZVswXTtcbiAgICAgIHMxID0gaW5wdXRXb3JkczMgXiBpbnZLZXlTY2hlZHVsZVsxXTtcbiAgICAgIHMyID0gaW5wdXRXb3JkczIgXiBpbnZLZXlTY2hlZHVsZVsyXTtcbiAgICAgIHMzID0gaW5wdXRXb3JkczEgXiBpbnZLZXlTY2hlZHVsZVszXTtcbiAgICAgIGtzUm93ID0gNDtcblxuICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSByb3VuZHMgb2YgZGVjcnlwdGlvblxuICAgICAgZm9yIChpID0gMTsgaSA8IG5Sb3VuZHM7IGkrKykge1xuICAgICAgICB0MCA9IGludlN1Yk1peDBbczAgPj4+IDI0XSBeIGludlN1Yk1peDFbczEgPj4gMTYgJiAweGZmXSBeIGludlN1Yk1peDJbczIgPj4gOCAmIDB4ZmZdIF4gaW52U3ViTWl4M1tzMyAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3ddO1xuICAgICAgICB0MSA9IGludlN1Yk1peDBbczEgPj4+IDI0XSBeIGludlN1Yk1peDFbczIgPj4gMTYgJiAweGZmXSBeIGludlN1Yk1peDJbczMgPj4gOCAmIDB4ZmZdIF4gaW52U3ViTWl4M1tzMCAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAxXTtcbiAgICAgICAgdDIgPSBpbnZTdWJNaXgwW3MyID4+PiAyNF0gXiBpbnZTdWJNaXgxW3MzID4+IDE2ICYgMHhmZl0gXiBpbnZTdWJNaXgyW3MwID4+IDggJiAweGZmXSBeIGludlN1Yk1peDNbczEgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgMl07XG4gICAgICAgIHQzID0gaW52U3ViTWl4MFtzMyA+Pj4gMjRdIF4gaW52U3ViTWl4MVtzMCA+PiAxNiAmIDB4ZmZdIF4gaW52U3ViTWl4MltzMSA+PiA4ICYgMHhmZl0gXiBpbnZTdWJNaXgzW3MyICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDNdO1xuICAgICAgICAvLyBVcGRhdGUgc3RhdGVcbiAgICAgICAgczAgPSB0MDtcbiAgICAgICAgczEgPSB0MTtcbiAgICAgICAgczIgPSB0MjtcbiAgICAgICAgczMgPSB0MztcbiAgICAgICAga3NSb3cgPSBrc1JvdyArIDQ7XG4gICAgICB9XG5cbiAgICAgIC8vIFNoaWZ0IHJvd3MsIHN1YiBieXRlcywgYWRkIHJvdW5kIGtleVxuICAgICAgdDAgPSBpbnZTQk9YW3MwID4+PiAyNF0gPDwgMjQgXiBpbnZTQk9YW3MxID4+IDE2ICYgMHhmZl0gPDwgMTYgXiBpbnZTQk9YW3MyID4+IDggJiAweGZmXSA8PCA4IF4gaW52U0JPWFtzMyAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3ddO1xuICAgICAgdDEgPSBpbnZTQk9YW3MxID4+PiAyNF0gPDwgMjQgXiBpbnZTQk9YW3MyID4+IDE2ICYgMHhmZl0gPDwgMTYgXiBpbnZTQk9YW3MzID4+IDggJiAweGZmXSA8PCA4IF4gaW52U0JPWFtzMCAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAxXTtcbiAgICAgIHQyID0gaW52U0JPWFtzMiA+Pj4gMjRdIDw8IDI0IF4gaW52U0JPWFtzMyA+PiAxNiAmIDB4ZmZdIDw8IDE2IF4gaW52U0JPWFtzMCA+PiA4ICYgMHhmZl0gPDwgOCBeIGludlNCT1hbczEgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgMl07XG4gICAgICB0MyA9IGludlNCT1hbczMgPj4+IDI0XSA8PCAyNCBeIGludlNCT1hbczAgPj4gMTYgJiAweGZmXSA8PCAxNiBeIGludlNCT1hbczEgPj4gOCAmIDB4ZmZdIDw8IDggXiBpbnZTQk9YW3MyICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDNdO1xuXG4gICAgICAvLyBXcml0ZVxuICAgICAgb3V0cHV0SW50MzJbb2Zmc2V0XSA9IHN3YXBXb3JkKHQwIF4gaW5pdFZlY3RvcjApO1xuICAgICAgb3V0cHV0SW50MzJbb2Zmc2V0ICsgMV0gPSBzd2FwV29yZCh0MyBeIGluaXRWZWN0b3IxKTtcbiAgICAgIG91dHB1dEludDMyW29mZnNldCArIDJdID0gc3dhcFdvcmQodDIgXiBpbml0VmVjdG9yMik7XG4gICAgICBvdXRwdXRJbnQzMltvZmZzZXQgKyAzXSA9IHN3YXBXb3JkKHQxIF4gaW5pdFZlY3RvcjMpO1xuXG4gICAgICAvLyByZXNldCBpbml0VmVjdG9yIHRvIGxhc3QgNCB1bnNpZ25lZCBpbnRcbiAgICAgIGluaXRWZWN0b3IwID0gaW5wdXRXb3JkczA7XG4gICAgICBpbml0VmVjdG9yMSA9IGlucHV0V29yZHMxO1xuICAgICAgaW5pdFZlY3RvcjIgPSBpbnB1dFdvcmRzMjtcbiAgICAgIGluaXRWZWN0b3IzID0gaW5wdXRXb3JkczM7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgKyA0O1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0SW50MzIuYnVmZmVyO1xuICB9XG59XG5cbmNsYXNzIEZhc3RBRVNLZXkge1xuICBjb25zdHJ1Y3RvcihzdWJ0bGUsIGtleSwgYWVzTW9kZSkge1xuICAgIHRoaXMuc3VidGxlID0gdm9pZCAwO1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuYWVzTW9kZSA9IHZvaWQgMDtcbiAgICB0aGlzLnN1YnRsZSA9IHN1YnRsZTtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLmFlc01vZGUgPSBhZXNNb2RlO1xuICB9XG4gIGV4cGFuZEtleSgpIHtcbiAgICBjb25zdCBzdWJ0bGVBbGdvTmFtZSA9IGdldFN1YnRsZUFsZ29OYW1lKHRoaXMuYWVzTW9kZSk7XG4gICAgcmV0dXJuIHRoaXMuc3VidGxlLmltcG9ydEtleSgncmF3JywgdGhpcy5rZXksIHtcbiAgICAgIG5hbWU6IHN1YnRsZUFsZ29OYW1lXG4gICAgfSwgZmFsc2UsIFsnZW5jcnlwdCcsICdkZWNyeXB0J10pO1xuICB9XG59XG5mdW5jdGlvbiBnZXRTdWJ0bGVBbGdvTmFtZShhZXNNb2RlKSB7XG4gIHN3aXRjaCAoYWVzTW9kZSkge1xuICAgIGNhc2UgRGVjcnlwdGVyQWVzTW9kZS5jYmM6XG4gICAgICByZXR1cm4gJ0FFUy1DQkMnO1xuICAgIGNhc2UgRGVjcnlwdGVyQWVzTW9kZS5jdHI6XG4gICAgICByZXR1cm4gJ0FFUy1DVFInO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFtGYXN0QUVTS2V5XSBpbnZhbGlkIGFlcyBtb2RlICR7YWVzTW9kZX1gKTtcbiAgfVxufVxuXG5jb25zdCBDSFVOS19TSVpFID0gMTY7IC8vIDE2IGJ5dGVzLCAxMjggYml0c1xuXG5jbGFzcyBEZWNyeXB0ZXIge1xuICBjb25zdHJ1Y3Rvcihjb25maWcsIHtcbiAgICByZW1vdmVQS0NTN1BhZGRpbmcgPSB0cnVlXG4gIH0gPSB7fSkge1xuICAgIHRoaXMubG9nRW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5yZW1vdmVQS0NTN1BhZGRpbmcgPSB2b2lkIDA7XG4gICAgdGhpcy5zdWJ0bGUgPSBudWxsO1xuICAgIHRoaXMuc29mdHdhcmVEZWNyeXB0ZXIgPSBudWxsO1xuICAgIHRoaXMua2V5ID0gbnVsbDtcbiAgICB0aGlzLmZhc3RBZXNLZXkgPSBudWxsO1xuICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50SVYgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudFJlc3VsdCA9IG51bGw7XG4gICAgdGhpcy51c2VTb2Z0d2FyZSA9IHZvaWQgMDtcbiAgICB0aGlzLmVuYWJsZVNvZnR3YXJlQUVTID0gdm9pZCAwO1xuICAgIHRoaXMuZW5hYmxlU29mdHdhcmVBRVMgPSBjb25maWcuZW5hYmxlU29mdHdhcmVBRVM7XG4gICAgdGhpcy5yZW1vdmVQS0NTN1BhZGRpbmcgPSByZW1vdmVQS0NTN1BhZGRpbmc7XG4gICAgLy8gYnVpbHQgaW4gZGVjcnlwdG9yIGV4cGVjdHMgUEtDUzcgcGFkZGluZ1xuICAgIGlmIChyZW1vdmVQS0NTN1BhZGRpbmcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGJyb3dzZXJDcnlwdG8gPSBzZWxmLmNyeXB0bztcbiAgICAgICAgaWYgKGJyb3dzZXJDcnlwdG8pIHtcbiAgICAgICAgICB0aGlzLnN1YnRsZSA9IGJyb3dzZXJDcnlwdG8uc3VidGxlIHx8IGJyb3dzZXJDcnlwdG8ud2Via2l0U3VidGxlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8qIG5vLW9wICovXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudXNlU29mdHdhcmUgPSAhdGhpcy5zdWJ0bGU7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnRsZSA9IG51bGw7XG4gICAgdGhpcy5zb2Z0d2FyZURlY3J5cHRlciA9IG51bGw7XG4gICAgdGhpcy5rZXkgPSBudWxsO1xuICAgIHRoaXMuZmFzdEFlc0tleSA9IG51bGw7XG4gICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRJViA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50UmVzdWx0ID0gbnVsbDtcbiAgfVxuICBpc1N5bmMoKSB7XG4gICAgcmV0dXJuIHRoaXMudXNlU29mdHdhcmU7XG4gIH1cbiAgZmx1c2goKSB7XG4gICAgY29uc3Qge1xuICAgICAgY3VycmVudFJlc3VsdCxcbiAgICAgIHJlbWFpbmRlckRhdGFcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWN1cnJlbnRSZXN1bHQgfHwgcmVtYWluZGVyRGF0YSkge1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShjdXJyZW50UmVzdWx0KTtcbiAgICB0aGlzLnJlc2V0KCk7XG4gICAgaWYgKHRoaXMucmVtb3ZlUEtDUzdQYWRkaW5nKSB7XG4gICAgICByZXR1cm4gcmVtb3ZlUGFkZGluZyhkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5jdXJyZW50UmVzdWx0ID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRJViA9IG51bGw7XG4gICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgICBpZiAodGhpcy5zb2Z0d2FyZURlY3J5cHRlcikge1xuICAgICAgdGhpcy5zb2Z0d2FyZURlY3J5cHRlciA9IG51bGw7XG4gICAgfVxuICB9XG4gIGRlY3J5cHQoZGF0YSwga2V5LCBpdiwgYWVzTW9kZSkge1xuICAgIGlmICh0aGlzLnVzZVNvZnR3YXJlKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBkYXRhVmlldyA9IEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSA/IGRhdGEgOiBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICAgICAgdGhpcy5zb2Z0d2FyZURlY3J5cHQoZGF0YVZpZXcsIGtleSwgaXYsIGFlc01vZGUpO1xuICAgICAgICBjb25zdCBkZWNyeXB0UmVzdWx0ID0gdGhpcy5mbHVzaCgpO1xuICAgICAgICBpZiAoZGVjcnlwdFJlc3VsdCkge1xuICAgICAgICAgIHJlc29sdmUoZGVjcnlwdFJlc3VsdC5idWZmZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1tzb2Z0d2FyZURlY3J5cHRdIEZhaWxlZCB0byBkZWNyeXB0IGRhdGEnKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy53ZWJDcnlwdG9EZWNyeXB0KG5ldyBVaW50OEFycmF5KGRhdGEpLCBrZXksIGl2LCBhZXNNb2RlKTtcbiAgfVxuXG4gIC8vIFNvZnR3YXJlIGRlY3J5cHRpb24gaXMgcHJvZ3Jlc3NpdmUuIFByb2dyZXNzaXZlIGRlY3J5cHRpb24gbWF5IG5vdCByZXR1cm4gYSByZXN1bHQgb24gZWFjaCBjYWxsLiBBbnkgY2FjaGVkXG4gIC8vIGRhdGEgaXMgaGFuZGxlZCBpbiB0aGUgZmx1c2goKSBjYWxsXG4gIHNvZnR3YXJlRGVjcnlwdChkYXRhLCBrZXksIGl2LCBhZXNNb2RlKSB7XG4gICAgY29uc3Qge1xuICAgICAgY3VycmVudElWLFxuICAgICAgY3VycmVudFJlc3VsdCxcbiAgICAgIHJlbWFpbmRlckRhdGFcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoYWVzTW9kZSAhPT0gRGVjcnlwdGVyQWVzTW9kZS5jYmMgfHwga2V5LmJ5dGVMZW5ndGggIT09IDE2KSB7XG4gICAgICBsb2dnZXIud2FybignU29mdHdhcmVEZWNyeXB0OiBjYW4gb25seSBoYW5kbGUgQUVTLTEyOC1DQkMnKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0aGlzLmxvZ09uY2UoJ0pTIEFFUyBkZWNyeXB0Jyk7XG4gICAgLy8gVGhlIG91dHB1dCBpcyBzdGFnZ2VyZWQgZHVyaW5nIHByb2dyZXNzaXZlIHBhcnNpbmcgLSB0aGUgY3VycmVudCByZXN1bHQgaXMgY2FjaGVkLCBhbmQgZW1pdHRlZCBvbiB0aGUgbmV4dCBjYWxsXG4gICAgLy8gVGhpcyBpcyBkb25lIGluIG9yZGVyIHRvIHN0cmlwIFBLQ1M3IHBhZGRpbmcsIHdoaWNoIGlzIGZvdW5kIGF0IHRoZSBlbmQgb2YgZWFjaCBzZWdtZW50LiBXZSBvbmx5IGtub3cgd2UndmUgcmVhY2hlZFxuICAgIC8vIHRoZSBlbmQgb24gZmx1c2goKSwgYnV0IGJ5IHRoYXQgdGltZSB3ZSBoYXZlIGFscmVhZHkgcmVjZWl2ZWQgYWxsIGJ5dGVzIGZvciB0aGUgc2VnbWVudC5cbiAgICAvLyBQcm9ncmVzc2l2ZSBkZWNyeXB0aW9uIGRvZXMgbm90IHdvcmsgd2l0aCBXZWJDcnlwdG9cblxuICAgIGlmIChyZW1haW5kZXJEYXRhKSB7XG4gICAgICBkYXRhID0gYXBwZW5kVWludDhBcnJheShyZW1haW5kZXJEYXRhLCBkYXRhKTtcbiAgICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gQnl0ZSBsZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2IChBRVMtMTI4ID0gMTI4IGJpdCBibG9ja3MgPSAxNiBieXRlcylcbiAgICBjb25zdCBjdXJyZW50Q2h1bmsgPSB0aGlzLmdldFZhbGlkQ2h1bmsoZGF0YSk7XG4gICAgaWYgKCFjdXJyZW50Q2h1bmsubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRJVikge1xuICAgICAgaXYgPSBjdXJyZW50SVY7XG4gICAgfVxuICAgIGxldCBzb2Z0d2FyZURlY3J5cHRlciA9IHRoaXMuc29mdHdhcmVEZWNyeXB0ZXI7XG4gICAgaWYgKCFzb2Z0d2FyZURlY3J5cHRlcikge1xuICAgICAgc29mdHdhcmVEZWNyeXB0ZXIgPSB0aGlzLnNvZnR3YXJlRGVjcnlwdGVyID0gbmV3IEFFU0RlY3J5cHRvcigpO1xuICAgIH1cbiAgICBzb2Z0d2FyZURlY3J5cHRlci5leHBhbmRLZXkoa2V5KTtcbiAgICBjb25zdCByZXN1bHQgPSBjdXJyZW50UmVzdWx0O1xuICAgIHRoaXMuY3VycmVudFJlc3VsdCA9IHNvZnR3YXJlRGVjcnlwdGVyLmRlY3J5cHQoY3VycmVudENodW5rLmJ1ZmZlciwgMCwgaXYpO1xuICAgIHRoaXMuY3VycmVudElWID0gY3VycmVudENodW5rLnNsaWNlKC0xNikuYnVmZmVyO1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB3ZWJDcnlwdG9EZWNyeXB0KGRhdGEsIGtleSwgaXYsIGFlc01vZGUpIHtcbiAgICBpZiAodGhpcy5rZXkgIT09IGtleSB8fCAhdGhpcy5mYXN0QWVzS2V5KSB7XG4gICAgICBpZiAoIXRoaXMuc3VidGxlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5vbldlYkNyeXB0b0Vycm9yKGRhdGEsIGtleSwgaXYsIGFlc01vZGUpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgdGhpcy5mYXN0QWVzS2V5ID0gbmV3IEZhc3RBRVNLZXkodGhpcy5zdWJ0bGUsIGtleSwgYWVzTW9kZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZhc3RBZXNLZXkuZXhwYW5kS2V5KCkudGhlbihhZXNLZXkgPT4ge1xuICAgICAgLy8gZGVjcnlwdCB1c2luZyB3ZWIgY3J5cHRvXG4gICAgICBpZiAoIXRoaXMuc3VidGxlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ3dlYiBjcnlwdG8gbm90IGluaXRpYWxpemVkJykpO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2dPbmNlKCdXZWJDcnlwdG8gQUVTIGRlY3J5cHQnKTtcbiAgICAgIGNvbnN0IGNyeXB0byA9IG5ldyBBRVNDcnlwdG8odGhpcy5zdWJ0bGUsIG5ldyBVaW50OEFycmF5KGl2KSwgYWVzTW9kZSk7XG4gICAgICByZXR1cm4gY3J5cHRvLmRlY3J5cHQoZGF0YS5idWZmZXIsIGFlc0tleSk7XG4gICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgIGxvZ2dlci53YXJuKGBbZGVjcnlwdGVyXTogV2ViQ3J5cHRvIEVycm9yLCBkaXNhYmxlIFdlYkNyeXB0byBBUEksICR7ZXJyLm5hbWV9OiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgcmV0dXJuIHRoaXMub25XZWJDcnlwdG9FcnJvcihkYXRhLCBrZXksIGl2LCBhZXNNb2RlKTtcbiAgICB9KTtcbiAgfVxuICBvbldlYkNyeXB0b0Vycm9yKGRhdGEsIGtleSwgaXYsIGFlc01vZGUpIHtcbiAgICBjb25zdCBlbmFibGVTb2Z0d2FyZUFFUyA9IHRoaXMuZW5hYmxlU29mdHdhcmVBRVM7XG4gICAgaWYgKGVuYWJsZVNvZnR3YXJlQUVTKSB7XG4gICAgICB0aGlzLnVzZVNvZnR3YXJlID0gdHJ1ZTtcbiAgICAgIHRoaXMubG9nRW5hYmxlZCA9IHRydWU7XG4gICAgICB0aGlzLnNvZnR3YXJlRGVjcnlwdChkYXRhLCBrZXksIGl2LCBhZXNNb2RlKTtcbiAgICAgIGNvbnN0IGRlY3J5cHRSZXN1bHQgPSB0aGlzLmZsdXNoKCk7XG4gICAgICBpZiAoZGVjcnlwdFJlc3VsdCkge1xuICAgICAgICByZXR1cm4gZGVjcnlwdFJlc3VsdC5idWZmZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignV2ViQ3J5cHRvJyArIChlbmFibGVTb2Z0d2FyZUFFUyA/ICcgYW5kIHNvZnR3YXJlRGVjcnlwdCcgOiAnJykgKyAnOiBmYWlsZWQgdG8gZGVjcnlwdCBkYXRhJyk7XG4gIH1cbiAgZ2V0VmFsaWRDaHVuayhkYXRhKSB7XG4gICAgbGV0IGN1cnJlbnRDaHVuayA9IGRhdGE7XG4gICAgY29uc3Qgc3BsaXRQb2ludCA9IGRhdGEubGVuZ3RoIC0gZGF0YS5sZW5ndGggJSBDSFVOS19TSVpFO1xuICAgIGlmIChzcGxpdFBvaW50ICE9PSBkYXRhLmxlbmd0aCkge1xuICAgICAgY3VycmVudENodW5rID0gZGF0YS5zbGljZSgwLCBzcGxpdFBvaW50KTtcbiAgICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IGRhdGEuc2xpY2Uoc3BsaXRQb2ludCk7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50Q2h1bms7XG4gIH1cbiAgbG9nT25jZShtc2cpIHtcbiAgICBpZiAoIXRoaXMubG9nRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsb2dnZXIubG9nKGBbZGVjcnlwdGVyXTogJHttc2d9YCk7XG4gICAgdGhpcy5sb2dFbmFibGVkID0gZmFsc2U7XG4gIH1cbn1cblxuY29uc3QgTUlOX0NIVU5LX1NJWkUgPSBNYXRoLnBvdygyLCAxNyk7IC8vIDEyOGtiXG5cbmNsYXNzIEZyYWdtZW50TG9hZGVyIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy5sb2FkZXIgPSBudWxsO1xuICAgIHRoaXMucGFydExvYWRUaW1lb3V0ID0gLTE7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5sb2FkZXIpIHtcbiAgICAgIHRoaXMubG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgYWJvcnQoKSB7XG4gICAgaWYgKHRoaXMubG9hZGVyKSB7XG4gICAgICAvLyBBYm9ydCB0aGUgbG9hZGVyIGZvciBjdXJyZW50IGZyYWdtZW50LiBPbmx5IG9uZSBtYXkgbG9hZCBhdCBhbnkgZ2l2ZW4gdGltZVxuICAgICAgdGhpcy5sb2FkZXIuYWJvcnQoKTtcbiAgICB9XG4gIH1cbiAgbG9hZChmcmFnLCBvblByb2dyZXNzKSB7XG4gICAgY29uc3QgdXJsID0gZnJhZy51cmw7XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIGZyYWcsXG4gICAgICAgIGVycm9yOiBuZXcgRXJyb3IoYEZyYWdtZW50IGRvZXMgbm90IGhhdmUgYSAke3VybCA/ICdwYXJ0IGxpc3QnIDogJ3VybCd9YCksXG4gICAgICAgIG5ldHdvcmtEZXRhaWxzOiBudWxsXG4gICAgICB9KSk7XG4gICAgfVxuICAgIHRoaXMuYWJvcnQoKTtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBjb25zdCBGcmFnbWVudElMb2FkZXIgPSBjb25maWcuZkxvYWRlcjtcbiAgICBjb25zdCBEZWZhdWx0SUxvYWRlciA9IGNvbmZpZy5sb2FkZXI7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICh0aGlzLmxvYWRlcikge1xuICAgICAgICB0aGlzLmxvYWRlci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgICBpZiAoZnJhZy5nYXApIHtcbiAgICAgICAgaWYgKGZyYWcudGFnTGlzdC5zb21lKHRhZ3MgPT4gdGFnc1swXSA9PT0gJ0dBUCcpKSB7XG4gICAgICAgICAgcmVqZWN0KGNyZWF0ZUdhcExvYWRFcnJvcihmcmFnKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlc2V0IHRlbXBvcmFyeSB0cmVhdG1lbnQgYXMgR0FQIHRhZ1xuICAgICAgICAgIGZyYWcuZ2FwID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGxvYWRlciA9IHRoaXMubG9hZGVyID0gRnJhZ21lbnRJTG9hZGVyID8gbmV3IEZyYWdtZW50SUxvYWRlcihjb25maWcpIDogbmV3IERlZmF1bHRJTG9hZGVyKGNvbmZpZyk7XG4gICAgICBjb25zdCBsb2FkZXJDb250ZXh0ID0gY3JlYXRlTG9hZGVyQ29udGV4dChmcmFnKTtcbiAgICAgIGZyYWcubG9hZGVyID0gbG9hZGVyO1xuICAgICAgY29uc3QgbG9hZFBvbGljeSA9IGdldExvYWRlckNvbmZpZ1dpdGhvdXRSZXRpZXMoY29uZmlnLmZyYWdMb2FkUG9saWN5LmRlZmF1bHQpO1xuICAgICAgY29uc3QgbG9hZGVyQ29uZmlnID0ge1xuICAgICAgICBsb2FkUG9saWN5LFxuICAgICAgICB0aW1lb3V0OiBsb2FkUG9saWN5Lm1heExvYWRUaW1lTXMsXG4gICAgICAgIG1heFJldHJ5OiAwLFxuICAgICAgICByZXRyeURlbGF5OiAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5OiAwLFxuICAgICAgICBoaWdoV2F0ZXJNYXJrOiBmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnID8gSW5maW5pdHkgOiBNSU5fQ0hVTktfU0laRVxuICAgICAgfTtcbiAgICAgIC8vIEFzc2lnbiBmcmFnIHN0YXRzIHRvIHRoZSBsb2FkZXIncyBzdGF0cyByZWZlcmVuY2VcbiAgICAgIGZyYWcuc3RhdHMgPSBsb2FkZXIuc3RhdHM7XG4gICAgICBjb25zdCBjYWxsYmFja3MgPSB7XG4gICAgICAgIG9uU3VjY2VzczogKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpID0+IHtcbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGVyKGZyYWcsIGxvYWRlcik7XG4gICAgICAgICAgbGV0IHBheWxvYWQgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICAgIGlmIChjb250ZXh0LnJlc2V0SVYgJiYgZnJhZy5kZWNyeXB0ZGF0YSkge1xuICAgICAgICAgICAgZnJhZy5kZWNyeXB0ZGF0YS5pdiA9IG5ldyBVaW50OEFycmF5KHBheWxvYWQuc2xpY2UoMCwgMTYpKTtcbiAgICAgICAgICAgIHBheWxvYWQgPSBwYXlsb2FkLnNsaWNlKDE2KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgcGFydDogbnVsbCxcbiAgICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlsc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbkVycm9yOiAocmVzcG9uc2UsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCBzdGF0cykgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcbiAgICAgICAgICByZWplY3QobmV3IExvYWRFcnJvcih7XG4gICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SLFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgIHJlc3BvbnNlOiBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgZGF0YTogdW5kZWZpbmVkXG4gICAgICAgICAgICB9LCByZXNwb25zZSksXG4gICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKGBIVFRQIEVycm9yICR7cmVzcG9uc2UuY29kZX0gJHtyZXNwb25zZS50ZXh0fWApLFxuICAgICAgICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgICBzdGF0c1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25BYm9ydDogKHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcbiAgICAgICAgICByZWplY3QobmV3IExvYWRFcnJvcih7XG4gICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuSU5URVJOQUxfQUJPUlRFRCxcbiAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKCdBYm9ydGVkJyksXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICAgIHN0YXRzXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9LFxuICAgICAgICBvblRpbWVvdXQ6IChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpID0+IHtcbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGVyKGZyYWcsIGxvYWRlcik7XG4gICAgICAgICAgcmVqZWN0KG5ldyBMb2FkRXJyb3Ioe1xuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VULFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3IoYFRpbWVvdXQgYWZ0ZXIgJHtsb2FkZXJDb25maWcudGltZW91dH1tc2ApLFxuICAgICAgICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgICBzdGF0c1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChvblByb2dyZXNzKSB7XG4gICAgICAgIGNhbGxiYWNrcy5vblByb2dyZXNzID0gKHN0YXRzLCBjb250ZXh0LCBkYXRhLCBuZXR3b3JrRGV0YWlscykgPT4gb25Qcm9ncmVzcyh7XG4gICAgICAgICAgZnJhZyxcbiAgICAgICAgICBwYXJ0OiBudWxsLFxuICAgICAgICAgIHBheWxvYWQ6IGRhdGEsXG4gICAgICAgICAgbmV0d29ya0RldGFpbHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBsb2FkZXIubG9hZChsb2FkZXJDb250ZXh0LCBsb2FkZXJDb25maWcsIGNhbGxiYWNrcyk7XG4gICAgfSk7XG4gIH1cbiAgbG9hZFBhcnQoZnJhZywgcGFydCwgb25Qcm9ncmVzcykge1xuICAgIHRoaXMuYWJvcnQoKTtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBjb25zdCBGcmFnbWVudElMb2FkZXIgPSBjb25maWcuZkxvYWRlcjtcbiAgICBjb25zdCBEZWZhdWx0SUxvYWRlciA9IGNvbmZpZy5sb2FkZXI7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICh0aGlzLmxvYWRlcikge1xuICAgICAgICB0aGlzLmxvYWRlci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgICBpZiAoZnJhZy5nYXAgfHwgcGFydC5nYXApIHtcbiAgICAgICAgcmVqZWN0KGNyZWF0ZUdhcExvYWRFcnJvcihmcmFnLCBwYXJ0KSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxvYWRlciA9IHRoaXMubG9hZGVyID0gRnJhZ21lbnRJTG9hZGVyID8gbmV3IEZyYWdtZW50SUxvYWRlcihjb25maWcpIDogbmV3IERlZmF1bHRJTG9hZGVyKGNvbmZpZyk7XG4gICAgICBjb25zdCBsb2FkZXJDb250ZXh0ID0gY3JlYXRlTG9hZGVyQ29udGV4dChmcmFnLCBwYXJ0KTtcbiAgICAgIGZyYWcubG9hZGVyID0gbG9hZGVyO1xuICAgICAgLy8gU2hvdWxkIHdlIGRlZmluZSBhbm90aGVyIGxvYWQgcG9saWN5IGZvciBwYXJ0cz9cbiAgICAgIGNvbnN0IGxvYWRQb2xpY3kgPSBnZXRMb2FkZXJDb25maWdXaXRob3V0UmV0aWVzKGNvbmZpZy5mcmFnTG9hZFBvbGljeS5kZWZhdWx0KTtcbiAgICAgIGNvbnN0IGxvYWRlckNvbmZpZyA9IHtcbiAgICAgICAgbG9hZFBvbGljeSxcbiAgICAgICAgdGltZW91dDogbG9hZFBvbGljeS5tYXhMb2FkVGltZU1zLFxuICAgICAgICBtYXhSZXRyeTogMCxcbiAgICAgICAgcmV0cnlEZWxheTogMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheTogMCxcbiAgICAgICAgaGlnaFdhdGVyTWFyazogTUlOX0NIVU5LX1NJWkVcbiAgICAgIH07XG4gICAgICAvLyBBc3NpZ24gcGFydCBzdGF0cyB0byB0aGUgbG9hZGVyJ3Mgc3RhdHMgcmVmZXJlbmNlXG4gICAgICBwYXJ0LnN0YXRzID0gbG9hZGVyLnN0YXRzO1xuICAgICAgbG9hZGVyLmxvYWQobG9hZGVyQ29udGV4dCwgbG9hZGVyQ29uZmlnLCB7XG4gICAgICAgIG9uU3VjY2VzczogKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpID0+IHtcbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGVyKGZyYWcsIGxvYWRlcik7XG4gICAgICAgICAgdGhpcy51cGRhdGVTdGF0c0Zyb21QYXJ0KGZyYWcsIHBhcnQpO1xuICAgICAgICAgIGNvbnN0IHBhcnRMb2FkZWREYXRhID0ge1xuICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgIHBhcnQsXG4gICAgICAgICAgICBwYXlsb2FkOiByZXNwb25zZS5kYXRhLFxuICAgICAgICAgICAgbmV0d29ya0RldGFpbHNcbiAgICAgICAgICB9O1xuICAgICAgICAgIG9uUHJvZ3Jlc3MocGFydExvYWRlZERhdGEpO1xuICAgICAgICAgIHJlc29sdmUocGFydExvYWRlZERhdGEpO1xuICAgICAgICB9LFxuICAgICAgICBvbkVycm9yOiAocmVzcG9uc2UsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCBzdGF0cykgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcbiAgICAgICAgICByZWplY3QobmV3IExvYWRFcnJvcih7XG4gICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SLFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgIHBhcnQsXG4gICAgICAgICAgICByZXNwb25zZTogX29iamVjdFNwcmVhZDIoe1xuICAgICAgICAgICAgICB1cmw6IGxvYWRlckNvbnRleHQudXJsLFxuICAgICAgICAgICAgICBkYXRhOiB1bmRlZmluZWRcbiAgICAgICAgICAgIH0sIHJlc3BvbnNlKSxcbiAgICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3IoYEhUVFAgRXJyb3IgJHtyZXNwb25zZS5jb2RlfSAke3Jlc3BvbnNlLnRleHR9YCksXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICAgIHN0YXRzXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9LFxuICAgICAgICBvbkFib3J0OiAoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgICAgZnJhZy5zdGF0cy5hYm9ydGVkID0gcGFydC5zdGF0cy5hYm9ydGVkO1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcbiAgICAgICAgICByZWplY3QobmV3IExvYWRFcnJvcih7XG4gICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuSU5URVJOQUxfQUJPUlRFRCxcbiAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcignQWJvcnRlZCcpLFxuICAgICAgICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgICBzdGF0c1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25UaW1lb3V0OiAoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuICAgICAgICAgIHJlamVjdChuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVCxcbiAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihgVGltZW91dCBhZnRlciAke2xvYWRlckNvbmZpZy50aW1lb3V0fW1zYCksXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICAgIHN0YXRzXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVTdGF0c0Zyb21QYXJ0KGZyYWcsIHBhcnQpIHtcbiAgICBjb25zdCBmcmFnU3RhdHMgPSBmcmFnLnN0YXRzO1xuICAgIGNvbnN0IHBhcnRTdGF0cyA9IHBhcnQuc3RhdHM7XG4gICAgY29uc3QgcGFydFRvdGFsID0gcGFydFN0YXRzLnRvdGFsO1xuICAgIGZyYWdTdGF0cy5sb2FkZWQgKz0gcGFydFN0YXRzLmxvYWRlZDtcbiAgICBpZiAocGFydFRvdGFsKSB7XG4gICAgICBjb25zdCBlc3RUb3RhbFBhcnRzID0gTWF0aC5yb3VuZChmcmFnLmR1cmF0aW9uIC8gcGFydC5kdXJhdGlvbik7XG4gICAgICBjb25zdCBlc3RMb2FkZWRQYXJ0cyA9IE1hdGgubWluKE1hdGgucm91bmQoZnJhZ1N0YXRzLmxvYWRlZCAvIHBhcnRUb3RhbCksIGVzdFRvdGFsUGFydHMpO1xuICAgICAgY29uc3QgZXN0UmVtYWluaW5nUGFydHMgPSBlc3RUb3RhbFBhcnRzIC0gZXN0TG9hZGVkUGFydHM7XG4gICAgICBjb25zdCBlc3RSZW1haW5pbmdCeXRlcyA9IGVzdFJlbWFpbmluZ1BhcnRzICogTWF0aC5yb3VuZChmcmFnU3RhdHMubG9hZGVkIC8gZXN0TG9hZGVkUGFydHMpO1xuICAgICAgZnJhZ1N0YXRzLnRvdGFsID0gZnJhZ1N0YXRzLmxvYWRlZCArIGVzdFJlbWFpbmluZ0J5dGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcmFnU3RhdHMudG90YWwgPSBNYXRoLm1heChmcmFnU3RhdHMubG9hZGVkLCBmcmFnU3RhdHMudG90YWwpO1xuICAgIH1cbiAgICBjb25zdCBmcmFnTG9hZGluZyA9IGZyYWdTdGF0cy5sb2FkaW5nO1xuICAgIGNvbnN0IHBhcnRMb2FkaW5nID0gcGFydFN0YXRzLmxvYWRpbmc7XG4gICAgaWYgKGZyYWdMb2FkaW5nLnN0YXJ0KSB7XG4gICAgICAvLyBhZGQgdG8gZnJhZ21lbnQgbG9hZGVyIGxhdGVuY3lcbiAgICAgIGZyYWdMb2FkaW5nLmZpcnN0ICs9IHBhcnRMb2FkaW5nLmZpcnN0IC0gcGFydExvYWRpbmcuc3RhcnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYWdMb2FkaW5nLnN0YXJ0ID0gcGFydExvYWRpbmcuc3RhcnQ7XG4gICAgICBmcmFnTG9hZGluZy5maXJzdCA9IHBhcnRMb2FkaW5nLmZpcnN0O1xuICAgIH1cbiAgICBmcmFnTG9hZGluZy5lbmQgPSBwYXJ0TG9hZGluZy5lbmQ7XG4gIH1cbiAgcmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKSB7XG4gICAgZnJhZy5sb2FkZXIgPSBudWxsO1xuICAgIGlmICh0aGlzLmxvYWRlciA9PT0gbG9hZGVyKSB7XG4gICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnBhcnRMb2FkVGltZW91dCk7XG4gICAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgfVxuICAgIGxvYWRlci5kZXN0cm95KCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUxvYWRlckNvbnRleHQoZnJhZywgcGFydCA9IG51bGwpIHtcbiAgY29uc3Qgc2VnbWVudCA9IHBhcnQgfHwgZnJhZztcbiAgY29uc3QgbG9hZGVyQ29udGV4dCA9IHtcbiAgICBmcmFnLFxuICAgIHBhcnQsXG4gICAgcmVzcG9uc2VUeXBlOiAnYXJyYXlidWZmZXInLFxuICAgIHVybDogc2VnbWVudC51cmwsXG4gICAgaGVhZGVyczoge30sXG4gICAgcmFuZ2VTdGFydDogMCxcbiAgICByYW5nZUVuZDogMFxuICB9O1xuICBjb25zdCBzdGFydCA9IHNlZ21lbnQuYnl0ZVJhbmdlU3RhcnRPZmZzZXQ7XG4gIGNvbnN0IGVuZCA9IHNlZ21lbnQuYnl0ZVJhbmdlRW5kT2Zmc2V0O1xuICBpZiAoaXNGaW5pdGVOdW1iZXIoc3RhcnQpICYmIGlzRmluaXRlTnVtYmVyKGVuZCkpIHtcbiAgICB2YXIgX2ZyYWckZGVjcnlwdGRhdGE7XG4gICAgbGV0IGJ5dGVSYW5nZVN0YXJ0ID0gc3RhcnQ7XG4gICAgbGV0IGJ5dGVSYW5nZUVuZCA9IGVuZDtcbiAgICBpZiAoZnJhZy5zbiA9PT0gJ2luaXRTZWdtZW50JyAmJiBpc01ldGhvZEZ1bGxTZWdtZW50QWVzQ2JjKChfZnJhZyRkZWNyeXB0ZGF0YSA9IGZyYWcuZGVjcnlwdGRhdGEpID09IG51bGwgPyB2b2lkIDAgOiBfZnJhZyRkZWNyeXB0ZGF0YS5tZXRob2QpKSB7XG4gICAgICAvLyBNQVAgc2VnbWVudCBlbmNyeXB0ZWQgd2l0aCBtZXRob2QgJ0FFUy0xMjgnIG9yICdBRVMtMjU2JyAoY2JjKSwgd2hlbiBzZXJ2ZWQgd2l0aCBIVFRQIFJhbmdlLFxuICAgICAgLy8gaGFzIHRoZSB1bmVuY3J5cHRlZCBzaXplIHNwZWNpZmllZCBpbiB0aGUgcmFuZ2UuXG4gICAgICAvLyBSZWY6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1wYW50b3MtaGxzLXJmYzgyMTZiaXMtMDgjc2VjdGlvbi02LjMuNlxuICAgICAgY29uc3QgZnJhZ21lbnRMZW4gPSBlbmQgLSBzdGFydDtcbiAgICAgIGlmIChmcmFnbWVudExlbiAlIDE2KSB7XG4gICAgICAgIGJ5dGVSYW5nZUVuZCA9IGVuZCArICgxNiAtIGZyYWdtZW50TGVuICUgMTYpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ICE9PSAwKSB7XG4gICAgICAgIGxvYWRlckNvbnRleHQucmVzZXRJViA9IHRydWU7XG4gICAgICAgIGJ5dGVSYW5nZVN0YXJ0ID0gc3RhcnQgLSAxNjtcbiAgICAgIH1cbiAgICB9XG4gICAgbG9hZGVyQ29udGV4dC5yYW5nZVN0YXJ0ID0gYnl0ZVJhbmdlU3RhcnQ7XG4gICAgbG9hZGVyQ29udGV4dC5yYW5nZUVuZCA9IGJ5dGVSYW5nZUVuZDtcbiAgfVxuICByZXR1cm4gbG9hZGVyQ29udGV4dDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUdhcExvYWRFcnJvcihmcmFnLCBwYXJ0KSB7XG4gIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBHQVAgJHtmcmFnLmdhcCA/ICd0YWcnIDogJ2F0dHJpYnV0ZSd9IGZvdW5kYCk7XG4gIGNvbnN0IGVycm9yRGF0YSA9IHtcbiAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0dBUCxcbiAgICBmYXRhbDogZmFsc2UsXG4gICAgZnJhZyxcbiAgICBlcnJvcixcbiAgICBuZXR3b3JrRGV0YWlsczogbnVsbFxuICB9O1xuICBpZiAocGFydCkge1xuICAgIGVycm9yRGF0YS5wYXJ0ID0gcGFydDtcbiAgfVxuICAocGFydCA/IHBhcnQgOiBmcmFnKS5zdGF0cy5hYm9ydGVkID0gdHJ1ZTtcbiAgcmV0dXJuIG5ldyBMb2FkRXJyb3IoZXJyb3JEYXRhKTtcbn1cbmZ1bmN0aW9uIGlzTWV0aG9kRnVsbFNlZ21lbnRBZXNDYmMobWV0aG9kKSB7XG4gIHJldHVybiBtZXRob2QgPT09ICdBRVMtMTI4JyB8fCBtZXRob2QgPT09ICdBRVMtMjU2Jztcbn1cbmNsYXNzIExvYWRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKGRhdGEuZXJyb3IubWVzc2FnZSk7XG4gICAgdGhpcy5kYXRhID0gdm9pZCAwO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cbn1cblxuLyoqXG4gKiBAaWdub3JlXG4gKiBTdWItY2xhc3Mgc3BlY2lhbGl6YXRpb24gb2YgRXZlbnRIYW5kbGVyIGJhc2UgY2xhc3MuXG4gKlxuICogVGFza0xvb3AgYWxsb3dzIHRvIHNjaGVkdWxlIGEgdGFzayBmdW5jdGlvbiBiZWluZyBjYWxsZWQgKG9wdGlvbm5hbHkgcmVwZWF0ZWRseSkgb24gdGhlIG1haW4gbG9vcCxcbiAqIHNjaGVkdWxlZCBhc3luY2hyb25lb3VzbHksIGF2b2lkaW5nIHJlY3Vyc2l2ZSBjYWxscyBpbiB0aGUgc2FtZSB0aWNrLlxuICpcbiAqIFRoZSB0YXNrIGl0c2VsZiBpcyBpbXBsZW1lbnRlZCBpbiBgZG9UaWNrYC4gSXQgY2FuIGJlIHJlcXVlc3RlZCBhbmQgY2FsbGVkIGZvciBzaW5nbGUgZXhlY3V0aW9uXG4gKiB1c2luZyB0aGUgYHRpY2tgIG1ldGhvZC5cbiAqXG4gKiBJdCB3aWxsIGJlIGFzc3VyZWQgdGhhdCB0aGUgdGFzayBleGVjdXRpb24gbWV0aG9kIChgdGlja2ApIG9ubHkgZ2V0cyBjYWxsZWQgb25jZSBwZXIgbWFpbiBsb29wIFwidGlja1wiLFxuICogbm8gbWF0dGVyIGhvdyBvZnRlbiBpdCBnZXRzIHJlcXVlc3RlZCBmb3IgZXhlY3V0aW9uLiBFeGVjdXRpb24gaW4gZnVydGhlciB0aWNrcyB3aWxsIGJlIHNjaGVkdWxlZCBhY2NvcmRpbmdseS5cbiAqXG4gKiBJZiBmdXJ0aGVyIGV4ZWN1dGlvbiByZXF1ZXN0cyBoYXZlIGFscmVhZHkgYmVlbiBzY2hlZHVsZWQgb24gdGhlIG5leHQgdGljaywgaXQgY2FuIGJlIGNoZWNrZWQgd2l0aCBgaGFzTmV4dFRpY2tgLFxuICogYW5kIGNhbmNlbGxlZCB3aXRoIGBjbGVhck5leHRUaWNrYC5cbiAqXG4gKiBUaGUgdGFzayBjYW4gYmUgc2NoZWR1bGVkIGFzIGFuIGludGVydmFsIHJlcGVhdGVkbHkgd2l0aCBhIHBlcmlvZCBhcyBwYXJhbWV0ZXIgKHNlZSBgc2V0SW50ZXJ2YWxgLCBgY2xlYXJJbnRlcnZhbGApLlxuICpcbiAqIFN1Yi1jbGFzc2VzIG5lZWQgdG8gaW1wbGVtZW50IHRoZSBgZG9UaWNrYCBtZXRob2Qgd2hpY2ggd2lsbCBlZmZlY3RpdmVseSBoYXZlIHRoZSB0YXNrIGV4ZWN1dGlvbiByb3V0aW5lLlxuICpcbiAqIEZ1cnRoZXIgZXhwbGFuYXRpb25zOlxuICpcbiAqIFRoZSBiYXNlY2xhc3MgaGFzIGEgYHRpY2tgIG1ldGhvZCB0aGF0IHdpbGwgc2NoZWR1bGUgdGhlIGRvVGljayBjYWxsLiBJdCBtYXkgYmUgY2FsbGVkIHN5bmNocm9uZW91c2x5XG4gKiBvbmx5IGZvciBhIHN0YWNrLWRlcHRoIG9mIG9uZS4gT24gcmUtZW50cmFudCBjYWxscywgc3ViLXNlcXVlbnQgY2FsbHMgYXJlIHNjaGVkdWxlZCBmb3IgbmV4dCBtYWluIGxvb3AgdGlja3MuXG4gKlxuICogV2hlbiB0aGUgdGFzayBleGVjdXRpb24gKGB0aWNrYCBtZXRob2QpIGlzIGNhbGxlZCBpbiByZS1lbnRyYW50IHdheSB0aGlzIGlzIGRldGVjdGVkIGFuZFxuICogd2UgYXJlIGxpbWl0aW5nIHRoZSB0YXNrIGV4ZWN1dGlvbiBwZXIgY2FsbCBzdGFjayB0byBleGFjdGx5IG9uZSwgYnV0IHNjaGVkdWxpbmcvcG9zdC1wb25pbmcgZnVydGhlclxuICogdGFzayBwcm9jZXNzaW5nIG9uIHRoZSBuZXh0IG1haW4gbG9vcCBpdGVyYXRpb24gKGFsc28ga25vd24gYXMgXCJuZXh0IHRpY2tcIiBpbiB0aGUgTm9kZS9KUyBydW50aW1lIGxpbmdvKS5cbiAqL1xuY2xhc3MgVGFza0xvb3AgZXh0ZW5kcyBMb2dnZXIge1xuICBjb25zdHJ1Y3RvcihsYWJlbCwgbG9nZ2VyKSB7XG4gICAgc3VwZXIobGFiZWwsIGxvZ2dlcik7XG4gICAgdGhpcy5fYm91bmRUaWNrID0gdm9pZCAwO1xuICAgIHRoaXMuX3RpY2tUaW1lciA9IG51bGw7XG4gICAgdGhpcy5fdGlja0ludGVydmFsID0gbnVsbDtcbiAgICB0aGlzLl90aWNrQ2FsbENvdW50ID0gMDtcbiAgICB0aGlzLl9ib3VuZFRpY2sgPSB0aGlzLnRpY2suYmluZCh0aGlzKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMub25IYW5kbGVyRGVzdHJveWluZygpO1xuICAgIHRoaXMub25IYW5kbGVyRGVzdHJveWVkKCk7XG4gIH1cbiAgb25IYW5kbGVyRGVzdHJveWluZygpIHtcbiAgICAvLyBjbGVhciBhbGwgdGltZXJzIGJlZm9yZSB1bnJlZ2lzdGVyaW5nIGZyb20gZXZlbnQgYnVzXG4gICAgdGhpcy5jbGVhck5leHRUaWNrKCk7XG4gICAgdGhpcy5jbGVhckludGVydmFsKCk7XG4gIH1cbiAgb25IYW5kbGVyRGVzdHJveWVkKCkge31cbiAgaGFzSW50ZXJ2YWwoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fdGlja0ludGVydmFsO1xuICB9XG4gIGhhc05leHRUaWNrKCkge1xuICAgIHJldHVybiAhIXRoaXMuX3RpY2tUaW1lcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gbWlsbGlzIC0gSW50ZXJ2YWwgdGltZSAobXMpXG4gICAqIEBldHVybnMgVHJ1ZSB3aGVuIGludGVydmFsIGhhcyBiZWVuIHNjaGVkdWxlZCwgZmFsc2Ugd2hlbiBhbHJlYWR5IHNjaGVkdWxlZCAobm8gZWZmZWN0KVxuICAgKi9cbiAgc2V0SW50ZXJ2YWwobWlsbGlzKSB7XG4gICAgaWYgKCF0aGlzLl90aWNrSW50ZXJ2YWwpIHtcbiAgICAgIHRoaXMuX3RpY2tDYWxsQ291bnQgPSAwO1xuICAgICAgdGhpcy5fdGlja0ludGVydmFsID0gc2VsZi5zZXRJbnRlcnZhbCh0aGlzLl9ib3VuZFRpY2ssIG1pbGxpcyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIFRydWUgd2hlbiBpbnRlcnZhbCB3YXMgY2xlYXJlZCwgZmFsc2Ugd2hlbiBub25lIHdhcyBzZXQgKG5vIGVmZmVjdClcbiAgICovXG4gIGNsZWFySW50ZXJ2YWwoKSB7XG4gICAgaWYgKHRoaXMuX3RpY2tJbnRlcnZhbCkge1xuICAgICAgc2VsZi5jbGVhckludGVydmFsKHRoaXMuX3RpY2tJbnRlcnZhbCk7XG4gICAgICB0aGlzLl90aWNrSW50ZXJ2YWwgPSBudWxsO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBUcnVlIHdoZW4gdGltZW91dCB3YXMgY2xlYXJlZCwgZmFsc2Ugd2hlbiBub25lIHdhcyBzZXQgKG5vIGVmZmVjdClcbiAgICovXG4gIGNsZWFyTmV4dFRpY2soKSB7XG4gICAgaWYgKHRoaXMuX3RpY2tUaW1lcikge1xuICAgICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5fdGlja1RpbWVyKTtcbiAgICAgIHRoaXMuX3RpY2tUaW1lciA9IG51bGw7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFdpbGwgY2FsbCB0aGUgc3ViY2xhc3MgZG9UaWNrIGltcGxlbWVudGF0aW9uIGluIHRoaXMgbWFpbiBsb29wIHRpY2tcbiAgICogb3IgaW4gdGhlIG5leHQgb25lICh2aWEgc2V0VGltZW91dCgsMCkpIGluIGNhc2UgaXQgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWRcbiAgICogaW4gdGhpcyB0aWNrIChpbiBjYXNlIHRoaXMgaXMgYSByZS1lbnRyYW50IGNhbGwpLlxuICAgKi9cbiAgdGljaygpIHtcbiAgICB0aGlzLl90aWNrQ2FsbENvdW50Kys7XG4gICAgaWYgKHRoaXMuX3RpY2tDYWxsQ291bnQgPT09IDEpIHtcbiAgICAgIHRoaXMuZG9UaWNrKCk7XG4gICAgICAvLyByZS1lbnRyYW50IGNhbGwgdG8gdGljayBmcm9tIHByZXZpb3VzIGRvVGljayBjYWxsIHN0YWNrXG4gICAgICAvLyAtPiBzY2hlZHVsZSBhIGNhbGwgb24gdGhlIG5leHQgbWFpbiBsb29wIGl0ZXJhdGlvbiB0byBwcm9jZXNzIHRoaXMgdGFzayBwcm9jZXNzaW5nIHJlcXVlc3RcbiAgICAgIGlmICh0aGlzLl90aWNrQ2FsbENvdW50ID4gMSkge1xuICAgICAgICAvLyBtYWtlIHN1cmUgb25seSBvbmUgdGltZXIgZXhpc3RzIGF0IGFueSB0aW1lIGF0IG1heFxuICAgICAgICB0aGlzLnRpY2tJbW1lZGlhdGUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3RpY2tDYWxsQ291bnQgPSAwO1xuICAgIH1cbiAgfVxuICB0aWNrSW1tZWRpYXRlKCkge1xuICAgIHRoaXMuY2xlYXJOZXh0VGljaygpO1xuICAgIHRoaXMuX3RpY2tUaW1lciA9IHNlbGYuc2V0VGltZW91dCh0aGlzLl9ib3VuZFRpY2ssIDApO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvciBzdWJjbGFzcyB0byBpbXBsZW1lbnQgdGFzayBsb2dpY1xuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIGRvVGljaygpIHt9XG59XG5cbmNsYXNzIENodW5rTWV0YWRhdGEge1xuICBjb25zdHJ1Y3RvcihsZXZlbCwgc24sIGlkLCBzaXplID0gMCwgcGFydCA9IC0xLCBwYXJ0aWFsID0gZmFsc2UpIHtcbiAgICB0aGlzLmxldmVsID0gdm9pZCAwO1xuICAgIHRoaXMuc24gPSB2b2lkIDA7XG4gICAgdGhpcy5wYXJ0ID0gdm9pZCAwO1xuICAgIHRoaXMuaWQgPSB2b2lkIDA7XG4gICAgdGhpcy5zaXplID0gdm9pZCAwO1xuICAgIHRoaXMucGFydGlhbCA9IHZvaWQgMDtcbiAgICB0aGlzLnRyYW5zbXV4aW5nID0gZ2V0TmV3UGVyZm9ybWFuY2VUaW1pbmcoKTtcbiAgICB0aGlzLmJ1ZmZlcmluZyA9IHtcbiAgICAgIGF1ZGlvOiBnZXROZXdQZXJmb3JtYW5jZVRpbWluZygpLFxuICAgICAgdmlkZW86IGdldE5ld1BlcmZvcm1hbmNlVGltaW5nKCksXG4gICAgICBhdWRpb3ZpZGVvOiBnZXROZXdQZXJmb3JtYW5jZVRpbWluZygpXG4gICAgfTtcbiAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gICAgdGhpcy5zbiA9IHNuO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIHRoaXMucGFydCA9IHBhcnQ7XG4gICAgdGhpcy5wYXJ0aWFsID0gcGFydGlhbDtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0TmV3UGVyZm9ybWFuY2VUaW1pbmcoKSB7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IDAsXG4gICAgZXhlY3V0ZVN0YXJ0OiAwLFxuICAgIGV4ZWN1dGVFbmQ6IDAsXG4gICAgZW5kOiAwXG4gIH07XG59XG5cbi8qKlxuICogUHJvdmlkZXMgbWV0aG9kcyBkZWFsaW5nIHdpdGggYnVmZmVyIGxlbmd0aCByZXRyaWV2YWwgZm9yIGV4YW1wbGUuXG4gKlxuICogSW4gZ2VuZXJhbCwgYSBoZWxwZXIgYXJvdW5kIEhUTUw1IE1lZGlhRWxlbWVudCBUaW1lUmFuZ2VzIGdhdGhlcmVkIGZyb20gYGJ1ZmZlcmVkYCBwcm9wZXJ0eS5cbiAqXG4gKiBBbHNvIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxNZWRpYUVsZW1lbnQvYnVmZmVyZWRcbiAqL1xuXG5jb25zdCBub29wQnVmZmVyZWQgPSB7XG4gIGxlbmd0aDogMCxcbiAgc3RhcnQ6ICgpID0+IDAsXG4gIGVuZDogKCkgPT4gMFxufTtcbmNsYXNzIEJ1ZmZlckhlbHBlciB7XG4gIC8qKlxuICAgKiBSZXR1cm4gdHJ1ZSBpZiBgbWVkaWFgJ3MgYnVmZmVyZWQgaW5jbHVkZSBgcG9zaXRpb25gXG4gICAqL1xuICBzdGF0aWMgaXNCdWZmZXJlZChtZWRpYSwgcG9zaXRpb24pIHtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIGNvbnN0IGJ1ZmZlcmVkID0gQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKG1lZGlhKTtcbiAgICAgIGZvciAobGV0IGkgPSBidWZmZXJlZC5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uID49IGJ1ZmZlcmVkLnN0YXJ0KGkpICYmIHBvc2l0aW9uIDw9IGJ1ZmZlcmVkLmVuZChpKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgYnVmZmVyZWRSYW5nZXMobWVkaWEpIHtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIGNvbnN0IHRpbWVSYW5nZXMgPSBCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQobWVkaWEpO1xuICAgICAgcmV0dXJuIEJ1ZmZlckhlbHBlci50aW1lUmFuZ2VzVG9BcnJheSh0aW1lUmFuZ2VzKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHN0YXRpYyB0aW1lUmFuZ2VzVG9BcnJheSh0aW1lUmFuZ2VzKSB7XG4gICAgY29uc3QgYnVmZmVyZWQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRpbWVSYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ1ZmZlcmVkLnB1c2goe1xuICAgICAgICBzdGFydDogdGltZVJhbmdlcy5zdGFydChpKSxcbiAgICAgICAgZW5kOiB0aW1lUmFuZ2VzLmVuZChpKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXJlZDtcbiAgfVxuICBzdGF0aWMgYnVmZmVySW5mbyhtZWRpYSwgcG9zLCBtYXhIb2xlRHVyYXRpb24pIHtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIGNvbnN0IGJ1ZmZlcmVkID0gQnVmZmVySGVscGVyLmJ1ZmZlcmVkUmFuZ2VzKG1lZGlhKTtcbiAgICAgIGlmIChidWZmZXJlZC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlckhlbHBlci5idWZmZXJlZEluZm8oYnVmZmVyZWQsIHBvcywgbWF4SG9sZUR1cmF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlbjogMCxcbiAgICAgIHN0YXJ0OiBwb3MsXG4gICAgICBlbmQ6IHBvcyxcbiAgICAgIGJ1ZmZlcmVkSW5kZXg6IC0xXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgYnVmZmVyZWRJbmZvKGJ1ZmZlcmVkLCBwb3MsIG1heEhvbGVEdXJhdGlvbikge1xuICAgIHBvcyA9IE1hdGgubWF4KDAsIHBvcyk7XG4gICAgLy8gc29ydCBvbiBidWZmZXIuc3RhcnQvc21hbGxlciBlbmQgKElFIGRvZXMgbm90IGFsd2F5cyByZXR1cm4gc29ydGVkIGJ1ZmZlcmVkIHJhbmdlKVxuICAgIGlmIChidWZmZXJlZC5sZW5ndGggPiAxKSB7XG4gICAgICBidWZmZXJlZC5zb3J0KChhLCBiKSA9PiBhLnN0YXJ0IC0gYi5zdGFydCB8fCBiLmVuZCAtIGEuZW5kKTtcbiAgICB9XG4gICAgbGV0IGJ1ZmZlcmVkSW5kZXggPSAtMTtcbiAgICBsZXQgYnVmZmVyZWQyID0gW107XG4gICAgaWYgKG1heEhvbGVEdXJhdGlvbikge1xuICAgICAgLy8gdGhlcmUgbWlnaHQgYmUgc29tZSBzbWFsbCBob2xlcyBiZXR3ZWVuIGJ1ZmZlciB0aW1lIHJhbmdlXG4gICAgICAvLyBjb25zaWRlciB0aGF0IGhvbGVzIHNtYWxsZXIgdGhhbiBtYXhIb2xlRHVyYXRpb24gYXJlIGlycmVsZXZhbnQgYW5kIGJ1aWxkIGFub3RoZXJcbiAgICAgIC8vIGJ1ZmZlciB0aW1lIHJhbmdlIHJlcHJlc2VudGF0aW9ucyB0aGF0IGRpc2NhcmRzIHRob3NlIGhvbGVzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChwb3MgPj0gYnVmZmVyZWRbaV0uc3RhcnQgJiYgcG9zIDw9IGJ1ZmZlcmVkW2ldLmVuZCkge1xuICAgICAgICAgIGJ1ZmZlcmVkSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1ZjJsZW4gPSBidWZmZXJlZDIubGVuZ3RoO1xuICAgICAgICBpZiAoYnVmMmxlbikge1xuICAgICAgICAgIGNvbnN0IGJ1ZjJlbmQgPSBidWZmZXJlZDJbYnVmMmxlbiAtIDFdLmVuZDtcbiAgICAgICAgICAvLyBpZiBzbWFsbCBob2xlICh2YWx1ZSBiZXR3ZWVuIDAgb3IgbWF4SG9sZUR1cmF0aW9uICkgb3Igb3ZlcmxhcHBpbmcgKG5lZ2F0aXZlKVxuICAgICAgICAgIGlmIChidWZmZXJlZFtpXS5zdGFydCAtIGJ1ZjJlbmQgPCBtYXhIb2xlRHVyYXRpb24pIHtcbiAgICAgICAgICAgIC8vIG1lcmdlIG92ZXJsYXBwaW5nIHRpbWUgcmFuZ2VzXG4gICAgICAgICAgICAvLyB1cGRhdGUgbGFzdFJhbmdlLmVuZCBvbmx5IGlmIHNtYWxsZXIgdGhhbiBpdGVtLmVuZFxuICAgICAgICAgICAgLy8gZS5nLiAgWyAxLCAxNV0gd2l0aCAgWyAyLDhdID0+IFsgMSwxNV0gKG5vIG5lZWQgdG8gbW9kaWZ5IGxhc3RSYW5nZS5lbmQpXG4gICAgICAgICAgICAvLyB3aGVyZWFzIFsgMSwgOF0gd2l0aCAgWyAyLDE1XSA9PiBbIDEsMTVdICggbGFzdFJhbmdlIHNob3VsZCBzd2l0Y2ggZnJvbSBbMSw4XSB0byBbMSwxNV0pXG4gICAgICAgICAgICBpZiAoYnVmZmVyZWRbaV0uZW5kID4gYnVmMmVuZCkge1xuICAgICAgICAgICAgICBidWZmZXJlZDJbYnVmMmxlbiAtIDFdLmVuZCA9IGJ1ZmZlcmVkW2ldLmVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gYmlnIGhvbGVcbiAgICAgICAgICAgIGJ1ZmZlcmVkMi5wdXNoKGJ1ZmZlcmVkW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZmlyc3QgdmFsdWVcbiAgICAgICAgICBidWZmZXJlZDIucHVzaChidWZmZXJlZFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYnVmZmVyZWQyID0gYnVmZmVyZWQ7XG4gICAgfVxuICAgIGxldCBidWZmZXJMZW4gPSAwO1xuICAgIGxldCBuZXh0U3RhcnQ7XG5cbiAgICAvLyBidWZmZXJTdGFydCBhbmQgYnVmZmVyRW5kIGFyZSBidWZmZXIgYm91bmRhcmllcyBhcm91bmQgY3VycmVudCBwbGF5YmFjayBwb3NpdGlvbiAocG9zKVxuICAgIGxldCBidWZmZXJTdGFydCA9IHBvcztcbiAgICBsZXQgYnVmZmVyRW5kID0gcG9zO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyZWQyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdGFydCA9IGJ1ZmZlcmVkMltpXS5zdGFydDtcbiAgICAgIGNvbnN0IGVuZCA9IGJ1ZmZlcmVkMltpXS5lbmQ7XG4gICAgICAvLyBsb2dnZXIubG9nKCdidWYgc3RhcnQvZW5kOicgKyBidWZmZXJlZC5zdGFydChpKSArICcvJyArIGJ1ZmZlcmVkLmVuZChpKSk7XG4gICAgICBpZiAoYnVmZmVyZWRJbmRleCA9PT0gLTEgJiYgcG9zID49IHN0YXJ0ICYmIHBvcyA8PSBlbmQpIHtcbiAgICAgICAgYnVmZmVyZWRJbmRleCA9IGk7XG4gICAgICB9XG4gICAgICBpZiAocG9zICsgbWF4SG9sZUR1cmF0aW9uID49IHN0YXJ0ICYmIHBvcyA8IGVuZCkge1xuICAgICAgICAvLyBwbGF5IHBvc2l0aW9uIGlzIGluc2lkZSB0aGlzIGJ1ZmZlciBUaW1lUmFuZ2UsIHJldHJpZXZlIGVuZCBvZiBidWZmZXIgcG9zaXRpb24gYW5kIGJ1ZmZlciBsZW5ndGhcbiAgICAgICAgYnVmZmVyU3RhcnQgPSBzdGFydDtcbiAgICAgICAgYnVmZmVyRW5kID0gZW5kO1xuICAgICAgICBidWZmZXJMZW4gPSBidWZmZXJFbmQgLSBwb3M7XG4gICAgICB9IGVsc2UgaWYgKHBvcyArIG1heEhvbGVEdXJhdGlvbiA8IHN0YXJ0KSB7XG4gICAgICAgIG5leHRTdGFydCA9IHN0YXJ0O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlbjogYnVmZmVyTGVuLFxuICAgICAgc3RhcnQ6IGJ1ZmZlclN0YXJ0IHx8IDAsXG4gICAgICBlbmQ6IGJ1ZmZlckVuZCB8fCAwLFxuICAgICAgbmV4dFN0YXJ0LFxuICAgICAgYnVmZmVyZWQsXG4gICAgICBidWZmZXJlZEluZGV4XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTYWZlIG1ldGhvZCB0byBnZXQgYnVmZmVyZWQgcHJvcGVydHkuXG4gICAqIFNvdXJjZUJ1ZmZlci5idWZmZXJlZCBtYXkgdGhyb3cgaWYgU291cmNlQnVmZmVyIGlzIHJlbW92ZWQgZnJvbSBpdCdzIE1lZGlhU291cmNlXG4gICAqL1xuICBzdGF0aWMgZ2V0QnVmZmVyZWQobWVkaWEpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG1lZGlhLmJ1ZmZlcmVkIHx8IG5vb3BCdWZmZXJlZDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnZXIubG9nKCdmYWlsZWQgdG8gZ2V0IG1lZGlhLmJ1ZmZlcmVkJywgZSk7XG4gICAgICByZXR1cm4gbm9vcEJ1ZmZlcmVkO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBWQVJJQUJMRV9SRVBMQUNFTUVOVF9SRUdFWCA9IC9cXHtcXCQoW2EtekEtWjAtOS1fXSspXFx9L2c7XG5mdW5jdGlvbiBoYXNWYXJpYWJsZVJlZmVyZW5jZXMoc3RyKSB7XG4gIHJldHVybiBWQVJJQUJMRV9SRVBMQUNFTUVOVF9SRUdFWC50ZXN0KHN0cik7XG59XG5mdW5jdGlvbiBzdWJzdGl0dXRlVmFyaWFibGVzKHBhcnNlZCwgdmFsdWUpIHtcbiAgaWYgKHBhcnNlZC52YXJpYWJsZUxpc3QgIT09IG51bGwgfHwgcGFyc2VkLmhhc1ZhcmlhYmxlUmVmcykge1xuICAgIGNvbnN0IHZhcmlhYmxlTGlzdCA9IHBhcnNlZC52YXJpYWJsZUxpc3Q7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoVkFSSUFCTEVfUkVQTEFDRU1FTlRfUkVHRVgsIHZhcmlhYmxlUmVmZXJlbmNlID0+IHtcbiAgICAgIGNvbnN0IHZhcmlhYmxlTmFtZSA9IHZhcmlhYmxlUmVmZXJlbmNlLnN1YnN0cmluZygyLCB2YXJpYWJsZVJlZmVyZW5jZS5sZW5ndGggLSAxKTtcbiAgICAgIGNvbnN0IHZhcmlhYmxlVmFsdWUgPSB2YXJpYWJsZUxpc3QgPT0gbnVsbCA/IHZvaWQgMCA6IHZhcmlhYmxlTGlzdFt2YXJpYWJsZU5hbWVdO1xuICAgICAgaWYgKHZhcmlhYmxlVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXJzZWQucGxheWxpc3RQYXJzaW5nRXJyb3IgfHwgKHBhcnNlZC5wbGF5bGlzdFBhcnNpbmdFcnJvciA9IG5ldyBFcnJvcihgTWlzc2luZyBwcmVjZWRpbmcgRVhULVgtREVGSU5FIHRhZyBmb3IgVmFyaWFibGUgUmVmZXJlbmNlOiBcIiR7dmFyaWFibGVOYW1lfVwiYCkpO1xuICAgICAgICByZXR1cm4gdmFyaWFibGVSZWZlcmVuY2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFyaWFibGVWYWx1ZTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBhZGRWYXJpYWJsZURlZmluaXRpb24ocGFyc2VkLCBhdHRyLCBwYXJlbnRVcmwpIHtcbiAgbGV0IHZhcmlhYmxlTGlzdCA9IHBhcnNlZC52YXJpYWJsZUxpc3Q7XG4gIGlmICghdmFyaWFibGVMaXN0KSB7XG4gICAgcGFyc2VkLnZhcmlhYmxlTGlzdCA9IHZhcmlhYmxlTGlzdCA9IHt9O1xuICB9XG4gIGxldCBOQU1FO1xuICBsZXQgVkFMVUU7XG4gIGlmICgnUVVFUllQQVJBTScgaW4gYXR0cikge1xuICAgIE5BTUUgPSBhdHRyLlFVRVJZUEFSQU07XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IG5ldyBzZWxmLlVSTChwYXJlbnRVcmwpLnNlYXJjaFBhcmFtcztcbiAgICAgIGlmIChzZWFyY2hQYXJhbXMuaGFzKE5BTUUpKSB7XG4gICAgICAgIFZBTFVFID0gc2VhcmNoUGFyYW1zLmdldChOQU1FKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke05BTUV9XCIgZG9lcyBub3QgbWF0Y2ggYW55IHF1ZXJ5IHBhcmFtZXRlciBpbiBVUkk6IFwiJHtwYXJlbnRVcmx9XCJgKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcGFyc2VkLnBsYXlsaXN0UGFyc2luZ0Vycm9yIHx8IChwYXJzZWQucGxheWxpc3RQYXJzaW5nRXJyb3IgPSBuZXcgRXJyb3IoYEVYVC1YLURFRklORSBRVUVSWVBBUkFNOiAke2Vycm9yLm1lc3NhZ2V9YCkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBOQU1FID0gYXR0ci5OQU1FO1xuICAgIFZBTFVFID0gYXR0ci5WQUxVRTtcbiAgfVxuICBpZiAoTkFNRSBpbiB2YXJpYWJsZUxpc3QpIHtcbiAgICBwYXJzZWQucGxheWxpc3RQYXJzaW5nRXJyb3IgfHwgKHBhcnNlZC5wbGF5bGlzdFBhcnNpbmdFcnJvciA9IG5ldyBFcnJvcihgRVhULVgtREVGSU5FIGR1cGxpY2F0ZSBWYXJpYWJsZSBOYW1lIGRlY2xhcmF0aW9uczogXCIke05BTUV9XCJgKSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyaWFibGVMaXN0W05BTUVdID0gVkFMVUUgfHwgJyc7XG4gIH1cbn1cbmZ1bmN0aW9uIGltcG9ydFZhcmlhYmxlRGVmaW5pdGlvbihwYXJzZWQsIGF0dHIsIHNvdXJjZVZhcmlhYmxlTGlzdCkge1xuICBjb25zdCBJTVBPUlQgPSBhdHRyLklNUE9SVDtcbiAgaWYgKHNvdXJjZVZhcmlhYmxlTGlzdCAmJiBJTVBPUlQgaW4gc291cmNlVmFyaWFibGVMaXN0KSB7XG4gICAgbGV0IHZhcmlhYmxlTGlzdCA9IHBhcnNlZC52YXJpYWJsZUxpc3Q7XG4gICAgaWYgKCF2YXJpYWJsZUxpc3QpIHtcbiAgICAgIHBhcnNlZC52YXJpYWJsZUxpc3QgPSB2YXJpYWJsZUxpc3QgPSB7fTtcbiAgICB9XG4gICAgdmFyaWFibGVMaXN0W0lNUE9SVF0gPSBzb3VyY2VWYXJpYWJsZUxpc3RbSU1QT1JUXTtcbiAgfSBlbHNlIHtcbiAgICBwYXJzZWQucGxheWxpc3RQYXJzaW5nRXJyb3IgfHwgKHBhcnNlZC5wbGF5bGlzdFBhcnNpbmdFcnJvciA9IG5ldyBFcnJvcihgRVhULVgtREVGSU5FIElNUE9SVCBhdHRyaWJ1dGUgbm90IGZvdW5kIGluIE11bHRpdmFyaWFudCBQbGF5bGlzdDogXCIke0lNUE9SVH1cImApKTtcbiAgfVxufVxuXG5jb25zdCBERUNJTUFMX1JFU09MVVRJT05fUkVHRVggPSAvXihcXGQrKXgoXFxkKykkLztcbmNvbnN0IEFUVFJfTElTVF9SRUdFWCA9IC8oLis/KT0oXCIuKj9cInwuKj8pKD86LHwkKS9nO1xuXG4vLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2thbm9uZ2lsL25vZGUtbTN1OHBhcnNlL2Jsb2IvbWFzdGVyL2F0dHJsaXN0LmpzXG5jbGFzcyBBdHRyTGlzdCB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzLCBwYXJzZWQpIHtcbiAgICBpZiAodHlwZW9mIGF0dHJzID09PSAnc3RyaW5nJykge1xuICAgICAgYXR0cnMgPSBBdHRyTGlzdC5wYXJzZUF0dHJMaXN0KGF0dHJzLCBwYXJzZWQpO1xuICAgIH1cbiAgICBfZXh0ZW5kcyh0aGlzLCBhdHRycyk7XG4gIH1cbiAgZ2V0IGNsaWVudEF0dHJzKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzKS5maWx0ZXIoYXR0ciA9PiBhdHRyLnN1YnN0cmluZygwLCAyKSA9PT0gJ1gtJyk7XG4gIH1cbiAgZGVjaW1hbEludGVnZXIoYXR0ck5hbWUpIHtcbiAgICBjb25zdCBpbnRWYWx1ZSA9IHBhcnNlSW50KHRoaXNbYXR0ck5hbWVdLCAxMCk7XG4gICAgaWYgKGludFZhbHVlID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgcmV0dXJuIGludFZhbHVlO1xuICB9XG4gIGhleGFkZWNpbWFsSW50ZWdlcihhdHRyTmFtZSkge1xuICAgIGlmICh0aGlzW2F0dHJOYW1lXSkge1xuICAgICAgbGV0IHN0cmluZ1ZhbHVlID0gKHRoaXNbYXR0ck5hbWVdIHx8ICcweCcpLnNsaWNlKDIpO1xuICAgICAgc3RyaW5nVmFsdWUgPSAoc3RyaW5nVmFsdWUubGVuZ3RoICYgMSA/ICcwJyA6ICcnKSArIHN0cmluZ1ZhbHVlO1xuICAgICAgY29uc3QgdmFsdWUgPSBuZXcgVWludDhBcnJheShzdHJpbmdWYWx1ZS5sZW5ndGggLyAyKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaW5nVmFsdWUubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICAgIHZhbHVlW2ldID0gcGFyc2VJbnQoc3RyaW5nVmFsdWUuc2xpY2UoaSAqIDIsIGkgKiAyICsgMiksIDE2KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaGV4YWRlY2ltYWxJbnRlZ2VyQXNOdW1iZXIoYXR0ck5hbWUpIHtcbiAgICBjb25zdCBpbnRWYWx1ZSA9IHBhcnNlSW50KHRoaXNbYXR0ck5hbWVdLCAxNik7XG4gICAgaWYgKGludFZhbHVlID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgcmV0dXJuIGludFZhbHVlO1xuICB9XG4gIGRlY2ltYWxGbG9hdGluZ1BvaW50KGF0dHJOYW1lKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodGhpc1thdHRyTmFtZV0pO1xuICB9XG4gIG9wdGlvbmFsRmxvYXQoYXR0ck5hbWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpc1thdHRyTmFtZV07XG4gICAgcmV0dXJuIHZhbHVlID8gcGFyc2VGbG9hdCh2YWx1ZSkgOiBkZWZhdWx0VmFsdWU7XG4gIH1cbiAgZW51bWVyYXRlZFN0cmluZyhhdHRyTmFtZSkge1xuICAgIHJldHVybiB0aGlzW2F0dHJOYW1lXTtcbiAgfVxuICBlbnVtZXJhdGVkU3RyaW5nTGlzdChhdHRyTmFtZSwgZGljdCkge1xuICAgIGNvbnN0IGF0dHJWYWx1ZSA9IHRoaXNbYXR0ck5hbWVdO1xuICAgIHJldHVybiAoYXR0clZhbHVlID8gYXR0clZhbHVlLnNwbGl0KC9bICxdKy8pIDogW10pLnJlZHVjZSgocmVzdWx0LCBpZGVudGlmaWVyKSA9PiB7XG4gICAgICByZXN1bHRbaWRlbnRpZmllci50b0xvd2VyQ2FzZSgpXSA9IHRydWU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIGRpY3QpO1xuICB9XG4gIGJvb2woYXR0ck5hbWUpIHtcbiAgICByZXR1cm4gdGhpc1thdHRyTmFtZV0gPT09ICdZRVMnO1xuICB9XG4gIGRlY2ltYWxSZXNvbHV0aW9uKGF0dHJOYW1lKSB7XG4gICAgY29uc3QgcmVzID0gREVDSU1BTF9SRVNPTFVUSU9OX1JFR0VYLmV4ZWModGhpc1thdHRyTmFtZV0pO1xuICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogcGFyc2VJbnQocmVzWzFdLCAxMCksXG4gICAgICBoZWlnaHQ6IHBhcnNlSW50KHJlc1syXSwgMTApXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgcGFyc2VBdHRyTGlzdChpbnB1dCwgcGFyc2VkKSB7XG4gICAgbGV0IG1hdGNoO1xuICAgIGNvbnN0IGF0dHJzID0ge307XG4gICAgY29uc3QgcXVvdGUgPSAnXCInO1xuICAgIEFUVFJfTElTVF9SRUdFWC5sYXN0SW5kZXggPSAwO1xuICAgIHdoaWxlICgobWF0Y2ggPSBBVFRSX0xJU1RfUkVHRVguZXhlYyhpbnB1dCkpICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBuYW1lID0gbWF0Y2hbMV0udHJpbSgpO1xuICAgICAgbGV0IHZhbHVlID0gbWF0Y2hbMl07XG4gICAgICBjb25zdCBxdW90ZWRTdHJpbmcgPSB2YWx1ZS5pbmRleE9mKHF1b3RlKSA9PT0gMCAmJiB2YWx1ZS5sYXN0SW5kZXhPZihxdW90ZSkgPT09IHZhbHVlLmxlbmd0aCAtIDE7XG4gICAgICBsZXQgaGV4YWRlY2ltYWxTZXF1ZW5jZSA9IGZhbHNlO1xuICAgICAgaWYgKHF1b3RlZFN0cmluZykge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEsIC0xKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgIGNhc2UgJ0lWJzpcbiAgICAgICAgICBjYXNlICdTQ1RFMzUtQ01EJzpcbiAgICAgICAgICBjYXNlICdTQ1RFMzUtSU4nOlxuICAgICAgICAgIGNhc2UgJ1NDVEUzNS1PVVQnOlxuICAgICAgICAgICAgaGV4YWRlY2ltYWxTZXF1ZW5jZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwYXJzZWQgJiYgKHF1b3RlZFN0cmluZyB8fCBoZXhhZGVjaW1hbFNlcXVlbmNlKSkge1xuICAgICAgICB7XG4gICAgICAgICAgdmFsdWUgPSBzdWJzdGl0dXRlVmFyaWFibGVzKHBhcnNlZCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFoZXhhZGVjaW1hbFNlcXVlbmNlICYmICFxdW90ZWRTdHJpbmcpIHtcbiAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgY2FzZSAnQ0xPU0VELUNBUFRJT05TJzpcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJ05PTkUnKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgICBjYXNlICdBTExPV0VELUNQQyc6XG4gICAgICAgICAgY2FzZSAnQ0xBU1MnOlxuICAgICAgICAgIGNhc2UgJ0FTU09DLUxBTkdVQUdFJzpcbiAgICAgICAgICBjYXNlICdBVURJTyc6XG4gICAgICAgICAgY2FzZSAnQllURVJBTkdFJzpcbiAgICAgICAgICBjYXNlICdDSEFOTkVMUyc6XG4gICAgICAgICAgY2FzZSAnQ0hBUkFDVEVSSVNUSUNTJzpcbiAgICAgICAgICBjYXNlICdDT0RFQ1MnOlxuICAgICAgICAgIGNhc2UgJ0RBVEEtSUQnOlxuICAgICAgICAgIGNhc2UgJ0VORC1EQVRFJzpcbiAgICAgICAgICBjYXNlICdHUk9VUC1JRCc6XG4gICAgICAgICAgY2FzZSAnSUQnOlxuICAgICAgICAgIGNhc2UgJ0lNUE9SVCc6XG4gICAgICAgICAgY2FzZSAnSU5TVFJFQU0tSUQnOlxuICAgICAgICAgIGNhc2UgJ0tFWUZPUk1BVCc6XG4gICAgICAgICAgY2FzZSAnS0VZRk9STUFUVkVSU0lPTlMnOlxuICAgICAgICAgIGNhc2UgJ0xBTkdVQUdFJzpcbiAgICAgICAgICBjYXNlICdOQU1FJzpcbiAgICAgICAgICBjYXNlICdQQVRIV0FZLUlEJzpcbiAgICAgICAgICBjYXNlICdRVUVSWVBBUkFNJzpcbiAgICAgICAgICBjYXNlICdSRUNFTlRMWS1SRU1PVkVELURBVEVSQU5HRVMnOlxuICAgICAgICAgIGNhc2UgJ1NFUlZFUi1VUkknOlxuICAgICAgICAgIGNhc2UgJ1NUQUJMRS1SRU5ESVRJT04tSUQnOlxuICAgICAgICAgIGNhc2UgJ1NUQUJMRS1WQVJJQU5ULUlEJzpcbiAgICAgICAgICBjYXNlICdTVEFSVC1EQVRFJzpcbiAgICAgICAgICBjYXNlICdTVUJUSVRMRVMnOlxuICAgICAgICAgIGNhc2UgJ1NVUFBMRU1FTlRBTC1DT0RFQ1MnOlxuICAgICAgICAgIGNhc2UgJ1VSSSc6XG4gICAgICAgICAgY2FzZSAnVkFMVUUnOlxuICAgICAgICAgIGNhc2UgJ1ZJREVPJzpcbiAgICAgICAgICBjYXNlICdYLUFTU0VULUxJU1QnOlxuICAgICAgICAgIGNhc2UgJ1gtQVNTRVQtVVJJJzpcbiAgICAgICAgICAgIC8vIFNpbmNlIHdlIGFyZSBub3QgY2hlY2tpbmcgdGFnOmF0dHJpYnV0ZSBjb21iaW5hdGlvbiwganVzdCB3YXJuIHJhdGhlciB0aGFuIGlnbm9yaW5nIGF0dHJpYnV0ZVxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYCR7aW5wdXR9OiBhdHRyaWJ1dGUgJHtuYW1lfSBpcyBtaXNzaW5nIHF1b3Rlc2ApO1xuICAgICAgICAgIC8vIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhdHRyc1tuYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gYXR0cnM7XG4gIH1cbn1cblxuLy8gQXZvaWQgZXhwb3J0aW5nIGNvbnN0IGVudW0gc28gdGhhdCB0aGVzZSB2YWx1ZXMgY2FuIGJlIGlubGluZWRcblxuY29uc3QgQ0xBU1NfSU5URVJTVElUSUFMID0gJ2NvbS5hcHBsZS5obHMuaW50ZXJzdGl0aWFsJztcbmZ1bmN0aW9uIGlzRGF0ZVJhbmdlQ3VlQXR0cmlidXRlKGF0dHJOYW1lKSB7XG4gIHJldHVybiBhdHRyTmFtZSAhPT0gXCJJRFwiICYmIGF0dHJOYW1lICE9PSBcIkNMQVNTXCIgJiYgYXR0ck5hbWUgIT09IFwiQ1VFXCIgJiYgYXR0ck5hbWUgIT09IFwiU1RBUlQtREFURVwiICYmIGF0dHJOYW1lICE9PSBcIkRVUkFUSU9OXCIgJiYgYXR0ck5hbWUgIT09IFwiRU5ELURBVEVcIiAmJiBhdHRyTmFtZSAhPT0gXCJFTkQtT04tTkVYVFwiO1xufVxuZnVuY3Rpb24gaXNTQ1RFMzVBdHRyaWJ1dGUoYXR0ck5hbWUpIHtcbiAgcmV0dXJuIGF0dHJOYW1lID09PSBcIlNDVEUzNS1PVVRcIiB8fCBhdHRyTmFtZSA9PT0gXCJTQ1RFMzUtSU5cIiB8fCBhdHRyTmFtZSA9PT0gXCJTQ1RFMzUtQ01EXCI7XG59XG5jbGFzcyBEYXRlUmFuZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRlUmFuZ2VBdHRyLCBkYXRlUmFuZ2VXaXRoU2FtZUlkLCB0YWdDb3VudCA9IDApIHtcbiAgICB2YXIgX2RhdGVSYW5nZVdpdGhTYW1lSWQkO1xuICAgIHRoaXMuYXR0ciA9IHZvaWQgMDtcbiAgICB0aGlzLnRhZ0FuY2hvciA9IHZvaWQgMDtcbiAgICB0aGlzLnRhZ09yZGVyID0gdm9pZCAwO1xuICAgIHRoaXMuX3N0YXJ0RGF0ZSA9IHZvaWQgMDtcbiAgICB0aGlzLl9lbmREYXRlID0gdm9pZCAwO1xuICAgIHRoaXMuX2RhdGVBdEVuZCA9IHZvaWQgMDtcbiAgICB0aGlzLl9jdWUgPSB2b2lkIDA7XG4gICAgdGhpcy5fYmFkVmFsdWVGb3JTYW1lSWQgPSB2b2lkIDA7XG4gICAgdGhpcy50YWdBbmNob3IgPSAoZGF0ZVJhbmdlV2l0aFNhbWVJZCA9PSBudWxsID8gdm9pZCAwIDogZGF0ZVJhbmdlV2l0aFNhbWVJZC50YWdBbmNob3IpIHx8IG51bGw7XG4gICAgdGhpcy50YWdPcmRlciA9IChfZGF0ZVJhbmdlV2l0aFNhbWVJZCQgPSBkYXRlUmFuZ2VXaXRoU2FtZUlkID09IG51bGwgPyB2b2lkIDAgOiBkYXRlUmFuZ2VXaXRoU2FtZUlkLnRhZ09yZGVyKSAhPSBudWxsID8gX2RhdGVSYW5nZVdpdGhTYW1lSWQkIDogdGFnQ291bnQ7XG4gICAgaWYgKGRhdGVSYW5nZVdpdGhTYW1lSWQpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzQXR0ciA9IGRhdGVSYW5nZVdpdGhTYW1lSWQuYXR0cjtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHByZXZpb3VzQXR0cikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGVSYW5nZUF0dHIsIGtleSkgJiYgZGF0ZVJhbmdlQXR0cltrZXldICE9PSBwcmV2aW91c0F0dHJba2V5XSkge1xuICAgICAgICAgIGxvZ2dlci53YXJuKGBEQVRFUkFOR0UgdGFnIGF0dHJpYnV0ZTogXCIke2tleX1cIiBkb2VzIG5vdCBtYXRjaCBmb3IgdGFncyB3aXRoIElEOiBcIiR7ZGF0ZVJhbmdlQXR0ci5JRH1cImApO1xuICAgICAgICAgIHRoaXMuX2JhZFZhbHVlRm9yU2FtZUlkID0ga2V5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBNZXJnZSBEYXRlUmFuZ2UgdGFncyB3aXRoIHRoZSBzYW1lIElEXG4gICAgICBkYXRlUmFuZ2VBdHRyID0gX2V4dGVuZHMobmV3IEF0dHJMaXN0KHt9KSwgcHJldmlvdXNBdHRyLCBkYXRlUmFuZ2VBdHRyKTtcbiAgICB9XG4gICAgdGhpcy5hdHRyID0gZGF0ZVJhbmdlQXR0cjtcbiAgICBpZiAoZGF0ZVJhbmdlV2l0aFNhbWVJZCkge1xuICAgICAgdGhpcy5fc3RhcnREYXRlID0gZGF0ZVJhbmdlV2l0aFNhbWVJZC5fc3RhcnREYXRlO1xuICAgICAgdGhpcy5fY3VlID0gZGF0ZVJhbmdlV2l0aFNhbWVJZC5fY3VlO1xuICAgICAgdGhpcy5fZW5kRGF0ZSA9IGRhdGVSYW5nZVdpdGhTYW1lSWQuX2VuZERhdGU7XG4gICAgICB0aGlzLl9kYXRlQXRFbmQgPSBkYXRlUmFuZ2VXaXRoU2FtZUlkLl9kYXRlQXRFbmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3N0YXJ0RGF0ZSA9IG5ldyBEYXRlKGRhdGVSYW5nZUF0dHJbXCJTVEFSVC1EQVRFXCJdKTtcbiAgICB9XG4gICAgaWYgKFwiRU5ELURBVEVcIiBpbiB0aGlzLmF0dHIpIHtcbiAgICAgIGNvbnN0IGVuZERhdGUgPSAoZGF0ZVJhbmdlV2l0aFNhbWVJZCA9PSBudWxsID8gdm9pZCAwIDogZGF0ZVJhbmdlV2l0aFNhbWVJZC5lbmREYXRlKSB8fCBuZXcgRGF0ZSh0aGlzLmF0dHJbXCJFTkQtREFURVwiXSk7XG4gICAgICBpZiAoaXNGaW5pdGVOdW1iZXIoZW5kRGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgICAgIHRoaXMuX2VuZERhdGUgPSBlbmREYXRlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0ci5JRDtcbiAgfVxuICBnZXQgY2xhc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0ci5DTEFTUztcbiAgfVxuICBnZXQgY3VlKCkge1xuICAgIGNvbnN0IF9jdWUgPSB0aGlzLl9jdWU7XG4gICAgaWYgKF9jdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2N1ZSA9IHRoaXMuYXR0ci5lbnVtZXJhdGVkU3RyaW5nTGlzdCh0aGlzLmF0dHIuQ1VFID8gJ0NVRScgOiAnWC1DVUUnLCB7XG4gICAgICAgIHByZTogZmFsc2UsXG4gICAgICAgIHBvc3Q6IGZhbHNlLFxuICAgICAgICBvbmNlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBfY3VlO1xuICB9XG4gIGdldCBzdGFydFRpbWUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdGFnQW5jaG9yXG4gICAgfSA9IHRoaXM7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItb3B0aW9uYWwtY2hhaW5cbiAgICBpZiAodGFnQW5jaG9yID09PSBudWxsIHx8IHRhZ0FuY2hvci5wcm9ncmFtRGF0ZVRpbWUgPT09IG51bGwpIHtcbiAgICAgIGxvZ2dlci53YXJuKGBFeHBlY3RlZCB0YWdBbmNob3IgRnJhZ21lbnQgd2l0aCBQRFQgc2V0IGZvciBEYXRlUmFuZ2UgXCIke3RoaXMuaWR9XCI6ICR7dGFnQW5jaG9yfWApO1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgcmV0dXJuIHRhZ0FuY2hvci5zdGFydCArICh0aGlzLnN0YXJ0RGF0ZS5nZXRUaW1lKCkgLSB0YWdBbmNob3IucHJvZ3JhbURhdGVUaW1lKSAvIDEwMDA7XG4gIH1cbiAgZ2V0IHN0YXJ0RGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhcnREYXRlO1xuICB9XG4gIGdldCBlbmREYXRlKCkge1xuICAgIGNvbnN0IGRhdGVBdEVuZCA9IHRoaXMuX2VuZERhdGUgfHwgdGhpcy5fZGF0ZUF0RW5kO1xuICAgIGlmIChkYXRlQXRFbmQpIHtcbiAgICAgIHJldHVybiBkYXRlQXRFbmQ7XG4gICAgfVxuICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5kdXJhdGlvbjtcbiAgICBpZiAoZHVyYXRpb24gIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kYXRlQXRFbmQgPSBuZXcgRGF0ZSh0aGlzLl9zdGFydERhdGUuZ2V0VGltZSgpICsgZHVyYXRpb24gKiAxMDAwKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2V0IGR1cmF0aW9uKCkge1xuICAgIGlmIChcIkRVUkFUSU9OXCIgaW4gdGhpcy5hdHRyKSB7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IHRoaXMuYXR0ci5kZWNpbWFsRmxvYXRpbmdQb2ludChcIkRVUkFUSU9OXCIpO1xuICAgICAgaWYgKGlzRmluaXRlTnVtYmVyKGR1cmF0aW9uKSkge1xuICAgICAgICByZXR1cm4gZHVyYXRpb247XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9lbmREYXRlKSB7XG4gICAgICByZXR1cm4gKHRoaXMuX2VuZERhdGUuZ2V0VGltZSgpIC0gdGhpcy5fc3RhcnREYXRlLmdldFRpbWUoKSkgLyAxMDAwO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnZXQgcGxhbm5lZER1cmF0aW9uKCkge1xuICAgIGlmIChcIlBMQU5ORUQtRFVSQVRJT05cIiBpbiB0aGlzLmF0dHIpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHIuZGVjaW1hbEZsb2F0aW5nUG9pbnQoXCJQTEFOTkVELURVUkFUSU9OXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnZXQgZW5kT25OZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmF0dHIuYm9vbChcIkVORC1PTi1ORVhUXCIpO1xuICB9XG4gIGdldCBpc0ludGVyc3RpdGlhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5jbGFzcyA9PT0gQ0xBU1NfSU5URVJTVElUSUFMO1xuICB9XG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiAhIXRoaXMuaWQgJiYgIXRoaXMuX2JhZFZhbHVlRm9yU2FtZUlkICYmIGlzRmluaXRlTnVtYmVyKHRoaXMuc3RhcnREYXRlLmdldFRpbWUoKSkgJiYgKHRoaXMuZHVyYXRpb24gPT09IG51bGwgfHwgdGhpcy5kdXJhdGlvbiA+PSAwKSAmJiAoIXRoaXMuZW5kT25OZXh0IHx8ICEhdGhpcy5jbGFzcykgJiYgKCF0aGlzLmF0dHIuQ1VFIHx8ICF0aGlzLmN1ZS5wcmUgJiYgIXRoaXMuY3VlLnBvc3QgfHwgdGhpcy5jdWUucHJlICE9PSB0aGlzLmN1ZS5wb3N0KSAmJiAoIXRoaXMuaXNJbnRlcnN0aXRpYWwgfHwgJ1gtQVNTRVQtVVJJJyBpbiB0aGlzLmF0dHIgfHwgJ1gtQVNTRVQtTElTVCcgaW4gdGhpcy5hdHRyKTtcbiAgfVxufVxuXG5jb25zdCBERUZBVUxUX1RBUkdFVF9EVVJBVElPTiA9IDEwO1xuXG4vKipcbiAqIE9iamVjdCByZXByZXNlbnRpbmcgcGFyc2VkIGRhdGEgZnJvbSBhbiBITFMgTWVkaWEgUGxheWxpc3QuIEZvdW5kIGluIHtAbGluayBobHMuanMjTGV2ZWwuZGV0YWlsc30uXG4gKi9cbmNsYXNzIExldmVsRGV0YWlscyB7XG4gIGNvbnN0cnVjdG9yKGJhc2VVcmwpIHtcbiAgICB0aGlzLlBUU0tub3duID0gZmFsc2U7XG4gICAgdGhpcy5hbGlnbmVkU2xpZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuYXZlcmFnZXRhcmdldGR1cmF0aW9uID0gdm9pZCAwO1xuICAgIHRoaXMuZW5kQ0MgPSAwO1xuICAgIHRoaXMuZW5kU04gPSAwO1xuICAgIHRoaXMuZnJhZ21lbnRzID0gdm9pZCAwO1xuICAgIHRoaXMuZnJhZ21lbnRIaW50ID0gdm9pZCAwO1xuICAgIHRoaXMucGFydExpc3QgPSBudWxsO1xuICAgIHRoaXMuZGF0ZVJhbmdlcyA9IHZvaWQgMDtcbiAgICB0aGlzLmRhdGVSYW5nZVRhZ0NvdW50ID0gMDtcbiAgICB0aGlzLmxpdmUgPSB0cnVlO1xuICAgIHRoaXMucmVxdWVzdFNjaGVkdWxlZCA9IC0xO1xuICAgIHRoaXMuYWdlSGVhZGVyID0gMDtcbiAgICB0aGlzLmFkdmFuY2VkRGF0ZVRpbWUgPSB2b2lkIDA7XG4gICAgdGhpcy51cGRhdGVkID0gdHJ1ZTtcbiAgICB0aGlzLmFkdmFuY2VkID0gdHJ1ZTtcbiAgICB0aGlzLm1pc3NlcyA9IDA7XG4gICAgdGhpcy5zdGFydENDID0gMDtcbiAgICB0aGlzLnN0YXJ0U04gPSAwO1xuICAgIHRoaXMuc3RhcnRUaW1lT2Zmc2V0ID0gbnVsbDtcbiAgICB0aGlzLnRhcmdldGR1cmF0aW9uID0gMDtcbiAgICB0aGlzLnRvdGFsZHVyYXRpb24gPSAwO1xuICAgIHRoaXMudHlwZSA9IG51bGw7XG4gICAgdGhpcy51cmwgPSB2b2lkIDA7XG4gICAgdGhpcy5tM3U4ID0gJyc7XG4gICAgdGhpcy52ZXJzaW9uID0gbnVsbDtcbiAgICB0aGlzLmNhbkJsb2NrUmVsb2FkID0gZmFsc2U7XG4gICAgdGhpcy5jYW5Ta2lwVW50aWwgPSAwO1xuICAgIHRoaXMuY2FuU2tpcERhdGVSYW5nZXMgPSBmYWxzZTtcbiAgICB0aGlzLnNraXBwZWRTZWdtZW50cyA9IDA7XG4gICAgdGhpcy5yZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzID0gdm9pZCAwO1xuICAgIHRoaXMucGFydEhvbGRCYWNrID0gMDtcbiAgICB0aGlzLmhvbGRCYWNrID0gMDtcbiAgICB0aGlzLnBhcnRUYXJnZXQgPSAwO1xuICAgIHRoaXMucHJlbG9hZEhpbnQgPSB2b2lkIDA7XG4gICAgdGhpcy5yZW5kaXRpb25SZXBvcnRzID0gdm9pZCAwO1xuICAgIHRoaXMudHVuZUluR29hbCA9IDA7XG4gICAgdGhpcy5kZWx0YVVwZGF0ZUZhaWxlZCA9IHZvaWQgMDtcbiAgICB0aGlzLmRyaWZ0U3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLmRyaWZ0RW5kVGltZSA9IDA7XG4gICAgdGhpcy5kcmlmdFN0YXJ0ID0gMDtcbiAgICB0aGlzLmRyaWZ0RW5kID0gMDtcbiAgICB0aGlzLmVuY3J5cHRlZEZyYWdtZW50cyA9IHZvaWQgMDtcbiAgICB0aGlzLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gbnVsbDtcbiAgICB0aGlzLnZhcmlhYmxlTGlzdCA9IG51bGw7XG4gICAgdGhpcy5oYXNWYXJpYWJsZVJlZnMgPSBmYWxzZTtcbiAgICB0aGlzLmFwcGxpZWRUaW1lbGluZU9mZnNldCA9IHZvaWQgMDtcbiAgICB0aGlzLmZyYWdtZW50cyA9IFtdO1xuICAgIHRoaXMuZW5jcnlwdGVkRnJhZ21lbnRzID0gW107XG4gICAgdGhpcy5kYXRlUmFuZ2VzID0ge307XG4gICAgdGhpcy51cmwgPSBiYXNlVXJsO1xuICB9XG4gIHJlbG9hZGVkKHByZXZpb3VzKSB7XG4gICAgaWYgKCFwcmV2aW91cykge1xuICAgICAgdGhpcy5hZHZhbmNlZCA9IHRydWU7XG4gICAgICB0aGlzLnVwZGF0ZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwYXJ0U25EaWZmID0gdGhpcy5sYXN0UGFydFNuIC0gcHJldmlvdXMubGFzdFBhcnRTbjtcbiAgICBjb25zdCBwYXJ0SW5kZXhEaWZmID0gdGhpcy5sYXN0UGFydEluZGV4IC0gcHJldmlvdXMubGFzdFBhcnRJbmRleDtcbiAgICB0aGlzLnVwZGF0ZWQgPSB0aGlzLmVuZFNOICE9PSBwcmV2aW91cy5lbmRTTiB8fCAhIXBhcnRJbmRleERpZmYgfHwgISFwYXJ0U25EaWZmIHx8ICF0aGlzLmxpdmU7XG4gICAgdGhpcy5hZHZhbmNlZCA9IHRoaXMuZW5kU04gPiBwcmV2aW91cy5lbmRTTiB8fCBwYXJ0U25EaWZmID4gMCB8fCBwYXJ0U25EaWZmID09PSAwICYmIHBhcnRJbmRleERpZmYgPiAwO1xuICAgIGlmICh0aGlzLnVwZGF0ZWQgfHwgdGhpcy5hZHZhbmNlZCkge1xuICAgICAgdGhpcy5taXNzZXMgPSBNYXRoLmZsb29yKHByZXZpb3VzLm1pc3NlcyAqIDAuNik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWlzc2VzID0gcHJldmlvdXMubWlzc2VzICsgMTtcbiAgICB9XG4gIH1cbiAgZ2V0IGhhc1Byb2dyYW1EYXRlVGltZSgpIHtcbiAgICBpZiAodGhpcy5mcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gaXNGaW5pdGVOdW1iZXIodGhpcy5mcmFnbWVudHNbdGhpcy5mcmFnbWVudHMubGVuZ3RoIC0gMV0ucHJvZ3JhbURhdGVUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGdldCBsZXZlbFRhcmdldER1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbiB8fCB0aGlzLnRhcmdldGR1cmF0aW9uIHx8IERFRkFVTFRfVEFSR0VUX0RVUkFUSU9OO1xuICB9XG4gIGdldCBkcmlmdCgpIHtcbiAgICBjb25zdCBydW5UaW1lID0gdGhpcy5kcmlmdEVuZFRpbWUgLSB0aGlzLmRyaWZ0U3RhcnRUaW1lO1xuICAgIGlmIChydW5UaW1lID4gMCkge1xuICAgICAgY29uc3QgcnVuRHVyYXRpb24gPSB0aGlzLmRyaWZ0RW5kIC0gdGhpcy5kcmlmdFN0YXJ0O1xuICAgICAgcmV0dXJuIHJ1bkR1cmF0aW9uICogMTAwMCAvIHJ1blRpbWU7XG4gICAgfVxuICAgIHJldHVybiAxO1xuICB9XG4gIGdldCBlZGdlKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnRFbmQgfHwgdGhpcy5mcmFnbWVudEVuZDtcbiAgfVxuICBnZXQgcGFydEVuZCgpIHtcbiAgICB2YXIgX3RoaXMkcGFydExpc3Q7XG4gICAgaWYgKChfdGhpcyRwYXJ0TGlzdCA9IHRoaXMucGFydExpc3QpICE9IG51bGwgJiYgX3RoaXMkcGFydExpc3QubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJ0TGlzdFt0aGlzLnBhcnRMaXN0Lmxlbmd0aCAtIDFdLmVuZDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZnJhZ21lbnRFbmQ7XG4gIH1cbiAgZ2V0IGZyYWdtZW50RW5kKCkge1xuICAgIHZhciBfdGhpcyRmcmFnbWVudHM7XG4gICAgaWYgKChfdGhpcyRmcmFnbWVudHMgPSB0aGlzLmZyYWdtZW50cykgIT0gbnVsbCAmJiBfdGhpcyRmcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5mcmFnbWVudHNbdGhpcy5mcmFnbWVudHMubGVuZ3RoIC0gMV0uZW5kO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICBnZXQgZnJhZ21lbnRTdGFydCgpIHtcbiAgICB2YXIgX3RoaXMkZnJhZ21lbnRzMjtcbiAgICBpZiAoKF90aGlzJGZyYWdtZW50czIgPSB0aGlzLmZyYWdtZW50cykgIT0gbnVsbCAmJiBfdGhpcyRmcmFnbWVudHMyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICBnZXQgYWdlKCkge1xuICAgIGlmICh0aGlzLmFkdmFuY2VkRGF0ZVRpbWUpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heChEYXRlLm5vdygpIC0gdGhpcy5hZHZhbmNlZERhdGVUaW1lLCAwKSAvIDEwMDA7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIGdldCBsYXN0UGFydEluZGV4KCkge1xuICAgIHZhciBfdGhpcyRwYXJ0TGlzdDI7XG4gICAgaWYgKChfdGhpcyRwYXJ0TGlzdDIgPSB0aGlzLnBhcnRMaXN0KSAhPSBudWxsICYmIF90aGlzJHBhcnRMaXN0Mi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnRMaXN0W3RoaXMucGFydExpc3QubGVuZ3RoIC0gMV0uaW5kZXg7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICBnZXQgbWF4UGFydEluZGV4KCkge1xuICAgIGNvbnN0IHBhcnRMaXN0ID0gdGhpcy5wYXJ0TGlzdDtcbiAgICBpZiAocGFydExpc3QpIHtcbiAgICAgIGNvbnN0IGxhc3RJbmRleCA9IHRoaXMubGFzdFBhcnRJbmRleDtcbiAgICAgIGlmIChsYXN0SW5kZXggIT09IC0xKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBwYXJ0TGlzdC5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICBpZiAocGFydExpc3RbaV0uaW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJ0TGlzdFtpXS5pbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhc3RJbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZ2V0IGxhc3RQYXJ0U24oKSB7XG4gICAgdmFyIF90aGlzJHBhcnRMaXN0MztcbiAgICBpZiAoKF90aGlzJHBhcnRMaXN0MyA9IHRoaXMucGFydExpc3QpICE9IG51bGwgJiYgX3RoaXMkcGFydExpc3QzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFydExpc3RbdGhpcy5wYXJ0TGlzdC5sZW5ndGggLSAxXS5mcmFnbWVudC5zbjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZW5kU047XG4gIH1cbiAgZ2V0IGV4cGlyZWQoKSB7XG4gICAgaWYgKHRoaXMubGl2ZSAmJiB0aGlzLmFnZSAmJiB0aGlzLm1pc3NlcyA8IDMpIHtcbiAgICAgIGNvbnN0IHBsYXlsaXN0V2luZG93RHVyYXRpb24gPSB0aGlzLnBhcnRFbmQgLSB0aGlzLmZyYWdtZW50U3RhcnQ7XG4gICAgICByZXR1cm4gdGhpcy5hZ2UgPiBNYXRoLm1heChwbGF5bGlzdFdpbmRvd0R1cmF0aW9uLCB0aGlzLnRvdGFsZHVyYXRpb24pICsgdGhpcy5sZXZlbFRhcmdldER1cmF0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNGdWxsU2VnbWVudEVuY3J5cHRpb24obWV0aG9kKSB7XG4gIHJldHVybiBtZXRob2QgPT09ICdBRVMtMTI4JyB8fCBtZXRob2QgPT09ICdBRVMtMjU2JyB8fCBtZXRob2QgPT09ICdBRVMtMjU2LUNUUic7XG59XG5mdW5jdGlvbiBnZXRBZXNNb2RlRnJvbUZ1bGxTZWdtZW50TWV0aG9kKG1ldGhvZCkge1xuICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgIGNhc2UgJ0FFUy0xMjgnOlxuICAgIGNhc2UgJ0FFUy0yNTYnOlxuICAgICAgcmV0dXJuIERlY3J5cHRlckFlc01vZGUuY2JjO1xuICAgIGNhc2UgJ0FFUy0yNTYtQ1RSJzpcbiAgICAgIHJldHVybiBEZWNyeXB0ZXJBZXNNb2RlLmN0cjtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGZ1bGwgc2VnbWVudCBtZXRob2QgJHttZXRob2R9YCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0RGVjb2RlKGJhc2U2NGVuY29kZWRTdHIpIHtcbiAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShhdG9iKGJhc2U2NGVuY29kZWRTdHIpLCBjID0+IGMuY2hhckNvZGVBdCgwKSk7XG59XG5cbi8vIGJyZWFraW5nIHVwIHRob3NlIHR3byB0eXBlcyBpbiBvcmRlciB0byBjbGFyaWZ5IHdoYXQgaXMgaGFwcGVuaW5nIGluIHRoZSBkZWNvZGluZyBwYXRoLlxuXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg5MzY5ODQvdWludDhhcnJheS10by1zdHJpbmctaW4tamF2YXNjcmlwdC8yMjM3MzE5N1xuLy8gaHR0cDovL3d3dy5vbmljb3MuY29tL3N0YWZmL2l6L2FtdXNlL2phdmFzY3JpcHQvZXhwZXJ0L3V0Zi50eHRcbi8qIHV0Zi5qcyAtIFVURi04IDw9PiBVVEYtMTYgY29udmVydGlvblxuICpcbiAqIENvcHlyaWdodCAoQykgMTk5OSBNYXNhbmFvIEl6dW1vIDxpekBvbmljb3MuY28uanA+XG4gKiBWZXJzaW9uOiAxLjBcbiAqIExhc3RNb2RpZmllZDogRGVjIDI1IDE5OTlcbiAqIFRoaXMgbGlicmFyeSBpcyBmcmVlLiAgWW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdC5cbiAqL1xuXG5mdW5jdGlvbiBzdHJUb1V0ZjhhcnJheShzdHIpIHtcbiAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSksIGMgPT4gYy5jaGFyQ29kZUF0KDApKTtcbn1cblxuZnVuY3Rpb24gZ2V0S2V5SWRCeXRlcyhzdHIpIHtcbiAgY29uc3Qga2V5SWRieXRlcyA9IHN0clRvVXRmOGFycmF5KHN0cikuc3ViYXJyYXkoMCwgMTYpO1xuICBjb25zdCBwYWRkZWRrZXlJZGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICBwYWRkZWRrZXlJZGJ5dGVzLnNldChrZXlJZGJ5dGVzLCAxNiAtIGtleUlkYnl0ZXMubGVuZ3RoKTtcbiAgcmV0dXJuIHBhZGRlZGtleUlkYnl0ZXM7XG59XG5mdW5jdGlvbiBjaGFuZ2VFbmRpYW5uZXNzKGtleUlkKSB7XG4gIGNvbnN0IHN3YXAgPSBmdW5jdGlvbiBzd2FwKGFycmF5LCBmcm9tLCB0bykge1xuICAgIGNvbnN0IGN1ciA9IGFycmF5W2Zyb21dO1xuICAgIGFycmF5W2Zyb21dID0gYXJyYXlbdG9dO1xuICAgIGFycmF5W3RvXSA9IGN1cjtcbiAgfTtcbiAgc3dhcChrZXlJZCwgMCwgMyk7XG4gIHN3YXAoa2V5SWQsIDEsIDIpO1xuICBzd2FwKGtleUlkLCA0LCA1KTtcbiAgc3dhcChrZXlJZCwgNiwgNyk7XG59XG5mdW5jdGlvbiBjb252ZXJ0RGF0YVVyaVRvQXJyYXlCeXRlcyh1cmkpIHtcbiAgLy8gZGF0YTpbPG1lZGlhIHR5cGVdWzthdHRyaWJ1dGU9dmFsdWVdWztiYXNlNjRdLDxkYXRhPlxuICBjb25zdCBjb2xvbnNwbGl0ID0gdXJpLnNwbGl0KCc6Jyk7XG4gIGxldCBrZXlkYXRhID0gbnVsbDtcbiAgaWYgKGNvbG9uc3BsaXRbMF0gPT09ICdkYXRhJyAmJiBjb2xvbnNwbGl0Lmxlbmd0aCA9PT0gMikge1xuICAgIGNvbnN0IHNlbWljb2xvbnNwbGl0ID0gY29sb25zcGxpdFsxXS5zcGxpdCgnOycpO1xuICAgIGNvbnN0IGNvbW1hc3BsaXQgPSBzZW1pY29sb25zcGxpdFtzZW1pY29sb25zcGxpdC5sZW5ndGggLSAxXS5zcGxpdCgnLCcpO1xuICAgIGlmIChjb21tYXNwbGl0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgY29uc3QgaXNiYXNlNjQgPSBjb21tYXNwbGl0WzBdID09PSAnYmFzZTY0JztcbiAgICAgIGNvbnN0IGRhdGEgPSBjb21tYXNwbGl0WzFdO1xuICAgICAgaWYgKGlzYmFzZTY0KSB7XG4gICAgICAgIHNlbWljb2xvbnNwbGl0LnNwbGljZSgtMSwgMSk7IC8vIHJlbW92ZSBmcm9tIHByb2Nlc3NpbmdcbiAgICAgICAga2V5ZGF0YSA9IGJhc2U2NERlY29kZShkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleWRhdGEgPSBnZXRLZXlJZEJ5dGVzKGRhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4ga2V5ZGF0YTtcbn1cblxuLyoqIHJldHVybnMgYHVuZGVmaW5lZGAgaXMgYHNlbGZgIGlzIG1pc3NpbmcsIGUuZy4gaW4gbm9kZSAqL1xuY29uc3Qgb3B0aW9uYWxTZWxmID0gdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9OYXZpZ2F0b3IvcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzXG4gKi9cbnZhciBLZXlTeXN0ZW1zID0ge1xuICBDTEVBUktFWTogXCJvcmcudzMuY2xlYXJrZXlcIixcbiAgRkFJUlBMQVk6IFwiY29tLmFwcGxlLmZwc1wiLFxuICBQTEFZUkVBRFk6IFwiY29tLm1pY3Jvc29mdC5wbGF5cmVhZHlcIixcbiAgV0lERVZJTkU6IFwiY29tLndpZGV2aW5lLmFscGhhXCJcbn07XG5cbi8vIFBsYXlsaXN0ICNFWFQtWC1LRVkgS0VZRk9STUFUIHZhbHVlc1xudmFyIEtleVN5c3RlbUZvcm1hdHMgPSB7XG4gIENMRUFSS0VZOiBcIm9yZy53My5jbGVhcmtleVwiLFxuICBGQUlSUExBWTogXCJjb20uYXBwbGUuc3RyZWFtaW5na2V5ZGVsaXZlcnlcIixcbiAgUExBWVJFQURZOiBcImNvbS5taWNyb3NvZnQucGxheXJlYWR5XCIsXG4gIFdJREVWSU5FOiBcInVybjp1dWlkOmVkZWY4YmE5LTc5ZDYtNGFjZS1hM2M4LTI3ZGNkNTFkMjFlZFwiXG59O1xuZnVuY3Rpb24ga2V5U3lzdGVtRm9ybWF0VG9LZXlTeXN0ZW1Eb21haW4oZm9ybWF0KSB7XG4gIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgY2FzZSBLZXlTeXN0ZW1Gb3JtYXRzLkZBSVJQTEFZOlxuICAgICAgcmV0dXJuIEtleVN5c3RlbXMuRkFJUlBMQVk7XG4gICAgY2FzZSBLZXlTeXN0ZW1Gb3JtYXRzLlBMQVlSRUFEWTpcbiAgICAgIHJldHVybiBLZXlTeXN0ZW1zLlBMQVlSRUFEWTtcbiAgICBjYXNlIEtleVN5c3RlbUZvcm1hdHMuV0lERVZJTkU6XG4gICAgICByZXR1cm4gS2V5U3lzdGVtcy5XSURFVklORTtcbiAgICBjYXNlIEtleVN5c3RlbUZvcm1hdHMuQ0xFQVJLRVk6XG4gICAgICByZXR1cm4gS2V5U3lzdGVtcy5DTEVBUktFWTtcbiAgfVxufVxuZnVuY3Rpb24ga2V5U3lzdGVtRG9tYWluVG9LZXlTeXN0ZW1Gb3JtYXQoa2V5U3lzdGVtKSB7XG4gIHN3aXRjaCAoa2V5U3lzdGVtKSB7XG4gICAgY2FzZSBLZXlTeXN0ZW1zLkZBSVJQTEFZOlxuICAgICAgcmV0dXJuIEtleVN5c3RlbUZvcm1hdHMuRkFJUlBMQVk7XG4gICAgY2FzZSBLZXlTeXN0ZW1zLlBMQVlSRUFEWTpcbiAgICAgIHJldHVybiBLZXlTeXN0ZW1Gb3JtYXRzLlBMQVlSRUFEWTtcbiAgICBjYXNlIEtleVN5c3RlbXMuV0lERVZJTkU6XG4gICAgICByZXR1cm4gS2V5U3lzdGVtRm9ybWF0cy5XSURFVklORTtcbiAgICBjYXNlIEtleVN5c3RlbXMuQ0xFQVJLRVk6XG4gICAgICByZXR1cm4gS2V5U3lzdGVtRm9ybWF0cy5DTEVBUktFWTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0S2V5U3lzdGVtc0ZvckNvbmZpZyhjb25maWcpIHtcbiAgY29uc3Qge1xuICAgIGRybVN5c3RlbXMsXG4gICAgd2lkZXZpbmVMaWNlbnNlVXJsXG4gIH0gPSBjb25maWc7XG4gIGNvbnN0IGtleVN5c3RlbXNUb0F0dGVtcHQgPSBkcm1TeXN0ZW1zID8gW0tleVN5c3RlbXMuRkFJUlBMQVksIEtleVN5c3RlbXMuV0lERVZJTkUsIEtleVN5c3RlbXMuUExBWVJFQURZLCBLZXlTeXN0ZW1zLkNMRUFSS0VZXS5maWx0ZXIoa2V5U3lzdGVtID0+ICEhZHJtU3lzdGVtc1trZXlTeXN0ZW1dKSA6IFtdO1xuICBpZiAoIWtleVN5c3RlbXNUb0F0dGVtcHRbS2V5U3lzdGVtcy5XSURFVklORV0gJiYgd2lkZXZpbmVMaWNlbnNlVXJsKSB7XG4gICAga2V5U3lzdGVtc1RvQXR0ZW1wdC5wdXNoKEtleVN5c3RlbXMuV0lERVZJTkUpO1xuICB9XG4gIHJldHVybiBrZXlTeXN0ZW1zVG9BdHRlbXB0O1xufVxuY29uc3QgcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzID0gZnVuY3Rpb24gKF9vcHRpb25hbFNlbGYkbmF2aWdhdCkge1xuICBpZiAob3B0aW9uYWxTZWxmICE9IG51bGwgJiYgKF9vcHRpb25hbFNlbGYkbmF2aWdhdCA9IG9wdGlvbmFsU2VsZi5uYXZpZ2F0b3IpICE9IG51bGwgJiYgX29wdGlvbmFsU2VsZiRuYXZpZ2F0LnJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzcykge1xuICAgIHJldHVybiBzZWxmLm5hdmlnYXRvci5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MuYmluZChzZWxmLm5hdmlnYXRvcik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn0oKTtcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25cbiAqL1xuZnVuY3Rpb24gZ2V0U3VwcG9ydGVkTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9ucyhrZXlTeXN0ZW0sIGF1ZGlvQ29kZWNzLCB2aWRlb0NvZGVjcywgZHJtU3lzdGVtT3B0aW9ucykge1xuICBsZXQgaW5pdERhdGFUeXBlcztcbiAgc3dpdGNoIChrZXlTeXN0ZW0pIHtcbiAgICBjYXNlIEtleVN5c3RlbXMuRkFJUlBMQVk6XG4gICAgICBpbml0RGF0YVR5cGVzID0gWydjZW5jJywgJ3NpbmYnXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgS2V5U3lzdGVtcy5XSURFVklORTpcbiAgICBjYXNlIEtleVN5c3RlbXMuUExBWVJFQURZOlxuICAgICAgaW5pdERhdGFUeXBlcyA9IFsnY2VuYyddO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBLZXlTeXN0ZW1zLkNMRUFSS0VZOlxuICAgICAgaW5pdERhdGFUeXBlcyA9IFsnY2VuYycsICdrZXlpZHMnXTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24ga2V5LXN5c3RlbTogJHtrZXlTeXN0ZW19YCk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZU1lZGlhS2V5U3lzdGVtQ29uZmlndXJhdGlvbnMoaW5pdERhdGFUeXBlcywgYXVkaW9Db2RlY3MsIHZpZGVvQ29kZWNzLCBkcm1TeXN0ZW1PcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU1lZGlhS2V5U3lzdGVtQ29uZmlndXJhdGlvbnMoaW5pdERhdGFUeXBlcywgYXVkaW9Db2RlY3MsIHZpZGVvQ29kZWNzLCBkcm1TeXN0ZW1PcHRpb25zKSB7XG4gIGNvbnN0IGJhc2VDb25maWcgPSB7XG4gICAgaW5pdERhdGFUeXBlczogaW5pdERhdGFUeXBlcyxcbiAgICBwZXJzaXN0ZW50U3RhdGU6IGRybVN5c3RlbU9wdGlvbnMucGVyc2lzdGVudFN0YXRlIHx8ICdvcHRpb25hbCcsXG4gICAgZGlzdGluY3RpdmVJZGVudGlmaWVyOiBkcm1TeXN0ZW1PcHRpb25zLmRpc3RpbmN0aXZlSWRlbnRpZmllciB8fCAnb3B0aW9uYWwnLFxuICAgIHNlc3Npb25UeXBlczogZHJtU3lzdGVtT3B0aW9ucy5zZXNzaW9uVHlwZXMgfHwgW2RybVN5c3RlbU9wdGlvbnMuc2Vzc2lvblR5cGUgfHwgJ3RlbXBvcmFyeSddLFxuICAgIGF1ZGlvQ2FwYWJpbGl0aWVzOiBhdWRpb0NvZGVjcy5tYXAoY29kZWMgPT4gKHtcbiAgICAgIGNvbnRlbnRUeXBlOiBgYXVkaW8vbXA0OyBjb2RlY3M9JHtjb2RlY31gLFxuICAgICAgcm9idXN0bmVzczogZHJtU3lzdGVtT3B0aW9ucy5hdWRpb1JvYnVzdG5lc3MgfHwgJycsXG4gICAgICBlbmNyeXB0aW9uU2NoZW1lOiBkcm1TeXN0ZW1PcHRpb25zLmF1ZGlvRW5jcnlwdGlvblNjaGVtZSB8fCBudWxsXG4gICAgfSkpLFxuICAgIHZpZGVvQ2FwYWJpbGl0aWVzOiB2aWRlb0NvZGVjcy5tYXAoY29kZWMgPT4gKHtcbiAgICAgIGNvbnRlbnRUeXBlOiBgdmlkZW8vbXA0OyBjb2RlY3M9JHtjb2RlY31gLFxuICAgICAgcm9idXN0bmVzczogZHJtU3lzdGVtT3B0aW9ucy52aWRlb1JvYnVzdG5lc3MgfHwgJycsXG4gICAgICBlbmNyeXB0aW9uU2NoZW1lOiBkcm1TeXN0ZW1PcHRpb25zLnZpZGVvRW5jcnlwdGlvblNjaGVtZSB8fCBudWxsXG4gICAgfSkpXG4gIH07XG4gIHJldHVybiBbYmFzZUNvbmZpZ107XG59XG5mdW5jdGlvbiBpc1BlcnNpc3RlbnRTZXNzaW9uVHlwZShkcm1TeXN0ZW1PcHRpb25zKSB7XG4gIHZhciBfZHJtU3lzdGVtT3B0aW9ucyRzZXM7XG4gIHJldHVybiBkcm1TeXN0ZW1PcHRpb25zLnNlc3Npb25UeXBlID09PSAncGVyc2lzdGVudC1saWNlbnNlJyB8fCAhISgoX2RybVN5c3RlbU9wdGlvbnMkc2VzID0gZHJtU3lzdGVtT3B0aW9ucy5zZXNzaW9uVHlwZXMpICE9IG51bGwgJiYgX2RybVN5c3RlbU9wdGlvbnMkc2VzLnNvbWUodHlwZSA9PiB0eXBlID09PSAncGVyc2lzdGVudC1saWNlbnNlJykpO1xufVxuZnVuY3Rpb24gcGFyc2VQbGF5UmVhZHlXUk0oa2V5Qnl0ZXMpIHtcbiAgY29uc3Qga2V5Qnl0ZXNVdGYxNiA9IG5ldyBVaW50MTZBcnJheShrZXlCeXRlcy5idWZmZXIsIGtleUJ5dGVzLmJ5dGVPZmZzZXQsIGtleUJ5dGVzLmJ5dGVMZW5ndGggLyAyKTtcbiAgY29uc3Qga2V5Qnl0ZVN0ciA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgQXJyYXkuZnJvbShrZXlCeXRlc1V0ZjE2KSk7XG5cbiAgLy8gUGFyc2UgUGxheXJlYWR5IFdSTUhlYWRlciBYTUxcbiAgY29uc3QgeG1sS2V5Qnl0ZXMgPSBrZXlCeXRlU3RyLnN1YnN0cmluZyhrZXlCeXRlU3RyLmluZGV4T2YoJzwnKSwga2V5Qnl0ZVN0ci5sZW5ndGgpO1xuICBjb25zdCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gIGNvbnN0IHhtbERvYyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoeG1sS2V5Qnl0ZXMsICd0ZXh0L3htbCcpO1xuICBjb25zdCBrZXlEYXRhID0geG1sRG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdLSUQnKVswXTtcbiAgaWYgKGtleURhdGEpIHtcbiAgICBjb25zdCBrZXlJZCA9IGtleURhdGEuY2hpbGROb2Rlc1swXSA/IGtleURhdGEuY2hpbGROb2Rlc1swXS5ub2RlVmFsdWUgOiBrZXlEYXRhLmdldEF0dHJpYnV0ZSgnVkFMVUUnKTtcbiAgICBpZiAoa2V5SWQpIHtcbiAgICAgIGNvbnN0IGtleUlkQXJyYXkgPSBiYXNlNjREZWNvZGUoa2V5SWQpLnN1YmFycmF5KDAsIDE2KTtcbiAgICAgIC8vIEtJRCB2YWx1ZSBpbiBQUk8gaXMgYSBiYXNlNjQtZW5jb2RlZCBsaXR0bGUgZW5kaWFuIEdVSUQgaW50ZXJwcmV0YXRpb24gb2YgVVVJRFxuICAgICAgLy8gS0lEIHZhbHVlIGluIOKAmHRlbmPigJkgaXMgYSBiaWcgZW5kaWFuIFVVSUQgR1VJRCBpbnRlcnByZXRhdGlvbiBvZiBVVUlEXG4gICAgICBjaGFuZ2VFbmRpYW5uZXNzKGtleUlkQXJyYXkpO1xuICAgICAgcmV0dXJuIGtleUlkQXJyYXk7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5sZXQga2V5VXJpVG9LZXlJZE1hcCA9IHt9O1xuY2xhc3MgTGV2ZWxLZXkge1xuICBzdGF0aWMgY2xlYXJLZXlVcmlUb0tleUlkTWFwKCkge1xuICAgIGtleVVyaVRvS2V5SWRNYXAgPSB7fTtcbiAgfVxuICBjb25zdHJ1Y3RvcihtZXRob2QsIHVyaSwgZm9ybWF0LCBmb3JtYXR2ZXJzaW9ucyA9IFsxXSwgaXYgPSBudWxsLCBrZXlJZCkge1xuICAgIHRoaXMudXJpID0gdm9pZCAwO1xuICAgIHRoaXMubWV0aG9kID0gdm9pZCAwO1xuICAgIHRoaXMua2V5Rm9ybWF0ID0gdm9pZCAwO1xuICAgIHRoaXMua2V5Rm9ybWF0VmVyc2lvbnMgPSB2b2lkIDA7XG4gICAgdGhpcy5lbmNyeXB0ZWQgPSB2b2lkIDA7XG4gICAgdGhpcy5pc0NvbW1vbkVuY3J5cHRpb24gPSB2b2lkIDA7XG4gICAgdGhpcy5pdiA9IG51bGw7XG4gICAgdGhpcy5rZXkgPSBudWxsO1xuICAgIHRoaXMua2V5SWQgPSBudWxsO1xuICAgIHRoaXMucHNzaCA9IG51bGw7XG4gICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgdGhpcy51cmkgPSB1cmk7XG4gICAgdGhpcy5rZXlGb3JtYXQgPSBmb3JtYXQ7XG4gICAgdGhpcy5rZXlGb3JtYXRWZXJzaW9ucyA9IGZvcm1hdHZlcnNpb25zO1xuICAgIHRoaXMuaXYgPSBpdjtcbiAgICB0aGlzLmVuY3J5cHRlZCA9IG1ldGhvZCA/IG1ldGhvZCAhPT0gJ05PTkUnIDogZmFsc2U7XG4gICAgdGhpcy5pc0NvbW1vbkVuY3J5cHRpb24gPSB0aGlzLmVuY3J5cHRlZCAmJiAhaXNGdWxsU2VnbWVudEVuY3J5cHRpb24obWV0aG9kKTtcbiAgICBpZiAoa2V5SWQgIT0gbnVsbCAmJiBrZXlJZC5zdGFydHNXaXRoKCcweCcpKSB7XG4gICAgICB0aGlzLmtleUlkID0gbmV3IFVpbnQ4QXJyYXkoaGV4VG9BcnJheUJ1ZmZlcihrZXlJZCkpO1xuICAgIH1cbiAgfVxuICBtYXRjaGVzKGtleSkge1xuICAgIHZhciBfa2V5JGl2LCBfdGhpcyRpdjtcbiAgICByZXR1cm4ga2V5LnVyaSA9PT0gdGhpcy51cmkgJiYga2V5Lm1ldGhvZCA9PT0gdGhpcy5tZXRob2QgJiYga2V5LmVuY3J5cHRlZCA9PT0gdGhpcy5lbmNyeXB0ZWQgJiYga2V5LmtleUZvcm1hdCA9PT0gdGhpcy5rZXlGb3JtYXQgJiYga2V5LmtleUZvcm1hdFZlcnNpb25zLmpvaW4oJywnKSA9PT0gdGhpcy5rZXlGb3JtYXRWZXJzaW9ucy5qb2luKCcsJykgJiYgKChfa2V5JGl2ID0ga2V5Lml2KSA9PSBudWxsID8gdm9pZCAwIDogX2tleSRpdi5qb2luKCcsJykpID09PSAoKF90aGlzJGl2ID0gdGhpcy5pdikgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGl2LmpvaW4oJywnKSk7XG4gIH1cbiAgaXNTdXBwb3J0ZWQoKSB7XG4gICAgLy8gSWYgaXQncyBTZWdtZW50IGVuY3J5cHRpb24gb3IgTm8gZW5jcnlwdGlvbiwganVzdCBzZWxlY3QgdGhhdCBrZXkgc3lzdGVtXG4gICAgaWYgKHRoaXMubWV0aG9kKSB7XG4gICAgICBpZiAoaXNGdWxsU2VnbWVudEVuY3J5cHRpb24odGhpcy5tZXRob2QpIHx8IHRoaXMubWV0aG9kID09PSAnTk9ORScpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5rZXlGb3JtYXQgPT09ICdpZGVudGl0eScpIHtcbiAgICAgICAgLy8gTWFpbnRhaW4gc3VwcG9ydCBmb3IgY2xlYXIgU0FNUExFLUFFUyB3aXRoIE1QRUctMyBUU1xuICAgICAgICByZXR1cm4gdGhpcy5tZXRob2QgPT09ICdTQU1QTEUtQUVTJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5rZXlGb3JtYXQpIHtcbiAgICAgICAgICBjYXNlIEtleVN5c3RlbUZvcm1hdHMuRkFJUlBMQVk6XG4gICAgICAgICAgY2FzZSBLZXlTeXN0ZW1Gb3JtYXRzLldJREVWSU5FOlxuICAgICAgICAgIGNhc2UgS2V5U3lzdGVtRm9ybWF0cy5QTEFZUkVBRFk6XG4gICAgICAgICAgY2FzZSBLZXlTeXN0ZW1Gb3JtYXRzLkNMRUFSS0VZOlxuICAgICAgICAgICAgcmV0dXJuIFsnSVNPLTIzMDAxLTcnLCAnU0FNUExFLUFFUycsICdTQU1QTEUtQUVTLUNFTkMnLCAnU0FNUExFLUFFUy1DVFInXS5pbmRleE9mKHRoaXMubWV0aG9kKSAhPT0gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGdldERlY3J5cHREYXRhKHNuKSB7XG4gICAgaWYgKCF0aGlzLmVuY3J5cHRlZCB8fCAhdGhpcy51cmkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoaXNGdWxsU2VnbWVudEVuY3J5cHRpb24odGhpcy5tZXRob2QpICYmIHRoaXMudXJpICYmICF0aGlzLml2KSB7XG4gICAgICBpZiAodHlwZW9mIHNuICE9PSAnbnVtYmVyJykge1xuICAgICAgICAvLyBXZSBhcmUgZmV0Y2hpbmcgZGVjcnlwdGlvbiBkYXRhIGZvciBhIGluaXRpYWxpemF0aW9uIHNlZ21lbnRcbiAgICAgICAgLy8gSWYgdGhlIHNlZ21lbnQgd2FzIGVuY3J5cHRlZCB3aXRoIEFFUy0xMjgvMjU2XG4gICAgICAgIC8vIEl0IG11c3QgaGF2ZSBhbiBJViBkZWZpbmVkLiBXZSBjYW5ub3Qgc3Vic3RpdHV0ZSB0aGUgU2VnbWVudCBOdW1iZXIgaW4uXG4gICAgICAgIGxvZ2dlci53YXJuKGBtaXNzaW5nIElWIGZvciBpbml0aWFsaXphdGlvbiBzZWdtZW50IHdpdGggbWV0aG9kPVwiJHt0aGlzLm1ldGhvZH1cIiAtIGNvbXBsaWFuY2UgaXNzdWVgKTtcblxuICAgICAgICAvLyBFeHBsaWNpdGx5IHNldCBzbiB0byByZXN1bHRpbmcgdmFsdWUgZnJvbSBpbXBsaWNpdCBjb252ZXJzaW9ucyAnaW5pdFNlZ21lbnQnIHZhbHVlcyBmb3IgSVYgZ2VuZXJhdGlvbi5cbiAgICAgICAgc24gPSAwO1xuICAgICAgfVxuICAgICAgY29uc3QgaXYgPSBjcmVhdGVJbml0aWFsaXphdGlvblZlY3Rvcihzbik7XG4gICAgICBjb25zdCBkZWNyeXB0ZGF0YSA9IG5ldyBMZXZlbEtleSh0aGlzLm1ldGhvZCwgdGhpcy51cmksICdpZGVudGl0eScsIHRoaXMua2V5Rm9ybWF0VmVyc2lvbnMsIGl2KTtcbiAgICAgIHJldHVybiBkZWNyeXB0ZGF0YTtcbiAgICB9XG4gICAgaWYgKHRoaXMucHNzaCAmJiB0aGlzLmtleUlkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIGtleUlkIGlmIHBvc3NpYmxlXG4gICAgY29uc3Qga2V5Qnl0ZXMgPSBjb252ZXJ0RGF0YVVyaVRvQXJyYXlCeXRlcyh0aGlzLnVyaSk7XG4gICAgaWYgKGtleUJ5dGVzKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMua2V5Rm9ybWF0KSB7XG4gICAgICAgIGNhc2UgS2V5U3lzdGVtRm9ybWF0cy5XSURFVklORTpcbiAgICAgICAgICAvLyBTZXR0aW5nIGBwc3NoYCBvbiB0aGlzIExldmVsS2V5L0RlY3J5cHREYXRhIGFsbG93cyBITFMuanMgdG8gZ2VuZXJhdGUgYSBzZXNzaW9uIHVzaW5nXG4gICAgICAgICAgLy8gdGhlIHBsYXlsaXN0LWtleSBiZWZvcmUgdGhlIFwiZW5jcnlwdGVkXCIgZXZlbnQuIChDb21tZW50IG91dCB0byBvbmx5IHVzZSBcImVuY3J5cHRlZFwiIHBhdGguKVxuICAgICAgICAgIHRoaXMucHNzaCA9IGtleUJ5dGVzO1xuICAgICAgICAgIC8vIEluIGNhc2Ugb2YgV2lkZXZpbmUsIGlmIEtFWUlEIGlzIG5vdCBpbiB0aGUgcGxheWxpc3QsIGFzc3VtZSBvbmx5IHR3byBmaWVsZHMgaW4gdGhlIHBzc2ggS0VZIHRhZyBVUkkuXG4gICAgICAgICAgaWYgKCF0aGlzLmtleUlkICYmIGtleUJ5dGVzLmxlbmd0aCA+PSAyMikge1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0ga2V5Qnl0ZXMubGVuZ3RoIC0gMjI7XG4gICAgICAgICAgICB0aGlzLmtleUlkID0ga2V5Qnl0ZXMuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxNik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEtleVN5c3RlbUZvcm1hdHMuUExBWVJFQURZOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IFBsYXlSZWFkeUtleVN5c3RlbVVVSUQgPSBuZXcgVWludDhBcnJheShbMHg5YSwgMHgwNCwgMHhmMCwgMHg3OSwgMHg5OCwgMHg0MCwgMHg0MiwgMHg4NiwgMHhhYiwgMHg5MiwgMHhlNiwgMHg1YiwgMHhlMCwgMHg4OCwgMHg1ZiwgMHg5NV0pO1xuXG4gICAgICAgICAgICAvLyBTZXR0aW5nIGBwc3NoYCBvbiB0aGlzIExldmVsS2V5L0RlY3J5cHREYXRhIGFsbG93cyBITFMuanMgdG8gZ2VuZXJhdGUgYSBzZXNzaW9uIHVzaW5nXG4gICAgICAgICAgICAvLyB0aGUgcGxheWxpc3Qta2V5IGJlZm9yZSB0aGUgXCJlbmNyeXB0ZWRcIiBldmVudC4gKENvbW1lbnQgb3V0IHRvIG9ubHkgdXNlIFwiZW5jcnlwdGVkXCIgcGF0aC4pXG4gICAgICAgICAgICB0aGlzLnBzc2ggPSBtcDRwc3NoKFBsYXlSZWFkeUtleVN5c3RlbVVVSUQsIG51bGwsIGtleUJ5dGVzKTtcbiAgICAgICAgICAgIHRoaXMua2V5SWQgPSBwYXJzZVBsYXlSZWFkeVdSTShrZXlCeXRlcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgbGV0IGtleWRhdGEgPSBrZXlCeXRlcy5zdWJhcnJheSgwLCAxNik7XG4gICAgICAgICAgICBpZiAoa2V5ZGF0YS5sZW5ndGggIT09IDE2KSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhZGRlZCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICAgICAgICAgICAgcGFkZGVkLnNldChrZXlkYXRhLCAxNiAtIGtleWRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgICAga2V5ZGF0YSA9IHBhZGRlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMua2V5SWQgPSBrZXlkYXRhO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlZmF1bHQgYmVoYXZpb3I6IGFzc2lnbiBhIG5ldyBrZXlJZCBmb3IgZWFjaCB1cmlcbiAgICBpZiAoIXRoaXMua2V5SWQgfHwgdGhpcy5rZXlJZC5ieXRlTGVuZ3RoICE9PSAxNikge1xuICAgICAgbGV0IGtleUlkID0ga2V5VXJpVG9LZXlJZE1hcFt0aGlzLnVyaV07XG4gICAgICBpZiAoIWtleUlkKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IE9iamVjdC5rZXlzKGtleVVyaVRvS2V5SWRNYXApLmxlbmd0aCAlIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICBrZXlJZCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICAgICAgY29uc3QgZHYgPSBuZXcgRGF0YVZpZXcoa2V5SWQuYnVmZmVyLCAxMiwgNCk7IC8vIEp1c3Qgc2V0IHRoZSBsYXN0IDQgYnl0ZXNcbiAgICAgICAgZHYuc2V0VWludDMyKDAsIHZhbCk7XG4gICAgICAgIGtleVVyaVRvS2V5SWRNYXBbdGhpcy51cmldID0ga2V5SWQ7XG4gICAgICB9XG4gICAgICB0aGlzLmtleUlkID0ga2V5SWQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVJbml0aWFsaXphdGlvblZlY3RvcihzZWdtZW50TnVtYmVyKSB7XG4gIGNvbnN0IHVpbnQ4VmlldyA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgZm9yIChsZXQgaSA9IDEyOyBpIDwgMTY7IGkrKykge1xuICAgIHVpbnQ4Vmlld1tpXSA9IHNlZ21lbnROdW1iZXIgPj4gOCAqICgxNSAtIGkpICYgMHhmZjtcbiAgfVxuICByZXR1cm4gdWludDhWaWV3O1xufVxuXG5jb25zdCBNQVNURVJfUExBWUxJU1RfUkVHRVggPSAvI0VYVC1YLVNUUkVBTS1JTkY6KFteXFxyXFxuXSopKD86W1xcclxcbl0oPzojW15cXHJcXG5dKik/KSooW15cXHJcXG5dKyl8I0VYVC1YLShTRVNTSU9OLURBVEF8U0VTU0lPTi1LRVl8REVGSU5FfENPTlRFTlQtU1RFRVJJTkd8U1RBUlQpOihbXlxcclxcbl0qKVtcXHJcXG5dKy9nO1xuY29uc3QgTUFTVEVSX1BMQVlMSVNUX01FRElBX1JFR0VYID0gLyNFWFQtWC1NRURJQTooLiopL2c7XG5jb25zdCBJU19NRURJQV9QTEFZTElTVCA9IC9eI0VYVCg/OklORnwtWC1UQVJHRVREVVJBVElPTik6L207IC8vIEhhbmRsZSBlbXB0eSBNZWRpYSBQbGF5bGlzdCAoZmlyc3QgRVhUSU5GIG5vdCBzaWduYWxlZCwgYnV0IFRBUkdFVERVUkFUSU9OIHByZXNlbnQpXG5cbmNvbnN0IExFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QgPSBuZXcgUmVnRXhwKFsvI0VYVElORjpcXHMqKFxcZCooPzpcXC5cXGQrKT8pKD86LCguKilcXHMrKT8vLnNvdXJjZSxcbi8vIGR1cmF0aW9uICgjRVhUSU5GOjxkdXJhdGlvbj4sPHRpdGxlPiksIGdyb3VwIDEgPT4gZHVyYXRpb24sIGdyb3VwIDIgPT4gdGl0bGVcbi8oPyEjKSAqKFxcU1teXFxyXFxuXSopLy5zb3VyY2UsXG4vLyBzZWdtZW50IFVSSSwgZ3JvdXAgMyA9PiB0aGUgVVJJIChub3RlIG5ld2xpbmUgaXMgbm90IGVhdGVuKVxuLyMuKi8uc291cmNlIC8vIEFsbCBvdGhlciBub24tc2VnbWVudCBvcmllbnRlZCB0YWdzIHdpbGwgbWF0Y2ggd2l0aCBhbGwgZ3JvdXBzIGVtcHR5XG5dLmpvaW4oJ3wnKSwgJ2cnKTtcbmNvbnN0IExFVkVMX1BMQVlMSVNUX1JFR0VYX1NMT1cgPSBuZXcgUmVnRXhwKFsvI0VYVC1YLShQUk9HUkFNLURBVEUtVElNRXxCWVRFUkFOR0V8REFURVJBTkdFfERFRklORXxLRVl8TUFQfFBBUlR8UEFSVC1JTkZ8UExBWUxJU1QtVFlQRXxQUkVMT0FELUhJTlR8UkVORElUSU9OLVJFUE9SVHxTRVJWRVItQ09OVFJPTHxTS0lQfFNUQVJUKTooLispLy5zb3VyY2UsIC8jRVhULVgtKEJJVFJBVEV8RElTQ09OVElOVUlUWS1TRVFVRU5DRXxNRURJQS1TRVFVRU5DRXxUQVJHRVREVVJBVElPTnxWRVJTSU9OKTogKihcXGQrKS8uc291cmNlLCAvI0VYVC1YLShESVNDT05USU5VSVRZfEVORExJU1R8R0FQfElOREVQRU5ERU5ULVNFR01FTlRTKS8uc291cmNlLCAvKCMpKFteOl0qKTooLiopLy5zb3VyY2UsIC8oIykoLiopKD86LiopXFxyP1xcbj8vLnNvdXJjZV0uam9pbignfCcpKTtcbmNsYXNzIE0zVThQYXJzZXIge1xuICBzdGF0aWMgZmluZEdyb3VwKGdyb3VwcywgbWVkaWFHcm91cElkKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGdyb3VwID0gZ3JvdXBzW2ldO1xuICAgICAgaWYgKGdyb3VwLmlkID09PSBtZWRpYUdyb3VwSWQpIHtcbiAgICAgICAgcmV0dXJuIGdyb3VwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdGF0aWMgcmVzb2x2ZSh1cmwsIGJhc2VVcmwpIHtcbiAgICByZXR1cm4gdXJsVG9vbGtpdEV4cG9ydHMuYnVpbGRBYnNvbHV0ZVVSTChiYXNlVXJsLCB1cmwsIHtcbiAgICAgIGFsd2F5c05vcm1hbGl6ZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBpc01lZGlhUGxheWxpc3Qoc3RyKSB7XG4gICAgcmV0dXJuIElTX01FRElBX1BMQVlMSVNULnRlc3Qoc3RyKTtcbiAgfVxuICBzdGF0aWMgcGFyc2VNYXN0ZXJQbGF5bGlzdChzdHJpbmcsIGJhc2V1cmwpIHtcbiAgICBjb25zdCBoYXNWYXJpYWJsZVJlZnMgPSBoYXNWYXJpYWJsZVJlZmVyZW5jZXMoc3RyaW5nKSA7XG4gICAgY29uc3QgcGFyc2VkID0ge1xuICAgICAgY29udGVudFN0ZWVyaW5nOiBudWxsLFxuICAgICAgbGV2ZWxzOiBbXSxcbiAgICAgIHBsYXlsaXN0UGFyc2luZ0Vycm9yOiBudWxsLFxuICAgICAgc2Vzc2lvbkRhdGE6IG51bGwsXG4gICAgICBzZXNzaW9uS2V5czogbnVsbCxcbiAgICAgIHN0YXJ0VGltZU9mZnNldDogbnVsbCxcbiAgICAgIHZhcmlhYmxlTGlzdDogbnVsbCxcbiAgICAgIGhhc1ZhcmlhYmxlUmVmc1xuICAgIH07XG4gICAgY29uc3QgbGV2ZWxzV2l0aEtub3duQ29kZWNzID0gW107XG4gICAgTUFTVEVSX1BMQVlMSVNUX1JFR0VYLmxhc3RJbmRleCA9IDA7XG4gICAgbGV0IHJlc3VsdDtcbiAgICB3aGlsZSAoKHJlc3VsdCA9IE1BU1RFUl9QTEFZTElTVF9SRUdFWC5leGVjKHN0cmluZykpICE9IG51bGwpIHtcbiAgICAgIGlmIChyZXN1bHRbMV0pIHtcbiAgICAgICAgdmFyIF9sZXZlbCR1bmtub3duQ29kZWNzO1xuICAgICAgICAvLyAnI0VYVC1YLVNUUkVBTS1JTkYnIGlzIGZvdW5kLCBwYXJzZSBsZXZlbCB0YWcgIGluIGdyb3VwIDFcbiAgICAgICAgY29uc3QgYXR0cnMgPSBuZXcgQXR0ckxpc3QocmVzdWx0WzFdLCBwYXJzZWQpO1xuICAgICAgICBjb25zdCB1cmkgPSBzdWJzdGl0dXRlVmFyaWFibGVzKHBhcnNlZCwgcmVzdWx0WzJdKSA7XG4gICAgICAgIGNvbnN0IGxldmVsID0ge1xuICAgICAgICAgIGF0dHJzLFxuICAgICAgICAgIGJpdHJhdGU6IGF0dHJzLmRlY2ltYWxJbnRlZ2VyKCdCQU5EV0lEVEgnKSB8fCBhdHRycy5kZWNpbWFsSW50ZWdlcignQVZFUkFHRS1CQU5EV0lEVEgnKSxcbiAgICAgICAgICBuYW1lOiBhdHRycy5OQU1FLFxuICAgICAgICAgIHVybDogTTNVOFBhcnNlci5yZXNvbHZlKHVyaSwgYmFzZXVybClcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzb2x1dGlvbiA9IGF0dHJzLmRlY2ltYWxSZXNvbHV0aW9uKCdSRVNPTFVUSU9OJyk7XG4gICAgICAgIGlmIChyZXNvbHV0aW9uKSB7XG4gICAgICAgICAgbGV2ZWwud2lkdGggPSByZXNvbHV0aW9uLndpZHRoO1xuICAgICAgICAgIGxldmVsLmhlaWdodCA9IHJlc29sdXRpb24uaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHNldENvZGVjcyhhdHRycy5DT0RFQ1MsIGxldmVsKTtcbiAgICAgICAgY29uc3Qgc3VwcGxlbWVudGFsQ29kZWNzID0gYXR0cnNbJ1NVUFBMRU1FTlRBTC1DT0RFQ1MnXTtcbiAgICAgICAgaWYgKHN1cHBsZW1lbnRhbENvZGVjcykge1xuICAgICAgICAgIGxldmVsLnN1cHBsZW1lbnRhbCA9IHt9O1xuICAgICAgICAgIHNldENvZGVjcyhzdXBwbGVtZW50YWxDb2RlY3MsIGxldmVsLnN1cHBsZW1lbnRhbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoKF9sZXZlbCR1bmtub3duQ29kZWNzID0gbGV2ZWwudW5rbm93bkNvZGVjcykgIT0gbnVsbCAmJiBfbGV2ZWwkdW5rbm93bkNvZGVjcy5sZW5ndGgpKSB7XG4gICAgICAgICAgbGV2ZWxzV2l0aEtub3duQ29kZWNzLnB1c2gobGV2ZWwpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlZC5sZXZlbHMucHVzaChsZXZlbCk7XG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdFszXSkge1xuICAgICAgICBjb25zdCB0YWcgPSByZXN1bHRbM107XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSByZXN1bHRbNF07XG4gICAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgICAgY2FzZSAnU0VTU0lPTi1EQVRBJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLy8gI0VYVC1YLVNFU1NJT04tREFUQVxuICAgICAgICAgICAgICBjb25zdCBzZXNzaW9uQXR0cnMgPSBuZXcgQXR0ckxpc3QoYXR0cmlidXRlcywgcGFyc2VkKTtcbiAgICAgICAgICAgICAgY29uc3QgZGF0YUlkID0gc2Vzc2lvbkF0dHJzWydEQVRBLUlEJ107XG4gICAgICAgICAgICAgIGlmIChkYXRhSWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkLnNlc3Npb25EYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBwYXJzZWQuc2Vzc2lvbkRhdGEgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyc2VkLnNlc3Npb25EYXRhW2RhdGFJZF0gPSBzZXNzaW9uQXR0cnM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnU0VTU0lPTi1LRVknOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAvLyAjRVhULVgtU0VTU0lPTi1LRVlcbiAgICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbktleSA9IHBhcnNlS2V5KGF0dHJpYnV0ZXMsIGJhc2V1cmwsIHBhcnNlZCk7XG4gICAgICAgICAgICAgIGlmIChzZXNzaW9uS2V5LmVuY3J5cHRlZCAmJiBzZXNzaW9uS2V5LmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkLnNlc3Npb25LZXlzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBwYXJzZWQuc2Vzc2lvbktleXMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyc2VkLnNlc3Npb25LZXlzLnB1c2goc2Vzc2lvbktleSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYFtLZXlzXSBJZ25vcmluZyBpbnZhbGlkIEVYVC1YLVNFU1NJT04tS0VZIHRhZzogXCIke2F0dHJpYnV0ZXN9XCJgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdERUZJTkUnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAvLyAjRVhULVgtREVGSU5FXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YXJpYWJsZUF0dHJpYnV0ZXMgPSBuZXcgQXR0ckxpc3QoYXR0cmlidXRlcywgcGFyc2VkKTtcbiAgICAgICAgICAgICAgICBhZGRWYXJpYWJsZURlZmluaXRpb24ocGFyc2VkLCB2YXJpYWJsZUF0dHJpYnV0ZXMsIGJhc2V1cmwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ0NPTlRFTlQtU1RFRVJJTkcnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAvLyAjRVhULVgtQ09OVEVOVC1TVEVFUklOR1xuICAgICAgICAgICAgICBjb25zdCBjb250ZW50U3RlZXJpbmdBdHRyaWJ1dGVzID0gbmV3IEF0dHJMaXN0KGF0dHJpYnV0ZXMsIHBhcnNlZCk7XG4gICAgICAgICAgICAgIHBhcnNlZC5jb250ZW50U3RlZXJpbmcgPSB7XG4gICAgICAgICAgICAgICAgdXJpOiBNM1U4UGFyc2VyLnJlc29sdmUoY29udGVudFN0ZWVyaW5nQXR0cmlidXRlc1snU0VSVkVSLVVSSSddLCBiYXNldXJsKSxcbiAgICAgICAgICAgICAgICBwYXRod2F5SWQ6IGNvbnRlbnRTdGVlcmluZ0F0dHJpYnV0ZXNbJ1BBVEhXQVktSUQnXSB8fCAnLidcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnU1RBUlQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAvLyAjRVhULVgtU1RBUlRcbiAgICAgICAgICAgICAgcGFyc2VkLnN0YXJ0VGltZU9mZnNldCA9IHBhcnNlU3RhcnRUaW1lT2Zmc2V0KGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBGaWx0ZXIgb3V0IGxldmVscyB3aXRoIHVua25vd24gY29kZWNzIGlmIGl0IGRvZXMgbm90IHJlbW92ZSBhbGwgbGV2ZWxzXG4gICAgY29uc3Qgc3RyaXBVbmtub3duQ29kZWNMZXZlbHMgPSBsZXZlbHNXaXRoS25vd25Db2RlY3MubGVuZ3RoID4gMCAmJiBsZXZlbHNXaXRoS25vd25Db2RlY3MubGVuZ3RoIDwgcGFyc2VkLmxldmVscy5sZW5ndGg7XG4gICAgcGFyc2VkLmxldmVscyA9IHN0cmlwVW5rbm93bkNvZGVjTGV2ZWxzID8gbGV2ZWxzV2l0aEtub3duQ29kZWNzIDogcGFyc2VkLmxldmVscztcbiAgICBpZiAocGFyc2VkLmxldmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgIHBhcnNlZC5wbGF5bGlzdFBhcnNpbmdFcnJvciA9IG5ldyBFcnJvcignbm8gbGV2ZWxzIGZvdW5kIGluIG1hbmlmZXN0Jyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cbiAgc3RhdGljIHBhcnNlTWFzdGVyUGxheWxpc3RNZWRpYShzdHJpbmcsIGJhc2V1cmwsIHBhcnNlZCkge1xuICAgIGxldCByZXN1bHQ7XG4gICAgY29uc3QgcmVzdWx0cyA9IHt9O1xuICAgIGNvbnN0IGxldmVscyA9IHBhcnNlZC5sZXZlbHM7XG4gICAgY29uc3QgZ3JvdXBzQnlUeXBlID0ge1xuICAgICAgQVVESU86IGxldmVscy5tYXAobGV2ZWwgPT4gKHtcbiAgICAgICAgaWQ6IGxldmVsLmF0dHJzLkFVRElPLFxuICAgICAgICBhdWRpb0NvZGVjOiBsZXZlbC5hdWRpb0NvZGVjXG4gICAgICB9KSksXG4gICAgICBTVUJUSVRMRVM6IGxldmVscy5tYXAobGV2ZWwgPT4gKHtcbiAgICAgICAgaWQ6IGxldmVsLmF0dHJzLlNVQlRJVExFUyxcbiAgICAgICAgdGV4dENvZGVjOiBsZXZlbC50ZXh0Q29kZWNcbiAgICAgIH0pKSxcbiAgICAgICdDTE9TRUQtQ0FQVElPTlMnOiBbXVxuICAgIH07XG4gICAgbGV0IGlkID0gMDtcbiAgICBNQVNURVJfUExBWUxJU1RfTUVESUFfUkVHRVgubGFzdEluZGV4ID0gMDtcbiAgICB3aGlsZSAoKHJlc3VsdCA9IE1BU1RFUl9QTEFZTElTVF9NRURJQV9SRUdFWC5leGVjKHN0cmluZykpICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBhdHRycyA9IG5ldyBBdHRyTGlzdChyZXN1bHRbMV0sIHBhcnNlZCk7XG4gICAgICBjb25zdCB0eXBlID0gYXR0cnMuVFlQRTtcbiAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgIGNvbnN0IGdyb3VwcyA9IGdyb3Vwc0J5VHlwZVt0eXBlXTtcbiAgICAgICAgY29uc3QgbWVkaWFzID0gcmVzdWx0c1t0eXBlXSB8fCBbXTtcbiAgICAgICAgcmVzdWx0c1t0eXBlXSA9IG1lZGlhcztcbiAgICAgICAgY29uc3QgbGFuZyA9IGF0dHJzLkxBTkdVQUdFO1xuICAgICAgICBjb25zdCBhc3NvY0xhbmcgPSBhdHRyc1snQVNTT0MtTEFOR1VBR0UnXTtcbiAgICAgICAgY29uc3QgY2hhbm5lbHMgPSBhdHRycy5DSEFOTkVMUztcbiAgICAgICAgY29uc3QgY2hhcmFjdGVyaXN0aWNzID0gYXR0cnMuQ0hBUkFDVEVSSVNUSUNTO1xuICAgICAgICBjb25zdCBpbnN0cmVhbUlkID0gYXR0cnNbJ0lOU1RSRUFNLUlEJ107XG4gICAgICAgIGNvbnN0IG1lZGlhID0ge1xuICAgICAgICAgIGF0dHJzLFxuICAgICAgICAgIGJpdHJhdGU6IDAsXG4gICAgICAgICAgaWQ6IGlkKyssXG4gICAgICAgICAgZ3JvdXBJZDogYXR0cnNbJ0dST1VQLUlEJ10gfHwgJycsXG4gICAgICAgICAgbmFtZTogYXR0cnMuTkFNRSB8fCBsYW5nIHx8ICcnLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgZGVmYXVsdDogYXR0cnMuYm9vbCgnREVGQVVMVCcpLFxuICAgICAgICAgIGF1dG9zZWxlY3Q6IGF0dHJzLmJvb2woJ0FVVE9TRUxFQ1QnKSxcbiAgICAgICAgICBmb3JjZWQ6IGF0dHJzLmJvb2woJ0ZPUkNFRCcpLFxuICAgICAgICAgIGxhbmcsXG4gICAgICAgICAgdXJsOiBhdHRycy5VUkkgPyBNM1U4UGFyc2VyLnJlc29sdmUoYXR0cnMuVVJJLCBiYXNldXJsKSA6ICcnXG4gICAgICAgIH07XG4gICAgICAgIGlmIChhc3NvY0xhbmcpIHtcbiAgICAgICAgICBtZWRpYS5hc3NvY0xhbmcgPSBhc3NvY0xhbmc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5uZWxzKSB7XG4gICAgICAgICAgbWVkaWEuY2hhbm5lbHMgPSBjaGFubmVscztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhcmFjdGVyaXN0aWNzKSB7XG4gICAgICAgICAgbWVkaWEuY2hhcmFjdGVyaXN0aWNzID0gY2hhcmFjdGVyaXN0aWNzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnN0cmVhbUlkKSB7XG4gICAgICAgICAgbWVkaWEuaW5zdHJlYW1JZCA9IGluc3RyZWFtSWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwcyAhPSBudWxsICYmIGdyb3Vwcy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgYXVkaW8gb3IgdGV4dCBncm91cHMgc2lnbmFsbGVkIGluIHRoZSBtYW5pZmVzdCwgbGV0J3MgbG9vayBmb3IgYSBtYXRjaGluZyBjb2RlYyBzdHJpbmcgZm9yIHRoaXMgdHJhY2tcbiAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBmaW5kIHRoZSB0cmFjayBzaWduYWxsZWQsIGxldHMgdXNlIHRoZSBmaXJzdCBhdWRpbyBncm91cHMgY29kZWMgd2UgaGF2ZVxuICAgICAgICAgIC8vIEFjdGluZyBhcyBhIGJlc3QgZ3Vlc3NcbiAgICAgICAgICBjb25zdCBncm91cENvZGVjID0gTTNVOFBhcnNlci5maW5kR3JvdXAoZ3JvdXBzLCBtZWRpYS5ncm91cElkKSB8fCBncm91cHNbMF07XG4gICAgICAgICAgYXNzaWduQ29kZWMobWVkaWEsIGdyb3VwQ29kZWMsICdhdWRpb0NvZGVjJyk7XG4gICAgICAgICAgYXNzaWduQ29kZWMobWVkaWEsIGdyb3VwQ29kZWMsICd0ZXh0Q29kZWMnKTtcbiAgICAgICAgfVxuICAgICAgICBtZWRpYXMucHVzaChtZWRpYSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG4gIHN0YXRpYyBwYXJzZUxldmVsUGxheWxpc3Qoc3RyaW5nLCBiYXNldXJsLCBpZCwgdHlwZSwgbGV2ZWxVcmxJZCwgbXVsdGl2YXJpYW50VmFyaWFibGVMaXN0KSB7XG4gICAgdmFyIF9MRVZFTF9QTEFZTElTVF9SRUdFWDtcbiAgICBjb25zdCBiYXNlID0ge1xuICAgICAgdXJsOiBiYXNldXJsXG4gICAgfTtcbiAgICBjb25zdCBsZXZlbCA9IG5ldyBMZXZlbERldGFpbHMoYmFzZXVybCk7XG4gICAgY29uc3QgZnJhZ21lbnRzID0gbGV2ZWwuZnJhZ21lbnRzO1xuICAgIGNvbnN0IHByb2dyYW1EYXRlVGltZXMgPSBbXTtcbiAgICAvLyBUaGUgbW9zdCByZWNlbnQgaW5pdCBzZWdtZW50IHNlZW4gKGFwcGxpZXMgdG8gYWxsIHN1YnNlcXVlbnQgc2VnbWVudHMpXG4gICAgbGV0IGN1cnJlbnRJbml0U2VnbWVudCA9IG51bGw7XG4gICAgbGV0IGN1cnJlbnRTTiA9IDA7XG4gICAgbGV0IGN1cnJlbnRQYXJ0ID0gMDtcbiAgICBsZXQgdG90YWxkdXJhdGlvbiA9IDA7XG4gICAgbGV0IGRpc2NvbnRpbnVpdHlDb3VudGVyID0gMDtcbiAgICBsZXQgY3VycmVudEJpdHJhdGUgPSAwO1xuICAgIGxldCBwcmV2RnJhZyA9IG51bGw7XG4gICAgbGV0IGZyYWcgPSBuZXcgRnJhZ21lbnQodHlwZSwgYmFzZSk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBsZXQgaTtcbiAgICBsZXQgbGV2ZWxrZXlzO1xuICAgIGxldCBmaXJzdFBkdEluZGV4ID0gLTE7XG4gICAgbGV0IGNyZWF0ZU5leHRGcmFnID0gZmFsc2U7XG4gICAgbGV0IG5leHRCeXRlUmFuZ2UgPSBudWxsO1xuICAgIGxldCBzZXJ2ZXJDb250cm9sQXR0cnM7XG4gICAgTEVWRUxfUExBWUxJU1RfUkVHRVhfRkFTVC5sYXN0SW5kZXggPSAwO1xuICAgIGxldmVsLm0zdTggPSBzdHJpbmc7XG4gICAgbGV2ZWwuaGFzVmFyaWFibGVSZWZzID0gaGFzVmFyaWFibGVSZWZlcmVuY2VzKHN0cmluZykgO1xuICAgIGlmICgoKF9MRVZFTF9QTEFZTElTVF9SRUdFWCA9IExFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QuZXhlYyhzdHJpbmcpKSA9PSBudWxsID8gdm9pZCAwIDogX0xFVkVMX1BMQVlMSVNUX1JFR0VYWzBdKSAhPT0gJyNFWFRNM1UnKSB7XG4gICAgICBsZXZlbC5wbGF5bGlzdFBhcnNpbmdFcnJvciA9IG5ldyBFcnJvcignTWlzc2luZyBmb3JtYXQgaWRlbnRpZmllciAjRVhUTTNVJyk7XG4gICAgICByZXR1cm4gbGV2ZWw7XG4gICAgfVxuICAgIHdoaWxlICgocmVzdWx0ID0gTEVWRUxfUExBWUxJU1RfUkVHRVhfRkFTVC5leGVjKHN0cmluZykpICE9PSBudWxsKSB7XG4gICAgICBpZiAoY3JlYXRlTmV4dEZyYWcpIHtcbiAgICAgICAgY3JlYXRlTmV4dEZyYWcgPSBmYWxzZTtcbiAgICAgICAgZnJhZyA9IG5ldyBGcmFnbWVudCh0eXBlLCBiYXNlKTtcbiAgICAgICAgLy8gc2V0dXAgdGhlIG5leHQgZnJhZ21lbnQgZm9yIHBhcnQgbG9hZGluZ1xuICAgICAgICBmcmFnLnBsYXlsaXN0T2Zmc2V0ID0gdG90YWxkdXJhdGlvbjtcbiAgICAgICAgZnJhZy5zdGFydCA9IHRvdGFsZHVyYXRpb247XG4gICAgICAgIGZyYWcuc24gPSBjdXJyZW50U047XG4gICAgICAgIGZyYWcuY2MgPSBkaXNjb250aW51aXR5Q291bnRlcjtcbiAgICAgICAgaWYgKGN1cnJlbnRCaXRyYXRlKSB7XG4gICAgICAgICAgZnJhZy5iaXRyYXRlID0gY3VycmVudEJpdHJhdGU7XG4gICAgICAgIH1cbiAgICAgICAgZnJhZy5sZXZlbCA9IGlkO1xuICAgICAgICBpZiAoY3VycmVudEluaXRTZWdtZW50KSB7XG4gICAgICAgICAgZnJhZy5pbml0U2VnbWVudCA9IGN1cnJlbnRJbml0U2VnbWVudDtcbiAgICAgICAgICBpZiAoY3VycmVudEluaXRTZWdtZW50LnJhd1Byb2dyYW1EYXRlVGltZSkge1xuICAgICAgICAgICAgZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUgPSBjdXJyZW50SW5pdFNlZ21lbnQucmF3UHJvZ3JhbURhdGVUaW1lO1xuICAgICAgICAgICAgY3VycmVudEluaXRTZWdtZW50LnJhd1Byb2dyYW1EYXRlVGltZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZXh0Qnl0ZVJhbmdlKSB7XG4gICAgICAgICAgICBmcmFnLnNldEJ5dGVSYW5nZShuZXh0Qnl0ZVJhbmdlKTtcbiAgICAgICAgICAgIG5leHRCeXRlUmFuZ2UgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgZHVyYXRpb24gPSByZXN1bHRbMV07XG4gICAgICBpZiAoZHVyYXRpb24pIHtcbiAgICAgICAgLy8gSU5GXG4gICAgICAgIGZyYWcuZHVyYXRpb24gPSBwYXJzZUZsb2F0KGR1cmF0aW9uKTtcbiAgICAgICAgLy8gYXZvaWQgc2xpY2VkIHN0cmluZ3MgICAgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzkzOVxuICAgICAgICBjb25zdCB0aXRsZSA9ICgnICcgKyByZXN1bHRbMl0pLnNsaWNlKDEpO1xuICAgICAgICBmcmFnLnRpdGxlID0gdGl0bGUgfHwgbnVsbDtcbiAgICAgICAgZnJhZy50YWdMaXN0LnB1c2godGl0bGUgPyBbJ0lORicsIGR1cmF0aW9uLCB0aXRsZV0gOiBbJ0lORicsIGR1cmF0aW9uXSk7XG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdFszXSkge1xuICAgICAgICAvLyB1cmxcbiAgICAgICAgaWYgKGlzRmluaXRlTnVtYmVyKGZyYWcuZHVyYXRpb24pKSB7XG4gICAgICAgICAgZnJhZy5wbGF5bGlzdE9mZnNldCA9IHRvdGFsZHVyYXRpb247XG4gICAgICAgICAgZnJhZy5zdGFydCA9IHRvdGFsZHVyYXRpb247XG4gICAgICAgICAgaWYgKGxldmVsa2V5cykge1xuICAgICAgICAgICAgc2V0RnJhZ0xldmVsS2V5cyhmcmFnLCBsZXZlbGtleXMsIGxldmVsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnJhZy5zbiA9IGN1cnJlbnRTTjtcbiAgICAgICAgICBmcmFnLmxldmVsID0gaWQ7XG4gICAgICAgICAgZnJhZy5jYyA9IGRpc2NvbnRpbnVpdHlDb3VudGVyO1xuICAgICAgICAgIGZyYWdtZW50cy5wdXNoKGZyYWcpO1xuICAgICAgICAgIC8vIGF2b2lkIHNsaWNlZCBzdHJpbmdzICAgIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy85MzlcbiAgICAgICAgICBjb25zdCB1cmkgPSAoJyAnICsgcmVzdWx0WzNdKS5zbGljZSgxKTtcbiAgICAgICAgICBmcmFnLnJlbHVybCA9IHN1YnN0aXR1dGVWYXJpYWJsZXMobGV2ZWwsIHVyaSkgO1xuICAgICAgICAgIGFzc2lnblByb2dyYW1EYXRlVGltZShmcmFnLCBwcmV2RnJhZywgcHJvZ3JhbURhdGVUaW1lcyk7XG4gICAgICAgICAgcHJldkZyYWcgPSBmcmFnO1xuICAgICAgICAgIHRvdGFsZHVyYXRpb24gKz0gZnJhZy5kdXJhdGlvbjtcbiAgICAgICAgICBjdXJyZW50U04rKztcbiAgICAgICAgICBjdXJyZW50UGFydCA9IDA7XG4gICAgICAgICAgY3JlYXRlTmV4dEZyYWcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSByZXN1bHRbMF0ubWF0Y2goTEVWRUxfUExBWUxJU1RfUkVHRVhfU0xPVyk7XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oJ05vIG1hdGNoZXMgb24gc2xvdyByZWdleCBtYXRjaCBmb3IgbGV2ZWwgcGxheWxpc3QhJyk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMTsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChyZXN1bHRbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXZvaWQgc2xpY2VkIHN0cmluZ3MgICAgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzkzOVxuICAgICAgICBjb25zdCB0YWcgPSAoJyAnICsgcmVzdWx0W2ldKS5zbGljZSgxKTtcbiAgICAgICAgY29uc3QgdmFsdWUxID0gKCcgJyArIHJlc3VsdFtpICsgMV0pLnNsaWNlKDEpO1xuICAgICAgICBjb25zdCB2YWx1ZTIgPSByZXN1bHRbaSArIDJdID8gKCcgJyArIHJlc3VsdFtpICsgMl0pLnNsaWNlKDEpIDogbnVsbDtcbiAgICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgICBjYXNlICdCWVRFUkFOR0UnOlxuICAgICAgICAgICAgaWYgKHByZXZGcmFnKSB7XG4gICAgICAgICAgICAgIGZyYWcuc2V0Qnl0ZVJhbmdlKHZhbHVlMSwgcHJldkZyYWcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZnJhZy5zZXRCeXRlUmFuZ2UodmFsdWUxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ1BST0dSQU0tREFURS1USU1FJzpcbiAgICAgICAgICAgIC8vIGF2b2lkIHNsaWNlZCBzdHJpbmdzICAgIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy85MzlcbiAgICAgICAgICAgIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lID0gdmFsdWUxO1xuICAgICAgICAgICAgZnJhZy50YWdMaXN0LnB1c2goWydQUk9HUkFNLURBVEUtVElNRScsIHZhbHVlMV0pO1xuICAgICAgICAgICAgaWYgKGZpcnN0UGR0SW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgIGZpcnN0UGR0SW5kZXggPSBmcmFnbWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnUExBWUxJU1QtVFlQRSc6XG4gICAgICAgICAgICBpZiAobGV2ZWwudHlwZSkge1xuICAgICAgICAgICAgICBhc3NpZ25NdWx0aXBsZU1lZGlhUGxheWxpc3RUYWdPY2N1cmFuY2VFcnJvcihsZXZlbCwgdGFnLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV2ZWwudHlwZSA9IHZhbHVlMS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnTUVESUEtU0VRVUVOQ0UnOlxuICAgICAgICAgICAgaWYgKGxldmVsLnN0YXJ0U04gIT09IDApIHtcbiAgICAgICAgICAgICAgYXNzaWduTXVsdGlwbGVNZWRpYVBsYXlsaXN0VGFnT2NjdXJhbmNlRXJyb3IobGV2ZWwsIHRhZywgcmVzdWx0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZnJhZ21lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgYXNzaWduTXVzdEFwcGVhckJlZm9yZVNlZ21lbnRzRXJyb3IobGV2ZWwsIHRhZywgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRTTiA9IGxldmVsLnN0YXJ0U04gPSBwYXJzZUludCh2YWx1ZTEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnU0tJUCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmIChsZXZlbC5za2lwcGVkU2VnbWVudHMpIHtcbiAgICAgICAgICAgICAgICBhc3NpZ25NdWx0aXBsZU1lZGlhUGxheWxpc3RUYWdPY2N1cmFuY2VFcnJvcihsZXZlbCwgdGFnLCByZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IHNraXBBdHRycyA9IG5ldyBBdHRyTGlzdCh2YWx1ZTEsIGxldmVsKTtcbiAgICAgICAgICAgICAgY29uc3Qgc2tpcHBlZFNlZ21lbnRzID0gc2tpcEF0dHJzLmRlY2ltYWxJbnRlZ2VyKCdTS0lQUEVELVNFR01FTlRTJyk7XG4gICAgICAgICAgICAgIGlmIChpc0Zpbml0ZU51bWJlcihza2lwcGVkU2VnbWVudHMpKSB7XG4gICAgICAgICAgICAgICAgbGV2ZWwuc2tpcHBlZFNlZ21lbnRzICs9IHNraXBwZWRTZWdtZW50cztcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgcmVzdWx0IGluIGZyYWdtZW50c1tdIGNvbnRhaW5pbmcgdW5kZWZpbmVkIHZhbHVlcywgd2hpY2ggd2Ugd2lsbCBmaWxsIGluIHdpdGggYG1lcmdlRGV0YWlsc2BcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBfaSA9IHNraXBwZWRTZWdtZW50czsgX2ktLTspIHtcbiAgICAgICAgICAgICAgICAgIGZyYWdtZW50cy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50U04gKz0gc2tpcHBlZFNlZ21lbnRzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IHJlY2VudGx5UmVtb3ZlZERhdGVyYW5nZXMgPSBza2lwQXR0cnMuZW51bWVyYXRlZFN0cmluZygnUkVDRU5UTFktUkVNT1ZFRC1EQVRFUkFOR0VTJyk7XG4gICAgICAgICAgICAgIGlmIChyZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgbGV2ZWwucmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcyA9IChsZXZlbC5yZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzIHx8IFtdKS5jb25jYXQocmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcy5zcGxpdCgnXFx0JykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ1RBUkdFVERVUkFUSU9OJzpcbiAgICAgICAgICAgIGlmIChsZXZlbC50YXJnZXRkdXJhdGlvbiAhPT0gMCkge1xuICAgICAgICAgICAgICBhc3NpZ25NdWx0aXBsZU1lZGlhUGxheWxpc3RUYWdPY2N1cmFuY2VFcnJvcihsZXZlbCwgdGFnLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV2ZWwudGFyZ2V0ZHVyYXRpb24gPSBNYXRoLm1heChwYXJzZUludCh2YWx1ZTEpLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ1ZFUlNJT04nOlxuICAgICAgICAgICAgaWYgKGxldmVsLnZlcnNpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgYXNzaWduTXVsdGlwbGVNZWRpYVBsYXlsaXN0VGFnT2NjdXJhbmNlRXJyb3IobGV2ZWwsIHRhZywgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldmVsLnZlcnNpb24gPSBwYXJzZUludCh2YWx1ZTEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnSU5ERVBFTkRFTlQtU0VHTUVOVFMnOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnRU5ETElTVCc6XG4gICAgICAgICAgICBpZiAoIWxldmVsLmxpdmUpIHtcbiAgICAgICAgICAgICAgYXNzaWduTXVsdGlwbGVNZWRpYVBsYXlsaXN0VGFnT2NjdXJhbmNlRXJyb3IobGV2ZWwsIHRhZywgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldmVsLmxpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJyMnOlxuICAgICAgICAgICAgaWYgKHZhbHVlMSB8fCB2YWx1ZTIpIHtcbiAgICAgICAgICAgICAgZnJhZy50YWdMaXN0LnB1c2godmFsdWUyID8gW3ZhbHVlMSwgdmFsdWUyXSA6IFt2YWx1ZTFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0RJU0NPTlRJTlVJVFknOlxuICAgICAgICAgICAgZGlzY29udGludWl0eUNvdW50ZXIrKztcbiAgICAgICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKFsnRElTJ10pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnR0FQJzpcbiAgICAgICAgICAgIGZyYWcuZ2FwID0gdHJ1ZTtcbiAgICAgICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKFt0YWddKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0JJVFJBVEUnOlxuICAgICAgICAgICAgZnJhZy50YWdMaXN0LnB1c2goW3RhZywgdmFsdWUxXSk7XG4gICAgICAgICAgICBjdXJyZW50Qml0cmF0ZSA9IHBhcnNlSW50KHZhbHVlMSkgKiAxMDAwO1xuICAgICAgICAgICAgaWYgKGlzRmluaXRlTnVtYmVyKGN1cnJlbnRCaXRyYXRlKSkge1xuICAgICAgICAgICAgICBmcmFnLmJpdHJhdGUgPSBjdXJyZW50Qml0cmF0ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRCaXRyYXRlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0RBVEVSQU5HRSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IGRhdGVSYW5nZUF0dHIgPSBuZXcgQXR0ckxpc3QodmFsdWUxLCBsZXZlbCk7XG4gICAgICAgICAgICAgIGNvbnN0IGRhdGVSYW5nZSA9IG5ldyBEYXRlUmFuZ2UoZGF0ZVJhbmdlQXR0ciwgbGV2ZWwuZGF0ZVJhbmdlc1tkYXRlUmFuZ2VBdHRyLklEXSwgbGV2ZWwuZGF0ZVJhbmdlVGFnQ291bnQpO1xuICAgICAgICAgICAgICBsZXZlbC5kYXRlUmFuZ2VUYWdDb3VudCsrO1xuICAgICAgICAgICAgICBpZiAoZGF0ZVJhbmdlLmlzVmFsaWQgfHwgbGV2ZWwuc2tpcHBlZFNlZ21lbnRzKSB7XG4gICAgICAgICAgICAgICAgbGV2ZWwuZGF0ZVJhbmdlc1tkYXRlUmFuZ2UuaWRdID0gZGF0ZVJhbmdlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBJZ25vcmluZyBpbnZhbGlkIERBVEVSQU5HRSB0YWc6IFwiJHt2YWx1ZTF9XCJgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBBZGQgdG8gZnJhZ21lbnQgdGFnIGxpc3QgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5ICg8IHYxLjIuMClcbiAgICAgICAgICAgICAgZnJhZy50YWdMaXN0LnB1c2goWydFWFQtWC1EQVRFUkFOR0UnLCB2YWx1ZTFdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnREVGSU5FJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlQXR0cmlidXRlcyA9IG5ldyBBdHRyTGlzdCh2YWx1ZTEsIGxldmVsKTtcbiAgICAgICAgICAgICAgICBpZiAoJ0lNUE9SVCcgaW4gdmFyaWFibGVBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICBpbXBvcnRWYXJpYWJsZURlZmluaXRpb24obGV2ZWwsIHZhcmlhYmxlQXR0cmlidXRlcywgbXVsdGl2YXJpYW50VmFyaWFibGVMaXN0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgYWRkVmFyaWFibGVEZWZpbml0aW9uKGxldmVsLCB2YXJpYWJsZUF0dHJpYnV0ZXMsIGJhc2V1cmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdESVNDT05USU5VSVRZLVNFUVVFTkNFJzpcbiAgICAgICAgICAgIGlmIChsZXZlbC5zdGFydENDICE9PSAwKSB7XG4gICAgICAgICAgICAgIGFzc2lnbk11bHRpcGxlTWVkaWFQbGF5bGlzdFRhZ09jY3VyYW5jZUVycm9yKGxldmVsLCB0YWcsIHJlc3VsdCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZyYWdtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGFzc2lnbk11c3RBcHBlYXJCZWZvcmVTZWdtZW50c0Vycm9yKGxldmVsLCB0YWcsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXZlbC5zdGFydENDID0gZGlzY29udGludWl0eUNvdW50ZXIgPSBwYXJzZUludCh2YWx1ZTEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnS0VZJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgbGV2ZWxLZXkgPSBwYXJzZUtleSh2YWx1ZTEsIGJhc2V1cmwsIGxldmVsKTtcbiAgICAgICAgICAgICAgaWYgKGxldmVsS2V5LmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAobGV2ZWxLZXkubWV0aG9kID09PSAnTk9ORScpIHtcbiAgICAgICAgICAgICAgICAgIGxldmVsa2V5cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWxldmVsa2V5cykge1xuICAgICAgICAgICAgICAgICAgbGV2ZWxrZXlzID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRLZXkgPSBsZXZlbGtleXNbbGV2ZWxLZXkua2V5Rm9ybWF0XTtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZHVwbGljYXRlIHBsYXlsaXN0IEtFWSB0YWdzXG4gICAgICAgICAgICAgICAgaWYgKCEoY3VycmVudEtleSAhPSBudWxsICYmIGN1cnJlbnRLZXkubWF0Y2hlcyhsZXZlbEtleSkpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoY3VycmVudEtleSkge1xuICAgICAgICAgICAgICAgICAgICBsZXZlbGtleXMgPSBfZXh0ZW5kcyh7fSwgbGV2ZWxrZXlzKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGxldmVsa2V5c1tsZXZlbEtleS5rZXlGb3JtYXRdID0gbGV2ZWxLZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBbS2V5c10gSWdub3JpbmcgaW52YWxpZCBFWFQtWC1LRVkgdGFnOiBcIiR7dmFsdWUxfVwiYCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnU1RBUlQnOlxuICAgICAgICAgICAgbGV2ZWwuc3RhcnRUaW1lT2Zmc2V0ID0gcGFyc2VTdGFydFRpbWVPZmZzZXQodmFsdWUxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ01BUCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IG1hcEF0dHJzID0gbmV3IEF0dHJMaXN0KHZhbHVlMSwgbGV2ZWwpO1xuICAgICAgICAgICAgICBpZiAoZnJhZy5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIEluaXRpYWwgc2VnbWVudCB0YWcgaXMgYWZ0ZXIgc2VnbWVudCBkdXJhdGlvbiB0YWcuXG4gICAgICAgICAgICAgICAgLy8gICAjRVhUSU5GOiA2LjBcbiAgICAgICAgICAgICAgICAvLyAgICNFWFQtWC1NQVA6VVJJPVwiaW5pdC5tcDRcbiAgICAgICAgICAgICAgICBjb25zdCBpbml0ID0gbmV3IEZyYWdtZW50KHR5cGUsIGJhc2UpO1xuICAgICAgICAgICAgICAgIHNldEluaXRTZWdtZW50KGluaXQsIG1hcEF0dHJzLCBpZCwgbGV2ZWxrZXlzKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50SW5pdFNlZ21lbnQgPSBpbml0O1xuICAgICAgICAgICAgICAgIGZyYWcuaW5pdFNlZ21lbnQgPSBjdXJyZW50SW5pdFNlZ21lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRJbml0U2VnbWVudC5yYXdQcm9ncmFtRGF0ZVRpbWUgJiYgIWZyYWcucmF3UHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgICAgICAgICAgICAgICBmcmFnLnJhd1Byb2dyYW1EYXRlVGltZSA9IGN1cnJlbnRJbml0U2VnbWVudC5yYXdQcm9ncmFtRGF0ZVRpbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEluaXRpYWwgc2VnbWVudCB0YWcgaXMgYmVmb3JlIHNlZ21lbnQgZHVyYXRpb24gdGFnXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlcmUgRVhULVgtTUFQIGlzIGRlY2xhcmVkIGFmdGVyIEVYVC1YLUJZVEVSQU5HRVxuICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IGZyYWcuYnl0ZVJhbmdlRW5kT2Zmc2V0O1xuICAgICAgICAgICAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gZnJhZy5ieXRlUmFuZ2VTdGFydE9mZnNldDtcbiAgICAgICAgICAgICAgICAgIG5leHRCeXRlUmFuZ2UgPSBgJHtlbmQgLSBzdGFydH1AJHtzdGFydH1gO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBuZXh0Qnl0ZVJhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0SW5pdFNlZ21lbnQoZnJhZywgbWFwQXR0cnMsIGlkLCBsZXZlbGtleXMpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRJbml0U2VnbWVudCA9IGZyYWc7XG4gICAgICAgICAgICAgICAgY3JlYXRlTmV4dEZyYWcgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGN1cnJlbnRJbml0U2VnbWVudC5jYyA9IGRpc2NvbnRpbnVpdHlDb3VudGVyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdTRVJWRVItQ09OVFJPTCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmIChzZXJ2ZXJDb250cm9sQXR0cnMpIHtcbiAgICAgICAgICAgICAgICBhc3NpZ25NdWx0aXBsZU1lZGlhUGxheWxpc3RUYWdPY2N1cmFuY2VFcnJvcihsZXZlbCwgdGFnLCByZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNlcnZlckNvbnRyb2xBdHRycyA9IG5ldyBBdHRyTGlzdCh2YWx1ZTEpO1xuICAgICAgICAgICAgICBsZXZlbC5jYW5CbG9ja1JlbG9hZCA9IHNlcnZlckNvbnRyb2xBdHRycy5ib29sKCdDQU4tQkxPQ0stUkVMT0FEJyk7XG4gICAgICAgICAgICAgIGxldmVsLmNhblNraXBVbnRpbCA9IHNlcnZlckNvbnRyb2xBdHRycy5vcHRpb25hbEZsb2F0KCdDQU4tU0tJUC1VTlRJTCcsIDApO1xuICAgICAgICAgICAgICBsZXZlbC5jYW5Ta2lwRGF0ZVJhbmdlcyA9IGxldmVsLmNhblNraXBVbnRpbCA+IDAgJiYgc2VydmVyQ29udHJvbEF0dHJzLmJvb2woJ0NBTi1TS0lQLURBVEVSQU5HRVMnKTtcbiAgICAgICAgICAgICAgbGV2ZWwucGFydEhvbGRCYWNrID0gc2VydmVyQ29udHJvbEF0dHJzLm9wdGlvbmFsRmxvYXQoJ1BBUlQtSE9MRC1CQUNLJywgMCk7XG4gICAgICAgICAgICAgIGxldmVsLmhvbGRCYWNrID0gc2VydmVyQ29udHJvbEF0dHJzLm9wdGlvbmFsRmxvYXQoJ0hPTEQtQkFDSycsIDApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdQQVJULUlORic6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmIChsZXZlbC5wYXJ0VGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgYXNzaWduTXVsdGlwbGVNZWRpYVBsYXlsaXN0VGFnT2NjdXJhbmNlRXJyb3IobGV2ZWwsIHRhZywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBwYXJ0SW5mQXR0cnMgPSBuZXcgQXR0ckxpc3QodmFsdWUxKTtcbiAgICAgICAgICAgICAgbGV2ZWwucGFydFRhcmdldCA9IHBhcnRJbmZBdHRycy5kZWNpbWFsRmxvYXRpbmdQb2ludCgnUEFSVC1UQVJHRVQnKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnUEFSVCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGxldCBwYXJ0TGlzdCA9IGxldmVsLnBhcnRMaXN0O1xuICAgICAgICAgICAgICBpZiAoIXBhcnRMaXN0KSB7XG4gICAgICAgICAgICAgICAgcGFydExpc3QgPSBsZXZlbC5wYXJ0TGlzdCA9IFtdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzRnJhZ21lbnRQYXJ0ID0gY3VycmVudFBhcnQgPiAwID8gcGFydExpc3RbcGFydExpc3QubGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gY3VycmVudFBhcnQrKztcbiAgICAgICAgICAgICAgY29uc3QgcGFydEF0dHJzID0gbmV3IEF0dHJMaXN0KHZhbHVlMSwgbGV2ZWwpO1xuICAgICAgICAgICAgICBjb25zdCBwYXJ0ID0gbmV3IFBhcnQocGFydEF0dHJzLCBmcmFnLCBiYXNlLCBpbmRleCwgcHJldmlvdXNGcmFnbWVudFBhcnQpO1xuICAgICAgICAgICAgICBwYXJ0TGlzdC5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgICBmcmFnLmR1cmF0aW9uICs9IHBhcnQuZHVyYXRpb247XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ1BSRUxPQUQtSElOVCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IHByZWxvYWRIaW50QXR0cnMgPSBuZXcgQXR0ckxpc3QodmFsdWUxLCBsZXZlbCk7XG4gICAgICAgICAgICAgIGxldmVsLnByZWxvYWRIaW50ID0gcHJlbG9hZEhpbnRBdHRycztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnUkVORElUSU9OLVJFUE9SVCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlbmRpdGlvblJlcG9ydEF0dHJzID0gbmV3IEF0dHJMaXN0KHZhbHVlMSwgbGV2ZWwpO1xuICAgICAgICAgICAgICBsZXZlbC5yZW5kaXRpb25SZXBvcnRzID0gbGV2ZWwucmVuZGl0aW9uUmVwb3J0cyB8fCBbXTtcbiAgICAgICAgICAgICAgbGV2ZWwucmVuZGl0aW9uUmVwb3J0cy5wdXNoKHJlbmRpdGlvblJlcG9ydEF0dHJzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBsaW5lIHBhcnNlZCBidXQgbm90IGhhbmRsZWQ6ICR7cmVzdWx0fWApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByZXZGcmFnICYmICFwcmV2RnJhZy5yZWx1cmwpIHtcbiAgICAgIGZyYWdtZW50cy5wb3AoKTtcbiAgICAgIHRvdGFsZHVyYXRpb24gLT0gcHJldkZyYWcuZHVyYXRpb247XG4gICAgICBpZiAobGV2ZWwucGFydExpc3QpIHtcbiAgICAgICAgbGV2ZWwuZnJhZ21lbnRIaW50ID0gcHJldkZyYWc7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsZXZlbC5wYXJ0TGlzdCkge1xuICAgICAgYXNzaWduUHJvZ3JhbURhdGVUaW1lKGZyYWcsIHByZXZGcmFnLCBwcm9ncmFtRGF0ZVRpbWVzKTtcbiAgICAgIGZyYWcuY2MgPSBkaXNjb250aW51aXR5Q291bnRlcjtcbiAgICAgIGxldmVsLmZyYWdtZW50SGludCA9IGZyYWc7XG4gICAgICBpZiAobGV2ZWxrZXlzKSB7XG4gICAgICAgIHNldEZyYWdMZXZlbEtleXMoZnJhZywgbGV2ZWxrZXlzLCBsZXZlbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghbGV2ZWwudGFyZ2V0ZHVyYXRpb24pIHtcbiAgICAgIGxldmVsLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKGAjRVhULVgtVEFSR0VURFVSQVRJT04gaXMgcmVxdWlyZWRgKTtcbiAgICB9XG4gICAgY29uc3QgZnJhZ21lbnRMZW5ndGggPSBmcmFnbWVudHMubGVuZ3RoO1xuICAgIGNvbnN0IGZpcnN0RnJhZ21lbnQgPSBmcmFnbWVudHNbMF07XG4gICAgY29uc3QgbGFzdEZyYWdtZW50ID0gZnJhZ21lbnRzW2ZyYWdtZW50TGVuZ3RoIC0gMV07XG4gICAgdG90YWxkdXJhdGlvbiArPSBsZXZlbC5za2lwcGVkU2VnbWVudHMgKiBsZXZlbC50YXJnZXRkdXJhdGlvbjtcbiAgICBpZiAodG90YWxkdXJhdGlvbiA+IDAgJiYgZnJhZ21lbnRMZW5ndGggJiYgbGFzdEZyYWdtZW50KSB7XG4gICAgICBsZXZlbC5hdmVyYWdldGFyZ2V0ZHVyYXRpb24gPSB0b3RhbGR1cmF0aW9uIC8gZnJhZ21lbnRMZW5ndGg7XG4gICAgICBjb25zdCBsYXN0U24gPSBsYXN0RnJhZ21lbnQuc247XG4gICAgICBsZXZlbC5lbmRTTiA9IGxhc3RTbiAhPT0gJ2luaXRTZWdtZW50JyA/IGxhc3RTbiA6IDA7XG4gICAgICBpZiAoIWxldmVsLmxpdmUpIHtcbiAgICAgICAgbGFzdEZyYWdtZW50LmVuZExpc3QgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGZpcnN0RnJhZ21lbnQgJiYgbGV2ZWwuc3RhcnRDQyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldmVsLnN0YXJ0Q0MgPSBmaXJzdEZyYWdtZW50LmNjO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZmlsbCBhbnkgbWlzc2luZyBQRFQgdmFsdWVzXG4gICAgICAgKiBcIklmIHRoZSBmaXJzdCBFWFQtWC1QUk9HUkFNLURBVEUtVElNRSB0YWcgaW4gYSBQbGF5bGlzdCBhcHBlYXJzIGFmdGVyXG4gICAgICAgKiBvbmUgb3IgbW9yZSBNZWRpYSBTZWdtZW50IFVSSXMsIHRoZSBjbGllbnQgU0hPVUxEIGV4dHJhcG9sYXRlXG4gICAgICAgKiBiYWNrd2FyZCBmcm9tIHRoYXQgdGFnICh1c2luZyBFWFRJTkYgZHVyYXRpb25zIGFuZC9vciBtZWRpYVxuICAgICAgICogdGltZXN0YW1wcykgdG8gYXNzb2NpYXRlIGRhdGVzIHdpdGggdGhvc2Ugc2VnbWVudHMuXCJcbiAgICAgICAqIFdlIGhhdmUgYWxyZWFkeSBleHRyYXBvbGF0ZWQgZm9yd2FyZCwgYnV0IGFsbCBmcmFnbWVudHMgdXAgdG8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIFBEVCBkbyBub3QgaGF2ZSB0aGVpciBQRFRzXG4gICAgICAgKiBjb21wdXRlZC5cbiAgICAgICAqL1xuICAgICAgaWYgKGZpcnN0UGR0SW5kZXggPiAwKSB7XG4gICAgICAgIGJhY2tmaWxsUHJvZ3JhbURhdGVUaW1lcyhmcmFnbWVudHMsIGZpcnN0UGR0SW5kZXgpO1xuICAgICAgICBpZiAoZmlyc3RGcmFnbWVudCkge1xuICAgICAgICAgIHByb2dyYW1EYXRlVGltZXMudW5zaGlmdChmaXJzdEZyYWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXZlbC5lbmRTTiA9IDA7XG4gICAgICBsZXZlbC5zdGFydENDID0gMDtcbiAgICB9XG4gICAgaWYgKGxldmVsLmZyYWdtZW50SGludCkge1xuICAgICAgdG90YWxkdXJhdGlvbiArPSBsZXZlbC5mcmFnbWVudEhpbnQuZHVyYXRpb247XG4gICAgfVxuICAgIGxldmVsLnRvdGFsZHVyYXRpb24gPSB0b3RhbGR1cmF0aW9uO1xuICAgIGlmIChwcm9ncmFtRGF0ZVRpbWVzLmxlbmd0aCAmJiBsZXZlbC5kYXRlUmFuZ2VUYWdDb3VudCAmJiBmaXJzdEZyYWdtZW50KSB7XG4gICAgICBtYXBEYXRlUmFuZ2VzKHByb2dyYW1EYXRlVGltZXMsIGxldmVsKTtcbiAgICB9XG4gICAgbGV2ZWwuZW5kQ0MgPSBkaXNjb250aW51aXR5Q291bnRlcjtcbiAgICByZXR1cm4gbGV2ZWw7XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcERhdGVSYW5nZXMocHJvZ3JhbURhdGVUaW1lcywgZGV0YWlscykge1xuICAvLyBNYWtlIHN1cmUgRGF0ZVJhbmdlcyBhcmUgbWFwcGVkIHRvIGEgUHJvZ3JhbURhdGVUaW1lIHRhZyB0aGF0IGFwcGxpZXMgYSBkYXRlIHRvIGEgc2VnbWVudCB0aGF0IG92ZXJsYXBzIHdpdGggaXRzIHN0YXJ0IGRhdGVcbiAgY29uc3QgcHJvZ3JhbURhdGVUaW1lQ291bnQgPSBwcm9ncmFtRGF0ZVRpbWVzLmxlbmd0aDtcbiAgaWYgKCFwcm9ncmFtRGF0ZVRpbWVDb3VudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBsYXN0UHJvZ3JhbURhdGVUaW1lID0gcHJvZ3JhbURhdGVUaW1lc1twcm9ncmFtRGF0ZVRpbWVDb3VudCAtIDFdO1xuICBjb25zdCBwbGF5bGlzdEVuZCA9IGRldGFpbHMubGl2ZSA/IEluZmluaXR5IDogZGV0YWlscy50b3RhbGR1cmF0aW9uO1xuICBjb25zdCBkYXRlUmFuZ2VJZHMgPSBPYmplY3Qua2V5cyhkZXRhaWxzLmRhdGVSYW5nZXMpO1xuICBmb3IgKGxldCBpID0gZGF0ZVJhbmdlSWRzLmxlbmd0aDsgaS0tOykge1xuICAgIGNvbnN0IGRhdGVSYW5nZSA9IGRldGFpbHMuZGF0ZVJhbmdlc1tkYXRlUmFuZ2VJZHNbaV1dO1xuICAgIGNvbnN0IHN0YXJ0RGF0ZVRpbWUgPSBkYXRlUmFuZ2Uuc3RhcnREYXRlLmdldFRpbWUoKTtcbiAgICBkYXRlUmFuZ2UudGFnQW5jaG9yID0gbGFzdFByb2dyYW1EYXRlVGltZS5yZWY7XG4gICAgZm9yIChsZXQgaiA9IHByb2dyYW1EYXRlVGltZUNvdW50OyBqLS07KSB7XG4gICAgICBjb25zdCBmcmFnSW5kZXggPSBmaW5kRnJhZ21lbnRXaXRoU3RhcnREYXRlKGRldGFpbHMsIHN0YXJ0RGF0ZVRpbWUsIHByb2dyYW1EYXRlVGltZXMsIGosIHBsYXlsaXN0RW5kKTtcbiAgICAgIGlmIChmcmFnSW5kZXggIT09IC0xKSB7XG4gICAgICAgIGRhdGVSYW5nZS50YWdBbmNob3IgPSBkZXRhaWxzLmZyYWdtZW50c1tmcmFnSW5kZXhdLnJlZjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBmaW5kRnJhZ21lbnRXaXRoU3RhcnREYXRlKGRldGFpbHMsIHN0YXJ0RGF0ZVRpbWUsIHByb2dyYW1EYXRlVGltZXMsIGluZGV4LCBlbmRUaW1lKSB7XG4gIGNvbnN0IHBkdEZyYWdtZW50ID0gcHJvZ3JhbURhdGVUaW1lc1tpbmRleF07XG4gIGlmIChwZHRGcmFnbWVudCkge1xuICAgIC8vIGZpbmQgbWF0Y2hpbmcgcmFuZ2UgYmV0d2VlbiBQRFQgdGFnc1xuICAgIGNvbnN0IHBkdFN0YXJ0ID0gcGR0RnJhZ21lbnQucHJvZ3JhbURhdGVUaW1lO1xuICAgIGlmIChzdGFydERhdGVUaW1lID49IHBkdFN0YXJ0IHx8IGluZGV4ID09PSAwKSB7XG4gICAgICB2YXIgX3Byb2dyYW1EYXRlVGltZXM7XG4gICAgICBjb25zdCBkdXJhdGlvbkJldHdlZW5QZHQgPSAoKChfcHJvZ3JhbURhdGVUaW1lcyA9IHByb2dyYW1EYXRlVGltZXNbaW5kZXggKyAxXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wcm9ncmFtRGF0ZVRpbWVzLnN0YXJ0KSB8fCBlbmRUaW1lKSAtIHBkdEZyYWdtZW50LnN0YXJ0O1xuICAgICAgaWYgKHN0YXJ0RGF0ZVRpbWUgPD0gcGR0U3RhcnQgKyBkdXJhdGlvbkJldHdlZW5QZHQgKiAxMDAwKSB7XG4gICAgICAgIC8vIG1hcCB0byBmcmFnbWVudCB3aXRoIGRhdGUtdGltZSByYW5nZVxuICAgICAgICBjb25zdCBzdGFydEluZGV4ID0gcHJvZ3JhbURhdGVUaW1lc1tpbmRleF0uc24gLSBkZXRhaWxzLnN0YXJ0U047XG4gICAgICAgIGNvbnN0IGZyYWdtZW50cyA9IGRldGFpbHMuZnJhZ21lbnRzO1xuICAgICAgICBpZiAoZnJhZ21lbnRzLmxlbmd0aCA+IHByb2dyYW1EYXRlVGltZXMubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgZW5kU2VnbWVudCA9IHByb2dyYW1EYXRlVGltZXNbaW5kZXggKyAxXSB8fCBmcmFnbWVudHNbZnJhZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGNvbnN0IGVuZEluZGV4ID0gZW5kU2VnbWVudC5zbiAtIGRldGFpbHMuc3RhcnRTTjtcbiAgICAgICAgICBmb3IgKGxldCBpID0gZW5kSW5kZXg7IGkgPiBzdGFydEluZGV4OyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGZyYWdTdGFydERhdGVUaW1lID0gZnJhZ21lbnRzW2ldLnByb2dyYW1EYXRlVGltZTtcbiAgICAgICAgICAgIGlmIChzdGFydERhdGVUaW1lID49IGZyYWdTdGFydERhdGVUaW1lICYmIHN0YXJ0RGF0ZVRpbWUgPCBmcmFnU3RhcnREYXRlVGltZSArIGZyYWdtZW50c1tpXS5kdXJhdGlvbiAqIDEwMDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGFydEluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5mdW5jdGlvbiBwYXJzZUtleShrZXlUYWdBdHRyaWJ1dGVzLCBiYXNldXJsLCBwYXJzZWQpIHtcbiAgdmFyIF9rZXlBdHRycyRNRVRIT0QsIF9rZXlBdHRycyRLRVlGT1JNQVQ7XG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM4MjE2I3NlY3Rpb24tNC4zLjIuNFxuICBjb25zdCBrZXlBdHRycyA9IG5ldyBBdHRyTGlzdChrZXlUYWdBdHRyaWJ1dGVzLCBwYXJzZWQpO1xuICBjb25zdCBkZWNyeXB0bWV0aG9kID0gKF9rZXlBdHRycyRNRVRIT0QgPSBrZXlBdHRycy5NRVRIT0QpICE9IG51bGwgPyBfa2V5QXR0cnMkTUVUSE9EIDogJyc7XG4gIGNvbnN0IGRlY3J5cHR1cmkgPSBrZXlBdHRycy5VUkk7XG4gIGNvbnN0IGRlY3J5cHRpdiA9IGtleUF0dHJzLmhleGFkZWNpbWFsSW50ZWdlcignSVYnKTtcbiAgY29uc3QgZGVjcnlwdGtleWZvcm1hdHZlcnNpb25zID0ga2V5QXR0cnMuS0VZRk9STUFUVkVSU0lPTlM7XG4gIC8vIEZyb20gUkZDOiBUaGlzIGF0dHJpYnV0ZSBpcyBPUFRJT05BTDsgaXRzIGFic2VuY2UgaW5kaWNhdGVzIGFuIGltcGxpY2l0IHZhbHVlIG9mIFwiaWRlbnRpdHlcIi5cbiAgY29uc3QgZGVjcnlwdGtleWZvcm1hdCA9IChfa2V5QXR0cnMkS0VZRk9STUFUID0ga2V5QXR0cnMuS0VZRk9STUFUKSAhPSBudWxsID8gX2tleUF0dHJzJEtFWUZPUk1BVCA6ICdpZGVudGl0eSc7XG4gIGlmIChkZWNyeXB0dXJpICYmIGtleUF0dHJzLklWICYmICFkZWNyeXB0aXYpIHtcbiAgICBsb2dnZXIuZXJyb3IoYEludmFsaWQgSVY6ICR7a2V5QXR0cnMuSVZ9YCk7XG4gIH1cbiAgLy8gSWYgZGVjcnlwdHVyaSBpcyBhIFVSSSB3aXRoIGEgc2NoZW1lLCB0aGVuIGJhc2V1cmwgd2lsbCBiZSBpZ25vcmVkXG4gIC8vIE5vIHVyaSBpcyBhbGxvd2VkIHdoZW4gTUVUSE9EIGlzIE5PTkVcbiAgY29uc3QgcmVzb2x2ZWRVcmkgPSBkZWNyeXB0dXJpID8gTTNVOFBhcnNlci5yZXNvbHZlKGRlY3J5cHR1cmksIGJhc2V1cmwpIDogJyc7XG4gIGNvbnN0IGtleUZvcm1hdFZlcnNpb25zID0gKGRlY3J5cHRrZXlmb3JtYXR2ZXJzaW9ucyA/IGRlY3J5cHRrZXlmb3JtYXR2ZXJzaW9ucyA6ICcxJykuc3BsaXQoJy8nKS5tYXAoTnVtYmVyKS5maWx0ZXIoTnVtYmVyLmlzRmluaXRlKTtcbiAgcmV0dXJuIG5ldyBMZXZlbEtleShkZWNyeXB0bWV0aG9kLCByZXNvbHZlZFVyaSwgZGVjcnlwdGtleWZvcm1hdCwga2V5Rm9ybWF0VmVyc2lvbnMsIGRlY3J5cHRpdiwga2V5QXR0cnMuS0VZSUQpO1xufVxuZnVuY3Rpb24gcGFyc2VTdGFydFRpbWVPZmZzZXQoc3RhcnRBdHRyaWJ1dGVzKSB7XG4gIGNvbnN0IHN0YXJ0QXR0cnMgPSBuZXcgQXR0ckxpc3Qoc3RhcnRBdHRyaWJ1dGVzKTtcbiAgY29uc3Qgc3RhcnRUaW1lT2Zmc2V0ID0gc3RhcnRBdHRycy5kZWNpbWFsRmxvYXRpbmdQb2ludCgnVElNRS1PRkZTRVQnKTtcbiAgaWYgKGlzRmluaXRlTnVtYmVyKHN0YXJ0VGltZU9mZnNldCkpIHtcbiAgICByZXR1cm4gc3RhcnRUaW1lT2Zmc2V0O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gc2V0Q29kZWNzKGNvZGVjc0F0dHJpYnV0ZVZhbHVlLCBsZXZlbCkge1xuICBsZXQgY29kZWNzID0gKGNvZGVjc0F0dHJpYnV0ZVZhbHVlIHx8ICcnKS5zcGxpdCgvWyAsXSsvKS5maWx0ZXIoYyA9PiBjKTtcbiAgWyd2aWRlbycsICdhdWRpbycsICd0ZXh0J10uZm9yRWFjaCh0eXBlID0+IHtcbiAgICBjb25zdCBmaWx0ZXJlZCA9IGNvZGVjcy5maWx0ZXIoY29kZWMgPT4gaXNDb2RlY1R5cGUoY29kZWMsIHR5cGUpKTtcbiAgICBpZiAoZmlsdGVyZWQubGVuZ3RoKSB7XG4gICAgICAvLyBDb21tYSBzZXBhcmF0ZWQgbGlzdCBvZiBhbGwgY29kZWNzIGZvciB0eXBlXG4gICAgICBsZXZlbFtgJHt0eXBlfUNvZGVjYF0gPSBmaWx0ZXJlZC5tYXAoYyA9PiBjLnNwbGl0KCcvJylbMF0pLmpvaW4oJywnKTtcbiAgICAgIC8vIFJlbW92ZSBrbm93biBjb2RlY3Mgc28gdGhhdCBvbmx5IHVua25vd25Db2RlY3MgYXJlIGxlZnQgYWZ0ZXIgaXRlcmF0aW5nIHRocm91Z2ggZWFjaCB0eXBlXG4gICAgICBjb2RlY3MgPSBjb2RlY3MuZmlsdGVyKGNvZGVjID0+IGZpbHRlcmVkLmluZGV4T2YoY29kZWMpID09PSAtMSk7XG4gICAgfVxuICB9KTtcbiAgbGV2ZWwudW5rbm93bkNvZGVjcyA9IGNvZGVjcztcbn1cbmZ1bmN0aW9uIGFzc2lnbkNvZGVjKG1lZGlhLCBncm91cEl0ZW0sIGNvZGVjUHJvcGVydHkpIHtcbiAgY29uc3QgY29kZWNWYWx1ZSA9IGdyb3VwSXRlbVtjb2RlY1Byb3BlcnR5XTtcbiAgaWYgKGNvZGVjVmFsdWUpIHtcbiAgICBtZWRpYVtjb2RlY1Byb3BlcnR5XSA9IGNvZGVjVmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGJhY2tmaWxsUHJvZ3JhbURhdGVUaW1lcyhmcmFnbWVudHMsIGZpcnN0UGR0SW5kZXgpIHtcbiAgbGV0IGZyYWdQcmV2ID0gZnJhZ21lbnRzW2ZpcnN0UGR0SW5kZXhdO1xuICBmb3IgKGxldCBpID0gZmlyc3RQZHRJbmRleDsgaS0tOykge1xuICAgIGNvbnN0IGZyYWcgPSBmcmFnbWVudHNbaV07XG4gICAgLy8gRXhpdCBvbiBkZWx0YS1wbGF5bGlzdCBza2lwcGVkIHNlZ21lbnRzXG4gICAgaWYgKCFmcmFnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZyYWcucHJvZ3JhbURhdGVUaW1lID0gZnJhZ1ByZXYucHJvZ3JhbURhdGVUaW1lIC0gZnJhZy5kdXJhdGlvbiAqIDEwMDA7XG4gICAgZnJhZ1ByZXYgPSBmcmFnO1xuICB9XG59XG5mdW5jdGlvbiBhc3NpZ25Qcm9ncmFtRGF0ZVRpbWUoZnJhZywgcHJldkZyYWcsIHByb2dyYW1EYXRlVGltZXMpIHtcbiAgaWYgKGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgcHJvZ3JhbURhdGVUaW1lcy5wdXNoKGZyYWcpO1xuICB9IGVsc2UgaWYgKHByZXZGcmFnICE9IG51bGwgJiYgcHJldkZyYWcucHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgZnJhZy5wcm9ncmFtRGF0ZVRpbWUgPSBwcmV2RnJhZy5lbmRQcm9ncmFtRGF0ZVRpbWU7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldEluaXRTZWdtZW50KGZyYWcsIG1hcEF0dHJzLCBpZCwgbGV2ZWxrZXlzKSB7XG4gIGZyYWcucmVsdXJsID0gbWFwQXR0cnMuVVJJO1xuICBpZiAobWFwQXR0cnMuQllURVJBTkdFKSB7XG4gICAgZnJhZy5zZXRCeXRlUmFuZ2UobWFwQXR0cnMuQllURVJBTkdFKTtcbiAgfVxuICBmcmFnLmxldmVsID0gaWQ7XG4gIGZyYWcuc24gPSAnaW5pdFNlZ21lbnQnO1xuICBpZiAobGV2ZWxrZXlzKSB7XG4gICAgZnJhZy5sZXZlbGtleXMgPSBsZXZlbGtleXM7XG4gIH1cbiAgZnJhZy5pbml0U2VnbWVudCA9IG51bGw7XG59XG5mdW5jdGlvbiBzZXRGcmFnTGV2ZWxLZXlzKGZyYWcsIGxldmVsa2V5cywgbGV2ZWwpIHtcbiAgZnJhZy5sZXZlbGtleXMgPSBsZXZlbGtleXM7XG4gIGNvbnN0IHtcbiAgICBlbmNyeXB0ZWRGcmFnbWVudHNcbiAgfSA9IGxldmVsO1xuICBpZiAoKCFlbmNyeXB0ZWRGcmFnbWVudHMubGVuZ3RoIHx8IGVuY3J5cHRlZEZyYWdtZW50c1tlbmNyeXB0ZWRGcmFnbWVudHMubGVuZ3RoIC0gMV0ubGV2ZWxrZXlzICE9PSBsZXZlbGtleXMpICYmIE9iamVjdC5rZXlzKGxldmVsa2V5cykuc29tZShmb3JtYXQgPT4gbGV2ZWxrZXlzW2Zvcm1hdF0uaXNDb21tb25FbmNyeXB0aW9uKSkge1xuICAgIGVuY3J5cHRlZEZyYWdtZW50cy5wdXNoKGZyYWcpO1xuICB9XG59XG5mdW5jdGlvbiBhc3NpZ25NdWx0aXBsZU1lZGlhUGxheWxpc3RUYWdPY2N1cmFuY2VFcnJvcihsZXZlbCwgdGFnLCByZXN1bHQpIHtcbiAgbGV2ZWwucGxheWxpc3RQYXJzaW5nRXJyb3IgPSBuZXcgRXJyb3IoYCNFWFQtWC0ke3RhZ30gbXVzdCBub3QgYXBwZWFyIG1vcmUgdGhhbiBvbmNlICgke3Jlc3VsdFswXX0pYCk7XG59XG5mdW5jdGlvbiBhc3NpZ25NdXN0QXBwZWFyQmVmb3JlU2VnbWVudHNFcnJvcihsZXZlbCwgdGFnLCByZXN1bHQpIHtcbiAgbGV2ZWwucGxheWxpc3RQYXJzaW5nRXJyb3IgPSBuZXcgRXJyb3IoYCNFWFQtWC0ke3RhZ30gbXVzdCBhcHBlYXIgYmVmb3JlIHRoZSBmaXJzdCBNZWRpYSBTZWdtZW50ICgke3Jlc3VsdFswXX0pYCk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUZyb21Ub1BUUyhmcmFnRnJvbSwgZnJhZ1RvKSB7XG4gIGNvbnN0IGZyYWdUb1BUUyA9IGZyYWdUby5zdGFydFBUUztcbiAgLy8gaWYgd2Uga25vdyBzdGFydFBUU1t0b0lkeF1cbiAgaWYgKGlzRmluaXRlTnVtYmVyKGZyYWdUb1BUUykpIHtcbiAgICAvLyB1cGRhdGUgZnJhZ21lbnQgZHVyYXRpb24uXG4gICAgLy8gaXQgaGVscHMgdG8gZml4IGRyaWZ0cyBiZXR3ZWVuIHBsYXlsaXN0IHJlcG9ydGVkIGR1cmF0aW9uIGFuZCBmcmFnbWVudCByZWFsIGR1cmF0aW9uXG4gICAgbGV0IGR1cmF0aW9uID0gMDtcbiAgICBsZXQgZnJhZztcbiAgICBpZiAoZnJhZ1RvLnNuID4gZnJhZ0Zyb20uc24pIHtcbiAgICAgIGR1cmF0aW9uID0gZnJhZ1RvUFRTIC0gZnJhZ0Zyb20uc3RhcnQ7XG4gICAgICBmcmFnID0gZnJhZ0Zyb207XG4gICAgfSBlbHNlIHtcbiAgICAgIGR1cmF0aW9uID0gZnJhZ0Zyb20uc3RhcnQgLSBmcmFnVG9QVFM7XG4gICAgICBmcmFnID0gZnJhZ1RvO1xuICAgIH1cbiAgICBpZiAoZnJhZy5kdXJhdGlvbiAhPT0gZHVyYXRpb24pIHtcbiAgICAgIGZyYWcuc2V0RHVyYXRpb24oZHVyYXRpb24pO1xuICAgIH1cbiAgICAvLyB3ZSBkb250IGtub3cgc3RhcnRQVFNbdG9JZHhdXG4gIH0gZWxzZSBpZiAoZnJhZ1RvLnNuID4gZnJhZ0Zyb20uc24pIHtcbiAgICBjb25zdCBjb250aWd1b3VzID0gZnJhZ0Zyb20uY2MgPT09IGZyYWdUby5jYztcbiAgICAvLyBUT0RPOiBXaXRoIHBhcnQtbG9hZGluZyBlbmQvZHVyYXRpb25zIHdlIG5lZWQgdG8gY29uZmlybSB0aGUgd2hvbGUgZnJhZ21lbnQgaXMgbG9hZGVkIGJlZm9yZSB1c2luZyAob3Igc2V0dGluZykgbWluRW5kUFRTXG4gICAgaWYgKGNvbnRpZ3VvdXMgJiYgZnJhZ0Zyb20ubWluRW5kUFRTKSB7XG4gICAgICBmcmFnVG8uc2V0U3RhcnQoZnJhZ0Zyb20uc3RhcnQgKyAoZnJhZ0Zyb20ubWluRW5kUFRTIC0gZnJhZ0Zyb20uc3RhcnQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhZ1RvLnNldFN0YXJ0KGZyYWdGcm9tLnN0YXJ0ICsgZnJhZ0Zyb20uZHVyYXRpb24pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmcmFnVG8uc2V0U3RhcnQoTWF0aC5tYXgoZnJhZ0Zyb20uc3RhcnQgLSBmcmFnVG8uZHVyYXRpb24sIDApKTtcbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlRnJhZ1BUU0RUUyhkZXRhaWxzLCBmcmFnLCBzdGFydFBUUywgZW5kUFRTLCBzdGFydERUUywgZW5kRFRTKSB7XG4gIGNvbnN0IHBhcnNlZE1lZGlhRHVyYXRpb24gPSBlbmRQVFMgLSBzdGFydFBUUztcbiAgaWYgKHBhcnNlZE1lZGlhRHVyYXRpb24gPD0gMCkge1xuICAgIGxvZ2dlci53YXJuKCdGcmFnbWVudCBzaG91bGQgaGF2ZSBhIHBvc2l0aXZlIGR1cmF0aW9uJywgZnJhZyk7XG4gICAgZW5kUFRTID0gc3RhcnRQVFMgKyBmcmFnLmR1cmF0aW9uO1xuICAgIGVuZERUUyA9IHN0YXJ0RFRTICsgZnJhZy5kdXJhdGlvbjtcbiAgfVxuICBsZXQgbWF4U3RhcnRQVFMgPSBzdGFydFBUUztcbiAgbGV0IG1pbkVuZFBUUyA9IGVuZFBUUztcbiAgY29uc3QgZnJhZ1N0YXJ0UHRzID0gZnJhZy5zdGFydFBUUztcbiAgY29uc3QgZnJhZ0VuZFB0cyA9IGZyYWcuZW5kUFRTO1xuICBpZiAoaXNGaW5pdGVOdW1iZXIoZnJhZ1N0YXJ0UHRzKSkge1xuICAgIC8vIGRlbHRhIFBUUyBiZXR3ZWVuIGF1ZGlvIGFuZCB2aWRlb1xuICAgIGNvbnN0IGRlbHRhUFRTID0gTWF0aC5hYnMoZnJhZ1N0YXJ0UHRzIC0gc3RhcnRQVFMpO1xuICAgIGlmICghaXNGaW5pdGVOdW1iZXIoZnJhZy5kZWx0YVBUUykpIHtcbiAgICAgIGZyYWcuZGVsdGFQVFMgPSBkZWx0YVBUUztcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhZy5kZWx0YVBUUyA9IE1hdGgubWF4KGRlbHRhUFRTLCBmcmFnLmRlbHRhUFRTKTtcbiAgICB9XG4gICAgbWF4U3RhcnRQVFMgPSBNYXRoLm1heChzdGFydFBUUywgZnJhZ1N0YXJ0UHRzKTtcbiAgICBzdGFydFBUUyA9IE1hdGgubWluKHN0YXJ0UFRTLCBmcmFnU3RhcnRQdHMpO1xuICAgIHN0YXJ0RFRTID0gTWF0aC5taW4oc3RhcnREVFMsIGZyYWcuc3RhcnREVFMpO1xuICAgIG1pbkVuZFBUUyA9IE1hdGgubWluKGVuZFBUUywgZnJhZ0VuZFB0cyk7XG4gICAgZW5kUFRTID0gTWF0aC5tYXgoZW5kUFRTLCBmcmFnRW5kUHRzKTtcbiAgICBlbmREVFMgPSBNYXRoLm1heChlbmREVFMsIGZyYWcuZW5kRFRTKTtcbiAgfVxuICBjb25zdCBkcmlmdCA9IHN0YXJ0UFRTIC0gZnJhZy5zdGFydDtcbiAgaWYgKGZyYWcuc3RhcnQgIT09IDApIHtcbiAgICBmcmFnLnNldFN0YXJ0KHN0YXJ0UFRTKTtcbiAgfVxuICBmcmFnLnNldER1cmF0aW9uKGVuZFBUUyAtIGZyYWcuc3RhcnQpO1xuICBmcmFnLnN0YXJ0UFRTID0gc3RhcnRQVFM7XG4gIGZyYWcubWF4U3RhcnRQVFMgPSBtYXhTdGFydFBUUztcbiAgZnJhZy5zdGFydERUUyA9IHN0YXJ0RFRTO1xuICBmcmFnLmVuZFBUUyA9IGVuZFBUUztcbiAgZnJhZy5taW5FbmRQVFMgPSBtaW5FbmRQVFM7XG4gIGZyYWcuZW5kRFRTID0gZW5kRFRTO1xuICBjb25zdCBzbiA9IGZyYWcuc247XG4gIC8vIGV4aXQgaWYgc24gb3V0IG9mIHJhbmdlXG4gIGlmICghZGV0YWlscyB8fCBzbiA8IGRldGFpbHMuc3RhcnRTTiB8fCBzbiA+IGRldGFpbHMuZW5kU04pIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBsZXQgaTtcbiAgY29uc3QgZnJhZ0lkeCA9IHNuIC0gZGV0YWlscy5zdGFydFNOO1xuICBjb25zdCBmcmFnbWVudHMgPSBkZXRhaWxzLmZyYWdtZW50cztcbiAgLy8gdXBkYXRlIGZyYWcgcmVmZXJlbmNlIGluIGZyYWdtZW50cyBhcnJheVxuICAvLyByYXRpb25hbGUgaXMgdGhhdCBmcmFnbWVudHMgYXJyYXkgbWlnaHQgbm90IGNvbnRhaW4gdGhpcyBmcmFnIG9iamVjdC5cbiAgLy8gdGhpcyB3aWxsIGhhcHBlbiBpZiBwbGF5bGlzdCBoYXMgYmVlbiByZWZyZXNoZWQgYmV0d2VlbiBmcmFnIGxvYWRpbmcgYW5kIGNhbGwgdG8gdXBkYXRlRnJhZ1BUU0RUUygpXG4gIC8vIGlmIHdlIGRvbid0IHVwZGF0ZSBmcmFnLCB3ZSB3b24ndCBiZSBhYmxlIHRvIHByb3BhZ2F0ZSBQVFMgaW5mbyBvbiB0aGUgcGxheWxpc3RcbiAgLy8gcmVzdWx0aW5nIGluIGludmFsaWQgc2xpZGluZyBjb21wdXRhdGlvblxuICBmcmFnbWVudHNbZnJhZ0lkeF0gPSBmcmFnO1xuICAvLyBhZGp1c3QgZnJhZ21lbnQgUFRTL2R1cmF0aW9uIGZyb20gc2VxbnVtLTEgdG8gZnJhZyAwXG4gIGZvciAoaSA9IGZyYWdJZHg7IGkgPiAwOyBpLS0pIHtcbiAgICB1cGRhdGVGcm9tVG9QVFMoZnJhZ21lbnRzW2ldLCBmcmFnbWVudHNbaSAtIDFdKTtcbiAgfVxuXG4gIC8vIGFkanVzdCBmcmFnbWVudCBQVFMvZHVyYXRpb24gZnJvbSBzZXFudW0gdG8gbGFzdCBmcmFnXG4gIGZvciAoaSA9IGZyYWdJZHg7IGkgPCBmcmFnbWVudHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgdXBkYXRlRnJvbVRvUFRTKGZyYWdtZW50c1tpXSwgZnJhZ21lbnRzW2kgKyAxXSk7XG4gIH1cbiAgaWYgKGRldGFpbHMuZnJhZ21lbnRIaW50KSB7XG4gICAgdXBkYXRlRnJvbVRvUFRTKGZyYWdtZW50c1tmcmFnbWVudHMubGVuZ3RoIC0gMV0sIGRldGFpbHMuZnJhZ21lbnRIaW50KTtcbiAgfVxuICBkZXRhaWxzLlBUU0tub3duID0gZGV0YWlscy5hbGlnbmVkU2xpZGluZyA9IHRydWU7XG4gIHJldHVybiBkcmlmdDtcbn1cbmZ1bmN0aW9uIG1lcmdlRGV0YWlscyhvbGREZXRhaWxzLCBuZXdEZXRhaWxzKSB7XG4gIGlmIChvbGREZXRhaWxzID09PSBuZXdEZXRhaWxzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIFRyYWNrIHRoZSBsYXN0IGluaXRTZWdtZW50IHByb2Nlc3NlZC4gSW5pdGlhbGl6ZSBpdCB0byB0aGUgbGFzdCBvbmUgb24gdGhlIHRpbWVsaW5lLlxuICBsZXQgY3VycmVudEluaXRTZWdtZW50ID0gbnVsbDtcbiAgY29uc3Qgb2xkRnJhZ21lbnRzID0gb2xkRGV0YWlscy5mcmFnbWVudHM7XG4gIGZvciAobGV0IGkgPSBvbGRGcmFnbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBvbGRJbml0ID0gb2xkRnJhZ21lbnRzW2ldLmluaXRTZWdtZW50O1xuICAgIGlmIChvbGRJbml0KSB7XG4gICAgICBjdXJyZW50SW5pdFNlZ21lbnQgPSBvbGRJbml0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChvbGREZXRhaWxzLmZyYWdtZW50SGludCkge1xuICAgIC8vIHByZXZlbnQgUFRTIGFuZCBkdXJhdGlvbiBmcm9tIGJlaW5nIGFkanVzdGVkIG9uIHRoZSBuZXh0IGhpbnRcbiAgICBkZWxldGUgb2xkRGV0YWlscy5mcmFnbWVudEhpbnQuZW5kUFRTO1xuICB9XG4gIC8vIGNoZWNrIGlmIG9sZC9uZXcgcGxheWxpc3RzIGhhdmUgZnJhZ21lbnRzIGluIGNvbW1vblxuICAvLyBsb29wIHRocm91Z2ggb3ZlcmxhcHBpbmcgU04gYW5kIHVwZGF0ZSBzdGFydFBUUywgY2MsIGFuZCBkdXJhdGlvbiBpZiBhbnkgZm91bmRcbiAgbGV0IFBUU0ZyYWc7XG4gIG1hcEZyYWdtZW50SW50ZXJzZWN0aW9uKG9sZERldGFpbHMsIG5ld0RldGFpbHMsIChvbGRGcmFnLCBuZXdGcmFnLCBuZXdGcmFnSW5kZXgsIG5ld0ZyYWdtZW50cykgPT4ge1xuICAgIGlmICgoIW5ld0RldGFpbHMuc3RhcnRDQyB8fCBuZXdEZXRhaWxzLnNraXBwZWRTZWdtZW50cykgJiYgbmV3RnJhZy5jYyAhPT0gb2xkRnJhZy5jYykge1xuICAgICAgY29uc3QgY2NPZmZzZXQgPSBvbGRGcmFnLmNjIC0gbmV3RnJhZy5jYztcbiAgICAgIGZvciAobGV0IGkgPSBuZXdGcmFnSW5kZXg7IGkgPCBuZXdGcmFnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmV3RnJhZ21lbnRzW2ldLmNjICs9IGNjT2Zmc2V0O1xuICAgICAgfVxuICAgICAgbmV3RGV0YWlscy5lbmRDQyA9IG5ld0ZyYWdtZW50c1tuZXdGcmFnbWVudHMubGVuZ3RoIC0gMV0uY2M7XG4gICAgfVxuICAgIGlmIChpc0Zpbml0ZU51bWJlcihvbGRGcmFnLnN0YXJ0UFRTKSAmJiBpc0Zpbml0ZU51bWJlcihvbGRGcmFnLmVuZFBUUykpIHtcbiAgICAgIG5ld0ZyYWcuc2V0U3RhcnQobmV3RnJhZy5zdGFydFBUUyA9IG9sZEZyYWcuc3RhcnRQVFMpO1xuICAgICAgbmV3RnJhZy5zdGFydERUUyA9IG9sZEZyYWcuc3RhcnREVFM7XG4gICAgICBuZXdGcmFnLm1heFN0YXJ0UFRTID0gb2xkRnJhZy5tYXhTdGFydFBUUztcbiAgICAgIG5ld0ZyYWcuZW5kUFRTID0gb2xkRnJhZy5lbmRQVFM7XG4gICAgICBuZXdGcmFnLmVuZERUUyA9IG9sZEZyYWcuZW5kRFRTO1xuICAgICAgbmV3RnJhZy5taW5FbmRQVFMgPSBvbGRGcmFnLm1pbkVuZFBUUztcbiAgICAgIG5ld0ZyYWcuc2V0RHVyYXRpb24ob2xkRnJhZy5lbmRQVFMgLSBvbGRGcmFnLnN0YXJ0UFRTKTtcbiAgICAgIGlmIChuZXdGcmFnLmR1cmF0aW9uKSB7XG4gICAgICAgIFBUU0ZyYWcgPSBuZXdGcmFnO1xuICAgICAgfVxuXG4gICAgICAvLyBQVFMgaXMga25vd24gd2hlbiBhbnkgc2VnbWVudCBoYXMgc3RhcnRQVFMgYW5kIGVuZFBUU1xuICAgICAgbmV3RGV0YWlscy5QVFNLbm93biA9IG5ld0RldGFpbHMuYWxpZ25lZFNsaWRpbmcgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAob2xkRnJhZy5oYXNTdHJlYW1zKSB7XG4gICAgICBuZXdGcmFnLmVsZW1lbnRhcnlTdHJlYW1zID0gb2xkRnJhZy5lbGVtZW50YXJ5U3RyZWFtcztcbiAgICB9XG4gICAgbmV3RnJhZy5sb2FkZXIgPSBvbGRGcmFnLmxvYWRlcjtcbiAgICBpZiAob2xkRnJhZy5oYXNTdGF0cykge1xuICAgICAgbmV3RnJhZy5zdGF0cyA9IG9sZEZyYWcuc3RhdHM7XG4gICAgfVxuICAgIGlmIChvbGRGcmFnLmluaXRTZWdtZW50KSB7XG4gICAgICBuZXdGcmFnLmluaXRTZWdtZW50ID0gb2xkRnJhZy5pbml0U2VnbWVudDtcbiAgICAgIGN1cnJlbnRJbml0U2VnbWVudCA9IG9sZEZyYWcuaW5pdFNlZ21lbnQ7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgbmV3RnJhZ21lbnRzID0gbmV3RGV0YWlscy5mcmFnbWVudHM7XG4gIGNvbnN0IGZyYWdtZW50c1RvQ2hlY2sgPSBuZXdEZXRhaWxzLmZyYWdtZW50SGludCA/IG5ld0ZyYWdtZW50cy5jb25jYXQobmV3RGV0YWlscy5mcmFnbWVudEhpbnQpIDogbmV3RnJhZ21lbnRzO1xuICBpZiAoY3VycmVudEluaXRTZWdtZW50KSB7XG4gICAgZnJhZ21lbnRzVG9DaGVjay5mb3JFYWNoKGZyYWcgPT4ge1xuICAgICAgdmFyIF9jdXJyZW50SW5pdFNlZ21lbnQ7XG4gICAgICBpZiAoZnJhZyAmJiAoIWZyYWcuaW5pdFNlZ21lbnQgfHwgZnJhZy5pbml0U2VnbWVudC5yZWx1cmwgPT09ICgoX2N1cnJlbnRJbml0U2VnbWVudCA9IGN1cnJlbnRJbml0U2VnbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jdXJyZW50SW5pdFNlZ21lbnQucmVsdXJsKSkpIHtcbiAgICAgICAgZnJhZy5pbml0U2VnbWVudCA9IGN1cnJlbnRJbml0U2VnbWVudDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBpZiAobmV3RGV0YWlscy5za2lwcGVkU2VnbWVudHMpIHtcbiAgICBuZXdEZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkID0gbmV3RnJhZ21lbnRzLnNvbWUoZnJhZyA9PiAhZnJhZyk7XG4gICAgaWYgKG5ld0RldGFpbHMuZGVsdGFVcGRhdGVGYWlsZWQpIHtcbiAgICAgIGxvZ2dlci53YXJuKCdbbGV2ZWwtaGVscGVyXSBQcmV2aW91cyBwbGF5bGlzdCBtaXNzaW5nIHNlZ21lbnRzIHNraXBwZWQgaW4gZGVsdGEgcGxheWxpc3QnKTtcbiAgICAgIGZvciAobGV0IGkgPSBuZXdEZXRhaWxzLnNraXBwZWRTZWdtZW50czsgaS0tOykge1xuICAgICAgICBuZXdGcmFnbWVudHMuc2hpZnQoKTtcbiAgICAgIH1cbiAgICAgIG5ld0RldGFpbHMuc3RhcnRTTiA9IG5ld0ZyYWdtZW50c1swXS5zbjtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5ld0RldGFpbHMuY2FuU2tpcERhdGVSYW5nZXMpIHtcbiAgICAgICAgbmV3RGV0YWlscy5kYXRlUmFuZ2VzID0gbWVyZ2VEYXRlUmFuZ2VzKG9sZERldGFpbHMuZGF0ZVJhbmdlcywgbmV3RGV0YWlscyk7XG4gICAgICB9XG4gICAgICBjb25zdCBwcm9ncmFtRGF0ZVRpbWVzID0gb2xkRGV0YWlscy5mcmFnbWVudHMuZmlsdGVyKGZyYWcgPT4gZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUpO1xuICAgICAgaWYgKG9sZERldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lICYmICFuZXdEZXRhaWxzLmhhc1Byb2dyYW1EYXRlVGltZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGZyYWdtZW50c1RvQ2hlY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoZnJhZ21lbnRzVG9DaGVja1tpXS5wcm9ncmFtRGF0ZVRpbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGFzc2lnblByb2dyYW1EYXRlVGltZShmcmFnbWVudHNUb0NoZWNrW2ldLCBmcmFnbWVudHNUb0NoZWNrW2kgLSAxXSwgcHJvZ3JhbURhdGVUaW1lcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtYXBEYXRlUmFuZ2VzKHByb2dyYW1EYXRlVGltZXMsIG5ld0RldGFpbHMpO1xuICAgIH1cbiAgICBuZXdEZXRhaWxzLmVuZENDID0gbmV3RnJhZ21lbnRzW25ld0ZyYWdtZW50cy5sZW5ndGggLSAxXS5jYztcbiAgfVxuICBpZiAoIW5ld0RldGFpbHMuc3RhcnRDQykge1xuICAgIHZhciBfZnJhZ1ByaW9yVG9OZXdTdGFydCQ7XG4gICAgY29uc3QgZnJhZ1ByaW9yVG9OZXdTdGFydCA9IGdldEZyYWdtZW50V2l0aFNOKG9sZERldGFpbHMsIG5ld0RldGFpbHMuc3RhcnRTTiAtIDEpO1xuICAgIG5ld0RldGFpbHMuc3RhcnRDQyA9IChfZnJhZ1ByaW9yVG9OZXdTdGFydCQgPSBmcmFnUHJpb3JUb05ld1N0YXJ0ID09IG51bGwgPyB2b2lkIDAgOiBmcmFnUHJpb3JUb05ld1N0YXJ0LmNjKSAhPSBudWxsID8gX2ZyYWdQcmlvclRvTmV3U3RhcnQkIDogbmV3RnJhZ21lbnRzWzBdLmNjO1xuICB9XG5cbiAgLy8gTWVyZ2UgcGFydHNcbiAgbWFwUGFydEludGVyc2VjdGlvbihvbGREZXRhaWxzLnBhcnRMaXN0LCBuZXdEZXRhaWxzLnBhcnRMaXN0LCAob2xkUGFydCwgbmV3UGFydCkgPT4ge1xuICAgIG5ld1BhcnQuZWxlbWVudGFyeVN0cmVhbXMgPSBvbGRQYXJ0LmVsZW1lbnRhcnlTdHJlYW1zO1xuICAgIG5ld1BhcnQuc3RhdHMgPSBvbGRQYXJ0LnN0YXRzO1xuICB9KTtcblxuICAvLyBpZiBhdCBsZWFzdCBvbmUgZnJhZ21lbnQgY29udGFpbnMgUFRTIGluZm8sIHJlY29tcHV0ZSBQVFMgaW5mb3JtYXRpb24gZm9yIGFsbCBmcmFnbWVudHNcbiAgaWYgKFBUU0ZyYWcpIHtcbiAgICB1cGRhdGVGcmFnUFRTRFRTKG5ld0RldGFpbHMsIFBUU0ZyYWcsIFBUU0ZyYWcuc3RhcnRQVFMsIFBUU0ZyYWcuZW5kUFRTLCBQVFNGcmFnLnN0YXJ0RFRTLCBQVFNGcmFnLmVuZERUUyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZW5zdXJlIHRoYXQgZGVsdGEgaXMgd2l0aGluIG9sZEZyYWdtZW50cyByYW5nZVxuICAgIC8vIGFsc28gYWRqdXN0IHNsaWRpbmcgaW4gY2FzZSBkZWx0YSBpcyAwICh3ZSBjb3VsZCBoYXZlIG9sZD1bNTAtNjBdIGFuZCBuZXc9b2xkPVs1MC02MV0pXG4gICAgLy8gaW4gdGhhdCBjYXNlIHdlIGFsc28gbmVlZCB0byBhZGp1c3Qgc3RhcnQgb2Zmc2V0IG9mIGFsbCBmcmFnbWVudHNcbiAgICBhZGp1c3RTbGlkaW5nKG9sZERldGFpbHMsIG5ld0RldGFpbHMpO1xuICB9XG4gIGlmIChuZXdGcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgbmV3RGV0YWlscy50b3RhbGR1cmF0aW9uID0gbmV3RGV0YWlscy5lZGdlIC0gbmV3RnJhZ21lbnRzWzBdLnN0YXJ0O1xuICB9XG4gIG5ld0RldGFpbHMuZHJpZnRTdGFydFRpbWUgPSBvbGREZXRhaWxzLmRyaWZ0U3RhcnRUaW1lO1xuICBuZXdEZXRhaWxzLmRyaWZ0U3RhcnQgPSBvbGREZXRhaWxzLmRyaWZ0U3RhcnQ7XG4gIGNvbnN0IGFkdmFuY2VkRGF0ZVRpbWUgPSBuZXdEZXRhaWxzLmFkdmFuY2VkRGF0ZVRpbWU7XG4gIGlmIChuZXdEZXRhaWxzLmFkdmFuY2VkICYmIGFkdmFuY2VkRGF0ZVRpbWUpIHtcbiAgICBjb25zdCBlZGdlID0gbmV3RGV0YWlscy5lZGdlO1xuICAgIGlmICghbmV3RGV0YWlscy5kcmlmdFN0YXJ0KSB7XG4gICAgICBuZXdEZXRhaWxzLmRyaWZ0U3RhcnRUaW1lID0gYWR2YW5jZWREYXRlVGltZTtcbiAgICAgIG5ld0RldGFpbHMuZHJpZnRTdGFydCA9IGVkZ2U7XG4gICAgfVxuICAgIG5ld0RldGFpbHMuZHJpZnRFbmRUaW1lID0gYWR2YW5jZWREYXRlVGltZTtcbiAgICBuZXdEZXRhaWxzLmRyaWZ0RW5kID0gZWRnZTtcbiAgfSBlbHNlIHtcbiAgICBuZXdEZXRhaWxzLmRyaWZ0RW5kVGltZSA9IG9sZERldGFpbHMuZHJpZnRFbmRUaW1lO1xuICAgIG5ld0RldGFpbHMuZHJpZnRFbmQgPSBvbGREZXRhaWxzLmRyaWZ0RW5kO1xuICAgIG5ld0RldGFpbHMuYWR2YW5jZWREYXRlVGltZSA9IG9sZERldGFpbHMuYWR2YW5jZWREYXRlVGltZTtcbiAgfVxuICBpZiAobmV3RGV0YWlscy5yZXF1ZXN0U2NoZWR1bGVkID09PSAtMSkge1xuICAgIG5ld0RldGFpbHMucmVxdWVzdFNjaGVkdWxlZCA9IG9sZERldGFpbHMucmVxdWVzdFNjaGVkdWxlZDtcbiAgfVxufVxuZnVuY3Rpb24gbWVyZ2VEYXRlUmFuZ2VzKG9sZERhdGVSYW5nZXMsIG5ld0RldGFpbHMpIHtcbiAgY29uc3Qge1xuICAgIGRhdGVSYW5nZXM6IGRlbHRhRGF0ZVJhbmdlcyxcbiAgICByZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzXG4gIH0gPSBuZXdEZXRhaWxzO1xuICBjb25zdCBkYXRlUmFuZ2VzID0gX2V4dGVuZHMoe30sIG9sZERhdGVSYW5nZXMpO1xuICBpZiAocmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcykge1xuICAgIHJlY2VudGx5UmVtb3ZlZERhdGVyYW5nZXMuZm9yRWFjaChpZCA9PiB7XG4gICAgICBkZWxldGUgZGF0ZVJhbmdlc1tpZF07XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgbWVyZ2VJZHMgPSBPYmplY3Qua2V5cyhkYXRlUmFuZ2VzKTtcbiAgY29uc3QgbWVyZ2VDb3VudCA9IG1lcmdlSWRzLmxlbmd0aDtcbiAgaWYgKG1lcmdlQ291bnQpIHtcbiAgICBPYmplY3Qua2V5cyhkZWx0YURhdGVSYW5nZXMpLmZvckVhY2goaWQgPT4ge1xuICAgICAgY29uc3QgbWVyZ2VkRGF0ZVJhbmdlID0gZGF0ZVJhbmdlc1tpZF07XG4gICAgICBjb25zdCBkYXRlUmFuZ2UgPSBuZXcgRGF0ZVJhbmdlKGRlbHRhRGF0ZVJhbmdlc1tpZF0uYXR0ciwgbWVyZ2VkRGF0ZVJhbmdlKTtcbiAgICAgIGlmIChkYXRlUmFuZ2UuaXNWYWxpZCkge1xuICAgICAgICBkYXRlUmFuZ2VzW2lkXSA9IGRhdGVSYW5nZTtcbiAgICAgICAgaWYgKCFtZXJnZWREYXRlUmFuZ2UpIHtcbiAgICAgICAgICBkYXRlUmFuZ2UudGFnT3JkZXIgKz0gbWVyZ2VDb3VudDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oYElnbm9yaW5nIGludmFsaWQgUGxheWxpc3QgRGVsdGEgVXBkYXRlIERBVEVSQU5HRSB0YWc6IFwiJHtzdHJpbmdpZnkoZGVsdGFEYXRlUmFuZ2VzW2lkXS5hdHRyKX1cImApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBkYXRlUmFuZ2VzO1xufVxuZnVuY3Rpb24gbWFwUGFydEludGVyc2VjdGlvbihvbGRQYXJ0cywgbmV3UGFydHMsIGludGVyc2VjdGlvbkZuKSB7XG4gIGlmIChvbGRQYXJ0cyAmJiBuZXdQYXJ0cykge1xuICAgIGxldCBkZWx0YSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG9sZFBhcnRzLmxlbmd0aDsgaSA8PSBsZW47IGkrKykge1xuICAgICAgY29uc3Qgb2xkUGFydCA9IG9sZFBhcnRzW2ldO1xuICAgICAgY29uc3QgbmV3UGFydCA9IG5ld1BhcnRzW2kgKyBkZWx0YV07XG4gICAgICBpZiAob2xkUGFydCAmJiBuZXdQYXJ0ICYmIG9sZFBhcnQuaW5kZXggPT09IG5ld1BhcnQuaW5kZXggJiYgb2xkUGFydC5mcmFnbWVudC5zbiA9PT0gbmV3UGFydC5mcmFnbWVudC5zbikge1xuICAgICAgICBpbnRlcnNlY3Rpb25GbihvbGRQYXJ0LCBuZXdQYXJ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbHRhLS07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXBGcmFnbWVudEludGVyc2VjdGlvbihvbGREZXRhaWxzLCBuZXdEZXRhaWxzLCBpbnRlcnNlY3Rpb25Gbikge1xuICBjb25zdCBza2lwcGVkU2VnbWVudHMgPSBuZXdEZXRhaWxzLnNraXBwZWRTZWdtZW50cztcbiAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heChvbGREZXRhaWxzLnN0YXJ0U04sIG5ld0RldGFpbHMuc3RhcnRTTikgLSBuZXdEZXRhaWxzLnN0YXJ0U047XG4gIGNvbnN0IGVuZCA9IChvbGREZXRhaWxzLmZyYWdtZW50SGludCA/IDEgOiAwKSArIChza2lwcGVkU2VnbWVudHMgPyBuZXdEZXRhaWxzLmVuZFNOIDogTWF0aC5taW4ob2xkRGV0YWlscy5lbmRTTiwgbmV3RGV0YWlscy5lbmRTTikpIC0gbmV3RGV0YWlscy5zdGFydFNOO1xuICBjb25zdCBkZWx0YSA9IG5ld0RldGFpbHMuc3RhcnRTTiAtIG9sZERldGFpbHMuc3RhcnRTTjtcbiAgY29uc3QgbmV3RnJhZ3MgPSBuZXdEZXRhaWxzLmZyYWdtZW50SGludCA/IG5ld0RldGFpbHMuZnJhZ21lbnRzLmNvbmNhdChuZXdEZXRhaWxzLmZyYWdtZW50SGludCkgOiBuZXdEZXRhaWxzLmZyYWdtZW50cztcbiAgY29uc3Qgb2xkRnJhZ3MgPSBvbGREZXRhaWxzLmZyYWdtZW50SGludCA/IG9sZERldGFpbHMuZnJhZ21lbnRzLmNvbmNhdChvbGREZXRhaWxzLmZyYWdtZW50SGludCkgOiBvbGREZXRhaWxzLmZyYWdtZW50cztcbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgY29uc3Qgb2xkRnJhZyA9IG9sZEZyYWdzW2RlbHRhICsgaV07XG4gICAgbGV0IG5ld0ZyYWcgPSBuZXdGcmFnc1tpXTtcbiAgICBpZiAoc2tpcHBlZFNlZ21lbnRzICYmICFuZXdGcmFnICYmIG9sZEZyYWcpIHtcbiAgICAgIC8vIEZpbGwgaW4gc2tpcHBlZCBzZWdtZW50cyBpbiBkZWx0YSBwbGF5bGlzdFxuICAgICAgbmV3RnJhZyA9IG5ld0RldGFpbHMuZnJhZ21lbnRzW2ldID0gb2xkRnJhZztcbiAgICB9XG4gICAgaWYgKG9sZEZyYWcgJiYgbmV3RnJhZykge1xuICAgICAgaW50ZXJzZWN0aW9uRm4ob2xkRnJhZywgbmV3RnJhZywgaSwgbmV3RnJhZ3MpO1xuICAgICAgaWYgKG9sZEZyYWcudXJsICYmIG9sZEZyYWcudXJsICE9PSBuZXdGcmFnLnVybCkge1xuICAgICAgICBuZXdEZXRhaWxzLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gZ2V0U2VxdWVuY2VFcnJvcihgbWVkaWEgc2VxdWVuY2UgbWlzbWF0Y2ggJHtuZXdGcmFnLnNufTpgLCBvbGREZXRhaWxzLCBuZXdEZXRhaWxzLCBvbGRGcmFnLCBuZXdGcmFnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChvbGRGcmFnLmNjICE9PSBuZXdGcmFnLmNjKSB7XG4gICAgICAgIG5ld0RldGFpbHMucGxheWxpc3RQYXJzaW5nRXJyb3IgPSBnZXRTZXF1ZW5jZUVycm9yKGBkaXNjb250aW51aXR5IHNlcXVlbmNlIG1pc21hdGNoICgke29sZEZyYWcuY2N9IT0ke25ld0ZyYWcuY2N9KWAsIG9sZERldGFpbHMsIG5ld0RldGFpbHMsIG9sZEZyYWcsIG5ld0ZyYWcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRTZXF1ZW5jZUVycm9yKG1lc3NhZ2UsIG9sZERldGFpbHMsIG5ld0RldGFpbHMsIG9sZEZyYWcsIG5ld0ZyYWcpIHtcbiAgcmV0dXJuIG5ldyBFcnJvcihgJHttZXNzYWdlfSAke25ld0ZyYWcudXJsfVxuUGxheWxpc3Qgc3RhcnRpbmcgQCR7b2xkRGV0YWlscy5zdGFydFNOfVxuJHtvbGREZXRhaWxzLm0zdTh9XG5cblBsYXlsaXN0IHN0YXJ0aW5nIEAke25ld0RldGFpbHMuc3RhcnRTTn1cbiR7bmV3RGV0YWlscy5tM3U4fWApO1xufVxuZnVuY3Rpb24gYWRqdXN0U2xpZGluZyhvbGREZXRhaWxzLCBuZXdEZXRhaWxzLCBtYXRjaGluZ1N0YWJsZVZhcmlhbnRPclJlbmRpdGlvbiA9IHRydWUpIHtcbiAgY29uc3QgZGVsdGEgPSBuZXdEZXRhaWxzLnN0YXJ0U04gKyBuZXdEZXRhaWxzLnNraXBwZWRTZWdtZW50cyAtIG9sZERldGFpbHMuc3RhcnRTTjtcbiAgY29uc3Qgb2xkRnJhZ21lbnRzID0gb2xkRGV0YWlscy5mcmFnbWVudHM7XG4gIGNvbnN0IGFkdmFuY2VkT3JTdGFibGUgPSBkZWx0YSA+PSAwO1xuICBsZXQgc2xpZGluZyA9IDA7XG4gIGlmIChhZHZhbmNlZE9yU3RhYmxlICYmIGRlbHRhIDwgb2xkRnJhZ21lbnRzLmxlbmd0aCkge1xuICAgIHNsaWRpbmcgPSBvbGRGcmFnbWVudHNbZGVsdGFdLnN0YXJ0O1xuICB9IGVsc2UgaWYgKGFkdmFuY2VkT3JTdGFibGUgJiYgbmV3RGV0YWlscy5zdGFydFNOID09PSBvbGREZXRhaWxzLmVuZFNOICsgMSkge1xuICAgIHNsaWRpbmcgPSBvbGREZXRhaWxzLmZyYWdtZW50RW5kO1xuICB9IGVsc2UgaWYgKGFkdmFuY2VkT3JTdGFibGUgJiYgbWF0Y2hpbmdTdGFibGVWYXJpYW50T3JSZW5kaXRpb24pIHtcbiAgICAvLyBhbGlnbiB3aXRoIGV4cGVjdGVkIHBvc2l0aW9uICh1cGRhdGVkIHBsYXlsaXN0IHN0YXJ0IHNlcXVlbmNlIGlzIHBhc3QgZW5kIHNlcXVlbmNlIG9mIGxhc3QgdXBkYXRlKVxuICAgIHNsaWRpbmcgPSBvbGREZXRhaWxzLmZyYWdtZW50U3RhcnQgKyBkZWx0YSAqIG5ld0RldGFpbHMubGV2ZWxUYXJnZXREdXJhdGlvbjtcbiAgfSBlbHNlIGlmICghbmV3RGV0YWlscy5za2lwcGVkU2VnbWVudHMgJiYgbmV3RGV0YWlscy5mcmFnbWVudFN0YXJ0ID09PSAwKSB7XG4gICAgLy8gYWxpZ24gbmV3IHN0YXJ0IHdpdGggb2xkIChwbGF5bGlzdCBzd2l0Y2ggaGFzIGEgc2VxdWVuY2Ugd2l0aCBubyBvdmVybGFwIGFuZCBzaG91bGQgbm90IGJlIHVzZWQgZm9yIGFsaWdubWVudClcbiAgICBzbGlkaW5nID0gb2xkRGV0YWlscy5mcmFnbWVudFN0YXJ0O1xuICB9IGVsc2Uge1xuICAgIC8vIG5ldyBkZXRhaWxzIGFscmVhZHkgaGFzIGEgc2xpZGluZyBvZmZzZXQgb3IgaGFzIHNraXBwZWQgc2VnbWVudHNcbiAgICByZXR1cm47XG4gIH1cbiAgYWRkU2xpZGluZyhuZXdEZXRhaWxzLCBzbGlkaW5nKTtcbn1cbmZ1bmN0aW9uIGFkZFNsaWRpbmcoZGV0YWlscywgc2xpZGluZykge1xuICBpZiAoc2xpZGluZykge1xuICAgIGNvbnN0IGZyYWdtZW50cyA9IGRldGFpbHMuZnJhZ21lbnRzO1xuICAgIGZvciAobGV0IGkgPSBkZXRhaWxzLnNraXBwZWRTZWdtZW50czsgaSA8IGZyYWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgZnJhZ21lbnRzW2ldLmFkZFN0YXJ0KHNsaWRpbmcpO1xuICAgIH1cbiAgICBpZiAoZGV0YWlscy5mcmFnbWVudEhpbnQpIHtcbiAgICAgIGRldGFpbHMuZnJhZ21lbnRIaW50LmFkZFN0YXJ0KHNsaWRpbmcpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZVJlbG9hZEludGVydmFsKG5ld0RldGFpbHMsIGRpc3RhbmNlVG9MaXZlRWRnZU1zID0gSW5maW5pdHkpIHtcbiAgbGV0IHJlbG9hZEludGVydmFsID0gMTAwMCAqIG5ld0RldGFpbHMudGFyZ2V0ZHVyYXRpb247XG4gIGlmIChuZXdEZXRhaWxzLnVwZGF0ZWQpIHtcbiAgICAvLyBVc2UgbGFzdCBzZWdtZW50IGR1cmF0aW9uIHdoZW4gc2hvcnRlciB0aGFuIHRhcmdldCBkdXJhdGlvbiBhbmQgbmVhciBsaXZlIGVkZ2VcbiAgICBjb25zdCBmcmFnbWVudHMgPSBuZXdEZXRhaWxzLmZyYWdtZW50cztcbiAgICBjb25zdCBsaXZlRWRnZU1heFRhcmdldER1cmF0aW9ucyA9IDQ7XG4gICAgaWYgKGZyYWdtZW50cy5sZW5ndGggJiYgcmVsb2FkSW50ZXJ2YWwgKiBsaXZlRWRnZU1heFRhcmdldER1cmF0aW9ucyA+IGRpc3RhbmNlVG9MaXZlRWRnZU1zKSB7XG4gICAgICBjb25zdCBsYXN0U2VnbWVudER1cmF0aW9uID0gZnJhZ21lbnRzW2ZyYWdtZW50cy5sZW5ndGggLSAxXS5kdXJhdGlvbiAqIDEwMDA7XG4gICAgICBpZiAobGFzdFNlZ21lbnREdXJhdGlvbiA8IHJlbG9hZEludGVydmFsKSB7XG4gICAgICAgIHJlbG9hZEludGVydmFsID0gbGFzdFNlZ21lbnREdXJhdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gZXN0aW1hdGUgPSAnbWlzcyBoYWxmIGF2ZXJhZ2UnO1xuICAgIC8vIGZvbGxvdyBITFMgU3BlYywgSWYgdGhlIGNsaWVudCByZWxvYWRzIGEgUGxheWxpc3QgZmlsZSBhbmQgZmluZHMgdGhhdCBpdCBoYXMgbm90XG4gICAgLy8gY2hhbmdlZCB0aGVuIGl0IE1VU1Qgd2FpdCBmb3IgYSBwZXJpb2Qgb2Ygb25lLWhhbGYgdGhlIHRhcmdldFxuICAgIC8vIGR1cmF0aW9uIGJlZm9yZSByZXRyeWluZy5cbiAgICByZWxvYWRJbnRlcnZhbCAvPSAyO1xuICB9XG4gIHJldHVybiBNYXRoLnJvdW5kKHJlbG9hZEludGVydmFsKTtcbn1cbmZ1bmN0aW9uIGdldEZyYWdtZW50V2l0aFNOKGRldGFpbHMsIHNuLCBmcmFnQ3VycmVudCkge1xuICBpZiAoIWRldGFpbHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBsZXQgZnJhZ21lbnQgPSBkZXRhaWxzLmZyYWdtZW50c1tzbiAtIGRldGFpbHMuc3RhcnRTTl07XG4gIGlmIChmcmFnbWVudCkge1xuICAgIHJldHVybiBmcmFnbWVudDtcbiAgfVxuICBmcmFnbWVudCA9IGRldGFpbHMuZnJhZ21lbnRIaW50O1xuICBpZiAoZnJhZ21lbnQgJiYgZnJhZ21lbnQuc24gPT09IHNuKSB7XG4gICAgcmV0dXJuIGZyYWdtZW50O1xuICB9XG4gIGlmIChzbiA8IGRldGFpbHMuc3RhcnRTTiAmJiBmcmFnQ3VycmVudCAmJiBmcmFnQ3VycmVudC5zbiA9PT0gc24pIHtcbiAgICByZXR1cm4gZnJhZ0N1cnJlbnQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRQYXJ0V2l0aChkZXRhaWxzLCBzbiwgcGFydEluZGV4KSB7XG4gIGlmICghZGV0YWlscykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBmaW5kUGFydChkZXRhaWxzLnBhcnRMaXN0LCBzbiwgcGFydEluZGV4KTtcbn1cbmZ1bmN0aW9uIGZpbmRQYXJ0KHBhcnRMaXN0LCBzbiwgcGFydEluZGV4KSB7XG4gIGlmIChwYXJ0TGlzdCkge1xuICAgIGZvciAobGV0IGkgPSBwYXJ0TGlzdC5sZW5ndGg7IGktLTspIHtcbiAgICAgIGNvbnN0IHBhcnQgPSBwYXJ0TGlzdFtpXTtcbiAgICAgIGlmIChwYXJ0LmluZGV4ID09PSBwYXJ0SW5kZXggJiYgcGFydC5mcmFnbWVudC5zbiA9PT0gc24pIHtcbiAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcmVhc3NpZ25GcmFnbWVudExldmVsSW5kZXhlcyhsZXZlbHMpIHtcbiAgbGV2ZWxzLmZvckVhY2goKGxldmVsLCBpbmRleCkgPT4ge1xuICAgIHZhciBfbGV2ZWwkZGV0YWlscztcbiAgICAoX2xldmVsJGRldGFpbHMgPSBsZXZlbC5kZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX2xldmVsJGRldGFpbHMuZnJhZ21lbnRzLmZvckVhY2goZnJhZ21lbnQgPT4ge1xuICAgICAgZnJhZ21lbnQubGV2ZWwgPSBpbmRleDtcbiAgICAgIGlmIChmcmFnbWVudC5pbml0U2VnbWVudCkge1xuICAgICAgICBmcmFnbWVudC5pbml0U2VnbWVudC5sZXZlbCA9IGluZGV4O1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZmluZEZpcnN0RnJhZ1dpdGhDQyhmcmFnbWVudHMsIGNjKSB7XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBmcmFnbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgX2ZyYWdtZW50cyRpO1xuICAgIGlmICgoKF9mcmFnbWVudHMkaSA9IGZyYWdtZW50c1tpXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mcmFnbWVudHMkaS5jYykgPT09IGNjKSB7XG4gICAgICByZXR1cm4gZnJhZ21lbnRzW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHNob3VsZEFsaWduT25EaXNjb250aW51aXRpZXMocmVmRGV0YWlscywgZGV0YWlscykge1xuICBpZiAocmVmRGV0YWlscykge1xuICAgIGlmIChkZXRhaWxzLnN0YXJ0Q0MgPCByZWZEZXRhaWxzLmVuZENDICYmIGRldGFpbHMuZW5kQ0MgPiByZWZEZXRhaWxzLnN0YXJ0Q0MpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBhZGp1c3RGcmFnbWVudFN0YXJ0KGZyYWcsIHNsaWRpbmcpIHtcbiAgaWYgKGZyYWcpIHtcbiAgICBjb25zdCBzdGFydCA9IGZyYWcuc3RhcnQgKyBzbGlkaW5nO1xuICAgIGZyYWcuc3RhcnQgPSBmcmFnLnN0YXJ0UFRTID0gc3RhcnQ7XG4gICAgZnJhZy5lbmRQVFMgPSBzdGFydCArIGZyYWcuZHVyYXRpb247XG4gIH1cbn1cbmZ1bmN0aW9uIGFkanVzdFNsaWRpbmdTdGFydChzbGlkaW5nLCBkZXRhaWxzKSB7XG4gIC8vIFVwZGF0ZSBzZWdtZW50c1xuICBjb25zdCBmcmFnbWVudHMgPSBkZXRhaWxzLmZyYWdtZW50cztcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGZyYWdtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGFkanVzdEZyYWdtZW50U3RhcnQoZnJhZ21lbnRzW2ldLCBzbGlkaW5nKTtcbiAgfVxuICAvLyBVcGRhdGUgTEwtSExTIHBhcnRzIGF0IHRoZSBlbmQgb2YgdGhlIHBsYXlsaXN0XG4gIGlmIChkZXRhaWxzLmZyYWdtZW50SGludCkge1xuICAgIGFkanVzdEZyYWdtZW50U3RhcnQoZGV0YWlscy5mcmFnbWVudEhpbnQsIHNsaWRpbmcpO1xuICB9XG4gIGRldGFpbHMuYWxpZ25lZFNsaWRpbmcgPSB0cnVlO1xufVxuXG4vKipcbiAqIFVzaW5nIHRoZSBwYXJhbWV0ZXJzIG9mIHRoZSBsYXN0IGxldmVsLCB0aGlzIGZ1bmN0aW9uIGNvbXB1dGVzIFBUUycgb2YgdGhlIG5ldyBmcmFnbWVudHMgc28gdGhhdCB0aGV5IGZvcm0gYVxuICogY29udGlndW91cyBzdHJlYW0gd2l0aCB0aGUgbGFzdCBmcmFnbWVudHMuXG4gKiBUaGUgUFRTIG9mIGEgZnJhZ21lbnQgbGV0cyBIbHMuanMga25vdyB3aGVyZSBpdCBmaXRzIGludG8gYSBzdHJlYW0gLSBieSBrbm93aW5nIGV2ZXJ5IFBUUywgd2Uga25vdyB3aGljaCBmcmFnbWVudCB0b1xuICogZG93bmxvYWQgYXQgYW55IGdpdmVuIHRpbWUuIFBUUyBpcyBub3JtYWxseSBjb21wdXRlZCB3aGVuIHRoZSBmcmFnbWVudCBpcyBkZW11eGVkLCBzbyB0YWtpbmcgdGhpcyBzdGVwIHNhdmVzIHVzIHRpbWVcbiAqIGFuZCBhbiBleHRyYSBkb3dubG9hZC5cbiAqIEBwYXJhbSBsYXN0TGV2ZWxcbiAqIEBwYXJhbSBkZXRhaWxzXG4gKi9cbmZ1bmN0aW9uIGFsaWduU3RyZWFtKHN3aXRjaERldGFpbHMsIGRldGFpbHMpIHtcbiAgaWYgKCFzd2l0Y2hEZXRhaWxzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFsaWduRGlzY29udGludWl0aWVzKGRldGFpbHMsIHN3aXRjaERldGFpbHMpO1xuICBpZiAoIWRldGFpbHMuYWxpZ25lZFNsaWRpbmcgJiYgc3dpdGNoRGV0YWlscykge1xuICAgIC8vIElmIHRoZSBQVFMgd2Fzbid0IGZpZ3VyZWQgb3V0IHZpYSBkaXNjb250aW51aXR5IHNlcXVlbmNlIHRoYXQgbWVhbnMgdGhlcmUgd2FzIG5vIENDIGluY3JlYXNlIHdpdGhpbiB0aGUgbGV2ZWwuXG4gICAgLy8gQWxpZ25pbmcgdmlhIFByb2dyYW0gRGF0ZSBUaW1lIHNob3VsZCB0aGVyZWZvcmUgYmUgcmVsaWFibGUsIHNpbmNlIFBEVCBzaG91bGQgYmUgdGhlIHNhbWUgd2l0aGluIHRoZSBzYW1lXG4gICAgLy8gZGlzY29udGludWl0eSBzZXF1ZW5jZS5cbiAgICBhbGlnbk1lZGlhUGxheWxpc3RCeVBEVChkZXRhaWxzLCBzd2l0Y2hEZXRhaWxzKTtcbiAgfVxuICBpZiAoIWRldGFpbHMuYWxpZ25lZFNsaWRpbmcgJiYgc3dpdGNoRGV0YWlscyAmJiAhZGV0YWlscy5za2lwcGVkU2VnbWVudHMpIHtcbiAgICAvLyBUcnkgdG8gYWxpZ24gb24gc24gc28gdGhhdCB3ZSBwaWNrIGEgYmV0dGVyIHN0YXJ0IGZyYWdtZW50LlxuICAgIC8vIERvIG5vdCBwZXJmb3JtIHRoaXMgb24gcGxheWxpc3RzIHdpdGggZGVsdGEgdXBkYXRlcyBhcyB0aGlzIGlzIG9ubHkgdG8gYWxpZ24gbGV2ZWxzIG9uIHN3aXRjaFxuICAgIC8vIGFuZCBhZGp1c3RTbGlkaW5nIG9ubHkgYWRqdXN0cyBmcmFnbWVudHMgYWZ0ZXIgc2tpcHBlZFNlZ21lbnRzLlxuICAgIGFkanVzdFNsaWRpbmcoc3dpdGNoRGV0YWlscywgZGV0YWlscywgZmFsc2UpO1xuICB9XG59XG5cbi8qKlxuICogQWp1c3QgdGhlIHN0YXJ0IG9mIGZyYWdtZW50cyBpbiBgZGV0YWlsc2AgYnkgdGhlIGRpZmZlcmVuY2UgaW4gdGltZSBiZXR3ZWVuIGZyYWdtZW50cyBvZiB0aGUgbGF0ZXN0XG4gKiBzaGFyZWQgZGlzY29udGludWl0eSBzZXF1ZW5jZSBjaGFuZ2UuXG4gKiBAcGFyYW0gbGFzdExldmVsIC0gVGhlIGRldGFpbHMgb2YgdGhlIGxhc3QgbG9hZGVkIGxldmVsXG4gKiBAcGFyYW0gZGV0YWlscyAtIFRoZSBkZXRhaWxzIG9mIHRoZSBuZXcgbGV2ZWxcbiAqL1xuZnVuY3Rpb24gYWxpZ25EaXNjb250aW51aXRpZXMoZGV0YWlscywgcmVmRGV0YWlscykge1xuICBpZiAoIXNob3VsZEFsaWduT25EaXNjb250aW51aXRpZXMocmVmRGV0YWlscywgZGV0YWlscykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdGFyZ2V0Q0MgPSBNYXRoLm1pbihyZWZEZXRhaWxzLmVuZENDLCBkZXRhaWxzLmVuZENDKTtcbiAgY29uc3QgcmVmRnJhZyA9IGZpbmRGaXJzdEZyYWdXaXRoQ0MocmVmRGV0YWlscy5mcmFnbWVudHMsIHRhcmdldENDKTtcbiAgY29uc3QgZnJhZyA9IGZpbmRGaXJzdEZyYWdXaXRoQ0MoZGV0YWlscy5mcmFnbWVudHMsIHRhcmdldENDKTtcbiAgaWYgKCFyZWZGcmFnIHx8ICFmcmFnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxvZ2dlci5sb2coYEFsaWduaW5nIHBsYXlsaXN0IGF0IHN0YXJ0IG9mIGRpY29udGludWl0eSBzZXF1ZW5jZSAke3RhcmdldENDfWApO1xuICBjb25zdCBkZWx0YSA9IHJlZkZyYWcuc3RhcnQgLSBmcmFnLnN0YXJ0O1xuICBhZGp1c3RTbGlkaW5nU3RhcnQoZGVsdGEsIGRldGFpbHMpO1xufVxuXG4vKipcbiAqIEVuc3VyZXMgYXBwcm9wcmlhdGUgdGltZS1hbGlnbm1lbnQgYmV0d2VlbiByZW5kaXRpb25zIGJhc2VkIG9uIFBEVC5cbiAqIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGUgdGltZWxpbmVzIHJlcHJlc2VudGVkIGluIGByZWZEZXRhaWxzYCBhcmUgYWNjdXJhdGUsIGluY2x1ZGluZyB0aGUgUERUc1xuICogZm9yIHRoZSBsYXN0IGRpc2NvbnRpbnVpdHkgc2VxdWVuY2UgbnVtYmVyIHNoYXJlZCBieSBib3RoIHBsYXlsaXN0cyB3aGVuIHByZXNlbnQsXG4gKiBhbmQgdXNlcyB0aGUgXCJ3YWxsY2xvY2tcIi9QRFQgdGltZWxpbmUgYXMgYSBjcm9zcy1yZWZlcmVuY2UgdG8gYGRldGFpbHNgLCBhZGp1c3RpbmcgdGhlIHByZXNlbnRhdGlvblxuICogdGltZXMvdGltZWxpbmVzIG9mIGBkZXRhaWxzYCBhY2NvcmRpbmdseS5cbiAqIEdpdmVuIHRoZSBhc3luY2hyb25vdXMgbmF0dXJlIG9mIGZldGNoZXMgYW5kIGluaXRpYWwgbG9hZHMgb2YgbGl2ZSBgbWFpbmAgYW5kIGF1ZGlvL3N1YnRpdGxlIHRyYWNrcyxcbiAqIHRoZSBwcmltYXJ5IHB1cnBvc2Ugb2YgdGhpcyBmdW5jdGlvbiBpcyB0byBlbnN1cmUgdGhlIFwibG9jYWwgdGltZWxpbmVzXCIgb2YgYXVkaW8vc3VidGl0bGUgdHJhY2tzXG4gKiBhcmUgYWxpZ25lZCB0byB0aGUgbWFpbi92aWRlbyB0aW1lbGluZSwgdXNpbmcgUERUIGFzIHRoZSBjcm9zcy1yZWZlcmVuY2UvXCJhbmNob3JcIiB0aGF0IHNob3VsZFxuICogYmUgY29uc2lzdGVudCBhY3Jvc3MgcGxheWxpc3RzLCBwZXIgdGhlIEhMUyBzcGVjLlxuICogQHBhcmFtIGRldGFpbHMgLSBUaGUgZGV0YWlscyBvZiB0aGUgcmVuZGl0aW9uIHlvdSdkIGxpa2UgdG8gdGltZS1hbGlnbiAoZS5nLiBhbiBhdWRpbyByZW5kaXRpb24pLlxuICogQHBhcmFtIHJlZkRldGFpbHMgLSBUaGUgZGV0YWlscyBvZiB0aGUgcmVmZXJlbmNlIHJlbmRpdGlvbiB3aXRoIHN0YXJ0IGFuZCBQRFQgdGltZXMgZm9yIGFsaWdubWVudC5cbiAqL1xuZnVuY3Rpb24gYWxpZ25NZWRpYVBsYXlsaXN0QnlQRFQoZGV0YWlscywgcmVmRGV0YWlscykge1xuICBpZiAoIWRldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lIHx8ICFyZWZEZXRhaWxzLmhhc1Byb2dyYW1EYXRlVGltZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBmcmFnbWVudHMgPSBkZXRhaWxzLmZyYWdtZW50cztcbiAgY29uc3QgcmVmRnJhZ21lbnRzID0gcmVmRGV0YWlscy5mcmFnbWVudHM7XG4gIGlmICghZnJhZ21lbnRzLmxlbmd0aCB8fCAhcmVmRnJhZ21lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIENhbGN1bGF0ZSBhIGRlbHRhIHRvIGFwcGx5IHRvIGFsbCBmcmFnbWVudHMgYWNjb3JkaW5nIHRvIHRoZSBkZWx0YSBpbiBQRFQgdGltZXMgYW5kIHN0YXJ0IHRpbWVzXG4gIC8vIG9mIGEgZnJhZ21lbnQgaW4gdGhlIHJlZmVyZW5jZSBkZXRhaWxzLCBhbmQgYSBmcmFnbWVudCBpbiB0aGUgdGFyZ2V0IGRldGFpbHMgb2YgdGhlIHNhbWUgZGlzY29udGludWl0eS5cbiAgLy8gSWYgYSBmcmFnbWVudCBvZiB0aGUgc2FtZSBkaXNjb250aW51aXR5IHdhcyBub3QgZm91bmQgdXNlIHRoZSBtaWRkbGUgZnJhZ21lbnQgb2YgYm90aC5cbiAgbGV0IHJlZkZyYWc7XG4gIGxldCBmcmFnO1xuICBjb25zdCB0YXJnZXRDQyA9IE1hdGgubWluKHJlZkRldGFpbHMuZW5kQ0MsIGRldGFpbHMuZW5kQ0MpO1xuICBpZiAocmVmRGV0YWlscy5zdGFydENDIDwgdGFyZ2V0Q0MgJiYgZGV0YWlscy5zdGFydENDIDwgdGFyZ2V0Q0MpIHtcbiAgICByZWZGcmFnID0gZmluZEZpcnN0RnJhZ1dpdGhDQyhyZWZGcmFnbWVudHMsIHRhcmdldENDKTtcbiAgICBmcmFnID0gZmluZEZpcnN0RnJhZ1dpdGhDQyhmcmFnbWVudHMsIHRhcmdldENDKTtcbiAgfVxuICBpZiAoIXJlZkZyYWcgfHwgIWZyYWcpIHtcbiAgICByZWZGcmFnID0gcmVmRnJhZ21lbnRzW01hdGguZmxvb3IocmVmRnJhZ21lbnRzLmxlbmd0aCAvIDIpXTtcbiAgICBmcmFnID0gZmluZEZpcnN0RnJhZ1dpdGhDQyhmcmFnbWVudHMsIHJlZkZyYWcuY2MpIHx8IGZyYWdtZW50c1tNYXRoLmZsb29yKGZyYWdtZW50cy5sZW5ndGggLyAyKV07XG4gIH1cbiAgY29uc3QgcmVmUERUID0gcmVmRnJhZy5wcm9ncmFtRGF0ZVRpbWU7XG4gIGNvbnN0IHRhcmdldFBEVCA9IGZyYWcucHJvZ3JhbURhdGVUaW1lO1xuICBpZiAoIXJlZlBEVCB8fCAhdGFyZ2V0UERUKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGRlbHRhID0gKHRhcmdldFBEVCAtIHJlZlBEVCkgLyAxMDAwIC0gKGZyYWcuc3RhcnQgLSByZWZGcmFnLnN0YXJ0KTtcbiAgYWRqdXN0U2xpZGluZ1N0YXJ0KGRlbHRhLCBkZXRhaWxzKTtcbn1cblxuLyoqXG4gKiAgVGltZVJhbmdlcyB0byBzdHJpbmcgaGVscGVyXG4gKi9cblxuY29uc3QgVGltZVJhbmdlcyA9IHtcbiAgdG9TdHJpbmc6IGZ1bmN0aW9uIChyKSB7XG4gICAgbGV0IGxvZyA9ICcnO1xuICAgIGNvbnN0IGxlbiA9IHIubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGxvZyArPSBgWyR7ci5zdGFydChpKS50b0ZpeGVkKDMpfS0ke3IuZW5kKGkpLnRvRml4ZWQoMyl9XWA7XG4gICAgfVxuICAgIHJldHVybiBsb2c7XG4gIH1cbn07XG5cbmNvbnN0IFN0YXRlID0ge1xuICBTVE9QUEVEOiAnU1RPUFBFRCcsXG4gIElETEU6ICdJRExFJyxcbiAgS0VZX0xPQURJTkc6ICdLRVlfTE9BRElORycsXG4gIEZSQUdfTE9BRElORzogJ0ZSQUdfTE9BRElORycsXG4gIEZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZOiAnRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlknLFxuICBXQUlUSU5HX1RSQUNLOiAnV0FJVElOR19UUkFDSycsXG4gIFBBUlNJTkc6ICdQQVJTSU5HJyxcbiAgUEFSU0VEOiAnUEFSU0VEJyxcbiAgRU5ERUQ6ICdFTkRFRCcsXG4gIEVSUk9SOiAnRVJST1InLFxuICBXQUlUSU5HX0lOSVRfUFRTOiAnV0FJVElOR19JTklUX1BUUycsXG4gIFdBSVRJTkdfTEVWRUw6ICdXQUlUSU5HX0xFVkVMJ1xufTtcbmNsYXNzIEJhc2VTdHJlYW1Db250cm9sbGVyIGV4dGVuZHMgVGFza0xvb3Age1xuICBjb25zdHJ1Y3RvcihobHMsIGZyYWdtZW50VHJhY2tlciwga2V5TG9hZGVyLCBsb2dQcmVmaXgsIHBsYXlsaXN0VHlwZSkge1xuICAgIHN1cGVyKGxvZ1ByZWZpeCwgaGxzLmxvZ2dlcik7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyID0gdm9pZCAwO1xuICAgIHRoaXMudHJhbnNtdXhlciA9IG51bGw7XG4gICAgdGhpcy5fc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICAgIHRoaXMucGxheWxpc3RUeXBlID0gdm9pZCAwO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMubWVkaWFCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMuYml0cmF0ZVRlc3QgPSBmYWxzZTtcbiAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XG4gICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gMDtcbiAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSAwO1xuICAgIHRoaXMuc3RhcnRUaW1lT2Zmc2V0ID0gbnVsbDtcbiAgICB0aGlzLnJldHJ5RGF0ZSA9IDA7XG4gICAgdGhpcy5sZXZlbHMgPSBudWxsO1xuICAgIHRoaXMuZnJhZ21lbnRMb2FkZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXlMb2FkZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5sZXZlbExhc3RMb2FkZWQgPSBudWxsO1xuICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgdGhpcy5kZWNyeXB0ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5pbml0UFRTID0gW107XG4gICAgdGhpcy5idWZmZXJpbmcgPSB0cnVlO1xuICAgIHRoaXMubG9hZGluZ1BhcnRzID0gZmFsc2U7XG4gICAgdGhpcy5sb29wU24gPSB2b2lkIDA7XG4gICAgdGhpcy5vbk1lZGlhU2Vla2luZyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29uZmlnLFxuICAgICAgICBmcmFnQ3VycmVudCxcbiAgICAgICAgbWVkaWEsXG4gICAgICAgIG1lZGlhQnVmZmVyLFxuICAgICAgICBzdGF0ZVxuICAgICAgfSA9IHRoaXM7XG4gICAgICBjb25zdCBjdXJyZW50VGltZSA9IG1lZGlhID8gbWVkaWEuY3VycmVudFRpbWUgOiAwO1xuICAgICAgY29uc3QgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKG1lZGlhQnVmZmVyID8gbWVkaWFCdWZmZXIgOiBtZWRpYSwgY3VycmVudFRpbWUsIGNvbmZpZy5tYXhCdWZmZXJIb2xlKTtcbiAgICAgIGNvbnN0IG5vRm93YXJkQnVmZmVyID0gIWJ1ZmZlckluZm8ubGVuO1xuICAgICAgdGhpcy5sb2coYE1lZGlhIHNlZWtpbmcgdG8gJHtpc0Zpbml0ZU51bWJlcihjdXJyZW50VGltZSkgPyBjdXJyZW50VGltZS50b0ZpeGVkKDMpIDogY3VycmVudFRpbWV9LCBzdGF0ZTogJHtzdGF0ZX0sICR7bm9Gb3dhcmRCdWZmZXIgPyAnb3V0IG9mJyA6ICdpbid9IGJ1ZmZlcmApO1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkVOREVEKSB7XG4gICAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICAgIH0gZWxzZSBpZiAoZnJhZ0N1cnJlbnQpIHtcbiAgICAgICAgLy8gU2Vla2luZyB3aGlsZSBmcmFnIGxvYWQgaXMgaW4gcHJvZ3Jlc3NcbiAgICAgICAgY29uc3QgdG9sZXJhbmNlID0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2U7XG4gICAgICAgIGNvbnN0IGZyYWdTdGFydE9mZnNldCA9IGZyYWdDdXJyZW50LnN0YXJ0IC0gdG9sZXJhbmNlO1xuICAgICAgICBjb25zdCBmcmFnRW5kT2Zmc2V0ID0gZnJhZ0N1cnJlbnQuc3RhcnQgKyBmcmFnQ3VycmVudC5kdXJhdGlvbiArIHRvbGVyYW5jZTtcbiAgICAgICAgLy8gaWYgc2Vla2luZyBvdXQgb2YgYnVmZmVyZWQgcmFuZ2Ugb3IgaW50byBuZXcgb25lXG4gICAgICAgIGlmIChub0Zvd2FyZEJ1ZmZlciB8fCBmcmFnRW5kT2Zmc2V0IDwgYnVmZmVySW5mby5zdGFydCB8fCBmcmFnU3RhcnRPZmZzZXQgPiBidWZmZXJJbmZvLmVuZCkge1xuICAgICAgICAgIGNvbnN0IHBhc3RGcmFnbWVudCA9IGN1cnJlbnRUaW1lID4gZnJhZ0VuZE9mZnNldDtcbiAgICAgICAgICAvLyBpZiB0aGUgc2VlayBwb3NpdGlvbiBpcyBvdXRzaWRlIHRoZSBjdXJyZW50IGZyYWdtZW50IHJhbmdlXG4gICAgICAgICAgaWYgKGN1cnJlbnRUaW1lIDwgZnJhZ1N0YXJ0T2Zmc2V0IHx8IHBhc3RGcmFnbWVudCkge1xuICAgICAgICAgICAgaWYgKHBhc3RGcmFnbWVudCAmJiBmcmFnQ3VycmVudC5sb2FkZXIpIHtcbiAgICAgICAgICAgICAgdGhpcy5sb2coYENhbmNlbGxpbmcgZnJhZ21lbnQgbG9hZCBmb3Igc2VlayAoc246ICR7ZnJhZ0N1cnJlbnQuc259KWApO1xuICAgICAgICAgICAgICBmcmFnQ3VycmVudC5hYm9ydFJlcXVlc3RzKCk7XG4gICAgICAgICAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICAvLyBSZW1vdmUgZ2FwIGZyYWdtZW50c1xuICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudHNJblJhbmdlKGN1cnJlbnRUaW1lLCBJbmZpbml0eSwgdGhpcy5wbGF5bGlzdFR5cGUsIHRydWUpO1xuXG4gICAgICAgIC8vIERvbid0IHNldCBsYXN0Q3VycmVudFRpbWUgd2l0aCBiYWNrd2FyZCBzZWVrcyAoYWxsb3dzIGZvciBmcmFnIHNlbGVjdGlvbiB3aXRoIHN0cmljdCB0b2xlcmFuY2VzKVxuICAgICAgICBjb25zdCBsYXN0Q3VycmVudFRpbWUgPSB0aGlzLmxhc3RDdXJyZW50VGltZTtcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lID4gbGFzdEN1cnJlbnRUaW1lKSB7XG4gICAgICAgICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMubG9hZGluZ1BhcnRzKSB7XG4gICAgICAgICAgY29uc3QgYnVmZmVyRW5kID0gTWF0aC5tYXgoYnVmZmVySW5mby5lbmQsIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICBjb25zdCBzaG91bGRMb2FkUGFydHMgPSB0aGlzLnNob3VsZExvYWRQYXJ0cyh0aGlzLmdldExldmVsRGV0YWlscygpLCBidWZmZXJFbmQpO1xuICAgICAgICAgIGlmIChzaG91bGRMb2FkUGFydHMpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKGBMTC1QYXJ0IGxvYWRpbmcgT04gYWZ0ZXIgc2Vla2luZyB0byAke2N1cnJlbnRUaW1lLnRvRml4ZWQoMil9IHdpdGggYnVmZmVyIEAke2J1ZmZlckVuZC50b0ZpeGVkKDIpfWApO1xuICAgICAgICAgICAgdGhpcy5sb2FkaW5nUGFydHMgPSBzaG91bGRMb2FkUGFydHM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGluIGNhc2Ugc2Vla2luZyBvY2N1cnMgYWx0aG91Z2ggbm8gbWVkaWEgYnVmZmVyZWQsIGFkanVzdCBzdGFydFBvc2l0aW9uIGFuZCBuZXh0TG9hZFBvc2l0aW9uIHRvIHNlZWsgdGFyZ2V0XG4gICAgICBpZiAoIXRoaXMuaGxzLmhhc0Vub3VnaFRvU3RhcnQpIHtcbiAgICAgICAgdGhpcy5sb2coYFNldHRpbmcgJHtub0Zvd2FyZEJ1ZmZlciA/ICdzdGFydFBvc2l0aW9uJyA6ICduZXh0TG9hZFBvc2l0aW9uJ30gdG8gJHtjdXJyZW50VGltZX0gZm9yIHNlZWsgd2l0aG91dCBlbm91Z2ggdG8gc3RhcnRgKTtcbiAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gY3VycmVudFRpbWU7XG4gICAgICAgIGlmIChub0Zvd2FyZEJ1ZmZlcikge1xuICAgICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IGN1cnJlbnRUaW1lO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEFzeW5jIHRpY2sgdG8gc3BlZWQgdXAgcHJvY2Vzc2luZ1xuICAgICAgdGhpcy50aWNrSW1tZWRpYXRlKCk7XG4gICAgfTtcbiAgICB0aGlzLm9uTWVkaWFFbmRlZCA9ICgpID0+IHtcbiAgICAgIC8vIHJlc2V0IHN0YXJ0UG9zaXRpb24gYW5kIGxhc3RDdXJyZW50VGltZSB0byByZXN0YXJ0IHBsYXliYWNrIEAgc3RyZWFtIGJlZ2lubmluZ1xuICAgICAgdGhpcy5sb2coYHNldHRpbmcgc3RhcnRQb3NpdGlvbiB0byAwIGJlY2F1c2UgbWVkaWEgZW5kZWRgKTtcbiAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgICB9O1xuICAgIHRoaXMucGxheWxpc3RUeXBlID0gcGxheWxpc3RUeXBlO1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMuZnJhZ21lbnRMb2FkZXIgPSBuZXcgRnJhZ21lbnRMb2FkZXIoaGxzLmNvbmZpZyk7XG4gICAgdGhpcy5rZXlMb2FkZXIgPSBrZXlMb2FkZXI7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIgPSBmcmFnbWVudFRyYWNrZXI7XG4gICAgdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgIHRoaXMuZGVjcnlwdGVyID0gbmV3IERlY3J5cHRlcihobHMuY29uZmlnKTtcbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURFRCwgdGhpcy5vbk1hbmlmZXN0TG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9XG4gIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9XG4gIGRvVGljaygpIHtcbiAgICB0aGlzLm9uVGlja0VuZCgpO1xuICB9XG4gIG9uVGlja0VuZCgpIHt9XG4gIHN0YXJ0TG9hZChzdGFydFBvc2l0aW9uKSB7fVxuICBzdG9wTG9hZCgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuU1RPUFBFRCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmZyYWdtZW50TG9hZGVyLmFib3J0KCk7XG4gICAgdGhpcy5rZXlMb2FkZXIuYWJvcnQodGhpcy5wbGF5bGlzdFR5cGUpO1xuICAgIGNvbnN0IGZyYWcgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgIGlmIChmcmFnICE9IG51bGwgJiYgZnJhZy5sb2FkZXIpIHtcbiAgICAgIGZyYWcuYWJvcnRSZXF1ZXN0cygpO1xuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgfVxuICAgIHRoaXMucmVzZXRUcmFuc211eGVyKCk7XG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgIHRoaXMuY2xlYXJJbnRlcnZhbCgpO1xuICAgIHRoaXMuY2xlYXJOZXh0VGljaygpO1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICB9XG4gIGdldCBzdGFydFBvc2l0aW9uVmFsdWUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmV4dExvYWRQb3NpdGlvbixcbiAgICAgIHN0YXJ0UG9zaXRpb25cbiAgICB9ID0gdGhpcztcbiAgICBpZiAoc3RhcnRQb3NpdGlvbiA9PT0gLTEgJiYgbmV4dExvYWRQb3NpdGlvbikge1xuICAgICAgcmV0dXJuIG5leHRMb2FkUG9zaXRpb247XG4gICAgfVxuICAgIHJldHVybiBzdGFydFBvc2l0aW9uO1xuICB9XG4gIGdldCBidWZmZXJpbmdFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlcmluZztcbiAgfVxuICBwYXVzZUJ1ZmZlcmluZygpIHtcbiAgICB0aGlzLmJ1ZmZlcmluZyA9IGZhbHNlO1xuICB9XG4gIHJlc3VtZUJ1ZmZlcmluZygpIHtcbiAgICB0aGlzLmJ1ZmZlcmluZyA9IHRydWU7XG4gIH1cbiAgZ2V0IGluRmxpZ2h0RnJhZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZnJhZzogdGhpcy5mcmFnQ3VycmVudCxcbiAgICAgIHN0YXRlOiB0aGlzLnN0YXRlXG4gICAgfTtcbiAgfVxuICBfc3RyZWFtRW5kZWQoYnVmZmVySW5mbywgbGV2ZWxEZXRhaWxzKSB7XG4gICAgLy8gU3RyZWFtIGlzIG5ldmVyIFwiZW5kZWRcIiB3aGVuIHBsYXlsaXN0IGlzIGxpdmUgb3IgbWVkaWEgaXMgZGV0YWNoZWRcbiAgICBpZiAobGV2ZWxEZXRhaWxzLmxpdmUgfHwgIXRoaXMubWVkaWEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gU3RyZWFtIGlzIG5vdCBcImVuZGVkXCIgd2hlbiBub3RoaW5nIGlzIGJ1ZmZlcmVkIHBhc3QgdGhlIHN0YXJ0XG4gICAgY29uc3QgYnVmZmVyRW5kID0gYnVmZmVySW5mby5lbmQgfHwgMDtcbiAgICBjb25zdCB0aW1lbGluZVN0YXJ0ID0gdGhpcy5jb25maWcudGltZWxpbmVPZmZzZXQgfHwgMDtcbiAgICBpZiAoYnVmZmVyRW5kIDw9IHRpbWVsaW5lU3RhcnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gU3RyZWFtIGlzIG5vdCBcImVuZGVkXCIgd2hlbiB0aGVyZSBpcyBhIHNlY29uZCBidWZmZXJlZCByYW5nZSBzdGFydGluZyBiZWZvcmUgdGhlIGVuZCBvZiB0aGUgcGxheWxpc3RcbiAgICBjb25zdCBidWZmZXJlZFJhbmdlcyA9IGJ1ZmZlckluZm8uYnVmZmVyZWQ7XG4gICAgaWYgKHRoaXMuY29uZmlnLm1heEJ1ZmZlckhvbGUgJiYgYnVmZmVyZWRSYW5nZXMgJiYgYnVmZmVyZWRSYW5nZXMubGVuZ3RoID4gMSkge1xuICAgICAgLy8gbWFrZSBzdXJlIGJ1ZmZlckluZm8gYWNjb3VudHMgZm9yIGFueSBnYXBzXG4gICAgICBidWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlcmVkSW5mbyhidWZmZXJlZFJhbmdlcywgYnVmZmVySW5mby5zdGFydCwgMCk7XG4gICAgfVxuICAgIGNvbnN0IG5leHRTdGFydCA9IGJ1ZmZlckluZm8ubmV4dFN0YXJ0O1xuICAgIGNvbnN0IGhhc1NlY29uZEJ1ZmZlcmVkUmFuZ2UgPSBuZXh0U3RhcnQgJiYgbmV4dFN0YXJ0ID4gdGltZWxpbmVTdGFydCAmJiBuZXh0U3RhcnQgPCBsZXZlbERldGFpbHMuZWRnZTtcbiAgICBpZiAoaGFzU2Vjb25kQnVmZmVyZWRSYW5nZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBQbGF5aGVhZCBpcyBpbiB1bmJ1ZmZlcmVkIHJlZ2lvbi4gTWFya2luZyBFb1Mgbm93IGNvdWxkIHJlc3VsdCBpbiBTYWZhcmkgZmFpbGluZyB0byBkaXNwYXRjaCBcImVuZGVkXCIgZXZlbnQgZm9sbG93aW5nIHNlZWsgb24gc3RhcnQuXG4gICAgaWYgKHRoaXMubWVkaWEuY3VycmVudFRpbWUgPCBidWZmZXJJbmZvLnN0YXJ0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHBhcnRMaXN0ID0gbGV2ZWxEZXRhaWxzLnBhcnRMaXN0O1xuICAgIC8vIFNpbmNlIHRoZSBsYXN0IHBhcnQgaXNuJ3QgZ3VhcmFudGVlZCB0byBjb3JyZXNwb25kIHRvIHRoZSBsYXN0IHBsYXlsaXN0IHNlZ21lbnQgZm9yIExvdy1MYXRlbmN5IEhMUyxcbiAgICAvLyBjaGVjayBpbnN0ZWFkIGlmIHRoZSBsYXN0IHBhcnQgaXMgYnVmZmVyZWQuXG4gICAgaWYgKHBhcnRMaXN0ICE9IG51bGwgJiYgcGFydExpc3QubGVuZ3RoKSB7XG4gICAgICBjb25zdCBsYXN0UGFydCA9IHBhcnRMaXN0W3BhcnRMaXN0Lmxlbmd0aCAtIDFdO1xuXG4gICAgICAvLyBDaGVja2luZyB0aGUgbWlkcG9pbnQgb2YgdGhlIHBhcnQgZm9yIHBvdGVudGlhbCBtYXJnaW4gb2YgZXJyb3IgYW5kIHJlbGF0ZWQgaXNzdWVzLlxuICAgICAgLy8gTk9URTogVGVjaG5pY2FsbHkgSSBiZWxpZXZlIHBhcnRzIGNvdWxkIHlpZWxkIGNvbnRlbnQgdGhhdCBpcyA8IHRoZSBjb21wdXRlZCBkdXJhdGlvbiAoaW5jbHVkaW5nIHBvdGVudGlhbCBhIGR1cmF0aW9uIG9mIDApXG4gICAgICAvLyBhbmQgc3RpbGwgYmUgc3BlYy1jb21wbGlhbnQsIHNvIHRoZXJlIG1heSBzdGlsbCBiZSBlZGdlIGNhc2VzIGhlcmUuIExpa2V3aXNlLCB0aGVyZSBjb3VsZCBiZSBpc3N1ZXMgaW4gZW5kIG9mIHN0cmVhbVxuICAgICAgLy8gcGFydCBtaXNtYXRjaGVzIGZvciBpbmRlcGVuZGVudCBhdWRpbyBhbmQgdmlkZW8gcGxheWxpc3RzL3NlZ21lbnRzLlxuICAgICAgY29uc3QgbGFzdFBhcnRCdWZmZXJlZCA9IEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKHRoaXMubWVkaWEsIGxhc3RQYXJ0LnN0YXJ0ICsgbGFzdFBhcnQuZHVyYXRpb24gLyAyKTtcbiAgICAgIHJldHVybiBsYXN0UGFydEJ1ZmZlcmVkO1xuICAgIH1cbiAgICBjb25zdCBwbGF5bGlzdFR5cGUgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRzW2xldmVsRGV0YWlscy5mcmFnbWVudHMubGVuZ3RoIC0gMV0udHlwZTtcbiAgICByZXR1cm4gdGhpcy5mcmFnbWVudFRyYWNrZXIuaXNFbmRMaXN0QXBwZW5kZWQocGxheWxpc3RUeXBlKTtcbiAgfVxuICBnZXRMZXZlbERldGFpbHMoKSB7XG4gICAgaWYgKHRoaXMubGV2ZWxzICYmIHRoaXMubGV2ZWxMYXN0TG9hZGVkICE9PSBudWxsKSB7XG4gICAgICB2YXIgX3RoaXMkbGV2ZWxMYXN0TG9hZGVkO1xuICAgICAgcmV0dXJuIChfdGhpcyRsZXZlbExhc3RMb2FkZWQgPSB0aGlzLmxldmVsTGFzdExvYWRlZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGxldmVsTGFzdExvYWRlZC5kZXRhaWxzO1xuICAgIH1cbiAgfVxuICBnZXQgdGltZWxpbmVPZmZzZXQoKSB7XG4gICAgY29uc3QgY29uZmlndXJlZFRpbWVsaW5lT2Zmc2V0ID0gdGhpcy5jb25maWcudGltZWxpbmVPZmZzZXQ7XG4gICAgaWYgKGNvbmZpZ3VyZWRUaW1lbGluZU9mZnNldCkge1xuICAgICAgdmFyIF90aGlzJGdldExldmVsRGV0YWlscztcbiAgICAgIHJldHVybiAoKF90aGlzJGdldExldmVsRGV0YWlscyA9IHRoaXMuZ2V0TGV2ZWxEZXRhaWxzKCkpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRnZXRMZXZlbERldGFpbHMuYXBwbGllZFRpbWVsaW5lT2Zmc2V0KSB8fCBjb25maWd1cmVkVGltZWxpbmVPZmZzZXQ7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIG9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPSBkYXRhLm1lZGlhO1xuICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlZWtpbmcnLCB0aGlzLm9uTWVkaWFTZWVraW5nKTtcbiAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMub25NZWRpYUVuZGVkKTtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdzZWVraW5nJywgdGhpcy5vbk1lZGlhU2Vla2luZyk7XG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLm9uTWVkaWFFbmRlZCk7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgaWYgKHRoaXMubGV2ZWxzICYmIGNvbmZpZy5hdXRvU3RhcnRMb2FkICYmIHRoaXMuc3RhdGUgPT09IFN0YXRlLlNUT1BQRUQpIHtcbiAgICAgIHRoaXMuc3RhcnRMb2FkKGNvbmZpZy5zdGFydFBvc2l0aW9uKTtcbiAgICB9XG4gIH1cbiAgb25NZWRpYURldGFjaGluZyhldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHRyYW5zZmVycmluZ01lZGlhID0gISFkYXRhLnRyYW5zZmVyTWVkaWE7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGlmIChtZWRpYSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobWVkaWEuZW5kZWQpIHtcbiAgICAgIHRoaXMubG9nKCdNU0UgZGV0YWNoaW5nIGFuZCB2aWRlbyBlbmRlZCwgcmVzZXQgc3RhcnRQb3NpdGlvbicpO1xuICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSB2aWRlbyBsaXN0ZW5lcnNcbiAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWVraW5nJywgdGhpcy5vbk1lZGlhU2Vla2luZyk7XG4gICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLm9uTWVkaWFFbmRlZCk7XG4gICAgaWYgKHRoaXMua2V5TG9hZGVyICYmICF0cmFuc2ZlcnJpbmdNZWRpYSkge1xuICAgICAgdGhpcy5rZXlMb2FkZXIuZGV0YWNoKCk7XG4gICAgfVxuICAgIHRoaXMubWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmxvb3BTbiA9IHVuZGVmaW5lZDtcbiAgICBpZiAodHJhbnNmZXJyaW5nTWVkaWEpIHtcbiAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICAgIHRoaXMucmVzZXRUcmFuc211eGVyKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubG9hZGluZ1BhcnRzID0gZmFsc2U7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlQWxsRnJhZ21lbnRzKCk7XG4gICAgdGhpcy5zdG9wTG9hZCgpO1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHRoaXMuaW5pdFBUUyA9IFtdO1xuICAgIHRoaXMubGV2ZWxzID0gdGhpcy5sZXZlbExhc3RMb2FkZWQgPSB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IHRoaXMuc3RhcnRQb3NpdGlvbiA9IDA7XG4gICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgfVxuICBvbkVycm9yKGV2ZW50LCBkYXRhKSB7fVxuICBvbk1hbmlmZXN0TG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5zdGFydFRpbWVPZmZzZXQgPSBkYXRhLnN0YXJ0VGltZU9mZnNldDtcbiAgfVxuICBvbkhhbmRsZXJEZXN0cm95aW5nKCkge1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICBpZiAodGhpcy50cmFuc211eGVyKSB7XG4gICAgICB0aGlzLnRyYW5zbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy50cmFuc211eGVyID0gbnVsbDtcbiAgICB9XG4gICAgc3VwZXIub25IYW5kbGVyRGVzdHJveWluZygpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmhscyA9IHRoaXMub25NZWRpYVNlZWtpbmcgPSB0aGlzLm9uTWVkaWFFbmRlZCA9IG51bGw7XG4gIH1cbiAgb25IYW5kbGVyRGVzdHJveWVkKCkge1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICAgIGlmICh0aGlzLmZyYWdtZW50TG9hZGVyKSB7XG4gICAgICB0aGlzLmZyYWdtZW50TG9hZGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgaWYgKHRoaXMua2V5TG9hZGVyKSB7XG4gICAgICB0aGlzLmtleUxvYWRlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmRlY3J5cHRlcikge1xuICAgICAgdGhpcy5kZWNyeXB0ZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLmhscyA9IHRoaXMubG9nID0gdGhpcy53YXJuID0gdGhpcy5kZWNyeXB0ZXIgPSB0aGlzLmtleUxvYWRlciA9IHRoaXMuZnJhZ21lbnRMb2FkZXIgPSB0aGlzLmZyYWdtZW50VHJhY2tlciA9IG51bGw7XG4gICAgc3VwZXIub25IYW5kbGVyRGVzdHJveWVkKCk7XG4gIH1cbiAgbG9hZEZyYWdtZW50KGZyYWcsIGxldmVsLCB0YXJnZXRCdWZmZXJUaW1lKSB7XG4gICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSB0cnVlO1xuICAgIHRoaXMuX2xvYWRGcmFnRm9yUGxheWJhY2soZnJhZywgbGV2ZWwsIHRhcmdldEJ1ZmZlclRpbWUpO1xuICB9XG4gIF9sb2FkRnJhZ0ZvclBsYXliYWNrKGZyYWdtZW50LCBsZXZlbCwgdGFyZ2V0QnVmZmVyVGltZSkge1xuICAgIGNvbnN0IHByb2dyZXNzQ2FsbGJhY2sgPSBkYXRhID0+IHtcbiAgICAgIGNvbnN0IGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgICBpZiAodGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgICAgdGhpcy53YXJuKGAke2ZyYWcudHlwZX0gc246ICR7ZnJhZy5zbn0ke2RhdGEucGFydCA/ICcgcGFydDogJyArIGRhdGEucGFydC5pbmRleCA6ICcnfSBvZiAke3RoaXMuZnJhZ0luZm8oZnJhZywgZmFsc2UsIGRhdGEucGFydCl9KSB3YXMgZHJvcHBlZCBkdXJpbmcgZG93bmxvYWQuYCk7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmcmFnLnN0YXRzLmNodW5rQ291bnQrKztcbiAgICAgIHRoaXMuX2hhbmRsZUZyYWdtZW50TG9hZFByb2dyZXNzKGRhdGEpO1xuICAgIH07XG4gICAgdGhpcy5fZG9GcmFnTG9hZChmcmFnbWVudCwgbGV2ZWwsIHRhcmdldEJ1ZmZlclRpbWUsIHByb2dyZXNzQ2FsbGJhY2spLnRoZW4oZGF0YSA9PiB7XG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgLy8gaWYgd2UncmUgaGVyZSB3ZSBwcm9iYWJseSBuZWVkZWQgdG8gYmFja3RyYWNrIG9yIGFyZSB3YWl0aW5nIGZvciBtb3JlIHBhcnRzXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgIGNvbnN0IGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgICBpZiAodGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgICAgaWYgKHN0YXRlID09PSBTdGF0ZS5GUkFHX0xPQURJTkcgfHwgIXRoaXMuZnJhZ0N1cnJlbnQgJiYgc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoJ3BheWxvYWQnIGluIGRhdGEpIHtcbiAgICAgICAgdGhpcy5sb2coYExvYWRlZCAke2ZyYWcudHlwZX0gc246ICR7ZnJhZy5zbn0gb2YgJHt0aGlzLnBsYXlsaXN0TGFiZWwoKX0gJHtmcmFnLmxldmVsfWApO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0xPQURFRCwgZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFBhc3MgdGhyb3VnaCB0aGUgd2hvbGUgcGF5bG9hZDsgY29udHJvbGxlcnMgbm90IGltcGxlbWVudGluZyBwcm9ncmVzc2l2ZSBsb2FkaW5nIHJlY2VpdmUgZGF0YSBmcm9tIHRoaXMgY2FsbGJhY2tcbiAgICAgIHRoaXMuX2hhbmRsZUZyYWdtZW50TG9hZENvbXBsZXRlKGRhdGEpO1xuICAgIH0pLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuU1RPUFBFRCB8fCB0aGlzLnN0YXRlID09PSBTdGF0ZS5FUlJPUikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLndhcm4oYEZyYWcgZXJyb3I6ICR7KHJlYXNvbiA9PSBudWxsID8gdm9pZCAwIDogcmVhc29uLm1lc3NhZ2UpIHx8IHJlYXNvbn1gKTtcbiAgICAgIHRoaXMucmVzZXRGcmFnbWVudExvYWRpbmcoZnJhZ21lbnQpO1xuICAgIH0pO1xuICB9XG4gIGNsZWFyVHJhY2tlcklmTmVlZGVkKGZyYWcpIHtcbiAgICB2YXIgX3RoaXMkbWVkaWFCdWZmZXI7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZ21lbnRUcmFja2VyXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgZnJhZ1N0YXRlID0gZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGZyYWcpO1xuICAgIGlmIChmcmFnU3RhdGUgPT09IEZyYWdtZW50U3RhdGUuQVBQRU5ESU5HKSB7XG4gICAgICAvLyBMb3dlciB0aGUgbWF4IGJ1ZmZlciBsZW5ndGggYW5kIHRyeSBhZ2FpblxuICAgICAgY29uc3QgcGxheWxpc3RUeXBlID0gZnJhZy50eXBlO1xuICAgICAgY29uc3QgYnVmZmVyZWRJbmZvID0gdGhpcy5nZXRGd2RCdWZmZXJJbmZvKHRoaXMubWVkaWFCdWZmZXIsIHBsYXlsaXN0VHlwZSk7XG4gICAgICBjb25zdCBtaW5Gb3J3YXJkQnVmZmVyTGVuZ3RoID0gTWF0aC5tYXgoZnJhZy5kdXJhdGlvbiwgYnVmZmVyZWRJbmZvID8gYnVmZmVyZWRJbmZvLmxlbiA6IHRoaXMuY29uZmlnLm1heEJ1ZmZlckxlbmd0aCk7XG4gICAgICAvLyBJZiBiYWNrdHJhY2tpbmcsIGFsd2F5cyByZW1vdmUgZnJvbSB0aGUgdHJhY2tlciB3aXRob3V0IHJlZHVjaW5nIG1heCBidWZmZXIgbGVuZ3RoXG4gICAgICBjb25zdCBiYWNrdHJhY2tGcmFnbWVudCA9IHRoaXMuYmFja3RyYWNrRnJhZ21lbnQ7XG4gICAgICBjb25zdCBiYWNrdHJhY2tlZCA9IGJhY2t0cmFja0ZyYWdtZW50ID8gZnJhZy5zbiAtIGJhY2t0cmFja0ZyYWdtZW50LnNuIDogMDtcbiAgICAgIGlmIChiYWNrdHJhY2tlZCA9PT0gMSB8fCB0aGlzLnJlZHVjZU1heEJ1ZmZlckxlbmd0aChtaW5Gb3J3YXJkQnVmZmVyTGVuZ3RoLCBmcmFnLmR1cmF0aW9uKSkge1xuICAgICAgICBmcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgoKF90aGlzJG1lZGlhQnVmZmVyID0gdGhpcy5tZWRpYUJ1ZmZlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG1lZGlhQnVmZmVyLmJ1ZmZlcmVkLmxlbmd0aCkgPT09IDApIHtcbiAgICAgIC8vIFN0b3AgZ2FwIGZvciBiYWQgdHJhY2tlciAvIGJ1ZmZlciBmbHVzaCBiZWhhdmlvclxuICAgICAgZnJhZ21lbnRUcmFja2VyLnJlbW92ZUFsbEZyYWdtZW50cygpO1xuICAgIH0gZWxzZSBpZiAoZnJhZ21lbnRUcmFja2VyLmhhc1BhcnRzKGZyYWcudHlwZSkpIHtcbiAgICAgIC8vIEluIGxvdyBsYXRlbmN5IG1vZGUsIHJlbW92ZSBmcmFnbWVudHMgZm9yIHdoaWNoIG9ubHkgc29tZSBwYXJ0cyB3ZXJlIGJ1ZmZlcmVkXG4gICAgICBmcmFnbWVudFRyYWNrZXIuZGV0ZWN0UGFydGlhbEZyYWdtZW50cyh7XG4gICAgICAgIGZyYWcsXG4gICAgICAgIHBhcnQ6IG51bGwsXG4gICAgICAgIHN0YXRzOiBmcmFnLnN0YXRzLFxuICAgICAgICBpZDogZnJhZy50eXBlXG4gICAgICB9KTtcbiAgICAgIGlmIChmcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZykgPT09IEZyYWdtZW50U3RhdGUuUEFSVElBTCkge1xuICAgICAgICBmcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNoZWNrTGl2ZVVwZGF0ZShkZXRhaWxzKSB7XG4gICAgaWYgKGRldGFpbHMudXBkYXRlZCAmJiAhZGV0YWlscy5saXZlKSB7XG4gICAgICAvLyBMaXZlIHN0cmVhbSBlbmRlZCwgdXBkYXRlIGZyYWdtZW50IHRyYWNrZXJcbiAgICAgIGNvbnN0IGxhc3RGcmFnbWVudCA9IGRldGFpbHMuZnJhZ21lbnRzW2RldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIuZGV0ZWN0UGFydGlhbEZyYWdtZW50cyh7XG4gICAgICAgIGZyYWc6IGxhc3RGcmFnbWVudCxcbiAgICAgICAgcGFydDogbnVsbCxcbiAgICAgICAgc3RhdHM6IGxhc3RGcmFnbWVudC5zdGF0cyxcbiAgICAgICAgaWQ6IGxhc3RGcmFnbWVudC50eXBlXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFkZXRhaWxzLmZyYWdtZW50c1swXSkge1xuICAgICAgZGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIHdhaXRGb3JMaXZlKGxldmVsSW5mbykge1xuICAgIGNvbnN0IGRldGFpbHMgPSBsZXZlbEluZm8uZGV0YWlscztcbiAgICByZXR1cm4gKGRldGFpbHMgPT0gbnVsbCA/IHZvaWQgMCA6IGRldGFpbHMubGl2ZSkgJiYgZGV0YWlscy50eXBlICE9PSAnRVZFTlQnICYmICh0aGlzLmxldmVsTGFzdExvYWRlZCAhPT0gbGV2ZWxJbmZvIHx8IGRldGFpbHMuZXhwaXJlZCk7XG4gIH1cbiAgZmx1c2hNYWluQnVmZmVyKHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQsIHR5cGUgPSBudWxsKSB7XG4gICAgaWYgKCEoc3RhcnRPZmZzZXQgLSBlbmRPZmZzZXQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFdoZW4gYWx0ZXJuYXRlIGF1ZGlvIGlzIHBsYXlpbmcsIHRoZSBhdWRpby1zdHJlYW0tY29udHJvbGxlciBpcyByZXNwb25zaWJsZSBmb3IgdGhlIGF1ZGlvIGJ1ZmZlci4gT3RoZXJ3aXNlLFxuICAgIC8vIHBhc3NpbmcgYSBudWxsIHR5cGUgZmx1c2hlcyBib3RoIGJ1ZmZlcnNcbiAgICBjb25zdCBmbHVzaFNjb3BlID0ge1xuICAgICAgc3RhcnRPZmZzZXQsXG4gICAgICBlbmRPZmZzZXQsXG4gICAgICB0eXBlXG4gICAgfTtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIGZsdXNoU2NvcGUpO1xuICB9XG4gIF9sb2FkSW5pdFNlZ21lbnQoZnJhZ21lbnQsIGxldmVsKSB7XG4gICAgdGhpcy5fZG9GcmFnTG9hZChmcmFnbWVudCwgbGV2ZWwpLnRoZW4oZGF0YSA9PiB7XG4gICAgICBjb25zdCBmcmFnID0gZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5mcmFnO1xuICAgICAgaWYgKCFmcmFnIHx8IHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpIHx8ICF0aGlzLmxldmVscykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luaXQgbG9hZCBhYm9ydGVkJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9KS50aGVuKGRhdGEgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBobHNcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBmcmFnLFxuICAgICAgICBwYXlsb2FkXG4gICAgICB9ID0gZGF0YTtcbiAgICAgIGNvbnN0IGRlY3J5cHREYXRhID0gZnJhZy5kZWNyeXB0ZGF0YTtcblxuICAgICAgLy8gY2hlY2sgdG8gc2VlIGlmIHRoZSBwYXlsb2FkIG5lZWRzIHRvIGJlIGRlY3J5cHRlZFxuICAgICAgaWYgKHBheWxvYWQgJiYgcGF5bG9hZC5ieXRlTGVuZ3RoID4gMCAmJiBkZWNyeXB0RGF0YSAhPSBudWxsICYmIGRlY3J5cHREYXRhLmtleSAmJiBkZWNyeXB0RGF0YS5pdiAmJiBpc0Z1bGxTZWdtZW50RW5jcnlwdGlvbihkZWNyeXB0RGF0YS5tZXRob2QpKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIC8vIGRlY3J5cHQgaW5pdCBzZWdtZW50IGRhdGFcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdGVyLmRlY3J5cHQobmV3IFVpbnQ4QXJyYXkocGF5bG9hZCksIGRlY3J5cHREYXRhLmtleS5idWZmZXIsIGRlY3J5cHREYXRhLml2LmJ1ZmZlciwgZ2V0QWVzTW9kZUZyb21GdWxsU2VnbWVudE1ldGhvZChkZWNyeXB0RGF0YS5tZXRob2QpKS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0RFQ1JZUFRfRVJST1IsXG4gICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogZXJyLFxuICAgICAgICAgICAgcmVhc29uOiBlcnIubWVzc2FnZSxcbiAgICAgICAgICAgIGZyYWdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0pLnRoZW4oZGVjcnlwdGVkRGF0YSA9PiB7XG4gICAgICAgICAgY29uc3QgZW5kVGltZSA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfREVDUllQVEVELCB7XG4gICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgcGF5bG9hZDogZGVjcnlwdGVkRGF0YSxcbiAgICAgICAgICAgIHN0YXRzOiB7XG4gICAgICAgICAgICAgIHRzdGFydDogc3RhcnRUaW1lLFxuICAgICAgICAgICAgICB0ZGVjcnlwdDogZW5kVGltZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGRhdGEucGF5bG9hZCA9IGRlY3J5cHRlZERhdGE7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGVJbml0U2VnbWVudExvYWQoZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGVJbml0U2VnbWVudExvYWQoZGF0YSk7XG4gICAgfSkuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5TVE9QUEVEIHx8IHRoaXMuc3RhdGUgPT09IFN0YXRlLkVSUk9SKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMud2FybihyZWFzb24pO1xuICAgICAgdGhpcy5yZXNldEZyYWdtZW50TG9hZGluZyhmcmFnbWVudCk7XG4gICAgfSk7XG4gIH1cbiAgY29tcGxldGVJbml0U2VnbWVudExvYWQoZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxldmVsc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmICghbGV2ZWxzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luaXQgbG9hZCBhYm9ydGVkLCBtaXNzaW5nIGxldmVscycpO1xuICAgIH1cbiAgICBjb25zdCBzdGF0cyA9IGRhdGEuZnJhZy5zdGF0cztcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU3RhdGUuU1RPUFBFRCkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgfVxuICAgIGRhdGEuZnJhZy5kYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5wYXlsb2FkKTtcbiAgICBzdGF0cy5wYXJzaW5nLnN0YXJ0ID0gc3RhdHMuYnVmZmVyaW5nLnN0YXJ0ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICBzdGF0cy5wYXJzaW5nLmVuZCA9IHN0YXRzLmJ1ZmZlcmluZy5lbmQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHRoaXMudGljaygpO1xuICB9XG4gIGZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZ0N1cnJlbnRcbiAgICB9ID0gdGhpcztcbiAgICByZXR1cm4gIWZyYWcgfHwgIWZyYWdDdXJyZW50IHx8IGZyYWcuc24gIT09IGZyYWdDdXJyZW50LnNuIHx8IGZyYWcubGV2ZWwgIT09IGZyYWdDdXJyZW50LmxldmVsO1xuICB9XG4gIGZyYWdCdWZmZXJlZENvbXBsZXRlKGZyYWcsIHBhcnQpIHtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogdGhpcy5tZWRpYTtcbiAgICB0aGlzLmxvZyhgQnVmZmVyZWQgJHtmcmFnLnR5cGV9IHNuOiAke2ZyYWcuc259JHtwYXJ0ID8gJyBwYXJ0OiAnICsgcGFydC5pbmRleCA6ICcnfSBvZiAke3RoaXMuZnJhZ0luZm8oZnJhZywgZmFsc2UsIHBhcnQpfSA+IGJ1ZmZlcjoke21lZGlhID8gVGltZVJhbmdlcy50b1N0cmluZyhCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQobWVkaWEpKSA6ICcoZGV0YWNoZWQpJ30pYCk7XG4gICAgaWYgKGlzTWVkaWFGcmFnbWVudChmcmFnKSkge1xuICAgICAgdmFyIF90aGlzJGxldmVscztcbiAgICAgIGlmIChmcmFnLnR5cGUgIT09IFBsYXlsaXN0TGV2ZWxUeXBlLlNVQlRJVExFKSB7XG4gICAgICAgIGNvbnN0IGVsID0gZnJhZy5lbGVtZW50YXJ5U3RyZWFtcztcbiAgICAgICAgaWYgKCFPYmplY3Qua2V5cyhlbCkuc29tZSh0eXBlID0+ICEhZWxbdHlwZV0pKSB7XG4gICAgICAgICAgLy8gZW1wdHkgc2VnbWVudFxuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgbGV2ZWwgPSAoX3RoaXMkbGV2ZWxzID0gdGhpcy5sZXZlbHMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRsZXZlbHNbZnJhZy5sZXZlbF07XG4gICAgICBpZiAobGV2ZWwgIT0gbnVsbCAmJiBsZXZlbC5mcmFnbWVudEVycm9yKSB7XG4gICAgICAgIHRoaXMubG9nKGBSZXNldHRpbmcgbGV2ZWwgZnJhZ21lbnQgZXJyb3IgY291bnQgb2YgJHtsZXZlbC5mcmFnbWVudEVycm9yfSBvbiBmcmFnIGJ1ZmZlcmVkYCk7XG4gICAgICAgIGxldmVsLmZyYWdtZW50RXJyb3IgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgfVxuICBfaGFuZGxlRnJhZ21lbnRMb2FkQ29tcGxldGUoZnJhZ0xvYWRlZEVuZERhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICB0cmFuc211eGVyXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCF0cmFuc211eGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGZyYWcsXG4gICAgICBwYXJ0LFxuICAgICAgcGFydHNMb2FkZWRcbiAgICB9ID0gZnJhZ0xvYWRlZEVuZERhdGE7XG4gICAgLy8gSWYgd2UgZGlkIG5vdCBsb2FkIHBhcnRzLCBvciBsb2FkZWQgYWxsIHBhcnRzLCB3ZSBoYXZlIGNvbXBsZXRlIChub3QgcGFydGlhbCkgZnJhZ21lbnQgZGF0YVxuICAgIGNvbnN0IGNvbXBsZXRlID0gIXBhcnRzTG9hZGVkIHx8IHBhcnRzTG9hZGVkLmxlbmd0aCA9PT0gMCB8fCBwYXJ0c0xvYWRlZC5zb21lKGZyYWdMb2FkZWQgPT4gIWZyYWdMb2FkZWQpO1xuICAgIGNvbnN0IGNodW5rTWV0YSA9IG5ldyBDaHVua01ldGFkYXRhKGZyYWcubGV2ZWwsIGZyYWcuc24sIGZyYWcuc3RhdHMuY2h1bmtDb3VudCArIDEsIDAsIHBhcnQgPyBwYXJ0LmluZGV4IDogLTEsICFjb21wbGV0ZSk7XG4gICAgdHJhbnNtdXhlci5mbHVzaChjaHVua01ldGEpO1xuICB9XG4gIF9oYW5kbGVGcmFnbWVudExvYWRQcm9ncmVzcyhmcmFnKSB7fVxuICBfZG9GcmFnTG9hZChmcmFnLCBsZXZlbCwgdGFyZ2V0QnVmZmVyVGltZSA9IG51bGwsIHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICB2YXIgX2ZyYWckZGVjcnlwdGRhdGE7XG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IGZyYWc7XG4gICAgY29uc3QgZGV0YWlscyA9IGxldmVsID09IG51bGwgPyB2b2lkIDAgOiBsZXZlbC5kZXRhaWxzO1xuICAgIGlmICghdGhpcy5sZXZlbHMgfHwgIWRldGFpbHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgZnJhZyBsb2FkIGFib3J0ZWQsIG1pc3NpbmcgbGV2ZWwke2RldGFpbHMgPyAnJyA6ICcgZGV0YWlsJ31zYCk7XG4gICAgfVxuICAgIGxldCBrZXlMb2FkaW5nUHJvbWlzZSA9IG51bGw7XG4gICAgaWYgKGZyYWcuZW5jcnlwdGVkICYmICEoKF9mcmFnJGRlY3J5cHRkYXRhID0gZnJhZy5kZWNyeXB0ZGF0YSkgIT0gbnVsbCAmJiBfZnJhZyRkZWNyeXB0ZGF0YS5rZXkpKSB7XG4gICAgICB0aGlzLmxvZyhgTG9hZGluZyBrZXkgZm9yICR7ZnJhZy5zbn0gb2YgWyR7ZGV0YWlscy5zdGFydFNOfS0ke2RldGFpbHMuZW5kU059XSwgJHt0aGlzLnBsYXlsaXN0TGFiZWwoKX0gJHtmcmFnLmxldmVsfWApO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLktFWV9MT0FESU5HO1xuICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IGZyYWc7XG4gICAgICBrZXlMb2FkaW5nUHJvbWlzZSA9IHRoaXMua2V5TG9hZGVyLmxvYWQoZnJhZykudGhlbihrZXlMb2FkZWREYXRhID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChrZXlMb2FkZWREYXRhLmZyYWcpKSB7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuS0VZX0xPQURFRCwga2V5TG9hZGVkRGF0YSk7XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLktFWV9MT0FESU5HKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGtleUxvYWRlZERhdGE7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuS0VZX0xPQURJTkcsIHtcbiAgICAgICAgZnJhZ1xuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5mcmFnQ3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICBrZXlMb2FkaW5nUHJvbWlzZSA9IFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgZnJhZyBsb2FkIGFib3J0ZWQsIGNvbnRleHQgY2hhbmdlZCBpbiBLRVlfTE9BRElOR2ApKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFmcmFnLmVuY3J5cHRlZCkge1xuICAgICAga2V5TG9hZGluZ1Byb21pc2UgPSB0aGlzLmtleUxvYWRlci5sb2FkQ2xlYXIoZnJhZywgZGV0YWlscy5lbmNyeXB0ZWRGcmFnbWVudHMsIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkKTtcbiAgICAgIGlmIChrZXlMb2FkaW5nUHJvbWlzZSkge1xuICAgICAgICB0aGlzLmxvZyhgW2VtZV0gYmxvY2tpbmcgZnJhZyBsb2FkIHVudGlsIG1lZGlhLWtleXMgYWNxdWlyZWRgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZnJhZ1ByZXZpb3VzID0gdGhpcy5mcmFnUHJldmlvdXM7XG4gICAgaWYgKGlzTWVkaWFGcmFnbWVudChmcmFnKSAmJiAoIWZyYWdQcmV2aW91cyB8fCBmcmFnLnNuICE9PSBmcmFnUHJldmlvdXMuc24pKSB7XG4gICAgICBjb25zdCBzaG91bGRMb2FkUGFydHMgPSB0aGlzLnNob3VsZExvYWRQYXJ0cyhsZXZlbC5kZXRhaWxzLCBmcmFnLmVuZCk7XG4gICAgICBpZiAoc2hvdWxkTG9hZFBhcnRzICE9PSB0aGlzLmxvYWRpbmdQYXJ0cykge1xuICAgICAgICB0aGlzLmxvZyhgTEwtUGFydCBsb2FkaW5nICR7c2hvdWxkTG9hZFBhcnRzID8gJ09OJyA6ICdPRkYnfSBsb2FkaW5nIHNuICR7ZnJhZ1ByZXZpb3VzID09IG51bGwgPyB2b2lkIDAgOiBmcmFnUHJldmlvdXMuc259LT4ke2ZyYWcuc259YCk7XG4gICAgICAgIHRoaXMubG9hZGluZ1BhcnRzID0gc2hvdWxkTG9hZFBhcnRzO1xuICAgICAgfVxuICAgIH1cbiAgICB0YXJnZXRCdWZmZXJUaW1lID0gTWF0aC5tYXgoZnJhZy5zdGFydCwgdGFyZ2V0QnVmZmVyVGltZSB8fCAwKTtcbiAgICBpZiAodGhpcy5sb2FkaW5nUGFydHMgJiYgaXNNZWRpYUZyYWdtZW50KGZyYWcpKSB7XG4gICAgICBjb25zdCBwYXJ0TGlzdCA9IGRldGFpbHMucGFydExpc3Q7XG4gICAgICBpZiAocGFydExpc3QgJiYgcHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgICAgICBpZiAodGFyZ2V0QnVmZmVyVGltZSA+IGZyYWcuZW5kICYmIGRldGFpbHMuZnJhZ21lbnRIaW50KSB7XG4gICAgICAgICAgZnJhZyA9IGRldGFpbHMuZnJhZ21lbnRIaW50O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnRJbmRleCA9IHRoaXMuZ2V0TmV4dFBhcnQocGFydExpc3QsIGZyYWcsIHRhcmdldEJ1ZmZlclRpbWUpO1xuICAgICAgICBpZiAocGFydEluZGV4ID4gLTEpIHtcbiAgICAgICAgICBjb25zdCBwYXJ0ID0gcGFydExpc3RbcGFydEluZGV4XTtcbiAgICAgICAgICBmcmFnID0gdGhpcy5mcmFnQ3VycmVudCA9IHBhcnQuZnJhZ21lbnQ7XG4gICAgICAgICAgdGhpcy5sb2coYExvYWRpbmcgJHtmcmFnLnR5cGV9IHNuOiAke2ZyYWcuc259IHBhcnQ6ICR7cGFydC5pbmRleH0gKCR7cGFydEluZGV4fS8ke3BhcnRMaXN0Lmxlbmd0aCAtIDF9KSBvZiAke3RoaXMuZnJhZ0luZm8oZnJhZywgZmFsc2UsIHBhcnQpfSkgY2M6ICR7ZnJhZy5jY30gWyR7ZGV0YWlscy5zdGFydFNOfS0ke2RldGFpbHMuZW5kU059XSwgdGFyZ2V0OiAke3BhcnNlRmxvYXQodGFyZ2V0QnVmZmVyVGltZS50b0ZpeGVkKDMpKX1gKTtcbiAgICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBwYXJ0LnN0YXJ0ICsgcGFydC5kdXJhdGlvbjtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HO1xuICAgICAgICAgIGxldCBfcmVzdWx0O1xuICAgICAgICAgIGlmIChrZXlMb2FkaW5nUHJvbWlzZSkge1xuICAgICAgICAgICAgX3Jlc3VsdCA9IGtleUxvYWRpbmdQcm9taXNlLnRoZW4oa2V5TG9hZGVkRGF0YSA9PiB7XG4gICAgICAgICAgICAgIGlmICgha2V5TG9hZGVkRGF0YSB8fCB0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChrZXlMb2FkZWREYXRhLmZyYWcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9GcmFnUGFydHNMb2FkKGZyYWcsIHBhcnQsIGxldmVsLCBwcm9ncmVzc0NhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHRoaXMuaGFuZGxlRnJhZ0xvYWRFcnJvcihlcnJvcikpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfcmVzdWx0ID0gdGhpcy5kb0ZyYWdQYXJ0c0xvYWQoZnJhZywgcGFydCwgbGV2ZWwsIHByb2dyZXNzQ2FsbGJhY2spLmNhdGNoKGVycm9yID0+IHRoaXMuaGFuZGxlRnJhZ0xvYWRFcnJvcihlcnJvcikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0xPQURJTkcsIHtcbiAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgdGFyZ2V0QnVmZmVyVGltZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICh0aGlzLmZyYWdDdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBmcmFnIGxvYWQgYWJvcnRlZCwgY29udGV4dCBjaGFuZ2VkIGluIEZSQUdfTE9BRElORyBwYXJ0c2ApKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9yZXN1bHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoIWZyYWcudXJsIHx8IHRoaXMubG9hZGVkRW5kT2ZQYXJ0cyhwYXJ0TGlzdCwgdGFyZ2V0QnVmZmVyVGltZSkpIHtcbiAgICAgICAgICAvLyBGcmFnbWVudCBoaW50IGhhcyBubyBwYXJ0c1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzTWVkaWFGcmFnbWVudChmcmFnKSAmJiB0aGlzLmxvYWRpbmdQYXJ0cykge1xuICAgICAgdGhpcy5sb2coYExMLVBhcnQgbG9hZGluZyBPRkYgYWZ0ZXIgbmV4dCBwYXJ0IG1pc3MgQCR7dGFyZ2V0QnVmZmVyVGltZS50b0ZpeGVkKDIpfWApO1xuICAgICAgdGhpcy5sb2FkaW5nUGFydHMgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKCFmcmFnLnVybCkge1xuICAgICAgLy8gU2VsZWN0ZWQgZnJhZ21lbnQgaGludCBmb3IgcGFydCBidXQgbm90IGxvYWRpbmcgcGFydHNcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgfVxuICAgIHRoaXMubG9nKGBMb2FkaW5nICR7ZnJhZy50eXBlfSBzbjogJHtmcmFnLnNufSBvZiAke3RoaXMuZnJhZ0luZm8oZnJhZywgZmFsc2UpfSkgY2M6ICR7ZnJhZy5jY30gJHtkZXRhaWxzID8gJ1snICsgZGV0YWlscy5zdGFydFNOICsgJy0nICsgZGV0YWlscy5lbmRTTiArICddJyA6ICcnfSwgdGFyZ2V0OiAke3BhcnNlRmxvYXQodGFyZ2V0QnVmZmVyVGltZS50b0ZpeGVkKDMpKX1gKTtcbiAgICAvLyBEb24ndCB1cGRhdGUgbmV4dExvYWRQb3NpdGlvbiBmb3IgZnJhZ21lbnRzIHdoaWNoIGFyZSBub3QgYnVmZmVyZWRcbiAgICBpZiAoaXNGaW5pdGVOdW1iZXIoZnJhZy5zbikgJiYgIXRoaXMuYml0cmF0ZVRlc3QpIHtcbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IGZyYWcuc3RhcnQgKyBmcmFnLmR1cmF0aW9uO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HO1xuXG4gICAgLy8gTG9hZCBrZXkgYmVmb3JlIHN0cmVhbWluZyBmcmFnbWVudCBkYXRhXG4gICAgY29uc3QgZGF0YU9uUHJvZ3Jlc3MgPSB0aGlzLmNvbmZpZy5wcm9ncmVzc2l2ZTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmIChkYXRhT25Qcm9ncmVzcyAmJiBrZXlMb2FkaW5nUHJvbWlzZSkge1xuICAgICAgcmVzdWx0ID0ga2V5TG9hZGluZ1Byb21pc2UudGhlbihrZXlMb2FkZWREYXRhID0+IHtcbiAgICAgICAgaWYgKCFrZXlMb2FkZWREYXRhIHx8IHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGtleUxvYWRlZERhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGtleUxvYWRlZERhdGEuZnJhZykpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5mcmFnbWVudExvYWRlci5sb2FkKGZyYWcsIHByb2dyZXNzQ2FsbGJhY2spO1xuICAgICAgfSkuY2F0Y2goZXJyb3IgPT4gdGhpcy5oYW5kbGVGcmFnTG9hZEVycm9yKGVycm9yKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxvYWQgdW5lbmNyeXB0ZWQgZnJhZ21lbnQgZGF0YSB3aXRoIHByb2dyZXNzIGV2ZW50LFxuICAgICAgLy8gb3IgaGFuZGxlIGZyYWdtZW50IHJlc3VsdCBhZnRlciBrZXkgYW5kIGZyYWdtZW50IGFyZSBmaW5pc2hlZCBsb2FkaW5nXG4gICAgICByZXN1bHQgPSBQcm9taXNlLmFsbChbdGhpcy5mcmFnbWVudExvYWRlci5sb2FkKGZyYWcsIGRhdGFPblByb2dyZXNzID8gcHJvZ3Jlc3NDYWxsYmFjayA6IHVuZGVmaW5lZCksIGtleUxvYWRpbmdQcm9taXNlXSkudGhlbigoW2ZyYWdMb2FkZWREYXRhXSkgPT4ge1xuICAgICAgICBpZiAoIWRhdGFPblByb2dyZXNzICYmIGZyYWdMb2FkZWREYXRhICYmIHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICAgICAgICBwcm9ncmVzc0NhbGxiYWNrKGZyYWdMb2FkZWREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJhZ0xvYWRlZERhdGE7XG4gICAgICB9KS5jYXRjaChlcnJvciA9PiB0aGlzLmhhbmRsZUZyYWdMb2FkRXJyb3IoZXJyb3IpKTtcbiAgICB9XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRlJBR19MT0FESU5HLCB7XG4gICAgICBmcmFnLFxuICAgICAgdGFyZ2V0QnVmZmVyVGltZVxuICAgIH0pO1xuICAgIGlmICh0aGlzLmZyYWdDdXJyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBmcmFnIGxvYWQgYWJvcnRlZCwgY29udGV4dCBjaGFuZ2VkIGluIEZSQUdfTE9BRElOR2ApKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkb0ZyYWdQYXJ0c0xvYWQoZnJhZywgZnJvbVBhcnQsIGxldmVsLCBwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHZhciBfbGV2ZWwkZGV0YWlscztcbiAgICAgIGNvbnN0IHBhcnRzTG9hZGVkID0gW107XG4gICAgICBjb25zdCBpbml0aWFsUGFydExpc3QgPSAoX2xldmVsJGRldGFpbHMgPSBsZXZlbC5kZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX2xldmVsJGRldGFpbHMucGFydExpc3Q7XG4gICAgICBjb25zdCBsb2FkUGFydCA9IHBhcnQgPT4ge1xuICAgICAgICB0aGlzLmZyYWdtZW50TG9hZGVyLmxvYWRQYXJ0KGZyYWcsIHBhcnQsIHByb2dyZXNzQ2FsbGJhY2spLnRoZW4ocGFydExvYWRlZERhdGEgPT4ge1xuICAgICAgICAgIHBhcnRzTG9hZGVkW3BhcnQuaW5kZXhdID0gcGFydExvYWRlZERhdGE7XG4gICAgICAgICAgY29uc3QgbG9hZGVkUGFydCA9IHBhcnRMb2FkZWREYXRhLnBhcnQ7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRlJBR19MT0FERUQsIHBhcnRMb2FkZWREYXRhKTtcbiAgICAgICAgICBjb25zdCBuZXh0UGFydCA9IGdldFBhcnRXaXRoKGxldmVsLmRldGFpbHMsIGZyYWcuc24sIHBhcnQuaW5kZXggKyAxKSB8fCBmaW5kUGFydChpbml0aWFsUGFydExpc3QsIGZyYWcuc24sIHBhcnQuaW5kZXggKyAxKTtcbiAgICAgICAgICBpZiAobmV4dFBhcnQpIHtcbiAgICAgICAgICAgIGxvYWRQYXJ0KG5leHRQYXJ0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoe1xuICAgICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgICBwYXJ0OiBsb2FkZWRQYXJ0LFxuICAgICAgICAgICAgICBwYXJ0c0xvYWRlZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xuICAgICAgfTtcbiAgICAgIGxvYWRQYXJ0KGZyb21QYXJ0KTtcbiAgICB9KTtcbiAgfVxuICBoYW5kbGVGcmFnTG9hZEVycm9yKGVycm9yKSB7XG4gICAgaWYgKCdkYXRhJyBpbiBlcnJvcikge1xuICAgICAgY29uc3QgZGF0YSA9IGVycm9yLmRhdGE7XG4gICAgICBpZiAoZXJyb3IuZGF0YSAmJiBkYXRhLmRldGFpbHMgPT09IEVycm9yRGV0YWlscy5JTlRFUk5BTF9BQk9SVEVEKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRnJhZ0xvYWRBYm9ydGVkKGRhdGEuZnJhZywgZGF0YS5wYXJ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCBkYXRhKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5PVEhFUl9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLklOVEVSTkFMX0VYQ0VQVElPTixcbiAgICAgICAgZXJyOiBlcnJvcixcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgX2hhbmRsZVRyYW5zbXV4ZXJGbHVzaChjaHVua01ldGEpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5nZXRDdXJyZW50Q29udGV4dChjaHVua01ldGEpO1xuICAgIGlmICghY29udGV4dCB8fCB0aGlzLnN0YXRlICE9PSBTdGF0ZS5QQVJTSU5HKSB7XG4gICAgICBpZiAoIXRoaXMuZnJhZ0N1cnJlbnQgJiYgdGhpcy5zdGF0ZSAhPT0gU3RhdGUuU1RPUFBFRCAmJiB0aGlzLnN0YXRlICE9PSBTdGF0ZS5FUlJPUikge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIHBhcnQsXG4gICAgICBsZXZlbFxuICAgIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgZnJhZy5zdGF0cy5wYXJzaW5nLmVuZCA9IG5vdztcbiAgICBpZiAocGFydCkge1xuICAgICAgcGFydC5zdGF0cy5wYXJzaW5nLmVuZCA9IG5vdztcbiAgICB9XG4gICAgLy8gU2VlIGlmIHBhcnQgbG9hZGluZyBzaG91bGQgYmUgZGlzYWJsZWQvZW5hYmxlZCBiYXNlZCBvbiBidWZmZXIgYW5kIHBsYXliYWNrIHBvc2l0aW9uLlxuICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IHRoaXMuZ2V0TGV2ZWxEZXRhaWxzKCk7XG4gICAgY29uc3QgbG9hZGluZ1BhcnRzQXRFZGdlID0gbGV2ZWxEZXRhaWxzICYmIGZyYWcuc24gPiBsZXZlbERldGFpbHMuZW5kU047XG4gICAgY29uc3Qgc2hvdWxkTG9hZFBhcnRzID0gbG9hZGluZ1BhcnRzQXRFZGdlIHx8IHRoaXMuc2hvdWxkTG9hZFBhcnRzKGxldmVsRGV0YWlscywgZnJhZy5lbmQpO1xuICAgIGlmIChzaG91bGRMb2FkUGFydHMgIT09IHRoaXMubG9hZGluZ1BhcnRzKSB7XG4gICAgICB0aGlzLmxvZyhgTEwtUGFydCBsb2FkaW5nICR7c2hvdWxkTG9hZFBhcnRzID8gJ09OJyA6ICdPRkYnfSBhZnRlciBwYXJzaW5nIHNlZ21lbnQgZW5kaW5nIEAke2ZyYWcuZW5kLnRvRml4ZWQoMil9YCk7XG4gICAgICB0aGlzLmxvYWRpbmdQYXJ0cyA9IHNob3VsZExvYWRQYXJ0cztcbiAgICB9XG4gICAgdGhpcy51cGRhdGVMZXZlbFRpbWluZyhmcmFnLCBwYXJ0LCBsZXZlbCwgY2h1bmtNZXRhLnBhcnRpYWwpO1xuICB9XG4gIHNob3VsZExvYWRQYXJ0cyhkZXRhaWxzLCBidWZmZXJFbmQpIHtcbiAgICBpZiAodGhpcy5jb25maWcubG93TGF0ZW5jeU1vZGUpIHtcbiAgICAgIGlmICghZGV0YWlscykge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkaW5nUGFydHM7XG4gICAgICB9XG4gICAgICBpZiAoZGV0YWlscyAhPSBudWxsICYmIGRldGFpbHMucGFydExpc3QpIHtcbiAgICAgICAgdmFyIF9kZXRhaWxzJGZyYWdtZW50SGludDtcbiAgICAgICAgLy8gQnVmZmVyIG11c3QgYmUgYWhlYWQgb2YgZmlyc3QgcGFydCArIGR1cmF0aW9uIG9mIHBhcnRzIGFmdGVyIGxhc3Qgc2VnbWVudFxuICAgICAgICAvLyBhbmQgcGxheWJhY2sgbXVzdCBiZSBhdCBvciBwYXN0IHNlZ21lbnQgYWRqYWNlbnQgdG8gcGFydCBsaXN0XG4gICAgICAgIGNvbnN0IGZpcnN0UGFydCA9IGRldGFpbHMucGFydExpc3RbMF07XG4gICAgICAgIGNvbnN0IHNhZmVQYXJ0U3RhcnQgPSBmaXJzdFBhcnQuZW5kICsgKCgoX2RldGFpbHMkZnJhZ21lbnRIaW50ID0gZGV0YWlscy5mcmFnbWVudEhpbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZGV0YWlscyRmcmFnbWVudEhpbnQuZHVyYXRpb24pIHx8IDApO1xuICAgICAgICBpZiAoYnVmZmVyRW5kID49IHNhZmVQYXJ0U3RhcnQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMkbWVkaWE7XG4gICAgICAgICAgY29uc3QgcGxheWhlYWQgPSB0aGlzLmhscy5oYXNFbm91Z2hUb1N0YXJ0ID8gKChfdGhpcyRtZWRpYSA9IHRoaXMubWVkaWEpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRtZWRpYS5jdXJyZW50VGltZSkgfHwgdGhpcy5sYXN0Q3VycmVudFRpbWUgOiB0aGlzLmdldExvYWRQb3NpdGlvbigpO1xuICAgICAgICAgIGlmIChwbGF5aGVhZCA+IGZpcnN0UGFydC5zdGFydCAtIGZpcnN0UGFydC5mcmFnbWVudC5kdXJhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBnZXRDdXJyZW50Q29udGV4dChjaHVua01ldGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBsZXZlbHMsXG4gICAgICBmcmFnQ3VycmVudFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIGxldmVsOiBsZXZlbEluZGV4LFxuICAgICAgc24sXG4gICAgICBwYXJ0OiBwYXJ0SW5kZXhcbiAgICB9ID0gY2h1bmtNZXRhO1xuICAgIGlmICghKGxldmVscyAhPSBudWxsICYmIGxldmVsc1tsZXZlbEluZGV4XSkpIHtcbiAgICAgIHRoaXMud2FybihgTGV2ZWxzIG9iamVjdCB3YXMgdW5zZXQgd2hpbGUgYnVmZmVyaW5nIGZyYWdtZW50ICR7c259IG9mICR7dGhpcy5wbGF5bGlzdExhYmVsKCl9ICR7bGV2ZWxJbmRleH0uIFRoZSBjdXJyZW50IGNodW5rIHdpbGwgbm90IGJlIGJ1ZmZlcmVkLmApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGxldmVsID0gbGV2ZWxzW2xldmVsSW5kZXhdO1xuICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IGxldmVsLmRldGFpbHM7XG4gICAgY29uc3QgcGFydCA9IHBhcnRJbmRleCA+IC0xID8gZ2V0UGFydFdpdGgobGV2ZWxEZXRhaWxzLCBzbiwgcGFydEluZGV4KSA6IG51bGw7XG4gICAgY29uc3QgZnJhZyA9IHBhcnQgPyBwYXJ0LmZyYWdtZW50IDogZ2V0RnJhZ21lbnRXaXRoU04obGV2ZWxEZXRhaWxzLCBzbiwgZnJhZ0N1cnJlbnQpO1xuICAgIGlmICghZnJhZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChmcmFnQ3VycmVudCAmJiBmcmFnQ3VycmVudCAhPT0gZnJhZykge1xuICAgICAgZnJhZy5zdGF0cyA9IGZyYWdDdXJyZW50LnN0YXRzO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZnJhZyxcbiAgICAgIHBhcnQsXG4gICAgICBsZXZlbFxuICAgIH07XG4gIH1cbiAgYnVmZmVyRnJhZ21lbnREYXRhKGRhdGEsIGZyYWcsIHBhcnQsIGNodW5rTWV0YSwgbm9CYWNrdHJhY2tpbmcpIHtcbiAgICB2YXIgX2J1ZmZlcjtcbiAgICBpZiAoIWRhdGEgfHwgdGhpcy5zdGF0ZSAhPT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBkYXRhMSxcbiAgICAgIGRhdGEyXG4gICAgfSA9IGRhdGE7XG4gICAgbGV0IGJ1ZmZlciA9IGRhdGExO1xuICAgIGlmIChkYXRhMSAmJiBkYXRhMikge1xuICAgICAgLy8gQ29tYmluZSB0aGUgbW9vZiArIG1kYXQgc28gdGhhdCB3ZSBidWZmZXIgd2l0aCBhIHNpbmdsZSBhcHBlbmRcbiAgICAgIGJ1ZmZlciA9IGFwcGVuZFVpbnQ4QXJyYXkoZGF0YTEsIGRhdGEyKTtcbiAgICB9XG4gICAgaWYgKCEoKF9idWZmZXIgPSBidWZmZXIpICE9IG51bGwgJiYgX2J1ZmZlci5sZW5ndGgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9mZnNldFRpbWVzdGFtcCA9IHRoaXMuaW5pdFBUU1tmcmFnLmNjXTtcbiAgICBjb25zdCBvZmZzZXQgPSBvZmZzZXRUaW1lc3RhbXAgPyAtb2Zmc2V0VGltZXN0YW1wLmJhc2VUaW1lIC8gb2Zmc2V0VGltZXN0YW1wLnRpbWVzY2FsZSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBzZWdtZW50ID0ge1xuICAgICAgdHlwZTogZGF0YS50eXBlLFxuICAgICAgZnJhZyxcbiAgICAgIHBhcnQsXG4gICAgICBjaHVua01ldGEsXG4gICAgICBvZmZzZXQsXG4gICAgICBwYXJlbnQ6IGZyYWcudHlwZSxcbiAgICAgIGRhdGE6IGJ1ZmZlclxuICAgIH07XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0FQUEVORElORywgc2VnbWVudCk7XG4gICAgaWYgKGRhdGEuZHJvcHBlZCAmJiBkYXRhLmluZGVwZW5kZW50ICYmICFwYXJ0KSB7XG4gICAgICBpZiAobm9CYWNrdHJhY2tpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gQ2xlYXIgYnVmZmVyIHNvIHRoYXQgd2UgcmVsb2FkIHByZXZpb3VzIHNlZ21lbnRzIHNlcXVlbnRpYWxseSBpZiByZXF1aXJlZFxuICAgICAgdGhpcy5mbHVzaEJ1ZmZlckdhcChmcmFnKTtcbiAgICB9XG4gIH1cbiAgZmx1c2hCdWZmZXJHYXAoZnJhZykge1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAoIW1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIElmIGN1cnJlbnRUaW1lIGlzIG5vdCBidWZmZXJlZCwgY2xlYXIgdGhlIGJhY2sgYnVmZmVyIHNvIHRoYXQgd2UgY2FuIGJhY2t0cmFjayBhcyBtdWNoIGFzIG5lZWRlZFxuICAgIGlmICghQnVmZmVySGVscGVyLmlzQnVmZmVyZWQobWVkaWEsIG1lZGlhLmN1cnJlbnRUaW1lKSkge1xuICAgICAgdGhpcy5mbHVzaE1haW5CdWZmZXIoMCwgZnJhZy5zdGFydCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFJlbW92ZSBiYWNrLWJ1ZmZlciB3aXRob3V0IGludGVycnVwdGluZyBwbGF5YmFjayB0byBhbGxvdyBiYWNrIHRyYWNraW5nXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICBjb25zdCBidWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8obWVkaWEsIGN1cnJlbnRUaW1lLCAwKTtcbiAgICBjb25zdCBmcmFnRHVyYXRpb24gPSBmcmFnLmR1cmF0aW9uO1xuICAgIGNvbnN0IHNlZ21lbnRGcmFjdGlvbiA9IE1hdGgubWluKHRoaXMuY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UgKiAyLCBmcmFnRHVyYXRpb24gKiAwLjI1KTtcbiAgICBjb25zdCBzdGFydCA9IE1hdGgubWF4KE1hdGgubWluKGZyYWcuc3RhcnQgLSBzZWdtZW50RnJhY3Rpb24sIGJ1ZmZlckluZm8uZW5kIC0gc2VnbWVudEZyYWN0aW9uKSwgY3VycmVudFRpbWUgKyBzZWdtZW50RnJhY3Rpb24pO1xuICAgIGlmIChmcmFnLnN0YXJ0IC0gc3RhcnQgPiBzZWdtZW50RnJhY3Rpb24pIHtcbiAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKHN0YXJ0LCBmcmFnLnN0YXJ0KTtcbiAgICB9XG4gIH1cbiAgZ2V0RndkQnVmZmVySW5mbyhidWZmZXJhYmxlLCB0eXBlKSB7XG4gICAgdmFyIF90aGlzJG1lZGlhMjtcbiAgICBjb25zdCBwb3MgPSB0aGlzLmdldExvYWRQb3NpdGlvbigpO1xuICAgIGlmICghaXNGaW5pdGVOdW1iZXIocG9zKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGJhY2t3YXJkU2VlayA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID4gcG9zO1xuICAgIGNvbnN0IG1heEJ1ZmZlckhvbGUgPSBiYWNrd2FyZFNlZWsgfHwgKF90aGlzJG1lZGlhMiA9IHRoaXMubWVkaWEpICE9IG51bGwgJiYgX3RoaXMkbWVkaWEyLnBhdXNlZCA/IDAgOiB0aGlzLmNvbmZpZy5tYXhCdWZmZXJIb2xlO1xuICAgIHJldHVybiB0aGlzLmdldEZ3ZEJ1ZmZlckluZm9BdFBvcyhidWZmZXJhYmxlLCBwb3MsIHR5cGUsIG1heEJ1ZmZlckhvbGUpO1xuICB9XG4gIGdldEZ3ZEJ1ZmZlckluZm9BdFBvcyhidWZmZXJhYmxlLCBwb3MsIHR5cGUsIG1heEJ1ZmZlckhvbGUpIHtcbiAgICBjb25zdCBidWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8oYnVmZmVyYWJsZSwgcG9zLCBtYXhCdWZmZXJIb2xlKTtcbiAgICAvLyBXb3JrYXJvdW5kIGZsYXcgaW4gZ2V0dGluZyBmb3J3YXJkIGJ1ZmZlciB3aGVuIG1heEJ1ZmZlckhvbGUgaXMgc21hbGxlciB0aGFuIGdhcCBhdCBjdXJyZW50IHBvc1xuICAgIGlmIChidWZmZXJJbmZvLmxlbiA9PT0gMCAmJiBidWZmZXJJbmZvLm5leHRTdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBidWZmZXJlZEZyYWdBdFBvcyA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldEJ1ZmZlcmVkRnJhZyhwb3MsIHR5cGUpO1xuICAgICAgaWYgKGJ1ZmZlcmVkRnJhZ0F0UG9zICYmIChidWZmZXJJbmZvLm5leHRTdGFydCA8PSBidWZmZXJlZEZyYWdBdFBvcy5lbmQgfHwgYnVmZmVyZWRGcmFnQXRQb3MuZ2FwKSkge1xuICAgICAgICBjb25zdCBnYXBEdXJhdGlvbiA9IE1hdGgubWF4KE1hdGgubWluKGJ1ZmZlckluZm8ubmV4dFN0YXJ0LCBidWZmZXJlZEZyYWdBdFBvcy5lbmQpIC0gcG9zLCBtYXhCdWZmZXJIb2xlKTtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKGJ1ZmZlcmFibGUsIHBvcywgZ2FwRHVyYXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnVmZmVySW5mbztcbiAgfVxuICBnZXRNYXhCdWZmZXJMZW5ndGgobGV2ZWxCaXRyYXRlKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29uZmlnXG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IG1heEJ1ZkxlbjtcbiAgICBpZiAobGV2ZWxCaXRyYXRlKSB7XG4gICAgICBtYXhCdWZMZW4gPSBNYXRoLm1heCg4ICogY29uZmlnLm1heEJ1ZmZlclNpemUgLyBsZXZlbEJpdHJhdGUsIGNvbmZpZy5tYXhCdWZmZXJMZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXhCdWZMZW4gPSBjb25maWcubWF4QnVmZmVyTGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5taW4obWF4QnVmTGVuLCBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoKTtcbiAgfVxuICByZWR1Y2VNYXhCdWZmZXJMZW5ndGgodGhyZXNob2xkLCBmcmFnRHVyYXRpb24pIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBjb25zdCBtaW5MZW5ndGggPSBNYXRoLm1heChNYXRoLm1pbih0aHJlc2hvbGQgLSBmcmFnRHVyYXRpb24sIGNvbmZpZy5tYXhCdWZmZXJMZW5ndGgpLCBmcmFnRHVyYXRpb24pO1xuICAgIGNvbnN0IHJlZHVjZWRMZW5ndGggPSBNYXRoLm1heCh0aHJlc2hvbGQgLSBmcmFnRHVyYXRpb24gKiAzLCBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoIC8gMiwgbWluTGVuZ3RoKTtcbiAgICBpZiAocmVkdWNlZExlbmd0aCA+PSBtaW5MZW5ndGgpIHtcbiAgICAgIC8vIHJlZHVjZSBtYXggYnVmZmVyIGxlbmd0aCBhcyBpdCBtaWdodCBiZSB0b28gaGlnaC4gd2UgZG8gdGhpcyB0byBhdm9pZCBsb29wIGZsdXNoaW5nIC4uLlxuICAgICAgY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCA9IHJlZHVjZWRMZW5ndGg7XG4gICAgICB0aGlzLndhcm4oYFJlZHVjZSBtYXggYnVmZmVyIGxlbmd0aCB0byAke3JlZHVjZWRMZW5ndGh9c2ApO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBnZXRBcHBlbmRlZEZyYWcocG9zaXRpb24sIHBsYXlsaXN0VHlwZSA9IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pIHtcbiAgICB2YXIgX3RoaXMkZnJhZ21lbnRUcmFja2VyO1xuICAgIGNvbnN0IGZyYWdPclBhcnQgPSAoX3RoaXMkZnJhZ21lbnRUcmFja2VyID0gdGhpcy5mcmFnbWVudFRyYWNrZXIpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRmcmFnbWVudFRyYWNrZXIuZ2V0QXBwZW5kZWRGcmFnKHBvc2l0aW9uLCBwbGF5bGlzdFR5cGUpO1xuICAgIGlmIChmcmFnT3JQYXJ0ICYmICdmcmFnbWVudCcgaW4gZnJhZ09yUGFydCkge1xuICAgICAgcmV0dXJuIGZyYWdPclBhcnQuZnJhZ21lbnQ7XG4gICAgfVxuICAgIHJldHVybiBmcmFnT3JQYXJ0O1xuICB9XG4gIGdldE5leHRGcmFnbWVudChwb3MsIGxldmVsRGV0YWlscykge1xuICAgIGNvbnN0IGZyYWdtZW50cyA9IGxldmVsRGV0YWlscy5mcmFnbWVudHM7XG4gICAgY29uc3QgZnJhZ0xlbiA9IGZyYWdtZW50cy5sZW5ndGg7XG4gICAgaWYgKCFmcmFnTGVuKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBmaW5kIGZyYWdtZW50IGluZGV4LCBjb250aWd1b3VzIHdpdGggZW5kIG9mIGJ1ZmZlciBwb3NpdGlvblxuICAgIGNvbnN0IHtcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHN0YXJ0ID0gZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgIGNvbnN0IGNhbkxvYWRQYXJ0cyA9IGNvbmZpZy5sb3dMYXRlbmN5TW9kZSAmJiAhIWxldmVsRGV0YWlscy5wYXJ0TGlzdDtcbiAgICBsZXQgZnJhZyA9IG51bGw7XG4gICAgaWYgKGxldmVsRGV0YWlscy5saXZlKSB7XG4gICAgICBjb25zdCBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZSA9IGNvbmZpZy5pbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZTtcbiAgICAgIGlmIChmcmFnTGVuIDwgaW5pdGlhbExpdmVNYW5pZmVzdFNpemUpIHtcbiAgICAgICAgdGhpcy53YXJuKGBOb3QgZW5vdWdoIGZyYWdtZW50cyB0byBzdGFydCBwbGF5YmFjayAoaGF2ZTogJHtmcmFnTGVufSwgbmVlZDogJHtpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZX0pYCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgLy8gVGhlIHJlYWwgZnJhZ21lbnQgc3RhcnQgdGltZXMgZm9yIGEgbGl2ZSBzdHJlYW0gYXJlIG9ubHkga25vd24gYWZ0ZXIgdGhlIFBUUyByYW5nZSBmb3IgdGhhdCBsZXZlbCBpcyBrbm93bi5cbiAgICAgIC8vIEluIG9yZGVyIHRvIGRpc2NvdmVyIHRoZSByYW5nZSwgd2UgbG9hZCB0aGUgYmVzdCBtYXRjaGluZyBmcmFnbWVudCBmb3IgdGhhdCBsZXZlbCBhbmQgZGVtdXggaXQuXG4gICAgICAvLyBEbyBub3QgbG9hZCB1c2luZyBsaXZlIGxvZ2ljIGlmIHRoZSBzdGFydGluZyBmcmFnIGlzIHJlcXVlc3RlZCAtIHdlIHdhbnQgdG8gdXNlIGdldEZyYWdtZW50QXRQb3NpdGlvbigpIHNvIHRoYXRcbiAgICAgIC8vIHdlIGdldCB0aGUgZnJhZ21lbnQgbWF0Y2hpbmcgdGhhdCBzdGFydCB0aW1lXG4gICAgICBpZiAoIWxldmVsRGV0YWlscy5QVFNLbm93biAmJiAhdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgJiYgdGhpcy5zdGFydFBvc2l0aW9uID09PSAtMSB8fCBwb3MgPCBzdGFydCkge1xuICAgICAgICB2YXIgX2ZyYWc7XG4gICAgICAgIGlmIChjYW5Mb2FkUGFydHMgJiYgIXRoaXMubG9hZGluZ1BhcnRzKSB7XG4gICAgICAgICAgdGhpcy5sb2coYExMLVBhcnQgbG9hZGluZyBPTiBmb3IgaW5pdGlhbCBsaXZlIGZyYWdtZW50YCk7XG4gICAgICAgICAgdGhpcy5sb2FkaW5nUGFydHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZyYWcgPSB0aGlzLmdldEluaXRpYWxMaXZlRnJhZ21lbnQobGV2ZWxEZXRhaWxzKTtcbiAgICAgICAgY29uc3QgbWFpblN0YXJ0ID0gdGhpcy5obHMuc3RhcnRQb3NpdGlvbjtcbiAgICAgICAgY29uc3QgbGl2ZVN5bmNQb3NpdGlvbiA9IHRoaXMuaGxzLmxpdmVTeW5jUG9zaXRpb247XG4gICAgICAgIGNvbnN0IHN0YXJ0UG9zaXRpb24gPSBmcmFnID8gKG1haW5TdGFydCAhPT0gLTEgJiYgbWFpblN0YXJ0ID49IHN0YXJ0ID8gbWFpblN0YXJ0IDogbGl2ZVN5bmNQb3NpdGlvbikgfHwgZnJhZy5zdGFydCA6IHBvcztcbiAgICAgICAgdGhpcy5sb2coYFNldHRpbmcgc3RhcnRQb3NpdGlvbiB0byAke3N0YXJ0UG9zaXRpb259IHRvIG1hdGNoIHN0YXJ0IGZyYWcgYXQgbGl2ZSBlZGdlLiBtYWluU3RhcnQ6ICR7bWFpblN0YXJ0fSBsaXZlU3luY1Bvc2l0aW9uOiAke2xpdmVTeW5jUG9zaXRpb259IGZyYWcuc3RhcnQ6ICR7KF9mcmFnID0gZnJhZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9mcmFnLnN0YXJ0fWApO1xuICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBzdGFydFBvc2l0aW9uO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocG9zIDw9IHN0YXJ0KSB7XG4gICAgICAvLyBWb0QgcGxheWxpc3Q6IGlmIGxvYWRQb3NpdGlvbiBiZWZvcmUgc3RhcnQgb2YgcGxheWxpc3QsIGxvYWQgZmlyc3QgZnJhZ21lbnRcbiAgICAgIGZyYWcgPSBmcmFnbWVudHNbMF07XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgaGF2ZW4ndCBydW4gaW50byBhbnkgc3BlY2lhbCBjYXNlcyBhbHJlYWR5LCBqdXN0IGxvYWQgdGhlIGZyYWdtZW50IG1vc3QgY2xvc2VseSBtYXRjaGluZyB0aGUgcmVxdWVzdGVkIHBvc2l0aW9uXG4gICAgaWYgKCFmcmFnKSB7XG4gICAgICBjb25zdCBlbmQgPSB0aGlzLmxvYWRpbmdQYXJ0cyA/IGxldmVsRGV0YWlscy5wYXJ0RW5kIDogbGV2ZWxEZXRhaWxzLmZyYWdtZW50RW5kO1xuICAgICAgZnJhZyA9IHRoaXMuZ2V0RnJhZ21lbnRBdFBvc2l0aW9uKHBvcywgZW5kLCBsZXZlbERldGFpbHMpO1xuICAgIH1cbiAgICBsZXQgcHJvZ3JhbUZyYWcgPSB0aGlzLmZpbHRlclJlcGxhY2VkUHJpbWFyeShmcmFnLCBsZXZlbERldGFpbHMpO1xuICAgIGlmICghcHJvZ3JhbUZyYWcgJiYgZnJhZykge1xuICAgICAgY29uc3QgY3VyU05JZHggPSBmcmFnLnNuIC0gbGV2ZWxEZXRhaWxzLnN0YXJ0U047XG4gICAgICBwcm9ncmFtRnJhZyA9IHRoaXMuZmlsdGVyUmVwbGFjZWRQcmltYXJ5KGZyYWdtZW50c1tjdXJTTklkeCArIDFdIHx8IG51bGwsIGxldmVsRGV0YWlscyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1hcFRvSW5pdEZyYWdXaGVuUmVxdWlyZWQocHJvZ3JhbUZyYWcpO1xuICB9XG4gIGlzTG9vcExvYWRpbmcoZnJhZywgdGFyZ2V0QnVmZmVyVGltZSkge1xuICAgIGNvbnN0IHRyYWNrZXJTdGF0ZSA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGZyYWcpO1xuICAgIHJldHVybiAodHJhY2tlclN0YXRlID09PSBGcmFnbWVudFN0YXRlLk9LIHx8IHRyYWNrZXJTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5QQVJUSUFMICYmICEhZnJhZy5nYXApICYmIHRoaXMubmV4dExvYWRQb3NpdGlvbiA+IHRhcmdldEJ1ZmZlclRpbWU7XG4gIH1cbiAgZ2V0TmV4dEZyYWdtZW50TG9vcExvYWRpbmcoZnJhZywgbGV2ZWxEZXRhaWxzLCBidWZmZXJJbmZvLCBwbGF5bGlzdFR5cGUsIG1heEJ1Zkxlbikge1xuICAgIGxldCBuZXh0RnJhZ21lbnQgPSBudWxsO1xuICAgIGlmIChmcmFnLmdhcCkge1xuICAgICAgbmV4dEZyYWdtZW50ID0gdGhpcy5nZXROZXh0RnJhZ21lbnQodGhpcy5uZXh0TG9hZFBvc2l0aW9uLCBsZXZlbERldGFpbHMpO1xuICAgICAgaWYgKG5leHRGcmFnbWVudCAmJiAhbmV4dEZyYWdtZW50LmdhcCAmJiBidWZmZXJJbmZvLm5leHRTdGFydCkge1xuICAgICAgICAvLyBNZWRpYSBidWZmZXJlZCBhZnRlciBHQVAgdGFncyBzaG91bGQgbm90IG1ha2UgdGhlIG5leHQgYnVmZmVyIHRpbWVyYW5nZSBleGNlZWQgZm9yd2FyZCBidWZmZXIgbGVuZ3RoXG4gICAgICAgIGNvbnN0IG5leHRidWZmZXJJbmZvID0gdGhpcy5nZXRGd2RCdWZmZXJJbmZvQXRQb3ModGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhLCBidWZmZXJJbmZvLm5leHRTdGFydCwgcGxheWxpc3RUeXBlLCAwKTtcbiAgICAgICAgaWYgKG5leHRidWZmZXJJbmZvICE9PSBudWxsICYmIGJ1ZmZlckluZm8ubGVuICsgbmV4dGJ1ZmZlckluZm8ubGVuID49IG1heEJ1Zkxlbikge1xuICAgICAgICAgIC8vIFJldHVybmluZyBoZXJlIG1pZ2h0IHJlc3VsdCBpbiBub3QgZmluZGluZyBhbiBhdWRpbyBhbmQgdmlkZW8gY2FuZGlhdGUgdG8gc2tpcCB0b1xuICAgICAgICAgIGNvbnN0IHNuID0gbmV4dEZyYWdtZW50LnNuO1xuICAgICAgICAgIGlmICh0aGlzLmxvb3BTbiAhPT0gc24pIHtcbiAgICAgICAgICAgIHRoaXMubG9nKGBidWZmZXIgZnVsbCBhZnRlciBnYXBzIGluIFwiJHtwbGF5bGlzdFR5cGV9XCIgcGxheWxpc3Qgc3RhcnRpbmcgYXQgc246ICR7c259YCk7XG4gICAgICAgICAgICB0aGlzLmxvb3BTbiA9IHNuO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxvb3BTbiA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gbmV4dEZyYWdtZW50O1xuICB9XG4gIGdldCBwcmltYXJ5UHJlZmV0Y2goKSB7XG4gICAgaWYgKGludGVyc3RpdGlhbHNFbmFibGVkKHRoaXMuaGxzLmNvbmZpZykpIHtcbiAgICAgIHZhciBfdGhpcyRobHMkaW50ZXJzdGl0aWEsIF90aGlzJGhscyRpbnRlcnN0aXRpYTI7XG4gICAgICBjb25zdCBwbGF5aW5nSW50ZXJzdGl0aWFsID0gKF90aGlzJGhscyRpbnRlcnN0aXRpYSA9IHRoaXMuaGxzLmludGVyc3RpdGlhbHNNYW5hZ2VyKSA9PSBudWxsID8gdm9pZCAwIDogKF90aGlzJGhscyRpbnRlcnN0aXRpYTIgPSBfdGhpcyRobHMkaW50ZXJzdGl0aWEucGxheWluZ0l0ZW0pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRobHMkaW50ZXJzdGl0aWEyLmV2ZW50O1xuICAgICAgaWYgKHBsYXlpbmdJbnRlcnN0aXRpYWwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmaWx0ZXJSZXBsYWNlZFByaW1hcnkoZnJhZywgZGV0YWlscykge1xuICAgIGlmICghZnJhZykge1xuICAgICAgcmV0dXJuIGZyYWc7XG4gICAgfVxuICAgIGlmIChpbnRlcnN0aXRpYWxzRW5hYmxlZCh0aGlzLmhscy5jb25maWcpICYmIGZyYWcudHlwZSAhPT0gUGxheWxpc3RMZXZlbFR5cGUuU1VCVElUTEUpIHtcbiAgICAgIC8vIERvIG5vdCBsb2FkIGZyYWdtZW50cyBvdXRzaWRlIHRoZSBidWZmZXJpbmcgc2NoZWR1bGUgc2VnbWVudFxuICAgICAgY29uc3QgaW50ZXJzdGl0aWFscyA9IHRoaXMuaGxzLmludGVyc3RpdGlhbHNNYW5hZ2VyO1xuICAgICAgY29uc3QgYnVmZmVyaW5nSXRlbSA9IGludGVyc3RpdGlhbHMgPT0gbnVsbCA/IHZvaWQgMCA6IGludGVyc3RpdGlhbHMuYnVmZmVyaW5nSXRlbTtcbiAgICAgIGlmIChidWZmZXJpbmdJdGVtKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlcmluZ0ludGVyc3RpdGlhbCA9IGJ1ZmZlcmluZ0l0ZW0uZXZlbnQ7XG4gICAgICAgIGlmIChidWZmZXJpbmdJbnRlcnN0aXRpYWwpIHtcbiAgICAgICAgICAvLyBEbyBub3Qgc3RyZWFtIGZyYWdtZW50cyB3aGlsZSBidWZmZXJpbmcgSW50ZXJzdGl0aWFsIEV2ZW50cyAoZXhjZXB0IGZvciBvdmVybGFwIGF0IHRoZSBzdGFydClcbiAgICAgICAgICBpZiAoYnVmZmVyaW5nSW50ZXJzdGl0aWFsLmFwcGVuZEluUGxhY2UgfHwgTWF0aC5hYnMoZnJhZy5zdGFydCAtIGJ1ZmZlcmluZ0l0ZW0uc3RhcnQpID4gMSB8fCBidWZmZXJpbmdJdGVtLnN0YXJ0ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTGltaXQgZnJhZ21lbnQgbG9hZGluZyB0byBtZWRpYSBpbiBzY2hlZHVsZSBpdGVtXG4gICAgICAgICAgaWYgKGZyYWcuZW5kIDw9IGJ1ZmZlcmluZ0l0ZW0uc3RhcnQgJiYgKGRldGFpbHMgPT0gbnVsbCA/IHZvaWQgMCA6IGRldGFpbHMubGl2ZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAvLyBmcmFnbWVudCBlbmRzIGJ5IHNjaGVkdWxlIGl0ZW0gc3RhcnRcbiAgICAgICAgICAgIC8vIHRoaXMuZnJhZ21lbnRUcmFja2VyLmZyYWdCdWZmZXJlZChmcmFnLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZnJhZy5zdGFydCA+IGJ1ZmZlcmluZ0l0ZW0uZW5kICYmIGJ1ZmZlcmluZ0l0ZW0ubmV4dEV2ZW50KSB7XG4gICAgICAgICAgICAvLyBmcmFnbWVudCBpcyBwYXN0IHNjaGVkdWxlIGl0ZW0gZW5kXG4gICAgICAgICAgICAvLyBhbGxvdyBzb21lIG92ZXJmbG93IHdoZW4gbm90IGFwcGVuZGluZyBpbiBwbGFjZSB0byBwcmV2ZW50IHN0YWxsc1xuICAgICAgICAgICAgaWYgKGJ1ZmZlcmluZ0l0ZW0ubmV4dEV2ZW50LmFwcGVuZEluUGxhY2UgfHwgZnJhZy5zdGFydCAtIGJ1ZmZlcmluZ0l0ZW0uZW5kID4gMSkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFNraXAgbG9hZGluZyBvZiBmcmFnbWVudHMgdGhhdCBvdmVybGFwIGNvbXBsZXRlbHkgd2l0aCBhcHBlbmRJblBsYWNlIGludGVyc3RpdGlhbHNcbiAgICAgIGNvbnN0IHBsYXllclF1ZXVlID0gaW50ZXJzdGl0aWFscyA9PSBudWxsID8gdm9pZCAwIDogaW50ZXJzdGl0aWFscy5wbGF5ZXJRdWV1ZTtcbiAgICAgIGlmIChwbGF5ZXJRdWV1ZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gcGxheWVyUXVldWUubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgY29uc3QgaW50ZXJzdGl0aWFsID0gcGxheWVyUXVldWVbaV0uaW50ZXJzdGl0aWFsO1xuICAgICAgICAgIGlmIChpbnRlcnN0aXRpYWwuYXBwZW5kSW5QbGFjZSAmJiBmcmFnLnN0YXJ0ID49IGludGVyc3RpdGlhbC5zdGFydFRpbWUgJiYgZnJhZy5lbmQgPD0gaW50ZXJzdGl0aWFsLnJlc3VtZVRpbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnJhZztcbiAgfVxuICBtYXBUb0luaXRGcmFnV2hlblJlcXVpcmVkKGZyYWcpIHtcbiAgICAvLyBJZiBhbiBpbml0U2VnbWVudCBpcyBwcmVzZW50LCBpdCBtdXN0IGJlIGJ1ZmZlcmVkIGZpcnN0XG4gICAgaWYgKGZyYWcgIT0gbnVsbCAmJiBmcmFnLmluaXRTZWdtZW50ICYmICEoZnJhZyAhPSBudWxsICYmIGZyYWcuaW5pdFNlZ21lbnQuZGF0YSkgJiYgIXRoaXMuYml0cmF0ZVRlc3QpIHtcbiAgICAgIHJldHVybiBmcmFnLmluaXRTZWdtZW50O1xuICAgIH1cbiAgICByZXR1cm4gZnJhZztcbiAgfVxuICBnZXROZXh0UGFydChwYXJ0TGlzdCwgZnJhZywgdGFyZ2V0QnVmZmVyVGltZSkge1xuICAgIGxldCBuZXh0UGFydCA9IC0xO1xuICAgIGxldCBjb250aWd1b3VzID0gZmFsc2U7XG4gICAgbGV0IGluZGVwZW5kZW50QXR0ck9taXR0ZWQgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBwYXJ0TGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgcGFydCA9IHBhcnRMaXN0W2ldO1xuICAgICAgaW5kZXBlbmRlbnRBdHRyT21pdHRlZCA9IGluZGVwZW5kZW50QXR0ck9taXR0ZWQgJiYgIXBhcnQuaW5kZXBlbmRlbnQ7XG4gICAgICBpZiAobmV4dFBhcnQgPiAtMSAmJiB0YXJnZXRCdWZmZXJUaW1lIDwgcGFydC5zdGFydCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxvYWRlZCA9IHBhcnQubG9hZGVkO1xuICAgICAgaWYgKGxvYWRlZCkge1xuICAgICAgICBuZXh0UGFydCA9IC0xO1xuICAgICAgfSBlbHNlIGlmICgoY29udGlndW91cyB8fCBwYXJ0LmluZGVwZW5kZW50IHx8IGluZGVwZW5kZW50QXR0ck9taXR0ZWQpICYmIHBhcnQuZnJhZ21lbnQgPT09IGZyYWcpIHtcbiAgICAgICAgbmV4dFBhcnQgPSBpO1xuICAgICAgfVxuICAgICAgY29udGlndW91cyA9IGxvYWRlZDtcbiAgICB9XG4gICAgcmV0dXJuIG5leHRQYXJ0O1xuICB9XG4gIGxvYWRlZEVuZE9mUGFydHMocGFydExpc3QsIHRhcmdldEJ1ZmZlclRpbWUpIHtcbiAgICBjb25zdCBsYXN0UGFydCA9IHBhcnRMaXN0W3BhcnRMaXN0Lmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBsYXN0UGFydCAmJiB0YXJnZXRCdWZmZXJUaW1lID4gbGFzdFBhcnQuc3RhcnQgJiYgbGFzdFBhcnQubG9hZGVkO1xuICB9XG5cbiAgLypcbiAgIFRoaXMgbWV0aG9kIGlzIHVzZWQgZmluZCB0aGUgYmVzdCBtYXRjaGluZyBmaXJzdCBmcmFnbWVudCBmb3IgYSBsaXZlIHBsYXlsaXN0LiBUaGlzIGZyYWdtZW50IGlzIHVzZWQgdG8gY2FsY3VsYXRlIHRoZVxuICAgXCJzbGlkaW5nXCIgb2YgdGhlIHBsYXlsaXN0LCB3aGljaCBpcyBpdHMgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIHBsYXliYWNrLiBBZnRlciBzbGlkaW5nIHdlIGNhbiBjb21wdXRlIHRoZSByZWFsXG4gICBzdGFydCBhbmQgZW5kIHRpbWVzIGZvciBlYWNoIGZyYWdtZW50IGluIHRoZSBwbGF5bGlzdCAoYWZ0ZXIgd2hpY2ggdGhpcyBtZXRob2Qgd2lsbCBub3QgbmVlZCB0byBiZSBjYWxsZWQpLlxuICAqL1xuICBnZXRJbml0aWFsTGl2ZUZyYWdtZW50KGxldmVsRGV0YWlscykge1xuICAgIGNvbnN0IGZyYWdtZW50cyA9IGxldmVsRGV0YWlscy5mcmFnbWVudHM7XG4gICAgY29uc3QgZnJhZ1ByZXZpb3VzID0gdGhpcy5mcmFnUHJldmlvdXM7XG4gICAgbGV0IGZyYWcgPSBudWxsO1xuICAgIGlmIChmcmFnUHJldmlvdXMpIHtcbiAgICAgIGlmIChsZXZlbERldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgICAgIC8vIFByZWZlciB1c2luZyBQRFQsIGJlY2F1c2UgaXQgY2FuIGJlIGFjY3VyYXRlIGVub3VnaCB0byBjaG9vc2UgdGhlIGNvcnJlY3QgZnJhZ21lbnQgd2l0aG91dCBrbm93aW5nIHRoZSBsZXZlbCBzbGlkaW5nXG4gICAgICAgIHRoaXMubG9nKGBMaXZlIHBsYXlsaXN0LCBzd2l0Y2hpbmcgcGxheWxpc3QsIGxvYWQgZnJhZyB3aXRoIHNhbWUgUERUOiAke2ZyYWdQcmV2aW91cy5wcm9ncmFtRGF0ZVRpbWV9YCk7XG4gICAgICAgIGZyYWcgPSBmaW5kRnJhZ21lbnRCeVBEVChmcmFnbWVudHMsIGZyYWdQcmV2aW91cy5lbmRQcm9ncmFtRGF0ZVRpbWUsIHRoaXMuY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UpO1xuICAgICAgfVxuICAgICAgaWYgKCFmcmFnKSB7XG4gICAgICAgIC8vIFNOIGRvZXMgbm90IG5lZWQgdG8gYmUgYWNjdXJhdGUgYmV0d2VlbiByZW5kaXRpb25zLCBidXQgZGVwZW5kaW5nIG9uIHRoZSBwYWNrYWdpbmcgaXQgbWF5IGJlIHNvLlxuICAgICAgICBjb25zdCB0YXJnZXRTTiA9IGZyYWdQcmV2aW91cy5zbiArIDE7XG4gICAgICAgIGlmICh0YXJnZXRTTiA+PSBsZXZlbERldGFpbHMuc3RhcnRTTiAmJiB0YXJnZXRTTiA8PSBsZXZlbERldGFpbHMuZW5kU04pIHtcbiAgICAgICAgICBjb25zdCBmcmFnTmV4dCA9IGZyYWdtZW50c1t0YXJnZXRTTiAtIGxldmVsRGV0YWlscy5zdGFydFNOXTtcbiAgICAgICAgICAvLyBFbnN1cmUgdGhhdCB3ZSdyZSBzdGF5aW5nIHdpdGhpbiB0aGUgY29udGludWl0eSByYW5nZSwgc2luY2UgUFRTIHJlc2V0cyB1cG9uIGEgbmV3IHJhbmdlXG4gICAgICAgICAgaWYgKGZyYWdQcmV2aW91cy5jYyA9PT0gZnJhZ05leHQuY2MpIHtcbiAgICAgICAgICAgIGZyYWcgPSBmcmFnTmV4dDtcbiAgICAgICAgICAgIHRoaXMubG9nKGBMaXZlIHBsYXlsaXN0LCBzd2l0Y2hpbmcgcGxheWxpc3QsIGxvYWQgZnJhZyB3aXRoIG5leHQgU046ICR7ZnJhZy5zbn1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXQncyBpbXBvcnRhbnQgdG8gc3RheSB3aXRoaW4gdGhlIGNvbnRpbnVpdHkgcmFuZ2UgaWYgYXZhaWxhYmxlOyBvdGhlcndpc2UgdGhlIGZyYWdtZW50cyBpbiB0aGUgcGxheWxpc3RcbiAgICAgICAgLy8gd2lsbCBoYXZlIHRoZSB3cm9uZyBzdGFydCB0aW1lc1xuICAgICAgICBpZiAoIWZyYWcpIHtcbiAgICAgICAgICBmcmFnID0gZmluZE5lYXJlc3RXaXRoQ0MobGV2ZWxEZXRhaWxzLCBmcmFnUHJldmlvdXMuY2MsIGZyYWdQcmV2aW91cy5lbmQpO1xuICAgICAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgICAgICB0aGlzLmxvZyhgTGl2ZSBwbGF5bGlzdCwgc3dpdGNoaW5nIHBsYXlsaXN0LCBsb2FkIGZyYWcgd2l0aCBzYW1lIENDOiAke2ZyYWcuc259YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZpbmQgYSBuZXcgc3RhcnQgZnJhZ21lbnQgd2hlbiBmcmFnUHJldmlvdXMgaXMgbnVsbFxuICAgICAgY29uc3QgbGl2ZVN0YXJ0ID0gdGhpcy5obHMubGl2ZVN5bmNQb3NpdGlvbjtcbiAgICAgIGlmIChsaXZlU3RhcnQgIT09IG51bGwpIHtcbiAgICAgICAgZnJhZyA9IHRoaXMuZ2V0RnJhZ21lbnRBdFBvc2l0aW9uKGxpdmVTdGFydCwgdGhpcy5iaXRyYXRlVGVzdCA/IGxldmVsRGV0YWlscy5mcmFnbWVudEVuZCA6IGxldmVsRGV0YWlscy5lZGdlLCBsZXZlbERldGFpbHMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnJhZztcbiAgfVxuXG4gIC8qXG4gIFRoaXMgbWV0aG9kIGZpbmRzIHRoZSBiZXN0IG1hdGNoaW5nIGZyYWdtZW50IGdpdmVuIHRoZSBwcm92aWRlZCBwb3NpdGlvbi5cbiAgICovXG4gIGdldEZyYWdtZW50QXRQb3NpdGlvbihidWZmZXJFbmQsIGVuZCwgbGV2ZWxEZXRhaWxzKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29uZmlnXG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHtcbiAgICAgIGZyYWdQcmV2aW91c1xuICAgIH0gPSB0aGlzO1xuICAgIGxldCB7XG4gICAgICBmcmFnbWVudHMsXG4gICAgICBlbmRTTlxuICAgIH0gPSBsZXZlbERldGFpbHM7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZ21lbnRIaW50XG4gICAgfSA9IGxldmVsRGV0YWlscztcbiAgICBjb25zdCB7XG4gICAgICBtYXhGcmFnTG9va1VwVG9sZXJhbmNlXG4gICAgfSA9IGNvbmZpZztcbiAgICBjb25zdCBwYXJ0TGlzdCA9IGxldmVsRGV0YWlscy5wYXJ0TGlzdDtcbiAgICBjb25zdCBsb2FkaW5nUGFydHMgPSAhISh0aGlzLmxvYWRpbmdQYXJ0cyAmJiBwYXJ0TGlzdCAhPSBudWxsICYmIHBhcnRMaXN0Lmxlbmd0aCAmJiBmcmFnbWVudEhpbnQpO1xuICAgIGlmIChsb2FkaW5nUGFydHMgJiYgZnJhZ21lbnRIaW50ICYmICF0aGlzLmJpdHJhdGVUZXN0ICYmIHBhcnRMaXN0W3BhcnRMaXN0Lmxlbmd0aCAtIDFdLmZyYWdtZW50LnNuID09PSBmcmFnbWVudEhpbnQuc24pIHtcbiAgICAgIC8vIEluY2x1ZGUgaW5jb21wbGV0ZSBmcmFnbWVudCB3aXRoIHBhcnRzIGF0IGVuZFxuICAgICAgZnJhZ21lbnRzID0gZnJhZ21lbnRzLmNvbmNhdChmcmFnbWVudEhpbnQpO1xuICAgICAgZW5kU04gPSBmcmFnbWVudEhpbnQuc247XG4gICAgfVxuICAgIGxldCBmcmFnO1xuICAgIGlmIChidWZmZXJFbmQgPCBlbmQpIHtcbiAgICAgIHZhciBfdGhpcyRtZWRpYTM7XG4gICAgICBjb25zdCBiYWNrd2FyZFNlZWsgPSBidWZmZXJFbmQgPCB0aGlzLmxhc3RDdXJyZW50VGltZTtcbiAgICAgIGNvbnN0IGxvb2t1cFRvbGVyYW5jZSA9IGJhY2t3YXJkU2VlayB8fCBidWZmZXJFbmQgPiBlbmQgLSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIHx8IChfdGhpcyRtZWRpYTMgPSB0aGlzLm1lZGlhKSAhPSBudWxsICYmIF90aGlzJG1lZGlhMy5wYXVzZWQgfHwgIXRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID8gMCA6IG1heEZyYWdMb29rVXBUb2xlcmFuY2U7XG4gICAgICAvLyBSZW1vdmUgdGhlIHRvbGVyYW5jZSBpZiBpdCB3b3VsZCBwdXQgdGhlIGJ1ZmZlckVuZCBwYXN0IHRoZSBhY3R1YWwgZW5kIG9mIHN0cmVhbVxuICAgICAgLy8gVXNlcyBidWZmZXIgYW5kIHNlcXVlbmNlIG51bWJlciB0byBjYWxjdWxhdGUgc3dpdGNoIHNlZ21lbnQgKHJlcXVpcmVkIGlmIHVzaW5nIEVYVC1YLURJU0NPTlRJTlVJVFktU0VRVUVOQ0UpXG4gICAgICBmcmFnID0gZmluZEZyYWdtZW50QnlQVFMoZnJhZ1ByZXZpb3VzLCBmcmFnbWVudHMsIGJ1ZmZlckVuZCwgbG9va3VwVG9sZXJhbmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVhY2ggZW5kIG9mIHBsYXlsaXN0XG4gICAgICBmcmFnID0gZnJhZ21lbnRzW2ZyYWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgaWYgKGZyYWcpIHtcbiAgICAgIGNvbnN0IGN1clNOSWR4ID0gZnJhZy5zbiAtIGxldmVsRGV0YWlscy5zdGFydFNOO1xuICAgICAgLy8gTW92ZSBmcmFnUHJldmlvdXMgZm9yd2FyZCB0byBzdXBwb3J0IGZvcmNpbmcgdGhlIG5leHQgZnJhZ21lbnQgdG8gbG9hZFxuICAgICAgLy8gd2hlbiB0aGUgYnVmZmVyIGNhdGNoZXMgdXAgdG8gYSBwcmV2aW91c2x5IGJ1ZmZlcmVkIHJhbmdlLlxuICAgICAgY29uc3QgZnJhZ1N0YXRlID0gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZyk7XG4gICAgICBpZiAoZnJhZ1N0YXRlID09PSBGcmFnbWVudFN0YXRlLk9LIHx8IGZyYWdTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5QQVJUSUFMICYmIGZyYWcuZ2FwKSB7XG4gICAgICAgIGZyYWdQcmV2aW91cyA9IGZyYWc7XG4gICAgICB9XG4gICAgICBpZiAoZnJhZ1ByZXZpb3VzICYmIGZyYWcuc24gPT09IGZyYWdQcmV2aW91cy5zbiAmJiAoIWxvYWRpbmdQYXJ0cyB8fCBwYXJ0TGlzdFswXS5mcmFnbWVudC5zbiA+IGZyYWcuc24gfHwgIWxldmVsRGV0YWlscy5saXZlICYmICFsb2FkaW5nUGFydHMpKSB7XG4gICAgICAgIC8vIEZvcmNlIHRoZSBuZXh0IGZyYWdtZW50IHRvIGxvYWQgaWYgdGhlIHByZXZpb3VzIG9uZSB3YXMgYWxyZWFkeSBzZWxlY3RlZC4gVGhpcyBjYW4gb2NjYXNpb25hbGx5IGhhcHBlbiB3aXRoXG4gICAgICAgIC8vIG5vbi11bmlmb3JtIGZyYWdtZW50IGR1cmF0aW9uc1xuICAgICAgICBjb25zdCBzYW1lTGV2ZWwgPSBmcmFnUHJldmlvdXMgJiYgZnJhZy5sZXZlbCA9PT0gZnJhZ1ByZXZpb3VzLmxldmVsO1xuICAgICAgICBpZiAoc2FtZUxldmVsKSB7XG4gICAgICAgICAgY29uc3QgbmV4dEZyYWcgPSBmcmFnbWVudHNbY3VyU05JZHggKyAxXTtcbiAgICAgICAgICBpZiAoZnJhZy5zbiA8IGVuZFNOICYmIHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKG5leHRGcmFnKSAhPT0gRnJhZ21lbnRTdGF0ZS5PSykge1xuICAgICAgICAgICAgZnJhZyA9IG5leHRGcmFnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcmFnID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZyYWc7XG4gIH1cbiAgYWxpZ25QbGF5bGlzdHMoZGV0YWlscywgcHJldmlvdXNEZXRhaWxzLCBzd2l0Y2hEZXRhaWxzKSB7XG4gICAgLy8gVE9ETzogSWYgbm90IGZvciBgc2hvdWxkQWxpZ25PbkRpc2NvbnRpbnVpdGllc2AgcmVxdWlyaW5nIGZyYWdQcmV2aW91cy5jYyxcbiAgICAvLyAgdGhpcyBjb3VsZCBhbGwgZ28gaW4gbGV2ZWwtaGVscGVyIG1lcmdlRGV0YWlscygpXG4gICAgY29uc3QgbGVuZ3RoID0gZGV0YWlscy5mcmFnbWVudHMubGVuZ3RoO1xuICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICB0aGlzLndhcm4oYE5vIGZyYWdtZW50cyBpbiBsaXZlIHBsYXlsaXN0YCk7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29uc3Qgc2xpZGluZ1N0YXJ0ID0gZGV0YWlscy5mcmFnbWVudFN0YXJ0O1xuICAgIGNvbnN0IGZpcnN0TGV2ZWxMb2FkID0gIXByZXZpb3VzRGV0YWlscztcbiAgICBjb25zdCBhbGlnbmVkID0gZGV0YWlscy5hbGlnbmVkU2xpZGluZyAmJiBpc0Zpbml0ZU51bWJlcihzbGlkaW5nU3RhcnQpO1xuICAgIGlmIChmaXJzdExldmVsTG9hZCB8fCAhYWxpZ25lZCAmJiAhc2xpZGluZ1N0YXJ0KSB7XG4gICAgICBhbGlnblN0cmVhbShzd2l0Y2hEZXRhaWxzLCBkZXRhaWxzKTtcbiAgICAgIGNvbnN0IGFsaWduZWRTbGlkaW5nU3RhcnQgPSBkZXRhaWxzLmZyYWdtZW50U3RhcnQ7XG4gICAgICB0aGlzLmxvZyhgTGl2ZSBwbGF5bGlzdCBzbGlkaW5nOiAke2FsaWduZWRTbGlkaW5nU3RhcnQudG9GaXhlZCgyKX0gc3RhcnQtc246ICR7cHJldmlvdXNEZXRhaWxzID8gcHJldmlvdXNEZXRhaWxzLnN0YXJ0U04gOiAnbmEnfS0+JHtkZXRhaWxzLnN0YXJ0U059IGZyYWdtZW50czogJHtsZW5ndGh9YCk7XG4gICAgICByZXR1cm4gYWxpZ25lZFNsaWRpbmdTdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIHNsaWRpbmdTdGFydDtcbiAgfVxuICB3YWl0Rm9yQ2RuVHVuZUluKGRldGFpbHMpIHtcbiAgICAvLyBXYWl0IGZvciBMb3ctTGF0ZW5jeSBDRE4gVHVuZS1pbiB0byBnZXQgYW4gdXBkYXRlZCBwbGF5bGlzdFxuICAgIGNvbnN0IGFkdmFuY2VQYXJ0TGltaXQgPSAzO1xuICAgIHJldHVybiBkZXRhaWxzLmxpdmUgJiYgZGV0YWlscy5jYW5CbG9ja1JlbG9hZCAmJiBkZXRhaWxzLnBhcnRUYXJnZXQgJiYgZGV0YWlscy50dW5lSW5Hb2FsID4gTWF0aC5tYXgoZGV0YWlscy5wYXJ0SG9sZEJhY2ssIGRldGFpbHMucGFydFRhcmdldCAqIGFkdmFuY2VQYXJ0TGltaXQpO1xuICB9XG4gIHNldFN0YXJ0UG9zaXRpb24oZGV0YWlscywgc2xpZGluZykge1xuICAgIC8vIGNvbXB1dGUgc3RhcnQgcG9zaXRpb24gaWYgc2V0IHRvIC0xLiB1c2UgaXQgc3RyYWlnaHQgYXdheSBpZiB2YWx1ZSBpcyBkZWZpbmVkXG4gICAgbGV0IHN0YXJ0UG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb247XG4gICAgaWYgKHN0YXJ0UG9zaXRpb24gPCBzbGlkaW5nKSB7XG4gICAgICBzdGFydFBvc2l0aW9uID0gLTE7XG4gICAgfVxuICAgIGNvbnN0IHRpbWVsaW5lT2Zmc2V0ID0gdGhpcy50aW1lbGluZU9mZnNldDtcbiAgICBpZiAoc3RhcnRQb3NpdGlvbiA9PT0gLTEpIHtcbiAgICAgIC8vIFVzZSBQbGF5bGlzdCBFWFQtWC1TVEFSVDpUSU1FLU9GRlNFVCB3aGVuIHNldFxuICAgICAgLy8gUHJpb3JpdGl6ZSBNdWx0aXZhcmlhbnQgUGxheWxpc3Qgb2Zmc2V0IHNvIHRoYXQgbWFpbiwgYXVkaW8sIGFuZCBzdWJ0aXRsZSBzdHJlYW0tY29udHJvbGxlciBzdGFydCB0aW1lcyBtYXRjaFxuICAgICAgY29uc3Qgb2Zmc2V0SW5NdWx0aXZhcmlhbnRQbGF5bGlzdCA9IHRoaXMuc3RhcnRUaW1lT2Zmc2V0ICE9PSBudWxsO1xuICAgICAgY29uc3Qgc3RhcnRUaW1lT2Zmc2V0ID0gb2Zmc2V0SW5NdWx0aXZhcmlhbnRQbGF5bGlzdCA/IHRoaXMuc3RhcnRUaW1lT2Zmc2V0IDogZGV0YWlscy5zdGFydFRpbWVPZmZzZXQ7XG4gICAgICBpZiAoc3RhcnRUaW1lT2Zmc2V0ICE9PSBudWxsICYmIGlzRmluaXRlTnVtYmVyKHN0YXJ0VGltZU9mZnNldCkpIHtcbiAgICAgICAgc3RhcnRQb3NpdGlvbiA9IHNsaWRpbmcgKyBzdGFydFRpbWVPZmZzZXQ7XG4gICAgICAgIGlmIChzdGFydFRpbWVPZmZzZXQgPCAwKSB7XG4gICAgICAgICAgc3RhcnRQb3NpdGlvbiArPSBkZXRhaWxzLmVkZ2U7XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnRQb3NpdGlvbiA9IE1hdGgubWluKE1hdGgubWF4KHNsaWRpbmcsIHN0YXJ0UG9zaXRpb24pLCBzbGlkaW5nICsgZGV0YWlscy50b3RhbGR1cmF0aW9uKTtcbiAgICAgICAgdGhpcy5sb2coYFNldHRpbmcgc3RhcnRQb3NpdGlvbiB0byAke3N0YXJ0UG9zaXRpb259IGZvciBzdGFydCB0aW1lIG9mZnNldCAke3N0YXJ0VGltZU9mZnNldH0gZm91bmQgaW4gJHtvZmZzZXRJbk11bHRpdmFyaWFudFBsYXlsaXN0ID8gJ211bHRpdmFyaWFudCcgOiAnbWVkaWEnfSBwbGF5bGlzdGApO1xuICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBzdGFydFBvc2l0aW9uO1xuICAgICAgfSBlbHNlIGlmIChkZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgLy8gTGVhdmUgdGhpcy5zdGFydFBvc2l0aW9uIGF0IC0xLCBzbyB0aGF0IHdlIGNhbiB1c2UgYGdldEluaXRpYWxMaXZlRnJhZ21lbnRgIGxvZ2ljIHdoZW4gc3RhcnRQb3NpdGlvbiBoYXNcbiAgICAgICAgLy8gbm90IGJlZW4gc3BlY2lmaWVkIHZpYSB0aGUgY29uZmlnIG9yIGFuIGFzIGFuIGFyZ3VtZW50IHRvIHN0YXJ0TG9hZCAoIzM3MzYpLlxuICAgICAgICBzdGFydFBvc2l0aW9uID0gdGhpcy5obHMubGl2ZVN5bmNQb3NpdGlvbiB8fCBzbGlkaW5nO1xuICAgICAgICB0aGlzLmxvZyhgU2V0dGluZyBzdGFydFBvc2l0aW9uIHRvIC0xIHRvIHN0YXJ0IGF0IGxpdmUgZWRnZSAke3N0YXJ0UG9zaXRpb259YCk7XG4gICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sb2coYHNldHRpbmcgc3RhcnRQb3NpdGlvbiB0byAwIGJ5IGRlZmF1bHRgKTtcbiAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbiA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IHN0YXJ0UG9zaXRpb24gKyB0aW1lbGluZU9mZnNldDtcbiAgICB9XG4gICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbiArIHRpbWVsaW5lT2Zmc2V0O1xuICB9XG4gIGdldExvYWRQb3NpdGlvbigpIHtcbiAgICB2YXIgX3RoaXMkaGxzO1xuICAgIGNvbnN0IHtcbiAgICAgIG1lZGlhXG4gICAgfSA9IHRoaXM7XG4gICAgLy8gaWYgd2UgaGF2ZSBub3QgeWV0IGxvYWRlZCBhbnkgZnJhZ21lbnQsIHN0YXJ0IGxvYWRpbmcgZnJvbSBzdGFydCBwb3NpdGlvblxuICAgIGxldCBwb3MgPSAwO1xuICAgIGlmICgoX3RoaXMkaGxzID0gdGhpcy5obHMpICE9IG51bGwgJiYgX3RoaXMkaGxzLmhhc0Vub3VnaFRvU3RhcnQgJiYgbWVkaWEpIHtcbiAgICAgIHBvcyA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0TG9hZFBvc2l0aW9uID49IDApIHtcbiAgICAgIHBvcyA9IHRoaXMubmV4dExvYWRQb3NpdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIHBvcztcbiAgfVxuICBoYW5kbGVGcmFnTG9hZEFib3J0ZWQoZnJhZywgcGFydCkge1xuICAgIGlmICh0aGlzLnRyYW5zbXV4ZXIgJiYgZnJhZy50eXBlID09PSB0aGlzLnBsYXlsaXN0VHlwZSAmJiBpc01lZGlhRnJhZ21lbnQoZnJhZykgJiYgZnJhZy5zdGF0cy5hYm9ydGVkKSB7XG4gICAgICB0aGlzLmxvZyhgRnJhZ21lbnQgJHtmcmFnLnNufSR7cGFydCA/ICcgcGFydCAnICsgcGFydC5pbmRleCA6ICcnfSBvZiAke3RoaXMucGxheWxpc3RMYWJlbCgpfSAke2ZyYWcubGV2ZWx9IHdhcyBhYm9ydGVkYCk7XG4gICAgICB0aGlzLnJlc2V0RnJhZ21lbnRMb2FkaW5nKGZyYWcpO1xuICAgIH1cbiAgfVxuICByZXNldEZyYWdtZW50TG9hZGluZyhmcmFnKSB7XG4gICAgaWYgKCF0aGlzLmZyYWdDdXJyZW50IHx8ICF0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSAmJiB0aGlzLnN0YXRlICE9PSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgfVxuICB9XG4gIG9uRnJhZ21lbnRPcktleUxvYWRFcnJvcihmaWx0ZXJUeXBlLCBkYXRhKSB7XG4gICAgaWYgKGRhdGEuY2h1bmtNZXRhICYmICFkYXRhLmZyYWcpIHtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdldEN1cnJlbnRDb250ZXh0KGRhdGEuY2h1bmtNZXRhKTtcbiAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgIGRhdGEuZnJhZyA9IGNvbnRleHQuZnJhZztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZnJhZyA9IGRhdGEuZnJhZztcbiAgICAvLyBIYW5kbGUgZnJhZyBlcnJvciByZWxhdGVkIHRvIGNhbGxlcidzIGZpbHRlclR5cGVcbiAgICBpZiAoIWZyYWcgfHwgZnJhZy50eXBlICE9PSBmaWx0ZXJUeXBlIHx8ICF0aGlzLmxldmVscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgIHZhciBfdGhpcyRmcmFnQ3VycmVudDtcbiAgICAgIHRoaXMud2FybihgRnJhZyBsb2FkIGVycm9yIG11c3QgbWF0Y2ggY3VycmVudCBmcmFnIHRvIHJldHJ5ICR7ZnJhZy51cmx9ID4gJHsoX3RoaXMkZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkZnJhZ0N1cnJlbnQudXJsfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBnYXBUYWdFbmNvdW50ZXJlZCA9IGRhdGEuZGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLkZSQUdfR0FQO1xuICAgIGlmIChnYXBUYWdFbmNvdW50ZXJlZCkge1xuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIuZnJhZ0J1ZmZlcmVkKGZyYWcsIHRydWUpO1xuICAgIH1cbiAgICAvLyBrZWVwIHJldHJ5aW5nIHVudGlsIHRoZSBsaW1pdCB3aWxsIGJlIHJlYWNoZWRcbiAgICBjb25zdCBlcnJvckFjdGlvbiA9IGRhdGEuZXJyb3JBY3Rpb247XG4gICAgY29uc3Qge1xuICAgICAgYWN0aW9uLFxuICAgICAgZmxhZ3MsXG4gICAgICByZXRyeUNvdW50ID0gMCxcbiAgICAgIHJldHJ5Q29uZmlnXG4gICAgfSA9IGVycm9yQWN0aW9uIHx8IHt9O1xuICAgIGNvbnN0IGNvdWxkUmV0cnkgPSAhIWVycm9yQWN0aW9uICYmICEhcmV0cnlDb25maWc7XG4gICAgY29uc3QgcmV0cnkgPSBjb3VsZFJldHJ5ICYmIGFjdGlvbiA9PT0gTmV0d29ya0Vycm9yQWN0aW9uLlJldHJ5UmVxdWVzdDtcbiAgICBjb25zdCBub0FsdGVybmF0ZSA9IGNvdWxkUmV0cnkgJiYgIWVycm9yQWN0aW9uLnJlc29sdmVkICYmIGZsYWdzID09PSBFcnJvckFjdGlvbkZsYWdzLk1vdmVBbGxBbHRlcm5hdGVzTWF0Y2hpbmdIb3N0O1xuICAgIGlmICghcmV0cnkgJiYgbm9BbHRlcm5hdGUgJiYgaXNNZWRpYUZyYWdtZW50KGZyYWcpICYmICFmcmFnLmVuZExpc3QpIHtcbiAgICAgIHRoaXMucmVzZXRGcmFnbWVudEVycm9ycyhmaWx0ZXJUeXBlKTtcbiAgICAgIHRoaXMudHJlYXRBc0dhcChmcmFnKTtcbiAgICAgIGVycm9yQWN0aW9uLnJlc29sdmVkID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKChyZXRyeSB8fCBub0FsdGVybmF0ZSkgJiYgcmV0cnlDb3VudCA8IHJldHJ5Q29uZmlnLm1heE51bVJldHJ5KSB7XG4gICAgICB0aGlzLnJlc2V0U3RhcnRXaGVuTm90TG9hZGVkKHRoaXMubGV2ZWxMYXN0TG9hZGVkKTtcbiAgICAgIGNvbnN0IGRlbGF5ID0gZ2V0UmV0cnlEZWxheShyZXRyeUNvbmZpZywgcmV0cnlDb3VudCk7XG4gICAgICB0aGlzLndhcm4oYEZyYWdtZW50ICR7ZnJhZy5zbn0gb2YgJHtmaWx0ZXJUeXBlfSAke2ZyYWcubGV2ZWx9IGVycm9yZWQgd2l0aCAke2RhdGEuZGV0YWlsc30sIHJldHJ5aW5nIGxvYWRpbmcgJHtyZXRyeUNvdW50ICsgMX0vJHtyZXRyeUNvbmZpZy5tYXhOdW1SZXRyeX0gaW4gJHtkZWxheX1tc2ApO1xuICAgICAgZXJyb3JBY3Rpb24ucmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5yZXRyeURhdGUgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpICsgZGVsYXk7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk7XG4gICAgfSBlbHNlIGlmIChyZXRyeUNvbmZpZyAmJiBlcnJvckFjdGlvbikge1xuICAgICAgdGhpcy5yZXNldEZyYWdtZW50RXJyb3JzKGZpbHRlclR5cGUpO1xuICAgICAgaWYgKHJldHJ5Q291bnQgPCByZXRyeUNvbmZpZy5tYXhOdW1SZXRyeSkge1xuICAgICAgICAvLyBOZXR3b3JrIHJldHJ5IGlzIHNraXBwZWQgd2hlbiBsZXZlbCBzd2l0Y2ggaXMgcHJlZmVycmVkXG4gICAgICAgIGlmICghZ2FwVGFnRW5jb3VudGVyZWQgJiYgYWN0aW9uICE9PSBOZXR3b3JrRXJyb3JBY3Rpb24uUmVtb3ZlQWx0ZXJuYXRlUGVybWFuZW50bHkpIHtcbiAgICAgICAgICBlcnJvckFjdGlvbi5yZXNvbHZlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud2FybihgJHtkYXRhLmRldGFpbHN9IHJlYWNoZWQgb3IgZXhjZWVkZWQgbWF4IHJldHJ5ICgke3JldHJ5Q291bnR9KWApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhY3Rpb24gPT09IE5ldHdvcmtFcnJvckFjdGlvbi5TZW5kQWx0ZXJuYXRlVG9QZW5hbHR5Qm94KSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19MRVZFTDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVSUk9SO1xuICAgIH1cbiAgICAvLyBQZXJmb3JtIG5leHQgYXN5bmMgdGljayBzb29uZXIgdG8gc3BlZWQgdXAgZXJyb3IgYWN0aW9uIHJlc29sdXRpb25cbiAgICB0aGlzLnRpY2tJbW1lZGlhdGUoKTtcbiAgfVxuICByZWR1Y2VMZW5ndGhBbmRGbHVzaEJ1ZmZlcihkYXRhKSB7XG4gICAgLy8gaWYgaW4gYXBwZW5kaW5nIHN0YXRlXG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcgfHwgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0VEKSB7XG4gICAgICBjb25zdCBmcmFnID0gZGF0YS5mcmFnO1xuICAgICAgY29uc3QgcGxheWxpc3RUeXBlID0gZGF0YS5wYXJlbnQ7XG4gICAgICBjb25zdCBidWZmZXJlZEluZm8gPSB0aGlzLmdldEZ3ZEJ1ZmZlckluZm8odGhpcy5tZWRpYUJ1ZmZlciwgcGxheWxpc3RUeXBlKTtcbiAgICAgIC8vIDAuNSA6IHRvbGVyYW5jZSBuZWVkZWQgYXMgc29tZSBicm93c2VycyBzdGFsbHMgcGxheWJhY2sgYmVmb3JlIHJlYWNoaW5nIGJ1ZmZlcmVkIGVuZFxuICAgICAgLy8gcmVkdWNlIG1heCBidWYgbGVuIGlmIGN1cnJlbnQgcG9zaXRpb24gaXMgYnVmZmVyZWRcbiAgICAgIGNvbnN0IGJ1ZmZlcmVkID0gYnVmZmVyZWRJbmZvICYmIGJ1ZmZlcmVkSW5mby5sZW4gPiAwLjU7XG4gICAgICBpZiAoYnVmZmVyZWQpIHtcbiAgICAgICAgdGhpcy5yZWR1Y2VNYXhCdWZmZXJMZW5ndGgoYnVmZmVyZWRJbmZvLmxlbiwgKGZyYWcgPT0gbnVsbCA/IHZvaWQgMCA6IGZyYWcuZHVyYXRpb24pIHx8IDEwKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZsdXNoQnVmZmVyID0gIWJ1ZmZlcmVkO1xuICAgICAgaWYgKGZsdXNoQnVmZmVyKSB7XG4gICAgICAgIC8vIGN1cnJlbnQgcG9zaXRpb24gaXMgbm90IGJ1ZmZlcmVkLCBidXQgYnJvd3NlciBpcyBzdGlsbCBjb21wbGFpbmluZyBhYm91dCBidWZmZXIgZnVsbCBlcnJvclxuICAgICAgICAvLyB0aGlzIGhhcHBlbnMgb24gSUUvRWRnZSwgcmVmZXIgdG8gaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvcHVsbC83MDhcbiAgICAgICAgLy8gaW4gdGhhdCBjYXNlIGZsdXNoIHRoZSB3aG9sZSBhdWRpbyBidWZmZXIgdG8gcmVjb3ZlclxuICAgICAgICB0aGlzLndhcm4oYEJ1ZmZlciBmdWxsIGVycm9yIHdoaWxlIG1lZGlhLmN1cnJlbnRUaW1lIGlzIG5vdCBidWZmZXJlZCwgZmx1c2ggJHtwbGF5bGlzdFR5cGV9IGJ1ZmZlcmApO1xuICAgICAgfVxuICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IGZyYWcuc3RhcnQ7XG4gICAgICB9XG4gICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgICByZXR1cm4gZmx1c2hCdWZmZXI7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXNldEZyYWdtZW50RXJyb3JzKGZpbHRlclR5cGUpIHtcbiAgICBpZiAoZmlsdGVyVHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuQVVESU8pIHtcbiAgICAgIC8vIFJlc2V0IGN1cnJlbnQgZnJhZ21lbnQgc2luY2UgYXVkaW8gdHJhY2sgYXVkaW8gaXMgZXNzZW50aWFsIGFuZCBtYXkgbm90IGhhdmUgYSBmYWlsLW92ZXIgdHJhY2tcbiAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgICAvLyBGcmFnbWVudCBlcnJvcnMgdGhhdCByZXN1bHQgaW4gYSBsZXZlbCBzd2l0Y2ggb3IgcmVkdW5kYW50IGZhaWwtb3ZlclxuICAgIC8vIHNob3VsZCByZXNldCB0aGUgc3RyZWFtIGNvbnRyb2xsZXIgc3RhdGUgdG8gaWRsZVxuICAgIGlmICghdGhpcy5obHMuaGFzRW5vdWdoVG9TdGFydCkge1xuICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IFN0YXRlLlNUT1BQRUQpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIH1cbiAgfVxuICBhZnRlckJ1ZmZlckZsdXNoZWQobWVkaWEsIGJ1ZmZlclR5cGUsIHBsYXlsaXN0VHlwZSkge1xuICAgIGlmICghbWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQWZ0ZXIgc3VjY2Vzc2Z1bCBidWZmZXIgZmx1c2hpbmcsIGZpbHRlciBmbHVzaGVkIGZyYWdtZW50cyBmcm9tIGJ1ZmZlcmVkRnJhZ3MgdXNlIG1lZGlhQnVmZmVyZWQgaW5zdGVhZCBvZiBtZWRpYVxuICAgIC8vIChzbyB0aGF0IHdlIHdpbGwgY2hlY2sgYWdhaW5zdCB2aWRlby5idWZmZXJlZCByYW5nZXMgaW4gY2FzZSBvZiBhbHQgYXVkaW8gdHJhY2spXG4gICAgY29uc3QgYnVmZmVyZWRUaW1lUmFuZ2VzID0gQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKG1lZGlhKTtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5kZXRlY3RFdmljdGVkRnJhZ21lbnRzKGJ1ZmZlclR5cGUsIGJ1ZmZlcmVkVGltZVJhbmdlcywgcGxheWxpc3RUeXBlKTtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuRU5ERUQpIHtcbiAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICB9XG4gIH1cbiAgcmVzZXRMb2FkaW5nU3RhdGUoKSB7XG4gICAgdGhpcy5sb2coJ1Jlc2V0IGxvYWRpbmcgc3RhdGUnKTtcbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IFN0YXRlLlNUT1BQRUQpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIH1cbiAgfVxuICByZXNldFN0YXJ0V2hlbk5vdExvYWRlZChsZXZlbCkge1xuICAgIC8vIGlmIGxvYWRlZG1ldGFkYXRhIGlzIG5vdCBzZXQsIGl0IG1lYW5zIHRoYXQgZmlyc3QgZnJhZyByZXF1ZXN0IGZhaWxlZFxuICAgIC8vIGluIHRoYXQgY2FzZSwgcmVzZXQgc3RhcnRGcmFnUmVxdWVzdGVkIGZsYWdcbiAgICBpZiAoIXRoaXMuaGxzLmhhc0Vub3VnaFRvU3RhcnQpIHtcbiAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICBjb25zdCBkZXRhaWxzID0gbGV2ZWwgPyBsZXZlbC5kZXRhaWxzIDogbnVsbDtcbiAgICAgIGlmIChkZXRhaWxzICE9IG51bGwgJiYgZGV0YWlscy5saXZlKSB7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgc3RhcnQgcG9zaXRpb24gYW5kIHJldHVybiB0byBJRExFIHRvIHJlY292ZXIgbGl2ZSBzdGFydFxuICAgICAgICB0aGlzLmxvZyhgcmVzZXR0aW5nIHN0YXJ0UG9zaXRpb24gZm9yIGxpdmUgc3RhcnRgKTtcbiAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gLTE7XG4gICAgICAgIHRoaXMuc2V0U3RhcnRQb3NpdGlvbihkZXRhaWxzLCBkZXRhaWxzLmZyYWdtZW50U3RhcnQpO1xuICAgICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb247XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlc2V0V2hlbk1pc3NpbmdDb250ZXh0KGNodW5rTWV0YSkge1xuICAgIHRoaXMud2FybihgVGhlIGxvYWRpbmcgY29udGV4dCBjaGFuZ2VkIHdoaWxlIGJ1ZmZlcmluZyBmcmFnbWVudCAke2NodW5rTWV0YS5zbn0gb2YgJHt0aGlzLnBsYXlsaXN0TGFiZWwoKX0gJHtjaHVua01ldGEubGV2ZWx9LiBUaGlzIGNodW5rIHdpbGwgbm90IGJlIGJ1ZmZlcmVkLmApO1xuICAgIHRoaXMucmVtb3ZlVW5idWZmZXJlZEZyYWdzKCk7XG4gICAgdGhpcy5yZXNldFN0YXJ0V2hlbk5vdExvYWRlZCh0aGlzLmxldmVsTGFzdExvYWRlZCk7XG4gICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICB9XG4gIHJlbW92ZVVuYnVmZmVyZWRGcmFncyhzdGFydCA9IDApIHtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudHNJblJhbmdlKHN0YXJ0LCBJbmZpbml0eSwgdGhpcy5wbGF5bGlzdFR5cGUsIGZhbHNlLCB0cnVlKTtcbiAgfVxuICB1cGRhdGVMZXZlbFRpbWluZyhmcmFnLCBwYXJ0LCBsZXZlbCwgcGFydGlhbCkge1xuICAgIGNvbnN0IGRldGFpbHMgPSBsZXZlbC5kZXRhaWxzO1xuICAgIGlmICghZGV0YWlscykge1xuICAgICAgdGhpcy53YXJuKCdsZXZlbC5kZXRhaWxzIHVuZGVmaW5lZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWQgPSBPYmplY3Qua2V5cyhmcmFnLmVsZW1lbnRhcnlTdHJlYW1zKS5yZWR1Y2UoKHJlc3VsdCwgdHlwZSkgPT4ge1xuICAgICAgY29uc3QgaW5mbyA9IGZyYWcuZWxlbWVudGFyeVN0cmVhbXNbdHlwZV07XG4gICAgICBpZiAoaW5mbykge1xuICAgICAgICBjb25zdCBwYXJzZWREdXJhdGlvbiA9IGluZm8uZW5kUFRTIC0gaW5mby5zdGFydFBUUztcbiAgICAgICAgaWYgKHBhcnNlZER1cmF0aW9uIDw9IDApIHtcbiAgICAgICAgICAvLyBEZXN0cm95IHRoZSB0cmFuc211eGVyIGFmdGVyIGl0J3MgbmV4dCB0aW1lIG9mZnNldCBmYWlsZWQgdG8gYWR2YW5jZSBiZWNhdXNlIGR1cmF0aW9uIHdhcyA8PSAwLlxuICAgICAgICAgIC8vIFRoZSBuZXcgdHJhbnNtdXhlciB3aWxsIGJlIGNvbmZpZ3VyZWQgd2l0aCBhIHRpbWUgb2Zmc2V0IG1hdGNoaW5nIHRoZSBuZXh0IGZyYWdtZW50IHN0YXJ0LFxuICAgICAgICAgIC8vIHByZXZlbnRpbmcgdGhlIHRpbWVsaW5lIGZyb20gc2hpZnRpbmcuXG4gICAgICAgICAgdGhpcy53YXJuKGBDb3VsZCBub3QgcGFyc2UgZnJhZ21lbnQgJHtmcmFnLnNufSAke3R5cGV9IGR1cmF0aW9uIHJlbGlhYmx5ICgke3BhcnNlZER1cmF0aW9ufSlgKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0IHx8IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRyaWZ0ID0gcGFydGlhbCA/IDAgOiB1cGRhdGVGcmFnUFRTRFRTKGRldGFpbHMsIGZyYWcsIGluZm8uc3RhcnRQVFMsIGluZm8uZW5kUFRTLCBpbmZvLnN0YXJ0RFRTLCBpbmZvLmVuZERUUyk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkxFVkVMX1BUU19VUERBVEVELCB7XG4gICAgICAgICAgZGV0YWlscyxcbiAgICAgICAgICBsZXZlbCxcbiAgICAgICAgICBkcmlmdCxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgc3RhcnQ6IGluZm8uc3RhcnRQVFMsXG4gICAgICAgICAgZW5kOiBpbmZvLmVuZFBUU1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIGZhbHNlKTtcbiAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgdmFyIF90aGlzJHRyYW5zbXV4ZXI7XG4gICAgICBpZiAobGV2ZWwuZnJhZ21lbnRFcnJvciA9PT0gMCkge1xuICAgICAgICAvLyBNYXJrIGFuZCB0cmFjayB0aGUgb2RkIGVtcHR5IHNlZ21lbnQgYXMgYSBnYXAgdG8gYXZvaWQgcmVsb2FkaW5nXG4gICAgICAgIHRoaXMudHJlYXRBc0dhcChmcmFnLCBsZXZlbCk7XG4gICAgICB9XG4gICAgICBpZiAoKChfdGhpcyR0cmFuc211eGVyID0gdGhpcy50cmFuc211eGVyKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkdHJhbnNtdXhlci5lcnJvcikgPT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYEZvdW5kIG5vIG1lZGlhIGluIGZyYWdtZW50ICR7ZnJhZy5zbn0gb2YgJHt0aGlzLnBsYXlsaXN0TGFiZWwoKX0gJHtmcmFnLmxldmVsfSByZXNldHRpbmcgdHJhbnNtdXhlciB0byBmYWxsYmFjayB0byBwbGF5bGlzdCB0aW1pbmdgKTtcbiAgICAgICAgdGhpcy53YXJuKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUixcbiAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgZnJhZyxcbiAgICAgICAgICByZWFzb246IGBGb3VuZCBubyBtZWRpYSBpbiBtc24gJHtmcmFnLnNufSBvZiAke3RoaXMucGxheWxpc3RMYWJlbCgpfSBcIiR7bGV2ZWwudXJsfVwiYFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCF0aGlzLmhscykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc2V0VHJhbnNtdXhlcigpO1xuICAgICAgfVxuICAgICAgLy8gRm9yIHRoaXMgZXJyb3IgZmFsbHRocm91Z2guIE1hcmtpbmcgcGFyc2VkIHdpbGwgYWxsb3cgYWR2YW5jaW5nIHRvIG5leHQgZnJhZ21lbnQuXG4gICAgfVxuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5QQVJTRUQ7XG4gICAgdGhpcy5sb2coYFBhcnNlZCAke2ZyYWcudHlwZX0gc246ICR7ZnJhZy5zbn0ke3BhcnQgPyAnIHBhcnQ6ICcgKyBwYXJ0LmluZGV4IDogJyd9IG9mICR7dGhpcy5mcmFnSW5mbyhmcmFnLCBmYWxzZSwgcGFydCl9KWApO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfUEFSU0VELCB7XG4gICAgICBmcmFnLFxuICAgICAgcGFydFxuICAgIH0pO1xuICB9XG4gIHBsYXlsaXN0TGFiZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMucGxheWxpc3RUeXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOID8gJ2xldmVsJyA6ICd0cmFjayc7XG4gIH1cbiAgZnJhZ0luZm8oZnJhZywgcHRzID0gdHJ1ZSwgcGFydCkge1xuICAgIHZhciBfcmVmLCBfcmVmMjtcbiAgICByZXR1cm4gYCR7dGhpcy5wbGF5bGlzdExhYmVsKCl9ICR7ZnJhZy5sZXZlbH0gKCR7cGFydCA/ICdwYXJ0JyA6ICdmcmFnJ306WyR7KChfcmVmID0gcHRzICYmICFwYXJ0ID8gZnJhZy5zdGFydFBUUyA6IChwYXJ0IHx8IGZyYWcpLnN0YXJ0KSAhPSBudWxsID8gX3JlZiA6IE5hTikudG9GaXhlZCgzKX0tJHsoKF9yZWYyID0gcHRzICYmICFwYXJ0ID8gZnJhZy5lbmRQVFMgOiAocGFydCB8fCBmcmFnKS5lbmQpICE9IG51bGwgPyBfcmVmMiA6IE5hTikudG9GaXhlZCgzKX1dJHtwYXJ0ICYmIGZyYWcudHlwZSA9PT0gJ21haW4nID8gJ0lOREVQRU5ERU5UPScgKyAocGFydC5pbmRlcGVuZGVudCA/ICdZRVMnIDogJ05PJykgOiAnJ31gO1xuICB9XG4gIHRyZWF0QXNHYXAoZnJhZywgbGV2ZWwpIHtcbiAgICBpZiAobGV2ZWwpIHtcbiAgICAgIGxldmVsLmZyYWdtZW50RXJyb3IrKztcbiAgICB9XG4gICAgZnJhZy5nYXAgPSB0cnVlO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLmZyYWdCdWZmZXJlZChmcmFnLCB0cnVlKTtcbiAgfVxuICByZXNldFRyYW5zbXV4ZXIoKSB7XG4gICAgdmFyIF90aGlzJHRyYW5zbXV4ZXIyO1xuICAgIChfdGhpcyR0cmFuc211eGVyMiA9IHRoaXMudHJhbnNtdXhlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHRyYW5zbXV4ZXIyLnJlc2V0KCk7XG4gIH1cbiAgcmVjb3ZlcldvcmtlckVycm9yKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5ldmVudCA9PT0gJ2RlbXV4ZXJXb3JrZXInKSB7XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVBbGxGcmFnbWVudHMoKTtcbiAgICAgIGlmICh0aGlzLnRyYW5zbXV4ZXIpIHtcbiAgICAgICAgdGhpcy50cmFuc211eGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy50cmFuc211eGVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVzZXRTdGFydFdoZW5Ob3RMb2FkZWQodGhpcy5sZXZlbExhc3RMb2FkZWQpO1xuICAgICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICAgIH1cbiAgfVxuICBzZXQgc3RhdGUobmV4dFN0YXRlKSB7XG4gICAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgIGlmIChwcmV2aW91c1N0YXRlICE9PSBuZXh0U3RhdGUpIHtcbiAgICAgIHRoaXMuX3N0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgdGhpcy5sb2coYCR7cHJldmlvdXNTdGF0ZX0tPiR7bmV4dFN0YXRlfWApO1xuICAgIH1cbiAgfVxuICBnZXQgc3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICB9XG59XG5mdW5jdGlvbiBpbnRlcnN0aXRpYWxzRW5hYmxlZChjb25maWcpIHtcbiAgcmV0dXJuICEhY29uZmlnLmludGVyc3RpdGlhbHNDb250cm9sbGVyICYmIGNvbmZpZy5lbmFibGVJbnRlcnN0aXRpYWxQbGF5YmFjayAhPT0gZmFsc2U7XG59XG5cbmNsYXNzIENodW5rQ2FjaGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgIHRoaXMuZGF0YUxlbmd0aCA9IDA7XG4gIH1cbiAgcHVzaChjaHVuaykge1xuICAgIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xuICAgIHRoaXMuZGF0YUxlbmd0aCArPSBjaHVuay5sZW5ndGg7XG4gIH1cbiAgZmx1c2goKSB7XG4gICAgY29uc3Qge1xuICAgICAgY2h1bmtzLFxuICAgICAgZGF0YUxlbmd0aFxuICAgIH0gPSB0aGlzO1xuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKCFjaHVua3MubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgfSBlbHNlIGlmIChjaHVua3MubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXN1bHQgPSBjaHVua3NbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGNvbmNhdFVpbnQ4QXJyYXlzKGNodW5rcywgZGF0YUxlbmd0aCk7XG4gICAgfVxuICAgIHRoaXMucmVzZXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuY2h1bmtzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5kYXRhTGVuZ3RoID0gMDtcbiAgfVxufVxuZnVuY3Rpb24gY29uY2F0VWludDhBcnJheXMoY2h1bmtzLCBkYXRhTGVuZ3RoKSB7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGRhdGFMZW5ndGgpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaHVuayA9IGNodW5rc1tpXTtcbiAgICByZXN1bHQuc2V0KGNodW5rLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBjaHVuay5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIGV2ZW50ZW1pdHRlcjMgPSB7ZXhwb3J0czoge319O1xuXG52YXIgaGFzUmVxdWlyZWRFdmVudGVtaXR0ZXIzO1xuXG5mdW5jdGlvbiByZXF1aXJlRXZlbnRlbWl0dGVyMyAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEV2ZW50ZW1pdHRlcjMpIHJldHVybiBldmVudGVtaXR0ZXIzLmV4cG9ydHM7XG5cdGhhc1JlcXVpcmVkRXZlbnRlbWl0dGVyMyA9IDE7XG5cdChmdW5jdGlvbiAobW9kdWxlKSB7XG5cblx0XHR2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuXHRcdCAgLCBwcmVmaXggPSAnfic7XG5cblx0XHQvKipcblx0XHQgKiBDb25zdHJ1Y3RvciB0byBjcmVhdGUgYSBzdG9yYWdlIGZvciBvdXIgYEVFYCBvYmplY3RzLlxuXHRcdCAqIEFuIGBFdmVudHNgIGluc3RhbmNlIGlzIGEgcGxhaW4gb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgYXJlIGV2ZW50IG5hbWVzLlxuXHRcdCAqXG5cdFx0ICogQGNvbnN0cnVjdG9yXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBFdmVudHMoKSB7fVxuXG5cdFx0Ly9cblx0XHQvLyBXZSB0cnkgdG8gbm90IGluaGVyaXQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuIEluIHNvbWUgZW5naW5lcyBjcmVhdGluZyBhblxuXHRcdC8vIGluc3RhbmNlIGluIHRoaXMgd2F5IGlzIGZhc3RlciB0aGFuIGNhbGxpbmcgYE9iamVjdC5jcmVhdGUobnVsbClgIGRpcmVjdGx5LlxuXHRcdC8vIElmIGBPYmplY3QuY3JlYXRlKG51bGwpYCBpcyBub3Qgc3VwcG9ydGVkIHdlIHByZWZpeCB0aGUgZXZlbnQgbmFtZXMgd2l0aCBhXG5cdFx0Ly8gY2hhcmFjdGVyIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBidWlsdC1pbiBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90XG5cdFx0Ly8gb3ZlcnJpZGRlbiBvciB1c2VkIGFzIGFuIGF0dGFjayB2ZWN0b3IuXG5cdFx0Ly9cblx0XHRpZiAoT2JqZWN0LmNyZWF0ZSkge1xuXHRcdCAgRXZlbnRzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cblx0XHQgIC8vXG5cdFx0ICAvLyBUaGlzIGhhY2sgaXMgbmVlZGVkIGJlY2F1c2UgdGhlIGBfX3Byb3RvX19gIHByb3BlcnR5IGlzIHN0aWxsIGluaGVyaXRlZCBpblxuXHRcdCAgLy8gc29tZSBvbGQgYnJvd3NlcnMgbGlrZSBBbmRyb2lkIDQsIGlQaG9uZSA1LjEsIE9wZXJhIDExIGFuZCBTYWZhcmkgNS5cblx0XHQgIC8vXG5cdFx0ICBpZiAoIW5ldyBFdmVudHMoKS5fX3Byb3RvX18pIHByZWZpeCA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIGV2ZW50IGxpc3RlbmVyLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuXHRcdCAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBbb25jZT1mYWxzZV0gU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cblx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIEVFKGZuLCBjb250ZXh0LCBvbmNlKSB7XG5cdFx0ICB0aGlzLmZuID0gZm47XG5cdFx0ICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuXHRcdCAgdGhpcy5vbmNlID0gb25jZSB8fCBmYWxzZTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG5cdFx0ICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuXHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cblx0XHQgKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuXHRcdCAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBhZGRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcblx0XHQgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcblx0XHQgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXHRcdCAgfVxuXG5cdFx0ICB2YXIgbGlzdGVuZXIgPSBuZXcgRUUoZm4sIGNvbnRleHQgfHwgZW1pdHRlciwgb25jZSlcblx0XHQgICAgLCBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG5cdFx0ICBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdKSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IGxpc3RlbmVyLCBlbWl0dGVyLl9ldmVudHNDb3VudCsrO1xuXHRcdCAgZWxzZSBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdLmZuKSBlbWl0dGVyLl9ldmVudHNbZXZ0XS5wdXNoKGxpc3RlbmVyKTtcblx0XHQgIGVsc2UgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBbZW1pdHRlci5fZXZlbnRzW2V2dF0sIGxpc3RlbmVyXTtcblxuXHRcdCAgcmV0dXJuIGVtaXR0ZXI7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogQ2xlYXIgZXZlbnQgYnkgbmFtZS5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG5cdFx0ICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2dCBUaGUgRXZlbnQgbmFtZS5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGNsZWFyRXZlbnQoZW1pdHRlciwgZXZ0KSB7XG5cdFx0ICBpZiAoLS1lbWl0dGVyLl9ldmVudHNDb3VudCA9PT0gMCkgZW1pdHRlci5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuXHRcdCAgZWxzZSBkZWxldGUgZW1pdHRlci5fZXZlbnRzW2V2dF07XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogTWluaW1hbCBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UgdGhhdCBpcyBtb2xkZWQgYWdhaW5zdCB0aGUgTm9kZS5qc1xuXHRcdCAqIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZS5cblx0XHQgKlxuXHRcdCAqIEBjb25zdHJ1Y3RvclxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG5cdFx0ICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG5cdFx0ICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJuIGFuIGFycmF5IGxpc3RpbmcgdGhlIGV2ZW50cyBmb3Igd2hpY2ggdGhlIGVtaXR0ZXIgaGFzIHJlZ2lzdGVyZWRcblx0XHQgKiBsaXN0ZW5lcnMuXG5cdFx0ICpcblx0XHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqL1xuXHRcdEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG5cdFx0ICB2YXIgbmFtZXMgPSBbXVxuXHRcdCAgICAsIGV2ZW50c1xuXHRcdCAgICAsIG5hbWU7XG5cblx0XHQgIGlmICh0aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgcmV0dXJuIG5hbWVzO1xuXG5cdFx0ICBmb3IgKG5hbWUgaW4gKGV2ZW50cyA9IHRoaXMuX2V2ZW50cykpIHtcblx0XHQgICAgaWYgKGhhcy5jYWxsKGV2ZW50cywgbmFtZSkpIG5hbWVzLnB1c2gocHJlZml4ID8gbmFtZS5zbGljZSgxKSA6IG5hbWUpO1xuXHRcdCAgfVxuXG5cdFx0ICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdCAgICByZXR1cm4gbmFtZXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZXZlbnRzKSk7XG5cdFx0ICB9XG5cblx0XHQgIHJldHVybiBuYW1lcztcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJuIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cblx0XHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSByZWdpc3RlcmVkIGxpc3RlbmVycy5cblx0XHQgKiBAcHVibGljXG5cdFx0ICovXG5cdFx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnMoZXZlbnQpIHtcblx0XHQgIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG5cdFx0ICAgICwgaGFuZGxlcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuXHRcdCAgaWYgKCFoYW5kbGVycykgcmV0dXJuIFtdO1xuXHRcdCAgaWYgKGhhbmRsZXJzLmZuKSByZXR1cm4gW2hhbmRsZXJzLmZuXTtcblxuXHRcdCAgZm9yICh2YXIgaSA9IDAsIGwgPSBoYW5kbGVycy5sZW5ndGgsIGVlID0gbmV3IEFycmF5KGwpOyBpIDwgbDsgaSsrKSB7XG5cdFx0ICAgIGVlW2ldID0gaGFuZGxlcnNbaV0uZm47XG5cdFx0ICB9XG5cblx0XHQgIHJldHVybiBlZTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJuIHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIGxpc3RlbmluZyB0byBhIGdpdmVuIGV2ZW50LlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuXHRcdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgbGlzdGVuZXJzLlxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKi9cblx0XHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBsaXN0ZW5lckNvdW50KGV2ZW50KSB7XG5cdFx0ICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuXHRcdCAgICAsIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG5cdFx0ICBpZiAoIWxpc3RlbmVycykgcmV0dXJuIDA7XG5cdFx0ICBpZiAobGlzdGVuZXJzLmZuKSByZXR1cm4gMTtcblx0XHQgIHJldHVybiBsaXN0ZW5lcnMubGVuZ3RoO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBDYWxscyBlYWNoIG9mIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cblx0XHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBldmVudCBoYWQgbGlzdGVuZXJzLCBlbHNlIGBmYWxzZWAuXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqL1xuXHRcdEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuXHRcdCAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cblx0XHQgIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiBmYWxzZTtcblxuXHRcdCAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdXG5cdFx0ICAgICwgbGVuID0gYXJndW1lbnRzLmxlbmd0aFxuXHRcdCAgICAsIGFyZ3Ncblx0XHQgICAgLCBpO1xuXG5cdFx0ICBpZiAobGlzdGVuZXJzLmZuKSB7XG5cdFx0ICAgIGlmIChsaXN0ZW5lcnMub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG5cdFx0ICAgIHN3aXRjaCAobGVuKSB7XG5cdFx0ICAgICAgY2FzZSAxOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQpLCB0cnVlO1xuXHRcdCAgICAgIGNhc2UgMjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSksIHRydWU7XG5cdFx0ICAgICAgY2FzZSAzOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiksIHRydWU7XG5cdFx0ICAgICAgY2FzZSA0OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMpLCB0cnVlO1xuXHRcdCAgICAgIGNhc2UgNTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCksIHRydWU7XG5cdFx0ICAgICAgY2FzZSA2OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0LCBhNSksIHRydWU7XG5cdFx0ICAgIH1cblxuXHRcdCAgICBmb3IgKGkgPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGkgPCBsZW47IGkrKykge1xuXHRcdCAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuXHRcdCAgICB9XG5cblx0XHQgICAgbGlzdGVuZXJzLmZuLmFwcGx5KGxpc3RlbmVycy5jb250ZXh0LCBhcmdzKTtcblx0XHQgIH0gZWxzZSB7XG5cdFx0ICAgIHZhciBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoXG5cdFx0ICAgICAgLCBqO1xuXG5cdFx0ICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdCAgICAgIGlmIChsaXN0ZW5lcnNbaV0ub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzW2ldLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG5cdFx0ICAgICAgc3dpdGNoIChsZW4pIHtcblx0XHQgICAgICAgIGNhc2UgMTogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQpOyBicmVhaztcblx0XHQgICAgICAgIGNhc2UgMjogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExKTsgYnJlYWs7XG5cdFx0ICAgICAgICBjYXNlIDM6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIpOyBicmVhaztcblx0XHQgICAgICAgIGNhc2UgNDogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMiwgYTMpOyBicmVhaztcblx0XHQgICAgICAgIGRlZmF1bHQ6XG5cdFx0ICAgICAgICAgIGlmICghYXJncykgZm9yIChqID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBqIDwgbGVuOyBqKyspIHtcblx0XHQgICAgICAgICAgICBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcblx0XHQgICAgICAgICAgfVxuXG5cdFx0ICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5hcHBseShsaXN0ZW5lcnNbaV0uY29udGV4dCwgYXJncyk7XG5cdFx0ICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICB9XG5cblx0XHQgIHJldHVybiB0cnVlO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cblx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG5cdFx0ICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG5cdFx0ICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKi9cblx0XHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGZuLCBjb250ZXh0KSB7XG5cdFx0ICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCBmYWxzZSk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEFkZCBhIG9uZS10aW1lIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuXHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cblx0XHQgKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cblx0XHQgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqL1xuXHRcdEV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UoZXZlbnQsIGZuLCBjb250ZXh0KSB7XG5cdFx0ICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCB0cnVlKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlIHRoZSBsaXN0ZW5lcnMgb2YgYSBnaXZlbiBldmVudC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cblx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgbWF0Y2ggdGhpcyBmdW5jdGlvbi5cblx0XHQgKiBAcGFyYW0geyp9IGNvbnRleHQgT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IGhhdmUgdGhpcyBjb250ZXh0LlxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBPbmx5IHJlbW92ZSBvbmUtdGltZSBsaXN0ZW5lcnMuXG5cdFx0ICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKi9cblx0XHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG5cdFx0ICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuXHRcdCAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIHRoaXM7XG5cdFx0ICBpZiAoIWZuKSB7XG5cdFx0ICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcblx0XHQgICAgcmV0dXJuIHRoaXM7XG5cdFx0ICB9XG5cblx0XHQgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuXHRcdCAgaWYgKGxpc3RlbmVycy5mbikge1xuXHRcdCAgICBpZiAoXG5cdFx0ICAgICAgbGlzdGVuZXJzLmZuID09PSBmbiAmJlxuXHRcdCAgICAgICghb25jZSB8fCBsaXN0ZW5lcnMub25jZSkgJiZcblx0XHQgICAgICAoIWNvbnRleHQgfHwgbGlzdGVuZXJzLmNvbnRleHQgPT09IGNvbnRleHQpXG5cdFx0ICAgICkge1xuXHRcdCAgICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcblx0XHQgICAgfVxuXHRcdCAgfSBlbHNlIHtcblx0XHQgICAgZm9yICh2YXIgaSA9IDAsIGV2ZW50cyA9IFtdLCBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHQgICAgICBpZiAoXG5cdFx0ICAgICAgICBsaXN0ZW5lcnNbaV0uZm4gIT09IGZuIHx8XG5cdFx0ICAgICAgICAob25jZSAmJiAhbGlzdGVuZXJzW2ldLm9uY2UpIHx8XG5cdFx0ICAgICAgICAoY29udGV4dCAmJiBsaXN0ZW5lcnNbaV0uY29udGV4dCAhPT0gY29udGV4dClcblx0XHQgICAgICApIHtcblx0XHQgICAgICAgIGV2ZW50cy5wdXNoKGxpc3RlbmVyc1tpXSk7XG5cdFx0ICAgICAgfVxuXHRcdCAgICB9XG5cblx0XHQgICAgLy9cblx0XHQgICAgLy8gUmVzZXQgdGhlIGFycmF5LCBvciByZW1vdmUgaXQgY29tcGxldGVseSBpZiB3ZSBoYXZlIG5vIG1vcmUgbGlzdGVuZXJzLlxuXHRcdCAgICAvL1xuXHRcdCAgICBpZiAoZXZlbnRzLmxlbmd0aCkgdGhpcy5fZXZlbnRzW2V2dF0gPSBldmVudHMubGVuZ3RoID09PSAxID8gZXZlbnRzWzBdIDogZXZlbnRzO1xuXHRcdCAgICBlbHNlIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcblx0XHQgIH1cblxuXHRcdCAgcmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZSBhbGwgbGlzdGVuZXJzLCBvciB0aG9zZSBvZiB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IFtldmVudF0gVGhlIGV2ZW50IG5hbWUuXG5cdFx0ICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKi9cblx0XHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuXHRcdCAgdmFyIGV2dDtcblxuXHRcdCAgaWYgKGV2ZW50KSB7XG5cdFx0ICAgIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cdFx0ICAgIGlmICh0aGlzLl9ldmVudHNbZXZ0XSkgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuXHRcdCAgfSBlbHNlIHtcblx0XHQgICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuXHRcdCAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG5cdFx0ICB9XG5cblx0XHQgIHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHQvL1xuXHRcdC8vIEFsaWFzIG1ldGhvZHMgbmFtZXMgYmVjYXVzZSBwZW9wbGUgcm9sbCBsaWtlIHRoYXQuXG5cdFx0Ly9cblx0XHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cdFx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub247XG5cblx0XHQvL1xuXHRcdC8vIEV4cG9zZSB0aGUgcHJlZml4LlxuXHRcdC8vXG5cdFx0RXZlbnRFbWl0dGVyLnByZWZpeGVkID0gcHJlZml4O1xuXG5cdFx0Ly9cblx0XHQvLyBBbGxvdyBgRXZlbnRFbWl0dGVyYCB0byBiZSBpbXBvcnRlZCBhcyBtb2R1bGUgbmFtZXNwYWNlLlxuXHRcdC8vXG5cdFx0RXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuXHRcdC8vXG5cdFx0Ly8gRXhwb3NlIHRoZSBtb2R1bGUuXG5cdFx0Ly9cblx0XHR7XG5cdFx0ICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblx0XHR9IFxuXHR9IChldmVudGVtaXR0ZXIzKSk7XG5cdHJldHVybiBldmVudGVtaXR0ZXIzLmV4cG9ydHM7XG59XG5cbnZhciBldmVudGVtaXR0ZXIzRXhwb3J0cyA9IHJlcXVpcmVFdmVudGVtaXR0ZXIzKCk7XG52YXIgRXZlbnRFbWl0dGVyID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGV2ZW50ZW1pdHRlcjNFeHBvcnRzKTtcblxuY29uc3QgdmVyc2lvbiA9IFwiMS42LjdcIjtcblxuLy8gZW5zdXJlIHRoZSB3b3JrZXIgZW5kcyB1cCBpbiB0aGUgYnVuZGxlXG4vLyBJZiB0aGUgd29ya2VyIHNob3VsZCBub3QgYmUgaW5jbHVkZWQgdGhpcyBnZXRzIGFsaWFzZWQgdG8gZW1wdHkuanNcbmNvbnN0IHdvcmtlclN0b3JlID0ge307XG5mdW5jdGlvbiBoYXNVTURXb3JrZXIoKSB7XG4gIHJldHVybiB0eXBlb2YgX19ITFNfV09SS0VSX0JVTkRMRV9fID09PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gaW5qZWN0V29ya2VyKCkge1xuICBjb25zdCB3b3JrZXJDb250ZXh0ID0gd29ya2VyU3RvcmVbdmVyc2lvbl07XG4gIGlmICh3b3JrZXJDb250ZXh0KSB7XG4gICAgd29ya2VyQ29udGV4dC5jbGllbnRDb3VudCsrO1xuICAgIHJldHVybiB3b3JrZXJDb250ZXh0O1xuICB9XG4gIGNvbnN0IGJsb2IgPSBuZXcgc2VsZi5CbG9iKFtgdmFyIGV4cG9ydHM9e307dmFyIG1vZHVsZT17ZXhwb3J0czpleHBvcnRzfTtmdW5jdGlvbiBkZWZpbmUoZil7ZigpfTtkZWZpbmUuYW1kPXRydWU7KCR7X19ITFNfV09SS0VSX0JVTkRMRV9fLnRvU3RyaW5nKCl9KSh0cnVlKTtgXSwge1xuICAgIHR5cGU6ICd0ZXh0L2phdmFzY3JpcHQnXG4gIH0pO1xuICBjb25zdCBvYmplY3RVUkwgPSBzZWxmLlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gIGNvbnN0IHdvcmtlciA9IG5ldyBzZWxmLldvcmtlcihvYmplY3RVUkwpO1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgd29ya2VyLFxuICAgIG9iamVjdFVSTCxcbiAgICBjbGllbnRDb3VudDogMVxuICB9O1xuICB3b3JrZXJTdG9yZVt2ZXJzaW9uXSA9IHJlc3VsdDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGxvYWRXb3JrZXIocGF0aCkge1xuICBjb25zdCB3b3JrZXJDb250ZXh0ID0gd29ya2VyU3RvcmVbcGF0aF07XG4gIGlmICh3b3JrZXJDb250ZXh0KSB7XG4gICAgd29ya2VyQ29udGV4dC5jbGllbnRDb3VudCsrO1xuICAgIHJldHVybiB3b3JrZXJDb250ZXh0O1xuICB9XG4gIGNvbnN0IHNjcmlwdFVSTCA9IG5ldyBzZWxmLlVSTChwYXRoLCBzZWxmLmxvY2F0aW9uLmhyZWYpLmhyZWY7XG4gIGNvbnN0IHdvcmtlciA9IG5ldyBzZWxmLldvcmtlcihzY3JpcHRVUkwpO1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgd29ya2VyLFxuICAgIHNjcmlwdFVSTCxcbiAgICBjbGllbnRDb3VudDogMVxuICB9O1xuICB3b3JrZXJTdG9yZVtwYXRoXSA9IHJlc3VsdDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHJlbW92ZVdvcmtlckZyb21TdG9yZShwYXRoKSB7XG4gIGNvbnN0IHdvcmtlckNvbnRleHQgPSB3b3JrZXJTdG9yZVtwYXRoIHx8IHZlcnNpb25dO1xuICBpZiAod29ya2VyQ29udGV4dCkge1xuICAgIGNvbnN0IGNsaWVudENvdW50ID0gd29ya2VyQ29udGV4dC5jbGllbnRDb3VudC0tO1xuICAgIGlmIChjbGllbnRDb3VudCA9PT0gMSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB3b3JrZXIsXG4gICAgICAgIG9iamVjdFVSTFxuICAgICAgfSA9IHdvcmtlckNvbnRleHQ7XG4gICAgICBkZWxldGUgd29ya2VyU3RvcmVbcGF0aCB8fCB2ZXJzaW9uXTtcbiAgICAgIGlmIChvYmplY3RVUkwpIHtcbiAgICAgICAgLy8gcmV2b2tlIHRoZSBPYmplY3QgVVJMIHRoYXQgd2FzIHVzZWQgdG8gY3JlYXRlIHRyYW5zbXV4ZXIgd29ya2VyLCBzbyBhcyBub3QgdG8gbGVhayBpdFxuICAgICAgICBzZWxmLlVSTC5yZXZva2VPYmplY3RVUkwob2JqZWN0VVJMKTtcbiAgICAgIH1cbiAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYW4gSUQzIGZvb3RlciBjYW4gYmUgZm91bmQgYXQgb2Zmc2V0IGluIGRhdGFcbiAqXG4gKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIHNlYXJjaCBpblxuICogQHBhcmFtIG9mZnNldCAtIFRoZSBvZmZzZXQgYXQgd2hpY2ggdG8gc3RhcnQgc2VhcmNoaW5nXG4gKlxuICogQHJldHVybnMgYHRydWVgIGlmIGFuIElEMyBmb290ZXIgaXMgZm91bmRcbiAqXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBAZ3JvdXAgSUQzXG4gKi9cbmZ1bmN0aW9uIGlzSWQzRm9vdGVyKGRhdGEsIG9mZnNldCkge1xuICAvKlxuICAgKiBUaGUgZm9vdGVyIGlzIGEgY29weSBvZiB0aGUgaGVhZGVyLCBidXQgd2l0aCBhIGRpZmZlcmVudCBpZGVudGlmaWVyXG4gICAqL1xuICBpZiAob2Zmc2V0ICsgMTAgPD0gZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBsb29rIGZvciAnM0RJJyBpZGVudGlmaWVyXG4gICAgaWYgKGRhdGFbb2Zmc2V0XSA9PT0gMHgzMyAmJiBkYXRhW29mZnNldCArIDFdID09PSAweDQ0ICYmIGRhdGFbb2Zmc2V0ICsgMl0gPT09IDB4NDkpIHtcbiAgICAgIC8vIGNoZWNrIHZlcnNpb24gaXMgd2l0aGluIHJhbmdlXG4gICAgICBpZiAoZGF0YVtvZmZzZXQgKyAzXSA8IDB4ZmYgJiYgZGF0YVtvZmZzZXQgKyA0XSA8IDB4ZmYpIHtcbiAgICAgICAgLy8gY2hlY2sgc2l6ZSBpcyB3aXRoaW4gcmFuZ2VcbiAgICAgICAgaWYgKGRhdGFbb2Zmc2V0ICsgNl0gPCAweDgwICYmIGRhdGFbb2Zmc2V0ICsgN10gPCAweDgwICYmIGRhdGFbb2Zmc2V0ICsgOF0gPCAweDgwICYmIGRhdGFbb2Zmc2V0ICsgOV0gPCAweDgwKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhbiBJRDMgaGVhZGVyIGNhbiBiZSBmb3VuZCBhdCBvZmZzZXQgaW4gZGF0YVxuICpcbiAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gc2VhcmNoIGluXG4gKiBAcGFyYW0gb2Zmc2V0IC0gVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCBzZWFyY2hpbmdcbiAqXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgYW4gSUQzIGhlYWRlciBpcyBmb3VuZFxuICpcbiAqIEBpbnRlcm5hbFxuICpcbiAqIEBncm91cCBJRDNcbiAqL1xuZnVuY3Rpb24gaXNJZDNIZWFkZXIoZGF0YSwgb2Zmc2V0KSB7XG4gIC8qXG4gICAqIGh0dHA6Ly9pZDMub3JnL2lkM3YyLjMuMFxuICAgKiBbMF0gICAgID0gJ0knXG4gICAqIFsxXSAgICAgPSAnRCdcbiAgICogWzJdICAgICA9ICczJ1xuICAgKiBbMyw0XSAgID0ge1ZlcnNpb259XG4gICAqIFs1XSAgICAgPSB7RmxhZ3N9XG4gICAqIFs2LTldICAgPSB7SUQzIFNpemV9XG4gICAqXG4gICAqIEFuIElEM3YyIHRhZyBjYW4gYmUgZGV0ZWN0ZWQgd2l0aCB0aGUgZm9sbG93aW5nIHBhdHRlcm46XG4gICAqICAkNDkgNDQgMzMgeXkgeXkgeHggenogenogenogenpcbiAgICogV2hlcmUgeXkgaXMgbGVzcyB0aGFuICRGRiwgeHggaXMgdGhlICdmbGFncycgYnl0ZSBhbmQgenogaXMgbGVzcyB0aGFuICQ4MFxuICAgKi9cbiAgaWYgKG9mZnNldCArIDEwIDw9IGRhdGEubGVuZ3RoKSB7XG4gICAgLy8gbG9vayBmb3IgJ0lEMycgaWRlbnRpZmllclxuICAgIGlmIChkYXRhW29mZnNldF0gPT09IDB4NDkgJiYgZGF0YVtvZmZzZXQgKyAxXSA9PT0gMHg0NCAmJiBkYXRhW29mZnNldCArIDJdID09PSAweDMzKSB7XG4gICAgICAvLyBjaGVjayB2ZXJzaW9uIGlzIHdpdGhpbiByYW5nZVxuICAgICAgaWYgKGRhdGFbb2Zmc2V0ICsgM10gPCAweGZmICYmIGRhdGFbb2Zmc2V0ICsgNF0gPCAweGZmKSB7XG4gICAgICAgIC8vIGNoZWNrIHNpemUgaXMgd2l0aGluIHJhbmdlXG4gICAgICAgIGlmIChkYXRhW29mZnNldCArIDZdIDwgMHg4MCAmJiBkYXRhW29mZnNldCArIDddIDwgMHg4MCAmJiBkYXRhW29mZnNldCArIDhdIDwgMHg4MCAmJiBkYXRhW29mZnNldCArIDldIDwgMHg4MCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZWFkIElEMyBzaXplXG4gKlxuICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byByZWFkIGZyb21cbiAqIEBwYXJhbSBvZmZzZXQgLSBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRvIHN0YXJ0IHJlYWRpbmdcbiAqXG4gKiBAcmV0dXJucyBUaGUgc2l6ZVxuICpcbiAqIEBpbnRlcm5hbFxuICpcbiAqIEBncm91cCBJRDNcbiAqL1xuZnVuY3Rpb24gcmVhZElkM1NpemUoZGF0YSwgb2Zmc2V0KSB7XG4gIGxldCBzaXplID0gMDtcbiAgc2l6ZSA9IChkYXRhW29mZnNldF0gJiAweDdmKSA8PCAyMTtcbiAgc2l6ZSB8PSAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4N2YpIDw8IDE0O1xuICBzaXplIHw9IChkYXRhW29mZnNldCArIDJdICYgMHg3ZikgPDwgNztcbiAgc2l6ZSB8PSBkYXRhW29mZnNldCArIDNdICYgMHg3ZjtcbiAgcmV0dXJuIHNpemU7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbnkgYWRqYWNlbnQgSUQzIHRhZ3MgZm91bmQgaW4gZGF0YSBzdGFydGluZyBhdCBvZmZzZXQsIGFzIG9uZSBibG9jayBvZiBkYXRhXG4gKlxuICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byBzZWFyY2ggaW5cbiAqIEBwYXJhbSBvZmZzZXQgLSBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRvIHN0YXJ0IHNlYXJjaGluZ1xuICpcbiAqIEByZXR1cm5zIFRoZSBibG9jayBvZiBkYXRhIGNvbnRhaW5pbmcgYW55IElEMyB0YWdzIGZvdW5kXG4gKiBvciBgdW5kZWZpbmVkYCBpZiBubyBoZWFkZXIgaXMgZm91bmQgYXQgdGhlIHN0YXJ0aW5nIG9mZnNldFxuICpcbiAqIEBpbnRlcm5hbFxuICpcbiAqIEBncm91cCBJRDNcbiAqL1xuZnVuY3Rpb24gZ2V0SWQzRGF0YShkYXRhLCBvZmZzZXQpIHtcbiAgY29uc3QgZnJvbnQgPSBvZmZzZXQ7XG4gIGxldCBsZW5ndGggPSAwO1xuICB3aGlsZSAoaXNJZDNIZWFkZXIoZGF0YSwgb2Zmc2V0KSkge1xuICAgIC8vIElEMyBoZWFkZXIgaXMgMTAgYnl0ZXNcbiAgICBsZW5ndGggKz0gMTA7XG4gICAgY29uc3Qgc2l6ZSA9IHJlYWRJZDNTaXplKGRhdGEsIG9mZnNldCArIDYpO1xuICAgIGxlbmd0aCArPSBzaXplO1xuICAgIGlmIChpc0lkM0Zvb3RlcihkYXRhLCBvZmZzZXQgKyAxMCkpIHtcbiAgICAgIC8vIElEMyBmb290ZXIgaXMgMTAgYnl0ZXNcbiAgICAgIGxlbmd0aCArPSAxMDtcbiAgICB9XG4gICAgb2Zmc2V0ICs9IGxlbmd0aDtcbiAgfVxuICBpZiAobGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBkYXRhLnN1YmFycmF5KGZyb250LCBmcm9udCArIGxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZ2V0QXVkaW9Db25maWcob2JzZXJ2ZXIsIGRhdGEsIG9mZnNldCwgbWFuaWZlc3RDb2RlYykge1xuICBjb25zdCBhZHRzU2FtcGxpbmdSYXRlcyA9IFs5NjAwMCwgODgyMDAsIDY0MDAwLCA0ODAwMCwgNDQxMDAsIDMyMDAwLCAyNDAwMCwgMjIwNTAsIDE2MDAwLCAxMjAwMCwgMTEwMjUsIDgwMDAsIDczNTBdO1xuICBjb25zdCBieXRlMiA9IGRhdGFbb2Zmc2V0ICsgMl07XG4gIGNvbnN0IGFkdHNTYW1wbGluZ0luZGV4ID0gYnl0ZTIgPj4gMiAmIDB4ZjtcbiAgaWYgKGFkdHNTYW1wbGluZ0luZGV4ID4gMTIpIHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgaW52YWxpZCBBRFRTIHNhbXBsaW5nIGluZGV4OiR7YWR0c1NhbXBsaW5nSW5kZXh9YCk7XG4gICAgb2JzZXJ2ZXIuZW1pdChFdmVudHMuRVJST1IsIEV2ZW50cy5FUlJPUiwge1xuICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsXG4gICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgIGVycm9yLFxuICAgICAgcmVhc29uOiBlcnJvci5tZXNzYWdlXG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIE1QRUctNCBBdWRpbyBPYmplY3QgVHlwZSAocHJvZmlsZV9PYmplY3RUeXBlKzEpXG4gIGNvbnN0IGFkdHNPYmplY3RUeXBlID0gKGJ5dGUyID4+IDYgJiAweDMpICsgMTtcbiAgY29uc3QgY2hhbm5lbENvdW50ID0gZGF0YVtvZmZzZXQgKyAzXSA+PiA2ICYgMHgzIHwgKGJ5dGUyICYgMSkgPDwgMjtcbiAgY29uc3QgY29kZWMgPSAnbXA0YS40MC4nICsgYWR0c09iamVjdFR5cGU7XG4gIC8qIHJlZmVyIHRvIGh0dHA6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwP3RpdGxlPU1QRUctNF9BdWRpbyNBdWRpb19TcGVjaWZpY19Db25maWdcbiAgICAgIElTTy9JRUMgMTQ0OTYtMyAtIFRhYmxlIDEuMTMg4oCUIFN5bnRheCBvZiBBdWRpb1NwZWNpZmljQ29uZmlnKClcbiAgICBBdWRpbyBQcm9maWxlIC8gQXVkaW8gT2JqZWN0IFR5cGVcbiAgICAwOiBOdWxsXG4gICAgMTogQUFDIE1haW5cbiAgICAyOiBBQUMgTEMgKExvdyBDb21wbGV4aXR5KVxuICAgIDM6IEFBQyBTU1IgKFNjYWxhYmxlIFNhbXBsZSBSYXRlKVxuICAgIDQ6IEFBQyBMVFAgKExvbmcgVGVybSBQcmVkaWN0aW9uKVxuICAgIDU6IFNCUiAoU3BlY3RyYWwgQmFuZCBSZXBsaWNhdGlvbilcbiAgICA2OiBBQUMgU2NhbGFibGVcbiAgIHNhbXBsaW5nIGZyZXFcbiAgICAwOiA5NjAwMCBIelxuICAgIDE6IDg4MjAwIEh6XG4gICAgMjogNjQwMDAgSHpcbiAgICAzOiA0ODAwMCBIelxuICAgIDQ6IDQ0MTAwIEh6XG4gICAgNTogMzIwMDAgSHpcbiAgICA2OiAyNDAwMCBIelxuICAgIDc6IDIyMDUwIEh6XG4gICAgODogMTYwMDAgSHpcbiAgICA5OiAxMjAwMCBIelxuICAgIDEwOiAxMTAyNSBIelxuICAgIDExOiA4MDAwIEh6XG4gICAgMTI6IDczNTAgSHpcbiAgICAxMzogUmVzZXJ2ZWRcbiAgICAxNDogUmVzZXJ2ZWRcbiAgICAxNTogZnJlcXVlbmN5IGlzIHdyaXR0ZW4gZXhwbGljdGx5XG4gICAgQ2hhbm5lbCBDb25maWd1cmF0aW9uc1xuICAgIFRoZXNlIGFyZSB0aGUgY2hhbm5lbCBjb25maWd1cmF0aW9uczpcbiAgICAwOiBEZWZpbmVkIGluIEFPVCBTcGVjaWZjIENvbmZpZ1xuICAgIDE6IDEgY2hhbm5lbDogZnJvbnQtY2VudGVyXG4gICAgMjogMiBjaGFubmVsczogZnJvbnQtbGVmdCwgZnJvbnQtcmlnaHRcbiAgKi9cbiAgLy8gYXVkaW9PYmplY3RUeXBlID0gcHJvZmlsZSA9PiBwcm9maWxlLCB0aGUgTVBFRy00IEF1ZGlvIE9iamVjdCBUeXBlIG1pbnVzIDFcbiAgY29uc3Qgc2FtcGxlcmF0ZSA9IGFkdHNTYW1wbGluZ1JhdGVzW2FkdHNTYW1wbGluZ0luZGV4XTtcbiAgbGV0IGFhY1NhbXBsZUluZGV4ID0gYWR0c1NhbXBsaW5nSW5kZXg7XG4gIGlmIChhZHRzT2JqZWN0VHlwZSA9PT0gNSB8fCBhZHRzT2JqZWN0VHlwZSA9PT0gMjkpIHtcbiAgICAvLyBIRS1BQUMgdXNlcyBTQlIgKFNwZWN0cmFsIEJhbmQgUmVwbGljYXRpb24pICwgaGlnaCBmcmVxdWVuY2llcyBhcmUgY29uc3RydWN0ZWQgZnJvbSBsb3cgZnJlcXVlbmNpZXNcbiAgICAvLyB0aGVyZSBpcyBhIGZhY3RvciAyIGJldHdlZW4gZnJhbWUgc2FtcGxlIHJhdGUgYW5kIG91dHB1dCBzYW1wbGUgcmF0ZVxuICAgIC8vIG11bHRpcGx5IGZyZXF1ZW5jeSBieSAyIChzZWUgdGFibGUgYWJvdmUsIGVxdWl2YWxlbnQgdG8gc3Vic3RyYWN0IDMpXG4gICAgYWFjU2FtcGxlSW5kZXggLT0gMztcbiAgfVxuICBjb25zdCBjb25maWcgPSBbYWR0c09iamVjdFR5cGUgPDwgMyB8IChhYWNTYW1wbGVJbmRleCAmIDB4MGUpID4+IDEsIChhYWNTYW1wbGVJbmRleCAmIDB4MDEpIDw8IDcgfCBjaGFubmVsQ291bnQgPDwgM107XG4gIGxvZ2dlci5sb2coYG1hbmlmZXN0IGNvZGVjOiR7bWFuaWZlc3RDb2RlY30sIHBhcnNlZCBjb2RlYzoke2NvZGVjfSwgY2hhbm5lbHM6JHtjaGFubmVsQ291bnR9LCByYXRlOiR7c2FtcGxlcmF0ZX0gKEFEVFMgb2JqZWN0IHR5cGU6JHthZHRzT2JqZWN0VHlwZX0gc2FtcGxpbmcgaW5kZXg6JHthZHRzU2FtcGxpbmdJbmRleH0pYCk7XG4gIHJldHVybiB7XG4gICAgY29uZmlnLFxuICAgIHNhbXBsZXJhdGUsXG4gICAgY2hhbm5lbENvdW50LFxuICAgIGNvZGVjLFxuICAgIHBhcnNlZENvZGVjOiBjb2RlYyxcbiAgICBtYW5pZmVzdENvZGVjXG4gIH07XG59XG5mdW5jdGlvbiBpc0hlYWRlclBhdHRlcm4kMShkYXRhLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGRhdGFbb2Zmc2V0XSA9PT0gMHhmZiAmJiAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4ZjYpID09PSAweGYwO1xufVxuZnVuY3Rpb24gZ2V0SGVhZGVyTGVuZ3RoKGRhdGEsIG9mZnNldCkge1xuICByZXR1cm4gZGF0YVtvZmZzZXQgKyAxXSAmIDB4MDEgPyA3IDogOTtcbn1cbmZ1bmN0aW9uIGdldEZ1bGxGcmFtZUxlbmd0aChkYXRhLCBvZmZzZXQpIHtcbiAgcmV0dXJuIChkYXRhW29mZnNldCArIDNdICYgMHgwMykgPDwgMTEgfCBkYXRhW29mZnNldCArIDRdIDw8IDMgfCAoZGF0YVtvZmZzZXQgKyA1XSAmIDB4ZTApID4+PiA1O1xufVxuZnVuY3Rpb24gY2FuR2V0RnJhbWVMZW5ndGgoZGF0YSwgb2Zmc2V0KSB7XG4gIHJldHVybiBvZmZzZXQgKyA1IDwgZGF0YS5sZW5ndGg7XG59XG5mdW5jdGlvbiBpc0hlYWRlciQxKGRhdGEsIG9mZnNldCkge1xuICAvLyBMb29rIGZvciBBRFRTIGhlYWRlciB8IDExMTEgMTExMSB8IDExMTEgWDAwWCB8IHdoZXJlIFggY2FuIGJlIGVpdGhlciAwIG9yIDFcbiAgLy8gTGF5ZXIgYml0cyAocG9zaXRpb24gMTQgYW5kIDE1KSBpbiBoZWFkZXIgc2hvdWxkIGJlIGFsd2F5cyAwIGZvciBBRFRTXG4gIC8vIE1vcmUgaW5mbyBodHRwczovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9QURUU1xuICByZXR1cm4gb2Zmc2V0ICsgMSA8IGRhdGEubGVuZ3RoICYmIGlzSGVhZGVyUGF0dGVybiQxKGRhdGEsIG9mZnNldCk7XG59XG5mdW5jdGlvbiBjYW5QYXJzZSQxKGRhdGEsIG9mZnNldCkge1xuICByZXR1cm4gY2FuR2V0RnJhbWVMZW5ndGgoZGF0YSwgb2Zmc2V0KSAmJiBpc0hlYWRlclBhdHRlcm4kMShkYXRhLCBvZmZzZXQpICYmIGdldEZ1bGxGcmFtZUxlbmd0aChkYXRhLCBvZmZzZXQpIDw9IGRhdGEubGVuZ3RoIC0gb2Zmc2V0O1xufVxuZnVuY3Rpb24gcHJvYmUkMShkYXRhLCBvZmZzZXQpIHtcbiAgLy8gc2FtZSBhcyBpc0hlYWRlciBidXQgd2UgYWxzbyBjaGVjayB0aGF0IEFEVFMgZnJhbWUgZm9sbG93cyBsYXN0IEFEVFMgZnJhbWVcbiAgLy8gb3IgZW5kIG9mIGRhdGEgaXMgcmVhY2hlZFxuICBpZiAoaXNIZWFkZXIkMShkYXRhLCBvZmZzZXQpKSB7XG4gICAgLy8gQURUUyBoZWFkZXIgTGVuZ3RoXG4gICAgY29uc3QgaGVhZGVyTGVuZ3RoID0gZ2V0SGVhZGVyTGVuZ3RoKGRhdGEsIG9mZnNldCk7XG4gICAgaWYgKG9mZnNldCArIGhlYWRlckxlbmd0aCA+PSBkYXRhLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBBRFRTIGZyYW1lIExlbmd0aFxuICAgIGNvbnN0IGZyYW1lTGVuZ3RoID0gZ2V0RnVsbEZyYW1lTGVuZ3RoKGRhdGEsIG9mZnNldCk7XG4gICAgaWYgKGZyYW1lTGVuZ3RoIDw9IGhlYWRlckxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBuZXdPZmZzZXQgPSBvZmZzZXQgKyBmcmFtZUxlbmd0aDtcbiAgICByZXR1cm4gbmV3T2Zmc2V0ID09PSBkYXRhLmxlbmd0aCB8fCBpc0hlYWRlciQxKGRhdGEsIG5ld09mZnNldCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaW5pdFRyYWNrQ29uZmlnKHRyYWNrLCBvYnNlcnZlciwgZGF0YSwgb2Zmc2V0LCBhdWRpb0NvZGVjKSB7XG4gIGlmICghdHJhY2suc2FtcGxlcmF0ZSkge1xuICAgIGNvbnN0IGNvbmZpZyA9IGdldEF1ZGlvQ29uZmlnKG9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIGF1ZGlvQ29kZWMpO1xuICAgIGlmICghY29uZmlnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIF9leHRlbmRzKHRyYWNrLCBjb25maWcpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRGcmFtZUR1cmF0aW9uKHNhbXBsZXJhdGUpIHtcbiAgcmV0dXJuIDEwMjQgKiA5MDAwMCAvIHNhbXBsZXJhdGU7XG59XG5mdW5jdGlvbiBwYXJzZUZyYW1lSGVhZGVyKGRhdGEsIG9mZnNldCkge1xuICAvLyBUaGUgcHJvdGVjdGlvbiBza2lwIGJpdCB0ZWxscyB1cyBpZiB3ZSBoYXZlIDIgYnl0ZXMgb2YgQ1JDIGRhdGEgYXQgdGhlIGVuZCBvZiB0aGUgQURUUyBoZWFkZXJcbiAgY29uc3QgaGVhZGVyTGVuZ3RoID0gZ2V0SGVhZGVyTGVuZ3RoKGRhdGEsIG9mZnNldCk7XG4gIGlmIChvZmZzZXQgKyBoZWFkZXJMZW5ndGggPD0gZGF0YS5sZW5ndGgpIHtcbiAgICAvLyByZXRyaWV2ZSBmcmFtZSBzaXplXG4gICAgY29uc3QgZnJhbWVMZW5ndGggPSBnZXRGdWxsRnJhbWVMZW5ndGgoZGF0YSwgb2Zmc2V0KSAtIGhlYWRlckxlbmd0aDtcbiAgICBpZiAoZnJhbWVMZW5ndGggPiAwKSB7XG4gICAgICAvLyBsb2dnZXIubG9nKGBBQUMgZnJhbWUsIG9mZnNldC9sZW5ndGgvdG90YWwvcHRzOiR7b2Zmc2V0K2hlYWRlckxlbmd0aH0vJHtmcmFtZUxlbmd0aH0vJHtkYXRhLmJ5dGVMZW5ndGh9YCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBoZWFkZXJMZW5ndGgsXG4gICAgICAgIGZyYW1lTGVuZ3RoXG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYXBwZW5kRnJhbWUkMih0cmFjaywgZGF0YSwgb2Zmc2V0LCBwdHMsIGZyYW1lSW5kZXgpIHtcbiAgY29uc3QgZnJhbWVEdXJhdGlvbiA9IGdldEZyYW1lRHVyYXRpb24odHJhY2suc2FtcGxlcmF0ZSk7XG4gIGNvbnN0IHN0YW1wID0gcHRzICsgZnJhbWVJbmRleCAqIGZyYW1lRHVyYXRpb247XG4gIGNvbnN0IGhlYWRlciA9IHBhcnNlRnJhbWVIZWFkZXIoZGF0YSwgb2Zmc2V0KTtcbiAgbGV0IHVuaXQ7XG4gIGlmIChoZWFkZXIpIHtcbiAgICBjb25zdCB7XG4gICAgICBmcmFtZUxlbmd0aCxcbiAgICAgIGhlYWRlckxlbmd0aFxuICAgIH0gPSBoZWFkZXI7XG4gICAgY29uc3QgX2xlbmd0aCA9IGhlYWRlckxlbmd0aCArIGZyYW1lTGVuZ3RoO1xuICAgIGNvbnN0IG1pc3NpbmcgPSBNYXRoLm1heCgwLCBvZmZzZXQgKyBfbGVuZ3RoIC0gZGF0YS5sZW5ndGgpO1xuICAgIC8vIGxvZ2dlci5sb2coYEFBQyBmcmFtZSAke2ZyYW1lSW5kZXh9LCBwdHM6JHtzdGFtcH0gbGVuZ3RoQG9mZnNldC90b3RhbDogJHtmcmFtZUxlbmd0aH1AJHtvZmZzZXQraGVhZGVyTGVuZ3RofS8ke2RhdGEuYnl0ZUxlbmd0aH0gbWlzc2luZzogJHttaXNzaW5nfWApO1xuICAgIGlmIChtaXNzaW5nKSB7XG4gICAgICB1bml0ID0gbmV3IFVpbnQ4QXJyYXkoX2xlbmd0aCAtIGhlYWRlckxlbmd0aCk7XG4gICAgICB1bml0LnNldChkYXRhLnN1YmFycmF5KG9mZnNldCArIGhlYWRlckxlbmd0aCwgZGF0YS5sZW5ndGgpLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdW5pdCA9IGRhdGEuc3ViYXJyYXkob2Zmc2V0ICsgaGVhZGVyTGVuZ3RoLCBvZmZzZXQgKyBfbGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3QgX3NhbXBsZSA9IHtcbiAgICAgIHVuaXQsXG4gICAgICBwdHM6IHN0YW1wXG4gICAgfTtcbiAgICBpZiAoIW1pc3NpbmcpIHtcbiAgICAgIHRyYWNrLnNhbXBsZXMucHVzaChfc2FtcGxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHNhbXBsZTogX3NhbXBsZSxcbiAgICAgIGxlbmd0aDogX2xlbmd0aCxcbiAgICAgIG1pc3NpbmdcbiAgICB9O1xuICB9XG4gIC8vIG92ZXJmbG93IGluY29tcGxldGUgaGVhZGVyXG4gIGNvbnN0IGxlbmd0aCA9IGRhdGEubGVuZ3RoIC0gb2Zmc2V0O1xuICB1bml0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgdW5pdC5zZXQoZGF0YS5zdWJhcnJheShvZmZzZXQsIGRhdGEubGVuZ3RoKSwgMCk7XG4gIGNvbnN0IHNhbXBsZSA9IHtcbiAgICB1bml0LFxuICAgIHB0czogc3RhbXBcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBzYW1wbGUsXG4gICAgbGVuZ3RoLFxuICAgIG1pc3Npbmc6IC0xXG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBkYXRhIGNvbnRhaW5zIGFuIElEMyB0YWcuXG4gKlxuICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byBjaGVja1xuICogQHBhcmFtIG9mZnNldCAtIFRoZSBvZmZzZXQgYXQgd2hpY2ggdG8gc3RhcnQgY2hlY2tpbmdcbiAqXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgYW4gSUQzIHRhZyBpcyBmb3VuZFxuICpcbiAqIEBncm91cCBJRDNcbiAqXG4gKiBAYmV0YVxuICovXG5mdW5jdGlvbiBjYW5QYXJzZUlkMyhkYXRhLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGlzSWQzSGVhZGVyKGRhdGEsIG9mZnNldCkgJiYgcmVhZElkM1NpemUoZGF0YSwgb2Zmc2V0ICsgNikgKyAxMCA8PSBkYXRhLmxlbmd0aCAtIG9mZnNldDtcbn1cblxuZnVuY3Rpb24gdG9BcnJheUJ1ZmZlcih2aWV3KSB7XG4gIGlmICh2aWV3IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gdmlldztcbiAgfSBlbHNlIHtcbiAgICBpZiAodmlldy5ieXRlT2Zmc2V0ID09IDAgJiYgdmlldy5ieXRlTGVuZ3RoID09IHZpZXcuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBUeXBlZEFycmF5IG92ZXIgdGhlIHdob2xlIGJ1ZmZlci5cbiAgICAgIHJldHVybiB2aWV3LmJ1ZmZlcjtcbiAgICB9XG4gICAgLy8gVGhpcyBpcyBhICd2aWV3JyBvbiB0aGUgYnVmZmVyLiAgQ3JlYXRlIGEgbmV3IGJ1ZmZlciB0aGF0IG9ubHkgY29udGFpbnNcbiAgICAvLyB0aGUgZGF0YS4gIE5vdGUgdGhhdCBzaW5jZSB0aGlzIGlzbid0IGFuIEFycmF5QnVmZmVyLCB0aGUgJ25ldycgY2FsbFxuICAgIC8vIHdpbGwgYWxsb2NhdGUgYSBuZXcgYnVmZmVyIHRvIGhvbGQgdGhlIGNvcHkuXG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHZpZXcpLmJ1ZmZlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiB0b1VpbnQ4KGRhdGEsIG9mZnNldCA9IDAsIGxlbmd0aCA9IEluZmluaXR5KSB7XG4gIHJldHVybiB2aWV3KGRhdGEsIG9mZnNldCwgbGVuZ3RoLCBVaW50OEFycmF5KTtcbn1cbmZ1bmN0aW9uIHZpZXcoZGF0YSwgb2Zmc2V0LCBsZW5ndGgsIFR5cGUpIHtcbiAgY29uc3QgYnVmZmVyID0gdW5zYWZlR2V0QXJyYXlCdWZmZXIoZGF0YSk7XG4gIGxldCBieXRlc1BlckVsZW1lbnQgPSAxO1xuICBpZiAoJ0JZVEVTX1BFUl9FTEVNRU5UJyBpbiBUeXBlKSB7XG4gICAgYnl0ZXNQZXJFbGVtZW50ID0gVHlwZS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgfVxuICAvLyBBYnNvbHV0ZSBlbmQgb2YgdGhlIHxkYXRhfCB2aWV3IHdpdGhpbiB8YnVmZmVyfC5cbiAgY29uc3QgZGF0YU9mZnNldCA9IGlzQXJyYXlCdWZmZXJWaWV3KGRhdGEpID8gZGF0YS5ieXRlT2Zmc2V0IDogMDtcbiAgY29uc3QgZGF0YUVuZCA9IChkYXRhT2Zmc2V0ICsgZGF0YS5ieXRlTGVuZ3RoKSAvIGJ5dGVzUGVyRWxlbWVudDtcbiAgLy8gQWJzb2x1dGUgc3RhcnQgb2YgdGhlIHJlc3VsdCB3aXRoaW4gfGJ1ZmZlcnwuXG4gIGNvbnN0IHJhd1N0YXJ0ID0gKGRhdGFPZmZzZXQgKyBvZmZzZXQpIC8gYnl0ZXNQZXJFbGVtZW50O1xuICBjb25zdCBzdGFydCA9IE1hdGguZmxvb3IoTWF0aC5tYXgoMCwgTWF0aC5taW4ocmF3U3RhcnQsIGRhdGFFbmQpKSk7XG4gIC8vIEFic29sdXRlIGVuZCBvZiB0aGUgcmVzdWx0IHdpdGhpbiB8YnVmZmVyfC5cbiAgY29uc3QgZW5kID0gTWF0aC5mbG9vcihNYXRoLm1pbihzdGFydCArIE1hdGgubWF4KGxlbmd0aCwgMCksIGRhdGFFbmQpKTtcbiAgcmV0dXJuIG5ldyBUeXBlKGJ1ZmZlciwgc3RhcnQsIGVuZCAtIHN0YXJ0KTtcbn1cbmZ1bmN0aW9uIHVuc2FmZUdldEFycmF5QnVmZmVyKHZpZXcpIHtcbiAgaWYgKHZpZXcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiB2aWV3O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2aWV3LmJ1ZmZlcjtcbiAgfVxufVxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcob2JqKSB7XG4gIHJldHVybiBvYmogJiYgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyICYmIG9iai5ieXRlTGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgb2JqLmJ5dGVPZmZzZXQgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZGVjb2RlSWQzSW1hZ2VGcmFtZShmcmFtZSkge1xuICBjb25zdCBtZXRhZGF0YUZyYW1lID0ge1xuICAgIGtleTogZnJhbWUudHlwZSxcbiAgICBkZXNjcmlwdGlvbjogJycsXG4gICAgZGF0YTogJycsXG4gICAgbWltZVR5cGU6IG51bGwsXG4gICAgcGljdHVyZVR5cGU6IG51bGxcbiAgfTtcbiAgY29uc3QgdXRmOEVuY29kaW5nID0gMHgwMztcbiAgaWYgKGZyYW1lLnNpemUgPCAyKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoZnJhbWUuZGF0YVswXSAhPT0gdXRmOEVuY29kaW5nKSB7XG4gICAgY29uc29sZS5sb2coJ0lnbm9yZSBmcmFtZSB3aXRoIHVucmVjb2duaXplZCBjaGFyYWN0ZXIgJyArICdlbmNvZGluZycpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3QgbWltZVR5cGVFbmRJbmRleCA9IGZyYW1lLmRhdGEuc3ViYXJyYXkoMSkuaW5kZXhPZigwKTtcbiAgaWYgKG1pbWVUeXBlRW5kSW5kZXggPT09IC0xKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCBtaW1lVHlwZSA9IHV0ZjhBcnJheVRvU3RyKHRvVWludDgoZnJhbWUuZGF0YSwgMSwgbWltZVR5cGVFbmRJbmRleCkpO1xuICBjb25zdCBwaWN0dXJlVHlwZSA9IGZyYW1lLmRhdGFbMiArIG1pbWVUeXBlRW5kSW5kZXhdO1xuICBjb25zdCBkZXNjcmlwdGlvbkVuZEluZGV4ID0gZnJhbWUuZGF0YS5zdWJhcnJheSgzICsgbWltZVR5cGVFbmRJbmRleCkuaW5kZXhPZigwKTtcbiAgaWYgKGRlc2NyaXB0aW9uRW5kSW5kZXggPT09IC0xKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCBkZXNjcmlwdGlvbiA9IHV0ZjhBcnJheVRvU3RyKHRvVWludDgoZnJhbWUuZGF0YSwgMyArIG1pbWVUeXBlRW5kSW5kZXgsIGRlc2NyaXB0aW9uRW5kSW5kZXgpKTtcbiAgbGV0IGRhdGE7XG4gIGlmIChtaW1lVHlwZSA9PT0gJy0tPicpIHtcbiAgICBkYXRhID0gdXRmOEFycmF5VG9TdHIodG9VaW50OChmcmFtZS5kYXRhLCA0ICsgbWltZVR5cGVFbmRJbmRleCArIGRlc2NyaXB0aW9uRW5kSW5kZXgpKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhID0gdG9BcnJheUJ1ZmZlcihmcmFtZS5kYXRhLnN1YmFycmF5KDQgKyBtaW1lVHlwZUVuZEluZGV4ICsgZGVzY3JpcHRpb25FbmRJbmRleCkpO1xuICB9XG4gIG1ldGFkYXRhRnJhbWUubWltZVR5cGUgPSBtaW1lVHlwZTtcbiAgbWV0YWRhdGFGcmFtZS5waWN0dXJlVHlwZSA9IHBpY3R1cmVUeXBlO1xuICBtZXRhZGF0YUZyYW1lLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gIG1ldGFkYXRhRnJhbWUuZGF0YSA9IGRhdGE7XG4gIHJldHVybiBtZXRhZGF0YUZyYW1lO1xufVxuXG4vKipcbiAqIERlY29kZSBhbiBJRDMgUFJJViBmcmFtZS5cbiAqXG4gKiBAcGFyYW0gZnJhbWUgLSB0aGUgSUQzIFBSSVYgZnJhbWVcbiAqXG4gKiBAcmV0dXJucyBUaGUgZGVjb2RlZCBJRDMgUFJJViBmcmFtZVxuICpcbiAqIEBpbnRlcm5hbFxuICpcbiAqIEBncm91cCBJRDNcbiAqL1xuZnVuY3Rpb24gZGVjb2RlSWQzUHJpdkZyYW1lKGZyYW1lKSB7XG4gIC8qXG4gIEZvcm1hdDogPHRleHQgc3RyaW5nPlxcMDxiaW5hcnkgZGF0YT5cbiAgKi9cbiAgaWYgKGZyYW1lLnNpemUgPCAyKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCBvd25lciA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEsIHRydWUpO1xuICBjb25zdCBwcml2YXRlRGF0YSA9IG5ldyBVaW50OEFycmF5KGZyYW1lLmRhdGEuc3ViYXJyYXkob3duZXIubGVuZ3RoICsgMSkpO1xuICByZXR1cm4ge1xuICAgIGtleTogZnJhbWUudHlwZSxcbiAgICBpbmZvOiBvd25lcixcbiAgICBkYXRhOiBwcml2YXRlRGF0YS5idWZmZXJcbiAgfTtcbn1cblxuLyoqXG4gKiBEZWNvZGVzIGFuIElEMyB0ZXh0IGZyYW1lXG4gKlxuICogQHBhcmFtIGZyYW1lIC0gdGhlIElEMyB0ZXh0IGZyYW1lXG4gKlxuICogQHJldHVybnMgVGhlIGRlY29kZWQgSUQzIHRleHQgZnJhbWVcbiAqXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBAZ3JvdXAgSUQzXG4gKi9cbmZ1bmN0aW9uIGRlY29kZUlkM1RleHRGcmFtZShmcmFtZSkge1xuICBpZiAoZnJhbWUuc2l6ZSA8IDIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChmcmFtZS50eXBlID09PSAnVFhYWCcpIHtcbiAgICAvKlxuICAgIEZvcm1hdDpcbiAgICBbMF0gICA9IHtUZXh0IEVuY29kaW5nfVxuICAgIFsxLT9dID0ge0Rlc2NyaXB0aW9ufVxcMHtWYWx1ZX1cbiAgICAqL1xuICAgIGxldCBpbmRleCA9IDE7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSB1dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLnN1YmFycmF5KGluZGV4KSwgdHJ1ZSk7XG4gICAgaW5kZXggKz0gZGVzY3JpcHRpb24ubGVuZ3RoICsgMTtcbiAgICBjb25zdCB2YWx1ZSA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoaW5kZXgpKTtcbiAgICByZXR1cm4ge1xuICAgICAga2V5OiBmcmFtZS50eXBlLFxuICAgICAgaW5mbzogZGVzY3JpcHRpb24sXG4gICAgICBkYXRhOiB2YWx1ZVxuICAgIH07XG4gIH1cbiAgLypcbiAgRm9ybWF0OlxuICBbMF0gICA9IHtUZXh0IEVuY29kaW5nfVxuICBbMS0/XSA9IHtWYWx1ZX1cbiAgKi9cbiAgY29uc3QgdGV4dCA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoMSkpO1xuICByZXR1cm4ge1xuICAgIGtleTogZnJhbWUudHlwZSxcbiAgICBpbmZvOiAnJyxcbiAgICBkYXRhOiB0ZXh0XG4gIH07XG59XG5cbi8qKlxuICogRGVjb2RlIGEgVVJMIGZyYW1lXG4gKlxuICogQHBhcmFtIGZyYW1lIC0gdGhlIElEMyBVUkwgZnJhbWVcbiAqXG4gKiBAcmV0dXJucyBUaGUgZGVjb2RlZCBJRDMgVVJMIGZyYW1lXG4gKlxuICogQGludGVybmFsXG4gKlxuICogQGdyb3VwIElEM1xuICovXG5mdW5jdGlvbiBkZWNvZGVJZDNVcmxGcmFtZShmcmFtZSkge1xuICBpZiAoZnJhbWUudHlwZSA9PT0gJ1dYWFgnKSB7XG4gICAgLypcbiAgICBGb3JtYXQ6XG4gICAgWzBdICAgPSB7VGV4dCBFbmNvZGluZ31cbiAgICBbMS0/XSA9IHtEZXNjcmlwdGlvbn1cXDB7VVJMfVxuICAgICovXG4gICAgaWYgKGZyYW1lLnNpemUgPCAyKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBsZXQgaW5kZXggPSAxO1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YS5zdWJhcnJheShpbmRleCksIHRydWUpO1xuICAgIGluZGV4ICs9IGRlc2NyaXB0aW9uLmxlbmd0aCArIDE7XG4gICAgY29uc3QgdmFsdWUgPSB1dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLnN1YmFycmF5KGluZGV4KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleTogZnJhbWUudHlwZSxcbiAgICAgIGluZm86IGRlc2NyaXB0aW9uLFxuICAgICAgZGF0YTogdmFsdWVcbiAgICB9O1xuICB9XG4gIC8qXG4gIEZvcm1hdDpcbiAgWzAtP10gPSB7VVJMfVxuICAqL1xuICBjb25zdCB1cmwgPSB1dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhKTtcbiAgcmV0dXJuIHtcbiAgICBrZXk6IGZyYW1lLnR5cGUsXG4gICAgaW5mbzogJycsXG4gICAgZGF0YTogdXJsXG4gIH07XG59XG5cbi8qKlxuICogRGVjb2RlIGFuIElEMyBmcmFtZS5cbiAqXG4gKiBAcGFyYW0gZnJhbWUgLSB0aGUgSUQzIGZyYW1lXG4gKlxuICogQHJldHVybnMgVGhlIGRlY29kZWQgSUQzIGZyYW1lXG4gKlxuICogQGludGVybmFsXG4gKlxuICogQGdyb3VwIElEM1xuICovXG5mdW5jdGlvbiBkZWNvZGVJZDNGcmFtZShmcmFtZSkge1xuICBpZiAoZnJhbWUudHlwZSA9PT0gJ1BSSVYnKSB7XG4gICAgcmV0dXJuIGRlY29kZUlkM1ByaXZGcmFtZShmcmFtZSk7XG4gIH0gZWxzZSBpZiAoZnJhbWUudHlwZVswXSA9PT0gJ1cnKSB7XG4gICAgcmV0dXJuIGRlY29kZUlkM1VybEZyYW1lKGZyYW1lKTtcbiAgfSBlbHNlIGlmIChmcmFtZS50eXBlID09PSAnQVBJQycpIHtcbiAgICByZXR1cm4gZGVjb2RlSWQzSW1hZ2VGcmFtZShmcmFtZSk7XG4gIH1cbiAgcmV0dXJuIGRlY29kZUlkM1RleHRGcmFtZShmcmFtZSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZGF0YSBvZiBhbiBJRDMgZnJhbWUuXG4gKlxuICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byByZWFkIGZyb21cbiAqXG4gKiBAcmV0dXJucyBUaGUgZGF0YSBvZiB0aGUgSUQzIGZyYW1lXG4gKlxuICogQGludGVybmFsXG4gKlxuICogQGdyb3VwIElEM1xuICovXG5mdW5jdGlvbiBnZXRJZDNGcmFtZURhdGEoZGF0YSkge1xuICAvKlxuICBGcmFtZSBJRCAgICAgICAkeHggeHggeHggeHggKGZvdXIgY2hhcmFjdGVycylcbiAgU2l6ZSAgICAgICAgICAgJHh4IHh4IHh4IHh4XG4gIEZsYWdzICAgICAgICAgICR4eCB4eFxuICAqL1xuICBjb25zdCB0eXBlID0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhWzBdLCBkYXRhWzFdLCBkYXRhWzJdLCBkYXRhWzNdKTtcbiAgY29uc3Qgc2l6ZSA9IHJlYWRJZDNTaXplKGRhdGEsIDQpO1xuICAvLyBza2lwIGZyYW1lIGlkLCBzaXplLCBhbmQgZmxhZ3NcbiAgY29uc3Qgb2Zmc2V0ID0gMTA7XG4gIHJldHVybiB7XG4gICAgdHlwZSxcbiAgICBzaXplLFxuICAgIGRhdGE6IGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBzaXplKVxuICB9O1xufVxuXG5jb25zdCBIRUFERVJfRk9PVEVSX1NJWkUgPSAxMDtcbmNvbnN0IEZSQU1FX1NJWkUgPSAxMDtcbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiBJRDMgZnJhbWVzIGZvdW5kIGluIGFsbCB0aGUgSUQzIHRhZ3MgaW4gdGhlIGlkM0RhdGFcbiAqXG4gKiBAcGFyYW0gaWQzRGF0YSAtIFRoZSBJRDMgZGF0YSBjb250YWluaW5nIG9uZSBvciBtb3JlIElEMyB0YWdzXG4gKlxuICogQHJldHVybnMgQXJyYXkgb2YgSUQzIGZyYW1lIG9iamVjdHNcbiAqXG4gKiBAZ3JvdXAgSUQzXG4gKlxuICogQGJldGFcbiAqL1xuZnVuY3Rpb24gZ2V0SWQzRnJhbWVzKGlkM0RhdGEpIHtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGNvbnN0IGZyYW1lcyA9IFtdO1xuICB3aGlsZSAoaXNJZDNIZWFkZXIoaWQzRGF0YSwgb2Zmc2V0KSkge1xuICAgIGNvbnN0IHNpemUgPSByZWFkSWQzU2l6ZShpZDNEYXRhLCBvZmZzZXQgKyA2KTtcbiAgICBpZiAoaWQzRGF0YVtvZmZzZXQgKyA1XSA+PiA2ICYgMSkge1xuICAgICAgLy8gc2tpcCBleHRlbmRlZCBoZWFkZXJcbiAgICAgIG9mZnNldCArPSBIRUFERVJfRk9PVEVSX1NJWkU7XG4gICAgfVxuICAgIC8vIHNraXAgcGFzdCBJRDMgaGVhZGVyXG4gICAgb2Zmc2V0ICs9IEhFQURFUl9GT09URVJfU0laRTtcbiAgICBjb25zdCBlbmQgPSBvZmZzZXQgKyBzaXplO1xuICAgIC8vIGxvb3AgdGhyb3VnaCBmcmFtZXMgaW4gdGhlIElEMyB0YWdcbiAgICB3aGlsZSAob2Zmc2V0ICsgRlJBTUVfU0laRSA8IGVuZCkge1xuICAgICAgY29uc3QgZnJhbWVEYXRhID0gZ2V0SWQzRnJhbWVEYXRhKGlkM0RhdGEuc3ViYXJyYXkob2Zmc2V0KSk7XG4gICAgICBjb25zdCBmcmFtZSA9IGRlY29kZUlkM0ZyYW1lKGZyYW1lRGF0YSk7XG4gICAgICBpZiAoZnJhbWUpIHtcbiAgICAgICAgZnJhbWVzLnB1c2goZnJhbWUpO1xuICAgICAgfVxuICAgICAgLy8gc2tpcCBmcmFtZSBoZWFkZXIgYW5kIGZyYW1lIGRhdGFcbiAgICAgIG9mZnNldCArPSBmcmFtZURhdGEuc2l6ZSArIEhFQURFUl9GT09URVJfU0laRTtcbiAgICB9XG4gICAgaWYgKGlzSWQzRm9vdGVyKGlkM0RhdGEsIG9mZnNldCkpIHtcbiAgICAgIG9mZnNldCArPSBIRUFERVJfRk9PVEVSX1NJWkU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmcmFtZXM7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBJRDMgZnJhbWUgaXMgYW4gRWxlbWVudGFyeSBTdHJlYW0gdGltZXN0YW1wIGZyYW1lXG4gKlxuICogQHBhcmFtIGZyYW1lIC0gdGhlIElEMyBmcmFtZVxuICpcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgSUQzIGZyYW1lIGlzIGFuIEVsZW1lbnRhcnkgU3RyZWFtIHRpbWVzdGFtcCBmcmFtZVxuICpcbiAqIEBpbnRlcm5hbFxuICpcbiAqIEBncm91cCBJRDNcbiAqL1xuZnVuY3Rpb24gaXNJZDNUaW1lc3RhbXBGcmFtZShmcmFtZSkge1xuICByZXR1cm4gZnJhbWUgJiYgZnJhbWUua2V5ID09PSAnUFJJVicgJiYgZnJhbWUuaW5mbyA9PT0gJ2NvbS5hcHBsZS5zdHJlYW1pbmcudHJhbnNwb3J0U3RyZWFtVGltZXN0YW1wJztcbn1cblxuLyoqXG4gKiBSZWFkIGEgMzMgYml0IHRpbWVzdGFtcCBmcm9tIGFuIElEMyBmcmFtZS5cbiAqXG4gKiBAcGFyYW0gdGltZVN0YW1wRnJhbWUgLSB0aGUgSUQzIGZyYW1lXG4gKlxuICogQHJldHVybnMgVGhlIHRpbWVzdGFtcFxuICpcbiAqIEBpbnRlcm5hbFxuICpcbiAqIEBncm91cCBJRDNcbiAqL1xuZnVuY3Rpb24gcmVhZElkM1RpbWVzdGFtcCh0aW1lU3RhbXBGcmFtZSkge1xuICBpZiAodGltZVN0YW1wRnJhbWUuZGF0YS5ieXRlTGVuZ3RoID09PSA4KSB7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KHRpbWVTdGFtcEZyYW1lLmRhdGEpO1xuICAgIC8vIHRpbWVzdGFtcCBpcyAzMyBiaXQgZXhwcmVzc2VkIGFzIGEgYmlnLWVuZGlhbiBlaWdodC1vY3RldCBudW1iZXIsXG4gICAgLy8gd2l0aCB0aGUgdXBwZXIgMzEgYml0cyBzZXQgdG8gemVyby5cbiAgICBjb25zdCBwdHMzM0JpdCA9IGRhdGFbM10gJiAweDE7XG4gICAgbGV0IHRpbWVzdGFtcCA9IChkYXRhWzRdIDw8IDIzKSArIChkYXRhWzVdIDw8IDE1KSArIChkYXRhWzZdIDw8IDcpICsgZGF0YVs3XTtcbiAgICB0aW1lc3RhbXAgLz0gNDU7XG4gICAgaWYgKHB0czMzQml0KSB7XG4gICAgICB0aW1lc3RhbXAgKz0gNDc3MjE4NTguODQ7XG4gICAgfSAvLyAyXjMyIC8gOTBcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh0aW1lc3RhbXApO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogU2VhcmNoZXMgZm9yIHRoZSBFbGVtZW50YXJ5IFN0cmVhbSB0aW1lc3RhbXAgZm91bmQgaW4gdGhlIElEMyBkYXRhIGNodW5rXG4gKlxuICogQHBhcmFtIGRhdGEgLSBCbG9jayBvZiBkYXRhIGNvbnRhaW5pbmcgb25lIG9yIG1vcmUgSUQzIHRhZ3NcbiAqXG4gKiBAcmV0dXJucyBUaGUgdGltZXN0YW1wXG4gKlxuICogQGdyb3VwIElEM1xuICpcbiAqIEBiZXRhXG4gKi9cbmZ1bmN0aW9uIGdldElkM1RpbWVzdGFtcChkYXRhKSB7XG4gIGNvbnN0IGZyYW1lcyA9IGdldElkM0ZyYW1lcyhkYXRhKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBmcmFtZSA9IGZyYW1lc1tpXTtcbiAgICBpZiAoaXNJZDNUaW1lc3RhbXBGcmFtZShmcmFtZSkpIHtcbiAgICAgIHJldHVybiByZWFkSWQzVGltZXN0YW1wKGZyYW1lKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxubGV0IE1ldGFkYXRhU2NoZW1hID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChNZXRhZGF0YVNjaGVtYSkge1xuICBNZXRhZGF0YVNjaGVtYVtcImF1ZGlvSWQzXCJdID0gXCJvcmcuaWQzXCI7XG4gIE1ldGFkYXRhU2NoZW1hW1wiZGF0ZVJhbmdlXCJdID0gXCJjb20uYXBwbGUucXVpY2t0aW1lLkhMU1wiO1xuICBNZXRhZGF0YVNjaGVtYVtcImVtc2dcIl0gPSBcImh0dHBzOi8vYW9tZWRpYS5vcmcvZW1zZy9JRDNcIjtcbiAgTWV0YWRhdGFTY2hlbWFbXCJtaXNia2x2XCJdID0gXCJ1cm46bWlzYjpLTFY6YmluOjE5MTAuMVwiO1xuICByZXR1cm4gTWV0YWRhdGFTY2hlbWE7XG59KHt9KTtcblxuZnVuY3Rpb24gZHVtbXlUcmFjayh0eXBlID0gJycsIGlucHV0VGltZVNjYWxlID0gOTAwMDApIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlLFxuICAgIGlkOiAtMSxcbiAgICBwaWQ6IC0xLFxuICAgIGlucHV0VGltZVNjYWxlLFxuICAgIHNlcXVlbmNlTnVtYmVyOiAtMSxcbiAgICBzYW1wbGVzOiBbXSxcbiAgICBkcm9wcGVkOiAwXG4gIH07XG59XG5cbmNsYXNzIEJhc2VBdWRpb0RlbXV4ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9hdWRpb1RyYWNrID0gdm9pZCAwO1xuICAgIHRoaXMuX2lkM1RyYWNrID0gdm9pZCAwO1xuICAgIHRoaXMuZnJhbWVJbmRleCA9IDA7XG4gICAgdGhpcy5jYWNoZWREYXRhID0gbnVsbDtcbiAgICB0aGlzLmJhc2VQVFMgPSBudWxsO1xuICAgIHRoaXMuaW5pdFBUUyA9IG51bGw7XG4gICAgdGhpcy5sYXN0UFRTID0gbnVsbDtcbiAgfVxuICByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0cmFja0R1cmF0aW9uKSB7XG4gICAgdGhpcy5faWQzVHJhY2sgPSB7XG4gICAgICB0eXBlOiAnaWQzJyxcbiAgICAgIGlkOiAzLFxuICAgICAgcGlkOiAtMSxcbiAgICAgIGlucHV0VGltZVNjYWxlOiA5MDAwMCxcbiAgICAgIHNlcXVlbmNlTnVtYmVyOiAwLFxuICAgICAgc2FtcGxlczogW10sXG4gICAgICBkcm9wcGVkOiAwXG4gICAgfTtcbiAgfVxuICByZXNldFRpbWVTdGFtcChkZWF1bHRUaW1lc3RhbXApIHtcbiAgICB0aGlzLmluaXRQVFMgPSBkZWF1bHRUaW1lc3RhbXA7XG4gICAgdGhpcy5yZXNldENvbnRpZ3VpdHkoKTtcbiAgfVxuICByZXNldENvbnRpZ3VpdHkoKSB7XG4gICAgdGhpcy5iYXNlUFRTID0gbnVsbDtcbiAgICB0aGlzLmxhc3RQVFMgPSBudWxsO1xuICAgIHRoaXMuZnJhbWVJbmRleCA9IDA7XG4gIH1cbiAgY2FuUGFyc2UoZGF0YSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQpIHt9XG5cbiAgLy8gZmVlZCBpbmNvbWluZyBkYXRhIHRvIHRoZSBmcm9udCBvZiB0aGUgcGFyc2luZyBwaXBlbGluZVxuICBkZW11eChkYXRhLCB0aW1lT2Zmc2V0KSB7XG4gICAgaWYgKHRoaXMuY2FjaGVkRGF0YSkge1xuICAgICAgZGF0YSA9IGFwcGVuZFVpbnQ4QXJyYXkodGhpcy5jYWNoZWREYXRhLCBkYXRhKTtcbiAgICAgIHRoaXMuY2FjaGVkRGF0YSA9IG51bGw7XG4gICAgfVxuICAgIGxldCBpZDNEYXRhID0gZ2V0SWQzRGF0YShkYXRhLCAwKTtcbiAgICBsZXQgb2Zmc2V0ID0gaWQzRGF0YSA/IGlkM0RhdGEubGVuZ3RoIDogMDtcbiAgICBsZXQgbGFzdERhdGFJbmRleDtcbiAgICBjb25zdCB0cmFjayA9IHRoaXMuX2F1ZGlvVHJhY2s7XG4gICAgY29uc3QgaWQzVHJhY2sgPSB0aGlzLl9pZDNUcmFjaztcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBpZDNEYXRhID8gZ2V0SWQzVGltZXN0YW1wKGlkM0RhdGEpIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgIGlmICh0aGlzLmJhc2VQVFMgPT09IG51bGwgfHwgdGhpcy5mcmFtZUluZGV4ID09PSAwICYmIGlzRmluaXRlTnVtYmVyKHRpbWVzdGFtcCkpIHtcbiAgICAgIHRoaXMuYmFzZVBUUyA9IGluaXRQVFNGbih0aW1lc3RhbXAsIHRpbWVPZmZzZXQsIHRoaXMuaW5pdFBUUyk7XG4gICAgICB0aGlzLmxhc3RQVFMgPSB0aGlzLmJhc2VQVFM7XG4gICAgfVxuICAgIGlmICh0aGlzLmxhc3RQVFMgPT09IG51bGwpIHtcbiAgICAgIHRoaXMubGFzdFBUUyA9IHRoaXMuYmFzZVBUUztcbiAgICB9XG5cbiAgICAvLyBtb3JlIGV4cHJlc3NpdmUgdGhhbiBhbHRlcm5hdGl2ZTogaWQzRGF0YT8ubGVuZ3RoXG4gICAgaWYgKGlkM0RhdGEgJiYgaWQzRGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICBpZDNUcmFjay5zYW1wbGVzLnB1c2goe1xuICAgICAgICBwdHM6IHRoaXMubGFzdFBUUyxcbiAgICAgICAgZHRzOiB0aGlzLmxhc3RQVFMsXG4gICAgICAgIGRhdGE6IGlkM0RhdGEsXG4gICAgICAgIHR5cGU6IE1ldGFkYXRhU2NoZW1hLmF1ZGlvSWQzLFxuICAgICAgICBkdXJhdGlvbjogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG4gICAgICB9KTtcbiAgICB9XG4gICAgd2hpbGUgKG9mZnNldCA8IGxlbmd0aCkge1xuICAgICAgaWYgKHRoaXMuY2FuUGFyc2UoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICBjb25zdCBmcmFtZSA9IHRoaXMuYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCk7XG4gICAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICAgIHRoaXMuZnJhbWVJbmRleCsrO1xuICAgICAgICAgIHRoaXMubGFzdFBUUyA9IGZyYW1lLnNhbXBsZS5wdHM7XG4gICAgICAgICAgb2Zmc2V0ICs9IGZyYW1lLmxlbmd0aDtcbiAgICAgICAgICBsYXN0RGF0YUluZGV4ID0gb2Zmc2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZnNldCA9IGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjYW5QYXJzZUlkMyhkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgIC8vIGFmdGVyIGEgY2FuUGFyc2UsIGEgY2FsbCB0byBnZXRJZDNEYXRhICpzaG91bGQqIGFsd2F5cyByZXR1cm5zIHNvbWUgZGF0YVxuICAgICAgICBpZDNEYXRhID0gZ2V0SWQzRGF0YShkYXRhLCBvZmZzZXQpO1xuICAgICAgICBpZDNUcmFjay5zYW1wbGVzLnB1c2goe1xuICAgICAgICAgIHB0czogdGhpcy5sYXN0UFRTLFxuICAgICAgICAgIGR0czogdGhpcy5sYXN0UFRTLFxuICAgICAgICAgIGRhdGE6IGlkM0RhdGEsXG4gICAgICAgICAgdHlwZTogTWV0YWRhdGFTY2hlbWEuYXVkaW9JZDMsXG4gICAgICAgICAgZHVyYXRpb246IE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxuICAgICAgICB9KTtcbiAgICAgICAgb2Zmc2V0ICs9IGlkM0RhdGEubGVuZ3RoO1xuICAgICAgICBsYXN0RGF0YUluZGV4ID0gb2Zmc2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICB9XG4gICAgICBpZiAob2Zmc2V0ID09PSBsZW5ndGggJiYgbGFzdERhdGFJbmRleCAhPT0gbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHBhcnRpYWxEYXRhID0gZGF0YS5zbGljZShsYXN0RGF0YUluZGV4KTtcbiAgICAgICAgaWYgKHRoaXMuY2FjaGVkRGF0YSkge1xuICAgICAgICAgIHRoaXMuY2FjaGVkRGF0YSA9IGFwcGVuZFVpbnQ4QXJyYXkodGhpcy5jYWNoZWREYXRhLCBwYXJ0aWFsRGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jYWNoZWREYXRhID0gcGFydGlhbERhdGE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGF1ZGlvVHJhY2s6IHRyYWNrLFxuICAgICAgdmlkZW9UcmFjazogZHVtbXlUcmFjaygpLFxuICAgICAgaWQzVHJhY2ssXG4gICAgICB0ZXh0VHJhY2s6IGR1bW15VHJhY2soKVxuICAgIH07XG4gIH1cbiAgZGVtdXhTYW1wbGVBZXMoZGF0YSwga2V5RGF0YSwgdGltZU9mZnNldCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYFske3RoaXN9XSBUaGlzIGRlbXV4ZXIgZG9lcyBub3Qgc3VwcG9ydCBTYW1wbGUtQUVTIGRlY3J5cHRpb25gKSk7XG4gIH1cbiAgZmx1c2godGltZU9mZnNldCkge1xuICAgIC8vIFBhcnNlIGNhY2hlIGluIGNhc2Ugb2YgcmVtYWluaW5nIGZyYW1lcy5cbiAgICBjb25zdCBjYWNoZWREYXRhID0gdGhpcy5jYWNoZWREYXRhO1xuICAgIGlmIChjYWNoZWREYXRhKSB7XG4gICAgICB0aGlzLmNhY2hlZERhdGEgPSBudWxsO1xuICAgICAgdGhpcy5kZW11eChjYWNoZWREYXRhLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGF1ZGlvVHJhY2s6IHRoaXMuX2F1ZGlvVHJhY2ssXG4gICAgICB2aWRlb1RyYWNrOiBkdW1teVRyYWNrKCksXG4gICAgICBpZDNUcmFjazogdGhpcy5faWQzVHJhY2ssXG4gICAgICB0ZXh0VHJhY2s6IGR1bW15VHJhY2soKVxuICAgIH07XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmNhY2hlZERhdGEgPSBudWxsO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLl9hdWRpb1RyYWNrID0gdGhpcy5faWQzVHJhY2sgPSB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIFBUU1xuICogPHA+XG4gKiAgICB1c2UgdGltZXN0YW1wIHVubGVzcyBpdCBpcyB1bmRlZmluZWQsIE5hTiBvciBJbmZpbml0eVxuICogPC9wPlxuICovXG5jb25zdCBpbml0UFRTRm4gPSAodGltZXN0YW1wLCB0aW1lT2Zmc2V0LCBpbml0UFRTKSA9PiB7XG4gIGlmIChpc0Zpbml0ZU51bWJlcih0aW1lc3RhbXApKSB7XG4gICAgcmV0dXJuIHRpbWVzdGFtcCAqIDkwO1xuICB9XG4gIGNvbnN0IGluaXQ5MGtIeiA9IGluaXRQVFMgPyBpbml0UFRTLmJhc2VUaW1lICogOTAwMDAgLyBpbml0UFRTLnRpbWVzY2FsZSA6IDA7XG4gIHJldHVybiB0aW1lT2Zmc2V0ICogOTAwMDAgKyBpbml0OTBrSHo7XG59O1xuXG4vKipcbiAqICBNUEVHIHBhcnNlciBoZWxwZXJcbiAqL1xuXG5sZXQgY2hyb21lVmVyc2lvbiQxID0gbnVsbDtcbmNvbnN0IEJpdHJhdGVzTWFwID0gWzMyLCA2NCwgOTYsIDEyOCwgMTYwLCAxOTIsIDIyNCwgMjU2LCAyODgsIDMyMCwgMzUyLCAzODQsIDQxNiwgNDQ4LCAzMiwgNDgsIDU2LCA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTYwLCAxOTIsIDIyNCwgMjU2LCAzMjAsIDM4NCwgMzIsIDQwLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNjAsIDE5MiwgMjI0LCAyNTYsIDMyMCwgMzIsIDQ4LCA1NiwgNjQsIDgwLCA5NiwgMTEyLCAxMjgsIDE0NCwgMTYwLCAxNzYsIDE5MiwgMjI0LCAyNTYsIDgsIDE2LCAyNCwgMzIsIDQwLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNDQsIDE2MF07XG5jb25zdCBTYW1wbGluZ1JhdGVNYXAgPSBbNDQxMDAsIDQ4MDAwLCAzMjAwMCwgMjIwNTAsIDI0MDAwLCAxNjAwMCwgMTEwMjUsIDEyMDAwLCA4MDAwXTtcbmNvbnN0IFNhbXBsZXNDb2VmZmljaWVudHMgPSBbXG4vLyBNUEVHIDIuNVxuWzAsXG4vLyBSZXNlcnZlZFxuNzIsXG4vLyBMYXllcjNcbjE0NCxcbi8vIExheWVyMlxuMTIgLy8gTGF5ZXIxXG5dLFxuLy8gUmVzZXJ2ZWRcblswLFxuLy8gUmVzZXJ2ZWRcbjAsXG4vLyBMYXllcjNcbjAsXG4vLyBMYXllcjJcbjAgLy8gTGF5ZXIxXG5dLFxuLy8gTVBFRyAyXG5bMCxcbi8vIFJlc2VydmVkXG43Mixcbi8vIExheWVyM1xuMTQ0LFxuLy8gTGF5ZXIyXG4xMiAvLyBMYXllcjFcbl0sXG4vLyBNUEVHIDFcblswLFxuLy8gUmVzZXJ2ZWRcbjE0NCxcbi8vIExheWVyM1xuMTQ0LFxuLy8gTGF5ZXIyXG4xMiAvLyBMYXllcjFcbl1dO1xuY29uc3QgQnl0ZXNJblNsb3QgPSBbMCxcbi8vIFJlc2VydmVkXG4xLFxuLy8gTGF5ZXIzXG4xLFxuLy8gTGF5ZXIyXG40IC8vIExheWVyMVxuXTtcbmZ1bmN0aW9uIGFwcGVuZEZyYW1lJDEodHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KSB7XG4gIC8vIFVzaW5nIGh0dHA6Ly93d3cuZGF0YXZveWFnZS5jb20vbXBnc2NyaXB0L21wZWdoZHIuaHRtIGFzIGEgcmVmZXJlbmNlXG4gIGlmIChvZmZzZXQgKyAyNCA+IGRhdGEubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGhlYWRlciA9IHBhcnNlSGVhZGVyKGRhdGEsIG9mZnNldCk7XG4gIGlmIChoZWFkZXIgJiYgb2Zmc2V0ICsgaGVhZGVyLmZyYW1lTGVuZ3RoIDw9IGRhdGEubGVuZ3RoKSB7XG4gICAgY29uc3QgZnJhbWVEdXJhdGlvbiA9IGhlYWRlci5zYW1wbGVzUGVyRnJhbWUgKiA5MDAwMCAvIGhlYWRlci5zYW1wbGVSYXRlO1xuICAgIGNvbnN0IHN0YW1wID0gcHRzICsgZnJhbWVJbmRleCAqIGZyYW1lRHVyYXRpb247XG4gICAgY29uc3Qgc2FtcGxlID0ge1xuICAgICAgdW5pdDogZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGhlYWRlci5mcmFtZUxlbmd0aCksXG4gICAgICBwdHM6IHN0YW1wLFxuICAgICAgZHRzOiBzdGFtcFxuICAgIH07XG4gICAgdHJhY2suY29uZmlnID0gW107XG4gICAgdHJhY2suY2hhbm5lbENvdW50ID0gaGVhZGVyLmNoYW5uZWxDb3VudDtcbiAgICB0cmFjay5zYW1wbGVyYXRlID0gaGVhZGVyLnNhbXBsZVJhdGU7XG4gICAgdHJhY2suc2FtcGxlcy5wdXNoKHNhbXBsZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNhbXBsZSxcbiAgICAgIGxlbmd0aDogaGVhZGVyLmZyYW1lTGVuZ3RoLFxuICAgICAgbWlzc2luZzogMFxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlSGVhZGVyKGRhdGEsIG9mZnNldCkge1xuICBjb25zdCBtcGVnVmVyc2lvbiA9IGRhdGFbb2Zmc2V0ICsgMV0gPj4gMyAmIDM7XG4gIGNvbnN0IG1wZWdMYXllciA9IGRhdGFbb2Zmc2V0ICsgMV0gPj4gMSAmIDM7XG4gIGNvbnN0IGJpdFJhdGVJbmRleCA9IGRhdGFbb2Zmc2V0ICsgMl0gPj4gNCAmIDE1O1xuICBjb25zdCBzYW1wbGVSYXRlSW5kZXggPSBkYXRhW29mZnNldCArIDJdID4+IDIgJiAzO1xuICBpZiAobXBlZ1ZlcnNpb24gIT09IDEgJiYgYml0UmF0ZUluZGV4ICE9PSAwICYmIGJpdFJhdGVJbmRleCAhPT0gMTUgJiYgc2FtcGxlUmF0ZUluZGV4ICE9PSAzKSB7XG4gICAgY29uc3QgcGFkZGluZ0JpdCA9IGRhdGFbb2Zmc2V0ICsgMl0gPj4gMSAmIDE7XG4gICAgY29uc3QgY2hhbm5lbE1vZGUgPSBkYXRhW29mZnNldCArIDNdID4+IDY7XG4gICAgY29uc3QgY29sdW1uSW5CaXRyYXRlcyA9IG1wZWdWZXJzaW9uID09PSAzID8gMyAtIG1wZWdMYXllciA6IG1wZWdMYXllciA9PT0gMyA/IDMgOiA0O1xuICAgIGNvbnN0IGJpdFJhdGUgPSBCaXRyYXRlc01hcFtjb2x1bW5JbkJpdHJhdGVzICogMTQgKyBiaXRSYXRlSW5kZXggLSAxXSAqIDEwMDA7XG4gICAgY29uc3QgY29sdW1uSW5TYW1wbGVSYXRlcyA9IG1wZWdWZXJzaW9uID09PSAzID8gMCA6IG1wZWdWZXJzaW9uID09PSAyID8gMSA6IDI7XG4gICAgY29uc3Qgc2FtcGxlUmF0ZSA9IFNhbXBsaW5nUmF0ZU1hcFtjb2x1bW5JblNhbXBsZVJhdGVzICogMyArIHNhbXBsZVJhdGVJbmRleF07XG4gICAgY29uc3QgY2hhbm5lbENvdW50ID0gY2hhbm5lbE1vZGUgPT09IDMgPyAxIDogMjsgLy8gSWYgYml0cyBvZiBjaGFubmVsIG1vZGUgYXJlIGAxMWAgdGhlbiBpdCBpcyBhIHNpbmdsZSBjaGFubmVsIChNb25vKVxuICAgIGNvbnN0IHNhbXBsZUNvZWZmaWNpZW50ID0gU2FtcGxlc0NvZWZmaWNpZW50c1ttcGVnVmVyc2lvbl1bbXBlZ0xheWVyXTtcbiAgICBjb25zdCBieXRlc0luU2xvdCA9IEJ5dGVzSW5TbG90W21wZWdMYXllcl07XG4gICAgY29uc3Qgc2FtcGxlc1BlckZyYW1lID0gc2FtcGxlQ29lZmZpY2llbnQgKiA4ICogYnl0ZXNJblNsb3Q7XG4gICAgY29uc3QgZnJhbWVMZW5ndGggPSBNYXRoLmZsb29yKHNhbXBsZUNvZWZmaWNpZW50ICogYml0UmF0ZSAvIHNhbXBsZVJhdGUgKyBwYWRkaW5nQml0KSAqIGJ5dGVzSW5TbG90O1xuICAgIGlmIChjaHJvbWVWZXJzaW9uJDEgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQgfHwgJyc7XG4gICAgICBjb25zdCByZXN1bHQgPSB1c2VyQWdlbnQubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS9pKTtcbiAgICAgIGNocm9tZVZlcnNpb24kMSA9IHJlc3VsdCA/IHBhcnNlSW50KHJlc3VsdFsxXSkgOiAwO1xuICAgIH1cbiAgICBjb25zdCBuZWVkQ2hyb21lRml4ID0gISFjaHJvbWVWZXJzaW9uJDEgJiYgY2hyb21lVmVyc2lvbiQxIDw9IDg3O1xuICAgIGlmIChuZWVkQ2hyb21lRml4ICYmIG1wZWdMYXllciA9PT0gMiAmJiBiaXRSYXRlID49IDIyNDAwMCAmJiBjaGFubmVsTW9kZSA9PT0gMCkge1xuICAgICAgLy8gV29yayBhcm91bmQgYnVnIGluIENocm9taXVtIGJ5IHNldHRpbmcgY2hhbm5lbE1vZGUgdG8gZHVhbC1jaGFubmVsICgwMSkgaW5zdGVhZCBvZiBzdGVyZW8gKDAwKVxuICAgICAgZGF0YVtvZmZzZXQgKyAzXSA9IGRhdGFbb2Zmc2V0ICsgM10gfCAweDgwO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc2FtcGxlUmF0ZSxcbiAgICAgIGNoYW5uZWxDb3VudCxcbiAgICAgIGZyYW1lTGVuZ3RoLFxuICAgICAgc2FtcGxlc1BlckZyYW1lXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG9mZnNldCkge1xuICByZXR1cm4gZGF0YVtvZmZzZXRdID09PSAweGZmICYmIChkYXRhW29mZnNldCArIDFdICYgMHhlMCkgPT09IDB4ZTAgJiYgKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDA2KSAhPT0gMHgwMDtcbn1cbmZ1bmN0aW9uIGlzSGVhZGVyKGRhdGEsIG9mZnNldCkge1xuICAvLyBMb29rIGZvciBNUEVHIGhlYWRlciB8IDExMTEgMTExMSB8IDExMVggWFlaWCB8IHdoZXJlIFggY2FuIGJlIGVpdGhlciAwIG9yIDEgYW5kIFkgb3IgWiBzaG91bGQgYmUgMVxuICAvLyBMYXllciBiaXRzIChwb3NpdGlvbiAxNCBhbmQgMTUpIGluIGhlYWRlciBzaG91bGQgYmUgYWx3YXlzIGRpZmZlcmVudCBmcm9tIDAgKExheWVyIEkgb3IgTGF5ZXIgSUkgb3IgTGF5ZXIgSUlJKVxuICAvLyBNb3JlIGluZm8gaHR0cDovL3d3dy5tcDMtdGVjaC5vcmcvcHJvZ3JhbW1lci9mcmFtZV9oZWFkZXIuaHRtbFxuICByZXR1cm4gb2Zmc2V0ICsgMSA8IGRhdGEubGVuZ3RoICYmIGlzSGVhZGVyUGF0dGVybihkYXRhLCBvZmZzZXQpO1xufVxuZnVuY3Rpb24gY2FuUGFyc2UoZGF0YSwgb2Zmc2V0KSB7XG4gIGNvbnN0IGhlYWRlclNpemUgPSA0O1xuICByZXR1cm4gaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG9mZnNldCkgJiYgaGVhZGVyU2l6ZSA8PSBkYXRhLmxlbmd0aCAtIG9mZnNldDtcbn1cbmZ1bmN0aW9uIHByb2JlKGRhdGEsIG9mZnNldCkge1xuICAvLyBzYW1lIGFzIGlzSGVhZGVyIGJ1dCB3ZSBhbHNvIGNoZWNrIHRoYXQgTVBFRyBmcmFtZSBmb2xsb3dzIGxhc3QgTVBFRyBmcmFtZVxuICAvLyBvciBlbmQgb2YgZGF0YSBpcyByZWFjaGVkXG4gIGlmIChvZmZzZXQgKyAxIDwgZGF0YS5sZW5ndGggJiYgaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG9mZnNldCkpIHtcbiAgICAvLyBNUEVHIGhlYWRlciBMZW5ndGhcbiAgICBjb25zdCBoZWFkZXJMZW5ndGggPSA0O1xuICAgIC8vIE1QRUcgZnJhbWUgTGVuZ3RoXG4gICAgY29uc3QgaGVhZGVyID0gcGFyc2VIZWFkZXIoZGF0YSwgb2Zmc2V0KTtcbiAgICBsZXQgZnJhbWVMZW5ndGggPSBoZWFkZXJMZW5ndGg7XG4gICAgaWYgKGhlYWRlciAhPSBudWxsICYmIGhlYWRlci5mcmFtZUxlbmd0aCkge1xuICAgICAgZnJhbWVMZW5ndGggPSBoZWFkZXIuZnJhbWVMZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IG5ld09mZnNldCA9IG9mZnNldCArIGZyYW1lTGVuZ3RoO1xuICAgIHJldHVybiBuZXdPZmZzZXQgPT09IGRhdGEubGVuZ3RoIHx8IGlzSGVhZGVyKGRhdGEsIG5ld09mZnNldCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEFBQyBkZW11eGVyXG4gKi9cbmNsYXNzIEFBQ0RlbXV4ZXIgZXh0ZW5kcyBCYXNlQXVkaW9EZW11eGVyIHtcbiAgY29uc3RydWN0b3Iob2JzZXJ2ZXIsIGNvbmZpZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vYnNlcnZlciA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gIH1cbiAgcmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbikge1xuICAgIHN1cGVyLnJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRyYWNrRHVyYXRpb24pO1xuICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSB7XG4gICAgICBjb250YWluZXI6ICdhdWRpby9hZHRzJyxcbiAgICAgIHR5cGU6ICdhdWRpbycsXG4gICAgICBpZDogMixcbiAgICAgIHBpZDogLTEsXG4gICAgICBzZXF1ZW5jZU51bWJlcjogMCxcbiAgICAgIHNlZ21lbnRDb2RlYzogJ2FhYycsXG4gICAgICBzYW1wbGVzOiBbXSxcbiAgICAgIG1hbmlmZXN0Q29kZWM6IGF1ZGlvQ29kZWMsXG4gICAgICBkdXJhdGlvbjogdHJhY2tEdXJhdGlvbixcbiAgICAgIGlucHV0VGltZVNjYWxlOiA5MDAwMCxcbiAgICAgIGRyb3BwZWQ6IDBcbiAgICB9O1xuICB9XG5cbiAgLy8gU291cmNlIGZvciBwcm9iZSBpbmZvIC0gaHR0cHM6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwP3RpdGxlPUFEVFNcbiAgc3RhdGljIHByb2JlKGRhdGEsIGxvZ2dlcikge1xuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciB0aGUgQURUUyBzeW5jIHdvcmRcbiAgICAvLyBMb29rIGZvciBBRFRTIGhlYWRlciB8IDExMTEgMTExMSB8IDExMTEgWDAwWCB8IHdoZXJlIFggY2FuIGJlIGVpdGhlciAwIG9yIDFcbiAgICAvLyBMYXllciBiaXRzIChwb3NpdGlvbiAxNCBhbmQgMTUpIGluIGhlYWRlciBzaG91bGQgYmUgYWx3YXlzIDAgZm9yIEFEVFNcbiAgICAvLyBNb3JlIGluZm8gaHR0cHM6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwP3RpdGxlPUFEVFNcbiAgICBjb25zdCBpZDNEYXRhID0gZ2V0SWQzRGF0YShkYXRhLCAwKTtcbiAgICBsZXQgb2Zmc2V0ID0gKGlkM0RhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGlkM0RhdGEubGVuZ3RoKSB8fCAwO1xuICAgIGlmIChwcm9iZShkYXRhLCBvZmZzZXQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGxlbmd0aCA9IGRhdGEubGVuZ3RoOyBvZmZzZXQgPCBsZW5ndGg7IG9mZnNldCsrKSB7XG4gICAgICBpZiAocHJvYmUkMShkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ0FEVFMgc3luYyB3b3JkIGZvdW5kICEnKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjYW5QYXJzZShkYXRhLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gY2FuUGFyc2UkMShkYXRhLCBvZmZzZXQpO1xuICB9XG4gIGFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQpIHtcbiAgICBpbml0VHJhY2tDb25maWcodHJhY2ssIHRoaXMub2JzZXJ2ZXIsIGRhdGEsIG9mZnNldCwgdHJhY2subWFuaWZlc3RDb2RlYyk7XG4gICAgY29uc3QgZnJhbWUgPSBhcHBlbmRGcmFtZSQyKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHRoaXMuYmFzZVBUUywgdGhpcy5mcmFtZUluZGV4KTtcbiAgICBpZiAoZnJhbWUgJiYgZnJhbWUubWlzc2luZyA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBnZXRBdWRpb0JTSUQgPSAoZGF0YSwgb2Zmc2V0KSA9PiB7XG4gIC8vIGNoZWNrIHRoZSBic2lkIHRvIGNvbmZpcm0gYWMtMyB8IGVjLTNcbiAgbGV0IGJzaWQgPSAwO1xuICBsZXQgbnVtQml0cyA9IDU7XG4gIG9mZnNldCArPSBudW1CaXRzO1xuICBjb25zdCB0ZW1wID0gbmV3IFVpbnQzMkFycmF5KDEpOyAvLyB1bnNpZ25lZCAzMiBiaXQgZm9yIHRlbXBvcmFyeSBzdG9yYWdlXG4gIGNvbnN0IG1hc2sgPSBuZXcgVWludDMyQXJyYXkoMSk7IC8vIHVuc2lnbmVkIDMyIGJpdCBtYXNrIHZhbHVlXG4gIGNvbnN0IGJ5dGUgPSBuZXcgVWludDhBcnJheSgxKTsgLy8gdW5zaWduZWQgOCBiaXQgZm9yIHRlbXBvcmFyeSBzdG9yYWdlXG4gIHdoaWxlIChudW1CaXRzID4gMCkge1xuICAgIGJ5dGVbMF0gPSBkYXRhW29mZnNldF07XG4gICAgLy8gcmVhZCByZW1haW5pbmcgYml0cywgdXB0byA4IGJpdHMgYXQgYSB0aW1lXG4gICAgY29uc3QgYml0cyA9IE1hdGgubWluKG51bUJpdHMsIDgpO1xuICAgIGNvbnN0IHNoaWZ0ID0gOCAtIGJpdHM7XG4gICAgbWFza1swXSA9IDB4ZmYwMDAwMDAgPj4+IDI0ICsgc2hpZnQgPDwgc2hpZnQ7XG4gICAgdGVtcFswXSA9IChieXRlWzBdICYgbWFza1swXSkgPj4gc2hpZnQ7XG4gICAgYnNpZCA9ICFic2lkID8gdGVtcFswXSA6IGJzaWQgPDwgYml0cyB8IHRlbXBbMF07XG4gICAgb2Zmc2V0ICs9IDE7XG4gICAgbnVtQml0cyAtPSBiaXRzO1xuICB9XG4gIHJldHVybiBic2lkO1xufTtcblxuY2xhc3MgQUMzRGVtdXhlciBleHRlbmRzIEJhc2VBdWRpb0RlbXV4ZXIge1xuICBjb25zdHJ1Y3RvcihvYnNlcnZlcikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vYnNlcnZlciA9IHZvaWQgMDtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gIH1cbiAgcmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbikge1xuICAgIHN1cGVyLnJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRyYWNrRHVyYXRpb24pO1xuICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSB7XG4gICAgICBjb250YWluZXI6ICdhdWRpby9hYy0zJyxcbiAgICAgIHR5cGU6ICdhdWRpbycsXG4gICAgICBpZDogMixcbiAgICAgIHBpZDogLTEsXG4gICAgICBzZXF1ZW5jZU51bWJlcjogMCxcbiAgICAgIHNlZ21lbnRDb2RlYzogJ2FjMycsXG4gICAgICBzYW1wbGVzOiBbXSxcbiAgICAgIG1hbmlmZXN0Q29kZWM6IGF1ZGlvQ29kZWMsXG4gICAgICBkdXJhdGlvbjogdHJhY2tEdXJhdGlvbixcbiAgICAgIGlucHV0VGltZVNjYWxlOiA5MDAwMCxcbiAgICAgIGRyb3BwZWQ6IDBcbiAgICB9O1xuICB9XG4gIGNhblBhcnNlKGRhdGEsIG9mZnNldCkge1xuICAgIHJldHVybiBvZmZzZXQgKyA2NCA8IGRhdGEubGVuZ3RoO1xuICB9XG4gIGFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQpIHtcbiAgICBjb25zdCBmcmFtZUxlbmd0aCA9IGFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHRoaXMuYmFzZVBUUywgdGhpcy5mcmFtZUluZGV4KTtcbiAgICBpZiAoZnJhbWVMZW5ndGggIT09IC0xKSB7XG4gICAgICBjb25zdCBzYW1wbGUgPSB0cmFjay5zYW1wbGVzW3RyYWNrLnNhbXBsZXMubGVuZ3RoIC0gMV07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzYW1wbGUsXG4gICAgICAgIGxlbmd0aDogZnJhbWVMZW5ndGgsXG4gICAgICAgIG1pc3Npbmc6IDBcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHN0YXRpYyBwcm9iZShkYXRhKSB7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGlkM0RhdGEgPSBnZXRJZDNEYXRhKGRhdGEsIDApO1xuICAgIGlmICghaWQzRGF0YSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGxvb2sgZm9yIHRoZSBhYy0zIHN5bmMgYnl0ZXNcbiAgICBjb25zdCBvZmZzZXQgPSBpZDNEYXRhLmxlbmd0aDtcbiAgICBpZiAoZGF0YVtvZmZzZXRdID09PSAweDBiICYmIGRhdGFbb2Zmc2V0ICsgMV0gPT09IDB4NzcgJiYgZ2V0SWQzVGltZXN0YW1wKGlkM0RhdGEpICE9PSB1bmRlZmluZWQgJiZcbiAgICAvLyBjaGVjayB0aGUgYnNpZCB0byBjb25maXJtIGFjLTNcbiAgICBnZXRBdWRpb0JTSUQoZGF0YSwgb2Zmc2V0KSA8IDE2KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBhcHBlbmRGcmFtZSh0cmFjaywgZGF0YSwgc3RhcnQsIHB0cywgZnJhbWVJbmRleCkge1xuICBpZiAoc3RhcnQgKyA4ID4gZGF0YS5sZW5ndGgpIHtcbiAgICByZXR1cm4gLTE7IC8vIG5vdCBlbm91Z2ggYnl0ZXMgbGVmdFxuICB9XG4gIGlmIChkYXRhW3N0YXJ0XSAhPT0gMHgwYiB8fCBkYXRhW3N0YXJ0ICsgMV0gIT09IDB4NzcpIHtcbiAgICByZXR1cm4gLTE7IC8vIGludmFsaWQgbWFnaWNcbiAgfVxuXG4gIC8vIGdldCBzYW1wbGUgcmF0ZVxuICBjb25zdCBzYW1wbGluZ1JhdGVDb2RlID0gZGF0YVtzdGFydCArIDRdID4+IDY7XG4gIGlmIChzYW1wbGluZ1JhdGVDb2RlID49IDMpIHtcbiAgICByZXR1cm4gLTE7IC8vIGludmFsaWQgc2FtcGxpbmcgcmF0ZVxuICB9XG4gIGNvbnN0IHNhbXBsaW5nUmF0ZU1hcCA9IFs0ODAwMCwgNDQxMDAsIDMyMDAwXTtcbiAgY29uc3Qgc2FtcGxlUmF0ZSA9IHNhbXBsaW5nUmF0ZU1hcFtzYW1wbGluZ1JhdGVDb2RlXTtcblxuICAvLyBnZXQgZnJhbWUgc2l6ZVxuICBjb25zdCBmcmFtZVNpemVDb2RlID0gZGF0YVtzdGFydCArIDRdICYgMHgzZjtcbiAgY29uc3QgZnJhbWVTaXplTWFwID0gWzY0LCA2OSwgOTYsIDY0LCA3MCwgOTYsIDgwLCA4NywgMTIwLCA4MCwgODgsIDEyMCwgOTYsIDEwNCwgMTQ0LCA5NiwgMTA1LCAxNDQsIDExMiwgMTIxLCAxNjgsIDExMiwgMTIyLCAxNjgsIDEyOCwgMTM5LCAxOTIsIDEyOCwgMTQwLCAxOTIsIDE2MCwgMTc0LCAyNDAsIDE2MCwgMTc1LCAyNDAsIDE5MiwgMjA4LCAyODgsIDE5MiwgMjA5LCAyODgsIDIyNCwgMjQzLCAzMzYsIDIyNCwgMjQ0LCAzMzYsIDI1NiwgMjc4LCAzODQsIDI1NiwgMjc5LCAzODQsIDMyMCwgMzQ4LCA0ODAsIDMyMCwgMzQ5LCA0ODAsIDM4NCwgNDE3LCA1NzYsIDM4NCwgNDE4LCA1NzYsIDQ0OCwgNDg3LCA2NzIsIDQ0OCwgNDg4LCA2NzIsIDUxMiwgNTU3LCA3NjgsIDUxMiwgNTU4LCA3NjgsIDY0MCwgNjk2LCA5NjAsIDY0MCwgNjk3LCA5NjAsIDc2OCwgODM1LCAxMTUyLCA3NjgsIDgzNiwgMTE1MiwgODk2LCA5NzUsIDEzNDQsIDg5NiwgOTc2LCAxMzQ0LCAxMDI0LCAxMTE0LCAxNTM2LCAxMDI0LCAxMTE1LCAxNTM2LCAxMTUyLCAxMjUzLCAxNzI4LCAxMTUyLCAxMjU0LCAxNzI4LCAxMjgwLCAxMzkzLCAxOTIwLCAxMjgwLCAxMzk0LCAxOTIwXTtcbiAgY29uc3QgZnJhbWVMZW5ndGggPSBmcmFtZVNpemVNYXBbZnJhbWVTaXplQ29kZSAqIDMgKyBzYW1wbGluZ1JhdGVDb2RlXSAqIDI7XG4gIGlmIChzdGFydCArIGZyYW1lTGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvLyBnZXQgY2hhbm5lbCBjb3VudFxuICBjb25zdCBjaGFubmVsTW9kZSA9IGRhdGFbc3RhcnQgKyA2XSA+PiA1O1xuICBsZXQgc2tpcENvdW50ID0gMDtcbiAgaWYgKGNoYW5uZWxNb2RlID09PSAyKSB7XG4gICAgc2tpcENvdW50ICs9IDI7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGNoYW5uZWxNb2RlICYgMSAmJiBjaGFubmVsTW9kZSAhPT0gMSkge1xuICAgICAgc2tpcENvdW50ICs9IDI7XG4gICAgfVxuICAgIGlmIChjaGFubmVsTW9kZSAmIDQpIHtcbiAgICAgIHNraXBDb3VudCArPSAyO1xuICAgIH1cbiAgfVxuICBjb25zdCBsZmVvbiA9IChkYXRhW3N0YXJ0ICsgNl0gPDwgOCB8IGRhdGFbc3RhcnQgKyA3XSkgPj4gMTIgLSBza2lwQ291bnQgJiAxO1xuICBjb25zdCBjaGFubmVsc01hcCA9IFsyLCAxLCAyLCAzLCAzLCA0LCA0LCA1XTtcbiAgY29uc3QgY2hhbm5lbENvdW50ID0gY2hhbm5lbHNNYXBbY2hhbm5lbE1vZGVdICsgbGZlb247XG5cbiAgLy8gYnVpbGQgZGFjMyBib3hcbiAgY29uc3QgYnNpZCA9IGRhdGFbc3RhcnQgKyA1XSA+PiAzO1xuICBjb25zdCBic21vZCA9IGRhdGFbc3RhcnQgKyA1XSAmIDc7XG4gIGNvbnN0IGNvbmZpZyA9IG5ldyBVaW50OEFycmF5KFtzYW1wbGluZ1JhdGVDb2RlIDw8IDYgfCBic2lkIDw8IDEgfCBic21vZCA+PiAyLCAoYnNtb2QgJiAzKSA8PCA2IHwgY2hhbm5lbE1vZGUgPDwgMyB8IGxmZW9uIDw8IDIgfCBmcmFtZVNpemVDb2RlID4+IDQsIGZyYW1lU2l6ZUNvZGUgPDwgNCAmIDB4ZTBdKTtcbiAgY29uc3QgZnJhbWVEdXJhdGlvbiA9IDE1MzYgLyBzYW1wbGVSYXRlICogOTAwMDA7XG4gIGNvbnN0IHN0YW1wID0gcHRzICsgZnJhbWVJbmRleCAqIGZyYW1lRHVyYXRpb247XG4gIGNvbnN0IHVuaXQgPSBkYXRhLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGZyYW1lTGVuZ3RoKTtcbiAgdHJhY2suY29uZmlnID0gY29uZmlnO1xuICB0cmFjay5jaGFubmVsQ291bnQgPSBjaGFubmVsQ291bnQ7XG4gIHRyYWNrLnNhbXBsZXJhdGUgPSBzYW1wbGVSYXRlO1xuICB0cmFjay5zYW1wbGVzLnB1c2goe1xuICAgIHVuaXQsXG4gICAgcHRzOiBzdGFtcFxuICB9KTtcbiAgcmV0dXJuIGZyYW1lTGVuZ3RoO1xufVxuXG4vKipcbiAqIE1QMyBkZW11eGVyXG4gKi9cbmNsYXNzIE1QM0RlbXV4ZXIgZXh0ZW5kcyBCYXNlQXVkaW9EZW11eGVyIHtcbiAgcmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbikge1xuICAgIHN1cGVyLnJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRyYWNrRHVyYXRpb24pO1xuICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSB7XG4gICAgICBjb250YWluZXI6ICdhdWRpby9tcGVnJyxcbiAgICAgIHR5cGU6ICdhdWRpbycsXG4gICAgICBpZDogMixcbiAgICAgIHBpZDogLTEsXG4gICAgICBzZXF1ZW5jZU51bWJlcjogMCxcbiAgICAgIHNlZ21lbnRDb2RlYzogJ21wMycsXG4gICAgICBzYW1wbGVzOiBbXSxcbiAgICAgIG1hbmlmZXN0Q29kZWM6IGF1ZGlvQ29kZWMsXG4gICAgICBkdXJhdGlvbjogdHJhY2tEdXJhdGlvbixcbiAgICAgIGlucHV0VGltZVNjYWxlOiA5MDAwMCxcbiAgICAgIGRyb3BwZWQ6IDBcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBwcm9iZShkYXRhKSB7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgZGF0YSBjb250YWlucyBJRDMgdGltZXN0YW1wIGFuZCBNUEVHIHN5bmMgd29yZFxuICAgIC8vIExvb2sgZm9yIE1QRUcgaGVhZGVyIHwgMTExMSAxMTExIHwgMTExWCBYWVpYIHwgd2hlcmUgWCBjYW4gYmUgZWl0aGVyIDAgb3IgMSBhbmQgWSBvciBaIHNob3VsZCBiZSAxXG4gICAgLy8gTGF5ZXIgYml0cyAocG9zaXRpb24gMTQgYW5kIDE1KSBpbiBoZWFkZXIgc2hvdWxkIGJlIGFsd2F5cyBkaWZmZXJlbnQgZnJvbSAwIChMYXllciBJIG9yIExheWVyIElJIG9yIExheWVyIElJSSlcbiAgICAvLyBNb3JlIGluZm8gaHR0cDovL3d3dy5tcDMtdGVjaC5vcmcvcHJvZ3JhbW1lci9mcmFtZV9oZWFkZXIuaHRtbFxuICAgIGNvbnN0IGlkM0RhdGEgPSBnZXRJZDNEYXRhKGRhdGEsIDApO1xuICAgIGxldCBvZmZzZXQgPSAoaWQzRGF0YSA9PSBudWxsID8gdm9pZCAwIDogaWQzRGF0YS5sZW5ndGgpIHx8IDA7XG5cbiAgICAvLyBDaGVjayBmb3IgYWMtM3xlYy0zIHN5bmMgYnl0ZXMgYW5kIHJldHVybiBmYWxzZSBpZiBwcmVzZW50XG4gICAgaWYgKGlkM0RhdGEgJiYgZGF0YVtvZmZzZXRdID09PSAweDBiICYmIGRhdGFbb2Zmc2V0ICsgMV0gPT09IDB4NzcgJiYgZ2V0SWQzVGltZXN0YW1wKGlkM0RhdGEpICE9PSB1bmRlZmluZWQgJiZcbiAgICAvLyBjaGVjayB0aGUgYnNpZCB0byBjb25maXJtIGFjLTMgb3IgZWMtMyAobm90IG1wMylcbiAgICBnZXRBdWRpb0JTSUQoZGF0YSwgb2Zmc2V0KSA8PSAxNikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBsZW5ndGggPSBkYXRhLmxlbmd0aDsgb2Zmc2V0IDwgbGVuZ3RoOyBvZmZzZXQrKykge1xuICAgICAgaWYgKHByb2JlKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnTVBFRyBBdWRpbyBzeW5jIHdvcmQgZm91bmQgIScpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNhblBhcnNlKGRhdGEsIG9mZnNldCkge1xuICAgIHJldHVybiBjYW5QYXJzZShkYXRhLCBvZmZzZXQpO1xuICB9XG4gIGFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQpIHtcbiAgICBpZiAodGhpcy5iYXNlUFRTID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBhcHBlbmRGcmFtZSQxKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHRoaXMuYmFzZVBUUywgdGhpcy5mcmFtZUluZGV4KTtcbiAgfVxufVxuXG5jb25zdCBlbXNnU2NoZW1lUGF0dGVybiA9IC9cXC9lbXNnWy0vXUlEMy9pO1xuY2xhc3MgTVA0RGVtdXhlciB7XG4gIGNvbnN0cnVjdG9yKG9ic2VydmVyLCBjb25maWcpIHtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIHRoaXMudGltZU9mZnNldCA9IDA7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy52aWRlb1RyYWNrID0gdm9pZCAwO1xuICAgIHRoaXMuYXVkaW9UcmFjayA9IHZvaWQgMDtcbiAgICB0aGlzLmlkM1RyYWNrID0gdm9pZCAwO1xuICAgIHRoaXMudHh0VHJhY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gIH1cbiAgcmVzZXRUaW1lU3RhbXAoKSB7fVxuICByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0cmFja0R1cmF0aW9uKSB7XG4gICAgY29uc3QgdmlkZW9UcmFjayA9IHRoaXMudmlkZW9UcmFjayA9IGR1bW15VHJhY2soJ3ZpZGVvJywgMSk7XG4gICAgY29uc3QgYXVkaW9UcmFjayA9IHRoaXMuYXVkaW9UcmFjayA9IGR1bW15VHJhY2soJ2F1ZGlvJywgMSk7XG4gICAgY29uc3QgY2FwdGlvblRyYWNrID0gdGhpcy50eHRUcmFjayA9IGR1bW15VHJhY2soJ3RleHQnLCAxKTtcbiAgICB0aGlzLmlkM1RyYWNrID0gZHVtbXlUcmFjaygnaWQzJywgMSk7XG4gICAgdGhpcy50aW1lT2Zmc2V0ID0gMDtcbiAgICBpZiAoIShpbml0U2VnbWVudCAhPSBudWxsICYmIGluaXRTZWdtZW50LmJ5dGVMZW5ndGgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGluaXREYXRhID0gcGFyc2VJbml0U2VnbWVudChpbml0U2VnbWVudCk7XG4gICAgaWYgKGluaXREYXRhLnZpZGVvKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGlkLFxuICAgICAgICB0aW1lc2NhbGUsXG4gICAgICAgIGNvZGVjLFxuICAgICAgICBzdXBwbGVtZW50YWxcbiAgICAgIH0gPSBpbml0RGF0YS52aWRlbztcbiAgICAgIHZpZGVvVHJhY2suaWQgPSBpZDtcbiAgICAgIHZpZGVvVHJhY2sudGltZXNjYWxlID0gY2FwdGlvblRyYWNrLnRpbWVzY2FsZSA9IHRpbWVzY2FsZTtcbiAgICAgIHZpZGVvVHJhY2suY29kZWMgPSBjb2RlYztcbiAgICAgIHZpZGVvVHJhY2suc3VwcGxlbWVudGFsID0gc3VwcGxlbWVudGFsO1xuICAgIH1cbiAgICBpZiAoaW5pdERhdGEuYXVkaW8pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaWQsXG4gICAgICAgIHRpbWVzY2FsZSxcbiAgICAgICAgY29kZWNcbiAgICAgIH0gPSBpbml0RGF0YS5hdWRpbztcbiAgICAgIGF1ZGlvVHJhY2suaWQgPSBpZDtcbiAgICAgIGF1ZGlvVHJhY2sudGltZXNjYWxlID0gdGltZXNjYWxlO1xuICAgICAgYXVkaW9UcmFjay5jb2RlYyA9IGNvZGVjO1xuICAgIH1cbiAgICBjYXB0aW9uVHJhY2suaWQgPSBSZW11eGVyVHJhY2tJZENvbmZpZy50ZXh0O1xuICAgIHZpZGVvVHJhY2suc2FtcGxlRHVyYXRpb24gPSAwO1xuICAgIHZpZGVvVHJhY2suZHVyYXRpb24gPSBhdWRpb1RyYWNrLmR1cmF0aW9uID0gdHJhY2tEdXJhdGlvbjtcbiAgfVxuICByZXNldENvbnRpZ3VpdHkoKSB7XG4gICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgfVxuICBzdGF0aWMgcHJvYmUoZGF0YSkge1xuICAgIHJldHVybiBoYXNNb29mRGF0YShkYXRhKTtcbiAgfVxuICBkZW11eChkYXRhLCB0aW1lT2Zmc2V0KSB7XG4gICAgdGhpcy50aW1lT2Zmc2V0ID0gdGltZU9mZnNldDtcbiAgICAvLyBMb2FkIGFsbCBkYXRhIGludG8gdGhlIGF2YyB0cmFjay4gVGhlIENNQUYgcmVtdXhlciB3aWxsIGxvb2sgZm9yIHRoZSBkYXRhIGluIHRoZSBzYW1wbGVzIG9iamVjdDsgdGhlIHJlc3Qgb2YgdGhlIGZpZWxkcyBkbyBub3QgbWF0dGVyXG4gICAgbGV0IHZpZGVvU2FtcGxlcyA9IGRhdGE7XG4gICAgY29uc3QgdmlkZW9UcmFjayA9IHRoaXMudmlkZW9UcmFjaztcbiAgICBjb25zdCB0ZXh0VHJhY2sgPSB0aGlzLnR4dFRyYWNrO1xuICAgIGlmICh0aGlzLmNvbmZpZy5wcm9ncmVzc2l2ZSkge1xuICAgICAgLy8gU3BsaXQgdGhlIGJ5dGVzdHJlYW0gaW50byB0d28gcmFuZ2VzOiBvbmUgZW5jb21wYXNzaW5nIGFsbCBkYXRhIHVwIHVudGlsIHRoZSBzdGFydCBvZiB0aGUgbGFzdCBtb29mLCBhbmQgZXZlcnl0aGluZyBlbHNlLlxuICAgICAgLy8gVGhpcyBpcyBkb25lIHRvIGd1YXJhbnRlZSB0aGF0IHdlJ3JlIHNlbmRpbmcgdmFsaWQgZGF0YSB0byBNU0UgLSB3aGVuIGRlbXV4aW5nIHByb2dyZXNzaXZlbHksIHdlIGhhdmUgbm8gZ3VhcmFudGVlXG4gICAgICAvLyB0aGF0IHRoZSBmZXRjaCBsb2FkZXIgZ2l2ZXMgdXMgZmx1c2ggbW9vZittZGF0IHBhaXJzLiBJZiB3ZSBwdXNoIGphZ2dlZCBkYXRhIHRvIE1TRSwgaXQgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24uXG4gICAgICBpZiAodGhpcy5yZW1haW5kZXJEYXRhKSB7XG4gICAgICAgIHZpZGVvU2FtcGxlcyA9IGFwcGVuZFVpbnQ4QXJyYXkodGhpcy5yZW1haW5kZXJEYXRhLCBkYXRhKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlZ21lbnRlZERhdGEgPSBzZWdtZW50VmFsaWRSYW5nZSh2aWRlb1NhbXBsZXMpO1xuICAgICAgdGhpcy5yZW1haW5kZXJEYXRhID0gc2VnbWVudGVkRGF0YS5yZW1haW5kZXI7XG4gICAgICB2aWRlb1RyYWNrLnNhbXBsZXMgPSBzZWdtZW50ZWREYXRhLnZhbGlkIHx8IG5ldyBVaW50OEFycmF5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpZGVvVHJhY2suc2FtcGxlcyA9IHZpZGVvU2FtcGxlcztcbiAgICB9XG4gICAgY29uc3QgaWQzVHJhY2sgPSB0aGlzLmV4dHJhY3RJRDNUcmFjayh2aWRlb1RyYWNrLCB0aW1lT2Zmc2V0KTtcbiAgICB0ZXh0VHJhY2suc2FtcGxlcyA9IHBhcnNlU2FtcGxlcyh0aW1lT2Zmc2V0LCB2aWRlb1RyYWNrKTtcbiAgICByZXR1cm4ge1xuICAgICAgdmlkZW9UcmFjayxcbiAgICAgIGF1ZGlvVHJhY2s6IHRoaXMuYXVkaW9UcmFjayxcbiAgICAgIGlkM1RyYWNrLFxuICAgICAgdGV4dFRyYWNrOiB0aGlzLnR4dFRyYWNrXG4gICAgfTtcbiAgfVxuICBmbHVzaCgpIHtcbiAgICBjb25zdCB0aW1lT2Zmc2V0ID0gdGhpcy50aW1lT2Zmc2V0O1xuICAgIGNvbnN0IHZpZGVvVHJhY2sgPSB0aGlzLnZpZGVvVHJhY2s7XG4gICAgY29uc3QgdGV4dFRyYWNrID0gdGhpcy50eHRUcmFjaztcbiAgICB2aWRlb1RyYWNrLnNhbXBsZXMgPSB0aGlzLnJlbWFpbmRlckRhdGEgfHwgbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIGNvbnN0IGlkM1RyYWNrID0gdGhpcy5leHRyYWN0SUQzVHJhY2sodmlkZW9UcmFjaywgdGhpcy50aW1lT2Zmc2V0KTtcbiAgICB0ZXh0VHJhY2suc2FtcGxlcyA9IHBhcnNlU2FtcGxlcyh0aW1lT2Zmc2V0LCB2aWRlb1RyYWNrKTtcbiAgICByZXR1cm4ge1xuICAgICAgdmlkZW9UcmFjayxcbiAgICAgIGF1ZGlvVHJhY2s6IGR1bW15VHJhY2soKSxcbiAgICAgIGlkM1RyYWNrLFxuICAgICAgdGV4dFRyYWNrOiBkdW1teVRyYWNrKClcbiAgICB9O1xuICB9XG4gIGV4dHJhY3RJRDNUcmFjayh2aWRlb1RyYWNrLCB0aW1lT2Zmc2V0KSB7XG4gICAgY29uc3QgaWQzVHJhY2sgPSB0aGlzLmlkM1RyYWNrO1xuICAgIGlmICh2aWRlb1RyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBlbXNncyA9IGZpbmRCb3godmlkZW9UcmFjay5zYW1wbGVzLCBbJ2Vtc2cnXSk7XG4gICAgICBpZiAoZW1zZ3MpIHtcbiAgICAgICAgZW1zZ3MuZm9yRWFjaChkYXRhID0+IHtcbiAgICAgICAgICBjb25zdCBlbXNnSW5mbyA9IHBhcnNlRW1zZyhkYXRhKTtcbiAgICAgICAgICBpZiAoZW1zZ1NjaGVtZVBhdHRlcm4udGVzdChlbXNnSW5mby5zY2hlbWVJZFVyaSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHB0cyA9IGdldEVtc2dTdGFydFRpbWUoZW1zZ0luZm8sIHRpbWVPZmZzZXQpO1xuICAgICAgICAgICAgbGV0IGR1cmF0aW9uID0gZW1zZ0luZm8uZXZlbnREdXJhdGlvbiA9PT0gMHhmZmZmZmZmZiA/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSA6IGVtc2dJbmZvLmV2ZW50RHVyYXRpb24gLyBlbXNnSW5mby50aW1lU2NhbGU7XG4gICAgICAgICAgICAvLyBTYWZhcmkgdGFrZXMgYW55dGhpbmcgPD0gMC4wMDEgc2Vjb25kcyBhbmQgbWFwcyBpdCB0byBJbmZpbml0eVxuICAgICAgICAgICAgaWYgKGR1cmF0aW9uIDw9IDAuMDAxKSB7XG4gICAgICAgICAgICAgIGR1cmF0aW9uID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGVtc2dJbmZvLnBheWxvYWQ7XG4gICAgICAgICAgICBpZDNUcmFjay5zYW1wbGVzLnB1c2goe1xuICAgICAgICAgICAgICBkYXRhOiBwYXlsb2FkLFxuICAgICAgICAgICAgICBsZW46IHBheWxvYWQuYnl0ZUxlbmd0aCxcbiAgICAgICAgICAgICAgZHRzOiBwdHMsXG4gICAgICAgICAgICAgIHB0czogcHRzLFxuICAgICAgICAgICAgICB0eXBlOiBNZXRhZGF0YVNjaGVtYS5lbXNnLFxuICAgICAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5jb25maWcuZW5hYmxlRW1zZ0tMVk1ldGFkYXRhICYmIGVtc2dJbmZvLnNjaGVtZUlkVXJpLnN0YXJ0c1dpdGgoJ3VybjptaXNiOktMVjpiaW46MTkxMC4xJykpIHtcbiAgICAgICAgICAgIGNvbnN0IHB0cyA9IGdldEVtc2dTdGFydFRpbWUoZW1zZ0luZm8sIHRpbWVPZmZzZXQpO1xuICAgICAgICAgICAgaWQzVHJhY2suc2FtcGxlcy5wdXNoKHtcbiAgICAgICAgICAgICAgZGF0YTogZW1zZ0luZm8ucGF5bG9hZCxcbiAgICAgICAgICAgICAgbGVuOiBlbXNnSW5mby5wYXlsb2FkLmJ5dGVMZW5ndGgsXG4gICAgICAgICAgICAgIGR0czogcHRzLFxuICAgICAgICAgICAgICBwdHM6IHB0cyxcbiAgICAgICAgICAgICAgdHlwZTogTWV0YWRhdGFTY2hlbWEubWlzYmtsdixcbiAgICAgICAgICAgICAgZHVyYXRpb246IE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlkM1RyYWNrO1xuICB9XG4gIGRlbXV4U2FtcGxlQWVzKGRhdGEsIGtleURhdGEsIHRpbWVPZmZzZXQpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdUaGUgTVA0IGRlbXV4ZXIgZG9lcyBub3Qgc3VwcG9ydCBTQU1QTEUtQUVTIGRlY3J5cHRpb24nKSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5jb25maWcgPSBudWxsO1xuICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgdGhpcy52aWRlb1RyYWNrID0gdGhpcy5hdWRpb1RyYWNrID0gdGhpcy5pZDNUcmFjayA9IHRoaXMudHh0VHJhY2sgPSB1bmRlZmluZWQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEVtc2dTdGFydFRpbWUoZW1zZ0luZm8sIHRpbWVPZmZzZXQpIHtcbiAgcmV0dXJuIGlzRmluaXRlTnVtYmVyKGVtc2dJbmZvLnByZXNlbnRhdGlvblRpbWUpID8gZW1zZ0luZm8ucHJlc2VudGF0aW9uVGltZSAvIGVtc2dJbmZvLnRpbWVTY2FsZSA6IHRpbWVPZmZzZXQgKyBlbXNnSW5mby5wcmVzZW50YXRpb25UaW1lRGVsdGEgLyBlbXNnSW5mby50aW1lU2NhbGU7XG59XG5cbi8qKlxuICogU0FNUExFLUFFUyBkZWNyeXB0ZXJcbiAqL1xuXG5jbGFzcyBTYW1wbGVBZXNEZWNyeXB0ZXIge1xuICBjb25zdHJ1Y3RvcihvYnNlcnZlciwgY29uZmlnLCBrZXlEYXRhKSB7XG4gICAgdGhpcy5rZXlEYXRhID0gdm9pZCAwO1xuICAgIHRoaXMuZGVjcnlwdGVyID0gdm9pZCAwO1xuICAgIHRoaXMua2V5RGF0YSA9IGtleURhdGE7XG4gICAgdGhpcy5kZWNyeXB0ZXIgPSBuZXcgRGVjcnlwdGVyKGNvbmZpZywge1xuICAgICAgcmVtb3ZlUEtDUzdQYWRkaW5nOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIGRlY3J5cHRCdWZmZXIoZW5jcnlwdGVkRGF0YSkge1xuICAgIHJldHVybiB0aGlzLmRlY3J5cHRlci5kZWNyeXB0KGVuY3J5cHRlZERhdGEsIHRoaXMua2V5RGF0YS5rZXkuYnVmZmVyLCB0aGlzLmtleURhdGEuaXYuYnVmZmVyLCBEZWNyeXB0ZXJBZXNNb2RlLmNiYyk7XG4gIH1cblxuICAvLyBBQUMgLSBlbmNyeXB0IGFsbCBmdWxsIDE2IGJ5dGVzIGJsb2NrcyBzdGFydGluZyBmcm9tIG9mZnNldCAxNlxuICBkZWNyeXB0QWFjU2FtcGxlKHNhbXBsZXMsIHNhbXBsZUluZGV4LCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGN1clVuaXQgPSBzYW1wbGVzW3NhbXBsZUluZGV4XS51bml0O1xuICAgIGlmIChjdXJVbml0Lmxlbmd0aCA8PSAxNikge1xuICAgICAgLy8gTm8gZW5jcnlwdGVkIHBvcnRpb24gaW4gdGhpcyBzYW1wbGUgKGZpcnN0IDE2IGJ5dGVzIGlzIG5vdFxuICAgICAgLy8gZW5jcnlwdGVkLCBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvYXJjaGl2ZS9kb2N1bWVudGF0aW9uL0F1ZGlvVmlkZW8vQ29uY2VwdHVhbC9ITFNfU2FtcGxlX0VuY3J5cHRpb24vRW5jcnlwdGlvbi9FbmNyeXB0aW9uLmh0bWwpLFxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlbmNyeXB0ZWREYXRhID0gY3VyVW5pdC5zdWJhcnJheSgxNiwgY3VyVW5pdC5sZW5ndGggLSBjdXJVbml0Lmxlbmd0aCAlIDE2KTtcbiAgICBjb25zdCBlbmNyeXB0ZWRCdWZmZXIgPSBlbmNyeXB0ZWREYXRhLmJ1ZmZlci5zbGljZShlbmNyeXB0ZWREYXRhLmJ5dGVPZmZzZXQsIGVuY3J5cHRlZERhdGEuYnl0ZU9mZnNldCArIGVuY3J5cHRlZERhdGEubGVuZ3RoKTtcbiAgICB0aGlzLmRlY3J5cHRCdWZmZXIoZW5jcnlwdGVkQnVmZmVyKS50aGVuKGRlY3J5cHRlZEJ1ZmZlciA9PiB7XG4gICAgICBjb25zdCBkZWNyeXB0ZWREYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGVjcnlwdGVkQnVmZmVyKTtcbiAgICAgIGN1clVuaXQuc2V0KGRlY3J5cHRlZERhdGEsIDE2KTtcbiAgICAgIGlmICghdGhpcy5kZWNyeXB0ZXIuaXNTeW5jKCkpIHtcbiAgICAgICAgdGhpcy5kZWNyeXB0QWFjU2FtcGxlcyhzYW1wbGVzLCBzYW1wbGVJbmRleCArIDEsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBkZWNyeXB0QWFjU2FtcGxlcyhzYW1wbGVzLCBzYW1wbGVJbmRleCwgY2FsbGJhY2spIHtcbiAgICBmb3IgKDs7IHNhbXBsZUluZGV4KyspIHtcbiAgICAgIGlmIChzYW1wbGVJbmRleCA+PSBzYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoc2FtcGxlc1tzYW1wbGVJbmRleF0udW5pdC5sZW5ndGggPCAzMikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVjcnlwdEFhY1NhbXBsZShzYW1wbGVzLCBzYW1wbGVJbmRleCwgY2FsbGJhY2spO1xuICAgICAgaWYgKCF0aGlzLmRlY3J5cHRlci5pc1N5bmMoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQVZDIC0gZW5jcnlwdCBvbmUgMTYgYnl0ZXMgYmxvY2sgb3V0IG9mIHRlbiwgc3RhcnRpbmcgZnJvbSBvZmZzZXQgMzJcbiAgZ2V0QXZjRW5jcnlwdGVkRGF0YShkZWNvZGVkRGF0YSkge1xuICAgIGNvbnN0IGVuY3J5cHRlZERhdGFMZW4gPSBNYXRoLmZsb29yKChkZWNvZGVkRGF0YS5sZW5ndGggLSA0OCkgLyAxNjApICogMTYgKyAxNjtcbiAgICBjb25zdCBlbmNyeXB0ZWREYXRhID0gbmV3IEludDhBcnJheShlbmNyeXB0ZWREYXRhTGVuKTtcbiAgICBsZXQgb3V0cHV0UG9zID0gMDtcbiAgICBmb3IgKGxldCBpbnB1dFBvcyA9IDMyOyBpbnB1dFBvcyA8IGRlY29kZWREYXRhLmxlbmd0aCAtIDE2OyBpbnB1dFBvcyArPSAxNjAsIG91dHB1dFBvcyArPSAxNikge1xuICAgICAgZW5jcnlwdGVkRGF0YS5zZXQoZGVjb2RlZERhdGEuc3ViYXJyYXkoaW5wdXRQb3MsIGlucHV0UG9zICsgMTYpLCBvdXRwdXRQb3MpO1xuICAgIH1cbiAgICByZXR1cm4gZW5jcnlwdGVkRGF0YTtcbiAgfVxuICBnZXRBdmNEZWNyeXB0ZWRVbml0KGRlY29kZWREYXRhLCBkZWNyeXB0ZWREYXRhKSB7XG4gICAgY29uc3QgdWludDhEZWNyeXB0ZWREYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGVjcnlwdGVkRGF0YSk7XG4gICAgbGV0IGlucHV0UG9zID0gMDtcbiAgICBmb3IgKGxldCBvdXRwdXRQb3MgPSAzMjsgb3V0cHV0UG9zIDwgZGVjb2RlZERhdGEubGVuZ3RoIC0gMTY7IG91dHB1dFBvcyArPSAxNjAsIGlucHV0UG9zICs9IDE2KSB7XG4gICAgICBkZWNvZGVkRGF0YS5zZXQodWludDhEZWNyeXB0ZWREYXRhLnN1YmFycmF5KGlucHV0UG9zLCBpbnB1dFBvcyArIDE2KSwgb3V0cHV0UG9zKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZWREYXRhO1xuICB9XG4gIGRlY3J5cHRBdmNTYW1wbGUoc2FtcGxlcywgc2FtcGxlSW5kZXgsIHVuaXRJbmRleCwgY2FsbGJhY2ssIGN1clVuaXQpIHtcbiAgICBjb25zdCBkZWNvZGVkRGF0YSA9IGRpc2NhcmRFUEIoY3VyVW5pdC5kYXRhKTtcbiAgICBjb25zdCBlbmNyeXB0ZWREYXRhID0gdGhpcy5nZXRBdmNFbmNyeXB0ZWREYXRhKGRlY29kZWREYXRhKTtcbiAgICB0aGlzLmRlY3J5cHRCdWZmZXIoZW5jcnlwdGVkRGF0YS5idWZmZXIpLnRoZW4oZGVjcnlwdGVkQnVmZmVyID0+IHtcbiAgICAgIGN1clVuaXQuZGF0YSA9IHRoaXMuZ2V0QXZjRGVjcnlwdGVkVW5pdChkZWNvZGVkRGF0YSwgZGVjcnlwdGVkQnVmZmVyKTtcbiAgICAgIGlmICghdGhpcy5kZWNyeXB0ZXIuaXNTeW5jKCkpIHtcbiAgICAgICAgdGhpcy5kZWNyeXB0QXZjU2FtcGxlcyhzYW1wbGVzLCBzYW1wbGVJbmRleCwgdW5pdEluZGV4ICsgMSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGRlY3J5cHRBdmNTYW1wbGVzKHNhbXBsZXMsIHNhbXBsZUluZGV4LCB1bml0SW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHNhbXBsZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBkZWNyeXB0IHNhbXBsZXMgb2YgdHlwZSBVaW50OEFycmF5Jyk7XG4gICAgfVxuICAgIGZvciAoOzsgc2FtcGxlSW5kZXgrKywgdW5pdEluZGV4ID0gMCkge1xuICAgICAgaWYgKHNhbXBsZUluZGV4ID49IHNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGN1clVuaXRzID0gc2FtcGxlc1tzYW1wbGVJbmRleF0udW5pdHM7XG4gICAgICBmb3IgKDs7IHVuaXRJbmRleCsrKSB7XG4gICAgICAgIGlmICh1bml0SW5kZXggPj0gY3VyVW5pdHMubGVuZ3RoKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VyVW5pdCA9IGN1clVuaXRzW3VuaXRJbmRleF07XG4gICAgICAgIGlmIChjdXJVbml0LmRhdGEubGVuZ3RoIDw9IDQ4IHx8IGN1clVuaXQudHlwZSAhPT0gMSAmJiBjdXJVbml0LnR5cGUgIT09IDUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlY3J5cHRBdmNTYW1wbGUoc2FtcGxlcywgc2FtcGxlSW5kZXgsIHVuaXRJbmRleCwgY2FsbGJhY2ssIGN1clVuaXQpO1xuICAgICAgICBpZiAoIXRoaXMuZGVjcnlwdGVyLmlzU3luYygpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIEJhc2VWaWRlb1BhcnNlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuVmlkZW9TYW1wbGUgPSBudWxsO1xuICB9XG4gIGNyZWF0ZVZpZGVvU2FtcGxlKGtleSwgcHRzLCBkdHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2V5LFxuICAgICAgZnJhbWU6IGZhbHNlLFxuICAgICAgcHRzLFxuICAgICAgZHRzLFxuICAgICAgdW5pdHM6IFtdLFxuICAgICAgbGVuZ3RoOiAwXG4gICAgfTtcbiAgfVxuICBnZXRMYXN0TmFsVW5pdChzYW1wbGVzKSB7XG4gICAgdmFyIF9WaWRlb1NhbXBsZTtcbiAgICBsZXQgVmlkZW9TYW1wbGUgPSB0aGlzLlZpZGVvU2FtcGxlO1xuICAgIGxldCBsYXN0VW5pdDtcbiAgICAvLyB0cnkgdG8gZmFsbGJhY2sgdG8gcHJldmlvdXMgc2FtcGxlIGlmIGN1cnJlbnQgb25lIGlzIGVtcHR5XG4gICAgaWYgKCFWaWRlb1NhbXBsZSB8fCBWaWRlb1NhbXBsZS51bml0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIFZpZGVvU2FtcGxlID0gc2FtcGxlc1tzYW1wbGVzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBpZiAoKF9WaWRlb1NhbXBsZSA9IFZpZGVvU2FtcGxlKSAhPSBudWxsICYmIF9WaWRlb1NhbXBsZS51bml0cykge1xuICAgICAgY29uc3QgdW5pdHMgPSBWaWRlb1NhbXBsZS51bml0cztcbiAgICAgIGxhc3RVbml0ID0gdW5pdHNbdW5pdHMubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHJldHVybiBsYXN0VW5pdDtcbiAgfVxuICBwdXNoQWNjZXNzVW5pdChWaWRlb1NhbXBsZSwgdmlkZW9UcmFjaykge1xuICAgIGlmIChWaWRlb1NhbXBsZS51bml0cy5sZW5ndGggJiYgVmlkZW9TYW1wbGUuZnJhbWUpIHtcbiAgICAgIC8vIGlmIHNhbXBsZSBkb2VzIG5vdCBoYXZlIFBUUy9EVFMsIHBhdGNoIHdpdGggbGFzdCBzYW1wbGUgUFRTL0RUU1xuICAgICAgaWYgKFZpZGVvU2FtcGxlLnB0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHNhbXBsZXMgPSB2aWRlb1RyYWNrLnNhbXBsZXM7XG4gICAgICAgIGNvbnN0IG5iU2FtcGxlcyA9IHNhbXBsZXMubGVuZ3RoO1xuICAgICAgICBpZiAobmJTYW1wbGVzKSB7XG4gICAgICAgICAgY29uc3QgbGFzdFNhbXBsZSA9IHNhbXBsZXNbbmJTYW1wbGVzIC0gMV07XG4gICAgICAgICAgVmlkZW9TYW1wbGUucHRzID0gbGFzdFNhbXBsZS5wdHM7XG4gICAgICAgICAgVmlkZW9TYW1wbGUuZHRzID0gbGFzdFNhbXBsZS5kdHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZHJvcHBpbmcgc2FtcGxlcywgbm8gdGltZXN0YW1wIGZvdW5kXG4gICAgICAgICAgdmlkZW9UcmFjay5kcm9wcGVkKys7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2aWRlb1RyYWNrLnNhbXBsZXMucHVzaChWaWRlb1NhbXBsZSk7XG4gICAgfVxuICB9XG4gIHBhcnNlTkFMdSh0cmFjaywgYXJyYXksIGVuZE9mU2VnbWVudCkge1xuICAgIGNvbnN0IGxlbiA9IGFycmF5LmJ5dGVMZW5ndGg7XG4gICAgbGV0IHN0YXRlID0gdHJhY2submFsdVN0YXRlIHx8IDA7XG4gICAgY29uc3QgbGFzdFN0YXRlID0gc3RhdGU7XG4gICAgY29uc3QgdW5pdHMgPSBbXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IHZhbHVlO1xuICAgIGxldCBvdmVyZmxvdztcbiAgICBsZXQgdW5pdFR5cGU7XG4gICAgbGV0IGxhc3RVbml0U3RhcnQgPSAtMTtcbiAgICBsZXQgbGFzdFVuaXRUeXBlID0gMDtcbiAgICAvLyBsb2dnZXIubG9nKCdQRVM6JyArIEhleC5oZXhEdW1wKGFycmF5KSk7XG5cbiAgICBpZiAoc3RhdGUgPT09IC0xKSB7XG4gICAgICAvLyBzcGVjaWFsIHVzZSBjYXNlIHdoZXJlIHdlIGZvdW5kIDMgb3IgNC1ieXRlIHN0YXJ0IGNvZGVzIGV4YWN0bHkgYXQgdGhlIGVuZCBvZiBwcmV2aW91cyBQRVMgcGFja2V0XG4gICAgICBsYXN0VW5pdFN0YXJ0ID0gMDtcbiAgICAgIC8vIE5BTHUgdHlwZSBpcyB2YWx1ZSByZWFkIGZyb20gb2Zmc2V0IDBcbiAgICAgIGxhc3RVbml0VHlwZSA9IHRoaXMuZ2V0TkFMdVR5cGUoYXJyYXksIDApO1xuICAgICAgc3RhdGUgPSAwO1xuICAgICAgaSA9IDE7XG4gICAgfVxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICB2YWx1ZSA9IGFycmF5W2krK107XG4gICAgICAvLyBvcHRpbWl6YXRpb24uIHN0YXRlIDAgYW5kIDEgYXJlIHRoZSBwcmVkb21pbmFudCBjYXNlLiBsZXQncyBoYW5kbGUgdGhlbSBvdXRzaWRlIG9mIHRoZSBzd2l0Y2gvY2FzZVxuICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICBzdGF0ZSA9IHZhbHVlID8gMCA6IDE7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlID09PSAxKSB7XG4gICAgICAgIHN0YXRlID0gdmFsdWUgPyAwIDogMjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBoZXJlIHdlIGhhdmUgc3RhdGUgZWl0aGVyIGVxdWFsIHRvIDIgb3IgM1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICBzdGF0ZSA9IDM7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAxKSB7XG4gICAgICAgIG92ZXJmbG93ID0gaSAtIHN0YXRlIC0gMTtcbiAgICAgICAgaWYgKGxhc3RVbml0U3RhcnQgPj0gMCkge1xuICAgICAgICAgIGNvbnN0IHVuaXQgPSB7XG4gICAgICAgICAgICBkYXRhOiBhcnJheS5zdWJhcnJheShsYXN0VW5pdFN0YXJ0LCBvdmVyZmxvdyksXG4gICAgICAgICAgICB0eXBlOiBsYXN0VW5pdFR5cGVcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ3B1c2hpbmcgTkFMVSwgdHlwZS9zaXplOicgKyB1bml0LnR5cGUgKyAnLycgKyB1bml0LmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgdW5pdHMucHVzaCh1bml0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBsYXN0VW5pdFN0YXJ0IGlzIHVuZGVmaW5lZCA9PiB0aGlzIGlzIHRoZSBmaXJzdCBzdGFydCBjb2RlIGZvdW5kIGluIHRoaXMgUEVTIHBhY2tldFxuICAgICAgICAgIC8vIGZpcnN0IGNoZWNrIGlmIHN0YXJ0IGNvZGUgZGVsaW1pdGVyIGlzIG92ZXJsYXBwaW5nIGJldHdlZW4gMiBQRVMgcGFja2V0cyxcbiAgICAgICAgICAvLyBpZSBpdCBzdGFydGVkIGluIGxhc3QgcGFja2V0IChsYXN0U3RhdGUgbm90IHplcm8pXG4gICAgICAgICAgLy8gYW5kIGVuZGVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBQRVMgcGFja2V0IChpIDw9IDQgLSBsYXN0U3RhdGUpXG4gICAgICAgICAgY29uc3QgbGFzdFVuaXQgPSB0aGlzLmdldExhc3ROYWxVbml0KHRyYWNrLnNhbXBsZXMpO1xuICAgICAgICAgIGlmIChsYXN0VW5pdCkge1xuICAgICAgICAgICAgaWYgKGxhc3RTdGF0ZSAmJiBpIDw9IDQgLSBsYXN0U3RhdGUpIHtcbiAgICAgICAgICAgICAgLy8gc3RhcnQgZGVsaW1pdGVyIG92ZXJsYXBwaW5nIGJldHdlZW4gUEVTIHBhY2tldHNcbiAgICAgICAgICAgICAgLy8gc3RyaXAgc3RhcnQgZGVsaW1pdGVyIGJ5dGVzIGZyb20gdGhlIGVuZCBvZiBsYXN0IE5BTCB1bml0XG4gICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGxhc3RVbml0IGhhZCBhIHN0YXRlIGRpZmZlcmVudCBmcm9tIHplcm9cbiAgICAgICAgICAgICAgaWYgKGxhc3RVbml0LnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RyaXAgbGFzdCBieXRlc1xuICAgICAgICAgICAgICAgIGxhc3RVbml0LmRhdGEgPSBsYXN0VW5pdC5kYXRhLnN1YmFycmF5KDAsIGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCAtIGxhc3RTdGF0ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIE5BTCB1bml0cyBhcmUgbm90IHN0YXJ0aW5nIHJpZ2h0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIFBFUyBwYWNrZXQsIHB1c2ggcHJlY2VkaW5nIGRhdGEgaW50byBwcmV2aW91cyBOQUwgdW5pdC5cblxuICAgICAgICAgICAgaWYgKG92ZXJmbG93ID4gMCkge1xuICAgICAgICAgICAgICAvLyBsb2dnZXIubG9nKCdmaXJzdCBOQUxVIGZvdW5kIHdpdGggb3ZlcmZsb3c6JyArIG92ZXJmbG93KTtcbiAgICAgICAgICAgICAgbGFzdFVuaXQuZGF0YSA9IGFwcGVuZFVpbnQ4QXJyYXkobGFzdFVuaXQuZGF0YSwgYXJyYXkuc3ViYXJyYXkoMCwgb3ZlcmZsb3cpKTtcbiAgICAgICAgICAgICAgbGFzdFVuaXQuc3RhdGUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBpZiB3ZSBjYW4gcmVhZCB1bml0IHR5cGVcbiAgICAgICAgaWYgKGkgPCBsZW4pIHtcbiAgICAgICAgICB1bml0VHlwZSA9IHRoaXMuZ2V0TkFMdVR5cGUoYXJyYXksIGkpO1xuICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ2ZpbmQgTkFMVSBAIG9mZnNldDonICsgaSArICcsdHlwZTonICsgdW5pdFR5cGUpO1xuICAgICAgICAgIGxhc3RVbml0U3RhcnQgPSBpO1xuICAgICAgICAgIGxhc3RVbml0VHlwZSA9IHVuaXRUeXBlO1xuICAgICAgICAgIHN0YXRlID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBub3QgZW5vdWdoIGJ5dGUgdG8gcmVhZCB1bml0IHR5cGUuIGxldCdzIHJlYWQgaXQgb24gbmV4dCBQRVMgcGFyc2luZ1xuICAgICAgICAgIHN0YXRlID0gLTE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxhc3RVbml0U3RhcnQgPj0gMCAmJiBzdGF0ZSA+PSAwKSB7XG4gICAgICBjb25zdCB1bml0ID0ge1xuICAgICAgICBkYXRhOiBhcnJheS5zdWJhcnJheShsYXN0VW5pdFN0YXJ0LCBsZW4pLFxuICAgICAgICB0eXBlOiBsYXN0VW5pdFR5cGUsXG4gICAgICAgIHN0YXRlOiBzdGF0ZVxuICAgICAgfTtcbiAgICAgIHVuaXRzLnB1c2godW5pdCk7XG4gICAgICAvLyBsb2dnZXIubG9nKCdwdXNoaW5nIE5BTFUsIHR5cGUvc2l6ZS9zdGF0ZTonICsgdW5pdC50eXBlICsgJy8nICsgdW5pdC5kYXRhLmJ5dGVMZW5ndGggKyAnLycgKyBzdGF0ZSk7XG4gICAgfVxuICAgIC8vIG5vIE5BTHUgZm91bmRcbiAgICBpZiAodW5pdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBhcHBlbmQgcGVzLmRhdGEgdG8gcHJldmlvdXMgTkFMIHVuaXRcbiAgICAgIGNvbnN0IGxhc3RVbml0ID0gdGhpcy5nZXRMYXN0TmFsVW5pdCh0cmFjay5zYW1wbGVzKTtcbiAgICAgIGlmIChsYXN0VW5pdCkge1xuICAgICAgICBsYXN0VW5pdC5kYXRhID0gYXBwZW5kVWludDhBcnJheShsYXN0VW5pdC5kYXRhLCBhcnJheSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRyYWNrLm5hbHVTdGF0ZSA9IHN0YXRlO1xuICAgIHJldHVybiB1bml0cztcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlciBmb3IgZXhwb25lbnRpYWwgR29sb21iIGNvZGVzLCBhIHZhcmlhYmxlLWJpdHdpZHRoIG51bWJlciBlbmNvZGluZyBzY2hlbWUgdXNlZCBieSBoMjY0LlxuICovXG5cbmNsYXNzIEV4cEdvbG9tYiB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICB0aGlzLmRhdGEgPSB2b2lkIDA7XG4gICAgdGhpcy5ieXRlc0F2YWlsYWJsZSA9IHZvaWQgMDtcbiAgICB0aGlzLndvcmQgPSB2b2lkIDA7XG4gICAgdGhpcy5iaXRzQXZhaWxhYmxlID0gdm9pZCAwO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgLy8gdGhlIG51bWJlciBvZiBieXRlcyBsZWZ0IHRvIGV4YW1pbmUgaW4gdGhpcy5kYXRhXG4gICAgdGhpcy5ieXRlc0F2YWlsYWJsZSA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAvLyB0aGUgY3VycmVudCB3b3JkIGJlaW5nIGV4YW1pbmVkXG4gICAgdGhpcy53b3JkID0gMDsgLy8gOnVpbnRcbiAgICAvLyB0aGUgbnVtYmVyIG9mIGJpdHMgbGVmdCB0byBleGFtaW5lIGluIHRoZSBjdXJyZW50IHdvcmRcbiAgICB0aGlzLmJpdHNBdmFpbGFibGUgPSAwOyAvLyA6dWludFxuICB9XG5cbiAgLy8gKCk6dm9pZFxuICBsb2FkV29yZCgpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGNvbnN0IGJ5dGVzQXZhaWxhYmxlID0gdGhpcy5ieXRlc0F2YWlsYWJsZTtcbiAgICBjb25zdCBwb3NpdGlvbiA9IGRhdGEuYnl0ZUxlbmd0aCAtIGJ5dGVzQXZhaWxhYmxlO1xuICAgIGNvbnN0IHdvcmtpbmdCeXRlcyA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIGNvbnN0IGF2YWlsYWJsZUJ5dGVzID0gTWF0aC5taW4oNCwgYnl0ZXNBdmFpbGFibGUpO1xuICAgIGlmIChhdmFpbGFibGVCeXRlcyA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBieXRlcyBhdmFpbGFibGUnKTtcbiAgICB9XG4gICAgd29ya2luZ0J5dGVzLnNldChkYXRhLnN1YmFycmF5KHBvc2l0aW9uLCBwb3NpdGlvbiArIGF2YWlsYWJsZUJ5dGVzKSk7XG4gICAgdGhpcy53b3JkID0gbmV3IERhdGFWaWV3KHdvcmtpbmdCeXRlcy5idWZmZXIpLmdldFVpbnQzMigwKTtcbiAgICAvLyB0cmFjayB0aGUgYW1vdW50IG9mIHRoaXMuZGF0YSB0aGF0IGhhcyBiZWVuIHByb2Nlc3NlZFxuICAgIHRoaXMuYml0c0F2YWlsYWJsZSA9IGF2YWlsYWJsZUJ5dGVzICogODtcbiAgICB0aGlzLmJ5dGVzQXZhaWxhYmxlIC09IGF2YWlsYWJsZUJ5dGVzO1xuICB9XG5cbiAgLy8gKGNvdW50OmludCk6dm9pZFxuICBza2lwQml0cyhjb3VudCkge1xuICAgIGxldCBza2lwQnl0ZXM7IC8vIDppbnRcbiAgICBjb3VudCA9IE1hdGgubWluKGNvdW50LCB0aGlzLmJ5dGVzQXZhaWxhYmxlICogOCArIHRoaXMuYml0c0F2YWlsYWJsZSk7XG4gICAgaWYgKHRoaXMuYml0c0F2YWlsYWJsZSA+IGNvdW50KSB7XG4gICAgICB0aGlzLndvcmQgPDw9IGNvdW50O1xuICAgICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGNvdW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCAtPSB0aGlzLmJpdHNBdmFpbGFibGU7XG4gICAgICBza2lwQnl0ZXMgPSBjb3VudCA+PiAzO1xuICAgICAgY291bnQgLT0gc2tpcEJ5dGVzIDw8IDM7XG4gICAgICB0aGlzLmJ5dGVzQXZhaWxhYmxlIC09IHNraXBCeXRlcztcbiAgICAgIHRoaXMubG9hZFdvcmQoKTtcbiAgICAgIHRoaXMud29yZCA8PD0gY291bnQ7XG4gICAgICB0aGlzLmJpdHNBdmFpbGFibGUgLT0gY291bnQ7XG4gICAgfVxuICB9XG5cbiAgLy8gKHNpemU6aW50KTp1aW50XG4gIHJlYWRCaXRzKHNpemUpIHtcbiAgICBsZXQgYml0cyA9IE1hdGgubWluKHRoaXMuYml0c0F2YWlsYWJsZSwgc2l6ZSk7IC8vIDp1aW50XG4gICAgY29uc3QgdmFsdSA9IHRoaXMud29yZCA+Pj4gMzIgLSBiaXRzOyAvLyA6dWludFxuICAgIGlmIChzaXplID4gMzIpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignQ2Fubm90IHJlYWQgbW9yZSB0aGFuIDMyIGJpdHMgYXQgYSB0aW1lJyk7XG4gICAgfVxuICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBiaXRzO1xuICAgIGlmICh0aGlzLmJpdHNBdmFpbGFibGUgPiAwKSB7XG4gICAgICB0aGlzLndvcmQgPDw9IGJpdHM7XG4gICAgfSBlbHNlIGlmICh0aGlzLmJ5dGVzQXZhaWxhYmxlID4gMCkge1xuICAgICAgdGhpcy5sb2FkV29yZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGJpdHMgYXZhaWxhYmxlJyk7XG4gICAgfVxuICAgIGJpdHMgPSBzaXplIC0gYml0cztcbiAgICBpZiAoYml0cyA+IDAgJiYgdGhpcy5iaXRzQXZhaWxhYmxlKSB7XG4gICAgICByZXR1cm4gdmFsdSA8PCBiaXRzIHwgdGhpcy5yZWFkQml0cyhiaXRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbHU7XG4gICAgfVxuICB9XG5cbiAgLy8gKCk6dWludFxuICBza2lwTFooKSB7XG4gICAgbGV0IGxlYWRpbmdaZXJvQ291bnQ7IC8vIDp1aW50XG4gICAgZm9yIChsZWFkaW5nWmVyb0NvdW50ID0gMDsgbGVhZGluZ1plcm9Db3VudCA8IHRoaXMuYml0c0F2YWlsYWJsZTsgKytsZWFkaW5nWmVyb0NvdW50KSB7XG4gICAgICBpZiAoKHRoaXMud29yZCAmIDB4ODAwMDAwMDAgPj4+IGxlYWRpbmdaZXJvQ291bnQpICE9PSAwKSB7XG4gICAgICAgIC8vIHRoZSBmaXJzdCBiaXQgb2Ygd29ya2luZyB3b3JkIGlzIDFcbiAgICAgICAgdGhpcy53b3JkIDw8PSBsZWFkaW5nWmVyb0NvdW50O1xuICAgICAgICB0aGlzLmJpdHNBdmFpbGFibGUgLT0gbGVhZGluZ1plcm9Db3VudDtcbiAgICAgICAgcmV0dXJuIGxlYWRpbmdaZXJvQ291bnQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHdlIGV4aGF1c3RlZCB3b3JkIGFuZCBzdGlsbCBoYXZlIG5vdCBmb3VuZCBhIDFcbiAgICB0aGlzLmxvYWRXb3JkKCk7XG4gICAgcmV0dXJuIGxlYWRpbmdaZXJvQ291bnQgKyB0aGlzLnNraXBMWigpO1xuICB9XG5cbiAgLy8gKCk6dm9pZFxuICBza2lwVUVHKCkge1xuICAgIHRoaXMuc2tpcEJpdHMoMSArIHRoaXMuc2tpcExaKCkpO1xuICB9XG5cbiAgLy8gKCk6dm9pZFxuICBza2lwRUcoKSB7XG4gICAgdGhpcy5za2lwQml0cygxICsgdGhpcy5za2lwTFooKSk7XG4gIH1cblxuICAvLyAoKTp1aW50XG4gIHJlYWRVRUcoKSB7XG4gICAgY29uc3QgY2x6ID0gdGhpcy5za2lwTFooKTsgLy8gOnVpbnRcbiAgICByZXR1cm4gdGhpcy5yZWFkQml0cyhjbHogKyAxKSAtIDE7XG4gIH1cblxuICAvLyAoKTppbnRcbiAgcmVhZEVHKCkge1xuICAgIGNvbnN0IHZhbHUgPSB0aGlzLnJlYWRVRUcoKTsgLy8gOmludFxuICAgIGlmICgweDAxICYgdmFsdSkge1xuICAgICAgLy8gdGhlIG51bWJlciBpcyBvZGQgaWYgdGhlIGxvdyBvcmRlciBiaXQgaXMgc2V0XG4gICAgICByZXR1cm4gMSArIHZhbHUgPj4+IDE7IC8vIGFkZCAxIHRvIG1ha2UgaXQgZXZlbiwgYW5kIGRpdmlkZSBieSAyXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAtMSAqICh2YWx1ID4+PiAxKTsgLy8gZGl2aWRlIGJ5IHR3byB0aGVuIG1ha2UgaXQgbmVnYXRpdmVcbiAgICB9XG4gIH1cblxuICAvLyBTb21lIGNvbnZlbmllbmNlIGZ1bmN0aW9uc1xuICAvLyA6Qm9vbGVhblxuICByZWFkQm9vbGVhbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkQml0cygxKSA9PT0gMTtcbiAgfVxuXG4gIC8vICgpOmludFxuICByZWFkVUJ5dGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoOCk7XG4gIH1cblxuICAvLyAoKTppbnRcbiAgcmVhZFVTaG9ydCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkQml0cygxNik7XG4gIH1cblxuICAvLyAoKTppbnRcbiAgcmVhZFVJbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoMzIpO1xuICB9XG59XG5cbmNsYXNzIEF2Y1ZpZGVvUGFyc2VyIGV4dGVuZHMgQmFzZVZpZGVvUGFyc2VyIHtcbiAgcGFyc2VQRVModHJhY2ssIHRleHRUcmFjaywgcGVzLCBlbmRPZlNlZ21lbnQpIHtcbiAgICBjb25zdCB1bml0cyA9IHRoaXMucGFyc2VOQUx1KHRyYWNrLCBwZXMuZGF0YSwgZW5kT2ZTZWdtZW50KTtcbiAgICBsZXQgVmlkZW9TYW1wbGUgPSB0aGlzLlZpZGVvU2FtcGxlO1xuICAgIGxldCBwdXNoO1xuICAgIGxldCBzcHNmb3VuZCA9IGZhbHNlO1xuICAgIC8vIGZyZWUgcGVzLmRhdGEgdG8gc2F2ZSB1cCBzb21lIG1lbW9yeVxuICAgIHBlcy5kYXRhID0gbnVsbDtcblxuICAgIC8vIGlmIG5ldyBOQUwgdW5pdHMgZm91bmQgYW5kIGxhc3Qgc2FtcGxlIHN0aWxsIHRoZXJlLCBsZXQncyBwdXNoIC4uLlxuICAgIC8vIHRoaXMgaGVscHMgcGFyc2luZyBzdHJlYW1zIHdpdGggbWlzc2luZyBBVUQgKG9ubHkgZG8gdGhpcyBpZiBBVUQgbmV2ZXIgZm91bmQpXG4gICAgaWYgKFZpZGVvU2FtcGxlICYmIHVuaXRzLmxlbmd0aCAmJiAhdHJhY2suYXVkRm91bmQpIHtcbiAgICAgIHRoaXMucHVzaEFjY2Vzc1VuaXQoVmlkZW9TYW1wbGUsIHRyYWNrKTtcbiAgICAgIFZpZGVvU2FtcGxlID0gdGhpcy5WaWRlb1NhbXBsZSA9IHRoaXMuY3JlYXRlVmlkZW9TYW1wbGUoZmFsc2UsIHBlcy5wdHMsIHBlcy5kdHMpO1xuICAgIH1cbiAgICB1bml0cy5mb3JFYWNoKHVuaXQgPT4ge1xuICAgICAgdmFyIF9WaWRlb1NhbXBsZTIsIF9WaWRlb1NhbXBsZTM7XG4gICAgICBzd2l0Y2ggKHVuaXQudHlwZSkge1xuICAgICAgICAvLyBORFJcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGxldCBpc2tleSA9IGZhbHNlO1xuICAgICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gdW5pdC5kYXRhO1xuICAgICAgICAgICAgLy8gb25seSBjaGVjayBzbGljZSB0eXBlIHRvIGRldGVjdCBLRiBpbiBjYXNlIFNQUyBmb3VuZCBpbiBzYW1lIHBhY2tldCAoYW55IGtleWZyYW1lIGlzIHByZWNlZGVkIGJ5IFNQUyAuLi4pXG4gICAgICAgICAgICBpZiAoc3BzZm91bmQgJiYgZGF0YS5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgICAgIC8vIHJldHJpZXZlIHNsaWNlIHR5cGUgYnkgcGFyc2luZyBiZWdpbm5pbmcgb2YgTkFMIHVuaXQgKGZvbGxvdyBIMjY0IHNwZWMsIHNsaWNlX2hlYWRlciBkZWZpbml0aW9uKSB0byBkZXRlY3Qga2V5ZnJhbWUgZW1iZWRkZWQgaW4gTkRSXG4gICAgICAgICAgICAgIGNvbnN0IHNsaWNlVHlwZSA9IHRoaXMucmVhZFNsaWNlVHlwZShkYXRhKTtcbiAgICAgICAgICAgICAgLy8gMiA6IEkgc2xpY2UsIDQgOiBTSSBzbGljZSwgNyA6IEkgc2xpY2UsIDk6IFNJIHNsaWNlXG4gICAgICAgICAgICAgIC8vIFNJIHNsaWNlIDogQSBzbGljZSB0aGF0IGlzIGNvZGVkIHVzaW5nIGludHJhIHByZWRpY3Rpb24gb25seSBhbmQgdXNpbmcgcXVhbnRpc2F0aW9uIG9mIHRoZSBwcmVkaWN0aW9uIHNhbXBsZXMuXG4gICAgICAgICAgICAgIC8vIEFuIFNJIHNsaWNlIGNhbiBiZSBjb2RlZCBzdWNoIHRoYXQgaXRzIGRlY29kZWQgc2FtcGxlcyBjYW4gYmUgY29uc3RydWN0ZWQgaWRlbnRpY2FsbHkgdG8gYW4gU1Agc2xpY2UuXG4gICAgICAgICAgICAgIC8vIEkgc2xpY2U6IEEgc2xpY2UgdGhhdCBpcyBub3QgYW4gU0kgc2xpY2UgdGhhdCBpcyBkZWNvZGVkIHVzaW5nIGludHJhIHByZWRpY3Rpb24gb25seS5cbiAgICAgICAgICAgICAgLy8gaWYgKHNsaWNlVHlwZSA9PT0gMiB8fCBzbGljZVR5cGUgPT09IDcpIHtcbiAgICAgICAgICAgICAgaWYgKHNsaWNlVHlwZSA9PT0gMiB8fCBzbGljZVR5cGUgPT09IDQgfHwgc2xpY2VUeXBlID09PSA3IHx8IHNsaWNlVHlwZSA9PT0gOSkge1xuICAgICAgICAgICAgICAgIGlza2V5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlza2V5KSB7XG4gICAgICAgICAgICAgIHZhciBfVmlkZW9TYW1wbGU7XG4gICAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgbm9uLWtleWZyYW1lIGRhdGEgYWxyZWFkeSwgdGhhdCBjYW5ub3QgYmVsb25nIHRvIHRoZSBzYW1lIGZyYW1lIGFzIGEga2V5ZnJhbWUsIHNvIGZvcmNlIGEgcHVzaFxuICAgICAgICAgICAgICBpZiAoKF9WaWRlb1NhbXBsZSA9IFZpZGVvU2FtcGxlKSAhPSBudWxsICYmIF9WaWRlb1NhbXBsZS5mcmFtZSAmJiAhVmlkZW9TYW1wbGUua2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoQWNjZXNzVW5pdChWaWRlb1NhbXBsZSwgdHJhY2spO1xuICAgICAgICAgICAgICAgIFZpZGVvU2FtcGxlID0gdGhpcy5WaWRlb1NhbXBsZSA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghVmlkZW9TYW1wbGUpIHtcbiAgICAgICAgICAgICAgVmlkZW9TYW1wbGUgPSB0aGlzLlZpZGVvU2FtcGxlID0gdGhpcy5jcmVhdGVWaWRlb1NhbXBsZSh0cnVlLCBwZXMucHRzLCBwZXMuZHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFZpZGVvU2FtcGxlLmZyYW1lID0gdHJ1ZTtcbiAgICAgICAgICAgIFZpZGVvU2FtcGxlLmtleSA9IGlza2V5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBJRFJcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICAvLyBoYW5kbGUgUEVTIG5vdCBzdGFydGluZyB3aXRoIEFVRFxuICAgICAgICAgIC8vIGlmIHdlIGhhdmUgZnJhbWUgZGF0YSBhbHJlYWR5LCB0aGF0IGNhbm5vdCBiZWxvbmcgdG8gdGhlIHNhbWUgZnJhbWUsIHNvIGZvcmNlIGEgcHVzaFxuICAgICAgICAgIGlmICgoX1ZpZGVvU2FtcGxlMiA9IFZpZGVvU2FtcGxlKSAhPSBudWxsICYmIF9WaWRlb1NhbXBsZTIuZnJhbWUgJiYgIVZpZGVvU2FtcGxlLmtleSkge1xuICAgICAgICAgICAgdGhpcy5wdXNoQWNjZXNzVW5pdChWaWRlb1NhbXBsZSwgdHJhY2spO1xuICAgICAgICAgICAgVmlkZW9TYW1wbGUgPSB0aGlzLlZpZGVvU2FtcGxlID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFWaWRlb1NhbXBsZSkge1xuICAgICAgICAgICAgVmlkZW9TYW1wbGUgPSB0aGlzLlZpZGVvU2FtcGxlID0gdGhpcy5jcmVhdGVWaWRlb1NhbXBsZSh0cnVlLCBwZXMucHRzLCBwZXMuZHRzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgVmlkZW9TYW1wbGUua2V5ID0gdHJ1ZTtcbiAgICAgICAgICBWaWRlb1NhbXBsZS5mcmFtZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFNFSVxuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgICBwYXJzZVNFSU1lc3NhZ2VGcm9tTkFMdSh1bml0LmRhdGEsIDEsIHBlcy5wdHMsIHRleHRUcmFjay5zYW1wbGVzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gU1BTXG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF90cmFjayRwaXhlbFJhdGlvLCBfdHJhY2skcGl4ZWxSYXRpbzI7XG4gICAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIHNwc2ZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IHNwcyA9IHVuaXQuZGF0YTtcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMucmVhZFNQUyhzcHMpO1xuICAgICAgICAgICAgaWYgKCF0cmFjay5zcHMgfHwgdHJhY2sud2lkdGggIT09IGNvbmZpZy53aWR0aCB8fCB0cmFjay5oZWlnaHQgIT09IGNvbmZpZy5oZWlnaHQgfHwgKChfdHJhY2skcGl4ZWxSYXRpbyA9IHRyYWNrLnBpeGVsUmF0aW8pID09IG51bGwgPyB2b2lkIDAgOiBfdHJhY2skcGl4ZWxSYXRpb1swXSkgIT09IGNvbmZpZy5waXhlbFJhdGlvWzBdIHx8ICgoX3RyYWNrJHBpeGVsUmF0aW8yID0gdHJhY2sucGl4ZWxSYXRpbykgPT0gbnVsbCA/IHZvaWQgMCA6IF90cmFjayRwaXhlbFJhdGlvMlsxXSkgIT09IGNvbmZpZy5waXhlbFJhdGlvWzFdKSB7XG4gICAgICAgICAgICAgIHRyYWNrLndpZHRoID0gY29uZmlnLndpZHRoO1xuICAgICAgICAgICAgICB0cmFjay5oZWlnaHQgPSBjb25maWcuaGVpZ2h0O1xuICAgICAgICAgICAgICB0cmFjay5waXhlbFJhdGlvID0gY29uZmlnLnBpeGVsUmF0aW87XG4gICAgICAgICAgICAgIHRyYWNrLnNwcyA9IFtzcHNdO1xuICAgICAgICAgICAgICBjb25zdCBjb2RlY2FycmF5ID0gc3BzLnN1YmFycmF5KDEsIDQpO1xuICAgICAgICAgICAgICBsZXQgY29kZWNzdHJpbmcgPSAnYXZjMS4nO1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBoID0gY29kZWNhcnJheVtpXS50b1N0cmluZygxNik7XG4gICAgICAgICAgICAgICAgaWYgKGgubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgICAgaCA9ICcwJyArIGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvZGVjc3RyaW5nICs9IGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdHJhY2suY29kZWMgPSBjb2RlY3N0cmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgLy8gUFBTXG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICB0cmFjay5wcHMgPSBbdW5pdC5kYXRhXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gQVVEXG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICB0cmFjay5hdWRGb3VuZCA9IHRydWU7XG4gICAgICAgICAgaWYgKChfVmlkZW9TYW1wbGUzID0gVmlkZW9TYW1wbGUpICE9IG51bGwgJiYgX1ZpZGVvU2FtcGxlMy5mcmFtZSkge1xuICAgICAgICAgICAgdGhpcy5wdXNoQWNjZXNzVW5pdChWaWRlb1NhbXBsZSwgdHJhY2spO1xuICAgICAgICAgICAgVmlkZW9TYW1wbGUgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIVZpZGVvU2FtcGxlKSB7XG4gICAgICAgICAgICBWaWRlb1NhbXBsZSA9IHRoaXMuVmlkZW9TYW1wbGUgPSB0aGlzLmNyZWF0ZVZpZGVvU2FtcGxlKGZhbHNlLCBwZXMucHRzLCBwZXMuZHRzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIEZpbGxlciBEYXRhXG4gICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKFZpZGVvU2FtcGxlICYmIHB1c2gpIHtcbiAgICAgICAgY29uc3QgdW5pdHMgPSBWaWRlb1NhbXBsZS51bml0cztcbiAgICAgICAgdW5pdHMucHVzaCh1bml0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBpZiBsYXN0IFBFUyBwYWNrZXQsIHB1c2ggc2FtcGxlc1xuICAgIGlmIChlbmRPZlNlZ21lbnQgJiYgVmlkZW9TYW1wbGUpIHtcbiAgICAgIHRoaXMucHVzaEFjY2Vzc1VuaXQoVmlkZW9TYW1wbGUsIHRyYWNrKTtcbiAgICAgIHRoaXMuVmlkZW9TYW1wbGUgPSBudWxsO1xuICAgIH1cbiAgfVxuICBnZXROQUx1VHlwZShkYXRhLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gZGF0YVtvZmZzZXRdICYgMHgxZjtcbiAgfVxuICByZWFkU2xpY2VUeXBlKGRhdGEpIHtcbiAgICBjb25zdCBlZyA9IG5ldyBFeHBHb2xvbWIoZGF0YSk7XG4gICAgLy8gc2tpcCBOQUx1IHR5cGVcbiAgICBlZy5yZWFkVUJ5dGUoKTtcbiAgICAvLyBkaXNjYXJkIGZpcnN0X21iX2luX3NsaWNlXG4gICAgZWcucmVhZFVFRygpO1xuICAgIC8vIHJldHVybiBzbGljZV90eXBlXG4gICAgcmV0dXJuIGVnLnJlYWRVRUcoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgc2NhbGluZyBsaXN0IGlzIG9wdGlvbmFsbHkgdHJhbnNtaXR0ZWQgYXMgcGFydCBvZiBhIHNlcXVlbmNlIHBhcmFtZXRlclxuICAgKiBzZXQgYW5kIGlzIG5vdCByZWxldmFudCB0byB0cmFuc211eGluZy5cbiAgICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgZW50cmllcyBpbiB0aGlzIHNjYWxpbmcgbGlzdFxuICAgKiBAc2VlIFJlY29tbWVuZGF0aW9uIElUVS1UIEguMjY0LCBTZWN0aW9uIDcuMy4yLjEuMS4xXG4gICAqL1xuICBza2lwU2NhbGluZ0xpc3QoY291bnQsIHJlYWRlcikge1xuICAgIGxldCBsYXN0U2NhbGUgPSA4O1xuICAgIGxldCBuZXh0U2NhbGUgPSA4O1xuICAgIGxldCBkZWx0YVNjYWxlO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgY291bnQ7IGorKykge1xuICAgICAgaWYgKG5leHRTY2FsZSAhPT0gMCkge1xuICAgICAgICBkZWx0YVNjYWxlID0gcmVhZGVyLnJlYWRFRygpO1xuICAgICAgICBuZXh0U2NhbGUgPSAobGFzdFNjYWxlICsgZGVsdGFTY2FsZSArIDI1NikgJSAyNTY7XG4gICAgICB9XG4gICAgICBsYXN0U2NhbGUgPSBuZXh0U2NhbGUgPT09IDAgPyBsYXN0U2NhbGUgOiBuZXh0U2NhbGU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgYSBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0IGFuZCByZXR1cm4gc29tZSBpbnRlcmVzdGluZyB2aWRlb1xuICAgKiBwcm9wZXJ0aWVzLiBBIHNlcXVlbmNlIHBhcmFtZXRlciBzZXQgaXMgdGhlIEgyNjQgbWV0YWRhdGEgdGhhdFxuICAgKiBkZXNjcmliZXMgdGhlIHByb3BlcnRpZXMgb2YgdXBjb21pbmcgdmlkZW8gZnJhbWVzLlxuICAgKiBAcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBjb25maWd1cmF0aW9uIHBhcnNlZCBmcm9tIHRoZVxuICAgKiBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0LCBpbmNsdWRpbmcgdGhlIGRpbWVuc2lvbnMgb2YgdGhlXG4gICAqIGFzc29jaWF0ZWQgdmlkZW8gZnJhbWVzLlxuICAgKi9cbiAgcmVhZFNQUyhzcHMpIHtcbiAgICBjb25zdCBlZyA9IG5ldyBFeHBHb2xvbWIoc3BzKTtcbiAgICBsZXQgZnJhbWVDcm9wTGVmdE9mZnNldCA9IDA7XG4gICAgbGV0IGZyYW1lQ3JvcFJpZ2h0T2Zmc2V0ID0gMDtcbiAgICBsZXQgZnJhbWVDcm9wVG9wT2Zmc2V0ID0gMDtcbiAgICBsZXQgZnJhbWVDcm9wQm90dG9tT2Zmc2V0ID0gMDtcbiAgICBsZXQgbnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlO1xuICAgIGxldCBzY2FsaW5nTGlzdENvdW50O1xuICAgIGxldCBpO1xuICAgIGNvbnN0IHJlYWRVQnl0ZSA9IGVnLnJlYWRVQnl0ZS5iaW5kKGVnKTtcbiAgICBjb25zdCByZWFkQml0cyA9IGVnLnJlYWRCaXRzLmJpbmQoZWcpO1xuICAgIGNvbnN0IHJlYWRVRUcgPSBlZy5yZWFkVUVHLmJpbmQoZWcpO1xuICAgIGNvbnN0IHJlYWRCb29sZWFuID0gZWcucmVhZEJvb2xlYW4uYmluZChlZyk7XG4gICAgY29uc3Qgc2tpcEJpdHMgPSBlZy5za2lwQml0cy5iaW5kKGVnKTtcbiAgICBjb25zdCBza2lwRUcgPSBlZy5za2lwRUcuYmluZChlZyk7XG4gICAgY29uc3Qgc2tpcFVFRyA9IGVnLnNraXBVRUcuYmluZChlZyk7XG4gICAgY29uc3Qgc2tpcFNjYWxpbmdMaXN0ID0gdGhpcy5za2lwU2NhbGluZ0xpc3QuYmluZCh0aGlzKTtcbiAgICByZWFkVUJ5dGUoKTtcbiAgICBjb25zdCBwcm9maWxlSWRjID0gcmVhZFVCeXRlKCk7IC8vIHByb2ZpbGVfaWRjXG4gICAgcmVhZEJpdHMoNSk7IC8vIHByb2ZpbGVDb21wYXQgY29uc3RyYWludF9zZXRbMC00XV9mbGFnLCB1KDUpXG4gICAgc2tpcEJpdHMoMyk7IC8vIHJlc2VydmVkX3plcm9fM2JpdHMgdSgzKSxcbiAgICByZWFkVUJ5dGUoKTsgLy8gbGV2ZWxfaWRjIHUoOClcbiAgICBza2lwVUVHKCk7IC8vIHNlcV9wYXJhbWV0ZXJfc2V0X2lkXG4gICAgLy8gc29tZSBwcm9maWxlcyBoYXZlIG1vcmUgb3B0aW9uYWwgZGF0YSB3ZSBkb24ndCBuZWVkXG4gICAgaWYgKHByb2ZpbGVJZGMgPT09IDEwMCB8fCBwcm9maWxlSWRjID09PSAxMTAgfHwgcHJvZmlsZUlkYyA9PT0gMTIyIHx8IHByb2ZpbGVJZGMgPT09IDI0NCB8fCBwcm9maWxlSWRjID09PSA0NCB8fCBwcm9maWxlSWRjID09PSA4MyB8fCBwcm9maWxlSWRjID09PSA4NiB8fCBwcm9maWxlSWRjID09PSAxMTggfHwgcHJvZmlsZUlkYyA9PT0gMTI4KSB7XG4gICAgICBjb25zdCBjaHJvbWFGb3JtYXRJZGMgPSByZWFkVUVHKCk7XG4gICAgICBpZiAoY2hyb21hRm9ybWF0SWRjID09PSAzKSB7XG4gICAgICAgIHNraXBCaXRzKDEpO1xuICAgICAgfSAvLyBzZXBhcmF0ZV9jb2xvdXJfcGxhbmVfZmxhZ1xuXG4gICAgICBza2lwVUVHKCk7IC8vIGJpdF9kZXB0aF9sdW1hX21pbnVzOFxuICAgICAgc2tpcFVFRygpOyAvLyBiaXRfZGVwdGhfY2hyb21hX21pbnVzOFxuICAgICAgc2tpcEJpdHMoMSk7IC8vIHFwcHJpbWVfeV96ZXJvX3RyYW5zZm9ybV9ieXBhc3NfZmxhZ1xuICAgICAgaWYgKHJlYWRCb29sZWFuKCkpIHtcbiAgICAgICAgLy8gc2VxX3NjYWxpbmdfbWF0cml4X3ByZXNlbnRfZmxhZ1xuICAgICAgICBzY2FsaW5nTGlzdENvdW50ID0gY2hyb21hRm9ybWF0SWRjICE9PSAzID8gOCA6IDEyO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2NhbGluZ0xpc3RDb3VudDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHJlYWRCb29sZWFuKCkpIHtcbiAgICAgICAgICAgIC8vIHNlcV9zY2FsaW5nX2xpc3RfcHJlc2VudF9mbGFnWyBpIF1cbiAgICAgICAgICAgIGlmIChpIDwgNikge1xuICAgICAgICAgICAgICBza2lwU2NhbGluZ0xpc3QoMTYsIGVnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNraXBTY2FsaW5nTGlzdCg2NCwgZWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBza2lwVUVHKCk7IC8vIGxvZzJfbWF4X2ZyYW1lX251bV9taW51czRcbiAgICBjb25zdCBwaWNPcmRlckNudFR5cGUgPSByZWFkVUVHKCk7XG4gICAgaWYgKHBpY09yZGVyQ250VHlwZSA9PT0gMCkge1xuICAgICAgcmVhZFVFRygpOyAvLyBsb2cyX21heF9waWNfb3JkZXJfY250X2xzYl9taW51czRcbiAgICB9IGVsc2UgaWYgKHBpY09yZGVyQ250VHlwZSA9PT0gMSkge1xuICAgICAgc2tpcEJpdHMoMSk7IC8vIGRlbHRhX3BpY19vcmRlcl9hbHdheXNfemVyb19mbGFnXG4gICAgICBza2lwRUcoKTsgLy8gb2Zmc2V0X2Zvcl9ub25fcmVmX3BpY1xuICAgICAgc2tpcEVHKCk7IC8vIG9mZnNldF9mb3JfdG9wX3RvX2JvdHRvbV9maWVsZFxuICAgICAgbnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlID0gcmVhZFVFRygpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG51bVJlZkZyYW1lc0luUGljT3JkZXJDbnRDeWNsZTsgaSsrKSB7XG4gICAgICAgIHNraXBFRygpO1xuICAgICAgfSAvLyBvZmZzZXRfZm9yX3JlZl9mcmFtZVsgaSBdXG4gICAgfVxuICAgIHNraXBVRUcoKTsgLy8gbWF4X251bV9yZWZfZnJhbWVzXG4gICAgc2tpcEJpdHMoMSk7IC8vIGdhcHNfaW5fZnJhbWVfbnVtX3ZhbHVlX2FsbG93ZWRfZmxhZ1xuICAgIGNvbnN0IHBpY1dpZHRoSW5NYnNNaW51czEgPSByZWFkVUVHKCk7XG4gICAgY29uc3QgcGljSGVpZ2h0SW5NYXBVbml0c01pbnVzMSA9IHJlYWRVRUcoKTtcbiAgICBjb25zdCBmcmFtZU1ic09ubHlGbGFnID0gcmVhZEJpdHMoMSk7XG4gICAgaWYgKGZyYW1lTWJzT25seUZsYWcgPT09IDApIHtcbiAgICAgIHNraXBCaXRzKDEpO1xuICAgIH0gLy8gbWJfYWRhcHRpdmVfZnJhbWVfZmllbGRfZmxhZ1xuXG4gICAgc2tpcEJpdHMoMSk7IC8vIGRpcmVjdF84eDhfaW5mZXJlbmNlX2ZsYWdcbiAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgLy8gZnJhbWVfY3JvcHBpbmdfZmxhZ1xuICAgICAgZnJhbWVDcm9wTGVmdE9mZnNldCA9IHJlYWRVRUcoKTtcbiAgICAgIGZyYW1lQ3JvcFJpZ2h0T2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgICAgZnJhbWVDcm9wVG9wT2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgICAgZnJhbWVDcm9wQm90dG9tT2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgIH1cbiAgICBsZXQgcGl4ZWxSYXRpbyA9IFsxLCAxXTtcbiAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgLy8gdnVpX3BhcmFtZXRlcnNfcHJlc2VudF9mbGFnXG4gICAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgICAvLyBhc3BlY3RfcmF0aW9faW5mb19wcmVzZW50X2ZsYWdcbiAgICAgICAgY29uc3QgYXNwZWN0UmF0aW9JZGMgPSByZWFkVUJ5dGUoKTtcbiAgICAgICAgc3dpdGNoIChhc3BlY3RSYXRpb0lkYykge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMSwgMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzEyLCAxMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzEwLCAxMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzE2LCAxMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzQwLCAzM107XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzI0LCAxMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzIwLCAxMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzMyLCAxMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzgwLCAzM107XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxOCwgMTFdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMTUsIDExXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzY0LCAzM107XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxNjAsIDk5XTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzQsIDNdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMywgMl07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsyLCAxXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjU1OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gW3JlYWRVQnl0ZSgpIDw8IDggfCByZWFkVUJ5dGUoKSwgcmVhZFVCeXRlKCkgPDwgOCB8IHJlYWRVQnl0ZSgpXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBNYXRoLmNlaWwoKHBpY1dpZHRoSW5NYnNNaW51czEgKyAxKSAqIDE2IC0gZnJhbWVDcm9wTGVmdE9mZnNldCAqIDIgLSBmcmFtZUNyb3BSaWdodE9mZnNldCAqIDIpLFxuICAgICAgaGVpZ2h0OiAoMiAtIGZyYW1lTWJzT25seUZsYWcpICogKHBpY0hlaWdodEluTWFwVW5pdHNNaW51czEgKyAxKSAqIDE2IC0gKGZyYW1lTWJzT25seUZsYWcgPyAyIDogNCkgKiAoZnJhbWVDcm9wVG9wT2Zmc2V0ICsgZnJhbWVDcm9wQm90dG9tT2Zmc2V0KSxcbiAgICAgIHBpeGVsUmF0aW86IHBpeGVsUmF0aW9cbiAgICB9O1xuICB9XG59XG5cbmNsYXNzIEhldmNWaWRlb1BhcnNlciBleHRlbmRzIEJhc2VWaWRlb1BhcnNlciB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICB0aGlzLmluaXRWUFMgPSBudWxsO1xuICB9XG4gIHBhcnNlUEVTKHRyYWNrLCB0ZXh0VHJhY2ssIHBlcywgZW5kT2ZTZWdtZW50KSB7XG4gICAgY29uc3QgdW5pdHMgPSB0aGlzLnBhcnNlTkFMdSh0cmFjaywgcGVzLmRhdGEsIGVuZE9mU2VnbWVudCk7XG4gICAgbGV0IFZpZGVvU2FtcGxlID0gdGhpcy5WaWRlb1NhbXBsZTtcbiAgICBsZXQgcHVzaDtcbiAgICBsZXQgc3BzZm91bmQgPSBmYWxzZTtcbiAgICAvLyBmcmVlIHBlcy5kYXRhIHRvIHNhdmUgdXAgc29tZSBtZW1vcnlcbiAgICBwZXMuZGF0YSA9IG51bGw7XG5cbiAgICAvLyBpZiBuZXcgTkFMIHVuaXRzIGZvdW5kIGFuZCBsYXN0IHNhbXBsZSBzdGlsbCB0aGVyZSwgbGV0J3MgcHVzaCAuLi5cbiAgICAvLyB0aGlzIGhlbHBzIHBhcnNpbmcgc3RyZWFtcyB3aXRoIG1pc3NpbmcgQVVEIChvbmx5IGRvIHRoaXMgaWYgQVVEIG5ldmVyIGZvdW5kKVxuICAgIGlmIChWaWRlb1NhbXBsZSAmJiB1bml0cy5sZW5ndGggJiYgIXRyYWNrLmF1ZEZvdW5kKSB7XG4gICAgICB0aGlzLnB1c2hBY2Nlc3NVbml0KFZpZGVvU2FtcGxlLCB0cmFjayk7XG4gICAgICBWaWRlb1NhbXBsZSA9IHRoaXMuVmlkZW9TYW1wbGUgPSB0aGlzLmNyZWF0ZVZpZGVvU2FtcGxlKGZhbHNlLCBwZXMucHRzLCBwZXMuZHRzKTtcbiAgICB9XG4gICAgdW5pdHMuZm9yRWFjaCh1bml0ID0+IHtcbiAgICAgIHZhciBfVmlkZW9TYW1wbGUyLCBfVmlkZW9TYW1wbGUzO1xuICAgICAgc3dpdGNoICh1bml0LnR5cGUpIHtcbiAgICAgICAgLy8gTk9OLUlEUiwgTk9OIFJBTkRPTSBBQ0NFU1MgU0xJQ0VcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICBjYXNlIDQ6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICBjYXNlIDc6XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIGlmICghVmlkZW9TYW1wbGUpIHtcbiAgICAgICAgICAgIFZpZGVvU2FtcGxlID0gdGhpcy5WaWRlb1NhbXBsZSA9IHRoaXMuY3JlYXRlVmlkZW9TYW1wbGUoZmFsc2UsIHBlcy5wdHMsIHBlcy5kdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBWaWRlb1NhbXBsZS5mcmFtZSA9IHRydWU7XG4gICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gQ1JBLCBCTEEgKHJhbmRvbSBhY2Nlc3MgcGljdHVyZSlcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgY2FzZSAxODpcbiAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoc3BzZm91bmQpIHtcbiAgICAgICAgICAgIHZhciBfVmlkZW9TYW1wbGU7XG4gICAgICAgICAgICAvLyBoYW5kbGUgUEVTIG5vdCBzdGFydGluZyB3aXRoIEFVRFxuICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBmcmFtZSBkYXRhIGFscmVhZHksIHRoYXQgY2Fubm90IGJlbG9uZyB0byB0aGUgc2FtZSBmcmFtZSwgc28gZm9yY2UgYSBwdXNoXG4gICAgICAgICAgICBpZiAoKF9WaWRlb1NhbXBsZSA9IFZpZGVvU2FtcGxlKSAhPSBudWxsICYmIF9WaWRlb1NhbXBsZS5mcmFtZSAmJiAhVmlkZW9TYW1wbGUua2V5KSB7XG4gICAgICAgICAgICAgIHRoaXMucHVzaEFjY2Vzc1VuaXQoVmlkZW9TYW1wbGUsIHRyYWNrKTtcbiAgICAgICAgICAgICAgVmlkZW9TYW1wbGUgPSB0aGlzLlZpZGVvU2FtcGxlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFWaWRlb1NhbXBsZSkge1xuICAgICAgICAgICAgVmlkZW9TYW1wbGUgPSB0aGlzLlZpZGVvU2FtcGxlID0gdGhpcy5jcmVhdGVWaWRlb1NhbXBsZSh0cnVlLCBwZXMucHRzLCBwZXMuZHRzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgVmlkZW9TYW1wbGUua2V5ID0gdHJ1ZTtcbiAgICAgICAgICBWaWRlb1NhbXBsZS5mcmFtZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gSURSXG4gICAgICAgIGNhc2UgMTk6XG4gICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgLy8gaGFuZGxlIFBFUyBub3Qgc3RhcnRpbmcgd2l0aCBBVURcbiAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGZyYW1lIGRhdGEgYWxyZWFkeSwgdGhhdCBjYW5ub3QgYmVsb25nIHRvIHRoZSBzYW1lIGZyYW1lLCBzbyBmb3JjZSBhIHB1c2hcbiAgICAgICAgICBpZiAoKF9WaWRlb1NhbXBsZTIgPSBWaWRlb1NhbXBsZSkgIT0gbnVsbCAmJiBfVmlkZW9TYW1wbGUyLmZyYW1lICYmICFWaWRlb1NhbXBsZS5rZXkpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaEFjY2Vzc1VuaXQoVmlkZW9TYW1wbGUsIHRyYWNrKTtcbiAgICAgICAgICAgIFZpZGVvU2FtcGxlID0gdGhpcy5WaWRlb1NhbXBsZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghVmlkZW9TYW1wbGUpIHtcbiAgICAgICAgICAgIFZpZGVvU2FtcGxlID0gdGhpcy5WaWRlb1NhbXBsZSA9IHRoaXMuY3JlYXRlVmlkZW9TYW1wbGUodHJ1ZSwgcGVzLnB0cywgcGVzLmR0cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFZpZGVvU2FtcGxlLmtleSA9IHRydWU7XG4gICAgICAgICAgVmlkZW9TYW1wbGUuZnJhbWUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vIFNFSVxuICAgICAgICBjYXNlIDM5OlxuICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgIHBhcnNlU0VJTWVzc2FnZUZyb21OQUx1KHVuaXQuZGF0YSwgMixcbiAgICAgICAgICAvLyBOQUx1IGhlYWRlciBzaXplXG4gICAgICAgICAgcGVzLnB0cywgdGV4dFRyYWNrLnNhbXBsZXMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vIFZQU1xuICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgIGlmICghdHJhY2sudnBzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRyYWNrLnBhcmFtcyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgdHJhY2sucGFyYW1zID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjay5wYXJhbXMgPSBfZXh0ZW5kcyh0cmFjay5wYXJhbXMsIHRoaXMucmVhZFZQUyh1bml0LmRhdGEpKTtcbiAgICAgICAgICAgIHRoaXMuaW5pdFZQUyA9IHVuaXQuZGF0YTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJhY2sudnBzID0gW3VuaXQuZGF0YV07XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gU1BTXG4gICAgICAgIGNhc2UgMzM6XG4gICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgc3BzZm91bmQgPSB0cnVlO1xuICAgICAgICAgIGlmICh0cmFjay52cHMgIT09IHVuZGVmaW5lZCAmJiB0cmFjay52cHNbMF0gIT09IHRoaXMuaW5pdFZQUyAmJiB0cmFjay5zcHMgIT09IHVuZGVmaW5lZCAmJiAhdGhpcy5tYXRjaFNQUyh0cmFjay5zcHNbMF0sIHVuaXQuZGF0YSkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdFZQUyA9IHRyYWNrLnZwc1swXTtcbiAgICAgICAgICAgIHRyYWNrLnNwcyA9IHRyYWNrLnBwcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0cmFjay5zcHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMucmVhZFNQUyh1bml0LmRhdGEpO1xuICAgICAgICAgICAgdHJhY2sud2lkdGggPSBjb25maWcud2lkdGg7XG4gICAgICAgICAgICB0cmFjay5oZWlnaHQgPSBjb25maWcuaGVpZ2h0O1xuICAgICAgICAgICAgdHJhY2sucGl4ZWxSYXRpbyA9IGNvbmZpZy5waXhlbFJhdGlvO1xuICAgICAgICAgICAgdHJhY2suY29kZWMgPSBjb25maWcuY29kZWNTdHJpbmc7XG4gICAgICAgICAgICB0cmFjay5zcHMgPSBbXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdHJhY2sucGFyYW1zICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICB0cmFjay5wYXJhbXMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBjb25maWcucGFyYW1zKSB7XG4gICAgICAgICAgICAgIHRyYWNrLnBhcmFtc1twcm9wXSA9IGNvbmZpZy5wYXJhbXNbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucHVzaFBhcmFtZXRlclNldCh0cmFjay5zcHMsIHVuaXQuZGF0YSwgdHJhY2sudnBzKTtcbiAgICAgICAgICBpZiAoIVZpZGVvU2FtcGxlKSB7XG4gICAgICAgICAgICBWaWRlb1NhbXBsZSA9IHRoaXMuVmlkZW9TYW1wbGUgPSB0aGlzLmNyZWF0ZVZpZGVvU2FtcGxlKHRydWUsIHBlcy5wdHMsIHBlcy5kdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBWaWRlb1NhbXBsZS5rZXkgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vIFBQU1xuICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgIGlmICh0eXBlb2YgdHJhY2sucGFyYW1zID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKCF0cmFjay5wcHMpIHtcbiAgICAgICAgICAgICAgdHJhY2sucHBzID0gW107XG4gICAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMucmVhZFBQUyh1bml0LmRhdGEpO1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgdHJhY2sucGFyYW1zW3Byb3BdID0gY29uZmlnW3Byb3BdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnB1c2hQYXJhbWV0ZXJTZXQodHJhY2sucHBzLCB1bml0LmRhdGEsIHRyYWNrLnZwcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vIEFDQ0VTUyBVTklUIERFTElNSVRFUlxuICAgICAgICBjYXNlIDM1OlxuICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgIHRyYWNrLmF1ZEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoKF9WaWRlb1NhbXBsZTMgPSBWaWRlb1NhbXBsZSkgIT0gbnVsbCAmJiBfVmlkZW9TYW1wbGUzLmZyYW1lKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hBY2Nlc3NVbml0KFZpZGVvU2FtcGxlLCB0cmFjayk7XG4gICAgICAgICAgICBWaWRlb1NhbXBsZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghVmlkZW9TYW1wbGUpIHtcbiAgICAgICAgICAgIFZpZGVvU2FtcGxlID0gdGhpcy5WaWRlb1NhbXBsZSA9IHRoaXMuY3JlYXRlVmlkZW9TYW1wbGUoZmFsc2UsIHBlcy5wdHMsIHBlcy5kdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXNoID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoVmlkZW9TYW1wbGUgJiYgcHVzaCkge1xuICAgICAgICBjb25zdCB1bml0cyA9IFZpZGVvU2FtcGxlLnVuaXRzO1xuICAgICAgICB1bml0cy5wdXNoKHVuaXQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIGlmIGxhc3QgUEVTIHBhY2tldCwgcHVzaCBzYW1wbGVzXG4gICAgaWYgKGVuZE9mU2VnbWVudCAmJiBWaWRlb1NhbXBsZSkge1xuICAgICAgdGhpcy5wdXNoQWNjZXNzVW5pdChWaWRlb1NhbXBsZSwgdHJhY2spO1xuICAgICAgdGhpcy5WaWRlb1NhbXBsZSA9IG51bGw7XG4gICAgfVxuICB9XG4gIHB1c2hQYXJhbWV0ZXJTZXQocGFyYW1ldGVyU2V0cywgZGF0YSwgdnBzKSB7XG4gICAgaWYgKHZwcyAmJiB2cHNbMF0gPT09IHRoaXMuaW5pdFZQUyB8fCAhdnBzICYmICFwYXJhbWV0ZXJTZXRzLmxlbmd0aCkge1xuICAgICAgcGFyYW1ldGVyU2V0cy5wdXNoKGRhdGEpO1xuICAgIH1cbiAgfVxuICBnZXROQUx1VHlwZShkYXRhLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gKGRhdGFbb2Zmc2V0XSAmIDB4N2UpID4+PiAxO1xuICB9XG4gIGVic3AycmJzcChhcnIpIHtcbiAgICBjb25zdCBkc3QgPSBuZXcgVWludDhBcnJheShhcnIuYnl0ZUxlbmd0aCk7XG4gICAgbGV0IGRzdElkeCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIuYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaSA+PSAyKSB7XG4gICAgICAgIC8vIFVuZXNjYXBlOiBTa2lwIDB4MDMgYWZ0ZXIgMDAgMDBcbiAgICAgICAgaWYgKGFycltpXSA9PT0gMHgwMyAmJiBhcnJbaSAtIDFdID09PSAweDAwICYmIGFycltpIC0gMl0gPT09IDB4MDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZHN0W2RzdElkeF0gPSBhcnJbaV07XG4gICAgICBkc3RJZHgrKztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRzdC5idWZmZXIsIDAsIGRzdElkeCk7XG4gIH1cbiAgcHVzaEFjY2Vzc1VuaXQoVmlkZW9TYW1wbGUsIHZpZGVvVHJhY2spIHtcbiAgICBzdXBlci5wdXNoQWNjZXNzVW5pdChWaWRlb1NhbXBsZSwgdmlkZW9UcmFjayk7XG4gICAgaWYgKHRoaXMuaW5pdFZQUykge1xuICAgICAgdGhpcy5pbml0VlBTID0gbnVsbDsgLy8gbnVsbCBpbml0VlBTIHRvIHByZXZlbnQgcG9zc2libGUgdHJhY2sncyBzcHMvcHBzIGdyb3d0aCB1bnRpbCBuZXh0IFZQU1xuICAgIH1cbiAgfVxuICByZWFkVlBTKHZwcykge1xuICAgIGNvbnN0IGVnID0gbmV3IEV4cEdvbG9tYih2cHMpO1xuICAgIC8vIHJlbW92ZSBoZWFkZXJcbiAgICBlZy5yZWFkVUJ5dGUoKTtcbiAgICBlZy5yZWFkVUJ5dGUoKTtcbiAgICBlZy5yZWFkQml0cyg0KTsgLy8gdmlkZW9fcGFyYW1ldGVyX3NldF9pZFxuICAgIGVnLnNraXBCaXRzKDIpO1xuICAgIGVnLnJlYWRCaXRzKDYpOyAvLyBtYXhfbGF5ZXJzX21pbnVzMVxuICAgIGNvbnN0IG1heF9zdWJfbGF5ZXJzX21pbnVzMSA9IGVnLnJlYWRCaXRzKDMpO1xuICAgIGNvbnN0IHRlbXBvcmFsX2lkX25lc3RpbmdfZmxhZyA9IGVnLnJlYWRCb29sZWFuKCk7XG4gICAgLy8gLi4udnVpIGZwcyBjYW4gYmUgaGVyZSwgYnV0IGVtcHR5IGZwcyB2YWx1ZSBpcyBub3QgY3JpdGljYWwgZm9yIG1ldGFkYXRhXG5cbiAgICByZXR1cm4ge1xuICAgICAgbnVtVGVtcG9yYWxMYXllcnM6IG1heF9zdWJfbGF5ZXJzX21pbnVzMSArIDEsXG4gICAgICB0ZW1wb3JhbElkTmVzdGVkOiB0ZW1wb3JhbF9pZF9uZXN0aW5nX2ZsYWdcbiAgICB9O1xuICB9XG4gIHJlYWRTUFMoc3BzKSB7XG4gICAgY29uc3QgZWcgPSBuZXcgRXhwR29sb21iKHRoaXMuZWJzcDJyYnNwKHNwcykpO1xuICAgIGVnLnJlYWRVQnl0ZSgpO1xuICAgIGVnLnJlYWRVQnl0ZSgpO1xuICAgIGVnLnJlYWRCaXRzKDQpOyAvL3ZpZGVvX3BhcmFtZXRlcl9zZXRfaWRcbiAgICBjb25zdCBtYXhfc3ViX2xheWVyc19taW51czEgPSBlZy5yZWFkQml0cygzKTtcbiAgICBlZy5yZWFkQm9vbGVhbigpOyAvLyB0ZW1wb3JhbF9pZF9uZXN0aW5nX2ZsYWdcblxuICAgIC8vIHByb2ZpbGVfdGllcl9sZXZlbFxuICAgIGNvbnN0IGdlbmVyYWxfcHJvZmlsZV9zcGFjZSA9IGVnLnJlYWRCaXRzKDIpO1xuICAgIGNvbnN0IGdlbmVyYWxfdGllcl9mbGFnID0gZWcucmVhZEJvb2xlYW4oKTtcbiAgICBjb25zdCBnZW5lcmFsX3Byb2ZpbGVfaWRjID0gZWcucmVhZEJpdHMoNSk7XG4gICAgY29uc3QgZ2VuZXJhbF9wcm9maWxlX2NvbXBhdGliaWxpdHlfZmxhZ3NfMSA9IGVnLnJlYWRVQnl0ZSgpO1xuICAgIGNvbnN0IGdlbmVyYWxfcHJvZmlsZV9jb21wYXRpYmlsaXR5X2ZsYWdzXzIgPSBlZy5yZWFkVUJ5dGUoKTtcbiAgICBjb25zdCBnZW5lcmFsX3Byb2ZpbGVfY29tcGF0aWJpbGl0eV9mbGFnc18zID0gZWcucmVhZFVCeXRlKCk7XG4gICAgY29uc3QgZ2VuZXJhbF9wcm9maWxlX2NvbXBhdGliaWxpdHlfZmxhZ3NfNCA9IGVnLnJlYWRVQnl0ZSgpO1xuICAgIGNvbnN0IGdlbmVyYWxfY29uc3RyYWludF9pbmRpY2F0b3JfZmxhZ3NfMSA9IGVnLnJlYWRVQnl0ZSgpO1xuICAgIGNvbnN0IGdlbmVyYWxfY29uc3RyYWludF9pbmRpY2F0b3JfZmxhZ3NfMiA9IGVnLnJlYWRVQnl0ZSgpO1xuICAgIGNvbnN0IGdlbmVyYWxfY29uc3RyYWludF9pbmRpY2F0b3JfZmxhZ3NfMyA9IGVnLnJlYWRVQnl0ZSgpO1xuICAgIGNvbnN0IGdlbmVyYWxfY29uc3RyYWludF9pbmRpY2F0b3JfZmxhZ3NfNCA9IGVnLnJlYWRVQnl0ZSgpO1xuICAgIGNvbnN0IGdlbmVyYWxfY29uc3RyYWludF9pbmRpY2F0b3JfZmxhZ3NfNSA9IGVnLnJlYWRVQnl0ZSgpO1xuICAgIGNvbnN0IGdlbmVyYWxfY29uc3RyYWludF9pbmRpY2F0b3JfZmxhZ3NfNiA9IGVnLnJlYWRVQnl0ZSgpO1xuICAgIGNvbnN0IGdlbmVyYWxfbGV2ZWxfaWRjID0gZWcucmVhZFVCeXRlKCk7XG4gICAgY29uc3Qgc3ViX2xheWVyX3Byb2ZpbGVfcHJlc2VudF9mbGFncyA9IFtdO1xuICAgIGNvbnN0IHN1Yl9sYXllcl9sZXZlbF9wcmVzZW50X2ZsYWdzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhfc3ViX2xheWVyc19taW51czE7IGkrKykge1xuICAgICAgc3ViX2xheWVyX3Byb2ZpbGVfcHJlc2VudF9mbGFncy5wdXNoKGVnLnJlYWRCb29sZWFuKCkpO1xuICAgICAgc3ViX2xheWVyX2xldmVsX3ByZXNlbnRfZmxhZ3MucHVzaChlZy5yZWFkQm9vbGVhbigpKTtcbiAgICB9XG4gICAgaWYgKG1heF9zdWJfbGF5ZXJzX21pbnVzMSA+IDApIHtcbiAgICAgIGZvciAobGV0IGkgPSBtYXhfc3ViX2xheWVyc19taW51czE7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgZWcucmVhZEJpdHMoMik7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4X3N1Yl9sYXllcnNfbWludXMxOyBpKyspIHtcbiAgICAgIGlmIChzdWJfbGF5ZXJfcHJvZmlsZV9wcmVzZW50X2ZsYWdzW2ldKSB7XG4gICAgICAgIGVnLnJlYWRVQnl0ZSgpOyAvLyBzdWJfbGF5ZXJfcHJvZmlsZV9zcGFjZSwgc3ViX2xheWVyX3RpZXJfZmxhZywgc3ViX2xheWVyX3Byb2ZpbGVfaWRjXG4gICAgICAgIGVnLnJlYWRVQnl0ZSgpO1xuICAgICAgICBlZy5yZWFkVUJ5dGUoKTtcbiAgICAgICAgZWcucmVhZFVCeXRlKCk7XG4gICAgICAgIGVnLnJlYWRVQnl0ZSgpOyAvLyBzdWJfbGF5ZXJfcHJvZmlsZV9jb21wYXRpYmlsaXR5X2ZsYWdcbiAgICAgICAgZWcucmVhZFVCeXRlKCk7XG4gICAgICAgIGVnLnJlYWRVQnl0ZSgpO1xuICAgICAgICBlZy5yZWFkVUJ5dGUoKTtcbiAgICAgICAgZWcucmVhZFVCeXRlKCk7XG4gICAgICAgIGVnLnJlYWRVQnl0ZSgpO1xuICAgICAgICBlZy5yZWFkVUJ5dGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdWJfbGF5ZXJfbGV2ZWxfcHJlc2VudF9mbGFnc1tpXSkge1xuICAgICAgICBlZy5yZWFkVUJ5dGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWcucmVhZFVFRygpOyAvLyBzZXFfcGFyYW1ldGVyX3NldF9pZFxuICAgIGNvbnN0IGNocm9tYV9mb3JtYXRfaWRjID0gZWcucmVhZFVFRygpO1xuICAgIGlmIChjaHJvbWFfZm9ybWF0X2lkYyA9PSAzKSB7XG4gICAgICBlZy5za2lwQml0cygxKTsgLy9zZXBhcmF0ZV9jb2xvdXJfcGxhbmVfZmxhZ1xuICAgIH1cbiAgICBjb25zdCBwaWNfd2lkdGhfaW5fbHVtYV9zYW1wbGVzID0gZWcucmVhZFVFRygpO1xuICAgIGNvbnN0IHBpY19oZWlnaHRfaW5fbHVtYV9zYW1wbGVzID0gZWcucmVhZFVFRygpO1xuICAgIGNvbnN0IGNvbmZvcm1hbmNlX3dpbmRvd19mbGFnID0gZWcucmVhZEJvb2xlYW4oKTtcbiAgICBsZXQgcGljX2xlZnRfb2Zmc2V0ID0gMCxcbiAgICAgIHBpY19yaWdodF9vZmZzZXQgPSAwLFxuICAgICAgcGljX3RvcF9vZmZzZXQgPSAwLFxuICAgICAgcGljX2JvdHRvbV9vZmZzZXQgPSAwO1xuICAgIGlmIChjb25mb3JtYW5jZV93aW5kb3dfZmxhZykge1xuICAgICAgcGljX2xlZnRfb2Zmc2V0ICs9IGVnLnJlYWRVRUcoKTtcbiAgICAgIHBpY19yaWdodF9vZmZzZXQgKz0gZWcucmVhZFVFRygpO1xuICAgICAgcGljX3RvcF9vZmZzZXQgKz0gZWcucmVhZFVFRygpO1xuICAgICAgcGljX2JvdHRvbV9vZmZzZXQgKz0gZWcucmVhZFVFRygpO1xuICAgIH1cbiAgICBjb25zdCBiaXRfZGVwdGhfbHVtYV9taW51czggPSBlZy5yZWFkVUVHKCk7XG4gICAgY29uc3QgYml0X2RlcHRoX2Nocm9tYV9taW51czggPSBlZy5yZWFkVUVHKCk7XG4gICAgY29uc3QgbG9nMl9tYXhfcGljX29yZGVyX2NudF9sc2JfbWludXM0ID0gZWcucmVhZFVFRygpO1xuICAgIGNvbnN0IHN1Yl9sYXllcl9vcmRlcmluZ19pbmZvX3ByZXNlbnRfZmxhZyA9IGVnLnJlYWRCb29sZWFuKCk7XG4gICAgZm9yIChsZXQgaSA9IHN1Yl9sYXllcl9vcmRlcmluZ19pbmZvX3ByZXNlbnRfZmxhZyA/IDAgOiBtYXhfc3ViX2xheWVyc19taW51czE7IGkgPD0gbWF4X3N1Yl9sYXllcnNfbWludXMxOyBpKyspIHtcbiAgICAgIGVnLnNraXBVRUcoKTsgLy8gbWF4X2RlY19waWNfYnVmZmVyaW5nX21pbnVzMVtpXVxuICAgICAgZWcuc2tpcFVFRygpOyAvLyBtYXhfbnVtX3Jlb3JkZXJfcGljc1tpXVxuICAgICAgZWcuc2tpcFVFRygpOyAvLyBtYXhfbGF0ZW5jeV9pbmNyZWFzZV9wbHVzMVtpXVxuICAgIH1cbiAgICBlZy5za2lwVUVHKCk7IC8vIGxvZzJfbWluX2x1bWFfY29kaW5nX2Jsb2NrX3NpemVfbWludXMzXG4gICAgZWcuc2tpcFVFRygpOyAvLyBsb2cyX2RpZmZfbWF4X21pbl9sdW1hX2NvZGluZ19ibG9ja19zaXplXG4gICAgZWcuc2tpcFVFRygpOyAvLyBsb2cyX21pbl90cmFuc2Zvcm1fYmxvY2tfc2l6ZV9taW51czJcbiAgICBlZy5za2lwVUVHKCk7IC8vIGxvZzJfZGlmZl9tYXhfbWluX3RyYW5zZm9ybV9ibG9ja19zaXplXG4gICAgZWcuc2tpcFVFRygpOyAvLyBtYXhfdHJhbnNmb3JtX2hpZXJhcmNoeV9kZXB0aF9pbnRlclxuICAgIGVnLnNraXBVRUcoKTsgLy8gbWF4X3RyYW5zZm9ybV9oaWVyYXJjaHlfZGVwdGhfaW50cmFcbiAgICBjb25zdCBzY2FsaW5nX2xpc3RfZW5hYmxlZF9mbGFnID0gZWcucmVhZEJvb2xlYW4oKTtcbiAgICBpZiAoc2NhbGluZ19saXN0X2VuYWJsZWRfZmxhZykge1xuICAgICAgY29uc3Qgc3BzX3NjYWxpbmdfbGlzdF9kYXRhX3ByZXNlbnRfZmxhZyA9IGVnLnJlYWRCb29sZWFuKCk7XG4gICAgICBpZiAoc3BzX3NjYWxpbmdfbGlzdF9kYXRhX3ByZXNlbnRfZmxhZykge1xuICAgICAgICBmb3IgKGxldCBzaXplSWQgPSAwOyBzaXplSWQgPCA0OyBzaXplSWQrKykge1xuICAgICAgICAgIGZvciAobGV0IG1hdHJpeElkID0gMDsgbWF0cml4SWQgPCAoc2l6ZUlkID09PSAzID8gMiA6IDYpOyBtYXRyaXhJZCsrKSB7XG4gICAgICAgICAgICBjb25zdCBzY2FsaW5nX2xpc3RfcHJlZF9tb2RlX2ZsYWcgPSBlZy5yZWFkQm9vbGVhbigpO1xuICAgICAgICAgICAgaWYgKCFzY2FsaW5nX2xpc3RfcHJlZF9tb2RlX2ZsYWcpIHtcbiAgICAgICAgICAgICAgZWcucmVhZFVFRygpOyAvLyBzY2FsaW5nX2xpc3RfcHJlZF9tYXRyaXhfaWRfZGVsdGFcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNvZWZOdW0gPSBNYXRoLm1pbig2NCwgMSA8PCA0ICsgKHNpemVJZCA8PCAxKSk7XG4gICAgICAgICAgICAgIGlmIChzaXplSWQgPiAxKSB7XG4gICAgICAgICAgICAgICAgZWcucmVhZEVHKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2VmTnVtOyBpKyspIHtcbiAgICAgICAgICAgICAgICBlZy5yZWFkRUcoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlZy5yZWFkQm9vbGVhbigpOyAvLyBhbXBfZW5hYmxlZF9mbGFnXG4gICAgZWcucmVhZEJvb2xlYW4oKTsgLy8gc2FtcGxlX2FkYXB0aXZlX29mZnNldF9lbmFibGVkX2ZsYWdcbiAgICBjb25zdCBwY21fZW5hYmxlZF9mbGFnID0gZWcucmVhZEJvb2xlYW4oKTtcbiAgICBpZiAocGNtX2VuYWJsZWRfZmxhZykge1xuICAgICAgZWcucmVhZFVCeXRlKCk7XG4gICAgICBlZy5za2lwVUVHKCk7XG4gICAgICBlZy5za2lwVUVHKCk7XG4gICAgICBlZy5yZWFkQm9vbGVhbigpO1xuICAgIH1cbiAgICBjb25zdCBudW1fc2hvcnRfdGVybV9yZWZfcGljX3NldHMgPSBlZy5yZWFkVUVHKCk7XG4gICAgbGV0IG51bV9kZWx0YV9wb2NzID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bV9zaG9ydF90ZXJtX3JlZl9waWNfc2V0czsgaSsrKSB7XG4gICAgICBsZXQgaW50ZXJfcmVmX3BpY19zZXRfcHJlZGljdGlvbl9mbGFnID0gZmFsc2U7XG4gICAgICBpZiAoaSAhPT0gMCkge1xuICAgICAgICBpbnRlcl9yZWZfcGljX3NldF9wcmVkaWN0aW9uX2ZsYWcgPSBlZy5yZWFkQm9vbGVhbigpO1xuICAgICAgfVxuICAgICAgaWYgKGludGVyX3JlZl9waWNfc2V0X3ByZWRpY3Rpb25fZmxhZykge1xuICAgICAgICBpZiAoaSA9PT0gbnVtX3Nob3J0X3Rlcm1fcmVmX3BpY19zZXRzKSB7XG4gICAgICAgICAgZWcucmVhZFVFRygpO1xuICAgICAgICB9XG4gICAgICAgIGVnLnJlYWRCb29sZWFuKCk7XG4gICAgICAgIGVnLnJlYWRVRUcoKTtcbiAgICAgICAgbGV0IG5leHRfbnVtX2RlbHRhX3BvY3MgPSAwO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8PSBudW1fZGVsdGFfcG9jczsgaisrKSB7XG4gICAgICAgICAgY29uc3QgdXNlZF9ieV9jdXJyX3BpY19mbGFnID0gZWcucmVhZEJvb2xlYW4oKTtcbiAgICAgICAgICBsZXQgdXNlX2RlbHRhX2ZsYWcgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoIXVzZWRfYnlfY3Vycl9waWNfZmxhZykge1xuICAgICAgICAgICAgdXNlX2RlbHRhX2ZsYWcgPSBlZy5yZWFkQm9vbGVhbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodXNlZF9ieV9jdXJyX3BpY19mbGFnIHx8IHVzZV9kZWx0YV9mbGFnKSB7XG4gICAgICAgICAgICBuZXh0X251bV9kZWx0YV9wb2NzKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG51bV9kZWx0YV9wb2NzID0gbmV4dF9udW1fZGVsdGFfcG9jcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG51bV9uZWdhdGl2ZV9waWNzID0gZWcucmVhZFVFRygpO1xuICAgICAgICBjb25zdCBudW1fcG9zaXRpdmVfcGljcyA9IGVnLnJlYWRVRUcoKTtcbiAgICAgICAgbnVtX2RlbHRhX3BvY3MgPSBudW1fbmVnYXRpdmVfcGljcyArIG51bV9wb3NpdGl2ZV9waWNzO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bV9uZWdhdGl2ZV9waWNzOyBqKyspIHtcbiAgICAgICAgICBlZy5yZWFkVUVHKCk7XG4gICAgICAgICAgZWcucmVhZEJvb2xlYW4oKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bV9wb3NpdGl2ZV9waWNzOyBqKyspIHtcbiAgICAgICAgICBlZy5yZWFkVUVHKCk7XG4gICAgICAgICAgZWcucmVhZEJvb2xlYW4oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsb25nX3Rlcm1fcmVmX3BpY3NfcHJlc2VudF9mbGFnID0gZWcucmVhZEJvb2xlYW4oKTtcbiAgICBpZiAobG9uZ190ZXJtX3JlZl9waWNzX3ByZXNlbnRfZmxhZykge1xuICAgICAgY29uc3QgbnVtX2xvbmdfdGVybV9yZWZfcGljc19zcHMgPSBlZy5yZWFkVUVHKCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bV9sb25nX3Rlcm1fcmVmX3BpY3Nfc3BzOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsb2cyX21heF9waWNfb3JkZXJfY250X2xzYl9taW51czQgKyA0OyBqKyspIHtcbiAgICAgICAgICBlZy5yZWFkQml0cygxKTtcbiAgICAgICAgfVxuICAgICAgICBlZy5yZWFkQml0cygxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IG1pbl9zcGF0aWFsX3NlZ21lbnRhdGlvbl9pZGMgPSAwO1xuICAgIGxldCBzYXJfd2lkdGggPSAxLFxuICAgICAgc2FyX2hlaWdodCA9IDE7XG4gICAgbGV0IGZwc19maXhlZCA9IHRydWUsXG4gICAgICBmcHNfZGVuID0gMSxcbiAgICAgIGZwc19udW0gPSAwO1xuICAgIGVnLnJlYWRCb29sZWFuKCk7IC8vIHNwc190ZW1wb3JhbF9tdnBfZW5hYmxlZF9mbGFnXG4gICAgZWcucmVhZEJvb2xlYW4oKTsgLy8gc3Ryb25nX2ludHJhX3Ntb290aGluZ19lbmFibGVkX2ZsYWdcbiAgICBsZXQgZGVmYXVsdF9kaXNwbGF5X3dpbmRvd19mbGFnID0gZmFsc2U7XG4gICAgY29uc3QgdnVpX3BhcmFtZXRlcnNfcHJlc2VudF9mbGFnID0gZWcucmVhZEJvb2xlYW4oKTtcbiAgICBpZiAodnVpX3BhcmFtZXRlcnNfcHJlc2VudF9mbGFnKSB7XG4gICAgICBjb25zdCBhc3BlY3RfcmF0aW9faW5mb19wcmVzZW50X2ZsYWcgPSBlZy5yZWFkQm9vbGVhbigpO1xuICAgICAgaWYgKGFzcGVjdF9yYXRpb19pbmZvX3ByZXNlbnRfZmxhZykge1xuICAgICAgICBjb25zdCBhc3BlY3RfcmF0aW9faWRjID0gZWcucmVhZFVCeXRlKCk7XG4gICAgICAgIGNvbnN0IHNhcl93aWR0aF90YWJsZSA9IFsxLCAxMiwgMTAsIDE2LCA0MCwgMjQsIDIwLCAzMiwgODAsIDE4LCAxNSwgNjQsIDE2MCwgNCwgMywgMl07XG4gICAgICAgIGNvbnN0IHNhcl9oZWlnaHRfdGFibGUgPSBbMSwgMTEsIDExLCAxMSwgMzMsIDExLCAxMSwgMTEsIDMzLCAxMSwgMTEsIDMzLCA5OSwgMywgMiwgMV07XG4gICAgICAgIGlmIChhc3BlY3RfcmF0aW9faWRjID4gMCAmJiBhc3BlY3RfcmF0aW9faWRjIDwgMTYpIHtcbiAgICAgICAgICBzYXJfd2lkdGggPSBzYXJfd2lkdGhfdGFibGVbYXNwZWN0X3JhdGlvX2lkYyAtIDFdO1xuICAgICAgICAgIHNhcl9oZWlnaHQgPSBzYXJfaGVpZ2h0X3RhYmxlW2FzcGVjdF9yYXRpb19pZGMgLSAxXTtcbiAgICAgICAgfSBlbHNlIGlmIChhc3BlY3RfcmF0aW9faWRjID09PSAyNTUpIHtcbiAgICAgICAgICBzYXJfd2lkdGggPSBlZy5yZWFkQml0cygxNik7XG4gICAgICAgICAgc2FyX2hlaWdodCA9IGVnLnJlYWRCaXRzKDE2KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgb3ZlcnNjYW5faW5mb19wcmVzZW50X2ZsYWcgPSBlZy5yZWFkQm9vbGVhbigpO1xuICAgICAgaWYgKG92ZXJzY2FuX2luZm9fcHJlc2VudF9mbGFnKSB7XG4gICAgICAgIGVnLnJlYWRCb29sZWFuKCk7XG4gICAgICB9XG4gICAgICBjb25zdCB2aWRlb19zaWduYWxfdHlwZV9wcmVzZW50X2ZsYWcgPSBlZy5yZWFkQm9vbGVhbigpO1xuICAgICAgaWYgKHZpZGVvX3NpZ25hbF90eXBlX3ByZXNlbnRfZmxhZykge1xuICAgICAgICBlZy5yZWFkQml0cygzKTtcbiAgICAgICAgZWcucmVhZEJvb2xlYW4oKTtcbiAgICAgICAgY29uc3QgY29sb3VyX2Rlc2NyaXB0aW9uX3ByZXNlbnRfZmxhZyA9IGVnLnJlYWRCb29sZWFuKCk7XG4gICAgICAgIGlmIChjb2xvdXJfZGVzY3JpcHRpb25fcHJlc2VudF9mbGFnKSB7XG4gICAgICAgICAgZWcucmVhZFVCeXRlKCk7XG4gICAgICAgICAgZWcucmVhZFVCeXRlKCk7XG4gICAgICAgICAgZWcucmVhZFVCeXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGNocm9tYV9sb2NfaW5mb19wcmVzZW50X2ZsYWcgPSBlZy5yZWFkQm9vbGVhbigpO1xuICAgICAgaWYgKGNocm9tYV9sb2NfaW5mb19wcmVzZW50X2ZsYWcpIHtcbiAgICAgICAgZWcucmVhZFVFRygpO1xuICAgICAgICBlZy5yZWFkVUVHKCk7XG4gICAgICB9XG4gICAgICBlZy5yZWFkQm9vbGVhbigpOyAvLyBuZXV0cmFsX2Nocm9tYV9pbmRpY2F0aW9uX2ZsYWdcbiAgICAgIGVnLnJlYWRCb29sZWFuKCk7IC8vIGZpZWxkX3NlcV9mbGFnXG4gICAgICBlZy5yZWFkQm9vbGVhbigpOyAvLyBmcmFtZV9maWVsZF9pbmZvX3ByZXNlbnRfZmxhZ1xuICAgICAgZGVmYXVsdF9kaXNwbGF5X3dpbmRvd19mbGFnID0gZWcucmVhZEJvb2xlYW4oKTtcbiAgICAgIGlmIChkZWZhdWx0X2Rpc3BsYXlfd2luZG93X2ZsYWcpIHtcbiAgICAgICAgcGljX2xlZnRfb2Zmc2V0ICs9IGVnLnJlYWRVRUcoKTtcbiAgICAgICAgcGljX3JpZ2h0X29mZnNldCArPSBlZy5yZWFkVUVHKCk7XG4gICAgICAgIHBpY190b3Bfb2Zmc2V0ICs9IGVnLnJlYWRVRUcoKTtcbiAgICAgICAgcGljX2JvdHRvbV9vZmZzZXQgKz0gZWcucmVhZFVFRygpO1xuICAgICAgfVxuICAgICAgY29uc3QgdnVpX3RpbWluZ19pbmZvX3ByZXNlbnRfZmxhZyA9IGVnLnJlYWRCb29sZWFuKCk7XG4gICAgICBpZiAodnVpX3RpbWluZ19pbmZvX3ByZXNlbnRfZmxhZykge1xuICAgICAgICBmcHNfZGVuID0gZWcucmVhZEJpdHMoMzIpO1xuICAgICAgICBmcHNfbnVtID0gZWcucmVhZEJpdHMoMzIpO1xuICAgICAgICBjb25zdCB2dWlfcG9jX3Byb3BvcnRpb25hbF90b190aW1pbmdfZmxhZyA9IGVnLnJlYWRCb29sZWFuKCk7XG4gICAgICAgIGlmICh2dWlfcG9jX3Byb3BvcnRpb25hbF90b190aW1pbmdfZmxhZykge1xuICAgICAgICAgIGVnLnJlYWRVRUcoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2dWlfaHJkX3BhcmFtZXRlcnNfcHJlc2VudF9mbGFnID0gZWcucmVhZEJvb2xlYW4oKTtcbiAgICAgICAgaWYgKHZ1aV9ocmRfcGFyYW1ldGVyc19wcmVzZW50X2ZsYWcpIHtcbiAgICAgICAgICAvL2NvbnN0IGNvbW1vbkluZlByZXNlbnRGbGFnID0gdHJ1ZTtcbiAgICAgICAgICAvL2lmIChjb21tb25JbmZQcmVzZW50RmxhZykge1xuICAgICAgICAgIGNvbnN0IG5hbF9ocmRfcGFyYW1ldGVyc19wcmVzZW50X2ZsYWcgPSBlZy5yZWFkQm9vbGVhbigpO1xuICAgICAgICAgIGNvbnN0IHZjbF9ocmRfcGFyYW1ldGVyc19wcmVzZW50X2ZsYWcgPSBlZy5yZWFkQm9vbGVhbigpO1xuICAgICAgICAgIGxldCBzdWJfcGljX2hyZF9wYXJhbXNfcHJlc2VudF9mbGFnID0gZmFsc2U7XG4gICAgICAgICAgaWYgKG5hbF9ocmRfcGFyYW1ldGVyc19wcmVzZW50X2ZsYWcgfHwgdmNsX2hyZF9wYXJhbWV0ZXJzX3ByZXNlbnRfZmxhZykge1xuICAgICAgICAgICAgc3ViX3BpY19ocmRfcGFyYW1zX3ByZXNlbnRfZmxhZyA9IGVnLnJlYWRCb29sZWFuKCk7XG4gICAgICAgICAgICBpZiAoc3ViX3BpY19ocmRfcGFyYW1zX3ByZXNlbnRfZmxhZykge1xuICAgICAgICAgICAgICBlZy5yZWFkVUJ5dGUoKTtcbiAgICAgICAgICAgICAgZWcucmVhZEJpdHMoNSk7XG4gICAgICAgICAgICAgIGVnLnJlYWRCb29sZWFuKCk7XG4gICAgICAgICAgICAgIGVnLnJlYWRCaXRzKDUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWcucmVhZEJpdHMoNCk7IC8vIGJpdF9yYXRlX3NjYWxlXG4gICAgICAgICAgICBlZy5yZWFkQml0cyg0KTsgLy8gY3BiX3NpemVfc2NhbGVcbiAgICAgICAgICAgIGlmIChzdWJfcGljX2hyZF9wYXJhbXNfcHJlc2VudF9mbGFnKSB7XG4gICAgICAgICAgICAgIGVnLnJlYWRCaXRzKDQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWcucmVhZEJpdHMoNSk7XG4gICAgICAgICAgICBlZy5yZWFkQml0cyg1KTtcbiAgICAgICAgICAgIGVnLnJlYWRCaXRzKDUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvL31cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBtYXhfc3ViX2xheWVyc19taW51czE7IGkrKykge1xuICAgICAgICAgICAgZnBzX2ZpeGVkID0gZWcucmVhZEJvb2xlYW4oKTsgLy8gZml4ZWRfcGljX3JhdGVfZ2VuZXJhbF9mbGFnXG4gICAgICAgICAgICBjb25zdCBmaXhlZF9waWNfcmF0ZV93aXRoaW5fY3ZzX2ZsYWcgPSBmcHNfZml4ZWQgfHwgZWcucmVhZEJvb2xlYW4oKTtcbiAgICAgICAgICAgIGxldCBsb3dfZGVsYXlfaHJkX2ZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChmaXhlZF9waWNfcmF0ZV93aXRoaW5fY3ZzX2ZsYWcpIHtcbiAgICAgICAgICAgICAgZWcucmVhZEVHKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsb3dfZGVsYXlfaHJkX2ZsYWcgPSBlZy5yZWFkQm9vbGVhbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY3BiX2NudCA9IGxvd19kZWxheV9ocmRfZmxhZyA/IDEgOiBlZy5yZWFkVUVHKCkgKyAxO1xuICAgICAgICAgICAgaWYgKG5hbF9ocmRfcGFyYW1ldGVyc19wcmVzZW50X2ZsYWcpIHtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjcGJfY250OyBqKyspIHtcbiAgICAgICAgICAgICAgICBlZy5yZWFkVUVHKCk7XG4gICAgICAgICAgICAgICAgZWcucmVhZFVFRygpO1xuICAgICAgICAgICAgICAgIGlmIChzdWJfcGljX2hyZF9wYXJhbXNfcHJlc2VudF9mbGFnKSB7XG4gICAgICAgICAgICAgICAgICBlZy5yZWFkVUVHKCk7XG4gICAgICAgICAgICAgICAgICBlZy5yZWFkVUVHKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVnLnNraXBCaXRzKDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmNsX2hyZF9wYXJhbWV0ZXJzX3ByZXNlbnRfZmxhZykge1xuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNwYl9jbnQ7IGorKykge1xuICAgICAgICAgICAgICAgIGVnLnJlYWRVRUcoKTtcbiAgICAgICAgICAgICAgICBlZy5yZWFkVUVHKCk7XG4gICAgICAgICAgICAgICAgaWYgKHN1Yl9waWNfaHJkX3BhcmFtc19wcmVzZW50X2ZsYWcpIHtcbiAgICAgICAgICAgICAgICAgIGVnLnJlYWRVRUcoKTtcbiAgICAgICAgICAgICAgICAgIGVnLnJlYWRVRUcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWcuc2tpcEJpdHMoMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGJpdHN0cmVhbV9yZXN0cmljdGlvbl9mbGFnID0gZWcucmVhZEJvb2xlYW4oKTtcbiAgICAgIGlmIChiaXRzdHJlYW1fcmVzdHJpY3Rpb25fZmxhZykge1xuICAgICAgICBlZy5yZWFkQm9vbGVhbigpOyAvLyB0aWxlc19maXhlZF9zdHJ1Y3R1cmVfZmxhZ1xuICAgICAgICBlZy5yZWFkQm9vbGVhbigpOyAvLyBtb3Rpb25fdmVjdG9yc19vdmVyX3BpY19ib3VuZGFyaWVzX2ZsYWdcbiAgICAgICAgZWcucmVhZEJvb2xlYW4oKTsgLy8gcmVzdHJpY3RlZF9yZWZfcGljX2xpc3RzX2ZsYWdcbiAgICAgICAgbWluX3NwYXRpYWxfc2VnbWVudGF0aW9uX2lkYyA9IGVnLnJlYWRVRUcoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHdpZHRoID0gcGljX3dpZHRoX2luX2x1bWFfc2FtcGxlcyxcbiAgICAgIGhlaWdodCA9IHBpY19oZWlnaHRfaW5fbHVtYV9zYW1wbGVzO1xuICAgIGlmIChjb25mb3JtYW5jZV93aW5kb3dfZmxhZyB8fCBkZWZhdWx0X2Rpc3BsYXlfd2luZG93X2ZsYWcpIHtcbiAgICAgIGxldCBjaHJvbWFfc2NhbGVfdyA9IDEsXG4gICAgICAgIGNocm9tYV9zY2FsZV9oID0gMTtcbiAgICAgIGlmIChjaHJvbWFfZm9ybWF0X2lkYyA9PT0gMSkge1xuICAgICAgICAvLyBZVVYgNDIwXG4gICAgICAgIGNocm9tYV9zY2FsZV93ID0gY2hyb21hX3NjYWxlX2ggPSAyO1xuICAgICAgfSBlbHNlIGlmIChjaHJvbWFfZm9ybWF0X2lkYyA9PSAyKSB7XG4gICAgICAgIC8vIFlVViA0MjJcbiAgICAgICAgY2hyb21hX3NjYWxlX3cgPSAyO1xuICAgICAgfVxuICAgICAgd2lkdGggPSBwaWNfd2lkdGhfaW5fbHVtYV9zYW1wbGVzIC0gY2hyb21hX3NjYWxlX3cgKiBwaWNfcmlnaHRfb2Zmc2V0IC0gY2hyb21hX3NjYWxlX3cgKiBwaWNfbGVmdF9vZmZzZXQ7XG4gICAgICBoZWlnaHQgPSBwaWNfaGVpZ2h0X2luX2x1bWFfc2FtcGxlcyAtIGNocm9tYV9zY2FsZV9oICogcGljX2JvdHRvbV9vZmZzZXQgLSBjaHJvbWFfc2NhbGVfaCAqIHBpY190b3Bfb2Zmc2V0O1xuICAgIH1cbiAgICBjb25zdCBwcm9maWxlX3NwYWNlX3N0cmluZyA9IGdlbmVyYWxfcHJvZmlsZV9zcGFjZSA/IFsnQScsICdCJywgJ0MnXVtnZW5lcmFsX3Byb2ZpbGVfc3BhY2VdIDogJyc7XG4gICAgY29uc3QgcHJvZmlsZV9jb21wYXRpYmlsaXR5X2J1ZiA9IGdlbmVyYWxfcHJvZmlsZV9jb21wYXRpYmlsaXR5X2ZsYWdzXzEgPDwgMjQgfCBnZW5lcmFsX3Byb2ZpbGVfY29tcGF0aWJpbGl0eV9mbGFnc18yIDw8IDE2IHwgZ2VuZXJhbF9wcm9maWxlX2NvbXBhdGliaWxpdHlfZmxhZ3NfMyA8PCA4IHwgZ2VuZXJhbF9wcm9maWxlX2NvbXBhdGliaWxpdHlfZmxhZ3NfNDtcbiAgICBsZXQgcHJvZmlsZV9jb21wYXRpYmlsaXR5X3JldiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgICBwcm9maWxlX2NvbXBhdGliaWxpdHlfcmV2ID0gKHByb2ZpbGVfY29tcGF0aWJpbGl0eV9yZXYgfCAocHJvZmlsZV9jb21wYXRpYmlsaXR5X2J1ZiA+PiBpICYgMSkgPDwgMzEgLSBpKSA+Pj4gMDsgLy8gcmV2ZXJzZSBiaXQgcG9zaXRpb24gKGFuZCBjYXN0IGFzIFVJbnQzMilcbiAgICB9XG4gICAgbGV0IHByb2ZpbGVfY29tcGF0aWJpbGl0eV9mbGFnc19zdHJpbmcgPSBwcm9maWxlX2NvbXBhdGliaWxpdHlfcmV2LnRvU3RyaW5nKDE2KTtcbiAgICBpZiAoZ2VuZXJhbF9wcm9maWxlX2lkYyA9PT0gMSAmJiBwcm9maWxlX2NvbXBhdGliaWxpdHlfZmxhZ3Nfc3RyaW5nID09PSAnMicpIHtcbiAgICAgIHByb2ZpbGVfY29tcGF0aWJpbGl0eV9mbGFnc19zdHJpbmcgPSAnNic7XG4gICAgfVxuICAgIGNvbnN0IHRpZXJfZmxhZ19zdHJpbmcgPSBnZW5lcmFsX3RpZXJfZmxhZyA/ICdIJyA6ICdMJztcbiAgICByZXR1cm4ge1xuICAgICAgY29kZWNTdHJpbmc6IGBodmMxLiR7cHJvZmlsZV9zcGFjZV9zdHJpbmd9JHtnZW5lcmFsX3Byb2ZpbGVfaWRjfS4ke3Byb2ZpbGVfY29tcGF0aWJpbGl0eV9mbGFnc19zdHJpbmd9LiR7dGllcl9mbGFnX3N0cmluZ30ke2dlbmVyYWxfbGV2ZWxfaWRjfS5CMGAsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgZ2VuZXJhbF90aWVyX2ZsYWcsXG4gICAgICAgIGdlbmVyYWxfcHJvZmlsZV9pZGMsXG4gICAgICAgIGdlbmVyYWxfcHJvZmlsZV9zcGFjZSxcbiAgICAgICAgZ2VuZXJhbF9wcm9maWxlX2NvbXBhdGliaWxpdHlfZmxhZ3M6IFtnZW5lcmFsX3Byb2ZpbGVfY29tcGF0aWJpbGl0eV9mbGFnc18xLCBnZW5lcmFsX3Byb2ZpbGVfY29tcGF0aWJpbGl0eV9mbGFnc18yLCBnZW5lcmFsX3Byb2ZpbGVfY29tcGF0aWJpbGl0eV9mbGFnc18zLCBnZW5lcmFsX3Byb2ZpbGVfY29tcGF0aWJpbGl0eV9mbGFnc180XSxcbiAgICAgICAgZ2VuZXJhbF9jb25zdHJhaW50X2luZGljYXRvcl9mbGFnczogW2dlbmVyYWxfY29uc3RyYWludF9pbmRpY2F0b3JfZmxhZ3NfMSwgZ2VuZXJhbF9jb25zdHJhaW50X2luZGljYXRvcl9mbGFnc18yLCBnZW5lcmFsX2NvbnN0cmFpbnRfaW5kaWNhdG9yX2ZsYWdzXzMsIGdlbmVyYWxfY29uc3RyYWludF9pbmRpY2F0b3JfZmxhZ3NfNCwgZ2VuZXJhbF9jb25zdHJhaW50X2luZGljYXRvcl9mbGFnc181LCBnZW5lcmFsX2NvbnN0cmFpbnRfaW5kaWNhdG9yX2ZsYWdzXzZdLFxuICAgICAgICBnZW5lcmFsX2xldmVsX2lkYyxcbiAgICAgICAgYml0X2RlcHRoOiBiaXRfZGVwdGhfbHVtYV9taW51czggKyA4LFxuICAgICAgICBiaXRfZGVwdGhfbHVtYV9taW51czgsXG4gICAgICAgIGJpdF9kZXB0aF9jaHJvbWFfbWludXM4LFxuICAgICAgICBtaW5fc3BhdGlhbF9zZWdtZW50YXRpb25faWRjLFxuICAgICAgICBjaHJvbWFfZm9ybWF0X2lkYzogY2hyb21hX2Zvcm1hdF9pZGMsXG4gICAgICAgIGZyYW1lX3JhdGU6IHtcbiAgICAgICAgICBmaXhlZDogZnBzX2ZpeGVkLFxuICAgICAgICAgIGZwczogZnBzX251bSAvIGZwc19kZW5cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgcGl4ZWxSYXRpbzogW3Nhcl93aWR0aCwgc2FyX2hlaWdodF1cbiAgICB9O1xuICB9XG4gIHJlYWRQUFMocHBzKSB7XG4gICAgY29uc3QgZWcgPSBuZXcgRXhwR29sb21iKHRoaXMuZWJzcDJyYnNwKHBwcykpO1xuICAgIGVnLnJlYWRVQnl0ZSgpO1xuICAgIGVnLnJlYWRVQnl0ZSgpO1xuICAgIGVnLnNraXBVRUcoKTsgLy8gcGljX3BhcmFtZXRlcl9zZXRfaWRcbiAgICBlZy5za2lwVUVHKCk7IC8vIHNlcV9wYXJhbWV0ZXJfc2V0X2lkXG4gICAgZWcuc2tpcEJpdHMoMik7IC8vIGRlcGVuZGVudF9zbGljZV9zZWdtZW50c19lbmFibGVkX2ZsYWcsIG91dHB1dF9mbGFnX3ByZXNlbnRfZmxhZ1xuICAgIGVnLnNraXBCaXRzKDMpOyAvLyBudW1fZXh0cmFfc2xpY2VfaGVhZGVyX2JpdHNcbiAgICBlZy5za2lwQml0cygyKTsgLy8gc2lnbl9kYXRhX2hpZGluZ19lbmFibGVkX2ZsYWcsIGNhYmFjX2luaXRfcHJlc2VudF9mbGFnXG4gICAgZWcuc2tpcFVFRygpO1xuICAgIGVnLnNraXBVRUcoKTtcbiAgICBlZy5za2lwRUcoKTsgLy8gaW5pdF9xcF9taW51czI2XG4gICAgZWcuc2tpcEJpdHMoMik7IC8vIGNvbnN0cmFpbmVkX2ludHJhX3ByZWRfZmxhZywgdHJhbnNmb3JtX3NraXBfZW5hYmxlZF9mbGFnXG4gICAgY29uc3QgY3VfcXBfZGVsdGFfZW5hYmxlZF9mbGFnID0gZWcucmVhZEJvb2xlYW4oKTtcbiAgICBpZiAoY3VfcXBfZGVsdGFfZW5hYmxlZF9mbGFnKSB7XG4gICAgICBlZy5za2lwVUVHKCk7XG4gICAgfVxuICAgIGVnLnNraXBFRygpOyAvLyBjYl9xcF9vZmZzZXRcbiAgICBlZy5za2lwRUcoKTsgLy8gY3JfcXBfb2Zmc2V0XG4gICAgZWcuc2tpcEJpdHMoNCk7IC8vIHBwc19zbGljZV9jaHJvbWFfcXBfb2Zmc2V0c19wcmVzZW50X2ZsYWcsIHdlaWdodGVkX3ByZWRfZmxhZywgd2VpZ2h0ZWRfYmlwcmVkX2ZsYWcsIHRyYW5zcXVhbnRfYnlwYXNzX2VuYWJsZWRfZmxhZ1xuICAgIGNvbnN0IHRpbGVzX2VuYWJsZWRfZmxhZyA9IGVnLnJlYWRCb29sZWFuKCk7XG4gICAgY29uc3QgZW50cm9weV9jb2Rpbmdfc3luY19lbmFibGVkX2ZsYWcgPSBlZy5yZWFkQm9vbGVhbigpO1xuICAgIGxldCBwYXJhbGxlbGlzbVR5cGUgPSAxOyAvLyBzbGljZS1iYXNlZCBwYXJhbGxlbCBkZWNvZGluZ1xuICAgIGlmIChlbnRyb3B5X2NvZGluZ19zeW5jX2VuYWJsZWRfZmxhZyAmJiB0aWxlc19lbmFibGVkX2ZsYWcpIHtcbiAgICAgIHBhcmFsbGVsaXNtVHlwZSA9IDA7IC8vIG1peGVkLXR5cGUgcGFyYWxsZWwgZGVjb2RpbmdcbiAgICB9IGVsc2UgaWYgKGVudHJvcHlfY29kaW5nX3N5bmNfZW5hYmxlZF9mbGFnKSB7XG4gICAgICBwYXJhbGxlbGlzbVR5cGUgPSAzOyAvLyB3YXZlZnJvbnQtYmFzZWQgcGFyYWxsZWwgZGVjb2RpbmdcbiAgICB9IGVsc2UgaWYgKHRpbGVzX2VuYWJsZWRfZmxhZykge1xuICAgICAgcGFyYWxsZWxpc21UeXBlID0gMjsgLy8gdGlsZS1iYXNlZCBwYXJhbGxlbCBkZWNvZGluZ1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcGFyYWxsZWxpc21UeXBlXG4gICAgfTtcbiAgfVxuICBtYXRjaFNQUyhzcHMxLCBzcHMyKSB7XG4gICAgLy8gY29tcGFyZSB3aXRob3V0IGhlYWRlcnMgYW5kIFZQUyByZWxhdGVkIHBhcmFtc1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIHNwczEpLnN1YnN0cigzKSA9PT0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBzcHMyKS5zdWJzdHIoMyk7XG4gIH1cbn1cblxuY29uc3QgUEFDS0VUX0xFTkdUSCA9IDE4ODtcbmNsYXNzIFRTRGVtdXhlciB7XG4gIGNvbnN0cnVjdG9yKG9ic2VydmVyLCBjb25maWcsIHR5cGVTdXBwb3J0ZWQsIGxvZ2dlcikge1xuICAgIHRoaXMubG9nZ2VyID0gdm9pZCAwO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy50eXBlU3VwcG9ydGVkID0gdm9pZCAwO1xuICAgIHRoaXMuc2FtcGxlQWVzID0gbnVsbDtcbiAgICB0aGlzLnBtdFBhcnNlZCA9IGZhbHNlO1xuICAgIHRoaXMuYXVkaW9Db2RlYyA9IHZvaWQgMDtcbiAgICB0aGlzLnZpZGVvQ29kZWMgPSB2b2lkIDA7XG4gICAgdGhpcy5fcG10SWQgPSAtMTtcbiAgICB0aGlzLl92aWRlb1RyYWNrID0gdm9pZCAwO1xuICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5faWQzVHJhY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5fdHh0VHJhY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5hYWNPdmVyRmxvdyA9IG51bGw7XG4gICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgICB0aGlzLnZpZGVvUGFyc2VyID0gdm9pZCAwO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB0eXBlU3VwcG9ydGVkO1xuICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgIHRoaXMudmlkZW9QYXJzZXIgPSBudWxsO1xuICB9XG4gIHN0YXRpYyBwcm9iZShkYXRhLCBsb2dnZXIpIHtcbiAgICBjb25zdCBzeW5jT2Zmc2V0ID0gVFNEZW11eGVyLnN5bmNPZmZzZXQoZGF0YSk7XG4gICAgaWYgKHN5bmNPZmZzZXQgPiAwKSB7XG4gICAgICBsb2dnZXIud2FybihgTVBFRzItVFMgZGV0ZWN0ZWQgYnV0IGZpcnN0IHN5bmMgd29yZCBmb3VuZCBAIG9mZnNldCAke3N5bmNPZmZzZXR9YCk7XG4gICAgfVxuICAgIHJldHVybiBzeW5jT2Zmc2V0ICE9PSAtMTtcbiAgfVxuICBzdGF0aWMgc3luY09mZnNldChkYXRhKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgbGV0IHNjYW53aW5kb3cgPSBNYXRoLm1pbihQQUNLRVRfTEVOR1RIICogNSwgbGVuZ3RoIC0gUEFDS0VUX0xFTkdUSCkgKyAxO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHNjYW53aW5kb3cpIHtcbiAgICAgIC8vIGEgVFMgaW5pdCBzZWdtZW50IHNob3VsZCBjb250YWluIGF0IGxlYXN0IDIgVFMgcGFja2V0czogUEFUIGFuZCBQTVQsIGVhY2ggc3RhcnRpbmcgd2l0aCAweDQ3XG4gICAgICBsZXQgZm91bmRQYXQgPSBmYWxzZTtcbiAgICAgIGxldCBwYWNrZXRTdGFydCA9IC0xO1xuICAgICAgbGV0IHRzUGFja2V0cyA9IDA7XG4gICAgICBmb3IgKGxldCBqID0gaTsgaiA8IGxlbmd0aDsgaiArPSBQQUNLRVRfTEVOR1RIKSB7XG4gICAgICAgIGlmIChkYXRhW2pdID09PSAweDQ3ICYmIChsZW5ndGggLSBqID09PSBQQUNLRVRfTEVOR1RIIHx8IGRhdGFbaiArIFBBQ0tFVF9MRU5HVEhdID09PSAweDQ3KSkge1xuICAgICAgICAgIHRzUGFja2V0cysrO1xuICAgICAgICAgIGlmIChwYWNrZXRTdGFydCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHBhY2tldFN0YXJ0ID0gajtcbiAgICAgICAgICAgIC8vIEZpcnN0IHN5bmMgd29yZCBmb3VuZCBhdCBvZmZzZXQsIGluY3JlYXNlIHNjYW4gbGVuZ3RoICgjNTI1MSlcbiAgICAgICAgICAgIGlmIChwYWNrZXRTdGFydCAhPT0gMCkge1xuICAgICAgICAgICAgICBzY2Fud2luZG93ID0gTWF0aC5taW4ocGFja2V0U3RhcnQgKyBQQUNLRVRfTEVOR1RIICogOTksIGRhdGEubGVuZ3RoIC0gUEFDS0VUX0xFTkdUSCkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWZvdW5kUGF0KSB7XG4gICAgICAgICAgICBmb3VuZFBhdCA9IHBhcnNlUElEKGRhdGEsIGopID09PSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBTeW5jIHdvcmQgZm91bmQgYXQgMCB3aXRoIDMgcGFja2V0cywgb3IgZm91bmQgYXQgb2Zmc2V0IGxlYXN0IDIgcGFja2V0cyB1cCB0byBzY2Fud2luZG93ICgjNTUwMSlcbiAgICAgICAgICBpZiAoZm91bmRQYXQgJiYgdHNQYWNrZXRzID4gMSAmJiAocGFja2V0U3RhcnQgPT09IDAgJiYgdHNQYWNrZXRzID4gMiB8fCBqICsgUEFDS0VUX0xFTkdUSCA+IHNjYW53aW5kb3cpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFja2V0U3RhcnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRzUGFja2V0cykge1xuICAgICAgICAgIC8vIEV4aXQgaWYgc3luYyB3b3JkIGZvdW5kLCBidXQgZG9lcyBub3QgY29udGFpbiBjb250aWd1b3VzIHBhY2tldHNcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB0cmFjayBtb2RlbCBpbnRlcm5hbCB0byBkZW11eGVyIHVzZWQgdG8gZHJpdmUgcmVtdXhpbmcgaW5wdXRcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVUcmFjayh0eXBlLCBkdXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICBjb250YWluZXI6IHR5cGUgPT09ICd2aWRlbycgfHwgdHlwZSA9PT0gJ2F1ZGlvJyA/ICd2aWRlby9tcDJ0JyA6IHVuZGVmaW5lZCxcbiAgICAgIHR5cGUsXG4gICAgICBpZDogUmVtdXhlclRyYWNrSWRDb25maWdbdHlwZV0sXG4gICAgICBwaWQ6IC0xLFxuICAgICAgaW5wdXRUaW1lU2NhbGU6IDkwMDAwLFxuICAgICAgc2VxdWVuY2VOdW1iZXI6IDAsXG4gICAgICBzYW1wbGVzOiBbXSxcbiAgICAgIGRyb3BwZWQ6IDAsXG4gICAgICBkdXJhdGlvbjogdHlwZSA9PT0gJ2F1ZGlvJyA/IGR1cmF0aW9uIDogdW5kZWZpbmVkXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBhIG5ldyBpbml0IHNlZ21lbnQgb24gdGhlIGRlbXV4ZXIvcmVtdXhlciBpbnRlcmZhY2UuIE5lZWRlZCBmb3IgZGlzY29udGludWl0aWVzL3RyYWNrLXN3aXRjaGVzIChvciBhdCBzdHJlYW0gc3RhcnQpXG4gICAqIFJlc2V0cyBhbGwgaW50ZXJuYWwgdHJhY2sgaW5zdGFuY2VzIG9mIHRoZSBkZW11eGVyLlxuICAgKi9cbiAgcmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbikge1xuICAgIHRoaXMucG10UGFyc2VkID0gZmFsc2U7XG4gICAgdGhpcy5fcG10SWQgPSAtMTtcbiAgICB0aGlzLl92aWRlb1RyYWNrID0gVFNEZW11eGVyLmNyZWF0ZVRyYWNrKCd2aWRlbycpO1xuICAgIHRoaXMuX3ZpZGVvVHJhY2suZHVyYXRpb24gPSB0cmFja0R1cmF0aW9uO1xuICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSBUU0RlbXV4ZXIuY3JlYXRlVHJhY2soJ2F1ZGlvJywgdHJhY2tEdXJhdGlvbik7XG4gICAgdGhpcy5faWQzVHJhY2sgPSBUU0RlbXV4ZXIuY3JlYXRlVHJhY2soJ2lkMycpO1xuICAgIHRoaXMuX3R4dFRyYWNrID0gVFNEZW11eGVyLmNyZWF0ZVRyYWNrKCd0ZXh0Jyk7XG4gICAgdGhpcy5fYXVkaW9UcmFjay5zZWdtZW50Q29kZWMgPSAnYWFjJztcblxuICAgIC8vIGZsdXNoIGFueSBwYXJ0aWFsIGNvbnRlbnRcbiAgICB0aGlzLmFhY092ZXJGbG93ID0gbnVsbDtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIHRoaXMuYXVkaW9Db2RlYyA9IGF1ZGlvQ29kZWM7XG4gICAgdGhpcy52aWRlb0NvZGVjID0gdmlkZW9Db2RlYztcbiAgfVxuICByZXNldFRpbWVTdGFtcCgpIHt9XG4gIHJlc2V0Q29udGlndWl0eSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBfYXVkaW9UcmFjayxcbiAgICAgIF92aWRlb1RyYWNrLFxuICAgICAgX2lkM1RyYWNrXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKF9hdWRpb1RyYWNrKSB7XG4gICAgICBfYXVkaW9UcmFjay5wZXNEYXRhID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKF92aWRlb1RyYWNrKSB7XG4gICAgICBfdmlkZW9UcmFjay5wZXNEYXRhID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKF9pZDNUcmFjaykge1xuICAgICAgX2lkM1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmFhY092ZXJGbG93ID0gbnVsbDtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICB9XG4gIGRlbXV4KGRhdGEsIHRpbWVPZmZzZXQsIGlzU2FtcGxlQWVzID0gZmFsc2UsIGZsdXNoID0gZmFsc2UpIHtcbiAgICBpZiAoIWlzU2FtcGxlQWVzKSB7XG4gICAgICB0aGlzLnNhbXBsZUFlcyA9IG51bGw7XG4gICAgfVxuICAgIGxldCBwZXM7XG4gICAgY29uc3QgdmlkZW9UcmFjayA9IHRoaXMuX3ZpZGVvVHJhY2s7XG4gICAgY29uc3QgYXVkaW9UcmFjayA9IHRoaXMuX2F1ZGlvVHJhY2s7XG4gICAgY29uc3QgaWQzVHJhY2sgPSB0aGlzLl9pZDNUcmFjaztcbiAgICBjb25zdCB0ZXh0VHJhY2sgPSB0aGlzLl90eHRUcmFjaztcbiAgICBsZXQgdmlkZW9QaWQgPSB2aWRlb1RyYWNrLnBpZDtcbiAgICBsZXQgdmlkZW9EYXRhID0gdmlkZW9UcmFjay5wZXNEYXRhO1xuICAgIGxldCBhdWRpb1BpZCA9IGF1ZGlvVHJhY2sucGlkO1xuICAgIGxldCBpZDNQaWQgPSBpZDNUcmFjay5waWQ7XG4gICAgbGV0IGF1ZGlvRGF0YSA9IGF1ZGlvVHJhY2sucGVzRGF0YTtcbiAgICBsZXQgaWQzRGF0YSA9IGlkM1RyYWNrLnBlc0RhdGE7XG4gICAgbGV0IHVua25vd25QSUQgPSBudWxsO1xuICAgIGxldCBwbXRQYXJzZWQgPSB0aGlzLnBtdFBhcnNlZDtcbiAgICBsZXQgcG10SWQgPSB0aGlzLl9wbXRJZDtcbiAgICBsZXQgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgaWYgKHRoaXMucmVtYWluZGVyRGF0YSkge1xuICAgICAgZGF0YSA9IGFwcGVuZFVpbnQ4QXJyYXkodGhpcy5yZW1haW5kZXJEYXRhLCBkYXRhKTtcbiAgICAgIGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGxlbiA8IFBBQ0tFVF9MRU5HVEggJiYgIWZsdXNoKSB7XG4gICAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBkYXRhO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXVkaW9UcmFjayxcbiAgICAgICAgdmlkZW9UcmFjayxcbiAgICAgICAgaWQzVHJhY2ssXG4gICAgICAgIHRleHRUcmFja1xuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgc3luY09mZnNldCA9IE1hdGgubWF4KDAsIFRTRGVtdXhlci5zeW5jT2Zmc2V0KGRhdGEpKTtcbiAgICBsZW4gLT0gKGxlbiAtIHN5bmNPZmZzZXQpICUgUEFDS0VUX0xFTkdUSDtcbiAgICBpZiAobGVuIDwgZGF0YS5ieXRlTGVuZ3RoICYmICFmbHVzaCkge1xuICAgICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIsIGxlbiwgZGF0YS5idWZmZXIuYnl0ZUxlbmd0aCAtIGxlbik7XG4gICAgfVxuXG4gICAgLy8gbG9vcCB0aHJvdWdoIFRTIHBhY2tldHNcbiAgICBsZXQgdHNQYWNrZXRFcnJvcnMgPSAwO1xuICAgIGZvciAobGV0IHN0YXJ0ID0gc3luY09mZnNldDsgc3RhcnQgPCBsZW47IHN0YXJ0ICs9IFBBQ0tFVF9MRU5HVEgpIHtcbiAgICAgIGlmIChkYXRhW3N0YXJ0XSA9PT0gMHg0Nykge1xuICAgICAgICBjb25zdCBzdHQgPSAhIShkYXRhW3N0YXJ0ICsgMV0gJiAweDQwKTtcbiAgICAgICAgY29uc3QgcGlkID0gcGFyc2VQSUQoZGF0YSwgc3RhcnQpO1xuICAgICAgICBjb25zdCBhdGYgPSAoZGF0YVtzdGFydCArIDNdICYgMHgzMCkgPj4gNDtcblxuICAgICAgICAvLyBpZiBhbiBhZGFwdGlvbiBmaWVsZCBpcyBwcmVzZW50LCBpdHMgbGVuZ3RoIGlzIHNwZWNpZmllZCBieSB0aGUgZmlmdGggYnl0ZSBvZiB0aGUgVFMgcGFja2V0IGhlYWRlci5cbiAgICAgICAgbGV0IG9mZnNldDtcbiAgICAgICAgaWYgKGF0ZiA+IDEpIHtcbiAgICAgICAgICBvZmZzZXQgPSBzdGFydCArIDUgKyBkYXRhW3N0YXJ0ICsgNF07XG4gICAgICAgICAgLy8gY29udGludWUgaWYgdGhlcmUgaXMgb25seSBhZGFwdGF0aW9uIGZpZWxkXG4gICAgICAgICAgaWYgKG9mZnNldCA9PT0gc3RhcnQgKyBQQUNLRVRfTEVOR1RIKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Zmc2V0ID0gc3RhcnQgKyA0O1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAocGlkKSB7XG4gICAgICAgICAgY2FzZSB2aWRlb1BpZDpcbiAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgaWYgKHZpZGVvRGF0YSAmJiAocGVzID0gcGFyc2VQRVModmlkZW9EYXRhLCB0aGlzLmxvZ2dlcikpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmlkZW9QYXJzZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHN3aXRjaCAodmlkZW9UcmFjay5zZWdtZW50Q29kZWMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYXZjJzpcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZGVvUGFyc2VyID0gbmV3IEF2Y1ZpZGVvUGFyc2VyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2hldmMnOlxuICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlkZW9QYXJzZXIgPSBuZXcgSGV2Y1ZpZGVvUGFyc2VyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy52aWRlb1BhcnNlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy52aWRlb1BhcnNlci5wYXJzZVBFUyh2aWRlb1RyYWNrLCB0ZXh0VHJhY2ssIHBlcywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2aWRlb0RhdGEgPSB7XG4gICAgICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICAgICAgc2l6ZTogMFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZpZGVvRGF0YSkge1xuICAgICAgICAgICAgICB2aWRlb0RhdGEuZGF0YS5wdXNoKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBzdGFydCArIFBBQ0tFVF9MRU5HVEgpKTtcbiAgICAgICAgICAgICAgdmlkZW9EYXRhLnNpemUgKz0gc3RhcnQgKyBQQUNLRVRfTEVOR1RIIC0gb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBhdWRpb1BpZDpcbiAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgaWYgKGF1ZGlvRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoYXVkaW9EYXRhLCB0aGlzLmxvZ2dlcikpKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChhdWRpb1RyYWNrLnNlZ21lbnRDb2RlYykge1xuICAgICAgICAgICAgICAgICAgY2FzZSAnYWFjJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZUFBQ1BFUyhhdWRpb1RyYWNrLCBwZXMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ21wMyc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VNUEVHUEVTKGF1ZGlvVHJhY2ssIHBlcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAnYWMzJzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VBQzNQRVMoYXVkaW9UcmFjaywgcGVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXVkaW9EYXRhID0ge1xuICAgICAgICAgICAgICAgIGRhdGE6IFtdLFxuICAgICAgICAgICAgICAgIHNpemU6IDBcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdWRpb0RhdGEpIHtcbiAgICAgICAgICAgICAgYXVkaW9EYXRhLmRhdGEucHVzaChkYXRhLnN1YmFycmF5KG9mZnNldCwgc3RhcnQgKyBQQUNLRVRfTEVOR1RIKSk7XG4gICAgICAgICAgICAgIGF1ZGlvRGF0YS5zaXplICs9IHN0YXJ0ICsgUEFDS0VUX0xFTkdUSCAtIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQzUGlkOlxuICAgICAgICAgICAgaWYgKHN0dCkge1xuICAgICAgICAgICAgICBpZiAoaWQzRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoaWQzRGF0YSwgdGhpcy5sb2dnZXIpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VJRDNQRVMoaWQzVHJhY2ssIHBlcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWQzRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICAgICAgICBzaXplOiAwXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaWQzRGF0YSkge1xuICAgICAgICAgICAgICBpZDNEYXRhLmRhdGEucHVzaChkYXRhLnN1YmFycmF5KG9mZnNldCwgc3RhcnQgKyBQQUNLRVRfTEVOR1RIKSk7XG4gICAgICAgICAgICAgIGlkM0RhdGEuc2l6ZSArPSBzdGFydCArIFBBQ0tFVF9MRU5HVEggLSBvZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICAgIG9mZnNldCArPSBkYXRhW29mZnNldF0gKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG10SWQgPSB0aGlzLl9wbXRJZCA9IHBhcnNlUEFUKGRhdGEsIG9mZnNldCk7XG4gICAgICAgICAgICAvLyB0aGlzLmxvZ2dlci5sb2coJ1BNVCBQSUQ6JyAgKyB0aGlzLl9wbXRJZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIHBtdElkOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGRhdGFbb2Zmc2V0XSArIDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgcGFyc2VkUElEcyA9IHBhcnNlUE1UKGRhdGEsIG9mZnNldCwgdGhpcy50eXBlU3VwcG9ydGVkLCBpc1NhbXBsZUFlcywgdGhpcy5vYnNlcnZlciwgdGhpcy5sb2dnZXIpO1xuXG4gICAgICAgICAgICAgIC8vIG9ubHkgdXBkYXRlIHRyYWNrIGlkIGlmIHRyYWNrIFBJRCBmb3VuZCB3aGlsZSBwYXJzaW5nIFBNVFxuICAgICAgICAgICAgICAvLyB0aGlzIGlzIHRvIGF2b2lkIHJlc2V0dGluZyB0aGUgUElEIHRvIC0xIGluIGNhc2VcbiAgICAgICAgICAgICAgLy8gdHJhY2sgUElEIHRyYW5zaWVudGx5IGRpc2FwcGVhcnMgZnJvbSB0aGUgc3RyZWFtXG4gICAgICAgICAgICAgIC8vIHRoaXMgY291bGQgaGFwcGVuIGluIGNhc2Ugb2YgdHJhbnNpZW50IG1pc3NpbmcgYXVkaW8gc2FtcGxlcyBmb3IgZXhhbXBsZVxuICAgICAgICAgICAgICAvLyBOT1RFIHRoaXMgaXMgb25seSB0aGUgUElEIG9mIHRoZSB0cmFjayBhcyBmb3VuZCBpbiBUUyxcbiAgICAgICAgICAgICAgLy8gYnV0IHdlIGFyZSBub3QgdXNpbmcgdGhpcyBmb3IgTVA0IHRyYWNrIElEcy5cbiAgICAgICAgICAgICAgdmlkZW9QaWQgPSBwYXJzZWRQSURzLnZpZGVvUGlkO1xuICAgICAgICAgICAgICBpZiAodmlkZW9QaWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgdmlkZW9UcmFjay5waWQgPSB2aWRlb1BpZDtcbiAgICAgICAgICAgICAgICB2aWRlb1RyYWNrLnNlZ21lbnRDb2RlYyA9IHBhcnNlZFBJRHMuc2VnbWVudFZpZGVvQ29kZWM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXVkaW9QaWQgPSBwYXJzZWRQSURzLmF1ZGlvUGlkO1xuICAgICAgICAgICAgICBpZiAoYXVkaW9QaWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgYXVkaW9UcmFjay5waWQgPSBhdWRpb1BpZDtcbiAgICAgICAgICAgICAgICBhdWRpb1RyYWNrLnNlZ21lbnRDb2RlYyA9IHBhcnNlZFBJRHMuc2VnbWVudEF1ZGlvQ29kZWM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWQzUGlkID0gcGFyc2VkUElEcy5pZDNQaWQ7XG4gICAgICAgICAgICAgIGlmIChpZDNQaWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWQzVHJhY2sucGlkID0gaWQzUGlkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh1bmtub3duUElEICE9PSBudWxsICYmICFwbXRQYXJzZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBNUEVHLVRTIFBNVCBmb3VuZCBhdCAke3N0YXJ0fSBhZnRlciB1bmtub3duIFBJRCAnJHt1bmtub3duUElEfScuIEJhY2t0cmFja2luZyB0byBzeW5jIGJ5dGUgQCR7c3luY09mZnNldH0gdG8gcGFyc2UgYWxsIFRTIHBhY2tldHMuYCk7XG4gICAgICAgICAgICAgICAgdW5rbm93blBJRCA9IG51bGw7XG4gICAgICAgICAgICAgICAgLy8gd2Ugc2V0IGl0IHRvIC0xODgsIHRoZSArPSAxODggaW4gdGhlIGZvciBsb29wIHdpbGwgcmVzZXQgc3RhcnQgdG8gMFxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gc3luY09mZnNldCAtIDE4ODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwbXRQYXJzZWQgPSB0aGlzLnBtdFBhcnNlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMHgxMTpcbiAgICAgICAgICBjYXNlIDB4MWZmZjpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB1bmtub3duUElEID0gcGlkO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRzUGFja2V0RXJyb3JzKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0c1BhY2tldEVycm9ycyA+IDApIHtcbiAgICAgIGVtaXRQYXJzaW5nRXJyb3IodGhpcy5vYnNlcnZlciwgbmV3IEVycm9yKGBGb3VuZCAke3RzUGFja2V0RXJyb3JzfSBUUyBwYWNrZXQvcyB0aGF0IGRvIG5vdCBzdGFydCB3aXRoIDB4NDdgKSwgdW5kZWZpbmVkLCB0aGlzLmxvZ2dlcik7XG4gICAgfVxuICAgIHZpZGVvVHJhY2sucGVzRGF0YSA9IHZpZGVvRGF0YTtcbiAgICBhdWRpb1RyYWNrLnBlc0RhdGEgPSBhdWRpb0RhdGE7XG4gICAgaWQzVHJhY2sucGVzRGF0YSA9IGlkM0RhdGE7XG4gICAgY29uc3QgZGVtdXhSZXN1bHQgPSB7XG4gICAgICBhdWRpb1RyYWNrLFxuICAgICAgdmlkZW9UcmFjayxcbiAgICAgIGlkM1RyYWNrLFxuICAgICAgdGV4dFRyYWNrXG4gICAgfTtcbiAgICBpZiAoZmx1c2gpIHtcbiAgICAgIHRoaXMuZXh0cmFjdFJlbWFpbmluZ1NhbXBsZXMoZGVtdXhSZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gZGVtdXhSZXN1bHQ7XG4gIH1cbiAgZmx1c2goKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVtYWluZGVyRGF0YVxuICAgIH0gPSB0aGlzO1xuICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAocmVtYWluZGVyRGF0YSkge1xuICAgICAgcmVzdWx0ID0gdGhpcy5kZW11eChyZW1haW5kZXJEYXRhLCAtMSwgZmFsc2UsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIHZpZGVvVHJhY2s6IHRoaXMuX3ZpZGVvVHJhY2ssXG4gICAgICAgIGF1ZGlvVHJhY2s6IHRoaXMuX2F1ZGlvVHJhY2ssXG4gICAgICAgIGlkM1RyYWNrOiB0aGlzLl9pZDNUcmFjayxcbiAgICAgICAgdGV4dFRyYWNrOiB0aGlzLl90eHRUcmFja1xuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5leHRyYWN0UmVtYWluaW5nU2FtcGxlcyhyZXN1bHQpO1xuICAgIGlmICh0aGlzLnNhbXBsZUFlcykge1xuICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdChyZXN1bHQsIHRoaXMuc2FtcGxlQWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBleHRyYWN0UmVtYWluaW5nU2FtcGxlcyhkZW11eFJlc3VsdCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGF1ZGlvVHJhY2ssXG4gICAgICB2aWRlb1RyYWNrLFxuICAgICAgaWQzVHJhY2ssXG4gICAgICB0ZXh0VHJhY2tcbiAgICB9ID0gZGVtdXhSZXN1bHQ7XG4gICAgY29uc3QgdmlkZW9EYXRhID0gdmlkZW9UcmFjay5wZXNEYXRhO1xuICAgIGNvbnN0IGF1ZGlvRGF0YSA9IGF1ZGlvVHJhY2sucGVzRGF0YTtcbiAgICBjb25zdCBpZDNEYXRhID0gaWQzVHJhY2sucGVzRGF0YTtcbiAgICAvLyB0cnkgdG8gcGFyc2UgbGFzdCBQRVMgcGFja2V0c1xuICAgIGxldCBwZXM7XG4gICAgaWYgKHZpZGVvRGF0YSAmJiAocGVzID0gcGFyc2VQRVModmlkZW9EYXRhLCB0aGlzLmxvZ2dlcikpKSB7XG4gICAgICBpZiAodGhpcy52aWRlb1BhcnNlciA9PT0gbnVsbCkge1xuICAgICAgICBzd2l0Y2ggKHZpZGVvVHJhY2suc2VnbWVudENvZGVjKSB7XG4gICAgICAgICAgY2FzZSAnYXZjJzpcbiAgICAgICAgICAgIHRoaXMudmlkZW9QYXJzZXIgPSBuZXcgQXZjVmlkZW9QYXJzZXIoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2hldmMnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aGlzLnZpZGVvUGFyc2VyID0gbmV3IEhldmNWaWRlb1BhcnNlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnZpZGVvUGFyc2VyICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMudmlkZW9QYXJzZXIucGFyc2VQRVModmlkZW9UcmFjaywgdGV4dFRyYWNrLCBwZXMsIHRydWUpO1xuICAgICAgICB2aWRlb1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlaXRoZXIgYXZjRGF0YSBudWxsIG9yIFBFUyB0cnVuY2F0ZWQsIGtlZXAgaXQgZm9yIG5leHQgZnJhZyBwYXJzaW5nXG4gICAgICB2aWRlb1RyYWNrLnBlc0RhdGEgPSB2aWRlb0RhdGE7XG4gICAgfVxuICAgIGlmIChhdWRpb0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGF1ZGlvRGF0YSwgdGhpcy5sb2dnZXIpKSkge1xuICAgICAgc3dpdGNoIChhdWRpb1RyYWNrLnNlZ21lbnRDb2RlYykge1xuICAgICAgICBjYXNlICdhYWMnOlxuICAgICAgICAgIHRoaXMucGFyc2VBQUNQRVMoYXVkaW9UcmFjaywgcGVzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbXAzJzpcbiAgICAgICAgICB0aGlzLnBhcnNlTVBFR1BFUyhhdWRpb1RyYWNrLCBwZXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdhYzMnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VBQzNQRVMoYXVkaW9UcmFjaywgcGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBhdWRpb1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYXVkaW9EYXRhICE9IG51bGwgJiYgYXVkaW9EYXRhLnNpemUpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKCdsYXN0IEFBQyBQRVMgcGFja2V0IHRydW5jYXRlZCxtaWdodCBvdmVybGFwIGJldHdlZW4gZnJhZ21lbnRzJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGVpdGhlciBhdWRpb0RhdGEgbnVsbCBvciBQRVMgdHJ1bmNhdGVkLCBrZWVwIGl0IGZvciBuZXh0IGZyYWcgcGFyc2luZ1xuICAgICAgYXVkaW9UcmFjay5wZXNEYXRhID0gYXVkaW9EYXRhO1xuICAgIH1cbiAgICBpZiAoaWQzRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoaWQzRGF0YSwgdGhpcy5sb2dnZXIpKSkge1xuICAgICAgdGhpcy5wYXJzZUlEM1BFUyhpZDNUcmFjaywgcGVzKTtcbiAgICAgIGlkM1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlaXRoZXIgaWQzRGF0YSBudWxsIG9yIFBFUyB0cnVuY2F0ZWQsIGtlZXAgaXQgZm9yIG5leHQgZnJhZyBwYXJzaW5nXG4gICAgICBpZDNUcmFjay5wZXNEYXRhID0gaWQzRGF0YTtcbiAgICB9XG4gIH1cbiAgZGVtdXhTYW1wbGVBZXMoZGF0YSwga2V5RGF0YSwgdGltZU9mZnNldCkge1xuICAgIGNvbnN0IGRlbXV4UmVzdWx0ID0gdGhpcy5kZW11eChkYXRhLCB0aW1lT2Zmc2V0LCB0cnVlLCAhdGhpcy5jb25maWcucHJvZ3Jlc3NpdmUpO1xuICAgIGNvbnN0IHNhbXBsZUFlcyA9IHRoaXMuc2FtcGxlQWVzID0gbmV3IFNhbXBsZUFlc0RlY3J5cHRlcih0aGlzLm9ic2VydmVyLCB0aGlzLmNvbmZpZywga2V5RGF0YSk7XG4gICAgcmV0dXJuIHRoaXMuZGVjcnlwdChkZW11eFJlc3VsdCwgc2FtcGxlQWVzKTtcbiAgfVxuICBkZWNyeXB0KGRlbXV4UmVzdWx0LCBzYW1wbGVBZXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGF1ZGlvVHJhY2ssXG4gICAgICAgIHZpZGVvVHJhY2tcbiAgICAgIH0gPSBkZW11eFJlc3VsdDtcbiAgICAgIGlmIChhdWRpb1RyYWNrLnNhbXBsZXMgJiYgYXVkaW9UcmFjay5zZWdtZW50Q29kZWMgPT09ICdhYWMnKSB7XG4gICAgICAgIHNhbXBsZUFlcy5kZWNyeXB0QWFjU2FtcGxlcyhhdWRpb1RyYWNrLnNhbXBsZXMsIDAsICgpID0+IHtcbiAgICAgICAgICBpZiAodmlkZW9UcmFjay5zYW1wbGVzKSB7XG4gICAgICAgICAgICBzYW1wbGVBZXMuZGVjcnlwdEF2Y1NhbXBsZXModmlkZW9UcmFjay5zYW1wbGVzLCAwLCAwLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHJlc29sdmUoZGVtdXhSZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoZGVtdXhSZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHZpZGVvVHJhY2suc2FtcGxlcykge1xuICAgICAgICBzYW1wbGVBZXMuZGVjcnlwdEF2Y1NhbXBsZXModmlkZW9UcmFjay5zYW1wbGVzLCAwLCAwLCAoKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZShkZW11eFJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMub2JzZXJ2ZXIpIHtcbiAgICAgIHRoaXMub2JzZXJ2ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmNvbmZpZyA9IHRoaXMubG9nZ2VyID0gdGhpcy5vYnNlcnZlciA9IG51bGw7XG4gICAgdGhpcy5hYWNPdmVyRmxvdyA9IHRoaXMudmlkZW9QYXJzZXIgPSB0aGlzLnJlbWFpbmRlckRhdGEgPSB0aGlzLnNhbXBsZUFlcyA9IG51bGw7XG4gICAgdGhpcy5fdmlkZW9UcmFjayA9IHRoaXMuX2F1ZGlvVHJhY2sgPSB0aGlzLl9pZDNUcmFjayA9IHRoaXMuX3R4dFRyYWNrID0gdW5kZWZpbmVkO1xuICB9XG4gIHBhcnNlQUFDUEVTKHRyYWNrLCBwZXMpIHtcbiAgICBsZXQgc3RhcnRPZmZzZXQgPSAwO1xuICAgIGNvbnN0IGFhY092ZXJGbG93ID0gdGhpcy5hYWNPdmVyRmxvdztcbiAgICBsZXQgZGF0YSA9IHBlcy5kYXRhO1xuICAgIGlmIChhYWNPdmVyRmxvdykge1xuICAgICAgdGhpcy5hYWNPdmVyRmxvdyA9IG51bGw7XG4gICAgICBjb25zdCBmcmFtZU1pc3NpbmdCeXRlcyA9IGFhY092ZXJGbG93Lm1pc3Npbmc7XG4gICAgICBjb25zdCBzYW1wbGVMZW5ndGggPSBhYWNPdmVyRmxvdy5zYW1wbGUudW5pdC5ieXRlTGVuZ3RoO1xuICAgICAgLy8gbG9nZ2VyLmxvZyhgQUFDOiBhcHBlbmQgb3ZlcmZsb3dpbmcgJHtzYW1wbGVMZW5ndGh9IGJ5dGVzIHRvIGJlZ2lubmluZyBvZiBuZXcgUEVTYCk7XG4gICAgICBpZiAoZnJhbWVNaXNzaW5nQnl0ZXMgPT09IC0xKSB7XG4gICAgICAgIGRhdGEgPSBhcHBlbmRVaW50OEFycmF5KGFhY092ZXJGbG93LnNhbXBsZS51bml0LCBkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGZyYW1lT3ZlcmZsb3dCeXRlcyA9IHNhbXBsZUxlbmd0aCAtIGZyYW1lTWlzc2luZ0J5dGVzO1xuICAgICAgICBhYWNPdmVyRmxvdy5zYW1wbGUudW5pdC5zZXQoZGF0YS5zdWJhcnJheSgwLCBmcmFtZU1pc3NpbmdCeXRlcyksIGZyYW1lT3ZlcmZsb3dCeXRlcyk7XG4gICAgICAgIHRyYWNrLnNhbXBsZXMucHVzaChhYWNPdmVyRmxvdy5zYW1wbGUpO1xuICAgICAgICBzdGFydE9mZnNldCA9IGFhY092ZXJGbG93Lm1pc3Npbmc7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGxvb2sgZm9yIEFEVFMgaGVhZGVyICgweEZGRngpXG4gICAgbGV0IG9mZnNldDtcbiAgICBsZXQgbGVuO1xuICAgIGZvciAob2Zmc2V0ID0gc3RhcnRPZmZzZXQsIGxlbiA9IGRhdGEubGVuZ3RoOyBvZmZzZXQgPCBsZW4gLSAxOyBvZmZzZXQrKykge1xuICAgICAgaWYgKGlzSGVhZGVyJDEoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgQURUUyBoZWFkZXIgZG9lcyBub3Qgc3RhcnQgc3RyYWlnaHQgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBQRVMgcGF5bG9hZCwgcmFpc2UgYW4gZXJyb3JcbiAgICBpZiAob2Zmc2V0ICE9PSBzdGFydE9mZnNldCkge1xuICAgICAgbGV0IHJlYXNvbjtcbiAgICAgIGNvbnN0IHJlY292ZXJhYmxlID0gb2Zmc2V0IDwgbGVuIC0gMTtcbiAgICAgIGlmIChyZWNvdmVyYWJsZSkge1xuICAgICAgICByZWFzb24gPSBgQUFDIFBFUyBkaWQgbm90IHN0YXJ0IHdpdGggQURUUyBoZWFkZXIsb2Zmc2V0OiR7b2Zmc2V0fWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWFzb24gPSAnTm8gQURUUyBoZWFkZXIgZm91bmQgaW4gQUFDIFBFUyc7XG4gICAgICB9XG4gICAgICBlbWl0UGFyc2luZ0Vycm9yKHRoaXMub2JzZXJ2ZXIsIG5ldyBFcnJvcihyZWFzb24pLCByZWNvdmVyYWJsZSwgdGhpcy5sb2dnZXIpO1xuICAgICAgaWYgKCFyZWNvdmVyYWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGluaXRUcmFja0NvbmZpZyh0cmFjaywgdGhpcy5vYnNlcnZlciwgZGF0YSwgb2Zmc2V0LCB0aGlzLmF1ZGlvQ29kZWMpO1xuICAgIGxldCBwdHM7XG4gICAgaWYgKHBlcy5wdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcHRzID0gcGVzLnB0cztcbiAgICB9IGVsc2UgaWYgKGFhY092ZXJGbG93KSB7XG4gICAgICAvLyBpZiBsYXN0IEFBQyBmcmFtZSBpcyBvdmVyZmxvd2luZywgd2Ugc2hvdWxkIGVuc3VyZSB0aW1lc3RhbXBzIGFyZSBjb250aWd1b3VzOlxuICAgICAgLy8gZmlyc3Qgc2FtcGxlIFBUUyBzaG91bGQgYmUgZXF1YWwgdG8gbGFzdCBzYW1wbGUgUFRTICsgZnJhbWVEdXJhdGlvblxuICAgICAgY29uc3QgZnJhbWVEdXJhdGlvbiA9IGdldEZyYW1lRHVyYXRpb24odHJhY2suc2FtcGxlcmF0ZSk7XG4gICAgICBwdHMgPSBhYWNPdmVyRmxvdy5zYW1wbGUucHRzICsgZnJhbWVEdXJhdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2dnZXIud2FybignW3RzZGVtdXhlcl06IEFBQyBQRVMgdW5rbm93biBQVFMnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzY2FuIGZvciBhYWMgc2FtcGxlc1xuICAgIGxldCBmcmFtZUluZGV4ID0gMDtcbiAgICBsZXQgZnJhbWU7XG4gICAgd2hpbGUgKG9mZnNldCA8IGxlbikge1xuICAgICAgZnJhbWUgPSBhcHBlbmRGcmFtZSQyKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHB0cywgZnJhbWVJbmRleCk7XG4gICAgICBvZmZzZXQgKz0gZnJhbWUubGVuZ3RoO1xuICAgICAgaWYgKCFmcmFtZS5taXNzaW5nKSB7XG4gICAgICAgIGZyYW1lSW5kZXgrKztcbiAgICAgICAgZm9yICg7IG9mZnNldCA8IGxlbiAtIDE7IG9mZnNldCsrKSB7XG4gICAgICAgICAgaWYgKGlzSGVhZGVyJDEoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFhY092ZXJGbG93ID0gZnJhbWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwYXJzZU1QRUdQRVModHJhY2ssIHBlcykge1xuICAgIGNvbnN0IGRhdGEgPSBwZXMuZGF0YTtcbiAgICBjb25zdCBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICBsZXQgZnJhbWVJbmRleCA9IDA7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgY29uc3QgcHRzID0gcGVzLnB0cztcbiAgICBpZiAocHRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ1t0c2RlbXV4ZXJdOiBNUEVHIFBFUyB1bmtub3duIFBUUycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3aGlsZSAob2Zmc2V0IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICBjb25zdCBmcmFtZSA9IGFwcGVuZEZyYW1lJDEodHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KTtcbiAgICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgICAgb2Zmc2V0ICs9IGZyYW1lLmxlbmd0aDtcbiAgICAgICAgICBmcmFtZUluZGV4Kys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbG9nZ2VyLmxvZygnVW5hYmxlIHRvIHBhcnNlIE1wZWcgYXVkaW8gZnJhbWUnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm90aGluZyBmb3VuZCwga2VlcCBsb29raW5nXG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwYXJzZUFDM1BFUyh0cmFjaywgcGVzKSB7XG4gICAge1xuICAgICAgY29uc3QgZGF0YSA9IHBlcy5kYXRhO1xuICAgICAgY29uc3QgcHRzID0gcGVzLnB0cztcbiAgICAgIGlmIChwdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdbdHNkZW11eGVyXTogQUMzIFBFUyB1bmtub3duIFBUUycpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIGxldCBmcmFtZUluZGV4ID0gMDtcbiAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgbGV0IHBhcnNlZDtcbiAgICAgIHdoaWxlIChvZmZzZXQgPCBsZW5ndGggJiYgKHBhcnNlZCA9IGFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHB0cywgZnJhbWVJbmRleCsrKSkgPiAwKSB7XG4gICAgICAgIG9mZnNldCArPSBwYXJzZWQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBhcnNlSUQzUEVTKGlkM1RyYWNrLCBwZXMpIHtcbiAgICBpZiAocGVzLnB0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKCdbdHNkZW11eGVyXTogSUQzIFBFUyB1bmtub3duIFBUUycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpZDNTYW1wbGUgPSBfZXh0ZW5kcyh7fSwgcGVzLCB7XG4gICAgICB0eXBlOiB0aGlzLl92aWRlb1RyYWNrID8gTWV0YWRhdGFTY2hlbWEuZW1zZyA6IE1ldGFkYXRhU2NoZW1hLmF1ZGlvSWQzLFxuICAgICAgZHVyYXRpb246IE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxuICAgIH0pO1xuICAgIGlkM1RyYWNrLnNhbXBsZXMucHVzaChpZDNTYW1wbGUpO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZVBJRChkYXRhLCBvZmZzZXQpIHtcbiAgLy8gcGlkIGlzIGEgMTMtYml0IGZpZWxkIHN0YXJ0aW5nIGF0IHRoZSBsYXN0IGJpdCBvZiBUU1sxXVxuICByZXR1cm4gKChkYXRhW29mZnNldCArIDFdICYgMHgxZikgPDwgOCkgKyBkYXRhW29mZnNldCArIDJdO1xufVxuZnVuY3Rpb24gcGFyc2VQQVQoZGF0YSwgb2Zmc2V0KSB7XG4gIC8vIHNraXAgdGhlIFBTSSBoZWFkZXIgYW5kIHBhcnNlIHRoZSBmaXJzdCBQTVQgZW50cnlcbiAgcmV0dXJuIChkYXRhW29mZnNldCArIDEwXSAmIDB4MWYpIDw8IDggfCBkYXRhW29mZnNldCArIDExXTtcbn1cbmZ1bmN0aW9uIHBhcnNlUE1UKGRhdGEsIG9mZnNldCwgdHlwZVN1cHBvcnRlZCwgaXNTYW1wbGVBZXMsIG9ic2VydmVyLCBsb2dnZXIpIHtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIGF1ZGlvUGlkOiAtMSxcbiAgICB2aWRlb1BpZDogLTEsXG4gICAgaWQzUGlkOiAtMSxcbiAgICBzZWdtZW50VmlkZW9Db2RlYzogJ2F2YycsXG4gICAgc2VnbWVudEF1ZGlvQ29kZWM6ICdhYWMnXG4gIH07XG4gIGNvbnN0IHNlY3Rpb25MZW5ndGggPSAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4MGYpIDw8IDggfCBkYXRhW29mZnNldCArIDJdO1xuICBjb25zdCB0YWJsZUVuZCA9IG9mZnNldCArIDMgKyBzZWN0aW9uTGVuZ3RoIC0gNDtcbiAgLy8gdG8gZGV0ZXJtaW5lIHdoZXJlIHRoZSB0YWJsZSBpcywgd2UgaGF2ZSB0byBmaWd1cmUgb3V0IGhvd1xuICAvLyBsb25nIHRoZSBwcm9ncmFtIGluZm8gZGVzY3JpcHRvcnMgYXJlXG4gIGNvbnN0IHByb2dyYW1JbmZvTGVuZ3RoID0gKGRhdGFbb2Zmc2V0ICsgMTBdICYgMHgwZikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgMTFdO1xuICAvLyBhZHZhbmNlIHRoZSBvZmZzZXQgdG8gdGhlIGZpcnN0IGVudHJ5IGluIHRoZSBtYXBwaW5nIHRhYmxlXG4gIG9mZnNldCArPSAxMiArIHByb2dyYW1JbmZvTGVuZ3RoO1xuICB3aGlsZSAob2Zmc2V0IDwgdGFibGVFbmQpIHtcbiAgICBjb25zdCBwaWQgPSBwYXJzZVBJRChkYXRhLCBvZmZzZXQpO1xuICAgIGNvbnN0IGVzSW5mb0xlbmd0aCA9IChkYXRhW29mZnNldCArIDNdICYgMHgwZikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgNF07XG4gICAgc3dpdGNoIChkYXRhW29mZnNldF0pIHtcbiAgICAgIGNhc2UgMHhjZjpcbiAgICAgICAgLy8gU0FNUExFLUFFUyBBQUNcbiAgICAgICAgaWYgKCFpc1NhbXBsZUFlcykge1xuICAgICAgICAgIGxvZ0VuY3J5cHRlZFNhbXBsZXNGb3VuZEluVW5lbmNyeXB0ZWRTdHJlYW0oJ0FEVFMgQUFDJywgbG9nZ2VyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSAweDBmOlxuICAgICAgICAvLyBJU08vSUVDIDEzODE4LTcgQURUUyBBQUMgKE1QRUctMiBsb3dlciBiaXQtcmF0ZSBhdWRpbylcbiAgICAgICAgLy8gbG9nZ2VyLmxvZygnQUFDIFBJRDonICArIHBpZCk7XG4gICAgICAgIGlmIChyZXN1bHQuYXVkaW9QaWQgPT09IC0xKSB7XG4gICAgICAgICAgcmVzdWx0LmF1ZGlvUGlkID0gcGlkO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAvLyBQYWNrZXRpemVkIG1ldGFkYXRhIChJRDMpXG4gICAgICBjYXNlIDB4MTU6XG4gICAgICAgIC8vIGxvZ2dlci5sb2coJ0lEMyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICBpZiAocmVzdWx0LmlkM1BpZCA9PT0gLTEpIHtcbiAgICAgICAgICByZXN1bHQuaWQzUGlkID0gcGlkO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAweGRiOlxuICAgICAgICAvLyBTQU1QTEUtQUVTIEFWQ1xuICAgICAgICBpZiAoIWlzU2FtcGxlQWVzKSB7XG4gICAgICAgICAgbG9nRW5jcnlwdGVkU2FtcGxlc0ZvdW5kSW5VbmVuY3J5cHRlZFN0cmVhbSgnSC4yNjQnLCBsb2dnZXIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIDB4MWI6XG4gICAgICAgIC8vIElUVS1UIFJlYy4gSC4yNjQgYW5kIElTTy9JRUMgMTQ0OTYtMTAgKGxvd2VyIGJpdC1yYXRlIHZpZGVvKVxuICAgICAgICAvLyBsb2dnZXIubG9nKCdBVkMgUElEOicgICsgcGlkKTtcbiAgICAgICAgaWYgKHJlc3VsdC52aWRlb1BpZCA9PT0gLTEpIHtcbiAgICAgICAgICByZXN1bHQudmlkZW9QaWQgPSBwaWQ7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIC8vIElTTy9JRUMgMTExNzItMyAoTVBFRy0xIGF1ZGlvKVxuICAgICAgLy8gb3IgSVNPL0lFQyAxMzgxOC0zIChNUEVHLTIgaGFsdmVkIHNhbXBsZSByYXRlIGF1ZGlvKVxuICAgICAgY2FzZSAweDAzOlxuICAgICAgY2FzZSAweDA0OlxuICAgICAgICAvLyBsb2dnZXIubG9nKCdNUEVHIFBJRDonICArIHBpZCk7XG4gICAgICAgIGlmICghdHlwZVN1cHBvcnRlZC5tcGVnICYmICF0eXBlU3VwcG9ydGVkLm1wMykge1xuICAgICAgICAgIGxvZ2dlci5sb2coJ01QRUcgYXVkaW8gZm91bmQsIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJyk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmF1ZGlvUGlkID09PSAtMSkge1xuICAgICAgICAgIHJlc3VsdC5hdWRpb1BpZCA9IHBpZDtcbiAgICAgICAgICByZXN1bHQuc2VnbWVudEF1ZGlvQ29kZWMgPSAnbXAzJztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMHhjMTpcbiAgICAgICAgLy8gU0FNUExFLUFFUyBBQzNcbiAgICAgICAgaWYgKCFpc1NhbXBsZUFlcykge1xuICAgICAgICAgIGxvZ0VuY3J5cHRlZFNhbXBsZXNGb3VuZEluVW5lbmNyeXB0ZWRTdHJlYW0oJ0FDLTMnLCBsb2dnZXIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIDB4ODE6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoIXR5cGVTdXBwb3J0ZWQuYWMzKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKCdBQy0zIGF1ZGlvIGZvdW5kLCBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmF1ZGlvUGlkID09PSAtMSkge1xuICAgICAgICAgICAgcmVzdWx0LmF1ZGlvUGlkID0gcGlkO1xuICAgICAgICAgICAgcmVzdWx0LnNlZ21lbnRBdWRpb0NvZGVjID0gJ2FjMyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAweDA2OlxuICAgICAgICAvLyBzdHJlYW1fdHlwZSA2IGNhbiBtZWFuIGEgbG90IG9mIGRpZmZlcmVudCB0aGluZ3MgaW4gY2FzZSBvZiBEVkIuXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gbG9vayBhdCB0aGUgZGVzY3JpcHRvcnMuIFJpZ2h0IG5vdywgd2UncmUgb25seSBpbnRlcmVzdGVkXG4gICAgICAgIC8vIGluIEFDLTMgYXVkaW8sIHNvIHdlIGRvIHRoZSBkZXNjcmlwdG9yIHBhcnNpbmcgb25seSB3aGVuIHdlIGRvbid0IGhhdmVcbiAgICAgICAgLy8gYW4gYXVkaW8gUElEIHlldC5cbiAgICAgICAgaWYgKHJlc3VsdC5hdWRpb1BpZCA9PT0gLTEgJiYgZXNJbmZvTGVuZ3RoID4gMCkge1xuICAgICAgICAgIGxldCBwYXJzZVBvcyA9IG9mZnNldCArIDU7XG4gICAgICAgICAgbGV0IHJlbWFpbmluZyA9IGVzSW5mb0xlbmd0aDtcbiAgICAgICAgICB3aGlsZSAocmVtYWluaW5nID4gMikge1xuICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRvcklkID0gZGF0YVtwYXJzZVBvc107XG4gICAgICAgICAgICBzd2l0Y2ggKGRlc2NyaXB0b3JJZCkge1xuICAgICAgICAgICAgICBjYXNlIDB4NmE6XG4gICAgICAgICAgICAgICAgLy8gRFZCIERlc2NyaXB0b3IgZm9yIEFDLTNcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZVN1cHBvcnRlZC5hYzMgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnQUMtMyBhdWRpbyBmb3VuZCwgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIgZm9yIG5vdycpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmF1ZGlvUGlkID0gcGlkO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2VnbWVudEF1ZGlvQ29kZWMgPSAnYWMzJztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdG9yTGVuID0gZGF0YVtwYXJzZVBvcyArIDFdICsgMjtcbiAgICAgICAgICAgIHBhcnNlUG9zICs9IGRlc2NyaXB0b3JMZW47XG4gICAgICAgICAgICByZW1haW5pbmcgLT0gZGVzY3JpcHRvckxlbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDB4YzI6IC8vIFNBTVBMRS1BRVMgRUMzXG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIDB4ODc6XG4gICAgICAgIGVtaXRQYXJzaW5nRXJyb3Iob2JzZXJ2ZXIsIG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgRUMtMyBpbiBNMlRTIGZvdW5kJyksIHVuZGVmaW5lZCwgbG9nZ2VyKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIGNhc2UgMHgyNDpcbiAgICAgICAgLy8gSVRVLVQgUmVjLiBILjI2NSBhbmQgSVNPL0lFQyAyMzAwOC0yIChIRVZDKVxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHJlc3VsdC52aWRlb1BpZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdC52aWRlb1BpZCA9IHBpZDtcbiAgICAgICAgICAgIHJlc3VsdC5zZWdtZW50VmlkZW9Db2RlYyA9ICdoZXZjJztcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ0hFVkMgaW4gTTJUUyBmb3VuZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gbW92ZSB0byB0aGUgbmV4dCB0YWJsZSBlbnRyeVxuICAgIC8vIHNraXAgcGFzdCB0aGUgZWxlbWVudGFyeSBzdHJlYW0gZGVzY3JpcHRvcnMsIGlmIHByZXNlbnRcbiAgICBvZmZzZXQgKz0gZXNJbmZvTGVuZ3RoICsgNTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZW1pdFBhcnNpbmdFcnJvcihvYnNlcnZlciwgZXJyb3IsIGxldmVsUmV0cnksIGxvZ2dlcikge1xuICBsb2dnZXIud2FybihgcGFyc2luZyBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICBvYnNlcnZlci5lbWl0KEV2ZW50cy5FUlJPUiwgRXZlbnRzLkVSUk9SLCB7XG4gICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLFxuICAgIGZhdGFsOiBmYWxzZSxcbiAgICBsZXZlbFJldHJ5LFxuICAgIGVycm9yLFxuICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGxvZ0VuY3J5cHRlZFNhbXBsZXNGb3VuZEluVW5lbmNyeXB0ZWRTdHJlYW0odHlwZSwgbG9nZ2VyKSB7XG4gIGxvZ2dlci5sb2coYCR7dHlwZX0gd2l0aCBBRVMtMTI4LUNCQyBlbmNyeXB0aW9uIGZvdW5kIGluIHVuZW5jcnlwdGVkIHN0cmVhbWApO1xufVxuZnVuY3Rpb24gcGFyc2VQRVMoc3RyZWFtLCBsb2dnZXIpIHtcbiAgbGV0IGkgPSAwO1xuICBsZXQgZnJhZztcbiAgbGV0IHBlc0xlbjtcbiAgbGV0IHBlc0hkckxlbjtcbiAgbGV0IHBlc1B0cztcbiAgbGV0IHBlc0R0cztcbiAgY29uc3QgZGF0YSA9IHN0cmVhbS5kYXRhO1xuICAvLyBzYWZldHkgY2hlY2tcbiAgaWYgKCFzdHJlYW0gfHwgc3RyZWFtLnNpemUgPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIHdlIG1pZ2h0IG5lZWQgdXAgdG8gMTkgYnl0ZXMgdG8gcmVhZCBQRVMgaGVhZGVyXG4gIC8vIGlmIGZpcnN0IGNodW5rIG9mIGRhdGEgaXMgbGVzcyB0aGFuIDE5IGJ5dGVzLCBsZXQncyBtZXJnZSBpdCB3aXRoIGZvbGxvd2luZyBvbmVzIHVudGlsIHdlIGdldCAxOSBieXRlc1xuICAvLyB1c3VhbGx5IG9ubHkgb25lIG1lcmdlIGlzIG5lZWRlZCAoYW5kIHRoaXMgaXMgcmFyZSAuLi4pXG4gIHdoaWxlIChkYXRhWzBdLmxlbmd0aCA8IDE5ICYmIGRhdGEubGVuZ3RoID4gMSkge1xuICAgIGRhdGFbMF0gPSBhcHBlbmRVaW50OEFycmF5KGRhdGFbMF0sIGRhdGFbMV0pO1xuICAgIGRhdGEuc3BsaWNlKDEsIDEpO1xuICB9XG4gIC8vIHJldHJpZXZlIFBUUy9EVFMgZnJvbSBmaXJzdCBmcmFnbWVudFxuICBmcmFnID0gZGF0YVswXTtcbiAgY29uc3QgcGVzUHJlZml4ID0gKGZyYWdbMF0gPDwgMTYpICsgKGZyYWdbMV0gPDwgOCkgKyBmcmFnWzJdO1xuICBpZiAocGVzUHJlZml4ID09PSAxKSB7XG4gICAgcGVzTGVuID0gKGZyYWdbNF0gPDwgOCkgKyBmcmFnWzVdO1xuICAgIC8vIGlmIFBFUyBwYXJzZWQgbGVuZ3RoIGlzIG5vdCB6ZXJvIGFuZCBncmVhdGVyIHRoYW4gdG90YWwgcmVjZWl2ZWQgbGVuZ3RoLCBzdG9wIHBhcnNpbmcuIFBFUyBtaWdodCBiZSB0cnVuY2F0ZWRcbiAgICAvLyBtaW51cyA2IDogUEVTIGhlYWRlciBzaXplXG4gICAgaWYgKHBlc0xlbiAmJiBwZXNMZW4gPiBzdHJlYW0uc2l6ZSAtIDYpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBwZXNGbGFncyA9IGZyYWdbN107XG4gICAgaWYgKHBlc0ZsYWdzICYgMHhjMCkge1xuICAgICAgLyogUEVTIGhlYWRlciBkZXNjcmliZWQgaGVyZSA6IGh0dHA6Ly9kdmQuc291cmNlZm9yZ2UubmV0L2R2ZGluZm8vcGVzLWhkci5odG1sXG4gICAgICAgICAgYXMgUFRTIC8gRFRTIGlzIDMzIGJpdCB3ZSBjYW5ub3QgdXNlIGJpdHdpc2Ugb3BlcmF0b3IgaW4gSlMsXG4gICAgICAgICAgYXMgQml0d2lzZSBvcGVyYXRvcnMgdHJlYXQgdGhlaXIgb3BlcmFuZHMgYXMgYSBzZXF1ZW5jZSBvZiAzMiBiaXRzICovXG4gICAgICBwZXNQdHMgPSAoZnJhZ1s5XSAmIDB4MGUpICogNTM2ODcwOTEyICtcbiAgICAgIC8vIDEgPDwgMjlcbiAgICAgIChmcmFnWzEwXSAmIDB4ZmYpICogNDE5NDMwNCArXG4gICAgICAvLyAxIDw8IDIyXG4gICAgICAoZnJhZ1sxMV0gJiAweGZlKSAqIDE2Mzg0ICtcbiAgICAgIC8vIDEgPDwgMTRcbiAgICAgIChmcmFnWzEyXSAmIDB4ZmYpICogMTI4ICtcbiAgICAgIC8vIDEgPDwgN1xuICAgICAgKGZyYWdbMTNdICYgMHhmZSkgLyAyO1xuICAgICAgaWYgKHBlc0ZsYWdzICYgMHg0MCkge1xuICAgICAgICBwZXNEdHMgPSAoZnJhZ1sxNF0gJiAweDBlKSAqIDUzNjg3MDkxMiArXG4gICAgICAgIC8vIDEgPDwgMjlcbiAgICAgICAgKGZyYWdbMTVdICYgMHhmZikgKiA0MTk0MzA0ICtcbiAgICAgICAgLy8gMSA8PCAyMlxuICAgICAgICAoZnJhZ1sxNl0gJiAweGZlKSAqIDE2Mzg0ICtcbiAgICAgICAgLy8gMSA8PCAxNFxuICAgICAgICAoZnJhZ1sxN10gJiAweGZmKSAqIDEyOCArXG4gICAgICAgIC8vIDEgPDwgN1xuICAgICAgICAoZnJhZ1sxOF0gJiAweGZlKSAvIDI7XG4gICAgICAgIGlmIChwZXNQdHMgLSBwZXNEdHMgPiA2MCAqIDkwMDAwKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYCR7TWF0aC5yb3VuZCgocGVzUHRzIC0gcGVzRHRzKSAvIDkwMDAwKX1zIGRlbHRhIGJldHdlZW4gUFRTIGFuZCBEVFMsIGFsaWduIHRoZW1gKTtcbiAgICAgICAgICBwZXNQdHMgPSBwZXNEdHM7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlc0R0cyA9IHBlc1B0cztcbiAgICAgIH1cbiAgICB9XG4gICAgcGVzSGRyTGVuID0gZnJhZ1s4XTtcbiAgICAvLyA5IGJ5dGVzIDogNiBieXRlcyBmb3IgUEVTIGhlYWRlciArIDMgYnl0ZXMgZm9yIFBFUyBleHRlbnNpb25cbiAgICBsZXQgcGF5bG9hZFN0YXJ0T2Zmc2V0ID0gcGVzSGRyTGVuICsgOTtcbiAgICBpZiAoc3RyZWFtLnNpemUgPD0gcGF5bG9hZFN0YXJ0T2Zmc2V0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3RyZWFtLnNpemUgLT0gcGF5bG9hZFN0YXJ0T2Zmc2V0O1xuICAgIC8vIHJlYXNzZW1ibGUgUEVTIHBhY2tldFxuICAgIGNvbnN0IHBlc0RhdGEgPSBuZXcgVWludDhBcnJheShzdHJlYW0uc2l6ZSk7XG4gICAgZm9yIChsZXQgaiA9IDAsIGRhdGFMZW4gPSBkYXRhLmxlbmd0aDsgaiA8IGRhdGFMZW47IGorKykge1xuICAgICAgZnJhZyA9IGRhdGFbal07XG4gICAgICBsZXQgbGVuID0gZnJhZy5ieXRlTGVuZ3RoO1xuICAgICAgaWYgKHBheWxvYWRTdGFydE9mZnNldCkge1xuICAgICAgICBpZiAocGF5bG9hZFN0YXJ0T2Zmc2V0ID4gbGVuKSB7XG4gICAgICAgICAgLy8gdHJpbSBmdWxsIGZyYWcgaWYgUEVTIGhlYWRlciBiaWdnZXIgdGhhbiBmcmFnXG4gICAgICAgICAgcGF5bG9hZFN0YXJ0T2Zmc2V0IC09IGxlbjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0cmltIHBhcnRpYWwgZnJhZyBpZiBQRVMgaGVhZGVyIHNtYWxsZXIgdGhhbiBmcmFnXG4gICAgICAgICAgZnJhZyA9IGZyYWcuc3ViYXJyYXkocGF5bG9hZFN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICBsZW4gLT0gcGF5bG9hZFN0YXJ0T2Zmc2V0O1xuICAgICAgICAgIHBheWxvYWRTdGFydE9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBlc0RhdGEuc2V0KGZyYWcsIGkpO1xuICAgICAgaSArPSBsZW47XG4gICAgfVxuICAgIGlmIChwZXNMZW4pIHtcbiAgICAgIC8vIHBheWxvYWQgc2l6ZSA6IHJlbW92ZSBQRVMgaGVhZGVyICsgUEVTIGV4dGVuc2lvblxuICAgICAgcGVzTGVuIC09IHBlc0hkckxlbiArIDM7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiBwZXNEYXRhLFxuICAgICAgcHRzOiBwZXNQdHMsXG4gICAgICBkdHM6IHBlc0R0cyxcbiAgICAgIGxlbjogcGVzTGVuXG4gICAgfTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiAgQUFDIGhlbHBlclxuICovXG5cbmNsYXNzIEFBQyB7XG4gIHN0YXRpYyBnZXRTaWxlbnRGcmFtZShjb2RlYywgY2hhbm5lbENvdW50KSB7XG4gICAgc3dpdGNoIChjb2RlYykge1xuICAgICAgY2FzZSAnbXA0YS40MC4yJzpcbiAgICAgICAgaWYgKGNoYW5uZWxDb3VudCA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMywgMHg4MF0pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMikge1xuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgyMSwgMHgwMCwgMHg0OSwgMHg5MCwgMHgwMiwgMHgxOSwgMHgwMCwgMHgyMywgMHg4MF0pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMykge1xuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4ZV0pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gNCkge1xuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4MCwgMHgyYywgMHg4MCwgMHgwOCwgMHgwMiwgMHgzOF0pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gNSkge1xuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4MiwgMHgzMCwgMHgwNCwgMHg5OSwgMHgwMCwgMHgyMSwgMHg5MCwgMHgwMiwgMHgzOF0pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gNikge1xuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4MiwgMHgzMCwgMHgwNCwgMHg5OSwgMHgwMCwgMHgyMSwgMHg5MCwgMHgwMiwgMHgwMCwgMHhiMiwgMHgwMCwgMHgyMCwgMHgwOCwgMHhlMF0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gaGFuZGxlIEhFLUFBQyBiZWxvdyAobXA0YS40MC41IC8gbXA0YS40MC4yOSlcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChjaGFubmVsQ291bnQgPT09IDEpIHtcbiAgICAgICAgICAvLyBmZm1wZWcgLXkgLWYgbGF2ZmkgLWkgXCJhZXZhbHNyYz0wOmQ9MC4wNVwiIC1jOmEgbGliZmRrX2FhYyAtcHJvZmlsZTphIGFhY19oZSAtYjphIDRrIG91dHB1dC5hYWMgJiYgaGV4ZHVtcCAtdiAtZSAnMTYvMSBcIjB4JXgsXCIgXCJcXG5cIicgLXYgb3V0cHV0LmFhY1xuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgxLCAweDQwLCAweDIyLCAweDgwLCAweGEzLCAweDRlLCAweGU2LCAweDgwLCAweGJhLCAweDgsIDB4MCwgMHgwLCAweDAsIDB4MWMsIDB4NiwgMHhmMSwgMHhjMSwgMHhhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVlXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAyKSB7XG4gICAgICAgICAgLy8gZmZtcGVnIC15IC1mIGxhdmZpIC1pIFwiYWV2YWxzcmM9MHwwOmQ9MC4wNVwiIC1jOmEgbGliZmRrX2FhYyAtcHJvZmlsZTphIGFhY19oZV92MiAtYjphIDRrIG91dHB1dC5hYWMgJiYgaGV4ZHVtcCAtdiAtZSAnMTYvMSBcIjB4JXgsXCIgXCJcXG5cIicgLXYgb3V0cHV0LmFhY1xuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgxLCAweDQwLCAweDIyLCAweDgwLCAweGEzLCAweDVlLCAweGU2LCAweDgwLCAweGJhLCAweDgsIDB4MCwgMHgwLCAweDAsIDB4MCwgMHg5NSwgMHgwLCAweDYsIDB4ZjEsIDB4YTEsIDB4YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1ZV0pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMykge1xuICAgICAgICAgIC8vIGZmbXBlZyAteSAtZiBsYXZmaSAtaSBcImFldmFsc3JjPTB8MHwwOmQ9MC4wNVwiIC1jOmEgbGliZmRrX2FhYyAtcHJvZmlsZTphIGFhY19oZV92MiAtYjphIDRrIG91dHB1dC5hYWMgJiYgaGV4ZHVtcCAtdiAtZSAnMTYvMSBcIjB4JXgsXCIgXCJcXG5cIicgLXYgb3V0cHV0LmFhY1xuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgxLCAweDQwLCAweDIyLCAweDgwLCAweGEzLCAweDVlLCAweGU2LCAweDgwLCAweGJhLCAweDgsIDB4MCwgMHgwLCAweDAsIDB4MCwgMHg5NSwgMHgwLCAweDYsIDB4ZjEsIDB4YTEsIDB4YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1ZV0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogR2VuZXJhdGUgTVA0IEJveFxuICovXG5cbmNvbnN0IFVJTlQzMl9NQVggPSBNYXRoLnBvdygyLCAzMikgLSAxO1xuY2xhc3MgTVA0IHtcbiAgc3RhdGljIGluaXQoKSB7XG4gICAgTVA0LnR5cGVzID0ge1xuICAgICAgYXZjMTogW10sXG4gICAgICAvLyBjb2RpbmduYW1lXG4gICAgICBhdmNDOiBbXSxcbiAgICAgIGh2YzE6IFtdLFxuICAgICAgaHZjQzogW10sXG4gICAgICBidHJ0OiBbXSxcbiAgICAgIGRpbmY6IFtdLFxuICAgICAgZHJlZjogW10sXG4gICAgICBlc2RzOiBbXSxcbiAgICAgIGZ0eXA6IFtdLFxuICAgICAgaGRscjogW10sXG4gICAgICBtZGF0OiBbXSxcbiAgICAgIG1kaGQ6IFtdLFxuICAgICAgbWRpYTogW10sXG4gICAgICBtZmhkOiBbXSxcbiAgICAgIG1pbmY6IFtdLFxuICAgICAgbW9vZjogW10sXG4gICAgICBtb292OiBbXSxcbiAgICAgIG1wNGE6IFtdLFxuICAgICAgJy5tcDMnOiBbXSxcbiAgICAgIGRhYzM6IFtdLFxuICAgICAgJ2FjLTMnOiBbXSxcbiAgICAgIG12ZXg6IFtdLFxuICAgICAgbXZoZDogW10sXG4gICAgICBwYXNwOiBbXSxcbiAgICAgIHNkdHA6IFtdLFxuICAgICAgc3RibDogW10sXG4gICAgICBzdGNvOiBbXSxcbiAgICAgIHN0c2M6IFtdLFxuICAgICAgc3RzZDogW10sXG4gICAgICBzdHN6OiBbXSxcbiAgICAgIHN0dHM6IFtdLFxuICAgICAgdGZkdDogW10sXG4gICAgICB0ZmhkOiBbXSxcbiAgICAgIHRyYWY6IFtdLFxuICAgICAgdHJhazogW10sXG4gICAgICB0cnVuOiBbXSxcbiAgICAgIHRyZXg6IFtdLFxuICAgICAgdGtoZDogW10sXG4gICAgICB2bWhkOiBbXSxcbiAgICAgIHNtaGQ6IFtdXG4gICAgfTtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgaW4gTVA0LnR5cGVzKSB7XG4gICAgICBpZiAoTVA0LnR5cGVzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgIE1QNC50eXBlc1tpXSA9IFtpLmNoYXJDb2RlQXQoMCksIGkuY2hhckNvZGVBdCgxKSwgaS5jaGFyQ29kZUF0KDIpLCBpLmNoYXJDb2RlQXQoMyldO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB2aWRlb0hkbHIgPSBuZXcgVWludDhBcnJheShbMHgwMCxcbiAgICAvLyB2ZXJzaW9uIDBcbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIGZsYWdzXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBwcmVfZGVmaW5lZFxuICAgIDB4NzYsIDB4NjksIDB4NjQsIDB4NjUsXG4gICAgLy8gaGFuZGxlcl90eXBlOiAndmlkZSdcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDU2LCAweDY5LCAweDY0LCAweDY1LCAweDZmLCAweDQ4LCAweDYxLCAweDZlLCAweDY0LCAweDZjLCAweDY1LCAweDcyLCAweDAwIC8vIG5hbWU6ICdWaWRlb0hhbmRsZXInXG4gICAgXSk7XG4gICAgY29uc3QgYXVkaW9IZGxyID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgLy8gdmVyc2lvbiAwXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcHJlX2RlZmluZWRcbiAgICAweDczLCAweDZmLCAweDc1LCAweDZlLFxuICAgIC8vIGhhbmRsZXJfdHlwZTogJ3NvdW4nXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHg1MywgMHg2ZiwgMHg3NSwgMHg2ZSwgMHg2NCwgMHg0OCwgMHg2MSwgMHg2ZSwgMHg2NCwgMHg2YywgMHg2NSwgMHg3MiwgMHgwMCAvLyBuYW1lOiAnU291bmRIYW5kbGVyJ1xuICAgIF0pO1xuICAgIE1QNC5IRExSX1RZUEVTID0ge1xuICAgICAgdmlkZW86IHZpZGVvSGRscixcbiAgICAgIGF1ZGlvOiBhdWRpb0hkbHJcbiAgICB9O1xuICAgIGNvbnN0IGRyZWYgPSBuZXcgVWludDhBcnJheShbMHgwMCxcbiAgICAvLyB2ZXJzaW9uIDBcbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIGZsYWdzXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSxcbiAgICAvLyBlbnRyeV9jb3VudFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MGMsXG4gICAgLy8gZW50cnlfc2l6ZVxuICAgIDB4NzUsIDB4NzIsIDB4NmMsIDB4MjAsXG4gICAgLy8gJ3VybCcgdHlwZVxuICAgIDB4MDAsXG4gICAgLy8gdmVyc2lvbiAwXG4gICAgMHgwMCwgMHgwMCwgMHgwMSAvLyBlbnRyeV9mbGFnc1xuICAgIF0pO1xuICAgIGNvbnN0IHN0Y28gPSBuZXcgVWludDhBcnJheShbMHgwMCxcbiAgICAvLyB2ZXJzaW9uXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAgLy8gZW50cnlfY291bnRcbiAgICBdKTtcbiAgICBNUDQuU1RUUyA9IE1QNC5TVFNDID0gTVA0LlNUQ08gPSBzdGNvO1xuICAgIE1QNC5TVFNaID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgLy8gdmVyc2lvblxuICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gZmxhZ3NcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHNhbXBsZV9zaXplXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCAvLyBzYW1wbGVfY291bnRcbiAgICBdKTtcbiAgICBNUDQuVk1IRCA9IG5ldyBVaW50OEFycmF5KFsweDAwLFxuICAgIC8vIHZlcnNpb25cbiAgICAweDAwLCAweDAwLCAweDAxLFxuICAgIC8vIGZsYWdzXG4gICAgMHgwMCwgMHgwMCxcbiAgICAvLyBncmFwaGljc21vZGVcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwIC8vIG9wY29sb3JcbiAgICBdKTtcbiAgICBNUDQuU01IRCA9IG5ldyBVaW50OEFycmF5KFsweDAwLFxuICAgIC8vIHZlcnNpb25cbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIGZsYWdzXG4gICAgMHgwMCwgMHgwMCxcbiAgICAvLyBiYWxhbmNlXG4gICAgMHgwMCwgMHgwMCAvLyByZXNlcnZlZFxuICAgIF0pO1xuICAgIE1QNC5TVFNEID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgLy8gdmVyc2lvbiAwXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDFdKTsgLy8gZW50cnlfY291bnRcblxuICAgIGNvbnN0IG1ham9yQnJhbmQgPSBuZXcgVWludDhBcnJheShbMTA1LCAxMTUsIDExMSwgMTA5XSk7IC8vIGlzb21cbiAgICBjb25zdCBhdmMxQnJhbmQgPSBuZXcgVWludDhBcnJheShbOTcsIDExOCwgOTksIDQ5XSk7IC8vIGF2YzFcbiAgICBjb25zdCBtaW5vclZlcnNpb24gPSBuZXcgVWludDhBcnJheShbMCwgMCwgMCwgMV0pO1xuICAgIE1QNC5GVFlQID0gTVA0LmJveChNUDQudHlwZXMuZnR5cCwgbWFqb3JCcmFuZCwgbWlub3JWZXJzaW9uLCBtYWpvckJyYW5kLCBhdmMxQnJhbmQpO1xuICAgIE1QNC5ESU5GID0gTVA0LmJveChNUDQudHlwZXMuZGluZiwgTVA0LmJveChNUDQudHlwZXMuZHJlZiwgZHJlZikpO1xuICB9XG4gIHN0YXRpYyBib3godHlwZSwgLi4ucGF5bG9hZCkge1xuICAgIGxldCBzaXplID0gODtcbiAgICBsZXQgaSA9IHBheWxvYWQubGVuZ3RoO1xuICAgIGNvbnN0IGxlbiA9IGk7XG4gICAgLy8gY2FsY3VsYXRlIHRoZSB0b3RhbCBzaXplIHdlIG5lZWQgdG8gYWxsb2NhdGVcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBzaXplICs9IHBheWxvYWRbaV0uYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgcmVzdWx0WzBdID0gc2l6ZSA+PiAyNCAmIDB4ZmY7XG4gICAgcmVzdWx0WzFdID0gc2l6ZSA+PiAxNiAmIDB4ZmY7XG4gICAgcmVzdWx0WzJdID0gc2l6ZSA+PiA4ICYgMHhmZjtcbiAgICByZXN1bHRbM10gPSBzaXplICYgMHhmZjtcbiAgICByZXN1bHQuc2V0KHR5cGUsIDQpO1xuICAgIC8vIGNvcHkgdGhlIHBheWxvYWQgaW50byB0aGUgcmVzdWx0XG4gICAgZm9yIChpID0gMCwgc2l6ZSA9IDg7IGkgPCBsZW47IGkrKykge1xuICAgICAgLy8gY29weSBwYXlsb2FkW2ldIGFycmF5IEAgb2Zmc2V0IHNpemVcbiAgICAgIHJlc3VsdC5zZXQocGF5bG9hZFtpXSwgc2l6ZSk7XG4gICAgICBzaXplICs9IHBheWxvYWRbaV0uYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBzdGF0aWMgaGRscih0eXBlKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLmhkbHIsIE1QNC5IRExSX1RZUEVTW3R5cGVdKTtcbiAgfVxuICBzdGF0aWMgbWRhdChkYXRhKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1kYXQsIGRhdGEpO1xuICB9XG4gIHN0YXRpYyBtZGhkKHRpbWVzY2FsZSwgZHVyYXRpb24pIHtcbiAgICBkdXJhdGlvbiAqPSB0aW1lc2NhbGU7XG4gICAgY29uc3QgdXBwZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uIC8gKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgY29uc3QgbG93ZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uICUgKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1kaGQsIG5ldyBVaW50OEFycmF5KFsweDAxLFxuICAgIC8vIHZlcnNpb24gMVxuICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gZmxhZ3NcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAyLFxuICAgIC8vIGNyZWF0aW9uX3RpbWVcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAzLFxuICAgIC8vIG1vZGlmaWNhdGlvbl90aW1lXG4gICAgdGltZXNjYWxlID4+IDI0ICYgMHhmZiwgdGltZXNjYWxlID4+IDE2ICYgMHhmZiwgdGltZXNjYWxlID4+IDggJiAweGZmLCB0aW1lc2NhbGUgJiAweGZmLFxuICAgIC8vIHRpbWVzY2FsZVxuICAgIHVwcGVyV29yZER1cmF0aW9uID4+IDI0LCB1cHBlcldvcmREdXJhdGlvbiA+PiAxNiAmIDB4ZmYsIHVwcGVyV29yZER1cmF0aW9uID4+IDggJiAweGZmLCB1cHBlcldvcmREdXJhdGlvbiAmIDB4ZmYsIGxvd2VyV29yZER1cmF0aW9uID4+IDI0LCBsb3dlcldvcmREdXJhdGlvbiA+PiAxNiAmIDB4ZmYsIGxvd2VyV29yZER1cmF0aW9uID4+IDggJiAweGZmLCBsb3dlcldvcmREdXJhdGlvbiAmIDB4ZmYsIDB4NTUsIDB4YzQsXG4gICAgLy8gJ3VuZCcgbGFuZ3VhZ2UgKHVuZGV0ZXJtaW5lZClcbiAgICAweDAwLCAweDAwXSkpO1xuICB9XG4gIHN0YXRpYyBtZGlhKHRyYWNrKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1kaWEsIE1QNC5tZGhkKHRyYWNrLnRpbWVzY2FsZSB8fCAwLCB0cmFjay5kdXJhdGlvbiB8fCAwKSwgTVA0LmhkbHIodHJhY2sudHlwZSksIE1QNC5taW5mKHRyYWNrKSk7XG4gIH1cbiAgc3RhdGljIG1maGQoc2VxdWVuY2VOdW1iZXIpIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWZoZCwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gZmxhZ3NcbiAgICBzZXF1ZW5jZU51bWJlciA+PiAyNCwgc2VxdWVuY2VOdW1iZXIgPj4gMTYgJiAweGZmLCBzZXF1ZW5jZU51bWJlciA+PiA4ICYgMHhmZiwgc2VxdWVuY2VOdW1iZXIgJiAweGZmIC8vIHNlcXVlbmNlX251bWJlclxuICAgIF0pKTtcbiAgfVxuICBzdGF0aWMgbWluZih0cmFjaykge1xuICAgIGlmICh0cmFjay50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWluZiwgTVA0LmJveChNUDQudHlwZXMuc21oZCwgTVA0LlNNSEQpLCBNUDQuRElORiwgTVA0LnN0YmwodHJhY2spKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1pbmYsIE1QNC5ib3goTVA0LnR5cGVzLnZtaGQsIE1QNC5WTUhEKSwgTVA0LkRJTkYsIE1QNC5zdGJsKHRyYWNrKSk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBtb29mKHNuLCBiYXNlTWVkaWFEZWNvZGVUaW1lLCB0cmFjaykge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tb29mLCBNUDQubWZoZChzbiksIE1QNC50cmFmKHRyYWNrLCBiYXNlTWVkaWFEZWNvZGVUaW1lKSk7XG4gIH1cbiAgc3RhdGljIG1vb3YodHJhY2tzKSB7XG4gICAgbGV0IGkgPSB0cmFja3MubGVuZ3RoO1xuICAgIGNvbnN0IGJveGVzID0gW107XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgYm94ZXNbaV0gPSBNUDQudHJhayh0cmFja3NbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gTVA0LmJveC5hcHBseShudWxsLCBbTVA0LnR5cGVzLm1vb3YsIE1QNC5tdmhkKHRyYWNrc1swXS50aW1lc2NhbGUgfHwgMCwgdHJhY2tzWzBdLmR1cmF0aW9uIHx8IDApXS5jb25jYXQoYm94ZXMpLmNvbmNhdChNUDQubXZleCh0cmFja3MpKSk7XG4gIH1cbiAgc3RhdGljIG12ZXgodHJhY2tzKSB7XG4gICAgbGV0IGkgPSB0cmFja3MubGVuZ3RoO1xuICAgIGNvbnN0IGJveGVzID0gW107XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgYm94ZXNbaV0gPSBNUDQudHJleCh0cmFja3NbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gTVA0LmJveC5hcHBseShudWxsLCBbTVA0LnR5cGVzLm12ZXgsIC4uLmJveGVzXSk7XG4gIH1cbiAgc3RhdGljIG12aGQodGltZXNjYWxlLCBkdXJhdGlvbikge1xuICAgIGR1cmF0aW9uICo9IHRpbWVzY2FsZTtcbiAgICBjb25zdCB1cHBlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gLyAoVUlOVDMyX01BWCArIDEpKTtcbiAgICBjb25zdCBsb3dlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gJSAoVUlOVDMyX01BWCArIDEpKTtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KFsweDAxLFxuICAgIC8vIHZlcnNpb24gMVxuICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gZmxhZ3NcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAyLFxuICAgIC8vIGNyZWF0aW9uX3RpbWVcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAzLFxuICAgIC8vIG1vZGlmaWNhdGlvbl90aW1lXG4gICAgdGltZXNjYWxlID4+IDI0ICYgMHhmZiwgdGltZXNjYWxlID4+IDE2ICYgMHhmZiwgdGltZXNjYWxlID4+IDggJiAweGZmLCB0aW1lc2NhbGUgJiAweGZmLFxuICAgIC8vIHRpbWVzY2FsZVxuICAgIHVwcGVyV29yZER1cmF0aW9uID4+IDI0LCB1cHBlcldvcmREdXJhdGlvbiA+PiAxNiAmIDB4ZmYsIHVwcGVyV29yZER1cmF0aW9uID4+IDggJiAweGZmLCB1cHBlcldvcmREdXJhdGlvbiAmIDB4ZmYsIGxvd2VyV29yZER1cmF0aW9uID4+IDI0LCBsb3dlcldvcmREdXJhdGlvbiA+PiAxNiAmIDB4ZmYsIGxvd2VyV29yZER1cmF0aW9uID4+IDggJiAweGZmLCBsb3dlcldvcmREdXJhdGlvbiAmIDB4ZmYsIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsXG4gICAgLy8gMS4wIHJhdGVcbiAgICAweDAxLCAweDAwLFxuICAgIC8vIDEuMCB2b2x1bWVcbiAgICAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAxLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDQwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHRyYW5zZm9ybWF0aW9uOiB1bml0eSBtYXRyaXhcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHByZV9kZWZpbmVkXG4gICAgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiAvLyBuZXh0X3RyYWNrX0lEXG4gICAgXSk7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm12aGQsIGJ5dGVzKTtcbiAgfVxuICBzdGF0aWMgc2R0cCh0cmFjaykge1xuICAgIGNvbnN0IHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzIHx8IFtdO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoNCArIHNhbXBsZXMubGVuZ3RoKTtcbiAgICBsZXQgaTtcbiAgICBsZXQgZmxhZ3M7XG4gICAgLy8gbGVhdmUgdGhlIGZ1bGwgYm94IGhlYWRlciAoNCBieXRlcykgYWxsIHplcm9cbiAgICAvLyB3cml0ZSB0aGUgc2FtcGxlIHRhYmxlXG4gICAgZm9yIChpID0gMDsgaSA8IHNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZsYWdzID0gc2FtcGxlc1tpXS5mbGFncztcbiAgICAgIGJ5dGVzW2kgKyA0XSA9IGZsYWdzLmRlcGVuZHNPbiA8PCA0IHwgZmxhZ3MuaXNEZXBlbmRlZE9uIDw8IDIgfCBmbGFncy5oYXNSZWR1bmRhbmN5O1xuICAgIH1cbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc2R0cCwgYnl0ZXMpO1xuICB9XG4gIHN0YXRpYyBzdGJsKHRyYWNrKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnN0YmwsIE1QNC5zdHNkKHRyYWNrKSwgTVA0LmJveChNUDQudHlwZXMuc3R0cywgTVA0LlNUVFMpLCBNUDQuYm94KE1QNC50eXBlcy5zdHNjLCBNUDQuU1RTQyksIE1QNC5ib3goTVA0LnR5cGVzLnN0c3osIE1QNC5TVFNaKSwgTVA0LmJveChNUDQudHlwZXMuc3RjbywgTVA0LlNUQ08pKTtcbiAgfVxuICBzdGF0aWMgYXZjMSh0cmFjaykge1xuICAgIGxldCBzcHMgPSBbXTtcbiAgICBsZXQgcHBzID0gW107XG4gICAgbGV0IGk7XG4gICAgbGV0IGRhdGE7XG4gICAgbGV0IGxlbjtcbiAgICAvLyBhc3NlbWJsZSB0aGUgU1BTc1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRyYWNrLnNwcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGF0YSA9IHRyYWNrLnNwc1tpXTtcbiAgICAgIGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgIHNwcy5wdXNoKGxlbiA+Pj4gOCAmIDB4ZmYpO1xuICAgICAgc3BzLnB1c2gobGVuICYgMHhmZik7XG5cbiAgICAgIC8vIFNQU1xuICAgICAgc3BzID0gc3BzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkYXRhKSk7XG4gICAgfVxuXG4gICAgLy8gYXNzZW1ibGUgdGhlIFBQU3NcbiAgICBmb3IgKGkgPSAwOyBpIDwgdHJhY2sucHBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkYXRhID0gdHJhY2sucHBzW2ldO1xuICAgICAgbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgcHBzLnB1c2gobGVuID4+PiA4ICYgMHhmZik7XG4gICAgICBwcHMucHVzaChsZW4gJiAweGZmKTtcbiAgICAgIHBwcyA9IHBwcy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBhdmNjID0gTVA0LmJveChNUDQudHlwZXMuYXZjQywgbmV3IFVpbnQ4QXJyYXkoWzB4MDEsXG4gICAgLy8gdmVyc2lvblxuICAgIHNwc1szXSxcbiAgICAvLyBwcm9maWxlXG4gICAgc3BzWzRdLFxuICAgIC8vIHByb2ZpbGUgY29tcGF0XG4gICAgc3BzWzVdLFxuICAgIC8vIGxldmVsXG4gICAgMHhmYyB8IDMsXG4gICAgLy8gbGVuZ3RoU2l6ZU1pbnVzT25lLCBoYXJkLWNvZGVkIHRvIDQgYnl0ZXNcbiAgICAweGUwIHwgdHJhY2suc3BzLmxlbmd0aCAvLyAzYml0IHJlc2VydmVkICgxMTEpICsgbnVtT2ZTZXF1ZW5jZVBhcmFtZXRlclNldHNcbiAgICBdLmNvbmNhdChzcHMpLmNvbmNhdChbdHJhY2sucHBzLmxlbmd0aCAvLyBudW1PZlBpY3R1cmVQYXJhbWV0ZXJTZXRzXG4gICAgXSkuY29uY2F0KHBwcykpKTsgLy8gXCJQUFNcIlxuICAgIGNvbnN0IHdpZHRoID0gdHJhY2sud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gdHJhY2suaGVpZ2h0O1xuICAgIGNvbnN0IGhTcGFjaW5nID0gdHJhY2sucGl4ZWxSYXRpb1swXTtcbiAgICBjb25zdCB2U3BhY2luZyA9IHRyYWNrLnBpeGVsUmF0aW9bMV07XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLmF2YzEsIG5ldyBVaW50OEFycmF5KFsweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDEsXG4gICAgLy8gZGF0YV9yZWZlcmVuY2VfaW5kZXhcbiAgICAweDAwLCAweDAwLFxuICAgIC8vIHByZV9kZWZpbmVkXG4gICAgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcHJlX2RlZmluZWRcbiAgICB3aWR0aCA+PiA4ICYgMHhmZiwgd2lkdGggJiAweGZmLFxuICAgIC8vIHdpZHRoXG4gICAgaGVpZ2h0ID4+IDggJiAweGZmLCBoZWlnaHQgJiAweGZmLFxuICAgIC8vIGhlaWdodFxuICAgIDB4MDAsIDB4NDgsIDB4MDAsIDB4MDAsXG4gICAgLy8gaG9yaXpyZXNvbHV0aW9uXG4gICAgMHgwMCwgMHg0OCwgMHgwMCwgMHgwMCxcbiAgICAvLyB2ZXJ0cmVzb2x1dGlvblxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAxLFxuICAgIC8vIGZyYW1lX2NvdW50XG4gICAgMHgxMiwgMHg2NCwgMHg2MSwgMHg2OSwgMHg2YyxcbiAgICAvLyBkYWlseW1vdGlvbi9obHMuanNcbiAgICAweDc5LCAweDZkLCAweDZmLCAweDc0LCAweDY5LCAweDZmLCAweDZlLCAweDJmLCAweDY4LCAweDZjLCAweDczLCAweDJlLCAweDZhLCAweDczLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIGNvbXByZXNzb3JuYW1lXG4gICAgMHgwMCwgMHgxOCxcbiAgICAvLyBkZXB0aCA9IDI0XG4gICAgMHgxMSwgMHgxMV0pLFxuICAgIC8vIHByZV9kZWZpbmVkID0gLTFcbiAgICBhdmNjLCBNUDQuYm94KE1QNC50eXBlcy5idHJ0LCBuZXcgVWludDhBcnJheShbMHgwMCwgMHgxYywgMHg5YywgMHg4MCxcbiAgICAvLyBidWZmZXJTaXplREJcbiAgICAweDAwLCAweDJkLCAweGM2LCAweGMwLFxuICAgIC8vIG1heEJpdHJhdGVcbiAgICAweDAwLCAweDJkLCAweGM2LCAweGMwXSkpLFxuICAgIC8vIGF2Z0JpdHJhdGVcbiAgICBNUDQuYm94KE1QNC50eXBlcy5wYXNwLCBuZXcgVWludDhBcnJheShbaFNwYWNpbmcgPj4gMjQsXG4gICAgLy8gaFNwYWNpbmdcbiAgICBoU3BhY2luZyA+PiAxNiAmIDB4ZmYsIGhTcGFjaW5nID4+IDggJiAweGZmLCBoU3BhY2luZyAmIDB4ZmYsIHZTcGFjaW5nID4+IDI0LFxuICAgIC8vIHZTcGFjaW5nXG4gICAgdlNwYWNpbmcgPj4gMTYgJiAweGZmLCB2U3BhY2luZyA+PiA4ICYgMHhmZiwgdlNwYWNpbmcgJiAweGZmXSkpKTtcbiAgfVxuICBzdGF0aWMgZXNkcyh0cmFjaykge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRyYWNrLmNvbmZpZztcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgLy8gdmVyc2lvbiAwXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuXG4gICAgMHgwMyxcbiAgICAvLyBkZXNjcmlwdG9yX3R5cGVcbiAgICAweDE5LFxuICAgIC8vIGxlbmd0aFxuXG4gICAgMHgwMCwgMHgwMSxcbiAgICAvLyBlc19pZFxuXG4gICAgMHgwMCxcbiAgICAvLyBzdHJlYW1fcHJpb3JpdHlcblxuICAgIDB4MDQsXG4gICAgLy8gZGVzY3JpcHRvcl90eXBlXG4gICAgMHgxMSxcbiAgICAvLyBsZW5ndGhcbiAgICAweDQwLFxuICAgIC8vIGNvZGVjIDogbXBlZzRfYXVkaW9cbiAgICAweDE1LFxuICAgIC8vIHN0cmVhbV90eXBlXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBidWZmZXJfc2l6ZVxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gbWF4Qml0cmF0ZVxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gYXZnQml0cmF0ZVxuXG4gICAgMHgwNSxcbiAgICAvLyBkZXNjcmlwdG9yX3R5cGVcbiAgICAweDAyLFxuICAgIC8vIGxlbmd0aFxuICAgIC4uLmNvbmZpZywgMHgwNiwgMHgwMSwgMHgwMiAvLyBHQVNwZWNpZmljQ29uZmlnKSk7IC8vIGxlbmd0aCArIGF1ZGlvIGNvbmZpZyBkZXNjcmlwdG9yXG4gICAgXSk7XG4gIH1cbiAgc3RhdGljIGF1ZGlvU3RzZCh0cmFjaykge1xuICAgIGNvbnN0IHNhbXBsZXJhdGUgPSB0cmFjay5zYW1wbGVyYXRlIHx8IDA7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDEsXG4gICAgLy8gZGF0YV9yZWZlcmVuY2VfaW5kZXhcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgdHJhY2suY2hhbm5lbENvdW50IHx8IDAsXG4gICAgLy8gY2hhbm5lbGNvdW50XG4gICAgMHgwMCwgMHgxMCxcbiAgICAvLyBzYW1wbGVTaXplOjE2Yml0c1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWQyXG4gICAgc2FtcGxlcmF0ZSA+PiA4ICYgMHhmZiwgc2FtcGxlcmF0ZSAmIDB4ZmYsXG4gICAgLy9cbiAgICAweDAwLCAweDAwXSk7XG4gIH1cbiAgc3RhdGljIG1wNGEodHJhY2spIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubXA0YSwgTVA0LmF1ZGlvU3RzZCh0cmFjayksIE1QNC5ib3goTVA0LnR5cGVzLmVzZHMsIE1QNC5lc2RzKHRyYWNrKSkpO1xuICB9XG4gIHN0YXRpYyBtcDModHJhY2spIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXNbJy5tcDMnXSwgTVA0LmF1ZGlvU3RzZCh0cmFjaykpO1xuICB9XG4gIHN0YXRpYyBhYzModHJhY2spIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXNbJ2FjLTMnXSwgTVA0LmF1ZGlvU3RzZCh0cmFjayksIE1QNC5ib3goTVA0LnR5cGVzLmRhYzMsIHRyYWNrLmNvbmZpZykpO1xuICB9XG4gIHN0YXRpYyBzdHNkKHRyYWNrKSB7XG4gICAgY29uc3Qge1xuICAgICAgc2VnbWVudENvZGVjXG4gICAgfSA9IHRyYWNrO1xuICAgIGlmICh0cmFjay50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICBpZiAoc2VnbWVudENvZGVjID09PSAnYWFjJykge1xuICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RzZCwgTVA0LlNUU0QsIE1QNC5tcDRhKHRyYWNrKSk7XG4gICAgICB9XG4gICAgICBpZiAoc2VnbWVudENvZGVjID09PSAnYWMzJyAmJiB0cmFjay5jb25maWcpIHtcbiAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnN0c2QsIE1QNC5TVFNELCBNUDQuYWMzKHRyYWNrKSk7XG4gICAgICB9XG4gICAgICBpZiAoc2VnbWVudENvZGVjID09PSAnbXAzJyAmJiB0cmFjay5jb2RlYyA9PT0gJ21wMycpIHtcbiAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnN0c2QsIE1QNC5TVFNELCBNUDQubXAzKHRyYWNrKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0cmFjay5wcHMgJiYgdHJhY2suc3BzKSB7XG4gICAgICAgIGlmIChzZWdtZW50Q29kZWMgPT09ICdhdmMnKSB7XG4gICAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnN0c2QsIE1QNC5TVFNELCBNUDQuYXZjMSh0cmFjaykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWdtZW50Q29kZWMgPT09ICdoZXZjJyAmJiB0cmFjay52cHMpIHtcbiAgICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RzZCwgTVA0LlNUU0QsIE1QNC5odmMxKHRyYWNrKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdmlkZW8gdHJhY2sgbWlzc2luZyBwcHMgb3Igc3BzYCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgJHt0cmFjay50eXBlfSBzZWdtZW50IGNvZGVjICgke3NlZ21lbnRDb2RlY30vJHt0cmFjay5jb2RlY30pYCk7XG4gIH1cbiAgc3RhdGljIHRraGQodHJhY2spIHtcbiAgICBjb25zdCBpZCA9IHRyYWNrLmlkO1xuICAgIGNvbnN0IGR1cmF0aW9uID0gKHRyYWNrLmR1cmF0aW9uIHx8IDApICogKHRyYWNrLnRpbWVzY2FsZSB8fCAwKTtcbiAgICBjb25zdCB3aWR0aCA9IHRyYWNrLndpZHRoIHx8IDA7XG4gICAgY29uc3QgaGVpZ2h0ID0gdHJhY2suaGVpZ2h0IHx8IDA7XG4gICAgY29uc3QgdXBwZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uIC8gKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgY29uc3QgbG93ZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uICUgKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRraGQsIG5ldyBVaW50OEFycmF5KFsweDAxLFxuICAgIC8vIHZlcnNpb24gMVxuICAgIDB4MDAsIDB4MDAsIDB4MDcsXG4gICAgLy8gZmxhZ3NcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAyLFxuICAgIC8vIGNyZWF0aW9uX3RpbWVcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAzLFxuICAgIC8vIG1vZGlmaWNhdGlvbl90aW1lXG4gICAgaWQgPj4gMjQgJiAweGZmLCBpZCA+PiAxNiAmIDB4ZmYsIGlkID4+IDggJiAweGZmLCBpZCAmIDB4ZmYsXG4gICAgLy8gdHJhY2tfSURcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgdXBwZXJXb3JkRHVyYXRpb24gPj4gMjQsIHVwcGVyV29yZER1cmF0aW9uID4+IDE2ICYgMHhmZiwgdXBwZXJXb3JkRHVyYXRpb24gPj4gOCAmIDB4ZmYsIHVwcGVyV29yZER1cmF0aW9uICYgMHhmZiwgbG93ZXJXb3JkRHVyYXRpb24gPj4gMjQsIGxvd2VyV29yZER1cmF0aW9uID4+IDE2ICYgMHhmZiwgbG93ZXJXb3JkRHVyYXRpb24gPj4gOCAmIDB4ZmYsIGxvd2VyV29yZER1cmF0aW9uICYgMHhmZiwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDAsXG4gICAgLy8gbGF5ZXJcbiAgICAweDAwLCAweDAwLFxuICAgIC8vIGFsdGVybmF0ZV9ncm91cFxuICAgIDB4MDAsIDB4MDAsXG4gICAgLy8gbm9uLWF1ZGlvIHRyYWNrIHZvbHVtZVxuICAgIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAxLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDQwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHRyYW5zZm9ybWF0aW9uOiB1bml0eSBtYXRyaXhcbiAgICB3aWR0aCA+PiA4ICYgMHhmZiwgd2lkdGggJiAweGZmLCAweDAwLCAweDAwLFxuICAgIC8vIHdpZHRoXG4gICAgaGVpZ2h0ID4+IDggJiAweGZmLCBoZWlnaHQgJiAweGZmLCAweDAwLCAweDAwIC8vIGhlaWdodFxuICAgIF0pKTtcbiAgfVxuICBzdGF0aWMgdHJhZih0cmFjaywgYmFzZU1lZGlhRGVjb2RlVGltZSkge1xuICAgIGNvbnN0IHNhbXBsZURlcGVuZGVuY3lUYWJsZSA9IE1QNC5zZHRwKHRyYWNrKTtcbiAgICBjb25zdCBpZCA9IHRyYWNrLmlkO1xuICAgIGNvbnN0IHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPSBNYXRoLmZsb29yKGJhc2VNZWRpYURlY29kZVRpbWUgLyAoVUlOVDMyX01BWCArIDEpKTtcbiAgICBjb25zdCBsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID0gTWF0aC5mbG9vcihiYXNlTWVkaWFEZWNvZGVUaW1lICUgKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRyYWYsIE1QNC5ib3goTVA0LnR5cGVzLnRmaGQsIG5ldyBVaW50OEFycmF5KFsweDAwLFxuICAgIC8vIHZlcnNpb24gMFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gZmxhZ3NcbiAgICBpZCA+PiAyNCwgaWQgPj4gMTYgJiAweGZmLCBpZCA+PiA4ICYgMHhmZiwgaWQgJiAweGZmIC8vIHRyYWNrX0lEXG4gICAgXSkpLCBNUDQuYm94KE1QNC50eXBlcy50ZmR0LCBuZXcgVWludDhBcnJheShbMHgwMSxcbiAgICAvLyB2ZXJzaW9uIDFcbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIGZsYWdzXG4gICAgdXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiAyNCwgdXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiAxNiAmIDB4ZmYsIHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gOCAmIDB4ZmYsIHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgJiAweGZmLCBsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDI0LCBsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDE2ICYgMHhmZiwgbG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiA4ICYgMHhmZiwgbG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSAmIDB4ZmZdKSksIE1QNC50cnVuKHRyYWNrLCBzYW1wbGVEZXBlbmRlbmN5VGFibGUubGVuZ3RoICsgMTYgK1xuICAgIC8vIHRmaGRcbiAgICAyMCArXG4gICAgLy8gdGZkdFxuICAgIDggK1xuICAgIC8vIHRyYWYgaGVhZGVyXG4gICAgMTYgK1xuICAgIC8vIG1maGRcbiAgICA4ICtcbiAgICAvLyBtb29mIGhlYWRlclxuICAgIDgpLFxuICAgIC8vIG1kYXQgaGVhZGVyXG4gICAgc2FtcGxlRGVwZW5kZW5jeVRhYmxlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYWNrIGJveC5cbiAgICogQHBhcmFtIHRyYWNrIGEgdHJhY2sgZGVmaW5pdGlvblxuICAgKi9cbiAgc3RhdGljIHRyYWsodHJhY2spIHtcbiAgICB0cmFjay5kdXJhdGlvbiA9IHRyYWNrLmR1cmF0aW9uIHx8IDB4ZmZmZmZmZmY7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRyYWssIE1QNC50a2hkKHRyYWNrKSwgTVA0Lm1kaWEodHJhY2spKTtcbiAgfVxuICBzdGF0aWMgdHJleCh0cmFjaykge1xuICAgIGNvbnN0IGlkID0gdHJhY2suaWQ7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRyZXgsIG5ldyBVaW50OEFycmF5KFsweDAwLFxuICAgIC8vIHZlcnNpb24gMFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gZmxhZ3NcbiAgICBpZCA+PiAyNCwgaWQgPj4gMTYgJiAweGZmLCBpZCA+PiA4ICYgMHhmZiwgaWQgJiAweGZmLFxuICAgIC8vIHRyYWNrX0lEXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSxcbiAgICAvLyBkZWZhdWx0X3NhbXBsZV9kZXNjcmlwdGlvbl9pbmRleFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gZGVmYXVsdF9zYW1wbGVfZHVyYXRpb25cbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIGRlZmF1bHRfc2FtcGxlX3NpemVcbiAgICAweDAwLCAweDAxLCAweDAwLCAweDAxIC8vIGRlZmF1bHRfc2FtcGxlX2ZsYWdzXG4gICAgXSkpO1xuICB9XG4gIHN0YXRpYyB0cnVuKHRyYWNrLCBvZmZzZXQpIHtcbiAgICBjb25zdCBzYW1wbGVzID0gdHJhY2suc2FtcGxlcyB8fCBbXTtcbiAgICBjb25zdCBsZW4gPSBzYW1wbGVzLmxlbmd0aDtcbiAgICBjb25zdCBhcnJheWxlbiA9IDEyICsgMTYgKiBsZW47XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheWxlbik7XG4gICAgbGV0IGk7XG4gICAgbGV0IHNhbXBsZTtcbiAgICBsZXQgZHVyYXRpb247XG4gICAgbGV0IHNpemU7XG4gICAgbGV0IGZsYWdzO1xuICAgIGxldCBjdHM7XG4gICAgb2Zmc2V0ICs9IDggKyBhcnJheWxlbjtcbiAgICBhcnJheS5zZXQoW3RyYWNrLnR5cGUgPT09ICd2aWRlbycgPyAweDAxIDogMHgwMCxcbiAgICAvLyB2ZXJzaW9uIDEgZm9yIHZpZGVvIHdpdGggc2lnbmVkLWludCBzYW1wbGVfY29tcG9zaXRpb25fdGltZV9vZmZzZXRcbiAgICAweDAwLCAweDBmLCAweDAxLFxuICAgIC8vIGZsYWdzXG4gICAgbGVuID4+PiAyNCAmIDB4ZmYsIGxlbiA+Pj4gMTYgJiAweGZmLCBsZW4gPj4+IDggJiAweGZmLCBsZW4gJiAweGZmLFxuICAgIC8vIHNhbXBsZV9jb3VudFxuICAgIG9mZnNldCA+Pj4gMjQgJiAweGZmLCBvZmZzZXQgPj4+IDE2ICYgMHhmZiwgb2Zmc2V0ID4+PiA4ICYgMHhmZiwgb2Zmc2V0ICYgMHhmZiAvLyBkYXRhX29mZnNldFxuICAgIF0sIDApO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgc2FtcGxlID0gc2FtcGxlc1tpXTtcbiAgICAgIGR1cmF0aW9uID0gc2FtcGxlLmR1cmF0aW9uO1xuICAgICAgc2l6ZSA9IHNhbXBsZS5zaXplO1xuICAgICAgZmxhZ3MgPSBzYW1wbGUuZmxhZ3M7XG4gICAgICBjdHMgPSBzYW1wbGUuY3RzO1xuICAgICAgYXJyYXkuc2V0KFtkdXJhdGlvbiA+Pj4gMjQgJiAweGZmLCBkdXJhdGlvbiA+Pj4gMTYgJiAweGZmLCBkdXJhdGlvbiA+Pj4gOCAmIDB4ZmYsIGR1cmF0aW9uICYgMHhmZixcbiAgICAgIC8vIHNhbXBsZV9kdXJhdGlvblxuICAgICAgc2l6ZSA+Pj4gMjQgJiAweGZmLCBzaXplID4+PiAxNiAmIDB4ZmYsIHNpemUgPj4+IDggJiAweGZmLCBzaXplICYgMHhmZixcbiAgICAgIC8vIHNhbXBsZV9zaXplXG4gICAgICBmbGFncy5pc0xlYWRpbmcgPDwgMiB8IGZsYWdzLmRlcGVuZHNPbiwgZmxhZ3MuaXNEZXBlbmRlZE9uIDw8IDYgfCBmbGFncy5oYXNSZWR1bmRhbmN5IDw8IDQgfCBmbGFncy5wYWRkaW5nVmFsdWUgPDwgMSB8IGZsYWdzLmlzTm9uU3luYywgZmxhZ3MuZGVncmFkUHJpbyAmIDB4ZjAgPDwgOCwgZmxhZ3MuZGVncmFkUHJpbyAmIDB4MGYsXG4gICAgICAvLyBzYW1wbGVfZmxhZ3NcbiAgICAgIGN0cyA+Pj4gMjQgJiAweGZmLCBjdHMgPj4+IDE2ICYgMHhmZiwgY3RzID4+PiA4ICYgMHhmZiwgY3RzICYgMHhmZiAvLyBzYW1wbGVfY29tcG9zaXRpb25fdGltZV9vZmZzZXRcbiAgICAgIF0sIDEyICsgMTYgKiBpKTtcbiAgICB9XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRydW4sIGFycmF5KTtcbiAgfVxuICBzdGF0aWMgaW5pdFNlZ21lbnQodHJhY2tzKSB7XG4gICAgaWYgKCFNUDQudHlwZXMpIHtcbiAgICAgIE1QNC5pbml0KCk7XG4gICAgfVxuICAgIGNvbnN0IG1vdmllID0gTVA0Lm1vb3YodHJhY2tzKTtcbiAgICBjb25zdCByZXN1bHQgPSBhcHBlbmRVaW50OEFycmF5KE1QNC5GVFlQLCBtb3ZpZSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBzdGF0aWMgaHZjMSh0cmFjaykge1xuICAgIGNvbnN0IHBzID0gdHJhY2sucGFyYW1zO1xuICAgIGNvbnN0IHVuaXRzID0gW3RyYWNrLnZwcywgdHJhY2suc3BzLCB0cmFjay5wcHNdO1xuICAgIGNvbnN0IE5BTHVMZW5ndGhTaXplID0gNDtcbiAgICBjb25zdCBjb25maWcgPSBuZXcgVWludDhBcnJheShbMHgwMSwgcHMuZ2VuZXJhbF9wcm9maWxlX3NwYWNlIDw8IDYgfCAocHMuZ2VuZXJhbF90aWVyX2ZsYWcgPyAzMiA6IDApIHwgcHMuZ2VuZXJhbF9wcm9maWxlX2lkYywgcHMuZ2VuZXJhbF9wcm9maWxlX2NvbXBhdGliaWxpdHlfZmxhZ3NbMF0sIHBzLmdlbmVyYWxfcHJvZmlsZV9jb21wYXRpYmlsaXR5X2ZsYWdzWzFdLCBwcy5nZW5lcmFsX3Byb2ZpbGVfY29tcGF0aWJpbGl0eV9mbGFnc1syXSwgcHMuZ2VuZXJhbF9wcm9maWxlX2NvbXBhdGliaWxpdHlfZmxhZ3NbM10sIHBzLmdlbmVyYWxfY29uc3RyYWludF9pbmRpY2F0b3JfZmxhZ3NbMF0sIHBzLmdlbmVyYWxfY29uc3RyYWludF9pbmRpY2F0b3JfZmxhZ3NbMV0sIHBzLmdlbmVyYWxfY29uc3RyYWludF9pbmRpY2F0b3JfZmxhZ3NbMl0sIHBzLmdlbmVyYWxfY29uc3RyYWludF9pbmRpY2F0b3JfZmxhZ3NbM10sIHBzLmdlbmVyYWxfY29uc3RyYWludF9pbmRpY2F0b3JfZmxhZ3NbNF0sIHBzLmdlbmVyYWxfY29uc3RyYWludF9pbmRpY2F0b3JfZmxhZ3NbNV0sIHBzLmdlbmVyYWxfbGV2ZWxfaWRjLCAyNDAgfCBwcy5taW5fc3BhdGlhbF9zZWdtZW50YXRpb25faWRjID4+IDgsIDI1NSAmIHBzLm1pbl9zcGF0aWFsX3NlZ21lbnRhdGlvbl9pZGMsIDI1MiB8IHBzLnBhcmFsbGVsaXNtVHlwZSwgMjUyIHwgcHMuY2hyb21hX2Zvcm1hdF9pZGMsIDI0OCB8IHBzLmJpdF9kZXB0aF9sdW1hX21pbnVzOCwgMjQ4IHwgcHMuYml0X2RlcHRoX2Nocm9tYV9taW51czgsIDB4MDAsIHBhcnNlSW50KHBzLmZyYW1lX3JhdGUuZnBzKSwgTkFMdUxlbmd0aFNpemUgLSAxIHwgcHMudGVtcG9yYWxfaWRfbmVzdGVkIDw8IDIgfCBwcy5udW1fdGVtcG9yYWxfbGF5ZXJzIDw8IDMgfCAocHMuZnJhbWVfcmF0ZS5maXhlZCA/IDY0IDogMCksIHVuaXRzLmxlbmd0aF0pO1xuXG4gICAgLy8gY29tcHV0ZSBodmNDIHNpemUgaW4gYnl0ZXNcbiAgICBsZXQgbGVuZ3RoID0gY29uZmlnLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVuaXRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBsZW5ndGggKz0gMztcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdW5pdHNbaV0ubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgbGVuZ3RoICs9IDIgKyB1bml0c1tpXVtqXS5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGh2Y0MgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIGh2Y0Muc2V0KGNvbmZpZywgMCk7XG4gICAgbGVuZ3RoID0gY29uZmlnLmxlbmd0aDtcbiAgICAvLyBhcHBlbmQgcGFyYW1ldGVyIHNldCB1bml0czogb25lIHZwcywgb25lIG9yIG1vcmUgc3BzIGFuZCBwcHNcbiAgICBjb25zdCBpTWF4ID0gdW5pdHMubGVuZ3RoIC0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVuaXRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBodmNDLnNldChuZXcgVWludDhBcnJheShbMzIgKyBpIHwgKGkgPT09IGlNYXggPyAxMjggOiAwKSwgMHgwMCwgdW5pdHNbaV0ubGVuZ3RoXSksIGxlbmd0aCk7XG4gICAgICBsZW5ndGggKz0gMztcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdW5pdHNbaV0ubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgaHZjQy5zZXQobmV3IFVpbnQ4QXJyYXkoW3VuaXRzW2ldW2pdLmxlbmd0aCA+PiA4LCB1bml0c1tpXVtqXS5sZW5ndGggJiAyNTVdKSwgbGVuZ3RoKTtcbiAgICAgICAgbGVuZ3RoICs9IDI7XG4gICAgICAgIGh2Y0Muc2V0KHVuaXRzW2ldW2pdLCBsZW5ndGgpO1xuICAgICAgICBsZW5ndGggKz0gdW5pdHNbaV1bal0ubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBodmNjID0gTVA0LmJveChNUDQudHlwZXMuaHZjQywgaHZjQyk7XG4gICAgY29uc3Qgd2lkdGggPSB0cmFjay53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSB0cmFjay5oZWlnaHQ7XG4gICAgY29uc3QgaFNwYWNpbmcgPSB0cmFjay5waXhlbFJhdGlvWzBdO1xuICAgIGNvbnN0IHZTcGFjaW5nID0gdHJhY2sucGl4ZWxSYXRpb1sxXTtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuaHZjMSwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMSxcbiAgICAvLyBkYXRhX3JlZmVyZW5jZV9pbmRleFxuICAgIDB4MDAsIDB4MDAsXG4gICAgLy8gcHJlX2RlZmluZWRcbiAgICAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBwcmVfZGVmaW5lZFxuICAgIHdpZHRoID4+IDggJiAweGZmLCB3aWR0aCAmIDB4ZmYsXG4gICAgLy8gd2lkdGhcbiAgICBoZWlnaHQgPj4gOCAmIDB4ZmYsIGhlaWdodCAmIDB4ZmYsXG4gICAgLy8gaGVpZ2h0XG4gICAgMHgwMCwgMHg0OCwgMHgwMCwgMHgwMCxcbiAgICAvLyBob3JpenJlc29sdXRpb25cbiAgICAweDAwLCAweDQ4LCAweDAwLCAweDAwLFxuICAgIC8vIHZlcnRyZXNvbHV0aW9uXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDEsXG4gICAgLy8gZnJhbWVfY291bnRcbiAgICAweDEyLCAweDY0LCAweDYxLCAweDY5LCAweDZjLFxuICAgIC8vIGRhaWx5bW90aW9uL2hscy5qc1xuICAgIDB4NzksIDB4NmQsIDB4NmYsIDB4NzQsIDB4NjksIDB4NmYsIDB4NmUsIDB4MmYsIDB4NjgsIDB4NmMsIDB4NzMsIDB4MmUsIDB4NmEsIDB4NzMsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gY29tcHJlc3Nvcm5hbWVcbiAgICAweDAwLCAweDE4LFxuICAgIC8vIGRlcHRoID0gMjRcbiAgICAweDExLCAweDExXSksXG4gICAgLy8gcHJlX2RlZmluZWQgPSAtMVxuICAgIGh2Y2MsIE1QNC5ib3goTVA0LnR5cGVzLmJ0cnQsIG5ldyBVaW50OEFycmF5KFsweDAwLCAweDFjLCAweDljLCAweDgwLFxuICAgIC8vIGJ1ZmZlclNpemVEQlxuICAgIDB4MDAsIDB4MmQsIDB4YzYsIDB4YzAsXG4gICAgLy8gbWF4Qml0cmF0ZVxuICAgIDB4MDAsIDB4MmQsIDB4YzYsIDB4YzBdKSksXG4gICAgLy8gYXZnQml0cmF0ZVxuICAgIE1QNC5ib3goTVA0LnR5cGVzLnBhc3AsIG5ldyBVaW50OEFycmF5KFtoU3BhY2luZyA+PiAyNCxcbiAgICAvLyBoU3BhY2luZ1xuICAgIGhTcGFjaW5nID4+IDE2ICYgMHhmZiwgaFNwYWNpbmcgPj4gOCAmIDB4ZmYsIGhTcGFjaW5nICYgMHhmZiwgdlNwYWNpbmcgPj4gMjQsXG4gICAgLy8gdlNwYWNpbmdcbiAgICB2U3BhY2luZyA+PiAxNiAmIDB4ZmYsIHZTcGFjaW5nID4+IDggJiAweGZmLCB2U3BhY2luZyAmIDB4ZmZdKSkpO1xuICB9XG59XG5NUDQudHlwZXMgPSB2b2lkIDA7XG5NUDQuSERMUl9UWVBFUyA9IHZvaWQgMDtcbk1QNC5TVFRTID0gdm9pZCAwO1xuTVA0LlNUU0MgPSB2b2lkIDA7XG5NUDQuU1RDTyA9IHZvaWQgMDtcbk1QNC5TVFNaID0gdm9pZCAwO1xuTVA0LlZNSEQgPSB2b2lkIDA7XG5NUDQuU01IRCA9IHZvaWQgMDtcbk1QNC5TVFNEID0gdm9pZCAwO1xuTVA0LkZUWVAgPSB2b2lkIDA7XG5NUDQuRElORiA9IHZvaWQgMDtcblxuY29uc3QgTVBFR19UU19DTE9DS19GUkVRX0haID0gOTAwMDA7XG5mdW5jdGlvbiB0b1RpbWVzY2FsZUZyb21CYXNlKGJhc2VUaW1lLCBkZXN0U2NhbGUsIHNyY0Jhc2UgPSAxLCByb3VuZCA9IGZhbHNlKSB7XG4gIGNvbnN0IHJlc3VsdCA9IGJhc2VUaW1lICogZGVzdFNjYWxlICogc3JjQmFzZTsgLy8gZXF1aXZhbGVudCB0byBgKHZhbHVlICogc2NhbGUpIC8gKDEgLyBiYXNlKWBcbiAgcmV0dXJuIHJvdW5kID8gTWF0aC5yb3VuZChyZXN1bHQpIDogcmVzdWx0O1xufVxuZnVuY3Rpb24gdG9UaW1lc2NhbGVGcm9tU2NhbGUoYmFzZVRpbWUsIGRlc3RTY2FsZSwgc3JjU2NhbGUgPSAxLCByb3VuZCA9IGZhbHNlKSB7XG4gIHJldHVybiB0b1RpbWVzY2FsZUZyb21CYXNlKGJhc2VUaW1lLCBkZXN0U2NhbGUsIDEgLyBzcmNTY2FsZSwgcm91bmQpO1xufVxuZnVuY3Rpb24gdG9Nc0Zyb21NcGVnVHNDbG9jayhiYXNlVGltZSwgcm91bmQgPSBmYWxzZSkge1xuICByZXR1cm4gdG9UaW1lc2NhbGVGcm9tQmFzZShiYXNlVGltZSwgMTAwMCwgMSAvIE1QRUdfVFNfQ0xPQ0tfRlJFUV9IWiwgcm91bmQpO1xufVxuZnVuY3Rpb24gdG9NcGVnVHNDbG9ja0Zyb21UaW1lc2NhbGUoYmFzZVRpbWUsIHNyY1NjYWxlID0gMSkge1xuICByZXR1cm4gdG9UaW1lc2NhbGVGcm9tQmFzZShiYXNlVGltZSwgTVBFR19UU19DTE9DS19GUkVRX0haLCAxIC8gc3JjU2NhbGUpO1xufVxuXG5jb25zdCBNQVhfU0lMRU5UX0ZSQU1FX0RVUkFUSU9OID0gMTAgKiAxMDAwOyAvLyAxMCBzZWNvbmRzXG5jb25zdCBBQUNfU0FNUExFU19QRVJfRlJBTUUgPSAxMDI0O1xuY29uc3QgTVBFR19BVURJT19TQU1QTEVfUEVSX0ZSQU1FID0gMTE1MjtcbmNvbnN0IEFDM19TQU1QTEVTX1BFUl9GUkFNRSA9IDE1MzY7XG5sZXQgY2hyb21lVmVyc2lvbiA9IG51bGw7XG5sZXQgc2FmYXJpV2Via2l0VmVyc2lvbiA9IG51bGw7XG5mdW5jdGlvbiBjcmVhdGVNcDRTYW1wbGUoaXNLZXlmcmFtZSwgZHVyYXRpb24sIHNpemUsIGN0cykge1xuICByZXR1cm4ge1xuICAgIGR1cmF0aW9uLFxuICAgIHNpemUsXG4gICAgY3RzLFxuICAgIGZsYWdzOiB7XG4gICAgICBpc0xlYWRpbmc6IDAsXG4gICAgICBpc0RlcGVuZGVkT246IDAsXG4gICAgICBoYXNSZWR1bmRhbmN5OiAwLFxuICAgICAgZGVncmFkUHJpbzogMCxcbiAgICAgIGRlcGVuZHNPbjogaXNLZXlmcmFtZSA/IDIgOiAxLFxuICAgICAgaXNOb25TeW5jOiBpc0tleWZyYW1lID8gMCA6IDFcbiAgICB9XG4gIH07XG59XG5jbGFzcyBNUDRSZW11eGVyIGV4dGVuZHMgTG9nZ2VyIHtcbiAgY29uc3RydWN0b3Iob2JzZXJ2ZXIsIGNvbmZpZywgdHlwZVN1cHBvcnRlZCwgbG9nZ2VyKSB7XG4gICAgc3VwZXIoJ21wNC1yZW11eGVyJywgbG9nZ2VyKTtcbiAgICB0aGlzLm9ic2VydmVyID0gdm9pZCAwO1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHZvaWQgMDtcbiAgICB0aGlzLklTR2VuZXJhdGVkID0gZmFsc2U7XG4gICAgdGhpcy5faW5pdFBUUyA9IG51bGw7XG4gICAgdGhpcy5faW5pdERUUyA9IG51bGw7XG4gICAgdGhpcy5uZXh0VmlkZW9UcyA9IG51bGw7XG4gICAgdGhpcy5uZXh0QXVkaW9UcyA9IG51bGw7XG4gICAgdGhpcy52aWRlb1NhbXBsZUR1cmF0aW9uID0gbnVsbDtcbiAgICB0aGlzLmlzQXVkaW9Db250aWd1b3VzID0gZmFsc2U7XG4gICAgdGhpcy5pc1ZpZGVvQ29udGlndW91cyA9IGZhbHNlO1xuICAgIHRoaXMudmlkZW9UcmFja0NvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy50eXBlU3VwcG9ydGVkID0gdHlwZVN1cHBvcnRlZDtcbiAgICB0aGlzLklTR2VuZXJhdGVkID0gZmFsc2U7XG4gICAgaWYgKGNocm9tZVZlcnNpb24gPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQgfHwgJyc7XG4gICAgICBjb25zdCByZXN1bHQgPSB1c2VyQWdlbnQubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS9pKTtcbiAgICAgIGNocm9tZVZlcnNpb24gPSByZXN1bHQgPyBwYXJzZUludChyZXN1bHRbMV0pIDogMDtcbiAgICB9XG4gICAgaWYgKHNhZmFyaVdlYmtpdFZlcnNpb24gPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1NhZmFyaVxcLyhcXGQrKS9pKTtcbiAgICAgIHNhZmFyaVdlYmtpdFZlcnNpb24gPSByZXN1bHQgPyBwYXJzZUludChyZXN1bHRbMV0pIDogMDtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5jb25maWcgPSB0aGlzLnZpZGVvVHJhY2tDb25maWcgPSB0aGlzLl9pbml0UFRTID0gdGhpcy5faW5pdERUUyA9IG51bGw7XG4gIH1cbiAgcmVzZXRUaW1lU3RhbXAoZGVmYXVsdFRpbWVTdGFtcCkge1xuICAgIHRoaXMubG9nKCdpbml0UFRTICYgaW5pdERUUyByZXNldCcpO1xuICAgIHRoaXMuX2luaXRQVFMgPSB0aGlzLl9pbml0RFRTID0gZGVmYXVsdFRpbWVTdGFtcDtcbiAgfVxuICByZXNldE5leHRUaW1lc3RhbXAoKSB7XG4gICAgdGhpcy5sb2coJ3Jlc2V0IG5leHQgdGltZXN0YW1wJyk7XG4gICAgdGhpcy5pc1ZpZGVvQ29udGlndW91cyA9IGZhbHNlO1xuICAgIHRoaXMuaXNBdWRpb0NvbnRpZ3VvdXMgPSBmYWxzZTtcbiAgfVxuICByZXNldEluaXRTZWdtZW50KCkge1xuICAgIHRoaXMubG9nKCdJU0dlbmVyYXRlZCBmbGFnIHJlc2V0Jyk7XG4gICAgdGhpcy5JU0dlbmVyYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMudmlkZW9UcmFja0NvbmZpZyA9IHVuZGVmaW5lZDtcbiAgfVxuICBnZXRWaWRlb1N0YXJ0UHRzKHZpZGVvU2FtcGxlcykge1xuICAgIC8vIEdldCB0aGUgbWluaW11bSBQVFMgdmFsdWUgcmVsYXRpdmUgdG8gdGhlIGZpcnN0IHNhbXBsZSdzIFBUUywgbm9ybWFsaXplZCBmb3IgMzMtYml0IHdyYXBwaW5nXG4gICAgbGV0IHJvbGxvdmVyRGV0ZWN0ZWQgPSBmYWxzZTtcbiAgICBjb25zdCBmaXJzdFB0cyA9IHZpZGVvU2FtcGxlc1swXS5wdHM7XG4gICAgY29uc3Qgc3RhcnRQVFMgPSB2aWRlb1NhbXBsZXMucmVkdWNlKChtaW5QVFMsIHNhbXBsZSkgPT4ge1xuICAgICAgbGV0IHB0cyA9IHNhbXBsZS5wdHM7XG4gICAgICBsZXQgZGVsdGEgPSBwdHMgLSBtaW5QVFM7XG4gICAgICBpZiAoZGVsdGEgPCAtNDI5NDk2NzI5Nikge1xuICAgICAgICAvLyAyXjMyLCBzZWUgUFRTTm9ybWFsaXplIGZvciByZWFzb25pbmcsIGJ1dCB3ZSdyZSBoaXR0aW5nIGEgcm9sbG92ZXIgaGVyZSwgYW5kIHdlIGRvbid0IHdhbnQgdGhhdCB0byBpbXBhY3QgdGhlIHRpbWVPZmZzZXQgY2FsY3VsYXRpb25cbiAgICAgICAgcm9sbG92ZXJEZXRlY3RlZCA9IHRydWU7XG4gICAgICAgIHB0cyA9IG5vcm1hbGl6ZVB0cyhwdHMsIGZpcnN0UHRzKTtcbiAgICAgICAgZGVsdGEgPSBwdHMgLSBtaW5QVFM7XG4gICAgICB9XG4gICAgICBpZiAoZGVsdGEgPiAwKSB7XG4gICAgICAgIHJldHVybiBtaW5QVFM7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHRzO1xuICAgIH0sIGZpcnN0UHRzKTtcbiAgICBpZiAocm9sbG92ZXJEZXRlY3RlZCkge1xuICAgICAgdGhpcy5kZWJ1ZygnUFRTIHJvbGxvdmVyIGRldGVjdGVkJyk7XG4gICAgfVxuICAgIHJldHVybiBzdGFydFBUUztcbiAgfVxuICByZW11eChhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGZsdXNoLCBwbGF5bGlzdFR5cGUpIHtcbiAgICBsZXQgdmlkZW87XG4gICAgbGV0IGF1ZGlvO1xuICAgIGxldCBpbml0U2VnbWVudDtcbiAgICBsZXQgdGV4dDtcbiAgICBsZXQgaWQzO1xuICAgIGxldCBpbmRlcGVuZGVudDtcbiAgICBsZXQgYXVkaW9UaW1lT2Zmc2V0ID0gdGltZU9mZnNldDtcbiAgICBsZXQgdmlkZW9UaW1lT2Zmc2V0ID0gdGltZU9mZnNldDtcblxuICAgIC8vIElmIHdlJ3JlIHJlbXV4aW5nIGF1ZGlvIGFuZCB2aWRlbyBwcm9ncmVzc2l2ZWx5LCB3YWl0IHVudGlsIHdlJ3ZlIHJlY2VpdmVkIGVub3VnaCBzYW1wbGVzIGZvciBlYWNoIHRyYWNrIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAgIC8vIFRoaXMgaXMgZG9uZSB0byBzeW5jaHJvbml6ZSB0aGUgYXVkaW8gYW5kIHZpZGVvIHN0cmVhbXMuIFdlIGtub3cgaWYgdGhlIGN1cnJlbnQgc2VnbWVudCB3aWxsIGhhdmUgc2FtcGxlcyBpZiB0aGUgXCJwaWRcIlxuICAgIC8vIHBhcmFtZXRlciBpcyBncmVhdGVyIHRoYW4gLTEuIFRoZSBwaWQgaXMgc2V0IHdoZW4gdGhlIFBNVCBpcyBwYXJzZWQsIHdoaWNoIGNvbnRhaW5zIHRoZSB0cmFja3MgbGlzdC5cbiAgICAvLyBIb3dldmVyLCBpZiB0aGUgaW5pdFNlZ21lbnQgaGFzIGFscmVhZHkgYmVlbiBnZW5lcmF0ZWQsIG9yIHdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiBhIHNlZ21lbnQgKGZsdXNoKSxcbiAgICAvLyB0aGVuIHdlIGNhbiByZW11eCBvbmUgdHJhY2sgd2l0aG91dCB3YWl0aW5nIGZvciB0aGUgb3RoZXIuXG4gICAgY29uc3QgaGFzQXVkaW8gPSBhdWRpb1RyYWNrLnBpZCA+IC0xO1xuICAgIGNvbnN0IGhhc1ZpZGVvID0gdmlkZW9UcmFjay5waWQgPiAtMTtcbiAgICBjb25zdCBsZW5ndGggPSB2aWRlb1RyYWNrLnNhbXBsZXMubGVuZ3RoO1xuICAgIGNvbnN0IGVub3VnaEF1ZGlvU2FtcGxlcyA9IGF1ZGlvVHJhY2suc2FtcGxlcy5sZW5ndGggPiAwO1xuICAgIGNvbnN0IGVub3VnaFZpZGVvU2FtcGxlcyA9IGZsdXNoICYmIGxlbmd0aCA+IDAgfHwgbGVuZ3RoID4gMTtcbiAgICBjb25zdCBjYW5SZW11eEF2YyA9ICghaGFzQXVkaW8gfHwgZW5vdWdoQXVkaW9TYW1wbGVzKSAmJiAoIWhhc1ZpZGVvIHx8IGVub3VnaFZpZGVvU2FtcGxlcykgfHwgdGhpcy5JU0dlbmVyYXRlZCB8fCBmbHVzaDtcbiAgICBpZiAoY2FuUmVtdXhBdmMpIHtcbiAgICAgIGlmICh0aGlzLklTR2VuZXJhdGVkKSB7XG4gICAgICAgIHZhciBfdmlkZW9UcmFjayRwaXhlbFJhdGksIF9jb25maWckcGl4ZWxSYXRpbywgX3ZpZGVvVHJhY2skcGl4ZWxSYXRpMiwgX2NvbmZpZyRwaXhlbFJhdGlvMjtcbiAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy52aWRlb1RyYWNrQ29uZmlnO1xuICAgICAgICBpZiAoY29uZmlnICYmICh2aWRlb1RyYWNrLndpZHRoICE9PSBjb25maWcud2lkdGggfHwgdmlkZW9UcmFjay5oZWlnaHQgIT09IGNvbmZpZy5oZWlnaHQgfHwgKChfdmlkZW9UcmFjayRwaXhlbFJhdGkgPSB2aWRlb1RyYWNrLnBpeGVsUmF0aW8pID09IG51bGwgPyB2b2lkIDAgOiBfdmlkZW9UcmFjayRwaXhlbFJhdGlbMF0pICE9PSAoKF9jb25maWckcGl4ZWxSYXRpbyA9IGNvbmZpZy5waXhlbFJhdGlvKSA9PSBudWxsID8gdm9pZCAwIDogX2NvbmZpZyRwaXhlbFJhdGlvWzBdKSB8fCAoKF92aWRlb1RyYWNrJHBpeGVsUmF0aTIgPSB2aWRlb1RyYWNrLnBpeGVsUmF0aW8pID09IG51bGwgPyB2b2lkIDAgOiBfdmlkZW9UcmFjayRwaXhlbFJhdGkyWzFdKSAhPT0gKChfY29uZmlnJHBpeGVsUmF0aW8yID0gY29uZmlnLnBpeGVsUmF0aW8pID09IG51bGwgPyB2b2lkIDAgOiBfY29uZmlnJHBpeGVsUmF0aW8yWzFdKSkgfHwgIWNvbmZpZyAmJiBlbm91Z2hWaWRlb1NhbXBsZXMgfHwgdGhpcy5uZXh0QXVkaW9UcyA9PT0gbnVsbCAmJiBlbm91Z2hBdWRpb1NhbXBsZXMpIHtcbiAgICAgICAgICB0aGlzLnJlc2V0SW5pdFNlZ21lbnQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLklTR2VuZXJhdGVkKSB7XG4gICAgICAgIGluaXRTZWdtZW50ID0gdGhpcy5nZW5lcmF0ZUlTKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgICB9XG4gICAgICBjb25zdCBpc1ZpZGVvQ29udGlndW91cyA9IHRoaXMuaXNWaWRlb0NvbnRpZ3VvdXM7XG4gICAgICBsZXQgZmlyc3RLZXlGcmFtZUluZGV4ID0gLTE7XG4gICAgICBsZXQgZmlyc3RLZXlGcmFtZVBUUztcbiAgICAgIGlmIChlbm91Z2hWaWRlb1NhbXBsZXMpIHtcbiAgICAgICAgZmlyc3RLZXlGcmFtZUluZGV4ID0gZmluZEtleWZyYW1lSW5kZXgodmlkZW9UcmFjay5zYW1wbGVzKTtcbiAgICAgICAgaWYgKCFpc1ZpZGVvQ29udGlndW91cyAmJiB0aGlzLmNvbmZpZy5mb3JjZUtleUZyYW1lT25EaXNjb250aW51aXR5KSB7XG4gICAgICAgICAgaW5kZXBlbmRlbnQgPSB0cnVlO1xuICAgICAgICAgIGlmIChmaXJzdEtleUZyYW1lSW5kZXggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLndhcm4oYERyb3BwZWQgJHtmaXJzdEtleUZyYW1lSW5kZXh9IG91dCBvZiAke2xlbmd0aH0gdmlkZW8gc2FtcGxlcyBkdWUgdG8gYSBtaXNzaW5nIGtleWZyYW1lYCk7XG4gICAgICAgICAgICBjb25zdCBzdGFydFBUUyA9IHRoaXMuZ2V0VmlkZW9TdGFydFB0cyh2aWRlb1RyYWNrLnNhbXBsZXMpO1xuICAgICAgICAgICAgdmlkZW9UcmFjay5zYW1wbGVzID0gdmlkZW9UcmFjay5zYW1wbGVzLnNsaWNlKGZpcnN0S2V5RnJhbWVJbmRleCk7XG4gICAgICAgICAgICB2aWRlb1RyYWNrLmRyb3BwZWQgKz0gZmlyc3RLZXlGcmFtZUluZGV4O1xuICAgICAgICAgICAgdmlkZW9UaW1lT2Zmc2V0ICs9ICh2aWRlb1RyYWNrLnNhbXBsZXNbMF0ucHRzIC0gc3RhcnRQVFMpIC8gdmlkZW9UcmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICAgICAgICAgIGZpcnN0S2V5RnJhbWVQVFMgPSB2aWRlb1RpbWVPZmZzZXQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChmaXJzdEtleUZyYW1lSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLndhcm4oYE5vIGtleWZyYW1lIGZvdW5kIG91dCBvZiAke2xlbmd0aH0gdmlkZW8gc2FtcGxlc2ApO1xuICAgICAgICAgICAgaW5kZXBlbmRlbnQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLklTR2VuZXJhdGVkKSB7XG4gICAgICAgIGlmIChlbm91Z2hBdWRpb1NhbXBsZXMgJiYgZW5vdWdoVmlkZW9TYW1wbGVzKSB7XG4gICAgICAgICAgLy8gdGltZU9mZnNldCBpcyBleHBlY3RlZCB0byBiZSB0aGUgb2Zmc2V0IG9mIHRoZSBmaXJzdCB0aW1lc3RhbXAgb2YgdGhpcyBmcmFnbWVudCAoZmlyc3QgRFRTKVxuICAgICAgICAgIC8vIGlmIGZpcnN0IGF1ZGlvIERUUyBpcyBub3QgYWxpZ25lZCB3aXRoIGZpcnN0IHZpZGVvIERUUyB0aGVuIHdlIG5lZWQgdG8gdGFrZSB0aGF0IGludG8gYWNjb3VudFxuICAgICAgICAgIC8vIHdoZW4gcHJvdmlkaW5nIHRpbWVPZmZzZXQgdG8gcmVtdXhBdWRpbyAvIHJlbXV4VmlkZW8uIGlmIHdlIGRvbid0IGRvIHRoYXQsIHRoZXJlIG1pZ2h0IGJlIGEgcGVybWFuZW50IC8gc21hbGxcbiAgICAgICAgICAvLyBkcmlmdCBiZXR3ZWVuIGF1ZGlvIGFuZCB2aWRlbyBzdHJlYW1zXG4gICAgICAgICAgY29uc3Qgc3RhcnRQVFMgPSB0aGlzLmdldFZpZGVvU3RhcnRQdHModmlkZW9UcmFjay5zYW1wbGVzKTtcbiAgICAgICAgICBjb25zdCB0c0RlbHRhID0gbm9ybWFsaXplUHRzKGF1ZGlvVHJhY2suc2FtcGxlc1swXS5wdHMsIHN0YXJ0UFRTKSAtIHN0YXJ0UFRTO1xuICAgICAgICAgIGNvbnN0IGF1ZGlvdmlkZW9UaW1lc3RhbXBEZWx0YSA9IHRzRGVsdGEgLyB2aWRlb1RyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgICAgICAgIGF1ZGlvVGltZU9mZnNldCArPSBNYXRoLm1heCgwLCBhdWRpb3ZpZGVvVGltZXN0YW1wRGVsdGEpO1xuICAgICAgICAgIHZpZGVvVGltZU9mZnNldCArPSBNYXRoLm1heCgwLCAtYXVkaW92aWRlb1RpbWVzdGFtcERlbHRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFB1cnBvc2VmdWxseSByZW11eGluZyBhdWRpbyBiZWZvcmUgdmlkZW8sIHNvIHRoYXQgcmVtdXhWaWRlbyBjYW4gdXNlIG5leHRBdWRpb1B0cywgd2hpY2ggaXMgY2FsY3VsYXRlZCBpbiByZW11eEF1ZGlvLlxuICAgICAgICBpZiAoZW5vdWdoQXVkaW9TYW1wbGVzKSB7XG4gICAgICAgICAgLy8gaWYgaW5pdFNlZ21lbnQgd2FzIGdlbmVyYXRlZCB3aXRob3V0IGF1ZGlvIHNhbXBsZXMsIHJlZ2VuZXJhdGUgaXQgYWdhaW5cbiAgICAgICAgICBpZiAoIWF1ZGlvVHJhY2suc2FtcGxlcmF0ZSkge1xuICAgICAgICAgICAgdGhpcy53YXJuKCdyZWdlbmVyYXRlIEluaXRTZWdtZW50IGFzIGF1ZGlvIGRldGVjdGVkJyk7XG4gICAgICAgICAgICBpbml0U2VnbWVudCA9IHRoaXMuZ2VuZXJhdGVJUyhhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhdWRpbyA9IHRoaXMucmVtdXhBdWRpbyhhdWRpb1RyYWNrLCBhdWRpb1RpbWVPZmZzZXQsIHRoaXMuaXNBdWRpb0NvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCwgaGFzVmlkZW8gfHwgZW5vdWdoVmlkZW9TYW1wbGVzIHx8IHBsYXlsaXN0VHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuQVVESU8gPyB2aWRlb1RpbWVPZmZzZXQgOiB1bmRlZmluZWQpO1xuICAgICAgICAgIGlmIChlbm91Z2hWaWRlb1NhbXBsZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGF1ZGlvVHJhY2tMZW5ndGggPSBhdWRpbyA/IGF1ZGlvLmVuZFBUUyAtIGF1ZGlvLnN0YXJ0UFRTIDogMDtcbiAgICAgICAgICAgIC8vIGlmIGluaXRTZWdtZW50IHdhcyBnZW5lcmF0ZWQgd2l0aG91dCB2aWRlbyBzYW1wbGVzLCByZWdlbmVyYXRlIGl0IGFnYWluXG4gICAgICAgICAgICBpZiAoIXZpZGVvVHJhY2suaW5wdXRUaW1lU2NhbGUpIHtcbiAgICAgICAgICAgICAgdGhpcy53YXJuKCdyZWdlbmVyYXRlIEluaXRTZWdtZW50IGFzIHZpZGVvIGRldGVjdGVkJyk7XG4gICAgICAgICAgICAgIGluaXRTZWdtZW50ID0gdGhpcy5nZW5lcmF0ZUlTKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2aWRlbyA9IHRoaXMucmVtdXhWaWRlbyh2aWRlb1RyYWNrLCB2aWRlb1RpbWVPZmZzZXQsIGlzVmlkZW9Db250aWd1b3VzLCBhdWRpb1RyYWNrTGVuZ3RoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZW5vdWdoVmlkZW9TYW1wbGVzKSB7XG4gICAgICAgICAgdmlkZW8gPSB0aGlzLnJlbXV4VmlkZW8odmlkZW9UcmFjaywgdmlkZW9UaW1lT2Zmc2V0LCBpc1ZpZGVvQ29udGlndW91cywgMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpZGVvKSB7XG4gICAgICAgICAgdmlkZW8uZmlyc3RLZXlGcmFtZSA9IGZpcnN0S2V5RnJhbWVJbmRleDtcbiAgICAgICAgICB2aWRlby5pbmRlcGVuZGVudCA9IGZpcnN0S2V5RnJhbWVJbmRleCAhPT0gLTE7XG4gICAgICAgICAgdmlkZW8uZmlyc3RLZXlGcmFtZVBUUyA9IGZpcnN0S2V5RnJhbWVQVFM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbGxvdyBJRDMgYW5kIHRleHQgdG8gcmVtdXgsIGV2ZW4gaWYgbW9yZSBhdWRpby92aWRlbyBzYW1wbGVzIGFyZSByZXF1aXJlZFxuICAgIGlmICh0aGlzLklTR2VuZXJhdGVkICYmIHRoaXMuX2luaXRQVFMgJiYgdGhpcy5faW5pdERUUykge1xuICAgICAgaWYgKGlkM1RyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgIGlkMyA9IGZsdXNoVGV4dFRyYWNrTWV0YWRhdGFDdWVTYW1wbGVzKGlkM1RyYWNrLCB0aW1lT2Zmc2V0LCB0aGlzLl9pbml0UFRTLCB0aGlzLl9pbml0RFRTKTtcbiAgICAgIH1cbiAgICAgIGlmICh0ZXh0VHJhY2suc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgdGV4dCA9IGZsdXNoVGV4dFRyYWNrVXNlcmRhdGFDdWVTYW1wbGVzKHRleHRUcmFjaywgdGltZU9mZnNldCwgdGhpcy5faW5pdFBUUyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBhdWRpbyxcbiAgICAgIHZpZGVvLFxuICAgICAgaW5pdFNlZ21lbnQsXG4gICAgICBpbmRlcGVuZGVudCxcbiAgICAgIHRleHQsXG4gICAgICBpZDNcbiAgICB9O1xuICB9XG4gIGdlbmVyYXRlSVMoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgY29uc3QgYXVkaW9TYW1wbGVzID0gYXVkaW9UcmFjay5zYW1wbGVzO1xuICAgIGNvbnN0IHZpZGVvU2FtcGxlcyA9IHZpZGVvVHJhY2suc2FtcGxlcztcbiAgICBjb25zdCB0eXBlU3VwcG9ydGVkID0gdGhpcy50eXBlU3VwcG9ydGVkO1xuICAgIGNvbnN0IHRyYWNrcyA9IHt9O1xuICAgIGNvbnN0IF9pbml0UFRTID0gdGhpcy5faW5pdFBUUztcbiAgICBsZXQgY29tcHV0ZVBUU0RUUyA9ICFfaW5pdFBUUyB8fCBhY2N1cmF0ZVRpbWVPZmZzZXQ7XG4gICAgbGV0IGNvbnRhaW5lciA9ICdhdWRpby9tcDQnO1xuICAgIGxldCBpbml0UFRTO1xuICAgIGxldCBpbml0RFRTO1xuICAgIGxldCB0aW1lc2NhbGU7XG4gICAgbGV0IHRyYWNrSWQ7XG4gICAgaWYgKGNvbXB1dGVQVFNEVFMpIHtcbiAgICAgIGluaXRQVFMgPSBpbml0RFRTID0gSW5maW5pdHk7XG4gICAgfVxuICAgIGlmIChhdWRpb1RyYWNrLmNvbmZpZyAmJiBhdWRpb1NhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAvLyBsZXQncyB1c2UgYXVkaW8gc2FtcGxpbmcgcmF0ZSBhcyBNUDQgdGltZSBzY2FsZS5cbiAgICAgIC8vIHJhdGlvbmFsZSBpcyB0aGF0IHRoZXJlIGlzIGEgaW50ZWdlciBuYiBvZiBhdWRpbyBmcmFtZXMgcGVyIGF1ZGlvIHNhbXBsZSAoMTAyNCBmb3IgQUFDKVxuICAgICAgLy8gdXNpbmcgYXVkaW8gc2FtcGxpbmcgcmF0ZSBoZXJlIGhlbHBzIGhhdmluZyBhbiBpbnRlZ2VyIE1QNCBmcmFtZSBkdXJhdGlvblxuICAgICAgLy8gdGhpcyBhdm9pZHMgcG90ZW50aWFsIHJvdW5kaW5nIGlzc3VlIGFuZCBBViBzeW5jIGlzc3VlXG4gICAgICBhdWRpb1RyYWNrLnRpbWVzY2FsZSA9IGF1ZGlvVHJhY2suc2FtcGxlcmF0ZTtcbiAgICAgIHN3aXRjaCAoYXVkaW9UcmFjay5zZWdtZW50Q29kZWMpIHtcbiAgICAgICAgY2FzZSAnbXAzJzpcbiAgICAgICAgICBpZiAodHlwZVN1cHBvcnRlZC5tcGVnKSB7XG4gICAgICAgICAgICAvLyBDaHJvbWUgYW5kIFNhZmFyaVxuICAgICAgICAgICAgY29udGFpbmVyID0gJ2F1ZGlvL21wZWcnO1xuICAgICAgICAgICAgYXVkaW9UcmFjay5jb2RlYyA9ICcnO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZVN1cHBvcnRlZC5tcDMpIHtcbiAgICAgICAgICAgIC8vIEZpcmVmb3hcbiAgICAgICAgICAgIGF1ZGlvVHJhY2suY29kZWMgPSAnbXAzJztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2FjMyc6XG4gICAgICAgICAgYXVkaW9UcmFjay5jb2RlYyA9ICdhYy0zJztcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRyYWNrcy5hdWRpbyA9IHtcbiAgICAgICAgaWQ6ICdhdWRpbycsXG4gICAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgICBjb2RlYzogYXVkaW9UcmFjay5jb2RlYyxcbiAgICAgICAgaW5pdFNlZ21lbnQ6IGF1ZGlvVHJhY2suc2VnbWVudENvZGVjID09PSAnbXAzJyAmJiB0eXBlU3VwcG9ydGVkLm1wZWcgPyBuZXcgVWludDhBcnJheSgwKSA6IE1QNC5pbml0U2VnbWVudChbYXVkaW9UcmFja10pLFxuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIGNoYW5uZWxDb3VudDogYXVkaW9UcmFjay5jaGFubmVsQ291bnRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XG4gICAgICAgIHRyYWNrSWQgPSBhdWRpb1RyYWNrLmlkO1xuICAgICAgICB0aW1lc2NhbGUgPSBhdWRpb1RyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgICAgICBpZiAoIV9pbml0UFRTIHx8IHRpbWVzY2FsZSAhPT0gX2luaXRQVFMudGltZXNjYWxlKSB7XG4gICAgICAgICAgLy8gcmVtZW1iZXIgZmlyc3QgUFRTIG9mIHRoaXMgZGVtdXhpbmcgY29udGV4dC4gZm9yIGF1ZGlvLCBQVFMgPSBEVFNcbiAgICAgICAgICBpbml0UFRTID0gaW5pdERUUyA9IGF1ZGlvU2FtcGxlc1swXS5wdHMgLSBNYXRoLnJvdW5kKHRpbWVzY2FsZSAqIHRpbWVPZmZzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbXB1dGVQVFNEVFMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodmlkZW9UcmFjay5zcHMgJiYgdmlkZW9UcmFjay5wcHMgJiYgdmlkZW9TYW1wbGVzLmxlbmd0aCkge1xuICAgICAgLy8gbGV0J3MgdXNlIGlucHV0IHRpbWUgc2NhbGUgYXMgTVA0IHZpZGVvIHRpbWVzY2FsZVxuICAgICAgLy8gd2UgdXNlIGlucHV0IHRpbWUgc2NhbGUgc3RyYWlnaHQgYXdheSB0byBhdm9pZCByb3VuZGluZyBpc3N1ZXMgb24gZnJhbWUgZHVyYXRpb24gLyBjdHMgY29tcHV0YXRpb25cbiAgICAgIHZpZGVvVHJhY2sudGltZXNjYWxlID0gdmlkZW9UcmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICAgIHRyYWNrcy52aWRlbyA9IHtcbiAgICAgICAgaWQ6ICdtYWluJyxcbiAgICAgICAgY29udGFpbmVyOiAndmlkZW8vbXA0JyxcbiAgICAgICAgY29kZWM6IHZpZGVvVHJhY2suY29kZWMsXG4gICAgICAgIGluaXRTZWdtZW50OiBNUDQuaW5pdFNlZ21lbnQoW3ZpZGVvVHJhY2tdKSxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICB3aWR0aDogdmlkZW9UcmFjay53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHZpZGVvVHJhY2suaGVpZ2h0XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xuICAgICAgICB0cmFja0lkID0gdmlkZW9UcmFjay5pZDtcbiAgICAgICAgdGltZXNjYWxlID0gdmlkZW9UcmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICAgICAgaWYgKCFfaW5pdFBUUyB8fCB0aW1lc2NhbGUgIT09IF9pbml0UFRTLnRpbWVzY2FsZSkge1xuICAgICAgICAgIGNvbnN0IHN0YXJ0UFRTID0gdGhpcy5nZXRWaWRlb1N0YXJ0UHRzKHZpZGVvU2FtcGxlcyk7XG4gICAgICAgICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBNYXRoLnJvdW5kKHRpbWVzY2FsZSAqIHRpbWVPZmZzZXQpO1xuICAgICAgICAgIGluaXREVFMgPSBNYXRoLm1pbihpbml0RFRTLCBub3JtYWxpemVQdHModmlkZW9TYW1wbGVzWzBdLmR0cywgc3RhcnRQVFMpIC0gc3RhcnRPZmZzZXQpO1xuICAgICAgICAgIGluaXRQVFMgPSBNYXRoLm1pbihpbml0UFRTLCBzdGFydFBUUyAtIHN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb21wdXRlUFRTRFRTID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMudmlkZW9UcmFja0NvbmZpZyA9IHtcbiAgICAgICAgd2lkdGg6IHZpZGVvVHJhY2sud2lkdGgsXG4gICAgICAgIGhlaWdodDogdmlkZW9UcmFjay5oZWlnaHQsXG4gICAgICAgIHBpeGVsUmF0aW86IHZpZGVvVHJhY2sucGl4ZWxSYXRpb1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKHRyYWNrcykubGVuZ3RoKSB7XG4gICAgICB0aGlzLklTR2VuZXJhdGVkID0gdHJ1ZTtcbiAgICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XG4gICAgICAgIHRoaXMuX2luaXRQVFMgPSB7XG4gICAgICAgICAgYmFzZVRpbWU6IGluaXRQVFMsXG4gICAgICAgICAgdGltZXNjYWxlOiB0aW1lc2NhbGVcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5faW5pdERUUyA9IHtcbiAgICAgICAgICBiYXNlVGltZTogaW5pdERUUyxcbiAgICAgICAgICB0aW1lc2NhbGU6IHRpbWVzY2FsZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdFBUUyA9IHRpbWVzY2FsZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRyYWNrcyxcbiAgICAgICAgaW5pdFBUUyxcbiAgICAgICAgdGltZXNjYWxlLFxuICAgICAgICB0cmFja0lkXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICByZW11eFZpZGVvKHRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhdWRpb1RyYWNrTGVuZ3RoKSB7XG4gICAgY29uc3QgdGltZVNjYWxlID0gdHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgY29uc3QgaW5wdXRTYW1wbGVzID0gdHJhY2suc2FtcGxlcztcbiAgICBjb25zdCBvdXRwdXRTYW1wbGVzID0gW107XG4gICAgY29uc3QgbmJTYW1wbGVzID0gaW5wdXRTYW1wbGVzLmxlbmd0aDtcbiAgICBjb25zdCBpbml0UFRTID0gdGhpcy5faW5pdFBUUztcbiAgICBjb25zdCBpbml0VGltZSA9IGluaXRQVFMuYmFzZVRpbWUgKiB0aW1lU2NhbGUgLyBpbml0UFRTLnRpbWVzY2FsZTtcbiAgICBsZXQgbmV4dFZpZGVvVHMgPSB0aGlzLm5leHRWaWRlb1RzO1xuICAgIGxldCBvZmZzZXQgPSA4O1xuICAgIGxldCBtcDRTYW1wbGVEdXJhdGlvbiA9IHRoaXMudmlkZW9TYW1wbGVEdXJhdGlvbjtcbiAgICBsZXQgZmlyc3REVFM7XG4gICAgbGV0IGxhc3REVFM7XG4gICAgbGV0IG1pblBUUyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgbWF4UFRTID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIGxldCBzb3J0U2FtcGxlcyA9IGZhbHNlO1xuXG4gICAgLy8gaWYgcGFyc2VkIGZyYWdtZW50IGlzIGNvbnRpZ3VvdXMgd2l0aCBsYXN0IG9uZSwgbGV0J3MgdXNlIGxhc3QgRFRTIHZhbHVlIGFzIHJlZmVyZW5jZVxuICAgIGlmICghY29udGlndW91cyB8fCBuZXh0VmlkZW9UcyA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgcHRzID0gaW5pdFRpbWUgKyB0aW1lT2Zmc2V0ICogdGltZVNjYWxlO1xuICAgICAgY29uc3QgY3RzID0gaW5wdXRTYW1wbGVzWzBdLnB0cyAtIG5vcm1hbGl6ZVB0cyhpbnB1dFNhbXBsZXNbMF0uZHRzLCBpbnB1dFNhbXBsZXNbMF0ucHRzKTtcbiAgICAgIGlmIChjaHJvbWVWZXJzaW9uICYmIG5leHRWaWRlb1RzICE9PSBudWxsICYmIE1hdGguYWJzKHB0cyAtIGN0cyAtIChuZXh0VmlkZW9UcyArIGluaXRUaW1lKSkgPCAxNTAwMCkge1xuICAgICAgICAvLyB0cmVhdCBhcyBjb250aWdvdXMgdG8gYWRqdXN0IHNhbXBsZXMgdGhhdCB3b3VsZCBvdGhlcndpc2UgcHJvZHVjZSB2aWRlbyBidWZmZXIgZ2FwcyBpbiBDaHJvbWVcbiAgICAgICAgY29udGlndW91cyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiBub3QgY29udGlndW91cywgbGV0J3MgdXNlIHRhcmdldCB0aW1lT2Zmc2V0XG4gICAgICAgIG5leHRWaWRlb1RzID0gcHRzIC0gY3RzIC0gaW5pdFRpbWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUFRTIGlzIGNvZGVkIG9uIDMzYml0cywgYW5kIGNhbiBsb29wIGZyb20gLTJeMzIgdG8gMl4zMlxuICAgIC8vIFBUU05vcm1hbGl6ZSB3aWxsIG1ha2UgUFRTL0RUUyB2YWx1ZSBtb25vdG9uaWMsIHdlIHVzZSBsYXN0IGtub3duIERUUyB2YWx1ZSBhcyByZWZlcmVuY2UgdmFsdWVcbiAgICBjb25zdCBuZXh0VmlkZW9QdHMgPSBuZXh0VmlkZW9UcyArIGluaXRUaW1lO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmJTYW1wbGVzOyBpKyspIHtcbiAgICAgIGNvbnN0IHNhbXBsZSA9IGlucHV0U2FtcGxlc1tpXTtcbiAgICAgIHNhbXBsZS5wdHMgPSBub3JtYWxpemVQdHMoc2FtcGxlLnB0cywgbmV4dFZpZGVvUHRzKTtcbiAgICAgIHNhbXBsZS5kdHMgPSBub3JtYWxpemVQdHMoc2FtcGxlLmR0cywgbmV4dFZpZGVvUHRzKTtcbiAgICAgIGlmIChzYW1wbGUuZHRzIDwgaW5wdXRTYW1wbGVzW2kgPiAwID8gaSAtIDEgOiBpXS5kdHMpIHtcbiAgICAgICAgc29ydFNhbXBsZXMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNvcnQgdmlkZW8gc2FtcGxlcyBieSBEVFMgdGhlbiBQVFMgdGhlbiBkZW11eCBpZCBvcmRlclxuICAgIGlmIChzb3J0U2FtcGxlcykge1xuICAgICAgaW5wdXRTYW1wbGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgY29uc3QgZGVsdGFkdHMgPSBhLmR0cyAtIGIuZHRzO1xuICAgICAgICBjb25zdCBkZWx0YXB0cyA9IGEucHRzIC0gYi5wdHM7XG4gICAgICAgIHJldHVybiBkZWx0YWR0cyB8fCBkZWx0YXB0cztcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEdldCBmaXJzdC9sYXN0IERUU1xuICAgIGZpcnN0RFRTID0gaW5wdXRTYW1wbGVzWzBdLmR0cztcbiAgICBsYXN0RFRTID0gaW5wdXRTYW1wbGVzW2lucHV0U2FtcGxlcy5sZW5ndGggLSAxXS5kdHM7XG5cbiAgICAvLyBTYW1wbGUgZHVyYXRpb24gKGFzIGV4cGVjdGVkIGJ5IHRydW4gTVA0IGJveGVzKSwgc2hvdWxkIGJlIHRoZSBkZWx0YSBiZXR3ZWVuIHNhbXBsZSBEVFNcbiAgICAvLyBzZXQgdGhpcyBjb25zdGFudCBkdXJhdGlvbiBhcyBiZWluZyB0aGUgYXZnIGRlbHRhIGJldHdlZW4gY29uc2VjdXRpdmUgRFRTLlxuICAgIGNvbnN0IGlucHV0RHVyYXRpb24gPSBsYXN0RFRTIC0gZmlyc3REVFM7XG4gICAgY29uc3QgYXZlcmFnZVNhbXBsZUR1cmF0aW9uID0gaW5wdXREdXJhdGlvbiA/IE1hdGgucm91bmQoaW5wdXREdXJhdGlvbiAvIChuYlNhbXBsZXMgLSAxKSkgOiBtcDRTYW1wbGVEdXJhdGlvbiB8fCB0cmFjay5pbnB1dFRpbWVTY2FsZSAvIDMwO1xuXG4gICAgLy8gaWYgZnJhZ21lbnQgYXJlIGNvbnRpZ3VvdXMsIGRldGVjdCBob2xlL292ZXJsYXBwaW5nIGJldHdlZW4gZnJhZ21lbnRzXG4gICAgaWYgKGNvbnRpZ3VvdXMpIHtcbiAgICAgIC8vIGNoZWNrIHRpbWVzdGFtcCBjb250aW51aXR5IGFjcm9zcyBjb25zZWN1dGl2ZSBmcmFnbWVudHMgKHRoaXMgaXMgdG8gcmVtb3ZlIGludGVyLWZyYWdtZW50IGdhcC9ob2xlKVxuICAgICAgY29uc3QgZGVsdGEgPSBmaXJzdERUUyAtIG5leHRWaWRlb1B0cztcbiAgICAgIGNvbnN0IGZvdW5kSG9sZSA9IGRlbHRhID4gYXZlcmFnZVNhbXBsZUR1cmF0aW9uO1xuICAgICAgY29uc3QgZm91bmRPdmVybGFwID0gZGVsdGEgPCAtMTtcbiAgICAgIGlmIChmb3VuZEhvbGUgfHwgZm91bmRPdmVybGFwKSB7XG4gICAgICAgIGlmIChmb3VuZEhvbGUpIHtcbiAgICAgICAgICB0aGlzLndhcm4oYCR7KHRyYWNrLnNlZ21lbnRDb2RlYyB8fCAnJykudG9VcHBlckNhc2UoKX06ICR7dG9Nc0Zyb21NcGVnVHNDbG9jayhkZWx0YSwgdHJ1ZSl9IG1zICgke2RlbHRhfWR0cykgaG9sZSBiZXR3ZWVuIGZyYWdtZW50cyBkZXRlY3RlZCBhdCAke3RpbWVPZmZzZXQudG9GaXhlZCgzKX1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLndhcm4oYCR7KHRyYWNrLnNlZ21lbnRDb2RlYyB8fCAnJykudG9VcHBlckNhc2UoKX06ICR7dG9Nc0Zyb21NcGVnVHNDbG9jaygtZGVsdGEsIHRydWUpfSBtcyAoJHtkZWx0YX1kdHMpIG92ZXJsYXBwaW5nIGJldHdlZW4gZnJhZ21lbnRzIGRldGVjdGVkIGF0ICR7dGltZU9mZnNldC50b0ZpeGVkKDMpfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZm91bmRPdmVybGFwIHx8IG5leHRWaWRlb1B0cyA+PSBpbnB1dFNhbXBsZXNbMF0ucHRzIHx8IGNocm9tZVZlcnNpb24pIHtcbiAgICAgICAgICBmaXJzdERUUyA9IG5leHRWaWRlb1B0cztcbiAgICAgICAgICBjb25zdCBmaXJzdFBUUyA9IGlucHV0U2FtcGxlc1swXS5wdHMgLSBkZWx0YTtcbiAgICAgICAgICBpZiAoZm91bmRIb2xlKSB7XG4gICAgICAgICAgICBpbnB1dFNhbXBsZXNbMF0uZHRzID0gZmlyc3REVFM7XG4gICAgICAgICAgICBpbnB1dFNhbXBsZXNbMF0ucHRzID0gZmlyc3RQVFM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBpc1BUU09yZGVyUmV0YWluZWQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dFNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKGlucHV0U2FtcGxlc1tpXS5kdHMgPiBmaXJzdFBUUyAmJiBpc1BUU09yZGVyUmV0YWluZWQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBwcmV2UFRTID0gaW5wdXRTYW1wbGVzW2ldLnB0cztcbiAgICAgICAgICAgICAgaW5wdXRTYW1wbGVzW2ldLmR0cyAtPSBkZWx0YTtcbiAgICAgICAgICAgICAgaW5wdXRTYW1wbGVzW2ldLnB0cyAtPSBkZWx0YTtcblxuICAgICAgICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgdGhpcyBzYW1wbGUncyBQVFMgb3JkZXIgaGFzIGNoYW5nZWRcbiAgICAgICAgICAgICAgLy8gcmVsYXRpdmUgdG8gdGhlIG5leHQgb25lXG4gICAgICAgICAgICAgIGlmIChpIDwgaW5wdXRTYW1wbGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0U2FtcGxlUFRTID0gaW5wdXRTYW1wbGVzW2kgKyAxXS5wdHM7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFNhbXBsZVBUUyA9IGlucHV0U2FtcGxlc1tpXS5wdHM7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudE9yZGVyID0gbmV4dFNhbXBsZVBUUyA8PSBjdXJyZW50U2FtcGxlUFRTO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZPcmRlciA9IG5leHRTYW1wbGVQVFMgPD0gcHJldlBUUztcbiAgICAgICAgICAgICAgICBpc1BUU09yZGVyUmV0YWluZWQgPSBjdXJyZW50T3JkZXIgPT0gcHJldk9yZGVyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubG9nKGBWaWRlbzogSW5pdGlhbCBQVFMvRFRTIGFkanVzdGVkOiAke3RvTXNGcm9tTXBlZ1RzQ2xvY2soZmlyc3RQVFMsIHRydWUpfS8ke3RvTXNGcm9tTXBlZ1RzQ2xvY2soZmlyc3REVFMsIHRydWUpfSwgZGVsdGE6ICR7dG9Nc0Zyb21NcGVnVHNDbG9jayhkZWx0YSwgdHJ1ZSl9IG1zYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZmlyc3REVFMgPSBNYXRoLm1heCgwLCBmaXJzdERUUyk7XG4gICAgbGV0IG5iTmFsdSA9IDA7XG4gICAgbGV0IG5hbHVMZW4gPSAwO1xuICAgIGxldCBkdHNTdGVwID0gZmlyc3REVFM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYlNhbXBsZXM7IGkrKykge1xuICAgICAgLy8gY29tcHV0ZSB0b3RhbC9hdmMgc2FtcGxlIGxlbmd0aCBhbmQgbmIgb2YgTkFMIHVuaXRzXG4gICAgICBjb25zdCBzYW1wbGUgPSBpbnB1dFNhbXBsZXNbaV07XG4gICAgICBjb25zdCB1bml0cyA9IHNhbXBsZS51bml0cztcbiAgICAgIGNvbnN0IG5iVW5pdHMgPSB1bml0cy5sZW5ndGg7XG4gICAgICBsZXQgc2FtcGxlTGVuID0gMDtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbmJVbml0czsgaisrKSB7XG4gICAgICAgIHNhbXBsZUxlbiArPSB1bml0c1tqXS5kYXRhLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIG5hbHVMZW4gKz0gc2FtcGxlTGVuO1xuICAgICAgbmJOYWx1ICs9IG5iVW5pdHM7XG4gICAgICBzYW1wbGUubGVuZ3RoID0gc2FtcGxlTGVuO1xuXG4gICAgICAvLyBlbnN1cmUgc2FtcGxlIG1vbm90b25pYyBEVFNcbiAgICAgIGlmIChzYW1wbGUuZHRzIDwgZHRzU3RlcCkge1xuICAgICAgICBzYW1wbGUuZHRzID0gZHRzU3RlcDtcbiAgICAgICAgZHRzU3RlcCArPSBhdmVyYWdlU2FtcGxlRHVyYXRpb24gLyA0IHwgMCB8fCAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHRzU3RlcCA9IHNhbXBsZS5kdHM7XG4gICAgICB9XG4gICAgICBtaW5QVFMgPSBNYXRoLm1pbihzYW1wbGUucHRzLCBtaW5QVFMpO1xuICAgICAgbWF4UFRTID0gTWF0aC5tYXgoc2FtcGxlLnB0cywgbWF4UFRTKTtcbiAgICB9XG4gICAgbGFzdERUUyA9IGlucHV0U2FtcGxlc1tuYlNhbXBsZXMgLSAxXS5kdHM7XG5cbiAgICAvKiBjb25jYXRlbmF0ZSB0aGUgdmlkZW8gZGF0YSBhbmQgY29uc3RydWN0IHRoZSBtZGF0IGluIHBsYWNlXG4gICAgICAobmVlZCA4IG1vcmUgYnl0ZXMgdG8gZmlsbCBsZW5ndGggYW5kIG1wZGF0IHR5cGUpICovXG4gICAgY29uc3QgbWRhdFNpemUgPSBuYWx1TGVuICsgNCAqIG5iTmFsdSArIDg7XG4gICAgbGV0IG1kYXQ7XG4gICAgdHJ5IHtcbiAgICAgIG1kYXQgPSBuZXcgVWludDhBcnJheShtZGF0U2l6ZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLm9ic2VydmVyLmVtaXQoRXZlbnRzLkVSUk9SLCBFdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NVVhfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5SRU1VWF9BTExPQ19FUlJPUixcbiAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyLFxuICAgICAgICBieXRlczogbWRhdFNpemUsXG4gICAgICAgIHJlYXNvbjogYGZhaWwgYWxsb2NhdGluZyB2aWRlbyBtZGF0ICR7bWRhdFNpemV9YFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcobWRhdC5idWZmZXIpO1xuICAgIHZpZXcuc2V0VWludDMyKDAsIG1kYXRTaXplKTtcbiAgICBtZGF0LnNldChNUDQudHlwZXMubWRhdCwgNCk7XG4gICAgbGV0IHN0cmV0Y2hlZExhc3RGcmFtZSA9IGZhbHNlO1xuICAgIGxldCBtaW5EdHNEZWx0YSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgbWluUHRzRGVsdGEgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IG1heER0c0RlbHRhID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIGxldCBtYXhQdHNEZWx0YSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5iU2FtcGxlczsgaSsrKSB7XG4gICAgICBjb25zdCBWaWRlb1NhbXBsZSA9IGlucHV0U2FtcGxlc1tpXTtcbiAgICAgIGNvbnN0IFZpZGVvU2FtcGxlVW5pdHMgPSBWaWRlb1NhbXBsZS51bml0cztcbiAgICAgIGxldCBtcDRTYW1wbGVMZW5ndGggPSAwO1xuICAgICAgLy8gY29udmVydCBOQUxVIGJpdHN0cmVhbSB0byBNUDQgZm9ybWF0IChwcmVwZW5kIE5BTFUgd2l0aCBzaXplIGZpZWxkKVxuICAgICAgZm9yIChsZXQgaiA9IDAsIG5iVW5pdHMgPSBWaWRlb1NhbXBsZVVuaXRzLmxlbmd0aDsgaiA8IG5iVW5pdHM7IGorKykge1xuICAgICAgICBjb25zdCB1bml0ID0gVmlkZW9TYW1wbGVVbml0c1tqXTtcbiAgICAgICAgY29uc3QgdW5pdERhdGEgPSB1bml0LmRhdGE7XG4gICAgICAgIGNvbnN0IHVuaXREYXRhTGVuID0gdW5pdC5kYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCwgdW5pdERhdGFMZW4pO1xuICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgbWRhdC5zZXQodW5pdERhdGEsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSB1bml0RGF0YUxlbjtcbiAgICAgICAgbXA0U2FtcGxlTGVuZ3RoICs9IDQgKyB1bml0RGF0YUxlbjtcbiAgICAgIH1cblxuICAgICAgLy8gZXhwZWN0ZWQgc2FtcGxlIGR1cmF0aW9uIGlzIHRoZSBEZWNvZGluZyBUaW1lc3RhbXAgZGlmZiBvZiBjb25zZWN1dGl2ZSBzYW1wbGVzXG4gICAgICBsZXQgcHRzRGVsdGE7XG4gICAgICBpZiAoaSA8IG5iU2FtcGxlcyAtIDEpIHtcbiAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBpbnB1dFNhbXBsZXNbaSArIDFdLmR0cyAtIFZpZGVvU2FtcGxlLmR0cztcbiAgICAgICAgcHRzRGVsdGEgPSBpbnB1dFNhbXBsZXNbaSArIDFdLnB0cyAtIFZpZGVvU2FtcGxlLnB0cztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgICBjb25zdCBsYXN0RnJhbWVEdXJhdGlvbiA9IGkgPiAwID8gVmlkZW9TYW1wbGUuZHRzIC0gaW5wdXRTYW1wbGVzW2kgLSAxXS5kdHMgOiBhdmVyYWdlU2FtcGxlRHVyYXRpb247XG4gICAgICAgIHB0c0RlbHRhID0gaSA+IDAgPyBWaWRlb1NhbXBsZS5wdHMgLSBpbnB1dFNhbXBsZXNbaSAtIDFdLnB0cyA6IGF2ZXJhZ2VTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgaWYgKGNvbmZpZy5zdHJldGNoU2hvcnRWaWRlb1RyYWNrICYmIHRoaXMubmV4dEF1ZGlvVHMgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBJbiBzb21lIGNhc2VzLCBhIHNlZ21lbnQncyBhdWRpbyB0cmFjayBkdXJhdGlvbiBtYXkgZXhjZWVkIHRoZSB2aWRlbyB0cmFjayBkdXJhdGlvbi5cbiAgICAgICAgICAvLyBTaW5jZSB3ZSd2ZSBhbHJlYWR5IHJlbXV4ZWQgYXVkaW8sIGFuZCB3ZSBrbm93IGhvdyBsb25nIHRoZSBhdWRpbyB0cmFjayBpcywgd2UgbG9vayB0b1xuICAgICAgICAgIC8vIHNlZSBpZiB0aGUgZGVsdGEgdG8gdGhlIG5leHQgc2VnbWVudCBpcyBsb25nZXIgdGhhbiBtYXhCdWZmZXJIb2xlLlxuICAgICAgICAgIC8vIElmIHNvLCBwbGF5YmFjayB3b3VsZCBwb3RlbnRpYWxseSBnZXQgc3R1Y2ssIHNvIHdlIGFydGlmaWNpYWxseSBpbmZsYXRlXG4gICAgICAgICAgLy8gdGhlIGR1cmF0aW9uIG9mIHRoZSBsYXN0IGZyYW1lIHRvIG1pbmltaXplIGFueSBwb3RlbnRpYWwgZ2FwIGJldHdlZW4gc2VnbWVudHMuXG4gICAgICAgICAgY29uc3QgZ2FwVG9sZXJhbmNlID0gTWF0aC5mbG9vcihjb25maWcubWF4QnVmZmVySG9sZSAqIHRpbWVTY2FsZSk7XG4gICAgICAgICAgY29uc3QgZGVsdGFUb0ZyYW1lRW5kID0gKGF1ZGlvVHJhY2tMZW5ndGggPyBtaW5QVFMgKyBhdWRpb1RyYWNrTGVuZ3RoICogdGltZVNjYWxlIDogdGhpcy5uZXh0QXVkaW9UcyArIGluaXRUaW1lKSAtIFZpZGVvU2FtcGxlLnB0cztcbiAgICAgICAgICBpZiAoZGVsdGFUb0ZyYW1lRW5kID4gZ2FwVG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAvLyBXZSBzdWJ0cmFjdCBsYXN0RnJhbWVEdXJhdGlvbiBmcm9tIGRlbHRhVG9GcmFtZUVuZCB0byB0cnkgdG8gcHJldmVudCBhbnkgdmlkZW9cbiAgICAgICAgICAgIC8vIGZyYW1lIG92ZXJsYXAuIG1heEJ1ZmZlckhvbGUgc2hvdWxkIGJlID4+IGxhc3RGcmFtZUR1cmF0aW9uIGFueXdheS5cbiAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gZGVsdGFUb0ZyYW1lRW5kIC0gbGFzdEZyYW1lRHVyYXRpb247XG4gICAgICAgICAgICBpZiAobXA0U2FtcGxlRHVyYXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gbGFzdEZyYW1lRHVyYXRpb247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHJldGNoZWRMYXN0RnJhbWUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sb2coYEl0IGlzIGFwcHJveGltYXRlbHkgJHtkZWx0YVRvRnJhbWVFbmQgLyA5MH0gbXMgdG8gdGhlIG5leHQgc2VnbWVudDsgdXNpbmcgZHVyYXRpb24gJHttcDRTYW1wbGVEdXJhdGlvbiAvIDkwfSBtcyBmb3IgdGhlIGxhc3QgdmlkZW8gZnJhbWUuYCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gbGFzdEZyYW1lRHVyYXRpb247XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gbGFzdEZyYW1lRHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbXBvc2l0aW9uVGltZU9mZnNldCA9IE1hdGgucm91bmQoVmlkZW9TYW1wbGUucHRzIC0gVmlkZW9TYW1wbGUuZHRzKTtcbiAgICAgIG1pbkR0c0RlbHRhID0gTWF0aC5taW4obWluRHRzRGVsdGEsIG1wNFNhbXBsZUR1cmF0aW9uKTtcbiAgICAgIG1heER0c0RlbHRhID0gTWF0aC5tYXgobWF4RHRzRGVsdGEsIG1wNFNhbXBsZUR1cmF0aW9uKTtcbiAgICAgIG1pblB0c0RlbHRhID0gTWF0aC5taW4obWluUHRzRGVsdGEsIHB0c0RlbHRhKTtcbiAgICAgIG1heFB0c0RlbHRhID0gTWF0aC5tYXgobWF4UHRzRGVsdGEsIHB0c0RlbHRhKTtcbiAgICAgIG91dHB1dFNhbXBsZXMucHVzaChjcmVhdGVNcDRTYW1wbGUoVmlkZW9TYW1wbGUua2V5LCBtcDRTYW1wbGVEdXJhdGlvbiwgbXA0U2FtcGxlTGVuZ3RoLCBjb21wb3NpdGlvblRpbWVPZmZzZXQpKTtcbiAgICB9XG4gICAgaWYgKG91dHB1dFNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICBpZiAoY2hyb21lVmVyc2lvbikge1xuICAgICAgICBpZiAoY2hyb21lVmVyc2lvbiA8IDcwKSB7XG4gICAgICAgICAgLy8gQ2hyb21lIHdvcmthcm91bmQsIG1hcmsgZmlyc3Qgc2FtcGxlIGFzIGJlaW5nIGEgUmFuZG9tIEFjY2VzcyBQb2ludCAoa2V5ZnJhbWUpIHRvIGF2b2lkIHNvdXJjZWJ1ZmZlciBhcHBlbmQgaXNzdWVcbiAgICAgICAgICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjI5NDEyXG4gICAgICAgICAgY29uc3QgZmxhZ3MgPSBvdXRwdXRTYW1wbGVzWzBdLmZsYWdzO1xuICAgICAgICAgIGZsYWdzLmRlcGVuZHNPbiA9IDI7XG4gICAgICAgICAgZmxhZ3MuaXNOb25TeW5jID0gMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzYWZhcmlXZWJraXRWZXJzaW9uKSB7XG4gICAgICAgIC8vIEZpeCBmb3IgXCJDTk4gc3BlY2lhbCByZXBvcnQsIHdpdGggQ0NcIiBpbiB0ZXN0LXN0cmVhbXMgKFNhZmFyaSBicm93c2VyIG9ubHkpXG4gICAgICAgIC8vIElnbm9yZSBEVFMgd2hlbiBmcmFtZSBkdXJhdGlvbnMgYXJlIGlycmVndWxhci4gU2FmYXJpIE1TRSBkb2VzIG5vdCBoYW5kbGUgdGhpcyBsZWFkaW5nIHRvIGdhcHMuXG4gICAgICAgIGlmIChtYXhQdHNEZWx0YSAtIG1pblB0c0RlbHRhIDwgbWF4RHRzRGVsdGEgLSBtaW5EdHNEZWx0YSAmJiBhdmVyYWdlU2FtcGxlRHVyYXRpb24gLyBtYXhEdHNEZWx0YSA8IDAuMDI1ICYmIG91dHB1dFNhbXBsZXNbMF0uY3RzID09PSAwKSB7XG4gICAgICAgICAgdGhpcy53YXJuKCdGb3VuZCBpcnJlZ3VsYXIgZ2FwcyBpbiBzYW1wbGUgZHVyYXRpb24uIFVzaW5nIFBUUyBpbnN0ZWFkIG9mIERUUyB0byBkZXRlcm1pbmUgTVA0IHNhbXBsZSBkdXJhdGlvbi4nKTtcbiAgICAgICAgICBsZXQgZHRzID0gZmlyc3REVFM7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG91dHB1dFNhbXBsZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHREdHMgPSBkdHMgKyBvdXRwdXRTYW1wbGVzW2ldLmR1cmF0aW9uO1xuICAgICAgICAgICAgY29uc3QgcHRzID0gZHRzICsgb3V0cHV0U2FtcGxlc1tpXS5jdHM7XG4gICAgICAgICAgICBpZiAoaSA8IGxlbiAtIDEpIHtcbiAgICAgICAgICAgICAgY29uc3QgbmV4dFB0cyA9IG5leHREdHMgKyBvdXRwdXRTYW1wbGVzW2kgKyAxXS5jdHM7XG4gICAgICAgICAgICAgIG91dHB1dFNhbXBsZXNbaV0uZHVyYXRpb24gPSBuZXh0UHRzIC0gcHRzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3V0cHV0U2FtcGxlc1tpXS5kdXJhdGlvbiA9IGkgPyBvdXRwdXRTYW1wbGVzW2kgLSAxXS5kdXJhdGlvbiA6IGF2ZXJhZ2VTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dFNhbXBsZXNbaV0uY3RzID0gMDtcbiAgICAgICAgICAgIGR0cyA9IG5leHREdHM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG5leHQgQVZDL0hFVkMgc2FtcGxlIERUUyBzaG91bGQgYmUgZXF1YWwgdG8gbGFzdCBzYW1wbGUgRFRTICsgbGFzdCBzYW1wbGUgZHVyYXRpb24gKGluIFBFUyB0aW1lc2NhbGUpXG4gICAgbXA0U2FtcGxlRHVyYXRpb24gPSBzdHJldGNoZWRMYXN0RnJhbWUgfHwgIW1wNFNhbXBsZUR1cmF0aW9uID8gYXZlcmFnZVNhbXBsZUR1cmF0aW9uIDogbXA0U2FtcGxlRHVyYXRpb247XG4gICAgY29uc3QgZW5kRFRTID0gbGFzdERUUyArIG1wNFNhbXBsZUR1cmF0aW9uO1xuICAgIHRoaXMubmV4dFZpZGVvVHMgPSBuZXh0VmlkZW9UcyA9IGVuZERUUyAtIGluaXRUaW1lO1xuICAgIHRoaXMudmlkZW9TYW1wbGVEdXJhdGlvbiA9IG1wNFNhbXBsZUR1cmF0aW9uO1xuICAgIHRoaXMuaXNWaWRlb0NvbnRpZ3VvdXMgPSB0cnVlO1xuICAgIGNvbnN0IG1vb2YgPSBNUDQubW9vZih0cmFjay5zZXF1ZW5jZU51bWJlcisrLCBmaXJzdERUUywgX2V4dGVuZHModHJhY2ssIHtcbiAgICAgIHNhbXBsZXM6IG91dHB1dFNhbXBsZXNcbiAgICB9KSk7XG4gICAgY29uc3QgdHlwZSA9ICd2aWRlbyc7XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIGRhdGExOiBtb29mLFxuICAgICAgZGF0YTI6IG1kYXQsXG4gICAgICBzdGFydFBUUzogKG1pblBUUyAtIGluaXRUaW1lKSAvIHRpbWVTY2FsZSxcbiAgICAgIGVuZFBUUzogKG1heFBUUyArIG1wNFNhbXBsZUR1cmF0aW9uIC0gaW5pdFRpbWUpIC8gdGltZVNjYWxlLFxuICAgICAgc3RhcnREVFM6IChmaXJzdERUUyAtIGluaXRUaW1lKSAvIHRpbWVTY2FsZSxcbiAgICAgIGVuZERUUzogbmV4dFZpZGVvVHMgLyB0aW1lU2NhbGUsXG4gICAgICB0eXBlLFxuICAgICAgaGFzQXVkaW86IGZhbHNlLFxuICAgICAgaGFzVmlkZW86IHRydWUsXG4gICAgICBuYjogb3V0cHV0U2FtcGxlcy5sZW5ndGgsXG4gICAgICBkcm9wcGVkOiB0cmFjay5kcm9wcGVkXG4gICAgfTtcbiAgICB0cmFjay5zYW1wbGVzID0gW107XG4gICAgdHJhY2suZHJvcHBlZCA9IDA7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgZ2V0U2FtcGxlc1BlckZyYW1lKHRyYWNrKSB7XG4gICAgc3dpdGNoICh0cmFjay5zZWdtZW50Q29kZWMpIHtcbiAgICAgIGNhc2UgJ21wMyc6XG4gICAgICAgIHJldHVybiBNUEVHX0FVRElPX1NBTVBMRV9QRVJfRlJBTUU7XG4gICAgICBjYXNlICdhYzMnOlxuICAgICAgICByZXR1cm4gQUMzX1NBTVBMRVNfUEVSX0ZSQU1FO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIEFBQ19TQU1QTEVTX1BFUl9GUkFNRTtcbiAgICB9XG4gIH1cbiAgcmVtdXhBdWRpbyh0cmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0LCB2aWRlb1RpbWVPZmZzZXQpIHtcbiAgICBjb25zdCBpbnB1dFRpbWVTY2FsZSA9IHRyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgIGNvbnN0IG1wNHRpbWVTY2FsZSA9IHRyYWNrLnNhbXBsZXJhdGUgPyB0cmFjay5zYW1wbGVyYXRlIDogaW5wdXRUaW1lU2NhbGU7XG4gICAgY29uc3Qgc2NhbGVGYWN0b3IgPSBpbnB1dFRpbWVTY2FsZSAvIG1wNHRpbWVTY2FsZTtcbiAgICBjb25zdCBtcDRTYW1wbGVEdXJhdGlvbiA9IHRoaXMuZ2V0U2FtcGxlc1BlckZyYW1lKHRyYWNrKTtcbiAgICBjb25zdCBpbnB1dFNhbXBsZUR1cmF0aW9uID0gbXA0U2FtcGxlRHVyYXRpb24gKiBzY2FsZUZhY3RvcjtcbiAgICBjb25zdCBpbml0UFRTID0gdGhpcy5faW5pdFBUUztcbiAgICBjb25zdCByYXdNUEVHID0gdHJhY2suc2VnbWVudENvZGVjID09PSAnbXAzJyAmJiB0aGlzLnR5cGVTdXBwb3J0ZWQubXBlZztcbiAgICBjb25zdCBvdXRwdXRTYW1wbGVzID0gW107XG4gICAgY29uc3QgYWxpZ25lZFdpdGhWaWRlbyA9IHZpZGVvVGltZU9mZnNldCAhPT0gdW5kZWZpbmVkO1xuICAgIGxldCBpbnB1dFNhbXBsZXMgPSB0cmFjay5zYW1wbGVzO1xuICAgIGxldCBvZmZzZXQgPSByYXdNUEVHID8gMCA6IDg7XG4gICAgbGV0IG5leHRBdWRpb1RzID0gdGhpcy5uZXh0QXVkaW9UcyB8fCAtMTtcblxuICAgIC8vIHdpbmRvdy5hdWRpb1NhbXBsZXMgPyB3aW5kb3cuYXVkaW9TYW1wbGVzLnB1c2goaW5wdXRTYW1wbGVzLm1hcChzID0+IHMucHRzKSkgOiAod2luZG93LmF1ZGlvU2FtcGxlcyA9IFtpbnB1dFNhbXBsZXMubWFwKHMgPT4gcy5wdHMpXSk7XG5cbiAgICAvLyBmb3IgYXVkaW8gc2FtcGxlcywgYWxzbyBjb25zaWRlciBjb25zZWN1dGl2ZSBmcmFnbWVudHMgYXMgYmVpbmcgY29udGlndW91cyAoZXZlbiBpZiBhIGxldmVsIHN3aXRjaCBvY2N1cnMpLFxuICAgIC8vIGZvciBzYWtlIG9mIGNsYXJpdHk6XG4gICAgLy8gY29uc2VjdXRpdmUgZnJhZ21lbnRzIGFyZSBmcmFncyB3aXRoXG4gICAgLy8gIC0gbGVzcyB0aGFuIDEwMG1zIGdhcHMgYmV0d2VlbiBuZXcgdGltZSBvZmZzZXQgKGlmIGFjY3VyYXRlKSBhbmQgbmV4dCBleHBlY3RlZCBQVFMgT1JcbiAgICAvLyAgLSBsZXNzIHRoYW4gMjAgYXVkaW8gZnJhbWVzIGRpc3RhbmNlXG4gICAgLy8gY29udGlndW91cyBmcmFnbWVudHMgYXJlIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBmcm9tIHNhbWUgcXVhbGl0eSBsZXZlbCAoc2FtZSBsZXZlbCwgbmV3IFNOID0gb2xkIFNOICsgMSlcbiAgICAvLyB0aGlzIGhlbHBzIGVuc3VyaW5nIGF1ZGlvIGNvbnRpbnVpdHlcbiAgICAvLyBhbmQgdGhpcyBhbHNvIGF2b2lkcyBhdWRpbyBnbGl0Y2hlcy9jdXQgd2hlbiBzd2l0Y2hpbmcgcXVhbGl0eSwgb3IgcmVwb3J0aW5nIHdyb25nIGR1cmF0aW9uIG9uIGZpcnN0IGF1ZGlvIGZyYW1lXG4gICAgY29uc3QgaW5pdFRpbWUgPSBpbml0UFRTLmJhc2VUaW1lICogaW5wdXRUaW1lU2NhbGUgLyBpbml0UFRTLnRpbWVzY2FsZTtcbiAgICBjb25zdCB0aW1lT2Zmc2V0TXBlZ1RTID0gaW5pdFRpbWUgKyB0aW1lT2Zmc2V0ICogaW5wdXRUaW1lU2NhbGU7XG4gICAgdGhpcy5pc0F1ZGlvQ29udGlndW91cyA9IGNvbnRpZ3VvdXMgPSBjb250aWd1b3VzIHx8IGlucHV0U2FtcGxlcy5sZW5ndGggJiYgbmV4dEF1ZGlvVHMgPiAwICYmIChhY2N1cmF0ZVRpbWVPZmZzZXQgJiYgTWF0aC5hYnModGltZU9mZnNldE1wZWdUUyAtIChuZXh0QXVkaW9UcyArIGluaXRUaW1lKSkgPCA5MDAwIHx8IE1hdGguYWJzKG5vcm1hbGl6ZVB0cyhpbnB1dFNhbXBsZXNbMF0ucHRzLCB0aW1lT2Zmc2V0TXBlZ1RTKSAtIChuZXh0QXVkaW9UcyArIGluaXRUaW1lKSkgPCAyMCAqIGlucHV0U2FtcGxlRHVyYXRpb24pO1xuXG4gICAgLy8gY29tcHV0ZSBub3JtYWxpemVkIFBUU1xuICAgIGlucHV0U2FtcGxlcy5mb3JFYWNoKGZ1bmN0aW9uIChzYW1wbGUpIHtcbiAgICAgIHNhbXBsZS5wdHMgPSBub3JtYWxpemVQdHMoc2FtcGxlLnB0cywgdGltZU9mZnNldE1wZWdUUyk7XG4gICAgfSk7XG4gICAgaWYgKCFjb250aWd1b3VzIHx8IG5leHRBdWRpb1RzIDwgMCkge1xuICAgICAgLy8gZmlsdGVyIG91dCBzYW1wbGUgd2l0aCBuZWdhdGl2ZSBQVFMgdGhhdCBhcmUgbm90IHBsYXlhYmxlIGFueXdheVxuICAgICAgLy8gaWYgd2UgZG9uJ3QgcmVtb3ZlIHRoZXNlIG5lZ2F0aXZlIHNhbXBsZXMsIHRoZXkgd2lsbCBzaGlmdCBhbGwgYXVkaW8gc2FtcGxlcyBmb3J3YXJkLlxuICAgICAgLy8gbGVhZGluZyB0byBhdWRpbyBvdmVybGFwIGJldHdlZW4gY3VycmVudCAvIG5leHQgZnJhZ21lbnRcbiAgICAgIGlucHV0U2FtcGxlcyA9IGlucHV0U2FtcGxlcy5maWx0ZXIoc2FtcGxlID0+IHNhbXBsZS5wdHMgPj0gMCk7XG5cbiAgICAgIC8vIGluIGNhc2UgYWxsIHNhbXBsZXMgaGF2ZSBuZWdhdGl2ZSBQVFMsIGFuZCBoYXZlIGJlZW4gZmlsdGVyZWQgb3V0LCByZXR1cm4gbm93XG4gICAgICBpZiAoIWlucHV0U2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHZpZGVvVGltZU9mZnNldCA9PT0gMCkge1xuICAgICAgICAvLyBTZXQgdGhlIHN0YXJ0IHRvIG1hdGNoIHZpZGVvIHNvIHRoYXQgc3RhcnQgZ2FwcyBsYXJnZXIgdGhhbiBpbnB1dFNhbXBsZUR1cmF0aW9uIGFyZSBmaWxsZWQgd2l0aCBzaWxlbmNlXG4gICAgICAgIG5leHRBdWRpb1RzID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoYWNjdXJhdGVUaW1lT2Zmc2V0ICYmICFhbGlnbmVkV2l0aFZpZGVvKSB7XG4gICAgICAgIC8vIFdoZW4gbm90IHNlZWtpbmcsIG5vdCBsaXZlLCBhbmQgTGV2ZWxEZXRhaWxzLlBUU0tub3duLCB1c2UgZnJhZ21lbnQgc3RhcnQgYXMgcHJlZGljdGVkIG5leHQgYXVkaW8gUFRTXG4gICAgICAgIG5leHRBdWRpb1RzID0gTWF0aC5tYXgoMCwgdGltZU9mZnNldE1wZWdUUyAtIGluaXRUaW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIGZyYWdzIGFyZSBub3QgY29udGlndW91cyBhbmQgaWYgd2UgY2FudCB0cnVzdCB0aW1lIG9mZnNldCwgbGV0J3MgdXNlIGZpcnN0IHNhbXBsZSBQVFMgYXMgbmV4dCBhdWRpbyBQVFNcbiAgICAgICAgbmV4dEF1ZGlvVHMgPSBpbnB1dFNhbXBsZXNbMF0ucHRzIC0gaW5pdFRpbWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGF1ZGlvIHRyYWNrIGlzIG1pc3Npbmcgc2FtcGxlcywgdGhlIGZyYW1lcyBzZWVtIHRvIGdldCBcImxlZnQtc2hpZnRlZFwiIHdpdGhpbiB0aGVcbiAgICAvLyByZXN1bHRpbmcgbXA0IHNlZ21lbnQsIGNhdXNpbmcgc3luYyBpc3N1ZXMgYW5kIGxlYXZpbmcgZ2FwcyBhdCB0aGUgZW5kIG9mIHRoZSBhdWRpbyBzZWdtZW50LlxuICAgIC8vIEluIGFuIGVmZm9ydCB0byBwcmV2ZW50IHRoaXMgZnJvbSBoYXBwZW5pbmcsIHdlIGluamVjdCBmcmFtZXMgaGVyZSB3aGVyZSB0aGVyZSBhcmUgZ2Fwcy5cbiAgICAvLyBXaGVuIHBvc3NpYmxlLCB3ZSBpbmplY3QgYSBzaWxlbnQgZnJhbWU7IHdoZW4gdGhhdCdzIG5vdCBwb3NzaWJsZSwgd2UgZHVwbGljYXRlIHRoZSBsYXN0XG4gICAgLy8gZnJhbWUuXG5cbiAgICBpZiAodHJhY2suc2VnbWVudENvZGVjID09PSAnYWFjJykge1xuICAgICAgY29uc3QgbWF4QXVkaW9GcmFtZXNEcmlmdCA9IHRoaXMuY29uZmlnLm1heEF1ZGlvRnJhbWVzRHJpZnQ7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbmV4dFB0cyA9IG5leHRBdWRpb1RzICsgaW5pdFRpbWU7IGkgPCBpbnB1dFNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gRmlyc3QsIGxldCdzIHNlZSBob3cgZmFyIG9mZiB0aGlzIGZyYW1lIGlzIGZyb20gd2hlcmUgd2UgZXhwZWN0IGl0IHRvIGJlXG4gICAgICAgIGNvbnN0IHNhbXBsZSA9IGlucHV0U2FtcGxlc1tpXTtcbiAgICAgICAgY29uc3QgcHRzID0gc2FtcGxlLnB0cztcbiAgICAgICAgY29uc3QgZGVsdGEgPSBwdHMgLSBuZXh0UHRzO1xuICAgICAgICBjb25zdCBkdXJhdGlvbiA9IE1hdGguYWJzKDEwMDAgKiBkZWx0YSAvIGlucHV0VGltZVNjYWxlKTtcblxuICAgICAgICAvLyBXaGVuIHJlbXV4aW5nIHdpdGggdmlkZW8sIGlmIHdlJ3JlIG92ZXJsYXBwaW5nIGJ5IG1vcmUgdGhhbiBhIGR1cmF0aW9uLCBkcm9wIHRoaXMgc2FtcGxlIHRvIHN0YXkgaW4gc3luY1xuICAgICAgICBpZiAoZGVsdGEgPD0gLW1heEF1ZGlvRnJhbWVzRHJpZnQgKiBpbnB1dFNhbXBsZUR1cmF0aW9uICYmIGFsaWduZWRXaXRoVmlkZW8pIHtcbiAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy53YXJuKGBBdWRpbyBmcmFtZSBAICR7KHB0cyAvIGlucHV0VGltZVNjYWxlKS50b0ZpeGVkKDMpfXMgb3ZlcmxhcHMgbWFya2VyIGJ5ICR7TWF0aC5yb3VuZCgxMDAwICogZGVsdGEgLyBpbnB1dFRpbWVTY2FsZSl9IG1zLmApO1xuICAgICAgICAgICAgdGhpcy5uZXh0QXVkaW9UcyA9IG5leHRBdWRpb1RzID0gcHRzIC0gaW5pdFRpbWU7XG4gICAgICAgICAgICBuZXh0UHRzID0gcHRzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJyYWNlLXN0eWxlXG5cbiAgICAgICAgLy8gSW5zZXJ0IG1pc3NpbmcgZnJhbWVzIGlmOlxuICAgICAgICAvLyAxOiBXZSdyZSBtb3JlIHRoYW4gbWF4QXVkaW9GcmFtZXNEcmlmdCBmcmFtZSBhd2F5XG4gICAgICAgIC8vIDI6IE5vdCBtb3JlIHRoYW4gTUFYX1NJTEVOVF9GUkFNRV9EVVJBVElPTiBhd2F5XG4gICAgICAgIC8vIDM6IGN1cnJlbnRUaW1lIChha2EgbmV4dFB0c05vcm0pIGlzIG5vdCAwXG4gICAgICAgIC8vIDQ6IHJlbXV4aW5nIHdpdGggdmlkZW8gKHZpZGVvVGltZU9mZnNldCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBlbHNlIGlmIChkZWx0YSA+PSBtYXhBdWRpb0ZyYW1lc0RyaWZ0ICogaW5wdXRTYW1wbGVEdXJhdGlvbiAmJiBkdXJhdGlvbiA8IE1BWF9TSUxFTlRfRlJBTUVfRFVSQVRJT04gJiYgYWxpZ25lZFdpdGhWaWRlbykge1xuICAgICAgICAgIGxldCBtaXNzaW5nID0gTWF0aC5yb3VuZChkZWx0YSAvIGlucHV0U2FtcGxlRHVyYXRpb24pO1xuICAgICAgICAgIC8vIEFkanVzdCBuZXh0UHRzIHNvIHRoYXQgc2lsZW50IHNhbXBsZXMgYXJlIGFsaWduZWQgd2l0aCBtZWRpYSBwdHMuIFRoaXMgd2lsbCBwcmV2ZW50IG1lZGlhIHNhbXBsZXMgZnJvbVxuICAgICAgICAgIC8vIGxhdGVyIGJlaW5nIHNoaWZ0ZWQgaWYgbmV4dFB0cyBpcyBiYXNlZCBvbiB0aW1lT2Zmc2V0IGFuZCBkZWx0YSBpcyBub3QgYSBtdWx0aXBsZSBvZiBpbnB1dFNhbXBsZUR1cmF0aW9uLlxuICAgICAgICAgIG5leHRQdHMgPSBwdHMgLSBtaXNzaW5nICogaW5wdXRTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgICB3aGlsZSAobmV4dFB0cyA8IDAgJiYgbWlzc2luZyAmJiBpbnB1dFNhbXBsZUR1cmF0aW9uKSB7XG4gICAgICAgICAgICBtaXNzaW5nLS07XG4gICAgICAgICAgICBuZXh0UHRzICs9IGlucHV0U2FtcGxlRHVyYXRpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLm5leHRBdWRpb1RzID0gbmV4dEF1ZGlvVHMgPSBuZXh0UHRzIC0gaW5pdFRpbWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMud2FybihgSW5qZWN0aW5nICR7bWlzc2luZ30gYXVkaW8gZnJhbWVzIEAgJHsoKG5leHRQdHMgLSBpbml0VGltZSkgLyBpbnB1dFRpbWVTY2FsZSkudG9GaXhlZCgzKX1zIGR1ZSB0byAke01hdGgucm91bmQoMTAwMCAqIGRlbHRhIC8gaW5wdXRUaW1lU2NhbGUpfSBtcyBnYXAuYCk7XG4gICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtaXNzaW5nOyBqKyspIHtcbiAgICAgICAgICAgIGxldCBmaWxsRnJhbWUgPSBBQUMuZ2V0U2lsZW50RnJhbWUodHJhY2sucGFyc2VkQ29kZWMgfHwgdHJhY2subWFuaWZlc3RDb2RlYyB8fCB0cmFjay5jb2RlYywgdHJhY2suY2hhbm5lbENvdW50KTtcbiAgICAgICAgICAgIGlmICghZmlsbEZyYW1lKSB7XG4gICAgICAgICAgICAgIHRoaXMubG9nKCdVbmFibGUgdG8gZ2V0IHNpbGVudCBmcmFtZSBmb3IgZ2l2ZW4gYXVkaW8gY29kZWM7IGR1cGxpY2F0aW5nIGxhc3QgZnJhbWUgaW5zdGVhZC4nKTtcbiAgICAgICAgICAgICAgZmlsbEZyYW1lID0gc2FtcGxlLnVuaXQuc3ViYXJyYXkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlucHV0U2FtcGxlcy5zcGxpY2UoaSwgMCwge1xuICAgICAgICAgICAgICB1bml0OiBmaWxsRnJhbWUsXG4gICAgICAgICAgICAgIHB0czogbmV4dFB0c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBuZXh0UHRzICs9IGlucHV0U2FtcGxlRHVyYXRpb247XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNhbXBsZS5wdHMgPSBuZXh0UHRzO1xuICAgICAgICBuZXh0UHRzICs9IGlucHV0U2FtcGxlRHVyYXRpb247XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBmaXJzdFBUUyA9IG51bGw7XG4gICAgbGV0IGxhc3RQVFMgPSBudWxsO1xuICAgIGxldCBtZGF0O1xuICAgIGxldCBtZGF0U2l6ZSA9IDA7XG4gICAgbGV0IHNhbXBsZUxlbmd0aCA9IGlucHV0U2FtcGxlcy5sZW5ndGg7XG4gICAgd2hpbGUgKHNhbXBsZUxlbmd0aC0tKSB7XG4gICAgICBtZGF0U2l6ZSArPSBpbnB1dFNhbXBsZXNbc2FtcGxlTGVuZ3RoXS51bml0LmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIGZvciAobGV0IGogPSAwLCBfbmJTYW1wbGVzID0gaW5wdXRTYW1wbGVzLmxlbmd0aDsgaiA8IF9uYlNhbXBsZXM7IGorKykge1xuICAgICAgY29uc3QgYXVkaW9TYW1wbGUgPSBpbnB1dFNhbXBsZXNbal07XG4gICAgICBjb25zdCB1bml0ID0gYXVkaW9TYW1wbGUudW5pdDtcbiAgICAgIGxldCBwdHMgPSBhdWRpb1NhbXBsZS5wdHM7XG4gICAgICBpZiAobGFzdFBUUyAhPT0gbnVsbCkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIG1vcmUgdGhhbiBvbmUgc2FtcGxlLCBzZXQgdGhlIGR1cmF0aW9uIG9mIHRoZSBzYW1wbGUgdG8gdGhlIFwicmVhbFwiIGR1cmF0aW9uOyB0aGUgUFRTIGRpZmYgd2l0aFxuICAgICAgICAvLyB0aGUgcHJldmlvdXMgc2FtcGxlXG4gICAgICAgIGNvbnN0IHByZXZTYW1wbGUgPSBvdXRwdXRTYW1wbGVzW2ogLSAxXTtcbiAgICAgICAgcHJldlNhbXBsZS5kdXJhdGlvbiA9IE1hdGgucm91bmQoKHB0cyAtIGxhc3RQVFMpIC8gc2NhbGVGYWN0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNvbnRpZ3VvdXMgJiYgdHJhY2suc2VnbWVudENvZGVjID09PSAnYWFjJykge1xuICAgICAgICAgIC8vIHNldCBQVFMvRFRTIHRvIGV4cGVjdGVkIFBUUy9EVFNcbiAgICAgICAgICBwdHMgPSBuZXh0QXVkaW9UcyArIGluaXRUaW1lO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlbWVtYmVyIGZpcnN0IFBUUyBvZiBvdXIgYXVkaW9TYW1wbGVzXG4gICAgICAgIGZpcnN0UFRTID0gcHRzO1xuICAgICAgICBpZiAobWRhdFNpemUgPiAwKSB7XG4gICAgICAgICAgLyogY29uY2F0ZW5hdGUgdGhlIGF1ZGlvIGRhdGEgYW5kIGNvbnN0cnVjdCB0aGUgbWRhdCBpbiBwbGFjZVxuICAgICAgICAgICAgKG5lZWQgOCBtb3JlIGJ5dGVzIHRvIGZpbGwgbGVuZ3RoIGFuZCBtZGF0IHR5cGUpICovXG4gICAgICAgICAgbWRhdFNpemUgKz0gb2Zmc2V0O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtZGF0ID0gbmV3IFVpbnQ4QXJyYXkobWRhdFNpemUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5lbWl0KEV2ZW50cy5FUlJPUiwgRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTVVYX0VSUk9SLFxuICAgICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuUkVNVVhfQUxMT0NfRVJST1IsXG4gICAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgZXJyb3I6IGVycixcbiAgICAgICAgICAgICAgYnl0ZXM6IG1kYXRTaXplLFxuICAgICAgICAgICAgICByZWFzb246IGBmYWlsIGFsbG9jYXRpbmcgYXVkaW8gbWRhdCAke21kYXRTaXplfWBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJhd01QRUcpIHtcbiAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcobWRhdC5idWZmZXIpO1xuICAgICAgICAgICAgdmlldy5zZXRVaW50MzIoMCwgbWRhdFNpemUpO1xuICAgICAgICAgICAgbWRhdC5zZXQoTVA0LnR5cGVzLm1kYXQsIDQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBubyBhdWRpbyBzYW1wbGVzXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtZGF0LnNldCh1bml0LCBvZmZzZXQpO1xuICAgICAgY29uc3QgdW5pdExlbiA9IHVuaXQuYnl0ZUxlbmd0aDtcbiAgICAgIG9mZnNldCArPSB1bml0TGVuO1xuICAgICAgLy8gRGVmYXVsdCB0aGUgc2FtcGxlJ3MgZHVyYXRpb24gdG8gdGhlIGNvbXB1dGVkIG1wNFNhbXBsZUR1cmF0aW9uLCB3aGljaCB3aWxsIGVpdGhlciBiZSAxMDI0IGZvciBBQUMgb3IgMTE1MiBmb3IgTVBFR1xuICAgICAgLy8gSW4gdGhlIGNhc2UgdGhhdCB3ZSBoYXZlIDEgc2FtcGxlLCB0aGlzIHdpbGwgYmUgdGhlIGR1cmF0aW9uLiBJZiB3ZSBoYXZlIG1vcmUgdGhhbiBvbmUgc2FtcGxlLCB0aGUgZHVyYXRpb25cbiAgICAgIC8vIGJlY29tZXMgdGhlIFBUUyBkaWZmIHdpdGggdGhlIHByZXZpb3VzIHNhbXBsZVxuICAgICAgb3V0cHV0U2FtcGxlcy5wdXNoKGNyZWF0ZU1wNFNhbXBsZSh0cnVlLCBtcDRTYW1wbGVEdXJhdGlvbiwgdW5pdExlbiwgMCkpO1xuICAgICAgbGFzdFBUUyA9IHB0cztcbiAgICB9XG5cbiAgICAvLyBXZSBjb3VsZCBlbmQgdXAgd2l0aCBubyBhdWRpbyBzYW1wbGVzIGlmIGFsbCBpbnB1dCBzYW1wbGVzIHdlcmUgb3ZlcmxhcHBpbmcgd2l0aCB0aGUgcHJldmlvdXNseSByZW11eGVkIG9uZXNcbiAgICBjb25zdCBuYlNhbXBsZXMgPSBvdXRwdXRTYW1wbGVzLmxlbmd0aDtcbiAgICBpZiAoIW5iU2FtcGxlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRoZSBuZXh0IGF1ZGlvIHNhbXBsZSBQVFMgc2hvdWxkIGJlIGVxdWFsIHRvIGxhc3Qgc2FtcGxlIFBUUyArIGR1cmF0aW9uXG4gICAgY29uc3QgbGFzdFNhbXBsZSA9IG91dHB1dFNhbXBsZXNbb3V0cHV0U2FtcGxlcy5sZW5ndGggLSAxXTtcbiAgICBuZXh0QXVkaW9UcyA9IGxhc3RQVFMgLSBpbml0VGltZTtcbiAgICB0aGlzLm5leHRBdWRpb1RzID0gbmV4dEF1ZGlvVHMgKyBzY2FsZUZhY3RvciAqIGxhc3RTYW1wbGUuZHVyYXRpb247XG5cbiAgICAvLyBTZXQgdGhlIHRyYWNrIHNhbXBsZXMgZnJvbSBpbnB1dFNhbXBsZXMgdG8gb3V0cHV0U2FtcGxlcyBiZWZvcmUgcmVtdXhpbmdcbiAgICBjb25zdCBtb29mID0gcmF3TVBFRyA/IG5ldyBVaW50OEFycmF5KDApIDogTVA0Lm1vb2YodHJhY2suc2VxdWVuY2VOdW1iZXIrKywgZmlyc3RQVFMgLyBzY2FsZUZhY3RvciwgX2V4dGVuZHMoe30sIHRyYWNrLCB7XG4gICAgICBzYW1wbGVzOiBvdXRwdXRTYW1wbGVzXG4gICAgfSkpO1xuXG4gICAgLy8gQ2xlYXIgdGhlIHRyYWNrIHNhbXBsZXMuIFRoaXMgYWxzbyBjbGVhcnMgdGhlIHNhbXBsZXMgYXJyYXkgaW4gdGhlIGRlbXV4ZXIsIHNpbmNlIHRoZSByZWZlcmVuY2UgaXMgc2hhcmVkXG4gICAgdHJhY2suc2FtcGxlcyA9IFtdO1xuICAgIGNvbnN0IHN0YXJ0ID0gKGZpcnN0UFRTIC0gaW5pdFRpbWUpIC8gaW5wdXRUaW1lU2NhbGU7XG4gICAgY29uc3QgZW5kID0gbmV4dEF1ZGlvVHMgLyBpbnB1dFRpbWVTY2FsZTtcbiAgICBjb25zdCB0eXBlID0gJ2F1ZGlvJztcbiAgICBjb25zdCBhdWRpb0RhdGEgPSB7XG4gICAgICBkYXRhMTogbW9vZixcbiAgICAgIGRhdGEyOiBtZGF0LFxuICAgICAgc3RhcnRQVFM6IHN0YXJ0LFxuICAgICAgZW5kUFRTOiBlbmQsXG4gICAgICBzdGFydERUUzogc3RhcnQsXG4gICAgICBlbmREVFM6IGVuZCxcbiAgICAgIHR5cGUsXG4gICAgICBoYXNBdWRpbzogdHJ1ZSxcbiAgICAgIGhhc1ZpZGVvOiBmYWxzZSxcbiAgICAgIG5iOiBuYlNhbXBsZXNcbiAgICB9O1xuICAgIHRoaXMuaXNBdWRpb0NvbnRpZ3VvdXMgPSB0cnVlO1xuICAgIHJldHVybiBhdWRpb0RhdGE7XG4gIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVB0cyh2YWx1ZSwgcmVmZXJlbmNlKSB7XG4gIGxldCBvZmZzZXQ7XG4gIGlmIChyZWZlcmVuY2UgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHJlZmVyZW5jZSA8IHZhbHVlKSB7XG4gICAgLy8gLSAyXjMzXG4gICAgb2Zmc2V0ID0gLTg1ODk5MzQ1OTI7XG4gIH0gZWxzZSB7XG4gICAgLy8gKyAyXjMzXG4gICAgb2Zmc2V0ID0gODU4OTkzNDU5MjtcbiAgfVxuICAvKiBQVFMgaXMgMzNiaXQgKGZyb20gMCB0byAyXjMzIC0xKVxuICAgIGlmIGRpZmYgYmV0d2VlbiB2YWx1ZSBhbmQgcmVmZXJlbmNlIGlzIGJpZ2dlciB0aGFuIGhhbGYgb2YgdGhlIGFtcGxpdHVkZSAoMl4zMikgdGhlbiBpdCBtZWFucyB0aGF0XG4gICAgUFRTIGxvb3Bpbmcgb2NjdXJlZC4gZmlsbCB0aGUgZ2FwICovXG4gIHdoaWxlIChNYXRoLmFicyh2YWx1ZSAtIHJlZmVyZW5jZSkgPiA0Mjk0OTY3Mjk2KSB7XG4gICAgdmFsdWUgKz0gb2Zmc2V0O1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGZpbmRLZXlmcmFtZUluZGV4KHNhbXBsZXMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHNhbXBsZXNbaV0ua2V5KSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gZmx1c2hUZXh0VHJhY2tNZXRhZGF0YUN1ZVNhbXBsZXModHJhY2ssIHRpbWVPZmZzZXQsIGluaXRQVFMsIGluaXREVFMpIHtcbiAgY29uc3QgbGVuZ3RoID0gdHJhY2suc2FtcGxlcy5sZW5ndGg7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGlucHV0VGltZVNjYWxlID0gdHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBzYW1wbGUgPSB0cmFjay5zYW1wbGVzW2luZGV4XTtcbiAgICAvLyBzZXR0aW5nIGlkMyBwdHMsIGR0cyB0byByZWxhdGl2ZSB0aW1lXG4gICAgLy8gdXNpbmcgdGhpcy5faW5pdFBUUyBhbmQgdGhpcy5faW5pdERUUyB0byBjYWxjdWxhdGUgcmVsYXRpdmUgdGltZVxuICAgIHNhbXBsZS5wdHMgPSBub3JtYWxpemVQdHMoc2FtcGxlLnB0cyAtIGluaXRQVFMuYmFzZVRpbWUgKiBpbnB1dFRpbWVTY2FsZSAvIGluaXRQVFMudGltZXNjYWxlLCB0aW1lT2Zmc2V0ICogaW5wdXRUaW1lU2NhbGUpIC8gaW5wdXRUaW1lU2NhbGU7XG4gICAgc2FtcGxlLmR0cyA9IG5vcm1hbGl6ZVB0cyhzYW1wbGUuZHRzIC0gaW5pdERUUy5iYXNlVGltZSAqIGlucHV0VGltZVNjYWxlIC8gaW5pdERUUy50aW1lc2NhbGUsIHRpbWVPZmZzZXQgKiBpbnB1dFRpbWVTY2FsZSkgLyBpbnB1dFRpbWVTY2FsZTtcbiAgfVxuICBjb25zdCBzYW1wbGVzID0gdHJhY2suc2FtcGxlcztcbiAgdHJhY2suc2FtcGxlcyA9IFtdO1xuICByZXR1cm4ge1xuICAgIHNhbXBsZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIGZsdXNoVGV4dFRyYWNrVXNlcmRhdGFDdWVTYW1wbGVzKHRyYWNrLCB0aW1lT2Zmc2V0LCBpbml0UFRTKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHRyYWNrLnNhbXBsZXMubGVuZ3RoO1xuICBpZiAoIWxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBpbnB1dFRpbWVTY2FsZSA9IHRyYWNrLmlucHV0VGltZVNjYWxlO1xuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY29uc3Qgc2FtcGxlID0gdHJhY2suc2FtcGxlc1tpbmRleF07XG4gICAgLy8gc2V0dGluZyB0ZXh0IHB0cywgZHRzIHRvIHJlbGF0aXZlIHRpbWVcbiAgICAvLyB1c2luZyB0aGlzLl9pbml0UFRTIGFuZCB0aGlzLl9pbml0RFRTIHRvIGNhbGN1bGF0ZSByZWxhdGl2ZSB0aW1lXG4gICAgc2FtcGxlLnB0cyA9IG5vcm1hbGl6ZVB0cyhzYW1wbGUucHRzIC0gaW5pdFBUUy5iYXNlVGltZSAqIGlucHV0VGltZVNjYWxlIC8gaW5pdFBUUy50aW1lc2NhbGUsIHRpbWVPZmZzZXQgKiBpbnB1dFRpbWVTY2FsZSkgLyBpbnB1dFRpbWVTY2FsZTtcbiAgfVxuICB0cmFjay5zYW1wbGVzLnNvcnQoKGEsIGIpID0+IGEucHRzIC0gYi5wdHMpO1xuICBjb25zdCBzYW1wbGVzID0gdHJhY2suc2FtcGxlcztcbiAgdHJhY2suc2FtcGxlcyA9IFtdO1xuICByZXR1cm4ge1xuICAgIHNhbXBsZXNcbiAgfTtcbn1cblxuY2xhc3MgUGFzc1Rocm91Z2hSZW11eGVyIGV4dGVuZHMgTG9nZ2VyIHtcbiAgY29uc3RydWN0b3Iob2JzZXJ2ZXIsIGNvbmZpZywgdHlwZVN1cHBvcnRlZCwgbG9nZ2VyKSB7XG4gICAgc3VwZXIoJ3Bhc3N0aHJvdWdoLXJlbXV4ZXInLCBsb2dnZXIpO1xuICAgIHRoaXMuZW1pdEluaXRTZWdtZW50ID0gZmFsc2U7XG4gICAgdGhpcy5hdWRpb0NvZGVjID0gdm9pZCAwO1xuICAgIHRoaXMudmlkZW9Db2RlYyA9IHZvaWQgMDtcbiAgICB0aGlzLmluaXREYXRhID0gdm9pZCAwO1xuICAgIHRoaXMuaW5pdFBUUyA9IG51bGw7XG4gICAgdGhpcy5pbml0VHJhY2tzID0gdm9pZCAwO1xuICAgIHRoaXMubGFzdEVuZFRpbWUgPSBudWxsO1xuICAgIHRoaXMuaXNWaWRlb0NvbnRpZ3VvdXMgPSBmYWxzZTtcbiAgfVxuICBkZXN0cm95KCkge31cbiAgcmVzZXRUaW1lU3RhbXAoZGVmYXVsdEluaXRQVFMpIHtcbiAgICB0aGlzLmxhc3RFbmRUaW1lID0gbnVsbDtcbiAgICBjb25zdCBpbml0UFRTID0gdGhpcy5pbml0UFRTO1xuICAgIGlmIChpbml0UFRTICYmIGRlZmF1bHRJbml0UFRTKSB7XG4gICAgICBpZiAoaW5pdFBUUy5iYXNlVGltZSA9PT0gZGVmYXVsdEluaXRQVFMuYmFzZVRpbWUgJiYgaW5pdFBUUy50aW1lc2NhbGUgPT09IGRlZmF1bHRJbml0UFRTLnRpbWVzY2FsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuaW5pdFBUUyA9IGRlZmF1bHRJbml0UFRTO1xuICB9XG4gIHJlc2V0TmV4dFRpbWVzdGFtcCgpIHtcbiAgICB0aGlzLmlzVmlkZW9Db250aWd1b3VzID0gZmFsc2U7XG4gICAgdGhpcy5sYXN0RW5kVGltZSA9IG51bGw7XG4gIH1cbiAgcmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgZGVjcnlwdGRhdGEpIHtcbiAgICB0aGlzLmF1ZGlvQ29kZWMgPSBhdWRpb0NvZGVjO1xuICAgIHRoaXMudmlkZW9Db2RlYyA9IHZpZGVvQ29kZWM7XG4gICAgdGhpcy5nZW5lcmF0ZUluaXRTZWdtZW50KHBhdGNoRW5jeXB0aW9uRGF0YShpbml0U2VnbWVudCwgZGVjcnlwdGRhdGEpKTtcbiAgICB0aGlzLmVtaXRJbml0U2VnbWVudCA9IHRydWU7XG4gIH1cbiAgZ2VuZXJhdGVJbml0U2VnbWVudChpbml0U2VnbWVudCkge1xuICAgIGxldCB7XG4gICAgICBhdWRpb0NvZGVjLFxuICAgICAgdmlkZW9Db2RlY1xuICAgIH0gPSB0aGlzO1xuICAgIGlmICghKGluaXRTZWdtZW50ICE9IG51bGwgJiYgaW5pdFNlZ21lbnQuYnl0ZUxlbmd0aCkpIHtcbiAgICAgIHRoaXMuaW5pdFRyYWNrcyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuaW5pdERhdGEgPSB1bmRlZmluZWQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGluaXREYXRhID0gdGhpcy5pbml0RGF0YSA9IHBhcnNlSW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQpO1xuXG4gICAgLy8gR2V0IGNvZGVjIGZyb20gaW5pdFNlZ21lbnRcbiAgICBpZiAoaW5pdERhdGEuYXVkaW8pIHtcbiAgICAgIGF1ZGlvQ29kZWMgPSBnZXRQYXJzZWRUcmFja0NvZGVjKGluaXREYXRhLmF1ZGlvLCBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU8sIHRoaXMpO1xuICAgIH1cbiAgICBpZiAoaW5pdERhdGEudmlkZW8pIHtcbiAgICAgIHZpZGVvQ29kZWMgPSBnZXRQYXJzZWRUcmFja0NvZGVjKGluaXREYXRhLnZpZGVvLCBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU8sIHRoaXMpO1xuICAgIH1cbiAgICBjb25zdCB0cmFja3MgPSB7fTtcbiAgICBpZiAoaW5pdERhdGEuYXVkaW8gJiYgaW5pdERhdGEudmlkZW8pIHtcbiAgICAgIHRyYWNrcy5hdWRpb3ZpZGVvID0ge1xuICAgICAgICBjb250YWluZXI6ICd2aWRlby9tcDQnLFxuICAgICAgICBjb2RlYzogYXVkaW9Db2RlYyArICcsJyArIHZpZGVvQ29kZWMsXG4gICAgICAgIHN1cHBsZW1lbnRhbDogaW5pdERhdGEudmlkZW8uc3VwcGxlbWVudGFsLFxuICAgICAgICBpbml0U2VnbWVudCxcbiAgICAgICAgaWQ6ICdtYWluJ1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGluaXREYXRhLmF1ZGlvKSB7XG4gICAgICB0cmFja3MuYXVkaW8gPSB7XG4gICAgICAgIGNvbnRhaW5lcjogJ2F1ZGlvL21wNCcsXG4gICAgICAgIGNvZGVjOiBhdWRpb0NvZGVjLFxuICAgICAgICBpbml0U2VnbWVudCxcbiAgICAgICAgaWQ6ICdhdWRpbydcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChpbml0RGF0YS52aWRlbykge1xuICAgICAgdHJhY2tzLnZpZGVvID0ge1xuICAgICAgICBjb250YWluZXI6ICd2aWRlby9tcDQnLFxuICAgICAgICBjb2RlYzogdmlkZW9Db2RlYyxcbiAgICAgICAgc3VwcGxlbWVudGFsOiBpbml0RGF0YS52aWRlby5zdXBwbGVtZW50YWwsXG4gICAgICAgIGluaXRTZWdtZW50LFxuICAgICAgICBpZDogJ21haW4nXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndhcm4oJ2luaXRTZWdtZW50IGRvZXMgbm90IGNvbnRhaW4gbW9vdiBvciB0cmFrIGJveGVzLicpO1xuICAgIH1cbiAgICB0aGlzLmluaXRUcmFja3MgPSB0cmFja3M7XG4gIH1cbiAgcmVtdXgoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgdmFyIF9pbml0RGF0YSwgX2luaXREYXRhMjtcbiAgICBsZXQge1xuICAgICAgaW5pdFBUUyxcbiAgICAgIGxhc3RFbmRUaW1lXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgYXVkaW86IHVuZGVmaW5lZCxcbiAgICAgIHZpZGVvOiB1bmRlZmluZWQsXG4gICAgICB0ZXh0OiB0ZXh0VHJhY2ssXG4gICAgICBpZDM6IGlkM1RyYWNrLFxuICAgICAgaW5pdFNlZ21lbnQ6IHVuZGVmaW5lZFxuICAgIH07XG5cbiAgICAvLyBJZiB3ZSBoYXZlbid0IHlldCBzZXQgYSBsYXN0RW5kRFRTLCBvciBpdCB3YXMgcmVzZXQsIHNldCBpdCB0byB0aGUgcHJvdmlkZWQgdGltZU9mZnNldC4gV2Ugd2FudCB0byB1c2UgdGhlXG4gICAgLy8gbGFzdEVuZERUUyBvdmVyIHRpbWVPZmZzZXQgd2hlbmV2ZXIgcG9zc2libGU7IGR1cmluZyBwcm9ncmVzc2l2ZSBwbGF5YmFjaywgdGhlIG1lZGlhIHNvdXJjZSB3aWxsIG5vdCB1cGRhdGVcbiAgICAvLyB0aGUgbWVkaWEgZHVyYXRpb24gKHdoaWNoIGlzIHdoYXQgdGltZU9mZnNldCBpcyBwcm92aWRlZCBhcykgYmVmb3JlIHdlIG5lZWQgdG8gcHJvY2VzcyB0aGUgbmV4dCBjaHVuay5cbiAgICBpZiAoIWlzRmluaXRlTnVtYmVyKGxhc3RFbmRUaW1lKSkge1xuICAgICAgbGFzdEVuZFRpbWUgPSB0aGlzLmxhc3RFbmRUaW1lID0gdGltZU9mZnNldCB8fCAwO1xuICAgIH1cblxuICAgIC8vIFRoZSBiaW5hcnkgc2VnbWVudCBkYXRhIGlzIGFkZGVkIHRvIHRoZSB2aWRlb1RyYWNrIGluIHRoZSBtcDRkZW11eGVyLiBXZSBkb24ndCBjaGVjayB0byBzZWUgaWYgdGhlIGRhdGEgaXMgb25seVxuICAgIC8vIGF1ZGlvIG9yIHZpZGVvIChvciBib3RoKTsgYWRkaW5nIGl0IHRvIHZpZGVvIHdhcyBhbiBhcmJpdHJhcnkgY2hvaWNlLlxuICAgIGNvbnN0IGRhdGEgPSB2aWRlb1RyYWNrLnNhbXBsZXM7XG4gICAgaWYgKCEoZGF0YSAhPSBudWxsICYmIGRhdGEubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgaW5pdFNlZ21lbnQgPSB7XG4gICAgICBpbml0UFRTOiB1bmRlZmluZWQsXG4gICAgICB0aW1lc2NhbGU6IHVuZGVmaW5lZCxcbiAgICAgIHRyYWNrSWQ6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgbGV0IGluaXREYXRhID0gdGhpcy5pbml0RGF0YTtcbiAgICBpZiAoISgoX2luaXREYXRhID0gaW5pdERhdGEpICE9IG51bGwgJiYgX2luaXREYXRhLmxlbmd0aCkpIHtcbiAgICAgIHRoaXMuZ2VuZXJhdGVJbml0U2VnbWVudChkYXRhKTtcbiAgICAgIGluaXREYXRhID0gdGhpcy5pbml0RGF0YTtcbiAgICB9XG4gICAgaWYgKCEoKF9pbml0RGF0YTIgPSBpbml0RGF0YSkgIT0gbnVsbCAmJiBfaW5pdERhdGEyLmxlbmd0aCkpIHtcbiAgICAgIC8vIFdlIGNhbid0IHJlbXV4IGlmIHRoZSBpbml0U2VnbWVudCBjb3VsZCBub3QgYmUgZ2VuZXJhdGVkXG4gICAgICB0aGlzLndhcm4oJ0ZhaWxlZCB0byBnZW5lcmF0ZSBpbml0U2VnbWVudC4nKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmVtaXRJbml0U2VnbWVudCkge1xuICAgICAgaW5pdFNlZ21lbnQudHJhY2tzID0gdGhpcy5pbml0VHJhY2tzO1xuICAgICAgdGhpcy5lbWl0SW5pdFNlZ21lbnQgPSBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdHJhY2tTYW1wbGVEYXRhID0gZ2V0U2FtcGxlRGF0YShkYXRhLCBpbml0RGF0YSwgdGhpcyk7XG4gICAgY29uc3QgYXVkaW9TYW1wbGVUaW1lc3RhbXBzID0gaW5pdERhdGEuYXVkaW8gPyB0cmFja1NhbXBsZURhdGFbaW5pdERhdGEuYXVkaW8uaWRdIDogbnVsbDtcbiAgICBjb25zdCB2aWRlb1NhbXBsZVRpbWVzdGFtcHMgPSBpbml0RGF0YS52aWRlbyA/IHRyYWNrU2FtcGxlRGF0YVtpbml0RGF0YS52aWRlby5pZF0gOiBudWxsO1xuICAgIGNvbnN0IHZpZGVvU3RhcnRUaW1lID0gdG9TdGFydEVuZE9yRGVmYXVsdCh2aWRlb1NhbXBsZVRpbWVzdGFtcHMsIEluZmluaXR5KTtcbiAgICBjb25zdCBhdWRpb1N0YXJ0VGltZSA9IHRvU3RhcnRFbmRPckRlZmF1bHQoYXVkaW9TYW1wbGVUaW1lc3RhbXBzLCBJbmZpbml0eSk7XG4gICAgY29uc3QgdmlkZW9FbmRUaW1lID0gdG9TdGFydEVuZE9yRGVmYXVsdCh2aWRlb1NhbXBsZVRpbWVzdGFtcHMsIDAsIHRydWUpO1xuICAgIGNvbnN0IGF1ZGlvRW5kVGltZSA9IHRvU3RhcnRFbmRPckRlZmF1bHQoYXVkaW9TYW1wbGVUaW1lc3RhbXBzLCAwLCB0cnVlKTtcbiAgICBsZXQgYmFzZU9mZnNldFNhbXBsZXM7XG4gICAgbGV0IGRlY29kZVRpbWUgPSB0aW1lT2Zmc2V0O1xuICAgIGxldCBkdXJhdGlvbiA9IDA7XG4gICAgaWYgKGF1ZGlvU2FtcGxlVGltZXN0YW1wcyAmJiAoIXZpZGVvU2FtcGxlVGltZXN0YW1wcyB8fCAhaW5pdFBUUyAmJiBhdWRpb1N0YXJ0VGltZSA8IHZpZGVvU3RhcnRUaW1lIHx8IGluaXRQVFMgJiYgaW5pdFBUUy50cmFja0lkID09PSBpbml0RGF0YS5hdWRpby5pZCkpIHtcbiAgICAgIGluaXRTZWdtZW50LnRyYWNrSWQgPSBpbml0RGF0YS5hdWRpby5pZDtcbiAgICAgIGJhc2VPZmZzZXRTYW1wbGVzID0gYXVkaW9TYW1wbGVUaW1lc3RhbXBzO1xuICAgICAgZHVyYXRpb24gPSBhdWRpb0VuZFRpbWUgLSBhdWRpb1N0YXJ0VGltZTtcbiAgICB9IGVsc2UgaWYgKHZpZGVvU2FtcGxlVGltZXN0YW1wcykge1xuICAgICAgaW5pdFNlZ21lbnQudHJhY2tJZCA9IGluaXREYXRhLnZpZGVvLmlkO1xuICAgICAgYmFzZU9mZnNldFNhbXBsZXMgPSB2aWRlb1NhbXBsZVRpbWVzdGFtcHM7XG4gICAgICBkdXJhdGlvbiA9IHZpZGVvRW5kVGltZSAtIHZpZGVvU3RhcnRUaW1lO1xuICAgIH1cbiAgICBpZiAoYmFzZU9mZnNldFNhbXBsZXMpIHtcbiAgICAgIGNvbnN0IHRpbWVzY2FsZSA9IGJhc2VPZmZzZXRTYW1wbGVzLnRpbWVzY2FsZTtcbiAgICAgIGRlY29kZVRpbWUgPSBiYXNlT2Zmc2V0U2FtcGxlcy5zdGFydCAvIHRpbWVzY2FsZTtcbiAgICAgIGluaXRTZWdtZW50LmluaXRQVFMgPSBiYXNlT2Zmc2V0U2FtcGxlcy5zdGFydCAtIHRpbWVPZmZzZXQgKiB0aW1lc2NhbGU7XG4gICAgICBpbml0U2VnbWVudC50aW1lc2NhbGUgPSB0aW1lc2NhbGU7XG4gICAgICBpZiAoIWluaXRQVFMpIHtcbiAgICAgICAgdGhpcy5pbml0UFRTID0gaW5pdFBUUyA9IHtcbiAgICAgICAgICBiYXNlVGltZTogaW5pdFNlZ21lbnQuaW5pdFBUUyxcbiAgICAgICAgICB0aW1lc2NhbGUsXG4gICAgICAgICAgdHJhY2tJZDogaW5pdFNlZ21lbnQudHJhY2tJZFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoKGFjY3VyYXRlVGltZU9mZnNldCB8fCAhaW5pdFBUUykgJiYgKGlzSW52YWxpZEluaXRQdHMoaW5pdFBUUywgZGVjb2RlVGltZSwgdGltZU9mZnNldCwgZHVyYXRpb24pIHx8IGluaXRTZWdtZW50LnRpbWVzY2FsZSAhPT0gaW5pdFBUUy50aW1lc2NhbGUpKSB7XG4gICAgICBpbml0U2VnbWVudC5pbml0UFRTID0gZGVjb2RlVGltZSAtIHRpbWVPZmZzZXQ7XG4gICAgICBpbml0U2VnbWVudC50aW1lc2NhbGUgPSAxO1xuICAgICAgaWYgKGluaXRQVFMgJiYgaW5pdFBUUy50aW1lc2NhbGUgPT09IDEpIHtcbiAgICAgICAgdGhpcy53YXJuKGBBZGp1c3RpbmcgaW5pdFBUUyBAJHt0aW1lT2Zmc2V0fSBmcm9tICR7aW5pdFBUUy5iYXNlVGltZSAvIGluaXRQVFMudGltZXNjYWxlfSB0byAke2luaXRTZWdtZW50LmluaXRQVFN9YCk7XG4gICAgICB9XG4gICAgICB0aGlzLmluaXRQVFMgPSBpbml0UFRTID0ge1xuICAgICAgICBiYXNlVGltZTogaW5pdFNlZ21lbnQuaW5pdFBUUyxcbiAgICAgICAgdGltZXNjYWxlOiAxXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBzdGFydFRpbWUgPSBhdWRpb1RyYWNrID8gZGVjb2RlVGltZSAtIGluaXRQVFMuYmFzZVRpbWUgLyBpbml0UFRTLnRpbWVzY2FsZSA6IGxhc3RFbmRUaW1lO1xuICAgIGNvbnN0IGVuZFRpbWUgPSBzdGFydFRpbWUgKyBkdXJhdGlvbjtcbiAgICBpZiAoZHVyYXRpb24gPiAwKSB7XG4gICAgICB0aGlzLmxhc3RFbmRUaW1lID0gZW5kVGltZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53YXJuKCdEdXJhdGlvbiBwYXJzZWQgZnJvbSBtcDQgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiB6ZXJvJyk7XG4gICAgICB0aGlzLnJlc2V0TmV4dFRpbWVzdGFtcCgpO1xuICAgIH1cbiAgICBjb25zdCBoYXNBdWRpbyA9ICEhaW5pdERhdGEuYXVkaW87XG4gICAgY29uc3QgaGFzVmlkZW8gPSAhIWluaXREYXRhLnZpZGVvO1xuICAgIGxldCB0eXBlID0gJyc7XG4gICAgaWYgKGhhc0F1ZGlvKSB7XG4gICAgICB0eXBlICs9ICdhdWRpbyc7XG4gICAgfVxuICAgIGlmIChoYXNWaWRlbykge1xuICAgICAgdHlwZSArPSAndmlkZW8nO1xuICAgIH1cbiAgICBjb25zdCB0cmFjayA9IHtcbiAgICAgIGRhdGExOiBkYXRhLFxuICAgICAgc3RhcnRQVFM6IHN0YXJ0VGltZSxcbiAgICAgIHN0YXJ0RFRTOiBzdGFydFRpbWUsXG4gICAgICBlbmRQVFM6IGVuZFRpbWUsXG4gICAgICBlbmREVFM6IGVuZFRpbWUsXG4gICAgICB0eXBlLFxuICAgICAgaGFzQXVkaW8sXG4gICAgICBoYXNWaWRlbyxcbiAgICAgIG5iOiAxLFxuICAgICAgZHJvcHBlZDogMFxuICAgIH07XG4gICAgcmVzdWx0LmF1ZGlvID0gaGFzQXVkaW8gJiYgIWhhc1ZpZGVvID8gdHJhY2sgOiB1bmRlZmluZWQ7XG4gICAgcmVzdWx0LnZpZGVvID0gaGFzVmlkZW8gPyB0cmFjayA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCB2aWRlb1NhbXBsZUNvdW50ID0gdmlkZW9TYW1wbGVUaW1lc3RhbXBzID09IG51bGwgPyB2b2lkIDAgOiB2aWRlb1NhbXBsZVRpbWVzdGFtcHMuc2FtcGxlQ291bnQ7XG4gICAgaWYgKHZpZGVvU2FtcGxlQ291bnQpIHtcbiAgICAgIGNvbnN0IGZpcnN0S2V5RnJhbWUgPSB2aWRlb1NhbXBsZVRpbWVzdGFtcHMua2V5RnJhbWVJbmRleDtcbiAgICAgIGNvbnN0IGluZGVwZW5kZW50ID0gZmlyc3RLZXlGcmFtZSAhPT0gLTE7XG4gICAgICB0cmFjay5uYiA9IHZpZGVvU2FtcGxlQ291bnQ7XG4gICAgICB0cmFjay5kcm9wcGVkID0gZmlyc3RLZXlGcmFtZSA9PT0gMCB8fCB0aGlzLmlzVmlkZW9Db250aWd1b3VzID8gMCA6IGluZGVwZW5kZW50ID8gZmlyc3RLZXlGcmFtZSA6IHZpZGVvU2FtcGxlQ291bnQ7XG4gICAgICB0cmFjay5pbmRlcGVuZGVudCA9IGluZGVwZW5kZW50O1xuICAgICAgdHJhY2suZmlyc3RLZXlGcmFtZSA9IGZpcnN0S2V5RnJhbWU7XG4gICAgICBpZiAoaW5kZXBlbmRlbnQgJiYgdmlkZW9TYW1wbGVUaW1lc3RhbXBzLmtleUZyYW1lU3RhcnQpIHtcbiAgICAgICAgdHJhY2suZmlyc3RLZXlGcmFtZVBUUyA9ICh2aWRlb1NhbXBsZVRpbWVzdGFtcHMua2V5RnJhbWVTdGFydCAtIGluaXRQVFMuYmFzZVRpbWUpIC8gaW5pdFBUUy50aW1lc2NhbGU7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuaXNWaWRlb0NvbnRpZ3VvdXMpIHtcbiAgICAgICAgcmVzdWx0LmluZGVwZW5kZW50ID0gaW5kZXBlbmRlbnQ7XG4gICAgICB9XG4gICAgICB0aGlzLmlzVmlkZW9Db250aWd1b3VzIHx8ICh0aGlzLmlzVmlkZW9Db250aWd1b3VzID0gaW5kZXBlbmRlbnQpO1xuICAgICAgaWYgKHRyYWNrLmRyb3BwZWQpIHtcbiAgICAgICAgdGhpcy53YXJuKGBmbXA0IGRvZXMgbm90IHN0YXJ0IHdpdGggSURSOiBmaXJzdElEUiAke2ZpcnN0S2V5RnJhbWV9LyR7dmlkZW9TYW1wbGVDb3VudH0gZHJvcHBlZDogJHt0cmFjay5kcm9wcGVkfSBzdGFydDogJHt0cmFjay5maXJzdEtleUZyYW1lUFRTIHx8ICdOQSd9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5pbml0U2VnbWVudCA9IGluaXRTZWdtZW50O1xuICAgIHJlc3VsdC5pZDMgPSBmbHVzaFRleHRUcmFja01ldGFkYXRhQ3VlU2FtcGxlcyhpZDNUcmFjaywgdGltZU9mZnNldCwgaW5pdFBUUywgaW5pdFBUUyk7XG4gICAgaWYgKHRleHRUcmFjay5zYW1wbGVzLmxlbmd0aCkge1xuICAgICAgcmVzdWx0LnRleHQgPSBmbHVzaFRleHRUcmFja1VzZXJkYXRhQ3VlU2FtcGxlcyh0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGluaXRQVFMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5mdW5jdGlvbiB0b1N0YXJ0RW5kT3JEZWZhdWx0KHRyYWNrVGltZXMsIGRlZmF1bHRWYWx1ZSwgZW5kID0gZmFsc2UpIHtcbiAgcmV0dXJuICh0cmFja1RpbWVzID09IG51bGwgPyB2b2lkIDAgOiB0cmFja1RpbWVzLnN0YXJ0KSAhPT0gdW5kZWZpbmVkID8gKHRyYWNrVGltZXMuc3RhcnQgKyAoZW5kID8gdHJhY2tUaW1lcy5kdXJhdGlvbiA6IDApKSAvIHRyYWNrVGltZXMudGltZXNjYWxlIDogZGVmYXVsdFZhbHVlO1xufVxuZnVuY3Rpb24gaXNJbnZhbGlkSW5pdFB0cyhpbml0UFRTLCBzdGFydERUUywgdGltZU9mZnNldCwgZHVyYXRpb24pIHtcbiAgaWYgKGluaXRQVFMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyBJbml0UFRTIGlzIGludmFsaWQgd2hlbiBkaXN0YW5jZSBmcm9tIHByb2dyYW0gd291bGQgYmUgbW9yZSB0aGFuIHNlZ21lbnQgZHVyYXRpb24gb3IgYSBtaW5pbXVtIG9mIG9uZSBzZWNvbmRcbiAgY29uc3QgbWluRHVyYXRpb24gPSBNYXRoLm1heChkdXJhdGlvbiwgMSk7XG4gIGNvbnN0IHN0YXJ0VGltZSA9IHN0YXJ0RFRTIC0gaW5pdFBUUy5iYXNlVGltZSAvIGluaXRQVFMudGltZXNjYWxlO1xuICByZXR1cm4gTWF0aC5hYnMoc3RhcnRUaW1lIC0gdGltZU9mZnNldCkgPiBtaW5EdXJhdGlvbjtcbn1cbmZ1bmN0aW9uIGdldFBhcnNlZFRyYWNrQ29kZWModHJhY2ssIHR5cGUsIGxvZ2dlcikge1xuICBjb25zdCBwYXJzZWRDb2RlYyA9IHRyYWNrID09IG51bGwgPyB2b2lkIDAgOiB0cmFjay5jb2RlYztcbiAgaWYgKHBhcnNlZENvZGVjICYmIHBhcnNlZENvZGVjLmxlbmd0aCA+IDQpIHtcbiAgICByZXR1cm4gcGFyc2VkQ29kZWM7XG4gIH1cbiAgaWYgKHR5cGUgPT09IEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJTykge1xuICAgIGlmIChwYXJzZWRDb2RlYyA9PT0gJ2VjLTMnIHx8IHBhcnNlZENvZGVjID09PSAnYWMtMycgfHwgcGFyc2VkQ29kZWMgPT09ICdhbGFjJykge1xuICAgICAgcmV0dXJuIHBhcnNlZENvZGVjO1xuICAgIH1cbiAgICBpZiAocGFyc2VkQ29kZWMgPT09ICdmTGFDJyB8fCBwYXJzZWRDb2RlYyA9PT0gJ09wdXMnKSB7XG4gICAgICAvLyBPcHRpbmcgbm90IHRvIGdldCBgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlYCBmcm9tIHBsYXllciBjb25maWcgZm9yIGlzU3VwcG9ydGVkKCkgY2hlY2sgZm9yIHNpbXBsaWNpdHlcbiAgICAgIGNvbnN0IHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGdldENvZGVjQ29tcGF0aWJsZU5hbWUocGFyc2VkQ29kZWMsIHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSk7XG4gICAgfVxuICAgIGxvZ2dlci53YXJuKGBVbmhhbmRsZWQgYXVkaW8gY29kZWMgXCIke3BhcnNlZENvZGVjfVwiIGluIG1wNCBNQVBgKTtcbiAgICByZXR1cm4gcGFyc2VkQ29kZWMgfHwgJ21wNGEnO1xuICB9XG4gIC8vIFByb3ZpZGUgZGVmYXVsdHMgYmFzZWQgb24gY29kZWMgdHlwZVxuICAvLyBUaGlzIGFsbG93cyBmb3Igc29tZSBwbGF5YmFjayBvZiBzb21lIGZtcDQgcGxheWxpc3RzIHdpdGhvdXQgQ09ERUNTIGRlZmluZWQgaW4gbWFuaWZlc3RcbiAgbG9nZ2VyLndhcm4oYFVuaGFuZGxlZCB2aWRlbyBjb2RlYyBcIiR7cGFyc2VkQ29kZWN9XCIgaW4gbXA0IE1BUGApO1xuICByZXR1cm4gcGFyc2VkQ29kZWMgfHwgJ2F2YzEnO1xufVxuXG5sZXQgbm93O1xuLy8gcGVyZm9ybWFuY2Uubm93KCkgbm90IGF2YWlsYWJsZSBvbiBXZWJXb3JrZXIsIGF0IGxlYXN0IG9uIFNhZmFyaSBEZXNrdG9wXG50cnkge1xuICBub3cgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdy5iaW5kKHNlbGYucGVyZm9ybWFuY2UpO1xufSBjYXRjaCAoZXJyKSB7XG4gIG5vdyA9IERhdGUubm93O1xufVxuY29uc3QgbXV4Q29uZmlnID0gW3tcbiAgZGVtdXg6IE1QNERlbXV4ZXIsXG4gIHJlbXV4OiBQYXNzVGhyb3VnaFJlbXV4ZXJcbn0sIHtcbiAgZGVtdXg6IFRTRGVtdXhlcixcbiAgcmVtdXg6IE1QNFJlbXV4ZXJcbn0sIHtcbiAgZGVtdXg6IEFBQ0RlbXV4ZXIsXG4gIHJlbXV4OiBNUDRSZW11eGVyXG59LCB7XG4gIGRlbXV4OiBNUDNEZW11eGVyLFxuICByZW11eDogTVA0UmVtdXhlclxufV07XG57XG4gIG11eENvbmZpZy5zcGxpY2UoMiwgMCwge1xuICAgIGRlbXV4OiBBQzNEZW11eGVyLFxuICAgIHJlbXV4OiBNUDRSZW11eGVyXG4gIH0pO1xufVxuY2xhc3MgVHJhbnNtdXhlciB7XG4gIGNvbnN0cnVjdG9yKG9ic2VydmVyLCB0eXBlU3VwcG9ydGVkLCBjb25maWcsIHZlbmRvciwgaWQsIGxvZ2dlcikge1xuICAgIHRoaXMuYXN5bmNSZXN1bHQgPSBmYWxzZTtcbiAgICB0aGlzLmxvZ2dlciA9IHZvaWQgMDtcbiAgICB0aGlzLm9ic2VydmVyID0gdm9pZCAwO1xuICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLmlkID0gdm9pZCAwO1xuICAgIHRoaXMuZGVtdXhlciA9IHZvaWQgMDtcbiAgICB0aGlzLnJlbXV4ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5kZWNyeXB0ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5wcm9iZSA9IHZvaWQgMDtcbiAgICB0aGlzLmRlY3J5cHRpb25Qcm9taXNlID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zbXV4Q29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMuY3VycmVudFRyYW5zbXV4U3RhdGUgPSB2b2lkIDA7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHR5cGVTdXBwb3J0ZWQ7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICB9XG4gIGNvbmZpZ3VyZSh0cmFuc211eENvbmZpZykge1xuICAgIHRoaXMudHJhbnNtdXhDb25maWcgPSB0cmFuc211eENvbmZpZztcbiAgICBpZiAodGhpcy5kZWNyeXB0ZXIpIHtcbiAgICAgIHRoaXMuZGVjcnlwdGVyLnJlc2V0KCk7XG4gICAgfVxuICB9XG4gIHB1c2goZGF0YSwgZGVjcnlwdGRhdGEsIGNodW5rTWV0YSwgc3RhdGUpIHtcbiAgICBjb25zdCBzdGF0cyA9IGNodW5rTWV0YS50cmFuc211eGluZztcbiAgICBzdGF0cy5leGVjdXRlU3RhcnQgPSBub3coKTtcbiAgICBsZXQgdWludERhdGEgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICBjb25zdCB7XG4gICAgICBjdXJyZW50VHJhbnNtdXhTdGF0ZSxcbiAgICAgIHRyYW5zbXV4Q29uZmlnXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKHN0YXRlKSB7XG4gICAgICB0aGlzLmN1cnJlbnRUcmFuc211eFN0YXRlID0gc3RhdGU7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRpZ3VvdXMsXG4gICAgICBkaXNjb250aW51aXR5LFxuICAgICAgdHJhY2tTd2l0Y2gsXG4gICAgICBhY2N1cmF0ZVRpbWVPZmZzZXQsXG4gICAgICB0aW1lT2Zmc2V0LFxuICAgICAgaW5pdFNlZ21lbnRDaGFuZ2VcbiAgICB9ID0gc3RhdGUgfHwgY3VycmVudFRyYW5zbXV4U3RhdGU7XG4gICAgY29uc3Qge1xuICAgICAgYXVkaW9Db2RlYyxcbiAgICAgIHZpZGVvQ29kZWMsXG4gICAgICBkZWZhdWx0SW5pdFB0cyxcbiAgICAgIGR1cmF0aW9uLFxuICAgICAgaW5pdFNlZ21lbnREYXRhXG4gICAgfSA9IHRyYW5zbXV4Q29uZmlnO1xuICAgIGNvbnN0IGtleURhdGEgPSBnZXRFbmNyeXB0aW9uVHlwZSh1aW50RGF0YSwgZGVjcnlwdGRhdGEpO1xuICAgIGlmIChrZXlEYXRhICYmIGlzRnVsbFNlZ21lbnRFbmNyeXB0aW9uKGtleURhdGEubWV0aG9kKSkge1xuICAgICAgY29uc3QgZGVjcnlwdGVyID0gdGhpcy5nZXREZWNyeXB0ZXIoKTtcbiAgICAgIGNvbnN0IGFlc01vZGUgPSBnZXRBZXNNb2RlRnJvbUZ1bGxTZWdtZW50TWV0aG9kKGtleURhdGEubWV0aG9kKTtcblxuICAgICAgLy8gU29mdHdhcmUgZGVjcnlwdGlvbiBpcyBzeW5jaHJvbm91czsgd2ViQ3J5cHRvIGlzIG5vdFxuICAgICAgaWYgKGRlY3J5cHRlci5pc1N5bmMoKSkge1xuICAgICAgICAvLyBTb2Z0d2FyZSBkZWNyeXB0aW9uIGlzIHByb2dyZXNzaXZlLiBQcm9ncmVzc2l2ZSBkZWNyeXB0aW9uIG1heSBub3QgcmV0dXJuIGEgcmVzdWx0IG9uIGVhY2ggY2FsbC4gQW55IGNhY2hlZFxuICAgICAgICAvLyBkYXRhIGlzIGhhbmRsZWQgaW4gdGhlIGZsdXNoKCkgY2FsbFxuICAgICAgICBsZXQgZGVjcnlwdGVkRGF0YSA9IGRlY3J5cHRlci5zb2Z0d2FyZURlY3J5cHQodWludERhdGEsIGtleURhdGEua2V5LmJ1ZmZlciwga2V5RGF0YS5pdi5idWZmZXIsIGFlc01vZGUpO1xuICAgICAgICAvLyBGb3IgTG93LUxhdGVuY3kgSExTIFBhcnRzLCBkZWNyeXB0IGluIHBsYWNlLCBzaW5jZSBwYXJ0IHBhcnNpbmcgaXMgZXhwZWN0ZWQgb24gcHVzaCBwcm9ncmVzc1xuICAgICAgICBjb25zdCBsb2FkaW5nUGFydHMgPSBjaHVua01ldGEucGFydCA+IC0xO1xuICAgICAgICBpZiAobG9hZGluZ1BhcnRzKSB7XG4gICAgICAgICAgY29uc3QgX2RhdGEgPSBkZWNyeXB0ZXIuZmx1c2goKTtcbiAgICAgICAgICBkZWNyeXB0ZWREYXRhID0gX2RhdGEgPyBfZGF0YS5idWZmZXIgOiBfZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlY3J5cHRlZERhdGEpIHtcbiAgICAgICAgICBzdGF0cy5leGVjdXRlRW5kID0gbm93KCk7XG4gICAgICAgICAgcmV0dXJuIGVtcHR5UmVzdWx0KGNodW5rTWV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdWludERhdGEgPSBuZXcgVWludDhBcnJheShkZWNyeXB0ZWREYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYXN5bmNSZXN1bHQgPSB0cnVlO1xuICAgICAgICB0aGlzLmRlY3J5cHRpb25Qcm9taXNlID0gZGVjcnlwdGVyLndlYkNyeXB0b0RlY3J5cHQodWludERhdGEsIGtleURhdGEua2V5LmJ1ZmZlciwga2V5RGF0YS5pdi5idWZmZXIsIGFlc01vZGUpLnRoZW4oZGVjcnlwdGVkRGF0YSA9PiB7XG4gICAgICAgICAgLy8gQ2FsbGluZyBwdXNoIGhlcmUgaXMgaW1wb3J0YW50OyBpZiBmbHVzaCgpIGlzIGNhbGxlZCB3aGlsZSB0aGlzIGlzIHN0aWxsIHJlc29sdmluZywgdGhpcyBlbnN1cmVzIHRoYXRcbiAgICAgICAgICAvLyB0aGUgZGVjcnlwdGVkIGRhdGEgaGFzIGJlZW4gdHJhbnNtdXhlZFxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucHVzaChkZWNyeXB0ZWREYXRhLCBudWxsLCBjaHVua01ldGEpO1xuICAgICAgICAgIHRoaXMuZGVjcnlwdGlvblByb21pc2UgPSBudWxsO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5kZWNyeXB0aW9uUHJvbWlzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzZXRNdXhlcnMgPSB0aGlzLm5lZWRzUHJvYmluZyhkaXNjb250aW51aXR5LCB0cmFja1N3aXRjaCk7XG4gICAgaWYgKHJlc2V0TXV4ZXJzKSB7XG4gICAgICBjb25zdCBlcnJvciA9IHRoaXMuY29uZmlndXJlVHJhbnNtdXhlcih1aW50RGF0YSk7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihgW3RyYW5zbXV4ZXJdICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5lbWl0KEV2ZW50cy5FUlJPUiwgRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLFxuICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICByZWFzb246IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXRzLmV4ZWN1dGVFbmQgPSBub3coKTtcbiAgICAgICAgcmV0dXJuIGVtcHR5UmVzdWx0KGNodW5rTWV0YSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkaXNjb250aW51aXR5IHx8IHRyYWNrU3dpdGNoIHx8IGluaXRTZWdtZW50Q2hhbmdlIHx8IHJlc2V0TXV4ZXJzKSB7XG4gICAgICB0aGlzLnJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnREYXRhLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBkdXJhdGlvbiwgZGVjcnlwdGRhdGEpO1xuICAgIH1cbiAgICBpZiAoZGlzY29udGludWl0eSB8fCBpbml0U2VnbWVudENoYW5nZSB8fCByZXNldE11eGVycykge1xuICAgICAgdGhpcy5yZXNldEluaXRpYWxUaW1lc3RhbXAoZGVmYXVsdEluaXRQdHMpO1xuICAgIH1cbiAgICBpZiAoIWNvbnRpZ3VvdXMpIHtcbiAgICAgIHRoaXMucmVzZXRDb250aWd1aXR5KCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudHJhbnNtdXgodWludERhdGEsIGtleURhdGEsIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhKTtcbiAgICB0aGlzLmFzeW5jUmVzdWx0ID0gaXNQcm9taXNlKHJlc3VsdCk7XG4gICAgY29uc3QgY3VycmVudFN0YXRlID0gdGhpcy5jdXJyZW50VHJhbnNtdXhTdGF0ZTtcbiAgICBjdXJyZW50U3RhdGUuY29udGlndW91cyA9IHRydWU7XG4gICAgY3VycmVudFN0YXRlLmRpc2NvbnRpbnVpdHkgPSBmYWxzZTtcbiAgICBjdXJyZW50U3RhdGUudHJhY2tTd2l0Y2ggPSBmYWxzZTtcbiAgICBzdGF0cy5leGVjdXRlRW5kID0gbm93KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIER1ZSB0byBkYXRhIGNhY2hpbmcsIGZsdXNoIGNhbGxzIGNhbiBwcm9kdWNlIG1vcmUgdGhhbiBvbmUgVHJhbnNtdXhlclJlc3VsdCAoaGVuY2UgdGhlIEFycmF5IHR5cGUpXG4gIGZsdXNoKGNodW5rTWV0YSkge1xuICAgIGNvbnN0IHN0YXRzID0gY2h1bmtNZXRhLnRyYW5zbXV4aW5nO1xuICAgIHN0YXRzLmV4ZWN1dGVTdGFydCA9IG5vdygpO1xuICAgIGNvbnN0IHtcbiAgICAgIGRlY3J5cHRlcixcbiAgICAgIGN1cnJlbnRUcmFuc211eFN0YXRlLFxuICAgICAgZGVjcnlwdGlvblByb21pc2VcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoZGVjcnlwdGlvblByb21pc2UpIHtcbiAgICAgIHRoaXMuYXN5bmNSZXN1bHQgPSB0cnVlO1xuICAgICAgLy8gVXBvbiByZXNvbHV0aW9uLCB0aGUgZGVjcnlwdGlvbiBwcm9taXNlIGNhbGxzIHB1c2goKSBhbmQgcmV0dXJucyBpdHMgVHJhbnNtdXhlclJlc3VsdCB1cCB0aGUgc3RhY2suIFRoZXJlZm9yZVxuICAgICAgLy8gb25seSBmbHVzaGluZyBpcyByZXF1aXJlZCBmb3IgYXN5bmMgZGVjcnlwdGlvblxuICAgICAgcmV0dXJuIGRlY3J5cHRpb25Qcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5mbHVzaChjaHVua01ldGEpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zbXV4UmVzdWx0cyA9IFtdO1xuICAgIGNvbnN0IHtcbiAgICAgIHRpbWVPZmZzZXRcbiAgICB9ID0gY3VycmVudFRyYW5zbXV4U3RhdGU7XG4gICAgaWYgKGRlY3J5cHRlcikge1xuICAgICAgLy8gVGhlIGRlY3J5cHRlciBtYXkgaGF2ZSBkYXRhIGNhY2hlZCwgd2hpY2ggbmVlZHMgdG8gYmUgZGVtdXhlZC4gSW4gdGhpcyBjYXNlIHdlJ2xsIGhhdmUgdHdvIFRyYW5zbXV4UmVzdWx0c1xuICAgICAgLy8gVGhpcyBoYXBwZW5zIGluIHRoZSBjYXNlIHRoYXQgd2UgcmVjZWl2ZSBvbmx5IDEgcHVzaCBjYWxsIGZvciBhIHNlZ21lbnQgKGVpdGhlciBmb3Igbm9uLXByb2dyZXNzaXZlIGRvd25sb2FkcyxcbiAgICAgIC8vIG9yIGZvciBwcm9ncmVzc2l2ZSBkb3dubG9hZHMgd2l0aCBzbWFsbCBzZWdtZW50cylcbiAgICAgIGNvbnN0IGRlY3J5cHRlZERhdGEgPSBkZWNyeXB0ZXIuZmx1c2goKTtcbiAgICAgIGlmIChkZWNyeXB0ZWREYXRhKSB7XG4gICAgICAgIC8vIFB1c2ggYWx3YXlzIHJldHVybnMgYSBUcmFuc211eGVyUmVzdWx0IGlmIGRlY3J5cHRkYXRhIGlzIG51bGxcbiAgICAgICAgdHJhbnNtdXhSZXN1bHRzLnB1c2godGhpcy5wdXNoKGRlY3J5cHRlZERhdGEuYnVmZmVyLCBudWxsLCBjaHVua01ldGEpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgZGVtdXhlcixcbiAgICAgIHJlbXV4ZXJcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWRlbXV4ZXIgfHwgIXJlbXV4ZXIpIHtcbiAgICAgIC8vIElmIHByb2JpbmcgZmFpbGVkLCB0aGVuIEhscy5qcyBoYXMgYmVlbiBnaXZlbiBjb250ZW50IGl0cyBub3QgYWJsZSB0byBoYW5kbGVcbiAgICAgIHN0YXRzLmV4ZWN1dGVFbmQgPSBub3coKTtcbiAgICAgIGNvbnN0IGVtcHR5UmVzdWx0cyA9IFtlbXB0eVJlc3VsdChjaHVua01ldGEpXTtcbiAgICAgIGlmICh0aGlzLmFzeW5jUmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZW1wdHlSZXN1bHRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbXB0eVJlc3VsdHM7XG4gICAgfVxuICAgIGNvbnN0IGRlbXV4UmVzdWx0T3JQcm9taXNlID0gZGVtdXhlci5mbHVzaCh0aW1lT2Zmc2V0KTtcbiAgICBpZiAoaXNQcm9taXNlKGRlbXV4UmVzdWx0T3JQcm9taXNlKSkge1xuICAgICAgdGhpcy5hc3luY1Jlc3VsdCA9IHRydWU7XG4gICAgICAvLyBEZWNyeXB0IGZpbmFsIFNBTVBMRS1BRVMgc2FtcGxlc1xuICAgICAgcmV0dXJuIGRlbXV4UmVzdWx0T3JQcm9taXNlLnRoZW4oZGVtdXhSZXN1bHQgPT4ge1xuICAgICAgICB0aGlzLmZsdXNoUmVtdXgodHJhbnNtdXhSZXN1bHRzLCBkZW11eFJlc3VsdCwgY2h1bmtNZXRhKTtcbiAgICAgICAgcmV0dXJuIHRyYW5zbXV4UmVzdWx0cztcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLmZsdXNoUmVtdXgodHJhbnNtdXhSZXN1bHRzLCBkZW11eFJlc3VsdE9yUHJvbWlzZSwgY2h1bmtNZXRhKTtcbiAgICBpZiAodGhpcy5hc3luY1Jlc3VsdCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cmFuc211eFJlc3VsdHMpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNtdXhSZXN1bHRzO1xuICB9XG4gIGZsdXNoUmVtdXgodHJhbnNtdXhSZXN1bHRzLCBkZW11eFJlc3VsdCwgY2h1bmtNZXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgYXVkaW9UcmFjayxcbiAgICAgIHZpZGVvVHJhY2ssXG4gICAgICBpZDNUcmFjayxcbiAgICAgIHRleHRUcmFja1xuICAgIH0gPSBkZW11eFJlc3VsdDtcbiAgICBjb25zdCB7XG4gICAgICBhY2N1cmF0ZVRpbWVPZmZzZXQsXG4gICAgICB0aW1lT2Zmc2V0XG4gICAgfSA9IHRoaXMuY3VycmVudFRyYW5zbXV4U3RhdGU7XG4gICAgdGhpcy5sb2dnZXIubG9nKGBbdHJhbnNtdXhlci50c106IEZsdXNoZWQgJHt0aGlzLmlkfSBzbjogJHtjaHVua01ldGEuc259JHtjaHVua01ldGEucGFydCA+IC0xID8gJyBwYXJ0OiAnICsgY2h1bmtNZXRhLnBhcnQgOiAnJ30gb2YgJHt0aGlzLmlkID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOID8gJ2xldmVsJyA6ICd0cmFjayd9ICR7Y2h1bmtNZXRhLmxldmVsfWApO1xuICAgIGNvbnN0IHJlbXV4UmVzdWx0ID0gdGhpcy5yZW11eGVyLnJlbXV4KGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgdHJ1ZSwgdGhpcy5pZCk7XG4gICAgdHJhbnNtdXhSZXN1bHRzLnB1c2goe1xuICAgICAgcmVtdXhSZXN1bHQsXG4gICAgICBjaHVua01ldGFcbiAgICB9KTtcbiAgICBjaHVua01ldGEudHJhbnNtdXhpbmcuZXhlY3V0ZUVuZCA9IG5vdygpO1xuICB9XG4gIHJlc2V0SW5pdGlhbFRpbWVzdGFtcChkZWZhdWx0SW5pdFB0cykge1xuICAgIGNvbnN0IHtcbiAgICAgIGRlbXV4ZXIsXG4gICAgICByZW11eGVyXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFkZW11eGVyIHx8ICFyZW11eGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlbXV4ZXIucmVzZXRUaW1lU3RhbXAoZGVmYXVsdEluaXRQdHMpO1xuICAgIHJlbXV4ZXIucmVzZXRUaW1lU3RhbXAoZGVmYXVsdEluaXRQdHMpO1xuICB9XG4gIHJlc2V0Q29udGlndWl0eSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBkZW11eGVyLFxuICAgICAgcmVtdXhlclxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghZGVtdXhlciB8fCAhcmVtdXhlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZW11eGVyLnJlc2V0Q29udGlndWl0eSgpO1xuICAgIHJlbXV4ZXIucmVzZXROZXh0VGltZXN0YW1wKCk7XG4gIH1cbiAgcmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudERhdGEsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRyYWNrRHVyYXRpb24sIGRlY3J5cHRkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGVtdXhlcixcbiAgICAgIHJlbXV4ZXJcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWRlbXV4ZXIgfHwgIXJlbXV4ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVtdXhlci5yZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50RGF0YSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbik7XG4gICAgcmVtdXhlci5yZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50RGF0YSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgZGVjcnlwdGRhdGEpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuZGVtdXhlcikge1xuICAgICAgdGhpcy5kZW11eGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuZGVtdXhlciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVtdXhlcikge1xuICAgICAgdGhpcy5yZW11eGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMucmVtdXhlciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgdHJhbnNtdXgoZGF0YSwga2V5RGF0YSwgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBjaHVua01ldGEpIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmIChrZXlEYXRhICYmIGtleURhdGEubWV0aG9kID09PSAnU0FNUExFLUFFUycpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMudHJhbnNtdXhTYW1wbGVBZXMoZGF0YSwga2V5RGF0YSwgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBjaHVua01ldGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSB0aGlzLnRyYW5zbXV4VW5lbmNyeXB0ZWQoZGF0YSwgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBjaHVua01ldGEpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHRyYW5zbXV4VW5lbmNyeXB0ZWQoZGF0YSwgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBjaHVua01ldGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBhdWRpb1RyYWNrLFxuICAgICAgdmlkZW9UcmFjayxcbiAgICAgIGlkM1RyYWNrLFxuICAgICAgdGV4dFRyYWNrXG4gICAgfSA9IHRoaXMuZGVtdXhlci5kZW11eChkYXRhLCB0aW1lT2Zmc2V0LCBmYWxzZSwgIXRoaXMuY29uZmlnLnByb2dyZXNzaXZlKTtcbiAgICBjb25zdCByZW11eFJlc3VsdCA9IHRoaXMucmVtdXhlci5yZW11eChhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGZhbHNlLCB0aGlzLmlkKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVtdXhSZXN1bHQsXG4gICAgICBjaHVua01ldGFcbiAgICB9O1xuICB9XG4gIHRyYW5zbXV4U2FtcGxlQWVzKGRhdGEsIGRlY3J5cHREYXRhLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGNodW5rTWV0YSkge1xuICAgIHJldHVybiB0aGlzLmRlbXV4ZXIuZGVtdXhTYW1wbGVBZXMoZGF0YSwgZGVjcnlwdERhdGEsIHRpbWVPZmZzZXQpLnRoZW4oZGVtdXhSZXN1bHQgPT4ge1xuICAgICAgY29uc3QgcmVtdXhSZXN1bHQgPSB0aGlzLnJlbXV4ZXIucmVtdXgoZGVtdXhSZXN1bHQuYXVkaW9UcmFjaywgZGVtdXhSZXN1bHQudmlkZW9UcmFjaywgZGVtdXhSZXN1bHQuaWQzVHJhY2ssIGRlbXV4UmVzdWx0LnRleHRUcmFjaywgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBmYWxzZSwgdGhpcy5pZCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW11eFJlc3VsdCxcbiAgICAgICAgY2h1bmtNZXRhXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIGNvbmZpZ3VyZVRyYW5zbXV4ZXIoZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbmZpZyxcbiAgICAgIG9ic2VydmVyLFxuICAgICAgdHlwZVN1cHBvcnRlZFxuICAgIH0gPSB0aGlzO1xuICAgIC8vIHByb2JlIGZvciBjb250ZW50IHR5cGVcbiAgICBsZXQgbXV4O1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBtdXhDb25maWcubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBfbXV4Q29uZmlnJGkkZGVtdXg7XG4gICAgICBpZiAoKF9tdXhDb25maWckaSRkZW11eCA9IG11eENvbmZpZ1tpXS5kZW11eCkgIT0gbnVsbCAmJiBfbXV4Q29uZmlnJGkkZGVtdXgucHJvYmUoZGF0YSwgdGhpcy5sb2dnZXIpKSB7XG4gICAgICAgIG11eCA9IG11eENvbmZpZ1tpXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghbXV4KSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdGYWlsZWQgdG8gZmluZCBkZW11eGVyIGJ5IHByb2JpbmcgZnJhZ21lbnQgZGF0YScpO1xuICAgIH1cbiAgICAvLyBzbyBsZXQncyBjaGVjayB0aGF0IGN1cnJlbnQgcmVtdXhlciBhbmQgZGVtdXhlciBhcmUgc3RpbGwgdmFsaWRcbiAgICBjb25zdCBkZW11eGVyID0gdGhpcy5kZW11eGVyO1xuICAgIGNvbnN0IHJlbXV4ZXIgPSB0aGlzLnJlbXV4ZXI7XG4gICAgY29uc3QgUmVtdXhlciA9IG11eC5yZW11eDtcbiAgICBjb25zdCBEZW11eGVyID0gbXV4LmRlbXV4O1xuICAgIGlmICghcmVtdXhlciB8fCAhKHJlbXV4ZXIgaW5zdGFuY2VvZiBSZW11eGVyKSkge1xuICAgICAgdGhpcy5yZW11eGVyID0gbmV3IFJlbXV4ZXIob2JzZXJ2ZXIsIGNvbmZpZywgdHlwZVN1cHBvcnRlZCwgdGhpcy5sb2dnZXIpO1xuICAgIH1cbiAgICBpZiAoIWRlbXV4ZXIgfHwgIShkZW11eGVyIGluc3RhbmNlb2YgRGVtdXhlcikpIHtcbiAgICAgIHRoaXMuZGVtdXhlciA9IG5ldyBEZW11eGVyKG9ic2VydmVyLCBjb25maWcsIHR5cGVTdXBwb3J0ZWQsIHRoaXMubG9nZ2VyKTtcbiAgICAgIHRoaXMucHJvYmUgPSBEZW11eGVyLnByb2JlO1xuICAgIH1cbiAgfVxuICBuZWVkc1Byb2JpbmcoZGlzY29udGludWl0eSwgdHJhY2tTd2l0Y2gpIHtcbiAgICAvLyBpbiBjYXNlIG9mIGNvbnRpbnVpdHkgY2hhbmdlLCBvciB0cmFjayBzd2l0Y2hcbiAgICAvLyB3ZSBtaWdodCBzd2l0Y2ggZnJvbSBjb250ZW50IHR5cGUgKEFBQyBjb250YWluZXIgdG8gVFMgY29udGFpbmVyLCBvciBUUyB0byBmbXA0IGZvciBleGFtcGxlKVxuICAgIHJldHVybiAhdGhpcy5kZW11eGVyIHx8ICF0aGlzLnJlbXV4ZXIgfHwgZGlzY29udGludWl0eSB8fCB0cmFja1N3aXRjaDtcbiAgfVxuICBnZXREZWNyeXB0ZXIoKSB7XG4gICAgbGV0IGRlY3J5cHRlciA9IHRoaXMuZGVjcnlwdGVyO1xuICAgIGlmICghZGVjcnlwdGVyKSB7XG4gICAgICBkZWNyeXB0ZXIgPSB0aGlzLmRlY3J5cHRlciA9IG5ldyBEZWNyeXB0ZXIodGhpcy5jb25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gZGVjcnlwdGVyO1xuICB9XG59XG5mdW5jdGlvbiBnZXRFbmNyeXB0aW9uVHlwZShkYXRhLCBkZWNyeXB0RGF0YSkge1xuICBsZXQgZW5jcnlwdGlvblR5cGUgPSBudWxsO1xuICBpZiAoZGF0YS5ieXRlTGVuZ3RoID4gMCAmJiAoZGVjcnlwdERhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRlY3J5cHREYXRhLmtleSkgIT0gbnVsbCAmJiBkZWNyeXB0RGF0YS5pdiAhPT0gbnVsbCAmJiBkZWNyeXB0RGF0YS5tZXRob2QgIT0gbnVsbCkge1xuICAgIGVuY3J5cHRpb25UeXBlID0gZGVjcnlwdERhdGE7XG4gIH1cbiAgcmV0dXJuIGVuY3J5cHRpb25UeXBlO1xufVxuY29uc3QgZW1wdHlSZXN1bHQgPSBjaHVua01ldGEgPT4gKHtcbiAgcmVtdXhSZXN1bHQ6IHt9LFxuICBjaHVua01ldGFcbn0pO1xuZnVuY3Rpb24gaXNQcm9taXNlKHApIHtcbiAgcmV0dXJuICd0aGVuJyBpbiBwICYmIHAudGhlbiBpbnN0YW5jZW9mIEZ1bmN0aW9uO1xufVxuY2xhc3MgVHJhbnNtdXhDb25maWcge1xuICBjb25zdHJ1Y3RvcihhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBpbml0U2VnbWVudERhdGEsIGR1cmF0aW9uLCBkZWZhdWx0SW5pdFB0cykge1xuICAgIHRoaXMuYXVkaW9Db2RlYyA9IHZvaWQgMDtcbiAgICB0aGlzLnZpZGVvQ29kZWMgPSB2b2lkIDA7XG4gICAgdGhpcy5pbml0U2VnbWVudERhdGEgPSB2b2lkIDA7XG4gICAgdGhpcy5kdXJhdGlvbiA9IHZvaWQgMDtcbiAgICB0aGlzLmRlZmF1bHRJbml0UHRzID0gdm9pZCAwO1xuICAgIHRoaXMuYXVkaW9Db2RlYyA9IGF1ZGlvQ29kZWM7XG4gICAgdGhpcy52aWRlb0NvZGVjID0gdmlkZW9Db2RlYztcbiAgICB0aGlzLmluaXRTZWdtZW50RGF0YSA9IGluaXRTZWdtZW50RGF0YTtcbiAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgdGhpcy5kZWZhdWx0SW5pdFB0cyA9IGRlZmF1bHRJbml0UHRzIHx8IG51bGw7XG4gIH1cbn1cbmNsYXNzIFRyYW5zbXV4U3RhdGUge1xuICBjb25zdHJ1Y3RvcihkaXNjb250aW51aXR5LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIHRyYWNrU3dpdGNoLCB0aW1lT2Zmc2V0LCBpbml0U2VnbWVudENoYW5nZSkge1xuICAgIHRoaXMuZGlzY29udGludWl0eSA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbnRpZ3VvdXMgPSB2b2lkIDA7XG4gICAgdGhpcy5hY2N1cmF0ZVRpbWVPZmZzZXQgPSB2b2lkIDA7XG4gICAgdGhpcy50cmFja1N3aXRjaCA9IHZvaWQgMDtcbiAgICB0aGlzLnRpbWVPZmZzZXQgPSB2b2lkIDA7XG4gICAgdGhpcy5pbml0U2VnbWVudENoYW5nZSA9IHZvaWQgMDtcbiAgICB0aGlzLmRpc2NvbnRpbnVpdHkgPSBkaXNjb250aW51aXR5O1xuICAgIHRoaXMuY29udGlndW91cyA9IGNvbnRpZ3VvdXM7XG4gICAgdGhpcy5hY2N1cmF0ZVRpbWVPZmZzZXQgPSBhY2N1cmF0ZVRpbWVPZmZzZXQ7XG4gICAgdGhpcy50cmFja1N3aXRjaCA9IHRyYWNrU3dpdGNoO1xuICAgIHRoaXMudGltZU9mZnNldCA9IHRpbWVPZmZzZXQ7XG4gICAgdGhpcy5pbml0U2VnbWVudENoYW5nZSA9IGluaXRTZWdtZW50Q2hhbmdlO1xuICB9XG59XG5cbmxldCB0cmFuc211eGVySW5zdGFuY2VDb3VudCA9IDA7XG5jbGFzcyBUcmFuc211eGVySW50ZXJmYWNlIHtcbiAgY29uc3RydWN0b3IoX2hscywgaWQsIG9uVHJhbnNtdXhDb21wbGV0ZSwgb25GbHVzaCkge1xuICAgIHRoaXMuZXJyb3IgPSBudWxsO1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMuaWQgPSB2b2lkIDA7XG4gICAgdGhpcy5pbnN0YW5jZU5vID0gdHJhbnNtdXhlckluc3RhbmNlQ291bnQrKztcbiAgICB0aGlzLm9ic2VydmVyID0gdm9pZCAwO1xuICAgIHRoaXMuZnJhZyA9IG51bGw7XG4gICAgdGhpcy5wYXJ0ID0gbnVsbDtcbiAgICB0aGlzLnVzZVdvcmtlciA9IHZvaWQgMDtcbiAgICB0aGlzLndvcmtlckNvbnRleHQgPSBudWxsO1xuICAgIHRoaXMudHJhbnNtdXhlciA9IG51bGw7XG4gICAgdGhpcy5vblRyYW5zbXV4Q29tcGxldGUgPSB2b2lkIDA7XG4gICAgdGhpcy5vbkZsdXNoID0gdm9pZCAwO1xuICAgIHRoaXMub25Xb3JrZXJNZXNzYWdlID0gZXZlbnQgPT4ge1xuICAgICAgY29uc3QgZGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICAgIGlmICghaGxzIHx8ICEoZGF0YSAhPSBudWxsICYmIGRhdGEuZXZlbnQpIHx8IGRhdGEuaW5zdGFuY2VObyAhPT0gdGhpcy5pbnN0YW5jZU5vKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoZGF0YS5ldmVudCkge1xuICAgICAgICBjYXNlICdpbml0JzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX3RoaXMkd29ya2VyQ29udGV4dDtcbiAgICAgICAgICAgIGNvbnN0IG9iamVjdFVSTCA9IChfdGhpcyR3b3JrZXJDb250ZXh0ID0gdGhpcy53b3JrZXJDb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkd29ya2VyQ29udGV4dC5vYmplY3RVUkw7XG4gICAgICAgICAgICBpZiAob2JqZWN0VVJMKSB7XG4gICAgICAgICAgICAgIC8vIHJldm9rZSB0aGUgT2JqZWN0IFVSTCB0aGF0IHdhcyB1c2VkIHRvIGNyZWF0ZSB0cmFuc211eGVyIHdvcmtlciwgc28gYXMgbm90IHRvIGxlYWsgaXRcbiAgICAgICAgICAgICAgc2VsZi5VUkwucmV2b2tlT2JqZWN0VVJMKG9iamVjdFVSTCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3RyYW5zbXV4Q29tcGxldGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlVHJhbnNtdXhDb21wbGV0ZShkYXRhLmRhdGEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdmbHVzaCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5vbkZsdXNoKGRhdGEuZGF0YSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgLy8gcGFzcyBsb2dzIGZyb20gdGhlIHdvcmtlciB0aHJlYWQgdG8gdGhlIG1haW4gbG9nZ2VyXG4gICAgICAgIGNhc2UgJ3dvcmtlckxvZyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKGhscy5sb2dnZXJbZGF0YS5kYXRhLmxvZ1R5cGVdKSB7XG4gICAgICAgICAgICAgIGhscy5sb2dnZXJbZGF0YS5kYXRhLmxvZ1R5cGVdKGRhdGEuZGF0YS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBkYXRhLmRhdGEgPSBkYXRhLmRhdGEgfHwge307XG4gICAgICAgICAgICBkYXRhLmRhdGEuZnJhZyA9IHRoaXMuZnJhZztcbiAgICAgICAgICAgIGRhdGEuZGF0YS5wYXJ0ID0gdGhpcy5wYXJ0O1xuICAgICAgICAgICAgZGF0YS5kYXRhLmlkID0gdGhpcy5pZDtcbiAgICAgICAgICAgIGhscy50cmlnZ2VyKGRhdGEuZXZlbnQsIGRhdGEuZGF0YSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm9uV29ya2VyRXJyb3IgPSBldmVudCA9PiB7XG4gICAgICBpZiAoIXRoaXMuaGxzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGAke2V2ZW50Lm1lc3NhZ2V9ICAoJHtldmVudC5maWxlbmFtZX06JHtldmVudC5saW5lbm99KWApO1xuICAgICAgdGhpcy5obHMuY29uZmlnLmVuYWJsZVdvcmtlciA9IGZhbHNlO1xuICAgICAgdGhpcy5obHMubG9nZ2VyLndhcm4oYEVycm9yIGluIFwiJHt0aGlzLmlkfVwiIFdlYiBXb3JrZXIsIGZhbGxiYWNrIHRvIGlubGluZWApO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5PVEhFUl9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLklOVEVSTkFMX0VYQ0VQVElPTixcbiAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICBldmVudDogJ2RlbXV4ZXJXb3JrZXInLFxuICAgICAgICBlcnJvclxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBjb25maWcgPSBfaGxzLmNvbmZpZztcbiAgICB0aGlzLmhscyA9IF9obHM7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMudXNlV29ya2VyID0gISFjb25maWcuZW5hYmxlV29ya2VyO1xuICAgIHRoaXMub25UcmFuc211eENvbXBsZXRlID0gb25UcmFuc211eENvbXBsZXRlO1xuICAgIHRoaXMub25GbHVzaCA9IG9uRmx1c2g7XG4gICAgY29uc3QgZm9yd2FyZE1lc3NhZ2UgPSAoZXYsIGRhdGEpID0+IHtcbiAgICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgICAgZGF0YS5mcmFnID0gdGhpcy5mcmFnIHx8IHVuZGVmaW5lZDtcbiAgICAgIGlmIChldiA9PT0gRXZlbnRzLkVSUk9SKSB7XG4gICAgICAgIGRhdGEgPSBkYXRhO1xuICAgICAgICBkYXRhLnBhcmVudCA9IHRoaXMuaWQ7XG4gICAgICAgIGRhdGEucGFydCA9IHRoaXMucGFydDtcbiAgICAgICAgdGhpcy5lcnJvciA9IGRhdGEuZXJyb3I7XG4gICAgICB9XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKGV2LCBkYXRhKTtcbiAgICB9O1xuXG4gICAgLy8gZm9yd2FyZCBldmVudHMgdG8gbWFpbiB0aHJlYWRcbiAgICB0aGlzLm9ic2VydmVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIHRoaXMub2JzZXJ2ZXIub24oRXZlbnRzLkZSQUdfREVDUllQVEVELCBmb3J3YXJkTWVzc2FnZSk7XG4gICAgdGhpcy5vYnNlcnZlci5vbihFdmVudHMuRVJST1IsIGZvcndhcmRNZXNzYWdlKTtcbiAgICBjb25zdCBtMnRzVHlwZVN1cHBvcnRlZCA9IGdldE0yVFNTdXBwb3J0ZWRBdWRpb1R5cGVzKGNvbmZpZy5wcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UpO1xuICAgIGlmICh0aGlzLnVzZVdvcmtlciAmJiB0eXBlb2YgV29ya2VyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc3QgbG9nZ2VyID0gdGhpcy5obHMubG9nZ2VyO1xuICAgICAgY29uc3QgY2FuQ3JlYXRlV29ya2VyID0gY29uZmlnLndvcmtlclBhdGggfHwgaGFzVU1EV29ya2VyKCk7XG4gICAgICBpZiAoY2FuQ3JlYXRlV29ya2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKGNvbmZpZy53b3JrZXJQYXRoKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKGBsb2FkaW5nIFdlYiBXb3JrZXIgJHtjb25maWcud29ya2VyUGF0aH0gZm9yIFwiJHtpZH1cImApO1xuICAgICAgICAgICAgdGhpcy53b3JrZXJDb250ZXh0ID0gbG9hZFdvcmtlcihjb25maWcud29ya2VyUGF0aCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coYGluamVjdGluZyBXZWIgV29ya2VyIGZvciBcIiR7aWR9XCJgKTtcbiAgICAgICAgICAgIHRoaXMud29ya2VyQ29udGV4dCA9IGluamVjdFdvcmtlcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB3b3JrZXJcbiAgICAgICAgICB9ID0gdGhpcy53b3JrZXJDb250ZXh0O1xuICAgICAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5vbldvcmtlck1lc3NhZ2UpO1xuICAgICAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMub25Xb3JrZXJFcnJvcik7XG4gICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIGluc3RhbmNlTm86IHRoaXMuaW5zdGFuY2VObyxcbiAgICAgICAgICAgIGNtZDogJ2luaXQnLFxuICAgICAgICAgICAgdHlwZVN1cHBvcnRlZDogbTJ0c1R5cGVTdXBwb3J0ZWQsXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGNvbmZpZzogc3RyaW5naWZ5KGNvbmZpZylcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYEVycm9yIHNldHRpbmcgdXAgXCIke2lkfVwiIFdlYiBXb3JrZXIsIGZhbGxiYWNrIHRvIGlubGluZWAsIGVycik7XG4gICAgICAgICAgdGhpcy50ZXJtaW5hdGVXb3JrZXIoKTtcbiAgICAgICAgICB0aGlzLmVycm9yID0gbnVsbDtcbiAgICAgICAgICB0aGlzLnRyYW5zbXV4ZXIgPSBuZXcgVHJhbnNtdXhlcih0aGlzLm9ic2VydmVyLCBtMnRzVHlwZVN1cHBvcnRlZCwgY29uZmlnLCAnJywgaWQsIF9obHMubG9nZ2VyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudHJhbnNtdXhlciA9IG5ldyBUcmFuc211eGVyKHRoaXMub2JzZXJ2ZXIsIG0ydHNUeXBlU3VwcG9ydGVkLCBjb25maWcsICcnLCBpZCwgX2hscy5sb2dnZXIpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuZnJhZyA9IG51bGw7XG4gICAgdGhpcy5wYXJ0ID0gbnVsbDtcbiAgICBpZiAodGhpcy53b3JrZXJDb250ZXh0KSB7XG4gICAgICBjb25zdCBpbnN0YW5jZU5vID0gdGhpcy5pbnN0YW5jZU5vO1xuICAgICAgdGhpcy5pbnN0YW5jZU5vID0gdHJhbnNtdXhlckluc3RhbmNlQ291bnQrKztcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcbiAgICAgIGNvbnN0IG0ydHNUeXBlU3VwcG9ydGVkID0gZ2V0TTJUU1N1cHBvcnRlZEF1ZGlvVHlwZXMoY29uZmlnLnByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSk7XG4gICAgICB0aGlzLndvcmtlckNvbnRleHQud29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgaW5zdGFuY2VObzogdGhpcy5pbnN0YW5jZU5vLFxuICAgICAgICBjbWQ6ICdyZXNldCcsXG4gICAgICAgIHJlc2V0Tm86IGluc3RhbmNlTm8sXG4gICAgICAgIHR5cGVTdXBwb3J0ZWQ6IG0ydHNUeXBlU3VwcG9ydGVkLFxuICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgY29uZmlnOiBzdHJpbmdpZnkoY29uZmlnKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHRlcm1pbmF0ZVdvcmtlcigpIHtcbiAgICBpZiAodGhpcy53b3JrZXJDb250ZXh0KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHdvcmtlclxuICAgICAgfSA9IHRoaXMud29ya2VyQ29udGV4dDtcbiAgICAgIHRoaXMud29ya2VyQ29udGV4dCA9IG51bGw7XG4gICAgICB3b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMub25Xb3JrZXJNZXNzYWdlKTtcbiAgICAgIHdvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMub25Xb3JrZXJFcnJvcik7XG4gICAgICByZW1vdmVXb3JrZXJGcm9tU3RvcmUodGhpcy5obHMuY29uZmlnLndvcmtlclBhdGgpO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLndvcmtlckNvbnRleHQpIHtcbiAgICAgIHRoaXMudGVybWluYXRlV29ya2VyKCk7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLm9uV29ya2VyTWVzc2FnZSA9IHRoaXMub25Xb3JrZXJFcnJvciA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRyYW5zbXV4ZXIgPSB0aGlzLnRyYW5zbXV4ZXI7XG4gICAgICBpZiAodHJhbnNtdXhlcikge1xuICAgICAgICB0cmFuc211eGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy50cmFuc211eGVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyO1xuICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgb2JzZXJ2ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIHRoaXMuZnJhZyA9IG51bGw7XG4gICAgdGhpcy5wYXJ0ID0gbnVsbDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5vYnNlcnZlciA9IG51bGw7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuaGxzID0gbnVsbDtcbiAgfVxuICBwdXNoKGRhdGEsIGluaXRTZWdtZW50RGF0YSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgZnJhZywgcGFydCwgZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhLCBkZWZhdWx0SW5pdFBUUykge1xuICAgIHZhciBfZnJhZyRpbml0U2VnbWVudCwgX2xhc3RGcmFnJGluaXRTZWdtZW50O1xuICAgIGNodW5rTWV0YS50cmFuc211eGluZy5zdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3Qge1xuICAgICAgaW5zdGFuY2VObyxcbiAgICAgIHRyYW5zbXV4ZXJcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB0aW1lT2Zmc2V0ID0gcGFydCA/IHBhcnQuc3RhcnQgOiBmcmFnLnN0YXJ0O1xuICAgIC8vIFRPRE86IHB1c2ggXCJjbGVhci1sZWFkXCIgZGVjcnlwdCBkYXRhIGZvciB1bmVuY3J5cHRlZCBmcmFnbWVudHMgaW4gc3RyZWFtcyB3aXRoIGVuY3J5cHRlZCBvbmVzXG4gICAgY29uc3QgZGVjcnlwdGRhdGEgPSBmcmFnLmRlY3J5cHRkYXRhO1xuICAgIGNvbnN0IGxhc3RGcmFnID0gdGhpcy5mcmFnO1xuICAgIGNvbnN0IGRpc2NvbnRpbnVpdHkgPSAhKGxhc3RGcmFnICYmIGZyYWcuY2MgPT09IGxhc3RGcmFnLmNjKTtcbiAgICBjb25zdCB0cmFja1N3aXRjaCA9ICEobGFzdEZyYWcgJiYgY2h1bmtNZXRhLmxldmVsID09PSBsYXN0RnJhZy5sZXZlbCk7XG4gICAgY29uc3Qgc25EaWZmID0gbGFzdEZyYWcgPyBjaHVua01ldGEuc24gLSBsYXN0RnJhZy5zbiA6IC0xO1xuICAgIGNvbnN0IHBhcnREaWZmID0gdGhpcy5wYXJ0ID8gY2h1bmtNZXRhLnBhcnQgLSB0aGlzLnBhcnQuaW5kZXggOiAtMTtcbiAgICBjb25zdCBwcm9ncmVzc2l2ZSA9IHNuRGlmZiA9PT0gMCAmJiBjaHVua01ldGEuaWQgPiAxICYmIGNodW5rTWV0YS5pZCA9PT0gKGxhc3RGcmFnID09IG51bGwgPyB2b2lkIDAgOiBsYXN0RnJhZy5zdGF0cy5jaHVua0NvdW50KTtcbiAgICBjb25zdCBjb250aWd1b3VzID0gIXRyYWNrU3dpdGNoICYmIChzbkRpZmYgPT09IDEgfHwgc25EaWZmID09PSAwICYmIChwYXJ0RGlmZiA9PT0gMSB8fCBwcm9ncmVzc2l2ZSAmJiBwYXJ0RGlmZiA8PSAwKSk7XG4gICAgY29uc3Qgbm93ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICBpZiAodHJhY2tTd2l0Y2ggfHwgc25EaWZmIHx8IGZyYWcuc3RhdHMucGFyc2luZy5zdGFydCA9PT0gMCkge1xuICAgICAgZnJhZy5zdGF0cy5wYXJzaW5nLnN0YXJ0ID0gbm93O1xuICAgIH1cbiAgICBpZiAocGFydCAmJiAocGFydERpZmYgfHwgIWNvbnRpZ3VvdXMpKSB7XG4gICAgICBwYXJ0LnN0YXRzLnBhcnNpbmcuc3RhcnQgPSBub3c7XG4gICAgfVxuICAgIGNvbnN0IGluaXRTZWdtZW50Q2hhbmdlID0gIShsYXN0RnJhZyAmJiAoKF9mcmFnJGluaXRTZWdtZW50ID0gZnJhZy5pbml0U2VnbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mcmFnJGluaXRTZWdtZW50LnVybCkgPT09ICgoX2xhc3RGcmFnJGluaXRTZWdtZW50ID0gbGFzdEZyYWcuaW5pdFNlZ21lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbGFzdEZyYWckaW5pdFNlZ21lbnQudXJsKSk7XG4gICAgY29uc3Qgc3RhdGUgPSBuZXcgVHJhbnNtdXhTdGF0ZShkaXNjb250aW51aXR5LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIHRyYWNrU3dpdGNoLCB0aW1lT2Zmc2V0LCBpbml0U2VnbWVudENoYW5nZSk7XG4gICAgaWYgKCFjb250aWd1b3VzIHx8IGRpc2NvbnRpbnVpdHkgfHwgaW5pdFNlZ21lbnRDaGFuZ2UpIHtcbiAgICAgIHRoaXMuaGxzLmxvZ2dlci5sb2coYFt0cmFuc211eGVyLWludGVyZmFjZV06IFN0YXJ0aW5nIG5ldyB0cmFuc211eCBzZXNzaW9uIGZvciAke2ZyYWcudHlwZX0gc246ICR7Y2h1bmtNZXRhLnNufSR7Y2h1bmtNZXRhLnBhcnQgPiAtMSA/ICcgcGFydDogJyArIGNodW5rTWV0YS5wYXJ0IDogJyd9ICR7dGhpcy5pZCA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTiA/ICdsZXZlbCcgOiAndHJhY2snfTogJHtjaHVua01ldGEubGV2ZWx9IGlkOiAke2NodW5rTWV0YS5pZH1cbiAgICAgICAgZGlzY29udGludWl0eTogJHtkaXNjb250aW51aXR5fVxuICAgICAgICB0cmFja1N3aXRjaDogJHt0cmFja1N3aXRjaH1cbiAgICAgICAgY29udGlndW91czogJHtjb250aWd1b3VzfVxuICAgICAgICBhY2N1cmF0ZVRpbWVPZmZzZXQ6ICR7YWNjdXJhdGVUaW1lT2Zmc2V0fVxuICAgICAgICB0aW1lT2Zmc2V0OiAke3RpbWVPZmZzZXR9XG4gICAgICAgIGluaXRTZWdtZW50Q2hhbmdlOiAke2luaXRTZWdtZW50Q2hhbmdlfWApO1xuICAgICAgY29uc3QgY29uZmlnID0gbmV3IFRyYW5zbXV4Q29uZmlnKGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGluaXRTZWdtZW50RGF0YSwgZHVyYXRpb24sIGRlZmF1bHRJbml0UFRTKTtcbiAgICAgIHRoaXMuY29uZmlndXJlVHJhbnNtdXhlcihjb25maWcpO1xuICAgIH1cbiAgICB0aGlzLmZyYWcgPSBmcmFnO1xuICAgIHRoaXMucGFydCA9IHBhcnQ7XG5cbiAgICAvLyBGcmFncyB3aXRoIHNuIG9mICdpbml0U2VnbWVudCcgYXJlIG5vdCB0cmFuc211eGVkXG4gICAgaWYgKHRoaXMud29ya2VyQ29udGV4dCkge1xuICAgICAgLy8gcG9zdCBmcmFnbWVudCBwYXlsb2FkIGFzIHRyYW5zZmVyYWJsZSBvYmplY3RzIGZvciBBcnJheUJ1ZmZlciAobm8gY29weSlcbiAgICAgIHRoaXMud29ya2VyQ29udGV4dC53b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBpbnN0YW5jZU5vLFxuICAgICAgICBjbWQ6ICdkZW11eCcsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGRlY3J5cHRkYXRhLFxuICAgICAgICBjaHVua01ldGEsXG4gICAgICAgIHN0YXRlXG4gICAgICB9LCBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyBbZGF0YV0gOiBbXSk7XG4gICAgfSBlbHNlIGlmICh0cmFuc211eGVyKSB7XG4gICAgICBjb25zdCB0cmFuc211eFJlc3VsdCA9IHRyYW5zbXV4ZXIucHVzaChkYXRhLCBkZWNyeXB0ZGF0YSwgY2h1bmtNZXRhLCBzdGF0ZSk7XG4gICAgICBpZiAoaXNQcm9taXNlKHRyYW5zbXV4UmVzdWx0KSkge1xuICAgICAgICB0cmFuc211eFJlc3VsdC50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgIHRoaXMuaGFuZGxlVHJhbnNtdXhDb21wbGV0ZShkYXRhKTtcbiAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgIHRoaXMudHJhbnNtdXhlckVycm9yKGVycm9yLCBjaHVua01ldGEsICd0cmFuc211eGVyLWludGVyZmFjZSBwdXNoIGVycm9yJyk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oYW5kbGVUcmFuc211eENvbXBsZXRlKHRyYW5zbXV4UmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZmx1c2goY2h1bmtNZXRhKSB7XG4gICAgY2h1bmtNZXRhLnRyYW5zbXV4aW5nLnN0YXJ0ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCB7XG4gICAgICBpbnN0YW5jZU5vLFxuICAgICAgdHJhbnNtdXhlclxuICAgIH0gPSB0aGlzO1xuICAgIGlmICh0aGlzLndvcmtlckNvbnRleHQpIHtcbiAgICAgIHRoaXMud29ya2VyQ29udGV4dC53b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBpbnN0YW5jZU5vLFxuICAgICAgICBjbWQ6ICdmbHVzaCcsXG4gICAgICAgIGNodW5rTWV0YVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0cmFuc211eGVyKSB7XG4gICAgICBjb25zdCB0cmFuc211eFJlc3VsdCA9IHRyYW5zbXV4ZXIuZmx1c2goY2h1bmtNZXRhKTtcbiAgICAgIGlmIChpc1Byb21pc2UodHJhbnNtdXhSZXN1bHQpKSB7XG4gICAgICAgIHRyYW5zbXV4UmVzdWx0LnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVGbHVzaFJlc3VsdChkYXRhLCBjaHVua01ldGEpO1xuICAgICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgdGhpcy50cmFuc211eGVyRXJyb3IoZXJyb3IsIGNodW5rTWV0YSwgJ3RyYW5zbXV4ZXItaW50ZXJmYWNlIGZsdXNoIGVycm9yJyk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oYW5kbGVGbHVzaFJlc3VsdCh0cmFuc211eFJlc3VsdCwgY2h1bmtNZXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdHJhbnNtdXhlckVycm9yKGVycm9yLCBjaHVua01ldGEsIHJlYXNvbikge1xuICAgIGlmICghdGhpcy5obHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUixcbiAgICAgIGNodW5rTWV0YSxcbiAgICAgIGZyYWc6IHRoaXMuZnJhZyB8fCB1bmRlZmluZWQsXG4gICAgICBwYXJ0OiB0aGlzLnBhcnQgfHwgdW5kZWZpbmVkLFxuICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgZXJyb3IsXG4gICAgICBlcnI6IGVycm9yLFxuICAgICAgcmVhc29uXG4gICAgfSk7XG4gIH1cbiAgaGFuZGxlRmx1c2hSZXN1bHQocmVzdWx0cywgY2h1bmtNZXRhKSB7XG4gICAgcmVzdWx0cy5mb3JFYWNoKHJlc3VsdCA9PiB7XG4gICAgICB0aGlzLmhhbmRsZVRyYW5zbXV4Q29tcGxldGUocmVzdWx0KTtcbiAgICB9KTtcbiAgICB0aGlzLm9uRmx1c2goY2h1bmtNZXRhKTtcbiAgfVxuICBjb25maWd1cmVUcmFuc211eGVyKGNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGluc3RhbmNlTm8sXG4gICAgICB0cmFuc211eGVyXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKHRoaXMud29ya2VyQ29udGV4dCkge1xuICAgICAgdGhpcy53b3JrZXJDb250ZXh0Lndvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgIGluc3RhbmNlTm8sXG4gICAgICAgIGNtZDogJ2NvbmZpZ3VyZScsXG4gICAgICAgIGNvbmZpZ1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0cmFuc211eGVyKSB7XG4gICAgICB0cmFuc211eGVyLmNvbmZpZ3VyZShjb25maWcpO1xuICAgIH1cbiAgfVxuICBoYW5kbGVUcmFuc211eENvbXBsZXRlKHJlc3VsdCkge1xuICAgIHJlc3VsdC5jaHVua01ldGEudHJhbnNtdXhpbmcuZW5kID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICB0aGlzLm9uVHJhbnNtdXhDb21wbGV0ZShyZXN1bHQpO1xuICB9XG59XG5cbmNvbnN0IFRJQ0tfSU5URVJWQUwkMyA9IDEwMDsgLy8gaG93IG9mdGVuIHRvIHRpY2sgaW4gbXNcblxuY2xhc3MgQXVkaW9TdHJlYW1Db250cm9sbGVyIGV4dGVuZHMgQmFzZVN0cmVhbUNvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihobHMsIGZyYWdtZW50VHJhY2tlciwga2V5TG9hZGVyKSB7XG4gICAgc3VwZXIoaGxzLCBmcmFnbWVudFRyYWNrZXIsIGtleUxvYWRlciwgJ2F1ZGlvLXN0cmVhbS1jb250cm9sbGVyJywgUGxheWxpc3RMZXZlbFR5cGUuQVVESU8pO1xuICAgIHRoaXMubWFpbkFuY2hvciA9IG51bGw7XG4gICAgdGhpcy5tYWluRnJhZ0xvYWRpbmcgPSBudWxsO1xuICAgIHRoaXMuYXVkaW9Pbmx5ID0gZmFsc2U7XG4gICAgdGhpcy5idWZmZXJlZFRyYWNrID0gbnVsbDtcbiAgICB0aGlzLnN3aXRjaGluZ1RyYWNrID0gbnVsbDtcbiAgICB0aGlzLnRyYWNrSWQgPSAtMTtcbiAgICB0aGlzLndhaXRpbmdEYXRhID0gbnVsbDtcbiAgICB0aGlzLm1haW5EZXRhaWxzID0gbnVsbDtcbiAgICB0aGlzLmZsdXNoaW5nID0gZmFsc2U7XG4gICAgdGhpcy5idWZmZXJGbHVzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5jYWNoZWRUcmFja0xvYWRlZERhdGEgPSBudWxsO1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICBvbkhhbmRsZXJEZXN0cm95aW5nKCkge1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHN1cGVyLm9uSGFuZGxlckRlc3Ryb3lpbmcoKTtcbiAgICB0aGlzLnJlc2V0SXRlbSgpO1xuICB9XG4gIHJlc2V0SXRlbSgpIHtcbiAgICB0aGlzLm1haW5EZXRhaWxzID0gdGhpcy5tYWluQW5jaG9yID0gdGhpcy5tYWluRnJhZ0xvYWRpbmcgPSB0aGlzLmJ1ZmZlcmVkVHJhY2sgPSB0aGlzLnN3aXRjaGluZ1RyYWNrID0gdGhpcy53YWl0aW5nRGF0YSA9IHRoaXMuY2FjaGVkVHJhY2tMb2FkZWREYXRhID0gbnVsbDtcbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBzdXBlci5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQVVESU9fVFJBQ0tTX1VQREFURUQsIHRoaXMub25BdWRpb1RyYWNrc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENISU5HLCB0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5BVURJT19UUkFDS19MT0FERUQsIHRoaXMub25BdWRpb1RyYWNrTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9SRVNFVCwgdGhpcy5vbkJ1ZmZlclJlc2V0LCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9DUkVBVEVELCB0aGlzLm9uQnVmZmVyQ3JlYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfRkxVU0hFRCwgdGhpcy5vbkJ1ZmZlckZsdXNoZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuSU5JVF9QVFNfRk9VTkQsIHRoaXMub25Jbml0UHRzRm91bmQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19MT0FESU5HLCB0aGlzLm9uRnJhZ0xvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gIH1cbiAgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWhscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkFVRElPX1RSQUNLU19VUERBVEVELCB0aGlzLm9uQXVkaW9UcmFja3NVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hJTkcsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5BVURJT19UUkFDS19MT0FERUQsIHRoaXMub25BdWRpb1RyYWNrTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfUkVTRVQsIHRoaXMub25CdWZmZXJSZXNldCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0NSRUFURUQsIHRoaXMub25CdWZmZXJDcmVhdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0ZMVVNIRUQsIHRoaXMub25CdWZmZXJGbHVzaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5JTklUX1BUU19GT1VORCwgdGhpcy5vbkluaXRQdHNGb3VuZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19MT0FESU5HLCB0aGlzLm9uRnJhZ0xvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICB9XG5cbiAgLy8gSU5JVF9QVFNfRk9VTkQgaXMgdHJpZ2dlcmVkIHdoZW4gdGhlIHZpZGVvIHRyYWNrIHBhcnNlZCBpbiB0aGUgc3RyZWFtLWNvbnRyb2xsZXIgaGFzIGEgbmV3IFBUUyB2YWx1ZVxuICBvbkluaXRQdHNGb3VuZChldmVudCwge1xuICAgIGZyYWcsXG4gICAgaWQsXG4gICAgaW5pdFBUUyxcbiAgICB0aW1lc2NhbGVcbiAgfSkge1xuICAgIC8vIEFsd2F5cyB1cGRhdGUgdGhlIG5ldyBJTklUIFBUU1xuICAgIC8vIENhbiBjaGFuZ2UgZHVlIGxldmVsIHN3aXRjaFxuICAgIGlmIChpZCA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTikge1xuICAgICAgY29uc3QgY2MgPSBmcmFnLmNjO1xuICAgICAgY29uc3QgaW5GbGlnaHRGcmFnID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICAgIHRoaXMuaW5pdFBUU1tjY10gPSB7XG4gICAgICAgIGJhc2VUaW1lOiBpbml0UFRTLFxuICAgICAgICB0aW1lc2NhbGVcbiAgICAgIH07XG4gICAgICB0aGlzLmxvZyhgSW5pdFBUUyBmb3IgY2M6ICR7Y2N9IGZvdW5kIGZyb20gbWFpbjogJHtpbml0UFRTfS8ke3RpbWVzY2FsZX1gKTtcbiAgICAgIHRoaXMubWFpbkFuY2hvciA9IGZyYWc7XG4gICAgICAvLyBJZiB3ZSBhcmUgd2FpdGluZywgdGljayBpbW1lZGlhdGVseSB0byB1bmJsb2NrIGF1ZGlvIGZyYWdtZW50IHRyYW5zbXV4aW5nXG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19JTklUX1BUUykge1xuICAgICAgICBjb25zdCB3YWl0aW5nRGF0YSA9IHRoaXMud2FpdGluZ0RhdGE7XG4gICAgICAgIGlmICghd2FpdGluZ0RhdGEgJiYgIXRoaXMubG9hZGluZ1BhcnRzIHx8IHdhaXRpbmdEYXRhICYmIHdhaXRpbmdEYXRhLmZyYWcuY2MgIT09IGNjKSB7XG4gICAgICAgICAgdGhpcy5zeW5jV2l0aEFuY2hvcihmcmFnLCB3YWl0aW5nRGF0YSA9PSBudWxsID8gdm9pZCAwIDogd2FpdGluZ0RhdGEuZnJhZyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuaGxzLmhhc0Vub3VnaFRvU3RhcnQgJiYgaW5GbGlnaHRGcmFnICYmIGluRmxpZ2h0RnJhZy5jYyAhPT0gY2MpIHtcbiAgICAgICAgaW5GbGlnaHRGcmFnLmFib3J0UmVxdWVzdHMoKTtcbiAgICAgICAgdGhpcy5zeW5jV2l0aEFuY2hvcihmcmFnLCBpbkZsaWdodEZyYWcpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5JRExFKSB7XG4gICAgICAgIHRoaXMudGljaygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXRMb2FkUG9zaXRpb24oKSB7XG4gICAgaWYgKCF0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCAmJiB0aGlzLm5leHRMb2FkUG9zaXRpb24gPj0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMubmV4dExvYWRQb3NpdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmdldExvYWRQb3NpdGlvbigpO1xuICB9XG4gIHN5bmNXaXRoQW5jaG9yKG1haW5BbmNob3IsIHdhaXRpbmdUb0FwcGVuZCkge1xuICAgIHZhciBfdGhpcyRtYWluRnJhZ0xvYWRpbmc7XG4gICAgLy8gRHJvcCB3YWl0aW5nIGZyYWdtZW50IGlmIHZpZGVvVHJhY2tDQyBoYXMgY2hhbmdlZCBzaW5jZSB3YWl0aW5nRnJhZ21lbnQgd2FzIHNldCBhbmQgaW5pdFBUUyB3YXMgbm90IGZvdW5kXG4gICAgY29uc3QgbWFpbkZyYWdMb2FkaW5nID0gKChfdGhpcyRtYWluRnJhZ0xvYWRpbmcgPSB0aGlzLm1haW5GcmFnTG9hZGluZykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG1haW5GcmFnTG9hZGluZy5mcmFnKSB8fCBudWxsO1xuICAgIGlmICh3YWl0aW5nVG9BcHBlbmQpIHtcbiAgICAgIGlmICgobWFpbkZyYWdMb2FkaW5nID09IG51bGwgPyB2b2lkIDAgOiBtYWluRnJhZ0xvYWRpbmcuY2MpID09PSB3YWl0aW5nVG9BcHBlbmQuY2MpIHtcbiAgICAgICAgLy8gV2FpdCBmb3IgbG9hZGluZyBmcmFnIHRvIGNvbXBsZXRlIGFuZCBJTklUX1BUU19GT1VORFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldERpc2NvbnRpbnVpdHkgPSAobWFpbkZyYWdMb2FkaW5nIHx8IG1haW5BbmNob3IpLmNjO1xuICAgIGNvbnN0IHRyYWNrRGV0YWlscyA9IHRoaXMuZ2V0TGV2ZWxEZXRhaWxzKCk7XG4gICAgY29uc3QgcG9zID0gdGhpcy5nZXRMb2FkUG9zaXRpb24oKTtcbiAgICBjb25zdCBzeW5jRnJhZyA9IGZpbmROZWFyZXN0V2l0aENDKHRyYWNrRGV0YWlscywgdGFyZ2V0RGlzY29udGludWl0eSwgcG9zKTtcbiAgICAvLyBPbmx5IHN0b3Agd2FpdGluZyBmb3IgYXVkaW9GcmFnLmNjIGlmIGFuIGF1ZGlvIHNlZ21lbnQgb2YgdGhlIHNhbWUgZGlzY29udGludWl0eSBkb21haW4gKGNjKSBpcyBmb3VuZFxuICAgIGlmIChzeW5jRnJhZykge1xuICAgICAgdGhpcy5sb2coYFN5bmNpbmcgd2l0aCBtYWluIGZyYWcgYXQgJHtzeW5jRnJhZy5zdGFydH0gY2MgJHtzeW5jRnJhZy5jY31gKTtcbiAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBzeW5jRnJhZy5zdGFydDtcbiAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5JRExFKSB7XG4gICAgICAgIHRoaXMuZG9UaWNrSWRsZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdGFydExvYWQoc3RhcnRQb3NpdGlvbiwgc2tpcFNlZWtUb1N0YXJ0UG9zaXRpb24pIHtcbiAgICBpZiAoIXRoaXMubGV2ZWxzKSB7XG4gICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBzdGFydFBvc2l0aW9uO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxhc3RDdXJyZW50VGltZSA9IHRoaXMubGFzdEN1cnJlbnRUaW1lO1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICB0aGlzLnNldEludGVydmFsKFRJQ0tfSU5URVJWQUwkMyk7XG4gICAgaWYgKGxhc3RDdXJyZW50VGltZSA+IDAgJiYgc3RhcnRQb3NpdGlvbiA9PT0gLTEpIHtcbiAgICAgIHRoaXMubG9nKGBPdmVycmlkZSBzdGFydFBvc2l0aW9uIHdpdGggbGFzdEN1cnJlbnRUaW1lIEAke2xhc3RDdXJyZW50VGltZS50b0ZpeGVkKDMpfWApO1xuICAgICAgc3RhcnRQb3NpdGlvbiA9IGxhc3RDdXJyZW50VGltZTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19UUkFDSztcbiAgICB9XG4gICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBzdGFydFBvc2l0aW9uICsgdGhpcy50aW1lbGluZU9mZnNldDtcbiAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBza2lwU2Vla1RvU3RhcnRQb3NpdGlvbiA/IC0xIDogc3RhcnRQb3NpdGlvbjtcbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuICBkb1RpY2soKSB7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIFN0YXRlLklETEU6XG4gICAgICAgIHRoaXMuZG9UaWNrSWRsZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RhdGUuV0FJVElOR19UUkFDSzpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGxldmVscyxcbiAgICAgICAgICAgIHRyYWNrSWRcbiAgICAgICAgICB9ID0gdGhpcztcbiAgICAgICAgICBjb25zdCBjdXJyZW5UcmFjayA9IGxldmVscyA9PSBudWxsID8gdm9pZCAwIDogbGV2ZWxzW3RyYWNrSWRdO1xuICAgICAgICAgIGNvbnN0IGRldGFpbHMgPSBjdXJyZW5UcmFjayA9PSBudWxsID8gdm9pZCAwIDogY3VycmVuVHJhY2suZGV0YWlscztcbiAgICAgICAgICBpZiAoZGV0YWlscyAmJiAhdGhpcy53YWl0Rm9yTGl2ZShjdXJyZW5UcmFjaykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLndhaXRGb3JDZG5UdW5lSW4oZGV0YWlscykpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19JTklUX1BUUztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX3RoaXMkbWVkaWE7XG4gICAgICAgICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgY29uc3QgcmV0cnlEYXRlID0gdGhpcy5yZXRyeURhdGU7XG4gICAgICAgICAgLy8gaWYgY3VycmVudCB0aW1lIGlzIGd0IHRoYW4gcmV0cnlEYXRlLCBvciBpZiBtZWRpYSBzZWVraW5nIGxldCdzIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIHJldHJ5IGxvYWRpbmdcbiAgICAgICAgICBpZiAoIXJldHJ5RGF0ZSB8fCBub3cgPj0gcmV0cnlEYXRlIHx8IChfdGhpcyRtZWRpYSA9IHRoaXMubWVkaWEpICE9IG51bGwgJiYgX3RoaXMkbWVkaWEuc2Vla2luZykge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBsZXZlbHMsXG4gICAgICAgICAgICAgIHRyYWNrSWRcbiAgICAgICAgICAgIH0gPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5sb2coJ1JldHJ5RGF0ZSByZWFjaGVkLCBzd2l0Y2ggYmFjayB0byBJRExFIHN0YXRlJyk7XG4gICAgICAgICAgICB0aGlzLnJlc2V0U3RhcnRXaGVuTm90TG9hZGVkKChsZXZlbHMgPT0gbnVsbCA/IHZvaWQgMCA6IGxldmVsc1t0cmFja0lkXSkgfHwgbnVsbCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgU3RhdGUuV0FJVElOR19JTklUX1BUUzpcbiAgICAgICAge1xuICAgICAgICAgIC8vIEVuc3VyZSB3ZSBkb24ndCBnZXQgc3R1Y2sgaW4gdGhlIFdBSVRJTkdfSU5JVF9QVFMgc3RhdGUgaWYgdGhlIHdhaXRpbmcgZnJhZyBDQyBkb2Vzbid0IG1hdGNoIGFueSBpbml0UFRTXG4gICAgICAgICAgY29uc3Qgd2FpdGluZ0RhdGEgPSB0aGlzLndhaXRpbmdEYXRhO1xuICAgICAgICAgIGlmICh3YWl0aW5nRGF0YSkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICAgICAgY29tcGxldGVcbiAgICAgICAgICAgIH0gPSB3YWl0aW5nRGF0YTtcbiAgICAgICAgICAgIGNvbnN0IG1haW5BbmNob3IgPSB0aGlzLm1haW5BbmNob3I7XG4gICAgICAgICAgICBpZiAodGhpcy5pbml0UFRTW2ZyYWcuY2NdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdGhpcy53YWl0aW5nRGF0YSA9IG51bGw7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5GUkFHX0xPQURJTkc7XG4gICAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBjYWNoZS5mbHVzaCgpLmJ1ZmZlcjtcbiAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgICAgIHBhcnQsXG4gICAgICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbnVsbFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVGcmFnbWVudExvYWRQcm9ncmVzcyhkYXRhKTtcbiAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgc3VwZXIuX2hhbmRsZUZyYWdtZW50TG9hZENvbXBsZXRlKGRhdGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1haW5BbmNob3IgJiYgbWFpbkFuY2hvci5jYyAhPT0gd2FpdGluZ0RhdGEuZnJhZy5jYykge1xuICAgICAgICAgICAgICB0aGlzLnN5bmNXaXRoQW5jaG9yKG1haW5BbmNob3IsIHdhaXRpbmdEYXRhLmZyYWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5vblRpY2tFbmQoKTtcbiAgfVxuICByZXNldExvYWRpbmdTdGF0ZSgpIHtcbiAgICBjb25zdCB3YWl0aW5nRGF0YSA9IHRoaXMud2FpdGluZ0RhdGE7XG4gICAgaWYgKHdhaXRpbmdEYXRhKSB7XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudCh3YWl0aW5nRGF0YS5mcmFnKTtcbiAgICAgIHRoaXMud2FpdGluZ0RhdGEgPSBudWxsO1xuICAgIH1cbiAgICBzdXBlci5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICB9XG4gIG9uVGlja0VuZCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBtZWRpYVxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghKG1lZGlhICE9IG51bGwgJiYgbWVkaWEucmVhZHlTdGF0ZSkpIHtcbiAgICAgIC8vIEV4aXQgZWFybHkgaWYgd2UgZG9uJ3QgaGF2ZSBtZWRpYSBvciBpZiB0aGUgbWVkaWEgaGFzbid0IGJ1ZmZlcmVkIGFueXRoaW5nIHlldCAocmVhZHlTdGF0ZSAwKVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICB9XG4gIGRvVGlja0lkbGUoKSB7XG4gICAgdmFyIF90aGlzJG1haW5GcmFnTG9hZGluZzI7XG4gICAgY29uc3Qge1xuICAgICAgaGxzLFxuICAgICAgbGV2ZWxzLFxuICAgICAgbWVkaWEsXG4gICAgICB0cmFja0lkXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgY29uZmlnID0gaGxzLmNvbmZpZztcblxuICAgIC8vIDEuIGlmIGJ1ZmZlcmluZyBpcyBzdXNwZW5kZWRcbiAgICAvLyAyLiBpZiB2aWRlbyBub3QgYXR0YWNoZWQgQU5EXG4gICAgLy8gICAgc3RhcnQgZnJhZ21lbnQgYWxyZWFkeSByZXF1ZXN0ZWQgT1Igc3RhcnQgZnJhZyBwcmVmZXRjaCBub3QgZW5hYmxlZFxuICAgIC8vIDMuIGlmIHRyYWNrcyBvciB0cmFjayBub3QgbG9hZGVkIGFuZCBzZWxlY3RlZFxuICAgIC8vIHRoZW4gZXhpdCBsb29wXG4gICAgLy8gPT4gaWYgbWVkaWEgbm90IGF0dGFjaGVkIGJ1dCBzdGFydCBmcmFnIHByZWZldGNoIGlzIGVuYWJsZWQgYW5kIHN0YXJ0IGZyYWcgbm90IHJlcXVlc3RlZCB5ZXQsIHdlIHdpbGwgbm90IGV4aXQgbG9vcFxuICAgIGlmICghdGhpcy5idWZmZXJpbmcgfHwgIW1lZGlhICYmICF0aGlzLnByaW1hcnlQcmVmZXRjaCAmJiAodGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgfHwgIWNvbmZpZy5zdGFydEZyYWdQcmVmZXRjaCkgfHwgIShsZXZlbHMgIT0gbnVsbCAmJiBsZXZlbHNbdHJhY2tJZF0pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxldmVsSW5mbyA9IGxldmVsc1t0cmFja0lkXTtcbiAgICBjb25zdCB0cmFja0RldGFpbHMgPSBsZXZlbEluZm8uZGV0YWlscztcbiAgICBpZiAoIXRyYWNrRGV0YWlscyB8fCB0aGlzLndhaXRGb3JMaXZlKGxldmVsSW5mbykgfHwgdGhpcy53YWl0Rm9yQ2RuVHVuZUluKHRyYWNrRGV0YWlscykpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5XQUlUSU5HX1RSQUNLO1xuICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYnVmZmVyYWJsZSA9IHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogdGhpcy5tZWRpYTtcbiAgICBpZiAodGhpcy5idWZmZXJGbHVzaGVkICYmIGJ1ZmZlcmFibGUpIHtcbiAgICAgIHRoaXMuYnVmZmVyRmx1c2hlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5hZnRlckJ1ZmZlckZsdXNoZWQoYnVmZmVyYWJsZSwgRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPLCBQbGF5bGlzdExldmVsVHlwZS5BVURJTyk7XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSB0aGlzLmdldEZ3ZEJ1ZmZlckluZm8oYnVmZmVyYWJsZSwgUGxheWxpc3RMZXZlbFR5cGUuQVVESU8pO1xuICAgIGlmIChidWZmZXJJbmZvID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5zd2l0Y2hpbmdUcmFjayAmJiB0aGlzLl9zdHJlYW1FbmRlZChidWZmZXJJbmZvLCB0cmFja0RldGFpbHMpKSB7XG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0VPUywge1xuICAgICAgICB0eXBlOiAnYXVkaW8nXG4gICAgICB9KTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5FTkRFRDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYnVmZmVyTGVuID0gYnVmZmVySW5mby5sZW47XG4gICAgY29uc3QgbWF4QnVmTGVuID0gaGxzLm1heEJ1ZmZlckxlbmd0aDtcbiAgICBjb25zdCBmcmFnbWVudHMgPSB0cmFja0RldGFpbHMuZnJhZ21lbnRzO1xuICAgIGNvbnN0IHN0YXJ0ID0gZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgIGNvbnN0IGxvYWRQb3NpdGlvbiA9IHRoaXMuZ2V0TG9hZFBvc2l0aW9uKCk7XG4gICAgY29uc3QgdGFyZ2V0QnVmZmVyVGltZSA9IHRoaXMuZmx1c2hpbmcgPyBsb2FkUG9zaXRpb24gOiBidWZmZXJJbmZvLmVuZDtcbiAgICBpZiAodGhpcy5zd2l0Y2hpbmdUcmFjayAmJiBtZWRpYSkge1xuICAgICAgY29uc3QgcG9zID0gbG9hZFBvc2l0aW9uO1xuICAgICAgLy8gaWYgY3VycmVudFRpbWUgKHBvcykgaXMgbGVzcyB0aGFuIGFsdCBhdWRpbyBwbGF5bGlzdCBzdGFydCB0aW1lLCBpdCBtZWFucyB0aGF0IGFsdCBhdWRpbyBpcyBhaGVhZCBvZiBjdXJyZW50VGltZVxuICAgICAgaWYgKHRyYWNrRGV0YWlscy5QVFNLbm93biAmJiBwb3MgPCBzdGFydCkge1xuICAgICAgICAvLyBpZiBldmVyeXRoaW5nIGlzIGJ1ZmZlcmVkIGZyb20gcG9zIHRvIHN0YXJ0IG9yIGlmIGF1ZGlvIGJ1ZmZlciB1cGZyb250LCBsZXQncyBzZWVrIHRvIHN0YXJ0XG4gICAgICAgIGlmIChidWZmZXJJbmZvLmVuZCA+IHN0YXJ0IHx8IGJ1ZmZlckluZm8ubmV4dFN0YXJ0KSB7XG4gICAgICAgICAgdGhpcy5sb2coJ0FsdCBhdWRpbyB0cmFjayBhaGVhZCBvZiBtYWluIHRyYWNrLCBzZWVrIHRvIHN0YXJ0IG9mIGFsdCBhdWRpbyB0cmFjaycpO1xuICAgICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gc3RhcnQgKyAwLjA1O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgYnVmZmVyIGxlbmd0aCBpcyBsZXNzIHRoYW4gbWF4QnVmTGVuLCBvciBuZWFyIHRoZSBlbmQsIGZpbmQgYSBmcmFnbWVudCB0byBsb2FkXG4gICAgaWYgKGJ1ZmZlckxlbiA+PSBtYXhCdWZMZW4gJiYgIXRoaXMuc3dpdGNoaW5nVHJhY2sgJiYgdGFyZ2V0QnVmZmVyVGltZSA8IGZyYWdtZW50c1tmcmFnbWVudHMubGVuZ3RoIC0gMV0uc3RhcnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGZyYWcgPSB0aGlzLmdldE5leHRGcmFnbWVudCh0YXJnZXRCdWZmZXJUaW1lLCB0cmFja0RldGFpbHMpO1xuICAgIC8vIEF2b2lkIGxvb3AgbG9hZGluZyBieSB1c2luZyBuZXh0TG9hZFBvc2l0aW9uIHNldCBmb3IgYmFja3RyYWNraW5nIGFuZCBza2lwcGluZyBjb25zZWN1dGl2ZSBHQVAgdGFnc1xuICAgIGlmIChmcmFnICYmIHRoaXMuaXNMb29wTG9hZGluZyhmcmFnLCB0YXJnZXRCdWZmZXJUaW1lKSkge1xuICAgICAgZnJhZyA9IHRoaXMuZ2V0TmV4dEZyYWdtZW50TG9vcExvYWRpbmcoZnJhZywgdHJhY2tEZXRhaWxzLCBidWZmZXJJbmZvLCBQbGF5bGlzdExldmVsVHlwZS5NQUlOLCBtYXhCdWZMZW4pO1xuICAgIH1cbiAgICBpZiAoIWZyYWcpIHtcbiAgICAgIHRoaXMuYnVmZmVyRmx1c2hlZCA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUmVxdWVzdCBhdWRpbyBzZWdtZW50cyB1cCB0byBvbmUgZnJhZ21lbnQgYWhlYWQgb2YgbWFpbiBzdHJlYW0tY29udHJvbGxlclxuICAgIGxldCBtYWluRnJhZ0xvYWRpbmcgPSAoKF90aGlzJG1haW5GcmFnTG9hZGluZzIgPSB0aGlzLm1haW5GcmFnTG9hZGluZykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG1haW5GcmFnTG9hZGluZzIuZnJhZykgfHwgbnVsbDtcbiAgICBpZiAoIXRoaXMuYXVkaW9Pbmx5ICYmIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkICYmIG1haW5GcmFnTG9hZGluZyAmJiBpc01lZGlhRnJhZ21lbnQoZnJhZykgJiYgIWZyYWcuZW5kTGlzdCAmJiAoIXRyYWNrRGV0YWlscy5saXZlIHx8ICF0aGlzLmxvYWRpbmdQYXJ0cyAmJiB0YXJnZXRCdWZmZXJUaW1lIDwgdGhpcy5obHMubGl2ZVN5bmNQb3NpdGlvbikpIHtcbiAgICAgIGlmICh0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShtYWluRnJhZ0xvYWRpbmcpID09PSBGcmFnbWVudFN0YXRlLk9LKSB7XG4gICAgICAgIHRoaXMubWFpbkZyYWdMb2FkaW5nID0gbWFpbkZyYWdMb2FkaW5nID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChtYWluRnJhZ0xvYWRpbmcgJiYgaXNNZWRpYUZyYWdtZW50KG1haW5GcmFnTG9hZGluZykpIHtcbiAgICAgICAgaWYgKGZyYWcuc3RhcnQgPiBtYWluRnJhZ0xvYWRpbmcuZW5kKSB7XG4gICAgICAgICAgLy8gR2V0IGJ1ZmZlcmVkIGZyYWcgYXQgdGFyZ2V0IHBvc2l0aW9uIGZyb20gdHJhY2tlciAobG9hZGVkIG91dCBvZiBzZXF1ZW5jZSlcbiAgICAgICAgICBjb25zdCBtYWluRnJhZ0F0UG9zID0gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0RnJhZ0F0UG9zKHRhcmdldEJ1ZmZlclRpbWUsIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pO1xuICAgICAgICAgIGlmIChtYWluRnJhZ0F0UG9zICYmIG1haW5GcmFnQXRQb3MuZW5kID4gbWFpbkZyYWdMb2FkaW5nLmVuZCkge1xuICAgICAgICAgICAgbWFpbkZyYWdMb2FkaW5nID0gbWFpbkZyYWdBdFBvcztcbiAgICAgICAgICAgIHRoaXMubWFpbkZyYWdMb2FkaW5nID0ge1xuICAgICAgICAgICAgICBmcmFnOiBtYWluRnJhZ0F0UG9zLFxuICAgICAgICAgICAgICB0YXJnZXRCdWZmZXJUaW1lOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhdEJ1ZmZlclN5bmNMaW1pdCA9IGZyYWcuc3RhcnQgPiBtYWluRnJhZ0xvYWRpbmcuZW5kO1xuICAgICAgICBpZiAoYXRCdWZmZXJTeW5jTGltaXQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sb2FkRnJhZ21lbnQoZnJhZywgbGV2ZWxJbmZvLCB0YXJnZXRCdWZmZXJUaW1lKTtcbiAgfVxuICBvbk1lZGlhRGV0YWNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5idWZmZXJGbHVzaGVkID0gdGhpcy5mbHVzaGluZyA9IGZhbHNlO1xuICAgIHN1cGVyLm9uTWVkaWFEZXRhY2hpbmcoZXZlbnQsIGRhdGEpO1xuICB9XG4gIG9uQXVkaW9UcmFja3NVcGRhdGVkKGV2ZW50LCB7XG4gICAgYXVkaW9UcmFja3NcbiAgfSkge1xuICAgIC8vIFJlc2V0IHRyYW54bXV4ZXIgaXMgZXNzZW50aWFsIGZvciBsYXJnZSBjb250ZXh0IHN3aXRjaGVzIChDb250ZW50IFN0ZWVyaW5nKVxuICAgIHRoaXMucmVzZXRUcmFuc211eGVyKCk7XG4gICAgdGhpcy5sZXZlbHMgPSBhdWRpb1RyYWNrcy5tYXAobWVkaWFQbGF5bGlzdCA9PiBuZXcgTGV2ZWwobWVkaWFQbGF5bGlzdCkpO1xuICB9XG4gIG9uQXVkaW9UcmFja1N3aXRjaGluZyhldmVudCwgZGF0YSkge1xuICAgIC8vIGlmIGFueSBVUkwgZm91bmQgb24gbmV3IGF1ZGlvIHRyYWNrLCBpdCBpcyBhbiBhbHRlcm5hdGUgYXVkaW8gdHJhY2tcbiAgICBjb25zdCBhbHRBdWRpbyA9ICEhZGF0YS51cmw7XG4gICAgdGhpcy50cmFja0lkID0gZGF0YS5pZDtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnQ3VycmVudFxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChmcmFnQ3VycmVudCkge1xuICAgICAgZnJhZ0N1cnJlbnQuYWJvcnRSZXF1ZXN0cygpO1xuICAgICAgdGhpcy5yZW1vdmVVbmJ1ZmZlcmVkRnJhZ3MoZnJhZ0N1cnJlbnQuc3RhcnQpO1xuICAgIH1cbiAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG5cbiAgICAvLyBzaG91bGQgd2Ugc3dpdGNoIHRyYWNrcyA/XG4gICAgaWYgKGFsdEF1ZGlvKSB7XG4gICAgICB0aGlzLnN3aXRjaGluZ1RyYWNrID0gZGF0YTtcbiAgICAgIC8vIG1haW4gYXVkaW8gdHJhY2sgYXJlIGhhbmRsZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXIsIGp1c3QgZG8gc29tZXRoaW5nIGlmIHN3aXRjaGluZyB0byBhbHQgYXVkaW8gdHJhY2tcbiAgICAgIHRoaXMuZmx1c2hBdWRpb0lmTmVlZGVkKGRhdGEpO1xuICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFN0YXRlLlNUT1BQRUQpIHtcbiAgICAgICAgLy8gc3dpdGNoaW5nIHRvIGF1ZGlvIHRyYWNrLCBzdGFydCB0aW1lciBpZiBub3QgYWxyZWFkeSBzdGFydGVkXG4gICAgICAgIHRoaXMuc2V0SW50ZXJ2YWwoVElDS19JTlRFUlZBTCQzKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgIHRoaXMudGljaygpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkZXN0cm95IHVzZWxlc3MgdHJhbnNtdXhlciB3aGVuIHN3aXRjaGluZyBhdWRpbyB0byBtYWluXG4gICAgICB0aGlzLnJlc2V0VHJhbnNtdXhlcigpO1xuICAgICAgdGhpcy5zd2l0Y2hpbmdUcmFjayA9IG51bGw7XG4gICAgICB0aGlzLmJ1ZmZlcmVkVHJhY2sgPSBkYXRhO1xuICAgICAgdGhpcy5jbGVhckludGVydmFsKCk7XG4gICAgfVxuICB9XG4gIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHN1cGVyLm9uTWFuaWZlc3RMb2FkaW5nKCk7XG4gICAgdGhpcy5idWZmZXJGbHVzaGVkID0gdGhpcy5mbHVzaGluZyA9IHRoaXMuYXVkaW9Pbmx5ID0gZmFsc2U7XG4gICAgdGhpcy5yZXNldEl0ZW0oKTtcbiAgICB0aGlzLnRyYWNrSWQgPSAtMTtcbiAgfVxuICBvbkxldmVsTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5tYWluRGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICBjb25zdCBjYWNoZWRUcmFja0xvYWRlZERhdGEgPSB0aGlzLmNhY2hlZFRyYWNrTG9hZGVkRGF0YTtcbiAgICBpZiAoY2FjaGVkVHJhY2tMb2FkZWREYXRhKSB7XG4gICAgICB0aGlzLmNhY2hlZFRyYWNrTG9hZGVkRGF0YSA9IG51bGw7XG4gICAgICB0aGlzLm9uQXVkaW9UcmFja0xvYWRlZChFdmVudHMuQVVESU9fVFJBQ0tfTE9BREVELCBjYWNoZWRUcmFja0xvYWRlZERhdGEpO1xuICAgIH1cbiAgfVxuICBvbkF1ZGlvVHJhY2tMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgX3RyYWNrTGV2ZWwkZGV0YWlscztcbiAgICBjb25zdCB7XG4gICAgICBsZXZlbHNcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBkZXRhaWxzOiBuZXdEZXRhaWxzLFxuICAgICAgaWQ6IHRyYWNrSWQsXG4gICAgICBncm91cElkLFxuICAgICAgdHJhY2tcbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoIWxldmVscykge1xuICAgICAgdGhpcy53YXJuKGBBdWRpbyB0cmFja3MgcmVzZXQgd2hpbGUgbG9hZGluZyB0cmFjayAke3RyYWNrSWR9IFwiJHt0cmFjay5uYW1lfVwiIG9mIFwiJHtncm91cElkfVwiYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1haW5EZXRhaWxzID0gdGhpcy5tYWluRGV0YWlscztcbiAgICBpZiAoIW1haW5EZXRhaWxzIHx8IG5ld0RldGFpbHMuZW5kQ0MgPiBtYWluRGV0YWlscy5lbmRDQyB8fCBtYWluRGV0YWlscy5leHBpcmVkKSB7XG4gICAgICB0aGlzLmNhY2hlZFRyYWNrTG9hZGVkRGF0YSA9IGRhdGE7XG4gICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU3RhdGUuU1RPUFBFRCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19UUkFDSztcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jYWNoZWRUcmFja0xvYWRlZERhdGEgPSBudWxsO1xuICAgIHRoaXMubG9nKGBBdWRpbyB0cmFjayAke3RyYWNrSWR9IFwiJHt0cmFjay5uYW1lfVwiIG9mIFwiJHtncm91cElkfVwiIGxvYWRlZCBbJHtuZXdEZXRhaWxzLnN0YXJ0U059LCR7bmV3RGV0YWlscy5lbmRTTn1dJHtuZXdEZXRhaWxzLmxhc3RQYXJ0U24gPyBgW3BhcnQtJHtuZXdEZXRhaWxzLmxhc3RQYXJ0U259LSR7bmV3RGV0YWlscy5sYXN0UGFydEluZGV4fV1gIDogJyd9LGR1cmF0aW9uOiR7bmV3RGV0YWlscy50b3RhbGR1cmF0aW9ufWApO1xuICAgIGNvbnN0IHRyYWNrTGV2ZWwgPSBsZXZlbHNbdHJhY2tJZF07XG4gICAgbGV0IHNsaWRpbmcgPSAwO1xuICAgIGlmIChuZXdEZXRhaWxzLmxpdmUgfHwgKF90cmFja0xldmVsJGRldGFpbHMgPSB0cmFja0xldmVsLmRldGFpbHMpICE9IG51bGwgJiYgX3RyYWNrTGV2ZWwkZGV0YWlscy5saXZlKSB7XG4gICAgICB0aGlzLmNoZWNrTGl2ZVVwZGF0ZShuZXdEZXRhaWxzKTtcbiAgICAgIGlmIChuZXdEZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFja0xldmVsLmRldGFpbHMpIHtcbiAgICAgICAgdmFyIF90aGlzJGxldmVsTGFzdExvYWRlZDtcbiAgICAgICAgc2xpZGluZyA9IHRoaXMuYWxpZ25QbGF5bGlzdHMobmV3RGV0YWlscywgdHJhY2tMZXZlbC5kZXRhaWxzLCAoX3RoaXMkbGV2ZWxMYXN0TG9hZGVkID0gdGhpcy5sZXZlbExhc3RMb2FkZWQpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRsZXZlbExhc3RMb2FkZWQuZGV0YWlscyk7XG4gICAgICB9XG4gICAgICBpZiAoIW5ld0RldGFpbHMuYWxpZ25lZFNsaWRpbmcpIHtcbiAgICAgICAgLy8gQWxpZ24gYXVkaW8gcmVuZGl0aW9uIHdpdGggdGhlIFwibWFpblwiIHBsYXlsaXN0IG9uIGRpc2NvbnRpbnVpdHkgY2hhbmdlXG4gICAgICAgIC8vIG9yIHByb2dyYW0tZGF0ZS10aW1lIChQRFQpXG4gICAgICAgIGFsaWduRGlzY29udGludWl0aWVzKG5ld0RldGFpbHMsIG1haW5EZXRhaWxzKTtcbiAgICAgICAgaWYgKCFuZXdEZXRhaWxzLmFsaWduZWRTbGlkaW5nKSB7XG4gICAgICAgICAgYWxpZ25NZWRpYVBsYXlsaXN0QnlQRFQobmV3RGV0YWlscywgbWFpbkRldGFpbHMpO1xuICAgICAgICB9XG4gICAgICAgIHNsaWRpbmcgPSBuZXdEZXRhaWxzLmZyYWdtZW50U3RhcnQ7XG4gICAgICB9XG4gICAgfVxuICAgIHRyYWNrTGV2ZWwuZGV0YWlscyA9IG5ld0RldGFpbHM7XG4gICAgdGhpcy5sZXZlbExhc3RMb2FkZWQgPSB0cmFja0xldmVsO1xuXG4gICAgLy8gY29tcHV0ZSBzdGFydCBwb3NpdGlvbiBpZiB3ZSBhcmUgYWxpZ25lZCB3aXRoIHRoZSBtYWluIHBsYXlsaXN0XG4gICAgaWYgKCF0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCkge1xuICAgICAgdGhpcy5zZXRTdGFydFBvc2l0aW9uKG1haW5EZXRhaWxzLCBzbGlkaW5nKTtcbiAgICB9XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQVVESU9fVFJBQ0tfVVBEQVRFRCwge1xuICAgICAgZGV0YWlsczogbmV3RGV0YWlscyxcbiAgICAgIGlkOiB0cmFja0lkLFxuICAgICAgZ3JvdXBJZDogZGF0YS5ncm91cElkXG4gICAgfSk7XG5cbiAgICAvLyBvbmx5IHN3aXRjaCBiYWNrIHRvIElETEUgc3RhdGUgaWYgd2Ugd2VyZSB3YWl0aW5nIGZvciB0cmFjayB0byBzdGFydCBkb3dubG9hZGluZyBhIG5ldyBmcmFnbWVudFxuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5XQUlUSU5HX1RSQUNLICYmICF0aGlzLndhaXRGb3JDZG5UdW5lSW4obmV3RGV0YWlscykpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIH1cblxuICAgIC8vIHRyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuICBfaGFuZGxlRnJhZ21lbnRMb2FkUHJvZ3Jlc3MoZGF0YSkge1xuICAgIHZhciBfZnJhZyRpbml0U2VnbWVudDtcbiAgICBjb25zdCBmcmFnID0gZGF0YS5mcmFnO1xuICAgIGNvbnN0IHtcbiAgICAgIHBhcnQsXG4gICAgICBwYXlsb2FkXG4gICAgfSA9IGRhdGE7XG4gICAgY29uc3Qge1xuICAgICAgY29uZmlnLFxuICAgICAgdHJhY2tJZCxcbiAgICAgIGxldmVsc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmICghbGV2ZWxzKSB7XG4gICAgICB0aGlzLndhcm4oYEF1ZGlvIHRyYWNrcyB3ZXJlIHJlc2V0IHdoaWxlIGZyYWdtZW50IGxvYWQgd2FzIGluIHByb2dyZXNzLiBGcmFnbWVudCAke2ZyYWcuc259IG9mIGxldmVsICR7ZnJhZy5sZXZlbH0gd2lsbCBub3QgYmUgYnVmZmVyZWRgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdHJhY2sgPSBsZXZlbHNbdHJhY2tJZF07XG4gICAgaWYgKCF0cmFjaykge1xuICAgICAgdGhpcy53YXJuKCdBdWRpbyB0cmFjayBpcyB1bmRlZmluZWQgb24gZnJhZ21lbnQgbG9hZCBwcm9ncmVzcycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkZXRhaWxzID0gdHJhY2suZGV0YWlscztcbiAgICBpZiAoIWRldGFpbHMpIHtcbiAgICAgIHRoaXMud2FybignQXVkaW8gdHJhY2sgZGV0YWlscyB1bmRlZmluZWQgb24gZnJhZ21lbnQgbG9hZCBwcm9ncmVzcycpO1xuICAgICAgdGhpcy5yZW1vdmVVbmJ1ZmZlcmVkRnJhZ3MoZnJhZy5zdGFydCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGF1ZGlvQ29kZWMgPSBjb25maWcuZGVmYXVsdEF1ZGlvQ29kZWMgfHwgdHJhY2suYXVkaW9Db2RlYyB8fCAnbXA0YS40MC4yJztcbiAgICBsZXQgdHJhbnNtdXhlciA9IHRoaXMudHJhbnNtdXhlcjtcbiAgICBpZiAoIXRyYW5zbXV4ZXIpIHtcbiAgICAgIHRyYW5zbXV4ZXIgPSB0aGlzLnRyYW5zbXV4ZXIgPSBuZXcgVHJhbnNtdXhlckludGVyZmFjZSh0aGlzLmhscywgUGxheWxpc3RMZXZlbFR5cGUuQVVESU8sIHRoaXMuX2hhbmRsZVRyYW5zbXV4Q29tcGxldGUuYmluZCh0aGlzKSwgdGhpcy5faGFuZGxlVHJhbnNtdXhlckZsdXNoLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgdmlkZW8gaW5pdFBUU1xuICAgIC8vIElmIG5vdCB3ZSBuZWVkIHRvIHdhaXQgZm9yIGl0XG4gICAgY29uc3QgaW5pdFBUUyA9IHRoaXMuaW5pdFBUU1tmcmFnLmNjXTtcbiAgICBjb25zdCBpbml0U2VnbWVudERhdGEgPSAoX2ZyYWckaW5pdFNlZ21lbnQgPSBmcmFnLmluaXRTZWdtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2ZyYWckaW5pdFNlZ21lbnQuZGF0YTtcbiAgICBpZiAoaW5pdFBUUyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyB0aGlzLmxvZyhgVHJhbnNtdXhpbmcgJHtzbn0gb2YgWyR7ZGV0YWlscy5zdGFydFNOfSAsJHtkZXRhaWxzLmVuZFNOfV0sdHJhY2sgJHt0cmFja0lkfWApO1xuICAgICAgLy8gdGltZSBPZmZzZXQgaXMgYWNjdXJhdGUgaWYgbGV2ZWwgUFRTIGlzIGtub3duLCBvciBpZiBwbGF5bGlzdCBpcyBub3Qgc2xpZGluZyAobm90IGxpdmUpXG4gICAgICBjb25zdCBhY2N1cmF0ZVRpbWVPZmZzZXQgPSBmYWxzZTsgLy8gZGV0YWlscy5QVFNLbm93biB8fCAhZGV0YWlscy5saXZlO1xuICAgICAgY29uc3QgcGFydEluZGV4ID0gcGFydCA/IHBhcnQuaW5kZXggOiAtMTtcbiAgICAgIGNvbnN0IHBhcnRpYWwgPSBwYXJ0SW5kZXggIT09IC0xO1xuICAgICAgY29uc3QgY2h1bmtNZXRhID0gbmV3IENodW5rTWV0YWRhdGEoZnJhZy5sZXZlbCwgZnJhZy5zbiwgZnJhZy5zdGF0cy5jaHVua0NvdW50LCBwYXlsb2FkLmJ5dGVMZW5ndGgsIHBhcnRJbmRleCwgcGFydGlhbCk7XG4gICAgICB0cmFuc211eGVyLnB1c2gocGF5bG9hZCwgaW5pdFNlZ21lbnREYXRhLCBhdWRpb0NvZGVjLCAnJywgZnJhZywgcGFydCwgZGV0YWlscy50b3RhbGR1cmF0aW9uLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGNodW5rTWV0YSwgaW5pdFBUUyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nKGBVbmtub3duIHZpZGVvIFBUUyBmb3IgY2MgJHtmcmFnLmNjfSwgd2FpdGluZyBmb3IgdmlkZW8gUFRTIGJlZm9yZSBkZW11eGluZyBhdWRpbyBmcmFnICR7ZnJhZy5zbn0gb2YgWyR7ZGV0YWlscy5zdGFydFNOfSAsJHtkZXRhaWxzLmVuZFNOfV0sdHJhY2sgJHt0cmFja0lkfWApO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjYWNoZVxuICAgICAgfSA9IHRoaXMud2FpdGluZ0RhdGEgPSB0aGlzLndhaXRpbmdEYXRhIHx8IHtcbiAgICAgICAgZnJhZyxcbiAgICAgICAgcGFydCxcbiAgICAgICAgY2FjaGU6IG5ldyBDaHVua0NhY2hlKCksXG4gICAgICAgIGNvbXBsZXRlOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGNhY2hlLnB1c2gobmV3IFVpbnQ4QXJyYXkocGF5bG9hZCkpO1xuICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFN0YXRlLlNUT1BQRUQpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLldBSVRJTkdfSU5JVF9QVFM7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZShmcmFnTG9hZGVkRGF0YSkge1xuICAgIGlmICh0aGlzLndhaXRpbmdEYXRhKSB7XG4gICAgICB0aGlzLndhaXRpbmdEYXRhLmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIuX2hhbmRsZUZyYWdtZW50TG9hZENvbXBsZXRlKGZyYWdMb2FkZWREYXRhKTtcbiAgfVxuICBvbkJ1ZmZlclJlc2V0KC8qIGV2ZW50OiBFdmVudHMuQlVGRkVSX1JFU0VUICovXG4gICkge1xuICAgIC8vIHJlc2V0IHJlZmVyZW5jZSB0byBzb3VyY2VidWZmZXJzXG4gICAgdGhpcy5tZWRpYUJ1ZmZlciA9IG51bGw7XG4gIH1cbiAgb25CdWZmZXJDcmVhdGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5idWZmZXJGbHVzaGVkID0gdGhpcy5mbHVzaGluZyA9IGZhbHNlO1xuICAgIGNvbnN0IGF1ZGlvVHJhY2sgPSBkYXRhLnRyYWNrcy5hdWRpbztcbiAgICBpZiAoYXVkaW9UcmFjaykge1xuICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IGF1ZGlvVHJhY2suYnVmZmVyIHx8IG51bGw7XG4gICAgfVxuICB9XG4gIG9uRnJhZ0xvYWRpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuYXVkaW9Pbmx5ICYmIGRhdGEuZnJhZy50eXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOICYmIGlzTWVkaWFGcmFnbWVudChkYXRhLmZyYWcpKSB7XG4gICAgICB0aGlzLm1haW5GcmFnTG9hZGluZyA9IGRhdGE7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuSURMRSkge1xuICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgb25GcmFnQnVmZmVyZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnLFxuICAgICAgcGFydFxuICAgIH0gPSBkYXRhO1xuICAgIGlmIChmcmFnLnR5cGUgIT09IFBsYXlsaXN0TGV2ZWxUeXBlLkFVRElPKSB7XG4gICAgICBpZiAoIXRoaXMuYXVkaW9Pbmx5ICYmIGZyYWcudHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTiAmJiAhZnJhZy5lbGVtZW50YXJ5U3RyZWFtcy52aWRlbyAmJiAhZnJhZy5lbGVtZW50YXJ5U3RyZWFtcy5hdWRpb3ZpZGVvKSB7XG4gICAgICAgIHRoaXMuYXVkaW9Pbmx5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5tYWluRnJhZ0xvYWRpbmcgPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgIC8vIElmIGEgbGV2ZWwgc3dpdGNoIHdhcyByZXF1ZXN0ZWQgd2hpbGUgYSBmcmFnbWVudCB3YXMgYnVmZmVyaW5nLCBpdCB3aWxsIGVtaXQgdGhlIEZSQUdfQlVGRkVSRUQgZXZlbnQgdXBvbiBjb21wbGV0aW9uXG4gICAgICAvLyBBdm9pZCBzZXR0aW5nIHN0YXRlIGJhY2sgdG8gSURMRSBvciBjb25jbHVkaW5nIHRoZSBhdWRpbyBzd2l0Y2g7IG90aGVyd2lzZSwgdGhlIHN3aXRjaGVkLXRvIHRyYWNrIHdpbGwgbm90IGJ1ZmZlclxuICAgICAgdGhpcy53YXJuKGBGcmFnbWVudCAke2ZyYWcuc259JHtwYXJ0ID8gJyBwOiAnICsgcGFydC5pbmRleCA6ICcnfSBvZiBsZXZlbCAke2ZyYWcubGV2ZWx9IGZpbmlzaGVkIGJ1ZmZlcmluZywgYnV0IHdhcyBhYm9ydGVkLiBzdGF0ZTogJHt0aGlzLnN0YXRlfSwgYXVkaW9Td2l0Y2g6ICR7dGhpcy5zd2l0Y2hpbmdUcmFjayA/IHRoaXMuc3dpdGNoaW5nVHJhY2submFtZSA6ICdmYWxzZSd9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc01lZGlhRnJhZ21lbnQoZnJhZykpIHtcbiAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gZnJhZztcbiAgICAgIGNvbnN0IHRyYWNrID0gdGhpcy5zd2l0Y2hpbmdUcmFjaztcbiAgICAgIGlmICh0cmFjaykge1xuICAgICAgICB0aGlzLmJ1ZmZlcmVkVHJhY2sgPSB0cmFjaztcbiAgICAgICAgdGhpcy5zd2l0Y2hpbmdUcmFjayA9IG51bGw7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSEVELCBfb2JqZWN0U3ByZWFkMih7fSwgdHJhY2spKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5mcmFnQnVmZmVyZWRDb21wbGV0ZShmcmFnLCBwYXJ0KTtcbiAgICBpZiAodGhpcy5tZWRpYSkge1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfVxuICB9XG4gIG9uRXJyb3IoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgX2RhdGEkY29udGV4dDtcbiAgICBpZiAoZGF0YS5mYXRhbCkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVSUk9SO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2ggKGRhdGEuZGV0YWlscykge1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19HQVA6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0RFQ1JZUFRfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVDpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVDpcbiAgICAgICAgdGhpcy5vbkZyYWdtZW50T3JLZXlMb2FkRXJyb3IoUGxheWxpc3RMZXZlbFR5cGUuQVVESU8sIGRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX1RJTUVPVVQ6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9QQVJTSU5HX0VSUk9SOlxuICAgICAgICAvLyBpbiBjYXNlIG9mIG5vbiBmYXRhbCBlcnJvciB3aGlsZSBsb2FkaW5nIHRyYWNrLCBpZiBub3QgcmV0cnlpbmcgdG8gbG9hZCB0cmFjaywgc3dpdGNoIGJhY2sgdG8gSURMRVxuICAgICAgICBpZiAoIWRhdGEubGV2ZWxSZXRyeSAmJiB0aGlzLnN0YXRlID09PSBTdGF0ZS5XQUlUSU5HX1RSQUNLICYmICgoX2RhdGEkY29udGV4dCA9IGRhdGEuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhJGNvbnRleHQudHlwZSkgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0spIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9BRERfQ09ERUNfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5EX0VSUk9SOlxuICAgICAgICBpZiAoZGF0YS5wYXJlbnQgIT09ICdhdWRpbycpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnJlZHVjZUxlbmd0aEFuZEZsdXNoQnVmZmVyKGRhdGEpKSB7XG4gICAgICAgICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0ZVTExfRVJST1I6XG4gICAgICAgIGlmIChkYXRhLnBhcmVudCAhPT0gJ2F1ZGlvJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWR1Y2VMZW5ndGhBbmRGbHVzaEJ1ZmZlcihkYXRhKSkge1xuICAgICAgICAgIHRoaXMuYnVmZmVyZWRUcmFjayA9IG51bGw7XG4gICAgICAgICAgc3VwZXIuZmx1c2hNYWluQnVmZmVyKDAsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgJ2F1ZGlvJyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5JTlRFUk5BTF9FWENFUFRJT046XG4gICAgICAgIHRoaXMucmVjb3ZlcldvcmtlckVycm9yKGRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgb25CdWZmZXJGbHVzaGluZyhldmVudCwge1xuICAgIHR5cGVcbiAgfSkge1xuICAgIGlmICh0eXBlICE9PSBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU8pIHtcbiAgICAgIHRoaXMuZmx1c2hpbmcgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBvbkJ1ZmZlckZsdXNoZWQoZXZlbnQsIHtcbiAgICB0eXBlXG4gIH0pIHtcbiAgICBpZiAodHlwZSAhPT0gRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPKSB7XG4gICAgICB0aGlzLmZsdXNoaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLmJ1ZmZlckZsdXNoZWQgPSB0cnVlO1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkVOREVEKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgfVxuICAgICAgY29uc3QgbWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhQnVmZmVyIHx8IHRoaXMubWVkaWE7XG4gICAgICBpZiAobWVkaWFCdWZmZXIpIHtcbiAgICAgICAgdGhpcy5hZnRlckJ1ZmZlckZsdXNoZWQobWVkaWFCdWZmZXIsIHR5cGUsIFBsYXlsaXN0TGV2ZWxUeXBlLkFVRElPKTtcbiAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9oYW5kbGVUcmFuc211eENvbXBsZXRlKHRyYW5zbXV4UmVzdWx0KSB7XG4gICAgdmFyIF9pZDMkc2FtcGxlcztcbiAgICBjb25zdCBpZCA9ICdhdWRpbyc7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgcmVtdXhSZXN1bHQsXG4gICAgICBjaHVua01ldGFcbiAgICB9ID0gdHJhbnNtdXhSZXN1bHQ7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ2V0Q3VycmVudENvbnRleHQoY2h1bmtNZXRhKTtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgIHRoaXMucmVzZXRXaGVuTWlzc2luZ0NvbnRleHQoY2h1bmtNZXRhKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIHBhcnQsXG4gICAgICBsZXZlbFxuICAgIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IHtcbiAgICAgIGRldGFpbHNcbiAgICB9ID0gbGV2ZWw7XG4gICAgY29uc3Qge1xuICAgICAgYXVkaW8sXG4gICAgICB0ZXh0LFxuICAgICAgaWQzLFxuICAgICAgaW5pdFNlZ21lbnRcbiAgICB9ID0gcmVtdXhSZXN1bHQ7XG5cbiAgICAvLyBDaGVjayBpZiB0aGUgY3VycmVudCBmcmFnbWVudCBoYXMgYmVlbiBhYm9ydGVkLiBXZSBjaGVjayB0aGlzIGJ5IGZpcnN0IHNlZWluZyBpZiB3ZSdyZSBzdGlsbCBwbGF5aW5nIHRoZSBjdXJyZW50IGxldmVsLlxuICAgIC8vIElmIHdlIGFyZSwgc3Vic2VxdWVudGx5IGNoZWNrIGlmIHRoZSBjdXJyZW50bHkgbG9hZGluZyBmcmFnbWVudCAoZnJhZ0N1cnJlbnQpIGhhcyBjaGFuZ2VkLlxuICAgIGlmICh0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSB8fCAhZGV0YWlscykge1xuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5QQVJTSU5HO1xuICAgIGlmICh0aGlzLnN3aXRjaGluZ1RyYWNrICYmIGF1ZGlvKSB7XG4gICAgICB0aGlzLmNvbXBsZXRlQXVkaW9Td2l0Y2godGhpcy5zd2l0Y2hpbmdUcmFjayk7XG4gICAgfVxuICAgIGlmIChpbml0U2VnbWVudCAhPSBudWxsICYmIGluaXRTZWdtZW50LnRyYWNrcykge1xuICAgICAgY29uc3QgbWFwRnJhZ21lbnQgPSBmcmFnLmluaXRTZWdtZW50IHx8IGZyYWc7XG4gICAgICB0aGlzLl9idWZmZXJJbml0U2VnbWVudChsZXZlbCwgaW5pdFNlZ21lbnQudHJhY2tzLCBtYXBGcmFnbWVudCwgY2h1bmtNZXRhKTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULCB7XG4gICAgICAgIGZyYWc6IG1hcEZyYWdtZW50LFxuICAgICAgICBpZCxcbiAgICAgICAgdHJhY2tzOiBpbml0U2VnbWVudC50cmFja3NcbiAgICAgIH0pO1xuICAgICAgLy8gT25seSBmbHVzaCBhdWRpbyBmcm9tIG9sZCBhdWRpbyB0cmFja3Mgd2hlbiBQVFMgaXMga25vd24gb24gbmV3IGF1ZGlvIHRyYWNrXG4gICAgfVxuICAgIGlmIChhdWRpbykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzdGFydFBUUyxcbiAgICAgICAgZW5kUFRTLFxuICAgICAgICBzdGFydERUUyxcbiAgICAgICAgZW5kRFRTXG4gICAgICB9ID0gYXVkaW87XG4gICAgICBpZiAocGFydCkge1xuICAgICAgICBwYXJ0LmVsZW1lbnRhcnlTdHJlYW1zW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJT10gPSB7XG4gICAgICAgICAgc3RhcnRQVFMsXG4gICAgICAgICAgZW5kUFRTLFxuICAgICAgICAgIHN0YXJ0RFRTLFxuICAgICAgICAgIGVuZERUU1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZnJhZy5zZXRFbGVtZW50YXJ5U3RyZWFtSW5mbyhFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU8sIHN0YXJ0UFRTLCBlbmRQVFMsIHN0YXJ0RFRTLCBlbmREVFMpO1xuICAgICAgdGhpcy5idWZmZXJGcmFnbWVudERhdGEoYXVkaW8sIGZyYWcsIHBhcnQsIGNodW5rTWV0YSk7XG4gICAgfVxuICAgIGlmIChpZDMgIT0gbnVsbCAmJiAoX2lkMyRzYW1wbGVzID0gaWQzLnNhbXBsZXMpICE9IG51bGwgJiYgX2lkMyRzYW1wbGVzLmxlbmd0aCkge1xuICAgICAgY29uc3QgZW1pdHRlZElEMyA9IF9leHRlbmRzKHtcbiAgICAgICAgaWQsXG4gICAgICAgIGZyYWcsXG4gICAgICAgIGRldGFpbHNcbiAgICAgIH0sIGlkMyk7XG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuRlJBR19QQVJTSU5HX01FVEFEQVRBLCBlbWl0dGVkSUQzKTtcbiAgICB9XG4gICAgaWYgKHRleHQpIHtcbiAgICAgIGNvbnN0IGVtaXR0ZWRUZXh0ID0gX2V4dGVuZHMoe1xuICAgICAgICBpZCxcbiAgICAgICAgZnJhZyxcbiAgICAgICAgZGV0YWlsc1xuICAgICAgfSwgdGV4dCk7XG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuRlJBR19QQVJTSU5HX1VTRVJEQVRBLCBlbWl0dGVkVGV4dCk7XG4gICAgfVxuICB9XG4gIF9idWZmZXJJbml0U2VnbWVudChjdXJyZW50TGV2ZWwsIHRyYWNrcywgZnJhZywgY2h1bmtNZXRhKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gZGVsZXRlIGFueSB2aWRlbyB0cmFjayBmb3VuZCBvbiBhdWRpbyB0cmFuc211eGVyXG4gICAgaWYgKHRyYWNrcy52aWRlbykge1xuICAgICAgZGVsZXRlIHRyYWNrcy52aWRlbztcbiAgICB9XG4gICAgaWYgKHRyYWNrcy5hdWRpb3ZpZGVvKSB7XG4gICAgICBkZWxldGUgdHJhY2tzLmF1ZGlvdmlkZW87XG4gICAgfVxuXG4gICAgLy8gaW5jbHVkZSBsZXZlbENvZGVjIGluIGF1ZGlvIGFuZCB2aWRlbyB0cmFja3NcbiAgICBpZiAoIXRyYWNrcy5hdWRpbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0cmFjayA9IHRyYWNrcy5hdWRpbztcbiAgICB0cmFjay5pZCA9IFBsYXlsaXN0TGV2ZWxUeXBlLkFVRElPO1xuICAgIGNvbnN0IHZhcmlhbnRBdWRpb0NvZGVjcyA9IGN1cnJlbnRMZXZlbC5hdWRpb0NvZGVjO1xuICAgIHRoaXMubG9nKGBJbml0IGF1ZGlvIGJ1ZmZlciwgY29udGFpbmVyOiR7dHJhY2suY29udGFpbmVyfSwgY29kZWNzW2xldmVsL3BhcnNlZF09WyR7dmFyaWFudEF1ZGlvQ29kZWNzfS8ke3RyYWNrLmNvZGVjfV1gKTtcbiAgICAvLyBTb3VyY2VCdWZmZXIgd2lsbCB1c2UgdHJhY2subGV2ZWxDb2RlYyBpZiBkZWZpbmVkXG4gICAgaWYgKHZhcmlhbnRBdWRpb0NvZGVjcyAmJiB2YXJpYW50QXVkaW9Db2RlY3Muc3BsaXQoJywnKS5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRyYWNrLmxldmVsQ29kZWMgPSB2YXJpYW50QXVkaW9Db2RlY3M7XG4gICAgfVxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9DT0RFQ1MsIHRyYWNrcyk7XG4gICAgY29uc3QgaW5pdFNlZ21lbnQgPSB0cmFjay5pbml0U2VnbWVudDtcbiAgICBpZiAoaW5pdFNlZ21lbnQgIT0gbnVsbCAmJiBpbml0U2VnbWVudC5ieXRlTGVuZ3RoKSB7XG4gICAgICBjb25zdCBzZWdtZW50ID0ge1xuICAgICAgICB0eXBlOiAnYXVkaW8nLFxuICAgICAgICBmcmFnLFxuICAgICAgICBwYXJ0OiBudWxsLFxuICAgICAgICBjaHVua01ldGEsXG4gICAgICAgIHBhcmVudDogZnJhZy50eXBlLFxuICAgICAgICBkYXRhOiBpbml0U2VnbWVudFxuICAgICAgfTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9BUFBFTkRJTkcsIHNlZ21lbnQpO1xuICAgIH1cbiAgICAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgdGhpcy50aWNrSW1tZWRpYXRlKCk7XG4gIH1cbiAgbG9hZEZyYWdtZW50KGZyYWcsIHRyYWNrLCB0YXJnZXRCdWZmZXJUaW1lKSB7XG4gICAgLy8gb25seSBsb2FkIGlmIGZyYWdtZW50IGlzIG5vdCBsb2FkZWQgb3IgaWYgaW4gYXVkaW8gc3dpdGNoXG4gICAgY29uc3QgZnJhZ1N0YXRlID0gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZyk7XG5cbiAgICAvLyB3ZSBmb3JjZSBhIGZyYWcgbG9hZGluZyBpbiBhdWRpbyBzd2l0Y2ggYXMgZnJhZ21lbnQgdHJhY2tlciBtaWdodCBub3QgaGF2ZSBldmljdGVkIHByZXZpb3VzIGZyYWdzIGluIGNhc2Ugb2YgcXVpY2sgYXVkaW8gc3dpdGNoXG4gICAgaWYgKHRoaXMuc3dpdGNoaW5nVHJhY2sgfHwgZnJhZ1N0YXRlID09PSBGcmFnbWVudFN0YXRlLk5PVF9MT0FERUQgfHwgZnJhZ1N0YXRlID09PSBGcmFnbWVudFN0YXRlLlBBUlRJQUwpIHtcbiAgICAgIHZhciBfdHJhY2skZGV0YWlscztcbiAgICAgIGlmICghaXNNZWRpYUZyYWdtZW50KGZyYWcpKSB7XG4gICAgICAgIHRoaXMuX2xvYWRJbml0U2VnbWVudChmcmFnLCB0cmFjayk7XG4gICAgICB9IGVsc2UgaWYgKChfdHJhY2skZGV0YWlscyA9IHRyYWNrLmRldGFpbHMpICE9IG51bGwgJiYgX3RyYWNrJGRldGFpbHMubGl2ZSAmJiAhdGhpcy5pbml0UFRTW2ZyYWcuY2NdKSB7XG4gICAgICAgIHRoaXMubG9nKGBXYWl0aW5nIGZvciB2aWRlbyBQVFMgaW4gY29udGludWl0eSBjb3VudGVyICR7ZnJhZy5jY30gb2YgbGl2ZSBzdHJlYW0gYmVmb3JlIGxvYWRpbmcgYXVkaW8gZnJhZ21lbnQgJHtmcmFnLnNufSBvZiBsZXZlbCAke3RoaXMudHJhY2tJZH1gKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLldBSVRJTkdfSU5JVF9QVFM7XG4gICAgICAgIGNvbnN0IG1haW5EZXRhaWxzID0gdGhpcy5tYWluRGV0YWlscztcbiAgICAgICAgaWYgKG1haW5EZXRhaWxzICYmIG1haW5EZXRhaWxzLmZyYWdtZW50U3RhcnQgIT09IHRyYWNrLmRldGFpbHMuZnJhZ21lbnRTdGFydCkge1xuICAgICAgICAgIGFsaWduTWVkaWFQbGF5bGlzdEJ5UERUKHRyYWNrLmRldGFpbHMsIG1haW5EZXRhaWxzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VwZXIubG9hZEZyYWdtZW50KGZyYWcsIHRyYWNrLCB0YXJnZXRCdWZmZXJUaW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jbGVhclRyYWNrZXJJZk5lZWRlZChmcmFnKTtcbiAgICB9XG4gIH1cbiAgZmx1c2hBdWRpb0lmTmVlZGVkKHN3aXRjaGluZ1RyYWNrKSB7XG4gICAgaWYgKHRoaXMubWVkaWEgJiYgdGhpcy5idWZmZXJlZFRyYWNrKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGxhbmcsXG4gICAgICAgIGFzc29jTGFuZyxcbiAgICAgICAgY2hhcmFjdGVyaXN0aWNzLFxuICAgICAgICBhdWRpb0NvZGVjLFxuICAgICAgICBjaGFubmVsc1xuICAgICAgfSA9IHRoaXMuYnVmZmVyZWRUcmFjaztcbiAgICAgIGlmICghbWF0Y2hlc09wdGlvbih7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGxhbmcsXG4gICAgICAgIGFzc29jTGFuZyxcbiAgICAgICAgY2hhcmFjdGVyaXN0aWNzLFxuICAgICAgICBhdWRpb0NvZGVjLFxuICAgICAgICBjaGFubmVsc1xuICAgICAgfSwgc3dpdGNoaW5nVHJhY2ssIGF1ZGlvTWF0Y2hQcmVkaWNhdGUpKSB7XG4gICAgICAgIGlmICh1c2VBbHRlcm5hdGVBdWRpbyhzd2l0Y2hpbmdUcmFjay51cmwsIHRoaXMuaGxzKSkge1xuICAgICAgICAgIHRoaXMubG9nKCdTd2l0Y2hpbmcgYXVkaW8gdHJhY2sgOiBmbHVzaGluZyBhbGwgYXVkaW8nKTtcbiAgICAgICAgICBzdXBlci5mbHVzaE1haW5CdWZmZXIoMCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCAnYXVkaW8nKTtcbiAgICAgICAgICB0aGlzLmJ1ZmZlcmVkVHJhY2sgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE1haW4gaXMgYmVpbmcgYnVmZmVyZWQuIFNldCBidWZmZXJlZFRyYWNrIHNvIHRoYXQgaXQgaXMgZmx1c2hlZCB3aGVuIHN3aXRjaGluZyBiYWNrIHRvIGFsdC1hdWRpb1xuICAgICAgICAgIHRoaXMuYnVmZmVyZWRUcmFjayA9IHN3aXRjaGluZ1RyYWNrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbXBsZXRlQXVkaW9Td2l0Y2goc3dpdGNoaW5nVHJhY2spIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICB0aGlzLmZsdXNoQXVkaW9JZk5lZWRlZChzd2l0Y2hpbmdUcmFjayk7XG4gICAgdGhpcy5idWZmZXJlZFRyYWNrID0gc3dpdGNoaW5nVHJhY2s7XG4gICAgdGhpcy5zd2l0Y2hpbmdUcmFjayA9IG51bGw7XG4gICAgaGxzLnRyaWdnZXIoRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSEVELCBfb2JqZWN0U3ByZWFkMih7fSwgc3dpdGNoaW5nVHJhY2spKTtcbiAgfVxufVxuXG5jbGFzcyBCYXNlUGxheWxpc3RDb250cm9sbGVyIGV4dGVuZHMgTG9nZ2VyIHtcbiAgY29uc3RydWN0b3IoaGxzLCBsb2dQcmVmaXgpIHtcbiAgICBzdXBlcihsb2dQcmVmaXgsIGhscy5sb2dnZXIpO1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMuY2FuTG9hZCA9IGZhbHNlO1xuICAgIHRoaXMudGltZXIgPSAtMTtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmhscyA9IHRoaXMubG9nID0gdGhpcy53YXJuID0gbnVsbDtcbiAgfVxuICBjbGVhclRpbWVyKCkge1xuICAgIGlmICh0aGlzLnRpbWVyICE9PSAtMSkge1xuICAgICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICB0aGlzLnRpbWVyID0gLTE7XG4gICAgfVxuICB9XG4gIHN0YXJ0TG9hZCgpIHtcbiAgICB0aGlzLmNhbkxvYWQgPSB0cnVlO1xuICAgIHRoaXMubG9hZFBsYXlsaXN0KCk7XG4gIH1cbiAgc3RvcExvYWQoKSB7XG4gICAgdGhpcy5jYW5Mb2FkID0gZmFsc2U7XG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gIH1cbiAgc3dpdGNoUGFyYW1zKHBsYXlsaXN0VXJpLCBwcmV2aW91cywgY3VycmVudCkge1xuICAgIGNvbnN0IHJlbmRpdGlvblJlcG9ydHMgPSBwcmV2aW91cyA9PSBudWxsID8gdm9pZCAwIDogcHJldmlvdXMucmVuZGl0aW9uUmVwb3J0cztcbiAgICBpZiAocmVuZGl0aW9uUmVwb3J0cykge1xuICAgICAgbGV0IGZvdW5kSW5kZXggPSAtMTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVuZGl0aW9uUmVwb3J0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhdHRyID0gcmVuZGl0aW9uUmVwb3J0c1tpXTtcbiAgICAgICAgbGV0IHVyaTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB1cmkgPSBuZXcgc2VsZi5VUkwoYXR0ci5VUkksIHByZXZpb3VzLnVybCkuaHJlZjtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aGlzLndhcm4oYENvdWxkIG5vdCBjb25zdHJ1Y3QgbmV3IFVSTCBmb3IgUmVuZGl0aW9uIFJlcG9ydDogJHtlcnJvcn1gKTtcbiAgICAgICAgICB1cmkgPSBhdHRyLlVSSSB8fCAnJztcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2UgZXhhY3QgbWF0Y2guIE90aGVyd2lzZSwgdGhlIGxhc3QgcGFydGlhbCBtYXRjaCwgaWYgYW55LCB3aWxsIGJlIHVzZWRcbiAgICAgICAgLy8gKFBsYXlsaXN0IFVSSSBpbmNsdWRlcyBhIHF1ZXJ5IHN0cmluZyB0aGF0IHRoZSBSZW5kaXRpb24gUmVwb3J0IGRvZXMgbm90KVxuICAgICAgICBpZiAodXJpID09PSBwbGF5bGlzdFVyaSkge1xuICAgICAgICAgIGZvdW5kSW5kZXggPSBpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKHVyaSA9PT0gcGxheWxpc3RVcmkuc3Vic3RyaW5nKDAsIHVyaS5sZW5ndGgpKSB7XG4gICAgICAgICAgZm91bmRJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkge1xuICAgICAgICBjb25zdCBhdHRyID0gcmVuZGl0aW9uUmVwb3J0c1tmb3VuZEluZGV4XTtcbiAgICAgICAgY29uc3QgbXNuID0gcGFyc2VJbnQoYXR0clsnTEFTVC1NU04nXSkgfHwgKHByZXZpb3VzID09IG51bGwgPyB2b2lkIDAgOiBwcmV2aW91cy5sYXN0UGFydFNuKTtcbiAgICAgICAgbGV0IHBhcnQgPSBwYXJzZUludChhdHRyWydMQVNULVBBUlQnXSkgfHwgKHByZXZpb3VzID09IG51bGwgPyB2b2lkIDAgOiBwcmV2aW91cy5sYXN0UGFydEluZGV4KTtcbiAgICAgICAgaWYgKHRoaXMuaGxzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZSkge1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRHb2FsID0gTWF0aC5taW4ocHJldmlvdXMuYWdlIC0gcHJldmlvdXMucGFydFRhcmdldCwgcHJldmlvdXMudGFyZ2V0ZHVyYXRpb24pO1xuICAgICAgICAgIGlmIChwYXJ0ID49IDAgJiYgY3VycmVudEdvYWwgPiBwcmV2aW91cy5wYXJ0VGFyZ2V0KSB7XG4gICAgICAgICAgICBwYXJ0ICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNraXAgPSBjdXJyZW50ICYmIGdldFNraXBWYWx1ZShjdXJyZW50KTtcbiAgICAgICAgcmV0dXJuIG5ldyBIbHNVcmxQYXJhbWV0ZXJzKG1zbiwgcGFydCA+PSAwID8gcGFydCA6IHVuZGVmaW5lZCwgc2tpcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxvYWRQbGF5bGlzdChobHNVcmxQYXJhbWV0ZXJzKSB7XG4gICAgLy8gTG9hZGluZyBpcyBoYW5kbGVkIGJ5IHRoZSBzdWJjbGFzc2VzXG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gIH1cbiAgbG9hZGluZ1BsYXlsaXN0KHBsYXlsaXN0LCBobHNVcmxQYXJhbWV0ZXJzKSB7XG4gICAgLy8gTG9hZGluZyBpcyBoYW5kbGVkIGJ5IHRoZSBzdWJjbGFzc2VzXG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gIH1cbiAgc2hvdWxkTG9hZFBsYXlsaXN0KHBsYXlsaXN0KSB7XG4gICAgcmV0dXJuIHRoaXMuY2FuTG9hZCAmJiAhIXBsYXlsaXN0ICYmICEhcGxheWxpc3QudXJsICYmICghcGxheWxpc3QuZGV0YWlscyB8fCBwbGF5bGlzdC5kZXRhaWxzLmxpdmUpO1xuICB9XG4gIGdldFVybFdpdGhEaXJlY3RpdmVzKHVyaSwgaGxzVXJsUGFyYW1ldGVycykge1xuICAgIGlmIChobHNVcmxQYXJhbWV0ZXJzKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gaGxzVXJsUGFyYW1ldGVycy5hZGREaXJlY3RpdmVzKHVyaSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aGlzLndhcm4oYENvdWxkIG5vdCBjb25zdHJ1Y3QgbmV3IFVSTCB3aXRoIEhMUyBEZWxpdmVyeSBEaXJlY3RpdmVzOiAke2Vycm9yfWApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdXJpO1xuICB9XG4gIHBsYXlsaXN0TG9hZGVkKGluZGV4LCBkYXRhLCBwcmV2aW91c0RldGFpbHMpIHtcbiAgICBjb25zdCB7XG4gICAgICBkZXRhaWxzLFxuICAgICAgc3RhdHNcbiAgICB9ID0gZGF0YTtcblxuICAgIC8vIFNldCBsYXN0IHVwZGF0ZWQgZGF0ZS10aW1lXG4gICAgY29uc3Qgbm93ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCBlbGFwc2VkID0gc3RhdHMubG9hZGluZy5maXJzdCA/IE1hdGgubWF4KDAsIG5vdyAtIHN0YXRzLmxvYWRpbmcuZmlyc3QpIDogMDtcbiAgICBkZXRhaWxzLmFkdmFuY2VkRGF0ZVRpbWUgPSBEYXRlLm5vdygpIC0gZWxhcHNlZDtcblxuICAgIC8vIHNoaWZ0IGZyYWdtZW50IHN0YXJ0cyB3aXRoIHRpbWVsaW5lT2Zmc2V0XG4gICAgY29uc3QgdGltZWxpbmVPZmZzZXQgPSB0aGlzLmhscy5jb25maWcudGltZWxpbmVPZmZzZXQ7XG4gICAgaWYgKHRpbWVsaW5lT2Zmc2V0ICE9PSBkZXRhaWxzLmFwcGxpZWRUaW1lbGluZU9mZnNldCkge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gTWF0aC5tYXgodGltZWxpbmVPZmZzZXQgfHwgMCwgMCk7XG4gICAgICBkZXRhaWxzLmFwcGxpZWRUaW1lbGluZU9mZnNldCA9IG9mZnNldDtcbiAgICAgIGRldGFpbHMuZnJhZ21lbnRzLmZvckVhY2goZnJhZyA9PiB7XG4gICAgICAgIGZyYWcuc3RhcnQgPSBmcmFnLnBsYXlsaXN0T2Zmc2V0ICsgb2Zmc2V0O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gaWYgY3VycmVudCBwbGF5bGlzdCBpcyBhIGxpdmUgcGxheWxpc3QsIGFybSBhIHRpbWVyIHRvIHJlbG9hZCBpdFxuICAgIGlmIChkZXRhaWxzLmxpdmUgfHwgcHJldmlvdXNEZXRhaWxzICE9IG51bGwgJiYgcHJldmlvdXNEZXRhaWxzLmxpdmUpIHtcbiAgICAgIGNvbnN0IGxldmVsT3JUcmFjayA9ICdsZXZlbEluZm8nIGluIGRhdGEgPyBkYXRhLmxldmVsSW5mbyA6IGRhdGEudHJhY2s7XG4gICAgICBkZXRhaWxzLnJlbG9hZGVkKHByZXZpb3VzRGV0YWlscyk7XG4gICAgICAvLyBNZXJnZSBsaXZlIHBsYXlsaXN0cyB0byBhZGp1c3QgZnJhZ21lbnQgc3RhcnRzIGFuZCBmaWxsIGluIGRlbHRhIHBsYXlsaXN0IHNraXBwZWQgc2VnbWVudHNcbiAgICAgIGlmIChwcmV2aW91c0RldGFpbHMgJiYgZGV0YWlscy5mcmFnbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICBtZXJnZURldGFpbHMocHJldmlvdXNEZXRhaWxzLCBkZXRhaWxzKTtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBkZXRhaWxzLnBsYXlsaXN0UGFyc2luZ0Vycm9yO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICB0aGlzLndhcm4oZXJyb3IpO1xuICAgICAgICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgICAgICAgIGlmICghaGxzLmNvbmZpZy5pZ25vcmVQbGF5bGlzdFBhcnNpbmdFcnJvcnMpIHtcbiAgICAgICAgICAgIHZhciBfZGV0YWlscyRmcmFnbWVudHMkO1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBuZXR3b3JrRGV0YWlsc1xuICAgICAgICAgICAgfSA9IGRhdGE7XG4gICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuTEVWRUxfUEFSU0lOR19FUlJPUixcbiAgICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgICB1cmw6IGRldGFpbHMudXJsLFxuICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgcmVhc29uOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICBsZXZlbDogZGF0YS5sZXZlbCB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIHBhcmVudDogKF9kZXRhaWxzJGZyYWdtZW50cyQgPSBkZXRhaWxzLmZyYWdtZW50c1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kZXRhaWxzJGZyYWdtZW50cyQudHlwZSxcbiAgICAgICAgICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgICAgIHN0YXRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGV0YWlscy5wbGF5bGlzdFBhcnNpbmdFcnJvciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkZXRhaWxzLnJlcXVlc3RTY2hlZHVsZWQgPT09IC0xKSB7XG4gICAgICAgIGRldGFpbHMucmVxdWVzdFNjaGVkdWxlZCA9IHN0YXRzLmxvYWRpbmcuc3RhcnQ7XG4gICAgICB9XG4gICAgICBjb25zdCBidWZmZXJJbmZvID0gdGhpcy5obHMubWFpbkZvcndhcmRCdWZmZXJJbmZvO1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBidWZmZXJJbmZvID8gYnVmZmVySW5mby5lbmQgLSBidWZmZXJJbmZvLmxlbiA6IDA7XG4gICAgICBjb25zdCBkaXN0YW5jZVRvTGl2ZUVkZ2VNcyA9IChkZXRhaWxzLmVkZ2UgLSBwb3NpdGlvbikgKiAxMDAwO1xuICAgICAgY29uc3QgcmVsb2FkSW50ZXJ2YWwgPSBjb21wdXRlUmVsb2FkSW50ZXJ2YWwoZGV0YWlscywgZGlzdGFuY2VUb0xpdmVFZGdlTXMpO1xuICAgICAgaWYgKGRldGFpbHMucmVxdWVzdFNjaGVkdWxlZCArIHJlbG9hZEludGVydmFsIDwgbm93KSB7XG4gICAgICAgIGRldGFpbHMucmVxdWVzdFNjaGVkdWxlZCA9IG5vdztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRldGFpbHMucmVxdWVzdFNjaGVkdWxlZCArPSByZWxvYWRJbnRlcnZhbDtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nKGBsaXZlIHBsYXlsaXN0ICR7aW5kZXh9ICR7ZGV0YWlscy5hZHZhbmNlZCA/ICdSRUZSRVNIRUQgJyArIGRldGFpbHMubGFzdFBhcnRTbiArICctJyArIGRldGFpbHMubGFzdFBhcnRJbmRleCA6IGRldGFpbHMudXBkYXRlZCA/ICdVUERBVEVEJyA6ICdNSVNTRUQnfWApO1xuICAgICAgaWYgKCF0aGlzLmNhbkxvYWQgfHwgIWRldGFpbHMubGl2ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgZGVsaXZlcnlEaXJlY3RpdmVzO1xuICAgICAgbGV0IG1zbiA9IHVuZGVmaW5lZDtcbiAgICAgIGxldCBwYXJ0ID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKGRldGFpbHMuY2FuQmxvY2tSZWxvYWQgJiYgZGV0YWlscy5lbmRTTiAmJiBkZXRhaWxzLmFkdmFuY2VkKSB7XG4gICAgICAgIC8vIExvYWQgbGV2ZWwgd2l0aCBMTC1ITFMgZGVsaXZlcnkgZGlyZWN0aXZlc1xuICAgICAgICBjb25zdCBsb3dMYXRlbmN5TW9kZSA9IHRoaXMuaGxzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZTtcbiAgICAgICAgY29uc3QgbGFzdFBhcnRTbiA9IGRldGFpbHMubGFzdFBhcnRTbjtcbiAgICAgICAgY29uc3QgZW5kU24gPSBkZXRhaWxzLmVuZFNOO1xuICAgICAgICBjb25zdCBsYXN0UGFydEluZGV4ID0gZGV0YWlscy5sYXN0UGFydEluZGV4O1xuICAgICAgICBjb25zdCBoYXNQYXJ0cyA9IGxhc3RQYXJ0SW5kZXggIT09IC0xO1xuICAgICAgICBjb25zdCBhdExhc3RQYXJ0T2ZTZWdtZW50ID0gbGFzdFBhcnRTbiA9PT0gZW5kU247XG4gICAgICAgIGlmIChoYXNQYXJ0cykge1xuICAgICAgICAgIC8vIFdoZW4gbG93IGxhdGVuY3kgbW9kZSBpcyBkaXNhYmxlZCwgcmVxdWVzdCB0aGUgbGFzdCBwYXJ0IG9mIHRoZSBuZXh0IHNlZ21lbnRcbiAgICAgICAgICBpZiAoYXRMYXN0UGFydE9mU2VnbWVudCkge1xuICAgICAgICAgICAgbXNuID0gZW5kU24gKyAxO1xuICAgICAgICAgICAgcGFydCA9IGxvd0xhdGVuY3lNb2RlID8gMCA6IGxhc3RQYXJ0SW5kZXg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1zbiA9IGxhc3RQYXJ0U247XG4gICAgICAgICAgICBwYXJ0ID0gbG93TGF0ZW5jeU1vZGUgPyBsYXN0UGFydEluZGV4ICsgMSA6IGRldGFpbHMubWF4UGFydEluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtc24gPSBlbmRTbiArIDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTG93LUxhdGVuY3kgQ0ROIFR1bmUtaW46IFwiYWdlXCIgaGVhZGVyIGFuZCB0aW1lIHNpbmNlIGxvYWQgaW5kaWNhdGVzIHdlJ3JlIGJlaGluZCBieSBtb3JlIHRoYW4gb25lIHBhcnRcbiAgICAgICAgLy8gVXBkYXRlIGRpcmVjdGl2ZXMgdG8gb2J0YWluIHRoZSBQbGF5bGlzdCB0aGF0IGhhcyB0aGUgZXN0aW1hdGVkIGFkZGl0aW9uYWwgZHVyYXRpb24gb2YgbWVkaWFcbiAgICAgICAgY29uc3QgbGFzdEFkdmFuY2VkID0gZGV0YWlscy5hZ2U7XG4gICAgICAgIGNvbnN0IGNkbkFnZSA9IGxhc3RBZHZhbmNlZCArIGRldGFpbHMuYWdlSGVhZGVyO1xuICAgICAgICBsZXQgY3VycmVudEdvYWwgPSBNYXRoLm1pbihjZG5BZ2UgLSBkZXRhaWxzLnBhcnRUYXJnZXQsIGRldGFpbHMudGFyZ2V0ZHVyYXRpb24gKiAxLjUpO1xuICAgICAgICBpZiAoY3VycmVudEdvYWwgPiAwKSB7XG4gICAgICAgICAgaWYgKGNkbkFnZSA+IGRldGFpbHMudGFyZ2V0ZHVyYXRpb24gKiAzKSB7XG4gICAgICAgICAgICAvLyBPbWl0IHNlZ21lbnQgYW5kIHBhcnQgZGlyZWN0aXZlcyB3aGVuIHRoZSBsYXN0IHJlc3BvbnNlIHdhcyBtb3JlIHRoYW4gMyB0YXJnZXQgZHVyYXRpb25zIGFnbyxcbiAgICAgICAgICAgIHRoaXMubG9nKGBQbGF5bGlzdCBsYXN0IGFkdmFuY2VkICR7bGFzdEFkdmFuY2VkLnRvRml4ZWQoMil9cyBhZ28uIE9taXR0aW5nIHNlZ21lbnQgYW5kIHBhcnQgZGlyZWN0aXZlcy5gKTtcbiAgICAgICAgICAgIG1zbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHBhcnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcmV2aW91c0RldGFpbHMgIT0gbnVsbCAmJiBwcmV2aW91c0RldGFpbHMudHVuZUluR29hbCAmJiBjZG5BZ2UgLSBkZXRhaWxzLnBhcnRUYXJnZXQgPiBwcmV2aW91c0RldGFpbHMudHVuZUluR29hbCkge1xuICAgICAgICAgICAgLy8gSWYgd2UgYXR0ZW1wdGVkIHRvIGdldCB0aGUgbmV4dCBvciBsYXRlc3QgcGxheWxpc3QgdXBkYXRlLCBidXQgY3VycmVudEdvYWwgaW5jcmVhc2VkLFxuICAgICAgICAgICAgLy8gdGhlbiB3ZSBlaXRoZXIgY2FuJ3QgY2F0Y2h1cCwgb3IgdGhlIFwiYWdlXCIgaGVhZGVyIGNhbm5vdCBiZSB0cnVzdGVkLlxuICAgICAgICAgICAgdGhpcy53YXJuKGBDRE4gVHVuZS1pbiBnb2FsIGluY3JlYXNlZCBmcm9tOiAke3ByZXZpb3VzRGV0YWlscy50dW5lSW5Hb2FsfSB0bzogJHtjdXJyZW50R29hbH0gd2l0aCBwbGF5bGlzdCBhZ2U6ICR7ZGV0YWlscy5hZ2V9YCk7XG4gICAgICAgICAgICBjdXJyZW50R29hbCA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNlZ21lbnRzID0gTWF0aC5mbG9vcihjdXJyZW50R29hbCAvIGRldGFpbHMudGFyZ2V0ZHVyYXRpb24pO1xuICAgICAgICAgICAgbXNuICs9IHNlZ21lbnRzO1xuICAgICAgICAgICAgaWYgKHBhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IE1hdGgucm91bmQoY3VycmVudEdvYWwgJSBkZXRhaWxzLnRhcmdldGR1cmF0aW9uIC8gZGV0YWlscy5wYXJ0VGFyZ2V0KTtcbiAgICAgICAgICAgICAgcGFydCArPSBwYXJ0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubG9nKGBDRE4gVHVuZS1pbiBhZ2U6ICR7ZGV0YWlscy5hZ2VIZWFkZXJ9cyBsYXN0IGFkdmFuY2VkICR7bGFzdEFkdmFuY2VkLnRvRml4ZWQoMil9cyBnb2FsOiAke2N1cnJlbnRHb2FsfSBza2lwIHNuICR7c2VnbWVudHN9IHRvIHBhcnQgJHtwYXJ0fWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZXRhaWxzLnR1bmVJbkdvYWwgPSBjdXJyZW50R29hbDtcbiAgICAgICAgfVxuICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXMgPSB0aGlzLmdldERlbGl2ZXJ5RGlyZWN0aXZlcyhkZXRhaWxzLCBkYXRhLmRlbGl2ZXJ5RGlyZWN0aXZlcywgbXNuLCBwYXJ0KTtcbiAgICAgICAgaWYgKGxvd0xhdGVuY3lNb2RlIHx8ICFhdExhc3RQYXJ0T2ZTZWdtZW50KSB7XG4gICAgICAgICAgZGV0YWlscy5yZXF1ZXN0U2NoZWR1bGVkID0gbm93O1xuICAgICAgICAgIHRoaXMubG9hZGluZ1BsYXlsaXN0KGxldmVsT3JUcmFjaywgZGVsaXZlcnlEaXJlY3RpdmVzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGV0YWlscy5jYW5CbG9ja1JlbG9hZCB8fCBkZXRhaWxzLmNhblNraXBVbnRpbCkge1xuICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXMgPSB0aGlzLmdldERlbGl2ZXJ5RGlyZWN0aXZlcyhkZXRhaWxzLCBkYXRhLmRlbGl2ZXJ5RGlyZWN0aXZlcywgbXNuLCBwYXJ0KTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWxpdmVyeURpcmVjdGl2ZXMgJiYgbXNuICE9PSB1bmRlZmluZWQgJiYgZGV0YWlscy5jYW5CbG9ja1JlbG9hZCkge1xuICAgICAgICBkZXRhaWxzLnJlcXVlc3RTY2hlZHVsZWQgPSBzdGF0cy5sb2FkaW5nLmZpcnN0ICsgTWF0aC5tYXgocmVsb2FkSW50ZXJ2YWwgLSBlbGFwc2VkICogMiwgcmVsb2FkSW50ZXJ2YWwgLyAyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2NoZWR1bGVMb2FkaW5nKGxldmVsT3JUcmFjaywgZGVsaXZlcnlEaXJlY3RpdmVzLCBkZXRhaWxzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgfVxuICB9XG4gIHNjaGVkdWxlTG9hZGluZyhsZXZlbE9yVHJhY2ssIGRlbGl2ZXJ5RGlyZWN0aXZlcywgdXBkYXRlZERldGFpbHMpIHtcbiAgICBjb25zdCBkZXRhaWxzID0gdXBkYXRlZERldGFpbHMgfHwgbGV2ZWxPclRyYWNrLmRldGFpbHM7XG4gICAgaWYgKCFkZXRhaWxzKSB7XG4gICAgICB0aGlzLmxvYWRpbmdQbGF5bGlzdChsZXZlbE9yVHJhY2ssIGRlbGl2ZXJ5RGlyZWN0aXZlcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3QgcmVxdWVzdFNjaGVkdWxlZCA9IGRldGFpbHMucmVxdWVzdFNjaGVkdWxlZDtcbiAgICBpZiAobm93ID49IHJlcXVlc3RTY2hlZHVsZWQpIHtcbiAgICAgIHRoaXMubG9hZGluZ1BsYXlsaXN0KGxldmVsT3JUcmFjaywgZGVsaXZlcnlEaXJlY3RpdmVzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZXN0aW1hdGVkVGltZVVudGlsVXBkYXRlID0gcmVxdWVzdFNjaGVkdWxlZCAtIG5vdztcbiAgICB0aGlzLmxvZyhgcmVsb2FkIGxpdmUgcGxheWxpc3QgJHtsZXZlbE9yVHJhY2submFtZSB8fCBsZXZlbE9yVHJhY2suYml0cmF0ZSArICdicHMnfSBpbiAke01hdGgucm91bmQoZXN0aW1hdGVkVGltZVVudGlsVXBkYXRlKX0gbXNgKTtcbiAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICB0aGlzLnRpbWVyID0gc2VsZi5zZXRUaW1lb3V0KCgpID0+IHRoaXMubG9hZGluZ1BsYXlsaXN0KGxldmVsT3JUcmFjaywgZGVsaXZlcnlEaXJlY3RpdmVzKSwgZXN0aW1hdGVkVGltZVVudGlsVXBkYXRlKTtcbiAgfVxuICBnZXREZWxpdmVyeURpcmVjdGl2ZXMoZGV0YWlscywgcHJldmlvdXNEZWxpdmVyeURpcmVjdGl2ZXMsIG1zbiwgcGFydCkge1xuICAgIGxldCBza2lwID0gZ2V0U2tpcFZhbHVlKGRldGFpbHMpO1xuICAgIGlmIChwcmV2aW91c0RlbGl2ZXJ5RGlyZWN0aXZlcyAhPSBudWxsICYmIHByZXZpb3VzRGVsaXZlcnlEaXJlY3RpdmVzLnNraXAgJiYgZGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCkge1xuICAgICAgbXNuID0gcHJldmlvdXNEZWxpdmVyeURpcmVjdGl2ZXMubXNuO1xuICAgICAgcGFydCA9IHByZXZpb3VzRGVsaXZlcnlEaXJlY3RpdmVzLnBhcnQ7XG4gICAgICBza2lwID0gSGxzU2tpcC5ObztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBIbHNVcmxQYXJhbWV0ZXJzKG1zbiwgcGFydCwgc2tpcCk7XG4gIH1cbiAgY2hlY2tSZXRyeShlcnJvckV2ZW50KSB7XG4gICAgY29uc3QgZXJyb3JEZXRhaWxzID0gZXJyb3JFdmVudC5kZXRhaWxzO1xuICAgIGNvbnN0IGlzVGltZW91dCA9IGlzVGltZW91dEVycm9yKGVycm9yRXZlbnQpO1xuICAgIGNvbnN0IGVycm9yQWN0aW9uID0gZXJyb3JFdmVudC5lcnJvckFjdGlvbjtcbiAgICBjb25zdCB7XG4gICAgICBhY3Rpb24sXG4gICAgICByZXRyeUNvdW50ID0gMCxcbiAgICAgIHJldHJ5Q29uZmlnXG4gICAgfSA9IGVycm9yQWN0aW9uIHx8IHt9O1xuICAgIGNvbnN0IHJldHJ5ID0gISFlcnJvckFjdGlvbiAmJiAhIXJldHJ5Q29uZmlnICYmIChhY3Rpb24gPT09IE5ldHdvcmtFcnJvckFjdGlvbi5SZXRyeVJlcXVlc3QgfHwgIWVycm9yQWN0aW9uLnJlc29sdmVkICYmIGFjdGlvbiA9PT0gTmV0d29ya0Vycm9yQWN0aW9uLlNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3gpO1xuICAgIGlmIChyZXRyeSkge1xuICAgICAgdmFyIF9lcnJvckV2ZW50JGNvbnRleHQ7XG4gICAgICBpZiAocmV0cnlDb3VudCA+PSByZXRyeUNvbmZpZy5tYXhOdW1SZXRyeSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNUaW1lb3V0ICYmIChfZXJyb3JFdmVudCRjb250ZXh0ID0gZXJyb3JFdmVudC5jb250ZXh0KSAhPSBudWxsICYmIF9lcnJvckV2ZW50JGNvbnRleHQuZGVsaXZlcnlEaXJlY3RpdmVzKSB7XG4gICAgICAgIC8vIFRoZSBMTC1ITFMgcmVxdWVzdCBhbHJlYWR5IHRpbWVkIG91dCBzbyByZXRyeSBpbW1lZGlhdGVseVxuICAgICAgICB0aGlzLndhcm4oYFJldHJ5aW5nIHBsYXlsaXN0IGxvYWRpbmcgJHtyZXRyeUNvdW50ICsgMX0vJHtyZXRyeUNvbmZpZy5tYXhOdW1SZXRyeX0gYWZ0ZXIgXCIke2Vycm9yRGV0YWlsc31cIiB3aXRob3V0IGRlbGl2ZXJ5LWRpcmVjdGl2ZXNgKTtcbiAgICAgICAgdGhpcy5sb2FkUGxheWxpc3QoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGRlbGF5ID0gZ2V0UmV0cnlEZWxheShyZXRyeUNvbmZpZywgcmV0cnlDb3VudCk7XG4gICAgICAgIC8vIFNjaGVkdWxlIGxldmVsL3RyYWNrIHJlbG9hZFxuICAgICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgICAgdGhpcy50aW1lciA9IHNlbGYuc2V0VGltZW91dCgoKSA9PiB0aGlzLmxvYWRQbGF5bGlzdCgpLCBkZWxheSk7XG4gICAgICAgIHRoaXMud2FybihgUmV0cnlpbmcgcGxheWxpc3QgbG9hZGluZyAke3JldHJ5Q291bnQgKyAxfS8ke3JldHJ5Q29uZmlnLm1heE51bVJldHJ5fSBhZnRlciBcIiR7ZXJyb3JEZXRhaWxzfVwiIGluICR7ZGVsYXl9bXNgKTtcbiAgICAgIH1cbiAgICAgIC8vIGBsZXZlbFJldHJ5ID0gdHJ1ZWAgdXNlZCB0byBpbmZvcm0gb3RoZXIgY29udHJvbGxlcnMgdGhhdCBhIHJldHJ5IGlzIGhhcHBlbmluZ1xuICAgICAgZXJyb3JFdmVudC5sZXZlbFJldHJ5ID0gdHJ1ZTtcbiAgICAgIGVycm9yQWN0aW9uLnJlc29sdmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJldHJ5O1xuICB9XG59XG5cbmZ1bmN0aW9uIHN1YnRpdGxlT3B0aW9uc0lkZW50aWNhbCh0cmFja0xpc3QxLCB0cmFja0xpc3QyKSB7XG4gIGlmICh0cmFja0xpc3QxLmxlbmd0aCAhPT0gdHJhY2tMaXN0Mi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFja0xpc3QxLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFtZWRpYUF0dHJpYnV0ZXNJZGVudGljYWwodHJhY2tMaXN0MVtpXS5hdHRycywgdHJhY2tMaXN0MltpXS5hdHRycykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBtZWRpYUF0dHJpYnV0ZXNJZGVudGljYWwoYXR0cnMxLCBhdHRyczIsIGN1c3RvbUF0dHJpYnV0ZXMpIHtcbiAgLy8gTWVkaWEgb3B0aW9ucyB3aXRoIHRoZSBzYW1lIHJlbmRpdGlvbiBJRCBtdXN0IGJlIGJpdCBpZGVudGljYWxcbiAgY29uc3Qgc3RhYmxlUmVuZGl0aW9uSWQgPSBhdHRyczFbJ1NUQUJMRS1SRU5ESVRJT04tSUQnXTtcbiAgaWYgKHN0YWJsZVJlbmRpdGlvbklkICYmICFjdXN0b21BdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIHN0YWJsZVJlbmRpdGlvbklkID09PSBhdHRyczJbJ1NUQUJMRS1SRU5ESVRJT04tSUQnXTtcbiAgfVxuICAvLyBXaGVuIHJlbmRpdGlvbiBJRCBpcyBub3QgcHJlc2VudCwgY29tcGFyZSBhdHRyaWJ1dGVzXG4gIHJldHVybiAhKGN1c3RvbUF0dHJpYnV0ZXMgfHwgWydMQU5HVUFHRScsICdOQU1FJywgJ0NIQVJBQ1RFUklTVElDUycsICdBVVRPU0VMRUNUJywgJ0RFRkFVTFQnLCAnRk9SQ0VEJywgJ0FTU09DLUxBTkdVQUdFJ10pLnNvbWUoc3VidGl0bGVBdHRyaWJ1dGUgPT4gYXR0cnMxW3N1YnRpdGxlQXR0cmlidXRlXSAhPT0gYXR0cnMyW3N1YnRpdGxlQXR0cmlidXRlXSk7XG59XG5mdW5jdGlvbiBzdWJ0aXRsZVRyYWNrTWF0Y2hlc1RleHRUcmFjayhzdWJ0aXRsZVRyYWNrLCB0ZXh0VHJhY2spIHtcbiAgcmV0dXJuIHRleHRUcmFjay5sYWJlbC50b0xvd2VyQ2FzZSgpID09PSBzdWJ0aXRsZVRyYWNrLm5hbWUudG9Mb3dlckNhc2UoKSAmJiAoIXRleHRUcmFjay5sYW5ndWFnZSB8fCB0ZXh0VHJhY2subGFuZ3VhZ2UudG9Mb3dlckNhc2UoKSA9PT0gKHN1YnRpdGxlVHJhY2subGFuZyB8fCAnJykudG9Mb3dlckNhc2UoKSk7XG59XG5cbmNsYXNzIEF1ZGlvVHJhY2tDb250cm9sbGVyIGV4dGVuZHMgQmFzZVBsYXlsaXN0Q29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHN1cGVyKGhscywgJ2F1ZGlvLXRyYWNrLWNvbnRyb2xsZXInKTtcbiAgICB0aGlzLnRyYWNrcyA9IFtdO1xuICAgIHRoaXMuZ3JvdXBJZHMgPSBudWxsO1xuICAgIHRoaXMudHJhY2tzSW5Hcm91cCA9IFtdO1xuICAgIHRoaXMudHJhY2tJZCA9IC0xO1xuICAgIHRoaXMuY3VycmVudFRyYWNrID0gbnVsbDtcbiAgICB0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IHRydWU7XG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX1NXSVRDSElORywgdGhpcy5vbkxldmVsU3dpdGNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkFVRElPX1RSQUNLX0xPQURFRCwgdGhpcy5vbkF1ZGlvVHJhY2tMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH1cbiAgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxfTE9BRElORywgdGhpcy5vbkxldmVsTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxfU1dJVENISU5HLCB0aGlzLm9uTGV2ZWxTd2l0Y2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkFVRElPX1RSQUNLX0xPQURFRCwgdGhpcy5vbkF1ZGlvVHJhY2tMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy50cmFja3MubGVuZ3RoID0gMDtcbiAgICB0aGlzLnRyYWNrc0luR3JvdXAubGVuZ3RoID0gMDtcbiAgICB0aGlzLmN1cnJlbnRUcmFjayA9IG51bGw7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgdGhpcy50cmFja3NJbkdyb3VwID0gW107XG4gICAgdGhpcy5ncm91cElkcyA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50VHJhY2sgPSBudWxsO1xuICAgIHRoaXMudHJhY2tJZCA9IC0xO1xuICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gdHJ1ZTtcbiAgfVxuICBvbk1hbmlmZXN0UGFyc2VkKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy50cmFja3MgPSBkYXRhLmF1ZGlvVHJhY2tzIHx8IFtdO1xuICB9XG4gIG9uQXVkaW9UcmFja0xvYWRlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkLFxuICAgICAgZ3JvdXBJZCxcbiAgICAgIGRldGFpbHNcbiAgICB9ID0gZGF0YTtcbiAgICBjb25zdCB0cmFja0luQWN0aXZlR3JvdXAgPSB0aGlzLnRyYWNrc0luR3JvdXBbaWRdO1xuICAgIGlmICghdHJhY2tJbkFjdGl2ZUdyb3VwIHx8IHRyYWNrSW5BY3RpdmVHcm91cC5ncm91cElkICE9PSBncm91cElkKSB7XG4gICAgICB0aGlzLndhcm4oYEF1ZGlvIHRyYWNrIHdpdGggaWQ6JHtpZH0gYW5kIGdyb3VwOiR7Z3JvdXBJZH0gbm90IGZvdW5kIGluIGFjdGl2ZSBncm91cCAke3RyYWNrSW5BY3RpdmVHcm91cCA9PSBudWxsID8gdm9pZCAwIDogdHJhY2tJbkFjdGl2ZUdyb3VwLmdyb3VwSWR9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1ckRldGFpbHMgPSB0cmFja0luQWN0aXZlR3JvdXAuZGV0YWlscztcbiAgICB0cmFja0luQWN0aXZlR3JvdXAuZGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICB0aGlzLmxvZyhgQXVkaW8gdHJhY2sgJHtpZH0gXCIke3RyYWNrSW5BY3RpdmVHcm91cC5uYW1lfVwiIGxhbmc6JHt0cmFja0luQWN0aXZlR3JvdXAubGFuZ30gZ3JvdXA6JHtncm91cElkfSBsb2FkZWQgWyR7ZGV0YWlscy5zdGFydFNOfS0ke2RldGFpbHMuZW5kU059XWApO1xuICAgIGlmIChpZCA9PT0gdGhpcy50cmFja0lkKSB7XG4gICAgICB0aGlzLnBsYXlsaXN0TG9hZGVkKGlkLCBkYXRhLCBjdXJEZXRhaWxzKTtcbiAgICB9XG4gIH1cbiAgb25MZXZlbExvYWRpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLnN3aXRjaExldmVsKGRhdGEubGV2ZWwpO1xuICB9XG4gIG9uTGV2ZWxTd2l0Y2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLnN3aXRjaExldmVsKGRhdGEubGV2ZWwpO1xuICB9XG4gIHN3aXRjaExldmVsKGxldmVsSW5kZXgpIHtcbiAgICBjb25zdCBsZXZlbEluZm8gPSB0aGlzLmhscy5sZXZlbHNbbGV2ZWxJbmRleF07XG4gICAgaWYgKCFsZXZlbEluZm8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYXVkaW9Hcm91cHMgPSBsZXZlbEluZm8uYXVkaW9Hcm91cHMgfHwgbnVsbDtcbiAgICBjb25zdCBjdXJyZW50R3JvdXBzID0gdGhpcy5ncm91cElkcztcbiAgICBsZXQgY3VycmVudFRyYWNrID0gdGhpcy5jdXJyZW50VHJhY2s7XG4gICAgaWYgKCFhdWRpb0dyb3VwcyB8fCAoY3VycmVudEdyb3VwcyA9PSBudWxsID8gdm9pZCAwIDogY3VycmVudEdyb3Vwcy5sZW5ndGgpICE9PSAoYXVkaW9Hcm91cHMgPT0gbnVsbCA/IHZvaWQgMCA6IGF1ZGlvR3JvdXBzLmxlbmd0aCkgfHwgYXVkaW9Hcm91cHMgIT0gbnVsbCAmJiBhdWRpb0dyb3Vwcy5zb21lKGdyb3VwSWQgPT4gKGN1cnJlbnRHcm91cHMgPT0gbnVsbCA/IHZvaWQgMCA6IGN1cnJlbnRHcm91cHMuaW5kZXhPZihncm91cElkKSkgPT09IC0xKSkge1xuICAgICAgdGhpcy5ncm91cElkcyA9IGF1ZGlvR3JvdXBzO1xuICAgICAgdGhpcy50cmFja0lkID0gLTE7XG4gICAgICB0aGlzLmN1cnJlbnRUcmFjayA9IG51bGw7XG4gICAgICBjb25zdCBhdWRpb1RyYWNrcyA9IHRoaXMudHJhY2tzLmZpbHRlcih0cmFjayA9PiAhYXVkaW9Hcm91cHMgfHwgYXVkaW9Hcm91cHMuaW5kZXhPZih0cmFjay5ncm91cElkKSAhPT0gLTEpO1xuICAgICAgaWYgKGF1ZGlvVHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAvLyBEaXNhYmxlIHNlbGVjdERlZmF1bHRUcmFjayBpZiB0aGVyZSBhcmUgbm8gZGVmYXVsdCB0cmFja3NcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrICYmICFhdWRpb1RyYWNrcy5zb21lKHRyYWNrID0+IHRyYWNrLmRlZmF1bHQpKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0cmFjay5pZCBzaG91bGQgbWF0Y2ggaGxzLmF1ZGlvVHJhY2tzIGluZGV4XG4gICAgICAgIGF1ZGlvVHJhY2tzLmZvckVhY2goKHRyYWNrLCBpKSA9PiB7XG4gICAgICAgICAgdHJhY2suaWQgPSBpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoIWN1cnJlbnRUcmFjayAmJiAhdGhpcy50cmFja3NJbkdyb3VwLmxlbmd0aCkge1xuICAgICAgICAvLyBEbyBub3QgZGlzcGF0Y2ggQVVESU9fVFJBQ0tTX1VQREFURUQgd2hlbiB0aGVyZSB3ZXJlIGFuZCBhcmUgbm8gdHJhY2tzXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMudHJhY2tzSW5Hcm91cCA9IGF1ZGlvVHJhY2tzO1xuXG4gICAgICAvLyBGaW5kIHByZWZlcnJlZCB0cmFja1xuICAgICAgY29uc3QgYXVkaW9QcmVmZXJlbmNlID0gdGhpcy5obHMuY29uZmlnLmF1ZGlvUHJlZmVyZW5jZTtcbiAgICAgIGlmICghY3VycmVudFRyYWNrICYmIGF1ZGlvUHJlZmVyZW5jZSkge1xuICAgICAgICBjb25zdCBncm91cEluZGV4ID0gZmluZE1hdGNoaW5nT3B0aW9uKGF1ZGlvUHJlZmVyZW5jZSwgYXVkaW9UcmFja3MsIGF1ZGlvTWF0Y2hQcmVkaWNhdGUpO1xuICAgICAgICBpZiAoZ3JvdXBJbmRleCA+IC0xKSB7XG4gICAgICAgICAgY3VycmVudFRyYWNrID0gYXVkaW9UcmFja3NbZ3JvdXBJbmRleF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgYWxsSW5kZXggPSBmaW5kTWF0Y2hpbmdPcHRpb24oYXVkaW9QcmVmZXJlbmNlLCB0aGlzLnRyYWNrcyk7XG4gICAgICAgICAgY3VycmVudFRyYWNrID0gdGhpcy50cmFja3NbYWxsSW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFNlbGVjdCBpbml0aWFsIHRyYWNrXG4gICAgICBsZXQgdHJhY2tJZCA9IHRoaXMuZmluZFRyYWNrSWQoY3VycmVudFRyYWNrKTtcbiAgICAgIGlmICh0cmFja0lkID09PSAtMSAmJiBjdXJyZW50VHJhY2spIHtcbiAgICAgICAgdHJhY2tJZCA9IHRoaXMuZmluZFRyYWNrSWQobnVsbCk7XG4gICAgICB9XG5cbiAgICAgIC8vIERpc3BhdGNoIGV2ZW50cyBhbmQgbG9hZCB0cmFjayBpZiBuZWVkZWRcbiAgICAgIGNvbnN0IGF1ZGlvVHJhY2tzVXBkYXRlZCA9IHtcbiAgICAgICAgYXVkaW9UcmFja3NcbiAgICAgIH07XG4gICAgICB0aGlzLmxvZyhgVXBkYXRpbmcgYXVkaW8gdHJhY2tzLCAke2F1ZGlvVHJhY2tzLmxlbmd0aH0gdHJhY2socykgZm91bmQgaW4gZ3JvdXAocyk6ICR7YXVkaW9Hcm91cHMgPT0gbnVsbCA/IHZvaWQgMCA6IGF1ZGlvR3JvdXBzLmpvaW4oJywnKX1gKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkFVRElPX1RSQUNLU19VUERBVEVELCBhdWRpb1RyYWNrc1VwZGF0ZWQpO1xuICAgICAgY29uc3Qgc2VsZWN0ZWRUcmFja0lkID0gdGhpcy50cmFja0lkO1xuICAgICAgaWYgKHRyYWNrSWQgIT09IC0xICYmIHNlbGVjdGVkVHJhY2tJZCA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5zZXRBdWRpb1RyYWNrKHRyYWNrSWQpO1xuICAgICAgfSBlbHNlIGlmIChhdWRpb1RyYWNrcy5sZW5ndGggJiYgc2VsZWN0ZWRUcmFja0lkID09PSAtMSkge1xuICAgICAgICB2YXIgX3RoaXMkZ3JvdXBJZHM7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBObyBhdWRpbyB0cmFjayBzZWxlY3RlZCBmb3IgY3VycmVudCBhdWRpbyBncm91cC1JRChzKTogJHsoX3RoaXMkZ3JvdXBJZHMgPSB0aGlzLmdyb3VwSWRzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkZ3JvdXBJZHMuam9pbignLCcpfSB0cmFjayBjb3VudDogJHthdWRpb1RyYWNrcy5sZW5ndGh9YCk7XG4gICAgICAgIHRoaXMud2FybihlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX0VSUk9SLFxuICAgICAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgICAgIGVycm9yXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKGRhdGEuZmF0YWwgfHwgIWRhdGEuY29udGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGF0YS5jb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0sgJiYgZGF0YS5jb250ZXh0LmlkID09PSB0aGlzLnRyYWNrSWQgJiYgKCF0aGlzLmdyb3VwSWRzIHx8IHRoaXMuZ3JvdXBJZHMuaW5kZXhPZihkYXRhLmNvbnRleHQuZ3JvdXBJZCkgIT09IC0xKSkge1xuICAgICAgdGhpcy5jaGVja1JldHJ5KGRhdGEpO1xuICAgIH1cbiAgfVxuICBnZXQgYWxsQXVkaW9UcmFja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2tzO1xuICB9XG4gIGdldCBhdWRpb1RyYWNrcygpIHtcbiAgICByZXR1cm4gdGhpcy50cmFja3NJbkdyb3VwO1xuICB9XG4gIGdldCBhdWRpb1RyYWNrKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrSWQ7XG4gIH1cbiAgc2V0IGF1ZGlvVHJhY2sobmV3SWQpIHtcbiAgICAvLyBJZiBhdWRpbyB0cmFjayBpcyBzZWxlY3RlZCBmcm9tIEFQSSB0aGVuIGRvbid0IGNob29zZSBmcm9tIHRoZSBtYW5pZmVzdCBkZWZhdWx0IHRyYWNrXG4gICAgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSBmYWxzZTtcbiAgICB0aGlzLnNldEF1ZGlvVHJhY2sobmV3SWQpO1xuICB9XG4gIHNldEF1ZGlvT3B0aW9uKGF1ZGlvT3B0aW9uKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLmNvbmZpZy5hdWRpb1ByZWZlcmVuY2UgPSBhdWRpb09wdGlvbjtcbiAgICBpZiAoYXVkaW9PcHRpb24pIHtcbiAgICAgIGNvbnN0IGFsbEF1ZGlvVHJhY2tzID0gdGhpcy5hbGxBdWRpb1RyYWNrcztcbiAgICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gZmFsc2U7XG4gICAgICBpZiAoYWxsQXVkaW9UcmFja3MubGVuZ3RoKSB7XG4gICAgICAgIC8vIEZpcnN0IHNlZSBpZiBjdXJyZW50IG9wdGlvbiBtYXRjaGVzIChubyBzd2l0Y2ggb3ApXG4gICAgICAgIGNvbnN0IGN1cnJlbnRUcmFjayA9IHRoaXMuY3VycmVudFRyYWNrO1xuICAgICAgICBpZiAoY3VycmVudFRyYWNrICYmIG1hdGNoZXNPcHRpb24oYXVkaW9PcHRpb24sIGN1cnJlbnRUcmFjaywgYXVkaW9NYXRjaFByZWRpY2F0ZSkpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudFRyYWNrO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmQgb3B0aW9uIGluIGF2YWlsYWJsZSB0cmFja3MgKHRyYWNrc0luR3JvdXApXG4gICAgICAgIGNvbnN0IGdyb3VwSW5kZXggPSBmaW5kTWF0Y2hpbmdPcHRpb24oYXVkaW9PcHRpb24sIHRoaXMudHJhY2tzSW5Hcm91cCwgYXVkaW9NYXRjaFByZWRpY2F0ZSk7XG4gICAgICAgIGlmIChncm91cEluZGV4ID4gLTEpIHtcbiAgICAgICAgICBjb25zdCB0cmFjayA9IHRoaXMudHJhY2tzSW5Hcm91cFtncm91cEluZGV4XTtcbiAgICAgICAgICB0aGlzLnNldEF1ZGlvVHJhY2soZ3JvdXBJbmRleCk7XG4gICAgICAgICAgcmV0dXJuIHRyYWNrO1xuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRUcmFjaykge1xuICAgICAgICAgIC8vIEZpbmQgb3B0aW9uIGluIG5lYXJlc3QgbGV2ZWwgYXVkaW8gZ3JvdXBcbiAgICAgICAgICBsZXQgc2VhcmNoSW5kZXggPSBobHMubG9hZExldmVsO1xuICAgICAgICAgIGlmIChzZWFyY2hJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHNlYXJjaEluZGV4ID0gaGxzLmZpcnN0QXV0b0xldmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzd2l0Y2hJbmRleCA9IGZpbmRDbG9zZXN0TGV2ZWxXaXRoQXVkaW9Hcm91cChhdWRpb09wdGlvbiwgaGxzLmxldmVscywgYWxsQXVkaW9UcmFja3MsIHNlYXJjaEluZGV4LCBhdWRpb01hdGNoUHJlZGljYXRlKTtcbiAgICAgICAgICBpZiAoc3dpdGNoSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBjb3VsZCBub3QgZmluZCBtYXRjaGluZyB2YXJpYW50XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gYW5kIHN3aXRjaCBsZXZlbCB0byBhY2hlaXZlIHRoZSBhdWRpbyBncm91cCBzd2l0Y2hcbiAgICAgICAgICBobHMubmV4dExvYWRMZXZlbCA9IHN3aXRjaEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdWRpb09wdGlvbi5jaGFubmVscyB8fCBhdWRpb09wdGlvbi5hdWRpb0NvZGVjKSB7XG4gICAgICAgICAgLy8gQ291bGQgbm90IGZpbmQgYSBtYXRjaCB3aXRoIGNvZGVjIC8gY2hhbm5lbHMgcHJlZGljYXRlXG4gICAgICAgICAgLy8gRmluZCBhIG1hdGNoIHdpdGhvdXQgY2hhbm5lbHMgb3IgY29kZWNcbiAgICAgICAgICBjb25zdCB3aXRob3V0Q29kZWNBbmRDaGFubmVsc01hdGNoID0gZmluZE1hdGNoaW5nT3B0aW9uKGF1ZGlvT3B0aW9uLCBhbGxBdWRpb1RyYWNrcyk7XG4gICAgICAgICAgaWYgKHdpdGhvdXRDb2RlY0FuZENoYW5uZWxzTWF0Y2ggPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGFsbEF1ZGlvVHJhY2tzW3dpdGhvdXRDb2RlY0FuZENoYW5uZWxzTWF0Y2hdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBzZXRBdWRpb1RyYWNrKG5ld0lkKSB7XG4gICAgY29uc3QgdHJhY2tzID0gdGhpcy50cmFja3NJbkdyb3VwO1xuXG4gICAgLy8gY2hlY2sgaWYgbGV2ZWwgaWR4IGlzIHZhbGlkXG4gICAgaWYgKG5ld0lkIDwgMCB8fCBuZXdJZCA+PSB0cmFja3MubGVuZ3RoKSB7XG4gICAgICB0aGlzLndhcm4oYEludmFsaWQgYXVkaW8gdHJhY2sgaWQ6ICR7bmV3SWR9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gZmFsc2U7XG4gICAgY29uc3QgbGFzdFRyYWNrID0gdGhpcy5jdXJyZW50VHJhY2s7XG4gICAgY29uc3QgdHJhY2sgPSB0cmFja3NbbmV3SWRdO1xuICAgIGNvbnN0IHRyYWNrTG9hZGVkID0gdHJhY2suZGV0YWlscyAmJiAhdHJhY2suZGV0YWlscy5saXZlO1xuICAgIGlmIChuZXdJZCA9PT0gdGhpcy50cmFja0lkICYmIHRyYWNrID09PSBsYXN0VHJhY2sgJiYgdHJhY2tMb2FkZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sb2coYFN3aXRjaGluZyB0byBhdWRpby10cmFjayAke25ld0lkfSBcIiR7dHJhY2submFtZX1cIiBsYW5nOiR7dHJhY2subGFuZ30gZ3JvdXA6JHt0cmFjay5ncm91cElkfSBjaGFubmVsczoke3RyYWNrLmNoYW5uZWxzfWApO1xuICAgIHRoaXMudHJhY2tJZCA9IG5ld0lkO1xuICAgIHRoaXMuY3VycmVudFRyYWNrID0gdHJhY2s7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENISU5HLCBfb2JqZWN0U3ByZWFkMih7fSwgdHJhY2spKTtcbiAgICAvLyBEbyBub3QgcmVsb2FkIHRyYWNrIHVubGVzcyBsaXZlXG4gICAgaWYgKHRyYWNrTG9hZGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhsc1VybFBhcmFtZXRlcnMgPSB0aGlzLnN3aXRjaFBhcmFtcyh0cmFjay51cmwsIGxhc3RUcmFjayA9PSBudWxsID8gdm9pZCAwIDogbGFzdFRyYWNrLmRldGFpbHMsIHRyYWNrLmRldGFpbHMpO1xuICAgIHRoaXMubG9hZFBsYXlsaXN0KGhsc1VybFBhcmFtZXRlcnMpO1xuICB9XG4gIGZpbmRUcmFja0lkKGN1cnJlbnRUcmFjaykge1xuICAgIGNvbnN0IGF1ZGlvVHJhY2tzID0gdGhpcy50cmFja3NJbkdyb3VwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXVkaW9UcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRyYWNrID0gYXVkaW9UcmFja3NbaV07XG4gICAgICBpZiAodGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgJiYgIXRyYWNrLmRlZmF1bHQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIWN1cnJlbnRUcmFjayB8fCBtYXRjaGVzT3B0aW9uKGN1cnJlbnRUcmFjaywgdHJhY2ssIGF1ZGlvTWF0Y2hQcmVkaWNhdGUpKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY3VycmVudFRyYWNrKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGxhbmcsXG4gICAgICAgIGFzc29jTGFuZyxcbiAgICAgICAgY2hhcmFjdGVyaXN0aWNzLFxuICAgICAgICBhdWRpb0NvZGVjLFxuICAgICAgICBjaGFubmVsc1xuICAgICAgfSA9IGN1cnJlbnRUcmFjaztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXVkaW9UcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdHJhY2sgPSBhdWRpb1RyYWNrc1tpXTtcbiAgICAgICAgaWYgKG1hdGNoZXNPcHRpb24oe1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgbGFuZyxcbiAgICAgICAgICBhc3NvY0xhbmcsXG4gICAgICAgICAgY2hhcmFjdGVyaXN0aWNzLFxuICAgICAgICAgIGF1ZGlvQ29kZWMsXG4gICAgICAgICAgY2hhbm5lbHNcbiAgICAgICAgfSwgdHJhY2ssIGF1ZGlvTWF0Y2hQcmVkaWNhdGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXVkaW9UcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdHJhY2sgPSBhdWRpb1RyYWNrc1tpXTtcbiAgICAgICAgaWYgKG1lZGlhQXR0cmlidXRlc0lkZW50aWNhbChjdXJyZW50VHJhY2suYXR0cnMsIHRyYWNrLmF0dHJzLCBbJ0xBTkdVQUdFJywgJ0FTU09DLUxBTkdVQUdFJywgJ0NIQVJBQ1RFUklTVElDUyddKSkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF1ZGlvVHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRyYWNrID0gYXVkaW9UcmFja3NbaV07XG4gICAgICAgIGlmIChtZWRpYUF0dHJpYnV0ZXNJZGVudGljYWwoY3VycmVudFRyYWNrLmF0dHJzLCB0cmFjay5hdHRycywgWydMQU5HVUFHRSddKSkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICBsb2FkUGxheWxpc3QoaGxzVXJsUGFyYW1ldGVycykge1xuICAgIHN1cGVyLmxvYWRQbGF5bGlzdCgpO1xuICAgIGNvbnN0IGF1ZGlvVHJhY2sgPSB0aGlzLmN1cnJlbnRUcmFjaztcbiAgICBpZiAoIXRoaXMuc2hvdWxkTG9hZFBsYXlsaXN0KGF1ZGlvVHJhY2spKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIERvIG5vdCBsb2FkIGF1ZGlvIHJlbmRpdGlvbiB3aXRoIFVSSSBtYXRjaGluZyBtYWluIHZhcmlhbnQgVVJJXG4gICAgaWYgKHVzZUFsdGVybmF0ZUF1ZGlvKGF1ZGlvVHJhY2sudXJsLCB0aGlzLmhscykpIHtcbiAgICAgIHRoaXMuc2NoZWR1bGVMb2FkaW5nKGF1ZGlvVHJhY2ssIGhsc1VybFBhcmFtZXRlcnMpO1xuICAgIH1cbiAgfVxuICBsb2FkaW5nUGxheWxpc3QoYXVkaW9UcmFjaywgaGxzVXJsUGFyYW1ldGVycykge1xuICAgIHN1cGVyLmxvYWRpbmdQbGF5bGlzdChhdWRpb1RyYWNrLCBobHNVcmxQYXJhbWV0ZXJzKTtcbiAgICBjb25zdCBpZCA9IGF1ZGlvVHJhY2suaWQ7XG4gICAgY29uc3QgZ3JvdXBJZCA9IGF1ZGlvVHJhY2suZ3JvdXBJZDtcbiAgICBjb25zdCB1cmwgPSB0aGlzLmdldFVybFdpdGhEaXJlY3RpdmVzKGF1ZGlvVHJhY2sudXJsLCBobHNVcmxQYXJhbWV0ZXJzKTtcbiAgICBjb25zdCBkZXRhaWxzID0gYXVkaW9UcmFjay5kZXRhaWxzO1xuICAgIGNvbnN0IGFnZSA9IGRldGFpbHMgPT0gbnVsbCA/IHZvaWQgMCA6IGRldGFpbHMuYWdlO1xuICAgIHRoaXMubG9nKGBMb2FkaW5nIGF1ZGlvLXRyYWNrICR7aWR9IFwiJHthdWRpb1RyYWNrLm5hbWV9XCIgbGFuZzoke2F1ZGlvVHJhY2subGFuZ30gZ3JvdXA6JHtncm91cElkfSR7KGhsc1VybFBhcmFtZXRlcnMgPT0gbnVsbCA/IHZvaWQgMCA6IGhsc1VybFBhcmFtZXRlcnMubXNuKSAhPT0gdW5kZWZpbmVkID8gJyBhdCBzbiAnICsgaGxzVXJsUGFyYW1ldGVycy5tc24gKyAnIHBhcnQgJyArIGhsc1VybFBhcmFtZXRlcnMucGFydCA6ICcnfSR7YWdlICYmIGRldGFpbHMubGl2ZSA/ICcgYWdlICcgKyBhZ2UudG9GaXhlZCgxKSArIChkZXRhaWxzLnR5cGUgPyAnICcgKyBkZXRhaWxzLnR5cGUgfHwgJycgOiAnJykgOiAnJ30gJHt1cmx9YCk7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQVVESU9fVFJBQ0tfTE9BRElORywge1xuICAgICAgdXJsLFxuICAgICAgaWQsXG4gICAgICBncm91cElkLFxuICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzOiBobHNVcmxQYXJhbWV0ZXJzIHx8IG51bGwsXG4gICAgICB0cmFjazogYXVkaW9UcmFja1xuICAgIH0pO1xuICB9XG59XG5cbmNsYXNzIEJ1ZmZlck9wZXJhdGlvblF1ZXVlIHtcbiAgY29uc3RydWN0b3Ioc291cmNlQnVmZmVyUmVmZXJlbmNlKSB7XG4gICAgdGhpcy50cmFja3MgPSB2b2lkIDA7XG4gICAgdGhpcy5xdWV1ZXMgPSB7XG4gICAgICB2aWRlbzogW10sXG4gICAgICBhdWRpbzogW10sXG4gICAgICBhdWRpb3ZpZGVvOiBbXVxuICAgIH07XG4gICAgdGhpcy50cmFja3MgPSBzb3VyY2VCdWZmZXJSZWZlcmVuY2U7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnRyYWNrcyA9IHRoaXMucXVldWVzID0gbnVsbDtcbiAgfVxuICBhcHBlbmQob3BlcmF0aW9uLCB0eXBlLCBwZW5kaW5nKSB7XG4gICAgaWYgKHRoaXMucXVldWVzID09PSBudWxsIHx8IHRoaXMudHJhY2tzID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHF1ZXVlID0gdGhpcy5xdWV1ZXNbdHlwZV07XG4gICAgcXVldWUucHVzaChvcGVyYXRpb24pO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIXBlbmRpbmcpIHtcbiAgICAgIHRoaXMuZXhlY3V0ZU5leHQodHlwZSk7XG4gICAgfVxuICB9XG4gIGFwcGVuZEJsb2NrZXIodHlwZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IHtcbiAgICAgICAgbGFiZWw6ICdhc3luYy1ibG9ja2VyJyxcbiAgICAgICAgZXhlY3V0ZTogcmVzb2x2ZSxcbiAgICAgICAgb25TdGFydDogKCkgPT4ge30sXG4gICAgICAgIG9uQ29tcGxldGU6ICgpID0+IHt9LFxuICAgICAgICBvbkVycm9yOiAoKSA9PiB7fVxuICAgICAgfTtcbiAgICAgIHRoaXMuYXBwZW5kKG9wZXJhdGlvbiwgdHlwZSk7XG4gICAgfSk7XG4gIH1cbiAgcHJlcGVuZEJsb2NrZXIodHlwZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGlmICh0aGlzLnF1ZXVlcykge1xuICAgICAgICBjb25zdCBvcGVyYXRpb24gPSB7XG4gICAgICAgICAgbGFiZWw6ICdhc3luYy1ibG9ja2VyLXByZXBlbmQnLFxuICAgICAgICAgIGV4ZWN1dGU6IHJlc29sdmUsXG4gICAgICAgICAgb25TdGFydDogKCkgPT4ge30sXG4gICAgICAgICAgb25Db21wbGV0ZTogKCkgPT4ge30sXG4gICAgICAgICAgb25FcnJvcjogKCkgPT4ge31cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5xdWV1ZXNbdHlwZV0udW5zaGlmdChvcGVyYXRpb24pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJlbW92ZUJsb2NrZXJzKCkge1xuICAgIGlmICh0aGlzLnF1ZXVlcyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBbdGhpcy5xdWV1ZXMudmlkZW8sIHRoaXMucXVldWVzLmF1ZGlvLCB0aGlzLnF1ZXVlcy5hdWRpb3ZpZGVvXS5mb3JFYWNoKHF1ZXVlID0+IHtcbiAgICAgIHZhciBfcXVldWUkO1xuICAgICAgY29uc3QgbGFiZWwgPSAoX3F1ZXVlJCA9IHF1ZXVlWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3F1ZXVlJC5sYWJlbDtcbiAgICAgIGlmIChsYWJlbCA9PT0gJ2FzeW5jLWJsb2NrZXInIHx8IGxhYmVsID09PSAnYXN5bmMtYmxvY2tlci1wcmVwZW5kJykge1xuICAgICAgICBxdWV1ZVswXS5leGVjdXRlKCk7XG4gICAgICAgIHF1ZXVlLnNwbGljZSgwLCAxKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB1bmJsb2NrQXVkaW8ob3ApIHtcbiAgICBpZiAodGhpcy5xdWV1ZXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcXVldWUgPSB0aGlzLnF1ZXVlcy5hdWRpbztcbiAgICBpZiAocXVldWVbMF0gPT09IG9wKSB7XG4gICAgICB0aGlzLnNoaWZ0QW5kRXhlY3V0ZU5leHQoJ2F1ZGlvJyk7XG4gICAgfVxuICB9XG4gIGV4ZWN1dGVOZXh0KHR5cGUpIHtcbiAgICBpZiAodGhpcy5xdWV1ZXMgPT09IG51bGwgfHwgdGhpcy50cmFja3MgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcXVldWUgPSB0aGlzLnF1ZXVlc1t0eXBlXTtcbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICBjb25zdCBvcGVyYXRpb24gPSBxdWV1ZVswXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIE9wZXJhdGlvbnMgYXJlIGV4cGVjdGVkIHRvIHJlc3VsdCBpbiBhbiAndXBkYXRlZW5kJyBldmVudCBiZWluZyBmaXJlZC4gSWYgbm90LCB0aGUgcXVldWUgd2lsbCBsb2NrLiBPcGVyYXRpb25zXG4gICAgICAgIC8vIHdoaWNoIGRvIG5vdCBlbmQgd2l0aCB0aGlzIGV2ZW50IG11c3QgY2FsbCBfb25TQlVwZGF0ZUVuZCBtYW51YWxseVxuICAgICAgICBvcGVyYXRpb24uZXhlY3V0ZSgpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdmFyIF90aGlzJHRyYWNrcyR0eXBlO1xuICAgICAgICBvcGVyYXRpb24ub25FcnJvcihlcnJvcik7XG4gICAgICAgIGlmICh0aGlzLnF1ZXVlcyA9PT0gbnVsbCB8fCB0aGlzLnRyYWNrcyA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9ubHkgc2hpZnQgdGhlIGN1cnJlbnQgb3BlcmF0aW9uIG9mZiwgb3RoZXJ3aXNlIHRoZSB1cGRhdGVlbmQgaGFuZGxlciB3aWxsIGRvIHRoaXMgZm9yIHVzXG4gICAgICAgIGNvbnN0IHNiID0gKF90aGlzJHRyYWNrcyR0eXBlID0gdGhpcy50cmFja3NbdHlwZV0pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyR0cmFja3MkdHlwZS5idWZmZXI7XG4gICAgICAgIGlmICghKHNiICE9IG51bGwgJiYgc2IudXBkYXRpbmcpKSB7XG4gICAgICAgICAgdGhpcy5zaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNoaWZ0QW5kRXhlY3V0ZU5leHQodHlwZSkge1xuICAgIGlmICh0aGlzLnF1ZXVlcyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnF1ZXVlc1t0eXBlXS5zaGlmdCgpO1xuICAgIHRoaXMuZXhlY3V0ZU5leHQodHlwZSk7XG4gIH1cbiAgY3VycmVudCh0eXBlKSB7XG4gICAgdmFyIF90aGlzJHF1ZXVlcztcbiAgICByZXR1cm4gKChfdGhpcyRxdWV1ZXMgPSB0aGlzLnF1ZXVlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHF1ZXVlc1t0eXBlXVswXSkgfHwgbnVsbDtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICBjb25zdCB7XG4gICAgICBxdWV1ZXMsXG4gICAgICB0cmFja3NcbiAgICB9ID0gdGhpcztcbiAgICBpZiAocXVldWVzID09PSBudWxsIHx8IHRyYWNrcyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGA8ZGVzdHJveWVkPmA7XG4gICAgfVxuICAgIHJldHVybiBgXG4ke3RoaXMubGlzdCgndmlkZW8nKX1cbiR7dGhpcy5saXN0KCdhdWRpbycpfVxuJHt0aGlzLmxpc3QoJ2F1ZGlvdmlkZW8nKX19YDtcbiAgfVxuICBsaXN0KHR5cGUpIHtcbiAgICB2YXIgX3RoaXMkcXVldWVzMiwgX3RoaXMkdHJhY2tzO1xuICAgIHJldHVybiAoX3RoaXMkcXVldWVzMiA9IHRoaXMucXVldWVzKSAhPSBudWxsICYmIF90aGlzJHF1ZXVlczJbdHlwZV0gfHwgKF90aGlzJHRyYWNrcyA9IHRoaXMudHJhY2tzKSAhPSBudWxsICYmIF90aGlzJHRyYWNrc1t0eXBlXSA/IGAke3R5cGV9OiAoJHt0aGlzLmxpc3RTYkluZm8odHlwZSl9KSAke3RoaXMubGlzdE9wcyh0eXBlKX1gIDogJyc7XG4gIH1cbiAgbGlzdFNiSW5mbyh0eXBlKSB7XG4gICAgdmFyIF90aGlzJHRyYWNrczI7XG4gICAgY29uc3QgdHJhY2sgPSAoX3RoaXMkdHJhY2tzMiA9IHRoaXMudHJhY2tzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkdHJhY2tzMlt0eXBlXTtcbiAgICBjb25zdCBzYiA9IHRyYWNrID09IG51bGwgPyB2b2lkIDAgOiB0cmFjay5idWZmZXI7XG4gICAgaWYgKCFzYikge1xuICAgICAgcmV0dXJuICdub25lJztcbiAgICB9XG4gICAgcmV0dXJuIGBTb3VyY2VCdWZmZXIke3NiLnVwZGF0aW5nID8gJyB1cGRhdGluZycgOiAnJ30ke3RyYWNrLmVuZGVkID8gJyBlbmRlZCcgOiAnJ30ke3RyYWNrLmVuZGluZyA/ICcgZW5kaW5nJyA6ICcnfWA7XG4gIH1cbiAgbGlzdE9wcyh0eXBlKSB7XG4gICAgdmFyIF90aGlzJHF1ZXVlczM7XG4gICAgcmV0dXJuICgoX3RoaXMkcXVldWVzMyA9IHRoaXMucXVldWVzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkcXVldWVzM1t0eXBlXS5tYXAob3AgPT4gb3AubGFiZWwpLmpvaW4oJywgJykpIHx8ICcnO1xuICB9XG59XG5cbmNvbnN0IFZJREVPX0NPREVDX1BST0ZJTEVfUkVQTEFDRSA9IC8oYXZjWzEyMzRdfGh2YzF8aGV2MXxkdmhbMWVdfHZwMDl8YXYwMSkoPzpcXC5bXi4sXSspKy87XG5jb25zdCBUUkFDS19SRU1PVkVEX0VSUk9SX05BTUUgPSAnSGxzSnNUcmFja1JlbW92ZWRFcnJvcic7XG5jbGFzcyBIbHNKc1RyYWNrUmVtb3ZlZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gVFJBQ0tfUkVNT1ZFRF9FUlJPUl9OQU1FO1xuICB9XG59XG5jbGFzcyBCdWZmZXJDb250cm9sbGVyIGV4dGVuZHMgTG9nZ2VyIHtcbiAgY29uc3RydWN0b3IoaGxzLCBmcmFnbWVudFRyYWNrZXIpIHtcbiAgICBzdXBlcignYnVmZmVyLWNvbnRyb2xsZXInLCBobHMubG9nZ2VyKTtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlciA9IHZvaWQgMDtcbiAgICAvLyBUaGUgbGV2ZWwgZGV0YWlscyB1c2VkIHRvIGRldGVybWluZSBkdXJhdGlvbiwgdGFyZ2V0LWR1cmF0aW9uIGFuZCBsaXZlXG4gICAgdGhpcy5kZXRhaWxzID0gbnVsbDtcbiAgICAvLyBjYWNoZSB0aGUgc2VsZiBnZW5lcmF0ZWQgb2JqZWN0IHVybCB0byBkZXRlY3QgaGlqYWNrIG9mIHZpZGVvIHRhZ1xuICAgIHRoaXMuX29iamVjdFVybCA9IG51bGw7XG4gICAgLy8gQSBxdWV1ZSBvZiBidWZmZXIgb3BlcmF0aW9ucyB3aGljaCByZXF1aXJlIHRoZSBTb3VyY2VCdWZmZXIgdG8gbm90IGJlIHVwZGF0aW5nIHVwb24gZXhlY3V0aW9uXG4gICAgdGhpcy5vcGVyYXRpb25RdWV1ZSA9IG51bGw7XG4gICAgLy8gVGhlIHRvdGFsIG51bWJlciB0cmFjayBjb2RlY3MgZXhwZWN0ZWQgYmVmb3JlIGFueSBzb3VyY2VCdWZmZXJzIGFyZSBjcmVhdGVkICgyOiBhdWRpbyBhbmQgdmlkZW8gb3IgMTogYXVkaW92aWRlbyB8IGF1ZGlvIHwgdmlkZW8pXG4gICAgdGhpcy5idWZmZXJDb2RlY0V2ZW50c1RvdGFsID0gMDtcbiAgICAvLyBBIHJlZmVyZW5jZSB0byB0aGUgYXR0YWNoZWQgbWVkaWEgZWxlbWVudFxuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIC8vIEEgcmVmZXJlbmNlIHRvIHRoZSBhY3RpdmUgbWVkaWEgc291cmNlXG4gICAgdGhpcy5tZWRpYVNvdXJjZSA9IG51bGw7XG4gICAgLy8gTGFzdCBNUDMgYXVkaW8gY2h1bmsgYXBwZW5kZWRcbiAgICB0aGlzLmxhc3RNcGVnQXVkaW9DaHVuayA9IG51bGw7XG4gICAgLy8gQXVkaW8gZnJhZ21lbnQgYmxvY2tlZCBmcm9tIGFwcGVuZGluZyB1bnRpbCBjb3JyZXNwb25kaW5nIHZpZGVvIGFwcGVuZHMgb3IgY29udGV4dCBjaGFuZ2VzXG4gICAgdGhpcy5ibG9ja2VkQXVkaW9BcHBlbmQgPSBudWxsO1xuICAgIC8vIEtlZXAgdHJhY2sgb2YgdmlkZW8gYXBwZW5kIHBvc2l0aW9uIGZvciB1bmJsb2NraW5nIGF1ZGlvXG4gICAgdGhpcy5sYXN0VmlkZW9BcHBlbmRFbmQgPSAwO1xuICAgIC8vIFdoZXRoZXIgb3Igbm90IHRvIHVzZSBNYW5hZ2VkTWVkaWFTb3VyY2UgQVBJIGFuZCBhcHBlbmQgc291cmNlIGVsZW1lbnQgdG8gbWVkaWEgZWxlbWVudC5cbiAgICB0aGlzLmFwcGVuZFNvdXJjZSA9IHZvaWQgMDtcbiAgICAvLyBUcmFuc2ZlcnJlZCBNZWRpYVNvdXJjZSBpbmZvcm1hdGlvbiB1c2VkIHRvIGRldG1lcmluZSBpZiBkdXJhdGlvbiBlbmQgZW5kc3RyZWFtIG1heSBiZSBhcHBlbmRlZFxuICAgIHRoaXMudHJhbnNmZXJEYXRhID0gdm9pZCAwO1xuICAgIC8vIERpcmVjdGl2ZXMgdXNlZCB0byBvdmVycmlkZSBkZWZhdWx0IE1lZGlhU291cmNlIGhhbmRsaW5nXG4gICAgdGhpcy5vdmVycmlkZXMgPSB2b2lkIDA7XG4gICAgLy8gRXJyb3IgY291bnRlcnNcbiAgICB0aGlzLmFwcGVuZEVycm9ycyA9IHtcbiAgICAgIGF1ZGlvOiAwLFxuICAgICAgdmlkZW86IDAsXG4gICAgICBhdWRpb3ZpZGVvOiAwXG4gICAgfTtcbiAgICAvLyBSZWNvcmQgb2YgcmVxdWlyZWQgb3IgY3JlYXRlZCBidWZmZXJzIGJ5IHR5cGUuIFNvdXJjZUJ1ZmZlciBpcyBzdG9yZWQgaW4gVHJhY2suYnVmZmVyIG9uY2UgY3JlYXRlZC5cbiAgICB0aGlzLnRyYWNrcyA9IHt9O1xuICAgIC8vIEFycmF5IG9mIFNvdXJjZUJ1ZmZlciB0eXBlIGFuZCBTb3VyY2VCdWZmZXIgKG9yIG51bGwpLiBPbmUgZW50cnkgcGVyIFRyYWNrU2V0IGluIHRoaXMudHJhY2tzLlxuICAgIHRoaXMuc291cmNlQnVmZmVycyA9IFtbbnVsbCwgbnVsbF0sIFtudWxsLCBudWxsXV07XG4gICAgdGhpcy5fb25FbmRTdHJlYW1pbmcgPSBldmVudCA9PiB7XG4gICAgICB2YXIgX3RoaXMkbWVkaWFTb3VyY2U7XG4gICAgICBpZiAoIXRoaXMuaGxzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICgoKF90aGlzJG1lZGlhU291cmNlID0gdGhpcy5tZWRpYVNvdXJjZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG1lZGlhU291cmNlLnJlYWR5U3RhdGUpICE9PSAnb3BlbicpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5obHMucGF1c2VCdWZmZXJpbmcoKTtcbiAgICB9O1xuICAgIHRoaXMuX29uU3RhcnRTdHJlYW1pbmcgPSBldmVudCA9PiB7XG4gICAgICBpZiAoIXRoaXMuaGxzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGxzLnJlc3VtZUJ1ZmZlcmluZygpO1xuICAgIH07XG4gICAgLy8gS2VlcCBhcyBhcnJvdyBmdW5jdGlvbnMgc28gdGhhdCB3ZSBjYW4gZGlyZWN0bHkgcmVmZXJlbmNlIHRoZXNlIGZ1bmN0aW9ucyBkaXJlY3RseSBhcyBldmVudCBsaXN0ZW5lcnNcbiAgICB0aGlzLl9vbk1lZGlhU291cmNlT3BlbiA9IGUgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBtZWRpYSxcbiAgICAgICAgbWVkaWFTb3VyY2VcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgaWYgKGUpIHtcbiAgICAgICAgdGhpcy5sb2coJ01lZGlhIHNvdXJjZSBvcGVuZWQnKTtcbiAgICAgIH1cbiAgICAgIGlmICghbWVkaWEgfHwgIW1lZGlhU291cmNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIG9uY2UgcmVjZWl2ZWQsIGRvbid0IGxpc3RlbiBhbnltb3JlIHRvIHNvdXJjZW9wZW4gZXZlbnRcbiAgICAgIG1lZGlhU291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCB0aGlzLl9vbk1lZGlhU291cmNlT3Blbik7XG4gICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdlbXB0aWVkJywgdGhpcy5fb25NZWRpYUVtcHRpZWQpO1xuICAgICAgdGhpcy51cGRhdGVEdXJhdGlvbigpO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHtcbiAgICAgICAgbWVkaWEsXG4gICAgICAgIG1lZGlhU291cmNlOiBtZWRpYVNvdXJjZVxuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5tZWRpYVNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmNoZWNrUGVuZGluZ1RyYWNrcygpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fb25NZWRpYVNvdXJjZUNsb3NlID0gKCkgPT4ge1xuICAgICAgdGhpcy5sb2coJ01lZGlhIHNvdXJjZSBjbG9zZWQnKTtcbiAgICB9O1xuICAgIHRoaXMuX29uTWVkaWFTb3VyY2VFbmRlZCA9ICgpID0+IHtcbiAgICAgIHRoaXMubG9nKCdNZWRpYSBzb3VyY2UgZW5kZWQnKTtcbiAgICB9O1xuICAgIHRoaXMuX29uTWVkaWFFbXB0aWVkID0gKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBtZWRpYVNyYyxcbiAgICAgICAgX29iamVjdFVybFxuICAgICAgfSA9IHRoaXM7XG4gICAgICBpZiAobWVkaWFTcmMgIT09IF9vYmplY3RVcmwpIHtcbiAgICAgICAgdGhpcy5lcnJvcihgTWVkaWEgZWxlbWVudCBzcmMgd2FzIHNldCB3aGlsZSBhdHRhY2hpbmcgTWVkaWFTb3VyY2UgKCR7X29iamVjdFVybH0gPiAke21lZGlhU3JjfSlgKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyID0gZnJhZ21lbnRUcmFja2VyO1xuICAgIHRoaXMuYXBwZW5kU291cmNlID0gaXNNYW5hZ2VkTWVkaWFTb3VyY2UoZ2V0TWVkaWFTb3VyY2UoaGxzLmNvbmZpZy5wcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UpKTtcbiAgICB0aGlzLmluaXRUcmFja3MoKTtcbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgaGFzU291cmNlVHlwZXMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMudHJhY2tzKS5sZW5ndGggPiAwO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5kZXRhaWxzID0gbnVsbDtcbiAgICB0aGlzLmxhc3RNcGVnQXVkaW9DaHVuayA9IHRoaXMuYmxvY2tlZEF1ZGlvQXBwZW5kID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zZmVyRGF0YSA9IHRoaXMub3ZlcnJpZGVzID0gdW5kZWZpbmVkO1xuICAgIGlmICh0aGlzLm9wZXJhdGlvblF1ZXVlKSB7XG4gICAgICB0aGlzLm9wZXJhdGlvblF1ZXVlLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMub3BlcmF0aW9uUXVldWUgPSBudWxsO1xuICAgIH1cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSB0aGlzLmZyYWdtZW50VHJhY2tlciA9IG51bGw7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuX29uTWVkaWFTb3VyY2VPcGVuID0gdGhpcy5fb25NZWRpYVNvdXJjZUNsb3NlID0gbnVsbDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5fb25NZWRpYVNvdXJjZUVuZGVkID0gbnVsbDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5fb25TdGFydFN0cmVhbWluZyA9IHRoaXMuX29uRW5kU3RyZWFtaW5nID0gbnVsbDtcbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX1JFU0VULCB0aGlzLm9uQnVmZmVyUmVzZXQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0FQUEVORElORywgdGhpcy5vbkJ1ZmZlckFwcGVuZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfQ09ERUNTLCB0aGlzLm9uQnVmZmVyQ29kZWNzLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9FT1MsIHRoaXMub25CdWZmZXJFb3MsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0ZMVVNISU5HLCB0aGlzLm9uQnVmZmVyRmx1c2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxfVVBEQVRFRCwgdGhpcy5vbkxldmVsVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX1BBUlNFRCwgdGhpcy5vbkZyYWdQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19DSEFOR0VELCB0aGlzLm9uRnJhZ0NoYW5nZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH1cbiAgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfUkVTRVQsIHRoaXMub25CdWZmZXJSZXNldCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0FQUEVORElORywgdGhpcy5vbkJ1ZmZlckFwcGVuZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0NPREVDUywgdGhpcy5vbkJ1ZmZlckNvZGVjcywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0VPUywgdGhpcy5vbkJ1ZmZlckVvcywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0ZMVVNISU5HLCB0aGlzLm9uQnVmZmVyRmx1c2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX1VQREFURUQsIHRoaXMub25MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfUEFSU0VELCB0aGlzLm9uRnJhZ1BhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19DSEFOR0VELCB0aGlzLm9uRnJhZ0NoYW5nZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9XG4gIHRyYW5zZmVyTWVkaWEoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbWVkaWEsXG4gICAgICBtZWRpYVNvdXJjZVxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghbWVkaWEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB0cmFja3MgPSB7fTtcbiAgICBpZiAodGhpcy5vcGVyYXRpb25RdWV1ZSkge1xuICAgICAgY29uc3QgdXBkYXRpbmcgPSB0aGlzLmlzVXBkYXRpbmcoKTtcbiAgICAgIGlmICghdXBkYXRpbmcpIHtcbiAgICAgICAgdGhpcy5vcGVyYXRpb25RdWV1ZS5yZW1vdmVCbG9ja2VycygpO1xuICAgICAgfVxuICAgICAgY29uc3QgcXVldWVkID0gdGhpcy5pc1F1ZXVlZCgpO1xuICAgICAgaWYgKHVwZGF0aW5nIHx8IHF1ZXVlZCkge1xuICAgICAgICB0aGlzLndhcm4oYFRyYW5zZmVyaW5nIE1lZGlhU291cmNlIHdpdGgke3F1ZXVlZCA/ICcgb3BlcmF0aW9ucyBpbiBxdWV1ZScgOiAnJ30ke3VwZGF0aW5nID8gJyB1cGRhdGluZyBTb3VyY2VCdWZmZXIocyknIDogJyd9ICR7dGhpcy5vcGVyYXRpb25RdWV1ZX1gKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub3BlcmF0aW9uUXVldWUuZGVzdHJveSgpO1xuICAgIH1cbiAgICBjb25zdCB0cmFuc2ZlckRhdGEgPSB0aGlzLnRyYW5zZmVyRGF0YTtcbiAgICBpZiAoIXRoaXMuc291cmNlQnVmZmVyQ291bnQgJiYgdHJhbnNmZXJEYXRhICYmIHRyYW5zZmVyRGF0YS5tZWRpYVNvdXJjZSA9PT0gbWVkaWFTb3VyY2UpIHtcbiAgICAgIF9leHRlbmRzKHRyYWNrcywgdHJhbnNmZXJEYXRhLnRyYWNrcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc291cmNlQnVmZmVycy5mb3JFYWNoKHR1cGxlID0+IHtcbiAgICAgICAgY29uc3QgW3R5cGVdID0gdHVwbGU7XG4gICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgdHJhY2tzW3R5cGVdID0gX2V4dGVuZHMoe30sIHRoaXMudHJhY2tzW3R5cGVdKTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUJ1ZmZlcih0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICB0dXBsZVswXSA9IHR1cGxlWzFdID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbWVkaWEsXG4gICAgICBtZWRpYVNvdXJjZSxcbiAgICAgIHRyYWNrc1xuICAgIH07XG4gIH1cbiAgaW5pdFRyYWNrcygpIHtcbiAgICBjb25zdCB0cmFja3MgPSB7fTtcbiAgICB0aGlzLnNvdXJjZUJ1ZmZlcnMgPSBbW251bGwsIG51bGxdLCBbbnVsbCwgbnVsbF1dO1xuICAgIHRoaXMudHJhY2tzID0gdHJhY2tzO1xuICAgIHRoaXMucmVzZXRRdWV1ZSgpO1xuICAgIHRoaXMucmVzZXRBcHBlbmRFcnJvcnMoKTtcbiAgICB0aGlzLmxhc3RNcGVnQXVkaW9DaHVuayA9IHRoaXMuYmxvY2tlZEF1ZGlvQXBwZW5kID0gbnVsbDtcbiAgICB0aGlzLmxhc3RWaWRlb0FwcGVuZEVuZCA9IDA7XG4gIH1cbiAgb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgdGhpcy5idWZmZXJDb2RlY0V2ZW50c1RvdGFsID0gMDtcbiAgICB0aGlzLmRldGFpbHMgPSBudWxsO1xuICB9XG4gIG9uTWFuaWZlc3RQYXJzZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgX3RoaXMkdHJhbnNmZXJEYXRhO1xuICAgIC8vIGluIGNhc2Ugb2YgYWx0IGF1ZGlvIDIgQlVGRkVSX0NPREVDUyBldmVudHMgd2lsbCBiZSB0cmlnZ2VyZWQsIG9uZSBwZXIgc3RyZWFtIGNvbnRyb2xsZXJcbiAgICAvLyBzb3VyY2VidWZmZXJzIHdpbGwgYmUgY3JlYXRlZCBhbGwgYXQgb25jZSB3aGVuIHRoZSBleHBlY3RlZCBuYiBvZiB0cmFja3Mgd2lsbCBiZSByZWFjaGVkXG4gICAgLy8gaW4gY2FzZSBhbHQgYXVkaW8gaXMgbm90IHVzZWQsIG9ubHkgb25lIEJVRkZFUl9DT0RFQyBldmVudCB3aWxsIGJlIGZpcmVkIGZyb20gbWFpbiBzdHJlYW0gY29udHJvbGxlclxuICAgIC8vIGl0IHdpbGwgY29udGFpbiB0aGUgZXhwZWN0ZWQgbmIgb2Ygc291cmNlIGJ1ZmZlcnMsIG5vIG5lZWQgdG8gY29tcHV0ZSBpdFxuICAgIGxldCBjb2RlY0V2ZW50cyA9IDI7XG4gICAgaWYgKGRhdGEuYXVkaW8gJiYgIWRhdGEudmlkZW8gfHwgIWRhdGEuYWx0QXVkaW8pIHtcbiAgICAgIGNvZGVjRXZlbnRzID0gMTtcbiAgICB9XG4gICAgdGhpcy5idWZmZXJDb2RlY0V2ZW50c1RvdGFsID0gY29kZWNFdmVudHM7XG4gICAgdGhpcy5sb2coYCR7Y29kZWNFdmVudHN9IGJ1ZmZlckNvZGVjIGV2ZW50KHMpIGV4cGVjdGVkLmApO1xuICAgIGlmICgoX3RoaXMkdHJhbnNmZXJEYXRhID0gdGhpcy50cmFuc2ZlckRhdGEpICE9IG51bGwgJiYgX3RoaXMkdHJhbnNmZXJEYXRhLm1lZGlhU291cmNlICYmIHRoaXMuc291cmNlQnVmZmVyQ291bnQgJiYgY29kZWNFdmVudHMpIHtcbiAgICAgIHRoaXMuYnVmZmVyQ3JlYXRlZCgpO1xuICAgIH1cbiAgfVxuICBvbk1lZGlhQXR0YWNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICBjb25zdCBNZWRpYVNvdXJjZSA9IGdldE1lZGlhU291cmNlKHRoaXMuYXBwZW5kU291cmNlKTtcbiAgICB0aGlzLnRyYW5zZmVyRGF0YSA9IHRoaXMub3ZlcnJpZGVzID0gdW5kZWZpbmVkO1xuICAgIGlmIChtZWRpYSAmJiBNZWRpYVNvdXJjZSkge1xuICAgICAgY29uc3QgdHJhbnNmZXJyaW5nTWVkaWEgPSAhIWRhdGEubWVkaWFTb3VyY2U7XG4gICAgICBpZiAodHJhbnNmZXJyaW5nTWVkaWEgfHwgZGF0YS5vdmVycmlkZXMpIHtcbiAgICAgICAgdGhpcy50cmFuc2ZlckRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLm92ZXJyaWRlcyA9IGRhdGEub3ZlcnJpZGVzO1xuICAgICAgfVxuICAgICAgY29uc3QgbXMgPSB0aGlzLm1lZGlhU291cmNlID0gZGF0YS5tZWRpYVNvdXJjZSB8fCBuZXcgTWVkaWFTb3VyY2UoKTtcbiAgICAgIHRoaXMuYXNzaWduTWVkaWFTb3VyY2UobXMpO1xuICAgICAgaWYgKHRyYW5zZmVycmluZ01lZGlhKSB7XG4gICAgICAgIHRoaXMuX29iamVjdFVybCA9IG1lZGlhLnNyYztcbiAgICAgICAgdGhpcy5hdHRhY2hUcmFuc2ZlcnJlZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY2FjaGUgdGhlIGxvY2FsbHkgZ2VuZXJhdGVkIG9iamVjdCB1cmxcbiAgICAgICAgY29uc3Qgb2JqZWN0VXJsID0gdGhpcy5fb2JqZWN0VXJsID0gc2VsZi5VUkwuY3JlYXRlT2JqZWN0VVJMKG1zKTtcbiAgICAgICAgLy8gbGluayB2aWRlbyBhbmQgbWVkaWEgU291cmNlXG4gICAgICAgIGlmICh0aGlzLmFwcGVuZFNvdXJjZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtZWRpYS5yZW1vdmVBdHRyaWJ1dGUoJ3NyYycpO1xuICAgICAgICAgICAgLy8gTWFuYWdlZE1lZGlhU291cmNlIHdpbGwgbm90IG9wZW4gd2l0aG91dCBkaXNhYmxlUmVtb3RlUGxheWJhY2sgc2V0IHRvIGZhbHNlIG9yIHNvdXJjZSBhbHRlcm5hdGl2ZXNcbiAgICAgICAgICAgIGNvbnN0IE1NUyA9IHNlbGYuTWFuYWdlZE1lZGlhU291cmNlO1xuICAgICAgICAgICAgbWVkaWEuZGlzYWJsZVJlbW90ZVBsYXliYWNrID0gbWVkaWEuZGlzYWJsZVJlbW90ZVBsYXliYWNrIHx8IE1NUyAmJiBtcyBpbnN0YW5jZW9mIE1NUztcbiAgICAgICAgICAgIHJlbW92ZVNvdXJjZUNoaWxkcmVuKG1lZGlhKTtcbiAgICAgICAgICAgIGFkZFNvdXJjZShtZWRpYSwgb2JqZWN0VXJsKTtcbiAgICAgICAgICAgIG1lZGlhLmxvYWQoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbWVkaWEuc3JjID0gb2JqZWN0VXJsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtZWRpYS5zcmMgPSBvYmplY3RVcmw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ2VtcHRpZWQnLCB0aGlzLl9vbk1lZGlhRW1wdGllZCk7XG4gICAgfVxuICB9XG4gIGFzc2lnbk1lZGlhU291cmNlKG1zKSB7XG4gICAgdmFyIF90aGlzJHRyYW5zZmVyRGF0YTIsIF9tcyRjb25zdHJ1Y3RvcjtcbiAgICB0aGlzLmxvZyhgJHsoKF90aGlzJHRyYW5zZmVyRGF0YTIgPSB0aGlzLnRyYW5zZmVyRGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHRyYW5zZmVyRGF0YTIubWVkaWFTb3VyY2UpID09PSBtcyA/ICd0cmFuc2ZlcnJlZCcgOiAnY3JlYXRlZCd9IG1lZGlhIHNvdXJjZTogJHsoX21zJGNvbnN0cnVjdG9yID0gbXMuY29uc3RydWN0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfbXMkY29uc3RydWN0b3IubmFtZX1gKTtcbiAgICAvLyBNZWRpYVNvdXJjZSBsaXN0ZW5lcnMgYXJlIGFycm93IGZ1bmN0aW9ucyB3aXRoIGEgbGV4aWNhbCBzY29wZSwgYW5kIGRvIG5vdCBuZWVkIHRvIGJlIGJvdW5kXG4gICAgbXMuYWRkRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIHRoaXMuX29uTWVkaWFTb3VyY2VPcGVuKTtcbiAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VlbmRlZCcsIHRoaXMuX29uTWVkaWFTb3VyY2VFbmRlZCk7XG4gICAgbXMuYWRkRXZlbnRMaXN0ZW5lcignc291cmNlY2xvc2UnLCB0aGlzLl9vbk1lZGlhU291cmNlQ2xvc2UpO1xuICAgIGlmICh0aGlzLmFwcGVuZFNvdXJjZSkge1xuICAgICAgbXMuYWRkRXZlbnRMaXN0ZW5lcignc3RhcnRzdHJlYW1pbmcnLCB0aGlzLl9vblN0YXJ0U3RyZWFtaW5nKTtcbiAgICAgIG1zLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZHN0cmVhbWluZycsIHRoaXMuX29uRW5kU3RyZWFtaW5nKTtcbiAgICB9XG4gIH1cbiAgYXR0YWNoVHJhbnNmZXJyZWQoKSB7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnRyYW5zZmVyRGF0YTtcbiAgICBpZiAoIWRhdGEgfHwgIW1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlcXVpcmVkVHJhY2tzID0gdGhpcy50cmFja3M7XG4gICAgY29uc3QgdHJhbnNmZXJyZWRUcmFja3MgPSBkYXRhLnRyYWNrcztcbiAgICBjb25zdCB0cmFja05hbWVzID0gdHJhbnNmZXJyZWRUcmFja3MgPyBPYmplY3Qua2V5cyh0cmFuc2ZlcnJlZFRyYWNrcykgOiBudWxsO1xuICAgIGNvbnN0IHRyYWNrQ291bnQgPSB0cmFja05hbWVzID8gdHJhY2tOYW1lcy5sZW5ndGggOiAwO1xuICAgIGNvbnN0IG1lZGlhU291cmNlT3BlbkNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMubWVkaWEgJiYgdGhpcy5tZWRpYVNvdXJjZU9wZW5PckVuZGVkKSB7XG4gICAgICAgIHRoaXMuX29uTWVkaWFTb3VyY2VPcGVuKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAodHJhbnNmZXJyZWRUcmFja3MgJiYgdHJhY2tOYW1lcyAmJiB0cmFja0NvdW50KSB7XG4gICAgICBpZiAoIXRoaXMudHJhY2tzUmVhZHkpIHtcbiAgICAgICAgLy8gV2FpdCBmb3IgQ09ERUNTIGV2ZW50KHMpXG4gICAgICAgIHRoaXMuaGxzLmNvbmZpZy5zdGFydEZyYWdQcmVmZXRjaCA9IHRydWU7XG4gICAgICAgIHRoaXMubG9nKGBhdHRhY2hUcmFuc2ZlcnJlZDogd2FpdGluZyBmb3IgU291cmNlQnVmZmVyIHRyYWNrIGluZm9gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2coYGF0dGFjaFRyYW5zZmVycmVkOiAoYnVmZmVyQ29kZWNFdmVudHNUb3RhbCAke3RoaXMuYnVmZmVyQ29kZWNFdmVudHNUb3RhbH0pXG5yZXF1aXJlZCB0cmFja3M6ICR7c3RyaW5naWZ5KHJlcXVpcmVkVHJhY2tzLCAoa2V5LCB2YWx1ZSkgPT4ga2V5ID09PSAnaW5pdFNlZ21lbnQnID8gdW5kZWZpbmVkIDogdmFsdWUpfTtcbnRyYW5zZmVyIHRyYWNrczogJHtzdHJpbmdpZnkodHJhbnNmZXJyZWRUcmFja3MsIChrZXksIHZhbHVlKSA9PiBrZXkgPT09ICdpbml0U2VnbWVudCcgPyB1bmRlZmluZWQgOiB2YWx1ZSl9fWApO1xuICAgICAgaWYgKCFpc0NvbXBhdGlibGVUcmFja0NoYW5nZSh0cmFuc2ZlcnJlZFRyYWNrcywgcmVxdWlyZWRUcmFja3MpKSB7XG4gICAgICAgIC8vIGRlc3Ryb3kgYXR0YWNoaW5nIG1lZGlhIHNvdXJjZVxuICAgICAgICBkYXRhLm1lZGlhU291cmNlID0gbnVsbDtcbiAgICAgICAgZGF0YS50cmFja3MgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgICAgIGNvbnN0IGRldGFpbHMgPSB0aGlzLmRldGFpbHM7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IE1hdGgubWF4KGN1cnJlbnRUaW1lLCAoZGV0YWlscyA9PSBudWxsID8gdm9pZCAwIDogZGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQpIHx8IDApO1xuICAgICAgICBpZiAoc3RhcnRUaW1lIC0gY3VycmVudFRpbWUgPiAxKSB7XG4gICAgICAgICAgdGhpcy5sb2coYGF0dGFjaFRyYW5zZmVycmVkOiB3YWl0aW5nIGZvciBwbGF5YmFjayB0byByZWFjaCBuZXcgdHJhY2tzIHN0YXJ0IHRpbWUgJHtjdXJyZW50VGltZX0gLT4gJHtzdGFydFRpbWV9YCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2FybihgYXR0YWNoVHJhbnNmZXJyZWQ6IHJlc2V0dGluZyBNZWRpYVNvdXJjZSBmb3IgaW5jb21wYXRpYmxlIHRyYWNrcyAoXCIke09iamVjdC5rZXlzKHRyYW5zZmVycmVkVHJhY2tzKX1cIi0+XCIke09iamVjdC5rZXlzKHJlcXVpcmVkVHJhY2tzKX1cIikgc3RhcnQgdGltZTogJHtzdGFydFRpbWV9IGN1cnJlbnRUaW1lOiAke2N1cnJlbnRUaW1lfWApO1xuICAgICAgICB0aGlzLm9uTWVkaWFEZXRhY2hpbmcoRXZlbnRzLk1FRElBX0RFVEFDSElORywge30pO1xuICAgICAgICB0aGlzLm9uTWVkaWFBdHRhY2hpbmcoRXZlbnRzLk1FRElBX0FUVEFDSElORywgZGF0YSk7XG4gICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gc3RhcnRUaW1lO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnRyYW5zZmVyRGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgIHRyYWNrTmFtZXMuZm9yRWFjaCh0cmFja05hbWUgPT4ge1xuICAgICAgICBjb25zdCB0eXBlID0gdHJhY2tOYW1lO1xuICAgICAgICBjb25zdCB0cmFjayA9IHRyYW5zZmVycmVkVHJhY2tzW3R5cGVdO1xuICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICBjb25zdCBzYiA9IHRyYWNrLmJ1ZmZlcjtcbiAgICAgICAgICBpZiAoc2IpIHtcbiAgICAgICAgICAgIC8vIFB1cmdlIGZyYWdtZW50IHRyYWNrZXIgb2YgZWplY3RlZCBzZWdtZW50cyBmb3IgZXhpc3RpbmcgYnVmZmVyXG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudFRyYWNrZXIgPSB0aGlzLmZyYWdtZW50VHJhY2tlcjtcbiAgICAgICAgICAgIGNvbnN0IHBsYXlsaXN0VHlwZSA9IHRyYWNrLmlkO1xuICAgICAgICAgICAgaWYgKGZyYWdtZW50VHJhY2tlci5oYXNGcmFnbWVudHMocGxheWxpc3RUeXBlKSB8fCBmcmFnbWVudFRyYWNrZXIuaGFzUGFydHMocGxheWxpc3RUeXBlKSkge1xuICAgICAgICAgICAgICBjb25zdCBidWZmZXJlZFRpbWVSYW5nZXMgPSBCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQoc2IpO1xuICAgICAgICAgICAgICBmcmFnbWVudFRyYWNrZXIuZGV0ZWN0RXZpY3RlZEZyYWdtZW50cyh0eXBlLCBidWZmZXJlZFRpbWVSYW5nZXMsIHBsYXlsaXN0VHlwZSwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUcmFuc2ZlciBTb3VyY2VCdWZmZXJcbiAgICAgICAgICAgIGNvbnN0IHNiSW5kZXggPSBzb3VyY2VCdWZmZXJOYW1lVG9JbmRleCh0eXBlKTtcbiAgICAgICAgICAgIGNvbnN0IHNiVHVwbGUgPSBbdHlwZSwgc2JdO1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VCdWZmZXJzW3NiSW5kZXhdID0gc2JUdXBsZTtcbiAgICAgICAgICAgIGlmIChzYi51cGRhdGluZyAmJiB0aGlzLm9wZXJhdGlvblF1ZXVlKSB7XG4gICAgICAgICAgICAgIHRoaXMub3BlcmF0aW9uUXVldWUucHJlcGVuZEJsb2NrZXIodHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyYWNrU291cmNlQnVmZmVyKHR5cGUsIHRyYWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbWVkaWFTb3VyY2VPcGVuQ2FsbGJhY2soKTtcbiAgICAgIHRoaXMuYnVmZmVyQ3JlYXRlZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvZyhgYXR0YWNoVHJhbnNmZXJyZWQ6IE1lZGlhU291cmNlIHcvbyBTb3VyY2VCdWZmZXJzYCk7XG4gICAgICBtZWRpYVNvdXJjZU9wZW5DYWxsYmFjaygpO1xuICAgIH1cbiAgfVxuICBnZXQgbWVkaWFTb3VyY2VPcGVuT3JFbmRlZCgpIHtcbiAgICB2YXIgX3RoaXMkbWVkaWFTb3VyY2UyO1xuICAgIGNvbnN0IHJlYWR5U3RhdGUgPSAoX3RoaXMkbWVkaWFTb3VyY2UyID0gdGhpcy5tZWRpYVNvdXJjZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG1lZGlhU291cmNlMi5yZWFkeVN0YXRlO1xuICAgIHJldHVybiByZWFkeVN0YXRlID09PSAnb3BlbicgfHwgcmVhZHlTdGF0ZSA9PT0gJ2VuZGVkJztcbiAgfVxuICBvbk1lZGlhRGV0YWNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3QgdHJhbnNmZXJyaW5nTWVkaWEgPSAhIWRhdGEudHJhbnNmZXJNZWRpYTtcbiAgICB0aGlzLnRyYW5zZmVyRGF0YSA9IHRoaXMub3ZlcnJpZGVzID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHtcbiAgICAgIG1lZGlhLFxuICAgICAgbWVkaWFTb3VyY2UsXG4gICAgICBfb2JqZWN0VXJsXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKG1lZGlhU291cmNlKSB7XG4gICAgICB0aGlzLmxvZyhgbWVkaWEgc291cmNlICR7dHJhbnNmZXJyaW5nTWVkaWEgPyAndHJhbnNmZXJyaW5nJyA6ICdkZXRhY2hpbmcnfWApO1xuICAgICAgaWYgKHRyYW5zZmVycmluZ01lZGlhKSB7XG4gICAgICAgIC8vIERldGFjaCBTb3VyY2VCdWZmZXJzIHdpdGhvdXQgcmVtb3ZpbmcgZnJvbSBNZWRpYVNvdXJjZVxuICAgICAgICAvLyBhbmQgbGVhdmUgYHRyYWNrc2AgKHJlcXVpcmVkIFNvdXJjZUJ1ZmZlcnMgY29uZmlndXJhdGlvbilcbiAgICAgICAgdGhpcy5zb3VyY2VCdWZmZXJzLmZvckVhY2goKFt0eXBlXSkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUJ1ZmZlcih0eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlc2V0UXVldWUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLm1lZGlhU291cmNlT3Blbk9yRW5kZWQpIHtcbiAgICAgICAgICBjb25zdCBvcGVuID0gbWVkaWFTb3VyY2UucmVhZHlTdGF0ZSA9PT0gJ29wZW4nO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VCdWZmZXJzID0gbWVkaWFTb3VyY2Uuc291cmNlQnVmZmVycztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBzb3VyY2VCdWZmZXJzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgICAgICAgIHNvdXJjZUJ1ZmZlcnNbaV0uYWJvcnQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBtZWRpYVNvdXJjZS5yZW1vdmVTb3VyY2VCdWZmZXIoc291cmNlQnVmZmVyc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgICAgICAvLyBlbmRPZlN0cmVhbSBjb3VsZCB0cmlnZ2VyIGV4Y2VwdGlvbiBpZiBhbnkgc291cmNlYnVmZmVyIGlzIGluIHVwZGF0aW5nIHN0YXRlXG4gICAgICAgICAgICAgIC8vIHdlIGRvbid0IHJlYWxseSBjYXJlIGFib3V0IGNoZWNraW5nIHNvdXJjZWJ1ZmZlciBzdGF0ZSBoZXJlLFxuICAgICAgICAgICAgICAvLyBhcyB3ZSBhcmUgYW55d2F5IGRldGFjaGluZyB0aGUgTWVkaWFTb3VyY2VcbiAgICAgICAgICAgICAgLy8gbGV0J3MganVzdCBhdm9pZCB0aGlzIGV4Y2VwdGlvbiB0byBwcm9wYWdhdGVcbiAgICAgICAgICAgICAgbWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMud2Fybihgb25NZWRpYURldGFjaGluZzogJHtlcnIubWVzc2FnZX0gd2hpbGUgY2FsbGluZyBlbmRPZlN0cmVhbWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDbGVhbiB1cCB0aGUgU291cmNlQnVmZmVycyBieSBpbnZva2luZyBvbkJ1ZmZlclJlc2V0XG4gICAgICAgIGlmICh0aGlzLnNvdXJjZUJ1ZmZlckNvdW50KSB7XG4gICAgICAgICAgdGhpcy5vbkJ1ZmZlclJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1lZGlhU291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCB0aGlzLl9vbk1lZGlhU291cmNlT3Blbik7XG4gICAgICBtZWRpYVNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VlbmRlZCcsIHRoaXMuX29uTWVkaWFTb3VyY2VFbmRlZCk7XG4gICAgICBtZWRpYVNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VjbG9zZScsIHRoaXMuX29uTWVkaWFTb3VyY2VDbG9zZSk7XG4gICAgICBpZiAodGhpcy5hcHBlbmRTb3VyY2UpIHtcbiAgICAgICAgbWVkaWFTb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3RhcnRzdHJlYW1pbmcnLCB0aGlzLl9vblN0YXJ0U3RyZWFtaW5nKTtcbiAgICAgICAgbWVkaWFTb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kc3RyZWFtaW5nJywgdGhpcy5fb25FbmRTdHJlYW1pbmcpO1xuICAgICAgfVxuICAgICAgdGhpcy5tZWRpYVNvdXJjZSA9IG51bGw7XG4gICAgICB0aGlzLl9vYmplY3RVcmwgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIERldGFjaCBwcm9wZXJseSB0aGUgTWVkaWFTb3VyY2UgZnJvbSB0aGUgSFRNTE1lZGlhRWxlbWVudCBhc1xuICAgIC8vIHN1Z2dlc3RlZCBpbiBodHRwczovL2dpdGh1Yi5jb20vdzNjL21lZGlhLXNvdXJjZS9pc3N1ZXMvNTMuXG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdlbXB0aWVkJywgdGhpcy5fb25NZWRpYUVtcHRpZWQpO1xuICAgICAgaWYgKCF0cmFuc2ZlcnJpbmdNZWRpYSkge1xuICAgICAgICBpZiAoX29iamVjdFVybCkge1xuICAgICAgICAgIHNlbGYuVVJMLnJldm9rZU9iamVjdFVSTChfb2JqZWN0VXJsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFuIHVwIHZpZGVvIHRhZyBzcmMgb25seSBpZiBpdCdzIG91ciBvd24gdXJsLiBzb21lIGV4dGVybmFsIGxpYnJhcmllcyBtaWdodFxuICAgICAgICAvLyBoaWphY2sgdGhlIHZpZGVvIHRhZyBhbmQgY2hhbmdlIGl0cyAnc3JjJyB3aXRob3V0IGRlc3Ryb3lpbmcgdGhlIEhscyBpbnN0YW5jZSBmaXJzdFxuICAgICAgICBpZiAodGhpcy5tZWRpYVNyYyA9PT0gX29iamVjdFVybCkge1xuICAgICAgICAgIG1lZGlhLnJlbW92ZUF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgICAgICAgaWYgKHRoaXMuYXBwZW5kU291cmNlKSB7XG4gICAgICAgICAgICByZW1vdmVTb3VyY2VDaGlsZHJlbihtZWRpYSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1lZGlhLmxvYWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLndhcm4oJ21lZGlhfHNvdXJjZS5zcmMgd2FzIGNoYW5nZWQgYnkgYSB0aGlyZCBwYXJ0eSAtIHNraXAgY2xlYW51cCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTUVESUFfREVUQUNIRUQsIGRhdGEpO1xuICB9XG4gIG9uQnVmZmVyUmVzZXQoKSB7XG4gICAgdGhpcy5zb3VyY2VCdWZmZXJzLmZvckVhY2goKFt0eXBlXSkgPT4ge1xuICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgdGhpcy5yZXNldEJ1ZmZlcih0eXBlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmluaXRUcmFja3MoKTtcbiAgfVxuICByZXNldEJ1ZmZlcih0eXBlKSB7XG4gICAgdmFyIF90aGlzJHRyYWNrcyR0eXBlO1xuICAgIGNvbnN0IHNiID0gKF90aGlzJHRyYWNrcyR0eXBlID0gdGhpcy50cmFja3NbdHlwZV0pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyR0cmFja3MkdHlwZS5idWZmZXI7XG4gICAgdGhpcy5yZW1vdmVCdWZmZXIodHlwZSk7XG4gICAgaWYgKHNiKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgX3RoaXMkbWVkaWFTb3VyY2UzO1xuICAgICAgICBpZiAoKF90aGlzJG1lZGlhU291cmNlMyA9IHRoaXMubWVkaWFTb3VyY2UpICE9IG51bGwgJiYgX3RoaXMkbWVkaWFTb3VyY2UzLnNvdXJjZUJ1ZmZlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5tZWRpYVNvdXJjZS5yZW1vdmVTb3VyY2VCdWZmZXIoc2IpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy53YXJuKGBvbkJ1ZmZlclJlc2V0ICR7dHlwZX1gLCBlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgICBkZWxldGUgdGhpcy50cmFja3NbdHlwZV07XG4gIH1cbiAgcmVtb3ZlQnVmZmVyKHR5cGUpIHtcbiAgICB0aGlzLnJlbW92ZUJ1ZmZlckxpc3RlbmVycyh0eXBlKTtcbiAgICB0aGlzLnNvdXJjZUJ1ZmZlcnNbc291cmNlQnVmZmVyTmFtZVRvSW5kZXgodHlwZSldID0gW251bGwsIG51bGxdO1xuICAgIGNvbnN0IHRyYWNrID0gdGhpcy50cmFja3NbdHlwZV07XG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICB0cmFjay5idWZmZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIHJlc2V0UXVldWUoKSB7XG4gICAgaWYgKHRoaXMub3BlcmF0aW9uUXVldWUpIHtcbiAgICAgIHRoaXMub3BlcmF0aW9uUXVldWUuZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLm9wZXJhdGlvblF1ZXVlID0gbmV3IEJ1ZmZlck9wZXJhdGlvblF1ZXVlKHRoaXMudHJhY2tzKTtcbiAgfVxuICBvbkJ1ZmZlckNvZGVjcyhldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHRyYWNrcyA9IHRoaXMudHJhY2tzO1xuICAgIGNvbnN0IHRyYWNrTmFtZXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgICB0aGlzLmxvZyhgQlVGRkVSX0NPREVDUzogXCIke3RyYWNrTmFtZXN9XCIgKGN1cnJlbnQgU0IgY291bnQgJHt0aGlzLnNvdXJjZUJ1ZmZlckNvdW50fSlgKTtcbiAgICBjb25zdCB1bm11eGVkVG9NdXhlZCA9ICdhdWRpb3ZpZGVvJyBpbiBkYXRhICYmICh0cmFja3MuYXVkaW8gfHwgdHJhY2tzLnZpZGVvKSB8fCB0cmFja3MuYXVkaW92aWRlbyAmJiAoJ2F1ZGlvJyBpbiBkYXRhIHx8ICd2aWRlbycgaW4gZGF0YSk7XG4gICAgY29uc3QgbXV4ZWRUb1VubXV4ZWQgPSAhdW5tdXhlZFRvTXV4ZWQgJiYgdGhpcy5zb3VyY2VCdWZmZXJDb3VudCAmJiB0aGlzLm1lZGlhICYmIHRyYWNrTmFtZXMuc29tZShzYk5hbWUgPT4gIXRyYWNrc1tzYk5hbWVdKTtcbiAgICBpZiAodW5tdXhlZFRvTXV4ZWQgfHwgbXV4ZWRUb1VubXV4ZWQpIHtcbiAgICAgIHRoaXMud2FybihgVW5zdXBwb3J0ZWQgdHJhbnNpdGlvbiBiZXR3ZWVuIFwiJHtPYmplY3Qua2V5cyh0cmFja3MpfVwiIGFuZCBcIiR7dHJhY2tOYW1lc31cIiBTb3VyY2VCdWZmZXJzYCk7XG4gICAgICAvLyBEbyBub3QgYWRkIGluY29tcGF0aWJsZSB0cmFjayAoJ2F1ZGlvdmlkZW8nIDwtPiAndmlkZW8nLydhdWRpbycpLlxuICAgICAgLy8gQWxsb3cgZm9sbG93aW5nIG9uQnVmZmVyQXBwZW5kaW5nIGhhbmRsZSB0byB0cmlnZ2VyIEJVRkZFUl9BUFBFTkRfRVJST1IuXG4gICAgICAvLyBUaGlzIHdpbGwgZWl0aGVyIGJlIHJlc29sdmVkIGJ5IGxldmVsIHN3aXRjaCBvciBjb3VsZCBiZSBoYW5kbGVkIHdpdGggcmVjb3Zlck1lZGlhRXJyb3IoKS5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJhY2tOYW1lcy5mb3JFYWNoKHRyYWNrTmFtZSA9PiB7XG4gICAgICB2YXIgX3RoaXMkdHJhbnNmZXJEYXRhMywgX3RoaXMkdHJhbnNmZXJEYXRhMyR0LCBfdHJhY2tDb2RlYztcbiAgICAgIGNvbnN0IHBhcnNlZFRyYWNrID0gZGF0YVt0cmFja05hbWVdO1xuICAgICAgY29uc3Qge1xuICAgICAgICBpZCxcbiAgICAgICAgY29kZWMsXG4gICAgICAgIGxldmVsQ29kZWMsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgIHN1cHBsZW1lbnRhbFxuICAgICAgfSA9IHBhcnNlZFRyYWNrO1xuICAgICAgbGV0IHRyYWNrID0gdHJhY2tzW3RyYWNrTmFtZV07XG4gICAgICBjb25zdCB0cmFuc2ZlcnJlZFRyYWNrID0gKF90aGlzJHRyYW5zZmVyRGF0YTMgPSB0aGlzLnRyYW5zZmVyRGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IChfdGhpcyR0cmFuc2ZlckRhdGEzJHQgPSBfdGhpcyR0cmFuc2ZlckRhdGEzLnRyYWNrcykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHRyYW5zZmVyRGF0YTMkdFt0cmFja05hbWVdO1xuICAgICAgY29uc3Qgc2JUcmFjayA9IHRyYW5zZmVycmVkVHJhY2sgIT0gbnVsbCAmJiB0cmFuc2ZlcnJlZFRyYWNrLmJ1ZmZlciA/IHRyYW5zZmVycmVkVHJhY2sgOiB0cmFjaztcbiAgICAgIGNvbnN0IHNiQ29kZWMgPSAoc2JUcmFjayA9PSBudWxsID8gdm9pZCAwIDogc2JUcmFjay5wZW5kaW5nQ29kZWMpIHx8IChzYlRyYWNrID09IG51bGwgPyB2b2lkIDAgOiBzYlRyYWNrLmNvZGVjKTtcbiAgICAgIGNvbnN0IHRyYWNrTGV2ZWxDb2RlYyA9IHNiVHJhY2sgPT0gbnVsbCA/IHZvaWQgMCA6IHNiVHJhY2subGV2ZWxDb2RlYztcbiAgICAgIGlmICghdHJhY2spIHtcbiAgICAgICAgdHJhY2sgPSB0cmFja3NbdHJhY2tOYW1lXSA9IHtcbiAgICAgICAgICBidWZmZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICBsaXN0ZW5lcnM6IFtdLFxuICAgICAgICAgIGNvZGVjLFxuICAgICAgICAgIHN1cHBsZW1lbnRhbCxcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgbGV2ZWxDb2RlYyxcbiAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICBpZFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgLy8gY2hlY2sgaWYgU291cmNlQnVmZmVyIGNvZGVjIG5lZWRzIHRvIGNoYW5nZVxuICAgICAgY29uc3QgY3VycmVudENvZGVjRnVsbCA9IHBpY2tNb3N0Q29tcGxldGVDb2RlY05hbWUoc2JDb2RlYywgdHJhY2tMZXZlbENvZGVjKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRDb2RlYyA9IGN1cnJlbnRDb2RlY0Z1bGwgPT0gbnVsbCA/IHZvaWQgMCA6IGN1cnJlbnRDb2RlY0Z1bGwucmVwbGFjZShWSURFT19DT0RFQ19QUk9GSUxFX1JFUExBQ0UsICckMScpO1xuICAgICAgbGV0IHRyYWNrQ29kZWMgPSBwaWNrTW9zdENvbXBsZXRlQ29kZWNOYW1lKGNvZGVjLCBsZXZlbENvZGVjKTtcbiAgICAgIGNvbnN0IG5leHRDb2RlYyA9IChfdHJhY2tDb2RlYyA9IHRyYWNrQ29kZWMpID09IG51bGwgPyB2b2lkIDAgOiBfdHJhY2tDb2RlYy5yZXBsYWNlKFZJREVPX0NPREVDX1BST0ZJTEVfUkVQTEFDRSwgJyQxJyk7XG4gICAgICBpZiAodHJhY2tDb2RlYyAmJiBjdXJyZW50Q29kZWNGdWxsICYmIGN1cnJlbnRDb2RlYyAhPT0gbmV4dENvZGVjKSB7XG4gICAgICAgIGlmICh0cmFja05hbWUuc2xpY2UoMCwgNSkgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICB0cmFja0NvZGVjID0gZ2V0Q29kZWNDb21wYXRpYmxlTmFtZSh0cmFja0NvZGVjLCB0aGlzLmFwcGVuZFNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2coYHN3aXRjaGluZyBjb2RlYyAke3NiQ29kZWN9IHRvICR7dHJhY2tDb2RlY31gKTtcbiAgICAgICAgaWYgKHRyYWNrQ29kZWMgIT09ICh0cmFjay5wZW5kaW5nQ29kZWMgfHwgdHJhY2suY29kZWMpKSB7XG4gICAgICAgICAgdHJhY2sucGVuZGluZ0NvZGVjID0gdHJhY2tDb2RlYztcbiAgICAgICAgfVxuICAgICAgICB0cmFjay5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hhbmdlVHlwZSh0cmFja05hbWUsIGNvbnRhaW5lciwgdHJhY2tDb2RlYyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHRoaXMudHJhY2tzUmVhZHkgfHwgdGhpcy5zb3VyY2VCdWZmZXJDb3VudCkge1xuICAgICAgZGF0YS50cmFja3MgPSB0aGlzLnNvdXJjZUJ1ZmZlclRyYWNrcztcbiAgICB9XG5cbiAgICAvLyBpZiBzb3VyY2VidWZmZXJzIGFscmVhZHkgY3JlYXRlZCwgZG8gbm90aGluZyAuLi5cbiAgICBpZiAodGhpcy5zb3VyY2VCdWZmZXJDb3VudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5tZWRpYVNvdXJjZU9wZW5PckVuZGVkKSB7XG4gICAgICB0aGlzLmNoZWNrUGVuZGluZ1RyYWNrcygpO1xuICAgIH1cbiAgfVxuICBnZXQgc291cmNlQnVmZmVyVHJhY2tzKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnRyYWNrcykucmVkdWNlKChiYXNlVHJhY2tzLCB0eXBlKSA9PiB7XG4gICAgICBjb25zdCB0cmFjayA9IHRoaXMudHJhY2tzW3R5cGVdO1xuICAgICAgYmFzZVRyYWNrc1t0eXBlXSA9IHtcbiAgICAgICAgaWQ6IHRyYWNrLmlkLFxuICAgICAgICBjb250YWluZXI6IHRyYWNrLmNvbnRhaW5lcixcbiAgICAgICAgY29kZWM6IHRyYWNrLmNvZGVjLFxuICAgICAgICBsZXZlbENvZGVjOiB0cmFjay5sZXZlbENvZGVjXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGJhc2VUcmFja3M7XG4gICAgfSwge30pO1xuICB9XG4gIGFwcGVuZENoYW5nZVR5cGUodHlwZSwgY29udGFpbmVyLCBjb2RlYykge1xuICAgIGNvbnN0IG1pbWVUeXBlID0gYCR7Y29udGFpbmVyfTtjb2RlY3M9JHtjb2RlY31gO1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHtcbiAgICAgIGxhYmVsOiBgY2hhbmdlLXR5cGU9JHttaW1lVHlwZX1gLFxuICAgICAgZXhlY3V0ZTogKCkgPT4ge1xuICAgICAgICBjb25zdCB0cmFjayA9IHRoaXMudHJhY2tzW3R5cGVdO1xuICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICBjb25zdCBzYiA9IHRyYWNrLmJ1ZmZlcjtcbiAgICAgICAgICBpZiAoc2IgIT0gbnVsbCAmJiBzYi5jaGFuZ2VUeXBlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZyhgY2hhbmdpbmcgJHt0eXBlfSBzb3VyY2VCdWZmZXIgdHlwZSB0byAke21pbWVUeXBlfWApO1xuICAgICAgICAgICAgc2IuY2hhbmdlVHlwZShtaW1lVHlwZSk7XG4gICAgICAgICAgICB0cmFjay5jb2RlYyA9IGNvZGVjO1xuICAgICAgICAgICAgdHJhY2suY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNoaWZ0QW5kRXhlY3V0ZU5leHQodHlwZSk7XG4gICAgICB9LFxuICAgICAgb25TdGFydDogKCkgPT4ge30sXG4gICAgICBvbkNvbXBsZXRlOiAoKSA9PiB7fSxcbiAgICAgIG9uRXJyb3I6IGVycm9yID0+IHtcbiAgICAgICAgdGhpcy53YXJuKGBGYWlsZWQgdG8gY2hhbmdlICR7dHlwZX0gU291cmNlQnVmZmVyIHR5cGVgLCBlcnJvcik7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmFwcGVuZChvcGVyYXRpb24sIHR5cGUsIHRoaXMuaXNQZW5kaW5nKHRoaXMudHJhY2tzW3R5cGVdKSk7XG4gIH1cbiAgYmxvY2tBdWRpbyhwYXJ0T3JGcmFnKSB7XG4gICAgdmFyIF90aGlzJGZyYWdtZW50VHJhY2tlcjtcbiAgICBjb25zdCBwU3RhcnQgPSBwYXJ0T3JGcmFnLnN0YXJ0O1xuICAgIGNvbnN0IHBUaW1lID0gcFN0YXJ0ICsgcGFydE9yRnJhZy5kdXJhdGlvbiAqIDAuMDU7XG4gICAgY29uc3QgYXRHYXAgPSAoKF90aGlzJGZyYWdtZW50VHJhY2tlciA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldEFwcGVuZGVkRnJhZyhwU3RhcnQsIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkZnJhZ21lbnRUcmFja2VyLmdhcCkgPT09IHRydWU7XG4gICAgaWYgKGF0R2FwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9wID0ge1xuICAgICAgbGFiZWw6ICdibG9jay1hdWRpbycsXG4gICAgICBleGVjdXRlOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGhpcyRmcmFnbWVudFRyYWNrZXIyO1xuICAgICAgICBjb25zdCB2aWRlb1RyYWNrID0gdGhpcy50cmFja3MudmlkZW87XG4gICAgICAgIGlmICh0aGlzLmxhc3RWaWRlb0FwcGVuZEVuZCA+IHBUaW1lIHx8IHZpZGVvVHJhY2sgIT0gbnVsbCAmJiB2aWRlb1RyYWNrLmJ1ZmZlciAmJiBCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZCh2aWRlb1RyYWNrLmJ1ZmZlciwgcFRpbWUpIHx8ICgoX3RoaXMkZnJhZ21lbnRUcmFja2VyMiA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldEFwcGVuZGVkRnJhZyhwVGltZSwgUGxheWxpc3RMZXZlbFR5cGUuTUFJTikpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRmcmFnbWVudFRyYWNrZXIyLmdhcCkgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmJsb2NrZWRBdWRpb0FwcGVuZCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5zaGlmdEFuZEV4ZWN1dGVOZXh0KCdhdWRpbycpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25TdGFydDogKCkgPT4ge30sXG4gICAgICBvbkNvbXBsZXRlOiAoKSA9PiB7fSxcbiAgICAgIG9uRXJyb3I6IGVycm9yID0+IHtcbiAgICAgICAgdGhpcy53YXJuKCdFcnJvciBleGVjdXRpbmcgYmxvY2stYXVkaW8gb3BlcmF0aW9uJywgZXJyb3IpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5ibG9ja2VkQXVkaW9BcHBlbmQgPSB7XG4gICAgICBvcCxcbiAgICAgIGZyYWc6IHBhcnRPckZyYWdcbiAgICB9O1xuICAgIHRoaXMuYXBwZW5kKG9wLCAnYXVkaW8nLCB0cnVlKTtcbiAgfVxuICB1bmJsb2NrQXVkaW8oKSB7XG4gICAgY29uc3Qge1xuICAgICAgYmxvY2tlZEF1ZGlvQXBwZW5kLFxuICAgICAgb3BlcmF0aW9uUXVldWVcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoYmxvY2tlZEF1ZGlvQXBwZW5kICYmIG9wZXJhdGlvblF1ZXVlKSB7XG4gICAgICB0aGlzLmJsb2NrZWRBdWRpb0FwcGVuZCA9IG51bGw7XG4gICAgICBvcGVyYXRpb25RdWV1ZS51bmJsb2NrQXVkaW8oYmxvY2tlZEF1ZGlvQXBwZW5kLm9wKTtcbiAgICB9XG4gIH1cbiAgb25CdWZmZXJBcHBlbmRpbmcoZXZlbnQsIGV2ZW50RGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHRyYWNrc1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICB0eXBlLFxuICAgICAgcGFyZW50LFxuICAgICAgZnJhZyxcbiAgICAgIHBhcnQsXG4gICAgICBjaHVua01ldGEsXG4gICAgICBvZmZzZXRcbiAgICB9ID0gZXZlbnREYXRhO1xuICAgIGNvbnN0IGNodW5rU3RhdHMgPSBjaHVua01ldGEuYnVmZmVyaW5nW3R5cGVdO1xuICAgIGNvbnN0IHtcbiAgICAgIHNuLFxuICAgICAgY2NcbiAgICB9ID0gZnJhZztcbiAgICBjb25zdCBidWZmZXJBcHBlbmRpbmdTdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY2h1bmtTdGF0cy5zdGFydCA9IGJ1ZmZlckFwcGVuZGluZ1N0YXJ0O1xuICAgIGNvbnN0IGZyYWdCdWZmZXJpbmcgPSBmcmFnLnN0YXRzLmJ1ZmZlcmluZztcbiAgICBjb25zdCBwYXJ0QnVmZmVyaW5nID0gcGFydCA/IHBhcnQuc3RhdHMuYnVmZmVyaW5nIDogbnVsbDtcbiAgICBpZiAoZnJhZ0J1ZmZlcmluZy5zdGFydCA9PT0gMCkge1xuICAgICAgZnJhZ0J1ZmZlcmluZy5zdGFydCA9IGJ1ZmZlckFwcGVuZGluZ1N0YXJ0O1xuICAgIH1cbiAgICBpZiAocGFydEJ1ZmZlcmluZyAmJiBwYXJ0QnVmZmVyaW5nLnN0YXJ0ID09PSAwKSB7XG4gICAgICBwYXJ0QnVmZmVyaW5nLnN0YXJ0ID0gYnVmZmVyQXBwZW5kaW5nU3RhcnQ7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogT25seSB1cGRhdGUgdGltZXN0YW1wT2Zmc2V0IHdoZW4gYXVkaW8vbXBlZyBmcmFnbWVudCBvciBwYXJ0IGlzIG5vdCBjb250aWd1b3VzIHdpdGggcHJldmlvdXNseSBhcHBlbmRlZFxuICAgIC8vIEFkanVzdGluZyBgU291cmNlQnVmZmVyLnRpbWVzdGFtcE9mZnNldGAgKGRlc2lyZWQgcG9pbnQgaW4gdGhlIHRpbWVsaW5lIHdoZXJlIHRoZSBuZXh0IGZyYW1lcyBzaG91bGQgYmUgYXBwZW5kZWQpXG4gICAgLy8gaW4gQ2hyb21lIGJyb3dzZXIgd2hlbiB3ZSBkZXRlY3QgTVBFRyBhdWRpbyBjb250YWluZXIgYW5kIHRpbWUgZGVsdGEgYmV0d2VlbiBsZXZlbCBQVFMgYW5kIGBTb3VyY2VCdWZmZXIudGltZXN0YW1wT2Zmc2V0YFxuICAgIC8vIGlzIGdyZWF0ZXIgdGhhbiAxMDBtcyAodGhpcyBpcyBlbm91Z2ggdG8gaGFuZGxlIHNlZWsgZm9yIFZPRCBvciBsZXZlbCBjaGFuZ2UgZm9yIExJVkUgdmlkZW9zKS5cbiAgICAvLyBNb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzMzMiNpc3N1ZWNvbW1lbnQtMjU3OTg2NDg2XG4gICAgY29uc3QgYXVkaW9UcmFjayA9IHRyYWNrcy5hdWRpbztcbiAgICBsZXQgY2hlY2tUaW1lc3RhbXBPZmZzZXQgPSBmYWxzZTtcbiAgICBpZiAodHlwZSA9PT0gJ2F1ZGlvJyAmJiAoYXVkaW9UcmFjayA9PSBudWxsID8gdm9pZCAwIDogYXVkaW9UcmFjay5jb250YWluZXIpID09PSAnYXVkaW8vbXBlZycpIHtcbiAgICAgIGNoZWNrVGltZXN0YW1wT2Zmc2V0ID0gIXRoaXMubGFzdE1wZWdBdWRpb0NodW5rIHx8IGNodW5rTWV0YS5pZCA9PT0gMSB8fCB0aGlzLmxhc3RNcGVnQXVkaW9DaHVuay5zbiAhPT0gY2h1bmtNZXRhLnNuO1xuICAgICAgdGhpcy5sYXN0TXBlZ0F1ZGlvQ2h1bmsgPSBjaHVua01ldGE7XG4gICAgfVxuXG4gICAgLy8gQmxvY2sgYXVkaW8gYXBwZW5kIHVudGlsIG92ZXJsYXBwaW5nIHZpZGVvIGFwcGVuZFxuICAgIGNvbnN0IHZpZGVvVHJhY2sgPSB0cmFja3MudmlkZW87XG4gICAgY29uc3QgdmlkZW9TYiA9IHZpZGVvVHJhY2sgPT0gbnVsbCA/IHZvaWQgMCA6IHZpZGVvVHJhY2suYnVmZmVyO1xuICAgIGlmICh2aWRlb1NiICYmIHNuICE9PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICBjb25zdCBwYXJ0T3JGcmFnID0gcGFydCB8fCBmcmFnO1xuICAgICAgY29uc3QgYmxvY2tlZEF1ZGlvQXBwZW5kID0gdGhpcy5ibG9ja2VkQXVkaW9BcHBlbmQ7XG4gICAgICBpZiAodHlwZSA9PT0gJ2F1ZGlvJyAmJiBwYXJlbnQgIT09ICdtYWluJyAmJiAhdGhpcy5ibG9ja2VkQXVkaW9BcHBlbmQpIHtcbiAgICAgICAgY29uc3QgcFN0YXJ0ID0gcGFydE9yRnJhZy5zdGFydDtcbiAgICAgICAgY29uc3QgcFRpbWUgPSBwU3RhcnQgKyBwYXJ0T3JGcmFnLmR1cmF0aW9uICogMC4wNTtcbiAgICAgICAgY29uc3QgdmJ1ZmZlcmVkID0gdmlkZW9TYi5idWZmZXJlZDtcbiAgICAgICAgY29uc3QgdmFwcGVuZGluZyA9IHRoaXMuY3VycmVudE9wKCd2aWRlbycpO1xuICAgICAgICBpZiAoIXZidWZmZXJlZC5sZW5ndGggJiYgIXZhcHBlbmRpbmcpIHtcbiAgICAgICAgICAvLyB3YWl0IGZvciB2aWRlbyBiZWZvcmUgYXBwZW5kaW5nIGF1ZGlvXG4gICAgICAgICAgdGhpcy5ibG9ja0F1ZGlvKHBhcnRPckZyYWcpO1xuICAgICAgICB9IGVsc2UgaWYgKCF2YXBwZW5kaW5nICYmICFCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZCh2aWRlb1NiLCBwVGltZSkgJiYgdGhpcy5sYXN0VmlkZW9BcHBlbmRFbmQgPCBwVGltZSkge1xuICAgICAgICAgIC8vIGF1ZGlvIGlzIGFoZWFkIG9mIHZpZGVvXG4gICAgICAgICAgdGhpcy5ibG9ja0F1ZGlvKHBhcnRPckZyYWcpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgY29uc3QgdmlkZW9BcHBlbmRFbmQgPSBwYXJ0T3JGcmFnLmVuZDtcbiAgICAgICAgaWYgKGJsb2NrZWRBdWRpb0FwcGVuZCkge1xuICAgICAgICAgIGNvbnN0IGF1ZGlvU3RhcnQgPSBibG9ja2VkQXVkaW9BcHBlbmQuZnJhZy5zdGFydDtcbiAgICAgICAgICBpZiAodmlkZW9BcHBlbmRFbmQgPiBhdWRpb1N0YXJ0IHx8IHZpZGVvQXBwZW5kRW5kIDwgdGhpcy5sYXN0VmlkZW9BcHBlbmRFbmQgfHwgQnVmZmVySGVscGVyLmlzQnVmZmVyZWQodmlkZW9TYiwgYXVkaW9TdGFydCkpIHtcbiAgICAgICAgICAgIHRoaXMudW5ibG9ja0F1ZGlvKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdFZpZGVvQXBwZW5kRW5kID0gdmlkZW9BcHBlbmRFbmQ7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZyYWdTdGFydCA9IChwYXJ0IHx8IGZyYWcpLnN0YXJ0O1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHtcbiAgICAgIGxhYmVsOiBgYXBwZW5kLSR7dHlwZX1gLFxuICAgICAgZXhlY3V0ZTogKCkgPT4ge1xuICAgICAgICB2YXIgX3RoaXMkdHJhY2tzJHR5cGUyO1xuICAgICAgICBjaHVua1N0YXRzLmV4ZWN1dGVTdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGNvbnN0IHNiID0gKF90aGlzJHRyYWNrcyR0eXBlMiA9IHRoaXMudHJhY2tzW3R5cGVdKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkdHJhY2tzJHR5cGUyLmJ1ZmZlcjtcbiAgICAgICAgaWYgKHNiKSB7XG4gICAgICAgICAgaWYgKGNoZWNrVGltZXN0YW1wT2Zmc2V0KSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRpbWVzdGFtcE9mZnNldChzYiwgZnJhZ1N0YXJ0LCAwLjEsIHR5cGUsIHNuLCBjYyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBpc0Zpbml0ZU51bWJlcihvZmZzZXQpKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRpbWVzdGFtcE9mZnNldChzYiwgb2Zmc2V0LCAwLjAwMDAwMSwgdHlwZSwgc24sIGNjKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcHBlbmRFeGVjdXRvcihkYXRhLCB0eXBlKTtcbiAgICAgIH0sXG4gICAgICBvblN0YXJ0OiAoKSA9PiB7XG4gICAgICAgIC8vIGxvZ2dlci5kZWJ1ZyhgW2J1ZmZlci1jb250cm9sbGVyXTogJHt0eXBlfSBTb3VyY2VCdWZmZXIgdXBkYXRlc3RhcnRgKTtcbiAgICAgIH0sXG4gICAgICBvbkNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgIC8vIGxvZ2dlci5kZWJ1ZyhgW2J1ZmZlci1jb250cm9sbGVyXTogJHt0eXBlfSBTb3VyY2VCdWZmZXIgdXBkYXRlZW5kYCk7XG4gICAgICAgIGNvbnN0IGVuZCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGNodW5rU3RhdHMuZXhlY3V0ZUVuZCA9IGNodW5rU3RhdHMuZW5kID0gZW5kO1xuICAgICAgICBpZiAoZnJhZ0J1ZmZlcmluZy5maXJzdCA9PT0gMCkge1xuICAgICAgICAgIGZyYWdCdWZmZXJpbmcuZmlyc3QgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRCdWZmZXJpbmcgJiYgcGFydEJ1ZmZlcmluZy5maXJzdCA9PT0gMCkge1xuICAgICAgICAgIHBhcnRCdWZmZXJpbmcuZmlyc3QgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZVJhbmdlcyA9IHt9O1xuICAgICAgICB0aGlzLnNvdXJjZUJ1ZmZlcnMuZm9yRWFjaCgoW3R5cGUsIHNiXSkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICB0aW1lUmFuZ2VzW3R5cGVdID0gQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKHNiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFwcGVuZEVycm9yc1t0eXBlXSA9IDA7XG4gICAgICAgIGlmICh0eXBlID09PSAnYXVkaW8nIHx8IHR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICB0aGlzLmFwcGVuZEVycm9ycy5hdWRpb3ZpZGVvID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFwcGVuZEVycm9ycy5hdWRpbyA9IDA7XG4gICAgICAgICAgdGhpcy5hcHBlbmRFcnJvcnMudmlkZW8gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9BUFBFTkRFRCwge1xuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgZnJhZyxcbiAgICAgICAgICBwYXJ0LFxuICAgICAgICAgIGNodW5rTWV0YSxcbiAgICAgICAgICBwYXJlbnQ6IGZyYWcudHlwZSxcbiAgICAgICAgICB0aW1lUmFuZ2VzXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIG9uRXJyb3I6IGVycm9yID0+IHtcbiAgICAgICAgdmFyIF90aGlzJG1lZGlhO1xuICAgICAgICAvLyBpbiBjYXNlIGFueSBlcnJvciBvY2N1cmVkIHdoaWxlIGFwcGVuZGluZywgcHV0IGJhY2sgc2VnbWVudCBpbiBzZWdtZW50cyB0YWJsZVxuICAgICAgICBjb25zdCBldmVudCA9IHtcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgIHBhcmVudDogZnJhZy50eXBlLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5EX0VSUk9SLFxuICAgICAgICAgIHNvdXJjZUJ1ZmZlck5hbWU6IHR5cGUsXG4gICAgICAgICAgZnJhZyxcbiAgICAgICAgICBwYXJ0LFxuICAgICAgICAgIGNodW5rTWV0YSxcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICBlcnI6IGVycm9yLFxuICAgICAgICAgIGZhdGFsOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBtZWRpYUVycm9yID0gKF90aGlzJG1lZGlhID0gdGhpcy5tZWRpYSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG1lZGlhLmVycm9yO1xuICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gRE9NRXhjZXB0aW9uLlFVT1RBX0VYQ0VFREVEX0VSUiB8fCBlcnJvci5uYW1lID09ICdRdW90YUV4Y2VlZGVkRXJyb3InIHx8IGBxdW90YWAgaW4gZXJyb3IpIHtcbiAgICAgICAgICAvLyBRdW90YUV4Y2VlZGVkRXJyb3I6IGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZnJhc3RydWN0dXJlLmh0bWwjcXVvdGFleGNlZWRlZGVycm9yXG4gICAgICAgICAgLy8gbGV0J3Mgc3RvcCBhcHBlbmRpbmcgYW55IHNlZ21lbnRzLCBhbmQgcmVwb3J0IEJVRkZFUl9GVUxMX0VSUk9SIGVycm9yXG4gICAgICAgICAgZXZlbnQuZGV0YWlscyA9IEVycm9yRGV0YWlscy5CVUZGRVJfRlVMTF9FUlJPUjtcbiAgICAgICAgfSBlbHNlIGlmIChlcnJvci5jb2RlID09PSBET01FeGNlcHRpb24uSU5WQUxJRF9TVEFURV9FUlIgJiYgdGhpcy5tZWRpYVNvdXJjZU9wZW5PckVuZGVkICYmICFtZWRpYUVycm9yKSB7XG4gICAgICAgICAgLy8gQWxsb3cgcmV0cnkgZm9yIFwiRmFpbGVkIHRvIGV4ZWN1dGUgJ2FwcGVuZEJ1ZmZlcicgb24gJ1NvdXJjZUJ1ZmZlcic6IFRoaXMgU291cmNlQnVmZmVyIGlzIHN0aWxsIHByb2Nlc3NpbmdcIiBlcnJvcnNcbiAgICAgICAgICBldmVudC5lcnJvckFjdGlvbiA9IGNyZWF0ZURvTm90aGluZ0Vycm9yQWN0aW9uKHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGVycm9yLm5hbWUgPT09IFRSQUNLX1JFTU9WRURfRVJST1JfTkFNRSAmJiB0aGlzLnNvdXJjZUJ1ZmZlckNvdW50ID09PSAwKSB7XG4gICAgICAgICAgLy8gRG8gbm90aGluZyBpZiBzb3VyY2VCdWZmZXJzIHdlcmUgcmVtb3ZlZCAobWVkaWEgaXMgZGV0YWNoZWQgYW5kIGFwcGVuZCB3YXMgbm90IGFib3J0ZWQpXG4gICAgICAgICAgZXZlbnQuZXJyb3JBY3Rpb24gPSBjcmVhdGVEb05vdGhpbmdFcnJvckFjdGlvbih0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBhcHBlbmRFcnJvckNvdW50ID0gKyt0aGlzLmFwcGVuZEVycm9yc1t0eXBlXTtcbiAgICAgICAgICAvKiB3aXRoIFVIRCBjb250ZW50LCB3ZSBjb3VsZCBnZXQgbG9vcCBvZiBxdW90YSBleGNlZWRlZCBlcnJvciB1bnRpbFxuICAgICAgICAgICAgYnJvd3NlciBpcyBhYmxlIHRvIGV2aWN0IHNvbWUgZGF0YSBmcm9tIHNvdXJjZWJ1ZmZlci4gUmV0cnlpbmcgY2FuIGhlbHAgcmVjb3Zlci5cbiAgICAgICAgICAqL1xuICAgICAgICAgIHRoaXMud2FybihgRmFpbGVkICR7YXBwZW5kRXJyb3JDb3VudH0vJHt0aGlzLmhscy5jb25maWcuYXBwZW5kRXJyb3JNYXhSZXRyeX0gdGltZXMgdG8gYXBwZW5kIHNlZ21lbnQgaW4gXCIke3R5cGV9XCIgc291cmNlQnVmZmVyICgke21lZGlhRXJyb3IgPyBtZWRpYUVycm9yIDogJ25vIG1lZGlhIGVycm9yJ30pYCk7XG4gICAgICAgICAgaWYgKGFwcGVuZEVycm9yQ291bnQgPj0gdGhpcy5obHMuY29uZmlnLmFwcGVuZEVycm9yTWF4UmV0cnkgfHwgISFtZWRpYUVycm9yKSB7XG4gICAgICAgICAgICBldmVudC5mYXRhbCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCBldmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmFwcGVuZChvcGVyYXRpb24sIHR5cGUsIHRoaXMuaXNQZW5kaW5nKHRoaXMudHJhY2tzW3R5cGVdKSk7XG4gIH1cbiAgZ2V0Rmx1c2hPcCh0eXBlLCBzdGFydCwgZW5kKSB7XG4gICAgdGhpcy5sb2coYHF1ZXVpbmcgXCIke3R5cGV9XCIgcmVtb3ZlICR7c3RhcnR9LSR7ZW5kfWApO1xuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogJ3JlbW92ZScsXG4gICAgICBleGVjdXRlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXhlY3V0b3IodHlwZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9LFxuICAgICAgb25TdGFydDogKCkgPT4ge1xuICAgICAgICAvLyBsb2dnZXIuZGVidWcoYFtidWZmZXItY29udHJvbGxlcl06IFN0YXJ0ZWQgZmx1c2hpbmcgJHtkYXRhLnN0YXJ0T2Zmc2V0fSAtPiAke2RhdGEuZW5kT2Zmc2V0fSBmb3IgJHt0eXBlfSBTb3VyY2UgQnVmZmVyYCk7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAvLyBsb2dnZXIuZGVidWcoYFtidWZmZXItY29udHJvbGxlcl06IEZpbmlzaGVkIGZsdXNoaW5nICR7ZGF0YS5zdGFydE9mZnNldH0gLT4gJHtkYXRhLmVuZE9mZnNldH0gZm9yICR7dHlwZX0gU291cmNlIEJ1ZmZlcmApO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfRkxVU0hFRCwge1xuICAgICAgICAgIHR5cGVcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgb25FcnJvcjogZXJyb3IgPT4ge1xuICAgICAgICB0aGlzLndhcm4oYEZhaWxlZCB0byByZW1vdmUgJHtzdGFydH0tJHtlbmR9IGZyb20gXCIke3R5cGV9XCIgU291cmNlQnVmZmVyYCwgZXJyb3IpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgb25CdWZmZXJGbHVzaGluZyhldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGUsXG4gICAgICBzdGFydE9mZnNldCxcbiAgICAgIGVuZE9mZnNldFxuICAgIH0gPSBkYXRhO1xuICAgIGlmICh0eXBlKSB7XG4gICAgICB0aGlzLmFwcGVuZCh0aGlzLmdldEZsdXNoT3AodHlwZSwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCksIHR5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNvdXJjZUJ1ZmZlcnMuZm9yRWFjaCgoW3R5cGVdKSA9PiB7XG4gICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgdGhpcy5hcHBlbmQodGhpcy5nZXRGbHVzaE9wKHR5cGUsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIG9uRnJhZ1BhcnNlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWcsXG4gICAgICBwYXJ0XG4gICAgfSA9IGRhdGE7XG4gICAgY29uc3QgYnVmZmVyc0FwcGVuZGVkVG8gPSBbXTtcbiAgICBjb25zdCBlbGVtZW50YXJ5U3RyZWFtcyA9IHBhcnQgPyBwYXJ0LmVsZW1lbnRhcnlTdHJlYW1zIDogZnJhZy5lbGVtZW50YXJ5U3RyZWFtcztcbiAgICBpZiAoZWxlbWVudGFyeVN0cmVhbXNbRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPVklERU9dKSB7XG4gICAgICBidWZmZXJzQXBwZW5kZWRUby5wdXNoKCdhdWRpb3ZpZGVvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChlbGVtZW50YXJ5U3RyZWFtc1tFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU9dKSB7XG4gICAgICAgIGJ1ZmZlcnNBcHBlbmRlZFRvLnB1c2goJ2F1ZGlvJyk7XG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudGFyeVN0cmVhbXNbRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPXSkge1xuICAgICAgICBidWZmZXJzQXBwZW5kZWRUby5wdXNoKCd2aWRlbycpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBvblVuYmxvY2tlZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBmcmFnLnN0YXRzLmJ1ZmZlcmluZy5lbmQgPSBub3c7XG4gICAgICBpZiAocGFydCkge1xuICAgICAgICBwYXJ0LnN0YXRzLmJ1ZmZlcmluZy5lbmQgPSBub3c7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0cyA9IHBhcnQgPyBwYXJ0LnN0YXRzIDogZnJhZy5zdGF0cztcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHtcbiAgICAgICAgZnJhZyxcbiAgICAgICAgcGFydCxcbiAgICAgICAgc3RhdHMsXG4gICAgICAgIGlkOiBmcmFnLnR5cGVcbiAgICAgIH0pO1xuICAgIH07XG4gICAgaWYgKGJ1ZmZlcnNBcHBlbmRlZFRvLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy53YXJuKGBGcmFnbWVudHMgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBFbGVtZW50YXJ5U3RyZWFtVHlwZSBzZXQuIHR5cGU6ICR7ZnJhZy50eXBlfSBsZXZlbDogJHtmcmFnLmxldmVsfSBzbjogJHtmcmFnLnNufWApO1xuICAgIH1cbiAgICB0aGlzLmJsb2NrQnVmZmVycyhvblVuYmxvY2tlZCwgYnVmZmVyc0FwcGVuZGVkVG8pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgIHRoaXMud2FybihgRnJhZ21lbnQgYnVmZmVyZWQgY2FsbGJhY2sgJHtlcnJvcn1gKTtcbiAgICAgIHRoaXMuc3RlcE9wZXJhdGlvblF1ZXVlKHRoaXMuc291cmNlQnVmZmVyVHlwZXMpO1xuICAgIH0pO1xuICB9XG4gIG9uRnJhZ0NoYW5nZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLnRyaW1CdWZmZXJzKCk7XG4gIH1cbiAgZ2V0IGJ1ZmZlcmVkVG9FbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlQnVmZmVyQ291bnQgPiAwICYmICF0aGlzLnNvdXJjZUJ1ZmZlcnMuc29tZSgoW3R5cGVdKSA9PiB7XG4gICAgICB2YXIgX3RoaXMkdHJhY2tzJHR5cGUzLCBfdGhpcyR0cmFja3MkdHlwZTQ7XG4gICAgICByZXR1cm4gdHlwZSAmJiAoISgoX3RoaXMkdHJhY2tzJHR5cGUzID0gdGhpcy50cmFja3NbdHlwZV0pICE9IG51bGwgJiYgX3RoaXMkdHJhY2tzJHR5cGUzLmVuZGVkKSB8fCAoKF90aGlzJHRyYWNrcyR0eXBlNCA9IHRoaXMudHJhY2tzW3R5cGVdKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkdHJhY2tzJHR5cGU0LmVuZGluZykpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gb24gQlVGRkVSX0VPUyBtYXJrIG1hdGNoaW5nIHNvdXJjZWJ1ZmZlcihzKSBhcyBcImVuZGluZ1wiIGFuZCBcImVuZGVkXCIgYW5kIHF1ZXVlIGVuZE9mU3RyZWFtIGFmdGVyIHJlbWFpbmluZyBvcGVyYXRpb25zKHMpXG4gIC8vIGFuIHVuZGVmaW5lZCBkYXRhLnR5cGUgd2lsbCBtYXJrIGFsbCBidWZmZXJzIGFzIEVPUy5cbiAgb25CdWZmZXJFb3MoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgX3RoaXMkb3ZlcnJpZGVzO1xuICAgIHRoaXMuc291cmNlQnVmZmVycy5mb3JFYWNoKChbdHlwZV0pID0+IHtcbiAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgIGNvbnN0IHRyYWNrID0gdGhpcy50cmFja3NbdHlwZV07XG4gICAgICAgIGlmICghZGF0YS50eXBlIHx8IGRhdGEudHlwZSA9PT0gdHlwZSkge1xuICAgICAgICAgIHRyYWNrLmVuZGluZyA9IHRydWU7XG4gICAgICAgICAgaWYgKCF0cmFjay5lbmRlZCkge1xuICAgICAgICAgICAgdHJhY2suZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5sb2coYCR7dHlwZX0gYnVmZmVyIHJlYWNoZWQgRU9TYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgYWxsb3dFbmRPZlN0cmVhbSA9ICgoX3RoaXMkb3ZlcnJpZGVzID0gdGhpcy5vdmVycmlkZXMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRvdmVycmlkZXMuZW5kT2ZTdHJlYW0pICE9PSBmYWxzZTtcbiAgICBjb25zdCBhbGxUcmFja3NFbmRpbmcgPSB0aGlzLnNvdXJjZUJ1ZmZlckNvdW50ID4gMCAmJiAhdGhpcy5zb3VyY2VCdWZmZXJzLnNvbWUoKFt0eXBlXSkgPT4ge1xuICAgICAgdmFyIF90aGlzJHRyYWNrcyR0eXBlNTtcbiAgICAgIHJldHVybiB0eXBlICYmICEoKF90aGlzJHRyYWNrcyR0eXBlNSA9IHRoaXMudHJhY2tzW3R5cGVdKSAhPSBudWxsICYmIF90aGlzJHRyYWNrcyR0eXBlNS5lbmRlZCk7XG4gICAgfSk7XG4gICAgaWYgKGFsbFRyYWNrc0VuZGluZykge1xuICAgICAgaWYgKGFsbG93RW5kT2ZTdHJlYW0pIHtcbiAgICAgICAgdGhpcy5sb2coYFF1ZXVlaW5nIEVPU2ApO1xuICAgICAgICB0aGlzLmJsb2NrVW50aWxPcGVuKCgpID0+IHtcbiAgICAgICAgICB0aGlzLnRyYWNrc0VuZGVkKCk7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgbWVkaWFTb3VyY2VcbiAgICAgICAgICB9ID0gdGhpcztcbiAgICAgICAgICBpZiAoIW1lZGlhU291cmNlIHx8IG1lZGlhU291cmNlLnJlYWR5U3RhdGUgIT09ICdvcGVuJykge1xuICAgICAgICAgICAgaWYgKG1lZGlhU291cmNlKSB7XG4gICAgICAgICAgICAgIHRoaXMubG9nKGBDb3VsZCBub3QgY2FsbCBtZWRpYVNvdXJjZS5lbmRPZlN0cmVhbSgpLiBtZWRpYVNvdXJjZS5yZWFkeVN0YXRlOiAke21lZGlhU291cmNlLnJlYWR5U3RhdGV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubG9nKGBDYWxsaW5nIG1lZGlhU291cmNlLmVuZE9mU3RyZWFtKClgKTtcbiAgICAgICAgICAvLyBBbGxvdyB0aGlzIHRvIHRocm93IGFuZCBiZSBjYXVnaHQgYnkgdGhlIGVucXVldWVpbmcgZnVuY3Rpb25cbiAgICAgICAgICBtZWRpYVNvdXJjZS5lbmRPZlN0cmVhbSgpO1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUkVEX1RPX0VORCwgdW5kZWZpbmVkKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRyYWNrc0VuZGVkKCk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUkVEX1RPX0VORCwgdW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdHJhY2tzRW5kZWQoKSB7XG4gICAgdGhpcy5zb3VyY2VCdWZmZXJzLmZvckVhY2goKFt0eXBlXSkgPT4ge1xuICAgICAgaWYgKHR5cGUgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgdHJhY2sgPSB0aGlzLnRyYWNrc1t0eXBlXTtcbiAgICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgICAgdHJhY2suZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBvbkxldmVsVXBkYXRlZChldmVudCwge1xuICAgIGRldGFpbHNcbiAgfSkge1xuICAgIGlmICghZGV0YWlscy5mcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gICAgdGhpcy51cGRhdGVEdXJhdGlvbigpO1xuICB9XG4gIHVwZGF0ZUR1cmF0aW9uKCkge1xuICAgIHRoaXMuYmxvY2tVbnRpbE9wZW4oKCkgPT4ge1xuICAgICAgY29uc3QgZHVyYXRpb25BbmRSYW5nZSA9IHRoaXMuZ2V0RHVyYXRpb25BbmRSYW5nZSgpO1xuICAgICAgaWYgKCFkdXJhdGlvbkFuZFJhbmdlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlTWVkaWFTb3VyY2UoZHVyYXRpb25BbmRSYW5nZSk7XG4gICAgfSk7XG4gIH1cbiAgb25FcnJvcihldmVudCwgZGF0YSkge1xuICAgIGlmIChkYXRhLmRldGFpbHMgPT09IEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5EX0VSUk9SICYmIGRhdGEuZnJhZykge1xuICAgICAgdmFyIF9kYXRhJGVycm9yQWN0aW9uO1xuICAgICAgY29uc3QgbmV4dEF1dG9MZXZlbCA9IChfZGF0YSRlcnJvckFjdGlvbiA9IGRhdGEuZXJyb3JBY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YSRlcnJvckFjdGlvbi5uZXh0QXV0b0xldmVsO1xuICAgICAgaWYgKGlzRmluaXRlTnVtYmVyKG5leHRBdXRvTGV2ZWwpICYmIG5leHRBdXRvTGV2ZWwgIT09IGRhdGEuZnJhZy5sZXZlbCkge1xuICAgICAgICB0aGlzLnJlc2V0QXBwZW5kRXJyb3JzKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlc2V0QXBwZW5kRXJyb3JzKCkge1xuICAgIHRoaXMuYXBwZW5kRXJyb3JzID0ge1xuICAgICAgYXVkaW86IDAsXG4gICAgICB2aWRlbzogMCxcbiAgICAgIGF1ZGlvdmlkZW86IDBcbiAgICB9O1xuICB9XG4gIHRyaW1CdWZmZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhscyxcbiAgICAgIGRldGFpbHMsXG4gICAgICBtZWRpYVxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghbWVkaWEgfHwgZGV0YWlscyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuc291cmNlQnVmZmVyQ291bnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIGNvbnN0IHRhcmdldER1cmF0aW9uID0gZGV0YWlscy5sZXZlbFRhcmdldER1cmF0aW9uO1xuXG4gICAgLy8gU3VwcG9ydCBmb3IgZGVwcmVjYXRlZCBsaXZlQmFja0J1ZmZlckxlbmd0aFxuICAgIGNvbnN0IGJhY2tCdWZmZXJMZW5ndGggPSBkZXRhaWxzLmxpdmUgJiYgY29uZmlnLmxpdmVCYWNrQnVmZmVyTGVuZ3RoICE9PSBudWxsID8gY29uZmlnLmxpdmVCYWNrQnVmZmVyTGVuZ3RoIDogY29uZmlnLmJhY2tCdWZmZXJMZW5ndGg7XG4gICAgaWYgKGlzRmluaXRlTnVtYmVyKGJhY2tCdWZmZXJMZW5ndGgpICYmIGJhY2tCdWZmZXJMZW5ndGggPj0gMCkge1xuICAgICAgY29uc3QgbWF4QmFja0J1ZmZlckxlbmd0aCA9IE1hdGgubWF4KGJhY2tCdWZmZXJMZW5ndGgsIHRhcmdldER1cmF0aW9uKTtcbiAgICAgIGNvbnN0IHRhcmdldEJhY2tCdWZmZXJQb3NpdGlvbiA9IE1hdGguZmxvb3IoY3VycmVudFRpbWUgLyB0YXJnZXREdXJhdGlvbikgKiB0YXJnZXREdXJhdGlvbiAtIG1heEJhY2tCdWZmZXJMZW5ndGg7XG4gICAgICB0aGlzLmZsdXNoQmFja0J1ZmZlcihjdXJyZW50VGltZSwgdGFyZ2V0RHVyYXRpb24sIHRhcmdldEJhY2tCdWZmZXJQb3NpdGlvbik7XG4gICAgfVxuICAgIGlmIChpc0Zpbml0ZU51bWJlcihjb25maWcuZnJvbnRCdWZmZXJGbHVzaFRocmVzaG9sZCkgJiYgY29uZmlnLmZyb250QnVmZmVyRmx1c2hUaHJlc2hvbGQgPiAwKSB7XG4gICAgICBjb25zdCBmcm9udEJ1ZmZlckxlbmd0aCA9IE1hdGgubWF4KGNvbmZpZy5tYXhCdWZmZXJMZW5ndGgsIGNvbmZpZy5mcm9udEJ1ZmZlckZsdXNoVGhyZXNob2xkKTtcbiAgICAgIGNvbnN0IG1heEZyb250QnVmZmVyTGVuZ3RoID0gTWF0aC5tYXgoZnJvbnRCdWZmZXJMZW5ndGgsIHRhcmdldER1cmF0aW9uKTtcbiAgICAgIGNvbnN0IHRhcmdldEZyb250QnVmZmVyUG9zaXRpb24gPSBNYXRoLmZsb29yKGN1cnJlbnRUaW1lIC8gdGFyZ2V0RHVyYXRpb24pICogdGFyZ2V0RHVyYXRpb24gKyBtYXhGcm9udEJ1ZmZlckxlbmd0aDtcbiAgICAgIHRoaXMuZmx1c2hGcm9udEJ1ZmZlcihjdXJyZW50VGltZSwgdGFyZ2V0RHVyYXRpb24sIHRhcmdldEZyb250QnVmZmVyUG9zaXRpb24pO1xuICAgIH1cbiAgfVxuICBmbHVzaEJhY2tCdWZmZXIoY3VycmVudFRpbWUsIHRhcmdldER1cmF0aW9uLCB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb24pIHtcbiAgICB0aGlzLnNvdXJjZUJ1ZmZlcnMuZm9yRWFjaCgoW3R5cGUsIHNiXSkgPT4ge1xuICAgICAgaWYgKHNiKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlcmVkID0gQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKHNiKTtcbiAgICAgICAgLy8gd2hlbiB0YXJnZXQgYnVmZmVyIHN0YXJ0IGV4Y2VlZHMgYWN0dWFsIGJ1ZmZlciBzdGFydFxuICAgICAgICBpZiAoYnVmZmVyZWQubGVuZ3RoID4gMCAmJiB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb24gPiBidWZmZXJlZC5zdGFydCgwKSkge1xuICAgICAgICAgIHZhciBfdGhpcyRkZXRhaWxzO1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJBQ0tfQlVGRkVSX1JFQUNIRUQsIHtcbiAgICAgICAgICAgIGJ1ZmZlckVuZDogdGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBTdXBwb3J0IGZvciBkZXByZWNhdGVkIGV2ZW50OlxuICAgICAgICAgIGNvbnN0IHRyYWNrID0gdGhpcy50cmFja3NbdHlwZV07XG4gICAgICAgICAgaWYgKChfdGhpcyRkZXRhaWxzID0gdGhpcy5kZXRhaWxzKSAhPSBudWxsICYmIF90aGlzJGRldGFpbHMubGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTElWRV9CQUNLX0JVRkZFUl9SRUFDSEVELCB7XG4gICAgICAgICAgICAgIGJ1ZmZlckVuZDogdGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRyYWNrICE9IG51bGwgJiYgdHJhY2suZW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKGBDYW5ub3QgZmx1c2ggJHt0eXBlfSBiYWNrIGJ1ZmZlciB3aGlsZSBTb3VyY2VCdWZmZXIgaXMgaW4gZW5kZWQgc3RhdGVgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0ZMVVNISU5HLCB7XG4gICAgICAgICAgICBzdGFydE9mZnNldDogMCxcbiAgICAgICAgICAgIGVuZE9mZnNldDogdGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uLFxuICAgICAgICAgICAgdHlwZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZmx1c2hGcm9udEJ1ZmZlcihjdXJyZW50VGltZSwgdGFyZ2V0RHVyYXRpb24sIHRhcmdldEZyb250QnVmZmVyUG9zaXRpb24pIHtcbiAgICB0aGlzLnNvdXJjZUJ1ZmZlcnMuZm9yRWFjaCgoW3R5cGUsIHNiXSkgPT4ge1xuICAgICAgaWYgKHNiKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlcmVkID0gQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKHNiKTtcbiAgICAgICAgY29uc3QgbnVtQnVmZmVyZWRSYW5nZXMgPSBidWZmZXJlZC5sZW5ndGg7XG4gICAgICAgIC8vIFRoZSBidWZmZXIgaXMgZWl0aGVyIGVtcHR5IG9yIGNvbnRpZ3VvdXNcbiAgICAgICAgaWYgKG51bUJ1ZmZlcmVkUmFuZ2VzIDwgMikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWZmZXJTdGFydCA9IGJ1ZmZlcmVkLnN0YXJ0KG51bUJ1ZmZlcmVkUmFuZ2VzIC0gMSk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlckVuZCA9IGJ1ZmZlcmVkLmVuZChudW1CdWZmZXJlZFJhbmdlcyAtIDEpO1xuICAgICAgICAvLyBObyBmbHVzaCBpZiB3ZSBjYW4gdG9sZXJhdGUgdGhlIGN1cnJlbnQgYnVmZmVyIGxlbmd0aCBvciB0aGUgY3VycmVudCBidWZmZXIgcmFuZ2Ugd2Ugd291bGQgZmx1c2ggaXMgY29udGlndW91cyB3aXRoIGN1cnJlbnQgcG9zaXRpb25cbiAgICAgICAgaWYgKHRhcmdldEZyb250QnVmZmVyUG9zaXRpb24gPiBidWZmZXJTdGFydCB8fCBjdXJyZW50VGltZSA+PSBidWZmZXJTdGFydCAmJiBjdXJyZW50VGltZSA8PSBidWZmZXJFbmQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0ZMVVNISU5HLCB7XG4gICAgICAgICAgc3RhcnRPZmZzZXQ6IGJ1ZmZlclN0YXJ0LFxuICAgICAgICAgIGVuZE9mZnNldDogSW5maW5pdHksXG4gICAgICAgICAgdHlwZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgTWVkaWEgU291cmNlIGR1cmF0aW9uIHRvIGN1cnJlbnQgbGV2ZWwgZHVyYXRpb24gb3Igb3ZlcnJpZGUgdG8gSW5maW5pdHkgaWYgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJcbiAgICogJ2xpdmVEdXJhdGlvbkluZmluaXR5YCBpcyBzZXQgdG8gYHRydWVgXG4gICAqIE1vcmUgZGV0YWlsczogaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzM1NVxuICAgKi9cbiAgZ2V0RHVyYXRpb25BbmRSYW5nZSgpIHtcbiAgICB2YXIgX3RoaXMkb3ZlcnJpZGVzMjtcbiAgICBjb25zdCB7XG4gICAgICBkZXRhaWxzLFxuICAgICAgbWVkaWFTb3VyY2VcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWRldGFpbHMgfHwgIXRoaXMubWVkaWEgfHwgKG1lZGlhU291cmNlID09IG51bGwgPyB2b2lkIDAgOiBtZWRpYVNvdXJjZS5yZWFkeVN0YXRlKSAhPT0gJ29wZW4nKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcGxheWxpc3RFbmQgPSBkZXRhaWxzLmVkZ2U7XG4gICAgaWYgKGRldGFpbHMubGl2ZSAmJiB0aGlzLmhscy5jb25maWcubGl2ZUR1cmF0aW9uSW5maW5pdHkpIHtcbiAgICAgIGNvbnN0IGxlbiA9IGRldGFpbHMuZnJhZ21lbnRzLmxlbmd0aDtcbiAgICAgIGlmIChsZW4gJiYgZGV0YWlscy5saXZlICYmICEhbWVkaWFTb3VyY2Uuc2V0TGl2ZVNlZWthYmxlUmFuZ2UpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heCgwLCBkZXRhaWxzLmZyYWdtZW50U3RhcnQpO1xuICAgICAgICBjb25zdCBlbmQgPSBNYXRoLm1heChzdGFydCwgcGxheWxpc3RFbmQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGR1cmF0aW9uOiBJbmZpbml0eSxcbiAgICAgICAgICBzdGFydCxcbiAgICAgICAgICBlbmRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGR1cmF0aW9uOiBJbmZpbml0eVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgb3ZlcnJpZGVEdXJhdGlvbiA9IChfdGhpcyRvdmVycmlkZXMyID0gdGhpcy5vdmVycmlkZXMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRvdmVycmlkZXMyLmR1cmF0aW9uO1xuICAgIGlmIChvdmVycmlkZUR1cmF0aW9uKSB7XG4gICAgICBpZiAoIWlzRmluaXRlTnVtYmVyKG92ZXJyaWRlRHVyYXRpb24pKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZHVyYXRpb246IG92ZXJyaWRlRHVyYXRpb25cbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IG1lZGlhRHVyYXRpb24gPSB0aGlzLm1lZGlhLmR1cmF0aW9uO1xuICAgIGNvbnN0IG1zRHVyYXRpb24gPSBpc0Zpbml0ZU51bWJlcihtZWRpYVNvdXJjZS5kdXJhdGlvbikgPyBtZWRpYVNvdXJjZS5kdXJhdGlvbiA6IDA7XG4gICAgaWYgKHBsYXlsaXN0RW5kID4gbXNEdXJhdGlvbiAmJiBwbGF5bGlzdEVuZCA+IG1lZGlhRHVyYXRpb24gfHwgIWlzRmluaXRlTnVtYmVyKG1lZGlhRHVyYXRpb24pKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkdXJhdGlvbjogcGxheWxpc3RFbmRcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHVwZGF0ZU1lZGlhU291cmNlKHtcbiAgICBkdXJhdGlvbixcbiAgICBzdGFydCxcbiAgICBlbmRcbiAgfSkge1xuICAgIGNvbnN0IG1lZGlhU291cmNlID0gdGhpcy5tZWRpYVNvdXJjZTtcbiAgICBpZiAoIXRoaXMubWVkaWEgfHwgIW1lZGlhU291cmNlIHx8IG1lZGlhU291cmNlLnJlYWR5U3RhdGUgIT09ICdvcGVuJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobWVkaWFTb3VyY2UuZHVyYXRpb24gIT09IGR1cmF0aW9uKSB7XG4gICAgICBpZiAoaXNGaW5pdGVOdW1iZXIoZHVyYXRpb24pKSB7XG4gICAgICAgIHRoaXMubG9nKGBVcGRhdGluZyBNZWRpYVNvdXJjZSBkdXJhdGlvbiB0byAke2R1cmF0aW9uLnRvRml4ZWQoMyl9YCk7XG4gICAgICB9XG4gICAgICBtZWRpYVNvdXJjZS5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIH1cbiAgICBpZiAoc3RhcnQgIT09IHVuZGVmaW5lZCAmJiBlbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5sb2coYE1lZGlhU291cmNlIGR1cmF0aW9uIGlzIHNldCB0byAke21lZGlhU291cmNlLmR1cmF0aW9ufS4gU2V0dGluZyBzZWVrYWJsZSByYW5nZSB0byAke3N0YXJ0fS0ke2VuZH0uYCk7XG4gICAgICBtZWRpYVNvdXJjZS5zZXRMaXZlU2Vla2FibGVSYW5nZShzdGFydCwgZW5kKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHRyYWNrc1JlYWR5KCkge1xuICAgIGNvbnN0IHBlbmRpbmdUcmFja0NvdW50ID0gdGhpcy5wZW5kaW5nVHJhY2tDb3VudDtcbiAgICByZXR1cm4gcGVuZGluZ1RyYWNrQ291bnQgPiAwICYmIChwZW5kaW5nVHJhY2tDb3VudCA+PSB0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzVG90YWwgfHwgdGhpcy5pc1BlbmRpbmcodGhpcy50cmFja3MuYXVkaW92aWRlbykpO1xuICB9XG4gIGNoZWNrUGVuZGluZ1RyYWNrcygpIHtcbiAgICBjb25zdCB7XG4gICAgICBidWZmZXJDb2RlY0V2ZW50c1RvdGFsLFxuICAgICAgcGVuZGluZ1RyYWNrQ291bnQsXG4gICAgICB0cmFja3NcbiAgICB9ID0gdGhpcztcbiAgICB0aGlzLmxvZyhgY2hlY2tQZW5kaW5nVHJhY2tzIChwZW5kaW5nOiAke3BlbmRpbmdUcmFja0NvdW50fSBjb2RlYyBldmVudHMgZXhwZWN0ZWQ6ICR7YnVmZmVyQ29kZWNFdmVudHNUb3RhbH0pICR7c3RyaW5naWZ5KHRyYWNrcyl9YCk7XG4gICAgLy8gQ2hlY2sgaWYgd2UndmUgcmVjZWl2ZWQgYWxsIG9mIHRoZSBleHBlY3RlZCBidWZmZXJDb2RlYyBldmVudHMuIFdoZW4gbm9uZSByZW1haW4sIGNyZWF0ZSBhbGwgdGhlIHNvdXJjZUJ1ZmZlcnMgYXQgb25jZS5cbiAgICAvLyBUaGlzIGlzIGltcG9ydGFudCBiZWNhdXNlIHRoZSBNU0Ugc3BlYyBhbGxvd3MgaW1wbGVtZW50YXRpb25zIHRvIHRocm93IFF1b3RhRXhjZWVkZWRFcnJvcnMgaWYgY3JlYXRpbmcgbmV3IHNvdXJjZUJ1ZmZlcnMgYWZ0ZXJcbiAgICAvLyBkYXRhIGhhcyBiZWVuIGFwcGVuZGVkIHRvIGV4aXN0aW5nIG9uZXMuXG4gICAgLy8gMiB0cmFja3MgaXMgdGhlIG1heCAob25lIGZvciBhdWRpbywgb25lIGZvciB2aWRlbykuIElmIHdlJ3ZlIHJlYWNoIHRoaXMgbWF4IGdvIGFoZWFkIGFuZCBjcmVhdGUgdGhlIGJ1ZmZlcnMuXG4gICAgaWYgKHRoaXMudHJhY2tzUmVhZHkpIHtcbiAgICAgIHZhciBfdGhpcyR0cmFuc2ZlckRhdGE0O1xuICAgICAgY29uc3QgdHJhbnNmZXJyZWRUcmFja3MgPSAoX3RoaXMkdHJhbnNmZXJEYXRhNCA9IHRoaXMudHJhbnNmZXJEYXRhKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkdHJhbnNmZXJEYXRhNC50cmFja3M7XG4gICAgICBpZiAodHJhbnNmZXJyZWRUcmFja3MgJiYgT2JqZWN0LmtleXModHJhbnNmZXJyZWRUcmFja3MpLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmF0dGFjaFRyYW5zZmVycmVkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvaywgbGV0J3MgY3JlYXRlIHRoZW0gbm93ICFcbiAgICAgICAgdGhpcy5jcmVhdGVTb3VyY2VCdWZmZXJzKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGJ1ZmZlckNyZWF0ZWQoKSB7XG4gICAgaWYgKHRoaXMuc291cmNlQnVmZmVyQ291bnQpIHtcbiAgICAgIGNvbnN0IHRyYWNrcyA9IHt9O1xuICAgICAgdGhpcy5zb3VyY2VCdWZmZXJzLmZvckVhY2goKFt0eXBlLCBidWZmZXJdKSA9PiB7XG4gICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgY29uc3QgdHJhY2sgPSB0aGlzLnRyYWNrc1t0eXBlXTtcbiAgICAgICAgICB0cmFja3NbdHlwZV0gPSB7XG4gICAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgICBjb250YWluZXI6IHRyYWNrLmNvbnRhaW5lcixcbiAgICAgICAgICAgIGNvZGVjOiB0cmFjay5jb2RlYyxcbiAgICAgICAgICAgIHN1cHBsZW1lbnRhbDogdHJhY2suc3VwcGxlbWVudGFsLFxuICAgICAgICAgICAgbGV2ZWxDb2RlYzogdHJhY2subGV2ZWxDb2RlYyxcbiAgICAgICAgICAgIGlkOiB0cmFjay5pZCxcbiAgICAgICAgICAgIG1ldGFkYXRhOiB0cmFjay5tZXRhZGF0YVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0NSRUFURUQsIHtcbiAgICAgICAgdHJhY2tzXG4gICAgICB9KTtcbiAgICAgIHRoaXMubG9nKGBTb3VyY2VCdWZmZXJzIGNyZWF0ZWQuIFJ1bm5pbmcgcXVldWU6ICR7dGhpcy5vcGVyYXRpb25RdWV1ZX1gKTtcbiAgICAgIHRoaXMuc291cmNlQnVmZmVycy5mb3JFYWNoKChbdHlwZV0pID0+IHtcbiAgICAgICAgdGhpcy5leGVjdXRlTmV4dCh0eXBlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignY291bGQgbm90IGNyZWF0ZSBzb3VyY2UgYnVmZmVyIGZvciBtZWRpYSBjb2RlYyhzKScpO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SLFxuICAgICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGNyZWF0ZVNvdXJjZUJ1ZmZlcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHJhY2tzLFxuICAgICAgc291cmNlQnVmZmVycyxcbiAgICAgIG1lZGlhU291cmNlXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFtZWRpYVNvdXJjZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcmVhdGVTb3VyY2VCdWZmZXJzIGNhbGxlZCB3aGVuIG1lZGlhU291cmNlIHdhcyBudWxsJyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgdHJhY2tOYW1lIGluIHRyYWNrcykge1xuICAgICAgY29uc3QgdHlwZSA9IHRyYWNrTmFtZTtcbiAgICAgIGNvbnN0IHRyYWNrID0gdHJhY2tzW3R5cGVdO1xuICAgICAgaWYgKHRoaXMuaXNQZW5kaW5nKHRyYWNrKSkge1xuICAgICAgICBjb25zdCBjb2RlYyA9IHRoaXMuZ2V0VHJhY2tDb2RlYyh0cmFjaywgdHlwZSk7XG4gICAgICAgIGNvbnN0IG1pbWVUeXBlID0gYCR7dHJhY2suY29udGFpbmVyfTtjb2RlY3M9JHtjb2RlY31gO1xuICAgICAgICB0cmFjay5jb2RlYyA9IGNvZGVjO1xuICAgICAgICB0aGlzLmxvZyhgY3JlYXRpbmcgc291cmNlQnVmZmVyKCR7bWltZVR5cGV9KSR7dGhpcy5jdXJyZW50T3AodHlwZSkgPyAnIFF1ZXVlZCcgOiAnJ30gJHtzdHJpbmdpZnkodHJhY2spfWApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHNiID0gbWVkaWFTb3VyY2UuYWRkU291cmNlQnVmZmVyKG1pbWVUeXBlKTtcbiAgICAgICAgICBjb25zdCBzYkluZGV4ID0gc291cmNlQnVmZmVyTmFtZVRvSW5kZXgodHlwZSk7XG4gICAgICAgICAgY29uc3Qgc2JUdXBsZSA9IFt0eXBlLCBzYl07XG4gICAgICAgICAgc291cmNlQnVmZmVyc1tzYkluZGV4XSA9IHNiVHVwbGU7XG4gICAgICAgICAgdHJhY2suYnVmZmVyID0gc2I7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdmFyIF90aGlzJG9wZXJhdGlvblF1ZXVlO1xuICAgICAgICAgIHRoaXMuZXJyb3IoYGVycm9yIHdoaWxlIHRyeWluZyB0byBhZGQgc291cmNlQnVmZmVyOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgLy8gcmVtb3ZlIGluaXQgc2VnbWVudCBmcm9tIHF1ZXVlIGFuZCBkZWxldGUgdHJhY2sgaW5mb1xuICAgICAgICAgIHRoaXMuc2hpZnRBbmRFeGVjdXRlTmV4dCh0eXBlKTtcbiAgICAgICAgICAoX3RoaXMkb3BlcmF0aW9uUXVldWUgPSB0aGlzLm9wZXJhdGlvblF1ZXVlKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkb3BlcmF0aW9uUXVldWUucmVtb3ZlQmxvY2tlcnMoKTtcbiAgICAgICAgICBkZWxldGUgdGhpcy50cmFja3NbdHlwZV07XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX0FERF9DT0RFQ19FUlJPUixcbiAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgc291cmNlQnVmZmVyTmFtZTogdHlwZSxcbiAgICAgICAgICAgIG1pbWVUeXBlOiBtaW1lVHlwZSxcbiAgICAgICAgICAgIHBhcmVudDogdHJhY2suaWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFja1NvdXJjZUJ1ZmZlcih0eXBlLCB0cmFjayk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYnVmZmVyQ3JlYXRlZCgpO1xuICB9XG4gIGdldFRyYWNrQ29kZWModHJhY2ssIHRyYWNrTmFtZSkge1xuICAgIC8vIFVzZSBzdXBwbGVtZW50YWwgdmlkZW8gY29kZWMgd2hlbiBzdXBwb3J0ZWQgd2hlbiBhZGRpbmcgU291cmNlQnVmZmVyICgjNTU1OClcbiAgICBjb25zdCBzdXBwbGVtZW50YWxDb2RlYyA9IHRyYWNrLnN1cHBsZW1lbnRhbDtcbiAgICBsZXQgdHJhY2tDb2RlYyA9IHRyYWNrLmNvZGVjO1xuICAgIGlmIChzdXBwbGVtZW50YWxDb2RlYyAmJiAodHJhY2tOYW1lID09PSAndmlkZW8nIHx8IHRyYWNrTmFtZSA9PT0gJ2F1ZGlvdmlkZW8nKSAmJiBhcmVDb2RlY3NNZWRpYVNvdXJjZVN1cHBvcnRlZChzdXBwbGVtZW50YWxDb2RlYywgJ3ZpZGVvJykpIHtcbiAgICAgIHRyYWNrQ29kZWMgPSByZXBsYWNlVmlkZW9Db2RlYyh0cmFja0NvZGVjLCBzdXBwbGVtZW50YWxDb2RlYyk7XG4gICAgfVxuICAgIGNvbnN0IGNvZGVjID0gcGlja01vc3RDb21wbGV0ZUNvZGVjTmFtZSh0cmFja0NvZGVjLCB0cmFjay5sZXZlbENvZGVjKTtcbiAgICBpZiAoY29kZWMpIHtcbiAgICAgIGlmICh0cmFja05hbWUuc2xpY2UoMCwgNSkgPT09ICdhdWRpbycpIHtcbiAgICAgICAgcmV0dXJuIGdldENvZGVjQ29tcGF0aWJsZU5hbWUoY29kZWMsIHRoaXMuYXBwZW5kU291cmNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2RlYztcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHRyYWNrU291cmNlQnVmZmVyKHR5cGUsIHRyYWNrKSB7XG4gICAgY29uc3QgYnVmZmVyID0gdHJhY2suYnVmZmVyO1xuICAgIGlmICghYnVmZmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvZGVjID0gdGhpcy5nZXRUcmFja0NvZGVjKHRyYWNrLCB0eXBlKTtcbiAgICB0aGlzLnRyYWNrc1t0eXBlXSA9IHtcbiAgICAgIGJ1ZmZlcixcbiAgICAgIGNvZGVjLFxuICAgICAgY29udGFpbmVyOiB0cmFjay5jb250YWluZXIsXG4gICAgICBsZXZlbENvZGVjOiB0cmFjay5sZXZlbENvZGVjLFxuICAgICAgc3VwcGxlbWVudGFsOiB0cmFjay5zdXBwbGVtZW50YWwsXG4gICAgICBtZXRhZGF0YTogdHJhY2subWV0YWRhdGEsXG4gICAgICBpZDogdHJhY2suaWQsXG4gICAgICBsaXN0ZW5lcnM6IFtdXG4gICAgfTtcbiAgICB0aGlzLnJlbW92ZUJ1ZmZlckxpc3RlbmVycyh0eXBlKTtcbiAgICB0aGlzLmFkZEJ1ZmZlckxpc3RlbmVyKHR5cGUsICd1cGRhdGVzdGFydCcsIHRoaXMub25TQlVwZGF0ZVN0YXJ0KTtcbiAgICB0aGlzLmFkZEJ1ZmZlckxpc3RlbmVyKHR5cGUsICd1cGRhdGVlbmQnLCB0aGlzLm9uU0JVcGRhdGVFbmQpO1xuICAgIHRoaXMuYWRkQnVmZmVyTGlzdGVuZXIodHlwZSwgJ2Vycm9yJywgdGhpcy5vblNCVXBkYXRlRXJyb3IpO1xuICAgIC8vIE1hbmFnZWRTb3VyY2VCdWZmZXIgYnVmZmVyZWRjaGFuZ2UgZXZlbnRcbiAgICBpZiAodGhpcy5hcHBlbmRTb3VyY2UpIHtcbiAgICAgIHRoaXMuYWRkQnVmZmVyTGlzdGVuZXIodHlwZSwgJ2J1ZmZlcmVkY2hhbmdlJywgKHR5cGUsIGV2ZW50KSA9PiB7XG4gICAgICAgIC8vIElmIG1lZGlhIHdhcyBlamVjdGVkIGNoZWNrIGZvciBhIGNoYW5nZS4gQWRkZWQgcmFuZ2VzIGFyZSByZWR1bmRhbnQgd2l0aCBjaGFuZ2VzIG9uICd1cGRhdGVlbmQnIGV2ZW50LlxuICAgICAgICBjb25zdCByZW1vdmVkUmFuZ2VzID0gZXZlbnQucmVtb3ZlZFJhbmdlcztcbiAgICAgICAgaWYgKHJlbW92ZWRSYW5nZXMgIT0gbnVsbCAmJiByZW1vdmVkUmFuZ2VzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9GTFVTSEVELCB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXQgbWVkaWFTcmMoKSB7XG4gICAgdmFyIF90aGlzJG1lZGlhMiwgX3RoaXMkbWVkaWEyJHF1ZXJ5U2VsO1xuICAgIGNvbnN0IG1lZGlhID0gKChfdGhpcyRtZWRpYTIgPSB0aGlzLm1lZGlhKSA9PSBudWxsID8gdm9pZCAwIDogKF90aGlzJG1lZGlhMiRxdWVyeVNlbCA9IF90aGlzJG1lZGlhMi5xdWVyeVNlbGVjdG9yKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbWVkaWEyJHF1ZXJ5U2VsLmNhbGwoX3RoaXMkbWVkaWEyLCAnc291cmNlJykpIHx8IHRoaXMubWVkaWE7XG4gICAgcmV0dXJuIG1lZGlhID09IG51bGwgPyB2b2lkIDAgOiBtZWRpYS5zcmM7XG4gIH1cbiAgb25TQlVwZGF0ZVN0YXJ0KHR5cGUpIHtcbiAgICBjb25zdCBvcGVyYXRpb24gPSB0aGlzLmN1cnJlbnRPcCh0eXBlKTtcbiAgICBpZiAoIW9wZXJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvcGVyYXRpb24ub25TdGFydCgpO1xuICB9XG4gIG9uU0JVcGRhdGVFbmQodHlwZSkge1xuICAgIHZhciBfdGhpcyRtZWRpYVNvdXJjZTQ7XG4gICAgaWYgKCgoX3RoaXMkbWVkaWFTb3VyY2U0ID0gdGhpcy5tZWRpYVNvdXJjZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG1lZGlhU291cmNlNC5yZWFkeVN0YXRlKSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgIHRoaXMucmVzZXRCdWZmZXIodHlwZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHRoaXMuY3VycmVudE9wKHR5cGUpO1xuICAgIGlmICghb3BlcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG9wZXJhdGlvbi5vbkNvbXBsZXRlKCk7XG4gICAgdGhpcy5zaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpO1xuICB9XG4gIG9uU0JVcGRhdGVFcnJvcih0eXBlLCBldmVudCkge1xuICAgIHZhciBfdGhpcyRtZWRpYVNvdXJjZTU7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYCR7dHlwZX0gU291cmNlQnVmZmVyIGVycm9yLiBNZWRpYVNvdXJjZSByZWFkeVN0YXRlOiAkeyhfdGhpcyRtZWRpYVNvdXJjZTUgPSB0aGlzLm1lZGlhU291cmNlKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbWVkaWFTb3VyY2U1LnJlYWR5U3RhdGV9YCk7XG4gICAgdGhpcy5lcnJvcihgJHtlcnJvcn1gLCBldmVudCk7XG4gICAgLy8gYWNjb3JkaW5nIHRvIGh0dHA6Ly93d3cudzMub3JnL1RSL21lZGlhLXNvdXJjZS8jc291cmNlYnVmZmVyLWFwcGVuZC1lcnJvclxuICAgIC8vIFNvdXJjZUJ1ZmZlciBlcnJvcnMgYXJlIG5vdCBuZWNlc3NhcmlseSBmYXRhbDsgaWYgc28sIHRoZSBIVE1MTWVkaWFFbGVtZW50IHdpbGwgZmlyZSBhbiBlcnJvciBldmVudFxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRJTkdfRVJST1IsXG4gICAgICBzb3VyY2VCdWZmZXJOYW1lOiB0eXBlLFxuICAgICAgZXJyb3IsXG4gICAgICBmYXRhbDogZmFsc2VcbiAgICB9KTtcbiAgICAvLyB1cGRhdGVlbmQgaXMgYWx3YXlzIGZpcmVkIGFmdGVyIGVycm9yLCBzbyB3ZSdsbCBhbGxvdyB0aGF0IHRvIHNoaWZ0IHRoZSBjdXJyZW50IG9wZXJhdGlvbiBvZmYgb2YgdGhlIHF1ZXVlXG4gICAgY29uc3Qgb3BlcmF0aW9uID0gdGhpcy5jdXJyZW50T3AodHlwZSk7XG4gICAgaWYgKG9wZXJhdGlvbikge1xuICAgICAgb3BlcmF0aW9uLm9uRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVUaW1lc3RhbXBPZmZzZXQoc2IsIHRpbWVzdGFtcE9mZnNldCwgdG9sZXJhbmNlLCB0eXBlLCBzbiwgY2MpIHtcbiAgICBjb25zdCBkZWx0YSA9IHRpbWVzdGFtcE9mZnNldCAtIHNiLnRpbWVzdGFtcE9mZnNldDtcbiAgICBpZiAoTWF0aC5hYnMoZGVsdGEpID49IHRvbGVyYW5jZSkge1xuICAgICAgdGhpcy5sb2coYFVwZGF0aW5nICR7dHlwZX0gU291cmNlQnVmZmVyIHRpbWVzdGFtcE9mZnNldCB0byAke3RpbWVzdGFtcE9mZnNldH0gKHNuOiAke3NufSBjYzogJHtjY30pYCk7XG4gICAgICBzYi50aW1lc3RhbXBPZmZzZXQgPSB0aW1lc3RhbXBPZmZzZXQ7XG4gICAgfVxuICB9XG5cbiAgLy8gVGhpcyBtZXRob2QgbXVzdCByZXN1bHQgaW4gYW4gdXBkYXRlZW5kIGV2ZW50OyBpZiByZW1vdmUgaXMgbm90IGNhbGxlZCwgb25TQlVwZGF0ZUVuZCBtdXN0IGJlIGNhbGxlZCBtYW51YWxseVxuICByZW1vdmVFeGVjdXRvcih0eXBlLCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0KSB7XG4gICAgY29uc3Qge1xuICAgICAgbWVkaWEsXG4gICAgICBtZWRpYVNvdXJjZVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHRyYWNrID0gdGhpcy50cmFja3NbdHlwZV07XG4gICAgY29uc3Qgc2IgPSB0cmFjayA9PSBudWxsID8gdm9pZCAwIDogdHJhY2suYnVmZmVyO1xuICAgIGlmICghbWVkaWEgfHwgIW1lZGlhU291cmNlIHx8ICFzYikge1xuICAgICAgdGhpcy53YXJuKGBBdHRlbXB0aW5nIHRvIHJlbW92ZSBmcm9tIHRoZSAke3R5cGV9IFNvdXJjZUJ1ZmZlciwgYnV0IGl0IGRvZXMgbm90IGV4aXN0YCk7XG4gICAgICB0aGlzLnNoaWZ0QW5kRXhlY3V0ZU5leHQodHlwZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1lZGlhRHVyYXRpb24gPSBpc0Zpbml0ZU51bWJlcihtZWRpYS5kdXJhdGlvbikgPyBtZWRpYS5kdXJhdGlvbiA6IEluZmluaXR5O1xuICAgIGNvbnN0IG1zRHVyYXRpb24gPSBpc0Zpbml0ZU51bWJlcihtZWRpYVNvdXJjZS5kdXJhdGlvbikgPyBtZWRpYVNvdXJjZS5kdXJhdGlvbiA6IEluZmluaXR5O1xuICAgIGNvbnN0IHJlbW92ZVN0YXJ0ID0gTWF0aC5tYXgoMCwgc3RhcnRPZmZzZXQpO1xuICAgIGNvbnN0IHJlbW92ZUVuZCA9IE1hdGgubWluKGVuZE9mZnNldCwgbWVkaWFEdXJhdGlvbiwgbXNEdXJhdGlvbik7XG4gICAgaWYgKHJlbW92ZUVuZCA+IHJlbW92ZVN0YXJ0ICYmICghdHJhY2suZW5kaW5nIHx8IHRyYWNrLmVuZGVkKSkge1xuICAgICAgdHJhY2suZW5kZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMubG9nKGBSZW1vdmluZyBbJHtyZW1vdmVTdGFydH0sJHtyZW1vdmVFbmR9XSBmcm9tIHRoZSAke3R5cGV9IFNvdXJjZUJ1ZmZlcmApO1xuICAgICAgc2IucmVtb3ZlKHJlbW92ZVN0YXJ0LCByZW1vdmVFbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDeWNsZSB0aGUgcXVldWVcbiAgICAgIHRoaXMuc2hpZnRBbmRFeGVjdXRlTmV4dCh0eXBlKTtcbiAgICB9XG4gIH1cblxuICAvLyBUaGlzIG1ldGhvZCBtdXN0IHJlc3VsdCBpbiBhbiB1cGRhdGVlbmQgZXZlbnQ7IGlmIGFwcGVuZCBpcyBub3QgY2FsbGVkLCBvblNCVXBkYXRlRW5kIG11c3QgYmUgY2FsbGVkIG1hbnVhbGx5XG4gIGFwcGVuZEV4ZWN1dG9yKGRhdGEsIHR5cGUpIHtcbiAgICBjb25zdCB0cmFjayA9IHRoaXMudHJhY2tzW3R5cGVdO1xuICAgIGNvbnN0IHNiID0gdHJhY2sgPT0gbnVsbCA/IHZvaWQgMCA6IHRyYWNrLmJ1ZmZlcjtcbiAgICBpZiAoIXNiKSB7XG4gICAgICB0aHJvdyBuZXcgSGxzSnNUcmFja1JlbW92ZWRFcnJvcihgQXR0ZW1wdGluZyB0byBhcHBlbmQgdG8gdGhlICR7dHlwZX0gU291cmNlQnVmZmVyLCBidXQgaXQgZG9lcyBub3QgZXhpc3RgKTtcbiAgICB9XG4gICAgdHJhY2suZW5kaW5nID0gZmFsc2U7XG4gICAgdHJhY2suZW5kZWQgPSBmYWxzZTtcbiAgICBzYi5hcHBlbmRCdWZmZXIoZGF0YSk7XG4gIH1cbiAgYmxvY2tVbnRpbE9wZW4oY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5pc1VwZGF0aW5nKCkgfHwgdGhpcy5pc1F1ZXVlZCgpKSB7XG4gICAgICB0aGlzLmJsb2NrQnVmZmVycyhjYWxsYmFjaykuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICB0aGlzLndhcm4oYFNvdXJjZUJ1ZmZlciBibG9ja2VkIGNhbGxiYWNrICR7ZXJyb3J9YCk7XG4gICAgICAgIHRoaXMuc3RlcE9wZXJhdGlvblF1ZXVlKHRoaXMuc291cmNlQnVmZmVyVHlwZXMpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aGlzLndhcm4oYENhbGxiYWNrIHJ1biB3aXRob3V0IGJsb2NraW5nICR7dGhpcy5vcGVyYXRpb25RdWV1ZX0gJHtlcnJvcn1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaXNVcGRhdGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2VCdWZmZXJzLnNvbWUoKFt0eXBlLCBzYl0pID0+IHR5cGUgJiYgc2IudXBkYXRpbmcpO1xuICB9XG4gIGlzUXVldWVkKCkge1xuICAgIHJldHVybiB0aGlzLnNvdXJjZUJ1ZmZlcnMuc29tZSgoW3R5cGVdKSA9PiB0eXBlICYmICEhdGhpcy5jdXJyZW50T3AodHlwZSkpO1xuICB9XG4gIGlzUGVuZGluZyh0cmFjaykge1xuICAgIHJldHVybiAhIXRyYWNrICYmICF0cmFjay5idWZmZXI7XG4gIH1cblxuICAvLyBFbnF1ZXVlcyBhbiBvcGVyYXRpb24gdG8gZWFjaCBTb3VyY2VCdWZmZXIgcXVldWUgd2hpY2gsIHVwb24gZXhlY3V0aW9uLCByZXNvbHZlcyBhIHByb21pc2UuIFdoZW4gYWxsIHByb21pc2VzXG4gIC8vIHJlc29sdmUsIHRoZSBvblVuYmxvY2tlZCBmdW5jdGlvbiBpcyBleGVjdXRlZC4gRnVuY3Rpb25zIGNhbGxpbmcgdGhpcyBtZXRob2QgZG8gbm90IG5lZWQgdG8gdW5ibG9jayB0aGUgcXVldWVcbiAgLy8gdXBvbiBjb21wbGV0aW9uLCBzaW5jZSB3ZSBhbHJlYWR5IGRvIGl0IGhlcmVcbiAgYmxvY2tCdWZmZXJzKG9uVW5ibG9ja2VkLCBidWZmZXJOYW1lcyA9IHRoaXMuc291cmNlQnVmZmVyVHlwZXMpIHtcbiAgICBpZiAoIWJ1ZmZlck5hbWVzLmxlbmd0aCkge1xuICAgICAgdGhpcy5sb2coJ0Jsb2NraW5nIG9wZXJhdGlvbiByZXF1ZXN0ZWQsIGJ1dCBubyBTb3VyY2VCdWZmZXJzIGV4aXN0Jyk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihvblVuYmxvY2tlZCk7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIG9wZXJhdGlvblF1ZXVlXG4gICAgfSA9IHRoaXM7XG5cbiAgICAvLyBsb2dnZXIuZGVidWcoYFtidWZmZXItY29udHJvbGxlcl06IEJsb2NraW5nICR7YnVmZmVyc30gU291cmNlQnVmZmVyYCk7XG4gICAgY29uc3QgYmxvY2tpbmdPcGVyYXRpb25zID0gYnVmZmVyTmFtZXMubWFwKHR5cGUgPT4gdGhpcy5hcHBlbmRCbG9ja2VyKHR5cGUpKTtcbiAgICBjb25zdCBhdWRpb0Jsb2NrZWQgPSBidWZmZXJOYW1lcy5sZW5ndGggPiAxICYmICEhdGhpcy5ibG9ja2VkQXVkaW9BcHBlbmQ7XG4gICAgaWYgKGF1ZGlvQmxvY2tlZCkge1xuICAgICAgdGhpcy51bmJsb2NrQXVkaW8oKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGJsb2NraW5nT3BlcmF0aW9ucykudGhlbihyZXN1bHQgPT4ge1xuICAgICAgaWYgKG9wZXJhdGlvblF1ZXVlICE9PSB0aGlzLm9wZXJhdGlvblF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGxvZ2dlci5kZWJ1ZyhgW2J1ZmZlci1jb250cm9sbGVyXTogQmxvY2tpbmcgb3BlcmF0aW9uIHJlc29sdmVkOyB1bmJsb2NraW5nICR7YnVmZmVyc30gU291cmNlQnVmZmVyYCk7XG4gICAgICBvblVuYmxvY2tlZCgpO1xuICAgICAgdGhpcy5zdGVwT3BlcmF0aW9uUXVldWUodGhpcy5zb3VyY2VCdWZmZXJUeXBlcyk7XG4gICAgfSk7XG4gIH1cbiAgc3RlcE9wZXJhdGlvblF1ZXVlKGJ1ZmZlck5hbWVzKSB7XG4gICAgYnVmZmVyTmFtZXMuZm9yRWFjaCh0eXBlID0+IHtcbiAgICAgIHZhciBfdGhpcyR0cmFja3MkdHlwZTY7XG4gICAgICBjb25zdCBzYiA9IChfdGhpcyR0cmFja3MkdHlwZTYgPSB0aGlzLnRyYWNrc1t0eXBlXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHRyYWNrcyR0eXBlNi5idWZmZXI7XG4gICAgICAvLyBPbmx5IGN5Y2xlIHRoZSBxdWV1ZSBpZiB0aGUgU0IgaXMgbm90IHVwZGF0aW5nLiBUaGVyZSdzIGEgYnVnIGluIENocm9tZSB3aGljaCBzZXRzIHRoZSBTQiB1cGRhdGluZyBmbGFnIHRvXG4gICAgICAvLyB0cnVlIHdoZW4gY2hhbmdpbmcgdGhlIE1lZGlhU291cmNlIGR1cmF0aW9uIChodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD05NTkzNTkmY2FuPTImcT1tZWRpYXNvdXJjZSUyMGR1cmF0aW9uKVxuICAgICAgLy8gV2hpbGUgdGhpcyBpcyBhIHdvcmthcm91bmQsIGl0J3MgcHJvYmFibHkgdXNlZnVsIHRvIGhhdmUgYXJvdW5kXG4gICAgICBpZiAoIXNiIHx8IHNiLnVwZGF0aW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2hpZnRBbmRFeGVjdXRlTmV4dCh0eXBlKTtcbiAgICB9KTtcbiAgfVxuICBhcHBlbmQob3BlcmF0aW9uLCB0eXBlLCBwZW5kaW5nKSB7XG4gICAgaWYgKHRoaXMub3BlcmF0aW9uUXVldWUpIHtcbiAgICAgIHRoaXMub3BlcmF0aW9uUXVldWUuYXBwZW5kKG9wZXJhdGlvbiwgdHlwZSwgcGVuZGluZyk7XG4gICAgfVxuICB9XG4gIGFwcGVuZEJsb2NrZXIodHlwZSkge1xuICAgIGlmICh0aGlzLm9wZXJhdGlvblF1ZXVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcGVyYXRpb25RdWV1ZS5hcHBlbmRCbG9ja2VyKHR5cGUpO1xuICAgIH1cbiAgfVxuICBjdXJyZW50T3AodHlwZSkge1xuICAgIGlmICh0aGlzLm9wZXJhdGlvblF1ZXVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcGVyYXRpb25RdWV1ZS5jdXJyZW50KHR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBleGVjdXRlTmV4dCh0eXBlKSB7XG4gICAgaWYgKHR5cGUgJiYgdGhpcy5vcGVyYXRpb25RdWV1ZSkge1xuICAgICAgdGhpcy5vcGVyYXRpb25RdWV1ZS5leGVjdXRlTmV4dCh0eXBlKTtcbiAgICB9XG4gIH1cbiAgc2hpZnRBbmRFeGVjdXRlTmV4dCh0eXBlKSB7XG4gICAgaWYgKHRoaXMub3BlcmF0aW9uUXVldWUpIHtcbiAgICAgIHRoaXMub3BlcmF0aW9uUXVldWUuc2hpZnRBbmRFeGVjdXRlTmV4dCh0eXBlKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHBlbmRpbmdUcmFja0NvdW50KCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnRyYWNrcykucmVkdWNlKChhY2MsIHR5cGUpID0+IGFjYyArICh0aGlzLmlzUGVuZGluZyh0aGlzLnRyYWNrc1t0eXBlXSkgPyAxIDogMCksIDApO1xuICB9XG4gIGdldCBzb3VyY2VCdWZmZXJDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2VCdWZmZXJzLnJlZHVjZSgoYWNjLCBbdHlwZV0pID0+IGFjYyArICh0eXBlID8gMSA6IDApLCAwKTtcbiAgfVxuICBnZXQgc291cmNlQnVmZmVyVHlwZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlQnVmZmVycy5tYXAoKFt0eXBlXSkgPT4gdHlwZSkuZmlsdGVyKHR5cGUgPT4gISF0eXBlKTtcbiAgfVxuICBhZGRCdWZmZXJMaXN0ZW5lcih0eXBlLCBldmVudCwgZm4pIHtcbiAgICBjb25zdCB0cmFjayA9IHRoaXMudHJhY2tzW3R5cGVdO1xuICAgIGlmICghdHJhY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYnVmZmVyID0gdHJhY2suYnVmZmVyO1xuICAgIGlmICghYnVmZmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxpc3RlbmVyID0gZm4uYmluZCh0aGlzLCB0eXBlKTtcbiAgICB0cmFjay5saXN0ZW5lcnMucHVzaCh7XG4gICAgICBldmVudCxcbiAgICAgIGxpc3RlbmVyXG4gICAgfSk7XG4gICAgYnVmZmVyLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKTtcbiAgfVxuICByZW1vdmVCdWZmZXJMaXN0ZW5lcnModHlwZSkge1xuICAgIGNvbnN0IHRyYWNrID0gdGhpcy50cmFja3NbdHlwZV07XG4gICAgaWYgKCF0cmFjaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBidWZmZXIgPSB0cmFjay5idWZmZXI7XG4gICAgaWYgKCFidWZmZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJhY2subGlzdGVuZXJzLmZvckVhY2gobCA9PiB7XG4gICAgICBidWZmZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihsLmV2ZW50LCBsLmxpc3RlbmVyKTtcbiAgICB9KTtcbiAgICB0cmFjay5saXN0ZW5lcnMubGVuZ3RoID0gMDtcbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlU291cmNlQ2hpbGRyZW4obm9kZSkge1xuICBjb25zdCBzb3VyY2VDaGlsZHJlbiA9IG5vZGUucXVlcnlTZWxlY3RvckFsbCgnc291cmNlJyk7XG4gIFtdLnNsaWNlLmNhbGwoc291cmNlQ2hpbGRyZW4pLmZvckVhY2goc291cmNlID0+IHtcbiAgICBub2RlLnJlbW92ZUNoaWxkKHNvdXJjZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gYWRkU291cmNlKG1lZGlhLCB1cmwpIHtcbiAgY29uc3Qgc291cmNlID0gc2VsZi5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzb3VyY2UnKTtcbiAgc291cmNlLnR5cGUgPSAndmlkZW8vbXA0JztcbiAgc291cmNlLnNyYyA9IHVybDtcbiAgbWVkaWEuYXBwZW5kQ2hpbGQoc291cmNlKTtcbn1cbmZ1bmN0aW9uIHNvdXJjZUJ1ZmZlck5hbWVUb0luZGV4KHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUgPT09ICdhdWRpbycgPyAxIDogMDtcbn1cblxuY2xhc3MgQ2FwTGV2ZWxDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gdm9pZCAwO1xuICAgIHRoaXMuZmlyc3RMZXZlbCA9IHZvaWQgMDtcbiAgICB0aGlzLm1lZGlhID0gdm9pZCAwO1xuICAgIHRoaXMucmVzdHJpY3RlZExldmVscyA9IHZvaWQgMDtcbiAgICB0aGlzLnRpbWVyID0gdm9pZCAwO1xuICAgIHRoaXMuY2xpZW50UmVjdCA9IHZvaWQgMDtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIHRoaXMuZmlyc3RMZXZlbCA9IC0xO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMucmVzdHJpY3RlZExldmVscyA9IFtdO1xuICAgIHRoaXMudGltZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jbGllbnRSZWN0ID0gbnVsbDtcbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgc2V0U3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyKSB7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyID0gc3RyZWFtQ29udHJvbGxlcjtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmhscykge1xuICAgICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXIoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgIHRoaXMuc3RvcENhcHBpbmcoKTtcbiAgICB9XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5jbGllbnRSZWN0ID0gbnVsbDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSB0aGlzLnN0cmVhbUNvbnRyb2xsZXIgPSBudWxsO1xuICB9XG4gIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vbihFdmVudHMuRlBTX0RST1BfTEVWRUxfQ0FQUElORywgdGhpcy5vbkZwc0Ryb3BMZXZlbENhcHBpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxTX1VQREFURUQsIHRoaXMub25MZXZlbHNVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9DT0RFQ1MsIHRoaXMub25CdWZmZXJDb2RlY3MsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICB9XG4gIHVucmVnaXN0ZXJMaXN0ZW5lcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub2ZmKEV2ZW50cy5GUFNfRFJPUF9MRVZFTF9DQVBQSU5HLCB0aGlzLm9uRnBzRHJvcExldmVsQ2FwcGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTFNfVVBEQVRFRCwgdGhpcy5vbkxldmVsc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9DT0RFQ1MsIHRoaXMub25CdWZmZXJDb2RlY3MsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgfVxuICBvbkZwc0Ryb3BMZXZlbENhcHBpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICAvLyBEb24ndCBhZGQgYSByZXN0cmljdGVkIGxldmVsIG1vcmUgdGhhbiBvbmNlXG4gICAgY29uc3QgbGV2ZWwgPSB0aGlzLmhscy5sZXZlbHNbZGF0YS5kcm9wcGVkTGV2ZWxdO1xuICAgIGlmICh0aGlzLmlzTGV2ZWxBbGxvd2VkKGxldmVsKSkge1xuICAgICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzLnB1c2goe1xuICAgICAgICBiaXRyYXRlOiBsZXZlbC5iaXRyYXRlLFxuICAgICAgICBoZWlnaHQ6IGxldmVsLmhlaWdodCxcbiAgICAgICAgd2lkdGg6IGxldmVsLndpZHRoXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgb25NZWRpYUF0dGFjaGluZyhldmVudCwgZGF0YSkge1xuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCA/IGRhdGEubWVkaWEgOiBudWxsO1xuICAgIHRoaXMuY2xpZW50UmVjdCA9IG51bGw7XG4gICAgaWYgKHRoaXMudGltZXIgJiYgdGhpcy5obHMubGV2ZWxzLmxlbmd0aCkge1xuICAgICAgdGhpcy5kZXRlY3RQbGF5ZXJTaXplKCk7XG4gICAgfVxuICB9XG4gIG9uTWFuaWZlc3RQYXJzZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMgPSBbXTtcbiAgICB0aGlzLmZpcnN0TGV2ZWwgPSBkYXRhLmZpcnN0TGV2ZWw7XG4gICAgaWYgKGhscy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemUgJiYgZGF0YS52aWRlbykge1xuICAgICAgLy8gU3RhcnQgY2FwcGluZyBpbW1lZGlhdGVseSBpZiB0aGUgbWFuaWZlc3QgaGFzIHNpZ25hbGVkIHZpZGVvIGNvZGVjc1xuICAgICAgdGhpcy5zdGFydENhcHBpbmcoKTtcbiAgICB9XG4gIH1cbiAgb25MZXZlbHNVcGRhdGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKHRoaXMudGltZXIgJiYgaXNGaW5pdGVOdW1iZXIodGhpcy5hdXRvTGV2ZWxDYXBwaW5nKSkge1xuICAgICAgdGhpcy5kZXRlY3RQbGF5ZXJTaXplKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gT25seSBhY3RpdmF0ZSBjYXBwaW5nIHdoZW4gcGxheWluZyBhIHZpZGVvIHN0cmVhbTsgb3RoZXJ3aXNlLCBtdWx0aS1iaXRyYXRlIGF1ZGlvLW9ubHkgc3RyZWFtcyB3aWxsIGJlIHJlc3RyaWN0ZWRcbiAgLy8gdG8gdGhlIGZpcnN0IGxldmVsXG4gIG9uQnVmZmVyQ29kZWNzKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgaWYgKGhscy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemUgJiYgZGF0YS52aWRlbykge1xuICAgICAgLy8gSWYgdGhlIG1hbmlmZXN0IGRpZCBub3Qgc2lnbmFsIGEgdmlkZW8gY29kZWMgY2FwcGluZyBoYXMgYmVlbiBkZWZlcnJlZCB1bnRpbCB3ZSdyZSBjZXJ0YWluIHZpZGVvIGlzIHByZXNlbnRcbiAgICAgIHRoaXMuc3RhcnRDYXBwaW5nKCk7XG4gICAgfVxuICB9XG4gIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgdGhpcy5zdG9wQ2FwcGluZygpO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICB9XG4gIGRldGVjdFBsYXllclNpemUoKSB7XG4gICAgaWYgKHRoaXMubWVkaWEpIHtcbiAgICAgIGlmICh0aGlzLm1lZGlhSGVpZ2h0IDw9IDAgfHwgdGhpcy5tZWRpYVdpZHRoIDw9IDApIHtcbiAgICAgICAgdGhpcy5jbGllbnRSZWN0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbGV2ZWxzID0gdGhpcy5obHMubGV2ZWxzO1xuICAgICAgaWYgKGxldmVscy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgICAgIGNvbnN0IG1heExldmVsID0gdGhpcy5nZXRNYXhMZXZlbChsZXZlbHMubGVuZ3RoIC0gMSk7XG4gICAgICAgIGlmIChtYXhMZXZlbCAhPT0gdGhpcy5hdXRvTGV2ZWxDYXBwaW5nKSB7XG4gICAgICAgICAgaGxzLmxvZ2dlci5sb2coYFNldHRpbmcgYXV0b0xldmVsQ2FwcGluZyB0byAke21heExldmVsfTogJHtsZXZlbHNbbWF4TGV2ZWxdLmhlaWdodH1wQCR7bGV2ZWxzW21heExldmVsXS5iaXRyYXRlfSBmb3IgbWVkaWEgJHt0aGlzLm1lZGlhV2lkdGh9eCR7dGhpcy5tZWRpYUhlaWdodH1gKTtcbiAgICAgICAgfVxuICAgICAgICBobHMuYXV0b0xldmVsQ2FwcGluZyA9IG1heExldmVsO1xuICAgICAgICBpZiAoaGxzLmF1dG9MZXZlbEVuYWJsZWQgJiYgaGxzLmF1dG9MZXZlbENhcHBpbmcgPiB0aGlzLmF1dG9MZXZlbENhcHBpbmcgJiYgdGhpcy5zdHJlYW1Db250cm9sbGVyKSB7XG4gICAgICAgICAgLy8gaWYgYXV0byBsZXZlbCBjYXBwaW5nIGhhcyBhIGhpZ2hlciB2YWx1ZSBmb3IgdGhlIHByZXZpb3VzIG9uZSwgZmx1c2ggdGhlIGJ1ZmZlciB1c2luZyBuZXh0TGV2ZWxTd2l0Y2hcbiAgICAgICAgICAvLyB1c3VhbGx5IGhhcHBlbiB3aGVuIHRoZSB1c2VyIGdvIHRvIHRoZSBmdWxsc2NyZWVuIG1vZGUuXG4gICAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbFN3aXRjaCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IGhscy5hdXRvTGV2ZWxDYXBwaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qXG4gICAqIHJldHVybnMgbGV2ZWwgc2hvdWxkIGJlIHRoZSBvbmUgd2l0aCB0aGUgZGltZW5zaW9ucyBlcXVhbCBvciBncmVhdGVyIHRoYW4gdGhlIG1lZGlhIChwbGF5ZXIpIGRpbWVuc2lvbnMgKHNvIHRoZSB2aWRlbyB3aWxsIGJlIGRvd25zY2FsZWQpXG4gICAqL1xuICBnZXRNYXhMZXZlbChjYXBMZXZlbEluZGV4KSB7XG4gICAgY29uc3QgbGV2ZWxzID0gdGhpcy5obHMubGV2ZWxzO1xuICAgIGlmICghbGV2ZWxzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBjb25zdCB2YWxpZExldmVscyA9IGxldmVscy5maWx0ZXIoKGxldmVsLCBpbmRleCkgPT4gdGhpcy5pc0xldmVsQWxsb3dlZChsZXZlbCkgJiYgaW5kZXggPD0gY2FwTGV2ZWxJbmRleCk7XG4gICAgdGhpcy5jbGllbnRSZWN0ID0gbnVsbDtcbiAgICByZXR1cm4gQ2FwTGV2ZWxDb250cm9sbGVyLmdldE1heExldmVsQnlNZWRpYVNpemUodmFsaWRMZXZlbHMsIHRoaXMubWVkaWFXaWR0aCwgdGhpcy5tZWRpYUhlaWdodCk7XG4gIH1cbiAgc3RhcnRDYXBwaW5nKCkge1xuICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAvLyBEb24ndCByZXNldCBjYXBwaW5nIGlmIHN0YXJ0ZWQgdHdpY2U7IHRoaXMgY2FuIGhhcHBlbiBpZiB0aGUgbWFuaWZlc3Qgc2lnbmFscyBhIHZpZGVvIGNvZGVjXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBzZWxmLmNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgdGhpcy50aW1lciA9IHNlbGYuc2V0SW50ZXJ2YWwodGhpcy5kZXRlY3RQbGF5ZXJTaXplLmJpbmQodGhpcyksIDEwMDApO1xuICAgIHRoaXMuZGV0ZWN0UGxheWVyU2l6ZSgpO1xuICB9XG4gIHN0b3BDYXBwaW5nKCkge1xuICAgIHRoaXMucmVzdHJpY3RlZExldmVscyA9IFtdO1xuICAgIHRoaXMuZmlyc3RMZXZlbCA9IC0xO1xuICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgc2VsZi5jbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgdGhpcy50aW1lciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgZ2V0RGltZW5zaW9ucygpIHtcbiAgICBpZiAodGhpcy5jbGllbnRSZWN0KSB7XG4gICAgICByZXR1cm4gdGhpcy5jbGllbnRSZWN0O1xuICAgIH1cbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgY29uc3QgYm91bmRzUmVjdCA9IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfTtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIGNvbnN0IGNsaWVudFJlY3QgPSBtZWRpYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGJvdW5kc1JlY3Qud2lkdGggPSBjbGllbnRSZWN0LndpZHRoO1xuICAgICAgYm91bmRzUmVjdC5oZWlnaHQgPSBjbGllbnRSZWN0LmhlaWdodDtcbiAgICAgIGlmICghYm91bmRzUmVjdC53aWR0aCAmJiAhYm91bmRzUmVjdC5oZWlnaHQpIHtcbiAgICAgICAgLy8gV2hlbiB0aGUgbWVkaWEgZWxlbWVudCBoYXMgbm8gd2lkdGggb3IgaGVpZ2h0IChlcXVpdmFsZW50IHRvIG5vdCBiZWluZyBpbiB0aGUgRE9NKSxcbiAgICAgICAgLy8gdGhlbiB1c2UgaXRzIHdpZHRoIGFuZCBoZWlnaHQgYXR0cmlidXRlcyAobWVkaWEud2lkdGgsIG1lZGlhLmhlaWdodClcbiAgICAgICAgYm91bmRzUmVjdC53aWR0aCA9IGNsaWVudFJlY3QucmlnaHQgLSBjbGllbnRSZWN0LmxlZnQgfHwgbWVkaWEud2lkdGggfHwgMDtcbiAgICAgICAgYm91bmRzUmVjdC5oZWlnaHQgPSBjbGllbnRSZWN0LmJvdHRvbSAtIGNsaWVudFJlY3QudG9wIHx8IG1lZGlhLmhlaWdodCB8fCAwO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNsaWVudFJlY3QgPSBib3VuZHNSZWN0O1xuICAgIHJldHVybiBib3VuZHNSZWN0O1xuICB9XG4gIGdldCBtZWRpYVdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmdldERpbWVuc2lvbnMoKS53aWR0aCAqIHRoaXMuY29udGVudFNjYWxlRmFjdG9yO1xuICB9XG4gIGdldCBtZWRpYUhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXREaW1lbnNpb25zKCkuaGVpZ2h0ICogdGhpcy5jb250ZW50U2NhbGVGYWN0b3I7XG4gIH1cbiAgZ2V0IGNvbnRlbnRTY2FsZUZhY3RvcigpIHtcbiAgICBsZXQgcGl4ZWxSYXRpbyA9IDE7XG4gICAgaWYgKCF0aGlzLmhscy5jb25maWcuaWdub3JlRGV2aWNlUGl4ZWxSYXRpbykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGl4ZWxSYXRpbyA9IHNlbGYuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLyogbm8tb3AgKi9cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE1hdGgubWluKHBpeGVsUmF0aW8sIHRoaXMuaGxzLmNvbmZpZy5tYXhEZXZpY2VQaXhlbFJhdGlvKTtcbiAgfVxuICBpc0xldmVsQWxsb3dlZChsZXZlbCkge1xuICAgIGNvbnN0IHJlc3RyaWN0ZWRMZXZlbHMgPSB0aGlzLnJlc3RyaWN0ZWRMZXZlbHM7XG4gICAgcmV0dXJuICFyZXN0cmljdGVkTGV2ZWxzLnNvbWUocmVzdHJpY3RlZExldmVsID0+IHtcbiAgICAgIHJldHVybiBsZXZlbC5iaXRyYXRlID09PSByZXN0cmljdGVkTGV2ZWwuYml0cmF0ZSAmJiBsZXZlbC53aWR0aCA9PT0gcmVzdHJpY3RlZExldmVsLndpZHRoICYmIGxldmVsLmhlaWdodCA9PT0gcmVzdHJpY3RlZExldmVsLmhlaWdodDtcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0TWF4TGV2ZWxCeU1lZGlhU2l6ZShsZXZlbHMsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAoIShsZXZlbHMgIT0gbnVsbCAmJiBsZXZlbHMubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8vIExldmVscyBjYW4gaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb25zIGJ1dCBkaWZmZXJpbmcgYmFuZHdpZHRocyAtIHNpbmNlIGxldmVscyBhcmUgb3JkZXJlZCwgd2UgY2FuIGxvb2sgdG8gdGhlIG5leHRcbiAgICAvLyB0byBkZXRlcm1pbmUgd2hldGhlciB3ZSd2ZSBjaG9zZW4gdGhlIGdyZWF0ZXN0IGJhbmR3aWR0aCBmb3IgdGhlIG1lZGlhJ3MgZGltZW5zaW9uc1xuICAgIGNvbnN0IGF0R3JlYXRlc3RCYW5kd2lkdGggPSAoY3VyTGV2ZWwsIG5leHRMZXZlbCkgPT4ge1xuICAgICAgaWYgKCFuZXh0TGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VyTGV2ZWwud2lkdGggIT09IG5leHRMZXZlbC53aWR0aCB8fCBjdXJMZXZlbC5oZWlnaHQgIT09IG5leHRMZXZlbC5oZWlnaHQ7XG4gICAgfTtcblxuICAgIC8vIElmIHdlIHJ1biB0aHJvdWdoIHRoZSBsb29wIHdpdGhvdXQgYnJlYWtpbmcsIHRoZSBtZWRpYSdzIGRpbWVuc2lvbnMgYXJlIGdyZWF0ZXIgdGhhbiBldmVyeSBsZXZlbCwgc28gZGVmYXVsdCB0b1xuICAgIC8vIHRoZSBtYXggbGV2ZWxcbiAgICBsZXQgbWF4TGV2ZWxJbmRleCA9IGxldmVscy5sZW5ndGggLSAxO1xuICAgIC8vIFByZXZlbnQgY2hhbmdlcyBpbiBhc3BlY3QtcmF0aW8gZnJvbSBjYXVzaW5nIGNhcHBpbmcgdG8gdG9nZ2xlIGJhY2sgYW5kIGZvcnRoXG4gICAgY29uc3Qgc3F1YXJlU2l6ZSA9IE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGV2ZWxzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjb25zdCBsZXZlbCA9IGxldmVsc1tpXTtcbiAgICAgIGlmICgobGV2ZWwud2lkdGggPj0gc3F1YXJlU2l6ZSB8fCBsZXZlbC5oZWlnaHQgPj0gc3F1YXJlU2l6ZSkgJiYgYXRHcmVhdGVzdEJhbmR3aWR0aChsZXZlbCwgbGV2ZWxzW2kgKyAxXSkpIHtcbiAgICAgICAgbWF4TGV2ZWxJbmRleCA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF4TGV2ZWxJbmRleDtcbiAgfVxufVxuXG4vKipcbiAqIENvbW1vbiBNZWRpYSBPYmplY3QgVHlwZVxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBDbU9iamVjdFR5cGUgPSB7XG4gIC8qKlxuICAgKiB0ZXh0IGZpbGUsIHN1Y2ggYXMgYSBtYW5pZmVzdCBvciBwbGF5bGlzdFxuICAgKi9cbiAgTUFOSUZFU1Q6ICdtJyxcbiAgLyoqXG4gICAqIGF1ZGlvIG9ubHlcbiAgICovXG4gIEFVRElPOiAnYScsXG4gIC8qKlxuICAgKiB2aWRlbyBvbmx5XG4gICAqL1xuICBWSURFTzogJ3YnLFxuICAvKipcbiAgICogbXV4ZWQgYXVkaW8gYW5kIHZpZGVvXG4gICAqL1xuICBNVVhFRDogJ2F2JyxcbiAgLyoqXG4gICAqIGluaXQgc2VnbWVudFxuICAgKi9cbiAgSU5JVDogJ2knLFxuICAvKipcbiAgICogY2FwdGlvbiBvciBzdWJ0aXRsZVxuICAgKi9cbiAgQ0FQVElPTjogJ2MnLFxuICAvKipcbiAgICogSVNPQk1GRiB0aW1lZCB0ZXh0IHRyYWNrXG4gICAqL1xuICBUSU1FRF9URVhUOiAndHQnLFxuICAvKipcbiAgICogY3J5cHRvZ3JhcGhpYyBrZXksIGxpY2Vuc2Ugb3IgY2VydGlmaWNhdGUuXG4gICAqL1xuICBLRVk6ICdrJyxcbiAgLyoqXG4gICAqIG90aGVyXG4gICAqL1xuICBPVEhFUjogJ28nXG59O1xuXG4vKipcbiAqIENvbW1vbiBNZWRpYSBDbGllbnQgRGF0YSBPYmplY3QgVHlwZVxuICpcbiAqIEBncm91cCBDTUNEXG4gKlxuICogQGJldGFcbiAqXG4gKiBAZW51bVxuICovXG5jb25zdCBDbWNkT2JqZWN0VHlwZSA9IENtT2JqZWN0VHlwZTtcblxuLyoqXG4gKiBDb21tb24gTWVkaWEgU3RyZWFtaW5nIEZvcm1hdFxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBDbVN0cmVhbWluZ0Zvcm1hdCA9IHtcbiAgLyoqXG4gICAqIEhUVFAgTGl2ZSBTdHJlYW1pbmcgKEhMUylcbiAgICovXG4gIEhMUzogJ2gnfTtcblxuLyoqXG4gKiBDb21tb24gTWVkaWEgQ2xpZW50IERhdGEgU3RyZWFtaW5nIEZvcm1hdFxuICpcbiAqIEBncm91cCBDTUNEXG4gKlxuICogQGVudW1cbiAqXG4gKiBAYmV0YVxuICovXG5jb25zdCBDbWNkU3RyZWFtaW5nRm9ybWF0ID0gQ21TdHJlYW1pbmdGb3JtYXQ7XG5cbi8qKlxuICogQ01DRCBvYmplY3QgaGVhZGVyIG5hbWUuXG4gKlxuICogQGdyb3VwIENNQ0RcbiAqXG4gKiBAYmV0YVxuICovXG5jb25zdCBDTUNEX09CSkVDVCA9ICdDTUNELU9iamVjdCc7XG5cbi8qKlxuICogQ01DRCByZXF1ZXN0IGhlYWRlciBuYW1lLlxuICpcbiAqIEBncm91cCBDTUNEXG4gKlxuICogQGJldGFcbiAqL1xuY29uc3QgQ01DRF9SRVFVRVNUID0gJ0NNQ0QtUmVxdWVzdCc7XG5cbi8qKlxuICogQ01DRCBzZXNzaW9uIGhlYWRlciBuYW1lLlxuICpcbiAqIEBncm91cCBDTUNEXG4gKlxuICogQGJldGFcbiAqL1xuY29uc3QgQ01DRF9TRVNTSU9OID0gJ0NNQ0QtU2Vzc2lvbic7XG5cbi8qKlxuICogQ01DRCBzdGF0dXMgaGVhZGVyIG5hbWUuXG4gKlxuICogQGdyb3VwIENNQ0RcbiAqXG4gKiBAYmV0YVxuICovXG5jb25zdCBDTUNEX1NUQVRVUyA9ICdDTUNELVN0YXR1cyc7XG5cbi8qKlxuICogQ01DRCBoZWFkZXIgZmllbGRzLlxuICpcbiAqIEBncm91cCBDTUNEXG4gKlxuICogQGVudW1cbiAqXG4gKiBAYmV0YVxuICovXG5jb25zdCBDbWNkSGVhZGVyRmllbGQgPSB7XG4gIC8qKlxuICAgKiBrZXlzIHdob3NlIHZhbHVlcyB2YXJ5IHdpdGggdGhlIG9iamVjdCBiZWluZyByZXF1ZXN0ZWQuXG4gICAqL1xuICBPQkpFQ1Q6IENNQ0RfT0JKRUNULFxuICAvKipcbiAgICoga2V5cyB3aG9zZSB2YWx1ZXMgdmFyeSB3aXRoIGVhY2ggcmVxdWVzdC5cbiAgICovXG4gIFJFUVVFU1Q6IENNQ0RfUkVRVUVTVCxcbiAgLyoqXG4gICAqIGtleXMgd2hvc2UgdmFsdWVzIGFyZSBleHBlY3RlZCB0byBiZSBpbnZhcmlhbnQgb3ZlciB0aGUgbGlmZSBvZiB0aGUgc2Vzc2lvbi5cbiAgICovXG4gIFNFU1NJT046IENNQ0RfU0VTU0lPTixcbiAgLyoqXG4gICAqIGtleXMgd2hvc2UgdmFsdWVzIGRvIG5vdCB2YXJ5IHdpdGggZXZlcnkgcmVxdWVzdCBvciBvYmplY3QuXG4gICAqL1xuICBTVEFUVVM6IENNQ0RfU1RBVFVTXG59O1xuXG4vKipcbiAqIFRoZSBtYXAgb2YgQ01DRCBoZWFkZXIgZmllbGRzIHRvIG9mZmljaWFsIENNQ0Qga2V5cy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBAZ3JvdXAgQ01DRFxuICovXG5jb25zdCBDbWNkSGVhZGVyTWFwID0ge1xuICBbQ21jZEhlYWRlckZpZWxkLk9CSkVDVF06IFsnYnInLCAnYWInLCAnZCcsICdvdCcsICd0YicsICd0cGInLCAnbGInLCAndGFiJywgJ2xhYicsICd1cmwnXSxcbiAgW0NtY2RIZWFkZXJGaWVsZC5SRVFVRVNUXTogWydwYicsICdibCcsICd0YmwnLCAnZGwnLCAnbHRjJywgJ210cCcsICdub3InLCAnbnJyJywgJ3JjJywgJ3NuJywgJ3N0YScsICdzdScsICd0dGZiJywgJ3R0ZmJiJywgJ3R0bGInLCAnY21zZGQnLCAnY21zZHMnLCAnc21ydCcsICdkZicsICdjcyddLFxuICBbQ21jZEhlYWRlckZpZWxkLlNFU1NJT05dOiBbJ2NpZCcsICdwcicsICdzZicsICdzaWQnLCAnc3QnLCAndicsICdtc2QnXSxcbiAgW0NtY2RIZWFkZXJGaWVsZC5TVEFUVVNdOiBbJ2JzJywgJ2JzZCcsICdjZG4nLCAncnRwJywgJ2JnJywgJ3B0JywgJ2VjJywgJ2UnXVxufTtcblxuLyoqXG4gKiBTdHJ1Y3R1cmVkIEZpZWxkIEl0ZW1cbiAqXG4gKiBAZ3JvdXAgU3RydWN0dXJlZCBGaWVsZFxuICpcbiAqIEBiZXRhXG4gKi9cbmNsYXNzIFNmSXRlbSB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBwYXJhbXMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUubWFwKHYgPT4gdiBpbnN0YW5jZW9mIFNmSXRlbSA/IHYgOiBuZXcgU2ZJdGVtKHYpKTtcbiAgICB9XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICB9XG59XG5cbmNvbnN0IERJQ1QgPSAnRGljdCc7XG5cbmZ1bmN0aW9uIGZvcm1hdCh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICB9XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCkge1xuICAgIHJldHVybiAnTWFwe30nO1xuICB9XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgIHJldHVybiAnU2V0e30nO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgfVxuICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHRocm93RXJyb3IoYWN0aW9uLCBzcmMsIHR5cGUsIGNhdXNlKSB7XG4gIHJldHVybiBuZXcgRXJyb3IoYGZhaWxlZCB0byAke2FjdGlvbn0gXCIke2Zvcm1hdChzcmMpfVwiIGFzICR7dHlwZX1gLCB7XG4gICAgY2F1c2VcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZUVycm9yKHNyYywgdHlwZSwgY2F1c2UpIHtcbiAgcmV0dXJuIHRocm93RXJyb3IoJ3NlcmlhbGl6ZScsIHNyYywgdHlwZSwgY2F1c2UpO1xufVxuXG4vKipcbiAqIEEgY2xhc3MgdG8gcmVwcmVzZW50IHN0cnVjdHVyZWQgZmllbGQgdG9rZW5zIHdoZW4gYFN5bWJvbGAgaXMgbm90IGF2YWlsYWJsZS5cbiAqXG4gKiBAZ3JvdXAgU3RydWN0dXJlZCBGaWVsZFxuICpcbiAqIEBiZXRhXG4gKi9cbmNsYXNzIFNmVG9rZW4ge1xuICBjb25zdHJ1Y3RvcihkZXNjcmlwdGlvbikge1xuICAgIHRoaXMuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgfVxufVxuXG5jb25zdCBCQVJFX0lURU0gPSAnQmFyZSBJdGVtJztcblxuY29uc3QgQk9PTEVBTiA9ICdCb29sZWFuJztcblxuLy8gNC4xLjkuICBTZXJpYWxpemluZyBhIEJvb2xlYW5cbi8vXG4vLyBHaXZlbiBhIEJvb2xlYW4gYXMgaW5wdXRfYm9vbGVhbiwgcmV0dXJuIGFuIEFTQ0lJIHN0cmluZyBzdWl0YWJsZSBmb3Jcbi8vIHVzZSBpbiBhIEhUVFAgZmllbGQgdmFsdWUuXG4vL1xuLy8gMS4gIElmIGlucHV0X2Jvb2xlYW4gaXMgbm90IGEgYm9vbGVhbiwgZmFpbCBzZXJpYWxpemF0aW9uLlxuLy9cbi8vIDIuICBMZXQgb3V0cHV0IGJlIGFuIGVtcHR5IHN0cmluZy5cbi8vXG4vLyAzLiAgQXBwZW5kIFwiP1wiIHRvIG91dHB1dC5cbi8vXG4vLyA0LiAgSWYgaW5wdXRfYm9vbGVhbiBpcyB0cnVlLCBhcHBlbmQgXCIxXCIgdG8gb3V0cHV0LlxuLy9cbi8vIDUuICBJZiBpbnB1dF9ib29sZWFuIGlzIGZhbHNlLCBhcHBlbmQgXCIwXCIgdG8gb3V0cHV0LlxuLy9cbi8vIDYuICBSZXR1cm4gb3V0cHV0LlxuZnVuY3Rpb24gc2VyaWFsaXplQm9vbGVhbih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpIHtcbiAgICB0aHJvdyBzZXJpYWxpemVFcnJvcih2YWx1ZSwgQk9PTEVBTik7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID8gJz8xJyA6ICc/MCc7XG59XG5cbi8qKlxuICogRW5jb2RlcyBiaW5hcnkgZGF0YSB0byBiYXNlNjRcbiAqXG4gKiBAcGFyYW0gYmluYXJ5IC0gVGhlIGJpbmFyeSBkYXRhIHRvIGVuY29kZVxuICogQHJldHVybnMgVGhlIGJhc2U2NCBlbmNvZGVkIHN0cmluZ1xuICpcbiAqIEBncm91cCBVdGlsc1xuICpcbiAqIEBiZXRhXG4gKi9cbmZ1bmN0aW9uIGVuY29kZUJhc2U2NChiaW5hcnkpIHtcbiAgcmV0dXJuIGJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZSguLi5iaW5hcnkpKTtcbn1cblxuY29uc3QgQllURVMgPSAnQnl0ZSBTZXF1ZW5jZSc7XG5cbi8vIDQuMS44LiAgU2VyaWFsaXppbmcgYSBCeXRlIFNlcXVlbmNlXG4vL1xuLy8gR2l2ZW4gYSBCeXRlIFNlcXVlbmNlIGFzIGlucHV0X2J5dGVzLCByZXR1cm4gYW4gQVNDSUkgc3RyaW5nIHN1aXRhYmxlXG4vLyBmb3IgdXNlIGluIGEgSFRUUCBmaWVsZCB2YWx1ZS5cbi8vXG4vLyAxLiAgSWYgaW5wdXRfYnl0ZXMgaXMgbm90IGEgc2VxdWVuY2Ugb2YgYnl0ZXMsIGZhaWwgc2VyaWFsaXphdGlvbi5cbi8vXG4vLyAyLiAgTGV0IG91dHB1dCBiZSBhbiBlbXB0eSBzdHJpbmcuXG4vL1xuLy8gMy4gIEFwcGVuZCBcIjpcIiB0byBvdXRwdXQuXG4vL1xuLy8gNC4gIEFwcGVuZCB0aGUgcmVzdWx0IG9mIGJhc2U2NC1lbmNvZGluZyBpbnB1dF9ieXRlcyBhcyBwZXJcbi8vICAgICBbUkZDNDY0OF0sIFNlY3Rpb24gNCwgdGFraW5nIGFjY291bnQgb2YgdGhlIHJlcXVpcmVtZW50cyBiZWxvdy5cbi8vXG4vLyA1LiAgQXBwZW5kIFwiOlwiIHRvIG91dHB1dC5cbi8vXG4vLyA2LiAgUmV0dXJuIG91dHB1dC5cbi8vXG4vLyBUaGUgZW5jb2RlZCBkYXRhIGlzIHJlcXVpcmVkIHRvIGJlIHBhZGRlZCB3aXRoIFwiPVwiLCBhcyBwZXIgW1JGQzQ2NDhdLFxuLy8gU2VjdGlvbiAzLjIuXG4vL1xuLy8gTGlrZXdpc2UsIGVuY29kZWQgZGF0YSBTSE9VTEQgaGF2ZSBwYWQgYml0cyBzZXQgdG8gemVybywgYXMgcGVyXG4vLyBbUkZDNDY0OF0sIFNlY3Rpb24gMy41LCB1bmxlc3MgaXQgaXMgbm90IHBvc3NpYmxlIHRvIGRvIHNvIGR1ZSB0b1xuLy8gaW1wbGVtZW50YXRpb24gY29uc3RyYWludHMuXG5mdW5jdGlvbiBzZXJpYWxpemVCeXRlU2VxdWVuY2UodmFsdWUpIHtcbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgc2VyaWFsaXplRXJyb3IodmFsdWUsIEJZVEVTKTtcbiAgfVxuICByZXR1cm4gYDoke2VuY29kZUJhc2U2NCh2YWx1ZSl9OmA7XG59XG5cbmNvbnN0IElOVEVHRVIgPSAnSW50ZWdlcic7XG5cbmZ1bmN0aW9uIGlzSW52YWxpZEludCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPCAtOTk5OTk5OTk5OTk5OTk5IHx8IDk5OTk5OTk5OTk5OTk5OSA8IHZhbHVlO1xufVxuXG4vLyA0LjEuNC4gIFNlcmlhbGl6aW5nIGFuIEludGVnZXJcbi8vXG4vLyBHaXZlbiBhbiBJbnRlZ2VyIGFzIGlucHV0X2ludGVnZXIsIHJldHVybiBhbiBBU0NJSSBzdHJpbmcgc3VpdGFibGVcbi8vIGZvciB1c2UgaW4gYSBIVFRQIGZpZWxkIHZhbHVlLlxuLy9cbi8vIDEuICBJZiBpbnB1dF9pbnRlZ2VyIGlzIG5vdCBhbiBpbnRlZ2VyIGluIHRoZSByYW5nZSBvZlxuLy8gICAgIC05OTksOTk5LDk5OSw5OTksOTk5IHRvIDk5OSw5OTksOTk5LDk5OSw5OTkgaW5jbHVzaXZlLCBmYWlsXG4vLyAgICAgc2VyaWFsaXphdGlvbi5cbi8vXG4vLyAyLiAgTGV0IG91dHB1dCBiZSBhbiBlbXB0eSBzdHJpbmcuXG4vL1xuLy8gMy4gIElmIGlucHV0X2ludGVnZXIgaXMgbGVzcyB0aGFuIChidXQgbm90IGVxdWFsIHRvKSAwLCBhcHBlbmQgXCItXCIgdG9cbi8vICAgICBvdXRwdXQuXG4vL1xuLy8gNC4gIEFwcGVuZCBpbnB1dF9pbnRlZ2VyJ3MgbnVtZXJpYyB2YWx1ZSByZXByZXNlbnRlZCBpbiBiYXNlIDEwIHVzaW5nXG4vLyAgICAgb25seSBkZWNpbWFsIGRpZ2l0cyB0byBvdXRwdXQuXG4vL1xuLy8gNS4gIFJldHVybiBvdXRwdXQuXG5mdW5jdGlvbiBzZXJpYWxpemVJbnRlZ2VyKHZhbHVlKSB7XG4gIGlmIChpc0ludmFsaWRJbnQodmFsdWUpKSB7XG4gICAgdGhyb3cgc2VyaWFsaXplRXJyb3IodmFsdWUsIElOVEVHRVIpO1xuICB9XG4gIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xufVxuXG4vLyA0LjEuMTAuICBTZXJpYWxpemluZyBhIERhdGVcbi8vXG4vLyBHaXZlbiBhIERhdGUgYXMgaW5wdXRfaW50ZWdlciwgcmV0dXJuIGFuIEFTQ0lJIHN0cmluZyBzdWl0YWJsZSBmb3Jcbi8vIHVzZSBpbiBhbiBIVFRQIGZpZWxkIHZhbHVlLlxuLy8gMS4gIExldCBvdXRwdXQgYmUgXCJAXCIuXG4vLyAyLiAgQXBwZW5kIHRvIG91dHB1dCB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgU2VyaWFsaXppbmcgYW4gSW50ZWdlclxuLy8gICAgIHdpdGggaW5wdXRfZGF0ZSAoU2VjdGlvbiA0LjEuNCkuXG4vLyAzLiAgUmV0dXJuIG91dHB1dC5cbmZ1bmN0aW9uIHNlcmlhbGl6ZURhdGUodmFsdWUpIHtcbiAgcmV0dXJuIGBAJHtzZXJpYWxpemVJbnRlZ2VyKHZhbHVlLmdldFRpbWUoKSAvIDEwMDApfWA7XG59XG5cbi8qKlxuICogVGhpcyBpbXBsZW1lbnRzIHRoZSByb3VuZGluZyBwcm9jZWR1cmUgZGVzY3JpYmVkIGluIHN0ZXAgMiBvZiB0aGUgXCJTZXJpYWxpemluZyBhIERlY2ltYWxcIiBzcGVjaWZpY2F0aW9uLlxuICogVGhpcyByb3VuZGluZyBzdHlsZSBpcyBrbm93biBhcyBcImV2ZW4gcm91bmRpbmdcIiwgXCJiYW5rZXIncyByb3VuZGluZ1wiLCBvciBcImNvbW1lcmNpYWwgcm91bmRpbmdcIi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gcm91bmRcbiAqIEBwYXJhbSBwcmVjaXNpb24gLSBUaGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRvIHJvdW5kIHRvXG4gKiBAcmV0dXJucyBUaGUgcm91bmRlZCB2YWx1ZVxuICpcbiAqIEBncm91cCBVdGlsc1xuICpcbiAqIEBiZXRhXG4gKi9cbmZ1bmN0aW9uIHJvdW5kVG9FdmVuKHZhbHVlLCBwcmVjaXNpb24pIHtcbiAgaWYgKHZhbHVlIDwgMCkge1xuICAgIHJldHVybiAtcm91bmRUb0V2ZW4oLXZhbHVlLCBwcmVjaXNpb24pO1xuICB9XG4gIGNvbnN0IGRlY2ltYWxTaGlmdCA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24pO1xuICBjb25zdCBpc0VxdWlkaXN0YW50ID0gTWF0aC5hYnModmFsdWUgKiBkZWNpbWFsU2hpZnQgJSAxIC0gMC41KSA8IE51bWJlci5FUFNJTE9OO1xuICBpZiAoaXNFcXVpZGlzdGFudCkge1xuICAgIC8vIElmIHRoZSB0YWlsIG9mIHRoZSBkZWNpbWFsIHBsYWNlIGlzICdlcXVpZGlzdGFudCcgd2Ugcm91bmQgdG8gdGhlIG5lYXJlc3QgZXZlbiB2YWx1ZVxuICAgIGNvbnN0IGZsb29yZWRWYWx1ZSA9IE1hdGguZmxvb3IodmFsdWUgKiBkZWNpbWFsU2hpZnQpO1xuICAgIHJldHVybiAoZmxvb3JlZFZhbHVlICUgMiA9PT0gMCA/IGZsb29yZWRWYWx1ZSA6IGZsb29yZWRWYWx1ZSArIDEpIC8gZGVjaW1hbFNoaWZ0O1xuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZSwgcHJvY2VlZCBhcyBub3JtYWxcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIGRlY2ltYWxTaGlmdCkgLyBkZWNpbWFsU2hpZnQ7XG4gIH1cbn1cblxuY29uc3QgREVDSU1BTCA9ICdEZWNpbWFsJztcblxuLy8gNC4xLjUuICBTZXJpYWxpemluZyBhIERlY2ltYWxcbi8vXG4vLyBHaXZlbiBhIGRlY2ltYWwgbnVtYmVyIGFzIGlucHV0X2RlY2ltYWwsIHJldHVybiBhbiBBU0NJSSBzdHJpbmdcbi8vIHN1aXRhYmxlIGZvciB1c2UgaW4gYSBIVFRQIGZpZWxkIHZhbHVlLlxuLy9cbi8vIDEuICAgSWYgaW5wdXRfZGVjaW1hbCBpcyBub3QgYSBkZWNpbWFsIG51bWJlciwgZmFpbCBzZXJpYWxpemF0aW9uLlxuLy9cbi8vIDIuICAgSWYgaW5wdXRfZGVjaW1hbCBoYXMgbW9yZSB0aGFuIHRocmVlIHNpZ25pZmljYW50IGRpZ2l0cyB0byB0aGVcbi8vICAgICAgcmlnaHQgb2YgdGhlIGRlY2ltYWwgcG9pbnQsIHJvdW5kIGl0IHRvIHRocmVlIGRlY2ltYWwgcGxhY2VzLFxuLy8gICAgICByb3VuZGluZyB0aGUgZmluYWwgZGlnaXQgdG8gdGhlIG5lYXJlc3QgdmFsdWUsIG9yIHRvIHRoZSBldmVuXG4vLyAgICAgIHZhbHVlIGlmIGl0IGlzIGVxdWlkaXN0YW50LlxuLy9cbi8vIDMuICAgSWYgaW5wdXRfZGVjaW1hbCBoYXMgbW9yZSB0aGFuIDEyIHNpZ25pZmljYW50IGRpZ2l0cyB0byB0aGUgbGVmdFxuLy8gICAgICBvZiB0aGUgZGVjaW1hbCBwb2ludCBhZnRlciByb3VuZGluZywgZmFpbCBzZXJpYWxpemF0aW9uLlxuLy9cbi8vIDQuICAgTGV0IG91dHB1dCBiZSBhbiBlbXB0eSBzdHJpbmcuXG4vL1xuLy8gNS4gICBJZiBpbnB1dF9kZWNpbWFsIGlzIGxlc3MgdGhhbiAoYnV0IG5vdCBlcXVhbCB0bykgMCwgYXBwZW5kIFwiLVwiXG4vLyAgICAgIHRvIG91dHB1dC5cbi8vXG4vLyA2LiAgIEFwcGVuZCBpbnB1dF9kZWNpbWFsJ3MgaW50ZWdlciBjb21wb25lbnQgcmVwcmVzZW50ZWQgaW4gYmFzZSAxMFxuLy8gICAgICAodXNpbmcgb25seSBkZWNpbWFsIGRpZ2l0cykgdG8gb3V0cHV0OyBpZiBpdCBpcyB6ZXJvLCBhcHBlbmRcbi8vICAgICAgXCIwXCIuXG4vL1xuLy8gNy4gICBBcHBlbmQgXCIuXCIgdG8gb3V0cHV0LlxuLy9cbi8vIDguICAgSWYgaW5wdXRfZGVjaW1hbCdzIGZyYWN0aW9uYWwgY29tcG9uZW50IGlzIHplcm8sIGFwcGVuZCBcIjBcIiB0b1xuLy8gICAgICBvdXRwdXQuXG4vL1xuLy8gOS4gICBPdGhlcndpc2UsIGFwcGVuZCB0aGUgc2lnbmlmaWNhbnQgZGlnaXRzIG9mIGlucHV0X2RlY2ltYWwnc1xuLy8gICAgICBmcmFjdGlvbmFsIGNvbXBvbmVudCByZXByZXNlbnRlZCBpbiBiYXNlIDEwICh1c2luZyBvbmx5IGRlY2ltYWxcbi8vICAgICAgZGlnaXRzKSB0byBvdXRwdXQuXG4vL1xuLy8gMTAuICBSZXR1cm4gb3V0cHV0LlxuZnVuY3Rpb24gc2VyaWFsaXplRGVjaW1hbCh2YWx1ZSkge1xuICBjb25zdCByb3VuZGVkVmFsdWUgPSByb3VuZFRvRXZlbih2YWx1ZSwgMyk7IC8vIHJvdW5kIHRvIDMgZGVjaW1hbCBwbGFjZXNcbiAgaWYgKE1hdGguZmxvb3IoTWF0aC5hYnMocm91bmRlZFZhbHVlKSkudG9TdHJpbmcoKS5sZW5ndGggPiAxMikge1xuICAgIHRocm93IHNlcmlhbGl6ZUVycm9yKHZhbHVlLCBERUNJTUFMKTtcbiAgfVxuICBjb25zdCBzdHJpbmdWYWx1ZSA9IHJvdW5kZWRWYWx1ZS50b1N0cmluZygpO1xuICByZXR1cm4gc3RyaW5nVmFsdWUuaW5jbHVkZXMoJy4nKSA/IHN0cmluZ1ZhbHVlIDogYCR7c3RyaW5nVmFsdWV9LjBgO1xufVxuXG5jb25zdCBTVFJJTkcgPSAnU3RyaW5nJztcblxuY29uc3QgU1RSSU5HX1JFR0VYID0gL1tcXHgwMC1cXHgxZlxceDdmXSsvO1xuXG4vLyA0LjEuNi4gIFNlcmlhbGl6aW5nIGEgU3RyaW5nXG4vL1xuLy8gR2l2ZW4gYSBTdHJpbmcgYXMgaW5wdXRfc3RyaW5nLCByZXR1cm4gYW4gQVNDSUkgc3RyaW5nIHN1aXRhYmxlIGZvclxuLy8gdXNlIGluIGEgSFRUUCBmaWVsZCB2YWx1ZS5cbi8vXG4vLyAxLiAgQ29udmVydCBpbnB1dF9zdHJpbmcgaW50byBhIHNlcXVlbmNlIG9mIEFTQ0lJIGNoYXJhY3RlcnM7IGlmXG4vLyAgICAgY29udmVyc2lvbiBmYWlscywgZmFpbCBzZXJpYWxpemF0aW9uLlxuLy9cbi8vIDIuICBJZiBpbnB1dF9zdHJpbmcgY29udGFpbnMgY2hhcmFjdGVycyBpbiB0aGUgcmFuZ2UgJXgwMC0xZiBvciAleDdmXG4vLyAgICAgKGkuZS4sIG5vdCBpbiBWQ0hBUiBvciBTUCksIGZhaWwgc2VyaWFsaXphdGlvbi5cbi8vXG4vLyAzLiAgTGV0IG91dHB1dCBiZSB0aGUgc3RyaW5nIERRVU9URS5cbi8vXG4vLyA0LiAgRm9yIGVhY2ggY2hhcmFjdGVyIGNoYXIgaW4gaW5wdXRfc3RyaW5nOlxuLy9cbi8vICAgICAxLiAgSWYgY2hhciBpcyBcIlxcXCIgb3IgRFFVT1RFOlxuLy9cbi8vICAgICAgICAgMS4gIEFwcGVuZCBcIlxcXCIgdG8gb3V0cHV0LlxuLy9cbi8vICAgICAyLiAgQXBwZW5kIGNoYXIgdG8gb3V0cHV0LlxuLy9cbi8vIDUuICBBcHBlbmQgRFFVT1RFIHRvIG91dHB1dC5cbi8vXG4vLyA2LiAgUmV0dXJuIG91dHB1dC5cbmZ1bmN0aW9uIHNlcmlhbGl6ZVN0cmluZyh2YWx1ZSkge1xuICBpZiAoU1RSSU5HX1JFR0VYLnRlc3QodmFsdWUpKSB7XG4gICAgdGhyb3cgc2VyaWFsaXplRXJyb3IodmFsdWUsIFNUUklORyk7XG4gIH1cbiAgcmV0dXJuIGBcIiR7dmFsdWUucmVwbGFjZSgvXFxcXC9nLCBgXFxcXFxcXFxgKS5yZXBsYWNlKC9cIi9nLCBgXFxcXFwiYCl9XCJgO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgc3ltYm9sIHRvIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBzeW1ib2wgLSBUaGUgc3ltYm9sIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybnMgVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgc3ltYm9sLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBzeW1ib2xUb1N0cihzeW1ib2wpIHtcbiAgcmV0dXJuIHN5bWJvbC5kZXNjcmlwdGlvbiB8fCBzeW1ib2wudG9TdHJpbmcoKS5zbGljZSg3LCAtMSk7XG59XG5cbmNvbnN0IFRPS0VOID0gJ1Rva2VuJztcblxuZnVuY3Rpb24gc2VyaWFsaXplVG9rZW4odG9rZW4pIHtcbiAgY29uc3QgdmFsdWUgPSBzeW1ib2xUb1N0cih0b2tlbik7XG4gIGlmICgvXihbYS16QS1aKl0pKFshIyQlJicqK1xcLS5eX2B8flxcdzovXSopJC8udGVzdCh2YWx1ZSkgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgc2VyaWFsaXplRXJyb3IodmFsdWUsIFRPS0VOKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIDQuMS4zLjEuICBTZXJpYWxpemluZyBhIEJhcmUgSXRlbVxuLy9cbi8vIEdpdmVuIGFuIEl0ZW0gYXMgaW5wdXRfaXRlbSwgcmV0dXJuIGFuIEFTQ0lJIHN0cmluZyBzdWl0YWJsZSBmb3IgdXNlXG4vLyBpbiBhIEhUVFAgZmllbGQgdmFsdWUuXG4vL1xuLy8gMS4gIElmIGlucHV0X2l0ZW0gaXMgYW4gSW50ZWdlciwgcmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZ1xuLy8gICAgIFNlcmlhbGl6aW5nIGFuIEludGVnZXIgKFNlY3Rpb24gNC4xLjQpIHdpdGggaW5wdXRfaXRlbS5cbi8vXG4vLyAyLiAgSWYgaW5wdXRfaXRlbSBpcyBhIERlY2ltYWwsIHJldHVybiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmdcbi8vICAgICBTZXJpYWxpemluZyBhIERlY2ltYWwgKFNlY3Rpb24gNC4xLjUpIHdpdGggaW5wdXRfaXRlbS5cbi8vXG4vLyAzLiAgSWYgaW5wdXRfaXRlbSBpcyBhIFN0cmluZywgcmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZ1xuLy8gICAgIFNlcmlhbGl6aW5nIGEgU3RyaW5nIChTZWN0aW9uIDQuMS42KSB3aXRoIGlucHV0X2l0ZW0uXG4vL1xuLy8gNC4gIElmIGlucHV0X2l0ZW0gaXMgYSBUb2tlbiwgcmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZ1xuLy8gICAgIFNlcmlhbGl6aW5nIGEgVG9rZW4gKFNlY3Rpb24gNC4xLjcpIHdpdGggaW5wdXRfaXRlbS5cbi8vXG4vLyA1LiAgSWYgaW5wdXRfaXRlbSBpcyBhIEJvb2xlYW4sIHJldHVybiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmdcbi8vICAgICBTZXJpYWxpemluZyBhIEJvb2xlYW4gKFNlY3Rpb24gNC4xLjkpIHdpdGggaW5wdXRfaXRlbS5cbi8vXG4vLyA2LiAgSWYgaW5wdXRfaXRlbSBpcyBhIEJ5dGUgU2VxdWVuY2UsIHJldHVybiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmdcbi8vICAgICBTZXJpYWxpemluZyBhIEJ5dGUgU2VxdWVuY2UgKFNlY3Rpb24gNC4xLjgpIHdpdGggaW5wdXRfaXRlbS5cbi8vXG4vLyA3LiAgSWYgaW5wdXRfaXRlbSBpcyBhIERhdGUsIHJldHVybiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgU2VyaWFsaXppbmdcbi8vICAgICBhIERhdGUgKFNlY3Rpb24gNC4xLjEwKSB3aXRoIGlucHV0X2l0ZW0uXG4vL1xuLy8gOC4gIE90aGVyd2lzZSwgZmFpbCBzZXJpYWxpemF0aW9uLlxuZnVuY3Rpb24gc2VyaWFsaXplQmFyZUl0ZW0odmFsdWUpIHtcbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgaWYgKCFpc0Zpbml0ZU51bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgc2VyaWFsaXplRXJyb3IodmFsdWUsIEJBUkVfSVRFTSk7XG4gICAgICB9XG4gICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZUludGVnZXIodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlcmlhbGl6ZURlY2ltYWwodmFsdWUpO1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gc2VyaWFsaXplU3RyaW5nKHZhbHVlKTtcbiAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgcmV0dXJuIHNlcmlhbGl6ZVRva2VuKHZhbHVlKTtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiBzZXJpYWxpemVCb29sZWFuKHZhbHVlKTtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplRGF0ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVCeXRlU2VxdWVuY2UodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2ZUb2tlbikge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplVG9rZW4odmFsdWUpO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBmYWlsXG4gICAgICB0aHJvdyBzZXJpYWxpemVFcnJvcih2YWx1ZSwgQkFSRV9JVEVNKTtcbiAgfVxufVxuXG5jb25zdCBLRVkgPSAnS2V5JztcblxuLy8gNC4xLjEuMy4gIFNlcmlhbGl6aW5nIGEgS2V5XG4vL1xuLy8gR2l2ZW4gYSBrZXkgYXMgaW5wdXRfa2V5LCByZXR1cm4gYW4gQVNDSUkgc3RyaW5nIHN1aXRhYmxlIGZvciB1c2UgaW5cbi8vIGEgSFRUUCBmaWVsZCB2YWx1ZS5cbi8vXG4vLyAxLiAgQ29udmVydCBpbnB1dF9rZXkgaW50byBhIHNlcXVlbmNlIG9mIEFTQ0lJIGNoYXJhY3RlcnM7IGlmXG4vLyAgICAgY29udmVyc2lvbiBmYWlscywgZmFpbCBzZXJpYWxpemF0aW9uLlxuLy9cbi8vIDIuICBJZiBpbnB1dF9rZXkgY29udGFpbnMgY2hhcmFjdGVycyBub3QgaW4gbGNhbHBoYSwgRElHSVQsIFwiX1wiLCBcIi1cIixcbi8vICAgICBcIi5cIiwgb3IgXCIqXCIgZmFpbCBzZXJpYWxpemF0aW9uLlxuLy9cbi8vIDMuICBJZiB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGlucHV0X2tleSBpcyBub3QgbGNhbHBoYSBvciBcIipcIiwgZmFpbFxuLy8gICAgIHNlcmlhbGl6YXRpb24uXG4vL1xuLy8gNC4gIExldCBvdXRwdXQgYmUgYW4gZW1wdHkgc3RyaW5nLlxuLy9cbi8vIDUuICBBcHBlbmQgaW5wdXRfa2V5IHRvIG91dHB1dC5cbi8vXG4vLyA2LiAgUmV0dXJuIG91dHB1dC5cbmZ1bmN0aW9uIHNlcmlhbGl6ZUtleSh2YWx1ZSkge1xuICBpZiAoL15bYS16Kl1bYS16MC05XFwtXy4qXSokLy50ZXN0KHZhbHVlKSA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBzZXJpYWxpemVFcnJvcih2YWx1ZSwgS0VZKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIDQuMS4xLjIuICBTZXJpYWxpemluZyBQYXJhbWV0ZXJzXG4vL1xuLy8gR2l2ZW4gYW4gb3JkZXJlZCBEaWN0aW9uYXJ5IGFzIGlucHV0X3BhcmFtZXRlcnMgKGVhY2ggbWVtYmVyIGhhdmluZyBhXG4vLyBwYXJhbV9uYW1lIGFuZCBhIHBhcmFtX3ZhbHVlKSwgcmV0dXJuIGFuIEFTQ0lJIHN0cmluZyBzdWl0YWJsZSBmb3Jcbi8vIHVzZSBpbiBhIEhUVFAgZmllbGQgdmFsdWUuXG4vL1xuLy8gMS4gIExldCBvdXRwdXQgYmUgYW4gZW1wdHkgc3RyaW5nLlxuLy9cbi8vIDIuICBGb3IgZWFjaCBwYXJhbV9uYW1lIHdpdGggYSB2YWx1ZSBvZiBwYXJhbV92YWx1ZSBpblxuLy8gICAgIGlucHV0X3BhcmFtZXRlcnM6XG4vL1xuLy8gICAgIDEuICBBcHBlbmQgXCI7XCIgdG8gb3V0cHV0LlxuLy9cbi8vICAgICAyLiAgQXBwZW5kIHRoZSByZXN1bHQgb2YgcnVubmluZyBTZXJpYWxpemluZyBhIEtleVxuLy8gICAgICAgICAoU2VjdGlvbiA0LjEuMS4zKSB3aXRoIHBhcmFtX25hbWUgdG8gb3V0cHV0LlxuLy9cbi8vICAgICAzLiAgSWYgcGFyYW1fdmFsdWUgaXMgbm90IEJvb2xlYW4gdHJ1ZTpcbi8vXG4vLyAgICAgICAgIDEuICBBcHBlbmQgXCI9XCIgdG8gb3V0cHV0LlxuLy9cbi8vICAgICAgICAgMi4gIEFwcGVuZCB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgU2VyaWFsaXppbmcgYSBiYXJlIEl0ZW1cbi8vICAgICAgICAgICAgIChTZWN0aW9uIDQuMS4zLjEpIHdpdGggcGFyYW1fdmFsdWUgdG8gb3V0cHV0LlxuLy9cbi8vIDMuICBSZXR1cm4gb3V0cHV0LlxuZnVuY3Rpb24gc2VyaWFsaXplUGFyYW1zKHBhcmFtcykge1xuICBpZiAocGFyYW1zID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHBhcmFtcykubWFwKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBgOyR7c2VyaWFsaXplS2V5KGtleSl9YDsgLy8gb21pdCB0cnVlXG4gICAgfVxuICAgIHJldHVybiBgOyR7c2VyaWFsaXplS2V5KGtleSl9PSR7c2VyaWFsaXplQmFyZUl0ZW0odmFsdWUpfWA7XG4gIH0pLmpvaW4oJycpO1xufVxuXG4vLyA0LjEuMy4gIFNlcmlhbGl6aW5nIGFuIEl0ZW1cbi8vXG4vLyBHaXZlbiBhbiBJdGVtIGFzIGJhcmVfaXRlbSBhbmQgUGFyYW1ldGVycyBhcyBpdGVtX3BhcmFtZXRlcnMsIHJldHVyblxuLy8gYW4gQVNDSUkgc3RyaW5nIHN1aXRhYmxlIGZvciB1c2UgaW4gYSBIVFRQIGZpZWxkIHZhbHVlLlxuLy9cbi8vIDEuICBMZXQgb3V0cHV0IGJlIGFuIGVtcHR5IHN0cmluZy5cbi8vXG4vLyAyLiAgQXBwZW5kIHRoZSByZXN1bHQgb2YgcnVubmluZyBTZXJpYWxpemluZyBhIEJhcmUgSXRlbVxuLy8gICAgIFNlY3Rpb24gNC4xLjMuMSB3aXRoIGJhcmVfaXRlbSB0byBvdXRwdXQuXG4vL1xuLy8gMy4gIEFwcGVuZCB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgU2VyaWFsaXppbmcgUGFyYW1ldGVyc1xuLy8gICAgIFNlY3Rpb24gNC4xLjEuMiB3aXRoIGl0ZW1fcGFyYW1ldGVycyB0byBvdXRwdXQuXG4vL1xuLy8gNC4gIFJldHVybiBvdXRwdXQuXG5mdW5jdGlvbiBzZXJpYWxpemVJdGVtKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNmSXRlbSkge1xuICAgIHJldHVybiBgJHtzZXJpYWxpemVCYXJlSXRlbSh2YWx1ZS52YWx1ZSl9JHtzZXJpYWxpemVQYXJhbXModmFsdWUucGFyYW1zKX1gO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzZXJpYWxpemVCYXJlSXRlbSh2YWx1ZSk7XG4gIH1cbn1cblxuLy8gNC4xLjEuMS4gIFNlcmlhbGl6aW5nIGFuIElubmVyIExpc3Rcbi8vXG4vLyBHaXZlbiBhbiBhcnJheSBvZiAobWVtYmVyX3ZhbHVlLCBwYXJhbWV0ZXJzKSB0dXBsZXMgYXMgaW5uZXJfbGlzdCxcbi8vIGFuZCBwYXJhbWV0ZXJzIGFzIGxpc3RfcGFyYW1ldGVycywgcmV0dXJuIGFuIEFTQ0lJIHN0cmluZyBzdWl0YWJsZVxuLy8gZm9yIHVzZSBpbiBhIEhUVFAgZmllbGQgdmFsdWUuXG4vL1xuLy8gMS4gIExldCBvdXRwdXQgYmUgdGhlIHN0cmluZyBcIihcIi5cbi8vXG4vLyAyLiAgRm9yIGVhY2ggKG1lbWJlcl92YWx1ZSwgcGFyYW1ldGVycykgb2YgaW5uZXJfbGlzdDpcbi8vXG4vLyAgICAgMS4gIEFwcGVuZCB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgU2VyaWFsaXppbmcgYW4gSXRlbVxuLy8gICAgICAgICAoU2VjdGlvbiA0LjEuMykgd2l0aCAobWVtYmVyX3ZhbHVlLCBwYXJhbWV0ZXJzKSB0byBvdXRwdXQuXG4vL1xuLy8gICAgIDIuICBJZiBtb3JlIHZhbHVlcyByZW1haW4gaW4gaW5uZXJfbGlzdCwgYXBwZW5kIGEgc2luZ2xlIFNQIHRvXG4vLyAgICAgICAgIG91dHB1dC5cbi8vXG4vLyAzLiAgQXBwZW5kIFwiKVwiIHRvIG91dHB1dC5cbi8vXG4vLyA0LiAgQXBwZW5kIHRoZSByZXN1bHQgb2YgcnVubmluZyBTZXJpYWxpemluZyBQYXJhbWV0ZXJzXG4vLyAgICAgKFNlY3Rpb24gNC4xLjEuMikgd2l0aCBsaXN0X3BhcmFtZXRlcnMgdG8gb3V0cHV0LlxuLy9cbi8vIDUuICBSZXR1cm4gb3V0cHV0LlxuZnVuY3Rpb24gc2VyaWFsaXplSW5uZXJMaXN0KHZhbHVlKSB7XG4gIHJldHVybiBgKCR7dmFsdWUudmFsdWUubWFwKHNlcmlhbGl6ZUl0ZW0pLmpvaW4oJyAnKX0pJHtzZXJpYWxpemVQYXJhbXModmFsdWUucGFyYW1zKX1gO1xufVxuXG4vLyA0LjEuMi4gIFNlcmlhbGl6aW5nIGEgRGljdGlvbmFyeVxuLy9cbi8vIEdpdmVuIGFuIG9yZGVyZWQgRGljdGlvbmFyeSBhcyBpbnB1dF9kaWN0aW9uYXJ5IChlYWNoIG1lbWJlciBoYXZpbmcgYVxuLy8gbWVtYmVyX25hbWUgYW5kIGEgdHVwbGUgdmFsdWUgb2YgKG1lbWJlcl92YWx1ZSwgcGFyYW1ldGVycykpLCByZXR1cm5cbi8vIGFuIEFTQ0lJIHN0cmluZyBzdWl0YWJsZSBmb3IgdXNlIGluIGEgSFRUUCBmaWVsZCB2YWx1ZS5cbi8vXG4vLyAxLiAgTGV0IG91dHB1dCBiZSBhbiBlbXB0eSBzdHJpbmcuXG4vL1xuLy8gMi4gIEZvciBlYWNoIG1lbWJlcl9uYW1lIHdpdGggYSB2YWx1ZSBvZiAobWVtYmVyX3ZhbHVlLCBwYXJhbWV0ZXJzKVxuLy8gICAgIGluIGlucHV0X2RpY3Rpb25hcnk6XG4vL1xuLy8gICAgIDEuICBBcHBlbmQgdGhlIHJlc3VsdCBvZiBydW5uaW5nIFNlcmlhbGl6aW5nIGEgS2V5XG4vLyAgICAgICAgIChTZWN0aW9uIDQuMS4xLjMpIHdpdGggbWVtYmVyJ3MgbWVtYmVyX25hbWUgdG8gb3V0cHV0LlxuLy9cbi8vICAgICAyLiAgSWYgbWVtYmVyX3ZhbHVlIGlzIEJvb2xlYW4gdHJ1ZTpcbi8vXG4vLyAgICAgICAgIDEuICBBcHBlbmQgdGhlIHJlc3VsdCBvZiBydW5uaW5nIFNlcmlhbGl6aW5nIFBhcmFtZXRlcnNcbi8vICAgICAgICAgICAgIChTZWN0aW9uIDQuMS4xLjIpIHdpdGggcGFyYW1ldGVycyB0byBvdXRwdXQuXG4vL1xuLy8gICAgIDMuICBPdGhlcndpc2U6XG4vL1xuLy8gICAgICAgICAxLiAgQXBwZW5kIFwiPVwiIHRvIG91dHB1dC5cbi8vXG4vLyAgICAgICAgIDIuICBJZiBtZW1iZXJfdmFsdWUgaXMgYW4gYXJyYXksIGFwcGVuZCB0aGUgcmVzdWx0IG9mIHJ1bm5pbmdcbi8vICAgICAgICAgICAgIFNlcmlhbGl6aW5nIGFuIElubmVyIExpc3QgKFNlY3Rpb24gNC4xLjEuMSkgd2l0aFxuLy8gICAgICAgICAgICAgKG1lbWJlcl92YWx1ZSwgcGFyYW1ldGVycykgdG8gb3V0cHV0LlxuLy9cbi8vICAgICAgICAgMy4gIE90aGVyd2lzZSwgYXBwZW5kIHRoZSByZXN1bHQgb2YgcnVubmluZyBTZXJpYWxpemluZyBhblxuLy8gICAgICAgICAgICAgSXRlbSAoU2VjdGlvbiA0LjEuMykgd2l0aCAobWVtYmVyX3ZhbHVlLCBwYXJhbWV0ZXJzKSB0b1xuLy8gICAgICAgICAgICAgb3V0cHV0LlxuLy9cbi8vICAgICA0LiAgSWYgbW9yZSBtZW1iZXJzIHJlbWFpbiBpbiBpbnB1dF9kaWN0aW9uYXJ5OlxuLy9cbi8vICAgICAgICAgMS4gIEFwcGVuZCBcIixcIiB0byBvdXRwdXQuXG4vL1xuLy8gICAgICAgICAyLiAgQXBwZW5kIGEgc2luZ2xlIFNQIHRvIG91dHB1dC5cbi8vXG4vLyAzLiAgUmV0dXJuIG91dHB1dC5cbmZ1bmN0aW9uIHNlcmlhbGl6ZURpY3QoZGljdCwgb3B0aW9ucyA9IHtcbiAgd2hpdGVzcGFjZTogdHJ1ZVxufSkge1xuICBpZiAodHlwZW9mIGRpY3QgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgc2VyaWFsaXplRXJyb3IoZGljdCwgRElDVCk7XG4gIH1cbiAgY29uc3QgZW50cmllcyA9IGRpY3QgaW5zdGFuY2VvZiBNYXAgPyBkaWN0LmVudHJpZXMoKSA6IE9iamVjdC5lbnRyaWVzKGRpY3QpO1xuICBjb25zdCBvcHRpb25hbFdoaXRlU3BhY2UgPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLndoaXRlc3BhY2UpID8gJyAnIDogJyc7XG4gIHJldHVybiBBcnJheS5mcm9tKGVudHJpZXMpLm1hcCgoW2tleSwgaXRlbV0pID0+IHtcbiAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFNmSXRlbSA9PT0gZmFsc2UpIHtcbiAgICAgIGl0ZW0gPSBuZXcgU2ZJdGVtKGl0ZW0pO1xuICAgIH1cbiAgICBsZXQgb3V0cHV0ID0gc2VyaWFsaXplS2V5KGtleSk7XG4gICAgaWYgKGl0ZW0udmFsdWUgPT09IHRydWUpIHtcbiAgICAgIG91dHB1dCArPSBzZXJpYWxpemVQYXJhbXMoaXRlbS5wYXJhbXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQgKz0gJz0nO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbS52YWx1ZSkpIHtcbiAgICAgICAgb3V0cHV0ICs9IHNlcmlhbGl6ZUlubmVyTGlzdChpdGVtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dCArPSBzZXJpYWxpemVJdGVtKGl0ZW0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9KS5qb2luKGAsJHtvcHRpb25hbFdoaXRlU3BhY2V9YCk7XG59XG5cbi8qKlxuICogRW5jb2RlIGFuIG9iamVjdCBpbnRvIGEgc3RydWN0dXJlZCBmaWVsZCBkaWN0aW9uYXJ5XG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHN0cnVjdHVyZWQgZmllbGQgZGljdGlvbmFyeSB0byBlbmNvZGVcbiAqIEBwYXJhbSBvcHRpb25zIC0gRW5jb2Rpbmcgb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zIFRoZSBzdHJ1Y3R1cmVkIGZpZWxkIHN0cmluZ1xuICpcbiAqIEBncm91cCBTdHJ1Y3R1cmVkIEZpZWxkXG4gKlxuICogQGJldGFcbiAqL1xuZnVuY3Rpb24gZW5jb2RlU2ZEaWN0KHZhbHVlLCBvcHRpb25zKSB7XG4gIHJldHVybiBzZXJpYWxpemVEaWN0KHZhbHVlLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGtleSBpcyBhIHRva2VuIGZpZWxkLlxuICpcbiAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IHRvIGNoZWNrLlxuICpcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUga2V5IGlzIGEgdG9rZW4gZmllbGQuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGlzVG9rZW5GaWVsZChrZXkpIHtcbiAgcmV0dXJuIFsnb3QnLCAnc2YnLCAnc3QnLCAnZScsICdzdGEnXS5pbmNsdWRlcyhrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgdmFsaWRcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBrZXkgaXMgYSB2YWx1ZSBpcyB2YWxpZC5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBpc0Zpbml0ZU51bWJlcih2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09ICcnICYmIHZhbHVlICE9PSBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgcmVsYXRpdmUgcGF0aCBmcm9tIGEgVVJMLlxuICpcbiAqIEBwYXJhbSB1cmwgLSBUaGUgZGVzdGluYXRpb24gVVJMXG4gKiBAcGFyYW0gYmFzZSAtIFRoZSBiYXNlIFVSTFxuICogQHJldHVybnMgVGhlIHJlbGF0aXZlIHBhdGhcbiAqXG4gKiBAZ3JvdXAgVXRpbHNcbiAqXG4gKiBAYmV0YVxuICovXG5mdW5jdGlvbiB1cmxUb1JlbGF0aXZlUGF0aCh1cmwsIGJhc2UpIHtcbiAgY29uc3QgdG8gPSBuZXcgVVJMKHVybCk7XG4gIGNvbnN0IGZyb20gPSBuZXcgVVJMKGJhc2UpO1xuICBpZiAodG8ub3JpZ2luICE9PSBmcm9tLm9yaWdpbikge1xuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgY29uc3QgdG9QYXRoID0gdG8ucGF0aG5hbWUuc3BsaXQoJy8nKS5zbGljZSgxKTtcbiAgY29uc3QgZnJvbVBhdGggPSBmcm9tLnBhdGhuYW1lLnNwbGl0KCcvJykuc2xpY2UoMSwgLTEpO1xuICAvLyByZW1vdmUgY29tbW9uIHBhcmVudHNcbiAgd2hpbGUgKHRvUGF0aFswXSA9PT0gZnJvbVBhdGhbMF0pIHtcbiAgICB0b1BhdGguc2hpZnQoKTtcbiAgICBmcm9tUGF0aC5zaGlmdCgpO1xuICB9XG4gIC8vIGFkZCBiYWNrIHBhdGhzXG4gIHdoaWxlIChmcm9tUGF0aC5sZW5ndGgpIHtcbiAgICBmcm9tUGF0aC5zaGlmdCgpO1xuICAgIHRvUGF0aC51bnNoaWZ0KCcuLicpO1xuICB9XG4gIHJldHVybiB0b1BhdGguam9pbignLycpO1xufVxuXG5jb25zdCB0b1JvdW5kZWQgPSB2YWx1ZSA9PiBNYXRoLnJvdW5kKHZhbHVlKTtcbmNvbnN0IHRvVXJsU2FmZSA9ICh2YWx1ZSwgb3B0aW9ucykgPT4ge1xuICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmJhc2VVcmwpIHtcbiAgICB2YWx1ZSA9IHVybFRvUmVsYXRpdmVQYXRoKHZhbHVlLCBvcHRpb25zLmJhc2VVcmwpO1xuICB9XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xufTtcbmNvbnN0IHRvSHVuZHJlZCA9IHZhbHVlID0+IHRvUm91bmRlZCh2YWx1ZSAvIDEwMCkgKiAxMDA7XG4vKipcbiAqIFRoZSBkZWZhdWx0IGZvcm1hdHRlcnMgZm9yIENNQ0QgdmFsdWVzLlxuICpcbiAqIEBncm91cCBDTUNEXG4gKlxuICogQGJldGFcbiAqL1xuY29uc3QgQ21jZEZvcm1hdHRlcnMgPSB7XG4gIC8qKlxuICAgKiBCaXRyYXRlIChrYnBzKSByb3VuZGVkIGludGVnZXJcbiAgICovXG4gIGJyOiB0b1JvdW5kZWQsXG4gIC8qKlxuICAgKiBEdXJhdGlvbiAobWlsbGlzZWNvbmRzKSByb3VuZGVkIGludGVnZXJcbiAgICovXG4gIGQ6IHRvUm91bmRlZCxcbiAgLyoqXG4gICAqIEJ1ZmZlciBMZW5ndGggKG1pbGxpc2Vjb25kcykgcm91bmRlZCBuZWFyZXN0IDEwMG1zXG4gICAqL1xuICBibDogdG9IdW5kcmVkLFxuICAvKipcbiAgICogRGVhZGxpbmUgKG1pbGxpc2Vjb25kcykgcm91bmRlZCBuZWFyZXN0IDEwMG1zXG4gICAqL1xuICBkbDogdG9IdW5kcmVkLFxuICAvKipcbiAgICogTWVhc3VyZWQgVGhyb3VnaHB1dCAoa2Jwcykgcm91bmRlZCBuZWFyZXN0IDEwMGticHNcbiAgICovXG4gIG10cDogdG9IdW5kcmVkLFxuICAvKipcbiAgICogTmV4dCBPYmplY3QgUmVxdWVzdCBVUkwgZW5jb2RlZFxuICAgKi9cbiAgbm9yOiB0b1VybFNhZmUsXG4gIC8qKlxuICAgKiBSZXF1ZXN0ZWQgbWF4aW11bSB0aHJvdWdocHV0IChrYnBzKSByb3VuZGVkIG5lYXJlc3QgMTAwa2Jwc1xuICAgKi9cbiAgcnRwOiB0b0h1bmRyZWQsXG4gIC8qKlxuICAgKiBUb3AgQml0cmF0ZSAoa2Jwcykgcm91bmRlZCBpbnRlZ2VyXG4gICAqL1xuICB0YjogdG9Sb3VuZGVkXG59O1xuXG4vKipcbiAqIEludGVybmFsIENNQ0QgcHJvY2Vzc2luZyBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gb2JqIC0gVGhlIENNQ0Qgb2JqZWN0IHRvIHByb2Nlc3MuXG4gKiBAcGFyYW0gbWFwIC0gVGhlIG1hcHBpbmcgZnVuY3Rpb24gdG8gdXNlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciBlbmNvZGluZy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBAZ3JvdXAgQ01DRFxuICovXG5mdW5jdGlvbiBwcm9jZXNzQ21jZChvYmosIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzdWx0cyA9IHt9O1xuICBpZiAob2JqID09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKS5zb3J0KCk7XG4gIGNvbnN0IGZvcm1hdHRlcnMgPSBfZXh0ZW5kcyh7fSwgQ21jZEZvcm1hdHRlcnMsIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5mb3JtYXR0ZXJzKTtcbiAgY29uc3QgZmlsdGVyID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmZpbHRlcjtcbiAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgaWYgKChmaWx0ZXIgPT09IG51bGwgfHwgZmlsdGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWx0ZXIoa2V5KSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB2YWx1ZSA9IG9ialtrZXldO1xuICAgIGNvbnN0IGZvcm1hdHRlciA9IGZvcm1hdHRlcnNba2V5XTtcbiAgICBpZiAoZm9ybWF0dGVyKSB7XG4gICAgICB2YWx1ZSA9IGZvcm1hdHRlcih2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8vIFZlcnNpb24gc2hvdWxkIG9ubHkgYmUgcmVwb3J0ZWQgaWYgbm90IGVxdWFsIHRvIDEuXG4gICAgaWYgKGtleSA9PT0gJ3YnICYmIHZhbHVlID09PSAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFBsYXliYWNrIHJhdGUgc2hvdWxkIG9ubHkgYmUgc2VudCBpZiBub3QgZXF1YWwgdG8gMS5cbiAgICBpZiAoa2V5ID09ICdwcicgJiYgdmFsdWUgPT09IDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gaWdub3JlIGludmFsaWQgdmFsdWVzXG4gICAgaWYgKCFpc1ZhbGlkKHZhbHVlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNUb2tlbkZpZWxkKGtleSkgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSBuZXcgU2ZUb2tlbih2YWx1ZSk7XG4gICAgfVxuICAgIHJlc3VsdHNba2V5XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbi8qKlxuICogRW5jb2RlIGEgQ01DRCBvYmplY3QgdG8gYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGNtY2QgLSBUaGUgQ01DRCBvYmplY3QgdG8gZW5jb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciBlbmNvZGluZy5cbiAqXG4gKiBAcmV0dXJucyBUaGUgZW5jb2RlZCBDTUNEIHN0cmluZy5cbiAqXG4gKiBAZ3JvdXAgQ01DRFxuICpcbiAqIEBiZXRhXG4gKi9cbmZ1bmN0aW9uIGVuY29kZUNtY2QoY21jZCwgb3B0aW9ucyA9IHt9KSB7XG4gIGlmICghY21jZCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICByZXR1cm4gZW5jb2RlU2ZEaWN0KHByb2Nlc3NDbWNkKGNtY2QsIG9wdGlvbnMpLCBfZXh0ZW5kcyh7XG4gICAgd2hpdGVzcGFjZTogZmFsc2VcbiAgfSwgb3B0aW9ucykpO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSBDTUNEIGRhdGEgb2JqZWN0IHRvIHJlcXVlc3QgaGVhZGVyc1xuICpcbiAqIEBwYXJhbSBjbWNkIC0gVGhlIENNQ0QgZGF0YSBvYmplY3QgdG8gY29udmVydC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgZW5jb2RpbmcgdGhlIENNQ0Qgb2JqZWN0LlxuICpcbiAqIEByZXR1cm5zIFRoZSBDTUNEIGhlYWRlciBzaGFyZHMuXG4gKlxuICogQGdyb3VwIENNQ0RcbiAqXG4gKiBAYmV0YVxuICovXG5mdW5jdGlvbiB0b0NtY2RIZWFkZXJzKGNtY2QsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgaWYgKCFjbWNkKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoY21jZCk7XG4gIGNvbnN0IGhlYWRlck1hcCA9IE9iamVjdC5lbnRyaWVzKENtY2RIZWFkZXJNYXApLmNvbmNhdChPYmplY3QuZW50cmllcygob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmN1c3RvbUhlYWRlck1hcCkgfHwge30pKTtcbiAgY29uc3Qgc2hhcmRzID0gZW50cmllcy5yZWR1Y2UoKGFjYywgZW50cnkpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IGVudHJ5O1xuICAgIGNvbnN0IGZpZWxkID0gKChfYSA9IGhlYWRlck1hcC5maW5kKGVudHJ5ID0+IGVudHJ5WzFdLmluY2x1ZGVzKGtleSkpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pIHx8IENtY2RIZWFkZXJGaWVsZC5SRVFVRVNUO1xuICAgIChfYiA9IGFjY1tmaWVsZF0pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGFjY1tmaWVsZF0gPSB7fTtcbiAgICBhY2NbZmllbGRdW2tleV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhzaGFyZHMpLnJlZHVjZSgoYWNjLCBbZmllbGQsIHZhbHVlXSkgPT4ge1xuICAgIGFjY1tmaWVsZF0gPSBlbmNvZGVDbWNkKHZhbHVlLCBvcHRpb25zKTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCByZXN1bHQpO1xufVxuXG4vKipcbiAqIEFwcGVuZCBDTUNEIHF1ZXJ5IGFyZ3MgdG8gYSBoZWFkZXIgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBoZWFkZXJzIC0gVGhlIGhlYWRlcnMgdG8gYXBwZW5kIHRvLlxuICogQHBhcmFtIGNtY2QgLSBUaGUgQ01DRCBvYmplY3QgdG8gYXBwZW5kLlxuICogQHBhcmFtIG9wdGlvbnMgLSBFbmNvZGUgb3B0aW9ucy5cbiAqXG4gKiBAcmV0dXJucyBUaGUgaGVhZGVycyB3aXRoIHRoZSBDTUNEIGhlYWRlciBzaGFyZHMgYXBwZW5kZWQuXG4gKlxuICogQGdyb3VwIENNQ0RcbiAqXG4gKiBAYmV0YVxuICovXG5mdW5jdGlvbiBhcHBlbmRDbWNkSGVhZGVycyhoZWFkZXJzLCBjbWNkLCBvcHRpb25zKSB7XG4gIHJldHVybiBfZXh0ZW5kcyhoZWFkZXJzLCB0b0NtY2RIZWFkZXJzKGNtY2QsIG9wdGlvbnMpKTtcbn1cblxuLyoqXG4gKiBDTUNEIHBhcmFtZXRlciBuYW1lLlxuICpcbiAqIEBncm91cCBDTUNEXG4gKlxuICogQGJldGFcbiAqL1xuY29uc3QgQ01DRF9QQVJBTSA9ICdDTUNEJztcblxuLyoqXG4gKiBDb252ZXJ0IGEgQ01DRCBkYXRhIG9iamVjdCB0byBhIHF1ZXJ5IGFyZy5cbiAqXG4gKiBAcGFyYW0gY21jZCAtIFRoZSBDTUNEIG9iamVjdCB0byBjb252ZXJ0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciBlbmNvZGluZyB0aGUgQ01DRCBvYmplY3QuXG4gKlxuICogQHJldHVybnMgVGhlIENNQ0QgcXVlcnkgYXJnLlxuICpcbiAqIEBncm91cCBDTUNEXG4gKlxuICogQGJldGFcbiAqL1xuZnVuY3Rpb24gdG9DbWNkUXVlcnkoY21jZCwgb3B0aW9ucyA9IHt9KSB7XG4gIGlmICghY21jZCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBjb25zdCBwYXJhbXMgPSBlbmNvZGVDbWNkKGNtY2QsIG9wdGlvbnMpO1xuICByZXR1cm4gYCR7Q01DRF9QQVJBTX09JHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zKX1gO1xufVxuXG5jb25zdCBSRUdFWCA9IC9DTUNEPVteJiNdKy87XG4vKipcbiAqIEFwcGVuZCBDTUNEIHF1ZXJ5IGFyZ3MgdG8gYSBVUkwuXG4gKlxuICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdG8gYXBwZW5kIHRvLlxuICogQHBhcmFtIGNtY2QgLSBUaGUgQ01DRCBvYmplY3QgdG8gYXBwZW5kLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciBlbmNvZGluZyB0aGUgQ01DRCBvYmplY3QuXG4gKlxuICogQHJldHVybnMgVGhlIFVSTCB3aXRoIHRoZSBDTUNEIHF1ZXJ5IGFyZ3MgYXBwZW5kZWQuXG4gKlxuICogQGdyb3VwIENNQ0RcbiAqXG4gKiBAYmV0YVxuICovXG5mdW5jdGlvbiBhcHBlbmRDbWNkUXVlcnkodXJsLCBjbWNkLCBvcHRpb25zKSB7XG4gIC8vIFRPRE86IFJlcGxhY2Ugd2l0aCBVUkxTZWFyY2hQYXJhbXMgb25jZSB3ZSBkcm9wIFNhZmFyaSA8IDEwLjEgJiBDaHJvbWUgPCA0OSBzdXBwb3J0LlxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVVJMU2VhcmNoUGFyYW1zXG4gIGNvbnN0IHF1ZXJ5ID0gdG9DbWNkUXVlcnkoY21jZCwgb3B0aW9ucyk7XG4gIGlmICghcXVlcnkpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIGlmIChSRUdFWC50ZXN0KHVybCkpIHtcbiAgICByZXR1cm4gdXJsLnJlcGxhY2UoUkVHRVgsIHF1ZXJ5KTtcbiAgfVxuICBjb25zdCBzZXBhcmF0b3IgPSB1cmwuaW5jbHVkZXMoJz8nKSA/ICcmJyA6ICc/JztcbiAgcmV0dXJuIGAke3VybH0ke3NlcGFyYXRvcn0ke3F1ZXJ5fWA7XG59XG5cbi8qKlxuICogQ29udHJvbGxlciB0byBkZWFsIHdpdGggQ29tbW9uIE1lZGlhIENsaWVudCBEYXRhIChDTUNEKVxuICogQHNlZSBodHRwczovL2Nkbi5jdGEudGVjaC9jdGEvbWVkaWEvbWVkaWEvcmVzb3VyY2VzL3N0YW5kYXJkcy9wZGZzL2N0YS01MDA0LWZpbmFsLnBkZlxuICovXG5jbGFzcyBDTUNEQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMubWVkaWEgPSB2b2lkIDA7XG4gICAgdGhpcy5zaWQgPSB2b2lkIDA7XG4gICAgdGhpcy5jaWQgPSB2b2lkIDA7XG4gICAgdGhpcy51c2VIZWFkZXJzID0gZmFsc2U7XG4gICAgdGhpcy5pbmNsdWRlS2V5cyA9IHZvaWQgMDtcbiAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5zdGFydmVkID0gZmFsc2U7XG4gICAgdGhpcy5idWZmZXJpbmcgPSB0cnVlO1xuICAgIHRoaXMuYXVkaW9CdWZmZXIgPSB2b2lkIDA7XG4gICAgdGhpcy52aWRlb0J1ZmZlciA9IHZvaWQgMDtcbiAgICB0aGlzLm9uV2FpdGluZyA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgIHRoaXMuc3RhcnZlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLmJ1ZmZlcmluZyA9IHRydWU7XG4gICAgfTtcbiAgICB0aGlzLm9uUGxheWluZyA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYnVmZmVyaW5nID0gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBcHBseSBDTUNEIGRhdGEgdG8gYSBtYW5pZmVzdCByZXF1ZXN0LlxuICAgICAqL1xuICAgIHRoaXMuYXBwbHlQbGF5bGlzdERhdGEgPSBjb250ZXh0ID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuYXBwbHkoY29udGV4dCwge1xuICAgICAgICAgIG90OiBDbWNkT2JqZWN0VHlwZS5NQU5JRkVTVCxcbiAgICAgICAgICBzdTogIXRoaXMuaW5pdGlhbGl6ZWRcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aGlzLmhscy5sb2dnZXIud2FybignQ291bGQgbm90IGdlbmVyYXRlIG1hbmlmZXN0IENNQ0QgZGF0YS4nLCBlcnJvcik7XG4gICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBcHBseSBDTUNEIGRhdGEgdG8gYSBzZWdtZW50IHJlcXVlc3RcbiAgICAgKi9cbiAgICB0aGlzLmFwcGx5RnJhZ21lbnREYXRhID0gY29udGV4dCA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZnJhZyxcbiAgICAgICAgICBwYXJ0XG4gICAgICAgIH0gPSBjb250ZXh0O1xuICAgICAgICBjb25zdCBsZXZlbCA9IHRoaXMuaGxzLmxldmVsc1tmcmFnLmxldmVsXTtcbiAgICAgICAgY29uc3Qgb3QgPSB0aGlzLmdldE9iamVjdFR5cGUoZnJhZyk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgZDogKHBhcnQgfHwgZnJhZykuZHVyYXRpb24gKiAxMDAwLFxuICAgICAgICAgIG90XG4gICAgICAgIH07XG4gICAgICAgIGlmIChvdCA9PT0gQ21jZE9iamVjdFR5cGUuVklERU8gfHwgb3QgPT09IENtY2RPYmplY3RUeXBlLkFVRElPIHx8IG90ID09IENtY2RPYmplY3RUeXBlLk1VWEVEKSB7XG4gICAgICAgICAgZGF0YS5iciA9IGxldmVsLmJpdHJhdGUgLyAxMDAwO1xuICAgICAgICAgIGRhdGEudGIgPSB0aGlzLmdldFRvcEJhbmR3aWR0aChvdCkgLyAxMDAwO1xuICAgICAgICAgIGRhdGEuYmwgPSB0aGlzLmdldEJ1ZmZlckxlbmd0aChvdCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV4dCA9IHBhcnQgPyB0aGlzLmdldE5leHRQYXJ0KHBhcnQpIDogdGhpcy5nZXROZXh0RnJhZyhmcmFnKTtcbiAgICAgICAgaWYgKG5leHQgIT0gbnVsbCAmJiBuZXh0LnVybCAmJiBuZXh0LnVybCAhPT0gZnJhZy51cmwpIHtcbiAgICAgICAgICBkYXRhLm5vciA9IG5leHQudXJsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXBwbHkoY29udGV4dCwgZGF0YSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aGlzLmhscy5sb2dnZXIud2FybignQ291bGQgbm90IGdlbmVyYXRlIHNlZ21lbnQgQ01DRCBkYXRhLicsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICBjb25zdCB7XG4gICAgICBjbWNkXG4gICAgfSA9IGNvbmZpZztcbiAgICBpZiAoY21jZCAhPSBudWxsKSB7XG4gICAgICBjb25maWcucExvYWRlciA9IHRoaXMuY3JlYXRlUGxheWxpc3RMb2FkZXIoKTtcbiAgICAgIGNvbmZpZy5mTG9hZGVyID0gdGhpcy5jcmVhdGVGcmFnbWVudExvYWRlcigpO1xuICAgICAgdGhpcy5zaWQgPSBjbWNkLnNlc3Npb25JZCB8fCBobHMuc2Vzc2lvbklkO1xuICAgICAgdGhpcy5jaWQgPSBjbWNkLmNvbnRlbnRJZDtcbiAgICAgIHRoaXMudXNlSGVhZGVycyA9IGNtY2QudXNlSGVhZGVycyA9PT0gdHJ1ZTtcbiAgICAgIHRoaXMuaW5jbHVkZUtleXMgPSBjbWNkLmluY2x1ZGVLZXlzO1xuICAgICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIH1cbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9ERVRBQ0hFRCwgdGhpcy5vbk1lZGlhRGV0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0NSRUFURUQsIHRoaXMub25CdWZmZXJDcmVhdGVkLCB0aGlzKTtcbiAgfVxuICB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfREVUQUNIRUQsIHRoaXMub25NZWRpYURldGFjaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfQ1JFQVRFRCwgdGhpcy5vbkJ1ZmZlckNyZWF0ZWQsIHRoaXMpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5vbk1lZGlhRGV0YWNoZWQoKTtcblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmhscyA9IHRoaXMuY29uZmlnID0gdGhpcy5hdWRpb0J1ZmZlciA9IHRoaXMudmlkZW9CdWZmZXIgPSBudWxsO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLm9uV2FpdGluZyA9IHRoaXMub25QbGF5aW5nID0gdGhpcy5tZWRpYSA9IG51bGw7XG4gIH1cbiAgb25NZWRpYUF0dGFjaGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgdGhpcy5tZWRpYS5hZGRFdmVudExpc3RlbmVyKCd3YWl0aW5nJywgdGhpcy5vbldhaXRpbmcpO1xuICAgIHRoaXMubWVkaWEuYWRkRXZlbnRMaXN0ZW5lcigncGxheWluZycsIHRoaXMub25QbGF5aW5nKTtcbiAgfVxuICBvbk1lZGlhRGV0YWNoZWQoKSB7XG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2FpdGluZycsIHRoaXMub25XYWl0aW5nKTtcbiAgICB0aGlzLm1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BsYXlpbmcnLCB0aGlzLm9uUGxheWluZyk7XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gIH1cbiAgb25CdWZmZXJDcmVhdGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF9kYXRhJHRyYWNrcyRhdWRpbywgX2RhdGEkdHJhY2tzJHZpZGVvO1xuICAgIHRoaXMuYXVkaW9CdWZmZXIgPSAoX2RhdGEkdHJhY2tzJGF1ZGlvID0gZGF0YS50cmFja3MuYXVkaW8pID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YSR0cmFja3MkYXVkaW8uYnVmZmVyO1xuICAgIHRoaXMudmlkZW9CdWZmZXIgPSAoX2RhdGEkdHJhY2tzJHZpZGVvID0gZGF0YS50cmFja3MudmlkZW8pID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YSR0cmFja3MkdmlkZW8uYnVmZmVyO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYmFzZWxpbmUgQ01DRCBkYXRhXG4gICAqL1xuICBjcmVhdGVEYXRhKCkge1xuICAgIHZhciBfdGhpcyRtZWRpYTtcbiAgICByZXR1cm4ge1xuICAgICAgdjogMSxcbiAgICAgIHNmOiBDbWNkU3RyZWFtaW5nRm9ybWF0LkhMUyxcbiAgICAgIHNpZDogdGhpcy5zaWQsXG4gICAgICBjaWQ6IHRoaXMuY2lkLFxuICAgICAgcHI6IChfdGhpcyRtZWRpYSA9IHRoaXMubWVkaWEpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRtZWRpYS5wbGF5YmFja1JhdGUsXG4gICAgICBtdHA6IHRoaXMuaGxzLmJhbmR3aWR0aEVzdGltYXRlIC8gMTAwMFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQXBwbHkgQ01DRCBkYXRhIHRvIGEgcmVxdWVzdC5cbiAgICovXG4gIGFwcGx5KGNvbnRleHQsIGRhdGEgPSB7fSkge1xuICAgIC8vIGFwcGx5IGJhc2VsaW5lIGRhdGFcbiAgICBfZXh0ZW5kcyhkYXRhLCB0aGlzLmNyZWF0ZURhdGEoKSk7XG4gICAgY29uc3QgaXNWaWRlbyA9IGRhdGEub3QgPT09IENtY2RPYmplY3RUeXBlLklOSVQgfHwgZGF0YS5vdCA9PT0gQ21jZE9iamVjdFR5cGUuVklERU8gfHwgZGF0YS5vdCA9PT0gQ21jZE9iamVjdFR5cGUuTVVYRUQ7XG4gICAgaWYgKHRoaXMuc3RhcnZlZCAmJiBpc1ZpZGVvKSB7XG4gICAgICBkYXRhLmJzID0gdHJ1ZTtcbiAgICAgIGRhdGEuc3UgPSB0cnVlO1xuICAgICAgdGhpcy5zdGFydmVkID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkYXRhLnN1ID09IG51bGwpIHtcbiAgICAgIGRhdGEuc3UgPSB0aGlzLmJ1ZmZlcmluZztcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBJbXBsZW1lbnQgcnRwLCBucnIsIGRsXG5cbiAgICBjb25zdCB7XG4gICAgICBpbmNsdWRlS2V5c1xuICAgIH0gPSB0aGlzO1xuICAgIGlmIChpbmNsdWRlS2V5cykge1xuICAgICAgZGF0YSA9IE9iamVjdC5rZXlzKGRhdGEpLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICAgICAgaW5jbHVkZUtleXMuaW5jbHVkZXMoa2V5KSAmJiAoYWNjW2tleV0gPSBkYXRhW2tleV0pO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSwge30pO1xuICAgIH1cbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgYmFzZVVybDogY29udGV4dC51cmxcbiAgICB9O1xuICAgIGlmICh0aGlzLnVzZUhlYWRlcnMpIHtcbiAgICAgIGlmICghY29udGV4dC5oZWFkZXJzKSB7XG4gICAgICAgIGNvbnRleHQuaGVhZGVycyA9IHt9O1xuICAgICAgfVxuICAgICAgYXBwZW5kQ21jZEhlYWRlcnMoY29udGV4dC5oZWFkZXJzLCBkYXRhLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC51cmwgPSBhcHBlbmRDbWNkUXVlcnkoY29udGV4dC51cmwsIGRhdGEsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICBnZXROZXh0RnJhZyhmcmFnbWVudCkge1xuICAgIHZhciBfdGhpcyRobHMkbGV2ZWxzJGZyYWc7XG4gICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gKF90aGlzJGhscyRsZXZlbHMkZnJhZyA9IHRoaXMuaGxzLmxldmVsc1tmcmFnbWVudC5sZXZlbF0pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRobHMkbGV2ZWxzJGZyYWcuZGV0YWlscztcbiAgICBpZiAobGV2ZWxEZXRhaWxzKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGZyYWdtZW50LnNuIC0gbGV2ZWxEZXRhaWxzLnN0YXJ0U047XG4gICAgICByZXR1cm4gbGV2ZWxEZXRhaWxzLmZyYWdtZW50c1tpbmRleCArIDFdO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGdldE5leHRQYXJ0KHBhcnQpIHtcbiAgICB2YXIgX3RoaXMkaGxzJGxldmVscyRmcmFnMiwgX3RoaXMkaGxzJGxldmVscyRmcmFnMztcbiAgICBjb25zdCB7XG4gICAgICBpbmRleCxcbiAgICAgIGZyYWdtZW50XG4gICAgfSA9IHBhcnQ7XG4gICAgY29uc3QgcGFydExpc3QgPSAoX3RoaXMkaGxzJGxldmVscyRmcmFnMiA9IHRoaXMuaGxzLmxldmVsc1tmcmFnbWVudC5sZXZlbF0pID09IG51bGwgPyB2b2lkIDAgOiAoX3RoaXMkaGxzJGxldmVscyRmcmFnMyA9IF90aGlzJGhscyRsZXZlbHMkZnJhZzIuZGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGhscyRsZXZlbHMkZnJhZzMucGFydExpc3Q7XG4gICAgaWYgKHBhcnRMaXN0KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNuXG4gICAgICB9ID0gZnJhZ21lbnQ7XG4gICAgICBmb3IgKGxldCBpID0gcGFydExpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgcCA9IHBhcnRMaXN0W2ldO1xuICAgICAgICBpZiAocC5pbmRleCA9PT0gaW5kZXggJiYgcC5mcmFnbWVudC5zbiA9PT0gc24pIHtcbiAgICAgICAgICByZXR1cm4gcGFydExpc3RbaSArIDFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIENNQ0Qgb2JqZWN0IHR5cGUuXG4gICAqL1xuICBnZXRPYmplY3RUeXBlKGZyYWdtZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gPSBmcmFnbWVudDtcbiAgICBpZiAodHlwZSA9PT0gJ3N1YnRpdGxlJykge1xuICAgICAgcmV0dXJuIENtY2RPYmplY3RUeXBlLlRJTUVEX1RFWFQ7XG4gICAgfVxuICAgIGlmIChmcmFnbWVudC5zbiA9PT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgcmV0dXJuIENtY2RPYmplY3RUeXBlLklOSVQ7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICByZXR1cm4gQ21jZE9iamVjdFR5cGUuQVVESU87XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnbWFpbicpIHtcbiAgICAgIGlmICghdGhpcy5obHMuYXVkaW9UcmFja3MubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBDbWNkT2JqZWN0VHlwZS5NVVhFRDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDbWNkT2JqZWN0VHlwZS5WSURFTztcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGhpZ2hlc3QgYml0cmF0ZS5cbiAgICovXG4gIGdldFRvcEJhbmR3aWR0aCh0eXBlKSB7XG4gICAgbGV0IGJpdHJhdGUgPSAwO1xuICAgIGxldCBsZXZlbHM7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgaWYgKHR5cGUgPT09IENtY2RPYmplY3RUeXBlLkFVRElPKSB7XG4gICAgICBsZXZlbHMgPSBobHMuYXVkaW9UcmFja3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1heCA9IGhscy5tYXhBdXRvTGV2ZWw7XG4gICAgICBjb25zdCBsZW4gPSBtYXggPiAtMSA/IG1heCArIDEgOiBobHMubGV2ZWxzLmxlbmd0aDtcbiAgICAgIGxldmVscyA9IGhscy5sZXZlbHMuc2xpY2UoMCwgbGVuKTtcbiAgICB9XG4gICAgbGV2ZWxzLmZvckVhY2gobGV2ZWwgPT4ge1xuICAgICAgaWYgKGxldmVsLmJpdHJhdGUgPiBiaXRyYXRlKSB7XG4gICAgICAgIGJpdHJhdGUgPSBsZXZlbC5iaXRyYXRlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBiaXRyYXRlID4gMCA/IGJpdHJhdGUgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBidWZmZXIgbGVuZ3RoIGZvciBhIG1lZGlhIHR5cGUgaW4gbWlsbGlzZWNvbmRzXG4gICAqL1xuICBnZXRCdWZmZXJMZW5ndGgodHlwZSkge1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBjb25zdCBidWZmZXIgPSB0eXBlID09PSBDbWNkT2JqZWN0VHlwZS5BVURJTyA/IHRoaXMuYXVkaW9CdWZmZXIgOiB0aGlzLnZpZGVvQnVmZmVyO1xuICAgIGlmICghYnVmZmVyIHx8ICFtZWRpYSkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgY29uc3QgaW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKGJ1ZmZlciwgbWVkaWEuY3VycmVudFRpbWUsIHRoaXMuY29uZmlnLm1heEJ1ZmZlckhvbGUpO1xuICAgIHJldHVybiBpbmZvLmxlbiAqIDEwMDA7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgcGxheWxpc3QgbG9hZGVyXG4gICAqL1xuICBjcmVhdGVQbGF5bGlzdExvYWRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBwTG9hZGVyXG4gICAgfSA9IHRoaXMuY29uZmlnO1xuICAgIGNvbnN0IGFwcGx5ID0gdGhpcy5hcHBseVBsYXlsaXN0RGF0YTtcbiAgICBjb25zdCBDdG9yID0gcExvYWRlciB8fCB0aGlzLmNvbmZpZy5sb2FkZXI7XG4gICAgcmV0dXJuIGNsYXNzIENtY2RQbGF5bGlzdExvYWRlciB7XG4gICAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdGhpcy5sb2FkZXIgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IEN0b3IoY29uZmlnKTtcbiAgICAgIH1cbiAgICAgIGdldCBzdGF0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZGVyLnN0YXRzO1xuICAgICAgfVxuICAgICAgZ2V0IGNvbnRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRlci5jb250ZXh0O1xuICAgICAgfVxuICAgICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5sb2FkZXIuZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgYWJvcnQoKSB7XG4gICAgICAgIHRoaXMubG9hZGVyLmFib3J0KCk7XG4gICAgICB9XG4gICAgICBsb2FkKGNvbnRleHQsIGNvbmZpZywgY2FsbGJhY2tzKSB7XG4gICAgICAgIGFwcGx5KGNvbnRleHQpO1xuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKGNvbnRleHQsIGNvbmZpZywgY2FsbGJhY2tzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHBsYXlsaXN0IGxvYWRlclxuICAgKi9cbiAgY3JlYXRlRnJhZ21lbnRMb2FkZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZkxvYWRlclxuICAgIH0gPSB0aGlzLmNvbmZpZztcbiAgICBjb25zdCBhcHBseSA9IHRoaXMuYXBwbHlGcmFnbWVudERhdGE7XG4gICAgY29uc3QgQ3RvciA9IGZMb2FkZXIgfHwgdGhpcy5jb25maWcubG9hZGVyO1xuICAgIHJldHVybiBjbGFzcyBDbWNkRnJhZ21lbnRMb2FkZXIge1xuICAgICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHRoaXMubG9hZGVyID0gdm9pZCAwO1xuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBDdG9yKGNvbmZpZyk7XG4gICAgICB9XG4gICAgICBnZXQgc3RhdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRlci5zdGF0cztcbiAgICAgIH1cbiAgICAgIGdldCBjb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkZXIuY29udGV4dDtcbiAgICAgIH1cbiAgICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMubG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIGFib3J0KCkge1xuICAgICAgICB0aGlzLmxvYWRlci5hYm9ydCgpO1xuICAgICAgfVxuICAgICAgbG9hZChjb250ZXh0LCBjb25maWcsIGNhbGxiYWNrcykge1xuICAgICAgICBhcHBseShjb250ZXh0KTtcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZChjb250ZXh0LCBjb25maWcsIGNhbGxiYWNrcyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuXG5jb25zdCBQQVRIV0FZX1BFTkFMVFlfRFVSQVRJT05fTVMgPSAzMDAwMDA7XG5jbGFzcyBDb250ZW50U3RlZXJpbmdDb250cm9sbGVyIGV4dGVuZHMgTG9nZ2VyIHtcbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgc3VwZXIoJ2NvbnRlbnQtc3RlZXJpbmcnLCBobHMubG9nZ2VyKTtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgdGhpcy51cmkgPSBudWxsO1xuICAgIHRoaXMucGF0aHdheUlkID0gJy4nO1xuICAgIHRoaXMuX3BhdGh3YXlQcmlvcml0eSA9IG51bGw7XG4gICAgdGhpcy50aW1lVG9Mb2FkID0gMzAwO1xuICAgIHRoaXMucmVsb2FkVGltZXIgPSAtMTtcbiAgICB0aGlzLnVwZGF0ZWQgPSAwO1xuICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5sZXZlbHMgPSBudWxsO1xuICAgIHRoaXMuYXVkaW9UcmFja3MgPSBudWxsO1xuICAgIHRoaXMuc3VidGl0bGVUcmFja3MgPSBudWxsO1xuICAgIHRoaXMucGVuYWxpemVkUGF0aHdheXMgPSB7fTtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURFRCwgdGhpcy5vbk1hbmlmZXN0TG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9XG4gIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgaWYgKCFobHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfVxuICBwYXRod2F5cygpIHtcbiAgICByZXR1cm4gKHRoaXMubGV2ZWxzIHx8IFtdKS5yZWR1Y2UoKHBhdGh3YXlzLCBsZXZlbCkgPT4ge1xuICAgICAgaWYgKHBhdGh3YXlzLmluZGV4T2YobGV2ZWwucGF0aHdheUlkKSA9PT0gLTEpIHtcbiAgICAgICAgcGF0aHdheXMucHVzaChsZXZlbC5wYXRod2F5SWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhdGh3YXlzO1xuICAgIH0sIFtdKTtcbiAgfVxuICBnZXQgcGF0aHdheVByaW9yaXR5KCkge1xuICAgIHJldHVybiB0aGlzLl9wYXRod2F5UHJpb3JpdHk7XG4gIH1cbiAgc2V0IHBhdGh3YXlQcmlvcml0eShwYXRod2F5UHJpb3JpdHkpIHtcbiAgICB0aGlzLnVwZGF0ZVBhdGh3YXlQcmlvcml0eShwYXRod2F5UHJpb3JpdHkpO1xuICB9XG4gIHN0YXJ0TG9hZCgpIHtcbiAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG4gICAgaWYgKHRoaXMuZW5hYmxlZCAmJiB0aGlzLnVyaSkge1xuICAgICAgaWYgKHRoaXMudXBkYXRlZCkge1xuICAgICAgICBjb25zdCB0dGwgPSB0aGlzLnRpbWVUb0xvYWQgKiAxMDAwIC0gKHBlcmZvcm1hbmNlLm5vdygpIC0gdGhpcy51cGRhdGVkKTtcbiAgICAgICAgaWYgKHR0bCA+IDApIHtcbiAgICAgICAgICB0aGlzLnNjaGVkdWxlUmVmcmVzaCh0aGlzLnVyaSwgdHRsKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubG9hZFN0ZWVyaW5nTWFuaWZlc3QodGhpcy51cmkpO1xuICAgIH1cbiAgfVxuICBzdG9wTG9hZCgpIHtcbiAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5sb2FkZXIpIHtcbiAgICAgIHRoaXMubG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgfVxuICBjbGVhclRpbWVvdXQoKSB7XG4gICAgaWYgKHRoaXMucmVsb2FkVGltZXIgIT09IC0xKSB7XG4gICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlbG9hZFRpbWVyKTtcbiAgICAgIHRoaXMucmVsb2FkVGltZXIgPSAtMTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuaGxzID0gbnVsbDtcbiAgICB0aGlzLmxldmVscyA9IHRoaXMuYXVkaW9UcmFja3MgPSB0aGlzLnN1YnRpdGxlVHJhY2tzID0gbnVsbDtcbiAgfVxuICByZW1vdmVMZXZlbChsZXZlbFRvUmVtb3ZlKSB7XG4gICAgY29uc3QgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG4gICAgaWYgKGxldmVscykge1xuICAgICAgdGhpcy5sZXZlbHMgPSBsZXZlbHMuZmlsdGVyKGxldmVsID0+IGxldmVsICE9PSBsZXZlbFRvUmVtb3ZlKTtcbiAgICB9XG4gIH1cbiAgb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy50aW1lVG9Mb2FkID0gMzAwO1xuICAgIHRoaXMudXBkYXRlZCA9IDA7XG4gICAgdGhpcy51cmkgPSBudWxsO1xuICAgIHRoaXMucGF0aHdheUlkID0gJy4nO1xuICAgIHRoaXMubGV2ZWxzID0gdGhpcy5hdWRpb1RyYWNrcyA9IHRoaXMuc3VidGl0bGVUcmFja3MgPSBudWxsO1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250ZW50U3RlZXJpbmdcbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoY29udGVudFN0ZWVyaW5nID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGF0aHdheUlkID0gY29udGVudFN0ZWVyaW5nLnBhdGh3YXlJZDtcbiAgICB0aGlzLnVyaSA9IGNvbnRlbnRTdGVlcmluZy51cmk7XG4gICAgaWYgKHRoaXMuc3RhcnRlZCkge1xuICAgICAgdGhpcy5zdGFydExvYWQoKTtcbiAgICB9XG4gIH1cbiAgb25NYW5pZmVzdFBhcnNlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMuYXVkaW9UcmFja3MgPSBkYXRhLmF1ZGlvVHJhY2tzO1xuICAgIHRoaXMuc3VidGl0bGVUcmFja3MgPSBkYXRhLnN1YnRpdGxlVHJhY2tzO1xuICB9XG4gIG9uRXJyb3IoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBlcnJvckFjdGlvblxuICAgIH0gPSBkYXRhO1xuICAgIGlmICgoZXJyb3JBY3Rpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yQWN0aW9uLmFjdGlvbikgPT09IE5ldHdvcmtFcnJvckFjdGlvbi5TZW5kQWx0ZXJuYXRlVG9QZW5hbHR5Qm94ICYmIGVycm9yQWN0aW9uLmZsYWdzID09PSBFcnJvckFjdGlvbkZsYWdzLk1vdmVBbGxBbHRlcm5hdGVzTWF0Y2hpbmdIb3N0KSB7XG4gICAgICBjb25zdCBsZXZlbHMgPSB0aGlzLmxldmVscztcbiAgICAgIGxldCBwYXRod2F5UHJpb3JpdHkgPSB0aGlzLl9wYXRod2F5UHJpb3JpdHk7XG4gICAgICBsZXQgZXJyb3JQYXRod2F5ID0gdGhpcy5wYXRod2F5SWQ7XG4gICAgICBpZiAoZGF0YS5jb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBncm91cElkLFxuICAgICAgICAgIHBhdGh3YXlJZCxcbiAgICAgICAgICB0eXBlXG4gICAgICAgIH0gPSBkYXRhLmNvbnRleHQ7XG4gICAgICAgIGlmIChncm91cElkICYmIGxldmVscykge1xuICAgICAgICAgIGVycm9yUGF0aHdheSA9IHRoaXMuZ2V0UGF0aHdheUZvckdyb3VwSWQoZ3JvdXBJZCwgdHlwZSwgZXJyb3JQYXRod2F5KTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXRod2F5SWQpIHtcbiAgICAgICAgICBlcnJvclBhdGh3YXkgPSBwYXRod2F5SWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghKGVycm9yUGF0aHdheSBpbiB0aGlzLnBlbmFsaXplZFBhdGh3YXlzKSkge1xuICAgICAgICB0aGlzLnBlbmFsaXplZFBhdGh3YXlzW2Vycm9yUGF0aHdheV0gPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIH1cbiAgICAgIGlmICghcGF0aHdheVByaW9yaXR5ICYmIGxldmVscykge1xuICAgICAgICAvLyBJZiBQQVRIV0FZLVBSSU9SSVRZIHdhcyBub3QgcHJvdmlkZWQsIGxpc3QgcGF0aHdheXMgZm9yIGVycm9yIGhhbmRsaW5nXG4gICAgICAgIHBhdGh3YXlQcmlvcml0eSA9IHRoaXMucGF0aHdheXMoKTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXRod2F5UHJpb3JpdHkgJiYgcGF0aHdheVByaW9yaXR5Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhpcy51cGRhdGVQYXRod2F5UHJpb3JpdHkocGF0aHdheVByaW9yaXR5KTtcbiAgICAgICAgZXJyb3JBY3Rpb24ucmVzb2x2ZWQgPSB0aGlzLnBhdGh3YXlJZCAhPT0gZXJyb3JQYXRod2F5O1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEuZGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRfRVJST1IgJiYgIWRhdGEuZmF0YWwpIHtcbiAgICAgICAgLy8gRXJyb3Igd2lsbCBiZWNvbWUgZmF0YWwgaW4gYnVmZmVyLWNvbnRyb2xsZXIgd2hlbiByZWFjaGluZyBgYXBwZW5kRXJyb3JNYXhSZXRyeWBcbiAgICAgICAgLy8gU3RyZWFtLWNvbnRyb2xsZXJzIGFyZSBleHBlY3RlZCB0byByZWR1Y2UgYnVmZmVyIGxlbmd0aCBldmVuIGlmIHRoaXMgaXMgbm90IGRlZW1lZCBhIFF1b3RhRXhjZWVkZWRFcnJvclxuICAgICAgICBlcnJvckFjdGlvbi5yZXNvbHZlZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKCFlcnJvckFjdGlvbi5yZXNvbHZlZCkge1xuICAgICAgICB0aGlzLndhcm4oYENvdWxkIG5vdCByZXNvbHZlICR7ZGF0YS5kZXRhaWxzfSAoXCIke2RhdGEuZXJyb3IubWVzc2FnZX1cIikgd2l0aCBjb250ZW50LXN0ZWVyaW5nIGZvciBQYXRod2F5OiAke2Vycm9yUGF0aHdheX0gbGV2ZWxzOiAke2xldmVscyA/IGxldmVscy5sZW5ndGggOiBsZXZlbHN9IHByaW9yaXRpZXM6ICR7c3RyaW5naWZ5KHBhdGh3YXlQcmlvcml0eSl9IHBlbmFsaXplZDogJHtzdHJpbmdpZnkodGhpcy5wZW5hbGl6ZWRQYXRod2F5cyl9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZpbHRlclBhcnNlZExldmVscyhsZXZlbHMpIHtcbiAgICAvLyBGaWx0ZXIgbGV2ZWxzIHRvIG9ubHkgaW5jbHVkZSB0aG9zZSB0aGF0IGFyZSBpbiB0aGUgaW5pdGlhbCBwYXRod2F5XG4gICAgdGhpcy5sZXZlbHMgPSBsZXZlbHM7XG4gICAgbGV0IHBhdGh3YXlMZXZlbHMgPSB0aGlzLmdldExldmVsc0ZvclBhdGh3YXkodGhpcy5wYXRod2F5SWQpO1xuICAgIGlmIChwYXRod2F5TGV2ZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc3QgcGF0aHdheUlkID0gbGV2ZWxzWzBdLnBhdGh3YXlJZDtcbiAgICAgIHRoaXMubG9nKGBObyBsZXZlbHMgZm91bmQgaW4gUGF0aHdheSAke3RoaXMucGF0aHdheUlkfS4gU2V0dGluZyBpbml0aWFsIFBhdGh3YXkgdG8gXCIke3BhdGh3YXlJZH1cImApO1xuICAgICAgcGF0aHdheUxldmVscyA9IHRoaXMuZ2V0TGV2ZWxzRm9yUGF0aHdheShwYXRod2F5SWQpO1xuICAgICAgdGhpcy5wYXRod2F5SWQgPSBwYXRod2F5SWQ7XG4gICAgfVxuICAgIGlmIChwYXRod2F5TGV2ZWxzLmxlbmd0aCAhPT0gbGV2ZWxzLmxlbmd0aCkge1xuICAgICAgdGhpcy5sb2coYEZvdW5kICR7cGF0aHdheUxldmVscy5sZW5ndGh9LyR7bGV2ZWxzLmxlbmd0aH0gbGV2ZWxzIGluIFBhdGh3YXkgXCIke3RoaXMucGF0aHdheUlkfVwiYCk7XG4gICAgfVxuICAgIHJldHVybiBwYXRod2F5TGV2ZWxzO1xuICB9XG4gIGdldExldmVsc0ZvclBhdGh3YXkocGF0aHdheUlkKSB7XG4gICAgaWYgKHRoaXMubGV2ZWxzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxldmVscy5maWx0ZXIobGV2ZWwgPT4gcGF0aHdheUlkID09PSBsZXZlbC5wYXRod2F5SWQpO1xuICB9XG4gIHVwZGF0ZVBhdGh3YXlQcmlvcml0eShwYXRod2F5UHJpb3JpdHkpIHtcbiAgICB0aGlzLl9wYXRod2F5UHJpb3JpdHkgPSBwYXRod2F5UHJpb3JpdHk7XG4gICAgbGV0IGxldmVscztcblxuICAgIC8vIEV2YWx1YXRlIGlmIHdlIHNob3VsZCByZW1vdmUgdGhlIHBhdGh3YXkgZnJvbSB0aGUgcGVuYWxpemVkIGxpc3RcbiAgICBjb25zdCBwZW5hbGl6ZWRQYXRod2F5cyA9IHRoaXMucGVuYWxpemVkUGF0aHdheXM7XG4gICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgT2JqZWN0LmtleXMocGVuYWxpemVkUGF0aHdheXMpLmZvckVhY2gocGF0aHdheUlkID0+IHtcbiAgICAgIGlmIChub3cgLSBwZW5hbGl6ZWRQYXRod2F5c1twYXRod2F5SWRdID4gUEFUSFdBWV9QRU5BTFRZX0RVUkFUSU9OX01TKSB7XG4gICAgICAgIGRlbGV0ZSBwZW5hbGl6ZWRQYXRod2F5c1twYXRod2F5SWRdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aHdheVByaW9yaXR5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXRod2F5SWQgPSBwYXRod2F5UHJpb3JpdHlbaV07XG4gICAgICBpZiAocGF0aHdheUlkIGluIHBlbmFsaXplZFBhdGh3YXlzKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHBhdGh3YXlJZCA9PT0gdGhpcy5wYXRod2F5SWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2VsZWN0ZWRJbmRleCA9IHRoaXMuaGxzLm5leHRMb2FkTGV2ZWw7XG4gICAgICBjb25zdCBzZWxlY3RlZExldmVsID0gdGhpcy5obHMubGV2ZWxzW3NlbGVjdGVkSW5kZXhdO1xuICAgICAgbGV2ZWxzID0gdGhpcy5nZXRMZXZlbHNGb3JQYXRod2F5KHBhdGh3YXlJZCk7XG4gICAgICBpZiAobGV2ZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5sb2coYFNldHRpbmcgUGF0aHdheSB0byBcIiR7cGF0aHdheUlkfVwiYCk7XG4gICAgICAgIHRoaXMucGF0aHdheUlkID0gcGF0aHdheUlkO1xuICAgICAgICByZWFzc2lnbkZyYWdtZW50TGV2ZWxJbmRleGVzKGxldmVscyk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkxFVkVMU19VUERBVEVELCB7XG4gICAgICAgICAgbGV2ZWxzXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTZXQgTGV2ZWxDb250cm9sbGVyJ3MgbGV2ZWwgdG8gdHJpZ2dlciBMRVZFTF9TV0lUQ0hJTkcgd2hpY2ggbG9hZHMgcGxheWxpc3QgaWYgbmVlZGVkXG4gICAgICAgIGNvbnN0IGxldmVsQWZ0ZXJDaGFuZ2UgPSB0aGlzLmhscy5sZXZlbHNbc2VsZWN0ZWRJbmRleF07XG4gICAgICAgIGlmIChzZWxlY3RlZExldmVsICYmIGxldmVsQWZ0ZXJDaGFuZ2UgJiYgdGhpcy5sZXZlbHMpIHtcbiAgICAgICAgICBpZiAobGV2ZWxBZnRlckNoYW5nZS5hdHRyc1snU1RBQkxFLVZBUklBTlQtSUQnXSAhPT0gc2VsZWN0ZWRMZXZlbC5hdHRyc1snU1RBQkxFLVZBUklBTlQtSUQnXSAmJiBsZXZlbEFmdGVyQ2hhbmdlLmJpdHJhdGUgIT09IHNlbGVjdGVkTGV2ZWwuYml0cmF0ZSkge1xuICAgICAgICAgICAgdGhpcy5sb2coYFVuc3RhYmxlIFBhdGh3YXlzIGNoYW5nZSBmcm9tIGJpdHJhdGUgJHtzZWxlY3RlZExldmVsLmJpdHJhdGV9IHRvICR7bGV2ZWxBZnRlckNoYW5nZS5iaXRyYXRlfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmhscy5uZXh0TG9hZExldmVsID0gc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0UGF0aHdheUZvckdyb3VwSWQoZ3JvdXBJZCwgdHlwZSwgZGVmYXVsdFBhdGh3YXkpIHtcbiAgICBjb25zdCBsZXZlbHMgPSB0aGlzLmdldExldmVsc0ZvclBhdGh3YXkoZGVmYXVsdFBhdGh3YXkpLmNvbmNhdCh0aGlzLmxldmVscyB8fCBbXSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLkFVRElPX1RSQUNLICYmIGxldmVsc1tpXS5oYXNBdWRpb0dyb3VwKGdyb3VwSWQpIHx8IHR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuU1VCVElUTEVfVFJBQ0sgJiYgbGV2ZWxzW2ldLmhhc1N1YnRpdGxlR3JvdXAoZ3JvdXBJZCkpIHtcbiAgICAgICAgcmV0dXJuIGxldmVsc1tpXS5wYXRod2F5SWQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0UGF0aHdheTtcbiAgfVxuICBjbG9uZVBhdGh3YXlzKHBhdGh3YXlDbG9uZXMpIHtcbiAgICBjb25zdCBsZXZlbHMgPSB0aGlzLmxldmVscztcbiAgICBpZiAoIWxldmVscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhdWRpb0dyb3VwQ2xvbmVNYXAgPSB7fTtcbiAgICBjb25zdCBzdWJ0aXRsZUdyb3VwQ2xvbmVNYXAgPSB7fTtcbiAgICBwYXRod2F5Q2xvbmVzLmZvckVhY2gocGF0aHdheUNsb25lID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgSUQ6IGNsb25lSWQsXG4gICAgICAgICdCQVNFLUlEJzogYmFzZUlkLFxuICAgICAgICAnVVJJLVJFUExBQ0VNRU5UJzogdXJpUmVwbGFjZW1lbnRcbiAgICAgIH0gPSBwYXRod2F5Q2xvbmU7XG4gICAgICBpZiAobGV2ZWxzLnNvbWUobGV2ZWwgPT4gbGV2ZWwucGF0aHdheUlkID09PSBjbG9uZUlkKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBjbG9uZWRWYXJpYW50cyA9IHRoaXMuZ2V0TGV2ZWxzRm9yUGF0aHdheShiYXNlSWQpLm1hcChiYXNlTGV2ZWwgPT4ge1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gbmV3IEF0dHJMaXN0KGJhc2VMZXZlbC5hdHRycyk7XG4gICAgICAgIGF0dHJpYnV0ZXNbJ1BBVEhXQVktSUQnXSA9IGNsb25lSWQ7XG4gICAgICAgIGNvbnN0IGNsb25lZEF1ZGlvR3JvdXBJZCA9IGF0dHJpYnV0ZXMuQVVESU8gJiYgYCR7YXR0cmlidXRlcy5BVURJT31fY2xvbmVfJHtjbG9uZUlkfWA7XG4gICAgICAgIGNvbnN0IGNsb25lZFN1YnRpdGxlR3JvdXBJZCA9IGF0dHJpYnV0ZXMuU1VCVElUTEVTICYmIGAke2F0dHJpYnV0ZXMuU1VCVElUTEVTfV9jbG9uZV8ke2Nsb25lSWR9YDtcbiAgICAgICAgaWYgKGNsb25lZEF1ZGlvR3JvdXBJZCkge1xuICAgICAgICAgIGF1ZGlvR3JvdXBDbG9uZU1hcFthdHRyaWJ1dGVzLkFVRElPXSA9IGNsb25lZEF1ZGlvR3JvdXBJZDtcbiAgICAgICAgICBhdHRyaWJ1dGVzLkFVRElPID0gY2xvbmVkQXVkaW9Hcm91cElkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbG9uZWRTdWJ0aXRsZUdyb3VwSWQpIHtcbiAgICAgICAgICBzdWJ0aXRsZUdyb3VwQ2xvbmVNYXBbYXR0cmlidXRlcy5TVUJUSVRMRVNdID0gY2xvbmVkU3VidGl0bGVHcm91cElkO1xuICAgICAgICAgIGF0dHJpYnV0ZXMuU1VCVElUTEVTID0gY2xvbmVkU3VidGl0bGVHcm91cElkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVybCA9IHBlcmZvcm1VcmlSZXBsYWNlbWVudChiYXNlTGV2ZWwudXJpLCBhdHRyaWJ1dGVzWydTVEFCTEUtVkFSSUFOVC1JRCddLCAnUEVSLVZBUklBTlQtVVJJUycsIHVyaVJlcGxhY2VtZW50KTtcbiAgICAgICAgY29uc3QgY2xvbmVkTGV2ZWwgPSBuZXcgTGV2ZWwoe1xuICAgICAgICAgIGF0dHJzOiBhdHRyaWJ1dGVzLFxuICAgICAgICAgIGF1ZGlvQ29kZWM6IGJhc2VMZXZlbC5hdWRpb0NvZGVjLFxuICAgICAgICAgIGJpdHJhdGU6IGJhc2VMZXZlbC5iaXRyYXRlLFxuICAgICAgICAgIGhlaWdodDogYmFzZUxldmVsLmhlaWdodCxcbiAgICAgICAgICBuYW1lOiBiYXNlTGV2ZWwubmFtZSxcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgdmlkZW9Db2RlYzogYmFzZUxldmVsLnZpZGVvQ29kZWMsXG4gICAgICAgICAgd2lkdGg6IGJhc2VMZXZlbC53aWR0aFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGJhc2VMZXZlbC5hdWRpb0dyb3Vwcykge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYmFzZUxldmVsLmF1ZGlvR3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjbG9uZWRMZXZlbC5hZGRHcm91cElkKCdhdWRpbycsIGAke2Jhc2VMZXZlbC5hdWRpb0dyb3Vwc1tpXX1fY2xvbmVfJHtjbG9uZUlkfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYmFzZUxldmVsLnN1YnRpdGxlR3JvdXBzKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBiYXNlTGV2ZWwuc3VidGl0bGVHcm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNsb25lZExldmVsLmFkZEdyb3VwSWQoJ3RleHQnLCBgJHtiYXNlTGV2ZWwuc3VidGl0bGVHcm91cHNbaV19X2Nsb25lXyR7Y2xvbmVJZH1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsb25lZExldmVsO1xuICAgICAgfSk7XG4gICAgICBsZXZlbHMucHVzaCguLi5jbG9uZWRWYXJpYW50cyk7XG4gICAgICBjbG9uZVJlbmRpdGlvbkdyb3Vwcyh0aGlzLmF1ZGlvVHJhY2tzLCBhdWRpb0dyb3VwQ2xvbmVNYXAsIHVyaVJlcGxhY2VtZW50LCBjbG9uZUlkKTtcbiAgICAgIGNsb25lUmVuZGl0aW9uR3JvdXBzKHRoaXMuc3VidGl0bGVUcmFja3MsIHN1YnRpdGxlR3JvdXBDbG9uZU1hcCwgdXJpUmVwbGFjZW1lbnQsIGNsb25lSWQpO1xuICAgIH0pO1xuICB9XG4gIGxvYWRTdGVlcmluZ01hbmlmZXN0KHVyaSkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcbiAgICBjb25zdCBMb2FkZXIgPSBjb25maWcubG9hZGVyO1xuICAgIGlmICh0aGlzLmxvYWRlcikge1xuICAgICAgdGhpcy5sb2FkZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLmxvYWRlciA9IG5ldyBMb2FkZXIoY29uZmlnKTtcbiAgICBsZXQgdXJsO1xuICAgIHRyeSB7XG4gICAgICB1cmwgPSBuZXcgc2VsZi5VUkwodXJpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmxvZyhgRmFpbGVkIHRvIHBhcnNlIFN0ZWVyaW5nIE1hbmlmZXN0IFVSSTogJHt1cml9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh1cmwucHJvdG9jb2wgIT09ICdkYXRhOicpIHtcbiAgICAgIGNvbnN0IHRocm91Z2hwdXQgPSAodGhpcy5obHMuYmFuZHdpZHRoRXN0aW1hdGUgfHwgY29uZmlnLmFickV3bWFEZWZhdWx0RXN0aW1hdGUpIHwgMDtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdfSExTX3BhdGh3YXknLCB0aGlzLnBhdGh3YXlJZCk7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnX0hMU190aHJvdWdocHV0JywgJycgKyB0aHJvdWdocHV0KTtcbiAgICB9XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgICAgdXJsOiB1cmwuaHJlZlxuICAgIH07XG4gICAgY29uc3QgbG9hZFBvbGljeSA9IGNvbmZpZy5zdGVlcmluZ01hbmlmZXN0TG9hZFBvbGljeS5kZWZhdWx0O1xuICAgIGNvbnN0IGxlZ2FjeVJldHJ5Q29tcGF0aWJpbGl0eSA9IGxvYWRQb2xpY3kuZXJyb3JSZXRyeSB8fCBsb2FkUG9saWN5LnRpbWVvdXRSZXRyeSB8fCB7fTtcbiAgICBjb25zdCBsb2FkZXJDb25maWcgPSB7XG4gICAgICBsb2FkUG9saWN5LFxuICAgICAgdGltZW91dDogbG9hZFBvbGljeS5tYXhMb2FkVGltZU1zLFxuICAgICAgbWF4UmV0cnk6IGxlZ2FjeVJldHJ5Q29tcGF0aWJpbGl0eS5tYXhOdW1SZXRyeSB8fCAwLFxuICAgICAgcmV0cnlEZWxheTogbGVnYWN5UmV0cnlDb21wYXRpYmlsaXR5LnJldHJ5RGVsYXlNcyB8fCAwLFxuICAgICAgbWF4UmV0cnlEZWxheTogbGVnYWN5UmV0cnlDb21wYXRpYmlsaXR5Lm1heFJldHJ5RGVsYXlNcyB8fCAwXG4gICAgfTtcbiAgICBjb25zdCBjYWxsYmFja3MgPSB7XG4gICAgICBvblN1Y2Nlc3M6IChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgIHRoaXMubG9nKGBMb2FkZWQgc3RlZXJpbmcgbWFuaWZlc3Q6IFwiJHt1cmx9XCJgKTtcbiAgICAgICAgY29uc3Qgc3RlZXJpbmdEYXRhID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgaWYgKChzdGVlcmluZ0RhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IHN0ZWVyaW5nRGF0YS5WRVJTSU9OKSAhPT0gMSkge1xuICAgICAgICAgIHRoaXMubG9nKGBTdGVlcmluZyBWRVJTSU9OICR7c3RlZXJpbmdEYXRhLlZFUlNJT059IG5vdCBzdXBwb3J0ZWQhYCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB0aGlzLnRpbWVUb0xvYWQgPSBzdGVlcmluZ0RhdGEuVFRMO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgJ1JFTE9BRC1VUkknOiByZWxvYWRVcmksXG4gICAgICAgICAgJ1BBVEhXQVktQ0xPTkVTJzogcGF0aHdheUNsb25lcyxcbiAgICAgICAgICAnUEFUSFdBWS1QUklPUklUWSc6IHBhdGh3YXlQcmlvcml0eVxuICAgICAgICB9ID0gc3RlZXJpbmdEYXRhO1xuICAgICAgICBpZiAocmVsb2FkVXJpKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMudXJpID0gbmV3IHNlbGYuVVJMKHJlbG9hZFVyaSwgdXJsKS5ocmVmO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubG9nKGBGYWlsZWQgdG8gcGFyc2UgU3RlZXJpbmcgTWFuaWZlc3QgUkVMT0FELVVSSTogJHtyZWxvYWRVcml9YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2NoZWR1bGVSZWZyZXNoKHRoaXMudXJpIHx8IGNvbnRleHQudXJsKTtcbiAgICAgICAgaWYgKHBhdGh3YXlDbG9uZXMpIHtcbiAgICAgICAgICB0aGlzLmNsb25lUGF0aHdheXMocGF0aHdheUNsb25lcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG9hZGVkU3RlZXJpbmdEYXRhID0ge1xuICAgICAgICAgIHN0ZWVyaW5nTWFuaWZlc3Q6IHN0ZWVyaW5nRGF0YSxcbiAgICAgICAgICB1cmw6IHVybC50b1N0cmluZygpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLlNURUVSSU5HX01BTklGRVNUX0xPQURFRCwgbG9hZGVkU3RlZXJpbmdEYXRhKTtcbiAgICAgICAgaWYgKHBhdGh3YXlQcmlvcml0eSkge1xuICAgICAgICAgIHRoaXMudXBkYXRlUGF0aHdheVByaW9yaXR5KHBhdGh3YXlQcmlvcml0eSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbkVycm9yOiAoZXJyb3IsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCBzdGF0cykgPT4ge1xuICAgICAgICB0aGlzLmxvZyhgRXJyb3IgbG9hZGluZyBzdGVlcmluZyBtYW5pZmVzdDogJHtlcnJvci5jb2RlfSAke2Vycm9yLnRleHR9ICgke2NvbnRleHQudXJsfSlgKTtcbiAgICAgICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gNDEwKSB7XG4gICAgICAgICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5sb2coYFN0ZWVyaW5nIG1hbmlmZXN0ICR7Y29udGV4dC51cmx9IG5vIGxvbmdlciBhdmFpbGFibGVgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHR0bCA9IHRoaXMudGltZVRvTG9hZCAqIDEwMDA7XG4gICAgICAgIGlmIChlcnJvci5jb2RlID09PSA0MjkpIHtcbiAgICAgICAgICBjb25zdCBsb2FkZXIgPSB0aGlzLmxvYWRlcjtcbiAgICAgICAgICBpZiAodHlwZW9mIChsb2FkZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGxvYWRlci5nZXRSZXNwb25zZUhlYWRlcikgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldHJ5QWZ0ZXIgPSBsb2FkZXIuZ2V0UmVzcG9uc2VIZWFkZXIoJ1JldHJ5LUFmdGVyJyk7XG4gICAgICAgICAgICBpZiAocmV0cnlBZnRlcikge1xuICAgICAgICAgICAgICB0dGwgPSBwYXJzZUZsb2F0KHJldHJ5QWZ0ZXIpICogMTAwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5sb2coYFN0ZWVyaW5nIG1hbmlmZXN0ICR7Y29udGV4dC51cmx9IHJhdGUgbGltaXRlZGApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjaGVkdWxlUmVmcmVzaCh0aGlzLnVyaSB8fCBjb250ZXh0LnVybCwgdHRsKTtcbiAgICAgIH0sXG4gICAgICBvblRpbWVvdXQ6IChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpID0+IHtcbiAgICAgICAgdGhpcy5sb2coYFRpbWVvdXQgbG9hZGluZyBzdGVlcmluZyBtYW5pZmVzdCAoJHtjb250ZXh0LnVybH0pYCk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVSZWZyZXNoKHRoaXMudXJpIHx8IGNvbnRleHQudXJsKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMubG9nKGBSZXF1ZXN0aW5nIHN0ZWVyaW5nIG1hbmlmZXN0OiAke3VybH1gKTtcbiAgICB0aGlzLmxvYWRlci5sb2FkKGNvbnRleHQsIGxvYWRlckNvbmZpZywgY2FsbGJhY2tzKTtcbiAgfVxuICBzY2hlZHVsZVJlZnJlc2godXJpLCB0dGxNcyA9IHRoaXMudGltZVRvTG9hZCAqIDEwMDApIHtcbiAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICAgIHRoaXMucmVsb2FkVGltZXIgPSBzZWxmLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdmFyIF90aGlzJGhscztcbiAgICAgIGNvbnN0IG1lZGlhID0gKF90aGlzJGhscyA9IHRoaXMuaGxzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkaGxzLm1lZGlhO1xuICAgICAgaWYgKG1lZGlhICYmICFtZWRpYS5lbmRlZCkge1xuICAgICAgICB0aGlzLmxvYWRTdGVlcmluZ01hbmlmZXN0KHVyaSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2NoZWR1bGVSZWZyZXNoKHVyaSwgdGhpcy50aW1lVG9Mb2FkICogMTAwMCk7XG4gICAgfSwgdHRsTXMpO1xuICB9XG59XG5mdW5jdGlvbiBjbG9uZVJlbmRpdGlvbkdyb3Vwcyh0cmFja3MsIGdyb3VwQ2xvbmVNYXAsIHVyaVJlcGxhY2VtZW50LCBjbG9uZUlkKSB7XG4gIGlmICghdHJhY2tzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIE9iamVjdC5rZXlzKGdyb3VwQ2xvbmVNYXApLmZvckVhY2goYXVkaW9Hcm91cElkID0+IHtcbiAgICBjb25zdCBjbG9uZWRUcmFja3MgPSB0cmFja3MuZmlsdGVyKHRyYWNrID0+IHRyYWNrLmdyb3VwSWQgPT09IGF1ZGlvR3JvdXBJZCkubWFwKHRyYWNrID0+IHtcbiAgICAgIGNvbnN0IGNsb25lZFRyYWNrID0gX2V4dGVuZHMoe30sIHRyYWNrKTtcbiAgICAgIGNsb25lZFRyYWNrLmRldGFpbHMgPSB1bmRlZmluZWQ7XG4gICAgICBjbG9uZWRUcmFjay5hdHRycyA9IG5ldyBBdHRyTGlzdChjbG9uZWRUcmFjay5hdHRycyk7XG4gICAgICBjbG9uZWRUcmFjay51cmwgPSBjbG9uZWRUcmFjay5hdHRycy5VUkkgPSBwZXJmb3JtVXJpUmVwbGFjZW1lbnQodHJhY2sudXJsLCB0cmFjay5hdHRyc1snU1RBQkxFLVJFTkRJVElPTi1JRCddLCAnUEVSLVJFTkRJVElPTi1VUklTJywgdXJpUmVwbGFjZW1lbnQpO1xuICAgICAgY2xvbmVkVHJhY2suZ3JvdXBJZCA9IGNsb25lZFRyYWNrLmF0dHJzWydHUk9VUC1JRCddID0gZ3JvdXBDbG9uZU1hcFthdWRpb0dyb3VwSWRdO1xuICAgICAgY2xvbmVkVHJhY2suYXR0cnNbJ1BBVEhXQVktSUQnXSA9IGNsb25lSWQ7XG4gICAgICByZXR1cm4gY2xvbmVkVHJhY2s7XG4gICAgfSk7XG4gICAgdHJhY2tzLnB1c2goLi4uY2xvbmVkVHJhY2tzKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBwZXJmb3JtVXJpUmVwbGFjZW1lbnQodXJpLCBzdGFibGVJZCwgcGVyT3B0aW9uS2V5LCB1cmlSZXBsYWNlbWVudCkge1xuICBjb25zdCB7XG4gICAgSE9TVDogaG9zdCxcbiAgICBQQVJBTVM6IHBhcmFtcyxcbiAgICBbcGVyT3B0aW9uS2V5XTogcGVyT3B0aW9uVXJpc1xuICB9ID0gdXJpUmVwbGFjZW1lbnQ7XG4gIGxldCBwZXJWYXJpYW50VXJpO1xuICBpZiAoc3RhYmxlSWQpIHtcbiAgICBwZXJWYXJpYW50VXJpID0gcGVyT3B0aW9uVXJpcyA9PSBudWxsID8gdm9pZCAwIDogcGVyT3B0aW9uVXJpc1tzdGFibGVJZF07XG4gICAgaWYgKHBlclZhcmlhbnRVcmkpIHtcbiAgICAgIHVyaSA9IHBlclZhcmlhbnRVcmk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHVybCA9IG5ldyBzZWxmLlVSTCh1cmkpO1xuICBpZiAoaG9zdCAmJiAhcGVyVmFyaWFudFVyaSkge1xuICAgIHVybC5ob3N0ID0gaG9zdDtcbiAgfVxuICBpZiAocGFyYW1zKSB7XG4gICAgT2JqZWN0LmtleXMocGFyYW1zKS5zb3J0KCkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKGtleSkge1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChrZXksIHBhcmFtc1trZXldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdXJsLmhyZWY7XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZWwsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWwsIHR5cGUsIGxpc3RlbmVyKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcik7XG59XG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKGVsLCB0eXBlLCBsaXN0ZW5lcikge1xuICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKTtcbn1cblxuLyoqXG4gKiBDb250cm9sbGVyIHRvIGRlYWwgd2l0aCBlbmNyeXB0ZWQgbWVkaWEgZXh0ZW5zaW9ucyAoRU1FKVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRW5jcnlwdGVkX01lZGlhX0V4dGVuc2lvbnNfQVBJXG4gKlxuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgRU1FQ29udHJvbGxlciBleHRlbmRzIExvZ2dlciB7XG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHN1cGVyKCdlbWUnLCBobHMubG9nZ2VyKTtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLmtleUZvcm1hdFByb21pc2UgPSBudWxsO1xuICAgIHRoaXMua2V5U3lzdGVtQWNjZXNzUHJvbWlzZXMgPSB7fTtcbiAgICB0aGlzLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCA9IDA7XG4gICAgdGhpcy5tZWRpYUtleVNlc3Npb25zID0gW107XG4gICAgdGhpcy5rZXlJZFRvS2V5U2Vzc2lvblByb21pc2UgPSB7fTtcbiAgICB0aGlzLm1lZGlhS2V5cyA9IG51bGw7XG4gICAgdGhpcy5zZXRNZWRpYUtleXNRdWV1ZSA9IEVNRUNvbnRyb2xsZXIuQ0RNQ2xlYW51cFByb21pc2UgPyBbRU1FQ29udHJvbGxlci5DRE1DbGVhbnVwUHJvbWlzZV0gOiBbXTtcbiAgICB0aGlzLm9uV2FpdGluZ0ZvcktleSA9IGV2ZW50ID0+IHtcbiAgICAgIHRoaXMubG9nKGBcIiR7ZXZlbnQudHlwZX1cIiBldmVudGApO1xuICAgIH07XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMub25EZXN0cm95aW5nKCk7XG4gICAgdGhpcy5vbk1lZGlhRGV0YWNoZWQoKTtcbiAgICAvLyBSZW1vdmUgYW55IHJlZmVyZW5jZXMgdGhhdCBjb3VsZCBiZSBoZWxkIGluIGNvbmZpZyBvcHRpb25zIG9yIGNhbGxiYWNrc1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGNvbmZpZy5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NGdW5jID0gbnVsbDtcbiAgICBjb25maWcubGljZW5zZVhoclNldHVwID0gY29uZmlnLmxpY2Vuc2VSZXNwb25zZUNhbGxiYWNrID0gdW5kZWZpbmVkO1xuICAgIGNvbmZpZy5kcm1TeXN0ZW1zID0gY29uZmlnLmRybVN5c3RlbU9wdGlvbnMgPSB7fTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSB0aGlzLmNvbmZpZyA9IHRoaXMua2V5SWRUb0tleVNlc3Npb25Qcm9taXNlID0gbnVsbDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5vbldhaXRpbmdGb3JLZXkgPSBudWxsO1xuICB9XG4gIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHRoaXMuaGxzLm9uKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9uKEV2ZW50cy5NRURJQV9ERVRBQ0hFRCwgdGhpcy5vbk1lZGlhRGV0YWNoZWQsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9uKEV2ZW50cy5ERVNUUk9ZSU5HLCB0aGlzLm9uRGVzdHJveWluZywgdGhpcyk7XG4gIH1cbiAgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB0aGlzLmhscy5vZmYoRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgdGhpcy5obHMub2ZmKEV2ZW50cy5NRURJQV9ERVRBQ0hFRCwgdGhpcy5vbk1lZGlhRGV0YWNoZWQsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgdGhpcy5obHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FERUQsIHRoaXMub25NYW5pZmVzdExvYWRlZCwgdGhpcyk7XG4gICAgdGhpcy5obHMub2ZmKEV2ZW50cy5ERVNUUk9ZSU5HLCB0aGlzLm9uRGVzdHJveWluZywgdGhpcyk7XG4gIH1cbiAgZ2V0TGljZW5zZVNlcnZlclVybChrZXlTeXN0ZW0pIHtcbiAgICBjb25zdCB7XG4gICAgICBkcm1TeXN0ZW1zLFxuICAgICAgd2lkZXZpbmVMaWNlbnNlVXJsXG4gICAgfSA9IHRoaXMuY29uZmlnO1xuICAgIGNvbnN0IGtleVN5c3RlbUNvbmZpZ3VyYXRpb24gPSBkcm1TeXN0ZW1zW2tleVN5c3RlbV07XG4gICAgaWYgKGtleVN5c3RlbUNvbmZpZ3VyYXRpb24pIHtcbiAgICAgIHJldHVybiBrZXlTeXN0ZW1Db25maWd1cmF0aW9uLmxpY2Vuc2VVcmw7XG4gICAgfVxuXG4gICAgLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICBpZiAoa2V5U3lzdGVtID09PSBLZXlTeXN0ZW1zLldJREVWSU5FICYmIHdpZGV2aW5lTGljZW5zZVVybCkge1xuICAgICAgcmV0dXJuIHdpZGV2aW5lTGljZW5zZVVybDtcbiAgICB9XG4gIH1cbiAgZ2V0TGljZW5zZVNlcnZlclVybE9yVGhyb3coa2V5U3lzdGVtKSB7XG4gICAgY29uc3QgdXJsID0gdGhpcy5nZXRMaWNlbnNlU2VydmVyVXJsKGtleVN5c3RlbSk7XG4gICAgaWYgKHVybCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vIGxpY2Vuc2Ugc2VydmVyIFVSTCBjb25maWd1cmVkIGZvciBrZXktc3lzdGVtIFwiJHtrZXlTeXN0ZW19XCJgKTtcbiAgICB9XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICBnZXRTZXJ2ZXJDZXJ0aWZpY2F0ZVVybChrZXlTeXN0ZW0pIHtcbiAgICBjb25zdCB7XG4gICAgICBkcm1TeXN0ZW1zXG4gICAgfSA9IHRoaXMuY29uZmlnO1xuICAgIGNvbnN0IGtleVN5c3RlbUNvbmZpZ3VyYXRpb24gPSBkcm1TeXN0ZW1zW2tleVN5c3RlbV07XG4gICAgaWYgKGtleVN5c3RlbUNvbmZpZ3VyYXRpb24pIHtcbiAgICAgIHJldHVybiBrZXlTeXN0ZW1Db25maWd1cmF0aW9uLnNlcnZlckNlcnRpZmljYXRlVXJsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvZyhgTm8gU2VydmVyIENlcnRpZmljYXRlIGluIGNvbmZpZy5kcm1TeXN0ZW1zW1wiJHtrZXlTeXN0ZW19XCJdYCk7XG4gICAgfVxuICB9XG4gIGF0dGVtcHRLZXlTeXN0ZW1BY2Nlc3Moa2V5U3lzdGVtc1RvQXR0ZW1wdCkge1xuICAgIGNvbnN0IGxldmVscyA9IHRoaXMuaGxzLmxldmVscztcbiAgICBjb25zdCB1bmlxdWVDb2RlYyA9ICh2YWx1ZSwgaSwgYSkgPT4gISF2YWx1ZSAmJiBhLmluZGV4T2YodmFsdWUpID09PSBpO1xuICAgIGNvbnN0IGF1ZGlvQ29kZWNzID0gbGV2ZWxzLm1hcChsZXZlbCA9PiBsZXZlbC5hdWRpb0NvZGVjKS5maWx0ZXIodW5pcXVlQ29kZWMpO1xuICAgIGNvbnN0IHZpZGVvQ29kZWNzID0gbGV2ZWxzLm1hcChsZXZlbCA9PiBsZXZlbC52aWRlb0NvZGVjKS5maWx0ZXIodW5pcXVlQ29kZWMpO1xuICAgIGlmIChhdWRpb0NvZGVjcy5sZW5ndGggKyB2aWRlb0NvZGVjcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHZpZGVvQ29kZWNzLnB1c2goJ2F2YzEuNDJlMDFlJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBhdHRlbXB0ID0ga2V5U3lzdGVtcyA9PiB7XG4gICAgICAgIGNvbnN0IGtleVN5c3RlbSA9IGtleVN5c3RlbXMuc2hpZnQoKTtcbiAgICAgICAgdGhpcy5nZXRNZWRpYUtleXNQcm9taXNlKGtleVN5c3RlbSwgYXVkaW9Db2RlY3MsIHZpZGVvQ29kZWNzKS50aGVuKG1lZGlhS2V5cyA9PiByZXNvbHZlKHtcbiAgICAgICAgICBrZXlTeXN0ZW0sXG4gICAgICAgICAgbWVkaWFLZXlzXG4gICAgICAgIH0pKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgaWYgKGtleVN5c3RlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhdHRlbXB0KGtleVN5c3RlbXMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFTUVLZXlFcnJvcikge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFTUVLZXlFcnJvcih7XG4gICAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fTk9fQUNDRVNTLFxuICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgICAgICAgIH0sIGVycm9yLm1lc3NhZ2UpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGF0dGVtcHQoa2V5U3lzdGVtc1RvQXR0ZW1wdCk7XG4gICAgfSk7XG4gIH1cbiAgcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzKGtleVN5c3RlbSwgc3VwcG9ydGVkQ29uZmlndXJhdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NGdW5jXG4gICAgfSA9IHRoaXMuY29uZmlnO1xuICAgIGlmICghKHR5cGVvZiByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NGdW5jID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgbGV0IGVyck1lc3NhZ2UgPSBgQ29uZmlndXJlZCByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgaXMgbm90IGEgZnVuY3Rpb24gJHtyZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NGdW5jfWA7XG4gICAgICBpZiAocmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzID09PSBudWxsICYmIHNlbGYubG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwOicpIHtcbiAgICAgICAgZXJyTWVzc2FnZSA9IGBuYXZpZ2F0b3IucmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzIGlzIG5vdCBhdmFpbGFibGUgb3ZlciBpbnNlY3VyZSBwcm90b2NvbCAke2xvY2F0aW9uLnByb3RvY29sfWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGVyck1lc3NhZ2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc0Z1bmMoa2V5U3lzdGVtLCBzdXBwb3J0ZWRDb25maWd1cmF0aW9ucyk7XG4gIH1cbiAgZ2V0TWVkaWFLZXlzUHJvbWlzZShrZXlTeXN0ZW0sIGF1ZGlvQ29kZWNzLCB2aWRlb0NvZGVjcykge1xuICAgIC8vIFRoaXMgY2FuIHRocm93LCBidXQgaXMgY2F1Z2h0IGluIGV2ZW50IGhhbmRsZXIgY2FsbHBhdGhcbiAgICBjb25zdCBtZWRpYUtleVN5c3RlbUNvbmZpZ3MgPSBnZXRTdXBwb3J0ZWRNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25zKGtleVN5c3RlbSwgYXVkaW9Db2RlY3MsIHZpZGVvQ29kZWNzLCB0aGlzLmNvbmZpZy5kcm1TeXN0ZW1PcHRpb25zKTtcbiAgICBjb25zdCBrZXlTeXN0ZW1BY2Nlc3NQcm9taXNlcyA9IHRoaXMua2V5U3lzdGVtQWNjZXNzUHJvbWlzZXNba2V5U3lzdGVtXTtcbiAgICBsZXQga2V5U3lzdGVtQWNjZXNzID0ga2V5U3lzdGVtQWNjZXNzUHJvbWlzZXMgPT0gbnVsbCA/IHZvaWQgMCA6IGtleVN5c3RlbUFjY2Vzc1Byb21pc2VzLmtleVN5c3RlbUFjY2VzcztcbiAgICBpZiAoIWtleVN5c3RlbUFjY2Vzcykge1xuICAgICAgdGhpcy5sb2coYFJlcXVlc3RpbmcgZW5jcnlwdGVkIG1lZGlhIFwiJHtrZXlTeXN0ZW19XCIga2V5LXN5c3RlbSBhY2Nlc3Mgd2l0aCBjb25maWc6ICR7c3RyaW5naWZ5KG1lZGlhS2V5U3lzdGVtQ29uZmlncyl9YCk7XG4gICAgICBrZXlTeXN0ZW1BY2Nlc3MgPSB0aGlzLnJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyhrZXlTeXN0ZW0sIG1lZGlhS2V5U3lzdGVtQ29uZmlncyk7XG4gICAgICBjb25zdCBfa2V5U3lzdGVtQWNjZXNzUHJvbWlzZXMgPSB0aGlzLmtleVN5c3RlbUFjY2Vzc1Byb21pc2VzW2tleVN5c3RlbV0gPSB7XG4gICAgICAgIGtleVN5c3RlbUFjY2Vzc1xuICAgICAgfTtcbiAgICAgIGtleVN5c3RlbUFjY2Vzcy5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIHRoaXMubG9nKGBGYWlsZWQgdG8gb2J0YWluIGFjY2VzcyB0byBrZXktc3lzdGVtIFwiJHtrZXlTeXN0ZW19XCI6ICR7ZXJyb3J9YCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBrZXlTeXN0ZW1BY2Nlc3MudGhlbihtZWRpYUtleVN5c3RlbUFjY2VzcyA9PiB7XG4gICAgICAgIHRoaXMubG9nKGBBY2Nlc3MgZm9yIGtleS1zeXN0ZW0gXCIke21lZGlhS2V5U3lzdGVtQWNjZXNzLmtleVN5c3RlbX1cIiBvYnRhaW5lZGApO1xuICAgICAgICBjb25zdCBjZXJ0aWZpY2F0ZVJlcXVlc3QgPSB0aGlzLmZldGNoU2VydmVyQ2VydGlmaWNhdGUoa2V5U3lzdGVtKTtcbiAgICAgICAgdGhpcy5sb2coYENyZWF0ZSBtZWRpYS1rZXlzIGZvciBcIiR7a2V5U3lzdGVtfVwiYCk7XG4gICAgICAgIF9rZXlTeXN0ZW1BY2Nlc3NQcm9taXNlcy5tZWRpYUtleXMgPSBtZWRpYUtleVN5c3RlbUFjY2Vzcy5jcmVhdGVNZWRpYUtleXMoKS50aGVuKG1lZGlhS2V5cyA9PiB7XG4gICAgICAgICAgdGhpcy5sb2coYE1lZGlhLWtleXMgY3JlYXRlZCBmb3IgXCIke2tleVN5c3RlbX1cImApO1xuICAgICAgICAgIF9rZXlTeXN0ZW1BY2Nlc3NQcm9taXNlcy5oYXNNZWRpYUtleXMgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBjZXJ0aWZpY2F0ZVJlcXVlc3QudGhlbihjZXJ0aWZpY2F0ZSA9PiB7XG4gICAgICAgICAgICBpZiAoY2VydGlmaWNhdGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TWVkaWFLZXlzU2VydmVyQ2VydGlmaWNhdGUobWVkaWFLZXlzLCBrZXlTeXN0ZW0sIGNlcnRpZmljYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZWRpYUtleXM7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBfa2V5U3lzdGVtQWNjZXNzUHJvbWlzZXMubWVkaWFLZXlzLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICB0aGlzLmVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIG1lZGlhLWtleXMgZm9yIFwiJHtrZXlTeXN0ZW19XCJ9OiAke2Vycm9yfWApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF9rZXlTeXN0ZW1BY2Nlc3NQcm9taXNlcy5tZWRpYUtleXM7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGtleVN5c3RlbUFjY2Vzcy50aGVuKCgpID0+IGtleVN5c3RlbUFjY2Vzc1Byb21pc2VzLm1lZGlhS2V5cyk7XG4gIH1cbiAgY3JlYXRlTWVkaWFLZXlTZXNzaW9uQ29udGV4dCh7XG4gICAgZGVjcnlwdGRhdGEsXG4gICAga2V5U3lzdGVtLFxuICAgIG1lZGlhS2V5c1xuICB9KSB7XG4gICAgdGhpcy5sb2coYENyZWF0aW5nIGtleS1zeXN0ZW0gc2Vzc2lvbiBcIiR7a2V5U3lzdGVtfVwiIGtleUlkOiAke0hleC5oZXhEdW1wKGRlY3J5cHRkYXRhLmtleUlkIHx8IFtdKX1gKTtcbiAgICBjb25zdCBtZWRpYUtleXNTZXNzaW9uID0gbWVkaWFLZXlzLmNyZWF0ZVNlc3Npb24oKTtcbiAgICBjb25zdCBtZWRpYUtleVNlc3Npb25Db250ZXh0ID0ge1xuICAgICAgZGVjcnlwdGRhdGEsXG4gICAgICBrZXlTeXN0ZW0sXG4gICAgICBtZWRpYUtleXMsXG4gICAgICBtZWRpYUtleXNTZXNzaW9uLFxuICAgICAga2V5U3RhdHVzOiAnc3RhdHVzLXBlbmRpbmcnXG4gICAgfTtcbiAgICB0aGlzLm1lZGlhS2V5U2Vzc2lvbnMucHVzaChtZWRpYUtleVNlc3Npb25Db250ZXh0KTtcbiAgICByZXR1cm4gbWVkaWFLZXlTZXNzaW9uQ29udGV4dDtcbiAgfVxuICByZW5ld0tleVNlc3Npb24obWVkaWFLZXlTZXNzaW9uQ29udGV4dCkge1xuICAgIGNvbnN0IGRlY3J5cHRkYXRhID0gbWVkaWFLZXlTZXNzaW9uQ29udGV4dC5kZWNyeXB0ZGF0YTtcbiAgICBpZiAoZGVjcnlwdGRhdGEucHNzaCkge1xuICAgICAgY29uc3Qga2V5U2Vzc2lvbkNvbnRleHQgPSB0aGlzLmNyZWF0ZU1lZGlhS2V5U2Vzc2lvbkNvbnRleHQobWVkaWFLZXlTZXNzaW9uQ29udGV4dCk7XG4gICAgICBjb25zdCBrZXlJZCA9IHRoaXMuZ2V0S2V5SWRTdHJpbmcoZGVjcnlwdGRhdGEpO1xuICAgICAgY29uc3Qgc2NoZW1lID0gJ2NlbmMnO1xuICAgICAgdGhpcy5rZXlJZFRvS2V5U2Vzc2lvblByb21pc2Vba2V5SWRdID0gdGhpcy5nZW5lcmF0ZVJlcXVlc3RXaXRoUHJlZmVycmVkS2V5U2Vzc2lvbihrZXlTZXNzaW9uQ29udGV4dCwgc2NoZW1lLCBkZWNyeXB0ZGF0YS5wc3NoLmJ1ZmZlciwgJ2V4cGlyZWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53YXJuKGBDb3VsZCBub3QgcmVuZXcgZXhwaXJlZCBzZXNzaW9uLiBNaXNzaW5nIHBzc2ggaW5pdERhdGEuYCk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlU2Vzc2lvbihtZWRpYUtleVNlc3Npb25Db250ZXh0KTtcbiAgfVxuICBnZXRLZXlJZFN0cmluZyhkZWNyeXB0ZGF0YSkge1xuICAgIGlmICghZGVjcnlwdGRhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHJlYWQga2V5SWQgb2YgdW5kZWZpbmVkIGRlY3J5cHRkYXRhJyk7XG4gICAgfVxuICAgIGlmIChkZWNyeXB0ZGF0YS5rZXlJZCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdrZXlJZCBpcyBudWxsJyk7XG4gICAgfVxuICAgIHJldHVybiBIZXguaGV4RHVtcChkZWNyeXB0ZGF0YS5rZXlJZCk7XG4gIH1cbiAgdXBkYXRlS2V5U2Vzc2lvbihtZWRpYUtleVNlc3Npb25Db250ZXh0LCBkYXRhKSB7XG4gICAgdmFyIF9tZWRpYUtleVNlc3Npb25Db250ZTtcbiAgICBjb25zdCBrZXlTZXNzaW9uID0gbWVkaWFLZXlTZXNzaW9uQ29udGV4dC5tZWRpYUtleXNTZXNzaW9uO1xuICAgIHRoaXMubG9nKGBVcGRhdGluZyBrZXktc2Vzc2lvbiBcIiR7a2V5U2Vzc2lvbi5zZXNzaW9uSWR9XCIgZm9yIGtleUlEICR7SGV4LmhleER1bXAoKChfbWVkaWFLZXlTZXNzaW9uQ29udGUgPSBtZWRpYUtleVNlc3Npb25Db250ZXh0LmRlY3J5cHRkYXRhKSA9PSBudWxsID8gdm9pZCAwIDogX21lZGlhS2V5U2Vzc2lvbkNvbnRlLmtleUlkKSB8fCBbXSl9XG4gICAgICB9IChkYXRhIGxlbmd0aDogJHtkYXRhID8gZGF0YS5ieXRlTGVuZ3RoIDogZGF0YX0pYCk7XG4gICAgcmV0dXJuIGtleVNlc3Npb24udXBkYXRlKGRhdGEpO1xuICB9XG4gIGdldFNlbGVjdGVkS2V5U3lzdGVtRm9ybWF0cygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5rZXlTeXN0ZW1BY2Nlc3NQcm9taXNlcykubWFwKGtleVN5c3RlbSA9PiAoe1xuICAgICAga2V5U3lzdGVtLFxuICAgICAgaGFzTWVkaWFLZXlzOiB0aGlzLmtleVN5c3RlbUFjY2Vzc1Byb21pc2VzW2tleVN5c3RlbV0uaGFzTWVkaWFLZXlzXG4gICAgfSkpLmZpbHRlcigoe1xuICAgICAgaGFzTWVkaWFLZXlzXG4gICAgfSkgPT4gISFoYXNNZWRpYUtleXMpLm1hcCgoe1xuICAgICAga2V5U3lzdGVtXG4gICAgfSkgPT4ga2V5U3lzdGVtRG9tYWluVG9LZXlTeXN0ZW1Gb3JtYXQoa2V5U3lzdGVtKSkuZmlsdGVyKGtleVN5c3RlbSA9PiAhIWtleVN5c3RlbSk7XG4gIH1cbiAgZ2V0S2V5U3lzdGVtQWNjZXNzKGtleVN5c3RlbXNUb0F0dGVtcHQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRLZXlTeXN0ZW1TZWxlY3Rpb25Qcm9taXNlKGtleVN5c3RlbXNUb0F0dGVtcHQpLnRoZW4oKHtcbiAgICAgIGtleVN5c3RlbSxcbiAgICAgIG1lZGlhS2V5c1xuICAgIH0pID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmF0dGVtcHRTZXRNZWRpYUtleXMoa2V5U3lzdGVtLCBtZWRpYUtleXMpO1xuICAgIH0pO1xuICB9XG4gIHNlbGVjdEtleVN5c3RlbShrZXlTeXN0ZW1zVG9BdHRlbXB0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmdldEtleVN5c3RlbVNlbGVjdGlvblByb21pc2Uoa2V5U3lzdGVtc1RvQXR0ZW1wdCkudGhlbigoe1xuICAgICAgICBrZXlTeXN0ZW1cbiAgICAgIH0pID0+IHtcbiAgICAgICAgY29uc3Qga2V5U3lzdGVtRm9ybWF0ID0ga2V5U3lzdGVtRG9tYWluVG9LZXlTeXN0ZW1Gb3JtYXQoa2V5U3lzdGVtKTtcbiAgICAgICAgaWYgKGtleVN5c3RlbUZvcm1hdCkge1xuICAgICAgICAgIHJlc29sdmUoa2V5U3lzdGVtRm9ybWF0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBVbmFibGUgdG8gZmluZCBmb3JtYXQgZm9yIGtleS1zeXN0ZW0gXCIke2tleVN5c3RlbX1cImApKTtcbiAgICAgICAgfVxuICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcbiAgICB9KTtcbiAgfVxuICBzZWxlY3RLZXlTeXN0ZW1Gb3JtYXQoZnJhZykge1xuICAgIGNvbnN0IGtleUZvcm1hdHMgPSBPYmplY3Qua2V5cyhmcmFnLmxldmVsa2V5cyB8fCB7fSk7XG4gICAgaWYgKCF0aGlzLmtleUZvcm1hdFByb21pc2UpIHtcbiAgICAgIHRoaXMubG9nKGBTZWxlY3Rpbmcga2V5LXN5c3RlbSBmcm9tIGZyYWdtZW50IChzbjogJHtmcmFnLnNufSAke2ZyYWcudHlwZX06ICR7ZnJhZy5sZXZlbH0pIGtleSBmb3JtYXRzICR7a2V5Rm9ybWF0cy5qb2luKCcsICcpfWApO1xuICAgICAgdGhpcy5rZXlGb3JtYXRQcm9taXNlID0gdGhpcy5nZXRLZXlGb3JtYXRQcm9taXNlKGtleUZvcm1hdHMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5rZXlGb3JtYXRQcm9taXNlO1xuICB9XG4gIGdldEtleUZvcm1hdFByb21pc2Uoa2V5Rm9ybWF0cykge1xuICAgIGNvbnN0IGtleVN5c3RlbXNJbkNvbmZpZyA9IGdldEtleVN5c3RlbXNGb3JDb25maWcodGhpcy5jb25maWcpO1xuICAgIGNvbnN0IGtleVN5c3RlbXNUb0F0dGVtcHQgPSBrZXlGb3JtYXRzLm1hcChrZXlTeXN0ZW1Gb3JtYXRUb0tleVN5c3RlbURvbWFpbikuZmlsdGVyKHZhbHVlID0+ICEhdmFsdWUgJiYga2V5U3lzdGVtc0luQ29uZmlnLmluZGV4T2YodmFsdWUpICE9PSAtMSk7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0S2V5U3lzdGVtKGtleVN5c3RlbXNUb0F0dGVtcHQpO1xuICB9XG4gIGxvYWRLZXkoZGF0YSkge1xuICAgIGNvbnN0IGRlY3J5cHRkYXRhID0gZGF0YS5rZXlJbmZvLmRlY3J5cHRkYXRhO1xuICAgIGNvbnN0IGtleUlkID0gdGhpcy5nZXRLZXlJZFN0cmluZyhkZWNyeXB0ZGF0YSk7XG4gICAgY29uc3Qga2V5RGV0YWlscyA9IGAoa2V5SWQ6ICR7a2V5SWR9IGZvcm1hdDogXCIke2RlY3J5cHRkYXRhLmtleUZvcm1hdH1cIiBtZXRob2Q6ICR7ZGVjcnlwdGRhdGEubWV0aG9kfSB1cmk6ICR7ZGVjcnlwdGRhdGEudXJpfSlgO1xuICAgIHRoaXMubG9nKGBTdGFydGluZyBzZXNzaW9uIGZvciBrZXkgJHtrZXlEZXRhaWxzfWApO1xuICAgIGxldCBrZXlDb250ZXh0UHJvbWlzZSA9IHRoaXMua2V5SWRUb0tleVNlc3Npb25Qcm9taXNlW2tleUlkXTtcbiAgICBpZiAoIWtleUNvbnRleHRQcm9taXNlKSB7XG4gICAgICBrZXlDb250ZXh0UHJvbWlzZSA9IHRoaXMuZ2V0S2V5U3lzdGVtRm9yS2V5UHJvbWlzZShkZWNyeXB0ZGF0YSkudGhlbigoe1xuICAgICAgICBrZXlTeXN0ZW0sXG4gICAgICAgIG1lZGlhS2V5c1xuICAgICAgfSkgPT4ge1xuICAgICAgICB0aGlzLnRocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgdGhpcy5sb2coYEhhbmRsZSBlbmNyeXB0ZWQgbWVkaWEgc246ICR7ZGF0YS5mcmFnLnNufSAke2RhdGEuZnJhZy50eXBlfTogJHtkYXRhLmZyYWcubGV2ZWx9IHVzaW5nIGtleSAke2tleURldGFpbHN9YCk7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dGVtcHRTZXRNZWRpYUtleXMoa2V5U3lzdGVtLCBtZWRpYUtleXMpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHRoaXMudGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU1lZGlhS2V5U2Vzc2lvbkNvbnRleHQoe1xuICAgICAgICAgICAga2V5U3lzdGVtLFxuICAgICAgICAgICAgbWVkaWFLZXlzLFxuICAgICAgICAgICAgZGVjcnlwdGRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGtleVNlc3Npb25Db250ZXh0UHJvbWlzZSA9IHRoaXMua2V5SWRUb0tleVNlc3Npb25Qcm9taXNlW2tleUlkXSA9IGtleUNvbnRleHRQcm9taXNlLnRoZW4oa2V5U2Vzc2lvbkNvbnRleHQgPT4ge1xuICAgICAgICBjb25zdCBzY2hlbWUgPSAnY2VuYyc7XG4gICAgICAgIGNvbnN0IGluaXREYXRhID0gZGVjcnlwdGRhdGEucHNzaCA/IGRlY3J5cHRkYXRhLnBzc2guYnVmZmVyIDogbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVSZXF1ZXN0V2l0aFByZWZlcnJlZEtleVNlc3Npb24oa2V5U2Vzc2lvbkNvbnRleHQsIHNjaGVtZSwgaW5pdERhdGEsICdwbGF5bGlzdC1rZXknKTtcbiAgICAgIH0pO1xuICAgICAga2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlLmNhdGNoKGVycm9yID0+IHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleUNvbnRleHRQcm9taXNlO1xuICB9XG4gIHRocm93SWZEZXN0cm95ZWQobWVzc2FnZSA9ICdJbnZhbGlkIHN0YXRlJykge1xuICAgIGlmICghdGhpcy5obHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzdGF0ZScpO1xuICAgIH1cbiAgfVxuICBoYW5kbGVFcnJvcihlcnJvcikge1xuICAgIGlmICghdGhpcy5obHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFTUVLZXlFcnJvcikge1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIGVycm9yLmRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX05PX0tFWVMsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldEtleVN5c3RlbUZvcktleVByb21pc2UoZGVjcnlwdGRhdGEpIHtcbiAgICBjb25zdCBrZXlJZCA9IHRoaXMuZ2V0S2V5SWRTdHJpbmcoZGVjcnlwdGRhdGEpO1xuICAgIGNvbnN0IG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQgPSB0aGlzLmtleUlkVG9LZXlTZXNzaW9uUHJvbWlzZVtrZXlJZF07XG4gICAgaWYgKCFtZWRpYUtleVNlc3Npb25Db250ZXh0KSB7XG4gICAgICBjb25zdCBrZXlTeXN0ZW0gPSBrZXlTeXN0ZW1Gb3JtYXRUb0tleVN5c3RlbURvbWFpbihkZWNyeXB0ZGF0YS5rZXlGb3JtYXQpO1xuICAgICAgY29uc3Qga2V5U3lzdGVtc1RvQXR0ZW1wdCA9IGtleVN5c3RlbSA/IFtrZXlTeXN0ZW1dIDogZ2V0S2V5U3lzdGVtc0ZvckNvbmZpZyh0aGlzLmNvbmZpZyk7XG4gICAgICByZXR1cm4gdGhpcy5hdHRlbXB0S2V5U3lzdGVtQWNjZXNzKGtleVN5c3RlbXNUb0F0dGVtcHQpO1xuICAgIH1cbiAgICByZXR1cm4gbWVkaWFLZXlTZXNzaW9uQ29udGV4dDtcbiAgfVxuICBnZXRLZXlTeXN0ZW1TZWxlY3Rpb25Qcm9taXNlKGtleVN5c3RlbXNUb0F0dGVtcHQpIHtcbiAgICBpZiAoIWtleVN5c3RlbXNUb0F0dGVtcHQubGVuZ3RoKSB7XG4gICAgICBrZXlTeXN0ZW1zVG9BdHRlbXB0ID0gZ2V0S2V5U3lzdGVtc0ZvckNvbmZpZyh0aGlzLmNvbmZpZyk7XG4gICAgfVxuICAgIGlmIChrZXlTeXN0ZW1zVG9BdHRlbXB0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVNRUtleUVycm9yKHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9OT19DT05GSUdVUkVEX0xJQ0VOU0UsXG4gICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICB9LCBgTWlzc2luZyBrZXktc3lzdGVtIGxpY2Vuc2UgY29uZmlndXJhdGlvbiBvcHRpb25zICR7c3RyaW5naWZ5KHtcbiAgICAgICAgZHJtU3lzdGVtczogdGhpcy5jb25maWcuZHJtU3lzdGVtc1xuICAgICAgfSl9YCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmF0dGVtcHRLZXlTeXN0ZW1BY2Nlc3Moa2V5U3lzdGVtc1RvQXR0ZW1wdCk7XG4gIH1cbiAgYXR0ZW1wdFNldE1lZGlhS2V5cyhrZXlTeXN0ZW0sIG1lZGlhS2V5cykge1xuICAgIGlmICh0aGlzLm1lZGlhS2V5cyA9PT0gbWVkaWFLZXlzKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IHF1ZXVlID0gdGhpcy5zZXRNZWRpYUtleXNRdWV1ZS5zbGljZSgpO1xuICAgIHRoaXMubG9nKGBTZXR0aW5nIG1lZGlhLWtleXMgZm9yIFwiJHtrZXlTeXN0ZW19XCJgKTtcbiAgICAvLyBPbmx5IG9uZSBzZXRNZWRpYUtleXMoKSBjYW4gcnVuIGF0IG9uZSB0aW1lLCBhbmQgbXVsdGlwbGUgc2V0TWVkaWFLZXlzKCkgb3BlcmF0aW9uc1xuICAgIC8vIGNhbiBiZSBxdWV1ZWQgZm9yIGV4ZWN1dGlvbiBmb3IgbXVsdGlwbGUga2V5IHNlc3Npb25zLlxuICAgIGNvbnN0IHNldE1lZGlhS2V5c1Byb21pc2UgPSBQcm9taXNlLmFsbChxdWV1ZSkudGhlbigoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgICAgdGhpcy5tZWRpYUtleXMgPSBudWxsO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byBzZXQgbWVkaWFLZXlzIHdpdGhvdXQgbWVkaWEgZWxlbWVudCBhdHRhY2hlZCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubWVkaWEuc2V0TWVkaWFLZXlzKG1lZGlhS2V5cyk7XG4gICAgfSk7XG4gICAgdGhpcy5tZWRpYUtleXMgPSBtZWRpYUtleXM7XG4gICAgdGhpcy5zZXRNZWRpYUtleXNRdWV1ZS5wdXNoKHNldE1lZGlhS2V5c1Byb21pc2UpO1xuICAgIHJldHVybiBzZXRNZWRpYUtleXNQcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5sb2coYE1lZGlhLWtleXMgc2V0IGZvciBcIiR7a2V5U3lzdGVtfVwiYCk7XG4gICAgICBxdWV1ZS5wdXNoKHNldE1lZGlhS2V5c1Byb21pc2UpO1xuICAgICAgdGhpcy5zZXRNZWRpYUtleXNRdWV1ZSA9IHRoaXMuc2V0TWVkaWFLZXlzUXVldWUuZmlsdGVyKHAgPT4gcXVldWUuaW5kZXhPZihwKSA9PT0gLTEpO1xuICAgIH0pO1xuICB9XG4gIGdlbmVyYXRlUmVxdWVzdFdpdGhQcmVmZXJyZWRLZXlTZXNzaW9uKGNvbnRleHQsIGluaXREYXRhVHlwZSwgaW5pdERhdGEsIHJlYXNvbikge1xuICAgIHZhciBfdGhpcyRjb25maWckZHJtU3lzdGUsIF90aGlzJGNvbmZpZyRkcm1TeXN0ZTI7XG4gICAgY29uc3QgZ2VuZXJhdGVSZXF1ZXN0RmlsdGVyID0gKF90aGlzJGNvbmZpZyRkcm1TeXN0ZSA9IHRoaXMuY29uZmlnLmRybVN5c3RlbXMpID09IG51bGwgPyB2b2lkIDAgOiAoX3RoaXMkY29uZmlnJGRybVN5c3RlMiA9IF90aGlzJGNvbmZpZyRkcm1TeXN0ZVtjb250ZXh0LmtleVN5c3RlbV0pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRjb25maWckZHJtU3lzdGUyLmdlbmVyYXRlUmVxdWVzdDtcbiAgICBpZiAoZ2VuZXJhdGVSZXF1ZXN0RmlsdGVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBtYXBwZWRJbml0RGF0YSA9IGdlbmVyYXRlUmVxdWVzdEZpbHRlci5jYWxsKHRoaXMuaGxzLCBpbml0RGF0YVR5cGUsIGluaXREYXRhLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKCFtYXBwZWRJbml0RGF0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZXNwb25zZSBmcm9tIGNvbmZpZ3VyZWQgZ2VuZXJhdGVSZXF1ZXN0IGZpbHRlcicpO1xuICAgICAgICB9XG4gICAgICAgIGluaXREYXRhVHlwZSA9IG1hcHBlZEluaXREYXRhLmluaXREYXRhVHlwZTtcbiAgICAgICAgaW5pdERhdGEgPSBtYXBwZWRJbml0RGF0YS5pbml0RGF0YSA/IG1hcHBlZEluaXREYXRhLmluaXREYXRhIDogbnVsbDtcbiAgICAgICAgY29udGV4dC5kZWNyeXB0ZGF0YS5wc3NoID0gaW5pdERhdGEgPyBuZXcgVWludDhBcnJheShpbml0RGF0YSkgOiBudWxsO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdmFyIF90aGlzJGhscztcbiAgICAgICAgdGhpcy53YXJuKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICBpZiAoKF90aGlzJGhscyA9IHRoaXMuaGxzKSAhPSBudWxsICYmIF90aGlzJGhscy5jb25maWcuZGVidWcpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5pdERhdGEgPT09IG51bGwpIHtcbiAgICAgIHRoaXMubG9nKGBTa2lwcGluZyBrZXktc2Vzc2lvbiByZXF1ZXN0IGZvciBcIiR7cmVhc29ufVwiIChubyBpbml0RGF0YSlgKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY29udGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGtleUlkID0gdGhpcy5nZXRLZXlJZFN0cmluZyhjb250ZXh0LmRlY3J5cHRkYXRhKTtcbiAgICB0aGlzLmxvZyhgR2VuZXJhdGluZyBrZXktc2Vzc2lvbiByZXF1ZXN0IGZvciBcIiR7cmVhc29ufVwiOiAke2tleUlkfSAoaW5pdCBkYXRhIHR5cGU6ICR7aW5pdERhdGFUeXBlfSBsZW5ndGg6ICR7aW5pdERhdGEgPyBpbml0RGF0YS5ieXRlTGVuZ3RoIDogbnVsbH0pYCk7XG4gICAgY29uc3QgbGljZW5zZVN0YXR1cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICBjb25zdCBvbm1lc3NhZ2UgPSBjb250ZXh0Ll9vbm1lc3NhZ2UgPSBldmVudCA9PiB7XG4gICAgICBjb25zdCBrZXlTZXNzaW9uID0gY29udGV4dC5tZWRpYUtleXNTZXNzaW9uO1xuICAgICAgaWYgKCFrZXlTZXNzaW9uKSB7XG4gICAgICAgIGxpY2Vuc2VTdGF0dXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ2ludmFsaWQgc3RhdGUnKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWVzc2FnZVR5cGUsXG4gICAgICAgIG1lc3NhZ2VcbiAgICAgIH0gPSBldmVudDtcbiAgICAgIHRoaXMubG9nKGBcIiR7bWVzc2FnZVR5cGV9XCIgbWVzc2FnZSBldmVudCBmb3Igc2Vzc2lvbiBcIiR7a2V5U2Vzc2lvbi5zZXNzaW9uSWR9XCIgbWVzc2FnZSBzaXplOiAke21lc3NhZ2UuYnl0ZUxlbmd0aH1gKTtcbiAgICAgIGlmIChtZXNzYWdlVHlwZSA9PT0gJ2xpY2Vuc2UtcmVxdWVzdCcgfHwgbWVzc2FnZVR5cGUgPT09ICdsaWNlbnNlLXJlbmV3YWwnKSB7XG4gICAgICAgIHRoaXMucmVuZXdMaWNlbnNlKGNvbnRleHQsIG1lc3NhZ2UpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICBpZiAobGljZW5zZVN0YXR1cy5ldmVudE5hbWVzKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICBsaWNlbnNlU3RhdHVzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUVycm9yKGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChtZXNzYWdlVHlwZSA9PT0gJ2xpY2Vuc2UtcmVsZWFzZScpIHtcbiAgICAgICAgaWYgKGNvbnRleHQua2V5U3lzdGVtID09PSBLZXlTeXN0ZW1zLkZBSVJQTEFZKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVLZXlTZXNzaW9uKGNvbnRleHQsIHN0clRvVXRmOGFycmF5KCdhY2tub3dsZWRnZWQnKSk7XG4gICAgICAgICAgdGhpcy5yZW1vdmVTZXNzaW9uKGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLndhcm4oYHVuaGFuZGxlZCBtZWRpYSBrZXkgbWVzc2FnZSB0eXBlIFwiJHttZXNzYWdlVHlwZX1cImApO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgb25rZXlzdGF0dXNlc2NoYW5nZSA9IGNvbnRleHQuX29ua2V5c3RhdHVzZXNjaGFuZ2UgPSBldmVudCA9PiB7XG4gICAgICBjb25zdCBrZXlTZXNzaW9uID0gY29udGV4dC5tZWRpYUtleXNTZXNzaW9uO1xuICAgICAgaWYgKCFrZXlTZXNzaW9uKSB7XG4gICAgICAgIGxpY2Vuc2VTdGF0dXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ2ludmFsaWQgc3RhdGUnKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMub25LZXlTdGF0dXNDaGFuZ2UoY29udGV4dCk7XG4gICAgICBjb25zdCBrZXlTdGF0dXMgPSBjb250ZXh0LmtleVN0YXR1cztcbiAgICAgIGxpY2Vuc2VTdGF0dXMuZW1pdCgna2V5U3RhdHVzJywga2V5U3RhdHVzKTtcbiAgICAgIGlmIChrZXlTdGF0dXMgPT09ICdleHBpcmVkJykge1xuICAgICAgICB0aGlzLndhcm4oYCR7Y29udGV4dC5rZXlTeXN0ZW19IGV4cGlyZWQgZm9yIGtleSAke2tleUlkfWApO1xuICAgICAgICB0aGlzLnJlbmV3S2V5U2Vzc2lvbihjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoY29udGV4dC5tZWRpYUtleXNTZXNzaW9uLCAnbWVzc2FnZScsIG9ubWVzc2FnZSk7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihjb250ZXh0Lm1lZGlhS2V5c1Nlc3Npb24sICdrZXlzdGF0dXNlc2NoYW5nZScsIG9ua2V5c3RhdHVzZXNjaGFuZ2UpO1xuICAgIGNvbnN0IGtleVVzYWJsZVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsaWNlbnNlU3RhdHVzLm9uKCdlcnJvcicsIHJlamVjdCk7XG4gICAgICBsaWNlbnNlU3RhdHVzLm9uKCdrZXlTdGF0dXMnLCBrZXlTdGF0dXMgPT4ge1xuICAgICAgICBpZiAoa2V5U3RhdHVzLnN0YXJ0c1dpdGgoJ3VzYWJsZScpKSB7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGtleVN0YXR1cyA9PT0gJ291dHB1dC1yZXN0cmljdGVkJykge1xuICAgICAgICAgIHJlamVjdChuZXcgRU1FS2V5RXJyb3Ioe1xuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fU1RBVFVTX09VVFBVVF9SRVNUUklDVEVELFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlXG4gICAgICAgICAgfSwgJ0hEQ1AgbGV2ZWwgb3V0cHV0IHJlc3RyaWN0ZWQnKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5U3RhdHVzID09PSAnaW50ZXJuYWwtZXJyb3InKSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFTUVLZXlFcnJvcih7XG4gICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9TVEFUVVNfSU5URVJOQUxfRVJST1IsXG4gICAgICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgICAgIH0sIGBrZXkgc3RhdHVzIGNoYW5nZWQgdG8gXCIke2tleVN0YXR1c31cImApKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXlTdGF0dXMgPT09ICdleHBpcmVkJykge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ2tleSBleHBpcmVkIHdoaWxlIGdlbmVyYXRpbmcgcmVxdWVzdCcpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLndhcm4oYHVuaGFuZGxlZCBrZXkgc3RhdHVzIGNoYW5nZSBcIiR7a2V5U3RhdHVzfVwiYCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBjb250ZXh0Lm1lZGlhS2V5c1Nlc3Npb24uZ2VuZXJhdGVSZXF1ZXN0KGluaXREYXRhVHlwZSwgaW5pdERhdGEpLnRoZW4oKCkgPT4ge1xuICAgICAgdmFyIF9jb250ZXh0JG1lZGlhS2V5c1NlcztcbiAgICAgIHRoaXMubG9nKGBSZXF1ZXN0IGdlbmVyYXRlZCBmb3Iga2V5LXNlc3Npb24gXCIkeyhfY29udGV4dCRtZWRpYUtleXNTZXMgPSBjb250ZXh0Lm1lZGlhS2V5c1Nlc3Npb24pID09IG51bGwgPyB2b2lkIDAgOiBfY29udGV4dCRtZWRpYUtleXNTZXMuc2Vzc2lvbklkfVwiIGtleUlkOiAke2tleUlkfWApO1xuICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgIHRocm93IG5ldyBFTUVLZXlFcnJvcih7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fTk9fU0VTU0lPTixcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGZhdGFsOiBmYWxzZVxuICAgICAgfSwgYEVycm9yIGdlbmVyYXRpbmcga2V5LXNlc3Npb24gcmVxdWVzdDogJHtlcnJvcn1gKTtcbiAgICB9KS50aGVuKCgpID0+IGtleVVzYWJsZVByb21pc2UpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgIGxpY2Vuc2VTdGF0dXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLnJlbW92ZVNlc3Npb24oY29udGV4dCk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgIGxpY2Vuc2VTdGF0dXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9KTtcbiAgfVxuICBvbktleVN0YXR1c0NoYW5nZShtZWRpYUtleVNlc3Npb25Db250ZXh0KSB7XG4gICAgbWVkaWFLZXlTZXNzaW9uQ29udGV4dC5tZWRpYUtleXNTZXNzaW9uLmtleVN0YXR1c2VzLmZvckVhY2goKHN0YXR1cywga2V5SWQpID0+IHtcbiAgICAgIC8vIGtleVN0YXR1c2VzLmZvckVhY2ggaXMgbm90IHN0YW5kYXJkIEFQSSBzbyB0aGUgY2FsbGJhY2sgdmFsdWUgbG9va3Mgd2VpcmQgb24geGJveG9uZVxuICAgICAgLy8geGJveG9uZSBjYWxsYmFjayhrZXlJZCwgc3RhdHVzKSBzbyB3ZSBuZWVkIHRvIGV4Y2hhbmdlIHRoZW1cbiAgICAgIGlmICh0eXBlb2Yga2V5SWQgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBzdGF0dXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbnN0IHRlbXAgPSBrZXlJZDtcbiAgICAgICAga2V5SWQgPSBzdGF0dXM7XG4gICAgICAgIHN0YXR1cyA9IHRlbXA7XG4gICAgICB9XG4gICAgICB0aGlzLmxvZyhga2V5IHN0YXR1cyBjaGFuZ2UgXCIke3N0YXR1c31cIiBmb3Iga2V5U3RhdHVzZXMga2V5SWQ6ICR7SGV4LmhleER1bXAoJ2J1ZmZlcicgaW4ga2V5SWQgPyBuZXcgVWludDhBcnJheShrZXlJZC5idWZmZXIsIGtleUlkLmJ5dGVPZmZzZXQsIGtleUlkLmJ5dGVMZW5ndGgpIDogbmV3IFVpbnQ4QXJyYXkoa2V5SWQpKX0gc2Vzc2lvbiBrZXlJZDogJHtIZXguaGV4RHVtcChuZXcgVWludDhBcnJheShtZWRpYUtleVNlc3Npb25Db250ZXh0LmRlY3J5cHRkYXRhLmtleUlkIHx8IFtdKSl9IHVyaTogJHttZWRpYUtleVNlc3Npb25Db250ZXh0LmRlY3J5cHRkYXRhLnVyaX1gKTtcbiAgICAgIG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQua2V5U3RhdHVzID0gc3RhdHVzO1xuICAgIH0pO1xuICB9XG4gIGZldGNoU2VydmVyQ2VydGlmaWNhdGUoa2V5U3lzdGVtKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgY29uc3QgTG9hZGVyID0gY29uZmlnLmxvYWRlcjtcbiAgICBjb25zdCBjZXJ0TG9hZGVyID0gbmV3IExvYWRlcihjb25maWcpO1xuICAgIGNvbnN0IHVybCA9IHRoaXMuZ2V0U2VydmVyQ2VydGlmaWNhdGVVcmwoa2V5U3lzdGVtKTtcbiAgICBpZiAoIXVybCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICB0aGlzLmxvZyhgRmV0Y2hpbmcgc2VydmVyIGNlcnRpZmljYXRlIGZvciBcIiR7a2V5U3lzdGVtfVwiYCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGxvYWRlckNvbnRleHQgPSB7XG4gICAgICAgIHJlc3BvbnNlVHlwZTogJ2FycmF5YnVmZmVyJyxcbiAgICAgICAgdXJsXG4gICAgICB9O1xuICAgICAgY29uc3QgbG9hZFBvbGljeSA9IGNvbmZpZy5jZXJ0TG9hZFBvbGljeS5kZWZhdWx0O1xuICAgICAgY29uc3QgbG9hZGVyQ29uZmlnID0ge1xuICAgICAgICBsb2FkUG9saWN5LFxuICAgICAgICB0aW1lb3V0OiBsb2FkUG9saWN5Lm1heExvYWRUaW1lTXMsXG4gICAgICAgIG1heFJldHJ5OiAwLFxuICAgICAgICByZXRyeURlbGF5OiAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5OiAwXG4gICAgICB9O1xuICAgICAgY29uc3QgbG9hZGVyQ2FsbGJhY2tzID0ge1xuICAgICAgICBvblN1Y2Nlc3M6IChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZShyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FcnJvcjogKHJlc3BvbnNlLCBjb250ZXgsIG5ldHdvcmtEZXRhaWxzLCBzdGF0cykgPT4ge1xuICAgICAgICAgIHJlamVjdChuZXcgRU1FS2V5RXJyb3Ioe1xuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fU0VSVkVSX0NFUlRJRklDQVRFX1JFUVVFU1RfRkFJTEVELFxuICAgICAgICAgICAgZmF0YWw6IHRydWUsXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICAgIHJlc3BvbnNlOiBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgICAgIHVybDogbG9hZGVyQ29udGV4dC51cmwsXG4gICAgICAgICAgICAgIGRhdGE6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSwgcmVzcG9uc2UpXG4gICAgICAgICAgfSwgYFwiJHtrZXlTeXN0ZW19XCIgY2VydGlmaWNhdGUgcmVxdWVzdCBmYWlsZWQgKCR7dXJsfSkuIFN0YXR1czogJHtyZXNwb25zZS5jb2RlfSAoJHtyZXNwb25zZS50ZXh0fSlgKSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uVGltZW91dDogKHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICAgIHJlamVjdChuZXcgRU1FS2V5RXJyb3Ioe1xuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fU0VSVkVSX0NFUlRJRklDQVRFX1JFUVVFU1RfRkFJTEVELFxuICAgICAgICAgICAgZmF0YWw6IHRydWUsXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICAgIHVybDogbG9hZGVyQ29udGV4dC51cmwsXG4gICAgICAgICAgICAgIGRhdGE6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIGBcIiR7a2V5U3lzdGVtfVwiIGNlcnRpZmljYXRlIHJlcXVlc3QgdGltZWQgb3V0ICgke3VybH0pYCkpO1xuICAgICAgICB9LFxuICAgICAgICBvbkFib3J0OiAoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignYWJvcnRlZCcpKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNlcnRMb2FkZXIubG9hZChsb2FkZXJDb250ZXh0LCBsb2FkZXJDb25maWcsIGxvYWRlckNhbGxiYWNrcyk7XG4gICAgfSk7XG4gIH1cbiAgc2V0TWVkaWFLZXlzU2VydmVyQ2VydGlmaWNhdGUobWVkaWFLZXlzLCBrZXlTeXN0ZW0sIGNlcnQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbWVkaWFLZXlzLnNldFNlcnZlckNlcnRpZmljYXRlKGNlcnQpLnRoZW4oc3VjY2VzcyA9PiB7XG4gICAgICAgIHRoaXMubG9nKGBzZXRTZXJ2ZXJDZXJ0aWZpY2F0ZSAke3N1Y2Nlc3MgPyAnc3VjY2VzcycgOiAnbm90IHN1cHBvcnRlZCBieSBDRE0nfSAoJHtjZXJ0ID09IG51bGwgPyB2b2lkIDAgOiBjZXJ0LmJ5dGVMZW5ndGh9KSBvbiBcIiR7a2V5U3lzdGVtfVwiYCk7XG4gICAgICAgIHJlc29sdmUobWVkaWFLZXlzKTtcbiAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgcmVqZWN0KG5ldyBFTUVLZXlFcnJvcih7XG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX1NFUlZFUl9DRVJUSUZJQ0FURV9VUERBVEVfRkFJTEVELFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgIH0sIGVycm9yLm1lc3NhZ2UpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJlbmV3TGljZW5zZShjb250ZXh0LCBrZXlNZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdExpY2Vuc2UoY29udGV4dCwgbmV3IFVpbnQ4QXJyYXkoa2V5TWVzc2FnZSkpLnRoZW4oZGF0YSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy51cGRhdGVLZXlTZXNzaW9uKGNvbnRleHQsIG5ldyBVaW50OEFycmF5KGRhdGEpKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFTUVLZXlFcnJvcih7XG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX1NFU1NJT05fVVBEQVRFX0ZBSUxFRCxcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgICB9LCBlcnJvci5tZXNzYWdlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHVucGFja1BsYXlSZWFkeUtleU1lc3NhZ2UoeGhyLCBsaWNlbnNlQ2hhbGxlbmdlKSB7XG4gICAgLy8gT24gRWRnZSwgdGhlIHJhdyBsaWNlbnNlIG1lc3NhZ2UgaXMgVVRGLTE2LWVuY29kZWQgWE1MLiAgV2UgbmVlZFxuICAgIC8vIHRvIHVucGFjayB0aGUgQ2hhbGxlbmdlIGVsZW1lbnQgKGJhc2U2NC1lbmNvZGVkIHN0cmluZyBjb250YWluaW5nIHRoZVxuICAgIC8vIGFjdHVhbCBsaWNlbnNlIHJlcXVlc3QpIGFuZCBhbnkgSHR0cEhlYWRlciBlbGVtZW50cyAoc2VudCBhcyByZXF1ZXN0XG4gICAgLy8gaGVhZGVycykuXG4gICAgLy8gRm9yIFBsYXlSZWFkeSBDRE1zLCB3ZSBuZWVkIHRvIGRpZyB0aGUgQ2hhbGxlbmdlIG91dCBvZiB0aGUgWE1MLlxuICAgIGNvbnN0IHhtbFN0cmluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQxNkFycmF5KGxpY2Vuc2VDaGFsbGVuZ2UuYnVmZmVyKSk7XG4gICAgaWYgKCF4bWxTdHJpbmcuaW5jbHVkZXMoJ1BsYXlSZWFkeUtleU1lc3NhZ2UnKSkge1xuICAgICAgLy8gVGhpcyBkb2VzIG5vdCBhcHBlYXIgdG8gYmUgYSB3cmFwcGVkIG1lc3NhZ2UgYXMgb24gRWRnZS4gIFNvbWVcbiAgICAgIC8vIGNsaWVudHMgZG8gbm90IG5lZWQgdGhpcyB1bndyYXBwaW5nLCBzbyB3ZSB3aWxsIGFzc3VtZSB0aGlzIGlzIG9uZSBvZlxuICAgICAgLy8gdGhlbS4gIE5vdGUgdGhhdCBcInhtbFwiIGF0IHRoaXMgcG9pbnQgcHJvYmFibHkgbG9va3MgbGlrZSByYW5kb21cbiAgICAgIC8vIGdhcmJhZ2UsIHNpbmNlIHdlIGludGVycHJldGVkIFVURi04IGFzIFVURi0xNi5cbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAndGV4dC94bWw7IGNoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBsaWNlbnNlQ2hhbGxlbmdlO1xuICAgIH1cbiAgICBjb25zdCBrZXlNZXNzYWdlWG1sID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyh4bWxTdHJpbmcsICdhcHBsaWNhdGlvbi94bWwnKTtcbiAgICAvLyBTZXQgcmVxdWVzdCBoZWFkZXJzLlxuICAgIGNvbnN0IGhlYWRlcnMgPSBrZXlNZXNzYWdlWG1sLnF1ZXJ5U2VsZWN0b3JBbGwoJ0h0dHBIZWFkZXInKTtcbiAgICBpZiAoaGVhZGVycy5sZW5ndGggPiAwKSB7XG4gICAgICBsZXQgaGVhZGVyO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGhlYWRlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIF9oZWFkZXIkcXVlcnlTZWxlY3RvciwgX2hlYWRlciRxdWVyeVNlbGVjdG9yMjtcbiAgICAgICAgaGVhZGVyID0gaGVhZGVyc1tpXTtcbiAgICAgICAgY29uc3QgbmFtZSA9IChfaGVhZGVyJHF1ZXJ5U2VsZWN0b3IgPSBoZWFkZXIucXVlcnlTZWxlY3RvcignbmFtZScpKSA9PSBudWxsID8gdm9pZCAwIDogX2hlYWRlciRxdWVyeVNlbGVjdG9yLnRleHRDb250ZW50O1xuICAgICAgICBjb25zdCB2YWx1ZSA9IChfaGVhZGVyJHF1ZXJ5U2VsZWN0b3IyID0gaGVhZGVyLnF1ZXJ5U2VsZWN0b3IoJ3ZhbHVlJykpID09IG51bGwgPyB2b2lkIDAgOiBfaGVhZGVyJHF1ZXJ5U2VsZWN0b3IyLnRleHRDb250ZW50O1xuICAgICAgICBpZiAobmFtZSAmJiB2YWx1ZSkge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjaGFsbGVuZ2VFbGVtZW50ID0ga2V5TWVzc2FnZVhtbC5xdWVyeVNlbGVjdG9yKCdDaGFsbGVuZ2UnKTtcbiAgICBjb25zdCBjaGFsbGVuZ2VUZXh0ID0gY2hhbGxlbmdlRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogY2hhbGxlbmdlRWxlbWVudC50ZXh0Q29udGVudDtcbiAgICBpZiAoIWNoYWxsZW5nZVRleHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGZpbmQgPENoYWxsZW5nZT4gaW4ga2V5IG1lc3NhZ2VgKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0clRvVXRmOGFycmF5KGF0b2IoY2hhbGxlbmdlVGV4dCkpO1xuICB9XG4gIHNldHVwTGljZW5zZVhIUih4aHIsIHVybCwga2V5c0xpc3RJdGVtLCBsaWNlbnNlQ2hhbGxlbmdlKSB7XG4gICAgY29uc3QgbGljZW5zZVhoclNldHVwID0gdGhpcy5jb25maWcubGljZW5zZVhoclNldHVwO1xuICAgIGlmICghbGljZW5zZVhoclNldHVwKSB7XG4gICAgICB4aHIub3BlbignUE9TVCcsIHVybCwgdHJ1ZSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgeGhyLFxuICAgICAgICBsaWNlbnNlQ2hhbGxlbmdlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKCFrZXlzTGlzdEl0ZW0uZGVjcnlwdGRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdLZXkgcmVtb3ZlZCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpY2Vuc2VYaHJTZXR1cC5jYWxsKHRoaXMuaGxzLCB4aHIsIHVybCwga2V5c0xpc3RJdGVtLCBsaWNlbnNlQ2hhbGxlbmdlKTtcbiAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICBpZiAoIWtleXNMaXN0SXRlbS5kZWNyeXB0ZGF0YSkge1xuICAgICAgICAvLyBLZXkgc2Vzc2lvbiByZW1vdmVkLiBDYW5jZWwgbGljZW5zZSByZXF1ZXN0LlxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIC8vIGxldCdzIHRyeSB0byBvcGVuIGJlZm9yZSBydW5uaW5nIHNldHVwXG4gICAgICB4aHIub3BlbignUE9TVCcsIHVybCwgdHJ1ZSk7XG4gICAgICByZXR1cm4gbGljZW5zZVhoclNldHVwLmNhbGwodGhpcy5obHMsIHhociwgdXJsLCBrZXlzTGlzdEl0ZW0sIGxpY2Vuc2VDaGFsbGVuZ2UpO1xuICAgIH0pLnRoZW4obGljZW5zZVhoclNldHVwUmVzdWx0ID0+IHtcbiAgICAgIC8vIGlmIGxpY2Vuc2VYaHJTZXR1cCBkaWQgbm90IHlldCBjYWxsIG9wZW4sIGxldCdzIGRvIGl0IG5vd1xuICAgICAgaWYgKCF4aHIucmVhZHlTdGF0ZSkge1xuICAgICAgICB4aHIub3BlbignUE9TVCcsIHVybCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBmaW5hbExpY2Vuc2VDaGFsbGVuZ2UgPSBsaWNlbnNlWGhyU2V0dXBSZXN1bHQgPyBsaWNlbnNlWGhyU2V0dXBSZXN1bHQgOiBsaWNlbnNlQ2hhbGxlbmdlO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeGhyLFxuICAgICAgICBsaWNlbnNlQ2hhbGxlbmdlOiBmaW5hbExpY2Vuc2VDaGFsbGVuZ2VcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgcmVxdWVzdExpY2Vuc2Uoa2V5U2Vzc2lvbkNvbnRleHQsIGxpY2Vuc2VDaGFsbGVuZ2UpIHtcbiAgICBjb25zdCBrZXlMb2FkUG9saWN5ID0gdGhpcy5jb25maWcua2V5TG9hZFBvbGljeS5kZWZhdWx0O1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCB1cmwgPSB0aGlzLmdldExpY2Vuc2VTZXJ2ZXJVcmxPclRocm93KGtleVNlc3Npb25Db250ZXh0LmtleVN5c3RlbSk7XG4gICAgICB0aGlzLmxvZyhgU2VuZGluZyBsaWNlbnNlIHJlcXVlc3QgdG8gVVJMOiAke3VybH1gKTtcbiAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuaGxzIHx8ICFrZXlTZXNzaW9uQ29udGV4dC5tZWRpYUtleXNTZXNzaW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ2ludmFsaWQgc3RhdGUnKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgaWYgKHhoci5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdExpY2Vuc2VGYWlsdXJlQ291bnQgPSAwO1xuICAgICAgICAgICAgbGV0IGRhdGEgPSB4aHIucmVzcG9uc2U7XG4gICAgICAgICAgICB0aGlzLmxvZyhgTGljZW5zZSByZWNlaXZlZCAke2RhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IGRhdGEuYnl0ZUxlbmd0aCA6IGRhdGF9YCk7XG4gICAgICAgICAgICBjb25zdCBsaWNlbnNlUmVzcG9uc2VDYWxsYmFjayA9IHRoaXMuY29uZmlnLmxpY2Vuc2VSZXNwb25zZUNhbGxiYWNrO1xuICAgICAgICAgICAgaWYgKGxpY2Vuc2VSZXNwb25zZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGxpY2Vuc2VSZXNwb25zZUNhbGxiYWNrLmNhbGwodGhpcy5obHMsIHhociwgdXJsLCBrZXlTZXNzaW9uQ29udGV4dCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHJldHJ5Q29uZmlnID0ga2V5TG9hZFBvbGljeS5lcnJvclJldHJ5O1xuICAgICAgICAgICAgY29uc3QgbWF4TnVtUmV0cnkgPSByZXRyeUNvbmZpZyA/IHJldHJ5Q29uZmlnLm1heE51bVJldHJ5IDogMDtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50Kys7XG4gICAgICAgICAgICBpZiAodGhpcy5fcmVxdWVzdExpY2Vuc2VGYWlsdXJlQ291bnQgPiBtYXhOdW1SZXRyeSB8fCB4aHIuc3RhdHVzID49IDQwMCAmJiB4aHIuc3RhdHVzIDwgNTAwKSB7XG4gICAgICAgICAgICAgIHJlamVjdChuZXcgRU1FS2V5RXJyb3Ioe1xuICAgICAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9MSUNFTlNFX1JFUVVFU1RfRkFJTEVELFxuICAgICAgICAgICAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiB4aHIsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICAgIGRhdGE6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgIGNvZGU6IHhoci5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICB0ZXh0OiB4aHIuc3RhdHVzVGV4dFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSwgYExpY2Vuc2UgUmVxdWVzdCBYSFIgZmFpbGVkICgke3VybH0pLiBTdGF0dXM6ICR7eGhyLnN0YXR1c30gKCR7eGhyLnN0YXR1c1RleHR9KWApKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IGF0dGVtcHRzTGVmdCA9IG1heE51bVJldHJ5IC0gdGhpcy5fcmVxdWVzdExpY2Vuc2VGYWlsdXJlQ291bnQgKyAxO1xuICAgICAgICAgICAgICB0aGlzLndhcm4oYFJldHJ5aW5nIGxpY2Vuc2UgcmVxdWVzdCwgJHthdHRlbXB0c0xlZnR9IGF0dGVtcHRzIGxlZnRgKTtcbiAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0TGljZW5zZShrZXlTZXNzaW9uQ29udGV4dCwgbGljZW5zZUNoYWxsZW5nZSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChrZXlTZXNzaW9uQ29udGV4dC5saWNlbnNlWGhyICYmIGtleVNlc3Npb25Db250ZXh0LmxpY2Vuc2VYaHIucmVhZHlTdGF0ZSAhPT0gWE1MSHR0cFJlcXVlc3QuRE9ORSkge1xuICAgICAgICBrZXlTZXNzaW9uQ29udGV4dC5saWNlbnNlWGhyLmFib3J0KCk7XG4gICAgICB9XG4gICAgICBrZXlTZXNzaW9uQ29udGV4dC5saWNlbnNlWGhyID0geGhyO1xuICAgICAgdGhpcy5zZXR1cExpY2Vuc2VYSFIoeGhyLCB1cmwsIGtleVNlc3Npb25Db250ZXh0LCBsaWNlbnNlQ2hhbGxlbmdlKS50aGVuKCh7XG4gICAgICAgIHhocixcbiAgICAgICAgbGljZW5zZUNoYWxsZW5nZVxuICAgICAgfSkgPT4ge1xuICAgICAgICBpZiAoa2V5U2Vzc2lvbkNvbnRleHQua2V5U3lzdGVtID09IEtleVN5c3RlbXMuUExBWVJFQURZKSB7XG4gICAgICAgICAgbGljZW5zZUNoYWxsZW5nZSA9IHRoaXMudW5wYWNrUGxheVJlYWR5S2V5TWVzc2FnZSh4aHIsIGxpY2Vuc2VDaGFsbGVuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHhoci5zZW5kKGxpY2Vuc2VDaGFsbGVuZ2UpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgb25EZXN0cm95aW5nKCkge1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHRoaXMuX2NsZWFyKCk7XG4gIH1cbiAgb25NZWRpYUF0dGFjaGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKCF0aGlzLmNvbmZpZy5lbWVFbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1lZGlhID0gZGF0YS5tZWRpYTtcblxuICAgIC8vIGtlZXAgcmVmZXJlbmNlIG9mIG1lZGlhXG4gICAgdGhpcy5tZWRpYSA9IG1lZGlhO1xuICAgIGFkZEV2ZW50TGlzdGVuZXIobWVkaWEsICd3YWl0aW5nZm9ya2V5JywgdGhpcy5vbldhaXRpbmdGb3JLZXkpO1xuICB9XG4gIG9uTWVkaWFEZXRhY2hlZCgpIHtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKG1lZGlhLCAnd2FpdGluZ2ZvcmtleScsIHRoaXMub25XYWl0aW5nRm9yS2V5KTtcbiAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgICAgdGhpcy5tZWRpYUtleXMgPSBudWxsO1xuICAgIH1cbiAgfVxuICBfY2xlYXIoKSB7XG4gICAgdmFyIF9tZWRpYSRzZXRNZWRpYUtleXM7XG4gICAgdGhpcy5fcmVxdWVzdExpY2Vuc2VGYWlsdXJlQ291bnQgPSAwO1xuICAgIHRoaXMua2V5SWRUb0tleVNlc3Npb25Qcm9taXNlID0ge307XG4gICAgaWYgKCF0aGlzLm1lZGlhS2V5cyAmJiAhdGhpcy5tZWRpYUtleVNlc3Npb25zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgY29uc3QgbWVkaWFLZXlzTGlzdCA9IHRoaXMubWVkaWFLZXlTZXNzaW9ucy5zbGljZSgpO1xuICAgIHRoaXMubWVkaWFLZXlTZXNzaW9ucyA9IFtdO1xuICAgIHRoaXMubWVkaWFLZXlzID0gbnVsbDtcbiAgICBMZXZlbEtleS5jbGVhcktleVVyaVRvS2V5SWRNYXAoKTtcblxuICAgIC8vIENsb3NlIGFsbCBzZXNzaW9ucyBhbmQgcmVtb3ZlIG1lZGlhIGtleXMgZnJvbSB0aGUgdmlkZW8gZWxlbWVudC5cbiAgICBjb25zdCBrZXlTZXNzaW9uQ291bnQgPSBtZWRpYUtleXNMaXN0Lmxlbmd0aDtcbiAgICBFTUVDb250cm9sbGVyLkNETUNsZWFudXBQcm9taXNlID0gUHJvbWlzZS5hbGwobWVkaWFLZXlzTGlzdC5tYXAobWVkaWFLZXlTZXNzaW9uQ29udGV4dCA9PiB0aGlzLnJlbW92ZVNlc3Npb24obWVkaWFLZXlTZXNzaW9uQ29udGV4dCkpLmNvbmNhdChtZWRpYSA9PSBudWxsID8gdm9pZCAwIDogKF9tZWRpYSRzZXRNZWRpYUtleXMgPSBtZWRpYS5zZXRNZWRpYUtleXMobnVsbCkpID09IG51bGwgPyB2b2lkIDAgOiBfbWVkaWEkc2V0TWVkaWFLZXlzLmNhdGNoKGVycm9yID0+IHtcbiAgICAgIHZhciBfdGhpcyRobHMyO1xuICAgICAgdGhpcy5sb2coYENvdWxkIG5vdCBjbGVhciBtZWRpYSBrZXlzOiAke2Vycm9yfWApO1xuICAgICAgKF90aGlzJGhsczIgPSB0aGlzLmhscykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGhsczIudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5PVEhFUl9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fREVTVFJPWV9NRURJQV9LRVlTX0VSUk9SLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIGVycm9yOiBuZXcgRXJyb3IoYENvdWxkIG5vdCBjbGVhciBtZWRpYSBrZXlzOiAke2Vycm9yfWApXG4gICAgICB9KTtcbiAgICB9KSkpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgIHZhciBfdGhpcyRobHMzO1xuICAgICAgdGhpcy5sb2coYENvdWxkIG5vdCBjbG9zZSBzZXNzaW9ucyBhbmQgY2xlYXIgbWVkaWEga2V5czogJHtlcnJvcn1gKTtcbiAgICAgIChfdGhpcyRobHMzID0gdGhpcy5obHMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRobHMzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuT1RIRVJfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX0RFU1RST1lfQ0xPU0VfU0VTU0lPTl9FUlJPUixcbiAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICBlcnJvcjogbmV3IEVycm9yKGBDb3VsZCBub3QgY2xvc2Ugc2Vzc2lvbnMgYW5kIGNsZWFyIG1lZGlhIGtleXM6ICR7ZXJyb3J9YClcbiAgICAgIH0pO1xuICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKGtleVNlc3Npb25Db3VudCkge1xuICAgICAgICB0aGlzLmxvZygnZmluaXNoZWQgY2xvc2luZyBrZXkgc2Vzc2lvbnMgYW5kIGNsZWFyaW5nIG1lZGlhIGtleXMnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLmtleUZvcm1hdFByb21pc2UgPSBudWxsO1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkZWQoZXZlbnQsIHtcbiAgICBzZXNzaW9uS2V5c1xuICB9KSB7XG4gICAgaWYgKCFzZXNzaW9uS2V5cyB8fCAhdGhpcy5jb25maWcuZW1lRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMua2V5Rm9ybWF0UHJvbWlzZSkge1xuICAgICAgY29uc3Qga2V5Rm9ybWF0cyA9IHNlc3Npb25LZXlzLnJlZHVjZSgoZm9ybWF0cywgc2Vzc2lvbktleSkgPT4ge1xuICAgICAgICBpZiAoZm9ybWF0cy5pbmRleE9mKHNlc3Npb25LZXkua2V5Rm9ybWF0KSA9PT0gLTEpIHtcbiAgICAgICAgICBmb3JtYXRzLnB1c2goc2Vzc2lvbktleS5rZXlGb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXRzO1xuICAgICAgfSwgW10pO1xuICAgICAgdGhpcy5sb2coYFNlbGVjdGluZyBrZXktc3lzdGVtIGZyb20gc2Vzc2lvbi1rZXlzICR7a2V5Rm9ybWF0cy5qb2luKCcsICcpfWApO1xuICAgICAgdGhpcy5rZXlGb3JtYXRQcm9taXNlID0gdGhpcy5nZXRLZXlGb3JtYXRQcm9taXNlKGtleUZvcm1hdHMpO1xuICAgIH1cbiAgfVxuICByZW1vdmVTZXNzaW9uKG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQpIHtcbiAgICBjb25zdCB7XG4gICAgICBtZWRpYUtleXNTZXNzaW9uLFxuICAgICAgbGljZW5zZVhoclxuICAgIH0gPSBtZWRpYUtleVNlc3Npb25Db250ZXh0O1xuICAgIGlmIChtZWRpYUtleXNTZXNzaW9uKSB7XG4gICAgICB0aGlzLmxvZyhgUmVtb3ZlIGxpY2Vuc2VzIGFuZCBrZXlzIGFuZCBjbG9zZSBzZXNzaW9uICR7bWVkaWFLZXlzU2Vzc2lvbi5zZXNzaW9uSWR9YCk7XG4gICAgICBpZiAobWVkaWFLZXlTZXNzaW9uQ29udGV4dC5fb25tZXNzYWdlKSB7XG4gICAgICAgIG1lZGlhS2V5c1Nlc3Npb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQuX29ubWVzc2FnZSk7XG4gICAgICAgIG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQuX29ubWVzc2FnZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChtZWRpYUtleVNlc3Npb25Db250ZXh0Ll9vbmtleXN0YXR1c2VzY2hhbmdlKSB7XG4gICAgICAgIG1lZGlhS2V5c1Nlc3Npb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5c3RhdHVzZXNjaGFuZ2UnLCBtZWRpYUtleVNlc3Npb25Db250ZXh0Ll9vbmtleXN0YXR1c2VzY2hhbmdlKTtcbiAgICAgICAgbWVkaWFLZXlTZXNzaW9uQ29udGV4dC5fb25rZXlzdGF0dXNlc2NoYW5nZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChsaWNlbnNlWGhyICYmIGxpY2Vuc2VYaHIucmVhZHlTdGF0ZSAhPT0gWE1MSHR0cFJlcXVlc3QuRE9ORSkge1xuICAgICAgICBsaWNlbnNlWGhyLmFib3J0KCk7XG4gICAgICB9XG4gICAgICBtZWRpYUtleVNlc3Npb25Db250ZXh0Lm1lZGlhS2V5c1Nlc3Npb24gPSBtZWRpYUtleVNlc3Npb25Db250ZXh0LmRlY3J5cHRkYXRhID0gbWVkaWFLZXlTZXNzaW9uQ29udGV4dC5saWNlbnNlWGhyID0gdW5kZWZpbmVkO1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLm1lZGlhS2V5U2Vzc2lvbnMuaW5kZXhPZihtZWRpYUtleVNlc3Npb25Db250ZXh0KTtcbiAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgIHRoaXMubWVkaWFLZXlTZXNzaW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBkcm1TeXN0ZW1PcHRpb25zXG4gICAgICB9ID0gdGhpcy5jb25maWc7XG4gICAgICBjb25zdCByZW1vdmVQcm9taXNlID0gaXNQZXJzaXN0ZW50U2Vzc2lvblR5cGUoZHJtU3lzdGVtT3B0aW9ucykgPyBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHNlbGYuc2V0VGltZW91dCgoKSA9PiByZWplY3QobmV3IEVycm9yKGBNZWRpYUtleVNlc3Npb24ucmVtb3ZlKCkgdGltZW91dGApKSwgODAwMCk7XG4gICAgICAgIG1lZGlhS2V5c1Nlc3Npb24ucmVtb3ZlKCkudGhlbihyZXNvbHZlKTtcbiAgICAgIH0pIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICByZXR1cm4gcmVtb3ZlUHJvbWlzZS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIHZhciBfdGhpcyRobHM0O1xuICAgICAgICB0aGlzLmxvZyhgQ291bGQgbm90IHJlbW92ZSBzZXNzaW9uOiAke2Vycm9yfWApO1xuICAgICAgICAoX3RoaXMkaGxzNCA9IHRoaXMuaGxzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkaGxzNC50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuT1RIRVJfRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fREVTVFJPWV9SRU1PVkVfU0VTU0lPTl9FUlJPUixcbiAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihgQ291bGQgbm90IHJlbW92ZSBzZXNzaW9uOiAke2Vycm9yfWApXG4gICAgICAgIH0pO1xuICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgIHJldHVybiBtZWRpYUtleXNTZXNzaW9uLmNsb3NlKCk7XG4gICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIHZhciBfdGhpcyRobHM1O1xuICAgICAgICB0aGlzLmxvZyhgQ291bGQgbm90IGNsb3NlIHNlc3Npb246ICR7ZXJyb3J9YCk7XG4gICAgICAgIChfdGhpcyRobHM1ID0gdGhpcy5obHMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRobHM1LnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5PVEhFUl9FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9ERVNUUk9ZX0NMT1NFX1NFU1NJT05fRVJST1IsXG4gICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3IoYENvdWxkIG5vdCBjbG9zZSBzZXNzaW9uOiAke2Vycm9yfWApXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5FTUVDb250cm9sbGVyLkNETUNsZWFudXBQcm9taXNlID0gdm9pZCAwO1xuY2xhc3MgRU1FS2V5RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmRhdGEgPSB2b2lkIDA7XG4gICAgZGF0YS5lcnJvciB8fCAoZGF0YS5lcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKSk7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICBkYXRhLmVyciA9IGRhdGEuZXJyb3I7XG4gIH1cbn1cblxuY2xhc3MgRlBTQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMudGltZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5sYXN0VGltZSA9IHZvaWQgMDtcbiAgICB0aGlzLmxhc3REcm9wcGVkRnJhbWVzID0gMDtcbiAgICB0aGlzLmxhc3REZWNvZGVkRnJhbWVzID0gMDtcbiAgICAvLyBzdHJlYW0gY29udHJvbGxlciBtdXN0IGJlIHByb3ZpZGVkIGFzIGEgZGVwZW5kZW5jeSFcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIHNldFN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtQ29udHJvbGxlcikge1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IHN0cmVhbUNvbnRyb2xsZXI7XG4gIH1cbiAgcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5obHMub24oRXZlbnRzLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vbihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICB9XG4gIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5obHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyk7XG4gICAgdGhpcy5obHMub2ZmKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICB9XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tRdWFsaXR5QXZhaWxhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gIH1cbiAgb25NZWRpYUF0dGFjaGluZyhldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcbiAgICBpZiAoY29uZmlnLmNhcExldmVsT25GUFNEcm9wKSB7XG4gICAgICBjb25zdCBtZWRpYSA9IGRhdGEubWVkaWEgaW5zdGFuY2VvZiBzZWxmLkhUTUxWaWRlb0VsZW1lbnQgPyBkYXRhLm1lZGlhIDogbnVsbDtcbiAgICAgIHRoaXMubWVkaWEgPSBtZWRpYTtcbiAgICAgIGlmIChtZWRpYSAmJiB0eXBlb2YgbWVkaWEuZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tRdWFsaXR5QXZhaWxhYmxlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgIHRoaXMudGltZXIgPSBzZWxmLnNldEludGVydmFsKHRoaXMuY2hlY2tGUFNJbnRlcnZhbC5iaW5kKHRoaXMpLCBjb25maWcuZnBzRHJvcHBlZE1vbml0b3JpbmdQZXJpb2QpO1xuICAgIH1cbiAgfVxuICBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICB9XG4gIGNoZWNrRlBTKHZpZGVvLCBkZWNvZGVkRnJhbWVzLCBkcm9wcGVkRnJhbWVzKSB7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBpZiAoZGVjb2RlZEZyYW1lcykge1xuICAgICAgaWYgKHRoaXMubGFzdFRpbWUpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFBlcmlvZCA9IGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0VGltZTtcbiAgICAgICAgY29uc3QgY3VycmVudERyb3BwZWQgPSBkcm9wcGVkRnJhbWVzIC0gdGhpcy5sYXN0RHJvcHBlZEZyYW1lcztcbiAgICAgICAgY29uc3QgY3VycmVudERlY29kZWQgPSBkZWNvZGVkRnJhbWVzIC0gdGhpcy5sYXN0RGVjb2RlZEZyYW1lcztcbiAgICAgICAgY29uc3QgZHJvcHBlZEZQUyA9IDEwMDAgKiBjdXJyZW50RHJvcHBlZCAvIGN1cnJlbnRQZXJpb2Q7XG4gICAgICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuRlBTX0RST1AsIHtcbiAgICAgICAgICBjdXJyZW50RHJvcHBlZDogY3VycmVudERyb3BwZWQsXG4gICAgICAgICAgY3VycmVudERlY29kZWQ6IGN1cnJlbnREZWNvZGVkLFxuICAgICAgICAgIHRvdGFsRHJvcHBlZEZyYW1lczogZHJvcHBlZEZyYW1lc1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGRyb3BwZWRGUFMgPiAwKSB7XG4gICAgICAgICAgLy8gaGxzLmxvZ2dlci5sb2coJ2NoZWNrRlBTIDogZHJvcHBlZEZQUy9kZWNvZGVkRlBTOicgKyBkcm9wcGVkRlBTLygxMDAwICogY3VycmVudERlY29kZWQgLyBjdXJyZW50UGVyaW9kKSk7XG4gICAgICAgICAgaWYgKGN1cnJlbnREcm9wcGVkID4gaGxzLmNvbmZpZy5mcHNEcm9wcGVkTW9uaXRvcmluZ1RocmVzaG9sZCAqIGN1cnJlbnREZWNvZGVkKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudExldmVsID0gaGxzLmN1cnJlbnRMZXZlbDtcbiAgICAgICAgICAgIGhscy5sb2dnZXIud2FybignZHJvcCBGUFMgcmF0aW8gZ3JlYXRlciB0aGFuIG1heCBhbGxvd2VkIHZhbHVlIGZvciBjdXJyZW50TGV2ZWw6ICcgKyBjdXJyZW50TGV2ZWwpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRMZXZlbCA+IDAgJiYgKGhscy5hdXRvTGV2ZWxDYXBwaW5nID09PSAtMSB8fCBobHMuYXV0b0xldmVsQ2FwcGluZyA+PSBjdXJyZW50TGV2ZWwpKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IGN1cnJlbnRMZXZlbCAtIDE7XG4gICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUFNfRFJPUF9MRVZFTF9DQVBQSU5HLCB7XG4gICAgICAgICAgICAgICAgbGV2ZWw6IGN1cnJlbnRMZXZlbCxcbiAgICAgICAgICAgICAgICBkcm9wcGVkTGV2ZWw6IGhscy5jdXJyZW50TGV2ZWxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGhscy5hdXRvTGV2ZWxDYXBwaW5nID0gY3VycmVudExldmVsO1xuICAgICAgICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmxhc3RUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICB0aGlzLmxhc3REcm9wcGVkRnJhbWVzID0gZHJvcHBlZEZyYW1lcztcbiAgICAgIHRoaXMubGFzdERlY29kZWRGcmFtZXMgPSBkZWNvZGVkRnJhbWVzO1xuICAgIH1cbiAgfVxuICBjaGVja0ZQU0ludGVydmFsKCkge1xuICAgIGNvbnN0IHZpZGVvID0gdGhpcy5tZWRpYTtcbiAgICBpZiAodmlkZW8pIHtcbiAgICAgIGlmICh0aGlzLmlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGUpIHtcbiAgICAgICAgY29uc3QgdmlkZW9QbGF5YmFja1F1YWxpdHkgPSB2aWRlby5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSgpO1xuICAgICAgICB0aGlzLmNoZWNrRlBTKHZpZGVvLCB2aWRlb1BsYXliYWNrUXVhbGl0eS50b3RhbFZpZGVvRnJhbWVzLCB2aWRlb1BsYXliYWNrUXVhbGl0eS5kcm9wcGVkVmlkZW9GcmFtZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSFRNTFZpZGVvRWxlbWVudCBkb2Vzbid0IGluY2x1ZGUgdGhlIHdlYmtpdCB0eXBlc1xuICAgICAgICB0aGlzLmNoZWNrRlBTKHZpZGVvLCB2aWRlby53ZWJraXREZWNvZGVkRnJhbWVDb3VudCwgdmlkZW8ud2Via2l0RHJvcHBlZEZyYW1lQ291bnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZW5kQWRkVHJhY2tFdmVudCh0cmFjaywgdmlkZW9FbCkge1xuICBsZXQgZXZlbnQ7XG4gIHRyeSB7XG4gICAgZXZlbnQgPSBuZXcgRXZlbnQoJ2FkZHRyYWNrJyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIGZvciBJRTExXG4gICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBldmVudC5pbml0RXZlbnQoJ2FkZHRyYWNrJywgZmFsc2UsIGZhbHNlKTtcbiAgfVxuICBldmVudC50cmFjayA9IHRyYWNrO1xuICB2aWRlb0VsLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xufVxuZnVuY3Rpb24gYWRkQ3VlVG9UcmFjayh0cmFjaywgY3VlKSB7XG4gIC8vIFNvbWV0aW1lcyB0aGVyZSBhcmUgY3VlIG92ZXJsYXBzIG9uIHNlZ21lbnRlZCB2dHRzIHNvIHRoZSBzYW1lXG4gIC8vIGN1ZSBjYW4gYXBwZWFyIG1vcmUgdGhhbiBvbmNlIGluIGRpZmZlcmVudCB2dHQgZmlsZXMuXG4gIC8vIFRoaXMgYXZvaWQgc2hvd2luZyBkdXBsaWNhdGVkIGN1ZXMgd2l0aCBzYW1lIHRpbWVjb2RlIGFuZCB0ZXh0LlxuICBjb25zdCBtb2RlID0gdHJhY2subW9kZTtcbiAgaWYgKG1vZGUgPT09ICdkaXNhYmxlZCcpIHtcbiAgICB0cmFjay5tb2RlID0gJ2hpZGRlbic7XG4gIH1cbiAgaWYgKHRyYWNrLmN1ZXMgJiYgIXRyYWNrLmN1ZXMuZ2V0Q3VlQnlJZChjdWUuaWQpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRyYWNrLmFkZEN1ZShjdWUpO1xuICAgICAgaWYgKCF0cmFjay5jdWVzLmdldEN1ZUJ5SWQoY3VlLmlkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFkZEN1ZSBpcyBmYWlsZWQgZm9yOiAke2N1ZX1gKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhgW3RleHR0cmFjay11dGlsc106ICR7ZXJyfWApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdGV4dFRyYWNrQ3VlID0gbmV3IHNlbGYuVGV4dFRyYWNrQ3VlKGN1ZS5zdGFydFRpbWUsIGN1ZS5lbmRUaW1lLCBjdWUudGV4dCk7XG4gICAgICAgIHRleHRUcmFja0N1ZS5pZCA9IGN1ZS5pZDtcbiAgICAgICAgdHJhY2suYWRkQ3VlKHRleHRUcmFja0N1ZSk7XG4gICAgICB9IGNhdGNoIChlcnIyKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgW3RleHR0cmFjay11dGlsc106IExlZ2FjeSBUZXh0VHJhY2tDdWUgZmFsbGJhY2sgZmFpbGVkOiAke2VycjJ9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChtb2RlID09PSAnZGlzYWJsZWQnKSB7XG4gICAgdHJhY2subW9kZSA9IG1vZGU7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsZWFyQ3VycmVudEN1ZXModHJhY2ssIGVudGVySGFuZGxlcikge1xuICAvLyBXaGVuIHRyYWNrLm1vZGUgaXMgZGlzYWJsZWQsIHRyYWNrLmN1ZXMgd2lsbCBiZSBudWxsLlxuICAvLyBUbyBndWFyYW50ZWUgdGhlIHJlbW92YWwgb2YgY3Vlcywgd2UgbmVlZCB0byB0ZW1wb3JhcmlseVxuICAvLyBjaGFuZ2UgdGhlIG1vZGUgdG8gaGlkZGVuXG4gIGNvbnN0IG1vZGUgPSB0cmFjay5tb2RlO1xuICBpZiAobW9kZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgIHRyYWNrLm1vZGUgPSAnaGlkZGVuJztcbiAgfVxuICBpZiAodHJhY2suY3Vlcykge1xuICAgIGZvciAobGV0IGkgPSB0cmFjay5jdWVzLmxlbmd0aDsgaS0tOykge1xuICAgICAgaWYgKGVudGVySGFuZGxlcikge1xuICAgICAgICB0cmFjay5jdWVzW2ldLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VudGVyJywgZW50ZXJIYW5kbGVyKTtcbiAgICAgIH1cbiAgICAgIHRyYWNrLnJlbW92ZUN1ZSh0cmFjay5jdWVzW2ldKTtcbiAgICB9XG4gIH1cbiAgaWYgKG1vZGUgPT09ICdkaXNhYmxlZCcpIHtcbiAgICB0cmFjay5tb2RlID0gbW9kZTtcbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlQ3Vlc0luUmFuZ2UodHJhY2ssIHN0YXJ0LCBlbmQsIHByZWRpY2F0ZSkge1xuICBjb25zdCBtb2RlID0gdHJhY2subW9kZTtcbiAgaWYgKG1vZGUgPT09ICdkaXNhYmxlZCcpIHtcbiAgICB0cmFjay5tb2RlID0gJ2hpZGRlbic7XG4gIH1cbiAgaWYgKHRyYWNrLmN1ZXMgJiYgdHJhY2suY3Vlcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgY3VlcyA9IGdldEN1ZXNJblJhbmdlKHRyYWNrLmN1ZXMsIHN0YXJ0LCBlbmQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3Vlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFwcmVkaWNhdGUgfHwgcHJlZGljYXRlKGN1ZXNbaV0pKSB7XG4gICAgICAgIHRyYWNrLnJlbW92ZUN1ZShjdWVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG1vZGUgPT09ICdkaXNhYmxlZCcpIHtcbiAgICB0cmFjay5tb2RlID0gbW9kZTtcbiAgfVxufVxuXG4vLyBGaW5kIGZpcnN0IGN1ZSBzdGFydGluZyBhdCBvciBhZnRlciBnaXZlbiB0aW1lLlxuLy8gTW9kaWZpZWQgdmVyc2lvbiBvZiBiaW5hcnkgc2VhcmNoIE8obG9nKG4pKS5cbmZ1bmN0aW9uIGdldEZpcnN0Q3VlSW5kZXhGcm9tVGltZShjdWVzLCB0aW1lKSB7XG4gIC8vIElmIGZpcnN0IGN1ZSBzdGFydHMgYXQgb3IgYWZ0ZXIgdGltZSwgc3RhcnQgdGhlcmVcbiAgaWYgKHRpbWUgPD0gY3Vlc1swXS5zdGFydFRpbWUpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICAvLyBJZiB0aGUgbGFzdCBjdWUgZW5kcyBiZWZvcmUgdGltZSB0aGVyZSBpcyBubyBvdmVybGFwXG4gIGNvbnN0IGxlbiA9IGN1ZXMubGVuZ3RoIC0gMTtcbiAgaWYgKHRpbWUgPiBjdWVzW2xlbl0uZW5kVGltZSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBsZXQgbGVmdCA9IDA7XG4gIGxldCByaWdodCA9IGxlbjtcbiAgbGV0IG1pZDtcbiAgd2hpbGUgKGxlZnQgPD0gcmlnaHQpIHtcbiAgICBtaWQgPSBNYXRoLmZsb29yKChyaWdodCArIGxlZnQpIC8gMik7XG4gICAgaWYgKHRpbWUgPCBjdWVzW21pZF0uc3RhcnRUaW1lKSB7XG4gICAgICByaWdodCA9IG1pZCAtIDE7XG4gICAgfSBlbHNlIGlmICh0aW1lID4gY3Vlc1ttaWRdLnN0YXJ0VGltZSAmJiBsZWZ0IDwgbGVuKSB7XG4gICAgICBsZWZ0ID0gbWlkICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgaXQncyBub3QgbG93ZXIgb3IgaGlnaGVyLCBpdCBtdXN0IGJlIGVxdWFsLlxuICAgICAgcmV0dXJuIG1pZDtcbiAgICB9XG4gIH1cbiAgLy8gQXQgdGhpcyBwb2ludCwgbGVmdCBhbmQgcmlnaHQgaGF2ZSBzd2FwcGVkLlxuICAvLyBObyBkaXJlY3QgbWF0Y2ggd2FzIGZvdW5kLCBsZWZ0IG9yIHJpZ2h0IGVsZW1lbnQgbXVzdCBiZSB0aGUgY2xvc2VzdC4gQ2hlY2sgd2hpY2ggb25lIGhhcyB0aGUgc21hbGxlc3QgZGlmZi5cbiAgcmV0dXJuIGN1ZXNbbGVmdF0uc3RhcnRUaW1lIC0gdGltZSA8IHRpbWUgLSBjdWVzW3JpZ2h0XS5zdGFydFRpbWUgPyBsZWZ0IDogcmlnaHQ7XG59XG5mdW5jdGlvbiBnZXRDdWVzSW5SYW5nZShjdWVzLCBzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGN1ZXNGb3VuZCA9IFtdO1xuICBjb25zdCBmaXJzdEN1ZUluUmFuZ2UgPSBnZXRGaXJzdEN1ZUluZGV4RnJvbVRpbWUoY3Vlcywgc3RhcnQpO1xuICBpZiAoZmlyc3RDdWVJblJhbmdlID4gLTEpIHtcbiAgICBmb3IgKGxldCBpID0gZmlyc3RDdWVJblJhbmdlLCBsZW4gPSBjdWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBjdWUgPSBjdWVzW2ldO1xuICAgICAgaWYgKGN1ZS5zdGFydFRpbWUgPj0gc3RhcnQgJiYgY3VlLmVuZFRpbWUgPD0gZW5kKSB7XG4gICAgICAgIGN1ZXNGb3VuZC5wdXNoKGN1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGN1ZS5zdGFydFRpbWUgPiBlbmQpIHtcbiAgICAgICAgcmV0dXJuIGN1ZXNGb3VuZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGN1ZXNGb3VuZDtcbn1cbmZ1bmN0aW9uIGZpbHRlclN1YnRpdGxlVHJhY2tzKHRleHRUcmFja0xpc3QpIHtcbiAgY29uc3QgdHJhY2tzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dFRyYWNrTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRyYWNrID0gdGV4dFRyYWNrTGlzdFtpXTtcbiAgICAvLyBFZGdlIGFkZHMgYSB0cmFjayB3aXRob3V0IGEgbGFiZWw7IHdlIGRvbid0IHdhbnQgdG8gdXNlIGl0XG4gICAgaWYgKCh0cmFjay5raW5kID09PSAnc3VidGl0bGVzJyB8fCB0cmFjay5raW5kID09PSAnY2FwdGlvbnMnKSAmJiB0cmFjay5sYWJlbCkge1xuICAgICAgdHJhY2tzLnB1c2godGV4dFRyYWNrTGlzdFtpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cmFja3M7XG59XG5cbmNsYXNzIFN1YnRpdGxlVHJhY2tDb250cm9sbGVyIGV4dGVuZHMgQmFzZVBsYXlsaXN0Q29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHN1cGVyKGhscywgJ3N1YnRpdGxlLXRyYWNrLWNvbnRyb2xsZXInKTtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLnRyYWNrcyA9IFtdO1xuICAgIHRoaXMuZ3JvdXBJZHMgPSBudWxsO1xuICAgIHRoaXMudHJhY2tzSW5Hcm91cCA9IFtdO1xuICAgIHRoaXMudHJhY2tJZCA9IC0xO1xuICAgIHRoaXMuY3VycmVudFRyYWNrID0gbnVsbDtcbiAgICB0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IHRydWU7XG4gICAgdGhpcy5xdWV1ZWREZWZhdWx0VHJhY2sgPSAtMTtcbiAgICB0aGlzLnVzZVRleHRUcmFja1BvbGxpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnN1YnRpdGxlUG9sbGluZ0ludGVydmFsID0gLTE7XG4gICAgdGhpcy5fc3VidGl0bGVEaXNwbGF5ID0gdHJ1ZTtcbiAgICB0aGlzLmFzeW5jUG9sbFRyYWNrQ2hhbmdlID0gKCkgPT4gdGhpcy5wb2xsVHJhY2tDaGFuZ2UoMCk7XG4gICAgdGhpcy5vblRleHRUcmFja3NDaGFuZ2VkID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnVzZVRleHRUcmFja1BvbGxpbmcpIHtcbiAgICAgICAgc2VsZi5jbGVhckludGVydmFsKHRoaXMuc3VidGl0bGVQb2xsaW5nSW50ZXJ2YWwpO1xuICAgICAgfVxuICAgICAgLy8gTWVkaWEgaXMgdW5kZWZpbmVkIHdoZW4gc3dpdGNoaW5nIHN0cmVhbXMgdmlhIGxvYWRTb3VyY2UoKVxuICAgICAgaWYgKCF0aGlzLm1lZGlhIHx8ICF0aGlzLmhscy5jb25maWcucmVuZGVyVGV4dFRyYWNrc05hdGl2ZWx5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCB0ZXh0VHJhY2sgPSBudWxsO1xuICAgICAgY29uc3QgdHJhY2tzID0gZmlsdGVyU3VidGl0bGVUcmFja3ModGhpcy5tZWRpYS50ZXh0VHJhY2tzKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0cmFja3NbaV0ubW9kZSA9PT0gJ2hpZGRlbicpIHtcbiAgICAgICAgICAvLyBEbyBub3QgYnJlYWsgaW4gY2FzZSB0aGVyZSBpcyBhIGZvbGxvd2luZyB0cmFjayB3aXRoIHNob3dpbmcuXG4gICAgICAgICAgdGV4dFRyYWNrID0gdHJhY2tzW2ldO1xuICAgICAgICB9IGVsc2UgaWYgKHRyYWNrc1tpXS5tb2RlID09PSAnc2hvd2luZycpIHtcbiAgICAgICAgICB0ZXh0VHJhY2sgPSB0cmFja3NbaV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRmluZCBpbnRlcm5hbCB0cmFjayBpbmRleCBmb3IgVGV4dFRyYWNrXG4gICAgICBjb25zdCB0cmFja0lkID0gdGhpcy5maW5kVHJhY2tGb3JUZXh0VHJhY2sodGV4dFRyYWNrKTtcbiAgICAgIGlmICh0aGlzLnN1YnRpdGxlVHJhY2sgIT09IHRyYWNrSWQpIHtcbiAgICAgICAgdGhpcy5zZXRTdWJ0aXRsZVRyYWNrKHRyYWNrSWQpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy50cmFja3MubGVuZ3RoID0gMDtcbiAgICB0aGlzLnRyYWNrc0luR3JvdXAubGVuZ3RoID0gMDtcbiAgICB0aGlzLmN1cnJlbnRUcmFjayA9IG51bGw7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMub25UZXh0VHJhY2tzQ2hhbmdlZCA9IHRoaXMuYXN5bmNQb2xsVHJhY2tDaGFuZ2UgPSBudWxsO1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgfVxuICBnZXQgc3VidGl0bGVEaXNwbGF5KCkge1xuICAgIHJldHVybiB0aGlzLl9zdWJ0aXRsZURpc3BsYXk7XG4gIH1cbiAgc2V0IHN1YnRpdGxlRGlzcGxheSh2YWx1ZSkge1xuICAgIHRoaXMuX3N1YnRpdGxlRGlzcGxheSA9IHZhbHVlO1xuICAgIGlmICh0aGlzLnRyYWNrSWQgPiAtMSkge1xuICAgICAgdGhpcy50b2dnbGVUcmFja01vZGVzKCk7XG4gICAgfVxuICB9XG4gIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxfTE9BRElORywgdGhpcy5vbkxldmVsTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9TV0lUQ0hJTkcsIHRoaXMub25MZXZlbFN3aXRjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5TVUJUSVRMRV9UUkFDS19MT0FERUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9XG4gIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX0xPQURJTkcsIHRoaXMub25MZXZlbExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX1NXSVRDSElORywgdGhpcy5vbkxldmVsU3dpdGNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5TVUJUSVRMRV9UUkFDS19MT0FERUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfVxuXG4gIC8vIExpc3RlbiBmb3Igc3VidGl0bGUgdHJhY2sgY2hhbmdlLCB0aGVuIGV4dHJhY3QgdGhlIGN1cnJlbnQgdHJhY2sgSUQuXG4gIG9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5xdWV1ZWREZWZhdWx0VHJhY2sgPiAtMSkge1xuICAgICAgdGhpcy5zdWJ0aXRsZVRyYWNrID0gdGhpcy5xdWV1ZWREZWZhdWx0VHJhY2s7XG4gICAgICB0aGlzLnF1ZXVlZERlZmF1bHRUcmFjayA9IC0xO1xuICAgIH1cbiAgICB0aGlzLnVzZVRleHRUcmFja1BvbGxpbmcgPSAhKHRoaXMubWVkaWEudGV4dFRyYWNrcyAmJiAnb25jaGFuZ2UnIGluIHRoaXMubWVkaWEudGV4dFRyYWNrcyk7XG4gICAgaWYgKHRoaXMudXNlVGV4dFRyYWNrUG9sbGluZykge1xuICAgICAgdGhpcy5wb2xsVHJhY2tDaGFuZ2UoNTAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tZWRpYS50ZXh0VHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuYXN5bmNQb2xsVHJhY2tDaGFuZ2UpO1xuICAgIH1cbiAgfVxuICBwb2xsVHJhY2tDaGFuZ2UodGltZW91dCkge1xuICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnN1YnRpdGxlUG9sbGluZ0ludGVydmFsKTtcbiAgICB0aGlzLnN1YnRpdGxlUG9sbGluZ0ludGVydmFsID0gc2VsZi5zZXRJbnRlcnZhbCh0aGlzLm9uVGV4dFRyYWNrc0NoYW5nZWQsIHRpbWVvdXQpO1xuICB9XG4gIG9uTWVkaWFEZXRhY2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgaWYgKCFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0cmFuc2ZlcnJpbmdNZWRpYSA9ICEhZGF0YS50cmFuc2Zlck1lZGlhO1xuICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnN1YnRpdGxlUG9sbGluZ0ludGVydmFsKTtcbiAgICBpZiAoIXRoaXMudXNlVGV4dFRyYWNrUG9sbGluZykge1xuICAgICAgbWVkaWEudGV4dFRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLmFzeW5jUG9sbFRyYWNrQ2hhbmdlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudHJhY2tJZCA+IC0xKSB7XG4gICAgICB0aGlzLnF1ZXVlZERlZmF1bHRUcmFjayA9IHRoaXMudHJhY2tJZDtcbiAgICB9XG5cbiAgICAvLyBEaXNhYmxlIGFsbCBzdWJ0aXRsZSB0cmFja3MgYmVmb3JlIGRldGFjaG1lbnQgc28gd2hlbiByZWF0dGFjaGVkIG9ubHkgdHJhY2tzIGluIHRoYXQgY29udGVudCBhcmUgZW5hYmxlZC5cbiAgICB0aGlzLnN1YnRpdGxlVHJhY2sgPSAtMTtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICBpZiAodHJhbnNmZXJyaW5nTWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGV4dFRyYWNrcyA9IGZpbHRlclN1YnRpdGxlVHJhY2tzKG1lZGlhLnRleHRUcmFja3MpO1xuICAgIC8vIENsZWFyIGxvYWRlZCBjdWVzIG9uIG1lZGlhIGRldGFjaG1lbnQgZnJvbSB0cmFja3NcbiAgICB0ZXh0VHJhY2tzLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgY2xlYXJDdXJyZW50Q3Vlcyh0cmFjayk7XG4gICAgfSk7XG4gIH1cbiAgb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgdGhpcy50cmFja3MgPSBbXTtcbiAgICB0aGlzLmdyb3VwSWRzID0gbnVsbDtcbiAgICB0aGlzLnRyYWNrc0luR3JvdXAgPSBbXTtcbiAgICB0aGlzLnRyYWNrSWQgPSAtMTtcbiAgICB0aGlzLmN1cnJlbnRUcmFjayA9IG51bGw7XG4gICAgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSB0cnVlO1xuICB9XG5cbiAgLy8gRmlyZWQgd2hlbmV2ZXIgYSBuZXcgbWFuaWZlc3QgaXMgbG9hZGVkLlxuICBvbk1hbmlmZXN0UGFyc2VkKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy50cmFja3MgPSBkYXRhLnN1YnRpdGxlVHJhY2tzO1xuICB9XG4gIG9uU3VidGl0bGVUcmFja0xvYWRlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkLFxuICAgICAgZ3JvdXBJZCxcbiAgICAgIGRldGFpbHNcbiAgICB9ID0gZGF0YTtcbiAgICBjb25zdCB0cmFja0luQWN0aXZlR3JvdXAgPSB0aGlzLnRyYWNrc0luR3JvdXBbaWRdO1xuICAgIGlmICghdHJhY2tJbkFjdGl2ZUdyb3VwIHx8IHRyYWNrSW5BY3RpdmVHcm91cC5ncm91cElkICE9PSBncm91cElkKSB7XG4gICAgICB0aGlzLndhcm4oYFN1YnRpdGxlIHRyYWNrIHdpdGggaWQ6JHtpZH0gYW5kIGdyb3VwOiR7Z3JvdXBJZH0gbm90IGZvdW5kIGluIGFjdGl2ZSBncm91cCAke3RyYWNrSW5BY3RpdmVHcm91cCA9PSBudWxsID8gdm9pZCAwIDogdHJhY2tJbkFjdGl2ZUdyb3VwLmdyb3VwSWR9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1ckRldGFpbHMgPSB0cmFja0luQWN0aXZlR3JvdXAuZGV0YWlscztcbiAgICB0cmFja0luQWN0aXZlR3JvdXAuZGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICB0aGlzLmxvZyhgU3VidGl0bGUgdHJhY2sgJHtpZH0gXCIke3RyYWNrSW5BY3RpdmVHcm91cC5uYW1lfVwiIGxhbmc6JHt0cmFja0luQWN0aXZlR3JvdXAubGFuZ30gZ3JvdXA6JHtncm91cElkfSBsb2FkZWQgWyR7ZGV0YWlscy5zdGFydFNOfS0ke2RldGFpbHMuZW5kU059XWApO1xuICAgIGlmIChpZCA9PT0gdGhpcy50cmFja0lkKSB7XG4gICAgICB0aGlzLnBsYXlsaXN0TG9hZGVkKGlkLCBkYXRhLCBjdXJEZXRhaWxzKTtcbiAgICB9XG4gIH1cbiAgb25MZXZlbExvYWRpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLnN3aXRjaExldmVsKGRhdGEubGV2ZWwpO1xuICB9XG4gIG9uTGV2ZWxTd2l0Y2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLnN3aXRjaExldmVsKGRhdGEubGV2ZWwpO1xuICB9XG4gIHN3aXRjaExldmVsKGxldmVsSW5kZXgpIHtcbiAgICBjb25zdCBsZXZlbEluZm8gPSB0aGlzLmhscy5sZXZlbHNbbGV2ZWxJbmRleF07XG4gICAgaWYgKCFsZXZlbEluZm8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3VidGl0bGVHcm91cHMgPSBsZXZlbEluZm8uc3VidGl0bGVHcm91cHMgfHwgbnVsbDtcbiAgICBjb25zdCBjdXJyZW50R3JvdXBzID0gdGhpcy5ncm91cElkcztcbiAgICBsZXQgY3VycmVudFRyYWNrID0gdGhpcy5jdXJyZW50VHJhY2s7XG4gICAgaWYgKCFzdWJ0aXRsZUdyb3VwcyB8fCAoY3VycmVudEdyb3VwcyA9PSBudWxsID8gdm9pZCAwIDogY3VycmVudEdyb3Vwcy5sZW5ndGgpICE9PSAoc3VidGl0bGVHcm91cHMgPT0gbnVsbCA/IHZvaWQgMCA6IHN1YnRpdGxlR3JvdXBzLmxlbmd0aCkgfHwgc3VidGl0bGVHcm91cHMgIT0gbnVsbCAmJiBzdWJ0aXRsZUdyb3Vwcy5zb21lKGdyb3VwSWQgPT4gKGN1cnJlbnRHcm91cHMgPT0gbnVsbCA/IHZvaWQgMCA6IGN1cnJlbnRHcm91cHMuaW5kZXhPZihncm91cElkKSkgPT09IC0xKSkge1xuICAgICAgdGhpcy5ncm91cElkcyA9IHN1YnRpdGxlR3JvdXBzO1xuICAgICAgdGhpcy50cmFja0lkID0gLTE7XG4gICAgICB0aGlzLmN1cnJlbnRUcmFjayA9IG51bGw7XG4gICAgICBjb25zdCBzdWJ0aXRsZVRyYWNrcyA9IHRoaXMudHJhY2tzLmZpbHRlcih0cmFjayA9PiAhc3VidGl0bGVHcm91cHMgfHwgc3VidGl0bGVHcm91cHMuaW5kZXhPZih0cmFjay5ncm91cElkKSAhPT0gLTEpO1xuICAgICAgaWYgKHN1YnRpdGxlVHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAvLyBEaXNhYmxlIHNlbGVjdERlZmF1bHRUcmFjayBpZiB0aGVyZSBhcmUgbm8gZGVmYXVsdCB0cmFja3NcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrICYmICFzdWJ0aXRsZVRyYWNrcy5zb21lKHRyYWNrID0+IHRyYWNrLmRlZmF1bHQpKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0cmFjay5pZCBzaG91bGQgbWF0Y2ggaGxzLmF1ZGlvVHJhY2tzIGluZGV4XG4gICAgICAgIHN1YnRpdGxlVHJhY2tzLmZvckVhY2goKHRyYWNrLCBpKSA9PiB7XG4gICAgICAgICAgdHJhY2suaWQgPSBpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoIWN1cnJlbnRUcmFjayAmJiAhdGhpcy50cmFja3NJbkdyb3VwLmxlbmd0aCkge1xuICAgICAgICAvLyBEbyBub3QgZGlzcGF0Y2ggU1VCVElUTEVfVFJBQ0tTX1VQREFURUQgd2hlbiB0aGVyZSB3ZXJlIGFuZCBhcmUgbm8gdHJhY2tzXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMudHJhY2tzSW5Hcm91cCA9IHN1YnRpdGxlVHJhY2tzO1xuXG4gICAgICAvLyBGaW5kIHByZWZlcnJlZCB0cmFja1xuICAgICAgY29uc3Qgc3VidGl0bGVQcmVmZXJlbmNlID0gdGhpcy5obHMuY29uZmlnLnN1YnRpdGxlUHJlZmVyZW5jZTtcbiAgICAgIGlmICghY3VycmVudFRyYWNrICYmIHN1YnRpdGxlUHJlZmVyZW5jZSkge1xuICAgICAgICB0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IGZhbHNlO1xuICAgICAgICBjb25zdCBncm91cEluZGV4ID0gZmluZE1hdGNoaW5nT3B0aW9uKHN1YnRpdGxlUHJlZmVyZW5jZSwgc3VidGl0bGVUcmFja3MpO1xuICAgICAgICBpZiAoZ3JvdXBJbmRleCA+IC0xKSB7XG4gICAgICAgICAgY3VycmVudFRyYWNrID0gc3VidGl0bGVUcmFja3NbZ3JvdXBJbmRleF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgYWxsSW5kZXggPSBmaW5kTWF0Y2hpbmdPcHRpb24oc3VidGl0bGVQcmVmZXJlbmNlLCB0aGlzLnRyYWNrcyk7XG4gICAgICAgICAgY3VycmVudFRyYWNrID0gdGhpcy50cmFja3NbYWxsSW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFNlbGVjdCBpbml0aWFsIHRyYWNrXG4gICAgICBsZXQgdHJhY2tJZCA9IHRoaXMuZmluZFRyYWNrSWQoY3VycmVudFRyYWNrKTtcbiAgICAgIGlmICh0cmFja0lkID09PSAtMSAmJiBjdXJyZW50VHJhY2spIHtcbiAgICAgICAgdHJhY2tJZCA9IHRoaXMuZmluZFRyYWNrSWQobnVsbCk7XG4gICAgICB9XG5cbiAgICAgIC8vIERpc3BhdGNoIGV2ZW50cyBhbmQgbG9hZCB0cmFjayBpZiBuZWVkZWRcbiAgICAgIGNvbnN0IHN1YnRpdGxlVHJhY2tzVXBkYXRlZCA9IHtcbiAgICAgICAgc3VidGl0bGVUcmFja3NcbiAgICAgIH07XG4gICAgICB0aGlzLmxvZyhgVXBkYXRpbmcgc3VidGl0bGUgdHJhY2tzLCAke3N1YnRpdGxlVHJhY2tzLmxlbmd0aH0gdHJhY2socykgZm91bmQgaW4gXCIke3N1YnRpdGxlR3JvdXBzID09IG51bGwgPyB2b2lkIDAgOiBzdWJ0aXRsZUdyb3Vwcy5qb2luKCcsJyl9XCIgZ3JvdXAtaWRgKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLlNVQlRJVExFX1RSQUNLU19VUERBVEVELCBzdWJ0aXRsZVRyYWNrc1VwZGF0ZWQpO1xuICAgICAgaWYgKHRyYWNrSWQgIT09IC0xICYmIHRoaXMudHJhY2tJZCA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5zZXRTdWJ0aXRsZVRyYWNrKHRyYWNrSWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmaW5kVHJhY2tJZChjdXJyZW50VHJhY2spIHtcbiAgICBjb25zdCB0cmFja3MgPSB0aGlzLnRyYWNrc0luR3JvdXA7XG4gICAgY29uc3Qgc2VsZWN0RGVmYXVsdCA9IHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB0cmFjayA9IHRyYWNrc1tpXTtcbiAgICAgIGlmIChzZWxlY3REZWZhdWx0ICYmICF0cmFjay5kZWZhdWx0IHx8ICFzZWxlY3REZWZhdWx0ICYmICFjdXJyZW50VHJhY2spIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIWN1cnJlbnRUcmFjayB8fCBtYXRjaGVzT3B0aW9uKHRyYWNrLCBjdXJyZW50VHJhY2spKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY3VycmVudFRyYWNrKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB0cmFjayA9IHRyYWNrc1tpXTtcbiAgICAgICAgaWYgKG1lZGlhQXR0cmlidXRlc0lkZW50aWNhbChjdXJyZW50VHJhY2suYXR0cnMsIHRyYWNrLmF0dHJzLCBbJ0xBTkdVQUdFJywgJ0FTU09DLUxBTkdVQUdFJywgJ0NIQVJBQ1RFUklTVElDUyddKSkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB0cmFjayA9IHRyYWNrc1tpXTtcbiAgICAgICAgaWYgKG1lZGlhQXR0cmlidXRlc0lkZW50aWNhbChjdXJyZW50VHJhY2suYXR0cnMsIHRyYWNrLmF0dHJzLCBbJ0xBTkdVQUdFJ10pKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGZpbmRUcmFja0ZvclRleHRUcmFjayh0ZXh0VHJhY2spIHtcbiAgICBpZiAodGV4dFRyYWNrKSB7XG4gICAgICBjb25zdCB0cmFja3MgPSB0aGlzLnRyYWNrc0luR3JvdXA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB0cmFjayA9IHRyYWNrc1tpXTtcbiAgICAgICAgaWYgKHN1YnRpdGxlVHJhY2tNYXRjaGVzVGV4dFRyYWNrKHRyYWNrLCB0ZXh0VHJhY2spKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIG9uRXJyb3IoZXZlbnQsIGRhdGEpIHtcbiAgICBpZiAoZGF0YS5mYXRhbCB8fCAhZGF0YS5jb250ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkYXRhLmNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSyAmJiBkYXRhLmNvbnRleHQuaWQgPT09IHRoaXMudHJhY2tJZCAmJiAoIXRoaXMuZ3JvdXBJZHMgfHwgdGhpcy5ncm91cElkcy5pbmRleE9mKGRhdGEuY29udGV4dC5ncm91cElkKSAhPT0gLTEpKSB7XG4gICAgICB0aGlzLmNoZWNrUmV0cnkoZGF0YSk7XG4gICAgfVxuICB9XG4gIGdldCBhbGxTdWJ0aXRsZVRyYWNrcygpIHtcbiAgICByZXR1cm4gdGhpcy50cmFja3M7XG4gIH1cblxuICAvKiogZ2V0IGFsdGVybmF0ZSBzdWJ0aXRsZSB0cmFja3MgbGlzdCBmcm9tIHBsYXlsaXN0ICoqL1xuICBnZXQgc3VidGl0bGVUcmFja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2tzSW5Hcm91cDtcbiAgfVxuXG4gIC8qKiBnZXQvc2V0IGluZGV4IG9mIHRoZSBzZWxlY3RlZCBzdWJ0aXRsZSB0cmFjayAoYmFzZWQgb24gaW5kZXggaW4gc3VidGl0bGUgdHJhY2sgbGlzdHMpICoqL1xuICBnZXQgc3VidGl0bGVUcmFjaygpIHtcbiAgICByZXR1cm4gdGhpcy50cmFja0lkO1xuICB9XG4gIHNldCBzdWJ0aXRsZVRyYWNrKG5ld0lkKSB7XG4gICAgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSBmYWxzZTtcbiAgICB0aGlzLnNldFN1YnRpdGxlVHJhY2sobmV3SWQpO1xuICB9XG4gIHNldFN1YnRpdGxlT3B0aW9uKHN1YnRpdGxlT3B0aW9uKSB7XG4gICAgdGhpcy5obHMuY29uZmlnLnN1YnRpdGxlUHJlZmVyZW5jZSA9IHN1YnRpdGxlT3B0aW9uO1xuICAgIGlmIChzdWJ0aXRsZU9wdGlvbikge1xuICAgICAgaWYgKHN1YnRpdGxlT3B0aW9uLmlkID09PSAtMSkge1xuICAgICAgICB0aGlzLnNldFN1YnRpdGxlVHJhY2soLTEpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFsbFN1YnRpdGxlVHJhY2tzID0gdGhpcy5hbGxTdWJ0aXRsZVRyYWNrcztcbiAgICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gZmFsc2U7XG4gICAgICBpZiAoYWxsU3VidGl0bGVUcmFja3MubGVuZ3RoKSB7XG4gICAgICAgIC8vIEZpcnN0IHNlZSBpZiBjdXJyZW50IG9wdGlvbiBtYXRjaGVzIChubyBzd2l0Y2ggb3ApXG4gICAgICAgIGNvbnN0IGN1cnJlbnRUcmFjayA9IHRoaXMuY3VycmVudFRyYWNrO1xuICAgICAgICBpZiAoY3VycmVudFRyYWNrICYmIG1hdGNoZXNPcHRpb24oc3VidGl0bGVPcHRpb24sIGN1cnJlbnRUcmFjaykpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudFRyYWNrO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmQgb3B0aW9uIGluIGN1cnJlbnQgZ3JvdXBcbiAgICAgICAgY29uc3QgZ3JvdXBJbmRleCA9IGZpbmRNYXRjaGluZ09wdGlvbihzdWJ0aXRsZU9wdGlvbiwgdGhpcy50cmFja3NJbkdyb3VwKTtcbiAgICAgICAgaWYgKGdyb3VwSW5kZXggPiAtMSkge1xuICAgICAgICAgIGNvbnN0IHRyYWNrID0gdGhpcy50cmFja3NJbkdyb3VwW2dyb3VwSW5kZXhdO1xuICAgICAgICAgIHRoaXMuc2V0U3VidGl0bGVUcmFjayhncm91cEluZGV4KTtcbiAgICAgICAgICByZXR1cm4gdHJhY2s7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFRyYWNrKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyBpcyBub3QgdGhlIGluaXRpYWwgc2VsZWN0aW9uIHJldHVybiBudWxsXG4gICAgICAgICAgLy8gb3B0aW9uIHNob3VsZCBoYXZlIG1hdGNoZWQgb25lIGluIGFjdGl2ZSBncm91cFxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEZpbmQgdGhlIG9wdGlvbiBpbiBhbGwgdHJhY2tzIGZvciBpbml0aWFsIHNlbGVjdGlvblxuICAgICAgICAgIGNvbnN0IGFsbEluZGV4ID0gZmluZE1hdGNoaW5nT3B0aW9uKHN1YnRpdGxlT3B0aW9uLCBhbGxTdWJ0aXRsZVRyYWNrcyk7XG4gICAgICAgICAgaWYgKGFsbEluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBhbGxTdWJ0aXRsZVRyYWNrc1thbGxJbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxvYWRQbGF5bGlzdChobHNVcmxQYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIubG9hZFBsYXlsaXN0KCk7XG4gICAgaWYgKHRoaXMuc2hvdWxkTG9hZFBsYXlsaXN0KHRoaXMuY3VycmVudFRyYWNrKSkge1xuICAgICAgdGhpcy5zY2hlZHVsZUxvYWRpbmcodGhpcy5jdXJyZW50VHJhY2ssIGhsc1VybFBhcmFtZXRlcnMpO1xuICAgIH1cbiAgfVxuICBsb2FkaW5nUGxheWxpc3QoY3VycmVudFRyYWNrLCBobHNVcmxQYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIubG9hZGluZ1BsYXlsaXN0KGN1cnJlbnRUcmFjaywgaGxzVXJsUGFyYW1ldGVycyk7XG4gICAgY29uc3QgaWQgPSBjdXJyZW50VHJhY2suaWQ7XG4gICAgY29uc3QgZ3JvdXBJZCA9IGN1cnJlbnRUcmFjay5ncm91cElkO1xuICAgIGNvbnN0IHVybCA9IHRoaXMuZ2V0VXJsV2l0aERpcmVjdGl2ZXMoY3VycmVudFRyYWNrLnVybCwgaGxzVXJsUGFyYW1ldGVycyk7XG4gICAgY29uc3QgZGV0YWlscyA9IGN1cnJlbnRUcmFjay5kZXRhaWxzO1xuICAgIGNvbnN0IGFnZSA9IGRldGFpbHMgPT0gbnVsbCA/IHZvaWQgMCA6IGRldGFpbHMuYWdlO1xuICAgIHRoaXMubG9nKGBMb2FkaW5nIHN1YnRpdGxlICR7aWR9IFwiJHtjdXJyZW50VHJhY2submFtZX1cIiBsYW5nOiR7Y3VycmVudFRyYWNrLmxhbmd9IGdyb3VwOiR7Z3JvdXBJZH0keyhobHNVcmxQYXJhbWV0ZXJzID09IG51bGwgPyB2b2lkIDAgOiBobHNVcmxQYXJhbWV0ZXJzLm1zbikgIT09IHVuZGVmaW5lZCA/ICcgYXQgc24gJyArIGhsc1VybFBhcmFtZXRlcnMubXNuICsgJyBwYXJ0ICcgKyBobHNVcmxQYXJhbWV0ZXJzLnBhcnQgOiAnJ30ke2FnZSAmJiBkZXRhaWxzLmxpdmUgPyAnIGFnZSAnICsgYWdlLnRvRml4ZWQoMSkgKyAoZGV0YWlscy50eXBlID8gJyAnICsgZGV0YWlscy50eXBlIHx8ICcnIDogJycpIDogJyd9ICR7dXJsfWApO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLlNVQlRJVExFX1RSQUNLX0xPQURJTkcsIHtcbiAgICAgIHVybCxcbiAgICAgIGlkLFxuICAgICAgZ3JvdXBJZCxcbiAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlczogaGxzVXJsUGFyYW1ldGVycyB8fCBudWxsLFxuICAgICAgdHJhY2s6IGN1cnJlbnRUcmFja1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc2FibGVzIHRoZSBvbGQgc3VidGl0bGVUcmFjayBhbmQgc2V0cyBjdXJyZW50IG1vZGUgb24gdGhlIG5leHQgc3VidGl0bGVUcmFjay5cbiAgICogVGhpcyBvcGVyYXRlcyBvbiB0aGUgRE9NIHRleHRUcmFja3MuXG4gICAqIEEgdmFsdWUgb2YgLTEgd2lsbCBkaXNhYmxlIGFsbCBzdWJ0aXRsZSB0cmFja3MuXG4gICAqL1xuICB0b2dnbGVUcmFja01vZGVzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lZGlhXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0VHJhY2tzID0gZmlsdGVyU3VidGl0bGVUcmFja3MobWVkaWEudGV4dFRyYWNrcyk7XG4gICAgY29uc3QgY3VycmVudFRyYWNrID0gdGhpcy5jdXJyZW50VHJhY2s7XG4gICAgbGV0IG5leHRUcmFjaztcbiAgICBpZiAoY3VycmVudFRyYWNrKSB7XG4gICAgICBuZXh0VHJhY2sgPSB0ZXh0VHJhY2tzLmZpbHRlcih0ZXh0VHJhY2sgPT4gc3VidGl0bGVUcmFja01hdGNoZXNUZXh0VHJhY2soY3VycmVudFRyYWNrLCB0ZXh0VHJhY2spKVswXTtcbiAgICAgIGlmICghbmV4dFRyYWNrKSB7XG4gICAgICAgIHRoaXMud2FybihgVW5hYmxlIHRvIGZpbmQgc3VidGl0bGUgVGV4dFRyYWNrIHdpdGggbmFtZSBcIiR7Y3VycmVudFRyYWNrLm5hbWV9XCIgYW5kIGxhbmd1YWdlIFwiJHtjdXJyZW50VHJhY2subGFuZ31cImApO1xuICAgICAgfVxuICAgIH1cbiAgICBbXS5zbGljZS5jYWxsKHRleHRUcmFja3MpLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgaWYgKHRyYWNrLm1vZGUgIT09ICdkaXNhYmxlZCcgJiYgdHJhY2sgIT09IG5leHRUcmFjaykge1xuICAgICAgICB0cmFjay5tb2RlID0gJ2Rpc2FibGVkJztcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAobmV4dFRyYWNrKSB7XG4gICAgICBjb25zdCBtb2RlID0gdGhpcy5zdWJ0aXRsZURpc3BsYXkgPyAnc2hvd2luZycgOiAnaGlkZGVuJztcbiAgICAgIGlmIChuZXh0VHJhY2subW9kZSAhPT0gbW9kZSkge1xuICAgICAgICBuZXh0VHJhY2subW9kZSA9IG1vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIHJlc3BvbnNpYmxlIGZvciB2YWxpZGF0aW5nIHRoZSBzdWJ0aXRsZSBpbmRleCBhbmQgcGVyaW9kaWNhbGx5IHJlbG9hZGluZyBpZiBsaXZlLlxuICAgKiBEaXNwYXRjaGVzIHRoZSBTVUJUSVRMRV9UUkFDS19TV0lUQ0ggZXZlbnQsIHdoaWNoIGluc3RydWN0cyB0aGUgc3VidGl0bGUtc3RyZWFtLWNvbnRyb2xsZXIgdG8gbG9hZCB0aGUgc2VsZWN0ZWQgdHJhY2suXG4gICAqL1xuICBzZXRTdWJ0aXRsZVRyYWNrKG5ld0lkKSB7XG4gICAgY29uc3QgdHJhY2tzID0gdGhpcy50cmFja3NJbkdyb3VwO1xuXG4gICAgLy8gc2V0dGluZyB0aGlzLnN1YnRpdGxlVHJhY2sgd2lsbCB0cmlnZ2VyIGludGVybmFsIGxvZ2ljXG4gICAgLy8gaWYgbWVkaWEgaGFzIG5vdCBiZWVuIGF0dGFjaGVkIHlldCwgaXQgd2lsbCBmYWlsXG4gICAgLy8gd2Uga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgZGVmYXVsdCB0cmFjayBpZFxuICAgIC8vIGFuZCB3ZSdsbCBzZXQgc3VidGl0bGVUcmFjayB3aGVuIG9uTWVkaWFBdHRhY2hlZCBpcyB0cmlnZ2VyZWRcbiAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgIHRoaXMucXVldWVkRGVmYXVsdFRyYWNrID0gbmV3SWQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZXhpdCBpZiB0cmFjayBpZCBhcyBhbHJlYWR5IHNldCBvciBpbnZhbGlkXG4gICAgaWYgKG5ld0lkIDwgLTEgfHwgbmV3SWQgPj0gdHJhY2tzLmxlbmd0aCB8fCAhaXNGaW5pdGVOdW1iZXIobmV3SWQpKSB7XG4gICAgICB0aGlzLndhcm4oYEludmFsaWQgc3VidGl0bGUgdHJhY2sgaWQ6ICR7bmV3SWR9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gZmFsc2U7XG4gICAgY29uc3QgbGFzdFRyYWNrID0gdGhpcy5jdXJyZW50VHJhY2s7XG4gICAgY29uc3QgdHJhY2sgPSB0cmFja3NbbmV3SWRdIHx8IG51bGw7XG4gICAgdGhpcy50cmFja0lkID0gbmV3SWQ7XG4gICAgdGhpcy5jdXJyZW50VHJhY2sgPSB0cmFjaztcbiAgICB0aGlzLnRvZ2dsZVRyYWNrTW9kZXMoKTtcbiAgICBpZiAoIXRyYWNrKSB7XG4gICAgICAvLyBzd2l0Y2ggdG8gLTFcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLlNVQlRJVExFX1RSQUNLX1NXSVRDSCwge1xuICAgICAgICBpZDogbmV3SWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0cmFja0xvYWRlZCA9ICEhdHJhY2suZGV0YWlscyAmJiAhdHJhY2suZGV0YWlscy5saXZlO1xuICAgIGlmIChuZXdJZCA9PT0gdGhpcy50cmFja0lkICYmIHRyYWNrID09PSBsYXN0VHJhY2sgJiYgdHJhY2tMb2FkZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sb2coYFN3aXRjaGluZyB0byBzdWJ0aXRsZS10cmFjayAke25ld0lkfWAgKyAodHJhY2sgPyBgIFwiJHt0cmFjay5uYW1lfVwiIGxhbmc6JHt0cmFjay5sYW5nfSBncm91cDoke3RyYWNrLmdyb3VwSWR9YCA6ICcnKSk7XG4gICAgY29uc3Qge1xuICAgICAgaWQsXG4gICAgICBncm91cElkID0gJycsXG4gICAgICBuYW1lLFxuICAgICAgdHlwZSxcbiAgICAgIHVybFxuICAgIH0gPSB0cmFjaztcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5TVUJUSVRMRV9UUkFDS19TV0lUQ0gsIHtcbiAgICAgIGlkLFxuICAgICAgZ3JvdXBJZCxcbiAgICAgIG5hbWUsXG4gICAgICB0eXBlLFxuICAgICAgdXJsXG4gICAgfSk7XG4gICAgY29uc3QgaGxzVXJsUGFyYW1ldGVycyA9IHRoaXMuc3dpdGNoUGFyYW1zKHRyYWNrLnVybCwgbGFzdFRyYWNrID09IG51bGwgPyB2b2lkIDAgOiBsYXN0VHJhY2suZGV0YWlscywgdHJhY2suZGV0YWlscyk7XG4gICAgdGhpcy5sb2FkUGxheWxpc3QoaGxzVXJsUGFyYW1ldGVycyk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHJhbmRvbSB2NCBVVUlEXG4gKlxuICogQHJldHVybnMgQSByYW5kb20gdjQgVVVJRFxuICpcbiAqIEBncm91cCBVdGlsc1xuICpcbiAqIEBiZXRhXG4gKi9cbmZ1bmN0aW9uIHV1aWQoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGNyeXB0by5yYW5kb21VVUlEKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoKSk7XG4gICAgICBjb25zdCB1dWlkID0gdXJsLnRvU3RyaW5nKCk7XG4gICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XG4gICAgICByZXR1cm4gdXVpZC5zbGljZSh1dWlkLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbGV0IGR0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICBjb25zdCB1dWlkID0gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBjID0+IHtcbiAgICAgICAgY29uc3QgciA9IChkdCArIE1hdGgucmFuZG9tKCkgKiAxNikgJSAxNiB8IDA7XG4gICAgICAgIGR0ID0gTWF0aC5mbG9vcihkdCAvIDE2KTtcbiAgICAgICAgcmV0dXJuIChjID09ICd4JyA/IHIgOiByICYgMHgzIHwgMHg4KS50b1N0cmluZygxNik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB1dWlkO1xuICAgIH1cbiAgfVxufVxuXG4vLyBGcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXJrc2t5YXBwL3N0cmluZy1oYXNoXG5mdW5jdGlvbiBoYXNoKHRleHQpIHtcbiAgbGV0IGhhc2ggPSA1MzgxO1xuICBsZXQgaSA9IHRleHQubGVuZ3RoO1xuICB3aGlsZSAoaSkge1xuICAgIGhhc2ggPSBoYXNoICogMzMgXiB0ZXh0LmNoYXJDb2RlQXQoLS1pKTtcbiAgfVxuICByZXR1cm4gKGhhc2ggPj4+IDApLnRvU3RyaW5nKCk7XG59XG5cbmNvbnN0IEFMSUdORURfRU5EX1RIUkVTSE9MRF9TRUNPTkRTID0gMC4wMjU7XG5sZXQgVGltZWxpbmVPY2N1cGFuY3kgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKFRpbWVsaW5lT2NjdXBhbmN5KSB7XG4gIFRpbWVsaW5lT2NjdXBhbmN5W1RpbWVsaW5lT2NjdXBhbmN5W1wiUG9pbnRcIl0gPSAwXSA9IFwiUG9pbnRcIjtcbiAgVGltZWxpbmVPY2N1cGFuY3lbVGltZWxpbmVPY2N1cGFuY3lbXCJSYW5nZVwiXSA9IDFdID0gXCJSYW5nZVwiO1xuICByZXR1cm4gVGltZWxpbmVPY2N1cGFuY3k7XG59KHt9KTtcbmZ1bmN0aW9uIGdlbmVyYXRlQXNzZXRJZGVudGlmaWVyKGludGVyc3RpdGlhbCwgdXJpLCBhc3NldExpc3RJbmRleCkge1xuICByZXR1cm4gYCR7aW50ZXJzdGl0aWFsLmlkZW50aWZpZXJ9LSR7YXNzZXRMaXN0SW5kZXggKyAxfS0ke2hhc2godXJpKX1gO1xufVxuY2xhc3MgSW50ZXJzdGl0aWFsRXZlbnQge1xuICBjb25zdHJ1Y3RvcihkYXRlUmFuZ2UsIGJhc2UpIHtcbiAgICB0aGlzLmJhc2UgPSB2b2lkIDA7XG4gICAgdGhpcy5fZHVyYXRpb24gPSBudWxsO1xuICAgIHRoaXMuX3RpbWVsaW5lU3RhcnQgPSBudWxsO1xuICAgIHRoaXMuYXBwZW5kSW5QbGFjZURpc2FibGVkID0gdm9pZCAwO1xuICAgIHRoaXMuYXBwZW5kSW5QbGFjZVN0YXJ0ZWQgPSB2b2lkIDA7XG4gICAgdGhpcy5kYXRlUmFuZ2UgPSB2b2lkIDA7XG4gICAgdGhpcy5oYXNQbGF5ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmN1bXVsYXRpdmVEdXJhdGlvbiA9IDA7XG4gICAgdGhpcy5yZXN1bWVPZmZzZXQgPSBOYU47XG4gICAgdGhpcy5wbGF5b3V0TGltaXQgPSBOYU47XG4gICAgdGhpcy5yZXN0cmljdGlvbnMgPSB7XG4gICAgICBza2lwOiBmYWxzZSxcbiAgICAgIGp1bXA6IGZhbHNlXG4gICAgfTtcbiAgICB0aGlzLnNuYXBPcHRpb25zID0ge1xuICAgICAgb3V0OiBmYWxzZSxcbiAgICAgIGluOiBmYWxzZVxuICAgIH07XG4gICAgdGhpcy5hc3NldExpc3QgPSBbXTtcbiAgICB0aGlzLmFzc2V0TGlzdExvYWRlciA9IHZvaWQgMDtcbiAgICB0aGlzLmFzc2V0TGlzdFJlc3BvbnNlID0gbnVsbDtcbiAgICB0aGlzLnJlc3VtZUFuY2hvciA9IHZvaWQgMDtcbiAgICB0aGlzLmVycm9yID0gdm9pZCAwO1xuICAgIHRoaXMucmVzZXRPblJlc3VtZSA9IHZvaWQgMDtcbiAgICB0aGlzLmJhc2UgPSBiYXNlO1xuICAgIHRoaXMuZGF0ZVJhbmdlID0gZGF0ZVJhbmdlO1xuICAgIHRoaXMuc2V0RGF0ZVJhbmdlKGRhdGVSYW5nZSk7XG4gIH1cbiAgc2V0RGF0ZVJhbmdlKGRhdGVSYW5nZSkge1xuICAgIHRoaXMuZGF0ZVJhbmdlID0gZGF0ZVJhbmdlO1xuICAgIHRoaXMucmVzdW1lT2Zmc2V0ID0gZGF0ZVJhbmdlLmF0dHIub3B0aW9uYWxGbG9hdCgnWC1SRVNVTUUtT0ZGU0VUJywgdGhpcy5yZXN1bWVPZmZzZXQpO1xuICAgIHRoaXMucGxheW91dExpbWl0ID0gZGF0ZVJhbmdlLmF0dHIub3B0aW9uYWxGbG9hdCgnWC1QTEFZT1VULUxJTUlUJywgdGhpcy5wbGF5b3V0TGltaXQpO1xuICAgIHRoaXMucmVzdHJpY3Rpb25zID0gZGF0ZVJhbmdlLmF0dHIuZW51bWVyYXRlZFN0cmluZ0xpc3QoJ1gtUkVTVFJJQ1QnLCB0aGlzLnJlc3RyaWN0aW9ucyk7XG4gICAgdGhpcy5zbmFwT3B0aW9ucyA9IGRhdGVSYW5nZS5hdHRyLmVudW1lcmF0ZWRTdHJpbmdMaXN0KCdYLVNOQVAnLCB0aGlzLnNuYXBPcHRpb25zKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB2YXIgX3RoaXMkYXNzZXRMaXN0TG9hZGVyO1xuICAgIHRoaXMuYXBwZW5kSW5QbGFjZVN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAoX3RoaXMkYXNzZXRMaXN0TG9hZGVyID0gdGhpcy5hc3NldExpc3RMb2FkZXIpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRhc3NldExpc3RMb2FkZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuYXNzZXRMaXN0TG9hZGVyID0gdW5kZWZpbmVkO1xuICAgIGlmICghdGhpcy5zdXBwbGVtZW50c1ByaW1hcnkpIHtcbiAgICAgIHRoaXMuYXNzZXRMaXN0UmVzcG9uc2UgPSBudWxsO1xuICAgICAgdGhpcy5hc3NldExpc3QgPSBbXTtcbiAgICAgIHRoaXMuX2R1cmF0aW9uID0gbnVsbDtcbiAgICB9XG4gICAgLy8gYGVycm9yP2AgaXMgcmVzZXQgd2hlbiBzZWVraW5nIGJhY2sgb3ZlciBpbnRlcnN0aXRpYWwgYHN0YXJ0T2Zmc2V0YFxuICAgIC8vICB1c2luZyBgc2NoZWR1bGUucmVzZXRFcnJvcnNJblJhbmdlKHN0YXJ0LCBlbmQpYC5cbiAgfVxuICBpc0Fzc2V0UGFzdFBsYXlvdXRMaW1pdChhc3NldEluZGV4KSB7XG4gICAgdmFyIF90aGlzJGFzc2V0TGlzdCRhc3NldDtcbiAgICBpZiAoYXNzZXRJbmRleCA+IDAgJiYgYXNzZXRJbmRleCA+PSB0aGlzLmFzc2V0TGlzdC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBwbGF5b3V0TGltaXQgPSB0aGlzLnBsYXlvdXRMaW1pdDtcbiAgICBpZiAoYXNzZXRJbmRleCA8PSAwIHx8IGlzTmFOKHBsYXlvdXRMaW1pdCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBsYXlvdXRMaW1pdCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGFzc2V0T2Zmc2V0ID0gKChfdGhpcyRhc3NldExpc3QkYXNzZXQgPSB0aGlzLmFzc2V0TGlzdFthc3NldEluZGV4XSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGFzc2V0TGlzdCRhc3NldC5zdGFydE9mZnNldCkgfHwgMDtcbiAgICByZXR1cm4gYXNzZXRPZmZzZXQgPiBwbGF5b3V0TGltaXQ7XG4gIH1cbiAgZmluZEFzc2V0SW5kZXgoYXNzZXQpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuYXNzZXRMaXN0LmluZGV4T2YoYXNzZXQpO1xuICAgIHJldHVybiBpbmRleDtcbiAgfVxuICBnZXQgaWRlbnRpZmllcigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlUmFuZ2UuaWQ7XG4gIH1cbiAgZ2V0IHN0YXJ0RGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlUmFuZ2Uuc3RhcnREYXRlO1xuICB9XG4gIGdldCBzdGFydFRpbWUoKSB7XG4gICAgLy8gUHJpbWFyeSBtZWRpYSB0aW1lbGluZSBzdGFydCB0aW1lXG4gICAgY29uc3Qgc3RhcnRUaW1lID0gdGhpcy5kYXRlUmFuZ2Uuc3RhcnRUaW1lO1xuICAgIGlmICh0aGlzLnNuYXBPcHRpb25zLm91dCkge1xuICAgICAgY29uc3QgZnJhZyA9IHRoaXMuZGF0ZVJhbmdlLnRhZ0FuY2hvcjtcbiAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgIHJldHVybiBnZXRTbmFwVG9GcmFnbWVudFRpbWUoc3RhcnRUaW1lLCBmcmFnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0YXJ0VGltZTtcbiAgfVxuICBnZXQgc3RhcnRPZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VlLnByZSA/IDAgOiB0aGlzLnN0YXJ0VGltZTtcbiAgfVxuICBnZXQgc3RhcnRJc0FsaWduZWQoKSB7XG4gICAgaWYgKHRoaXMuc3RhcnRUaW1lID09PSAwIHx8IHRoaXMuc25hcE9wdGlvbnMub3V0KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgZnJhZyA9IHRoaXMuZGF0ZVJhbmdlLnRhZ0FuY2hvcjtcbiAgICBpZiAoZnJhZykge1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gdGhpcy5kYXRlUmFuZ2Uuc3RhcnRUaW1lO1xuICAgICAgY29uc3Qgc25hcHBlZFN0YXJ0ID0gZ2V0U25hcFRvRnJhZ21lbnRUaW1lKHN0YXJ0VGltZSwgZnJhZyk7XG4gICAgICByZXR1cm4gc3RhcnRUaW1lIC0gc25hcHBlZFN0YXJ0IDwgMC4xO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZ2V0IHJlc3VtcHRpb25PZmZzZXQoKSB7XG4gICAgY29uc3QgcmVzdW1lT2Zmc2V0ID0gdGhpcy5yZXN1bWVPZmZzZXQ7XG4gICAgY29uc3Qgb2Zmc2V0ID0gaXNGaW5pdGVOdW1iZXIocmVzdW1lT2Zmc2V0KSA/IHJlc3VtZU9mZnNldCA6IHRoaXMuZHVyYXRpb247XG4gICAgcmV0dXJuIHRoaXMuY3VtdWxhdGl2ZUR1cmF0aW9uICsgb2Zmc2V0O1xuICB9XG4gIGdldCByZXN1bWVUaW1lKCkge1xuICAgIC8vIFByaW1hcnkgbWVkaWEgdGltZWxpbmUgcmVzdW1wdGlvbiB0aW1lXG4gICAgY29uc3QgcmVzdW1lVGltZSA9IHRoaXMuc3RhcnRPZmZzZXQgKyB0aGlzLnJlc3VtcHRpb25PZmZzZXQ7XG4gICAgaWYgKHRoaXMuc25hcE9wdGlvbnMuaW4pIHtcbiAgICAgIGNvbnN0IGZyYWcgPSB0aGlzLnJlc3VtZUFuY2hvcjtcbiAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgIHJldHVybiBnZXRTbmFwVG9GcmFnbWVudFRpbWUocmVzdW1lVGltZSwgZnJhZyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bWVUaW1lO1xuICB9XG4gIGdldCBhcHBlbmRJblBsYWNlKCkge1xuICAgIGlmICh0aGlzLmFwcGVuZEluUGxhY2VTdGFydGVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYXBwZW5kSW5QbGFjZURpc2FibGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghdGhpcy5jdWUub25jZSAmJiAhdGhpcy5jdWUucHJlICYmXG4gICAgLy8gcHJlcm9sbCBzdGFydHMgYXQgc3RhcnRQb3NpdGlvbiBiZWZvcmUgc3RhcnRQb3NpdGlvbiBpcyBrbm93biAobGl2ZSlcbiAgICB0aGlzLnN0YXJ0SXNBbGlnbmVkICYmIChpc05hTih0aGlzLnBsYXlvdXRMaW1pdCkgJiYgaXNOYU4odGhpcy5yZXN1bWVPZmZzZXQpIHx8IHRoaXMucmVzdW1lT2Zmc2V0ICYmIHRoaXMuZHVyYXRpb24gJiYgTWF0aC5hYnModGhpcy5yZXN1bWVPZmZzZXQgLSB0aGlzLmR1cmF0aW9uKSA8IEFMSUdORURfRU5EX1RIUkVTSE9MRF9TRUNPTkRTKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzZXQgYXBwZW5kSW5QbGFjZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmFwcGVuZEluUGxhY2VTdGFydGVkKSB7XG4gICAgICB0aGlzLnJlc2V0T25SZXN1bWUgPSAhdmFsdWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYXBwZW5kSW5QbGFjZURpc2FibGVkID0gIXZhbHVlO1xuICB9XG5cbiAgLy8gRXh0ZW5kZWQgdGltZWxpbmUgc3RhcnQgdGltZVxuICBnZXQgdGltZWxpbmVTdGFydCgpIHtcbiAgICBpZiAodGhpcy5fdGltZWxpbmVTdGFydCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RpbWVsaW5lU3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnN0YXJ0VGltZTtcbiAgfVxuICBzZXQgdGltZWxpbmVTdGFydCh2YWx1ZSkge1xuICAgIHRoaXMuX3RpbWVsaW5lU3RhcnQgPSB2YWx1ZTtcbiAgfVxuICBnZXQgZHVyYXRpb24oKSB7XG4gICAgY29uc3QgcGxheW91dExpbWl0ID0gdGhpcy5wbGF5b3V0TGltaXQ7XG4gICAgbGV0IGR1cmF0aW9uO1xuICAgIGlmICh0aGlzLl9kdXJhdGlvbiAhPT0gbnVsbCkge1xuICAgICAgZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbjtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZGF0ZVJhbmdlLmR1cmF0aW9uKSB7XG4gICAgICBkdXJhdGlvbiA9IHRoaXMuZGF0ZVJhbmdlLmR1cmF0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICBkdXJhdGlvbiA9IHRoaXMuZGF0ZVJhbmdlLnBsYW5uZWREdXJhdGlvbiB8fCAwO1xuICAgIH1cbiAgICBpZiAoIWlzTmFOKHBsYXlvdXRMaW1pdCkgJiYgcGxheW91dExpbWl0IDwgZHVyYXRpb24pIHtcbiAgICAgIGR1cmF0aW9uID0gcGxheW91dExpbWl0O1xuICAgIH1cbiAgICByZXR1cm4gZHVyYXRpb247XG4gIH1cbiAgc2V0IGR1cmF0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5fZHVyYXRpb24gPSB2YWx1ZTtcbiAgfVxuICBnZXQgY3VlKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGVSYW5nZS5jdWU7XG4gIH1cbiAgZ2V0IHRpbWVsaW5lT2NjdXBhbmN5KCkge1xuICAgIGlmICh0aGlzLmRhdGVSYW5nZS5hdHRyWydYLVRJTUVMSU5FLU9DQ1VQSUVTJ10gPT09ICdSQU5HRScpIHtcbiAgICAgIHJldHVybiBUaW1lbGluZU9jY3VwYW5jeS5SYW5nZTtcbiAgICB9XG4gICAgcmV0dXJuIFRpbWVsaW5lT2NjdXBhbmN5LlBvaW50O1xuICB9XG4gIGdldCBzdXBwbGVtZW50c1ByaW1hcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0ZVJhbmdlLmF0dHJbJ1gtVElNRUxJTkUtU1RZTEUnXSA9PT0gJ1BSSU1BUlknO1xuICB9XG4gIGdldCBjb250ZW50TWF5VmFyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlUmFuZ2UuYXR0clsnWC1DT05URU5ULU1BWS1WQVJZJ10gIT09ICdOTyc7XG4gIH1cbiAgZ2V0IGFzc2V0VXJsKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGVSYW5nZS5hdHRyWydYLUFTU0VULVVSSSddO1xuICB9XG4gIGdldCBhc3NldExpc3RVcmwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0ZVJhbmdlLmF0dHJbJ1gtQVNTRVQtTElTVCddO1xuICB9XG4gIGdldCBiYXNlVXJsKCkge1xuICAgIHJldHVybiB0aGlzLmJhc2UudXJsO1xuICB9XG4gIGdldCBhc3NldExpc3RMb2FkZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXNzZXRMaXN0Lmxlbmd0aCA+IDAgfHwgdGhpcy5hc3NldExpc3RSZXNwb25zZSAhPT0gbnVsbDtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gZXZlbnRUb1N0cmluZyh0aGlzKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0U25hcFRvRnJhZ21lbnRUaW1lKHRpbWUsIGZyYWcpIHtcbiAgcmV0dXJuIHRpbWUgLSBmcmFnLnN0YXJ0IDwgZnJhZy5kdXJhdGlvbiAvIDIgJiYgIShNYXRoLmFicyh0aW1lIC0gKGZyYWcuc3RhcnQgKyBmcmFnLmR1cmF0aW9uKSkgPCBBTElHTkVEX0VORF9USFJFU0hPTERfU0VDT05EUykgPyBmcmFnLnN0YXJ0IDogZnJhZy5zdGFydCArIGZyYWcuZHVyYXRpb247XG59XG5mdW5jdGlvbiBnZXRJbnRlcnN0aXRpYWxVcmwodXJpLCBzZXNzaW9uSWQsIGJhc2VVcmwpIHtcbiAgY29uc3QgdXJsID0gbmV3IHNlbGYuVVJMKHVyaSwgYmFzZVVybCk7XG4gIGlmICh1cmwucHJvdG9jb2wgIT09ICdkYXRhOicpIHtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnX0hMU19wcmltYXJ5X2lkJywgc2Vzc2lvbklkKTtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuZnVuY3Rpb24gZ2V0TmV4dEFzc2V0SW5kZXgoaW50ZXJzdGl0aWFsLCBhc3NldExpc3RJbmRleCkge1xuICB3aGlsZSAoKF9pbnRlcnN0aXRpYWwkYXNzZXRMaSA9IGludGVyc3RpdGlhbC5hc3NldExpc3RbKythc3NldExpc3RJbmRleF0pICE9IG51bGwgJiYgX2ludGVyc3RpdGlhbCRhc3NldExpLmVycm9yKSB7XG4gICAgdmFyIF9pbnRlcnN0aXRpYWwkYXNzZXRMaTtcbiAgfSAvKiBuby1vcCAqL1xuICByZXR1cm4gYXNzZXRMaXN0SW5kZXg7XG59XG5mdW5jdGlvbiBldmVudFRvU3RyaW5nKGludGVyc3RpdGlhbCkge1xuICByZXR1cm4gYFtcIiR7aW50ZXJzdGl0aWFsLmlkZW50aWZpZXJ9XCIgJHtpbnRlcnN0aXRpYWwuY3VlLnByZSA/ICc8cHJlPicgOiBpbnRlcnN0aXRpYWwuY3VlLnBvc3QgPyAnPHBvc3Q+JyA6ICcnfSR7aW50ZXJzdGl0aWFsLnRpbWVsaW5lU3RhcnQudG9GaXhlZCgyKX0tJHtpbnRlcnN0aXRpYWwucmVzdW1lVGltZS50b0ZpeGVkKDIpfV1gO1xufVxuZnVuY3Rpb24gZXZlbnRBc3NldFRvU3RyaW5nKGFzc2V0KSB7XG4gIGNvbnN0IHN0YXJ0ID0gYXNzZXQudGltZWxpbmVTdGFydDtcbiAgY29uc3QgZHVyYXRpb24gPSBhc3NldC5kdXJhdGlvbiB8fCAwO1xuICByZXR1cm4gYFtcIiR7YXNzZXQuaWRlbnRpZmllcn1cIiAke3N0YXJ0LnRvRml4ZWQoMil9LSR7KHN0YXJ0ICsgZHVyYXRpb24pLnRvRml4ZWQoMil9XWA7XG59XG5cbmNsYXNzIEhsc0Fzc2V0UGxheWVyIHtcbiAgY29uc3RydWN0b3IoSGxzUGxheWVyQ2xhc3MsIHVzZXJDb25maWcsIGludGVyc3RpdGlhbCwgYXNzZXRJdGVtKSB7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5pbnRlcnN0aXRpYWwgPSB2b2lkIDA7XG4gICAgdGhpcy5hc3NldEl0ZW0gPSB2b2lkIDA7XG4gICAgdGhpcy50cmFja3MgPSBudWxsO1xuICAgIHRoaXMuaGFzRGV0YWlscyA9IGZhbHNlO1xuICAgIHRoaXMubWVkaWFBdHRhY2hlZCA9IG51bGw7XG4gICAgdGhpcy5fY3VycmVudFRpbWUgPSB2b2lkIDA7XG4gICAgdGhpcy5fYnVmZmVyZWRFb3NUaW1lID0gdm9pZCAwO1xuICAgIHRoaXMuY2hlY2tQbGF5b3V0ID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMucmVhY2hlZFBsYXlvdXQodGhpcy5jdXJyZW50VGltZSkpIHtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuUExBWU9VVF9MSU1JVF9SRUFDSEVELCB7fSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscyA9IG5ldyBIbHNQbGF5ZXJDbGFzcyh1c2VyQ29uZmlnKTtcbiAgICB0aGlzLmludGVyc3RpdGlhbCA9IGludGVyc3RpdGlhbDtcbiAgICB0aGlzLmFzc2V0SXRlbSA9IGFzc2V0SXRlbTtcbiAgICBsZXQgdXJpID0gYXNzZXRJdGVtLnVyaTtcbiAgICB0cnkge1xuICAgICAgdXJpID0gZ2V0SW50ZXJzdGl0aWFsVXJsKHVyaSwgdXNlckNvbmZpZy5wcmltYXJ5U2Vzc2lvbklkKS5ocmVmO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBJZ25vcmUgZXJyb3IgcGFyc2luZyBBU1NFVF9VUkkgb3IgYWRkaW5nIF9ITFNfcHJpbWFyeV9pZCB0byBpdC4gVGhlXG4gICAgICAvLyBpc3N1ZSBzaG91bGQgc3VyZmFjZSBhcyBhbiBJTlRFUlNUSVRJQUxfQVNTRVRfRVJST1IgbG9hZGluZyB0aGUgYXNzZXQuXG4gICAgfVxuICAgIGhscy5sb2FkU291cmNlKHVyaSk7XG4gICAgY29uc3QgZGV0YWlsc0xvYWRlZCA9ICgpID0+IHtcbiAgICAgIHRoaXMuaGFzRGV0YWlscyA9IHRydWU7XG4gICAgfTtcbiAgICBobHMub25jZShFdmVudHMuTEVWRUxfTE9BREVELCBkZXRhaWxzTG9hZGVkKTtcbiAgICBobHMub25jZShFdmVudHMuQVVESU9fVFJBQ0tfTE9BREVELCBkZXRhaWxzTG9hZGVkKTtcbiAgICBobHMub25jZShFdmVudHMuU1VCVElUTEVfVFJBQ0tfTE9BREVELCBkZXRhaWxzTG9hZGVkKTtcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0FUVEFDSElORywgKG5hbWUsIHtcbiAgICAgIG1lZGlhXG4gICAgfSkgPT4ge1xuICAgICAgdGhpcy5yZW1vdmVNZWRpYUxpc3RlbmVycygpO1xuICAgICAgdGhpcy5tZWRpYUF0dGFjaGVkID0gbWVkaWE7XG4gICAgICBjb25zdCBldmVudCA9IHRoaXMuaW50ZXJzdGl0aWFsO1xuICAgICAgaWYgKGV2ZW50LnBsYXlvdXRMaW1pdCkge1xuICAgICAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCd0aW1ldXBkYXRlJywgdGhpcy5jaGVja1BsYXlvdXQpO1xuICAgICAgICBpZiAodGhpcy5hcHBlbmRJblBsYWNlKSB7XG4gICAgICAgICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfQVBQRU5ERUQsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlcmVkRW5kID0gdGhpcy5idWZmZXJlZEVuZDtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWNoZWRQbGF5b3V0KGJ1ZmZlcmVkRW5kKSkge1xuICAgICAgICAgICAgICB0aGlzLl9idWZmZXJlZEVvc1RpbWUgPSBidWZmZXJlZEVuZDtcbiAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUkVEX1RPX0VORCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldCBhcHBlbmRJblBsYWNlKCkge1xuICAgIHZhciBfdGhpcyRpbnRlcnN0aXRpYWw7XG4gICAgcmV0dXJuICgoX3RoaXMkaW50ZXJzdGl0aWFsID0gdGhpcy5pbnRlcnN0aXRpYWwpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRpbnRlcnN0aXRpYWwuYXBwZW5kSW5QbGFjZSkgfHwgZmFsc2U7XG4gIH1cbiAgYnVmZmVyZWRJblBsYWNlVG9FbmQobWVkaWEpIHtcbiAgICB2YXIgX3RoaXMkaGxzO1xuICAgIGlmICghdGhpcy5hcHBlbmRJblBsYWNlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICgoX3RoaXMkaGxzID0gdGhpcy5obHMpICE9IG51bGwgJiYgX3RoaXMkaGxzLmJ1ZmZlcmVkVG9FbmQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIW1lZGlhIHx8ICF0aGlzLl9idWZmZXJlZEVvc1RpbWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLnRpbWVsaW5lT2Zmc2V0O1xuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhtZWRpYSwgc3RhcnQsIDApO1xuICAgIGNvbnN0IGJ1ZmZlcmVkRW5kID0gdGhpcy5nZXRBc3NldFRpbWUoYnVmZmVySW5mby5lbmQpO1xuICAgIHJldHVybiBidWZmZXJlZEVuZCA+PSB0aGlzLl9idWZmZXJlZEVvc1RpbWUgLSAwLjAyO1xuICB9XG4gIHJlYWNoZWRQbGF5b3V0KHRpbWUpIHtcbiAgICBjb25zdCBpbnRlcnN0aXRpYWwgPSB0aGlzLmludGVyc3RpdGlhbDtcbiAgICBjb25zdCBwbGF5b3V0TGltaXQgPSBpbnRlcnN0aXRpYWwucGxheW91dExpbWl0O1xuICAgIHJldHVybiB0aGlzLnN0YXJ0T2Zmc2V0ICsgdGltZSA+PSBwbGF5b3V0TGltaXQ7XG4gIH1cbiAgZ2V0IGRlc3Ryb3llZCgpIHtcbiAgICB2YXIgX3RoaXMkaGxzMjtcbiAgICByZXR1cm4gISgoX3RoaXMkaGxzMiA9IHRoaXMuaGxzKSAhPSBudWxsICYmIF90aGlzJGhsczIudXNlckNvbmZpZyk7XG4gIH1cbiAgZ2V0IGFzc2V0SWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXNzZXRJdGVtLmlkZW50aWZpZXI7XG4gIH1cbiAgZ2V0IGludGVyc3RpdGlhbElkKCkge1xuICAgIHJldHVybiB0aGlzLmFzc2V0SXRlbS5wYXJlbnRJZGVudGlmaWVyO1xuICB9XG4gIGdldCBtZWRpYSgpIHtcbiAgICB2YXIgX3RoaXMkaGxzMztcbiAgICByZXR1cm4gKChfdGhpcyRobHMzID0gdGhpcy5obHMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRobHMzLm1lZGlhKSB8fCBudWxsO1xuICB9XG4gIGdldCBidWZmZXJlZEVuZCgpIHtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWEgfHwgdGhpcy5tZWRpYUF0dGFjaGVkO1xuICAgIGlmICghbWVkaWEpIHtcbiAgICAgIGlmICh0aGlzLl9idWZmZXJlZEVvc1RpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlcmVkRW9zVGltZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRUaW1lO1xuICAgIH1cbiAgICBjb25zdCBidWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8obWVkaWEsIG1lZGlhLmN1cnJlbnRUaW1lLCAwLjAwMSk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXNzZXRUaW1lKGJ1ZmZlckluZm8uZW5kKTtcbiAgfVxuICBnZXQgY3VycmVudFRpbWUoKSB7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhIHx8IHRoaXMubWVkaWFBdHRhY2hlZDtcbiAgICBpZiAoIW1lZGlhKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY3VycmVudFRpbWUgfHwgMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXNzZXRUaW1lKG1lZGlhLmN1cnJlbnRUaW1lKTtcbiAgfVxuICBnZXQgZHVyYXRpb24oKSB7XG4gICAgY29uc3QgZHVyYXRpb24gPSB0aGlzLmFzc2V0SXRlbS5kdXJhdGlvbjtcbiAgICBpZiAoIWR1cmF0aW9uKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIGR1cmF0aW9uO1xuICB9XG4gIGdldCByZW1haW5pbmcoKSB7XG4gICAgY29uc3QgZHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uO1xuICAgIGlmICghZHVyYXRpb24pIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgZHVyYXRpb24gLSB0aGlzLmN1cnJlbnRUaW1lKTtcbiAgfVxuICBnZXQgc3RhcnRPZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXNzZXRJdGVtLnN0YXJ0T2Zmc2V0O1xuICB9XG4gIGdldCB0aW1lbGluZU9mZnNldCgpIHtcbiAgICB2YXIgX3RoaXMkaGxzNDtcbiAgICByZXR1cm4gKChfdGhpcyRobHM0ID0gdGhpcy5obHMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRobHM0LmNvbmZpZy50aW1lbGluZU9mZnNldCkgfHwgMDtcbiAgfVxuICBzZXQgdGltZWxpbmVPZmZzZXQodmFsdWUpIHtcbiAgICBjb25zdCB0aW1lbGluZU9mZnNldCA9IHRoaXMudGltZWxpbmVPZmZzZXQ7XG4gICAgaWYgKHZhbHVlICE9PSB0aW1lbGluZU9mZnNldCkge1xuICAgICAgY29uc3QgZGlmZiA9IHZhbHVlIC0gdGltZWxpbmVPZmZzZXQ7XG4gICAgICBpZiAoTWF0aC5hYnMoZGlmZikgPiAxIC8gOTAwMDApIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzRGV0YWlscykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHNldCB0aW1lbGluZU9mZnNldCBhZnRlciBwbGF5bGlzdHMgYXJlIGxvYWRlZGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGxzLmNvbmZpZy50aW1lbGluZU9mZnNldCA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXRBc3NldFRpbWUodGltZSkge1xuICAgIGNvbnN0IHRpbWVsaW5lT2Zmc2V0ID0gdGhpcy50aW1lbGluZU9mZnNldDtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHRoaXMuZHVyYXRpb247XG4gICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KDAsIHRpbWUgLSB0aW1lbGluZU9mZnNldCksIGR1cmF0aW9uKTtcbiAgfVxuICByZW1vdmVNZWRpYUxpc3RlbmVycygpIHtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWFBdHRhY2hlZDtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgICB0aGlzLmJ1ZmZlclNuYXBTaG90KCk7XG4gICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCd0aW1ldXBkYXRlJywgdGhpcy5jaGVja1BsYXlvdXQpO1xuICAgIH1cbiAgfVxuICBidWZmZXJTbmFwU2hvdCgpIHtcbiAgICBpZiAodGhpcy5tZWRpYUF0dGFjaGVkKSB7XG4gICAgICB2YXIgX3RoaXMkaGxzNTtcbiAgICAgIGlmICgoX3RoaXMkaGxzNSA9IHRoaXMuaGxzKSAhPSBudWxsICYmIF90aGlzJGhsczUuYnVmZmVyZWRUb0VuZCkge1xuICAgICAgICB0aGlzLl9idWZmZXJlZEVvc1RpbWUgPSB0aGlzLmJ1ZmZlcmVkRW5kO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVtb3ZlTWVkaWFMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmhscy5kZXN0cm95KCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuaGxzID0gdGhpcy5pbnRlcnN0aXRpYWwgPSBudWxsO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLnRyYWNrcyA9IHRoaXMubWVkaWFBdHRhY2hlZCA9IHRoaXMuY2hlY2tQbGF5b3V0ID0gbnVsbDtcbiAgfVxuICBhdHRhY2hNZWRpYShkYXRhKSB7XG4gICAgdGhpcy5obHMuYXR0YWNoTWVkaWEoZGF0YSk7XG4gIH1cbiAgZGV0YWNoTWVkaWEoKSB7XG4gICAgdGhpcy5yZW1vdmVNZWRpYUxpc3RlbmVycygpO1xuICAgIHRoaXMubWVkaWFBdHRhY2hlZCA9IG51bGw7XG4gICAgdGhpcy5obHMuZGV0YWNoTWVkaWEoKTtcbiAgfVxuICByZXN1bWVCdWZmZXJpbmcoKSB7XG4gICAgdGhpcy5obHMucmVzdW1lQnVmZmVyaW5nKCk7XG4gIH1cbiAgcGF1c2VCdWZmZXJpbmcoKSB7XG4gICAgdGhpcy5obHMucGF1c2VCdWZmZXJpbmcoKTtcbiAgfVxuICB0cmFuc2Zlck1lZGlhKCkge1xuICAgIHRoaXMuYnVmZmVyU25hcFNob3QoKTtcbiAgICByZXR1cm4gdGhpcy5obHMudHJhbnNmZXJNZWRpYSgpO1xuICB9XG4gIHJlc2V0RGV0YWlscygpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBpZiAodGhpcy5oYXNEZXRhaWxzKSB7XG4gICAgICBobHMuc3RvcExvYWQoKTtcbiAgICAgIGNvbnN0IGRlbGV0ZURldGFpbHMgPSBvYmogPT4gZGVsZXRlIG9iai5kZXRhaWxzO1xuICAgICAgaGxzLmxldmVscy5mb3JFYWNoKGRlbGV0ZURldGFpbHMpO1xuICAgICAgaGxzLmFsbEF1ZGlvVHJhY2tzLmZvckVhY2goZGVsZXRlRGV0YWlscyk7XG4gICAgICBobHMuYWxsU3VidGl0bGVUcmFja3MuZm9yRWFjaChkZWxldGVEZXRhaWxzKTtcbiAgICAgIHRoaXMuaGFzRGV0YWlscyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBvbihldmVudCwgbGlzdGVuZXIsIGNvbnRleHQpIHtcbiAgICB0aGlzLmhscy5vbihldmVudCwgbGlzdGVuZXIpO1xuICB9XG4gIG9uY2UoZXZlbnQsIGxpc3RlbmVyLCBjb250ZXh0KSB7XG4gICAgdGhpcy5obHMub25jZShldmVudCwgbGlzdGVuZXIpO1xuICB9XG4gIG9mZihldmVudCwgbGlzdGVuZXIsIGNvbnRleHQpIHtcbiAgICB0aGlzLmhscy5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICB2YXIgX3RoaXMkaGxzNjtcbiAgICByZXR1cm4gYEhsc0Fzc2V0UGxheWVyOiAke2V2ZW50QXNzZXRUb1N0cmluZyh0aGlzLmFzc2V0SXRlbSl9ICR7KF90aGlzJGhsczYgPSB0aGlzLmhscykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGhsczYuc2Vzc2lvbklkfSAke3RoaXMuYXBwZW5kSW5QbGFjZSA/ICdhcHBlbmQtaW4tcGxhY2UnIDogJyd9YDtcbiAgfVxufVxuXG5jb25zdCBBQlVUVElOR19USFJFU0hPTERfU0VDT05EUyA9IDAuMDMzO1xuY2xhc3MgSW50ZXJzdGl0aWFsc1NjaGVkdWxlIGV4dGVuZHMgTG9nZ2VyIHtcbiAgY29uc3RydWN0b3Iob25TY2hlZHVsZVVwZGF0ZSwgbG9nZ2VyKSB7XG4gICAgc3VwZXIoJ2ludGVyc3RpdGlhbHMtc2NoZWQnLCBsb2dnZXIpO1xuICAgIHRoaXMub25TY2hlZHVsZVVwZGF0ZSA9IHZvaWQgMDtcbiAgICB0aGlzLmV2ZW50TWFwID0ge307XG4gICAgdGhpcy5ldmVudHMgPSBudWxsO1xuICAgIHRoaXMuaXRlbXMgPSBudWxsO1xuICAgIHRoaXMuZHVyYXRpb25zID0ge1xuICAgICAgcHJpbWFyeTogMCxcbiAgICAgIHBsYXlvdXQ6IDAsXG4gICAgICBpbnRlZ3JhdGVkOiAwXG4gICAgfTtcbiAgICB0aGlzLm9uU2NoZWR1bGVVcGRhdGUgPSBvblNjaGVkdWxlVXBkYXRlO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZXNldCgpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLm9uU2NoZWR1bGVVcGRhdGUgPSBudWxsO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuZXZlbnRNYXAgPSB7fTtcbiAgICB0aGlzLnNldER1cmF0aW9ucygwLCAwLCAwKTtcbiAgICBpZiAodGhpcy5ldmVudHMpIHtcbiAgICAgIHRoaXMuZXZlbnRzLmZvckVhY2goaW50ZXJzdGl0aWFsID0+IGludGVyc3RpdGlhbC5yZXNldCgpKTtcbiAgICB9XG4gICAgdGhpcy5ldmVudHMgPSB0aGlzLml0ZW1zID0gbnVsbDtcbiAgfVxuICByZXNldEVycm9yc0luUmFuZ2Uoc3RhcnQsIGVuZCkge1xuICAgIGlmICh0aGlzLmV2ZW50cykge1xuICAgICAgcmV0dXJuIHRoaXMuZXZlbnRzLnJlZHVjZSgoY291bnQsIGludGVyc3RpdGlhbCkgPT4ge1xuICAgICAgICBpZiAoc3RhcnQgPD0gaW50ZXJzdGl0aWFsLnN0YXJ0T2Zmc2V0ICYmIGVuZCA+IGludGVyc3RpdGlhbC5zdGFydE9mZnNldCkge1xuICAgICAgICAgIGRlbGV0ZSBpbnRlcnN0aXRpYWwuZXJyb3I7XG4gICAgICAgICAgcmV0dXJuIGNvdW50ICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZ2V0IGR1cmF0aW9uKCkge1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5pdGVtcztcbiAgICByZXR1cm4gaXRlbXMgPyBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXS5lbmQgOiAwO1xuICB9XG4gIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXMgPyB0aGlzLml0ZW1zLmxlbmd0aCA6IDA7XG4gIH1cbiAgZ2V0RXZlbnQoaWRlbnRpZmllcikge1xuICAgIHJldHVybiBpZGVudGlmaWVyID8gdGhpcy5ldmVudE1hcFtpZGVudGlmaWVyXSB8fCBudWxsIDogbnVsbDtcbiAgfVxuICBoYXNFdmVudChpZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIGlkZW50aWZpZXIgaW4gdGhpcy5ldmVudE1hcDtcbiAgfVxuICBmaW5kSXRlbUluZGV4KGl0ZW0sIHRpbWUpIHtcbiAgICBpZiAoaXRlbS5ldmVudCkge1xuICAgICAgLy8gRmluZCBFdmVudCBJdGVtXG4gICAgICByZXR1cm4gdGhpcy5maW5kRXZlbnRJbmRleChpdGVtLmV2ZW50LmlkZW50aWZpZXIpO1xuICAgIH1cbiAgICAvLyBGaW5kIFByaW1hcnkgSXRlbVxuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGlmIChpdGVtLm5leHRFdmVudCkge1xuICAgICAgaW5kZXggPSB0aGlzLmZpbmRFdmVudEluZGV4KGl0ZW0ubmV4dEV2ZW50LmlkZW50aWZpZXIpIC0gMTtcbiAgICB9IGVsc2UgaWYgKGl0ZW0ucHJldmlvdXNFdmVudCkge1xuICAgICAgaW5kZXggPSB0aGlzLmZpbmRFdmVudEluZGV4KGl0ZW0ucHJldmlvdXNFdmVudC5pZGVudGlmaWVyKSArIDE7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5pdGVtcztcbiAgICBpZiAoaXRlbXMpIHtcbiAgICAgIGlmICghaXRlbXNbaW5kZXhdKSB7XG4gICAgICAgIGlmICh0aW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aW1lID0gaXRlbS5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IHRoaXMuZmluZEl0ZW1JbmRleEF0VGltZSh0aW1lKTtcbiAgICAgIH1cbiAgICAgIC8vIE9ubHkgcmV0dXJuIGluZGV4IG9mIGEgUHJpbWFyeSBJdGVtXG4gICAgICB3aGlsZSAoaW5kZXggPj0gMCAmJiAoX2l0ZW1zJGluZGV4ID0gaXRlbXNbaW5kZXhdKSAhPSBudWxsICYmIF9pdGVtcyRpbmRleC5ldmVudCkge1xuICAgICAgICB2YXIgX2l0ZW1zJGluZGV4O1xuICAgICAgICAvLyBJZiBpbmRleCBmb3VuZCBpcyBhbiBpbnRlcnN0aXRpYWwgaXQgaXMgbm90IGEgdmFsaWQgcmVzdWx0IGFzIGl0IHNob3VsZCBoYXZlIGJlZW4gbWF0Y2hlZCB1cCB0b3BcbiAgICAgICAgLy8gZGVjcmVtZW50IHVudGlsIHJlc3VsdCBpcyBuZWdhdGl2ZSAobm90IGZvdW5kKSBvciBhIHByaW1hcnkgc2VnbWVudFxuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cbiAgZmluZEl0ZW1JbmRleEF0VGltZSh0aW1lbGluZVBvcywgdGltZWxpbmVUeXBlKSB7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgIGlmIChpdGVtcykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgdGltZVJhbmdlID0gaXRlbXNbaV07XG4gICAgICAgIGlmICh0aW1lbGluZVR5cGUgJiYgdGltZWxpbmVUeXBlICE9PSAncHJpbWFyeScpIHtcbiAgICAgICAgICB0aW1lUmFuZ2UgPSB0aW1lUmFuZ2VbdGltZWxpbmVUeXBlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZWxpbmVQb3MgPT09IHRpbWVSYW5nZS5zdGFydCB8fCB0aW1lbGluZVBvcyA+IHRpbWVSYW5nZS5zdGFydCAmJiB0aW1lbGluZVBvcyA8IHRpbWVSYW5nZS5lbmQpIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgZmluZEp1bXBSZXN0cmljdGVkSW5kZXgoc3RhcnRJbmRleCwgZW5kSW5kZXgpIHtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuaXRlbXM7XG4gICAgaWYgKGl0ZW1zKSB7XG4gICAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8PSBlbmRJbmRleDsgaSsrKSB7XG4gICAgICAgIGlmICghaXRlbXNbaV0pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBldmVudCA9IGl0ZW1zW2ldLmV2ZW50O1xuICAgICAgICBpZiAoZXZlbnQgIT0gbnVsbCAmJiBldmVudC5yZXN0cmljdGlvbnMuanVtcCAmJiAhZXZlbnQuYXBwZW5kSW5QbGFjZSkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICBmaW5kRXZlbnRJbmRleChpZGVudGlmaWVyKSB7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgIGlmIChpdGVtcykge1xuICAgICAgZm9yIChsZXQgaSA9IGl0ZW1zLmxlbmd0aDsgaS0tOykge1xuICAgICAgICB2YXIgX2l0ZW1zJGkkZXZlbnQ7XG4gICAgICAgIGlmICgoKF9pdGVtcyRpJGV2ZW50ID0gaXRlbXNbaV0uZXZlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfaXRlbXMkaSRldmVudC5pZGVudGlmaWVyKSA9PT0gaWRlbnRpZmllcikge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICBmaW5kQXNzZXRJbmRleChldmVudCwgdGltZWxpbmVQb3MpIHtcbiAgICBjb25zdCBhc3NldExpc3QgPSBldmVudC5hc3NldExpc3Q7XG4gICAgY29uc3QgbGVuZ3RoID0gYXNzZXRMaXN0Lmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoID4gMSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhc3NldCA9IGFzc2V0TGlzdFtpXTtcbiAgICAgICAgaWYgKCFhc3NldC5lcnJvcikge1xuICAgICAgICAgIGNvbnN0IHRpbWVsaW5lU3RhcnQgPSBhc3NldC50aW1lbGluZVN0YXJ0O1xuICAgICAgICAgIGlmICh0aW1lbGluZVBvcyA9PT0gdGltZWxpbmVTdGFydCB8fCB0aW1lbGluZVBvcyA+IHRpbWVsaW5lU3RhcnQgJiYgdGltZWxpbmVQb3MgPCB0aW1lbGluZVN0YXJ0ICsgKGFzc2V0LmR1cmF0aW9uIHx8IDApKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZ2V0IGFzc2V0SWRBdEVuZCgpIHtcbiAgICB2YXIgX3RoaXMkaXRlbXMsIF90aGlzJGl0ZW1zMjtcbiAgICBjb25zdCBpbnRlcnN0aXRpYWxBdEVuZCA9IChfdGhpcyRpdGVtcyA9IHRoaXMuaXRlbXMpID09IG51bGwgPyB2b2lkIDAgOiAoX3RoaXMkaXRlbXMyID0gX3RoaXMkaXRlbXNbdGhpcy5sZW5ndGggLSAxXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGl0ZW1zMi5ldmVudDtcbiAgICBpZiAoaW50ZXJzdGl0aWFsQXRFbmQpIHtcbiAgICAgIGNvbnN0IGFzc2V0TGlzdCA9IGludGVyc3RpdGlhbEF0RW5kLmFzc2V0TGlzdDtcbiAgICAgIGNvbnN0IGFzc2V0QXRFbmQgPSBhc3NldExpc3RbYXNzZXRMaXN0Lmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGFzc2V0QXRFbmQpIHtcbiAgICAgICAgcmV0dXJuIGFzc2V0QXRFbmQuaWRlbnRpZmllcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcGFyc2VJbnRlcnN0aXRpYWxEYXRlUmFuZ2VzKG1lZGlhU2VsZWN0aW9uLCBlbmFibGVBcHBlbmRJblBsYWNlKSB7XG4gICAgY29uc3QgZGV0YWlscyA9IG1lZGlhU2VsZWN0aW9uLm1haW4uZGV0YWlscztcbiAgICBjb25zdCB7XG4gICAgICBkYXRlUmFuZ2VzXG4gICAgfSA9IGRldGFpbHM7XG4gICAgY29uc3QgcHJldmlvdXNJbnRlcnN0aXRpYWxFdmVudHMgPSB0aGlzLmV2ZW50cztcbiAgICBjb25zdCBpbnRlcnN0aXRpYWxFdmVudHMgPSB0aGlzLnBhcnNlRGF0ZVJhbmdlcyhkYXRlUmFuZ2VzLCB7XG4gICAgICB1cmw6IGRldGFpbHMudXJsXG4gICAgfSwgZW5hYmxlQXBwZW5kSW5QbGFjZSk7XG4gICAgY29uc3QgaWRzID0gT2JqZWN0LmtleXMoZGF0ZVJhbmdlcyk7XG4gICAgY29uc3QgcmVtb3ZlZEludGVyc3RpdGlhbHMgPSBwcmV2aW91c0ludGVyc3RpdGlhbEV2ZW50cyA/IHByZXZpb3VzSW50ZXJzdGl0aWFsRXZlbnRzLmZpbHRlcihldmVudCA9PiAhaWRzLmluY2x1ZGVzKGV2ZW50LmlkZW50aWZpZXIpKSA6IFtdO1xuICAgIGlmIChpbnRlcnN0aXRpYWxFdmVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBwcmUtcm9sbHMsIHBvc3Qtcm9sbHMsIGFuZCBldmVudHMgd2l0aCB0aGUgc2FtZSBzdGFydCB0aW1lIGFyZSBwbGF5ZWQgaW4gcGxheWxpc3QgdGFnIG9yZGVyXG4gICAgICAvLyBhbGwgb3RoZXIgZXZlbnRzIGFyZSBvcmRlcmVkIGJ5IHN0YXJ0IHRpbWVcbiAgICAgIGludGVyc3RpdGlhbEV2ZW50cy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgIGNvbnN0IGFQcmUgPSBhLmN1ZS5wcmU7XG4gICAgICAgIGNvbnN0IGFQb3N0ID0gYS5jdWUucG9zdDtcbiAgICAgICAgY29uc3QgYlByZSA9IGIuY3VlLnByZTtcbiAgICAgICAgY29uc3QgYlBvc3QgPSBiLmN1ZS5wb3N0O1xuICAgICAgICBpZiAoYVByZSAmJiAhYlByZSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYlByZSAmJiAhYVByZSkge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhUG9zdCAmJiAhYlBvc3QpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYlBvc3QgJiYgIWFQb3N0KSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYVByZSAmJiAhYlByZSAmJiAhYVBvc3QgJiYgIWJQb3N0KSB7XG4gICAgICAgICAgY29uc3Qgc3RhcnRBID0gYS5zdGFydFRpbWU7XG4gICAgICAgICAgY29uc3Qgc3RhcnRCID0gYi5zdGFydFRpbWU7XG4gICAgICAgICAgaWYgKHN0YXJ0QSAhPT0gc3RhcnRCKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnRBIC0gc3RhcnRCO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYS5kYXRlUmFuZ2UudGFnT3JkZXIgLSBiLmRhdGVSYW5nZS50YWdPcmRlcjtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLmV2ZW50cyA9IGludGVyc3RpdGlhbEV2ZW50cztcblxuICAgIC8vIENsZWFyIHJlbW92ZWQgRGF0ZVJhbmdlcyBmcm9tIGJ1ZmZlcmVkIGxpc3QgKGtpbGxzIHBsYXliYWNrIG9mIGFjdGl2ZSBJbnRlcnN0aXRpYWxzKVxuICAgIHJlbW92ZWRJbnRlcnN0aXRpYWxzLmZvckVhY2goaW50ZXJzdGl0aWFsID0+IHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnQoaW50ZXJzdGl0aWFsKTtcbiAgICB9KTtcbiAgICB0aGlzLnVwZGF0ZVNjaGVkdWxlKG1lZGlhU2VsZWN0aW9uLCByZW1vdmVkSW50ZXJzdGl0aWFscyk7XG4gIH1cbiAgdXBkYXRlU2NoZWR1bGUobWVkaWFTZWxlY3Rpb24sIHJlbW92ZWRJbnRlcnN0aXRpYWxzID0gW10pIHtcbiAgICBjb25zdCBldmVudHMgPSB0aGlzLmV2ZW50cyB8fCBbXTtcbiAgICBpZiAoZXZlbnRzLmxlbmd0aCB8fCByZW1vdmVkSW50ZXJzdGl0aWFscy5sZW5ndGggfHwgdGhpcy5sZW5ndGggPCAyKSB7XG4gICAgICBjb25zdCBjdXJyZW50SXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgICAgY29uc3QgdXBkYXRlZEl0ZW1zID0gdGhpcy5wYXJzZVNjaGVkdWxlKGV2ZW50cywgbWVkaWFTZWxlY3Rpb24pO1xuICAgICAgY29uc3QgdXBkYXRlZCA9IHJlbW92ZWRJbnRlcnN0aXRpYWxzLmxlbmd0aCB8fCAoY3VycmVudEl0ZW1zID09IG51bGwgPyB2b2lkIDAgOiBjdXJyZW50SXRlbXMubGVuZ3RoKSAhPT0gdXBkYXRlZEl0ZW1zLmxlbmd0aCB8fCB1cGRhdGVkSXRlbXMuc29tZSgoaXRlbSwgaSkgPT4ge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoaXRlbS5wbGF5b3V0LnN0YXJ0IC0gY3VycmVudEl0ZW1zW2ldLnBsYXlvdXQuc3RhcnQpID4gMC4wMDUgfHwgTWF0aC5hYnMoaXRlbS5wbGF5b3V0LmVuZCAtIGN1cnJlbnRJdGVtc1tpXS5wbGF5b3V0LmVuZCkgPiAwLjAwNTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHVwZGF0ZWQpIHtcbiAgICAgICAgdGhpcy5pdGVtcyA9IHVwZGF0ZWRJdGVtcztcbiAgICAgICAgLy8gY2FsbCBpbnRlcnN0aXRpYWxzLWNvbnRyb2xsZXIgb25TY2hlZHVsZVVwZGF0ZWQoKVxuICAgICAgICB0aGlzLm9uU2NoZWR1bGVVcGRhdGUocmVtb3ZlZEludGVyc3RpdGlhbHMsIGN1cnJlbnRJdGVtcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBhcnNlRGF0ZVJhbmdlcyhkYXRlUmFuZ2VzLCBiYXNlRGF0YSwgZW5hYmxlQXBwZW5kSW5QbGFjZSkge1xuICAgIGNvbnN0IGludGVyc3RpdGlhbEV2ZW50cyA9IFtdO1xuICAgIGNvbnN0IGlkcyA9IE9iamVjdC5rZXlzKGRhdGVSYW5nZXMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpZCA9IGlkc1tpXTtcbiAgICAgIGNvbnN0IGRhdGVSYW5nZSA9IGRhdGVSYW5nZXNbaWRdO1xuICAgICAgaWYgKGRhdGVSYW5nZS5pc0ludGVyc3RpdGlhbCkge1xuICAgICAgICBsZXQgaW50ZXJzdGl0aWFsID0gdGhpcy5ldmVudE1hcFtpZF07XG4gICAgICAgIGlmIChpbnRlcnN0aXRpYWwpIHtcbiAgICAgICAgICAvLyBVcGRhdGUgSW50ZXJzdGl0aWFsRXZlbnQgYWxyZWFkeSBwYXJzZWQgYW5kIG1hcHBlZFxuICAgICAgICAgIC8vIFRoaXMgcmV0YWlucyBhbHJlYWR5IGxvYWRlZCBkdXJhdGlvbiBhbmQgbG9hZGVkIGFzc2V0IGxpc3QgaW5mb1xuICAgICAgICAgIGludGVyc3RpdGlhbC5zZXREYXRlUmFuZ2UoZGF0ZVJhbmdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnRlcnN0aXRpYWwgPSBuZXcgSW50ZXJzdGl0aWFsRXZlbnQoZGF0ZVJhbmdlLCBiYXNlRGF0YSk7XG4gICAgICAgICAgdGhpcy5ldmVudE1hcFtpZF0gPSBpbnRlcnN0aXRpYWw7XG4gICAgICAgICAgaWYgKGVuYWJsZUFwcGVuZEluUGxhY2UgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpbnRlcnN0aXRpYWwuYXBwZW5kSW5QbGFjZSA9IGVuYWJsZUFwcGVuZEluUGxhY2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGludGVyc3RpdGlhbEV2ZW50cy5wdXNoKGludGVyc3RpdGlhbCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbnRlcnN0aXRpYWxFdmVudHM7XG4gIH1cbiAgcGFyc2VTY2hlZHVsZShpbnRlcnN0aXRpYWxFdmVudHMsIG1lZGlhU2VsZWN0aW9uKSB7XG4gICAgY29uc3Qgc2NoZWR1bGUgPSBbXTtcbiAgICBjb25zdCBkZXRhaWxzID0gbWVkaWFTZWxlY3Rpb24ubWFpbi5kZXRhaWxzO1xuICAgIGNvbnN0IHByaW1hcnlEdXJhdGlvbiA9IGRldGFpbHMubGl2ZSA/IEluZmluaXR5IDogZGV0YWlscy5lZGdlO1xuICAgIGxldCBwbGF5b3V0RHVyYXRpb24gPSAwO1xuXG4gICAgLy8gRmlsdGVyIGV2ZW50cyB0aGF0IGhhdmUgZXJyb3JlZCBmcm9tIHRoZSBzY2hlZHVsZSAoUHJpbWFyeSBmYWxsYmFjaylcbiAgICBpbnRlcnN0aXRpYWxFdmVudHMgPSBpbnRlcnN0aXRpYWxFdmVudHMuZmlsdGVyKGV2ZW50ID0+ICFldmVudC5lcnJvciAmJiAhKGV2ZW50LmN1ZS5vbmNlICYmIGV2ZW50Lmhhc1BsYXllZCkpO1xuICAgIGlmIChpbnRlcnN0aXRpYWxFdmVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBVcGRhdGUgU2NoZWR1bGVcbiAgICAgIHRoaXMucmVzb2x2ZU9mZnNldHMoaW50ZXJzdGl0aWFsRXZlbnRzLCBtZWRpYVNlbGVjdGlvbik7XG5cbiAgICAgIC8vIFBvcHVsYXRlIFNjaGVkdWxlIHdpdGggSW50ZXJzdGl0aWFsIEV2ZW50IGFuZCBQcmltYXJ5IFNlZ21lbnQgSXRlbXNcbiAgICAgIGxldCBwcmltYXJ5UG9zaXRpb24gPSAwO1xuICAgICAgbGV0IGludGVncmF0ZWRUaW1lID0gMDtcbiAgICAgIGludGVyc3RpdGlhbEV2ZW50cy5mb3JFYWNoKChpbnRlcnN0aXRpYWwsIGkpID0+IHtcbiAgICAgICAgY29uc3QgcHJlcm9sbCA9IGludGVyc3RpdGlhbC5jdWUucHJlO1xuICAgICAgICBjb25zdCBwb3N0cm9sbCA9IGludGVyc3RpdGlhbC5jdWUucG9zdDtcbiAgICAgICAgY29uc3QgcHJldmlvdXNFdmVudCA9IGludGVyc3RpdGlhbEV2ZW50c1tpIC0gMV0gfHwgbnVsbDtcbiAgICAgICAgY29uc3QgYXBwZW5kSW5QbGFjZSA9IGludGVyc3RpdGlhbC5hcHBlbmRJblBsYWNlO1xuICAgICAgICBjb25zdCBldmVudFN0YXJ0ID0gcG9zdHJvbGwgPyBwcmltYXJ5RHVyYXRpb24gOiBpbnRlcnN0aXRpYWwuc3RhcnRPZmZzZXQ7XG4gICAgICAgIGNvbnN0IGludGVyc3RpdGlhbER1cmF0aW9uID0gaW50ZXJzdGl0aWFsLmR1cmF0aW9uO1xuICAgICAgICBjb25zdCB0aW1lbGluZUR1cmF0aW9uID0gaW50ZXJzdGl0aWFsLnRpbWVsaW5lT2NjdXBhbmN5ID09PSBUaW1lbGluZU9jY3VwYW5jeS5SYW5nZSA/IGludGVyc3RpdGlhbER1cmF0aW9uIDogMDtcbiAgICAgICAgY29uc3QgcmVzdW1wdGlvbk9mZnNldCA9IGludGVyc3RpdGlhbC5yZXN1bXB0aW9uT2Zmc2V0O1xuICAgICAgICBjb25zdCBpblNhbWVTdGFydFRpbWVTZXF1ZW5jZSA9IChwcmV2aW91c0V2ZW50ID09IG51bGwgPyB2b2lkIDAgOiBwcmV2aW91c0V2ZW50LnN0YXJ0VGltZSkgPT09IGV2ZW50U3RhcnQ7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gZXZlbnRTdGFydCArIGludGVyc3RpdGlhbC5jdW11bGF0aXZlRHVyYXRpb247XG4gICAgICAgIGxldCBlbmQgPSBhcHBlbmRJblBsYWNlID8gc3RhcnQgKyBpbnRlcnN0aXRpYWxEdXJhdGlvbiA6IGV2ZW50U3RhcnQgKyByZXN1bXB0aW9uT2Zmc2V0O1xuICAgICAgICBpZiAocHJlcm9sbCB8fCAhcG9zdHJvbGwgJiYgZXZlbnRTdGFydCA8PSAwKSB7XG4gICAgICAgICAgLy8gcHJlcm9sbCBvciBpbi1wcm9ncmVzcyBtaWRyb2xsXG4gICAgICAgICAgY29uc3QgaW50ZWdyYXRlZFN0YXJ0ID0gaW50ZWdyYXRlZFRpbWU7XG4gICAgICAgICAgaW50ZWdyYXRlZFRpbWUgKz0gdGltZWxpbmVEdXJhdGlvbjtcbiAgICAgICAgICBpbnRlcnN0aXRpYWwudGltZWxpbmVTdGFydCA9IHN0YXJ0O1xuICAgICAgICAgIGNvbnN0IHBsYXlvdXRTdGFydCA9IHBsYXlvdXREdXJhdGlvbjtcbiAgICAgICAgICBwbGF5b3V0RHVyYXRpb24gKz0gaW50ZXJzdGl0aWFsRHVyYXRpb247XG4gICAgICAgICAgc2NoZWR1bGUucHVzaCh7XG4gICAgICAgICAgICBldmVudDogaW50ZXJzdGl0aWFsLFxuICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICBlbmQsXG4gICAgICAgICAgICBwbGF5b3V0OiB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBwbGF5b3V0U3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogcGxheW91dER1cmF0aW9uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW50ZWdyYXRlZDoge1xuICAgICAgICAgICAgICBzdGFydDogaW50ZWdyYXRlZFN0YXJ0LFxuICAgICAgICAgICAgICBlbmQ6IGludGVncmF0ZWRUaW1lXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRTdGFydCA8PSBwcmltYXJ5RHVyYXRpb24pIHtcbiAgICAgICAgICBpZiAoIWluU2FtZVN0YXJ0VGltZVNlcXVlbmNlKSB7XG4gICAgICAgICAgICBjb25zdCBzZWdtZW50RHVyYXRpb24gPSBldmVudFN0YXJ0IC0gcHJpbWFyeVBvc2l0aW9uO1xuICAgICAgICAgICAgLy8gRG8gbm90IHNjaGVkdWxlIGEgcHJpbWFyeSBzZWdtZW50IGlmIGludGVyc3RpdGlhbHMgYXJlIGFidXR0aW5nIGJ5IGxlc3MgdGhhbiBBQlVUVElOR19USFJFU0hPTERfU0VDT05EU1xuICAgICAgICAgICAgaWYgKHNlZ21lbnREdXJhdGlvbiA+IEFCVVRUSU5HX1RIUkVTSE9MRF9TRUNPTkRTKSB7XG4gICAgICAgICAgICAgIC8vIHByaW1hcnkgc2VnbWVudFxuICAgICAgICAgICAgICBjb25zdCB0aW1lbGluZVN0YXJ0ID0gcHJpbWFyeVBvc2l0aW9uO1xuICAgICAgICAgICAgICBjb25zdCBfaW50ZWdyYXRlZFN0YXJ0ID0gaW50ZWdyYXRlZFRpbWU7XG4gICAgICAgICAgICAgIGludGVncmF0ZWRUaW1lICs9IHNlZ21lbnREdXJhdGlvbjtcbiAgICAgICAgICAgICAgY29uc3QgX3BsYXlvdXRTdGFydCA9IHBsYXlvdXREdXJhdGlvbjtcbiAgICAgICAgICAgICAgcGxheW91dER1cmF0aW9uICs9IHNlZ21lbnREdXJhdGlvbjtcbiAgICAgICAgICAgICAgY29uc3QgcHJpbWFyeVNlZ21lbnQgPSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNFdmVudDogaW50ZXJzdGl0aWFsRXZlbnRzW2kgLSAxXSB8fCBudWxsLFxuICAgICAgICAgICAgICAgIG5leHRFdmVudDogaW50ZXJzdGl0aWFsLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiB0aW1lbGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZDogdGltZWxpbmVTdGFydCArIHNlZ21lbnREdXJhdGlvbixcbiAgICAgICAgICAgICAgICBwbGF5b3V0OiB7XG4gICAgICAgICAgICAgICAgICBzdGFydDogX3BsYXlvdXRTdGFydCxcbiAgICAgICAgICAgICAgICAgIGVuZDogcGxheW91dER1cmF0aW9uXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbnRlZ3JhdGVkOiB7XG4gICAgICAgICAgICAgICAgICBzdGFydDogX2ludGVncmF0ZWRTdGFydCxcbiAgICAgICAgICAgICAgICAgIGVuZDogaW50ZWdyYXRlZFRpbWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHNjaGVkdWxlLnB1c2gocHJpbWFyeVNlZ21lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZWdtZW50RHVyYXRpb24gPiAwICYmIHByZXZpb3VzRXZlbnQpIHtcbiAgICAgICAgICAgICAgLy8gQWRkIHByZXZpb3VzIGV2ZW50IGByZXN1bWVUaW1lYCAoYmFzZWQgb24gZHVyYXRpb24gb3IgcmVzdW1lT2Zmc2V0KSBzbyB0aGF0IGl0IGVuZHMgYWxpZ25lZCB3aXRoIHRoaXMgb25lXG4gICAgICAgICAgICAgIHByZXZpb3VzRXZlbnQuY3VtdWxhdGl2ZUR1cmF0aW9uICs9IHNlZ21lbnREdXJhdGlvbjtcbiAgICAgICAgICAgICAgc2NoZWR1bGVbc2NoZWR1bGUubGVuZ3RoIC0gMV0uZW5kID0gZXZlbnRTdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gbWlkcm9sbCAvIHBvc3Ryb2xsXG4gICAgICAgICAgaWYgKHBvc3Ryb2xsKSB7XG4gICAgICAgICAgICBlbmQgPSBzdGFydDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW50ZXJzdGl0aWFsLnRpbWVsaW5lU3RhcnQgPSBzdGFydDtcbiAgICAgICAgICBjb25zdCBpbnRlZ3JhdGVkU3RhcnQgPSBpbnRlZ3JhdGVkVGltZTtcbiAgICAgICAgICBpbnRlZ3JhdGVkVGltZSArPSB0aW1lbGluZUR1cmF0aW9uO1xuICAgICAgICAgIGNvbnN0IHBsYXlvdXRTdGFydCA9IHBsYXlvdXREdXJhdGlvbjtcbiAgICAgICAgICBwbGF5b3V0RHVyYXRpb24gKz0gaW50ZXJzdGl0aWFsRHVyYXRpb247XG4gICAgICAgICAgc2NoZWR1bGUucHVzaCh7XG4gICAgICAgICAgICBldmVudDogaW50ZXJzdGl0aWFsLFxuICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICBlbmQsXG4gICAgICAgICAgICBwbGF5b3V0OiB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBwbGF5b3V0U3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogcGxheW91dER1cmF0aW9uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW50ZWdyYXRlZDoge1xuICAgICAgICAgICAgICBzdGFydDogaW50ZWdyYXRlZFN0YXJ0LFxuICAgICAgICAgICAgICBlbmQ6IGludGVncmF0ZWRUaW1lXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSW50ZXJzdGl0aWFsIHN0YXJ0cyBhZnRlciBlbmQgb2YgcHJpbWFyeSBWT0QgLSBub3QgaW5jbHVkZWQgaW4gc2NoZWR1bGVcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdW1lVGltZSA9IGludGVyc3RpdGlhbC5yZXN1bWVUaW1lO1xuICAgICAgICBpZiAocG9zdHJvbGwgfHwgcmVzdW1lVGltZSA+IHByaW1hcnlEdXJhdGlvbikge1xuICAgICAgICAgIHByaW1hcnlQb3NpdGlvbiA9IHByaW1hcnlEdXJhdGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmltYXJ5UG9zaXRpb24gPSByZXN1bWVUaW1lO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChwcmltYXJ5UG9zaXRpb24gPCBwcmltYXJ5RHVyYXRpb24pIHtcbiAgICAgICAgdmFyIF9zY2hlZHVsZTtcbiAgICAgICAgLy8gbGFzdCBwcmltYXJ5IHNlZ21lbnRcbiAgICAgICAgY29uc3QgdGltZWxpbmVTdGFydCA9IHByaW1hcnlQb3NpdGlvbjtcbiAgICAgICAgY29uc3QgaW50ZWdyYXRlZFN0YXJ0ID0gaW50ZWdyYXRlZFRpbWU7XG4gICAgICAgIGNvbnN0IHNlZ21lbnREdXJhdGlvbiA9IHByaW1hcnlEdXJhdGlvbiAtIHByaW1hcnlQb3NpdGlvbjtcbiAgICAgICAgaW50ZWdyYXRlZFRpbWUgKz0gc2VnbWVudER1cmF0aW9uO1xuICAgICAgICBjb25zdCBwbGF5b3V0U3RhcnQgPSBwbGF5b3V0RHVyYXRpb247XG4gICAgICAgIHBsYXlvdXREdXJhdGlvbiArPSBzZWdtZW50RHVyYXRpb247XG4gICAgICAgIHNjaGVkdWxlLnB1c2goe1xuICAgICAgICAgIHByZXZpb3VzRXZlbnQ6ICgoX3NjaGVkdWxlID0gc2NoZWR1bGVbc2NoZWR1bGUubGVuZ3RoIC0gMV0pID09IG51bGwgPyB2b2lkIDAgOiBfc2NoZWR1bGUuZXZlbnQpIHx8IG51bGwsXG4gICAgICAgICAgbmV4dEV2ZW50OiBudWxsLFxuICAgICAgICAgIHN0YXJ0OiBwcmltYXJ5UG9zaXRpb24sXG4gICAgICAgICAgZW5kOiB0aW1lbGluZVN0YXJ0ICsgc2VnbWVudER1cmF0aW9uLFxuICAgICAgICAgIHBsYXlvdXQ6IHtcbiAgICAgICAgICAgIHN0YXJ0OiBwbGF5b3V0U3RhcnQsXG4gICAgICAgICAgICBlbmQ6IHBsYXlvdXREdXJhdGlvblxuICAgICAgICAgIH0sXG4gICAgICAgICAgaW50ZWdyYXRlZDoge1xuICAgICAgICAgICAgc3RhcnQ6IGludGVncmF0ZWRTdGFydCxcbiAgICAgICAgICAgIGVuZDogaW50ZWdyYXRlZFRpbWVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXREdXJhdGlvbnMocHJpbWFyeUR1cmF0aW9uLCBwbGF5b3V0RHVyYXRpb24sIGludGVncmF0ZWRUaW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm8gaW50ZXJzdGlhbHMgLSBzY2hlZHVsZSBpcyBvbmUgcHJpbWFyeSBzZWdtZW50XG4gICAgICBjb25zdCBzdGFydCA9IDA7XG4gICAgICBzY2hlZHVsZS5wdXNoKHtcbiAgICAgICAgcHJldmlvdXNFdmVudDogbnVsbCxcbiAgICAgICAgbmV4dEV2ZW50OiBudWxsLFxuICAgICAgICBzdGFydCxcbiAgICAgICAgZW5kOiBwcmltYXJ5RHVyYXRpb24sXG4gICAgICAgIHBsYXlvdXQ6IHtcbiAgICAgICAgICBzdGFydCxcbiAgICAgICAgICBlbmQ6IHByaW1hcnlEdXJhdGlvblxuICAgICAgICB9LFxuICAgICAgICBpbnRlZ3JhdGVkOiB7XG4gICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgZW5kOiBwcmltYXJ5RHVyYXRpb25cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLnNldER1cmF0aW9ucyhwcmltYXJ5RHVyYXRpb24sIHByaW1hcnlEdXJhdGlvbiwgcHJpbWFyeUR1cmF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjaGVkdWxlO1xuICB9XG4gIHNldER1cmF0aW9ucyhwcmltYXJ5LCBwbGF5b3V0LCBpbnRlZ3JhdGVkKSB7XG4gICAgdGhpcy5kdXJhdGlvbnMgPSB7XG4gICAgICBwcmltYXJ5LFxuICAgICAgcGxheW91dCxcbiAgICAgIGludGVncmF0ZWRcbiAgICB9O1xuICB9XG4gIHJlc29sdmVPZmZzZXRzKGludGVyc3RpdGlhbEV2ZW50cywgbWVkaWFTZWxlY3Rpb24pIHtcbiAgICBjb25zdCBkZXRhaWxzID0gbWVkaWFTZWxlY3Rpb24ubWFpbi5kZXRhaWxzO1xuICAgIGNvbnN0IHByaW1hcnlEdXJhdGlvbiA9IGRldGFpbHMubGl2ZSA/IEluZmluaXR5IDogZGV0YWlscy5lZGdlO1xuXG4gICAgLy8gRmlyc3QgcmVzb2x2ZSBjdW11bGF0aXZlIHJlc3VtcHRpb24gb2Zmc2V0cyBmb3IgSW50ZXJzdGl0aWFscyB0aGF0IHN0YXJ0IGF0IHRoZSBzYW1lIERhdGVUaW1lXG4gICAgbGV0IGN1bXVsYXRpdmVEdXJhdGlvbiA9IDA7XG4gICAgbGV0IGxhc3RTY2hlZHVsZWRTdGFydCA9IC0xO1xuICAgIGludGVyc3RpdGlhbEV2ZW50cy5mb3JFYWNoKChpbnRlcnN0aXRpYWwsIGkpID0+IHtcbiAgICAgIGNvbnN0IHByZXJvbGwgPSBpbnRlcnN0aXRpYWwuY3VlLnByZTtcbiAgICAgIGNvbnN0IHBvc3Ryb2xsID0gaW50ZXJzdGl0aWFsLmN1ZS5wb3N0O1xuICAgICAgY29uc3QgZXZlbnRTdGFydCA9IHByZXJvbGwgPyAwIDogcG9zdHJvbGwgPyBwcmltYXJ5RHVyYXRpb24gOiBpbnRlcnN0aXRpYWwuc3RhcnRUaW1lO1xuICAgICAgdGhpcy51cGRhdGVBc3NldER1cmF0aW9ucyhpbnRlcnN0aXRpYWwpO1xuXG4gICAgICAvLyBYLVJFU1VNRS1PRkZTRVQgdmFsdWVzIG9mIGludGVyc3RpdGlhbHMgc2NoZWR1bGVkIGF0IHRoZSBzYW1lIHRpbWUgYXJlIGN1bXVsYXRpdmVcbiAgICAgIGNvbnN0IGluU2FtZVN0YXJ0VGltZVNlcXVlbmNlID0gbGFzdFNjaGVkdWxlZFN0YXJ0ID09PSBldmVudFN0YXJ0O1xuICAgICAgaWYgKGluU2FtZVN0YXJ0VGltZVNlcXVlbmNlKSB7XG4gICAgICAgIGludGVyc3RpdGlhbC5jdW11bGF0aXZlRHVyYXRpb24gPSBjdW11bGF0aXZlRHVyYXRpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdW11bGF0aXZlRHVyYXRpb24gPSAwO1xuICAgICAgICBsYXN0U2NoZWR1bGVkU3RhcnQgPSBldmVudFN0YXJ0O1xuICAgICAgfVxuICAgICAgaWYgKCFwb3N0cm9sbCAmJiBpbnRlcnN0aXRpYWwuc25hcE9wdGlvbnMuaW4pIHtcbiAgICAgICAgLy8gRklYTUU6IEluY2x1ZGUgYXVkaW8gcGxheWxpc3QgaW4gc25hcHBpbmdcbiAgICAgICAgaW50ZXJzdGl0aWFsLnJlc3VtZUFuY2hvciA9IGZpbmRGcmFnbWVudEJ5UFRTKG51bGwsIGRldGFpbHMuZnJhZ21lbnRzLCBpbnRlcnN0aXRpYWwuc3RhcnRPZmZzZXQgKyBpbnRlcnN0aXRpYWwucmVzdW1wdGlvbk9mZnNldCwgMCwgMCkgfHwgdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgaWYgcHJpbWFyeSBmcmFnbWVudHMgYWxpZ24gd2l0aCByZXN1bXB0aW9uIG9mZnNldCBhbmQgZGlzYWJsZSBhcHBlbmRJblBsYWNlIGlmIHRoZXkgZG8gbm90XG4gICAgICBpZiAoaW50ZXJzdGl0aWFsLmFwcGVuZEluUGxhY2UgJiYgIWludGVyc3RpdGlhbC5hcHBlbmRJblBsYWNlU3RhcnRlZCkge1xuICAgICAgICBjb25zdCBhbGlnbmVkU2VnbWVudFN0YXJ0ID0gdGhpcy5wcmltYXJ5Q2FuUmVzdW1lSW5QbGFjZUF0KGludGVyc3RpdGlhbCwgbWVkaWFTZWxlY3Rpb24pO1xuICAgICAgICBpZiAoIWFsaWduZWRTZWdtZW50U3RhcnQpIHtcbiAgICAgICAgICBpbnRlcnN0aXRpYWwuYXBwZW5kSW5QbGFjZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWludGVyc3RpdGlhbC5hcHBlbmRJblBsYWNlICYmIGkgKyAxIDwgaW50ZXJzdGl0aWFsRXZlbnRzLmxlbmd0aCkge1xuICAgICAgICAvLyBhYnV0dGluZyBJbnRlcnN0aXRpYWxzIG11c3QgdXNlIHRoZSBzYW1lIE1lZGlhU291cmNlIHN0cmF0ZWd5LCB0aGlzIGFwcGxpZXMgdG8gYWxsIHdoZXRoZXIgb3Igbm90IHRoZXkgYXJlIGJhY2sgdG8gYmFjazpcbiAgICAgICAgY29uc3QgdGltZUJldHdlZW4gPSBpbnRlcnN0aXRpYWxFdmVudHNbaSArIDFdLnN0YXJ0VGltZSAtIGludGVyc3RpdGlhbEV2ZW50c1tpXS5yZXN1bWVUaW1lO1xuICAgICAgICBpZiAodGltZUJldHdlZW4gPCBBQlVUVElOR19USFJFU0hPTERfU0VDT05EUykge1xuICAgICAgICAgIGludGVyc3RpdGlhbEV2ZW50c1tpICsgMV0uYXBwZW5kSW5QbGFjZSA9IGZhbHNlO1xuICAgICAgICAgIGlmIChpbnRlcnN0aXRpYWxFdmVudHNbaSArIDFdLmFwcGVuZEluUGxhY2UpIHtcbiAgICAgICAgICAgIHRoaXMud2FybihgQ291bGQgbm90IGNoYW5nZSBhcHBlbmQgc3RyYXRlZ3kgZm9yIGFidXR0aW5nIGV2ZW50ICR7aW50ZXJzdGl0aWFsfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gVXBkYXRlIGN1bXVsYXRpdmVEdXJhdGlvbiBmb3IgbmV4dCBhYnV0dGluZyBpbnRlcnN0aXRpYWwgd2l0aCB0aGUgc2FtZSBzdGFydCBkYXRlXG4gICAgICBjb25zdCByZXN1bWVPZmZzZXQgPSBpc0Zpbml0ZU51bWJlcihpbnRlcnN0aXRpYWwucmVzdW1lT2Zmc2V0KSA/IGludGVyc3RpdGlhbC5yZXN1bWVPZmZzZXQgOiBpbnRlcnN0aXRpYWwuZHVyYXRpb247XG4gICAgICBjdW11bGF0aXZlRHVyYXRpb24gKz0gcmVzdW1lT2Zmc2V0O1xuICAgIH0pO1xuICB9XG4gIHByaW1hcnlDYW5SZXN1bWVJblBsYWNlQXQoaW50ZXJzdGl0aWFsLCBtZWRpYVNlbGVjdGlvbikge1xuICAgIGNvbnN0IHJlc3VtZVRpbWUgPSBpbnRlcnN0aXRpYWwucmVzdW1lVGltZTtcbiAgICBjb25zdCByZXN1bWVzSW5QbGFjZUF0ID0gaW50ZXJzdGl0aWFsLnN0YXJ0VGltZSArIGludGVyc3RpdGlhbC5yZXN1bXB0aW9uT2Zmc2V0O1xuICAgIGlmIChNYXRoLmFicyhyZXN1bWVUaW1lIC0gcmVzdW1lc0luUGxhY2VBdCkgPiBBTElHTkVEX0VORF9USFJFU0hPTERfU0VDT05EUykge1xuICAgICAgdGhpcy5sb2coYFwiJHtpbnRlcnN0aXRpYWwuaWRlbnRpZmllcn1cIiByZXN1bXB0aW9uICR7cmVzdW1lVGltZX0gbm90IGFsaWduZWQgd2l0aCBlc3RpbWF0ZWQgdGltZWxpbmUgZW5kICR7cmVzdW1lc0luUGxhY2VBdH1gKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFtZWRpYVNlbGVjdGlvbikge1xuICAgICAgdGhpcy5sb2coYFwiJHtpbnRlcnN0aXRpYWwuaWRlbnRpZmllcn1cIiByZXN1bXB0aW9uICR7cmVzdW1lVGltZX0gY2FuIG5vdCBiZSBhbGlnbmVkIHdpdGggbWVkaWEgKG5vbmUgc2VsZWN0ZWQpYCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHBsYXlsaXN0cyA9IE9iamVjdC5rZXlzKG1lZGlhU2VsZWN0aW9uKTtcbiAgICByZXR1cm4gIXBsYXlsaXN0cy5zb21lKHBsYXlsaXN0VHlwZSA9PiB7XG4gICAgICBjb25zdCBkZXRhaWxzID0gbWVkaWFTZWxlY3Rpb25bcGxheWxpc3RUeXBlXS5kZXRhaWxzO1xuICAgICAgY29uc3QgcGxheWxpc3RFbmQgPSBkZXRhaWxzLmVkZ2U7XG4gICAgICBpZiAocmVzdW1lVGltZSA+PSBwbGF5bGlzdEVuZCkge1xuICAgICAgICAvLyBMaXZlIHBsYXliYWNrIC0gcmVzdW1wdGlvbiBzZWdtZW50cyBhcmUgbm90IHlldCBhdmFpbGFibGVcbiAgICAgICAgdGhpcy5sb2coYFwiJHtpbnRlcnN0aXRpYWwuaWRlbnRpZmllcn1cIiByZXN1bXB0aW9uICR7cmVzdW1lVGltZX0gcGFzdCAke3BsYXlsaXN0VHlwZX0gcGxheWxpc3QgZW5kICR7cGxheWxpc3RFbmR9YCk7XG4gICAgICAgIC8vIEFzc3VtZSBhbGlnbm1lbnQgaXMgcG9zc2libGUgKG9yIHJlc2V0IGNhbiB0YWtlIHBsYWNlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGFydEZyYWdtZW50ID0gZmluZEZyYWdtZW50QnlQVFMobnVsbCwgZGV0YWlscy5mcmFnbWVudHMsIHJlc3VtZVRpbWUpO1xuICAgICAgaWYgKCFzdGFydEZyYWdtZW50KSB7XG4gICAgICAgIHRoaXMubG9nKGBcIiR7aW50ZXJzdGl0aWFsLmlkZW50aWZpZXJ9XCIgcmVzdW1wdGlvbiAke3Jlc3VtZVRpbWV9IGRvZXMgbm90IGFsaWduIHdpdGggYW55IGZyYWdtZW50cyBpbiAke3BsYXlsaXN0VHlwZX0gcGxheWxpc3QgKCR7ZGV0YWlscy5mcmFnU3RhcnR9LSR7ZGV0YWlscy5mcmFnbWVudEVuZH0pYCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgYWxsb3dhbmNlID0gcGxheWxpc3RUeXBlID09PSAnYXVkaW8nID8gMC4xNzUgOiAwO1xuICAgICAgY29uc3QgYWxpZ25lZFdpdGhTZWdtZW50ID0gTWF0aC5hYnMoc3RhcnRGcmFnbWVudC5zdGFydCAtIHJlc3VtZVRpbWUpIDwgQUxJR05FRF9FTkRfVEhSRVNIT0xEX1NFQ09ORFMgKyBhbGxvd2FuY2UgfHwgTWF0aC5hYnMoc3RhcnRGcmFnbWVudC5lbmQgLSByZXN1bWVUaW1lKSA8IEFMSUdORURfRU5EX1RIUkVTSE9MRF9TRUNPTkRTICsgYWxsb3dhbmNlO1xuICAgICAgaWYgKCFhbGlnbmVkV2l0aFNlZ21lbnQpIHtcbiAgICAgICAgdGhpcy5sb2coYFwiJHtpbnRlcnN0aXRpYWwuaWRlbnRpZmllcn1cIiByZXN1bXB0aW9uICR7cmVzdW1lVGltZX0gbm90IGFsaWduZWQgd2l0aCAke3BsYXlsaXN0VHlwZX0gZnJhZ21lbnQgYm91bmRzICgke3N0YXJ0RnJhZ21lbnQuc3RhcnR9LSR7c3RhcnRGcmFnbWVudC5lbmR9IHNuOiAke3N0YXJ0RnJhZ21lbnQuc259IGNjOiAke3N0YXJ0RnJhZ21lbnQuY2N9KWApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVBc3NldER1cmF0aW9ucyhpbnRlcnN0aXRpYWwpIHtcbiAgICBpZiAoIWludGVyc3RpdGlhbC5hc3NldExpc3RMb2FkZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZXZlbnRTdGFydCA9IGludGVyc3RpdGlhbC50aW1lbGluZVN0YXJ0O1xuICAgIGxldCBzdW1EdXJhdGlvbiA9IDA7XG4gICAgbGV0IGhhc1Vua25vd25EdXJhdGlvbiA9IGZhbHNlO1xuICAgIGxldCBoYXNFcnJvcnMgPSBmYWxzZTtcbiAgICBpbnRlcnN0aXRpYWwuYXNzZXRMaXN0LmZvckVhY2goKGFzc2V0LCBpKSA9PiB7XG4gICAgICBjb25zdCB0aW1lbGluZVN0YXJ0ID0gZXZlbnRTdGFydCArIHN1bUR1cmF0aW9uO1xuICAgICAgYXNzZXQuc3RhcnRPZmZzZXQgPSBzdW1EdXJhdGlvbjtcbiAgICAgIGFzc2V0LnRpbWVsaW5lU3RhcnQgPSB0aW1lbGluZVN0YXJ0O1xuICAgICAgaGFzVW5rbm93bkR1cmF0aW9uIHx8IChoYXNVbmtub3duRHVyYXRpb24gPSBhc3NldC5kdXJhdGlvbiA9PT0gbnVsbCk7XG4gICAgICBoYXNFcnJvcnMgfHwgKGhhc0Vycm9ycyA9ICEhYXNzZXQuZXJyb3IpO1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBhc3NldC5lcnJvciA/IDAgOiBhc3NldC5kdXJhdGlvbiB8fCAwO1xuICAgICAgc3VtRHVyYXRpb24gKz0gZHVyYXRpb247XG4gICAgfSk7XG4gICAgLy8gVXNlIHRoZSBzdW0gb2Yga25vd24gZHVyYXRpb25zIHdoZW4gaXQgaXMgZ3JlYXRlciB0aGFuIHRoZSBzdGF0ZWQgZHVyYXRpb25cbiAgICBpZiAoaGFzVW5rbm93bkR1cmF0aW9uICYmICFoYXNFcnJvcnMpIHtcbiAgICAgIGludGVyc3RpdGlhbC5kdXJhdGlvbiA9IE1hdGgubWF4KHN1bUR1cmF0aW9uLCBpbnRlcnN0aXRpYWwuZHVyYXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnRlcnN0aXRpYWwuZHVyYXRpb24gPSBzdW1EdXJhdGlvbjtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlRXZlbnQoaW50ZXJzdGl0aWFsKSB7XG4gICAgaW50ZXJzdGl0aWFsLnJlc2V0KCk7XG4gICAgZGVsZXRlIHRoaXMuZXZlbnRNYXBbaW50ZXJzdGl0aWFsLmlkZW50aWZpZXJdO1xuICB9XG59XG5mdW5jdGlvbiBzZWdtZW50VG9TdHJpbmcoc2VnbWVudCkge1xuICByZXR1cm4gYFske3NlZ21lbnQuZXZlbnQgPyAnXCInICsgc2VnbWVudC5ldmVudC5pZGVudGlmaWVyICsgJ1wiJyA6ICdwcmltYXJ5J306ICR7c2VnbWVudC5zdGFydC50b0ZpeGVkKDIpfS0ke3NlZ21lbnQuZW5kLnRvRml4ZWQoMil9XWA7XG59XG5cbmNsYXNzIEFzc2V0TGlzdExvYWRlciB7XG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuaGxzID0gbnVsbDtcbiAgfVxuICBsb2FkQXNzZXRMaXN0KGludGVyc3RpdGlhbCwgaGxzU3RhcnRPZmZzZXQpIHtcbiAgICBjb25zdCBhc3NldExpc3RVcmwgPSBpbnRlcnN0aXRpYWwuYXNzZXRMaXN0VXJsO1xuICAgIGxldCB1cmw7XG4gICAgdHJ5IHtcbiAgICAgIHVybCA9IGdldEludGVyc3RpdGlhbFVybChhc3NldExpc3RVcmwsIHRoaXMuaGxzLnNlc3Npb25JZCwgaW50ZXJzdGl0aWFsLmJhc2VVcmwpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSB0aGlzLmFzc2lnbkFzc2V0TGlzdEVycm9yKGludGVyc3RpdGlhbCwgRXJyb3JEZXRhaWxzLkFTU0VUX0xJU1RfTE9BRF9FUlJPUiwgZXJyb3IsIGFzc2V0TGlzdFVybCk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwgZXJyb3JEYXRhKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGhsc1N0YXJ0T2Zmc2V0ICYmIHVybC5wcm90b2NvbCAhPT0gJ2RhdGE6Jykge1xuICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ19ITFNfc3RhcnRfb2Zmc2V0JywgJycgKyBobHNTdGFydE9mZnNldCk7XG4gICAgfVxuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcbiAgICBjb25zdCBMb2FkZXIgPSBjb25maWcubG9hZGVyO1xuICAgIGNvbnN0IGxvYWRlciA9IG5ldyBMb2FkZXIoY29uZmlnKTtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgICB1cmw6IHVybC5ocmVmXG4gICAgfTtcbiAgICBjb25zdCBsb2FkUG9saWN5ID0gY29uZmlnLmludGVyc3RpdGlhbEFzc2V0TGlzdExvYWRQb2xpY3kuZGVmYXVsdDtcbiAgICBjb25zdCBsb2FkZXJDb25maWcgPSB7XG4gICAgICBsb2FkUG9saWN5LFxuICAgICAgdGltZW91dDogbG9hZFBvbGljeS5tYXhMb2FkVGltZU1zLFxuICAgICAgbWF4UmV0cnk6IDAsXG4gICAgICByZXRyeURlbGF5OiAwLFxuICAgICAgbWF4UmV0cnlEZWxheTogMFxuICAgIH07XG4gICAgY29uc3QgY2FsbGJhY2tzID0ge1xuICAgICAgb25TdWNjZXNzOiAocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICBjb25zdCBhc3NldExpc3RSZXNwb25zZSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgIGNvbnN0IGFzc2V0cyA9IGFzc2V0TGlzdFJlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiBhc3NldExpc3RSZXNwb25zZS5BU1NFVFM7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhc3NldHMpKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gdGhpcy5hc3NpZ25Bc3NldExpc3RFcnJvcihpbnRlcnN0aXRpYWwsIEVycm9yRGV0YWlscy5BU1NFVF9MSVNUX1BBUlNJTkdfRVJST1IsIG5ldyBFcnJvcihgSW52YWxpZCBpbnRlcnN0aXRpYWwgYXNzZXQgbGlzdGApLCBjb250ZXh0LnVybCwgc3RhdHMsIG5ldHdvcmtEZXRhaWxzKTtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwgZXJyb3JEYXRhKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaW50ZXJzdGl0aWFsLmFzc2V0TGlzdFJlc3BvbnNlID0gYXNzZXRMaXN0UmVzcG9uc2U7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkFTU0VUX0xJU1RfTE9BREVELCB7XG4gICAgICAgICAgZXZlbnQ6IGludGVyc3RpdGlhbCxcbiAgICAgICAgICBhc3NldExpc3RSZXNwb25zZSxcbiAgICAgICAgICBuZXR3b3JrRGV0YWlsc1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBvbkVycm9yOiAoZXJyb3IsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCBzdGF0cykgPT4ge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSB0aGlzLmFzc2lnbkFzc2V0TGlzdEVycm9yKGludGVyc3RpdGlhbCwgRXJyb3JEZXRhaWxzLkFTU0VUX0xJU1RfTE9BRF9FUlJPUiwgbmV3IEVycm9yKGBFcnJvciBsb2FkaW5nIFgtQVNTRVQtTElTVDogSFRUUCBzdGF0dXMgJHtlcnJvci5jb2RlfSAke2Vycm9yLnRleHR9ICgke2NvbnRleHQudXJsfSlgKSwgY29udGV4dC51cmwsIHN0YXRzLCBuZXR3b3JrRGV0YWlscyk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCBlcnJvckRhdGEpO1xuICAgICAgfSxcbiAgICAgIG9uVGltZW91dDogKHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSB0aGlzLmFzc2lnbkFzc2V0TGlzdEVycm9yKGludGVyc3RpdGlhbCwgRXJyb3JEZXRhaWxzLkFTU0VUX0xJU1RfTE9BRF9USU1FT1VULCBuZXcgRXJyb3IoYFRpbWVvdXQgbG9hZGluZyBYLUFTU0VULUxJU1QgKCR7Y29udGV4dC51cmx9KWApLCBjb250ZXh0LnVybCwgc3RhdHMsIG5ldHdvcmtEZXRhaWxzKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIGVycm9yRGF0YSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBsb2FkZXIubG9hZChjb250ZXh0LCBsb2FkZXJDb25maWcsIGNhbGxiYWNrcyk7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQVNTRVRfTElTVF9MT0FESU5HLCB7XG4gICAgICBldmVudDogaW50ZXJzdGl0aWFsXG4gICAgfSk7XG4gICAgcmV0dXJuIGxvYWRlcjtcbiAgfVxuICBhc3NpZ25Bc3NldExpc3RFcnJvcihpbnRlcnN0aXRpYWwsIGRldGFpbHMsIGVycm9yLCB1cmwsIHN0YXRzLCBuZXR3b3JrRGV0YWlscykge1xuICAgIGludGVyc3RpdGlhbC5lcnJvciA9IGVycm9yO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICBkZXRhaWxzLFxuICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgaW50ZXJzdGl0aWFsLFxuICAgICAgdXJsLFxuICAgICAgZXJyb3IsXG4gICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgIHN0YXRzXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwbGF5V2l0aENhdGNoKG1lZGlhKSB7XG4gIG1lZGlhID09IG51bGwgPyB2b2lkIDAgOiBtZWRpYS5wbGF5KCkuY2F0Y2goKCkgPT4ge1xuICAgIC8qIG5vLW9wICovXG4gIH0pO1xufVxuY2xhc3MgSW50ZXJzdGl0aWFsc0NvbnRyb2xsZXIgZXh0ZW5kcyBMb2dnZXIge1xuICBjb25zdHJ1Y3RvcihobHMsIEhsc1BsYXllckNsYXNzKSB7XG4gICAgc3VwZXIoJ2ludGVyc3RpdGlhbHMnLCBobHMubG9nZ2VyKTtcbiAgICB0aGlzLkhsc1BsYXllckNsYXNzID0gdm9pZCAwO1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMuYXNzZXRMaXN0TG9hZGVyID0gdm9pZCAwO1xuICAgIC8vIExhc3QgdXBkYXRlZCBMZXZlbERldGFpbHNcbiAgICB0aGlzLm1lZGlhU2VsZWN0aW9uID0gbnVsbDtcbiAgICB0aGlzLmFsdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgLy8gTWVkaWEgYW5kIE1lZGlhU291cmNlL1NvdXJjZUJ1ZmZlcnNcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLmRldGFjaGVkRGF0YSA9IG51bGw7XG4gICAgdGhpcy5yZXF1aXJlZFRyYWNrcyA9IG51bGw7XG4gICAgLy8gUHVibGljIEludGVyZmFjZSBmb3IgSW50ZXJzdGl0aWFsIHBsYXliYWNrIHN0YXRlIGFuZCBjb250cm9sXG4gICAgdGhpcy5tYW5hZ2VyID0gbnVsbDtcbiAgICAvLyBJbnRlcnN0aXRpYWwgQXNzZXQgUGxheWVyc1xuICAgIHRoaXMucGxheWVyUXVldWUgPSBbXTtcbiAgICAvLyBUaW1lbGluZSBwb3NpdGlvbiB0cmFja2luZ1xuICAgIHRoaXMuYnVmZmVyZWRQb3MgPSAtMTtcbiAgICB0aGlzLnRpbWVsaW5lUG9zID0gLTE7XG4gICAgLy8gU2NoZWR1bGVcbiAgICB0aGlzLnNjaGVkdWxlID0gdm9pZCAwO1xuICAgIC8vIFNjaGVkdWxlIHBsYXliYWNrIGFuZCBidWZmZXJpbmcgc3RhdGVcbiAgICB0aGlzLnBsYXlpbmdJdGVtID0gbnVsbDtcbiAgICB0aGlzLmJ1ZmZlcmluZ0l0ZW0gPSBudWxsO1xuICAgIHRoaXMud2FpdGluZ0l0ZW0gPSBudWxsO1xuICAgIHRoaXMuZW5kZWRJdGVtID0gbnVsbDtcbiAgICB0aGlzLnBsYXlpbmdBc3NldCA9IG51bGw7XG4gICAgdGhpcy5lbmRlZEFzc2V0ID0gbnVsbDtcbiAgICB0aGlzLmJ1ZmZlcmluZ0Fzc2V0ID0gbnVsbDtcbiAgICB0aGlzLnNob3VsZFBsYXkgPSBmYWxzZTtcbiAgICB0aGlzLm9uUGxheSA9ICgpID0+IHtcbiAgICAgIHRoaXMuc2hvdWxkUGxheSA9IHRydWU7XG4gICAgfTtcbiAgICB0aGlzLm9uUGF1c2UgPSAoKSA9PiB7XG4gICAgICB0aGlzLnNob3VsZFBsYXkgPSBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMub25TZWVraW5nID0gKCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudFRpbWUgPSB0aGlzLmN1cnJlbnRUaW1lO1xuICAgICAgaWYgKGN1cnJlbnRUaW1lID09PSB1bmRlZmluZWQgfHwgdGhpcy5wbGF5YmFja0Rpc2FibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRpZmYgPSBjdXJyZW50VGltZSAtIHRoaXMudGltZWxpbmVQb3M7XG4gICAgICBjb25zdCByb3VuZGluZ0Vycm9yID0gTWF0aC5hYnMoZGlmZikgPCAxIC8gNzA1NjAwMDAwOyAvLyBvbmUgZmxpY2tcbiAgICAgIGlmIChyb3VuZGluZ0Vycm9yKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJhY2t3YXJkU2VlayA9IGRpZmYgPD0gLTAuMDE7XG4gICAgICB0aGlzLnRpbWVsaW5lUG9zID0gY3VycmVudFRpbWU7XG4gICAgICB0aGlzLmJ1ZmZlcmVkUG9zID0gY3VycmVudFRpbWU7XG5cbiAgICAgIC8vIENoZWNrIGlmIHNlZWtpbmcgb3V0IG9mIGFuIGl0ZW1cbiAgICAgIGNvbnN0IHBsYXlpbmdJdGVtID0gdGhpcy5wbGF5aW5nSXRlbTtcbiAgICAgIGlmICghcGxheWluZ0l0ZW0pIHtcbiAgICAgICAgdGhpcy5jaGVja0J1ZmZlcigpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoYmFja3dhcmRTZWVrKSB7XG4gICAgICAgIGNvbnN0IHJlc2V0Q291bnQgPSB0aGlzLnNjaGVkdWxlLnJlc2V0RXJyb3JzSW5SYW5nZShjdXJyZW50VGltZSwgY3VycmVudFRpbWUgLSBkaWZmKTtcbiAgICAgICAgaWYgKHJlc2V0Q291bnQpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZVNjaGVkdWxlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuY2hlY2tCdWZmZXIoKTtcbiAgICAgIGlmIChiYWNrd2FyZFNlZWsgJiYgY3VycmVudFRpbWUgPCBwbGF5aW5nSXRlbS5zdGFydCB8fCBjdXJyZW50VGltZSA+PSBwbGF5aW5nSXRlbS5lbmQpIHtcbiAgICAgICAgdmFyIF90aGlzJG1lZGlhO1xuICAgICAgICBjb25zdCBzY2hlZHVsZUluZGV4ID0gdGhpcy5zY2hlZHVsZS5maW5kSXRlbUluZGV4QXRUaW1lKHRoaXMudGltZWxpbmVQb3MpO1xuICAgICAgICBpZiAoIXRoaXMuaXNJbnRlcnN0aXRpYWwocGxheWluZ0l0ZW0pICYmIChfdGhpcyRtZWRpYSA9IHRoaXMubWVkaWEpICE9IG51bGwgJiYgX3RoaXMkbWVkaWEucGF1c2VkKSB7XG4gICAgICAgICAgdGhpcy5zaG91bGRQbGF5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFiYWNrd2FyZFNlZWspIHtcbiAgICAgICAgICAvLyBjaGVjayBpZiBhbiBJbnRlcnN0aXRpYWwgYmV0d2VlbiB0aGUgY3VycmVudCBpdGVtIGFuZCB0YXJnZXQgaXRlbSBoYXMgYW4gWC1SRVNUUklDVCBKVU1QIHJlc3RyaWN0aW9uXG4gICAgICAgICAgY29uc3QgcGxheWluZ0luZGV4ID0gdGhpcy5maW5kSXRlbUluZGV4KHBsYXlpbmdJdGVtKTtcbiAgICAgICAgICBpZiAoc2NoZWR1bGVJbmRleCA+IHBsYXlpbmdJbmRleCkge1xuICAgICAgICAgICAgY29uc3QganVtcEluZGV4ID0gdGhpcy5zY2hlZHVsZS5maW5kSnVtcFJlc3RyaWN0ZWRJbmRleChwbGF5aW5nSW5kZXggKyAxLCBzY2hlZHVsZUluZGV4KTtcbiAgICAgICAgICAgIGlmIChqdW1wSW5kZXggPiBwbGF5aW5nSW5kZXgpIHtcbiAgICAgICAgICAgICAgdGhpcy5zZXRTY2hlZHVsZVBvc2l0aW9uKGp1bXBJbmRleCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRTY2hlZHVsZVBvc2l0aW9uKHNjaGVkdWxlSW5kZXgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBDaGVjayBpZiBzZWVraW5nIG91dCBvZiBhbiBhc3NldCAoYXNzdW1lcyBzYW1lIGl0ZW0gZm9sbG93aW5nIGFib3ZlIGNoZWNrKVxuICAgICAgY29uc3QgcGxheWluZ0Fzc2V0ID0gdGhpcy5wbGF5aW5nQXNzZXQ7XG4gICAgICBpZiAoIXBsYXlpbmdBc3NldCkge1xuICAgICAgICAvLyByZXN0YXJ0IEludGVyc3RpdGlhbCBhdCBlbmRcbiAgICAgICAgaWYgKHRoaXMucGxheWluZ0xhc3RJdGVtICYmIHRoaXMuaXNJbnRlcnN0aXRpYWwocGxheWluZ0l0ZW0pKSB7XG4gICAgICAgICAgY29uc3QgcmVzdGFydEFzc2V0ID0gcGxheWluZ0l0ZW0uZXZlbnQuYXNzZXRMaXN0WzBdO1xuICAgICAgICAgIGlmIChyZXN0YXJ0QXNzZXQpIHtcbiAgICAgICAgICAgIHRoaXMuZW5kZWRJdGVtID0gdGhpcy5wbGF5aW5nSXRlbTtcbiAgICAgICAgICAgIHRoaXMucGxheWluZ0l0ZW0gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5zZXRTY2hlZHVsZVRvQXNzZXRBdFRpbWUoY3VycmVudFRpbWUsIHJlc3RhcnRBc3NldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXJ0ID0gcGxheWluZ0Fzc2V0LnRpbWVsaW5lU3RhcnQ7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IHBsYXlpbmdBc3NldC5kdXJhdGlvbiB8fCAwO1xuICAgICAgaWYgKGJhY2t3YXJkU2VlayAmJiBjdXJyZW50VGltZSA8IHN0YXJ0IHx8IGN1cnJlbnRUaW1lID49IHN0YXJ0ICsgZHVyYXRpb24pIHtcbiAgICAgICAgdGhpcy5zZXRTY2hlZHVsZVRvQXNzZXRBdFRpbWUoY3VycmVudFRpbWUsIHBsYXlpbmdBc3NldCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm9uVGltZXVwZGF0ZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gdGhpcy5jdXJyZW50VGltZTtcbiAgICAgIGlmIChjdXJyZW50VGltZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMucGxheWJhY2tEaXNhYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIE9ubHkgYWxsb3cgdGltZXVwZGF0ZSB0byBhZHZhbmNlIHByaW1hcnkgcG9zaXRpb24sIHNlZWtpbmcgaXMgdXNlZCBmb3IganVtcGluZyBiYWNrXG4gICAgICAvLyB0aGlzIHByZXZlbnRzIHByaW1hcnlQb3MgZnJvbSBiZWluZyByZXNldCB0byAwIGFmdGVyIHJlLWF0dGFjaFxuICAgICAgaWYgKGN1cnJlbnRUaW1lID4gdGhpcy50aW1lbGluZVBvcykge1xuICAgICAgICB0aGlzLnRpbWVsaW5lUG9zID0gY3VycmVudFRpbWU7XG4gICAgICAgIGlmIChjdXJyZW50VGltZSA+IHRoaXMuYnVmZmVyZWRQb3MpIHtcbiAgICAgICAgICB0aGlzLmNoZWNrQnVmZmVyKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgcGxheWJhY2sgaGFzIGVudGVyZWQgdGhlIG5leHQgaXRlbVxuICAgICAgY29uc3QgcGxheWluZ0l0ZW0gPSB0aGlzLnBsYXlpbmdJdGVtO1xuICAgICAgaWYgKCFwbGF5aW5nSXRlbSB8fCB0aGlzLnBsYXlpbmdMYXN0SXRlbSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudFRpbWUgPj0gcGxheWluZ0l0ZW0uZW5kKSB7XG4gICAgICAgIHRoaXMudGltZWxpbmVQb3MgPSBwbGF5aW5nSXRlbS5lbmQ7XG4gICAgICAgIGNvbnN0IHBsYXlpbmdJbmRleCA9IHRoaXMuZmluZEl0ZW1JbmRleChwbGF5aW5nSXRlbSk7XG4gICAgICAgIHRoaXMuc2V0U2NoZWR1bGVQb3NpdGlvbihwbGF5aW5nSW5kZXggKyAxKTtcbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIGlmIHBsYXliYWNrIGhhcyBlbnRlcmVkIHRoZSBuZXh0IGFzc2V0XG4gICAgICBjb25zdCBwbGF5aW5nQXNzZXQgPSB0aGlzLnBsYXlpbmdBc3NldDtcbiAgICAgIGlmICghcGxheWluZ0Fzc2V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVuZCA9IHBsYXlpbmdBc3NldC50aW1lbGluZVN0YXJ0ICsgKHBsYXlpbmdBc3NldC5kdXJhdGlvbiB8fCAwKTtcbiAgICAgIGlmIChjdXJyZW50VGltZSA+PSBlbmQpIHtcbiAgICAgICAgdGhpcy5zZXRTY2hlZHVsZVRvQXNzZXRBdFRpbWUoY3VycmVudFRpbWUsIHBsYXlpbmdBc3NldCk7XG4gICAgICB9XG4gICAgfTtcbiAgICAvLyBTY2hlZHVsZSB1cGRhdGUgY2FsbGJhY2tcbiAgICB0aGlzLm9uU2NoZWR1bGVVcGRhdGUgPSAocmVtb3ZlZEludGVyc3RpdGlhbHMsIHByZXZpb3VzSXRlbXMpID0+IHtcbiAgICAgIGNvbnN0IHNjaGVkdWxlID0gdGhpcy5zY2hlZHVsZTtcbiAgICAgIGNvbnN0IHBsYXlpbmdJdGVtID0gdGhpcy5wbGF5aW5nSXRlbTtcbiAgICAgIGNvbnN0IGludGVyc3RpdGlhbEV2ZW50cyA9IHNjaGVkdWxlLmV2ZW50cyB8fCBbXTtcbiAgICAgIGNvbnN0IHNjaGVkdWxlSXRlbXMgPSBzY2hlZHVsZS5pdGVtcyB8fCBbXTtcbiAgICAgIGNvbnN0IGR1cmF0aW9ucyA9IHNjaGVkdWxlLmR1cmF0aW9ucztcbiAgICAgIGNvbnN0IHJlbW92ZWRJZHMgPSByZW1vdmVkSW50ZXJzdGl0aWFscy5tYXAoaW50ZXJzdGl0aWFsID0+IGludGVyc3RpdGlhbC5pZGVudGlmaWVyKTtcbiAgICAgIGNvbnN0IGludGVyc3RpdGlhbHNVcGRhdGVkID0gISEoaW50ZXJzdGl0aWFsRXZlbnRzLmxlbmd0aCB8fCByZW1vdmVkSWRzLmxlbmd0aCk7XG4gICAgICBpZiAoaW50ZXJzdGl0aWFsc1VwZGF0ZWQgfHwgcHJldmlvdXNJdGVtcykge1xuICAgICAgICB0aGlzLmxvZyhgSU5URVJTVElUSUFMU19VUERBVEVEICgke2ludGVyc3RpdGlhbEV2ZW50cy5sZW5ndGh9KTogJHtpbnRlcnN0aXRpYWxFdmVudHN9XG5TY2hlZHVsZTogJHtzY2hlZHVsZUl0ZW1zLm1hcChzZWcgPT4gc2VnbWVudFRvU3RyaW5nKHNlZykpfSBwb3M6ICR7dGhpcy50aW1lbGluZVBvc31gKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZW1vdmVkSWRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmxvZyhgUmVtb3ZlZCBldmVudHMgJHtyZW1vdmVkSWRzfWApO1xuICAgICAgfVxuICAgICAgdGhpcy5wbGF5ZXJRdWV1ZS5mb3JFYWNoKHBsYXllciA9PiB7XG4gICAgICAgIGlmIChwbGF5ZXIuaW50ZXJzdGl0aWFsLmFwcGVuZEluUGxhY2UpIHtcbiAgICAgICAgICBjb25zdCB0aW1lbGluZVN0YXJ0ID0gcGxheWVyLmFzc2V0SXRlbS50aW1lbGluZVN0YXJ0O1xuICAgICAgICAgIGNvbnN0IGRpZmYgPSBwbGF5ZXIudGltZWxpbmVPZmZzZXQgLSB0aW1lbGluZVN0YXJ0O1xuICAgICAgICAgIGlmIChkaWZmKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBwbGF5ZXIudGltZWxpbmVPZmZzZXQgPSB0aW1lbGluZVN0YXJ0O1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoZGlmZikgPiBBTElHTkVEX0VORF9USFJFU0hPTERfU0VDT05EUykge1xuICAgICAgICAgICAgICAgIHRoaXMud2FybihgJHtlfSAoXCIke3BsYXllci5hc3NldElkfVwiICR7cGxheWVyLnRpbWVsaW5lT2Zmc2V0fS0+JHt0aW1lbGluZVN0YXJ0fSlgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIFVwZGF0ZSBzY2hlZHVsZSBpdGVtIHJlZmVyZW5jZXNcbiAgICAgIC8vIERvIG5vdCByZXBsYWNlIEludGVyc3RpdGlhbCBwbGF5aW5nSXRlbSB3aXRob3V0IGEgbWF0Y2ggLSB1c2VkIGZvciBJTlRFUlNUSVRJQUxfQVNTRVRfRU5ERUQgYW5kIElOVEVSU1RJVElBTF9FTkRFRFxuICAgICAgbGV0IHRyaW1JblBsYWNlRm9yUGxheW91dCA9IG51bGw7XG4gICAgICBpZiAocGxheWluZ0l0ZW0pIHtcbiAgICAgICAgY29uc3QgdXBkYXRlZFBsYXlpbmdJdGVtID0gdGhpcy51cGRhdGVJdGVtKHBsYXlpbmdJdGVtLCB0aGlzLnRpbWVsaW5lUG9zKTtcbiAgICAgICAgaWYgKHRoaXMuaXRlbXNNYXRjaChwbGF5aW5nSXRlbSwgdXBkYXRlZFBsYXlpbmdJdGVtKSkge1xuICAgICAgICAgIHRoaXMucGxheWluZ0l0ZW0gPSB1cGRhdGVkUGxheWluZ0l0ZW07XG4gICAgICAgICAgdGhpcy53YWl0aW5nSXRlbSA9IHRoaXMuZW5kZWRJdGVtID0gbnVsbDtcbiAgICAgICAgICB0cmltSW5QbGFjZUZvclBsYXlvdXQgPSAoKSA9PiB0aGlzLnRyaW1JblBsYWNlKHVwZGF0ZWRQbGF5aW5nSXRlbSwgcGxheWluZ0l0ZW0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDbGVhciB3YWl0aW5nSXRlbSBpZiBpdCBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIHNjaGVkdWxlXG4gICAgICAgIHRoaXMud2FpdGluZ0l0ZW0gPSB0aGlzLnVwZGF0ZUl0ZW0odGhpcy53YWl0aW5nSXRlbSk7XG4gICAgICAgIHRoaXMuZW5kZWRJdGVtID0gdGhpcy51cGRhdGVJdGVtKHRoaXMuZW5kZWRJdGVtKTtcbiAgICAgIH1cbiAgICAgIC8vIERvIG5vdCByZXBsYWNlIEludGVyc3RpdGlhbCBidWZmZXJpbmdJdGVtIHdpdGhvdXQgYSBtYXRjaCAtIHVzZWQgZm9yIHRyYW5zZmVyaW5nIG1lZGlhIGVsZW1lbnQgb3Igc291cmNlXG4gICAgICBjb25zdCBidWZmZXJpbmdJdGVtID0gdGhpcy5idWZmZXJpbmdJdGVtO1xuICAgICAgaWYgKGJ1ZmZlcmluZ0l0ZW0pIHtcbiAgICAgICAgY29uc3QgdXBkYXRlZEJ1ZmZlcmluZ0l0ZW0gPSB0aGlzLnVwZGF0ZUl0ZW0oYnVmZmVyaW5nSXRlbSwgdGhpcy5idWZmZXJlZFBvcyk7XG4gICAgICAgIGlmICh0aGlzLml0ZW1zTWF0Y2goYnVmZmVyaW5nSXRlbSwgdXBkYXRlZEJ1ZmZlcmluZ0l0ZW0pKSB7XG4gICAgICAgICAgdGhpcy5idWZmZXJpbmdJdGVtID0gdXBkYXRlZEJ1ZmZlcmluZ0l0ZW07XG4gICAgICAgICAgdHJpbUluUGxhY2VGb3JQbGF5b3V0IHx8ICh0cmltSW5QbGFjZUZvclBsYXlvdXQgPSAoKSA9PiB0aGlzLnRyaW1JblBsYWNlKHVwZGF0ZWRCdWZmZXJpbmdJdGVtLCBidWZmZXJpbmdJdGVtKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYnVmZmVyaW5nSXRlbS5ldmVudCkge1xuICAgICAgICAgIC8vIEludGVyc3RpdGlhbCByZW1vdmVkIGZyb20gc2NoZWR1bGUgKExpdmUgLT4gVk9EIG9yIG90aGVyIHNjZW5hcmlvIHdoZXJlIFN0YXJ0IERhdGUgaXMgb3V0c2lkZSB0aGUgcmFuZ2Ugb2YgVk9EIFBsYXlsaXN0KVxuICAgICAgICAgIHRoaXMuYnVmZmVyaW5nSXRlbSA9IHRoaXMucGxheWluZ0l0ZW07XG4gICAgICAgICAgdGhpcy5jbGVhckludGVyc3RpdGlhbChidWZmZXJpbmdJdGVtLmV2ZW50LCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVtb3ZlZEludGVyc3RpdGlhbHMuZm9yRWFjaChpbnRlcnN0aXRpYWwgPT4ge1xuICAgICAgICBpbnRlcnN0aXRpYWwuYXNzZXRMaXN0LmZvckVhY2goYXNzZXQgPT4ge1xuICAgICAgICAgIHRoaXMuY2xlYXJBc3NldFBsYXllcihhc3NldC5pZGVudGlmaWVyLCBudWxsKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGlmIChpbnRlcnN0aXRpYWxzVXBkYXRlZCB8fCBwcmV2aW91c0l0ZW1zKSB7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLklOVEVSU1RJVElBTFNfVVBEQVRFRCwge1xuICAgICAgICAgIGV2ZW50czogaW50ZXJzdGl0aWFsRXZlbnRzLnNsaWNlKDApLFxuICAgICAgICAgIHNjaGVkdWxlOiBzY2hlZHVsZUl0ZW1zLnNsaWNlKDApLFxuICAgICAgICAgIGR1cmF0aW9ucyxcbiAgICAgICAgICByZW1vdmVkSWRzXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5pc0ludGVyc3RpdGlhbChwbGF5aW5nSXRlbSkgJiYgcmVtb3ZlZElkcy5pbmNsdWRlcyhwbGF5aW5nSXRlbS5ldmVudC5pZGVudGlmaWVyKSkge1xuICAgICAgICAgIHRoaXMud2FybihgSW50ZXJzdGl0aWFsIFwiJHtwbGF5aW5nSXRlbS5ldmVudC5pZGVudGlmaWVyfVwiIHJlbW92ZWQgd2hpbGUgcGxheWluZ2ApO1xuICAgICAgICAgIHRoaXMucHJpbWFyeUZhbGxiYWNrKHBsYXlpbmdJdGVtLmV2ZW50KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyaW1JblBsYWNlRm9yUGxheW91dCkge1xuICAgICAgICAgIHRyaW1JblBsYWNlRm9yUGxheW91dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaXMgYnVmZmVyZWQgdG8gbmV3IEludGVyc3RpdGlhbCBldmVudCBib3VuZGFyeVxuICAgICAgICAvLyAoTGl2ZSB1cGRhdGUgcHVibGlzaGVzIEludGVyc3RpdGlhbCB3aXRoIG5ldyBzZWdtZW50KVxuICAgICAgICB0aGlzLmNoZWNrQnVmZmVyKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLkhsc1BsYXllckNsYXNzID0gSGxzUGxheWVyQ2xhc3M7XG4gICAgdGhpcy5hc3NldExpc3RMb2FkZXIgPSBuZXcgQXNzZXRMaXN0TG9hZGVyKGhscyk7XG4gICAgdGhpcy5zY2hlZHVsZSA9IG5ldyBJbnRlcnN0aXRpYWxzU2NoZWR1bGUodGhpcy5vblNjaGVkdWxlVXBkYXRlLCBobHMubG9nZ2VyKTtcbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSElORywgdGhpcy5vbkF1ZGlvVHJhY2tTd2l0Y2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQVVESU9fVFJBQ0tfVVBEQVRFRCwgdGhpcy5vbkF1ZGlvVHJhY2tVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLlNVQlRJVExFX1RSQUNLX1NXSVRDSCwgdGhpcy5vblN1YnRpdGxlVHJhY2tTd2l0Y2gsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuU1VCVElUTEVfVFJBQ0tfVVBEQVRFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkVWRU5UX0NVRV9FTlRFUiwgdGhpcy5vbkludGVyc3RpdGlhbEN1ZUVudGVyLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkFTU0VUX0xJU1RfTE9BREVELCB0aGlzLm9uQXNzZXRMaXN0TG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9BUFBFTkRFRCwgdGhpcy5vbkJ1ZmZlckFwcGVuZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9GTFVTSEVELCB0aGlzLm9uQnVmZmVyRmx1c2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJFRF9UT19FTkQsIHRoaXMub25CdWZmZXJlZFRvRW5kLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0VOREVELCB0aGlzLm9uTWVkaWFFbmRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkRFU1RST1lJTkcsIHRoaXMub25EZXN0cm95aW5nLCB0aGlzKTtcbiAgfVxuICB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGlmICghaGxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hJTkcsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5BVURJT19UUkFDS19VUERBVEVELCB0aGlzLm9uQXVkaW9UcmFja1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLlNVQlRJVExFX1RSQUNLX1NXSVRDSCwgdGhpcy5vblN1YnRpdGxlVHJhY2tTd2l0Y2gsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLlNVQlRJVExFX1RSQUNLX1VQREFURUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRVZFTlRfQ1VFX0VOVEVSLCB0aGlzLm9uSW50ZXJzdGl0aWFsQ3VlRW50ZXIsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkFTU0VUX0xJU1RfTE9BREVELCB0aGlzLm9uQXNzZXRMaXN0TG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfQ09ERUNTLCB0aGlzLm9uQnVmZmVyQ29kZWNzLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfQVBQRU5ERUQsIHRoaXMub25CdWZmZXJBcHBlbmRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0ZMVVNIRUQsIHRoaXMub25CdWZmZXJGbHVzaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJFRF9UT19FTkQsIHRoaXMub25CdWZmZXJlZFRvRW5kLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9FTkRFRCwgdGhpcy5vbk1lZGlhRW5kZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkRFU1RST1lJTkcsIHRoaXMub25EZXN0cm95aW5nLCB0aGlzKTtcbiAgfVxuICBzdGFydExvYWQoKSB7XG4gICAgLy8gVE9ETzogc3RhcnRMb2FkIC0gY2hlY2sgZm9yIHdhaXRpbmdJdGVtIGFuZCByZXRyeSBieSByZXNldHRpbmcgc2NoZWR1bGVcbiAgICB0aGlzLnJlc3VtZUJ1ZmZlcmluZygpO1xuICB9XG4gIHN0b3BMb2FkKCkge1xuICAgIC8vIFRPRE86IHN0b3BMb2FkIC0gc3RvcCBhbGwgc2NoZXVsZS5ldmVudHNbXS5hc3NldExpc3RMb2FkZXI/LmFib3J0KCkgdGhlbiBkZWxldGUgdGhlIGxvYWRlcnNcbiAgICB0aGlzLnBhdXNlQnVmZmVyaW5nKCk7XG4gIH1cbiAgcmVzdW1lQnVmZmVyaW5nKCkge1xuICAgIHZhciBfdGhpcyRnZXRCdWZmZXJpbmdQbGE7XG4gICAgKF90aGlzJGdldEJ1ZmZlcmluZ1BsYSA9IHRoaXMuZ2V0QnVmZmVyaW5nUGxheWVyKCkpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRnZXRCdWZmZXJpbmdQbGEucmVzdW1lQnVmZmVyaW5nKCk7XG4gIH1cbiAgcGF1c2VCdWZmZXJpbmcoKSB7XG4gICAgdmFyIF90aGlzJGdldEJ1ZmZlcmluZ1BsYTI7XG4gICAgKF90aGlzJGdldEJ1ZmZlcmluZ1BsYTIgPSB0aGlzLmdldEJ1ZmZlcmluZ1BsYXllcigpKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkZ2V0QnVmZmVyaW5nUGxhMi5wYXVzZUJ1ZmZlcmluZygpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgIGlmICh0aGlzLmFzc2V0TGlzdExvYWRlcikge1xuICAgICAgdGhpcy5hc3NldExpc3RMb2FkZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLmVtcHR5UGxheWVyUXVldWUoKTtcbiAgICB0aGlzLmNsZWFyU2NoZWR1bGVTdGF0ZSgpO1xuICAgIGlmICh0aGlzLnNjaGVkdWxlKSB7XG4gICAgICB0aGlzLnNjaGVkdWxlLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5tZWRpYSA9IHRoaXMuZGV0YWNoZWREYXRhID0gdGhpcy5tZWRpYVNlbGVjdGlvbiA9IHRoaXMucmVxdWlyZWRUcmFja3MgPSB0aGlzLmFsdFNlbGVjdGlvbiA9IHRoaXMubWFuYWdlciA9IG51bGw7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuaGxzID0gdGhpcy5IbHNQbGF5ZXJDbGFzcyA9IHRoaXMuc2NoZWR1bGUgPSB0aGlzLmxvZyA9IG51bGw7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuYXNzZXRMaXN0TG9hZGVyID0gbnVsbDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5vblBsYXkgPSB0aGlzLm9uUGF1c2UgPSB0aGlzLm9uU2Vla2luZyA9IHRoaXMub25UaW1ldXBkYXRlID0gbnVsbDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5vblNjaGVkdWxlVXBkYXRlID0gbnVsbDtcbiAgfVxuICBvbkRlc3Ryb3lpbmcoKSB7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLnByaW1hcnlNZWRpYSB8fCB0aGlzLm1lZGlhO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgdGhpcy5yZW1vdmVNZWRpYUxpc3RlbmVycyhtZWRpYSk7XG4gICAgfVxuICB9XG4gIHJlbW92ZU1lZGlhTGlzdGVuZXJzKG1lZGlhKSB7XG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihtZWRpYSwgJ3BsYXknLCB0aGlzLm9uUGxheSk7XG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihtZWRpYSwgJ3BhdXNlJywgdGhpcy5vblBhdXNlKTtcbiAgICByZW1vdmVFdmVudExpc3RlbmVyKG1lZGlhLCAnc2Vla2luZycsIHRoaXMub25TZWVraW5nKTtcbiAgICByZW1vdmVFdmVudExpc3RlbmVyKG1lZGlhLCAndGltZXVwZGF0ZScsIHRoaXMub25UaW1ldXBkYXRlKTtcbiAgfVxuICBvbk1lZGlhQXR0YWNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICBhZGRFdmVudExpc3RlbmVyKG1lZGlhLCAnc2Vla2luZycsIHRoaXMub25TZWVraW5nKTtcbiAgICBhZGRFdmVudExpc3RlbmVyKG1lZGlhLCAndGltZXVwZGF0ZScsIHRoaXMub25UaW1ldXBkYXRlKTtcbiAgICBhZGRFdmVudExpc3RlbmVyKG1lZGlhLCAncGxheScsIHRoaXMub25QbGF5KTtcbiAgICBhZGRFdmVudExpc3RlbmVyKG1lZGlhLCAncGF1c2UnLCB0aGlzLm9uUGF1c2UpO1xuICB9XG4gIG9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHBsYXlpbmdJdGVtID0gdGhpcy5lZmZlY3RpdmVQbGF5aW5nSXRlbTtcbiAgICBjb25zdCBkZXRhY2hlZE1lZGlhID0gdGhpcy5kZXRhY2hlZERhdGE7XG4gICAgdGhpcy5kZXRhY2hlZERhdGEgPSBudWxsO1xuICAgIGlmIChwbGF5aW5nSXRlbSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5jaGVja1N0YXJ0KCk7XG4gICAgfSBlbHNlIGlmICghZGV0YWNoZWRNZWRpYSkge1xuICAgICAgLy8gUmVzdW1lIHNjaGVkdWxlIGFmdGVyIGRldGFjaGVkIGV4dGVybmFsbHlcbiAgICAgIHRoaXMuY2xlYXJTY2hlZHVsZVN0YXRlKCk7XG4gICAgICBjb25zdCBwbGF5aW5nSW5kZXggPSB0aGlzLmZpbmRJdGVtSW5kZXgocGxheWluZ0l0ZW0pO1xuICAgICAgdGhpcy5zZXRTY2hlZHVsZVBvc2l0aW9uKHBsYXlpbmdJbmRleCk7XG4gICAgfVxuICB9XG4gIGNsZWFyU2NoZWR1bGVTdGF0ZSgpIHtcbiAgICB0aGlzLnBsYXlpbmdJdGVtID0gdGhpcy5idWZmZXJpbmdJdGVtID0gdGhpcy53YWl0aW5nSXRlbSA9IHRoaXMuZW5kZWRJdGVtID0gdGhpcy5wbGF5aW5nQXNzZXQgPSB0aGlzLmVuZGVkQXNzZXQgPSB0aGlzLmJ1ZmZlcmluZ0Fzc2V0ID0gbnVsbDtcbiAgfVxuICBvbk1lZGlhRGV0YWNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3QgdHJhbnNmZXJyaW5nTWVkaWEgPSAhIWRhdGEudHJhbnNmZXJNZWRpYTtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgaWYgKHRyYW5zZmVycmluZ01lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChtZWRpYSkge1xuICAgICAgdGhpcy5yZW1vdmVNZWRpYUxpc3RlbmVycyhtZWRpYSk7XG4gICAgfVxuICAgIC8vIElmIGRldGFjaE1lZGlhIGlzIGNhbGxlZCB3aGlsZSBpbiBhbiBJbnRlcnN0aXRpYWwsIGRldGFjaCB0aGUgYXNzZXQgcGxheWVyIGFzIHdlbGwgYW5kIHJlc2V0IHRoZSBzY2hlZHVsZSBwb3NpdGlvblxuICAgIGlmICh0aGlzLmRldGFjaGVkRGF0YSkge1xuICAgICAgY29uc3QgcGxheWVyID0gdGhpcy5nZXRCdWZmZXJpbmdQbGF5ZXIoKTtcbiAgICAgIGlmIChwbGF5ZXIpIHtcbiAgICAgICAgdGhpcy5wbGF5aW5nQXNzZXQgPSB0aGlzLmVuZGVkQXNzZXQgPSB0aGlzLmJ1ZmZlcmluZ0Fzc2V0ID0gdGhpcy5idWZmZXJpbmdJdGVtID0gdGhpcy53YWl0aW5nSXRlbSA9IHRoaXMuZGV0YWNoZWREYXRhID0gbnVsbDtcbiAgICAgICAgcGxheWVyLmRldGFjaE1lZGlhKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnNob3VsZFBsYXkgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZ2V0IGludGVyc3RpdGlhbHNNYW5hZ2VyKCkge1xuICAgIGlmICghdGhpcy5tYW5hZ2VyKSB7XG4gICAgICBpZiAoIXRoaXMuaGxzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgYyA9IHRoaXM7XG4gICAgICBjb25zdCBlZmZlY3RpdmVCdWZmZXJpbmdJdGVtID0gKCkgPT4gYy5idWZmZXJpbmdJdGVtIHx8IGMud2FpdGluZ0l0ZW07XG4gICAgICBjb25zdCBnZXRBc3NldFBsYXllciA9IGFzc2V0ID0+IGFzc2V0ID8gYy5nZXRBc3NldFBsYXllcihhc3NldC5pZGVudGlmaWVyKSA6IGFzc2V0O1xuICAgICAgY29uc3QgZ2V0TWFwcGVkVGltZSA9IChpdGVtLCB0aW1lbGluZVR5cGUsIGFzc2V0LCBjb250cm9sbGVyRmllbGQsIGFzc2V0UGxheWVyRmllbGQpID0+IHtcbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICBsZXQgdGltZSA9IGl0ZW1bdGltZWxpbmVUeXBlXS5zdGFydDtcbiAgICAgICAgICBjb25zdCBpbnRlcnN0aXRpYWwgPSBpdGVtLmV2ZW50O1xuICAgICAgICAgIGlmIChpbnRlcnN0aXRpYWwpIHtcbiAgICAgICAgICAgIGlmICh0aW1lbGluZVR5cGUgPT09ICdwbGF5b3V0JyB8fCBpbnRlcnN0aXRpYWwudGltZWxpbmVPY2N1cGFuY3kgIT09IFRpbWVsaW5lT2NjdXBhbmN5LlBvaW50KSB7XG4gICAgICAgICAgICAgIGNvbnN0IGFzc2V0UGxheWVyID0gZ2V0QXNzZXRQbGF5ZXIoYXNzZXQpO1xuICAgICAgICAgICAgICBpZiAoKGFzc2V0UGxheWVyID09IG51bGwgPyB2b2lkIDAgOiBhc3NldFBsYXllci5pbnRlcnN0aXRpYWwpID09PSBpbnRlcnN0aXRpYWwpIHtcbiAgICAgICAgICAgICAgICB0aW1lICs9IGFzc2V0UGxheWVyLmFzc2V0SXRlbS5zdGFydE9mZnNldCArIGFzc2V0UGxheWVyW2Fzc2V0UGxheWVyRmllbGRdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY29udHJvbGxlckZpZWxkID09PSAnYnVmZmVyZWRQb3MnID8gZ2V0QnVmZmVyZWRFbmQoKSA6IGNbY29udHJvbGxlckZpZWxkXTtcbiAgICAgICAgICAgIHRpbWUgKz0gdmFsdWUgLSBpdGVtLnN0YXJ0O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGltZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH07XG4gICAgICBjb25zdCBmaW5kTWFwcGVkVGltZSA9IChwcmltYXJ5VGltZSwgdGltZWxpbmVUeXBlKSA9PiB7XG4gICAgICAgIGlmIChwcmltYXJ5VGltZSAhPT0gMCAmJiB0aW1lbGluZVR5cGUgIT09ICdwcmltYXJ5JyAmJiBjLnNjaGVkdWxlLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBfYyRzY2hlZHVsZSRpdGVtcztcbiAgICAgICAgICBjb25zdCBpbmRleCA9IGMuc2NoZWR1bGUuZmluZEl0ZW1JbmRleEF0VGltZShwcmltYXJ5VGltZSk7XG4gICAgICAgICAgY29uc3QgaXRlbSA9IChfYyRzY2hlZHVsZSRpdGVtcyA9IGMuc2NoZWR1bGUuaXRlbXMpID09IG51bGwgPyB2b2lkIDAgOiBfYyRzY2hlZHVsZSRpdGVtc1tpbmRleF07XG4gICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBpdGVtW3RpbWVsaW5lVHlwZV0uc3RhcnQgLSBpdGVtLnN0YXJ0O1xuICAgICAgICAgICAgcmV0dXJuIHByaW1hcnlUaW1lICsgZGlmZjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByaW1hcnlUaW1lO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldEJ1ZmZlcmVkRW5kID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGMuYnVmZmVyZWRQb3M7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gTnVtYmVyLk1BWF9WQUxVRSkge1xuICAgICAgICAgIHJldHVybiBnZXRNYXBwZWREdXJhdGlvbigncHJpbWFyeScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLm1heCh2YWx1ZSwgMCk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0TWFwcGVkRHVyYXRpb24gPSB0aW1lbGluZVR5cGUgPT4ge1xuICAgICAgICB2YXIgX2MkcHJpbWFyeURldGFpbHM7XG4gICAgICAgIGlmICgoX2MkcHJpbWFyeURldGFpbHMgPSBjLnByaW1hcnlEZXRhaWxzKSAhPSBudWxsICYmIF9jJHByaW1hcnlEZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgICAvLyByZXR1cm4gZW5kIG9mIGxhc3QgZXZlbnQgaXRlbSBvciBwbGF5bGlzdFxuICAgICAgICAgIHJldHVybiBjLnByaW1hcnlEZXRhaWxzLmVkZ2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGMuc2NoZWR1bGUuZHVyYXRpb25zW3RpbWVsaW5lVHlwZV07XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2Vla1RvID0gKHRpbWUsIHRpbWVsaW5lVHlwZSkgPT4ge1xuICAgICAgICB2YXIgX2l0ZW0kZXZlbnQsIF9jJHNjaGVkdWxlJGl0ZW1zMjtcbiAgICAgICAgY29uc3QgaXRlbSA9IGMuZWZmZWN0aXZlUGxheWluZ0l0ZW07XG4gICAgICAgIGlmIChpdGVtICE9IG51bGwgJiYgKF9pdGVtJGV2ZW50ID0gaXRlbS5ldmVudCkgIT0gbnVsbCAmJiBfaXRlbSRldmVudC5yZXN0cmljdGlvbnMuc2tpcCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjLmxvZyhgc2VlayB0byAke3RpbWV9IFwiJHt0aW1lbGluZVR5cGV9XCJgKTtcbiAgICAgICAgY29uc3QgcGxheWluZ0l0ZW0gPSBjLmVmZmVjdGl2ZVBsYXlpbmdJdGVtO1xuICAgICAgICBjb25zdCB0YXJnZXRJbmRleCA9IGMuc2NoZWR1bGUuZmluZEl0ZW1JbmRleEF0VGltZSh0aW1lLCB0aW1lbGluZVR5cGUpO1xuICAgICAgICBjb25zdCB0YXJnZXRJdGVtID0gKF9jJHNjaGVkdWxlJGl0ZW1zMiA9IGMuc2NoZWR1bGUuaXRlbXMpID09IG51bGwgPyB2b2lkIDAgOiBfYyRzY2hlZHVsZSRpdGVtczJbdGFyZ2V0SW5kZXhdO1xuICAgICAgICBjb25zdCBidWZmZXJpbmdQbGF5ZXIgPSBjLmdldEJ1ZmZlcmluZ1BsYXllcigpO1xuICAgICAgICBjb25zdCBidWZmZXJpbmdJbnRlcnN0aXRpYWwgPSBidWZmZXJpbmdQbGF5ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGJ1ZmZlcmluZ1BsYXllci5pbnRlcnN0aXRpYWw7XG4gICAgICAgIGNvbnN0IGFwcGVuZEluUGxhY2UgPSBidWZmZXJpbmdJbnRlcnN0aXRpYWwgPT0gbnVsbCA/IHZvaWQgMCA6IGJ1ZmZlcmluZ0ludGVyc3RpdGlhbC5hcHBlbmRJblBsYWNlO1xuICAgICAgICBjb25zdCBzZWVrSW5JdGVtID0gcGxheWluZ0l0ZW0gJiYgYy5pdGVtc01hdGNoKHBsYXlpbmdJdGVtLCB0YXJnZXRJdGVtKTtcbiAgICAgICAgaWYgKHBsYXlpbmdJdGVtICYmIChhcHBlbmRJblBsYWNlIHx8IHNlZWtJbkl0ZW0pKSB7XG4gICAgICAgICAgLy8gc2VlayBpbiBhc3NldCBwbGF5ZXIgb3IgcHJpbWFyeSBtZWRpYSAoYXBwZW5kSW5QbGFjZSlcbiAgICAgICAgICBjb25zdCBhc3NldFBsYXllciA9IGdldEFzc2V0UGxheWVyKGMucGxheWluZ0Fzc2V0KTtcbiAgICAgICAgICBjb25zdCBtZWRpYSA9IChhc3NldFBsYXllciA9PSBudWxsID8gdm9pZCAwIDogYXNzZXRQbGF5ZXIubWVkaWEpIHx8IGMucHJpbWFyeU1lZGlhO1xuICAgICAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFRpbWUgPSB0aW1lbGluZVR5cGUgPT09ICdwcmltYXJ5JyA/IG1lZGlhLmN1cnJlbnRUaW1lIDogZ2V0TWFwcGVkVGltZShwbGF5aW5nSXRlbSwgdGltZWxpbmVUeXBlLCBjLnBsYXlpbmdBc3NldCwgJ3RpbWVsaW5lUG9zJywgJ2N1cnJlbnRUaW1lJyk7XG4gICAgICAgICAgICBjb25zdCBkaWZmID0gdGltZSAtIGN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgY29uc3Qgc2Vla1RvVGltZSA9IChhcHBlbmRJblBsYWNlID8gY3VycmVudFRpbWUgOiBtZWRpYS5jdXJyZW50VGltZSkgKyBkaWZmO1xuICAgICAgICAgICAgaWYgKHNlZWtUb1RpbWUgPj0gMCAmJiAoIWFzc2V0UGxheWVyIHx8IGFwcGVuZEluUGxhY2UgfHwgc2Vla1RvVGltZSA8PSBhc3NldFBsYXllci5kdXJhdGlvbikpIHtcbiAgICAgICAgICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSBzZWVrVG9UaW1lO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHNlZWsgb3V0IG9mIGl0ZW0gb3IgYXNzZXRcbiAgICAgICAgaWYgKHRhcmdldEl0ZW0pIHtcbiAgICAgICAgICBsZXQgc2Vla1RvVGltZSA9IHRpbWU7XG4gICAgICAgICAgaWYgKHRpbWVsaW5lVHlwZSAhPT0gJ3ByaW1hcnknKSB7XG4gICAgICAgICAgICBjb25zdCBwcmltYXJ5U2VnbWVudFN0YXJ0ID0gdGFyZ2V0SXRlbVt0aW1lbGluZVR5cGVdLnN0YXJ0O1xuICAgICAgICAgICAgY29uc3QgZGlmZiA9IHRpbWUgLSBwcmltYXJ5U2VnbWVudFN0YXJ0O1xuICAgICAgICAgICAgc2Vla1RvVGltZSA9IHRhcmdldEl0ZW0uc3RhcnQgKyBkaWZmO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB0YXJnZXRJc1ByaW1hcnkgPSAhYy5pc0ludGVyc3RpdGlhbCh0YXJnZXRJdGVtKTtcbiAgICAgICAgICBpZiAoKCFjLmlzSW50ZXJzdGl0aWFsKHBsYXlpbmdJdGVtKSB8fCBwbGF5aW5nSXRlbS5ldmVudC5hcHBlbmRJblBsYWNlKSAmJiAodGFyZ2V0SXNQcmltYXJ5IHx8IHRhcmdldEl0ZW0uZXZlbnQuYXBwZW5kSW5QbGFjZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lZGlhID0gYy5tZWRpYSB8fCAoYXBwZW5kSW5QbGFjZSA/IGJ1ZmZlcmluZ1BsYXllciA9PSBudWxsID8gdm9pZCAwIDogYnVmZmVyaW5nUGxheWVyLm1lZGlhIDogbnVsbCk7XG4gICAgICAgICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSBzZWVrVG9UaW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAocGxheWluZ0l0ZW0pIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIGFuIEludGVyc3RpdGlhbCBiZXR3ZWVuIHRoZSBjdXJyZW50IGl0ZW0gYW5kIHRhcmdldCBpdGVtIGhhcyBhbiBYLVJFU1RSSUNUIEpVTVAgcmVzdHJpY3Rpb25cbiAgICAgICAgICAgIGNvbnN0IHBsYXlpbmdJbmRleCA9IGMuZmluZEl0ZW1JbmRleChwbGF5aW5nSXRlbSk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0SW5kZXggPiBwbGF5aW5nSW5kZXgpIHtcbiAgICAgICAgICAgICAgY29uc3QganVtcEluZGV4ID0gYy5zY2hlZHVsZS5maW5kSnVtcFJlc3RyaWN0ZWRJbmRleChwbGF5aW5nSW5kZXggKyAxLCB0YXJnZXRJbmRleCk7XG4gICAgICAgICAgICAgIGlmIChqdW1wSW5kZXggPiBwbGF5aW5nSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjLnNldFNjaGVkdWxlUG9zaXRpb24oanVtcEluZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBhc3NldEluZGV4ID0gMDtcbiAgICAgICAgICAgIGlmICh0YXJnZXRJc1ByaW1hcnkpIHtcbiAgICAgICAgICAgICAgYy50aW1lbGluZVBvcyA9IHNlZWtUb1RpbWU7XG4gICAgICAgICAgICAgIGMuY2hlY2tCdWZmZXIoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBfdGFyZ2V0SXRlbSRldmVudDtcbiAgICAgICAgICAgICAgY29uc3QgYXNzZXRMaXN0ID0gdGFyZ2V0SXRlbSA9PSBudWxsID8gdm9pZCAwIDogKF90YXJnZXRJdGVtJGV2ZW50ID0gdGFyZ2V0SXRlbS5ldmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YXJnZXRJdGVtJGV2ZW50LmFzc2V0TGlzdDtcbiAgICAgICAgICAgICAgaWYgKGFzc2V0TGlzdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50VGltZSA9IHRpbWUgLSAodGFyZ2V0SXRlbVt0aW1lbGluZVR5cGVdIHx8IHRhcmdldEl0ZW0pLnN0YXJ0O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBhc3NldExpc3QubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBhc3NldCA9IGFzc2V0TGlzdFtpXTtcbiAgICAgICAgICAgICAgICAgIGlmIChhc3NldC5kdXJhdGlvbiAmJiBldmVudFRpbWUgPj0gYXNzZXQuc3RhcnRPZmZzZXQgJiYgZXZlbnRUaW1lIDwgYXNzZXQuc3RhcnRPZmZzZXQgKyBhc3NldC5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBhc3NldEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjLnNldFNjaGVkdWxlUG9zaXRpb24odGFyZ2V0SW5kZXgsIGFzc2V0SW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldEFjdGl2ZUludGVyc3RpdGlhbCA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgcGxheWluZ0l0ZW0gPSBjLmVmZmVjdGl2ZVBsYXlpbmdJdGVtO1xuICAgICAgICBpZiAoYy5pc0ludGVyc3RpdGlhbChwbGF5aW5nSXRlbSkpIHtcbiAgICAgICAgICByZXR1cm4gcGxheWluZ0l0ZW07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnVmZmVyaW5nSXRlbSA9IGVmZmVjdGl2ZUJ1ZmZlcmluZ0l0ZW0oKTtcbiAgICAgICAgaWYgKGMuaXNJbnRlcnN0aXRpYWwoYnVmZmVyaW5nSXRlbSkpIHtcbiAgICAgICAgICByZXR1cm4gYnVmZmVyaW5nSXRlbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBjb25zdCBpbnRlcnN0aXRpYWxQbGF5ZXIgPSB7XG4gICAgICAgIGdldCBjdXJyZW50VGltZSgpIHtcbiAgICAgICAgICBjb25zdCBpbnRlcnN0aXRpYWxJdGVtID0gZ2V0QWN0aXZlSW50ZXJzdGl0aWFsKCk7XG4gICAgICAgICAgY29uc3QgcGxheWluZ0l0ZW0gPSBjLmVmZmVjdGl2ZVBsYXlpbmdJdGVtO1xuICAgICAgICAgIGlmIChwbGF5aW5nSXRlbSAmJiBwbGF5aW5nSXRlbSA9PT0gaW50ZXJzdGl0aWFsSXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldE1hcHBlZFRpbWUocGxheWluZ0l0ZW0sICdwbGF5b3V0JywgYy5lZmZlY3RpdmVQbGF5aW5nQXNzZXQsICd0aW1lbGluZVBvcycsICdjdXJyZW50VGltZScpIC0gcGxheWluZ0l0ZW0ucGxheW91dC5zdGFydDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCBjdXJyZW50VGltZSh0aW1lKSB7XG4gICAgICAgICAgY29uc3QgaW50ZXJzdGl0aWFsSXRlbSA9IGdldEFjdGl2ZUludGVyc3RpdGlhbCgpO1xuICAgICAgICAgIGNvbnN0IHBsYXlpbmdJdGVtID0gYy5lZmZlY3RpdmVQbGF5aW5nSXRlbTtcbiAgICAgICAgICBpZiAocGxheWluZ0l0ZW0gJiYgcGxheWluZ0l0ZW0gPT09IGludGVyc3RpdGlhbEl0ZW0pIHtcbiAgICAgICAgICAgIHNlZWtUbyh0aW1lICsgcGxheWluZ0l0ZW0ucGxheW91dC5zdGFydCwgJ3BsYXlvdXQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBkdXJhdGlvbigpIHtcbiAgICAgICAgICBjb25zdCBpbnRlcnN0aXRpYWxJdGVtID0gZ2V0QWN0aXZlSW50ZXJzdGl0aWFsKCk7XG4gICAgICAgICAgaWYgKGludGVyc3RpdGlhbEl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcnN0aXRpYWxJdGVtLnBsYXlvdXQuZW5kIC0gaW50ZXJzdGl0aWFsSXRlbS5wbGF5b3V0LnN0YXJ0O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGFzc2V0UGxheWVycygpIHtcbiAgICAgICAgICB2YXIgX2dldEFjdGl2ZUludGVyc3RpdGlhO1xuICAgICAgICAgIGNvbnN0IGFzc2V0TGlzdCA9IChfZ2V0QWN0aXZlSW50ZXJzdGl0aWEgPSBnZXRBY3RpdmVJbnRlcnN0aXRpYWwoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9nZXRBY3RpdmVJbnRlcnN0aXRpYS5ldmVudC5hc3NldExpc3Q7XG4gICAgICAgICAgaWYgKGFzc2V0TGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuIGFzc2V0TGlzdC5tYXAoYXNzZXQgPT4gYy5nZXRBc3NldFBsYXllcihhc3NldC5pZGVudGlmaWVyKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHBsYXlpbmdJbmRleCgpIHtcbiAgICAgICAgICB2YXIgX2dldEFjdGl2ZUludGVyc3RpdGlhMjtcbiAgICAgICAgICBjb25zdCBpbnRlcnN0aXRpYWwgPSAoX2dldEFjdGl2ZUludGVyc3RpdGlhMiA9IGdldEFjdGl2ZUludGVyc3RpdGlhbCgpKSA9PSBudWxsID8gdm9pZCAwIDogX2dldEFjdGl2ZUludGVyc3RpdGlhMi5ldmVudDtcbiAgICAgICAgICBpZiAoaW50ZXJzdGl0aWFsICYmIGMuZWZmZWN0aXZlUGxheWluZ0Fzc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJzdGl0aWFsLmZpbmRBc3NldEluZGV4KGMuZWZmZWN0aXZlUGxheWluZ0Fzc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgc2NoZWR1bGVJdGVtKCkge1xuICAgICAgICAgIHJldHVybiBnZXRBY3RpdmVJbnRlcnN0aXRpYWwoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMubWFuYWdlciA9IHtcbiAgICAgICAgZ2V0IGV2ZW50cygpIHtcbiAgICAgICAgICB2YXIgX2Mkc2NoZWR1bGUsIF9jJHNjaGVkdWxlJGV2ZW50cztcbiAgICAgICAgICByZXR1cm4gKChfYyRzY2hlZHVsZSA9IGMuc2NoZWR1bGUpID09IG51bGwgPyB2b2lkIDAgOiAoX2Mkc2NoZWR1bGUkZXZlbnRzID0gX2Mkc2NoZWR1bGUuZXZlbnRzKSA9PSBudWxsID8gdm9pZCAwIDogX2Mkc2NoZWR1bGUkZXZlbnRzLnNsaWNlKDApKSB8fCBbXTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHNjaGVkdWxlKCkge1xuICAgICAgICAgIHZhciBfYyRzY2hlZHVsZTIsIF9jJHNjaGVkdWxlMiRpdGVtcztcbiAgICAgICAgICByZXR1cm4gKChfYyRzY2hlZHVsZTIgPSBjLnNjaGVkdWxlKSA9PSBudWxsID8gdm9pZCAwIDogKF9jJHNjaGVkdWxlMiRpdGVtcyA9IF9jJHNjaGVkdWxlMi5pdGVtcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jJHNjaGVkdWxlMiRpdGVtcy5zbGljZSgwKSkgfHwgW107XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBpbnRlcnN0aXRpYWxQbGF5ZXIoKSB7XG4gICAgICAgICAgaWYgKGdldEFjdGl2ZUludGVyc3RpdGlhbCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJzdGl0aWFsUGxheWVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHBsYXllclF1ZXVlKCkge1xuICAgICAgICAgIHJldHVybiBjLnBsYXllclF1ZXVlLnNsaWNlKDApO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgYnVmZmVyaW5nQXNzZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIGMuYnVmZmVyaW5nQXNzZXQ7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBidWZmZXJpbmdJdGVtKCkge1xuICAgICAgICAgIHJldHVybiBlZmZlY3RpdmVCdWZmZXJpbmdJdGVtKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBidWZmZXJpbmdJbmRleCgpIHtcbiAgICAgICAgICBjb25zdCBpdGVtID0gZWZmZWN0aXZlQnVmZmVyaW5nSXRlbSgpO1xuICAgICAgICAgIHJldHVybiBjLmZpbmRJdGVtSW5kZXgoaXRlbSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBwbGF5aW5nQXNzZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIGMuZWZmZWN0aXZlUGxheWluZ0Fzc2V0O1xuICAgICAgICB9LFxuICAgICAgICBnZXQgcGxheWluZ0l0ZW0oKSB7XG4gICAgICAgICAgcmV0dXJuIGMuZWZmZWN0aXZlUGxheWluZ0l0ZW07XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBwbGF5aW5nSW5kZXgoKSB7XG4gICAgICAgICAgY29uc3QgaXRlbSA9IGMuZWZmZWN0aXZlUGxheWluZ0l0ZW07XG4gICAgICAgICAgcmV0dXJuIGMuZmluZEl0ZW1JbmRleChpdGVtKTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJpbWFyeToge1xuICAgICAgICAgIGdldCBidWZmZXJlZEVuZCgpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRCdWZmZXJlZEVuZCgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IGN1cnJlbnRUaW1lKCkge1xuICAgICAgICAgICAgY29uc3QgdGltZWxpbmVQb3MgPSBjLnRpbWVsaW5lUG9zO1xuICAgICAgICAgICAgcmV0dXJuIHRpbWVsaW5lUG9zID4gMCA/IHRpbWVsaW5lUG9zIDogMDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldCBjdXJyZW50VGltZSh0aW1lKSB7XG4gICAgICAgICAgICBzZWVrVG8odGltZSwgJ3ByaW1hcnknKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBkdXJhdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRNYXBwZWREdXJhdGlvbigncHJpbWFyeScpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IHNlZWthYmxlU3RhcnQoKSB7XG4gICAgICAgICAgICB2YXIgX2MkcHJpbWFyeURldGFpbHMyO1xuICAgICAgICAgICAgcmV0dXJuICgoX2MkcHJpbWFyeURldGFpbHMyID0gYy5wcmltYXJ5RGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jJHByaW1hcnlEZXRhaWxzMi5mcmFnbWVudFN0YXJ0KSB8fCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaW50ZWdyYXRlZDoge1xuICAgICAgICAgIGdldCBidWZmZXJlZEVuZCgpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRNYXBwZWRUaW1lKGVmZmVjdGl2ZUJ1ZmZlcmluZ0l0ZW0oKSwgJ2ludGVncmF0ZWQnLCBjLmJ1ZmZlcmluZ0Fzc2V0LCAnYnVmZmVyZWRQb3MnLCAnYnVmZmVyZWRFbmQnKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBjdXJyZW50VGltZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRNYXBwZWRUaW1lKGMuZWZmZWN0aXZlUGxheWluZ0l0ZW0sICdpbnRlZ3JhdGVkJywgYy5lZmZlY3RpdmVQbGF5aW5nQXNzZXQsICd0aW1lbGluZVBvcycsICdjdXJyZW50VGltZScpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0IGN1cnJlbnRUaW1lKHRpbWUpIHtcbiAgICAgICAgICAgIHNlZWtUbyh0aW1lLCAnaW50ZWdyYXRlZCcpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IGR1cmF0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldE1hcHBlZER1cmF0aW9uKCdpbnRlZ3JhdGVkJyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgc2Vla2FibGVTdGFydCgpIHtcbiAgICAgICAgICAgIHZhciBfYyRwcmltYXJ5RGV0YWlsczM7XG4gICAgICAgICAgICByZXR1cm4gZmluZE1hcHBlZFRpbWUoKChfYyRwcmltYXJ5RGV0YWlsczMgPSBjLnByaW1hcnlEZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX2MkcHJpbWFyeURldGFpbHMzLmZyYWdtZW50U3RhcnQpIHx8IDAsICdpbnRlZ3JhdGVkJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBza2lwOiAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgaXRlbSA9IGMuZWZmZWN0aXZlUGxheWluZ0l0ZW07XG4gICAgICAgICAgY29uc3QgZXZlbnQgPSBpdGVtID09IG51bGwgPyB2b2lkIDAgOiBpdGVtLmV2ZW50O1xuICAgICAgICAgIGlmIChldmVudCAmJiAhZXZlbnQucmVzdHJpY3Rpb25zLnNraXApIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gYy5maW5kSXRlbUluZGV4KGl0ZW0pO1xuICAgICAgICAgICAgaWYgKGV2ZW50LmFwcGVuZEluUGxhY2UpIHtcbiAgICAgICAgICAgICAgY29uc3QgdGltZSA9IGl0ZW0ucGxheW91dC5zdGFydCArIGl0ZW0uZXZlbnQuZHVyYXRpb247XG4gICAgICAgICAgICAgIHNlZWtUbyh0aW1lICsgMC4wMDEsICdwbGF5b3V0Jyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjLmFkdmFuY2VBZnRlckFzc2V0RW5kZWQoZXZlbnQsIGluZGV4LCBJbmZpbml0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tYW5hZ2VyO1xuICB9XG5cbiAgLy8gU2NoZWR1bGUgZ2V0dGVyc1xuICBnZXQgZWZmZWN0aXZlUGxheWluZ0l0ZW0oKSB7XG4gICAgcmV0dXJuIHRoaXMud2FpdGluZ0l0ZW0gfHwgdGhpcy5wbGF5aW5nSXRlbSB8fCB0aGlzLmVuZGVkSXRlbTtcbiAgfVxuICBnZXQgZWZmZWN0aXZlUGxheWluZ0Fzc2V0KCkge1xuICAgIHJldHVybiB0aGlzLnBsYXlpbmdBc3NldCB8fCB0aGlzLmVuZGVkQXNzZXQ7XG4gIH1cbiAgZ2V0IHBsYXlpbmdMYXN0SXRlbSgpIHtcbiAgICB2YXIgX3RoaXMkc2NoZWR1bGU7XG4gICAgY29uc3QgcGxheWluZ0l0ZW0gPSB0aGlzLnBsYXlpbmdJdGVtO1xuICAgIGNvbnN0IGl0ZW1zID0gKF90aGlzJHNjaGVkdWxlID0gdGhpcy5zY2hlZHVsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHNjaGVkdWxlLml0ZW1zO1xuICAgIGlmICghdGhpcy5wbGF5YmFja1N0YXJ0ZWQgfHwgIXBsYXlpbmdJdGVtIHx8ICFpdGVtcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5kSXRlbUluZGV4KHBsYXlpbmdJdGVtKSA9PT0gaXRlbXMubGVuZ3RoIC0gMTtcbiAgfVxuICBnZXQgcGxheWJhY2tTdGFydGVkKCkge1xuICAgIHJldHVybiB0aGlzLmVmZmVjdGl2ZVBsYXlpbmdJdGVtICE9PSBudWxsO1xuICB9XG5cbiAgLy8gTWVkaWEgZ2V0dGVycyBhbmQgZXZlbnQgY2FsbGJhY2tzXG4gIGdldCBjdXJyZW50VGltZSgpIHtcbiAgICB2YXIgX3RoaXMkYnVmZmVyaW5nSXRlbSwgX3RoaXMkYnVmZmVyaW5nSXRlbSRlLCBfbWVkaWE7XG4gICAgaWYgKHRoaXMubWVkaWFTZWxlY3Rpb24gPT09IG51bGwpIHtcbiAgICAgIC8vIERvIG5vdCBhZHZhbmNlIGJlZm9yZSBzY2hlZHVsZSBpcyBrbm93blxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gSWdub3JlIGN1cnJlbnRUaW1lIHdoZW4gZGV0YWNoZWQgZm9yIEludGVyc3RpdGlhbCBwbGF5YmFjayB3aXRoIHNvdXJjZSByZXNldFxuICAgIGNvbnN0IHF1ZXVlZEZvclBsYXliYWNrID0gdGhpcy53YWl0aW5nSXRlbSB8fCB0aGlzLnBsYXlpbmdJdGVtO1xuICAgIGlmICh0aGlzLmlzSW50ZXJzdGl0aWFsKHF1ZXVlZEZvclBsYXliYWNrKSAmJiAhcXVldWVkRm9yUGxheWJhY2suZXZlbnQuYXBwZW5kSW5QbGFjZSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAoIW1lZGlhICYmIChfdGhpcyRidWZmZXJpbmdJdGVtID0gdGhpcy5idWZmZXJpbmdJdGVtKSAhPSBudWxsICYmIChfdGhpcyRidWZmZXJpbmdJdGVtJGUgPSBfdGhpcyRidWZmZXJpbmdJdGVtLmV2ZW50KSAhPSBudWxsICYmIF90aGlzJGJ1ZmZlcmluZ0l0ZW0kZS5hcHBlbmRJblBsYWNlKSB7XG4gICAgICAvLyBPYnNlcnZlIGRldGFjaGVkIG1lZGlhIGN1cnJlbnRUaW1lIHdoZW4gYXBwZW5kaW5nIGluIHBsYWNlXG4gICAgICBtZWRpYSA9IHRoaXMucHJpbWFyeU1lZGlhO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50VGltZSA9IChfbWVkaWEgPSBtZWRpYSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9tZWRpYS5jdXJyZW50VGltZTtcbiAgICBpZiAoY3VycmVudFRpbWUgPT09IHVuZGVmaW5lZCB8fCAhaXNGaW5pdGVOdW1iZXIoY3VycmVudFRpbWUpKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudFRpbWU7XG4gIH1cbiAgZ2V0IHByaW1hcnlNZWRpYSgpIHtcbiAgICB2YXIgX3RoaXMkZGV0YWNoZWREYXRhO1xuICAgIHJldHVybiB0aGlzLm1lZGlhIHx8ICgoX3RoaXMkZGV0YWNoZWREYXRhID0gdGhpcy5kZXRhY2hlZERhdGEpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRkZXRhY2hlZERhdGEubWVkaWEpIHx8IG51bGw7XG4gIH1cbiAgaXNJbnRlcnN0aXRpYWwoaXRlbSkge1xuICAgIHJldHVybiAhIShpdGVtICE9IG51bGwgJiYgaXRlbS5ldmVudCk7XG4gIH1cbiAgcmV0cmVpdmVNZWRpYVNvdXJjZShhc3NldElkLCB0b1NlZ21lbnQpIHtcbiAgICBjb25zdCBwbGF5ZXIgPSB0aGlzLmdldEFzc2V0UGxheWVyKGFzc2V0SWQpO1xuICAgIGlmIChwbGF5ZXIpIHtcbiAgICAgIHRoaXMudHJhbnNmZXJNZWRpYUZyb21QbGF5ZXIocGxheWVyLCB0b1NlZ21lbnQpO1xuICAgIH1cbiAgfVxuICB0cmFuc2Zlck1lZGlhRnJvbVBsYXllcihwbGF5ZXIsIHRvU2VnbWVudCkge1xuICAgIGNvbnN0IGFwcGVuZEluUGxhY2UgPSBwbGF5ZXIuaW50ZXJzdGl0aWFsLmFwcGVuZEluUGxhY2U7XG4gICAgY29uc3QgcGxheWVyTWVkaWEgPSBwbGF5ZXIubWVkaWE7XG4gICAgaWYgKGFwcGVuZEluUGxhY2UgJiYgcGxheWVyTWVkaWEgPT09IHRoaXMucHJpbWFyeU1lZGlhKSB7XG4gICAgICB0aGlzLmJ1ZmZlcmluZ0Fzc2V0ID0gbnVsbDtcbiAgICAgIGlmICghdG9TZWdtZW50IHx8IHRoaXMuaXNJbnRlcnN0aXRpYWwodG9TZWdtZW50KSAmJiAhdG9TZWdtZW50LmV2ZW50LmFwcGVuZEluUGxhY2UpIHtcbiAgICAgICAgLy8gTWVkaWFTb3VyY2UgY2Fubm90IGJlIHRyYW5zZmVyZWQgYmFjayB0byBhbiBJbnRlcnN0aXRpYWwgdGhhdCByZXF1aXJlcyBhIHNvdXJjZSByZXNldFxuICAgICAgICAvLyBuby1vcCB3aGVuIHRvU2VnbWVudCBpcyB1bmRlZmluZWRcbiAgICAgICAgaWYgKHRvU2VnbWVudCAmJiBwbGF5ZXJNZWRpYSkge1xuICAgICAgICAgIHRoaXMuZGV0YWNoZWREYXRhID0ge1xuICAgICAgICAgICAgbWVkaWE6IHBsYXllck1lZGlhXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGF0dGFjaE1lZGlhU291cmNlRGF0YSA9IHBsYXllci50cmFuc2Zlck1lZGlhKCk7XG4gICAgICB0aGlzLmxvZyhgdHJhbnNmZXIgTWVkaWFTb3VyY2UgZnJvbSAke3BsYXllcn0gJHtzdHJpbmdpZnkoYXR0YWNoTWVkaWFTb3VyY2VEYXRhKX1gKTtcbiAgICAgIHRoaXMuZGV0YWNoZWREYXRhID0gYXR0YWNoTWVkaWFTb3VyY2VEYXRhO1xuICAgIH0gZWxzZSBpZiAodG9TZWdtZW50ICYmIHBsYXllck1lZGlhKSB7XG4gICAgICB0aGlzLnNob3VsZFBsYXkgfHwgKHRoaXMuc2hvdWxkUGxheSA9ICFwbGF5ZXJNZWRpYS5wYXVzZWQpO1xuICAgIH1cbiAgfVxuICB0cmFuc2Zlck1lZGlhVG8ocGxheWVyLCBtZWRpYSkge1xuICAgIHZhciBfdGhpcyRkZXRhY2hlZERhdGEyLCBfYXR0YWNoTWVkaWFTb3VyY2VEYXQ7XG4gICAgaWYgKHBsYXllci5tZWRpYSA9PT0gbWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGF0dGFjaE1lZGlhU291cmNlRGF0YSA9IG51bGw7XG4gICAgY29uc3QgcHJpbWFyeVBsYXllciA9IHRoaXMuaGxzO1xuICAgIGNvbnN0IGlzQXNzZXRQbGF5ZXIgPSBwbGF5ZXIgIT09IHByaW1hcnlQbGF5ZXI7XG4gICAgY29uc3QgYXBwZW5kSW5QbGFjZSA9IGlzQXNzZXRQbGF5ZXIgJiYgcGxheWVyLmludGVyc3RpdGlhbC5hcHBlbmRJblBsYWNlO1xuICAgIGNvbnN0IGRldGFjaGVkTWVkaWFTb3VyY2UgPSAoX3RoaXMkZGV0YWNoZWREYXRhMiA9IHRoaXMuZGV0YWNoZWREYXRhKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkZGV0YWNoZWREYXRhMi5tZWRpYVNvdXJjZTtcbiAgICBsZXQgbG9nRnJvbVNvdXJjZTtcbiAgICBpZiAocHJpbWFyeVBsYXllci5tZWRpYSkge1xuICAgICAgaWYgKGFwcGVuZEluUGxhY2UpIHtcbiAgICAgICAgYXR0YWNoTWVkaWFTb3VyY2VEYXRhID0gcHJpbWFyeVBsYXllci50cmFuc2Zlck1lZGlhKCk7XG4gICAgICAgIHRoaXMuZGV0YWNoZWREYXRhID0gYXR0YWNoTWVkaWFTb3VyY2VEYXRhO1xuICAgICAgfVxuICAgICAgbG9nRnJvbVNvdXJjZSA9IGBQcmltYXJ5YDtcbiAgICB9IGVsc2UgaWYgKGRldGFjaGVkTWVkaWFTb3VyY2UpIHtcbiAgICAgIGNvbnN0IGJ1ZmZlcmluZ1BsYXllciA9IHRoaXMuZ2V0QnVmZmVyaW5nUGxheWVyKCk7XG4gICAgICBpZiAoYnVmZmVyaW5nUGxheWVyKSB7XG4gICAgICAgIGF0dGFjaE1lZGlhU291cmNlRGF0YSA9IGJ1ZmZlcmluZ1BsYXllci50cmFuc2Zlck1lZGlhKCk7XG4gICAgICAgIGxvZ0Zyb21Tb3VyY2UgPSBgJHtidWZmZXJpbmdQbGF5ZXJ9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ0Zyb21Tb3VyY2UgPSBgZGV0YWNoZWQgTWVkaWFTb3VyY2VgO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2dGcm9tU291cmNlID0gYGRldGFjaGVkIG1lZGlhYDtcbiAgICB9XG4gICAgaWYgKCFhdHRhY2hNZWRpYVNvdXJjZURhdGEpIHtcbiAgICAgIGlmIChkZXRhY2hlZE1lZGlhU291cmNlKSB7XG4gICAgICAgIGF0dGFjaE1lZGlhU291cmNlRGF0YSA9IHRoaXMuZGV0YWNoZWREYXRhO1xuICAgICAgICB0aGlzLmxvZyhgdXNpbmcgZGV0YWNoZWREYXRhOiBNZWRpYVNvdXJjZSAke3N0cmluZ2lmeShhdHRhY2hNZWRpYVNvdXJjZURhdGEpfWApO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5kZXRhY2hlZERhdGEgfHwgcHJpbWFyeVBsYXllci5tZWRpYSA9PT0gbWVkaWEpIHtcbiAgICAgICAgLy8gS2VlcCBpbnRlcnN0aXRpYWwgbWVkaWEgdHJhbnNpdGlvbiBjb25zaXN0ZW50XG4gICAgICAgIGNvbnN0IHBsYXllclF1ZXVlID0gdGhpcy5wbGF5ZXJRdWV1ZTtcbiAgICAgICAgaWYgKHBsYXllclF1ZXVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBwbGF5ZXJRdWV1ZS5mb3JFYWNoKHF1ZXVlZFBsYXllciA9PiB7XG4gICAgICAgICAgICBpZiAoaXNBc3NldFBsYXllciAmJiBxdWV1ZWRQbGF5ZXIuaW50ZXJzdGl0aWFsLmFwcGVuZEluUGxhY2UgIT09IGFwcGVuZEluUGxhY2UpIHtcbiAgICAgICAgICAgICAgY29uc3QgaW50ZXJzdGl0aWFsID0gcXVldWVkUGxheWVyLmludGVyc3RpdGlhbDtcbiAgICAgICAgICAgICAgdGhpcy5jbGVhckludGVyc3RpdGlhbChxdWV1ZWRQbGF5ZXIuaW50ZXJzdGl0aWFsLCBudWxsKTtcbiAgICAgICAgICAgICAgaW50ZXJzdGl0aWFsLmFwcGVuZEluUGxhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgaWYgKGludGVyc3RpdGlhbC5hcHBlbmRJblBsYWNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53YXJuKGBDb3VsZCBub3QgY2hhbmdlIGFwcGVuZCBzdHJhdGVneSBmb3IgcXVldWVkIGFzc2V0cyAke2ludGVyc3RpdGlhbH1gKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGxzLmRldGFjaE1lZGlhKCk7XG4gICAgICAgIHRoaXMuZGV0YWNoZWREYXRhID0ge1xuICAgICAgICAgIG1lZGlhXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zZmVycmluZyA9IGF0dGFjaE1lZGlhU291cmNlRGF0YSAmJiAnbWVkaWFTb3VyY2UnIGluIGF0dGFjaE1lZGlhU291cmNlRGF0YSAmJiAoKF9hdHRhY2hNZWRpYVNvdXJjZURhdCA9IGF0dGFjaE1lZGlhU291cmNlRGF0YS5tZWRpYVNvdXJjZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hdHRhY2hNZWRpYVNvdXJjZURhdC5yZWFkeVN0YXRlKSAhPT0gJ2Nsb3NlZCc7XG4gICAgY29uc3QgZGF0YVRvQXR0YWNoID0gdHJhbnNmZXJyaW5nICYmIGF0dGFjaE1lZGlhU291cmNlRGF0YSA/IGF0dGFjaE1lZGlhU291cmNlRGF0YSA6IG1lZGlhO1xuICAgIHRoaXMubG9nKGAke3RyYW5zZmVycmluZyA/ICd0cmFuc2ZlcmluZyBNZWRpYVNvdXJjZScgOiAnYXR0YWNoaW5nIG1lZGlhJ30gdG8gJHtpc0Fzc2V0UGxheWVyID8gcGxheWVyIDogJ1ByaW1hcnknfSBmcm9tICR7bG9nRnJvbVNvdXJjZX1gKTtcbiAgICBpZiAoZGF0YVRvQXR0YWNoID09PSBhdHRhY2hNZWRpYVNvdXJjZURhdGEpIHtcbiAgICAgIGNvbnN0IGlzQXNzZXRBdEVuZE9mU2NoZWR1bGUgPSBpc0Fzc2V0UGxheWVyICYmIHBsYXllci5hc3NldElkID09PSB0aGlzLnNjaGVkdWxlLmFzc2V0SWRBdEVuZDtcbiAgICAgIC8vIFByZXZlbnQgYXNzZXQgcGxheWVycyBmcm9tIG1hcmtpbmcgRW9TIG9uIHRyYW5zZmVycmVkIE1lZGlhU291cmNlXG4gICAgICBkYXRhVG9BdHRhY2gub3ZlcnJpZGVzID0ge1xuICAgICAgICBkdXJhdGlvbjogdGhpcy5zY2hlZHVsZS5kdXJhdGlvbixcbiAgICAgICAgZW5kT2ZTdHJlYW06ICFpc0Fzc2V0UGxheWVyIHx8IGlzQXNzZXRBdEVuZE9mU2NoZWR1bGUsXG4gICAgICAgIGN1ZVJlbW92YWw6ICFpc0Fzc2V0UGxheWVyXG4gICAgICB9O1xuICAgIH1cbiAgICBwbGF5ZXIuYXR0YWNoTWVkaWEoZGF0YVRvQXR0YWNoKTtcbiAgfVxuICBvbkludGVyc3RpdGlhbEN1ZUVudGVyKCkge1xuICAgIHRoaXMub25UaW1ldXBkYXRlKCk7XG4gIH1cbiAgLy8gU2NoZWR1bGluZyBtZXRob2RzXG4gIGNoZWNrU3RhcnQoKSB7XG4gICAgY29uc3Qgc2NoZWR1bGUgPSB0aGlzLnNjaGVkdWxlO1xuICAgIGNvbnN0IGludGVyc3RpdGlhbEV2ZW50cyA9IHNjaGVkdWxlLmV2ZW50cztcbiAgICBpZiAoIWludGVyc3RpdGlhbEV2ZW50cyB8fCB0aGlzLnBsYXliYWNrRGlzYWJsZWQgfHwgIXRoaXMubWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQ2hlY2sgYnVmZmVyZWQgdG8gcHJlLXJvbGxcbiAgICBpZiAodGhpcy5idWZmZXJlZFBvcyA9PT0gLTEpIHtcbiAgICAgIHRoaXMuYnVmZmVyZWRQb3MgPSAwO1xuICAgIH1cbiAgICAvLyBTdGFydCBzdGVwcGluZyB0aHJvdWdoIHNjaGVkdWxlIHdoZW4gcGxheWJhY2sgYmVnaW5zIGZvciB0aGUgZmlyc3QgdGltZSBhbmQgd2UgaGF2ZSBhIHByZS1yb2xsXG4gICAgY29uc3QgdGltZWxpbmVQb3MgPSB0aGlzLnRpbWVsaW5lUG9zO1xuICAgIGNvbnN0IGVmZmVjdGl2ZVBsYXlpbmdJdGVtID0gdGhpcy5lZmZlY3RpdmVQbGF5aW5nSXRlbTtcbiAgICBpZiAodGltZWxpbmVQb3MgPT09IC0xKSB7XG4gICAgICBjb25zdCBzdGFydFBvc2l0aW9uID0gdGhpcy5obHMuc3RhcnRQb3NpdGlvbjtcbiAgICAgIHRoaXMudGltZWxpbmVQb3MgPSBzdGFydFBvc2l0aW9uO1xuICAgICAgaWYgKGludGVyc3RpdGlhbEV2ZW50cy5sZW5ndGggJiYgaW50ZXJzdGl0aWFsRXZlbnRzWzBdLmN1ZS5wcmUpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBzY2hlZHVsZS5maW5kRXZlbnRJbmRleChpbnRlcnN0aXRpYWxFdmVudHNbMF0uaWRlbnRpZmllcik7XG4gICAgICAgIHRoaXMuc2V0U2NoZWR1bGVQb3NpdGlvbihpbmRleCk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0UG9zaXRpb24gPj0gMCB8fCAhdGhpcy5wcmltYXJ5TGl2ZSkge1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMudGltZWxpbmVQb3MgPSBzdGFydFBvc2l0aW9uID4gMCA/IHN0YXJ0UG9zaXRpb24gOiAwO1xuICAgICAgICBjb25zdCBpbmRleCA9IHNjaGVkdWxlLmZpbmRJdGVtSW5kZXhBdFRpbWUoc3RhcnQpO1xuICAgICAgICB0aGlzLnNldFNjaGVkdWxlUG9zaXRpb24oaW5kZXgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWZmZWN0aXZlUGxheWluZ0l0ZW0gJiYgIXRoaXMucGxheWluZ0l0ZW0pIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gc2NoZWR1bGUuZmluZEl0ZW1JbmRleChlZmZlY3RpdmVQbGF5aW5nSXRlbSk7XG4gICAgICB0aGlzLnNldFNjaGVkdWxlUG9zaXRpb24oaW5kZXgpO1xuICAgIH1cbiAgfVxuICBhZHZhbmNlQWZ0ZXJBc3NldEVuZGVkKGludGVyc3RpdGlhbCwgaW5kZXgsIGFzc2V0TGlzdEluZGV4KSB7XG4gICAgY29uc3QgbmV4dEFzc2V0SW5kZXggPSBnZXROZXh0QXNzZXRJbmRleChpbnRlcnN0aXRpYWwsIGFzc2V0TGlzdEluZGV4KTtcbiAgICBpZiAoIWludGVyc3RpdGlhbC5pc0Fzc2V0UGFzdFBsYXlvdXRMaW1pdChuZXh0QXNzZXRJbmRleCkpIHtcbiAgICAgIC8vIEFkdmFuY2UgdG8gbmV4dCBhc3NldCBsaXN0IGl0ZW1cbiAgICAgIHRoaXMuc2V0U2NoZWR1bGVQb3NpdGlvbihpbmRleCwgbmV4dEFzc2V0SW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBZHZhbmNlIHRvIG5leHQgc2NoZWR1bGUgc2VnbWVudFxuICAgICAgLy8gY2hlY2sgaWYgd2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBwcm9ncmFtXG4gICAgICBjb25zdCBzY2hlZHVsZUl0ZW1zID0gdGhpcy5zY2hlZHVsZS5pdGVtcztcbiAgICAgIGlmIChzY2hlZHVsZUl0ZW1zKSB7XG4gICAgICAgIGNvbnN0IG5leHRJbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgY29uc3Qgc2NoZWR1bGVMZW5ndGggPSBzY2hlZHVsZUl0ZW1zLmxlbmd0aDtcbiAgICAgICAgaWYgKG5leHRJbmRleCA+PSBzY2hlZHVsZUxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuc2V0U2NoZWR1bGVQb3NpdGlvbigtMSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VtcHRpb25UaW1lID0gaW50ZXJzdGl0aWFsLnJlc3VtZVRpbWU7XG4gICAgICAgIGlmICh0aGlzLnRpbWVsaW5lUG9zIDwgcmVzdW1wdGlvblRpbWUpIHtcbiAgICAgICAgICB0aGlzLnRpbWVsaW5lUG9zID0gcmVzdW1wdGlvblRpbWU7XG4gICAgICAgICAgdGhpcy5jaGVja0J1ZmZlcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0U2NoZWR1bGVQb3NpdGlvbihuZXh0SW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzZXRTY2hlZHVsZVRvQXNzZXRBdFRpbWUodGltZSwgcGxheWluZ0Fzc2V0KSB7XG4gICAgY29uc3Qgc2NoZWR1bGUgPSB0aGlzLnNjaGVkdWxlO1xuICAgIGNvbnN0IHBhcmVudElkZW50aWZpZXIgPSBwbGF5aW5nQXNzZXQucGFyZW50SWRlbnRpZmllcjtcbiAgICBjb25zdCBpbnRlcnN0aXRpYWwgPSBzY2hlZHVsZS5nZXRFdmVudChwYXJlbnRJZGVudGlmaWVyKTtcbiAgICBpZiAoaW50ZXJzdGl0aWFsKSB7XG4gICAgICBjb25zdCBpdGVtSW5kZXggPSBzY2hlZHVsZS5maW5kRXZlbnRJbmRleChwYXJlbnRJZGVudGlmaWVyKTtcbiAgICAgIGNvbnN0IGFzc2V0TGlzdEluZGV4ID0gc2NoZWR1bGUuZmluZEFzc2V0SW5kZXgoaW50ZXJzdGl0aWFsLCB0aW1lKTtcbiAgICAgIHRoaXMuYWR2YW5jZUFmdGVyQXNzZXRFbmRlZChpbnRlcnN0aXRpYWwsIGl0ZW1JbmRleCwgYXNzZXRMaXN0SW5kZXggLSAxKTtcbiAgICB9XG4gIH1cbiAgc2V0U2NoZWR1bGVQb3NpdGlvbihpbmRleCwgYXNzZXRMaXN0SW5kZXgpIHtcbiAgICBjb25zdCBzY2hlZHVsZUl0ZW1zID0gdGhpcy5zY2hlZHVsZS5pdGVtcztcbiAgICBpZiAoIXNjaGVkdWxlSXRlbXMgfHwgdGhpcy5wbGF5YmFja0Rpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubG9nKGBzZXRTY2hlZHVsZVBvc2l0aW9uICR7aW5kZXh9LCAke2Fzc2V0TGlzdEluZGV4fWApO1xuICAgIGNvbnN0IHNjaGVkdWxlZEl0ZW0gPSBpbmRleCA+PSAwID8gc2NoZWR1bGVJdGVtc1tpbmRleF0gOiBudWxsO1xuICAgIC8vIENsZWFudXAgY3VycmVudCBpdGVtIC8gYXNzZXRcbiAgICBjb25zdCBjdXJyZW50SXRlbSA9IHRoaXMucGxheWluZ0l0ZW07XG4gICAgY29uc3QgcGxheWluZ0xhc3RJdGVtID0gdGhpcy5wbGF5aW5nTGFzdEl0ZW07XG4gICAgaWYgKHRoaXMuaXNJbnRlcnN0aXRpYWwoY3VycmVudEl0ZW0pKSB7XG4gICAgICB2YXIgX2ludGVyc3RpdGlhbCRhc3NldExpO1xuICAgICAgY29uc3QgaW50ZXJzdGl0aWFsID0gY3VycmVudEl0ZW0uZXZlbnQ7XG4gICAgICBjb25zdCBwbGF5aW5nQXNzZXQgPSB0aGlzLnBsYXlpbmdBc3NldDtcbiAgICAgIGNvbnN0IGFzc2V0SWQgPSBwbGF5aW5nQXNzZXQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXlpbmdBc3NldC5pZGVudGlmaWVyO1xuICAgICAgY29uc3QgcGxheWVyID0gYXNzZXRJZCA/IHRoaXMuZ2V0QXNzZXRQbGF5ZXIoYXNzZXRJZCkgOiBudWxsO1xuICAgICAgaWYgKHBsYXllciAmJiBhc3NldElkICYmICghdGhpcy5ldmVudEl0ZW1zTWF0Y2goY3VycmVudEl0ZW0sIHNjaGVkdWxlZEl0ZW0pIHx8IGFzc2V0TGlzdEluZGV4ICE9PSB1bmRlZmluZWQgJiYgYXNzZXRJZCAhPT0gKChfaW50ZXJzdGl0aWFsJGFzc2V0TGkgPSBpbnRlcnN0aXRpYWwuYXNzZXRMaXN0KSA9PSBudWxsID8gdm9pZCAwIDogX2ludGVyc3RpdGlhbCRhc3NldExpW2Fzc2V0TGlzdEluZGV4XS5pZGVudGlmaWVyKSkpIHtcbiAgICAgICAgdmFyIF90aGlzJGRldGFjaGVkRGF0YTM7XG4gICAgICAgIGNvbnN0IHBsYXlpbmdBc3NldExpc3RJbmRleCA9IGludGVyc3RpdGlhbC5maW5kQXNzZXRJbmRleChwbGF5aW5nQXNzZXQpO1xuICAgICAgICB0aGlzLmxvZyhgSU5URVJTVElUSUFMX0FTU0VUX0VOREVEICR7cGxheWluZ0Fzc2V0TGlzdEluZGV4ICsgMX0vJHtpbnRlcnN0aXRpYWwuYXNzZXRMaXN0Lmxlbmd0aH0gJHtldmVudEFzc2V0VG9TdHJpbmcocGxheWluZ0Fzc2V0KX1gKTtcbiAgICAgICAgdGhpcy5lbmRlZEFzc2V0ID0gcGxheWluZ0Fzc2V0O1xuICAgICAgICB0aGlzLnBsYXlpbmdBc3NldCA9IG51bGw7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLklOVEVSU1RJVElBTF9BU1NFVF9FTkRFRCwge1xuICAgICAgICAgIGFzc2V0OiBwbGF5aW5nQXNzZXQsXG4gICAgICAgICAgYXNzZXRMaXN0SW5kZXg6IHBsYXlpbmdBc3NldExpc3RJbmRleCxcbiAgICAgICAgICBldmVudDogaW50ZXJzdGl0aWFsLFxuICAgICAgICAgIHNjaGVkdWxlOiBzY2hlZHVsZUl0ZW1zLnNsaWNlKDApLFxuICAgICAgICAgIHNjaGVkdWxlSW5kZXg6IGluZGV4LFxuICAgICAgICAgIHBsYXllclxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGN1cnJlbnRJdGVtICE9PSB0aGlzLnBsYXlpbmdJdGVtKSB7XG4gICAgICAgICAgLy8gU2NoZWR1bGUgY2hhbmdlIG9jY3VyZWQgb24gSU5URVJTVElUSUFMX0FTU0VUX0VOREVEXG4gICAgICAgICAgaWYgKHRoaXMuaXRlbXNNYXRjaChjdXJyZW50SXRlbSwgdGhpcy5wbGF5aW5nSXRlbSkgJiYgIXRoaXMucGxheWluZ0Fzc2V0KSB7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2VBZnRlckFzc2V0RW5kZWQoaW50ZXJzdGl0aWFsLCB0aGlzLmZpbmRJdGVtSW5kZXgodGhpcy5wbGF5aW5nSXRlbSksIHBsYXlpbmdBc3NldExpc3RJbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE5hdmlnYXRpb24gb2NjdXJlZCBvbiBJTlRFUlNUSVRJQUxfQVNTRVRfRU5ERURcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXRyZWl2ZU1lZGlhU291cmNlKGFzc2V0SWQsIHNjaGVkdWxlZEl0ZW0pO1xuICAgICAgICBpZiAocGxheWVyLm1lZGlhICYmICEoKF90aGlzJGRldGFjaGVkRGF0YTMgPSB0aGlzLmRldGFjaGVkRGF0YSkgIT0gbnVsbCAmJiBfdGhpcyRkZXRhY2hlZERhdGEzLm1lZGlhU291cmNlKSkge1xuICAgICAgICAgIHBsYXllci5kZXRhY2hNZWRpYSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuZXZlbnRJdGVtc01hdGNoKGN1cnJlbnRJdGVtLCBzY2hlZHVsZWRJdGVtKSkge1xuICAgICAgICB0aGlzLmVuZGVkSXRlbSA9IGN1cnJlbnRJdGVtO1xuICAgICAgICB0aGlzLnBsYXlpbmdJdGVtID0gbnVsbDtcbiAgICAgICAgdGhpcy5sb2coYElOVEVSU1RJVElBTF9FTkRFRCAke2ludGVyc3RpdGlhbH0gJHtzZWdtZW50VG9TdHJpbmcoY3VycmVudEl0ZW0pfWApO1xuICAgICAgICBpbnRlcnN0aXRpYWwuaGFzUGxheWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuSU5URVJTVElUSUFMX0VOREVELCB7XG4gICAgICAgICAgZXZlbnQ6IGludGVyc3RpdGlhbCxcbiAgICAgICAgICBzY2hlZHVsZTogc2NoZWR1bGVJdGVtcy5zbGljZSgwKSxcbiAgICAgICAgICBzY2hlZHVsZUluZGV4OiBpbmRleFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gRXhpdGluZyBhbiBJbnRlcnN0aXRpYWxcbiAgICAgICAgaWYgKGludGVyc3RpdGlhbC5jdWUub25jZSkge1xuICAgICAgICAgIC8vIFJlbW92ZSBpbnRlcnN0aXRpYWwgd2l0aCBDVUUgYXR0cmlidXRlIHZhbHVlIG9mIE9OQ0UgYWZ0ZXIgaXQgaGFzIHBsYXllZFxuICAgICAgICAgIHRoaXMudXBkYXRlU2NoZWR1bGUoKTtcbiAgICAgICAgICBjb25zdCBpdGVtcyA9IHRoaXMuc2NoZWR1bGUuaXRlbXM7XG4gICAgICAgICAgaWYgKHNjaGVkdWxlZEl0ZW0gJiYgaXRlbXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRJbmRleCA9IHRoaXMuZmluZEl0ZW1JbmRleChzY2hlZHVsZWRJdGVtKTtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZVNjaGVkdWxlKHVwZGF0ZWRJbmRleCwgaXRlbXMsIGFzc2V0TGlzdEluZGV4LCBjdXJyZW50SXRlbSwgcGxheWluZ0xhc3RJdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYWR2YW5jZVNjaGVkdWxlKGluZGV4LCBzY2hlZHVsZUl0ZW1zLCBhc3NldExpc3RJbmRleCwgY3VycmVudEl0ZW0sIHBsYXlpbmdMYXN0SXRlbSk7XG4gIH1cbiAgYWR2YW5jZVNjaGVkdWxlKGluZGV4LCBzY2hlZHVsZUl0ZW1zLCBhc3NldExpc3RJbmRleCwgY3VycmVudEl0ZW0sIHBsYXllZExhc3RJdGVtKSB7XG4gICAgY29uc3Qgc2NoZWR1bGVkSXRlbSA9IGluZGV4ID49IDAgPyBzY2hlZHVsZUl0ZW1zW2luZGV4XSA6IG51bGw7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLnByaW1hcnlNZWRpYTtcbiAgICAvLyBDbGVhbnVwIG91dCBvZiByYW5nZSBJbnRlcnN0aXRpYWxzXG4gICAgY29uc3QgcGxheWVyUXVldWUgPSB0aGlzLnBsYXllclF1ZXVlO1xuICAgIGlmIChwbGF5ZXJRdWV1ZS5sZW5ndGgpIHtcbiAgICAgIHBsYXllclF1ZXVlLmZvckVhY2gocGxheWVyID0+IHtcbiAgICAgICAgY29uc3QgaW50ZXJzdGl0aWFsID0gcGxheWVyLmludGVyc3RpdGlhbDtcbiAgICAgICAgY29uc3QgcXVldWVkSW5kZXggPSB0aGlzLnNjaGVkdWxlLmZpbmRFdmVudEluZGV4KGludGVyc3RpdGlhbC5pZGVudGlmaWVyKTtcbiAgICAgICAgaWYgKHF1ZXVlZEluZGV4IDwgaW5kZXggfHwgcXVldWVkSW5kZXggPiBpbmRleCArIDEpIHtcbiAgICAgICAgICB0aGlzLmNsZWFySW50ZXJzdGl0aWFsKGludGVyc3RpdGlhbCwgc2NoZWR1bGVkSXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBTZXR1cCBzY2hlZHVsZWQgaXRlbVxuICAgIGlmICh0aGlzLmlzSW50ZXJzdGl0aWFsKHNjaGVkdWxlZEl0ZW0pKSB7XG4gICAgICB0aGlzLnRpbWVsaW5lUG9zID0gTWF0aC5taW4oTWF0aC5tYXgodGhpcy50aW1lbGluZVBvcywgc2NoZWR1bGVkSXRlbS5zdGFydCksIHNjaGVkdWxlZEl0ZW0uZW5kKTtcbiAgICAgIC8vIEhhbmRsZSBJbnRlcnN0aXRpYWxcbiAgICAgIGNvbnN0IGludGVyc3RpdGlhbCA9IHNjaGVkdWxlZEl0ZW0uZXZlbnQ7XG4gICAgICAvLyBmaW5kIGFzc2V0IGluZGV4XG4gICAgICBpZiAoYXNzZXRMaXN0SW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhc3NldExpc3RJbmRleCA9IHRoaXMuc2NoZWR1bGUuZmluZEFzc2V0SW5kZXgoaW50ZXJzdGl0aWFsLCB0aGlzLnRpbWVsaW5lUG9zKTtcbiAgICAgICAgY29uc3QgYXNzZXRJbmRleENhbmRpZGF0ZSA9IGdldE5leHRBc3NldEluZGV4KGludGVyc3RpdGlhbCwgYXNzZXRMaXN0SW5kZXggLSAxKTtcbiAgICAgICAgaWYgKGludGVyc3RpdGlhbC5pc0Fzc2V0UGFzdFBsYXlvdXRMaW1pdChhc3NldEluZGV4Q2FuZGlkYXRlKSkge1xuICAgICAgICAgIHRoaXMuYWR2YW5jZUFmdGVyQXNzZXRFbmRlZChpbnRlcnN0aXRpYWwsIGluZGV4LCBhc3NldExpc3RJbmRleCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGFzc2V0TGlzdEluZGV4ID0gYXNzZXRJbmRleENhbmRpZGF0ZTtcbiAgICAgIH1cbiAgICAgIC8vIEVuc3VyZSBJbnRlcnN0aXRpYWwgaXMgZW5xdWV1ZWRcbiAgICAgIGNvbnN0IHdhaXRpbmdJdGVtID0gdGhpcy53YWl0aW5nSXRlbTtcbiAgICAgIGlmICghdGhpcy5hc3NldHNCdWZmZXJlZChzY2hlZHVsZWRJdGVtLCBtZWRpYSkpIHtcbiAgICAgICAgdGhpcy5zZXRCdWZmZXJpbmdJdGVtKHNjaGVkdWxlZEl0ZW0pO1xuICAgICAgfVxuICAgICAgbGV0IHBsYXllciA9IHRoaXMucHJlbG9hZEFzc2V0cyhpbnRlcnN0aXRpYWwsIGFzc2V0TGlzdEluZGV4KTtcbiAgICAgIGlmICghdGhpcy5ldmVudEl0ZW1zTWF0Y2goc2NoZWR1bGVkSXRlbSwgd2FpdGluZ0l0ZW0gfHwgY3VycmVudEl0ZW0pKSB7XG4gICAgICAgIHRoaXMud2FpdGluZ0l0ZW0gPSBzY2hlZHVsZWRJdGVtO1xuICAgICAgICB0aGlzLmxvZyhgSU5URVJTVElUSUFMX1NUQVJURUQgJHtzZWdtZW50VG9TdHJpbmcoc2NoZWR1bGVkSXRlbSl9ICR7aW50ZXJzdGl0aWFsLmFwcGVuZEluUGxhY2UgPyAnYXBwZW5kIGluIHBsYWNlJyA6ICcnfWApO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5JTlRFUlNUSVRJQUxfU1RBUlRFRCwge1xuICAgICAgICAgIGV2ZW50OiBpbnRlcnN0aXRpYWwsXG4gICAgICAgICAgc2NoZWR1bGU6IHNjaGVkdWxlSXRlbXMuc2xpY2UoMCksXG4gICAgICAgICAgc2NoZWR1bGVJbmRleDogaW5kZXhcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIWludGVyc3RpdGlhbC5hc3NldExpc3RMb2FkZWQpIHtcbiAgICAgICAgLy8gV2FpdGluZyBhdCBlbmQgb2YgcHJpbWFyeSBjb250ZW50IHNlZ21lbnRcbiAgICAgICAgLy8gRXhwZWN0IHNldFNjaGVkdWxlUG9zaXRpb24gdG8gYmUgY2FsbGVkIGFnYWluIG9uY2UgQVNTRVQtTElTVCBpcyBsb2FkZWRcbiAgICAgICAgdGhpcy5sb2coYFdhaXRpbmcgZm9yIEFTU0VULUxJU1QgdG8gY29tcGxldGUgbG9hZGluZyAke2ludGVyc3RpdGlhbH1gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGludGVyc3RpdGlhbC5hc3NldExpc3RMb2FkZXIpIHtcbiAgICAgICAgaW50ZXJzdGl0aWFsLmFzc2V0TGlzdExvYWRlci5kZXN0cm95KCk7XG4gICAgICAgIGludGVyc3RpdGlhbC5hc3NldExpc3RMb2FkZXIgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoIW1lZGlhKSB7XG4gICAgICAgIHRoaXMubG9nKGBXYWl0aW5nIGZvciBhdHRhY2hNZWRpYSB0byBzdGFydCBJbnRlcnN0aXRpYWwgJHtpbnRlcnN0aXRpYWx9YCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFVwZGF0ZSBzY2hlZHVsZSBhbmQgYXNzZXQgbGlzdCBwb3NpdGlvbiBub3cgdGhhdCBpdCBjYW4gc3RhcnRcbiAgICAgIHRoaXMud2FpdGluZ0l0ZW0gPSB0aGlzLmVuZGVkSXRlbSA9IG51bGw7XG4gICAgICB0aGlzLnBsYXlpbmdJdGVtID0gc2NoZWR1bGVkSXRlbTtcblxuICAgICAgLy8gSWYgYXNzZXQtbGlzdCBpcyBlbXB0eSBvciBtaXNzaW5nIGFzc2V0IGluZGV4LCBhZHZhbmNlIHRvIG5leHQgaXRlbVxuICAgICAgY29uc3QgYXNzZXRJdGVtID0gaW50ZXJzdGl0aWFsLmFzc2V0TGlzdFthc3NldExpc3RJbmRleF07XG4gICAgICBpZiAoIWFzc2V0SXRlbSkge1xuICAgICAgICBjb25zdCBuZXh0SXRlbSA9IHNjaGVkdWxlSXRlbXNbaW5kZXggKyAxXTtcbiAgICAgICAgY29uc3QgX21lZGlhMiA9IHRoaXMubWVkaWE7XG4gICAgICAgIGlmIChuZXh0SXRlbSAmJiBfbWVkaWEyICYmICF0aGlzLmlzSW50ZXJzdGl0aWFsKG5leHRJdGVtKSAmJiBfbWVkaWEyLmN1cnJlbnRUaW1lIDwgbmV4dEl0ZW0uc3RhcnQpIHtcbiAgICAgICAgICBfbWVkaWEyLmN1cnJlbnRUaW1lID0gdGhpcy50aW1lbGluZVBvcyA9IG5leHRJdGVtLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWR2YW5jZUFmdGVyQXNzZXRFbmRlZChpbnRlcnN0aXRpYWwsIGluZGV4LCBhc3NldExpc3RJbmRleCB8fCAwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBTdGFydCBJbnRlcnN0aXRpYWwgUGxheWJhY2tcbiAgICAgIGlmICghcGxheWVyKSB7XG4gICAgICAgIHBsYXllciA9IHRoaXMuZ2V0QXNzZXRQbGF5ZXIoYXNzZXRJdGVtLmlkZW50aWZpZXIpO1xuICAgICAgfVxuICAgICAgaWYgKHBsYXllciA9PT0gbnVsbCB8fCBwbGF5ZXIuZGVzdHJveWVkKSB7XG4gICAgICAgIGNvbnN0IGFzc2V0TGlzdExlbmd0aCA9IGludGVyc3RpdGlhbC5hc3NldExpc3QubGVuZ3RoO1xuICAgICAgICB0aGlzLndhcm4oYGFzc2V0ICR7YXNzZXRMaXN0SW5kZXggKyAxfS8ke2Fzc2V0TGlzdExlbmd0aH0gcGxheWVyIGRlc3Ryb3llZCAke2ludGVyc3RpdGlhbH1gKTtcbiAgICAgICAgcGxheWVyID0gdGhpcy5jcmVhdGVBc3NldFBsYXllcihpbnRlcnN0aXRpYWwsIGFzc2V0SXRlbSwgYXNzZXRMaXN0SW5kZXgpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmV2ZW50SXRlbXNNYXRjaChzY2hlZHVsZWRJdGVtLCB0aGlzLmJ1ZmZlcmluZ0l0ZW0pKSB7XG4gICAgICAgIGlmIChpbnRlcnN0aXRpYWwuYXBwZW5kSW5QbGFjZSAmJiB0aGlzLmlzQXNzZXRCdWZmZXJlZChhc3NldEl0ZW0pKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXJ0QXNzZXRQbGF5ZXIocGxheWVyLCBhc3NldExpc3RJbmRleCwgc2NoZWR1bGVJdGVtcywgaW5kZXgsIG1lZGlhKTtcbiAgICAgIGlmICh0aGlzLnNob3VsZFBsYXkpIHtcbiAgICAgICAgcGxheVdpdGhDYXRjaChwbGF5ZXIubWVkaWEpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2NoZWR1bGVkSXRlbSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5yZXN1bWVQcmltYXJ5KHNjaGVkdWxlZEl0ZW0sIGluZGV4LCBjdXJyZW50SXRlbSk7XG4gICAgICBpZiAodGhpcy5zaG91bGRQbGF5KSB7XG4gICAgICAgIHBsYXlXaXRoQ2F0Y2godGhpcy5obHMubWVkaWEpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGxheWVkTGFzdEl0ZW0gJiYgdGhpcy5pc0ludGVyc3RpdGlhbChjdXJyZW50SXRlbSkpIHtcbiAgICAgIC8vIE1haW50YWluIHBsYXlpbmdJdGVtIHN0YXRlIGF0IGVuZCBvZiBzY2hlZHVsZSAoc2V0U2NoZWR1bGVQb3NpdGlvbigtMSkgY2FsbGVkIHRvIGVuZCBwcm9ncmFtKVxuICAgICAgLy8gdGhpcyBhbGxvd3Mgb25TZWVraW5nIGhhbmRsZXIgdG8gdXBkYXRlIHNjaGVkdWxlIHBvc2l0aW9uXG4gICAgICB0aGlzLmVuZGVkSXRlbSA9IG51bGw7XG4gICAgICB0aGlzLnBsYXlpbmdJdGVtID0gY3VycmVudEl0ZW07XG4gICAgICBpZiAoIWN1cnJlbnRJdGVtLmV2ZW50LmFwcGVuZEluUGxhY2UpIHtcbiAgICAgICAgLy8gTWVkaWEgbXVzdCBiZSByZS1hdHRhY2hlZCB0byByZXN1bWUgcHJpbWFyeSBzY2hlZHVsZSBpZiBub3Qgc2hhcmluZyBzb3VyY2VcbiAgICAgICAgdGhpcy5hdHRhY2hQcmltYXJ5KHRoaXMuc2NoZWR1bGUuZHVyYXRpb25zLnByaW1hcnksIG51bGwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgcGxheWJhY2tEaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5obHMuY29uZmlnLmVuYWJsZUludGVyc3RpdGlhbFBsYXliYWNrID09PSBmYWxzZTtcbiAgfVxuICBnZXQgcHJpbWFyeURldGFpbHMoKSB7XG4gICAgdmFyIF90aGlzJG1lZGlhU2VsZWN0aW9uLCBfdGhpcyRtZWRpYVNlbGVjdGlvbiQ7XG4gICAgcmV0dXJuIChfdGhpcyRtZWRpYVNlbGVjdGlvbiA9IHRoaXMubWVkaWFTZWxlY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiAoX3RoaXMkbWVkaWFTZWxlY3Rpb24kID0gX3RoaXMkbWVkaWFTZWxlY3Rpb24ubWFpbikgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG1lZGlhU2VsZWN0aW9uJC5kZXRhaWxzO1xuICB9XG4gIGdldCBwcmltYXJ5TGl2ZSgpIHtcbiAgICB2YXIgX3RoaXMkcHJpbWFyeURldGFpbHM7XG4gICAgcmV0dXJuICEhKChfdGhpcyRwcmltYXJ5RGV0YWlscyA9IHRoaXMucHJpbWFyeURldGFpbHMpICE9IG51bGwgJiYgX3RoaXMkcHJpbWFyeURldGFpbHMubGl2ZSk7XG4gIH1cbiAgcmVzdW1lUHJpbWFyeShzY2hlZHVsZWRJdGVtLCBpbmRleCwgZnJvbUl0ZW0pIHtcbiAgICB2YXIgX3RoaXMkZGV0YWNoZWREYXRhNDtcbiAgICB0aGlzLnBsYXlpbmdJdGVtID0gc2NoZWR1bGVkSXRlbTtcbiAgICB0aGlzLnBsYXlpbmdBc3NldCA9IHRoaXMuZW5kZWRBc3NldCA9IG51bGw7XG4gICAgdGhpcy53YWl0aW5nSXRlbSA9IHRoaXMuZW5kZWRJdGVtID0gbnVsbDtcbiAgICB0aGlzLmJ1ZmZlcmVkVG9JdGVtKHNjaGVkdWxlZEl0ZW0pO1xuICAgIHRoaXMubG9nKGByZXN1bWluZyAke3NlZ21lbnRUb1N0cmluZyhzY2hlZHVsZWRJdGVtKX1gKTtcbiAgICBpZiAoISgoX3RoaXMkZGV0YWNoZWREYXRhNCA9IHRoaXMuZGV0YWNoZWREYXRhKSAhPSBudWxsICYmIF90aGlzJGRldGFjaGVkRGF0YTQubWVkaWFTb3VyY2UpKSB7XG4gICAgICBsZXQgdGltZWxpbmVQb3MgPSB0aGlzLnRpbWVsaW5lUG9zO1xuICAgICAgaWYgKHRpbWVsaW5lUG9zIDwgc2NoZWR1bGVkSXRlbS5zdGFydCB8fCB0aW1lbGluZVBvcyA+PSBzY2hlZHVsZWRJdGVtLmVuZCkge1xuICAgICAgICB0aW1lbGluZVBvcyA9IHRoaXMuZ2V0UHJpbWFyeVJlc3VtcHRpb24oc2NoZWR1bGVkSXRlbSwgaW5kZXgpO1xuICAgICAgICB0aGlzLnRpbWVsaW5lUG9zID0gdGltZWxpbmVQb3M7XG4gICAgICB9XG4gICAgICB0aGlzLmF0dGFjaFByaW1hcnkodGltZWxpbmVQb3MsIHNjaGVkdWxlZEl0ZW0pO1xuICAgIH1cbiAgICBpZiAoIWZyb21JdGVtKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNjaGVkdWxlSXRlbXMgPSB0aGlzLnNjaGVkdWxlLml0ZW1zO1xuICAgIGlmICghc2NoZWR1bGVJdGVtcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxvZyhgSU5URVJTVElUSUFMU19QUklNQVJZX1JFU1VNRUQgJHtzZWdtZW50VG9TdHJpbmcoc2NoZWR1bGVkSXRlbSl9YCk7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuSU5URVJTVElUSUFMU19QUklNQVJZX1JFU1VNRUQsIHtcbiAgICAgIHNjaGVkdWxlOiBzY2hlZHVsZUl0ZW1zLnNsaWNlKDApLFxuICAgICAgc2NoZWR1bGVJbmRleDogaW5kZXhcbiAgICB9KTtcbiAgICB0aGlzLmNoZWNrQnVmZmVyKCk7XG4gIH1cbiAgZ2V0UHJpbWFyeVJlc3VtcHRpb24oc2NoZWR1bGVkSXRlbSwgaW5kZXgpIHtcbiAgICBjb25zdCBpdGVtU3RhcnQgPSBzY2hlZHVsZWRJdGVtLnN0YXJ0O1xuICAgIGlmICh0aGlzLnByaW1hcnlMaXZlKSB7XG4gICAgICBjb25zdCBkZXRhaWxzID0gdGhpcy5wcmltYXJ5RGV0YWlscztcbiAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5obHMuc3RhcnRQb3NpdGlvbjtcbiAgICAgIH0gZWxzZSBpZiAoZGV0YWlscyAmJiAoaXRlbVN0YXJ0IDwgZGV0YWlscy5mcmFnbWVudFN0YXJ0IHx8IGl0ZW1TdGFydCA+IGRldGFpbHMuZWRnZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGxzLmxpdmVTeW5jUG9zaXRpb24gfHwgLTE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpdGVtU3RhcnQ7XG4gIH1cbiAgaXNBc3NldEJ1ZmZlcmVkKGFzc2V0KSB7XG4gICAgY29uc3QgcGxheWVyID0gdGhpcy5nZXRBc3NldFBsYXllcihhc3NldC5pZGVudGlmaWVyKTtcbiAgICBpZiAocGxheWVyICE9IG51bGwgJiYgcGxheWVyLmhscykge1xuICAgICAgcmV0dXJuIHBsYXllci5obHMuYnVmZmVyZWRUb0VuZDtcbiAgICB9XG4gICAgY29uc3QgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKHRoaXMucHJpbWFyeU1lZGlhLCB0aGlzLnRpbWVsaW5lUG9zLCAwKTtcbiAgICByZXR1cm4gYnVmZmVySW5mby5lbmQgKyAxID49IGFzc2V0LnRpbWVsaW5lU3RhcnQgKyAoYXNzZXQuZHVyYXRpb24gfHwgMCk7XG4gIH1cbiAgYXR0YWNoUHJpbWFyeSh0aW1lbGluZVBvcywgaXRlbSwgc2tpcFNlZWtUb1N0YXJ0UG9zaXRpb24pIHtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgdGhpcy5zZXRCdWZmZXJpbmdJdGVtKGl0ZW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJ1ZmZlcmluZ0l0ZW0gPSB0aGlzLnBsYXlpbmdJdGVtO1xuICAgIH1cbiAgICB0aGlzLmJ1ZmZlcmluZ0Fzc2V0ID0gbnVsbDtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMucHJpbWFyeU1lZGlhO1xuICAgIGlmICghbWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgaWYgKGhscy5tZWRpYSkge1xuICAgICAgdGhpcy5jaGVja0J1ZmZlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRyYW5zZmVyTWVkaWFUbyhobHMsIG1lZGlhKTtcbiAgICAgIGlmIChza2lwU2Vla1RvU3RhcnRQb3NpdGlvbikge1xuICAgICAgICB0aGlzLnN0YXJ0TG9hZGluZ1ByaW1hcnlBdCh0aW1lbGluZVBvcywgc2tpcFNlZWtUb1N0YXJ0UG9zaXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXNraXBTZWVrVG9TdGFydFBvc2l0aW9uKSB7XG4gICAgICAvLyBTZXQgcHJpbWFyeSBwb3NpdGlvbiB0byByZXN1bWUgdGltZVxuICAgICAgdGhpcy50aW1lbGluZVBvcyA9IHRpbWVsaW5lUG9zO1xuICAgICAgdGhpcy5zdGFydExvYWRpbmdQcmltYXJ5QXQodGltZWxpbmVQb3MsIHNraXBTZWVrVG9TdGFydFBvc2l0aW9uKTtcbiAgICB9XG4gIH1cbiAgc3RhcnRMb2FkaW5nUHJpbWFyeUF0KHRpbWVsaW5lUG9zLCBza2lwU2Vla1RvU3RhcnRQb3NpdGlvbikge1xuICAgIHZhciBfaGxzJG1haW5Gb3J3YXJkQnVmZmU7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgaWYgKCFobHMubG9hZGluZ0VuYWJsZWQgfHwgIWhscy5tZWRpYSB8fCBNYXRoLmFicygoKChfaGxzJG1haW5Gb3J3YXJkQnVmZmUgPSBobHMubWFpbkZvcndhcmRCdWZmZXJJbmZvKSA9PSBudWxsID8gdm9pZCAwIDogX2hscyRtYWluRm9yd2FyZEJ1ZmZlLnN0YXJ0KSB8fCBobHMubWVkaWEuY3VycmVudFRpbWUpIC0gdGltZWxpbmVQb3MpID4gMC41KSB7XG4gICAgICBobHMuc3RhcnRMb2FkKHRpbWVsaW5lUG9zLCBza2lwU2Vla1RvU3RhcnRQb3NpdGlvbik7XG4gICAgfSBlbHNlIGlmICghaGxzLmJ1ZmZlcmluZ0VuYWJsZWQpIHtcbiAgICAgIGhscy5yZXN1bWVCdWZmZXJpbmcoKTtcbiAgICB9XG4gIH1cblxuICAvLyBITFMuanMgZXZlbnQgY2FsbGJhY2tzXG4gIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICB0aGlzLnNjaGVkdWxlLnJlc2V0KCk7XG4gICAgdGhpcy5lbXB0eVBsYXllclF1ZXVlKCk7XG4gICAgdGhpcy5jbGVhclNjaGVkdWxlU3RhdGUoKTtcbiAgICB0aGlzLnNob3VsZFBsYXkgPSBmYWxzZTtcbiAgICB0aGlzLmJ1ZmZlcmVkUG9zID0gdGhpcy50aW1lbGluZVBvcyA9IC0xO1xuICAgIHRoaXMubWVkaWFTZWxlY3Rpb24gPSB0aGlzLmFsdFNlbGVjdGlvbiA9IHRoaXMubWFuYWdlciA9IHRoaXMucmVxdWlyZWRUcmFja3MgPSBudWxsO1xuICAgIC8vIEJVRkZFUl9DT0RFQ1MgbGlzdGVuZXIgYWRkZWQgaGVyZSBmb3IgYnVmZmVyLWNvbnRyb2xsZXIgdG8gaGFuZGxlIGl0IGZpcnN0IHdoZXJlIGl0IGFkZHMgdHJhY2tzXG4gICAgdGhpcy5obHMub2ZmKEV2ZW50cy5CVUZGRVJfQ09ERUNTLCB0aGlzLm9uQnVmZmVyQ29kZWNzLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vbihFdmVudHMuQlVGRkVSX0NPREVDUywgdGhpcy5vbkJ1ZmZlckNvZGVjcywgdGhpcyk7XG4gIH1cbiAgb25MZXZlbFVwZGF0ZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBpZiAoZGF0YS5sZXZlbCA9PT0gLTEpIHtcbiAgICAgIC8vIGxldmVsIHdhcyByZW1vdmVkXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1haW4gPSB0aGlzLmhscy5sZXZlbHNbZGF0YS5sZXZlbF07XG4gICAgY29uc3QgY3VycmVudFNlbGVjdGlvbiA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCB0aGlzLm1lZGlhU2VsZWN0aW9uIHx8IHRoaXMuYWx0U2VsZWN0aW9uKSwge30sIHtcbiAgICAgIG1haW5cbiAgICB9KTtcbiAgICB0aGlzLm1lZGlhU2VsZWN0aW9uID0gY3VycmVudFNlbGVjdGlvbjtcbiAgICB0aGlzLnNjaGVkdWxlLnBhcnNlSW50ZXJzdGl0aWFsRGF0ZVJhbmdlcyhjdXJyZW50U2VsZWN0aW9uLCB0aGlzLmhscy5jb25maWcuaW50ZXJzdGl0aWFsQXBwZW5kSW5QbGFjZSk7XG4gICAgaWYgKCF0aGlzLmVmZmVjdGl2ZVBsYXlpbmdJdGVtICYmIHRoaXMuc2NoZWR1bGUuaXRlbXMpIHtcbiAgICAgIHRoaXMuY2hlY2tTdGFydCgpO1xuICAgIH1cbiAgfVxuICBvbkF1ZGlvVHJhY2tVcGRhdGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3QgYXVkaW8gPSB0aGlzLmhscy5hdWRpb1RyYWNrc1tkYXRhLmlkXTtcbiAgICBjb25zdCBwcmV2aW91c1NlbGVjdGlvbiA9IHRoaXMubWVkaWFTZWxlY3Rpb247XG4gICAgaWYgKCFwcmV2aW91c1NlbGVjdGlvbikge1xuICAgICAgdGhpcy5hbHRTZWxlY3Rpb24gPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgdGhpcy5hbHRTZWxlY3Rpb24pLCB7fSwge1xuICAgICAgICBhdWRpb1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRTZWxlY3Rpb24gPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgcHJldmlvdXNTZWxlY3Rpb24pLCB7fSwge1xuICAgICAgYXVkaW9cbiAgICB9KTtcbiAgICB0aGlzLm1lZGlhU2VsZWN0aW9uID0gY3VycmVudFNlbGVjdGlvbjtcbiAgfVxuICBvblN1YnRpdGxlVHJhY2tVcGRhdGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qgc3VidGl0bGVzID0gdGhpcy5obHMuc3VidGl0bGVUcmFja3NbZGF0YS5pZF07XG4gICAgY29uc3QgcHJldmlvdXNTZWxlY3Rpb24gPSB0aGlzLm1lZGlhU2VsZWN0aW9uO1xuICAgIGlmICghcHJldmlvdXNTZWxlY3Rpb24pIHtcbiAgICAgIHRoaXMuYWx0U2VsZWN0aW9uID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHRoaXMuYWx0U2VsZWN0aW9uKSwge30sIHtcbiAgICAgICAgc3VidGl0bGVzXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFNlbGVjdGlvbiA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBwcmV2aW91c1NlbGVjdGlvbiksIHt9LCB7XG4gICAgICBzdWJ0aXRsZXNcbiAgICB9KTtcbiAgICB0aGlzLm1lZGlhU2VsZWN0aW9uID0gY3VycmVudFNlbGVjdGlvbjtcbiAgfVxuICBvbkF1ZGlvVHJhY2tTd2l0Y2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCBhdWRpb09wdGlvbiA9IGdldEJhc2ljU2VsZWN0aW9uT3B0aW9uKGRhdGEpO1xuICAgIHRoaXMucGxheWVyUXVldWUuZm9yRWFjaChwbGF5ZXIgPT4gcGxheWVyLmhscy5zZXRBdWRpb09wdGlvbihkYXRhKSB8fCBwbGF5ZXIuaGxzLnNldEF1ZGlvT3B0aW9uKGF1ZGlvT3B0aW9uKSk7XG4gIH1cbiAgb25TdWJ0aXRsZVRyYWNrU3dpdGNoKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qgc3VidGl0bGVPcHRpb24gPSBnZXRCYXNpY1NlbGVjdGlvbk9wdGlvbihkYXRhKTtcbiAgICB0aGlzLnBsYXllclF1ZXVlLmZvckVhY2gocGxheWVyID0+IHBsYXllci5obHMuc2V0U3VidGl0bGVPcHRpb24oZGF0YSkgfHwgZGF0YS5pZCAhPT0gLTEgJiYgcGxheWVyLmhscy5zZXRTdWJ0aXRsZU9wdGlvbihzdWJ0aXRsZU9wdGlvbikpO1xuICB9XG4gIG9uQnVmZmVyQ29kZWNzKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmVxdWlyZWRUcmFja3MgPSBkYXRhLnRyYWNrcztcbiAgICBpZiAocmVxdWlyZWRUcmFja3MpIHtcbiAgICAgIHRoaXMucmVxdWlyZWRUcmFja3MgPSByZXF1aXJlZFRyYWNrcztcbiAgICB9XG4gIH1cbiAgb25CdWZmZXJBcHBlbmRlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMuY2hlY2tCdWZmZXIoKTtcbiAgfVxuICBvbkJ1ZmZlckZsdXNoZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCBwbGF5aW5nSXRlbSA9IHRoaXMucGxheWluZ0l0ZW07XG4gICAgaWYgKHBsYXlpbmdJdGVtICYmICF0aGlzLml0ZW1zTWF0Y2gocGxheWluZ0l0ZW0sIHRoaXMuYnVmZmVyaW5nSXRlbSkgJiYgIXRoaXMuaXNJbnRlcnN0aXRpYWwocGxheWluZ0l0ZW0pKSB7XG4gICAgICBjb25zdCB0aW1lbGluZVBvcyA9IHRoaXMudGltZWxpbmVQb3M7XG4gICAgICB0aGlzLmJ1ZmZlcmVkUG9zID0gdGltZWxpbmVQb3M7XG4gICAgICB0aGlzLmNoZWNrQnVmZmVyKCk7XG4gICAgfVxuICB9XG4gIG9uQnVmZmVyZWRUb0VuZChldmVudCkge1xuICAgIC8vIEJ1ZmZlcmVkIHRvIHBvc3Qtcm9sbFxuICAgIGNvbnN0IGludGVyc3RpdGlhbEV2ZW50cyA9IHRoaXMuc2NoZWR1bGUuZXZlbnRzO1xuICAgIGlmICh0aGlzLmJ1ZmZlcmVkUG9zIDwgTnVtYmVyLk1BWF9WQUxVRSAmJiBpbnRlcnN0aXRpYWxFdmVudHMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW50ZXJzdGl0aWFsRXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGludGVyc3RpdGlhbCA9IGludGVyc3RpdGlhbEV2ZW50c1tpXTtcbiAgICAgICAgaWYgKGludGVyc3RpdGlhbC5jdWUucG9zdCkge1xuICAgICAgICAgIHZhciBfdGhpcyRzY2hlZHVsZSRpdGVtcztcbiAgICAgICAgICBjb25zdCBzY2hlZHVsZUluZGV4ID0gdGhpcy5zY2hlZHVsZS5maW5kRXZlbnRJbmRleChpbnRlcnN0aXRpYWwuaWRlbnRpZmllcik7XG4gICAgICAgICAgY29uc3QgaXRlbSA9IChfdGhpcyRzY2hlZHVsZSRpdGVtcyA9IHRoaXMuc2NoZWR1bGUuaXRlbXMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRzY2hlZHVsZSRpdGVtc1tzY2hlZHVsZUluZGV4XTtcbiAgICAgICAgICBpZiAodGhpcy5pc0ludGVyc3RpdGlhbChpdGVtKSAmJiB0aGlzLmV2ZW50SXRlbXNNYXRjaChpdGVtLCB0aGlzLmJ1ZmZlcmluZ0l0ZW0pKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcmVkVG9JdGVtKGl0ZW0sIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5idWZmZXJlZFBvcyA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgfVxuICB9XG4gIG9uTWVkaWFFbmRlZChldmVudCkge1xuICAgIGNvbnN0IHBsYXlpbmdJdGVtID0gdGhpcy5wbGF5aW5nSXRlbTtcbiAgICBpZiAoIXRoaXMucGxheWluZ0xhc3RJdGVtICYmIHBsYXlpbmdJdGVtKSB7XG4gICAgICBjb25zdCBwbGF5aW5nSW5kZXggPSB0aGlzLmZpbmRJdGVtSW5kZXgocGxheWluZ0l0ZW0pO1xuICAgICAgdGhpcy5zZXRTY2hlZHVsZVBvc2l0aW9uKHBsYXlpbmdJbmRleCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNob3VsZFBsYXkgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlSXRlbShwcmV2aW91c0l0ZW0sIHRpbWUpIHtcbiAgICAvLyBmaW5kIGl0ZW0gaW4gdGhpcy5zY2hlZHVsZS5pdGVtcztcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuc2NoZWR1bGUuaXRlbXM7XG4gICAgaWYgKHByZXZpb3VzSXRlbSAmJiBpdGVtcykge1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmZpbmRJdGVtSW5kZXgocHJldmlvdXNJdGVtLCB0aW1lKTtcbiAgICAgIHJldHVybiBpdGVtc1tpbmRleF0gfHwgbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdHJpbUluUGxhY2UodXBkYXRlZEl0ZW0sIGl0ZW1CZWZvcmVVcGRhdGUpIHtcbiAgICBpZiAodGhpcy5pc0ludGVyc3RpdGlhbCh1cGRhdGVkSXRlbSkgJiYgdXBkYXRlZEl0ZW0uZXZlbnQuYXBwZW5kSW5QbGFjZSAmJiBpdGVtQmVmb3JlVXBkYXRlLmVuZCAtIHVwZGF0ZWRJdGVtLmVuZCA+IDAuMjUpIHtcbiAgICAgIHVwZGF0ZWRJdGVtLmV2ZW50LmFzc2V0TGlzdC5mb3JFYWNoKChhc3NldCwgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKHVwZGF0ZWRJdGVtLmV2ZW50LmlzQXNzZXRQYXN0UGxheW91dExpbWl0KGluZGV4KSkge1xuICAgICAgICAgIHRoaXMuY2xlYXJBc3NldFBsYXllcihhc3NldC5pZGVudGlmaWVyLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCBmbHVzaFN0YXJ0ID0gdXBkYXRlZEl0ZW0uZW5kICsgMC4yNTtcbiAgICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyh0aGlzLnByaW1hcnlNZWRpYSwgZmx1c2hTdGFydCwgMCk7XG4gICAgICBpZiAoYnVmZmVySW5mby5lbmQgPiBmbHVzaFN0YXJ0IHx8IChidWZmZXJJbmZvLm5leHRTdGFydCB8fCAwKSA+IGZsdXNoU3RhcnQpIHtcbiAgICAgICAgdGhpcy5hdHRhY2hQcmltYXJ5KGZsdXNoU3RhcnQsIG51bGwpO1xuICAgICAgICB0aGlzLmZsdXNoRnJvbnRCdWZmZXIoZmx1c2hTdGFydCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGl0ZW1zTWF0Y2goYSwgYikge1xuICAgIHJldHVybiAhIWIgJiYgKGEgPT09IGIgfHwgYS5ldmVudCAmJiBiLmV2ZW50ICYmIHRoaXMuZXZlbnRJdGVtc01hdGNoKGEsIGIpIHx8ICFhLmV2ZW50ICYmICFiLmV2ZW50ICYmIHRoaXMuZmluZEl0ZW1JbmRleChhKSA9PT0gdGhpcy5maW5kSXRlbUluZGV4KGIpKTtcbiAgfVxuICBldmVudEl0ZW1zTWF0Y2goYSwgYikge1xuICAgIHZhciBfYiRldmVudDtcbiAgICByZXR1cm4gISFiICYmIChhID09PSBiIHx8IGEuZXZlbnQuaWRlbnRpZmllciA9PT0gKChfYiRldmVudCA9IGIuZXZlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYiRldmVudC5pZGVudGlmaWVyKSk7XG4gIH1cbiAgZmluZEl0ZW1JbmRleChpdGVtLCB0aW1lKSB7XG4gICAgcmV0dXJuIGl0ZW0gPyB0aGlzLnNjaGVkdWxlLmZpbmRJdGVtSW5kZXgoaXRlbSwgdGltZSkgOiAtMTtcbiAgfVxuICB1cGRhdGVTY2hlZHVsZSgpIHtcbiAgICBjb25zdCBtZWRpYVNlbGVjdGlvbiA9IHRoaXMubWVkaWFTZWxlY3Rpb247XG4gICAgaWYgKCFtZWRpYVNlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNjaGVkdWxlLnVwZGF0ZVNjaGVkdWxlKG1lZGlhU2VsZWN0aW9uLCBbXSk7XG4gIH1cblxuICAvLyBTY2hlZHVsZSBidWZmZXIgY29udHJvbFxuICBjaGVja0J1ZmZlcihzdGFydmVkKSB7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLnNjaGVkdWxlLml0ZW1zO1xuICAgIGlmICghaXRlbXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gRmluZCB3aGVuIGNvbWJpbmVkIGZvcndhcmQgYnVmZmVyIGNoYW5nZSByZWFjaGVzIG5leHQgc2NoZWR1bGUgc2VnbWVudFxuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyh0aGlzLnByaW1hcnlNZWRpYSwgdGhpcy50aW1lbGluZVBvcywgMCk7XG4gICAgaWYgKHN0YXJ2ZWQpIHtcbiAgICAgIHRoaXMuYnVmZmVyZWRQb3MgPSB0aGlzLnRpbWVsaW5lUG9zO1xuICAgIH1cbiAgICBzdGFydmVkIHx8IChzdGFydmVkID0gYnVmZmVySW5mby5sZW4gPCAxKTtcbiAgICB0aGlzLnVwZGF0ZUJ1ZmZlcmVkUG9zKGJ1ZmZlckluZm8uZW5kLCBpdGVtcywgc3RhcnZlZCk7XG4gIH1cbiAgdXBkYXRlQnVmZmVyZWRQb3MoYnVmZmVyRW5kLCBpdGVtcywgYnVmZmVySXNFbXB0eSkge1xuICAgIGNvbnN0IHNjaGVkdWxlID0gdGhpcy5zY2hlZHVsZTtcbiAgICBjb25zdCBidWZmZXJpbmdJdGVtID0gdGhpcy5idWZmZXJpbmdJdGVtO1xuICAgIGlmICh0aGlzLmJ1ZmZlcmVkUG9zID4gYnVmZmVyRW5kKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDEgJiYgdGhpcy5pdGVtc01hdGNoKGl0ZW1zWzBdLCBidWZmZXJpbmdJdGVtKSkge1xuICAgICAgdGhpcy5idWZmZXJlZFBvcyA9IGJ1ZmZlckVuZDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGxheWluZ0l0ZW0gPSB0aGlzLnBsYXlpbmdJdGVtO1xuICAgIGNvbnN0IHBsYXlpbmdJbmRleCA9IHRoaXMuZmluZEl0ZW1JbmRleChwbGF5aW5nSXRlbSk7XG4gICAgbGV0IGJ1ZmZlckVuZEluZGV4ID0gc2NoZWR1bGUuZmluZEl0ZW1JbmRleEF0VGltZShidWZmZXJFbmQpO1xuICAgIGlmICh0aGlzLmJ1ZmZlcmVkUG9zIDwgYnVmZmVyRW5kKSB7XG4gICAgICB2YXIgX25leHRJdGVtVG9CdWZmZXIkZXZlLCBfYnVmZmVyaW5nSXRlbSRldmVudDtcbiAgICAgIGNvbnN0IGJ1ZmZlcmluZ0luZGV4ID0gdGhpcy5maW5kSXRlbUluZGV4KGJ1ZmZlcmluZ0l0ZW0pO1xuICAgICAgY29uc3QgbmV4dFRvQnVmZmVySW5kZXggPSBNYXRoLm1pbihidWZmZXJpbmdJbmRleCArIDEsIGl0ZW1zLmxlbmd0aCAtIDEpO1xuICAgICAgY29uc3QgbmV4dEl0ZW1Ub0J1ZmZlciA9IGl0ZW1zW25leHRUb0J1ZmZlckluZGV4XTtcbiAgICAgIGlmIChidWZmZXJFbmRJbmRleCA9PT0gLTEgJiYgYnVmZmVyaW5nSXRlbSAmJiBidWZmZXJFbmQgPj0gYnVmZmVyaW5nSXRlbS5lbmQgfHwgKF9uZXh0SXRlbVRvQnVmZmVyJGV2ZSA9IG5leHRJdGVtVG9CdWZmZXIuZXZlbnQpICE9IG51bGwgJiYgX25leHRJdGVtVG9CdWZmZXIkZXZlLmFwcGVuZEluUGxhY2UgJiYgYnVmZmVyRW5kICsgMC4wMSA+PSBuZXh0SXRlbVRvQnVmZmVyLnN0YXJ0KSB7XG4gICAgICAgIGJ1ZmZlckVuZEluZGV4ID0gbmV4dFRvQnVmZmVySW5kZXg7XG4gICAgICB9XG4gICAgICBpZiAobmV4dFRvQnVmZmVySW5kZXggLSBwbGF5aW5nSW5kZXggPiAxICYmIChidWZmZXJpbmdJdGVtID09IG51bGwgPyB2b2lkIDAgOiAoX2J1ZmZlcmluZ0l0ZW0kZXZlbnQgPSBidWZmZXJpbmdJdGVtLmV2ZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2J1ZmZlcmluZ0l0ZW0kZXZlbnQuYXBwZW5kSW5QbGFjZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIGRvIG5vdCBhZHZhbmNlIGJ1ZmZlcmluZyBpdGVtIHBhc3QgSW50ZXJzdGl0aWFsIHRoYXQgcmVxdWlyZXMgc291cmNlIHJlc2V0XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuYnVmZmVyZWRQb3MgPSBidWZmZXJFbmQ7XG4gICAgICBpZiAoYnVmZmVyRW5kSW5kZXggPiBidWZmZXJpbmdJbmRleCAmJiBidWZmZXJFbmRJbmRleCA+IHBsYXlpbmdJbmRleCkge1xuICAgICAgICB0aGlzLmJ1ZmZlcmVkVG9JdGVtKG5leHRJdGVtVG9CdWZmZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYWxsb3cgbW9yZSB0aW1lIHRoYW4gZGlzdGFuY2UgZnJvbSBlZGdlIGZvciBhc3NldHMgdG8gbG9hZFxuICAgICAgICBjb25zdCBkZXRhaWxzID0gdGhpcy5wcmltYXJ5RGV0YWlscztcbiAgICAgICAgaWYgKHRoaXMucHJpbWFyeUxpdmUgJiYgZGV0YWlscyAmJiBidWZmZXJFbmQgPiBkZXRhaWxzLmVkZ2UgLSBkZXRhaWxzLnRhcmdldGR1cmF0aW9uICYmIG5leHRJdGVtVG9CdWZmZXIuc3RhcnQgPCBkZXRhaWxzLmVkZ2UgKyB0aGlzLmhscy5jb25maWcuaW50ZXJzdGl0aWFsTGl2ZUxvb2tBaGVhZCAmJiB0aGlzLmlzSW50ZXJzdGl0aWFsKG5leHRJdGVtVG9CdWZmZXIpKSB7XG4gICAgICAgICAgdGhpcy5wcmVsb2FkQXNzZXRzKG5leHRJdGVtVG9CdWZmZXIuZXZlbnQsIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChidWZmZXJJc0VtcHR5ICYmIHBsYXlpbmdJdGVtICYmICF0aGlzLml0ZW1zTWF0Y2gocGxheWluZ0l0ZW0sIGJ1ZmZlcmluZ0l0ZW0pKSB7XG4gICAgICBpZiAoYnVmZmVyRW5kSW5kZXggPT09IHBsYXlpbmdJbmRleCkge1xuICAgICAgICB0aGlzLmJ1ZmZlcmVkVG9JdGVtKHBsYXlpbmdJdGVtKTtcbiAgICAgIH0gZWxzZSBpZiAoYnVmZmVyRW5kSW5kZXggPT09IHBsYXlpbmdJbmRleCArIDEpIHtcbiAgICAgICAgdGhpcy5idWZmZXJlZFRvSXRlbShpdGVtc1tidWZmZXJFbmRJbmRleF0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3NldHNCdWZmZXJlZChpdGVtLCBtZWRpYSkge1xuICAgIGNvbnN0IGFzc2V0TGlzdCA9IGl0ZW0uZXZlbnQuYXNzZXRMaXN0O1xuICAgIGlmIChhc3NldExpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAhaXRlbS5ldmVudC5hc3NldExpc3Quc29tZShhc3NldCA9PiB7XG4gICAgICBjb25zdCBwbGF5ZXIgPSB0aGlzLmdldEFzc2V0UGxheWVyKGFzc2V0LmlkZW50aWZpZXIpO1xuICAgICAgcmV0dXJuICEocGxheWVyICE9IG51bGwgJiYgcGxheWVyLmJ1ZmZlcmVkSW5QbGFjZVRvRW5kKG1lZGlhKSk7XG4gICAgfSk7XG4gIH1cbiAgc2V0QnVmZmVyaW5nSXRlbShpdGVtKSB7XG4gICAgY29uc3QgYnVmZmVyaW5nTGFzdCA9IHRoaXMuYnVmZmVyaW5nSXRlbTtcbiAgICBjb25zdCBzY2hlZHVsZSA9IHRoaXMuc2NoZWR1bGU7XG4gICAgaWYgKCF0aGlzLml0ZW1zTWF0Y2goaXRlbSwgYnVmZmVyaW5nTGFzdCkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaXRlbXMsXG4gICAgICAgIGV2ZW50c1xuICAgICAgfSA9IHNjaGVkdWxlO1xuICAgICAgaWYgKCFpdGVtcyB8fCAhZXZlbnRzKSB7XG4gICAgICAgIHJldHVybiBidWZmZXJpbmdMYXN0O1xuICAgICAgfVxuICAgICAgY29uc3QgaXNJbnRlcnN0aXRpYWwgPSB0aGlzLmlzSW50ZXJzdGl0aWFsKGl0ZW0pO1xuICAgICAgY29uc3QgYnVmZmVyaW5nUGxheWVyID0gdGhpcy5nZXRCdWZmZXJpbmdQbGF5ZXIoKTtcbiAgICAgIHRoaXMuYnVmZmVyaW5nSXRlbSA9IGl0ZW07XG4gICAgICB0aGlzLmJ1ZmZlcmVkUG9zID0gTWF0aC5tYXgoaXRlbS5zdGFydCwgTWF0aC5taW4oaXRlbS5lbmQsIHRoaXMudGltZWxpbmVQb3MpKTtcbiAgICAgIGNvbnN0IHRpbWVSZW1haW5pbmcgPSBidWZmZXJpbmdQbGF5ZXIgPyBidWZmZXJpbmdQbGF5ZXIucmVtYWluaW5nIDogYnVmZmVyaW5nTGFzdCA/IGJ1ZmZlcmluZ0xhc3QuZW5kIC0gdGhpcy50aW1lbGluZVBvcyA6IDA7XG4gICAgICB0aGlzLmxvZyhgSU5URVJTVElUSUFMU19CVUZGRVJFRF9UT19CT1VOREFSWSAke3NlZ21lbnRUb1N0cmluZyhpdGVtKX1gICsgKGJ1ZmZlcmluZ0xhc3QgPyBgICgke3RpbWVSZW1haW5pbmcudG9GaXhlZCgyKX0gcmVtYWluaW5nKWAgOiAnJykpO1xuICAgICAgaWYgKCF0aGlzLnBsYXliYWNrRGlzYWJsZWQpIHtcbiAgICAgICAgaWYgKGlzSW50ZXJzdGl0aWFsKSB7XG4gICAgICAgICAgLy8gcHJpbWFyeSBmcmFnbWVudCBsb2FkaW5nIHdpbGwgZXhpdCBlYXJseSBpbiBiYXNlLXN0cmVhbS1jb250cm9sbGVyIHdoaWxlIGBidWZmZXJpbmdJdGVtYCBpcyBzZXQgdG8gYW4gSW50ZXJzdGl0aWFsIGJsb2NrXG4gICAgICAgICAgaXRlbS5ldmVudC5hc3NldExpc3QuZm9yRWFjaChhc3NldCA9PiB7XG4gICAgICAgICAgICBjb25zdCBwbGF5ZXIgPSB0aGlzLmdldEFzc2V0UGxheWVyKGFzc2V0LmlkZW50aWZpZXIpO1xuICAgICAgICAgICAgaWYgKHBsYXllcikge1xuICAgICAgICAgICAgICBwbGF5ZXIucmVzdW1lQnVmZmVyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5obHMucmVzdW1lQnVmZmVyaW5nKCk7XG4gICAgICAgICAgdGhpcy5wbGF5ZXJRdWV1ZS5mb3JFYWNoKHBsYXllciA9PiBwbGF5ZXIucGF1c2VCdWZmZXJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLklOVEVSU1RJVElBTFNfQlVGRkVSRURfVE9fQk9VTkRBUlksIHtcbiAgICAgICAgZXZlbnRzOiBldmVudHMuc2xpY2UoMCksXG4gICAgICAgIHNjaGVkdWxlOiBpdGVtcy5zbGljZSgwKSxcbiAgICAgICAgYnVmZmVyaW5nSW5kZXg6IHRoaXMuZmluZEl0ZW1JbmRleChpdGVtKSxcbiAgICAgICAgcGxheWluZ0luZGV4OiB0aGlzLmZpbmRJdGVtSW5kZXgodGhpcy5wbGF5aW5nSXRlbSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5idWZmZXJpbmdJdGVtICE9PSBpdGVtKSB7XG4gICAgICB0aGlzLmJ1ZmZlcmluZ0l0ZW0gPSBpdGVtO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyaW5nTGFzdDtcbiAgfVxuICBidWZmZXJlZFRvSXRlbShpdGVtLCBhc3NldExpc3RJbmRleCA9IDApIHtcbiAgICBjb25zdCBidWZmZXJpbmdMYXN0ID0gdGhpcy5zZXRCdWZmZXJpbmdJdGVtKGl0ZW0pO1xuICAgIGlmICh0aGlzLnBsYXliYWNrRGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNJbnRlcnN0aXRpYWwoaXRlbSkpIHtcbiAgICAgIC8vIEVuc3VyZSBhc3NldCBsaXN0IGlzIGxvYWRlZFxuICAgICAgdGhpcy5idWZmZXJlZFRvRXZlbnQoaXRlbSwgYXNzZXRMaXN0SW5kZXgpO1xuICAgIH0gZWxzZSBpZiAoYnVmZmVyaW5nTGFzdCAhPT0gbnVsbCkge1xuICAgICAgLy8gSWYgcHJpbWFyeSBwbGF5ZXIgaXMgZGV0YWNoZWQsIGl0IGlzIGFsc28gc3RvcHBlZCwgcmVzdGFydCBsb2FkaW5nIGF0IHByaW1hcnkgcG9zaXRpb25cbiAgICAgIHRoaXMuYnVmZmVyaW5nQXNzZXQgPSBudWxsO1xuICAgICAgY29uc3QgZGV0YWNoZWREYXRhID0gdGhpcy5kZXRhY2hlZERhdGE7XG4gICAgICBpZiAoZGV0YWNoZWREYXRhKSB7XG4gICAgICAgIGlmIChkZXRhY2hlZERhdGEubWVkaWFTb3VyY2UpIHtcbiAgICAgICAgICBjb25zdCBza2lwU2Vla1RvU3RhcnRQb3NpdGlvbiA9IHRydWU7XG4gICAgICAgICAgdGhpcy5hdHRhY2hQcmltYXJ5KGl0ZW0uc3RhcnQsIGl0ZW0sIHNraXBTZWVrVG9TdGFydFBvc2l0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnByZWxvYWRQcmltYXJ5KGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiBub3QgZGV0YWNoZWQgc2VlayB0byByZXN1bXB0aW9uIHBvaW50XG4gICAgICAgIHRoaXMucHJlbG9hZFByaW1hcnkoaXRlbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHByZWxvYWRQcmltYXJ5KGl0ZW0pIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuZmluZEl0ZW1JbmRleChpdGVtKTtcbiAgICBjb25zdCB0aW1lbGluZVBvcyA9IHRoaXMuZ2V0UHJpbWFyeVJlc3VtcHRpb24oaXRlbSwgaW5kZXgpO1xuICAgIHRoaXMuc3RhcnRMb2FkaW5nUHJpbWFyeUF0KHRpbWVsaW5lUG9zKTtcbiAgfVxuICBidWZmZXJlZFRvRXZlbnQoaXRlbSwgYXNzZXRMaXN0SW5kZXgpIHtcbiAgICBjb25zdCBpbnRlcnN0aXRpYWwgPSBpdGVtLmV2ZW50O1xuICAgIGNvbnN0IG5ldmVyTG9hZGVkID0gaW50ZXJzdGl0aWFsLmFzc2V0TGlzdC5sZW5ndGggPT09IDAgJiYgIWludGVyc3RpdGlhbC5hc3NldExpc3RMb2FkZXI7XG4gICAgY29uc3QgcGxheU9uY2UgPSBpbnRlcnN0aXRpYWwuY3VlLm9uY2U7XG4gICAgaWYgKG5ldmVyTG9hZGVkIHx8ICFwbGF5T25jZSkge1xuICAgICAgLy8gQnVmZmVyZWQgdG8gSW50ZXJzdGl0aWFsIGJvdW5kYXJ5XG4gICAgICBjb25zdCBwbGF5ZXIgPSB0aGlzLnByZWxvYWRBc3NldHMoaW50ZXJzdGl0aWFsLCBhc3NldExpc3RJbmRleCk7XG4gICAgICBpZiAocGxheWVyICE9IG51bGwgJiYgcGxheWVyLmludGVyc3RpdGlhbC5hcHBlbmRJblBsYWNlKSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSBwbGF5ZXIgYW5kIGFzc2V0IGxpc3QgaW5mbywgc3RhcnQgYnVmZmVyaW5nXG4gICAgICAgIGNvbnN0IGFzc2V0SXRlbSA9IGludGVyc3RpdGlhbC5hc3NldExpc3RbYXNzZXRMaXN0SW5kZXhdO1xuICAgICAgICBjb25zdCBtZWRpYSA9IHRoaXMucHJpbWFyeU1lZGlhO1xuICAgICAgICBpZiAoYXNzZXRJdGVtICYmIG1lZGlhKSB7XG4gICAgICAgICAgdGhpcy5idWZmZXJBc3NldFBsYXllcihwbGF5ZXIsIG1lZGlhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBwcmVsb2FkQXNzZXRzKGludGVyc3RpdGlhbCwgYXNzZXRMaXN0SW5kZXgpIHtcbiAgICBjb25zdCB1cmkgPSBpbnRlcnN0aXRpYWwuYXNzZXRVcmw7XG4gICAgY29uc3QgYXNzZXRMaXN0TGVuZ3RoID0gaW50ZXJzdGl0aWFsLmFzc2V0TGlzdC5sZW5ndGg7XG4gICAgY29uc3QgbmV2ZXJMb2FkZWQgPSBhc3NldExpc3RMZW5ndGggPT09IDAgJiYgIWludGVyc3RpdGlhbC5hc3NldExpc3RMb2FkZXI7XG4gICAgY29uc3QgcGxheU9uY2UgPSBpbnRlcnN0aXRpYWwuY3VlLm9uY2U7XG4gICAgaWYgKG5ldmVyTG9hZGVkKSB7XG4gICAgICBjb25zdCB0aW1lbGluZVN0YXJ0ID0gaW50ZXJzdGl0aWFsLnRpbWVsaW5lU3RhcnQ7XG4gICAgICBpZiAoaW50ZXJzdGl0aWFsLmFwcGVuZEluUGxhY2UpIHtcbiAgICAgICAgdmFyIF9wbGF5aW5nSXRlbSRuZXh0RXZlbjtcbiAgICAgICAgY29uc3QgcGxheWluZ0l0ZW0gPSB0aGlzLnBsYXlpbmdJdGVtO1xuICAgICAgICBpZiAoIXRoaXMuaXNJbnRlcnN0aXRpYWwocGxheWluZ0l0ZW0pICYmIChwbGF5aW5nSXRlbSA9PSBudWxsID8gdm9pZCAwIDogKF9wbGF5aW5nSXRlbSRuZXh0RXZlbiA9IHBsYXlpbmdJdGVtLm5leHRFdmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wbGF5aW5nSXRlbSRuZXh0RXZlbi5pZGVudGlmaWVyKSA9PT0gaW50ZXJzdGl0aWFsLmlkZW50aWZpZXIpIHtcbiAgICAgICAgICB0aGlzLmZsdXNoRnJvbnRCdWZmZXIodGltZWxpbmVTdGFydCArIDAuMjUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgaGxzU3RhcnRPZmZzZXQ7XG4gICAgICBsZXQgbGl2ZVN0YXJ0UG9zaXRpb24gPSAwO1xuICAgICAgaWYgKCF0aGlzLnBsYXlpbmdJdGVtICYmIHRoaXMucHJpbWFyeUxpdmUpIHtcbiAgICAgICAgbGl2ZVN0YXJ0UG9zaXRpb24gPSB0aGlzLmhscy5zdGFydFBvc2l0aW9uO1xuICAgICAgICBpZiAobGl2ZVN0YXJ0UG9zaXRpb24gPT09IC0xKSB7XG4gICAgICAgICAgbGl2ZVN0YXJ0UG9zaXRpb24gPSB0aGlzLmhscy5saXZlU3luY1Bvc2l0aW9uIHx8IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsaXZlU3RhcnRQb3NpdGlvbiAmJiAhKGludGVyc3RpdGlhbC5jdWUucHJlIHx8IGludGVyc3RpdGlhbC5jdWUucG9zdCkpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBsaXZlU3RhcnRQb3NpdGlvbiAtIHRpbWVsaW5lU3RhcnQ7XG4gICAgICAgIGlmIChzdGFydE9mZnNldCA+IDApIHtcbiAgICAgICAgICBobHNTdGFydE9mZnNldCA9IE1hdGgucm91bmQoc3RhcnRPZmZzZXQgKiAxMDAwKSAvIDEwMDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubG9nKGBMb2FkIGludGVyc3RpdGlhbCBhc3NldCAke2Fzc2V0TGlzdEluZGV4ICsgMX0vJHt1cmkgPyAxIDogYXNzZXRMaXN0TGVuZ3RofSAke2ludGVyc3RpdGlhbH0ke2hsc1N0YXJ0T2Zmc2V0ID8gYCBsaXZlLXN0YXJ0OiAke2xpdmVTdGFydFBvc2l0aW9ufSBzdGFydC1vZmZzZXQ6ICR7aGxzU3RhcnRPZmZzZXR9YCA6ICcnfWApO1xuICAgICAgaWYgKHVyaSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVBc3NldChpbnRlcnN0aXRpYWwsIDAsIDAsIHRpbWVsaW5lU3RhcnQsIGludGVyc3RpdGlhbC5kdXJhdGlvbiwgdXJpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFzc2V0TGlzdExvYWRlciA9IHRoaXMuYXNzZXRMaXN0TG9hZGVyLmxvYWRBc3NldExpc3QoaW50ZXJzdGl0aWFsLCBobHNTdGFydE9mZnNldCk7XG4gICAgICBpZiAoYXNzZXRMaXN0TG9hZGVyKSB7XG4gICAgICAgIGludGVyc3RpdGlhbC5hc3NldExpc3RMb2FkZXIgPSBhc3NldExpc3RMb2FkZXI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghcGxheU9uY2UgJiYgYXNzZXRMaXN0TGVuZ3RoKSB7XG4gICAgICAvLyBSZS1idWZmZXJlZCB0byBJbnRlcnN0aXRpYWwgYm91bmRhcnksIHJlLWNyZWF0ZSBhc3NldCBwbGF5ZXIocylcbiAgICAgIGZvciAobGV0IGkgPSBhc3NldExpc3RJbmRleDsgaSA8IGFzc2V0TGlzdExlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFzc2V0ID0gaW50ZXJzdGl0aWFsLmFzc2V0TGlzdFtpXTtcbiAgICAgICAgY29uc3QgcGxheWVySW5kZXggPSB0aGlzLmdldEFzc2V0UGxheWVyUXVldWVJbmRleChhc3NldC5pZGVudGlmaWVyKTtcbiAgICAgICAgaWYgKChwbGF5ZXJJbmRleCA9PT0gLTEgfHwgdGhpcy5wbGF5ZXJRdWV1ZVtwbGF5ZXJJbmRleF0uZGVzdHJveWVkKSAmJiAhYXNzZXQuZXJyb3IpIHtcbiAgICAgICAgICB0aGlzLmNyZWF0ZUFzc2V0UGxheWVyKGludGVyc3RpdGlhbCwgYXNzZXQsIGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5nZXRBc3NldFBsYXllcihpbnRlcnN0aXRpYWwuYXNzZXRMaXN0W2Fzc2V0TGlzdEluZGV4XS5pZGVudGlmaWVyKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZmx1c2hGcm9udEJ1ZmZlcihzdGFydE9mZnNldCkge1xuICAgIC8vIEZvcmNlIHF1ZXVlZCBmbHVzaGluZyBvZiBhbGwgYnVmZmVyc1xuICAgIGNvbnN0IHJlcXVpcmVkVHJhY2tzID0gdGhpcy5yZXF1aXJlZFRyYWNrcztcbiAgICBpZiAoIXJlcXVpcmVkVHJhY2tzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubG9nKGBSZW1vdmluZyBmcm9udCBidWZmZXIgc3RhcnRpbmcgYXQgJHtzdGFydE9mZnNldH1gKTtcbiAgICBjb25zdCBzb3VyY2VCdWZmZXJOYW1lcyA9IE9iamVjdC5rZXlzKHJlcXVpcmVkVHJhY2tzKTtcbiAgICBzb3VyY2VCdWZmZXJOYW1lcy5mb3JFYWNoKHR5cGUgPT4ge1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0ZMVVNISU5HLCB7XG4gICAgICAgIHN0YXJ0T2Zmc2V0LFxuICAgICAgICBlbmRPZmZzZXQ6IEluZmluaXR5LFxuICAgICAgICB0eXBlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEludGVyc3RpdGlhbCBBc3NldCBQbGF5ZXIgY29udHJvbFxuICBnZXRBc3NldFBsYXllclF1ZXVlSW5kZXgoYXNzZXRJZCkge1xuICAgIGNvbnN0IHBsYXllclF1ZXVlID0gdGhpcy5wbGF5ZXJRdWV1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBsYXllclF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXNzZXRJZCA9PT0gcGxheWVyUXVldWVbaV0uYXNzZXRJZCkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGdldEFzc2V0UGxheWVyKGFzc2V0SWQpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0QXNzZXRQbGF5ZXJRdWV1ZUluZGV4KGFzc2V0SWQpO1xuICAgIHJldHVybiB0aGlzLnBsYXllclF1ZXVlW2luZGV4XSB8fCBudWxsO1xuICB9XG4gIGdldEJ1ZmZlcmluZ1BsYXllcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBwbGF5ZXJRdWV1ZSxcbiAgICAgIHByaW1hcnlNZWRpYVxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChwcmltYXJ5TWVkaWEpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGxheWVyUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHBsYXllclF1ZXVlW2ldLm1lZGlhID09PSBwcmltYXJ5TWVkaWEpIHtcbiAgICAgICAgICByZXR1cm4gcGxheWVyUXVldWVbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY3JlYXRlQXNzZXQoaW50ZXJzdGl0aWFsLCBhc3NldExpc3RJbmRleCwgc3RhcnRPZmZzZXQsIHRpbWVsaW5lU3RhcnQsIGR1cmF0aW9uLCB1cmkpIHtcbiAgICBjb25zdCBhc3NldEl0ZW0gPSB7XG4gICAgICBwYXJlbnRJZGVudGlmaWVyOiBpbnRlcnN0aXRpYWwuaWRlbnRpZmllcixcbiAgICAgIGlkZW50aWZpZXI6IGdlbmVyYXRlQXNzZXRJZGVudGlmaWVyKGludGVyc3RpdGlhbCwgdXJpLCBhc3NldExpc3RJbmRleCksXG4gICAgICBkdXJhdGlvbixcbiAgICAgIHN0YXJ0T2Zmc2V0LFxuICAgICAgdGltZWxpbmVTdGFydCxcbiAgICAgIHVyaVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlQXNzZXRQbGF5ZXIoaW50ZXJzdGl0aWFsLCBhc3NldEl0ZW0sIGFzc2V0TGlzdEluZGV4KTtcbiAgfVxuICBjcmVhdGVBc3NldFBsYXllcihpbnRlcnN0aXRpYWwsIGFzc2V0SXRlbSwgYXNzZXRMaXN0SW5kZXgpIHtcbiAgICBjb25zdCBwcmltYXJ5ID0gdGhpcy5obHM7XG4gICAgY29uc3QgdXNlckNvbmZpZyA9IHByaW1hcnkudXNlckNvbmZpZztcbiAgICBsZXQgdmlkZW9QcmVmZXJlbmNlID0gdXNlckNvbmZpZy52aWRlb1ByZWZlcmVuY2U7XG4gICAgY29uc3QgY3VycmVudExldmVsID0gcHJpbWFyeS5sb2FkTGV2ZWxPYmogfHwgcHJpbWFyeS5sZXZlbHNbcHJpbWFyeS5jdXJyZW50TGV2ZWxdO1xuICAgIGlmICh2aWRlb1ByZWZlcmVuY2UgfHwgY3VycmVudExldmVsKSB7XG4gICAgICB2aWRlb1ByZWZlcmVuY2UgPSBfZXh0ZW5kcyh7fSwgdmlkZW9QcmVmZXJlbmNlKTtcbiAgICAgIGlmIChjdXJyZW50TGV2ZWwudmlkZW9Db2RlYykge1xuICAgICAgICB2aWRlb1ByZWZlcmVuY2UudmlkZW9Db2RlYyA9IGN1cnJlbnRMZXZlbC52aWRlb0NvZGVjO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRMZXZlbC52aWRlb1JhbmdlKSB7XG4gICAgICAgIHZpZGVvUHJlZmVyZW5jZS5hbGxvd2VkVmlkZW9SYW5nZXMgPSBbY3VycmVudExldmVsLnZpZGVvUmFuZ2VdO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzZWxlY3RlZEF1ZGlvID0gcHJpbWFyeS5hdWRpb1RyYWNrc1twcmltYXJ5LmF1ZGlvVHJhY2tdO1xuICAgIGNvbnN0IHNlbGVjdGVkU3VidGl0bGUgPSBwcmltYXJ5LnN1YnRpdGxlVHJhY2tzW3ByaW1hcnkuc3VidGl0bGVUcmFja107XG4gICAgbGV0IHN0YXJ0UG9zaXRpb24gPSAwO1xuICAgIGlmICh0aGlzLnByaW1hcnlMaXZlIHx8IGludGVyc3RpdGlhbC5hcHBlbmRJblBsYWNlKSB7XG4gICAgICBjb25zdCB0aW1lUGFzdFN0YXJ0ID0gdGhpcy50aW1lbGluZVBvcyAtIGFzc2V0SXRlbS50aW1lbGluZVN0YXJ0O1xuICAgICAgaWYgKHRpbWVQYXN0U3RhcnQgPiAxKSB7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gYXNzZXRJdGVtLmR1cmF0aW9uO1xuICAgICAgICBpZiAoZHVyYXRpb24gJiYgdGltZVBhc3RTdGFydCA8IGR1cmF0aW9uKSB7XG4gICAgICAgICAgc3RhcnRQb3NpdGlvbiA9IHRpbWVQYXN0U3RhcnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYXNzZXRJZCA9IGFzc2V0SXRlbS5pZGVudGlmaWVyO1xuICAgIGNvbnN0IHBsYXllckNvbmZpZyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCB1c2VyQ29uZmlnKSwge30sIHtcbiAgICAgIGF1dG9TdGFydExvYWQ6IHRydWUsXG4gICAgICBzdGFydEZyYWdQcmVmZXRjaDogdHJ1ZSxcbiAgICAgIHByaW1hcnlTZXNzaW9uSWQ6IHByaW1hcnkuc2Vzc2lvbklkLFxuICAgICAgYXNzZXRQbGF5ZXJJZDogYXNzZXRJZCxcbiAgICAgIGFickV3bWFEZWZhdWx0RXN0aW1hdGU6IHByaW1hcnkuYmFuZHdpZHRoRXN0aW1hdGUsXG4gICAgICBpbnRlcnN0aXRpYWxzQ29udHJvbGxlcjogdW5kZWZpbmVkLFxuICAgICAgc3RhcnRQb3NpdGlvbixcbiAgICAgIGxpdmVEdXJhdGlvbkluZmluaXR5OiBmYWxzZSxcbiAgICAgIHRlc3RCYW5kd2lkdGg6IGZhbHNlLFxuICAgICAgdmlkZW9QcmVmZXJlbmNlLFxuICAgICAgYXVkaW9QcmVmZXJlbmNlOiBzZWxlY3RlZEF1ZGlvIHx8IHVzZXJDb25maWcuYXVkaW9QcmVmZXJlbmNlLFxuICAgICAgc3VidGl0bGVQcmVmZXJlbmNlOiBzZWxlY3RlZFN1YnRpdGxlIHx8IHVzZXJDb25maWcuc3VidGl0bGVQcmVmZXJlbmNlXG4gICAgfSk7XG4gICAgaWYgKGludGVyc3RpdGlhbC5hcHBlbmRJblBsYWNlKSB7XG4gICAgICBpbnRlcnN0aXRpYWwuYXBwZW5kSW5QbGFjZVN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgaWYgKGFzc2V0SXRlbS50aW1lbGluZVN0YXJ0KSB7XG4gICAgICAgIHBsYXllckNvbmZpZy50aW1lbGluZU9mZnNldCA9IGFzc2V0SXRlbS50aW1lbGluZVN0YXJ0O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjbWNkID0gcGxheWVyQ29uZmlnLmNtY2Q7XG4gICAgaWYgKGNtY2QgIT0gbnVsbCAmJiBjbWNkLnNlc3Npb25JZCAmJiBjbWNkLmNvbnRlbnRJZCkge1xuICAgICAgcGxheWVyQ29uZmlnLmNtY2QgPSBfZXh0ZW5kcyh7fSwgY21jZCwge1xuICAgICAgICBjb250ZW50SWQ6IGhhc2goYXNzZXRJdGVtLnVyaSlcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5nZXRBc3NldFBsYXllcihhc3NldElkKSkge1xuICAgICAgdGhpcy53YXJuKGBEdXBsaWNhdGUgZGF0ZSByYW5nZSBpZGVudGlmaWVyICR7aW50ZXJzdGl0aWFsfSBhbmQgYXNzZXQgJHthc3NldElkfWApO1xuICAgIH1cbiAgICBjb25zdCBwbGF5ZXIgPSBuZXcgSGxzQXNzZXRQbGF5ZXIodGhpcy5IbHNQbGF5ZXJDbGFzcywgcGxheWVyQ29uZmlnLCBpbnRlcnN0aXRpYWwsIGFzc2V0SXRlbSk7XG4gICAgdGhpcy5wbGF5ZXJRdWV1ZS5wdXNoKHBsYXllcik7XG4gICAgaW50ZXJzdGl0aWFsLmFzc2V0TGlzdFthc3NldExpc3RJbmRleF0gPSBhc3NldEl0ZW07XG4gICAgLy8gTGlzdGVuIGZvciBMZXZlbERldGFpbHMgYW5kIFBUUyBjaGFuZ2UgdG8gdXBkYXRlIGR1cmF0aW9uXG4gICAgY29uc3QgdXBkYXRlQXNzZXRQbGF5ZXJEZXRhaWxzID0gZGV0YWlscyA9PiB7XG4gICAgICBpZiAoZGV0YWlscy5saXZlKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBJbnRlcnN0aXRpYWxzIE1VU1QgYmUgVk9EIGFzc2V0cyAke2ludGVyc3RpdGlhbH1gKTtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0ge1xuICAgICAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuT1RIRVJfRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLklOVEVSU1RJVElBTF9BU1NFVF9JVEVNX0VSUk9SLFxuICAgICAgICAgIGVycm9yXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlQXNzZXRJdGVtRXJyb3IoZXJyb3JEYXRhLCBpbnRlcnN0aXRpYWwsIHRoaXMuc2NoZWR1bGUuZmluZEV2ZW50SW5kZXgoaW50ZXJzdGl0aWFsLmlkZW50aWZpZXIpLCBhc3NldExpc3RJbmRleCwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIEdldCB0aW1lIGF0IGVuZCBvZiBsYXN0IGZyYWdtZW50XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IGRldGFpbHMuZWRnZSAtIGRldGFpbHMuZnJhZ21lbnRTdGFydDtcbiAgICAgIGNvbnN0IGN1cnJlbnRBc3NldER1cmF0aW9uID0gYXNzZXRJdGVtLmR1cmF0aW9uO1xuICAgICAgaWYgKGN1cnJlbnRBc3NldER1cmF0aW9uID09PSBudWxsIHx8IGR1cmF0aW9uID4gY3VycmVudEFzc2V0RHVyYXRpb24pIHtcbiAgICAgICAgdGhpcy5sb2coYEludGVyc3RpdGlhbCBhc3NldCBcIiR7YXNzZXRJZH1cIiBkdXJhdGlvbiBjaGFuZ2UgJHtjdXJyZW50QXNzZXREdXJhdGlvbn0gPiAke2R1cmF0aW9ufWApO1xuICAgICAgICBhc3NldEl0ZW0uZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgLy8gVXBkYXRlIHNjaGVkdWxlIHdpdGggbmV3IGV2ZW50IGFuZCBhc3NldCBkdXJhdGlvblxuICAgICAgICB0aGlzLnVwZGF0ZVNjaGVkdWxlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBwbGF5ZXIub24oRXZlbnRzLkxFVkVMX1VQREFURUQsIChldmVudCwge1xuICAgICAgZGV0YWlsc1xuICAgIH0pID0+IHVwZGF0ZUFzc2V0UGxheWVyRGV0YWlscyhkZXRhaWxzKSk7XG4gICAgcGxheWVyLm9uKEV2ZW50cy5MRVZFTF9QVFNfVVBEQVRFRCwgKGV2ZW50LCB7XG4gICAgICBkZXRhaWxzXG4gICAgfSkgPT4gdXBkYXRlQXNzZXRQbGF5ZXJEZXRhaWxzKGRldGFpbHMpKTtcbiAgICBjb25zdCBvbkJ1ZmZlckNvZGVjcyA9IChldmVudCwgZGF0YSkgPT4ge1xuICAgICAgY29uc3QgaW5RdWV1UGxheWVyID0gdGhpcy5nZXRBc3NldFBsYXllcihhc3NldElkKTtcbiAgICAgIGlmIChpblF1ZXVQbGF5ZXIgJiYgZGF0YS50cmFja3MpIHtcbiAgICAgICAgaW5RdWV1UGxheWVyLm9mZihFdmVudHMuQlVGRkVSX0NPREVDUywgb25CdWZmZXJDb2RlY3MpO1xuICAgICAgICBpblF1ZXVQbGF5ZXIudHJhY2tzID0gZGF0YS50cmFja3M7XG4gICAgICAgIGNvbnN0IG1lZGlhID0gdGhpcy5wcmltYXJ5TWVkaWE7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlcmluZ0Fzc2V0ID09PSBpblF1ZXVQbGF5ZXIuYXNzZXRJdGVtICYmIG1lZGlhICYmICFpblF1ZXVQbGF5ZXIubWVkaWEpIHtcbiAgICAgICAgICB0aGlzLmJ1ZmZlckFzc2V0UGxheWVyKGluUXVldVBsYXllciwgbWVkaWEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBwbGF5ZXIub24oRXZlbnRzLkJVRkZFUl9DT0RFQ1MsIG9uQnVmZmVyQ29kZWNzKTtcbiAgICBjb25zdCBidWZmZXJlZFRvRW5kID0gKCkgPT4ge1xuICAgICAgdmFyIF90aGlzJHNjaGVkdWxlJGl0ZW1zMjtcbiAgICAgIGNvbnN0IGluUXVldVBsYXllciA9IHRoaXMuZ2V0QXNzZXRQbGF5ZXIoYXNzZXRJZCk7XG4gICAgICB0aGlzLmxvZyhgYnVmZmVyZWQgdG8gZW5kIG9mIGFzc2V0ICR7aW5RdWV1UGxheWVyfWApO1xuICAgICAgaWYgKCFpblF1ZXVQbGF5ZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gUHJlbG9hZCBhdCBlbmQgb2YgYXNzZXRcbiAgICAgIGNvbnN0IHNjaGVkdWxlSW5kZXggPSB0aGlzLnNjaGVkdWxlLmZpbmRFdmVudEluZGV4KGludGVyc3RpdGlhbC5pZGVudGlmaWVyKTtcbiAgICAgIGNvbnN0IGl0ZW0gPSAoX3RoaXMkc2NoZWR1bGUkaXRlbXMyID0gdGhpcy5zY2hlZHVsZS5pdGVtcykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHNjaGVkdWxlJGl0ZW1zMltzY2hlZHVsZUluZGV4XTtcbiAgICAgIGlmICh0aGlzLmlzSW50ZXJzdGl0aWFsKGl0ZW0pKSB7XG4gICAgICAgIGNvbnN0IGFzc2V0TGlzdEluZGV4ID0gaW50ZXJzdGl0aWFsLmZpbmRBc3NldEluZGV4KGFzc2V0SXRlbSk7XG4gICAgICAgIGNvbnN0IG5leHRBc3NldEluZGV4ID0gZ2V0TmV4dEFzc2V0SW5kZXgoaW50ZXJzdGl0aWFsLCBhc3NldExpc3RJbmRleCk7XG4gICAgICAgIGlmICghaW50ZXJzdGl0aWFsLmlzQXNzZXRQYXN0UGxheW91dExpbWl0KG5leHRBc3NldEluZGV4KSkge1xuICAgICAgICAgIHRoaXMuYnVmZmVyZWRUb0l0ZW0oaXRlbSwgbmV4dEFzc2V0SW5kZXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfdGhpcyRzY2hlZHVsZSRpdGVtczM7XG4gICAgICAgICAgY29uc3QgbmV4dEl0ZW0gPSAoX3RoaXMkc2NoZWR1bGUkaXRlbXMzID0gdGhpcy5zY2hlZHVsZS5pdGVtcykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHNjaGVkdWxlJGl0ZW1zM1tzY2hlZHVsZUluZGV4ICsgMV07XG4gICAgICAgICAgaWYgKG5leHRJdGVtKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcmVkVG9JdGVtKG5leHRJdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHBsYXllci5vbihFdmVudHMuQlVGRkVSRURfVE9fRU5ELCBidWZmZXJlZFRvRW5kKTtcbiAgICBjb25zdCBlbmRlZFdpdGhBc3NldEluZGV4ID0gYXNzZXRJbmRleCA9PiB7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb25zdCBpblF1ZXVQbGF5ZXIgPSB0aGlzLmdldEFzc2V0UGxheWVyKGFzc2V0SWQpO1xuICAgICAgICBpZiAoIWluUXVldVBsYXllcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNob3VsZFBsYXkgPSB0cnVlO1xuICAgICAgICBjb25zdCBzY2hlZHVsZUluZGV4ID0gdGhpcy5zY2hlZHVsZS5maW5kRXZlbnRJbmRleChpbnRlcnN0aXRpYWwuaWRlbnRpZmllcik7XG4gICAgICAgIHRoaXMuYWR2YW5jZUFmdGVyQXNzZXRFbmRlZChpbnRlcnN0aXRpYWwsIHNjaGVkdWxlSW5kZXgsIGFzc2V0SW5kZXgpO1xuICAgICAgfTtcbiAgICB9O1xuICAgIHBsYXllci5vbmNlKEV2ZW50cy5NRURJQV9FTkRFRCwgZW5kZWRXaXRoQXNzZXRJbmRleChhc3NldExpc3RJbmRleCkpO1xuICAgIHBsYXllci5vbmNlKEV2ZW50cy5QTEFZT1VUX0xJTUlUX1JFQUNIRUQsIGVuZGVkV2l0aEFzc2V0SW5kZXgoSW5maW5pdHkpKTtcbiAgICBwbGF5ZXIub24oRXZlbnRzLkVSUk9SLCAoZXZlbnQsIGRhdGEpID0+IHtcbiAgICAgIGNvbnN0IGluUXVldVBsYXllciA9IHRoaXMuZ2V0QXNzZXRQbGF5ZXIoYXNzZXRJZCk7XG4gICAgICBpZiAoZGF0YS5kZXRhaWxzID09PSBFcnJvckRldGFpbHMuQlVGRkVSX1NUQUxMRURfRVJST1IpIHtcbiAgICAgICAgaWYgKGluUXVldVBsYXllciAhPSBudWxsICYmIGluUXVldVBsYXllci5tZWRpYSkge1xuICAgICAgICAgIGNvbnN0IGFzc2V0Q3VycmVudFRpbWUgPSBpblF1ZXVQbGF5ZXIuY3VycmVudFRpbWU7XG4gICAgICAgICAgY29uc3QgZGlzdGFuY2VGcm9tRW5kID0gaW5RdWV1UGxheWVyLmR1cmF0aW9uIC0gYXNzZXRDdXJyZW50VGltZTtcbiAgICAgICAgICBpZiAoYXNzZXRDdXJyZW50VGltZSAmJiBpbnRlcnN0aXRpYWwuYXBwZW5kSW5QbGFjZSAmJiBkaXN0YW5jZUZyb21FbmQgLyBpblF1ZXVQbGF5ZXIubWVkaWEucGxheWJhY2tSYXRlIDwgMC41KSB7XG4gICAgICAgICAgICB0aGlzLmxvZyhgQWR2YW5jaW5nIGJ1ZmZlciBwYXN0IGVuZCBvZiBhc3NldCAke2Fzc2V0SWR9ICR7aW50ZXJzdGl0aWFsfSBhdCAke2luUXVldVBsYXllci5tZWRpYS5jdXJyZW50VGltZX1gKTtcbiAgICAgICAgICAgIGJ1ZmZlcmVkVG9FbmQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53YXJuKGBTdGFsbGVkIGF0ICR7YXNzZXRDdXJyZW50VGltZX0gb2YgJHthc3NldEN1cnJlbnRUaW1lICsgZGlzdGFuY2VGcm9tRW5kfSBpbiBhc3NldCAke2Fzc2V0SWR9ICR7aW50ZXJzdGl0aWFsfWApO1xuICAgICAgICAgICAgdGhpcy5vblRpbWV1cGRhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tCdWZmZXIodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGFuZGxlQXNzZXRJdGVtRXJyb3IoZGF0YSwgaW50ZXJzdGl0aWFsLCB0aGlzLnNjaGVkdWxlLmZpbmRFdmVudEluZGV4KGludGVyc3RpdGlhbC5pZGVudGlmaWVyKSwgYXNzZXRMaXN0SW5kZXgsIGBBc3NldCBwbGF5ZXIgZXJyb3IgJHtkYXRhLmVycm9yfSAke2ludGVyc3RpdGlhbH1gKTtcbiAgICB9KTtcbiAgICBwbGF5ZXIub24oRXZlbnRzLkRFU1RST1lJTkcsICgpID0+IHtcbiAgICAgIGNvbnN0IGluUXVldVBsYXllciA9IHRoaXMuZ2V0QXNzZXRQbGF5ZXIoYXNzZXRJZCk7XG4gICAgICBpZiAoIWluUXVldVBsYXllcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgQXNzZXQgcGxheWVyIGRlc3Ryb3llZCB1bmV4cGVjdGVkbHkgJHthc3NldElkfWApO1xuICAgICAgY29uc3QgZXJyb3JEYXRhID0ge1xuICAgICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5PVEhFUl9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLklOVEVSU1RJVElBTF9BU1NFVF9JVEVNX0VSUk9SLFxuICAgICAgICBlcnJvclxuICAgICAgfTtcbiAgICAgIHRoaXMuaGFuZGxlQXNzZXRJdGVtRXJyb3IoZXJyb3JEYXRhLCBpbnRlcnN0aXRpYWwsIHRoaXMuc2NoZWR1bGUuZmluZEV2ZW50SW5kZXgoaW50ZXJzdGl0aWFsLmlkZW50aWZpZXIpLCBhc3NldExpc3RJbmRleCwgZXJyb3IubWVzc2FnZSk7XG4gICAgfSk7XG4gICAgdGhpcy5sb2coYElOVEVSU1RJVElBTF9BU1NFVF9QTEFZRVJfQ1JFQVRFRCAke2V2ZW50QXNzZXRUb1N0cmluZyhhc3NldEl0ZW0pfWApO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLklOVEVSU1RJVElBTF9BU1NFVF9QTEFZRVJfQ1JFQVRFRCwge1xuICAgICAgYXNzZXQ6IGFzc2V0SXRlbSxcbiAgICAgIGFzc2V0TGlzdEluZGV4LFxuICAgICAgZXZlbnQ6IGludGVyc3RpdGlhbCxcbiAgICAgIHBsYXllclxuICAgIH0pO1xuICAgIHJldHVybiBwbGF5ZXI7XG4gIH1cbiAgY2xlYXJJbnRlcnN0aXRpYWwoaW50ZXJzdGl0aWFsLCB0b1NlZ21lbnQpIHtcbiAgICBpbnRlcnN0aXRpYWwuYXNzZXRMaXN0LmZvckVhY2goYXNzZXQgPT4ge1xuICAgICAgdGhpcy5jbGVhckFzc2V0UGxheWVyKGFzc2V0LmlkZW50aWZpZXIsIHRvU2VnbWVudCk7XG4gICAgfSk7XG4gICAgLy8gUmVtb3ZlIGFzc2V0IGxpc3QgYW5kIHJlc29sdmVkIGR1cmF0aW9uXG4gICAgaW50ZXJzdGl0aWFsLnJlc2V0KCk7XG4gIH1cbiAgcmVzZXRBc3NldFBsYXllcihhc3NldElkKSB7XG4gICAgLy8gUmVzZXQgYXNzZXQgcGxheWVyIHNvIHRoYXQgaXQncyB0aW1lbGluZSBjYW4gYmUgYWRqdXN0ZWQgd2l0aG91dCByZWxvYWRpbmcgdGhlIE1WUFxuICAgIGNvbnN0IHBsYXllckluZGV4ID0gdGhpcy5nZXRBc3NldFBsYXllclF1ZXVlSW5kZXgoYXNzZXRJZCk7XG4gICAgaWYgKHBsYXllckluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5sb2coYHJlc2V0IGFzc2V0IHBsYXllciBcIiR7YXNzZXRJZH1cIiBhZnRlciBlcnJvcmApO1xuICAgICAgY29uc3QgcGxheWVyID0gdGhpcy5wbGF5ZXJRdWV1ZVtwbGF5ZXJJbmRleF07XG4gICAgICB0aGlzLnRyYW5zZmVyTWVkaWFGcm9tUGxheWVyKHBsYXllciwgbnVsbCk7XG4gICAgICBwbGF5ZXIucmVzZXREZXRhaWxzKCk7XG4gICAgfVxuICB9XG4gIGNsZWFyQXNzZXRQbGF5ZXIoYXNzZXRJZCwgdG9TZWdtZW50KSB7XG4gICAgY29uc3QgcGxheWVySW5kZXggPSB0aGlzLmdldEFzc2V0UGxheWVyUXVldWVJbmRleChhc3NldElkKTtcbiAgICBpZiAocGxheWVySW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLmxvZyhgY2xlYXIgYXNzZXQgcGxheWVyIFwiJHthc3NldElkfVwiIHRvU2VnbWVudDogJHt0b1NlZ21lbnQgPyBzZWdtZW50VG9TdHJpbmcodG9TZWdtZW50KSA6IHRvU2VnbWVudH1gKTtcbiAgICAgIGNvbnN0IHBsYXllciA9IHRoaXMucGxheWVyUXVldWVbcGxheWVySW5kZXhdO1xuICAgICAgdGhpcy50cmFuc2Zlck1lZGlhRnJvbVBsYXllcihwbGF5ZXIsIHRvU2VnbWVudCk7XG4gICAgICB0aGlzLnBsYXllclF1ZXVlLnNwbGljZShwbGF5ZXJJbmRleCwgMSk7XG4gICAgICBwbGF5ZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxuICBlbXB0eVBsYXllclF1ZXVlKCkge1xuICAgIGxldCBwbGF5ZXI7XG4gICAgd2hpbGUgKHBsYXllciA9IHRoaXMucGxheWVyUXVldWUucG9wKCkpIHtcbiAgICAgIHBsYXllci5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMucGxheWVyUXVldWUgPSBbXTtcbiAgfVxuICBzdGFydEFzc2V0UGxheWVyKHBsYXllciwgYXNzZXRMaXN0SW5kZXgsIHNjaGVkdWxlSXRlbXMsIHNjaGVkdWxlSW5kZXgsIG1lZGlhKSB7XG4gICAgY29uc3Qge1xuICAgICAgaW50ZXJzdGl0aWFsLFxuICAgICAgYXNzZXRJdGVtLFxuICAgICAgYXNzZXRJZFxuICAgIH0gPSBwbGF5ZXI7XG4gICAgY29uc3QgYXNzZXRMaXN0TGVuZ3RoID0gaW50ZXJzdGl0aWFsLmFzc2V0TGlzdC5sZW5ndGg7XG4gICAgY29uc3QgcGxheWluZ0Fzc2V0ID0gdGhpcy5wbGF5aW5nQXNzZXQ7XG4gICAgdGhpcy5lbmRlZEFzc2V0ID0gbnVsbDtcbiAgICB0aGlzLnBsYXlpbmdBc3NldCA9IGFzc2V0SXRlbTtcbiAgICBpZiAoIXBsYXlpbmdBc3NldCB8fCBwbGF5aW5nQXNzZXQuaWRlbnRpZmllciAhPT0gYXNzZXRJZCkge1xuICAgICAgaWYgKHBsYXlpbmdBc3NldCkge1xuICAgICAgICAvLyBFeGl0aW5nIGFub3RoZXIgSW50ZXJzdGl0aWFsIGFzc2V0XG4gICAgICAgIHRoaXMuY2xlYXJBc3NldFBsYXllcihwbGF5aW5nQXNzZXQuaWRlbnRpZmllciwgc2NoZWR1bGVJdGVtc1tzY2hlZHVsZUluZGV4XSk7XG4gICAgICAgIGRlbGV0ZSBwbGF5aW5nQXNzZXQuZXJyb3I7XG4gICAgICB9XG4gICAgICB0aGlzLmxvZyhgSU5URVJTVElUSUFMX0FTU0VUX1NUQVJURUQgJHthc3NldExpc3RJbmRleCArIDF9LyR7YXNzZXRMaXN0TGVuZ3RofSAke2V2ZW50QXNzZXRUb1N0cmluZyhhc3NldEl0ZW0pfWApO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuSU5URVJTVElUSUFMX0FTU0VUX1NUQVJURUQsIHtcbiAgICAgICAgYXNzZXQ6IGFzc2V0SXRlbSxcbiAgICAgICAgYXNzZXRMaXN0SW5kZXgsXG4gICAgICAgIGV2ZW50OiBpbnRlcnN0aXRpYWwsXG4gICAgICAgIHNjaGVkdWxlOiBzY2hlZHVsZUl0ZW1zLnNsaWNlKDApLFxuICAgICAgICBzY2hlZHVsZUluZGV4LFxuICAgICAgICBwbGF5ZXJcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGRldGFjaCBtZWRpYSBhbmQgYXR0YWNoIHRvIGludGVyc3RpdGlhbCBwbGF5ZXIgaWYgaXQgZG9lcyBub3QgaGF2ZSBhbm90aGVyIGVsZW1lbnQgYXR0YWNoZWRcbiAgICB0aGlzLmJ1ZmZlckFzc2V0UGxheWVyKHBsYXllciwgbWVkaWEpO1xuICB9XG4gIGJ1ZmZlckFzc2V0UGxheWVyKHBsYXllciwgbWVkaWEpIHtcbiAgICB2YXIgX3RoaXMkc2NoZWR1bGUkaXRlbXM0LCBfdGhpcyRkZXRhY2hlZERhdGE1O1xuICAgIGNvbnN0IHtcbiAgICAgIGludGVyc3RpdGlhbCxcbiAgICAgIGFzc2V0SXRlbVxuICAgIH0gPSBwbGF5ZXI7XG4gICAgY29uc3Qgc2NoZWR1bGVJbmRleCA9IHRoaXMuc2NoZWR1bGUuZmluZEV2ZW50SW5kZXgoaW50ZXJzdGl0aWFsLmlkZW50aWZpZXIpO1xuICAgIGNvbnN0IGl0ZW0gPSAoX3RoaXMkc2NoZWR1bGUkaXRlbXM0ID0gdGhpcy5zY2hlZHVsZS5pdGVtcykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHNjaGVkdWxlJGl0ZW1zNFtzY2hlZHVsZUluZGV4XTtcbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZXRCdWZmZXJpbmdJdGVtKGl0ZW0pO1xuICAgIHRoaXMuYnVmZmVyaW5nQXNzZXQgPSBhc3NldEl0ZW07XG4gICAgY29uc3QgYnVmZmVyaW5nUGxheWVyID0gdGhpcy5nZXRCdWZmZXJpbmdQbGF5ZXIoKTtcbiAgICBpZiAoYnVmZmVyaW5nUGxheWVyID09PSBwbGF5ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYXBwZW5kSW5QbGFjZU5leHQgPSBpbnRlcnN0aXRpYWwuYXBwZW5kSW5QbGFjZTtcbiAgICBpZiAoYXBwZW5kSW5QbGFjZU5leHQgJiYgKGJ1ZmZlcmluZ1BsYXllciA9PSBudWxsID8gdm9pZCAwIDogYnVmZmVyaW5nUGxheWVyLmludGVyc3RpdGlhbC5hcHBlbmRJblBsYWNlKSA9PT0gZmFsc2UpIHtcbiAgICAgIC8vIE1lZGlhIGlzIGRldGFjaGVkIGFuZCBub3QgYXZhaWxhYmxlIHRvIGFwcGVuZCBpbiBwbGFjZVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhY3RpdmVUcmFja3MgPSAoYnVmZmVyaW5nUGxheWVyID09IG51bGwgPyB2b2lkIDAgOiBidWZmZXJpbmdQbGF5ZXIudHJhY2tzKSB8fCAoKF90aGlzJGRldGFjaGVkRGF0YTUgPSB0aGlzLmRldGFjaGVkRGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGRldGFjaGVkRGF0YTUudHJhY2tzKSB8fCB0aGlzLnJlcXVpcmVkVHJhY2tzO1xuICAgIGlmIChhcHBlbmRJblBsYWNlTmV4dCAmJiBhc3NldEl0ZW0gIT09IHRoaXMucGxheWluZ0Fzc2V0KSB7XG4gICAgICAvLyBEbyBub3QgYnVmZmVyIGFub3RoZXIgaXRlbSBpZiB0cmFja3MgYXJlIHVua25vd24gb3IgaW5jb21wYXRpYmxlXG4gICAgICBpZiAoIXBsYXllci50cmFja3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGFjdGl2ZVRyYWNrcyAmJiAhaXNDb21wYXRpYmxlVHJhY2tDaGFuZ2UoYWN0aXZlVHJhY2tzLCBwbGF5ZXIudHJhY2tzKSkge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgQXNzZXQgJHtldmVudEFzc2V0VG9TdHJpbmcoYXNzZXRJdGVtKX0gU291cmNlQnVmZmVyIHRyYWNrcyAoJyR7T2JqZWN0LmtleXMocGxheWVyLnRyYWNrcyl9JykgYXJlIG5vdCBjb21wYXRpYmxlIHdpdGggcHJpbWFyeSBjb250ZW50IHRyYWNrcyAoJyR7T2JqZWN0LmtleXMoYWN0aXZlVHJhY2tzKX0nKWApO1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSB7XG4gICAgICAgICAgZmF0YWw6IHRydWUsXG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5PVEhFUl9FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuSU5URVJTVElUSUFMX0FTU0VUX0lURU1fRVJST1IsXG4gICAgICAgICAgZXJyb3JcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYXNzZXRMaXN0SW5kZXggPSBpbnRlcnN0aXRpYWwuZmluZEFzc2V0SW5kZXgoYXNzZXRJdGVtKTtcbiAgICAgICAgdGhpcy5oYW5kbGVBc3NldEl0ZW1FcnJvcihlcnJvckRhdGEsIGludGVyc3RpdGlhbCwgc2NoZWR1bGVJbmRleCwgYXNzZXRMaXN0SW5kZXgsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudHJhbnNmZXJNZWRpYVRvKHBsYXllciwgbWVkaWEpO1xuICB9XG4gIGhhbmRsZUFzc2V0SXRlbUVycm9yKGRhdGEsIGludGVyc3RpdGlhbCwgc2NoZWR1bGVJbmRleCwgYXNzZXRMaXN0SW5kZXgsIGVycm9yTWVzc2FnZSkge1xuICAgIGlmIChkYXRhLmRldGFpbHMgPT09IEVycm9yRGV0YWlscy5CVUZGRVJfU1RBTExFRF9FUlJPUikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhc3NldEl0ZW0gPSBpbnRlcnN0aXRpYWwuYXNzZXRMaXN0W2Fzc2V0TGlzdEluZGV4XTtcbiAgICB0aGlzLndhcm4oYElOVEVSU1RJVElBTF9BU1NFVF9FUlJPUiAke2Fzc2V0SXRlbSA/IGV2ZW50QXNzZXRUb1N0cmluZyhhc3NldEl0ZW0pIDogYXNzZXRJdGVtfSAke2RhdGEuZXJyb3J9YCk7XG4gICAgY29uc3QgYXNzZXRJZCA9IGFzc2V0SXRlbSA9PSBudWxsID8gdm9pZCAwIDogYXNzZXRJdGVtLmlkZW50aWZpZXI7XG4gICAgY29uc3QgcGxheWVySW5kZXggPSB0aGlzLmdldEFzc2V0UGxheWVyUXVldWVJbmRleChhc3NldElkKTtcbiAgICBjb25zdCBwbGF5ZXIgPSB0aGlzLnBsYXllclF1ZXVlW3BsYXllckluZGV4XSB8fCBudWxsO1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5zY2hlZHVsZS5pdGVtcztcbiAgICBjb25zdCBpbnRlcnN0aXRpYWxBc3NldEVycm9yID0gX2V4dGVuZHMoe30sIGRhdGEsIHtcbiAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgIGVycm9yQWN0aW9uOiBjcmVhdGVEb05vdGhpbmdFcnJvckFjdGlvbih0cnVlKSxcbiAgICAgIGFzc2V0OiBhc3NldEl0ZW0sXG4gICAgICBhc3NldExpc3RJbmRleCxcbiAgICAgIGV2ZW50OiBpbnRlcnN0aXRpYWwsXG4gICAgICBzY2hlZHVsZTogaXRlbXMsXG4gICAgICBzY2hlZHVsZUluZGV4LFxuICAgICAgcGxheWVyXG4gICAgfSk7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuSU5URVJTVElUSUFMX0FTU0VUX0VSUk9SLCBpbnRlcnN0aXRpYWxBc3NldEVycm9yKTtcbiAgICBpZiAoIWRhdGEuZmF0YWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGxheWluZ0Fzc2V0ID0gdGhpcy5wbGF5aW5nQXNzZXQ7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICBpZiAoYXNzZXRJdGVtKSB7XG4gICAgICB0aGlzLmNsZWFyQXNzZXRQbGF5ZXIoYXNzZXRJZCwgbnVsbCk7XG4gICAgICBhc3NldEl0ZW0uZXJyb3IgPSBlcnJvcjtcbiAgICB9XG5cbiAgICAvLyBJZiBhbGwgYXNzZXRzIGluIGludGVyc3RpdGlhbCBmYWlsLCBtYXJrIHRoZSBpbnRlcnN0aXRpYWwgd2l0aCBhbiBlcnJvclxuICAgIGlmICghaW50ZXJzdGl0aWFsLmFzc2V0TGlzdC5zb21lKGFzc2V0ID0+ICFhc3NldC5lcnJvcikpIHtcbiAgICAgIGludGVyc3RpdGlhbC5lcnJvciA9IGVycm9yO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZXNldCBsZXZlbCBkZXRhaWxzIGFuZCByZWxvYWQvcGFyc2UgbWVkaWEgcGxheWxpc3RzIHRvIGFsaWduIHdpdGggdXBkYXRlZCBzY2hlZHVsZVxuICAgICAgZm9yIChsZXQgaSA9IGFzc2V0TGlzdEluZGV4OyBpIDwgaW50ZXJzdGl0aWFsLmFzc2V0TGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnJlc2V0QXNzZXRQbGF5ZXIoaW50ZXJzdGl0aWFsLmFzc2V0TGlzdFtpXS5pZGVudGlmaWVyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlU2NoZWR1bGUoKTtcbiAgICB9XG4gICAgaWYgKGludGVyc3RpdGlhbC5lcnJvcikge1xuICAgICAgdGhpcy5wcmltYXJ5RmFsbGJhY2soaW50ZXJzdGl0aWFsKTtcbiAgICB9IGVsc2UgaWYgKHBsYXlpbmdBc3NldCAmJiBwbGF5aW5nQXNzZXQuaWRlbnRpZmllciA9PT0gYXNzZXRJZCkge1xuICAgICAgdGhpcy5hZHZhbmNlQWZ0ZXJBc3NldEVuZGVkKGludGVyc3RpdGlhbCwgc2NoZWR1bGVJbmRleCwgYXNzZXRMaXN0SW5kZXgpO1xuICAgIH1cbiAgfVxuICBwcmltYXJ5RmFsbGJhY2soaW50ZXJzdGl0aWFsKSB7XG4gICAgLy8gRmFsbGJhY2sgdG8gUHJpbWFyeSBieSBvbiBjdXJyZW50IG9yIGZ1dHVyZSBldmVudHMgYnkgdXBkYXRpbmcgc2NoZWR1bGUgdG8gc2tpcCBlcnJvcmVkIGludGVyc3RpdGlhbHMvYXNzZXRzXG4gICAgY29uc3QgZmx1c2hTdGFydCA9IGludGVyc3RpdGlhbC50aW1lbGluZVN0YXJ0O1xuICAgIGNvbnN0IHBsYXlpbmdJdGVtID0gdGhpcy5lZmZlY3RpdmVQbGF5aW5nSXRlbTtcbiAgICAvLyBVcGRhdGUgc2NoZWR1bGUgbm93IHRoYXQgaW50ZXJzdGl0aWFsL2Fzc2V0cyBhcmUgZmxhZ2dlZCB3aXRoIGBlcnJvcmAgZm9yIGZhbGxiYWNrXG4gICAgdGhpcy51cGRhdGVTY2hlZHVsZSgpO1xuICAgIGlmIChwbGF5aW5nSXRlbSkge1xuICAgICAgdGhpcy5sb2coYEZhbGxiYWNrIHRvIHByaW1hcnkgZnJvbSBldmVudCBcIiR7aW50ZXJzdGl0aWFsLmlkZW50aWZpZXJ9XCIgc3RhcnQ6ICR7Zmx1c2hTdGFydH0gcG9zOiAke3RoaXMudGltZWxpbmVQb3N9IHBsYXlpbmc6ICR7cGxheWluZ0l0ZW0gPyBzZWdtZW50VG9TdHJpbmcocGxheWluZ0l0ZW0pIDogJzxub25lPid9IGVycm9yOiAke2ludGVyc3RpdGlhbC5lcnJvcn1gKTtcbiAgICAgIGxldCB0aW1lbGluZVBvcyA9IHRoaXMudGltZWxpbmVQb3M7XG4gICAgICBpZiAodGltZWxpbmVQb3MgPT09IC0xKSB7XG4gICAgICAgIHRpbWVsaW5lUG9zID0gdGhpcy5obHMuc3RhcnRQb3NpdGlvbjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld1BsYXlpbmdJdGVtID0gdGhpcy51cGRhdGVJdGVtKHBsYXlpbmdJdGVtLCB0aW1lbGluZVBvcyk7XG4gICAgICBpZiAodGhpcy5pdGVtc01hdGNoKHBsYXlpbmdJdGVtLCBuZXdQbGF5aW5nSXRlbSkpIHtcbiAgICAgICAgdGhpcy5jbGVhckludGVyc3RpdGlhbChpbnRlcnN0aXRpYWwsIG51bGwpO1xuICAgICAgfVxuICAgICAgaWYgKGludGVyc3RpdGlhbC5hcHBlbmRJblBsYWNlKSB7XG4gICAgICAgIHRoaXMuYXR0YWNoUHJpbWFyeShmbHVzaFN0YXJ0LCBudWxsKTtcbiAgICAgICAgdGhpcy5mbHVzaEZyb250QnVmZmVyKGZsdXNoU3RhcnQpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2NoZWR1bGVJbmRleCA9IHRoaXMuc2NoZWR1bGUuZmluZEl0ZW1JbmRleEF0VGltZSh0aW1lbGluZVBvcyk7XG4gICAgICB0aGlzLnNldFNjaGVkdWxlUG9zaXRpb24oc2NoZWR1bGVJbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2hlY2tTdGFydCgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFzc2V0IExpc3QgbG9hZGluZ1xuICBvbkFzc2V0TGlzdExvYWRlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBfdGhpcyRidWZmZXJpbmdJdGVtMjtcbiAgICBjb25zdCBpbnRlcnN0aXRpYWwgPSBkYXRhLmV2ZW50O1xuICAgIGNvbnN0IGludGVyc3RpdGlhbElkID0gaW50ZXJzdGl0aWFsLmlkZW50aWZpZXI7XG4gICAgY29uc3QgYXNzZXRzID0gZGF0YS5hc3NldExpc3RSZXNwb25zZS5BU1NFVFM7XG4gICAgaWYgKCF0aGlzLnNjaGVkdWxlLmhhc0V2ZW50KGludGVyc3RpdGlhbElkKSkge1xuICAgICAgLy8gSW50ZXJzdGl0aWFsIHdpdGggaWQgd2FzIHJlbW92ZWRcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZXZlbnRTdGFydCA9IGludGVyc3RpdGlhbC50aW1lbGluZVN0YXJ0O1xuICAgIGNvbnN0IHByZXZpb3VzRHVyYXRpb24gPSBpbnRlcnN0aXRpYWwuZHVyYXRpb247XG4gICAgbGV0IHN1bUR1cmF0aW9uID0gMDtcbiAgICBhc3NldHMuZm9yRWFjaCgoYXNzZXQsIGFzc2V0TGlzdEluZGV4KSA9PiB7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IHBhcnNlRmxvYXQoYXNzZXQuRFVSQVRJT04pO1xuICAgICAgdGhpcy5jcmVhdGVBc3NldChpbnRlcnN0aXRpYWwsIGFzc2V0TGlzdEluZGV4LCBzdW1EdXJhdGlvbiwgZXZlbnRTdGFydCArIHN1bUR1cmF0aW9uLCBkdXJhdGlvbiwgYXNzZXQuVVJJKTtcbiAgICAgIHN1bUR1cmF0aW9uICs9IGR1cmF0aW9uO1xuICAgIH0pO1xuICAgIGludGVyc3RpdGlhbC5kdXJhdGlvbiA9IHN1bUR1cmF0aW9uO1xuICAgIHRoaXMubG9nKGBMb2FkZWQgYXNzZXQtbGlzdCB3aXRoIGR1cmF0aW9uOiAke3N1bUR1cmF0aW9ufSAod2FzOiAke3ByZXZpb3VzRHVyYXRpb259KSAke2ludGVyc3RpdGlhbH1gKTtcbiAgICBjb25zdCB3YWl0aW5nSXRlbSA9IHRoaXMud2FpdGluZ0l0ZW07XG4gICAgY29uc3Qgd2FpdGluZ0Zvckl0ZW0gPSAod2FpdGluZ0l0ZW0gPT0gbnVsbCA/IHZvaWQgMCA6IHdhaXRpbmdJdGVtLmV2ZW50LmlkZW50aWZpZXIpID09PSBpbnRlcnN0aXRpYWxJZDtcblxuICAgIC8vIFVwZGF0ZSBzY2hlZHVsZSBub3cgdGhhdCBhc3NldC5EVVJBVElPTihzKSBhcmUgcGFyc2VkXG4gICAgdGhpcy51cGRhdGVTY2hlZHVsZSgpO1xuICAgIGNvbnN0IGJ1ZmZlcmluZ0V2ZW50ID0gKF90aGlzJGJ1ZmZlcmluZ0l0ZW0yID0gdGhpcy5idWZmZXJpbmdJdGVtKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkYnVmZmVyaW5nSXRlbTIuZXZlbnQ7XG5cbiAgICAvLyBJZiBidWZmZXIgcmVhY2hlZCBJbnRlcnN0aXRpYWwsIHN0YXJ0IGJ1ZmZlcmluZyBmaXJzdCBhc3NldFxuICAgIGlmICh3YWl0aW5nRm9ySXRlbSkge1xuICAgICAgdmFyIF90aGlzJHNjaGVkdWxlJGl0ZW1zNTtcbiAgICAgIC8vIEFkdmFuY2Ugc2NoZWR1bGUgd2hlbiB3YWl0aW5nIGZvciBhc3NldCBsaXN0IGRhdGEgdG8gcGxheVxuICAgICAgY29uc3Qgc2NoZWR1bGVJbmRleCA9IHRoaXMuc2NoZWR1bGUuZmluZEV2ZW50SW5kZXgoaW50ZXJzdGl0aWFsSWQpO1xuICAgICAgY29uc3QgaXRlbSA9IChfdGhpcyRzY2hlZHVsZSRpdGVtczUgPSB0aGlzLnNjaGVkdWxlLml0ZW1zKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkc2NoZWR1bGUkaXRlbXM1W3NjaGVkdWxlSW5kZXhdO1xuICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgaWYgKCF0aGlzLnBsYXlpbmdJdGVtICYmIHRoaXMudGltZWxpbmVQb3MgPiBpdGVtLmVuZCkge1xuICAgICAgICAgIC8vIEFiYW5kb24gaWYgbmV3IGR1cmF0aW9uIGlzIHJlZHVjZWQgZW5vdWdoIHRvIGxhbmQgcGxheWJhY2sgaW4gcHJpbWFyeSBzdGFydFxuICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5zY2hlZHVsZS5maW5kSXRlbUluZGV4QXRUaW1lKHRoaXMudGltZWxpbmVQb3MpO1xuICAgICAgICAgIGlmIChpbmRleCAhPT0gc2NoZWR1bGVJbmRleCkge1xuICAgICAgICAgICAgaW50ZXJzdGl0aWFsLmVycm9yID0gbmV3IEVycm9yKGBJbnRlcnN0aXRpYWwgbm8gbG9uZ2VyIHdpdGhpbiBwbGF5YmFjayByYW5nZSAke3RoaXMudGltZWxpbmVQb3N9ICR7aW50ZXJzdGl0aWFsfWApO1xuICAgICAgICAgICAgdGhpcy5wcmltYXJ5RmFsbGJhY2soaW50ZXJzdGl0aWFsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRCdWZmZXJpbmdJdGVtKGl0ZW0pO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRTY2hlZHVsZVBvc2l0aW9uKHNjaGVkdWxlSW5kZXgpO1xuICAgIH0gZWxzZSBpZiAoKGJ1ZmZlcmluZ0V2ZW50ID09IG51bGwgPyB2b2lkIDAgOiBidWZmZXJpbmdFdmVudC5pZGVudGlmaWVyKSA9PT0gaW50ZXJzdGl0aWFsSWQgJiYgYnVmZmVyaW5nRXZlbnQuYXBwZW5kSW5QbGFjZSkge1xuICAgICAgLy8gSWYgYnVmZmVyaW5nIChidXQgbm90IHBsYXliYWNrKSBoYXMgcmVhY2hlZCB0aGlzIGl0ZW0gdHJhbnNmZXIgbWVkaWEtc291cmNlXG4gICAgICBjb25zdCBhc3NldEl0ZW0gPSBpbnRlcnN0aXRpYWwuYXNzZXRMaXN0WzBdO1xuICAgICAgY29uc3QgcGxheWVyID0gdGhpcy5nZXRBc3NldFBsYXllcihhc3NldEl0ZW0uaWRlbnRpZmllcik7XG4gICAgICBjb25zdCBtZWRpYSA9IHRoaXMucHJpbWFyeU1lZGlhO1xuICAgICAgaWYgKGFzc2V0SXRlbSAmJiBwbGF5ZXIgJiYgbWVkaWEpIHtcbiAgICAgICAgdGhpcy5idWZmZXJBc3NldFBsYXllcihwbGF5ZXIsIG1lZGlhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgb25FcnJvcihldmVudCwgZGF0YSkge1xuICAgIHN3aXRjaCAoZGF0YS5kZXRhaWxzKSB7XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5BU1NFVF9MSVNUX1BBUlNJTkdfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5BU1NFVF9MSVNUX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5BU1NFVF9MSVNUX0xPQURfVElNRU9VVDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGludGVyc3RpdGlhbCA9IGRhdGEuaW50ZXJzdGl0aWFsO1xuICAgICAgICAgIGlmIChpbnRlcnN0aXRpYWwpIHtcbiAgICAgICAgICAgIHRoaXMucHJpbWFyeUZhbGxiYWNrKGludGVyc3RpdGlhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfU1RBTExFRF9FUlJPUjpcbiAgICAgICAge1xuICAgICAgICAgIHRoaXMub25UaW1ldXBkYXRlKCk7XG4gICAgICAgICAgdGhpcy5jaGVja0J1ZmZlcih0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBUSUNLX0lOVEVSVkFMJDIgPSA1MDA7IC8vIGhvdyBvZnRlbiB0byB0aWNrIGluIG1zXG5cbmNsYXNzIFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlciBleHRlbmRzIEJhc2VTdHJlYW1Db250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoaGxzLCBmcmFnbWVudFRyYWNrZXIsIGtleUxvYWRlcikge1xuICAgIHN1cGVyKGhscywgZnJhZ21lbnRUcmFja2VyLCBrZXlMb2FkZXIsICdzdWJ0aXRsZS1zdHJlYW0tY29udHJvbGxlcicsIFBsYXlsaXN0TGV2ZWxUeXBlLlNVQlRJVExFKTtcbiAgICB0aGlzLmN1cnJlbnRUcmFja0lkID0gLTE7XG4gICAgdGhpcy50cmFja3NCdWZmZXJlZCA9IFtdO1xuICAgIHRoaXMubWFpbkRldGFpbHMgPSBudWxsO1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICBvbkhhbmRsZXJEZXN0cm95aW5nKCkge1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHN1cGVyLm9uSGFuZGxlckRlc3Ryb3lpbmcoKTtcbiAgICB0aGlzLm1haW5EZXRhaWxzID0gbnVsbDtcbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBzdXBlci5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuU1VCVElUTEVfVFJBQ0tTX1VQREFURUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuU1VCVElUTEVfVFJBQ0tfU1dJVENILCB0aGlzLm9uU3VidGl0bGVUcmFja1N3aXRjaCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5TVUJUSVRMRV9UUkFDS19MT0FERUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB0aGlzLm9uU3VidGl0bGVGcmFnUHJvY2Vzc2VkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgfVxuICB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHN1cGVyLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuU1VCVElUTEVfVFJBQ0tTX1VQREFURUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLlNVQlRJVExFX1RSQUNLX1NXSVRDSCwgdGhpcy5vblN1YnRpdGxlVHJhY2tTd2l0Y2gsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLlNVQlRJVExFX1RSQUNLX0xPQURFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB0aGlzLm9uU3VidGl0bGVGcmFnUHJvY2Vzc2VkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyk7XG4gIH1cbiAgc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24sIHNraXBTZWVrVG9TdGFydFBvc2l0aW9uKSB7XG4gICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIHRoaXMuc2V0SW50ZXJ2YWwoVElDS19JTlRFUlZBTCQyKTtcbiAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IHN0YXJ0UG9zaXRpb24gKyB0aGlzLnRpbWVsaW5lT2Zmc2V0O1xuICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHNraXBTZWVrVG9TdGFydFBvc2l0aW9uID8gLTEgOiBzdGFydFBvc2l0aW9uO1xuICAgIHRoaXMudGljaygpO1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHN1cGVyLm9uTWFuaWZlc3RMb2FkaW5nKCk7XG4gICAgdGhpcy5tYWluRGV0YWlscyA9IG51bGw7XG4gIH1cbiAgb25NZWRpYURldGFjaGluZyhldmVudCwgZGF0YSkge1xuICAgIHRoaXMudHJhY2tzQnVmZmVyZWQgPSBbXTtcbiAgICBzdXBlci5vbk1lZGlhRGV0YWNoaW5nKGV2ZW50LCBkYXRhKTtcbiAgfVxuICBvbkxldmVsTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5tYWluRGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgfVxuICBvblN1YnRpdGxlRnJhZ1Byb2Nlc3NlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWcsXG4gICAgICBzdWNjZXNzXG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKCF0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgaWYgKGlzTWVkaWFGcmFnbWVudChmcmFnKSkge1xuICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IGZyYWc7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICB9XG4gICAgaWYgKCFzdWNjZXNzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlcmVkID0gdGhpcy50cmFja3NCdWZmZXJlZFt0aGlzLmN1cnJlbnRUcmFja0lkXTtcbiAgICBpZiAoIWJ1ZmZlcmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlL3VwZGF0ZSBhIGJ1ZmZlcmVkIGFycmF5IG1hdGNoaW5nIHRoZSBpbnRlcmZhY2UgdXNlZCBieSBCdWZmZXJIZWxwZXIuYnVmZmVyZWRJbmZvXG4gICAgLy8gc28gd2UgY2FuIHJlLXVzZSB0aGUgbG9naWMgdXNlZCB0byBkZXRlY3QgaG93IG11Y2ggaGFzIGJlZW4gYnVmZmVyZWRcbiAgICBsZXQgdGltZVJhbmdlO1xuICAgIGNvbnN0IGZyYWdTdGFydCA9IGZyYWcuc3RhcnQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGZyYWdTdGFydCA+PSBidWZmZXJlZFtpXS5zdGFydCAmJiBmcmFnU3RhcnQgPD0gYnVmZmVyZWRbaV0uZW5kKSB7XG4gICAgICAgIHRpbWVSYW5nZSA9IGJ1ZmZlcmVkW2ldO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZnJhZ0VuZCA9IGZyYWcuc3RhcnQgKyBmcmFnLmR1cmF0aW9uO1xuICAgIGlmICh0aW1lUmFuZ2UpIHtcbiAgICAgIHRpbWVSYW5nZS5lbmQgPSBmcmFnRW5kO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lUmFuZ2UgPSB7XG4gICAgICAgIHN0YXJ0OiBmcmFnU3RhcnQsXG4gICAgICAgIGVuZDogZnJhZ0VuZFxuICAgICAgfTtcbiAgICAgIGJ1ZmZlcmVkLnB1c2godGltZVJhbmdlKTtcbiAgICB9XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIuZnJhZ0J1ZmZlcmVkKGZyYWcpO1xuICAgIHRoaXMuZnJhZ0J1ZmZlcmVkQ29tcGxldGUoZnJhZywgbnVsbCk7XG4gICAgaWYgKHRoaXMubWVkaWEpIHtcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH1cbiAgfVxuICBvbkJ1ZmZlckZsdXNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3RhcnRPZmZzZXQsXG4gICAgICBlbmRPZmZzZXRcbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoc3RhcnRPZmZzZXQgPT09IDAgJiYgZW5kT2Zmc2V0ICE9PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgIGNvbnN0IGVuZE9mZnNldFN1YnRpdGxlcyA9IGVuZE9mZnNldCAtIDE7XG4gICAgICBpZiAoZW5kT2Zmc2V0U3VidGl0bGVzIDw9IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZGF0YS5lbmRPZmZzZXRTdWJ0aXRsZXMgPSBNYXRoLm1heCgwLCBlbmRPZmZzZXRTdWJ0aXRsZXMpO1xuICAgICAgdGhpcy50cmFja3NCdWZmZXJlZC5mb3JFYWNoKGJ1ZmZlcmVkID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXJlZC5sZW5ndGg7KSB7XG4gICAgICAgICAgaWYgKGJ1ZmZlcmVkW2ldLmVuZCA8PSBlbmRPZmZzZXRTdWJ0aXRsZXMpIHtcbiAgICAgICAgICAgIGJ1ZmZlcmVkLnNoaWZ0KCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGJ1ZmZlcmVkW2ldLnN0YXJ0IDwgZW5kT2Zmc2V0U3VidGl0bGVzKSB7XG4gICAgICAgICAgICBidWZmZXJlZFtpXS5zdGFydCA9IGVuZE9mZnNldFN1YnRpdGxlcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudHNJblJhbmdlKHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXRTdWJ0aXRsZXMsIFBsYXlsaXN0TGV2ZWxUeXBlLlNVQlRJVExFKTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiBzb21ldGhpbmcgZ29lcyB3cm9uZywgcHJvY2VlZCB0byBuZXh0IGZyYWcsIGlmIHdlIHdlcmUgcHJvY2Vzc2luZyBvbmUuXG4gIG9uRXJyb3IoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCBmcmFnID0gZGF0YS5mcmFnO1xuICAgIGlmICgoZnJhZyA9PSBudWxsID8gdm9pZCAwIDogZnJhZy50eXBlKSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuU1VCVElUTEUpIHtcbiAgICAgIGlmIChkYXRhLmRldGFpbHMgPT09IEVycm9yRGV0YWlscy5GUkFHX0dBUCkge1xuICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5mcmFnQnVmZmVyZWQoZnJhZywgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5mcmFnQ3VycmVudCkge1xuICAgICAgICB0aGlzLmZyYWdDdXJyZW50LmFib3J0UmVxdWVzdHMoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTdGF0ZS5TVE9QUEVEKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEdvdCBhbGwgbmV3IHN1YnRpdGxlIGxldmVscy5cbiAgb25TdWJ0aXRsZVRyYWNrc1VwZGF0ZWQoZXZlbnQsIHtcbiAgICBzdWJ0aXRsZVRyYWNrc1xuICB9KSB7XG4gICAgaWYgKHRoaXMubGV2ZWxzICYmIHN1YnRpdGxlT3B0aW9uc0lkZW50aWNhbCh0aGlzLmxldmVscywgc3VidGl0bGVUcmFja3MpKSB7XG4gICAgICB0aGlzLmxldmVscyA9IHN1YnRpdGxlVHJhY2tzLm1hcChtZWRpYVBsYXlsaXN0ID0+IG5ldyBMZXZlbChtZWRpYVBsYXlsaXN0KSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudHJhY2tzQnVmZmVyZWQgPSBbXTtcbiAgICB0aGlzLmxldmVscyA9IHN1YnRpdGxlVHJhY2tzLm1hcChtZWRpYVBsYXlsaXN0ID0+IHtcbiAgICAgIGNvbnN0IGxldmVsID0gbmV3IExldmVsKG1lZGlhUGxheWxpc3QpO1xuICAgICAgdGhpcy50cmFja3NCdWZmZXJlZFtsZXZlbC5pZF0gPSBbXTtcbiAgICAgIHJldHVybiBsZXZlbDtcbiAgICB9KTtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudHNJblJhbmdlKDAsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgUGxheWxpc3RMZXZlbFR5cGUuU1VCVElUTEUpO1xuICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICB0aGlzLm1lZGlhQnVmZmVyID0gbnVsbDtcbiAgfVxuICBvblN1YnRpdGxlVHJhY2tTd2l0Y2goZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgX3RoaXMkbGV2ZWxzO1xuICAgIHRoaXMuY3VycmVudFRyYWNrSWQgPSBkYXRhLmlkO1xuICAgIGlmICghKChfdGhpcyRsZXZlbHMgPSB0aGlzLmxldmVscykgIT0gbnVsbCAmJiBfdGhpcyRsZXZlbHMubGVuZ3RoKSB8fCB0aGlzLmN1cnJlbnRUcmFja0lkID09PSAtMSkge1xuICAgICAgdGhpcy5jbGVhckludGVydmFsKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdHJhY2sgaGFzIHRoZSBuZWNlc3NhcnkgZGV0YWlscyB0byBsb2FkIGZyYWdtZW50c1xuICAgIGNvbnN0IGN1cnJlbnRUcmFjayA9IHRoaXMubGV2ZWxzW3RoaXMuY3VycmVudFRyYWNrSWRdO1xuICAgIGlmIChjdXJyZW50VHJhY2sgIT0gbnVsbCAmJiBjdXJyZW50VHJhY2suZGV0YWlscykge1xuICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWFCdWZmZXJUaW1lUmFuZ2VzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1lZGlhQnVmZmVyID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRUcmFjayAmJiB0aGlzLnN0YXRlICE9PSBTdGF0ZS5TVE9QUEVEKSB7XG4gICAgICB0aGlzLnNldEludGVydmFsKFRJQ0tfSU5URVJWQUwkMik7XG4gICAgfVxuICB9XG5cbiAgLy8gR290IGEgbmV3IHNldCBvZiBzdWJ0aXRsZSBmcmFnbWVudHMuXG4gIG9uU3VidGl0bGVUcmFja0xvYWRlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBfdHJhY2skZGV0YWlscztcbiAgICBjb25zdCB7XG4gICAgICBjdXJyZW50VHJhY2tJZCxcbiAgICAgIGxldmVsc1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIGRldGFpbHM6IG5ld0RldGFpbHMsXG4gICAgICBpZDogdHJhY2tJZFxuICAgIH0gPSBkYXRhO1xuICAgIGlmICghbGV2ZWxzKSB7XG4gICAgICB0aGlzLndhcm4oYFN1YnRpdGxlIHRyYWNrcyB3ZXJlIHJlc2V0IHdoaWxlIGxvYWRpbmcgbGV2ZWwgJHt0cmFja0lkfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0cmFjayA9IGxldmVsc1t0cmFja0lkXTtcbiAgICBpZiAodHJhY2tJZCA+PSBsZXZlbHMubGVuZ3RoIHx8ICF0cmFjaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxvZyhgU3VidGl0bGUgdHJhY2sgJHt0cmFja0lkfSBsb2FkZWQgWyR7bmV3RGV0YWlscy5zdGFydFNOfSwke25ld0RldGFpbHMuZW5kU059XSR7bmV3RGV0YWlscy5sYXN0UGFydFNuID8gYFtwYXJ0LSR7bmV3RGV0YWlscy5sYXN0UGFydFNufS0ke25ld0RldGFpbHMubGFzdFBhcnRJbmRleH1dYCA6ICcnfSxkdXJhdGlvbjoke25ld0RldGFpbHMudG90YWxkdXJhdGlvbn1gKTtcbiAgICB0aGlzLm1lZGlhQnVmZmVyID0gdGhpcy5tZWRpYUJ1ZmZlclRpbWVSYW5nZXM7XG4gICAgbGV0IHNsaWRpbmcgPSAwO1xuICAgIGlmIChuZXdEZXRhaWxzLmxpdmUgfHwgKF90cmFjayRkZXRhaWxzID0gdHJhY2suZGV0YWlscykgIT0gbnVsbCAmJiBfdHJhY2skZGV0YWlscy5saXZlKSB7XG4gICAgICBpZiAobmV3RGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBtYWluRGV0YWlscyA9IHRoaXMubWFpbkRldGFpbHM7XG4gICAgICBpZiAoIW1haW5EZXRhaWxzKSB7XG4gICAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1haW5TbGlkaW5nU3RhcnRGcmFnbWVudCA9IG1haW5EZXRhaWxzLmZyYWdtZW50c1swXTtcbiAgICAgIGlmICghdHJhY2suZGV0YWlscykge1xuICAgICAgICBpZiAobmV3RGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUgJiYgbWFpbkRldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgICAgICAgYWxpZ25NZWRpYVBsYXlsaXN0QnlQRFQobmV3RGV0YWlscywgbWFpbkRldGFpbHMpO1xuICAgICAgICAgIHNsaWRpbmcgPSBuZXdEZXRhaWxzLmZyYWdtZW50U3RhcnQ7XG4gICAgICAgIH0gZWxzZSBpZiAobWFpblNsaWRpbmdTdGFydEZyYWdtZW50KSB7XG4gICAgICAgICAgLy8gbGluZSB1cCBsaXZlIHBsYXlsaXN0IHdpdGggbWFpbiBzbyB0aGF0IGZyYWdtZW50cyBpbiByYW5nZSBhcmUgbG9hZGVkXG4gICAgICAgICAgc2xpZGluZyA9IG1haW5TbGlkaW5nU3RhcnRGcmFnbWVudC5zdGFydDtcbiAgICAgICAgICBhZGRTbGlkaW5nKG5ld0RldGFpbHMsIHNsaWRpbmcpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX3RoaXMkbGV2ZWxMYXN0TG9hZGVkO1xuICAgICAgICBzbGlkaW5nID0gdGhpcy5hbGlnblBsYXlsaXN0cyhuZXdEZXRhaWxzLCB0cmFjay5kZXRhaWxzLCAoX3RoaXMkbGV2ZWxMYXN0TG9hZGVkID0gdGhpcy5sZXZlbExhc3RMb2FkZWQpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRsZXZlbExhc3RMb2FkZWQuZGV0YWlscyk7XG4gICAgICAgIGlmIChzbGlkaW5nID09PSAwICYmIG1haW5TbGlkaW5nU3RhcnRGcmFnbWVudCkge1xuICAgICAgICAgIC8vIHJlYWxpZ24gd2l0aCBtYWluIHdoZW4gdGhlcmUgaXMgbm8gb3ZlcmxhcCB3aXRoIGxhc3QgcmVmcmVzaFxuICAgICAgICAgIHNsaWRpbmcgPSBtYWluU2xpZGluZ1N0YXJ0RnJhZ21lbnQuc3RhcnQ7XG4gICAgICAgICAgYWRkU2xpZGluZyhuZXdEZXRhaWxzLCBzbGlkaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gY29tcHV0ZSBzdGFydCBwb3NpdGlvbiBpZiB3ZSBhcmUgYWxpZ25lZCB3aXRoIHRoZSBtYWluIHBsYXlsaXN0XG4gICAgICBpZiAobWFpbkRldGFpbHMgJiYgIXRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhcnRQb3NpdGlvbihtYWluRGV0YWlscywgc2xpZGluZyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRyYWNrLmRldGFpbHMgPSBuZXdEZXRhaWxzO1xuICAgIHRoaXMubGV2ZWxMYXN0TG9hZGVkID0gdHJhY2s7XG4gICAgaWYgKHRyYWNrSWQgIT09IGN1cnJlbnRUcmFja0lkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLlNVQlRJVExFX1RSQUNLX1VQREFURUQsIHtcbiAgICAgIGRldGFpbHM6IG5ld0RldGFpbHMsXG4gICAgICBpZDogdHJhY2tJZCxcbiAgICAgIGdyb3VwSWQ6IGRhdGEuZ3JvdXBJZFxuICAgIH0pO1xuXG4gICAgLy8gdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgIHRoaXMudGljaygpO1xuXG4gICAgLy8gSWYgcGxheWxpc3QgaXMgbWlzYWxpZ25lZCBiZWNhdXNlIG9mIGJhZCBQRFQgb3IgZHJpZnQsIGRlbGV0ZSBkZXRhaWxzIHRvIHJlc3luYyB3aXRoIG1haW4gb24gcmVsb2FkXG4gICAgaWYgKG5ld0RldGFpbHMubGl2ZSAmJiAhdGhpcy5mcmFnQ3VycmVudCAmJiB0aGlzLm1lZGlhICYmIHRoaXMuc3RhdGUgPT09IFN0YXRlLklETEUpIHtcbiAgICAgIGNvbnN0IGZvdW5kRnJhZyA9IGZpbmRGcmFnbWVudEJ5UFRTKG51bGwsIG5ld0RldGFpbHMuZnJhZ21lbnRzLCB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lLCAwKTtcbiAgICAgIGlmICghZm91bmRGcmFnKSB7XG4gICAgICAgIHRoaXMud2FybignU3VidGl0bGUgcGxheWxpc3Qgbm90IGFsaWduZWQgd2l0aCBwbGF5YmFjaycpO1xuICAgICAgICB0cmFjay5kZXRhaWxzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfaGFuZGxlRnJhZ21lbnRMb2FkQ29tcGxldGUoZnJhZ0xvYWRlZERhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnLFxuICAgICAgcGF5bG9hZFxuICAgIH0gPSBmcmFnTG9hZGVkRGF0YTtcbiAgICBjb25zdCBkZWNyeXB0RGF0YSA9IGZyYWcuZGVjcnlwdGRhdGE7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgaWYgKHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGNoZWNrIHRvIHNlZSBpZiB0aGUgcGF5bG9hZCBuZWVkcyB0byBiZSBkZWNyeXB0ZWRcbiAgICBpZiAocGF5bG9hZCAmJiBwYXlsb2FkLmJ5dGVMZW5ndGggPiAwICYmIGRlY3J5cHREYXRhICE9IG51bGwgJiYgZGVjcnlwdERhdGEua2V5ICYmIGRlY3J5cHREYXRhLml2ICYmIGlzRnVsbFNlZ21lbnRFbmNyeXB0aW9uKGRlY3J5cHREYXRhLm1ldGhvZCkpIHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgLy8gZGVjcnlwdCB0aGUgc3VidGl0bGVzXG4gICAgICB0aGlzLmRlY3J5cHRlci5kZWNyeXB0KG5ldyBVaW50OEFycmF5KHBheWxvYWQpLCBkZWNyeXB0RGF0YS5rZXkuYnVmZmVyLCBkZWNyeXB0RGF0YS5pdi5idWZmZXIsIGdldEFlc01vZGVGcm9tRnVsbFNlZ21lbnRNZXRob2QoZGVjcnlwdERhdGEubWV0aG9kKSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19ERUNSWVBUX0VSUk9SLFxuICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogZXJyLFxuICAgICAgICAgIHJlYXNvbjogZXJyLm1lc3NhZ2UsXG4gICAgICAgICAgZnJhZ1xuICAgICAgICB9KTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfSkudGhlbihkZWNyeXB0ZWREYXRhID0+IHtcbiAgICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuRlJBR19ERUNSWVBURUQsIHtcbiAgICAgICAgICBmcmFnLFxuICAgICAgICAgIHBheWxvYWQ6IGRlY3J5cHRlZERhdGEsXG4gICAgICAgICAgc3RhdHM6IHtcbiAgICAgICAgICAgIHRzdGFydDogc3RhcnRUaW1lLFxuICAgICAgICAgICAgdGRlY3J5cHQ6IGVuZFRpbWVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgdGhpcy53YXJuKGAke2Vyci5uYW1lfTogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZG9UaWNrKCkge1xuICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5JRExFKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGN1cnJlbnRUcmFja0lkLFxuICAgICAgICBsZXZlbHNcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgY29uc3QgdHJhY2sgPSBsZXZlbHMgPT0gbnVsbCA/IHZvaWQgMCA6IGxldmVsc1tjdXJyZW50VHJhY2tJZF07XG4gICAgICBpZiAoIXRyYWNrIHx8ICFsZXZlbHMubGVuZ3RoIHx8ICF0cmFjay5kZXRhaWxzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLndhaXRGb3JMaXZlKHRyYWNrKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbmZpZ1xuICAgICAgfSA9IHRoaXM7XG4gICAgICBjb25zdCBjdXJyZW50VGltZSA9IHRoaXMuZ2V0TG9hZFBvc2l0aW9uKCk7XG4gICAgICBjb25zdCBidWZmZXJlZEluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVyZWRJbmZvKHRoaXMudHJhY2tzQnVmZmVyZWRbdGhpcy5jdXJyZW50VHJhY2tJZF0gfHwgW10sIGN1cnJlbnRUaW1lLCBjb25maWcubWF4QnVmZmVySG9sZSk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGVuZDogdGFyZ2V0QnVmZmVyVGltZSxcbiAgICAgICAgbGVuOiBidWZmZXJMZW5cbiAgICAgIH0gPSBidWZmZXJlZEluZm87XG4gICAgICBjb25zdCB0cmFja0RldGFpbHMgPSB0cmFjay5kZXRhaWxzO1xuICAgICAgY29uc3QgbWF4QnVmTGVuID0gdGhpcy5obHMubWF4QnVmZmVyTGVuZ3RoICsgdHJhY2tEZXRhaWxzLmxldmVsVGFyZ2V0RHVyYXRpb247XG4gICAgICBpZiAoYnVmZmVyTGVuID4gbWF4QnVmTGVuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZyYWdtZW50cyA9IHRyYWNrRGV0YWlscy5mcmFnbWVudHM7XG4gICAgICBjb25zdCBmcmFnTGVuID0gZnJhZ21lbnRzLmxlbmd0aDtcbiAgICAgIGNvbnN0IGVuZCA9IHRyYWNrRGV0YWlscy5lZGdlO1xuICAgICAgbGV0IGZvdW5kRnJhZyA9IG51bGw7XG4gICAgICBjb25zdCBmcmFnUHJldmlvdXMgPSB0aGlzLmZyYWdQcmV2aW91cztcbiAgICAgIGlmICh0YXJnZXRCdWZmZXJUaW1lIDwgZW5kKSB7XG4gICAgICAgIGNvbnN0IHRvbGVyYW5jZSA9IGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlO1xuICAgICAgICBjb25zdCBsb29rdXBUb2xlcmFuY2UgPSB0YXJnZXRCdWZmZXJUaW1lID4gZW5kIC0gdG9sZXJhbmNlID8gMCA6IHRvbGVyYW5jZTtcbiAgICAgICAgZm91bmRGcmFnID0gZmluZEZyYWdtZW50QnlQVFMoZnJhZ1ByZXZpb3VzLCBmcmFnbWVudHMsIE1hdGgubWF4KGZyYWdtZW50c1swXS5zdGFydCwgdGFyZ2V0QnVmZmVyVGltZSksIGxvb2t1cFRvbGVyYW5jZSk7XG4gICAgICAgIGlmICghZm91bmRGcmFnICYmIGZyYWdQcmV2aW91cyAmJiBmcmFnUHJldmlvdXMuc3RhcnQgPCBmcmFnbWVudHNbMF0uc3RhcnQpIHtcbiAgICAgICAgICBmb3VuZEZyYWcgPSBmcmFnbWVudHNbMF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvdW5kRnJhZyA9IGZyYWdtZW50c1tmcmFnTGVuIC0gMV07XG4gICAgICB9XG4gICAgICBmb3VuZEZyYWcgPSB0aGlzLmZpbHRlclJlcGxhY2VkUHJpbWFyeShmb3VuZEZyYWcsIHRyYWNrLmRldGFpbHMpO1xuICAgICAgaWYgKCFmb3VuZEZyYWcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gTG9hZCBlYXJsaWVyIGZyYWdtZW50IGluIHNhbWUgZGlzY29udGludWl0eSB0byBtYWtlIHVwIGZvciBtaXNhbGlnbmVkIHBsYXlsaXN0cyBhbmQgY3VlcyB0aGF0IGV4dGVuZCBiZXlvbmQgZW5kIG9mIHNlZ21lbnRcbiAgICAgIGNvbnN0IGN1clNOSWR4ID0gZm91bmRGcmFnLnNuIC0gdHJhY2tEZXRhaWxzLnN0YXJ0U047XG4gICAgICBjb25zdCBwcmV2RnJhZyA9IGZyYWdtZW50c1tjdXJTTklkeCAtIDFdO1xuICAgICAgaWYgKHByZXZGcmFnICYmIHByZXZGcmFnLmNjID09PSBmb3VuZEZyYWcuY2MgJiYgdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUocHJldkZyYWcpID09PSBGcmFnbWVudFN0YXRlLk5PVF9MT0FERUQpIHtcbiAgICAgICAgZm91bmRGcmFnID0gcHJldkZyYWc7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZm91bmRGcmFnKSA9PT0gRnJhZ21lbnRTdGF0ZS5OT1RfTE9BREVEKSB7XG4gICAgICAgIC8vIG9ubHkgbG9hZCBpZiBmcmFnbWVudCBpcyBub3QgbG9hZGVkXG4gICAgICAgIGNvbnN0IGZyYWdUb0xvYWQgPSB0aGlzLm1hcFRvSW5pdEZyYWdXaGVuUmVxdWlyZWQoZm91bmRGcmFnKTtcbiAgICAgICAgaWYgKGZyYWdUb0xvYWQpIHtcbiAgICAgICAgICB0aGlzLmxvYWRGcmFnbWVudChmcmFnVG9Mb2FkLCB0cmFjaywgdGFyZ2V0QnVmZmVyVGltZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbG9hZEZyYWdtZW50KGZyYWcsIGxldmVsLCB0YXJnZXRCdWZmZXJUaW1lKSB7XG4gICAgaWYgKCFpc01lZGlhRnJhZ21lbnQoZnJhZykpIHtcbiAgICAgIHRoaXMuX2xvYWRJbml0U2VnbWVudChmcmFnLCBsZXZlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLmxvYWRGcmFnbWVudChmcmFnLCBsZXZlbCwgdGFyZ2V0QnVmZmVyVGltZSk7XG4gICAgfVxuICB9XG4gIGdldCBtZWRpYUJ1ZmZlclRpbWVSYW5nZXMoKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXJhYmxlSW5zdGFuY2UodGhpcy50cmFja3NCdWZmZXJlZFt0aGlzLmN1cnJlbnRUcmFja0lkXSB8fCBbXSk7XG4gIH1cbn1cbmNsYXNzIEJ1ZmZlcmFibGVJbnN0YW5jZSB7XG4gIGNvbnN0cnVjdG9yKHRpbWVyYW5nZXMpIHtcbiAgICB0aGlzLmJ1ZmZlcmVkID0gdm9pZCAwO1xuICAgIGNvbnN0IGdldFJhbmdlID0gKG5hbWUsIGluZGV4LCBsZW5ndGgpID0+IHtcbiAgICAgIGluZGV4ID0gaW5kZXggPj4+IDA7XG4gICAgICBpZiAoaW5kZXggPiBsZW5ndGggLSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oYEZhaWxlZCB0byBleGVjdXRlICcke25hbWV9JyBvbiAnVGltZVJhbmdlcyc6IFRoZSBpbmRleCBwcm92aWRlZCAoJHtpbmRleH0pIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbWF4aW11bSBib3VuZCAoJHtsZW5ndGh9KWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRpbWVyYW5nZXNbaW5kZXhdW25hbWVdO1xuICAgIH07XG4gICAgdGhpcy5idWZmZXJlZCA9IHtcbiAgICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aW1lcmFuZ2VzLmxlbmd0aDtcbiAgICAgIH0sXG4gICAgICBlbmQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGdldFJhbmdlKCdlbmQnLCBpbmRleCwgdGltZXJhbmdlcy5sZW5ndGgpO1xuICAgICAgfSxcbiAgICAgIHN0YXJ0KGluZGV4KSB7XG4gICAgICAgIHJldHVybiBnZXRSYW5nZSgnc3RhcnQnLCBpbmRleCwgdGltZXJhbmdlcy5sZW5ndGgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKlxuICogVGhpcyBjb2RlIHdhcyBwb3J0ZWQgZnJvbSB0aGUgZGFzaC5qcyBwcm9qZWN0IGF0OlxuICogICBodHRwczovL2dpdGh1Yi5jb20vRGFzaC1JbmR1c3RyeS1Gb3J1bS9kYXNoLmpzL2Jsb2IvZGV2ZWxvcG1lbnQvZXh0ZXJuYWxzL2NlYTYwOC1wYXJzZXIuanNcbiAqICAgaHR0cHM6Ly9naXRodWIuY29tL0Rhc2gtSW5kdXN0cnktRm9ydW0vZGFzaC5qcy9jb21taXQvODI2OWIyNmE3NjFlMDg1M2JiMjFkNzg3ODBlZDk0NTE0NGVjZGQ0ZCNkaWZmLTcxYmMyOTVhMmQ2YjZiNzA5M2ExZDMyOTBkNTNhNGIyXG4gKlxuICogVGhlIG9yaWdpbmFsIGNvcHlyaWdodCBhcHBlYXJzIGJlbG93OlxuICpcbiAqIFRoZSBjb3B5cmlnaHQgaW4gdGhpcyBzb2Z0d2FyZSBpcyBiZWluZyBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGUgQlNEIExpY2Vuc2UsXG4gKiBpbmNsdWRlZCBiZWxvdy4gVGhpcyBzb2Z0d2FyZSBtYXkgYmUgc3ViamVjdCB0byBvdGhlciB0aGlyZCBwYXJ0eSBhbmQgY29udHJpYnV0b3JcbiAqIHJpZ2h0cywgaW5jbHVkaW5nIHBhdGVudCByaWdodHMsIGFuZCBubyBzdWNoIHJpZ2h0cyBhcmUgZ3JhbnRlZCB1bmRlciB0aGlzIGxpY2Vuc2UuXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LTIwMTYsIERBU0ggSW5kdXN0cnkgRm9ydW0uXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXG4gKiBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gKiAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gKiAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3JcbiAqICBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICogIDIuIE5laXRoZXIgdGhlIG5hbWUgb2YgRGFzaCBJbmR1c3RyeSBGb3J1bSBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbiAqICB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBBUyBJUyBBTkQgQU5ZXG4gKiAgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuICogIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC5cbiAqICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULFxuICogIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVRcbiAqICBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiAgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksXG4gKiAgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKVxuICogIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4gKiAgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cbi8qKlxuICogIEV4Y2VwdGlvbnMgZnJvbSByZWd1bGFyIEFTQ0lJLiBDb2RlUG9pbnRzIGFyZSBtYXBwZWQgdG8gVVRGLTE2IGNvZGVzXG4gKi9cblxuY29uc3Qgc3BlY2lhbENlYTYwOENoYXJzQ29kZXMgPSB7XG4gIDB4MmE6IDB4ZTEsXG4gIC8vIGxvd2VyY2FzZSBhLCBhY3V0ZSBhY2NlbnRcbiAgMHg1YzogMHhlOSxcbiAgLy8gbG93ZXJjYXNlIGUsIGFjdXRlIGFjY2VudFxuICAweDVlOiAweGVkLFxuICAvLyBsb3dlcmNhc2UgaSwgYWN1dGUgYWNjZW50XG4gIDB4NWY6IDB4ZjMsXG4gIC8vIGxvd2VyY2FzZSBvLCBhY3V0ZSBhY2NlbnRcbiAgMHg2MDogMHhmYSxcbiAgLy8gbG93ZXJjYXNlIHUsIGFjdXRlIGFjY2VudFxuICAweDdiOiAweGU3LFxuICAvLyBsb3dlcmNhc2UgYyB3aXRoIGNlZGlsbGFcbiAgMHg3YzogMHhmNyxcbiAgLy8gZGl2aXNpb24gc3ltYm9sXG4gIDB4N2Q6IDB4ZDEsXG4gIC8vIHVwcGVyY2FzZSBOIHRpbGRlXG4gIDB4N2U6IDB4ZjEsXG4gIC8vIGxvd2VyY2FzZSBuIHRpbGRlXG4gIDB4N2Y6IDB4MjU4OCxcbiAgLy8gRnVsbCBibG9ja1xuICAvLyBUSElTIEJMT0NLIElOQ0xVREVTIFRIRSAxNiBFWFRFTkRFRCAoVFdPLUJZVEUpIExJTkUgMjEgQ0hBUkFDVEVSU1xuICAvLyBUSEFUIENPTUUgRlJPTSBISSBCWVRFPTB4MTEgQU5EIExPVyBCRVRXRUVOIDB4MzAgQU5EIDB4M0ZcbiAgLy8gVEhJUyBNRUFOUyBUSEFUIFxceDUwIE1VU1QgQkUgQURERUQgVE8gVEhFIFZBTFVFU1xuICAweDgwOiAweGFlLFxuICAvLyBSZWdpc3RlcmVkIHN5bWJvbCAoUilcbiAgMHg4MTogMHhiMCxcbiAgLy8gZGVncmVlIHNpZ25cbiAgMHg4MjogMHhiZCxcbiAgLy8gMS8yIHN5bWJvbFxuICAweDgzOiAweGJmLFxuICAvLyBJbnZlcnRlZCAob3BlbikgcXVlc3Rpb24gbWFya1xuICAweDg0OiAweDIxMjIsXG4gIC8vIFRyYWRlbWFyayBzeW1ib2wgKFRNKVxuICAweDg1OiAweGEyLFxuICAvLyBDZW50cyBzeW1ib2xcbiAgMHg4NjogMHhhMyxcbiAgLy8gUG91bmRzIHN0ZXJsaW5nXG4gIDB4ODc6IDB4MjY2YSxcbiAgLy8gTXVzaWMgOCd0aCBub3RlXG4gIDB4ODg6IDB4ZTAsXG4gIC8vIGxvd2VyY2FzZSBhLCBncmF2ZSBhY2NlbnRcbiAgMHg4OTogMHgyMCxcbiAgLy8gdHJhbnNwYXJlbnQgc3BhY2UgKHJlZ3VsYXIpXG4gIDB4OGE6IDB4ZTgsXG4gIC8vIGxvd2VyY2FzZSBlLCBncmF2ZSBhY2NlbnRcbiAgMHg4YjogMHhlMixcbiAgLy8gbG93ZXJjYXNlIGEsIGNpcmN1bWZsZXggYWNjZW50XG4gIDB4OGM6IDB4ZWEsXG4gIC8vIGxvd2VyY2FzZSBlLCBjaXJjdW1mbGV4IGFjY2VudFxuICAweDhkOiAweGVlLFxuICAvLyBsb3dlcmNhc2UgaSwgY2lyY3VtZmxleCBhY2NlbnRcbiAgMHg4ZTogMHhmNCxcbiAgLy8gbG93ZXJjYXNlIG8sIGNpcmN1bWZsZXggYWNjZW50XG4gIDB4OGY6IDB4ZmIsXG4gIC8vIGxvd2VyY2FzZSB1LCBjaXJjdW1mbGV4IGFjY2VudFxuICAvLyBUSElTIEJMT0NLIElOQ0xVREVTIFRIRSAzMiBFWFRFTkRFRCAoVFdPLUJZVEUpIExJTkUgMjEgQ0hBUkFDVEVSU1xuICAvLyBUSEFUIENPTUUgRlJPTSBISSBCWVRFPTB4MTIgQU5EIExPVyBCRVRXRUVOIDB4MjAgQU5EIDB4M0ZcbiAgMHg5MDogMHhjMSxcbiAgLy8gY2FwaXRhbCBsZXR0ZXIgQSB3aXRoIGFjdXRlXG4gIDB4OTE6IDB4YzksXG4gIC8vIGNhcGl0YWwgbGV0dGVyIEUgd2l0aCBhY3V0ZVxuICAweDkyOiAweGQzLFxuICAvLyBjYXBpdGFsIGxldHRlciBPIHdpdGggYWN1dGVcbiAgMHg5MzogMHhkYSxcbiAgLy8gY2FwaXRhbCBsZXR0ZXIgVSB3aXRoIGFjdXRlXG4gIDB4OTQ6IDB4ZGMsXG4gIC8vIGNhcGl0YWwgbGV0dGVyIFUgd2l0aCBkaWFyZXNpc1xuICAweDk1OiAweGZjLFxuICAvLyBsb3dlcmNhc2UgbGV0dGVyIFUgd2l0aCBkaWFlcmVzaXNcbiAgMHg5NjogMHgyMDE4LFxuICAvLyBvcGVuaW5nIHNpbmdsZSBxdW90ZVxuICAweDk3OiAweGExLFxuICAvLyBpbnZlcnRlZCBleGNsYW1hdGlvbiBtYXJrXG4gIDB4OTg6IDB4MmEsXG4gIC8vIGFzdGVyaXNrXG4gIDB4OTk6IDB4MjAxOSxcbiAgLy8gY2xvc2luZyBzaW5nbGUgcXVvdGVcbiAgMHg5YTogMHgyNTAxLFxuICAvLyBib3ggZHJhd2luZ3MgaGVhdnkgaG9yaXpvbnRhbFxuICAweDliOiAweGE5LFxuICAvLyBjb3B5cmlnaHQgc2lnblxuICAweDljOiAweDIxMjAsXG4gIC8vIFNlcnZpY2UgbWFya1xuICAweDlkOiAweDIwMjIsXG4gIC8vIChyb3VuZCkgYnVsbGV0XG4gIDB4OWU6IDB4MjAxYyxcbiAgLy8gTGVmdCBkb3VibGUgcXVvdGF0aW9uIG1hcmtcbiAgMHg5ZjogMHgyMDFkLFxuICAvLyBSaWdodCBkb3VibGUgcXVvdGF0aW9uIG1hcmtcbiAgMHhhMDogMHhjMCxcbiAgLy8gdXBwZXJjYXNlIEEsIGdyYXZlIGFjY2VudFxuICAweGExOiAweGMyLFxuICAvLyB1cHBlcmNhc2UgQSwgY2lyY3VtZmxleFxuICAweGEyOiAweGM3LFxuICAvLyB1cHBlcmNhc2UgQyB3aXRoIGNlZGlsbGFcbiAgMHhhMzogMHhjOCxcbiAgLy8gdXBwZXJjYXNlIEUsIGdyYXZlIGFjY2VudFxuICAweGE0OiAweGNhLFxuICAvLyB1cHBlcmNhc2UgRSwgY2lyY3VtZmxleFxuICAweGE1OiAweGNiLFxuICAvLyBjYXBpdGFsIGxldHRlciBFIHdpdGggZGlhcmVzaXNcbiAgMHhhNjogMHhlYixcbiAgLy8gbG93ZXJjYXNlIGxldHRlciBlIHdpdGggZGlhcmVzaXNcbiAgMHhhNzogMHhjZSxcbiAgLy8gdXBwZXJjYXNlIEksIGNpcmN1bWZsZXhcbiAgMHhhODogMHhjZixcbiAgLy8gdXBwZXJjYXNlIEksIHdpdGggZGlhcmVzaXNcbiAgMHhhOTogMHhlZixcbiAgLy8gbG93ZXJjYXNlIGksIHdpdGggZGlhcmVzaXNcbiAgMHhhYTogMHhkNCxcbiAgLy8gdXBwZXJjYXNlIE8sIGNpcmN1bWZsZXhcbiAgMHhhYjogMHhkOSxcbiAgLy8gdXBwZXJjYXNlIFUsIGdyYXZlIGFjY2VudFxuICAweGFjOiAweGY5LFxuICAvLyBsb3dlcmNhc2UgdSwgZ3JhdmUgYWNjZW50XG4gIDB4YWQ6IDB4ZGIsXG4gIC8vIHVwcGVyY2FzZSBVLCBjaXJjdW1mbGV4XG4gIDB4YWU6IDB4YWIsXG4gIC8vIGxlZnQtcG9pbnRpbmcgZG91YmxlIGFuZ2xlIHF1b3RhdGlvbiBtYXJrXG4gIDB4YWY6IDB4YmIsXG4gIC8vIHJpZ2h0LXBvaW50aW5nIGRvdWJsZSBhbmdsZSBxdW90YXRpb24gbWFya1xuICAvLyBUSElTIEJMT0NLIElOQ0xVREVTIFRIRSAzMiBFWFRFTkRFRCAoVFdPLUJZVEUpIExJTkUgMjEgQ0hBUkFDVEVSU1xuICAvLyBUSEFUIENPTUUgRlJPTSBISSBCWVRFPTB4MTMgQU5EIExPVyBCRVRXRUVOIDB4MjAgQU5EIDB4M0ZcbiAgMHhiMDogMHhjMyxcbiAgLy8gVXBwZXJjYXNlIEEsIHRpbGRlXG4gIDB4YjE6IDB4ZTMsXG4gIC8vIExvd2VyY2FzZSBhLCB0aWxkZVxuICAweGIyOiAweGNkLFxuICAvLyBVcHBlcmNhc2UgSSwgYWN1dGUgYWNjZW50XG4gIDB4YjM6IDB4Y2MsXG4gIC8vIFVwcGVyY2FzZSBJLCBncmF2ZSBhY2NlbnRcbiAgMHhiNDogMHhlYyxcbiAgLy8gTG93ZXJjYXNlIGksIGdyYXZlIGFjY2VudFxuICAweGI1OiAweGQyLFxuICAvLyBVcHBlcmNhc2UgTywgZ3JhdmUgYWNjZW50XG4gIDB4YjY6IDB4ZjIsXG4gIC8vIExvd2VyY2FzZSBvLCBncmF2ZSBhY2NlbnRcbiAgMHhiNzogMHhkNSxcbiAgLy8gVXBwZXJjYXNlIE8sIHRpbGRlXG4gIDB4Yjg6IDB4ZjUsXG4gIC8vIExvd2VyY2FzZSBvLCB0aWxkZVxuICAweGI5OiAweDdiLFxuICAvLyBPcGVuIGN1cmx5IGJyYWNlXG4gIDB4YmE6IDB4N2QsXG4gIC8vIENsb3NpbmcgY3VybHkgYnJhY2VcbiAgMHhiYjogMHg1YyxcbiAgLy8gQmFja3NsYXNoXG4gIDB4YmM6IDB4NWUsXG4gIC8vIENhcmV0XG4gIDB4YmQ6IDB4NWYsXG4gIC8vIFVuZGVyc2NvcmVcbiAgMHhiZTogMHg3YyxcbiAgLy8gUGlwZSAodmVydGljYWwgbGluZSlcbiAgMHhiZjogMHgyMjNjLFxuICAvLyBUaWxkZSBvcGVyYXRvclxuICAweGMwOiAweGM0LFxuICAvLyBVcHBlcmNhc2UgQSwgdW1sYXV0XG4gIDB4YzE6IDB4ZTQsXG4gIC8vIExvd2VyY2FzZSBBLCB1bWxhdXRcbiAgMHhjMjogMHhkNixcbiAgLy8gVXBwZXJjYXNlIE8sIHVtbGF1dFxuICAweGMzOiAweGY2LFxuICAvLyBMb3dlcmNhc2UgbywgdW1sYXV0XG4gIDB4YzQ6IDB4ZGYsXG4gIC8vIEVzc3pldHQgKHNoYXJwIFMpXG4gIDB4YzU6IDB4YTUsXG4gIC8vIFllbiBzeW1ib2xcbiAgMHhjNjogMHhhNCxcbiAgLy8gR2VuZXJpYyBjdXJyZW5jeSBzaWduXG4gIDB4Yzc6IDB4MjUwMyxcbiAgLy8gQm94IGRyYXdpbmdzIGhlYXZ5IHZlcnRpY2FsXG4gIDB4Yzg6IDB4YzUsXG4gIC8vIFVwcGVyY2FzZSBBLCByaW5nXG4gIDB4Yzk6IDB4ZTUsXG4gIC8vIExvd2VyY2FzZSBBLCByaW5nXG4gIDB4Y2E6IDB4ZDgsXG4gIC8vIFVwcGVyY2FzZSBPLCBzdHJva2VcbiAgMHhjYjogMHhmOCxcbiAgLy8gTG93ZXJjYXNlIG8sIHN0cm9rXG4gIDB4Y2M6IDB4MjUwZixcbiAgLy8gQm94IGRyYXdpbmdzIGhlYXZ5IGRvd24gYW5kIHJpZ2h0XG4gIDB4Y2Q6IDB4MjUxMyxcbiAgLy8gQm94IGRyYXdpbmdzIGhlYXZ5IGRvd24gYW5kIGxlZnRcbiAgMHhjZTogMHgyNTE3LFxuICAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgdXAgYW5kIHJpZ2h0XG4gIDB4Y2Y6IDB4MjUxYiAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgdXAgYW5kIGxlZnRcbn07XG5cbi8qKlxuICogVXRpbHNcbiAqL1xuY29uc3QgZ2V0Q2hhckZvckJ5dGUgPSBieXRlID0+IFN0cmluZy5mcm9tQ2hhckNvZGUoc3BlY2lhbENlYTYwOENoYXJzQ29kZXNbYnl0ZV0gfHwgYnl0ZSk7XG5jb25zdCBOUl9ST1dTID0gMTU7XG5jb25zdCBOUl9DT0xTID0gMTAwO1xuLy8gVGFibGVzIHRvIGxvb2sgdXAgcm93IGZyb20gUEFDIGRhdGFcbmNvbnN0IHJvd3NMb3dDaDEgPSB7XG4gIDB4MTE6IDEsXG4gIDB4MTI6IDMsXG4gIDB4MTU6IDUsXG4gIDB4MTY6IDcsXG4gIDB4MTc6IDksXG4gIDB4MTA6IDExLFxuICAweDEzOiAxMixcbiAgMHgxNDogMTRcbn07XG5jb25zdCByb3dzSGlnaENoMSA9IHtcbiAgMHgxMTogMixcbiAgMHgxMjogNCxcbiAgMHgxNTogNixcbiAgMHgxNjogOCxcbiAgMHgxNzogMTAsXG4gIDB4MTM6IDEzLFxuICAweDE0OiAxNVxufTtcbmNvbnN0IHJvd3NMb3dDaDIgPSB7XG4gIDB4MTk6IDEsXG4gIDB4MWE6IDMsXG4gIDB4MWQ6IDUsXG4gIDB4MWU6IDcsXG4gIDB4MWY6IDksXG4gIDB4MTg6IDExLFxuICAweDFiOiAxMixcbiAgMHgxYzogMTRcbn07XG5jb25zdCByb3dzSGlnaENoMiA9IHtcbiAgMHgxOTogMixcbiAgMHgxYTogNCxcbiAgMHgxZDogNixcbiAgMHgxZTogOCxcbiAgMHgxZjogMTAsXG4gIDB4MWI6IDEzLFxuICAweDFjOiAxNVxufTtcbmNvbnN0IGJhY2tncm91bmRDb2xvcnMgPSBbJ3doaXRlJywgJ2dyZWVuJywgJ2JsdWUnLCAnY3lhbicsICdyZWQnLCAneWVsbG93JywgJ21hZ2VudGEnLCAnYmxhY2snLCAndHJhbnNwYXJlbnQnXTtcbmNsYXNzIENhcHRpb25zTG9nZ2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy50aW1lID0gbnVsbDtcbiAgICB0aGlzLnZlcmJvc2VMZXZlbCA9IDA7XG4gIH1cbiAgbG9nKHNldmVyaXR5LCBtc2cpIHtcbiAgICBpZiAodGhpcy52ZXJib3NlTGV2ZWwgPj0gc2V2ZXJpdHkpIHtcbiAgICAgIGNvbnN0IG0gPSB0eXBlb2YgbXNnID09PSAnZnVuY3Rpb24nID8gbXNnKCkgOiBtc2c7XG4gICAgICBsb2dnZXIubG9nKGAke3RoaXMudGltZX0gWyR7c2V2ZXJpdHl9XSAke219YCk7XG4gICAgfVxuICB9XG59XG5jb25zdCBudW1BcnJheVRvSGV4QXJyYXkgPSBmdW5jdGlvbiBudW1BcnJheVRvSGV4QXJyYXkobnVtQXJyYXkpIHtcbiAgY29uc3QgaGV4QXJyYXkgPSBbXTtcbiAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1BcnJheS5sZW5ndGg7IGorKykge1xuICAgIGhleEFycmF5LnB1c2gobnVtQXJyYXlbal0udG9TdHJpbmcoMTYpKTtcbiAgfVxuICByZXR1cm4gaGV4QXJyYXk7XG59O1xuY2xhc3MgUGVuU3RhdGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmZvcmVncm91bmQgPSAnd2hpdGUnO1xuICAgIHRoaXMudW5kZXJsaW5lID0gZmFsc2U7XG4gICAgdGhpcy5pdGFsaWNzID0gZmFsc2U7XG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gJ2JsYWNrJztcbiAgICB0aGlzLmZsYXNoID0gZmFsc2U7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gJ3doaXRlJztcbiAgICB0aGlzLnVuZGVybGluZSA9IGZhbHNlO1xuICAgIHRoaXMuaXRhbGljcyA9IGZhbHNlO1xuICAgIHRoaXMuYmFja2dyb3VuZCA9ICdibGFjayc7XG4gICAgdGhpcy5mbGFzaCA9IGZhbHNlO1xuICB9XG4gIHNldFN0eWxlcyhzdHlsZXMpIHtcbiAgICBjb25zdCBhdHRyaWJzID0gWydmb3JlZ3JvdW5kJywgJ3VuZGVybGluZScsICdpdGFsaWNzJywgJ2JhY2tncm91bmQnLCAnZmxhc2gnXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHJpYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHN0eWxlID0gYXR0cmlic1tpXTtcbiAgICAgIGlmIChzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGUpKSB7XG4gICAgICAgIHRoaXNbc3R5bGVdID0gc3R5bGVzW3N0eWxlXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaXNEZWZhdWx0KCkge1xuICAgIHJldHVybiB0aGlzLmZvcmVncm91bmQgPT09ICd3aGl0ZScgJiYgIXRoaXMudW5kZXJsaW5lICYmICF0aGlzLml0YWxpY3MgJiYgdGhpcy5iYWNrZ3JvdW5kID09PSAnYmxhY2snICYmICF0aGlzLmZsYXNoO1xuICB9XG4gIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmZvcmVncm91bmQgPT09IG90aGVyLmZvcmVncm91bmQgJiYgdGhpcy51bmRlcmxpbmUgPT09IG90aGVyLnVuZGVybGluZSAmJiB0aGlzLml0YWxpY3MgPT09IG90aGVyLml0YWxpY3MgJiYgdGhpcy5iYWNrZ3JvdW5kID09PSBvdGhlci5iYWNrZ3JvdW5kICYmIHRoaXMuZmxhc2ggPT09IG90aGVyLmZsYXNoO1xuICB9XG4gIGNvcHkobmV3UGVuU3RhdGUpIHtcbiAgICB0aGlzLmZvcmVncm91bmQgPSBuZXdQZW5TdGF0ZS5mb3JlZ3JvdW5kO1xuICAgIHRoaXMudW5kZXJsaW5lID0gbmV3UGVuU3RhdGUudW5kZXJsaW5lO1xuICAgIHRoaXMuaXRhbGljcyA9IG5ld1BlblN0YXRlLml0YWxpY3M7XG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gbmV3UGVuU3RhdGUuYmFja2dyb3VuZDtcbiAgICB0aGlzLmZsYXNoID0gbmV3UGVuU3RhdGUuZmxhc2g7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdjb2xvcj0nICsgdGhpcy5mb3JlZ3JvdW5kICsgJywgdW5kZXJsaW5lPScgKyB0aGlzLnVuZGVybGluZSArICcsIGl0YWxpY3M9JyArIHRoaXMuaXRhbGljcyArICcsIGJhY2tncm91bmQ9JyArIHRoaXMuYmFja2dyb3VuZCArICcsIGZsYXNoPScgKyB0aGlzLmZsYXNoO1xuICB9XG59XG5cbi8qKlxuICogVW5pY29kZSBjaGFyYWN0ZXIgd2l0aCBzdHlsaW5nIGFuZCBiYWNrZ3JvdW5kLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIFN0eWxlZFVuaWNvZGVDaGFyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy51Y2hhciA9ICcgJztcbiAgICB0aGlzLnBlblN0YXRlID0gbmV3IFBlblN0YXRlKCk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy51Y2hhciA9ICcgJztcbiAgICB0aGlzLnBlblN0YXRlLnJlc2V0KCk7XG4gIH1cbiAgc2V0Q2hhcih1Y2hhciwgbmV3UGVuU3RhdGUpIHtcbiAgICB0aGlzLnVjaGFyID0gdWNoYXI7XG4gICAgdGhpcy5wZW5TdGF0ZS5jb3B5KG5ld1BlblN0YXRlKTtcbiAgfVxuICBzZXRQZW5TdGF0ZShuZXdQZW5TdGF0ZSkge1xuICAgIHRoaXMucGVuU3RhdGUuY29weShuZXdQZW5TdGF0ZSk7XG4gIH1cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMudWNoYXIgPT09IG90aGVyLnVjaGFyICYmIHRoaXMucGVuU3RhdGUuZXF1YWxzKG90aGVyLnBlblN0YXRlKTtcbiAgfVxuICBjb3B5KG5ld0NoYXIpIHtcbiAgICB0aGlzLnVjaGFyID0gbmV3Q2hhci51Y2hhcjtcbiAgICB0aGlzLnBlblN0YXRlLmNvcHkobmV3Q2hhci5wZW5TdGF0ZSk7XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy51Y2hhciA9PT0gJyAnICYmIHRoaXMucGVuU3RhdGUuaXNEZWZhdWx0KCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDRUEtNjA4IHJvdyBjb25zaXN0aW5nIG9mIE5SX0NPTFMgaW5zdGFuY2VzIG9mIFN0eWxlZFVuaWNvZGVDaGFyLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIFJvdyB7XG4gIGNvbnN0cnVjdG9yKGxvZ2dlcikge1xuICAgIHRoaXMuY2hhcnMgPSBbXTtcbiAgICB0aGlzLnBvcyA9IDA7XG4gICAgdGhpcy5jdXJyUGVuU3RhdGUgPSBuZXcgUGVuU3RhdGUoKTtcbiAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IG51bGw7XG4gICAgdGhpcy5sb2dnZXIgPSB2b2lkIDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9DT0xTOyBpKyspIHtcbiAgICAgIHRoaXMuY2hhcnMucHVzaChuZXcgU3R5bGVkVW5pY29kZUNoYXIoKSk7XG4gICAgfVxuICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICB9XG4gIGVxdWFscyhvdGhlcikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfQ09MUzsgaSsrKSB7XG4gICAgICBpZiAoIXRoaXMuY2hhcnNbaV0uZXF1YWxzKG90aGVyLmNoYXJzW2ldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvcHkob3RoZXIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgdGhpcy5jaGFyc1tpXS5jb3B5KG90aGVyLmNoYXJzW2ldKTtcbiAgICB9XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICBsZXQgZW1wdHkgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfQ09MUzsgaSsrKSB7XG4gICAgICBpZiAoIXRoaXMuY2hhcnNbaV0uaXNFbXB0eSgpKSB7XG4gICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW1wdHk7XG4gIH1cblxuICAvKipcbiAgICogIFNldCB0aGUgY3Vyc29yIHRvIGEgdmFsaWQgY29sdW1uLlxuICAgKi9cbiAgc2V0Q3Vyc29yKGFic1Bvcykge1xuICAgIGlmICh0aGlzLnBvcyAhPT0gYWJzUG9zKSB7XG4gICAgICB0aGlzLnBvcyA9IGFic1BvcztcbiAgICB9XG4gICAgaWYgKHRoaXMucG9zIDwgMCkge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKDMsICdOZWdhdGl2ZSBjdXJzb3IgcG9zaXRpb24gJyArIHRoaXMucG9zKTtcbiAgICAgIHRoaXMucG9zID0gMDtcbiAgICB9IGVsc2UgaWYgKHRoaXMucG9zID4gTlJfQ09MUykge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKDMsICdUb28gbGFyZ2UgY3Vyc29yIHBvc2l0aW9uICcgKyB0aGlzLnBvcyk7XG4gICAgICB0aGlzLnBvcyA9IE5SX0NPTFM7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1vdmUgdGhlIGN1cnNvciByZWxhdGl2ZSB0byBjdXJyZW50IHBvc2l0aW9uLlxuICAgKi9cbiAgbW92ZUN1cnNvcihyZWxQb3MpIHtcbiAgICBjb25zdCBuZXdQb3MgPSB0aGlzLnBvcyArIHJlbFBvcztcbiAgICBpZiAocmVsUG9zID4gMSkge1xuICAgICAgZm9yIChsZXQgaSA9IHRoaXMucG9zICsgMTsgaSA8IG5ld1BvcyArIDE7IGkrKykge1xuICAgICAgICB0aGlzLmNoYXJzW2ldLnNldFBlblN0YXRlKHRoaXMuY3VyclBlblN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zZXRDdXJzb3IobmV3UG9zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCYWNrc3BhY2UsIG1vdmUgb25lIHN0ZXAgYmFjayBhbmQgY2xlYXIgY2hhcmFjdGVyLlxuICAgKi9cbiAgYmFja1NwYWNlKCkge1xuICAgIHRoaXMubW92ZUN1cnNvcigtMSk7XG4gICAgdGhpcy5jaGFyc1t0aGlzLnBvc10uc2V0Q2hhcignICcsIHRoaXMuY3VyclBlblN0YXRlKTtcbiAgfVxuICBpbnNlcnRDaGFyKGJ5dGUpIHtcbiAgICBpZiAoYnl0ZSA+PSAweDkwKSB7XG4gICAgICAvLyBFeHRlbmRlZCBjaGFyXG4gICAgICB0aGlzLmJhY2tTcGFjZSgpO1xuICAgIH1cbiAgICBjb25zdCBjaGFyID0gZ2V0Q2hhckZvckJ5dGUoYnl0ZSk7XG4gICAgaWYgKHRoaXMucG9zID49IE5SX0NPTFMpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygwLCAoKSA9PiAnQ2Fubm90IGluc2VydCAnICsgYnl0ZS50b1N0cmluZygxNikgKyAnICgnICsgY2hhciArICcpIGF0IHBvc2l0aW9uICcgKyB0aGlzLnBvcyArICcuIFNraXBwaW5nIGl0IScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmNoYXJzW3RoaXMucG9zXS5zZXRDaGFyKGNoYXIsIHRoaXMuY3VyclBlblN0YXRlKTtcbiAgICB0aGlzLm1vdmVDdXJzb3IoMSk7XG4gIH1cbiAgY2xlYXJGcm9tUG9zKHN0YXJ0UG9zKSB7XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gc3RhcnRQb3M7IGkgPCBOUl9DT0xTOyBpKyspIHtcbiAgICAgIHRoaXMuY2hhcnNbaV0ucmVzZXQoKTtcbiAgICB9XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5jbGVhckZyb21Qb3MoMCk7XG4gICAgdGhpcy5wb3MgPSAwO1xuICAgIHRoaXMuY3VyclBlblN0YXRlLnJlc2V0KCk7XG4gIH1cbiAgY2xlYXJUb0VuZE9mUm93KCkge1xuICAgIHRoaXMuY2xlYXJGcm9tUG9zKHRoaXMucG9zKTtcbiAgfVxuICBnZXRUZXh0U3RyaW5nKCkge1xuICAgIGNvbnN0IGNoYXJzID0gW107XG4gICAgbGV0IGVtcHR5ID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgY29uc3QgY2hhciA9IHRoaXMuY2hhcnNbaV0udWNoYXI7XG4gICAgICBpZiAoY2hhciAhPT0gJyAnKSB7XG4gICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBjaGFycy5wdXNoKGNoYXIpO1xuICAgIH1cbiAgICBpZiAoZW1wdHkpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpO1xuICAgIH1cbiAgfVxuICBzZXRQZW5TdHlsZXMoc3R5bGVzKSB7XG4gICAgdGhpcy5jdXJyUGVuU3RhdGUuc2V0U3R5bGVzKHN0eWxlcyk7XG4gICAgY29uc3QgY3VyckNoYXIgPSB0aGlzLmNoYXJzW3RoaXMucG9zXTtcbiAgICBjdXJyQ2hhci5zZXRQZW5TdGF0ZSh0aGlzLmN1cnJQZW5TdGF0ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBLZWVwIGEgQ0VBLTYwOCBzY3JlZW4gb2YgMzJ4MTUgc3R5bGVkIGNoYXJhY3RlcnNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBDYXB0aW9uU2NyZWVuIHtcbiAgY29uc3RydWN0b3IobG9nZ2VyKSB7XG4gICAgdGhpcy5yb3dzID0gW107XG4gICAgdGhpcy5jdXJyUm93ID0gTlJfUk9XUyAtIDE7XG4gICAgdGhpcy5uclJvbGxVcFJvd3MgPSBudWxsO1xuICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbiA9IG51bGw7XG4gICAgdGhpcy5sb2dnZXIgPSB2b2lkIDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgIHRoaXMucm93cy5wdXNoKG5ldyBSb3cobG9nZ2VyKSk7XG4gICAgfVxuICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICB0aGlzLnJvd3NbaV0uY2xlYXIoKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyUm93ID0gTlJfUk9XUyAtIDE7XG4gIH1cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgbGV0IGVxdWFsID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgaWYgKCF0aGlzLnJvd3NbaV0uZXF1YWxzKG90aGVyLnJvd3NbaV0pKSB7XG4gICAgICAgIGVxdWFsID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXF1YWw7XG4gIH1cbiAgY29weShvdGhlcikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICB0aGlzLnJvd3NbaV0uY29weShvdGhlci5yb3dzW2ldKTtcbiAgICB9XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICBsZXQgZW1wdHkgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICBpZiAoIXRoaXMucm93c1tpXS5pc0VtcHR5KCkpIHtcbiAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbXB0eTtcbiAgfVxuICBiYWNrU3BhY2UoKSB7XG4gICAgY29uc3Qgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgcm93LmJhY2tTcGFjZSgpO1xuICB9XG4gIGNsZWFyVG9FbmRPZlJvdygpIHtcbiAgICBjb25zdCByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICByb3cuY2xlYXJUb0VuZE9mUm93KCk7XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0IGEgY2hhcmFjdGVyICh3aXRob3V0IHN0eWxpbmcpIGluIHRoZSBjdXJyZW50IHJvdy5cbiAgICovXG4gIGluc2VydENoYXIoY2hhcikge1xuICAgIGNvbnN0IHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgIHJvdy5pbnNlcnRDaGFyKGNoYXIpO1xuICB9XG4gIHNldFBlbihzdHlsZXMpIHtcbiAgICBjb25zdCByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICByb3cuc2V0UGVuU3R5bGVzKHN0eWxlcyk7XG4gIH1cbiAgbW92ZUN1cnNvcihyZWxQb3MpIHtcbiAgICBjb25zdCByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICByb3cubW92ZUN1cnNvcihyZWxQb3MpO1xuICB9XG4gIHNldEN1cnNvcihhYnNQb3MpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ3NldEN1cnNvcjogJyArIGFic1Bvcyk7XG4gICAgY29uc3Qgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgcm93LnNldEN1cnNvcihhYnNQb3MpO1xuICB9XG4gIHNldFBBQyhwYWNEYXRhKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nKDIsICgpID0+ICdwYWNEYXRhID0gJyArIHN0cmluZ2lmeShwYWNEYXRhKSk7XG4gICAgbGV0IG5ld1JvdyA9IHBhY0RhdGEucm93IC0gMTtcbiAgICBpZiAodGhpcy5uclJvbGxVcFJvd3MgJiYgbmV3Um93IDwgdGhpcy5uclJvbGxVcFJvd3MgLSAxKSB7XG4gICAgICBuZXdSb3cgPSB0aGlzLm5yUm9sbFVwUm93cyAtIDE7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIHRoaXMgb25seSBhZmZlY3RzIFJvbGwtdXAgQ2FwdGlvbnMgYnkgY2hlY2tpbmcgdGhpcy5uclJvbGxVcFJvd3NcbiAgICBpZiAodGhpcy5uclJvbGxVcFJvd3MgJiYgdGhpcy5jdXJyUm93ICE9PSBuZXdSb3cpIHtcbiAgICAgIC8vIGNsZWFyIGFsbCByb3dzIGZpcnN0XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgICB0aGlzLnJvd3NbaV0uY2xlYXIoKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ29weSB0aGlzLm5yUm9sbFVwUm93cyByb3dzIGZyb20gbGFzdE91dHB1dFNjcmVlbiBhbmQgcGxhY2UgaXQgaW4gdGhlIG5ld1JvdyBsb2NhdGlvblxuICAgICAgLy8gdG9wUm93SW5kZXggLSB0aGUgc3RhcnQgb2Ygcm93cyB0byBjb3B5IChpbmNsdXNpdmUgaW5kZXgpXG4gICAgICBjb25zdCB0b3BSb3dJbmRleCA9IHRoaXMuY3VyclJvdyArIDEgLSB0aGlzLm5yUm9sbFVwUm93cztcbiAgICAgIC8vIFdlIG9ubHkgY29weSBpZiB0aGUgbGFzdCBwb3NpdGlvbiB3YXMgYWxyZWFkeSBzaG93bi5cbiAgICAgIC8vIFdlIHVzZSB0aGUgY3VlU3RhcnRUaW1lIHZhbHVlIHRvIGNoZWNrIHRoaXMuXG4gICAgICBjb25zdCBsYXN0T3V0cHV0U2NyZWVuID0gdGhpcy5sYXN0T3V0cHV0U2NyZWVuO1xuICAgICAgaWYgKGxhc3RPdXRwdXRTY3JlZW4pIHtcbiAgICAgICAgY29uc3QgcHJldkxpbmVUaW1lID0gbGFzdE91dHB1dFNjcmVlbi5yb3dzW3RvcFJvd0luZGV4XS5jdWVTdGFydFRpbWU7XG4gICAgICAgIGNvbnN0IHRpbWUgPSB0aGlzLmxvZ2dlci50aW1lO1xuICAgICAgICBpZiAocHJldkxpbmVUaW1lICE9PSBudWxsICYmIHRpbWUgIT09IG51bGwgJiYgcHJldkxpbmVUaW1lIDwgdGltZSkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uclJvbGxVcFJvd3M7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5yb3dzW25ld1JvdyAtIHRoaXMubnJSb2xsVXBSb3dzICsgaSArIDFdLmNvcHkobGFzdE91dHB1dFNjcmVlbi5yb3dzW3RvcFJvd0luZGV4ICsgaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmN1cnJSb3cgPSBuZXdSb3c7XG4gICAgY29uc3Qgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgaWYgKHBhY0RhdGEuaW5kZW50ICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBpbmRlbnQgPSBwYWNEYXRhLmluZGVudDtcbiAgICAgIGNvbnN0IHByZXZQb3MgPSBNYXRoLm1heChpbmRlbnQgLSAxLCAwKTtcbiAgICAgIHJvdy5zZXRDdXJzb3IocGFjRGF0YS5pbmRlbnQpO1xuICAgICAgcGFjRGF0YS5jb2xvciA9IHJvdy5jaGFyc1twcmV2UG9zXS5wZW5TdGF0ZS5mb3JlZ3JvdW5kO1xuICAgIH1cbiAgICBjb25zdCBzdHlsZXMgPSB7XG4gICAgICBmb3JlZ3JvdW5kOiBwYWNEYXRhLmNvbG9yLFxuICAgICAgdW5kZXJsaW5lOiBwYWNEYXRhLnVuZGVybGluZSxcbiAgICAgIGl0YWxpY3M6IHBhY0RhdGEuaXRhbGljcyxcbiAgICAgIGJhY2tncm91bmQ6ICdibGFjaycsXG4gICAgICBmbGFzaDogZmFsc2VcbiAgICB9O1xuICAgIHRoaXMuc2V0UGVuKHN0eWxlcyk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGJhY2tncm91bmQvZXh0cmEgZm9yZWdyb3VuZCwgYnV0IGZpcnN0IGRvIGJhY2tfc3BhY2UsIGFuZCB0aGVuIGluc2VydCBzcGFjZSAoYmFja3dhcmRzIGNvbXBhdGliaWxpdHkpLlxuICAgKi9cbiAgc2V0QmtnRGF0YShia2dEYXRhKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nKDIsICgpID0+ICdia2dEYXRhID0gJyArIHN0cmluZ2lmeShia2dEYXRhKSk7XG4gICAgdGhpcy5iYWNrU3BhY2UoKTtcbiAgICB0aGlzLnNldFBlbihia2dEYXRhKTtcbiAgICB0aGlzLmluc2VydENoYXIoMHgyMCk7IC8vIFNwYWNlXG4gIH1cbiAgc2V0Um9sbFVwUm93cyhuclJvd3MpIHtcbiAgICB0aGlzLm5yUm9sbFVwUm93cyA9IG5yUm93cztcbiAgfVxuICByb2xsVXAoKSB7XG4gICAgaWYgKHRoaXMubnJSb2xsVXBSb3dzID09PSBudWxsKSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coMywgJ3JvbGxfdXAgYnV0IG5yUm9sbFVwUm93cyBub3Qgc2V0IHlldCcpO1xuICAgICAgcmV0dXJuOyAvLyBOb3QgcHJvcGVybHkgc2V0dXBcbiAgICB9XG4gICAgdGhpcy5sb2dnZXIubG9nKDEsICgpID0+IHRoaXMuZ2V0RGlzcGxheVRleHQoKSk7XG4gICAgY29uc3QgdG9wUm93SW5kZXggPSB0aGlzLmN1cnJSb3cgKyAxIC0gdGhpcy5uclJvbGxVcFJvd3M7XG4gICAgY29uc3QgdG9wUm93ID0gdGhpcy5yb3dzLnNwbGljZSh0b3BSb3dJbmRleCwgMSlbMF07XG4gICAgdG9wUm93LmNsZWFyKCk7XG4gICAgdGhpcy5yb3dzLnNwbGljZSh0aGlzLmN1cnJSb3csIDAsIHRvcFJvdyk7XG4gICAgdGhpcy5sb2dnZXIubG9nKDIsICdSb2xsaW5nIHVwJyk7XG4gICAgLy8gdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5URVhULCB0aGlzLmdldF9kaXNwbGF5X3RleHQoKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIG5vbi1lbXB0eSByb3dzIHdpdGggYXMgdW5pY29kZSB0ZXh0LlxuICAgKi9cbiAgZ2V0RGlzcGxheVRleHQoYXNPbmVSb3cpIHtcbiAgICBhc09uZVJvdyA9IGFzT25lUm93IHx8IGZhbHNlO1xuICAgIGNvbnN0IGRpc3BsYXlUZXh0ID0gW107XG4gICAgbGV0IHRleHQgPSAnJztcbiAgICBsZXQgcm93TnIgPSAtMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgY29uc3Qgcm93VGV4dCA9IHRoaXMucm93c1tpXS5nZXRUZXh0U3RyaW5nKCk7XG4gICAgICBpZiAocm93VGV4dCkge1xuICAgICAgICByb3dOciA9IGkgKyAxO1xuICAgICAgICBpZiAoYXNPbmVSb3cpIHtcbiAgICAgICAgICBkaXNwbGF5VGV4dC5wdXNoKCdSb3cgJyArIHJvd05yICsgXCI6ICdcIiArIHJvd1RleHQgKyBcIidcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGlzcGxheVRleHQucHVzaChyb3dUZXh0LnRyaW0oKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRpc3BsYXlUZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgIGlmIChhc09uZVJvdykge1xuICAgICAgICB0ZXh0ID0gJ1snICsgZGlzcGxheVRleHQuam9pbignIHwgJykgKyAnXSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0ID0gZGlzcGxheVRleHQuam9pbignXFxuJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xuICB9XG4gIGdldFRleHRBbmRGb3JtYXQoKSB7XG4gICAgcmV0dXJuIHRoaXMucm93cztcbiAgfVxufVxuXG4vLyB2YXIgbW9kZXMgPSBbJ01PREVfUk9MTC1VUCcsICdNT0RFX1BPUC1PTicsICdNT0RFX1BBSU5ULU9OJywgJ01PREVfVEVYVCddO1xuXG5jbGFzcyBDZWE2MDhDaGFubmVsIHtcbiAgY29uc3RydWN0b3IoY2hhbm5lbE51bWJlciwgb3V0cHV0RmlsdGVyLCBsb2dnZXIpIHtcbiAgICB0aGlzLmNoTnIgPSB2b2lkIDA7XG4gICAgdGhpcy5vdXRwdXRGaWx0ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5tb2RlID0gdm9pZCAwO1xuICAgIHRoaXMudmVyYm9zZSA9IHZvaWQgMDtcbiAgICB0aGlzLmRpc3BsYXllZE1lbW9yeSA9IHZvaWQgMDtcbiAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeSA9IHZvaWQgMDtcbiAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4gPSB2b2lkIDA7XG4gICAgdGhpcy5jdXJyUm9sbFVwUm93ID0gdm9pZCAwO1xuICAgIHRoaXMud3JpdGVTY3JlZW4gPSB2b2lkIDA7XG4gICAgdGhpcy5jdWVTdGFydFRpbWUgPSB2b2lkIDA7XG4gICAgdGhpcy5sb2dnZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jaE5yID0gY2hhbm5lbE51bWJlcjtcbiAgICB0aGlzLm91dHB1dEZpbHRlciA9IG91dHB1dEZpbHRlcjtcbiAgICB0aGlzLm1vZGUgPSBudWxsO1xuICAgIHRoaXMudmVyYm9zZSA9IDA7XG4gICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkgPSBuZXcgQ2FwdGlvblNjcmVlbihsb2dnZXIpO1xuICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5ID0gbmV3IENhcHRpb25TY3JlZW4obG9nZ2VyKTtcbiAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4gPSBuZXcgQ2FwdGlvblNjcmVlbihsb2dnZXIpO1xuICAgIHRoaXMuY3VyclJvbGxVcFJvdyA9IHRoaXMuZGlzcGxheWVkTWVtb3J5LnJvd3NbTlJfUk9XUyAtIDFdO1xuICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICB0aGlzLm1vZGUgPSBudWxsO1xuICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gbnVsbDsgLy8gS2VlcHMgdHJhY2sgb2Ygd2hlcmUgYSBjdWUgc3RhcnRlZC5cbiAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLm1vZGUgPSBudWxsO1xuICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5LnJlc2V0KCk7XG4gICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkucmVzZXQoKTtcbiAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4ucmVzZXQoKTtcbiAgICB0aGlzLm91dHB1dEZpbHRlci5yZXNldCgpO1xuICAgIHRoaXMuY3VyclJvbGxVcFJvdyA9IHRoaXMuZGlzcGxheWVkTWVtb3J5LnJvd3NbTlJfUk9XUyAtIDFdO1xuICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICB0aGlzLm1vZGUgPSBudWxsO1xuICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gbnVsbDtcbiAgfVxuICBnZXRIYW5kbGVyKCkge1xuICAgIHJldHVybiB0aGlzLm91dHB1dEZpbHRlcjtcbiAgfVxuICBzZXRIYW5kbGVyKG5ld0hhbmRsZXIpIHtcbiAgICB0aGlzLm91dHB1dEZpbHRlciA9IG5ld0hhbmRsZXI7XG4gIH1cbiAgc2V0UEFDKHBhY0RhdGEpIHtcbiAgICB0aGlzLndyaXRlU2NyZWVuLnNldFBBQyhwYWNEYXRhKTtcbiAgfVxuICBzZXRCa2dEYXRhKGJrZ0RhdGEpIHtcbiAgICB0aGlzLndyaXRlU2NyZWVuLnNldEJrZ0RhdGEoYmtnRGF0YSk7XG4gIH1cbiAgc2V0TW9kZShuZXdNb2RlKSB7XG4gICAgaWYgKG5ld01vZGUgPT09IHRoaXMubW9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm1vZGUgPSBuZXdNb2RlO1xuICAgIHRoaXMubG9nZ2VyLmxvZygyLCAoKSA9PiAnTU9ERT0nICsgbmV3TW9kZSk7XG4gICAgaWYgKHRoaXMubW9kZSA9PT0gJ01PREVfUE9QLU9OJykge1xuICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMubm9uRGlzcGxheWVkTWVtb3J5O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XG4gICAgICB0aGlzLndyaXRlU2NyZWVuLnJlc2V0KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1vZGUgIT09ICdNT0RFX1JPTEwtVVAnKSB7XG4gICAgICB0aGlzLmRpc3BsYXllZE1lbW9yeS5uclJvbGxVcFJvd3MgPSBudWxsO1xuICAgICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkubnJSb2xsVXBSb3dzID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5tb2RlID0gbmV3TW9kZTtcbiAgfVxuICBpbnNlcnRDaGFycyhjaGFycykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud3JpdGVTY3JlZW4uaW5zZXJ0Q2hhcihjaGFyc1tpXSk7XG4gICAgfVxuICAgIGNvbnN0IHNjcmVlbiA9IHRoaXMud3JpdGVTY3JlZW4gPT09IHRoaXMuZGlzcGxheWVkTWVtb3J5ID8gJ0RJU1AnIDogJ05PTl9ESVNQJztcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgKCkgPT4gc2NyZWVuICsgJzogJyArIHRoaXMud3JpdGVTY3JlZW4uZ2V0RGlzcGxheVRleHQodHJ1ZSkpO1xuICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1BBSU5ULU9OJyB8fCB0aGlzLm1vZGUgPT09ICdNT0RFX1JPTEwtVVAnKSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coMSwgKCkgPT4gJ0RJU1BMQVlFRDogJyArIHRoaXMuZGlzcGxheWVkTWVtb3J5LmdldERpc3BsYXlUZXh0KHRydWUpKTtcbiAgICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSgpO1xuICAgIH1cbiAgfVxuICBjY1JDTCgpIHtcbiAgICAvLyBSZXN1bWUgQ2FwdGlvbiBMb2FkaW5nIChzd2l0Y2ggbW9kZSB0byBQb3AgT24pXG4gICAgdGhpcy5sb2dnZXIubG9nKDIsICdSQ0wgLSBSZXN1bWUgQ2FwdGlvbiBMb2FkaW5nJyk7XG4gICAgdGhpcy5zZXRNb2RlKCdNT0RFX1BPUC1PTicpO1xuICB9XG4gIGNjQlMoKSB7XG4gICAgLy8gQmFja1NwYWNlXG4gICAgdGhpcy5sb2dnZXIubG9nKDIsICdCUyAtIEJhY2tTcGFjZScpO1xuICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1RFWFQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMud3JpdGVTY3JlZW4uYmFja1NwYWNlKCk7XG4gICAgaWYgKHRoaXMud3JpdGVTY3JlZW4gPT09IHRoaXMuZGlzcGxheWVkTWVtb3J5KSB7XG4gICAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUoKTtcbiAgICB9XG4gIH1cbiAgY2NBT0YoKSB7XG4gICAgLy8gUmVzZXJ2ZWQgKGZvcm1lcmx5IEFsYXJtIE9mZilcbiAgfVxuICBjY0FPTigpIHtcbiAgICAvLyBSZXNlcnZlZCAoZm9ybWVybHkgQWxhcm0gT24pXG4gIH1cbiAgY2NERVIoKSB7XG4gICAgLy8gRGVsZXRlIHRvIEVuZCBvZiBSb3dcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ0RFUi0gRGVsZXRlIHRvIEVuZCBvZiBSb3cnKTtcbiAgICB0aGlzLndyaXRlU2NyZWVuLmNsZWFyVG9FbmRPZlJvdygpO1xuICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSgpO1xuICB9XG4gIGNjUlUobnJSb3dzKSB7XG4gICAgLy8gUm9sbC1VcCBDYXB0aW9ucy0yLDMsb3IgNCBSb3dzXG4gICAgdGhpcy5sb2dnZXIubG9nKDIsICdSVSgnICsgbnJSb3dzICsgJykgLSBSb2xsIFVwJyk7XG4gICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9ST0xMLVVQJyk7XG4gICAgdGhpcy53cml0ZVNjcmVlbi5zZXRSb2xsVXBSb3dzKG5yUm93cyk7XG4gIH1cbiAgY2NGT04oKSB7XG4gICAgLy8gRmxhc2ggT25cbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ0ZPTiAtIEZsYXNoIE9uJyk7XG4gICAgdGhpcy53cml0ZVNjcmVlbi5zZXRQZW4oe1xuICAgICAgZmxhc2g6IHRydWVcbiAgICB9KTtcbiAgfVxuICBjY1JEQygpIHtcbiAgICAvLyBSZXN1bWUgRGlyZWN0IENhcHRpb25pbmcgKHN3aXRjaCBtb2RlIHRvIFBhaW50T24pXG4gICAgdGhpcy5sb2dnZXIubG9nKDIsICdSREMgLSBSZXN1bWUgRGlyZWN0IENhcHRpb25pbmcnKTtcbiAgICB0aGlzLnNldE1vZGUoJ01PREVfUEFJTlQtT04nKTtcbiAgfVxuICBjY1RSKCkge1xuICAgIC8vIFRleHQgUmVzdGFydCBpbiB0ZXh0IG1vZGUgKG5vdCBzdXBwb3J0ZWQsIGhvd2V2ZXIpXG4gICAgdGhpcy5sb2dnZXIubG9nKDIsICdUUicpO1xuICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9URVhUJyk7XG4gIH1cbiAgY2NSVEQoKSB7XG4gICAgLy8gUmVzdW1lIFRleHQgRGlzcGxheSBpbiBUZXh0IG1vZGUgKG5vdCBzdXBwb3J0ZWQsIGhvd2V2ZXIpXG4gICAgdGhpcy5sb2dnZXIubG9nKDIsICdSVEQnKTtcbiAgICB0aGlzLnNldE1vZGUoJ01PREVfVEVYVCcpO1xuICB9XG4gIGNjRURNKCkge1xuICAgIC8vIEVyYXNlIERpc3BsYXllZCBNZW1vcnlcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ0VETSAtIEVyYXNlIERpc3BsYXllZCBNZW1vcnknKTtcbiAgICB0aGlzLmRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSh0cnVlKTtcbiAgfVxuICBjY0NSKCkge1xuICAgIC8vIENhcnJpYWdlIFJldHVyblxuICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnQ1IgLSBDYXJyaWFnZSBSZXR1cm4nKTtcbiAgICB0aGlzLndyaXRlU2NyZWVuLnJvbGxVcCgpO1xuICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSh0cnVlKTtcbiAgfVxuICBjY0VOTSgpIHtcbiAgICAvLyBFcmFzZSBOb24tRGlzcGxheWVkIE1lbW9yeVxuICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnRU5NIC0gRXJhc2UgTm9uLWRpc3BsYXllZCBNZW1vcnknKTtcbiAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICB9XG4gIGNjRU9DKCkge1xuICAgIC8vIEVuZCBvZiBDYXB0aW9uIChGbGlwIE1lbW9yaWVzKVxuICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnRU9DIC0gRW5kIE9mIENhcHRpb24nKTtcbiAgICBpZiAodGhpcy5tb2RlID09PSAnTU9ERV9QT1AtT04nKSB7XG4gICAgICBjb25zdCB0bXAgPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5ID0gdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnk7XG4gICAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeSA9IHRtcDtcbiAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeTtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygxLCAoKSA9PiAnRElTUDogJyArIHRoaXMuZGlzcGxheWVkTWVtb3J5LmdldERpc3BsYXlUZXh0KCkpO1xuICAgIH1cbiAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUodHJ1ZSk7XG4gIH1cbiAgY2NUTyhuckNvbHMpIHtcbiAgICAvLyBUYWIgT2Zmc2V0IDEsMiwgb3IgMyBjb2x1bW5zXG4gICAgdGhpcy5sb2dnZXIubG9nKDIsICdUTygnICsgbnJDb2xzICsgJykgLSBUYWIgT2Zmc2V0Jyk7XG4gICAgdGhpcy53cml0ZVNjcmVlbi5tb3ZlQ3Vyc29yKG5yQ29scyk7XG4gIH1cbiAgY2NNSURST1coc2Vjb25kQnl0ZSkge1xuICAgIC8vIFBhcnNlIE1JRFJPVyBjb21tYW5kXG4gICAgY29uc3Qgc3R5bGVzID0ge1xuICAgICAgZmxhc2g6IGZhbHNlXG4gICAgfTtcbiAgICBzdHlsZXMudW5kZXJsaW5lID0gc2Vjb25kQnl0ZSAlIDIgPT09IDE7XG4gICAgc3R5bGVzLml0YWxpY3MgPSBzZWNvbmRCeXRlID49IDB4MmU7XG4gICAgaWYgKCFzdHlsZXMuaXRhbGljcykge1xuICAgICAgY29uc3QgY29sb3JJbmRleCA9IE1hdGguZmxvb3Ioc2Vjb25kQnl0ZSAvIDIpIC0gMHgxMDtcbiAgICAgIGNvbnN0IGNvbG9ycyA9IFsnd2hpdGUnLCAnZ3JlZW4nLCAnYmx1ZScsICdjeWFuJywgJ3JlZCcsICd5ZWxsb3cnLCAnbWFnZW50YSddO1xuICAgICAgc3R5bGVzLmZvcmVncm91bmQgPSBjb2xvcnNbY29sb3JJbmRleF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlcy5mb3JlZ3JvdW5kID0gJ3doaXRlJztcbiAgICB9XG4gICAgdGhpcy5sb2dnZXIubG9nKDIsICdNSURST1c6ICcgKyBzdHJpbmdpZnkoc3R5bGVzKSk7XG4gICAgdGhpcy53cml0ZVNjcmVlbi5zZXRQZW4oc3R5bGVzKTtcbiAgfVxuICBvdXRwdXREYXRhVXBkYXRlKGRpc3BhdGNoID0gZmFsc2UpIHtcbiAgICBjb25zdCB0aW1lID0gdGhpcy5sb2dnZXIudGltZTtcbiAgICBpZiAodGltZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5vdXRwdXRGaWx0ZXIpIHtcbiAgICAgIGlmICh0aGlzLmN1ZVN0YXJ0VGltZSA9PT0gbnVsbCAmJiAhdGhpcy5kaXNwbGF5ZWRNZW1vcnkuaXNFbXB0eSgpKSB7XG4gICAgICAgIC8vIFN0YXJ0IG9mIGEgbmV3IGN1ZVxuICAgICAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IHRpbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRoaXMuZGlzcGxheWVkTWVtb3J5LmVxdWFscyh0aGlzLmxhc3RPdXRwdXRTY3JlZW4pKSB7XG4gICAgICAgICAgdGhpcy5vdXRwdXRGaWx0ZXIubmV3Q3VlKHRoaXMuY3VlU3RhcnRUaW1lLCB0aW1lLCB0aGlzLmxhc3RPdXRwdXRTY3JlZW4pO1xuICAgICAgICAgIGlmIChkaXNwYXRjaCAmJiB0aGlzLm91dHB1dEZpbHRlci5kaXNwYXRjaEN1ZSkge1xuICAgICAgICAgICAgdGhpcy5vdXRwdXRGaWx0ZXIuZGlzcGF0Y2hDdWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSB0aGlzLmRpc3BsYXllZE1lbW9yeS5pc0VtcHR5KCkgPyBudWxsIDogdGltZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5sYXN0T3V0cHV0U2NyZWVuLmNvcHkodGhpcy5kaXNwbGF5ZWRNZW1vcnkpO1xuICAgIH1cbiAgfVxuICBjdWVTcGxpdEF0VGltZSh0KSB7XG4gICAgaWYgKHRoaXMub3V0cHV0RmlsdGVyKSB7XG4gICAgICBpZiAoIXRoaXMuZGlzcGxheWVkTWVtb3J5LmlzRW1wdHkoKSkge1xuICAgICAgICBpZiAodGhpcy5vdXRwdXRGaWx0ZXIubmV3Q3VlKSB7XG4gICAgICAgICAgdGhpcy5vdXRwdXRGaWx0ZXIubmV3Q3VlKHRoaXMuY3VlU3RhcnRUaW1lLCB0LCB0aGlzLmRpc3BsYXllZE1lbW9yeSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSB0O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBXaWxsIGJlIDEgb3IgMiB3aGVuIHBhcnNpbmcgY2FwdGlvbnNcblxuY2xhc3MgQ2VhNjA4UGFyc2VyIHtcbiAgY29uc3RydWN0b3IoZmllbGQsIG91dDEsIG91dDIpIHtcbiAgICB0aGlzLmNoYW5uZWxzID0gdm9pZCAwO1xuICAgIHRoaXMuY3VycmVudENoYW5uZWwgPSAwO1xuICAgIHRoaXMuY21kSGlzdG9yeSA9IGNyZWF0ZUNtZEhpc3RvcnkoKTtcbiAgICB0aGlzLmxvZ2dlciA9IHZvaWQgMDtcbiAgICBjb25zdCBsb2dnZXIgPSB0aGlzLmxvZ2dlciA9IG5ldyBDYXB0aW9uc0xvZ2dlcigpO1xuICAgIHRoaXMuY2hhbm5lbHMgPSBbbnVsbCwgbmV3IENlYTYwOENoYW5uZWwoZmllbGQsIG91dDEsIGxvZ2dlciksIG5ldyBDZWE2MDhDaGFubmVsKGZpZWxkICsgMSwgb3V0MiwgbG9nZ2VyKV07XG4gIH1cbiAgZ2V0SGFuZGxlcihjaGFubmVsKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNbY2hhbm5lbF0uZ2V0SGFuZGxlcigpO1xuICB9XG4gIHNldEhhbmRsZXIoY2hhbm5lbCwgbmV3SGFuZGxlcikge1xuICAgIHRoaXMuY2hhbm5lbHNbY2hhbm5lbF0uc2V0SGFuZGxlcihuZXdIYW5kbGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgZGF0YSBmb3IgdGltZSB0IGluIGZvcm1zIG9mIGxpc3Qgb2YgYnl0ZXMgKHVuc2lnbmVkIGludHMpLiBUaGUgYnl0ZXMgYXJlIHRyZWF0ZWQgYXMgcGFpcnMuXG4gICAqL1xuICBhZGREYXRhKHRpbWUsIGJ5dGVMaXN0KSB7XG4gICAgdGhpcy5sb2dnZXIudGltZSA9IHRpbWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlTGlzdC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgY29uc3QgYSA9IGJ5dGVMaXN0W2ldICYgMHg3ZjtcbiAgICAgIGNvbnN0IGIgPSBieXRlTGlzdFtpICsgMV0gJiAweDdmO1xuICAgICAgbGV0IGNtZEZvdW5kID0gZmFsc2U7XG4gICAgICBsZXQgY2hhcnNGb3VuZCA9IG51bGw7XG4gICAgICBpZiAoYSA9PT0gMCAmJiBiID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKDMsICgpID0+ICdbJyArIG51bUFycmF5VG9IZXhBcnJheShbYnl0ZUxpc3RbaV0sIGJ5dGVMaXN0W2kgKyAxXV0pICsgJ10gLT4gKCcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2EsIGJdKSArICcpJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBjbWRIaXN0b3J5ID0gdGhpcy5jbWRIaXN0b3J5O1xuICAgICAgY29uc3QgaXNDb250cm9sQ29kZSA9IGEgPj0gMHgxMCAmJiBhIDw9IDB4MWY7XG4gICAgICBpZiAoaXNDb250cm9sQ29kZSkge1xuICAgICAgICAvLyBTa2lwIHJlZHVuZGFudCBjb250cm9sIGNvZGVzXG4gICAgICAgIGlmIChoYXNDbWRSZXBlYXRlZChhLCBiLCBjbWRIaXN0b3J5KSkge1xuICAgICAgICAgIHNldExhc3RDbWQobnVsbCwgbnVsbCwgY21kSGlzdG9yeSk7XG4gICAgICAgICAgdGhpcy5sb2dnZXIubG9nKDMsICgpID0+ICdSZXBlYXRlZCBjb21tYW5kICgnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnKSBpcyBkcm9wcGVkJyk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc2V0TGFzdENtZChhLCBiLCB0aGlzLmNtZEhpc3RvcnkpO1xuICAgICAgICBjbWRGb3VuZCA9IHRoaXMucGFyc2VDbWQoYSwgYik7XG4gICAgICAgIGlmICghY21kRm91bmQpIHtcbiAgICAgICAgICBjbWRGb3VuZCA9IHRoaXMucGFyc2VNaWRyb3coYSwgYik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjbWRGb3VuZCkge1xuICAgICAgICAgIGNtZEZvdW5kID0gdGhpcy5wYXJzZVBBQyhhLCBiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNtZEZvdW5kKSB7XG4gICAgICAgICAgY21kRm91bmQgPSB0aGlzLnBhcnNlQmFja2dyb3VuZEF0dHJpYnV0ZXMoYSwgYik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldExhc3RDbWQobnVsbCwgbnVsbCwgY21kSGlzdG9yeSk7XG4gICAgICB9XG4gICAgICBpZiAoIWNtZEZvdW5kKSB7XG4gICAgICAgIGNoYXJzRm91bmQgPSB0aGlzLnBhcnNlQ2hhcnMoYSwgYik7XG4gICAgICAgIGlmIChjaGFyc0ZvdW5kKSB7XG4gICAgICAgICAgY29uc3QgY3VyckNoTnIgPSB0aGlzLmN1cnJlbnRDaGFubmVsO1xuICAgICAgICAgIGlmIChjdXJyQ2hOciAmJiBjdXJyQ2hOciA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2N1cnJDaE5yXTtcbiAgICAgICAgICAgIGNoYW5uZWwuaW5zZXJ0Q2hhcnMoY2hhcnNGb3VuZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnTm8gY2hhbm5lbCBmb3VuZCB5ZXQuIFRFWFQtTU9ERT8nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghY21kRm91bmQgJiYgIWNoYXJzRm91bmQpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKDIsICgpID0+IFwiQ291bGRuJ3QgcGFyc2UgY2xlYW5lZCBkYXRhIFwiICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnIG9yaWc6ICcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2J5dGVMaXN0W2ldLCBieXRlTGlzdFtpICsgMV1dKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIENvbW1hbmQuXG4gICAqIEByZXR1cm5zIFRydWUgaWYgYSBjb21tYW5kIHdhcyBmb3VuZFxuICAgKi9cbiAgcGFyc2VDbWQoYSwgYikge1xuICAgIGNvbnN0IGNvbmQxID0gKGEgPT09IDB4MTQgfHwgYSA9PT0gMHgxYyB8fCBhID09PSAweDE1IHx8IGEgPT09IDB4MWQpICYmIGIgPj0gMHgyMCAmJiBiIDw9IDB4MmY7XG4gICAgY29uc3QgY29uZDIgPSAoYSA9PT0gMHgxNyB8fCBhID09PSAweDFmKSAmJiBiID49IDB4MjEgJiYgYiA8PSAweDIzO1xuICAgIGlmICghKGNvbmQxIHx8IGNvbmQyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBjaE5yID0gYSA9PT0gMHgxNCB8fCBhID09PSAweDE1IHx8IGEgPT09IDB4MTcgPyAxIDogMjtcbiAgICBjb25zdCBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaE5yXTtcbiAgICBpZiAoYSA9PT0gMHgxNCB8fCBhID09PSAweDE1IHx8IGEgPT09IDB4MWMgfHwgYSA9PT0gMHgxZCkge1xuICAgICAgaWYgKGIgPT09IDB4MjApIHtcbiAgICAgICAgY2hhbm5lbC5jY1JDTCgpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDIxKSB7XG4gICAgICAgIGNoYW5uZWwuY2NCUygpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDIyKSB7XG4gICAgICAgIGNoYW5uZWwuY2NBT0YoKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyMykge1xuICAgICAgICBjaGFubmVsLmNjQU9OKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjQpIHtcbiAgICAgICAgY2hhbm5lbC5jY0RFUigpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDI1KSB7XG4gICAgICAgIGNoYW5uZWwuY2NSVSgyKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNikge1xuICAgICAgICBjaGFubmVsLmNjUlUoMyk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjcpIHtcbiAgICAgICAgY2hhbm5lbC5jY1JVKDQpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDI4KSB7XG4gICAgICAgIGNoYW5uZWwuY2NGT04oKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyOSkge1xuICAgICAgICBjaGFubmVsLmNjUkRDKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MmEpIHtcbiAgICAgICAgY2hhbm5lbC5jY1RSKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MmIpIHtcbiAgICAgICAgY2hhbm5lbC5jY1JURCgpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDJjKSB7XG4gICAgICAgIGNoYW5uZWwuY2NFRE0oKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyZCkge1xuICAgICAgICBjaGFubmVsLmNjQ1IoKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyZSkge1xuICAgICAgICBjaGFubmVsLmNjRU5NKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MmYpIHtcbiAgICAgICAgY2hhbm5lbC5jY0VPQygpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhID09IDB4MTcgfHwgYSA9PSAweDFGXG4gICAgICBjaGFubmVsLmNjVE8oYiAtIDB4MjApO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRDaGFubmVsID0gY2hOcjtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBtaWRyb3cgc3R5bGluZyBjb21tYW5kXG4gICAqL1xuICBwYXJzZU1pZHJvdyhhLCBiKSB7XG4gICAgbGV0IGNoTnIgPSAwO1xuICAgIGlmICgoYSA9PT0gMHgxMSB8fCBhID09PSAweDE5KSAmJiBiID49IDB4MjAgJiYgYiA8PSAweDJmKSB7XG4gICAgICBpZiAoYSA9PT0gMHgxMSkge1xuICAgICAgICBjaE5yID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoTnIgPSAyO1xuICAgICAgfVxuICAgICAgaWYgKGNoTnIgIT09IHRoaXMuY3VycmVudENoYW5uZWwpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKDAsICdNaXNtYXRjaCBjaGFubmVsIGluIG1pZHJvdyBwYXJzaW5nJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2NoTnJdO1xuICAgICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNoYW5uZWwuY2NNSURST1coYik7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coMywgKCkgPT4gJ01JRFJPVyAoJyArIG51bUFycmF5VG9IZXhBcnJheShbYSwgYl0pICsgJyknKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgUHJlYWJsZSBBY2Nlc3MgQ29kZXMgKFRhYmxlIDUzKS5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IFRlbGxzIGlmIFBBQyBmb3VuZFxuICAgKi9cbiAgcGFyc2VQQUMoYSwgYikge1xuICAgIGxldCByb3c7XG4gICAgY29uc3QgY2FzZTEgPSAoYSA+PSAweDExICYmIGEgPD0gMHgxNyB8fCBhID49IDB4MTkgJiYgYSA8PSAweDFmKSAmJiBiID49IDB4NDAgJiYgYiA8PSAweDdmO1xuICAgIGNvbnN0IGNhc2UyID0gKGEgPT09IDB4MTAgfHwgYSA9PT0gMHgxOCkgJiYgYiA+PSAweDQwICYmIGIgPD0gMHg1ZjtcbiAgICBpZiAoIShjYXNlMSB8fCBjYXNlMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgY2hOciA9IGEgPD0gMHgxNyA/IDEgOiAyO1xuICAgIGlmIChiID49IDB4NDAgJiYgYiA8PSAweDVmKSB7XG4gICAgICByb3cgPSBjaE5yID09PSAxID8gcm93c0xvd0NoMVthXSA6IHJvd3NMb3dDaDJbYV07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIDB4NjAgPD0gYiA8PSAweDdGXG4gICAgICByb3cgPSBjaE5yID09PSAxID8gcm93c0hpZ2hDaDFbYV0gOiByb3dzSGlnaENoMlthXTtcbiAgICB9XG4gICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY2hOcl07XG4gICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNoYW5uZWwuc2V0UEFDKHRoaXMuaW50ZXJwcmV0UEFDKHJvdywgYikpO1xuICAgIHRoaXMuY3VycmVudENoYW5uZWwgPSBjaE5yO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVycHJldCB0aGUgc2Vjb25kIGJ5dGUgb2YgdGhlIHBhYywgYW5kIHJldHVybiB0aGUgaW5mb3JtYXRpb24uXG4gICAqIEByZXR1cm5zIHBhY0RhdGEgd2l0aCBzdHlsZSBwYXJhbWV0ZXJzXG4gICAqL1xuICBpbnRlcnByZXRQQUMocm93LCBieXRlKSB7XG4gICAgbGV0IHBhY0luZGV4O1xuICAgIGNvbnN0IHBhY0RhdGEgPSB7XG4gICAgICBjb2xvcjogbnVsbCxcbiAgICAgIGl0YWxpY3M6IGZhbHNlLFxuICAgICAgaW5kZW50OiBudWxsLFxuICAgICAgdW5kZXJsaW5lOiBmYWxzZSxcbiAgICAgIHJvdzogcm93XG4gICAgfTtcbiAgICBpZiAoYnl0ZSA+IDB4NWYpIHtcbiAgICAgIHBhY0luZGV4ID0gYnl0ZSAtIDB4NjA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhY0luZGV4ID0gYnl0ZSAtIDB4NDA7XG4gICAgfVxuICAgIHBhY0RhdGEudW5kZXJsaW5lID0gKHBhY0luZGV4ICYgMSkgPT09IDE7XG4gICAgaWYgKHBhY0luZGV4IDw9IDB4ZCkge1xuICAgICAgcGFjRGF0YS5jb2xvciA9IFsnd2hpdGUnLCAnZ3JlZW4nLCAnYmx1ZScsICdjeWFuJywgJ3JlZCcsICd5ZWxsb3cnLCAnbWFnZW50YScsICd3aGl0ZSddW01hdGguZmxvb3IocGFjSW5kZXggLyAyKV07XG4gICAgfSBlbHNlIGlmIChwYWNJbmRleCA8PSAweGYpIHtcbiAgICAgIHBhY0RhdGEuaXRhbGljcyA9IHRydWU7XG4gICAgICBwYWNEYXRhLmNvbG9yID0gJ3doaXRlJztcbiAgICB9IGVsc2Uge1xuICAgICAgcGFjRGF0YS5pbmRlbnQgPSBNYXRoLmZsb29yKChwYWNJbmRleCAtIDB4MTApIC8gMikgKiA0O1xuICAgIH1cbiAgICByZXR1cm4gcGFjRGF0YTsgLy8gTm90ZSB0aGF0IHJvdyBoYXMgemVybyBvZmZzZXQuIFRoZSBzcGVjIHVzZXMgMS5cbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBjaGFyYWN0ZXJzLlxuICAgKiBAcmV0dXJucyBBbiBhcnJheSB3aXRoIDEgdG8gMiBjb2RlcyBjb3JyZXNwb25kaW5nIHRvIGNoYXJzLCBpZiBmb3VuZC4gbnVsbCBvdGhlcndpc2UuXG4gICAqL1xuICBwYXJzZUNoYXJzKGEsIGIpIHtcbiAgICBsZXQgY2hhbm5lbE5yO1xuICAgIGxldCBjaGFyQ29kZXMgPSBudWxsO1xuICAgIGxldCBjaGFyQ29kZTEgPSBudWxsO1xuICAgIGlmIChhID49IDB4MTkpIHtcbiAgICAgIGNoYW5uZWxOciA9IDI7XG4gICAgICBjaGFyQ29kZTEgPSBhIC0gODtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hhbm5lbE5yID0gMTtcbiAgICAgIGNoYXJDb2RlMSA9IGE7XG4gICAgfVxuICAgIGlmIChjaGFyQ29kZTEgPj0gMHgxMSAmJiBjaGFyQ29kZTEgPD0gMHgxMykge1xuICAgICAgLy8gU3BlY2lhbCBjaGFyYWN0ZXJcbiAgICAgIGxldCBvbmVDb2RlO1xuICAgICAgaWYgKGNoYXJDb2RlMSA9PT0gMHgxMSkge1xuICAgICAgICBvbmVDb2RlID0gYiArIDB4NTA7XG4gICAgICB9IGVsc2UgaWYgKGNoYXJDb2RlMSA9PT0gMHgxMikge1xuICAgICAgICBvbmVDb2RlID0gYiArIDB4NzA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbmVDb2RlID0gYiArIDB4OTA7XG4gICAgICB9XG4gICAgICB0aGlzLmxvZ2dlci5sb2coMiwgKCkgPT4gXCJTcGVjaWFsIGNoYXIgJ1wiICsgZ2V0Q2hhckZvckJ5dGUob25lQ29kZSkgKyBcIicgaW4gY2hhbm5lbCBcIiArIGNoYW5uZWxOcik7XG4gICAgICBjaGFyQ29kZXMgPSBbb25lQ29kZV07XG4gICAgfSBlbHNlIGlmIChhID49IDB4MjAgJiYgYSA8PSAweDdmKSB7XG4gICAgICBjaGFyQ29kZXMgPSBiID09PSAwID8gW2FdIDogW2EsIGJdO1xuICAgIH1cbiAgICBpZiAoY2hhckNvZGVzKSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coMywgKCkgPT4gJ0NoYXIgY29kZXMgPSAgJyArIG51bUFycmF5VG9IZXhBcnJheShjaGFyQ29kZXMpLmpvaW4oJywnKSk7XG4gICAgfVxuICAgIHJldHVybiBjaGFyQ29kZXM7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgZXh0ZW5kZWQgYmFja2dyb3VuZCBhdHRyaWJ1dGVzIGFzIHdlbGwgYXMgbmV3IGZvcmVncm91bmQgY29sb3IgYmxhY2suXG4gICAqIEByZXR1cm5zIFRydWUgaWYgYmFja2dyb3VuZCBhdHRyaWJ1dGVzIGFyZSBmb3VuZFxuICAgKi9cbiAgcGFyc2VCYWNrZ3JvdW5kQXR0cmlidXRlcyhhLCBiKSB7XG4gICAgY29uc3QgY2FzZTEgPSAoYSA9PT0gMHgxMCB8fCBhID09PSAweDE4KSAmJiBiID49IDB4MjAgJiYgYiA8PSAweDJmO1xuICAgIGNvbnN0IGNhc2UyID0gKGEgPT09IDB4MTcgfHwgYSA9PT0gMHgxZikgJiYgYiA+PSAweDJkICYmIGIgPD0gMHgyZjtcbiAgICBpZiAoIShjYXNlMSB8fCBjYXNlMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IGluZGV4O1xuICAgIGNvbnN0IGJrZ0RhdGEgPSB7fTtcbiAgICBpZiAoYSA9PT0gMHgxMCB8fCBhID09PSAweDE4KSB7XG4gICAgICBpbmRleCA9IE1hdGguZmxvb3IoKGIgLSAweDIwKSAvIDIpO1xuICAgICAgYmtnRGF0YS5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZENvbG9yc1tpbmRleF07XG4gICAgICBpZiAoYiAlIDIgPT09IDEpIHtcbiAgICAgICAgYmtnRGF0YS5iYWNrZ3JvdW5kID0gYmtnRGF0YS5iYWNrZ3JvdW5kICsgJ19zZW1pJztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGIgPT09IDB4MmQpIHtcbiAgICAgIGJrZ0RhdGEuYmFja2dyb3VuZCA9ICd0cmFuc3BhcmVudCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJrZ0RhdGEuZm9yZWdyb3VuZCA9ICdibGFjayc7XG4gICAgICBpZiAoYiA9PT0gMHgyZikge1xuICAgICAgICBia2dEYXRhLnVuZGVybGluZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNoTnIgPSBhIDw9IDB4MTcgPyAxIDogMjtcbiAgICBjb25zdCBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaE5yXTtcbiAgICBjaGFubmVsLnNldEJrZ0RhdGEoYmtnRGF0YSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXQgc3RhdGUgb2YgcGFyc2VyIGFuZCBpdHMgY2hhbm5lbHMuXG4gICAqL1xuICByZXNldCgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE9iamVjdC5rZXlzKHRoaXMuY2hhbm5lbHMpLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tpXTtcbiAgICAgIGlmIChjaGFubmVsKSB7XG4gICAgICAgIGNoYW5uZWwucmVzZXQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0TGFzdENtZChudWxsLCBudWxsLCB0aGlzLmNtZEhpc3RvcnkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyaWdnZXIgdGhlIGdlbmVyYXRpb24gb2YgYSBjdWUsIGFuZCB0aGUgc3RhcnQgb2YgYSBuZXcgb25lIGlmIGRpc3BsYXlTY3JlZW5zIGFyZSBub3QgZW1wdHkuXG4gICAqL1xuICBjdWVTcGxpdEF0VGltZSh0KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoYW5uZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tpXTtcbiAgICAgIGlmIChjaGFubmVsKSB7XG4gICAgICAgIGNoYW5uZWwuY3VlU3BsaXRBdFRpbWUodCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzZXRMYXN0Q21kKGEsIGIsIGNtZEhpc3RvcnkpIHtcbiAgY21kSGlzdG9yeS5hID0gYTtcbiAgY21kSGlzdG9yeS5iID0gYjtcbn1cbmZ1bmN0aW9uIGhhc0NtZFJlcGVhdGVkKGEsIGIsIGNtZEhpc3RvcnkpIHtcbiAgcmV0dXJuIGNtZEhpc3RvcnkuYSA9PT0gYSAmJiBjbWRIaXN0b3J5LmIgPT09IGI7XG59XG5mdW5jdGlvbiBjcmVhdGVDbWRIaXN0b3J5KCkge1xuICByZXR1cm4ge1xuICAgIGE6IG51bGwsXG4gICAgYjogbnVsbFxuICB9O1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAyMDEzIHZ0dC5qcyBDb250cmlidXRvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxudmFyIFZUVEN1ZSA9IChmdW5jdGlvbiAoKSB7XG4gIGlmIChvcHRpb25hbFNlbGYgIT0gbnVsbCAmJiBvcHRpb25hbFNlbGYuVlRUQ3VlKSB7XG4gICAgcmV0dXJuIHNlbGYuVlRUQ3VlO1xuICB9XG4gIGNvbnN0IEFsbG93ZWREaXJlY3Rpb25zID0gWycnLCAnbHInLCAncmwnXTtcbiAgY29uc3QgQWxsb3dlZEFsaWdubWVudHMgPSBbJ3N0YXJ0JywgJ21pZGRsZScsICdlbmQnLCAnbGVmdCcsICdyaWdodCddO1xuICBmdW5jdGlvbiBpc0FsbG93ZWRWYWx1ZShhbGxvd2VkLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIG5lY2Vzc2FyeSBmb3IgYXNzdXJpbmcgdGhlIGdlbmVyaWMgY29uZm9ybXMgdG8gdGhlIEFycmF5IGludGVyZmFjZVxuICAgIGlmICghQXJyYXkuaXNBcnJheShhbGxvd2VkKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyByZXNldCB0aGUgdHlwZSBzbyB0aGF0IHRoZSBuZXh0IG5hcnJvd2luZyB3b3JrcyB3ZWxsXG4gICAgY29uc3QgbGNWYWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gdXNlIHRoZSBhbGxvdyBsaXN0IHRvIG5hcnJvdyB0aGUgdHlwZSB0byBhIHNwZWNpZmljIHN1YnNldCBvZiBzdHJpbmdzXG4gICAgaWYgKH5hbGxvd2VkLmluZGV4T2YobGNWYWx1ZSkpIHtcbiAgICAgIHJldHVybiBsY1ZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gZmluZERpcmVjdGlvblNldHRpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gaXNBbGxvd2VkVmFsdWUoQWxsb3dlZERpcmVjdGlvbnMsIHZhbHVlKTtcbiAgfVxuICBmdW5jdGlvbiBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzQWxsb3dlZFZhbHVlKEFsbG93ZWRBbGlnbm1lbnRzLCB2YWx1ZSk7XG4gIH1cbiAgZnVuY3Rpb24gZXh0ZW5kKG9iaiwgLi4ucmVzdCkge1xuICAgIGxldCBpID0gMTtcbiAgICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY29iaiA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAoY29uc3QgcCBpbiBjb2JqKSB7XG4gICAgICAgIG9ialtwXSA9IGNvYmpbcF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgZnVuY3Rpb24gVlRUQ3VlKHN0YXJ0VGltZSwgZW5kVGltZSwgdGV4dCkge1xuICAgIGNvbnN0IGN1ZSA9IHRoaXM7XG4gICAgY29uc3QgYmFzZU9iaiA9IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNoaW0gaW1wbGVtZW50YXRpb24gc3BlY2lmaWMgcHJvcGVydGllcy4gVGhlc2UgcHJvcGVydGllcyBhcmUgbm90IGluXG4gICAgICogdGhlIHNwZWMuXG4gICAgICovXG5cbiAgICAvLyBMZXRzIHVzIGtub3cgd2hlbiB0aGUgVlRUQ3VlJ3MgZGF0YSBoYXMgY2hhbmdlZCBpbiBzdWNoIGEgd2F5IHRoYXQgd2UgbmVlZFxuICAgIC8vIHRvIHJlY29tcHV0ZSBpdHMgZGlzcGxheSBzdGF0ZS4gVGhpcyBsZXRzIHVzIGNvbXB1dGUgaXRzIGRpc3BsYXkgc3RhdGVcbiAgICAvLyBsYXppbHkuXG4gICAgY3VlLmhhc0JlZW5SZXNldCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVlRUQ3VlIGFuZCBUZXh0VHJhY2tDdWUgcHJvcGVydGllc1xuICAgICAqIGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3dlYnZ0dC8jdnR0Y3VlLWludGVyZmFjZVxuICAgICAqL1xuXG4gICAgbGV0IF9pZCA9ICcnO1xuICAgIGxldCBfcGF1c2VPbkV4aXQgPSBmYWxzZTtcbiAgICBsZXQgX3N0YXJ0VGltZSA9IHN0YXJ0VGltZTtcbiAgICBsZXQgX2VuZFRpbWUgPSBlbmRUaW1lO1xuICAgIGxldCBfdGV4dCA9IHRleHQ7XG4gICAgbGV0IF9yZWdpb24gPSBudWxsO1xuICAgIGxldCBfdmVydGljYWwgPSAnJztcbiAgICBsZXQgX3NuYXBUb0xpbmVzID0gdHJ1ZTtcbiAgICBsZXQgX2xpbmUgPSAnYXV0byc7XG4gICAgbGV0IF9saW5lQWxpZ24gPSAnc3RhcnQnO1xuICAgIGxldCBfcG9zaXRpb24gPSA1MDtcbiAgICBsZXQgX3Bvc2l0aW9uQWxpZ24gPSAnbWlkZGxlJztcbiAgICBsZXQgX3NpemUgPSA1MDtcbiAgICBsZXQgX2FsaWduID0gJ21pZGRsZSc7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ2lkJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9pZDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBfaWQgPSAnJyArIHZhbHVlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAncGF1c2VPbkV4aXQnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3BhdXNlT25FeGl0O1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIF9wYXVzZU9uRXhpdCA9ICEhdmFsdWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdzdGFydFRpbWUnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3N0YXJ0VGltZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1N0YXJ0IHRpbWUgbXVzdCBiZSBzZXQgdG8gYSBudW1iZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX3N0YXJ0VGltZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdlbmRUaW1lJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9lbmRUaW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRW5kIHRpbWUgbXVzdCBiZSBzZXQgdG8gYSBudW1iZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX2VuZFRpbWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAndGV4dCcsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGV4dDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBfdGV4dCA9ICcnICsgdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICAvLyB0b2RvOiBpbXBsZW1lbnQgVlRUUmVnaW9uIHBvbHlmaWxsP1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdyZWdpb24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3JlZ2lvbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBfcmVnaW9uID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3ZlcnRpY2FsJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF92ZXJ0aWNhbDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBjb25zdCBzZXR0aW5nID0gZmluZERpcmVjdGlvblNldHRpbmcodmFsdWUpO1xuICAgICAgICAvLyBIYXZlIHRvIGNoZWNrIGZvciBmYWxzZSBiZWNhdXNlIHRoZSBzZXR0aW5nIGFuIGJlIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgICAgaWYgKHNldHRpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX3ZlcnRpY2FsID0gc2V0dGluZztcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnc25hcFRvTGluZXMnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3NuYXBUb0xpbmVzO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIF9zbmFwVG9MaW5lcyA9ICEhdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ2xpbmUnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2xpbmU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgJiYgdmFsdWUgIT09ICdhdXRvJykge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQW4gaW52YWxpZCBudW1iZXIgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBfbGluZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdsaW5lQWxpZ24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2xpbmVBbGlnbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBjb25zdCBzZXR0aW5nID0gZmluZEFsaWduU2V0dGluZyh2YWx1ZSk7XG4gICAgICAgIGlmICghc2V0dGluZykge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgICB9XG4gICAgICAgIF9saW5lQWxpZ24gPSBzZXR0aW5nO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdwb3NpdGlvbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfcG9zaXRpb247XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDEwMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9zaXRpb24gbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwMC4nKTtcbiAgICAgICAgfVxuICAgICAgICBfcG9zaXRpb24gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAncG9zaXRpb25BbGlnbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfcG9zaXRpb25BbGlnbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBjb25zdCBzZXR0aW5nID0gZmluZEFsaWduU2V0dGluZyh2YWx1ZSk7XG4gICAgICAgIGlmICghc2V0dGluZykge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgICB9XG4gICAgICAgIF9wb3NpdGlvbkFsaWduID0gc2V0dGluZztcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnc2l6ZScsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfc2l6ZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaXplIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxMDAuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX3NpemUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnYWxpZ24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2FsaWduO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHNldHRpbmcgPSBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKTtcbiAgICAgICAgaWYgKCFzZXR0aW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX2FsaWduID0gc2V0dGluZztcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIC8qKlxuICAgICAqIE90aGVyIDx0cmFjaz4gc3BlYyBkZWZpbmVkIHByb3BlcnRpZXNcbiAgICAgKi9cblxuICAgIC8vIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS12aWRlby1lbGVtZW50Lmh0bWwjdGV4dC10cmFjay1jdWUtZGlzcGxheS1zdGF0ZVxuICAgIGN1ZS5kaXNwbGF5U3RhdGUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogVlRUQ3VlIG1ldGhvZHNcbiAgICovXG5cbiAgVlRUQ3VlLnByb3RvdHlwZS5nZXRDdWVBc0hUTUwgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gQXNzdW1lIFdlYlZUVC5jb252ZXJ0Q3VlVG9ET01UcmVlIGlzIG9uIHRoZSBnbG9iYWwuXG4gICAgY29uc3QgV2ViVlRUID0gc2VsZi5XZWJWVFQ7XG4gICAgcmV0dXJuIFdlYlZUVC5jb252ZXJ0Q3VlVG9ET01UcmVlKHNlbGYsIHRoaXMudGV4dCk7XG4gIH07XG4gIC8vIHRoaXMgaXMgYSBwb2x5ZmlsbCBoYWNrXG4gIHJldHVybiBWVFRDdWU7XG59KSgpO1xuXG4vKlxuICogU291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS92dHQuanMvYmxvYi9tYXN0ZXIvZGlzdC92dHQuanNcbiAqL1xuXG5jbGFzcyBTdHJpbmdEZWNvZGVyIHtcbiAgZGVjb2RlKGRhdGEsIG9wdGlvbnMpIHtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciAtIGV4cGVjdGVkIHN0cmluZyBkYXRhLicpO1xuICAgIH1cbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVuY29kZVVSSUNvbXBvbmVudChkYXRhKSk7XG4gIH1cbn1cblxuLy8gVHJ5IHRvIHBhcnNlIGlucHV0IGFzIGEgdGltZSBzdGFtcC5cbmZ1bmN0aW9uIHBhcnNlVGltZVN0YW1wKGlucHV0KSB7XG4gIGZ1bmN0aW9uIGNvbXB1dGVTZWNvbmRzKGgsIG0sIHMsIGYpIHtcbiAgICByZXR1cm4gKGggfCAwKSAqIDM2MDAgKyAobSB8IDApICogNjAgKyAocyB8IDApICsgcGFyc2VGbG9hdChmIHx8IDApO1xuICB9XG4gIGNvbnN0IG0gPSBpbnB1dC5tYXRjaCgvXig/OihcXGQrKTopPyhcXGR7Mn0pOihcXGR7Mn0pKFxcLlxcZCspPy8pO1xuICBpZiAoIW0pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAocGFyc2VGbG9hdChtWzJdKSA+IDU5KSB7XG4gICAgLy8gVGltZXN0YW1wIHRha2VzIHRoZSBmb3JtIG9mIFtob3Vyc106W21pbnV0ZXNdLlttaWxsaXNlY29uZHNdXG4gICAgLy8gRmlyc3QgcG9zaXRpb24gaXMgaG91cnMgYXMgaXQncyBvdmVyIDU5LlxuICAgIHJldHVybiBjb21wdXRlU2Vjb25kcyhtWzJdLCBtWzNdLCAwLCBtWzRdKTtcbiAgfVxuICAvLyBUaW1lc3RhbXAgdGFrZXMgdGhlIGZvcm0gb2YgW2hvdXJzIChvcHRpb25hbCldOlttaW51dGVzXTpbc2Vjb25kc10uW21pbGxpc2Vjb25kc11cbiAgcmV0dXJuIGNvbXB1dGVTZWNvbmRzKG1bMV0sIG1bMl0sIG1bM10sIG1bNF0pO1xufVxuXG4vLyBBIHNldHRpbmdzIG9iamVjdCBob2xkcyBrZXkvdmFsdWUgcGFpcnMgYW5kIHdpbGwgaWdub3JlIGFueXRoaW5nIGJ1dCB0aGUgZmlyc3Rcbi8vIGFzc2lnbm1lbnQgdG8gYSBzcGVjaWZpYyBrZXkuXG5jbGFzcyBTZXR0aW5ncyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudmFsdWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICAvLyBPbmx5IGFjY2VwdCB0aGUgZmlyc3QgYXNzaWdubWVudCB0byBhbnkga2V5LlxuICBzZXQoaywgdikge1xuICAgIGlmICghdGhpcy5nZXQoaykgJiYgdiAhPT0gJycpIHtcbiAgICAgIHRoaXMudmFsdWVzW2tdID0gdjtcbiAgICB9XG4gIH1cbiAgLy8gUmV0dXJuIHRoZSB2YWx1ZSBmb3IgYSBrZXksIG9yIGEgZGVmYXVsdCB2YWx1ZS5cbiAgLy8gSWYgJ2RlZmF1bHRLZXknIGlzIHBhc3NlZCB0aGVuICdkZmx0JyBpcyBhc3N1bWVkIHRvIGJlIGFuIG9iamVjdCB3aXRoXG4gIC8vIGEgbnVtYmVyIG9mIHBvc3NpYmxlIGRlZmF1bHQgdmFsdWVzIGFzIHByb3BlcnRpZXMgd2hlcmUgJ2RlZmF1bHRLZXknIGlzXG4gIC8vIHRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRoYXQgd2lsbCBiZSBjaG9zZW47IG90aGVyd2lzZSBpdCdzIGFzc3VtZWQgdG8gYmVcbiAgLy8gYSBzaW5nbGUgdmFsdWUuXG4gIGdldChrLCBkZmx0LCBkZWZhdWx0S2V5KSB7XG4gICAgaWYgKGRlZmF1bHRLZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhcyhrKSA/IHRoaXMudmFsdWVzW2tdIDogZGZsdFtkZWZhdWx0S2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaGFzKGspID8gdGhpcy52YWx1ZXNba10gOiBkZmx0O1xuICB9XG4gIC8vIENoZWNrIHdoZXRoZXIgd2UgaGF2ZSBhIHZhbHVlIGZvciBhIGtleS5cbiAgaGFzKGspIHtcbiAgICByZXR1cm4gayBpbiB0aGlzLnZhbHVlcztcbiAgfVxuICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBvbmUgb2YgdGhlIGdpdmVuIGFsdGVybmF0aXZlcy5cbiAgYWx0KGssIHYsIGEpIHtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IGEubGVuZ3RoOyArK24pIHtcbiAgICAgIGlmICh2ID09PSBhW25dKSB7XG4gICAgICAgIHRoaXMuc2V0KGssIHYpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gQWNjZXB0IGEgc2V0dGluZyBpZiBpdHMgYSB2YWxpZCAoc2lnbmVkKSBpbnRlZ2VyLlxuICBpbnRlZ2VyKGssIHYpIHtcbiAgICBpZiAoL14tP1xcZCskLy50ZXN0KHYpKSB7XG4gICAgICAvLyBpbnRlZ2VyXG4gICAgICB0aGlzLnNldChrLCBwYXJzZUludCh2LCAxMCkpO1xuICAgIH1cbiAgfVxuICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBhIHZhbGlkIHBlcmNlbnRhZ2UuXG4gIHBlcmNlbnQoaywgdikge1xuICAgIGlmICgvXihbXFxkXXsxLDN9KShcXC5bXFxkXSopPyUkLy50ZXN0KHYpKSB7XG4gICAgICBjb25zdCBwZXJjZW50ID0gcGFyc2VGbG9hdCh2KTtcbiAgICAgIGlmIChwZXJjZW50ID49IDAgJiYgcGVyY2VudCA8PSAxMDApIHtcbiAgICAgICAgdGhpcy5zZXQoaywgcGVyY2VudCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHBhcnNlIGlucHV0IGludG8gZ3JvdXBzIHNlcGFyYXRlZCBieSAnZ3JvdXBEZWxpbScsIGFuZFxuLy8gaW50ZXJwcmV0IGVhY2ggZ3JvdXAgYXMgYSBrZXkvdmFsdWUgcGFpciBzZXBhcmF0ZWQgYnkgJ2tleVZhbHVlRGVsaW0nLlxuZnVuY3Rpb24gcGFyc2VPcHRpb25zKGlucHV0LCBjYWxsYmFjaywga2V5VmFsdWVEZWxpbSwgZ3JvdXBEZWxpbSkge1xuICBjb25zdCBncm91cHMgPSBncm91cERlbGltID8gaW5wdXQuc3BsaXQoZ3JvdXBEZWxpbSkgOiBbaW5wdXRdO1xuICBmb3IgKGNvbnN0IGkgaW4gZ3JvdXBzKSB7XG4gICAgaWYgKHR5cGVvZiBncm91cHNbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3Qga3YgPSBncm91cHNbaV0uc3BsaXQoa2V5VmFsdWVEZWxpbSk7XG4gICAgaWYgKGt2Lmxlbmd0aCAhPT0gMikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGsgPSBrdlswXTtcbiAgICBjb25zdCB2ID0ga3ZbMV07XG4gICAgY2FsbGJhY2soaywgdik7XG4gIH1cbn1cbmNvbnN0IGRlZmF1bHRzID0gbmV3IFZUVEN1ZSgwLCAwLCAnJyk7XG4vLyAnbWlkZGxlJyB3YXMgY2hhbmdlZCB0byAnY2VudGVyJyBpbiB0aGUgc3BlYzogaHR0cHM6Ly9naXRodWIuY29tL3czYy93ZWJ2dHQvcHVsbC8yNDRcbi8vICBTYWZhcmkgZG9lc24ndCB5ZXQgc3VwcG9ydCB0aGlzIGNoYW5nZSwgYnV0IEZGIGFuZCBDaHJvbWUgZG8uXG5jb25zdCBjZW50ZXIgPSBkZWZhdWx0cy5hbGlnbiA9PT0gJ21pZGRsZScgPyAnbWlkZGxlJyA6ICdjZW50ZXInO1xuZnVuY3Rpb24gcGFyc2VDdWUoaW5wdXQsIGN1ZSwgcmVnaW9uTGlzdCkge1xuICAvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgaW5wdXQgaWYgd2UgbmVlZCB0byB0aHJvdyBhbiBlcnJvci5cbiAgY29uc3Qgb0lucHV0ID0gaW5wdXQ7XG4gIC8vIDQuMSBXZWJWVFQgdGltZXN0YW1wXG4gIGZ1bmN0aW9uIGNvbnN1bWVUaW1lU3RhbXAoKSB7XG4gICAgY29uc3QgdHMgPSBwYXJzZVRpbWVTdGFtcChpbnB1dCk7XG4gICAgaWYgKHRzID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCB0aW1lc3RhbXA6ICcgKyBvSW5wdXQpO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSB0aW1lIHN0YW1wIGZyb20gaW5wdXQuXG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9eW15cXHNhLXpBLVotXSsvLCAnJyk7XG4gICAgcmV0dXJuIHRzO1xuICB9XG5cbiAgLy8gNC40LjIgV2ViVlRUIGN1ZSBzZXR0aW5nc1xuICBmdW5jdGlvbiBjb25zdW1lQ3VlU2V0dGluZ3MoaW5wdXQsIGN1ZSkge1xuICAgIGNvbnN0IHNldHRpbmdzID0gbmV3IFNldHRpbmdzKCk7XG4gICAgcGFyc2VPcHRpb25zKGlucHV0LCBmdW5jdGlvbiAoaywgdikge1xuICAgICAgbGV0IHZhbHM7XG4gICAgICBzd2l0Y2ggKGspIHtcbiAgICAgICAgY2FzZSAncmVnaW9uJzpcbiAgICAgICAgICAvLyBGaW5kIHRoZSBsYXN0IHJlZ2lvbiB3ZSBwYXJzZWQgd2l0aCB0aGUgc2FtZSByZWdpb24gaWQuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IHJlZ2lvbkxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChyZWdpb25MaXN0W2ldLmlkID09PSB2KSB7XG4gICAgICAgICAgICAgIHNldHRpbmdzLnNldChrLCByZWdpb25MaXN0W2ldLnJlZ2lvbik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndmVydGljYWwnOlxuICAgICAgICAgIHNldHRpbmdzLmFsdChrLCB2LCBbJ3JsJywgJ2xyJ10pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdsaW5lJzpcbiAgICAgICAgICB2YWxzID0gdi5zcGxpdCgnLCcpO1xuICAgICAgICAgIHNldHRpbmdzLmludGVnZXIoaywgdmFsc1swXSk7XG4gICAgICAgICAgaWYgKHNldHRpbmdzLnBlcmNlbnQoaywgdmFsc1swXSkpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLnNldCgnc25hcFRvTGluZXMnLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldHRpbmdzLmFsdChrLCB2YWxzWzBdLCBbJ2F1dG8nXSk7XG4gICAgICAgICAgaWYgKHZhbHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5hbHQoJ2xpbmVBbGlnbicsIHZhbHNbMV0sIFsnc3RhcnQnLCBjZW50ZXIsICdlbmQnXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdwb3NpdGlvbic6XG4gICAgICAgICAgdmFscyA9IHYuc3BsaXQoJywnKTtcbiAgICAgICAgICBzZXR0aW5ncy5wZXJjZW50KGssIHZhbHNbMF0pO1xuICAgICAgICAgIGlmICh2YWxzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgc2V0dGluZ3MuYWx0KCdwb3NpdGlvbkFsaWduJywgdmFsc1sxXSwgWydzdGFydCcsIGNlbnRlciwgJ2VuZCcsICdsaW5lLWxlZnQnLCAnbGluZS1yaWdodCcsICdhdXRvJ10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2l6ZSc6XG4gICAgICAgICAgc2V0dGluZ3MucGVyY2VudChrLCB2KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYWxpZ24nOlxuICAgICAgICAgIHNldHRpbmdzLmFsdChrLCB2LCBbJ3N0YXJ0JywgY2VudGVyLCAnZW5kJywgJ2xlZnQnLCAncmlnaHQnXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSwgLzovLCAvXFxzLyk7XG5cbiAgICAvLyBBcHBseSBkZWZhdWx0IHZhbHVlcyBmb3IgYW55IG1pc3NpbmcgZmllbGRzLlxuICAgIGN1ZS5yZWdpb24gPSBzZXR0aW5ncy5nZXQoJ3JlZ2lvbicsIG51bGwpO1xuICAgIGN1ZS52ZXJ0aWNhbCA9IHNldHRpbmdzLmdldCgndmVydGljYWwnLCAnJyk7XG4gICAgbGV0IGxpbmUgPSBzZXR0aW5ncy5nZXQoJ2xpbmUnLCAnYXV0bycpO1xuICAgIGlmIChsaW5lID09PSAnYXV0bycgJiYgZGVmYXVsdHMubGluZSA9PT0gLTEpIHtcbiAgICAgIC8vIHNldCBudW1lcmljIGxpbmUgbnVtYmVyIGZvciBTYWZhcmlcbiAgICAgIGxpbmUgPSAtMTtcbiAgICB9XG4gICAgY3VlLmxpbmUgPSBsaW5lO1xuICAgIGN1ZS5saW5lQWxpZ24gPSBzZXR0aW5ncy5nZXQoJ2xpbmVBbGlnbicsICdzdGFydCcpO1xuICAgIGN1ZS5zbmFwVG9MaW5lcyA9IHNldHRpbmdzLmdldCgnc25hcFRvTGluZXMnLCB0cnVlKTtcbiAgICBjdWUuc2l6ZSA9IHNldHRpbmdzLmdldCgnc2l6ZScsIDEwMCk7XG4gICAgY3VlLmFsaWduID0gc2V0dGluZ3MuZ2V0KCdhbGlnbicsIGNlbnRlcik7XG4gICAgbGV0IHBvc2l0aW9uID0gc2V0dGluZ3MuZ2V0KCdwb3NpdGlvbicsICdhdXRvJyk7XG4gICAgaWYgKHBvc2l0aW9uID09PSAnYXV0bycgJiYgZGVmYXVsdHMucG9zaXRpb24gPT09IDUwKSB7XG4gICAgICAvLyBzZXQgbnVtZXJpYyBwb3NpdGlvbiBmb3IgU2FmYXJpXG4gICAgICBwb3NpdGlvbiA9IGN1ZS5hbGlnbiA9PT0gJ3N0YXJ0JyB8fCBjdWUuYWxpZ24gPT09ICdsZWZ0JyA/IDAgOiBjdWUuYWxpZ24gPT09ICdlbmQnIHx8IGN1ZS5hbGlnbiA9PT0gJ3JpZ2h0JyA/IDEwMCA6IDUwO1xuICAgIH1cbiAgICBjdWUucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgfVxuICBmdW5jdGlvbiBza2lwV2hpdGVzcGFjZSgpIHtcbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL15cXHMrLywgJycpO1xuICB9XG5cbiAgLy8gNC4xIFdlYlZUVCBjdWUgdGltaW5ncy5cbiAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgY3VlLnN0YXJ0VGltZSA9IGNvbnN1bWVUaW1lU3RhbXAoKTsgLy8gKDEpIGNvbGxlY3QgY3VlIHN0YXJ0IHRpbWVcbiAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgaWYgKGlucHV0LnNsaWNlKDAsIDMpICE9PSAnLS0+Jykge1xuICAgIC8vICgzKSBuZXh0IGNoYXJhY3RlcnMgbXVzdCBtYXRjaCAnLS0+J1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1hbGZvcm1lZCB0aW1lIHN0YW1wICh0aW1lIHN0YW1wcyBtdXN0IGJlIHNlcGFyYXRlZCBieSAnLS0+Jyk6IFwiICsgb0lucHV0KTtcbiAgfVxuICBpbnB1dCA9IGlucHV0LnNsaWNlKDMpO1xuICBza2lwV2hpdGVzcGFjZSgpO1xuICBjdWUuZW5kVGltZSA9IGNvbnN1bWVUaW1lU3RhbXAoKTsgLy8gKDUpIGNvbGxlY3QgY3VlIGVuZCB0aW1lXG5cbiAgLy8gNC4xIFdlYlZUVCBjdWUgc2V0dGluZ3MgbGlzdC5cbiAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgY29uc3VtZUN1ZVNldHRpbmdzKGlucHV0LCBjdWUpO1xufVxuZnVuY3Rpb24gZml4TGluZUJyZWFrcyhpbnB1dCkge1xuICByZXR1cm4gaW5wdXQucmVwbGFjZSgvPGJyKD86IFxcLyk/Pi9naSwgJ1xcbicpO1xufVxuY2xhc3MgVlRUUGFyc2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zdGF0ZSA9ICdJTklUSUFMJztcbiAgICB0aGlzLmJ1ZmZlciA9ICcnO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKCk7XG4gICAgdGhpcy5yZWdpb25MaXN0ID0gW107XG4gICAgdGhpcy5jdWUgPSBudWxsO1xuICAgIHRoaXMub25jdWUgPSB2b2lkIDA7XG4gICAgdGhpcy5vbnBhcnNpbmdlcnJvciA9IHZvaWQgMDtcbiAgICB0aGlzLm9uZmx1c2ggPSB2b2lkIDA7XG4gIH1cbiAgcGFyc2UoZGF0YSkge1xuICAgIGNvbnN0IF90aGlzID0gdGhpcztcblxuICAgIC8vIElmIHRoZXJlIGlzIG5vIGRhdGEgdGhlbiB3ZSB3b24ndCBkZWNvZGUgaXQsIGJ1dCB3aWxsIGp1c3QgdHJ5IHRvIHBhcnNlXG4gICAgLy8gd2hhdGV2ZXIgaXMgaW4gYnVmZmVyIGFscmVhZHkuIFRoaXMgbWF5IG9jY3VyIGluIGNpcmN1bXN0YW5jZXMsIGZvclxuICAgIC8vIGV4YW1wbGUgd2hlbiBmbHVzaCgpIGlzIGNhbGxlZC5cbiAgICBpZiAoZGF0YSkge1xuICAgICAgLy8gVHJ5IHRvIGRlY29kZSB0aGUgZGF0YSB0aGF0IHdlIHJlY2VpdmVkLlxuICAgICAgX3RoaXMuYnVmZmVyICs9IF90aGlzLmRlY29kZXIuZGVjb2RlKGRhdGEsIHtcbiAgICAgICAgc3RyZWFtOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29sbGVjdE5leHRMaW5lKCkge1xuICAgICAgbGV0IGJ1ZmZlciA9IF90aGlzLmJ1ZmZlcjtcbiAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgYnVmZmVyID0gZml4TGluZUJyZWFrcyhidWZmZXIpO1xuICAgICAgd2hpbGUgKHBvcyA8IGJ1ZmZlci5sZW5ndGggJiYgYnVmZmVyW3Bvc10gIT09ICdcXHInICYmIGJ1ZmZlcltwb3NdICE9PSAnXFxuJykge1xuICAgICAgICArK3BvcztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxpbmUgPSBidWZmZXIuc2xpY2UoMCwgcG9zKTtcbiAgICAgIC8vIEFkdmFuY2UgdGhlIGJ1ZmZlciBlYXJseSBpbiBjYXNlIHdlIGZhaWwgYmVsb3cuXG4gICAgICBpZiAoYnVmZmVyW3Bvc10gPT09ICdcXHInKSB7XG4gICAgICAgICsrcG9zO1xuICAgICAgfVxuICAgICAgaWYgKGJ1ZmZlcltwb3NdID09PSAnXFxuJykge1xuICAgICAgICArK3BvcztcbiAgICAgIH1cbiAgICAgIF90aGlzLmJ1ZmZlciA9IGJ1ZmZlci5zbGljZShwb3MpO1xuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfVxuXG4gICAgLy8gMy4yIFdlYlZUVCBtZXRhZGF0YSBoZWFkZXIgc3ludGF4XG4gICAgZnVuY3Rpb24gcGFyc2VIZWFkZXIoaW5wdXQpIHtcbiAgICAgIHBhcnNlT3B0aW9ucyhpbnB1dCwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgICAgLy8gc3dpdGNoIChrKSB7XG4gICAgICAgIC8vIGNhc2UgJ3JlZ2lvbic6XG4gICAgICAgIC8vIDMuMyBXZWJWVFQgcmVnaW9uIG1ldGFkYXRhIGhlYWRlciBzeW50YXhcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3BhcnNlIHJlZ2lvbicsIHYpO1xuICAgICAgICAvLyBwYXJzZVJlZ2lvbih2KTtcbiAgICAgICAgLy8gYnJlYWs7XG4gICAgICAgIC8vIH1cbiAgICAgIH0sIC86Lyk7XG4gICAgfVxuXG4gICAgLy8gNS4xIFdlYlZUVCBmaWxlIHBhcnNpbmcuXG4gICAgdHJ5IHtcbiAgICAgIGxldCBsaW5lID0gJyc7XG4gICAgICBpZiAoX3RoaXMuc3RhdGUgPT09ICdJTklUSUFMJykge1xuICAgICAgICAvLyBXZSBjYW4ndCBzdGFydCBwYXJzaW5nIHVudGlsIHdlIGhhdmUgdGhlIGZpcnN0IGxpbmUuXG4gICAgICAgIGlmICghL1xcclxcbnxcXG4vLnRlc3QoX3RoaXMuYnVmZmVyKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGxpbmUgPSBjb2xsZWN0TmV4dExpbmUoKTtcbiAgICAgICAgLy8gc3RyaXAgb2YgVVRGLTggQk9NIGlmIGFueVxuICAgICAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CeXRlX29yZGVyX21hcmsjVVRGLThcbiAgICAgICAgY29uc3QgbSA9IGxpbmUubWF0Y2goL14ow6/Cu8K/KT9XRUJWVFQoWyBcXHRdLiopPyQvKTtcbiAgICAgICAgaWYgKCEobSAhPSBudWxsICYmIG1bMF0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgV2ViVlRUIHNpZ25hdHVyZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5zdGF0ZSA9ICdIRUFERVInO1xuICAgICAgfVxuICAgICAgbGV0IGFscmVhZHlDb2xsZWN0ZWRMaW5lID0gZmFsc2U7XG4gICAgICB3aGlsZSAoX3RoaXMuYnVmZmVyKSB7XG4gICAgICAgIC8vIFdlIGNhbid0IHBhcnNlIGEgbGluZSB1bnRpbCB3ZSBoYXZlIHRoZSBmdWxsIGxpbmUuXG4gICAgICAgIGlmICghL1xcclxcbnxcXG4vLnRlc3QoX3RoaXMuYnVmZmVyKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYWxyZWFkeUNvbGxlY3RlZExpbmUpIHtcbiAgICAgICAgICBsaW5lID0gY29sbGVjdE5leHRMaW5lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWxyZWFkeUNvbGxlY3RlZExpbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKF90aGlzLnN0YXRlKSB7XG4gICAgICAgICAgY2FzZSAnSEVBREVSJzpcbiAgICAgICAgICAgIC8vIDEzLTE4IC0gQWxsb3cgYSBoZWFkZXIgKG1ldGFkYXRhKSB1bmRlciB0aGUgV0VCVlRUIGxpbmUuXG4gICAgICAgICAgICBpZiAoLzovLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgcGFyc2VIZWFkZXIobGluZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAgIC8vIEFuIGVtcHR5IGxpbmUgdGVybWluYXRlcyB0aGUgaGVhZGVyIGFuZCBzdGFydHMgdGhlIGJvZHkgKGN1ZXMpLlxuICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlICdOT1RFJzpcbiAgICAgICAgICAgIC8vIElnbm9yZSBOT1RFIGJsb2Nrcy5cbiAgICAgICAgICAgIGlmICghbGluZSkge1xuICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlICdJRCc6XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgdGhlIHN0YXJ0IG9mIE5PVEUgYmxvY2tzLlxuICAgICAgICAgICAgaWYgKC9eTk9URSgkfFsgXFx0XSkvLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSAnTk9URSc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gMTktMjkgLSBBbGxvdyBhbnkgbnVtYmVyIG9mIGxpbmUgdGVybWluYXRvcnMsIHRoZW4gaW5pdGlhbGl6ZSBuZXcgY3VlIHZhbHVlcy5cbiAgICAgICAgICAgIGlmICghbGluZSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmN1ZSA9IG5ldyBWVFRDdWUoMCwgMCwgJycpO1xuICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSAnQ1VFJztcbiAgICAgICAgICAgIC8vIDMwLTM5IC0gQ2hlY2sgaWYgc2VsZiBsaW5lIGNvbnRhaW5zIGFuIG9wdGlvbmFsIGlkZW50aWZpZXIgb3IgdGltaW5nIGRhdGEuXG4gICAgICAgICAgICBpZiAobGluZS5pbmRleE9mKCctLT4nKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgX3RoaXMuY3VlLmlkID0gbGluZTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgLy8gUHJvY2VzcyBsaW5lIGFzIHN0YXJ0IG9mIGEgY3VlLlxuICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICBjYXNlICdDVUUnOlxuICAgICAgICAgICAgLy8gNDAgLSBDb2xsZWN0IGN1ZSB0aW1pbmdzIGFuZCBzZXR0aW5ncy5cbiAgICAgICAgICAgIGlmICghX3RoaXMuY3VlKSB7XG4gICAgICAgICAgICAgIF90aGlzLnN0YXRlID0gJ0JBRENVRSc7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcGFyc2VDdWUobGluZSwgX3RoaXMuY3VlLCBfdGhpcy5yZWdpb25MaXN0KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgLy8gSW4gY2FzZSBvZiBhbiBlcnJvciBpZ25vcmUgcmVzdCBvZiB0aGUgY3VlLlxuICAgICAgICAgICAgICBfdGhpcy5jdWUgPSBudWxsO1xuICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdCQURDVUUnO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnN0YXRlID0gJ0NVRVRFWFQnO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSAnQ1VFVEVYVCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IGhhc1N1YnN0cmluZyA9IGxpbmUuaW5kZXhPZignLS0+JykgIT09IC0xO1xuICAgICAgICAgICAgICAvLyAzNCAtIElmIHdlIGhhdmUgYW4gZW1wdHkgbGluZSB0aGVuIHJlcG9ydCB0aGUgY3VlLlxuICAgICAgICAgICAgICAvLyAzNSAtIElmIHdlIGhhdmUgdGhlIHNwZWNpYWwgc3Vic3RyaW5nICctLT4nIHRoZW4gcmVwb3J0IHRoZSBjdWUsXG4gICAgICAgICAgICAgIC8vIGJ1dCBkbyBub3QgY29sbGVjdCB0aGUgbGluZSBhcyB3ZSBuZWVkIHRvIHByb2Nlc3MgdGhlIGN1cnJlbnRcbiAgICAgICAgICAgICAgLy8gb25lIGFzIGEgbmV3IGN1ZS5cbiAgICAgICAgICAgICAgaWYgKCFsaW5lIHx8IGhhc1N1YnN0cmluZyAmJiAoYWxyZWFkeUNvbGxlY3RlZExpbmUgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBkb25lIHBhcnNpbmcgc2VsZiBjdWUuXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLm9uY3VlICYmIF90aGlzLmN1ZSkge1xuICAgICAgICAgICAgICAgICAgX3RoaXMub25jdWUoX3RoaXMuY3VlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuY3VlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKF90aGlzLmN1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChfdGhpcy5jdWUudGV4dCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmN1ZS50ZXh0ICs9ICdcXG4nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF90aGlzLmN1ZS50ZXh0ICs9IGxpbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlICdCQURDVUUnOlxuICAgICAgICAgICAgLy8gNTQtNjIgLSBDb2xsZWN0IGFuZCBkaXNjYXJkIHRoZSByZW1haW5pbmcgY3VlLlxuICAgICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAgIF90aGlzLnN0YXRlID0gJ0lEJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgcGFyc2luZyBhIGN1ZSwgcmVwb3J0IHdoYXQgd2UgaGF2ZS5cbiAgICAgIGlmIChfdGhpcy5zdGF0ZSA9PT0gJ0NVRVRFWFQnICYmIF90aGlzLmN1ZSAmJiBfdGhpcy5vbmN1ZSkge1xuICAgICAgICBfdGhpcy5vbmN1ZShfdGhpcy5jdWUpO1xuICAgICAgfVxuICAgICAgX3RoaXMuY3VlID0gbnVsbDtcbiAgICAgIC8vIEVudGVyIEJBRFdFQlZUVCBzdGF0ZSBpZiBoZWFkZXIgd2FzIG5vdCBwYXJzZWQgY29ycmVjdGx5IG90aGVyd2lzZVxuICAgICAgLy8gYW5vdGhlciBleGNlcHRpb24gb2NjdXJyZWQgc28gZW50ZXIgQkFEQ1VFIHN0YXRlLlxuICAgICAgX3RoaXMuc3RhdGUgPSBfdGhpcy5zdGF0ZSA9PT0gJ0lOSVRJQUwnID8gJ0JBRFdFQlZUVCcgOiAnQkFEQ1VFJztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZmx1c2goKSB7XG4gICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgIHRyeSB7XG4gICAgICAvLyBGaW5pc2ggZGVjb2RpbmcgdGhlIHN0cmVhbS5cbiAgICAgIC8vIF90aGlzLmJ1ZmZlciArPSBfdGhpcy5kZWNvZGVyLmRlY29kZSgpO1xuICAgICAgLy8gU3ludGhlc2l6ZSB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGN1ZSBvciByZWdpb24uXG4gICAgICBpZiAoX3RoaXMuY3VlIHx8IF90aGlzLnN0YXRlID09PSAnSEVBREVSJykge1xuICAgICAgICBfdGhpcy5idWZmZXIgKz0gJ1xcblxcbic7XG4gICAgICAgIF90aGlzLnBhcnNlKCk7XG4gICAgICB9XG4gICAgICAvLyBJZiB3ZSd2ZSBmbHVzaGVkLCBwYXJzZWQsIGFuZCB3ZSdyZSBzdGlsbCBvbiB0aGUgSU5JVElBTCBzdGF0ZSB0aGVuXG4gICAgICAvLyB0aGF0IG1lYW5zIHdlIGRvbid0IGhhdmUgZW5vdWdoIG9mIHRoZSBzdHJlYW0gdG8gcGFyc2UgdGhlIGZpcnN0XG4gICAgICAvLyBsaW5lLlxuICAgICAgaWYgKF90aGlzLnN0YXRlID09PSAnSU5JVElBTCcgfHwgX3RoaXMuc3RhdGUgPT09ICdCQURXRUJWVFQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIFdlYlZUVCBzaWduYXR1cmUuJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKF90aGlzLm9ucGFyc2luZ2Vycm9yKSB7XG4gICAgICAgIF90aGlzLm9ucGFyc2luZ2Vycm9yKGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoX3RoaXMub25mbHVzaCkge1xuICAgICAgX3RoaXMub25mbHVzaCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG5jb25zdCBMSU5FQlJFQUtTID0gL1xcclxcbnxcXG5cXHJ8XFxufFxcci9nO1xuXG4vLyBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGggaXMgbm90IHN1cHBvcnRlZCBpbiBJRTExXG5jb25zdCBzdGFydHNXaXRoID0gZnVuY3Rpb24gc3RhcnRzV2l0aChpbnB1dFN0cmluZywgc2VhcmNoU3RyaW5nLCBwb3NpdGlvbiA9IDApIHtcbiAgcmV0dXJuIGlucHV0U3RyaW5nLnNsaWNlKHBvc2l0aW9uLCBwb3NpdGlvbiArIHNlYXJjaFN0cmluZy5sZW5ndGgpID09PSBzZWFyY2hTdHJpbmc7XG59O1xuY29uc3QgY3VlU3RyaW5nMm1pbGxpcyA9IGZ1bmN0aW9uIGN1ZVN0cmluZzJtaWxsaXModGltZVN0cmluZykge1xuICBsZXQgdHMgPSBwYXJzZUludCh0aW1lU3RyaW5nLnNsaWNlKC0zKSk7XG4gIGNvbnN0IHNlY3MgPSBwYXJzZUludCh0aW1lU3RyaW5nLnNsaWNlKC02LCAtNCkpO1xuICBjb25zdCBtaW5zID0gcGFyc2VJbnQodGltZVN0cmluZy5zbGljZSgtOSwgLTcpKTtcbiAgY29uc3QgaG91cnMgPSB0aW1lU3RyaW5nLmxlbmd0aCA+IDkgPyBwYXJzZUludCh0aW1lU3RyaW5nLnN1YnN0cmluZygwLCB0aW1lU3RyaW5nLmluZGV4T2YoJzonKSkpIDogMDtcbiAgaWYgKCFpc0Zpbml0ZU51bWJlcih0cykgfHwgIWlzRmluaXRlTnVtYmVyKHNlY3MpIHx8ICFpc0Zpbml0ZU51bWJlcihtaW5zKSB8fCAhaXNGaW5pdGVOdW1iZXIoaG91cnMpKSB7XG4gICAgdGhyb3cgRXJyb3IoYE1hbGZvcm1lZCBYLVRJTUVTVEFNUC1NQVA6IExvY2FsOiR7dGltZVN0cmluZ31gKTtcbiAgfVxuICB0cyArPSAxMDAwICogc2VjcztcbiAgdHMgKz0gNjAgKiAxMDAwICogbWlucztcbiAgdHMgKz0gNjAgKiA2MCAqIDEwMDAgKiBob3VycztcbiAgcmV0dXJuIHRzO1xufTtcblxuLy8gQ3JlYXRlIGEgdW5pcXVlIGhhc2ggaWQgZm9yIGEgY3VlIGJhc2VkIG9uIHN0YXJ0L2VuZCB0aW1lcyBhbmQgdGV4dC5cbi8vIFRoaXMgaGVscHMgdGltZWxpbmUtY29udHJvbGxlciB0byBhdm9pZCBzaG93aW5nIHJlcGVhdGVkIGNhcHRpb25zLlxuZnVuY3Rpb24gZ2VuZXJhdGVDdWVJZChzdGFydFRpbWUsIGVuZFRpbWUsIHRleHQpIHtcbiAgcmV0dXJuIGhhc2goc3RhcnRUaW1lLnRvU3RyaW5nKCkpICsgaGFzaChlbmRUaW1lLnRvU3RyaW5nKCkpICsgaGFzaCh0ZXh0KTtcbn1cbmNvbnN0IGNhbGN1bGF0ZU9mZnNldCA9IGZ1bmN0aW9uIGNhbGN1bGF0ZU9mZnNldCh2dHRDQ3MsIGNjLCBwcmVzZW50YXRpb25UaW1lKSB7XG4gIGxldCBjdXJyQ0MgPSB2dHRDQ3NbY2NdO1xuICBsZXQgcHJldkNDID0gdnR0Q0NzW2N1cnJDQy5wcmV2Q0NdO1xuXG4gIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGRpc2NvbnRpbnVpdHkgb3IgY3VlcyBoYXZlIGJlZW4gcHJvY2Vzc2VkIHNpbmNlIHRoZSBsYXN0IGRpc2NvbnRpbnVpdHlcbiAgLy8gT2Zmc2V0ID0gY3VycmVudCBkaXNjb250aW51aXR5IHRpbWVcbiAgaWYgKCFwcmV2Q0MgfHwgIXByZXZDQy5uZXcgJiYgY3VyckNDLm5ldykge1xuICAgIHZ0dENDcy5jY09mZnNldCA9IHZ0dENDcy5wcmVzZW50YXRpb25PZmZzZXQgPSBjdXJyQ0Muc3RhcnQ7XG4gICAgY3VyckNDLm5ldyA9IGZhbHNlO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRoZXJlIGhhdmUgYmVlbiBkaXNjb250aW51aXRpZXMgc2luY2UgY3VlcyB3ZXJlIGxhc3QgcGFyc2VkLlxuICAvLyBPZmZzZXQgPSB0aW1lIGVsYXBzZWRcbiAgd2hpbGUgKChfcHJldkNDID0gcHJldkNDKSAhPSBudWxsICYmIF9wcmV2Q0MubmV3KSB7XG4gICAgdmFyIF9wcmV2Q0M7XG4gICAgdnR0Q0NzLmNjT2Zmc2V0ICs9IGN1cnJDQy5zdGFydCAtIHByZXZDQy5zdGFydDtcbiAgICBjdXJyQ0MubmV3ID0gZmFsc2U7XG4gICAgY3VyckNDID0gcHJldkNDO1xuICAgIHByZXZDQyA9IHZ0dENDc1tjdXJyQ0MucHJldkNDXTtcbiAgfVxuICB2dHRDQ3MucHJlc2VudGF0aW9uT2Zmc2V0ID0gcHJlc2VudGF0aW9uVGltZTtcbn07XG5mdW5jdGlvbiBwYXJzZVdlYlZUVCh2dHRCeXRlQXJyYXksIGluaXRQVFMsIHZ0dENDcywgY2MsIHRpbWVPZmZzZXQsIGNhbGxCYWNrLCBlcnJvckNhbGxCYWNrKSB7XG4gIGNvbnN0IHBhcnNlciA9IG5ldyBWVFRQYXJzZXIoKTtcbiAgLy8gQ29udmVydCBieXRlQXJyYXkgaW50byBzdHJpbmcsIHJlcGxhY2luZyBhbnkgc29tZXdoYXQgZXhvdGljIGxpbmVmZWVkcyB3aXRoIFwiXFxuXCIsIHRoZW4gc3BsaXQgb24gdGhhdCBjaGFyYWN0ZXIuXG4gIC8vIFVpbnQ4QXJyYXkucHJvdG90eXBlLnJlZHVjZSBpcyBub3QgaW1wbGVtZW50ZWQgaW4gSUUxMVxuICBjb25zdCB2dHRMaW5lcyA9IHV0ZjhBcnJheVRvU3RyKG5ldyBVaW50OEFycmF5KHZ0dEJ5dGVBcnJheSkpLnRyaW0oKS5yZXBsYWNlKExJTkVCUkVBS1MsICdcXG4nKS5zcGxpdCgnXFxuJyk7XG4gIGNvbnN0IGN1ZXMgPSBbXTtcbiAgY29uc3QgaW5pdDkwa0h6ID0gaW5pdFBUUyA/IHRvTXBlZ1RzQ2xvY2tGcm9tVGltZXNjYWxlKGluaXRQVFMuYmFzZVRpbWUsIGluaXRQVFMudGltZXNjYWxlKSA6IDA7XG4gIGxldCBjdWVUaW1lID0gJzAwOjAwLjAwMCc7XG4gIGxldCB0aW1lc3RhbXBNYXBNUEVHVFMgPSAwO1xuICBsZXQgdGltZXN0YW1wTWFwTE9DQUwgPSAwO1xuICBsZXQgcGFyc2luZ0Vycm9yO1xuICBsZXQgaW5IZWFkZXIgPSB0cnVlO1xuICBwYXJzZXIub25jdWUgPSBmdW5jdGlvbiAoY3VlKSB7XG4gICAgLy8gQWRqdXN0IGN1ZSB0aW1pbmc7IGNsYW1wIGN1ZXMgdG8gc3RhcnQgbm8gZWFybGllciB0aGFuIC0gYW5kIGRyb3AgY3VlcyB0aGF0IGRvbid0IGVuZCBhZnRlciAtIDAgb24gdGltZWxpbmUuXG4gICAgY29uc3QgY3VyckNDID0gdnR0Q0NzW2NjXTtcbiAgICBsZXQgY3VlT2Zmc2V0ID0gdnR0Q0NzLmNjT2Zmc2V0O1xuXG4gICAgLy8gQ2FsY3VsYXRlIHN1YnRpdGxlIFBUUyBvZmZzZXRcbiAgICBjb25zdCB3ZWJWdHRNcGVnVHNNYXBPZmZzZXQgPSAodGltZXN0YW1wTWFwTVBFR1RTIC0gaW5pdDkwa0h6KSAvIDkwMDAwO1xuXG4gICAgLy8gVXBkYXRlIG9mZnNldHMgZm9yIG5ldyBkaXNjb250aW51aXRpZXNcbiAgICBpZiAoY3VyckNDICE9IG51bGwgJiYgY3VyckNDLm5ldykge1xuICAgICAgaWYgKHRpbWVzdGFtcE1hcExPQ0FMICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gV2hlbiBsb2NhbCB0aW1lIGlzIHByb3ZpZGVkLCBvZmZzZXQgPSBkaXNjb250aW51aXR5IHN0YXJ0IHRpbWUgLSBsb2NhbCB0aW1lXG4gICAgICAgIGN1ZU9mZnNldCA9IHZ0dENDcy5jY09mZnNldCA9IGN1cnJDQy5zdGFydDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGN1bGF0ZU9mZnNldCh2dHRDQ3MsIGNjLCB3ZWJWdHRNcGVnVHNNYXBPZmZzZXQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAod2ViVnR0TXBlZ1RzTWFwT2Zmc2V0KSB7XG4gICAgICBpZiAoIWluaXRQVFMpIHtcbiAgICAgICAgcGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKCdNaXNzaW5nIGluaXRQVFMgZm9yIFZUVCBNUEVHVFMnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gSWYgd2UgaGF2ZSBNUEVHVFMsIG9mZnNldCA9IHByZXNlbnRhdGlvbiB0aW1lICsgZGlzY29udGludWl0eSBvZmZzZXRcbiAgICAgIGN1ZU9mZnNldCA9IHdlYlZ0dE1wZWdUc01hcE9mZnNldCAtIHZ0dENDcy5wcmVzZW50YXRpb25PZmZzZXQ7XG4gICAgfVxuICAgIGNvbnN0IGR1cmF0aW9uID0gY3VlLmVuZFRpbWUgLSBjdWUuc3RhcnRUaW1lO1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IG5vcm1hbGl6ZVB0cygoY3VlLnN0YXJ0VGltZSArIGN1ZU9mZnNldCAtIHRpbWVzdGFtcE1hcExPQ0FMKSAqIDkwMDAwLCB0aW1lT2Zmc2V0ICogOTAwMDApIC8gOTAwMDA7XG4gICAgY3VlLnN0YXJ0VGltZSA9IE1hdGgubWF4KHN0YXJ0VGltZSwgMCk7XG4gICAgY3VlLmVuZFRpbWUgPSBNYXRoLm1heChzdGFydFRpbWUgKyBkdXJhdGlvbiwgMCk7XG5cbiAgICAvL3RyaW0gdHJhaWxpbmcgd2VidnR0IGJsb2NrIHdoaXRlc3BhY2VzXG4gICAgY29uc3QgdGV4dCA9IGN1ZS50ZXh0LnRyaW0oKTtcblxuICAgIC8vIEZpeCBlbmNvZGluZyBvZiBzcGVjaWFsIGNoYXJhY3RlcnNcbiAgICBjdWUudGV4dCA9IGRlY29kZVVSSUNvbXBvbmVudChlbmNvZGVVUklDb21wb25lbnQodGV4dCkpO1xuXG4gICAgLy8gSWYgdGhlIGN1ZSB3YXMgbm90IGFzc2lnbmVkIGFuIGlkIGZyb20gdGhlIFZUVCBmaWxlIChsaW5lIGFib3ZlIHRoZSBjb250ZW50KSwgY3JlYXRlIG9uZS5cbiAgICBpZiAoIWN1ZS5pZCkge1xuICAgICAgY3VlLmlkID0gZ2VuZXJhdGVDdWVJZChjdWUuc3RhcnRUaW1lLCBjdWUuZW5kVGltZSwgdGV4dCk7XG4gICAgfVxuICAgIGlmIChjdWUuZW5kVGltZSA+IDApIHtcbiAgICAgIGN1ZXMucHVzaChjdWUpO1xuICAgIH1cbiAgfTtcbiAgcGFyc2VyLm9ucGFyc2luZ2Vycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgcGFyc2luZ0Vycm9yID0gZXJyb3I7XG4gIH07XG4gIHBhcnNlci5vbmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChwYXJzaW5nRXJyb3IpIHtcbiAgICAgIGVycm9yQ2FsbEJhY2socGFyc2luZ0Vycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbEJhY2soY3Vlcyk7XG4gIH07XG5cbiAgLy8gR28gdGhyb3VnaCBjb250ZW50cyBsaW5lIGJ5IGxpbmUuXG4gIHZ0dExpbmVzLmZvckVhY2gobGluZSA9PiB7XG4gICAgaWYgKGluSGVhZGVyKSB7XG4gICAgICAvLyBMb29rIGZvciBYLVRJTUVTVEFNUC1NQVAgaW4gaGVhZGVyLlxuICAgICAgaWYgKHN0YXJ0c1dpdGgobGluZSwgJ1gtVElNRVNUQU1QLU1BUD0nKSkge1xuICAgICAgICAvLyBPbmNlIGZvdW5kLCBubyBtb3JlIGFyZSBhbGxvd2VkIGFueXdheSwgc28gc3RvcCBzZWFyY2hpbmcuXG4gICAgICAgIGluSGVhZGVyID0gZmFsc2U7XG4gICAgICAgIC8vIEV4dHJhY3QgTE9DQUwgYW5kIE1QRUdUUy5cbiAgICAgICAgbGluZS5zbGljZSgxNikuc3BsaXQoJywnKS5mb3JFYWNoKHRpbWVzdGFtcCA9PiB7XG4gICAgICAgICAgaWYgKHN0YXJ0c1dpdGgodGltZXN0YW1wLCAnTE9DQUw6JykpIHtcbiAgICAgICAgICAgIGN1ZVRpbWUgPSB0aW1lc3RhbXAuc2xpY2UoNik7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGFydHNXaXRoKHRpbWVzdGFtcCwgJ01QRUdUUzonKSkge1xuICAgICAgICAgICAgdGltZXN0YW1wTWFwTVBFR1RTID0gcGFyc2VJbnQodGltZXN0YW1wLnNsaWNlKDcpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIENvbnZlcnQgY3VlIHRpbWUgdG8gc2Vjb25kc1xuICAgICAgICAgIHRpbWVzdGFtcE1hcExPQ0FMID0gY3VlU3RyaW5nMm1pbGxpcyhjdWVUaW1lKSAvIDEwMDA7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcGFyc2luZ0Vycm9yID0gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIHdpdGhvdXQgcGFyc2luZyBYLVRJTUVTVEFNUC1NQVAgbGluZS5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChsaW5lID09PSAnJykge1xuICAgICAgICBpbkhlYWRlciA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBQYXJzZSBsaW5lIGJ5IGRlZmF1bHQuXG4gICAgcGFyc2VyLnBhcnNlKGxpbmUgKyAnXFxuJyk7XG4gIH0pO1xuICBwYXJzZXIuZmx1c2goKTtcbn1cblxuY29uc3QgSU1TQzFfQ09ERUMgPSAnc3RwcC50dG1sLmltMXQnO1xuXG4vLyBUaW1lIGZvcm1hdDogaDptOnM6ZnJhbWVzKC5zdWJmcmFtZXMpXG5jb25zdCBITVNGX1JFR0VYID0gL14oXFxkezIsfSk6KFxcZHsyfSk6KFxcZHsyfSk6KFxcZHsyfSlcXC4/KFxcZCspPyQvO1xuXG4vLyBUaW1lIGZvcm1hdDogaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgZnJhbWVzLCB0aWNrc1xuY29uc3QgVElNRV9VTklUX1JFR0VYID0gL14oXFxkKig/OlxcLlxcZCopPykoaHxtfHN8bXN8Znx0KSQvO1xuY29uc3QgdGV4dEFsaWduVG9MaW5lQWxpZ24gPSB7XG4gIGxlZnQ6ICdzdGFydCcsXG4gIGNlbnRlcjogJ2NlbnRlcicsXG4gIHJpZ2h0OiAnZW5kJyxcbiAgc3RhcnQ6ICdzdGFydCcsXG4gIGVuZDogJ2VuZCdcbn07XG5mdW5jdGlvbiBwYXJzZUlNU0MxKHBheWxvYWQsIGluaXRQVFMsIGNhbGxCYWNrLCBlcnJvckNhbGxCYWNrKSB7XG4gIGNvbnN0IHJlc3VsdHMgPSBmaW5kQm94KG5ldyBVaW50OEFycmF5KHBheWxvYWQpLCBbJ21kYXQnXSk7XG4gIGlmIChyZXN1bHRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGVycm9yQ2FsbEJhY2sobmV3IEVycm9yKCdDb3VsZCBub3QgcGFyc2UgSU1TQzEgbWRhdCcpKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdHRtbExpc3QgPSByZXN1bHRzLm1hcChtZGF0ID0+IHV0ZjhBcnJheVRvU3RyKG1kYXQpKTtcbiAgY29uc3Qgc3luY1RpbWUgPSB0b1RpbWVzY2FsZUZyb21TY2FsZShpbml0UFRTLmJhc2VUaW1lLCAxLCBpbml0UFRTLnRpbWVzY2FsZSk7XG4gIHRyeSB7XG4gICAgdHRtbExpc3QuZm9yRWFjaCh0dG1sID0+IGNhbGxCYWNrKHBhcnNlVFRNTCh0dG1sLCBzeW5jVGltZSkpKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBlcnJvckNhbGxCYWNrKGVycm9yKTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VUVE1MKHR0bWwsIHN5bmNUaW1lKSB7XG4gIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgY29uc3QgeG1sRG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyh0dG1sLCAndGV4dC94bWwnKTtcbiAgY29uc3QgdHQgPSB4bWxEb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3R0JylbMF07XG4gIGlmICghdHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHRtbCcpO1xuICB9XG4gIGNvbnN0IGRlZmF1bHRSYXRlSW5mbyA9IHtcbiAgICBmcmFtZVJhdGU6IDMwLFxuICAgIHN1YkZyYW1lUmF0ZTogMSxcbiAgICBmcmFtZVJhdGVNdWx0aXBsaWVyOiAwLFxuICAgIHRpY2tSYXRlOiAwXG4gIH07XG4gIGNvbnN0IHJhdGVJbmZvID0gT2JqZWN0LmtleXMoZGVmYXVsdFJhdGVJbmZvKS5yZWR1Y2UoKHJlc3VsdCwga2V5KSA9PiB7XG4gICAgcmVzdWx0W2tleV0gPSB0dC5nZXRBdHRyaWJ1dGUoYHR0cDoke2tleX1gKSB8fCBkZWZhdWx0UmF0ZUluZm9ba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCB7fSk7XG4gIGNvbnN0IHRyaW0gPSB0dC5nZXRBdHRyaWJ1dGUoJ3htbDpzcGFjZScpICE9PSAncHJlc2VydmUnO1xuICBjb25zdCBzdHlsZUVsZW1lbnRzID0gY29sbGVjdGlvblRvRGljdGlvbmFyeShnZXRFbGVtZW50Q29sbGVjdGlvbih0dCwgJ3N0eWxpbmcnLCAnc3R5bGUnKSk7XG4gIGNvbnN0IHJlZ2lvbkVsZW1lbnRzID0gY29sbGVjdGlvblRvRGljdGlvbmFyeShnZXRFbGVtZW50Q29sbGVjdGlvbih0dCwgJ2xheW91dCcsICdyZWdpb24nKSk7XG4gIGNvbnN0IGN1ZUVsZW1lbnRzID0gZ2V0RWxlbWVudENvbGxlY3Rpb24odHQsICdib2R5JywgJ1tiZWdpbl0nKTtcbiAgcmV0dXJuIFtdLm1hcC5jYWxsKGN1ZUVsZW1lbnRzLCBjdWVFbGVtZW50ID0+IHtcbiAgICBjb25zdCBjdWVUZXh0ID0gZ2V0VGV4dENvbnRlbnQoY3VlRWxlbWVudCwgdHJpbSk7XG4gICAgaWYgKCFjdWVUZXh0IHx8ICFjdWVFbGVtZW50Lmhhc0F0dHJpYnV0ZSgnYmVnaW4nKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBhcnNlVHRtbFRpbWUoY3VlRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2JlZ2luJyksIHJhdGVJbmZvKTtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHBhcnNlVHRtbFRpbWUoY3VlRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2R1cicpLCByYXRlSW5mbyk7XG4gICAgbGV0IGVuZFRpbWUgPSBwYXJzZVR0bWxUaW1lKGN1ZUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdlbmQnKSwgcmF0ZUluZm8pO1xuICAgIGlmIChzdGFydFRpbWUgPT09IG51bGwpIHtcbiAgICAgIHRocm93IHRpbWVzdGFtcFBhcnNpbmdFcnJvcihjdWVFbGVtZW50KTtcbiAgICB9XG4gICAgaWYgKGVuZFRpbWUgPT09IG51bGwpIHtcbiAgICAgIGlmIChkdXJhdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyB0aW1lc3RhbXBQYXJzaW5nRXJyb3IoY3VlRWxlbWVudCk7XG4gICAgICB9XG4gICAgICBlbmRUaW1lID0gc3RhcnRUaW1lICsgZHVyYXRpb247XG4gICAgfVxuICAgIGNvbnN0IGN1ZSA9IG5ldyBWVFRDdWUoc3RhcnRUaW1lIC0gc3luY1RpbWUsIGVuZFRpbWUgLSBzeW5jVGltZSwgY3VlVGV4dCk7XG4gICAgY3VlLmlkID0gZ2VuZXJhdGVDdWVJZChjdWUuc3RhcnRUaW1lLCBjdWUuZW5kVGltZSwgY3VlLnRleHQpO1xuICAgIGNvbnN0IHJlZ2lvbiA9IHJlZ2lvbkVsZW1lbnRzW2N1ZUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdyZWdpb24nKV07XG4gICAgY29uc3Qgc3R5bGUgPSBzdHlsZUVsZW1lbnRzW2N1ZUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzdHlsZScpXTtcblxuICAgIC8vIEFwcGx5IHN0eWxlcyB0byBjdWVcbiAgICBjb25zdCBzdHlsZXMgPSBnZXRUdG1sU3R5bGVzKHJlZ2lvbiwgc3R5bGUsIHN0eWxlRWxlbWVudHMpO1xuICAgIGNvbnN0IHtcbiAgICAgIHRleHRBbGlnblxuICAgIH0gPSBzdHlsZXM7XG4gICAgaWYgKHRleHRBbGlnbikge1xuICAgICAgLy8gY3VlLnBvc2l0aW9uQWxpZ24gbm90IHNldHRhYmxlIGluIEZGfjIwMTZcbiAgICAgIGNvbnN0IGxpbmVBbGlnbiA9IHRleHRBbGlnblRvTGluZUFsaWduW3RleHRBbGlnbl07XG4gICAgICBpZiAobGluZUFsaWduKSB7XG4gICAgICAgIGN1ZS5saW5lQWxpZ24gPSBsaW5lQWxpZ247XG4gICAgICB9XG4gICAgICBjdWUuYWxpZ24gPSB0ZXh0QWxpZ247XG4gICAgfVxuICAgIF9leHRlbmRzKGN1ZSwgc3R5bGVzKTtcbiAgICByZXR1cm4gY3VlO1xuICB9KS5maWx0ZXIoY3VlID0+IGN1ZSAhPT0gbnVsbCk7XG59XG5mdW5jdGlvbiBnZXRFbGVtZW50Q29sbGVjdGlvbihmcm9tRWxlbWVudCwgcGFyZW50TmFtZSwgY2hpbGROYW1lKSB7XG4gIGNvbnN0IHBhcmVudCA9IGZyb21FbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKHBhcmVudE5hbWUpWzBdO1xuICBpZiAocGFyZW50KSB7XG4gICAgcmV0dXJuIFtdLnNsaWNlLmNhbGwocGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoY2hpbGROYW1lKSk7XG4gIH1cbiAgcmV0dXJuIFtdO1xufVxuZnVuY3Rpb24gY29sbGVjdGlvblRvRGljdGlvbmFyeShlbGVtZW50c1dpdGhJZCkge1xuICByZXR1cm4gZWxlbWVudHNXaXRoSWQucmVkdWNlKChkaWN0LCBlbGVtZW50KSA9PiB7XG4gICAgY29uc3QgaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgneG1sOmlkJyk7XG4gICAgaWYgKGlkKSB7XG4gICAgICBkaWN0W2lkXSA9IGVsZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBkaWN0O1xuICB9LCB7fSk7XG59XG5mdW5jdGlvbiBnZXRUZXh0Q29udGVudChlbGVtZW50LCB0cmltKSB7XG4gIHJldHVybiBbXS5zbGljZS5jYWxsKGVsZW1lbnQuY2hpbGROb2RlcykucmVkdWNlKChzdHIsIG5vZGUsIGkpID0+IHtcbiAgICB2YXIgX25vZGUkY2hpbGROb2RlcztcbiAgICBpZiAobm9kZS5ub2RlTmFtZSA9PT0gJ2JyJyAmJiBpKSB7XG4gICAgICByZXR1cm4gc3RyICsgJ1xcbic7XG4gICAgfVxuICAgIGlmICgoX25vZGUkY2hpbGROb2RlcyA9IG5vZGUuY2hpbGROb2RlcykgIT0gbnVsbCAmJiBfbm9kZSRjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGdldFRleHRDb250ZW50KG5vZGUsIHRyaW0pO1xuICAgIH0gZWxzZSBpZiAodHJpbSkge1xuICAgICAgcmV0dXJuIHN0ciArIG5vZGUudGV4dENvbnRlbnQudHJpbSgpLnJlcGxhY2UoL1xccysvZywgJyAnKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0ciArIG5vZGUudGV4dENvbnRlbnQ7XG4gIH0sICcnKTtcbn1cbmZ1bmN0aW9uIGdldFR0bWxTdHlsZXMocmVnaW9uLCBzdHlsZSwgc3R5bGVFbGVtZW50cykge1xuICBjb25zdCB0dHNOcyA9ICdodHRwOi8vd3d3LnczLm9yZy9ucy90dG1sI3N0eWxpbmcnO1xuICBsZXQgcmVnaW9uU3R5bGUgPSBudWxsO1xuICBjb25zdCBzdHlsZUF0dHJpYnV0ZXMgPSBbJ2Rpc3BsYXlBbGlnbicsICd0ZXh0QWxpZ24nLCAnY29sb3InLCAnYmFja2dyb3VuZENvbG9yJywgJ2ZvbnRTaXplJywgJ2ZvbnRGYW1pbHknXG4gIC8vICdmb250V2VpZ2h0JyxcbiAgLy8gJ2xpbmVIZWlnaHQnLFxuICAvLyAnd3JhcE9wdGlvbicsXG4gIC8vICdmb250U3R5bGUnLFxuICAvLyAnZGlyZWN0aW9uJyxcbiAgLy8gJ3dyaXRpbmdNb2RlJ1xuICBdO1xuICBjb25zdCByZWdpb25TdHlsZU5hbWUgPSByZWdpb24gIT0gbnVsbCAmJiByZWdpb24uaGFzQXR0cmlidXRlKCdzdHlsZScpID8gcmVnaW9uLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSA6IG51bGw7XG4gIGlmIChyZWdpb25TdHlsZU5hbWUgJiYgc3R5bGVFbGVtZW50cy5oYXNPd25Qcm9wZXJ0eShyZWdpb25TdHlsZU5hbWUpKSB7XG4gICAgcmVnaW9uU3R5bGUgPSBzdHlsZUVsZW1lbnRzW3JlZ2lvblN0eWxlTmFtZV07XG4gIH1cbiAgcmV0dXJuIHN0eWxlQXR0cmlidXRlcy5yZWR1Y2UoKHN0eWxlcywgbmFtZSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0QXR0cmlidXRlTlMoc3R5bGUsIHR0c05zLCBuYW1lKSB8fCBnZXRBdHRyaWJ1dGVOUyhyZWdpb24sIHR0c05zLCBuYW1lKSB8fCBnZXRBdHRyaWJ1dGVOUyhyZWdpb25TdHlsZSwgdHRzTnMsIG5hbWUpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgc3R5bGVzW25hbWVdID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBzdHlsZXM7XG4gIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZU5TKGVsZW1lbnQsIG5zLCBuYW1lKSB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBlbGVtZW50Lmhhc0F0dHJpYnV0ZU5TKG5zLCBuYW1lKSA/IGVsZW1lbnQuZ2V0QXR0cmlidXRlTlMobnMsIG5hbWUpIDogbnVsbDtcbn1cbmZ1bmN0aW9uIHRpbWVzdGFtcFBhcnNpbmdFcnJvcihub2RlKSB7XG4gIHJldHVybiBuZXcgRXJyb3IoYENvdWxkIG5vdCBwYXJzZSB0dG1sIHRpbWVzdGFtcCAke25vZGV9YCk7XG59XG5mdW5jdGlvbiBwYXJzZVR0bWxUaW1lKHRpbWVBdHRyaWJ1dGVWYWx1ZSwgcmF0ZUluZm8pIHtcbiAgaWYgKCF0aW1lQXR0cmlidXRlVmFsdWUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBsZXQgc2Vjb25kcyA9IHBhcnNlVGltZVN0YW1wKHRpbWVBdHRyaWJ1dGVWYWx1ZSk7XG4gIGlmIChzZWNvbmRzID09PSBudWxsKSB7XG4gICAgaWYgKEhNU0ZfUkVHRVgudGVzdCh0aW1lQXR0cmlidXRlVmFsdWUpKSB7XG4gICAgICBzZWNvbmRzID0gcGFyc2VIb3Vyc01pbnV0ZXNTZWNvbmRzRnJhbWVzKHRpbWVBdHRyaWJ1dGVWYWx1ZSwgcmF0ZUluZm8pO1xuICAgIH0gZWxzZSBpZiAoVElNRV9VTklUX1JFR0VYLnRlc3QodGltZUF0dHJpYnV0ZVZhbHVlKSkge1xuICAgICAgc2Vjb25kcyA9IHBhcnNlVGltZVVuaXRzKHRpbWVBdHRyaWJ1dGVWYWx1ZSwgcmF0ZUluZm8pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2Vjb25kcztcbn1cbmZ1bmN0aW9uIHBhcnNlSG91cnNNaW51dGVzU2Vjb25kc0ZyYW1lcyh0aW1lQXR0cmlidXRlVmFsdWUsIHJhdGVJbmZvKSB7XG4gIGNvbnN0IG0gPSBITVNGX1JFR0VYLmV4ZWModGltZUF0dHJpYnV0ZVZhbHVlKTtcbiAgY29uc3QgZnJhbWVzID0gKG1bNF0gfCAwKSArIChtWzVdIHwgMCkgLyByYXRlSW5mby5zdWJGcmFtZVJhdGU7XG4gIHJldHVybiAobVsxXSB8IDApICogMzYwMCArIChtWzJdIHwgMCkgKiA2MCArIChtWzNdIHwgMCkgKyBmcmFtZXMgLyByYXRlSW5mby5mcmFtZVJhdGU7XG59XG5mdW5jdGlvbiBwYXJzZVRpbWVVbml0cyh0aW1lQXR0cmlidXRlVmFsdWUsIHJhdGVJbmZvKSB7XG4gIGNvbnN0IG0gPSBUSU1FX1VOSVRfUkVHRVguZXhlYyh0aW1lQXR0cmlidXRlVmFsdWUpO1xuICBjb25zdCB2YWx1ZSA9IE51bWJlcihtWzFdKTtcbiAgY29uc3QgdW5pdCA9IG1bMl07XG4gIHN3aXRjaCAodW5pdCkge1xuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIHZhbHVlICogMzYwMDtcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiB2YWx1ZSAqIDYwO1xuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiB2YWx1ZSAqIDEwMDA7XG4gICAgY2FzZSAnZic6XG4gICAgICByZXR1cm4gdmFsdWUgLyByYXRlSW5mby5mcmFtZVJhdGU7XG4gICAgY2FzZSAndCc6XG4gICAgICByZXR1cm4gdmFsdWUgLyByYXRlSW5mby50aWNrUmF0ZTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmNsYXNzIE91dHB1dEZpbHRlciB7XG4gIGNvbnN0cnVjdG9yKHRpbWVsaW5lQ29udHJvbGxlciwgdHJhY2tOYW1lKSB7XG4gICAgdGhpcy50aW1lbGluZUNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jdWVSYW5nZXMgPSBbXTtcbiAgICB0aGlzLnRyYWNrTmFtZSA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YXJ0VGltZSA9IG51bGw7XG4gICAgdGhpcy5lbmRUaW1lID0gbnVsbDtcbiAgICB0aGlzLnNjcmVlbiA9IG51bGw7XG4gICAgdGhpcy50aW1lbGluZUNvbnRyb2xsZXIgPSB0aW1lbGluZUNvbnRyb2xsZXI7XG4gICAgdGhpcy50cmFja05hbWUgPSB0cmFja05hbWU7XG4gIH1cbiAgZGlzcGF0Y2hDdWUoKSB7XG4gICAgaWYgKHRoaXMuc3RhcnRUaW1lID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudGltZWxpbmVDb250cm9sbGVyLmFkZEN1ZXModGhpcy50cmFja05hbWUsIHRoaXMuc3RhcnRUaW1lLCB0aGlzLmVuZFRpbWUsIHRoaXMuc2NyZWVuLCB0aGlzLmN1ZVJhbmdlcyk7XG4gICAgdGhpcy5zdGFydFRpbWUgPSBudWxsO1xuICB9XG4gIG5ld0N1ZShzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbikge1xuICAgIGlmICh0aGlzLnN0YXJ0VGltZSA9PT0gbnVsbCB8fCB0aGlzLnN0YXJ0VGltZSA+IHN0YXJ0VGltZSkge1xuICAgICAgdGhpcy5zdGFydFRpbWUgPSBzdGFydFRpbWU7XG4gICAgfVxuICAgIHRoaXMuZW5kVGltZSA9IGVuZFRpbWU7XG4gICAgdGhpcy5zY3JlZW4gPSBzY3JlZW47XG4gICAgdGhpcy50aW1lbGluZUNvbnRyb2xsZXIuY3JlYXRlQ2FwdGlvbnNUcmFjayh0aGlzLnRyYWNrTmFtZSk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5jdWVSYW5nZXMgPSBbXTtcbiAgICB0aGlzLnN0YXJ0VGltZSA9IG51bGw7XG4gIH1cbn1cblxuY2xhc3MgVGltZWxpbmVDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLkN1ZXMgPSB2b2lkIDA7XG4gICAgdGhpcy50ZXh0VHJhY2tzID0gW107XG4gICAgdGhpcy50cmFja3MgPSBbXTtcbiAgICB0aGlzLmluaXRQVFMgPSBbXTtcbiAgICB0aGlzLnVucGFyc2VkVnR0RnJhZ3MgPSBbXTtcbiAgICB0aGlzLmNhcHRpb25zVHJhY2tzID0ge307XG4gICAgdGhpcy5ub25OYXRpdmVDYXB0aW9uc1RyYWNrcyA9IHt9O1xuICAgIHRoaXMuY2VhNjA4UGFyc2VyMSA9IHZvaWQgMDtcbiAgICB0aGlzLmNlYTYwOFBhcnNlcjIgPSB2b2lkIDA7XG4gICAgdGhpcy5sYXN0Q2MgPSAtMTtcbiAgICAvLyBMYXN0IHZpZGVvIChDRUEtNjA4KSBmcmFnbWVudCBDQ1xuICAgIHRoaXMubGFzdFNuID0gLTE7XG4gICAgLy8gTGFzdCB2aWRlbyAoQ0VBLTYwOCkgZnJhZ21lbnQgTVNOXG4gICAgdGhpcy5sYXN0UGFydEluZGV4ID0gLTE7XG4gICAgLy8gTGFzdCB2aWRlbyAoQ0VBLTYwOCkgZnJhZ21lbnQgUGFydCBJbmRleFxuICAgIHRoaXMucHJldkNDID0gLTE7XG4gICAgLy8gTGFzdCBzdWJ0aXRsZSBmcmFnbWVudCBDQ1xuICAgIHRoaXMudnR0Q0NzID0gbmV3VlRUQ0NzKCk7XG4gICAgdGhpcy5jYXB0aW9uc1Byb3BlcnRpZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgIHRoaXMuQ3VlcyA9IGhscy5jb25maWcuY3VlSGFuZGxlcjtcbiAgICB0aGlzLmNhcHRpb25zUHJvcGVydGllcyA9IHtcbiAgICAgIHRleHRUcmFjazE6IHtcbiAgICAgICAgbGFiZWw6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMUxhYmVsLFxuICAgICAgICBsYW5ndWFnZUNvZGU6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMUxhbmd1YWdlQ29kZVxuICAgICAgfSxcbiAgICAgIHRleHRUcmFjazI6IHtcbiAgICAgICAgbGFiZWw6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMkxhYmVsLFxuICAgICAgICBsYW5ndWFnZUNvZGU6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMkxhbmd1YWdlQ29kZVxuICAgICAgfSxcbiAgICAgIHRleHRUcmFjazM6IHtcbiAgICAgICAgbGFiZWw6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrM0xhYmVsLFxuICAgICAgICBsYW5ndWFnZUNvZGU6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrM0xhbmd1YWdlQ29kZVxuICAgICAgfSxcbiAgICAgIHRleHRUcmFjazQ6IHtcbiAgICAgICAgbGFiZWw6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrNExhYmVsLFxuICAgICAgICBsYW5ndWFnZUNvZGU6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrNExhbmd1YWdlQ29kZVxuICAgICAgfVxuICAgIH07XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURFRCwgdGhpcy5vbk1hbmlmZXN0TG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLlNVQlRJVExFX1RSQUNLU19VUERBVEVELCB0aGlzLm9uU3VidGl0bGVUcmFja3NVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfTE9BRElORywgdGhpcy5vbkZyYWdMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfTE9BREVELCB0aGlzLm9uRnJhZ0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsIHRoaXMub25GcmFnUGFyc2luZ1VzZXJkYXRhLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfREVDUllQVEVELCB0aGlzLm9uRnJhZ0RlY3J5cHRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5JTklUX1BUU19GT1VORCwgdGhpcy5vbkluaXRQdHNGb3VuZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5TVUJUSVRMRV9UUkFDS1NfQ0xFQVJFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tzQ2xlYXJlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURFRCwgdGhpcy5vbk1hbmlmZXN0TG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5TVUJUSVRMRV9UUkFDS1NfVVBEQVRFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tzVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19MT0FESU5HLCB0aGlzLm9uRnJhZ0xvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfTE9BREVELCB0aGlzLm9uRnJhZ0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19QQVJTSU5HX1VTRVJEQVRBLCB0aGlzLm9uRnJhZ1BhcnNpbmdVc2VyZGF0YSwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19ERUNSWVBURUQsIHRoaXMub25GcmFnRGVjcnlwdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5JTklUX1BUU19GT1VORCwgdGhpcy5vbkluaXRQdHNGb3VuZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuU1VCVElUTEVfVFJBQ0tTX0NMRUFSRUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrc0NsZWFyZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSB0aGlzLmNvbmZpZyA9IHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMuY2VhNjA4UGFyc2VyMSA9IHRoaXMuY2VhNjA4UGFyc2VyMiA9IHVuZGVmaW5lZDtcbiAgfVxuICBpbml0Q2VhNjA4UGFyc2VycygpIHtcbiAgICBjb25zdCBjaGFubmVsMSA9IG5ldyBPdXRwdXRGaWx0ZXIodGhpcywgJ3RleHRUcmFjazEnKTtcbiAgICBjb25zdCBjaGFubmVsMiA9IG5ldyBPdXRwdXRGaWx0ZXIodGhpcywgJ3RleHRUcmFjazInKTtcbiAgICBjb25zdCBjaGFubmVsMyA9IG5ldyBPdXRwdXRGaWx0ZXIodGhpcywgJ3RleHRUcmFjazMnKTtcbiAgICBjb25zdCBjaGFubmVsNCA9IG5ldyBPdXRwdXRGaWx0ZXIodGhpcywgJ3RleHRUcmFjazQnKTtcbiAgICB0aGlzLmNlYTYwOFBhcnNlcjEgPSBuZXcgQ2VhNjA4UGFyc2VyKDEsIGNoYW5uZWwxLCBjaGFubmVsMik7XG4gICAgdGhpcy5jZWE2MDhQYXJzZXIyID0gbmV3IENlYTYwOFBhcnNlcigzLCBjaGFubmVsMywgY2hhbm5lbDQpO1xuICB9XG4gIGFkZEN1ZXModHJhY2tOYW1lLCBzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbiwgY3VlUmFuZ2VzKSB7XG4gICAgLy8gc2tpcCBjdWVzIHdoaWNoIG92ZXJsYXAgbW9yZSB0aGFuIDUwJSB3aXRoIHByZXZpb3VzbHkgcGFyc2VkIHRpbWUgcmFuZ2VzXG4gICAgbGV0IG1lcmdlZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSBjdWVSYW5nZXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICBjb25zdCBjdWVSYW5nZSA9IGN1ZVJhbmdlc1tpXTtcbiAgICAgIGNvbnN0IG92ZXJsYXAgPSBpbnRlcnNlY3Rpb24oY3VlUmFuZ2VbMF0sIGN1ZVJhbmdlWzFdLCBzdGFydFRpbWUsIGVuZFRpbWUpO1xuICAgICAgaWYgKG92ZXJsYXAgPj0gMCkge1xuICAgICAgICBjdWVSYW5nZVswXSA9IE1hdGgubWluKGN1ZVJhbmdlWzBdLCBzdGFydFRpbWUpO1xuICAgICAgICBjdWVSYW5nZVsxXSA9IE1hdGgubWF4KGN1ZVJhbmdlWzFdLCBlbmRUaW1lKTtcbiAgICAgICAgbWVyZ2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKG92ZXJsYXAgLyAoZW5kVGltZSAtIHN0YXJ0VGltZSkgPiAwLjUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFtZXJnZWQpIHtcbiAgICAgIGN1ZVJhbmdlcy5wdXNoKFtzdGFydFRpbWUsIGVuZFRpbWVdKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29uZmlnLnJlbmRlclRleHRUcmFja3NOYXRpdmVseSkge1xuICAgICAgY29uc3QgdHJhY2sgPSB0aGlzLmNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV07XG4gICAgICB0aGlzLkN1ZXMubmV3Q3VlKHRyYWNrLCBzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGN1ZXMgPSB0aGlzLkN1ZXMubmV3Q3VlKG51bGwsIHN0YXJ0VGltZSwgZW5kVGltZSwgc2NyZWVuKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkNVRVNfUEFSU0VELCB7XG4gICAgICAgIHR5cGU6ICdjYXB0aW9ucycsXG4gICAgICAgIGN1ZXMsXG4gICAgICAgIHRyYWNrOiB0cmFja05hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRyaWdnZXJlZCB3aGVuIGFuIGluaXRpYWwgUFRTIGlzIGZvdW5kOyB1c2VkIGZvciBzeW5jaHJvbmlzYXRpb24gb2YgV2ViVlRULlxuICBvbkluaXRQdHNGb3VuZChldmVudCwge1xuICAgIGZyYWcsXG4gICAgaWQsXG4gICAgaW5pdFBUUyxcbiAgICB0aW1lc2NhbGVcbiAgfSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHVucGFyc2VkVnR0RnJhZ3NcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoaWQgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pIHtcbiAgICAgIHRoaXMuaW5pdFBUU1tmcmFnLmNjXSA9IHtcbiAgICAgICAgYmFzZVRpbWU6IGluaXRQVFMsXG4gICAgICAgIHRpbWVzY2FsZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBEdWUgdG8gYXN5bmNocm9ub3VzIHByb2Nlc3NpbmcsIGluaXRpYWwgUFRTIG1heSBhcnJpdmUgbGF0ZXIgdGhhbiB0aGUgZmlyc3QgVlRUIGZyYWdtZW50cyBhcmUgbG9hZGVkLlxuICAgIC8vIFBhcnNlIGFueSB1bnBhcnNlZCBmcmFnbWVudHMgdXBvbiByZWNlaXZpbmcgdGhlIGluaXRpYWwgUFRTLlxuICAgIGlmICh1bnBhcnNlZFZ0dEZyYWdzLmxlbmd0aCkge1xuICAgICAgdGhpcy51bnBhcnNlZFZ0dEZyYWdzID0gW107XG4gICAgICB1bnBhcnNlZFZ0dEZyYWdzLmZvckVhY2goZGF0YSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmluaXRQVFNbZGF0YS5mcmFnLmNjXSkge1xuICAgICAgICAgIHRoaXMub25GcmFnTG9hZGVkKEV2ZW50cy5GUkFHX0xPQURFRCwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZnJhZzogZGF0YS5mcmFnLFxuICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcignU3VidGl0bGUgZGlzY29udGludWl0eSBkb21haW4gZG9lcyBub3QgbWF0Y2ggbWFpbicpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXRFeGlzdGluZ1RyYWNrKGxhYmVsLCBsYW5ndWFnZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lZGlhXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lZGlhLnRleHRUcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdGV4dFRyYWNrID0gbWVkaWEudGV4dFRyYWNrc1tpXTtcbiAgICAgICAgaWYgKGNhblJldXNlVnR0VGV4dFRyYWNrKHRleHRUcmFjaywge1xuICAgICAgICAgIG5hbWU6IGxhYmVsLFxuICAgICAgICAgIGxhbmc6IGxhbmd1YWdlLFxuICAgICAgICAgIGNoYXJhY3RlcmlzdGljczogJ3RyYW5zY3JpYmVzLXNwb2tlbi1kaWFsb2csZGVzY3JpYmVzLW11c2ljLWFuZC1zb3VuZCd9KSkge1xuICAgICAgICAgIHJldHVybiB0ZXh0VHJhY2s7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY3JlYXRlQ2FwdGlvbnNUcmFjayh0cmFja05hbWUpIHtcbiAgICBpZiAodGhpcy5jb25maWcucmVuZGVyVGV4dFRyYWNrc05hdGl2ZWx5KSB7XG4gICAgICB0aGlzLmNyZWF0ZU5hdGl2ZVRyYWNrKHRyYWNrTmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3JlYXRlTm9uTmF0aXZlVHJhY2sodHJhY2tOYW1lKTtcbiAgICB9XG4gIH1cbiAgY3JlYXRlTmF0aXZlVHJhY2sodHJhY2tOYW1lKSB7XG4gICAgaWYgKHRoaXMuY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjYXB0aW9uc1Byb3BlcnRpZXMsXG4gICAgICBjYXB0aW9uc1RyYWNrcyxcbiAgICAgIG1lZGlhXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgbGFiZWwsXG4gICAgICBsYW5ndWFnZUNvZGVcbiAgICB9ID0gY2FwdGlvbnNQcm9wZXJ0aWVzW3RyYWNrTmFtZV07XG4gICAgLy8gRW5hYmxlIHJldXNlIG9mIGV4aXN0aW5nIHRleHQgdHJhY2suXG4gICAgY29uc3QgZXhpc3RpbmdUcmFjayA9IHRoaXMuZ2V0RXhpc3RpbmdUcmFjayhsYWJlbCwgbGFuZ3VhZ2VDb2RlKTtcbiAgICBpZiAoIWV4aXN0aW5nVHJhY2spIHtcbiAgICAgIGNvbnN0IHRleHRUcmFjayA9IHRoaXMuY3JlYXRlVGV4dFRyYWNrKCdjYXB0aW9ucycsIGxhYmVsLCBsYW5ndWFnZUNvZGUpO1xuICAgICAgaWYgKHRleHRUcmFjaykge1xuICAgICAgICAvLyBTZXQgYSBzcGVjaWFsIHByb3BlcnR5IG9uIHRoZSB0cmFjayBzbyB3ZSBrbm93IGl0J3MgbWFuYWdlZCBieSBIbHMuanNcbiAgICAgICAgdGV4dFRyYWNrW3RyYWNrTmFtZV0gPSB0cnVlO1xuICAgICAgICBjYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdID0gdGV4dFRyYWNrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdID0gZXhpc3RpbmdUcmFjaztcbiAgICAgIGNsZWFyQ3VycmVudEN1ZXMoY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSk7XG4gICAgICBzZW5kQWRkVHJhY2tFdmVudChjYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdLCBtZWRpYSk7XG4gICAgfVxuICB9XG4gIGNyZWF0ZU5vbk5hdGl2ZVRyYWNrKHRyYWNrTmFtZSkge1xuICAgIGlmICh0aGlzLm5vbk5hdGl2ZUNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQ3JlYXRlIGEgbGlzdCBvZiBhIHNpbmdsZSB0cmFjayBmb3IgdGhlIHByb3ZpZGVyIHRvIGNvbnN1bWVcbiAgICBjb25zdCB0cmFja1Byb3BlcnRpZXMgPSB0aGlzLmNhcHRpb25zUHJvcGVydGllc1t0cmFja05hbWVdO1xuICAgIGlmICghdHJhY2tQcm9wZXJ0aWVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxhYmVsID0gdHJhY2tQcm9wZXJ0aWVzLmxhYmVsO1xuICAgIGNvbnN0IHRyYWNrID0ge1xuICAgICAgX2lkOiB0cmFja05hbWUsXG4gICAgICBsYWJlbCxcbiAgICAgIGtpbmQ6ICdjYXB0aW9ucycsXG4gICAgICBkZWZhdWx0OiB0cmFja1Byb3BlcnRpZXMubWVkaWEgPyAhIXRyYWNrUHJvcGVydGllcy5tZWRpYS5kZWZhdWx0IDogZmFsc2UsXG4gICAgICBjbG9zZWRDYXB0aW9uczogdHJhY2tQcm9wZXJ0aWVzLm1lZGlhXG4gICAgfTtcbiAgICB0aGlzLm5vbk5hdGl2ZUNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0gPSB0cmFjaztcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5OT05fTkFUSVZFX1RFWFRfVFJBQ0tTX0ZPVU5ELCB7XG4gICAgICB0cmFja3M6IFt0cmFja11cbiAgICB9KTtcbiAgfVxuICBjcmVhdGVUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmcpIHtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgaWYgKCFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gbWVkaWEuYWRkVGV4dFRyYWNrKGtpbmQsIGxhYmVsLCBsYW5nKTtcbiAgfVxuICBvbk1lZGlhQXR0YWNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgaWYgKCFkYXRhLm1lZGlhU291cmNlKSB7XG4gICAgICB0aGlzLl9jbGVhblRyYWNrcygpO1xuICAgIH1cbiAgfVxuICBvbk1lZGlhRGV0YWNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3QgdHJhbnNmZXJyaW5nTWVkaWEgPSAhIWRhdGEudHJhbnNmZXJNZWRpYTtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICBpZiAodHJhbnNmZXJyaW5nTWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY2FwdGlvbnNUcmFja3NcbiAgICB9ID0gdGhpcztcbiAgICBPYmplY3Qua2V5cyhjYXB0aW9uc1RyYWNrcykuZm9yRWFjaCh0cmFja05hbWUgPT4ge1xuICAgICAgY2xlYXJDdXJyZW50Q3VlcyhjYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdKTtcbiAgICAgIGRlbGV0ZSBjYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdO1xuICAgIH0pO1xuICAgIHRoaXMubm9uTmF0aXZlQ2FwdGlvbnNUcmFja3MgPSB7fTtcbiAgfVxuICBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICAvLyBEZXRlY3QgZGlzY29udGludWl0eSBpbiB2aWRlbyBmcmFnbWVudCAoQ0VBLTYwOCkgcGFyc2luZ1xuICAgIHRoaXMubGFzdENjID0gLTE7XG4gICAgdGhpcy5sYXN0U24gPSAtMTtcbiAgICB0aGlzLmxhc3RQYXJ0SW5kZXggPSAtMTtcbiAgICAvLyBEZXRlY3QgZGlzY29udGludWl0eSBpbiBzdWJ0aXRsZSBtYW5pZmVzdHNcbiAgICB0aGlzLnByZXZDQyA9IC0xO1xuICAgIHRoaXMudnR0Q0NzID0gbmV3VlRUQ0NzKCk7XG4gICAgLy8gUmVzZXQgdHJhY2tzXG4gICAgdGhpcy5fY2xlYW5UcmFja3MoKTtcbiAgICB0aGlzLnRyYWNrcyA9IFtdO1xuICAgIHRoaXMuY2FwdGlvbnNUcmFja3MgPSB7fTtcbiAgICB0aGlzLm5vbk5hdGl2ZUNhcHRpb25zVHJhY2tzID0ge307XG4gICAgdGhpcy50ZXh0VHJhY2tzID0gW107XG4gICAgdGhpcy51bnBhcnNlZFZ0dEZyYWdzID0gW107XG4gICAgdGhpcy5pbml0UFRTID0gW107XG4gICAgaWYgKHRoaXMuY2VhNjA4UGFyc2VyMSAmJiB0aGlzLmNlYTYwOFBhcnNlcjIpIHtcbiAgICAgIHRoaXMuY2VhNjA4UGFyc2VyMS5yZXNldCgpO1xuICAgICAgdGhpcy5jZWE2MDhQYXJzZXIyLnJlc2V0KCk7XG4gICAgfVxuICB9XG4gIF9jbGVhblRyYWNrcygpIHtcbiAgICAvLyBjbGVhciBvdXRkYXRlZCBzdWJ0aXRsZXNcbiAgICBjb25zdCB7XG4gICAgICBtZWRpYVxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghbWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGV4dFRyYWNrcyA9IG1lZGlhLnRleHRUcmFja3M7XG4gICAgaWYgKHRleHRUcmFja3MpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dFRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjbGVhckN1cnJlbnRDdWVzKHRleHRUcmFja3NbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBvblN1YnRpdGxlVHJhY2tzVXBkYXRlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHRyYWNrcyA9IGRhdGEuc3VidGl0bGVUcmFja3MgfHwgW107XG4gICAgY29uc3QgaGFzSU1TQzEgPSB0cmFja3Muc29tZSh0cmFjayA9PiB0cmFjay50ZXh0Q29kZWMgPT09IElNU0MxX0NPREVDKTtcbiAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlV2ViVlRUIHx8IGhhc0lNU0MxICYmIHRoaXMuY29uZmlnLmVuYWJsZUlNU0MxKSB7XG4gICAgICBjb25zdCBsaXN0SXNJZGVudGljYWwgPSBzdWJ0aXRsZU9wdGlvbnNJZGVudGljYWwodGhpcy50cmFja3MsIHRyYWNrcyk7XG4gICAgICBpZiAobGlzdElzSWRlbnRpY2FsKSB7XG4gICAgICAgIHRoaXMudHJhY2tzID0gdHJhY2tzO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnRleHRUcmFja3MgPSBbXTtcbiAgICAgIHRoaXMudHJhY2tzID0gdHJhY2tzO1xuICAgICAgaWYgKHRoaXMuY29uZmlnLnJlbmRlclRleHRUcmFja3NOYXRpdmVseSkge1xuICAgICAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICAgIGNvbnN0IGluVXNlVHJhY2tzID0gbWVkaWEgPyBmaWx0ZXJTdWJ0aXRsZVRyYWNrcyhtZWRpYS50ZXh0VHJhY2tzKSA6IG51bGw7XG4gICAgICAgIHRoaXMudHJhY2tzLmZvckVhY2goKHRyYWNrLCBpbmRleCkgPT4ge1xuICAgICAgICAgIC8vIFJldXNlIHRyYWNrcyB3aXRoIHRoZSBzYW1lIGxhYmVsIGFuZCBsYW5nLCBidXQgZG8gbm90IHJldXNlIDYwOC83MDggdHJhY2tzXG4gICAgICAgICAgbGV0IHRleHRUcmFjaztcbiAgICAgICAgICBpZiAoaW5Vc2VUcmFja3MpIHtcbiAgICAgICAgICAgIGxldCBpblVzZVRyYWNrID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5Vc2VUcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKGluVXNlVHJhY2tzW2ldICYmIGNhblJldXNlVnR0VGV4dFRyYWNrKGluVXNlVHJhY2tzW2ldLCB0cmFjaykpIHtcbiAgICAgICAgICAgICAgICBpblVzZVRyYWNrID0gaW5Vc2VUcmFja3NbaV07XG4gICAgICAgICAgICAgICAgaW5Vc2VUcmFja3NbaV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5Vc2VUcmFjaykge1xuICAgICAgICAgICAgICB0ZXh0VHJhY2sgPSBpblVzZVRyYWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGV4dFRyYWNrKSB7XG4gICAgICAgICAgICBjbGVhckN1cnJlbnRDdWVzKHRleHRUcmFjayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHRUcmFja0tpbmQgPSBjYXB0aW9uc09yU3VidGl0bGVzRnJvbUNoYXJhY3RlcmlzdGljcyh0cmFjayk7XG4gICAgICAgICAgICB0ZXh0VHJhY2sgPSB0aGlzLmNyZWF0ZVRleHRUcmFjayh0ZXh0VHJhY2tLaW5kLCB0cmFjay5uYW1lLCB0cmFjay5sYW5nKTtcbiAgICAgICAgICAgIGlmICh0ZXh0VHJhY2spIHtcbiAgICAgICAgICAgICAgdGV4dFRyYWNrLm1vZGUgPSAnZGlzYWJsZWQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGV4dFRyYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnRleHRUcmFja3MucHVzaCh0ZXh0VHJhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFdhcm4gd2hlbiB2aWRlbyBlbGVtZW50IGhhcyBjYXB0aW9ucyBvciBzdWJ0aXRsZSBUZXh0VHJhY2tzIGNhcnJpZWQgb3ZlciBmcm9tIGFub3RoZXIgc291cmNlXG4gICAgICAgIGlmIChpblVzZVRyYWNrcyAhPSBudWxsICYmIGluVXNlVHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IHVudXNlZFRleHRUcmFja3MgPSBpblVzZVRyYWNrcy5maWx0ZXIodCA9PiB0ICE9PSBudWxsKS5tYXAodCA9PiB0LmxhYmVsKTtcbiAgICAgICAgICBpZiAodW51c2VkVGV4dFRyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuaGxzLmxvZ2dlci53YXJuKGBNZWRpYSBlbGVtZW50IGNvbnRhaW5zIHVudXNlZCBzdWJ0aXRsZSB0cmFja3M6ICR7dW51c2VkVGV4dFRyYWNrcy5qb2luKCcsICcpfS4gUmVwbGFjZSBtZWRpYSBlbGVtZW50IGZvciBlYWNoIHNvdXJjZSB0byBjbGVhciBUZXh0VHJhY2tzIGFuZCBjYXB0aW9ucyBtZW51LmApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLnRyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbGlzdCBvZiB0cmFja3MgZm9yIHRoZSBwcm92aWRlciB0byBjb25zdW1lXG4gICAgICAgIGNvbnN0IHRyYWNrc0xpc3QgPSB0aGlzLnRyYWNrcy5tYXAodHJhY2sgPT4ge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYWJlbDogdHJhY2submFtZSxcbiAgICAgICAgICAgIGtpbmQ6IHRyYWNrLnR5cGUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRyYWNrLmRlZmF1bHQsXG4gICAgICAgICAgICBzdWJ0aXRsZVRyYWNrOiB0cmFja1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5OT05fTkFUSVZFX1RFWFRfVFJBQ0tTX0ZPVU5ELCB7XG4gICAgICAgICAgdHJhY2tzOiB0cmFja3NMaXN0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBvbk1hbmlmZXN0TG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKHRoaXMuY29uZmlnLmVuYWJsZUNFQTcwOENhcHRpb25zICYmIGRhdGEuY2FwdGlvbnMpIHtcbiAgICAgIGRhdGEuY2FwdGlvbnMuZm9yRWFjaChjYXB0aW9uc1RyYWNrID0+IHtcbiAgICAgICAgY29uc3QgaW5zdHJlYW1JZE1hdGNoID0gLyg/OkNDfFNFUlZJQ0UpKFsxLTRdKS8uZXhlYyhjYXB0aW9uc1RyYWNrLmluc3RyZWFtSWQpO1xuICAgICAgICBpZiAoIWluc3RyZWFtSWRNYXRjaCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFja05hbWUgPSBgdGV4dFRyYWNrJHtpbnN0cmVhbUlkTWF0Y2hbMV19YDtcbiAgICAgICAgY29uc3QgdHJhY2tQcm9wZXJ0aWVzID0gdGhpcy5jYXB0aW9uc1Byb3BlcnRpZXNbdHJhY2tOYW1lXTtcbiAgICAgICAgaWYgKCF0cmFja1Byb3BlcnRpZXMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2tQcm9wZXJ0aWVzLmxhYmVsID0gY2FwdGlvbnNUcmFjay5uYW1lO1xuICAgICAgICBpZiAoY2FwdGlvbnNUcmFjay5sYW5nKSB7XG4gICAgICAgICAgLy8gb3B0aW9uYWwgYXR0cmlidXRlXG4gICAgICAgICAgdHJhY2tQcm9wZXJ0aWVzLmxhbmd1YWdlQ29kZSA9IGNhcHRpb25zVHJhY2subGFuZztcbiAgICAgICAgfVxuICAgICAgICB0cmFja1Byb3BlcnRpZXMubWVkaWEgPSBjYXB0aW9uc1RyYWNrO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGNsb3NlZENhcHRpb25zRm9yTGV2ZWwoZnJhZykge1xuICAgIGNvbnN0IGxldmVsID0gdGhpcy5obHMubGV2ZWxzW2ZyYWcubGV2ZWxdO1xuICAgIHJldHVybiBsZXZlbCA9PSBudWxsID8gdm9pZCAwIDogbGV2ZWwuYXR0cnNbJ0NMT1NFRC1DQVBUSU9OUyddO1xuICB9XG4gIG9uRnJhZ0xvYWRpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICAvLyBpZiB0aGlzIGZyYWcgaXNuJ3QgY29udGlndW91cywgY2xlYXIgdGhlIHBhcnNlciBzbyBjdWVzIHdpdGggYmFkIHN0YXJ0L2VuZCB0aW1lcyBhcmVuJ3QgYWRkZWQgdG8gdGhlIHRleHRUcmFja1xuICAgIGlmICh0aGlzLmVuYWJsZWQgJiYgZGF0YS5mcmFnLnR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pIHtcbiAgICAgIHZhciBfZGF0YSRwYXJ0JGluZGV4LCBfZGF0YSRwYXJ0O1xuICAgICAgY29uc3Qge1xuICAgICAgICBjZWE2MDhQYXJzZXIxLFxuICAgICAgICBjZWE2MDhQYXJzZXIyLFxuICAgICAgICBsYXN0U25cbiAgICAgIH0gPSB0aGlzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjYyxcbiAgICAgICAgc25cbiAgICAgIH0gPSBkYXRhLmZyYWc7XG4gICAgICBjb25zdCBwYXJ0SW5kZXggPSAoX2RhdGEkcGFydCRpbmRleCA9IChfZGF0YSRwYXJ0ID0gZGF0YS5wYXJ0KSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGEkcGFydC5pbmRleCkgIT0gbnVsbCA/IF9kYXRhJHBhcnQkaW5kZXggOiAtMTtcbiAgICAgIGlmIChjZWE2MDhQYXJzZXIxICYmIGNlYTYwOFBhcnNlcjIpIHtcbiAgICAgICAgaWYgKHNuICE9PSBsYXN0U24gKyAxIHx8IHNuID09PSBsYXN0U24gJiYgcGFydEluZGV4ICE9PSB0aGlzLmxhc3RQYXJ0SW5kZXggKyAxIHx8IGNjICE9PSB0aGlzLmxhc3RDYykge1xuICAgICAgICAgIGNlYTYwOFBhcnNlcjEucmVzZXQoKTtcbiAgICAgICAgICBjZWE2MDhQYXJzZXIyLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdENjID0gY2M7XG4gICAgICB0aGlzLmxhc3RTbiA9IHNuO1xuICAgICAgdGhpcy5sYXN0UGFydEluZGV4ID0gcGFydEluZGV4O1xuICAgIH1cbiAgfVxuICBvbkZyYWdMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnLFxuICAgICAgcGF5bG9hZFxuICAgIH0gPSBkYXRhO1xuICAgIGlmIChmcmFnLnR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLlNVQlRJVExFKSB7XG4gICAgICAvLyBJZiBmcmFnbWVudCBpcyBzdWJ0aXRsZSB0eXBlLCBwYXJzZSBhcyBXZWJWVFQuXG4gICAgICBpZiAocGF5bG9hZC5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGRlY3J5cHREYXRhID0gZnJhZy5kZWNyeXB0ZGF0YTtcbiAgICAgICAgLy8gZnJhZ21lbnQgYWZ0ZXIgZGVjcnlwdGlvbiBoYXMgYSBzdGF0cyBvYmplY3RcbiAgICAgICAgY29uc3QgZGVjcnlwdGVkID0gJ3N0YXRzJyBpbiBkYXRhO1xuICAgICAgICAvLyBJZiB0aGUgc3VidGl0bGVzIGFyZSBub3QgZW5jcnlwdGVkLCBwYXJzZSBWVFRzIG5vdy4gT3RoZXJ3aXNlLCB3ZSBuZWVkIHRvIHdhaXQuXG4gICAgICAgIGlmIChkZWNyeXB0RGF0YSA9PSBudWxsIHx8ICFkZWNyeXB0RGF0YS5lbmNyeXB0ZWQgfHwgZGVjcnlwdGVkKSB7XG4gICAgICAgICAgY29uc3QgdHJhY2tQbGF5bGlzdE1lZGlhID0gdGhpcy50cmFja3NbZnJhZy5sZXZlbF07XG4gICAgICAgICAgY29uc3QgdnR0Q0NzID0gdGhpcy52dHRDQ3M7XG4gICAgICAgICAgaWYgKCF2dHRDQ3NbZnJhZy5jY10pIHtcbiAgICAgICAgICAgIHZ0dENDc1tmcmFnLmNjXSA9IHtcbiAgICAgICAgICAgICAgc3RhcnQ6IGZyYWcuc3RhcnQsXG4gICAgICAgICAgICAgIHByZXZDQzogdGhpcy5wcmV2Q0MsXG4gICAgICAgICAgICAgIG5ldzogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucHJldkNDID0gZnJhZy5jYztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRyYWNrUGxheWxpc3RNZWRpYSAmJiB0cmFja1BsYXlsaXN0TWVkaWEudGV4dENvZGVjID09PSBJTVNDMV9DT0RFQykge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VJTVNDMShmcmFnLCBwYXlsb2FkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VWVFRzKGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSW4gY2FzZSB0aGVyZSBpcyBubyBwYXlsb2FkLCBmaW5pc2ggdW5zdWNjZXNzZnVsbHkuXG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZnJhZyxcbiAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKCdFbXB0eSBzdWJ0aXRsZSBwYXlsb2FkJylcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9wYXJzZUlNU0MxKGZyYWcsIHBheWxvYWQpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBwYXJzZUlNU0MxKHBheWxvYWQsIHRoaXMuaW5pdFBUU1tmcmFnLmNjXSwgY3VlcyA9PiB7XG4gICAgICB0aGlzLl9hcHBlbmRDdWVzKGN1ZXMsIGZyYWcubGV2ZWwpO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGZyYWc6IGZyYWdcbiAgICAgIH0pO1xuICAgIH0sIGVycm9yID0+IHtcbiAgICAgIGhscy5sb2dnZXIubG9nKGBGYWlsZWQgdG8gcGFyc2UgSU1TQzE6ICR7ZXJyb3J9YCk7XG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgIGVycm9yXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfcGFyc2VWVFRzKGRhdGEpIHtcbiAgICB2YXIgX2ZyYWckaW5pdFNlZ21lbnQ7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIHBheWxvYWRcbiAgICB9ID0gZGF0YTtcbiAgICAvLyBXZSBuZWVkIGFuIGluaXRpYWwgc3luY2hyb25pc2F0aW9uIFBUUy4gU3RvcmUgZnJhZ21lbnRzIGFzIGxvbmcgYXMgbm9uZSBoYXMgYXJyaXZlZFxuICAgIGNvbnN0IHtcbiAgICAgIGluaXRQVFMsXG4gICAgICB1bnBhcnNlZFZ0dEZyYWdzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgbWF4QXZDQyA9IGluaXRQVFMubGVuZ3RoIC0gMTtcbiAgICBpZiAoIWluaXRQVFNbZnJhZy5jY10gJiYgbWF4QXZDQyA9PT0gLTEpIHtcbiAgICAgIHVucGFyc2VkVnR0RnJhZ3MucHVzaChkYXRhKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgLy8gUGFyc2UgdGhlIFdlYlZUVCBmaWxlIGNvbnRlbnRzLlxuICAgIGNvbnN0IHBheWxvYWRXZWJWVFQgPSAoX2ZyYWckaW5pdFNlZ21lbnQgPSBmcmFnLmluaXRTZWdtZW50KSAhPSBudWxsICYmIF9mcmFnJGluaXRTZWdtZW50LmRhdGEgPyBhcHBlbmRVaW50OEFycmF5KGZyYWcuaW5pdFNlZ21lbnQuZGF0YSwgbmV3IFVpbnQ4QXJyYXkocGF5bG9hZCkpLmJ1ZmZlciA6IHBheWxvYWQ7XG4gICAgcGFyc2VXZWJWVFQocGF5bG9hZFdlYlZUVCwgdGhpcy5pbml0UFRTW2ZyYWcuY2NdLCB0aGlzLnZ0dENDcywgZnJhZy5jYywgZnJhZy5zdGFydCwgY3VlcyA9PiB7XG4gICAgICB0aGlzLl9hcHBlbmRDdWVzKGN1ZXMsIGZyYWcubGV2ZWwpO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGZyYWc6IGZyYWdcbiAgICAgIH0pO1xuICAgIH0sIGVycm9yID0+IHtcbiAgICAgIGNvbnN0IG1pc3NpbmdJbml0UFRTID0gZXJyb3IubWVzc2FnZSA9PT0gJ01pc3NpbmcgaW5pdFBUUyBmb3IgVlRUIE1QRUdUUyc7XG4gICAgICBpZiAobWlzc2luZ0luaXRQVFMpIHtcbiAgICAgICAgdW5wYXJzZWRWdHRGcmFncy5wdXNoKGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZmFsbGJhY2tUb0lNU0MxKGZyYWcsIHBheWxvYWQpO1xuICAgICAgfVxuICAgICAgLy8gU29tZXRoaW5nIHdlbnQgd3Jvbmcgd2hpbGUgcGFyc2luZy4gVHJpZ2dlciBldmVudCB3aXRoIHN1Y2Nlc3MgZmFsc2UuXG4gICAgICBobHMubG9nZ2VyLmxvZyhgRmFpbGVkIHRvIHBhcnNlIFZUVCBjdWU6ICR7ZXJyb3J9YCk7XG4gICAgICBpZiAobWlzc2luZ0luaXRQVFMgJiYgbWF4QXZDQyA+IGZyYWcuY2MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICBlcnJvclxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX2ZhbGxiYWNrVG9JTVNDMShmcmFnLCBwYXlsb2FkKSB7XG4gICAgLy8gSWYgdGV4dENvZGVjIGlzIHVua25vd24sIHRyeSBwYXJzaW5nIGFzIElNU0MxLiBTZXQgdGV4dENvZGVjIGJhc2VkIG9uIHRoZSByZXN1bHRcbiAgICBjb25zdCB0cmFja1BsYXlsaXN0TWVkaWEgPSB0aGlzLnRyYWNrc1tmcmFnLmxldmVsXTtcbiAgICBpZiAoIXRyYWNrUGxheWxpc3RNZWRpYS50ZXh0Q29kZWMpIHtcbiAgICAgIHBhcnNlSU1TQzEocGF5bG9hZCwgdGhpcy5pbml0UFRTW2ZyYWcuY2NdLCAoKSA9PiB7XG4gICAgICAgIHRyYWNrUGxheWxpc3RNZWRpYS50ZXh0Q29kZWMgPSBJTVNDMV9DT0RFQztcbiAgICAgICAgdGhpcy5fcGFyc2VJTVNDMShmcmFnLCBwYXlsb2FkKTtcbiAgICAgIH0sICgpID0+IHtcbiAgICAgICAgdHJhY2tQbGF5bGlzdE1lZGlhLnRleHRDb2RlYyA9ICd3dnR0JztcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBfYXBwZW5kQ3VlcyhjdWVzLCBmcmFnTGV2ZWwpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBpZiAodGhpcy5jb25maWcucmVuZGVyVGV4dFRyYWNrc05hdGl2ZWx5KSB7XG4gICAgICBjb25zdCB0ZXh0VHJhY2sgPSB0aGlzLnRleHRUcmFja3NbZnJhZ0xldmVsXTtcbiAgICAgIC8vIFdlYlZUVFBhcnNlci5wYXJzZSBpcyBhbiBhc3luYyBtZXRob2QgYW5kIGlmIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdGV4dCB0cmFjayBtb2RlIGlzIHNldCB0byBcImRpc2FibGVkXCJcbiAgICAgIC8vIGJlZm9yZSBwYXJzaW5nIGlzIGRvbmUgdGhlbiBkb24ndCB0cnkgdG8gYWNjZXNzIGN1cnJlbnRUcmFjay5jdWVzLmdldEN1ZUJ5SWQgYXMgY3VlcyB3aWxsIGJlIG51bGxcbiAgICAgIC8vIGFuZCB0cnlpbmcgdG8gYWNjZXNzIGdldEN1ZUJ5SWQgbWV0aG9kIG9mIGN1ZXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb25cbiAgICAgIC8vIEJlY2F1c2Ugd2UgY2hlY2sgaWYgdGhlIG1vZGUgaXMgZGlzYWJsZWQsIHdlIGNhbiBmb3JjZSBjaGVjayBgY3Vlc2AgYmVsb3cuIFRoZXkgY2FuJ3QgYmUgbnVsbC5cbiAgICAgIGlmICghdGV4dFRyYWNrIHx8IHRleHRUcmFjay5tb2RlID09PSAnZGlzYWJsZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN1ZXMuZm9yRWFjaChjdWUgPT4gYWRkQ3VlVG9UcmFjayh0ZXh0VHJhY2ssIGN1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjdXJyZW50VHJhY2sgPSB0aGlzLnRyYWNrc1tmcmFnTGV2ZWxdO1xuICAgICAgaWYgKCFjdXJyZW50VHJhY2spIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdHJhY2sgPSBjdXJyZW50VHJhY2suZGVmYXVsdCA/ICdkZWZhdWx0JyA6ICdzdWJ0aXRsZXMnICsgZnJhZ0xldmVsO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkNVRVNfUEFSU0VELCB7XG4gICAgICAgIHR5cGU6ICdzdWJ0aXRsZXMnLFxuICAgICAgICBjdWVzLFxuICAgICAgICB0cmFja1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIG9uRnJhZ0RlY3J5cHRlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWdcbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoZnJhZy50eXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5TVUJUSVRMRSkge1xuICAgICAgdGhpcy5vbkZyYWdMb2FkZWQoRXZlbnRzLkZSQUdfTE9BREVELCBkYXRhKTtcbiAgICB9XG4gIH1cbiAgb25TdWJ0aXRsZVRyYWNrc0NsZWFyZWQoKSB7XG4gICAgdGhpcy50cmFja3MgPSBbXTtcbiAgICB0aGlzLmNhcHRpb25zVHJhY2tzID0ge307XG4gIH1cbiAgb25GcmFnUGFyc2luZ1VzZXJkYXRhKGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQgfHwgIXRoaXMuY29uZmlnLmVuYWJsZUNFQTcwOENhcHRpb25zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGZyYWcsXG4gICAgICBzYW1wbGVzXG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKGZyYWcudHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTiAmJiB0aGlzLmNsb3NlZENhcHRpb25zRm9yTGV2ZWwoZnJhZykgPT09ICdOT05FJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgZXZlbnQgY29udGFpbnMgY2FwdGlvbnMgKGZvdW5kIGluIHRoZSBieXRlcyBwcm9wZXJ0eSksIHB1c2ggYWxsIGJ5dGVzIGludG8gdGhlIHBhcnNlciBpbW1lZGlhdGVseVxuICAgIC8vIEl0IHdpbGwgY3JlYXRlIHRoZSBwcm9wZXIgdGltZXN0YW1wcyBiYXNlZCBvbiB0aGUgUFRTIHZhbHVlXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjY0J5dGVzID0gc2FtcGxlc1tpXS5ieXRlcztcbiAgICAgIGlmIChjY0J5dGVzKSB7XG4gICAgICAgIGlmICghdGhpcy5jZWE2MDhQYXJzZXIxKSB7XG4gICAgICAgICAgdGhpcy5pbml0Q2VhNjA4UGFyc2VycygpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNjZGF0YXMgPSB0aGlzLmV4dHJhY3RDZWE2MDhEYXRhKGNjQnl0ZXMpO1xuICAgICAgICB0aGlzLmNlYTYwOFBhcnNlcjEuYWRkRGF0YShzYW1wbGVzW2ldLnB0cywgY2NkYXRhc1swXSk7XG4gICAgICAgIHRoaXMuY2VhNjA4UGFyc2VyMi5hZGREYXRhKHNhbXBsZXNbaV0ucHRzLCBjY2RhdGFzWzFdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgb25CdWZmZXJGbHVzaGluZyhldmVudCwge1xuICAgIHN0YXJ0T2Zmc2V0LFxuICAgIGVuZE9mZnNldCxcbiAgICBlbmRPZmZzZXRTdWJ0aXRsZXMsXG4gICAgdHlwZVxuICB9KSB7XG4gICAgY29uc3Qge1xuICAgICAgbWVkaWFcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIW1lZGlhIHx8IG1lZGlhLmN1cnJlbnRUaW1lIDwgZW5kT2Zmc2V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIENsZWFyIDYwOCBjYXB0aW9uIGN1ZXMgZnJvbSB0aGUgY2FwdGlvbnMgVGV4dFRyYWNrcyB3aGVuIHRoZSB2aWRlbyBiYWNrIGJ1ZmZlciBpcyBmbHVzaGVkXG4gICAgLy8gRm9yd2FyZCBjdWVzIGFyZSBuZXZlciByZW1vdmVkIGJlY2F1c2Ugd2UgY2FuIGxvb3NlIHN0cmVhbWVkIDYwOCBjb250ZW50IGZyb20gcmVjZW50IGZyYWdtZW50c1xuICAgIGlmICghdHlwZSB8fCB0eXBlID09PSAndmlkZW8nKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNhcHRpb25zVHJhY2tzXG4gICAgICB9ID0gdGhpcztcbiAgICAgIE9iamVjdC5rZXlzKGNhcHRpb25zVHJhY2tzKS5mb3JFYWNoKHRyYWNrTmFtZSA9PiByZW1vdmVDdWVzSW5SYW5nZShjYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdLCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0KSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbmZpZy5yZW5kZXJUZXh0VHJhY2tzTmF0aXZlbHkpIHtcbiAgICAgIC8vIENsZWFyIFZUVC9JTVNDMSBzdWJ0aXRsZSBjdWVzIGZyb20gdGhlIHN1YnRpdGxlIFRleHRUcmFja3Mgd2hlbiB0aGUgYmFjayBidWZmZXIgaXMgZmx1c2hlZFxuICAgICAgaWYgKHN0YXJ0T2Zmc2V0ID09PSAwICYmIGVuZE9mZnNldFN1YnRpdGxlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB0ZXh0VHJhY2tzXG4gICAgICAgIH0gPSB0aGlzO1xuICAgICAgICBPYmplY3Qua2V5cyh0ZXh0VHJhY2tzKS5mb3JFYWNoKHRyYWNrTmFtZSA9PiByZW1vdmVDdWVzSW5SYW5nZSh0ZXh0VHJhY2tzW3RyYWNrTmFtZV0sIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXRTdWJ0aXRsZXMpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZXh0cmFjdENlYTYwOERhdGEoYnl0ZUFycmF5KSB7XG4gICAgY29uc3QgYWN0dWFsQ0NCeXRlcyA9IFtbXSwgW11dO1xuICAgIGNvbnN0IGNvdW50ID0gYnl0ZUFycmF5WzBdICYgMHgxZjtcbiAgICBsZXQgcG9zaXRpb24gPSAyO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgY291bnQ7IGorKykge1xuICAgICAgY29uc3QgdG1wQnl0ZSA9IGJ5dGVBcnJheVtwb3NpdGlvbisrXTtcbiAgICAgIGNvbnN0IGNjYnl0ZTEgPSAweDdmICYgYnl0ZUFycmF5W3Bvc2l0aW9uKytdO1xuICAgICAgY29uc3QgY2NieXRlMiA9IDB4N2YgJiBieXRlQXJyYXlbcG9zaXRpb24rK107XG4gICAgICBpZiAoY2NieXRlMSA9PT0gMCAmJiBjY2J5dGUyID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgY2NWYWxpZCA9ICgweDA0ICYgdG1wQnl0ZSkgIT09IDA7IC8vIFN1cHBvcnQgYWxsIGZvdXIgY2hhbm5lbHNcbiAgICAgIGlmIChjY1ZhbGlkKSB7XG4gICAgICAgIGNvbnN0IGNjVHlwZSA9IDB4MDMgJiB0bXBCeXRlO1xuICAgICAgICBpZiAoMHgwMCAvKiBDRUE2MDggZmllbGQxKi8gPT09IGNjVHlwZSB8fCAweDAxIC8qIENFQTYwOCBmaWVsZDIqLyA9PT0gY2NUeXBlKSB7XG4gICAgICAgICAgLy8gRXhjbHVkZSBDRUE3MDggQ0MgZGF0YS5cbiAgICAgICAgICBhY3R1YWxDQ0J5dGVzW2NjVHlwZV0ucHVzaChjY2J5dGUxKTtcbiAgICAgICAgICBhY3R1YWxDQ0J5dGVzW2NjVHlwZV0ucHVzaChjY2J5dGUyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWN0dWFsQ0NCeXRlcztcbiAgfVxufVxuZnVuY3Rpb24gY2FwdGlvbnNPclN1YnRpdGxlc0Zyb21DaGFyYWN0ZXJpc3RpY3ModHJhY2spIHtcbiAgaWYgKHRyYWNrLmNoYXJhY3RlcmlzdGljcykge1xuICAgIGlmICgvdHJhbnNjcmliZXMtc3Bva2VuLWRpYWxvZy9naS50ZXN0KHRyYWNrLmNoYXJhY3RlcmlzdGljcykgJiYgL2Rlc2NyaWJlcy1tdXNpYy1hbmQtc291bmQvZ2kudGVzdCh0cmFjay5jaGFyYWN0ZXJpc3RpY3MpKSB7XG4gICAgICByZXR1cm4gJ2NhcHRpb25zJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICdzdWJ0aXRsZXMnO1xufVxuZnVuY3Rpb24gY2FuUmV1c2VWdHRUZXh0VHJhY2soaW5Vc2VUcmFjaywgbWFuaWZlc3RUcmFjaykge1xuICByZXR1cm4gISFpblVzZVRyYWNrICYmIGluVXNlVHJhY2sua2luZCA9PT0gY2FwdGlvbnNPclN1YnRpdGxlc0Zyb21DaGFyYWN0ZXJpc3RpY3MobWFuaWZlc3RUcmFjaykgJiYgc3VidGl0bGVUcmFja01hdGNoZXNUZXh0VHJhY2sobWFuaWZlc3RUcmFjaywgaW5Vc2VUcmFjayk7XG59XG5mdW5jdGlvbiBpbnRlcnNlY3Rpb24oeDEsIHgyLCB5MSwgeTIpIHtcbiAgcmV0dXJuIE1hdGgubWluKHgyLCB5MikgLSBNYXRoLm1heCh4MSwgeTEpO1xufVxuZnVuY3Rpb24gbmV3VlRUQ0NzKCkge1xuICByZXR1cm4ge1xuICAgIGNjT2Zmc2V0OiAwLFxuICAgIHByZXNlbnRhdGlvbk9mZnNldDogMCxcbiAgICAwOiB7XG4gICAgICBzdGFydDogMCxcbiAgICAgIHByZXZDQzogLTEsXG4gICAgICBuZXc6IHRydWVcbiAgICB9XG4gIH07XG59XG5cbmNvbnN0IFdISVRFU1BBQ0VfQ0hBUiA9IC9cXHMvO1xuY29uc3QgQ3VlcyA9IHtcbiAgbmV3Q3VlKHRyYWNrLCBzdGFydFRpbWUsIGVuZFRpbWUsIGNhcHRpb25TY3JlZW4pIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgcm93O1xuICAgIC8vIHRoZSB0eXBlIGRhdGEgc3RhdGVzIHRoaXMgaXMgVlRUQ3VlLCBidXQgaXQgY2FuIHBvdGVudGlhbGx5IGJlIGEgVGV4dFRyYWNrQ3VlIG9uIG9sZCBicm93c2Vyc1xuICAgIGxldCBjdWU7XG4gICAgbGV0IGluZGVudGluZztcbiAgICBsZXQgaW5kZW50O1xuICAgIGxldCB0ZXh0O1xuICAgIGNvbnN0IEN1ZSA9IHNlbGYuVlRUQ3VlIHx8IHNlbGYuVGV4dFRyYWNrQ3VlO1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgY2FwdGlvblNjcmVlbi5yb3dzLmxlbmd0aDsgcisrKSB7XG4gICAgICByb3cgPSBjYXB0aW9uU2NyZWVuLnJvd3Nbcl07XG4gICAgICBpbmRlbnRpbmcgPSB0cnVlO1xuICAgICAgaW5kZW50ID0gMDtcbiAgICAgIHRleHQgPSAnJztcbiAgICAgIGlmICghcm93LmlzRW1wdHkoKSkge1xuICAgICAgICB2YXIgX3RyYWNrJGN1ZXM7XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgcm93LmNoYXJzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgaWYgKFdISVRFU1BBQ0VfQ0hBUi50ZXN0KHJvdy5jaGFyc1tjXS51Y2hhcikgJiYgaW5kZW50aW5nKSB7XG4gICAgICAgICAgICBpbmRlbnQrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dCArPSByb3cuY2hhcnNbY10udWNoYXI7XG4gICAgICAgICAgICBpbmRlbnRpbmcgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVG8gYmUgdXNlZCBmb3IgY2xlYW5pbmctdXAgb3JwaGFuZWQgcm9sbC11cCBjYXB0aW9uc1xuICAgICAgICByb3cuY3VlU3RhcnRUaW1lID0gc3RhcnRUaW1lO1xuXG4gICAgICAgIC8vIEdpdmUgYSBzbGlnaHQgYnVtcCB0byB0aGUgZW5kVGltZSBpZiBpdCdzIGVxdWFsIHRvIHN0YXJ0VGltZSB0byBhdm9pZCBhIFN5bnRheEVycm9yIGluIElFXG4gICAgICAgIGlmIChzdGFydFRpbWUgPT09IGVuZFRpbWUpIHtcbiAgICAgICAgICBlbmRUaW1lICs9IDAuMDAwMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZW50ID49IDE2KSB7XG4gICAgICAgICAgaW5kZW50LS07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5kZW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VlVGV4dCA9IGZpeExpbmVCcmVha3ModGV4dC50cmltKCkpO1xuICAgICAgICBjb25zdCBpZCA9IGdlbmVyYXRlQ3VlSWQoc3RhcnRUaW1lLCBlbmRUaW1lLCBjdWVUZXh0KTtcblxuICAgICAgICAvLyBJZiB0aGlzIGN1ZSBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgdHJhY2sgZG8gbm90IHB1c2ggaXRcbiAgICAgICAgaWYgKCEodHJhY2sgIT0gbnVsbCAmJiAoX3RyYWNrJGN1ZXMgPSB0cmFjay5jdWVzKSAhPSBudWxsICYmIF90cmFjayRjdWVzLmdldEN1ZUJ5SWQoaWQpKSkge1xuICAgICAgICAgIGN1ZSA9IG5ldyBDdWUoc3RhcnRUaW1lLCBlbmRUaW1lLCBjdWVUZXh0KTtcbiAgICAgICAgICBjdWUuaWQgPSBpZDtcbiAgICAgICAgICBjdWUubGluZSA9IHIgKyAxO1xuICAgICAgICAgIGN1ZS5hbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICAvLyBDbGFtcCB0aGUgcG9zaXRpb24gYmV0d2VlbiAxMCBhbmQgODAgcGVyY2VudCAoQ0VBLTYwOCBQQUMgaW5kZW50IGNvZGUpXG4gICAgICAgICAgLy8gaHR0cHM6Ly9kdmNzLnczLm9yZy9oZy90ZXh0LXRyYWNrcy9yYXctZmlsZS9kZWZhdWx0LzYwOHRvVlRULzYwOHRvVlRULmh0bWwjcG9zaXRpb25pbmctaW4tY2VhLTYwOFxuICAgICAgICAgIC8vIEZpcmVmb3ggdGhyb3dzIGFuIGV4Y2VwdGlvbiBhbmQgY2FwdGlvbnMgYnJlYWsgd2l0aCBvdXQgb2YgYm91bmRzIDAtMTAwIHZhbHVlc1xuICAgICAgICAgIGN1ZS5wb3NpdGlvbiA9IDEwICsgTWF0aC5taW4oODAsIE1hdGguZmxvb3IoaW5kZW50ICogOCAvIDMyKSAqIDEwKTtcbiAgICAgICAgICByZXN1bHQucHVzaChjdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0cmFjayAmJiByZXN1bHQubGVuZ3RoKSB7XG4gICAgICAvLyBTb3J0IGJvdHRvbSBjdWVzIGluIHJldmVyc2Ugb3JkZXIgc28gdGhhdCB0aGV5IHJlbmRlciBpbiBsaW5lIG9yZGVyIHdoZW4gb3ZlcmxhcHBpbmcgaW4gQ2hyb21lXG4gICAgICByZXN1bHQuc29ydCgoY3VlQSwgY3VlQikgPT4ge1xuICAgICAgICBpZiAoY3VlQS5saW5lID09PSAnYXV0bycgfHwgY3VlQi5saW5lID09PSAnYXV0bycpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VlQS5saW5lID4gOCAmJiBjdWVCLmxpbmUgPiA4KSB7XG4gICAgICAgICAgcmV0dXJuIGN1ZUIubGluZSAtIGN1ZUEubGluZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VlQS5saW5lIC0gY3VlQi5saW5lO1xuICAgICAgfSk7XG4gICAgICByZXN1bHQuZm9yRWFjaChjdWUgPT4gYWRkQ3VlVG9UcmFjayh0cmFjaywgY3VlKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGZldGNoU3VwcG9ydGVkKCkge1xuICBpZiAoXG4gIC8vIEB0cy1pZ25vcmVcbiAgc2VsZi5mZXRjaCAmJiBzZWxmLkFib3J0Q29udHJvbGxlciAmJiBzZWxmLlJlYWRhYmxlU3RyZWFtICYmIHNlbGYuUmVxdWVzdCkge1xuICAgIHRyeSB7XG4gICAgICBuZXcgc2VsZi5SZWFkYWJsZVN0cmVhbSh7fSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvKiBub29wICovXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmNvbnN0IEJZVEVSQU5HRSA9IC8oXFxkKyktKFxcZCspXFwvKFxcZCspLztcbmNsYXNzIEZldGNoTG9hZGVyIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5mZXRjaFNldHVwID0gdm9pZCAwO1xuICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSB2b2lkIDA7XG4gICAgdGhpcy5yZXF1ZXN0ID0gbnVsbDtcbiAgICB0aGlzLnJlc3BvbnNlID0gbnVsbDtcbiAgICB0aGlzLmNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLmNvbmZpZyA9IG51bGw7XG4gICAgdGhpcy5jYWxsYmFja3MgPSBudWxsO1xuICAgIHRoaXMuc3RhdHMgPSB2b2lkIDA7XG4gICAgdGhpcy5sb2FkZXIgPSBudWxsO1xuICAgIHRoaXMuZmV0Y2hTZXR1cCA9IGNvbmZpZy5mZXRjaFNldHVwIHx8IGdldFJlcXVlc3Q7XG4gICAgdGhpcy5jb250cm9sbGVyID0gbmV3IHNlbGYuQWJvcnRDb250cm9sbGVyKCk7XG4gICAgdGhpcy5zdGF0cyA9IG5ldyBMb2FkU3RhdHMoKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMubG9hZGVyID0gdGhpcy5jYWxsYmFja3MgPSB0aGlzLmNvbnRleHQgPSB0aGlzLmNvbmZpZyA9IHRoaXMucmVxdWVzdCA9IG51bGw7XG4gICAgdGhpcy5hYm9ydEludGVybmFsKCk7XG4gICAgdGhpcy5yZXNwb25zZSA9IG51bGw7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuZmV0Y2hTZXR1cCA9IHRoaXMuY29udHJvbGxlciA9IHRoaXMuc3RhdHMgPSBudWxsO1xuICB9XG4gIGFib3J0SW50ZXJuYWwoKSB7XG4gICAgaWYgKHRoaXMuY29udHJvbGxlciAmJiAhdGhpcy5zdGF0cy5sb2FkaW5nLmVuZCkge1xuICAgICAgdGhpcy5zdGF0cy5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuY29udHJvbGxlci5hYm9ydCgpO1xuICAgIH1cbiAgfVxuICBhYm9ydCgpIHtcbiAgICB2YXIgX3RoaXMkY2FsbGJhY2tzO1xuICAgIHRoaXMuYWJvcnRJbnRlcm5hbCgpO1xuICAgIGlmICgoX3RoaXMkY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3MpICE9IG51bGwgJiYgX3RoaXMkY2FsbGJhY2tzLm9uQWJvcnQpIHtcbiAgICAgIHRoaXMuY2FsbGJhY2tzLm9uQWJvcnQodGhpcy5zdGF0cywgdGhpcy5jb250ZXh0LCB0aGlzLnJlc3BvbnNlKTtcbiAgICB9XG4gIH1cbiAgbG9hZChjb250ZXh0LCBjb25maWcsIGNhbGxiYWNrcykge1xuICAgIGNvbnN0IHN0YXRzID0gdGhpcy5zdGF0cztcbiAgICBpZiAoc3RhdHMubG9hZGluZy5zdGFydCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb2FkZXIgY2FuIG9ubHkgYmUgdXNlZCBvbmNlLicpO1xuICAgIH1cbiAgICBzdGF0cy5sb2FkaW5nLnN0YXJ0ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCBpbml0UGFyYW1zID0gZ2V0UmVxdWVzdFBhcmFtZXRlcnMoY29udGV4dCwgdGhpcy5jb250cm9sbGVyLnNpZ25hbCk7XG4gICAgY29uc3QgaXNBcnJheUJ1ZmZlciA9IGNvbnRleHQucmVzcG9uc2VUeXBlID09PSAnYXJyYXlidWZmZXInO1xuICAgIGNvbnN0IExFTkdUSCA9IGlzQXJyYXlCdWZmZXIgPyAnYnl0ZUxlbmd0aCcgOiAnbGVuZ3RoJztcbiAgICBjb25zdCB7XG4gICAgICBtYXhUaW1lVG9GaXJzdEJ5dGVNcyxcbiAgICAgIG1heExvYWRUaW1lTXNcbiAgICB9ID0gY29uZmlnLmxvYWRQb2xpY3k7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcbiAgICB0aGlzLnJlcXVlc3QgPSB0aGlzLmZldGNoU2V0dXAoY29udGV4dCwgaW5pdFBhcmFtcyk7XG4gICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgY29uZmlnLnRpbWVvdXQgPSBtYXhUaW1lVG9GaXJzdEJ5dGVNcyAmJiBpc0Zpbml0ZU51bWJlcihtYXhUaW1lVG9GaXJzdEJ5dGVNcykgPyBtYXhUaW1lVG9GaXJzdEJ5dGVNcyA6IG1heExvYWRUaW1lTXM7XG4gICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IHNlbGYuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5jYWxsYmFja3MpIHtcbiAgICAgICAgdGhpcy5hYm9ydEludGVybmFsKCk7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLm9uVGltZW91dChzdGF0cywgY29udGV4dCwgdGhpcy5yZXNwb25zZSk7XG4gICAgICB9XG4gICAgfSwgY29uZmlnLnRpbWVvdXQpO1xuICAgIGNvbnN0IGZldGNoUHJvbWlzZSA9IGlzUHJvbWlzZSh0aGlzLnJlcXVlc3QpID8gdGhpcy5yZXF1ZXN0LnRoZW4oc2VsZi5mZXRjaCkgOiBzZWxmLmZldGNoKHRoaXMucmVxdWVzdCk7XG4gICAgZmV0Y2hQcm9taXNlLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgdmFyIF90aGlzJGNhbGxiYWNrczI7XG4gICAgICB0aGlzLnJlc3BvbnNlID0gdGhpcy5sb2FkZXIgPSByZXNwb25zZTtcbiAgICAgIGNvbnN0IGZpcnN0ID0gTWF0aC5tYXgoc2VsZi5wZXJmb3JtYW5jZS5ub3coKSwgc3RhdHMubG9hZGluZy5zdGFydCk7XG4gICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICAgIGNvbmZpZy50aW1lb3V0ID0gbWF4TG9hZFRpbWVNcztcbiAgICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBzZWxmLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5jYWxsYmFja3MpIHtcbiAgICAgICAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5vblRpbWVvdXQoc3RhdHMsIGNvbnRleHQsIHRoaXMucmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICB9LCBtYXhMb2FkVGltZU1zIC0gKGZpcnN0IC0gc3RhdHMubG9hZGluZy5zdGFydCkpO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgIHN0YXR1c1RleHRcbiAgICAgICAgfSA9IHJlc3BvbnNlO1xuICAgICAgICB0aHJvdyBuZXcgRmV0Y2hFcnJvcihzdGF0dXNUZXh0IHx8ICdmZXRjaCwgYmFkIG5ldHdvcmsgcmVzcG9uc2UnLCBzdGF0dXMsIHJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICAgIHN0YXRzLmxvYWRpbmcuZmlyc3QgPSBmaXJzdDtcbiAgICAgIHN0YXRzLnRvdGFsID0gZ2V0Q29udGVudExlbmd0aChyZXNwb25zZS5oZWFkZXJzKSB8fCBzdGF0cy50b3RhbDtcbiAgICAgIGNvbnN0IG9uUHJvZ3Jlc3MgPSAoX3RoaXMkY2FsbGJhY2tzMiA9IHRoaXMuY2FsbGJhY2tzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkY2FsbGJhY2tzMi5vblByb2dyZXNzO1xuICAgICAgaWYgKG9uUHJvZ3Jlc3MgJiYgaXNGaW5pdGVOdW1iZXIoY29uZmlnLmhpZ2hXYXRlck1hcmspKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRQcm9ncmVzc2l2ZWx5KHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgY29uZmlnLmhpZ2hXYXRlck1hcmssIG9uUHJvZ3Jlc3MpO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgICB9XG4gICAgICBpZiAoY29udGV4dC5yZXNwb25zZVR5cGUgPT09ICdqc29uJykge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgICB9KS50aGVuKHJlc3BvbnNlRGF0YSA9PiB7XG4gICAgICB2YXIgX3RoaXMkY2FsbGJhY2tzMywgX3RoaXMkY2FsbGJhY2tzNDtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy5yZXNwb25zZTtcbiAgICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsb2FkZXIgZGVzdHJveWVkJyk7XG4gICAgICB9XG4gICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICAgIHN0YXRzLmxvYWRpbmcuZW5kID0gTWF0aC5tYXgoc2VsZi5wZXJmb3JtYW5jZS5ub3coKSwgc3RhdHMubG9hZGluZy5maXJzdCk7XG4gICAgICBjb25zdCB0b3RhbCA9IHJlc3BvbnNlRGF0YVtMRU5HVEhdO1xuICAgICAgaWYgKHRvdGFsKSB7XG4gICAgICAgIHN0YXRzLmxvYWRlZCA9IHN0YXRzLnRvdGFsID0gdG90YWw7XG4gICAgICB9XG4gICAgICBjb25zdCBsb2FkZXJSZXNwb25zZSA9IHtcbiAgICAgICAgdXJsOiByZXNwb25zZS51cmwsXG4gICAgICAgIGRhdGE6IHJlc3BvbnNlRGF0YSxcbiAgICAgICAgY29kZTogcmVzcG9uc2Uuc3RhdHVzXG4gICAgICB9O1xuICAgICAgY29uc3Qgb25Qcm9ncmVzcyA9IChfdGhpcyRjYWxsYmFja3MzID0gdGhpcy5jYWxsYmFja3MpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRjYWxsYmFja3MzLm9uUHJvZ3Jlc3M7XG4gICAgICBpZiAob25Qcm9ncmVzcyAmJiAhaXNGaW5pdGVOdW1iZXIoY29uZmlnLmhpZ2hXYXRlck1hcmspKSB7XG4gICAgICAgIG9uUHJvZ3Jlc3Moc3RhdHMsIGNvbnRleHQsIHJlc3BvbnNlRGF0YSwgcmVzcG9uc2UpO1xuICAgICAgfVxuICAgICAgKF90aGlzJGNhbGxiYWNrczQgPSB0aGlzLmNhbGxiYWNrcykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGNhbGxiYWNrczQub25TdWNjZXNzKGxvYWRlclJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgcmVzcG9uc2UpO1xuICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgIHZhciBfdGhpcyRjYWxsYmFja3M1O1xuICAgICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgICBpZiAoc3RhdHMuYWJvcnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBDT1JTIGVycm9ycyByZXN1bHQgaW4gYW4gdW5kZWZpbmVkIGNvZGUuIFNldCBpdCB0byAwIGhlcmUgdG8gYWxpZ24gd2l0aCBYSFIncyBiZWhhdmlvclxuICAgICAgLy8gd2hlbiBkZXN0cm95aW5nLCAnZXJyb3InIGl0c2VsZiBjYW4gYmUgdW5kZWZpbmVkXG4gICAgICBjb25zdCBjb2RlID0gIWVycm9yID8gMCA6IGVycm9yLmNvZGUgfHwgMDtcbiAgICAgIGNvbnN0IHRleHQgPSAhZXJyb3IgPyBudWxsIDogZXJyb3IubWVzc2FnZTtcbiAgICAgIChfdGhpcyRjYWxsYmFja3M1ID0gdGhpcy5jYWxsYmFja3MpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRjYWxsYmFja3M1Lm9uRXJyb3Ioe1xuICAgICAgICBjb2RlLFxuICAgICAgICB0ZXh0XG4gICAgICB9LCBjb250ZXh0LCBlcnJvciA/IGVycm9yLmRldGFpbHMgOiBudWxsLCBzdGF0cyk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0Q2FjaGVBZ2UoKSB7XG4gICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgaWYgKHRoaXMucmVzcG9uc2UpIHtcbiAgICAgIGNvbnN0IGFnZUhlYWRlciA9IHRoaXMucmVzcG9uc2UuaGVhZGVycy5nZXQoJ2FnZScpO1xuICAgICAgcmVzdWx0ID0gYWdlSGVhZGVyID8gcGFyc2VGbG9hdChhZ2VIZWFkZXIpIDogbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBnZXRSZXNwb25zZUhlYWRlcihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzcG9uc2UgPyB0aGlzLnJlc3BvbnNlLmhlYWRlcnMuZ2V0KG5hbWUpIDogbnVsbDtcbiAgfVxuICBsb2FkUHJvZ3Jlc3NpdmVseShyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIGhpZ2hXYXRlck1hcmsgPSAwLCBvblByb2dyZXNzKSB7XG4gICAgY29uc3QgY2h1bmtDYWNoZSA9IG5ldyBDaHVua0NhY2hlKCk7XG4gICAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgICBjb25zdCBwdW1wID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHJlYWRlci5yZWFkKCkudGhlbihkYXRhID0+IHtcbiAgICAgICAgaWYgKGRhdGEuZG9uZSkge1xuICAgICAgICAgIGlmIChjaHVua0NhY2hlLmRhdGFMZW5ndGgpIHtcbiAgICAgICAgICAgIG9uUHJvZ3Jlc3Moc3RhdHMsIGNvbnRleHQsIGNodW5rQ2FjaGUuZmx1c2goKS5idWZmZXIsIHJlc3BvbnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQXJyYXlCdWZmZXIoMCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNodW5rID0gZGF0YS52YWx1ZTtcbiAgICAgICAgY29uc3QgbGVuID0gY2h1bmsubGVuZ3RoO1xuICAgICAgICBzdGF0cy5sb2FkZWQgKz0gbGVuO1xuICAgICAgICBpZiAobGVuIDwgaGlnaFdhdGVyTWFyayB8fCBjaHVua0NhY2hlLmRhdGFMZW5ndGgpIHtcbiAgICAgICAgICAvLyBUaGUgY3VycmVudCBjaHVuayBpcyB0b28gc21hbGwgdG8gdG8gYmUgZW1pdHRlZCBvciB0aGUgY2FjaGUgYWxyZWFkeSBoYXMgZGF0YVxuICAgICAgICAgIC8vIFB1c2ggaXQgdG8gdGhlIGNhY2hlXG4gICAgICAgICAgY2h1bmtDYWNoZS5wdXNoKGNodW5rKTtcbiAgICAgICAgICBpZiAoY2h1bmtDYWNoZS5kYXRhTGVuZ3RoID49IGhpZ2hXYXRlck1hcmspIHtcbiAgICAgICAgICAgIC8vIGZsdXNoIGluIG9yZGVyIHRvIGpvaW4gdGhlIHR5cGVkIGFycmF5c1xuICAgICAgICAgICAgb25Qcm9ncmVzcyhzdGF0cywgY29udGV4dCwgY2h1bmtDYWNoZS5mbHVzaCgpLmJ1ZmZlciwgcmVzcG9uc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZiB0aGVyZSdzIG5vdGhpbmcgY2FjaGVkIGFscmVhZHksIGFuZCB0aGUgY2hhY2hlIGlzIGxhcmdlIGVub3VnaFxuICAgICAgICAgIC8vIGp1c3QgZW1pdCB0aGUgcHJvZ3Jlc3MgZXZlbnRcbiAgICAgICAgICBvblByb2dyZXNzKHN0YXRzLCBjb250ZXh0LCBjaHVuay5idWZmZXIsIHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHVtcCgpO1xuICAgICAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAvKiBhYm9ydGVkICovXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gcHVtcCgpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRSZXF1ZXN0UGFyYW1ldGVycyhjb250ZXh0LCBzaWduYWwpIHtcbiAgY29uc3QgaW5pdFBhcmFtcyA9IHtcbiAgICBtZXRob2Q6ICdHRVQnLFxuICAgIG1vZGU6ICdjb3JzJyxcbiAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyxcbiAgICBzaWduYWwsXG4gICAgaGVhZGVyczogbmV3IHNlbGYuSGVhZGVycyhfZXh0ZW5kcyh7fSwgY29udGV4dC5oZWFkZXJzKSlcbiAgfTtcbiAgaWYgKGNvbnRleHQucmFuZ2VFbmQpIHtcbiAgICBpbml0UGFyYW1zLmhlYWRlcnMuc2V0KCdSYW5nZScsICdieXRlcz0nICsgY29udGV4dC5yYW5nZVN0YXJ0ICsgJy0nICsgU3RyaW5nKGNvbnRleHQucmFuZ2VFbmQgLSAxKSk7XG4gIH1cbiAgcmV0dXJuIGluaXRQYXJhbXM7XG59XG5mdW5jdGlvbiBnZXRCeXRlUmFuZ2VMZW5ndGgoYnl0ZVJhbmdlSGVhZGVyKSB7XG4gIGNvbnN0IHJlc3VsdCA9IEJZVEVSQU5HRS5leGVjKGJ5dGVSYW5nZUhlYWRlcik7XG4gIGlmIChyZXN1bHQpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQocmVzdWx0WzJdKSAtIHBhcnNlSW50KHJlc3VsdFsxXSkgKyAxO1xuICB9XG59XG5mdW5jdGlvbiBnZXRDb250ZW50TGVuZ3RoKGhlYWRlcnMpIHtcbiAgY29uc3QgY29udGVudFJhbmdlID0gaGVhZGVycy5nZXQoJ0NvbnRlbnQtUmFuZ2UnKTtcbiAgaWYgKGNvbnRlbnRSYW5nZSkge1xuICAgIGNvbnN0IGJ5dGVSYW5nZUxlbmd0aCA9IGdldEJ5dGVSYW5nZUxlbmd0aChjb250ZW50UmFuZ2UpO1xuICAgIGlmIChpc0Zpbml0ZU51bWJlcihieXRlUmFuZ2VMZW5ndGgpKSB7XG4gICAgICByZXR1cm4gYnl0ZVJhbmdlTGVuZ3RoO1xuICAgIH1cbiAgfVxuICBjb25zdCBjb250ZW50TGVuZ3RoID0gaGVhZGVycy5nZXQoJ0NvbnRlbnQtTGVuZ3RoJyk7XG4gIGlmIChjb250ZW50TGVuZ3RoKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KGNvbnRlbnRMZW5ndGgpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRSZXF1ZXN0KGNvbnRleHQsIGluaXRQYXJhbXMpIHtcbiAgcmV0dXJuIG5ldyBzZWxmLlJlcXVlc3QoY29udGV4dC51cmwsIGluaXRQYXJhbXMpO1xufVxuY2xhc3MgRmV0Y2hFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgY29kZSwgZGV0YWlscykge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuY29kZSA9IHZvaWQgMDtcbiAgICB0aGlzLmRldGFpbHMgPSB2b2lkIDA7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICB9XG59XG5cbmNvbnN0IEFHRV9IRUFERVJfTElORV9SRUdFWCA9IC9eYWdlOlxccypbXFxkLl0rXFxzKiQvaW07XG5jbGFzcyBYaHJMb2FkZXIge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLnhoclNldHVwID0gdm9pZCAwO1xuICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSB2b2lkIDA7XG4gICAgdGhpcy5yZXRyeVRpbWVvdXQgPSB2b2lkIDA7XG4gICAgdGhpcy5yZXRyeURlbGF5ID0gdm9pZCAwO1xuICAgIHRoaXMuY29uZmlnID0gbnVsbDtcbiAgICB0aGlzLmNhbGxiYWNrcyA9IG51bGw7XG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgdGhpcy5zdGF0cyA9IHZvaWQgMDtcbiAgICB0aGlzLnhoclNldHVwID0gY29uZmlnID8gY29uZmlnLnhoclNldHVwIHx8IG51bGwgOiBudWxsO1xuICAgIHRoaXMuc3RhdHMgPSBuZXcgTG9hZFN0YXRzKCk7XG4gICAgdGhpcy5yZXRyeURlbGF5ID0gMDtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuY2FsbGJhY2tzID0gbnVsbDtcbiAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgdGhpcy5jb25maWcgPSBudWxsO1xuICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgdGhpcy54aHJTZXR1cCA9IG51bGw7XG4gIH1cbiAgYWJvcnRJbnRlcm5hbCgpIHtcbiAgICBjb25zdCBsb2FkZXIgPSB0aGlzLmxvYWRlcjtcbiAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJldHJ5VGltZW91dCk7XG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgbG9hZGVyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICBsb2FkZXIub25wcm9ncmVzcyA9IG51bGw7XG4gICAgICBpZiAobG9hZGVyLnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgICAgdGhpcy5zdGF0cy5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFib3J0KCkge1xuICAgIHZhciBfdGhpcyRjYWxsYmFja3M7XG4gICAgdGhpcy5hYm9ydEludGVybmFsKCk7XG4gICAgaWYgKChfdGhpcyRjYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrcykgIT0gbnVsbCAmJiBfdGhpcyRjYWxsYmFja3Mub25BYm9ydCkge1xuICAgICAgdGhpcy5jYWxsYmFja3Mub25BYm9ydCh0aGlzLnN0YXRzLCB0aGlzLmNvbnRleHQsIHRoaXMubG9hZGVyKTtcbiAgICB9XG4gIH1cbiAgbG9hZChjb250ZXh0LCBjb25maWcsIGNhbGxiYWNrcykge1xuICAgIGlmICh0aGlzLnN0YXRzLmxvYWRpbmcuc3RhcnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTG9hZGVyIGNhbiBvbmx5IGJlIHVzZWQgb25jZS4nKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0cy5sb2FkaW5nLnN0YXJ0ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICAgIHRoaXMubG9hZEludGVybmFsKCk7XG4gIH1cbiAgbG9hZEludGVybmFsKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbmZpZyxcbiAgICAgIGNvbnRleHRcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWNvbmZpZyB8fCAhY29udGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB4aHIgPSB0aGlzLmxvYWRlciA9IG5ldyBzZWxmLlhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgY29uc3Qgc3RhdHMgPSB0aGlzLnN0YXRzO1xuICAgIHN0YXRzLmxvYWRpbmcuZmlyc3QgPSAwO1xuICAgIHN0YXRzLmxvYWRlZCA9IDA7XG4gICAgc3RhdHMuYWJvcnRlZCA9IGZhbHNlO1xuICAgIGNvbnN0IHhoclNldHVwID0gdGhpcy54aHJTZXR1cDtcbiAgICBpZiAoeGhyU2V0dXApIHtcbiAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5sb2FkZXIgIT09IHhociB8fCB0aGlzLnN0YXRzLmFib3J0ZWQpIHJldHVybjtcbiAgICAgICAgcmV0dXJuIHhoclNldHVwKHhociwgY29udGV4dC51cmwpO1xuICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICBpZiAodGhpcy5sb2FkZXIgIT09IHhociB8fCB0aGlzLnN0YXRzLmFib3J0ZWQpIHJldHVybjtcbiAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIGNvbnRleHQudXJsLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHhoclNldHVwKHhociwgY29udGV4dC51cmwpO1xuICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmxvYWRlciAhPT0geGhyIHx8IHRoaXMuc3RhdHMuYWJvcnRlZCkgcmV0dXJuO1xuICAgICAgICB0aGlzLm9wZW5BbmRTZW5kWGhyKHhociwgY29udGV4dCwgY29uZmlnKTtcbiAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgdmFyIF90aGlzJGNhbGxiYWNrczI7XG4gICAgICAgIC8vIElFMTEgdGhyb3dzIGFuIGV4Y2VwdGlvbiBvbiB4aHIub3BlbiBpZiBhdHRlbXB0aW5nIHRvIGFjY2VzcyBhbiBIVFRQIHJlc291cmNlIG92ZXIgSFRUUFNcbiAgICAgICAgKF90aGlzJGNhbGxiYWNrczIgPSB0aGlzLmNhbGxiYWNrcykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGNhbGxiYWNrczIub25FcnJvcih7XG4gICAgICAgICAgY29kZTogeGhyLnN0YXR1cyxcbiAgICAgICAgICB0ZXh0OiBlcnJvci5tZXNzYWdlXG4gICAgICAgIH0sIGNvbnRleHQsIHhociwgc3RhdHMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vcGVuQW5kU2VuZFhocih4aHIsIGNvbnRleHQsIGNvbmZpZyk7XG4gICAgfVxuICB9XG4gIG9wZW5BbmRTZW5kWGhyKHhociwgY29udGV4dCwgY29uZmlnKSB7XG4gICAgaWYgKCF4aHIucmVhZHlTdGF0ZSkge1xuICAgICAgeGhyLm9wZW4oJ0dFVCcsIGNvbnRleHQudXJsLCB0cnVlKTtcbiAgICB9XG4gICAgY29uc3QgaGVhZGVycyA9IGNvbnRleHQuaGVhZGVycztcbiAgICBjb25zdCB7XG4gICAgICBtYXhUaW1lVG9GaXJzdEJ5dGVNcyxcbiAgICAgIG1heExvYWRUaW1lTXNcbiAgICB9ID0gY29uZmlnLmxvYWRQb2xpY3k7XG4gICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgIGZvciAoY29uc3QgaGVhZGVyIGluIGhlYWRlcnMpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyLCBoZWFkZXJzW2hlYWRlcl0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29udGV4dC5yYW5nZUVuZCkge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ1JhbmdlJywgJ2J5dGVzPScgKyBjb250ZXh0LnJhbmdlU3RhcnQgKyAnLScgKyAoY29udGV4dC5yYW5nZUVuZCAtIDEpKTtcbiAgICB9XG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHRoaXMucmVhZHlzdGF0ZWNoYW5nZS5iaW5kKHRoaXMpO1xuICAgIHhoci5vbnByb2dyZXNzID0gdGhpcy5sb2FkcHJvZ3Jlc3MuYmluZCh0aGlzKTtcbiAgICB4aHIucmVzcG9uc2VUeXBlID0gY29udGV4dC5yZXNwb25zZVR5cGU7XG4gICAgLy8gc2V0dXAgdGltZW91dCBiZWZvcmUgd2UgcGVyZm9ybSByZXF1ZXN0XG4gICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgY29uZmlnLnRpbWVvdXQgPSBtYXhUaW1lVG9GaXJzdEJ5dGVNcyAmJiBpc0Zpbml0ZU51bWJlcihtYXhUaW1lVG9GaXJzdEJ5dGVNcykgPyBtYXhUaW1lVG9GaXJzdEJ5dGVNcyA6IG1heExvYWRUaW1lTXM7XG4gICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IHNlbGYuc2V0VGltZW91dCh0aGlzLmxvYWR0aW1lb3V0LmJpbmQodGhpcyksIGNvbmZpZy50aW1lb3V0KTtcbiAgICB4aHIuc2VuZCgpO1xuICB9XG4gIHJlYWR5c3RhdGVjaGFuZ2UoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dCxcbiAgICAgIGxvYWRlcjogeGhyLFxuICAgICAgc3RhdHNcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWNvbnRleHQgfHwgIXhocikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZWFkeVN0YXRlID0geGhyLnJlYWR5U3RhdGU7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG5cbiAgICAvLyBkb24ndCBwcm9jZWVkIGlmIHhociBoYXMgYmVlbiBhYm9ydGVkXG4gICAgaWYgKHN0YXRzLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyA+PSBIRUFERVJTX1JFQ0VJVkVEXG4gICAgaWYgKHJlYWR5U3RhdGUgPj0gMikge1xuICAgICAgaWYgKHN0YXRzLmxvYWRpbmcuZmlyc3QgPT09IDApIHtcbiAgICAgICAgc3RhdHMubG9hZGluZy5maXJzdCA9IE1hdGgubWF4KHNlbGYucGVyZm9ybWFuY2Uubm93KCksIHN0YXRzLmxvYWRpbmcuc3RhcnQpO1xuICAgICAgICAvLyByZWFkeVN0YXRlID49IDIgQU5EIHJlYWR5U3RhdGUgIT09NCAocmVhZHlTdGF0ZSA9IEhFQURFUlNfUkVDRUlWRUQgfHwgTE9BRElORykgcmVhcm0gdGltZW91dCBhcyB4aHIgbm90IGZpbmlzaGVkIHlldFxuICAgICAgICBpZiAoY29uZmlnLnRpbWVvdXQgIT09IGNvbmZpZy5sb2FkUG9saWN5Lm1heExvYWRUaW1lTXMpIHtcbiAgICAgICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICAgICAgICBjb25maWcudGltZW91dCA9IGNvbmZpZy5sb2FkUG9saWN5Lm1heExvYWRUaW1lTXM7XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IHNlbGYuc2V0VGltZW91dCh0aGlzLmxvYWR0aW1lb3V0LmJpbmQodGhpcyksIGNvbmZpZy5sb2FkUG9saWN5Lm1heExvYWRUaW1lTXMgLSAoc3RhdHMubG9hZGluZy5maXJzdCAtIHN0YXRzLmxvYWRpbmcuc3RhcnQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICB4aHIub25wcm9ncmVzcyA9IG51bGw7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IHhoci5zdGF0dXM7XG4gICAgICAgIC8vIGh0dHAgc3RhdHVzIGJldHdlZW4gMjAwIHRvIDI5OSBhcmUgYWxsIHN1Y2Nlc3NmdWxcbiAgICAgICAgY29uc3QgdXNlUmVzcG9uc2VUZXh0ID0geGhyLnJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnID8geGhyLnJlc3BvbnNlVGV4dCA6IG51bGw7XG4gICAgICAgIGlmIChzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCkge1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSB1c2VSZXNwb25zZVRleHQgIT0gbnVsbCA/IHVzZVJlc3BvbnNlVGV4dCA6IHhoci5yZXNwb25zZTtcbiAgICAgICAgICBpZiAoZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMkY2FsbGJhY2tzMywgX3RoaXMkY2FsbGJhY2tzNDtcbiAgICAgICAgICAgIHN0YXRzLmxvYWRpbmcuZW5kID0gTWF0aC5tYXgoc2VsZi5wZXJmb3JtYW5jZS5ub3coKSwgc3RhdHMubG9hZGluZy5maXJzdCk7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSB4aHIucmVzcG9uc2VUeXBlID09PSAnYXJyYXlidWZmZXInID8gZGF0YS5ieXRlTGVuZ3RoIDogZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICBzdGF0cy5sb2FkZWQgPSBzdGF0cy50b3RhbCA9IGxlbjtcbiAgICAgICAgICAgIHN0YXRzLmJ3RXN0aW1hdGUgPSBzdGF0cy50b3RhbCAqIDgwMDAgLyAoc3RhdHMubG9hZGluZy5lbmQgLSBzdGF0cy5sb2FkaW5nLmZpcnN0KTtcbiAgICAgICAgICAgIGNvbnN0IG9uUHJvZ3Jlc3MgPSAoX3RoaXMkY2FsbGJhY2tzMyA9IHRoaXMuY2FsbGJhY2tzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkY2FsbGJhY2tzMy5vblByb2dyZXNzO1xuICAgICAgICAgICAgaWYgKG9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgb25Qcm9ncmVzcyhzdGF0cywgY29udGV4dCwgZGF0YSwgeGhyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IF9yZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgdXJsOiB4aHIucmVzcG9uc2VVUkwsXG4gICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgIGNvZGU6IHN0YXR1c1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIChfdGhpcyRjYWxsYmFja3M0ID0gdGhpcy5jYWxsYmFja3MpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRjYWxsYmFja3M0Lm9uU3VjY2VzcyhfcmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCB4aHIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSBiYWQgc3RhdHVzIG9yIG51bGxpc2ggcmVzcG9uc2VcbiAgICAgICAgY29uc3QgcmV0cnlDb25maWcgPSBjb25maWcubG9hZFBvbGljeS5lcnJvclJldHJ5O1xuICAgICAgICBjb25zdCByZXRyeUNvdW50ID0gc3RhdHMucmV0cnk7XG4gICAgICAgIC8vIGlmIG1heCBuYiBvZiByZXRyaWVzIHJlYWNoZWQgb3IgaWYgaHR0cCBzdGF0dXMgYmV0d2VlbiA0MDAgYW5kIDQ5OSAoc3VjaCBlcnJvciBjYW5ub3QgYmUgcmVjb3ZlcmVkLCByZXRyeWluZyBpcyB1c2VsZXNzKSwgcmV0dXJuIGVycm9yXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICAgIHVybDogY29udGV4dC51cmwsXG4gICAgICAgICAgZGF0YTogdW5kZWZpbmVkLFxuICAgICAgICAgIGNvZGU6IHN0YXR1c1xuICAgICAgICB9O1xuICAgICAgICBpZiAoc2hvdWxkUmV0cnkocmV0cnlDb25maWcsIHJldHJ5Q291bnQsIGZhbHNlLCByZXNwb25zZSkpIHtcbiAgICAgICAgICB0aGlzLnJldHJ5KHJldHJ5Q29uZmlnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX3RoaXMkY2FsbGJhY2tzNTtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoYCR7c3RhdHVzfSB3aGlsZSBsb2FkaW5nICR7Y29udGV4dC51cmx9YCk7XG4gICAgICAgICAgKF90aGlzJGNhbGxiYWNrczUgPSB0aGlzLmNhbGxiYWNrcykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGNhbGxiYWNrczUub25FcnJvcih7XG4gICAgICAgICAgICBjb2RlOiBzdGF0dXMsXG4gICAgICAgICAgICB0ZXh0OiB4aHIuc3RhdHVzVGV4dFxuICAgICAgICAgIH0sIGNvbnRleHQsIHhociwgc3RhdHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxvYWR0aW1lb3V0KCkge1xuICAgIGlmICghdGhpcy5jb25maWcpIHJldHVybjtcbiAgICBjb25zdCByZXRyeUNvbmZpZyA9IHRoaXMuY29uZmlnLmxvYWRQb2xpY3kudGltZW91dFJldHJ5O1xuICAgIGNvbnN0IHJldHJ5Q291bnQgPSB0aGlzLnN0YXRzLnJldHJ5O1xuICAgIGlmIChzaG91bGRSZXRyeShyZXRyeUNvbmZpZywgcmV0cnlDb3VudCwgdHJ1ZSkpIHtcbiAgICAgIHRoaXMucmV0cnkocmV0cnlDb25maWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX3RoaXMkY29udGV4dDtcbiAgICAgIGxvZ2dlci53YXJuKGB0aW1lb3V0IHdoaWxlIGxvYWRpbmcgJHsoX3RoaXMkY29udGV4dCA9IHRoaXMuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGNvbnRleHQudXJsfWApO1xuICAgICAgY29uc3QgY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3M7XG4gICAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAgIHRoaXMuYWJvcnRJbnRlcm5hbCgpO1xuICAgICAgICBjYWxsYmFja3Mub25UaW1lb3V0KHRoaXMuc3RhdHMsIHRoaXMuY29udGV4dCwgdGhpcy5sb2FkZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXRyeShyZXRyeUNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRleHQsXG4gICAgICBzdGF0c1xuICAgIH0gPSB0aGlzO1xuICAgIHRoaXMucmV0cnlEZWxheSA9IGdldFJldHJ5RGVsYXkocmV0cnlDb25maWcsIHN0YXRzLnJldHJ5KTtcbiAgICBzdGF0cy5yZXRyeSsrO1xuICAgIGxvZ2dlci53YXJuKGAke3N0YXR1cyA/ICdIVFRQIFN0YXR1cyAnICsgc3RhdHVzIDogJ1RpbWVvdXQnfSB3aGlsZSBsb2FkaW5nICR7Y29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogY29udGV4dC51cmx9LCByZXRyeWluZyAke3N0YXRzLnJldHJ5fS8ke3JldHJ5Q29uZmlnLm1heE51bVJldHJ5fSBpbiAke3RoaXMucmV0cnlEZWxheX1tc2ApO1xuICAgIC8vIGFib3J0IGFuZCByZXNldCBpbnRlcm5hbCBzdGF0ZVxuICAgIHRoaXMuYWJvcnRJbnRlcm5hbCgpO1xuICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgICAvLyBzY2hlZHVsZSByZXRyeVxuICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmV0cnlUaW1lb3V0KTtcbiAgICB0aGlzLnJldHJ5VGltZW91dCA9IHNlbGYuc2V0VGltZW91dCh0aGlzLmxvYWRJbnRlcm5hbC5iaW5kKHRoaXMpLCB0aGlzLnJldHJ5RGVsYXkpO1xuICB9XG4gIGxvYWRwcm9ncmVzcyhldmVudCkge1xuICAgIGNvbnN0IHN0YXRzID0gdGhpcy5zdGF0cztcbiAgICBzdGF0cy5sb2FkZWQgPSBldmVudC5sb2FkZWQ7XG4gICAgaWYgKGV2ZW50Lmxlbmd0aENvbXB1dGFibGUpIHtcbiAgICAgIHN0YXRzLnRvdGFsID0gZXZlbnQudG90YWw7XG4gICAgfVxuICB9XG4gIGdldENhY2hlQWdlKCkge1xuICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgIGlmICh0aGlzLmxvYWRlciAmJiBBR0VfSEVBREVSX0xJTkVfUkVHRVgudGVzdCh0aGlzLmxvYWRlci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkpIHtcbiAgICAgIGNvbnN0IGFnZUhlYWRlciA9IHRoaXMubG9hZGVyLmdldFJlc3BvbnNlSGVhZGVyKCdhZ2UnKTtcbiAgICAgIHJlc3VsdCA9IGFnZUhlYWRlciA/IHBhcnNlRmxvYXQoYWdlSGVhZGVyKSA6IG51bGw7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZ2V0UmVzcG9uc2VIZWFkZXIobmFtZSkge1xuICAgIGlmICh0aGlzLmxvYWRlciAmJiBuZXcgUmVnRXhwKGBeJHtuYW1lfTpcXFxccypbXFxcXGQuXStcXFxccyokYCwgJ2ltJykudGVzdCh0aGlzLmxvYWRlci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvYWRlci5nZXRSZXNwb25zZUhlYWRlcihuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCB1c2UgZnJhZ0xvYWRQb2xpY3kuZGVmYXVsdFxuICovXG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgdXNlIG1hbmlmZXN0TG9hZFBvbGljeS5kZWZhdWx0IGFuZCBwbGF5bGlzdExvYWRQb2xpY3kuZGVmYXVsdFxuICovXG5cbmNvbnN0IGRlZmF1bHRMb2FkUG9saWN5ID0ge1xuICBtYXhUaW1lVG9GaXJzdEJ5dGVNczogODAwMCxcbiAgbWF4TG9hZFRpbWVNczogMjAwMDAsXG4gIHRpbWVvdXRSZXRyeTogbnVsbCxcbiAgZXJyb3JSZXRyeTogbnVsbFxufTtcblxuLyoqXG4gKiBAaWdub3JlXG4gKiBJZiBwb3NzaWJsZSwga2VlcCBobHNEZWZhdWx0Q29uZmlnIHNoYWxsb3dcbiAqIEl0IGlzIGNsb25lZCB3aGVuZXZlciBhIG5ldyBIbHMgaW5zdGFuY2UgaXMgY3JlYXRlZCwgYnkga2VlcGluZyB0aGUgY29uZmlnXG4gKiBzaGFsbG93IHRoZSBwcm9wZXJ0aWVzIGFyZSBjbG9uZWQsIGFuZCB3ZSBkb24ndCBlbmQgdXAgbWFuaXB1bGF0aW5nIHRoZSBkZWZhdWx0XG4gKi9cbmNvbnN0IGhsc0RlZmF1bHRDb25maWcgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7XG4gIGF1dG9TdGFydExvYWQ6IHRydWUsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgc3RhcnRQb3NpdGlvbjogLTEsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgZGVmYXVsdEF1ZGlvQ29kZWM6IHVuZGVmaW5lZCxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBkZWJ1ZzogZmFsc2UsXG4gIC8vIHVzZWQgYnkgbG9nZ2VyXG4gIGNhcExldmVsT25GUFNEcm9wOiBmYWxzZSxcbiAgLy8gdXNlZCBieSBmcHMtY29udHJvbGxlclxuICBjYXBMZXZlbFRvUGxheWVyU2l6ZTogZmFsc2UsXG4gIC8vIHVzZWQgYnkgY2FwLWxldmVsLWNvbnRyb2xsZXJcbiAgaWdub3JlRGV2aWNlUGl4ZWxSYXRpbzogZmFsc2UsXG4gIC8vIHVzZWQgYnkgY2FwLWxldmVsLWNvbnRyb2xsZXJcbiAgbWF4RGV2aWNlUGl4ZWxSYXRpbzogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAvLyB1c2VkIGJ5IGNhcC1sZXZlbC1jb250cm9sbGVyXG4gIHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZTogdHJ1ZSxcbiAgaW5pdGlhbExpdmVNYW5pZmVzdFNpemU6IDEsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgbWF4QnVmZmVyTGVuZ3RoOiAzMCxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBiYWNrQnVmZmVyTGVuZ3RoOiBJbmZpbml0eSxcbiAgLy8gdXNlZCBieSBidWZmZXItY29udHJvbGxlclxuICBmcm9udEJ1ZmZlckZsdXNoVGhyZXNob2xkOiBJbmZpbml0eSxcbiAgc3RhcnRPblNlZ21lbnRCb3VuZGFyeTogZmFsc2UsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgbWF4QnVmZmVyU2l6ZTogNjAgKiAxMDAwICogMTAwMCxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBtYXhGcmFnTG9va1VwVG9sZXJhbmNlOiAwLjI1LFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIG1heEJ1ZmZlckhvbGU6IDAuMSxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlciBhbmQgZ2FwLWNvbnRyb2xsZXJcbiAgZGV0ZWN0U3RhbGxXaXRoQ3VycmVudFRpbWVNczogMTI1MCxcbiAgLy8gdXNlZCBieSBnYXAtY29udHJvbGxlclxuICBoaWdoQnVmZmVyV2F0Y2hkb2dQZXJpb2Q6IDIsXG4gIC8vIHVzZWQgYnkgZ2FwLWNvbnRyb2xsZXJcbiAgbnVkZ2VPZmZzZXQ6IDAuMSxcbiAgLy8gdXNlZCBieSBnYXAtY29udHJvbGxlclxuICBudWRnZU1heFJldHJ5OiAzLFxuICAvLyB1c2VkIGJ5IGdhcC1jb250cm9sbGVyXG4gIG51ZGdlT25WaWRlb0hvbGU6IHRydWUsXG4gIC8vIHVzZWQgYnkgZ2FwLWNvbnRyb2xsZXJcbiAgbGl2ZVN5bmNNb2RlOiAnZWRnZScsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgbGl2ZVN5bmNEdXJhdGlvbkNvdW50OiAzLFxuICAvLyB1c2VkIGJ5IGxhdGVuY3ktY29udHJvbGxlclxuICBsaXZlU3luY09uU3RhbGxJbmNyZWFzZTogMSxcbiAgLy8gdXNlZCBieSBsYXRlbmN5LWNvbnRyb2xsZXJcbiAgbGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50OiBJbmZpbml0eSxcbiAgLy8gdXNlZCBieSBsYXRlbmN5LWNvbnRyb2xsZXJcbiAgbGl2ZVN5bmNEdXJhdGlvbjogdW5kZWZpbmVkLFxuICAvLyB1c2VkIGJ5IGxhdGVuY3ktY29udHJvbGxlclxuICBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uOiB1bmRlZmluZWQsXG4gIC8vIHVzZWQgYnkgbGF0ZW5jeS1jb250cm9sbGVyXG4gIG1heExpdmVTeW5jUGxheWJhY2tSYXRlOiAxLFxuICAvLyB1c2VkIGJ5IGxhdGVuY3ktY29udHJvbGxlclxuICBsaXZlRHVyYXRpb25JbmZpbml0eTogZmFsc2UsXG4gIC8vIHVzZWQgYnkgYnVmZmVyLWNvbnRyb2xsZXJcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBiYWNrQnVmZmVyTGVuZ3RoXG4gICAqL1xuICBsaXZlQmFja0J1ZmZlckxlbmd0aDogbnVsbCxcbiAgLy8gdXNlZCBieSBidWZmZXItY29udHJvbGxlclxuICBtYXhNYXhCdWZmZXJMZW5ndGg6IDYwMCxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBlbmFibGVXb3JrZXI6IHRydWUsXG4gIC8vIHVzZWQgYnkgdHJhbnNtdXhlclxuICB3b3JrZXJQYXRoOiBudWxsLFxuICAvLyB1c2VkIGJ5IHRyYW5zbXV4ZXJcbiAgZW5hYmxlU29mdHdhcmVBRVM6IHRydWUsXG4gIC8vIHVzZWQgYnkgZGVjcnlwdGVyXG4gIHN0YXJ0TGV2ZWw6IHVuZGVmaW5lZCxcbiAgLy8gdXNlZCBieSBsZXZlbC1jb250cm9sbGVyXG4gIHN0YXJ0RnJhZ1ByZWZldGNoOiBmYWxzZSxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBmcHNEcm9wcGVkTW9uaXRvcmluZ1BlcmlvZDogNTAwMCxcbiAgLy8gdXNlZCBieSBmcHMtY29udHJvbGxlclxuICBmcHNEcm9wcGVkTW9uaXRvcmluZ1RocmVzaG9sZDogMC4yLFxuICAvLyB1c2VkIGJ5IGZwcy1jb250cm9sbGVyXG4gIGFwcGVuZEVycm9yTWF4UmV0cnk6IDMsXG4gIC8vIHVzZWQgYnkgYnVmZmVyLWNvbnRyb2xsZXJcbiAgaWdub3JlUGxheWxpc3RQYXJzaW5nRXJyb3JzOiBmYWxzZSxcbiAgbG9hZGVyOiBYaHJMb2FkZXIsXG4gIC8vIGxvYWRlcjogRmV0Y2hMb2FkZXIsXG4gIGZMb2FkZXI6IHVuZGVmaW5lZCxcbiAgLy8gdXNlZCBieSBmcmFnbWVudC1sb2FkZXJcbiAgcExvYWRlcjogdW5kZWZpbmVkLFxuICAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxuICB4aHJTZXR1cDogdW5kZWZpbmVkLFxuICAvLyB1c2VkIGJ5IHhoci1sb2FkZXJcbiAgbGljZW5zZVhoclNldHVwOiB1bmRlZmluZWQsXG4gIC8vIHVzZWQgYnkgZW1lLWNvbnRyb2xsZXJcbiAgbGljZW5zZVJlc3BvbnNlQ2FsbGJhY2s6IHVuZGVmaW5lZCxcbiAgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICBhYnJDb250cm9sbGVyOiBBYnJDb250cm9sbGVyLFxuICBidWZmZXJDb250cm9sbGVyOiBCdWZmZXJDb250cm9sbGVyLFxuICBjYXBMZXZlbENvbnRyb2xsZXI6IENhcExldmVsQ29udHJvbGxlcixcbiAgZXJyb3JDb250cm9sbGVyOiBFcnJvckNvbnRyb2xsZXIsXG4gIGZwc0NvbnRyb2xsZXI6IEZQU0NvbnRyb2xsZXIsXG4gIHN0cmV0Y2hTaG9ydFZpZGVvVHJhY2s6IGZhbHNlLFxuICAvLyB1c2VkIGJ5IG1wNC1yZW11eGVyXG4gIG1heEF1ZGlvRnJhbWVzRHJpZnQ6IDEsXG4gIC8vIHVzZWQgYnkgbXA0LXJlbXV4ZXJcbiAgZm9yY2VLZXlGcmFtZU9uRGlzY29udGludWl0eTogdHJ1ZSxcbiAgLy8gdXNlZCBieSB0cy1kZW11eGVyXG4gIGFickV3bWFGYXN0TGl2ZTogMyxcbiAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJFd21hU2xvd0xpdmU6IDksXG4gIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyRXdtYUZhc3RWb0Q6IDMsXG4gIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyRXdtYVNsb3dWb0Q6IDksXG4gIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyRXdtYURlZmF1bHRFc3RpbWF0ZTogNWU1LFxuICAvLyA1MDAga2JwcyAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJFd21hRGVmYXVsdEVzdGltYXRlTWF4OiA1ZTYsXG4gIC8vIDUgbWJwc1xuICBhYnJCYW5kV2lkdGhGYWN0b3I6IDAuOTUsXG4gIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyQmFuZFdpZHRoVXBGYWN0b3I6IDAuNyxcbiAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJNYXhXaXRoUmVhbEJpdHJhdGU6IGZhbHNlLFxuICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIG1heFN0YXJ2YXRpb25EZWxheTogNCxcbiAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBtYXhMb2FkaW5nRGVsYXk6IDQsXG4gIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgbWluQXV0b0JpdHJhdGU6IDAsXG4gIC8vIHVzZWQgYnkgaGxzXG4gIGVtZUVuYWJsZWQ6IGZhbHNlLFxuICAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gIHdpZGV2aW5lTGljZW5zZVVybDogdW5kZWZpbmVkLFxuICAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gIGRybVN5c3RlbXM6IHt9LFxuICAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gIGRybVN5c3RlbU9wdGlvbnM6IHt9LFxuICAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc0Z1bmM6IHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyAsXG4gIC8vIHVzZWQgYnkgZW1lLWNvbnRyb2xsZXJcbiAgcmVxdWlyZUtleVN5c3RlbUFjY2Vzc09uU3RhcnQ6IGZhbHNlLFxuICAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gIHRlc3RCYW5kd2lkdGg6IHRydWUsXG4gIHByb2dyZXNzaXZlOiBmYWxzZSxcbiAgbG93TGF0ZW5jeU1vZGU6IHRydWUsXG4gIGNtY2Q6IHVuZGVmaW5lZCxcbiAgZW5hYmxlRGF0ZVJhbmdlTWV0YWRhdGFDdWVzOiB0cnVlLFxuICBlbmFibGVFbXNnTWV0YWRhdGFDdWVzOiB0cnVlLFxuICBlbmFibGVFbXNnS0xWTWV0YWRhdGE6IGZhbHNlLFxuICBlbmFibGVJRDNNZXRhZGF0YUN1ZXM6IHRydWUsXG4gIGVuYWJsZUludGVyc3RpdGlhbFBsYXliYWNrOiB0cnVlLFxuICBpbnRlcnN0aXRpYWxBcHBlbmRJblBsYWNlOiB0cnVlLFxuICBpbnRlcnN0aXRpYWxMaXZlTG9va0FoZWFkOiAxMCxcbiAgdXNlTWVkaWFDYXBhYmlsaXRpZXM6IHRydWUsXG4gIHByZXNlcnZlTWFudWFsTGV2ZWxPbkVycm9yOiBmYWxzZSxcbiAgY2VydExvYWRQb2xpY3k6IHtcbiAgICBkZWZhdWx0OiBkZWZhdWx0TG9hZFBvbGljeVxuICB9LFxuICBrZXlMb2FkUG9saWN5OiB7XG4gICAgZGVmYXVsdDoge1xuICAgICAgbWF4VGltZVRvRmlyc3RCeXRlTXM6IDgwMDAsXG4gICAgICBtYXhMb2FkVGltZU1zOiAyMDAwMCxcbiAgICAgIHRpbWVvdXRSZXRyeToge1xuICAgICAgICBtYXhOdW1SZXRyeTogMSxcbiAgICAgICAgcmV0cnlEZWxheU1zOiAxMDAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDIwMDAwLFxuICAgICAgICBiYWNrb2ZmOiAnbGluZWFyJ1xuICAgICAgfSxcbiAgICAgIGVycm9yUmV0cnk6IHtcbiAgICAgICAgbWF4TnVtUmV0cnk6IDgsXG4gICAgICAgIHJldHJ5RGVsYXlNczogMTAwMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheU1zOiAyMDAwMCxcbiAgICAgICAgYmFja29mZjogJ2xpbmVhcidcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1hbmlmZXN0TG9hZFBvbGljeToge1xuICAgIGRlZmF1bHQ6IHtcbiAgICAgIG1heFRpbWVUb0ZpcnN0Qnl0ZU1zOiBJbmZpbml0eSxcbiAgICAgIG1heExvYWRUaW1lTXM6IDIwMDAwLFxuICAgICAgdGltZW91dFJldHJ5OiB7XG4gICAgICAgIG1heE51bVJldHJ5OiAyLFxuICAgICAgICByZXRyeURlbGF5TXM6IDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXlNczogMFxuICAgICAgfSxcbiAgICAgIGVycm9yUmV0cnk6IHtcbiAgICAgICAgbWF4TnVtUmV0cnk6IDEsXG4gICAgICAgIHJldHJ5RGVsYXlNczogMTAwMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheU1zOiA4MDAwXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwbGF5bGlzdExvYWRQb2xpY3k6IHtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBtYXhUaW1lVG9GaXJzdEJ5dGVNczogMTAwMDAsXG4gICAgICBtYXhMb2FkVGltZU1zOiAyMDAwMCxcbiAgICAgIHRpbWVvdXRSZXRyeToge1xuICAgICAgICBtYXhOdW1SZXRyeTogMixcbiAgICAgICAgcmV0cnlEZWxheU1zOiAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDBcbiAgICAgIH0sXG4gICAgICBlcnJvclJldHJ5OiB7XG4gICAgICAgIG1heE51bVJldHJ5OiAyLFxuICAgICAgICByZXRyeURlbGF5TXM6IDEwMDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXlNczogODAwMFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZnJhZ0xvYWRQb2xpY3k6IHtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBtYXhUaW1lVG9GaXJzdEJ5dGVNczogMTAwMDAsXG4gICAgICBtYXhMb2FkVGltZU1zOiAxMjAwMDAsXG4gICAgICB0aW1lb3V0UmV0cnk6IHtcbiAgICAgICAgbWF4TnVtUmV0cnk6IDQsXG4gICAgICAgIHJldHJ5RGVsYXlNczogMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheU1zOiAwXG4gICAgICB9LFxuICAgICAgZXJyb3JSZXRyeToge1xuICAgICAgICBtYXhOdW1SZXRyeTogNixcbiAgICAgICAgcmV0cnlEZWxheU1zOiAxMDAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDgwMDBcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHN0ZWVyaW5nTWFuaWZlc3RMb2FkUG9saWN5OiB7XG4gICAgZGVmYXVsdDoge1xuICAgICAgbWF4VGltZVRvRmlyc3RCeXRlTXM6IDEwMDAwLFxuICAgICAgbWF4TG9hZFRpbWVNczogMjAwMDAsXG4gICAgICB0aW1lb3V0UmV0cnk6IHtcbiAgICAgICAgbWF4TnVtUmV0cnk6IDIsXG4gICAgICAgIHJldHJ5RGVsYXlNczogMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheU1zOiAwXG4gICAgICB9LFxuICAgICAgZXJyb3JSZXRyeToge1xuICAgICAgICBtYXhOdW1SZXRyeTogMSxcbiAgICAgICAgcmV0cnlEZWxheU1zOiAxMDAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDgwMDBcbiAgICAgIH1cbiAgICB9IFxuICB9LFxuICBpbnRlcnN0aXRpYWxBc3NldExpc3RMb2FkUG9saWN5OiB7XG4gICAgZGVmYXVsdDoge1xuICAgICAgbWF4VGltZVRvRmlyc3RCeXRlTXM6IDEwMDAwLFxuICAgICAgbWF4TG9hZFRpbWVNczogMzAwMDAsXG4gICAgICB0aW1lb3V0UmV0cnk6IHtcbiAgICAgICAgbWF4TnVtUmV0cnk6IDAsXG4gICAgICAgIHJldHJ5RGVsYXlNczogMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheU1zOiAwXG4gICAgICB9LFxuICAgICAgZXJyb3JSZXRyeToge1xuICAgICAgICBtYXhOdW1SZXRyeTogMCxcbiAgICAgICAgcmV0cnlEZWxheU1zOiAxMDAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDgwMDBcbiAgICAgIH1cbiAgICB9IFxuICB9LFxuICAvLyBUaGVzZSBkZWZhdWx0IHNldHRpbmdzIGFyZSBkZXByZWNhdGVkIGluIGZhdm9yIG9mIHRoZSBhYm92ZSBwb2xpY2llc1xuICAvLyBhbmQgYXJlIG1haW50YWluZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gIG1hbmlmZXN0TG9hZGluZ1RpbWVPdXQ6IDEwMDAwLFxuICBtYW5pZmVzdExvYWRpbmdNYXhSZXRyeTogMSxcbiAgbWFuaWZlc3RMb2FkaW5nUmV0cnlEZWxheTogMTAwMCxcbiAgbWFuaWZlc3RMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiA2NDAwMCxcbiAgbGV2ZWxMb2FkaW5nVGltZU91dDogMTAwMDAsXG4gIGxldmVsTG9hZGluZ01heFJldHJ5OiA0LFxuICBsZXZlbExvYWRpbmdSZXRyeURlbGF5OiAxMDAwLFxuICBsZXZlbExvYWRpbmdNYXhSZXRyeVRpbWVvdXQ6IDY0MDAwLFxuICBmcmFnTG9hZGluZ1RpbWVPdXQ6IDIwMDAwLFxuICBmcmFnTG9hZGluZ01heFJldHJ5OiA2LFxuICBmcmFnTG9hZGluZ1JldHJ5RGVsYXk6IDEwMDAsXG4gIGZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiA2NDAwMFxufSwgdGltZWxpbmVDb25maWcoKSksIHt9LCB7XG4gIHN1YnRpdGxlU3RyZWFtQ29udHJvbGxlcjogU3VidGl0bGVTdHJlYW1Db250cm9sbGVyICxcbiAgc3VidGl0bGVUcmFja0NvbnRyb2xsZXI6IFN1YnRpdGxlVHJhY2tDb250cm9sbGVyICxcbiAgdGltZWxpbmVDb250cm9sbGVyOiBUaW1lbGluZUNvbnRyb2xsZXIgLFxuICBhdWRpb1N0cmVhbUNvbnRyb2xsZXI6IEF1ZGlvU3RyZWFtQ29udHJvbGxlciAsXG4gIGF1ZGlvVHJhY2tDb250cm9sbGVyOiBBdWRpb1RyYWNrQ29udHJvbGxlciAsXG4gIGVtZUNvbnRyb2xsZXI6IEVNRUNvbnRyb2xsZXIgLFxuICBjbWNkQ29udHJvbGxlcjogQ01DRENvbnRyb2xsZXIgLFxuICBjb250ZW50U3RlZXJpbmdDb250cm9sbGVyOiBDb250ZW50U3RlZXJpbmdDb250cm9sbGVyICxcbiAgaW50ZXJzdGl0aWFsc0NvbnRyb2xsZXI6IEludGVyc3RpdGlhbHNDb250cm9sbGVyIFxufSk7XG5mdW5jdGlvbiB0aW1lbGluZUNvbmZpZygpIHtcbiAgcmV0dXJuIHtcbiAgICBjdWVIYW5kbGVyOiBDdWVzLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGVuYWJsZVdlYlZUVDogdHJ1ZSxcbiAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBlbmFibGVJTVNDMTogdHJ1ZSxcbiAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBlbmFibGVDRUE3MDhDYXB0aW9uczogdHJ1ZSxcbiAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBjYXB0aW9uc1RleHRUcmFjazFMYWJlbDogJ0VuZ2xpc2gnLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrMUxhbmd1YWdlQ29kZTogJ2VuJyxcbiAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBjYXB0aW9uc1RleHRUcmFjazJMYWJlbDogJ1NwYW5pc2gnLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrMkxhbmd1YWdlQ29kZTogJ2VzJyxcbiAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBjYXB0aW9uc1RleHRUcmFjazNMYWJlbDogJ1Vua25vd24gQ0MnLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrM0xhbmd1YWdlQ29kZTogJycsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgY2FwdGlvbnNUZXh0VHJhY2s0TGFiZWw6ICdVbmtub3duIENDJyxcbiAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBjYXB0aW9uc1RleHRUcmFjazRMYW5ndWFnZUNvZGU6ICcnLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIHJlbmRlclRleHRUcmFja3NOYXRpdmVseTogdHJ1ZVxuICB9O1xufVxuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gbWVyZ2VDb25maWcoZGVmYXVsdENvbmZpZywgdXNlckNvbmZpZywgbG9nZ2VyKSB7XG4gIGlmICgodXNlckNvbmZpZy5saXZlU3luY0R1cmF0aW9uQ291bnQgfHwgdXNlckNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQpICYmICh1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb24gfHwgdXNlckNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgaGxzLmpzIGNvbmZpZzogZG9uJ3QgbWl4IHVwIGxpdmVTeW5jRHVyYXRpb25Db3VudC9saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgYW5kIGxpdmVTeW5jRHVyYXRpb24vbGl2ZU1heExhdGVuY3lEdXJhdGlvblwiKTtcbiAgfVxuICBpZiAodXNlckNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgIT09IHVuZGVmaW5lZCAmJiAodXNlckNvbmZpZy5saXZlU3luY0R1cmF0aW9uQ291bnQgPT09IHVuZGVmaW5lZCB8fCB1c2VyQ29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCA8PSB1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgaGxzLmpzIGNvbmZpZzogXCJsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnRcIiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBcImxpdmVTeW5jRHVyYXRpb25Db3VudFwiJyk7XG4gIH1cbiAgaWYgKHVzZXJDb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiAhPT0gdW5kZWZpbmVkICYmICh1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb24gPT09IHVuZGVmaW5lZCB8fCB1c2VyQ29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gPD0gdXNlckNvbmZpZy5saXZlU3luY0R1cmF0aW9uKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBobHMuanMgY29uZmlnOiBcImxpdmVNYXhMYXRlbmN5RHVyYXRpb25cIiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBcImxpdmVTeW5jRHVyYXRpb25cIicpO1xuICB9XG4gIGNvbnN0IGRlZmF1bHRzQ29weSA9IGRlZXBDcHkoZGVmYXVsdENvbmZpZyk7XG5cbiAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCBkZXByZWNhdGVkIGNvbmZpZyB2YWx1ZXNcbiAgY29uc3QgZGVwcmVjYXRlZFNldHRpbmdUeXBlcyA9IFsnbWFuaWZlc3QnLCAnbGV2ZWwnLCAnZnJhZyddO1xuICBjb25zdCBkZXByZWNhdGVkU2V0dGluZ3MgPSBbJ1RpbWVPdXQnLCAnTWF4UmV0cnknLCAnUmV0cnlEZWxheScsICdNYXhSZXRyeVRpbWVvdXQnXTtcbiAgZGVwcmVjYXRlZFNldHRpbmdUeXBlcy5mb3JFYWNoKHR5cGUgPT4ge1xuICAgIGNvbnN0IHBvbGljeU5hbWUgPSBgJHt0eXBlID09PSAnbGV2ZWwnID8gJ3BsYXlsaXN0JyA6IHR5cGV9TG9hZFBvbGljeWA7XG4gICAgY29uc3QgcG9saWN5Tm90U2V0ID0gdXNlckNvbmZpZ1twb2xpY3lOYW1lXSA9PT0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHJlcG9ydCA9IFtdO1xuICAgIGRlcHJlY2F0ZWRTZXR0aW5ncy5mb3JFYWNoKHNldHRpbmcgPT4ge1xuICAgICAgY29uc3QgZGVwcmVjYXRlZFNldHRpbmcgPSBgJHt0eXBlfUxvYWRpbmcke3NldHRpbmd9YDtcbiAgICAgIGNvbnN0IHZhbHVlID0gdXNlckNvbmZpZ1tkZXByZWNhdGVkU2V0dGluZ107XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwb2xpY3lOb3RTZXQpIHtcbiAgICAgICAgcmVwb3J0LnB1c2goZGVwcmVjYXRlZFNldHRpbmcpO1xuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGRlZmF1bHRzQ29weVtwb2xpY3lOYW1lXS5kZWZhdWx0O1xuICAgICAgICB1c2VyQ29uZmlnW3BvbGljeU5hbWVdID0ge1xuICAgICAgICAgIGRlZmF1bHQ6IHNldHRpbmdzXG4gICAgICAgIH07XG4gICAgICAgIHN3aXRjaCAoc2V0dGluZykge1xuICAgICAgICAgIGNhc2UgJ1RpbWVPdXQnOlxuICAgICAgICAgICAgc2V0dGluZ3MubWF4TG9hZFRpbWVNcyA9IHZhbHVlO1xuICAgICAgICAgICAgc2V0dGluZ3MubWF4VGltZVRvRmlyc3RCeXRlTXMgPSB2YWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ01heFJldHJ5JzpcbiAgICAgICAgICAgIHNldHRpbmdzLmVycm9yUmV0cnkubWF4TnVtUmV0cnkgPSB2YWx1ZTtcbiAgICAgICAgICAgIHNldHRpbmdzLnRpbWVvdXRSZXRyeS5tYXhOdW1SZXRyeSA9IHZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnUmV0cnlEZWxheSc6XG4gICAgICAgICAgICBzZXR0aW5ncy5lcnJvclJldHJ5LnJldHJ5RGVsYXlNcyA9IHZhbHVlO1xuICAgICAgICAgICAgc2V0dGluZ3MudGltZW91dFJldHJ5LnJldHJ5RGVsYXlNcyA9IHZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnTWF4UmV0cnlUaW1lb3V0JzpcbiAgICAgICAgICAgIHNldHRpbmdzLmVycm9yUmV0cnkubWF4UmV0cnlEZWxheU1zID0gdmFsdWU7XG4gICAgICAgICAgICBzZXR0aW5ncy50aW1lb3V0UmV0cnkubWF4UmV0cnlEZWxheU1zID0gdmFsdWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChyZXBvcnQubGVuZ3RoKSB7XG4gICAgICBsb2dnZXIud2FybihgaGxzLmpzIGNvbmZpZzogXCIke3JlcG9ydC5qb2luKCdcIiwgXCInKX1cIiBzZXR0aW5nKHMpIGFyZSBkZXByZWNhdGVkLCB1c2UgXCIke3BvbGljeU5hbWV9XCI6ICR7c3RyaW5naWZ5KHVzZXJDb25maWdbcG9saWN5TmFtZV0pfWApO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZGVmYXVsdHNDb3B5KSwgdXNlckNvbmZpZyk7XG59XG5mdW5jdGlvbiBkZWVwQ3B5KG9iaikge1xuICBpZiAob2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgcmV0dXJuIG9iai5tYXAoZGVlcENweSk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IHtcbiAgICAgIHJlc3VsdFtrZXldID0gZGVlcENweShvYmpba2V5XSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIHt9KTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gZW5hYmxlU3RyZWFtaW5nTW9kZShjb25maWcsIGxvZ2dlcikge1xuICBjb25zdCBjdXJyZW50TG9hZGVyID0gY29uZmlnLmxvYWRlcjtcbiAgaWYgKGN1cnJlbnRMb2FkZXIgIT09IEZldGNoTG9hZGVyICYmIGN1cnJlbnRMb2FkZXIgIT09IFhockxvYWRlcikge1xuICAgIC8vIElmIGEgZGV2ZWxvcGVyIGhhcyBjb25maWd1cmVkIHRoZWlyIG93biBsb2FkZXIsIHJlc3BlY3QgdGhhdCBjaG9pY2VcbiAgICBsb2dnZXIubG9nKCdbY29uZmlnXTogQ3VzdG9tIGxvYWRlciBkZXRlY3RlZCwgY2Fubm90IGVuYWJsZSBwcm9ncmVzc2l2ZSBzdHJlYW1pbmcnKTtcbiAgICBjb25maWcucHJvZ3Jlc3NpdmUgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjYW5TdHJlYW1Qcm9ncmVzc2l2ZWx5ID0gZmV0Y2hTdXBwb3J0ZWQoKTtcbiAgICBpZiAoY2FuU3RyZWFtUHJvZ3Jlc3NpdmVseSkge1xuICAgICAgY29uZmlnLmxvYWRlciA9IEZldGNoTG9hZGVyO1xuICAgICAgY29uZmlnLnByb2dyZXNzaXZlID0gdHJ1ZTtcbiAgICAgIGNvbmZpZy5lbmFibGVTb2Z0d2FyZUFFUyA9IHRydWU7XG4gICAgICBsb2dnZXIubG9nKCdbY29uZmlnXTogUHJvZ3Jlc3NpdmUgc3RyZWFtaW5nIGVuYWJsZWQsIHVzaW5nIEZldGNoTG9hZGVyJyk7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IE1BWF9TVEFSVF9HQVBfSlVNUCA9IDIuMDtcbmNvbnN0IFNLSVBfQlVGRkVSX0hPTEVfU1RFUF9TRUNPTkRTID0gMC4xO1xuY29uc3QgU0tJUF9CVUZGRVJfUkFOR0VfU1RBUlQgPSAwLjA1O1xuY29uc3QgVElDS19JTlRFUlZBTCQxID0gMTAwO1xuY2xhc3MgR2FwQ29udHJvbGxlciBleHRlbmRzIFRhc2tMb29wIHtcbiAgY29uc3RydWN0b3IoaGxzLCBmcmFnbWVudFRyYWNrZXIpIHtcbiAgICBzdXBlcignZ2FwLWNvbnRyb2xsZXInLCBobHMubG9nZ2VyKTtcbiAgICB0aGlzLmhscyA9IG51bGw7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIgPSBudWxsO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMubWVkaWFTb3VyY2UgPSB2b2lkIDA7XG4gICAgdGhpcy5udWRnZVJldHJ5ID0gMDtcbiAgICB0aGlzLnN0YWxsUmVwb3J0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnN0YWxsZWQgPSBudWxsO1xuICAgIHRoaXMubW92ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnNlZWtpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmJ1ZmZlcmVkID0ge307XG4gICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICAgIHRoaXMuZW5kZWQgPSAwO1xuICAgIHRoaXMud2FpdGluZyA9IDA7XG4gICAgdGhpcy5vbk1lZGlhUGxheWluZyA9ICgpID0+IHtcbiAgICAgIHRoaXMuZW5kZWQgPSAwO1xuICAgICAgdGhpcy53YWl0aW5nID0gMDtcbiAgICB9O1xuICAgIHRoaXMub25NZWRpYVdhaXRpbmcgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RoaXMkbWVkaWE7XG4gICAgICBpZiAoKF90aGlzJG1lZGlhID0gdGhpcy5tZWRpYSkgIT0gbnVsbCAmJiBfdGhpcyRtZWRpYS5zZWVraW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMud2FpdGluZyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9O1xuICAgIHRoaXMub25NZWRpYUVuZGVkID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaGxzKSB7XG4gICAgICAgIHZhciBfdGhpcyRtZWRpYTI7XG4gICAgICAgIC8vIGVuZGVkIGlzIHNldCB3aGVuIHRyaWdnZXJpbmcgTUVESUFfRU5ERUQgc28gdGhhdCB3ZSBkbyBub3QgdHJpZ2dlciBpdCBhZ2FpbiBvbiBzdGFsbCBvciBvbiB0aWNrIHdpdGggbWVkaWEuZW5kZWRcbiAgICAgICAgdGhpcy5lbmRlZCA9ICgoX3RoaXMkbWVkaWEyID0gdGhpcy5tZWRpYSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG1lZGlhMi5jdXJyZW50VGltZSkgfHwgMTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTUVESUFfRU5ERUQsIHtcbiAgICAgICAgICBzdGFsbGVkOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyID0gZnJhZ21lbnRUcmFja2VyO1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoaGxzKSB7XG4gICAgICBobHMub24oRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0FQUEVOREVELCB0aGlzLm9uQnVmZmVyQXBwZW5kZWQsIHRoaXMpO1xuICAgIH1cbiAgfVxuICB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmIChobHMpIHtcbiAgICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfQVBQRU5ERUQsIHRoaXMub25CdWZmZXJBcHBlbmRlZCwgdGhpcyk7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHRoaXMubWVkaWEgPSB0aGlzLmhscyA9IHRoaXMuZnJhZ21lbnRUcmFja2VyID0gbnVsbDtcbiAgICB0aGlzLm1lZGlhU291cmNlID0gdW5kZWZpbmVkO1xuICB9XG4gIG9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMuc2V0SW50ZXJ2YWwoVElDS19JTlRFUlZBTCQxKTtcbiAgICB0aGlzLm1lZGlhU291cmNlID0gZGF0YS5tZWRpYVNvdXJjZTtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuICAgIGFkZEV2ZW50TGlzdGVuZXIobWVkaWEsICdwbGF5aW5nJywgdGhpcy5vbk1lZGlhUGxheWluZyk7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihtZWRpYSwgJ3dhaXRpbmcnLCB0aGlzLm9uTWVkaWFXYWl0aW5nKTtcbiAgICBhZGRFdmVudExpc3RlbmVyKG1lZGlhLCAnZW5kZWQnLCB0aGlzLm9uTWVkaWFFbmRlZCk7XG4gIH1cbiAgb25NZWRpYURldGFjaGluZyhldmVudCwgZGF0YSkge1xuICAgIHRoaXMuY2xlYXJJbnRlcnZhbCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIG1lZGlhXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKG1lZGlhLCAncGxheWluZycsIHRoaXMub25NZWRpYVBsYXlpbmcpO1xuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihtZWRpYSwgJ3dhaXRpbmcnLCB0aGlzLm9uTWVkaWFXYWl0aW5nKTtcbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIobWVkaWEsICdlbmRlZCcsIHRoaXMub25NZWRpYUVuZGVkKTtcbiAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLm1lZGlhU291cmNlID0gdW5kZWZpbmVkO1xuICB9XG4gIG9uQnVmZmVyQXBwZW5kZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLmJ1ZmZlcmVkID0gZGF0YS50aW1lUmFuZ2VzO1xuICB9XG4gIGdldCBoYXNCdWZmZXJlZCgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5idWZmZXJlZCkubGVuZ3RoID4gMDtcbiAgfVxuICB0aWNrKCkge1xuICAgIHZhciBfdGhpcyRtZWRpYTM7XG4gICAgaWYgKCEoKF90aGlzJG1lZGlhMyA9IHRoaXMubWVkaWEpICE9IG51bGwgJiYgX3RoaXMkbWVkaWEzLnJlYWR5U3RhdGUpIHx8ICF0aGlzLmhhc0J1ZmZlcmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gdGhpcy5tZWRpYS5jdXJyZW50VGltZTtcbiAgICB0aGlzLnBvbGwoY3VycmVudFRpbWUsIHRoaXMubGFzdEN1cnJlbnRUaW1lKTtcbiAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IGN1cnJlbnRUaW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgcGxheWhlYWQgaXMgc3R1Y2sgd2l0aGluIGEgZ2FwLCBhbmQgaWYgc28sIGF0dGVtcHRzIHRvIGZyZWUgaXQuXG4gICAqIEEgZ2FwIGlzIGFuIHVuYnVmZmVyZWQgcmFuZ2UgYmV0d2VlbiB0d28gYnVmZmVyZWQgcmFuZ2VzIChvciB0aGUgc3RhcnQgYW5kIHRoZSBmaXJzdCBidWZmZXJlZCByYW5nZSkuXG4gICAqXG4gICAqIEBwYXJhbSBsYXN0Q3VycmVudFRpbWUgLSBQcmV2aW91c2x5IHJlYWQgcGxheWhlYWQgcG9zaXRpb25cbiAgICovXG4gIHBvbGwoY3VycmVudFRpbWUsIGxhc3RDdXJyZW50VGltZSkge1xuICAgIHZhciBfdGhpcyRobHMsIF90aGlzJGhsczI7XG4gICAgY29uc3QgY29uZmlnID0gKF90aGlzJGhscyA9IHRoaXMuaGxzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkaGxzLmNvbmZpZztcbiAgICBpZiAoIWNvbmZpZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgaWYgKCFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzZWVraW5nXG4gICAgfSA9IG1lZGlhO1xuICAgIGNvbnN0IHNlZWtlZCA9IHRoaXMuc2Vla2luZyAmJiAhc2Vla2luZztcbiAgICBjb25zdCBiZWdpblNlZWsgPSAhdGhpcy5zZWVraW5nICYmIHNlZWtpbmc7XG4gICAgY29uc3QgcGF1c2VkRW5kZWRPckhhbHRlZCA9IG1lZGlhLnBhdXNlZCAmJiAhc2Vla2luZyB8fCBtZWRpYS5lbmRlZCB8fCBtZWRpYS5wbGF5YmFja1JhdGUgPT09IDA7XG4gICAgdGhpcy5zZWVraW5nID0gc2Vla2luZztcblxuICAgIC8vIFRoZSBwbGF5aGVhZCBpcyBtb3ZpbmcsIG5vLW9wXG4gICAgaWYgKGN1cnJlbnRUaW1lICE9PSBsYXN0Q3VycmVudFRpbWUpIHtcbiAgICAgIGlmIChsYXN0Q3VycmVudFRpbWUpIHtcbiAgICAgICAgdGhpcy5lbmRlZCA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLm1vdmVkID0gdHJ1ZTtcbiAgICAgIGlmICghc2Vla2luZykge1xuICAgICAgICB0aGlzLm51ZGdlUmV0cnkgPSAwO1xuICAgICAgICAvLyBXaGVuIGNyb3NzaW5nIGJldHdlZW4gYnVmZmVyZWQgdmlkZW8gdGltZSByYW5nZXMsIGJ1dCBub3QgYXVkaW8sIGZsdXNoIHBpcGVsaW5lIHdpdGggc2VlayAoQ2hyb21lKVxuICAgICAgICBpZiAoY29uZmlnLm51ZGdlT25WaWRlb0hvbGUgJiYgIXBhdXNlZEVuZGVkT3JIYWx0ZWQgJiYgY3VycmVudFRpbWUgPiBsYXN0Q3VycmVudFRpbWUpIHtcbiAgICAgICAgICB0aGlzLm51ZGdlT25WaWRlb0hvbGUoY3VycmVudFRpbWUsIGxhc3RDdXJyZW50VGltZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLndhaXRpbmcgPT09IDApIHtcbiAgICAgICAgdGhpcy5zdGFsbFJlc29sdmVkKGN1cnJlbnRUaW1lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDbGVhciBzdGFsbGVkIHN0YXRlIHdoZW4gYmVnaW5uaW5nIG9yIGZpbmlzaGluZyBzZWVraW5nIHNvIHRoYXQgd2UgZG9uJ3QgcmVwb3J0IHN0YWxscyBjb21pbmcgb3V0IG9mIGEgc2Vla1xuICAgIGlmIChiZWdpblNlZWsgfHwgc2Vla2VkKSB7XG4gICAgICBpZiAoc2Vla2VkKSB7XG4gICAgICAgIHRoaXMuc3RhbGxSZXNvbHZlZChjdXJyZW50VGltZSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVGhlIHBsYXloZWFkIHNob3VsZCBub3QgYmUgbW92aW5nXG4gICAgaWYgKHBhdXNlZEVuZGVkT3JIYWx0ZWQpIHtcbiAgICAgIHRoaXMubnVkZ2VSZXRyeSA9IDA7XG4gICAgICB0aGlzLnN0YWxsUmVzb2x2ZWQoY3VycmVudFRpbWUpO1xuICAgICAgLy8gRmlyZSBNRURJQV9FTkRFRCB0byB3b3JrYXJvdW5kIGV2ZW50IG5vdCBiZWluZyBkaXNwYXRjaGVkIGJ5IGJyb3dzZXJcbiAgICAgIGlmICghdGhpcy5lbmRlZCAmJiBtZWRpYS5lbmRlZCAmJiB0aGlzLmhscykge1xuICAgICAgICB0aGlzLmVuZGVkID0gY3VycmVudFRpbWUgfHwgMTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTUVESUFfRU5ERUQsIHtcbiAgICAgICAgICBzdGFsbGVkOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQobWVkaWEpLmxlbmd0aCkge1xuICAgICAgdGhpcy5udWRnZVJldHJ5ID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBSZXNvbHZlIHN0YWxscyBhdCBidWZmZXIgaG9sZXMgdXNpbmcgdGhlIG1haW4gYnVmZmVyLCB3aG9zZSByYW5nZXMgYXJlIHRoZSBpbnRlcnNlY3Rpb25zIG9mIHRoZSBBL1Ygc291cmNlYnVmZmVyc1xuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhtZWRpYSwgY3VycmVudFRpbWUsIDApO1xuICAgIGNvbnN0IG5leHRTdGFydCA9IGJ1ZmZlckluZm8ubmV4dFN0YXJ0IHx8IDA7XG4gICAgY29uc3QgZnJhZ21lbnRUcmFja2VyID0gdGhpcy5mcmFnbWVudFRyYWNrZXI7XG4gICAgaWYgKHNlZWtpbmcgJiYgZnJhZ21lbnRUcmFja2VyICYmIHRoaXMuaGxzKSB7XG4gICAgICAvLyBJcyB0aGVyZSBhIGZyYWdtZW50IGxvYWRpbmcvcGFyc2luZy9hcHBlbmRpbmcgYmVmb3JlIGN1cnJlbnRUaW1lP1xuICAgICAgY29uc3QgaW5GbGlnaHREZXBlbmRlbmN5ID0gZ2V0SW5GbGlnaHREZXBlbmRlbmN5KHRoaXMuaGxzLmluRmxpZ2h0RnJhZ21lbnRzLCBjdXJyZW50VGltZSk7XG5cbiAgICAgIC8vIFdhaXRpbmcgZm9yIHNlZWtpbmcgaW4gYSBidWZmZXJlZCByYW5nZSB0byBjb21wbGV0ZVxuICAgICAgY29uc3QgaGFzRW5vdWdoQnVmZmVyID0gYnVmZmVySW5mby5sZW4gPiBNQVhfU1RBUlRfR0FQX0pVTVA7XG4gICAgICAvLyBOZXh0IGJ1ZmZlcmVkIHJhbmdlIGlzIHRvbyBmYXIgYWhlYWQgdG8ganVtcCB0byB3aGlsZSBzdGlsbCBzZWVraW5nXG4gICAgICBjb25zdCBub0J1ZmZlckhvbGUgPSAhbmV4dFN0YXJ0IHx8IGluRmxpZ2h0RGVwZW5kZW5jeSB8fCBuZXh0U3RhcnQgLSBjdXJyZW50VGltZSA+IE1BWF9TVEFSVF9HQVBfSlVNUCAmJiAhZnJhZ21lbnRUcmFja2VyLmdldFBhcnRpYWxGcmFnbWVudChjdXJyZW50VGltZSk7XG4gICAgICBpZiAoaGFzRW5vdWdoQnVmZmVyIHx8IG5vQnVmZmVySG9sZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBSZXNldCBtb3ZlZCBzdGF0ZSB3aGVuIHNlZWtpbmcgdG8gYSBwb2ludCBpbiBvciBiZWZvcmUgYSBnYXAvaG9sZVxuICAgICAgdGhpcy5tb3ZlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFNraXAgc3RhcnQgZ2FwcyBpZiB3ZSBoYXZlbid0IHBsYXllZCwgYnV0IHRoZSBsYXN0IHBvbGwgZGV0ZWN0ZWQgdGhlIHN0YXJ0IG9mIGEgc3RhbGxcbiAgICAvLyBUaGUgYWRkaXRpb24gcG9sbCBnaXZlcyB0aGUgYnJvd3NlciBhIGNoYW5jZSB0byBqdW1wIHRoZSBnYXAgZm9yIHVzXG4gICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gKF90aGlzJGhsczIgPSB0aGlzLmhscykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGhsczIubGF0ZXN0TGV2ZWxEZXRhaWxzO1xuICAgIGlmICghdGhpcy5tb3ZlZCAmJiB0aGlzLnN0YWxsZWQgIT09IG51bGwgJiYgZnJhZ21lbnRUcmFja2VyKSB7XG4gICAgICAvLyBUaGVyZSBpcyBubyBwbGF5YWJsZSBidWZmZXIgKHNlZWtlZCwgd2FpdGluZyBmb3IgYnVmZmVyKVxuICAgICAgY29uc3QgaXNCdWZmZXJlZCA9IGJ1ZmZlckluZm8ubGVuID4gMDtcbiAgICAgIGlmICghaXNCdWZmZXJlZCAmJiAhbmV4dFN0YXJ0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIEp1bXAgc3RhcnQgZ2FwcyB3aXRoaW4ganVtcCB0aHJlc2hvbGRcbiAgICAgIGNvbnN0IHN0YXJ0SnVtcCA9IE1hdGgubWF4KG5leHRTdGFydCwgYnVmZmVySW5mby5zdGFydCB8fCAwKSAtIGN1cnJlbnRUaW1lO1xuXG4gICAgICAvLyBXaGVuIGpvaW5pbmcgYSBsaXZlIHN0cmVhbSB3aXRoIGF1ZGlvIHRyYWNrcywgYWNjb3VudCBmb3IgbGl2ZSBwbGF5bGlzdCB3aW5kb3cgc2xpZGluZyBieSBhbGxvd2luZ1xuICAgICAgLy8gYSBsYXJnZXIganVtcCBvdmVyIHN0YXJ0IGdhcHMgY2F1c2VkIGJ5IHRoZSBhdWRpby1zdHJlYW0tY29udHJvbGxlciBidWZmZXJpbmcgYSBzdGFydCBmcmFnbWVudFxuICAgICAgLy8gdGhhdCBiZWdpbnMgb3ZlciAxIHRhcmdldCBkdXJhdGlvbiBhZnRlciB0aGUgdmlkZW8gc3RhcnQgcG9zaXRpb24uXG4gICAgICBjb25zdCBpc0xpdmUgPSAhIShsZXZlbERldGFpbHMgIT0gbnVsbCAmJiBsZXZlbERldGFpbHMubGl2ZSk7XG4gICAgICBjb25zdCBtYXhTdGFydEdhcEp1bXAgPSBpc0xpdmUgPyBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb24gKiAyIDogTUFYX1NUQVJUX0dBUF9KVU1QO1xuICAgICAgY29uc3QgcGFydGlhbE9yR2FwID0gZnJhZ21lbnRUcmFja2VyLmdldFBhcnRpYWxGcmFnbWVudChjdXJyZW50VGltZSk7XG4gICAgICBpZiAoc3RhcnRKdW1wID4gMCAmJiAoc3RhcnRKdW1wIDw9IG1heFN0YXJ0R2FwSnVtcCB8fCBwYXJ0aWFsT3JHYXApKSB7XG4gICAgICAgIGlmICghbWVkaWEucGF1c2VkKSB7XG4gICAgICAgICAgdGhpcy5fdHJ5U2tpcEJ1ZmZlckhvbGUocGFydGlhbE9yR2FwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3RhcnQgdHJhY2tpbmcgc3RhbGwgdGltZVxuICAgIGNvbnN0IGRldGVjdFN0YWxsV2l0aEN1cnJlbnRUaW1lTXMgPSBjb25maWcuZGV0ZWN0U3RhbGxXaXRoQ3VycmVudFRpbWVNcztcbiAgICBjb25zdCB0bm93ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCB0V2FpdGluZyA9IHRoaXMud2FpdGluZztcbiAgICBsZXQgc3RhbGxlZCA9IHRoaXMuc3RhbGxlZDtcbiAgICBpZiAoc3RhbGxlZCA9PT0gbnVsbCkge1xuICAgICAgLy8gVXNlIHRpbWUgb2YgcmVjZW50IFwid2FpdGluZ1wiIGV2ZW50XG4gICAgICBpZiAodFdhaXRpbmcgPiAwICYmIHRub3cgLSB0V2FpdGluZyA8IGRldGVjdFN0YWxsV2l0aEN1cnJlbnRUaW1lTXMpIHtcbiAgICAgICAgc3RhbGxlZCA9IHRoaXMuc3RhbGxlZCA9IHRXYWl0aW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGFsbGVkID0gdG5vdztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzdGFsbGVkRHVyYXRpb24gPSB0bm93IC0gc3RhbGxlZDtcbiAgICBpZiAoIXNlZWtpbmcgJiYgKHN0YWxsZWREdXJhdGlvbiA+PSBkZXRlY3RTdGFsbFdpdGhDdXJyZW50VGltZU1zIHx8IHRXYWl0aW5nKSAmJiB0aGlzLmhscykge1xuICAgICAgdmFyIF90aGlzJG1lZGlhU291cmNlO1xuICAgICAgLy8gRGlzcGF0Y2ggTUVESUFfRU5ERUQgd2hlbiBtZWRpYS5lbmRlZC9lbmRlZCBldmVudCBpcyBub3Qgc2lnbmFsbGVkIGF0IGVuZCBvZiBzdHJlYW1cbiAgICAgIGlmICgoKF90aGlzJG1lZGlhU291cmNlID0gdGhpcy5tZWRpYVNvdXJjZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG1lZGlhU291cmNlLnJlYWR5U3RhdGUpID09PSAnZW5kZWQnICYmICEobGV2ZWxEZXRhaWxzICE9IG51bGwgJiYgbGV2ZWxEZXRhaWxzLmxpdmUpICYmIE1hdGguYWJzKGN1cnJlbnRUaW1lIC0gKChsZXZlbERldGFpbHMgPT0gbnVsbCA/IHZvaWQgMCA6IGxldmVsRGV0YWlscy5lZGdlKSB8fCAwKSkgPCAxKSB7XG4gICAgICAgIGlmICh0aGlzLmVuZGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW5kZWQgPSBjdXJyZW50VGltZSB8fCAxO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5NRURJQV9FTkRFRCwge1xuICAgICAgICAgIHN0YWxsZWQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFJlcG9ydCBzdGFsbGluZyBhZnRlciB0cnlpbmcgdG8gZml4XG4gICAgICB0aGlzLl9yZXBvcnRTdGFsbChidWZmZXJJbmZvKTtcbiAgICAgIGlmICghdGhpcy5tZWRpYSB8fCAhdGhpcy5obHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBidWZmZXJlZFdpdGhIb2xlcyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKG1lZGlhLCBjdXJyZW50VGltZSwgY29uZmlnLm1heEJ1ZmZlckhvbGUpO1xuICAgIHRoaXMuX3RyeUZpeEJ1ZmZlclN0YWxsKGJ1ZmZlcmVkV2l0aEhvbGVzLCBzdGFsbGVkRHVyYXRpb24sIGN1cnJlbnRUaW1lKTtcbiAgfVxuICBzdGFsbFJlc29sdmVkKGN1cnJlbnRUaW1lKSB7XG4gICAgY29uc3Qgc3RhbGxlZCA9IHRoaXMuc3RhbGxlZDtcbiAgICBpZiAoc3RhbGxlZCAmJiB0aGlzLmhscykge1xuICAgICAgdGhpcy5zdGFsbGVkID0gbnVsbDtcbiAgICAgIC8vIFRoZSBwbGF5aGVhZCBpcyBub3cgbW92aW5nLCBidXQgd2FzIHByZXZpb3VzbHkgc3RhbGxlZFxuICAgICAgaWYgKHRoaXMuc3RhbGxSZXBvcnRlZCkge1xuICAgICAgICBjb25zdCBzdGFsbGVkRHVyYXRpb24gPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpIC0gc3RhbGxlZDtcbiAgICAgICAgdGhpcy5sb2coYHBsYXliYWNrIG5vdCBzdHVjayBhbnltb3JlIEAke2N1cnJlbnRUaW1lfSwgYWZ0ZXIgJHtNYXRoLnJvdW5kKHN0YWxsZWREdXJhdGlvbil9bXNgKTtcbiAgICAgICAgdGhpcy5zdGFsbFJlcG9ydGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMud2FpdGluZyA9IDA7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLlNUQUxMX1JFU09MVkVELCB7fSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG51ZGdlT25WaWRlb0hvbGUoY3VycmVudFRpbWUsIGxhc3RDdXJyZW50VGltZSkge1xuICAgIHZhciBfdGhpcyRidWZmZXJlZCRhdWRpbztcbiAgICAvLyBDaHJvbWUgd2lsbCBwbGF5IG9uZSBzZWNvbmQgcGFzdCBhIGhvbGUgaW4gdmlkZW8gYnVmZmVyZWQgdGltZSByYW5nZXMgd2l0aG91dCByZW5kZXJpbmcgYW55IHZpZGVvIGZyb20gdGhlIHN1YnNlcXVlbnQgcmFuZ2UgYW5kIHRoZW4gc3RhbGwgYXMgbG9uZyBhcyBhdWRpbyBpcyBidWZmZXJlZDpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvNTYzMVxuICAgIC8vIGh0dHBzOi8vaXNzdWVzLmNocm9taXVtLm9yZy9pc3N1ZXMvNDAyODA2MTMjY29tbWVudDEwXG4gICAgLy8gRGV0ZWN0IHRoZSBwb3RlbnRpYWwgZm9yIHRoaXMgc2l0dWF0aW9uIGFuZCBwcm9hY3RpdmVseSBzZWVrIHRvIGZsdXNoIHRoZSB2aWRlbyBwaXBlbGluZSBvbmNlIHRoZSBwbGF5aGVhZCBwYXNzZXMgdGhlIHN0YXJ0IG9mIHRoZSB2aWRlbyBob2xlLlxuICAgIC8vIFdoZW4gdGhlcmUgYXJlIGF1ZGlvIGFuZCB2aWRlbyBidWZmZXJzIGFuZCBjdXJyZW50VGltZSBpcyBwYXN0IHRoZSBlbmQgb2YgdGhlIGZpcnN0IHZpZGVvIGJ1ZmZlcmVkIHJhbmdlLi4uXG4gICAgY29uc3QgdmlkZW9Tb3VyY2VCdWZmZXJlZCA9IHRoaXMuYnVmZmVyZWQudmlkZW87XG4gICAgaWYgKHRoaXMuaGxzICYmIHRoaXMubWVkaWEgJiYgdGhpcy5mcmFnbWVudFRyYWNrZXIgJiYgKF90aGlzJGJ1ZmZlcmVkJGF1ZGlvID0gdGhpcy5idWZmZXJlZC5hdWRpbykgIT0gbnVsbCAmJiBfdGhpcyRidWZmZXJlZCRhdWRpby5sZW5ndGggJiYgdmlkZW9Tb3VyY2VCdWZmZXJlZCAmJiB2aWRlb1NvdXJjZUJ1ZmZlcmVkLmxlbmd0aCA+IDEgJiYgY3VycmVudFRpbWUgPiB2aWRlb1NvdXJjZUJ1ZmZlcmVkLmVuZCgwKSkge1xuICAgICAgLy8gYW5kIGF1ZGlvIGlzIGJ1ZmZlcmVkIGF0IHRoZSBwbGF5aGVhZFxuICAgICAgY29uc3QgYXVkaW9CdWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlcmVkSW5mbyhCdWZmZXJIZWxwZXIudGltZVJhbmdlc1RvQXJyYXkodGhpcy5idWZmZXJlZC5hdWRpbyksIGN1cnJlbnRUaW1lLCAwKTtcbiAgICAgIGlmIChhdWRpb0J1ZmZlckluZm8ubGVuID4gMSAmJiBsYXN0Q3VycmVudFRpbWUgPj0gYXVkaW9CdWZmZXJJbmZvLnN0YXJ0KSB7XG4gICAgICAgIGNvbnN0IHZpZGVvVGltZXMgPSBCdWZmZXJIZWxwZXIudGltZVJhbmdlc1RvQXJyYXkodmlkZW9Tb3VyY2VCdWZmZXJlZCk7XG4gICAgICAgIGNvbnN0IGxhc3RCdWZmZXJlZEluZGV4ID0gQnVmZmVySGVscGVyLmJ1ZmZlcmVkSW5mbyh2aWRlb1RpbWVzLCBsYXN0Q3VycmVudFRpbWUsIDApLmJ1ZmZlcmVkSW5kZXg7XG4gICAgICAgIC8vIG51ZGdlIHdoZW4gY3Jvc3NpbmcgaW50byBhbm90aGVyIHZpZGVvIGJ1ZmZlcmVkIHJhbmdlIChob2xlKS5cbiAgICAgICAgaWYgKGxhc3RCdWZmZXJlZEluZGV4ID4gLTEgJiYgbGFzdEJ1ZmZlcmVkSW5kZXggPCB2aWRlb1RpbWVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBjb25zdCBidWZmZXJlZEluZGV4ID0gQnVmZmVySGVscGVyLmJ1ZmZlcmVkSW5mbyh2aWRlb1RpbWVzLCBjdXJyZW50VGltZSwgMCkuYnVmZmVyZWRJbmRleDtcbiAgICAgICAgICBjb25zdCBob2xlU3RhcnQgPSB2aWRlb1RpbWVzW2xhc3RCdWZmZXJlZEluZGV4XS5lbmQ7XG4gICAgICAgICAgY29uc3QgaG9sZUVuZCA9IHZpZGVvVGltZXNbbGFzdEJ1ZmZlcmVkSW5kZXggKyAxXS5zdGFydDtcbiAgICAgICAgICBpZiAoKGJ1ZmZlcmVkSW5kZXggPT09IC0xIHx8IGJ1ZmZlcmVkSW5kZXggPiBsYXN0QnVmZmVyZWRJbmRleCkgJiYgaG9sZUVuZCAtIGhvbGVTdGFydCA8IDEgJiZcbiAgICAgICAgICAvLyBgbWF4QnVmZmVySG9sZWAgbWF5IGJlIHRvbyBzbWFsbCBhbmQgc2V0dGluZyBpdCB0byAwIHNob3VsZCBub3QgZGlzYWJsZSB0aGlzIGZlYXR1cmVcbiAgICAgICAgICBjdXJyZW50VGltZSAtIGhvbGVTdGFydCA8IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBudWRnaW5nIHBsYXloZWFkIHRvIGZsdXNoIHBpcGVsaW5lIGFmdGVyIHZpZGVvIGhvbGUuIGN1cnJlbnRUaW1lOiAke2N1cnJlbnRUaW1lfSBob2xlOiAke2hvbGVTdGFydH0gLT4gJHtob2xlRW5kfSBidWZmZXJlZCBpbmRleDogJHtidWZmZXJlZEluZGV4fWApO1xuICAgICAgICAgICAgdGhpcy53YXJuKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgLy8gTWFnaWMgbnVtYmVyIHRvIGZsdXNoIHRoZSBwaXBlbGluZSB3aXRob3V0IGludGVydXB0aW9uIHRvIGF1ZGlvIHBsYXliYWNrOlxuICAgICAgICAgICAgdGhpcy5tZWRpYS5jdXJyZW50VGltZSArPSAwLjAwMDAwMTtcbiAgICAgICAgICAgIGNvbnN0IGZyYWcgPSB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRQYXJ0aWFsRnJhZ21lbnQoY3VycmVudFRpbWUpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyh0aGlzLm1lZGlhLCBjdXJyZW50VGltZSwgMCk7XG4gICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX1NFRUtfT1ZFUl9IT0xFLFxuICAgICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICByZWFzb246IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgIGJ1ZmZlcjogYnVmZmVySW5mby5sZW4sXG4gICAgICAgICAgICAgIGJ1ZmZlckluZm9cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlY3RzIGFuZCBhdHRlbXB0cyB0byBmaXgga25vd24gYnVmZmVyIHN0YWxsaW5nIGlzc3Vlcy5cbiAgICogQHBhcmFtIGJ1ZmZlckluZm8gLSBUaGUgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBidWZmZXIuXG4gICAqIEBwYXJhbSBzdGFsbGVkRHVyYXRpb25NcyAtIFRoZSBhbW91bnQgb2YgdGltZSBIbHMuanMgaGFzIGJlZW4gc3RhbGxpbmcgZm9yLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3RyeUZpeEJ1ZmZlclN0YWxsKGJ1ZmZlckluZm8sIHN0YWxsZWREdXJhdGlvbk1zLCBjdXJyZW50VGltZSkge1xuICAgIHZhciBfdGhpcyRobHMzLCBfdGhpcyRobHM0O1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWdtZW50VHJhY2tlcixcbiAgICAgIG1lZGlhXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgY29uZmlnID0gKF90aGlzJGhsczMgPSB0aGlzLmhscykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGhsczMuY29uZmlnO1xuICAgIGlmICghbWVkaWEgfHwgIWZyYWdtZW50VHJhY2tlciB8fCAhY29uZmlnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IChfdGhpcyRobHM0ID0gdGhpcy5obHMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRobHM0LmxhdGVzdExldmVsRGV0YWlscztcbiAgICBjb25zdCBwYXJ0aWFsID0gZnJhZ21lbnRUcmFja2VyLmdldFBhcnRpYWxGcmFnbWVudChjdXJyZW50VGltZSk7XG4gICAgaWYgKHBhcnRpYWwgfHwgbGV2ZWxEZXRhaWxzICE9IG51bGwgJiYgbGV2ZWxEZXRhaWxzLmxpdmUgJiYgY3VycmVudFRpbWUgPCBsZXZlbERldGFpbHMuZnJhZ21lbnRTdGFydCkge1xuICAgICAgLy8gVHJ5IHRvIHNraXAgb3ZlciB0aGUgYnVmZmVyIGhvbGUgY2F1c2VkIGJ5IGEgcGFydGlhbCBmcmFnbWVudFxuICAgICAgLy8gVGhpcyBtZXRob2QgaXNuJ3QgbGltaXRlZCBieSB0aGUgc2l6ZSBvZiB0aGUgZ2FwIGJldHdlZW4gYnVmZmVyZWQgcmFuZ2VzXG4gICAgICBjb25zdCB0YXJnZXRUaW1lID0gdGhpcy5fdHJ5U2tpcEJ1ZmZlckhvbGUocGFydGlhbCk7XG4gICAgICAvLyB3ZSByZXR1cm4gaGVyZSBpbiB0aGlzIGNhc2UsIG1lYW5pbmdcbiAgICAgIC8vIHRoZSBicmFuY2ggYmVsb3cgb25seSBleGVjdXRlcyB3aGVuIHdlIGhhdmVuJ3Qgc2Vla2VkIHRvIGEgbmV3IHBvc2l0aW9uXG4gICAgICBpZiAodGFyZ2V0VGltZSB8fCAhdGhpcy5tZWRpYSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgd2UgaGF2ZW4ndCBoYWQgdG8gc2tpcCBvdmVyIGEgYnVmZmVyIGhvbGUgb2YgYSBwYXJ0aWFsIGZyYWdtZW50XG4gICAgLy8gd2UgbWF5IGp1c3QgaGF2ZSB0byBcIm51ZGdlXCIgdGhlIHBsYXlsaXN0IGFzIHRoZSBicm93c2VyIGRlY29kaW5nL3JlbmRlcmluZyBlbmdpbmVcbiAgICAvLyBuZWVkcyB0byBjcm9zcyBzb21lIHNvcnQgb2YgdGhyZXNob2xkIGNvdmVyaW5nIGFsbCBzb3VyY2UtYnVmZmVycyBjb250ZW50XG4gICAgLy8gdG8gc3RhcnQgcGxheWluZyBwcm9wZXJseS5cbiAgICBjb25zdCBidWZmZXJlZFJhbmdlcyA9IGJ1ZmZlckluZm8uYnVmZmVyZWQ7XG4gICAgY29uc3QgYWRqYWNlbnRUcmF2ZXJzYWwgPSB0aGlzLmFkamFjZW50VHJhdmVyc2FsKGJ1ZmZlckluZm8sIGN1cnJlbnRUaW1lKTtcbiAgICBpZiAoKGJ1ZmZlcmVkUmFuZ2VzICYmIGJ1ZmZlcmVkUmFuZ2VzLmxlbmd0aCA+IDEgJiYgYnVmZmVySW5mby5sZW4gPiBjb25maWcubWF4QnVmZmVySG9sZSB8fCBidWZmZXJJbmZvLm5leHRTdGFydCAmJiAoYnVmZmVySW5mby5uZXh0U3RhcnQgLSBjdXJyZW50VGltZSA8IGNvbmZpZy5tYXhCdWZmZXJIb2xlIHx8IGFkamFjZW50VHJhdmVyc2FsKSkgJiYgKHN0YWxsZWREdXJhdGlvbk1zID4gY29uZmlnLmhpZ2hCdWZmZXJXYXRjaGRvZ1BlcmlvZCAqIDEwMDAgfHwgdGhpcy53YWl0aW5nKSkge1xuICAgICAgdGhpcy53YXJuKCdUcnlpbmcgdG8gbnVkZ2UgcGxheWhlYWQgb3ZlciBidWZmZXItaG9sZScpO1xuICAgICAgLy8gVHJ5IHRvIG51ZGdlIGN1cnJlbnRUaW1lIG92ZXIgYSBidWZmZXIgaG9sZSBpZiB3ZSd2ZSBiZWVuIHN0YWxsaW5nIGZvciB0aGUgY29uZmlndXJlZCBhbW91bnQgb2Ygc2Vjb25kc1xuICAgICAgLy8gV2Ugb25seSB0cnkgdG8ganVtcCB0aGUgaG9sZSBpZiBpdCdzIHVuZGVyIHRoZSBjb25maWd1cmVkIHNpemVcbiAgICAgIHRoaXMuX3RyeU51ZGdlQnVmZmVyKGJ1ZmZlckluZm8pO1xuICAgIH1cbiAgfVxuICBhZGphY2VudFRyYXZlcnNhbChidWZmZXJJbmZvLCBjdXJyZW50VGltZSkge1xuICAgIGNvbnN0IGZyYWdtZW50VHJhY2tlciA9IHRoaXMuZnJhZ21lbnRUcmFja2VyO1xuICAgIGNvbnN0IG5leHRTdGFydCA9IGJ1ZmZlckluZm8ubmV4dFN0YXJ0O1xuICAgIGlmIChmcmFnbWVudFRyYWNrZXIgJiYgbmV4dFN0YXJ0KSB7XG4gICAgICBjb25zdCBjdXJyZW50ID0gZnJhZ21lbnRUcmFja2VyLmdldEZyYWdBdFBvcyhjdXJyZW50VGltZSwgUGxheWxpc3RMZXZlbFR5cGUuTUFJTik7XG4gICAgICBjb25zdCBuZXh0ID0gZnJhZ21lbnRUcmFja2VyLmdldEZyYWdBdFBvcyhuZXh0U3RhcnQsIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pO1xuICAgICAgaWYgKGN1cnJlbnQgJiYgbmV4dCkge1xuICAgICAgICByZXR1cm4gbmV4dC5zbiAtIGN1cnJlbnQuc24gPCAyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogVHJpZ2dlcnMgYSBCVUZGRVJfU1RBTExFRF9FUlJPUiBldmVudCwgYnV0IG9ubHkgb25jZSBwZXIgc3RhbGwgcGVyaW9kLlxuICAgKiBAcGFyYW0gYnVmZmVyTGVuIC0gVGhlIHBsYXloZWFkIGRpc3RhbmNlIGZyb20gdGhlIGVuZCBvZiB0aGUgY3VycmVudCBidWZmZXIgc2VnbWVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZXBvcnRTdGFsbChidWZmZXJJbmZvKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzLFxuICAgICAgbWVkaWEsXG4gICAgICBzdGFsbFJlcG9ydGVkLFxuICAgICAgc3RhbGxlZFxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghc3RhbGxSZXBvcnRlZCAmJiBzdGFsbGVkICE9PSBudWxsICYmIG1lZGlhICYmIGhscykge1xuICAgICAgLy8gUmVwb3J0IHN0YWxsZWQgZXJyb3Igb25jZVxuICAgICAgdGhpcy5zdGFsbFJlcG9ydGVkID0gdHJ1ZTtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBQbGF5YmFjayBzdGFsbGluZyBhdCBAJHttZWRpYS5jdXJyZW50VGltZX0gZHVlIHRvIGxvdyBidWZmZXIgKCR7c3RyaW5naWZ5KGJ1ZmZlckluZm8pfSlgKTtcbiAgICAgIHRoaXMud2FybihlcnJvci5tZXNzYWdlKTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX1NUQUxMRURfRVJST1IsXG4gICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGJ1ZmZlcjogYnVmZmVySW5mby5sZW4sXG4gICAgICAgIGJ1ZmZlckluZm8sXG4gICAgICAgIHN0YWxsZWQ6IHtcbiAgICAgICAgICBzdGFydDogc3RhbGxlZFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gZml4IGJ1ZmZlciBzdGFsbHMgYnkganVtcGluZyBvdmVyIGtub3duIGdhcHMgY2F1c2VkIGJ5IHBhcnRpYWwgZnJhZ21lbnRzXG4gICAqIEBwYXJhbSBwYXJ0aWFsIC0gVGhlIHBhcnRpYWwgZnJhZ21lbnQgZm91bmQgYXQgdGhlIGN1cnJlbnQgdGltZSAod2hlcmUgcGxheWJhY2sgaXMgc3RhbGxpbmcpLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3RyeVNraXBCdWZmZXJIb2xlKHBhcnRpYWwpIHtcbiAgICB2YXIgX3RoaXMkaGxzNTtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnbWVudFRyYWNrZXIsXG4gICAgICBtZWRpYVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGNvbmZpZyA9IChfdGhpcyRobHM1ID0gdGhpcy5obHMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRobHM1LmNvbmZpZztcbiAgICBpZiAoIW1lZGlhIHx8ICFmcmFnbWVudFRyYWNrZXIgfHwgIWNvbmZpZykge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgY3VycmVudFRpbWUgaXMgYmV0d2VlbiB1bmJ1ZmZlcmVkIHJlZ2lvbnMgb2YgcGFydGlhbCBmcmFnbWVudHNcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhtZWRpYSwgY3VycmVudFRpbWUsIDApO1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lIDwgYnVmZmVySW5mby5zdGFydCA/IGJ1ZmZlckluZm8uc3RhcnQgOiBidWZmZXJJbmZvLm5leHRTdGFydDtcbiAgICBpZiAoc3RhcnRUaW1lICYmIHRoaXMuaGxzKSB7XG4gICAgICBjb25zdCBidWZmZXJTdGFydmVkID0gYnVmZmVySW5mby5sZW4gPD0gY29uZmlnLm1heEJ1ZmZlckhvbGU7XG4gICAgICBjb25zdCB3YWl0aW5nID0gYnVmZmVySW5mby5sZW4gPiAwICYmIGJ1ZmZlckluZm8ubGVuIDwgMSAmJiBtZWRpYS5yZWFkeVN0YXRlIDwgMztcbiAgICAgIGNvbnN0IGdhcExlbmd0aCA9IHN0YXJ0VGltZSAtIGN1cnJlbnRUaW1lO1xuICAgICAgaWYgKGdhcExlbmd0aCA+IDAgJiYgKGJ1ZmZlclN0YXJ2ZWQgfHwgd2FpdGluZykpIHtcbiAgICAgICAgLy8gT25seSBhbGxvdyBsYXJnZSBnYXBzIHRvIGJlIHNraXBwZWQgaWYgaXQgaXMgYSBzdGFydCBnYXAsIG9yIGFsbCBmcmFnbWVudHMgaW4gc2tpcCByYW5nZSBhcmUgcGFydGlhbFxuICAgICAgICBpZiAoZ2FwTGVuZ3RoID4gY29uZmlnLm1heEJ1ZmZlckhvbGUpIHtcbiAgICAgICAgICBsZXQgc3RhcnRHYXAgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoY3VycmVudFRpbWUgPT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0RnJhZyA9IGZyYWdtZW50VHJhY2tlci5nZXRBcHBlbmRlZEZyYWcoMCwgUGxheWxpc3RMZXZlbFR5cGUuTUFJTik7XG4gICAgICAgICAgICBpZiAoc3RhcnRGcmFnICYmIHN0YXJ0VGltZSA8IHN0YXJ0RnJhZy5lbmQpIHtcbiAgICAgICAgICAgICAgc3RhcnRHYXAgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXN0YXJ0R2FwKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydFByb3Zpc2lvbmVkID0gcGFydGlhbCB8fCBmcmFnbWVudFRyYWNrZXIuZ2V0QXBwZW5kZWRGcmFnKGN1cnJlbnRUaW1lLCBQbGF5bGlzdExldmVsVHlwZS5NQUlOKTtcbiAgICAgICAgICAgIGlmIChzdGFydFByb3Zpc2lvbmVkKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpcyRobHMkbG9hZExldmVsT2I7XG4gICAgICAgICAgICAgIC8vIERvIG5vdCBzZWVrIHdoZW4gc2VsZWN0ZWQgdmFyaWFudCBwbGF5bGlzdCBpcyB1bmxvYWRlZFxuICAgICAgICAgICAgICBpZiAoISgoX3RoaXMkaGxzJGxvYWRMZXZlbE9iID0gdGhpcy5obHMubG9hZExldmVsT2JqKSAhPSBudWxsICYmIF90aGlzJGhscyRsb2FkTGV2ZWxPYi5kZXRhaWxzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIERvIG5vdCBzZWVrIHdoZW4gcmVxdWlyZWQgZnJhZ21lbnRzIGFyZSBpbmZsaWdodCBvciBhcHBlbmRpbmdcbiAgICAgICAgICAgICAgY29uc3QgaW5GbGlnaHREZXBlbmRlbmN5ID0gZ2V0SW5GbGlnaHREZXBlbmRlbmN5KHRoaXMuaGxzLmluRmxpZ2h0RnJhZ21lbnRzLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICBpZiAoaW5GbGlnaHREZXBlbmRlbmN5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gRG8gbm90IHNlZWsgaWYgd2UgY2FuJ3Qgd2FsayB0cmFja2VkIGZyYWdtZW50cyB0byBlbmQgb2YgZ2FwXG4gICAgICAgICAgICAgIGxldCBtb3JlVG9Mb2FkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGxldCBwb3MgPSBzdGFydFByb3Zpc2lvbmVkLmVuZDtcbiAgICAgICAgICAgICAgd2hpbGUgKHBvcyA8IHN0YXJ0VGltZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3Zpc2lvbmVkID0gZnJhZ21lbnRUcmFja2VyLmdldEFwcGVuZGVkRnJhZyhwb3MsIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pIHx8IGZyYWdtZW50VHJhY2tlci5nZXRQYXJ0aWFsRnJhZ21lbnQocG9zKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvdmlzaW9uZWQpIHtcbiAgICAgICAgICAgICAgICAgIHBvcyArPSBwcm92aXNpb25lZC5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbW9yZVRvTG9hZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG1vcmVUb0xvYWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXRUaW1lID0gTWF0aC5tYXgoc3RhcnRUaW1lICsgU0tJUF9CVUZGRVJfUkFOR0VfU1RBUlQsIGN1cnJlbnRUaW1lICsgU0tJUF9CVUZGRVJfSE9MRV9TVEVQX1NFQ09ORFMpO1xuICAgICAgICB0aGlzLndhcm4oYHNraXBwaW5nIGhvbGUsIGFkanVzdGluZyBjdXJyZW50VGltZSBmcm9tICR7Y3VycmVudFRpbWV9IHRvICR7dGFyZ2V0VGltZX1gKTtcbiAgICAgICAgdGhpcy5tb3ZlZCA9IHRydWU7XG4gICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gdGFyZ2V0VGltZTtcbiAgICAgICAgaWYgKCEocGFydGlhbCAhPSBudWxsICYmIHBhcnRpYWwuZ2FwKSkge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBmcmFnbWVudCBsb2FkZWQgd2l0aCBidWZmZXIgaG9sZXMsIHNlZWtpbmcgZnJvbSAke2N1cnJlbnRUaW1lfSB0byAke3RhcmdldFRpbWV9YCk7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX1NFRUtfT1ZFUl9IT0xFLFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICByZWFzb246IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICBmcmFnOiBwYXJ0aWFsIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGJ1ZmZlcjogYnVmZmVySW5mby5sZW4sXG4gICAgICAgICAgICBidWZmZXJJbmZvXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldFRpbWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIGZpeCBidWZmZXIgc3RhbGxzIGJ5IGFkdmFuY2luZyB0aGUgbWVkaWFFbGVtZW50J3MgY3VycmVudCB0aW1lIGJ5IGEgc21hbGwgYW1vdW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3RyeU51ZGdlQnVmZmVyKGJ1ZmZlckluZm8pIHtcbiAgICBjb25zdCB7XG4gICAgICBobHMsXG4gICAgICBtZWRpYSxcbiAgICAgIG51ZGdlUmV0cnlcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBjb25maWcgPSBobHMgPT0gbnVsbCA/IHZvaWQgMCA6IGhscy5jb25maWc7XG4gICAgaWYgKCFtZWRpYSB8fCAhY29uZmlnKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICB0aGlzLm51ZGdlUmV0cnkrKztcbiAgICBpZiAobnVkZ2VSZXRyeSA8IGNvbmZpZy5udWRnZU1heFJldHJ5KSB7XG4gICAgICBjb25zdCB0YXJnZXRUaW1lID0gY3VycmVudFRpbWUgKyAobnVkZ2VSZXRyeSArIDEpICogY29uZmlnLm51ZGdlT2Zmc2V0O1xuICAgICAgLy8gcGxheWJhY2sgc3RhbGxlZCBpbiBidWZmZXJlZCBhcmVhIC4uLiBsZXQncyBudWRnZSBjdXJyZW50VGltZSB0byB0cnkgdG8gb3ZlcmNvbWUgdGhpc1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYE51ZGdpbmcgJ2N1cnJlbnRUaW1lJyBmcm9tICR7Y3VycmVudFRpbWV9IHRvICR7dGFyZ2V0VGltZX1gKTtcbiAgICAgIHRoaXMud2FybihlcnJvci5tZXNzYWdlKTtcbiAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gdGFyZ2V0VGltZTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX05VREdFX09OX1NUQUxMLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICBidWZmZXI6IGJ1ZmZlckluZm8ubGVuLFxuICAgICAgICBidWZmZXJJbmZvXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYFBsYXloZWFkIHN0aWxsIG5vdCBtb3Zpbmcgd2hpbGUgZW5vdWdoIGRhdGEgYnVmZmVyZWQgQCR7Y3VycmVudFRpbWV9IGFmdGVyICR7Y29uZmlnLm51ZGdlTWF4UmV0cnl9IG51ZGdlc2ApO1xuICAgICAgdGhpcy5lcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX1NUQUxMRURfRVJST1IsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgICAgYnVmZmVyOiBidWZmZXJJbmZvLmxlbixcbiAgICAgICAgYnVmZmVySW5mb1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRJbkZsaWdodERlcGVuZGVuY3koaW5GbGlnaHRGcmFnbWVudHMsIGN1cnJlbnRUaW1lKSB7XG4gIGNvbnN0IG1haW4gPSBpbkZsaWdodChpbkZsaWdodEZyYWdtZW50cy5tYWluKTtcbiAgaWYgKG1haW4gJiYgbWFpbi5zdGFydCA8PSBjdXJyZW50VGltZSkge1xuICAgIHJldHVybiBtYWluO1xuICB9XG4gIGNvbnN0IGF1ZGlvID0gaW5GbGlnaHQoaW5GbGlnaHRGcmFnbWVudHMuYXVkaW8pO1xuICBpZiAoYXVkaW8gJiYgYXVkaW8uc3RhcnQgPD0gY3VycmVudFRpbWUpIHtcbiAgICByZXR1cm4gYXVkaW87XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBpbkZsaWdodChpbkZsaWdodERhdGEpIHtcbiAgaWYgKCFpbkZsaWdodERhdGEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBzd2l0Y2ggKGluRmxpZ2h0RGF0YS5zdGF0ZSkge1xuICAgIGNhc2UgU3RhdGUuSURMRTpcbiAgICBjYXNlIFN0YXRlLlNUT1BQRUQ6XG4gICAgY2FzZSBTdGF0ZS5FTkRFRDpcbiAgICBjYXNlIFN0YXRlLkVSUk9SOlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGluRmxpZ2h0RGF0YS5mcmFnO1xufVxuXG5jb25zdCBNSU5fQ1VFX0RVUkFUSU9OID0gMC4yNTtcbmZ1bmN0aW9uIGdldEN1ZUNsYXNzKCkge1xuICBpZiAodHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gdW5kZWZpbmVkO1xuICByZXR1cm4gc2VsZi5WVFRDdWUgfHwgc2VsZi5UZXh0VHJhY2tDdWU7XG59XG5mdW5jdGlvbiBjcmVhdGVDdWVXaXRoRGF0YUZpZWxkcyhDdWUsIHN0YXJ0VGltZSwgZW5kVGltZSwgZGF0YSwgdHlwZSkge1xuICBsZXQgY3VlID0gbmV3IEN1ZShzdGFydFRpbWUsIGVuZFRpbWUsICcnKTtcbiAgdHJ5IHtcbiAgICBjdWUudmFsdWUgPSBkYXRhO1xuICAgIGlmICh0eXBlKSB7XG4gICAgICBjdWUudHlwZSA9IHR5cGU7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgY3VlID0gbmV3IEN1ZShzdGFydFRpbWUsIGVuZFRpbWUsIHN0cmluZ2lmeSh0eXBlID8gX29iamVjdFNwcmVhZDIoe1xuICAgICAgdHlwZVxuICAgIH0sIGRhdGEpIDogZGF0YSkpO1xuICB9XG4gIHJldHVybiBjdWU7XG59XG5cbi8vIFZUVEN1ZSBsYXRlc3QgZHJhZnQgYWxsb3dzIGFuIGluZmluaXRlIGR1cmF0aW9uLCBmYWxsYmFja1xuLy8gdG8gTUFYX1ZBTFVFIGlmIG5lY2Vzc2FyeVxuY29uc3QgTUFYX0NVRV9FTkRUSU1FID0gKCgpID0+IHtcbiAgY29uc3QgQ3VlID0gZ2V0Q3VlQ2xhc3MoKTtcbiAgdHJ5IHtcbiAgICBDdWUgJiYgbmV3IEN1ZSgwLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksICcnKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xuICB9XG4gIHJldHVybiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG59KSgpO1xuY2xhc3MgSUQzVHJhY2tDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5pZDNUcmFjayA9IG51bGw7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5kYXRlUmFuZ2VDdWVzQXBwZW5kZWQgPSB7fTtcbiAgICB0aGlzLnJlbW92ZUN1ZXMgPSB0cnVlO1xuICAgIHRoaXMub25FdmVudEN1ZUVudGVyID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmhscykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FVkVOVF9DVUVfRU5URVIsIHt9KTtcbiAgICB9O1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMuX3JlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl91bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5pZDNUcmFjayA9IG51bGw7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5kYXRlUmFuZ2VDdWVzQXBwZW5kZWQgPSB7fTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSB0aGlzLm9uRXZlbnRDdWVFbnRlciA9IG51bGw7XG4gIH1cbiAgX3JlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19QQVJTSU5HX01FVEFEQVRBLCB0aGlzLm9uRnJhZ1BhcnNpbmdNZXRhZGF0YSwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX1BUU19VUERBVEVELCB0aGlzLm9uTGV2ZWxQdHNVcGRhdGVkLCB0aGlzKTtcbiAgfVxuICBfdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19QQVJTSU5HX01FVEFEQVRBLCB0aGlzLm9uRnJhZ1BhcnNpbmdNZXRhZGF0YSwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0ZMVVNISU5HLCB0aGlzLm9uQnVmZmVyRmx1c2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX1VQREFURUQsIHRoaXMub25MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX1BUU19VUERBVEVELCB0aGlzLm9uTGV2ZWxQdHNVcGRhdGVkLCB0aGlzKTtcbiAgfVxuICAvLyBBZGQgSUQzIG1ldGF0YWRhdGEgdGV4dCB0cmFjay5cbiAgb25NZWRpYUF0dGFjaGluZyhldmVudCwgZGF0YSkge1xuICAgIHZhciBfZGF0YSRvdmVycmlkZXM7XG4gICAgdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgaWYgKCgoX2RhdGEkb3ZlcnJpZGVzID0gZGF0YS5vdmVycmlkZXMpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YSRvdmVycmlkZXMuY3VlUmVtb3ZhbCkgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLnJlbW92ZUN1ZXMgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgb25NZWRpYUF0dGFjaGVkKCkge1xuICAgIGNvbnN0IGRldGFpbHMgPSB0aGlzLmhscy5sYXRlc3RMZXZlbERldGFpbHM7XG4gICAgaWYgKGRldGFpbHMpIHtcbiAgICAgIHRoaXMudXBkYXRlRGF0ZVJhbmdlQ3VlcyhkZXRhaWxzKTtcbiAgICB9XG4gIH1cbiAgb25NZWRpYURldGFjaGluZyhldmVudCwgZGF0YSkge1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIGNvbnN0IHRyYW5zZmVycmluZ01lZGlhID0gISFkYXRhLnRyYW5zZmVyTWVkaWE7XG4gICAgaWYgKHRyYW5zZmVycmluZ01lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmlkM1RyYWNrKSB7XG4gICAgICBpZiAodGhpcy5yZW1vdmVDdWVzKSB7XG4gICAgICAgIGNsZWFyQ3VycmVudEN1ZXModGhpcy5pZDNUcmFjaywgdGhpcy5vbkV2ZW50Q3VlRW50ZXIpO1xuICAgICAgfVxuICAgICAgdGhpcy5pZDNUcmFjayA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkID0ge307XG4gIH1cbiAgb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgdGhpcy5kYXRlUmFuZ2VDdWVzQXBwZW5kZWQgPSB7fTtcbiAgfVxuICBjcmVhdGVUcmFjayhtZWRpYSkge1xuICAgIGNvbnN0IHRyYWNrID0gdGhpcy5nZXRJRDNUcmFjayhtZWRpYS50ZXh0VHJhY2tzKTtcbiAgICB0cmFjay5tb2RlID0gJ2hpZGRlbic7XG4gICAgcmV0dXJuIHRyYWNrO1xuICB9XG4gIGdldElEM1RyYWNrKHRleHRUcmFja3MpIHtcbiAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0VHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB0ZXh0VHJhY2sgPSB0ZXh0VHJhY2tzW2ldO1xuICAgICAgaWYgKHRleHRUcmFjay5raW5kID09PSAnbWV0YWRhdGEnICYmIHRleHRUcmFjay5sYWJlbCA9PT0gJ2lkMycpIHtcbiAgICAgICAgLy8gc2VuZCAnYWRkdHJhY2snIHdoZW4gcmV1c2luZyB0aGUgdGV4dFRyYWNrIGZvciBtZXRhZGF0YSxcbiAgICAgICAgLy8gc2FtZSBhcyB3aGF0IHdlIGRvIGZvciBjYXB0aW9uc1xuICAgICAgICBzZW5kQWRkVHJhY2tFdmVudCh0ZXh0VHJhY2ssIHRoaXMubWVkaWEpO1xuICAgICAgICByZXR1cm4gdGV4dFRyYWNrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tZWRpYS5hZGRUZXh0VHJhY2soJ21ldGFkYXRhJywgJ2lkMycpO1xuICB9XG4gIG9uRnJhZ1BhcnNpbmdNZXRhZGF0YShldmVudCwgZGF0YSkge1xuICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBobHM6IHtcbiAgICAgICAgY29uZmlnOiB7XG4gICAgICAgICAgZW5hYmxlRW1zZ01ldGFkYXRhQ3VlcyxcbiAgICAgICAgICBlbmFibGVJRDNNZXRhZGF0YUN1ZXNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghZW5hYmxlRW1zZ01ldGFkYXRhQ3VlcyAmJiAhZW5hYmxlSUQzTWV0YWRhdGFDdWVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHNhbXBsZXNcbiAgICB9ID0gZGF0YTtcblxuICAgIC8vIGNyZWF0ZSB0cmFjayBkeW5hbWljYWxseVxuICAgIGlmICghdGhpcy5pZDNUcmFjaykge1xuICAgICAgdGhpcy5pZDNUcmFjayA9IHRoaXMuY3JlYXRlVHJhY2sodGhpcy5tZWRpYSk7XG4gICAgfVxuICAgIGNvbnN0IEN1ZSA9IGdldEN1ZUNsYXNzKCk7XG4gICAgaWYgKCFDdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB0eXBlID0gc2FtcGxlc1tpXS50eXBlO1xuICAgICAgaWYgKHR5cGUgPT09IE1ldGFkYXRhU2NoZW1hLmVtc2cgJiYgIWVuYWJsZUVtc2dNZXRhZGF0YUN1ZXMgfHwgIWVuYWJsZUlEM01ldGFkYXRhQ3Vlcykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZyYW1lcyA9IGdldElkM0ZyYW1lcyhzYW1wbGVzW2ldLmRhdGEpO1xuICAgICAgaWYgKGZyYW1lcykge1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBzYW1wbGVzW2ldLnB0cztcbiAgICAgICAgbGV0IGVuZFRpbWUgPSBzdGFydFRpbWUgKyBzYW1wbGVzW2ldLmR1cmF0aW9uO1xuICAgICAgICBpZiAoZW5kVGltZSA+IE1BWF9DVUVfRU5EVElNRSkge1xuICAgICAgICAgIGVuZFRpbWUgPSBNQVhfQ1VFX0VORFRJTUU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZURpZmYgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgICBpZiAodGltZURpZmYgPD0gMCkge1xuICAgICAgICAgIGVuZFRpbWUgPSBzdGFydFRpbWUgKyBNSU5fQ1VFX0RVUkFUSU9OO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZnJhbWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY29uc3QgZnJhbWUgPSBmcmFtZXNbal07XG4gICAgICAgICAgLy8gU2FmYXJpIGRvZXNuJ3QgcHV0IHRoZSB0aW1lc3RhbXAgZnJhbWUgaW4gdGhlIFRleHRUcmFja1xuICAgICAgICAgIGlmICghaXNJZDNUaW1lc3RhbXBGcmFtZShmcmFtZSkpIHtcbiAgICAgICAgICAgIC8vIGFkZCBhIGJvdW5kcyB0byBhbnkgdW5ib3VuZGVkIGN1ZXNcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSWQzQ3VlRW5kcyhzdGFydFRpbWUsIHR5cGUpO1xuICAgICAgICAgICAgY29uc3QgY3VlID0gY3JlYXRlQ3VlV2l0aERhdGFGaWVsZHMoQ3VlLCBzdGFydFRpbWUsIGVuZFRpbWUsIGZyYW1lLCB0eXBlKTtcbiAgICAgICAgICAgIGlmIChjdWUpIHtcbiAgICAgICAgICAgICAgdGhpcy5pZDNUcmFjay5hZGRDdWUoY3VlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdXBkYXRlSWQzQ3VlRW5kcyhzdGFydFRpbWUsIHR5cGUpIHtcbiAgICB2YXIgX3RoaXMkaWQzVHJhY2s7XG4gICAgY29uc3QgY3VlcyA9IChfdGhpcyRpZDNUcmFjayA9IHRoaXMuaWQzVHJhY2spID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRpZDNUcmFjay5jdWVzO1xuICAgIGlmIChjdWVzKSB7XG4gICAgICBmb3IgKGxldCBpID0gY3Vlcy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgY29uc3QgY3VlID0gY3Vlc1tpXTtcbiAgICAgICAgaWYgKGN1ZS50eXBlID09PSB0eXBlICYmIGN1ZS5zdGFydFRpbWUgPCBzdGFydFRpbWUgJiYgY3VlLmVuZFRpbWUgPT09IE1BWF9DVUVfRU5EVElNRSkge1xuICAgICAgICAgIGN1ZS5lbmRUaW1lID0gc3RhcnRUaW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG9uQnVmZmVyRmx1c2hpbmcoZXZlbnQsIHtcbiAgICBzdGFydE9mZnNldCxcbiAgICBlbmRPZmZzZXQsXG4gICAgdHlwZVxuICB9KSB7XG4gICAgY29uc3Qge1xuICAgICAgaWQzVHJhY2ssXG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWhscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjb25maWc6IHtcbiAgICAgICAgZW5hYmxlRW1zZ01ldGFkYXRhQ3VlcyxcbiAgICAgICAgZW5hYmxlSUQzTWV0YWRhdGFDdWVzXG4gICAgICB9XG4gICAgfSA9IGhscztcbiAgICBpZiAoaWQzVHJhY2sgJiYgKGVuYWJsZUVtc2dNZXRhZGF0YUN1ZXMgfHwgZW5hYmxlSUQzTWV0YWRhdGFDdWVzKSkge1xuICAgICAgbGV0IHByZWRpY2F0ZTtcbiAgICAgIGlmICh0eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IGN1ZSA9PiBjdWUudHlwZSA9PT0gTWV0YWRhdGFTY2hlbWEuYXVkaW9JZDMgJiYgZW5hYmxlSUQzTWV0YWRhdGFDdWVzO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IGN1ZSA9PiBjdWUudHlwZSA9PT0gTWV0YWRhdGFTY2hlbWEuZW1zZyAmJiBlbmFibGVFbXNnTWV0YWRhdGFDdWVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJlZGljYXRlID0gY3VlID0+IGN1ZS50eXBlID09PSBNZXRhZGF0YVNjaGVtYS5hdWRpb0lkMyAmJiBlbmFibGVJRDNNZXRhZGF0YUN1ZXMgfHwgY3VlLnR5cGUgPT09IE1ldGFkYXRhU2NoZW1hLmVtc2cgJiYgZW5hYmxlRW1zZ01ldGFkYXRhQ3VlcztcbiAgICAgIH1cbiAgICAgIHJlbW92ZUN1ZXNJblJhbmdlKGlkM1RyYWNrLCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0LCBwcmVkaWNhdGUpO1xuICAgIH1cbiAgfVxuICBvbkxldmVsVXBkYXRlZChldmVudCwge1xuICAgIGRldGFpbHNcbiAgfSkge1xuICAgIHRoaXMudXBkYXRlRGF0ZVJhbmdlQ3VlcyhkZXRhaWxzLCB0cnVlKTtcbiAgfVxuICBvbkxldmVsUHRzVXBkYXRlZChldmVudCwgZGF0YSkge1xuICAgIGlmIChNYXRoLmFicyhkYXRhLmRyaWZ0KSA+IDAuMDEpIHtcbiAgICAgIHRoaXMudXBkYXRlRGF0ZVJhbmdlQ3VlcyhkYXRhLmRldGFpbHMpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVEYXRlUmFuZ2VDdWVzKGRldGFpbHMsIHJlbW92ZU9sZEN1ZXMpIHtcbiAgICBpZiAoIXRoaXMubWVkaWEgfHwgIWRldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lIHx8ICF0aGlzLmhscy5jb25maWcuZW5hYmxlRGF0ZVJhbmdlTWV0YWRhdGFDdWVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGlkM1RyYWNrXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgZGF0ZVJhbmdlc1xuICAgIH0gPSBkZXRhaWxzO1xuICAgIGNvbnN0IGlkcyA9IE9iamVjdC5rZXlzKGRhdGVSYW5nZXMpO1xuICAgIGxldCBkYXRlUmFuZ2VDdWVzQXBwZW5kZWQgPSB0aGlzLmRhdGVSYW5nZUN1ZXNBcHBlbmRlZDtcbiAgICAvLyBSZW1vdmUgY3VlcyBmcm9tIHRyYWNrIG5vdCBmb3VuZCBpbiBkZXRhaWxzLmRhdGVSYW5nZXNcbiAgICBpZiAoaWQzVHJhY2sgJiYgcmVtb3ZlT2xkQ3Vlcykge1xuICAgICAgdmFyIF9pZDNUcmFjayRjdWVzO1xuICAgICAgaWYgKChfaWQzVHJhY2skY3VlcyA9IGlkM1RyYWNrLmN1ZXMpICE9IG51bGwgJiYgX2lkM1RyYWNrJGN1ZXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGlkc1RvUmVtb3ZlID0gT2JqZWN0LmtleXMoZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkKS5maWx0ZXIoaWQgPT4gIWlkcy5pbmNsdWRlcyhpZCkpO1xuICAgICAgICBmb3IgKGxldCBpID0gaWRzVG9SZW1vdmUubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgY29uc3QgaWQgPSBpZHNUb1JlbW92ZVtpXTtcbiAgICAgICAgICBjb25zdCBjdWVzID0gZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkW2lkXS5jdWVzO1xuICAgICAgICAgIGRlbGV0ZSBkYXRlUmFuZ2VDdWVzQXBwZW5kZWRbaWRdO1xuICAgICAgICAgIE9iamVjdC5rZXlzKGN1ZXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1ZSA9IGN1ZXNba2V5XTtcbiAgICAgICAgICAgICAgY3VlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VudGVyJywgdGhpcy5vbkV2ZW50Q3VlRW50ZXIpO1xuICAgICAgICAgICAgICBpZDNUcmFjay5yZW1vdmVDdWUoY3VlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgLyogbm8tb3AgKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkID0gdGhpcy5kYXRlUmFuZ2VDdWVzQXBwZW5kZWQgPSB7fTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRXhpdCBpZiB0aGUgcGxheWxpc3QgZG9lcyBub3QgaGF2ZSBEYXRlIFJhbmdlcyBvciBkb2VzIG5vdCBoYXZlIFByb2dyYW0gRGF0ZSBUaW1lXG4gICAgY29uc3QgbGFzdEZyYWdtZW50ID0gZGV0YWlscy5mcmFnbWVudHNbZGV0YWlscy5mcmFnbWVudHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGlkcy5sZW5ndGggPT09IDAgfHwgIWlzRmluaXRlTnVtYmVyKGxhc3RGcmFnbWVudCA9PSBudWxsID8gdm9pZCAwIDogbGFzdEZyYWdtZW50LnByb2dyYW1EYXRlVGltZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlkM1RyYWNrKSB7XG4gICAgICB0aGlzLmlkM1RyYWNrID0gdGhpcy5jcmVhdGVUcmFjayh0aGlzLm1lZGlhKTtcbiAgICB9XG4gICAgY29uc3QgQ3VlID0gZ2V0Q3VlQ2xhc3MoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaWQgPSBpZHNbaV07XG4gICAgICBjb25zdCBkYXRlUmFuZ2UgPSBkYXRlUmFuZ2VzW2lkXTtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IGRhdGVSYW5nZS5zdGFydFRpbWU7XG5cbiAgICAgIC8vIFByb2Nlc3MgRGF0ZVJhbmdlcyB0byBkZXRlcm1pbmUgZW5kLXRpbWUgKGtub3duIERVUkFUSU9OLCBFTkQtREFURSwgb3IgRU5ELU9OLU5FWFQpXG4gICAgICBjb25zdCBhcHBlbmRlZERhdGVSYW5nZUN1ZXMgPSBkYXRlUmFuZ2VDdWVzQXBwZW5kZWRbaWRdO1xuICAgICAgY29uc3QgY3VlcyA9IChhcHBlbmRlZERhdGVSYW5nZUN1ZXMgPT0gbnVsbCA/IHZvaWQgMCA6IGFwcGVuZGVkRGF0ZVJhbmdlQ3Vlcy5jdWVzKSB8fCB7fTtcbiAgICAgIGxldCBkdXJhdGlvbktub3duID0gKGFwcGVuZGVkRGF0ZVJhbmdlQ3VlcyA9PSBudWxsID8gdm9pZCAwIDogYXBwZW5kZWREYXRlUmFuZ2VDdWVzLmR1cmF0aW9uS25vd24pIHx8IGZhbHNlO1xuICAgICAgbGV0IGVuZFRpbWUgPSBNQVhfQ1VFX0VORFRJTUU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBlbmREYXRlXG4gICAgICB9ID0gZGF0ZVJhbmdlO1xuICAgICAgaWYgKGVuZERhdGUgJiYgZHVyYXRpb24gIT09IG51bGwpIHtcbiAgICAgICAgZW5kVGltZSA9IHN0YXJ0VGltZSArIGR1cmF0aW9uO1xuICAgICAgICBkdXJhdGlvbktub3duID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0ZVJhbmdlLmVuZE9uTmV4dCAmJiAhZHVyYXRpb25Lbm93bikge1xuICAgICAgICBjb25zdCBuZXh0RGF0ZVJhbmdlV2l0aFNhbWVDbGFzcyA9IGlkcy5yZWR1Y2UoKGNhbmRpZGF0ZURhdGVSYW5nZSwgaWQpID0+IHtcbiAgICAgICAgICBpZiAoaWQgIT09IGRhdGVSYW5nZS5pZCkge1xuICAgICAgICAgICAgY29uc3Qgb3RoZXJEYXRlUmFuZ2UgPSBkYXRlUmFuZ2VzW2lkXTtcbiAgICAgICAgICAgIGlmIChvdGhlckRhdGVSYW5nZS5jbGFzcyA9PT0gZGF0ZVJhbmdlLmNsYXNzICYmIG90aGVyRGF0ZVJhbmdlLnN0YXJ0RGF0ZSA+IGRhdGVSYW5nZS5zdGFydERhdGUgJiYgKCFjYW5kaWRhdGVEYXRlUmFuZ2UgfHwgZGF0ZVJhbmdlLnN0YXJ0RGF0ZSA8IGNhbmRpZGF0ZURhdGVSYW5nZS5zdGFydERhdGUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvdGhlckRhdGVSYW5nZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZURhdGVSYW5nZTtcbiAgICAgICAgfSwgbnVsbCk7XG4gICAgICAgIGlmIChuZXh0RGF0ZVJhbmdlV2l0aFNhbWVDbGFzcykge1xuICAgICAgICAgIGVuZFRpbWUgPSBuZXh0RGF0ZVJhbmdlV2l0aFNhbWVDbGFzcy5zdGFydFRpbWU7XG4gICAgICAgICAgZHVyYXRpb25Lbm93biA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIFRleHRUcmFjayBDdWVzIGZvciBlYWNoIE1ldGFkYXRhR3JvdXAgSXRlbSAoc2VsZWN0IERhdGVSYW5nZSBhdHRyaWJ1dGUpXG4gICAgICAvLyBUaGlzIGlzIHRvIGVtdWxhdGUgU2FmYXJpIEhMUyBwbGF5YmFjayBoYW5kbGluZyBvZiBEYXRlUmFuZ2UgdGFnc1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IE9iamVjdC5rZXlzKGRhdGVSYW5nZS5hdHRyKTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYXR0cmlidXRlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCBrZXkgPSBhdHRyaWJ1dGVzW2pdO1xuICAgICAgICBpZiAoIWlzRGF0ZVJhbmdlQ3VlQXR0cmlidXRlKGtleSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdWUgPSBjdWVzW2tleV07XG4gICAgICAgIGlmIChjdWUpIHtcbiAgICAgICAgICBpZiAoZHVyYXRpb25Lbm93biAmJiAhYXBwZW5kZWREYXRlUmFuZ2VDdWVzLmR1cmF0aW9uS25vd24pIHtcbiAgICAgICAgICAgIGN1ZS5lbmRUaW1lID0gZW5kVGltZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGN1ZS5zdGFydFRpbWUgLSBzdGFydFRpbWUpID4gMC4wMSkge1xuICAgICAgICAgICAgY3VlLnN0YXJ0VGltZSA9IHN0YXJ0VGltZTtcbiAgICAgICAgICAgIGN1ZS5lbmRUaW1lID0gZW5kVGltZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoQ3VlKSB7XG4gICAgICAgICAgbGV0IGRhdGEgPSBkYXRlUmFuZ2UuYXR0cltrZXldO1xuICAgICAgICAgIGlmIChpc1NDVEUzNUF0dHJpYnV0ZShrZXkpKSB7XG4gICAgICAgICAgICBkYXRhID0gaGV4VG9BcnJheUJ1ZmZlcihkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IF9jdWUgPSBjcmVhdGVDdWVXaXRoRGF0YUZpZWxkcyhDdWUsIHN0YXJ0VGltZSwgZW5kVGltZSwgcGF5bG9hZCwgTWV0YWRhdGFTY2hlbWEuZGF0ZVJhbmdlKTtcbiAgICAgICAgICBpZiAoX2N1ZSkge1xuICAgICAgICAgICAgX2N1ZS5pZCA9IGlkO1xuICAgICAgICAgICAgdGhpcy5pZDNUcmFjay5hZGRDdWUoX2N1ZSk7XG4gICAgICAgICAgICBjdWVzW2tleV0gPSBfY3VlO1xuICAgICAgICAgICAgaWYgKHRoaXMuaGxzLmNvbmZpZy5pbnRlcnN0aXRpYWxzQ29udHJvbGxlcikge1xuICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnWC1BU1NFVC1MSVNUJyB8fCBrZXkgPT09ICdYLUFTU0VULVVSTCcpIHtcbiAgICAgICAgICAgICAgICBfY3VlLmFkZEV2ZW50TGlzdGVuZXIoJ2VudGVyJywgdGhpcy5vbkV2ZW50Q3VlRW50ZXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEtlZXAgdHJhY2sgb2YgcHJvY2Vzc2VkIERhdGVSYW5nZXMgYnkgSUQgZm9yIHVwZGF0aW5nIGN1ZXMgd2l0aCBuZXcgRGF0ZVJhbmdlIHRhZyBhdHRyaWJ1dGVzXG4gICAgICBkYXRlUmFuZ2VDdWVzQXBwZW5kZWRbaWRdID0ge1xuICAgICAgICBjdWVzLFxuICAgICAgICBkYXRlUmFuZ2UsXG4gICAgICAgIGR1cmF0aW9uS25vd25cbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIExhdGVuY3lDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50VGltZSA9IDA7XG4gICAgdGhpcy5zdGFsbENvdW50ID0gMDtcbiAgICB0aGlzLl9sYXRlbmN5ID0gbnVsbDtcbiAgICB0aGlzLl90YXJnZXRMYXRlbmN5VXBkYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMub25UaW1ldXBkYXRlID0gKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBtZWRpYVxuICAgICAgfSA9IHRoaXM7XG4gICAgICBjb25zdCBsZXZlbERldGFpbHMgPSB0aGlzLmxldmVsRGV0YWlscztcbiAgICAgIGlmICghbWVkaWEgfHwgIWxldmVsRGV0YWlscykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgICBjb25zdCBsYXRlbmN5ID0gdGhpcy5jb21wdXRlTGF0ZW5jeSgpO1xuICAgICAgaWYgKGxhdGVuY3kgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fbGF0ZW5jeSA9IGxhdGVuY3k7XG5cbiAgICAgIC8vIEFkYXB0IHBsYXliYWNrUmF0ZSB0byBtZWV0IHRhcmdldCBsYXRlbmN5IGluIGxvdy1sYXRlbmN5IG1vZGVcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbG93TGF0ZW5jeU1vZGUsXG4gICAgICAgIG1heExpdmVTeW5jUGxheWJhY2tSYXRlXG4gICAgICB9ID0gdGhpcy5jb25maWc7XG4gICAgICBpZiAoIWxvd0xhdGVuY3lNb2RlIHx8IG1heExpdmVTeW5jUGxheWJhY2tSYXRlID09PSAxIHx8ICFsZXZlbERldGFpbHMubGl2ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB0YXJnZXRMYXRlbmN5ID0gdGhpcy50YXJnZXRMYXRlbmN5O1xuICAgICAgaWYgKHRhcmdldExhdGVuY3kgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZGlzdGFuY2VGcm9tVGFyZ2V0ID0gbGF0ZW5jeSAtIHRhcmdldExhdGVuY3k7XG4gICAgICAvLyBPbmx5IGFkanVzdCBwbGF5YmFja1JhdGUgd2hlbiB3aXRoaW4gb25lIHRhcmdldCBkdXJhdGlvbiBvZiB0YXJnZXRMYXRlbmN5XG4gICAgICAvLyBhbmQgbW9yZSB0aGFuIG9uZSBzZWNvbmQgZnJvbSB1bmRlci1idWZmZXJpbmcuXG4gICAgICAvLyBQbGF5YmFjayBmdXJ0aGVyIHRoYW4gb25lIHRhcmdldCBkdXJhdGlvbiBmcm9tIHRhcmdldCBjYW4gYmUgY29uc2lkZXJlZCBEVlIgcGxheWJhY2suXG4gICAgICBjb25zdCBsaXZlTWluTGF0ZW5jeUR1cmF0aW9uID0gTWF0aC5taW4odGhpcy5tYXhMYXRlbmN5LCB0YXJnZXRMYXRlbmN5ICsgbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uKTtcbiAgICAgIGNvbnN0IGluTGl2ZVJhbmdlID0gZGlzdGFuY2VGcm9tVGFyZ2V0IDwgbGl2ZU1pbkxhdGVuY3lEdXJhdGlvbjtcbiAgICAgIGlmIChpbkxpdmVSYW5nZSAmJiBkaXN0YW5jZUZyb21UYXJnZXQgPiAwLjA1ICYmIHRoaXMuZm9yd2FyZEJ1ZmZlckxlbmd0aCA+IDEpIHtcbiAgICAgICAgY29uc3QgbWF4ID0gTWF0aC5taW4oMiwgTWF0aC5tYXgoMS4wLCBtYXhMaXZlU3luY1BsYXliYWNrUmF0ZSkpO1xuICAgICAgICBjb25zdCByYXRlID0gTWF0aC5yb3VuZCgyIC8gKDEgKyBNYXRoLmV4cCgtMC43NSAqIGRpc3RhbmNlRnJvbVRhcmdldCAtIHRoaXMuZWRnZVN0YWxsZWQpKSAqIDIwKSAvIDIwO1xuICAgICAgICBjb25zdCBwbGF5YmFja1JhdGUgPSBNYXRoLm1pbihtYXgsIE1hdGgubWF4KDEsIHJhdGUpKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VNZWRpYVBsYXliYWNrUmF0ZShtZWRpYSwgcGxheWJhY2tSYXRlKTtcbiAgICAgIH0gZWxzZSBpZiAobWVkaWEucGxheWJhY2tSYXRlICE9PSAxICYmIG1lZGlhLnBsYXliYWNrUmF0ZSAhPT0gMCkge1xuICAgICAgICB0aGlzLmNoYW5nZU1lZGlhUGxheWJhY2tSYXRlKG1lZGlhLCAxKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMuY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgZ2V0IGxldmVsRGV0YWlscygpIHtcbiAgICB2YXIgX3RoaXMkaGxzO1xuICAgIHJldHVybiAoKF90aGlzJGhscyA9IHRoaXMuaGxzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkaGxzLmxhdGVzdExldmVsRGV0YWlscykgfHwgbnVsbDtcbiAgfVxuICBnZXQgbGF0ZW5jeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGF0ZW5jeSB8fCAwO1xuICB9XG4gIGdldCBtYXhMYXRlbmN5KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSB0aGlzO1xuICAgIGlmIChjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb247XG4gICAgfVxuICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IHRoaXMubGV2ZWxEZXRhaWxzO1xuICAgIHJldHVybiBsZXZlbERldGFpbHMgPyBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50ICogbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uIDogMDtcbiAgfVxuICBnZXQgdGFyZ2V0TGF0ZW5jeSgpIHtcbiAgICBjb25zdCBsZXZlbERldGFpbHMgPSB0aGlzLmxldmVsRGV0YWlscztcbiAgICBpZiAobGV2ZWxEZXRhaWxzID09PSBudWxsIHx8IHRoaXMuaGxzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgaG9sZEJhY2ssXG4gICAgICBwYXJ0SG9sZEJhY2ssXG4gICAgICB0YXJnZXRkdXJhdGlvblxuICAgIH0gPSBsZXZlbERldGFpbHM7XG4gICAgY29uc3Qge1xuICAgICAgbGl2ZVN5bmNEdXJhdGlvbixcbiAgICAgIGxpdmVTeW5jRHVyYXRpb25Db3VudCxcbiAgICAgIGxvd0xhdGVuY3lNb2RlXG4gICAgfSA9IHRoaXMuY29uZmlnO1xuICAgIGNvbnN0IHVzZXJDb25maWcgPSB0aGlzLmhscy51c2VyQ29uZmlnO1xuICAgIGxldCB0YXJnZXRMYXRlbmN5ID0gbG93TGF0ZW5jeU1vZGUgPyBwYXJ0SG9sZEJhY2sgfHwgaG9sZEJhY2sgOiBob2xkQmFjaztcbiAgICBpZiAodGhpcy5fdGFyZ2V0TGF0ZW5jeVVwZGF0ZWQgfHwgdXNlckNvbmZpZy5saXZlU3luY0R1cmF0aW9uIHx8IHVzZXJDb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50IHx8IHRhcmdldExhdGVuY3kgPT09IDApIHtcbiAgICAgIHRhcmdldExhdGVuY3kgPSBsaXZlU3luY0R1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBsaXZlU3luY0R1cmF0aW9uIDogbGl2ZVN5bmNEdXJhdGlvbkNvdW50ICogdGFyZ2V0ZHVyYXRpb247XG4gICAgfVxuICAgIGNvbnN0IG1heExpdmVTeW5jT25TdGFsbEluY3JlYXNlID0gdGFyZ2V0ZHVyYXRpb247XG4gICAgcmV0dXJuIHRhcmdldExhdGVuY3kgKyBNYXRoLm1pbih0aGlzLnN0YWxsQ291bnQgKiB0aGlzLmNvbmZpZy5saXZlU3luY09uU3RhbGxJbmNyZWFzZSwgbWF4TGl2ZVN5bmNPblN0YWxsSW5jcmVhc2UpO1xuICB9XG4gIHNldCB0YXJnZXRMYXRlbmN5KGxhdGVuY3kpIHtcbiAgICB0aGlzLnN0YWxsQ291bnQgPSAwO1xuICAgIHRoaXMuY29uZmlnLmxpdmVTeW5jRHVyYXRpb24gPSBsYXRlbmN5O1xuICAgIHRoaXMuX3RhcmdldExhdGVuY3lVcGRhdGVkID0gdHJ1ZTtcbiAgfVxuICBnZXQgbGl2ZVN5bmNQb3NpdGlvbigpIHtcbiAgICBjb25zdCBsaXZlRWRnZSA9IHRoaXMuZXN0aW1hdGVMaXZlRWRnZSgpO1xuICAgIGNvbnN0IHRhcmdldExhdGVuY3kgPSB0aGlzLnRhcmdldExhdGVuY3k7XG4gICAgaWYgKGxpdmVFZGdlID09PSBudWxsIHx8IHRhcmdldExhdGVuY3kgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBsZXZlbERldGFpbHMgPSB0aGlzLmxldmVsRGV0YWlscztcbiAgICBpZiAobGV2ZWxEZXRhaWxzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZWRnZSA9IGxldmVsRGV0YWlscy5lZGdlO1xuICAgIGNvbnN0IHN5bmNQb3NpdGlvbiA9IGxpdmVFZGdlIC0gdGFyZ2V0TGF0ZW5jeSAtIHRoaXMuZWRnZVN0YWxsZWQ7XG4gICAgY29uc3QgbWluID0gZWRnZSAtIGxldmVsRGV0YWlscy50b3RhbGR1cmF0aW9uO1xuICAgIGNvbnN0IG1heCA9IGVkZ2UgLSAodGhpcy5jb25maWcubG93TGF0ZW5jeU1vZGUgJiYgbGV2ZWxEZXRhaWxzLnBhcnRUYXJnZXQgfHwgbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uKTtcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobWluLCBzeW5jUG9zaXRpb24pLCBtYXgpO1xuICB9XG4gIGdldCBkcmlmdCgpIHtcbiAgICBjb25zdCBsZXZlbERldGFpbHMgPSB0aGlzLmxldmVsRGV0YWlscztcbiAgICBpZiAobGV2ZWxEZXRhaWxzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIGxldmVsRGV0YWlscy5kcmlmdDtcbiAgfVxuICBnZXQgZWRnZVN0YWxsZWQoKSB7XG4gICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gdGhpcy5sZXZlbERldGFpbHM7XG4gICAgaWYgKGxldmVsRGV0YWlscyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNvbnN0IG1heExldmVsVXBkYXRlQWdlID0gKHRoaXMuY29uZmlnLmxvd0xhdGVuY3lNb2RlICYmIGxldmVsRGV0YWlscy5wYXJ0VGFyZ2V0IHx8IGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbikgKiAzO1xuICAgIHJldHVybiBNYXRoLm1heChsZXZlbERldGFpbHMuYWdlIC0gbWF4TGV2ZWxVcGRhdGVBZ2UsIDApO1xuICB9XG4gIGdldCBmb3J3YXJkQnVmZmVyTGVuZ3RoKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lZGlhXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gdGhpcy5sZXZlbERldGFpbHM7XG4gICAgaWYgKCFtZWRpYSB8fCAhbGV2ZWxEZXRhaWxzKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29uc3QgYnVmZmVyZWRSYW5nZXMgPSBtZWRpYS5idWZmZXJlZC5sZW5ndGg7XG4gICAgcmV0dXJuIChidWZmZXJlZFJhbmdlcyA/IG1lZGlhLmJ1ZmZlcmVkLmVuZChidWZmZXJlZFJhbmdlcyAtIDEpIDogbGV2ZWxEZXRhaWxzLmVkZ2UpIC0gdGhpcy5jdXJyZW50VGltZTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHRoaXMub25NZWRpYURldGFjaGluZygpO1xuICAgIHRoaXMuaGxzID0gbnVsbDtcbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWhscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBobHMub24oRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX1VQREFURUQsIHRoaXMub25MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH1cbiAgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWhscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfVxuICBvbk1lZGlhQXR0YWNoZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICB0aGlzLm1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3RpbWV1cGRhdGUnLCB0aGlzLm9uVGltZXVwZGF0ZSk7XG4gIH1cbiAgb25NZWRpYURldGFjaGluZygpIHtcbiAgICBpZiAodGhpcy5tZWRpYSkge1xuICAgICAgdGhpcy5tZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCd0aW1ldXBkYXRlJywgdGhpcy5vblRpbWV1cGRhdGUpO1xuICAgICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgfVxuICB9XG4gIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHRoaXMuX2xhdGVuY3kgPSBudWxsO1xuICAgIHRoaXMuc3RhbGxDb3VudCA9IDA7XG4gIH1cbiAgb25MZXZlbFVwZGF0ZWQoZXZlbnQsIHtcbiAgICBkZXRhaWxzXG4gIH0pIHtcbiAgICBpZiAoZGV0YWlscy5hZHZhbmNlZCkge1xuICAgICAgdGhpcy5vblRpbWV1cGRhdGUoKTtcbiAgICB9XG4gICAgaWYgKCFkZXRhaWxzLmxpdmUgJiYgdGhpcy5tZWRpYSkge1xuICAgICAgdGhpcy5tZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCd0aW1ldXBkYXRlJywgdGhpcy5vblRpbWV1cGRhdGUpO1xuICAgIH1cbiAgfVxuICBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF90aGlzJGxldmVsRGV0YWlscztcbiAgICBpZiAoZGF0YS5kZXRhaWxzICE9PSBFcnJvckRldGFpbHMuQlVGRkVSX1NUQUxMRURfRVJST1IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdGFsbENvdW50Kys7XG4gICAgaWYgKHRoaXMuaGxzICYmIChfdGhpcyRsZXZlbERldGFpbHMgPSB0aGlzLmxldmVsRGV0YWlscykgIT0gbnVsbCAmJiBfdGhpcyRsZXZlbERldGFpbHMubGl2ZSkge1xuICAgICAgdGhpcy5obHMubG9nZ2VyLndhcm4oJ1tsYXRlbmN5LWNvbnRyb2xsZXJdOiBTdGFsbCBkZXRlY3RlZCwgYWRqdXN0aW5nIHRhcmdldCBsYXRlbmN5Jyk7XG4gICAgfVxuICB9XG4gIGNoYW5nZU1lZGlhUGxheWJhY2tSYXRlKG1lZGlhLCBwbGF5YmFja1JhdGUpIHtcbiAgICB2YXIgX3RoaXMkaGxzMiwgX3RoaXMkdGFyZ2V0TGF0ZW5jeTtcbiAgICBpZiAobWVkaWEucGxheWJhY2tSYXRlID09PSBwbGF5YmFja1JhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgKF90aGlzJGhsczIgPSB0aGlzLmhscykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGhsczIubG9nZ2VyLmRlYnVnKGBbbGF0ZW5jeS1jb250cm9sbGVyXTogbGF0ZW5jeT0ke3RoaXMubGF0ZW5jeS50b0ZpeGVkKDMpfSwgdGFyZ2V0TGF0ZW5jeT0keyhfdGhpcyR0YXJnZXRMYXRlbmN5ID0gdGhpcy50YXJnZXRMYXRlbmN5KSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkdGFyZ2V0TGF0ZW5jeS50b0ZpeGVkKDMpfSwgZm9yd2FyZEJ1ZmZlckxlbmd0aD0ke3RoaXMuZm9yd2FyZEJ1ZmZlckxlbmd0aC50b0ZpeGVkKDMpfTogYWRqdXN0aW5nIHBsYXliYWNrIHJhdGUgZnJvbSAke21lZGlhLnBsYXliYWNrUmF0ZX0gdG8gJHtwbGF5YmFja1JhdGV9YCk7XG4gICAgbWVkaWEucGxheWJhY2tSYXRlID0gcGxheWJhY2tSYXRlO1xuICB9XG4gIGVzdGltYXRlTGl2ZUVkZ2UoKSB7XG4gICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gdGhpcy5sZXZlbERldGFpbHM7XG4gICAgaWYgKGxldmVsRGV0YWlscyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBsZXZlbERldGFpbHMuZWRnZSArIGxldmVsRGV0YWlscy5hZ2U7XG4gIH1cbiAgY29tcHV0ZUxhdGVuY3koKSB7XG4gICAgY29uc3QgbGl2ZUVkZ2UgPSB0aGlzLmVzdGltYXRlTGl2ZUVkZ2UoKTtcbiAgICBpZiAobGl2ZUVkZ2UgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbGl2ZUVkZ2UgLSB0aGlzLmN1cnJlbnRUaW1lO1xuICB9XG59XG5cbmNsYXNzIExldmVsQ29udHJvbGxlciBleHRlbmRzIEJhc2VQbGF5bGlzdENvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihobHMsIGNvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXIpIHtcbiAgICBzdXBlcihobHMsICdsZXZlbC1jb250cm9sbGVyJyk7XG4gICAgdGhpcy5fbGV2ZWxzID0gW107XG4gICAgdGhpcy5fZmlyc3RMZXZlbCA9IC0xO1xuICAgIHRoaXMuX21heEF1dG9MZXZlbCA9IC0xO1xuICAgIHRoaXMuX3N0YXJ0TGV2ZWwgPSB2b2lkIDA7XG4gICAgdGhpcy5jdXJyZW50TGV2ZWwgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudExldmVsSW5kZXggPSAtMTtcbiAgICB0aGlzLm1hbnVhbExldmVsSW5kZXggPSAtMTtcbiAgICB0aGlzLnN0ZWVyaW5nID0gdm9pZCAwO1xuICAgIHRoaXMub25QYXJzZWRDb21wbGV0ZSA9IHZvaWQgMDtcbiAgICB0aGlzLnN0ZWVyaW5nID0gY29udGVudFN0ZWVyaW5nQ29udHJvbGxlcjtcbiAgICB0aGlzLl9yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIF9yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxTX1VQREFURUQsIHRoaXMub25MZXZlbHNVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH1cbiAgX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTFNfVVBEQVRFRCwgdGhpcy5vbkxldmVsc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fdW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHRoaXMuc3RlZXJpbmcgPSBudWxsO1xuICAgIHRoaXMucmVzZXRMZXZlbHMoKTtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gIH1cbiAgc3RvcExvYWQoKSB7XG4gICAgY29uc3QgbGV2ZWxzID0gdGhpcy5fbGV2ZWxzO1xuXG4gICAgLy8gY2xlYW4gdXAgbGl2ZSBsZXZlbCBkZXRhaWxzIHRvIGZvcmNlIHJlbG9hZCB0aGVtLCBhbmQgcmVzZXQgbG9hZCBlcnJvcnNcbiAgICBsZXZlbHMuZm9yRWFjaChsZXZlbCA9PiB7XG4gICAgICBsZXZlbC5sb2FkRXJyb3IgPSAwO1xuICAgICAgbGV2ZWwuZnJhZ21lbnRFcnJvciA9IDA7XG4gICAgfSk7XG4gICAgc3VwZXIuc3RvcExvYWQoKTtcbiAgfVxuICByZXNldExldmVscygpIHtcbiAgICB0aGlzLl9zdGFydExldmVsID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWFudWFsTGV2ZWxJbmRleCA9IC0xO1xuICAgIHRoaXMuY3VycmVudExldmVsSW5kZXggPSAtMTtcbiAgICB0aGlzLmN1cnJlbnRMZXZlbCA9IG51bGw7XG4gICAgdGhpcy5fbGV2ZWxzID0gW107XG4gICAgdGhpcy5fbWF4QXV0b0xldmVsID0gLTE7XG4gIH1cbiAgb25NYW5pZmVzdExvYWRpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLnJlc2V0TGV2ZWxzKCk7XG4gIH1cbiAgb25NYW5pZmVzdExvYWRlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSA9IHRoaXMuaGxzLmNvbmZpZy5wcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2U7XG4gICAgY29uc3QgbGV2ZWxzID0gW107XG4gICAgY29uc3QgcmVkdW5kYW50U2V0ID0ge307XG4gICAgY29uc3QgZ2VuZXJhdGVQYXRod2F5U2V0ID0ge307XG4gICAgbGV0IHJlc29sdXRpb25Gb3VuZCA9IGZhbHNlO1xuICAgIGxldCB2aWRlb0NvZGVjRm91bmQgPSBmYWxzZTtcbiAgICBsZXQgYXVkaW9Db2RlY0ZvdW5kID0gZmFsc2U7XG4gICAgZGF0YS5sZXZlbHMuZm9yRWFjaChsZXZlbFBhcnNlZCA9PiB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gbGV2ZWxQYXJzZWQuYXR0cnM7XG4gICAgICBsZXQge1xuICAgICAgICBhdWRpb0NvZGVjLFxuICAgICAgICB2aWRlb0NvZGVjXG4gICAgICB9ID0gbGV2ZWxQYXJzZWQ7XG4gICAgICBpZiAoYXVkaW9Db2RlYykge1xuICAgICAgICAvLyBSZXR1cm5zIGVtcHR5IGFuZCBzZXQgdG8gdW5kZWZpbmVkIGZvciAnbXA0YS40MC4zNCcgd2l0aCBmYWxsYmFjayB0byAnYXVkaW8vbXBlZycgU291cmNlQnVmZmVyXG4gICAgICAgIGxldmVsUGFyc2VkLmF1ZGlvQ29kZWMgPSBhdWRpb0NvZGVjID0gZ2V0Q29kZWNDb21wYXRpYmxlTmFtZShhdWRpb0NvZGVjLCBwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UpIHx8IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmICh2aWRlb0NvZGVjKSB7XG4gICAgICAgIHZpZGVvQ29kZWMgPSBsZXZlbFBhcnNlZC52aWRlb0NvZGVjID0gY29udmVydEFWQzFUb0FWQ09USSh2aWRlb0NvZGVjKTtcbiAgICAgIH1cblxuICAgICAgLy8gb25seSBrZWVwIGxldmVscyB3aXRoIHN1cHBvcnRlZCBhdWRpby92aWRlbyBjb2RlY3NcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgdW5rbm93bkNvZGVjc1xuICAgICAgfSA9IGxldmVsUGFyc2VkO1xuICAgICAgbGV0IHVua25vd25VbnN1cHBvcnRlZENvZGVjQ291bnQgPSB1bmtub3duQ29kZWNzID8gdW5rbm93bkNvZGVjcy5sZW5ndGggOiAwO1xuICAgICAgaWYgKHVua25vd25Db2RlY3MpIHtcbiAgICAgICAgLy8gVHJlYXQgdW5rbm93biBjb2RlYyBhcyBhdWRpbyBvciB2aWRlbyBjb2RlYyBiYXNlZCBvbiBwYXNzaW5nIGBpc1R5cGVTdXBwb3J0ZWRgIGNoZWNrXG4gICAgICAgIC8vIChhbGxvd3MgZm9yIHBsYXliYWNrIG9mIGFueSBzdXBwb3J0ZWQgY29kZWMgZXZlbiBpZiBub3QgaW5kZXhlZCBpbiB1dGlscy9jb2RlY3MpXG4gICAgICAgIGZvciAobGV0IGkgPSB1bmtub3duVW5zdXBwb3J0ZWRDb2RlY0NvdW50OyBpLS07KSB7XG4gICAgICAgICAgY29uc3QgdW5rbm93bkNvZGVjID0gdW5rbm93bkNvZGVjc1tpXTtcbiAgICAgICAgICBpZiAodGhpcy5pc0F1ZGlvU3VwcG9ydGVkKHVua25vd25Db2RlYykpIHtcbiAgICAgICAgICAgIGxldmVsUGFyc2VkLmF1ZGlvQ29kZWMgPSBhdWRpb0NvZGVjID0gYXVkaW9Db2RlYyA/IGAke2F1ZGlvQ29kZWN9LCR7dW5rbm93bkNvZGVjfWAgOiB1bmtub3duQ29kZWM7XG4gICAgICAgICAgICB1bmtub3duVW5zdXBwb3J0ZWRDb2RlY0NvdW50LS07XG4gICAgICAgICAgICBzYW1wbGVFbnRyeUNvZGVzSVNPLmF1ZGlvW2F1ZGlvQ29kZWMuc3Vic3RyaW5nKDAsIDQpXSA9IDI7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzVmlkZW9TdXBwb3J0ZWQodW5rbm93bkNvZGVjKSkge1xuICAgICAgICAgICAgbGV2ZWxQYXJzZWQudmlkZW9Db2RlYyA9IHZpZGVvQ29kZWMgPSB2aWRlb0NvZGVjID8gYCR7dmlkZW9Db2RlY30sJHt1bmtub3duQ29kZWN9YCA6IHVua25vd25Db2RlYztcbiAgICAgICAgICAgIHVua25vd25VbnN1cHBvcnRlZENvZGVjQ291bnQtLTtcbiAgICAgICAgICAgIHNhbXBsZUVudHJ5Q29kZXNJU08udmlkZW9bdmlkZW9Db2RlYy5zdWJzdHJpbmcoMCwgNCldID0gMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc29sdXRpb25Gb3VuZCB8fCAocmVzb2x1dGlvbkZvdW5kID0gISEod2lkdGggJiYgaGVpZ2h0KSk7XG4gICAgICB2aWRlb0NvZGVjRm91bmQgfHwgKHZpZGVvQ29kZWNGb3VuZCA9ICEhdmlkZW9Db2RlYyk7XG4gICAgICBhdWRpb0NvZGVjRm91bmQgfHwgKGF1ZGlvQ29kZWNGb3VuZCA9ICEhYXVkaW9Db2RlYyk7XG4gICAgICBpZiAodW5rbm93blVuc3VwcG9ydGVkQ29kZWNDb3VudCB8fCBhdWRpb0NvZGVjICYmICF0aGlzLmlzQXVkaW9TdXBwb3J0ZWQoYXVkaW9Db2RlYykgfHwgdmlkZW9Db2RlYyAmJiAhdGhpcy5pc1ZpZGVvU3VwcG9ydGVkKHZpZGVvQ29kZWMpKSB7XG4gICAgICAgIHRoaXMubG9nKGBTb21lIG9yIGFsbCBDT0RFQ1Mgbm90IHN1cHBvcnRlZCBcIiR7YXR0cmlidXRlcy5DT0RFQ1N9XCJgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBDT0RFQ1MsXG4gICAgICAgICdGUkFNRS1SQVRFJzogRlJBTUVSQVRFLFxuICAgICAgICAnSERDUC1MRVZFTCc6IEhEQ1AsXG4gICAgICAgICdQQVRIV0FZLUlEJzogUEFUSFdBWSxcbiAgICAgICAgUkVTT0xVVElPTixcbiAgICAgICAgJ1ZJREVPLVJBTkdFJzogVklERU9fUkFOR0VcbiAgICAgIH0gPSBhdHRyaWJ1dGVzO1xuICAgICAgY29uc3QgY29udGVudFN0ZWVyaW5nUHJlZml4ID0gYCR7UEFUSFdBWSB8fCAnLid9LWA7XG4gICAgICBjb25zdCBsZXZlbEtleSA9IGAke2NvbnRlbnRTdGVlcmluZ1ByZWZpeH0ke2xldmVsUGFyc2VkLmJpdHJhdGV9LSR7UkVTT0xVVElPTn0tJHtGUkFNRVJBVEV9LSR7Q09ERUNTfS0ke1ZJREVPX1JBTkdFfS0ke0hEQ1B9YDtcbiAgICAgIGlmICghcmVkdW5kYW50U2V0W2xldmVsS2V5XSkge1xuICAgICAgICBjb25zdCBsZXZlbCA9IHRoaXMuY3JlYXRlTGV2ZWwobGV2ZWxQYXJzZWQpO1xuICAgICAgICByZWR1bmRhbnRTZXRbbGV2ZWxLZXldID0gbGV2ZWw7XG4gICAgICAgIGdlbmVyYXRlUGF0aHdheVNldFtsZXZlbEtleV0gPSAxO1xuICAgICAgICBsZXZlbHMucHVzaChsZXZlbCk7XG4gICAgICB9IGVsc2UgaWYgKHJlZHVuZGFudFNldFtsZXZlbEtleV0udXJpICE9PSBsZXZlbFBhcnNlZC51cmwgJiYgIWxldmVsUGFyc2VkLmF0dHJzWydQQVRIV0FZLUlEJ10pIHtcbiAgICAgICAgLy8gQXNzaWduIFBhdGh3YXkgSURzIHRvIFJlZHVuZGFudCBTdHJlYW1zIChkZWZhdWx0IFBhdGh3YXlzIGlzIFwiLlwiLiBSZWR1bmRhbnQgU3RyZWFtcyBcIi4uXCIsIFwiLi4uXCIsIGFuZCBzbyBvbi4pXG4gICAgICAgIC8vIENvbnRlbnQgU3RlZXJpbmcgY29udHJvbGxlciB0byBoYW5kbGVzIFBhdGh3YXkgZmFsbGJhY2sgb24gZXJyb3JcbiAgICAgICAgY29uc3QgcGF0aHdheUNvdW50ID0gZ2VuZXJhdGVQYXRod2F5U2V0W2xldmVsS2V5XSArPSAxO1xuICAgICAgICBsZXZlbFBhcnNlZC5hdHRyc1snUEFUSFdBWS1JRCddID0gbmV3IEFycmF5KHBhdGh3YXlDb3VudCArIDEpLmpvaW4oJy4nKTtcbiAgICAgICAgY29uc3QgbGV2ZWwgPSB0aGlzLmNyZWF0ZUxldmVsKGxldmVsUGFyc2VkKTtcbiAgICAgICAgcmVkdW5kYW50U2V0W2xldmVsS2V5XSA9IGxldmVsO1xuICAgICAgICBsZXZlbHMucHVzaChsZXZlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWR1bmRhbnRTZXRbbGV2ZWxLZXldLmFkZEdyb3VwSWQoJ2F1ZGlvJywgYXR0cmlidXRlcy5BVURJTyk7XG4gICAgICAgIHJlZHVuZGFudFNldFtsZXZlbEtleV0uYWRkR3JvdXBJZCgndGV4dCcsIGF0dHJpYnV0ZXMuU1VCVElUTEVTKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmZpbHRlckFuZFNvcnRNZWRpYU9wdGlvbnMobGV2ZWxzLCBkYXRhLCByZXNvbHV0aW9uRm91bmQsIHZpZGVvQ29kZWNGb3VuZCwgYXVkaW9Db2RlY0ZvdW5kKTtcbiAgfVxuICBjcmVhdGVMZXZlbChsZXZlbFBhcnNlZCkge1xuICAgIGNvbnN0IGxldmVsID0gbmV3IExldmVsKGxldmVsUGFyc2VkKTtcbiAgICBjb25zdCBzdXBwbGVtZW50YWwgPSBsZXZlbFBhcnNlZC5zdXBwbGVtZW50YWw7XG4gICAgaWYgKHN1cHBsZW1lbnRhbCAhPSBudWxsICYmIHN1cHBsZW1lbnRhbC52aWRlb0NvZGVjICYmICF0aGlzLmlzVmlkZW9TdXBwb3J0ZWQoc3VwcGxlbWVudGFsLnZpZGVvQ29kZWMpKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgU1VQUExFTUVOVEFMLUNPREVDUyBub3Qgc3VwcG9ydGVkIFwiJHtzdXBwbGVtZW50YWwudmlkZW9Db2RlY31cImApO1xuICAgICAgdGhpcy5sb2coZXJyb3IubWVzc2FnZSk7XG4gICAgICBsZXZlbC5zdXBwb3J0ZWRSZXN1bHQgPSBnZXRVbnN1cHBvcnRlZFJlc3VsdChlcnJvciwgW10pO1xuICAgIH1cbiAgICByZXR1cm4gbGV2ZWw7XG4gIH1cbiAgaXNBdWRpb1N1cHBvcnRlZChjb2RlYykge1xuICAgIHJldHVybiBhcmVDb2RlY3NNZWRpYVNvdXJjZVN1cHBvcnRlZChjb2RlYywgJ2F1ZGlvJywgdGhpcy5obHMuY29uZmlnLnByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSk7XG4gIH1cbiAgaXNWaWRlb1N1cHBvcnRlZChjb2RlYykge1xuICAgIHJldHVybiBhcmVDb2RlY3NNZWRpYVNvdXJjZVN1cHBvcnRlZChjb2RlYywgJ3ZpZGVvJywgdGhpcy5obHMuY29uZmlnLnByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSk7XG4gIH1cbiAgZmlsdGVyQW5kU29ydE1lZGlhT3B0aW9ucyhmaWx0ZXJlZExldmVscywgZGF0YSwgcmVzb2x1dGlvbkZvdW5kLCB2aWRlb0NvZGVjRm91bmQsIGF1ZGlvQ29kZWNGb3VuZCkge1xuICAgIGxldCBhdWRpb1RyYWNrcyA9IFtdO1xuICAgIGxldCBzdWJ0aXRsZVRyYWNrcyA9IFtdO1xuICAgIGxldCBsZXZlbHMgPSBmaWx0ZXJlZExldmVscztcblxuICAgIC8vIHJlbW92ZSBhdWRpby1vbmx5IGFuZCBpbnZhbGlkIHZpZGVvLXJhbmdlIGxldmVscyBpZiB3ZSBhbHNvIGhhdmUgbGV2ZWxzIHdpdGggdmlkZW8gY29kZWNzIG9yIFJFU09MVVRJT04gc2lnbmFsbGVkXG4gICAgaWYgKChyZXNvbHV0aW9uRm91bmQgfHwgdmlkZW9Db2RlY0ZvdW5kKSAmJiBhdWRpb0NvZGVjRm91bmQpIHtcbiAgICAgIGxldmVscyA9IGxldmVscy5maWx0ZXIoKHtcbiAgICAgICAgdmlkZW9Db2RlYyxcbiAgICAgICAgdmlkZW9SYW5nZSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSkgPT4gKCEhdmlkZW9Db2RlYyB8fCAhISh3aWR0aCAmJiBoZWlnaHQpKSAmJiBpc1ZpZGVvUmFuZ2UodmlkZW9SYW5nZSkpO1xuICAgIH1cbiAgICBpZiAobGV2ZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gRGlzcGF0Y2ggZXJyb3IgYWZ0ZXIgTUFOSUZFU1RfTE9BREVEIGlzIGRvbmUgcHJvcGFnYXRpbmdcbiAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5obHMpIHtcbiAgICAgICAgICBsZXQgbWVzc2FnZSA9ICdubyBsZXZlbCB3aXRoIGNvbXBhdGlibGUgY29kZWNzIGZvdW5kIGluIG1hbmlmZXN0JztcbiAgICAgICAgICBsZXQgcmVhc29uID0gbWVzc2FnZTtcbiAgICAgICAgICBpZiAoZGF0YS5sZXZlbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZWFzb24gPSBgb25lIG9yIG1vcmUgQ09ERUNTIGluIHZhcmlhbnQgbm90IHN1cHBvcnRlZDogJHtzdHJpbmdpZnkoZGF0YS5sZXZlbHMubWFwKGxldmVsID0+IGxldmVsLmF0dHJzLkNPREVDUykuZmlsdGVyKCh2YWx1ZSwgaW5kZXgsIGFycmF5KSA9PiBhcnJheS5pbmRleE9mKHZhbHVlKSA9PT0gaW5kZXgpKX1gO1xuICAgICAgICAgICAgdGhpcy53YXJuKHJlYXNvbik7XG4gICAgICAgICAgICBtZXNzYWdlICs9IGAgKCR7cmVhc29ufSlgO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5NQU5JRkVTVF9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SLFxuICAgICAgICAgICAgZmF0YWw6IHRydWUsXG4gICAgICAgICAgICB1cmw6IGRhdGEudXJsLFxuICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICByZWFzb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkYXRhLmF1ZGlvVHJhY2tzKSB7XG4gICAgICBhdWRpb1RyYWNrcyA9IGRhdGEuYXVkaW9UcmFja3MuZmlsdGVyKHRyYWNrID0+ICF0cmFjay5hdWRpb0NvZGVjIHx8IHRoaXMuaXNBdWRpb1N1cHBvcnRlZCh0cmFjay5hdWRpb0NvZGVjKSk7XG4gICAgICAvLyBBc3NpZ24gaWRzIGFmdGVyIGZpbHRlcmluZyBhcyBhcnJheSBpbmRpY2VzIGJ5IGdyb3VwLWlkXG4gICAgICBhc3NpZ25UcmFja0lkc0J5R3JvdXAoYXVkaW9UcmFja3MpO1xuICAgIH1cbiAgICBpZiAoZGF0YS5zdWJ0aXRsZXMpIHtcbiAgICAgIHN1YnRpdGxlVHJhY2tzID0gZGF0YS5zdWJ0aXRsZXM7XG4gICAgICBhc3NpZ25UcmFja0lkc0J5R3JvdXAoc3VidGl0bGVUcmFja3MpO1xuICAgIH1cbiAgICAvLyBzdGFydCBiaXRyYXRlIGlzIHRoZSBmaXJzdCBiaXRyYXRlIG9mIHRoZSBtYW5pZmVzdFxuICAgIGNvbnN0IHVuc29ydGVkTGV2ZWxzID0gbGV2ZWxzLnNsaWNlKDApO1xuICAgIC8vIHNvcnQgbGV2ZWxzIGZyb20gbG93ZXN0IHRvIGhpZ2hlc3RcbiAgICBsZXZlbHMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgaWYgKGEuYXR0cnNbJ0hEQ1AtTEVWRUwnXSAhPT0gYi5hdHRyc1snSERDUC1MRVZFTCddKSB7XG4gICAgICAgIHJldHVybiAoYS5hdHRyc1snSERDUC1MRVZFTCddIHx8ICcnKSA+IChiLmF0dHJzWydIRENQLUxFVkVMJ10gfHwgJycpID8gMSA6IC0xO1xuICAgICAgfVxuICAgICAgLy8gc29ydCBvbiBoZWlnaHQgYmVmb3JlIGJpdHJhdGUgZm9yIGNhcC1sZXZlbC1jb250cm9sbGVyXG4gICAgICBpZiAocmVzb2x1dGlvbkZvdW5kICYmIGEuaGVpZ2h0ICE9PSBiLmhlaWdodCkge1xuICAgICAgICByZXR1cm4gYS5oZWlnaHQgLSBiLmhlaWdodDtcbiAgICAgIH1cbiAgICAgIGlmIChhLmZyYW1lUmF0ZSAhPT0gYi5mcmFtZVJhdGUpIHtcbiAgICAgICAgcmV0dXJuIGEuZnJhbWVSYXRlIC0gYi5mcmFtZVJhdGU7XG4gICAgICB9XG4gICAgICBpZiAoYS52aWRlb1JhbmdlICE9PSBiLnZpZGVvUmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIFZpZGVvUmFuZ2VWYWx1ZXMuaW5kZXhPZihhLnZpZGVvUmFuZ2UpIC0gVmlkZW9SYW5nZVZhbHVlcy5pbmRleE9mKGIudmlkZW9SYW5nZSk7XG4gICAgICB9XG4gICAgICBpZiAoYS52aWRlb0NvZGVjICE9PSBiLnZpZGVvQ29kZWMpIHtcbiAgICAgICAgY29uc3QgdmFsdWVBID0gdmlkZW9Db2RlY1ByZWZlcmVuY2VWYWx1ZShhLnZpZGVvQ29kZWMpO1xuICAgICAgICBjb25zdCB2YWx1ZUIgPSB2aWRlb0NvZGVjUHJlZmVyZW5jZVZhbHVlKGIudmlkZW9Db2RlYyk7XG4gICAgICAgIGlmICh2YWx1ZUEgIT09IHZhbHVlQikge1xuICAgICAgICAgIHJldHVybiB2YWx1ZUIgLSB2YWx1ZUE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhLnVyaSA9PT0gYi51cmkgJiYgYS5jb2RlY1NldCAhPT0gYi5jb2RlY1NldCkge1xuICAgICAgICBjb25zdCB2YWx1ZUEgPSBjb2RlY3NTZXRTZWxlY3Rpb25QcmVmZXJlbmNlVmFsdWUoYS5jb2RlY1NldCk7XG4gICAgICAgIGNvbnN0IHZhbHVlQiA9IGNvZGVjc1NldFNlbGVjdGlvblByZWZlcmVuY2VWYWx1ZShiLmNvZGVjU2V0KTtcbiAgICAgICAgaWYgKHZhbHVlQSAhPT0gdmFsdWVCKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlQiAtIHZhbHVlQTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGEuYXZlcmFnZUJpdHJhdGUgIT09IGIuYXZlcmFnZUJpdHJhdGUpIHtcbiAgICAgICAgcmV0dXJuIGEuYXZlcmFnZUJpdHJhdGUgLSBiLmF2ZXJhZ2VCaXRyYXRlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSk7XG4gICAgbGV0IGZpcnN0TGV2ZWxJblBsYXlsaXN0ID0gdW5zb3J0ZWRMZXZlbHNbMF07XG4gICAgaWYgKHRoaXMuc3RlZXJpbmcpIHtcbiAgICAgIGxldmVscyA9IHRoaXMuc3RlZXJpbmcuZmlsdGVyUGFyc2VkTGV2ZWxzKGxldmVscyk7XG4gICAgICBpZiAobGV2ZWxzLmxlbmd0aCAhPT0gdW5zb3J0ZWRMZXZlbHMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdW5zb3J0ZWRMZXZlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodW5zb3J0ZWRMZXZlbHNbaV0ucGF0aHdheUlkID09PSBsZXZlbHNbMF0ucGF0aHdheUlkKSB7XG4gICAgICAgICAgICBmaXJzdExldmVsSW5QbGF5bGlzdCA9IHVuc29ydGVkTGV2ZWxzW2ldO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2xldmVscyA9IGxldmVscztcblxuICAgIC8vIGZpbmQgaW5kZXggb2YgZmlyc3QgbGV2ZWwgaW4gc29ydGVkIGxldmVsc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGV2ZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGV2ZWxzW2ldID09PSBmaXJzdExldmVsSW5QbGF5bGlzdCkge1xuICAgICAgICB2YXIgX3RoaXMkaGxzJHVzZXJDb25maWc7XG4gICAgICAgIHRoaXMuX2ZpcnN0TGV2ZWwgPSBpO1xuICAgICAgICBjb25zdCBmaXJzdExldmVsQml0cmF0ZSA9IGZpcnN0TGV2ZWxJblBsYXlsaXN0LmJpdHJhdGU7XG4gICAgICAgIGNvbnN0IGJhbmR3aWR0aEVzdGltYXRlID0gdGhpcy5obHMuYmFuZHdpZHRoRXN0aW1hdGU7XG4gICAgICAgIHRoaXMubG9nKGBtYW5pZmVzdCBsb2FkZWQsICR7bGV2ZWxzLmxlbmd0aH0gbGV2ZWwocykgZm91bmQsIGZpcnN0IGJpdHJhdGU6ICR7Zmlyc3RMZXZlbEJpdHJhdGV9YCk7XG4gICAgICAgIC8vIFVwZGF0ZSBkZWZhdWx0IGJ3ZSB0byBmaXJzdCB2YXJpYW50IGJpdHJhdGUgYXMgbG9uZyBpdCBoYXMgbm90IGJlZW4gY29uZmlndXJlZCBvciBzZXRcbiAgICAgICAgaWYgKCgoX3RoaXMkaGxzJHVzZXJDb25maWcgPSB0aGlzLmhscy51c2VyQ29uZmlnKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkaGxzJHVzZXJDb25maWcuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZSkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbnN0IHN0YXJ0aW5nQndFc3RpbWF0ZSA9IE1hdGgubWluKGZpcnN0TGV2ZWxCaXRyYXRlLCB0aGlzLmhscy5jb25maWcuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZU1heCk7XG4gICAgICAgICAgaWYgKHN0YXJ0aW5nQndFc3RpbWF0ZSA+IGJhbmR3aWR0aEVzdGltYXRlICYmIGJhbmR3aWR0aEVzdGltYXRlID09PSB0aGlzLmhscy5hYnJFd21hRGVmYXVsdEVzdGltYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmhscy5iYW5kd2lkdGhFc3RpbWF0ZSA9IHN0YXJ0aW5nQndFc3RpbWF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQXVkaW8gaXMgb25seSBhbHRlcm5hdGUgaWYgbWFuaWZlc3QgaW5jbHVkZSBhIFVSSSBhbG9uZyB3aXRoIHRoZSBhdWRpbyBncm91cCB0YWcsXG4gICAgLy8gYW5kIHRoaXMgaXMgbm90IGFuIGF1ZGlvLW9ubHkgc3RyZWFtIHdoZXJlIGxldmVscyBjb250YWluIGF1ZGlvLW9ubHlcbiAgICBjb25zdCBhdWRpb09ubHkgPSBhdWRpb0NvZGVjRm91bmQgJiYgIXZpZGVvQ29kZWNGb3VuZDtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG4gICAgY29uc3QgYWx0QXVkaW9FbmFibGVkID0gISEoY29uZmlnLmF1ZGlvU3RyZWFtQ29udHJvbGxlciAmJiBjb25maWcuYXVkaW9UcmFja0NvbnRyb2xsZXIpO1xuICAgIGNvbnN0IGVkYXRhID0ge1xuICAgICAgbGV2ZWxzLFxuICAgICAgYXVkaW9UcmFja3MsXG4gICAgICBzdWJ0aXRsZVRyYWNrcyxcbiAgICAgIHNlc3Npb25EYXRhOiBkYXRhLnNlc3Npb25EYXRhLFxuICAgICAgc2Vzc2lvbktleXM6IGRhdGEuc2Vzc2lvbktleXMsXG4gICAgICBmaXJzdExldmVsOiB0aGlzLl9maXJzdExldmVsLFxuICAgICAgc3RhdHM6IGRhdGEuc3RhdHMsXG4gICAgICBhdWRpbzogYXVkaW9Db2RlY0ZvdW5kLFxuICAgICAgdmlkZW86IHZpZGVvQ29kZWNGb3VuZCxcbiAgICAgIGFsdEF1ZGlvOiBhbHRBdWRpb0VuYWJsZWQgJiYgIWF1ZGlvT25seSAmJiBhdWRpb1RyYWNrcy5zb21lKHQgPT4gISF0LnVybClcbiAgICB9O1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgZWRhdGEpO1xuICB9XG4gIGdldCBsZXZlbHMoKSB7XG4gICAgaWYgKHRoaXMuX2xldmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbGV2ZWxzO1xuICB9XG4gIGdldCBsb2FkTGV2ZWxPYmooKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudExldmVsO1xuICB9XG4gIGdldCBsZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50TGV2ZWxJbmRleDtcbiAgfVxuICBzZXQgbGV2ZWwobmV3TGV2ZWwpIHtcbiAgICBjb25zdCBsZXZlbHMgPSB0aGlzLl9sZXZlbHM7XG4gICAgaWYgKGxldmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gY2hlY2sgaWYgbGV2ZWwgaWR4IGlzIHZhbGlkXG4gICAgaWYgKG5ld0xldmVsIDwgMCB8fCBuZXdMZXZlbCA+PSBsZXZlbHMubGVuZ3RoKSB7XG4gICAgICAvLyBpbnZhbGlkIGxldmVsIGlkIGdpdmVuLCB0cmlnZ2VyIGVycm9yXG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignaW52YWxpZCBsZXZlbCBpZHgnKTtcbiAgICAgIGNvbnN0IGZhdGFsID0gbmV3TGV2ZWwgPCAwO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5PVEhFUl9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkxFVkVMX1NXSVRDSF9FUlJPUixcbiAgICAgICAgbGV2ZWw6IG5ld0xldmVsLFxuICAgICAgICBmYXRhbCxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZVxuICAgICAgfSk7XG4gICAgICBpZiAoZmF0YWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbmV3TGV2ZWwgPSBNYXRoLm1pbihuZXdMZXZlbCwgbGV2ZWxzLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICBjb25zdCBsYXN0TGV2ZWxJbmRleCA9IHRoaXMuY3VycmVudExldmVsSW5kZXg7XG4gICAgY29uc3QgbGFzdExldmVsID0gdGhpcy5jdXJyZW50TGV2ZWw7XG4gICAgY29uc3QgbGFzdFBhdGh3YXlJZCA9IGxhc3RMZXZlbCA/IGxhc3RMZXZlbC5hdHRyc1snUEFUSFdBWS1JRCddIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IGxldmVsID0gbGV2ZWxzW25ld0xldmVsXTtcbiAgICBjb25zdCBwYXRod2F5SWQgPSBsZXZlbC5hdHRyc1snUEFUSFdBWS1JRCddO1xuICAgIHRoaXMuY3VycmVudExldmVsSW5kZXggPSBuZXdMZXZlbDtcbiAgICB0aGlzLmN1cnJlbnRMZXZlbCA9IGxldmVsO1xuICAgIGlmIChsYXN0TGV2ZWxJbmRleCA9PT0gbmV3TGV2ZWwgJiYgbGFzdExldmVsICYmIGxhc3RQYXRod2F5SWQgPT09IHBhdGh3YXlJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxvZyhgU3dpdGNoaW5nIHRvIGxldmVsICR7bmV3TGV2ZWx9ICgke2xldmVsLmhlaWdodCA/IGxldmVsLmhlaWdodCArICdwICcgOiAnJ30ke2xldmVsLnZpZGVvUmFuZ2UgPyBsZXZlbC52aWRlb1JhbmdlICsgJyAnIDogJyd9JHtsZXZlbC5jb2RlY1NldCA/IGxldmVsLmNvZGVjU2V0ICsgJyAnIDogJyd9QCR7bGV2ZWwuYml0cmF0ZX0pJHtwYXRod2F5SWQgPyAnIHdpdGggUGF0aHdheSAnICsgcGF0aHdheUlkIDogJyd9IGZyb20gbGV2ZWwgJHtsYXN0TGV2ZWxJbmRleH0ke2xhc3RQYXRod2F5SWQgPyAnIHdpdGggUGF0aHdheSAnICsgbGFzdFBhdGh3YXlJZCA6ICcnfWApO1xuICAgIGNvbnN0IGxldmVsU3dpdGNoaW5nRGF0YSA9IHtcbiAgICAgIGxldmVsOiBuZXdMZXZlbCxcbiAgICAgIGF0dHJzOiBsZXZlbC5hdHRycyxcbiAgICAgIGRldGFpbHM6IGxldmVsLmRldGFpbHMsXG4gICAgICBiaXRyYXRlOiBsZXZlbC5iaXRyYXRlLFxuICAgICAgYXZlcmFnZUJpdHJhdGU6IGxldmVsLmF2ZXJhZ2VCaXRyYXRlLFxuICAgICAgbWF4Qml0cmF0ZTogbGV2ZWwubWF4Qml0cmF0ZSxcbiAgICAgIHJlYWxCaXRyYXRlOiBsZXZlbC5yZWFsQml0cmF0ZSxcbiAgICAgIHdpZHRoOiBsZXZlbC53aWR0aCxcbiAgICAgIGhlaWdodDogbGV2ZWwuaGVpZ2h0LFxuICAgICAgY29kZWNTZXQ6IGxldmVsLmNvZGVjU2V0LFxuICAgICAgYXVkaW9Db2RlYzogbGV2ZWwuYXVkaW9Db2RlYyxcbiAgICAgIHZpZGVvQ29kZWM6IGxldmVsLnZpZGVvQ29kZWMsXG4gICAgICBhdWRpb0dyb3VwczogbGV2ZWwuYXVkaW9Hcm91cHMsXG4gICAgICBzdWJ0aXRsZUdyb3VwczogbGV2ZWwuc3VidGl0bGVHcm91cHMsXG4gICAgICBsb2FkZWQ6IGxldmVsLmxvYWRlZCxcbiAgICAgIGxvYWRFcnJvcjogbGV2ZWwubG9hZEVycm9yLFxuICAgICAgZnJhZ21lbnRFcnJvcjogbGV2ZWwuZnJhZ21lbnRFcnJvcixcbiAgICAgIG5hbWU6IGxldmVsLm5hbWUsXG4gICAgICBpZDogbGV2ZWwuaWQsXG4gICAgICB1cmk6IGxldmVsLnVyaSxcbiAgICAgIHVybDogbGV2ZWwudXJsLFxuICAgICAgdXJsSWQ6IDAsXG4gICAgICBhdWRpb0dyb3VwSWRzOiBsZXZlbC5hdWRpb0dyb3VwSWRzLFxuICAgICAgdGV4dEdyb3VwSWRzOiBsZXZlbC50ZXh0R3JvdXBJZHNcbiAgICB9O1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkxFVkVMX1NXSVRDSElORywgbGV2ZWxTd2l0Y2hpbmdEYXRhKTtcbiAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIGxvYWQgcGxheWxpc3QgZm9yIHRoaXMgbGV2ZWxcbiAgICBjb25zdCBsZXZlbERldGFpbHMgPSBsZXZlbC5kZXRhaWxzO1xuICAgIGlmICghbGV2ZWxEZXRhaWxzIHx8IGxldmVsRGV0YWlscy5saXZlKSB7XG4gICAgICAvLyBsZXZlbCBub3QgcmV0cmlldmVkIHlldCwgb3IgbGl2ZSBwbGF5bGlzdCB3ZSBuZWVkIHRvIChyZSlsb2FkIGl0XG4gICAgICBjb25zdCBobHNVcmxQYXJhbWV0ZXJzID0gdGhpcy5zd2l0Y2hQYXJhbXMobGV2ZWwudXJpLCBsYXN0TGV2ZWwgPT0gbnVsbCA/IHZvaWQgMCA6IGxhc3RMZXZlbC5kZXRhaWxzLCBsZXZlbERldGFpbHMpO1xuICAgICAgdGhpcy5sb2FkUGxheWxpc3QoaGxzVXJsUGFyYW1ldGVycyk7XG4gICAgfVxuICB9XG4gIGdldCBtYW51YWxMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYW51YWxMZXZlbEluZGV4O1xuICB9XG4gIHNldCBtYW51YWxMZXZlbChuZXdMZXZlbCkge1xuICAgIHRoaXMubWFudWFsTGV2ZWxJbmRleCA9IG5ld0xldmVsO1xuICAgIGlmICh0aGlzLl9zdGFydExldmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3N0YXJ0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB9XG4gICAgaWYgKG5ld0xldmVsICE9PSAtMSkge1xuICAgICAgdGhpcy5sZXZlbCA9IG5ld0xldmVsO1xuICAgIH1cbiAgfVxuICBnZXQgZmlyc3RMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlyc3RMZXZlbDtcbiAgfVxuICBzZXQgZmlyc3RMZXZlbChuZXdMZXZlbCkge1xuICAgIHRoaXMuX2ZpcnN0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgfVxuICBnZXQgc3RhcnRMZXZlbCgpIHtcbiAgICAvLyBTZXR0aW5nIGhscy5zdGFydExldmVsICh0aGlzLl9zdGFydExldmVsKSBvdmVycmlkZXMgY29uZmlnLnN0YXJ0TGV2ZWxcbiAgICBpZiAodGhpcy5fc3RhcnRMZXZlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBjb25maWdTdGFydExldmVsID0gdGhpcy5obHMuY29uZmlnLnN0YXJ0TGV2ZWw7XG4gICAgICBpZiAoY29uZmlnU3RhcnRMZXZlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBjb25maWdTdGFydExldmVsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuaGxzLmZpcnN0QXV0b0xldmVsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc3RhcnRMZXZlbDtcbiAgfVxuICBzZXQgc3RhcnRMZXZlbChuZXdMZXZlbCkge1xuICAgIHRoaXMuX3N0YXJ0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgfVxuICBnZXQgcGF0aHdheXMoKSB7XG4gICAgaWYgKHRoaXMuc3RlZXJpbmcpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0ZWVyaW5nLnBhdGh3YXlzKCk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuICBnZXQgcGF0aHdheVByaW9yaXR5KCkge1xuICAgIGlmICh0aGlzLnN0ZWVyaW5nKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGVlcmluZy5wYXRod2F5UHJpb3JpdHk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHNldCBwYXRod2F5UHJpb3JpdHkocGF0aHdheVByaW9yaXR5KSB7XG4gICAgaWYgKHRoaXMuc3RlZXJpbmcpIHtcbiAgICAgIGNvbnN0IHBhdGh3YXlzTGlzdCA9IHRoaXMuc3RlZXJpbmcucGF0aHdheXMoKTtcbiAgICAgIGNvbnN0IGZpbHRlcmVkUGF0aHdheVByaW9yaXR5ID0gcGF0aHdheVByaW9yaXR5LmZpbHRlcihwYXRod2F5SWQgPT4ge1xuICAgICAgICByZXR1cm4gcGF0aHdheXNMaXN0LmluZGV4T2YocGF0aHdheUlkKSAhPT0gLTE7XG4gICAgICB9KTtcbiAgICAgIGlmIChwYXRod2F5UHJpb3JpdHkubGVuZ3RoIDwgMSkge1xuICAgICAgICB0aGlzLndhcm4oYHBhdGh3YXlQcmlvcml0eSAke3BhdGh3YXlQcmlvcml0eX0gc2hvdWxkIGNvbnRhaW4gYXQgbGVhc3Qgb25lIHBhdGh3YXkgZnJvbSBsaXN0OiAke3BhdGh3YXlzTGlzdH1gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGVlcmluZy5wYXRod2F5UHJpb3JpdHkgPSBmaWx0ZXJlZFBhdGh3YXlQcmlvcml0eTtcbiAgICB9XG4gIH1cbiAgb25FcnJvcihldmVudCwgZGF0YSkge1xuICAgIGlmIChkYXRhLmZhdGFsIHx8ICFkYXRhLmNvbnRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRhdGEuY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLkxFVkVMICYmIGRhdGEuY29udGV4dC5sZXZlbCA9PT0gdGhpcy5sZXZlbCkge1xuICAgICAgdGhpcy5jaGVja1JldHJ5KGRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHJlc2V0IGVycm9ycyBvbiB0aGUgc3VjY2Vzc2Z1bCBsb2FkIG9mIGEgZnJhZ21lbnRcbiAgb25GcmFnQnVmZmVyZWQoZXZlbnQsIHtcbiAgICBmcmFnXG4gIH0pIHtcbiAgICBpZiAoZnJhZyAhPT0gdW5kZWZpbmVkICYmIGZyYWcudHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTikge1xuICAgICAgY29uc3QgZWwgPSBmcmFnLmVsZW1lbnRhcnlTdHJlYW1zO1xuICAgICAgaWYgKCFPYmplY3Qua2V5cyhlbCkuc29tZSh0eXBlID0+ICEhZWxbdHlwZV0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxldmVsID0gdGhpcy5fbGV2ZWxzW2ZyYWcubGV2ZWxdO1xuICAgICAgaWYgKGxldmVsICE9IG51bGwgJiYgbGV2ZWwubG9hZEVycm9yKSB7XG4gICAgICAgIHRoaXMubG9nKGBSZXNldHRpbmcgbGV2ZWwgZXJyb3IgY291bnQgb2YgJHtsZXZlbC5sb2FkRXJyb3J9IG9uIGZyYWcgYnVmZmVyZWRgKTtcbiAgICAgICAgbGV2ZWwubG9hZEVycm9yID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgb25MZXZlbExvYWRlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBfZGF0YSRkZWxpdmVyeURpcmVjdGkyO1xuICAgIGNvbnN0IHtcbiAgICAgIGxldmVsLFxuICAgICAgZGV0YWlsc1xuICAgIH0gPSBkYXRhO1xuICAgIGNvbnN0IGN1ckxldmVsID0gZGF0YS5sZXZlbEluZm87XG4gICAgaWYgKCFjdXJMZXZlbCkge1xuICAgICAgdmFyIF9kYXRhJGRlbGl2ZXJ5RGlyZWN0aTtcbiAgICAgIHRoaXMud2FybihgSW52YWxpZCBsZXZlbCBpbmRleCAke2xldmVsfWApO1xuICAgICAgaWYgKChfZGF0YSRkZWxpdmVyeURpcmVjdGkgPSBkYXRhLmRlbGl2ZXJ5RGlyZWN0aXZlcykgIT0gbnVsbCAmJiBfZGF0YSRkZWxpdmVyeURpcmVjdGkuc2tpcCkge1xuICAgICAgICBkZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBvbmx5IHByb2Nlc3MgbGV2ZWwgbG9hZGVkIGV2ZW50cyBtYXRjaGluZyB3aXRoIGV4cGVjdGVkIGxldmVsIG9yIHByaW9yIHRvIHN3aXRjaCB3aGVuIG1lZGlhIHBsYXlsaXN0IGlzIGxvYWRlZCBkaXJlY3RseVxuICAgIGlmIChjdXJMZXZlbCA9PT0gdGhpcy5jdXJyZW50TGV2ZWwgfHwgZGF0YS53aXRob3V0TXVsdGlWYXJpYW50KSB7XG4gICAgICAvLyByZXNldCBsZXZlbCBsb2FkIGVycm9yIGNvdW50ZXIgb24gc3VjY2Vzc2Z1bCBsZXZlbCBsb2FkZWQgb25seSBpZiB0aGVyZSBpcyBubyBpc3N1ZXMgd2l0aCBmcmFnbWVudHNcbiAgICAgIGlmIChjdXJMZXZlbC5mcmFnbWVudEVycm9yID09PSAwKSB7XG4gICAgICAgIGN1ckxldmVsLmxvYWRFcnJvciA9IDA7XG4gICAgICB9XG4gICAgICAvLyBJZ25vcmUgbWF0Y2hpbmcgZGV0YWlscyBwb3B1bGF0ZWQgYnkgbG9hZGluZyBhIE1lZGlhIFBsYXlsaXN0IGRpcmVjdGx5XG4gICAgICBsZXQgcHJldmlvdXNEZXRhaWxzID0gY3VyTGV2ZWwuZGV0YWlscztcbiAgICAgIGlmIChwcmV2aW91c0RldGFpbHMgPT09IGRhdGEuZGV0YWlscyAmJiBwcmV2aW91c0RldGFpbHMuYWR2YW5jZWQpIHtcbiAgICAgICAgcHJldmlvdXNEZXRhaWxzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdGhpcy5wbGF5bGlzdExvYWRlZChsZXZlbCwgZGF0YSwgcHJldmlvdXNEZXRhaWxzKTtcbiAgICB9IGVsc2UgaWYgKChfZGF0YSRkZWxpdmVyeURpcmVjdGkyID0gZGF0YS5kZWxpdmVyeURpcmVjdGl2ZXMpICE9IG51bGwgJiYgX2RhdGEkZGVsaXZlcnlEaXJlY3RpMi5za2lwKSB7XG4gICAgICAvLyByZWNlaXZlZCBhIGRlbHRhIHBsYXlsaXN0IHVwZGF0ZSB0aGF0IGNhbm5vdCBiZSBtZXJnZWRcbiAgICAgIGRldGFpbHMuZGVsdGFVcGRhdGVGYWlsZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBsb2FkUGxheWxpc3QoaGxzVXJsUGFyYW1ldGVycykge1xuICAgIHN1cGVyLmxvYWRQbGF5bGlzdCgpO1xuICAgIGlmICh0aGlzLnNob3VsZExvYWRQbGF5bGlzdCh0aGlzLmN1cnJlbnRMZXZlbCkpIHtcbiAgICAgIHRoaXMuc2NoZWR1bGVMb2FkaW5nKHRoaXMuY3VycmVudExldmVsLCBobHNVcmxQYXJhbWV0ZXJzKTtcbiAgICB9XG4gIH1cbiAgbG9hZGluZ1BsYXlsaXN0KGN1cnJlbnRMZXZlbCwgaGxzVXJsUGFyYW1ldGVycykge1xuICAgIHN1cGVyLmxvYWRpbmdQbGF5bGlzdChjdXJyZW50TGV2ZWwsIGhsc1VybFBhcmFtZXRlcnMpO1xuICAgIGNvbnN0IHVybCA9IHRoaXMuZ2V0VXJsV2l0aERpcmVjdGl2ZXMoY3VycmVudExldmVsLnVyaSwgaGxzVXJsUGFyYW1ldGVycyk7XG4gICAgY29uc3QgY3VycmVudExldmVsSW5kZXggPSB0aGlzLmN1cnJlbnRMZXZlbEluZGV4O1xuICAgIGNvbnN0IHBhdGh3YXlJZCA9IGN1cnJlbnRMZXZlbC5hdHRyc1snUEFUSFdBWS1JRCddO1xuICAgIGNvbnN0IGRldGFpbHMgPSBjdXJyZW50TGV2ZWwuZGV0YWlscztcbiAgICBjb25zdCBhZ2UgPSBkZXRhaWxzID09IG51bGwgPyB2b2lkIDAgOiBkZXRhaWxzLmFnZTtcbiAgICB0aGlzLmxvZyhgTG9hZGluZyBsZXZlbCBpbmRleCAke2N1cnJlbnRMZXZlbEluZGV4fSR7KGhsc1VybFBhcmFtZXRlcnMgPT0gbnVsbCA/IHZvaWQgMCA6IGhsc1VybFBhcmFtZXRlcnMubXNuKSAhPT0gdW5kZWZpbmVkID8gJyBhdCBzbiAnICsgaGxzVXJsUGFyYW1ldGVycy5tc24gKyAnIHBhcnQgJyArIGhsc1VybFBhcmFtZXRlcnMucGFydCA6ICcnfSR7cGF0aHdheUlkID8gJyBQYXRod2F5ICcgKyBwYXRod2F5SWQgOiAnJ30ke2FnZSAmJiBkZXRhaWxzLmxpdmUgPyAnIGFnZSAnICsgYWdlLnRvRml4ZWQoMSkgKyAoZGV0YWlscy50eXBlID8gJyAnICsgZGV0YWlscy50eXBlIHx8ICcnIDogJycpIDogJyd9ICR7dXJsfWApO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkxFVkVMX0xPQURJTkcsIHtcbiAgICAgIHVybCxcbiAgICAgIGxldmVsOiBjdXJyZW50TGV2ZWxJbmRleCxcbiAgICAgIGxldmVsSW5mbzogY3VycmVudExldmVsLFxuICAgICAgcGF0aHdheUlkOiBjdXJyZW50TGV2ZWwuYXR0cnNbJ1BBVEhXQVktSUQnXSxcbiAgICAgIGlkOiAwLFxuICAgICAgLy8gRGVwcmVjYXRlZCBMZXZlbCB1cmxJZFxuICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzOiBobHNVcmxQYXJhbWV0ZXJzIHx8IG51bGxcbiAgICB9KTtcbiAgfVxuICBnZXQgbmV4dExvYWRMZXZlbCgpIHtcbiAgICBpZiAodGhpcy5tYW51YWxMZXZlbEluZGV4ICE9PSAtMSkge1xuICAgICAgcmV0dXJuIHRoaXMubWFudWFsTGV2ZWxJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuaGxzLm5leHRBdXRvTGV2ZWw7XG4gICAgfVxuICB9XG4gIHNldCBuZXh0TG9hZExldmVsKG5leHRMZXZlbCkge1xuICAgIHRoaXMubGV2ZWwgPSBuZXh0TGV2ZWw7XG4gICAgaWYgKHRoaXMubWFudWFsTGV2ZWxJbmRleCA9PT0gLTEpIHtcbiAgICAgIHRoaXMuaGxzLm5leHRBdXRvTGV2ZWwgPSBuZXh0TGV2ZWw7XG4gICAgfVxuICB9XG4gIHJlbW92ZUxldmVsKGxldmVsSW5kZXgpIHtcbiAgICB2YXIgX3RoaXMkY3VycmVudExldmVsO1xuICAgIGlmICh0aGlzLl9sZXZlbHMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxldmVscyA9IHRoaXMuX2xldmVscy5maWx0ZXIoKGxldmVsLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGluZGV4ICE9PSBsZXZlbEluZGV4KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3RlZXJpbmcpIHtcbiAgICAgICAgdGhpcy5zdGVlcmluZy5yZW1vdmVMZXZlbChsZXZlbCk7XG4gICAgICB9XG4gICAgICBpZiAobGV2ZWwgPT09IHRoaXMuY3VycmVudExldmVsKSB7XG4gICAgICAgIHRoaXMuY3VycmVudExldmVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50TGV2ZWxJbmRleCA9IC0xO1xuICAgICAgICBpZiAobGV2ZWwuZGV0YWlscykge1xuICAgICAgICAgIGxldmVsLmRldGFpbHMuZnJhZ21lbnRzLmZvckVhY2goZiA9PiBmLmxldmVsID0gLTEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gICAgcmVhc3NpZ25GcmFnbWVudExldmVsSW5kZXhlcyhsZXZlbHMpO1xuICAgIHRoaXMuX2xldmVscyA9IGxldmVscztcbiAgICBpZiAodGhpcy5jdXJyZW50TGV2ZWxJbmRleCA+IC0xICYmIChfdGhpcyRjdXJyZW50TGV2ZWwgPSB0aGlzLmN1cnJlbnRMZXZlbCkgIT0gbnVsbCAmJiBfdGhpcyRjdXJyZW50TGV2ZWwuZGV0YWlscykge1xuICAgICAgdGhpcy5jdXJyZW50TGV2ZWxJbmRleCA9IHRoaXMuY3VycmVudExldmVsLmRldGFpbHMuZnJhZ21lbnRzWzBdLmxldmVsO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYW51YWxMZXZlbEluZGV4ID4gLTEpIHtcbiAgICAgIHRoaXMubWFudWFsTGV2ZWxJbmRleCA9IHRoaXMuY3VycmVudExldmVsSW5kZXg7XG4gICAgfVxuICAgIGNvbnN0IG1heExldmVsID0gbGV2ZWxzLmxlbmd0aCAtIDE7XG4gICAgdGhpcy5fZmlyc3RMZXZlbCA9IE1hdGgubWluKHRoaXMuX2ZpcnN0TGV2ZWwsIG1heExldmVsKTtcbiAgICBpZiAodGhpcy5fc3RhcnRMZXZlbCkge1xuICAgICAgdGhpcy5fc3RhcnRMZXZlbCA9IE1hdGgubWluKHRoaXMuX3N0YXJ0TGV2ZWwsIG1heExldmVsKTtcbiAgICB9XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTEVWRUxTX1VQREFURUQsIHtcbiAgICAgIGxldmVsc1xuICAgIH0pO1xuICB9XG4gIG9uTGV2ZWxzVXBkYXRlZChldmVudCwge1xuICAgIGxldmVsc1xuICB9KSB7XG4gICAgdGhpcy5fbGV2ZWxzID0gbGV2ZWxzO1xuICB9XG4gIGNoZWNrTWF4QXV0b1VwZGF0ZWQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgYXV0b0xldmVsQ2FwcGluZyxcbiAgICAgIG1heEF1dG9MZXZlbCxcbiAgICAgIG1heEhkY3BMZXZlbFxuICAgIH0gPSB0aGlzLmhscztcbiAgICBpZiAodGhpcy5fbWF4QXV0b0xldmVsICE9PSBtYXhBdXRvTGV2ZWwpIHtcbiAgICAgIHRoaXMuX21heEF1dG9MZXZlbCA9IG1heEF1dG9MZXZlbDtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLk1BWF9BVVRPX0xFVkVMX1VQREFURUQsIHtcbiAgICAgICAgYXV0b0xldmVsQ2FwcGluZyxcbiAgICAgICAgbGV2ZWxzOiB0aGlzLmxldmVscyxcbiAgICAgICAgbWF4QXV0b0xldmVsLFxuICAgICAgICBtaW5BdXRvTGV2ZWw6IHRoaXMuaGxzLm1pbkF1dG9MZXZlbCxcbiAgICAgICAgbWF4SGRjcExldmVsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2lnblRyYWNrSWRzQnlHcm91cCh0cmFja3MpIHtcbiAgY29uc3QgZ3JvdXBzID0ge307XG4gIHRyYWNrcy5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICBjb25zdCBncm91cElkID0gdHJhY2suZ3JvdXBJZCB8fCAnJztcbiAgICB0cmFjay5pZCA9IGdyb3Vwc1tncm91cElkXSA9IGdyb3Vwc1tncm91cElkXSB8fCAwO1xuICAgIGdyb3Vwc1tncm91cElkXSsrO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlQnVmZmVyKCkge1xuICByZXR1cm4gc2VsZi5Tb3VyY2VCdWZmZXIgfHwgc2VsZi5XZWJLaXRTb3VyY2VCdWZmZXI7XG59XG5mdW5jdGlvbiBpc01TRVN1cHBvcnRlZCgpIHtcbiAgY29uc3QgbWVkaWFTb3VyY2UgPSBnZXRNZWRpYVNvdXJjZSgpO1xuICBpZiAoIW1lZGlhU291cmNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gaWYgU291cmNlQnVmZmVyIGlzIGV4cG9zZWQgZW5zdXJlIGl0cyBBUEkgaXMgdmFsaWRcbiAgLy8gT2xkZXIgYnJvd3NlcnMgZG8gbm90IGV4cG9zZSBTb3VyY2VCdWZmZXIgZ2xvYmFsbHkgc28gY2hlY2tpbmcgU291cmNlQnVmZmVyLnByb3RvdHlwZSBpcyBpbXBvc3NpYmxlXG4gIGNvbnN0IHNvdXJjZUJ1ZmZlciA9IGdldFNvdXJjZUJ1ZmZlcigpO1xuICByZXR1cm4gIXNvdXJjZUJ1ZmZlciB8fCBzb3VyY2VCdWZmZXIucHJvdG90eXBlICYmIHR5cGVvZiBzb3VyY2VCdWZmZXIucHJvdG90eXBlLmFwcGVuZEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc291cmNlQnVmZmVyLnByb3RvdHlwZS5yZW1vdmUgPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBpc1N1cHBvcnRlZCgpIHtcbiAgaWYgKCFpc01TRVN1cHBvcnRlZCgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IG1lZGlhU291cmNlID0gZ2V0TWVkaWFTb3VyY2UoKTtcbiAgcmV0dXJuIHR5cGVvZiAobWVkaWFTb3VyY2UgPT0gbnVsbCA/IHZvaWQgMCA6IG1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCkgPT09ICdmdW5jdGlvbicgJiYgKFsnYXZjMS40MkUwMUUsbXA0YS40MC4yJywgJ2F2MDEuMC4wMU0uMDgnLCAndnAwOS4wMC41MC4wOCddLnNvbWUoY29kZWNzRm9yVmlkZW9Db250YWluZXIgPT4gbWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKG1pbWVUeXBlRm9yQ29kZWMoY29kZWNzRm9yVmlkZW9Db250YWluZXIsICd2aWRlbycpKSkgfHwgWydtcDRhLjQwLjInLCAnZkxhQyddLnNvbWUoY29kZWNGb3JBdWRpb0NvbnRhaW5lciA9PiBtZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQobWltZVR5cGVGb3JDb2RlYyhjb2RlY0ZvckF1ZGlvQ29udGFpbmVyLCAnYXVkaW8nKSkpKTtcbn1cbmZ1bmN0aW9uIGNoYW5nZVR5cGVTdXBwb3J0ZWQoKSB7XG4gIHZhciBfc291cmNlQnVmZmVyJHByb3RvdHk7XG4gIGNvbnN0IHNvdXJjZUJ1ZmZlciA9IGdldFNvdXJjZUJ1ZmZlcigpO1xuICByZXR1cm4gdHlwZW9mIChzb3VyY2VCdWZmZXIgPT0gbnVsbCA/IHZvaWQgMCA6IChfc291cmNlQnVmZmVyJHByb3RvdHkgPSBzb3VyY2VCdWZmZXIucHJvdG90eXBlKSA9PSBudWxsID8gdm9pZCAwIDogX3NvdXJjZUJ1ZmZlciRwcm90b3R5LmNoYW5nZVR5cGUpID09PSAnZnVuY3Rpb24nO1xufVxuXG5jb25zdCBUSUNLX0lOVEVSVkFMID0gMTAwOyAvLyBob3cgb2Z0ZW4gdG8gdGljayBpbiBtc1xuXG5jbGFzcyBTdHJlYW1Db250cm9sbGVyIGV4dGVuZHMgQmFzZVN0cmVhbUNvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihobHMsIGZyYWdtZW50VHJhY2tlciwga2V5TG9hZGVyKSB7XG4gICAgc3VwZXIoaGxzLCBmcmFnbWVudFRyYWNrZXIsIGtleUxvYWRlciwgJ3N0cmVhbS1jb250cm9sbGVyJywgUGxheWxpc3RMZXZlbFR5cGUuTUFJTik7XG4gICAgdGhpcy5hdWRpb0NvZGVjU3dhcCA9IGZhbHNlO1xuICAgIHRoaXMubGV2ZWwgPSAtMTtcbiAgICB0aGlzLl9mb3JjZVN0YXJ0TG9hZCA9IGZhbHNlO1xuICAgIHRoaXMuX2hhc0Vub3VnaFRvU3RhcnQgPSBmYWxzZTtcbiAgICB0aGlzLmFsdEF1ZGlvID0gMDtcbiAgICB0aGlzLmF1ZGlvT25seSA9IGZhbHNlO1xuICAgIHRoaXMuZnJhZ1BsYXlpbmcgPSBudWxsO1xuICAgIHRoaXMuZnJhZ0xhc3RLYnBzID0gMDtcbiAgICB0aGlzLmNvdWxkQmFja3RyYWNrID0gZmFsc2U7XG4gICAgdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IG51bGw7XG4gICAgdGhpcy5hdWRpb0NvZGVjU3dpdGNoID0gZmFsc2U7XG4gICAgdGhpcy52aWRlb0J1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5vbk1lZGlhUGxheWluZyA9ICgpID0+IHtcbiAgICAgIC8vIHRpY2sgdG8gc3BlZWQgdXAgRlJBR19DSEFOR0VEIHRyaWdnZXJpbmdcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH07XG4gICAgdGhpcy5vbk1lZGlhU2Vla2VkID0gKCkgPT4ge1xuICAgICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYSA/IG1lZGlhLmN1cnJlbnRUaW1lIDogbnVsbDtcbiAgICAgIGlmIChjdXJyZW50VGltZSA9PT0gbnVsbCB8fCAhaXNGaW5pdGVOdW1iZXIoY3VycmVudFRpbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nKGBNZWRpYSBzZWVrZWQgdG8gJHtjdXJyZW50VGltZS50b0ZpeGVkKDMpfWApO1xuXG4gICAgICAvLyBJZiBzZWVrZWQgd2FzIGlzc3VlZCBiZWZvcmUgYnVmZmVyIHdhcyBhcHBlbmRlZCBkbyBub3QgdGljayBpbW1lZGlhdGVseVxuICAgICAgaWYgKCF0aGlzLmdldEJ1ZmZlcmVkRnJhZyhjdXJyZW50VGltZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgYnVmZmVySW5mbyA9IHRoaXMuZ2V0RndkQnVmZmVySW5mb0F0UG9zKG1lZGlhLCBjdXJyZW50VGltZSwgUGxheWxpc3RMZXZlbFR5cGUuTUFJTiwgMCk7XG4gICAgICBpZiAoYnVmZmVySW5mbyA9PT0gbnVsbCB8fCBidWZmZXJJbmZvLmxlbiA9PT0gMCkge1xuICAgICAgICB0aGlzLndhcm4oYE1haW4gZm9yd2FyZCBidWZmZXIgbGVuZ3RoIGF0ICR7Y3VycmVudFRpbWV9IG9uIFwic2Vla2VkXCIgZXZlbnQgJHtidWZmZXJJbmZvID8gYnVmZmVySW5mby5sZW4gOiAnZW1wdHknfSlgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyB0aWNrIHRvIHNwZWVkIHVwIEZSQUdfQ0hBTkdFRCB0cmlnZ2VyaW5nXG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9O1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBzdXBlci5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxfTE9BRElORywgdGhpcy5vbkxldmVsTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQsIHRoaXMub25GcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENISU5HLCB0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hFRCwgdGhpcy5vbkF1ZGlvVHJhY2tTd2l0Y2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfQ1JFQVRFRCwgdGhpcy5vbkJ1ZmZlckNyZWF0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0ZMVVNIRUQsIHRoaXMub25CdWZmZXJGbHVzaGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMU19VUERBVEVELCB0aGlzLm9uTGV2ZWxzVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgfVxuICB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHN1cGVyLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRCwgdGhpcy5vbkZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENISU5HLCB0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENIRUQsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9DUkVBVEVELCB0aGlzLm9uQnVmZmVyQ3JlYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0ZMVVNIRUQsIHRoaXMub25CdWZmZXJGbHVzaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTFNfVVBEQVRFRCwgdGhpcy5vbkxldmVsc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICB9XG4gIG9uSGFuZGxlckRlc3Ryb3lpbmcoKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMub25NZWRpYVBsYXlpbmcgPSB0aGlzLm9uTWVkaWFTZWVrZWQgPSBudWxsO1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHN1cGVyLm9uSGFuZGxlckRlc3Ryb3lpbmcoKTtcbiAgfVxuICBzdGFydExvYWQoc3RhcnRQb3NpdGlvbiwgc2tpcFNlZWtUb1N0YXJ0UG9zaXRpb24pIHtcbiAgICBpZiAodGhpcy5sZXZlbHMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGFzdEN1cnJlbnRUaW1lLFxuICAgICAgICBobHNcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgICAgdGhpcy5zZXRJbnRlcnZhbChUSUNLX0lOVEVSVkFMKTtcbiAgICAgIHRoaXMubGV2ZWwgPSAtMTtcbiAgICAgIGlmICghdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQpIHtcbiAgICAgICAgLy8gZGV0ZXJtaW5lIGxvYWQgbGV2ZWxcbiAgICAgICAgbGV0IHN0YXJ0TGV2ZWwgPSBobHMuc3RhcnRMZXZlbDtcbiAgICAgICAgaWYgKHN0YXJ0TGV2ZWwgPT09IC0xKSB7XG4gICAgICAgICAgaWYgKGhscy5jb25maWcudGVzdEJhbmR3aWR0aCAmJiB0aGlzLmxldmVscy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAvLyAtMSA6IGd1ZXNzIHN0YXJ0IExldmVsIGJ5IGRvaW5nIGEgYml0cmF0ZSB0ZXN0IGJ5IGxvYWRpbmcgZmlyc3QgZnJhZ21lbnQgb2YgbG93ZXN0IHF1YWxpdHkgbGV2ZWxcbiAgICAgICAgICAgIHN0YXJ0TGV2ZWwgPSAwO1xuICAgICAgICAgICAgdGhpcy5iaXRyYXRlVGVzdCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0TGV2ZWwgPSBobHMuZmlyc3RBdXRvTGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHNldCBuZXcgbGV2ZWwgdG8gcGxheWxpc3QgbG9hZGVyIDogdGhpcyB3aWxsIHRyaWdnZXIgc3RhcnQgbGV2ZWwgbG9hZFxuICAgICAgICAvLyBobHMubmV4dExvYWRMZXZlbCByZW1haW5zIHVudGlsIGl0IGlzIHNldCB0byBhIG5ldyB2YWx1ZSBvciB1bnRpbCBhIG5ldyBmcmFnIGlzIHN1Y2Nlc3NmdWxseSBsb2FkZWRcbiAgICAgICAgaGxzLm5leHRMb2FkTGV2ZWwgPSBzdGFydExldmVsO1xuICAgICAgICB0aGlzLmxldmVsID0gaGxzLmxvYWRMZXZlbDtcbiAgICAgICAgdGhpcy5faGFzRW5vdWdoVG9TdGFydCA9ICEhc2tpcFNlZWtUb1N0YXJ0UG9zaXRpb247XG4gICAgICB9XG4gICAgICAvLyBpZiBzdGFydFBvc2l0aW9uIHVuZGVmaW5lZCBidXQgbGFzdEN1cnJlbnRUaW1lIHNldCwgc2V0IHN0YXJ0UG9zaXRpb24gdG8gbGFzdCBjdXJyZW50VGltZVxuICAgICAgaWYgKGxhc3RDdXJyZW50VGltZSA+IDAgJiYgc3RhcnRQb3NpdGlvbiA9PT0gLTEgJiYgIXNraXBTZWVrVG9TdGFydFBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMubG9nKGBPdmVycmlkZSBzdGFydFBvc2l0aW9uIHdpdGggbGFzdEN1cnJlbnRUaW1lIEAke2xhc3RDdXJyZW50VGltZS50b0ZpeGVkKDMpfWApO1xuICAgICAgICBzdGFydFBvc2l0aW9uID0gbGFzdEN1cnJlbnRUaW1lO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IHN0YXJ0UG9zaXRpb24gKyB0aGlzLnRpbWVsaW5lT2Zmc2V0O1xuICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc2tpcFNlZWtUb1N0YXJ0UG9zaXRpb24gPyAtMSA6IHN0YXJ0UG9zaXRpb247XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZm9yY2VTdGFydExvYWQgPSB0cnVlO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gICAgfVxuICB9XG4gIHN0b3BMb2FkKCkge1xuICAgIHRoaXMuX2ZvcmNlU3RhcnRMb2FkID0gZmFsc2U7XG4gICAgc3VwZXIuc3RvcExvYWQoKTtcbiAgfVxuICBkb1RpY2soKSB7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIFN0YXRlLldBSVRJTkdfTEVWRUw6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBsZXZlbHMsXG4gICAgICAgICAgICBsZXZlbFxuICAgICAgICAgIH0gPSB0aGlzO1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRMZXZlbCA9IGxldmVscyA9PSBudWxsID8gdm9pZCAwIDogbGV2ZWxzW2xldmVsXTtcbiAgICAgICAgICBjb25zdCBkZXRhaWxzID0gY3VycmVudExldmVsID09IG51bGwgPyB2b2lkIDAgOiBjdXJyZW50TGV2ZWwuZGV0YWlscztcbiAgICAgICAgICBpZiAoZGV0YWlscyAmJiAoIWRldGFpbHMubGl2ZSB8fCB0aGlzLmxldmVsTGFzdExvYWRlZCA9PT0gY3VycmVudExldmVsICYmICF0aGlzLndhaXRGb3JMaXZlKGN1cnJlbnRMZXZlbCkpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy53YWl0Rm9yQ2RuVHVuZUluKGRldGFpbHMpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaGxzLm5leHRMb2FkTGV2ZWwgIT09IHRoaXMubGV2ZWwpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIFN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF90aGlzJG1lZGlhO1xuICAgICAgICAgIGNvbnN0IG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgY29uc3QgcmV0cnlEYXRlID0gdGhpcy5yZXRyeURhdGU7XG4gICAgICAgICAgLy8gaWYgY3VycmVudCB0aW1lIGlzIGd0IHRoYW4gcmV0cnlEYXRlLCBvciBpZiBtZWRpYSBzZWVraW5nIGxldCdzIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIHJldHJ5IGxvYWRpbmdcbiAgICAgICAgICBpZiAoIXJldHJ5RGF0ZSB8fCBub3cgPj0gcmV0cnlEYXRlIHx8IChfdGhpcyRtZWRpYSA9IHRoaXMubWVkaWEpICE9IG51bGwgJiYgX3RoaXMkbWVkaWEuc2Vla2luZykge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBsZXZlbHMsXG4gICAgICAgICAgICAgIGxldmVsXG4gICAgICAgICAgICB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRMZXZlbCA9IGxldmVscyA9PSBudWxsID8gdm9pZCAwIDogbGV2ZWxzW2xldmVsXTtcbiAgICAgICAgICAgIHRoaXMucmVzZXRTdGFydFdoZW5Ob3RMb2FkZWQoY3VycmVudExldmVsIHx8IG51bGwpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuSURMRSkge1xuICAgICAgdGhpcy5kb1RpY2tJZGxlKCk7XG4gICAgfVxuICAgIHRoaXMub25UaWNrRW5kKCk7XG4gIH1cbiAgb25UaWNrRW5kKCkge1xuICAgIHZhciBfdGhpcyRtZWRpYTI7XG4gICAgc3VwZXIub25UaWNrRW5kKCk7XG4gICAgaWYgKChfdGhpcyRtZWRpYTIgPSB0aGlzLm1lZGlhKSAhPSBudWxsICYmIF90aGlzJG1lZGlhMi5yZWFkeVN0YXRlICYmIHRoaXMubWVkaWEuc2Vla2luZyA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gdGhpcy5tZWRpYS5jdXJyZW50VGltZTtcbiAgICB9XG4gICAgdGhpcy5jaGVja0ZyYWdtZW50Q2hhbmdlZCgpO1xuICB9XG4gIGRvVGlja0lkbGUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzLFxuICAgICAgbGV2ZWxMYXN0TG9hZGVkLFxuICAgICAgbGV2ZWxzLFxuICAgICAgbWVkaWFcbiAgICB9ID0gdGhpcztcblxuICAgIC8vIGlmIHN0YXJ0IGxldmVsIG5vdCBwYXJzZWQgeWV0IE9SXG4gICAgLy8gaWYgdmlkZW8gbm90IGF0dGFjaGVkIEFORCBzdGFydCBmcmFnbWVudCBhbHJlYWR5IHJlcXVlc3RlZCBPUiBzdGFydCBmcmFnIHByZWZldGNoIG5vdCBlbmFibGVkXG4gICAgLy8gZXhpdCBsb29wLCBhcyB3ZSBlaXRoZXIgbmVlZCBtb3JlIGluZm8gKGxldmVsIG5vdCBwYXJzZWQpIG9yIHdlIG5lZWQgbWVkaWEgdG8gYmUgYXR0YWNoZWQgdG8gbG9hZCBuZXcgZnJhZ21lbnRcbiAgICBpZiAobGV2ZWxMYXN0TG9hZGVkID09PSBudWxsIHx8ICFtZWRpYSAmJiAhdGhpcy5wcmltYXJ5UHJlZmV0Y2ggJiYgKHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkIHx8ICFobHMuY29uZmlnLnN0YXJ0RnJhZ1ByZWZldGNoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBcIm1haW5cIiBsZXZlbCBpcyBhdWRpby1vbmx5IGJ1dCB3ZSBhcmUgbG9hZGluZyBhbiBhbHRlcm5hdGUgdHJhY2sgaW4gdGhlIHNhbWUgZ3JvdXAsIGRvIG5vdCBsb2FkIGFueXRoaW5nXG4gICAgaWYgKHRoaXMuYWx0QXVkaW8gJiYgdGhpcy5hdWRpb09ubHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGV2ZWwgPSB0aGlzLmJ1ZmZlcmluZyA/IGhscy5uZXh0TG9hZExldmVsIDogaGxzLmxvYWRMZXZlbDtcbiAgICBpZiAoIShsZXZlbHMgIT0gbnVsbCAmJiBsZXZlbHNbbGV2ZWxdKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsZXZlbEluZm8gPSBsZXZlbHNbbGV2ZWxdO1xuXG4gICAgLy8gaWYgYnVmZmVyIGxlbmd0aCBpcyBsZXNzIHRoYW4gbWF4QnVmTGVuIHRyeSB0byBsb2FkIGEgbmV3IGZyYWdtZW50XG5cbiAgICBjb25zdCBidWZmZXJJbmZvID0gdGhpcy5nZXRNYWluRndkQnVmZmVySW5mbygpO1xuICAgIGlmIChidWZmZXJJbmZvID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxhc3REZXRhaWxzID0gdGhpcy5nZXRMZXZlbERldGFpbHMoKTtcbiAgICBpZiAobGFzdERldGFpbHMgJiYgdGhpcy5fc3RyZWFtRW5kZWQoYnVmZmVySW5mbywgbGFzdERldGFpbHMpKSB7XG4gICAgICBjb25zdCBkYXRhID0ge307XG4gICAgICBpZiAodGhpcy5hbHRBdWRpbyA9PT0gMikge1xuICAgICAgICBkYXRhLnR5cGUgPSAndmlkZW8nO1xuICAgICAgfVxuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0VPUywgZGF0YSk7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRU5ERUQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5idWZmZXJpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzZXQgbmV4dCBsb2FkIGxldmVsIDogdGhpcyB3aWxsIHRyaWdnZXIgYSBwbGF5bGlzdCBsb2FkIGlmIG5lZWRlZFxuICAgIGlmIChobHMubG9hZExldmVsICE9PSBsZXZlbCAmJiBobHMubWFudWFsTGV2ZWwgPT09IC0xKSB7XG4gICAgICB0aGlzLmxvZyhgQWRhcHRpbmcgdG8gbGV2ZWwgJHtsZXZlbH0gZnJvbSBsZXZlbCAke3RoaXMubGV2ZWx9YCk7XG4gICAgfVxuICAgIHRoaXMubGV2ZWwgPSBobHMubmV4dExvYWRMZXZlbCA9IGxldmVsO1xuICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IGxldmVsSW5mby5kZXRhaWxzO1xuICAgIC8vIGlmIGxldmVsIGluZm8gbm90IHJldHJpZXZlZCB5ZXQsIHN3aXRjaCBzdGF0ZSBhbmQgd2FpdCBmb3IgbGV2ZWwgcmV0cmlldmFsXG4gICAgLy8gaWYgbGl2ZSBwbGF5bGlzdCwgZW5zdXJlIHRoYXQgbmV3IHBsYXlsaXN0IGhhcyBiZWVuIHJlZnJlc2hlZCB0byBhdm9pZCBsb2FkaW5nL3RyeSB0byBsb2FkXG4gICAgLy8gYSB1c2VsZXNzIGFuZCBvdXRkYXRlZCBmcmFnbWVudCAodGhhdCBtaWdodCBldmVuIGludHJvZHVjZSBsb2FkIGVycm9yIGlmIGl0IGlzIGFscmVhZHkgb3V0IG9mIHRoZSBsaXZlIHBsYXlsaXN0KVxuICAgIGlmICghbGV2ZWxEZXRhaWxzIHx8IHRoaXMuc3RhdGUgPT09IFN0YXRlLldBSVRJTkdfTEVWRUwgfHwgdGhpcy53YWl0Rm9yTGl2ZShsZXZlbEluZm8pKSB7XG4gICAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19MRVZFTDtcbiAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlckxlbiA9IGJ1ZmZlckluZm8ubGVuO1xuXG4gICAgLy8gY29tcHV0ZSBtYXggQnVmZmVyIExlbmd0aCB0aGF0IHdlIGNvdWxkIGdldCBmcm9tIHRoaXMgbG9hZCBsZXZlbCwgYmFzZWQgb24gbGV2ZWwgYml0cmF0ZS4gZG9uJ3QgYnVmZmVyIG1vcmUgdGhhbiA2MCBNQiBhbmQgbW9yZSB0aGFuIDMwc1xuICAgIGNvbnN0IG1heEJ1ZkxlbiA9IHRoaXMuZ2V0TWF4QnVmZmVyTGVuZ3RoKGxldmVsSW5mby5tYXhCaXRyYXRlKTtcblxuICAgIC8vIFN0YXkgaWRsZSBpZiB3ZSBhcmUgc3RpbGwgd2l0aCBidWZmZXIgbWFyZ2luc1xuICAgIGlmIChidWZmZXJMZW4gPj0gbWF4QnVmTGVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmJhY2t0cmFja0ZyYWdtZW50ICYmIHRoaXMuYmFja3RyYWNrRnJhZ21lbnQuc3RhcnQgPiBidWZmZXJJbmZvLmVuZCkge1xuICAgICAgdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldEJ1ZmZlclRpbWUgPSB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ID8gdGhpcy5iYWNrdHJhY2tGcmFnbWVudC5zdGFydCA6IGJ1ZmZlckluZm8uZW5kO1xuICAgIGxldCBmcmFnID0gdGhpcy5nZXROZXh0RnJhZ21lbnQodGFyZ2V0QnVmZmVyVGltZSwgbGV2ZWxEZXRhaWxzKTtcbiAgICAvLyBBdm9pZCBiYWNrdHJhY2tpbmcgYnkgbG9hZGluZyBhbiBlYXJsaWVyIHNlZ21lbnQgaW4gc3RyZWFtcyB3aXRoIHNlZ21lbnRzIHRoYXQgZG8gbm90IHN0YXJ0IHdpdGggYSBrZXkgZnJhbWUgKGZsYWdnZWQgYnkgYGNvdWxkQmFja3RyYWNrYClcbiAgICBpZiAodGhpcy5jb3VsZEJhY2t0cmFjayAmJiAhdGhpcy5mcmFnUHJldmlvdXMgJiYgZnJhZyAmJiBpc01lZGlhRnJhZ21lbnQoZnJhZykgJiYgdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZykgIT09IEZyYWdtZW50U3RhdGUuT0spIHtcbiAgICAgIHZhciBfdGhpcyRiYWNrdHJhY2tGcmFnbWU7XG4gICAgICBjb25zdCBiYWNrdHJhY2tTbiA9ICgoX3RoaXMkYmFja3RyYWNrRnJhZ21lID0gdGhpcy5iYWNrdHJhY2tGcmFnbWVudCkgIT0gbnVsbCA/IF90aGlzJGJhY2t0cmFja0ZyYWdtZSA6IGZyYWcpLnNuO1xuICAgICAgY29uc3QgZnJhZ0lkeCA9IGJhY2t0cmFja1NuIC0gbGV2ZWxEZXRhaWxzLnN0YXJ0U047XG4gICAgICBjb25zdCBiYWNrdHJhY2tGcmFnID0gbGV2ZWxEZXRhaWxzLmZyYWdtZW50c1tmcmFnSWR4IC0gMV07XG4gICAgICBpZiAoYmFja3RyYWNrRnJhZyAmJiBmcmFnLmNjID09PSBiYWNrdHJhY2tGcmFnLmNjKSB7XG4gICAgICAgIGZyYWcgPSBiYWNrdHJhY2tGcmFnO1xuICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChiYWNrdHJhY2tGcmFnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgJiYgYnVmZmVySW5mby5sZW4pIHtcbiAgICAgIHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgPSBudWxsO1xuICAgIH1cbiAgICAvLyBBdm9pZCBsb29wIGxvYWRpbmcgYnkgdXNpbmcgbmV4dExvYWRQb3NpdGlvbiBzZXQgZm9yIGJhY2t0cmFja2luZyBhbmQgc2tpcHBpbmcgY29uc2VjdXRpdmUgR0FQIHRhZ3NcbiAgICBpZiAoZnJhZyAmJiB0aGlzLmlzTG9vcExvYWRpbmcoZnJhZywgdGFyZ2V0QnVmZmVyVGltZSkpIHtcbiAgICAgIGNvbnN0IGdhcFN0YXJ0ID0gZnJhZy5nYXA7XG4gICAgICBpZiAoIWdhcFN0YXJ0KSB7XG4gICAgICAgIC8vIENsZWFudXAgdGhlIGZyYWdtZW50IHRyYWNrZXIgYmVmb3JlIHRyeWluZyB0byBmaW5kIHRoZSBuZXh0IHVuYnVmZmVyZWQgZnJhZ21lbnRcbiAgICAgICAgY29uc3QgdHlwZSA9IHRoaXMuYXVkaW9Pbmx5ICYmICF0aGlzLmFsdEF1ZGlvID8gRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPIDogRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPO1xuICAgICAgICBjb25zdCBtZWRpYUJ1ZmZlciA9ICh0eXBlID09PSBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU8gPyB0aGlzLnZpZGVvQnVmZmVyIDogdGhpcy5tZWRpYUJ1ZmZlcikgfHwgdGhpcy5tZWRpYTtcbiAgICAgICAgaWYgKG1lZGlhQnVmZmVyKSB7XG4gICAgICAgICAgdGhpcy5hZnRlckJ1ZmZlckZsdXNoZWQobWVkaWFCdWZmZXIsIHR5cGUsIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmcmFnID0gdGhpcy5nZXROZXh0RnJhZ21lbnRMb29wTG9hZGluZyhmcmFnLCBsZXZlbERldGFpbHMsIGJ1ZmZlckluZm8sIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4sIG1heEJ1Zkxlbik7XG4gICAgfVxuICAgIGlmICghZnJhZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZnJhZy5pbml0U2VnbWVudCAmJiAhZnJhZy5pbml0U2VnbWVudC5kYXRhICYmICF0aGlzLmJpdHJhdGVUZXN0KSB7XG4gICAgICBmcmFnID0gZnJhZy5pbml0U2VnbWVudDtcbiAgICB9XG4gICAgdGhpcy5sb2FkRnJhZ21lbnQoZnJhZywgbGV2ZWxJbmZvLCB0YXJnZXRCdWZmZXJUaW1lKTtcbiAgfVxuICBsb2FkRnJhZ21lbnQoZnJhZywgbGV2ZWwsIHRhcmdldEJ1ZmZlclRpbWUpIHtcbiAgICAvLyBDaGVjayBpZiBmcmFnbWVudCBpcyBub3QgbG9hZGVkXG4gICAgY29uc3QgZnJhZ1N0YXRlID0gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZyk7XG4gICAgaWYgKGZyYWdTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5OT1RfTE9BREVEIHx8IGZyYWdTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5QQVJUSUFMKSB7XG4gICAgICBpZiAoIWlzTWVkaWFGcmFnbWVudChmcmFnKSkge1xuICAgICAgICB0aGlzLl9sb2FkSW5pdFNlZ21lbnQoZnJhZywgbGV2ZWwpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmJpdHJhdGVUZXN0KSB7XG4gICAgICAgIHRoaXMubG9nKGBGcmFnbWVudCAke2ZyYWcuc259IG9mIGxldmVsICR7ZnJhZy5sZXZlbH0gaXMgYmVpbmcgZG93bmxvYWRlZCB0byB0ZXN0IGJpdHJhdGUgYW5kIHdpbGwgbm90IGJlIGJ1ZmZlcmVkYCk7XG4gICAgICAgIHRoaXMuX2xvYWRCaXRyYXRlVGVzdEZyYWcoZnJhZywgbGV2ZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VwZXIubG9hZEZyYWdtZW50KGZyYWcsIGxldmVsLCB0YXJnZXRCdWZmZXJUaW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jbGVhclRyYWNrZXJJZk5lZWRlZChmcmFnKTtcbiAgICB9XG4gIH1cbiAgZ2V0QnVmZmVyZWRGcmFnKHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldEJ1ZmZlcmVkRnJhZyhwb3NpdGlvbiwgUGxheWxpc3RMZXZlbFR5cGUuTUFJTik7XG4gIH1cbiAgZm9sbG93aW5nQnVmZmVyZWRGcmFnKGZyYWcpIHtcbiAgICBpZiAoZnJhZykge1xuICAgICAgLy8gdHJ5IHRvIGdldCByYW5nZSBvZiBuZXh0IGZyYWdtZW50ICg1MDBtcyBhZnRlciB0aGlzIHJhbmdlKVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyZWRGcmFnKGZyYWcuZW5kICsgMC41KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKlxuICAgIG9uIGltbWVkaWF0ZSBsZXZlbCBzd2l0Y2ggOlxuICAgICAtIHBhdXNlIHBsYXliYWNrIGlmIHBsYXlpbmdcbiAgICAgLSBjYW5jZWwgYW55IHBlbmRpbmcgbG9hZCByZXF1ZXN0XG4gICAgIC0gYW5kIHRyaWdnZXIgYSBidWZmZXIgZmx1c2hcbiAgKi9cbiAgaW1tZWRpYXRlTGV2ZWxTd2l0Y2goKSB7XG4gICAgdGhpcy5hYm9ydEN1cnJlbnRGcmFnKCk7XG4gICAgdGhpcy5mbHVzaE1haW5CdWZmZXIoMCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgfVxuXG4gIC8qKlxuICAgKiB0cnkgdG8gc3dpdGNoIEFTQVAgd2l0aG91dCBicmVha2luZyB2aWRlbyBwbGF5YmFjazpcbiAgICogaW4gb3JkZXIgdG8gZW5zdXJlIHNtb290aCBidXQgcXVpY2sgbGV2ZWwgc3dpdGNoaW5nLFxuICAgKiB3ZSBuZWVkIHRvIGZpbmQgdGhlIG5leHQgZmx1c2hhYmxlIGJ1ZmZlciByYW5nZVxuICAgKiB3ZSBzaG91bGQgdGFrZSBpbnRvIGFjY291bnQgbmV3IHNlZ21lbnQgZmV0Y2ggdGltZVxuICAgKi9cbiAgbmV4dExldmVsU3dpdGNoKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxldmVscyxcbiAgICAgIG1lZGlhXG4gICAgfSA9IHRoaXM7XG4gICAgLy8gZW5zdXJlIHRoYXQgbWVkaWEgaXMgZGVmaW5lZCBhbmQgdGhhdCBtZXRhZGF0YSBhcmUgYXZhaWxhYmxlICh0byByZXRyaWV2ZSBjdXJyZW50VGltZSlcbiAgICBpZiAobWVkaWEgIT0gbnVsbCAmJiBtZWRpYS5yZWFkeVN0YXRlKSB7XG4gICAgICBsZXQgZmV0Y2hkZWxheTtcbiAgICAgIGNvbnN0IGZyYWdQbGF5aW5nQ3VycmVudCA9IHRoaXMuZ2V0QXBwZW5kZWRGcmFnKG1lZGlhLmN1cnJlbnRUaW1lKTtcbiAgICAgIGlmIChmcmFnUGxheWluZ0N1cnJlbnQgJiYgZnJhZ1BsYXlpbmdDdXJyZW50LnN0YXJ0ID4gMSkge1xuICAgICAgICAvLyBmbHVzaCBidWZmZXIgcHJlY2VkaW5nIGN1cnJlbnQgZnJhZ21lbnQgKGZsdXNoIHVudGlsIGN1cnJlbnQgZnJhZ21lbnQgc3RhcnQgb2Zmc2V0KVxuICAgICAgICAvLyBtaW51cyAxcyB0byBhdm9pZCB2aWRlbyBmcmVlemluZywgdGhhdCBjb3VsZCBoYXBwZW4gaWYgd2UgZmx1c2gga2V5ZnJhbWUgb2YgY3VycmVudCB2aWRlbyAuLi5cbiAgICAgICAgdGhpcy5mbHVzaE1haW5CdWZmZXIoMCwgZnJhZ1BsYXlpbmdDdXJyZW50LnN0YXJ0IC0gMSk7XG4gICAgICB9XG4gICAgICBjb25zdCBsZXZlbERldGFpbHMgPSB0aGlzLmdldExldmVsRGV0YWlscygpO1xuICAgICAgaWYgKGxldmVsRGV0YWlscyAhPSBudWxsICYmIGxldmVsRGV0YWlscy5saXZlKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlckluZm8gPSB0aGlzLmdldE1haW5Gd2RCdWZmZXJJbmZvKCk7XG4gICAgICAgIC8vIERvIG5vdCBmbHVzaCBpbiBsaXZlIHN0cmVhbSB3aXRoIGxvdyBidWZmZXJcbiAgICAgICAgaWYgKCFidWZmZXJJbmZvIHx8IGJ1ZmZlckluZm8ubGVuIDwgbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uICogMikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFtZWRpYS5wYXVzZWQgJiYgbGV2ZWxzKSB7XG4gICAgICAgIC8vIGFkZCBhIHNhZmV0eSBkZWxheSBvZiAxc1xuICAgICAgICBjb25zdCBuZXh0TGV2ZWxJZCA9IHRoaXMuaGxzLm5leHRMb2FkTGV2ZWw7XG4gICAgICAgIGNvbnN0IG5leHRMZXZlbCA9IGxldmVsc1tuZXh0TGV2ZWxJZF07XG4gICAgICAgIGNvbnN0IGZyYWdMYXN0S2JwcyA9IHRoaXMuZnJhZ0xhc3RLYnBzO1xuICAgICAgICBpZiAoZnJhZ0xhc3RLYnBzICYmIHRoaXMuZnJhZ0N1cnJlbnQpIHtcbiAgICAgICAgICBmZXRjaGRlbGF5ID0gdGhpcy5mcmFnQ3VycmVudC5kdXJhdGlvbiAqIG5leHRMZXZlbC5tYXhCaXRyYXRlIC8gKDEwMDAgKiBmcmFnTGFzdEticHMpICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmZXRjaGRlbGF5ID0gMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmV0Y2hkZWxheSA9IDA7XG4gICAgICB9XG4gICAgICAvLyB0aGlzLmxvZygnZmV0Y2hkZWxheTonK2ZldGNoZGVsYXkpO1xuICAgICAgLy8gZmluZCBidWZmZXIgcmFuZ2UgdGhhdCB3aWxsIGJlIHJlYWNoZWQgb25jZSBuZXcgZnJhZ21lbnQgd2lsbCBiZSBmZXRjaGVkXG4gICAgICBjb25zdCBidWZmZXJlZEZyYWcgPSB0aGlzLmdldEJ1ZmZlcmVkRnJhZyhtZWRpYS5jdXJyZW50VGltZSArIGZldGNoZGVsYXkpO1xuICAgICAgaWYgKGJ1ZmZlcmVkRnJhZykge1xuICAgICAgICAvLyB3ZSBjYW4gZmx1c2ggYnVmZmVyIHJhbmdlIGZvbGxvd2luZyB0aGlzIG9uZSB3aXRob3V0IHN0YWxsaW5nIHBsYXliYWNrXG4gICAgICAgIGNvbnN0IG5leHRCdWZmZXJlZEZyYWcgPSB0aGlzLmZvbGxvd2luZ0J1ZmZlcmVkRnJhZyhidWZmZXJlZEZyYWcpO1xuICAgICAgICBpZiAobmV4dEJ1ZmZlcmVkRnJhZykge1xuICAgICAgICAgIC8vIGlmIHdlIGFyZSBoZXJlLCB3ZSBjYW4gYWxzbyBjYW5jZWwgYW55IGxvYWRpbmcvZGVtdXhpbmcgaW4gcHJvZ3Jlc3MsIGFzIHRoZXkgYXJlIHVzZWxlc3NcbiAgICAgICAgICB0aGlzLmFib3J0Q3VycmVudEZyYWcoKTtcbiAgICAgICAgICAvLyBzdGFydCBmbHVzaCBwb3NpdGlvbiBpcyBpbiBuZXh0IGJ1ZmZlcmVkIGZyYWcuIExlYXZlIHNvbWUgcGFkZGluZyBmb3Igbm9uLWluZGVwZW5kZW50IHNlZ21lbnRzIGFuZCBzbW9vdGhlciBwbGF5YmFjay5cbiAgICAgICAgICBjb25zdCBtYXhTdGFydCA9IG5leHRCdWZmZXJlZEZyYWcubWF4U3RhcnRQVFMgPyBuZXh0QnVmZmVyZWRGcmFnLm1heFN0YXJ0UFRTIDogbmV4dEJ1ZmZlcmVkRnJhZy5zdGFydDtcbiAgICAgICAgICBjb25zdCBmcmFnRHVyYXRpb24gPSBuZXh0QnVmZmVyZWRGcmFnLmR1cmF0aW9uO1xuICAgICAgICAgIGNvbnN0IHN0YXJ0UHRzID0gTWF0aC5tYXgoYnVmZmVyZWRGcmFnLmVuZCwgbWF4U3RhcnQgKyBNYXRoLm1pbihNYXRoLm1heChmcmFnRHVyYXRpb24gLSB0aGlzLmNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBmcmFnRHVyYXRpb24gKiAodGhpcy5jb3VsZEJhY2t0cmFjayA/IDAuNSA6IDAuMTI1KSksIGZyYWdEdXJhdGlvbiAqICh0aGlzLmNvdWxkQmFja3RyYWNrID8gMC43NSA6IDAuMjUpKSk7XG4gICAgICAgICAgdGhpcy5mbHVzaE1haW5CdWZmZXIoc3RhcnRQdHMsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYWJvcnRDdXJyZW50RnJhZygpIHtcbiAgICBjb25zdCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IG51bGw7XG4gICAgaWYgKGZyYWdDdXJyZW50KSB7XG4gICAgICBmcmFnQ3VycmVudC5hYm9ydFJlcXVlc3RzKCk7XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnQ3VycmVudCk7XG4gICAgfVxuICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBTdGF0ZS5LRVlfTE9BRElORzpcbiAgICAgIGNhc2UgU3RhdGUuRlJBR19MT0FESU5HOlxuICAgICAgY2FzZSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTpcbiAgICAgIGNhc2UgU3RhdGUuUEFSU0lORzpcbiAgICAgIGNhc2UgU3RhdGUuUEFSU0VEOlxuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuZ2V0TG9hZFBvc2l0aW9uKCk7XG4gIH1cbiAgZmx1c2hNYWluQnVmZmVyKHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpIHtcbiAgICBzdXBlci5mbHVzaE1haW5CdWZmZXIoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgdGhpcy5hbHRBdWRpbyA9PT0gMiA/ICd2aWRlbycgOiBudWxsKTtcbiAgfVxuICBvbk1lZGlhQXR0YWNoZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBzdXBlci5vbk1lZGlhQXR0YWNoZWQoZXZlbnQsIGRhdGEpO1xuICAgIGNvbnN0IG1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICBhZGRFdmVudExpc3RlbmVyKG1lZGlhLCAncGxheWluZycsIHRoaXMub25NZWRpYVBsYXlpbmcpO1xuICAgIGFkZEV2ZW50TGlzdGVuZXIobWVkaWEsICdzZWVrZWQnLCB0aGlzLm9uTWVkaWFTZWVrZWQpO1xuICB9XG4gIG9uTWVkaWFEZXRhY2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBtZWRpYVxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihtZWRpYSwgJ3BsYXlpbmcnLCB0aGlzLm9uTWVkaWFQbGF5aW5nKTtcbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIobWVkaWEsICdzZWVrZWQnLCB0aGlzLm9uTWVkaWFTZWVrZWQpO1xuICAgIH1cbiAgICB0aGlzLnZpZGVvQnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmZyYWdQbGF5aW5nID0gbnVsbDtcbiAgICBzdXBlci5vbk1lZGlhRGV0YWNoaW5nKGV2ZW50LCBkYXRhKTtcbiAgICBjb25zdCB0cmFuc2ZlcnJpbmdNZWRpYSA9ICEhZGF0YS50cmFuc2Zlck1lZGlhO1xuICAgIGlmICh0cmFuc2ZlcnJpbmdNZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9oYXNFbm91Z2hUb1N0YXJ0ID0gZmFsc2U7XG4gIH1cbiAgb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgc3VwZXIub25NYW5pZmVzdExvYWRpbmcoKTtcbiAgICAvLyByZXNldCBidWZmZXIgb24gbWFuaWZlc3QgbG9hZGluZ1xuICAgIHRoaXMubG9nKCdUcmlnZ2VyIEJVRkZFUl9SRVNFVCcpO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9SRVNFVCwgdW5kZWZpbmVkKTtcbiAgICB0aGlzLmNvdWxkQmFja3RyYWNrID0gZmFsc2U7XG4gICAgdGhpcy5mcmFnTGFzdEticHMgPSAwO1xuICAgIHRoaXMuZnJhZ1BsYXlpbmcgPSB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ID0gbnVsbDtcbiAgICB0aGlzLmFsdEF1ZGlvID0gMDtcbiAgICB0aGlzLmF1ZGlvT25seSA9IGZhbHNlO1xuICB9XG4gIG9uTWFuaWZlc3RQYXJzZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAvLyBkZXRlY3QgaWYgd2UgaGF2ZSBkaWZmZXJlbnQga2luZCBvZiBhdWRpbyBjb2RlY3MgdXNlZCBhbW9uZ3N0IHBsYXlsaXN0c1xuICAgIGxldCBhYWMgPSBmYWxzZTtcbiAgICBsZXQgaGVhYWMgPSBmYWxzZTtcbiAgICBkYXRhLmxldmVscy5mb3JFYWNoKGxldmVsID0+IHtcbiAgICAgIGNvbnN0IGNvZGVjID0gbGV2ZWwuYXVkaW9Db2RlYztcbiAgICAgIGlmIChjb2RlYykge1xuICAgICAgICBhYWMgPSBhYWMgfHwgY29kZWMuaW5kZXhPZignbXA0YS40MC4yJykgIT09IC0xO1xuICAgICAgICBoZWFhYyA9IGhlYWFjIHx8IGNvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmF1ZGlvQ29kZWNTd2l0Y2ggPSBhYWMgJiYgaGVhYWMgJiYgIWNoYW5nZVR5cGVTdXBwb3J0ZWQoKTtcbiAgICBpZiAodGhpcy5hdWRpb0NvZGVjU3dpdGNoKSB7XG4gICAgICB0aGlzLmxvZygnQm90aCBBQUMvSEUtQUFDIGF1ZGlvIGZvdW5kIGluIGxldmVsczsgZGVjbGFyaW5nIGxldmVsIGNvZGVjIGFzIEhFLUFBQycpO1xuICAgIH1cbiAgICB0aGlzLmxldmVscyA9IGRhdGEubGV2ZWxzO1xuICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gIH1cbiAgb25MZXZlbExvYWRpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBsZXZlbHNcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWxldmVscyB8fCB0aGlzLnN0YXRlICE9PSBTdGF0ZS5JRExFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxldmVsID0gZGF0YS5sZXZlbEluZm87XG4gICAgaWYgKCFsZXZlbC5kZXRhaWxzIHx8IGxldmVsLmRldGFpbHMubGl2ZSAmJiAodGhpcy5sZXZlbExhc3RMb2FkZWQgIT09IGxldmVsIHx8IGxldmVsLmRldGFpbHMuZXhwaXJlZCkgfHwgdGhpcy53YWl0Rm9yQ2RuVHVuZUluKGxldmVsLmRldGFpbHMpKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19MRVZFTDtcbiAgICB9XG4gIH1cbiAgb25MZXZlbExvYWRlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBfY3VyTGV2ZWwkZGV0YWlscztcbiAgICBjb25zdCB7XG4gICAgICBsZXZlbHMsXG4gICAgICBzdGFydEZyYWdSZXF1ZXN0ZWRcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBuZXdMZXZlbElkID0gZGF0YS5sZXZlbDtcbiAgICBjb25zdCBuZXdEZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuICAgIGNvbnN0IGR1cmF0aW9uID0gbmV3RGV0YWlscy50b3RhbGR1cmF0aW9uO1xuICAgIGlmICghbGV2ZWxzKSB7XG4gICAgICB0aGlzLndhcm4oYExldmVscyB3ZXJlIHJlc2V0IHdoaWxlIGxvYWRpbmcgbGV2ZWwgJHtuZXdMZXZlbElkfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxvZyhgTGV2ZWwgJHtuZXdMZXZlbElkfSBsb2FkZWQgWyR7bmV3RGV0YWlscy5zdGFydFNOfSwke25ld0RldGFpbHMuZW5kU059XSR7bmV3RGV0YWlscy5sYXN0UGFydFNuID8gYFtwYXJ0LSR7bmV3RGV0YWlscy5sYXN0UGFydFNufS0ke25ld0RldGFpbHMubGFzdFBhcnRJbmRleH1dYCA6ICcnfSwgY2MgWyR7bmV3RGV0YWlscy5zdGFydENDfSwgJHtuZXdEZXRhaWxzLmVuZENDfV0gZHVyYXRpb246JHtkdXJhdGlvbn1gKTtcbiAgICBjb25zdCBjdXJMZXZlbCA9IGRhdGEubGV2ZWxJbmZvO1xuICAgIGNvbnN0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBpZiAoZnJhZ0N1cnJlbnQgJiYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkZSQUdfTE9BRElORyB8fCB0aGlzLnN0YXRlID09PSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWSkpIHtcbiAgICAgIGlmIChmcmFnQ3VycmVudC5sZXZlbCAhPT0gZGF0YS5sZXZlbCAmJiBmcmFnQ3VycmVudC5sb2FkZXIpIHtcbiAgICAgICAgdGhpcy5hYm9ydEN1cnJlbnRGcmFnKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBzbGlkaW5nID0gMDtcbiAgICBpZiAobmV3RGV0YWlscy5saXZlIHx8IChfY3VyTGV2ZWwkZGV0YWlscyA9IGN1ckxldmVsLmRldGFpbHMpICE9IG51bGwgJiYgX2N1ckxldmVsJGRldGFpbHMubGl2ZSkge1xuICAgICAgdmFyIF90aGlzJGxldmVsTGFzdExvYWRlZDtcbiAgICAgIHRoaXMuY2hlY2tMaXZlVXBkYXRlKG5ld0RldGFpbHMpO1xuICAgICAgaWYgKG5ld0RldGFpbHMuZGVsdGFVcGRhdGVGYWlsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2xpZGluZyA9IHRoaXMuYWxpZ25QbGF5bGlzdHMobmV3RGV0YWlscywgY3VyTGV2ZWwuZGV0YWlscywgKF90aGlzJGxldmVsTGFzdExvYWRlZCA9IHRoaXMubGV2ZWxMYXN0TG9hZGVkKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbGV2ZWxMYXN0TG9hZGVkLmRldGFpbHMpO1xuICAgIH1cbiAgICAvLyBvdmVycmlkZSBsZXZlbCBpbmZvXG4gICAgY3VyTGV2ZWwuZGV0YWlscyA9IG5ld0RldGFpbHM7XG4gICAgdGhpcy5sZXZlbExhc3RMb2FkZWQgPSBjdXJMZXZlbDtcbiAgICBpZiAoIXN0YXJ0RnJhZ1JlcXVlc3RlZCkge1xuICAgICAgdGhpcy5zZXRTdGFydFBvc2l0aW9uKG5ld0RldGFpbHMsIHNsaWRpbmcpO1xuICAgIH1cbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5MRVZFTF9VUERBVEVELCB7XG4gICAgICBkZXRhaWxzOiBuZXdEZXRhaWxzLFxuICAgICAgbGV2ZWw6IG5ld0xldmVsSWRcbiAgICB9KTtcblxuICAgIC8vIG9ubHkgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZSBpZiB3ZSB3ZXJlIHdhaXRpbmcgZm9yIGxldmVsIHRvIHN0YXJ0IGRvd25sb2FkaW5nIGEgbmV3IGZyYWdtZW50XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLldBSVRJTkdfTEVWRUwpIHtcbiAgICAgIGlmICh0aGlzLndhaXRGb3JDZG5UdW5lSW4obmV3RGV0YWlscykpIHtcbiAgICAgICAgLy8gV2FpdCBmb3IgTG93LUxhdGVuY3kgQ0ROIFR1bmUtaW5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgfVxuICAgIGlmIChzdGFydEZyYWdSZXF1ZXN0ZWQgJiYgbmV3RGV0YWlscy5saXZlKSB7XG4gICAgICB0aGlzLnN5bmNocm9uaXplVG9MaXZlRWRnZShuZXdEZXRhaWxzKTtcbiAgICB9XG5cbiAgICAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgdGhpcy50aWNrKCk7XG4gIH1cbiAgc3luY2hyb25pemVUb0xpdmVFZGdlKGxldmVsRGV0YWlscykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbmZpZyxcbiAgICAgIG1lZGlhXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsaXZlU3luY1Bvc2l0aW9uID0gdGhpcy5obHMubGl2ZVN5bmNQb3NpdGlvbjtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IHRoaXMuZ2V0TG9hZFBvc2l0aW9uKCk7XG4gICAgY29uc3Qgc3RhcnQgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRTdGFydDtcbiAgICBjb25zdCBlbmQgPSBsZXZlbERldGFpbHMuZWRnZTtcbiAgICBjb25zdCB3aXRoaW5TbGlkaW5nV2luZG93ID0gY3VycmVudFRpbWUgPj0gc3RhcnQgLSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSAmJiBjdXJyZW50VGltZSA8PSBlbmQ7XG4gICAgLy8gQ29udGludWUgaWYgd2UgY2FuIHNlZWsgZm9yd2FyZCB0byBzeW5jIHBvc2l0aW9uIG9yIGlmIGN1cnJlbnQgdGltZSBpcyBvdXRzaWRlIG9mIHNsaWRpbmcgd2luZG93XG4gICAgaWYgKGxpdmVTeW5jUG9zaXRpb24gIT09IG51bGwgJiYgbWVkaWEuZHVyYXRpb24gPiBsaXZlU3luY1Bvc2l0aW9uICYmIChjdXJyZW50VGltZSA8IGxpdmVTeW5jUG9zaXRpb24gfHwgIXdpdGhpblNsaWRpbmdXaW5kb3cpKSB7XG4gICAgICAvLyBDb250aW51ZSBpZiBidWZmZXIgaXMgc3RhcnZpbmcgb3IgaWYgY3VycmVudCB0aW1lIGlzIGJlaGluZCBtYXggbGF0ZW5jeVxuICAgICAgY29uc3QgbWF4TGF0ZW5jeSA9IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiA6IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgKiBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb247XG4gICAgICBpZiAoIXdpdGhpblNsaWRpbmdXaW5kb3cgJiYgbWVkaWEucmVhZHlTdGF0ZSA8IDQgfHwgY3VycmVudFRpbWUgPCBlbmQgLSBtYXhMYXRlbmN5KSB7XG4gICAgICAgIGlmICghdGhpcy5faGFzRW5vdWdoVG9TdGFydCkge1xuICAgICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IGxpdmVTeW5jUG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25seSBzZWVrIGlmIHJlYWR5IGFuZCB0aGVyZSBpcyBub3QgYSBzaWduaWZpY2FudCBmb3J3YXJkIGJ1ZmZlciBhdmFpbGFibGUgZm9yIHBsYXliYWNrXG4gICAgICAgIGlmIChtZWRpYS5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgdGhpcy53YXJuKGBQbGF5YmFjazogJHtjdXJyZW50VGltZS50b0ZpeGVkKDMpfSBpcyBsb2NhdGVkIHRvbyBmYXIgZnJvbSB0aGUgZW5kIG9mIGxpdmUgc2xpZGluZyBwbGF5bGlzdDogJHtlbmR9LCByZXNldCBjdXJyZW50VGltZSB0byA6ICR7bGl2ZVN5bmNQb3NpdGlvbi50b0ZpeGVkKDMpfWApO1xuICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5saXZlU3luY01vZGUgPT09ICdidWZmZXJlZCcpIHtcbiAgICAgICAgICAgIHZhciBfYnVmZmVySW5mbyRidWZmZXJlZDtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhtZWRpYSwgbGl2ZVN5bmNQb3NpdGlvbiwgMCk7XG4gICAgICAgICAgICBpZiAoIShidWZmZXJJbmZvICE9IG51bGwgJiYgKF9idWZmZXJJbmZvJGJ1ZmZlcmVkID0gYnVmZmVySW5mby5idWZmZXJlZCkgIT0gbnVsbCAmJiBfYnVmZmVySW5mbyRidWZmZXJlZC5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gbGl2ZVN5bmNQb3NpdGlvbjtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaXNMaXZlU3luY0luQnVmZmVyID0gYnVmZmVySW5mby5zdGFydCA8PSBjdXJyZW50VGltZTtcbiAgICAgICAgICAgIGlmIChpc0xpdmVTeW5jSW5CdWZmZXIpIHtcbiAgICAgICAgICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSBsaXZlU3luY1Bvc2l0aW9uO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIG5leHRTdGFydFxuICAgICAgICAgICAgfSA9IEJ1ZmZlckhlbHBlci5idWZmZXJlZEluZm8oYnVmZmVySW5mby5idWZmZXJlZCwgY3VycmVudFRpbWUsIDApO1xuICAgICAgICAgICAgaWYgKG5leHRTdGFydCkge1xuICAgICAgICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IG5leHRTdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSBsaXZlU3luY1Bvc2l0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBfaGFuZGxlRnJhZ21lbnRMb2FkUHJvZ3Jlc3MoZGF0YSkge1xuICAgIHZhciBfZnJhZyRpbml0U2VnbWVudDtcbiAgICBjb25zdCBmcmFnID0gZGF0YS5mcmFnO1xuICAgIGNvbnN0IHtcbiAgICAgIHBhcnQsXG4gICAgICBwYXlsb2FkXG4gICAgfSA9IGRhdGE7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWxzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFsZXZlbHMpIHtcbiAgICAgIHRoaXMud2FybihgTGV2ZWxzIHdlcmUgcmVzZXQgd2hpbGUgZnJhZ21lbnQgbG9hZCB3YXMgaW4gcHJvZ3Jlc3MuIEZyYWdtZW50ICR7ZnJhZy5zbn0gb2YgbGV2ZWwgJHtmcmFnLmxldmVsfSB3aWxsIG5vdCBiZSBidWZmZXJlZGApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50TGV2ZWwgPSBsZXZlbHNbZnJhZy5sZXZlbF07XG4gICAgaWYgKCFjdXJyZW50TGV2ZWwpIHtcbiAgICAgIHRoaXMud2FybihgTGV2ZWwgJHtmcmFnLmxldmVsfSBub3QgZm91bmQgb24gcHJvZ3Jlc3NgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGV0YWlscyA9IGN1cnJlbnRMZXZlbC5kZXRhaWxzO1xuICAgIGlmICghZGV0YWlscykge1xuICAgICAgdGhpcy53YXJuKGBEcm9wcGluZyBmcmFnbWVudCAke2ZyYWcuc259IG9mIGxldmVsICR7ZnJhZy5sZXZlbH0gYWZ0ZXIgbGV2ZWwgZGV0YWlscyB3ZXJlIHJlc2V0YCk7XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdmlkZW9Db2RlYyA9IGN1cnJlbnRMZXZlbC52aWRlb0NvZGVjO1xuXG4gICAgLy8gdGltZSBPZmZzZXQgaXMgYWNjdXJhdGUgaWYgbGV2ZWwgUFRTIGlzIGtub3duLCBvciBpZiBwbGF5bGlzdCBpcyBub3Qgc2xpZGluZyAobm90IGxpdmUpXG4gICAgY29uc3QgYWNjdXJhdGVUaW1lT2Zmc2V0ID0gZGV0YWlscy5QVFNLbm93biB8fCAhZGV0YWlscy5saXZlO1xuICAgIGNvbnN0IGluaXRTZWdtZW50RGF0YSA9IChfZnJhZyRpbml0U2VnbWVudCA9IGZyYWcuaW5pdFNlZ21lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZnJhZyRpbml0U2VnbWVudC5kYXRhO1xuICAgIGNvbnN0IGF1ZGlvQ29kZWMgPSB0aGlzLl9nZXRBdWRpb0NvZGVjKGN1cnJlbnRMZXZlbCk7XG5cbiAgICAvLyB0cmFuc211eCB0aGUgTVBFRy1UUyBkYXRhIHRvIElTTy1CTUZGIHNlZ21lbnRzXG4gICAgLy8gdGhpcy5sb2coYFRyYW5zbXV4aW5nICR7ZnJhZy5zbn0gb2YgWyR7ZGV0YWlscy5zdGFydFNOfSAsJHtkZXRhaWxzLmVuZFNOfV0sbGV2ZWwgJHtmcmFnLmxldmVsfSwgY2MgJHtmcmFnLmNjfWApO1xuICAgIGNvbnN0IHRyYW5zbXV4ZXIgPSB0aGlzLnRyYW5zbXV4ZXIgPSB0aGlzLnRyYW5zbXV4ZXIgfHwgbmV3IFRyYW5zbXV4ZXJJbnRlcmZhY2UodGhpcy5obHMsIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4sIHRoaXMuX2hhbmRsZVRyYW5zbXV4Q29tcGxldGUuYmluZCh0aGlzKSwgdGhpcy5faGFuZGxlVHJhbnNtdXhlckZsdXNoLmJpbmQodGhpcykpO1xuICAgIGNvbnN0IHBhcnRJbmRleCA9IHBhcnQgPyBwYXJ0LmluZGV4IDogLTE7XG4gICAgY29uc3QgcGFydGlhbCA9IHBhcnRJbmRleCAhPT0gLTE7XG4gICAgY29uc3QgY2h1bmtNZXRhID0gbmV3IENodW5rTWV0YWRhdGEoZnJhZy5sZXZlbCwgZnJhZy5zbiwgZnJhZy5zdGF0cy5jaHVua0NvdW50LCBwYXlsb2FkLmJ5dGVMZW5ndGgsIHBhcnRJbmRleCwgcGFydGlhbCk7XG4gICAgY29uc3QgaW5pdFBUUyA9IHRoaXMuaW5pdFBUU1tmcmFnLmNjXTtcbiAgICB0cmFuc211eGVyLnB1c2gocGF5bG9hZCwgaW5pdFNlZ21lbnREYXRhLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBmcmFnLCBwYXJ0LCBkZXRhaWxzLnRvdGFsZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhLCBpbml0UFRTKTtcbiAgfVxuICBvbkF1ZGlvVHJhY2tTd2l0Y2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICAvLyBpZiBhbnkgVVJMIGZvdW5kIG9uIG5ldyBhdWRpbyB0cmFjaywgaXQgaXMgYW4gYWx0ZXJuYXRlIGF1ZGlvIHRyYWNrXG4gICAgY29uc3QgZnJvbUFsdEF1ZGlvID0gdGhpcy5hbHRBdWRpbyA9PT0gMjtcbiAgICBjb25zdCBhbHRBdWRpbyA9IHVzZUFsdGVybmF0ZUF1ZGlvKGRhdGEudXJsLCBobHMpO1xuICAgIC8vIGlmIHdlIHN3aXRjaCBvbiBtYWluIGF1ZGlvLCBlbnN1cmUgdGhhdCBtYWluIGZyYWdtZW50IHNjaGVkdWxpbmcgaXMgc3luY2VkIHdpdGggbWVkaWEuYnVmZmVyZWRcbiAgICAvLyBkb24ndCBkbyBhbnl0aGluZyBpZiB3ZSBzd2l0Y2ggdG8gYWx0IGF1ZGlvOiBhdWRpbyBzdHJlYW0gY29udHJvbGxlciBpcyBoYW5kbGluZyBpdC5cbiAgICAvLyB3ZSB3aWxsIGp1c3QgaGF2ZSB0byBjaGFuZ2UgYnVmZmVyIHNjaGVkdWxpbmcgb24gYXVkaW9UcmFja1N3aXRjaGVkXG4gICAgaWYgKCFhbHRBdWRpbykge1xuICAgICAgaWYgKHRoaXMubWVkaWFCdWZmZXIgIT09IHRoaXMubWVkaWEpIHtcbiAgICAgICAgdGhpcy5sb2coJ1N3aXRjaGluZyBvbiBtYWluIGF1ZGlvLCB1c2UgbWVkaWEuYnVmZmVyZWQgdG8gc2NoZWR1bGUgbWFpbiBmcmFnbWVudCBsb2FkaW5nJyk7XG4gICAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhO1xuICAgICAgICBjb25zdCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gcmVmaWxsIGF1ZGlvIGJ1ZmZlciBmcm9tIG1haW46IGNhbmNlbCBhbnkgZnJhZyBsb2FkaW5nIHRvIHNwZWVkIHVwIGF1ZGlvIHN3aXRjaFxuICAgICAgICBpZiAoZnJhZ0N1cnJlbnQpIHtcbiAgICAgICAgICB0aGlzLmxvZygnU3dpdGNoaW5nIHRvIG1haW4gYXVkaW8gdHJhY2ssIGNhbmNlbCBtYWluIGZyYWdtZW50IGxvYWQnKTtcbiAgICAgICAgICBmcmFnQ3VycmVudC5hYm9ydFJlcXVlc3RzKCk7XG4gICAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZ0N1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRlc3Ryb3kgdHJhbnNtdXhlciB0byBmb3JjZSBpbml0IHNlZ21lbnQgZ2VuZXJhdGlvbiAoZm9sbG93aW5nIGF1ZGlvIHN3aXRjaClcbiAgICAgICAgdGhpcy5yZXNldFRyYW5zbXV4ZXIoKTtcbiAgICAgICAgLy8gc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gbG9hZCBuZXcgZnJhZ21lbnRcbiAgICAgICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmF1ZGlvT25seSkge1xuICAgICAgICAvLyBSZXNldCBhdWRpbyB0cmFuc211eGVyIHNvIHdoZW4gc3dpdGNoaW5nIGJhY2sgdG8gbWFpbiBhdWRpbyB3ZSdyZSBub3Qgc3RpbGwgYXBwZW5kaW5nIHdoZXJlIHdlIGxlZnQgb2ZmXG4gICAgICAgIHRoaXMucmVzZXRUcmFuc211eGVyKCk7XG4gICAgICB9XG4gICAgICAvLyBJZiBzd2l0Y2hpbmcgZnJvbSBhbHQgdG8gbWFpbiBhdWRpbywgZmx1c2ggYWxsIGF1ZGlvIGFuZCB0cmlnZ2VyIHRyYWNrIHN3aXRjaGVkXG4gICAgICBpZiAoZnJvbUFsdEF1ZGlvKSB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUFsbEZyYWdtZW50cygpO1xuICAgICAgICBobHMub25jZShFdmVudHMuQlVGRkVSX0ZMVVNIRUQsICgpID0+IHtcbiAgICAgICAgICB2YXIgX3RoaXMkaGxzO1xuICAgICAgICAgIChfdGhpcyRobHMgPSB0aGlzLmhscykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGhscy50cmlnZ2VyKEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hFRCwgZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0ZMVVNISU5HLCB7XG4gICAgICAgICAgc3RhcnRPZmZzZXQ6IDAsXG4gICAgICAgICAgZW5kT2Zmc2V0OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgICAgICAgdHlwZTogbnVsbFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSEVELCBkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hbHRBdWRpbyA9IDE7XG4gICAgfVxuICB9XG4gIG9uQXVkaW9UcmFja1N3aXRjaGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3QgYWx0QXVkaW8gPSB1c2VBbHRlcm5hdGVBdWRpbyhkYXRhLnVybCwgdGhpcy5obHMpO1xuICAgIGlmIChhbHRBdWRpbykge1xuICAgICAgY29uc3QgdmlkZW9CdWZmZXIgPSB0aGlzLnZpZGVvQnVmZmVyO1xuICAgICAgLy8gaWYgd2Ugc3dpdGNoZWQgb24gYWx0ZXJuYXRlIGF1ZGlvLCBlbnN1cmUgdGhhdCBtYWluIGZyYWdtZW50IHNjaGVkdWxpbmcgaXMgc3luY2VkIHdpdGggdmlkZW8gc291cmNlYnVmZmVyIGJ1ZmZlcmVkXG4gICAgICBpZiAodmlkZW9CdWZmZXIgJiYgdGhpcy5tZWRpYUJ1ZmZlciAhPT0gdmlkZW9CdWZmZXIpIHtcbiAgICAgICAgdGhpcy5sb2coJ1N3aXRjaGluZyBvbiBhbHRlcm5hdGUgYXVkaW8sIHVzZSB2aWRlby5idWZmZXJlZCB0byBzY2hlZHVsZSBtYWluIGZyYWdtZW50IGxvYWRpbmcnKTtcbiAgICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHZpZGVvQnVmZmVyO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFsdEF1ZGlvID0gYWx0QXVkaW8gPyAyIDogMDtcbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuICBvbkJ1ZmZlckNyZWF0ZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB0cmFja3MgPSBkYXRhLnRyYWNrcztcbiAgICBsZXQgbWVkaWFUcmFjaztcbiAgICBsZXQgbmFtZTtcbiAgICBsZXQgYWx0ZXJuYXRlID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCB0eXBlIGluIHRyYWNrcykge1xuICAgICAgY29uc3QgdHJhY2sgPSB0cmFja3NbdHlwZV07XG4gICAgICBpZiAodHJhY2suaWQgPT09ICdtYWluJykge1xuICAgICAgICBuYW1lID0gdHlwZTtcbiAgICAgICAgbWVkaWFUcmFjayA9IHRyYWNrO1xuICAgICAgICAvLyBrZWVwIHZpZGVvIHNvdXJjZSBidWZmZXIgcmVmZXJlbmNlXG4gICAgICAgIGlmICh0eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgY29uc3QgdmlkZW9UcmFjayA9IHRyYWNrc1t0eXBlXTtcbiAgICAgICAgICBpZiAodmlkZW9UcmFjaykge1xuICAgICAgICAgICAgdGhpcy52aWRlb0J1ZmZlciA9IHZpZGVvVHJhY2suYnVmZmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWx0ZXJuYXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFsdGVybmF0ZSAmJiBtZWRpYVRyYWNrKSB7XG4gICAgICB0aGlzLmxvZyhgQWx0ZXJuYXRlIHRyYWNrIGZvdW5kLCB1c2UgJHtuYW1lfS5idWZmZXJlZCB0byBzY2hlZHVsZSBtYWluIGZyYWdtZW50IGxvYWRpbmdgKTtcbiAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSBtZWRpYVRyYWNrLmJ1ZmZlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWE7XG4gICAgfVxuICB9XG4gIG9uRnJhZ0J1ZmZlcmVkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIHBhcnRcbiAgICB9ID0gZGF0YTtcbiAgICBjb25zdCBidWZmZXJlZE1haW5GcmFnbWVudCA9IGZyYWcudHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTjtcbiAgICBpZiAoYnVmZmVyZWRNYWluRnJhZ21lbnQpIHtcbiAgICAgIGlmICh0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgICAvLyBJZiBhIGxldmVsIHN3aXRjaCB3YXMgcmVxdWVzdGVkIHdoaWxlIGEgZnJhZ21lbnQgd2FzIGJ1ZmZlcmluZywgaXQgd2lsbCBlbWl0IHRoZSBGUkFHX0JVRkZFUkVEIGV2ZW50IHVwb24gY29tcGxldGlvblxuICAgICAgICAvLyBBdm9pZCBzZXR0aW5nIHN0YXRlIGJhY2sgdG8gSURMRSwgc2luY2UgdGhhdCB3aWxsIGludGVyZmVyZSB3aXRoIGEgbGV2ZWwgc3dpdGNoXG4gICAgICAgIHRoaXMud2FybihgRnJhZ21lbnQgJHtmcmFnLnNufSR7cGFydCA/ICcgcDogJyArIHBhcnQuaW5kZXggOiAnJ30gb2YgbGV2ZWwgJHtmcmFnLmxldmVsfSBmaW5pc2hlZCBidWZmZXJpbmcsIGJ1dCB3YXMgYWJvcnRlZC4gc3RhdGU6ICR7dGhpcy5zdGF0ZX1gKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNFRCkge1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXRzID0gcGFydCA/IHBhcnQuc3RhdHMgOiBmcmFnLnN0YXRzO1xuICAgICAgdGhpcy5mcmFnTGFzdEticHMgPSBNYXRoLnJvdW5kKDggKiBzdGF0cy50b3RhbCAvIChzdGF0cy5idWZmZXJpbmcuZW5kIC0gc3RhdHMubG9hZGluZy5maXJzdCkpO1xuICAgICAgaWYgKGlzTWVkaWFGcmFnbWVudChmcmFnKSkge1xuICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IGZyYWc7XG4gICAgICB9XG4gICAgICB0aGlzLmZyYWdCdWZmZXJlZENvbXBsZXRlKGZyYWcsIHBhcnQpO1xuICAgIH1cbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgaWYgKCFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2hhc0Vub3VnaFRvU3RhcnQgJiYgQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKG1lZGlhKS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX2hhc0Vub3VnaFRvU3RhcnQgPSB0cnVlO1xuICAgICAgdGhpcy5zZWVrVG9TdGFydFBvcygpO1xuICAgIH1cbiAgICBpZiAoYnVmZmVyZWRNYWluRnJhZ21lbnQpIHtcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH1cbiAgfVxuICBnZXQgaGFzRW5vdWdoVG9TdGFydCgpIHtcbiAgICByZXR1cm4gdGhpcy5faGFzRW5vdWdoVG9TdGFydDtcbiAgfVxuICBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF9kYXRhJGNvbnRleHQ7XG4gICAgaWYgKGRhdGEuZmF0YWwpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5FUlJPUjtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3dpdGNoIChkYXRhLmRldGFpbHMpIHtcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfR0FQOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19ERUNSWVBUX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQ6XG4gICAgICAgIHRoaXMub25GcmFnbWVudE9yS2V5TG9hZEVycm9yKFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4sIGRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQ6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9QQVJTSU5HX0VSUk9SOlxuICAgICAgICAvLyBpbiBjYXNlIG9mIG5vbiBmYXRhbCBlcnJvciB3aGlsZSBsb2FkaW5nIGxldmVsLCBpZiBsZXZlbCBjb250cm9sbGVyIGlzIG5vdCByZXRyeWluZyB0byBsb2FkIGxldmVsLCBzd2l0Y2ggYmFjayB0byBJRExFXG4gICAgICAgIGlmICghZGF0YS5sZXZlbFJldHJ5ICYmIHRoaXMuc3RhdGUgPT09IFN0YXRlLldBSVRJTkdfTEVWRUwgJiYgKChfZGF0YSRjb250ZXh0ID0gZGF0YS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGEkY29udGV4dC50eXBlKSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5MRVZFTCkge1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0FERF9DT0RFQ19FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRfRVJST1I6XG4gICAgICAgIGlmIChkYXRhLnBhcmVudCAhPT0gJ21haW4nKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlZHVjZUxlbmd0aEFuZEZsdXNoQnVmZmVyKGRhdGEpKSB7XG4gICAgICAgICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0ZVTExfRVJST1I6XG4gICAgICAgIGlmIChkYXRhLnBhcmVudCAhPT0gJ21haW4nKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlZHVjZUxlbmd0aEFuZEZsdXNoQnVmZmVyKGRhdGEpKSB7XG4gICAgICAgICAgdGhpcy5mbHVzaE1haW5CdWZmZXIoMCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLklOVEVSTkFMX0VYQ0VQVElPTjpcbiAgICAgICAgdGhpcy5yZWNvdmVyV29ya2VyRXJyb3IoZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBvbkZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZCgpIHtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAvLyBpZiBsb2FkZWRtZXRhZGF0YSBpcyBub3Qgc2V0LCBpdCBtZWFucyB0aGF0IHdlIGFyZSBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gb24gZmlyc3QgZnJhZ1xuICAgIC8vIGluIHRoYXQgY2FzZSwgcmVzZXQgc3RhcnRGcmFnUmVxdWVzdGVkIGZsYWdcbiAgICBpZiAoIXRoaXMuX2hhc0Vub3VnaFRvU3RhcnQpIHtcbiAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZTtcbiAgICB9XG4gICAgdGhpcy50aWNrSW1tZWRpYXRlKCk7XG4gIH1cbiAgb25CdWZmZXJGbHVzaGVkKGV2ZW50LCB7XG4gICAgdHlwZVxuICB9KSB7XG4gICAgaWYgKHR5cGUgIT09IEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJTyB8fCAhdGhpcy5hbHRBdWRpbykge1xuICAgICAgY29uc3QgbWVkaWFCdWZmZXIgPSAodHlwZSA9PT0gRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPID8gdGhpcy52aWRlb0J1ZmZlciA6IHRoaXMubWVkaWFCdWZmZXIpIHx8IHRoaXMubWVkaWE7XG4gICAgICBpZiAobWVkaWFCdWZmZXIpIHtcbiAgICAgICAgdGhpcy5hZnRlckJ1ZmZlckZsdXNoZWQobWVkaWFCdWZmZXIsIHR5cGUsIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pO1xuICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgb25MZXZlbHNVcGRhdGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKHRoaXMubGV2ZWwgPiAtMSAmJiB0aGlzLmZyYWdDdXJyZW50KSB7XG4gICAgICB0aGlzLmxldmVsID0gdGhpcy5mcmFnQ3VycmVudC5sZXZlbDtcbiAgICAgIGlmICh0aGlzLmxldmVsID09PSAtMSkge1xuICAgICAgICB0aGlzLnJlc2V0V2hlbk1pc3NpbmdDb250ZXh0KHRoaXMuZnJhZ0N1cnJlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxldmVscyA9IGRhdGEubGV2ZWxzO1xuICB9XG4gIHN3YXBBdWRpb0NvZGVjKCkge1xuICAgIHRoaXMuYXVkaW9Db2RlY1N3YXAgPSAhdGhpcy5hdWRpb0NvZGVjU3dhcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWVrcyB0byB0aGUgc2V0IHN0YXJ0UG9zaXRpb24gaWYgbm90IGVxdWFsIHRvIHRoZSBtZWRpYUVsZW1lbnQncyBjdXJyZW50IHRpbWUuXG4gICAqL1xuICBzZWVrVG9TdGFydFBvcygpIHtcbiAgICBjb25zdCB7XG4gICAgICBtZWRpYVxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghbWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICBsZXQgc3RhcnRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICAvLyBvbmx5IGFkanVzdCBjdXJyZW50VGltZSBpZiBkaWZmZXJlbnQgZnJvbSBzdGFydFBvc2l0aW9uIG9yIGlmIHN0YXJ0UG9zaXRpb24gbm90IGJ1ZmZlcmVkXG4gICAgLy8gYXQgdGhhdCBzdGFnZSwgdGhlcmUgc2hvdWxkIGJlIG9ubHkgb25lIGJ1ZmZlcmVkIHJhbmdlLCBhcyB3ZSByZWFjaCB0aGF0IGNvZGUgYWZ0ZXIgZmlyc3QgZnJhZ21lbnQgaGFzIGJlZW4gYnVmZmVyZWRcbiAgICBpZiAoc3RhcnRQb3NpdGlvbiA+PSAwICYmIGN1cnJlbnRUaW1lIDwgc3RhcnRQb3NpdGlvbikge1xuICAgICAgaWYgKG1lZGlhLnNlZWtpbmcpIHtcbiAgICAgICAgdGhpcy5sb2coYGNvdWxkIG5vdCBzZWVrIHRvICR7c3RhcnRQb3NpdGlvbn0sIGFscmVhZHkgc2Vla2luZyBhdCAke2N1cnJlbnRUaW1lfWApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIE9mZnNldCBzdGFydCBwb3NpdGlvbiBieSB0aW1lbGluZSBvZmZzZXRcbiAgICAgIGNvbnN0IHRpbWVsaW5lT2Zmc2V0ID0gdGhpcy50aW1lbGluZU9mZnNldDtcbiAgICAgIGlmICh0aW1lbGluZU9mZnNldCAmJiBzdGFydFBvc2l0aW9uKSB7XG4gICAgICAgIHN0YXJ0UG9zaXRpb24gKz0gdGltZWxpbmVPZmZzZXQ7XG4gICAgICB9XG4gICAgICBjb25zdCBkZXRhaWxzID0gdGhpcy5nZXRMZXZlbERldGFpbHMoKTtcbiAgICAgIGNvbnN0IGJ1ZmZlcmVkID0gQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKG1lZGlhKTtcbiAgICAgIGNvbnN0IGJ1ZmZlclN0YXJ0ID0gYnVmZmVyZWQubGVuZ3RoID8gYnVmZmVyZWQuc3RhcnQoMCkgOiAwO1xuICAgICAgY29uc3QgZGVsdGEgPSBidWZmZXJTdGFydCAtIHN0YXJ0UG9zaXRpb247XG4gICAgICBjb25zdCBza2lwVG9sZXJhbmNlID0gTWF0aC5tYXgodGhpcy5jb25maWcubWF4QnVmZmVySG9sZSwgdGhpcy5jb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSk7XG4gICAgICBpZiAodGhpcy5jb25maWcuc3RhcnRPblNlZ21lbnRCb3VuZGFyeSB8fCBkZWx0YSA+IDAgJiYgKGRlbHRhIDwgc2tpcFRvbGVyYW5jZSB8fCB0aGlzLmxvYWRpbmdQYXJ0cyAmJiBkZWx0YSA8IDIgKiAoKGRldGFpbHMgPT0gbnVsbCA/IHZvaWQgMCA6IGRldGFpbHMucGFydFRhcmdldCkgfHwgMCkpKSB7XG4gICAgICAgIHRoaXMubG9nKGBhZGp1c3Rpbmcgc3RhcnQgcG9zaXRpb24gYnkgJHtkZWx0YX0gdG8gbWF0Y2ggYnVmZmVyIHN0YXJ0YCk7XG4gICAgICAgIHN0YXJ0UG9zaXRpb24gKz0gZGVsdGE7XG4gICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHN0YXJ0UG9zaXRpb247XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudFRpbWUgPCBzdGFydFBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMubG9nKGBzZWVrIHRvIHRhcmdldCBzdGFydCBwb3NpdGlvbiAke3N0YXJ0UG9zaXRpb259IGZyb20gY3VycmVudCB0aW1lICR7Y3VycmVudFRpbWV9IGJ1ZmZlciBzdGFydCAke2J1ZmZlclN0YXJ0fWApO1xuICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IHN0YXJ0UG9zaXRpb247XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9nZXRBdWRpb0NvZGVjKGN1cnJlbnRMZXZlbCkge1xuICAgIGxldCBhdWRpb0NvZGVjID0gdGhpcy5jb25maWcuZGVmYXVsdEF1ZGlvQ29kZWMgfHwgY3VycmVudExldmVsLmF1ZGlvQ29kZWM7XG4gICAgaWYgKHRoaXMuYXVkaW9Db2RlY1N3YXAgJiYgYXVkaW9Db2RlYykge1xuICAgICAgdGhpcy5sb2coJ1N3YXBwaW5nIGF1ZGlvIGNvZGVjJyk7XG4gICAgICBpZiAoYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjUnKSAhPT0gLTEpIHtcbiAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjInO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjUnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXVkaW9Db2RlYztcbiAgfVxuICBfbG9hZEJpdHJhdGVUZXN0RnJhZyhmcmFnbWVudCwgbGV2ZWwpIHtcbiAgICBmcmFnbWVudC5iaXRyYXRlVGVzdCA9IHRydWU7XG4gICAgdGhpcy5fZG9GcmFnTG9hZChmcmFnbWVudCwgbGV2ZWwpLnRoZW4oZGF0YSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGhsc1xuICAgICAgfSA9IHRoaXM7XG4gICAgICBjb25zdCBmcmFnID0gZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5mcmFnO1xuICAgICAgaWYgKCFmcmFnIHx8IHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldmVsLmZyYWdtZW50RXJyb3IgPSAwO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5iaXRyYXRlVGVzdCA9IGZhbHNlO1xuICAgICAgY29uc3Qgc3RhdHMgPSBmcmFnLnN0YXRzO1xuICAgICAgLy8gQml0cmF0ZSB0ZXN0cyBmcmFnbWVudHMgYXJlIG5laXRoZXIgcGFyc2VkIG5vciBidWZmZXJlZFxuICAgICAgc3RhdHMucGFyc2luZy5zdGFydCA9IHN0YXRzLnBhcnNpbmcuZW5kID0gc3RhdHMuYnVmZmVyaW5nLnN0YXJ0ID0gc3RhdHMuYnVmZmVyaW5nLmVuZCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuRlJBR19MT0FERUQsIGRhdGEpO1xuICAgICAgZnJhZy5iaXRyYXRlVGVzdCA9IGZhbHNlO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVUcmFuc211eENvbXBsZXRlKHRyYW5zbXV4UmVzdWx0KSB7XG4gICAgdmFyIF9pZDMkc2FtcGxlcztcbiAgICBjb25zdCBpZCA9IHRoaXMucGxheWxpc3RUeXBlO1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlbXV4UmVzdWx0LFxuICAgICAgY2h1bmtNZXRhXG4gICAgfSA9IHRyYW5zbXV4UmVzdWx0O1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdldEN1cnJlbnRDb250ZXh0KGNodW5rTWV0YSk7XG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICB0aGlzLnJlc2V0V2hlbk1pc3NpbmdDb250ZXh0KGNodW5rTWV0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGZyYWcsXG4gICAgICBwYXJ0LFxuICAgICAgbGV2ZWxcbiAgICB9ID0gY29udGV4dDtcbiAgICBjb25zdCB7XG4gICAgICB2aWRlbyxcbiAgICAgIHRleHQsXG4gICAgICBpZDMsXG4gICAgICBpbml0U2VnbWVudFxuICAgIH0gPSByZW11eFJlc3VsdDtcbiAgICBjb25zdCB7XG4gICAgICBkZXRhaWxzXG4gICAgfSA9IGxldmVsO1xuICAgIC8vIFRoZSBhdWRpby1zdHJlYW0tY29udHJvbGxlciBoYW5kbGVzIGF1ZGlvIGJ1ZmZlcmluZyBpZiBIbHMuanMgaXMgcGxheWluZyBhbiBhbHRlcm5hdGUgYXVkaW8gdHJhY2tcbiAgICBjb25zdCBhdWRpbyA9IHRoaXMuYWx0QXVkaW8gPyB1bmRlZmluZWQgOiByZW11eFJlc3VsdC5hdWRpbztcblxuICAgIC8vIENoZWNrIGlmIHRoZSBjdXJyZW50IGZyYWdtZW50IGhhcyBiZWVuIGFib3J0ZWQuIFdlIGNoZWNrIHRoaXMgYnkgZmlyc3Qgc2VlaW5nIGlmIHdlJ3JlIHN0aWxsIHBsYXlpbmcgdGhlIGN1cnJlbnQgbGV2ZWwuXG4gICAgLy8gSWYgd2UgYXJlLCBzdWJzZXF1ZW50bHkgY2hlY2sgaWYgdGhlIGN1cnJlbnRseSBsb2FkaW5nIGZyYWdtZW50IChmcmFnQ3VycmVudCkgaGFzIGNoYW5nZWQuXG4gICAgaWYgKHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpKSB7XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBUlNJTkc7XG4gICAgaWYgKGluaXRTZWdtZW50KSB7XG4gICAgICBpZiAoaW5pdFNlZ21lbnQgIT0gbnVsbCAmJiBpbml0U2VnbWVudC50cmFja3MpIHtcbiAgICAgICAgY29uc3QgbWFwRnJhZ21lbnQgPSBmcmFnLmluaXRTZWdtZW50IHx8IGZyYWc7XG4gICAgICAgIHRoaXMuX2J1ZmZlckluaXRTZWdtZW50KGxldmVsLCBpbml0U2VnbWVudC50cmFja3MsIG1hcEZyYWdtZW50LCBjaHVua01ldGEpO1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCwge1xuICAgICAgICAgIGZyYWc6IG1hcEZyYWdtZW50LFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIHRyYWNrczogaW5pdFNlZ21lbnQudHJhY2tzXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGlzIHdvdWxkIGJlIG5pY2UgaWYgTnVtYmVyLmlzRmluaXRlIGFjdGVkIGFzIGEgdHlwZWd1YXJkLCBidXQgaXQgZG9lc24ndC4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzEwMDM4XG4gICAgICBjb25zdCBiYXNlVGltZSA9IGluaXRTZWdtZW50LmluaXRQVFM7XG4gICAgICBjb25zdCB0aW1lc2NhbGUgPSBpbml0U2VnbWVudC50aW1lc2NhbGU7XG4gICAgICBjb25zdCBpbml0UFRTID0gdGhpcy5pbml0UFRTW2ZyYWcuY2NdO1xuICAgICAgaWYgKGlzRmluaXRlTnVtYmVyKGJhc2VUaW1lKSAmJiAoIWluaXRQVFMgfHwgaW5pdFBUUy5iYXNlVGltZSAhPT0gYmFzZVRpbWUgfHwgaW5pdFBUUy50aW1lc2NhbGUgIT09IHRpbWVzY2FsZSkpIHtcbiAgICAgICAgdGhpcy5pbml0UFRTW2ZyYWcuY2NdID0ge1xuICAgICAgICAgIGJhc2VUaW1lLFxuICAgICAgICAgIHRpbWVzY2FsZVxuICAgICAgICB9O1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuSU5JVF9QVFNfRk9VTkQsIHtcbiAgICAgICAgICBmcmFnLFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIGluaXRQVFM6IGJhc2VUaW1lLFxuICAgICAgICAgIHRpbWVzY2FsZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBdm9pZCBidWZmZXJpbmcgaWYgYmFja3RyYWNraW5nIHRoaXMgZnJhZ21lbnRcbiAgICBpZiAodmlkZW8gJiYgZGV0YWlscykge1xuICAgICAgaWYgKGF1ZGlvICYmIHZpZGVvLnR5cGUgPT09ICdhdWRpb3ZpZGVvJykge1xuICAgICAgICB0aGlzLmxvZ011eGVkRXJyKGZyYWcpO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJldkZyYWcgPSBkZXRhaWxzLmZyYWdtZW50c1tmcmFnLnNuIC0gMSAtIGRldGFpbHMuc3RhcnRTTl07XG4gICAgICBjb25zdCBpc0ZpcnN0RnJhZ21lbnQgPSBmcmFnLnNuID09PSBkZXRhaWxzLnN0YXJ0U047XG4gICAgICBjb25zdCBpc0ZpcnN0SW5EaXNjb250aW51aXR5ID0gIXByZXZGcmFnIHx8IGZyYWcuY2MgPiBwcmV2RnJhZy5jYztcbiAgICAgIGlmIChyZW11eFJlc3VsdC5pbmRlcGVuZGVudCAhPT0gZmFsc2UpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHN0YXJ0UFRTLFxuICAgICAgICAgIGVuZFBUUyxcbiAgICAgICAgICBzdGFydERUUyxcbiAgICAgICAgICBlbmREVFNcbiAgICAgICAgfSA9IHZpZGVvO1xuICAgICAgICBpZiAocGFydCkge1xuICAgICAgICAgIHBhcnQuZWxlbWVudGFyeVN0cmVhbXNbdmlkZW8udHlwZV0gPSB7XG4gICAgICAgICAgICBzdGFydFBUUyxcbiAgICAgICAgICAgIGVuZFBUUyxcbiAgICAgICAgICAgIHN0YXJ0RFRTLFxuICAgICAgICAgICAgZW5kRFRTXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodmlkZW8uZmlyc3RLZXlGcmFtZSAmJiB2aWRlby5pbmRlcGVuZGVudCAmJiBjaHVua01ldGEuaWQgPT09IDEgJiYgIWlzRmlyc3RJbkRpc2NvbnRpbnVpdHkpIHtcbiAgICAgICAgICAgIHRoaXMuY291bGRCYWNrdHJhY2sgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmlkZW8uZHJvcHBlZCAmJiB2aWRlby5pbmRlcGVuZGVudCkge1xuICAgICAgICAgICAgLy8gQmFja3RyYWNrIGlmIGRyb3BwZWQgZnJhbWVzIGNyZWF0ZSBhIGdhcCBhZnRlciBjdXJyZW50VGltZVxuXG4gICAgICAgICAgICBjb25zdCBidWZmZXJJbmZvID0gdGhpcy5nZXRNYWluRndkQnVmZmVySW5mbygpO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0QnVmZmVyVGltZSA9IChidWZmZXJJbmZvID8gYnVmZmVySW5mby5lbmQgOiB0aGlzLmdldExvYWRQb3NpdGlvbigpKSArIHRoaXMuY29uZmlnLm1heEJ1ZmZlckhvbGU7XG4gICAgICAgICAgICBjb25zdCBzdGFydFRpbWUgPSB2aWRlby5maXJzdEtleUZyYW1lUFRTID8gdmlkZW8uZmlyc3RLZXlGcmFtZVBUUyA6IHN0YXJ0UFRTO1xuICAgICAgICAgICAgaWYgKCFpc0ZpcnN0RnJhZ21lbnQgJiYgdGFyZ2V0QnVmZmVyVGltZSA8IHN0YXJ0VGltZSAtIHRoaXMuY29uZmlnLm1heEJ1ZmZlckhvbGUgJiYgIWlzRmlyc3RJbkRpc2NvbnRpbnVpdHkpIHtcbiAgICAgICAgICAgICAgdGhpcy5iYWNrdHJhY2soZnJhZyk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNGaXJzdEluRGlzY29udGludWl0eSkge1xuICAgICAgICAgICAgICAvLyBNYXJrIHNlZ21lbnQgd2l0aCBhIGdhcCB0byBhdm9pZCBsb29wIGxvYWRpbmdcbiAgICAgICAgICAgICAgZnJhZy5nYXAgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2V0IHZpZGVvIHN0cmVhbSBzdGFydCB0byBmcmFnbWVudCBzdGFydCBzbyB0aGF0IHRydW5jYXRlZCBzYW1wbGVzIGRvIG5vdCBkaXN0b3J0IHRoZSB0aW1lbGluZSwgYW5kIG1hcmsgaXQgcGFydGlhbFxuICAgICAgICAgICAgZnJhZy5zZXRFbGVtZW50YXJ5U3RyZWFtSW5mbyh2aWRlby50eXBlLCBmcmFnLnN0YXJ0LCBlbmRQVFMsIGZyYWcuc3RhcnQsIGVuZERUUywgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0ZpcnN0RnJhZ21lbnQgJiYgc3RhcnRQVFMgLSAoZGV0YWlscy5hcHBsaWVkVGltZWxpbmVPZmZzZXQgfHwgMCkgPiBNQVhfU1RBUlRfR0FQX0pVTVApIHtcbiAgICAgICAgICAgIC8vIE1hcmsgc2VnbWVudCB3aXRoIGEgZ2FwIHRvIHNraXAgbGFyZ2Ugc3RhcnQgZ2FwXG4gICAgICAgICAgICBmcmFnLmdhcCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZyYWcuc2V0RWxlbWVudGFyeVN0cmVhbUluZm8odmlkZW8udHlwZSwgc3RhcnRQVFMsIGVuZFBUUywgc3RhcnREVFMsIGVuZERUUyk7XG4gICAgICAgIGlmICh0aGlzLmJhY2t0cmFja0ZyYWdtZW50KSB7XG4gICAgICAgICAgdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IGZyYWc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXJGcmFnbWVudERhdGEodmlkZW8sIGZyYWcsIHBhcnQsIGNodW5rTWV0YSwgaXNGaXJzdEZyYWdtZW50IHx8IGlzRmlyc3RJbkRpc2NvbnRpbnVpdHkpO1xuICAgICAgfSBlbHNlIGlmIChpc0ZpcnN0RnJhZ21lbnQgfHwgaXNGaXJzdEluRGlzY29udGludWl0eSkge1xuICAgICAgICAvLyBNYXJrIHNlZ21lbnQgd2l0aCBhIGdhcCB0byBhdm9pZCBsb29wIGxvYWRpbmdcbiAgICAgICAgZnJhZy5nYXAgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5iYWNrdHJhY2soZnJhZyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGF1ZGlvKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHN0YXJ0UFRTLFxuICAgICAgICBlbmRQVFMsXG4gICAgICAgIHN0YXJ0RFRTLFxuICAgICAgICBlbmREVFNcbiAgICAgIH0gPSBhdWRpbztcbiAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgIHBhcnQuZWxlbWVudGFyeVN0cmVhbXNbRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPXSA9IHtcbiAgICAgICAgICBzdGFydFBUUyxcbiAgICAgICAgICBlbmRQVFMsXG4gICAgICAgICAgc3RhcnREVFMsXG4gICAgICAgICAgZW5kRFRTXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBmcmFnLnNldEVsZW1lbnRhcnlTdHJlYW1JbmZvKEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJTywgc3RhcnRQVFMsIGVuZFBUUywgc3RhcnREVFMsIGVuZERUUyk7XG4gICAgICB0aGlzLmJ1ZmZlckZyYWdtZW50RGF0YShhdWRpbywgZnJhZywgcGFydCwgY2h1bmtNZXRhKTtcbiAgICB9XG4gICAgaWYgKGRldGFpbHMgJiYgaWQzICE9IG51bGwgJiYgKF9pZDMkc2FtcGxlcyA9IGlkMy5zYW1wbGVzKSAhPSBudWxsICYmIF9pZDMkc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGVtaXR0ZWRJRDMgPSB7XG4gICAgICAgIGlkLFxuICAgICAgICBmcmFnLFxuICAgICAgICBkZXRhaWxzLFxuICAgICAgICBzYW1wbGVzOiBpZDMuc2FtcGxlc1xuICAgICAgfTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX1BBUlNJTkdfTUVUQURBVEEsIGVtaXR0ZWRJRDMpO1xuICAgIH1cbiAgICBpZiAoZGV0YWlscyAmJiB0ZXh0KSB7XG4gICAgICBjb25zdCBlbWl0dGVkVGV4dCA9IHtcbiAgICAgICAgaWQsXG4gICAgICAgIGZyYWcsXG4gICAgICAgIGRldGFpbHMsXG4gICAgICAgIHNhbXBsZXM6IHRleHQuc2FtcGxlc1xuICAgICAgfTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsIGVtaXR0ZWRUZXh0KTtcbiAgICB9XG4gIH1cbiAgbG9nTXV4ZWRFcnIoZnJhZykge1xuICAgIHRoaXMud2FybihgJHtpc01lZGlhRnJhZ21lbnQoZnJhZykgPyAnTWVkaWEnIDogJ0luaXQnfSBzZWdtZW50IHdpdGggbXV4ZWQgYXVkaW92aWRlbyB3aGVyZSBvbmx5IHZpZGVvIGV4cGVjdGVkOiAke2ZyYWcudXJsfWApO1xuICB9XG4gIF9idWZmZXJJbml0U2VnbWVudChjdXJyZW50TGV2ZWwsIHRyYWNrcywgZnJhZywgY2h1bmtNZXRhKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5hdWRpb09ubHkgPSAhIXRyYWNrcy5hdWRpbyAmJiAhdHJhY2tzLnZpZGVvO1xuXG4gICAgLy8gaWYgYXVkaW8gdHJhY2sgaXMgZXhwZWN0ZWQgdG8gY29tZSBmcm9tIGF1ZGlvIHN0cmVhbSBjb250cm9sbGVyLCBkaXNjYXJkIGFueSBjb21pbmcgZnJvbSBtYWluXG4gICAgaWYgKHRoaXMuYWx0QXVkaW8gJiYgIXRoaXMuYXVkaW9Pbmx5KSB7XG4gICAgICBkZWxldGUgdHJhY2tzLmF1ZGlvO1xuICAgICAgaWYgKHRyYWNrcy5hdWRpb3ZpZGVvKSB7XG4gICAgICAgIHRoaXMubG9nTXV4ZWRFcnIoZnJhZyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGluY2x1ZGUgbGV2ZWxDb2RlYyBpbiBhdWRpbyBhbmQgdmlkZW8gdHJhY2tzXG4gICAgY29uc3Qge1xuICAgICAgYXVkaW8sXG4gICAgICB2aWRlbyxcbiAgICAgIGF1ZGlvdmlkZW9cbiAgICB9ID0gdHJhY2tzO1xuICAgIGlmIChhdWRpbykge1xuICAgICAgY29uc3QgbGV2ZWxDb2RlYyA9IGN1cnJlbnRMZXZlbC5hdWRpb0NvZGVjO1xuICAgICAgbGV0IGF1ZGlvQ29kZWMgPSBwaWNrTW9zdENvbXBsZXRlQ29kZWNOYW1lKGF1ZGlvLmNvZGVjLCBsZXZlbENvZGVjKTtcbiAgICAgIC8vIEFkZCBsZXZlbCBhbmQgcHJvZmlsZSB0byBtYWtlIHVwIGZvciByZW11eGVyIG5vdCBiZWluZyBhYmxlIHRvIHBhcnNlIGZ1bGwgY29kZWNcbiAgICAgIC8vIChsb2dnZXIgd2FybmluZyBcIlVuaGFuZGxlZCBhdWRpbyBjb2RlYy4uLlwiKVxuICAgICAgaWYgKGF1ZGlvQ29kZWMgPT09ICdtcDRhJykge1xuICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuNSc7XG4gICAgICB9XG4gICAgICAvLyBIYW5kbGUgYGF1ZGlvQ29kZWNTd2l0Y2hgXG4gICAgICBjb25zdCB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICh0aGlzLmF1ZGlvQ29kZWNTd2l0Y2gpIHtcbiAgICAgICAgaWYgKGF1ZGlvQ29kZWMpIHtcbiAgICAgICAgICBpZiAoYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjUnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC4yJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjUnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJbiB0aGUgY2FzZSB0aGF0IEFBQyBhbmQgSEUtQUFDIGF1ZGlvIGNvZGVjcyBhcmUgc2lnbmFsbGVkIGluIG1hbmlmZXN0LFxuICAgICAgICAvLyBmb3JjZSBIRS1BQUMsIGFzIGl0IHNlZW1zIHRoYXQgbW9zdCBicm93c2VycyBwcmVmZXJzIGl0LlxuICAgICAgICAvLyBkb24ndCBmb3JjZSBIRS1BQUMgaWYgbW9ubyBzdHJlYW0sIG9yIGluIEZpcmVmb3hcbiAgICAgICAgY29uc3QgYXVkaW9NZXRhZGF0YSA9IGF1ZGlvLm1ldGFkYXRhO1xuICAgICAgICBpZiAoYXVkaW9NZXRhZGF0YSAmJiAnY2hhbm5lbENvdW50JyBpbiBhdWRpb01ldGFkYXRhICYmIChhdWRpb01ldGFkYXRhLmNoYW5uZWxDb3VudCB8fCAxKSAhPT0gMSAmJiB1YS5pbmRleE9mKCdmaXJlZm94JykgPT09IC0xKSB7XG4gICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjUnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBIRS1BQUMgaXMgYnJva2VuIG9uIEFuZHJvaWQsIGFsd2F5cyBzaWduYWwgYXVkaW8gY29kZWMgYXMgQUFDIGV2ZW4gaWYgdmFyaWFudCBtYW5pZmVzdCBzdGF0ZXMgb3RoZXJ3aXNlXG4gICAgICBpZiAoYXVkaW9Db2RlYyAmJiBhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSAmJiB1YS5pbmRleE9mKCdhbmRyb2lkJykgIT09IC0xICYmIGF1ZGlvLmNvbnRhaW5lciAhPT0gJ2F1ZGlvL21wZWcnKSB7XG4gICAgICAgIC8vIEV4Y2x1ZGUgbXBlZyBhdWRpb1xuICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuMic7XG4gICAgICAgIHRoaXMubG9nKGBBbmRyb2lkOiBmb3JjZSBhdWRpbyBjb2RlYyB0byAke2F1ZGlvQ29kZWN9YCk7XG4gICAgICB9XG4gICAgICBpZiAobGV2ZWxDb2RlYyAmJiBsZXZlbENvZGVjICE9PSBhdWRpb0NvZGVjKSB7XG4gICAgICAgIHRoaXMubG9nKGBTd2FwcGluZyBtYW5pZmVzdCBhdWRpbyBjb2RlYyBcIiR7bGV2ZWxDb2RlY31cIiBmb3IgXCIke2F1ZGlvQ29kZWN9XCJgKTtcbiAgICAgIH1cbiAgICAgIGF1ZGlvLmxldmVsQ29kZWMgPSBhdWRpb0NvZGVjO1xuICAgICAgYXVkaW8uaWQgPSBQbGF5bGlzdExldmVsVHlwZS5NQUlOO1xuICAgICAgdGhpcy5sb2coYEluaXQgYXVkaW8gYnVmZmVyLCBjb250YWluZXI6JHthdWRpby5jb250YWluZXJ9LCBjb2RlY3Nbc2VsZWN0ZWQvbGV2ZWwvcGFyc2VkXT1bJHthdWRpb0NvZGVjIHx8ICcnfS8ke2xldmVsQ29kZWMgfHwgJyd9LyR7YXVkaW8uY29kZWN9XWApO1xuICAgICAgZGVsZXRlIHRyYWNrcy5hdWRpb3ZpZGVvO1xuICAgIH1cbiAgICBpZiAodmlkZW8pIHtcbiAgICAgIHZpZGVvLmxldmVsQ29kZWMgPSBjdXJyZW50TGV2ZWwudmlkZW9Db2RlYztcbiAgICAgIHZpZGVvLmlkID0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTjtcbiAgICAgIGNvbnN0IHBhcnNlZFZpZGVvQ29kZWMgPSB2aWRlby5jb2RlYztcbiAgICAgIGlmICgocGFyc2VkVmlkZW9Db2RlYyA9PSBudWxsID8gdm9pZCAwIDogcGFyc2VkVmlkZW9Db2RlYy5sZW5ndGgpID09PSA0KSB7XG4gICAgICAgIC8vIE1ha2UgdXAgZm9yIHBhc3N0aHJvdWdoLXJlbXV4ZXIgbm90IGJlaW5nIGFibGUgdG8gcGFyc2UgZnVsbCBjb2RlY1xuICAgICAgICAvLyAobG9nZ2VyIHdhcm5pbmcgXCJVbmhhbmRsZWQgdmlkZW8gY29kZWMuLi5cIilcbiAgICAgICAgc3dpdGNoIChwYXJzZWRWaWRlb0NvZGVjKSB7XG4gICAgICAgICAgY2FzZSAnaHZjMSc6XG4gICAgICAgICAgY2FzZSAnaGV2MSc6XG4gICAgICAgICAgICB2aWRlby5jb2RlYyA9ICdodmMxLjEuNi5MMTIwLjkwJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2F2MDEnOlxuICAgICAgICAgICAgdmlkZW8uY29kZWMgPSAnYXYwMS4wLjA0TS4wOCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdhdmMxJzpcbiAgICAgICAgICAgIHZpZGVvLmNvZGVjID0gJ2F2YzEuNDJlMDFlJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmxvZyhgSW5pdCB2aWRlbyBidWZmZXIsIGNvbnRhaW5lcjoke3ZpZGVvLmNvbnRhaW5lcn0sIGNvZGVjc1tsZXZlbC9wYXJzZWRdPVske2N1cnJlbnRMZXZlbC52aWRlb0NvZGVjIHx8ICcnfS8ke3BhcnNlZFZpZGVvQ29kZWN9XSR7dmlkZW8uY29kZWMgIT09IHBhcnNlZFZpZGVvQ29kZWMgPyAnIHBhcnNlZC1jb3JyZWN0ZWQ9JyArIHZpZGVvLmNvZGVjIDogJyd9JHt2aWRlby5zdXBwbGVtZW50YWwgPyAnIHN1cHBsZW1lbnRhbD0nICsgdmlkZW8uc3VwcGxlbWVudGFsIDogJyd9YCk7XG4gICAgICBkZWxldGUgdHJhY2tzLmF1ZGlvdmlkZW87XG4gICAgfVxuICAgIGlmIChhdWRpb3ZpZGVvKSB7XG4gICAgICB0aGlzLmxvZyhgSW5pdCBhdWRpb3ZpZGVvIGJ1ZmZlciwgY29udGFpbmVyOiR7YXVkaW92aWRlby5jb250YWluZXJ9LCBjb2RlY3NbbGV2ZWwvcGFyc2VkXT1bJHtjdXJyZW50TGV2ZWwuY29kZWNzfS8ke2F1ZGlvdmlkZW8uY29kZWN9XWApO1xuICAgICAgZGVsZXRlIHRyYWNrcy52aWRlbztcbiAgICAgIGRlbGV0ZSB0cmFja3MuYXVkaW87XG4gICAgfVxuICAgIGNvbnN0IHRyYWNrVHlwZXMgPSBPYmplY3Qua2V5cyh0cmFja3MpO1xuICAgIGlmICh0cmFja1R5cGVzLmxlbmd0aCkge1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0NPREVDUywgdHJhY2tzKTtcbiAgICAgIGlmICghdGhpcy5obHMpIHtcbiAgICAgICAgLy8gRXhpdCBhZnRlciBmYXRhbCB0cmFja3MgZXJyb3JcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gbG9vcCB0aHJvdWdoIHRyYWNrcyB0aGF0IGFyZSBnb2luZyB0byBiZSBwcm92aWRlZCB0byBidWZmZXJDb250cm9sbGVyXG4gICAgICB0cmFja1R5cGVzLmZvckVhY2godHJhY2tOYW1lID0+IHtcbiAgICAgICAgY29uc3QgdHJhY2sgPSB0cmFja3NbdHJhY2tOYW1lXTtcbiAgICAgICAgY29uc3QgaW5pdFNlZ21lbnQgPSB0cmFjay5pbml0U2VnbWVudDtcbiAgICAgICAgaWYgKGluaXRTZWdtZW50ICE9IG51bGwgJiYgaW5pdFNlZ21lbnQuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9BUFBFTkRJTkcsIHtcbiAgICAgICAgICAgIHR5cGU6IHRyYWNrTmFtZSxcbiAgICAgICAgICAgIGRhdGE6IGluaXRTZWdtZW50LFxuICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgIHBhcnQ6IG51bGwsXG4gICAgICAgICAgICBjaHVua01ldGEsXG4gICAgICAgICAgICBwYXJlbnQ6IGZyYWcudHlwZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgIHRoaXMudGlja0ltbWVkaWF0ZSgpO1xuICB9XG4gIGdldE1haW5Gd2RCdWZmZXJJbmZvKCkge1xuICAgIC8vIE9ic2VydmUgdmlkZW8gU291cmNlQnVmZmVyICh0aGlzLm1lZGlhQnVmZmVyKSBvbmx5IHdoZW4gYWx0LWF1ZGlvIGlzIHVzZWQsIG90aGVyd2lzZSBvYnNlcnZlIGNvbWJpbmVkIG1lZGlhIGJ1ZmZlclxuICAgIGNvbnN0IGJ1ZmZlck91dHB1dCA9IHRoaXMubWVkaWFCdWZmZXIgJiYgdGhpcy5hbHRBdWRpbyA9PT0gMiA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhO1xuICAgIHJldHVybiB0aGlzLmdldEZ3ZEJ1ZmZlckluZm8oYnVmZmVyT3V0cHV0LCBQbGF5bGlzdExldmVsVHlwZS5NQUlOKTtcbiAgfVxuICBnZXQgbWF4QnVmZmVyTGVuZ3RoKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxldmVscyxcbiAgICAgIGxldmVsXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgbGV2ZWxJbmZvID0gbGV2ZWxzID09IG51bGwgPyB2b2lkIDAgOiBsZXZlbHNbbGV2ZWxdO1xuICAgIGlmICghbGV2ZWxJbmZvKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25maWcubWF4QnVmZmVyTGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRNYXhCdWZmZXJMZW5ndGgobGV2ZWxJbmZvLm1heEJpdHJhdGUpO1xuICB9XG4gIGJhY2t0cmFjayhmcmFnKSB7XG4gICAgdGhpcy5jb3VsZEJhY2t0cmFjayA9IHRydWU7XG4gICAgLy8gQ2F1c2VzIGZpbmRGcmFnbWVudHMgdG8gYmFja3RyYWNrIHRocm91Z2ggZnJhZ21lbnRzIHRvIGZpbmQgdGhlIGtleWZyYW1lXG4gICAgdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IGZyYWc7XG4gICAgdGhpcy5yZXNldFRyYW5zbXV4ZXIoKTtcbiAgICB0aGlzLmZsdXNoQnVmZmVyR2FwKGZyYWcpO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBmcmFnLnN0YXJ0O1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICB9XG4gIGNoZWNrRnJhZ21lbnRDaGFuZ2VkKCkge1xuICAgIGNvbnN0IHZpZGVvID0gdGhpcy5tZWRpYTtcbiAgICBsZXQgZnJhZ1BsYXlpbmdDdXJyZW50ID0gbnVsbDtcbiAgICBpZiAodmlkZW8gJiYgdmlkZW8ucmVhZHlTdGF0ZSA+IDEgJiYgdmlkZW8uc2Vla2luZyA9PT0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gdmlkZW8uY3VycmVudFRpbWU7XG4gICAgICAvKiBpZiB2aWRlbyBlbGVtZW50IGlzIGluIHNlZWtlZCBzdGF0ZSwgY3VycmVudFRpbWUgY2FuIG9ubHkgaW5jcmVhc2UuXG4gICAgICAgIChhc3N1bWluZyB0aGF0IHBsYXliYWNrIHJhdGUgaXMgcG9zaXRpdmUgLi4uKVxuICAgICAgICBBcyBzb21ldGltZXMgY3VycmVudFRpbWUganVtcHMgYmFjayB0byB6ZXJvIGFmdGVyIGFcbiAgICAgICAgbWVkaWEgZGVjb2RlIGVycm9yLCBjaGVjayB0aGlzLCB0byBhdm9pZCBzZWVraW5nIGJhY2sgdG9cbiAgICAgICAgd3JvbmcgcG9zaXRpb24gYWZ0ZXIgYSBtZWRpYSBkZWNvZGUgZXJyb3JcbiAgICAgICovXG5cbiAgICAgIGlmIChCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZCh2aWRlbywgY3VycmVudFRpbWUpKSB7XG4gICAgICAgIGZyYWdQbGF5aW5nQ3VycmVudCA9IHRoaXMuZ2V0QXBwZW5kZWRGcmFnKGN1cnJlbnRUaW1lKTtcbiAgICAgIH0gZWxzZSBpZiAoQnVmZmVySGVscGVyLmlzQnVmZmVyZWQodmlkZW8sIGN1cnJlbnRUaW1lICsgMC4xKSkge1xuICAgICAgICAvKiBlbnN1cmUgdGhhdCBGUkFHX0NIQU5HRUQgZXZlbnQgaXMgdHJpZ2dlcmVkIGF0IHN0YXJ0dXAsXG4gICAgICAgICAgd2hlbiBmaXJzdCB2aWRlbyBmcmFtZSBpcyBkaXNwbGF5ZWQgYW5kIHBsYXliYWNrIGlzIHBhdXNlZC5cbiAgICAgICAgICBhZGQgYSB0b2xlcmFuY2Ugb2YgMTAwbXMsIGluIGNhc2UgY3VycmVudCBwb3NpdGlvbiBpcyBub3QgYnVmZmVyZWQsXG4gICAgICAgICAgY2hlY2sgaWYgY3VycmVudCBwb3MrMTAwbXMgaXMgYnVmZmVyZWQgYW5kIHVzZSB0aGF0IGJ1ZmZlciByYW5nZVxuICAgICAgICAgIGZvciBGUkFHX0NIQU5HRUQgZXZlbnQgcmVwb3J0aW5nICovXG4gICAgICAgIGZyYWdQbGF5aW5nQ3VycmVudCA9IHRoaXMuZ2V0QXBwZW5kZWRGcmFnKGN1cnJlbnRUaW1lICsgMC4xKTtcbiAgICAgIH1cbiAgICAgIGlmIChmcmFnUGxheWluZ0N1cnJlbnQpIHtcbiAgICAgICAgdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IG51bGw7XG4gICAgICAgIGNvbnN0IGZyYWdQbGF5aW5nID0gdGhpcy5mcmFnUGxheWluZztcbiAgICAgICAgY29uc3QgZnJhZ0N1cnJlbnRMZXZlbCA9IGZyYWdQbGF5aW5nQ3VycmVudC5sZXZlbDtcbiAgICAgICAgaWYgKCFmcmFnUGxheWluZyB8fCBmcmFnUGxheWluZ0N1cnJlbnQuc24gIT09IGZyYWdQbGF5aW5nLnNuIHx8IGZyYWdQbGF5aW5nLmxldmVsICE9PSBmcmFnQ3VycmVudExldmVsKSB7XG4gICAgICAgICAgdGhpcy5mcmFnUGxheWluZyA9IGZyYWdQbGF5aW5nQ3VycmVudDtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0NIQU5HRUQsIHtcbiAgICAgICAgICAgIGZyYWc6IGZyYWdQbGF5aW5nQ3VycmVudFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICghZnJhZ1BsYXlpbmcgfHwgZnJhZ1BsYXlpbmcubGV2ZWwgIT09IGZyYWdDdXJyZW50TGV2ZWwpIHtcbiAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkxFVkVMX1NXSVRDSEVELCB7XG4gICAgICAgICAgICAgIGxldmVsOiBmcmFnQ3VycmVudExldmVsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0IG5leHRMZXZlbCgpIHtcbiAgICBjb25zdCBmcmFnID0gdGhpcy5uZXh0QnVmZmVyZWRGcmFnO1xuICAgIGlmIChmcmFnKSB7XG4gICAgICByZXR1cm4gZnJhZy5sZXZlbDtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGdldCBjdXJyZW50RnJhZygpIHtcbiAgICB2YXIgX3RoaXMkbWVkaWEzO1xuICAgIGlmICh0aGlzLmZyYWdQbGF5aW5nKSB7XG4gICAgICByZXR1cm4gdGhpcy5mcmFnUGxheWluZztcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSAoKF90aGlzJG1lZGlhMyA9IHRoaXMubWVkaWEpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRtZWRpYTMuY3VycmVudFRpbWUpIHx8IHRoaXMubGFzdEN1cnJlbnRUaW1lO1xuICAgIGlmIChpc0Zpbml0ZU51bWJlcihjdXJyZW50VGltZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEFwcGVuZGVkRnJhZyhjdXJyZW50VGltZSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdldCBjdXJyZW50UHJvZ3JhbURhdGVUaW1lKCkge1xuICAgIHZhciBfdGhpcyRtZWRpYTQ7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSAoKF90aGlzJG1lZGlhNCA9IHRoaXMubWVkaWEpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRtZWRpYTQuY3VycmVudFRpbWUpIHx8IHRoaXMubGFzdEN1cnJlbnRUaW1lO1xuICAgIGlmIChpc0Zpbml0ZU51bWJlcihjdXJyZW50VGltZSkpIHtcbiAgICAgIGNvbnN0IGRldGFpbHMgPSB0aGlzLmdldExldmVsRGV0YWlscygpO1xuICAgICAgY29uc3QgZnJhZyA9IHRoaXMuY3VycmVudEZyYWcgfHwgKGRldGFpbHMgPyBmaW5kRnJhZ21lbnRCeVBUUyhudWxsLCBkZXRhaWxzLmZyYWdtZW50cywgY3VycmVudFRpbWUpIDogbnVsbCk7XG4gICAgICBpZiAoZnJhZykge1xuICAgICAgICBjb25zdCBwcm9ncmFtRGF0ZVRpbWUgPSBmcmFnLnByb2dyYW1EYXRlVGltZTtcbiAgICAgICAgaWYgKHByb2dyYW1EYXRlVGltZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IGVwb2NNcyA9IHByb2dyYW1EYXRlVGltZSArIChjdXJyZW50VGltZSAtIGZyYWcuc3RhcnQpICogMTAwMDtcbiAgICAgICAgICByZXR1cm4gbmV3IERhdGUoZXBvY01zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnZXQgY3VycmVudExldmVsKCkge1xuICAgIGNvbnN0IGZyYWcgPSB0aGlzLmN1cnJlbnRGcmFnO1xuICAgIGlmIChmcmFnKSB7XG4gICAgICByZXR1cm4gZnJhZy5sZXZlbDtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGdldCBuZXh0QnVmZmVyZWRGcmFnKCkge1xuICAgIGNvbnN0IGZyYWcgPSB0aGlzLmN1cnJlbnRGcmFnO1xuICAgIGlmIChmcmFnKSB7XG4gICAgICByZXR1cm4gdGhpcy5mb2xsb3dpbmdCdWZmZXJlZEZyYWcoZnJhZyk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdldCBmb3JjZVN0YXJ0TG9hZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9yY2VTdGFydExvYWQ7XG4gIH1cbn1cblxuY2xhc3MgS2V5TG9hZGVyIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXlVcmlUb0tleUluZm8gPSB7fTtcbiAgICB0aGlzLmVtZUNvbnRyb2xsZXIgPSBudWxsO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICB9XG4gIGFib3J0KHR5cGUpIHtcbiAgICBmb3IgKGNvbnN0IHVyaSBpbiB0aGlzLmtleVVyaVRvS2V5SW5mbykge1xuICAgICAgY29uc3QgbG9hZGVyID0gdGhpcy5rZXlVcmlUb0tleUluZm9bdXJpXS5sb2FkZXI7XG4gICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgIHZhciBfbG9hZGVyJGNvbnRleHQ7XG4gICAgICAgIGlmICh0eXBlICYmIHR5cGUgIT09ICgoX2xvYWRlciRjb250ZXh0ID0gbG9hZGVyLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbG9hZGVyJGNvbnRleHQuZnJhZy50eXBlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZGV0YWNoKCkge1xuICAgIGZvciAoY29uc3QgdXJpIGluIHRoaXMua2V5VXJpVG9LZXlJbmZvKSB7XG4gICAgICBjb25zdCBrZXlJbmZvID0gdGhpcy5rZXlVcmlUb0tleUluZm9bdXJpXTtcbiAgICAgIC8vIFJlbW92ZSBjYWNoZWQgRU1FIGtleXMgb24gZGV0YWNoXG4gICAgICBpZiAoa2V5SW5mby5tZWRpYUtleVNlc3Npb25Db250ZXh0IHx8IGtleUluZm8uZGVjcnlwdGRhdGEuaXNDb21tb25FbmNyeXB0aW9uKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmtleVVyaVRvS2V5SW5mb1t1cmldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgZm9yIChjb25zdCB1cmkgaW4gdGhpcy5rZXlVcmlUb0tleUluZm8pIHtcbiAgICAgIGNvbnN0IGxvYWRlciA9IHRoaXMua2V5VXJpVG9LZXlJbmZvW3VyaV0ubG9hZGVyO1xuICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICBsb2FkZXIuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmtleVVyaVRvS2V5SW5mbyA9IHt9O1xuICB9XG4gIGNyZWF0ZUtleUxvYWRFcnJvcihmcmFnLCBkZXRhaWxzID0gRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SLCBlcnJvciwgbmV0d29ya0RldGFpbHMsIHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIG5ldyBMb2FkRXJyb3Ioe1xuICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgZGV0YWlscyxcbiAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgIGZyYWcsXG4gICAgICByZXNwb25zZSxcbiAgICAgIGVycm9yLFxuICAgICAgbmV0d29ya0RldGFpbHNcbiAgICB9KTtcbiAgfVxuICBsb2FkQ2xlYXIobG9hZGluZ0ZyYWcsIGVuY3J5cHRlZEZyYWdtZW50cywgc3RhcnRGcmFnUmVxdWVzdGVkKSB7XG4gICAgaWYgKHRoaXMuZW1lQ29udHJvbGxlciAmJiB0aGlzLmNvbmZpZy5lbWVFbmFibGVkICYmICF0aGlzLmVtZUNvbnRyb2xsZXIuZ2V0U2VsZWN0ZWRLZXlTeXN0ZW1Gb3JtYXRzKCkubGVuZ3RoKSB7XG4gICAgICAvLyBBY2Nlc3Mga2V5LXN5c3RlbSB3aXRoIG5lYXJlc3Qga2V5IG9uIHN0YXJ0IChsb2FkaW5nIGZyYWcgaXMgdW5lbmNyeXB0ZWQpXG4gICAgICBpZiAoZW5jcnlwdGVkRnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGVuY3J5cHRlZEZyYWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBmcmFnID0gZW5jcnlwdGVkRnJhZ21lbnRzW2ldO1xuICAgICAgICAgIC8vIExvYWRpbmcgYXQgb3IgYmVmb3JlIHNlZ21lbnQgd2l0aCBFWFQtWC1LRVksIG9yIGZpcnN0IGZyYWcgbG9hZGluZyBhbmQgbGFzdCBFWFQtWC1LRVlcbiAgICAgICAgICBpZiAobG9hZGluZ0ZyYWcuY2MgPD0gZnJhZy5jYyAmJiAoIWlzTWVkaWFGcmFnbWVudChsb2FkaW5nRnJhZykgfHwgIWlzTWVkaWFGcmFnbWVudChmcmFnKSB8fCBsb2FkaW5nRnJhZy5zbiA8IGZyYWcuc24pIHx8ICFzdGFydEZyYWdSZXF1ZXN0ZWQgJiYgaSA9PSBsIC0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1lQ29udHJvbGxlci5zZWxlY3RLZXlTeXN0ZW1Gb3JtYXQoZnJhZykudGhlbihrZXlTeXN0ZW1Gb3JtYXQgPT4ge1xuICAgICAgICAgICAgICBpZiAoIXRoaXMuZW1lQ29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmcmFnLnNldEtleUZvcm1hdChrZXlTeXN0ZW1Gb3JtYXQpO1xuICAgICAgICAgICAgICBjb25zdCBrZXlTeXN0ZW0gPSBrZXlTeXN0ZW1Gb3JtYXRUb0tleVN5c3RlbURvbWFpbihrZXlTeXN0ZW1Gb3JtYXQpO1xuICAgICAgICAgICAgICBpZiAoa2V5U3lzdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1lQ29udHJvbGxlci5nZXRLZXlTeXN0ZW1BY2Nlc3MoW2tleVN5c3RlbV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNvbmZpZy5yZXF1aXJlS2V5U3lzdGVtQWNjZXNzT25TdGFydCkge1xuICAgICAgICBjb25zdCBrZXlTeXN0ZW1zSW5Db25maWcgPSBnZXRLZXlTeXN0ZW1zRm9yQ29uZmlnKHRoaXMuY29uZmlnKTtcbiAgICAgICAgaWYgKGtleVN5c3RlbXNJbkNvbmZpZy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbWVDb250cm9sbGVyLmdldEtleVN5c3RlbUFjY2VzcyhrZXlTeXN0ZW1zSW5Db25maWcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxvYWQoZnJhZykge1xuICAgIGlmICghZnJhZy5kZWNyeXB0ZGF0YSAmJiBmcmFnLmVuY3J5cHRlZCAmJiB0aGlzLmVtZUNvbnRyb2xsZXIgJiYgdGhpcy5jb25maWcuZW1lRW5hYmxlZCkge1xuICAgICAgLy8gTXVsdGlwbGUga2V5cywgYnV0IG5vbmUgc2VsZWN0ZWQsIHJlc29sdmUgaW4gZW1lLWNvbnRyb2xsZXJcbiAgICAgIHJldHVybiB0aGlzLmVtZUNvbnRyb2xsZXIuc2VsZWN0S2V5U3lzdGVtRm9ybWF0KGZyYWcpLnRoZW4oa2V5U3lzdGVtRm9ybWF0ID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZEludGVybmFsKGZyYWcsIGtleVN5c3RlbUZvcm1hdCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubG9hZEludGVybmFsKGZyYWcpO1xuICB9XG4gIGxvYWRJbnRlcm5hbChmcmFnLCBrZXlTeXN0ZW1Gb3JtYXQpIHtcbiAgICB2YXIgX2tleUluZm8sIF9rZXlJbmZvMjtcbiAgICBpZiAoa2V5U3lzdGVtRm9ybWF0KSB7XG4gICAgICBmcmFnLnNldEtleUZvcm1hdChrZXlTeXN0ZW1Gb3JtYXQpO1xuICAgIH1cbiAgICBjb25zdCBkZWNyeXB0ZGF0YSA9IGZyYWcuZGVjcnlwdGRhdGE7XG4gICAgaWYgKCFkZWNyeXB0ZGF0YSkge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3Ioa2V5U3lzdGVtRm9ybWF0ID8gYEV4cGVjdGVkIGZyYWcuZGVjcnlwdGRhdGEgdG8gYmUgZGVmaW5lZCBhZnRlciBzZXR0aW5nIGZvcm1hdCAke2tleVN5c3RlbUZvcm1hdH1gIDogJ01pc3NpbmcgZGVjcnlwdGlvbiBkYXRhIG9uIGZyYWdtZW50IGluIG9uS2V5TG9hZGluZycpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHRoaXMuY3JlYXRlS2V5TG9hZEVycm9yKGZyYWcsIEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUiwgZXJyb3IpKTtcbiAgICB9XG4gICAgY29uc3QgdXJpID0gZGVjcnlwdGRhdGEudXJpO1xuICAgIGlmICghdXJpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QodGhpcy5jcmVhdGVLZXlMb2FkRXJyb3IoZnJhZywgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SLCBuZXcgRXJyb3IoYEludmFsaWQga2V5IFVSSTogXCIke3VyaX1cImApKSk7XG4gICAgfVxuICAgIGxldCBrZXlJbmZvID0gdGhpcy5rZXlVcmlUb0tleUluZm9bdXJpXTtcbiAgICBpZiAoKF9rZXlJbmZvID0ga2V5SW5mbykgIT0gbnVsbCAmJiBfa2V5SW5mby5kZWNyeXB0ZGF0YS5rZXkpIHtcbiAgICAgIGRlY3J5cHRkYXRhLmtleSA9IGtleUluZm8uZGVjcnlwdGRhdGEua2V5O1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIGZyYWcsXG4gICAgICAgIGtleUluZm9cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBSZXR1cm4ga2V5IGxvYWQgcHJvbWlzZSBhcyBsb25nIGFzIGl0IGRvZXMgbm90IGhhdmUgYSBtZWRpYWtleSBzZXNzaW9uIHdpdGggYW4gdW51c2FibGUga2V5IHN0YXR1c1xuICAgIGlmICgoX2tleUluZm8yID0ga2V5SW5mbykgIT0gbnVsbCAmJiBfa2V5SW5mbzIua2V5TG9hZFByb21pc2UpIHtcbiAgICAgIHZhciBfa2V5SW5mbyRtZWRpYUtleVNlc3M7XG4gICAgICBzd2l0Y2ggKChfa2V5SW5mbyRtZWRpYUtleVNlc3MgPSBrZXlJbmZvLm1lZGlhS2V5U2Vzc2lvbkNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfa2V5SW5mbyRtZWRpYUtleVNlc3Mua2V5U3RhdHVzKSB7XG4gICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICBjYXNlICdzdGF0dXMtcGVuZGluZyc6XG4gICAgICAgIGNhc2UgJ3VzYWJsZSc6XG4gICAgICAgIGNhc2UgJ3VzYWJsZS1pbi1mdXR1cmUnOlxuICAgICAgICAgIHJldHVybiBrZXlJbmZvLmtleUxvYWRQcm9taXNlLnRoZW4oa2V5TG9hZGVkRGF0YSA9PiB7XG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGNvcnJlY3QgZnJhZ21lbnQgd2l0aCB1cGRhdGVkIGRlY3J5cHRkYXRhIGtleSBhbmQgbG9hZGVkIGtleUluZm9cbiAgICAgICAgICAgIGRlY3J5cHRkYXRhLmtleSA9IGtleUxvYWRlZERhdGEua2V5SW5mby5kZWNyeXB0ZGF0YS5rZXk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgICBrZXlJbmZvXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8gSWYgd2UgaGF2ZSBhIGtleSBzZXNzaW9uIGFuZCBzdGF0dXMgYW5kIGl0IGlzIG5vdCBwZW5kaW5nIG9yIHVzYWJsZSwgY29udGludWVcbiAgICAgIC8vIFRoaXMgd2lsbCBnbyBiYWNrIHRvIHRoZSBlbWUtY29udHJvbGxlciBmb3IgZXhwaXJlZCBrZXlzIHRvIGdldCBhIG5ldyBrZXlMb2FkUHJvbWlzZVxuICAgIH1cblxuICAgIC8vIExvYWQgdGhlIGtleSBvciByZXR1cm4gdGhlIGxvYWRpbmcgcHJvbWlzZVxuICAgIGtleUluZm8gPSB0aGlzLmtleVVyaVRvS2V5SW5mb1t1cmldID0ge1xuICAgICAgZGVjcnlwdGRhdGEsXG4gICAgICBrZXlMb2FkUHJvbWlzZTogbnVsbCxcbiAgICAgIGxvYWRlcjogbnVsbCxcbiAgICAgIG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQ6IG51bGxcbiAgICB9O1xuICAgIHN3aXRjaCAoZGVjcnlwdGRhdGEubWV0aG9kKSB7XG4gICAgICBjYXNlICdJU08tMjMwMDEtNyc6XG4gICAgICBjYXNlICdTQU1QTEUtQUVTJzpcbiAgICAgIGNhc2UgJ1NBTVBMRS1BRVMtQ0VOQyc6XG4gICAgICBjYXNlICdTQU1QTEUtQUVTLUNUUic6XG4gICAgICAgIGlmIChkZWNyeXB0ZGF0YS5rZXlGb3JtYXQgPT09ICdpZGVudGl0eScpIHtcbiAgICAgICAgICAvLyBsb2FkS2V5SFRUUCBoYW5kbGVzIGh0dHAocykgYW5kIGRhdGEgVVJMc1xuICAgICAgICAgIHJldHVybiB0aGlzLmxvYWRLZXlIVFRQKGtleUluZm8sIGZyYWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRLZXlFTUUoa2V5SW5mbywgZnJhZyk7XG4gICAgICBjYXNlICdBRVMtMTI4JzpcbiAgICAgIGNhc2UgJ0FFUy0yNTYnOlxuICAgICAgY2FzZSAnQUVTLTI1Ni1DVFInOlxuICAgICAgICByZXR1cm4gdGhpcy5sb2FkS2V5SFRUUChrZXlJbmZvLCBmcmFnKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLmNyZWF0ZUtleUxvYWRFcnJvcihmcmFnLCBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1IsIG5ldyBFcnJvcihgS2V5IHN1cHBsaWVkIHdpdGggdW5zdXBwb3J0ZWQgTUVUSE9EOiBcIiR7ZGVjcnlwdGRhdGEubWV0aG9kfVwiYCkpKTtcbiAgICB9XG4gIH1cbiAgbG9hZEtleUVNRShrZXlJbmZvLCBmcmFnKSB7XG4gICAgY29uc3Qga2V5TG9hZGVkRGF0YSA9IHtcbiAgICAgIGZyYWcsXG4gICAgICBrZXlJbmZvXG4gICAgfTtcbiAgICBpZiAodGhpcy5lbWVDb250cm9sbGVyICYmIHRoaXMuY29uZmlnLmVtZUVuYWJsZWQpIHtcbiAgICAgIGNvbnN0IGtleVNlc3Npb25Db250ZXh0UHJvbWlzZSA9IHRoaXMuZW1lQ29udHJvbGxlci5sb2FkS2V5KGtleUxvYWRlZERhdGEpO1xuICAgICAgaWYgKGtleVNlc3Npb25Db250ZXh0UHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gKGtleUluZm8ua2V5TG9hZFByb21pc2UgPSBrZXlTZXNzaW9uQ29udGV4dFByb21pc2UudGhlbihrZXlTZXNzaW9uQ29udGV4dCA9PiB7XG4gICAgICAgICAga2V5SW5mby5tZWRpYUtleVNlc3Npb25Db250ZXh0ID0ga2V5U2Vzc2lvbkNvbnRleHQ7XG4gICAgICAgICAgcmV0dXJuIGtleUxvYWRlZERhdGE7XG4gICAgICAgIH0pKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgLy8gUmVtb3ZlIHByb21pc2UgZm9yIGxpY2Vuc2UgcmVuZXdhbCBvciByZXRyeVxuICAgICAgICAgIGtleUluZm8ua2V5TG9hZFByb21pc2UgPSBudWxsO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShrZXlMb2FkZWREYXRhKTtcbiAgfVxuICBsb2FkS2V5SFRUUChrZXlJbmZvLCBmcmFnKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgY29uc3QgTG9hZGVyID0gY29uZmlnLmxvYWRlcjtcbiAgICBjb25zdCBrZXlMb2FkZXIgPSBuZXcgTG9hZGVyKGNvbmZpZyk7XG4gICAgZnJhZy5rZXlMb2FkZXIgPSBrZXlJbmZvLmxvYWRlciA9IGtleUxvYWRlcjtcbiAgICByZXR1cm4ga2V5SW5mby5rZXlMb2FkUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGxvYWRlckNvbnRleHQgPSB7XG4gICAgICAgIGtleUluZm8sXG4gICAgICAgIGZyYWcsXG4gICAgICAgIHJlc3BvbnNlVHlwZTogJ2FycmF5YnVmZmVyJyxcbiAgICAgICAgdXJsOiBrZXlJbmZvLmRlY3J5cHRkYXRhLnVyaVxuICAgICAgfTtcblxuICAgICAgLy8gbWF4UmV0cnkgaXMgMCBzbyB0aGF0IGluc3RlYWQgb2YgcmV0cnlpbmcgdGhlIHNhbWUga2V5IG9uIHRoZSBzYW1lIHZhcmlhbnQgbXVsdGlwbGUgdGltZXMsXG4gICAgICAvLyBrZXktbG9hZGVyIHdpbGwgdHJpZ2dlciBhbiBlcnJvciBhbmQgcmVseSBvbiBzdHJlYW0tY29udHJvbGxlciB0byBoYW5kbGUgcmV0cnkgbG9naWMuXG4gICAgICAvLyB0aGlzIHdpbGwgYWxzbyBhbGlnbiByZXRyeSBsb2dpYyB3aXRoIGZyYWdtZW50LWxvYWRlclxuICAgICAgY29uc3QgbG9hZFBvbGljeSA9IGNvbmZpZy5rZXlMb2FkUG9saWN5LmRlZmF1bHQ7XG4gICAgICBjb25zdCBsb2FkZXJDb25maWcgPSB7XG4gICAgICAgIGxvYWRQb2xpY3ksXG4gICAgICAgIHRpbWVvdXQ6IGxvYWRQb2xpY3kubWF4TG9hZFRpbWVNcyxcbiAgICAgICAgbWF4UmV0cnk6IDAsXG4gICAgICAgIHJldHJ5RGVsYXk6IDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXk6IDBcbiAgICAgIH07XG4gICAgICBjb25zdCBsb2FkZXJDYWxsYmFja3MgPSB7XG4gICAgICAgIG9uU3VjY2VzczogKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpID0+IHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAga2V5SW5mbyxcbiAgICAgICAgICAgIHVybDogdXJpXG4gICAgICAgICAgfSA9IGNvbnRleHQ7XG4gICAgICAgICAgaWYgKCFmcmFnLmRlY3J5cHRkYXRhIHx8IGtleUluZm8gIT09IHRoaXMua2V5VXJpVG9LZXlJbmZvW3VyaV0pIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QodGhpcy5jcmVhdGVLZXlMb2FkRXJyb3IoZnJhZywgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SLCBuZXcgRXJyb3IoJ2FmdGVyIGtleSBsb2FkLCBkZWNyeXB0ZGF0YSB1bnNldCBvciBjaGFuZ2VkJyksIG5ldHdvcmtEZXRhaWxzKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGtleUluZm8uZGVjcnlwdGRhdGEua2V5ID0gZnJhZy5kZWNyeXB0ZGF0YS5rZXkgPSBuZXcgVWludDhBcnJheShyZXNwb25zZS5kYXRhKTtcblxuICAgICAgICAgIC8vIGRldGFjaCBmcmFnbWVudCBrZXkgbG9hZGVyIG9uIGxvYWQgc3VjY2Vzc1xuICAgICAgICAgIGZyYWcua2V5TG9hZGVyID0gbnVsbDtcbiAgICAgICAgICBrZXlJbmZvLmxvYWRlciA9IG51bGw7XG4gICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAga2V5SW5mb1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbkVycm9yOiAocmVzcG9uc2UsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCBzdGF0cykgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoY29udGV4dCk7XG4gICAgICAgICAgcmVqZWN0KHRoaXMuY3JlYXRlS2V5TG9hZEVycm9yKGZyYWcsIEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUiwgbmV3IEVycm9yKGBIVFRQIEVycm9yICR7cmVzcG9uc2UuY29kZX0gbG9hZGluZyBrZXkgJHtyZXNwb25zZS50ZXh0fWApLCBuZXR3b3JrRGV0YWlscywgX29iamVjdFNwcmVhZDIoe1xuICAgICAgICAgICAgdXJsOiBsb2FkZXJDb250ZXh0LnVybCxcbiAgICAgICAgICAgIGRhdGE6IHVuZGVmaW5lZFxuICAgICAgICAgIH0sIHJlc3BvbnNlKSkpO1xuICAgICAgICB9LFxuICAgICAgICBvblRpbWVvdXQ6IChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpID0+IHtcbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGVyKGNvbnRleHQpO1xuICAgICAgICAgIHJlamVjdCh0aGlzLmNyZWF0ZUtleUxvYWRFcnJvcihmcmFnLCBFcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVCwgbmV3IEVycm9yKCdrZXkgbG9hZGluZyB0aW1lZCBvdXQnKSwgbmV0d29ya0RldGFpbHMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25BYm9ydDogKHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoY29udGV4dCk7XG4gICAgICAgICAgcmVqZWN0KHRoaXMuY3JlYXRlS2V5TG9hZEVycm9yKGZyYWcsIEVycm9yRGV0YWlscy5JTlRFUk5BTF9BQk9SVEVELCBuZXcgRXJyb3IoJ2tleSBsb2FkaW5nIGFib3J0ZWQnKSwgbmV0d29ya0RldGFpbHMpKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGtleUxvYWRlci5sb2FkKGxvYWRlckNvbnRleHQsIGxvYWRlckNvbmZpZywgbG9hZGVyQ2FsbGJhY2tzKTtcbiAgICB9KTtcbiAgfVxuICByZXNldExvYWRlcihjb250ZXh0KSB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIGtleUluZm8sXG4gICAgICB1cmw6IHVyaVxuICAgIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IGxvYWRlciA9IGtleUluZm8ubG9hZGVyO1xuICAgIGlmIChmcmFnLmtleUxvYWRlciA9PT0gbG9hZGVyKSB7XG4gICAgICBmcmFnLmtleUxvYWRlciA9IG51bGw7XG4gICAgICBrZXlJbmZvLmxvYWRlciA9IG51bGw7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLmtleVVyaVRvS2V5SW5mb1t1cmldO1xuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGxvYWRlci5kZXN0cm95KCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1hcENvbnRleHRUb0xldmVsVHlwZShjb250ZXh0KSB7XG4gIGNvbnN0IHtcbiAgICB0eXBlXG4gIH0gPSBjb250ZXh0O1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0s6XG4gICAgICByZXR1cm4gUGxheWxpc3RMZXZlbFR5cGUuQVVESU87XG4gICAgY2FzZSBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLOlxuICAgICAgcmV0dXJuIFBsYXlsaXN0TGV2ZWxUeXBlLlNVQlRJVExFO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gUGxheWxpc3RMZXZlbFR5cGUuTUFJTjtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0UmVzcG9uc2VVcmwocmVzcG9uc2UsIGNvbnRleHQpIHtcbiAgbGV0IHVybCA9IHJlc3BvbnNlLnVybDtcbiAgLy8gcmVzcG9uc2VVUkwgbm90IHN1cHBvcnRlZCBvbiBzb21lIGJyb3dzZXJzIChpdCBpcyB1c2VkIHRvIGRldGVjdCBVUkwgcmVkaXJlY3Rpb24pXG4gIC8vIGRhdGEtdXJpIG1vZGUgYWxzbyBub3Qgc3VwcG9ydGVkIChidXQgbm8gbmVlZCB0byBkZXRlY3QgcmVkaXJlY3Rpb24pXG4gIGlmICh1cmwgPT09IHVuZGVmaW5lZCB8fCB1cmwuaW5kZXhPZignZGF0YTonKSA9PT0gMCkge1xuICAgIC8vIGZhbGxiYWNrIHRvIGluaXRpYWwgVVJMXG4gICAgdXJsID0gY29udGV4dC51cmw7XG4gIH1cbiAgcmV0dXJuIHVybDtcbn1cbmNsYXNzIFBsYXlsaXN0TG9hZGVyIHtcbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5sb2FkZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnZhcmlhYmxlTGlzdCA9IG51bGw7XG4gICAgdGhpcy5vbk1hbmlmZXN0TG9hZGVkID0gdGhpcy5jaGVja0F1dG9zdGFydExvYWQ7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIHN0YXJ0TG9hZChzdGFydFBvc2l0aW9uKSB7fVxuICBzdG9wTG9hZCgpIHtcbiAgICB0aGlzLmRlc3Ryb3lJbnRlcm5hbExvYWRlcnMoKTtcbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxfTE9BRElORywgdGhpcy5vbkxldmVsTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5BVURJT19UUkFDS19MT0FESU5HLCB0aGlzLm9uQXVkaW9UcmFja0xvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuU1VCVElUTEVfVFJBQ0tfTE9BRElORywgdGhpcy5vblN1YnRpdGxlVHJhY2tMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMU19VUERBVEVELCB0aGlzLm9uTGV2ZWxzVXBkYXRlZCwgdGhpcyk7XG4gIH1cbiAgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5BVURJT19UUkFDS19MT0FESU5HLCB0aGlzLm9uQXVkaW9UcmFja0xvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLlNVQlRJVExFX1RSQUNLX0xPQURJTkcsIHRoaXMub25TdWJ0aXRsZVRyYWNrTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxTX1VQREFURUQsIHRoaXMub25MZXZlbHNVcGRhdGVkLCB0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGRlZmF1bHRzIG9yIGNvbmZpZ3VyZWQgbG9hZGVyLXR5cGUgb3ZlcmxvYWRzIChwTG9hZGVyIGFuZCBsb2FkZXIgY29uZmlnIHBhcmFtcylcbiAgICovXG4gIGNyZWF0ZUludGVybmFsTG9hZGVyKGNvbnRleHQpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG4gICAgY29uc3QgUExvYWRlciA9IGNvbmZpZy5wTG9hZGVyO1xuICAgIGNvbnN0IExvYWRlciA9IGNvbmZpZy5sb2FkZXI7XG4gICAgY29uc3QgSW50ZXJuYWxMb2FkZXIgPSBQTG9hZGVyIHx8IExvYWRlcjtcbiAgICBjb25zdCBsb2FkZXIgPSBuZXcgSW50ZXJuYWxMb2FkZXIoY29uZmlnKTtcbiAgICB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXSA9IGxvYWRlcjtcbiAgICByZXR1cm4gbG9hZGVyO1xuICB9XG4gIGdldEludGVybmFsTG9hZGVyKGNvbnRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5sb2FkZXJzW2NvbnRleHQudHlwZV07XG4gIH1cbiAgcmVzZXRJbnRlcm5hbExvYWRlcihjb250ZXh0VHlwZSkge1xuICAgIGlmICh0aGlzLmxvYWRlcnNbY29udGV4dFR5cGVdKSB7XG4gICAgICBkZWxldGUgdGhpcy5sb2FkZXJzW2NvbnRleHRUeXBlXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbCBgZGVzdHJveWAgb24gYWxsIGludGVybmFsIGxvYWRlciBpbnN0YW5jZXMgbWFwcGVkIChvbmUgcGVyIGNvbnRleHQgdHlwZSlcbiAgICovXG4gIGRlc3Ryb3lJbnRlcm5hbExvYWRlcnMoKSB7XG4gICAgZm9yIChjb25zdCBjb250ZXh0VHlwZSBpbiB0aGlzLmxvYWRlcnMpIHtcbiAgICAgIGNvbnN0IGxvYWRlciA9IHRoaXMubG9hZGVyc1tjb250ZXh0VHlwZV07XG4gICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgIGxvYWRlci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlc2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dFR5cGUpO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMudmFyaWFibGVMaXN0ID0gbnVsbDtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmRlc3Ryb3lJbnRlcm5hbExvYWRlcnMoKTtcbiAgfVxuICBvbk1hbmlmZXN0TG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHVybFxuICAgIH0gPSBkYXRhO1xuICAgIHRoaXMudmFyaWFibGVMaXN0ID0gbnVsbDtcbiAgICB0aGlzLmxvYWQoe1xuICAgICAgaWQ6IG51bGwsXG4gICAgICBsZXZlbDogMCxcbiAgICAgIHJlc3BvbnNlVHlwZTogJ3RleHQnLFxuICAgICAgdHlwZTogUGxheWxpc3RDb250ZXh0VHlwZS5NQU5JRkVTVCxcbiAgICAgIHVybCxcbiAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlczogbnVsbCxcbiAgICAgIGxldmVsT3JUcmFjazogbnVsbFxuICAgIH0pO1xuICB9XG4gIG9uTGV2ZWxMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgaWQsXG4gICAgICBsZXZlbCxcbiAgICAgIHBhdGh3YXlJZCxcbiAgICAgIHVybCxcbiAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlcyxcbiAgICAgIGxldmVsSW5mb1xuICAgIH0gPSBkYXRhO1xuICAgIHRoaXMubG9hZCh7XG4gICAgICBpZCxcbiAgICAgIGxldmVsLFxuICAgICAgcGF0aHdheUlkLFxuICAgICAgcmVzcG9uc2VUeXBlOiAndGV4dCcsXG4gICAgICB0eXBlOiBQbGF5bGlzdENvbnRleHRUeXBlLkxFVkVMLFxuICAgICAgdXJsLFxuICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzLFxuICAgICAgbGV2ZWxPclRyYWNrOiBsZXZlbEluZm9cbiAgICB9KTtcbiAgfVxuICBvbkF1ZGlvVHJhY2tMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgaWQsXG4gICAgICBncm91cElkLFxuICAgICAgdXJsLFxuICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzLFxuICAgICAgdHJhY2tcbiAgICB9ID0gZGF0YTtcbiAgICB0aGlzLmxvYWQoe1xuICAgICAgaWQsXG4gICAgICBncm91cElkLFxuICAgICAgbGV2ZWw6IG51bGwsXG4gICAgICByZXNwb25zZVR5cGU6ICd0ZXh0JyxcbiAgICAgIHR5cGU6IFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0ssXG4gICAgICB1cmwsXG4gICAgICBkZWxpdmVyeURpcmVjdGl2ZXMsXG4gICAgICBsZXZlbE9yVHJhY2s6IHRyYWNrXG4gICAgfSk7XG4gIH1cbiAgb25TdWJ0aXRsZVRyYWNrTG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkLFxuICAgICAgZ3JvdXBJZCxcbiAgICAgIHVybCxcbiAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlcyxcbiAgICAgIHRyYWNrXG4gICAgfSA9IGRhdGE7XG4gICAgdGhpcy5sb2FkKHtcbiAgICAgIGlkLFxuICAgICAgZ3JvdXBJZCxcbiAgICAgIGxldmVsOiBudWxsLFxuICAgICAgcmVzcG9uc2VUeXBlOiAndGV4dCcsXG4gICAgICB0eXBlOiBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLLFxuICAgICAgdXJsLFxuICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzLFxuICAgICAgbGV2ZWxPclRyYWNrOiB0cmFja1xuICAgIH0pO1xuICB9XG4gIG9uTGV2ZWxzVXBkYXRlZChldmVudCwgZGF0YSkge1xuICAgIC8vIGFib3J0IGFuZCBkZWxldGUgbG9hZGVyIG9mIHJlbW92ZWQgbGV2ZWxzXG4gICAgY29uc3QgbG9hZGVyID0gdGhpcy5sb2FkZXJzW1BsYXlsaXN0Q29udGV4dFR5cGUuTEVWRUxdO1xuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBsb2FkZXIuY29udGV4dDtcbiAgICAgIGlmIChjb250ZXh0ICYmICFkYXRhLmxldmVscy5zb21lKGx2bCA9PiBsdmwgPT09IGNvbnRleHQubGV2ZWxPclRyYWNrKSkge1xuICAgICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMubG9hZGVyc1tQbGF5bGlzdENvbnRleHRUeXBlLkxFVkVMXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbG9hZChjb250ZXh0KSB7XG4gICAgdmFyIF9jb250ZXh0JGRlbGl2ZXJ5RGlyZTtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG5cbiAgICAvLyBsb2dnZXIuZGVidWcoYFtwbGF5bGlzdC1sb2FkZXJdOiBMb2FkaW5nIHBsYXlsaXN0IG9mIHR5cGUgJHtjb250ZXh0LnR5cGV9LCBsZXZlbDogJHtjb250ZXh0LmxldmVsfSwgaWQ6ICR7Y29udGV4dC5pZH1gKTtcblxuICAgIC8vIENoZWNrIGlmIGEgbG9hZGVyIGZvciB0aGlzIGNvbnRleHQgYWxyZWFkeSBleGlzdHNcbiAgICBsZXQgbG9hZGVyID0gdGhpcy5nZXRJbnRlcm5hbExvYWRlcihjb250ZXh0KTtcbiAgICBpZiAobG9hZGVyKSB7XG4gICAgICBjb25zdCBsb2dnZXIgPSB0aGlzLmhscy5sb2dnZXI7XG4gICAgICBjb25zdCBsb2FkZXJDb250ZXh0ID0gbG9hZGVyLmNvbnRleHQ7XG4gICAgICBpZiAobG9hZGVyQ29udGV4dCAmJiBsb2FkZXJDb250ZXh0LmxldmVsT3JUcmFjayA9PT0gY29udGV4dC5sZXZlbE9yVHJhY2sgJiYgKGxvYWRlckNvbnRleHQudXJsID09PSBjb250ZXh0LnVybCB8fCBsb2FkZXJDb250ZXh0LmRlbGl2ZXJ5RGlyZWN0aXZlcyAmJiAhY29udGV4dC5kZWxpdmVyeURpcmVjdGl2ZXMpKSB7XG4gICAgICAgIC8vIHNhbWUgVVJMIGNhbid0IG92ZXJsYXAsIG9yIHdhaXQgZm9yIGJsb2NraW5nIHJlcXVlc3RcbiAgICAgICAgaWYgKGxvYWRlckNvbnRleHQudXJsID09PSBjb250ZXh0LnVybCkge1xuICAgICAgICAgIGxvZ2dlci5sb2coYFtwbGF5bGlzdC1sb2FkZXJdOiBpZ25vcmUgJHtjb250ZXh0LnVybH0gb25nb2luZyByZXF1ZXN0YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgW3BsYXlsaXN0LWxvYWRlcl06IGlnbm9yZSAke2NvbnRleHQudXJsfSBpbiBmYXZvciBvZiAke2xvYWRlckNvbnRleHQudXJsfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxvZ2dlci5sb2coYFtwbGF5bGlzdC1sb2FkZXJdOiBhYm9ydGluZyBwcmV2aW91cyBsb2FkZXIgZm9yIHR5cGU6ICR7Y29udGV4dC50eXBlfWApO1xuICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgZGlmZmVyZW50IGNvbmZpZ3MgZm9yIHJldHJpZXMgZGVwZW5kaW5nIG9uXG4gICAgLy8gY29udGV4dCAobWFuaWZlc3QsIGxldmVsLCBhdWRpby9zdWJzIHBsYXlsaXN0KVxuICAgIGxldCBsb2FkUG9saWN5O1xuICAgIGlmIChjb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuTUFOSUZFU1QpIHtcbiAgICAgIGxvYWRQb2xpY3kgPSBjb25maWcubWFuaWZlc3RMb2FkUG9saWN5LmRlZmF1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvYWRQb2xpY3kgPSBfZXh0ZW5kcyh7fSwgY29uZmlnLnBsYXlsaXN0TG9hZFBvbGljeS5kZWZhdWx0LCB7XG4gICAgICAgIHRpbWVvdXRSZXRyeTogbnVsbCxcbiAgICAgICAgZXJyb3JSZXRyeTogbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICAgIGxvYWRlciA9IHRoaXMuY3JlYXRlSW50ZXJuYWxMb2FkZXIoY29udGV4dCk7XG5cbiAgICAvLyBPdmVycmlkZSBsZXZlbC90cmFjayB0aW1lb3V0IGZvciBMTC1ITFMgcmVxdWVzdHNcbiAgICAvLyAodGhlIGRlZmF1bHQgb2YgMTAwMDBtcyBpcyBjb3VudGVyIHByb2R1Y3RpdmUgdG8gYmxvY2tpbmcgcGxheWxpc3QgcmVsb2FkIHJlcXVlc3RzKVxuICAgIGlmIChpc0Zpbml0ZU51bWJlcigoX2NvbnRleHQkZGVsaXZlcnlEaXJlID0gY29udGV4dC5kZWxpdmVyeURpcmVjdGl2ZXMpID09IG51bGwgPyB2b2lkIDAgOiBfY29udGV4dCRkZWxpdmVyeURpcmUucGFydCkpIHtcbiAgICAgIGxldCBsZXZlbERldGFpbHM7XG4gICAgICBpZiAoY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLkxFVkVMICYmIGNvbnRleHQubGV2ZWwgIT09IG51bGwpIHtcbiAgICAgICAgbGV2ZWxEZXRhaWxzID0gdGhpcy5obHMubGV2ZWxzW2NvbnRleHQubGV2ZWxdLmRldGFpbHM7XG4gICAgICB9IGVsc2UgaWYgKGNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSyAmJiBjb250ZXh0LmlkICE9PSBudWxsKSB7XG4gICAgICAgIGxldmVsRGV0YWlscyA9IHRoaXMuaGxzLmF1ZGlvVHJhY2tzW2NvbnRleHQuaWRdLmRldGFpbHM7XG4gICAgICB9IGVsc2UgaWYgKGNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSyAmJiBjb250ZXh0LmlkICE9PSBudWxsKSB7XG4gICAgICAgIGxldmVsRGV0YWlscyA9IHRoaXMuaGxzLnN1YnRpdGxlVHJhY2tzW2NvbnRleHQuaWRdLmRldGFpbHM7XG4gICAgICB9XG4gICAgICBpZiAobGV2ZWxEZXRhaWxzKSB7XG4gICAgICAgIGNvbnN0IHBhcnRUYXJnZXQgPSBsZXZlbERldGFpbHMucGFydFRhcmdldDtcbiAgICAgICAgY29uc3QgdGFyZ2V0RHVyYXRpb24gPSBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb247XG4gICAgICAgIGlmIChwYXJ0VGFyZ2V0ICYmIHRhcmdldER1cmF0aW9uKSB7XG4gICAgICAgICAgY29uc3QgbWF4TG93TGF0ZW5jeVBsYXlsaXN0UmVmcmVzaCA9IE1hdGgubWF4KHBhcnRUYXJnZXQgKiAzLCB0YXJnZXREdXJhdGlvbiAqIDAuOCkgKiAxMDAwO1xuICAgICAgICAgIGxvYWRQb2xpY3kgPSBfZXh0ZW5kcyh7fSwgbG9hZFBvbGljeSwge1xuICAgICAgICAgICAgbWF4VGltZVRvRmlyc3RCeXRlTXM6IE1hdGgubWluKG1heExvd0xhdGVuY3lQbGF5bGlzdFJlZnJlc2gsIGxvYWRQb2xpY3kubWF4VGltZVRvRmlyc3RCeXRlTXMpLFxuICAgICAgICAgICAgbWF4TG9hZFRpbWVNczogTWF0aC5taW4obWF4TG93TGF0ZW5jeVBsYXlsaXN0UmVmcmVzaCwgbG9hZFBvbGljeS5tYXhUaW1lVG9GaXJzdEJ5dGVNcylcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsZWdhY3lSZXRyeUNvbXBhdGliaWxpdHkgPSBsb2FkUG9saWN5LmVycm9yUmV0cnkgfHwgbG9hZFBvbGljeS50aW1lb3V0UmV0cnkgfHwge307XG4gICAgY29uc3QgbG9hZGVyQ29uZmlnID0ge1xuICAgICAgbG9hZFBvbGljeSxcbiAgICAgIHRpbWVvdXQ6IGxvYWRQb2xpY3kubWF4TG9hZFRpbWVNcyxcbiAgICAgIG1heFJldHJ5OiBsZWdhY3lSZXRyeUNvbXBhdGliaWxpdHkubWF4TnVtUmV0cnkgfHwgMCxcbiAgICAgIHJldHJ5RGVsYXk6IGxlZ2FjeVJldHJ5Q29tcGF0aWJpbGl0eS5yZXRyeURlbGF5TXMgfHwgMCxcbiAgICAgIG1heFJldHJ5RGVsYXk6IGxlZ2FjeVJldHJ5Q29tcGF0aWJpbGl0eS5tYXhSZXRyeURlbGF5TXMgfHwgMFxuICAgIH07XG4gICAgY29uc3QgbG9hZGVyQ2FsbGJhY2tzID0ge1xuICAgICAgb25TdWNjZXNzOiAocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICBjb25zdCBsb2FkZXIgPSB0aGlzLmdldEludGVybmFsTG9hZGVyKGNvbnRleHQpO1xuICAgICAgICB0aGlzLnJlc2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dC50eXBlKTtcbiAgICAgICAgY29uc3Qgc3RyaW5nID0gcmVzcG9uc2UuZGF0YTtcblxuICAgICAgICAvLyBWYWxpZGF0ZSBpZiBpdCBpcyBhbiBNM1U4IGF0IGFsbFxuICAgICAgICBpZiAoc3RyaW5nLmluZGV4T2YoJyNFWFRNM1UnKSAhPT0gMCkge1xuICAgICAgICAgIHRoaXMuaGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3IocmVzcG9uc2UsIGNvbnRleHQsIG5ldyBFcnJvcignbm8gRVhUTTNVIGRlbGltaXRlcicpLCBuZXR3b3JrRGV0YWlscyB8fCBudWxsLCBzdGF0cyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRzLnBhcnNpbmcuc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgaWYgKE0zVThQYXJzZXIuaXNNZWRpYVBsYXlsaXN0KHN0cmluZykgfHwgY29udGV4dC50eXBlICE9PSBQbGF5bGlzdENvbnRleHRUeXBlLk1BTklGRVNUKSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVUcmFja09yTGV2ZWxQbGF5bGlzdChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzIHx8IG51bGwsIGxvYWRlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVNYXN0ZXJQbGF5bGlzdChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uRXJyb3I6IChyZXNwb25zZSwgY29udGV4dCwgbmV0d29ya0RldGFpbHMsIHN0YXRzKSA9PiB7XG4gICAgICAgIHRoaXMuaGFuZGxlTmV0d29ya0Vycm9yKGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCBmYWxzZSwgcmVzcG9uc2UsIHN0YXRzKTtcbiAgICAgIH0sXG4gICAgICBvblRpbWVvdXQ6IChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpID0+IHtcbiAgICAgICAgdGhpcy5oYW5kbGVOZXR3b3JrRXJyb3IoY29udGV4dCwgbmV0d29ya0RldGFpbHMsIHRydWUsIHVuZGVmaW5lZCwgc3RhdHMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBsb2dnZXIuZGVidWcoYFtwbGF5bGlzdC1sb2FkZXJdOiBDYWxsaW5nIGludGVybmFsIGxvYWRlciBkZWxlZ2F0ZSBmb3IgVVJMOiAke2NvbnRleHQudXJsfWApO1xuXG4gICAgbG9hZGVyLmxvYWQoY29udGV4dCwgbG9hZGVyQ29uZmlnLCBsb2FkZXJDYWxsYmFja3MpO1xuICB9XG4gIGNoZWNrQXV0b3N0YXJ0TG9hZCgpIHtcbiAgICBpZiAoIXRoaXMuaGxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNvbmZpZzoge1xuICAgICAgICBhdXRvU3RhcnRMb2FkLFxuICAgICAgICBzdGFydFBvc2l0aW9uXG4gICAgICB9LFxuICAgICAgZm9yY2VTdGFydExvYWRcbiAgICB9ID0gdGhpcy5obHM7XG4gICAgaWYgKGF1dG9TdGFydExvYWQgfHwgZm9yY2VTdGFydExvYWQpIHtcbiAgICAgIHRoaXMuaGxzLmxvZ2dlci5sb2coYCR7YXV0b1N0YXJ0TG9hZCA/ICdhdXRvJyA6ICdmb3JjZSd9IHN0YXJ0TG9hZCB3aXRoIGNvbmZpZ3VyZWQgc3RhcnRQb3NpdGlvbiAke3N0YXJ0UG9zaXRpb259YCk7XG4gICAgICB0aGlzLmhscy5zdGFydExvYWQoc3RhcnRQb3NpdGlvbik7XG4gICAgfVxuICB9XG4gIGhhbmRsZU1hc3RlclBsYXlsaXN0KHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBjb25zdCBzdHJpbmcgPSByZXNwb25zZS5kYXRhO1xuICAgIGNvbnN0IHVybCA9IGdldFJlc3BvbnNlVXJsKHJlc3BvbnNlLCBjb250ZXh0KTtcbiAgICBjb25zdCBwYXJzZWRSZXN1bHQgPSBNM1U4UGFyc2VyLnBhcnNlTWFzdGVyUGxheWxpc3Qoc3RyaW5nLCB1cmwpO1xuICAgIGlmIChwYXJzZWRSZXN1bHQucGxheWxpc3RQYXJzaW5nRXJyb3IpIHtcbiAgICAgIHRoaXMuaGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3IocmVzcG9uc2UsIGNvbnRleHQsIHBhcnNlZFJlc3VsdC5wbGF5bGlzdFBhcnNpbmdFcnJvciwgbmV0d29ya0RldGFpbHMsIHN0YXRzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY29udGVudFN0ZWVyaW5nLFxuICAgICAgbGV2ZWxzLFxuICAgICAgc2Vzc2lvbkRhdGEsXG4gICAgICBzZXNzaW9uS2V5cyxcbiAgICAgIHN0YXJ0VGltZU9mZnNldCxcbiAgICAgIHZhcmlhYmxlTGlzdFxuICAgIH0gPSBwYXJzZWRSZXN1bHQ7XG4gICAgdGhpcy52YXJpYWJsZUxpc3QgPSB2YXJpYWJsZUxpc3Q7XG4gICAgY29uc3Qge1xuICAgICAgQVVESU86IGF1ZGlvVHJhY2tzID0gW10sXG4gICAgICBTVUJUSVRMRVM6IHN1YnRpdGxlcyxcbiAgICAgICdDTE9TRUQtQ0FQVElPTlMnOiBjYXB0aW9uc1xuICAgIH0gPSBNM1U4UGFyc2VyLnBhcnNlTWFzdGVyUGxheWxpc3RNZWRpYShzdHJpbmcsIHVybCwgcGFyc2VkUmVzdWx0KTtcbiAgICBpZiAoYXVkaW9UcmFja3MubGVuZ3RoKSB7XG4gICAgICAvLyBjaGVjayBpZiB3ZSBoYXZlIGZvdW5kIGFuIGF1ZGlvIHRyYWNrIGVtYmVkZGVkIGluIG1haW4gcGxheWxpc3QgKGF1ZGlvIHRyYWNrIHdpdGhvdXQgVVJJIGF0dHJpYnV0ZSlcbiAgICAgIGNvbnN0IGVtYmVkZGVkQXVkaW9Gb3VuZCA9IGF1ZGlvVHJhY2tzLnNvbWUoYXVkaW9UcmFjayA9PiAhYXVkaW9UcmFjay51cmwpO1xuXG4gICAgICAvLyBpZiBubyBlbWJlZGRlZCBhdWRpbyB0cmFjayBkZWZpbmVkLCBidXQgYXVkaW8gY29kZWMgc2lnbmFsZWQgaW4gcXVhbGl0eSBsZXZlbCxcbiAgICAgIC8vIHdlIG5lZWQgdG8gc2lnbmFsIHRoaXMgbWFpbiBhdWRpbyB0cmFjayB0aGlzIGNvdWxkIGhhcHBlbiB3aXRoIHBsYXlsaXN0cyB3aXRoXG4gICAgICAvLyBhbHQgYXVkaW8gcmVuZGl0aW9uIGluIHdoaWNoIHF1YWxpdHkgbGV2ZWxzIChtYWluKVxuICAgICAgLy8gY29udGFpbnMgYm90aCBhdWRpbyt2aWRlby4gYnV0IHdpdGggbWl4ZWQgYXVkaW8gdHJhY2sgbm90IHNpZ25hbGVkXG4gICAgICBpZiAoIWVtYmVkZGVkQXVkaW9Gb3VuZCAmJiBsZXZlbHNbMF0uYXVkaW9Db2RlYyAmJiAhbGV2ZWxzWzBdLmF0dHJzLkFVRElPKSB7XG4gICAgICAgIHRoaXMuaGxzLmxvZ2dlci5sb2coJ1twbGF5bGlzdC1sb2FkZXJdOiBhdWRpbyBjb2RlYyBzaWduYWxlZCBpbiBxdWFsaXR5IGxldmVsLCBidXQgbm8gZW1iZWRkZWQgYXVkaW8gdHJhY2sgc2lnbmFsZWQsIGNyZWF0ZSBvbmUnKTtcbiAgICAgICAgYXVkaW9UcmFja3MudW5zaGlmdCh7XG4gICAgICAgICAgdHlwZTogJ21haW4nLFxuICAgICAgICAgIG5hbWU6ICdtYWluJyxcbiAgICAgICAgICBncm91cElkOiAnbWFpbicsXG4gICAgICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICAgICAgYXV0b3NlbGVjdDogZmFsc2UsXG4gICAgICAgICAgZm9yY2VkOiBmYWxzZSxcbiAgICAgICAgICBpZDogLTEsXG4gICAgICAgICAgYXR0cnM6IG5ldyBBdHRyTGlzdCh7fSksXG4gICAgICAgICAgYml0cmF0ZTogMCxcbiAgICAgICAgICB1cmw6ICcnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBobHMudHJpZ2dlcihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB7XG4gICAgICBsZXZlbHMsXG4gICAgICBhdWRpb1RyYWNrcyxcbiAgICAgIHN1YnRpdGxlcyxcbiAgICAgIGNhcHRpb25zLFxuICAgICAgY29udGVudFN0ZWVyaW5nLFxuICAgICAgdXJsLFxuICAgICAgc3RhdHMsXG4gICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgIHNlc3Npb25EYXRhLFxuICAgICAgc2Vzc2lvbktleXMsXG4gICAgICBzdGFydFRpbWVPZmZzZXQsXG4gICAgICB2YXJpYWJsZUxpc3RcbiAgICB9KTtcbiAgfVxuICBoYW5kbGVUcmFja09yTGV2ZWxQbGF5bGlzdChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCBsb2FkZXIpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIGxldmVsLFxuICAgICAgdHlwZVxuICAgIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IHVybCA9IGdldFJlc3BvbnNlVXJsKHJlc3BvbnNlLCBjb250ZXh0KTtcbiAgICBjb25zdCBsZXZlbElkID0gaXNGaW5pdGVOdW1iZXIobGV2ZWwpID8gbGV2ZWwgOiBpc0Zpbml0ZU51bWJlcihpZCkgPyBpZCA6IDA7XG4gICAgY29uc3QgbGV2ZWxUeXBlID0gbWFwQ29udGV4dFRvTGV2ZWxUeXBlKGNvbnRleHQpO1xuICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IE0zVThQYXJzZXIucGFyc2VMZXZlbFBsYXlsaXN0KHJlc3BvbnNlLmRhdGEsIHVybCwgbGV2ZWxJZCwgbGV2ZWxUeXBlLCAwLCB0aGlzLnZhcmlhYmxlTGlzdCk7XG5cbiAgICAvLyBXZSBoYXZlIGRvbmUgb3VyIGZpcnN0IHJlcXVlc3QgKE1hbmlmZXN0LXR5cGUpIGFuZCByZWNlaXZlXG4gICAgLy8gbm90IGEgbWFzdGVyIHBsYXlsaXN0IGJ1dCBhIGNodW5rLWxpc3QgKHRyYWNrL2xldmVsKVxuICAgIC8vIFdlIGZpcmUgdGhlIG1hbmlmZXN0LWxvYWRlZCBldmVudCBhbnl3YXkgd2l0aCB0aGUgcGFyc2VkIGxldmVsLWRldGFpbHNcbiAgICAvLyBieSBjcmVhdGluZyBhIHNpbmdsZS1sZXZlbCBzdHJ1Y3R1cmUgZm9yIGl0LlxuICAgIGlmICh0eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLk1BTklGRVNUKSB7XG4gICAgICBjb25zdCBzaW5nbGVMZXZlbCA9IHtcbiAgICAgICAgYXR0cnM6IG5ldyBBdHRyTGlzdCh7fSksXG4gICAgICAgIGJpdHJhdGU6IDAsXG4gICAgICAgIGRldGFpbHM6IGxldmVsRGV0YWlscyxcbiAgICAgICAgbmFtZTogJycsXG4gICAgICAgIHVybFxuICAgICAgfTtcbiAgICAgIGxldmVsRGV0YWlscy5yZXF1ZXN0U2NoZWR1bGVkID0gc3RhdHMubG9hZGluZy5zdGFydCArIGNvbXB1dGVSZWxvYWRJbnRlcnZhbChsZXZlbERldGFpbHMsIDApO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLk1BTklGRVNUX0xPQURFRCwge1xuICAgICAgICBsZXZlbHM6IFtzaW5nbGVMZXZlbF0sXG4gICAgICAgIGF1ZGlvVHJhY2tzOiBbXSxcbiAgICAgICAgdXJsLFxuICAgICAgICBzdGF0cyxcbiAgICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICAgIHNlc3Npb25EYXRhOiBudWxsLFxuICAgICAgICBzZXNzaW9uS2V5czogbnVsbCxcbiAgICAgICAgY29udGVudFN0ZWVyaW5nOiBudWxsLFxuICAgICAgICBzdGFydFRpbWVPZmZzZXQ6IG51bGwsXG4gICAgICAgIHZhcmlhYmxlTGlzdDogbnVsbFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gc2F2ZSBwYXJzaW5nIHRpbWVcbiAgICBzdGF0cy5wYXJzaW5nLmVuZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgLy8gZXh0ZW5kIHRoZSBjb250ZXh0IHdpdGggdGhlIG5ldyBsZXZlbERldGFpbHMgcHJvcGVydHlcbiAgICBjb250ZXh0LmxldmVsRGV0YWlscyA9IGxldmVsRGV0YWlscztcbiAgICB0aGlzLmhhbmRsZVBsYXlsaXN0TG9hZGVkKGxldmVsRGV0YWlscywgcmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscywgbG9hZGVyKTtcbiAgfVxuICBoYW5kbGVNYW5pZmVzdFBhcnNpbmdFcnJvcihyZXNwb25zZSwgY29udGV4dCwgZXJyb3IsIG5ldHdvcmtEZXRhaWxzLCBzdGF0cykge1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuTUFOSUZFU1RfUEFSU0lOR19FUlJPUixcbiAgICAgIGZhdGFsOiBjb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuTUFOSUZFU1QsXG4gICAgICB1cmw6IHJlc3BvbnNlLnVybCxcbiAgICAgIGVycjogZXJyb3IsXG4gICAgICBlcnJvcixcbiAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZSxcbiAgICAgIHJlc3BvbnNlLFxuICAgICAgY29udGV4dCxcbiAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgc3RhdHNcbiAgICB9KTtcbiAgfVxuICBoYW5kbGVOZXR3b3JrRXJyb3IoY29udGV4dCwgbmV0d29ya0RldGFpbHMsIHRpbWVvdXQgPSBmYWxzZSwgcmVzcG9uc2UsIHN0YXRzKSB7XG4gICAgbGV0IG1lc3NhZ2UgPSBgQSBuZXR3b3JrICR7dGltZW91dCA/ICd0aW1lb3V0JyA6ICdlcnJvcicgKyAocmVzcG9uc2UgPyAnIChzdGF0dXMgJyArIHJlc3BvbnNlLmNvZGUgKyAnKScgOiAnJyl9IG9jY3VycmVkIHdoaWxlIGxvYWRpbmcgJHtjb250ZXh0LnR5cGV9YDtcbiAgICBpZiAoY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLkxFVkVMKSB7XG4gICAgICBtZXNzYWdlICs9IGA6ICR7Y29udGV4dC5sZXZlbH0gaWQ6ICR7Y29udGV4dC5pZH1gO1xuICAgIH0gZWxzZSBpZiAoY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLkFVRElPX1RSQUNLIHx8IGNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSykge1xuICAgICAgbWVzc2FnZSArPSBgIGlkOiAke2NvbnRleHQuaWR9IGdyb3VwLWlkOiBcIiR7Y29udGV4dC5ncm91cElkfVwiYDtcbiAgICB9XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgdGhpcy5obHMubG9nZ2VyLndhcm4oYFtwbGF5bGlzdC1sb2FkZXJdOiAke21lc3NhZ2V9YCk7XG4gICAgbGV0IGRldGFpbHMgPSBFcnJvckRldGFpbHMuVU5LTk9XTjtcbiAgICBsZXQgZmF0YWwgPSBmYWxzZTtcbiAgICBjb25zdCBsb2FkZXIgPSB0aGlzLmdldEludGVybmFsTG9hZGVyKGNvbnRleHQpO1xuICAgIHN3aXRjaCAoY29udGV4dC50eXBlKSB7XG4gICAgICBjYXNlIFBsYXlsaXN0Q29udGV4dFR5cGUuTUFOSUZFU1Q6XG4gICAgICAgIGRldGFpbHMgPSB0aW1lb3V0ID8gRXJyb3JEZXRhaWxzLk1BTklGRVNUX0xPQURfVElNRU9VVCA6IEVycm9yRGV0YWlscy5NQU5JRkVTVF9MT0FEX0VSUk9SO1xuICAgICAgICBmYXRhbCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQbGF5bGlzdENvbnRleHRUeXBlLkxFVkVMOlxuICAgICAgICBkZXRhaWxzID0gdGltZW91dCA/IEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQgOiBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9FUlJPUjtcbiAgICAgICAgZmF0YWwgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0s6XG4gICAgICAgIGRldGFpbHMgPSB0aW1lb3V0ID8gRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfVElNRU9VVCA6IEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX0VSUk9SO1xuICAgICAgICBmYXRhbCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSzpcbiAgICAgICAgZGV0YWlscyA9IHRpbWVvdXQgPyBFcnJvckRldGFpbHMuU1VCVElUTEVfVFJBQ0tfTE9BRF9USU1FT1VUIDogRXJyb3JEZXRhaWxzLlNVQlRJVExFX0xPQURfRVJST1I7XG4gICAgICAgIGZhdGFsID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAobG9hZGVyKSB7XG4gICAgICB0aGlzLnJlc2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dC50eXBlKTtcbiAgICB9XG4gICAgY29uc3QgZXJyb3JEYXRhID0ge1xuICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgZGV0YWlscyxcbiAgICAgIGZhdGFsLFxuICAgICAgdXJsOiBjb250ZXh0LnVybCxcbiAgICAgIGxvYWRlcixcbiAgICAgIGNvbnRleHQsXG4gICAgICBlcnJvcixcbiAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgc3RhdHNcbiAgICB9O1xuICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgY29uc3QgdXJsID0gKG5ldHdvcmtEZXRhaWxzID09IG51bGwgPyB2b2lkIDAgOiBuZXR3b3JrRGV0YWlscy51cmwpIHx8IGNvbnRleHQudXJsO1xuICAgICAgZXJyb3JEYXRhLnJlc3BvbnNlID0gX29iamVjdFNwcmVhZDIoe1xuICAgICAgICB1cmwsXG4gICAgICAgIGRhdGE6IHVuZGVmaW5lZFxuICAgICAgfSwgcmVzcG9uc2UpO1xuICAgIH1cbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwgZXJyb3JEYXRhKTtcbiAgfVxuICBoYW5kbGVQbGF5bGlzdExvYWRlZChsZXZlbERldGFpbHMsIHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMsIGxvYWRlcikge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGUsXG4gICAgICBsZXZlbCxcbiAgICAgIGlkLFxuICAgICAgZ3JvdXBJZCxcbiAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlc1xuICAgIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IHVybCA9IGdldFJlc3BvbnNlVXJsKHJlc3BvbnNlLCBjb250ZXh0KTtcbiAgICBjb25zdCBwYXJlbnQgPSBtYXBDb250ZXh0VG9MZXZlbFR5cGUoY29udGV4dCk7XG4gICAgY29uc3QgbGV2ZWxJbmRleCA9IHR5cGVvZiBjb250ZXh0LmxldmVsID09PSAnbnVtYmVyJyAmJiBwYXJlbnQgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4gPyBsZXZlbCA6IHVuZGVmaW5lZDtcbiAgICBpZiAoIWxldmVsRGV0YWlscy5mcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBfZXJyb3IgPSBsZXZlbERldGFpbHMucGxheWxpc3RQYXJzaW5nRXJyb3IgPSBuZXcgRXJyb3IoJ05vIFNlZ21lbnRzIGZvdW5kIGluIFBsYXlsaXN0Jyk7XG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuTEVWRUxfRU1QVFlfRVJST1IsXG4gICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgdXJsLFxuICAgICAgICBlcnJvcjogX2Vycm9yLFxuICAgICAgICByZWFzb246IF9lcnJvci5tZXNzYWdlLFxuICAgICAgICByZXNwb25zZSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgbGV2ZWw6IGxldmVsSW5kZXgsXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICAgIHN0YXRzXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb24pIHtcbiAgICAgIGxldmVsRGV0YWlscy5wbGF5bGlzdFBhcnNpbmdFcnJvciA9IG5ldyBFcnJvcignTWlzc2luZyBUYXJnZXQgRHVyYXRpb24nKTtcbiAgICB9XG4gICAgY29uc3QgZXJyb3IgPSBsZXZlbERldGFpbHMucGxheWxpc3RQYXJzaW5nRXJyb3I7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICB0aGlzLmhscy5sb2dnZXIud2FybihlcnJvcik7XG4gICAgICBpZiAoIWhscy5jb25maWcuaWdub3JlUGxheWxpc3RQYXJzaW5nRXJyb3JzKSB7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuTEVWRUxfUEFSU0lOR19FUlJPUixcbiAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIGxldmVsOiBsZXZlbEluZGV4LFxuICAgICAgICAgIHBhcmVudCxcbiAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICBzdGF0c1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV2ZWxEZXRhaWxzLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGxldmVsRGV0YWlscy5saXZlICYmIGxvYWRlcikge1xuICAgICAgaWYgKGxvYWRlci5nZXRDYWNoZUFnZSkge1xuICAgICAgICBsZXZlbERldGFpbHMuYWdlSGVhZGVyID0gbG9hZGVyLmdldENhY2hlQWdlKCkgfHwgMDtcbiAgICAgIH1cbiAgICAgIGlmICghbG9hZGVyLmdldENhY2hlQWdlIHx8IGlzTmFOKGxldmVsRGV0YWlscy5hZ2VIZWFkZXIpKSB7XG4gICAgICAgIGxldmVsRGV0YWlscy5hZ2VIZWFkZXIgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5NQU5JRkVTVDpcbiAgICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5MRVZFTDpcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkxFVkVMX0xPQURFRCwge1xuICAgICAgICAgIGRldGFpbHM6IGxldmVsRGV0YWlscyxcbiAgICAgICAgICBsZXZlbEluZm86IGNvbnRleHQubGV2ZWxPclRyYWNrIHx8IGhscy5sZXZlbHNbMF0sXG4gICAgICAgICAgbGV2ZWw6IGxldmVsSW5kZXggfHwgMCxcbiAgICAgICAgICBpZDogaWQgfHwgMCxcbiAgICAgICAgICBzdGF0cyxcbiAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXMsXG4gICAgICAgICAgd2l0aG91dE11bHRpVmFyaWFudDogdHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5NQU5JRkVTVFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0s6XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5BVURJT19UUkFDS19MT0FERUQsIHtcbiAgICAgICAgICBkZXRhaWxzOiBsZXZlbERldGFpbHMsXG4gICAgICAgICAgdHJhY2s6IGNvbnRleHQubGV2ZWxPclRyYWNrLFxuICAgICAgICAgIGlkOiBpZCB8fCAwLFxuICAgICAgICAgIGdyb3VwSWQ6IGdyb3VwSWQgfHwgJycsXG4gICAgICAgICAgc3RhdHMsXG4gICAgICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSzpcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLlNVQlRJVExFX1RSQUNLX0xPQURFRCwge1xuICAgICAgICAgIGRldGFpbHM6IGxldmVsRGV0YWlscyxcbiAgICAgICAgICB0cmFjazogY29udGV4dC5sZXZlbE9yVHJhY2ssXG4gICAgICAgICAgaWQ6IGlkIHx8IDAsXG4gICAgICAgICAgZ3JvdXBJZDogZ3JvdXBJZCB8fCAnJyxcbiAgICAgICAgICBzdGF0cyxcbiAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXNcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRoZSBgSGxzYCBjbGFzcyBpcyB0aGUgY29yZSBvZiB0aGUgSExTLmpzIGxpYnJhcnkgdXNlZCB0byBpbnN0YW50aWF0ZSBwbGF5ZXIgaW5zdGFuY2VzLlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBIbHMge1xuICAvKipcbiAgICogR2V0IHRoZSB2aWRlby1kZXYvaGxzLmpzIHBhY2thZ2UgdmVyc2lvbi5cbiAgICovXG4gIHN0YXRpYyBnZXQgdmVyc2lvbigpIHtcbiAgICByZXR1cm4gdmVyc2lvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgcmVxdWlyZWQgTWVkaWFTb3VyY2UgRXh0ZW5zaW9ucyBhcmUgYXZhaWxhYmxlLlxuICAgKi9cbiAgc3RhdGljIGlzTVNFU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBpc01TRVN1cHBvcnRlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIE1lZGlhU291cmNlIEV4dGVuc2lvbnMgYXJlIGF2YWlsYWJsZSBhbmQgaXNUeXBlU3VwcG9ydGVkIGNoZWNrcyBwYXNzIGZvciBhbnkgYmFzZWxpbmUgY29kZWNzLlxuICAgKi9cbiAgc3RhdGljIGlzU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBpc1N1cHBvcnRlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgTWVkaWFTb3VyY2UgZ2xvYmFsIHVzZWQgZm9yIE1TRSBwbGF5YmFjayAoTWFuYWdlZE1lZGlhU291cmNlLCBNZWRpYVNvdXJjZSwgb3IgV2ViS2l0TWVkaWFTb3VyY2UpLlxuICAgKi9cbiAgc3RhdGljIGdldE1lZGlhU291cmNlKCkge1xuICAgIHJldHVybiBnZXRNZWRpYVNvdXJjZSgpO1xuICB9XG4gIHN0YXRpYyBnZXQgRXZlbnRzKCkge1xuICAgIHJldHVybiBFdmVudHM7XG4gIH1cbiAgc3RhdGljIGdldCBNZXRhZGF0YVNjaGVtYSgpIHtcbiAgICByZXR1cm4gTWV0YWRhdGFTY2hlbWE7XG4gIH1cbiAgc3RhdGljIGdldCBFcnJvclR5cGVzKCkge1xuICAgIHJldHVybiBFcnJvclR5cGVzO1xuICB9XG4gIHN0YXRpYyBnZXQgRXJyb3JEZXRhaWxzKCkge1xuICAgIHJldHVybiBFcnJvckRldGFpbHM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gYXBwbGllZCB0byBuZXcgaW5zdGFuY2VzLlxuICAgKi9cbiAgc3RhdGljIGdldCBEZWZhdWx0Q29uZmlnKCkge1xuICAgIGlmICghSGxzLmRlZmF1bHRDb25maWcpIHtcbiAgICAgIHJldHVybiBobHNEZWZhdWx0Q29uZmlnO1xuICAgIH1cbiAgICByZXR1cm4gSGxzLmRlZmF1bHRDb25maWc7XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZSB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIGFwcGxpZWQgdG8gbmV3IGluc3RhbmNlcy5cbiAgICovXG4gIHN0YXRpYyBzZXQgRGVmYXVsdENvbmZpZyhkZWZhdWx0Q29uZmlnKSB7XG4gICAgSGxzLmRlZmF1bHRDb25maWcgPSBkZWZhdWx0Q29uZmlnO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYW4gSExTIGNsaWVudCB0aGF0IGNhbiBhdHRhY2ggdG8gZXhhY3RseSBvbmUgYEhUTUxNZWRpYUVsZW1lbnRgLlxuICAgKiBAcGFyYW0gdXNlckNvbmZpZyAtIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBhcHBsaWVkIG92ZXIgYEhscy5EZWZhdWx0Q29uZmlnYFxuICAgKi9cbiAgY29uc3RydWN0b3IodXNlckNvbmZpZyA9IHt9KSB7XG4gICAgLyoqXG4gICAgICogVGhlIHJ1bnRpbWUgY29uZmlndXJhdGlvbiB1c2VkIGJ5IHRoZSBwbGF5ZXIuIEF0IGluc3RhbnRpYXRpb24gdGhpcyBpcyBjb21iaW5hdGlvbiBvZiBgaGxzLnVzZXJDb25maWdgIG1lcmdlZCBvdmVyIGBIbHMuRGVmYXVsdENvbmZpZ2AuXG4gICAgICovXG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHByb3ZpZGVkIG9uIHBsYXllciBpbnN0YW50aWF0aW9uLlxuICAgICAqL1xuICAgIHRoaXMudXNlckNvbmZpZyA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBUaGUgbG9nZ2VyIGZ1bmN0aW9ucyB1c2VkIGJ5IHRoaXMgcGxheWVyIGluc3RhbmNlLCBjb25maWd1cmVkIG9uIHBsYXllciBpbnN0YW50aWF0aW9uLlxuICAgICAqL1xuICAgIHRoaXMubG9nZ2VyID0gdm9pZCAwO1xuICAgIHRoaXMuY29yZUNvbXBvbmVudHMgPSB2b2lkIDA7XG4gICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMgPSB2b2lkIDA7XG4gICAgdGhpcy5fZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nID0gLTE7XG4gICAgdGhpcy5fbWF4SGRjcExldmVsID0gbnVsbDtcbiAgICB0aGlzLmFickNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5idWZmZXJDb250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuY2FwTGV2ZWxDb250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuYXVkaW9TdHJlYW1Db250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuc3VidGl0aXRsZVN0cmVhbUNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuaW50ZXJzdGl0aWFsc0NvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5nYXBDb250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuZW1lQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLmNtY2RDb250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuX21lZGlhID0gbnVsbDtcbiAgICB0aGlzLl91cmwgPSBudWxsO1xuICAgIHRoaXMuX3Nlc3Npb25JZCA9IHZvaWQgMDtcbiAgICB0aGlzLnRyaWdnZXJpbmdFeGNlcHRpb24gPSB2b2lkIDA7XG4gICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgY29uc3QgbG9nZ2VyID0gdGhpcy5sb2dnZXIgPSBlbmFibGVMb2dzKHVzZXJDb25maWcuZGVidWcgfHwgZmFsc2UsICdIbHMgaW5zdGFuY2UnLCB1c2VyQ29uZmlnLmFzc2V0UGxheWVySWQpO1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnID0gbWVyZ2VDb25maWcoSGxzLkRlZmF1bHRDb25maWcsIHVzZXJDb25maWcsIGxvZ2dlcik7XG4gICAgdGhpcy51c2VyQ29uZmlnID0gdXNlckNvbmZpZztcbiAgICBpZiAoY29uZmlnLnByb2dyZXNzaXZlKSB7XG4gICAgICBlbmFibGVTdHJlYW1pbmdNb2RlKGNvbmZpZywgbG9nZ2VyKTtcbiAgICB9XG5cbiAgICAvLyBjb3JlIGNvbnRyb2xsZXJzIGFuZCBuZXR3b3JrIGxvYWRlcnNcbiAgICBjb25zdCB7XG4gICAgICBhYnJDb250cm9sbGVyOiBfQWJyQ29udHJvbGxlcixcbiAgICAgIGJ1ZmZlckNvbnRyb2xsZXI6IF9CdWZmZXJDb250cm9sbGVyLFxuICAgICAgY2FwTGV2ZWxDb250cm9sbGVyOiBfQ2FwTGV2ZWxDb250cm9sbGVyLFxuICAgICAgZXJyb3JDb250cm9sbGVyOiBfRXJyb3JDb250cm9sbGVyLFxuICAgICAgZnBzQ29udHJvbGxlcjogX0Zwc0NvbnRyb2xsZXJcbiAgICB9ID0gY29uZmlnO1xuICAgIGNvbnN0IGVycm9yQ29udHJvbGxlciA9IG5ldyBfRXJyb3JDb250cm9sbGVyKHRoaXMpO1xuICAgIGNvbnN0IGFickNvbnRyb2xsZXIgPSB0aGlzLmFickNvbnRyb2xsZXIgPSBuZXcgX0FickNvbnRyb2xsZXIodGhpcyk7XG4gICAgLy8gRnJhZ21lbnRUcmFja2VyIG11c3QgYmUgZGVmaW5lZCBiZWZvcmUgU3RyZWFtQ29udHJvbGxlciBiZWNhdXNlIHRoZSBvcmRlciBvZiBldmVudCBoYW5kbGluZyBpcyBpbXBvcnRhbnRcbiAgICBjb25zdCBmcmFnbWVudFRyYWNrZXIgPSBuZXcgRnJhZ21lbnRUcmFja2VyKHRoaXMpO1xuICAgIGNvbnN0IF9JbnRlcnN0aXRpYWxzQ29udHJvbGxlciA9IGNvbmZpZy5pbnRlcnN0aXRpYWxzQ29udHJvbGxlcjtcbiAgICBjb25zdCBpbnRlcnN0aXRpYWxzQ29udHJvbGxlciA9IF9JbnRlcnN0aXRpYWxzQ29udHJvbGxlciA/IHRoaXMuaW50ZXJzdGl0aWFsc0NvbnRyb2xsZXIgPSBuZXcgX0ludGVyc3RpdGlhbHNDb250cm9sbGVyKHRoaXMsIEhscykgOiBudWxsO1xuICAgIGNvbnN0IGJ1ZmZlckNvbnRyb2xsZXIgPSB0aGlzLmJ1ZmZlckNvbnRyb2xsZXIgPSBuZXcgX0J1ZmZlckNvbnRyb2xsZXIodGhpcywgZnJhZ21lbnRUcmFja2VyKTtcbiAgICBjb25zdCBjYXBMZXZlbENvbnRyb2xsZXIgPSB0aGlzLmNhcExldmVsQ29udHJvbGxlciA9IG5ldyBfQ2FwTGV2ZWxDb250cm9sbGVyKHRoaXMpO1xuICAgIGNvbnN0IGZwc0NvbnRyb2xsZXIgPSBuZXcgX0Zwc0NvbnRyb2xsZXIodGhpcyk7XG4gICAgY29uc3QgcGxheUxpc3RMb2FkZXIgPSBuZXcgUGxheWxpc3RMb2FkZXIodGhpcyk7XG4gICAgY29uc3QgX0NvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXIgPSBjb25maWcuY29udGVudFN0ZWVyaW5nQ29udHJvbGxlcjtcbiAgICAvLyBJbnN0YW50aWF0ZSBDb25lbnRTdGVlcmluZ0NvbnRyb2xsZXIgYmVmb3JlIExldmVsQ29udHJvbGxlciB0byByZWNlaXZlIE11bHRpdmFyaWFudCBQbGF5bGlzdCBldmVudHMgZmlyc3RcbiAgICBjb25zdCBjb250ZW50U3RlZXJpbmcgPSBfQ29udGVudFN0ZWVyaW5nQ29udHJvbGxlciA/IG5ldyBfQ29udGVudFN0ZWVyaW5nQ29udHJvbGxlcih0aGlzKSA6IG51bGw7XG4gICAgY29uc3QgbGV2ZWxDb250cm9sbGVyID0gdGhpcy5sZXZlbENvbnRyb2xsZXIgPSBuZXcgTGV2ZWxDb250cm9sbGVyKHRoaXMsIGNvbnRlbnRTdGVlcmluZyk7XG4gICAgY29uc3QgaWQzVHJhY2tDb250cm9sbGVyID0gbmV3IElEM1RyYWNrQ29udHJvbGxlcih0aGlzKTtcbiAgICBjb25zdCBrZXlMb2FkZXIgPSBuZXcgS2V5TG9hZGVyKHRoaXMuY29uZmlnKTtcbiAgICBjb25zdCBzdHJlYW1Db250cm9sbGVyID0gdGhpcy5zdHJlYW1Db250cm9sbGVyID0gbmV3IFN0cmVhbUNvbnRyb2xsZXIodGhpcywgZnJhZ21lbnRUcmFja2VyLCBrZXlMb2FkZXIpO1xuICAgIGNvbnN0IGdhcENvbnRyb2xsZXIgPSB0aGlzLmdhcENvbnRyb2xsZXIgPSBuZXcgR2FwQ29udHJvbGxlcih0aGlzLCBmcmFnbWVudFRyYWNrZXIpO1xuXG4gICAgLy8gQ2FwIGxldmVsIGNvbnRyb2xsZXIgdXNlcyBzdHJlYW1Db250cm9sbGVyIHRvIGZsdXNoIHRoZSBidWZmZXJcbiAgICBjYXBMZXZlbENvbnRyb2xsZXIuc2V0U3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyKTtcbiAgICAvLyBmcHNDb250cm9sbGVyIHVzZXMgc3RyZWFtQ29udHJvbGxlciB0byBzd2l0Y2ggd2hlbiBmcmFtZXMgYXJlIGJlaW5nIGRyb3BwZWRcbiAgICBmcHNDb250cm9sbGVyLnNldFN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtQ29udHJvbGxlcik7XG4gICAgY29uc3QgbmV0d29ya0NvbnRyb2xsZXJzID0gW3BsYXlMaXN0TG9hZGVyLCBsZXZlbENvbnRyb2xsZXIsIHN0cmVhbUNvbnRyb2xsZXJdO1xuICAgIGlmIChpbnRlcnN0aXRpYWxzQ29udHJvbGxlcikge1xuICAgICAgbmV0d29ya0NvbnRyb2xsZXJzLnNwbGljZSgxLCAwLCBpbnRlcnN0aXRpYWxzQ29udHJvbGxlcik7XG4gICAgfVxuICAgIGlmIChjb250ZW50U3RlZXJpbmcpIHtcbiAgICAgIG5ldHdvcmtDb250cm9sbGVycy5zcGxpY2UoMSwgMCwgY29udGVudFN0ZWVyaW5nKTtcbiAgICB9XG4gICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMgPSBuZXR3b3JrQ29udHJvbGxlcnM7XG4gICAgY29uc3QgY29yZUNvbXBvbmVudHMgPSBbYWJyQ29udHJvbGxlciwgYnVmZmVyQ29udHJvbGxlciwgZ2FwQ29udHJvbGxlciwgY2FwTGV2ZWxDb250cm9sbGVyLCBmcHNDb250cm9sbGVyLCBpZDNUcmFja0NvbnRyb2xsZXIsIGZyYWdtZW50VHJhY2tlcl07XG4gICAgdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlciA9IHRoaXMuY3JlYXRlQ29udHJvbGxlcihjb25maWcuYXVkaW9UcmFja0NvbnRyb2xsZXIsIG5ldHdvcmtDb250cm9sbGVycyk7XG4gICAgY29uc3QgQXVkaW9TdHJlYW1Db250cm9sbGVyQ2xhc3MgPSBjb25maWcuYXVkaW9TdHJlYW1Db250cm9sbGVyO1xuICAgIGlmIChBdWRpb1N0cmVhbUNvbnRyb2xsZXJDbGFzcykge1xuICAgICAgbmV0d29ya0NvbnRyb2xsZXJzLnB1c2godGhpcy5hdWRpb1N0cmVhbUNvbnRyb2xsZXIgPSBuZXcgQXVkaW9TdHJlYW1Db250cm9sbGVyQ2xhc3ModGhpcywgZnJhZ21lbnRUcmFja2VyLCBrZXlMb2FkZXIpKTtcbiAgICB9XG4gICAgLy8gSW5zdGFudGlhdGUgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgYmVmb3JlIFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlciB0byByZWNlaXZlIGxldmVsIGV2ZW50cyBmaXJzdFxuICAgIHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLmNyZWF0ZUNvbnRyb2xsZXIoY29uZmlnLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyLCBuZXR3b3JrQ29udHJvbGxlcnMpO1xuICAgIGNvbnN0IFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlckNsYXNzID0gY29uZmlnLnN1YnRpdGxlU3RyZWFtQ29udHJvbGxlcjtcbiAgICBpZiAoU3VidGl0bGVTdHJlYW1Db250cm9sbGVyQ2xhc3MpIHtcbiAgICAgIG5ldHdvcmtDb250cm9sbGVycy5wdXNoKHRoaXMuc3VidGl0aXRsZVN0cmVhbUNvbnRyb2xsZXIgPSBuZXcgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyQ2xhc3ModGhpcywgZnJhZ21lbnRUcmFja2VyLCBrZXlMb2FkZXIpKTtcbiAgICB9XG4gICAgdGhpcy5jcmVhdGVDb250cm9sbGVyKGNvbmZpZy50aW1lbGluZUNvbnRyb2xsZXIsIGNvcmVDb21wb25lbnRzKTtcbiAgICBrZXlMb2FkZXIuZW1lQ29udHJvbGxlciA9IHRoaXMuZW1lQ29udHJvbGxlciA9IHRoaXMuY3JlYXRlQ29udHJvbGxlcihjb25maWcuZW1lQ29udHJvbGxlciwgY29yZUNvbXBvbmVudHMpO1xuICAgIHRoaXMuY21jZENvbnRyb2xsZXIgPSB0aGlzLmNyZWF0ZUNvbnRyb2xsZXIoY29uZmlnLmNtY2RDb250cm9sbGVyLCBjb3JlQ29tcG9uZW50cyk7XG4gICAgdGhpcy5sYXRlbmN5Q29udHJvbGxlciA9IHRoaXMuY3JlYXRlQ29udHJvbGxlcihMYXRlbmN5Q29udHJvbGxlciwgY29yZUNvbXBvbmVudHMpO1xuICAgIHRoaXMuY29yZUNvbXBvbmVudHMgPSBjb3JlQ29tcG9uZW50cztcblxuICAgIC8vIEVycm9yIGNvbnRyb2xsZXIgaGFuZGxlcyBlcnJvcnMgYmVmb3JlIGFuZCBhZnRlciBhbGwgb3RoZXIgY29udHJvbGxlcnNcbiAgICAvLyBUaGlzIGxpc3RlbmVyIHdpbGwgYmUgaW52b2tlZCBhZnRlciBhbGwgb3RoZXIgY29udHJvbGxlcnMgZXJyb3IgbGlzdGVuZXJzXG4gICAgbmV0d29ya0NvbnRyb2xsZXJzLnB1c2goZXJyb3JDb250cm9sbGVyKTtcbiAgICBjb25zdCBvbkVycm9yT3V0ID0gZXJyb3JDb250cm9sbGVyLm9uRXJyb3JPdXQ7XG4gICAgaWYgKHR5cGVvZiBvbkVycm9yT3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLm9uKEV2ZW50cy5FUlJPUiwgb25FcnJvck91dCwgZXJyb3JDb250cm9sbGVyKTtcbiAgICB9XG4gICAgLy8gQXV0b3N0YXJ0IGxvYWQgaGFuZGxlclxuICAgIHRoaXMub24oRXZlbnRzLk1BTklGRVNUX0xPQURFRCwgcGxheUxpc3RMb2FkZXIub25NYW5pZmVzdExvYWRlZCwgcGxheUxpc3RMb2FkZXIpO1xuICB9XG4gIGNyZWF0ZUNvbnRyb2xsZXIoQ29udHJvbGxlckNsYXNzLCBjb21wb25lbnRzKSB7XG4gICAgaWYgKENvbnRyb2xsZXJDbGFzcykge1xuICAgICAgY29uc3QgY29udHJvbGxlckluc3RhbmNlID0gbmV3IENvbnRyb2xsZXJDbGFzcyh0aGlzKTtcbiAgICAgIGlmIChjb21wb25lbnRzKSB7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaChjb250cm9sbGVySW5zdGFuY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRyb2xsZXJJbnN0YW5jZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBEZWxlZ2F0ZSB0aGUgRXZlbnRFbWl0dGVyIHRocm91Z2ggdGhlIHB1YmxpYyBBUEkgb2YgSGxzLmpzXG4gIG9uKGV2ZW50LCBsaXN0ZW5lciwgY29udGV4dCA9IHRoaXMpIHtcbiAgICB0aGlzLl9lbWl0dGVyLm9uKGV2ZW50LCBsaXN0ZW5lciwgY29udGV4dCk7XG4gIH1cbiAgb25jZShldmVudCwgbGlzdGVuZXIsIGNvbnRleHQgPSB0aGlzKSB7XG4gICAgdGhpcy5fZW1pdHRlci5vbmNlKGV2ZW50LCBsaXN0ZW5lciwgY29udGV4dCk7XG4gIH1cbiAgcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gICAgdGhpcy5fZW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpO1xuICB9XG4gIG9mZihldmVudCwgbGlzdGVuZXIsIGNvbnRleHQgPSB0aGlzLCBvbmNlKSB7XG4gICAgdGhpcy5fZW1pdHRlci5vZmYoZXZlbnQsIGxpc3RlbmVyLCBjb250ZXh0LCBvbmNlKTtcbiAgfVxuICBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5fZW1pdHRlci5saXN0ZW5lcnMoZXZlbnQpO1xuICB9XG4gIGVtaXQoZXZlbnQsIG5hbWUsIGV2ZW50T2JqZWN0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VtaXR0ZXIuZW1pdChldmVudCwgbmFtZSwgZXZlbnRPYmplY3QpO1xuICB9XG4gIHRyaWdnZXIoZXZlbnQsIGV2ZW50T2JqZWN0KSB7XG4gICAgaWYgKHRoaXMuY29uZmlnLmRlYnVnKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KGV2ZW50LCBldmVudCwgZXZlbnRPYmplY3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KGV2ZW50LCBldmVudCwgZXZlbnRPYmplY3QpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ0FuIGludGVybmFsIGVycm9yIGhhcHBlbmVkIHdoaWxlIGhhbmRsaW5nIGV2ZW50ICcgKyBldmVudCArICcuIEVycm9yIG1lc3NhZ2U6IFwiJyArIGVycm9yLm1lc3NhZ2UgKyAnXCIuIEhlcmUgaXMgYSBzdGFja3RyYWNlOicsIGVycm9yKTtcbiAgICAgICAgLy8gUHJldmVudCByZWN1cnNpb24gaW4gZXJyb3IgZXZlbnQgaGFuZGxlcnMgdGhhdCB0aHJvdyAjNTQ5N1xuICAgICAgICBpZiAoIXRoaXMudHJpZ2dlcmluZ0V4Y2VwdGlvbikge1xuICAgICAgICAgIHRoaXMudHJpZ2dlcmluZ0V4Y2VwdGlvbiA9IHRydWU7XG4gICAgICAgICAgY29uc3QgZmF0YWwgPSBldmVudCA9PT0gRXZlbnRzLkVSUk9SO1xuICAgICAgICAgIHRoaXMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuT1RIRVJfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuSU5URVJOQUxfRVhDRVBUSU9OLFxuICAgICAgICAgICAgZmF0YWwsXG4gICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyaW5nRXhjZXB0aW9uID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5fZW1pdHRlci5saXN0ZW5lckNvdW50KGV2ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwb3NlIG9mIHRoZSBpbnN0YW5jZVxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coJ2Rlc3Ryb3knKTtcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLkRFU1RST1lJTkcsIHVuZGVmaW5lZCk7XG4gICAgdGhpcy5kZXRhY2hNZWRpYSgpO1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fYXV0b0xldmVsQ2FwcGluZyA9IC0xO1xuICAgIHRoaXMuX3VybCA9IG51bGw7XG4gICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMuZm9yRWFjaChjb21wb25lbnQgPT4gY29tcG9uZW50LmRlc3Ryb3koKSk7XG4gICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMubGVuZ3RoID0gMDtcbiAgICB0aGlzLmNvcmVDb21wb25lbnRzLmZvckVhY2goY29tcG9uZW50ID0+IGNvbXBvbmVudC5kZXN0cm95KCkpO1xuICAgIHRoaXMuY29yZUNvbXBvbmVudHMubGVuZ3RoID0gMDtcbiAgICAvLyBSZW1vdmUgYW55IHJlZmVyZW5jZXMgdGhhdCBjb3VsZCBiZSBoZWxkIGluIGNvbmZpZyBvcHRpb25zIG9yIGNhbGxiYWNrc1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGNvbmZpZy54aHJTZXR1cCA9IGNvbmZpZy5mZXRjaFNldHVwID0gdW5kZWZpbmVkO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLnVzZXJDb25maWcgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaGVzIEhscy5qcyB0byBhIG1lZGlhIGVsZW1lbnRcbiAgICovXG4gIGF0dGFjaE1lZGlhKGRhdGEpIHtcbiAgICBpZiAoIWRhdGEgfHwgJ21lZGlhJyBpbiBkYXRhICYmICFkYXRhLm1lZGlhKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgYXR0YWNoTWVkaWEgZmFpbGVkOiBpbnZhbGlkIGFyZ3VtZW50ICgke2RhdGF9KWApO1xuICAgICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQVRUQUNIX01FRElBX0VSUk9SLFxuICAgICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgICAgZXJyb3JcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxvZ2dlci5sb2coYGF0dGFjaE1lZGlhYCk7XG4gICAgaWYgKHRoaXMuX21lZGlhKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKGBtZWRpYSBtdXN0IGJlIGRldGFjaGVkIGJlZm9yZSBhdHRhY2hpbmdgKTtcbiAgICAgIHRoaXMuZGV0YWNoTWVkaWEoKTtcbiAgICB9XG4gICAgY29uc3QgYXR0YWNoTWVkaWFTb3VyY2UgPSAnbWVkaWEnIGluIGRhdGE7XG4gICAgY29uc3QgbWVkaWEgPSBhdHRhY2hNZWRpYVNvdXJjZSA/IGRhdGEubWVkaWEgOiBkYXRhO1xuICAgIGNvbnN0IGF0dGFjaGluZ0RhdGEgPSBhdHRhY2hNZWRpYVNvdXJjZSA/IGRhdGEgOiB7XG4gICAgICBtZWRpYVxuICAgIH07XG4gICAgdGhpcy5fbWVkaWEgPSBtZWRpYTtcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLk1FRElBX0FUVEFDSElORywgYXR0YWNoaW5nRGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogRGV0YWNoIEhscy5qcyBmcm9tIHRoZSBtZWRpYVxuICAgKi9cbiAgZGV0YWNoTWVkaWEoKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nKCdkZXRhY2hNZWRpYScpO1xuICAgIHRoaXMudHJpZ2dlcihFdmVudHMuTUVESUFfREVUQUNISU5HLCB7fSk7XG4gICAgdGhpcy5fbWVkaWEgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGFjaCBIVE1MTWVkaWFFbGVtZW50LCBNZWRpYVNvdXJjZSwgYW5kIFNvdXJjZUJ1ZmZlcnMgd2l0aG91dCByZXNldCwgZm9yIGF0dGFjaGluZyB0byBhbm90aGVyIGluc3RhbmNlXG4gICAqL1xuICB0cmFuc2Zlck1lZGlhKCkge1xuICAgIHRoaXMuX21lZGlhID0gbnVsbDtcbiAgICBjb25zdCB0cmFuc2Zlck1lZGlhID0gdGhpcy5idWZmZXJDb250cm9sbGVyLnRyYW5zZmVyTWVkaWEoKTtcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLk1FRElBX0RFVEFDSElORywge1xuICAgICAgdHJhbnNmZXJNZWRpYVxuICAgIH0pO1xuICAgIHJldHVybiB0cmFuc2Zlck1lZGlhO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc291cmNlIFVSTC4gQ2FuIGJlIHJlbGF0aXZlIG9yIGFic29sdXRlLlxuICAgKi9cbiAgbG9hZFNvdXJjZSh1cmwpIHtcbiAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGNvbnN0IGxvYWRlZFNvdXJjZSA9IHRoaXMuX3VybDtcbiAgICBjb25zdCBsb2FkaW5nU291cmNlID0gdGhpcy5fdXJsID0gdXJsVG9vbGtpdEV4cG9ydHMuYnVpbGRBYnNvbHV0ZVVSTChzZWxmLmxvY2F0aW9uLmhyZWYsIHVybCwge1xuICAgICAgYWx3YXlzTm9ybWFsaXplOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5fYXV0b0xldmVsQ2FwcGluZyA9IC0xO1xuICAgIHRoaXMuX21heEhkY3BMZXZlbCA9IG51bGw7XG4gICAgdGhpcy5sb2dnZXIubG9nKGBsb2FkU291cmNlOiR7bG9hZGluZ1NvdXJjZX1gKTtcbiAgICBpZiAobWVkaWEgJiYgbG9hZGVkU291cmNlICYmIChsb2FkZWRTb3VyY2UgIT09IGxvYWRpbmdTb3VyY2UgfHwgdGhpcy5idWZmZXJDb250cm9sbGVyLmhhc1NvdXJjZVR5cGVzKCkpKSB7XG4gICAgICAvLyBSZW1vdmUgYW5kIHJlLWNyZWF0ZSBNZWRpYVNvdXJjZVxuICAgICAgdGhpcy5kZXRhY2hNZWRpYSgpO1xuICAgICAgdGhpcy5hdHRhY2hNZWRpYShtZWRpYSk7XG4gICAgfVxuICAgIC8vIHdoZW4gYXR0YWNoaW5nIHRvIGEgc291cmNlIFVSTCwgdHJpZ2dlciBhIHBsYXlsaXN0IGxvYWRcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHtcbiAgICAgIHVybDogdXJsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudGx5IGxvYWRlZCBVUkxcbiAgICovXG4gIGdldCB1cmwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VybDtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCBlbm91Z2ggaGFzIGJlZW4gYnVmZmVyZWQgdG8gc2VlayB0byBzdGFydCBwb3NpdGlvbiBvciB1c2UgYG1lZGlhLmN1cnJlbnRUaW1lYCB0byBkZXRlcm1pbmUgbmV4dCBsb2FkIHBvc2l0aW9uXG4gICAqL1xuICBnZXQgaGFzRW5vdWdoVG9TdGFydCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmhhc0Vub3VnaFRvU3RhcnQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzdGFydFBvc2l0aW9uIHNldCBvbiBzdGFydExvYWQocG9zaXRpb24pIG9yIG9uIGF1dG9zdGFydCB3aXRoIGNvbmZpZy5zdGFydFBvc2l0aW9uXG4gICAqL1xuICBnZXQgc3RhcnRQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLnN0YXJ0UG9zaXRpb25WYWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBsb2FkaW5nIGRhdGEgZnJvbSB0aGUgc3RyZWFtIHNvdXJjZS5cbiAgICogRGVwZW5kaW5nIG9uIGRlZmF1bHQgY29uZmlnLCBjbGllbnQgc3RhcnRzIGxvYWRpbmcgYXV0b21hdGljYWxseSB3aGVuIGEgc291cmNlIGlzIHNldC5cbiAgICpcbiAgICogQHBhcmFtIHN0YXJ0UG9zaXRpb24gLSBTZXQgdGhlIHN0YXJ0IHBvc2l0aW9uIHRvIHN0cmVhbSBmcm9tLlxuICAgKiBEZWZhdWx0cyB0byAtMSAoTm9uZTogc3RhcnRzIGZyb20gZWFybGllc3QgcG9pbnQpXG4gICAqL1xuICBzdGFydExvYWQoc3RhcnRQb3NpdGlvbiA9IC0xLCBza2lwU2Vla1RvU3RhcnRQb3NpdGlvbikge1xuICAgIHRoaXMubG9nZ2VyLmxvZyhgc3RhcnRMb2FkKCR7c3RhcnRQb3NpdGlvbiArIChza2lwU2Vla1RvU3RhcnRQb3NpdGlvbiA/ICcsIDxza2lwIHNlZWsgdG8gc3RhcnQ+JyA6ICcnKX0pYCk7XG4gICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICB0aGlzLnJlc3VtZUJ1ZmZlcmluZygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzW2ldLnN0YXJ0TG9hZChzdGFydFBvc2l0aW9uLCBza2lwU2Vla1RvU3RhcnRQb3NpdGlvbik7XG4gICAgICBpZiAoIXRoaXMuc3RhcnRlZCB8fCAhdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgbG9hZGluZyBvZiBhbnkgc3RyZWFtIGRhdGEuXG4gICAqL1xuICBzdG9wTG9hZCgpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coJ3N0b3BMb2FkJyk7XG4gICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm5ldHdvcmtDb250cm9sbGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnNbaV0uc3RvcExvYWQoKTtcbiAgICAgIGlmICh0aGlzLnN0YXJ0ZWQgfHwgIXRoaXMubmV0d29ya0NvbnRyb2xsZXJzKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgbG9hZGluZywgdG9nZ2xlZCB3aXRoIGBzdGFydExvYWQoKWAgYW5kIGBzdG9wTG9hZCgpYCwgaXMgYWN0aXZlIG9yIG5vdGAuXG4gICAqL1xuICBnZXQgbG9hZGluZ0VuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhcnRlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHN0YXRlIG9mIGZyYWdtZW50IGxvYWRpbmcgdG9nZ2xlZCBieSBjYWxsaW5nIGBwYXVzZUJ1ZmZlcmluZygpYCBhbmQgYHJlc3VtZUJ1ZmZlcmluZygpYC5cbiAgICovXG4gIGdldCBidWZmZXJpbmdFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuYnVmZmVyaW5nRW5hYmxlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN1bWVzIHN0cmVhbSBjb250cm9sbGVyIHNlZ21lbnQgbG9hZGluZyBhZnRlciBgcGF1c2VCdWZmZXJpbmdgIGhhcyBiZWVuIGNhbGxlZC5cbiAgICovXG4gIHJlc3VtZUJ1ZmZlcmluZygpIHtcbiAgICBpZiAoIXRoaXMuYnVmZmVyaW5nRW5hYmxlZCkge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKGByZXN1bWUgYnVmZmVyaW5nYCk7XG4gICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycy5mb3JFYWNoKGNvbnRyb2xsZXIgPT4ge1xuICAgICAgICBpZiAoY29udHJvbGxlci5yZXN1bWVCdWZmZXJpbmcpIHtcbiAgICAgICAgICBjb250cm9sbGVyLnJlc3VtZUJ1ZmZlcmluZygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJldmVudHMgc3RyZWFtIGNvbnRyb2xsZXIgZnJvbSBsb2FkaW5nIG5ldyBzZWdtZW50cyB1bnRpbCBgcmVzdW1lQnVmZmVyaW5nYCBpcyBjYWxsZWQuXG4gICAqIFRoaXMgYWxsb3dzIGZvciBtZWRpYSBidWZmZXJpbmcgdG8gYmUgcGF1c2VkIHdpdGhvdXQgaW50ZXJ1cHRpbmcgcGxheWxpc3QgbG9hZGluZy5cbiAgICovXG4gIHBhdXNlQnVmZmVyaW5nKCkge1xuICAgIGlmICh0aGlzLmJ1ZmZlcmluZ0VuYWJsZWQpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhgcGF1c2UgYnVmZmVyaW5nYCk7XG4gICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycy5mb3JFYWNoKGNvbnRyb2xsZXIgPT4ge1xuICAgICAgICBpZiAoY29udHJvbGxlci5wYXVzZUJ1ZmZlcmluZykge1xuICAgICAgICAgIGNvbnRyb2xsZXIucGF1c2VCdWZmZXJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldCBpbkZsaWdodEZyYWdtZW50cygpIHtcbiAgICBjb25zdCBpbkZsaWdodERhdGEgPSB7XG4gICAgICBbUGxheWxpc3RMZXZlbFR5cGUuTUFJTl06IHRoaXMuc3RyZWFtQ29udHJvbGxlci5pbkZsaWdodEZyYWdcbiAgICB9O1xuICAgIGlmICh0aGlzLmF1ZGlvU3RyZWFtQ29udHJvbGxlcikge1xuICAgICAgaW5GbGlnaHREYXRhW1BsYXlsaXN0TGV2ZWxUeXBlLkFVRElPXSA9IHRoaXMuYXVkaW9TdHJlYW1Db250cm9sbGVyLmluRmxpZ2h0RnJhZztcbiAgICB9XG4gICAgaWYgKHRoaXMuc3VidGl0aXRsZVN0cmVhbUNvbnRyb2xsZXIpIHtcbiAgICAgIGluRmxpZ2h0RGF0YVtQbGF5bGlzdExldmVsVHlwZS5TVUJUSVRMRV0gPSB0aGlzLnN1YnRpdGl0bGVTdHJlYW1Db250cm9sbGVyLmluRmxpZ2h0RnJhZztcbiAgICB9XG4gICAgcmV0dXJuIGluRmxpZ2h0RGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTd2FwIHRocm91Z2ggcG9zc2libGUgYXVkaW8gY29kZWNzIGluIHRoZSBzdHJlYW0gKGZvciBleGFtcGxlIHRvIHN3aXRjaCBmcm9tIHN0ZXJlbyB0byA1LjEpXG4gICAqL1xuICBzd2FwQXVkaW9Db2RlYygpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coJ3N3YXBBdWRpb0NvZGVjJyk7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLnN3YXBBdWRpb0NvZGVjKCk7XG4gIH1cblxuICAvKipcbiAgICogV2hlbiB0aGUgbWVkaWEtZWxlbWVudCBmYWlscywgdGhpcyBhbGxvd3MgdG8gZGV0YWNoIGFuZCB0aGVuIHJlLWF0dGFjaCBpdFxuICAgKiBhcyBvbmUgY2FsbCAoY29udmVuaWVuY2UgbWV0aG9kKS5cbiAgICpcbiAgICogQXV0b21hdGljIHJlY292ZXJ5IG9mIG1lZGlhLWVycm9ycyBieSB0aGlzIHByb2Nlc3MgaXMgY29uZmlndXJhYmxlLlxuICAgKi9cbiAgcmVjb3Zlck1lZGlhRXJyb3IoKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nKCdyZWNvdmVyTWVkaWFFcnJvcicpO1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5fbWVkaWE7XG4gICAgY29uc3QgdGltZSA9IG1lZGlhID09IG51bGwgPyB2b2lkIDAgOiBtZWRpYS5jdXJyZW50VGltZTtcbiAgICB0aGlzLmRldGFjaE1lZGlhKCk7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICB0aGlzLmF0dGFjaE1lZGlhKG1lZGlhKTtcbiAgICAgIGlmICh0aW1lKSB7XG4gICAgICAgIHRoaXMuc3RhcnRMb2FkKHRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZW1vdmVMZXZlbChsZXZlbEluZGV4KSB7XG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIucmVtb3ZlTGV2ZWwobGV2ZWxJbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgYSBVVUlEIGZvciB0aGlzIHBsYXllciBpbnN0YW5jZVxuICAgKi9cbiAgZ2V0IHNlc3Npb25JZCgpIHtcbiAgICBsZXQgX3Nlc3Npb25JZCA9IHRoaXMuX3Nlc3Npb25JZDtcbiAgICBpZiAoIV9zZXNzaW9uSWQpIHtcbiAgICAgIF9zZXNzaW9uSWQgPSB0aGlzLl9zZXNzaW9uSWQgPSB1dWlkKCk7XG4gICAgfVxuICAgIHJldHVybiBfc2Vzc2lvbklkO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIGFuIGFycmF5IG9mIGxldmVscyAodmFyaWFudHMpIHNvcnRlZCBieSBIRENQLUxFVkVMLCBSRVNPTFVUSU9OIChoZWlnaHQpLCBGUkFNRS1SQVRFLCBDT0RFQ1MsIFZJREVPLVJBTkdFLCBhbmQgQkFORFdJRFRIXG4gICAqL1xuICBnZXQgbGV2ZWxzKCkge1xuICAgIGNvbnN0IGxldmVscyA9IHRoaXMubGV2ZWxDb250cm9sbGVyLmxldmVscztcbiAgICByZXR1cm4gbGV2ZWxzID8gbGV2ZWxzIDogW107XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgTGV2ZWxEZXRhaWxzIG9mIGxhc3QgbG9hZGVkIGxldmVsICh2YXJpYW50KSBvciBgbnVsbGAgcHJpb3IgdG8gbG9hZGluZyBhIG1lZGlhIHBsYXlsaXN0LlxuICAgKi9cbiAgZ2V0IGxhdGVzdExldmVsRGV0YWlscygpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmdldExldmVsRGV0YWlscygpIHx8IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgTGV2ZWwgb2JqZWN0IG9mIHNlbGVjdGVkIGxldmVsICh2YXJpYW50KSBvciBgbnVsbGAgcHJpb3IgdG8gc2VsZWN0aW5nIGEgbGV2ZWwgb3Igb25jZSB0aGUgbGV2ZWwgaXMgcmVtb3ZlZC5cbiAgICovXG4gIGdldCBsb2FkTGV2ZWxPYmooKSB7XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLmxvYWRMZXZlbE9iajtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRleCBvZiBxdWFsaXR5IGxldmVsICh2YXJpYW50KSBjdXJyZW50bHkgcGxheWVkXG4gICAqL1xuICBnZXQgY3VycmVudExldmVsKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuY3VycmVudExldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBxdWFsaXR5IGxldmVsIGluZGV4IGltbWVkaWF0ZWx5LiBUaGlzIHdpbGwgZmx1c2ggdGhlIGN1cnJlbnQgYnVmZmVyIHRvIHJlcGxhY2UgdGhlIHF1YWxpdHkgYXNhcC4gVGhhdCBtZWFucyBwbGF5YmFjayB3aWxsIGludGVycnVwdCBhdCBsZWFzdCBzaG9ydGx5IHRvIHJlLWJ1ZmZlciBhbmQgcmUtc3luYyBldmVudHVhbGx5LiBTZXQgdG8gLTEgZm9yIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb24uXG4gICAqL1xuICBzZXQgY3VycmVudExldmVsKG5ld0xldmVsKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nKGBzZXQgY3VycmVudExldmVsOiR7bmV3TGV2ZWx9YCk7XG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuaW1tZWRpYXRlTGV2ZWxTd2l0Y2goKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRleCBvZiBuZXh0IHF1YWxpdHkgbGV2ZWwgbG9hZGVkIGFzIHNjaGVkdWxlZCBieSBzdHJlYW0gY29udHJvbGxlci5cbiAgICovXG4gIGdldCBuZXh0TGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHF1YWxpdHkgbGV2ZWwgaW5kZXggZm9yIG5leHQgbG9hZGVkIGRhdGEuXG4gICAqIFRoaXMgd2lsbCBzd2l0Y2ggdGhlIHZpZGVvIHF1YWxpdHkgYXNhcCwgd2l0aG91dCBpbnRlcnJ1cHRpbmcgcGxheWJhY2suXG4gICAqIE1heSBhYm9ydCBjdXJyZW50IGxvYWRpbmcgb2YgZGF0YSwgYW5kIGZsdXNoIHBhcnRzIG9mIGJ1ZmZlciAob3V0c2lkZSBjdXJyZW50bHkgcGxheWVkIGZyYWdtZW50IHJlZ2lvbikuXG4gICAqIEBwYXJhbSBuZXdMZXZlbCAtIFBhc3MgLTEgZm9yIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb25cbiAgICovXG4gIHNldCBuZXh0TGV2ZWwobmV3TGV2ZWwpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coYHNldCBuZXh0TGV2ZWw6JHtuZXdMZXZlbH1gKTtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbCA9IG5ld0xldmVsO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWxTd2l0Y2goKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHF1YWxpdHkgbGV2ZWwgb2YgdGhlIGN1cnJlbnRseSBvciBsYXN0IChvZiBub25lIGlzIGxvYWRlZCBjdXJyZW50bHkpIHNlZ21lbnRcbiAgICovXG4gIGdldCBsb2FkTGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLmxldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBxdWFsaXR5IGxldmVsIGluZGV4IGZvciBuZXh0IGxvYWRlZCBkYXRhIGluIGEgY29uc2VydmF0aXZlIHdheS5cbiAgICogVGhpcyB3aWxsIHN3aXRjaCB0aGUgcXVhbGl0eSB3aXRob3V0IGZsdXNoaW5nLCBidXQgaW50ZXJydXB0IGN1cnJlbnQgbG9hZGluZy5cbiAgICogVGh1cyB0aGUgbW9tZW50IHdoZW4gdGhlIHF1YWxpdHkgc3dpdGNoIHdpbGwgYXBwZWFyIGluIGVmZmVjdCB3aWxsIG9ubHkgYmUgYWZ0ZXIgdGhlIGFscmVhZHkgZXhpc3RpbmcgYnVmZmVyLlxuICAgKiBAcGFyYW0gbmV3TGV2ZWwgLSBQYXNzIC0xIGZvciBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uXG4gICAqL1xuICBzZXQgbG9hZExldmVsKG5ld0xldmVsKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nKGBzZXQgbG9hZExldmVsOiR7bmV3TGV2ZWx9YCk7XG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWwgPSBuZXdMZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgbmV4dCBxdWFsaXR5IGxldmVsIGxvYWRlZFxuICAgKi9cbiAgZ2V0IG5leHRMb2FkTGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLm5leHRMb2FkTGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHF1YWxpdHkgbGV2ZWwgb2YgbmV4dCBsb2FkZWQgc2VnbWVudCBpbiBhIGZ1bGx5IFwibm9uLWRlc3RydWN0aXZlXCIgd2F5LlxuICAgKiBTYW1lIGFzIGBsb2FkTGV2ZWxgIGJ1dCB3aWxsIHdhaXQgZm9yIG5leHQgc3dpdGNoICh1bnRpbCBjdXJyZW50IGxvYWRpbmcgaXMgZG9uZSkuXG4gICAqL1xuICBzZXQgbmV4dExvYWRMZXZlbChsZXZlbCkge1xuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLm5leHRMb2FkTGV2ZWwgPSBsZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gXCJmaXJzdCBsZXZlbFwiOiBsaWtlIGEgZGVmYXVsdCBsZXZlbCwgaWYgbm90IHNldCxcbiAgICogZmFsbHMgYmFjayB0byBpbmRleCBvZiBmaXJzdCBsZXZlbCByZWZlcmVuY2VkIGluIG1hbmlmZXN0XG4gICAqL1xuICBnZXQgZmlyc3RMZXZlbCgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5sZXZlbENvbnRyb2xsZXIuZmlyc3RMZXZlbCwgdGhpcy5taW5BdXRvTGV2ZWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgXCJmaXJzdC1sZXZlbFwiLCBzZWUgZ2V0dGVyLlxuICAgKi9cbiAgc2V0IGZpcnN0TGV2ZWwobmV3TGV2ZWwpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coYHNldCBmaXJzdExldmVsOiR7bmV3TGV2ZWx9YCk7XG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIuZmlyc3RMZXZlbCA9IG5ld0xldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgZGVzaXJlZCBzdGFydCBsZXZlbCBmb3IgdGhlIGZpcnN0IGZyYWdtZW50IHRoYXQgd2lsbCBiZSBsb2FkZWQuXG4gICAqIFRoZSBkZWZhdWx0IHZhbHVlIG9mIC0xIGluZGljYXRlcyBhdXRvbWF0aWMgc3RhcnQgbGV2ZWwgc2VsZWN0aW9uLlxuICAgKiBTZXR0aW5nIGhscy5uZXh0QXV0b0xldmVsIHdpdGhvdXQgc2V0dGluZyBhIHN0YXJ0TGV2ZWwgd2lsbCByZXN1bHQgaW5cbiAgICogdGhlIG5leHRBdXRvTGV2ZWwgdmFsdWUgYmVpbmcgdXNlZCBmb3Igb25lIGZyYWdtZW50IGxvYWQuXG4gICAqL1xuICBnZXQgc3RhcnRMZXZlbCgpIHtcbiAgICBjb25zdCBzdGFydExldmVsID0gdGhpcy5sZXZlbENvbnRyb2xsZXIuc3RhcnRMZXZlbDtcbiAgICBpZiAoc3RhcnRMZXZlbCA9PT0gLTEgJiYgdGhpcy5hYnJDb250cm9sbGVyLmZvcmNlZEF1dG9MZXZlbCA+IC0xKSB7XG4gICAgICByZXR1cm4gdGhpcy5hYnJDb250cm9sbGVyLmZvcmNlZEF1dG9MZXZlbDtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXJ0TGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogc2V0ICBzdGFydCBsZXZlbCAobGV2ZWwgb2YgZmlyc3QgZnJhZ21lbnQgdGhhdCB3aWxsIGJlIHBsYXllZCBiYWNrKVxuICAgKiBpZiBub3Qgb3ZlcnJpZGVkIGJ5IHVzZXIsIGZpcnN0IGxldmVsIGFwcGVhcmluZyBpbiBtYW5pZmVzdCB3aWxsIGJlIHVzZWQgYXMgc3RhcnQgbGV2ZWxcbiAgICogaWYgLTEgOiBhdXRvbWF0aWMgc3RhcnQgbGV2ZWwgc2VsZWN0aW9uLCBwbGF5YmFjayB3aWxsIHN0YXJ0IGZyb20gbGV2ZWwgbWF0Y2hpbmcgZG93bmxvYWQgYmFuZHdpZHRoXG4gICAqIChkZXRlcm1pbmVkIGZyb20gZG93bmxvYWQgb2YgZmlyc3Qgc2VnbWVudClcbiAgICovXG4gIHNldCBzdGFydExldmVsKG5ld0xldmVsKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nKGBzZXQgc3RhcnRMZXZlbDoke25ld0xldmVsfWApO1xuICAgIC8vIGlmIG5vdCBpbiBhdXRvbWF0aWMgc3RhcnQgbGV2ZWwgZGV0ZWN0aW9uLCBlbnN1cmUgc3RhcnRMZXZlbCBpcyBncmVhdGVyIHRoYW4gbWluQXV0b0xldmVsXG4gICAgaWYgKG5ld0xldmVsICE9PSAtMSkge1xuICAgICAgbmV3TGV2ZWwgPSBNYXRoLm1heChuZXdMZXZlbCwgdGhpcy5taW5BdXRvTGV2ZWwpO1xuICAgIH1cbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5zdGFydExldmVsID0gbmV3TGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciBsZXZlbCBjYXBwaW5nIGlzIGVuYWJsZWQuXG4gICAqIERlZmF1bHQgdmFsdWUgaXMgc2V0IHZpYSBgY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplYC5cbiAgICovXG4gIGdldCBjYXBMZXZlbFRvUGxheWVyU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemU7XG4gIH1cblxuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlcyBsZXZlbCBjYXBwaW5nLiBJZiBkaXNhYmxlZCBhZnRlciBwcmV2aW91c2x5IGVuYWJsZWQsIGBuZXh0TGV2ZWxTd2l0Y2hgIHdpbGwgYmUgaW1tZWRpYXRlbHkgY2FsbGVkLlxuICAgKi9cbiAgc2V0IGNhcExldmVsVG9QbGF5ZXJTaXplKHNob3VsZFN0YXJ0Q2FwcGluZykge1xuICAgIGNvbnN0IG5ld0NhcExldmVsVG9QbGF5ZXJTaXplID0gISFzaG91bGRTdGFydENhcHBpbmc7XG4gICAgaWYgKG5ld0NhcExldmVsVG9QbGF5ZXJTaXplICE9PSB0aGlzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSkge1xuICAgICAgaWYgKG5ld0NhcExldmVsVG9QbGF5ZXJTaXplKSB7XG4gICAgICAgIHRoaXMuY2FwTGV2ZWxDb250cm9sbGVyLnN0YXJ0Q2FwcGluZygpOyAvLyBJZiBjYXBwaW5nIG9jY3VycywgbmV4dExldmVsU3dpdGNoIHdpbGwgaGFwcGVuIGJhc2VkIG9uIHNpemUuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNhcExldmVsQ29udHJvbGxlci5zdG9wQ2FwcGluZygpO1xuICAgICAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSAtMTtcbiAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbFN3aXRjaCgpOyAvLyBOb3cgd2UncmUgdW5jYXBwZWQsIGdldCB0aGUgbmV4dCBsZXZlbCBhc2FwLlxuICAgICAgfVxuICAgICAgdGhpcy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemUgPSBuZXdDYXBMZXZlbFRvUGxheWVyU2l6ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FwcGluZy9tYXggbGV2ZWwgdmFsdWUgdGhhdCBzaG91bGQgYmUgdXNlZCBieSBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uIGFsZ29yaXRobSAoYEFCUkNvbnRyb2xsZXJgKVxuICAgKi9cbiAgZ2V0IGF1dG9MZXZlbENhcHBpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F1dG9MZXZlbENhcHBpbmc7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBiYW5kd2lkdGggZXN0aW1hdGUgaW4gYml0cyBwZXIgc2Vjb25kLCB3aGVuIGF2YWlsYWJsZS4gT3RoZXJ3aXNlLCBgTmFOYCBpcyByZXR1cm5lZC5cbiAgICovXG4gIGdldCBiYW5kd2lkdGhFc3RpbWF0ZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBid0VzdGltYXRvclxuICAgIH0gPSB0aGlzLmFickNvbnRyb2xsZXI7XG4gICAgaWYgKCFid0VzdGltYXRvcikge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgcmV0dXJuIGJ3RXN0aW1hdG9yLmdldEVzdGltYXRlKCk7XG4gIH1cbiAgc2V0IGJhbmR3aWR0aEVzdGltYXRlKGFickV3bWFEZWZhdWx0RXN0aW1hdGUpIHtcbiAgICB0aGlzLmFickNvbnRyb2xsZXIucmVzZXRFc3RpbWF0b3IoYWJyRXdtYURlZmF1bHRFc3RpbWF0ZSk7XG4gIH1cbiAgZ2V0IGFickV3bWFEZWZhdWx0RXN0aW1hdGUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgYndFc3RpbWF0b3JcbiAgICB9ID0gdGhpcy5hYnJDb250cm9sbGVyO1xuICAgIGlmICghYndFc3RpbWF0b3IpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIHJldHVybiBid0VzdGltYXRvci5kZWZhdWx0RXN0aW1hdGU7XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHRpbWUgdG8gZmlyc3QgYnl0ZSBlc3RpbWF0ZVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHR0ZmJFc3RpbWF0ZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBid0VzdGltYXRvclxuICAgIH0gPSB0aGlzLmFickNvbnRyb2xsZXI7XG4gICAgaWYgKCFid0VzdGltYXRvcikge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgcmV0dXJuIGJ3RXN0aW1hdG9yLmdldEVzdGltYXRlVFRGQigpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhcHBpbmcvbWF4IGxldmVsIHZhbHVlIHRoYXQgc2hvdWxkIGJlIHVzZWQgYnkgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbiBhbGdvcml0aG0gKGBBQlJDb250cm9sbGVyYClcbiAgICovXG4gIHNldCBhdXRvTGV2ZWxDYXBwaW5nKG5ld0xldmVsKSB7XG4gICAgaWYgKHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgIT09IG5ld0xldmVsKSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coYHNldCBhdXRvTGV2ZWxDYXBwaW5nOiR7bmV3TGV2ZWx9YCk7XG4gICAgICB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nID0gbmV3TGV2ZWw7XG4gICAgICB0aGlzLmxldmVsQ29udHJvbGxlci5jaGVja01heEF1dG9VcGRhdGVkKCk7XG4gICAgfVxuICB9XG4gIGdldCBtYXhIZGNwTGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21heEhkY3BMZXZlbDtcbiAgfVxuICBzZXQgbWF4SGRjcExldmVsKHZhbHVlKSB7XG4gICAgaWYgKGlzSGRjcExldmVsKHZhbHVlKSAmJiB0aGlzLl9tYXhIZGNwTGV2ZWwgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9tYXhIZGNwTGV2ZWwgPSB2YWx1ZTtcbiAgICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLmNoZWNrTWF4QXV0b1VwZGF0ZWQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVHJ1ZSB3aGVuIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb24gZW5hYmxlZFxuICAgKi9cbiAgZ2V0IGF1dG9MZXZlbEVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsID09PSAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMZXZlbCBzZXQgbWFudWFsbHkgKGlmIGFueSlcbiAgICovXG4gIGdldCBtYW51YWxMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogbWluIGxldmVsIHNlbGVjdGFibGUgaW4gYXV0byBtb2RlIGFjY29yZGluZyB0byBjb25maWcubWluQXV0b0JpdHJhdGVcbiAgICovXG4gIGdldCBtaW5BdXRvTGV2ZWwoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWxzLFxuICAgICAgY29uZmlnOiB7XG4gICAgICAgIG1pbkF1dG9CaXRyYXRlXG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFsZXZlbHMpIHJldHVybiAwO1xuICAgIGNvbnN0IGxlbiA9IGxldmVscy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGxldmVsc1tpXS5tYXhCaXRyYXRlID49IG1pbkF1dG9CaXRyYXRlKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBtYXggbGV2ZWwgc2VsZWN0YWJsZSBpbiBhdXRvIG1vZGUgYWNjb3JkaW5nIHRvIGF1dG9MZXZlbENhcHBpbmdcbiAgICovXG4gIGdldCBtYXhBdXRvTGV2ZWwoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWxzLFxuICAgICAgYXV0b0xldmVsQ2FwcGluZyxcbiAgICAgIG1heEhkY3BMZXZlbFxuICAgIH0gPSB0aGlzO1xuICAgIGxldCBtYXhBdXRvTGV2ZWw7XG4gICAgaWYgKGF1dG9MZXZlbENhcHBpbmcgPT09IC0xICYmIGxldmVscyAhPSBudWxsICYmIGxldmVscy5sZW5ndGgpIHtcbiAgICAgIG1heEF1dG9MZXZlbCA9IGxldmVscy5sZW5ndGggLSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXhBdXRvTGV2ZWwgPSBhdXRvTGV2ZWxDYXBwaW5nO1xuICAgIH1cbiAgICBpZiAobWF4SGRjcExldmVsKSB7XG4gICAgICBmb3IgKGxldCBpID0gbWF4QXV0b0xldmVsOyBpLS07KSB7XG4gICAgICAgIGNvbnN0IGhkY3BMZXZlbCA9IGxldmVsc1tpXS5hdHRyc1snSERDUC1MRVZFTCddO1xuICAgICAgICBpZiAoaGRjcExldmVsICYmIGhkY3BMZXZlbCA8PSBtYXhIZGNwTGV2ZWwpIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF4QXV0b0xldmVsO1xuICB9XG4gIGdldCBmaXJzdEF1dG9MZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5hYnJDb250cm9sbGVyLmZpcnN0QXV0b0xldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIG5leHQgYXV0b21hdGljYWxseSBzZWxlY3RlZCBxdWFsaXR5IGxldmVsXG4gICAqL1xuICBnZXQgbmV4dEF1dG9MZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5hYnJDb250cm9sbGVyLm5leHRBdXRvTGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogdGhpcyBzZXR0ZXIgaXMgdXNlZCB0byBmb3JjZSBuZXh0IGF1dG8gbGV2ZWwuXG4gICAqIHRoaXMgaXMgdXNlZnVsIHRvIGZvcmNlIGEgc3dpdGNoIGRvd24gaW4gYXV0byBtb2RlOlxuICAgKiBpbiBjYXNlIG9mIGxvYWQgZXJyb3Igb24gbGV2ZWwgTiwgaGxzLmpzIGNhbiBzZXQgbmV4dEF1dG9MZXZlbCB0byBOLTEgZm9yIGV4YW1wbGUpXG4gICAqIGZvcmNlZCB2YWx1ZSBpcyB2YWxpZCBmb3Igb25lIGZyYWdtZW50LiB1cG9uIHN1Y2Nlc3NmdWwgZnJhZyBsb2FkaW5nIGF0IGZvcmNlZCBsZXZlbCxcbiAgICogdGhpcyB2YWx1ZSB3aWxsIGJlIHJlc2V0dGVkIHRvIC0xIGJ5IEFCUiBjb250cm9sbGVyLlxuICAgKi9cbiAgc2V0IG5leHRBdXRvTGV2ZWwobmV4dExldmVsKSB7XG4gICAgdGhpcy5hYnJDb250cm9sbGVyLm5leHRBdXRvTGV2ZWwgPSBuZXh0TGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHRoZSBkYXRldGltZSB2YWx1ZSByZWxhdGl2ZSB0byBtZWRpYS5jdXJyZW50VGltZSBmb3IgdGhlIGFjdGl2ZSBsZXZlbCBQcm9ncmFtIERhdGUgVGltZSBpZiBwcmVzZW50XG4gICAqL1xuICBnZXQgcGxheWluZ0RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5jdXJyZW50UHJvZ3JhbURhdGVUaW1lO1xuICB9XG4gIGdldCBtYWluRm9yd2FyZEJ1ZmZlckluZm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5nZXRNYWluRndkQnVmZmVySW5mbygpO1xuICB9XG4gIGdldCBtYXhCdWZmZXJMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5tYXhCdWZmZXJMZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogRmluZCBhbmQgc2VsZWN0IHRoZSBiZXN0IG1hdGNoaW5nIGF1ZGlvIHRyYWNrLCBtYWtpbmcgYSBsZXZlbCBzd2l0Y2ggd2hlbiBhIEdyb3VwIGNoYW5nZSBpcyBuZWNlc3NhcnkuXG4gICAqIFVwZGF0ZXMgYGhscy5jb25maWcuYXVkaW9QcmVmZXJlbmNlYC4gUmV0dXJucyB0aGUgc2VsZWN0ZWQgdHJhY2ssIG9yIG51bGwgd2hlbiBubyBtYXRjaGluZyB0cmFjayBpcyBmb3VuZC5cbiAgICovXG4gIHNldEF1ZGlvT3B0aW9uKGF1ZGlvT3B0aW9uKSB7XG4gICAgdmFyIF90aGlzJGF1ZGlvVHJhY2tDb250cjtcbiAgICByZXR1cm4gKChfdGhpcyRhdWRpb1RyYWNrQ29udHIgPSB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkYXVkaW9UcmFja0NvbnRyLnNldEF1ZGlvT3B0aW9uKGF1ZGlvT3B0aW9uKSkgfHwgbnVsbDtcbiAgfVxuICAvKipcbiAgICogRmluZCBhbmQgc2VsZWN0IHRoZSBiZXN0IG1hdGNoaW5nIHN1YnRpdGxlIHRyYWNrLCBtYWtpbmcgYSBsZXZlbCBzd2l0Y2ggd2hlbiBhIEdyb3VwIGNoYW5nZSBpcyBuZWNlc3NhcnkuXG4gICAqIFVwZGF0ZXMgYGhscy5jb25maWcuc3VidGl0bGVQcmVmZXJlbmNlYC4gUmV0dXJucyB0aGUgc2VsZWN0ZWQgdHJhY2ssIG9yIG51bGwgd2hlbiBubyBtYXRjaGluZyB0cmFjayBpcyBmb3VuZC5cbiAgICovXG4gIHNldFN1YnRpdGxlT3B0aW9uKHN1YnRpdGxlT3B0aW9uKSB7XG4gICAgdmFyIF90aGlzJHN1YnRpdGxlVHJhY2tDbztcbiAgICByZXR1cm4gKChfdGhpcyRzdWJ0aXRsZVRyYWNrQ28gPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkc3VidGl0bGVUcmFja0NvLnNldFN1YnRpdGxlT3B0aW9uKHN1YnRpdGxlT3B0aW9uKSkgfHwgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvbXBsZXRlIGxpc3Qgb2YgYXVkaW8gdHJhY2tzIGFjcm9zcyBhbGwgbWVkaWEgZ3JvdXBzXG4gICAqL1xuICBnZXQgYWxsQXVkaW9UcmFja3MoKSB7XG4gICAgY29uc3QgYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAgIHJldHVybiBhdWRpb1RyYWNrQ29udHJvbGxlciA/IGF1ZGlvVHJhY2tDb250cm9sbGVyLmFsbEF1ZGlvVHJhY2tzIDogW107XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsaXN0IG9mIHNlbGVjdGFibGUgYXVkaW8gdHJhY2tzXG4gICAqL1xuICBnZXQgYXVkaW9UcmFja3MoKSB7XG4gICAgY29uc3QgYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAgIHJldHVybiBhdWRpb1RyYWNrQ29udHJvbGxlciA/IGF1ZGlvVHJhY2tDb250cm9sbGVyLmF1ZGlvVHJhY2tzIDogW107XG4gIH1cblxuICAvKipcbiAgICogaW5kZXggb2YgdGhlIHNlbGVjdGVkIGF1ZGlvIHRyYWNrIChpbmRleCBpbiBhdWRpbyB0cmFjayBsaXN0cylcbiAgICovXG4gIGdldCBhdWRpb1RyYWNrKCkge1xuICAgIGNvbnN0IGF1ZGlvVHJhY2tDb250cm9sbGVyID0gdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlcjtcbiAgICByZXR1cm4gYXVkaW9UcmFja0NvbnRyb2xsZXIgPyBhdWRpb1RyYWNrQ29udHJvbGxlci5hdWRpb1RyYWNrIDogLTE7XG4gIH1cblxuICAvKipcbiAgICogc2VsZWN0cyBhbiBhdWRpbyB0cmFjaywgYmFzZWQgb24gaXRzIGluZGV4IGluIGF1ZGlvIHRyYWNrIGxpc3RzXG4gICAqL1xuICBzZXQgYXVkaW9UcmFjayhhdWRpb1RyYWNrSWQpIHtcbiAgICBjb25zdCBhdWRpb1RyYWNrQ29udHJvbGxlciA9IHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXI7XG4gICAgaWYgKGF1ZGlvVHJhY2tDb250cm9sbGVyKSB7XG4gICAgICBhdWRpb1RyYWNrQ29udHJvbGxlci5hdWRpb1RyYWNrID0gYXVkaW9UcmFja0lkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIGNvbXBsZXRlIGxpc3Qgb2Ygc3VidGl0bGUgdHJhY2tzIGFjcm9zcyBhbGwgbWVkaWEgZ3JvdXBzXG4gICAqL1xuICBnZXQgYWxsU3VidGl0bGVUcmFja3MoKSB7XG4gICAgY29uc3Qgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgIHJldHVybiBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA/IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLmFsbFN1YnRpdGxlVHJhY2tzIDogW107XG4gIH1cblxuICAvKipcbiAgICogZ2V0IGFsdGVybmF0ZSBzdWJ0aXRsZSB0cmFja3MgbGlzdCBmcm9tIHBsYXlsaXN0XG4gICAqL1xuICBnZXQgc3VidGl0bGVUcmFja3MoKSB7XG4gICAgY29uc3Qgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgIHJldHVybiBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA/IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlVHJhY2tzIDogW107XG4gIH1cblxuICAvKipcbiAgICogaW5kZXggb2YgdGhlIHNlbGVjdGVkIHN1YnRpdGxlIHRyYWNrIChpbmRleCBpbiBzdWJ0aXRsZSB0cmFjayBsaXN0cylcbiAgICovXG4gIGdldCBzdWJ0aXRsZVRyYWNrKCkge1xuICAgIGNvbnN0IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICByZXR1cm4gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPyBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5zdWJ0aXRsZVRyYWNrIDogLTE7XG4gIH1cbiAgZ2V0IG1lZGlhKCkge1xuICAgIHJldHVybiB0aGlzLl9tZWRpYTtcbiAgfVxuXG4gIC8qKlxuICAgKiBzZWxlY3QgYW4gc3VidGl0bGUgdHJhY2ssIGJhc2VkIG9uIGl0cyBpbmRleCBpbiBzdWJ0aXRsZSB0cmFjayBsaXN0c1xuICAgKi9cbiAgc2V0IHN1YnRpdGxlVHJhY2soc3VidGl0bGVUcmFja0lkKSB7XG4gICAgY29uc3Qgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgIGlmIChzdWJ0aXRsZVRyYWNrQ29udHJvbGxlcikge1xuICAgICAgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVUcmFjayA9IHN1YnRpdGxlVHJhY2tJZDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciBzdWJ0aXRsZSBkaXNwbGF5IGlzIGVuYWJsZWQgb3Igbm90XG4gICAqL1xuICBnZXQgc3VidGl0bGVEaXNwbGF5KCkge1xuICAgIGNvbnN0IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICByZXR1cm4gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPyBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5zdWJ0aXRsZURpc3BsYXkgOiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGUvZGlzYWJsZSBzdWJ0aXRsZSBkaXNwbGF5IHJlbmRlcmluZ1xuICAgKi9cbiAgc2V0IHN1YnRpdGxlRGlzcGxheSh2YWx1ZSkge1xuICAgIGNvbnN0IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICBpZiAoc3VidGl0bGVUcmFja0NvbnRyb2xsZXIpIHtcbiAgICAgIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlRGlzcGxheSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgbW9kZSBmb3IgTG93LUxhdGVuY3kgSExTIGxvYWRpbmdcbiAgICovXG4gIGdldCBsb3dMYXRlbmN5TW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcubG93TGF0ZW5jeU1vZGU7XG4gIH1cblxuICAvKipcbiAgICogRW5hYmxlL2Rpc2FibGUgTG93LUxhdGVuY3kgSExTIHBhcnQgcGxheWxpc3QgYW5kIHNlZ21lbnQgbG9hZGluZywgYW5kIHN0YXJ0IGxpdmUgc3RyZWFtcyBhdCBwbGF5bGlzdCBQQVJULUhPTEQtQkFDSyByYXRoZXIgdGhhbiBIT0xELUJBQ0suXG4gICAqL1xuICBzZXQgbG93TGF0ZW5jeU1vZGUobW9kZSkge1xuICAgIHRoaXMuY29uZmlnLmxvd0xhdGVuY3lNb2RlID0gbW9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQb3NpdGlvbiAoaW4gc2Vjb25kcykgb2YgbGl2ZSBzeW5jIHBvaW50IChpZSBlZGdlIG9mIGxpdmUgcG9zaXRpb24gbWludXMgc2FmZXR5IGRlbGF5IGRlZmluZWQgYnkgYGBgaGxzLmNvbmZpZy5saXZlU3luY0R1cmF0aW9uYGBgKVxuICAgKiBAcmV0dXJucyBudWxsIHByaW9yIHRvIGxvYWRpbmcgbGl2ZSBQbGF5bGlzdFxuICAgKi9cbiAgZ2V0IGxpdmVTeW5jUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIubGl2ZVN5bmNQb3NpdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFc3RpbWF0ZWQgcG9zaXRpb24gKGluIHNlY29uZHMpIG9mIGxpdmUgZWRnZSAoaWUgZWRnZSBvZiBsaXZlIHBsYXlsaXN0IHBsdXMgdGltZSBzeW5jIHBsYXlsaXN0IGFkdmFuY2VkKVxuICAgKiBAcmV0dXJucyAwIGJlZm9yZSBmaXJzdCBwbGF5bGlzdCBpcyBsb2FkZWRcbiAgICovXG4gIGdldCBsYXRlbmN5KCkge1xuICAgIHJldHVybiB0aGlzLmxhdGVuY3lDb250cm9sbGVyLmxhdGVuY3k7XG4gIH1cblxuICAvKipcbiAgICogbWF4aW11bSBkaXN0YW5jZSBmcm9tIHRoZSBlZGdlIGJlZm9yZSB0aGUgcGxheWVyIHNlZWtzIGZvcndhcmQgdG8gYGBgaGxzLmxpdmVTeW5jUG9zaXRpb25gYGBcbiAgICogY29uZmlndXJlZCB1c2luZyBgYGBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnRgYGAgKG11bHRpcGxlIG9mIHRhcmdldCBkdXJhdGlvbikgb3IgYGBgbGl2ZU1heExhdGVuY3lEdXJhdGlvbmBgYFxuICAgKiBAcmV0dXJucyAwIGJlZm9yZSBmaXJzdCBwbGF5bGlzdCBpcyBsb2FkZWRcbiAgICovXG4gIGdldCBtYXhMYXRlbmN5KCkge1xuICAgIHJldHVybiB0aGlzLmxhdGVuY3lDb250cm9sbGVyLm1heExhdGVuY3k7XG4gIH1cblxuICAvKipcbiAgICogdGFyZ2V0IGRpc3RhbmNlIGZyb20gdGhlIGVkZ2UgYXMgY2FsY3VsYXRlZCBieSB0aGUgbGF0ZW5jeSBjb250cm9sbGVyXG4gICAqL1xuICBnZXQgdGFyZ2V0TGF0ZW5jeSgpIHtcbiAgICByZXR1cm4gdGhpcy5sYXRlbmN5Q29udHJvbGxlci50YXJnZXRMYXRlbmN5O1xuICB9XG4gIHNldCB0YXJnZXRMYXRlbmN5KGxhdGVuY3kpIHtcbiAgICB0aGlzLmxhdGVuY3lDb250cm9sbGVyLnRhcmdldExhdGVuY3kgPSBsYXRlbmN5O1xuICB9XG5cbiAgLyoqXG4gICAqIHRoZSByYXRlIGF0IHdoaWNoIHRoZSBlZGdlIG9mIHRoZSBjdXJyZW50IGxpdmUgcGxheWxpc3QgaXMgYWR2YW5jaW5nIG9yIDEgaWYgdGhlcmUgaXMgbm9uZVxuICAgKi9cbiAgZ2V0IGRyaWZ0KCkge1xuICAgIHJldHVybiB0aGlzLmxhdGVuY3lDb250cm9sbGVyLmRyaWZ0O1xuICB9XG5cbiAgLyoqXG4gICAqIHNldCB0byB0cnVlIHdoZW4gc3RhcnRMb2FkIGlzIGNhbGxlZCBiZWZvcmUgTUFOSUZFU1RfUEFSU0VEIGV2ZW50XG4gICAqL1xuICBnZXQgZm9yY2VTdGFydExvYWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5mb3JjZVN0YXJ0TG9hZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb250ZW50U3RlZXJpbmcgcGF0aHdheXMgZ2V0dGVyXG4gICAqL1xuICBnZXQgcGF0aHdheXMoKSB7XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLnBhdGh3YXlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnRlbnRTdGVlcmluZyBwYXRod2F5UHJpb3JpdHkgZ2V0dGVyL3NldHRlclxuICAgKi9cbiAgZ2V0IHBhdGh3YXlQcmlvcml0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIucGF0aHdheVByaW9yaXR5O1xuICB9XG4gIHNldCBwYXRod2F5UHJpb3JpdHkocGF0aHdheVByaW9yaXR5KSB7XG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIucGF0aHdheVByaW9yaXR5ID0gcGF0aHdheVByaW9yaXR5O1xuICB9XG5cbiAgLyoqXG4gICAqIHJldHVybnMgdHJ1ZSB3aGVuIGFsbCBTb3VyY2VCdWZmZXJzIGFyZSBidWZmZXJlZCB0byB0aGUgZW5kXG4gICAqL1xuICBnZXQgYnVmZmVyZWRUb0VuZCgpIHtcbiAgICB2YXIgX3RoaXMkYnVmZmVyQ29udHJvbGxlO1xuICAgIHJldHVybiAhISgoX3RoaXMkYnVmZmVyQ29udHJvbGxlID0gdGhpcy5idWZmZXJDb250cm9sbGVyKSAhPSBudWxsICYmIF90aGlzJGJ1ZmZlckNvbnRyb2xsZS5idWZmZXJlZFRvRW5kKTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZXR1cm5zIEludGVyc3RpdGlhbHMgUHJvZ3JhbSBNYW5hZ2VyXG4gICAqL1xuICBnZXQgaW50ZXJzdGl0aWFsc01hbmFnZXIoKSB7XG4gICAgdmFyIF90aGlzJGludGVyc3RpdGlhbHNDbztcbiAgICByZXR1cm4gKChfdGhpcyRpbnRlcnN0aXRpYWxzQ28gPSB0aGlzLmludGVyc3RpdGlhbHNDb250cm9sbGVyKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkaW50ZXJzdGl0aWFsc0NvLmludGVyc3RpdGlhbHNNYW5hZ2VyKSB8fCBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIHJldHVybnMgbWVkaWFDYXBhYmlsaXRpZXMuZGVjb2RpbmdJbmZvIGZvciBhIHZhcmlhbnQvcmVuZGl0aW9uXG4gICAqL1xuICBnZXRNZWRpYURlY29kaW5nSW5mbyhsZXZlbCwgYXVkaW9UcmFja3MgPSB0aGlzLmFsbEF1ZGlvVHJhY2tzKSB7XG4gICAgY29uc3QgYXVkaW9UcmFja3NCeUdyb3VwID0gZ2V0QXVkaW9UcmFja3NCeUdyb3VwKGF1ZGlvVHJhY2tzKTtcbiAgICByZXR1cm4gZ2V0TWVkaWFEZWNvZGluZ0luZm9Qcm9taXNlKGxldmVsLCBhdWRpb1RyYWNrc0J5R3JvdXAsIG5hdmlnYXRvci5tZWRpYUNhcGFiaWxpdGllcyk7XG4gIH1cbn1cbkhscy5kZWZhdWx0Q29uZmlnID0gdm9pZCAwO1xuXG5leHBvcnQgeyBBYnJDb250cm9sbGVyLCBBdHRyTGlzdCwgQXVkaW9TdHJlYW1Db250cm9sbGVyLCBBdWRpb1RyYWNrQ29udHJvbGxlciwgQmFzZVBsYXlsaXN0Q29udHJvbGxlciwgQmFzZVNlZ21lbnQsIEJhc2VTdHJlYW1Db250cm9sbGVyLCBCdWZmZXJDb250cm9sbGVyLCBDTUNEQ29udHJvbGxlciwgQ2FwTGV2ZWxDb250cm9sbGVyLCBDaHVua01ldGFkYXRhLCBDb250ZW50U3RlZXJpbmdDb250cm9sbGVyLCBDdWVzLCBEYXRlUmFuZ2UsIEVNRUNvbnRyb2xsZXIsIEVycm9yQWN0aW9uRmxhZ3MsIEVycm9yQ29udHJvbGxlciwgRXJyb3JEZXRhaWxzLCBFcnJvclR5cGVzLCBFdmVudHMsIEZQU0NvbnRyb2xsZXIsIEZldGNoTG9hZGVyLCBGcmFnbWVudCwgSGxzLCBIbHNTa2lwLCBIbHNVcmxQYXJhbWV0ZXJzLCBLZXlTeXN0ZW1Gb3JtYXRzLCBLZXlTeXN0ZW1zLCBMZXZlbCwgTGV2ZWxEZXRhaWxzLCBMZXZlbEtleSwgTG9hZFN0YXRzLCBNM1U4UGFyc2VyLCBNZXRhZGF0YVNjaGVtYSwgTmV0d29ya0Vycm9yQWN0aW9uLCBQYXJ0LCBQbGF5bGlzdExldmVsVHlwZSwgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyLCBTdWJ0aXRsZVRyYWNrQ29udHJvbGxlciwgVGltZWxpbmVDb250cm9sbGVyLCBYaHJMb2FkZXIsIEhscyBhcyBkZWZhdWx0LCBmZXRjaFN1cHBvcnRlZCwgZ2V0TWVkaWFTb3VyY2UsIGlzTVNFU3VwcG9ydGVkLCBpc1N1cHBvcnRlZCwgcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1obHMubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/hls.js/dist/hls.mjs\n");

/***/ })

};
;